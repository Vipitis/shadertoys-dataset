{"id": "3t3SD8", "name": "Circle Rectangle Line Play", "author": "crewce", "description": "Circle - rectangle - line play", "tags": ["circle"], "likes": 3, "viewed": 49, "published": "Public", "date": "1634830750", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define EPS 0.07\n#define PI 3.1415926535\n\nfloat distLine(vec2 point, vec2 a, vec2 b) {\n    vec2 pa = point - a;\n    vec2 pb = b - a;\n    float t = dot(pa, pb) / dot(pb, pb);\n    t = clamp(t, 0.0, 1.0);\n    return distance(pa, t * pb);\n}\n\nvec3 line(vec2 point, vec2 a, vec2 b, float thickness, vec3 color) {\n    float dist = distLine(point, a, b);\n    return (1.0 - step(thickness, dist)) * color;\n}\n\nvec3 circle(vec2 point, vec2 center, float r, float thickness, vec3 fillColor, vec3 strokeColor) {\n\tfloat d = length(point - center);\n    float inner = step(r - thickness, d);\n    float outter = step(d, r);\n\tvec3 color = (1.0 - inner) * fillColor + inner * outter * strokeColor;\n\treturn color;\n}\n\nvec3 rectangle(vec2 point, vec2 center, vec2 size, float thickness, vec3 fillColor, vec3 strokeColor) {\n    vec2 po = abs(point - center);\n    vec2 mo = min(max(po, vec2(0.0)), size);\n    vec2 ed = vec2(1.0) - step(size, mo) * step(size - vec2(thickness), mo);\n    vec2 st = vec2(1.0) - step(size - vec2(thickness), mo);\n    return st.x * st.y * fillColor + ed.x * ed.y * strokeColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    uv *= mat2(cos(iTime), sin(iTime), -sin(iTime), cos(iTime));\n    \n    float dist = length(uv);\n      \n    float ang = atan(uv.y,uv.x);\n    float angMapVal = floor(ang / (2.*PI) * 100.);\n    float m1 = mod(angMapVal, 5.0);\n    float m2 = sin(ang * 40.0) * 4.0;\n    float m = mix(m1, m2, mod(iTime, 12.));\n    float modif = EPS + m * 0.010;\n    \n    float r = modif + 0.25 + sin(iTime) * 0.25;\n    float big = smoothstep(r, r - EPS, dist); // * step(r - EPS, dist);\n    \n    // generate final color\n    vec3 col = vec3(1.0, 0.1, 0.7) * big;\n    col += line(uv, vec2(-0.7,  0.3), vec2(0.7, 0.0), 0.0025, vec3(0.9, 0.0, 0.0));\n    col += line(uv, vec2(-0.7,  0.0), vec2(0.7, 0.3), 0.0025, vec3(0.9, 0.0, 0.0));\n    col += line(uv, vec2( 0.0, -0.3), vec2(0.0, 0.4), 0.0025, vec3(0.9, 0.0, 0.0));\n    col += line(uv, vec2(-0.7,  0.1), vec2(0.7, 0.1), 0.0025, vec3(0.9, 0.0, 0.0));\n    col += line(uv, vec2(-0.6, -0.4), vec2(0.2, 0.4), 0.0025, vec3(0.9, 0.0, 0.0));\n    col += line(uv, vec2( 0.4, -0.4), vec2(0.2, 0.4), 0.0025, vec3(0.9, 0.0, 0.0));\n    col += circle(uv, vec2(0.), 0.3, 0.07, vec3(0.0, 0.8, 0.0), vec3(0.0, 0.0, 0.7));\n    col += rectangle(uv, vec2(0.5, 0.3), vec2(0.15, 0.15), 0.05, vec3(0.9, 0.0, 0.0), vec3(0.9, 0.4, 0.2));\n    col += rectangle(uv, vec2(-0.5, -0.4), vec2(0.1, 0.1), 0.03, vec3(1.0, 0.0, 0.4), vec3(0.5, 0.4, 0.2));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t3SD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 42, 86, 86, 236], [238, 238, 306, 306, 398], [400, 400, 498, 498, 695], [697, 697, 800, 800, 1083], [1085, 1085, 1142, 1142, 2624]]}
{"id": "7d3SD2", "name": "FBM play", "author": "henrmota", "description": "fbm", "tags": ["fbm"], "likes": 3, "viewed": 52, "published": "Public", "date": "1633962784", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 5\n\nfloat fbm ( in vec2 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nfloat pattern( in vec2 p )\n{\n    vec2 q = vec2( fbm( p + vec2(0.0,0.0) ),\n                   fbm( p + vec2(5.2,1.3) ) );\n\n    vec2 r = vec2( fbm( p + 4.0*q + vec2(1.7,9.2) ),\n                   fbm( p + 4.0*q + vec2(8.3,2.8) ) );\n\n    return fbm( p + 4.0*r );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = gl_FragCoord.xy/iResolution.xy*3.;\n    vec2 oSt = st;\n    st += fbm(st + 0.2*iTime - distance(st, vec2(0.5)));\n    // st += st * abs(sin(u_time*0.1)*3.0);\n    vec3 color = vec3(0.0);\n\n   \n    float a = fbm(st + 3.*fbm(oSt + vec2(0.2*iTime, 0.)));\n    float b = fbm(st + 3.*fbm(oSt + vec2(a, 0.) ));\n    float c = fbm(st + 3.*fbm(oSt + vec2(b, 0.) ));\n   \n\n \n\n    color = mix(vec3(a*a*a*a, b, c),\n                vec3(196./255., 116./255., 174./255.),\n                a);\n  \n    color = mix(color,\n                vec3(156./255., 116./255., 196./255.),\n                b*b);\n     color = mix(color,\n                vec3(1.),\n                c*c);\n\n    fragColor = vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d3SD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 136], [138, 216, 243, 243, 625], [650, 650, 676, 676, 1014], [1016, 1016, 1044, 1044, 1277], [1279, 1279, 1336, 1336, 2031]]}
{"id": "7d3SDf", "name": "Boxyduck", "author": "eimink", "description": "A simple walking duck. I asked rimina to do a duck during a stream, so I decided to do one myself as well!", "tags": ["sdf", "walking", "duck"], "likes": 5, "viewed": 123, "published": "Public API", "date": "1634063115", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// A very simple duck that's walking.\n// Shoutout to rimina! :)\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvoid rot(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvec2 opU(vec2 d1, vec2 d2)\n{\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\nfloat llength = .4;\nfloat lspread = .4;\nfloat wspeedmod = 4.;\nfloat wstridemod = .2;\n\nstruct MarchResult\n{\n    vec3 p;\n    float id;\n};\n\n\nvec2 sdf(vec3 p){\n   vec3 pp = p;\n\n   pp = pp - vec3(1.+sin(iTime*wspeedmod*2.)*.02,.7,.0);\n   float head = sdBox(pp,vec3(.5,.4,.5));\n   vec3 ppp = pp - vec3(.7,-.1,.0);\n   float beak = sdBox(ppp,vec3(.2,.08,.2));\n   pp.z = abs(pp.z);\n   pp = pp - vec3(.5,.2,.3);\n   float eyes = sdBox(pp,vec3(.1,.1,.1));\n   \n   vec2 h = opU(vec2(eyes,1.0),opU(vec2(beak,2.0),vec2(head,3.0)));\n\n   pp = p;\n   rot(pp.xz,-sin(iTime*wspeedmod)*.1);\n   float body = sdBox(pp,vec3(1.,.6,.8));\n   pp = pp - vec3(-1.1+sin(iTime*wspeedmod*2.)*.02,.7,.0);\n   rot(pp.xz,sin(iTime*wspeedmod)*.1);\n   float tail = sdBox(pp,vec3(.4,.1,.6));\n   body = min(tail,body); \n   vec2 b = opU(vec2(body,3.0),h);\n   \n   pp = p;\n   rot(pp.xy,sin(iTime*wspeedmod)*wstridemod);\n   pp = pp - vec3(0.,-1.,lspread);\n   float lleg = sdBox(pp,vec3(.1,llength,.2));\n   lleg = min(lleg,sdBox(pp-vec3(.2,-llength,.0),vec3(.4,.1,.2)));\n   \n   pp = p;\n   rot(pp.xy,-sin(iTime*wspeedmod)*wstridemod);\n   pp = pp - vec3(0.,-1.,-lspread);\n   float rleg = sdBox(pp,vec3(.1,llength,.2));\n   rleg = min(rleg,sdBox(pp-vec3(.2,-llength,.0),vec3(.4,.1,.2)));\n   float legs = min(lleg,rleg);\n   \n   return opU(vec2(legs,2.0),b);\n\n}\n\nMarchResult march(in vec3 ro, in vec3 rd, inout float t){\n\n    MarchResult m;\n    m.p = ro+rd;\n    for(int i = 0; i < 40; ++i){\n        vec2 d = sdf(m.p);\n        t += d.x;\n        m.p += rd*d.x;\n        m.id = d.y;\n        \n        if(d.x < 0.01 || t > 100.){\n            break;\n        }\n        \n    }\n    \n    return m;\n}\n\nvec3 color(in float id)\n{\n    if (id == 1.0)\n        return vec3(0.1);\n    else if (id == 2.0)\n        return vec3(.8,.3,.2);\n    else if (id == 3.0)\n        return vec3(.8,.7,.4);\n    else\n        return vec3(0);\n}\nvec3 calcNormal( in vec3 pos) \n{\n    vec2 e = vec2(0.00001, 0.0);\n    return normalize( vec3(sdf(pos+e.xyy).x-sdf(pos-e.xyy).x,\n                           sdf(pos+e.yxy).x-sdf(pos-e.yxy).x,\n                           sdf(pos+e.yyx).x-sdf(pos-e.yyx).x ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 cp = vec3(3.,2.0,3.);\n    vec3 ct = vec3(0,0,0);\n    vec3 ld = vec3(-2.,0.5,2.);\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 q = -1.0+2.0*uv;\n    q.x *= iResolution.x/iResolution.y;\n    \n    vec3 cf = normalize(ct-cp);\n    vec3 cr = normalize(cross(vec3(0.0,1.0,0.0),cf));\n    vec3 cu = normalize(cross(cf,cr));\n    \n    vec3 rd = normalize(mat3(cr,cu,cf)*vec3(q,radians(90.0)));\n    \n    vec3 p = vec3(0.0);\n    \n    float t;\n    MarchResult m;\n    m.p = vec3(0.0);\n    m.id = 0.0;\n    m = march(cp,rd,t);\n    \n    vec3 col = vec3(0.0);\n    if(t < 100.){\n        col = color(m.id) + (clamp(dot(calcNormal(m.p), ld), 0.0, 1.0)*0.1);\n        \n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d3SDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 65, 96, 96, 183], [185, 185, 218, 218, 263], [265, 265, 293, 293, 331], [471, 471, 488, 488, 1640], [1642, 1642, 1699, 1699, 1967], [1969, 1969, 1994, 1994, 2184], [2185, 2185, 2217, 2217, 2442], [2444, 2444, 2501, 2501, 3208]]}
{"id": "7d3SDS", "name": "Simplex Skew Experiment", "author": "Yusef28", "description": "Based on the simplex grid introduced here: https://thebookofshaders.com/11/\nThe math is slightly better explained here: https://www.youtube.com/watch?v=dz6fg-Z0JKk&ab_channel=WannesMalfait\nand barryCentric Coordinates are used for the inner triangles", "tags": ["grid", "simplex", "skew"], "likes": 5, "viewed": 168, "published": "Public API", "date": "1633835793", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nvec2 baryCentric(vec2 A, vec2 B, vec2 C, vec2 P){\n    \n    //no needto normalize because equalateral triangles\n    vec2 AB = B-A;\n    vec2 BC = C-B;\n    vec2 CA = A-C;\n    \n    float areaA = length(cross(vec3(AB,0.),vec3(P-A,0.)));\n    float areaB = length(cross(vec3(BC,0.),vec3(P-B,0.)));\n    float areaC = length(cross(vec3(CA,0.),vec3(P-C,0.)));\n    \n    float ret = 0.;\n    \n    \n    float abSplit = abs(areaA-areaB);\n    float bcSplit = abs(areaC-areaB);\n    float caSplit = abs(areaA-areaC);\n    float thick = 0.03;\n    \n    \n    if(areaA < areaB && areaA < areaC) return vec2(1.,\n                                        smoothstep(thick,thick+0.01,caSplit) *\n                                        smoothstep(thick,thick+0.01,abSplit) );\n    if(areaB < areaA && areaB < areaC) return vec2(2.,\n                                        smoothstep(thick,thick+0.01,bcSplit) *\n                                        smoothstep(thick,thick+0.01,abSplit) );\n    \n    if(areaC < areaA && areaC < areaB) return vec2(3.,\n                                        smoothstep(thick,thick+0.01,caSplit) *\n                                        smoothstep(thick,thick+0.01,bcSplit) );\n    \n    \n    \n    \n    \n    //float linesAB = ret != 1. ? smoothstep(0.1,0.2,abSplit)\n       //                       : 0.;\n                 //(smoothstep(0.03,0.08, bcSplit)) *\n                 //(smoothstep(0.03,0.08, caSplit)) ;\n                 \n    //return linesAB;// * (smoothstep(0.03,0.08, bcSplit));\n    //if( abSplit < 0.05 && ret != 3.) return 4.;\n    //if( cbSplit < 0.05 && ret != 1.) return 4.;\n    //if( acSplit < 0.05 && ret != 2.) return 4.;\n\n}\nfloat badHash(vec2 x){\n    return fract(sin(dot(vec2(23.,72.),x)*134.)*43143.);\n}\nmat2 skew = mat2(1.1547, 0., 1.1547/2., 1.);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    uv.x += iTime/4.;\n    uv *= skew;\n  \n    uv *= 6.;\n    \n    float f = 1.-smoothstep(0.47,0.49, abs(fract(uv.x)-0.5) );\n    float g = 1.-smoothstep(0.47,0.49, abs(fract(uv.y)-0.5) );\n    float h = smoothstep(0.02,0.025,abs(fract(uv.y)-fract(uv.x)) );\n    \n    vec2 ff = fract(uv);\n    vec2 id = floor(uv);\n    \n    float side = sign(ff.x-ff.y);\n    float ii = badHash(id + side);\n    \n    \n    vec2 tri = side < 0. ? baryCentric(vec2(0.),vec2(1.),vec2(0.,1.),ff)\n                          : baryCentric(vec2(0.),vec2(1.,0.),vec2(1.,1.),ff);\n    ff = ff*2.-1.;\n    //float ac = abs(length(abs(ff*mat2(0.707,-0.707,0.707,0.707))-0.7)-0.1);\n    //ac = smoothstep(0.05,0.1,ac);\n    // Time varying pixel color\n    vec3 col = vec3( ii - 0.1*(length(ff-vec2(side*0.35,-side*0.35))-0.05) );\n    \n    \n    //col *= ac;\n    if(side < 0.){\n        col = mix(col, vec3(.3,0.1,0.7), step(.5,tri.x));\n        col = mix(col, vec3(.4,0.7,.9), step(1.5,tri.x));\n        col = mix(col, vec3(0.5,0.6,.3), step(2.5,tri.x));\n        col *= tri.y;//= mix(col, vec3(0.), tri);\n        }\n        \n    if(side > 0.){\n        col = mix(col, vec3(.1,0.,0.).xzy, step(.5,tri.x));\n        col = mix(col, vec3(.4,0.,.1).xzy, step(1.5,tri.x));\n        col = mix(col, vec3(0.8,0.,.3).xzy, step(2.5,tri.x));\n        col *= tri.y;//= mix(col, vec3(0.), tri);\n        }\n      col *=g*f*h; \n      col *= 1.2;\n    //col *= ac;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d3SDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 51, 112, 1645], [1646, 1646, 1668, 1668, 1727], [1773, 1773, 1830, 1880, 3391]]}
{"id": "7d3XR2", "name": "Holographic Torus Knot", "author": "Flopine", "description": "Learnign new stuff :D thanks to The Art Of Code youtube channel   <3    https://youtu.be/2dzJZx0yngg\nMotivated by byt3_m3chanic shader https://www.shadertoy.com/view/NstXDM", "tags": ["raymarching", "torus", "palette"], "likes": 19, "viewed": 216, "published": "Public", "date": "1633523186", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan, slerpy, wwrighter \n// BigWings, FabriceNeyret and Blackle for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  \n// https://twitter.com/CookieDemoparty\n\n\n// Based on BigWings tuts ~ https://youtu.be/2dzJZx0yngg\n\n#define PI acos(-1.)\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n#define pal(t,c) (vec3(0.5)+vec3(0.5)*cos(2.*PI*(c*t+vec3(0.,0.5,0.63))))\n#define swi(sp) floor(sin(fract(iTime*sp)*2.*PI))+1.\n\nfloat box2d (vec2 p, vec2 c)\n{\n    vec2 q = abs(p)-c;\n    return min(0.,max(q.x,q.y))+length(max(q,0.));\n}\n\nfloat a;\nfloat torus (vec3 p, vec2 rs)\n{\n    float s = length(p.xz)-rs.x, b = max(abs(p.x),abs(p.z))-rs.x;\n    vec2 cp = mix(vec2(b,p.y),vec2(s,p.y),clamp(swi(0.2),0.,1.));\n    a = atan(p.z,p.x);\n    cp *= rot(a+iTime);\n    cp.y = abs(abs(cp.y)-.6)-.3;\n    \n    float d = box2d(cp,vec2(rs.y,(rs.y+sin(a)/PI)*.35))-0.03;\n    return d;\n}\n\nfloat SDF (vec3 p)\n{\n    p.yz *= rot(-atan(1./sqrt(2.)));\n    p.xz *= rot(PI/4.);\n    \n    return torus(p,vec2(2.5,0.3));\n}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(0.001,0.);\n    return normalize(SDF(p)-vec3(SDF(p-eps.xyy),SDF(p-eps.yxy),SDF(p-eps.yyx)));\n}\n\nfloat spec (vec3 n, vec3 l, vec3 rd)\n{\n    vec3 h = normalize(l-rd);\n    return pow(max(dot(n,h),0.), 25.);\n}\n\nfloat AO (float eps, vec3 p, vec3 n)\n{return SDF(p+eps*n)/eps;}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 ro=vec3(uv*3.5,-30.),rd=vec3(0.,0.,1.),p=ro,\n    col=vec3(0.95,0.9,0.8),l=vec3(1.,2.,-2.);\n\n    bool hit=false;\n    \n    for(float i=0.; i<60.; i++)\n    {\n        float d = SDF(p);\n        if (d<0.01)\n        {\n            hit=true;break;\n        }\n        p += d*rd*0.65;\n    }\n\n    if (hit)\n    {\n        vec3 n = getnorm(p);\n        float light = dot(n,normalize(l))*.5+.5, ao=AO(0.1,p,n)+AO(0.45,p,n)+AO(0.8,p,n);\n        col = mix(vec3(0.,0.,0.2),pal(a/PI,vec3(2.)),light)*ao/3.+spec(n,l,rd);\n    }\n    \n    // Output to screen\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d3XR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[370, 628, 658, 658, 734], [745, 745, 776, 776, 1071], [1073, 1073, 1093, 1093, 1196], [1198, 1198, 1221, 1221, 1335], [1337, 1337, 1375, 1375, 1446], [1448, 1448, 1486, 1486, 1511], [1513, 1513, 1570, 1570, 2210]]}
{"id": "7d3XWN", "name": "23/49", "author": "tono", "description": "49", "tags": ["49"], "likes": 8, "viewed": 65, "published": "Public", "date": "1633131164", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat bo(vec3 p , vec3 s){p = abs(p) - s;return max(p.x,max(p.y,p.z));}\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\nvec3 random33(vec3 st)\n{\n    st = vec3(dot(st,vec3(127.1, 311.7,811.5)),\n                dot(st, vec3(269.5, 183.3,211.91)),\n                dot(st, vec3(511.3, 631.19,431.81))\n                );\n    return -1.0 + 2.0 * fract(sin(st) * 43758.5453123);\n}\n\nfloat norm(vec3 p, float n)\n{\n    vec3 t=pow(abs(p),vec3(n));\n    return pow(t.x+t.y,1./n);\n}\n\nvec4 celler3D(vec3 i,vec3 sepc)\n{\n    float siTime = iTime / 1.5;\n    vec3 sep = i * sepc;\n    vec3 fp = floor(sep);\n    vec3 sp = fract(sep);\n    float dist = 5.;\n    vec3 mp = vec3(0.);\n\tvec3 opos = vec3(0.);\n    \n    for (int z = -1; z <= 1; z++)\n    {\n        for (int y = -1; y <= 1; y++)\n        {\n            for (int x = -1; x <= 1; x++)\n            {\n                vec3 neighbor = vec3(x, y ,z);\n                vec3 rpos = vec3(random33(fp+neighbor));\n                vec3 pos = sin( (rpos*50. +siTime/(230. + 100.*cos(siTime/130.) ) ) ) * 0.5 + 0.5;\n                float shape = 0.5 + clamp(sin(siTime),0.,1.) *30.;\n                float divs = length(neighbor + pos - sp);\n                \n                if(dist > divs)\n                {\n                    opos = neighbor + fp + rpos;\n                    mp   = pos;\n                \tdist = divs;\n                }\n            }\n        }\n    }\n    return vec4(opos,dist);\n}\n\nvec2 map(vec3 p)\n{\n    float o = 10.;\n    float id = 0.;\n    \n    o = length(p + vec3(tan(iTime/5.),sin(iTime),cos(iTime))) - .8;\n    p.xz *= rot(iTime);\n    p.yz *= rot(iTime);\n    float bb = length(p + vec3(0,cos(iTime/3.),0)) - 1.;\n    bb = mix(bo(p + vec3(0.,sin(iTime),0.),vec3(1.) ),bb,clamp(sin(iTime) , -.5,.5) + .5 );\n    o = smin(o,bb,3.);\n    \n    return vec2(o,id);\n}\n\nvec2 march(vec3 cp , vec3 rd)\n{\n    float depth = 0.;\n    for(int i = 0 ; i< 66 ; i++)\n    {\n        vec3 rp = cp + rd * depth;\n        vec2 d = map(rp);\n        if(abs(d.x) < 0.01)\n        {\n            return vec2(depth,d.y);\n        }\n        depth += d.x;\n    }\n    return vec2(-depth , 0.);\n}\n\nvec3 getNormal(vec3 pos)\n{\n    vec2 e = vec2(1.0, -1.0) * 0.005;\n    vec3 N = normalize(\n              e.xyy * map(pos + e.xyy).x +\n              e.yyx * map(pos + e.yyx).x +\n              e.yxy * map(pos + e.yxy).x +\n              e.xxx * map(pos + e.xxx).x);\n    return N;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tvec3 cp = vec3(0.,0.,-6.);\n    vec3 target = vec3(0.);\n    \n    vec3 col = vec3(0.);\n    \n    vec3 cd = normalize(vec3(target - cp));\n    vec3 cs = normalize(cross(cd , vec3(0.,1.,0.)));\n    vec3 cu = normalize(cross(cd,cs));\n    \n    float fov = 2.5;\n    \n    vec3 rd = normalize(cd * fov + cs * p.x + cu * p.y);\n    p = vec2(length(p),acos(p));\n    //vec4 cells = celler3D(vec3(p * rot(iTime + p.x),1.).zxy,vec3(2.3));\n    vec3 rdd = rd;\n    rdd.xz *= rot(iTime/4.);\n    rdd.yz *= rot(iTime/6.);\n    vec4 cells = celler3D(rdd,vec3(3.3));\n    col = cells.xyz * (1.-cells.w);\n    vec3 bg = col;\n    vec2 d = march(cp,rd);\n    if( d.x > 0.)\n    {\n        vec3 pos = cp + rd * d.x;\n        vec4 cell = celler3D(pos,vec3(3.));\n        cell.xyz /= 3.;\n        col = cell.xyz;\n        vec3 N = getNormal(cell.xyz);\n        \n        vec3 sun = normalize(vec3(2.,4.,0.));\n        float diff = max(0.,dot(-sun,N));\n        diff = mix(diff , 1.,.1);\n        float sp = max(0.,dot(rd,reflect(N,sun)));\n        sp = pow(sp,16.) * 1.;\n        float rim = pow(clamp(1. - dot(N, -rd), 0., 1.), 13.);\n        vec3 mat = vec3(0.,1.,1.);\n        \n        vec4 ref = celler3D(reflect(N,sun),vec3(3.3));\n        ref.xyz = ref.xyz * (1.-ref.w);\n        \n        col = sp * ref.xyz + diff * mat + rim;\n        col += cell.xyz/10.;\n        col *= max(ref.xyz,0.);\n        //col = bg;\n    }\n    \n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d3XWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 61], [62, 62, 88, 88, 133], [134, 134, 175, 175, 249], [250, 250, 274, 274, 503], [505, 505, 534, 534, 598], [600, 600, 633, 633, 1543], [1545, 1545, 1563, 1563, 1924], [1926, 1926, 1957, 1957, 2223], [2225, 2225, 2251, 2251, 2501], [2503, 2503, 2560, 2560, 4056]]}
{"id": "7d3Xzl", "name": "Water_shader_sidps", "author": "kingcrimson1112", "description": "A simple water shader using voronoi noise", "tags": ["voronoi", "noise", "water", "worley"], "likes": 1, "viewed": 54, "published": "Public", "date": "1633875999", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//----------------------------------------------------\n// VORONOI_NOISE_GENERATOR\n//----------------------------------------------------\n#define GRID_HEIGHT 10\n\nfloat rand(vec2 pos)\n{\n    return fract(sin(dot(pos, vec2(12.9898f, 78.233f))) * 43758.5453f);\n}\n\nfloat get_voronoi_noise(vec2 pos)\n{\n    float dist=2.0f;\n    for(int y=-1;y<=1;y++)\n    {\n        for(int x=-1;x<=1;x++)\n        {\n            vec2 gridP = vec2(floor(pos.x+float(x)),floor(pos.y+float(y)));\n            vec2 rP = gridP+vec2(rand(gridP),rand(gridP.yx));\n            vec2 offset=vec2(sin(iTime*6.0f*rand(gridP)),cos(iTime*9.0f*rand(gridP.yx)))*0.1f;\n            float dis=distance(pos,rP+offset);\n            if(dis<dist)\n            {\n                dist=dis;\n            }\n        }\n    }\n    return dist/sqrt(2.0f);\n}\n//----------------------------------------------------\n//----------------------------------------------------\nvec3 waterCol=vec3(0.0f,0.44f,0.8f);\nvec3 highlightCol=vec3(0.5f,0.8f,1.0f);\nfloat p=4.5f;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Gets UVs\n    vec2 uv=fragCoord/iResolution.y;\n    uv*=float(GRID_HEIGHT);\n    \n    // Gets Offser\n    vec2 offset=vec2(0.0f);\n    offset.y=-iTime*3.0f;\n    offset.x=cos(iTime*0.5f)*2.0f;\n    \n    // Get Height Map\n    float h=get_voronoi_noise(uv+offset) + get_voronoi_noise(uv+offset*0.4f);\n    h=clamp(h*0.7f,0.0f,1.0f);\n    h=pow(h,p);\n    \n    // Final Color\n    vec3 col=vec3(h)*highlightCol+waterCol;\n   \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d3Xzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 161, 183, 183, 257], [259, 259, 294, 294, 794], [795, 997, 1054, 1070, 1529]]}
{"id": "7d3XzX", "name": "stars stripes and spirals", "author": "HaleyHalcyon", "description": "aa", "tags": ["a"], "likes": 4, "viewed": 42, "published": "Public", "date": "1633757691", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU (6.283185307)\n#define HEX(x) (vec3((x >> 16) & 255, (x >> 8) & 255, x & 255) / 255.)\n#define STRIPECOUNT 14.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float time = fract(iTime / 4.);\n  // Normalized pixel coordinates (from 0 to 1)\n  float scale = min(iResolution.x, iResolution.y);\n  vec2 uv = (gl_FragCoord.xy - 0.50 * iResolution.xy) / scale;\n  \n  float dist = length(uv);\n  float angle = atan(uv.y, uv.x);\n  // for calculating the parity of the stripe\n  float dark = floor(mod(angle * STRIPECOUNT / TAU - 2. * time, 2.));\n  // for calculating the stripes’ angle\n  float stripeAngle = ((0.5) * time * TAU) + (0.5 + floor(angle * STRIPECOUNT / TAU - 2. * time) + 2. * time) * TAU / STRIPECOUNT;\n  vec2 angleVec = vec2(cos(stripeAngle), sin(stripeAngle));\n  // for calculating which palette to use\n  float palette = step(fract(\n      log(dist + 0.01) + angle / TAU + time * 1.\n  ), 0.5);\n  \n  const vec3 col0L = HEX(0x840DaE);\n  const vec3 col1L = HEX(0x3BCEAC);\n  const vec3 col2L = HEX(0xFFD23F);\n  const vec3 col3L = HEX(0xEE4266);\n  \n  const vec3 col0D = HEX(0x118AB2);\n  const vec3 col1D = HEX(0xEF476F);\n  const vec3 col2D = HEX(0xFFD166);\n  const vec3 col3D = HEX(0x06D6A0);\n  \n  vec3 col0 = mix(col0L, col0D, palette);\n  vec3 col1 = mix(col1L, col1D, palette);\n  vec3 col2 = mix(col2L, col2D, palette);\n  vec3 col3 = mix(col3L, col3D, palette);\n  \n  float spiral = fract(\n      0.7 * log(\n          abs(\n              dot(uv, angleVec)\n          ) + 0.02\n      ) * (\n          1.1 - cos(TAU * (0.5 - time))\n      ) + (\n          -12. * time\n      )\n  );\n  \n  vec3 col = mix(\n      mix(\n          col0, col1, step(spiral, 0.75)\n      ), mix(\n          col2, col3, step(spiral, 0.25)\n      ), step(spiral, 0.5)\n  );\n  // Output to screen\n  fragColor = vec4(\n    col, 1.0\n  );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d3XzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[122, 122, 179, 179, 1816]]}
{"id": "7dcSRX", "name": "Swirling Balls", "author": "dr2", "description": "Balls arranged in multiple rotating shells with 60-fold symmetry", "tags": ["symmetry", "pentakis"], "likes": 20, "viewed": 231, "published": "Public API", "date": "1633601929", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Swirling Balls\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Balls arranged in multiple rotating shells with 60-fold symmetry\n// (see \"Pentakis Dodecahedron\" and \"Pentakis Reflections\");\n// only one ball drawn per shell, the (maximal) 60x factor is free.\n\nfloat PrSphDf (vec3 p, float r);\nfloat Maxv3 (vec3 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nvec3 HsvToRgb (vec3 c);\nfloat Fbm2 (vec2 p);\n\nvec3 ltDir;\nfloat tCur, dstFar;\nint idObj;\nconst float pi = 3.1415927;\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nvec3 DodecSym (vec3 p)\n{\n  vec2 csD;\n  csD = sin (0.5 * atan (2.) + vec2 (0.5 * pi, 0.));\n  p.xz = Rot2Cs (vec2 (p.x, abs (p.z)), csD);\n  p.xy = Rot2D (p.xy, - pi / 10.);\n  p.x = - abs (p.x);\n  for (int k = 0; k <= 3; k ++) {\n    p.zy = Rot2Cs (p.zy, vec2 (csD.x, - csD.y));\n    p.y = - abs (p.y);\n    p.zy = Rot2Cs (p.zy, csD);\n    if (k < 3) p.xy = Rot2Cs (p.xy, sin (-2. * pi / 5. + vec2 (0.5 * pi, 0.)));\n  }\n  p.xy = sin (mod (atan (p.x, p.y) + pi / 5., 2. * pi / 5.) - pi / 5. +\n     vec2 (0., 0.5 * pi)) * length (p.xy);\n  p.xz = - vec2 (abs (p.x), p.z);\n  return p;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, r;\n  dMin = dstFar;\n  p.y += 1.2 * sin (0.1 * pi * tCur);\n  p.xz += Rot2D (vec2 (1., 0.), 0.1 * pi * tCur); \n  p.xz = Rot2D (p.xz, 0.05 * pi * tCur);\n  r = 3.3;\n  d = PrSphDf (p, r + 0.2);\n  if (d < 0.1) {\n    for (int k = VAR_ZERO; k < 16; k ++) {\n      r *= 0.92;\n      p.xz = Rot2D (p.xz, 0.43 * pi);\n      p.xy = Rot2D (p.xy, 0.05 * pi * tCur);\n      q = DodecSym (p);\n      q.yz -= vec2 (0.365, -1.) * r;\n      d = PrSphDf (q, 0.05 * sqrt (r));\n      DMIN (1 + k);\n    }\n  } else dMin = d;\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 StarPat (vec3 rd, float scl) \n{\n  vec3 tm, qn, u;\n  vec2 q;\n  float f;\n  tm = -1. / max (abs (rd), 0.0001);\n  qn = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  u = Maxv3 (tm) * rd;\n  q = atan (vec2 (dot (u.zxy, qn), dot (u.yzx, qn)), vec2 (1.)) / pi;\n  f = 0.57 * (Fbm2 (11. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 131.13 * scl * q) +\n      Fbm2 (13. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 171.13 * scl * q.yx));\n  return 8. * vec3 (1., 1., 0.8) * pow (f, 16.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float dstObj;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col = HsvToRgb (vec3 (mod (float (idObj) / 16. + 0.03 * tCur, 1.), 0.5, 1.));\n    col = col * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +\n       0.2 * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.);\n    col *= exp (-0.3 * (dstObj - 17.) / 6.);\n  } else col = StarPat (rd, 12.);\n  return clamp (col, 0., 1.);\n}\n\n#define AA  0   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az -= 0.005 * pi * tCur;\n    el -= 0.1 * pi * sin (0.003 * pi * tCur);\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -20.);\n  zmFac = 4.;\n  dstFar = 50.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dcSRX.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[122, 721, 745, 745, 1296], [1298, 1298, 1320, 1320, 1859], [1861, 1861, 1894, 1894, 2077], [2079, 2079, 2100, 2100, 2355], [2357, 2357, 2393, 2393, 2846], [2848, 2848, 2883, 2883, 3328], [3372, 3372, 3428, 3428, 4472], [4474, 4474, 4507, 4507, 4534], [4536, 4536, 4558, 4558, 4596], [4598, 4598, 4634, 4634, 4840], [4842, 4842, 4872, 4872, 4985], [4987, 4987, 5018, 5018, 5082], [5084, 5084, 5108, 5108, 5225], [5259, 5259, 5283, 5283, 5395], [5397, 5397, 5422, 5422, 5608], [5610, 5610, 5631, 5631, 5786]]}
{"id": "7dcSWX", "name": "入门之路-2", "author": "jialouluo", "description": "在入门一的基础上扩展了一部分。", "tags": [], "likes": 2, "viewed": 113, "published": "Public API", "date": "1634047442", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 getcolor(float ang) {\n    //传入进来的是一个角度值 我们需要将他进行一定的运算来使得他成为我们需要的结果，这里可以根据自己喜好\n        //return 0.6 + 0.4 * cos(ang + vec3(0.5,.7,.2));\n        //return 0.6 + 0.4 * cos(ang + vec3(0.5,.7,.2)  + iTime );//有 iTime\n        //return .5 + .5 * cos(6.28 * (ang + vec3(0., .33, .67)));\n        return .5 + .5 * cos(6.28 * (ang/6.28 + vec3(0., .33, .67)));//6.28 约等于2Π\n    }\nvec2 getCir(float k,float ant,float dis){//注释掉颜色代码 记得将返回值改为float\n/**\n本人也才刚开始学 ，有不对的一些地方或者理解错误的地方，也希望路过的大佬不吝赐教QAQ\n*/\n    float ir = 2.0*fract((iTime*0.2 + k));//内环半径，将半径区间改变为0-2.0\n    float or = 2.2*fract((iTime*0.2 + k));//外环半径，将半径区间改变为0-2.2\n    //解释一下里面的一些数字的含义 2.0 ,2.2已经解释了\n    //0.2代表圆环的扩展速度 可以改变大小观察圆环的扩展速度\n    float c =0.0;\n    \n    if(max(dis,or)==or){\n        c = smoothstep(ant,-ant,dis-or);\n    }\n    if(max(dis,ir)==ir){\n        c = smoothstep(ant,-ant,abs(dis-ir) );\n    }\n     //return c;\n    //下面的代码是赋色代码，与生成环纹无关\n    float a =1.0;\n    if(max(dis,or)==or){//可以与上面的if块合并 这里分出来是为了区分\n        a = (dis-ir)/(or-ir);//这里分母是圆环有色的范围值，分子依靠着dis与内圈半径的差 差越大表示越不应该被隐藏，以此来实现向内圈虚化\n        //如果你有兴趣 不妨将ir改成or，这时会向外圈虚化\n    }\n    else{\n        a =1.0;\n    }\n    \n    return vec2(c,a*c);//返回值这次设置为一个vec2因为我们需要a的值，当然记得给a乘上c(c除开平滑部分值 只有0，1这可以代表着那些地方需要a的颜色)\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 uv = fragCoord/iResolution.xy;\n    //uv-=0.5;\n    //uv.x*=(iResolution.x/iResolution.y);//初始时x轴为0到2y轴为0到1,减去0.5计算之后为x轴-1到1 y轴为-0.5到0.5\n    //在查看其他大佬分享的案例中 有另外一种也可以使得长宽比例为1\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;//我们这次选用这种计算方式来使得uv.x处于-1-->1 uv.y也处于-1-->1\n    float dis = length(uv);\n    //今天我们来实现一种动态的圆环波，类似于往水中仍一块石头之后水面出现的那种波纹(当然目前是二维的 TAT~);\n    //首先让我们先写出生成圆环的代码（具体可以参考我的入门一）\n    //float ir =0.2;//内环半径\n    //float or =0.4;//外环半径\n    //这次我们将上次提到的抗锯齿代码加入进来\n    //float antialias = fwidth(dis);//这里内嵌了一个abs所以antialias是正数，偏导宽的具体定义可以先去搜搜，毕竟定义还是得官方说得更清楚详细\n    //float c =0.0;\n    //if(max(dis,or)==or){\n    //    c = smoothstep(antialias,-antialias,dis-or);\n    //}\n    //if(max(dis,ir)==ir){\n    //    c = smoothstep(antialias,-antialias,abs(dis-ir));\n    //}\n    //这次我改了一下，可以正确的调整内环和外环的半径了\n    //下面我们来尝试去实现环波\n    //初步我们可以看作内环和外环都同时被放大，然后新的圆环被生成然后新圆环的内外环又被放大，如此循环下去\n    //下面我们来尝试一下(需要使用到iTime)\n    //让我们来重写11-21行代码,为了后面的效果，这里我们不妨将他封装为一个函数；\n    //float antialias = fwidth(dis);//偏导宽作为参数传入，与之一起传入的还有距离\n    //float c = getCir(0.0,antialias,dis);//第一个参数类似于偏移量(作用是让圆环在生成时处在不同的位置)\n    //c+= getCir(0.4,antialias,dis);//这里为什么 c要加后面的每一个呢，因为我们fragColor里面依靠c来赋色\n    //c+= getCir(0.8,antialias,dis);//同时，如果当区域1(理解为圆环一)的返回值为1的话并且区域2的返回值1，如果不相加，仅取区域1的返回值\n    //c+= getCir(1.2,antialias,dis);//就会导致c的值仅取决于区域1的值 在区域1里的处在区域2返回值为1的区域会被赋值为0给c\n    //c+= getCir(1.6,antialias,dis);//所以我们需要将两个区域的值进行相加 可以理解为求交集 这样就会让我们每个区域的值被正确得赋值给c\n    //到这里我们已经生成了具有黑白颜色的环纹了，接下来我们需要给他赋色;\n    //让我们试试昨天的颜色代码，看看他会有什么效果，当然这些代码应该被写在函数里，或者根据个人需求作为一个参数传入;\n    //使用 atan(uv.y,uv.x)是常用的求uv角度的方法\n    //float angle  =atan(uv.y,uv.x);\n    //vec3 Color = getcolor(angle);\n    //Color = Color *c;\n    //观察效果 感觉似乎还不错(对于我这个萌新来说~);\n    //接下来 我们为什么不给他旋转起来呢;\n    //Color = Color * fract(angle/6.28 - iTime);\n    //看起来 似乎旋转过一统一了，让我们再给他加点偏移量，重写67行代码\n    //Color = Color * fract(angle/6.28 - iTime *0.1 + cos(dis)  );//这里的0.1控制颜色旋转的速度\n    //就先这样吧，我们来实现另外一种效果，代码在22行之后,并且重写63行之后的代码\n    float antialias = fwidth(dis);//偏导宽作为参数传入，与之一起传入的还有距离\n    vec2 c = getCir(0.0,antialias,dis);//第一个参数类似于偏移量(作用是让圆环在生成时处在不同的位置)\n    c+= getCir(0.4,antialias,dis);//这里为什么 c要加后面的每一个呢，因为我们fragColor里面依靠c来赋色\n    c+= getCir(0.8,antialias,dis);//同时，如果当区域1(理解为圆环一)的返回值为1的话并且区域2的返回值1，如果不相加，仅取区域1的返回值\n    c+= getCir(1.2,antialias,dis);//就会导致c的值仅取决于区域1的值 在区域1里的处在区域2返回值为1的区域会被赋值为0给c\n    c+= getCir(1.6,antialias,dis);//所以我们\n    vec3 Color = vec3(c[1]* 0.3,c[1]* 0.5,c[1] * 0.6)*c[1];\n    fragColor = vec4(Color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dcSWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 380, 475], [476, 476, 517, 699, 1886], [1887, 1887, 1944, 2225, 6243]]}
{"id": "7dcSzl", "name": "fork-e#75741.", "author": "jorge2017a2", "description": "fork", "tags": ["fork"], "likes": 4, "viewed": 56, "published": "Public", "date": "1633703424", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//fork\n//https://glslsandbox.com/e#75716.0\n//https://glslsandbox.com/e#75741.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n\tvec3 Color = vec3(0.1, 0.3, 0.9);\n\tfloat col = -0.2;\n    float col2 = -0.2;\n    \n\tvec2 a = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tfor(float i=0.0;i<50.0;i++)\n\t{\n    \n\t  float si = (sin(iTime + i * 0.05))/0.3;\n\t  float co = acos(cos(iTime + i * 0.5))*0.2;\n      float co2 = ceil(cos(iTime + i * 0.5))*0.2;\n      \n\t  col += 0.01 / abs(length(a+vec2(si*0.5,co))- 0.1);\n      col2 += 0.01 /abs(length(a+vec2(si*1.15,co2-0.5))- 0.1);\n\t}\n\tfragColor = vec4(vec3(Color * col+vec3(0.5,0.0,0.0)*col2), 5.0);\n}   ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dcSzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 80, 137, 137, 677]]}
{"id": "7dcSzX", "name": "Cloudy Crags", "author": "spalmer", "description": "golfing Mountains at dawn by guil", "tags": ["clouds", "mountains", "golf"], "likes": 6, "viewed": 116, "published": "Public", "date": "1634473271", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by S. Guillitte 2021\n// golfed by spalmer\n\n// this is only 555 characters,\n// was 561 before dean_the_coder's helpful suggestions.\n\n// FabriceNeyret2 style\n#define R(a) mat2(cos(a+vec4(0,11,33,0)))\n/* */\n#define S(A,B) += abs(dot(sin(s*p A),B)/s)\n#define N normalize\n\nvoid mainImage(out vec4 c, vec2 q)\n{\n    vec2 r = iResolution.xy;\n    q = (q + q - r)/r.y; // viewport\n\tfloat t = iTime, k = .0015, x;\n    vec3 o = vec3(2);\n    o.xz *= R(.1 * t);    \n    vec3 w = N(-o) // camera\n    //, u = N(cross(w, vec3(0,1,0)))\n    , u = N(vec3(-w.z,0,w.x)) // thx dean_the_coder!\n    , v = N(cross(u, w))\n    , d = N(q.x*u + q.y*v + 4.*w)\n    , a = vec3(0), p;\n    o.x -= .2*t;\n    t = 3.5; // now trace len, skip empty space at start\n    for (int i = 99; i-- > 0; k *= 1.025) {      \n        p = t * d + o;\n        float s = 2., z = 1., e, f;\t// Yonatan combined field\n        for (e = f = p.y; s < 1e2; s *= 1.6)\n            p.xz *= R(s),\n            e S(, vec3(.4)), // fog\n            f S(.xz*.5, vec2(1)); // hill\n        z += f > .001 ? e : -exp(-f*f);\n        x = max(z, 0.);\n        t += 2.5 * k * x * x;\n        a = .95 * a + .07 * x * vec3(x * x, x, 1);\n    }    \n    c = vec4(.5 * log(1. + a), 1); // tonemap\n}\n/* */\n\n// guil's is 948 ch.\n\n/* * /\n// but see Yonatan Mountains revisited https://shadertoy.com/view/ss3Sz2  !! \n// was only 442 and now golfed even more, down to 397 ch\n// still some golfing to be had there!  it doesn't spin the camera.  Has snow?!\nvoid mainImage(out vec4 C, vec2 Q)\n{\n    float o,c,i,e,f,s,g,k=.01;\n    vec2 r = iResolution.xy;\n    float t = iTime;\n    for(o=c=1.;i++<1e2;g+=min(f,max(.03,e))*.7) {\n        s=2.;vec3 p=vec3((Q.xy-r/s)/r.y*g,g-s);\n        p.yz*=R(-.8);\n        p.z+=t;\n        for(e=f=p.y;s<2e2;s/=.6)\n            p.xz*=R(s),\n            e+=abs(dot(sin(p*s)/s,p-p+.3)),\n            f+=abs(dot(sin(p.xz*s*.6)/s,r/r));\n        o+=(f>k*k?e:-exp(-f*f))*o*k;\n    }\n    c+=e;    \n    C = vec4(o);\n    C.rg -= c*.04;    \n}\n/* */\n\n// original tweet https://twitter.com/User2E32/status/1443544969847918593\n// but code in pastebin is gone, try https://gist.github.com/yonatan/f1793265416354f1229a41352d4bb115\n\n/* // saved from gist\n// r = probably screen resolution, o = output color, g = ray depth into the scene\n// FC.xy = which pixel we are on\nfloat i,e,f,s,g,k=.01;\nfor(o++;i++<100;){// go upto 100 steps with the ray\n    s=2.;\n    vec3 p = vec3((FC.xy-r/s)/r.y*g, g-s); // defining ray direction\n    p.yz *= rotate2D(-.8); // rotate the camera/ray downwards\n    p.z += t;// fly forward over time\n    e=f=p.y\n    // compute the terrain height and fog density at this xz coordinate\n    for(;s<200;s*=1.0/0.6){\n        // the position also serves as a source for the seed: higher octaves just use a more-quickly changing noise function\n        p.xz *= rotate2D(s);\n        // generate two random numbers: fog density, and terrain height\n        e+=abs(dot(sin(p*s)/s,p-p+.4));// fog density, because it contains y\n        f+=abs(dot(sin(p.xz*s*.6)/s, vec2(1.0)));// terrain height\n    }\n    o += (f > k*k ? e : -exp(-f*f))*o*k;// when the terrain is hit, add terrain color, otherwise add fog color\n    g += min(f,max(.03,e))*.3 // go deeper, but at max go to the terrain\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dcSzX.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[296, 366, 402, 402, 1310]]}
{"id": "7dcXD2", "name": "Supah wobbles", "author": "supah", "description": "Ripples", "tags": ["waves", "ripples", "wobbles"], "likes": 3, "viewed": 51, "published": "Public", "date": "1633967553", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 R = iResolution.xy,\n         uv = fragCoord/R.xy,\n         st = (fragCoord-.5*R.xy)/R.y;\n    float c = (.5+.5*abs(pow(sin(iTime - length(st) * 10.), 19.))) * .05;\n    st = mix(uv, uv * c, c);\n    fragColor = texture(iChannel0, st) * 1. - c * 6. * (.8 - uv.y);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dcXD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 328]]}
{"id": "7dcXDB", "name": "Hyperbolic tilings: intro", "author": "neozhaoliang", "description": "This is similar to shane's work https://www.shadertoy.com/view/WlBczG but used a different approach", "tags": ["2d", "tiling", "hyperbolic", "poincare"], "likes": 14, "viewed": 305, "published": "Public API", "date": "1633863097", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n    A mimic of shane's work at https://www.shadertoy.com/view/WlBczG.\n    \n    Show the basic procedure to draw a 2d hyperbolic Poincare tiling.\n    \n    Also can draw paracompact and noncompact tilings (with ideal and hyperideal vertices)\n\n*/\n\n// comment out this to see the initial pattern\n#define enableMouseInversion\n\n// change to Klein model\n//#define KleinModel\n\n// set inf = 1.0 for paracompact tiling\n// set inf > 1.0 for noncompact tiling\n#define inf       1.0\n\n#define PI\t\t  3.14159265\n#define TAU\t      6.28318531\n#define MAX_ITER  30\n\n\n// the smaller this value, the larger the black area\n#define BlackRegionSize   0.065\n\n// the first entry in PQR must be finite, other two entries can be either finite or infinite\n// for example (3, inf 4), (3, 4, inf), etc\nconst vec3 PQR = vec3(3, 3, 7);\n\n\n// reflection mirrors\nvec2 A, B;\nvec3 C;\n\n// two vertices of the fundamental triangle, the 3rd one is the origin\nvec2 v0, m0;\n\n// count the number of reflections across each mirror\nfloat count;\n\n\n// compute cos(PI / x), for x = infiniy this is cos(0) = 1.0\nfloat dihedral(float x) { return x == inf ? inf : cos(PI / x); }\n\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\nvoid init() {\n\n    float cAB = dihedral(PQR.x);\n    float sAB = sqrt(1. - cAB*cAB);\n    \n\tA = vec2(1, 0);\n    B = vec2(-cAB, sAB);\n    \n    float cAC = dihedral(PQR.y);\n    float cBC = dihedral(PQR.z);\n    \n    float k1 = cAC;\n    float k2 = (cBC + cAB*cAC) / sAB;\n    float r = 1. / sqrt(k1*k1 + k2*k2 - 1.);\n    \n    C = vec3(k1, k2, 1.)*r;\n    \n    if (r*r >= C.x*C.x)\n        v0 = vec2(0., C.y - sqrt(r*r - C.x*C.x));\n    else\n        v0 = vec2(0, 1);\n        \n    vec2 n = vec2(-B.y, B.x);\n    float b = dot(C.xy, n);\n    float c = dot(C.xy, C.xy) - r*r;\n    float k = -1.0;\n    \n    if (b*b >= c)\n        k = b + sqrt(b*b-c);\n    \n    m0 = k*n;\n}\n\n\nbool try_reflect(inout vec2 p, vec2 mirror, inout float count) {\n    float k = dot(p, mirror);\n    if (k >= 0.)\n        return true;\n    p -= 2. * k  * mirror;\n    count += 1.;\n    return false;\n}\n\n\nbool try_reflect(inout vec2 p, vec3 sphere, inout float count) {\n    vec2 cen = sphere.xy;\n    float r = sphere.z;\n    float d = length(p - cen) - r;\n    if (d >= 0.)\n        return true;\n    p -= cen;\n    p *= r * r/ dot(p, p);\n    p += cen;\n    count += 1.;\n    return false;\n}\n\n\nbool fold(inout vec2 p, inout float count) {\n    count = 0.;\n    for (int k = 0; k < MAX_ITER; k++) {\n        bool cond = true;\n        cond = cond && try_reflect(p, A, count);\n        cond = cond && try_reflect(p, B, count);\n        cond = cond && try_reflect(p, C, count);\n        if (cond)\n            return true;\n    }\n    return false;\n}\n\nfloat sBox(in vec2 p, in vec2 b) {\n    vec2 d = abs(p) - b;\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n\nfloat lBox(vec2 p, vec2 a, vec2 b, float ew) {\n    float ang = atan(b.y - a.y, b.x - a.x);\n    p = rot2(ang)*(p - mix(a, b, .5));\n\n    vec2 l = vec2(length(b - a), ew);\n    return sBox(p, (l + ew)/2.) ;\n}\n\n\nvec2 mouseInversion(vec2 p) {\n    vec2 m = vec2((2.*iMouse.xy - iResolution.xy)/iResolution.y);\n    if(length(m) < 1e-3) m += 1e-3; \n    if(abs(m.x)>.98*.7071 || abs(m.y)>.98*.7071) m *= .98;\n\n    float k = 1./dot(m, m);\n    vec2 invCtr = k*m;\n    float t = (k - 1.)/dot(p -invCtr, p - invCtr);\n    p = t*p + (1. - t)*invCtr;\n    p.x = -p.x;\n    return p;    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    uv *= 1.05;\n    vec2 p = uv;\n    \n#ifdef enableMouseInversion\n    p = mouseInversion(p);\n    p = rot2(iTime/16.)*p;\n#endif\n\n    init();   \n    \n    if(length(p)> 1.)\n        p /= dot(p, p);\n        \n#ifdef KleinModel\n    p = p / (1. + sqrt(1. - dot(p, p)));\n#endif\n  \n    bool found = fold(p, count);\n    \n    float ln = 1e5, ln2 = 1e5, pnt = 1e5;\n    ln = min(ln, lBox(p, vec2(0), v0, .007));    \n    ln = min(ln, lBox(p, vec2(0), m0, .007));\n    ln = min(ln, length(p-C.xy) - C.z - 0.007);\n\n    ln2 = min(ln2, lBox(p, vec2(0), m0, .007));\n    pnt = min(pnt, length(p - v0)); \n    pnt = min(pnt, length(p - m0)); \n    \n    float ssf = (2. - smoothstep(0., .25, abs(length(uv) - 1.) - .25));\n    float sf = 2./iResolution.y*ssf;\n        \n    vec3 oCol = .55 + .45*cos(count*TAU / 8. + vec3(0, 1, 2));\n    float pat = smoothstep(0., .25, abs(fract(ln2*50. - .2) - .5)*2. -.2);\n   \n    float sh = clamp(.65 + ln/v0.y*4., 0., 1.);\n    \n    vec3 col = min(oCol*(pat*.2 + .9)*sh, 1.);\n    \n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, ln));\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, -(ln - BlackRegionSize)));\n\n    pnt -= .032;\n    pnt = min(pnt, length(p) - .032);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, pnt));\n    col = mix(col, vec3(1, .8, .3), 1. - smoothstep(0., sf, pnt + .02));\n    \n    vec3 bg = vec3(1, .2, .4);\n    bg *= .7*(mix(col, vec3(1)*dot(col, vec3(.299, .587, .114)), .5)*.5 + .5);\n    pat = smoothstep(0., .25, abs(fract((uv.x - uv.y)*43. - .25) - .5)*2. -.5);\n    bg *= max(1. - length(uv)*.5, 0.)*(pat*.2 + .9);\n    \n    float cir = length(uv);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*10., abs(cir - 1.) - .05))*.7);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*2., abs(cir - 1.) - .05)));\n    col = mix(col, vec3(.9) + bg, (1. - smoothstep(0., sf, abs(cir - 1.) - .03)));\n    col = mix(col, col*max(1. - length(uv)*.5, 0.), (1. - smoothstep(0., sf, -cir + 1.05)));\n    col = mix(col, bg, (1. - smoothstep(0., sf, -cir + 1.05)));\n    \n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, abs(cir - 1.035) - .03))*.8);\n    col = mix(col, 1. - exp(-col), .35);\n\n    //debug mirrors\n/*\n    col = mix(col, vec3(1, 0, 0), 1. - smoothstep(0., 0.01, abs(dot(uv, A)) - 0.01));\n    col = mix(col, vec3(1, 0, 0), 1. - smoothstep(0., 0.01, abs(dot(uv, B)) - 0.01));\n    col = mix(col, vec3(1, 0, 0), 1. - smoothstep(0., 0.02, abs(length(uv-C.xy) - C.z))-0.01);\n*/\n    fragColor = vec4(sqrt(max(col, 0.)), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dcXDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1004, 1065, 1090, 1090, 1129], [1131, 1131, 1153, 1153, 1211], [1214, 1214, 1227, 1227, 1866], [1869, 1869, 1933, 1933, 2065], [2068, 2068, 2132, 2132, 2347], [2350, 2350, 2394, 2394, 2693], [2695, 2695, 2729, 2729, 2812], [2815, 2815, 2861, 2861, 3019], [3022, 3022, 3051, 3051, 3383], [3386, 3386, 3443, 3443, 5974]]}
{"id": "7ddSDB", "name": "Arrows1", "author": "rudros", "description": "Very small but (hopefully) readable ray-caster", "tags": ["raycasting", "mini"], "likes": 1, "viewed": 58, "published": "Public", "date": "1633975702", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415326\n\nmat2 rotate2D(float r) {\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\n// Distance of point p to ring #ringNum\nfloat distanceTo(vec3 p, float size) {\n//    p.xz = abs(abs(p.xz)-size*2.2)*rotate2D(PI/6.);\n    p.y += size;  // Ring location\n    return length(p-clamp(p,-size,size));\n}\n\n// Closest point of all the rings\nfloat worldSDF(vec3 p) {\n    float minDist = 1.;\n    for(float j=6.; j>0.; j--) { // Number of rings\n        float size = exp(-j);  // Ring size\n        p.xz = abs(abs(p.xz)-size*2.2)*rotate2D(PI/6.); // Mutation affects the following rings, so can't be moved above\n        float curDist = distanceTo(p, size);\n        minDist = min(minDist, curDist); \n    }\n    return minDist;\n}\n\nvec3 cameraMotion(vec3 p) {\n    p.yz *= rotate2D(-0.8);\n    p.xz *= rotate2D(iTime);\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float i;\n    float minDist, eyeDist;\n\n    vec3 eyePos = vec3(0, 0, -1);\n    vec3 ray = vec3((fragCoord.xy-.5*iResolution.xy)/iResolution.x, 1.);\n    ray = normalize(ray);\n\n    // Camera motion\n    eyePos = cameraMotion(eyePos);\n    ray = cameraMotion(ray);\n\n    for(minDist=1.; i<100. && minDist>.001; i++) {  \n        // Point to check\n        vec3 p = eyePos+eyeDist*ray;\n        \n        minDist = worldSDF(p);\n        // Move point forward\n        eyeDist += minDist*.5;\n    }\n    // Adjust steps by current distance to surface to fix banding\n    i += minDist*2000.;\n    fragColor = vec4(0) + 100./(i*i);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ddSDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 46, 46, 98], [100, 140, 178, 232, 311], [313, 347, 371, 371, 727], [729, 729, 756, 756, 829], [831, 831, 888, 888, 1503]]}
{"id": "7ddSW2", "name": "luces", "author": "nictemeral", "description": "shader jugando con varias superposiciones de de color", "tags": ["light", "color", "fract", "id"], "likes": 3, "viewed": 102, "published": "Public API", "date": "1634005663", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                * 43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nvec2 map(vec2 value, vec2 min1, vec2 max1, vec2 min2, vec2 max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nvec3 map(vec2 value, vec3 min1, vec3 max1, vec3 min2, vec3 max2) {\n  return min2 + ((value.s+value.t)/2.0 - min1) * (max2 - min2) / (max1 - min1);\n}\n\n\nvec2 rotate2d(vec2 _st, float _angle){\n  _st -=0.5;\n  _st = mat2(cos(_angle),-sin(_angle),\n    sin(_angle),cos(_angle))*_st;\n    _st +=0.5;\nreturn _st;\n}\n\n#define PI 3.14159235669\n\n#define TAU PI*2\n\n\nvec2 latice_id(in vec2 st,float div){\n    vec2 uv=st;\n    uv*=div;\n    return floor(uv);\n}\nvec2 latice_map(in vec2 st,float div,vec2 min,vec2 max){\n    vec2 uv=st;\n    uv*=div;\n    return map(floor(uv),vec2(0.0),vec2(7.0),vec2(min),vec2(max));\n}\nfloat latice_f(in vec2 st,float div){\n    vec2 uv=st;\n    uv*=div;\n    uv=floor(uv);\n    return (uv.s+uv.t)/2.0;\n}\nfloat lf_map(in vec2 st,float div,float min,float max){\n    vec2 uv=st;\n    uv*=div;\n    uv= map(floor(uv),vec2(0.0),vec2(7.0),vec2(min),vec2(max));\n    return (uv.s+uv.t)/2.0;\n}\nfloat lf_cmap(in vec2 st,float div,float min,float max){\n    vec2 uv=st-vec2(.50);\n    uv*=div;\n    uv=abs(uv);\n    uv=floor(uv)/div;\n    uv= map(uv,vec2(0.0),vec2(1.0),vec2(min),vec2(max));\n    return (uv.s+uv.t);\n}\nfloat lf(in vec2 st,float div,float min,float max){\n    vec2 uv=st-vec2(.50);\n    uv*=div;\n    uv=abs(uv);\n    uv=floor(uv)/div;\n    return (uv.s+uv.t);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st = fragCoord/iResolution.xy;\n\n  // st.x *= iResolution.x/iResolution.y;\n   vec2 uv=st;\n   vec2 st2=st;\n    st*=7.0;\n    st.s+=abs(sin(iTime*-0.1));\n    \n    vec2 ipos = floor(st);  // get the integer coords\n    vec2 fpos = fract(st);  // get the fractional coords\n\n    \n\n    st2=uv;\n   vec3  color = vec3(lf_cmap(vec2(st2.s,st2.t),50.,.25,0.75));\n    color.r+= lf_cmap(vec2(st2.s,-1.*st2.t+sin(iTime*.5)*01.5+01.5),15.,.0,0.5)/2.;\n    color.g+= lf_cmap(vec2(-1.*st2.s,st2.t+cos(iTime*.25+1.)*0.7+0.7),9.,.0,0.5)/3.;\n   color.b+= lf_cmap(vec2(st2.s,-1.*st2.t+sin(iTime*.5+sin(iTime*.5))*01.5+01.5),12.,.0,0.5)/2.;\n   // color.g+= lf_cmap(vec2(-1.*st2.s,st2.t+cos(u_time*.25+1.)*0.7+0.7),8.,.0,0.5)/3.;\n\n    \n    \n    //para recortar areas puede ser util\n   // color=clamp(color,vec3(0.675,0.675,0.675),vec3(0.450*abs(cos(u_time*0.01))+.90));\n     //color-=0.5;\n\tfragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ddSW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 29, 29, 145], [147, 225, 251, 251, 631], [634, 634, 706, 706, 772], [774, 774, 840, 840, 906], [908, 908, 974, 974, 1056], [1059, 1059, 1097, 1097, 1212], [1259, 1259, 1296, 1296, 1349], [1350, 1350, 1406, 1406, 1504], [1505, 1505, 1542, 1542, 1619], [1620, 1620, 1675, 1675, 1798], [1799, 1799, 1855, 1855, 2015], [2016, 2016, 2067, 2067, 2170], [2171, 2171, 2228, 2278, 3181]]}
{"id": "7ddSWB", "name": "Byte Patten 2", "author": "foxic", "description": "Byte Patten 2", "tags": ["bytepatten2"], "likes": 0, "viewed": 51, "published": "Public API", "date": "1633897498", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TileSize 8.\n\nvec2 rotate2D(vec2 _st,float _angle){\n    //_st-=.5;\n    _st=mat2(cos(_angle),-sin(_angle),\n    sin(_angle),cos(_angle))*_st;\n    //_st+=.5;\n    return _st;\n}\n\nfloat random(in float x){\n    return fract(sin(x)*43758.5453);\n}\n\n\nbool patten(in vec2 uv){\n    ivec2 uvs = ivec2(uv*TileSize);\n    uvs.x = (uvs.x+10000)%3;\n    \n    int byte = int( random(float(uvs.y))*7. );\n    return ((byte >> uvs.x)&1) == 0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){   \n    vec2 uv = ((2.0*fragCoord-iResolution.xy)/iResolution.y);\n\n    uv.y +=1.;\n    //uv = vec2( atan(uv.x ,uv.y)*0.159, length(uv)*0.25 );\n    uv.y += iTime*0.1;\n    \n    uv = rotate2D(uv,-0.7853);\n    float b = float(patten(uv));\n    b = max( b, float(!patten(uv+0.05))*0.0625 );\n    b = mix( b, 0.5,0.2);\n    \n    vec2 q = fragCoord / iResolution.xy;\n    \n    b *= b+0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.5)*3.;\n    b = clamp(b,0.,1.);\n    fragColor = vec4(vec3(b),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ddSWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 58, 73, 179], [181, 181, 206, 206, 245], [248, 248, 272, 272, 428], [430, 430, 486, 486, 968]]}
{"id": "7ddSWl", "name": "Color Value Noise", "author": "theschwa", "description": "Value color noise", "tags": ["noise"], "likes": 0, "viewed": 85, "published": "Public API", "date": "1634186691", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvec3 pos2col ( vec2 ipos ) {\n\n    ipos += vec2(9.,0.); // Just moved to pick some nice colors\n    \n    float r = random( ipos + vec2( 12., 2. ) );\n    float g = random( ipos + vec2(7., 5. ) );\n    float b = random( ipos );\n\n    \n    vec3 col = vec3(r,g,b);\n    return col;\n}\n\nvec3 colorNoise ( vec2 st ) {\n    vec2 ipos = floor( st );\n    vec2 fpos = fract( st );\n\n    \n    // Four corners in 2D of a tile\n    vec3 a = pos2col(ipos);\n    vec3 b = pos2col(ipos + vec2(1.0, 0.0));\n    vec3 c = pos2col(ipos + vec2(0.0, 1.0));\n    vec3 d = pos2col(ipos + vec2(1.0, 1.0));\n    \n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = fpos*fpos*(3.0-2.0*fpos);\n    // u = smoothstep(0.,1.,fpos);\n    \n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st = gl_FragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n    vec2 uv = st;\n    \n    float scale = 2.*abs(iTime/15. - floor(iTime/15. + .5) )*50.;\n    st *= scale;\n    \n    vec3 col = colorNoise( st );\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ddSWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 131], [133, 133, 161, 161, 407], [409, 409, 438, 438, 973], [975, 975, 1032, 1082, 1375]]}
{"id": "7ddXRs", "name": "Fractal 87_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 16, "viewed": 197, "published": "Public", "date": "1633780868", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    vec3 p,r=iResolution,c=vec3(0),\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));\n    float i=0.,s,e,g=0.;\n    for(;++i<99.;)\n    {\n        p=g*d;\n        p.z+=iTime*.8;\n        p=R(p,vec3(.577),.3);\n        s=2.;\n        p=cos(p);\n        for(int i=0;i++<7;)\n        {\n            p=1.8-abs(p-1.2);\n            p=p.x<p.y?p.zxy:p.zyx;\n            s*=e=4.5/min(dot(p,p),1.5);\n            p=p*e-vec3(.2,3,4);\n        }\n        g+=e=length(p.xz)/s;\n        c+=mix(vec3(1),H(log(s*5.)),.3)*.01*exp(-9./i/i/e);\n    }\n    c*=c;\n    O=vec4(c,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ddXRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 142, 142, 679]]}
{"id": "7dGXRt", "name": "Plotting Functions", "author": "droidkid", "description": "fun with trig functions in shadertoy", "tags": ["maths"], "likes": 1, "viewed": 114, "published": "Public API", "date": "1635182524", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 plot(float dist, vec3 color, float thickness) {\n    return color * (smoothstep(-thickness, 0.0, dist) - smoothstep(0.0, thickness, dist));\n} \n\nvec3 y_axis(vec2 uv) {\n    float dist = (uv.x - 0.5);\n    return plot(dist, vec3(1.0, 1.0, 0.0), 0.002);\n}\n\nvec3 x_axis(vec2 uv) {\n    float dist = (uv.y - 0.5);\n    return plot(dist, vec3(1.0, 1.0, 0.0), 0.003);\n}\n\nvec3 yx_line(vec2 uv) {\n    vec2 point = uv - 0.5;\n    float dist = abs(point.x - point.y);\n    return plot(dist, vec3(0.0, 1.0, 0.0), 0.003);\n}\n\nvec3 sin_line(vec2 uv) {\n    vec2 point = uv - 0.5;\n    float val = 0.4 * sin(iTime) * sin(point.x * 3.14 * 5. + iTime*2.);\n    float dist = abs(val - point.y);\n    return plot(dist, vec3(1.0, 0.0, 0.0), 0.02);\n}\n\nvec3 cos_line(vec2 uv) {\n    vec2 point = uv - 0.5;\n    float val = 0.3 * cos(iTime) * cos(point.x * 3.14 * 5. + iTime*5.);\n    float dist = abs(val - point.y);\n    return plot(dist, vec3(1.0, 0.0, 1.0), 0.02);\n}\n\nvec3 tan_line(vec2 uv) {\n    vec2 point = uv - 0.5;\n    float val = 0.3 * cos(iTime) * tan(point.x * 3.14 * 5. + iTime*4.);\n    float dist = abs(val - point.y);\n    return plot(dist, vec3(1.0, 1.0, 0.0), 0.02);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //vec4 yaxis_color = vec4(y_axis(uv), 1.0);\n    //vec4 xaxis_color = vec4(x_axis(uv), 1.0);\n    //vec4 yx_color = vec4(yx_line(uv), 1.0);\n    vec4 sin_color = vec4(sin_line(uv), 1.0);\n    vec4 cos_color = vec4(cos_line(uv), 1.0);\n    vec4 tan_color = vec4(tan_line(uv), 1.0);\n\n\n    //fragColor = vec4(max(yaxis_color, xaxis_color));\n    //fragColor = vec4(max(fragColor, yx_color));\n    fragColor = vec4(max(fragColor, sin_color));\n    fragColor = vec4(max(fragColor, cos_color));\n    fragColor = vec4(max(fragColor, tan_color));\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dGXRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 145], [148, 148, 170, 170, 254], [256, 256, 278, 278, 362], [364, 364, 387, 387, 508], [510, 510, 534, 534, 722], [724, 724, 748, 748, 936], [938, 938, 962, 962, 1150], [1153, 1153, 1210, 1260, 1846]]}
{"id": "7dGXzz", "name": "Metaballs - MrNissenDK", "author": "MrNissenDK", "description": "Metaballs inspired by https://www.youtube.com/watch?v=ccYLb7cLB1I\nJust wanted to do something today", "tags": ["metaballs", "colors"], "likes": 4, "viewed": 188, "published": "Public API", "date": "1634243531", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/***************************************\n  *              Settings              *\n  ***************************************/\n  \nfloat res = 15.; // how many sqrs along the x axes\nfloat seed = 429496.7295;\nbool debug = false;\nfloat timeSpeed = 0.1;\nint balls = 20;\nfloat ballSize = 5.;\n\n/***************************************\n  *          Define Variables          *\n  ***************************************/\n  \nfloat pixelSize = 0.0;\nfloat time = 0.;\n\n\n/***************************************\n  *               Random               *\n  ***************************************/\n\nfloat random (vec2 st) {\n    return\n        fract(\n                sin( \n                    dot(\n                         st.xy\n                        ,vec2(12.9898,78.233)\n                    )\n                )\n            *seed\n            +seed\n        );\n}\n\n/***************************************\n  *               Lerp                 *\n  ***************************************/\nfloat lerp(float f1, float f2, float t)\n{\n\treturn (f1 + t * (f2-f1));\n}\n\nvec2 lerp(vec2 v1, vec2 v2, float t){\n\treturn (v1 + t * (v2-v1));\n}\nvec2 initPos(int id){\n    return vec2(\n        random(vec2(id)),\n        random(vec2(id + 313))\n    ) * res * 2. - res;\n}\n\n/***************************************\n  *                Mod                 *\n  ***************************************/\n  \nint modInt(int i, int j){\n    return int(mod(float(i),float(j)));\n}\n\n/***************************************\n  *             Main Code              *\n  ***************************************/\nvec2 pos(int id){\n    //float time = iTime / 10.;\n    int first = id + int(time) * 3;\n    int second = first + 1;\n    int third = first + 2;\n    int forth = first + 3;\n    \n    vec2 pos1 = initPos(first);\n    vec2 pos2 = initPos(second);\n    vec2 pos3 = initPos(third);\n    vec2 pos4 = initPos(forth);\n    \n    float t =  fract(time);\n    \n    vec2 lerp1 = lerp(pos1, pos2, t);\n    vec2 lerp2 = lerp(pos3, pos4, t);\n    \n    return lerp(lerp1, lerp2, t);\n}\n\nvec3 randomCol(int id){\n    return vec3(\n        random(vec2(id)),\n        random(vec2(id + 513)),\n        random(vec2(id + 541313))\n    );\n}\n\nfloat cirkle(vec2 uv,vec2 pos, float size)\n{\n    float dist = length(uv - pos);\n    float m = smoothstep(size, .01, dist);\n    \n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime * timeSpeed;\n    vec2 uv = ((fragCoord - .5 * iResolution.xy) / (iResolution.x/res));\n    pixelSize = res / iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = vec3(0);\n    for(int i = 0; i < balls; i++){\n        int id = i * 500;\n        vec3 addCol = \n             randomCol(id)\n            *vec3(\n                cirkle(\n                     uv\n                    ,pos(id)\n                    ,ballSize\n                )\n            );\n        col += addCol;\n        \n        if(debug){\n            id += int(time) * 3;\n            float id1 = .1/length(uv - initPos(id + 0));\n            float id2 = .1/length(uv - initPos(id + 1));\n            float id3 = .1/length(uv - initPos(id + 2));\n            float id4 = .1/length(uv - initPos(id + 3));\n\n            col += vec3(id1, 0, 0);\n            col += vec3(0, id2, 0);\n            col += vec3(0, 0, id3);\n            col += vec3(id4);\n        }\n    }\n    if( debug && (\n        fract(uv.x) <= pixelSize || fract(uv.x) >= 1.-pixelSize || \n        fract(uv.y) <= pixelSize || fract(uv.y) >= 1.-pixelSize)\n    ) col.r = 1.;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dGXzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[456, 582, 606, 606, 845], [847, 972, 1013, 1013, 1043], [1045, 1045, 1082, 1082, 1112], [1113, 1113, 1134, 1134, 1234], [1236, 1364, 1389, 1389, 1431], [1433, 1558, 1575, 1607, 2014], [2016, 2016, 2039, 2039, 2157], [2159, 2159, 2203, 2203, 2302], [2304, 2304, 2361, 2361, 3528]]}
{"id": "7dKSWt", "name": "Mod Test 2", "author": "Livie", "description": "mod test 2", "tags": ["mod"], "likes": 0, "viewed": 14, "published": "Public", "date": "1635543918", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float CLOSE_ENOUGH = 0.001;\nconst float RENDER_DISTANCE = 30.0;\n\nconst vec3 BG_COLOR = vec3(90., 10., 90.)/255.;\nconst vec3 SHADOW_COLOR = vec3(30., 10., 80.)/255.;\nconst vec3 COLOR = vec3(30., 150., 250.)/255.;\n\nstruct sphere {\n\tvec3 c;\n    float r;\n};\n\nfloat sphereDist(vec3 p, sphere s) {\n\treturn distance(p, s.c) - s.r;\n}\n\n//from iq : https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat opSmoothUnion( float d1, float d2, float k )  {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat sdf(vec3 p) {\n    float returnVal = .0;\n    \n    vec3 rep = vec3(1., 0., 2.);\n\tvec3 pr = mod(p, rep) - .5 * rep; \n        \n    sphere s1 = sphere(vec3(sin(iTime*4.)*.0, sin(iTime*3.)*0.25-0.5, 0.5), 0.1-0.3*sin(iTime));\n    sphere s2 = sphere(vec3(0., sin(iTime*2.)*.8-0.8, 0.5), 0.1);\n    sphere s3 = sphere(vec3(0., sin(iTime*1.)*1.-0.8, 0.5), 0.3*sin(iTime));\n    \n    vec3 b = vec3(1.5, 0.01, 3.);\n    vec3 q = abs(pr + vec3(.5,1.,-2.)) - b;\n    float b1 = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    \n    float smoothness = .2;\n    returnVal = opSmoothUnion(b1, sphereDist(pr,s1), smoothness); \n    returnVal = opSmoothUnion(returnVal, sphereDist(pr,s2), smoothness); \n    returnVal = opSmoothUnion(returnVal, sphereDist(pr,s3), smoothness);    \n\treturn returnVal; \n}\n\n// from iq https://www.iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 p ) {\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*sdf( p + k.xyy*CLOSE_ENOUGH ) + \n                      k.yyx*sdf( p + k.yyx*CLOSE_ENOUGH ) + \n                      k.yxy*sdf( p + k.yxy*CLOSE_ENOUGH ) + \n                      k.xxx*sdf( p + k.xxx*CLOSE_ENOUGH ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n\tvec2 uv    = fragCoord.xy / iResolution.xy - vec2(0.5);\n         uv.x *= iResolution.x / iResolution.y;\n\tvec3 cameraPos = vec3(.0,0.0,-iTime*0.1);\n    \n    // Time varying pixel color\n    vec3 ro = vec3(cameraPos.x + uv.x, cameraPos.y + uv.y, cameraPos.z);\n\tvec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n    vec3 col = BG_COLOR * (1. - uv.y);\n    float dist = .0;\n       \n    vec3 lightDir = normalize(vec3(sin(iTime*0.125), sin(iTime*0.25), -1.0));\n\n    while(dist < RENDER_DISTANCE)\n    {\n        float d = sdf(ro + rd * dist);\n        if(d < CLOSE_ENOUGH)\n        {\n            vec3 hit = ro + rd * dist;\n            col = COLOR; \n            col *= mix(SHADOW_COLOR, col, max(dot(calcNormal(hit), lightDir), .0));\n            col = col;\n            break;\n        }\n        dist += d;\n    }\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dKSWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[261, 261, 297, 297, 331], [333, 417, 470, 470, 570], [572, 572, 591, 591, 1363], [1365, 1442, 1472, 1472, 1749], [1751, 1751, 1808, 1858, 2712]]}
{"id": "7dKXDD", "name": "Floating Green Circles", "author": "LoganLang", "description": "Floating Green Circles", "tags": ["2d", "pattern"], "likes": 8, "viewed": 50, "published": "Public", "date": "1634694837", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3 keyLime = vec3(236., 243., 158.)/255.;\nconst vec3 olivine = vec3(144., 169., 85.)/255.;\nconst vec3 sapGreen = vec3(79., 119., 45.)/255.;\nconst vec3 hunterGreen = vec3(49., 87., 44.)/255.;\n\nfloat sdCircle(vec2 st, float r){ \nreturn length(st) - r; \n} \n\nfloat stroke(float x, float w, float s){ \n    w *= .5; \n    return 1.-smoothstep(w-s,w+s,abs(x)); \n} \n\nfloat fill(float sdf,float s){\n    return 1.-smoothstep(-s,s,sdf);\n}\n\nvec3 draw(vec3 col, vec3 addCol, vec2 uv, float mult){\n    uv *= mult;\n    uv.x += iTime;\n    uv.y += (iTime*.01*mult) * step(1.,mod(uv.x,2.));\n    uv.y -= (iTime*.01*mult) * (1.-step(1.,mod(uv.x,2.)));\n    uv = fract(uv);\n    col = mix(col,vec3(.05),fill(sdCircle(uv-.5,.2),.04));\n    col = mix(col,addCol,stroke(sdCircle(uv-.5,.15),.1,.0015*mult));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 col = hunterGreen;\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n\n    col = draw(col, keyLime, uv, 10.);\n    col = draw(col, olivine, uv, 5.5);\n    col = draw(col, sapGreen, uv, 3.5);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dKXDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[200, 200, 233, 233, 260], [263, 263, 303, 303, 363], [366, 366, 396, 396, 434], [436, 436, 490, 490, 804], [806, 806, 862, 862, 1124]]}
{"id": "7dKXDR", "name": "newton memes", "author": "pema99", "description": "you should play vrchat, it's a good game", "tags": ["newton"], "likes": 3, "viewed": 150, "published": "Public API", "date": "1634499178", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// operations on complex numbers\nvec2 cmul(vec2 a, vec2 b)\n{\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvec2 conjugate(vec2 a)\n{\n    return vec2(a.x, -a.y);\n}\n\nvec2 cdiv(vec2 a, vec2 b)\n{\n    return cmul(a, conjugate(b)) / (b.x * b.x + b.y * b.y);\n}\n\nvec2 cpow(vec2 a, int e)\n{\n    vec2 res = a;\n    for (int i = 1; i < e; i++)\n    {\n        res = cmul(res, a);\n    }\n    return res;\n}\n\n// 4th degree polynomial with no constant term\nvec2 f(vec2 a, vec2 r[4])\n{\n    vec2 res = vec2(0.);\n    for (int i = 0; i < 4; i++)\n    {\n        res += cpow(cmul(r[i], a), 4-i);\n    }\n    return res;\n}\n\n// derivative\nvec2 df(vec2 a, vec2 r[4])\n{\n    vec2 res = vec2(0.);\n    for (int i = 0; i < 4; i++)\n    {\n        res += float(4-i) * cpow(cmul(r[i], a), 4-i-1);\n    }\n    return res;\n}\n\n// newton-raphson\nvec2 newton(vec2 guess, vec2 r[4])\n{\n    for (int i = 0; i < 30; i++)\n    {\n        guess = guess - cdiv(f(guess, r), df(guess, r));\n    }\n    return guess;\n}\n\nvec3 hs(vec3 Color, float Shift)\n{\n    vec3 P = vec3(0.55735, 0.55735, 0.55735)*dot(vec3(0.55735, 0.55735, 0.55735),Color);\n    vec3 U = Color-P;\n    vec3 V = cross(vec3(0.55735, 0.55735, 0.55735),U);\n    Color = U*cos(Shift*6.2832) + V*sin(Shift*6.2832) + P;\n    return Color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0*((fragCoord/iResolution.xy)-0.5);\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec2 r[4];\n    for (int i = 0; i < 4; i++)\n    {\n        r[i] = vec2(cos(float(i)*6.28*0.25 +3.14*0.5), sin(float(i)*6.28*0.25 +3.14*0.5));\n    }\n    r[0].x = sin(iTime)*0.7;\n    r[2].x = sin(-iTime)*0.7;\n    r[1] += vec2(cos(iTime*0.5), sin(iTime*0.5))*0.2;\n    r[3] -= vec2(cos(iTime*0.5), sin(iTime*0.5))*0.2;\n    vec2 guess = newton(uv, r);\n    \n    float minDist = distance(guess, r[0]);\n    vec2 minNum = r[0];\n    for (int i = 1; i < 4; i++)\n    {\n        float dist = distance(guess, r[i]);\n        if (dist < minDist)\n        {\n            minNum = r[i];\n            minDist = dist;\n        }\n    }\n\n    fragColor = vec4(hs(hs(vec3(1., 0., 0.), log(abs(guess.x))/5.), log(abs(guess.y))/5.), 1.);\n    \n    // Debug\n    /*for (int i = 0; i < 4; i++)\n    {\n        if (distance(r[i], uv) < 0.05)\n        {\n            fragColor = vec4(0.);\n        }\n    }*/\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dKXDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 33, 60, 60, 125], [127, 127, 151, 151, 181], [183, 183, 210, 210, 272], [274, 274, 300, 300, 408], [410, 457, 484, 484, 612], [614, 628, 656, 656, 799], [801, 819, 855, 855, 977], [979, 979, 1013, 1013, 1258], [1260, 1260, 1317, 1317, 2283]]}
{"id": "7dKXDW", "name": "Color Experiment 001", "author": "darknoon", "description": "some casual triangles", "tags": ["color"], "likes": 2, "viewed": 150, "published": "Public API", "date": "1634678539", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// via iq\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n\nvec3 c0 = vec3(0.63, 0.5, 0.5);\nvec3 c1 = vec3(0.7, 0.8, 0.5);\nvec3 c2 = vec3(0.1, 0.1, 0.7);\n\n\nconst float PI = 3.14159;\n\nfloat saturate(float x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nfloat sinc( float x, float k )\n{\n    float a = PI*(k*x)+PI;\n    return saturate(sin(a) / x);\n}\n\n// cite https://www.shadertoy.com/view/XlXcW4\nvec3 hash( uvec3 x )\n{\n  const uint k = 1103515245U;  // GLIB C\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\n\nmat2 rotation(float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\treturn mat2(c, -s, s, c);\n}\n    \n\nvoid mainImage( out vec4 result, in vec2 fragCoord )\n{\n    \n    result.rgb = c2 * 0.5;\n    \n    float tile = 18.0;\n    float sharp = 2.0 / iResolution.x * tile;\n    \n\n    // iterate neighbors\n    for (int i=-2; i<=2; i++) {\n    for (int j=-2; j<=2; j++) {\n        vec2 uv = fragCoord/iResolution.xy * vec2(1.0, iResolution.y / iResolution.x);\n\n        // get grid id of current object\n        ivec2 id = ivec2(floor(uv*tile) + vec2(i,j));\n        vec2 idf = vec2(id) / tile;\n\n        uv = fract(uv * tile);\n        // account for coord in neighborhood\n        uv -= vec2(i,j);\n\n\n        vec2 tri = vec2(0.6, 0.8 + 0.5*sin(iTime));\n        float rndg = 0.1234;\n\n        // TODO: rotation matrix!\n\n        // offset even rows\n        float off = id.y % 2 == 0 ? 1.0/3.0 : 0.0;\n        // tile\n        vec2 ctr = 0.5 + vec2(off, 0.0);\n        float r = 0.125;\n        \n        uv = rotation(PI / 4.0 + sin(idf.x + iTime)) * (uv - 0.5);\n        \n        //float dist = length(uv-ctr) - r;\n        float dist = sdTriangleIsosceles(uv + vec2(off, 0.0), tri) - rndg;\n        \n        \n\n        float a = sinc(dist * 22.0, 2.0);\n        float a_ = 1.0 - a;\n        \n        vec3 col = id.x % 2 == 0 ? c0 : c1;\n        vec3 other = mix(hash(uvec3(id.xyx)), c2, 0.7);\n        col = mix(col, other, 1.0 - 2.0*idf.y);\n\n        // source-over\n        result.rgb = result.rgb * a_ + col.rgb * a;\n        result.a   = result.a * a_ + a;\n    }}\n\n    // Output to screen\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dKXDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 11, 62, 62, 370], [496, 496, 521, 521, 554], [556, 556, 588, 588, 650], [652, 698, 720, 720, 894], [897, 897, 921, 921, 988], [995, 995, 1049, 1049, 2450]]}
{"id": "7dKXzV", "name": "spirograph rosette", "author": "pwf", "description": "tried to implement stuff from https://www.youtube.com/watch?v=n-e9C8g5x68", "tags": ["spirograph"], "likes": 0, "viewed": 40, "published": "Public", "date": "1634962154", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Radius of the first circle, scales the whole image.\nfloat R = 40.;\n// Ratio of the radius of the first circle to the second\nfloat k = 1.;\n// Ratio of the radius of the first circle to the third\nfloat k2 = 2.01;\n// Distance to the drawing point\nfloat h = 1.;\n// Ratio of the paths\nfloat p = 0.5;\n\nfloat coolX(float R, float r, float r2, float h, float p, float t) {\n    return (R + r) * cos(t) \n            + (r + r2) * cos(t + (R*t)/r - R*t/(p*r))\n            + h * cos(t + R*t/r - R*t/(p*r) - R*t/(p*r2));\n}\n\nfloat coolY(float R, float r, float r2, float h, float p, float t) {\n    return (R + r) * sin(t)\n            + (r + r2) * sin(t + (R*t)/r - R*t/(p*r))\n            + h * sin(t + R*t/r - R*t/(p*r) - R*t/(p*r2));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // x = (R + r) * np.cos(t) \n    //   + (r + r2) * np.cos(t + (R*t)/r - R*t/(p*r))\n    //   + h * np.cos(t + R*t/r - R*t/(p*r) - R*t/(p*r2))\n    // y = (R + r) * np.sin(t)\n    //   + (r + r2) * np.sin(t + (R*t)/r - R*t/(p*r))\n    //   + h * np.sin(t + R*t/r - R*t/(p*r) - R*t/(p*r2))\n    \n    \n    //vec2 muv = (iMouse.xy/iResolution.xy - .5) * 2.;\n    \n    h = sin((iTime+100.)/50.)*2.;\n    p = cos((iTime+100.)/100.)*2.;\n    \n    \n    float r = R/k;\n    float r2 = R/k2;\n    \n    //float t = iTime;\n    \n    // Normalized pixel coordinates (from -1.0 to 1.0)\n    vec2 uv = (fragCoord/iResolution.xy - .5) * 2. * 300.;\n    \n    // Initialize the Color\n    vec3 color  = vec3(0.0);\n    // Initialize the Coordinates\n    //vec2 coord = fragCoord;\n\n    float num_points = 300.;\n    for (float t = 0.0; t < num_points; t+=.1) {\n        vec2 xy = vec2(\n            coolX(R, r, r2, h, p, t),\n            coolY(R, r, r2, h, p, t)\n        );\n           \n        float dist = distance(uv, xy);\n        //fragColor = vec4(float(dist<.5));\n        fragColor += vec4(mix(1.0, 0.0, smoothstep(0.1, 1., dist)));\n    }\n\n    //fragColor = vec4(vec3(dist<1.), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dKXzV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[262, 300, 368, 368, 512], [514, 514, 582, 582, 725], [727, 727, 784, 1136, 1938]]}
{"id": "7dtXW7", "name": "Fractal 85_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 9, "viewed": 141, "published": "Public", "date": "1633382994", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\n\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));\n    float i=0.,g=0.,e,s,h,a;\n    for(;++i<99.;)\n    {\n        p=g*d;\n        p.z+=iTime*2.;\n        p=sin(p);\n        p=R(p,vec3(.577),iTime*.5);\n        p=abs(p)-1.5;\n        p=p.x<p.y?p.zxy:p.zyx;\n        p=p.x<p.y?p.zxy:p.zyx;\n        s=2.;\n        for(int i=0;i++<8;){\n          s*=e=2./clamp(dot(p,p),.3,1.2);\n          p=abs(p)*e-vec3(.8,8,.8);\n        }\n        a=1.;\n        p-=clamp(p,-a,a);\n        g+=e=length(p)/s;\n        O.rgb+=(H(log(s)*.5)+.5)*.01*exp(-.2*i*i*e);\n    }\n    O=pow(O,vec4(3));\n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dtXW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 107, 143, 143, 737]]}
{"id": "7dtXzX", "name": "land pac-JFP", "author": "jorge2017a2", "description": "land pac-JFP", "tags": ["ealandpacjfp"], "likes": 5, "viewed": 123, "published": "Public API", "date": "1633653648", "time_retrieved": "2021-10-01T00:00:00", "image_code": "///earth pac-JFP\n///por jorge2017a2...2021-oct-07\n///referencia\n//https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(antialiasing(0.05),b,d)\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n///---------------------------\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n    \nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  //colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.05,0.0));\n  return colOut;\n}\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\nreturn colOut;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdOrientedBox( in vec2 p, in vec2 a, in vec2 b, float th )\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\nfloat sdVesica(vec2 p, float r, float d)\n{\n    p = abs(p);\n    float b = sqrt(r*r-d*d);\n    return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))\n                             : length(p-vec2(-d,0.0))-r;\n}\n\nvec3 ondamar(vec2 p, vec3 col)\n{   vec2 q=p;\n    q.y-= 0.5;\n    q.y -= 0.8*sin(q.x*0.8);\n    col=DrawFig(vec3(0.0,0.8,0.0), col, abs(q.y)-4.0 );\n return col;\n}    \n\nvec3 Suelo0(vec2 p, vec3 col)\n{   vec2 q=p;\n    q.y+= 2.5;\n    col=DrawFig(vec3(0.85,0.58,0.0), col, abs(q.y)-4.5 );\n return col;\n}\n\nvec3 Suelo1(vec2 p, vec3 col)\n{   vec2 q=p;\n    q.y-= 0.5;\n    col=DrawFig(vec3(0.75,0.35,0.2)-p.y*0.15, col, abs(q.y)-1.5 );\n return col;\n}\n\nvec3 Suelo2(vec2 p, vec3 col)\n{   vec2 q=p;\n    q.y-= 0.5;\n    col=DrawFig(vec3(0.85,0.45,0.2), col, abs(q.y)-1.5 );\n return col;\n}  \n\nvec3 ramas(vec2 p, vec3 col, float escal)\n{\n   float d1= sdCircle(p- vec2(0.0,2.5), 1.5 );\n   float d2= sdCircle(p- vec2(2.0,3.5), 1.5 );\n   float d3= sdCircle(p- vec2(-2.0,4.0), 1.5 );\n   float d4= sdCircle(p- vec2(0.0,5.0), 1.5 );   \n   col=DrawFig(vec3(0.0,0.7,0.0)*escal, col, d1 );\n   col=DrawFig(vec3(0.0,0.7,0.0)*escal, col, d2 );\n   col=DrawFig(vec3(0.0,0.7,0.0)*escal, col, d3 );\n   col=DrawFig(vec3(0.0,0.7,0.0)*escal, col, d4 );\n   \n   return col;\n}\n\nvec3 Arbol(vec2 pp , vec3 col, float escal)\n{    vec2 p=pp;\n     float d1= sdBox(p, vec2(0.5,2.0) );\n     float d2=sdOrientedBox(p-vec2(0.0,-2.5), vec2(0.0), vec2(0.0,1.0), 0.5 );\n     p.x=abs(p.x)+0.2;\n     float d3=sdOrientedBox(p-vec2(0.0,-1.5), vec2(0.0,0.0), vec2(1.0,-0.8), 0.5 );\n     \n     col=DrawFig(vec3(0.45,0.15,0.0)*escal, col, d1);\n     col=DrawFig(vec3(0.45,0.15,0.0)*escal, col, d2);\n     col=DrawFig(vec3(0.45,0.15,0.0)*escal, col, d3);\n     p=pp;\n     col= ramas(p, col,escal);\n return col;\n}  \n\nvec3 Tronco(vec2 pp , vec3 col, float escal)\n{    vec2 p=pp;\n     float d1= sdBox(p, vec2(0.5,2.0) );\n     float d2=sdOrientedBox(p-vec2(0.0,-2.5), vec2(0.0), vec2(0.0,1.0), 0.5 );\n     p.x=abs(p.x)+0.2;\n     float d3=sdOrientedBox(p-vec2(0.0,-1.5), vec2(0.0,0.0), vec2(1.0,-0.8), 0.5 );\n\n     col=DrawFig(vec3(0.45,0.15,0.0)*escal, col, d1);\n     col=DrawFig(vec3(0.45,0.15,0.0)*escal, col, d2);\n     col=DrawFig(vec3(0.45,0.15,0.0)*escal, col, d3);\n return col;\n}  \n\nvec3 pac(vec2 pp, vec3 col)\n{    vec2 p=pp;\n    float d1cabeza= sdCircle(p, 2.0 );\n    float posOjoX=0.6;\n    float posOjoy=0.3;\n    float d1ojo1A= sdCircle(p-vec2(0.0-posOjoX,0.0+posOjoy), 0.6 );\n    float d1ojo1B= sdCircle(p-vec2(-0.2-posOjoX,-0.1+posOjoy), 0.7 );\n    float difOjo1= differenceSDF(d1ojo1A,d1ojo1B);\n\n    float d1ojo2A= sdCircle(p-vec2(0.0+posOjoX,0.0+posOjoy), 0.6 );\n    float d1ojo2B= sdCircle(p-vec2(-0.2+posOjoX,-0.1+posOjoy), 0.7 );\n    float difOjo2= differenceSDF(d1ojo2A,d1ojo2B);\n    \n    float pyo=0.3*sin(iTime);\n    float dojo1= sdVesica(p-vec2(-0.5,0.3+pyo), 0.4, 0.25);\n    float dojo2= sdVesica(p-vec2(0.7,0.3+pyo), 0.4, 0.25);\n    \n    float boca1A= sdCircle(p-vec2(0.0,0.0-1.1), 0.7 );\n    float boca1B= sdCircle(p-vec2(0.0,-0.3-1.1), 0.8 );\n    float difBoca= differenceSDF(boca1A,boca1B);\n    //pata\n    float pata1= sdOrientedBox( p-vec2(-1.0,-3.0), vec2(0.0,0.0),vec2(0.5,2.0), 0.25 );\n    float pata2= sdOrientedBox( p-vec2(1.0,-3.0), vec2(0.0,0.0),vec2(-0.5,2.0), 0.25 );\n    float zapato1= sdVesica(p.yx-vec2(-3.0,-1.0), 1.2, 1.0);\n    float zapato2= sdVesica(p.yx-vec2(-3.0,1.0), 1.2, 1.0);\n    float d1gorroA= sdCircle(p-vec2(0.0,1.5), 1.1 );\n    float d1gorroB= sdVesica(p.yx-vec2(2.0,1.0), 1.2, 1.0);\n    float dmano1= sdBox(p-vec2(-2.5,0.0),vec2(1.0,0.15) );\n    float dmano2= sdBox(p-vec2( 2.5,0.0),vec2(1.0,0.15) );    \n    col=DrawFig(vec3(0.0,0.0,0.0), col, pata1);\n    col=DrawFig(vec3(0.0,0.0,0.0), col, pata2);\n    col=DrawFig(vec3(1.0,0.0,0.0), col, d1gorroA);\n    col=DrawFig(vec3(.0,0.0,0.0), col, d1gorroB);\n    col=DrawFigBorde(vec3(0.0), col, dmano1);\n    col=DrawFigBorde(vec3(0.0), col, dmano2);\n    col=DrawFigBorde(vec3(1.0,1.0,0.0), col, d1cabeza);\n    col=DrawFig(vec3(0.0,0.0,0.0), col, difOjo1);\n    col=DrawFig(vec3(0.0,0.0,0.0), col, difOjo2);\n    \n    col=DrawFig(vec3(0.0,0.0,0.0), col, dojo1);\n    col=DrawFig(vec3(0.0,0.0,0.0), col, dojo2);\n    \n    col=DrawFig(vec3(0.0,0.0,0.0), col, difBoca);\n    col=DrawFigBorde(vec3(1.0), col, zapato1);\n    col=DrawFigBorde(vec3(1.0), col, zapato2);\n return col;\n}  \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    vec3  col=vec3(0.25,0.7,1.2)-uv.y*0.3;\n         uv*=6.0+sin(iTime);\n   \n   vec2 uv2=uv*6.0;\n   float t=iTime*2.0;\n   t=mod(t,20.0);\n   uv.x+=t;\n  uv2.x+=t;\n   \n   col=ondamar (uv-vec2(0.0,-3.0), col);\n   col=Suelo0(uv-vec2(0.0,-1.25), col);\n   \n   col=Suelo1(uv-vec2(0.0,-1.25), col);\n   col=Suelo2(uv-vec2(0.0,-3.5), col);\n   // atras  //arbol chico\n   col=Arbol(uv*2.0-vec2(6.0,1.5),col,0.8);\n   col=Arbol(uv*2.0-vec2(16.0,1.5),col,0.8);\n   col=Arbol(uv*2.0-vec2(25.0,1.5),col,0.8);\n   col=Arbol(uv*2.0-vec2(30.0,1.5),col,0.8);\n   \n   col=Arbol(uv-vec2(0.0,1.5),col,1.0);\n   col=Arbol(uv-vec2(6.0,1.5),col,1.0);\n   col=ramas(uv-vec2(10.0,1.5),col,1.0);\n   col=Arbol(uv-vec2(16.0,1.5),col,1.0);\n   col=ramas(uv-vec2(20.0,1.9),col,1.0);\n   \n   //troncos chicos\n  col=Tronco(uv*vec2(3.0,4.0)-vec2(12.0,-8.5),col,1.0);\n  col=Tronco(uv*vec2(3.0,4.0)-vec2(15.0,-7.5),col,1.0);\n  col=Tronco(uv*vec2(3.0,4.0)-vec2(30.0,-8.5),col,1.0);\n  col=Tronco(uv*vec2(3.0,4.0)-vec2(35.0,-7.5),col,1.0);\n  col=Tronco(uv*vec2(3.0,4.0)-vec2(60.0,-8.5),col,1.0);\n  col=Tronco(uv*vec2(3.0,4.0)-vec2(65.0,-7.5),col,1.0);\n  col= pac(uv, col);\n  col= pac(uv-vec2(25.0,0.0), col);\n  \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dtXzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 303, 337, 337, 432], [434, 465, 501, 501, 546], [551, 595, 642, 642, 669], [670, 670, 713, 713, 740], [741, 741, 789, 789, 817], [823, 823, 885, 885, 1081], [1083, 1083, 1140, 1140, 1206], [1208, 1208, 1245, 1245, 1325], [1327, 1327, 1362, 1362, 1390], [1392, 1392, 1458, 1458, 1675], [1677, 1677, 1719, 1719, 1876], [1878, 1878, 1910, 1910, 2037], [2043, 2043, 2074, 2074, 2174], [2176, 2176, 2207, 2207, 2316], [2318, 2318, 2349, 2349, 2449], [2453, 2453, 2496, 2496, 2913], [2915, 2915, 2960, 2960, 3426], [3430, 3430, 3476, 3476, 3895], [3899, 3899, 3928, 3928, 5978], [5982, 5982, 6039, 6039, 7354]]}
{"id": "7dVSRh", "name": "QuadTree Traversal [Commented]", "author": "Yusef28", "description": "It's commented but messy. I'll put up a way shorter version later that should be clearer.\nI only use euclidean distance no step size moves. I guess there could be a fully integer version if we made each level's cell size an int power of 2", "tags": ["commented", "quadtree", "traversal"], "likes": 26, "viewed": 224, "published": "Public API", "date": "1634348671", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* \n   This leads directily into my 3D version (Octree):\n   https://www.shadertoy.com/view/fdyXDR\n   \n   \n   SPOILERS:\n\n   The Basic Idea\n    \n   It might not be obvious from this code as it's a bit\n   convoluted, but there are three main concepts\n   \n   Quadtrees, DDA algorithms, and traversing a grid\n   \n   Together it is traversing a quadtree grid with a modified dda algo\n   \n   1. \n   \"Build the quad tree\" which really is just running that\n   space partitioning until a random stop level for each pixel\n   in a given cell at that level. \n   I can paint the quatree to final color using just the ending level \n   or the ending scale\n   \n   Important is this returns the cellsize (1./levelScale)\n  \n   2. \n   Most dda algos have an intialization phase where you have to snap\n   the start position to the nearest axis in the rd direction. I use\n   cellSize to calculate that based on the cellsize of the level the ro \n   is in, in the quadtree. Thats just a slight modification from the\n   fixed cellsize dda algorithm in lodev's tutorial. I scale the\n   ro, floor(ro), ceil(ro) by 1./cellSize to get to the local uv of the\n   quadtree, do the subtraction to get dist to nearest wall of that cell,\n   and then scale by cellSize to get back to global coordinates.\n   This dda initialization gives us the t value (euclidian distance)\n   to the nearest axis in the quadtree.\n   \n   3. \n   Carrying on from step two I basically do the same thing at every \n   step as I step through with t values based on current cell size,\n   and then calculate new t values and make new steps. I paint green \n   dots at every iteration.\n   \n   -----------------------------\n   \n   I have a version now that is a lot more simple.\n   It has just one quadtree function, since having a \n   quadtree and then a \"map\" that does almost the same is\n   redundant. There are also variables that are unessesary, \n   and some parts of the code can be branchless and some can\n   take advantage of the componentwise operations of min,max,abs,etc\n   more.\n        \n    \n   Random Note \n   \n   ------------\n   \n   Nudging the current position a bit in the ray direction was critical\n   otherwise we remain at the last floor value and the calculations\n   of t values in my code depend on that not being the case\n   \n   Another option might have been subtracting the cellsize of that\n   level by the result so that if the result was 0 (meaning\n   we were infact on a boundary, we would get a full cellsize instead of 0.\n   This wasn't nessesary though\n   \n   \n  \n*/\n\n\n#define pi acos(-1.)\n#define eps 1./iResolution.y\n#define MAX_LEVEL 6.\n#define debugCoord vec2(-1.,0.)\n#define debug 1.\n#define globalScale 2.\n\nmat2 rot(float a){\n    float c = cos(a), s = sin(a); return mat2(c,-s,s,c);}\n    \n//  1 out, 2 in...\nfloat rnd(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//Drawing stuff\nfloat drawPoint(vec2 uv, vec2 p, float r){\n    float c = length(uv - p);\n    float ss = eps * 4.;\n    c = 1.-smoothstep(r-ss, r+ss, c);\n  return c;\n}\n//Drawing stuff\nfloat distLine(vec2 p, vec2 A, vec2 B){\n    vec2 AB = B-A;\n  float t =  clamp(dot(AB,p-A)/dot(AB,AB),0.,1.);\n  vec2 P3 = A + (B-A)*t;\n  return length(P3-p);\n}\n//Drawing stuff\nfloat drawLine(vec2 uv, vec2 A, vec2 B, float r){\n    float ss = eps*3.;\n    float d = distLine(uv,A,B);\n    d = smoothstep(r+ss, r-ss, d);\n  return d;\n}\n\n//The map that partitions space until we reach the level\n//where the hash of the cellID gives back a value < 0.5\nfloat map(vec2 pos){\n  \n  vec2 localUV;\n  vec2 cellID;\n  float currentCellSize = 2.;// ?\n  float s = 1.;\n\n  for(float i = 1.; i < MAX_LEVEL; i++){\n    \n      localUV = s * pos;\n      cellID = floor(localUV);\n      float rndID = rnd(cellID);\n\n      \n      s *= 2.;\n    \n    //starting cellSize at 2 because we only break after dividing by 2.\n     currentCellSize /=2.;\n    //divide by 2 AFTER currentCellSize because otherwise you don't\n    //calculate the steps properly at the random exit points\n    if( rndID < 0.5 ) break;\n  }\n  //give back cellsize, that's critical\n  return currentCellSize;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\n  \n  vec3 col = vec3(0.);\n  uv *= globalScale;\n  \n  //step 1. Quad Tree ----------------------------------------\n  \n  //way too many variables for a quatree \n  vec2 globalUV = uv;\n  vec2 localUV = uv;\n  float level = 0.;\n  vec2 cellUV;\n  vec2 cellID;\n  float currentCellSize = 1.;\n  float s = 1.;\n  float extraLevel = float(floor(uv) == debugCoord)*debug;\n  \n  \n  \n  //if( max( abs(uv.x), abs(uv.y) ) > currentCellSize)\n  for(float i = 1.; i < MAX_LEVEL; i++){\n      level++;\n      localUV = s * globalUV;\n      cellUV = fract(localUV);\n      cellID = floor(localUV);\n    \n     //interessant float rndID = rnd(vec2(cellID.x,0.));\n      float rndID = rnd(cellID);\n    \n      if( max(abs(cellUV.x-0.5),\n           abs(cellUV.y-0.5) ) > 0.49-s/200.) {\n               level = 0.;\n               break;\n             }\n             \n     if( rndID < 0.5 ) break;\n     s *= 2.;\n     //currentCellSize /=2.;\n             \n  }\n  \n  \n  //drawing the quad tree\n  col = vec3(level/MAX_LEVEL);\n  \n  \n  \n  //Step 2. Ray and DDA Initialize  //------------------------------------\n  \n  \n  //starting a new section of initializing\n  //(maybe for this one we'll go simplified\n  //so start point is always 0,0\n  \n  vec2 ro = vec2(sin(iTime/8.)*.25,cos(iTime/8.)*.25);\n  vec2 rd = vec2(-1.,0.);\n  rd *= rot(iTime/4.);\n  float lineLength = 4.*globalScale;\n  \n  //drawing the ray\n  col=mix(col, vec3(1.,0.,0.), drawPoint(uv, ro, 0.02));\n  col=mix(col, vec3(1.,0.,0.), drawLine(uv, ro, ro+rd*lineLength, 0.014));\n  col=mix(col, vec3(1.,0.,0.), drawPoint(uv, ro+rd*lineLength, 0.02));\n  col=mix(col, vec3(0.,1.,0.), drawPoint(uv, ro, 0.02));\n  \n  //get delta (from lodev raycasting tutorial\n  vec2 delta;\n       delta.x  = abs(rd.x) < eps ? 1e30 : abs(1./rd.x);\n       delta.y  = abs(rd.y) < eps ? 1e30 : abs(1./rd.y);\n \n  \n  \n  //this would only evaulate the first level of the quad tree no matter where the ro\n  //was. \n  //We need to replace t with the distance to the first cell regardless of size\n  //to do that we need to find the distance from ro to that \n  \n  //This right here is the final cellsize for the ro position in the tree\n  float cellSize = map(ro);\n  \n  \n  //get the initial t value (basic version of this is in the lodev tutorial)\n  //I use \"cellSize\" to transform the ro back to the local coordinates and get what the difference\n  //would be locally which is how we get the initial t value in any level of the quadtree\n  \n  vec2 tStart;\n  tStart.x = rd.x < 0. ? ( ro.x/cellSize - floor(ro.x/cellSize) ) * cellSize * delta.x \n                           : ( ceil(ro.x/cellSize) - ro.x/cellSize ) * cellSize * delta.x;\n                           \n  tStart.y = rd.y < 0. ? ( ro.y/cellSize - floor(ro.y/cellSize) ) * cellSize * delta.y \n                           : ( ceil(ro.y/cellSize) - ro.y/cellSize ) * cellSize * delta.y;\n  \n \n //we'll hit the closest axis first\n  float tCurr = min(tStart.x,tStart.y);\n  vec2 currentPos;\n  vec2 tNext;\n  \n  \n  //Step 3. Running the Modified DDA---------------------------------------\n  \n  \n  for( float i = 0.; i < 30.; i++ ){\n     \n    currentPos = ro + rd*tCurr*1.01;//this slight nudge in the rd direction is critical\n    //without it, you are stuck on the floor values\n    //if it's too low, like 1.00001 you get too much flickering\n    \n    col=mix(col, vec3(0.,1.,0.), drawPoint(uv, currentPos, 0.02));\n    \n    float newSize = map(currentPos);\n    \n    //because I nudge a bit along the rd direction, the currentPos\n    //is never on an axis, so these calculations work fine. Otherwise\n    //I'd need something like what I mentioned at the top.\n    \n    tNext.x = rd.x < 0. ? ( ( currentPos.x/newSize - floor(currentPos.x/newSize)) * newSize ) * delta.x \n                        : (  ( ceil(currentPos.x/newSize) - currentPos.x/newSize ) * newSize ) * delta.x;\n    \n    tNext.y = rd.y < 0. ? (( currentPos.y/newSize - floor(currentPos.y/newSize))  * newSize ) * delta.y \n                        : ( ( ceil(currentPos.y/newSize) - currentPos.y/newSize)  * newSize ) * delta.y;\n    \n    \n    tCurr += min(tNext.x, tNext.y);\n    \n  } \n \n\tfragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dVSRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 2680, 2698, 2698, 2756], [2762, 2781, 2800, 2800, 2917], [2919, 2935, 2977, 2977, 3084], [3085, 3101, 3140, 3140, 3259], [3260, 3276, 3325, 3325, 3429], [3431, 3544, 3564, 3564, 4141], [4142, 4142, 4199, 4249, 8410]]}
{"id": "7dVSWt", "name": "Color Line Fractal", "author": "ShaderGuy57", "description": "Line fractal", "tags": ["fractal", "line", "color", "kifs"], "likes": 2, "viewed": 41, "published": "Public", "date": "1635534183", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST 0.00001\n\n// The SDF\nvec4 GetDist(vec3 p) {\n    float bg = p.y;\n    p -= vec3(0,1,0);\n    \n    float t = iTime * 0.4 + 1.*3.14;\n    mat2 m1 = mat2(cos(t),-sin(t),sin(t),cos(t));\n    \n    float size = 0.9;\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    for (int i = 0; i < 13; i++) {\n        size = size*0.66;\n        p.xz = m1*p.xz;\n        col.y -= (p.x)*size;\n        p.x = abs(p.x) - size;\n    }\n    \n    float d = min(bg, length(p)-5.8*size);\n    \n    col.x = - col.y;\n    col.z = (col.z+1.)/2.;\n    \n    col = bg < length(p)-5.8*size ? vec3(1.) : col;\n    return vec4(d, col);\n}\n\n// Get the distance from camera\nvec4 RayMarch( vec3 ro, vec3 rd ) {\n    float dO = 0.;\n    vec3 col = vec3(1.);\n    \n    for( int i = 0; i < MAX_STEPS; i++ ) {\n        vec3 p = ro + rd*dO;\n        vec4 ds = GetDist(p);\n        dO += ds.x;\n        col = ds.yzw;\n        if (dO > MAX_DIST || dO < SURF_DIST) break;\n    }\n    return vec4(dO, col);\n}\n\n// Normal from SDF\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.0001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p - e.xyy).x,\n        GetDist(p - e.yxy).x,\n        GetDist(p - e.yyx).x);\n    \n    return normalize(n);\n}\n\n// Darker light if close to lightray\nfloat softshadow( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n    float dO = 0.;\n    for( int i=0; i<MAX_STEPS; i++ )\n    {\n        float ds = GetDist(ro + rd*dO).x;\n        if( ds<SURF_DIST )\n            return 0.0;\n        res = min( res, k*ds/dO );\n        dO += ds;\n    }\n    return res;\n}\n\n// Lighting\nvec3 GetLight(vec3 p, vec3 lightPos) {\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    \n    // Diffuse lighting\n    vec3 dif = vec3(clamp(dot(n, l), 0., 1.));\n    \n    // Smooth shadow\n    // float d = softshadow(p + n*SURF_DIST*2.0, l, 10.);\n    // dif *= d;\n    \n    // Hard shadow\n    vec4 d = RayMarch(p+n*SURF_DIST*2., l);\n    if(d.x<length(lightPos-p)) dif *= 0.3*d.x*d.yzw;\n    \n    return dif;\n}\n\n// The camera\nvec3 camDir(vec3 origin, vec2 uv) {\n    vec3 up = vec3(0., 0., 1.);\n    float zoom = 1.;\n    vec3 lookat = vec3(0, 0, 0);\n    \n    vec3 f = normalize(lookat - origin);\n    vec3 r = cross(up, f);\n    vec3 u = cross(f, r);\n    vec3 c = origin + f * zoom;\n    vec3 i = c + uv.x*r + uv.y*u;\n    vec3 rd = i - origin;\n    return rd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t = -iTime * 0.4;\n    mat2 m1 = mat2(cos(t),-sin(t),sin(t),cos(t));\n\n    vec3 col = vec3(0.);  \n    \n    // Camera origin\n    vec3 ro = vec3(0, 4, 0);\n    uv = m1*uv;\n    // Camera direction\n    vec3 rd = camDir(ro, uv);\n\n    // Distance\n    vec4 d = RayMarch(ro, rd);\n    // Intersection point\n    vec3 p = ro + rd * d.x;\n    vec3 lightOff = vec3(2, 0, -2);\n    lightOff.xz = m1*lightOff.xz;\n    vec3 dif = GetLight(p, ro + lightOff);\n    col = dif * d.yzw;\n    \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dVSWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 82, 104, 104, 637], [639, 671, 706, 706, 985], [987, 1006, 1030, 1030, 1238], [1240, 1277, 1330, 1330, 1583], [1585, 1597, 1635, 1635, 2021], [2023, 2037, 2072, 2072, 2366], [2368, 2368, 2425, 2425, 2992]]}
{"id": "7dVXDR", "name": "Cookbook - SDF Sphere", "author": "omegasbk", "description": "SDF sphere", "tags": ["sdf"], "likes": 7, "viewed": 156, "published": "Public", "date": "1634502062", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 09.11.2021.\n// Made by Darko Supe (omegasbk)\n\n#define MAX_STEPS 100\n\n#define MAX_DIST 100.\n#define MIN_DIST 0.0002\n\nfloat sdfSphere(vec3 c, float r, vec3 p)\n{\n    return distance(p, c) - r + texture(iChannel0, p.xy).r / ((sin(iTime) + 1.) * 80.);\n}\n\nfloat getDist(vec3 p)\n{\n    // Setup scene\n    return sdfSphere(vec3(0.), 0.8, p);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd)\n{\n    float dist = 0.;\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 itPos = ro + rd * dist;\n        float itDist = getDist(itPos);\n        \n        dist += itDist;\n        \n        if (dist > MAX_DIST || dist < MIN_DIST)  \n            break;\n    }    \n    \n    return dist;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec2 e = vec2(0.01, 0.);    \n    return normalize(vec3(getDist(p + e.xyy), getDist(p + e.yxy), getDist(p + e.yyx)));    \n}\n\nfloat getLight(vec3 p)\n{\n    vec3 lightPos = vec3(sin(iTime * 3.), 3., -2.2);\n    vec3 lightDir = normalize(p - lightPos);\n    \n    return -dot(getNormal(p), lightDir);    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float focalDist = 0.6;\n    vec3 ro = vec3(0., 0., -1.6);\n    vec3 rd = vec3(uv.x, uv.y, focalDist);   \n    \n    vec3 col = vec3(0.);\n    \n    float dist = rayMarch(ro, rd);\n    if (dist < MAX_DIST)\n    {\n        vec3 pHit = ro + rd * dist;\n        col = vec3(0.5, 0.6, 0.6);\n        col *= vec3(getLight(pHit)) + vec3(0.1);\n        \n    }    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dVXDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 119, 161, 161, 251], [253, 253, 276, 295, 337], [339, 339, 373, 373, 666], [668, 668, 692, 692, 819], [821, 821, 845, 845, 995], [997, 997, 1054, 1054, 1557]]}
{"id": "7dVXDt", "name": "Twisted^4 Tunnel", "author": "Tater", "description": "A shader I made during practice for inercia shader royale. ", "tags": ["3d", "raymarching", "twisty", "rope"], "likes": 28, "viewed": 364, "published": "Public API", "date": "1635634032", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MDIST 60.0\n#define STEPS 178.0\n#define pi 3.1415926535\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define pmod(p,x) (mod(p,x)-0.5*(x))\n\n\nvec3 hsv(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n//My poor mans version of Javad Taba's helix function\nvec3 spiral(vec3 p, float R){\n   \n    p.xz*=rot(p.y/R);\n    vec2 s = sign(p.xz);\n    p.xz=abs(p.xz)-R*0.5;\n    \n    p.xz*=rot(iTime*pi/3.);\n    \n    float poy = p.y;\n    p.y=0.;\n    //This is supposed to correct for the distortion that happens\n    //when you twist a shape by rotating it over an axis.\n    //In my head it should work a lot better than it does, but\n    //it definitely helps a little bit so I guess it's better than nothing\n    p.yz*=rot(mix(0.,pi/4.,1./(R*0.5+1.5)))*-sign(s.x*s.y);\n    p.y=poy;\n    return p;\n}\n\n\nvec2 map(vec3 p){\n    float t = iTime*0.5;\n    //p.y+=sin(-p.z*0.1)*2.;\n    p.y-=p.z*p.z*0.008;\n    \n    p.zy*=rot(pi/2.);\n    vec3 po = p;\n\n    p.y-=t*pi*4.339;\n    \n    vec2 a = vec2(1);\n    vec2 b = vec2(2);\n    p.xz*=rot(-0.05*(iTime/3.));\n    p = spiral(p,6.6);\n    p = spiral(p,2.);\n    p = spiral(p,1.);\n    p = spiral(p,0.4);\n    //there are some small artifacts but you dont notice them ;) \n    \n    \n    //p = spiral(p,0.1);\n    //vec2 d = abs(p.xz);\n    //a.x = max(d.x,d.y)-1.0;\n    a.x = length(p.xz)-0.1;\n    //a.x = max((abs(po.y)-7.),a.x);\n    a.x*=0.6;\n    return vec2(a);\n}\nvec3 norm(vec3 p){\n    vec2 e = vec2(0.005,0);\n    return normalize(map(p).x-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0,0.,-1.)*1.5;\n    if(iMouse.z>0.){\n    ro.yz*=rot(3.0*(iMouse.y/iResolution.y-0.5));\n    ro.zx*=rot(-7.0*(iMouse.x/iResolution.x-0.5));\n    }\n    vec3 lk = vec3(0,0,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = normalize(f*(0.9)+uv.x*r+uv.y*cross(f,r));  \n    vec3 p = ro;\n    float dO = 0.;\n    bool hit = false;\n    vec2 d= vec2(0);\n    for(float i = 0.; i<STEPS; i++){\n        p = ro+rd*dO;\n        d = map(p);\n        dO+=d.x;\n\n        if(abs(d.x)<0.005||i>STEPS-1.5){\n            hit = true;\n            break;\n        }\n        if(dO>MDIST){\n            dO = MDIST;\n            break;\n        }\n    }\n    if(hit)\n    {\n        vec3 ld = normalize(-vec3(p.x,p.y,p.z-5.));\n      \n        //sss from nusan\n        float sss=0.01;\n        for(float i=1.; i<20.; ++i){\n            float dist = i*0.35;\n            sss += smoothstep(0.,1.,map(p+ld*dist).x/dist)*0.18*1.25;\n        }\n        for(float i=1.; i<5.; ++i){\n            float dist = i*0.7;\n            sss += smoothstep(0.,1.,map(p-ld*dist).x/dist)*0.25;\n        }\n        vec3 al = vec3(0.204,0.267,0.373);\n        vec3 n = norm(p);\n        vec3 r = reflect(rd,n);\n        float diff = max(0.,dot(n,ld));\n        float amb = dot(n,ld)*0.45+0.55;\n        float spec = pow(max(0.,dot(r,ld)),40.0);\n        #define AO(a,n,p) smoothstep(-a,a,map(p+n*a).x)\n        float ao = AO(.3,n,p)*AO(.5,n,p)*AO(.9,n,p);\n\n        col = al*\n        mix(vec3(0.169,0.000,0.169),vec3(0.984,0.996,0.804),mix(amb,diff,0.75))\n        +spec*0.3;\n        col+=sss*hsv(vec3(0.76,0.9,1.35));\n        col*=mix(ao,1.,0.5);\n        col = pow(col,vec3(0.7));\n    }\n    vec3 bg = mix(vec3(0.094,0.000,0.200),vec3(0.600,0.000,0.600),length(rd.xy)-0.65);\n    \n    col = mix(col,bg,pow(dO/MDIST,2.5));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dVXDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[152, 152, 169, 169, 338], [339, 393, 422, 422, 921], [924, 924, 941, 941, 1515], [1516, 1516, 1534, 1534, 1662], [1664, 1664, 1721, 1721, 3637]]}
{"id": "7dVXzd", "name": "Rainbow Loader Bar", "author": "Krischan", "description": "A simple floating and colorful customizable loader bar.", "tags": ["rainbow", "neon", "bar", "loader"], "likes": 2, "viewed": 150, "published": "Public API", "date": "1635166765", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define HEIGHT      0.05   // Height of the Bar\n#define BACKLIGHT   0.6    // Backlight\n#define BRIGHTNESS  0.33   // overall Brightness\n#define GLOW        1.25   // Glow intensity of the Bar\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n    \n\tfloat c = BACKLIGHT;\n\tfloat a = abs(uv.y);\n\tfloat s = 1.0 - smoothstep(0.0, HEIGHT, a);\n\tc *= 1.33 - smoothstep(0.0, 0.5, a);\n    c*=c*c;\n\t\n    if(abs(uv.y) < HEIGHT) { c += s; }\n\t\n\tfragColor = vec4(cos(6.283 * (uv.x + iTime + vec3(0.0,.33,0.66))) + GLOW, 1.0) * c * BRIGHTNESS;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dVXzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[194, 194, 251, 251, 586]]}
{"id": "7dVXzR", "name": "Simple ray-marching scene", "author": "busybeaver", "description": "Simple ray-marching scene", "tags": ["raymarching"], "likes": 10, "viewed": 149, "published": "Public API", "date": "1634280574", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define enable_color_correction 1\n\nfloat max_d = 100000.;\nfloat min_d = 0.0015;\nint max_i = 220;\nfloat rotation_speed = .2;\n\nvec4 s0 = vec4(-4.5, 0., -3., 4.);\nvec4 s1 = vec4(3., -1.8, -2., 2.2);\nvec4 c0 = vec4(1., -1.5, 4., 2.5);\nfloat p1 = -4.03;\nvec4 c2 = vec4(.5, 2.02, 3.5, 1.);\nvec4 s2 = vec4(.5, 4.5, 3.5, 1.5);\nvec4 s3 = vec4(-7., 4., 5., 1.);\n\n#if enable_color_correction\nfloat gamma = 2.2; // For gamma correction.\nfloat exposure = 0.6;\nfloat tone_pow = 0.35; // Represents how strong the tone mapping is.\n\nvec3 correct_color(vec3 c) {\n    c *= exposure;\n    c = pow(c, vec3(1. / tone_pow));\n    c = pow(c / (c + 1.), vec3(tone_pow));\n    c = pow(c, vec3(1. / gamma));\n    return c;\n}\n#endif\n\nfloat sum(vec3 v) { return v.x + v.y + v.z; }\nfloat max_abs(vec3 v) { return max(max(abs(v.x), abs(v.y)), abs(v.z)); }\n\nfloat sphere(vec3 p, vec3 s, float r) { return sqrt(sum((p - s) * (p - s))) - r; }\n\nfloat cube(vec3 p, vec3 s, float r) { return max_abs(p - s) - r; }\n\nvec3 cube_m(vec3 p, vec4 c, vec3 ray) {\n    if(abs(p.x - c.x) > max(abs(p.z - c.z), abs(p.y - c.y))) { ray.x *= -1.; }\n    if(abs(p.y - c.y) > max(abs(p.z - c.z), abs(p.x - c.x))) { ray.y *= -1.; }\n    if(abs(p.z - c.z) > max(abs(p.y - c.y), abs(p.x - c.x))) { ray.z *= -1.; }\n    return ray;\n}\n\nvec3 col(vec3 cam, vec3 ray) {\n    vec3 p = cam;\n    vec3 col = vec3(1., 1., 1.);\n    vec3 col_1 = col;\n    vec3 pcol = vec3(0., 0., 0.);\n    float min_s3d = 2.;\n    bool t;\n    for(int i = 0; i < max_i; i ++) {\n        t = true;\n        float d = max_d;\n        d = min(d, sphere(p, s0.xyz, s0.a));\n        if(d < min_d && t) {\n            ray -= normalize(s0.xyz - p) * dot(s0.xyz - p, ray) / s0.a * 2.;\n            col *= vec3(1., .5, .5);\n            t = false;\n        }\n        d = min(d, sphere(p, s1.xyz, s1.a));\n        if(d < min_d && t) {\n            ray -= normalize(s1.xyz - p) * dot(s1.xyz - p, ray) / s1.a * 2.;\n            col *= vec3(.5, 1., .5) * (float(sin(atan((s1.x - p.x) / (s1.z - p.z)) * 10. + sin(iTime) * 30.) > 0.) * .7 + .3);\n            t = false;\n        }\n        d = min(d, sphere(p, s2.xyz, s2.a));\n        if(d < min_d && t) {\n            ray -= normalize(s2.xyz - p) * dot(s2.xyz - p, ray) / s2.a * 2.;\n            col *= vec3(.2, 1., 1.) * (float(sin(atan(length(s2.xz - p.xz) / (s2.y - p.y)) * 12.) > 0.) * .7 + .3);\n            t = false;\n        }\n        float s3d = sphere(p, s3.xyz, s2.a);\n        if(s3d < min_s3d && s3d < 2.) { min_s3d = s3d; }\n        d = min(d, s3d * .4);\n        if(d < min_d && t) {\n            pcol += vec3(2., 2., 4.) * col;\n            t = false;\n            break;\n        }\n        d = min(d, cube(p, c0.xyz, c0.a));\n        if(d < min_d && t) {\n            ray = cube_m(p, c0, ray);\n            col *= vec3(.4, .4, 1.);\n            t = false;\n        }\n        if(ray.y < 0.) {\n            d = min(d, (p1 - p.y) / ray.y);\n            if(d < min_d && t) {\n                ray.y *= -1.;\n                col *= vec3(.3, .3, .3);\n                t = false;\n            }\n        }\n        d = min(d, cube(p, c2.xyz, c2.a));\n        if(d < min_d && t) {\n            ray = cube_m(p, c2, ray);\n            col *= vec3(1., 1., .1);\n            t = false;\n        }\n        if(!t) {\n            p += ray * min_d * 2.;\n            pcol += col_1 * vec3(1., 1., 2.) * (2. - min_s3d) * (2. - min_s3d) * .5;\n            min_s3d = 2.;\n            col_1 = col;\n        }\n        p += ray * d;\n        if(length(p) > max_d) { break; }\n    }\n    pcol += col * vec3(1., 1., 2.) * (2. - min_s3d) * (2. - min_s3d) * .5;\n    if(length(p) <= max_d && t) { return pcol; }\n    col = col * (ray.yxz * vec3(.65, .45, .45) + vec3(.35, .55, .55)).rgb * (ray.y * 2.5 + .4) *\n    (0.9 + .2 * float(sin(atan(ray.x / ray.z) * 30.) > 0.6)) *\n    (0.9 + .2 * float(sin(atan(ray.y / ray.z) * 30.) > 0.6)) *\n    (0.9 + .2 * float(sin(atan(ray.y / ray.x) * 30.) > 0.6)) + pcol;\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - iResolution.xy * .5) / (iResolution.x + iResolution.y) * 4.;\n\n    float x = iTime * 1.5 - float(int(iTime * 1.5)) - .5;\n    s2.y = 4.52 + (1. - x * x * 4.) * 2.;\n\n    float t = iTime * rotation_speed;\n    \n    vec3 color = col(\n        vec3(sin(t) * 25., 4., - cos(t) * 25.),\n        normalize(vec3(- sin(t) * 1.3 + cos(t) * uv.x,\n            uv.y - .3, cos(t) * 1.3 + sin(t) * uv.x))\n    );\n    \n    #if enable_color_correction\n    fragColor.rgb = correct_color(color);\n    #else\n    fragColor.rgb = color;\n    #endif\n    fragColor.a = 1.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dVXzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[703, 703, 722, 722, 748], [749, 749, 772, 772, 821], [823, 823, 862, 862, 905], [907, 907, 944, 944, 973], [975, 975, 1014, 1014, 1269], [1271, 1271, 1301, 1301, 3899], [3901, 3901, 3956, 3956, 4526]]}
{"id": "7dySzz", "name": "Swollen Kirby", "author": "Devskil", "description": "Well that's Kirby !", "tags": ["3d", "raymarching", "sdf", "animation", "kirby"], "likes": 13, "viewed": 171, "published": "Public", "date": "1634243087", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Using code from IQ\n//https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 20.0;\nconst float PRECISION = 0.001;\nconst float PI = 3.14159265359;\n\nvec3 white = vec3(1.);\nvec3 black = vec3(.0);\nvec3 grey = vec3(.6);\nvec3 weights_col = vec3(.2, .2, .2);\nvec3 pink = vec3(1., .71, .76);\nvec3 blush_col = vec3(.99, .5, .65);\nvec3 shoes_col = vec3(.87, .02, .35);\nvec3 blue = vec3(.0, .0, 1.);\n\nstruct Surface {\n    float sd;\n    vec3 col;\n};\n\nmat3 rotateX(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(\n        vec3(1., 0., 0.),\n        vec3(0., c, -s),\n        vec3(0., s, c)\n    );\n}\n\nmat3 rotateY(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(\n        vec3(c, 0., -s),\n        vec3(0., 1., 0.),\n        vec3(s, 0., c)\n    );\n}\n\nmat3 rotateZ(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(\n        vec3(c, -s, 0.),\n        vec3(s, c, 0.),\n        vec3(0., 0., 1.)\n    );\n}\n\n//operator\nSurface unionOp(Surface s1, Surface s2) {\n    if(s1.sd < s2.sd) {\n        return s1;\n    } else {\n        return s2;\n    }\n}\n\nSurface intersection(Surface s1, Surface s2) {\n    if(s1.sd < s2.sd) {\n        return s2;\n    } else {\n        return s1;\n    }\n}\n\nSurface smoothUnion(Surface a, Surface b, float k ) {\n    float h = clamp( 0.5 + 0.5 * (b.sd - a.sd) / k, 0.0, 1.0 );\n    vec3 col = mix( b.col, a.col, h ) - k * h * (1.0 - h);\n    return Surface(mix( b.sd, a.sd, h ) - k * h * (1.0 - h), col);\n}\n\nSurface ssubstract(Surface a, Surface b, float k ) {\n    float h = clamp( 0.5 - 0.5 * (b.sd + a.sd) / k, 0.0, 1.0 );\n    vec3 col = mix( b.col, a.col, h ) - k * h * (1.0 - h);\n    return Surface(mix( b.sd, -a.sd, h ) + k * h * (1.0 - h), col);\n}\n\n//sdf\n\nSurface sdSphere(vec3 p, float r, vec3 col) {\n    float d = length(p) - r;\n    return Surface(d, col);\n}\n\nSurface sdEllipsoid( vec3 p, vec3 r, vec3 col) {\n  float k0 = length(p / r);\n  float k1 = length(p / (r * r));\n  return Surface(k0 * (k0 - 1.0) / k1, col);\n}\n\nSurface sdFloor(vec3 p, vec3 col) {\n    return Surface(p.y, col);\n}\n\nSurface sdVerticalCapsule( vec3 p, float h, float r, vec3 col)\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return Surface(length( p ) - r, col);\n}\n\nSurface sdRoundCone( vec3 p, float r1, float r2, float h, vec3 col) {\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 )return Surface(length(q) - r1, col);\n  if( k > a*h ) return Surface(length(q-vec2(0.0,h)) - r2, col);\n        \n  return Surface(dot(q, vec2(a,b) ) - r1, col);\n}\n\nSurface sdBox( vec3 p, vec3 b , vec3 col) {\n  vec3 q = abs(p) - b;\n  return Surface(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0), col);\n}\n\nSurface sdCylinder( vec3 p, float h, float r, vec3 col) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h, r);\n  return Surface(min(max(d.x,d.y), 0.0) + length(max(d,0.0)), col);\n}\n\nSurface bar(vec3 p, vec3 repulsor, float k) {\n    //repulsor to bend the bar\n    p = p - normalize(p - repulsor) * k;\n    Surface bar = sdCylinder((p - vec3(0., -2.7, .3)) * rotateZ(1.5708), .08, 4., white);\n    return bar;\n}\n\n\nSurface arms(vec3 p, Surface modele, bool flex) {\n    vec3 pbiceps = p;\n    float wave = .5 +.35 * sin(iTime * 3.);\n    pbiceps.y += 1.;\n    pbiceps.y *= 1.+.1 * wave;\n    pbiceps.y -= 1.;\n    pbiceps.xz *= 1.-.1 * wave;\n\n    vec3 pforearm = p;\n    pforearm.x += 1.4;\n    pforearm.z += 1.1;\n    pforearm.y += 1.25;\n    pforearm *= 1.+.1 * -wave;\n    pforearm -= 1.2;\n\n    //arms\n    Surface shoulderL = sdSphere((pbiceps - vec3(.5, .5, -.25)), .6, pink);\n    Surface armL = sdVerticalCapsule((pbiceps - vec3(.5, 0.5, -.35)) * rotateZ(90.), 1.5, .45, pink);\n    Surface biceps = sdEllipsoid((pbiceps - vec3(1.5, .35, -.25)) * rotateZ(10.), vec3(.6, .45, .45), pink);\n    Surface triceps = sdEllipsoid((pbiceps - vec3(1.25, -.35, -.25)) * rotateY(6.) * rotateZ(10.), vec3(.5, .25, .25), pink);\n    Surface arm = smoothUnion(shoulderL, armL, .25);\n    arm = smoothUnion(biceps, arm, .1);\n    arm = smoothUnion(arm, triceps, .5);\n\n    Surface elbow = sdEllipsoid((p - vec3(2.0, -.35, -.25)) * rotateY(6.) * rotateZ(10.), vec3(.65, .5, .5), pink);\n    Surface elbow2 = sdEllipsoid((pforearm - vec3(2.35, -.65, -.25)) * rotateY(6.) * rotateZ(10.), vec3(.45, .3, .3), pink);\n    arm = smoothUnion(arm, elbow, .2);\n    arm = smoothUnion(arm, elbow2, .2);\n\n    Surface forearmL = sdEllipsoid((pforearm - vec3(2.5, 0.2, -.05)) * rotateX(-60.) /* rotateZ(-wave)*/, vec3(.5, 1.2, .45), pink);\n    Surface hand;\n    if(flex)\n        hand = sdRoundCone((pforearm - vec3(2.5, 1., .25)) * rotateX(50.) * rotateZ(87.), .25, .5, .5, pink);\n    else {\n         hand = sdRoundCone((pforearm - vec3(2.5, 1., .25)) * rotateX(50.) * rotateZ(0./*87.*/), .25, .5, .5, pink);\n         Surface thumb = sdEllipsoid((pforearm  - vec3(2.1, 1.4, .8)) * rotateY(-1.3), vec3(.3, .15, .15), pink);\n         hand = smoothUnion(hand, thumb, .2);\n    }\n    forearmL = smoothUnion(hand, forearmL, .1);\n    arm = smoothUnion(arm, forearmL, .1);\n    modele = smoothUnion(arm, modele, .1);\n\n    return modele;\n}\n\nSurface weights(vec3 p, Surface modele) {\n    float wave = .5 +.35 * sin(iTime * 3.);\n    p.x += 1.4;\n    p.z += 1.1;\n    p.y += 1.25;\n    p.xzy *= 1.+.1 * -wave;\n    p.xzy -= 1.2;\n\n    Surface bar = bar(p, vec3(0., -5.5, .0), 4.5);\n\n    vec3 op = p;\n    op.x = abs(op.x);\n    Surface weight1 = sdCylinder((op - vec3(5.45, .6, .65)) * rotateZ(1.8), 1.9, .4, weights_col);\n    Surface weight_sub = sdCylinder((op - vec3(5., .7, .65)) * rotateZ(1.8), 1., .2, grey);\n    Surface security1 = sdCylinder((op - vec3(5., .8, .65)) * rotateZ(1.8), .3, .2, grey);\n    weight1 = ssubstract(weight_sub, weight1, .1);\n    weight1 = unionOp(weight1, security1);\n    Surface weight2 = sdCylinder((op - vec3(6., .4, .65)) * rotateZ(1.8), 1.7, .2, weights_col);\n    Surface weight3 = sdCylinder((op - vec3(6.35, .3, .65)) * rotateZ(1.8), 1.3, .15, weights_col);\n    Surface weight_sub2 = sdCylinder((op - vec3(6.5, .25, .65)) * rotateZ(1.8), .5, .15, grey);\n    Surface security = sdCylinder((op - vec3(6.5, .25, .65)) * rotateZ(1.8), .25, .15, grey);\n    weight3 = ssubstract(weight_sub2, weight3, .1);\n    Surface weights = unionOp(weight1, weight2);\n    weights = unionOp(weights, weight3);\n    weights = unionOp(weights, security);\n    bar = unionOp(bar, weights);\n\n    modele = ssubstract(bar, modele, .2);\n    modele = unionOp(bar, modele);\n    return modele;\n}\n\nSurface legs(vec3 p, Surface modele) {\n    //thigh\n    Surface thigh = sdRoundCone((p - vec3(0.5, -2.1, .0)) * rotateZ(6.2), .5, .7, .9, pink);\n    Surface leg = smoothUnion(thigh, modele, .4);\n    modele = unionOp(leg, modele);\n    Surface quadri = sdEllipsoid((p - vec3(.75, -1.5, .2)) * rotateZ(50.3) * rotateX(50.05), vec3(.5, .9, .6), pink);\n    Surface isq = sdEllipsoid((p - vec3(.35, -1.5, .35)) * rotateZ(50.2) * rotateX(50.05), vec3(.45, .9, .4), pink);\n    Surface m = unionOp(quadri, isq);\n    modele = smoothUnion(m, modele, .1);\n    //Knee\n    Surface knee = sdRoundCone((p - vec3(0.65, -2.6, .05)) * rotateZ(6.2), .4, .4, .2, pink);\n    modele = smoothUnion(knee, modele, .1);\n    Surface knee_cap = sdRoundCone((p - vec3(0.7, -2.7, .35)) * rotateZ(6.2) * rotateX(50.5), .15, .3, .3, pink);\n    modele = smoothUnion(knee_cap, modele, .05);\n    //calf\n    Surface calf = sdRoundCone((p - vec3(0.65, -3.9, .0)) * rotateZ(6.2), .3, .5, .8, pink);\n    modele = smoothUnion(calf, modele, .2);\n\n    return modele;\n}\n\nSurface eyes(vec3 p, Surface modele) {\n    p.y *= 1./ smoothstep(.0,.15,abs(sin(iTime)));\n    Surface eyeL = sdEllipsoid((p - vec3(-.3, 0.5, 1.3)) * rotateX(6.6), vec3(.13, .43, .1), black);\n    Surface pupL = sdEllipsoid((p - vec3(-.3, 0.7, 1.3)) * rotateX(6.7), vec3(.08, .14, .05), white);\n    eyeL = ssubstract(pupL, eyeL, .1);\n    eyeL = unionOp(eyeL, pupL);\n    Surface blueL = sdEllipsoid((p - vec3(-.3, 0.3, 1.42)) * rotateX(6.5), vec3(.08, .17, .05), blue);\n    Surface subblue = sdEllipsoid((p - vec3(-.3, 0.4, 1.4)) * rotateX(6.5), vec3(.08, .17, .1), blue);\n    blueL = unionOp(blueL, subblue);\n    blueL = ssubstract(subblue, blueL, .01);\n    eyeL = unionOp(eyeL, blueL);\n    modele = ssubstract(eyeL, modele, .1);\n    modele = unionOp(eyeL, modele);\n    return modele;\n}\n\nSurface kirby(vec3 p, bool flex) {\n    vec3 op = p;\n    vec3 pbody = p;\n    float wave = .5 + .35 * sin(iTime * 3.);\n    pbody.y += 1.;\n    pbody.y *= 1. + .1 * wave;\n    pbody.y -= 1.;\n    pbody *= 1.-.1 * wave;\n\n    //body\n    Surface body = sdSphere(pbody, 1.5, pink);\n\n    //butt\n    op = pbody;\n    op.x = abs(p.x) -.9;\n    Surface butt = sdSphere(op - vec3(-.45, -1.35, -.45), .6, pink);\n    Surface modele = smoothUnion(body, butt, .3);\n\n    //eyes\n    op = pbody;\n    op.x = abs(op.x) -.6;\n    modele = eyes(op, modele);\n\n    //blush\n    op = pbody;\n    op.x = abs(op.x) - 1.5;\n    Surface blush = sdEllipsoid((op - vec3(-.75, -.0, 1.25)) * rotateY(.55), vec3(.15, .05, .05), blush_col);\n    modele = ssubstract(blush, modele, .1);\n    modele = smoothUnion(modele, blush, .1);\n    //mouth\n    Surface mouth = sdEllipsoid((pbody - vec3(.0, .75, 1.3)), vec3(.6, 1.2, .5), pink);\n    Surface box_mouth= sdBox((pbody - vec3(.0, 0.95, 1.3)), vec3(.8, 1., .65), shoes_col);\n    mouth = ssubstract(box_mouth, mouth, .5);\n    modele = ssubstract(mouth, modele, .1);\n    Surface mouthes = sdRoundCone((pbody - vec3(0.0, -.5, 1.5)) * rotateX(50.5), .15, .3, .3, black);\n    mouth = unionOp(box_mouth, mouth);    \n    //arms\n    op = p;\n    op.x = abs(op.x) - .8;\n    modele = arms(op - vec3(0., -.1, 0.2), modele, flex);\n    //legs\n    op = p;\n    op.x = abs(op.x) - .2;\n    modele = legs(op - vec3(0., -.2, 0.), modele);\n    //shoes\n    op = p;\n    op.x = abs(op.x) - 2.15;\n    Surface shoeL = sdEllipsoid((op - vec3(-1.1, -5.1, .3)) * rotateY(10.), vec3(.6, 1., 1.), shoes_col);\n    Surface box= sdBox((op - vec3(-1.1, -5.5, .3)) * rotateY(10.), vec3(.5, .6, 1.), shoes_col);\n    shoeL = ssubstract(box, shoeL, .3);\n    modele = smoothUnion(shoeL, modele, .1);\n    //weights\n    if(!flex)\n        modele = weights(p - vec3(.0, .0, .1), modele);\n\n    return modele;\n}\n\nSurface sdScene(vec3 p) {\n    //change false by true if you want to see kirby flex without the weights\n    Surface kirby = kirby(p, false);\n    Surface floor = sdFloor(p - vec3(.0, -5., .0), grey * 1.3);\n    return unionOp(kirby, floor);\n}\n\nvec3 computeNormal(vec3 p) {\n    float e = 0.0005;\n    return normalize(vec3(\n        sdScene(vec3(p.x + e, p.y, p.z)).sd - sdScene(vec3(p.x - e, p.y, p.z)).sd,\n        sdScene(vec3(p.x, p.y + e, p.z)).sd - sdScene(vec3(p.x, p.y - e, p.z)).sd,\n        sdScene(vec3(p.x, p.y, p.z + e)).sd - sdScene(vec3(p.x, p.y, p.z - e)).sd\n    ));\n}\n\nSurface rayMarching(vec3 ro, vec3 rd, float start, float end) {\n    float depth = start;\n    Surface co;\n    const int step = 255;\n    for(int i = 0; i < MAX_MARCHING_STEPS; ++i) {\n        vec3 p = ro + depth * rd;\n        co = sdScene(p);\n        depth += co.sd;\n        if(co.sd < PRECISION || depth > end)\n            break;\n    }\n    co.sd = depth;\n    return co;\n}\n\nvec3 blinn_phong(vec3 lightDirection, vec3 normal, vec3 rd) {\n    vec3 lightColor = vec3 (1.,1.,1.);\n    //ambient\n    float ka = .4;\n    vec3 ia = lightColor;\n    vec3 ambient = ia * ka;\n\n    //diffuse\n    float kd = .5;\n    vec3 id = lightColor;\n    float diff = clamp(dot(lightDirection, normal), 0., 1.);\n    vec3 diffuse = kd * diff * id;\n\n    //specular\n    float ks = .5;\n    vec3 is = lightColor;\n    float alpha = 10.;\n    float dotRV = clamp(dot(reflect(-lightDirection, normal), -rd), 0., 1.);\n    vec3 specular = ks * pow(dotRV, alpha) * is;\n\n    return ambient + diffuse + specular;\n}\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv =  (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    vec3 backgroundColor = vec3(0.6);\n    vec2 mouseUV = iMouse.xy / iResolution.xy;\n  \n    if (mouseUV == vec2(0.0)) \n        mouseUV = vec2(0.5);\n\n    vec3 col = vec3(0.);\n    vec3 ro = vec3(0., -1., 6.5);\n    vec3 lp = vec3(0);\n\n    //camera\n    float cameraRadius = 2.;\n    ro.yz = ro.yz * cameraRadius * rotate2d(mix(-PI/2., PI/20., mouseUV.y));\n    ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z);\n    vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1));\n\n    Surface co = rayMarching(ro, rd, MIN_DIST, MAX_DIST);\n    if(co.sd > MAX_DIST) {\n        col = backgroundColor;\n    } else {\n        vec3 p = ro + co.sd * rd;\n        vec3 normal = computeNormal(p);\n\n        //light\n        vec3 lightPosition = vec3(0., 2., 3.);\n        vec3 lightDirection = normalize(lightPosition - p);\n        col = co.col * blinn_phong(lightDirection, normal, rd) + backgroundColor * .2;\n    }\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dySzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 541, 564, 564, 708], [710, 710, 733, 733, 877], [879, 879, 902, 902, 1046], [1048, 1059, 1100, 1100, 1183], [1185, 1185, 1231, 1231, 1314], [1316, 1316, 1369, 1369, 1561], [1563, 1563, 1615, 1615, 1808], [1810, 1817, 1862, 1862, 1921], [1923, 1923, 1971, 1971, 2080], [2082, 2082, 2117, 2117, 2149], [2151, 2151, 2215, 2215, 2288], [2290, 2290, 2359, 2359, 2664], [2666, 2666, 2709, 2709, 2810], [2812, 2812, 2869, 2869, 2992], [2994, 2994, 3039, 3070, 3219], [3222, 3222, 3271, 3271, 5192], [5194, 5194, 5235, 5235, 6545], [6547, 6547, 6585, 6597, 7571], [7573, 7573, 7611, 7611, 8357], [8359, 8359, 8393, 8393, 10225], [10227, 10227, 10252, 10329, 10466], [10468, 10468, 10496, 10496, 10803], [10805, 10805, 10868, 10868, 11174], [11176, 11176, 11237, 11237, 11773], [11775, 11775, 11803, 11803, 11873], [11875, 11875, 11922, 11922, 12086], [12088, 12088, 12143, 12143, 13144]]}
{"id": "7dyXD3", "name": "Jeff's carpet", "author": "nkaretnikov", "description": "Dedicated to my friend Jeff and his carpet.", "tags": ["2d", "simple", "carpet", "jeff"], "likes": 4, "viewed": 101, "published": "Public", "date": "1635391330", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Public domain.\n\n#define S(a, b, x) smoothstep(a, b, x)\n\nvec4 Band(vec4 col, float dist, float start, float end, float blur)\n{\n    float step1 = S(start - blur, start + blur, dist);\n    float step2 = S(end   + blur, end   - blur, dist);\n\n    col.a = step1 * step2;  // intersection\n    \n    return col;\n}\n\nvec4 Rect(vec4 col, vec2 uv, float left, float right, float bot, float top,\n          float blur)\n{\n    vec4 band1 = Band(col, uv.x, left, right, blur);\n    vec4 band2 = Band(col, uv.y, bot,  top,   blur);\n\n    col.a = band1.a * band2.a;  // intersection\n    \n    return col;\n}\n\nvec4 Carpet(vec4 col, vec4 figCol, vec2 uv, float blur)\n{\n    vec4 square  = Rect(figCol, uv, -.2, .2, -.2, .2, blur);\n    \n    vec4 hLineM  = Band(figCol, uv.y, -.073, .073, blur);\n    \n    vec4 vLineTR = Rect(figCol, uv, .35,   .5,  .2,   .5, blur);\n    vec4 vLineTL = Rect(figCol, uv, -.5, -.35,  .2,   .5, blur);\n    vec4 vLineBL = Rect(figCol, uv, -.5, -.35, -.5,  -.2, blur); \n    vec4 vLineBR = Rect(figCol, uv, .35,   .5, -.5,  -.2, blur); \n    vec4 hLineT  = Rect(figCol, uv, -.4,   .4, .35,   .5, blur);\n    vec4 hLineB  = Rect(figCol, uv, -.4,   .4, -.5, -.35, blur);\n    \n    vec4 hLineTR = Rect(figCol, uv, .4,   1.5,   .2, .35, blur);\n    vec4 hLineBR = Rect(figCol, uv, .4,   1.5, -.35, -.2, blur);\n    vec4 hLineTL = Rect(figCol, uv, -1.5, -.4,   .2, .35, blur);\n    vec4 hLineBL = Rect(figCol, uv, -1.5, -.4, -.35, -.2, blur);\n    \n    col = mix(col, square,  square.a);\n    col = mix(col, hLineM,  hLineM.a);\n    col = mix(col, vLineTR, vLineTR.a);\n    col = mix(col, vLineTL, vLineTL.a);\n    col = mix(col, vLineBL, vLineBL.a);\n    col = mix(col, vLineBR, vLineBR.a);\n    col = mix(col, hLineT,  hLineT.a);\n    col = mix(col, hLineB,  hLineB.a);\n    col = mix(col, hLineTR, hLineTR.a);\n    col = mix(col, hLineBR, hLineBR.a);\n    col = mix(col, hLineTL, hLineTL.a);\n    col = mix(col, hLineBL, hLineBL.a);\n\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Move (0, 0) to the center of the screen.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x / iResolution.y;  \n\n    // Draw the image.\n    vec4 col = vec4(.95, .87, .77, 1.);\n    \n    vec4 figCol = vec4(.37, .33, .3, 1.);\n    float blur  = .001;\n    \n    vec2 pq = uv * 4.;  // scaled coords\n    \n    // Middle.\n    for (int i = -10; i < 10; i += 2) {\n        float fi = float(i) * 1. + mod(iTime * 2., 2.);\n\n        vec4 c = Carpet(col, figCol, vec2(pq.x + fi, pq.y), blur);\n\n        col = c;    \n    }\n    \n    // Top.\n    for (int i = -10; i < 10; i += 2) {\n        float fi = float(i) * 1. - mod(iTime * 2., 2.);\n\n        vec4 ct = Carpet(col, figCol, vec2(pq.x + fi + 3., pq.y + 1.3), blur);\n\n        col = ct;\n    }\n    \n    // Bottom.\n    for (int i = -10; i < 10; i += 2) {\n        float fi = float(i) * 1. - mod(iTime * 2., 2.);\n\n        vec4 cb = Carpet(col, figCol, vec2(pq.x + fi + 3., pq.y - 1.3), blur);\n\n        col = cb;\n    }    \n    \n    // Return the color of this pixel.\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dyXD3.jpg", "access": "shaders20k", "license": "public-domain", "functions": [[0, 59, 128, 128, 306], [308, 308, 407, 407, 585], [587, 587, 644, 644, 1930], [1932, 1932, 1987, 2035, 3042]]}
{"id": "7dyXRz", "name": "Blobs experiment", "author": "AlexXIIs", "description": "Simple blobs, operations with colors.", "tags": ["blob", "wyvill"], "likes": 2, "viewed": 35, "published": "Public", "date": "1634240690", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Common\n\n\n// Hashing function\n// Returns a random number in [-1,1]\nfloat Hash(float seed)\n{\n  return fract(sin(seed)*43758.5453);\n}\n\n// Cosine direction\nvec3 Cosine(in float seed,in vec3 nor)\n{\n  float u=Hash(78.233+seed);\n  float v=Hash(10.873+seed);\n  \n  // method 3 by fizzer: http://www.amietia.com/lambertnotangent.html\n  float a=6.2831853*v;\n  u=2.*u-1.;\n  return normalize(nor+vec3(sqrt(1.-u*u)*vec2(cos(a),sin(a)),u));\n}\n\n// Rotation matrix around z axis\n// a : Angle\nmat3 rotate_z(float a)\n{\n  float sa=sin(a);float ca=cos(a);\n  return mat3(ca,sa,0.,-sa,ca,0.,0.,0.,1.);\n}\n\n// Compute the ray\n// m : Mouse position\n// p : Pixel\n// ro, rd : Ray origin and direction\nvoid Ray(in vec2 m,in vec2 p,out vec3 ro,out vec3 rd)\n{\n  float a=3.*3.14*m.x;\n  float le=3.8;\n  \n  ro=vec3(40.,0.,0.);\n  ro*=rotate_z(3.*3.14*m.x);\n  \n  vec3 ta=vec3(0.,0.,1.);\n  vec3 ww=normalize(ta-ro);\n  vec3 uu=normalize(cross(ww,vec3(0.,0.,1.)));\n  vec3 vv=normalize(cross(uu,ww));\n  rd=normalize(p.x*uu+p.y*vv+le*ww);\n}\n\n// Main\n\nconst int Steps=1000;\nconst float Epsilon=.05;// Marching epsilon\nconst float T=.5;\n\nconst float rA=10.;// Maximum and minimum ray marching or sphere tracing distance from origin\nconst float rB=40.;\n\n// Transforms\nvec3 rotateX(vec3 p,float a)\n{\n  float sa=sin(a);\n  float ca=cos(a);\n  return vec3(p.x,ca*p.y-sa*p.z,sa*p.y+ca*p.z);\n}\n\nvec3 rotateY(vec3 p,float a)\n{\n  float sa=sin(a);\n  float ca=cos(a);\n  return vec3(ca*p.x+sa*p.z,p.y,-sa*p.x+ca*p.z);\n}\n\nvec3 rotateZ(vec3 p,float a)\n{\n  float sa=sin(a);\n  float ca=cos(a);\n  return vec3(ca*p.x+sa*p.y,-sa*p.x+ca*p.y,p.z);\n}\n\nvec3 translateX(vec3 p, float a)\n{\n  return vec3(p.x+a, p.y, p.z);\n}\n\nvec3 translateY(vec3 p, float a)\n{\n  return vec3(p.x, p.y+a, p.z);\n}\n\nvec3 translateZ(vec3 p, float a)\n{\n  return vec3(p.x, p.y, p.z+a);\n}\n\n// Smooth cubic falloff function\n// x : distance\n// R : radius\nfloat falloff(float x,float R)\n{\n  float u=clamp(x/R,0.,1.);\n  float v=(1.-u*u);\n  return v*v*v;\n}\n\n// Primitives\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : radius\nfloat point(vec3 p,vec3 c,float e,float R)\n{\n  return e*falloff(length(p-c),R);\n}\n\nvec4 Segment(vec3 a, vec3 b, vec3 p, vec3 color)\n{\n    vec3 c = b-a;\n    vec3 u = c/sqrt(pow(c.x,2.)+pow(c.y,2.)+pow(c.z,2.));\n    float l = dot(p-a, u);\n    float v;\n    \n    if(l < 0.)\n      v = sqrt(pow(p.x-a.x,2.)+pow(p.y-a.y,2.)+pow(p.z-a.z,2.));\n    else if(l > 0. && l < sqrt(pow(c.x,2.)+pow(c.y,2.)+pow(c.z,2.)))\n      v = sqrt(pow(p.x-a.x,2.)+pow(p.y-a.y,2.)+pow(p.z-a.z,2.)-pow(l,2.));\n    else\n      v = sqrt(pow(p.x-b.x,2.)+pow(p.y-b.y,2.)+pow(p.z-b.z,2.));\n      \n    return vec4(falloff(v,0.5), color);\n}\n\nvec4 Circle(vec3 p, vec3 c, vec3 u, float R, vec3 color)\n{\n  vec3 n = p-c;\n  float h = dot(n, u);\n  float d = dot(n, n);\n  float y = d - dot(h,h);\n  y = R - sqrt(y);\n  //float v=pow(p.x-c.x,2.)+pow(p.y-c.y,2.)+pow(p.z-c.z,2.) - R;\n\n  return vec4(falloff(sqrt(y*y+h*h), 1.), color);\n}\n\nvec4 Sphere(vec3 p, vec3 c, float R, vec3 color)\n{\n  p.z=-p.z;\n  float v=point(p,c,1.,R);\n\n  return vec4(v, color);\n}\n\nvec4 Box(vec3 a, vec3 b, vec3 p, vec3 color)\n{\n  float dx;\n  float dy;\n  float dz;\n  \n  if(p.x > b.x)\n      dx = p.x - b.x;\n  else if(p.x < a.x)\n      dx = -p.x + a.x;\n  else\n      dx = 0.;   \n  if(p.y > b.y)\n      dy = p.y - b.y;\n  else if(p.y < a.y)\n      dy = -p.y + a.y;\n  else\n      dy = 0.;   \n  if(p.z > b.z)\n      dz = p.z - b.z;\n  else if(p.z < a.z)\n      dz = -p.z + a.z;\n  else\n      dz = 0.;   \n  \n  float v = sqrt(pow(dx,2.) + pow(dy,2.) + pow(dz,2.));\n  \n  return vec4(falloff(v, 0.5), color);\n}\n\n// Operators\n\n// Blending\n// a,b : field function of the sub-trees\nfloat Blend(float a,float b)\n{\n  return a+b;\n}\n\nvec4 ColorBlend(vec4 a,vec4 b)\n{\n  return vec4(a.x+b.x, ((a.yzw*a.x+b.yzw*b.x)/(a.x+b.x)));\n}\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Union(float a,float b)\n{\n  return max(a,b);\n}\n\nvec4 ColorUnion(vec4 a,vec4 b)\n{\n  vec3 color;\n  if(a.x>b.x)\n    color = a.yzw;\n  else\n    color = b.yzw;\n  return vec4(max(a.x,b.x), color);\n}\n\nfloat Intersection(float a,float b)\n{\n  return min(a,b);\n}\n\n\n// Potential field of the object\n// p : point\nvec4 Object(vec3 p)\n{\n  vec3 a = vec3(0., 0., -7.);\n  vec3 b = vec3(4., 4., -6.);\n  vec3 c = vec3(0., 0., 6.);\n  vec3 d = vec3(4., 4., 7.);\n  vec3 socleCenter1 = vec3(2.,2.,6.);\n  vec3 socleCenter2 = vec3(2.,2.,-6);\n  vec3 circleCenter1 = vec3(2.,2.,5.);\n  vec3 circleCenter2 = vec3(2.,2.,-5.);\n  vec3 ballCenter1 = vec3(2.,2.,2.);\n  vec3 ballCenter2 = vec3(2.,2.,-2.);\n  vec3 segment1 = vec3(2.,2.,5.);\n  vec3 segment2 = vec3(2.,2.,-5.);\n  vec3 n = vec3(0,0,1.);\n  float R = 3.5;\n  float RCircles = 2.;\n  vec3 colorBall1 = vec3(0.6,0.1,0.);\n  vec3 colorBall2 = vec3(0.3,0.,0.5);\n  vec3 colorCircle1 = vec3(0.6,0.1,0.);\n  vec3 colorCircle2 = vec3(0.3,0.,0.5);\n  vec3 grey = vec3(0.8,0.8,0.8);\n  \n  circleCenter1.z += sin(0.7*iTime)*4.-5.;\n  circleCenter2.z += cos(0.7*iTime)*4.+5.;\n  \n  ballCenter1.z += sin(0.7*iTime)*3.-3.;\n  ballCenter2.z += cos(0.7*iTime)*3.+3.;\n  ballCenter1.x += sin(5.*iTime)*2.;\n  ballCenter1.y += cos(5.*iTime)*2.;\n  ballCenter2.x -= cos(5.*iTime)*2.;\n  ballCenter2.y -= sin(5.*iTime)*2.;\n  \n  RCircles = RCircles + sin(0.5*iTime)-0.5;\n  \n  vec4 socle1 = ColorUnion(Box(a,b,p,grey), Sphere(p,socleCenter1,R,grey));\n  vec4 socle2 = ColorUnion(Box(c,d,p,grey), Sphere(p,socleCenter2,R,grey));\n  vec4 frame = ColorUnion(socle1, socle2);\n  vec4 circles = ColorBlend(Circle(p,circleCenter1,n,RCircles,colorCircle1),Circle(p,circleCenter2,n,RCircles,colorCircle2));\n  vec4 balls = ColorBlend(Sphere(p,ballCenter1,2.,colorBall1),Sphere(p,ballCenter2,2.,colorBall2));\n  vec4 w = ColorBlend(circles, balls);\n  w = ColorBlend(w, Segment(segment1,segment2,p,grey));\n  vec4 v = ColorUnion(frame, w);\n  \n  v.x = v.x-T;\n  return v;\n}\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p,out vec3 obj_color)\n{\n  float eps=.0001;\n  vec3 n;\n  vec4 V=Object(p);\n  float v = V.x;\n  obj_color = V.yzw;\n  n.x=Object(vec3(p.x+eps,p.y,p.z)).x-v;\n  n.y=Object(vec3(p.x,p.y+eps,p.z)).x-v;\n  n.z=Object(vec3(p.x,p.y,p.z+eps)).x-v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat Trace(vec3 o,vec3 u,float rB,out bool h,out int s)\n{\n  h=false;\n  \n  // Don't start at the origin, instead move a little bit forward\n  float t=rA;\n  \n  for(int i=0;i<Steps;i++)\n  {\n    s=i;\n    vec3 p=o+t*u;\n    float v=Object(p).x;\n    // Hit object\n    if(v>0.)\n    {\n      s=i;\n      h=true;\n      break;\n    }\n    // Move along ray\n    t+=Epsilon;\n    // Escape marched far away\n    if(t>rB)\n    {\n      break;\n    }\n  }\n  return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o,vec3 u,float rB,out bool h,out int s)\n{\n  h=false;\n  \n  // Don't start at the origin, instead move a little bit forward\n  float t=rA;\n  \n  for(int i=0;i<Steps;i++)\n  {\n    s=i;\n    vec3 p=o+t*u;\n    float v=Object(p).x;\n    // Hit object\n    if(v>0.)\n    {\n      s=i;\n      h=true;\n      break;\n    }\n    // Move along ray\n    t+=max(Epsilon,abs(v)/4.);\n    // Escape marched far away\n    if(t>rB)\n    {\n      break;\n    }\n  }\n  return t;\n}\n\n// Ambient occlusion\n// p : Point\n// n : Normal\n// a : Number of smaples\nfloat AmbientOcclusion(vec3 p,vec3 n,int a)\n{\n  if(a==0){return 1.;}\n  \n  float ao=0.;\n  \n  for(int i=0;i<a;i++)\n  {\n    vec3 d=Cosine(581.123*float(i),n);\n    \n    int s;\n    bool h;\n    float t=SphereTrace(p,d,10.,h,s);\n    if(!h){ao+=1.;}\n    else if(t>5.)\n    {\n      ao+=1.;\n    }\n  }\n  \n  ao/=float(a);\n  return ao;\n}\n\n// Background color\nvec3 background(vec3 rd)\n{\n  return mix(vec3(.652,.451,.995),vec3(.552,.897,.995),rd.z*.5+.5);\n}\n\nfloat Light(vec3 p,vec3 n)\n{\n  // point light\n  const vec3 lp=vec3(5.,10.,25.);\n  \n  vec3 l=normalize(lp-p);\n  \n  // Not even Phong shading, use weighted cosine instead for smooth transitions\n  float diff=pow(.5*(1.+dot(n,l)),2.);\n  \n  bool h;\n  int s;\n  float t=SphereTrace(p+.1*n,l,100.,h,s);\n  if(!h)\n  {\n    return diff;\n  }\n  return 0.;\n}\n\nfloat SmoothLight(vec3 p,vec3 n,int a)\n{\n  if(a==0)\n  return 1.;\n  \n  // point light\n  const vec3 lp=vec3(5.,10.,25.);\n  \n  vec3 l=normalize(lp-p);\n  \n  float lo=0.;\n  \n  for(int i=0;i<a;i++)\n  {\n    vec3 d=Cosine(581.123*float(i),n);\n    d=normalize(l+d*.15);\n    int s;\n    bool h;\n    float t=SphereTrace(p,d,10.,h,s);\n    if(!h){lo+=1.;}\n    else if(t>100.)\n    {\n      lo+=1.;\n    }\n  }\n  \n  lo/=float(a);\n  return lo;\n  \n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\nvec3 Shade(vec3 p,vec3 n)\n{\n  vec3 c=.25+.25*background(n);\n  c+=.15*AmbientOcclusion(p+.1*n,n,0)*vec3(1.,1.,1.);\n  c+=.35*Light(p,n);\n  return c;\n}\n\n// Shading with number of steps\nvec3 ShadeSteps(int n)\n{\n  float t=float(n)/(float(Steps-1));\n  return .5+mix(vec3(.05,.05,.5),vec3(.65,.39,.65),t);\n}\n\n// Picture in picture\n// pixel : Pixel\n// pip : Boolean, true if pixel was in sub-picture zone\nvec2 Pip(in vec2 pixel,out bool pip)\n{\n  // Pixel coordinates\n  vec2 p=(-iResolution.xy+2.*pixel)/iResolution.y;\n  if(pip==true)\n  {\n    const float fraction=1./4.;\n    // Recompute pixel coordinates in sub-picture\n    if((pixel.x<iResolution.x*fraction)&&(pixel.y<iResolution.y*fraction))\n    {\n      p=(-iResolution.xy*fraction+2.*pixel)/(iResolution.y*fraction);\n      pip=true;\n    }\n    else\n    {\n      pip=false;\n    }\n  }\n  return p;\n}\n\n// Image\nvoid mainImage(out vec4 color,in vec2 pxy)\n{\n  // Picture in picture on\n  bool pip=true;\n  \n  // Pixel\n  vec2 pixel=Pip(pxy,pip);\n  \n  // Mouse\n  vec2 m=iMouse.xy/iResolution.xy;\n  \n  // Camera\n  vec3 ro,rd;\n  Ray(m,pixel,ro,rd);\n  \n  // Trace ray\n  \n  // Hit and number of steps\n  bool hit;\n  int s;\n  \n  float t=SphereTrace(ro,rd,100.,hit,s);\n  \n  // Position\n  vec3 pt=ro+t*rd;\n  \n  // Shade background\n  vec3 rgb=background(rd);\n  \n  if(hit)\n  {\n    // Compute normal\n    vec3 obj_color;\n    vec3 n=ObjectNormal(pt, obj_color);\n    \n    // Shade object with light\n    rgb=Shade(pt,n) * obj_color;\n  }\n  \n  // Uncomment this line to shade image with false colors representing the number of steps\n  if(pip==true)\n  {\n    rgb=ShadeSteps(s);\n  }\n  \n  color=vec4(rgb,1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dyXRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[12, 69, 93, 93, 133], [135, 155, 195, 195, 430], [432, 478, 502, 502, 583], [585, 676, 731, 731, 1002], [1213, 1227, 1257, 1257, 1345], [1347, 1347, 1377, 1377, 1466], [1468, 1468, 1498, 1498, 1587], [1589, 1589, 1623, 1623, 1657], [1659, 1659, 1693, 1693, 1727], [1729, 1729, 1763, 1763, 1797], [1799, 1862, 1894, 1894, 1960], [1977, 2085, 2129, 2129, 2166], [2168, 2168, 2218, 2218, 2686], [2688, 2688, 2746, 2746, 2971], [2973, 2973, 3023, 3023, 3090], [3092, 3092, 3138, 3138, 3601], [3617, 3670, 3700, 3700, 3716], [3718, 3718, 3750, 3750, 3811], [3813, 3901, 3931, 3931, 3952], [3954, 3954, 3986, 3986, 4097], [4099, 4099, 4136, 4136, 4157], [4160, 4206, 4227, 4227, 5851], [5853, 5893, 5942, 5942, 6177], [6179, 6284, 6342, 6342, 6728], [6730, 6835, 6899, 6899, 7300], [7302, 7375, 7420, 7420, 7698], [7700, 7720, 7746, 7746, 7816], [7818, 7818, 7846, 7863, 8161], [8163, 8163, 8203, 8203, 8591], [8593, 8654, 8681, 8681, 8802], [8804, 8836, 8860, 8860, 8954], [8956, 9051, 9089, 9112, 9494], [9496, 9505, 9549, 9576, 10277]]}
{"id": "7dyXWc", "name": "ocean under", "author": "rockhard", "description": "underwater scene. no Caustics .U better play this in fullscreen mode with some background music,can help sleep :)", "tags": ["ocean"], "likes": 22, "viewed": 248, "published": "Public", "date": "1635399102", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float wavedx(vec2 position, vec2 direction, float time, float freq){\n    float x = dot(direction, position) * freq + time;\n    return exp(sin(x) - 1.0);\n}\n\nfloat getwaves(vec2 position){\n    float iter = 0.0,phase = 6.0,speed = 2.0;\n    float weight = 1.0,w = 0.0,ws = 0.0;   \n    for(int i=0;i<5;i++){\n        vec2 p = vec2(sin(iter), cos(iter));\n        float res = wavedx(position,p,speed*iTime,phase);        \n        w += res * weight; ws += weight;\n        iter += 12.0; weight *=0.75; phase *= 1.18; speed *= 1.08;\n    }\n    return w / ws;\n}\nfloat sea_octave(vec2 uv,float choppy){\nreturn getwaves(uv*choppy)+getwaves(uv); }\n\nfloat noise3D(vec3 p){ \n   vec3 s = vec3(7, 157, 113);\n   vec3 ip = floor(p); // Unique unit cell ID. \n   vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    p -= ip; // Cell's fractional component. \n    p = p*p*(3.0 - 2.0*p); \n    h = mix(fract(sin(h)*43758.5453),fract(sin(h + s.x)*43758.5453),p.x); \n    h.xy = mix(h.xz, h.yw, p.y); \n    return mix(h.x, h.y, p.z);\t\n}\n//borrowed from\n//https://www.shadertoy.com/view/Xs33Df\nfloat smaxP(float a, float b, float s){\n    float h = clamp(0.5 + 0.5*(a - b)/s,0.0,1.0);\n    return mix(b, a, h) + h*(1.0 - h)*s;\n}\nvec3 Freq=vec3(0.125,0.31,0.128),Amp= vec3(1.0,1.5,2.5);\nvec2 path(float z){ return vec2(Amp.x*sin(z * Freq.x),\n     Amp.y*cos(z * Freq.y) + Amp.z*(sin(z*Freq.z) - 1.0)); }\nfloat map(vec3 p){\n    float n=noise3D(p);\n    float tx =n;\n    vec3 q = p*0.35;//rock\n    float h = dot(sin(q)*cos(q.yzx),vec3(0.222)) \n       + dot(sin(q*1.5)*cos(q.yzx*1.5),vec3(0.111));    \n    float d = p.y+h*3.9;//some hills.   \n    q = sin(p*0.5 + h);\n    h = q.x*q.y*q.z; //tunnel walls.\n    p.xy -= path(p.z);//detail wall\n    float tnl = 1.5 - length(p.xy*vec2(.33, .66)) + (0.25 - tx*0.35);\t\n    return smaxP(d, tnl, 2.) - tx*.25 + tnl*.8;\n}\n\n#define STEP 36\n#define FAR 35.0\n\nfloat logBisectTrace(vec3 ro, vec3 rd){\n    float t = 0., told = 0., mid, dn;\n    float d = map(ro);\n    float sgn = sign(d);\n    for (int i=0; i<STEP; i++){\n       if (sign(d) != sgn || d < 0.001 || t > FAR) break; \n        told = t;\n        t += step(d,1.0)*(log(abs(d) + 1.1) - d) + d;        \n        d = map(rd*t + ro); }\n    // If a threshold was crossed without a solution, use the bisection method.\n    if (sign(d) != sgn){    \n        dn = sign(map(rd*told + ro));        \n        vec2 iv = vec2(told, t); // Near, Far\n        for (int ii=0; ii<5; ii++){ \n            mid = dot(iv,vec2(0.5));\n            float d = map(rd*mid + ro);\n            if (abs(d) < 0.001)break;\n            iv = mix(vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d*dn));\n        }\n        t = mid;       \n    }\n    return min(t,FAR);\n}\n\nvec3 normal(vec3 p,float t){ vec2 e = vec2(-t, t);   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t e.xyx*map(p + e.xyx) + e.y*map(p + e.y));   \n} \nvec3 rotY(vec3 v, float a){float c = cos(a),s = sin(a);\n    return vec3(c*v.x - s*v.z,v.y,s*v.x + c*v.z);}\n//borrowed from \n//https://www.shadertoy.com/view/4ls3zM \n//\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy-0.5;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    float time = iTime*0.2;\n   \n    vec3 pos = (sin(time*0.14)*2.0+4.5)*vec3(sin(time*0.5), 0.0, cos(time*0.5));\n    pos.z -= time;\n    pos.y += 0.7 * sin(time * 0.2);\n    float rot = -time*0.5;\n    vec3 dir = normalize(vec3(uv, -0.6));\n    dir = rotY(dir, rot);\n    \n    vec3 sun = vec3(-0.6, 0.5,-0.3); \n    float i = max(0.0, 1.2/(length(sun-dir)+1.0));\n    vec3 col = vec3(pow(i, 1.9), pow(i, 1.0), pow(i, .8)) * 1.25;\n    col = mix(col, vec3(0.0,0.39,0.62),(1.0-dir.y)*0.9);   \n\n     if (dir.y > 0.0){//water suf\n        float d = (pos.y-3.0)/dir.y;\t\n        vec2 wat = (dir * d).xz-pos.xz;\n        d += sin(wat.x + time);\n        wat = (dir * d).xz-pos.xz;     \n        wat = wat * 0.1 + 0.2* texture(iChannel0,wat*0.01).xz;      \n        col += sea_octave(wat,0.5)*0.6 * max(2.0/-d, 0.0);\n    }\n    else{//rock        \n       vec3 ro=pos;ro.y+=12.0;\n       \n       float t = logBisectTrace(ro,dir);\n       vec3 rock=vec3(0.0);\n       if (t < FAR){   \n        pos=ro+dir*t;\n        t/=FAR;\n        vec3 sn = normal(pos,0.1/(1.0 + t));\n        float fre = clamp(1.0+dot(sun, sn),0.0,1.0); // Fresnel reflection.\n        float Schlick = pow(1.0- max(dot(dir, normalize(dir + sun)),0.0), 5.0);\n        fre *= mix(0.2, 1.0, Schlick);//Hard clay.\n        float dif=dot(sn,sun)*0.2;    \n        rock=(dif*texture(iChannel0,pos.xz*0.05).xyz+fre*fre*0.35)*col;\n        float y=smoothstep(0.9,1.0,(1.0+dir.y)); \n        if(y>0.0) rock=mix(rock,col, y*t);     \n        col=mix(rock,col,t);\n      }\t\n      float f =(-dir.y-0.3+sin(time*0.05)*0.2)*0.3185;\n\t  f = clamp(f, 0.0, 1.0);\t\t\n\t  col = mix(col,rock,f);\n    }\n  \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dyXWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 68, 68, 154], [156, 156, 186, 186, 548], [549, 549, 588, 588, 631], [633, 633, 655, 655, 1005], [1006, 1062, 1101, 1101, 1194], [1252, 1252, 1271, 1271, 1367], [1368, 1368, 1386, 1386, 1820], [1856, 1856, 1895, 1895, 2673], [2675, 2675, 2703, 2703, 2843], [2845, 2845, 2872, 2872, 2951], [2952, 3013, 3070, 3070, 4805]]}
{"id": "7dyXzm", "name": "SolidTux - Newton Fractal", "author": "SolidTux", "description": "Newton fractal for 4th order polynomial. Drag mouse to set 4th point.", "tags": ["fractal"], "likes": 1, "viewed": 36, "published": "Public", "date": "1634418730", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define N 4\n#define ITER 5\n#define ITERNORM 4\n\nvec2 conj(in vec2 a) {\n    return vec2(a.x, -a.y);\n}\n\nvec2 cmul(in vec2 a, in vec2 b) {\n    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\nvec2 cdiv(in vec2 a, in vec2 b) {\n    return cmul(a, conj(b))/(b.x*b.x + b.y*b.y);\n}\n\nvec2 p(in vec2 z, in vec2[N] points) {\n    vec2 res = vec2(1., 0.);\n    for (int i=0; i<N; i++) {\n        res = cmul(res, z - points[i]);\n    }\n    return res;\n}\n\nvec2 pd(in vec2 z, in vec2[N] points) {\n    vec2 res = vec2(0., 0.);\n    for (int i=0; i<N; i++) {\n        vec2 tmp = vec2(1., 0.);\n        for (int j=0; j<N; j++) {\n            if (i!=j) {\n                tmp = cmul(tmp, z - points[j]);\n            }\n        }\n        res += tmp;\n    }\n    return res;\n}\n    \n\nvec2 newton(in vec2 z, in vec2[N] points) {\n    return z - cdiv(p(z, points), pd(z, points));\n}\n\nvec2 s(in vec2 x) {\n    vec2 z = 2.*(x/iResolution.xy - 0.5);\n    z.x *= iResolution.x/iResolution.y;\n    z *= mix(0.5, 1., 0.5*(sin(iTime) + 1.));\n    return z;\n}\n    \n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 z = s(fragCoord);\n    \n    // points and colors\n    vec2 points[N];\n    points[0] = vec2(sin(2.02*iTime), 0.62*cos(1.2*iTime));\n    points[1] = vec2(-1.76*sin(0.3*iTime), 1.3*cos(1.01*iTime));\n    points[2] = vec2(1.33*sin(1.02*iTime), -0.3*cos(1.7*iTime));\n    if (iMouse.z > 0.) {\n        points[3] = s(iMouse.xy);\n    } else {\n        points[3] = vec2(0.11*sin(1.31*iTime), 0.05*cos(0.72*iTime));\n    }\n    vec3 color[N];\n    color[0] = vec3(0.863,0.208,0.133);\n    color[1] = vec3(0.851,0.797,0.620);\n    color[2] = vec3(0.216,0.255,0.251);\n    color[3] = vec3(0.741,0.765,0.780);\n    int ind = 0;\n    \n    // iterations\n    float dis = 2.;\n    float scale = 1.;\n    for (int i=0; i<ITER; i++) {\n        z = newton(z, points);\n        // calculate distance to nearest point\n        for (int i=0; i<N; i++) {\n            float cur = length(z - points[i]);\n            if (cur < dis) {\n                ind = i;\n                dis = cur;\n            }\n        }\n        if (dis < 0.05) {\n            scale = mix(0.1, 1., float(clamp(i, 0, ITERNORM-1))/float(ITERNORM-1));\n            break;\n        }\n    }\n\n    // set color\n    vec3 col = color[ind] * scale;\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dyXzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 69, 69, 99], [101, 101, 134, 134, 191], [193, 193, 226, 226, 277], [279, 279, 317, 317, 440], [442, 442, 481, 481, 747], [754, 754, 797, 797, 849], [851, 851, 870, 870, 1014], [1021, 1021, 1076, 1076, 2280]]}
{"id": "7dyXzt", "name": "Fab25 #inktober2021 \"splat\"", "author": "FabriceNeyret2", "description": "[url]https://inktober.com/[/url]\n#inktober2021 themes: [img]https://i.imgur.com/QjhAdpd.png[/img]\n", "tags": ["2d", "rain", "splat", "drops", "short", "splash", "inktober2021"], "likes": 3, "viewed": 146, "published": "Public API", "date": "1635110884", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define H(p)      fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n#define T(t,s)  ( t < 1. ? t-s : fract(t-s) )                   // init vs steady rain\n\nvoid mainImage(out vec4 O, vec2 u ) \n{\n    vec2  R = iResolution.xy;\n    float N = 2., w = N/R.y, t = iTime/10.,\n          l = 9., d,a;\n    vec2  U = w* ( u+u - R ), D,P,_P,\n          I = floor(U), F = fract(U)-.5;\n          \n    O = .9*texture(iChannel0, 2.*u/R);                          // background\n    \n    int i=-1,k=0;\n    for( ; k < 9; k++ )                                         // check neighbor cells\n        D = vec2( k%3, k/3 )-1.,\n        T( t , H(I+D+.2).x ) > 0.                               // proba of splat\n          ? P = F - D - H(I+D),\n            d = dot(P,P),\n            d < l ? l = d, _P=P,i=k : k :k;                     // keep closest splat id\n        \n    i >= 0\n      ? a = atan(_P.y,_P.x),                                    // restore closest splat\n        D = vec2( i%3, i/3 )-1.,\n        F = H(I+D+.6)*.1, P = H(I+D+.4)*6.28,\n        l = length(_P) - .1-F.x  -.03* cos(3.*a+P.x) -.03* (1.+3.*F.y)*cos(7.*a+P.y), // splat shape\n        O = mix(O, vec4(.8,.8,1,1), .4* smoothstep(2.*min(fwidth(l),w),0., l )     // draw splat\n                                      * smoothstep(1.,0.,T( t , H(I+D+.2).x ) ) )  // fade over time\n      : O;\n    \n}\n", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dyXzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[168, 168, 206, 206, 1349]]}
{"id": "7dyXzw", "name": "interactive  newtonFractal", "author": "Lordinator", "description": "you can control 1 root", "tags": ["interactivecomplex"], "likes": 1, "viewed": 42, "published": "Public", "date": "1634402624", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define cmul(a,b) vec2((a).x * (b).x - (a).y * (b).y, (a).x * (b).y + (a).y * (b).x)\n\n#define pi 3.14159\n\n#define r1 vec2(0.        ,  3.)\n#define r2 vec2(2.85316955,  0.92705098)\n#define r4 vec2(1.76335576, -2.42705098)\n#define r5 vec2(-1.76335576, -2.42705098)\n\n\nvec2 r3 = vec2(0.0,0.9);\n\n#define c1 0x264653\n#define c2 0x2a9d8f\n#define c3 0xe9c46a\n#define c4 0xf4a261\n#define c5 0xe76f51\n\n\n#define sqLength(z) z.x*z.x + z.y*z.y\n\n#define rotSpeed 0.03\n\n\n#define inv(z) vec2(z.x,-z.y)/(z.x*z.x + z.y * z.y)\n\n#define f(z) cmul(cmul(cmul(cmul(z-r1,z-r2), z-r3), z-r4), z-r5);\n\nint iterationNb;\n//(x−a)(x−b)(x−c)(x−d)+(x−e)(x−b)(x−c)(x−d)\n//(x−e)(x−a)(x−c)(x−d)+(x−e)(x−a)(x−b)(x−d)\n//+(x−e)(x−a)(x−b)(x−c)\nvec2 fp(vec2 z){\n    vec2 zr1 = z-r1;\n    vec2 zr2 = z-r2;\n    vec2 zr3 = z-r3;\n    vec2 zr4 = z-r4;\n    vec2 zr5 = z-r5;\n    return cmul(cmul(cmul(zr1,zr2),zr3),zr4) + \n           cmul(cmul(cmul(zr5,zr2),zr4),zr3) +\n           cmul(cmul(cmul(zr4,zr1),zr3),zr4) + \n           cmul(cmul(cmul(zr4,zr1),zr2),zr4) + \n           cmul(cmul(cmul(zr5,zr1),zr2),zr3);\n}\n\n\nvec2 newtonReg(vec2 z){\n\n    for (int i = 0; i < iterationNb; i +=1){\n            vec2 fz = f(z);\n            z -= cmul(fz, (inv(fp(z))));\n    }\n    return z;\n}\n\n/*\n\th : given in radians.\n\ts : from 0 to 1.\n\tv : from 0 to 1.\n*/\nvec3 hsvToRgb(vec3 hsv){/* not understood but from wikipedia :\n\t\t\t\t\t\thttps://fr.wikipedia.org/wiki/Teinte_Saturation_Valeur */\n    float s = hsv.y;\n    float v = hsv.z;\n    \n    vec3 rgb;\n    hsv.x *= 180.f/pi;\n    hsv.x = mod(hsv.x,360.f);\n    int state = int(hsv.x/60.f)%6;\n    float f = hsv.x/60.f - float(state);\n    \n    float l = (1.f - s);\n    float m = (1.f - s * f);\n    float n = (1.f - (1.f-f) * s);\n\t\n    return v * vec3[](vec3(1,n,l),\n                 vec3(m,1,l),\n                 vec3(l,1,n),\n                 vec3(l,m,1),\n                 vec3(n,l,1),\n                 vec3(1,l,m))[state];\n}\n\nvec3 hexToCol(int hex){\n    return vec3(float((hex & 0xff0000) >> 16),\n                float((hex & 0x00ff00) >> 8),\n                float((hex & 0x0000ff)))/255.0;\n}\n\n\nvec3 coordToColor(vec2 z){    \n    float r1Closeness = sqLength((z-r1));\n    float r2Closeness = sqLength((z-r2));\n    float r3Closeness = sqLength((z-r3));\n    float r4Closeness = sqLength((z-r4));\n    float r5Closeness = sqLength((z-r5));\n    float closeness[5];\n    if (r1Closeness < r2Closeness &&\n        r1Closeness < r3Closeness &&\n        r1Closeness < r4Closeness &&\n        r1Closeness < r5Closeness){\n        return hexToCol(c1);\n    }\n    if (r2Closeness < r3Closeness &&\n        r2Closeness < r4Closeness &&\n        r2Closeness < r5Closeness){\n        return hexToCol(c2);\n    }\n    if (r3Closeness < r4Closeness &&\n        r3Closeness < r5Closeness){\n        return hexToCol(c3);\n    }\n    if (r4Closeness < r5Closeness){\n        return hexToCol(c4);\n    }\n    return hexToCol(c5);\n}\n\nvec2 pixToComplexPlane(vec2 pixCoord){\n    return 10.0 * (pixCoord/iResolution.xy-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float fastTime = 5.0 * iTime;\n    iterationNb = int(fastTime - 50.0 * floor(fastTime/50.0));\n    r3 = pixToComplexPlane(iMouse.xy);\n    vec2 ab = pixToComplexPlane(fragCoord);\n    vec3 col = coordToColor(newtonReg(ab));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dyXzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[593, 745, 761, 761, 1105], [1108, 1108, 1131, 1131, 1268], [1270, 1335, 1359, 1461, 1942], [1944, 1944, 1967, 1967, 2110], [2113, 2113, 2139, 2139, 2910], [2912, 2912, 2950, 2950, 3000], [3002, 3002, 3059, 3059, 3345]]}
{"id": "7l33zr", "name": "iYOYi - Ambient Occlusion ", "author": "iY0Yi", "description": "For the last few years I've been borrowing and using the ao function found on Shadertoy.\nI decided to write my own ao function and give it a try.", "tags": ["ao", "occlusion", "ambient"], "likes": 16, "viewed": 181, "published": "Public API", "date": "1635605571", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Shoe Model from my shader.\n// \"A man from 'A LOST MEMORY'\" by iYOYi:\n// https://www.shadertoy.com/view/Ws3yW4\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n#define PI 3.14159265\n#define TAU (2.0*PI)\n#define saturate(x) clamp(x, 0.0, 1.0)\n\n#define MIN_DIST 0.0001\n#define MAX_DIST 30.0\n#define ITERATION 100\n\n#define SHOW_ANIM 0\nvec3 ro = vec3(0), rd = vec3(0), camup;\n\n// Cheap Rotation by las:\n// http://www.pouet.net/topic.php?which=7931&page=1\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\nvec3 rot(vec3 p,vec3 r){\n    R(p.xz, r.y);\n    R(p.yx, r.z);\n    R(p.zy, r.x);\n    return p;\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 n, int rep){\n    float sum = 0.0;\n    float amp= 1.0;\n    for (int i = 0; i <rep; i++){\n        sum += noise(n) * amp;\n        n += n*4.0;\n        amp *= 0.25;\n    }\n    return sum;\n}\n\n// SDF functions by iq and HG_SDF\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// https://mercury.sexy/hg_sdf/\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat vmax(vec3 v){\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat sdBox( in vec2 p, in vec2 b ) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdEllipsoid(in vec3 p, in vec3 r) {\n    return (length(p/r)-1.0)*min(min(r.x,r.y),r.z);\n}\n\nfloat sdCappedTorus(vec3 p, vec2 r, float per) {\n    p.x = abs(p.x);\n    vec2 sc = vec2(sin(per),cos(per));\n    float k = (sc.y*p.x>sc.x*p.z) ? dot(p.xz,sc) : length(p.xz);\n    return sqrt( dot(p,p) + r.x*r.x - 2.0*r.x*k ) - r.y;\n}\n\nfloat sdBox(vec3 p,vec3 b) {\n    vec3 d=abs(p)-b;\n    return length(max(d,vec3(0)))+vmax(min(d,vec3(0.0)));\n}\n\nfloat fOpUnion(in float a,in float b) {\n    return a<b?a:b;\n}\n\nvec4 v4OpUnion(in vec4 a,in vec4 b) {\n    return a.x<b.x?a:b;\n}\n\nfloat fOpUnionSmooth(float a,float b,float r) {\n    vec2 u = max(vec2(r - a,r - b), vec2(0));\n    return max(r, min (a, b)) - length(u);\n}\n\nfloat fOpSubstraction(in float a,in float b) {\n    return max(-a, b);\n}\n\nfloat fOpSubstractionSmooth( float a,float b,float r) {\n    vec2 u = max(vec2(r + b,r + -a), vec2(0));\n    return min(-r, max (b, -a)) + length(u);\n}\n\nvoid pElongate(inout float p, in float h ) {\n    p = p-clamp(p,-h,h);\n}\n\nfloat sdFoot(vec3 p) {\n\tfloat d = MAX_DIST;\n\tfloat bsd = length(p), bsr=0.2500;\n\tif (bsd > 2.*bsr) return bsd-bsr;\n    \n\tvec3 cpFoot = p;\n\t{\n\t\tvec3 q = cpFoot;\n#if SHOW_ANIM\n        float patapata = -q.z*(sin(iTime*5.)*.5+.05)+cos(iTime*5.)*.5;\n#else\n        float patapata = -.3;\n#endif\n        q.yz*=mat2(cos(-q.z*1.25+patapata+vec4(0,11,33,0)));\n        cpFoot=q;\n\t}\n\tvec3 cpFoot_Main = cpFoot;\n\tcpFoot_Main.xyz += vec3(0.0000, 0.0000, 0.1273);\n\tpElongate(cpFoot_Main.y, 0.0125);\n\t{\n\t\tvec3 q=cpFoot_Main;\n        vec3 pq=q;pq.yz *= mat2(cos(.6 + vec4(0, 11, 33, 0)));\n        float ycl = smoothstep(.002,.2,q.y);\n        float zcl = 1.-smoothstep(-.2,.5,q.z);\n        float zcl2 = smoothstep(-.2,.0,q.z);\n        q.z+=fbm(vec2(pq.x*20.5,pq.y*80.), 1)*.075*ycl*zcl*zcl2;\n        cpFoot_Main=q;\n\t}\n\n    // Shoe\n    float d1,d2;\n\td1 = sdEllipsoid(rot(cpFoot_Main+vec3(-0.0005, 0.0274, 0.1042), vec3(0.0818, -0.6861, 0.0566)), vec3(0.1102, 0.1233, 0.1214));\n\td1 = fOpUnionSmooth(sdEllipsoid(rot(cpFoot_Main+vec3(0.0028, -0.0093, -0.1258), vec3(-0.0291, -0.2744, -0.0364)), vec3(0.0870, 0.2295, 0.0880)), d1, 0.1438);\n\td1 = fOpSubstractionSmooth(sdBox(cpFoot+vec3(0.0000, -0.194, 0.0019), vec3(0.1676, 0.0551, 0.1171)), d1, 0.0100);\n    d1 = fOpSubstractionSmooth(dot(cpFoot_Main, vec3(0,1,0)) - .00001, d1, 0.0080);\n\td1 = fOpSubstraction(sdBox(rot(cpFoot+vec3(0.0000, 0.0171, 0.1521), vec3(-1.4413, 0.0000, 0.0000)), vec3(0.1676, 0.0912, 0.0116)), d1);\n\td1 = fOpUnionSmooth(sdCappedTorus(cpFoot+vec3(0.0028, -0.1578, 0.0014), vec2(0.0519, 0.0264), 3.1413), d1, 0.0100);\n\t\n\t// Shoe lace\n\td2 = sdCappedTorus(rot(cpFoot+vec3(0.0000, -0.0579, 0.1827), vec3(1.5708, 0.0000, 0.0000)), vec2(0.0636, 0.0064), 0.6283);\n\td2 = fOpUnion(sdCappedTorus(rot(cpFoot+vec3(0.0000, -0.1001, 0.0608), vec3(2.2401, -0.3407, 0.2843)), vec2(0.0636, 0.0064), 0.6283), d2);\n\td2 = fOpUnion(sdCappedTorus(rot(cpFoot+vec3(0.0000, -0.0639, 0.1321), vec3(1.7335, 0.4446, -0.0513)), vec2(0.0636, 0.0064), 0.6283), d2);\n\td2 = fOpUnion(sdCappedTorus(rot(cpFoot+vec3(0.0000, -0.1001, 0.0608), vec3(2.2463, 0.3180, -0.2669)), vec2(0.0636, 0.0064), 0.6283), d2);\n\td2 = fOpUnion(sdCappedTorus(rot(cpFoot+vec3(0.0000, -0.0639, 0.1321), vec3(1.7334, -0.4468, 0.0515)), vec2(0.0636, 0.0064), 0.6283), d2);\n\t\n\treturn min(d1,d2);\n}\n\nfloat sdScene(vec3 p) {\n\n    return min(dot(p-vec3(0,-.026,0), vec3(0,1,0)) - .0001, sdFoot(p));\n}\n\nfloat intersect() {\n    float d = MIN_DIST;\n\n    for (int i = 0; i < 200; i++) {\n        vec3 p = ro + d * rd;\n        float res = sdScene(p);\n        res*=.5;\n        if (abs(res) < MIN_DIST)break;\n        d += res;\n        if (d >= MAX_DIST) return MAX_DIST;\n    }\n    if(d>MAX_DIST) return MAX_DIST;\n    return d;\n}\n\n// from iq's shader\nvec3 normal(vec3 p) {\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ ) {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdScene(p+0.0005*e);\n    }\n    return normalize(n);\n}\n\n\n// \"Hash without Sine\" by Dave_Hoskins:\n// https://www.shadertoy.com/view/4djSRW\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n// I found \"gain\" function in iq's article.\n// https://www.iquilezles.org/www/articles/functions/functions.htm\n// And modify it smoothstep like function.\nfloat gainstep(float edge0, float edge1, float x, float k) {\n    x = clamp((x-edge0)/(edge1-edge0), 0., 1.);\n    float a = .5*pow(2.*((x<.5)?x:1.-x), k);\n    return (x<.5)?a:1.-a;\n}\n\n// For the last few years I've been borrowing and using the ao function found on Shadertoy.\n// I decided to write my own ao function and give it a try.\n// I vaguely remembered the basic algorithm from various references I read about 10 years ago,\n// but I've forgotten the details and I'm sure it's incomplete.\nfloat ao(vec3 p, vec3 n, float radius, float threshold) {\n    \n    const float MAX_SAMP = 32.;\n    float ao = 0.;\n    \n    for(float i=0.; i<=MAX_SAMP; i++) {\n        vec2 rnd = hash21(i);\n        rnd = texture(iChannel0, vec2(i+1.,i-1.)/iChannelResolution[0].xy).xy;\n        // The contribution is adjusted according to the distance from the origin.\n        // http://john-chapman-graphics.blogspot.com/2013/01/ssao-tutorial.html\n        float scale = i/MAX_SAMP;\n        scale = mix(.1, 1., scale*scale);\n        \n        // radians for rotate normal in hemisphere.\n        rnd.x = (rnd.x*2.-1.)*PI*.5; // (-90 to 90 degrees)\n        rnd.y = (rnd.y*2.-1.)*PI*1.;    // (-180 to 180 degrees)\n        vec3 rd = n;\n        rd.yz *= mat2(cos(rnd.x), sin(rnd.x), -sin(rnd.x), cos(rnd.x));\n        rd.xz *= mat2(cos(rnd.y), sin(rnd.y), -sin(rnd.y), cos(rnd.y));\n        float raylen = radius * scale;\n        vec3 rndp = p + rd * raylen; // sampling position\n        float res = min(max(sdScene(rndp)/radius, 0.), 1.); // linear step 0 to 1\n        //res = pow(res, scale);\n        ao += res;\n    }\n    \n    ao /= float(MAX_SAMP) * threshold;\n    \n    return (ao<.5) ? min(max(ao, 0.), 1.) : gainstep(0., 1., ao, 1.5); // smooth threshold.\n}\n\n\n// \"camera\": create camera vectors.\nvoid camera(vec2 uv) {\n    const float pY = .5;\n    const float cL = 10.;\n    const vec3 forcus = vec3(0,.06,-.137);\n    const float fov = .0175;\n\n    vec3 up = vec3(0,1,0);\n    vec3 pos = vec3(0,5.8,0);\n    pos.xz = vec2(sin(iTime*.6),cos(iTime*.6))*cL;\n    if(iMouse.z>.5)\n        pos = vec3(sin(iMouse.x/iResolution.x*TAU),sin(iMouse.y/iResolution.y*TAU),cos(iMouse.x/iResolution.x*TAU))*cL;\n    vec3 dir = normalize(forcus-pos);\n    vec3 target = pos-dir;\n    vec3 cw = normalize(target - pos);\n    vec3 cu = normalize(cross(cw, up));\n    vec3 cv = normalize(cross(cu, cw));\n\tcamup = cv;\n    mat3 camMat = mat3(cu, cv, cw);\n    rd = normalize(camMat * normalize(vec3(sin(fov) * uv.x, sin(fov) * uv.y, -cos(fov))));\n    ro = pos;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = (uv*2.-1.);\n    uv.x *= iResolution.x / iResolution.y;\n\n    camera(uv);\n    float hit = intersect();\n    vec3 p = ro + hit * rd;\n\n    vec3 n = normal(p);\n\n    //float ao = ao(p, n, (sin(iTime*2.)+1.1)*.05, iMouse.y/iResolution.y);\n    float ao = ao(p, n, .035, .35);\n    \n    fragColor.rgb = vec3(pow(ao, .4545));\n\tfragColor.a = 1.;\n}\n\n", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l33zr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[399, 526, 550, 550, 620], [622, 622, 642, 642, 714], [716, 716, 742, 742, 1078], [1080, 1080, 1107, 1107, 1278], [1280, 1489, 1508, 1508, 1546], [1548, 1548, 1585, 1585, 1665], [1667, 1667, 1708, 1708, 1762], [1764, 1764, 1812, 1812, 1995], [1997, 1997, 2025, 2025, 2106], [2108, 2108, 2147, 2147, 2169], [2171, 2171, 2208, 2208, 2234], [2236, 2236, 2283, 2283, 2374], [2376, 2376, 2422, 2422, 2447], [2449, 2449, 2504, 2504, 2598], [2600, 2600, 2644, 2644, 2671], [2673, 2673, 2695, 2695, 4961], [4963, 4963, 4986, 4986, 5061], [5063, 5063, 5082, 5082, 5381], [5383, 5403, 5424, 5522, 5719], [5722, 5803, 5825, 5825, 5954], [5955, 5955, 5977, 5977, 6110], [6112, 6266, 6326, 6326, 6447], [6449, 6760, 6817, 6817, 7997], [8000, 8036, 8058, 8058, 8770], [8772, 8772, 8827, 8827, 9216]]}
{"id": "7lcGRr", "name": "Happy Pumpkin", "author": "space928", "description": "It's a 3D pumpkin!", "tags": ["3d", "raymarching"], "likes": 3, "viewed": 128, "published": "Public API", "date": "1635597016", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MARCHSTEPS = 128;\nconst float MAX_DIST = 64.;\nconst float EPSILON = 0.01;\nconst vec3 pos = vec3(0.,0.0,-3.);\nconst vec3 posTime = vec3(0.,0.0,0.);\nconst vec3 lightDir = vec3(0.6,0.6,-0.6);\nconst float rotRate = 1.;\nconst float pi = 3.1415926535;\n\n//https://www.iquilezles.org/www/articles/smin/smin.htm\nvec2 sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    float m = h*h*h*0.5;\n    float s = m*k*(1.0/3.0); \n    return (a<b) ? vec2(a-s,m) : vec2(b-s,1.0-m);\n}\n\n//https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\n//https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\n//https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat map(vec3 p)\n{\n    //Body\n    vec3 pa = p-pos;\n    p.y *= 1.1;\n    float angle = atan(p.x, p.z);\n    float centreDist = length(p.xz);\n    float radMod = sin(angle*16.)*0.03;\n    radMod += sin(angle*120.)*0.001;\n    radMod *= (centreDist*centreDist);\n    radMod -= (smoothstep(1.2, -.8, centreDist))*0.5;\n    float d = sdSphere(p, 1. + radMod);\n    \n    //Stem\n    //Domain bending from:\n    float radMod2 = sin(angle*9.)*0.03;\n    radMod2 += sin(angle*23.)*0.005;\n    radMod2 *= smoothstep(0.02, 0.1, centreDist*centreDist);\n    radMod2 += sin(-p.x*12.)*0.05+sin(p.y*5.-1.)*0.03+sin(p.z*25.)*0.01;\n    d = sminCubic(d, sdVerticalCapsule(p, 1.1, 0.15+radMod2), 0.1).x;//sminCubic();\n    \n    //Eyes\n    d = max(d, -sdTriPrism(vec3(abs(p.x),p.y,p.z)-vec3(0.3,0.2,-1.), vec2(0.15, 1.5)));\n    \n    //Mouth\n    vec2 c = vec2(sin(0.5), cos(0.5));\n    d = min(d, sdCappedTorus(vec3(p.x,-p.y,p.z)-vec3(0.,-0.2,-0.97), c, 0.35, 0.08));\n    \n    return d;\n}\n\nfloat trace(vec3 o, vec3 r) {\n    float t = 0.0;\n    \n    for( int i=0;i<MARCHSTEPS;i++ ) {\n        vec3 p = o + r * t;\n        \n        float d = map(p);\n        \n        if(t > MAX_DIST) {\n            t = -1.0;\n            break;\n        }\n        \n        t += d;\n    }\n    return t;\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        map(vec3(p.x + EPSILON, p.y, p.z)) - map(vec3(p.x - EPSILON, p.y, p.z)),\n        map(vec3(p.x, p.y + EPSILON, p.z)) - map(vec3(p.x, p.y - EPSILON, p.z)),\n        map(vec3(p.x, p.y, p.z  + EPSILON)) - map(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nmat3 rotY(float x)\n{\n    return mat3(cos(x), 0., sin(x),\n                0., 1., 0.,\n                -sin(x), 0., cos(x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 r = normalize(vec3(uv, 2.0))*rotY(iTime*rotRate);\n    vec3 o = pos*rotY(iTime*rotRate) + (iTime*posTime);\n    vec3 t = vec3(trace(o, r));\n    vec3 p = (o+r*t);\n    vec3 nrm = estimateNormal(p);\n\n    vec3 fog = vec3(0.);\n    if(t != vec3(-1.))\n    {\n        fog = 1.0 / (1.0 + t * t * 0.05);\n        fog *= clamp(dot(lightDir, nrm), 0., 1.) + vec3(0.1,0.1,0.15);\n        fog *= vec3(1., .5, .02);\n    }\n\n    // Output to screen\n    fragColor = vec4(fog,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lcGRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[257, 313, 358, 358, 505], [507, 581, 651, 651, 791], [793, 867, 920, 920, 979], [981, 1055, 1091, 1091, 1174], [1176, 1176, 1209, 1209, 1235], [1237, 1237, 1256, 1267, 2190], [2192, 2192, 2221, 2221, 2480], [2482, 2482, 2511, 2511, 2791], [2793, 2793, 2813, 2813, 2917], [2919, 2919, 2976, 3026, 3604]]}
{"id": "7lt3zn", "name": "Shader royale@inercia 2021 entry", "author": "Exca", "description": "My entry to the point of dropping out for inercia 2021 shader royale.", "tags": ["raymarch", "twister"], "likes": 4, "viewed": 48, "published": "Public", "date": "1635631011", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat fft = 0.0;\nfloat ffts = 0.0;\nfloat ffti = 0.0;\nfloat beat = 0.0;\nfloat beatstep = 0.0;\n\nvec3 repeat( vec3 p, vec3 c)\n{\n  vec3 q = vec3(0.0);\n  vec3 q2 = mod( p+ 0.5*c,c)-0.5*c;\n  return q2;\n}\n\nvec3 rotate( vec3 p, float x, float y, float z){\n  mat3 rotx = mat3(1.0, 0.0, 0.0, 0.0, cos(x), -sin(x), 0.0, sin(x), cos(x));\n  mat3 roty = mat3( cos(y), 0.0, sin(y), 0.0, 1.0, 0.0, -sin(y), 0.0, cos(y));\n  mat3 rotz = mat3( cos(z), -sin(z), 0.0, sin(z), cos(z), 0.0, 0.0, 0.0, 1.0);\n  \n  return rotx*roty*rotz*p;\n}\n\n\n\nvec3 smoothUnion(vec3 a, vec3 b, float k)\n{\n  float h = clamp(0.5 + 0.5*(b.x-a.x)/k,0.0, 1.0);\n  float d = mix(b.x,a.x,h)-k*h*(1.0-h);\n  float s = step(a.x, b.x);\n  return vec3(d, mix(a.y, b.y, s),0.0);\n}\n\nvec3 getcam( vec3 cam, vec3 target, vec2 uv, float fov)\n{\n  vec3 forward = normalize(target-cam);\n  vec3 right = normalize(cross(vec3(0,1,0), forward));\n  vec3 up = normalize(cross(forward, right));\n  \n  return normalize( forward*fov + right*uv.x + up*uv.y);\n}\n\nfloat sphere( vec3 p, float r){\n  return length(p)-r;\n}\n\nfloat roundcube( vec3 p, vec3 b, float r){\n  vec3 d = abs(p)-b;\n  return min( max( d.x, max( d.y, d.z) ), 0.0)+length(max(d,0.0))-r;\n}\n\nfloat ground( vec3 p, float h){\n  return p.y -h;\n}\nvec3 Union(vec3 a, vec3 b){\n  return a.x < b.x ? a : b;\n}\n\nvec3 map( vec3 p ){\n  \n  vec2 id = floor(p.xz/8.0+0.5);\n  \n  vec3 cp = rotate(\n    repeat(p, vec3(8.0, 0.0, 8.0)), \n    sin(p.y*0.1)*0.2, \n    ffts*sin(id.y+id.x+ ffti*4.0+ iTime+p.y+ffti*5.0)*2.0+sin(iTime*0.33+p.y-ffti*2.0)*4.0+ffti*5.0, \n    cos(p.y*0.1)*0.2 \n\n  );\n  vec3 c = vec3( roundcube(cp, vec3(0.4, 29.0, 0.4), 0.2), 1.0, 0.0);\n  \n  float h1 = texture(iChannel0, p.xz*0.1+vec2(iTime*0.01-ffti*0.25, iTime*0.015)).r*0.5* (0.5+fft*1.0);\n  float h2 = texture(iChannel0, p.xz*0.1+vec2(iTime*0.015+0.17*ffti, -iTime*0.015)).r*0.5 * (0.25+ffts*2.0);\n  \n  float h = mix(h1,h2,0.5);\n  \n  vec3 gr = vec3( ground(p, h*2.0), 2.0, h);\n  \n  return smoothUnion(c,gr,2.5);\n  \n  return vec3(sphere(p, 0.5), 1.0, 0.0);\n}\nvec3 normal( vec3 p ){\n  vec3 c = map(p);\n  vec2 e = vec2( 0.1, 0.0);\n  return normalize( vec3(\n    map(p+e.xyy).x,\n    map(p+e.yxy).x,\n    map(p+e.yyx).x\n  )-c.x);\n}\n\nfloat diffuse( vec3 p , vec3 l, vec3 n){\n  return max(0.0, dot(n, normalize(l-p)));\n}\n\nvec3 march(vec3 cam, vec3 rd, out vec3 p, out float t)\n{\n  for(int i = 0; i < 100; i++)\n  {\n    p = cam + rd*t;\n    vec3 r = map(p);\n    t+=r.x;\n    if(r.x < 0.01){\n      return r;\n    }\n    if(t > 50.0){\n      t = 50.0;\n      return vec3(-1.0);\n    }\n  }\n  t = 50.0;\n  return vec3(-1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(gl_FragCoord.x / iResolution.x, gl_FragCoord.y / iResolution.y);\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n\n\tvec3 col = vec3(1.0);\n  \n  // Disabled ffts&i as no continous/smooth one\n  fft = texture(iChannel1, vec2(0.25,0.5)).r*0.25;\n  ffts = fft*0.0;\n  ffti = fft*0.0;\n  //ffts = texture(iChannel1, vec2(0.25,0.5)).r;\n  ///ffti = texture(iChannel1, vec2(0.25,0.5)).r;\n  \n  beat = floor(iTime*1.45);\n  beat = mod( beat/4.0, 8.0);\n  beatstep = fract( iTime*2.0);\n  \n  float travel = 3.0;\n  \n  float time = iTime*0.2;\n  \n  vec3 cam = vec3(\n    sin(time)*6.,\n    2. + cos(time),\n    cos(time)*6.+time\n  );\n  vec3 target = vec3(\n    0.0, \n    1.5+  cos(time*0.5), \n    time + cos(time*4.0)\n  );\n  vec3 light = vec3( sin(iTime)+5.0, 4.0, time+sin(time));\n  float fov = 0.5;\n  \n  \n  if(beat < 2.0){\n    uv*= sin(uv);\n  }\n  else if(beat < 4.0){\n    uv *= 1.0 + sin(uv.x*20.0 + time)*0.2 + cos(uv.y*20. + time)*0.2;\n  }\n  else if(beat < 6.0){\n    uv *= 1.0 - sin(uv.x*20.0 + time)*0.2 - cos(uv.y*20. - time)*0.2;  \n  }\n  \n  \n  vec3 rd = getcam( cam, target, uv, fov);\n  \n  \n  \n  vec3 p = vec3(0.0);\n  vec3 res = march( cam, rd, p, travel);\n  \n  vec3 n = normal(p);\n  if(res.y < 0.5){\n    // Bg\n  }\n  else if(res.y < 1.5){\n    //ground mat\n    col = vec3(0.0,0.7,0.9)*diffuse(p, light, n);\n  }\n  else if(res.y < 2.5){\n    //twister\n    float ly = abs(sin((p.y+iTime)*10.0));\n    col = mix(vec3(0.0,0.7,0.9), vec3(1.0, 0.7, 0.0), res.z*0.5)*diffuse(p, light, n);\n    col += smoothstep(1.0, 4.0, p.y)*(0.5/ly);\n  }\n  \n  col = mix( col, vec3(0.0,0.45,0.90), smoothstep( 10.0, 20.0, travel));\n  \n  \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4df3Rn", "previewfilepath": "/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lt3zn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[95, 95, 125, 125, 198], [200, 200, 248, 248, 516], [520, 520, 563, 563, 724], [726, 726, 783, 783, 986], [988, 988, 1019, 1019, 1043], [1045, 1045, 1087, 1087, 1179], [1181, 1181, 1212, 1212, 1231], [1232, 1232, 1259, 1259, 1289], [1291, 1291, 1310, 1310, 2005], [2006, 2006, 2028, 2028, 2172], [2174, 2174, 2214, 2214, 2259], [2261, 2261, 2317, 2317, 2551], [2554, 2554, 2611, 2611, 4289]]}
{"id": "7s3SDM", "name": "pulsating gradient line", "author": "SET001", "description": "pulsating gradient line", "tags": ["gradient"], "likes": 0, "viewed": 94, "published": "Public", "date": "1633294920", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 position = fragCoord/iResolution.xy;\n    float glow_length=cos(iTime*4.+position.x*3.)*.03+.05;\n    float green=0.;\n\n    green=1.-position.y/glow_length+(1./glow_length/2.);\n    if(position.y<.5){\n      green=position.y/glow_length-(1./glow_length/2.-1.);\n    }\n\n    // Output to screen\n    fragColor = vec4(0.,green,0.,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s3SDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 443]]}
{"id": "7s3SDX", "name": "landscape box fbm", "author": "drschizzo", "description": "from https://iquilezles.org/www/articles/fbmsdf/fbmsdf.htm", "tags": ["raymarching"], "likes": 0, "viewed": 80, "published": "Unlisted", "date": "1634397824", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define lin2sRGB(x) ( x <= .0031308 ? (x)*12.92 : 1.055*pow(x,1./2.4) - .055 )\n\n\nconst float ANIM_SPEED=5.;\n\n\nconst float SEED=3.42;\n\nconst int MAX_STEP=50;\nconst float MIN_DIST=.0001;\nconst float MAX_DIST=80.;\n\n\nstruct Light{\n    vec3 pos;\n    float intensity;\n    vec3 color;\n};\n\nstruct Hit{\n    float dist;\n    vec4 objId;\n    vec3 pos;\n    vec3 normal;    \n};\n\n//  from DAVE HOSKINS\nvec3 N13_(float p) {\n    p=p*SEED;\n    vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\nreturn fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat hash1( vec2 p )\n{\n    p  = 50.0*fract( p*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat hash1( float n )\n{\n    return fract( n*17.0*fract( n*0.3183099 ) );\n}\n\nvec2 hash2( vec2 p ) \n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    float n = 111.0*p.x + 113.0*p.y;\n    return fract(n*fract(k*n));\n}\n\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y*1.)), tri(p.z+tri(p.x*1.)), tri(p.y+tri(p.x*1.)));}\n                                 \n\nfloat triNoise3d(in vec3 p, in float spd)\n{\n    float z=1.4;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i=0.; i<=3.; i++ )\n\t{\n        vec3 dg = tri3(bp*2.);\n        p += (dg+iTime*spd);\n\n        bp *= 1.8;\n\t\tz *= 1.5;\n\t\tp *= 1.2;\n        \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\n        bp += 0.14;\n\t}\n\treturn rz;\n}\n\n\n\nfloat getzoffset(){\n   return iTime/ANIM_SPEED;\n}\n\nmat2 rotate2D(float r){\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\n\nfloat map01(float min,float max, float val){\n    return val=clamp((val-min)/(max-min),0.,1.);\n}\n\n \n\n//from https://www.iquilezles.org/www/articles/smin/smin.htm\nvec2 sminN( float a, float b, float k, float n )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    float m = pow(h, n)*0.5;\n    float s = m*k/n; \n    return (a<b) ? vec2(a-s,m) : vec2(b-s,m-1.0);\n}\n\nfloat computeId(vec3 p,vec3 rep){\n   \n    return dot(floor((rep*.5+p)/rep),vec3(1.,10.,100.));\n    \n}\n\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\n\n// https://iquilezles.org/www/articles/fbmsdf/fbmsdf.htm\nfloat sph( vec3 i, vec3 f, vec3 c )\n{\n    // random radius at grid vertex i+c (please replace this hash by\n    // something better if you plan to use this for a real application)\n    vec3  p = 17.0*fract((i+c)*0.3183099+vec3(0.11,0.17,0.13));\n    float w = fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n    float r = 0.7*w*w;\n    return sdBox(f-c,vec3( r));//*(.5+.5*sin(iTime)))); \n}\n\n// https://iquilezles.org/www/articles/fbmsdf/fbmsdf.htm\nfloat sdBase( in vec3 p )\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    return min(min(min(sph(i,f,vec3(0,0,0)),\n                       sph(i,f,vec3(0,0,1))),\n                   min(sph(i,f,vec3(0,1,0)),\n                       sph(i,f,vec3(0,1,1)))),\n               min(min(sph(i,f,vec3(1,0,0)),\n                       sph(i,f,vec3(1,0,1))),\n                   min(sph(i,f,vec3(1,1,0)),\n                       sph(i,f,vec3(1,1,1)))));\n}\n\n// https://iquilezles.org/www/articles/fbmsdf/fbmsdf.htm\nvec2 sdFbm( in vec3 p, in float d )\n{\n    // rotation and 2x scale matrix\n    const mat3 m = mat3( 0.0,  1.60,  1.20,\n                        -1.23,  0.72, -0.96,\n                        -1.20, -0.76,  1.28 );\n    vec3  q = p;\n    float t = 0.0;\n\tfloat s = 2.*(.6+.4*(sin(p.z*.5)*sin(p.x*.5)));\n     int ioct = int(floor(12.*(.5+.5*sin(iTime))));\n    for( int i=0; i<10; i++ )\n    {\n        if( d>s*.5) break; // early exit\n       // if( s<th ) break;      // lod\n        \n        float n = s*sdBase(q);\n        n = smax(n,d-0.1*s,0.2*s);\n        d = smin(n,d      ,0.2*s);\n        q = m*q;\n        s = 0.415*s;\n\n        t += d; \n        q.z += -2.33*t*s; // deform things a bit\n    }\n    return vec2( d, t );\n}   \n\n\nHit getDist(vec3 p,bool checkplane){\n  /*  p=p+vec3(0,0,getzoffset());\n    p.xz*=rotate2D(iTime/30.);\n    p+=vec3(0,0,-getzoffset());*/\n    float objId=1.;\n    vec3 col=vec3(1.);\n    float dist=MAX_DIST;\n    dist=min(dist,p.y+.2);\n    dist=min(dist,sdFbm(p,dist).x);\n    if(checkplane){\n    float delta=triNoise3d(p,.2)*.01;//(dist)/3.;\n    dist=min(dist,p.y+.1+delta);\n    if(p.y<-(.099-2.*delta))\n        objId=2.;\n    }\n  //  dist=smin(dist,length(p-vec3(0,1.,2.-getzoffset()))-1.5,1.);\n    return Hit(dist,vec4(objId,col),vec3(0),vec3(0));\n}\n\nHit getDist(vec3 p){\n    return getDist(p,true);\n}\n\n\nvec3 getNormal(vec3 pos){\n    vec2 e=vec2(.0001,0);\n    float dist=getDist(pos).dist;\n    vec3 n=vec3(\n        dist-getDist(pos-e.xyy).dist,\n        dist-getDist(pos-e.yxy).dist,\n        dist-getDist(pos-e.yyx).dist);\n    return normalize(n);\n}\n\n\n\n\nHit rayMarch(vec3 o,vec3 ray,float speed){\n    float totalDist=0.;\n    Hit hit;\n    \n    \n    for(int i=0;i<MAX_STEP;i++){\n        vec3 p=o+totalDist*ray;\n        hit=getDist(p);\n        totalDist+=hit.dist*speed;\n        if(hit.dist<MIN_DIST*speed||totalDist>MAX_DIST) break ;\n    }\n    if(totalDist<MAX_DIST){\n        vec3 pos=o+ray*totalDist;\n        return Hit(totalDist,hit.objId,pos,vec3(0.));\n    }\n    else{\n        return Hit(totalDist,vec4(-1),vec3(0),vec3(MAX_DIST));\n    }\n    \n}\n\nHit rayMarch(vec3 o,vec3 ray){\n return rayMarch(o,ray,1.);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n\n    for( float t=MIN_DIST; t<MAX_DIST; )\n    {\n        float h = getDist(ro + rd*t,false).dist;\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\nfloat computeao(vec3 ro, vec3 rd)\n {\n    //return 1.;\n    float tot = 0.;\n\n    float fact = 1.0;\n    for (float i = 0.; i < 5.; i++)\n    {\n\n        float hr = 0.01 + 0.01 *i;\n        vec3 p = ro + rd * hr;\n        float d = getDist(p,false).dist;\n        float ao = clamp((d*5.), 0.0, 1.0);\n\n        tot += ao * fact;\n        fact *= 0.75;\n    }\n\n    tot = 1.0 - clamp(tot*4., 0.1, .8);\n    return tot;\n }\n\n\n\n\nvec2 getmousePos(){\n    return(vec2(sin(iTime),.4+.6*cos(iTime)));\n   // return ((iMouse.xy-.5*iResolution.xy)/iResolution.y);\n\n}\n\nvec3 computeLighting(vec3 hitPos,vec3 n,vec3 ray){\n\n  float zoffset=getzoffset();\n  vec3 sunpos=vec3(getmousePos()*20.,30.-getzoffset());\n  vec3 suncolor=mix(vec3(1.),vec3(.9,.4,.1),dot(normalize(sunpos),vec3(0,1,0)));\n  vec3 sunDir=normalize(sunpos-hitPos);\nfloat occ = computeao( hitPos, n );\nfloat sha = softshadow( hitPos+n*.01, sunDir,20.);\nfloat sun = clamp( dot( n, sunDir ), 0.0, 1.0 );\nfloat sky = clamp( 0.5 + 0.5*n.y, 0.0 ,1.0 );\nfloat ind = clamp( dot( n, normalize(sunDir*vec3(-1.0,0.0,-1.0)) ), 0.0, 1.0 );\n\nvec3 lin  = sun*suncolor*sha;//pow(vec3(sha),vec3(1.0,1.2,1.5));\n        lin += sky*vec3(0.16,0.20,0.28)*occ;\n        lin += ind*vec3(0.40,0.28,0.20)*occ;\n\n       return lin;\n}\n\n\n\n\n\nvec4 render(vec3 ray,Hit hit){\n\n \n    \n  //  Hit hit=rayMarch(ro,ray);\n    hit.normal=getNormal(hit.pos);//hit.objId.x!=2. && hit.objId.x!=-1.?getNormal(hit.pos):vec3(0,1.,0);//normalize(vec3(1.*(.5+.5*cos(hit.pos.x*10.)),1.*(.5+.5*sin(hit.pos.z*100.)),1.*(.5+.5*-cos(hit.pos.x*10.))));\n\n\n    \n\n        vec3 sunpos=vec3(getmousePos()*40.,30.-getzoffset());\n\n    \n    float fogAmount = 1.0 - exp( -hit.dist*.2 );\n    float sunAmount = max( dot(normalize(sunpos), vec3(0,1.,0) ), 0. );\n    vec3  fogColor  = mix( vec3(0.8,0.4,0.3), \n                           vec3(.15,0.4,0.8), \n                           pow(min(sunAmount*(2.-dot(normalize(vec3(0,-sunpos.y,0)),ray))*5.,1.),8.)) ;\n    \n    vec3 saveray=ray;\n    \n    \n    \n    vec3 colSphere;\n    \n    //vec3 fog=vec3(.2,.3,.9);\n//   fog=mix(fog/10.,fog,sunincident);\n//    fog*=(map01(0.,4.,hit.pos.z+getzoffset()));\n    //only compute reflexion on close objects\n    \n    if(hit.objId.x>-1.){\n     //   if(hit.objId.x!=2.)hit.normal*=-1.;\n        vec3 col=computeLighting(hit.pos,hit.normal,saveray);\n        vec3 colsp;\n        if(hit.objId.x<2.){\n            colsp=colsp=mix(vec3(.8,.7,.5),vec3(.35,.62,.2),dot(hit.normal,vec3(0,1.,0)));\n        }\n        else\n            colsp=vec3(.1);\n       colSphere=vec3(colsp*col);\n    }\n    else{\n    //    olddist=hit.dist;\n        colSphere=vec3(triNoise3d(saveray*.8*vec3(.3,1.,1.),.02))*.7;\n        fogAmount=1.-saveray.y*2.;\n        }\n    colSphere=mix( colSphere, fogColor, fogAmount);\n    colSphere*=min(dot(normalize(sunpos), vec3(0,1.,0) )*10.+.2,1.);\n    return vec4(colSphere,1.);\n\n   // return colSphere;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n    \n     vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    float t=iTime/ANIM_SPEED;\n    \n    vec2 mousePos=getmousePos();\n    \n    float zoffset=getzoffset();\n    \n    //camera model from https://www.youtube.com/watch?v=PBxuVlp7nuM\n    vec3 camera=vec3(0,.3,10.-zoffset);//-20.*(1.+sin(t)));\n    vec3 lookAt=vec3(0,-.7,-zoffset);\n    float zoom=1.;\n    vec3 f=normalize(camera-lookAt);\n    vec3 r=cross(vec3(0,1.,0),f);\n    vec3 u=cross(f,r);\n    \n    vec3 c=camera-f*zoom;\n    vec3 i=c+uv.x*r+uv.y*u;\n    vec3 ray=normalize(i-camera);\n    \n    \n    float fresnel=0.;\n    float olddist=-1.;\n    Hit h=rayMarch(camera,ray);\n    fragColor=render(ray,h);\n    if(h.objId.x>1. && h.dist<5.5){\n   \n    \tvec3 n=getNormal(h.pos);\n    \t    \t\n    \tray=reflect(ray,n);\n    \tfloat fresnel=1.-dot(n,ray);\n    \th=rayMarch(h.pos+n*.001,ray,3.);\n\n\n    fragColor+=render(ray,h)*pow(map01(.2,.8,fresnel),5.);\n    }\n   //gamma correction\n    fragColor.r=lin2sRGB(fragColor.r);\n    fragColor.g=lin2sRGB(fragColor.g);\n    fragColor.b=lin2sRGB(fragColor.b);\n    \n    \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s3SDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[365, 387, 407, 407, 554], [556, 556, 579, 579, 656], [658, 658, 682, 682, 733], [735, 735, 758, 758, 878], [880, 880, 902, 902, 927], [928, 928, 949, 949, 1029], [1065, 1065, 1108, 1108, 1387], [1391, 1391, 1410, 1410, 1440], [1442, 1442, 1465, 1465, 1517], [1520, 1520, 1564, 1564, 1615], [1620, 1681, 1731, 1731, 1874], [1876, 1876, 1909, 1909, 1977], [1980, 2032, 2073, 2073, 2145], [2147, 2199, 2240, 2240, 2312], [2314, 2314, 2345, 2345, 2432], [2436, 2493, 2530, 2671, 2867], [2869, 2926, 2953, 2953, 3368], [3370, 3427, 3464, 3500, 4138], [4144, 4144, 4180, 4279, 4689], [4691, 4691, 4711, 4711, 4741], [4744, 4744, 4769, 4769, 4988], [4993, 4993, 5035, 5035, 5484], [5486, 5486, 5516, 5516, 5546], [5548, 5548, 5601, 5601, 5838], [5840, 5840, 5876, 5893, 6245], [6250, 6250, 6269, 6269, 6379], [6381, 6381, 6431, 6431, 7079], [7085, 7085, 7115, 7155, 8699], [8704, 8704, 8761, 8761, 9828]]}
{"id": "7s3SWl", "name": "Physically based rod light", "author": "hyperknot", "description": "Physically based lightness calculation\nfor a rod light perpendicular to a\nmatte (Lambertian) ground plane, expanding up and down.\ndetails: https://hyperknot.com/blog/area_lights_in_shaders/", "tags": ["light", "physics", "arealight"], "likes": 2, "viewed": 126, "published": "Public API", "date": "1634145310", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Physically based lightness calculation\n// for a rod light perpendicular to a\n// matte (Lambertian) ground plane, expanding up and down.\n// details: https://hyperknot.com/blog/area_lights_in_shaders/\n\nfloat rod_light_antideriv(vec2 uv, float i, float h) {\n  return i * uv.x / (dot(uv,uv) + h*h);\n}\n\nfloat rod_light(vec2 uv, float i, float h_top, float h_bottom) {\n  // h_top and h_bottom - the light's top and bottom above the ground\n  // i - light's intensity\n  return rod_light_antideriv(uv, i, h_top) - rod_light_antideriv(uv, i, h_bottom);\n}\n\n\nfloat lin_to_srgb ( float val ) {\n  if( val < 0.0031308 )\n    return val * 12.92;\n  else\n    return 1.055 * pow(val,1.0/2.4) - 0.055;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = ( fragCoord - .5*iResolution.xy ) / iResolution.y;\n\n    float h = pow(sin(iTime/3.), 2.) * 0.1 + 0.002;\n    float v = rod_light(uv, 0.1, h, 0.001);\n    v = lin_to_srgb(v);\n\t\n \tfragColor=vec4(v);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s3SWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 203, 257, 257, 299], [301, 301, 365, 462, 547], [550, 550, 583, 583, 685], [687, 687, 743, 743, 954]]}
{"id": "7s3SWM", "name": "Hexagon Math 2", "author": "pdkl95", "description": "Fun with hexagons.", "tags": ["hexagon"], "likes": 8, "viewed": 103, "published": "Public", "date": "1633285675", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define N 12.0\n#define FADESPEED 2.0\n\n#define EPSILON (0.001)\n#define EQUAL1(a,b) (((a - EPSILON) < b) && ((a + EPSILON) > b))\n#define EQUAL3(a,b) (EQUAL1(a.x, b.x) && EQUAL1(a.y, b.y) && EQUAL1(a.z, b.z))\n\nvec2 rec2hex(vec2 rec)\n{\n\tfloat temp = floor(rec.x + sqrt(3.0) * rec.y + 1.0);\n\tfloat q = floor((floor(2.0 * rec.x + 1.0) + temp) / 3.0);\n\tfloat r = floor((temp + floor(-rec.x + sqrt(3.0) * rec.y + 1.0)) / 3.0);\n\treturn vec2(q,r);\n}\n\nvec3 axial_to_cube(vec2 hex)\n{\n\treturn vec3(hex.x, hex.y, -hex.x-hex.y);\n}\n\nfloat hex_length(vec3 hex) {\n    return floor((abs(hex.x) + abs(hex.y) + abs(hex.z)) / 2.0);\n}\n\nfloat hex_distance(vec3 a, vec3 b) {\n    return hex_length(a - b);\n}\n\nvec3 hex_round(vec3 h) {\n    float q = floor(h.x);\n    float r = floor(h.y);\n    float s = floor(h.z);\n    float q_diff = abs(q - h.x);\n    float r_diff = abs(r - h.y);\n    float s_diff = abs(s - h.z);\n    if ((q_diff > r_diff) && (q_diff > s_diff)) {\n        q = -r - s;\n    } else if (r_diff > s_diff) {\n        r = -q - s;\n    } else {\n        s = -q - r;\n    }\n    return vec3 (q, r, s);\n}\n\nvec2 rotate(in vec2 point, in float rads)\n{\n\tfloat cs = cos(rads);\n\tfloat sn = sin(rads);\n\treturn point * mat2(cs, -sn, sn, cs);\n}\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nvec2 rand_loc(float i, float t)\n{\n\tfloat offset = i * 11.0;\n\tfloat seed = t + (offset * 200.0);\n\t\n\treturn vec2(snoise(vec2(seed, 11.0)),\n\t\t    snoise(vec2(seed, 88.765433)));\n\t\t    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 position = ((fragCoord.xy / iResolution.xy) * 2.0) - 1.0;\n\tposition.y *= iResolution.y/iResolution.x;\n\n\tfloat n = 7.0;\n\tvec2 pos = position * n;\n\t\n\tvec2 hpos = rec2hex(pos);\n\tvec3 orig_cube = axial_to_cube(hpos);\n\tvec3 orig_icube = hex_round(orig_cube);\n\n\tvec2 rhpos = rotate(hpos, iTime);\n\tvec3 cube = axial_to_cube(rhpos);\n\tvec3 h = abs(cube);\n\tfloat d = length(cube);\n\t\n\tvec3 color = vec3(0.0);\n\n\tcolor.rb = 1.0 - h.xz/n;\n\tfloat gfade = (cos(iTime) + 1.0) / 2.0;\n\tcolor.g = gfade * (1.0 - d/n);\n\t\n\tfloat bright = 0.0;\n\n\tfor (float i = 0.0; i < 1.0; i += (1.0/N)) {\n\t\tfloat t = iTime + i;\n\t\tfloat fadeiTime = t * FADESPEED;\n\t\tfloat stepiTime = floor(fadeiTime);\n\t\tfloat stepfract = fract(fadeiTime);\n\t\tfloat stepprog = sin(stepfract * 3.14159265);\n\t\tstepprog = stepprog * stepprog;\n\t\n\t\n\t\tvec2 loc = rand_loc(i, stepiTime);\n\t\tvec2 loc_axial = rec2hex(loc * n);\n\t\tvec3 loc_hex = axial_to_cube(loc_axial);\n\t\tvec3 loc_ihex = hex_round(loc_hex);\n\t\tif (EQUAL3(loc_ihex, orig_icube)) {\n\t\t\tbright += stepprog;\n\t\t}\n\t}\n\tfloat cbright = clamp(bright, 0.0, 1.0);\n\n#define R_SIZE  3.7\n#define R_MOD   1.0\n#define R_SPEED 1.666\n#define R_WIDE  1.3\n#define R_MARGIN (R_WIDE / 2.0)\n\n\tfloat r = R_SIZE + (R_MOD * sin(iTime * R_SPEED));\n\tif ((d > (r - R_MARGIN)) && (d < (r + R_MARGIN))) {\n\t\tvec3 grey = vec3((color.r + color.g + color.b) / 3.0);\n\t\tgrey *= 1.1;\n\t\tcolor = mix(grey, color, gfade);\n\t\t//color.rb /= 3.0;\n\t\t//color = vec3(0.0);\n\t}\n\t\n\tcolor += vec3(cbright);\n\n\tfragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s3SWM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[207, 207, 231, 231, 439], [441, 441, 471, 471, 515], [517, 517, 545, 545, 611], [613, 613, 649, 649, 681], [683, 683, 707, 707, 1076], [1078, 1078, 1121, 1121, 1208], [1210, 1210, 1231, 1231, 1280], [1282, 1282, 1303, 1303, 1352], [1354, 1354, 1376, 1376, 1413], [1415, 1415, 1439, 1439, 2945], [2947, 2947, 2980, 2980, 3130], [3132, 3132, 3187, 3187, 4682]]}
{"id": "7s3XDM", "name": "twisting log spiral disco", "author": "morisil", "description": "I generalized some previous sketches", "tags": ["spiral", "polar"], "likes": 5, "viewed": 150, "published": "Public API", "date": "1633297924", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"twisting log spiral\" by morisil. https://shadertoy.com/view/slSGDV\n// 2021-10-03 21:51:24\n\nconst float LOG_SCALE_MAX = 50.;\nconst float LOG_SCALE_PERIOD = .4;\nconst float ANGLE_SCALE = 4.;\nconst float ROTATION_SPEED = 10.;\n\n#define wave(x) (sin(x) + 1.) / 2.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st =\n        (2.* fragCoord - iResolution.xy)\n        / min(iResolution.x, iResolution.y);\n    float dist = length(st);\n    float angle = atan(st.x, st.y);\n    float logDist = log(dist);\n    float logScale = sin(iTime * LOG_SCALE_PERIOD) * LOG_SCALE_MAX;\n    float luma = wave(\n        logDist * logScale + angle * ANGLE_SCALE - iTime * ROTATION_SPEED + sin(dist * 40.) + cos(angle * 40.)\n    );\n    fragColor = vec4(vec3(luma), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s3XDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 272, 327, 327, 772]]}
{"id": "7s3XR2", "name": "eco", "author": "4eckme", "description": "animated detalization", "tags": ["fractal", "sphere", "rgb", "5d", "eco"], "likes": 2, "viewed": 129, "published": "Public", "date": "1633523539", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// CLICK MOUSE AND MOVE\nvoid mainImage( out vec4 color, in vec2 o )\n{\n    o-=iResolution.xy/vec2(2.0);\n    o/=iResolution.y/vec2(7.0);\n    \n    float x = (mod(abs(o.x),100.0));\n    float y = (mod(abs(o.y),100.0));\n    \n    float mx = (-iResolution.x/2.0+iMouse.x)/iResolution.x*8.0;\n    float my = (-iResolution.y/2.0+iMouse.y)/iResolution.y*8.0;\n    \n    float R = x*x+y*y;\n    float L=pow(o.x+(mx)/5.0,2.0)+pow(o.y+(my)/5.0,2.0);\n    \n    float t = mod(iTime,x/y);\n    float f = mod(iTime,y/x);\n    \n    float r1 = f*sin(x+sin(x+y)*L)+f*cos(y-sin(x-y)*L);\n    float r2 = t*sin(x+sin(y-x)*L)+t*cos(y-sin(-y-x)*L);   \n    \n    color = vec4(\n        mod(cos(r1),cos(r2)),\n        mod(cos(r1),sin(r2)),\n        max(sin(r2),sin(r1)),\n        //mod(cos(r1),cos(r2)),\n        //1.5*mod(cos(r1),sin(r2)),\n        //abs(sin(r2)*sin(r1)),\n    0)/sin(pow(R,0.5));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s3XR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 24, 69, 69, 856]]}
{"id": "7scSRX", "name": "Supah Sketch v1", "author": "supah", "description": "sketchify", "tags": ["sketch"], "likes": 3, "viewed": 92, "published": "Public", "date": "1633602913", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    float r = sin(col.r * 6.28 * .9);\n    vec3 silhouette = vec3(smoothstep(0., .8, 1. - pow(r, 6.)));\n    col = mix(col * silhouette, silhouette, sin(iTime * .8) * .5 + .5);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7scSRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 348]]}
{"id": "7scSWj", "name": "🎮 Kukoos - Lost Pets 🎮", "author": "rmmcal", "description": "Fan-art", "tags": ["kukoos"], "likes": 3, "viewed": 46, "published": "Public", "date": "1633947764", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/////////////////////////////////////////////////////////////\n//       ...  🎮 Kukoos - Lost Pets 🎮  ...             ////\n/////////////////////////////////////////////////////////////\n//  Fan Art by Rodrigo Cal (twitter: @rmmcal)\n// - Published: 2021/10\n// - https://www.shadertoy.com/view/7scSWj\n/////////////////////////////////////////////////////////////\n\nconst float pi = 3.1415926;\nconst float pi2 = 2.*pi;\nconst float rad = pi/180.;\n\n///////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\n///////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////\n\n\nmat2 rotate(float x){\n    float c = cos(x);\n    float s = sin(x);\n    return mat2(c,s,-s,c);\n}\n\nfloat dist(vec3 p)\n{\n    float d = 100.;\n    p.xz *= rotate(cos(iTime)*.4);    \n    p -= vec3(0.,-0.5,0.);\n    \n    float t = cos(iTime*8.)*.05;\n    float t2 = cos(iTime*9.)*.05;\n    float t3 = cos(iTime*12.)*.05;\n    float t4 = cos(iTime*9.)*.2+.8;\n    float t5 = cos(iTime*3.)*.2-.2;\n   \n    vec3 pr = vec3(sign(p.x),1.0,1.0);  // repeat x\n    vec3 pr1 = vec3(sign(p.x),1.+t2,1); // repeat x ani1\n    vec3 pr2 = vec3(sign(p.x),1.+t3,1); // repeat x ani2   \n    vec3 pa = p*pr2+vec3(0.,-cos(p.x)*0.7+.5,0.); // pos repeat\n\n    vec3 ph = vec3(-2.7,-2.6 + t,0.5); // pos hand\n    vec3 pf = p*pr+vec3(-0.7,1.9,0.2); // pos foot\n    pf += vec3(0., cos(sign(p.x) + t3)-.5,0.);\n\n    vec3 m1 = vec3(1.,cos(p.x*3.+.2 +t5 )*+t4,1.); // mouth ani 1\n    vec3 m2 = vec3(0.,-.2,0.);                     // mouth ani 2\n    vec3 pm = vec3(0.,.5,0.);                      // mouth \n\n\n    // body\n    d = opSmoothUnion(d, sdCapsule(p*vec3(1.,pow(abs(p.y),.5)/1.5,1.), vec3(0.), vec3(0., 1.3, 0.0), 1.5), 1.5);\n\n    // face\n    d = opSmoothUnion(d, sdCapsule((p-vec3(0.,1.,0.))*vec3(1.,pow(abs(p.y),1.)/1.5,1.), vec3(0.,-.3,-0.1), vec3(0., .6, -0.1), 1.44), .0);\n\n    //eye\n    d = opSmoothUnion(d, sdCapsule(p*pr1, vec3(0.25, 1.2, -1.5), vec3(0.25, 1.0, -1.5), 0.15), .06);\n\n    // eyebrow\n    d = opSmoothUnion(d, sdCapsule(p*pr1 + vec3(0.,-0.1+cos(abs(p.x)*2.+2.-t)*.5+.5,0.), vec3(0.6, 1.6, -1.35), vec3(0.25, 1.6, -1.5), 0.1), .03);\n\n    // arm\n    d = opSmoothUnion(d, sdCapsule(pa, vec3(2.7, 2.6, -.5), vec3(.55, -.6, -.5), 0.25), .33);\n\n    //clothes\n    d = opSmoothUnion(d, sdCapsule(pa, vec3(2.3, 2.0, -.5), vec3(.55, -.6, -.5), 0.3), .01);\n\n    // hand\n    d = opSmoothUnion(d, sdSphere((pa+ph),  0.4), .2);\n\n    // foot\n    d = opSmoothUnion(d, opSmoothSubtraction(pf.y, sdSphere(max(vec3(-100.,0.,-100.), pf),  0.6), .2 ), .15);\n\n    // mouth\n    d = opSmoothSubtraction(sdCapsule((p-pm)/m1 -m2, vec3(0.2, 0.0, -1.5),  vec3(-0.2, 0.0, -1.5), 0.15), d, .06);\n\n    // tooth\n    d = opSmoothUnion(d, sdCapsule(p*pr, vec3(0.2, .6, -1.4), vec3(0.2, 0.45, -1.4), 0.06), .02);\n\n    // ear\n    d = opSmoothUnion(d, sdSphere((p*pr +vec3(-1.7,-1.4 + t*.1, .2)) * vec3(.4,.4, 1.),  0.1), .13);\n\n\n    return d;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec2 d = vec2(0., 0.01);\n    float x = dist(p-d.yxx);\n    float y = dist(p-d.xyx);\n    float z = dist(p-d.xxy);\n    return normalize(vec3(x,y,z)-dist(p));\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 pc = (uv-.5)*vec2(1, iResolution.y/iResolution.x);\n    vec3 p = vec3(0,0.,-10);\n    vec3 d = normalize(vec3(pc,1.0));\n    \n    d *= setCamera(p, vec3(0.,0.,0.),0.);\n    \n    vec3 c=vec3(0.0);\n    float t = 0.;\n    for (int i = 0 ; i < 30; i++)\n    {\n        float h=dist(p); \n        if (h < 0.01)\n         break;\n        t+=h;\n        p += d*h;\n    }\n     \n    c += getNormal(p).z;\n    fragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7scSWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[607, 683, 718, 718, 742], [744, 744, 796, 796, 917], [919, 919, 971, 971, 1071], [1073, 1073, 1131, 1131, 1232], [1234, 1396, 1417, 1417, 1490], [1492, 1492, 1512, 1512, 3689], [3691, 3691, 3715, 3715, 3876], [3878, 3878, 3930, 3930, 4107], [4110, 4110, 4167, 4167, 4630]]}
{"id": "7scXD2", "name": "Thewaytoentry-1", "author": "jialouluo", "description": "从如何创建一个圆 到创建一个圆环，到为圆环增添颜色，到色彩动效；", "tags": [], "likes": 3, "viewed": 139, "published": "Public API", "date": "1633968031", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 getcolor(float ang) {\n    //传入进来的是一个角度值 我们需要将他进行一定的运算来使得他成为我们需要的结果，这里可以根据自己喜好\n        //return 0.6 + 0.4 * cos(ang + vec3(0.5,.7,.2));\n        //return 0.6 + 0.4 * cos(ang + vec3(0.5,.7,.2)  + iTime );//有 iTime\n        //return .5 + .5 * cos(6.28 * (ang + vec3(0., .33, .67)));\n        return .5 + .5 * cos(6.28 * (ang/6.28 + vec3(0., .33, .67)));//6.28 约等于2Π\n    }\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //从如何创建一个圆 到创建一个圆环，到为圆环增添颜色，到色彩动效；\n    //本人也才刚开始学 ，有不对的一些地方或者理解错误的地方，也希望路过的大佬不吝赐教QAQ\n    vec2 uv = fragCoord/iResolution.xy;//将uv坐标转换到0-1\n    uv-=.5;//将uv移到中心(0,0)\n    uv.x *= (iResolution.x/iResolution.y);//别急着解开注释，uv.x更新\n    //下面创建一个圆\n    float dis = length(uv);//得到每个像素到原点(0，0)的长度\n    \n    //smoothstep(a,b,x); 当a>b时 ,x>a 那么y值(返回值)为0;x <b小返回值为1; b>a的情况这里用不到,具体可以看Api的解释\n    //若x大于b小于a为平滑过渡的值(0-1)\n    //基于这一点 我们可以实现一个圆\n    //我们屏幕的坐标范围为 -0.5=>0.5(注释掉uv.x更新的那行代码的范围)\n    //float r = 0.6;//这是半径,不受范围大小影响\n    //float c  = smoothstep(r,r-0.1,dis);//只要dis(像素的坐标距离原点的距离)大于r 那么 返回值就为0，\n    //小于r-0.1就为1，有0.1的平滑距离\n    //我们将目前的c值赋值给fragColor试试效果\n    //vec3 cir = vec3(c);\n    //fragColor = vec4(cir,1.0);\n    //会发现是一个椭圆\n    //可以发现 是由于长宽比例的问题 所以将 所有的uv的x值都乘以一个x/y的值\n    //需要在计算距离之前添加这句代码uv.x *= (iResolution.x/iResolution.y);\n    //这下我们解开上面的注释再试试\n    //运行之后我们发现 成功的绘制的一个圆\n    //利用smoothstep 我们想想 可不可以在圆的基础上制作一个空心的圆(圆环)\n    //我们知道 如果在a>b的基础上 若x大于a返回值为0 我们可以基于这一点来实现\n    //也就是 在距离原点位置越近 某个值越大 最后达到临界值会大于a 以此来实现返回0 \n    //这个值 我们可以用 value 同时我们也可以设置一个内圆的半径 ir\n    //接下来让我们重写第8 - 32行的代码;\n    float ir = 0.09;\n    float or = 0.4;\n    float value = abs(dis - or);//dis越近 value的值越大\n    float c = smoothstep(ir,ir-0.01,value);//这里可以不用0.01作为区间 ，可以用偏导宽来作为平滑区间,(偏导宽 + smoothstep 经常作为去锯齿的一种常用方法)\n    //vec3 cir = vec3(c);\n    //fragColor = vec4(cir,1.0);\n    //效果似乎还行，但是改变参数发现 似乎效果不如我们想得那样美好，\n    //原因是当我们改变内圆半径时 a，b的值也发生了改变,使得除开内圆范围判断的其他判断也发生了改变，\n    //但是已经不影响我们下面的使用了\n    //下面我们来对这个圆环进行着色\n    //我们需要知道每个uv坐标对应于中心点的角度，以此来进行不同uv位置的不同颜色赋值\n    //使用 atan(uv.y,uv.x)是常用的求uv角度的方法\n    float angle  =atan(uv.y,uv.x);\n    //我们这时来进行赋值操作,重写37 - 44行的代码\n    //vec3 cir = vec3(angle * c);\n    //fragColor = vec4(cir,1.0);\n    //会发现渐变的效果似乎出来了，当然因为rgb的参数是一样的所以呈黑白\n    //我们需要对他进行优化，我们需要一个方法来使得我们的角度值转变为一个具有不同rgb的一个vec3对象\n    //让我们为他创建一个函数\n    //让我们来重写47-50行代码\n    vec3 f_color = getcolor(angle) * c * fract(angle/6.28 - iTime);\n    //vec3 f_color = getcolor(angle) * c * fract(angle - iTime);//不除2Π\n    fragColor =vec4(f_color,1.0);\n    //到这已经创建一个具有自己特色颜色的圆环了，接下来我们需要为他添加一些动效\n    //我们需要用到 iTime 这个shadertoy内置变量 他代编运行时间 ，与他对应的还有一个 ItimeDelta 他表示每帧时长;\n    //将 iTime 写入到计算中，这里跳转到函数哪去\n    //我们可以为他添加一些彩虹头亮尾暗的效果\n    //至于除2Π的作用现目前无法用语言来形容 看看效果应该能大致清楚了\n    \n    //就先写到这里吧 我也是刚学的新人，借鉴了无数大佬的理解和代码 才勉强做到这里，以后一起加油吧\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7scXD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 380, 475], [476, 476, 533, 762, 4709]]}
{"id": "7scXD4", "name": "Area light in 2D", "author": "athibaul", "description": "The analytical formula for the light intensity from a line of sources. Left: monopole sources. Right: dipole sources.\nDipole sources can be used to simulate an infinite vertical plane.", "tags": ["light", "area", "analytic"], "likes": 16, "viewed": 199, "published": "Public", "date": "1633122778", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    uv = 2.*uv;\n    \n    \n    // ANALYTICAL FORMULAS FOR \"LINE\" LIGHTS ON A PLANE\n    \n    // We consider here a line composed of continuously many light sources,\n    // which each radiate either uniformly in all directions (\"monopoles\"),\n    // or which are somewhat directional (\"dipoles\", more realistic for an area light)\n    \n    // The formulas below are derived by integrating the contribution of each\n    // infinitesimal source along the line.\n    \n    // The line is assumed to be at x=0 and y in [0,1].\n    \n    // Intensity radiated from \"monopole\" sources\n    // The contribution of the light source at (0,t) to the intensity at (x,y)\n    // is assumed to be : \n    // dt / sqrt(x^2 + (y-t)^2)\n    //\n    // In which case we obtain :\n    // \\int_0^1 \\frac{dt}{\\sqrt{x^2 + (y-t)^2}} = \\asinh(\\frac{1-y}{x}) - \\asinh(\\frac{-y}{x})\n    float umax = (1.-uv.y)/uv.x, umin = -uv.y/uv.x;\n    float inten_monopole = asinh(umax) - asinh(umin);\n    \n    // Intensity radiated from \"dipole\" sources\n    // The contribution of the light source is assumed to be :\n    // x * dt / (x^2 + (y-t)^2)^(3/2)\n    // \n    // Then we obtain :\n    // (the brackets in the RHS mean we take the difference of the values at the two given points)\n    // \\int_0^1 \\frac{x dt}{(x^2+(y-t)^2)^{3/2}} = \\frac{1}{x} \\left[ \\frac{u}{\\sqrt{1+u^2}} \\right]_{u_{min}}^{u_{max}}\n    // where u_{min} = -y/x and u_{max} = (1-y)/x.\n    float inten_dipole = (umax/sqrt(1.+umax*umax) - umin/sqrt(1.+umin*umin))/uv.x;\n    \n    \n    \n    float inten = uv.x < 0. ? inten_monopole : inten_dipole;\n    inten = abs(inten) * (0.5+0.2*sin(10.*iTime)+0.1*sin(16.18*iTime));\n    \n    \n    vec3 col = vec3(1.,0.25,0.05) * inten;\n    col = col / (1. + col); // Tone mapping\n    col = sqrt(col); // Gamma\n    \n    col = abs(uv.x) > 0.02 ? col : vec3(0,0,1);\n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7scXD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1969]]}
{"id": "7scXDM", "name": "031021_2", "author": "gtoledo3", "description": "shader", "tags": ["shader"], "likes": 0, "viewed": 32, "published": "Public", "date": "1633306942", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time=iTime*.5;\n    vec2 uv = -1.0 + 2.0 * fragCoord/iResolution.xy;\n    \n    uv.x *= iResolution.x/iResolution.y;\n\n\tfloat c=length(uv);\n\n    float r,g,b;\n    \n    float d=3.+sin(time*.5)*3.5;\n    \n    c=smoothstep(.125,.95,c);\n    \n    r=sin(time+(c+sin(1.+time+uv.y*.5))*d);\n    \n    g=sin(time+(c+sin(1.75+time+uv.y*.5))*d);\n\n    b=sin(time+(c+sin(2.25+time+uv.y*.5))*d);\n\n\n\n    fragColor = vec4(vec3(r,g,b)+(c-.5+sin(time*120.)*.04),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7scXDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 511]]}
{"id": "7scXzM", "name": "Nebula - Andrew", "author": "andrew741", "description": "This is a nebula and is a part of my project called \"Through The Cosmos\" which will be coming out sometime. I used volumetrics and ray tracing to render the stars and moving clouds of gas which use more noise to create the varying color. I hope you enjoy!", "tags": ["procedural", "noise", "volume", "clouds", "space", "space", "volumetric", "stars", "nebula", "dynamic"], "likes": 0, "viewed": 25, "published": "Public", "date": "1633132372", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n// from https://www.shadertoy.com/view/WtGXDD\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\n// from https://www.shadertoy.com/view/WtGXDD\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\n// 2d rotation matrix\nvec2 rot2D(vec2 v, float a)\n{\n    mat2x2 rot = mat2x2(cos(a), -sin(a), sin(a), cos(a));\n    return v * rot;\n}\n\n\n// takes a uv coord and mouse pos and converts it to the rays direction\nvec3 Transform(vec2 uv, vec2 m, float roll)\n{\n    vec3 ro = vec3(0, 1, -1) * 20.;\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    vec3 rd = GetRayDir(rot2D(uv, roll), ro, vec3(0,0.,0), 1.);\n    return rd;\n}\n\n\n// from another shadertoy shader\nvec3 hash( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n// from another shadertoy shader\nvec4 noised( in vec3 x )\n{\n    // grid\n    vec3 i = floor(x);\n    vec3 w = fract(x);\n    \n    // cubic interpolant\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    \n    // gradients\n    vec3 ga = hash( i+vec3(0.0,0.0,0.0) );\n    vec3 gb = hash( i+vec3(1.0,0.0,0.0) );\n    vec3 gc = hash( i+vec3(0.0,1.0,0.0) );\n    vec3 gd = hash( i+vec3(1.0,1.0,0.0) );\n    vec3 ge = hash( i+vec3(0.0,0.0,1.0) );\n\tvec3 gf = hash( i+vec3(1.0,0.0,1.0) );\n    vec3 gg = hash( i+vec3(0.0,1.0,1.0) );\n    vec3 gh = hash( i+vec3(1.0,1.0,1.0) );\n    \n    // projections\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolations\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\n                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\n}\n\n\nvec2 RaySphere(vec3 ro, vec3 rd, vec3 sc, float r)\n{\n    vec3 offset = ro - sc;\n    float b = 2. * dot(offset, rd);\n    float c = dot(offset, offset) - r * r;\n\n    float discriminant = b * b - 4. * c;\n\n    if (discriminant > 0.)\n    {\n        float s = sqrt(discriminant);\n        float dstToSphereNear = max(0., (-b - s) / 2.);\n        float dstToSphereFar = (-b + s) / 2.;\n\n        if (dstToSphereFar > 0.)\n        {\n            return vec2(dstToSphereNear, dstToSphereFar - dstToSphereNear);\n        }\n    }\n    return vec2(999999999999999999., 0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y * 1.75;\n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    if (iMouse.xy == vec2(0.))\n    {\n        m = vec2(1., 0.4);\n    }\n    \n    float roll = 0.;\n    \n    vec3 rd = Transform(uv, m, roll);\n    vec3 ro = vec3(0., 1., iTime * 0.5);\n    \n    vec3 sun_dir = normalize(vec3(0.2, 0.7, -0.2));\n\n    vec3 col = vec3(0.);\n    \n    col = mix(col, vec3(0.95, 0.75, 0.5) * 2., pow(max(dot(sun_dir, rd), 0.), 275.));\n\n    vec2 dstNebula = RaySphere(ro, rd, vec3(0., 0., 4.), 3.);\n    \n    if (dstNebula.y > 0.)\n    {\n        float transmission = 1.;\n        float step_size = dstNebula.y / 16.;\n        vec3 step_sizev = rd * step_size;\n        \n        vec3 total_color = vec3(0.);\n        vec3 p = ro + rd * dstNebula.x;\n        \n        for (int i = 0; i < 15; i++)\n        {\n            p += step_sizev;\n            \n            float colorBlend = noised(p * 0.5 + 20. + iTime * 0.75).x * 0.5 + 0.5;\n            float density = smoothstep(0., 0.7, max(noised(p).x + noised(p * 2. + 200. + iTime * 0.25).r * 0.5, 0.) / 1.5);\n            total_color += mix(vec3(0.8, 0.3, 0.2), vec3(0., 0., 0.9), smoothstep(0., 1., colorBlend)) * transmission * 0.3;\n            transmission *= exp(-density * step_size * 6. * smoothstep(3., 2.2, length(p - vec3(0., 0., 4.))));\n        }\n        col = col * transmission + total_color * 0.7 * (1. - transmission);\n        \n        float dst_sun;\n        dst_sun = RaySphere(ro, rd, vec3(0.1, 0., 3.), 0.05).x;\n        if (dst_sun < 9999999.) col += 4. * transmission;\n         dst_sun = RaySphere(ro, rd, vec3(1.7, 0.7, 5.), 0.05).x;\n        if (dst_sun < 9999999.) col += 4. * transmission;\n        dst_sun = RaySphere(ro, rd, vec3(-0.5, -1.8, 5.3), 0.05).x;\n        if (dst_sun < 9999999.) col += 4. * transmission;\n        dst_sun = RaySphere(ro, rd, vec3(1.5, 1.73, 4.3), 0.05).x;\n        if (dst_sun < 9999999.) col += 4. * transmission;\n        dst_sun = RaySphere(ro, rd, vec3(0.4, 1., 4.3), 0.05).x;\n        if (dst_sun < 9999999.) col += 4. * transmission;\n        dst_sun = RaySphere(ro, rd, vec3(-1.5, -0.72, 2.3), 0.05).x;\n        if (dst_sun < 9999999.) col += 4. * transmission;\n        dst_sun = RaySphere(ro, rd, vec3(1.2, -0.3, 4.63), 0.05).x;\n        if (dst_sun < 9999999.) col += 4. * transmission;\n        dst_sun = RaySphere(ro, rd, vec3(-0.82, 0.185, 4.2), 0.05).x;\n        if (dst_sun < 9999999.) col += 4. * transmission;\n        dst_sun = RaySphere(ro, rd, vec3(0.84, 1.4, 5.1), 0.05).x;\n        if (dst_sun < 9999999.) col += 4. * transmission;\n        dst_sun = RaySphere(ro, rd, vec3(-0.274, -1.63, 2.84), 0.05).x;\n        if (dst_sun < 9999999.) col += 4. * transmission;\n        //col = vec3(transmission);\n    }\n    \n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    col =  clamp((col*(a*col+b))/(col*(c*col+d)+e), 0., 1.);\n\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7scXzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 48, 67, 67, 129], [132, 178, 228, 228, 419], [422, 444, 473, 473, 553], [556, 628, 673, 673, 853], [856, 889, 910, 910, 1079], [1081, 1114, 1140, 1152, 2646], [2649, 2649, 2701, 2701, 3202], [3205, 3205, 3262, 3262, 6204]]}
{"id": "7sdSDS", "name": "hex segment digital display", "author": "remaindeer", "description": "Implement a seven-segment-ish digital display for a hexagonal grid where each character is bit-encoded.", "tags": ["grid", "text", "hexagon", "segment", "encoding", "bits", "digitaldisplay"], "likes": 3, "viewed": 176, "published": "Public API", "date": "1633893524", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define N   9.0\n#define ON  0.75\n#define OFF 0.25\n#define COS30 cos(radians(30.0))\n#define WIDTH 0.125\n\nfloat hex_codes[49] = float[] (\n    16127.0, 12735.0, 09087.0, 10681.0, 16313.0, 11263.0, 19199.0, 14719.0, 16063.0, 14527.0,\n    12289.0, 16145.0, 14015.0, 08511.0, 15549.0, 14521.0, 14777.0, 03839.0, 16071.0, 18617.0,\n    13287.0, 10687.0, 14649.0, 16191.0, 14617.0, 23709.0, 14007.0, 16263.0, 10227.0, 16255.0,\n    15873.0, 12283.0, 16363.0, 16015.0, 15343.0, 15359.0, 15939.0, 16383.0, 16079.0, 08481.0,\n    18569.0, 16425.0, 11777.0, 20219.0, 08193.0, 16391.0, 17927.0, 16767.0, 16193.0\n);\n\nfloat cross2(vec2 p, vec2 q)\n{\n    return p.x * q.y - p.y * q.x;\n}\n\nbool intri(vec2 uv, vec2 v1, vec2 v2, vec2 v3)\n{\n    // https://mathworld.wolfram.com/TriangleInterior.html\n    // http://www.sunshine2k.de/coding/java/pointInTriangle/pointInTriangle.html\n    vec2 w1 = v2 - v1;\n    vec2 w2 = v3 - v1;\n    float d = determinant(mat2(w1, w2));\n    // check for d ≈ 0.0 ?\n    float s = determinant(mat2(uv - v1, w2)) / d;\n    float t = determinant(mat2(w1, uv - v2)) / d;\n    return s >= 0.0 && t >= 0.0 && (s + t) <= 1.0;\n}\n\nbool inreg(vec2 uv, vec2 c, float n, float R, float theta)\n{\n    // break-up regular polygon into triangles\n    float dt = radians(360.0 / n);\n    for (float i = 0.0, j = 1.0; i < n; i++, j++)\n    {\n        vec2 a = R * vec2(cos(dt * i + theta), sin(dt * i + theta)) + c;\n        vec2 b = R * vec2(cos(dt * j + theta), sin(dt * j + theta)) + c;\n        if (intri(uv, a, b, c))\n            return true;\n    }\n    return false;\n}\n\nvec2 uv_to_hex(vec2 uv, float R) {\n    // get central hex coordinate\n    float r = R * COS30;\n    float theta = radians(30.0);\n    vec2 hvec = vec2(2.0 * r, 0.0);\n    vec2 kvec = vec2(r, 1.5 * R);\n    mat2 b = mat2(hvec, kvec);\n    vec2 cell = b * round(inverse(b) * uv);\n    bool inhex = inreg(uv, cell, 6.0, R, radians(theta));\n    // adjust hex coordinate due to overlap\n    if (!inhex)\n        if (cross2(vec2(r, 0.5 * R), cell - uv) < 0.)\n            cell += (uv.x > cell.x) ? kvec : -hvec;\n        else\n            cell += (uv.x > cell.x) ? hvec : -kvec;\n    return cell;\n}\n\nvec3 hex_display(vec2 uv, vec2 pos, float chr, float R, float B, vec3 col) {\n    // uv  the uv\n    // pos the centreal display position\n    // chr the character code to display\n    // R   the hexagon circumradius\n    // B   the border width\n    // col the default color\n    //\n    //     0    5    8  -\n    //    1         9    |\n    //   2    6    A      > display bit mapping\n    //  3         B      |\n    // 4    7    C      -\n    //\n    // A a 16127          n 14521        0 16255  _ 08481\n    // b   12735          o 14777        1 15873  - 18569\n    // C c 09087 10681  P   03839        2 12283  : 16425\n    //   d 16313          q 16071        3 16363  ! 11777\n    // E   11263          r 18617        4 16015  ? 20219\n    // F   19199        S   13287        5 15343  . 08193\n    // G g 14719          t 10687        6 15359  ' 16391\n    // H h 16063 14527  U u 16191 14649  7 15939  \" 17927\n    //   i 12289        V   14617        8 16383  [ 16767\n    // J   16145          w 23709        9 16079  ] 16193\n    // K   14015        X   14007\n    // L   8511           y 16263\n    // M   15549        Z   10227\n    \n    float r = R * COS30;\n    float theta = radians(30.0);\n    float n = chr;\n    // set display according to bit index\n    for (int i = 0; i < 13; i++) {\n        float q = floor(n / 2.0);\n        if (mod(q, 2.0) == 1.0) {\n            float ir = 0.0;\n            float ic = 0.0;\n            switch (i) {\n                case  0:\n                case  5:\n                case  8:\n                    ir = +2.0;\n                    break;\n                case  1:\n                case  9:\n                    ir = +1.0;\n                    break;\n                case  3:\n                case 11:\n                    ir = -1.0;;\n                    break;\n                case  4:\n                case  7:\n                case 12:\n                    ir = -2.0;\n                    break;\n            }\n            /**/ if (i <= 4) ic = -1.0;\n            else if (i >= 8) ic = +1.0;\n            float dx = ic * 2.0 * r + ir * r;\n            float dy = ir * 1.5 * R;\n            if (inreg(uv, pos + vec2(dx, dy), 6.0, R - B, theta)) {\n                col = vec3(ON);\n                break;\n            }\n        }\n        n = q;\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.y;\n    \n    float R = 1.0 / N;\n    float r = R * COS30;\n    float B = R * WIDTH;\n\n    vec2 hex = uv_to_hex(vec2(iResolution.x / iResolution.y / 2.0, 0.5), R);\n\n    vec3 col = (\n        inreg(uv, uv_to_hex(uv, R), 6.0, R - B, radians(30.0)) ? \n        vec3(OFF) : \n        0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0, 2, 4))\n    );\n    float code = hex_codes[int(mod(float(iFrame / 30), float(hex_codes.length())))];\n    col = hex_display(uv, hex, code, R, B, col);\n\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sdSDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[600, 600, 630, 630, 666], [668, 668, 716, 856, 1125], [1127, 1127, 1187, 1234, 1554], [1556, 1556, 1590, 1624, 2135], [2137, 2137, 2213, 3256, 4410], [4412, 4412, 4469, 4469, 5003]]}
{"id": "7sdXRS", "name": "weird world, blue snake", "author": "elenzil", "description": "I wanted to try out [url=https://www.shadertoy.com/view/Wt3fzB]TinyTexel's Panini Projection[/url] and ended up here.\nThe panini thing works like a charm!\nMouse Y to adjust Panini Factor, Mouse X for FOV.", "tags": ["panini"], "likes": 5, "viewed": 155, "published": "Public API", "date": "1633673536", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define RES    (iResolution.xy)\n#define MINRES (min(RES.x, RES.y))\n\nconst vec3 UP  = vec3(0.0, 1.0, 0.0);\nconst vec3 ONE = vec3(1.0, 1.0, 1.0);\nconst float Pi = 3.14159265359;\n\nfloat gTime    = 0.0;\nvec3  gPosCam  = vec3(0.0, 4.0, -2.0);\nvec3  gPosSph1 = UP;\nfloat gSizSph1 = 1.0;\n\nconst float gZoom = 0.8;\n\nfloat Pow2(float x) {return x*x;}\n\nvec3 posSph1(float time, float noiseAmt) {\n    \n    vec3 noise = texture(iChannel1, vec2(time * 0.051, time * 0.05), 0.0).rgb;\n    \n    return vec3(cos(time * 1.3), 0.0, sin(time * 0.7)) * 9.0 + UP + noise * noiseAmt;\n}\n\nvoid composeScene(float time) {\n    gTime    = time;\n    gPosSph1 = posSph1(gTime, 0.0);\n    \n    gPosCam  = posSph1(gTime + 0.0, 0.0);\n    gPosCam.xz  += normalize(gPosCam).xz * 6.0;\n    gPosCam  *= 1.0;\n    gPosCam  += UP * 3.0;\n}\n\nvec3 sky(in vec3 rd) {\n    vec3 ret = rd * 0.5 + 0.5;\n    ret.rg *= sin(rd.y * 20.0) * 0.2 + 0.8;\n    ret.gb *= sin(atan(rd.z, rd.x) * 10.0) * 0.3 + 0.7;\n    ret  = ONE * length(ret);\n    return ret;\n}\n\nvec3 shootRay(in vec3 ro, in vec3 rd) {\n    if (rd.y > -0.001) {\n        return sky(rd);\n    }\n    \n    vec2 planePt2  = -vec2(rd.xz * ro.y / rd.y) + ro.xz;\n    vec3 planePt   = vec3(planePt2.x, 0.0, planePt2.y);\n    float planeDst = length(planePt.xz);\n    float planeAng = atan(planePt.z, planePt.x);\n    float camDist  = length(planePt2 - ro.xz);\n    float blur     = smoothstep(0.0, 80.0, camDist);\n\n    const float txLim = 8.8;\n    float pa = planeAng;\n    float pd = planeDst;\n    if (pd < txLim) {\n        pa += Pow2((pd - txLim) * 0.2);\n    }\n    float planeCol = smoothstep(-blur, blur, sin(pa * 10.0) * sin(log(pd) * 4.0)) * (0.4 * (1.7 - blur)) + 0.6;\n    \n    \n    planeCol *= smoothstep(3.0, 5.0, camDist) * 0.4 + 0.6;\n    \n    vec3 ret = vec3(planeCol);\n    \n    ret = mix(ret, sky(rd), smoothstep(20.0, 1160.0, planeDst));\n    \n    vec2 planePt3  = -vec2(rd.xz * (ro.y - 1.0) / rd.y) + ro.xz;\n    \n    float shadwSum = 0.0;\n    float snakeSum = 0.0;\n    for (float dt = -6.0; dt < 1.0; dt += 0.02) {\n        float f = smoothstep(-6.0, 0.0, dt);\n        vec2 pos = posSph1(gTime + dt, 1.0 - f).xz;\n        float rad = f * gSizSph1;\n        rad *= sin(rad * 40.0 + gTime) * 0.1 + 0.9;\n        snakeSum += smoothstep(0.5, 0.1, abs(length(planePt3 - pos) - rad));\n        shadwSum += smoothstep(rad, 0.0, abs(length(planePt2 - pos) - rad * 0.5));\n    }\n    \n    ret *= 0.7 + 0.3 * smoothstep(3.0, 0.0, shadwSum);\n    ret = mix(ret, vec3(0.0, 0.0, 0.3), 0.9 * smoothstep(0.0, 11.0, snakeSum));\n    \n    return ret;\n}\n\n\n\n// From TinyTexel\n// https://www.shadertoy.com/user/TinyTexel\n// https://www.shadertoy.com/view/Wt3fzB\n// tc ∈ [-1,1]² | fov ∈ [0, π) | d ∈ [0,1]\nvec3 PaniniProjection(vec2 tc, float fov, float d)\n{\n    float d2 = d*d;\n\n    {\n        float fo = Pi / 2.0 - fov * 0.5;\n\n        float f = cos(fo)/sin(fo) * 2.0;\n        float f2 = f*f;\n\n        float b = (sqrt(max(0.0, Pow2(d+d2)*(f2+f2*f2))) - (d*f+f)) / (d2+d2*f2-1.0);\n\n        tc *= b;\n    }\n    \n    /* http://tksharpless.net/vedutismo/Pannini/panini.pdf */\n    float h = tc.x;\n    float v = tc.y;\n    \n    float h2 = h*h;\n    \n    float k = h2/Pow2(d+1.0);\n    float k2 = k*k;\n    \n    float discr = max(0.0, k2*d2 - (k+1.0)*(k*d2-1.0));\n    \n    float cosPhi = (-k*d+sqrt(discr))/(k+1.0);\n    float S = (d+1.0)/(d+cosPhi);\n    float tanTheta = v/S;\n    \n    float sinPhi = sqrt(max(0.0, 1.0-Pow2(cosPhi)));\n    if(tc.x < 0.0) sinPhi *= -1.0;\n    \n    float s = inversesqrt(1.0+Pow2(tanTheta));\n    \n    return vec3(sinPhi, tanTheta, cosPhi) * s;\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY)\n{\n    composeScene(iTime * 0.6);\n\n    float pixelSize = 1.0 / MINRES / gZoom;\n    vec2  xy        = (XY - (RES * 0.5)) * pixelSize * 2.0;\n    \n    vec3 camPt      = gPosCam;\n    vec3 lukPt      = gPosSph1;\n    vec3 cam2luk    = lukPt - camPt;\n    vec3 camFw      = normalize(cam2luk);\n    vec3 camRt      = normalize(cross(camFw, UP));\n    vec3 camUp      = normalize(cross(camRt, camFw));\n    mat3 wldFrmCam  = mat3(camRt, camUp, camFw);\n    \n    // Ray direction in camera space\n    vec2 ms = vec2(0.5);\n    if (length(iMouse.xy) > 50.0) {\n        ms = iMouse.xy / RES;\n    }\n    float paniniFOV = mix(0.2, Pi/4.0, ms.x);\n    float paniniD   = mix(0.0, 2.0, ms.y);\n    vec3 rayDirCam  = PaniniProjection(xy, paniniFOV, paniniD);\n    \n    // Ray direction in world space\n    vec3 rayDir     = wldFrmCam * rayDirCam;\n    \n    vec3 rgb        = shootRay(camPt, rayDir);\n        \n    RGBA = vec4(rgb, 1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sdXRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[308, 308, 329, 329, 341], [343, 343, 385, 385, 562], [564, 564, 595, 595, 796], [798, 798, 820, 820, 999], [1001, 1001, 1040, 1040, 2527], [2531, 2685, 2737, 2737, 3541], [3543, 3543, 3586, 3586, 4491]]}
{"id": "7sdXWs", "name": "Darts and Kites", "author": "incription", "description": "Darts and Kites! Example of a penrose tiling. Change N to increase detail. Distance fields from IQ", "tags": ["tiling", "penrose", "aperiodic"], "likes": 9, "viewed": 71, "published": "Public", "date": "1634208078", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ANGLE_ONE 0.628319\n#define ANGLE_TWO  1.88496\n#define PI         3.14159\n#define GOLDEN_RATIO 1.61803398875\n#define N 11\n#define scale (.02*(sin(iTime/3.)+2.))\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nvec3 sdShape( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2, in vec3 shapeCol, in vec3 lineCol, in float thickness ) {\n    vec3 col = lineCol;\n    \n    if(sdTriangle(p, p0, p1, p2) < 0.) col = shapeCol;\n    \n    if(min(sdSegment(p, p0, p1), sdSegment(p, p0, p2)) < thickness) col = lineCol;\n    \n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= scale;\n    uv += vec2(sin(iTime/10.), cos(iTime/10.)) *0.1;\n    vec3 col = vec3(1);\n   \n    int v = clamp(int(5.0 * (atan(uv.x, uv.y) + PI) / PI), 0, 9);\n    float offset = ANGLE_ONE /2. + float(v)/10. * PI * 2.;\n    \n    \n    \n    vec2 a = vec2(0.0, 0.0);\n    vec2 b = a + vec2(sin(ANGLE_ONE / 2. + PI + offset), cos(ANGLE_ONE / 2. + PI + offset)) * 0.3;\n    vec2 c = a + vec2(sin(PI - ANGLE_ONE / 2. + offset), cos(PI - ANGLE_ONE / 2. + offset)) * 0.3;\n    \n    if(v%2==0) {vec2 _ = b; b = c; c = _;}\n    float d;\n    bool blue = false;\n    \n    for(int i=0;i<N;i++) {\n        if(blue)\n        {\n            vec2 q = b + (a - b) / GOLDEN_RATIO;\n            vec2 r = b + (c - b) / GOLDEN_RATIO;\n            if(sdTriangle(uv, r, c, a) < 0.) { b = c; c = a; a = r; }\n            else if(sdTriangle(uv, r, q, a) < 0.) { blue = false; b = q; c = a; a = r; }\n            else { c = b; b = r; a = q; }\n        } else {\n            vec2 p = a + (b - a) / GOLDEN_RATIO;\n            if(sdTriangle(uv, c, p, b) < 0.) { a = c; c = b; b = p; }\n            else { blue = true; b = c; c = a; a = p; }\n        }\n        \n    }\n    \n    vec3 sCol = mix(vec3(0.859,0.263,0.263), vec3(0.306,0.306,0.792), float(blue));\n    vec3 lCol = vec3(0.353,0.325,0.325);\n    \n    col = sdShape(uv, a, b, c, sCol, lCol, 0.0001);\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sdXWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[168, 168, 220, 220, 339], [341, 341, 408, 408, 973], [975, 975, 1093, 1093, 1293], [1295, 1295, 1352, 1352, 2783]]}
{"id": "7sdXz2", "name": "Rounded Square - distance 2D", "author": "iq", "description": "SIGNED distance to a rounded square.", "tags": ["2d", "distance", "signed"], "likes": 21, "viewed": 423, "published": "Public API", "date": "1633564185", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org\n\n// Signed distance to a 2D rounded square.\n//\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n// and www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\n\n\n// s = side length\n// r = corner radius\nfloat sdRoundSquare( in vec2 p, in float s, in float r ) \n{\n    vec2 q = abs(p)-s+r;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // pixel and moust coordinates\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    // animate the square\n\tfloat si = 0.7 + 0.2*cos(1.2*iTime+0.0);\n    float ra = 0.3 - 0.2*cos(3.1*iTime+4.0);\n    ra = min(ra,si);\n\n    // draw the square \n\tfloat d = sdRoundSquare( p, si, ra );\n\n    // apply colors to it\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-3.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n    // mouse interaction\n    if( iMouse.z>0.001 )\n    {\n    d = sdRoundSquare( m, si, ra );\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sdXz2.jpg", "access": "shaders20k", "license": "mit", "functions": [[1347, 1387, 1446, 1446, 1532], [1536, 1536, 1593, 1628, 2465]]}
{"id": "7sdXzs", "name": "2d basic blocks", "author": "jorge2017a2", "description": "2d basic blocks", "tags": ["2dbasicblocks"], "likes": 5, "viewed": 121, "published": "Public API", "date": "1633812095", "time_retrieved": "2021-10-01T00:00:00", "image_code": "///2d basic blocks-JFP\n///por jorge2017a2...2021-oct-09\n///referencia\n//https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(antialiasing(0.05),b,d)\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n///---------------------------\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n    \nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  //colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.05,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.05,0.0));\n  return colOut;\n}\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\nreturn colOut;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdBoxRound( in vec2 p,vec2 b, in float r )\n{  return sdBox(p,b) - r; }\n\nvec2 hash( vec2 p ) // replace this by something better\n{   p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{   const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\n// -----------------------------------------------\nvec3 nube(vec2 p, vec3 col)\n{\n    float d1= sdCircle(p,1.0 );\n    float d2= sdCircle(p-vec2(0.5,0.5),1.0 );\n    float d3= sdCircle(p-vec2(-0.5,0.5),1.0 );\n    float d4= sdCircle(p-vec2(0.5,1.5),1.0 );\n    col= DrawFig(vec3(1.0)-p.y*0.25,col,d1);\n    col= DrawFig(vec3(1.0)-p.y*0.25,col,d2);\n    col= DrawFig(vec3(1.0)-p.y*0.25,col,d3);\n    col= DrawFig(vec3(1.0)-p.y*0.25,col,d4);\n    \n    return col;\n}\n\nvec3 bloque1(vec2 p, vec3 col, float esca)\n{\n    float d1=sdBoxRound(p,vec2(1.5,4.),0.25 );\n    float d2=sdBoxRound(p,vec2(0.8,3.5),0.25 );\n    d2=d2+ noise( p*0.8-0.5);\n    \n    col= DrawFigBordeCol(vec3(0.6)*esca, col, d1, vec3(0.5) );\n    col= DrawFigBordeCol(vec3(0.3)*esca, col, d2, vec3(0.4) );\n    return col;\n}\n\nvec3 grupoBloques(vec2 uv, vec3 col, float esca)\n{   col= bloque1(uv-vec2(-12.0,-4.0), col, esca);\n    col= bloque1(uv-vec2(-8.5,-5.0), col, esca);\n    col= bloque1(uv-vec2(-5.0,-5.0), col, esca);\n    col= bloque1(uv-vec2(-5.0,-5.0), col, esca);\n    col= bloque1(uv-vec2(-1.5,-6.0), col, esca);\n    col= bloque1(uv-vec2( 2.0,-6.0), col, esca);\n    col= bloque1(uv-vec2( 5.5,-8.0), col, esca);\n    col= bloque1(uv-vec2( 9.0,-8.0), col, esca);\n    col= bloque1(uv-vec2( 7.5,-9.0), col, esca);\n    col= bloque1(uv-vec2( 12.5,-6.0), col, esca);\n \n   return col;\n}    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    vec3  col=vec3(0.45,0.7,1.0)-uv.y*0.25;\n    uv*=8.0;\n    \n    vec2 uv2=uv;\n    uv2.x+=iTime*5.0;\n    uv2.x=mod(uv2.x,15.0);\n    \n    uv.x+=iTime*4.0;\n    \n    uv.x=mod(uv.x, 14.0);\n    \n    col= grupoBloques(uv-vec2(2.0,6.5), col,0.25);\n    col= grupoBloques(uv-vec2(3.0,4.0), col,0.5);\n    col= grupoBloques(uv, col,1.0);\n    \n    col= nube(uv2-vec2(1.5,1.0), col);\n    col= nube(uv2-vec2(4.0,5.0), col);\n    col= nube(uv2-vec2(8.0,3.0), col);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sdXzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 309, 343, 343, 438], [440, 471, 507, 507, 552], [557, 601, 648, 648, 675], [676, 676, 719, 719, 746], [747, 747, 795, 795, 823], [829, 829, 891, 891, 1087], [1089, 1089, 1170, 1170, 1300], [1302, 1302, 1359, 1359, 1425], [1427, 1427, 1464, 1464, 1544], [1546, 1546, 1581, 1581, 1609], [1611, 1611, 1661, 1661, 1687], [1689, 1689, 1746, 1746, 1862], [1864, 1864, 1890, 1890, 2367], [2369, 2420, 2449, 2449, 2823], [2825, 2825, 2869, 2869, 3143], [3145, 3145, 3195, 3195, 3704], [3710, 3710, 3767, 3767, 4372]]}
{"id": "7sGSRd", "name": "Figure-8 Knot", "author": "iq", "description": "A figure-8 knot, as described by François Guéritaud, Saul Schleimer, and Henry Segerman here: [url]http://gallery.bridgesmathart.org/exhibitions/2019-icerm-illustrating-mathematics/henrys[/url].", "tags": ["3d", "knot", "projective"], "likes": 85, "viewed": 1805, "published": "Public API", "date": "1635174616", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2021\n\n// This is a figure-8 knot, as described by François Guéritaud, Saul\n// Schleimer, and Henry Segerman here:\n//\n// http://gallery.bridgesmathart.org/exhibitions/2019-icerm-illustrating-mathematics/henrys\n// \n// It's defined in S3 (ie, the surface of a 4-dimensional hypersphere),\n// and then projected to R3 (regular 3D space) through a stereographic\n// projection. The extrussion of the path into a tube is done in R3.\n// I Tried adaptive subdivision, and worked well, but not completely.\n\n#define AA 1              // make 2 on fast machines\n\nconst int   kNum = 256;   // subdivisions. make 1024 on fast machines\nconst float kRad = 0.06;  // thickness\n\n\n// knot\nvec3 knot( in float t )\n{\n    t *= 6.283185;\n\n    // knot in S3\n    const float e = 0.16;\n    const float h = 0.25;\n    float a = e*sin(4.0*t);\n    float b = 1.0-a*a;\n    vec4 q = vec4 ( \n      b*(h*cos(t)+(1.0-h)*cos(3.0*t)),\n      b*(2.0*sqrt(h-h*h)*sin(2.0*t)),\n      a*(2.0),\n      b*(h*sin(t)-(1.0-h)*sin(3.0*t))\n      )\n      / (1.0+a*a);\n    \n    // rotate in the xw plane (in S3)\n    float a1 = iTime*6.283185/10.0;\n    q.xw *= mat2(cos(a1),sin(a1),-sin(a1),cos(a1));\n    \n    // stereographic projection from S3 to R3\n    vec3 p = q.xyz/(1.0-q.w);\n  \n    // scale\n    return p * 0.25;\n}\n\n//-------------------------------------------------------\n\n// intersects a capsule (single cap)\n// https://iquilezles.org/www/articles/intersectors/intersectors.htm\nvec4 iCylinder( in vec3 ro, in vec3 rd, \n                in vec3 pa, in vec3 pb, float ra, \n                out float v )\n{\n    vec4 res = vec4(-1.0);\n\n    v = 0.0;\n    vec3 ba = pb-pa;\n    vec3 oc = ro-pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoc = dot(ba,oc);\n    float ocrd = dot(oc,rd);\n    float ococ = dot(oc,oc);\n      \n    float a = baba - bard*bard;\n    float b = baba*ocrd - baoc*bard;\n    float c = baba*ococ - baoc*baoc - ra*ra*baba;\n    float h = b*b - a*c;\n    if( h>0.0 )\n    {\n        float t = (-b-sqrt(h))/a;\n\n        // body\n        float y = baoc + t*bard;\n        if( y>0.0 && y<baba )\n        {\n            v = y/baba;\n            res = vec4(t,(oc+t*rd-ba*v)/ra);\n        }\n        // sphere cap\n        else \n        {\n            h = ocrd*ocrd - ococ + ra*ra;\n            if( h>0.0 )\n            {\n                t = -ocrd - sqrt(h);\n                res = vec4(t,(oc+t*rd)/ra);\n            }\n        }\n    }\n    \n    return res;\n}\n\n// intersects a capsule\n// https://iquilezles.org/www/articles/intersectors/intersectors.htm\nbool sCylinder( in vec3 ro, in vec3 rd, \n                in vec3 pa, in vec3 pb, float ra )\n{\n    vec3 ba = pb-pa;\n    vec3 oc = ro-pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoc = dot(ba,oc);\n    float ocrd = dot(oc,rd);\n    float ococ = dot(oc,oc);\n    \n    float a = baba - bard*bard;\n    float b = baba*ocrd - baoc*bard;\n    float c = baba*ococ - baoc*baoc - ra*ra*baba;\n    float h = b*b - a*c;\n    if( h>0.0 )\n    {\n        float t = (-b-sqrt(h))/a;\n\n        // body\n        float y = baoc + t*bard;\n        if( t>0.0 && y>0.0 && y<baba ) return true;\n        // sphere cap\n        h = ocrd*ocrd - ococ + ra*ra;\n        if( h>0.0 )\n        {\n            //if( h*h<-ocrd*abs(ocrd) ) return true;\n            t = -ocrd - sqrt(h);\n            if( t>0.0 ) return true;\n        }\n    }\n    \n    return false;\n}\n\n// intersects the knot\nvec4 intersect( in vec3 ro, in vec3 rd, out float resV )\n{\n    // subdivide the knot, and find intersections\n    float   v = 0.0;\n    vec4 tnor = vec4(1e20);\n    vec3   op = knot(0.0);\n    for( int i=1; i<=kNum; i++ )\n    {\n        // parameter\n        float t = float(i)/float(kNum);\n\n        // evaluate knot\n        vec3 p = knot(t);\n\n        // segments\n        float tmpv;\n        vec4 tmp = iCylinder( ro, rd, op, p, kRad, tmpv );\n        if( tmp.x>0.0 && tmp.x<tnor.x ) { tnor = tmp; v=t+(tmpv-1.0)/float(kNum); }\n\n        op = p;\n    }\n    \n    resV = v;\n\n    return tnor;\n}\n\n// intersects the knot\nfloat shadow( in vec3 ro, in vec3 rd )\n{\n    // subdivide the knot, and find intersections\n    vec3 op = knot(0.0);\n    for( int i=1; i<=kNum; i++ )\n    {\n        // parameter\n        float t = float(i)/float(kNum);\n        \n        // evaluate knot\n        vec3 p = knot(t);\n        \n        // segments\n        if( sCylinder( ro, rd, op, p, kRad ) ) return 0.0;\n\n        op = p;\n    }\n    \n    return 1.0;\n}\n\n// do coloring and lighting\nvec3 shade( in vec3 pos, in vec3 nor, in vec3 rd, in float hm )\n{\n    // material - base color\n    vec3 mate = 0.5 + 0.5*cos(hm*6.283185+vec3(0.0,2.0,4.0));\n\n    // material - white stripes\n    vec3 cen = knot(hm); \n    vec3 w = normalize(knot(hm+0.001)-cen);\n    vec3 v = vec3(w.y,-w.x,0.0)/length(w.xy);\n    vec3 u = normalize(cross(v,w));\n    float an = atan( dot(pos-cen,u), dot(pos-cen,v) );\n    float ar = an - 30.0*hm + iTime;\n    mate += 1.5*smoothstep(-0.3,0.8,sin(6.283185*ar));\n\n    // sky lighting\n    vec3 ref = reflect(rd,nor);\n    float dif = 0.5+0.5*nor.y;\n    float spe = smoothstep(0.1,0.2,ref.y);\n    spe *= dif;\n    spe *= 0.04 + 0.96*pow( clamp(1.0+dot(rd,nor), 0.0, 1.0), 5.0 );\n    if( spe>0.001 ) spe *= shadow(pos+nor*0.001, ref);\n    vec3 col = 0.6*mate*vec3(1.0)*dif + spe*6.0;\n\n    // sss\n    float fre = clamp(1.0+dot(rd,nor),0.0,1.0);\n    col += fre*fre*(0.5+0.5*mate)*(0.2+0.8*dif);\n\n    // self occlusion\n    float occ = 0.0;\n    for( int i=1; i<=kNum/4; i++ )\n    {\n        float h = float(i)/float(kNum/4);\n        vec3  d = knot(h) - pos;\n        float l2 = dot(d,d);\n        float l = sqrt(l2);\n        float f = dot(d/l,nor);\n        occ = max(occ, f*exp2(-l2*8.0) );\n        occ = max(occ, f*1.5*kRad*kRad/l2 );\n    }\n    col *= 1.0-occ;\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera movement\t\n\tfloat an = 0.0*iTime;\n\tvec3 ro = vec3( 1.0*sin(6.283185*an), 0.0, 1.0*cos(6.283185*an) );\n    vec3 ta = vec3( 0.0, 0.02, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    \n    // render\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // background\n        vec3 col = vec3(0.17*(1.0-0.15*dot(p,p))*smoothstep(-1.0,1.0,rd.y));\n\n        // raytrace knot\n        float hm;\n        vec4 tnor = intersect( ro, rd, hm );\n        if( tnor.x<1e19 )\n        {\n            col = shade( ro+tnor.x*rd, tnor.yzw, rd, hm );\n        }\n        \n        // gain\n        col *= 1.4/(1.0+col);\n        // tint\n        col = pow( col, vec3(0.8,0.95,1.0) );\n        \n        // color to perceptual space\t\n        col = pow( col, vec3(0.4545) );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n \n    // remove color banding through dithering\n    tot += (1.0/255.0)*fract(sin(fragCoord.x*7.0+17.0*fragCoord.y)*1.317);\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sGSRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[695, 703, 728, 728, 1298], [1359, 1465, 1588, 1588, 2453], [2455, 2548, 2641, 2641, 3390], [3392, 3415, 3473, 3523, 3997], [3999, 4022, 4062, 4112, 4431], [4433, 4461, 4526, 4555, 5755], [5757, 5757, 5814, 5838, 7311]]}
{"id": "7sGXD1", "name": "Foilscape", "author": "hnh", "description": "Crinkled foil effect + evil glow. Making use of IQ's analytical noise derivatives.\nIt's a relatively simple effect based on the normalized gradient - haven't seen it before, however.\n", "tags": ["noise", "texture", "gradient", "effect", "pattern", "foil"], "likes": 1, "viewed": 106, "published": "Public API", "date": "1634558321", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec2 hash(vec2 p){   // by Dave_Hoskins: https://www.shadertoy.com/view/4djSRW\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy)*2.-1.;\n}\n\n\nvec3 noised( in vec2 p ){  // by IQ: https://www.shadertoy.com/view/XdXBRH\n// return gradient noise (in x) and its derivatives (in yz)\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n    vec2 u = f*f*f*(f*(f*6.-15.)+10.);\n    vec2 du = 30.*f*f*(f*(f-2.)+1.);\n    \n    vec2 ga = hash( i + vec2(0,0) );\n    vec2 gb = hash( i + vec2(1,0) );\n    vec2 gc = hash( i + vec2(0,1) );\n    vec2 gd = hash( i + vec2(1,1) );\n    \n    float va = dot( ga, f - vec2(0,0) );\n    float vb = dot( gb, f - vec2(1,0) );\n    float vc = dot( gc, f - vec2(0,1) );\n    float vd = dot( gd, f - vec2(1,1) );\n\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\n}\n\n\nvoid mainImage( out vec4 O, in vec2 P ){\n    vec2 p= (P-.5*iResolution.xy)/iResolution.y, pp= p;\n    p= p/(.8-p.y);  // perspective\n    p*= vec2(.5,1);  // horizontal stretch\n    p+= .1*iTime;  // diagonal scroll\n    p*= 300.;  // scale\n\n    vec3 nd= .4*noised(p/64.) + .3*noised(p/32.) + .2*noised(p/16.);  // 3-octave noise\n    vec2 n= normalize(nd.yz);\n    float a= dot(pp,vec2(2));  // changing light dir\n    \n    //O= .5*vec4(1.+dot(n,vec2(sin(a),cos(a))));  // basic (\"aluminium foil\")\n    O= .8*dot(n,vec2(sin(a),cos(a)))*(1.+.9/(nd.x-.5)*vec4(1,0,0,0));  // fancy\n    O= pow(O,vec4(3.));  // tone-map\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sGXD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 19, 79, 218], [221, 221, 246, 355, 1045], [1048, 1048, 1088, 1088, 1658]]}
{"id": "7sGXRw", "name": "newton fractal zoom", "author": "Lordinator", "description": "trying to create a newton fractal", "tags": ["complex"], "likes": 1, "viewed": 38, "published": "Public", "date": "1634402503", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define cmul(a,b) vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x)\n#define r1 vec2(0.5,0.0)\n#define r2 vec2(-0.5,0.0)\n#define r3 vec2(0.0,0.9)\n#define pi 3.14159\n\n#define c1 0xd77a61\n#define c2 0xdbd3d8\n#define c3 0x223843\n\n#define sqLength(z) z.x*z.x + z.y*z.y\n\n#define rotSpeed 0.03\n\nvec2 f(vec2 z){\n    return cmul((r1 + z), (cmul((r2 + z), (r3 + z))));\n}\n\nvec2 fp(vec2 z){\n    return cmul(((3.0*z)+2.0*(r1+r2+r3)),z) + cmul(r1,r2) + cmul(r2,r3) + cmul(r1,r3);\n}\n\n#define inv(z) vec2(z.x,-z.y)/(z.x*z.x + z.y * z.y)\n#define iterationNb 100\n\nvec2 newtonReg(vec2 z){\n\n    for (int i = 0; i < iterationNb; i +=1){\n            z -= cmul((f(z)), (inv(fp(z))));\n    }\n    return z;\n}\n\n/*\n\th : given in radians.\n\ts : from 0 to 1.\n\tv : from 0 to 1.\n*/\nvec3 hsvToRgb(vec3 hsv){/* not understood but from wikipedia :\n\t\t\t\t\t\thttps://fr.wikipedia.org/wiki/Teinte_Saturation_Valeur */\n    float s = hsv.y;\n    float v = hsv.z;\n    \n    vec3 rgb;\n    hsv.x *= 180.f/pi;\n    hsv.x = mod(hsv.x,360.f);\n    int state = int(hsv.x/60.f)%6;\n    float f = hsv.x/60.f - float(state);\n    \n    float l = (1.f - s);\n    float m = (1.f - s * f);\n    float n = (1.f - (1.f-f) * s);\n\t\n    return v * vec3[](vec3(1,n,l),\n                 vec3(m,1,l),\n                 vec3(l,1,n),\n                 vec3(l,m,1),\n                 vec3(n,l,1),\n                 vec3(1,l,m))[state];\n}\n\nvec3 hexToCol(int hex){\n    return vec3(float((hex & 0xff0000) >> 16),\n                float((hex & 0x00ff00) >> 8),\n                float((hex & 0x0000ff)))/255.0;\n}\n\n\nvec3 coordToColor(vec2 z){    \n    float r1Closeness = sqLength((z+r1));\n    float r2Closeness = sqLength((z+r2));\n    float r3Closeness = sqLength((z+r3));\n    if (r1Closeness < r2Closeness && r1Closeness < r3Closeness){\n        return hexToCol(c1);\n    }\n    if (r3Closeness < r2Closeness){\n        return hexToCol(c3);\n    }\n    return hexToCol(c2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float loopTime = iTime/4.0 - 25.49 * floor(iTime/(25.49*4.0));\n    vec2 ab = (exp(23.0-loopTime)) * (fragCoord/iResolution.xy-vec2(.24,.42));\n    ab -= vec2(0.0,.3);\n    float rotTime = 2.0*pi*(25.49-loopTime)/25.49;\n    ab = vec2(cos(rotTime) * ab.x + sin(rotTime) * ab.y,\n             -sin(rotTime) * ab.x + cos(rotTime) * ab.y);\n    vec3 col = coordToColor(newtonReg(ab));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sGXRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[288, 288, 303, 303, 360], [362, 362, 378, 378, 467], [546, 546, 569, 569, 682], [684, 749, 773, 875, 1356], [1358, 1358, 1381, 1381, 1524], [1527, 1527, 1553, 1553, 1881], [1883, 1883, 1940, 1940, 2382]]}
{"id": "7sGXWt", "name": "Fork Sierpinski HalbFettKa 764", "author": "HalbFettKaese", "description": "This version has an animated vertex count", "tags": ["2d", "fractal", "simple", "sierpinski"], "likes": 4, "viewed": 47, "published": "Public", "date": "1635481794", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Vinicius Graciano Santos - vgs/2013\n// I've learned a lot about fractals in this series of blog posts:\n// http://blog.hvidtfeldts.net/index.php/2011/08/distance-estimated-3d-fractals-iii-folding-space/\n\n#define TAU 6.283185\n\n// The range that the vertex count is interpolated within\n#define SPAN vec2(1, 10)\n\n// unit circle around polygon\n#define UCIRCLE\n\nfloat fractal(in vec2 uv, float SIDES) {\n\tfloat c = cos(1.0/float(SIDES)*TAU);\n\tfloat s = sin(1.0/float(SIDES)*TAU);\n\t\n\tmat2 m = mat2(c, s, -s, c);\n\tvec2 p = vec2(1.0, 0.0), r = p;\n\t\n\tfor (int i = 0; i < 7; ++i) {\n\t\tfloat dmin = length(uv - r);\n\t\tfor (int j = 0; j < int(ceil(SIDES)); ++j) {\n\t\t\tp = m*p;\n\t\t\tfloat d = length(uv - p); \n\t\t\tif (d < dmin) {dmin = d; r = p;}\n\t\t}\n\t\tuv = 2.0*uv - r;\n\t}\n\t\n\treturn (length(uv-r)-0.15)/pow(2.0, 7.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfloat vig = 0.15 + pow(uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1);\n\t\n\tuv = -1.0+2.0*uv;\n\tuv.x *= iResolution.x/iResolution.y;\n\t\n\tfloat d = fractal(uv, .5*(SPAN.x + SPAN.y) + .5*(SPAN.x - SPAN.y)*sin(iTime*0.1));\n\td = smoothstep(0.001, 0.015, d);\n\t\n\t#ifdef UCIRCLE\n\td *= 1.0-length(uv);\n\t#endif\n\t\t\n\tfragColor = vec4(vec3(pow(vig*d, 0.45)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sGXWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[323, 370, 410, 410, 812], [814, 814, 871, 871, 1255]]}
{"id": "7sGXzR", "name": "Surfing in the moon", "author": "LongJohnny", "description": "Inverting the texture values and using them as a heightmap to the plane. Finally bending the plane to emulate a circular surface.  All of this combined with a scaled sphere and moving camera create a speedy effect.", "tags": ["moon", "speed"], "likes": 5, "viewed": 75, "published": "Public", "date": "1634937022", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 200.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sinDisplacement(vec3 p, float strength) {\n    return sin(strength*-p.y);\n}\n\nfloat smin(float a, float b, float k) {\n    \n    /*float h = max(0., min(1., (b - a)/k + .5));\n    float m = h * (1. - h) * k;\n       \n    return a * k + b * (1. - k) - m * .5;*/\n    \n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    \n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    \n    // Project ap onto ab \n    float t = dot(ab, ap) / dot(ab, ab);\n    \n    // Projection cannot exceed the length of ab\n    t = clamp(t, 0., 1.);\n    \n    // Closest point in line segment\n    vec3 c = a + ab * t;\n    \n    // Distance to line segment\n    float d = length(p - c);\n    \n    // Distance to capsule\n    return d - r;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.)) +min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdTorus(vec3 p, vec2 r) {\n    float x = length(p.xz) - r.x;\n    float y = p.y;\n    return sqrt(x*x + y*y) - r.y;\n}\n\nfloat sdPlane(vec3 p, vec3 n, float h) {\n    \n    vec2 uv = p.xz;\n    float noise = texture(iChannel1, uv * 0.005).r;\n    \n   \n    return dot(p, normalize(n)) - (h - noise*6.);\n}\n\nfloat opCheapBend(vec3 p )\n{\n    const float k = -0.001; // or some other amount\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n   \n    \n    return sdPlane(q - vec3(0., 0., iTime * 100. + cos(iTime)+1. * 200.), vec3(cos(iTime * 1.5) * .15, 1.,0.),-3.);\n}\n\n\nvec4 GetDist(vec3 p) {\n    vec3 c = vec3(7.);\n    //p = mod(p+0.5*c,c)-0.5*c;\n    \n    float k = sin(iTime * 2.); // or some other amount\n    float e = cos(k*p.z);\n    float s = sin(k*p.z);\n    mat2  m = mat2(e,-s,s,e);\n    //p = vec3(m*p.xy,p.y);\n    \n    // From -1 to 2\n    float pulse = abs(cos(iTime * 4.));\n\n    vec3 sp = p;\n    sp *= vec3(1.,3.,.2);\n    sp -= vec3(cos(iTime*2.)*2., sin(iTime * 2.)*2., (cos(iTime) - 1.) * 3.);\n   \n    //sp. *= Rot(iTime);\n    float d = sdSphere(sp, 1.2);\n    float ds = sdSphere(p + vec3(0., 0.8 + sin(iTime) * 2., 1.2), 0.7);\n    float ds2 = sdSphere(p + vec3(0., 0.8 + sin(iTime) * 2., -1.2), 0.7);\n   \n    float d2 = sdBox(p - vec3(0.,-3., 0. ), vec3(10., .1, 10.));\n    \n    float d3 = sdCapsule(p, vec3(0., 1., 0.), vec3(.0, -1., 0.), 1.2);\n    \n    float d4 = sdTorus(p - vec3(0., pulse, 0.), vec2(1.0, 0.2));\n    \n    //float d5 = sdPlane(p - vec3(0., 0., iTime * 100.), vec3(cos(iTime * 1.5) * .15, 1.,0.),-3.);\n    float d5 = opCheapBend(p);\n    float sk = 1.;\n    \n    float mi = min(d, d5);\n    \n    return mi == d ? vec4(.5,0.01,.01,d) : vec4(vec3(.1),d5);\n}\n\nvec4 RayMarch(vec3 rayOrigin, vec3 rayDirection) {\n\n    // Current marching distance\n\tfloat currentDistance=0.;\n    vec4 curr;\n    \n    for(int i=0; i < MAX_STEPS; ++i) {\n    \n        // March in the ray direction\n    \tvec3 p = rayOrigin + rayDirection*currentDistance;\n        \n        // Get direction to solid using the distance function\n        curr = GetDist(p);\n        float dS = curr.w;\n        \n        // Increase marching distance\n        currentDistance += dS;\n        \n        // Stop ray marching when max distance is surpassed \n        // or when the distance is very small\n        if(currentDistance>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return vec4(curr.xyz, currentDistance);\n}\n\nfloat IsInShadow(vec3 rayOrigin, vec3 rayDirection) {\n    \n    float currentDistance = 0.;\n    float res = 1.;\n    \n    for (int i = 0; i < 200; ++i) {\n\n        // Get direction to solid using the distance function\n        float dS = GetDist(rayOrigin + rayDirection*currentDistance).w;\n        \n        // Stop ray marching when max distance is surpassed \n        // or when the distance is very small\n        if(dS < 0.001) return 0.;\n        \n        res = min(res, 9.*dS/currentDistance );\n        \n        // Increase marching distance\n        currentDistance += dS;\n    }\n    return res;\n\n}\n\nvec3 GetNormal(vec3 p) {\n\tconst float h = 0.1; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*GetDist( p + k.xyy*h ).w + \n                      k.yyx*GetDist( p + k.yyx*h ).w + \n                      k.yxy*GetDist( p + k.yxy*h ).w + \n                      k.xxx*GetDist( p + k.xxx*h ).w );\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n\n    // Ray from pixel to the scene origin\n    vec3 f = normalize(l-p);\n       \n    // Finding the ray direction\n    vec3 r = normalize(cross(vec3(0,1,0), f));\n    vec3 u = cross(f,r);\n   \n    vec3 c = f*z;\n    vec3 i = c + uv.x*r + uv.y*u;\n    vec3 d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    // Moving uv's to the [0,1] range and correcting porportions\n    // using the aspect ratio\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.y *= (iResolution.y/iResolution.x);\n\t//vec2 m = iMouse.xy/iResolution.xy;\n\n    float speed = iTime * 10.;\n    \n    float x = cos(iTime) * 3.;\n    vec3 ro = vec3(x, exp(abs(x) - 4.)*10. + 3.,20.);\n    //ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 sceneOrigin = vec3(0.);\n    \n    vec3 rd = GetRayDir(uv, ro, sceneOrigin, 1. );\n    vec3 col = vec3(0);\n       \n    vec4 obj = RayMarch(ro, rd);\n    float d = obj.w;\n    \n    vec3 lightDir = normalize(vec3(0., 1., 2.));\n    \n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = refract(rd, n, .5);\n        \n        float shadow = IsInShadow(p + n*SURF_DIST*10., lightDir);\n        \n        //vec3 cr = texture(iChannel0, r).rgb;\n\n        float dif = dot(normalize(n), lightDir) * .5 + .5;\n        col = obj.xyz * dif * (shadow*.9 + .1);\n    } else {\n        col = vec3(.0, .0, .0);\n    }\n    \n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sGXzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 125, 125, 187], [189, 189, 236, 236, 269], [271, 271, 310, 449, 540], [542, 542, 592, 592, 977], [979, 979, 1008, 1008, 1090], [1092, 1092, 1125, 1125, 1153], [1155, 1155, 1186, 1186, 1275], [1277, 1277, 1317, 1317, 1455], [1457, 1457, 1485, 1485, 1778], [1781, 1781, 1803, 1803, 2893], [2895, 2895, 2945, 2979, 3605], [3607, 3607, 3660, 3660, 4203], [4205, 4205, 4229, 4229, 4543], [4545, 4545, 4595, 4638, 4879], [4881, 4881, 4938, 5099, 6170]]}
{"id": "7sKSDc", "name": "Hyper Dimensional Meta Balls", "author": "wainggan", "description": "i was trying to implement AA lol", "tags": ["balls", "meta"], "likes": 4, "viewed": 103, "published": "Public", "date": "1635449862", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision highp float;\n/*\ncouldn't care less about your licences, just use this and if something happens its your fault\n*/\n\n#define AA 1.0\n\nfloat hash( float n ){\n    return fract(sin(n)*43758.5453);\n}\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n  return mix(a, b, h) - k*h*(1.0-h);\n}\n\n\nvec3 getPixel(vec2 p, float time) {\n    \n    float colOut = 1.0;\n    \n    for (float i = 0.0; i < 32.0; i += 1.0) {\n    \n        //float rnd = i * 3.141 * 2.0 + 0.412;\n        \n        //vec2 pos = vec2(sin(iTime / 2.0 * 0.9212 + rnd * 0.6512), cos(iTime / 2.0 * 1.0442 + rnd * 0.1264)) / 3.0;\n        float rnd = i*(3.141 * 2.0 + .4123);\n\t\tvec2 pos = vec2(sin(time*0.95 + rnd*3.131), cos(time*1.05 + rnd*5.763));\n\t\tpos *= vec2(sin(time*1.05 + i*i*3.141/7.131), cos(time*.95 + i*(i-1.0)*3.141/4.235));\n        \n        \n        float dist = distance(p, pos);\n        colOut = smin(colOut, dist, 0.47);\n    }\n    \n    vec3 col = vec3(colOut);\n    \n    if (colOut <= 0.14) {\n        \n        if (colOut <= 0.09) {\n            col = vec3(0.44, 0.1, 0.36);\n        } else {\n            col = vec3(0.93, 0.5, 0.8);\n        }\n        \n    } else {\n        float c = (1.0-colOut) * 0.9;\n        col = vec3(c * 0.5, c / 2.0, c * 0.8);\n    }\n    \n    return clamp(col, 0.0, 1.0);\n}\nvec3 render(vec2 p) {\n    vec3 average = vec3(0.0);\n    \n    for (float i = 0.0; i <= 3.0; i += 1.) { \n        float scale = 1.7 - i * 0.2;\n        float x = 0.9;\n        float y = 0.6;\n    \n        average += getPixel( vec2(p*scale +  vec2(x * scale, y * scale)  ), iTime / 50.0 + i * i * 2.5221);\n    }\n    vec3 col = average / 1.6;\n    \n    return clamp(col, 0.0, 1.0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mousePos = (iMouse.xy - iResolution.xy*.5) / iResolution.y;\n    \n    //const float AA = 1.0;\n    \n    vec3 average = vec3(0.0);\n    for (float y = 0.0; y < 1.0; y += 1.0 / AA) {\n        for (float x = 0.0; x < 1.0; x += 1.0 / AA) {\n            vec2 p = (fragCoord + vec2(x, y) - iResolution.xy*.5) / iResolution.y;\n            \n            average += render(p);\n        }\n    }\n    vec3 col = average / (AA * AA);\n    \n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sKSDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 140, 162, 162, 201], [202, 202, 241, 241, 328], [331, 331, 366, 366, 1303], [1304, 1304, 1325, 1325, 1678], [1682, 1682, 1739, 1739, 2202]]}
{"id": "7sKSDd", "name": "Fractal weirdness", "author": "jarble", "description": "A simple fractal pattern.", "tags": ["fractal"], "likes": 1, "viewed": 105, "published": "Public API", "date": "1635541042", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;\n    vec2 uv1 = ((fragCoord)*10.0-iResolution.xy)/iResolution.y/10.;\n    uv1 += iTime/10.;\n    for(int c=0;c<3;c++){\n        vec2 uv = uv1;\n        for(int i=0;i<6;i++)\n        {\n            uv = fract((uv.y+uv.x+uv)/1.5)*1.5;\n            uv *= (uv.x-uv.y);\n            col += col.yzx*(uv.x+uv.y)/8.;\n            col[c] += (uv.y-uv.x);\n        }\n\n\t}\n    \n    fragColor = vec4(fract(col),1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sKSDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 498]]}
{"id": "7sKSDV", "name": "Gaussian Filtered Checkerboard", "author": "oneshade", "description": "Applying a gaussion filter to a checkerboard.", "tags": ["2d", "blur", "filter", "checkerboard", "gaussian"], "likes": 5, "viewed": 45, "published": "Public", "date": "1635348037", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// https://www.desmos.com/calculator/l3buctrt3l\n\n// Error function approximation\nfloat erf(in float x) {\n    return sign(x) * sqrt(1.0 - exp2(-1.787776 * x * x));\n}\n\n// Gaussian filtered checkerboard\n// Works for filter widths between 0 and 3\n// Increase k to allow for larger filter widths\nconst float k = 4.0; // k → ∞\nfloat gchecker(in vec2 p, in vec2 w) {\n    p = mod(p, 2.0);\n    float s = 1.0 - 2.0 * mod(k, 2.0);\n    float u = 0.0, v = 0.0;\n    for (float n=-k; n <= k; n++) {\n        u += s * erf((p.x - n) / w.x);\n        v += s * erf((p.y - n) / w.y);\n        s = -s;\n    }\n\n    return (1.0 - u * v) / 2.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    vec2 w = mix(vec2(0.001), vec2(0.5), 0.5 - 0.5 * vec2(cos(0.5 * iTime), sin(iTime)));\n    fragColor = vec4(gchecker(uv, w));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sKSDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 81, 104, 104, 164], [166, 325, 363, 363, 622], [624, 624, 679, 679, 882]]}
{"id": "7sKSzy", "name": "Swarm Thing", "author": "shyuriken", "description": "This is a coincidence, but it stimulates an emotional response.", "tags": ["raymarching", "sdf", "ifs"], "likes": 7, "viewed": 128, "published": "Public", "date": "1634869397", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n\nfloat pBox(vec3 b, vec3 p) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nmat2 rot(float a) {\n\tfloat s = sin(a),\n\t      c = cos(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat hash(float x) { return fract(sin(x) * 43758.545) * 2. - 1.; }\n\nfloat sdf(vec3 p) {\n\tvec3 z = p;\n\tfloat sum = 1.5,\n\t      d = 1e5,\n\t      rnd = 0.;\n\tfor (float i = 0.; i < 12.; i++) {\n\t\tfloat td = pBox(vec3(.5), z) / sum;\n\t\tz = abs(z) - vec3(1.2, 1.2, 0);\n\t\trnd += .01 + hash(iTime * 8e-6);\n\t\td = min(td, d);\n\t\tz.xy *= rot(3.1415926 * .2 * rnd);\n\t\tz.yz *= rot(3.1415926 * .2 * rnd);\n\t\tz *= 1.5;\n\t\tsum *= 1.5;\n\t}\n\n\treturn d;\n}\n\nvec3 calcNormal(vec3 pos) {\n\tconst vec2 e = vec2(1, -1) * 58e-5;\n\treturn normalize(e.xyy * sdf(pos + e.xyy) + e.yyx * sdf(pos + e.yyx) + e.yxy * sdf(pos + e.yxy) + e.xxx * sdf(pos + e.xxx));\n}\n\nfloat calcOcclusion(vec3 pos, vec3 nor) {\n\tfloat res = 0.;\n\tvec3 aopos = pos;\n\tfor (int i = 0; i < 4; i++) {\n\t\taopos = pos + nor * .2 * float(i);\n\t\tfloat d = sdf(aopos);\n\t\tres += d;\n\t}\n\n\treturn clamp(res, 0., 1.);\n}\n\nfloat castRay(vec3 ro, vec3 rd) {\n\tfloat t = 0.;\n\tfor (int i = 0; i < 100; i++) {\n\t\tvec3 pos = ro + t * rd;\n\t\tfloat h = sdf(pos);\n\t\tif (abs(h) < .001) break;\n\t\tt += h;\n\t\tif (t > 20.) break;\n\t}\n\n\tif (t > 20.) t = -1.;\n\treturn t;\n}\n\nvec3 env_color(vec3 dir) {\n\tif (dir.y > 0.) return mix(vec3(0, .5, 1), vec3(0, .1, .8), dir.y);\n\treturn mix(vec3(0, .5, 1), vec3(.8, .7, .6), pow(-dir.y, .5));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tvec2 p = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\tfloat t,\n\t      fi = 10. * iMouse.x / iResolution.x,\n\t      th = 10. * iMouse.y / iResolution.y;\n\tvec3 ro = vec3(5. * cos(fi) * sin(th), 5. * sin(th) * sin(fi), 5. * cos(th)),\n\t     ww = normalize(vec3(0) - ro),\n\t     uu = normalize(cross(ww, vec3(0, 1, 0))),\n\t     rd = normalize(p.x * uu + p.y * normalize(cross(uu, ww)) + 1.5 * ww),\n\t     col = vec3(.25, .72, .75) - .005 * rd.y;\n\tt = castRay(ro, rd);\n\tif (t > 0.) {\n\t\tcol = vec3(1);\n\t\tvec3 pos = ro + t * rd,\n\t\t     nor = calcNormal(pos);\n\t\tfloat occ = calcOcclusion(pos, nor);\n\t\tvec3 sun_dir = normalize(vec3(.8, .4, .2));\n\t\tfloat sun_sha = step(castRay(pos + nor * .001, sun_dir), 0.),\n\t\t      sun_dif = clamp(dot(nor, sun_dir), 0., 1.),\n\t\t      sky_dif = clamp(.5 + .5 * dot(nor, vec3(0, 1, 0)), 0., 1.),\n\t\t      bou_dif = clamp(.5 + .5 * dot(nor, vec3(0, -1, 0)), 0., 1.);\n\t\tcol = vec3(.18) * vec3(4) * sun_dif * sun_sha;\n\t\tcol += vec3(.18) * vec3(.5, .8, .9) * sky_dif * occ;\n\t\tcol += vec3(.18) * vec3(.7, .3, .2) * bou_dif * occ;\n\t}\n\telse col = env_color(rd);\n\n\tfragColor = vec4(pow(col, vec3(.4545)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sKSzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 96, 124, 124, 211], [213, 213, 232, 232, 299], [301, 301, 322, 322, 368], [370, 370, 389, 389, 731], [733, 733, 760, 760, 925], [927, 927, 968, 968, 1142], [1144, 1144, 1177, 1177, 1373], [1375, 1375, 1401, 1401, 1536], [1538, 1538, 1590, 1590, 2720]]}
{"id": "7sKXDG", "name": "sea of balls", "author": "FabriceNeyret2", "description": "using the Worley/Voronoi seed-per-cell trick\n\nMouse controls camera.", "tags": ["raymarching", "voronoi", "worley", "short"], "likes": 19, "viewed": 348, "published": "Public API", "date": "1635253149", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// utils from https://www.shadertoy.com/view/llySRh\n#define rot(a)   mat2(cos(a+vec4(0,11,33,0)))                          // rotation\n#define H(p)     fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\nfloat map(vec3 q, out vec2 _I) {      // --- scene. return SDF, out = ID.\n    vec2 I = floor(q.yx), F = fract(q.yx), D,H;\n    float d, l=9.;\n    for( int k=0; k < 9; k++ )        // find closest seed within neihbors\n        D = vec2(k%3,k/3) -1.,\n        H = H(I+D+.5),                // motion parameters\n        d = length( D + H(I+D) - F    // offset to seed\n                      + .8*cos( 15.*iTime*(H.y-.5) + 6.3*H.x + vec2(0,11) ) // seed rotation\n                  ),\n        d < l ? l = d, _I = I+D : I;  // keep closest dist + its id.\n    return length(vec2(l,q.z)) - .3;\n}\n\nvoid mainImage(out vec4 O, vec2 U)    // --- renderer\n{\n    float t=9.; \n    vec3  R = iResolution, N, e = vec3(1,-1,0)/1e2, \n          D = normalize(vec3((U+U-R.xy)/R.y, -2.)),   // ray direction\n          p = vec3(0,-2,22), q,                       // marching point along ray \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(10,12,0)/1e2*cos(.3*iTime+vec3(0,11,0))+vec3(0,.12,0); \n    vec2 C;\n    for ( O=vec4(1); O.x > 0. && t > .005; O-=.005 )  \n        q = p,\n        q.yz *= rot(.5-6.3*M.y),                      // rotations\n        q.xz *= rot(-6.3*M.x),\n        t = map(q,C),                                 // SDF\n        p += .25*t*D;                                 // step forward = dist to obj\n\n    O *= hue(H(C).x);                 // coloring from ID\n                                      // optional: true shading\n    if (O.a>0.) N = normalize(   map(q+e.xyy,C)/e.xyy +  map(q+e.yxy,C)/e.yxy\n                               + map(q+e.yyx,C)/e.yyx +  map(q+e.xxx,C)/e.xxx ),\n                O *= vec4( .3 + .7*max(0.,N.z) )*1.3;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sKXDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 280, 312, 353, 863], [865, 865, 920, 920, 1916]]}
{"id": "7sKXDV", "name": "49/49", "author": "tono", "description": "for my little friend ", "tags": ["49"], "likes": 12, "viewed": 85, "published": "Public", "date": "1635350409", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//part 1 \n//\n\n//--------utill---------\nfloat pi = acos(-1.);\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat bo(vec3 p , vec3 s){p = abs(p)-s;return max(p.x,max(p.y,p.z));}\n//float bar(vec2 p , vec2 s){p = abs(p)-s;return max(p.x,p.y);}\nfloat bar(vec2 p,vec2 s,float r){p-=clamp(p,-s,s);return length(p)-r;}\nvec2 min2(vec2 a,vec2 b){if(a.x < b.x){return a;}return b;}\n#define TT(x,y) floor(x)+pow(fract(x),y)\nfloat rand(vec3 p){p  = fract( p*0.3183099+.1 );p *= 17.0;return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );}\nfloat noise(vec3 p){vec3 fp = floor(p);vec3 fs = fract(p);vec3 sf = vec3(1.,0.,0.); float a = rand(fp);float b = rand(fp + sf);float c = rand(fp + sf.yxz);float d = rand(fp + sf.xxz);float e = rand(fp + sf.yyx);float f = rand(fp + sf.xyx);float g = rand(fp + sf.yxx);float h = rand(fp + sf.xxx); vec3 u = smoothstep(0.,1.,fs); return mix(mix(mix(a,b,u.x),mix(c,d,u.x),u.y),mix(mix(e,f,u.x),mix(g,h,u.x),u.y),u.z);}\n//point light\nvec3 lightEffect(vec3 mat,float lPower,vec3 N,vec3 rd ,vec3 lightPos, vec3 lightDir,vec3 lightCol,vec3 pos,float shadow)\n{\n    vec3 col = vec3(0.);\n    float surfToLight = length(lightPos - pos);\n    vec3 surfToLightDir = normalize(pos - lightPos);\n    float range = clamp(dot(lightDir , surfToLightDir),0.,1. );\n    \n    float attenuation = 1./(1. + pow(surfToLight,2.));\n    float diff = max(0.,dot(N,lightDir) - range) * attenuation * lPower;\n    col += diff * lightCol * (attenuation ) + mat * diff;\n\n    float sp = max(0.,dot(rd,reflect(-lightDir,N)) - range) * attenuation;\n    sp = pow(sp,1.5);\n    col += sp * vec3(1.);\n    float rim = pow(clamp(1. - dot(N, -rd), 0., 1.), 1.) * 1. * attenuation;\n    col += rim * diff * mat;\n    col -= shadow;\n\n    return col;\n}\n//----------------------\n//-------------------------------------------\n//walk\n\tfloat walk(vec3 p){\n        float gtime = iTime;\n        float sig = sign(p.z);\n        float l = 1.;\n        p.x += sig/2. - 1.4;\n        l += floor((gtime - sig/2.)/2. );\n        float s = 2.;\n        p.x -=s*clamp(floor(p.x/s + .5),-l,l);\n        \n        //p.x = mod(p.x,1.)-.5;\n        p.y -=1.8;\n        vec3 wp = p;\n        wp.x += .01;\n        p.x -= clamp(p.x,-.15,.1);\n        p.z = abs(p.z)-.3;\n        \n        float o = length(p)-.15 - max(0.,sin(p.x/2.-3.2 ));\n        o=max(o,p.y-.1);\n        o = max(o,-(length(wp.xy)-.04));\n        return o;\n    }\n\tvec2 road(vec3 p)\n    {\n        vec2 o = vec2(bar(p.yz-vec2(12.,0.),vec2(10.,1.),.2),0.);\n        o.x = max(o.x,-walk(p));\n        if(o.x < .01){\n        \to.x+=noise(p*100.)/195.;\n        }\n        return o;\n    }\n\tvec2 lead(vec3 p)\n    {\n        float gtime = iTime;\n        vec2 o = vec2(10.,1.);\n        p.x += gtime;\n        p.yz *= rot(sin(gtime*10.)/10.);\n        p.y += sin(-gtime*pi + pi/2. + p.x)/12.+.1;\n      //  p.xy *= rot(pi/4.);\n        p.xy *= rot(-sin(sin(p.x/10.)-.02)+pi/4.);\n       // p.xy *= rot(-smoothstep(0.,-3.,p.x));\n        vec3 lp = p;\n        float l = 30.;\n        p.x -= l;\n        p.yz *= rot(p.x*13.3);\n        \n        p.yz = abs(p.yz)-.02;\n        p.x -= clamp(p.x,-l,l*2.);\n        \n        o.x = length(p)-.02;\n        lp.yz *= rot(2.3);\n        lp.x += 0.2;\n        lp.x -= clamp(lp.x,-.03,.03);\n        o.x = min(o.x,length(vec2(length(lp.xy)-.2,lp.z))-.03);\n        if(o.x < 0.01)\n        {\n            o.x -= noise(p * 40.)/390.;\n        }\n        return o;\n    }\n    vec2 map1(vec3 p)\n    {\n        float gtime = iTime;\n        vec2 o = vec2(10.);\n        p.x -= TT((gtime+.5),1.5);\n\t\to = min2(o,road(p));\n        o = min2(o,lead(p));\n        return o;\n    }\n\n    vec2 march1(vec3 cp , vec3 rd)\n    {\n        float depth = 0.;\n        for(int i = 0 ; i< 99 ; i++)\n        {\n            vec3 rp = cp + rd * depth;\n            vec2 d = map1(rp);\n            if(abs(d.x) < 0.009)\n            {\n                return vec2(depth,d.y);\n            }\n            if(depth > 30.)break;\n            depth += d.x;\n        }\n        return vec2(-depth , 0.);\n\n    }\n\n    float shadowmarch1(vec3 cp , vec3 rd)\n    {\n        float depth = 0.;\n        for(int i = 0 ; i< 256 ; i++)\n        {\n            vec3 rp = cp + rd * depth;\n            vec2 d = map1(rp);\n            if(d.x < 0.01)\n            {\n                return -1.;\n            }\n            if(depth > 60.)break;\n            depth += d.x;\n        }\n        return 1.;\n    }\n\tvec3 getMat1(vec3 pos,float id)\n    {\n        vec3 col = vec3(1.);\n        if(id == 0.)\n        {\n            col = vec3(0.6);\n        }else if(id == 1.){\n        \tcol = vec3(1.5,0.3,0.);\n        }\n        return col;\n    }\n    vec4 scene1(vec3 cp,vec3 target,vec2 fragCoord) {\n        vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n        p.y -= 0.2;\n        vec3 col = vec3(0.);\n        vec3 cd = normalize(vec3(target - cp));\n        vec3 cs = normalize(cross(cd , vec3(0.,1.,0.)));\n        vec3 cu = normalize(cross(cd,cs));\n        float fov = 2.5;\n        vec3 rd = normalize(cd * fov + cs * p.x + cu * p.y);\n        vec2 d = march1(cp,rd);\n        if( d.x > 0.)\n        {\n            vec2 e = vec2(1.0, -1.0) * .003;\n            vec3 pos = cp + rd * d.x;\n            vec3 N = normalize(\n                      e.xyy * map1(pos + e.xyy).x +\n                      e.yyx * map1(pos + e.yyx).x +\n                      e.yxy * map1(pos + e.yxy).x +\n                      e.xxx * map1(pos + e.xxx).x);\n            vec3 lightPos = vec3(0.,-1.5,0.);\n            vec3 lightDir = vec3(0.,-1.,0.);\n            vec3 lightCol = vec3(0.,1.,1.);\n            float lpower = 3.;\n            float shadow = step(shadowmarch1(pos + N*.01,lightDir),0.);\n            vec3 mat = getMat1(pos,d.y);\n            //vec3 lightEffect(vec3 mat,float lPower,vec3 N,vec3 rd ,vec3 lightPos, vec3 lightDir,vec3 lightCol,vec3 pos,float shadow)\n            col = lightEffect(mat,lpower,N,rd ,lightPos, lightDir,lightCol,pos,shadow);\n            float t = 1.-exp(-.001 * d.x * d.x * d.x);\n            col = mix(col,vec3(0.),t);\n        }\n        //col = pow(col,vec3(.4545));\n        return vec4(col,abs(d.x));\n    }\n//-------------------------------------------\n\nvec3 sceneManager(vec2 fragCoord)\n{\n    vec4 scol = vec4(0.);\n    if(true)\n    {\n    \tscol = scene1(vec3(-5.,-1.5,-8.)/1.6,vec3(1.,0.,0.),fragCoord);\n    }\n    return scol.rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec3 col = vec3(0.);\n    col = sceneManager(fragCoord);\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sKXDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[14, 61, 79, 79, 122], [123, 123, 149, 149, 192], [193, 257, 290, 290, 327], [328, 328, 353, 353, 387], [429, 429, 448, 448, 530], [531, 531, 551, 551, 945], [946, 960, 1082, 1082, 1731], [1732, 1811, 1830, 1830, 2375], [2377, 2377, 2400, 2400, 2590], [2592, 2592, 2615, 2615, 3381], [3386, 3386, 3409, 3409, 3577], [3583, 3583, 3619, 3619, 3974], [3980, 3980, 4023, 4023, 4345], [4347, 4347, 4384, 4384, 4570], [4575, 4575, 4624, 4624, 6071], [6072, 6119, 6154, 6154, 6297], [6299, 6299, 6355, 6355, 6444]]}
{"id": "7sKXRc", "name": "入门之路-6", "author": "jialouluo", "description": "noise+mix\n", "tags": [], "likes": 3, "viewed": 116, "published": "Public API", "date": "1635066674", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 random(in vec2 _st ){\n    _st = vec2(\n            dot(_st,vec2(127.326,321.324)),\n            dot(_st,vec2(15.31,45.332))\n                    );\n    return 2.0*fract(sin(_st)*432.23) +1.0; //1.0 ~ 3.0\n}\nfloat snoise(vec2 st){ //Gradient Noise\n    vec2 i = fract(st);//取小数\n    vec2 k = floor(st);//向负无穷取整\n    vec2 u = i*i*(3.0-2.0*i);//插值函数\n    return  mix(\n                    mix(dot(random(k + vec2(0.0,0.0)),i - vec2(0.0,0.0)),\n                        dot(random(k + vec2(0.0,1.0)),i - vec2(0.0,1.0)),\n                         u.y),\n                    mix(dot(random(k + vec2(1.0,0.0)),i - vec2(1.0,0.0)),\n                        dot(random(k + vec2(1.0,1.0)),i - vec2(1.0,1.0)),\n                         u.y),\n                       u.x\n                   );//二维noise\n}\nfloat Model(vec2 st,float N){\n    st = st*2.-1.;\n    float a = atan(st.x,st.y)+3.14;\n    float r = 6.28/N;\n    return abs(cos(floor(.5+a/r)*r-a)*length(st));\n}\nfloat getModel(vec2 st,vec2 size){\n    return Model(st*size,4.);\n}\nfloat createModel(in vec2 st,in float num[4]){\n    float exy =4.;\n    float exx =2.;\n    st*=vec2(exx,exy);\n    vec2 fi = fract(st);\n    vec2 df = floor(st);\n    fi.x = mix(fi.x,1.-fi.x,step(1.0,df.x));\n    return mix(getModel(fi,vec2(0.83,1.)),getModel(fi - vec2(0.03,0.),vec2(1.0)),num[int(df.y)]);\n}\nfloat getWork(vec2 st,float t){\n    float exy =4.;\n    float exx =2.;\n    float num[4];\n    float j = floor(mod(t,pow(2.,exy)));\n    for(int i=0;i<4;i++){\n        num[i] =0.0;\n        num[i] = step(1.0,mod(j,2.));\n        j = ceil(j/2.);\n    }\n    return createModel(st,num);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//和五同样的方法 只是将c的值进行筛选\n    vec2 vUv = fragCoord/iResolution.xy;\n    vUv*=3.;\n    vec2 uv = fract(vUv);\n  //  uv.x*=iResolution.x/iResolution.y;\n    float t = iTime*0.3;//速度\n    float c = mix(getWork(uv,t+floor(vUv.x) +floor(vUv.y) ),getWork(uv,t+floor(vUv.x) +floor(vUv.y) + 1.0),fract(t));\n    c += snoise(uv*7.)*0.08;\n    float angle = atan(uv.y,uv.x);\n    vec3 color = (0.5 + 0.5*cos(6.28*(angle/6.28 +vec3(0.6,0.7,0.9)) ))*step(c,0.77);\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sKXRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 207], [208, 208, 230, 247, 809], [810, 810, 839, 839, 969], [970, 970, 1004, 1004, 1036], [1037, 1037, 1083, 1083, 1339], [1340, 1340, 1371, 1371, 1617], [1618, 1618, 1675, 1728, 2209]]}
{"id": "7sKXWt", "name": "Broccoli Fractal", "author": "ShaderGuy57", "description": "Inspired by wyatt's fractal:\nhttps://www.shadertoy.com/view/MdKyRw", "tags": ["3d", "fractal", "color", "kifs", "broccoli"], "likes": 6, "viewed": 98, "published": "Public", "date": "1635534180", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Inspired by wyatt's fractal:\n//https://www.shadertoy.com/view/MdKyRw\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST 0.00001\n\n// The SDF\nvec4 GetDist(vec3 p) {\n    float bg = p.y;\n    \n    float t = iTime * 0.4;\n    mat2 m1 = mat2(cos(t),-sin(t),sin(t),cos(t));\n    t *= sqrt(2.);\n    mat2 m2 = mat2(cos(t),-sin(t),sin(t),cos(t));\n    t /= 3.;\n    mat2 m3 = mat2(cos(t),-sin(t),sin(t),cos(t));\n    \n    float size = 0.9;\n    \n    p -= vec3(0,1,0);\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    \n    for (int i = 0; i < 13; i++) {\n        size = size*0.66;\n        p.xz = m1*p.xz;\n        p.yz = m2*p.yz;\n        p.xy = m3*p.xy;\n        \n        col -= (p)*size;\n        p.xyz = abs(p.xyz) - size;\n    }\n    float d = min(bg, length(p)-5.8*size);\n    \n    col.r = (1.*col.x+2.)/3.;\n    col.b = (1.*col.z+0.8)/2.+0.2;\n    col.g = (.6*col.y+1.)/2. + 0.4*col.r + 0.4*col.b;\n    col *= 0.7;\n    col += 0.1;\n    \n    col = bg < length(p)-5.8*size ? vec3(1.) : col;\n    return vec4(d, col);\n}\n\n// Get the distance from camera\nvec4 RayMarch( vec3 ro, vec3 rd ) {\n    float dO = 0.;\n    vec3 col = vec3(1.);\n    \n    for( int i = 0; i < MAX_STEPS; i++ ) {\n        vec3 p = ro + rd*dO;\n        vec4 ds = GetDist(p);\n        dO += ds.x;\n        col = ds.yzw;\n        if (dO > MAX_DIST || dO < SURF_DIST) break;\n    }\n    return vec4(dO, col);\n}\n\n// Normal from SDF\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.0001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p - e.xyy).x,\n        GetDist(p - e.yxy).x,\n        GetDist(p - e.yyx).x);\n    \n    return normalize(n);\n}\n\n// Darker light if close to lightray\nfloat softshadow( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n    float dO = 0.;\n    for( int i=0; i<MAX_STEPS; i++ )\n    {\n        float ds = GetDist(ro + rd*dO).x;\n        if( ds<SURF_DIST )\n            return 0.0;\n        res = min( res, k*ds/dO );\n        dO += ds;\n    }\n    return res;\n}\n\n// Lighting\nvec3 GetLight(vec3 p, vec3 lightPos) {\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    \n    // Diffuse lighting\n    vec3 dif = vec3(clamp(dot(n, l), 0., 1.));\n    // Smooth shadow\n    //float d = softshadow(p + n*SURF_DIST*2.0, l, 10.);\n    //dif *= d;\n    // Hard shadow\n    vec4 d = RayMarch(p+n*SURF_DIST*2., l);\n    if(d.x<length(lightPos-p)) dif *= 0.1*d.x*d.yzw;\n    \n    return dif;\n}\n\n// The camera\nvec3 camDir(vec3 origin, vec2 uv) {\n    vec3 up = vec3(0., 0., 1.);\n    float zoom = 1.;\n    vec3 lookat = vec3(0, 0, 0);\n    \n    vec3 f = normalize(lookat - origin);\n    vec3 r = cross(up, f);\n    vec3 u = cross(f, r);\n    vec3 c = origin + f * zoom;\n    vec3 i = c + uv.x*r + uv.y*u;\n    vec3 rd = i - origin;\n    return rd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.);  \n    \n    // Camera origin\n    vec3 ro = vec3(0, 8, 0);\n    float t = -iTime * 0.4;\n    mat2 m1 = mat2(cos(t),-sin(t),sin(t),cos(t));\n    // Camera direction\n    vec3 rd = camDir(ro, uv);\n\n    // Distance\n    vec4 d = RayMarch(ro, rd);\n    // Intersection point\n    vec3 p = ro + rd * d.x;\n    vec3 lightOff = vec3(4,2, -3);\n    vec3 dif = GetLight(p, ro + lightOff);\n    col = dif * d.yzw;\n    \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sKXWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[143, 154, 176, 176, 996], [998, 1030, 1065, 1065, 1344], [1346, 1365, 1389, 1389, 1597], [1599, 1636, 1689, 1689, 1942], [1944, 1956, 1994, 1994, 2368], [2370, 2384, 2419, 2419, 2713], [2715, 2715, 2772, 2772, 3288]]}
{"id": "7sKXWw", "name": "IngioMarching", "author": "dreymatic", "description": "implementation of Ingio Quilez's approach to ray marching", "tags": ["raymarching"], "likes": 2, "viewed": 76, "published": "Public", "date": "1634769964", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Euclidean distance to a capped cone. Uses only two square roots instead of\n// three like the naive implementation.\n//\n//\n// Other cone functions:\n//\n// Cone bbox:         https://www.shadertoy.com/view/WdjSRK\n// Cone distance:     https://www.shadertoy.com/view/tsSXzK\n// Cone intersection: https://www.shadertoy.com/view/llcfRf\n//\n//\n// List of other 3D SDFs: https://www.shadertoy.com/playlist/43cXRl\n//\n// and http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat opTwist(in vec3 p)\n{\n    const float k = 2.0;\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2 m = mat2(c, -s, s, c);\n    vec3 q = vec3(m*p.xz, p.y);\n    return sdHexPrism(q, vec2(0.5, 0.5));\n}\n\nfloat opRep( in vec3 p, in vec3 c)\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return opTwist( q );\n}\n\nfloat map( in vec3 pos )\n{\n    return opRep(pos, vec3(2.0, 2.0, 2.0));\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n#define AA 5\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*(iTime-10.0);\n\tvec3 ro = vec3( 1.0*cos(an), 0.4, 1.0 );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 100.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = 0.2+map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(1.0,0.0,0.0));\n            col = vec3(0.2,0.3,0.4)*amb*(1.-t/tmax) + vec3(0.8,0.7,0.5)*dif;\n            //col += vec3(t/tmax, 0., 0.0);\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor =vec4(mix(vec3(.8,-.6,.3),vec3(1.5,.7,-.6),tot),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sKXWw.jpg", "access": "shaders20k", "license": "mit", "functions": [[1563, 1633, 1691, 1691, 2251], [2253, 2253, 2289, 2289, 2562], [2564, 2564, 2590, 2590, 2775], [2777, 2777, 2813, 2813, 2875], [2877, 2877, 2903, 2903, 2949], [2951, 3015, 3047, 3047, 3286], [3306, 3306, 3363, 3388, 5010]]}
{"id": "7sKXzK", "name": "rainbow_line", "author": "yyf1994", "description": "rainbow_line", "tags": ["rainbowline"], "likes": 2, "viewed": 36, "published": "Public", "date": "1634951028", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float len = 0.6;\n    \n    if(uv.y>0.4 && uv.y<0.46 ){\n         fragColor = vec4(.5*cos(6.283*(uv.x + iTime  +vec3(0.,-.33333,.33333)))+.5,1.0);\n         \n         float aa = sin(( uv.y-0.4)*  (1.0/0.6) )*6.0 ;\n         \n         vec4 vv = vec4(aa ,aa,aa,0  );\n         \n         \n         //float b = uv.y;\n         fragColor += vv;\n\n    }else{\n    \n             fragColor = vec4( 0.0 ,0.0 ,0.0,1.0);\n\n\n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sKXzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 520]]}
{"id": "7stSRf", "name": "Scanning pattern", "author": "lllcz", "description": "The effect of a scan", "tags": ["2d"], "likes": 3, "viewed": 115, "published": "Public API", "date": "1633657063", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define blue vec3(0.34, 0.78, 0.33)\n#define MOV(a,b,c,d,e) (vec2(a*cos(t)+b*cos(0.1*t)), c*sin(t)+d*cos(0.1*(t))))\n#define SMOOTH(r,R) 1.0 - smoothstep(0.0, 1.0, r)\n#define M_PI 3.1415926535897932384626433832795\nfloat _cross(vec2 uv, vec2 center, float radius){\n\n    vec2 d = uv - center;\n    //强制转换类型\n    int x = int(d.x);\n    int y = int(d.y);\n    float r = sqrt(dot(d,d));\n    if((r<radius)&&((x==y)||(x==-y)||(x==0)||(y==0)))\n    {\n       return 1.0;\n    }\n    return 0.0;\n}\n\n\nfloat movingLine(vec2 uv, vec2 c, float l){\n    //速度\n    float theta0 = 20.0*iTime;\n    \n    vec2 d = uv - c;\n    \n    float r = sqrt(dot(d,d));\n\n    if(r < l){\n    //计算到line(240)的距离确定线的宽度\n    \n        //颜色点坐标\n        vec2 p = l * vec2(cos(theta0 * M_PI/180.0), -sin(theta0 * M_PI/180.0));\n        //line颜色为设置颜色本身(l2 = 0)\n        float l2 = length(d - p*(length(d)/length(p)));\n        //d = normalize(d);\n        //度数转化\n        float theta = mod(180.0 * atan(d.y, d.x)/M_PI+theta0, 360.0);\n        float gradient = clamp(1.0 - theta/90.0, 0.0, 1.0);\n        return SMOOTH(l2, 1.0) + 0.5*gradient;\n    }\n    \n    return 0.0;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy;\n\n    vec2 c = iResolution.xy/2.0;\n    \n    vec3 finalColor = vec3(_cross(uv, c, 240.0));\n\n\n    finalColor += movingLine(uv, c, 240.0) * blue;\n    // Output to screen\n    fragColor = vec4(finalColor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7stSRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[212, 212, 261, 261, 490], [493, 493, 536, 549, 1184], [1186, 1186, 1243, 1243, 1474]]}
{"id": "7stSWf", "name": "Falling Random Numbers", "author": "dr2", "description": "Use at your peril", "tags": ["repetition", "pseudorandom"], "likes": 15, "viewed": 183, "published": "Public API", "date": "1634112614", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Falling Random Numbers\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Use at your peril\n\n// (Based on \"Panspermia Incoming\")\n\n#define AA  1  // optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat Minv3 (vec3 p);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nvec2 Rot2D (vec2 q, float a);\nmat3 StdVuMat (float el, float az);\nfloat ShowIntPZ (vec2 q, vec2 cBox, float mxChar, float val);\nfloat Hashfv2 (vec2 p);\nfloat Hashfv3 (vec3 p);\nvec3 Hashv3f (float p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\n\nvec3 qrHit, bGrid, cId, sunDir, obDisp, obRot;\nfloat dstFar, tCur, vSpd, rNum;\nbool cOcc;\nconst float pi = 3.1415927;\n\nfloat ObjDf (vec3 p)\n{\n  float d;\n  d = dstFar;\n  if (cOcc) {\n    p -= obDisp;\n    p.yz = Rot2D (p.yz, obRot.x);\n    p.xz = Rot2D (p.xz, obRot.y);\n    p.xy = Rot2D (p.xy, obRot.z);\n    d = PrRoundBoxDf (p, vec3 (0.5, 0.01, 0.3), 0.02);\n    qrHit = p;\n  }\n  return d;\n}\n\nvoid ObjState ()\n{\n  vec3 vRan;\n  vRan = Hashv3f (dot (cId, vec3 (31.1, 41.1, 51.1)) + 99.);\n  cOcc = (vRan.x * step (2., length (cId.xz)) > 0.5);\n  if (cOcc) {\n    obDisp = bGrid * (cId + 0.5) + (0.2 + 0.1 * bGrid.x * vRan.x) *\n       vec3 (sin (0.6 * vRan.z * tCur + vRan.x) * vec2 (0.5 * pi, 0.), 0.).xzy;\n    obRot = (vRan - 0.5) * 0.5 * tCur;\n    rNum = Hashfv3 (vec3 (31.1, 41.1, 51.1) * cId + 99.);\n  }\n}\n\nvec3 ObjCell (vec3 p)\n{\n  cId.xz = floor (p.xz / bGrid.xz);\n  p.y += vSpd * tCur * (1. + Hashfv2 (cId.xz));\n  cId.y = floor (p.y / bGrid.y);\n  return p;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p, cIdP, rdi;\n  float dHit, d, eps;\n  eps = 0.0005;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  rdi = 1. / rd;\n  cIdP = vec3 (-999.);\n  dHit = eps;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ObjCell (ro + dHit * rd);\n    if (cId != cIdP) {\n      ObjState ();\n      cIdP = cId;\n    }\n    d = ObjDf (p);\n    d = min (d, abs (Minv3 ((bGrid * (cId + step (0., rd)) - p) * rdi)) + eps);\n    dHit += d;\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol;\n  vec2 q;\n  float f, fd, ff;\n  if (rd.y > -0.02 && rd.y < 0.03 * Fbm1 (16. * atan (rd.z, - rd.x))) {\n    col = mix (vec3 (0.4, 0.5, 0.7), vec3 (0.3, 0.45, 0.55), smoothstep (-0.02, 0.01, rd.y));\n  } else if (rd.y > 0.) {\n    q = 0.005 * (ro.xz + tCur * vec2 (0.5, 2.) + ((200. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.1, 0.8, ff);\n    fd = smoothstep (0.1, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.8 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    fd = smoothstep (0.01, 0.1, rd.y);\n    col = mix (mix (vec3 (0.8, 0.8, 0.75), vec3 (0.4, 0.5, 0.8), 0.3 + 0.7 * fd), clCol,\n       0.1 + 0.9 * f * fd);\n  } else {\n    col = vec3 (0.1, 0.5, 0.1);\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, bgCol, vn, p;\n  float dstObj;\n  bGrid = vec3 (4.);\n  vSpd = 0.2;\n  bgCol = BgCol (ro, rd);\n  col = bgCol;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    p = ObjCell (ro);\n    ObjState ();\n    vn = ObjNf (p);\n    col = mix (vec3 (1., 1., 0.8), vec3 (0., 0., 1.), ShowIntPZ (vec2 (qrHit.x * sign (qrHit.y),\n       qrHit.z) - vec2 (0.3, -0.18), vec2 (0.6, 0.4), 5., 1. + floor ((1e5 - 1.) * rNum)));\n    col = mix (vec3 (0., 0., 1.), col, smoothstep (0., 0.02, PrRoundBox2Df (qrHit.xz -\n       vec2 (0., -0.25), vec2 (0.4, 0.005), 0.005)));\n    col *= 0.4 + 0.6 * max (dot (vn, sunDir), 0.);\n    col = mix (col, bgCol, smoothstep (0.5, 0.95, dstObj / dstFar));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, sr, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.085 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n  }\n  el = clamp (el, 0.085 * pi, 0.4 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vec3 (0.5);\n  zmFac = 3.5;\n  dstFar = 40.;\n  sunDir = normalize (vec3 (1., 2., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat DigSeg (vec2 q)\n{\n  q = 1. - smoothstep (vec2 (0.), vec2 (0.04, 0.07), abs (q) - vec2 (0.13, 0.5));\n  return q.x * q.y;\n}\n\n#define DSG(q) k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q)\n\nfloat ShowDig (vec2 q, int iv)\n{\n  vec2 vp, vm, vo;\n  float d;\n  int k, kk;\n  vp = vec2 (0.5, 0.5);\n  vm = vec2 (-0.5, 0.5);\n  vo = vp - vm;\n  if (iv == -1) k = 8;\n  else if (iv < 2) k = (iv == 0) ? 119 : 36;\n  else if (iv < 4) k = (iv == 2) ? 93 : 109;\n  else if (iv < 6) k = (iv == 4) ? 46 : 107;\n  else if (iv < 8) k = (iv == 6) ? 122 : 37;\n  else             k = (iv == 8) ? 127 : 47;\n  q = (q - 0.5) * vec2 (1.8, 2.3);\n  d = 0.;\n  kk = k;\n  DSG (q.yx - vo);  DSG (q.xy - vp);  DSG (q.xy - vm);  DSG (q.yx);\n  DSG (q.xy + vm);  DSG (q.xy + vp);  DSG (q.yx + vo);\n  return d;\n}\n\nfloat ShowIntPZ (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (Minv2 (q) >= 0. && Maxv2 (q) < 1.) {\n    q.x *= mxChar;\n    nDig = mxChar;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = max (val, 0.) / pow (10., mxChar - idChar - 1.);\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, vec3 (37., 39., 41.))) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec3 Hashv3f (float p)\n{\n  return fract (sin (p + vec3 (37., 39., 41.)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7stSWf.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[152, 824, 846, 846, 1092], [1094, 1094, 1112, 1112, 1505], [1507, 1507, 1530, 1530, 1661], [1663, 1663, 1696, 1696, 2254], [2256, 2256, 2277, 2277, 2532], [2534, 2534, 2565, 2565, 3352], [3354, 3354, 3389, 3389, 4128], [4130, 4130, 4186, 4186, 5169], [5171, 5171, 5217, 5217, 5264], [5266, 5266, 5313, 5313, 5360], [5362, 5362, 5384, 5384, 5422], [5424, 5424, 5446, 5446, 5473], [5475, 5475, 5497, 5497, 5524], [5526, 5526, 5562, 5562, 5768], [5770, 5770, 5800, 5800, 5913], [5915, 5915, 5938, 5938, 6042], [6115, 6115, 6147, 6147, 6695], [6697, 6697, 6759, 6759, 7126], [7160, 7160, 7184, 7184, 7244], [7246, 7246, 7270, 7270, 7335], [7337, 7337, 7361, 7361, 7414], [7416, 7416, 7440, 7440, 7552], [7554, 7554, 7578, 7578, 7638], [7640, 7640, 7665, 7665, 7811], [7813, 7813, 7838, 7838, 8024], [8026, 8026, 8048, 8048, 8202], [8204, 8204, 8225, 8225, 8380]]}
{"id": "7stSzl", "name": "Fbm: Banana Split", "author": "Yusef28", "description": "A short fbm experiment. They say noise is a hard thing to master.", "tags": ["noise", "fbm", "texture"], "likes": 7, "viewed": 170, "published": "Public API", "date": "1633763208", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi acos(-1.)\n\nfloat noise(vec2 st){\n    return fract(sin(dot(vec2(12.23,74.343),st))*43254.);  \n}\n\nfloat noise2D(vec2 st){\n  \n  //id,fract\n  vec2 id =floor(st);\n  vec2 f = fract(st);\n  \n  //nachbarn\n  float a = noise(id);\n  float b = noise(id + vec2(1.,0.));\n  float c = noise(id + vec2(0.,1.));\n  float d = noise(id + vec2(1.));\n  \n  \n  //f\n  f = smoothstep(0.,1.,f);\n  \n  //mix\n  float ab = mix(a,b,f.x);\n  float cd = mix(c,d,f.x);\n  return mix(ab,cd,f.y);\n}\n\nmat2 rot45 = mat2(0.707,-0.707,0.707,0.707);\n\nmat2 rot(float a){\n  float s = sin(a); float c = cos(a);\n  return mat2(c,-s,s,c);\n}\nfloat fbm(vec2 st, float N, float rt){\n    st*=3.;\n \n  float s = .5;\n  float ret = 0.;\n  for(float i = 0.; i < N; i++){\n     \n      ret += noise2D(st)*s; st *= 2.9; s/=2.; st *= rot((pi*(i+1.)/N)+rt*8.);\n      //st.x += iTime;\n  }\n  return ret;\n  \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n\n    uv.x += iTime*0.24;\n    float fa1 = fbm(uv*1.*rot(2.2)  ,5., 3.);\n    float fb1 = fbm(uv*1.*rot(5.3) + vec2(3. ,3. ) ,5., 5.);\n  \n\n  float fa2 = fbm(uv*2.*rot(2.) - vec2(8. ) + fa1 ,2., 8.);\n  float fb2 = fbm(uv*2.*rot(1.) + vec2(3.,4. ) + fb1 ,5., 6.);\n  \n  float fa3 = fbm(uv*1.*rot(1.5) + vec2(6. ) + fa2 ,5., 1.);\n  float fb3 = fbm(uv*1.*rot(1.8) + vec2(1. ,47. ) + fb2, 3., 2.);\n  \n  \n  vec3 col = vec3(0.);\n  \n  \n\tcol= mix(col, vec3(0.5,0.,0.),fb3);\n  col= mix(col,vec3(1.),fb3*fa3);\n  col= mix(col,vec3(0.9,0.6,0.2),fa3*(uv.y*0.5+0.5));\n  //col= mix(col,vec3(0.2,0.,0.9),fb3*pow(abs(uv.x*0.9),10.) );\n  col= mix(col,vec3(0.8,0.4,0.3), smoothstep(0.3,1.,fb3) );\n  col= mix(col,vec3(0.2,0.1,0.1), smoothstep(0.3,.2,fa3) );\n  col *= (fb3+0.5);\n\n  col.yz *= rot(5.6);\n  //col.xy *= rot(iTime);\n  col = pow(col,vec3(0.8));\n\tfragColor = vec4(col,1.);;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7stSzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 43, 43, 105], [107, 107, 130, 146, 468], [516, 516, 534, 534, 599], [600, 600, 638, 638, 849], [852, 852, 909, 909, 1826]]}
{"id": "7stXzl", "name": " Fab9 #inktober2021 \"pressure\"", "author": "FabriceNeyret2", "description": "[url]https://inktober.com/[/url]\n#inktober2021 themes: [img]https://i.imgur.com/QjhAdpd.png[/img]", "tags": ["2d", "short", "inktober2021", "peerpressure"], "likes": 4, "viewed": 124, "published": "Public API", "date": "1633771681", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(v)  smoothstep(3./R.y,0., v ) \n#define H(p)  fract(sin((p)*vec2(12.9898, 78.233)) * 43758.5453)\n#define C(c)  O = mix(O, vec4(c-c*S(abs(d)-.01)), S(d) );\nvoid mainImage(out vec4 O, vec2 u)\n{\n    vec2  R = iResolution.xy,\n          U = ( 2.*u - R ) / R.y, A=U,\n          C = sin(40.*U); C*=C.yx;\n          \n    O = vec4( .9+.1*clamp(C.x/fwidth(C.x),0.,1.));          // background\n    A.x = abs(A.x);\n    \n    float a=0., d;\n    for ( ; a < 5.; a ++ )                                  // 9 buddies\n        d = length(A - vec2(.7,.5)*sin(.67*a+vec2(0,33))*(1.+.05*sin(2.*iTime))) - .25,\n        C(.5);                                                     // +6.3*H(a) // asynch variant\n        \n    \n    d = length(U+=.01*H(iTime)-.005)-.25;                   // poor guy\n    C(1.);\n    \n    a = .1+.01*sin(3.*iTime); U.y += a-.1;\n    d = abs(U.x+.1)- ( U.y>0. ? a/3.*smoothstep(a,0.,U.y)   // tear\n                              : a/.3*sqrt(.01-U.y*U.y*9.) );\n    O = abs(U.y) < a ? mix(O, vec4(0,.8,1,1),  S(d) ) : O;\n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7stXzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[164, 164, 200, 200, 1031]]}
{"id": "7sVSRh", "name": "UnderScope", "author": "dmzmd", "description": "The focus is tricky. ", "tags": ["interactive", "experiment", "art"], "likes": 6, "viewed": 64, "published": "Public", "date": "1634349231", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 mod289(vec3 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec2 mod289(vec2 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec3 permute(vec3 x) {return mod289(((x*34.0)+1.0)*x);}\nfloat snoise(vec2 v)\n{\n\n//vec2 mouse=v.xy/iResolution.xy;\n     \n vec2 mouse=iMouse.xy/iResolution.xy;\n     vec4 C = vec4(mouse.x,  // (3.0-sqrt(3.0))/6.0\n                        mouse.y,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        iTime/5000.); // 1.0 / 41.0\n    // First corner\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n\n    // Other corners\n    vec2 i1;\n    //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n    //i1.y = 1.0 - i1.x;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\n    // x1 = x0 - i1 + 1.0 * C.xx ;\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n    + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt( a0*a0 + h*h );\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n    // Compute final noise value at P\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\nfloat sdLine( vec2 p, vec2 a, vec2 b, float r )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\nvec2 opRep( vec2 p, vec2 c )\n{ \n    return mod(p,c)-0.5*c;\n}\nvec2 opRepFlip( vec2 p, vec2 c )\n{ \n    vec2 fpc = floor(p/c);\n    float flip = mod((fpc.x + fpc.y), 2.);\n    vec2 ret = p - c*(fpc + 0.5);\n    if(flip >= 1.)return ret.yx;\n    return ret;\n}\nvec2 opWarp( vec2 p )\n{ \n// return vec2(sin(p.x+2.*p.y),sin(p.y+p.x));\nreturn vec2(p.x+0.1*sin(20.*p.y),p.y);\n}\n\nfloat nnoise( in vec2 uv ){return 0.5 + 0.5*snoise(uv);} //norm [0,1]\nfloat rnoise( in vec2 uv ){return 1. - abs(snoise(uv));} //ridge\nfloat fbm( vec2 x , int oct ) \n{\n    float f = 1.98;  // could be 2.0\n    float s = 0.49;  // could be 0.5\n    float a = 0.0;\n    float b = .9;\n    for( int i=0; i < 10; i++ )\n    {\n        if(i >= oct) break;\n        float n = nnoise(x);\n        a += b * n;          // accumulate values\t\t\n        b *= s;\n        x *= f;\n    }\n    return a;\n}\nfloat fbmr( vec2 x, int oct ) \n{\n    float f = 1.98;  // could be 2.0\n    float s = 0.9;  // could be 0.5\n    float a = 0.0;\n    float b = .4; //0.5\n    for( int i=0; i < 10; i++ )\n    {\n        if(i >= oct) break;\n        float n = rnoise(x);\n        a += b * n;          // accumulate values\t\t\n        b *= s;\n        x *= f;\n    }\n    return a;\n}\nfloat fbm2( in vec2 p )\n{\n    vec2 q = vec2( fbm( p + vec2(0.0,0.0) ,2 ),\n                    fbm( p + vec2(5.2,1.3) ,2) );\n\n    return fbmr( p + 2.9*q ,3); //4.0\n}\nfloat fbm3( in vec2 p )\n{\n    vec2 q = vec2( fbm( p + vec2(0.0,0.0) ,2),\n                    fbm( p + vec2(5.2,1.3) ,2) );\n\n    vec2 r = vec2( fbm( p + 4.0*q + vec2(1.7,9.2) ,2), //4q\n                    fbm( p + 4.0*q + vec2(8.3,2.8) ,2) );\n    // r = normalize(r);\n    return fbmr( p*2.0 + .4*r , 3); //4.0\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat aspect = iResolution.x/iResolution.y;\n    float nVal, n, len;\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 vUv = uv;\n    vUv *= iResolution.y/666.;\n    vUv.x *= aspect;\n    vUv*=.6;\n  //  vUv*=cos(iTime)*.4+.6;\n    //vUv += (iTime+sin(iTime))/10.;\n    vec2 c,luv,nuv = vUv*7.;\n    //nuv += rnd;\n\n    //background\n    n = fbm3(nuv);\n    nVal = 2.9*(n-0.06);\n    // nVal = 2.5*(n-0.2);\n    nVal *= 1.-0.35*clamp(abs(vUv.y-0.5)-0.1,0.,1.);\n    nVal *= 1.-0.65*smoothstep(0.27,0.45,(clamp(snoise(3.9*nuv)*nnoise(12.2*nuv)*rnoise(9.2*nuv),0.,1.)));\n    n = nVal = clamp(nVal,0.,1.);\n    nVal *= 1.14-1.5*clamp(abs(uv.y-0.5)-0.25,0.,1.);\n    // nVal *= (0.85+.1*rnoise(21.*nuv)*rnoise(17.*nuv));\n    nVal *= (0.9+.1*abs(snoise(14.*nuv)));\n    nVal *= (0.9+.1*abs(snoise(24.*nuv)));\n    nVal *= (0.86+.14*nnoise(41.*nuv));\n    // nVal *= (0.87+0.04*nnoise(0.6*nuv));\n    nVal *= (0.95+0.05*fbm(1.2*nuv,2));\n    \n    //white spots\n    // nVal += (1.-n)*2.7*nnoise(3.*nuv)*clamp(snoise(1.3*nuv),0.,1.); \n    // nVal += (1.-n)*1.72*nnoise(4.*nuv)*nnoise(6.3*nuv); \n    nVal += (1.-n)* smoothstep(0.5,1.,1.72*nnoise(3.*nuv)*nnoise(4.3*nuv)); \n\n    vec2 d1,d2;\n    d1 = vec2(rnoise(1.45*nuv),rnoise(1.45*nuv+vec2(-7.2,6.9)));\n    \n    nuv+=22.;\n    float lm = 0.6;\n    //lines 1\n    luv = nuv;\n    luv += 0.08*d1;\n    luv += 0.85 * vec2(snoise(.22*luv), snoise(.22*luv + vec2(4.2,-9.1)));\n    c = vec2(1.585);\n    len = 0.04;\n    n = sdLine( \n        opRepFlip(luv,c)\n    ,vec2(-c.x*len,-len),vec2(c.x*len,len),0.0001);\n    nVal *= lm+(1.-lm)*smoothstep(0.,0.01,n);\n    \n    //lines 2\n    luv = nuv + vec2(-13.2,15.1);\n    luv += 0.09*d1;\n    luv += 0.85 * vec2(snoise(.22*luv), snoise(.22*luv + vec2(11.2,-9.1)));\n    c = vec2(1.79);\n    len = 0.04; \n    n = sdLine( \n        opRepFlip(luv,c)\n    ,vec2(-c.x*len,len),vec2(c.x*len,-len),0.0001);\n    nVal *= lm+(1.-lm)*smoothstep(0.,0.01,n);\n    \n    //lines 3\n    luv = nuv + vec2(27.2,-21.5);\n    luv += 0.09*d1;\n    luv += 0.85 * vec2(snoise(.22*luv), snoise(.22*luv + vec2(-17.2,8.7)));\n    c = vec2(2.07);\n    len = 0.085; \n    n = sdLine( \n        opRepFlip(luv,c)\n    ,vec2(-c.x*len,0),vec2(c.x*len,0),0.0001);\n    nVal *= lm+(1.-lm)*smoothstep(0.,0.01,n);\n    \n    //lines 3.2\n    luv = nuv + vec2(-17.8,-28.5);\n    luv += 0.09*d1;\n    luv += 0.85 * vec2(snoise(.22*luv), snoise(.22*luv + vec2(-17.2,8.7)));\n    c = vec2(1.87);\n    len = 0.095; \n    n = sdLine( \n        opRepFlip(luv,c)\n    ,vec2(-c.x*len,0),vec2(c.x*len,0),0.0001);\n    nVal *= lm+(1.-lm)*smoothstep(0.,0.01,n);\n    \n    vec3 tint = vec3(1.,0.9,0.7);\n    fragColor = vec4(vec3(nVal)*tint,1.);//vec4(vUv, 0.0, 1.0);\n  }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sVSRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 66], [67, 67, 88, 88, 133], [134, 134, 156, 156, 189], [190, 190, 212, 247, 1859], [1860, 1860, 1909, 1909, 2036], [2037, 2037, 2067, 2067, 2097], [2098, 2098, 2132, 2132, 2288], [2289, 2289, 2312, 2359, 2400], [2402, 2402, 2429, 2429, 2458], [2459, 2472, 2499, 2499, 2528], [2529, 2537, 2569, 2569, 2881], [2882, 2882, 2914, 2914, 3231], [3232, 3232, 3257, 3257, 3396], [3397, 3397, 3422, 3422, 3707], [3709, 3709, 3766, 3766, 6408]]}
{"id": "7sVSW1", "name": "chungaTest4.11", "author": "chungaloid", "description": "animated seed change", "tags": ["test"], "likes": 0, "viewed": 36, "published": "Public", "date": "1634590899", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define complex vec2\n// z.s is real part; z.t is imaginary part\n\nconst float infinity = 100000.0;\nconst int maxSteps = 50;\n\nvec2 rot(vec2 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return vec2 (\n        c*p.x - s*p.y,\n        s*p.x + c*p.y\n    );\n}\n\ncomplex pow2(complex z) {\n    return complex(z.s*z.s - z.t*z.t, 2.0*z.s*z.t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( 2.0*fragCoord - iResolution.xy ) / iResolution.y;\n    vec2 m = ( 2.0*iMouse.xy - iResolution.xy ) / iResolution.y;\n\n    complex z = uv * 2.0;\n    complex c = complex(1.0, 0.0);\n    c = rot(c, iTime * 0.5);\n    \n    int i = 0;\n    for (; i < maxSteps; i++) {\n        z = pow2(z) + c;\n        if (z.s >= infinity || z.t >= infinity)\n            break;\n    }    \n    \n    vec3 col = mix(vec3(0.0), vec3(1.0), vec3(float(i) / float(maxSteps)));\n    \n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sVSW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 124, 151, 151, 267], [269, 269, 294, 294, 348], [351, 351, 408, 408, 909]]}
{"id": "7sVSWy", "name": "Asteroid w. Atmosphere", "author": "Ludicrous", "description": "A semi realistic atmospheric scattering shader, now with an asteroid.", "tags": ["physics", "rayleigh", "atmospheric"], "likes": 10, "viewed": 126, "published": "Public", "date": "1635254534", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float len(vec2 v)\n{\n    return sqrt(v.x * v.x + v.y * v.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float density = exp(-uv.y * 3.0) * (1.0 - uv.y) * 0.2;\n    vec3 transmittance = vec3(1,1,1);\n    vec3 col = vec3(0,0,0);\n    \n    float dotProduct = -cos(iTime * 0.1 - uv.x * 2.0) * (1.0 - uv.y) * 0.35 + 0.35;\n    vec3 scatter = vec3(0.25, 0.45, .75) * (1.0 - dotProduct) + vec3(0.3, 0.3, 0.3) * dotProduct; // Net in-scatter.\n    \n    float asterDist = 130.0 - iTime * 3.0;\n    vec2 asterScreenPos = vec2(iResolution.x * 0.65, iResolution.y * 0.3) - vec2(0.25 * iResolution.x, 0.25 * iResolution.y) / asterDist;\n    float dst = (len(fragCoord - asterScreenPos) - iResolution.x / asterDist * .5) / iResolution.x * asterDist * 2.0;\n\n    for (int i = 0; i < 60; i++)\n    {\n        if (dst < 0.0 && i > int(asterDist * 1.9))\n        {\n            i = 150;\n            continue;\n        }\n        col += scatter * density * transmittance; \n        transmittance -= transmittance * density * vec3(0.3, 0.55, 1); // Through-scatter: Light scattered into the camera but re-scattered out.\n    }\n    \n    if (dst < 0.0)\n        col += vec3(0.9, 0.94, 0.97) * sqrt(.2-dst) * transmittance; // Asteroid\n        \n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sVSWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 61], [63, 63, 120, 170, 1354]]}
{"id": "7sVXDd", "name": "Toxijuice_TestPattern_01", "author": "Toxijuice", "description": "A pattern made with two sets of UVs. Was meant as a simple shader to test Shadertoy, but hey it looks cool.", "tags": ["test", "pattern", "tiling", "step"], "likes": 2, "viewed": 24, "published": "Public", "date": "1635547616", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ss smoothstep\n#define saturate(x) clamp(x, 0.0, 1.0)\n\n\n//Taken from https://stackoverflow.com/a/17897228\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord)/iResolution.y;\n    \n    vec2 gv = uv * 5.0;\n    gv = fract(gv);\n    gv -= 0.5;\n    gv *= 2.0;\n    \n    vec2 gv2 = uv * 5.0 + 0.5;\n    gv2 += vec2(sin(iTime), iTime);\n    gv2 = fract(gv2);\n    gv2 -= 0.5;\n    gv2 *= 2.0;\n    \n    \n    vec3 col = vec3(gv.x, gv.y, 0.0);\n    col = vec3(1.-saturate(length(gv)));\n    col += vec3(1.-saturate(length(gv2)));\n    float stepThresh = (sin(iTime*0.33) + 1.0) * 0.5;\n    float stepOffs = 0.2;\n    col = vec3(ss(col.x, stepThresh, stepThresh + stepOffs));\n    col = step(col, vec3(0.5));\n    \n    \n    col *= hsv2rgb(vec3((iTime * 0.1) + uv.x * 0.1, 1.0, 1.0));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sVXDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 113, 135, 135, 304], [306, 306, 363, 363, 1023]]}
{"id": "7sVXDh", "name": "chungaTest4.0", "author": "chungaloid", "description": "https://www.youtube.com/watch?v=LqbZpur38nw\nThis video popped up in my youtube recommended, and it seemed pretty easy to create, so here we are!\n\nIt's probably been done a thousand times before but cool nonetheless.", "tags": ["test"], "likes": 1, "viewed": 35, "published": "Public", "date": "1634587769", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define complex vec2\n// z.s is real part; z.t is imaginary part\n\nconst float infinity = 100000.0;\nconst int maxSteps = 50;\n\n\ncomplex pow2(complex z) {\n    return complex(z.s*z.s - z.t*z.t, 2.0*z.s*z.t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( 2.0*fragCoord - iResolution.xy ) / iResolution.y;\n\n    complex c = uv * pow(1.5, -iTime) * 2.0 - complex(1.5, 0.0);\n    \n    complex z = complex(0.0);\n    \n    int steps = 0;\n    for (int i = 0; i < maxSteps; i++) {\n        steps = i;\n        z = pow2(z) + c;\n        if (z.s >= infinity || z.t >= infinity)\n            break;\n    }    \n    \n    vec3 col = mix(vec3(0.0), vec3(1.0), vec3(float(steps) / float(maxSteps)));\n    \n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sVXDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 125, 150, 150, 204], [207, 207, 264, 264, 746]]}
{"id": "7sVXWD", "name": "Fbm: Salt-Stained", "author": "Yusef28", "description": "Another fbm experiment using all the most rudimentary functions.", "tags": ["noise", "fbm", "texture", "marble"], "likes": 13, "viewed": 186, "published": "Public API", "date": "1634685455", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float noise(vec2 st){\n    return fract(sin(dot(vec2(12.23,74.343),st))*43254.);  \n}\n\n#define pi acos(-1.)\nfloat noise2D(vec2 st){\n  \n  //id,fract\n  vec2 id =floor(st);\n  vec2 f = fract(st);\n  \n  //nachbarn\n  float a = noise(id);\n  float b = noise(id + vec2(1.,0.));\n  float c = noise(id + vec2(0.,1.));\n  float d = noise(id + vec2(1.));\n  \n  \n  //f\n  f = smoothstep(0.,1.,f);\n  \n  //mix\n  float ab = mix(a,b,f.x);\n  float cd = mix(c,d,f.x);\n  return mix(ab,cd,f.y);\n}\n\nmat2 rot45 = mat2(0.707,-0.707,0.707,0.707);\n\nmat2 rot(float a){\n  float s = sin(a); float c = cos(a);\n  return mat2(c,-s,s,c);\n}\nfloat fbm(vec2 st, float N, float rt){\n    st*=3.;\n \n  float s = .5;\n  float ret = 0.;\n  for(float i = 0.; i < N; i++){\n     \n      ret += noise2D(st)*s; st *= 2.9; s/=2.; st *= rot((pi*(i+1.)/N)+rt*8.);\n      //st.x += iTime;\n  }\n  return ret;\n  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord.xy - iResolution.xy*0.5)/iResolution.y;\n\n\n  uv.x += iTime*0.14;\n  float fa1 = fbm(uv*rot(sin(uv.x)*0.001) ,5., 3.);\n  float fb1 = fbm(uv ,5., 5.);\n  \n  float fa2 = fbm(uv+sin(uv.x*15.) + fa1*5. ,4., 8.);\n  float fb2 = fbm(uv + fb1 , 5., 6.);\n \n  float fa3 = fbm(uv*1.5 + fa2 ,5., 1.);\n  float fb3 = fbm(uv + fa2, 3., 2.);\n  \n  vec3 col = vec3(0);\n  float circle = (fa3);\n  \n  //salt stained marble thing\n  //metal blue\n  col=mix(col,vec3(0.1,0.3,0.6),pow(fa3*2.4,1.5));\n  \n  //metal red\n  col=mix(col,vec3(0.9,0.3,0.3),clamp(pow(fb2*.7,1.9),0.,1.));\n  \n  //black\n  //col=mix(col,vec3(0.,0.,0.),clamp(pow(fa2*2.,9.),0.,1.)*0.3);\n  \n  //gold\n  col=mix(col,vec3(0.9,0.6,0.3),clamp(pow(fa2*1.5,20.)*0.7,0.,1.));\n  \n  //black\n col=mix(col,vec3(0.),clamp(pow(fb1*1.6,1.)*0.8,0.,1.));\n  \n  //white\n  col=mix(col,vec3(0.99),clamp(pow(fb2*1.4-0.05,20.),0.,1.));\n \n  col.yz *= rot(-0.12);\n \n \n\n fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sVXWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 83], [106, 106, 129, 145, 467], [515, 515, 533, 533, 598], [599, 599, 637, 637, 848], [850, 850, 907, 907, 1843]]}
{"id": "7sVXWK", "name": "Fork Figure-8 S DPiker 331", "author": "DPiker", "description": "See this thread:\nhttps://twitter.com/KangarooPhysics/status/1453107086573850626\n\nforked from https://www.shadertoy.com/view/fdyXWK", "tags": ["3d", "4d", "knot", "projective"], "likes": 3, "viewed": 55, "published": "Public", "date": "1635336643", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Daniel Piker 2021\n/* \nChanged to get the Seifert surface using (1/4πi) log (Q/Q∗)\n(added complex log line 85 and new field expression line 163)\n\nTrying here to show different valued Seifert fibers like in \nhttps://twitter.com/KangarooPhysics/status/1381380025568616459\n\n// Inigo Quilez 2021\n/*\n\nAn (appoximated) SDF that has a Figure-8 knot shape. It's not very\nsymmetric or pretty, but it counts (topologically).\n\nThe idea is described here https://arxiv.org/pdf/1610.02463.pdf and\ngoes like this:\n\nFrom R3, our regular 3D space, we do an inverse stereographic\nprojection to land in a 4D hyper sphere S3, a subset of R4.\n\nIn R4 we define a function F that returns a R2 field (or\ntwo scalar fields, if you want). We find the zero isosurface\n(the nodal set, or roots) of F by zeroing its two components.\n\nBecause we are only evaluating the subset of R4 that lays on S3,\nwe are really computing the intersection of the isosurfce of F\nwith the surface of the sphere S3. This creates a curve on the surface\nof the sphere, which thanks to the stereographic projection we started\nwith becomes a curve in R3, our 3D space. That's the curve we are\nraymarching.\n\nThe R4 parameter to F can be grouped as two complex numbers u and v.\nAnd in the case of this shader I'm using\n\nF(u,v) = 64v³ − 12v(3+2u²−2u*²) − (14u²+14u*²+u⁴-u*⁴)\n\nwhere u* is the conjugate of u. This curve is a figure 8 shape, as\ndescribed in the paper. You can change the SHAPE define below to\nsee another shape (a torus knot).\n\nLastly, there's more than one way to convert F into a R1 scalar field\nthan taking it's length |F|. For example, you can pass F through any\n2D SDF formula you want, such a square. Change the PROFILE define\nbellow to explore that.\n\n\nSee: https://www.shadertoy.com/view/tsBGzt\nSee: https://www.shadertoy.com/view/7sGSRd\n\n*/\n\n#define AA 1\n\n// 0: circular\n// 1: square\n#define PROFILE 0\n\n// 0: figure 8\n// 1: torus 5-2\n// 2: something i made\n#define SHAPE 0\n\n//------------------------------------------------------------\n// oldschool rand() from Visual Studio\n//------------------------------------------------------------\nint   seed = 1;\nvoid  srand(int s ) { seed = s; }\nint   rand(void) { seed = seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\n//------------------------------------------------------------\n// hash to initialize the random sequence (copied from Hugo Elias)\n//------------------------------------------------------------\nint hash( int n )\n{\n\tn = (n << 13) ^ n;\n    return n * (n * n * 15731 + 789221) + 1376312589;\n}\n\n//------------------------------------------------------------\n// complex number operations\n//------------------------------------------------------------\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 cdiv( vec2 a, vec2 b )  { float d = dot(b,b); return vec2( dot(a,b), a.y*b.x - a.x*b.y ) / d; }\nvec2 csqr( vec2 a ) { return vec2(a.x*a.x-a.y*a.y, 2.0*a.x*a.y ); }\nvec2 csqrt( vec2 z ) { float m = length(z); return sqrt( 0.5*vec2(m+z.x, m-z.x) ) * vec2( 1.0, sign(z.y) ); }\nvec2 conj( vec2 z ) { return vec2(z.x,-z.y); }\nvec2 cpow( vec2 z, float n ) { float r = length( z ); float a = atan( z.y, z.x ); return pow( r, n )*vec2( cos(a*n), sin(a*n) ); }\nvec2 clog( vec2 z) {return vec2 (log(sqrt(z.x*z.x+z.y*z.y)),atan(z.y,z.x));}\n//------------------------------------------------------------\n// https://en.wikipedia.org/wiki/Stereographic_projection\nvec4 inversestereographic(vec3 p)\n{\n    float r2 = 1.0+dot(p,p);\n    return vec4(2.0*p,r2-2.0)/r2;\n}\n//------------------------------------------------------------\n// https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdRoundSquare( in vec2 p, in float s, in float r ) \n{\n    vec2 q = abs(p)-s+r;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r;\n}\n//------------------------------------------------------------\n// https://iquilezles.org/www/articles/biplanar/biplanar.htm\nvec3 tex( sampler2D sam, in vec4 p, in vec4 n )\n{\n    n = n*n;\n    n = n*n;\n    vec3 col = vec3(0.0);\n    col += n.x*texture(iChannel0,p.yz).xyz;\n    col += n.y*texture(iChannel0,p.zw).xyz;\n    col += n.z*texture(iChannel0,p.wx).xyz;\n    col += n.w*texture(iChannel0,p.xy).xyz;\n    return col / (n.x+n.y+n.z+n.w);\n}\n//===============================================================================================\n\nvec4 r3_to_s3( in vec3 p )\n{\n    vec4 q = inversestereographic(p);\n    \n    // rotate in yw\n    float a = iTime*6.283185/24.0;\n    //float a = 0.0;\n    q.yw *= mat2(cos(a),sin(a),-sin(a),cos(a));\n    \n    return q;\n}\n\nvec2 F( in vec2 u, vec2 v )\n{\n    #if SHAPE==0\n    // figure-8\n    vec2 a = vec2(3.0,0.0) - 2.0*csqr(v) + 2.0*csqr(conj(v));\n    vec2 q = 64.0*cmul(u,csqr(u)) \n           - 12.0*cmul(u,a) \n           + 14.0*cmul(v,v) \n           + 14.0*csqr(conj(v)) \n           -      csqr(csqr(v)) \n           +      csqr(csqr(conj(v)));\n    return q;\n    #endif\n    \n    #if SHAPE==1\n    // torus\n    return 20.0*(cmul(u,csqr(csqr(u))) + csqr(v));\n    #endif    \n\n    #if SHAPE==2\n    // something I made\n    return    64.0*cmul(v,csqr(csqr(u)))\n           + 32.0*cmul(u,csqr(v))\n           + 32.0*csqr(v) \n           + 8.0;\n    #endif    \n\n}\n\nfloat field( in vec4 q )\n{\n    vec2 phi = F(q.xy,q.zw);\n    \n    #if PROFILE==0\n    //return length(phi) - 10.0;  \n    \n    //(1/4πi) log (Q/Q∗)  \n  //  return (length(cmul(vec2(0,0.785398163),clog(cdiv(phi,conj(phi))))));    \n    return abs(mod(((cmul(vec2(0,0.785398163),clog(cdiv(phi,conj(phi))))).x + iTime/3.14159265359),6.28318530718) - 0.5);\n    \n    \n    #else\n    return sdRoundSquare( phi, 8.0, 0.5 );\n    #endif\n}\n\n// only used for texturing, not for distance-estimation\nvec4 field_grad( in vec4 q )\n{\n    float f = field(q);\n    const vec2 e = vec2(0.001,0.0);\n    return normalize(vec4(\n        field(q+e.xyyy),\n        field(q+e.yxyy),\n        field(q+e.yyxy),\n        field(q+e.yyyx))-f );\n}\n\nfloat map( in vec3 p )\n{\n    float d = field(r3_to_s3(p));\n\n    // could do some automatic differentiation here...\n    float eps = 0.0001;\n    vec3 g = (vec3(field(r3_to_s3(p+vec3(eps,0.0,0.0))),\n                   field(r3_to_s3(p+vec3(0.0,eps,0.0))),\n                   field(r3_to_s3(p+vec3(0.0,0.0,eps))))-d)/eps;\n    \n    // distance estimator\n    return d/length(g);\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos, in float eps )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\n// https://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat shadow( in vec3 ro, in vec3 rd, float k )\n{\n    const float tmax = 5.0;\n    float t = 0.001;\n    float sh = 1.0;\n    for( int i=0; i<256; i++ )\n    {\n        vec3 pos = ro + rd*t;\n        float h = map(pos);\n        sh = min( sh, clamp(k*h/t,0.0,1.0) );\n        if( sh<0.001 ) break;\n        t += clamp(h,0.001,0.1);\n        if( t>tmax ) break;\n    }\n    return sh;\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat ao = 0.0;\n\tfor( int i=0; i<32; i++ )\n\t{\n\t\tfloat h = frand();\n        vec3 kv = normalize( vec3(frand(), frand(), frand()) );\n        kv *= sign(dot(kv,nor));\n\t\tao += clamp( map(pos+nor*0.001+kv*h*2.0)*1.0, 0.0, 1.0 );\n\t}\n\tao /= 32.0;\n\t\n\treturn clamp( ao*1.5-0.1, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // init random seed\n    ivec2 q = ivec2(fragCoord);\n    srand( hash(q.x+hash(q.y+hash(iFrame))));\n\n    // camera movement\t\n    float an = -0.0*iTime/20.0;\n    vec3 ro = vec3( 5.0*sin(6.283185*an), 4.0, 5.0*cos(6.283185*an) );\n    #if SHAPE>0\n    ro.xz *= 1.5;\n    ro.y = 0.0;\n    #endif\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n\n        // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 3.0*ww );\n        \n        // raymarch\n        const float tmax = 15.0;\n        float t = 0.0;\n        for( int i=0; i<8192; i++ )\n        {\n            vec3 pos = ro + rd*t;\n            float d = map(pos);\n            if( d<0.001 ) break;\n            d = min(d*0.8,0.1);\n            t += d;\n            if( t>tmax ) break;\n        }\n        \n        vec3 col = vec3(0.0);\n        col = vec3(0.05 + 0.05*rd.y);\n        if( t<tmax )\n        {\n            vec3  pos = ro + rd*t;\n            vec3  nor = calcNormal( pos, 0.0001 );\n            float occ = calcAO( pos+nor*0.001, nor );\n\n            // we do texturing in R4\n            vec4 pos4 = r3_to_s3(  pos );\n            vec4 nor4 = field_grad( pos4 );\n            vec3 mate = tex(iChannel0,pos4,nor4);\n            mate = mate*mate;\n            mate *= 0.3;\n\n            // sun\n            {\n            vec3 lig = normalize(vec3(1.0,1.0,0.2));\n            float dif = clamp(dot(nor,lig),0.0,1.0);\n            if( dif>0.001 ) dif *= shadow(pos+nor*0.001, lig, 48.0);\n            vec3 hal = normalize(lig-rd);\n            float spe = pow(clamp(dot(nor,hal),00.,1.0),32.0);\n            spe *= 0.04 + 0.96*pow( clamp(1.0-dot(lig,hal), 0.0, 1.0), 5.0 );\n            spe *= 10.0;\n\n            col  = 0.6*mate*vec3(9.0,8.0,7.0)*dif;\n            col += spe*dif*mate.x*10.0;\n            \n            float fre = clamp(1.0+dot(rd,nor),0.0,1.0);\n            col += mate*fre*1.0*(0.25+0.75*dif)*vec3(1.0,0.7,0.4);\n            }\n            \n            // sky\n            {\n            vec3 ref = reflect(rd,nor);\n            float dif = 0.5+0.5*nor.y;\n            float spe = smoothstep(0.3,0.5,ref.y);\n            spe *= dif;\n            spe *= 0.04 + 0.96*pow( clamp(1.0+dot(rd,nor), 0.0, 1.0), 5.0 );\n            if( spe>0.001 ) spe *= shadow(pos+nor*0.001, ref, 8.0);\n            col += 3.0*occ*mate*dif*vec3(0.5,0.6,1.0)*1.5;\n            col += 1.0*spe;\n            }\n\n            // sun bounce\n            col += mate*(1.0-occ)*vec3(1.2,0.5,0.2)*0.2;\n        }\n        \n        // gain\n        col = col*1.5/(1.0+col);\n        \n        // to gamma space\n        col = pow( col, vec3(0.4545) );\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    // remove color banding through dithering\n    tot += (1.0/255.0)*frand();\n \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sVXWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1961, 2142, 2163, 2163, 2175], [2176, 2176, 2194, 2194, 2251], [2252, 2252, 2271, 2271, 2303], [2304, 2497, 2516, 2516, 2592], [2594, 2749, 2779, 2779, 2834], [2835, 2835, 2865, 2865, 2935], [2936, 2936, 2957, 2957, 3003], [3004, 3004, 3026, 3026, 3113], [3114, 3114, 3135, 3135, 3160], [3161, 3161, 3191, 3191, 3291], [3292, 3292, 3312, 3312, 3368], [3369, 3490, 3525, 3525, 3590], [3591, 3729, 3788, 3788, 3874], [3875, 3999, 4048, 4048, 4314], [4315, 4414, 4442, 4442, 4630], [4632, 4632, 4661, 4661, 5260], [5262, 5262, 5288, 5288, 5689], [5691, 5747, 5777, 5777, 5971], [5973, 5973, 5997, 5997, 6347], [6349, 6413, 6459, 6459, 6656], [6658, 6721, 6770, 6770, 7094], [7096, 7096, 7138, 7138, 7422], [7424, 7424, 7481, 7505, 10704]]}
{"id": "7sVXzD", "name": "QuadTree Traversal [Reflection]", "author": "Yusef28", "description": "This quadtree traversal is simplified from my last commented verion: [url]https://www.shadertoy.com/view/7dVSRh[/url]\nbut then I went ahead and added reflections to it for only cells with scale == 2.\n\nMouse enabled!", "tags": ["reflection", "quadtree", "traverslao"], "likes": 15, "viewed": 163, "published": "Public API", "date": "1634422263", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi acos(-1.)\n#define eps 3./iResolution.y\n#define MAX_LEVEL 6.\n#define FAR 40.\n#define reflectiveTileNum pow(2.,floor(mod(iTime/2.,MAX_LEVEL-1.)))*2.\n\n\nmat2 rot(float a){\n    float c = cos(a), s = sin(a); return mat2(c,-s,s,c);}\n    \nfloat rnd(vec2 st){\n    return fract(sin(dot(vec2(12.563,19.99),st)*19.)*9439.8);}\n    \nfloat drawPoint(vec2 uv, vec2 p, float r){\n     return 1.-smoothstep(r-eps, r+eps, length(uv - p));\n}\n\nfloat distLine(vec2 p, vec2 A, vec2 B){\n  vec2 AB = B-A;\n  float t =  clamp(dot(AB,p-A)/dot(AB,AB),0.,1.);\n  vec2 P3 = A + (B-A)*t;\n  return length(P3-p);\n}\n\nfloat drawLine(vec2 uv, vec2 A, vec2 B, float r){\n    return smoothstep(r+eps, r-eps, distLine(uv,A,B));\n}\n\n// SHORTER, NEATER, BRANCHLESS, UNIQUE, SINGULAR PURPOSE\n// This map function returns the largest scaling factor for a given posision\n// the inverse of that is the cell size\nfloat map(vec2 p){\n  float s = 0.5, level = 1.; vec2 CP;\n  for(float i = 1.; i < MAX_LEVEL; i++){\n    s *= 2.;\n    CP = abs( fract(p * s) - 0.5 );\n    //if we don't pass the random check, add max to index so we break\n    i += step( rnd(floor(p * s)), 0.5 ) * MAX_LEVEL;\n  }\n  return s;\n}\n\n//SINGULAR // return the minimum distance to an axis in the rd direction\nvec4 calcT(vec2 p, vec2 rd, vec2 delta){\n    float s = map(p);\n    vec2 t;\n    t.x = rd.x < 0. ? ((p.x*s - floor(p.x*s))/s)*delta.x : ((ceil(p.x*s) - p.x*s)/s)*delta.x; \n    t.y = rd.y < 0. ? ((p.y*s - floor(p.y*s))/s)*delta.y : ((ceil(p.y*s) - p.y*s)/s)*delta.y; \n    vec2 n = t.x < t.y ? vec2(1.,0.) * -sign(rd.x) : \n                         vec2(0.,1.) * -sign(rd.y) ;\n    \n    return vec4(min(t.x,t.y), s, n);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n  uv*=2.;\n  \n  //get local uv scale\n  float s = map(uv);\n  vec2 CP = abs( fract(uv * s) - 0.5 );\n  \n  \n  //make scale 0 wherever the localUV would be an edge\n  //s *= (1.-step(0.5 - 0.002 * s, max(CP.x, CP.y)));\n  //set color to inverse of scale, the cell size at each uv\n  float f = sqrt(s)/(MAX_LEVEL);\n  vec3 col = clamp(vec3(f*f*f,f*f,f), 0., 1.);\n  col = mix(col,vec3(0.,0.,0.1)/max(CP.x, CP.y),float(s==reflectiveTileNum));\n  col *= (1.-step(0.5 - eps * s*1., max(CP.x, CP.y)));\n  \n // col /= ;\n  \n  vec2 ro = vec2(0.5), rd = vec2(-1.,0.);\n  rd *= rot(iTime/8.);\n  if(iMouse.z > 0.5) \n      rd = normalize((iMouse.xy*2.-iResolution.xy)*2./iResolution.y - ro);\n  //col = mix(col, vec3(0.,1.,0.), drawLine(uv,ro,ro+rd*8.,0.01));\n  vec2 delta = 1./max(abs(rd), eps);\n  float t = calcT(ro + rd * .01, rd, delta).x;\n  col = mix(col, vec3(0.,1.,0.), 1.-step(0.03,length(uv-ro)));\n  col = mix(col, vec3(0.,1.,0.), drawLine(uv,ro,ro+rd*t,0.01));\n  //ro += rd * t;\n  \n  //the tricky part of this algorithm as I have it is\n  //I collect t, scale and normal in t_s_n\n  //but the scale is for cell of the current position\n  //the normal is for the cell that we will hit\n  //so for each iteration I have to use the normal found in\n  //the previous interation to because that becomes the normal\n  //as we hit it, which allows for calculating the reflected ray\n  //if we need to reflect\n  vec4 t_s_n; vec2 n;\n  for(float i = 0.; i < FAR; i++){\n  \n    //get t,scale and normal all at once\n    t_s_n = calcT(ro+rd*0.01, rd, delta);\n    \n    //if the scale of the current cell the ro is on is 2,\n    //don't advance the ray, just calculate a relfected ray\n    //and a new delta for that ray, \n    //optionally nudge the ro out in the direction of the normal\n    if(t_s_n.y == reflectiveTileNum) { \n        rd = reflect(rd,n); \n        delta = 1./max(abs(rd), eps);\n        //ro += n*0.01;\n        }\n    \n    //if we hit any other cell, we advance the ray to that cell\n    //and draw the line from oldRo to new o\n    else{\n        vec2 oldRo = ro;\n        ro += rd * t_s_n.x*1.001;\n        col = mix(col, vec3(0.,.8,1.), drawLine(uv,oldRo,ro,0.015));\n        }\n        \n    //save the normal we just approached to use in the nect\n    //iteration\n    n = t_s_n.zw;\n    //draw our hit point\n    col = mix(col, vec3(1.,0.,0.), 1.-step(0.03,length(uv-ro)));\n    }\n\n    col = pow(col,vec3(0.7));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sVXzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[160, 160, 178, 178, 236], [242, 242, 261, 261, 324], [330, 330, 372, 372, 431], [433, 433, 472, 472, 589], [591, 591, 640, 640, 697], [699, 873, 891, 891, 1160], [1162, 1235, 1275, 1275, 1650], [1653, 1653, 1710, 1761, 4253]]}
{"id": "7sySWW", "name": "A Black Hole", "author": "pancakespeople", "description": "Black hole with an accretion disk", "tags": ["space", "blackhole"], "likes": 4, "viewed": 132, "published": "Public API", "date": "1634635414", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NUM_OCTAVES 5\n\nvec2 random2(vec2 st) {\n\tst = vec2(dot(st, vec2(127.1, 311.7)),\n\t\tdot(st, vec2(269.5, 183.3)));\n\treturn -1.0 + 2.0 * fract(sin(st) * 43758.5453123 * 0.7897);\n}\n\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec2 st) {\n\tvec2 i = floor(st);\n\tvec2 f = fract(st);\n\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\n\treturn mix(mix(dot(random2(i + vec2(0.0, 0.0)), f - vec2(0.0, 0.0)),\n\t\tdot(random2(i + vec2(1.0, 0.0)), f - vec2(1.0, 0.0)), u.x),\n\t\tmix(dot(random2(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0)),\n\t\t\tdot(random2(i + vec2(1.0, 1.0)), f - vec2(1.0, 1.0)), u.x), u.y);\n}\n\nfloat fbm(vec2 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n\t// Rotate to reduce axial bias\n\tmat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfor (int i = 0; i < NUM_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nmat2 rotate(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x;\n    float bhRadius = 0.1;\n    float n = fbm(uv*2.0*rotate(iTime/4.0))+0.8;\n    float dist = length(uv);\n\n    vec3 col = vec3(smoothstep(0.35, 0.0, dist - bhRadius));\n    col += smoothstep(0.3, 0.0, dist - bhRadius) * vec3(1.0, 0.8, 0.5);\n    col *= smoothstep(bhRadius, bhRadius + 0.01, dist) * n;\n    col *= fbm((uv+1.0/(dist+bhRadius))*2.0*(dist-bhRadius)*rotate(iTime/16.0))+0.8;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sySWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 46, 46, 182], [184, 269, 291, 291, 633], [635, 635, 654, 654, 922], [924, 924, 950, 950, 1034], [1036, 1036, 1093, 1143, 1644]]}
{"id": "7sySzd", "name": "Polar HSV_havocado", "author": "havocado", "description": "Polar HSV (with rotation)", "tags": ["practice"], "likes": 1, "viewed": 24, "published": "Public", "date": "1635136898", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hsv2rgb(vec3 hsv) {\n    float hue = mod(hsv.x, 360.);\n    float C = hsv.y * hsv.z;\n    float X = C * (1. - abs(mod((hue/60.), 2.)-1.));\n    \n    vec3 result_rgb;\n    if (hue < 60.) result_rgb = vec3(C, X, 0.);\n    else if (hue < 120.) result_rgb = vec3(X, C, 0.);\n    else if (hue < 180.) result_rgb = vec3(0., C, X);\n    else if (hue < 240.) result_rgb = vec3(0., X, C);\n    else if (hue < 300.) result_rgb = vec3(X, 0., C);\n    else result_rgb = vec3(C, 0., X);\n    \n    float m = hsv.z - C;\n    result_rgb = (result_rgb+m);\n    return result_rgb;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Relative position to center\n    vec2 to_center = vec2(uv.x - 0.5, uv.y - 0.5);\n    \n    // Calculating the polar coordinates\n    vec2 polar_coord = vec2(length(to_center), atan(to_center.y,to_center.x));\n\n    // Coordinate to HSV\n    vec3 hsv = vec3((polar_coord.y/6.28+0.5)*360.+180.+iTime*20., length(to_center)*2.5, 1.0);\n    \n    // HSV to RGB\n    vec3 rgb = hsv2rgb(hsv);\n\n    // Output to screen\n    fragColor = vec4(rgb, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sySzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 556], [559, 559, 616, 666, 1153]]}
{"id": "7syXDV", "name": "入门之路-8", "author": "jialouluo", "description": "分型布朗运动 +  noise \nps:我说这是云 谁赞成谁反对 QAQ", "tags": [], "likes": 6, "viewed": 164, "published": "Public API", "date": "1635304387", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\nvec2 random2(in vec2 _st ){\n    _st = vec2(\n            dot(_st,vec2(127.326,321.324)),\n            dot(_st,vec2(15.31,45.332))\n                    );\n    return 2.0*fract(sin(_st)*432.23) +1.0; //1.0 ~ 3.0\n}\nfloat snoise(vec2 st){ //Gradient Noise\n    vec2 i = fract(st);//取小数\n    vec2 k = floor(st);//向负无穷取整\n    vec2 u = i*i*(3.0-2.0*i);//插值函数\n    return  mix(\n                    mix(dot(random2(k + vec2(0.0,0.0)),i - vec2(0.0,0.0)),\n                        dot(random2(k + vec2(0.0,1.0)),i - vec2(0.0,1.0)),\n                         u.y),\n                    mix(dot(random2(k + vec2(1.0,0.0)),i - vec2(1.0,0.0)),\n                        dot(random2(k + vec2(1.0,1.0)),i - vec2(1.0,1.0)),\n                         u.y),\n                       u.x\n                   );//二维noise\n}\n#define FBM_COUNT  5\nfloat fbm(vec2 st){\n\n    float result =0.0;//输出值\n    float A = 0.5;//振幅\n    mat2 rotate = mat2(cos(0.5),sin(0.5),//旋转矩阵\n                        -sin(0.5),cos(0.5));\n    for(int i= 0;i<FBM_COUNT;i++){//分型布朗运动核心\n        result += A * noise(st);\n        st *=2.;//频率2倍\n        st *= rotate;\n        A *=0.5;//振幅1/2倍\n    }\n    return result;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv*=3.;\n    vec2 st = vec2(0.0);\n    st.x = fbm(uv +  iTime *0.112);\n    st.y = fbm(uv);\n    vec2 st2 =vec2(0.0);\n    st2.x = fbm(st + uv + iTime *0.15);\n    st2.y = fbm(st + uv + iTime *0.26);\n    float f = fbm(st + st2);\n    vec3 color = vec3(clamp(f*f,0.0,1.0),clamp(mix(0.6784,0.6345,f*f*(f-2.0)),0.0,1.0),clamp(f*f*4.0,0.0,1.0));\n    color = mix(color,vec3(0.1543,0.4345,0.7533),f*f*0.76);\n    color = mix(color,vec3(0.68777,0.0,0.7),clamp(length(st2.x),0.0,1.0));\n    color = mix(color,vec3(0.1543,1.,1.),clamp(length(st),0.0,1.0));\n    fragColor = vec4((f*f*f+.6*f*f+.5*f)*color,1.0);\n    \n}", "image_inputs": [{"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7syXDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 29, 29, 137], [138, 138, 165, 165, 510], [511, 511, 538, 538, 719], [720, 720, 742, 759, 1325], [1347, 1347, 1366, 1366, 1732], [1733, 1733, 1790, 1790, 2433]]}
{"id": "7syXRz", "name": "SDF Jack Skellington", "author": "AlexXIIs", "description": "Jack Skellington model made using SDFs", "tags": ["sdf"], "likes": 8, "viewed": 57, "published": "Public", "date": "1634240823", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Common\n\n\n// Hashing function\n// Returns a random number in [-1,1]\nfloat Hash(float seed)\n{\n  return fract(sin(seed)*43758.5453);\n}\n\n// Cosine direction\nvec3 Cosine(in float seed,in vec3 nor)\n{\n  float u=Hash(78.233+seed);\n  float v=Hash(10.873+seed);\n  \n  // method 3 by fizzer: http://www.amietia.com/lambertnotangent.html\n  float a=6.2831853*v;\n  u=2.*u-1.;\n  return normalize(nor+vec3(sqrt(1.-u*u)*vec2(cos(a),sin(a)),u));\n}\n\n// Rotation matrix around z axis\n// a : Angle\nmat3 rotate_z(float a)\n{\n  float sa=sin(a);float ca=cos(a);\n  return mat3(ca,sa,0.,-sa,ca,0.,0.,0.,1.);\n}\n\n// Compute the ray\n// m : Mouse position\n// p : Pixel\n// ro, rd : Ray origin and direction\nvoid Ray(in vec2 m,in vec2 p,out vec3 ro,out vec3 rd)\n{\n  float a=3.*3.14*m.x;\n  float le=5.;\n \n  ro=vec3(40.,0.,-1.);\n  ro*=rotate_z(3.*3.14*m.x);\n  \n  vec3 ta=vec3(0.,0.,1.);\n  vec3 ww=normalize(ta-ro);\n  vec3 uu=normalize(cross(ww,vec3(0.,0.,1.)));\n  vec3 vv=normalize(cross(uu,ww));\n  rd=normalize(p.x*uu+p.y*vv+le*ww);\n  rd.z -= 0.1;\n}\n\n// Main\n\nconst int Steps=1000;\nconst float Epsilon=.005;// Marching epsilon\nconst float T=.5;\n\nconst float rA=10.;// Maximum and minimum ray marching or sphere tracing distance from origin\nconst float rB=40.;\n\n// Transforms\nvec3 rotateX(vec3 p,float a)\n{\n  float sa=sin(a);\n  float ca=cos(a);\n  return vec3(p.x,ca*p.y-sa*p.z,sa*p.y+ca*p.z);\n}\n\nvec3 rotateY(vec3 p,float a)\n{\n  float sa=sin(a);\n  float ca=cos(a);\n  return vec3(ca*p.x+sa*p.z,p.y,-sa*p.x+ca*p.z);\n}\n\nvec3 rotateZ(vec3 p,float a)\n{\n  float sa=sin(a);\n  float ca=cos(a);\n  return vec3(ca*p.x+sa*p.y,-sa*p.x+ca*p.y,p.z);\n}\n\nvec3 translateX(vec3 p,float a)\n{\n  return vec3(p.x+a,p.y,p.z);\n}\n\nvec3 translateY(vec3 p,float a)\n{\n  return vec3(p.x,p.y+a,p.z);\n}\n\nvec3 translateZ(vec3 p,float a)\n{\n  return vec3(p.x,p.y,p.z+a);\n}\n\n// Smooth cubic falloff function\n// x : distance\n// R : radius\nfloat falloff(float x,float R)\n{\n  float u=clamp(x/R,0.,1.);\n  float v=(1.-u*u);\n  return v*v*v;\n}\n\n// Primitives\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : radius\nfloat point(vec3 p,vec3 c,float e,float R)\n{\n  return e*falloff(length(p-c),R);\n}\n\n// Operators\n\n// Blending\n// a,b : field function of the sub-trees\nvec4 ColorBlend(vec4 a,vec4 b)\n{\n  return vec4(a.x+b.x, ((a.yzw*a.x+b.yzw*b.x)/(a.x+b.x)));\n}\n\n// Union\n// a : field function of left sub-tree\nvec4 ColorIntersection(vec4 a,vec4 b)\n{\n  vec3 color;\n  if(a.x<b.x)\n  {\n    color = a.yzw;\n  }\n  else\n  {\n    color = b.yzw;\n  }\n  return vec4(max(a.x,b.x), color);\n}\n\n\nvec4 ColorSubstraction(vec4 a,vec4 b)\n{\n  vec3 color;\n  if(a.x>-b.x)\n  {\n    color = a.yzw;\n  }\n  else\n  {\n    color = b.yzw;\n  }\n  return vec4(max(a.x,-b.x), color);\n}\n\nvec4 ColorUnion(vec4 a,vec4 b)\n{\n  vec3 color;\n  if(a.x<b.x)\n  {\n    color = a.yzw;\n  }\n  else\n  {\n    color = b.yzw;\n  }\n  return vec4(min(a.x,b.x), color);\n}\n\n\nvec3 turbulence(in vec3 p)\n{\n    return vec3(0.01*sin(p.x*60.), 0.1*cos(p.y*20.)*sin(p.x*60.), 0.1*sin(p.z*5.));\n}\n\n\n//////////////////////////////\n// PRIMITIVES //\n//////////////////////////////\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nvec4 SDFSphere( vec3 p, vec3 c, float s, vec3 color)\n{\n  return vec4(length(p-c)-s, color);\n}\n\nvec4 SDFEllipsoid(vec3 p, vec3 c, vec3 r, vec3 color)\n{\n  float k0 = length((p-c)/r);\n  float k1 = length((p-c)/(r*r));\n  return vec4(k0*(k0-1.0)/k1, color);\n}\n\nvec4 SDFTorus(vec3 p, vec2 t, vec3 c, vec3 color)\n{\n  vec2 q = vec2(length(p.xz-c.xz)-t.x,p.y-c.y);\n  return vec4(length(q)-t.y, color);\n}\n\nvec4 SDFSegment(vec3 p, vec3 a, vec3 b, float r, vec3 color)\n{\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return vec4(length( pa - ba*h ) - r, color);\n}\n\nvec4 SDFBox(vec3 p, vec3 b, vec3 color)\n{\n  vec3 q = abs(p) - b;\n  return vec4(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0), color);\n}\n\n\nvec4 SDFCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb, vec3 color)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n    float x = sqrt( papa - paba*paba*baba );\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    return vec4(s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) ), color);\n}\n\nvec4 SDFPlane( vec3 p, vec3 n, float h, vec3 color)\n{\n  return vec4(dot(p,n) + h, color);\n}\n\n// Potential field of the object\n// p : point\nvec4 Object(vec3 p)\n{\n  vec3 floorP = translateZ(p, 8.5);\n\n  p = rotateY(p, -.2);\n\n  // Tete\n  vec3 headCenter = vec3(0.,0.,0.);\n  vec3 headP = translateX(p, -0.5);\n  headP = rotateY(headP, -0.2);\n  headP = rotateX(headP, 0.1);\n  headP = rotateZ(headP, 0.2);\n  vec3 eyesP = headP;\n  headP = rotateZ(headP, -1.5);\n  vec4 head = SDFSphere(headP, headCenter, 0.6, vec3(.9,.9,.9));\n  \n  // Bouche\n  vec3 mouthP = rotateX(headP, -0.5);\n  vec3 mouthCenter = vec3(0.01, 0.3, 0.5);\n  vec4 mouth = SDFTorus(mouthP - turbulence(mouthP), vec2(0.95,0.13), mouthCenter, vec3(0.,0.,0.));\n  \n  //Nez\n  vec4 leftNose = SDFSegment(p, vec3(1.1, 0.1, -0.15), vec3(1.1, 0.1, -0.1), 0.03, vec3(0.,0.,0.));\n  vec4 rightNose = SDFSegment(p, vec3(1.1, 0.15, -0.15), vec3(1.1, 0.15, -0.1), 0.04, vec3(0.,0.,0.));\n  \n  vec4 nose = ColorUnion(leftNose, rightNose);\n  head = ColorSubstraction(head, nose);\n  \n  head = ColorSubstraction(head, mouth);\n  \n  // Transfo pour yeux\n  vec3 leftEyeP = translateZ(eyesP, -0.25);\n  leftEyeP = translateX(leftEyeP, -0.5);\n  leftEyeP = translateY(leftEyeP, 0.2);\n  leftEyeP = rotateX(leftEyeP, 0.4);\n  leftEyeP = rotateZ(leftEyeP, -0.4);\n  leftEyeP = rotateY(leftEyeP, 0.);\n  \n  vec3 rightEyeP = translateZ(eyesP, -0.3);\n  rightEyeP = translateX(rightEyeP, -0.5);\n  rightEyeP = translateY(rightEyeP, -0.2);\n  rightEyeP = rotateX(rightEyeP, -0.4);\n  rightEyeP = rotateZ(rightEyeP, 0.4);\n  rightEyeP = rotateY(rightEyeP, 0.);\n  \n  // Yeux\n  vec4 halfeye1 = SDFEllipsoid(leftEyeP, vec3(0,0,0.05), vec3(0.1,0.2,0.25), vec3(0.,0.,0.));\n  vec4 halfeye2 = SDFEllipsoid(leftEyeP, vec3(0,0,0.2), vec3(0.3,0.2,0.15), vec3(1.,1.,1.));\n  vec4 halfeye3 = SDFEllipsoid(rightEyeP, vec3(0,0,0), vec3(0.1,0.2,0.25), vec3(0.,0.,0.));\n  vec4 halfeye4 = SDFEllipsoid(rightEyeP, vec3(0,0,0.1), vec3(0.3,0.2,0.15), vec3(1.,1.,1.));\n  vec4 eye1 = ColorSubstraction(halfeye1, halfeye2);\n  vec4 eye2 = ColorSubstraction(halfeye3, halfeye4);\n  vec4 eyes = ColorUnion(eye1, eye2);\n  head = ColorSubstraction(head, eyes);\n  \n  // Corps\n  vec4 neck = SDFSegment(p, vec3(0.5,0.,0.), vec3(0.,0.,-1.5), 0.1, vec3(1.,1.,1.));\n  head = ColorUnion(head, neck);\n  \n  vec4 torso = SDFCappedCone(p, vec3(0.,0.,-1.), vec3(0.,0.,-3.), 1., 0.4, vec3(0.,0.,0.));\n  \n  torso = ColorSubstraction(torso, SDFPlane(p, vec3(-0.9,0.,0.1), 0.45, vec3(0.,0.,0.)));\n  torso = ColorSubstraction(torso, SDFPlane(p, vec3(0.9,0.,0.1), 0.45, vec3(0.,0.,0.)));\n  \n  vec4 collar = SDFCappedCone(p, vec3(0.,0.,-1.1), vec3(0.,0.,-2.), 0.7, 0.4, vec3(1., 1., 1.));\n  collar = ColorSubstraction(collar, SDFPlane(p, vec3(-0.9,0.,0.1), 0.45, vec3(1.,1.,1.)));\n  collar = ColorSubstraction(collar, SDFPlane(p, vec3(0.9,0.,0.1), 0.45, vec3(0.,0.,0.)));\n  \n  torso = ColorUnion(torso, collar);\n  \n  vec3 waistCenter = translateZ(p, 3.3);\n  waistCenter = translateX(waistCenter, -0.1);\n  waistCenter = rotateY(waistCenter, 0.3);\n  vec4 waist = SDFBox(waistCenter, vec3(0.2,0.4,0.4), vec3(0.,0.,0.));\n  \n  vec4 body = ColorUnion(torso, waist);\n  \n  vec4 Jack = ColorUnion(head, body);\n  \n  // Membres\n  vec4 leftArm = SDFSegment(p, vec3(0., .5, -1.), vec3(0., 3., -1.3), 0.1, vec3(0.,0.,0.));\n  leftArm = ColorUnion(leftArm, SDFSegment(p, vec3(0., 3., -1.3), vec3(1., 4.0, 1.), 0.1, vec3(0.,0.,0.)));\n  vec4 rightArm = SDFSegment(p, vec3(0., -.5, -1.), vec3(0.2, -3., -1.4), 0.1, vec3(0.,0.,0.));\n  rightArm = ColorUnion(rightArm, SDFSegment(p, vec3(0.2, -3., -1.4), vec3(1.5, -4.5, 1.), 0.1, vec3(0.,0.,0.)));\n  \n  vec4 arms = ColorUnion(leftArm, rightArm);\n  \n  vec4 leftLeg = SDFSegment(p, vec3(0.2, 0.2, -3.6), vec3(2., 2., -1.7), 0.1, vec3(0., 0., 0.));\n  leftLeg = ColorUnion(leftLeg, SDFSegment(p, vec3(2.,2.,-1.7), vec3(0.,1.,-5.), 0.1, vec3(0.,0.,0.)));\n  vec4 rightLeg = SDFSegment(p, vec3(0.2, -0.2, -3.6), vec3(2., -2., -1.7), 0.1, vec3(0., 0., 0.));\n  rightLeg = ColorUnion(rightLeg, SDFSegment(p, vec3(2., -2., -1.7), vec3(0.,-1.5,-5.), 0.1, vec3(0.,0.,0.)));\n  \n  vec4 legs = ColorUnion(leftLeg, rightLeg);\n  Jack = ColorUnion(Jack, legs);\n  \n  vec4 leftShoe = SDFSegment(p, vec3(0.,1.,-5.), vec3(0.2,1.2,-5.1), 0.15, vec3(0.,0.,0.));\n  vec4 rightShoe = SDFSegment(p, vec3(0.,-1.5,-5.), vec3(0.2,-1.7,-5.1), 0.15, vec3(0.,0.,0.));\n  \n  vec4 shoes = ColorUnion(leftShoe, rightShoe);\n  legs = ColorUnion(legs, shoes);\n  \n  vec3 leftHandP = translateY(p, -4.);\n  leftHandP = translateX(leftHandP, -1.);\n  leftHandP = translateZ(leftHandP, -1.1);\n  vec4 leftHand = SDFBox(leftHandP, vec3(0.05,0.1,0.1), vec3(1.,1.,1.));\n  \n  vec4 leftFinger1 = SDFSegment(p, vec3(1.,4.1,1.15), vec3(1.,4.4,1.2), 0.05, vec3(1.,1.,1.));\n  leftFinger1 = ColorUnion(leftFinger1, SDFSegment(p, vec3(1.,4.4,1.2), vec3(1.5,4.4,1.35), 0.05, vec3(1.,1.,1.)));\n  leftFinger1 = ColorUnion(leftFinger1, SDFSegment(p, vec3(1.5,4.4,1.35), vec3(1.6,4.2,1.4), 0.05, vec3(1.,1.,1.)));\n  \n  vec4 leftFinger2 = SDFSegment(p, vec3(1.,4.1,1.15), vec3(1.,4.3,1.55), 0.05, vec3(1.,1.,1.));\n  leftFinger2 = ColorUnion(leftFinger2, SDFSegment(p, vec3(1.,4.3,1.55), vec3(1.4,4.1,1.8), 0.05, vec3(1.,1.,1.)));\n  leftFinger2 = ColorUnion(leftFinger2, SDFSegment(p, vec3(1.4,4.1,1.8), vec3(1.5,3.9,1.6), 0.05, vec3(1.,1.,1.)));\n  \n  vec4 leftFinger3 = SDFSegment(p, vec3(1.,4.,1.15), vec3(0.9,4.,1.7), 0.05, vec3(1.,1.,1.));\n  leftFinger3 = ColorUnion(leftFinger3, SDFSegment(p, vec3(0.9,4.,1.7), vec3(1.3,3.7,2.), 0.05, vec3(1.,1.,1.)));\n  leftFinger3 = ColorUnion(leftFinger3, SDFSegment(p, vec3(1.3,3.7,2.), vec3(1.4,3.6,1.8), 0.05, vec3(1.,1.,1.)));\n  \n  vec4 leftFinger4 = SDFSegment(p, vec3(1.,3.9,1.15), vec3(1.05,3.6,1.35), 0.05, vec3(1.,1.,1.));\n  leftFinger4 = ColorUnion(leftFinger4, SDFSegment(p, vec3(1.05,3.6,1.35), vec3(1.2,3.3,1.6), 0.05, vec3(1.,1.,1.)));\n  leftFinger4 = ColorUnion(leftFinger4, SDFSegment(p, vec3(1.2,3.3,1.6), vec3(1.35,3.55,1.5), 0.05, vec3(1.,1.,1.)));\n  \n  vec4 leftFingers = ColorUnion(leftFinger1, leftFinger2);\n  leftFingers = ColorUnion(leftFingers, leftFinger3);\n  leftFingers = ColorUnion(leftFingers, leftFinger4);\n  \n  leftHand = ColorUnion(leftHand, leftFingers);\n  \n  vec3 rightHandP = translateY(p, 4.5);\n  rightHandP = translateX(rightHandP, -1.5);\n  rightHandP = translateZ(rightHandP, -1.1);\n  vec4 rightHand = SDFBox(rightHandP, vec3(0.05,0.1,0.1), vec3(1.,1.,1.));\n  \n  vec4 rightFinger1 = SDFSegment(p, vec3(1.5,-4.4,1.15), vec3(1.4,-4.1,1.4), 0.05, vec3(1.,1.,1.));\n  rightFinger1 = ColorUnion(rightFinger1, SDFSegment(p, vec3(1.4,-4.1,1.4), vec3(1.8,-3.9,1.6), 0.05, vec3(1.,1.,1.)));\n  rightFinger1 = ColorUnion(rightFinger1, SDFSegment(p, vec3(1.8,-3.9,1.6), vec3(2.,-4.,1.55), 0.05, vec3(1.,1.,1.)));\n  \n  vec4 rightFinger2 = SDFSegment(p, vec3(1.5,-4.45,1.15), vec3(1.5,-4.45,1.55), 0.05, vec3(1.,1.,1.));\n  rightFinger2 = ColorUnion(rightFinger2, SDFSegment(p, vec3(1.5,-4.45,1.55), vec3(1.6,-4.35,1.8), 0.05, vec3(1.,1.,1.)));\n  rightFinger2 = ColorUnion(rightFinger2, SDFSegment(p, vec3(1.6,-4.35,1.8), vec3(1.8,-4.3,1.6), 0.05, vec3(1.,1.,1.)));\n  \n  vec4 rightFinger3 = SDFSegment(p, vec3(1.5,-4.55,1.15), vec3(1.6,-4.7,1.6), 0.05, vec3(1.,1.,1.));\n  rightFinger3 = ColorUnion(rightFinger3, SDFSegment(p, vec3(1.6,-4.7,1.6), vec3(1.8,-4.6,1.8), 0.05, vec3(1.,1.,1.)));\n  rightFinger3 = ColorUnion(rightFinger3, SDFSegment(p, vec3(1.8,-4.6,1.8), vec3(2.,-4.5,1.6), 0.05, vec3(1.,1.,1.)));\n  \n  vec4 rightFinger4 = SDFSegment(p, vec3(1.5,-4.55,1.15), vec3(1.5,-5.,1.25), 0.05, vec3(1.,1.,1.));\n  rightFinger4 = ColorUnion(rightFinger4, SDFSegment(p, vec3(1.5,-5.,1.25), vec3(1.9,-4.85,1.45), 0.05, vec3(1.,1.,1.)));\n  rightFinger4 = ColorUnion(rightFinger4, SDFSegment(p, vec3(1.9,-4.85,1.45), vec3(2.,-4.55,1.35), 0.05, vec3(1.,1.,1.)));\n  \n  vec4 rightFingers = ColorUnion(rightFinger1, rightFinger2);\n  rightFingers = ColorUnion(rightFingers, rightFinger3);\n  rightFingers = ColorUnion(rightFingers, rightFinger4);\n  \n  rightHand = ColorUnion(rightHand, rightFingers);\n  \n  vec4 hands = ColorUnion(leftHand, rightHand);\n  \n  arms = ColorUnion(arms, hands);\n  \n  vec4 Members = ColorUnion(arms, legs);\n  \n  Jack = ColorUnion(Jack, Members);\n  \n  // Decor\n  vec4 Moon = SDFSphere(p, vec3(-15.,-10.+5.*sin(iTime*0.05),5.-10.*sin(iTime*0.05)), 3., vec3(0.7, 0.7, 0.5)); \n  \n  vec3 tombP = translateZ(p, 7.);\n  tombP = translateX(tombP, -0.5);\n  tombP = translateY(tombP, 0.2);\n  tombP = rotateY(tombP, 0.2);\n  vec4 tomb = SDFBox(tombP, vec3(0.5,2.,2.), vec3(1.,1.,1.));\n  vec3 topP = rotateZ(p, 1.5);\n  vec4 tombTop = SDFTorus(topP, vec2(5.,1.9), vec3(-0.2,0.2,-8.1), vec3(1.,1.,1.));\n  vec4 tombLeft = SDFSphere(p, vec3(0.7,7.,-8.), 6., vec3(1.,1.,1.));\n  vec3 rightP = translateY(p, 2.1);\n  rightP = rotateX(rightP, -0.2);\n  vec4 tombRight = SDFPlane(rightP, vec3(0., 1., 0.) , 1., vec3(1.,1.,1.));\n  \n  tomb = ColorSubstraction(tomb, tombTop);\n  tomb = ColorSubstraction(tomb, tombLeft);\n  tomb = ColorSubstraction(tomb, tombRight);\n  \n  vec4 ground = SDFPlane(floorP, vec3(0., 0., 1.), 1., vec3(0.7, 0.6, 0.5));\n  vec4 mound = SDFSphere(p, vec3(2.5, 0., -17.5), 9., vec3(0.5,0.3,0.5));\n  \n  vec4 env = ColorUnion(tomb, ground);\n  env = ColorUnion(env, mound);\n  env = ColorUnion(env, Moon);\n  \n  Jack = ColorUnion(Jack, env);\n  \n  return Jack;\n}\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p,out vec3 obj_color)\n{\n  float eps=.0001;\n  vec3 n;\n  vec4 V=Object(p);\n  float v = V.x;\n  obj_color = V.yzw;\n  n.x=Object(vec3(p.x+eps,p.y,p.z)).x-v;\n  n.y=Object(vec3(p.x,p.y+eps,p.z)).x-v;\n  n.z=Object(vec3(p.x,p.y,p.z+eps)).x-v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat Trace(vec3 o,vec3 u,float rB,out bool h,out int s)\n{\n  h=false;\n  \n  // Don't start at the origin, instead move a little bit forward\n  float t=rA;\n  \n  for(int i=0;i<Steps;i++)\n  {\n    s=i;\n    vec3 p=o+t*u;\n    float v=Object(p).x;\n    // Hit object\n    if(v>0.)\n    {\n      s=i;\n      h=true;\n      break;\n    }\n    // Move along ray\n    t+=Epsilon;\n    // Escape marched far away\n    if(t>rB)\n    {\n      break;\n    }\n  }\n  return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o,vec3 u,float rB,out bool h,out int s)\n{\n  h=false;\n  \n  // Don't start at the origin, instead move a little bit forward\n  float t=rA;\n  \n  for(int i=0;i<Steps;i++)\n  {\n    s=i;\n    vec3 p=o+t*u;\n    float v=Object(p).x;\n    // Hit object\n    if(v<0.001)\n    {\n      s=i;\n      h=true;\n      break;\n    }\n    // Move along ray\n    t+=max(Epsilon,abs(v)/4.);\n    // Escape marched far away\n    if(t>rB)\n    {\n      break;\n    }\n  }\n  return t;\n}\n\n// Ambient occlusion\n// p : Point\n// n : Normal\n// a : Number of smaples\nfloat AmbientOcclusion(vec3 p,vec3 n,int a)\n{\n  if(a==0){return 1.;}\n  \n  float ao=0.;\n  \n  for(int i=0;i<a;i++)\n  {\n    vec3 d=Cosine(581.123*float(i),n);\n    \n    int s;\n    bool h;\n    float t=SphereTrace(p,d,10.,h,s);\n    if(!h){ao+=1.;}\n    else if(t>5.)\n    {\n      ao+=1.;\n    }\n  }\n  \n  ao/=float(a);\n  return ao;\n}\n\n// Background color\nvec3 background(vec3 rd)\n{\n  return mix(vec3(.14,.11,.55),vec3(.13,.20,.18),rd.z*.5+.5);\n}\n\nfloat Light(vec3 p,vec3 n)\n{\n  // point light\n  const vec3 lp=vec3(5.,10.,25.);\n  \n  vec3 l=normalize(lp-p);\n  \n  // Not even Phong shading, use weighted cosine instead for smooth transitions\n  float diff=pow(.5*(1.+dot(n,l)),2.);\n  \n  bool h;\n  int s;\n  float t=SphereTrace(p+.1*n,l,100.,h,s);\n  if(!h)\n  {\n    return diff;\n  }\n  return 0.;\n}\n\nfloat SmoothLight(vec3 p,vec3 n,int a)\n{\n  if(a==0)\n  return 1.;\n  \n  // point light\n  const vec3 lp=vec3(5.,10.,25.);\n  \n  vec3 l=normalize(lp-p);\n  \n  float lo=0.;\n  \n  for(int i=0;i<a;i++)\n  {\n    vec3 d=Cosine(581.123*float(i),n);\n    d=normalize(l+d*.15);\n    int s;\n    bool h;\n    float t=SphereTrace(p,d,10.,h,s);\n    if(!h){lo+=1.;}\n    else if(t>100.)\n    {\n      lo+=1.;\n    }\n  }\n  \n  lo/=float(a);\n  return lo;\n  \n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\nvec3 Shade(vec3 p,vec3 n)\n{\n  vec3 c=.25+.25*background(n);\n  c+=.15*AmbientOcclusion(p+.1*n,n,0)*vec3(1.,1.,1.);\n  c+=.35*Light(p,n);\n  return c;\n}\n\n// Shading with number of steps\nvec3 ShadeSteps(int n)\n{\n  float t=float(n)/(float(Steps-1));\n  return .5+mix(vec3(.05,.05,.5),vec3(.65,.39,.65),t);\n}\n\n// Picture in picture\n// pixel : Pixel\n// pip : Boolean, true if pixel was in sub-picture zone\nvec2 Pip(in vec2 pixel,out bool pip)\n{\n  // Pixel coordinates\n  vec2 p=(-iResolution.xy+2.*pixel)/iResolution.y;\n  if(pip==true)\n  {\n    const float fraction=1./4.;\n    // Recompute pixel coordinates in sub-picture\n    if((pixel.x<iResolution.x*fraction)&&(pixel.y<iResolution.y*fraction))\n    {\n      p=(-iResolution.xy*fraction+2.*pixel)/(iResolution.y*fraction);\n      pip=true;\n    }\n    else\n    {\n      pip=false;\n    }\n  }\n  return p;\n}\n\n// Image\nvoid mainImage(out vec4 color,in vec2 pxy)\n{\n  // Picture in picture on\n  bool pip=true;\n  \n  // Pixel\n  vec2 pixel=Pip(pxy,pip);\n  \n  // Mouse\n  vec2 m=iMouse.xy/iResolution.xy;\n  \n  // Camera\n  vec3 ro,rd;\n  Ray(m,pixel,ro,rd);\n  \n  // Trace ray\n  \n  // Hit and number of steps\n  bool hit;\n  int s;\n  \n  float t=SphereTrace(ro,rd,100.,hit,s);\n  \n  // Position\n  vec3 pt=ro+t*rd;\n  \n  // Shade background\n  vec3 rgb=background(rd);\n    \n  if(hit)\n  {\n    // Compute normal\n    vec3 obj_color;\n    vec3 n=ObjectNormal(pt, obj_color);\n    \n    // Shade object with light\n    rgb=Shade(pt,n) * obj_color;\n  }\n  \n  // Uncomment this line to shade image with false colors representing the number of steps\n  if(pip==true)\n  {\n    rgb=ShadeSteps(s);\n  }\n  \n  color=vec4(rgb,1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7syXRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[12, 69, 93, 93, 133], [135, 155, 195, 195, 430], [432, 478, 502, 502, 583], [585, 676, 731, 731, 1016], [1228, 1242, 1272, 1272, 1360], [1362, 1362, 1392, 1392, 1481], [1483, 1483, 1513, 1513, 1602], [1604, 1604, 1637, 1637, 1669], [1671, 1671, 1704, 1704, 1736], [1738, 1738, 1771, 1771, 1803], [1805, 1868, 1900, 1900, 1966], [1983, 2091, 2135, 2135, 2172], [2188, 2241, 2273, 2273, 2334], [2336, 2384, 2423, 2423, 2550], [2553, 2553, 2592, 2592, 2721], [2723, 2723, 2755, 2755, 2882], [2885, 2885, 2913, 2913, 2999], [3082, 3158, 3212, 3212, 3251], [3253, 3253, 3308, 3308, 3412], [3414, 3414, 3465, 3465, 3552], [3554, 3554, 3616, 3616, 3757], [3759, 3759, 3800, 3800, 3900], [3903, 3903, 3979, 3979, 4538], [4540, 4540, 4593, 4593, 4631], [4633, 4679, 4700, 4700, 13797], [13799, 13839, 13888, 13888, 14123], [14125, 14230, 14288, 14288, 14674], [14676, 14781, 14845, 14845, 15249], [15251, 15324, 15369, 15369, 15647], [15649, 15669, 15695, 15695, 15759], [15761, 15761, 15789, 15806, 16104], [16106, 16106, 16146, 16146, 16534], [16536, 16597, 16624, 16624, 16745], [16747, 16779, 16803, 16803, 16897], [16899, 16994, 17032, 17055, 17437], [17439, 17448, 17492, 17519, 18222]]}
{"id": "7syXz3", "name": "After Effects: Tint", "author": "barton", "description": "Possible implementation of Tint effect from After Effects", "tags": ["effect", "effects", "tint", "aftereffects", "after"], "likes": 2, "viewed": 53, "published": "Public", "date": "1635003709", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \n// Somewhere I made full replication of some plugins/effects from After Effects.\n// All plugins are written in C++ and use Metal for rendering.\n// So, I would like to demonstrate some of them.\n//\n// This shader shows possible implementation of Tint effect from After Effects.\n//\n// Effect Inputs:\n// - Map Black To: Color\n// - Map White To: Color\n// - Amount to Tint: 0...100\n// \n// The link about effect. The video is not mine, it's just for effect demonstration.\n// https://www.youtube.com/watch?v=f7EOumHGyMs\n// \n\nconst float amountMin = 0.0;\nconst float amountMax = 100.0;\n\nconst vec3 luminanceWeighting = vec3(0.2125, 0.7154, 0.0721);\n\nvec3 tintAdjust(vec3 color, vec3 mapBlackTo, vec3 mapWhiteTo, float amount) {\n    float luminance = dot(color, luminanceWeighting);\n    return mix(color, mix(mapBlackTo, mapWhiteTo, luminance), amount);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 c = texture(iChannel0, uv);\n\n    float value = abs(sin(iTime * 0.5));\n    float amount = mix(amountMin, amountMax, value);\n    float amountNormal = amount/(amountMax - amountMin);\n    float targetAmount = mix(0.0, 1.0, amountNormal);\n    \n    vec4 mapBlackTo = vec4(1, 0, 0, 1);\n    vec4 mapWhiteTo = vec4(0, 0, 1, 1);\n    \n    c.rgb = tintAdjust(c.rgb, mapBlackTo.rgb, mapWhiteTo.rgb, targetAmount);\n    \n    fragColor = c;\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7syXz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 645, 722, 722, 849], [851, 851, 908, 908, 1384]]}
{"id": "7syXzd", "name": "45/49", "author": "tono", "description": "45/49", "tags": ["49"], "likes": 4, "viewed": 48, "published": "Public", "date": "1635120576", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat pi = acos(-1.);\nvec2 pmod(vec2 p, float r){float a = atan(p.x,p.y)+pi/r;float n=(pi*2.)/r;return p*rot(-(floor(a/n)*n));}\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\nfloat bo(vec3 p,vec3 s){p=abs(p)-s;return max(p.x,max(p.y,p.z));}\nfloat rand(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise(vec3 p)\n{\n    vec3 fp = floor(p);\n\tvec3 fs = fract(p);\n    vec3 sf = vec3(1.,0.,0.);\n    \n    float a = rand(fp);\n    float b = rand(fp + sf);\n    float c = rand(fp + sf.yxz);\n    float d = rand(fp + sf.xxz);\n    float e = rand(fp + sf.yyx);\n    float f = rand(fp + sf.xyx);\n    float g = rand(fp + sf.yxx);\n    float h = rand(fp + sf.xxx);\n    \n    vec3 u = smoothstep(0.,1.,fs);\n  //  u = pow(fs,vec3(3.));\n    \n    return mix(mix(\n        \t\tmix(a,b,u.x),\n        \t\tmix(c,d,u.x),u.y),\n               mix(\n                mix(e,f,u.x),\n                mix(g,h,u.x),u.y),u.z\n            );\n}\nvec2 pumpkin(vec3 p,float y , float st)\n{\n    float o = 10.;\n    float id = 0.;\n    \n    p.y *= y;\n    float t = (iTime+ st)/10.;\n    t = floor(t) + pow(fract(t),3.);\n    p.y += abs(sin(t * pi * 2.)) * 10.;\n    vec3 pp = p;\n    \n    p.xz = pmod(p.xz,13.);\n    p.z -= .5;\n    float yy = (sin(p.y+iTime*5.)*.5+.5)/1.;\n    \n    yy = sin(t * pi * 2.);\n    o = length(vec2(length(p.yz)-.3,p.x))-.5 + yy*.1;\n    pp.y *= mix(1., yy*1.5,.1);\n    float cyl = sdRoundedCylinder(pp+vec3(0.,.8,0.),0.05,0.02,0.3);\n    \n    if(o > cyl)\n    {\n        o = cyl;\n        id = 1.;\n    }\n    \n    \n    return vec2(o,id);\n}\nvec2 map(vec3 p)\n{\n    float o = 10.;\n    float id = 0.;\n    vec3 pp = p;\n    \n    vec2 pump = pumpkin(pp,1.,-3.);\n    //pp.xz *= (sin(p.y)*.5+.5 + .8);\n    pp.x += 3.;\n    pp.z -= 2.;\n    pp.y += .3;\n    // pp.x -= 2.3;\n    // pp.z -= .1;\n    // pp.y += 0.3;\n    //pp.xy *= rot(0.8);\n    //pp.yz *= rot(0.4);\n    vec2 pump2 = pumpkin(pp,.7,3.);\n    if(pump.x > pump2.x)\n    {\n        pump = pump2;\n    }\n    o = pump.x;\n    id = pump.y;\n    p.y += sin(p.x * .5 + p.z * .3 + .3)/3.;\n    float b = bo(p-vec3(0.,1.45*2.,0.),vec3(13.,2.,13.));\n    \n    if(o > b)\n    {\n        o = b;\n\t\tif(o < .1)\n        {\n            o -= noise(p*10.)/30.;\n            o -= noise(p * 30.)/70.;\n        }\n        id = 2.;\n    }\n    else if(o < 0.03)\n    {\n        o -= noise(p*100.)/100.;\n    }\n    return vec2(o,id);\n}\n\nvec2 march(vec3 cp , vec3 rd)\n{\n    float depth = 0.;\n    for(int i = 0 ; i< 99 ; i++)\n    {\n        vec3 rp = cp + rd * depth;\n        vec2 d = map(rp);\n        if(abs(d.x) < 0.001)\n        {\n            return vec2(depth,d.y);\n        }\n        depth += d.x;\n    }\n    return vec2(-depth , 0.);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tvec3 cp = vec3(-3.,-2.,-12.);\n    cp.xz *= rot(iTime/12.);\n    cp.y += sin(iTime/6.);\n    vec3 target = vec3(0.,-1.3,0.);\n    target.xz += sin(iTime/7.)/1.;\n    cp.x += step(sin(iTime/2.),0.3) * -10.;\n    cp.y += step(sin(iTime/2.),0.3) * -10.;\n    vec3 col = vec3(0.);\n    \n    vec3 cd = normalize(vec3(target - cp));\n    vec3 cs = normalize(cross(cd , vec3(0.,1.,0.)));\n    vec3 cu = normalize(cross(cd,cs));\n    \n    float fov = 2.5;\n    \n    vec3 rd = normalize(cd * fov + cs * p.x + cu * p.y);\n    \n    vec2 d = march(cp,rd);\n    if( d.x > 0.)\n    {\n       \tvec2 e = vec2(1.0, -1.0) * .05;\n        vec3 pos = cp + rd * d.x;\n        vec3 N = normalize(\n                  e.xyy * map(pos + e.xyy).x +\n                  e.yyx * map(pos + e.yyx).x +\n                  e.yxy * map(pos + e.yxy).x +\n                  e.xxx * map(pos + e.xxx).x);\n        vec3 sun = normalize(vec3(5.,4.,2.));\n       // sun.xz *= rot(iTime/2.);\n        float diff = max(0.,dot(-sun,N));\n        diff = mix(diff , 1.,.1);\n        float sp = max(0.,dot(rd,reflect(N,sun)));\n        sp = pow(sp,1.6) * .3;\n        vec3 mat = mix(vec3(1.,0.5,0.),vec3(0.7,1.,0.),d.y);\n        if(d.y > 1.)mat = mix(vec3(.5,.15,0.2),vec3(0.2,0.23,0.),noise(pos*100.*(1./(d.x*.3)) ));\n        float shadow = step(march(pos + N * 0.01,-sun).x,0.);\n        float rim = pow(clamp(1. - dot(N, -rd), 0., 1.), 4.) * (.2+step(d.y,1.)*.2);\n        float up = max(0.,dot(N,vec3(0.,-1.,0.)));\n        float down = max(0.,dot(N,vec3(0.,1.,0.)));\n        \n        col = sp * mat + diff * mat + up * vec3(0.1) + down * vec3(0.1,0.12,.1);\n        col += rim;\n        col = floor(col * 3.)/2.4;\n        if(d.y > 1.)\n        { \n            col =mix( vec3(0.),col,shadow);\n        }\n    }\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7syXzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 61], [84, 84, 111, 111, 189], [190, 190, 254, 254, 371], [372, 372, 396, 396, 437], [438, 438, 458, 458, 553], [555, 555, 576, 576, 1158], [1159, 1159, 1200, 1200, 1762], [1763, 1763, 1781, 1781, 2563], [2565, 2565, 2596, 2596, 2864], [2866, 2866, 2923, 2923, 4781]]}
{"id": "7tdGzr", "name": "Quantum Annihilation", "author": "SnoopethDuckDuck", "description": "really overusing tanh(cos) but its nice", "tags": ["e"], "likes": 5, "viewed": 131, "published": "Public API", "date": "1635639005", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sig(float x) {\n    return x / (1. + abs(x));\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n   // uv.y += 0.02 * cos(40. * uv.x + iTime);\n    \n     float a = atan(uv.y, uv.x);\n    \n    float k = 2. * tanh(4. * cos(0.5 * iTime));\n    float time = tanh(4. * cos(k * uv.x + iTime)) + iTime;\n        \n    uv.y += 0.025 * tanh(0.5 * cos(16. * uv.x + 2. * time));\n    \n    float rand = h21(vec2(floor(100. * uv.y)));\n    \n    float f = 0.5 * tanh(4. * cos(rand * 0.5 + time));\n   \n    vec2 p = vec2(f, 0.);\n    \n    float d = length(uv-p) - 0.1 + 0.08 * tanh(1.5 * cos(100. * pow(h21(uv),4.) + 3. * time));\n    float s = step(d, 0.1 + 0.025 * tanh(-4.*cos(0.4 * rand - 2.*time)));\n    \n   // vec3 col = vec3(s);\n     vec3 col = s * pal(f + 0.1 * iTime, vec3(0.5), vec3(0.5), vec3(1.5), vec3(0.,0.333,0.666));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tdGzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 52], [54, 54, 74, 74, 149], [151, 151, 219, 219, 262], [264, 264, 321, 371, 1208]]}
{"id": "7tt3Rn", "name": "A Galaxy is Born - Interactive", "author": "Taytweets", "description": "Mouse Y- Zoom in\nMouse X \n\n@FabriceNeyret2 helped simplify and mouse position code\n", "tags": ["spiral", "mod", "vogel", "vogelsprial"], "likes": 3, "viewed": 43, "published": "Public", "date": "1635627794", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M iMouse\n#define R iResolution\n#define T iTime\n#define pi 3.14\n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n\n{vec2\nm = ( iMouse.xy != vec2(0) ) ? M.xy/R.y*.5 : 5.5/vec2(100,100),\nu=5.*m.xy*(gl_FragCoord.rg-R.rg/2.)/R.y;\n\nfloat\nd=pow(2./length(u),2.2),\nt=.05*(T+5.*m.x),\ni=floor(d-atan(u.g,u.r)/pi*2.),\na=atan(u.g,u.r)+pi/2.*i,\nh=.002*a+5.2*t,\ns=fract(a*1.2*t)<.1?3.:0.,\nv=fract(a*t)>.1?3.:5.;\n\n\nfragColor=vec4(sin(pi*2.*(h-vec3(1.,.888,.666))),1.);}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tt3Rn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 73, 128, 128, 467]]}
{"id": "7ttGRr", "name": "dok @ Inércia Shader Royale 21", "author": "dok", "description": "Live coded on 30.10.21\nfor the Shader Royale @ Inércia Demoparty https://inercia.pt/\n(streamed on https://www.twitch.tv/inerciademoparty)\n", "tags": ["liveshader"], "likes": 7, "viewed": 96, "published": "Public", "date": "1635632078", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* shadertoy glue wrapping for bonzomatic */\n#define fGlobalTime iTime\n#define v2Resolution iResolution\n#define texFFT iChannel0\n#define texFFTSmoothed iChannel0\n#define gl_FragCoord fragCoord\n#define out_color fragColor\n\n/* bonzomatic source */\n#define PI 3.1416\n#define PI2 (2.0*PI)\n#define gain 0.1\n\nvec2 pol2(vec2 uv) {\n        return vec2(length(uv), fract(atan(uv.x,uv.y)/PI2));\n}\nmat2 rot2(float a) { return mat2(cos(a), sin(a), -sin(a), cos(a));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        vec2 uv = (gl_FragCoord.xy - 0.5 * v2Resolution.xy) / v2Resolution.y;\n        vec3 col = vec3(0);\n        float ef = fGlobalTime/2.0;\n        vec2 ev = pol2(uv + vec2(sin(ef), cos(ef)) * 0.1);\n        vec2 cv = pol2(uv);\n        vec2 lv = ev;\n        vec2 UV = uv;\n        uv.y += mix(0.95, 0.85, abs(sin(fGlobalTime))) * sign(uv.y);\n        vec2 pv = pol2(uv);\n\n        float ff = texture(texFFTSmoothed, vec2(0.1)).r * gain;\n        float ey = step(pv.x, 1.0);\n        float ni = ey;\n        float nl = mix(10.0, 15.0, ff);\n        float pr = mix(0.25, 0.05, 5.0*ff);\n        ni = ni * step(pr, ev.x) + (1.0-ni)*step(fract(nl*pv.x), mix(0.1, 0.05, ff));\n\n        float li = step(fract(25.0*lv.y + sin(50.0*(lv.x) - fGlobalTime)), mix(0.05, 0.1, ff));\n        float ci = step(fract(50.0*cv.y + sin(10.0*(cv.x) - fGlobalTime)), mix(0.05, 0.1, ff));\n        col.r = ni + ey * li + ci * li;\n        col.r += 2.0*texture(texFFT, vec2(pv.x)).r * gain;\n\n        float r = 0.0;\n        for (float i = 0.0; i < 1.0; i += 0.1) {\n                float rr = mix(0.5, 0.75, sin(fGlobalTime/4.0));\n                r += step(pol2(UV + vec2(rr,0.0)*rot2(fGlobalTime + i*PI2)).x, 0.05+ff);\n        }\n        if (sign(UV.y) > 0.0)\n                col.r += r;\n\n        r = 0.0;\n        for (float i = 0.0; i < 1.0; i += 0.1) {\n                float rr = mix(0.5, 0.75, sin(fGlobalTime/4.0));\n                r += step(pol2(UV + vec2(rr,0.0)*rot2(-fGlobalTime + i*PI2)).x, 0.05+ff);\n        }\n        if (sign(UV.y) < 0.0)\n                col.r += r;\n\n\n        float sp= fGlobalTime/2.0;\n        vec2 sv = UV+vec2(sin(sp),cos(sp))*0.04;\n        r = 0.0;\n        for (float i = 0.0; i < 10.0; i += 0.11) {\n                float rr = mix(0.2, 1.0, sin(i+fGlobalTime/4.0));\n                r += step(pol2(sv + vec2(rr,0.0)*rot2(-fGlobalTime + i*PI2)).x, 0.01+ff);\n        }\n        if (r > 0.0)\n                col.r = 1.0 - col.r;\n\n        col.rgb = col.rrr;\n\n        out_color = vec4(col, 1);\n}\n\n\n", "image_inputs": [{"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ttGRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[222, 303, 323, 323, 386], [387, 387, 407, 407, 454], [456, 456, 513, 513, 2497]]}
{"id": "fd3SDN", "name": "Cool raymarching effect", "author": "SnoopethDuckDuck", "description": "forked from artofcode's thngy", "tags": ["raymarching", "template", "artofcode"], "likes": 9, "viewed": 203, "published": "Public API", "date": "1633106503", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n\nfloat GetDist(vec3 p) {\n    float b = .5 + .5 * cos(0.3 * iTime);\n    float bd = sdBox(p, vec3(0.8)) - .2;\n    float sd = length(p) - 1.2;\n    return min(bd,sd);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 Bg(vec3 rd) {\n    float k = rd.y*.5 + .5;\n    \n    vec3 col = mix(vec3(.5,0.,0.),vec3(0.),k);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(3.5 * cos(iTime),2. * sin(0.5 * iTime), 3.5 * sin(iTime));\n   // ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    vec3 col = vec3(0);\n    col += Bg(rd);\n   \n    float d = RayMarch(ro, rd);\n    float depth = 2.; //1.5 + cos(iTime);\n    \n    // comment / uncomment me\n    d = RayMarch(ro + rd * (1. + depth) * d, -0.5 * depth * rd);\n    \n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(1.5*rd, n);\n        \n        float spec = pow(max(0., -r.y),32.);\n        spec = .5 + .5 * cos(0.00001*spec); // <-- absolute fudge but works alright\n       \n       float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n       float a = atan(p.x,p.z);\n       // dif = 16. * dif * dif * (1.-dif) * (1.-dif);\n       \n       col = 0.4 * vec3(dif) + 1.5 * cos(2. * a) * Bg(r);        \n       col *= (1. + spec);\n       \n       // comment / uncomment me\n       //col = vec3(dif);\n    }\n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd3SDN.jpg", "access": "shaders20k", "license": "mit", "functions": [[0, 1475, 1494, 1494, 1556], [1558, 1558, 1587, 1587, 1668], [1671, 1671, 1694, 1694, 1834], [1836, 1836, 1870, 1870, 2081], [2083, 2083, 2107, 2107, 2297], [2299, 2299, 2349, 2349, 2540], [2542, 2542, 2560, 2560, 2658], [2660, 2660, 2717, 2717, 3914]]}
{"id": "fd3Szl", "name": "Dots Loader", "author": "Krischan", "description": "A small and very nice loading animation with 8 glowing dots. Found at https://glslsandbox.com/e#69806.1 - Author unknown, customized a little.", "tags": ["glow", "dots", "spinning", "loader", "ps2"], "likes": 8, "viewed": 211, "published": "Public API", "date": "1633728755", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float DOTS = 8.0;\nconst vec3 COLOR = vec3(0.3, 0.6, 1.0);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    float f = 0.0;\n    \n    for(float i = 1.0; i <= DOTS; i++)\n    {\n        float s = sin(0.7 * iTime + (i * 0.5) * iTime) * 0.2;\n        float c = cos(0.2 * iTime + (i * 0.5) * iTime) * 0.2 ;\n        f += 0.01 / abs(length(p*0.5 + vec2(c, s)));\n    }\n    \n\tfragColor = vec4(COLOR*f, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd3Szl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 65, 120, 120, 502]]}
{"id": "fd3XD2", "name": "SDFPainting", "author": "Del", "description": "Playing around with blending and painting primitives smoothly - mouse to look around", "tags": ["sdf", "color", "blend", "paint", "smin", "smax"], "likes": 4, "viewed": 142, "published": "Public API", "date": "1633944958", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// a simple (smooth) union / subtraction / paint CSG test with some color blend tightness control for some voxel stuff - 10/10/2021\n\n#define AA 1\t// make this 2 if you are feeling cold...\n\nvec3 _basecol = vec3(0.0);\t// pure filth\n\n// prims\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// min/max polynomial\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat smax(float a, float b, float k)\n{\n    return smin(a, b, -k);\n}\n\nfloat sminCol( float a, float b, float k, vec3 col1,float coltightness)\n{\n    if (k<=0.0)\n    {\n        // no smooth...\n        if (a>b)\n        {\n            _basecol = col1;\n            return b;\n        }\n        return a;\n    }\n    // smoothed...\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n    float colblend = clamp( 0.5 + 0.5*(b-a)/(k*(coltightness)), 0.0, 1.0 );\n    _basecol = mix(col1,_basecol,colblend);\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smaxCol( float a, float b, float k, vec3 col1, float coltightness)\n{\n    if (k<=0.0)\n    {\n        if (a<=-b)\n        {\n            _basecol = col1;\n            return -b;\n        }\n        return a;\n    }\n    //return smin(a, -b, -k);// subtract\n    //return smin(a, b, -k); // intersection\n    b=-b;\n    k=-k;\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n    float colblend = clamp( 0.5 + 0.5*(b-a)/(k*(coltightness)), 0.0, 1.0 );\n    _basecol = mix(col1,_basecol,colblend);\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// same as smaxCol but without the distance blend (so, just paint a shape)\nvoid PaintSmooth(float a,float b, float k, vec3 col1,  float coltightness)\n{\n    if (k<=0.0)\n    {\n        // no smooth...\n        if (a<=-b)\n            _basecol = col1;\n        return;\n    }\n    // smoothed...\n    b=-b;\n    k=-k;\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n    float colblend = clamp( 0.5 + 0.5*(b-a)/(k*(coltightness)), 0.0, 1.0 );\n    _basecol = mix(col1,_basecol,colblend);\n}\n\n\n\n\nfloat map( in vec3 pos )\n{\n    float dist_cylinder = sdCylinder(pos+vec3(2.0,1.0,0.0),vec2(1.2,2.5));\n    float dist_sphere1 = sdSphere(pos+vec3(0.0,0.0,0.0),1.8);\n    float dist_sphere2 = sdSphere(pos+vec3(2.0,-1.0,0.0),1.8);\n    float dist_box = sdBox(pos+vec3(-.5,0.0,0.0),vec3(2.1,0.4,0.4));\n\n    // paint shapes\n    float dist_box2 = sdBox(pos+vec3(2.0,0.5,0.0),vec3(0.2,0.5,0.2));\n    float dist_cylinder2 = sdCylinder(pos+vec3(2.0,1.8,0.0),vec2(2.0,0.3));\n\n\n   float _basedist = 1000.0f;\n    _basecol = vec3(0.0);\n    vec3 redcol = vec3(1.0,0.1,0.1);\n    vec3 greencol = vec3(0.1,1.0,0.1);\n    vec3 bluecol = vec3(0.1,0.1,1.0);\n    vec3 yellowcol = vec3(1.0,1.0,0.1);\n    vec3 whitecol = vec3(1.0,1.0,1.0);\n     \n    float _coltightness = 0.5+sin(iTime)*0.5;//0=tight, 1=loose\n     \n    _basedist = sminCol(_basedist, dist_cylinder, 0.0, redcol, _coltightness);  // +red cylinder\n    PaintSmooth(_basedist, dist_cylinder2, 0.5, whitecol, _coltightness);// PAINT white cylinder (band)\n    _basedist = sminCol(_basedist, dist_sphere1, 0.5, greencol, _coltightness); // +green sphere\n    _basedist = smaxCol(_basedist, dist_box, 0.5, bluecol, _coltightness);      // -blue box\n    _basedist = smaxCol(_basedist, dist_sphere2, 0.5, yellowcol, _coltightness);// -yellow sphere\n    PaintSmooth(_basedist, dist_box2, 0.5,whitecol, _coltightness); // PAINT white cube (square)\n    return _basedist;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.01;\t//0.0005\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n        float an = radians(-120.0);\n        float yoff = 3.0f;\n        if (iMouse.z>0.5)\n        {\n         an = an+(iMouse.x/iResolution.x)*6.28;\n         yoff = yoff+(5.0-((iMouse.y/iResolution.y)*15.0));\n        }\n\n    vec3 ro = vec3( 7.0*cos(an), yoff, 7.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 20.0;\n        float t = 0.0;\n        for( int i=0; i<200; i++ )// overkill\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.001 || t>tmax ) break;\n            t += h;\n        }\n    \n        // shading/lighting\t\n        float v = 1.0-abs(p.y);\n        vec3 col = vec3(v*0.1);\n\n        if( t<tmax )\n        {\n            vec3 mycol = _basecol;\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            \n            vec3 dir = normalize(vec3(1.0,0.7,0.0));\n\t        vec3 ref = reflect(rd, nor);\n\t        float spe = max(dot(ref, dir), 0.0);\n\t        vec3 spec = vec3(1.0) * pow(spe, 64.);\n            float dif = clamp( dot(nor,dir), 0.05, 1.0 );\n            col =  mycol*dif;\n            col+=spec;\n        }\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd3XD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[231, 240, 276, 276, 375], [376, 376, 409, 409, 435], [436, 436, 467, 467, 554], [556, 578, 619, 619, 708], [709, 709, 748, 748, 777], [779, 779, 852, 852, 1238], [1240, 1240, 1314, 1314, 1766], [1768, 1843, 1919, 1919, 2245], [2250, 2250, 2276, 2276, 3649], [3651, 3651, 3683, 3683, 3929], [3935, 3935, 3992, 4017, 5919]]}
{"id": "fdcSDM", "name": "clouds that change color", "author": "dog9789", "description": "it's all clouds", "tags": ["isitnotcool"], "likes": 3, "viewed": 85, "published": "Public", "date": "1633244217", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n} \n\nfloat map(vec3 p)\n{\n\tfloat d = 2.0;\n\tfor (int i = 0; i < 16; i++) {\n\t\tfloat fi = float(i);\n\t\tfloat time = iTime * (fract(fi * 412.531 + 0.513) - 0.5) * 2.0;\n\t\td = opSmoothUnion(\n            sdSphere(p + sin(time + fi * vec3(52.5126, 64.62744, 632.25)) * vec3(2.0, 2.0, 0.8), mix(0.5, 1.0, fract(fi * 412.531 + 0.5124))),\n\t\t\td,\n\t\t\t0.4\n\t\t);\n\t}\n\treturn d;\n}\n\nvec3 calcNormal( in vec3 p )\n{\n    const float h = 1e-5; // or some other value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ) + \n                      k.yyx*map( p + k.yyx*h ) + \n                      k.yxy*map( p + k.yxy*h ) + \n                      k.xxx*map( p + k.xxx*h ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // screen size is 6m x 6m\n\tvec3 rayOri = vec3((uv - 0.5) * vec2(iResolution.x/iResolution.y, 1.0) * 6.0, 3.0);\n\tvec3 rayDir = vec3(0.0, 0.0, -1.0);\n\t\n\tfloat depth = 0.0;\n\tvec3 p;\n\t\n\tfor(int i = 0; i < 64; i++) {\n\t\tp = rayOri + rayDir * depth;\n\t\tfloat dist = map(p);\n        depth += dist;\n\t\tif (dist < 1e-6) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n    depth = min(6.0, depth);\n\tvec3 n = calcNormal(p);\n    float b = max(0.0, dot(n, vec3(0.577)));\n    vec3 col = (0.5 + 0.5 * cos((b + iTime * 3.0) + uv.xyx * 2.0 + vec3(0,2,4))) * (0.85 + b * 0.35);\n    col *= exp( -depth * 0.15 );\n\t\n    // maximum thickness is 2m in alpha channel\n    fragColor = vec4(col, 1.0 - (depth - 0.5) / 2.0);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"My Shader 0\",\n\t\"description\": \"Lorem ipsum dolor\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdcSDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 151], [153, 153, 188, 188, 212], [215, 215, 234, 234, 569], [571, 571, 601, 601, 883], [885, 885, 942, 942, 1660]]}
{"id": "fdcSR2", "name": "Not Malevich Square", "author": "Ludmila", "description": "My first toy.", "tags": ["square", "shape"], "likes": 0, "viewed": 28, "published": "Public", "date": "1633477802", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 rectangle(vec2 uv, vec2 pos, float width, float height, vec3 color)\n{\n\tfloat t = 0.;\n\tif ((uv.x > pos.x - width / 2.0) && (uv.x < pos.x + width / 2.)\n\t\t&&\n        (uv.y > pos.y - height / 2.) && (uv.y < pos.y + height / 2.)) \n      {\n\t\tt = 1.;\n\t  }\n\treturn vec4(color, t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;;\n    float kx=max(iResolution.x, iResolution.y)/iResolution.x;\n    float ky=max(iResolution.x, iResolution.y)/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col1 = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 col2=vec3(1.-col1.r,1.-col1.g, 1.-col1.b);\n   \n    vec4 rect = rectangle(uv, vec2(.5), .25*kx , .25*ky, col2 );\n    // Output to screen \n    fragColor = mix(vec4(col1, 1), rect, rect.a);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdcSR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 74, 74, 279], [281, 281, 338, 388, 841]]}
{"id": "fdcSzB", "name": "pixmap in register file", "author": "holydel", "description": "WARNING: long compilation time\nTest pixmap in local array ", "tags": ["pixmap"], "likes": 1, "viewed": 74, "published": "Public", "date": "1633412601", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//asci gnome: https://gamedev.ru/art/forum/?id=5592\n#define TARGET_FPS 60.0f\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n//pixmap in shader code. trash register file. 4096 registers max.\nint pixMapWidth = 68;\nint pixMapHeight = 56;\nuint pixData[3808] = uint[3808](4287730051u,4287861120u,4287598475u,4287598475u,4287532685u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598478u,4287598225u,4287532684u,4287663498u,4287663757u,4287598221u,4287532943u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287925125u,4287532686u,4287532946u,4287532690u,4287532687u,4287598478u,4287598479u,4287598479u,\n4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598478u,4287598225u,4287270542u,4289172869u,4289237890u,4287335565u,4287532686u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4288058256u,4287466894u,4287532686u,4287598478u,4287598478u,4287598478u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,\n4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287467406u,4287532687u,4287663502u,4288251509u,4289961098u,4288189842u,4287466894u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598736u,4287532686u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,\n4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287467406u,4287532686u,4287729039u,4288382577u,4288908667u,4288058257u,4287467151u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287532686u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,\n4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598478u,4287467153u,4287728518u,4288186486u,4288317304u,4287794312u,4287532943u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287664272u,4287401610u,4287070591u,\n4286808961u,4287071363u,4287400328u,4287532943u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287137927u,4286479742u,4286809476u,4286678146u,4286479997u,4286479740u,4287401100u,4287598479u,4287598479u,4287598479u,4287598479u,\n4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287532686u,4287598479u,4287203465u,4285164650u,4285296237u,4285493873u,4285625459u,4285822581u,4287466893u,4287532686u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,\n4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287203464u,4285230444u,4285493616u,4285690995u,4285625202u,4286019704u,4287335307u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,\n4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287335050u,4285098858u,4285493616u,4285822581u,4286019960u,4285888117u,4287532686u,4287532686u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,\n4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287532686u,4287532686u,4287861651u,4285822581u,4285822581u,4285822838u,4285822837u,4286283132u,4287730065u,4287532686u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,\n4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287532686u,4288256409u,4283190348u,4286348669u,4285953654u,4286151033u,4286282619u,4287664272u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,\n4287598479u,4287598479u,4287598479u,4287532686u,4287466893u,4288453788u,4282532418u,4285887604u,4285427310u,4285822068u,4285822068u,4287532686u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287664272u,4283453520u,4285558896u,\n4285427310u,4285624689u,4285624689u,4287532686u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287730065u,4286151033u,4283650899u,4285624689u,4285624689u,4285361517u,4285493103u,4287532686u,4287532686u,4287598479u,4287598479u,4287598479u,\n4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287532686u,4287795858u,4285361517u,4284637794u,4285822068u,4285690482u,4285624689u,4285493103u,4287401100u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,\n4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287532686u,4287993237u,4284374622u,4285822068u,4285229931u,4285493103u,4285624689u,4285361517u,4287006342u,4287664272u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,\n4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287532943u,4287532686u,4287598223u,4287598478u,4287598478u,4287598478u,4287598478u,4287598478u,4287598478u,4287598478u,4287598479u,4287598479u,4287598479u,4287532686u,4288124823u,4283190348u,4285493103u,4285295724u,4285624689u,4285624689u,4285624689u,4287203721u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,\n4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287532942u,4287598480u,4287862168u,4287796114u,4287664019u,4287598485u,4287598224u,4287664018u,4287533459u,4287532688u,4287532430u,4287532942u,4287598479u,4287598479u,4287532686u,4288059030u,4283585106u,4285822068u,4285558896u,4285690482u,4285624689u,4285558896u,4286479998u,4287730065u,4287532686u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598480u,4287270277u,4285358673u,\n4285952873u,4286742648u,4287531912u,4287992722u,4287137412u,4287201662u,4287729810u,4287467407u,4287598478u,4287598479u,4287598479u,4287598479u,4287861651u,4283716692u,4285953654u,4285822068u,4285887861u,4285756275u,4286085240u,4286677376u,4287664272u,4287532686u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287664530u,4286677370u,4283779624u,4283254058u,4283121706u,4283187504u,4283383608u,4282331176u,4283186745u,4288059289u,4287532688u,\n4287598478u,4287598479u,4287598479u,4287598479u,4286940549u,4286019447u,4285953654u,4285953654u,4285953654u,4286019447u,4286282618u,4286940809u,4287467150u,4287598223u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287532686u,4287796116u,4286018155u,4283778358u,4283647803u,4283449399u,4283318071u,4282923313u,4283186479u,4282594082u,4286676602u,4287730323u,4287598478u,4287532686u,4287598479u,4287795858u,4286216826u,4285690482u,4285953654u,4285953654u,\n4285756275u,4285624689u,4286480253u,4285690744u,4286940805u,4287664016u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287532686u,4287532686u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287532686u,4287532686u,4287598479u,4287335308u,4287532686u,4287598480u,4287532687u,4287401613u,4287466894u,4288125083u,4285754200u,4285291334u,4284699967u,4284568128u,4282726188u,4282726706u,4283582520u,4284765236u,4283845697u,4288125082u,4287532686u,4287532685u,4286940549u,4286743170u,4286216826u,4285624689u,4285690482u,4285493103u,4285756275u,4285887861u,4286479997u,4284243556u,4286019704u,4287795858u,4287532686u,4287598479u,\n4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287335307u,4287203721u,4287532686u,4287532686u,4287401100u,4287466893u,4287532686u,4287598479u,4287598479u,4287532686u,4287598479u,4287795858u,4287664272u,4287269514u,4286479999u,4286677893u,4286612100u,4286348671u,4285822327u,4285295470u,4283716949u,4284504653u,4284439373u,4285821803u,4284440161u,4282598994u,4282731085u,4282994520u,4284304954u,4283910193u,4286084984u,4285953913u,4285953656u,4285953654u,4286216826u,4286019447u,4286545791u,4285558896u,4285558896u,4285887861u,4286085240u,4286413693u,4284573292u,4284045658u,4287993237u,4287532686u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,\n4287335306u,4286282620u,4288585374u,4289111460u,4288980132u,4288782753u,4287861650u,4287730064u,4287730065u,4287598735u,4287401099u,4287927444u,4285690482u,4285558896u,4285624689u,4285229931u,4285032811u,4285230190u,4285427569u,4286940808u,4287335311u,4282532416u,4284637792u,4286875531u,4286612105u,4283388249u,4282797142u,4283322711u,4285099640u,4283713854u,4284896310u,4285360992u,4286414462u,4285953658u,4286150776u,4285953654u,4285690482u,4285756275u,4285822068u,4285493104u,4286151033u,4286348412u,4286479998u,4284309864u,4284176987u,4285624689u,4287861907u,4287532686u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287203980u,4286809222u,4288980392u,4288717476u,4288717476u,4288783269u,4287927704u,4285032811u,\n4283651158u,4283914330u,4286809223u,4284111193u,4282269245u,4284111452u,4283914331u,4283651158u,4284045916u,4284572260u,4284506467u,4285953914u,4286940291u,4282137660u,4284703846u,4287006600u,4285230447u,4282533196u,4282993239u,4283519838u,4286019706u,4284636758u,4282790952u,4284698679u,4286281844u,4286347644u,4286020735u,4286611331u,4286481541u,4285954434u,4286216826u,4285690739u,4286939267u,4286216569u,4286348412u,4284178535u,4283324773u,4283322455u,4288123798u,4287532686u,4287532686u,4287598222u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287006601u,4286743429u,4288914598u,4288717219u,4288783012u,4288519840u,4287861910u,4284638053u,4284638053u,4284703846u,4286546051u,4283256141u,4283190091u,4285756533u,4284703847u,4284243295u,\n4284638053u,4285098604u,4285164397u,4286348671u,4286940548u,4282664004u,4285361519u,4286875015u,4284440932u,4282730575u,4282862166u,4283717217u,4285822327u,4286808194u,4283187769u,4283316777u,4285161283u,4286743176u,4286413166u,4283710754u,4284238126u,4284369459u,4284109120u,4284701514u,4286082138u,4286873981u,4286675312u,4283709723u,4283518020u,4282138434u,4288323234u,4288126371u,4287862684u,4287730581u,4287664531u,4287598480u,4287598222u,4287532943u,4287598479u,4287598479u,4287006601u,4286743429u,4288914598u,4288717219u,4288783012u,4288585633u,4287598738u,4284703846u,4285295983u,4285361776u,4285953913u,4283058763u,4283256141u,4285888119u,4284506468u,4284309088u,4284703846u,4284901225u,4285098604u,4286875015u,4286282619u,4282400832u,4285822582u,4286743428u,\n4283848286u,4282862162u,4282796627u,4284112227u,4286085241u,4286217339u,4285886065u,4282527788u,4283120940u,4286412649u,4286479988u,4282390784u,4283181056u,4283508992u,4283771904u,4284166912u,4284626688u,4284364288u,4284626953u,4284625922u,4284101120u,4283707136u,4283378944u,4283839247u,4285026611u,4285884505u,4286478448u,4287730323u,4287533714u,4287597964u,4287467406u,4287598479u,4287006601u,4286743429u,4288980391u,4288848805u,4288783012u,4288585633u,4287401359u,4284638053u,4285098604u,4285032811u,4286217085u,4282927175u,4283650899u,4285164140u,4284835432u,4284703846u,4284703846u,4284901225u,4285098603u,4287270030u,4285295724u,4282927176u,4286151289u,4286611843u,4283585627u,4282796369u,4282927700u,4284441191u,4286216829u,4286413947u,4286611843u,4284568918u,\n4283055143u,4283647026u,4286939766u,4282588928u,4283708425u,4284036360u,4284167432u,4284233477u,4284561925u,4284430085u,4284495111u,4284889865u,4284430599u,4284299014u,4284627464u,4286866483u,4287917625u,4288246592u,4286075426u,4284103441u,4287662729u,4287665302u,4287598222u,4287598478u,4287006600u,4287203721u,4289178027u,4288848805u,4288783012u,4288585633u,4287269773u,4284967018u,4285624948u,4285624948u,4286480258u,4282992969u,4283848278u,4285164140u,4284769639u,4284835432u,4284835432u,4285032811u,4284506467u,4288190875u,4284505951u,4283190348u,4285756532u,4285229935u,4282137924u,4282270279u,4282401866u,4285033073u,4286282363u,4286216569u,4286020217u,4287071367u,4284240193u,4283909166u,4285621330u,4282655488u,4283708165u,4283904774u,4284232712u,4284233223u,\n4284495879u,4284429833u,4284429833u,4284561161u,4284232710u,4284100864u,4286864939u,4289565026u,4291805600u,4287063874u,4289234520u,4285613847u,4283446025u,4287466890u,4287598480u,4287467406u,4286545791u,4284243036u,4287927703u,4289309357u,4289243563u,4289177770u,4287269773u,4284177502u,4284111709u,4283914330u,4285756534u,4281677109u,4282795590u,4285624948u,4283256400u,4283322193u,4283585365u,4283782744u,4283124814u,4288848806u,4282861383u,4283321934u,4285756534u,4285361780u,4282269766u,4282270533u,4282533449u,4285032818u,4286545790u,4286019446u,4286084983u,4286743429u,4285492070u,4283318314u,4284171567u,4283116032u,4283905288u,4284101385u,4284364041u,4284495628u,4284693004u,4284495625u,4284364296u,4284430089u,4284232452u,4283838209u,4286800178u,4289760861u,\n4291152557u,4286539336u,4289695328u,4286142759u,4283574784u,4284564771u,4288255907u,4287401871u,4287335307u,4285690482u,4283585109u,4285098603u,4285756533u,4286348670u,4286611842u,4284637796u,4285164140u,4284111709u,4285690741u,4281808695u,4283914070u,4286348670u,4284506467u,4284769639u,4284835432u,4284769639u,4284243295u,4288914599u,4282861126u,4284045657u,4285756532u,4285361779u,4283651162u,4284770410u,4282599243u,4284769902u,4286479999u,4286348412u,4286151033u,4286742656u,4286546045u,4283582523u,4283908655u,4283050240u,4283708166u,4284036104u,4284363784u,4284364297u,4284495369u,4284561673u,4284430342u,4284561670u,4284167172u,4284233480u,4287589432u,4289826652u,4291211663u,4286735945u,4290090343u,4286075682u,4283839750u,4283246592u,4287532416u,4287532691u,\n4287598479u,4287795858u,4288190616u,4286743170u,4286085240u,4284835173u,4284440416u,4283848280u,4283914073u,4284177502u,4285624948u,4284703332u,4282729542u,4283585365u,4284440674u,4284243295u,4284045916u,4284572260u,4284967018u,4284506468u,4282729797u,4284111449u,4285756533u,4285230190u,4284901225u,4285888121u,4282927184u,4284375655u,4286677636u,4286085240u,4285624689u,4286348412u,4286283131u,4285031519u,4282526244u,4282984449u,4283576584u,4283642629u,4284035589u,4284101639u,4284299015u,4284890119u,4284626951u,4284823817u,4283050245u,4281539840u,4285813288u,4290222693u,4291207529u,4290484840u,4290682473u,4286931764u,4283707909u,4283443456u,4287334013u,4287664018u,4287532686u,4287664272u,4287598479u,4287532686u,4287598478u,4287861649u,4288124824u,4288585120u,\n4287203466u,4285559412u,4285953913u,4287203468u,4285822070u,4284374881u,4287269773u,4285690741u,4285361776u,4285559155u,4285690741u,4285296240u,4282466625u,4283979863u,4285624948u,4285295983u,4284177500u,4285229935u,4282598476u,4284901743u,4286282622u,4285953653u,4285690482u,4286216826u,4285953910u,4286414455u,4283252018u,4283049728u,4283510790u,4283511044u,4283708678u,4283708678u,4284233478u,4284890120u,4284824584u,4285021705u,4283971079u,4283773700u,4287063859u,4288773974u,4288052044u,4288511828u,4290287461u,4286865458u,4283510530u,4283377408u,4287333757u,4287664019u,4287269514u,4286413948u,4286809222u,4288190876u,4288125082u,4288190875u,4286809222u,4284703846u,4285493362u,4284374881u,4285690742u,4283058762u,4283190091u,4286085498u,4285164397u,4285427569u,\n4285493362u,4285822327u,4285690741u,4288914599u,4282137660u,4284440415u,4285691251u,4285361776u,4282467144u,4282401608u,4282533450u,4285164911u,4286019447u,4285756275u,4285690482u,4285624690u,4285953135u,4286150510u,4285161559u,4282786304u,4283511043u,4283772680u,4283773700u,4283905031u,4284167685u,4284824327u,4284889862u,4284890123u,4284167173u,4283772418u,4286274096u,4288905297u,4290359709u,4285488192u,4288971854u,4284825872u,4283378435u,4283049472u,4287597191u,4287467663u,4286677377u,4287335306u,4289177770u,4288914598u,4288914598u,4289046184u,4286480257u,4284177502u,4284177502u,4283585365u,4285098604u,4281808695u,4282598211u,4286019449u,4282466884u,4282993228u,4283585365u,4283848537u,4283848537u,4288848806u,4282006073u,4283519313u,4286019703u,4285493362u,\n4282401351u,4282335815u,4282598987u,4285428084u,4286348155u,4285822068u,4285887861u,4285756277u,4286084721u,4286216562u,4286346608u,4282129408u,4283051527u,4283708678u,4283905284u,4283839752u,4284233478u,4284693255u,4284823813u,4284692744u,4284167430u,4283970053u,4285944873u,4288381010u,4290427555u,4284830522u,4289826910u,4284497426u,4283507968u,4284170528u,4288060064u,4287794317u,4286546050u,4287467152u,4288980392u,4288848805u,4288783012u,4288454047u,4286677636u,4284309088u,4284638053u,4284374881u,4285624949u,4282532418u,4283124554u,4285427568u,4284045916u,4284177502u,4284506467u,4285164397u,4284769639u,4287861910u,4284900966u,4282137660u,4284506466u,4284835432u,4282335301u,4282072643u,4282204229u,4282927952u,4285229933u,4285098345u,4285032552u,4285098344u,\n4285756015u,4285953651u,4286084720u,4281538048u,4282196231u,4282394115u,4283576071u,4284496137u,4284824074u,4284889864u,4284956167u,4284956168u,4284496131u,4283642625u,4285681956u,4288775001u,4289501044u,4286737994u,4288511572u,4285417238u,4284433182u,4287994264u,4287532689u,4287532429u,4286546050u,4287401359u,4288980391u,4288848805u,4288848805u,4288454047u,4286875015u,4284967018u,4285427569u,4285164397u,4286414464u,4282729796u,4283453520u,4285032811u,4284374881u,4284177502u,4284243295u,4284769639u,4284835432u,4287401359u,4285558895u,4281874488u,4284309087u,4284835432u,4282664521u,4282006850u,4282072900u,4282730318u,4284834920u,4284835172u,4284835173u,4284835172u,4285098343u,4285756016u,4285558375u,4281274368u,4281867008u,4282064640u,4282131461u,4282655232u,\n4283903235u,4284430087u,4284364548u,4284430343u,4284167429u,4283313924u,4283247872u,4284957718u,4285813799u,4286075170u,4285022228u,4284958759u,4287205779u,4287729808u,4287467407u,4287598479u,4286546050u,4287532945u,4288980391u,4288848805u,4288783012u,4288454047u,4287138187u,4284440674u,4284901225u,4284638053u,4285756535u,4282269246u,4282992969u,4285032554u,4283980123u,4283914330u,4284045916u,4284177502u,4284243295u,4287072651u,4286216825u,4281545523u,4284177501u,4284835432u,4282927693u,4281941057u,4282138436u,4282664525u,4284834919u,4284572001u,4284572001u,4284703586u,4284835172u,4285427309u,4285427050u,4284107580u,4285293913u,4285225537u,4283778366u,4283975215u,4284237605u,4283512079u,4282854403u,4283378694u,4283707652u,4284101637u,4283509504u,4283508736u,\n4283644437u,4285554763u,4287334787u,4287666077u,4287795089u,4287532685u,4287598478u,4287598479u,4286480257u,4287993497u,4288914598u,4288848805u,4288848805u,4288388254u,4287401359u,4284572260u,4285032811u,4284967018u,4285690741u,4282335039u,4283321677u,4285361776u,4283980123u,4283980123u,4284045916u,4284309088u,4284177502u,4286546307u,4287006342u,4281808694u,4283979866u,4284572260u,4283125072u,4281875775u,4282073155u,4282532938u,4284440161u,4284506207u,4284506208u,4284572001u,4284835173u,4284966759u,4285164396u,4285625464u,4286085249u,4286082378u,4285223735u,4283253567u,4288124565u,4287926416u,4287201142u,4283842581u,4283448356u,4282857506u,4285225799u,4287005057u,4288125084u,4287862427u,4287598481u,4287532686u,4287532942u,4287598479u,4287598479u,4287598479u,\n4286545793u,4288322460u,4289111721u,4288783013u,4288783012u,4288520097u,4287532945u,4284111711u,4284308832u,4283716951u,4287006602u,4281874488u,4282927175u,4283848280u,4283585365u,4283519572u,4283519572u,4283585365u,4282927435u,4286019707u,4286545791u,4281150765u,4283585365u,4284309088u,4283454036u,4281678141u,4282072898u,4282336073u,4284177246u,4284703587u,4284440415u,4284572001u,4284572001u,4284572001u,4284900966u,4285032294u,4284836205u,4285229671u,4286803780u,4282790949u,4284503378u,4287072907u,4286941062u,4284703597u,4283521637u,4282795599u,4287927960u,4287664529u,4287467150u,4287532685u,4287598478u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4285558896u,4284243035u,4287927443u,4289243303u,4289045924u,4289177511u,4288190617u,4284440418u,\n4284506210u,4284835685u,4287138697u,4282795590u,4282071866u,4284177501u,4283519572u,4283782744u,4283914330u,4284111452u,4283716951u,4286546051u,4286808963u,4281940281u,4283059021u,4284045917u,4284177501u,4281940541u,4282005825u,4282072899u,4283454810u,4284637537u,4284637794u,4284835173u,4284637794u,4284769380u,4284900966u,4285229931u,4285098345u,4285032814u,4285821277u,4287067461u,4283776816u,4285359972u,4287401610u,4284638828u,4284309348u,4283650899u,4287137924u,4287664272u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287532686u,4287466893u,4287006342u,4287466893u,4287466893u,4287532686u,4287532684u,4287993234u,4287598733u,4286941319u,4286743683u,4287335307u,4286414204u,4285690741u,4284045917u,4284309089u,\n4283782745u,4283585622u,4284243296u,4284243296u,4285493103u,4281216558u,4281940540u,4283585623u,4283782744u,4281808956u,4281216824u,4281414970u,4282599245u,4283124555u,4282006074u,4282992969u,4284111450u,4284506208u,4284506208u,4284900966u,4285164138u,4285756275u,4284573036u,4286674261u,4287132481u,4282527790u,4286478449u,4284902260u,4284243813u,4284308575u,4288124820u,4287532686u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287532686u,4287532686u,4287532686u,4287532687u,4287466895u,4287598479u,4287664272u,4287664272u,4287664272u,4287730065u,4287927444u,4287072135u,4285624432u,4285624433u,4285427310u,4285164138u,4284572001u,4283979864u,4285953654u,4286282362u,4286545790u,\n4286611583u,4285822068u,4284835172u,4284046427u,4283059276u,4286545791u,4288519581u,4286414205u,4285361517u,4284045657u,4283519313u,4283058762u,4283914071u,4284506208u,4284900709u,4284572521u,4286149981u,4285224507u,4283908918u,4284243808u,4283979866u,4286086009u,4287795348u,4287532686u,4287532942u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287532686u,4287664272u,4287730065u,4287795858u,4287795858u,4287795857u,4287795858u,4287927444u,4287795858u,4287730065u,4287730065u,4287730065u,4287795858u,4287992980u,4288058773u,4288058517u,4287730065u,4287532686u,4287730065u,\n4287861651u,4287927444u,4287861651u,4287795858u,4285164138u,4284308829u,4284900966u,4285229931u,4285230192u,4286215783u,4285356603u,4282988854u,4283648573u,4286741879u,4287598740u,4287532941u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287532942u,4287597967u,4287597967u,4287532943u,4287598479u,4287598479u,4287532686u,4287598479u,4287598479u,4287795858u,4286216826u,4284572001u,4285164138u,4285493103u,\n4285756017u,4286019706u,4286479740u,4285225290u,4286081112u,4288058774u,4287467407u,4287598478u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287532686u,4287664272u,4283782485u,4285164138u,4285295724u,4285756275u,4285953653u,4286020221u,4287268742u,4287664272u,4287532687u,4287598478u,4287598479u,\n4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287993237u,4282006074u,4285229931u,4285427310u,4285690482u,4285953654u,4285887091u,4286348414u,4287532432u,4287532686u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,\n4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287532686u,4288190616u,4283387727u,4284900966u,4285164138u,4285558896u,4285822068u,4285493103u,4286282618u,4287664528u,4287532686u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,\n4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287532686u,4288059030u,4283124555u,4284900966u,4285295724u,4285953654u,4285690482u,4285558896u,4286677377u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,\n4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287532686u,4287927444u,4284900966u,4285361517u,4285427310u,4285953654u,4285690482u,4285558896u,4286874756u,4287664272u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,\n4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287730065u,4285756275u,4282992969u,4285624689u,4285690482u,4285493103u,4285427310u,4287006342u,4287664272u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,\n4287598479u,4287598479u,4287598479u,4287532686u,4287664272u,4287006342u,4283256141u,4285558896u,4285558896u,4285624689u,4285427310u,4287203721u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287532686u,4288256409u,4282795590u,4285690482u,\n4285229931u,4285624689u,4285361517u,4287269514u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287532686u,4287466893u,4288453788u,4282400832u,4285756275u,4285427310u,4285756275u,4285822068u,4287401100u,4287598479u,4287598479u,4287598479u,4287598479u,\n4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287532686u,4287993237u,4284374622u,4286085240u,4285690482u,4285887861u,4286019447u,4287466893u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,\n4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287532686u,4287861651u,4286085496u,4285690482u,4285756275u,4285822068u,4286019447u,4287532686u,4287532686u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,\n4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287532686u,4287992981u,4284770149u,4285296237u,4285427823u,4285756788u,4285888373u,4287335307u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,\n4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287532686u,4287532686u,4287532686u,4284967272u,4285427823u,4285559409u,4285625459u,4285690738u,4287203721u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,\n4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287532686u,4287532686u,4285033065u,4285427823u,4285493616u,4285625202u,4285690739u,4287203721u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,\n4287598479u,4287598479u,4287598479u,4287532686u,4287598479u,4287006342u,4286283132u,4286217339u,4286283132u,4286085753u,4285953910u,4287072135u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287532686u,4287730321u,4287335823u,\n4287138955u,4287204493u,4287401616u,4287664272u,4287532686u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287467150u,4287598221u,4288058258u,4289371026u,4289305227u,4288912529u,4287335566u,4287598479u,4287598479u,4287598479u,4287598479u,\n4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287532942u,4287532686u,4287268999u,4290093452u,4291144853u,4288779663u,4287335566u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,\n4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287532686u,4287597965u,4287335566u,4288514678u,4291473045u,4289042833u,4287335822u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,\n4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287467407u,4287532942u,4287664273u,4287529073u,4288316529u,4287925641u,4287467407u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,\n4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287467409u,4287596161u,4287331441u,4287532945u,4287598478u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,\n4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287532943u,4287532943u,4287598737u,4287598220u,4287532943u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u,4287598479u);\n\n    int px = int(fragCoord.x + iTime*TARGET_FPS) % pixMapWidth;\n    int py = int(fragCoord.y) % pixMapHeight;\n    int index = px * pixMapHeight + py;\n    \n    uint pixColor = pixData[index];\n    \n    uint b = (pixColor >> 0u) & 0xFFu;\n    uint g = (pixColor >> 8u) & 0xFFu;\n    uint r = (pixColor >> 16u) & 0xFFu;\n    uint a = (pixColor >> 24u) & 0xFFu;\n    \n    // Output to screen\n    fragColor = vec4(vec4(r,g,b,a) / 255.0f );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdcSzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 78, 135, 202, 46469]]}
{"id": "fdcSzs", "name": "oct", "author": "Kornelius", "description": "my first shader.", "tags": ["octahedron"], "likes": 1, "viewed": 127, "published": "Public API", "date": "1633696292", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat plane(vec3 pos) {\nreturn pos.y;\n}\n\n\n\nfloat romb(vec3 p) \n{\n\nvec4 oct = vec4(2.5, .7, 0.0, 0.45);\n\n\n  p = abs(p-oct.xyz);\n     \n  \n  float m = p.x+p.y+p.z-oct.w*0.5554;\n  vec3 q;\n       if(-100.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( -3.5*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n     q.xyz -= clamp(sin(iTime)/2.0, 0.0, .19);\n\n  float k = clamp(0.5*(q.z-q.y+oct.w),0.0,oct.w); \n  return length(vec3(q.x,q.y-oct.w+k,q.z-k)*p*4.0);\n  }\n\n\nfloat octahedron(vec3 p)\n{\n\n\nvec4 s= vec4(2.5, 0.35*2.0 - sin(iTime*2.0)/55.0, 0.0, 0.25);\n\n  p = abs(p - s.xyz);\n  vec3 q = p-1.0*clamp(round(p/1.0),-1.0,.3);\n  return (q.x+q.y+q.z-s.w)*0.57735027;\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvec2 map(vec3 pos) {\n\n\nvec2 res = vec2(1e10, -1.0);\n\nvec2 romb = vec2(romb(pos), 1.0);\nvec2 plane = vec2(plane(pos), 2.0);\nvec2 octahedron= vec2(octahedron(pos), 3.0);\n\n\nif(romb.x < res.x) {res = romb;}\nif(octahedron.x < res.x) {res = octahedron;}\nif(plane.x < res.x) {res = plane;}\n\n\n\n\nreturn res; \n\n\n}\n\nvec2 raycast(vec3 ro, vec3 rd) {\nfloat epsilon = 0.01; \n\nvec2 res;\n\nfloat t = 0.0; \nfor(int i = 0; i < 180; ++i) \n{\nvec2 res = map(ro+rd*t);\nif(res.x < epsilon)\n{\nreturn vec2(t, res.y);\n}\nt += res.x;\n} \nreturn res;\n\n}\n\n\nvec3 calcNormal(vec3 p)\n{\n\n   const float h = 0.001; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ).x + \n                      k.yyx*map( p + k.yyx*h ).x + \n                      k.yxy*map( p + k.yxy*h ).x + \n                      k.xxx*map( p + k.xxx*h ).x );  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 light = normalize(vec3(0.2, -1.0, .2942342));\n    vec3 ro = vec3(6, 0.75, 0.0);\n    vec3 rd = vec3(-1, (fragCoord.y-iResolution.y/2.0)/iResolution.x, -fragCoord.x/iResolution.x+0.5);\n    rd = normalize(rd); \n    \n    vec2 res = raycast(ro, rd); \n    float t = res.x;\n    float m = res.y;\n    \n    vec3 col = vec3(0.0, 0, 0);\n    \n   if(m != -1.0){\n    vec3 pos = ro + rd * t; \n    if(m == 1.0) {//robm\n    \n    col = 0.5 + 2.5*cos(iTime+rd.xyx+vec3(6,0,4));\n    }\n    else if(m==2.0) {// plane\n    col = vec3(0., .0, .0);\n    \n    float ao = clamp(length(pos.xyz - vec3(1.5, 0.25, .04)), 0.0, 1.0); \n    col = col * 0.25 + ao * +.5 * col;\n    }\n    else if(m==3.0) {// octahedron\n    col = 0.5 + 0.5*cos(iTime+rd.xyx+vec3(3,0,4));\n    \n    }\n \n   \n    vec3 nor = calcNormal(pos);\n    float dif = clamp(dot(nor, -light), 0.0, 1.0); \n    \n    col = 0.55 * col +.75*dif * col;\n\n   \n    fragColor = vec4(col, 1.0);\n}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdcSzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 24, 24, 40], [44, 44, 65, 65, 478], [481, 481, 507, 507, 682], [698, 698, 718, 718, 1001], [1003, 1003, 1035, 1035, 1220], [1223, 1223, 1248, 1248, 1553], [1555, 1555, 1612, 1612, 2537]]}
{"id": "fdcXzf", "name": "Really Mandelbrot", "author": "Andrew3086", "description": "The Mandelbrot set. I like that it takes a few milliseconds to create a single frame.", "tags": ["mandelbrot"], "likes": 2, "viewed": 69, "published": "Public", "date": "1633596074", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pi = 3.1415926535;\n    float k = -3.0 + 20.0 * abs((asin(sin(iTime*0.055)))/pi*2.0);\n    //float k = -3.0 + 20.0 * abs(sin(iTime * 0.055));\n    float m = pow(2.0, k);\n    vec2 s = vec2(-0.792897, 0.160994);\n    float index = 0.0;\n    \n    vec2 xy = vec2((fragCoord.x - iResolution.x / 2.0) / iResolution.x / m + s.x, \n                   (fragCoord.y - iResolution.y / 2.0) / iResolution.x / m + s.y);\n    vec2 xy1 = xy;\n    vec2 tmp = vec2(0.0, 0.0);\n    \n    float count = 0.0;\n    \n    for (int i = 0; i < 256; i++) {\n        if (xy1.x*xy1.x+xy1.y*xy1.y>4.0) break;\n        tmp.x = xy.x + xy1.x*xy1.x - xy1.y*xy1.y;\n        tmp.y = xy.y + 2.0 * xy1.x * xy1.y;\n        xy1 = tmp;\n        \n        count++;\n    } \n    /*\n    if (count < 129.0) index = count / 128.0;\n    else if (count < 193.0) index = (count - 128.0) / 64.0;\n    else if (count < 225.0) index = (count - 192.0) / 32.0;\n    else if (count < 241.0) index = (count - 224.0) / 16.0;\n    else if (count < 249.0) index = (count - 240.0) / 8.0;\n    else if (count < 252.0) index = (count - 248.0) / 4.0;\n    else if (count < 256.0) index = (count - 252.0) / 2.0;\n    */\n\n    index = count / 256.0;\n    if (count == 256.0) index = 0.0;\n    \n    \n    fragColor = vec4(0.0, index, index, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdcXzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1321]]}
{"id": "fddSWj", "name": "Portal shape", "author": "therepo90", "description": "Test", "tags": ["practice"], "likes": 2, "viewed": 52, "published": "Public", "date": "1633974013", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float PI = 3.141592653589;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uvOrig = fragCoord/iResolution.xy;\n    vec2 uv = 2.0*(fragCoord-.5*iResolution.xy)/iResolution.xy;\n    \n\n    // polar\n    float d = length(uv); \n    //float alpha = atan(uv.y, uv.x) / (2.*PI) + 0.5; // normalize -pi,pi to 0, 1 for display\n    float alpha = atan(uv.y, uv.x); //-pi to pi\n    vec2 pc = vec2(d, alpha); // polar coords\n    \n    //fancy calc or irregular shape\n    float sinVal = sin(0.5+pc.y*3.+t*7.)*sin(pc.y*18.+t*2.)*0.02 - cos(0.3-pc.y*8.+t*5.)*0.015 + sin(pc.y*8.+t*8.)*0.03 * sin(-pc.y*2.+t*2.);\n    float thk = 0.03;\n    float res;\n    float r = 0.5;\n    float targetVal = r + sinVal;\n    \n    res = 1. - smoothstep(targetVal-thk, targetVal+thk, d);\n    \n    vec3 col;\n    \n    vec3 portalColor = texture(iChannel1,uvOrig).xyz;//vec3(1.0,1.0,1.0);\n    vec3 bgColor = vec3(0);\n    \n    col = mix(bgColor, portalColor, res);\n    vec3 edgeColor = vec3(1.,0,0);  // add edge tint\n    float edgeDist = smoothstep(targetVal-thk,targetVal+thk, d);\n    if(d < targetVal+thk){\n        col += edgeColor*edgeDist; // could be smoother\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fddSWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 86, 86, 1275]]}
{"id": "fddSzl", "name": "Mountains at dawn 2", "author": "guil", "description": "Mountains at dawn\nUsing Yonatan clouds/mountains combined field", "tags": ["clouds", "mountains"], "likes": 17, "viewed": 450, "published": "Public API", "date": "1633723649", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by S. Guillitte 2021\n \n\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\nvec3 l = vec3(1.);\n\n//Yonatan clouds/mountains combined field\nvec2 field(in vec3 p) {\n\t\n\tfloat s=2.,e,f,o;\n\t\n\tfor(e=f=p.y;s<8e2;s*=1.6)\n            p.xz*=rot(s),\n            e+=abs(dot(sin(p*s)/s,.4*l)),\n            f+=abs(dot(sin(p.xz*s*.5)/s,l.xz));\n\to = 1.+ (f>.001?e:-exp(-f*f));\n    return vec2(max(o,0.),min(f,max(e,.07)));\n}\n\n\nvec3 raycast( in vec3 ro, vec3 rd )\n{\n    float t = 2.5;\n    float dt = .035;\n    vec3 col= vec3(0.);\n    for( int i=0; i<100; i++ )\n\t{                \n        vec2 v = field(ro+t*rd);  \n        float c=v.x, f=v.y;\n        t+=dt*f;\n        dt *= 1.03;\n        col = .95*col+ .09*vec3(c*c*c, c*c, c);\t\n    }\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t = iTime;\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    \n\n    // camera\n\n    vec3 ro = vec3(2.);\n   \n    ro.yz*=rot(-1.5); \n    ro.y +=3.;\n    ro.xz*=rot(0.1*t);\n    \n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\n    ro.x -=t*.4;\n\n\t// raymarch \n    \n    vec3 col = raycast(ro,rd);\n    \n\t\n\t// shade\n    \n    col =  .5 *(log(1.+col));\n    col = clamp(col,0.,1.);\n    fragColor = vec4( col, 1.0 );\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fddSzl.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 122, 141, 141, 188], [210, 252, 275, 275, 521], [524, 524, 561, 561, 853], [856, 856, 913, 913, 1568]]}
{"id": "fddXRf", "name": "Supah Color Grading", "author": "supah", "description": "Color Palette", "tags": ["colorpalette"], "likes": 8, "viewed": 55, "published": "Public", "date": "1633635968", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float c = texture(iChannel0, uv).r;\n    \n    // https://www.color-hex.com/color-palette/114761\n    vec3 palette1[5] = vec3[5](\n        vec3(  84,  13, 110 ) / 255.,\n        vec3( 238,  66, 102 ) / 255.,\n        vec3( 255, 210,  63 ) / 255.,\n        vec3(  66, 191, 221 ) / 255.,\n        vec3( 187, 230, 228 ) / 255.\n    );\n    \n    // https://www.color-hex.com/color-palette/114398\n    vec3 palette2[5] = vec3[5](\n        vec3(  55,  90, 125) / 255.,\n        vec3( 190, 110, 130) / 255.,\n        vec3( 250, 175, 150) / 255.,\n        vec3( 190, 110, 130) / 255.,\n        vec3( 245, 115, 130) / 255.\n    );\n    \n    \n    vec3 col1 = palette1[0];\n    vec3 col2 = palette2[0];\n    float n = 1./4.;\n    \n    for (float i = 0.; i < 5.; i++) {\n        float cut = smoothstep(n * i, n * (i + 1.), c);\n        col1 = mix(col1, palette1[int(i)], cut);\n        col2 = mix(col2, palette2[int(i)], cut);\n    }\n    \n    float t = sin(iTime) * .5 + .5;\n    fragColor = vec4(mix(col1, col2, t),1.0);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fddXRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1087]]}
{"id": "fddXW7", "name": "inktober 02 - suit", "author": "pali6", "description": "♥♣l", "tags": ["sdf", "heart", "cards", "suits"], "likes": 5, "viewed": 141, "published": "Public API", "date": "1633361628", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Inktober 2021 - 02 - suit\n// by pali\n\n#define PI 3.141592\n#define A 0.4\n#define DEPTH 5\n#define XREP 8.\n\n#define ndot(x, y) normalize(dot(x, y))\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat triangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat rhombus( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p);\n    float h = clamp((-2.0*ndot(q,b)+ndot(b,b))/dot(b,b),-1.0,1.0);\n    float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( q.x*b.y + q.y*b.x - b.x*b.y );\n}\n\nfloat heart(vec2 pos)\n{\n    pos -= vec2(0.1, 0.);\n    pos.x /= 0.9;\n    pos.y *= 0.9;\n    float r = 1e10;\n    r = min(r, distance(pos, vec2(0.25, 0.6)) - 0.2);\n    r = opSmoothUnion(r, distance(pos, vec2(0.75, 0.6)) - 0.2, 0.05);\n    r = opSmoothUnion(r, triangleIsosceles(pos - vec2(0.5, 0.), vec2(0.4, 0.65)), 0.4);\n    return r;\n}\n\nfloat spade(vec2 pos)\n{\n    float r = heart(vec2(pos.x, 1.1 - pos.y / 0.9));\n    pos -= vec2(0.1, 0.);\n    pos.x /= 0.9;\n    pos.y *= 0.9;\n    r = opSmoothUnion(r, triangleIsosceles(pos + vec2(-0.5, -0.25), vec2(0.2, -0.25)), 0.02);\n    return r;\n}\n\nfloat diamond(vec2 pos)\n{\n    return rhombus(pos - vec2(0.5, 0.5), vec2(0.4, 0.5));\n}\n\nfloat club(vec2 pos)\n{\n    float r = 1e10;\n    r = opSmoothUnion(r, distance(pos, vec2(0.5, 0.75)) - 0.22, 0.1);\n    r = opSmoothUnion(r, distance(pos, vec2(0.21, 0.38)) - 0.22, 0.05);\n    r = opSmoothUnion(r, distance(pos, vec2(0.79, 0.38)) - 0.22, 0.05);\n    r = opSmoothUnion(r, distance(pos, vec2(0.5, 0.5)) - 0.15, 0.05);\n    r = opSmoothUnion(r, triangleIsosceles(pos + vec2(-0.5, -0.4), vec2(0.15, -0.4)), 0.05);\n    return r;\n}\n\nvec2 nHeart(vec2 pos)\n{\n    float base = heart(pos);\n    float d = 0.001;\n    return normalize(vec2(\n        heart(pos + vec2(d, 0)) - base,\n        heart(pos + vec2(0, d)) - base\n    ));\n}\n\nvec2 nSpade(vec2 pos)\n{\n    float base = spade(pos);\n    float d = 0.001;\n    return normalize(vec2(\n        spade(pos + vec2(d, 0)) - base,\n        spade(pos + vec2(0, d)) - base\n    ));\n}\n\nvec2 nDiamond(vec2 pos)\n{\n    float base = diamond(pos);\n    float d = 0.001;\n    return normalize(vec2(\n        diamond(pos + vec2(d, 0)) - base,\n        diamond(pos + vec2(0, d)) - base\n    ));\n}\n\nvec2 nClub(vec2 pos)\n{\n    float base = club(pos);\n    float d = 0.001;\n    return normalize(vec2(\n        club(pos + vec2(d, 0)) - base,\n        club(pos + vec2(0, d)) - base\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 pos = 2. * (uv - vec2(0.5));\n    pos.x /= iResolution.y / iResolution.x;\n    pos.x += 0.1;\n    pos /= 0.9;\n    pos = pos / 2. + vec2(0.5);\n    \n    float v = heart(pos);\n    vec2 norm = nHeart(pos);\n    bool col = false;\n    \n    for(int i = 0; i < DEPTH; i++)\n    {\n        if(v < 0.)\n        {\n            if(col)\n                fragColor = vec4(0, 0, 0, 1);\n            else\n                fragColor = vec4(1, 0, 0, 1);\n            return;\n        }\n        if(v > 2. * A)\n            break;\n        float y = v / A;\n        float ang = atan(norm.y, norm.x) + iTime * 0.1;\n        float bigx = XREP * ang / (2. * PI);\n        float x = fract(bigx);\n        x = x / 0.5 - 0.25;\n        int xPart = int(bigx);\n        if(xPart % 2 == 0)\n            col = !col;\n        int asd = (xPart / 2) % 2;\n        pos = vec2(x, y);\n        pos = vec2(0.5, 0.5) + (pos - vec2(0.5, 0.5));\n        if(col)\n        {\n            if(asd == 0)\n            {\n            v = spade(pos);\n            norm = nSpade(pos);\n            }\n            else\n            {\n                v = club(pos);\n                norm = nClub(pos);\n            }\n        }\n        else\n        {\n            if(asd == 0)\n            {\n                v = heart(pos);\n                norm = nHeart(pos);\n            }\n            else\n            {\n                v = diamond(pos);\n                norm = nDiamond(pos);\n            }\n        }\n    }\n    \n    fragColor = vec4(1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fddXW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 149, 201, 201, 300], [302, 302, 351, 351, 659], [661, 661, 701, 701, 896], [898, 898, 921, 921, 1231], [1233, 1233, 1256, 1256, 1481], [1483, 1483, 1508, 1508, 1568], [1570, 1570, 1592, 1592, 2005], [2007, 2007, 2030, 2030, 2196], [2198, 2198, 2221, 2221, 2387], [2389, 2389, 2414, 2414, 2586], [2588, 2588, 2610, 2610, 2773], [2775, 2775, 2832, 2832, 4332]]}
{"id": "fddXWB", "name": "I messed up but it looks cool", "author": "ninofiliu", "description": "I was attempting to visualize a cube of points in 3D but it looked like I messed up somewhere, looks cool tho", "tags": ["3d"], "likes": 5, "viewed": 41, "published": "Public", "date": "1633879776", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    const float zoom = 1.0;\n    vec3 camera = vec3(1.0*vec2(cos(iTime), sin(iTime)), 1.0);\n    vec3 lookAt = vec3(0.0, 0.0, 0.0);\n    \n    vec2 uv = (fragCoord - (iResolution.xy / 2.0)) / iResolution.y;\n    vec3 c = normalize(lookAt - camera);\n    vec3 u = vec3(c.y, -c.x, 0.0);\n    vec3 v = normalize(vec3(c.z*c.x, c.z*c.y, c.x*c.x+c.y*c.y));\n    vec3 ray = normalize(c + (uv.x * u + uv.y * v) / zoom);\n    \n    fragColor = vec4(vec3(0.0), 1.0);\n    \n    int nb = 10;\n    for (int xi = 0; xi < nb; xi++) {\n        for (int yi = 0; yi < nb; yi++) {\n            for (int zi = 0; zi < nb; zi++) {\n                vec3 point = vec3(\n                    float(xi)/float(nb),\n                    float(yi)/float(nb),\n                    float(zi)/float(nb)\n                );\n                float dp = dot(ray, normalize(point-camera));\n                if (dp > 0.999) {\n                    fragColor.rgb += vec3(0.1);\n                }\n            }\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fddXWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 1020]]}
{"id": "fddXWH", "name": "yonatan @zozuar tw shader", "author": "pirk0", "description": "Just port it to shadertoy", "tags": ["clouds", "mountains"], "likes": 18, "viewed": 257, "published": "Public", "date": "1633064112", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision highp float;\n\nmat2 rotate2D(float r){\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float i,e,f,s,g,k=.01;    \n    float o;    \n    o++;    \n    for(int i=0;i<100;i++)\n    {\n      s=2.;      \n      g+=min(f,max(.03,e))*.3;      \n      vec3 p=vec3((fragCoord.xy-iResolution.xy/s)/iResolution.y*g,g-s);\n      p.yz*=rotate2D(-.8);\n      p.z+=iTime;\n      e=p.y;\n      f=p.y;\n      for(;s<200.;)\n      {\n        s/=.6;\n        p.xz*=rotate2D(s);\n        e+=abs(dot(sin(p*s)/s,p-p+.4));\n        f+=abs(dot(sin(p.xz*s*.6)/s,iResolution.xy/iResolution.xy));\n      }\n\n      if(f>k*k)\n        o+=e*o*k;\n      else\n        o+=-exp(-f*f)*o*k;\n\n\n    }\n    fragColor = vec4(o);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fddXWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 47, 47, 99], [101, 101, 158, 158, 745]]}
{"id": "fdGSRm", "name": "[phreax] radial noise gradient", "author": "phreax", "description": "Inspired by a stage visual mapping I once saw on a festival.\nUsing it as material for MadMapper.", "tags": ["noise", "gradient", "fade"], "likes": 2, "viewed": 41, "published": "Public", "date": "1634383958", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592\n#define SIN(x) (.5*sin(x)+.5)\n#define hue(v) (.6+.6*cos(2.*PI*v + vec3(0, -2.*PI/3., 2.*PI/3.)))\n\nfloat t;\n\n\nmat2 rot(float a) {\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\n\n// noise function from https://www.shadertoy.com/view/MdyfWz\nfloat r(in vec2 p)\n{\n    return fract(cos(p.x*42.98 + p.y*43.23) * 1127.53);\n}\n\n// using noise functions from: https://www.shadertoy.com/view/XtXXD8\nfloat n(in vec2 p)\n{\n    vec2 fn = floor(p);\n    vec2 sn = smoothstep(vec2(0), vec2(1), fract(p));\n    \n    float h1 = mix(r(fn), r(fn + vec2(1,0)), sn.x);\n    float h2 = mix(r(fn + vec2(0,1)), r(fn + vec2(1)), sn.x);\n    return mix(h1 ,h2, sn.y);\n}\n\nfloat noise(in vec2 p)\n{\n    return n(p/32.) * 0.58 +\n           n(p/16.) * 0.2  +\n           n(p/8.)  * 0.1  +\n           n(p/4.)  * 0.05 +\n           n(p/2.)  * 0.02 +\n           n(p)     * 0.0125;\n}\n\nvec2 pixelate(vec2 uv, float gran) {\n    return vec2(gran*floor(uv/gran));\n}\n\n\nfloat radial(vec2 uv, float o) {\n    //return SIN(length(2.*uv)-t*2.);\n    \n    //return smoothstep(ts+.1, ts-.1, n);\n    float ts = SIN(length(.5*uv)-t*2.4+o);\n    float n = noise(uv*70.);\n    return smoothstep(ts+.5, ts-.5, n);\n}\n\nvec3 gradient1(vec2 uv) {\n\n    return hue(.4*iTime+2.*radial(uv, 0.3)) - mix(vec3(0.933,1.000,0.000), vec3(0.702,0.000,0.071), radial(uv*4., 0.));\n}\n\nvec3 gradient2(vec2 uv) {\n    return  hue(0.2*iTime+radial(uv, 0.9)) + mix(vec3(0.000,0.047,0.678), vec3(0.110,0.000,0.502), radial(uv*4., .5));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec2 uvo = uv;\n    uv = pixelate(uv, .008);\n\n    t= iTime;\n    vec3 col = vec3(0);\n    \n    \n    float r = 2.*length(uv*1.);\n    float n = noise(uv*rot(t*.1)*200.);\n    \n    float ts = SIN(4.5*length(uv)+t*4.);\n    \n    col = mix(gradient1(uvo), gradient2(uvo), smoothstep(ts+.2, ts-.2, n));\n   \n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdGSRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[129, 129, 148, 148, 200], [203, 264, 284, 284, 342], [344, 413, 433, 433, 662], [664, 664, 688, 688, 865], [867, 867, 903, 903, 943], [946, 946, 978, 1063, 1177], [1179, 1179, 1204, 1204, 1327], [1329, 1329, 1354, 1354, 1475], [1477, 1477, 1534, 1534, 1933]]}
{"id": "fdGSRt", "name": "Sineheart", "author": "safic2", "description": "Putting together a bunch of sine waves may result in something quite abstract but still recognizable...", "tags": ["2d", "abstract", "sine"], "likes": 0, "viewed": 33, "published": "Public", "date": "1635078267", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 cd;\n    cd.x = fragCoord.x - iResolution.x*0.5;\n    cd.y = fragCoord.y - iResolution.y*0.7;\n    cd = cd / iResolution.x;\n    \n    float pi = radians(180.);\n    \n    float fi = atan(cd.x/cd.y);\n    if (cd.y < 0.){\n        fi += pi;\n    }\n    fi = mod( fi + 2.*pi, 2.*pi );\n    \n    float r = pow( (cd.x*cd.x + cd.y*cd.y), 0.5 );\n    \n    float bps = 0.7;\n    float sinx = 2.*pi*iTime*bps;\n    \n    float heartbeat = 0.7 + 0.3 * abs( sin(sinx) * sin(2.*sinx) ) * 0.5;\n    \n    //float heartbeat;\n    //if (mod(iTime, 2.) > 1.){\n    //    heartbeat = 0.7 + 0.3 * sin(sinx);\n    //}else{\n    //    heartbeat = 0.7 + 0.15 * sin(sinx);\n    //}\n    \n    float r00 = .2;\n    //float r0 = r00 * heartbeat * pow( sin(fi/2.), 0.5 );\n    float r0 = r00 * heartbeat * sin(fi/2.);\n    \n    float rrel = r/r0;\n    \n    \n    \n    float red = 1. - 0.5*rrel;\n    \n    fragColor = vec4(red, 0, 0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdGSRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 996]]}
{"id": "fdGXWD", "name": "Matrix Metaballs", "author": "dreymatic", "description": "https://thebookofshaders.com/edit.php#08/matrix.frag\nhttps://thebookofshaders.com/edit.php#12/metaballs.frag\n", "tags": ["metaballs"], "likes": 2, "viewed": 67, "published": "Public", "date": "1634618752", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat random(in float x){\n    return fract(sin(x)*43758.5453);\n}\n\nfloat random(in vec2 st){\n    return fract(sin(dot(st.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rchar(in vec2 outer,in vec2 inner){\n    float grid = 5.;\n    vec2 margin = vec2(.2,.05);\n    float seed = 23.;\n    vec2 borders = step(margin,inner)*step(margin,1.-inner);\n    return step(.5,random(outer*seed+floor(inner*grid))) * borders.x * borders.y;\n}\n\nvec3 matrix(in vec2 st){\n    float rows = 80.0;\n    vec2 ipos = floor(st*rows);\n\n    ipos += vec2(.0,floor(iTime*20.*random(ipos.x)));\n\n\n    vec2 fpos = fract(st*rows);\n    vec2 center = (.5-fpos);\n\n    float pct = random(ipos);\n    float glow = (1.-dot(center,center)*3.)*2.0;\n\n    return vec3(rchar(ipos,fpos) * pct * glow);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 color = vec3(.0);\n    \n    uv += 5.;\n    \n    vec2 i_st = floor(uv);\n    vec2 f_st = fract(uv);\n    \n    float m_dist = 1.0;\n    for(int j = -1; j <= 1; j++) {\n        for (int i = -1; i <= 1; i++) {\n            vec2 neighbor = vec2(float(i), float(j));\n            vec2 offset = random2(i_st + neighbor);\n            \n            offset = 0.5 + 0.5*sin(iTime + 6.28323231*random2(offset));\n            \n            vec2 pos = neighbor + offset - f_st;\n            \n            float dist = length(pos);\n            \n            m_dist = min(m_dist, m_dist*dist);\n        }\n    }\n    \n    color += step(0.1, m_dist);\n    \n    if (color == vec3(0)) {\n        color = matrix(uv);\n        color = vec3(color.x + random(color.x)*sin(iTime+uv.x), color.y*cos(iTime+uv.y), color.z*cos(uv.y)*sin(uv.x));\n        fragColor = vec4(1.-color, 1.0);\n    } else {\n        fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdGXWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 25, 25, 118], [120, 120, 145, 145, 184], [186, 186, 211, 211, 283], [285, 285, 326, 326, 546], [548, 548, 572, 572, 876], [878, 878, 935, 985, 1987]]}
{"id": "fdKSDV", "name": "circle123 ", "author": "Yankowang", "description": "smoothstep test", "tags": ["smoothstep", "step", "length"], "likes": 1, "viewed": 26, "published": "Public", "date": "1635324422", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n         uv.x= uv.x*iResolution.x/iResolution.y;\n    float leng = iResolution.x/iResolution.y/2.0;\n    \n    // Time varying pixel color\n    float d = length((uv-vec2(leng,0.5))*30.0) + iTime+uv.x*20.0+uv.y*20.0;\n    float c =smoothstep(0.3,0.99,abs(sin(d+0.5)));\n    float k =step(0.8,abs(sin(d)))+c;\n    // Output to screen\n    fragColor = vec4(k,abs(cos(d)),1.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdKSDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 519]]}
{"id": "fdKSRt", "name": "46/49", "author": "tono", "description": "46/49", "tags": ["49"], "likes": 3, "viewed": 80, "published": "Public", "date": "1635120681", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat pi = acos(-1.);\nvec3 pp;\nfloat tt;\nfloat rand(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\nvec2 map(vec3 p)\n{\n    float o = 10.;\n    float id = 0.;\n    \n    o = length(p) - 1.7;\n    \n    vec2 d = floor(p.xz);\n    p.x += d.y/2.;\n    d = floor(p.xz);\n    p.xz = mod(p.xz,1.)-.5;\n    float t = iTime*13.;\n    t = floor(t) + pow(fract(t),3.);\n    float h = sin(t * pi * 2.)*.5+.5;\n    //t = iTime*15.;\n    \n    //p.x += d.y/2.;\n    pp = p;\n    d.x += floor((rand(vec3(d,1.)+floor(t) )-.5)*12.);\n    d.y += floor((rand(vec3(d.yx,-1.)+floor(t) )-.5)*12.);\n    float th = 1.-step(.9,length(d));\n    h *= th/2.;\n    tt =t;\n    p.y -= h;\n    p = abs(p)-clamp((p.y+.2)/5. ,0.,.1)-vec3(.4,.2,.4);\n    //p.y += h;\n    o = max(p.x,max(p.y,p.z));\n    o = max(o,-(length(pp + vec3(0.,1.9+h ,0.))-1.8) );\n    return vec2(o,id);\n}\n\nvec2 march(vec3 cp , vec3 rd)\n{\n    float depth = 0.;\n    for(int i = 0 ; i< 99 ; i++)\n    {\n        vec3 rp = cp + rd * depth;\n        vec2 d = map(rp);\n        if(abs(d.x) < 0.01)\n        {\n            return vec2(depth,d.y);\n        }\n        depth += d.x;\n    }\n    return vec2(-depth , 0.);\n\n}\n\n\nfloat noise(vec3 p)\n{\n    vec3 fp = floor(p);\n\tvec3 fs = fract(p);\n    vec3 sf = vec3(1.,0.,0.);\n    \n    float a = rand(fp);\n    float b = rand(fp + sf);\n    float c = rand(fp + sf.yxz);\n    float d = rand(fp + sf.xxz);\n    float e = rand(fp + sf.yyx);\n    float f = rand(fp + sf.xyx);\n    float g = rand(fp + sf.yxx);\n    float h = rand(fp + sf.xxx);\n    \n    vec3 u = smoothstep(0.,1.,fs);\n  //  u = pow(fs,vec3(3.));\n    \n    return mix(mix(\n        \t\tmix(a,b,u.x),\n        \t\tmix(c,d,u.x),u.y),\n               mix(\n                mix(e,f,u.x),\n                mix(g,h,u.x),u.y),u.z\n            );\n}\nfloat str(vec3 p,vec3 op)\n{\n    p = vec3(p.xz,1.).xzy;\n\tfloat o = noise(p*7.4 + noise(p*10.1+ tt + noise(p*1.3 )));\n    return step(.8 * clamp(1.- (length(op.xz))*2.4,0.,1.),o );\n    //return step(length(op),.3);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tvec3 cp = vec3(0.,-15.,-6.);\n    vec3 target = vec3(0.,2.,0.);\n    \n    vec3 col = vec3(0.);\n    \n    vec3 cd = normalize(vec3(target - cp));\n    vec3 cs = normalize(cross(cd , vec3(0.,1.,0.)));\n    vec3 cu = normalize(cross(cd,cs));\n    \n    float fov = 2.5;\n    \n    vec3 rd = normalize(cd * fov + cs * p.x + cu * p.y);\n    \n    vec2 d = march(cp,rd);\n    if( d.x > 0.)\n    {\n        vec2 e = vec2(0.,0.01);\n        vec3 pos = cp + rd * d.x;\n        vec3 N = normalize(map(pos).x - vec3(map(pos - e.xyy).x , map(pos - e.yxy).x,map(pos - e.yyx).x));\n        col = N;\n        vec3 sun = normalize(vec3(2.,4.,8.));\n        //sun.xz *= rot(iTime);\n        float diff = max(0.,dot(-sun,N));\n        diff = mix(diff , 1.,.1);\n        float sp = max(0.,dot(rd,reflect(N,sun)));\n        sp = pow(sp,56.6) * 1.;\n        vec3 mat = str(pos,pp) * vec3(1.);\n        col = sp * mat + diff * mat;\n    }\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdKSRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 61], [103, 103, 123, 123, 218], [219, 219, 237, 237, 941], [943, 943, 974, 974, 1241], [1244, 1244, 1265, 1265, 1847], [1848, 1848, 1875, 1875, 2062], [2063, 2063, 2120, 2120, 3139]]}
{"id": "fdKXWK", "name": "twin dragon curve", "author": "fpsunflower", "description": "An implementation of the twin dragon fractal by decomposing gaussian integers into binary digits in base -1+i.", "tags": ["fractal", "dragon", "gaussian", "integers"], "likes": 5, "viewed": 53, "published": "Public", "date": "1635350266", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Inspired by this nice video: https://youtu.be/zJSBL1XWFDc\n// Every integer in the complex plane can be turned into a natural number n\n// Consecutive values of n follow an interesting fractal pattern that tiles the plane\n\n#define AA 3\n#define MAXBITS 64 // anything > 31 will overflow an int - but we don't actually use the value of n here\n\nvec2 rand(uvec2 v)\n{\n    // https://www.shadertoy.com/view/XlGcRh\n    v = v * 1664525u + 1013904223u;\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n    v = v ^ (v>>16u);\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n    v = v ^ (v>>16u);\n    // return float in [0,1)\n    return vec2(v >> 8) / float(0x01000000);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // zoom in/out\n    float S = 12500.0;\n    float scale = 2.0 * (S * cos(0.3 * iTime) + S + 50.0);\n    vec3 result = vec3(0.0);\n    for (int y = 0; y < AA; y++)\n    for (int x = 0; x < AA; x++) {\n        // stratified tent filter sampling\n        vec2 j = (vec2(x,y)+rand(uvec2(fragCoord) * uvec2(AA) + uvec2(x,y)))/float(AA);\n        j.x *= 2.; j.x = j.x < 1. ? sqrt(j.x) - 1. : 1. - sqrt(2. - j.x);\n        j.y *= 2.; j.y = j.y < 1. ? sqrt(j.y) - 1. : 1. - sqrt(2. - j.y);\n        // jitter around pixel center\n        vec2 uv = (fragCoord+j+0.5)/iResolution.x;\n        // get nearest gaussian integer\n        uv *= scale;\n        uv -= vec2(1.0, iResolution.y / iResolution.x)*scale*0.5;\n\n        ivec2 g = ivec2(round(uv));\n        // decompose the gaussian integer g one digit at a time\n        // to extract the binary value n in base -1+i\n        // we don't actually need the value n, we just care about the highest bit index\n        // left the code in as an example\n        int n = 0, b = 1, bit = 0;\n        for (; bit < MAXBITS; bit++)\n        {\n            int r = (g.x ^ g.y) & 1; // remainder (1 only when x or y is odd)\n            g = ivec2( g.y - g.x + r, -g.x - g.y + r) / 2;\n            if (all(equal(g, ivec2(0))))\n            {\n                // done decomposing g, return index of current bit\n                break;\n            }\n            n += b * r;\n            b *= 2;\n        }\n        // color based on highest bit index (each colored region has the same number of digits)\n        float rx = 6.0*rand(uvec2(bit, 0)).x;\n        // hash to get a random color\n        result += 0.5 + 0.5*cos(rx+vec3(0,2,4));\n    }\n    fragColor=vec4(result / float(AA * AA), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdKXWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 343, 363, 408, 672], [674, 674, 731, 750, 2428]]}
{"id": "fdKXzw", "name": "Wobbles", "author": "Loubi", "description": "Just messing with circles", "tags": ["circles"], "likes": 4, "viewed": 73, "published": "Public", "date": "1634420155", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    \n    vec2 topLeft = vec2(-.5, .5);\n    vec2 topRight = vec2(.5, .5);\n    vec2 bottomRight = vec2(.5, -.5);\n    vec2 bottomLeft = vec2(-.5, -.5);\n    \n    float d1 = length(uv + topLeft);\n    float d2 = length(uv + topRight);\n    float d3 = length(uv + bottomRight);\n    float d4 = length(uv + bottomLeft);\n    // float d3 = length(uv);\n    \n    float m1 = cos(d1 * 20. - iTime * 3.) * .5 + .5;\n    float m2 = cos(d2 * 20. - iTime * 4.) * .5 + .5;\n    float m3 = cos(d3 * 20. - iTime * 5.) * .5 + .5;\n    float m4 = cos(d4 * 20. - iTime * 2.) * .5 + .5;\n    \n    float m = m1 / 4. + m2 / 4. + m3 / 4. + m4 / 4.;\n    m = smoothstep(.2, .6, m);\n    \n    float r = mix(.123, .7, m + sin(uv.x * m * 30.) * cos(uv.y * m * 20.));\n    float g = mix(.23, .9, m );\n    float b = mix(.3, .8, m );\n    \n    vec3 col = vec3(r, g, b);\n\n\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdKXzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 983]]}
{"id": "fdtSDB", "name": "Paradise Islands", "author": "omegasbk", "description": "Made these cute islands for fun, added basic day&night cycle to spice it up. \nSuper hacky.\n\nHint: You can use the mouse to change the water level!", "tags": ["raymarching", "islands"], "likes": 6, "viewed": 113, "published": "Public", "date": "1635358250", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Made by Darko Supe (omegasbk)\n// 27.10.2021.\n// Super hacky, I was just having fun :D\n\n#define MAX_STEPS 1000\n#define MAX_DIST 100.\n#define SURF_DIST .005\n\n#define PI 3.14159265359\n\n#define NONE 0.0\n#define SEA 1.0\n#define ISLAND 2.0\n#define SUN 3.0\n\n#define FLYING_SPEED 2.0\n#define SUN_SIZE 2.1\n\n#define SUN_DISTANCE 200.\n\n#define FOG_AMOUNT .97\n\nfloat SHORE_LINE = -4.5;\n\nvec3 lightPosition = vec3(0, 1, SUN_DISTANCE);\nvec3 lightColor = vec3(0.34, 0.3, 0.3) * 2.1;\nconst float lightIntensity = 1.5;\n\nfloat noise(vec2 uv)\n{\n    return fract(sin(uv.x * 113. + uv.y * 412.) * 6339.);\n}\n\nfloat add(float d1, float d2) \n{ \n    return min(d1,d2); \n}\n\nfloat noiseSmooth(vec2 uv)\n{\n    vec2 index = floor(uv);\n    \n    vec2 pq = fract(uv);\n    pq = smoothstep(0., 1., pq);\n     \n    float topLeft = noise(index);\n    float topRight = noise(index + vec2(1, 0.));\n    float top = mix(topLeft, topRight, pq.x);\n    \n    float bottomLeft = noise(index + vec2(0, 1));\n    float bottomRight = noise(index + vec2(1, 1));\n    float bottom = mix(bottomLeft, bottomRight, pq.x);\n    \n    return mix(top, bottom, pq.y);\n}\n\nfloat plane(vec3 p, vec3 n, float h)\n{\n    return dot(p,n) + h;\n}\n\nfloat sea(vec3 p)\n{\n    return dot(p, vec3(0., 1., 0)) - SHORE_LINE;\n}\n\nfloat islands(vec3 p, float h)\n{\n    h += noiseSmooth(p.xz / 8.) * 4.;\n    h += noiseSmooth(p.xz / 16.) * 2.;\n    h += noiseSmooth(p.xz / 32.);\n\n    h += textureLod(iChannel1, p.xz / 25., 0.).r;\n    return dot(p, vec3(0., 1., 0)) - h;\n}\n\nfloat sun(vec3 p)\n{\n    return distance(p, lightPosition - vec3(0., 0., SUN_DISTANCE)) - SUN_SIZE;\n}\n\nvec2 getDist(in vec3 p, in float specific)\n{    \n    float dIslands = islands(p, -8.);\n    float dSea = sea(p);\n    float dSun = sun(p);\n    \n    if (int(specific) == int(ISLAND))\n        return vec2(dIslands, ISLAND);\n\n    if (dIslands < dSea && dIslands < dSun)\n    {\n        return vec2(dIslands, ISLAND);\n    }\n    else if (dSea < dIslands && dSea < dSun)\n    {\n        return vec2(dSea, SEA);\n    }\n\n    return vec2(dSun, SUN);\n}\n\nvec3 getNormal(in vec3 p) \n{\n    vec2 d = getDist(p, NONE);\n    \n    vec2 e = vec2(.01, 0); \n    \n    vec3 n = d.x - vec3(\n        getDist(p - e.xyy, NONE).x, \n        getDist(p - e.yxy, NONE).x, \n        getDist(p - e.yyx, NONE).x);\n        \n    return normalize(n);\n}\n\nvec2 rayMarch(in vec3 ro, in vec3 rd, float specific)\n{\n    float dO = 0.;\n    float body = -1.;\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd * dO;\n        vec2 distVec = getDist(p, specific);\n        float dS = distVec.x;\n        body = distVec.y;\n        \n        dO += dS;\n        \n        if (dO > MAX_DIST)\n            return vec2(MAX_DIST, -1.);\n            \n        if (dS < SURF_DIST)\n            return vec2(dO, body);\n    }\n    \n    return vec2(dO, body);\n}\n\nvec3 getLight(in vec3 p, in vec3 rd, float ambiant, float diff, float shininess)\n{    \n\tvec3 normal = getNormal(p);\n    \n    vec3 lightDir = normalize(p - lightPosition);   \n    \n    float cosa = pow(0.5+0.5*dot(normal, -lightDir), 3.0);\n    float cosr = max(dot(-rd, reflect(lightDir, normal)), 0.0);\n    \n    vec3 diffuse = vec3(diff * cosa);\n    vec3 phong = vec3(0.5 * pow(cosr, shininess));\n    \n    return lightColor * (vec3(ambiant) + diffuse + phong) * lightIntensity;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 skyColor = vec3(0.1, 0.5, 1.) * (1.4 - uv.y);\n    \n    vec3 ro = vec3(sin(iTime) / 4., 0.5 + sin(sin(iTime)) / 2., iTime * FLYING_SPEED) + vec3(0., 1.2, 0.);\n    vec3 rd = normalize(vec3(uv.x, uv.y-0.2, 0.8));\n    \n    float lightMovement = fract(iTime / 25.) - 0.5;\n    //float lightMovement = 0.;\n\n    lightPosition.x = 200. * lightMovement;\n    lightPosition.y += sin((lightPosition.x - 189.) / 40.) * 18.; \n    \n    lightPosition += ro + vec3(0., 0., 60.);\n          \n    lightColor *= 1.0 - pow(abs(lightMovement * 2.), 2.0); \n    \n    lightColor.z += pow(abs(lightMovement * 2.), 2.0) / 3.; \n    \n    skyColor *= lightColor + 0.5;\n    skyColor.x *= (18. - lightPosition.y) * smoothstep(0.5, 0.1, abs(lightMovement));\n          \n    SHORE_LINE =((iMouse.y / iResolution.y) * 5.) - 4.;\n   \n    vec2 distVec = rayMarch(ro, rd, NONE);\n    if (distVec.x < MAX_DIST)\n    {\n        vec3 p = ro + rd * distVec.x;   \n        vec3 n = getNormal(p);\n        \n        if (distVec.y == SEA)\n        {\n            col = vec3(0.1, 0.65, 0.9);\n            \n            vec3 refrRay = refract(rd, n, 1./1.4);\n            distVec = rayMarch(p + refrRay * 0.01, rd, ISLAND);\n            \n            if (distVec.x < MAX_DIST)\n            {\n                col = mix(col, vec3(max(0., 1. - distVec.x)), 0.1);\n            }\n                        \n            vec3 reflRay = reflect(rd, n);\n            distVec = rayMarch(p + reflRay * 0.01, reflRay, NONE);\n                        \n            if (distVec.x < MAX_DIST)\n            {\n                vec3 pRefl = p + reflRay * distVec.x;  \n                \n                if (distVec.y != SUN)\n                    col = mix(getLight(pRefl, reflRay, 0.4, 0.6, 0.2), col, 0.8);\n                else\n                    col = mix(lightColor * 4., col, 0.8);\n            }\n            \n            col *= getLight(p, n, 1.3, 0.4, 50.0) / 1.5;\n        }\n        else if (distVec.y == SUN)\n        {\n            col = lightColor * 4.;\n        }  \n        else\n        {\n            col = vec3(0.1, 0.8, 0.3);\n            float sand = smoothstep(SHORE_LINE + 0.5, SHORE_LINE, p.y);\n            col = mix(col, vec3(0.8, 0.7, 0.5) * (2.5 - sand), sand);\n            col *= getLight(p, rd, 0.4, 0.2, 1.); \n        }  \n        \n        col = mix(col, skyColor, clamp(mix((FOG_AMOUNT * distance(ro, p)) / MAX_DIST, 1., -.5), 0., 1.)); // Distance fog\n        col = mix(col, skyColor, clamp(mix(FOG_AMOUNT * 0.38, 1., -.5), 0., 1.)); // General fog\n    }\n    else \n    {    \n        col = skyColor;\n    }   \n    \n    \n    fragColor = vec4(col,1.0) / 1.1;\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdtSDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 506, 528, 528, 588], [590, 590, 622, 622, 649], [651, 651, 679, 679, 1108], [1110, 1110, 1148, 1148, 1175], [1177, 1177, 1196, 1196, 1247], [1249, 1249, 1281, 1281, 1485], [1487, 1487, 1506, 1506, 1587], [1589, 1589, 1633, 1633, 2023], [2025, 2025, 2053, 2053, 2294], [2296, 2296, 2351, 2351, 2794], [2796, 2796, 2878, 2878, 3274], [3276, 3276, 3332, 3332, 6017]]}
{"id": "fdtSDX", "name": "Sponge Cylinder", "author": "rudros", "description": "Very small but (hopefully) readable ray-caster", "tags": ["raycasting", "mini"], "likes": 8, "viewed": 127, "published": "Public", "date": "1634165106", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415326\n\nmat2 rotate2D(float r) {\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\nfloat levelDist(vec3 p, float level) {\n    float scale = 1./pow(4., level);\n\tp = mod(p + scale, scale*2.) - scale;\n\tp = abs(p);\n\treturn .3*scale - min(max(p.x, p.y), min(max(p.y, p.z), max(p.z, p.x)));\n}\n\nfloat cylinder(vec3 p) {\n    return .5-length(p.xy);\n}\n\n// Max gives us the intersection of all the surfaces\nfloat maxDist(vec3 p) {\n\tfloat dist = 0.;\n\tfor (float i = 0.; i < 4.; i++) {\n\t\tdist = max(dist, levelDist(p, i));\n\t}\n\treturn max(dist, cylinder(p));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float i;\n    float eyeDist, minDist;\n\n    vec3 eyePos = vec3(0, 0, iTime); // Keep moving forward\n    vec3 ray = vec3((fragCoord.xy-.5*iResolution.xy)/iResolution.x, 1.);\n    ray = normalize(ray);\n    \n    // Camera rotation\n// \tray.xz *= rotate2D(PI*iTime*.2);\t\n\n    for(minDist=1.; i<100. && minDist>.001; i++) {  \n        // Point to check\n        vec3 p = eyePos+eyeDist*ray;\n        \n        minDist = maxDist(p);\n        // Move point forward\n        eyeDist += minDist*.5;\n    }\n    // Fix for banding\n    i += 2.*(minDist*1000.-1.);\n    fragColor = vec4(0);\n    fragColor += 400./(i*i);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdtSDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 46, 46, 98], [100, 100, 138, 138, 303], [305, 305, 329, 329, 359], [361, 414, 437, 437, 564], [566, 566, 621, 621, 1222]]}
{"id": "fdtSRs", "name": "Reef and waves short", "author": "guil", "description": "short version", "tags": ["waves", "reef"], "likes": 5, "viewed": 147, "published": "Public", "date": "1633733271", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 R(float a){\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\n\nvoid mainImage( out vec4 C, vec2 FC )\n{\n    float o,i,e,f,s, g=4., t=iTime, k=.1;\n    vec3 q, r=iResolution, l=vec3(2.);\n    \n    for(;i++<1e2; g+=min(f,min(e,3.*e*f))*k){\n        s=2.;\n        vec3 p=vec3((FC.xy-r.xy/s)/r.y*g,g-5.);\n        k*=1.015;\n        p.yz*=R(-.7);\n        p.z+=t;\n        for(e=f=p.y;s<2e2;s/=.6)\n            p.xz*=R(s),\n            q=p,\n            q.x+=t,\n            e+=abs(dot(sin(q.xz*s*.1)/s,l.xz)),\n            f+=abs(dot(sin(p*s*.15)/s,l));\n         o=1.+(f>4e-3?(e>.002?exp(-f*e):-exp(-e*e)):-exp(-f*f));\n         \n         C *= .96;\n         C.rgb += .05*max(o,.1)*(exp(-f)*vec3(.5,.3,.2)+exp(-e)*vec3(.1,.4,.7));\n         }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdtSRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 16, 16, 68], [71, 71, 110, 110, 738]]}
{"id": "fdVSWz", "name": "2d basic building", "author": "jorge2017a2", "description": "2d basic building", "tags": ["2dbasicbuilding"], "likes": 5, "viewed": 128, "published": "Public API", "date": "1634483855", "time_retrieved": "2021-10-01T00:00:00", "image_code": "///2d basic building-JFP\n///por jorge2017a2...2021-oct-09\n///referencia\n//https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(antialiasing(0.05),b,d)\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n///---------------------------\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n    \nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  //colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.05,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.05,0.0));\n  return colOut;\n}\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\nreturn colOut;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle( vec2 p, float r )\n{return length(p) - r;}\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n\nfloat sdParallelogram( in vec2 p, float wi, float he, float sk )\n{\n    vec2 e = vec2(sk,he);\n    p = (p.y<0.0)?-p:p;\n    vec2  w = p - e; w.x -= clamp(w.x,-wi,wi);\n    vec2  d = vec2(dot(w,w), -w.y);\n    float s = p.x*e.y - p.y*e.x;\n    p = (s<0.0)?-p:p;\n    vec2  v = p - vec2(wi,0); v -= e*clamp(dot(v,e)/dot(e,e),-1.0,1.0);\n    d = min( d, vec2(dot(v,v), wi*he-abs(s)));\n    return sqrt(d.x)*sign(-d.y);\n}\n\nfloat dot2( vec2 v ) { return dot(v,v); }\nfloat sdTunnel( in vec2 p, in vec2 wh )\n{\n    p.x = abs(p.x); p.y = -p.y;\n    vec2 q = p - wh;\n\n    float d1 = dot2(vec2(max(q.x,0.0),q.y));\n    q.x = (p.y>0.0) ? q.x : length(p)-wh.x;\n    float d2 = dot2(vec2(q.x,max(q.y,0.0)));\n    float d = sqrt( min(d1,d2) );\n    \n    return (max(q.x,q.y)<0.0) ? -d : d;\n}\n\nfloat sdOrientedBox( in vec2 p, in vec2 a, in vec2 b, float th )\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\n\nvec3 Suelo1(vec2 p, vec3 col)\n{   col=DrawFig(vec3(0.45), col, p.y-2.5 );\n return col;\n}\n\nvec3 colina(vec2 p, vec3 col)\n{   p.x=opRep1D(p.x, 8.5 );\n    float d1= sdTriangleIsosceles(vec2(p.x,-p.y+0.5), vec2(4.0,2.0) );\n    col=DrawFigBordeCol(vec3(0.0,0.95,0.2), col, d1 , vec3(0.35));\n    return col;\n}\n\nvec4 sujeto(vec2 p, vec3 col)\n{  float d1= sdCircle(p-vec2(0.0,0.0), 0.25);\n    float d2= sdBox(p-vec2(0.0,-0.8), vec2(0.1,0.6) ); //cuerpo\n    float d3=sdOrientedBox( p-vec2(0.0,-1.2), vec2(1.0,0.0), vec2(0.0,0.8), 0.2 );\n    float d4=sdOrientedBox( p-vec2(-1.0,-1.2), vec2(0.0,0.0), vec2(1.0,1.0), 0.2 );\n    float d5=sdOrientedBox( p-vec2(0.0,-2.2), vec2(1.0,0.0), vec2(0.0,0.8), 0.2 );\n    float d6=sdOrientedBox( p-vec2(-1.0,-2.2), vec2(0.0,0.0), vec2(1.0,1.0), 0.2 );\n    float d=unionSDF(d1,d2);\n    d=unionSDF(d,d3);\n    d=unionSDF(d,d4);\n    d=unionSDF(d,d5);\n    d=unionSDF(d,d6);\n    \n    return vec4(vec3(0.0),d);\n}\n\n\n\nvec3 Edificio0(vec2 p, vec3 col)\n{  \n    float d1=sdBox(p-vec2(-4.0,4.0), vec2(10.0,3.5) ); //frente\n    float d2=sdParallelogram( p.yx-vec2(5.0,7.0), 3.5, 1.0, 1.0 ); //pared derecha\n    float d3=sdParallelogram( p-vec2(-3.0,8.5), 10.0, 1.0, 1.0 );  //techo\n    \n    //ventana\n    float d4= sdTunnel(p- vec2(-10.0,2.0), vec2(1.0,1.5) );\n    float d5= sdTunnel(p- vec2(-6.0,2.0), vec2(1.0,1.5) );\n    float d6= sdTunnel(p- vec2(-2.0,2.0), vec2(1.0,1.5) );\n    float d7= sdTunnel(p- vec2(2.0,2.0), vec2(1.0,1.5) );\n    \n    vec3 coltex=texture(iChannel0, p*0.25).rgb;\n    //col= DrawFigBorde(vec3(0.2),col,d1);\n    col= DrawFigBorde(coltex,col,d1);\n    col= DrawFigBorde(vec3(0.3),col,d2);\n    col= DrawFigBorde(vec3(0.45),col,d3); //-\n    col= DrawFigBorde(vec3(0.0),col,d4);\n    col= DrawFigBorde(vec3(0.0),col,d5);\n    col= DrawFigBorde(vec3(0.0),col,d6);\n    col= DrawFigBorde(vec3(0.0),col,d7);\n    return col;\n}\n\n\nvec3 Edificio1(vec2 p, vec3 col)\n{  \n    ///suelo\n    float d1=sdParallelogram( p-vec2(-6.0,-2.5), 7.0, 2.0, 2.0 );\n    float d2=sdParallelogram( p-vec2(-5.8,-2.9), 7.0, 2.0, 2.0 );\n    float d3=sdBox(p-vec2(-8.0,-4.7), vec2(7.0,0.25) );\n    //edificio\n    float d4=sdBox(p-vec2(-6.0,1.0), vec2(4.0,4.0) ); //frente \n    float d5=sdParallelogram( p.yx-vec2(2.0,-1.0), 4.0, 1.0, 1.0 ); //pared derecha\n    float d6=sdParallelogram( p-vec2(-5.0,6.0), 4.0, 1.0, 1.0 );  //techo\n    //marco\n    float d7=sdBox(p-vec2(-6.0,1.0), vec2(0.5,4.0) );\n    float d8=sdBox(p-vec2(-6.0,1.0), vec2(4.0,0.5) );\n    //ventana\n    float d9= sdTunnel(p- vec2(-8.0,-1.0), vec2(1.0,1.5) );\n    float d10= sdTunnel(p-vec2(-4.0,-1.0), vec2(1.0,1.5) );\n    float d11= sdTunnel(p-vec2(-8.0,3.5), vec2(1.0,1.5) );\n    float d12= sdTunnel(p-vec2(-4.0,3.5), vec2(1.0,1.5) );\n    \n    col= DrawFigBorde(vec3(0.6),col, d2 );\n    col= DrawFigBorde(vec3(0.5,0.6,0.1),col, d1 );\n    col= DrawFigBorde(vec3(0.6),col, d3 );\n    //col= DrawFigBorde(vec3(0.6),col,d4);\n    vec3 coltex=texture(iChannel0, p*0.25).rgb;\n    col= DrawFigBorde(coltex,col,d4);\n    col= DrawFigBorde(vec3(0.3),col,d5);\n    col= DrawFigBorde(vec3(0.7),col,d6);\n    col= DrawFigBorde(vec3(0.8),col,d7);\n    col= DrawFigBorde(vec3(0.8),col,d8);\n    \n    col= DrawFigBorde(vec3(0.2,0.1,1.0),col,d9);\n    col= DrawFigBorde(vec3(0.2,0.1,1.0),col,d10);\n    col= DrawFigBorde(vec3(0.2,0.1,1.0),col,d11);\n    col= DrawFigBorde(vec3(0.2,0.1,1.0),col,d12);\n    return col;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    vec3  col=vec3(0.45,0.7,1.0)-uv.y*0.25;\n    uv*=10.0;\n    \n    uv.x+=4.0*sin(iTime*2.0);\n    col=colina(uv-vec2(0.0,4.0),col);\n    col=Suelo1(uv, col);\n    col=Edificio0(uv-vec2(-10.0,0.0),col);\n    col=Edificio0(uv-vec2(14.0,0.0),col);\n    col= Edificio1(uv-vec2(-5.0,-2.0),col);\n    col= Edificio1(uv-vec2(15.0,-2.0),col);\n    vec4 col4=sujeto(uv, col);\n    col=DrawFigBorde(col4.xyz, col, col4.w);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdVSWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 311, 345, 345, 440], [442, 473, 509, 509, 554], [559, 603, 650, 650, 677], [678, 678, 721, 721, 748], [749, 749, 797, 797, 825], [831, 831, 893, 893, 1089], [1091, 1091, 1172, 1172, 1302], [1304, 1304, 1361, 1361, 1427], [1429, 1429, 1466, 1466, 1546], [1548, 1548, 1583, 1583, 1605], [1607, 1607, 1658, 1658, 1966], [1969, 1969, 2035, 2035, 2377], [2379, 2379, 2401, 2401, 2420], [2421, 2421, 2462, 2462, 2731], [2733, 2733, 2799, 2799, 3016], [3019, 3019, 3050, 3050, 3107], [3109, 3109, 3140, 3140, 3322], [3324, 3324, 3355, 3355, 3951], [3955, 3955, 3989, 3989, 4871], [4874, 4874, 4908, 4923, 6377], [6382, 6382, 6439, 6439, 7000]]}
{"id": "fdVSz1", "name": "Trees 3", "author": "guil", "description": "Some trees", "tags": ["trees"], "likes": 9, "viewed": 201, "published": "Public API", "date": "1634377084", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n#define igt iTime\n\nvec4 ot=vec4(1.);\nfloat g=1.25;\n\nconst int MaxIter = 12;\n\nfloat zoom=1.3;\n\n\nfloat a1 = 1.15;\nfloat a2 = -.53;\nfloat a3 = 2.15;\nvec2 vr1; \nvec2 vr2; \nvec2 vr3;\n\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\n\n\nfloat capsule( vec3 p)\n{\n   \tp.y -= clamp( p.y, 0.0, 6.0 );\n    return length( p-.05 ) - .6;\n}\n\nfloat sphere( vec3 p, float r)\n{\n   \tp.y *= .4;\n    return length( p ) - r;\n}\n\n\nfloat branches(in vec3 p,in float l, in float dr, in int maxi , in int type)\n{ \n    l= min(l,capsule(p));\n    float b = sphere(p,9./dr);if(b>.5)return min(b,l);\n    for(int i=0;i<maxi;i++) {\n        p.y-=2.5;   \t\t\n        p.xz = abs(p.xz);\n        p.xz = cmul(vr1,p.xz);\n        p.xy = cmul(vr2,p.xy);\t\n        if (type==0)\n            if (i<maxi-2)p =  p * g; else p *=.8;\n        else if (type==1)\n            p *= g;\n        else\n            if (i>0 && i<maxi-1)p =  p * g; else p *=.9;\n        dr *= g;\n        l= min (l ,capsule(p) / dr);\n    }\n\treturn l;\n}\n\nfloat map(vec3 p)\n{ \n   \n    int a = int(floor(mod(p.x/20.+.5,3.)));\n    int b = int(floor(mod(p.z/20.+.5,4.)));\n    p.xz=mod(10.+p.xz,20.)-10.; \n    p.xz=cmul(p.xz, vec2(cos(float(b)),sin(float(b))));\n    float dr = 1.0;  \t\n    float l=p.y;\n   \n    if(p.y>.15){   \n\t\tfor(int i=0;i<5+b;i++){\n            l=branches(p,l,dr,MaxIter-i-b,a);\n            p.xz = cmul(vr3,p.xz);  \n            p.y-=5.5-float(b);\n            if(p.y<0.)break;\n            p*=g,dr*=g;   \n        }\n    }\t\t\t\n    return l;   \n}\n\nvec4 branchesOt(in vec3 p,in vec4 ot, in int maxi, in int type)\n{ \n   \n \n    for(int i=0;i<maxi;i++) {\n        p.y-=2.5;   \t\t\n        p.xz = abs(p.xz);\n        p.xz = cmul(vr1,p.xz);\n        p.xy = cmul(vr2,p.xy);\t\n        if (type==0)\n            if (i<maxi-2)p =  p * g; else p *=.8;\n        else if (type==1)\n            p *= g;\n        else\n            if (i>0 && i<maxi-1)p =  p * g; else p *=.9;\n        ot=min(ot,vec4(abs(p),dot(p,p)/float(i+1)));\n    }\n\treturn ot;\n}\n\nvec4 mapOt(vec3 p)\n{ \n   \n    int a = int(floor(mod(p.x/20.+.5,3.)));\n    int b = int(floor(mod(p.z/20.+.5,4.)));\n    p.xz=mod(10.+p.xz,20.)-10.; \n    p.xz=cmul(p.xz, vec2(cos(float(b)),sin(float(b))));\n    float dr = 1.0;\n    ot = vec4(1.);    \t\n   \n    if(p.y>.15){   \n\t\tfor(int i=0;i<5;i++){\n            ot=branchesOt(p,ot,MaxIter-i-b,a);\n            p.xz = cmul(vr3,p.xz);  \n            p.y-=5.5-float(b);\n            p*=g;dr*=g;   \n        }\n    }\t\t\t\n    return ot;   \n}\n\nfloat trace( in vec3 ro, in vec3 rd )\n{\n    float maxd = 120.;\n    float precis = 0.001;\n    float k = .5;\n      \n    float dt=1.;\n    float t = 0.0;\n    for( int i=0; i<128; i++ )\n    {\n\t\tif( t>maxd ||  dt<precis*(.1+t)) continue;             \n        t += dt*k;\n        k *= 1.01;\n\t\tdt = map( ro+rd*t );\n    }\n\n    if( t>maxd ) t=-1.0;\n    return t;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3  eps = vec3(.0001,0.0,0.0);\n\tvec3 nor;\n\tnor.x = map(pos+eps.xyy) - map(pos-eps.xyy);\n\tnor.y = map(pos+eps.yxy) - map(pos-eps.yxy);\n\tnor.z = map(pos+eps.yyx) - map(pos-eps.yyx);\n\treturn normalize(nor);\n}\n\nfloat softShadow( in vec3 ro, in vec3 rd, in float tmin, in float tmax)\n{\n\tfloat res = 1.0;\n        float precis = 0.1;\n\tfloat t = tmin;\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tfloat dt = 2.*map( ro + rd*t );\n\t\tres = min(res, 16.0*dt/t);\n\t\tt += dt;\n\t\tif( dt<precis || t>tmax ) break;\n\t}\n\treturn clamp(res*t/tmax, 0.0, 1.0);\t\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\n\tp.x *= iResolution.x/iResolution.y;\n\t\n\tvec2 m = vec2(-0.5)*6.28;\n\tm = (iMouse.xy/iResolution.xy-.5)*6.28;\n\tm += .5*vec2(cos(0.15*igt),cos(0.09*igt))+.3; \n    \n\tvr1 = vec2(cos(a1),sin(a1));\n    vr2 = vec2(cos(a2),sin(a2));\n    vr3 = vec2(cos(a3),sin(a3));\n    // camera\n\n\t\n\tvec3 ta = vec3(.5*igt,8.,4.);\n\tvec3 ro =ta  + zoom*4.*(5.+sin(.2*igt))*vec3( cos(m.x)*cos(m.y), 1.+sin(m.y), sin(m.x)*cos(m.y));\n\t\n\t\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(0.,1.,0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = normalize(cross(cu,cw));\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n\n\n    // trace\n\n   \n\t\n\tvec3 col = vec3(0.8,0.8,1.);\n\tfloat t = trace( ro, rd );\n\tif( t>0.0 )\n\t{\n\t\tvec3 pos = ro + t*rd;\n\t\tvec3 nor = calcNormal( pos );\n        ot = mapOt(pos);\n\t\t\n\t\t// lighting\n        \n        vec3  light1 = normalize(vec3( 0.4, 0.9,0.4  ));\n\t\tfloat key = clamp( dot( light1, nor ), 0.0, 1.0 );\n\t\tif(pos.y<.15){\n            key*=softShadow(pos,light1,1.,25.);\n            ot=texture(iChannel0,(pos.xz / 16.0));\n            ot.a=0.;\n        }\n\t\t\n\t\tfloat amb = (0.4+0.6*nor.y);\n\t\tfloat ao = pow( clamp(1.-.5*ot.a,0.2,1.0), 1.2 );\t\t\n        vec3 brdf = vec3(ao)*(.4*amb+key);\n\n        // material\t\t\t\t\n\t\tvec3 rgb =ot.rgb*vec3(.9,.7,.2);\n        \n        if(pos.y>.15){\n            rgb.rb = clamp(rgb.rb,0.,1.5*rgb.g);\n            \n        }\n        \n        \n\t\t// color\n        col = rgb*brdf;\n\t\tcol = mix(vec3(0.8,0.8,1.),col,exp(-0.015*t));\n        \n\n\t}\n\n\tfragColor=vec4(col,1.0);\n}", "image_inputs": [{"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdVSz1.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 266, 296, 296, 351], [354, 354, 378, 378, 448], [450, 450, 482, 482, 527], [530, 530, 608, 608, 1092], [1094, 1094, 1113, 1113, 1593], [1595, 1595, 1660, 1660, 2069], [2071, 2071, 2091, 2091, 2546], [2548, 2548, 2587, 2587, 2901], [2903, 2903, 2935, 2935, 3144], [3146, 3146, 3219, 3219, 3466], [3469, 3469, 3526, 3526, 5063]]}
{"id": "fdVXRh", "name": "angular lines", "author": "FabriceNeyret2", "description": "drawing polylines with angular junctions.\nMouse control.", "tags": ["lines"], "likes": 11, "viewed": 193, "published": "Public API", "date": "1634326997", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(v) smoothstep( 3./R.y, 0., (v) -.07 )\n\nfloat line0(vec2 p, vec2 a,vec2 b) { \n    p -= a, b -= a;\n    float h = dot(p, b) / dot(b, b);   // proj coord on line\n    return length(p - b * h);          // dist to segment\n}\nfloat line(vec2 p, vec2 a,vec2 b) { \n    p -= a, b -= a;\n    float h = dot(p, b) / dot(b, b);   // proj coord on line\n    h = clamp(h, 0.,1.);               // round end\n    return length(p - b * h);          // dist to segment\n}\n \nvec2 P,_D,D, M;\n#define L(B)  v = min( v, line(U,P,B) );                                        \\\n              _D = D; D = normalize(B-P); M = _D+D;                             \\\n              if (dot(U-P,D) < 0. && dot(U-P,_D) > 0. )                         \\\n                 v = min( v, dot(U-P,M) < 0. ? line0(U,P-_D,P) : line0(U,P,B)); \\\n              P = B; \n#define L0(A) P = A; D = vec2(0);\n\n             \nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( 2.*u - R ) / R.y ;   \n    \n    float a, v = 99.;\n    L0( vec2(-1.5,.7) ); \n    L( vec2(-1,-.5)+.4*cos(iTime+vec2(0,33)) ); \n    L( vec2(1.2,.7) ); L( vec2(.5,-.75) ); L( vec2(1.5,-.3) );\n    L( ( 2.*iMouse.xy - R ) / R.y );\n\n                 // bg  line pattern    line mask    \n    O = vec4(  mix( .5, S( v+2./R.y) , a = S( v ) ) );\n    v = max(0.,cos(.5*R.y*v)-.5); if (a==0.) O.b += v; else O.gb -= v; // show distance field\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdVXRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 85, 85, 227], [228, 228, 263, 263, 457], [875, 875, 913, 913, 1387]]}
{"id": "fdVXWc", "name": "Knot Curves 3", "author": "dr2", "description": "Visualize series of parametric knot curves (updated - see source)", "tags": ["knot"], "likes": 9, "viewed": 166, "published": "Public API", "date": "1635424793", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Knot Curves 3\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Cycle through 11 simple parametric knot curves (as in \"Knot Curves 2\").\n  Alternating tube and moving ball visualization.\n  Moving helical colors for tube.\n  Mouse near left/right edges overrides auto cycle.\n  Mouse near right edge, or in bottom window half, shows tube instead of balls.\n*/\n\n#define AA  0   // (= 0/1) optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nvec2 Rot2D (vec2 q, float a);\nmat3 StdVuMat (float el, float az);\nvec3 HsvToRgb (vec3 c);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltDir, knc[7], kns[7], qnHit;\nfloat dstFar, tCur, nSeg, sclFac, qCol;\nint knType;\nbool showBalls;\nconst float nKnot = 11.;\nconst float pi = 3.1415927;\n\nvec3 KtPoint (float a)\n{\n  vec3 r;\n  vec2 cs;\n  if (showBalls) a += mod (-0.2 * tCur, 2. * pi);\n  r = vec3 (0.);\n  for (int k = 0; k < 7; k ++) {\n    cs = sin (float (k + 1) * a + vec2 (0.5 * pi, 0.));\n    r += knc[k] * cs.x + kns[k] * cs.y;\n  }\n  return sclFac * r;\n}\n\nfloat SphHit (vec3 ro, vec3 rd, float rad)\n{\n  float b, d, w, dMin;\n  dMin = dstFar;\n  b = dot (rd, ro);\n  w = b * b - dot (ro, ro) + rad * rad;\n  if (w > 0.) {\n    d = - b - sqrt (w);\n    if (d > 0.) {\n      dMin = d;\n      qnHit = (ro + d * rd) / rad;\n    }\n  }\n  return dMin;\n}\n\nvec4 CapsHit (vec3 ro, vec3 rd, float rad, float len)\n{\n  vec3 s, sMin;\n  float dMin, d, a, b, w, drz;\n  dMin = dstFar;\n  a = dot (rd.xy, rd.xy);\n  b = dot (rd.xy, ro.xy);\n  w = b * b - a * (dot (ro.xy, ro.xy) - rad * rad);\n  if (w > 0. && a > 0.) {\n    d = - b - sqrt (w);\n    d /= a;\n    s = ro + d * rd;\n    if (d > 0. && abs (s.z) < len) {\n      dMin = d;\n      sMin = s;\n      qnHit = vec3 (s.xy, 0.);\n    } else {\n      drz = - len * sign (s.z);\n      ro.z += drz;\n      b = dot (rd, ro);\n      w = b * b - (dot (ro, ro) - rad * rad);\n      if (w > 0.) {\n        d = - b - sqrt (w);\n        if (d > 0.) {\n          s = ro + d * rd;\n          dMin = d;\n          sMin = s;\n          sMin.z -= drz;\n          qnHit = s;\n        }\n      }        \n    }\n  }\n  return vec4 (sMin, dMin);\n}\n\nmat3 EvalRMat (vec3 r, vec3 rp, vec3 rm)\n{\n  vec3 ddr, vt, vn;\n  vt = normalize (rp - rm);\n  ddr = rp + rm - 2. * r;\n  vn = normalize (ddr - vt * dot (vt, ddr));\n  return mat3 (vt, vn, cross (vt, vn));\n}\n\n#define NSEG_MAX  512.  // for tube: larger values, better but slower\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  mat3 rMat, rMatS;\n  vec4 ds4Min, ds4;\n  vec3 r, rp, qnHitS, qTube;\n  float dMin, d, dAng, eAng, len, jHit;\n  dAng = 2. * pi / nSeg;\n  dMin = dstFar;\n  if (! showBalls) {\n    ds4Min = vec4 (0., 0., 0., dMin);\n    eAng = 0.5 * dAng;\n  }\n  r = KtPoint (2. * pi - dAng);\n  for (float j = float (VAR_ZERO); j < NSEG_MAX; j ++) {\n    if (j == nSeg) break;\n    rp = r;\n    r = KtPoint (j * dAng);\n    if (showBalls) {\n      d = SphHit (ro - r, rd, 0.1);\n      if (d < dMin) {\n        dMin = d;\n        qnHitS = qnHit;\n        jHit = j;\n      }\n    } else {\n      rMat = EvalRMat (r, KtPoint (j * dAng + eAng), KtPoint (j * dAng - eAng));\n      len = 0.5 * length (r - rp);\n      ds4 = CapsHit (((ro - r) * rMat).yzx, (rd * rMat).yzx, 0.1, len);\n      if (ds4.w < ds4Min.w) {\n        ds4Min = ds4;\n        ds4Min.z /= len;\n        qnHitS = qnHit;\n        rMatS = rMat;\n        jHit = j;\n      }\n    }\n  }\n  if (showBalls) {\n    if (dMin < dstFar) {\n      qCol = 4. * jHit / nSeg;\n      qnHit = qnHitS;\n    }\n  } else {\n    if (ds4Min.w < dstFar) {\n      dMin = ds4Min.w;\n      qnHit = rMatS * normalize (qnHitS.zxy);\n      qTube = ds4Min.xyz;\n      qCol = 4. * (jHit + qTube.z + 0.5) / nSeg + atan (qTube.y, - qTube.x) / (2. * pi) +\n         0.2 * tCur;\n    }\n  }\n  return dMin;\n}\n\n// Knot parametrizations from A.K. Trautwein thesis (University of Iowa, 1995) (many more)\n\nvoid KtSetup ()\n{\n  for (int k = 0; k < 7; k ++) {\n    knc[k] = vec3 (0);  kns[k] = vec3 (0);\n  }\n  if (knType == 1) {  // 3.1 trefoil knot\n     knc[0] = vec3 ( 41,   36,   0);   kns[0] = vec3 (-18,   27,   45);\n     knc[1] = vec3 (-83, -113,  -30);  kns[1] = vec3 (-83,   30,  113);\n     knc[2] = vec3 (-11,   11,  -11);  kns[2] = vec3 ( 27,  -27,   27);\n     sclFac = 0.015;\n  } else if (knType == 2) {  // 4.1 figure 8 knot\n     knc[0] = vec3 (  32,   94,   16);  kns[0] = vec3 (-51,   41,   73);\n     knc[1] = vec3 (-104,  113, -211);  kns[1] = vec3 (-34,    0,  -39);\n     knc[2] = vec3 ( 104,  -68,  -99);  kns[2] = vec3 (-91, -124,  -21);\n     sclFac = 0.008;\n  } else if (knType == 3) {  // 5.1 knot\n     knc[0] = vec3 (  88,   89,   44);  kns[0] = vec3 ( 115,  -32,  -69);\n     knc[1] = vec3 (-475, -172,   34);  kns[1] = vec3 (-127,  294,  223);\n     knc[2] = vec3 ( -87,   76,   16);  kns[2] = vec3 (  36,  102,  120);\n     knc[3] = vec3 (  11,  -61,   42);  kns[3] = vec3 ( -19,  113, -125);\n     sclFac = 0.0045;\n  } else if (knType == 4) {  // 5.2 knot\n     knc[0] = vec3 ( -33,  -57,   34);  kns[0] = vec3 ( 43,   99, -21);\n     knc[1] = vec3 (   0,  -54, -100);  kns[1] = vec3 (214, -159, -93);\n     knc[2] = vec3 (-101, -117,  -27);  kns[2] = vec3 (-47,   -5, -16);\n     knc[3] = vec3 (   0,  -31,   52);  kns[3] = vec3 ( 11,  -45,  84);\n     sclFac = 0.008;\n  } else if (knType == 5) {  // granny knot\n     knc[0] = vec3 (-22,   0,  0);  kns[0] = vec3 (-128,   0,   0);\n     knc[1] = vec3 (  0, -10,  0);  kns[1] = vec3 (   0, -27,   0);\n     knc[2] = vec3 (-44,   0, 70);  kns[2] = vec3 ( -78,   0, -40);\n     knc[3] = vec3 (  0,  38,  0);  kns[3] = vec3 (   0,  38,   0);\n     sclFac = 0.016;\n  } else if (knType == 6) {  // square knot\n     knc[0] = vec3 ( -22,  11,   0);  kns[0] = vec3 (-128,   0,   0);\n     knc[2] = vec3 ( -44, -43,  70);  kns[2] = vec3 ( -78,   0, -40);\n     knc[4] = vec3 (   0,  34,   8);  kns[4] = vec3 (   0, -39,  -9);\n     sclFac = 0.016;\n  } else if (knType == 7) {  // 6.1 knot\n     knc[0] = vec3 (  12,   29,  -30);  kns[0] = vec3 ( 20,  78, -78);\n     knc[1] = vec3 (-163, -180, -111);  kns[1] = vec3 ( 76,  58,  37);\n     knc[2] = vec3 ( -87,   88,  -67);  kns[2] = vec3 (-15,  72, -51);\n     knc[3] = vec3 ( -21,    0,   31);  kns[3] = vec3 ( 14, -14,   8);\n     knc[4] = vec3 (  24,    0,  -11);  kns[4] = vec3 (-50,   0,  65);\n     sclFac = 0.008;\n  } else if (knType == 8) {  // 6.2 knot\n     knc[0] = vec3 (  -6,  -21,  -18);  kns[0] = vec3 (-21,  -24,  -13);\n     knc[1] = vec3 (-195, -207,  113);  kns[1] = vec3 ( 92,  -72, -107);\n     knc[2] = vec3 ( -64,  112,   86);  kns[2] = vec3 (-23,   -7,   -9);\n     knc[3] = vec3 (  -6,  -13,  -26);  kns[3] = vec3 ( 13,  -40,   -7);\n     knc[4] = vec3 (  24,  -27,   24);  kns[4] = vec3 ( 15,   -3,   33);\n     knc[5] = vec3 (   0,  -17,   21);  kns[5] = vec3 ( 41,    0,   31);\n     sclFac = 0.008;\n  } else if (knType == 9) {  // 6.3 knot\n     knc[0] = vec3 (-40,   90,  52);  kns[0] = vec3 ( 32,  89,  64);\n     knc[1] = vec3 ( 69, -142,  53);  kns[1] = vec3 (-12, 147,  35);\n     knc[2] = vec3 (120,   74,  77);  kns[2] = vec3 (-52,  85, -87);\n     knc[3] = vec3 (-56,    0, 101);  kns[3] = vec3 ( 46, -56, -19);\n     knc[4] = vec3 (  0,   23,  -5);  kns[4] = vec3 (-17,   0,   2);\n     knc[5] = vec3 ( 14,   16,   3);  kns[5] = vec3 ( 19,   7,   9);\n     sclFac = 0.008;\n  } else if (knType == 10) {  // 7.2 Knot\n     knc[0] = vec3 (  10, 42, 0);  kns[0] = vec3 (115, -104, 30);\n     knc[1] = vec3 (-184, -252,  20);  kns[1] = vec3 ( 10,  47,  19);\n     knc[2] = vec3 (   0,  -21,   6);  kns[2] = vec3 (101, -65, -31);\n     knc[3] = vec3 (  23,  -23,  -4);  kns[3] = vec3 ( 55, -23, -24);\n     knc[4] = vec3 ( -38,   36, -44);  kns[4] = vec3 ( -6, -10, -50);\n     knc[5] = vec3 ( -14,  -13,  31);  kns[5] = vec3 ( 8,    2,  39);\n     knc[6] = vec3 (  16,  -18, -16);  kns[6] = vec3 ( 14,  -9,  23);\n     sclFac = 0.007;\n  } else if (knType == 11) {  // 7.7 Knot\n     knc[0] = vec3 ( -5,   17, -28);  kns[0] = vec3 (  0,   21,   9);\n     knc[1] = vec3 (  8, -174, 110);  kns[1] = vec3 ( 83,   13,   4);\n     knc[2] = vec3 ( 87,  -15,  11);  kns[2] = vec3 (100,    3,  -6);\n     knc[3] = vec3 ( -5,   -9, -46);  kns[3] = vec3 ( 22,   46, -17);\n     knc[4] = vec3 (-10,   16,  32);  kns[4] = vec3 ( 10,  -25,  -9);\n     knc[5] = vec3 ( -2,  -21, -12);  kns[5] = vec3 (-10,    7,  -9);\n     knc[6] = vec3 (  5,   -9,  -9);  kns[6] = vec3 (  6,   -3,  18);\n     sclFac = 0.01;\n  }\n}\n\nvec3 BgCol (vec3 rd)\n{\n  return vec3 (0.3, 0.3, 0.35) * (0.5 + 0.2 * rd.y);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float dstObj, nDotL;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = qnHit;\n    nDotL = max (dot (vn, ltDir), 0.);\n    if (showBalls) nDotL *= nDotL;\n    else vn = VaryNf (32. * ro, qnHit, 0.2);\n    col = HsvToRgb (vec3 (mod (qCol, 1.), 0.6 , 1.)) * (0.3 + 0.7 * nDotL);\n  } else col = BgCol (rd);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 rd, ro, col;\n  vec2 canvas, uv;\n  float az, el, zmFac, sr, asp, t;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  knType = 1 + int (mod (floor (0.1 * tCur), nKnot));\n  showBalls = false;\n  az = 0.;\n  el = 0.;\n  zmFac = 6.;\n  if (mPtr.z > 0.) {\n    if (abs (mPtr.x) > 0.47) {\n      knType = 1 + int (mod ((mPtr.y + 0.5) * nKnot, nKnot));\n      showBalls = (mPtr.x < 0.);\n    } else {\n      az += 2. * pi * mPtr.x;\n      el += pi * mPtr.y;\n      showBalls = (mPtr.y > 0.);\n      zmFac += abs (az);\n    }\n  } else {\n    t = floor (0.6 * tCur) + smoothstep (0., 0.3, mod (0.6 * tCur, 1.));\n    az = 0.2 * t;\n    el = 0.23 * t;\n    showBalls = (mod (0.1 * tCur, 1.) < 0.5);\n  }\n  vuMat = StdVuMat (el, az);\n  nSeg = showBalls ? 128. : NSEG_MAX;\n  KtSetup ();\n  ro = vuMat * vec3 (0., 0., -20.);\n  dstFar = 50.;\n  ltDir = vuMat * normalize (vec3 (0.3, 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  if (abs (uv.x) < ((zmFac == 6.) ? 1. : asp)) {\n    col = vec3 (0.);\n    sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n    for (float a = float (VAR_ZERO); a < naa; a ++) {\n      rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n         sr * (0.667 * a + 0.5) * pi), zmFac));\n      col += (1. / naa) * ShowScene (ro, rd);\n    };\n  } else {\n    col = BgCol (vuMat * normalize (vec3 (uv, zmFac)));\n  }\n  if (mPtr.z > 0. && abs (uv.x) > 0.94 * asp) col = vec3 (0.3, 0.3, 0.);\n  fragColor = vec4 (col, 1.);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. -\n     3.) - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdVXWc.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[121, 827, 851, 851, 1095], [1097, 1097, 1141, 1141, 1377], [1379, 1379, 1434, 1434, 2168], [2170, 2170, 2212, 2212, 2373], [2446, 2446, 2479, 2479, 3754], [3756, 3848, 3865, 3865, 8335], [8337, 8337, 8359, 8359, 8414], [8416, 8416, 8451, 8451, 8836], [8838, 8838, 8894, 8894, 10592], [10594, 10594, 10624, 10624, 10737], [10739, 10739, 10775, 10775, 10981], [10983, 10983, 11007, 11007, 11129], [11163, 11163, 11187, 11187, 11299], [11301, 11301, 11326, 11326, 11512], [11514, 11514, 11543, 11543, 11755], [11757, 11757, 11796, 11796, 12048]]}
{"id": "fdVXWR", "name": "SolidTux - Newton Fractal Color", "author": "SolidTux", "description": "Newton fractal for 4th order polynomial with coloring according to argument of result. Drag mouse to set 4th point.", "tags": ["fractal"], "likes": 4, "viewed": 80, "published": "Public", "date": "1634473440", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define N 4\n#define ITER 6\n#define ITERNORM 5\n#define PI 3.1415926535897932384626433832795028841971693993751058209749445923\n\nvec2 conj(in vec2 a) {\n    return vec2(a.x, -a.y);\n}\n\nvec2 cmul(in vec2 a, in vec2 b) {\n    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\nvec2 cdiv(in vec2 a, in vec2 b) {\n    return cmul(a, conj(b))/(b.x*b.x + b.y*b.y);\n}\n\nvec2 p(in vec2 z, in vec2[N] points) {\n    vec2 res = vec2(1., 0.);\n    for (int i=0; i<N; i++) {\n        res = cmul(res, z - points[i]);\n    }\n    return res;\n}\n\nvec2 pd(in vec2 z, in vec2[N] points) {\n    vec2 res = vec2(0., 0.);\n    for (int i=0; i<N; i++) {\n        vec2 tmp = vec2(1., 0.);\n        for (int j=0; j<N; j++) {\n            if (i!=j) {\n                tmp = cmul(tmp, z - points[j]);\n            }\n        }\n        res += tmp;\n    }\n    return res;\n}\n    \n\nvec2 newton(in vec2 z, in vec2[N] points) {\n    return z - cdiv(p(z, points), pd(z, points));\n}\n\nvec2 s(in vec2 x) {\n    vec2 z = 2.*(x/iResolution.xy - 0.5);\n    z.x *= iResolution.x/iResolution.y;\n    z *= mix(0.5, 1., 0.5*(sin(iTime) + 1.));\n    return z;\n}\n\nvec3 huergb(in float hue) {\n    vec3 color;\n    float h = mod(hue, 1.);\n    float f = mod(6. * h, 1.);\n    if (6. * h < 1.)\n    {\n        color = vec3(1., f, 0.);\n    } else if (6. * h < 2.)\n    {\n        color = vec3(1. - f, 1., 0.);\n    } else if (6. * h < 3.)\n    {\n        color = vec3(0., 1., f);\n    } else if (6. * h < 4.)\n    {\n        color = vec3(0., 1. - f, 1.);\n    } else if (6. * h < 5.)\n    {\n        color = vec3(f, 0., 1.);\n    } else\n    {\n        color = vec3(1., 0., 1. - f);\n    }\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 z = s(fragCoord);\n    \n    // points and colors\n    vec2 points[N];\n    points[0] = vec2(sin(2.02*iTime), 0.62*cos(1.2*iTime)) + vec2(0.1, 2.);\n    points[1] = vec2(-1.76*sin(0.3*iTime), 1.3*cos(1.01*iTime)) + vec2(-0.7, 0.1);\n    points[2] = vec2(1.33*sin(1.02*iTime), -0.3*cos(1.7*iTime)) + vec2(0.3, -0.12);\n    if (iMouse.z > 0.) {\n        points[3] = s(iMouse.xy);\n    } else {\n        points[3] = vec2(0.11*sin(1.31*iTime), 0.05*cos(0.72*iTime)) + vec2(1.31, 0.1);\n    }\n    \n    // iterations\n    float dis = 2.;\n    float scale = 1.;\n    for (int i=0; i<ITER; i++) {\n        z = newton(z, points);\n        for (int i=0; i<N; i++) {\n            float cur = length(z - points[i]);\n            if (cur < dis) {\n                dis = cur;\n            }\n        }\n        if (dis < 0.05) {\n            scale = mix(0.1, 1., float(clamp(i, 0, ITERNORM-1))/float(ITERNORM-1));\n            break;\n        }\n    }\n    \n    // set color\n    float r = length(z);\n    float phi = 0.5*(1.+atan(z.y, z.x)/PI);\n    vec3 col = scale * huergb(phi);\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdVXWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[125, 125, 147, 147, 177], [179, 179, 212, 212, 269], [271, 271, 304, 304, 355], [357, 357, 395, 395, 518], [520, 520, 559, 559, 825], [832, 832, 875, 875, 927], [929, 929, 948, 948, 1092], [1094, 1094, 1121, 1121, 1615], [1617, 1617, 1672, 1672, 2753]]}
{"id": "fdVXzR", "name": "dither experiment w/ ball cycles", "author": "wnu", "description": "dither dithering from https://www.shadertoy.com/view/3ljXWK\n\nmove with mouse", "tags": ["dither"], "likes": 6, "viewed": 79, "published": "Public", "date": "1634257667", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R iResolution.xy\n#define PI 3.1415926\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\nmat2 rot(float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\n\nfloat random(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvec2 camera2D (vec2 uv) {\n    vec2 mouse = iMouse.xy/iResolution.xy*2.-1.;\n    vec3 p = vec3(uv,0);\n    if (iMouse.z > 0.5) {\n        p.yz *= rot(mouse.y*3.1415/2.);\n        p.xz *= rot(mouse.x*3.1415/2.);\n    }\n    return p.xy/(1.+p.z);\n}\n\nvec2 camera2D (vec3 p) {\n    vec2 mouse = iMouse.xy/iResolution.xy*2.-1.;\n    //vec3 p = vec3(uv,0);\n    if (iMouse.z > 0.5) {\n        p.yz *= rot(mouse.y*3.1415/2.);\n        p.xz *= rot(mouse.x*3.1415/2.);\n    }\n    return p.xy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n    vec2 uv = (fragCoord - .5*R.xy)/R.y;\n    \n    uv *= 5.;\n    //uv.y -= 0.3;\n    \n    \n    //mat4 rota = rotationMatrix(vec3(0.,1.,1.),uv.x);\n    mat4 rota2 = rotationMatrix(vec3(0.,1.,1.),iTime/2.+PI/4.+ uv.x*uv.y); \n    //could make a for loop in the for loop below to make arbitrary amounts of disconnects\n    \n\n    vec3 col = vec3(0.);\n    //vec2 gv = fract(uv)-0.5;\n    int nI = 20;\n    float nF = float(nI);\n    for(int i = 0;i<nI;i++){\n        float seg = float(i)/nF + 1.*random(uv+1.*fract(iTime))/nF;\n        float inc = 2.*PI*seg;\n        float t = iTime*2. + inc;\n        \n        float rotInd = step(0.5,seg);\n        vec3 pos = vec3(sin(t*1.),cos(1.*t),0.);\n        \n        mat4 rota = rotationMatrix(vec3(0.,1.,1.),pos.x*pos.y+cos(inc));\n        mat4 rota3 = rotationMatrix(vec3(1.,0.,0.),1.*-PI/4.);\n        pos = (rota*vec4(pos,1.)).xyz;\n        vec3 pos2 = (rota2*vec4(pos,1.)).xyz;\n        //pos = mix(pos,pos2,rotInd);\n        \n        \n        vec2 p2 = camera2D(pos.yz);\n        vec2 p3 = camera2D(pos.xyz);\n        //float d = length(uv + p2);\n        float d = length(uv + p3);\n        float s = smoothstep(0.,1.,d);\n        //float d = length(uv + pos.yz);\n        //float d = length((uv + pos.yz)/(1.+pos.x));\n        float m = 0.2*pow(d,-1.)/nF;\n        //col += m;\n        float c = mod(floor(seg*nF),2.)/3.;\n        vec3 addCol = hsl2rgb(vec3(c+0.2 + iTime/10.,0.3+1.*(cos(iTime/2.+PI/2.)+1.)/2.*0.8,m));\n        col = max(addCol,col)+ addCol*1.;\n    }\n    \n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdVXzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 92, 92, 720], [721, 721, 740, 740, 790], [792, 792, 814, 814, 902], [904, 904, 931, 931, 1074], [1076, 1076, 1101, 1101, 1315], [1317, 1317, 1341, 1341, 1548], [1550, 1550, 1607, 1607, 3142]]}
{"id": "fdySDh", "name": "Desert mesas v2", "author": "jarble", "description": "A desert terrain based on zchajax's [url=https://www.shadertoy.com/view/3dXcW2]\"simple terrain\"[/url] shader.", "tags": ["terrain", "fbm", "mountain", "desert", "erosion", "mesa"], "likes": 3, "viewed": 135, "published": "Public API", "date": "1634523358", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SC (250.0)\n\nvec2 noise(in vec2 uv)\n{\n    //return sin(uv.x/1.6)+cos(-uv.y*1.6);\n    return vec2(sin(uv.x),cos(uv.y))+vec2(1.);\n}\n\n#define OCTAVES 8\nfloat fbm1(in vec2 uv,int octaves,float i1,float value1)\n{\n    //this function generates the terrain height\n    float value = value1;\n    float amplitude = .5/i1;\n    float freq = i1/2.;\n    float n1 = 0.;\n    vec2 noise2;\n    for (int i = 0; i < octaves; i++)\n    {\n        \n        \n        noise2 = noise(noise2.yx+uv/(freq));\n        vec2 noise1 = noise2-value;\n        freq /= 2.15;\n        n1 = noise1.x+noise1.y;\n\n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        value += n1 * (amplitude-freq);\n        //value += n1/freq;\n        \n        amplitude *= -amplitude;\n        uv += (noise2.yx+n1*freq)*freq;\n        \n\n        //uv += (noise1+vec2(1.))/freq;\n        //uv1 = uv*freq;\n\n        //uv = uv.yx;\n    }\n    \n    return -value;\n}\n\nfloat fbm(vec2 uv, int oct){\n    float result = 0.;\n    for(float i = 1.; i < 3.; i++){\n        float i1 = i*i;\n        result += fbm1(uv,oct,i1,result/i1);\n        oct -= 2;\n    }\n    return result/4.;\n}\n\nfloat fbm(in vec2 uv){\n    return fbm(uv,OCTAVES);\n}\n\nfloat f(in vec3 p,int iters)\n{   \n    float h = fbm(p.xz,iters);\n    return h;\n}\n\nfloat f(in vec3 p)\n{   \n    float h = fbm(p.xz,OCTAVES+4);\n    return h;\n}\n\nvec3 getNormal(vec3 p, float t)\n{\n    vec3 eps=vec3(.001 * t, .0, .0);\n    vec3 n=vec3(f(p - eps.xyy) - f(p + eps.xyy),\n                2. * eps.x,\n                f(p - eps.yyx) - f(p + eps.yyx));\n  \n    return normalize(n);\n}\n\nfloat rayMarching(in vec3 ro, in vec3 rd, float tMin, float tMax)\n{\n    float t = tMin;\n\tfor( int i = 0; i < 300; i++ )\n\t{\n        vec3 pos = ro + t * rd;\n\t\tfloat h = pos.y - f(pos,OCTAVES);\n\t\tif( abs(h) < (0.0015 * t) || t > tMax ) \n            break;\n\t\tt += 0.4 * h;\n\t}\n\n\treturn t;\n}\n\n/*\n//raymarching with LOD\nfloat rayMarching(in vec3 ro, in vec3 rd, float tMin, float tMax)\n{\n    float t = tMin;\n    int oct = 2;\n\tfor( int i = 0; i < 300; i++ )\n\t{\n        vec3 pos = ro + t * rd;\n\t\tfloat h = pos.y - f(pos,OCTAVES);\n\t\tif( abs(h) < (0.0015 * t) || t > tMax ) \n            if(oct < 8) oct += 2;\n            else break;\n\t\tt += 0.4 * h;\n\t}\n\n\treturn t;\n}\n*/\n\nvec3 lighting(vec3 p, vec3 normal, vec3 L, vec3 V)\n{\n    vec3 sunColor = vec3(1., .956, .839);\n    vec3 albedo = vec3(1.);\n   \tvec3 diff = max(dot(normal, L) * albedo, 0.);\n    \n    vec3 refl = normalize(reflect(L, normal));\n    float spec = max(dot(refl, -normalize(V)), 0.);\n    spec = pow(spec, 18.);\n    spec = clamp(spec, 0., 1.);\n    float sky = max(0.0, dot(vec3(0.,1.,0.), normal));\n    \n    //float amb = 0.5 * smoothstep(0.0, 2.0, p.y);\n    \n    vec3 col = diff * sunColor;\n    col += spec * sunColor;\n    col += sky * vec3(0., .6, 1.) * .1;\n    //col += amb * .2;\n    \n   \treturn col;\n}\n\nmat3 lookAt(vec3 origin, vec3 target, float roll)\n{\n    vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n    vec3 ww = normalize(target - origin);\n    vec3 uu = normalize(cross(ww, rr));\n    vec3 vv = normalize(cross(uu, ww));\n\n    return mat3(uu, vv, ww);\n}\n\nvec3 camerapath(float t)\n{\n    vec3 p=vec3(-13.0+3.5*cos(t),3.3,-1.1+2.4*cos(2.4*t+2.0));\n\treturn p;\n}\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\t\n    vec3 lightDir = normalize(vec3(0., 1., -1.));\n    \n    vec3 camStep = vec3(-1., 0., 0.) * (iTime+12.)/4.;\n    vec3 camPos = vec3(8., 2., 5.) + camStep;\n    vec3 camTarget = vec3(1., 1., 4.) + camStep;\n\n    \n    mat3 mat = lookAt(camPos, camTarget, 0.0);\n    \n    vec3 ro = camPos;\n    ro.y += fbm(ro.xz,OCTAVES)-1.8;\n\n    vec3 rd = normalize(mat * vec3(uv.xy, 1.0));\n        \n    if (length(iMouse.xy) > 40.0) {\n        rd.yx *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        rd.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n\n    \n    float tMin = .1;\n    float tMax = 20.;\n    float t = rayMarching(ro, rd, tMin, tMax);\n    \n    vec3 col = vec3(0.);\n    \n    if (t > tMax)\n    {\n        // from iq's shader, https://www.shadertoy.com/view/MdX3Rr\n        float sundot = clamp(dot(rd, lightDir), 0.0, 1.0);\n        col = vec3(0.3,0.5,0.85) - rd.y*rd.y*0.5;\n        col = mix( col, 0.85*vec3(0.7,0.75,0.85), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n        // sun\n\t\tcol += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n\t\tcol += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n\t\tcol += 0.2*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );\n        // clouds\n\t\tvec2 sc = ro.xz + rd.xz*(SC*1000.0-ro.y)/rd.y;\n\t\tcol = mix( col, vec3(1.0,0.95,1.0), 0.5*smoothstep(0.5,0.8,fbm(0.0005*sc/SC)) );\n        // horizon\n        col = mix( col, 0.68*vec3(0.4,0.65,1.0), pow( 1.0-max(rd.y,0.0), 16.0 ) );\n    }\n    else\n    {\n        vec3 p = ro + rd * t;\n        vec3 normal = getNormal(p, t);\n        vec3 viewDir = normalize(ro - p);\n        \n        // lighting terrian\n        col = lighting(p, normal, lightDir, viewDir);\n        \n        // fog\n        float fo = 1.0-exp(-pow(30. * t/SC,1.5) );\n        vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n        col = mix( col, fco, fo);\n    }\n    \n    // Gama correction\n    col = pow(clamp(col, 0., 1.), vec3(.45)); \n    \n    fragColor = vec4(vec3(col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdySDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 44, 87, 136], [156, 156, 214, 263, 929], [931, 931, 959, 959, 1135], [1137, 1137, 1159, 1159, 1189], [1191, 1191, 1221, 1221, 1271], [1273, 1273, 1293, 1293, 1347], [1349, 1349, 1382, 1382, 1576], [1578, 1578, 1645, 1645, 1863], [1865, 2237, 2289, 2289, 2834], [2836, 2836, 2887, 2887, 3088], [3090, 3090, 3116, 3116, 3192], [3260, 3260, 3317, 3317, 5264]]}
{"id": "fdySWW", "name": "earth ship 2d", "author": "jorge2017a2", "description": "earth ship 2d", "tags": ["earthship2d"], "likes": 0, "viewed": 104, "published": "Public API", "date": "1634607945", "time_retrieved": "2021-10-01T00:00:00", "image_code": "///earth ship 2d- por-JFP\n///por jorge2017a2...2021-oct-18\n///referencia\n//https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(antialiasing(0.05),b,d)\n\n///---------------------------\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n    \nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  //colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.05,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.05,0.0));\n  return colOut;\n}\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n    return colOut;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{   vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{   p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdParallelogram( in vec2 p, float wi, float he, float sk )\n{   vec2 e = vec2(sk,he);\n    p = (p.y<0.0)?-p:p;\n    vec2  w = p - e; w.x -= clamp(w.x,-wi,wi);\n    vec2  d = vec2(dot(w,w), -w.y);\n    float s = p.x*e.y - p.y*e.x;\n    p = (s<0.0)?-p:p;\n    vec2  v = p - vec2(wi,0); v -= e*clamp(dot(v,e)/dot(e,e),-1.0,1.0);\n    d = min( d, vec2(dot(v,v), wi*he-abs(s)));\n    return sqrt(d.x)*sign(-d.y);\n}\n\nvec3 Cielo(vec2 p, vec3 col)\n{  col=DrawFig(vec3(0.2,0.0,0.3), col, -p.y+3.5 );\n return col;\n}\n\nvec3 colina(vec2 p, vec3 col)\n{   p.x=opRep1D(p.x, 8.5 );\n    float d1= sdTriangleIsosceles(vec2(p.x,-p.y+0.5), vec2(4.0,2.0) );\n    col=DrawFigBordeCol(vec3(0.3), col, d1 , vec3(0.35));\n    return col;\n}\n\nvec3 columna2(vec2 p, vec3 col)\n{   //esta funcion se puede mejorar....solo con usar la funcion  DrawFigBordeCol\n    // y asi se eliminan funciones ...ver la nave\n    float d1= sdTrapezoid( vec2(p.x, -p.y), 1.2, 1.5, 0.5 );\n    float d2= sdTrapezoid( vec2(p.x, -p.y)-vec2(-0.5,0.0), 0.5, 0.8, 0.4 );\n    float d3=sdParallelogram(vec2(p.x,-p.y)-vec2(0.8,0.0), 0.4, 0.4, 0.15 );    \n    float d4=sdBox(p-vec2(-0.5,-3.0), vec2(0.9,2.5) );\n    float d5=sdBox(p-vec2(0.9,-3.0), vec2(0.55,2.5) );\n    float d4a=sdBox(p-vec2(-0.5,-2.9), vec2(0.8,2.4) );\n    float d5a=sdBox(p-vec2(0.9,-2.9), vec2(0.4,2.4) );\n    //parte inferior\n    float d6= sdTrapezoid( vec2(p.x, -p.y)-vec2(-0.5,5.8), 0.8, 1.4, 0.5 );\n    float d7=sdParallelogram(vec2(p.x,-p.y)-vec2(1.25,5.85), 0.65, 0.45, 0.25 );    \n    float d6a= sdTrapezoid( vec2(p.x, -p.y)-vec2(-0.5,5.8), 0.6, 1.2, 0.35 );\n    float d7a=sdParallelogram(vec2(p.x,-p.y)-vec2(1.2,5.8), 0.5, 0.3, 0.25 );    \n    \n    col=DrawFig(vec3(1.0), col, d1);\n    col=DrawFig(vec3(0.0), col, d2);\n    col=DrawFig(vec3(0.0), col, d3);\n    col=DrawFig(vec3(1.0), col, d4);\n    col=DrawFig(vec3(1.0), col, d5);\n    col=DrawFig(vec3(0.0), col, d4a);\n    col=DrawFig(vec3(0.0), col, d5a);\n    col=DrawFig(vec3(1.0), col, d6);\n    col=DrawFig(vec3(1.0), col, d7);\n    col=DrawFig(vec3(0.0), col, d6a);\n    col=DrawFig(vec3(0.0), col, d7a);\n    return col;\n}\n\n\nvec3 Nave(vec2 p, vec3 col)\n{   float d1= sdTriangleIsosceles(vec2(p.x, -p.y), vec2(1.0,1.0) );\n    float d2=sdParallelogram(vec2(p.x,-p.y)-vec2(1.1,0.5), 0.5, 0.5, 0.45 );    \n    float d3=sdParallelogram(vec2(p.x,-p.y)-vec2(2.1,0.5), 0.5, 0.5, 0.45 );    \n    float d4= sdBox(p-vec2(1.0,-1.5), vec2(2.0,0.5) );\n    float d5= sdTrapezoid( vec2(p.x, -p.y)-vec2(1.1,2.4), 2.0, 1.5, 0.35 );\n    col=DrawFigBordeCol(vec3(0.0),col,d1,vec3(1.0));\n    col=DrawFigBordeCol(vec3(0.0),col,d2,vec3(1.0));\n    col=DrawFigBordeCol(vec3(0.0),col,d3,vec3(1.0));\n    col=DrawFigBordeCol(vec3(0.0),col,d4,vec3(1.0));\n    col=DrawFigBordeCol(vec3(0.0),col,d5,vec3(1.0));    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    vec3  col=vec3(0.5)-uv.y*0.125;\n    uv*=8.0;\n    vec2 uv1=uv;\n    \n    uv1.x= opRep1D(uv1.x-5.0+iTime*5.0, 25.0 );\n    col= Cielo(uv, col);\n    col=colina(uv1-vec2(0.0,5.0), col);\n    col=columna2(uv1*2.0-vec2(10.0,12.0), col);\n    col=columna2(uv1*1.5-vec2(5.0,5.0), col);\n    col=columna2(uv1*1.5-vec2(15.0,6.0), col);\n    col= Nave(uv-vec2(0.0,1.0+2.0*sin(iTime*0.5)),col);\n    col=columna2(uv1, col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdySWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[312, 343, 379, 379, 424], [429, 473, 520, 520, 547], [548, 548, 591, 591, 618], [619, 619, 667, 667, 695], [701, 701, 763, 763, 959], [961, 961, 1042, 1042, 1169], [1171, 1171, 1228, 1228, 1298], [1300, 1300, 1337, 1337, 1415], [1416, 1416, 1441, 1441, 1460], [1462, 1462, 1513, 1513, 1819], [1821, 1821, 1886, 1886, 2196], [2198, 2198, 2264, 2264, 2604], [2606, 2606, 2636, 2636, 2700], [2702, 2702, 2733, 2733, 2906], [2908, 2908, 2941, 3070, 4285], [4288, 4288, 4317, 4317, 4963], [4965, 4965, 5022, 5022, 5558]]}
{"id": "fdyXDR", "name": "Octree Basic [Commented]", "author": "Yusef28", "description": "First Octree Shader\nHere is a lightly stylized version with comments on lighting and coloring\nhttps://www.shadertoy.com/view/NdGXWh", "tags": ["3d", "raymarching", "raycasting", "voxel", "quadtree", "octree"], "likes": 11, "viewed": 195, "published": "Public API", "date": "1634534575", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//////////////////////////////////////////////////////\n// Octree Basic [Commented] By Yusef28\n// Purpose: Demonstrates A simplified Octree Shader Implentation\n// Well commented and fit for some educational purposes\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//And a lightly stylized version can be found here:\n//https://www.shadertoy.com/view/NdGXWh\n\n/* \n\nNotably, the first octree shaders I stumbled on were from abje\nalthough it seems they are using a different approach.\nHere is the main one: https://www.shadertoy.com/view/4sVfWw\nHere is one with lighting and shadow: https://www.shadertoy.com/view/XdyfRy\n\nMy version is \"stackless\" there is no bidiretional movement\nbetween levels of the tree. We always start at the top and\nwe get spit out somewhere along the way down. \n\nSo for each step in our traversal we have to jump into the tree\nfrom the top again and work down to get the next cell scale factor.\n\nWith a stack and with bidirectional movement I'm guessing\nyou don't have to leave the tree between steps, you just swing\nfrom vine to vine. Not completely sure yet though.\n\n***************************************************\nThe code for this 3D Octree is shorter than for\nthe 2D Quadtree it's based on! https://www.shadertoy.com/view/7dVSRh\nMainly because I draw lines and cirles in that one though and\nit could be more concise.\n\n*****************************************************\nIssues I ran into while writing this where I had to just\nuse intuition and play around with things until things worked out\n\nInitially:\nI found the ray origin needed to be shifter by epsilon\nto avoid really bad artifacts\n\nCurrently:\nI found the t value returned from tCalc() need to have epsilon\nadded to it to avoid really bad artifacts\n\nCurrently:\nthe value FAR needs to be atleast 100 or we get some\nweird cloud things that arn't clouds at all.\n\nFixed:\nI needed a way to create a hole where the camera would \nbe with out any octree cells being rendered and\n\n\n*/\n\n\n#define pi acos(-1.)\n#define eps 1./iResolution.y\n#define MAX_LEVEL 8.\n#define FAR 100.\n\n\n//Rotation matrix for the ray direction \nmat2 rot(float a){\n    float c = cos(a), s = sin(a); return mat2(c,-s,s,c);}\n    \n\n//  1 out, 3 in... from dave hoskins for the quad/octree\nfloat hash13(vec3 p3)\n{\n\tp3 = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n\n// SHORTER, NEATER, BRANCHLESS, UNIQUE, SINGULAR PURPOSE\n// This quad/octree map function returns the largest scaling factor \n//for a given posision\n// the inverse of that is the cell size\nfloat mapQ(vec3 p){\n  float s = 0.5;\n  for(float i = 1.; i < MAX_LEVEL; i++){\n    s *= 2.;\n    //if we don't pass the random check, add max to index so we break\n    i += step( hash13(floor(p * s)), 0.5 ) * MAX_LEVEL;\n  }\n  return s;\n}\n\n//This DDA algo is based on the lodev Raycasting tutorial\n// https://lodev.org/cgtutor/raycasting.html\n//and the modification is from my quadtree traversal\n//shader: https://www.shadertoy.com/view/7dVSRh\n//I explain the idea in the comments.\n//basically though we find the first axis the ray will \n//hit when traveling in the ray direction and return the \n//distance to that axis.\n//Firsst we get the \"scale factor\" from the qaudtree map so\n//we know what size box we are in. Then we find our distances\n//for each axis and return the smallest. More detail is given in\n//the link above.\nfloat calcT(vec3 p, vec3 rd, vec3 delta){\n    float s = mapQ(p);\n    vec3 t;\n    \n    t.x = rd.x < 0. ? ((p.x*s - floor(p.x*s))/s)*delta.x\n                    : ((ceil(p.x*s) - p.x*s)/s)*delta.x; \n                    \n    t.y = rd.y < 0. ? ((p.y*s - floor(p.y*s))/s)*delta.y\n                    : ((ceil(p.y*s) - p.y*s)/s)*delta.y; \n    \n    t.z = rd.z < 0. ? ((p.z*s - floor(p.z*s))/s)*delta.z\n                    : ((ceil(p.z*s) - p.z*s)/s)*delta.z; \n\n                    //+0.01 to get rid of a bunch of artifacts\n    return min(t.x,min(t.y,t.z))+0.001;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    \n    \n    //This is the canonical orthonormal basis for a camera \n    //ray in the uv plane. \n    vec3 fwd = vec3(0.,0.,1.);\n    vec3 up = vec3(0.,1.,0.);\n    vec3 right = normalize(cross(up,fwd));\n    up = cross(fwd,right);\n    vec3 ro = vec3(0., iTime/6.,0.);\n    vec3 rd = right*uv.x + up*uv.y + fwd;\n    rd = normalize(rd);\n    \n    //rotating the raydirection to look around.\n    rd.xz *= rot(iTime/6.);\n    \n    //get the delta which is explained in the lodev tutorial\n    //on raycasting: https://lodev.org/cgtutor/raycasting.html\n\tvec3 delta = 1./max(abs(rd), eps);\n    float t = 0.;\n    \n    //It all comes together in this small iteration loop.\n    //We are updating t just like in raymarching.\n    //The only \"sdf\" we use though is the \"hole\" rect tunnel\n    //We only render a block if our hash returns < 0.4 AND\n    // the hit point of the block is outside of the sdf (hole > 0.001)\n    for(float i = 0.; i < FAR; i++){\n        vec3 pos = ro + rd * t;\n        float ss = mapQ(pos);\n\n        //create the hole / shield so blocks stop\n        //hitting me in the face\n        vec3 shi = abs(floor(pos-ro)) - 1.;\n        //the hole. Basically a vertical rectangular/square tunnel\n        float hole = max( shi.x, shi.z);\n        \n        //n = calcN(pos, rd, delta);\n        //check the hole AND check the random missing squares\n        //if we are out of the hole AND not hitting a missint square\n        //then break!\n        if(hole > 0.001 && hash13(floor((pos)*ss)) > .4) break;\n        \n        //updating t with the modified DDA algo.\n        t += calcT(pos, rd, delta);\n    }\n    \n    fragColor = vec4(pow(vec3(clamp(1.-t/7.,0.,1.))*1.3,vec3(4.)),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdyXDR.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[2098, 2139, 2157, 2157, 2215], [2222, 2279, 2302, 2302, 2404], [2408, 2597, 2616, 2616, 2831], [2833, 3419, 3460, 3460, 3977], [3980, 3980, 4037, 4084, 5819]]}
{"id": "fdyXDW", "name": "jneen - hexel test 1", "author": "jneen", "description": "start by getting the coordinate system right. apparently matrix mulitplication is reversed in glsl? who knew", "tags": ["hexel"], "likes": 5, "viewed": 92, "published": "Public", "date": "1634614372", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// via https://www.redblobgames.com/grids/hexagons/#pixel-to-hex\nmat2 hexel = mat2(2.,0.,-1.,sqrt(3.))/3.;\nmat2 pixel = mat2(3.,0.,sqrt(3.),2.*sqrt(3.))/2.;\n\nfloat zz = 0./0.;\n\nvec3 to_cubic(vec2 p) { return vec3(p.x,-p.x-p.y,p.y); }\nvec2 from_cubic(vec3 p) { return p.xz; }\n\n// glsl-ized from https://www.redblobgames.com/grids/hexagons/#rounding\nvec3 round_cubic(vec3 p) {\n  vec3 r = round(p);\n\n  vec3 diff = abs(r-p);\n  vec3 alt = -r.yzx-r.zxy;\n  \n  float biggest = max(diff.x,max(diff.y,diff.z));\n\n  return mix(r, alt, step(biggest, diff));\n}\n\nfloat cube_len(vec3 c) {\n  vec3 d = abs(c);\n  return (d.x+d.y+d.z)/2.;\n}\n\n#define nsin(X) (.5+.5*sin(6.283*(X)))\n\nvec3 px_to_cube(float res, vec2 p) {\n  return round_cubic(to_cubic(res * p * hexel))/res;\n}\n\nvec2 cube_to_px(vec3 c) {\n  return c.xy * pixel;\n}\n\nmat2 rot(float T){float s=sin(T),c=cos(T);return mat2(c,s,-s,c);}\n\nfloat warp(vec3 c) {\n  float F = 10.+10.*nsin(iTime*.02);//+40.*nsin(iTime*.01);\n\n  c *= F;\n\n  vec2 p = cube_to_px(c);\n  \n  p*=rot(.3*iTime);\n  vec3 c2 = px_to_cube(1., p);\n  vec3 ta = tan(c2);\n  float w = length(ta);//(ta.x+ta.y-ta.z);//(pow(tan(p.x),2.)-pow(tan(p.y),2.));\n  return .05*w*w;//1./(1.-w);\n#if 0\n  float F = 3.+30.*nsin(.1*iTime);\n  c *= F;\n  vec3 t=tan(c);\n  \n  float w = (t.x*t.x+t.y*t.y+t.z*t.z)/F;\n  return 1./(1.+w);\n  \n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -=.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    uv *= rot(.3*iTime);\n    vec3 qr = px_to_cube(50.+10.*nsin(.4*iTime),uv);\n    vec3 C = vec3(warp(qr));\n    //C = vec3(nsin(iTime*.3+qr.xy),0.);\n    fragColor = vec4(C,0.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdyXDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 177, 200, 200, 233], [234, 234, 259, 259, 274], [276, 348, 374, 374, 546], [548, 548, 572, 572, 620], [662, 662, 698, 698, 753], [755, 755, 780, 780, 805], [807, 807, 825, 825, 872], [874, 874, 894, 894, 1322], [1324, 1324, 1381, 1431, 1708]]}
{"id": "fdyXR3", "name": "Androids marching", "author": "boldo", "description": "raymarching Androids. Use Mouse to move camera around :) \nHave fun.", "tags": ["raymarching"], "likes": 2, "viewed": 46, "published": "Public", "date": "1635159689", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define MAX_STEPS 100\n#define MAX_DIST 50.\n#define SURF_DIST .001\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    return length(p-c)-r;\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i;\n}\n\nfloat sdTorus(vec3 p, vec2 r) {\n\tfloat x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat sdCappedCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n  vec3  ba = b - a;\n  vec3  pa = p - a;\n  float baba = dot(ba,ba);\n  float paba = dot(pa,ba);\n  float x = length(pa*baba-ba*paba) - r*baba;\n  float y = abs(paba-baba*0.5)-baba*0.5;\n  float x2 = x*x;\n  float y2 = y*y*baba;\n  float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n  return sign(d)*sqrt(abs(d))/baba;\n}\n\nvec4 opUnionColor(vec4 a, vec4 b) {\n    return (a.w<b.w) ? a : b;\n}\n\nvec4 GetDist(vec3 p) {\n    float plane = p.y;\n    //float box = sdBox(p-vec3(0,1,0), vec3(1));\n    float d = MAX_DIST;\n    \n    p += vec3(0.,0.,-4) * fract(iTime * 0.1);\n    \n    vec3 c = vec3(4.,0,4.);\n    p = mod(p+0.5*c,c)-0.5*c;\n    \n    //legs\n    {\n        float angleL = sin(3.14 + iTime * 3.) * 0.9 + 1.8f;\n        float angleR = sin(       iTime * 3.) * 0.9 + 1.8f;\n        float rightLeg = sdCapsule(p, vec3(-.2, .4 - sin(angleR) * 0.3, cos(angleR) * 0.3), vec3(-.2, .4, 0), .1);\n        float leftLeg = sdCapsule(p,  vec3( .2, .4 - sin(angleL) * 0.3, cos(angleL) * 0.3), vec3( .2, .4, 0), .1);\n        d=min(d, leftLeg);\n        d=min(d, rightLeg);\n    }\n    \n    //body\n    {\n        float body = sdRoundedCylinder(p - vec3(0, .9, 0), .2, .1, .3);\n        d=min(d, body);\n    }\n    \n    //arms\n    {\n        float angleL = sin(3.14 + iTime * 3.) * 0.9 + 1.8f;\n        float angleR = sin(       iTime * 3.) * 0.9 + 1.8f;\n        float rightArm = sdCapsule(p, vec3(-.5, 1.2-sin(angleR) * 0.4, cos(angleR) * 0.4), vec3(-.5, 1.2, 0), .1);\n        float leftArm = sdCapsule(p,  vec3( .5, 1.2-sin(angleL) * 0.4, cos(angleL) * 0.4), vec3( .5, 1.2, 0), .1);\n        d=min(d, leftArm);\n        d=min(d, rightArm);\n    }\n    \n    //head\n    {\n        // first row is frequency data (48Khz/4 in 512 texels, meaning 23 Hz per texel)\n        float fft  = texelFetch( iChannel0, ivec2(0.2,0), 0 ).x; \n    \n        float c = cos(fft*.2 - .1);\n        float s = sin(fft*.2 - .1);\n\n        mat4 rot = mat4(\n            vec4(1, 0, 0, 0),\n            vec4(0, c, -s, 0),\n            vec4(0, s, c, 0),\n            vec4(0, 0, 0, 1)\n        );\n        vec3 q = (rot * vec4(p, 1.0)).xyz ;\n\n        \n        float box = sdBox(q- vec3(0,1.75,0), vec3(1.,.4,1.));\n        //d = min(d,box);\n        float head = max(length(q-vec3(0,1.40,0)) - .4, box);\n        \n        //float bottomheadbox = sdBox(p-vec3(0,1.35,0), vec3(1.,.05,1.));\n        //float bottomhead = max(bottomheadbox, sdRoundedCylinder(p - vec3(0,1.45,0), .2, .1, .05));\n        \n        d = min(d, head);// - (sin(iTime)*0.5 + 0.5) * .1;\n        \n        float angleL = sin(3.14 + iTime * 6.) * 0.1 + 1.6f;\n        float angleR = sin(       iTime * 6.) * 0.1 + 1.6f;\n        \n        float ear = sdCapsule(q, vec3(-.1,1.70,0), vec3(-.2,1.4 + sin(angleL) * 0.6,cos(angleL) * 0.6), .03);\n        d = opSmoothUnion(d, ear, .25);\n        \n        ear = sdCapsule(q, vec3(.1,1.70,0), vec3(.2,1.4 + sin(angleR) * 0.6,cos(angleR) * 0.6), .03);\n        d = opSmoothUnion(d, ear, .25);\n        \n        d = max(d, -sdCappedCylinder(q, vec3(-.15, 1.55, .2), vec3(-.15, 1.55, 1), .03));\n        d = max(d, -sdCappedCylinder(q, vec3(.15, 1.55, .2), vec3(.15, 1.55, 1), .03));\n    }\n    \n    return opUnionColor(vec4(vec3(.7,.7,.7), plane) , vec4(vec3(0.,1.,0.), d));\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, inout vec3 color) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        if (dO>MAX_DIST) \n            break;\n    \t\n        vec3 p = ro + rd*dO;\n        vec4 dS = GetDist(p);\n        if (dS.w < SURF_DIST) {\n            color = dS.rgb;\n            break;\n        }\n        dO += dS.w *.8;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p).w;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).w,\n        GetDist(p-e.yxy).w,\n        GetDist(p-e.yyx).w);\n    \n    return normalize(n);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = GetDist(ro + rd*t).w;\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(8, 10, 8);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    vec3 color = vec3(0.);\n    \n    \n    //float d = RayMarch(p+n*SURF_DIST*2., l, color);\n    //if(p.y<.01 && d<length(lightPos-p)) dif *= .5;\n    \n    dif = clamp( dot( n, l ), 0.0, 1.0 ) *\n                    softshadow( p+n*SURF_DIST*2., l, 0.01, 6.0, 16. );\n\n    \n    //float shadow = softshadow(p+n*SURF_DIST*2., l, 0.01, 6.0, 32.);\n    //dif *= shadow;\n    \n    return dif;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 4, -1);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = R(uv, ro, vec3(0,1,0), 1.);\n    vec3 color = vec3(0.);\n    float d = RayMarch(ro, rd,color);\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \n    \tfloat dif = GetLight(p);\n        vec3 c = vec3(4,0,4);\n        \n        //vec3 q = p + vec3(0.,0.,-4) * fract(iTime * 0.1);\n        //q = q - mod(q+0.5*c,c)-0.5*c;\n        //vec3 baseColor = q*0.1;\n        vec3 baseColor = color;\n        \n        vec3 m = mix(vec3(1,.5,0), baseColor, 1. - (dot(rd, GetNormal(p))*.5 + .5 ));\n    \tcol = m * dif;\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdyXR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 87, 87, 163], [165, 165, 206, 206, 297], [299, 299, 349, 349, 517], [519, 519, 570, 570, 880], [882, 882, 913, 913, 981], [983, 983, 1012, 1012, 1093], [1095, 1095, 1159, 1159, 1276], [1278, 1278, 1330, 1330, 1430], [1432, 1432, 1489, 1489, 1825], [1827, 1827, 1862, 1862, 1894], [1896, 1896, 1918, 1918, 4703], [4705, 4705, 4757, 4757, 5064], [5066, 5066, 5090, 5090, 5288], [5290, 5290, 5367, 5367, 5586], [5588, 5588, 5612, 5612, 6147], [6149, 6149, 6191, 6191, 6386], [6389, 6389, 6446, 6446, 7290]]}
{"id": "fdyXW3", "name": "Figure8 logeps in s3", "author": "ollj", "description": "figure 8 uses complex number distance fields in s3.\nThis extreme distortion comes with extreme marching challenge.\na naive approach to that is logeps(), as in this shader.\na a smarter approach is to calculate the matrix of differentials to rescale lipschi", "tags": ["3d", "4d", "knot", "projective", "s3", "seifert"], "likes": 6, "viewed": 182, "published": "Public API", "date": "1635356908", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define doLogEps\n// logeps break condition of https://www.shadertoy.com/view/tdXXzl\n\n//Daniel Piker 2021\n/* \nChanged to get the Seifert surface using (1/4πi) log (Q/Q∗)\n(added complex log line 85 and new field expression line 163)\n\nTrying here to show different valued Seifert fibers like in \nhttps://twitter.com/KangarooPhysics/status/1381380025568616459\n\n// Inigo Quilez 2021\n/*\n\nAn (appoximated) SDF that has a Figure-8 knot shape. It's not very\nsymmetric or pretty, but it counts (topologically).\n\nThe idea is described here https://arxiv.org/pdf/1610.02463.pdf and\ngoes like this:\n\nFrom R3, our regular 3D space, we do an inverse stereographic\nprojection to land in a 4D hyper sphere S3, a subset of R4.\n\nIn R4 we define a function F that returns a R2 field (or\ntwo scalar fields, if you want). We find the zero isosurface\n(the nodal set, or roots) of F by zeroing its two components.\n\nBecause we are only evaluating the subset of R4 that lays on S3,\nwe are really computing the intersection of the isosurfce of F\nwith the surface of the sphere S3. This creates a curve on the surface\nof the sphere, which thanks to the stereographic projection we started\nwith becomes a curve in R3, our 3D space. That's the curve we are\nraymarching.\n\nThe R4 parameter to F can be grouped as two complex numbers u and v.\nAnd in the case of this shader I'm using\n\nF(u,v) = 64v³ − 12v(3+2u²−2u*²) − (14u²+14u*²+u⁴-u*⁴)\n\nwhere u* is the conjugate of u. This curve is a figure 8 shape, as\ndescribed in the paper. You can change the SHAPE define below to\nsee another shape (a torus knot).\n\nLastly, there's more than one way to convert F into a R1 scalar field\nthan taking it's length |F|. For example, you can pass F through any\n2D SDF formula you want, such a square. Change the PROFILE define\nbellow to explore that.\n\n\nSee: https://www.shadertoy.com/view/tsBGzt\nSee: https://www.shadertoy.com/view/7sGSRd\n\n*/\n\n#define AA 1\n\n// 0: circular\n// 1: square\n#define PROFILE 0\n\n// 0: figure 8\n// 1: torus 5-2\n// 2: something i made\n#define SHAPE 0\n\n//------------------------------------------------------------\n// oldschool rand() from Visual Studio\n//------------------------------------------------------------\nint   seed = 1;\nvoid  srand(int s ) { seed = s; }\nint   rand(void) { seed = seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\n//------------------------------------------------------------\n// hash to initialize the random sequence (copied from Hugo Elias)\n//------------------------------------------------------------\nint hash( int n )\n{\n\tn = (n << 13) ^ n;\n    return n * (n * n * 15731 + 789221) + 1376312589;\n}\n\n//------------------------------------------------------------\n// complex number operations\n//------------------------------------------------------------\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 cdiv( vec2 a, vec2 b )  { float d = dot(b,b); return vec2( dot(a,b), a.y*b.x - a.x*b.y ) / d; }\nvec2 csqr( vec2 a ) { return vec2(a.x*a.x-a.y*a.y, 2.0*a.x*a.y ); }\nvec2 csqrt( vec2 z ) { float m = length(z); return sqrt( 0.5*vec2(m+z.x, m-z.x) ) * vec2( 1.0, sign(z.y) ); }\nvec2 conj( vec2 z ) { return vec2(z.x,-z.y); }\nvec2 cpow( vec2 z, float n ) { float r = length( z ); float a = atan( z.y, z.x ); return pow( r, n )*vec2( cos(a*n), sin(a*n) ); }\nvec2 clog( vec2 z) {return vec2 (log(sqrt(z.x*z.x+z.y*z.y)),atan(z.y,z.x));}\n//------------------------------------------------------------\n// https://en.wikipedia.org/wiki/Stereographic_projection\nvec4 inversestereographic(vec3 p)\n{\n    float r2 = 1.0+dot(p,p);\n    return vec4(2.0*p,r2-2.0)/r2;\n}\n//------------------------------------------------------------\n// https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdRoundSquare( in vec2 p, in float s, in float r ) \n{\n    vec2 q = abs(p)-s+r;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r;\n}\n//------------------------------------------------------------\n// https://iquilezles.org/www/articles/biplanar/biplanar.htm\nvec3 tex( sampler2D sam, in vec4 p, in vec4 n )\n{\n    n = n*n;\n    n = n*n;\n    vec3 col = vec3(0.0);\n    col += n.x*texture(iChannel0,p.yz).xyz;\n    col += n.y*texture(iChannel0,p.zw).xyz;\n    col += n.z*texture(iChannel0,p.wx).xyz;\n    col += n.w*texture(iChannel0,p.xy).xyz;\n    return col / (n.x+n.y+n.z+n.w);\n}\n//===============================================================================================\n\nvec4 r3_to_s3( in vec3 p )\n{\n    vec4 q = inversestereographic(p);\n    \n    // rotate in yw\n    float a = iTime*6.283185/24.0;\n    //float a = 0.0;\n    q.yw *= mat2(cos(a),sin(a),-sin(a),cos(a));\n    \n    return q;\n}\n\nvec2 F( in vec2 u, vec2 v )\n{\n    #if SHAPE==0\n    // figure-8\n    vec2 a = vec2(3.0,0.0) - 2.0*csqr(v) + 2.0*csqr(conj(v));\n    vec2 q = 64.0*cmul(u,csqr(u)) \n           - 12.0*cmul(u,a) \n           + 14.0*cmul(v,v) \n           + 14.0*csqr(conj(v)) \n           -      csqr(csqr(v)) \n           +      csqr(csqr(conj(v)));\n    return q;\n    #endif\n    \n    #if SHAPE==1\n    // torus\n    return 20.0*(cmul(u,csqr(csqr(u))) + csqr(v));\n    #endif    \n\n    #if SHAPE==2\n    // something I made\n    return    64.0*cmul(v,csqr(csqr(u)))\n           + 32.0*cmul(u,csqr(v))\n           + 32.0*csqr(v) \n           + 8.0;\n    #endif    \n\n}\n\nfloat field( in vec4 q )\n{\n    vec2 phi = F(q.xy,q.zw);\n    \n    #if PROFILE==0\n    //return length(phi) - 10.0;  \n    \n    //(1/4πi) log (Q/Q∗)  \n  //  return (length(cmul(vec2(0,0.785398163),clog(cdiv(phi,conj(phi))))));    \n    return abs(mod(((cmul(vec2(0,0.785398163),clog(cdiv(phi,conj(phi))))).x + iTime/3.14159265359),6.28318530718) - 0.5);\n    \n    \n    #else\n    return sdRoundSquare( phi, 8.0, 0.5 );\n    #endif\n}\n\n// only used for texturing, not for distance-estimation\nvec4 field_grad( in vec4 q )\n{\n    float f = field(q);\n    const vec2 e = vec2(0.001,0.0);\n    return normalize(vec4(\n        field(q+e.xyyy),\n        field(q+e.yxyy),\n        field(q+e.yyxy),\n        field(q+e.yyyx))-f );\n}\n\nfloat map( in vec3 p )\n{\n\n    float d = field(r3_to_s3(p));\n\n    // could do some automatic differentiation here...\n    float eps = 0.0001;\n    vec3 g = (vec3(field(r3_to_s3(p+vec3(eps,0.0,0.0))),\n                   field(r3_to_s3(p+vec3(0.0,eps,0.0))),\n                   field(r3_to_s3(p+vec3(0.0,0.0,eps))))-d)/eps;\n    \n    // distance estimator\n    return d/length(g);\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos, in float eps )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\n// https://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat shadow( in vec3 ro, in vec3 rd, float k )\n{\n    const float tmax = 5.0;\n    float t = 0.001;\n    float sh = 1.0;\n    for( int i=0; i<256; i++ )\n    {\n        vec3 pos = ro + rd*t;\n        float h = map(pos);\n        sh = min( sh, clamp(k*h/t,0.0,1.0) );\n        if( sh<0.001 ) break;\n        t += clamp(h,0.001,0.1);\n        if( t>tmax ) break;\n    }\n    return sh;\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat ao = 0.0;\n\tfor( int i=0; i<32; i++ )\n\t{\n\t\tfloat h = frand();\n        vec3 kv = normalize( vec3(frand(), frand(), frand()) );\n        kv *= sign(dot(kv,nor));\n\t\tao += clamp( map(pos+nor*0.001+kv*h*2.0)*1.0, 0.0, 1.0 );\n\t}\n\tao /= 32.0;\n\t\n\treturn clamp( ao*1.5-0.1, 0.0, 1.0 );\n}\n\n\n//logEps() put into subroutine\n//, to toggle between various LOD-scales (distance field zoom levels)\n//, to make it toggleAble (sometimes a simpler end condition is better)\nbool logEps(float d,float s//t=distanceToCamera s=numberOfmarchingIterations\n){if(1./exp(d)<.01)return s<.001;//better for short distance reflections\n  //above line fails within a tensor-distorted gradient...\n  return log(d*d/s/1e5)>0. //long distance logeps for spinor /tdXXzl\n ;}\n\n\nfloat marchLog(inout vec3 pos, inout vec3 dir  ,float tmax     \n){\n ;float s=0.\n ;float d=0.;\n ;vec3 p=pos//+1.*dir\n //pos//+1.*dir is optional zNear, logeps is a bit bad when camera is close to a wall\n //, this is easily avoided\n //logeps() shines in LONG distances, not as much in short distances (within large lipschitz)\n //i have plans for a [logNeps], which should be better ingeneral average fractals\n ;for(float i=0.;i<2000.;i++ //logeps is fine with 4x as many iterations, it unlikely needs half of them.\n //r3_to_s3():  could need more than 40000 iterations, but will have much lower framerates on it.\n ){if(logEps(d,s))return d\n  ;s=map(p)\n  ;d+=s*.02\n  //smaller value for r3_to_s3(): https://www.shadertoy.com/view/7sVXWK\n  //than for 2 spinors: https://www.shadertoy.com/view/tdXXzl\n  ;p=pos+dir*d\n ;}return 0.;}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // init random seed\n    ivec2 q = ivec2(fragCoord);\n    srand( hash(q.x+hash(q.y+hash(iFrame))));\n\n    // camera movement\t\n    float an = -0.0*iTime/20.0;\n    vec3 ro = vec3( 5.0*sin(6.283185*an), 4.0, 5.0*cos(6.283185*an) );\n    #if SHAPE>0\n    ro.xz *= 1.5;\n    ro.y = 0.0;\n    #endif\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n\n        // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 3.0*ww );\n        \n\n        // raymarch\n        const float tmax = 15.0;\n        #ifdef doLogEps\n        float t=marchLog(ro,rd,tmax);//child march loop function.\n        #else\n        float t = 0.0;\n        for( int i=0; i<8192; i++ ){ //parent march loop;\n            vec3 pos = ro + rd*t;\n            float d = map(pos);\n            if( d<0.001 ) break;\n            d = min(d*0.8,0.1);\n            t += d;\n            if( t>tmax ) break;} \n        #endif\n        \n        vec3 col = vec3(0.0);\n        col = vec3(0.05 + 0.05*rd.y);\n        #ifdef doLogEps\n        if(map(ro+rd*t)<0.001 && t<tmax)//because logeps may end up in empty space on this much distortion\n       //t<tmax seems to NEVER be true for logeps, which is kinda sad.\n        #else\n        if( t<tmax)\n        #endif\n        {\n            vec3  pos = ro + rd*t;\n            vec3  nor = calcNormal( pos, 0.0001 );\n            float occ = calcAO( pos+nor*0.001, nor );\n\n            // we do texturing in R4\n            vec4 pos4 = r3_to_s3(  pos );\n            vec4 nor4 = field_grad( pos4 );\n            vec3 mate = tex(iChannel0,pos4,nor4);\n            mate = mate*mate;\n            mate *= 0.3;\n\n            // sun\n            {\n            vec3 lig = normalize(vec3(1.0,1.0,0.2));\n            float dif = clamp(dot(nor,lig),0.0,1.0);\n            if( dif>0.001 ) dif *= shadow(pos+nor*0.001, lig, 48.0);\n            vec3 hal = normalize(lig-rd);\n            float spe = pow(clamp(dot(nor,hal),00.,1.0),32.0);\n            spe *= 0.04 + 0.96*pow( clamp(1.0-dot(lig,hal), 0.0, 1.0), 5.0 );\n            spe *= 10.0;\n\n            col  = 0.6*mate*vec3(9.0,8.0,7.0)*dif;\n            col += spe*dif*mate.x*10.0;\n            \n            float fre = clamp(1.0+dot(rd,nor),0.0,1.0);\n            col += mate*fre*1.0*(0.25+0.75*dif)*vec3(1.0,0.7,0.4);\n            }\n            \n            // sky\n            {\n            vec3 ref = reflect(rd,nor);\n            float dif = 0.5+0.5*nor.y;\n            float spe = smoothstep(0.3,0.5,ref.y);\n            spe *= dif;\n            spe *= 0.04 + 0.96*pow( clamp(1.0+dot(rd,nor), 0.0, 1.0), 5.0 );\n            if( spe>0.001 ) spe *= shadow(pos+nor*0.001, ref, 8.0);\n            col += 3.0*occ*mate*dif*vec3(0.5,0.6,1.0)*1.5;\n            col += 1.0*spe;\n            }\n\n            // sun bounce\n            col += mate*(1.0-occ)*vec3(1.2,0.5,0.2)*0.2;\n        }\n        \n        // gain\n        col = col*1.5/(1.0+col);\n        \n        // to gamma space\n        col = pow( col, vec3(0.4545) );\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    // remove color banding through dithering\n    tot += (1.0/255.0)*frand();\n \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdyXW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2046, 2227, 2248, 2248, 2260], [2261, 2261, 2279, 2279, 2336], [2337, 2337, 2356, 2356, 2388], [2389, 2582, 2601, 2601, 2677], [2679, 2834, 2864, 2864, 2919], [2920, 2920, 2950, 2950, 3020], [3021, 3021, 3042, 3042, 3088], [3089, 3089, 3111, 3111, 3198], [3199, 3199, 3220, 3220, 3245], [3246, 3246, 3276, 3276, 3376], [3377, 3377, 3397, 3397, 3453], [3454, 3575, 3610, 3610, 3675], [3676, 3814, 3873, 3873, 3959], [3960, 4084, 4133, 4133, 4399], [4400, 4499, 4527, 4527, 4715], [4717, 4717, 4746, 4746, 5345], [5347, 5347, 5373, 5373, 5774], [5776, 5832, 5862, 5862, 6056], [6058, 6058, 6082, 6082, 6433], [6435, 6499, 6545, 6545, 6742], [6744, 6807, 6856, 6856, 7180], [7182, 7182, 7224, 7224, 7508], [7511, 7684, 7763, 7763, 7965], [7968, 7968, 8034, 8034, 8793]]}
{"id": "fdyXWK", "name": "Figure-8 Knot (Implicit in R4)", "author": "iq", "description": "A figure-8 knot, as described here: [url]https://arxiv.org/pdf/1610.02463.pdf[/url].", "tags": ["3d", "4d", "knot", "projective"], "likes": 26, "viewed": 472, "published": "Public API", "date": "1635314093", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Inigo Quilez 2021\n\nAn appoximated SDF for a Figure-8 knot. The idea is described here\nhttps://arxiv.org/pdf/1610.02463.pdf and goes like this:\n\nFrom R3, our regular 3D space, we do an inverse stereographic projection\nto land in a 4D hyper sphere S3, a subset of R4. Here in R4 we define a\nfunction F that returns a R2 field (or two scalar fields, if you want).\nThen we find its zero isosurface (nodal set). Because we are only\nevaluating the subset of R4 that lays on S3, we are really computing the\nintersection of the isosurface of F with the sphere S3. This creates a\ncurve on the sphere, which thanks to the stereographic projection becomes\na curve in R3, our 3D space. That's the curve we are raymarching. Now,\nthe R4 domain of F can be grouped as two complex numbers u and v. In the\ncase of the figure 8 knot,\n\nF(u,v) = 64v³ − 12v(3+2u²−2u*²) − (14u²+14u*²+u⁴-u*⁴)\n\nwhere u* is the conjugate of u. Finally, texturing happens in spherical\ncoordinates on S3 itself, with becomes a regular 3D texturing problem.\n\nYou can change the SHAPE define below to see other shapes. Also, there\nare more than one way to convert F into a R1 scalar field than taking\nits length |F|. For example, you can pass F through any 2D SDF formula\nyou want, such a square. Change the PROFILE define bellow to explore that.\n\nSee also: https://www.shadertoy.com/view/tsBGzt\nSee also: https://www.shadertoy.com/view/7sGSRd                        */\n\n// antialiasing. Can set to 2 if you have a fast machine\n#define AA 1\n\n// 0: figure 8\n// 1: torus 5-2\n// 2: clifford torus\n// 3: something I made\n// 4: some other shape I made\n#define SHAPE 0\n\n// 0: circular\n// 1: square\n#define PROFILE 0\n\n// 0: distance estimation in R3 (pos)\n// 1: distance estimation in R1 (t), equivalent to Newtwon-Raphson\n#define METHOD 1\n\n//------------------------------------------------------------\n// oldschool rand() from Visual Studio\n//------------------------------------------------------------\nint   seed = 1;\nvoid  srand(int s ) { seed = s; }\nint   rand(void) { seed = seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\n//------------------------------------------------------------\n// hash to initialize the random sequence (copied from Hugo Elias)\n//------------------------------------------------------------\nint hash( int n )\n{\n\tn = (n << 13) ^ n;\n    return n * (n * n * 15731 + 789221) + 1376312589;\n}\n//------------------------------------------------------------\n// complex number operations\n//------------------------------------------------------------\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 cdiv( vec2 a, vec2 b )  { float d = dot(b,b); return vec2( dot(a,b), a.y*b.x - a.x*b.y ) / d; }\nvec2 csqr( vec2 a ) { return vec2(a.x*a.x-a.y*a.y, 2.0*a.x*a.y ); }\nvec2 csqrt( vec2 z ) { float m = length(z); return sqrt( 0.5*vec2(m+z.x, m-z.x) ) * vec2( 1.0, sign(z.y) ); }\nvec2 conj( vec2 z ) { return vec2(z.x,-z.y); }\nvec2 cpow( vec2 z, float n ) { float r = length( z ); float a = atan( z.y, z.x ); return pow( r, n )*vec2( cos(a*n), sin(a*n) ); }\n//------------------------------------------------------------\n// https://en.wikipedia.org/wiki/Stereographic_projection\nvec4 inversestereographic(vec3 p)\n{\n    float r2 = 1.0+dot(p,p);\n    return vec4(2.0*p,r2-2.0)/r2;\n}\n//------------------------------------------------------------\n// https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdRoundSquare( in vec2 p, in float s, in float r ) \n{\n    vec2 q = abs(p)-s+r;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r;\n}\n//------------------------------------------------------------\n// texture a 4D sphere, |p|=1\nvec3 tex( sampler2D sam, in vec4 p )\n{\n    // https://en.wikipedia.org/wiki/N-sphere#Spherical_coordinates\n    vec3 q = acos(p.xyz/vec3(length(p.xyzw),\n                             length(p.yzw),\n                             length(p.zw) ));\n                             \n    // here we could do actual 3D texturing, but instead,\n    // i hacked three 2D texture projections\n    vec3 col = vec3(0.0);\n    col  = texture(sam,q.xy).xyz;\n    col += texture(sam,q.yz).xyz;\n    col += texture(sam,q.zx).xyz;\n    col = col/3.0;\n    \n    // adjust contrast a bit to match source texture\n    col *= 0.5+col*(1.5-col);\n\n    // srgb to linear\n    return col*col;\n}\n//===============================================================================================\n\nvec4 r3_to_s3( in vec3 p )\n{\n    vec4 q = inversestereographic(p);\n    \n    // rotate in yw\n    float a = iTime*6.283185/6.0;\n    q.yw *= mat2(cos(a),sin(a),-sin(a),cos(a));\n    \n    return q;\n}\n\nvec2 F( in vec2 u, vec2 v )\n{\n    #if SHAPE==0\n    return  64.0*cmul(u,csqr(u)) \n          - 12.0*cmul(u,vec2(3.0,0.0) - 2.0*csqr(v) + 2.0*csqr(conj(v))) \n          + 14.0*cmul(v,v) \n          + 14.0*csqr(conj(v)) \n          -      csqr(csqr(v)) \n          +      csqr(csqr(conj(v)));\n    #endif\n    \n    #if SHAPE==1\n    return 20.0*(cmul(u,csqr(csqr(u))) + csqr(v));\n    #endif    \n    \n    #if SHAPE==2\n    return 32.0*(cmul(u,conj(u))-cmul(v,conj(v)));\n    #endif    \n\n    #if SHAPE==3\n    return  64.0*cmul(v,csqr(csqr(u)))\n          + 32.0*cmul(u,csqr(v))\n          + 32.0*csqr(v) \n          + 8.0;\n    #endif    \n\n    #if SHAPE==4\n    float h = u.x*u.x - u.y*u.y + v.x*v.x - v.y*v.y;\n    return vec2(u.y*u.y*u.y + v.y*v.y*h,  u.x*u.x*v.x + u.y*v.x*h)*32.0;\n    #endif\n\n}\n\nfloat field( in vec4 q )\n{\n    vec2 phi = F(q.xy,q.zw);\n    \n    #if SHAPE==4\n    const float th = 1.0;\n    #else\n    const float th = 10.0;\n    #endif\n    \n    #if PROFILE==0\n    return length(phi) - th;\n    #else\n    return sdRoundSquare( phi, 0.8*th, 0.05*th );\n    #endif\n}\n\nfloat map( in vec3 p )\n{\n    return field(r3_to_s3(p));\n}\n\nfloat distance_map( in vec3 p )\n{\n    float d = field(r3_to_s3(p));\n\n    // could do some automatic differentiation here...\n    float eps = 0.0001;\n    vec3 g = (vec3(field(r3_to_s3(p+vec3(eps,0.0,0.0))),\n                   field(r3_to_s3(p+vec3(0.0,eps,0.0))),\n                   field(r3_to_s3(p+vec3(0.0,0.0,eps))))-d)/eps;\n    \n    // distance estimator\n    return d/length(g);\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos, in float eps )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\n// https://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat shadow( in vec3 ro, in vec3 rd, float k )\n{\n    const float tmax = 5.0;\n    float t = 0.001;\n    float sh = 1.0;\n    for( int i=0; i<256; i++ )\n    {\n        vec3 pos = ro + rd*t;\n        #if METHOD==0\n        float f = distance_map(pos);\n        sh = min( sh, clamp(k*f/t,0.0,1.0) );\n        if( sh<0.001 ) break;\n        #else\n        float f = map(pos);\n        sh = min( sh, clamp(0.02*k*f/t,0.0,1.0) );\n        if( sh<0.001 ) break;\n        const float eps = 0.001;\n        float df = (map(ro+rd*(t+eps))-f)/eps;\n        f = f/abs(df);\n        #endif\n        \n\n        t += clamp(f,0.001,0.1);\n        if( t>tmax ) break;\n    }\n    return sh;\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat ao = 0.0;\n\tfor( int i=0; i<32; i++ )\n\t{\n\t\tfloat h = frand();\n        vec3 kv = normalize( vec3(frand(), frand(), frand()) );\n        kv *= sign(dot(kv,nor));\n\t\tao += clamp( distance_map(pos+nor*0.001+kv*h*2.0)*1.0, 0.0, 1.0 );\n\t}\n\tao /= 32.0;\n\t\n\treturn clamp( ao*1.5-0.1, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // init random seed\n    ivec2 q = ivec2(fragCoord);\n    srand( hash(q.x+hash(q.y+hash(iFrame))));\n\n    // camera movement\t\n    float an = -0.0*iTime/20.0;\n    vec3 ro = vec3( 5.0*sin(6.283185*an), 4.0, 5.0*cos(6.283185*an) );\n    #if SHAPE==1\n    ro.xz *= 1.5;\n    ro.y = 0.0;\n    #endif\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n\n        // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 3.0*ww );\n        \n        \n        vec3 col = vec3(0.0);\n        col = vec3(0.05 + 0.05*rd.y);\n        \n        // raymarch\n        if( map(ro)>0.0 )\n        {\n        const float tmax = 15.0;\n        float t = 0.0;\n        for( int i=0; i<8192; i++ )\n        {\n            vec3 pos = ro + rd*t;\n            \n            #if METHOD==0\n            float f = distance_map(pos);\n            if( abs(f)<0.001 ) break;\n            float dt = f;\n            #else\n            float f = map(pos);\n            if( abs(f)<0.001 ) break;\n            const float eps = 0.001;\n            float df = (map(ro+rd*(t+eps))-f)/eps;\n            float dt = f/abs(df);\n            #endif\n            \n            t += clamp(dt,-0.1,0.1);\n            if( t>tmax ) break;\n        }\n            \n\n        if( t<tmax )\n        {\n            vec3  pos = ro + rd*t;\n            vec3  nor = calcNormal( pos, 0.0001 );\n            float occ = calcAO( pos+nor*0.001, nor );\n\n            // we do texturing in R4\n            vec4 pos4 = r3_to_s3(pos);\n            vec3 mate = tex(iChannel0,pos4);\n            mate *= 0.3;\n\n            // sun\n            {\n            vec3 lig = normalize(vec3(1.0,1.0,0.2));\n            float dif = clamp(dot(nor,lig),0.0,1.0);\n            if( dif>0.001 ) dif *= shadow(pos+nor*0.001, lig, 48.0);\n            vec3 hal = normalize(lig-rd);\n            float spe = pow(clamp(dot(nor,hal),00.,1.0),32.0);\n            spe *= 0.04 + 0.96*pow( clamp(1.0-dot(lig,hal), 0.0, 1.0), 5.0 );\n            spe *= 10.0;\n\n            col  = 0.6*mate*vec3(9.0,8.0,7.0)*dif;\n            col += spe*dif*mate.x*10.0;\n            \n            float fre = clamp(1.0+dot(rd,nor),0.0,1.0);\n            col += mate*fre*1.0*(0.25+0.75*dif)*vec3(1.0,0.7,0.4);\n            }\n            \n            // sky\n            {\n            vec3 ref = reflect(rd,nor);\n            float dif = 0.5+0.5*nor.y;\n            float spe = smoothstep(0.3,0.5,ref.y);\n            spe *= dif;\n            spe *= 0.04 + 0.96*pow( clamp(1.0+dot(rd,nor), 0.0, 1.0), 5.0 );\n            if( spe>0.001 ) spe *= shadow(pos+nor*0.001, ref, 8.0);\n            col += 3.0*occ*mate*dif*vec3(0.5,0.6,1.0)*1.5;\n            #if METHOD==1\n            spe *= 2.0;\n            #endif\n            col += 1.0*spe;\n            }\n\n            // sun bounce\n            col += mate*(1.0-occ)*vec3(1.2,0.5,0.2)*0.2;\n        }\n        }\n\n        // gain\n        col = col*1.5/(1.0+col);\n        \n        // to gamma space\n        col = pow( col, vec3(0.4545) );\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    // remove color banding through dithering\n    tot += (1.0/255.0)*frand();\n \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdyXWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1808, 1989, 2010, 2010, 2022], [2023, 2023, 2041, 2041, 2098], [2099, 2099, 2118, 2118, 2150], [2151, 2344, 2363, 2363, 2439], [2440, 2595, 2625, 2625, 2680], [2681, 2681, 2711, 2711, 2781], [2782, 2782, 2803, 2803, 2849], [2850, 2850, 2872, 2872, 2959], [2960, 2960, 2981, 2981, 3006], [3007, 3007, 3037, 3037, 3137], [3138, 3259, 3294, 3294, 3359], [3360, 3498, 3557, 3557, 3643], [3644, 3737, 3775, 3843, 4391], [4392, 4491, 4519, 4519, 4685], [4687, 4687, 4716, 4716, 5464], [5466, 5466, 5492, 5492, 5743], [5745, 5745, 5769, 5769, 5802], [5804, 5804, 5837, 5837, 6187], [6189, 6253, 6299, 6299, 6496], [6498, 6561, 6610, 6610, 7216], [7218, 7218, 7260, 7260, 7553], [7555, 7555, 7612, 7636, 11190]]}
{"id": "fl3Gzr", "name": "Harmonic Arc", "author": "hydrocarborane", "description": "Harmonic Arc", "tags": ["arc"], "likes": 0, "viewed": 34, "published": "Public", "date": "1635561528", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Constants\nfloat PI = 3.14159265358979323846;\nvec2 ii = vec2( 0., 1. ); // imaginary unit\n\n\n// Operations on complex numbers (represented as vec2)\n\n// complex logarithm\nvec2 clog(vec2 x){\n    return vec2(log(x.x), atan(x.y, x.x));\n}\n\n// complex multiplication\nvec2 mul(vec2 a, vec2 b){\n    return vec2(a.x * b.x - a.y * b.y,\n                a.x * b.y + a.y * b.x);\n}\n\n// complex conjugation\nvec2 conj(vec2 a){\n    return vec2(a.x, -a.y);\n}\n\n// complex inverse\nvec2 inv(vec2 a) {\n   return conj(a)/dot(a,a);\n}\n\n// complex division\nvec2 div(vec2 a, vec2 b){\n    return mul(a,inv(b));\n}\n\n// harmonic segment\nfloat segment(vec2 z, vec2 p, vec2 q){\n    return clog(div((z - p), (z - q))).y;\n}\n\n// map scalar value to pseudocolor\nvec3 colorMap(float x){\n    x = .5 + .5*x/PI;\n    vec3 colA = vec3(1, 0, 0);\n    vec3 colB = vec3(0, 0, 1);\n    return colA * x + colB * (1.0f - x);\n}\n\nvec2 mobiusTransform(float a, float b, float c, float d, vec2 x){\n    return div(a * x + b, c * x + d);\n}\n\nvec2 invMobiusTransform(float a, float b, float c, float d, vec2 x){\n    return div((-d * x) + b, (c * x) - a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime; // short name for time\n\n    // transform coordinate system so origin is in the center,\n    // and so that pixels have a square aspect ratio\n    vec2 z = (fragCoord-iResolution.xy/2.)/iResolution.x;\n    //float r = sin(t * 2.0f) * 0.25f;\n    float r = 0.25f;\n    // float r = 0.125;\n    // vec2 p = r*vec2(cos(t),sin(t));\n    float s2 = sqrt(2.0) / 2.0;\n    float diamPos = 1.0 / (2.0 * r * s2);\n    float theta = sin(t) * (PI / 2.0);\n    //float anglePos = (1.0 - sqrt(1.0 - 2.0 * (sin(theta)*sin(theta)))) / (2.0 * r * sin(theta));\n    //float anglePos = 2.0 * r;\n    float anglePos = sqrt((diamPos - (diamPos * diamPos * (r * s2)) - (diamPos * diamPos * (r * s2) * sin(theta)))\n                         / (r + r * sin(theta)));\n    vec2 p1 = vec2(diamPos, -anglePos);\n    vec2 p2 = vec2(diamPos, anglePos);\n    float a = 0.0;\n    float b = 1.0;\n    float c = 1.0;\n    float d = 0.0;\n    vec2 offset = vec2(r * s2,r * s2);\n    // vec2 invPos = invMobiusTransform(a,b,c,d,pos);\n\n    vec3 col = colorMap(segment(invMobiusTransform(a,b,c,d,z + offset), p1, p2) );\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl3Gzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[150, 171, 189, 189, 234], [236, 262, 287, 287, 368], [370, 393, 411, 411, 441], [443, 462, 480, 480, 510], [512, 532, 557, 557, 585], [587, 607, 645, 645, 689], [691, 726, 749, 749, 876], [878, 878, 943, 943, 983], [985, 985, 1053, 1053, 1098], [1100, 1100, 1157, 1157, 2298]]}
{"id": "flc3zn", "name": "More black and white stuff", "author": "SnoopethDuckDuck", "description": "e", "tags": ["e"], "likes": 0, "viewed": 107, "published": "Public API", "date": "1635553269", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    uv *= tanh(10. * cos(length(uv) + 0.5 * iTime));\n    uv.x += 0.1 * cos(10. * uv.y + iTime);\n    float a = atan(uv.y, uv.x);\n    float d = length(uv) + 0.5\n    + 0.5 * tanh( (0. + 1. * tanh(4. * cos(length(uv) + 96. * a + 2. * iTime))) \n                   * cos(80. * length(uv) +  10. * iTime) );\n    d = d * (1.5 + tanh(2. * cos(0. * d + 2.* length(uv) * \n    (0. + tanh(1. * cos(192. * a + iTime))) + 3. * a+  1. * iTime)));\n   // d *= 0.22;\n    float s = step(d,0.4);\n    \n    vec3 col = vec3(s);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flc3zn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 713]]}
{"id": "flcGz8", "name": "Persian carpet 6", "author": "jarble", "description": "A Persian carpet fractal pattern.", "tags": ["fractal", "carpet", "rug"], "likes": 4, "viewed": 106, "published": "Public API", "date": "1635654487", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//change these constants to get different patterns!\n#define c2 1.5\n\n#define c1 vec4(3.0+c2,2.5+c2,-1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//to do: drag and drop using https://www.shadertoy.com/view/WdGGWh\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   //from David Hoskins' \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    \n\n    \n    vec3 col;  \n    float t1 = 4.5*3./2.;\n    float t = 45.87+iTime/2.;\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/128.0/2.;\n    uv += vec2(t/2.0,t/3.0)/t1/128.0/4.;\n    //vec3 random1 = hash31(floor((iTime)/10.0+uv.x))*10.*.0;\n    float t2 = floor((t+4.)/20.0+uv.x);\n    //vec3 random2 = hash31(1.+t2);\n    \n    \n    float offset = -.1;\n    \n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        float t3 = float(c)+t2;\n\n        for(int i=0;i<3;i++)\n        {\n            vec3 col_prev = col;\n            float factor = 1.1;\n            \n            uv = triangle_wave(uv.yx+c1.z,scale)+triangle_wave(uv,scale);\n            //uv.y /= .9;\n            uv.x *= .9;\n            for(int j = 0; j < 3;j++){\n                uv = triangle_wave((uv*(1.+offset)),scale);\n            }\n            uv.x /= -.9;\n            \n            if(i>0) col = abs(col.yzx*col.x + col_prev*col.y)/(col.x-col.y);\n            \n            col[c] = fract((uv.x*(1.+col.x/8.))-(uv.y*(col.y/8.+1.)));\n        }\n    }\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flcGz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[347, 457, 479, 524, 657], [659, 659, 698, 698, 743], [745, 745, 802, 802, 1908]]}
{"id": "fldGRr", "name": "MFSDF test", "author": "RodzLabs", "description": "Testing new Material Maker library by Paulo Falcao.", "tags": ["raymarching"], "likes": 6, "viewed": 58, "published": "Public", "date": "1635615437", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Generated by Material Maker */\n\n#define SEED_VARIATION 0.0\n\n//---\n\nfloat rand(vec2 x) {\n    return fract(cos(mod(dot(x, vec2(13.9898, 8.141)), 3.14)) * 43758.5453);\n}\n\nvec2 rand2(vec2 x) {\n    return fract(cos(mod(vec2(dot(x, vec2(13.9898, 8.141)),\n\t\t\t\t\t\t      dot(x, vec2(3.4562, 17.398))), vec2(3.14))) * 43758.5453);\n}\n\nvec3 rand3(vec2 x) {\n    return fract(cos(mod(vec3(dot(x, vec2(13.9898, 8.141)),\n\t\t\t\t\t\t\t  dot(x, vec2(3.4562, 17.398)),\n                              dot(x, vec2(13.254, 5.867))), vec3(3.14))) * 43758.5453);\n}\n\nvec3 rgb2hsv(vec3 c) {\n\tvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n\tvec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\n\tvec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n\n\tfloat d = q.x - min(q.w, q.y);\n\tfloat e = 1.0e-10;\n\treturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c) {\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat param_rnd(float minimum, float maximum, float seed) {\n\treturn minimum+(maximum-minimum)*rand(vec2(seed));\n}\nfloat rand31(vec3 p) {\n\treturn fract(sin(dot(p,vec3(127.1,311.7, 74.7)))*43758.5453123);\n}\nvec3 rand33(vec3 p){\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat tex3d_fbm_value(vec3 coord, vec3 size, float seed) {\n\tvec3 o = floor(coord)+rand3(vec2(seed, 1.0-seed))+size;\n\tvec3 f = fract(coord);\n\tfloat p000 = rand31(mod(o, size));\n\tfloat p001 = rand31(mod(o + vec3(0.0, 0.0, 1.0), size));\n\tfloat p010 = rand31(mod(o + vec3(0.0, 1.0, 0.0), size));\n\tfloat p011 = rand31(mod(o + vec3(0.0, 1.0, 1.0), size));\n\tfloat p100 = rand31(mod(o + vec3(1.0, 0.0, 0.0), size));\n\tfloat p101 = rand31(mod(o + vec3(1.0, 0.0, 1.0), size));\n\tfloat p110 = rand31(mod(o + vec3(1.0, 1.0, 0.0), size));\n\tfloat p111 = rand31(mod(o + vec3(1.0, 1.0, 1.0), size));\n\tvec3 t = f * f * (3.0 - 2.0 * f);\n\treturn mix(mix(mix(p000, p100, t.x), mix(p010, p110, t.x), t.y), mix(mix(p001, p101, t.x), mix(p011, p111, t.x), t.y), t.z);\n}\n\nfloat tex3d_fbm_value_nowrap(vec3 coord, vec3 size, float seed) {\n\tvec3 o = floor(coord)+rand3(vec2(seed, 1.0-seed))+size;\n\tvec3 f = fract(coord);\n\tfloat p000 = rand31(o);\n\tfloat p001 = rand31(o + vec3(0.0, 0.0, 1.0));\n\tfloat p010 = rand31(o + vec3(0.0, 1.0, 0.0));\n\tfloat p011 = rand31(o + vec3(0.0, 1.0, 1.0));\n\tfloat p100 = rand31(o + vec3(1.0, 0.0, 0.0));\n\tfloat p101 = rand31(o + vec3(1.0, 0.0, 1.0));\n\tfloat p110 = rand31(o + vec3(1.0, 1.0, 0.0));\n\tfloat p111 = rand31(o + vec3(1.0, 1.0, 1.0));\n\tvec3 t = f * f * (3.0 - 2.0 * f);\n\treturn mix(mix(mix(p000, p100, t.x), mix(p010, p110, t.x), t.y), mix(mix(p001, p101, t.x), mix(p011, p111, t.x), t.y), t.z);\n}\n\nfloat tex3d_fbm_perlin(vec3 coord, vec3 size, float seed) {\n\tvec3 o = floor(coord)+rand3(vec2(seed, 1.0-seed))+size;\n\tvec3 f = fract(coord);\n\tvec3 v000 = normalize(rand33(mod(o, size))-vec3(0.5));\n\tvec3 v001 = normalize(rand33(mod(o + vec3(0.0, 0.0, 1.0), size))-vec3(0.5));\n\tvec3 v010 = normalize(rand33(mod(o + vec3(0.0, 1.0, 0.0), size))-vec3(0.5));\n\tvec3 v011 = normalize(rand33(mod(o + vec3(0.0, 1.0, 1.0), size))-vec3(0.5));\n\tvec3 v100 = normalize(rand33(mod(o + vec3(1.0, 0.0, 0.0), size))-vec3(0.5));\n\tvec3 v101 = normalize(rand33(mod(o + vec3(1.0, 0.0, 1.0), size))-vec3(0.5));\n\tvec3 v110 = normalize(rand33(mod(o + vec3(1.0, 1.0, 0.0), size))-vec3(0.5));\n\tvec3 v111 = normalize(rand33(mod(o + vec3(1.0, 1.0, 1.0), size))-vec3(0.5));\n\tfloat p000 = dot(v000, f);\n\tfloat p001 = dot(v001, f - vec3(0.0, 0.0, 1.0));\n\tfloat p010 = dot(v010, f - vec3(0.0, 1.0, 0.0));\n\tfloat p011 = dot(v011, f - vec3(0.0, 1.0, 1.0));\n\tfloat p100 = dot(v100, f - vec3(1.0, 0.0, 0.0));\n\tfloat p101 = dot(v101, f - vec3(1.0, 0.0, 1.0));\n\tfloat p110 = dot(v110, f - vec3(1.0, 1.0, 0.0));\n\tfloat p111 = dot(v111, f - vec3(1.0, 1.0, 1.0));\n\tvec3 t = f * f * (3.0 - 2.0 * f);\n\treturn 0.5 + mix(mix(mix(p000, p100, t.x), mix(p010, p110, t.x), t.y), mix(mix(p001, p101, t.x), mix(p011, p111, t.x), t.y), t.z);\n}\n\nfloat tex3d_fbm_perlin_nowrap(vec3 coord, vec3 size, float seed) {\n\tvec3 o = floor(coord)+rand3(vec2(seed, 1.0-seed))+size;\n\tvec3 f = fract(coord);\n\tvec3 v000 = normalize(rand33(o)-vec3(0.5));\n\tvec3 v001 = normalize(rand33(o + vec3(0.0, 0.0, 1.0))-vec3(0.5));\n\tvec3 v010 = normalize(rand33(o + vec3(0.0, 1.0, 0.0))-vec3(0.5));\n\tvec3 v011 = normalize(rand33(o + vec3(0.0, 1.0, 1.0))-vec3(0.5));\n\tvec3 v100 = normalize(rand33(o + vec3(1.0, 0.0, 0.0))-vec3(0.5));\n\tvec3 v101 = normalize(rand33(o + vec3(1.0, 0.0, 1.0))-vec3(0.5));\n\tvec3 v110 = normalize(rand33(o + vec3(1.0, 1.0, 0.0))-vec3(0.5));\n\tvec3 v111 = normalize(rand33(o + vec3(1.0, 1.0, 1.0))-vec3(0.5));\n\tfloat p000 = dot(v000, f);\n\tfloat p001 = dot(v001, f - vec3(0.0, 0.0, 1.0));\n\tfloat p010 = dot(v010, f - vec3(0.0, 1.0, 0.0));\n\tfloat p011 = dot(v011, f - vec3(0.0, 1.0, 1.0));\n\tfloat p100 = dot(v100, f - vec3(1.0, 0.0, 0.0));\n\tfloat p101 = dot(v101, f - vec3(1.0, 0.0, 1.0));\n\tfloat p110 = dot(v110, f - vec3(1.0, 1.0, 0.0));\n\tfloat p111 = dot(v111, f - vec3(1.0, 1.0, 1.0));\n\tvec3 t = f * f * (3.0 - 2.0 * f);\n\treturn 0.5 + mix(mix(mix(p000, p100, t.x), mix(p010, p110, t.x), t.y), mix(mix(p001, p101, t.x), mix(p011, p111, t.x), t.y), t.z);\n}\n\nfloat tex3d_fbm_cellular(vec3 coord, vec3 size, float seed) {\n\tvec3 o = floor(coord)+rand3(vec2(seed, 1.0-seed))+size;\n\tvec3 f = fract(coord);\n\tfloat min_dist = 3.0;\n\tfor (float x = -1.0; x <= 1.0; x++) {\n\t\tfor (float y = -1.0; y <= 1.0; y++) {\n\t\t\tfor (float z = -1.0; z <= 1.0; z++) {\n\t\t\t\tvec3 node = 0.4*rand33(mod(o + vec3(x, y, z), size)) + vec3(x, y, z);\n\t\t\t\tfloat dist = sqrt((f - node).x * (f - node).x + (f - node).y * (f - node).y + (f - node).z * (f - node).z);\n\t\t\t\tmin_dist = min(min_dist, dist);\n\t\t\t}\n\t\t}\n\t}\n\treturn min_dist;\n}\n\nfloat tex3d_fbm_cellular_nowrap(vec3 coord, vec3 size, float seed) {\n\tvec3 o = floor(coord)+rand3(vec2(seed, 1.0-seed))+size;\n\tvec3 f = fract(coord);\n\tfloat min_dist = 3.0;\n\tfor (float x = -1.0; x <= 1.0; x++) {\n\t\tfor (float y = -1.0; y <= 1.0; y++) {\n\t\t\tfor (float z = -1.0; z <= 1.0; z++) {\n\t\t\t\tvec3 node = 0.4*rand33(o + vec3(x, y, z)) + vec3(x, y, z);\n\t\t\t\tfloat dist = sqrt((f - node).x * (f - node).x + (f - node).y * (f - node).y + (f - node).z * (f - node).z);\n\t\t\t\tmin_dist = min(min_dist, dist);\n\t\t\t}\n\t\t}\n\t}\n\treturn min_dist;\n}\nvec3 v4v4_rotate(vec3 p, vec3 a) {\n\tvec3 rv;\n\tfloat c;\n\tfloat s;\n\tc = cos(a.x);\n\ts = sin(a.x);\n\trv.x = p.x;\n\trv.y = p.y*c+p.z*s;\n\trv.z = -p.y*s+p.z*c;\n\tc = cos(a.y);\n\ts = sin(a.y);\n\tp.x = rv.x*c+rv.z*s;\n\tp.y = rv.y;\n\tp.z = -rv.x*s+rv.z*c;\n\tc = cos(a.z);\n\ts = sin(a.z);\n\trv.x = p.x*c+p.y*s;\n\trv.y = -p.x*s+p.y*c;\n\trv.z = p.z;\n\treturn rv;\n}\nfloat wave3d_constant(float x) {\n\treturn 1.0;\n}\n\nfloat wave3d_sine(float x) {\n\treturn 0.5-0.5*cos(3.14159265359*2.0*x);\n}\n\nfloat wave3d_triangle(float x) {\n\tx = fract(x);\n\treturn min(2.0*x, 2.0-2.0*x);\n}\n\nfloat wave3d_sawtooth(float x) {\n\treturn fract(x);\n}\n\nfloat wave3d_square(float x) {\n\treturn (fract(x) < 0.5) ? 0.0 : 1.0;\n}\n\nfloat wave3d_bounce(float x) {\n\tx = 2.0*(fract(x)-0.5);\n\treturn sqrt(1.0-x*x);\n}\n\nfloat mix3d_mul(float x, float y, float z) {\n\treturn x*y*z;\n}\n\nfloat mix3d_add(float x, float y, float z) {\n\treturn min(x+y+z, 1.0);\n}\n\nfloat mix3d_max(float x, float y, float z) {\n\treturn max(max(x, y), z);\n}\n\nfloat mix3d_min(float x, float y, float z) {\n\treturn min(min(x, y), z);\n}\n\nfloat mix3d_xor(float x, float y, float z) {\n\tfloat xy = min(x+y, 2.0-x-y);\n\treturn min(xy+z, 2.0-xy-z);\n}\n\nfloat mix3d_pow(float x, float y, float z) {\n\treturn pow(pow(x, y), z);\n}vec4 mfsdf3d_smooth_complex_union(vec4 a, vec4 b, float k, float shift,float colorContrast,float colorSmooth) {\n\t\n    k=clamp(k,0.01,1.0);\n    float h = max( k-abs(a.w-b.w), 0.0 )/k;\n\th=h*h*k*0.25;\n\t\n\tfloat invs=(1.0/colorContrast)/k; \n\tcolorSmooth=1.0/colorSmooth;\n\tvec3 c=mix(a.xyz,b.xyz,clamp((a.w*colorSmooth+shift+0.5-colorSmooth*0.5)*invs,0.0,1.0));\n\t\n\treturn vec4(c,min( a.w, b.w ) - h);\n}\n\nvec4 mfsdf3d_smooth_complex_subtraction(vec4 a, vec4 b, float k, float shift,float colorSmooth,float colorContrast) {\n\n    k=clamp(k,0.01,1.0);\n    float h = max( k-abs(-a.w-b.w), 0.0 )/k;\n\th=h*h*k*0.25;\n\t\n\tfloat invs=(1.0/colorContrast)/k; \n\tcolorSmooth=1.0/colorSmooth;\n\tvec3 c=mix(a.xyz,b.xyz,clamp((a.w*colorSmooth+shift+0.5-colorSmooth*0.5)*invs,0.0,1.0));\n\t\n\treturn vec4(c,max( -a.w, b.w ) + h);\n}\n\nvec4 mfsdf3d_smooth_complex_intersection(vec4 a, vec4 b, float k, float shift,float colorSmooth,float colorContrast) {\n\n    k=clamp(k,0.01,1.0);\n    float h = max( k-abs(a.w-b.w), 0.0 )/k;\n\th=h*h*k*0.25;\n\n\tfloat invs=(1.0/colorContrast)/k; \n\tcolorSmooth=1.0/colorSmooth;\n\tvec3 c=mix(a.xyz,b.xyz,clamp((a.w*colorSmooth+shift+0.5-colorSmooth*0.5)*invs+1.0,0.0,1.0));\n\t\n\treturn vec4(c,max( a.w, b.w ) + h);\n    //return vec4(mix(a.xyz,b.xyz,clamp(a.w*invs/k+1.0-shift*invs/k,0.0,1.0)),max( a.w, b.w ) + h);\n}const float PI=3.14159265359;\n\nvec2 equirectangularMap(vec3 dir) {\n\tvec2 longlat = vec2(atan(dir.y,dir.x),acos(dir.z));\n \treturn longlat/vec2(2.0*PI,PI);\n}\n\n\n//Simple HDRI START\n\n//Hash without Sine Dave_Hoskins\n//https://www.shadertoy.com/view/4djSRW \nfloat Simple360HDR_hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat Simple360HDR_noise(vec2 v){\n  vec2 v1=floor(v);\n  vec2 v2=smoothstep(0.0,1.0,fract(v));\n  float n00=Simple360HDR_hash12(v1);\n  float n01=Simple360HDR_hash12(v1+vec2(0,1));\n  float n10=Simple360HDR_hash12(v1+vec2(1,0));\n  float n11=Simple360HDR_hash12(v1+vec2(1,1));\n  return mix(mix(n00,n01,v2.y),mix(n10,n11,v2.y),v2.x);\n}\n\nfloat Simple360HDR_noiseOct(vec2 p){\n  return\n    Simple360HDR_noise(p)*0.5+\n    Simple360HDR_noise(p*2.0+13.0)*0.25+\n    Simple360HDR_noise(p*4.0+23.0)*0.15+\n    Simple360HDR_noise(p*8.0+33.0)*0.10+\n    Simple360HDR_noise(p*16.0+43.0)*0.05;\n}\n\nvec3 Simple360HDR_skyColor(vec3 p){\n\tvec3 s1=vec3(0.2,0.5,1.0);\n\tvec3 s2=vec3(0.1,0.2,0.4)*1.5;\n    vec3 v=(Simple360HDR_noiseOct(p.xz*0.1)-0.5)*vec3(1.0);\n\tfloat d=length(p);\n    return mix(s2+v,s1+v*(12.0/max(d,20.0)),clamp(d*0.1,0.0,1.0));\n}\n\nvec3 Simple360HDR_floorColor(vec3 p){\n    vec3 v=(Simple360HDR_noiseOct(p.xz*0.1)*0.5+0.25)*vec3(0.7,0.5,0.4);\n    return v;\n}\n\nvec3 Simple360HDR_renderHDR360(vec3 rd, vec3 sun){\n    vec3 col;\n\tvec3 p;\n\tvec3 c;\n\tif (rd.y>0.0) {\n        p=rd*(5.0/rd.y);\n        c=Simple360HDR_skyColor(p);\n    } else {\n        p=rd*(-10.0/rd.y);\n        c=Simple360HDR_floorColor(p);\n\t\tc=mix(c,vec3(0.5,0.7,1.0),clamp(1.0-sqrt(-rd.y)*3.0,0.0,1.0));\n\t}\n\tvec3 skycolor=vec3(0.1,0.45,0.68);\n\tfloat d=length(p);\n\t\n\tfloat ds=clamp(dot(sun,rd),0.0,1.0);\n\tvec3 sunc=(ds>0.9997?vec3(2.0):vec3(0.0))+pow(ds,512.0)*4.0+pow(ds,128.0)*vec3(0.5)+pow(ds,4.0)*vec3(0.5);\n    if (rd.y>0.0){\n\t\tc+=vec3(0.3)*pow(1.0-abs(rd.y),3.0)*0.7;\n\t} \n    return c+sunc;\n}\n\nvec3 Simple360HDR_make360hdri(vec2 p, vec3 sun){\n    float xPI=3.14159265359;\n    vec2 thetaphi = ((p * 2.0) - vec2(1.0)) * vec2(xPI,xPI/2.0); \n    vec3 rayDirection = vec3(cos(thetaphi.y) * cos(thetaphi.x), sin(thetaphi.y), cos(thetaphi.y) * sin(thetaphi.x));\n    return Simple360HDR_renderHDR360(rayDirection,sun);\n}\n//Simple HDRI END\n\nconst float p_o22148_CamX = 2.500000000;\nconst float p_o22148_CamY = 0.410000000;\nconst float p_o22148_CamZ = 8.080000000;\nconst float p_o22148_LookAtX = -0.993000000;\nconst float p_o22148_LookAtY = 0.515000000;\nconst float p_o22148_LookAtZ = -2.500000000;\nconst float p_o22148_CamD = 1.500000000;\nconst float p_o22148_CamZoom = 1.000000000;\nconst float p_o22148_SunX = 2.500000000;\nconst float p_o22148_SunY = 2.500000000;\nconst float p_o22148_SunZ = 2.500000000;\nconst float p_o22148_AmbLight = 0.000000000;\nconst float p_o22148_AmbOcclusion = 1.000000000;\nconst float p_o22148_Shadow = 0.457000000;\nconst float p_o22148_Gamma = 1.300000000;\nconst float p_o252591_k = 0.378000000;\nconst float p_o252591_shift = 0.000000000;\nconst float p_o252591_colorSmooth = 1.000000000;\nconst float p_o252591_colorContrast = 0.000000000;\nconst float p_o30069_BaseColor_r = 1.000000000;\nconst float p_o30069_BaseColor_g = 1.000000000;\nconst float p_o30069_BaseColor_b = 1.000000000;\nconst float p_o30069_BaseColor_a = 1.000000000;\nconst float p_o30069_Metallic = 1.000000000;\nconst float p_o30069_Specular = 0.500000000;\nconst float p_o30069_Roughness = 0.000000000;\nconst float p_o30069_Emission = 96.799000000;\nconst float p_o30069_Normal = 0.000000000;\nconst float p_o30069_Alpha = 0.000000000;\nconst float p_o30069_AmbientOcclusion = 1.000000000;\nconst float p_o30069_scale = 1.000000000;\nconst float p_o220169_g_0_pos = 0.000000000;\nconst float p_o220169_g_0_r = 0.000000000;\nconst float p_o220169_g_0_g = 0.578125000;\nconst float p_o220169_g_0_b = 0.429077148;\nconst float p_o220169_g_0_a = 1.000000000;\nconst float p_o220169_g_1_pos = 1.000000000;\nconst float p_o220169_g_1_r = 0.000000000;\nconst float p_o220169_g_1_g = 0.078125000;\nconst float p_o220169_g_1_b = 0.039672852;\nconst float p_o220169_g_1_a = 1.000000000;\nvec4 o220169_g_gradient_fct(float x) {\n  if (x < p_o220169_g_0_pos) {\n    return vec4(p_o220169_g_0_r,p_o220169_g_0_g,p_o220169_g_0_b,p_o220169_g_0_a);\n  } else if (x < p_o220169_g_1_pos) {\n    return mix(vec4(p_o220169_g_0_r,p_o220169_g_0_g,p_o220169_g_0_b,p_o220169_g_0_a), vec4(p_o220169_g_1_r,p_o220169_g_1_g,p_o220169_g_1_b,p_o220169_g_1_a), ((x-p_o220169_g_0_pos)/(p_o220169_g_1_pos-p_o220169_g_0_pos)));\n  }\n  return vec4(p_o220169_g_1_r,p_o220169_g_1_g,p_o220169_g_1_b,p_o220169_g_1_a);\n}\nconst float seed_o218870 = 0.000000000;\nconst float p_o218870_scale_x = 8.000000000;\nconst float p_o218870_scale_y = 8.000000000;\nconst float p_o218870_scale_z = 8.000000000;\nconst float p_o218870_iterations = 1.000000000;\nconst float p_o218870_persistence = 0.500000000;\nfloat o218870_fbm(vec3 coord, vec3 size, int octaves, float persistence, float seed, float _seed_variation_) {\n\tfloat normalize_factor = 0.0;\n\tfloat value = 0.0;\n\tfloat scale = 1.0;\n\tfor (int i = 0; i < octaves; i++) {\n\t\tvalue += tex3d_fbm_cellular_nowrap(coord*size, size, seed) * scale;\n\t\tnormalize_factor += scale;\n\t\tsize *= 2.0;\n\t\tscale *= persistence;\n\t}\n\treturn value / normalize_factor;\n}\nvec3 o30069_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\nfloat o218870_0_1_tex3d_gs = o218870_fbm((p).xyz, vec3(p_o218870_scale_x, p_o218870_scale_y, p_o218870_scale_z), int(p_o218870_iterations), p_o218870_persistence, float((seed_o218870+_seed_variation_)), _seed_variation_);\nvec3 o220169_0_1_tex3d = o220169_g_gradient_fct(dot(vec3(o218870_0_1_tex3d_gs), vec3(1.0))/3.0).rgb;\n\nreturn o220169_0_1_tex3d;\n}\nfloat o30069_input_Metallic_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o30069_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o30069_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nvec3 o30069_input_Emission_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0,1.0,1.0);\n}\nvec3 o30069_input_Normal_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(0.0,1.0,0.0);\n}\nfloat o30069_input_Alpha_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o30069_input_AmbientOcclusion_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nconst float p_o36040_l = 0.320000000;\nfloat o112765_input_obj3d(vec3 p, float _seed_variation_) {\nvec3 o36040_0_p = (p);\no36040_0_p.x -= clamp(o36040_0_p.x, -p_o36040_l, p_o36040_l);\nfloat o36040_0_1_sdf3d = length(o36040_0_p)-(0.2+0.1*sin(iTime))*1.0;\n\nreturn o36040_0_1_sdf3d;\n}\nconst float p_o152951_x = 0.382000000;\nconst float p_o152951_y = 0.673000000;\nconst float p_o152951_z = 0.000000000;\nconst float p_o145115_ax = 59.000000000;\nconst float p_o145115_az = 18.000000000;\nvec4 o112765_input_trans3d(vec4 p, float _seed_variation_) {\nvec4 o129370_0_1_v4v4 = (vec4(vec3(abs((vec4(v4v4_rotate((vec4((p).xyz-vec3(p_o152951_x, p_o152951_y, p_o152951_z),(p).w)).xyz, -vec3(p_o145115_ax, (iTime*10.0), p_o145115_az)*0.01745329251), (vec4((p).xyz-vec3(p_o152951_x, p_o152951_y, p_o152951_z),(p).w)).w)).xy),(vec4(v4v4_rotate((vec4((p).xyz-vec3(p_o152951_x, p_o152951_y, p_o152951_z),(p).w)).xyz, -vec3(p_o145115_ax, (iTime*10.0), p_o145115_az)*0.01745329251), (vec4((p).xyz-vec3(p_o152951_x, p_o152951_y, p_o152951_z),(p).w)).w)).z),(vec4(v4v4_rotate((vec4((p).xyz-vec3(p_o152951_x, p_o152951_y, p_o152951_z),(p).w)).xyz, -vec3(p_o145115_ax, (iTime*10.0), p_o145115_az)*0.01745329251), (vec4((p).xyz-vec3(p_o152951_x, p_o152951_y, p_o152951_z),(p).w)).w)).w));\nvec4 o124762_0_1_v4v4 = o129370_0_1_v4v4;\nvec4 o145115_0_1_v4v4 = o124762_0_1_v4v4;\nvec4 o152951_0_1_v4v4 = o145115_0_1_v4v4;\n\nreturn o152951_0_1_v4v4;\n}\nfloat o112765_input_custombool(vec2 uv, float _seed_variation_) {\n\nreturn min((uv).x,(uv).y);\n}\nfloat for_fold_o112765(vec4 p, float _seed_variation_) {\n  for(int i=0;i<6;i++){\n    p=o112765_input_trans3d(p, _seed_variation_);\n  }\n  return o112765_input_obj3d(p.xyz, _seed_variation_)/p.w;\n}\n\nfloat for_min_o112765(vec4 p, float _seed_variation_) {\n  float d=o112765_input_obj3d(p.xyz, _seed_variation_);\n  float m=min(999999.0,d);\n  for(int i=0;i<6;i++){\n    p=o112765_input_trans3d(p, _seed_variation_);\n\td=o112765_input_obj3d(p.xyz, _seed_variation_);\n\tm=min(m,d/p.w);\n  }\n  return m;\n}\n\nfloat for_custom_o112765(vec4 p, float _seed_variation_) {\n  float d=o112765_input_obj3d(p.xyz, _seed_variation_);\n  float m=o112765_input_custombool(vec2(999999.0,d), _seed_variation_);\n  for(int i=0;i<6;i++){\n    p=o112765_input_trans3d(p, _seed_variation_);\n\td=o112765_input_obj3d(p.xyz, _seed_variation_);\n\tm=o112765_input_custombool(vec2(m,d/p.w), _seed_variation_);\n  }\n  return m;\n}float o30069_input_sdf3d(vec3 p, float _seed_variation_) {\nfloat o112765_0_1_sdf3d = for_min_o112765(vec4((p),1.0), _seed_variation_);\n\nreturn o112765_0_1_sdf3d;\n}\n// 0 - SDF                    (0,0,0,sdf)\n// 1 - BaseColor              (r,g,b,sdf) linear (0-1) \n// 2 - Metallic               (v,0,0,sdf)\n// 4 - Specular               (v,0,0,sdf)\n// 5 - Roughness              (v,0,0,sdf)\n//13 - Emission\t              (r,g,b,sdf) linear (0-infinite)\n//14 - Normal                 (x,y,z,sdf)\n//15 - Alpha                  (v,0,0,sdf)\n//19 - Ambient Occlusion      (v,0,0,sdf) \n//999 - Table ID - Identifies this table (0,0,0,0)\n\nvec4 PBRObjectMaker_o30069(vec4 uv, float _seed_variation_) {\n\tfloat sdf=o30069_input_sdf3d(uv.xyz/p_o30069_scale, _seed_variation_)*p_o30069_scale;\n\t//19 - Ambient Occlusion\n\tif (uv.w>18.5) {\n\t\treturn vec4(p_o30069_AmbientOcclusion*o30069_input_AmbientOcclusion_tex3d(vec4(uv.xyz,19.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//15 - Alpha\n\tif (uv.w>14.5) {\n\t\treturn vec4(p_o30069_Alpha*o30069_input_Alpha_tex3d(vec4(uv.xyz,15.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//14 - Normal\n\tif (uv.w>13.5) {\n\t\treturn vec4(p_o30069_Normal*o30069_input_Normal_tex3d(vec4(uv.xyz,14.0), _seed_variation_),sdf);\n\t} else\n\t//13 - Emission\n\tif (uv.w>12.5) {\n\t\treturn vec4(p_o30069_Emission*o30069_input_Emission_tex3d(vec4(uv.xyz,13.0), _seed_variation_),sdf);\n\t} else\n\t//5 - Roughness\n\tif (uv.w>4.5) {\n\t\treturn vec4(p_o30069_Roughness*o30069_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o30069_Specular*o30069_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//2 - Metallic\n\tif (uv.w>1.5) {\n\t\treturn vec4(p_o30069_Metallic*o30069_input_Metallic_tex3d(vec4(uv.xyz,2.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(vec4(p_o30069_BaseColor_r, p_o30069_BaseColor_g, p_o30069_BaseColor_b, p_o30069_BaseColor_a).rgb*o30069_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}const float p_o304294_az = 0.000000000;\nconst float p_o51021_BaseColor_r = 1.000000000;\nconst float p_o51021_BaseColor_g = 1.000000000;\nconst float p_o51021_BaseColor_b = 1.000000000;\nconst float p_o51021_BaseColor_a = 1.000000000;\nconst float p_o51021_Metallic = 0.000000000;\nconst float p_o51021_Specular = 0.000000000;\nconst float p_o51021_Roughness = 1.000000000;\nconst float p_o51021_Emission = 96.799000000;\nconst float p_o51021_Normal = 0.000000000;\nconst float p_o51021_Alpha = 0.000000000;\nconst float p_o51021_AmbientOcclusion = 1.000000000;\nconst float p_o51021_scale = 1.000000000;\nconst float p_o278148_g_0_pos = 0.295868475;\nconst float p_o278148_g_0_r = 1.000000000;\nconst float p_o278148_g_0_g = 0.000000000;\nconst float p_o278148_g_0_b = 0.000000000;\nconst float p_o278148_g_0_a = 1.000000000;\nconst float p_o278148_g_1_pos = 0.692562589;\nconst float p_o278148_g_1_r = 0.000000000;\nconst float p_o278148_g_1_g = 0.000000000;\nconst float p_o278148_g_1_b = 0.000000000;\nconst float p_o278148_g_1_a = 1.000000000;\nvec4 o278148_g_gradient_fct(float x) {\n  if (x < p_o278148_g_0_pos) {\n    return vec4(p_o278148_g_0_r,p_o278148_g_0_g,p_o278148_g_0_b,p_o278148_g_0_a);\n  } else if (x < p_o278148_g_1_pos) {\n    return mix(vec4(p_o278148_g_0_r,p_o278148_g_0_g,p_o278148_g_0_b,p_o278148_g_0_a), vec4(p_o278148_g_1_r,p_o278148_g_1_g,p_o278148_g_1_b,p_o278148_g_1_a), ((x-p_o278148_g_0_pos)/(p_o278148_g_1_pos-p_o278148_g_0_pos)));\n  }\n  return vec4(p_o278148_g_1_r,p_o278148_g_1_g,p_o278148_g_1_b,p_o278148_g_1_a);\n}\nconst float seed_o271080 = 0.000000000;\nconst float p_o271080_scale_x = 2.000000000;\nconst float p_o271080_scale_y = 2.000000000;\nconst float p_o271080_scale_z = 2.000000000;\nconst float p_o271080_iterations = 1.000000000;\nconst float p_o271080_persistence = 0.500000000;\nfloat o271080_fbm(vec3 coord, vec3 size, int octaves, float persistence, float seed, float _seed_variation_) {\n\tfloat normalize_factor = 0.0;\n\tfloat value = 0.0;\n\tfloat scale = 1.0;\n\tfor (int i = 0; i < octaves; i++) {\n\t\tvalue += tex3d_fbm_perlin_nowrap(coord*size, size, seed) * scale;\n\t\tnormalize_factor += scale;\n\t\tsize *= 2.0;\n\t\tscale *= persistence;\n\t}\n\treturn value / normalize_factor;\n}\nvec3 o51021_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\nfloat o271080_0_1_tex3d_gs = o271080_fbm((p).xyz, vec3(p_o271080_scale_x, p_o271080_scale_y, p_o271080_scale_z), int(p_o271080_iterations), p_o271080_persistence, float((seed_o271080+_seed_variation_)), _seed_variation_);\nvec3 o278148_0_1_tex3d = o278148_g_gradient_fct(dot(vec3(o271080_0_1_tex3d_gs), vec3(1.0))/3.0).rgb;\n\nreturn o278148_0_1_tex3d;\n}\nfloat o51021_input_Metallic_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o51021_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o51021_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nvec3 o51021_input_Emission_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0,1.0,1.0);\n}\nvec3 o51021_input_Normal_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(0.0,1.0,0.0);\n}\nfloat o51021_input_Alpha_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o51021_input_AmbientOcclusion_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nconst float p_o313831_Distort = 0.167000000;\nconst float p_o313831_Correction = 0.000000000;\nconst float p_o313831_Bound = 0.000000000;\nconst float p_o240845_R = 2.010000000;\nconst float p_o240845_r = 0.740000000;\nfloat o313831_input_sdf(vec3 p, float _seed_variation_) {\nvec2 o240845_0_q = vec2(length((p).xy)-p_o240845_R,(p).z);\nfloat o240845_0_1_sdf3d = length(o240845_0_q)-p_o240845_r;\n\nreturn o240845_0_1_sdf3d;\n}\nconst float p_o318294_x_scale = 2.000000000;\nconst float p_o318294_y_scale = 2.000000000;\nconst float p_o318294_z_scale = 2.000000000;\nfloat o318294_fct(vec3 uv, float _seed_variation_) {\n\treturn mix3d_max(wave3d_triangle(p_o318294_x_scale*uv.x), wave3d_triangle(p_o318294_y_scale*uv.y), wave3d_triangle(p_o318294_z_scale*uv.z));\n}vec3 o313831_input_tex3d(vec4 p, float _seed_variation_) {\nvec3 o318294_0_1_tex3d = vec3(o318294_fct((p).xyz, _seed_variation_));\n\nreturn o318294_0_1_tex3d;\n}\n//tetrahedron normal by PauloFalcao\n//https://www.shadertoy.com/view/XstGDS\nvec3 normal_o313831(vec3 p, float _seed_variation_) {  \n  const vec3 e=vec3(0.001,-0.001,0.0);\n  float v1=o313831_input_sdf(p+e.xyy, _seed_variation_);\n  float v2=o313831_input_sdf(p+e.yyx, _seed_variation_);\n  float v3=o313831_input_sdf(p+e.yxy, _seed_variation_);\n  float v4=o313831_input_sdf(p+e.xxx, _seed_variation_);\n  return normalize(vec3(v4+v1-v3-v2,v3+v4-v1-v2,v2+v4-v3-v1));\n}\n\nfloat distortByNormal_o313831(vec3 uv, float _seed_variation_) {\n    float d=o313831_input_sdf(uv, _seed_variation_);\n\tif (d<=abs(p_o313831_Distort*(p_o313831_Bound+1.0))+0.01){\n\t\tvec3 n=normal_o313831(uv, _seed_variation_);\n\t\tvec3 s=o313831_input_tex3d(vec4(uv,0.0), _seed_variation_);\n\t\treturn o313831_input_sdf(uv-(n*s*p_o313831_Distort), _seed_variation_);\n\t} else return d;\n}\nfloat o51021_input_sdf3d(vec3 p, float _seed_variation_) {\nfloat o313831_0_1_sdf3d = distortByNormal_o313831((p), _seed_variation_)/(1.0+p_o313831_Distort*p_o313831_Correction);\n\nreturn o313831_0_1_sdf3d;\n}\n// 0 - SDF                    (0,0,0,sdf)\n// 1 - BaseColor              (r,g,b,sdf) linear (0-1) \n// 2 - Metallic               (v,0,0,sdf)\n// 4 - Specular               (v,0,0,sdf)\n// 5 - Roughness              (v,0,0,sdf)\n//13 - Emission\t              (r,g,b,sdf) linear (0-infinite)\n//14 - Normal                 (x,y,z,sdf)\n//15 - Alpha                  (v,0,0,sdf)\n//19 - Ambient Occlusion      (v,0,0,sdf) \n//999 - Table ID - Identifies this table (0,0,0,0)\n\nvec4 PBRObjectMaker_o51021(vec4 uv, float _seed_variation_) {\n\tfloat sdf=o51021_input_sdf3d(uv.xyz/p_o51021_scale, _seed_variation_)*p_o51021_scale;\n\t//19 - Ambient Occlusion\n\tif (uv.w>18.5) {\n\t\treturn vec4(p_o51021_AmbientOcclusion*o51021_input_AmbientOcclusion_tex3d(vec4(uv.xyz,19.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//15 - Alpha\n\tif (uv.w>14.5) {\n\t\treturn vec4(p_o51021_Alpha*o51021_input_Alpha_tex3d(vec4(uv.xyz,15.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//14 - Normal\n\tif (uv.w>13.5) {\n\t\treturn vec4(p_o51021_Normal*o51021_input_Normal_tex3d(vec4(uv.xyz,14.0), _seed_variation_),sdf);\n\t} else\n\t//13 - Emission\n\tif (uv.w>12.5) {\n\t\treturn vec4(p_o51021_Emission*o51021_input_Emission_tex3d(vec4(uv.xyz,13.0), _seed_variation_),sdf);\n\t} else\n\t//5 - Roughness\n\tif (uv.w>4.5) {\n\t\treturn vec4(p_o51021_Roughness*o51021_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o51021_Specular*o51021_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//2 - Metallic\n\tif (uv.w>1.5) {\n\t\treturn vec4(p_o51021_Metallic*o51021_input_Metallic_tex3d(vec4(uv.xyz,2.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(vec4(p_o51021_BaseColor_r, p_o51021_BaseColor_g, p_o51021_BaseColor_b, p_o51021_BaseColor_a).rgb*o51021_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}const float seed_o265866 = 0.000000000;\nconst float p_o265866_scale_x = 8.000000000;\nconst float p_o265866_scale_y = 8.000000000;\nconst float p_o265866_scale_z = 8.000000000;\nconst float p_o265866_iterations = 1.000000000;\nconst float p_o265866_persistence = 0.500000000;\nfloat o265866_fbm(vec3 coord, vec3 size, int octaves, float persistence, float seed, float _seed_variation_) {\n\tfloat normalize_factor = 0.0;\n\tfloat value = 0.0;\n\tfloat scale = 1.0;\n\tfor (int i = 0; i < octaves; i++) {\n\t\tvalue += tex3d_fbm_value(coord*size, size, seed) * scale;\n\t\tnormalize_factor += scale;\n\t\tsize *= 2.0;\n\t\tscale *= persistence;\n\t}\n\treturn value / normalize_factor;\n}\nvec4 o22148_input_mfsdf(vec4 p, float _seed_variation_) {\nvec4 o30069_0_1_v4v4 = PBRObjectMaker_o30069((p), _seed_variation_);\nvec4 o51021_0_1_v4v4 = PBRObjectMaker_o51021((vec4(v4v4_rotate((p).xyz, -vec3((iTime*20.0), (iTime*57.0), p_o304294_az)*0.01745329251), (p).w)), _seed_variation_);\nvec4 o304294_0_1_v4v4 = o51021_0_1_v4v4;\nfloat o265866_0_1_tex3d_gs = o265866_fbm((p).xyz, vec3(p_o265866_scale_x, p_o265866_scale_y, p_o265866_scale_z), int(p_o265866_iterations), p_o265866_persistence, float((seed_o265866+_seed_variation_)), _seed_variation_);\nvec4 o252591_0_1_v4v4 = mfsdf3d_smooth_complex_union(o30069_0_1_v4v4, o304294_0_1_v4v4,p_o252591_k,-p_o252591_shift-(o265866_0_1_tex3d_gs*0.5),max((1.0-p_o252591_colorContrast),0.001),max(p_o252591_colorSmooth,0.001));\n\nreturn o252591_0_1_v4v4;\n}\nvec3 o22148_input_hdri(vec2 uv, float _seed_variation_) {\n\nreturn Simple360HDR_make360hdri(vec2((uv).x,-(uv).y+1.0),normalize(vec3(-p_o22148_SunX,p_o22148_SunY,-p_o22148_SunZ)));\n}\n\n//tetrahedron normal by PauloFalcao\n//https://www.shadertoy.com/view/XstGDS\nvec3 normal_o22148(vec3 p, float _seed_variation_) {  \n  const vec3 e=vec3(0.001,-0.001,0.0);\n  float v1=o22148_input_mfsdf(vec4(p+e.xyy,0.0), _seed_variation_).w;\n  float v2=o22148_input_mfsdf(vec4(p+e.yyx,0.0), _seed_variation_).w;\n  float v3=o22148_input_mfsdf(vec4(p+e.yxy,0.0), _seed_variation_).w;\n  float v4=o22148_input_mfsdf(vec4(p+e.xxx,0.0), _seed_variation_).w;\n  return normalize(vec3(v4+v1-v3-v2,v3+v4-v1-v2,v2+v4-v3-v1));\n}\n\nvoid march_o22148(inout float d,inout vec3 p,float dS, vec3 ro, vec3 rd, float _seed_variation_) {\n    for (int i=0; i < 500; i++) {\n    \tp = ro + rd*d;\n        dS = o22148_input_mfsdf(vec4(p,0.0), _seed_variation_).w;\n        d += dS;\n        if (d > 50.0 || abs(dS) < 0.0001) break;\n    }\n}\n\n//from https://www.shadertoy.com/view/lsKcDD\nfloat calcAO_o22148( in vec3 pos, in vec3 nor , float _seed_variation_) {\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ ){\n        float h = 0.001 + 0.25*float(i)/4.0;\n        float d = o22148_input_mfsdf(vec4( pos + h*nor ,0.0), _seed_variation_).w;\n        occ += (h-d)*sca;\n        sca *= 0.98;\n    }\n    return clamp( 1.0 - 1.6*occ, 0.0, 1.0 );    \n}\n\n//from https://www.shadertoy.com/view/lsKcDD\nfloat calcSoftshadow_o22148( in vec3 ro, in vec3 rd, in float mint, in float tmax, float _seed_variation_) {\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    for( int i=0; i<32; i++ ){\n\t\tfloat h = o22148_input_mfsdf(vec4( ro + rd*t ,0.0), _seed_variation_).w;\n        res = min( res, 10.0*h/t );\n        t += h;\n        if( res<0.0001 || t>tmax ) break;  \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 raymarch_o22148(vec2 uv, float _seed_variation_) {\n    uv-=0.5;\n\tvec3 cam=vec3(p_o22148_CamX,p_o22148_CamY,p_o22148_CamZ)*p_o22148_CamZoom;\n\tvec3 lookat=vec3(p_o22148_LookAtX,p_o22148_LookAtY,p_o22148_LookAtZ);\n\tvec3 ray=normalize(lookat-cam);\n\tvec3 cX=normalize(cross(vec3(0.0,1.0,0.0),ray));\n\tvec3 cY=normalize(cross(cX,ray));\n\tvec3 rd = normalize(ray*p_o22148_CamD+cX*uv.x+cY*uv.y);\n\tvec3 ro = cam;\n\t\n\tfloat d=0.;\n\tvec3 p=vec3(0);\n\tfloat dS=0.0;\n\tmarch_o22148(d,p,dS,ro,rd, _seed_variation_);\n\t\n    vec3 color=vec3(0.0);\n\tvec3 objColor=o22148_input_mfsdf(vec4(p,1.0), _seed_variation_).xyz;   // 1 - BaseColor (r,g,b,sdf) linear (0-1) \n\tfloat objSpecular=o22148_input_mfsdf(vec4(p,4.0), _seed_variation_).x*0.2;  // 4 - Specular  (v,0,0,sdf)\n\tfloat objRoughness=o22148_input_mfsdf(vec4(p,5.0), _seed_variation_).x; // 5 - Roughness (v,0,0,sdf)\n\tvec3 light=normalize(vec3(p_o22148_SunX,p_o22148_SunY,p_o22148_SunZ));\n\tif (d<50.0) {\n\t    vec3 n=normal_o22148(p, _seed_variation_);\n\t\tfloat l=clamp(dot(-light,-n),0.0,1.0);\n\t\tvec3 ref=normalize(reflect(rd,-n));\n\t\tfloat r=clamp(dot(ref,light),0.0,1.0);\n\t\tfloat cAO=mix(1.0,calcAO_o22148(p,n, _seed_variation_),p_o22148_AmbOcclusion);\n\t\tfloat shadow=mix(1.0,calcSoftshadow_o22148(p,light,0.05,5.0, _seed_variation_),p_o22148_Shadow);\n\t\tcolor=min(vec3(max(shadow,p_o22148_AmbLight)),max(l,p_o22148_AmbLight))*max(cAO,p_o22148_AmbLight)*objColor+4.0*pow(r,pow(256.0,(1.0-objRoughness)))*objSpecular;\n\t\t//reflection\n\t\td=0.01;\n\t\tmarch_o22148(d,p,dS,p,ref, _seed_variation_);\n\t\tvec3 objColorRef=vec3(0);\n\t\tif (d<50.0) {\n\t\t\tobjColorRef=o22148_input_mfsdf(vec4(p,1.0), _seed_variation_).xyz;\n\t\t\tn=normal_o22148(p, _seed_variation_);\n\t\t\tl=clamp(dot(-light,-n),0.0,1.0);\n\t\t\tobjColorRef=max(l,p_o22148_AmbLight)*objColorRef;\n\t\t} else {\n\t\t\tobjColorRef=o22148_input_hdri(equirectangularMap(ref.xzy), _seed_variation_).xyz;\n\t\t}\n\t\tcolor=mix(color,objColorRef,objSpecular);\n\t} else {\n\t\tcolor=o22148_input_hdri(equirectangularMap(rd.xzy), _seed_variation_).xyz;\n\t}\n\treturn pow(color,vec3(1.0/p_o22148_Gamma));\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\nfloat minSize = min(iResolution.x, iResolution.y);\nfloat _seed_variation_ = SEED_VARIATION;\nvec2 UV = vec2(0.0, 1.0) + vec2(1.0, -1.0) * (fragCoord-0.5*(iResolution.xy-vec2(minSize)))/minSize;\nvec3 o22148_0_1_rgb = raymarch_o22148((UV), _seed_variation_);\nfragColor = vec4(o22148_0_1_rgb, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fldGRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 70, 90, 90, 169], [171, 171, 191, 191, 324], [326, 326, 346, 346, 535], [537, 537, 559, 559, 856], [858, 858, 880, 880, 1040], [1042, 1042, 1101, 1101, 1155], [1156, 1156, 1178, 1178, 1246], [1247, 1247, 1267, 1267, 1436], [1438, 1438, 1496, 1496, 2182], [2184, 2184, 2249, 2249, 2847], [2849, 2849, 2908, 2908, 4138], [4140, 4140, 4206, 4206, 5348], [5350, 5350, 5411, 5411, 5889], [5891, 5891, 5959, 5959, 6426], [6427, 6427, 6461, 6461, 6765], [6766, 6766, 6798, 6798, 6813], [6815, 6815, 6843, 6843, 6887], [6889, 6889, 6921, 6921, 6969], [6971, 6971, 7003, 7003, 7023], [7025, 7025, 7055, 7055, 7095], [7097, 7097, 7127, 7127, 7177], [7179, 7179, 7223, 7223, 7240], [7242, 7242, 7286, 7286, 7313], [7315, 7315, 7359, 7359, 7388], [7390, 7390, 7434, 7434, 7463], [7465, 7465, 7509, 7509, 7571], [7573, 7573, 7617, 7617, 7646], [7646, 7646, 7757, 7757, 8042], [8044, 8044, 8161, 8161, 8447], [8449, 8449, 8567, 8567, 8954], [8985, 8985, 9020, 9020, 9109], [9133, 9207, 9242, 9242, 9359], [9361, 9361, 9394, 9394, 9690], [9692, 9692, 9728, 9728, 9935], [9937, 9937, 9972, 9972, 10181], [10183, 10183, 10220, 10220, 10309], [10311, 10311, 10361, 10361, 10908], [10910, 10910, 10958, 10958, 11228], [11229, 13062, 13100, 13100, 13558], [13831, 13831, 13941, 13941, 14226], [14227, 14227, 14294, 14294, 14646], [14647, 14647, 14714, 14714, 14729], [14730, 14730, 14797, 14797, 14812], [14813, 14813, 14881, 14881, 14896], [14897, 14897, 14963, 14963, 14992], [14993, 14993, 15057, 15057, 15086], [15087, 15087, 15151, 15151, 15166], [15167, 15167, 15242, 15242, 15257], [15296, 15296, 15355, 15355, 15538], [15738, 15738, 15798, 15798, 16672], [16673, 16673, 16738, 16738, 16768], [16769, 16769, 16825, 16825, 16964], [16966, 16966, 17021, 17021, 17262], [17264, 17264, 17322, 17322, 17653], [17653, 17653, 17711, 17711, 17816], [17817, 18282, 18343, 18343, 19766], [20794, 20794, 20832, 20832, 21290], [21563, 21563, 21673, 21673, 21956], [21957, 21957, 22024, 22024, 22376], [22377, 22377, 22444, 22444, 22459], [22460, 22460, 22527, 22527, 22542], [22543, 22543, 22611, 22611, 22626], [22627, 22627, 22693, 22693, 22722], [22723, 22723, 22787, 22787, 22816], [22817, 22817, 22881, 22881, 22896], [22897, 22897, 22972, 22972, 22987], [23202, 23202, 23259, 23259, 23406], [23542, 23542, 23594, 23594, 23738], [23738, 23738, 23796, 23796, 23896], [23897, 23973, 24026, 24026, 24360], [24362, 24362, 24426, 24426, 24742], [24743, 24743, 24801, 24801, 24949], [24950, 25415, 25476, 25476, 26899], [27171, 27171, 27281, 27281, 27556], [27557, 27557, 27614, 27614, 28357], [28358, 28358, 28415, 28415, 28538], [28540, 28616, 28668, 28668, 29054], [29056, 29056, 29154, 29154, 29348], [29350, 29395, 29468, 29468, 29769], [29771, 29816, 29924, 29924, 30275], [30277, 30277, 30332, 30332, 32325], [32326, 32326, 32381, 32381, 32678]]}
{"id": "fs3SDj", "name": "Rocks1", "author": "rudros", "description": "Very small but (hopefully) readable ray-caster", "tags": ["raycasting", "mini"], "likes": 0, "viewed": 56, "published": "Public", "date": "1633931043", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415326\n\nmat2 rotate2D(float r) {\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\nfloat distanceTo(vec3 p, float waveNum) {\n    float frequency = exp(waveNum);\n    //p.xz *= rotate2D(PI/3.);\n    return abs(cos(p.x*frequency*PI)+sin(p.z*frequency*PI))/frequency;\n}\n\nfloat totalDistance(vec3 p) {\n    // Initial distace\n    float total = p.y;\n    // This loop determines the number of waves being combined\n    for(float j=0.; j < mod(iTime, 15.); j++) {\n        // Add noise to initial surface\n        total += distanceTo(p, j);\n    }\n    return total;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float i;\n    float eyeDist, minDist;\n\n    vec3 eyePos = vec3(0, 0, -1);\n    vec3 ray = vec3((fragCoord.xy-.5*iResolution.xy)/iResolution.x, 1.);\n    ray = normalize(ray);\n\n    // Camera motion\n    eyePos.yz *= rotate2D(5.);\n    eyePos.xz *= rotate2D(iTime);\n    ray.yz *= rotate2D(5.);\n    ray.xz *= rotate2D(iTime);\n\n    for(minDist = 1.; i<100. && minDist>0.001; i++) {\n        // Point to check\n        vec3 p = eyePos+eyeDist*ray;\n                 \n        minDist = totalDistance(p);\n        // Move point forward\n        eyeDist += minDist*.25;\n    }\n    i += 2.*(minDist*1000.+eyePos.z);\n    fragColor = vec4(0.);\n    fragColor += 600./(i*i);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs3SDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 46, 46, 98], [100, 100, 141, 141, 281], [283, 283, 312, 335, 570], [572, 572, 627, 627, 1283]]}
{"id": "fs3SDl", "name": "Urechis unicinctus", "author": "klk", "description": "2D render of tentacled underwater creature, inspired by Urechis unicinctus (penis fish)", "tags": ["tentacles", "creature"], "likes": 30, "viewed": 282, "published": "Public API", "date": "1634133178", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ((fragCoord-iResolution.xy/2.)/iResolution.yy)*10.;\n    vec3 col=vec3(0);\n    col=vec3(.1,.4+.05*uv.y,.5+.1*uv.y);\n    float t=iTime*3.;\n    vec2 ps[7];\n    for(int k=0;k<6;k++)\n    {\n        ps[k]=vec2(0);\n    }\n    \n    for(float f=0.;f<1.;f+=0.005)\n    {\n        for(int k=0;k<6;k++)\n        {\n            vec2 p=ps[k];\n            float j=float(k);\n            float r=sin(f*48.+sin(t+j*3.1));\n            r*=r;\n            float w=clamp((1.-length(uv-p*.03)*4.-f*.6-r*r*.1)*5.,0.,1.);\n            vec3 c=vec3(.6,.4,.2);\n            col=mix(col, (-r+2.)*c*(uv.y-p.y*.03+.05)*2.5*(1.+f)+vec3(.5,.3,.3), w);\n            float af=t*.1+j+sin(f*12.*(11.7+j*1.71)*.05-t*(26.3+j*1.87)*.02+j*3.1+117.)*f*5.;\n            ps[k]+=vec2(sin(af), cos(af))*1.7;\n        }\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs3SDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 871]]}
{"id": "fs3SWj", "name": "pentagonal tiling variations", "author": "mattz", "description": "Click and drag to set vertex position. \n\nInspired by [url]https://twitter.com/cs_kaplan[/url]. See [url]https://en.wikipedia.org/wiki/Cairo_pentagonal_tiling[/url] for details.", "tags": ["tiling", "pentagonal", "variations", "cairo"], "likes": 59, "viewed": 656, "published": "Public API", "date": "1633999926", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//////////////////////////////////////////////////////////////////////\n//\n// \"pentagonal tiling variations\" by mattz\n// License https://creativecommons.org/licenses/by/4.0/\n//\n// Click and drag to set vertex position.\n//\n// Renders \"type 4\" Cairo pentagonal tilings. See\n// https://en.wikipedia.org/wiki/Cairo_pentagonal_tiling\n// for details.\n//\n// Inspired by https://twitter.com/cs_kaplan\n//\n// Related shaders:\n//\n//   - \"Cairo tiling\" by nimitz\n//      https://www.shadertoy.com/view/4ssSWf\n//\n//   - \"More Cairo Tiles\" by mla\n//      https://www.shadertoy.com/view/MlSfRd\n//\n//   - \"Extruded Pentagon Tiling\" by Shane\n//      https://www.shadertoy.com/view/3t2cDK\n//\n//   - \"15th Pentagonal tiling\" by tomkh\n//      https://www.shadertoy.com/view/4lBXRV\n//\n//   - \"pentagonal tiling\" by FabriceNeyret2\n//      https://www.shadertoy.com/view/ltBBzK\n//      (golfed at https://www.shadertoy.com/view/XljfRV)\n//\n// Noise function from iq's \"Noise - gradient - 2D\"\n// https://www.shadertoy.com/view/XdXGW8\n//\n//////////////////////////////////////////////////////////////////////\n\n// vector rotated by 90 degrees CCW\nvec2 perp(vec2 u) {\n    return vec2(-u.y, u.x);\n}\n\n// rotate vector by rotation vector (cos(t), sin(t))\nvec2 rotate(vec2 rvec, vec2 p) {\n    return p.x * rvec + p.y * vec2(-rvec.y, rvec.x);\n}\n\n// rotate vector by rotation vector (cos(t), sin(t))\nvec2 unrotate(vec2 rvec, vec2 p) {\n    return p.x * vec2(rvec.x, -rvec.y) + p.y * rvec.yx;\n}\n\n// distance from point to line segment\nfloat dseg(vec2 p, vec2 a, vec2 b) {\n\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    \n    float u = dot(pa, ba) / dot(ba, ba);\n    \n    u = clamp(u, 0.0, 1.0);\n    \n    return length(pa - u * ba);\n    \n}\n\n// half-plane test\nbool in_half_plane(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    return dot(pa, perp(ba)) > 0.0;\n}\n\n// point in triangle\nbool in_triangle(vec2 p, vec2 a, vec2 b, vec2 c) {\n    return in_half_plane(p, a, b) && in_half_plane(p, b, c) && in_half_plane(p, c, a);\n}\n\n// from https://www.shadertoy.com/view/XdXGW8 - used for noise below\nvec2 grad( ivec2 z ) {\n\n    // 2D to 1D  (feel free to replace by some other)\n    int n = z.x+z.y*11111;\n\n    // Hugo Elias hash (feel free to replace by another one)\n    n = (n<<13)^n;\n    n = (n*(n*n*15731+789221)+1376312589)>>16;\n\n    // Perlin style vectors\n    n &= 7;\n    \n    vec2 gr = vec2(n&1,n>>1)*2.0-1.0;\n    \n    return ( n>=6 ) ? vec2(0.0,gr.x) : \n           ( n>=4 ) ? vec2(gr.x,0.0) :\n           gr;\n           \n}\n\n// from https://www.shadertoy.com/view/XdXGW8\nfloat noise( in vec2 p ) {\n\n    ivec2 i = ivec2(floor( p ));\n    vec2 f = fract( p );\n\t\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix( mix( dot( grad( i+ivec2(0,0) ), f-vec2(0.0,0.0) ), \n                     dot( grad( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( grad( i+ivec2(0,1) ), f-vec2(0.0,1.0) ), \n                     dot( grad( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n\n}\n\n\n// colors for each cell\nconst vec3 CELL_COLORS[4] = vec3[4](\n    vec3(0.9, 0.0, 0.05),\n    vec3(0.95, 0.85, 0.0),\n    vec3(0.1, 0.8, 0.05),\n    vec3(0.1, 0.5, 0.8)\n);\n\n// rotation vectors for theta = 0, pi/2, pi, 3*pi/2\nconst vec2 ROT_VECTORS[4] = vec2[4](\n    vec2(1, 0),\n    vec2(0, 1),\n    vec2(-1, 0),\n    vec2(0, -1)\n);\n\n// un-rotated cell geometry \n// \n//\n//           C\n//         _*_____\n//       _-       -----____\n//  D  _*------------------* B ---\n//   _- |                 ||\n//  *   |                 ||\n//  |   |                | |    \n//  |   |                | |    t\n//   |  |               |  |   \n//   |  |            A  |  |\n//    | |            __*   |   ---\n//    | |        __--   \\  |    \n//     ||    __--        \\ |    y\n//     ||__--             \\|    \n//    O *------------------* X ---\n//\n//      |       x      | s |\n// \n// notes:\n//\n//   square is 0.5 x 0.5\n//\n//   A = O + (x, y)\n//   B = O + (0.5, 0.5)\n//   C = B + (-t, s) = B + (y - 0.5, 0.5 - x)\n//   D = O + (-y, x)\n//   X = O + (0.5, 0)\n//\n//   segments OD and OA are congruent and perpendicular\n//   segments AB and BC are congruent and perpendicular\n//  \n//   there are four rotated copies of polygon OABCD around point O \n\n// polygon points\nvec2 O, A, B, C, D;\n\n// for bump-mapped shading\nvec2 heightmap(vec2 p) {\n\n    // get polygon distance\n    float dpoly = dseg(p, O, A);\n    dpoly = min(dpoly, dseg(p, A, B));\n    dpoly = min(dpoly, dseg(p, B, C));\n    dpoly = min(dpoly, dseg(p, C, D));\n    dpoly = min(dpoly, dseg(p, D, O));\n    \n    // offset from edge\n    float k = 0.08;\n    \n    // base height\n    float z = k + 0.01 * noise(5.*p);\n    \n    if (dpoly < k) {\n        // semicircular shoulder\n        float w = (dpoly/k - 1.0);\n        z *= sqrt(1.0 - w*w);\n    } else {\n        // depression inwards from edge\n        z *= (1.0 - 0.03*smoothstep(k, 2.0*k, dpoly));\n    }\n    \n    // return height and polygon distance\n    return vec2(z, dpoly);\n    \n}\n\n// do the things!\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // global rotation by 45 degrees\n    vec2 global_rot = vec2(0.5*sqrt(2.0));\n    \n    // image should be six blocks high\n    float scl = 6.0 * global_rot.x / iResolution.y;\n    \n    // uv in [0,1] x [0, 1] holds vertex position\n    vec2 uv = vec2(0.7886751345948132, 0.21132486540518713);\n    \n    // light coords relative to center\n    vec2 lcoord = vec2(0);\n\n    if (iMouse.z > 0.) {\n    \n        // set vertex coords by dragging - light is fixed\n        \n        uv = clamp(iMouse.xy / iResolution.xy, 0.0, 1.0);\n        lcoord = vec2(-0.0, 0.5);\n        \n    } else {\n    \n        // set vertex coords varying over screen\n        // and move light\n        uv = (fragCoord.xy - 0.5 * iResolution.xy) / (max(iResolution.x, iResolution.y));\n        \n        const float repeat = 30.0; // seconds\n        const float wraps_per_repeat = 5.0;\n        \n        const float x_lobes = 3.0;\n        const float y_lobes = 2.0;\n        \n        const float two_pi = 6.283185307179586;\n        \n        float t = iTime * two_pi / repeat;\n        \n        float t_wrap = t * wraps_per_repeat;\n       \n        float c = cos(t_wrap);\n        float s = sin(t_wrap);\n        \n        uv = rotate(vec2(s, -c), uv);\n        \n        uv = clamp(uv + 0.5, 0.0, 1.0);\n        \n        lcoord = vec2(-sin(t * x_lobes), cos(t * y_lobes));\n \n    }\n    \n    // z coordinate of camera and light (tiles live at z=0)\n    const float cz = 3.5;\n    \n    // set light pos in 3D\n    vec3 lpos = vec3(lcoord * 0.5 * iResolution.xy * scl, cz);\n    \n    // camera pos in 3D\n    const vec3 cpos = vec3(0, 0, cz);\n\n    // map frag cords to scene coords (before global rotation)\n    vec2 porig = (fragCoord + vec2(0.13, 0.17) - 0.5*iResolution.xy) * scl;\n    \n    // apply global rotation\n    vec2 p = rotate(porig, global_rot);\n\n    // find starting origin of tile cluster -- note this could change below\n    O = floor(p + 0.5);\n            \n    // figure out which quadrant we are in relative to the origin\n    ivec2 qstep = ivec2(step(p, O));\n    int quadrant = (qstep.x ^ qstep.y) + 2*qstep.y;\n    \n    // each quadrant rotates by 90 degrees\n    vec2 rvec = ROT_VECTORS[quadrant];\n    \n    // form some critical points of the polygon in this cell\n    vec2 xy = 0.5*uv;\n    vec2 st = 0.5 - xy;\n    \n    A = O + rotate(rvec, xy);\n    B = O + rotate(rvec, vec2(0.5));\n    vec2 X = O + rotate(rvec, vec2(0.5, 0));\n\n    // get distance from point to semgent AX\n    float dline = dseg(p, A, X);\n\n    // figure out whether we are in the main upper-left part of the\n    // cell or one of the two triangles\n    int cell = quadrant;\n    \n    if (in_triangle(p, X, B, A)) {\n        // in triangle XBA -- rotate polygon CCW by 90 degrees and translate it over by 1 cell\n        cell = (quadrant + 1) & 3;\n        O += rvec;\n        rvec = perp(rvec);\n    } else if (in_triangle(p, O, X, A)) {\n        // in trangle OXA -- rotate polygon CW by 90 degrees\n        cell = (quadrant + 3) & 3;\n        rvec = -perp(rvec);\n    } \n\n    // now we know which polygonal tile p is in, so get the distance to the\n    // polygon\n    \n    A = O + rotate(rvec, xy);\n    B = O + rotate(rvec, vec2(0.5));\n\n    C = B + rotate(rvec, perp(st));\n    D = O + rotate(rvec, perp(xy));\n    \n    vec2 hm = heightmap(p);\n    \n    const float h = 1e-3;\n    const vec2 eps = vec2(h, 0);\n    \n    vec2 hgrad = (0.5 / h) * vec2(\n        heightmap(p + eps.xy).x - heightmap(p - eps.xy).x,\n        heightmap(p + eps.yx).x - heightmap(p - eps.yx).x\n    );  \n    \n    hgrad = unrotate(global_rot, hgrad);\n    \n    float z = hm.x;\n        \n    dline = min(dline, hm.y);\n    \n    // bump-mapped surface normal\n    vec3 N = normalize(cross(vec3(1, 0, hgrad.x), vec3(0, 1, hgrad.y)));\n\n    // get color of this cell\n    vec3 color = CELL_COLORS[cell];\n    color *= color; // gamma un-correct\n    \n    // desaturate a bit\n    color = mix(color, vec3(0.5), 0.08);\n    \n    // get 3D point position\n    vec3 pos = vec3(porig, z);\n\n    // fake phong lighting\n    vec3 L = normalize(lpos - pos);\n    vec3 V = -normalize(cpos - pos);\n\n    vec3 R = reflect(L, N);\n    \n    color *= 0.1 + 0.9 * clamp(dot(N, L), 0.0, 1.0);\n    color += 0.3*pow(clamp(dot(V, R), 0.0, 1.0), 10.0)*vec3(1);\n\n    // darken by lines\n    color *= smoothstep(0.0, 0.0125, dline);\n    \n    // gamma \"correct\"\n    color = sqrt(color);\n\n    // done!\n    fragColor = vec4(color, 1);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs3SWj.jpg", "access": "shaders20k", "license": "cc-by-4.0", "functions": [[1083, 1119, 1138, 1138, 1168], [1170, 1223, 1255, 1255, 1310], [1312, 1365, 1399, 1399, 1457], [1459, 1498, 1534, 1534, 1700], [1702, 1721, 1765, 1765, 1845], [1847, 1868, 1918, 1918, 2007], [2009, 2078, 2100, 2155, 2507], [2509, 2555, 2581, 2581, 2976], [4232, 4259, 4283, 4312, 4931], [4933, 4951, 5008, 5046, 9379]]}
{"id": "fs3SzB", "name": "lavalamp_211009", "author": "andrevv", "description": "shader", "tags": ["shader"], "likes": 2, "viewed": 22, "published": "Public", "date": "1633827621", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\tClassic Perlin 3D Noise \n//\tby Stefan Gustavson\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec3 P){\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time=iTime*.25;\n    vec2 uv = -1.0 + 2.0 * fragCoord/iResolution.xy;\n    \n    uv.x *= iResolution.x/iResolution.y;\n    \n    \n    \n    \n\n\tfloat c=length(uv)/2.;\n\n    float r,g,b;\n    \n    float d=1.+sin(time*.1)*3.;\n    \n    float noise = cnoise(vec3(uv.x/2.0 +d, uv.y/2.0 + d, time * 0.5));\n    \n    \n    \n    uv.y += noise/5.;\n    \n    c=smoothstep(.1,2.0 * noise,c);\n    \n    r=sin(noise + time+(c-sin(0.5+time+uv.x*noise))*d);\n    \n    g=cos(noise / 10. + time+(c-cos(1.75+time+uv.y*noise))*d);\n\n    b=sin(noise * 0.25 + time+(c-sin(2.25+time+uv.y*noise))*d);\n\n\n\n    fragColor = vec4(vec3(r,g,b)+(noise/2.0-.5+sin(noise + time*20.)*.01),0.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs3SzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 54, 75, 75, 112], [113, 113, 140, 140, 188], [189, 189, 208, 208, 244], [246, 246, 267, 267, 2539], [2541, 2541, 2598, 2598, 3255]]}
{"id": "fs3XD7", "name": "The aperture", "author": "lllcz", "description": "I am a shader beginner, this is my first work, I hope you more correction", "tags": ["2l"], "likes": 0, "viewed": 41, "published": "Public", "date": "1633278090", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 u_resolution;\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 st = gl_FragCoord.xy/u_resolution.xy;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv -= vec2(0.5);\n    \n    int i;\n    \n    float q = smoothstep(1.0, 0.98, abs(sin(sqrt(uv.x*uv.x + uv.y*uv.y)-iTime/2.0)))\n               - smoothstep(0.98, 0.8, abs(sin(sqrt(uv.x*uv.x + uv.y*uv.y)-iTime/2.0)))\n            +smoothstep(0.8, 0.78, abs(sin(sqrt(uv.x*uv.x + uv.y*uv.y)-iTime/2.0)))+\n               - smoothstep(0.78, 0.6, abs(sin(sqrt(uv.x*uv.x + uv.y*uv.y)-iTime/2.0)))\n            +smoothstep(0.6, 0.58, abs(sin(sqrt(uv.x*uv.x + uv.y*uv.y)-iTime/2.0)))+\n               - smoothstep(0.58, 0.4, abs(sin(sqrt(uv.x*uv.x + uv.y*uv.y)-iTime/2.0)))\n            +smoothstep(0.4, 0.38, abs(sin(sqrt(uv.x*uv.x + uv.y*uv.y)-iTime/2.0)))+\n               - smoothstep(0.38, 0.2, abs(sin(sqrt(uv.x*uv.x + uv.y*uv.y)-iTime/2.0)))\n            +smoothstep(0.2, 0.18, abs(sin(sqrt(uv.x*uv.x + uv.y*uv.y)-iTime/2.0)))+\n               - smoothstep(0.18, 0.0, abs(sin(sqrt(uv.x*uv.x + uv.y*uv.y)-iTime/2.0)));\n            //-smoothstep(0.2, 0.1, abs(sin(sqrt(uv.x*uv.x + uv.y*uv.y)-iTime/3.0)));\n    // Time varying pixel color\n    vec3 col = vec3(q,0.4,0.6);\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs3XD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 76, 133, 133, 1401]]}
{"id": "fs3XWB", "name": "Black Hexagon", "author": "Edwy", "description": "eHexagon", "tags": ["hexagon"], "likes": 0, "viewed": 37, "published": "Public", "date": "1633809083", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float s = 2.0;\nvec2 c = vec2(0.0, 0.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord  - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    uv *= 5.0;\n    /*if(abs(c.y - uv.y) < s / 2.0 && dot(abs(uv - c), normalize(vec2(sqrt(3.0), 1.0))) < s / 2.0){\n        col *= 0.0;\n    }*/\n    col *= 1.0 - step(max(abs(c.y - uv.y), dot(abs(uv - c), normalize(vec2(1.7321, 1.0)))), s / 2.0);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs3XWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 41, 98, 98, 499]]}
{"id": "fscSzX", "name": "061021_1", "author": "gtoledo3", "description": "shader", "tags": ["shader"], "likes": 1, "viewed": 47, "published": "Public", "date": "1633570990", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time=iTime;\n    vec2 resolution=iResolution.xy;\n   \n    vec2 uv = -1.0 + 2.0 * gl_FragCoord.xy/resolution.xy;\n    \n    uv.x *= resolution.x/resolution.y;\n\tuv *=length(uv+vec2(sin(time)*.5,cos(time)*.5))*.3;\n\tuv /=length(5.*uv+vec2(sin(.3*time)*.75,cos(.8*time)*.75))*3.;\n\t\n\tfloat v=length(uv)*3.;\n    v=clamp(0.,1.,v);\n\n    \t\n    uv.xy +=sin(uv.xy*4.)*.1;\n\tuv.xy +=sin(uv.xy*12.)*.1;\n\tuv.xy +=sin(time+length(uv)+.5+sin(time*.2)*8.)*.1;\n\tuv.xy +=sin(uv.xy*32.)*sin(sin(time*.5)*uv.xy*12.)*.1;\n\t\n\n\tfloat uvL=length(uv);\n\t\n\tuv.xy +=sin(1.7*time+uv.xy*2.)*.13;\n\tfloat r=length(uv);\n\tr=clamp(r,0.,1.);\n\tuv.xy +=sin(1.4*time+uv.xy*2.)*.25;\n\tfloat g=length(uv);\n\tg=clamp(g,0.,1.);\n\tuv.xy +=sin(1.5*time+uv.xy*4.)*.57;\n\tfloat b=length(uv);\n\tb=clamp(b,0.,1.);\n\n\t\n\tuvL=smoothstep(.2,.23,uvL);\n\tuvL=2.75-exp(uvL);\n\tuvL=max(v,uvL);\n    fragColor = vec4(vec3(uvL)*vec3(r*.89,g*.87,b*.9)*v,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fscSzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 951]]}
{"id": "fscXWB", "name": "Brushed Metal Scales", "author": "oneshade", "description": "Trying to model a brushed metal texture.", "tags": ["scales", "metallic", "glint", "brushedmetal"], "likes": 12, "viewed": 91, "published": "Public", "date": "1633807047", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define hash(x) fract(485.375 * cos(375.843 * x + 881.482))\nvoid brushedDisk(in vec2 uv, inout vec3 color) {\n    float r = length(uv), a = atan(uv.y, uv.x);\n    bool mask = r < 0.5;\n    r *= 1.5 * iResolution.y;\n    float bands = mix(hash(floor(r)), hash(ceil(r)), smoothstep(0.0, 1.0, fract(r)));\n    float glint = 0.65 + 0.35 * sin(4.0 * a);\n    if (mask) color = vec3(bands * glint);\n}\n\nvoid render(inout vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y + 0.1 * iTime;\n    uv = fract(uv * 2.0) - 0.5;\n    vec3 color = vec3(0.0);\n\n    brushedDisk(uv - vec2(0.5, -0.5), color);\n    brushedDisk(uv + 0.5, color);\n    brushedDisk(uv, color);\n    brushedDisk(uv - 0.5, color);\n    brushedDisk(uv - vec2(-0.5, 0.5), color);\n\n    fragColor.rgb += color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0);\n    render(fragColor, fragCoord + vec2(0.000, 0.000));\n    render(fragColor, fragCoord + vec2(0.333, 0.000));\n    render(fragColor, fragCoord + vec2(0.666, 0.000));\n    render(fragColor, fragCoord + vec2(0.000, 0.333));\n    render(fragColor, fragCoord + vec2(0.333, 0.333));\n    render(fragColor, fragCoord + vec2(0.666, 0.333));\n    render(fragColor, fragCoord + vec2(0.000, 0.666));\n    render(fragColor, fragCoord + vec2(0.333, 0.666));\n    render(fragColor, fragCoord + vec2(0.666, 0.666));\n    fragColor /= 9.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fscXWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 108, 108, 388], [390, 390, 444, 444, 804], [806, 806, 861, 861, 1407]]}
{"id": "fscXWN", "name": "Coast", "author": "1rosehip", "description": "Coast", "tags": ["water"], "likes": 0, "viewed": 48, "published": "Public", "date": "1633106210", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define NUM_LAYERS 5.0\n#define NUM_OCTAVES 5\n\n\nmat2 getRotationMatrix(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n\n    return mat2(c, -s,\n                s, c);\n}\n\n\nfloat random(vec2 pos) {\n    pos = fract(pos * vec2(123.34, 456.21));\n    pos += dot(pos, pos + 45.32);\n    return fract(pos.x * pos.y);\n}\n\n\nfloat circle(vec2 uv, float radius, float smoothThickness){\n    return smoothstep(radius - smoothThickness, radius + smoothThickness, length(uv));\n}\n\n\nfloat createDrop(vec2 uv, float width) {\n    float soft = 0.0;\n    float drop = circle(uv, 0.1, 0.001);\n    return 1.0 - drop;\n}\n\nvec3 createLayer(vec2 uv){\n    vec3 result = vec3(0);\n    vec2 copies = fract(uv);\n    vec2 index = floor(uv);\n    for(float y=-1.0; y<=1.0; y++) {\n    \tfor(float x=-1.0; x<=1.0; x++) {\n            vec2 offset = vec2(x, y);\n    \t\tfloat rnd = random(index + offset);\n            float size = fract(rnd * 345.32);\n            float drop = createDrop(copies - offset - vec2(rnd, fract(rnd * 34.0)) + 0.5, 0.005);\n            result += drop * size * vec3(0.4706, 0.4706, 0.4706);\n        }\n    }\n\n    return result;\n}\n\n\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nfloat fbm(vec2 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfor (int i = 0; i < NUM_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    float aspect = iResolution.x / iResolution.y;\n    if(aspect > 1.0) {\n        uv-= 0.5;\n        uv.x *= aspect;\n        uv+= 0.5;\n    }\n    if(aspect < 1.0) {\n        uv-= 0.5;\n        uv.y *= 1.0 / aspect;\n        uv+= 0.5;\n    }\n\n   \n    float time = iTime * 0.01;\n    vec3 color = vec3(0.0275, 0.0275, 0.2902);\n    mat2 matr = getRotationMatrix(10.0 * 3.14 / 180.0);\n    uv = (matr * (uv - 0.5)) + 0.5;\n    float strength = smoothstep(0.2, 1.0, uv.y);\n\n    vec2 surface = strength * vec2(\n        mix(-0.3, 0.3, fbm(8.0 * uv + iTime * 0.1)), \n        mix(-0.3, 0.3, fbm(1.5 * uv + iTime * 0.1))\n    );\n    uv = refract(vec2(0.0), surface, 1.0 / 1.333);\n    \n    for(float i=0.0; i<1.0; i += 1.0 / NUM_LAYERS) {\n        float depth = fract(i);\n        float scale = mix(55.0, 10.0, depth);\n        vec2 offset = vec2(0.0, mod(time, 1000.0) * (depth + 0.3) * 0.6);\n        vec3 layer = createLayer((uv + offset) * scale);\n        color = mix(color, vec3(1.0, 1.0, 1.0), layer);\n    }\n\n    fragColor = vec4(color, 1.0); \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fscXWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 93, 130, 130, 231], [234, 234, 258, 258, 372], [375, 375, 434, 434, 523], [526, 526, 566, 566, 654], [656, 656, 682, 682, 1169], [1173, 1173, 1193, 1193, 1260], [1262, 1262, 1282, 1282, 1491], [1493, 1493, 1512, 1512, 1751], [1755, 1755, 1811, 1811, 2884]]}
{"id": "fscXzS", "name": "rotating 2d area lights lines", "author": "ohanegby", "description": "rotating 2d area lights,\ninspired by the thread here: https://www.facebook.com/groups/shadertoy/posts/954364335144593\n", "tags": ["lighting", "arealights"], "likes": 23, "viewed": 346, "published": "Public API", "date": "1633416357", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Rotating Area Lights Lines\n// By Ori Hanegby\n// Inspired by this thread: \n// https://www.facebook.com/groups/shadertoy/posts/954364335144593\n// Line segment code from iq's tutorials: https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n// Tone mapping code from here: https://www.shadertoy.com/view/7scXD4\n\n\nfloat line_segment(in vec2 p, in vec2 a, in vec2 b) {\n\tvec2 ba = b - a;\n\tvec2 pa = p - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n\treturn length(pa - h * ba);\n}\n\n\n// In order to calculate the area light I'm treating the line area as continous line of infinite directional light sources\n// To calculate how much light each point (uv) receives I'm using two factors: the distance from the line to the point and the integration of \n// all the sin(angle) between the point and the light sources on the line. The integral between angles b and a on the line segment have an easy solution\n// -cos(b)+cos(a) \n// cos(b) and cos(a) are given by the dot products between the two edges on of the line that are stored in l1 and l2\n// the integral result is multiplied by hh which gives control of the light intensity relative to the distance from the line\n// In order to know which side of the line the point resides on I'm using cross product where the sign of the z component indicates the direction\nvec2 area_light_intensity(vec2 p, vec2 v1, vec2 v2, float diffusePower, float shinePower)\n{  \n    vec2 areaLine = normalize(v2-v1);\n    float l1 = dot(normalize(p-v1),areaLine);\n    float l2 = dot(normalize(p-v2),areaLine);\n    vec3 crs=cross(vec3(p-v1,0.),vec3(areaLine,0.));\n    float d = line_segment(p,v1,v2);\n    float hh=max(0.,pow(max(0.01,shinePower-d),4.5));\n    float c=(-l2 + l1)*hh;\n    return vec2(pow(c,diffusePower),crs.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv =  (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv*=6.;\n    float t=0.;\n    float c=0.;\n    vec3 col=vec3(0.);\n    for (int i=0; i<3; i++){\n        t+=1.;\n        float angle = iTime/10. + t*5.;\n\n        vec2 line = vec2(sin(angle),cos(angle));\n        float s=1.6;    \n        vec2 v1 = -line*s;\n        vec2 v2 = line*s;  \n        vec2 disp = vec2(sin(t*2.1),cos(t*2.1))*2.;\n        v1 += disp;\n        v2 += disp;\n        vec2 intes_w_sign=area_light_intensity(uv, v1, v2, 1., 5.);\n        float intens=intes_w_sign.x/pow(2.,7.);\n        vec3 tCol = intes_w_sign.y>0.?vec3(1.0,0.25,0.05) * intens:\n        vec3(1.0,0.12,0.02) * intens/5.;        \n        col += tCol;\n    }\n\n    \n    col = col / (1. + col); // Tone mapping\n    col = sqrt(col); // Gamma\n    \n    fragColor = vec4(col, 1);       \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fscXzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 334, 387, 387, 507], [510, 1336, 1427, 1427, 1776], [1778, 1778, 1835, 1885, 2702]]}
{"id": "fsdGDS", "name": "Raymarch_renderer_sidps", "author": "kingcrimson1112", "description": "A 3D Renderer to display objects to screen", "tags": ["3d", "raymarching", "lighting", "renderer"], "likes": 0, "viewed": 37, "published": "Public", "date": "1633875937", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//----------------------------------------------------\n// SCENE_SETTINGS\n//----------------------------------------------------\nvec3 bgColor = vec3(0.4f,0.8f,0.9f);\nfloat yScale = 1.0f;\nvec3 wUp = vec3(0.0f, 1.0f, 0.0f);\n//----------------------------------------------------\n//----------------------------------------------------\n\n\n//----------------------------------------------------\n// CAMERA_SETTINGS\n//----------------------------------------------------\nvec3 cPos = vec3(0.0f, 0.0f, -5.0f);\nvec3 cLookAt = vec3(0.0f,0.0f,0.0f);\nfloat fov = 45.0f;\n\nvec3 get_target(vec2 uv, vec3 origin, vec3 lookAt)\n{\n    vec3 view = normalize(lookAt - origin);\n    vec3 right = normalize(cross(view , wUp));\n    vec3 up = normalize(cross(right , view));\n    right *= tan(radians(fov));\n    up *= tan(radians(fov));\n    vec3 target = ((origin + view) + (up * uv.y) + (right * uv.x));\n    return target;\n}\n//----------------------------------------------------\n//----------------------------------------------------\n\n\n//----------------------------------------------------\n// SCENE_DATA\n//----------------------------------------------------\nvec4[2] spheres = vec4[2](\nvec4(-6.0f,0.0f,5.0f,4.0f),\nvec4(6.0f,0.0f,5.0f,4.0f)\n);\nfloat plane = -4.0f;\nvec3 lPos = vec3(10.0f,8.0f,10.0f);\nvec3 lightCol = vec3(1.0f,1.0f,0.5f);\n//----------------------------------------------------\n//----------------------------------------------------\n\n\n//----------------------------------------------------\n// RAYMARCHING\n//----------------------------------------------------\n#define MAX_STEPS 2000\n#define MAX_DISTANCE 2000.0f\n#define SURFACE_DISTANCE 0.001f\n\nfloat get_dist(vec3 point)\n{\n    float dist=MAX_DISTANCE;\n    for(int i=0;i<2;i++)\n    {\n        vec3 sp=spheres[i].xyz;\n        sp.x += sin(iTime*2.5f)*2.5f;\n        sp.z += cos(iTime*2.5f)*2.5f;\n        float dSphere = distance(point, sp) - spheres[i].w;\n        dist=min(dSphere,dist);\n    }\n    float dPlane = point.y - plane;\n    return min(dist, dPlane);\n}\n\nfloat ray_march(vec3 rO, vec3 rD)\n{\n    float dist = 0.0f;\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 current = rO + (dist * rD);\n        float delta = get_dist(current);\n        dist += delta;\n        if(dist <= SURFACE_DISTANCE || dist >= MAX_DISTANCE)\n        {\n            break;\n        }\n    }\n    return dist;\n}\n\nvec3 get_normal(vec3 p)\n{\n    float dist=get_dist(p);\n    vec2 e=vec2(0.01f,0.0f);\n    vec3 n = dist- vec3(get_dist(p-e.xyy),\n                        get_dist(p-e.yxy),\n                        get_dist(p-e.yyx));\n    return normalize(n);\n}\n\nfloat get_diffuse(vec3 p)\n{\n    vec3 lp=lPos;\n    lp.xz =vec2(sin(iTime*5.0f),cos(iTime*5.0f))*7.0f;\n    vec3 l = normalize(lp-p);\n    vec3 n = get_normal(p);\n    float dif=clamp(dot(n,l),0.0f,1.0f);\n    // Shadows\n    float d = ray_march(p + n*1.5f,lp);\n    if(d<length(lp-p))\n    {\n        dif*=0.1f;\n    }\n    return dif;\n}\n\nvec3 trace_ray(vec2 uv)\n{\n    vec3 col = vec3(0.0f);\n    vec3 rOrigin = cPos;\n    vec3 offset=vec3(1.0f,0.0f,0.0f)*sin(iTime)*50.0f;\n    //rOrigin+=offset;\n    vec3 target = get_target(uv, rOrigin, cLookAt);\n    vec3 rDir = normalize(target - rOrigin);\n    float rayMarch = ray_march(rOrigin, rDir);\n    if(rayMarch >= MAX_DISTANCE)\n    {\n        col= bgColor;\n    }\n    else\n    {\n        vec3 end = rOrigin + rayMarch*rDir;\n        float diff=get_diffuse(end);\n        col=lightCol*diff;\n    }\n    return col;\n}\n//----------------------------------------------------\n//----------------------------------------------------\n\n\n//----------------------------------------------------\n// UTILITY\n//----------------------------------------------------\n\n// Gets the UV coordinate for Image\nvec2 get_uv(vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv * 2.0f) - 1.0f;\n    uv *= yScale;\n    uv.x *= (iResolution.x / iResolution.y);\n    return uv;\n    // return (yScale * 2.0f * (fragCoord - 0.5f * (iResolution.xy))) / iResolution.y;\n}\n\n//----------------------------------------------------\n//----------------------------------------------------\n\n\n// Main Image Function\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    // From (-X,-Y) to (X,Y)\n    vec2 uv = get_uv(fragCoord);\n    \n    // Pixel Color\n    vec3 col = trace_ray(uv);\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0f);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsdGDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[333, 556, 608, 608, 895], [1423, 1633, 1661, 1661, 1995], [1997, 1997, 2032, 2032, 2330], [2332, 2332, 2357, 2357, 2571], [2573, 2573, 2600, 2600, 2899], [2901, 2901, 2926, 2926, 3414], [3649, 3685, 3714, 3714, 3952], [4066, 4089, 4143, 4172, 4323]]}
{"id": "fsdXzj", "name": "Sunrise and sunset in the clouds", "author": "lllcz", "description": "A simple sunrise and sunset animation that will be updated later", "tags": ["2d"], "likes": 0, "viewed": 110, "published": "Public API", "date": "1633534177", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 g_random(vec2 ip){\n\treturn fract(sin(\n\t\tvec2(dot(ip,vec2(127.1,311.7)), dot(ip,vec2(269.5,183.3)))\n\t)* 44753.976967) *2. - 1.;\n}\n\nfloat g_noise(vec2 st){\n\tvec2 ip = floor(st);\n\tvec2 fp = fract(st);\n\n\tvec2 u = fp*fp*fp*(fp*(fp*6.-15.)+10.);//使用三次多项式进行插值\n\treturn mix(\n\t\tmix(dot(g_random(ip) , fp-vec2(0.,0.)) , dot(g_random(ip+vec2(1.,0.)) , fp-vec2(1.,0.)) ,u.x),\n\t\tmix(dot(g_random(ip+vec2(0.,1.)) , fp-vec2(0.,1.)) , dot(g_random(ip+vec2(1.,1.)) ,fp-vec2(1.,1.)) , u.x),\n\t\tu.y\n\t);\n}\n\n\nfloat circle(vec2 st, vec2 center){\n    return distance(st, center);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 beforeColor = vec4(1.0);\n  \n    uv.x -= abs(sin(iTime/4.0));\n    uv.y -= abs(sin(iTime/2.0))/1.5;\n    if(circle(uv, vec2(0,0)) <=0.15){\n        \n        beforeColor = vec4(1.000,smoothstep(0.566, 0.98, circle(uv, vec2(0,0))+0.69),0.3, 1.0);\n    } \n    uv -= 0.5;\n    \n \n    //To prevent clouds and the sun from moving together, they need a separate coordinate system\n    vec2 copy = fragCoord/iResolution.xy;\n    copy -= 0.5;\n    copy *= vec2(4.,4.);\n    copy += g_noise(copy*3.);\n    copy.x = sin(iTime/2.0);\n\n    \n    beforeColor += (g_noise(copy) -.5)*.19;\n    // Output to screen\n    fragColor = beforeColor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsdXzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 133], [135, 135, 158, 158, 510], [513, 513, 548, 548, 583], [586, 586, 643, 643, 1312]]}
{"id": "fsGSzV", "name": "Refraction Metaballs", "author": "luckyballa", "description": "some insta-like effect but for webcam", "tags": ["raymarching", "metaballs", "refraction", "webcam"], "likes": 6, "viewed": 266, "published": "Public API", "date": "1634990564", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 40\n#define MAX_DIST 40.\n#define SURF_DIST .005\n#define samples 32\n#define LOD 2\n\nfloat hash(vec2 n) {\n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 184.5453);\n}\n\nfloat noise(vec2 n) {\n    const vec2 d = vec2(0.0, 1.0);\n    vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(hash(b), hash(b + d.yx), f.x), mix(hash(b + d.xy), hash(b + d.yy), f.x), f.y);\n}\n\nfloat sdSphere( vec3 p, float s ) { return length(p)-s; }\n\n\nfloat smin( float a, float b, float k ) {\n    float h = max(k-abs(a-b), 0.0);\n    return min(a, b) - h*h*0.25/k; \n}\n\nfloat getDist(vec3 p) {\n    float final = MAX_DIST;\n    float iTime = iTime; \n    p = p - vec3(0.,0.5, 5.);\n    for (int i = 0; i < 10; i++) {\n        float fi = float(i)  + floor(float(i) / 5.);\n        vec3 pos = p;\n        pos.xy += vec2(sin(iTime + fi), cos(iTime + fi * 2.)) * 0.4;\n        pos.z += sin(iTime * cos(float(i * 4))) * 0.2;\n        float r = sin(fi + 1.) * 0.15;\n        float n = min(sin(pos.z * float(i) * 5.), cos(pos.x * pos.y * float(i) * 10.)) * 0.1;\n        float bubble = sdSphere(pos + vec3(n) * 0.1 - vec3(0.05), r);\n        \n        final = smin(final, bubble, 0.4);\n    }\n\n    \n    return final;\n}\nfloat rayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    float matId = -1.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float res = getDist(p);\n        float dS = res;\n        dO += dS;\n        \n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 normals(vec3 p, float of ) {\n\tfloat d = getDist(p);\n    vec2 e = vec2(of, 0);\n    \n    vec3 n = d - vec3(\n        getDist(p-e.xyy),\n        getDist(p-e.yxy),\n        getDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat diffuse(vec3 p, vec3 n, vec3 lp) {\n    vec3 l = normalize(lp-p);\n    float dif = clamp(dot(n, l), 0., 1.);\n\n    return dif;\n}\n\nfloat specular(vec3 rd, vec3 ld, vec3 n) {    \n    vec3 reflection = reflect(-ld, n);\n    float spec = max(dot(reflection, -normalize(rd)), 0.); \n    return spec;\n}\n\nfloat gaussian(vec2 i) {\nconst float sigma = float(samples) * .25;\n    return exp( -.5* dot(i/=sigma,i) ) / ( 6.28 * sigma*sigma );\n}\n\nvec4 blur(sampler2D sp, vec2 U, vec2 scale) {\n    const int  sLOD = 1 << LOD;\n    vec4 O = vec4(0);\n    int s = samples/sLOD;\n    \n    for ( int i = 0; i < s*s; i++ ) {\n        vec2 d = vec2(i%s, i/s)*float(sLOD) - float(samples)/2.;\n        O += gaussian(d) * texture(sp, U + scale * d);\n    }\n    \n    return O / O.a;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 mo = (iMouse.xy-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.0);\n    \n    float iTime = iTime * 2.;\n\n\tvec3 ro = vec3(.0, 0., 1.);\n    vec3 rd = normalize(vec3(uv.x, uv.y + 0.2 , 2.));\n    vec3 ld =  vec3(0., 0., 1.);\n    float d = rayMarch(ro, rd);\n    vec3 p = ro + rd * d;\n    vec3 n = normals(p, 0.03);\n    float dif = diffuse(p, n, ld); \n    float spec = specular(rd, ld, n) * 0.1;\n    float fresnel = smoothstep(0.5, 0.2, dot(-rd, n));\n    vec3 dispersion = vec3(noise(n.xy * 2.7), noise(n.xy * 3.), noise(n.xy * 3.3)) * 0.4; \n    \n    vec2 camUV = fragCoord / iResolution.xy;\n    vec3 cam1 = texture(iChannel0, camUV).xyz * 0.9;\n    camUV += n.xy * 0.05 * dif;\n    vec3 cam2 = blur(iChannel0, camUV, vec2(0.002)).xyz * 0.9;\n\n    col = dif * cam2;\n    col += spec;\n    col += cam2 * 0.15;         \n    col += dispersion;\n    col += fresnel * 0.2;\n    \n    if (d > MAX_DIST) { col = vec3(cam1);  }\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "4sf3zn", "previewfilepath": "/presets/webcam.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/webcam.png", "ctype": "webcam"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsGSzV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[99, 99, 119, 119, 186], [188, 188, 209, 209, 415], [417, 417, 452, 452, 474], [477, 477, 518, 518, 592], [594, 594, 617, 617, 1221], [1222, 1222, 1256, 1256, 1524], [1526, 1526, 1559, 1559, 1747], [1749, 1749, 1789, 1789, 1880], [1882, 1882, 1924, 1924, 2046], [2048, 2048, 2072, 2072, 2181], [2183, 2183, 2228, 2228, 2504], [2507, 2507, 2564, 2564, 3580]]}
{"id": "fsGSzy", "name": "Shredded Art 2", "author": "dr2", "description": "More endlessly self-shredding art (NFT rights reserved)", "tags": ["fractal", "kifs", "destruction", "banksy"], "likes": 17, "viewed": 266, "published": "Public API", "date": "1634809104", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Shredded Art 2\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define FIX_LO_PIC  0  // = 1 to freeze image in shredded part of picture\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nvec3 HsvToRgb (vec3 c);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nfloat Hashfv3 (vec3 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltDir, qHit;\nfloat tCur, dstFar, pWid, hMax, hFrac, hCur, nCyc, tCyc, tFrac;\nint idObj;\nconst int mxStep = 200;\nconst float pi = 3.1415927;\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, sWid, fx;\n  dMin = dstFar;\n  q = p;\n  q.y -= hFrac - hCur;\n  d = PrRoundBoxDf (q, vec3 (pWid, hMax - hCur, 0.), 0.005);\n  q.y += hCur;\n  DMINQ (1);\n  sWid = 0.1;\n  q = p;\n  d = abs (q.x) - pWid;\n  q.y -= - hMax + hFrac - hCur;\n  fx = floor (q.x / sWid);\n  q.x -= sWid * (fx + 0.5);\n  q.xz = Rot2D (q.xz, 0.2 * pi * (Hashff (fx + 17.33 * nCyc) - 0.5) * (q.y - hCur));\n  d = max (d, PrRoundBoxDf (q, vec3 (0.5 * sWid - 0.008, hCur, 0.), 0.005));\n  q.x = p.x;\n  q.y += hCur - hMax;\n  DMINQ (1);\n  q = p;\n  q.y -= hFrac;\n  d = SmoothMax (PrRoundBoxDf (q, vec3 (pWid + 0.15, hMax + 0.15, 0.02), 0.02),\n     - PrBox2Df (q.xy, vec2 (pWid, hMax)), 0.02);\n  DMINQ (2);\n  q.z -= 0.01;\n  d = PrBoxDf (q, vec3 (pWid, hMax, 0.01));\n  DMINQ (3);\n  q = p;\n  d = 10. - q.z;\n  DMINQ (4);\n  return 0.8 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 80; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat FracDf (vec3 p)\n{  // (KIFS fractal simplified from leon's \"Taste of Noise 7\")\n  vec3 ip, a;\n  float s, gSize, f, w;\n  p.x += 0.02 * tFrac;\n  gSize = 3.;\n  ip = floor (p / gSize);\n  p -= (ip + 0.5) * gSize;\n  a = vec3 (0.1, 0.2, 0.3) + 0.5 * length (p) + 0.1 * p + ip;\n  w = 5. + 3. * sin (2. * pi * Hashfv3 (ip) + 0.7 * tFrac);\n  s = gSize;\n  f = 0.1;\n  for (int j = 0; j < 5; j ++) {\n    p.xz = abs (p.xz) - w * f;\n    p.yz = Rot2D (p.yz, a.x);\n    p.xz = Rot2D (p.xz, a.y);\n    p.yx = Rot2D (p.yx, a.z);\n    s = SmoothMin (s, PrSphDf (p, f), f);\n    f *= 0.5;\n  }\n  return 0.5 * s;\n}\n\nvec2 FracRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  int nStep;\n  dHit = 0.;\n  nStep = 0;\n  for (int j = VAR_ZERO; j < mxStep; j ++) {\n    d = FracDf (ro + dHit * rd);\n    ++ nStep;\n    if (d < 0.01 || dHit > dstFar) break;\n    dHit += d;\n  }\n  if (nStep == mxStep) nStep = 0;\n  return vec2 (dHit, float (nStep));\n}\n\nvec3 FracNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = FracDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 FracCol (vec2 p)\n{\n  vec3 ro, rd, col, vn;\n  vec2 ff;\n  float dstFrac;\n  ro = vec3 (0., 0., -10.);\n  rd = normalize (vec3 (p, 5.));\n  ff = FracRay (ro, rd);\n  col = vec3 (0.);\n  if (ff.x < dstFar) {\n    ro += ff.x * rd;\n    if (ff.y > 0.) {\n      vn = FracNf (ro);\n      col = HsvToRgb (vec3 (mod (ff.y / float (mxStep) + 0.03 * tFrac, 1.), 0.9, 1.)) * vn.z * vn.z;\n      col = pow (clamp (col, 0., 1.), vec3 (0.7));\n    }\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstObj, t;\n  pWid = 1.;\n  hMax = 1.3;\n  hFrac = 0.7 * hMax;\n  t = fract (tCur / tCyc);\n  nCyc = floor (tCur / tCyc);\n  hCur = hMax * (0.1 + 0.85 * (1. - smoothstep (0.75, 0.8, t)) * smoothstep (0.1, 0.4, t)) - 0.15;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1) {\n      col4 = vec4 (1., 1., 1., 0.);\n      if (qHit.z < 0.) {\n        tFrac = tCur;\n#if FIX_LO_PIC\n        if (ro.y < hFrac - hMax) tFrac = nCyc * tCyc;\n#endif\n        qHit.y += 0.05;\n        if (PrBox2Df (qHit.xy, vec2 (pWid)) < -0.05) col4 = vec4 (FracCol (qHit.xy / pWid +\n           vec2 (1., 1.1)), -1.);\n      }\n    } else if (idObj == 2) {\n      col4 = vec4 (0.5, 0.4, 0.2, 0.2);\n    } else if (idObj == 3) {\n      col4 = vec4 (0.6, 0.3, 0.1, 0.) * (0.8 + 0.2 * Fbm2 (64. * ro.xy));\n    } else if (idObj == 4) {\n      col4 = vec4 (0.4, 0., 0., 0.);\n      vn = VaryNf (32. * ro, vn, 1.);\n    }\n    if (col4.a >= 0.) {\n      col = col4.rgb * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +\n         col4.a * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.);\n      col *= 1. - smoothstep (0.2, 0.6, dstObj / dstFar);\n    } else col = col4.rgb;\n  } else {\n    col = vec3 (0.);\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define AA  1   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr, t;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCyc = 15.;\n  t = smoothstep (0.15, 0.25, 0.5 - abs (fract (tCur / tCyc) - 0.5));\n  if (abs (uv.x) < 1.1 - 0.4 * t) {\n    az = 0.;\n    el = 0.;\n    if (mPtr.z > 0.) {\n      az += 2. * pi * mPtr.x;\n      el += pi * mPtr.y;\n    }\n    az = clamp (az, -0.6 * pi, 0.6 * pi);\n    el = clamp (el, -0.3 * pi, 0.3 * pi);\n    vuMat = StdVuMat (el, az);\n    ro = vuMat * mix (vec3 (0., 0.9, -7.), vec3 (0., 0., -12.), t);\n    zmFac = 4.5;\n    dstFar = 100.;\n    ltDir = normalize (vec3 (0.5, 1., -1.));\n#if ! AA\n    const float naa = 1.;\n#else\n    const float naa = 3.;\n#endif  \n    col = vec3 (0.);\n    sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n    for (float a = float (VAR_ZERO); a < naa; a ++) {\n      rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n         sr * (0.667 * a + 0.5) * pi), zmFac));\n      col += (1. / naa) * ShowScene (ro, rd);\n    }\n  } else col = vec3 (0.82);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, vec3 (37., 39., 41.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsGSzy.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 919, 941, 941, 1762], [1764, 1764, 1797, 1797, 1980], [1982, 1982, 2003, 2003, 2258], [2260, 2260, 2283, 2344, 2852], [2854, 2854, 2887, 2887, 3169], [3171, 3171, 3193, 3193, 3449], [3451, 3451, 3474, 3474, 3898], [3900, 3900, 3935, 3935, 5218], [5262, 5262, 5318, 5318, 6569], [6571, 6571, 6604, 6604, 6631], [6633, 6633, 6665, 6665, 6765], [6767, 6767, 6800, 6800, 6889], [6891, 6891, 6937, 6937, 6984], [6986, 6986, 7031, 7031, 7123], [7125, 7125, 7170, 7170, 7208], [7210, 7210, 7234, 7234, 7351], [7353, 7353, 7389, 7389, 7595], [7597, 7597, 7627, 7627, 7740], [7774, 7774, 7798, 7798, 7835], [7837, 7837, 7861, 7861, 7921], [7923, 7923, 7947, 7947, 8012], [8014, 8014, 8038, 8038, 8150], [8152, 8152, 8177, 8177, 8363], [8365, 8365, 8386, 8386, 8541], [8543, 8543, 8572, 8572, 8784], [8786, 8786, 8825, 8825, 9077]]}
{"id": "fsGXWG", "name": "galaxyyy", "author": "rifke", "description": "optimized from https://www.shadertoy.com/view/MdXSzS", "tags": ["galaxy", "universes"], "likes": 14, "viewed": 499, "published": "Public API", "date": "1635172364", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// optimized from https://www.shadertoy.com/view/MdXSzS\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = (fragCoord.xy/iResolution.xy)-.5;\n\tfloat len = length(uv.xy);\n\t\n    float t = .01*iTime;\n\tfloat time = t  +  (5.+sin(t))*.11 / (len+.07); // spiraling\n\tfloat si = sin(time), co = cos(time);\n\tuv *= mat2(co, si, -si, co);                    // rotation\n\n\tfloat c=0., v1=0., v2=0., v3;  vec3 p;\n\t\n\tfor (int i = 0; i < 100; i++) {\n\t\tp = .035*float(i) *  vec3(uv, 1.);\n\t\tp += vec3(.22,  .3,  -1.5 -sin(t*1.3)*.1);\n\t\t\n\t\tfor (int i = 0; i < 8; i++)                // IFS\n\t\t\tp = abs(p) / dot(p,p) - 0.659;\n\n\t\tfloat p2 = dot(p,p)*.0015;\n\t\tv1 += p2 * ( 1.8 + sin(len*13.0  +.5 -t*2.) );\n\t\tv2 += p2 * ( 1.5 + sin(len*13.5 +2.2 -t*3.) );\n\t}\n\t\n\tc = length(p.xy) * .175;\n\tv1 *= smoothstep(.7 , .0, len);\n\tv2 *= smoothstep(.6 , .0, len);\n\tv3  = smoothstep(.15, .0, len);\n\n\tvec3 col = vec3(c,  (v1+c)*.25,  v2);\n\tcol = col  +  v3*.9;                      // useless: clamp(col, 0.,1.)\n\tfragColor=vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsGXWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 56, 113, 113, 1021]]}
{"id": "fsGXzc", "name": "Curvature shader", "author": "iY0Yi", "description": "For SDF Sculptors!\nI've noticed the curvature is useful as a visual debug with complex SDF modelling.\nI've mostly just copied and pasted Evan's postprocess code.\n\"Screen Space Curvature Shader\" by Evan Wallace:\nhttp://madebyevan.com/shaders/curvature/", "tags": ["modeling", "debug", "curvature", "sculpting"], "likes": 32, "viewed": 280, "published": "Public API", "date": "1635002927", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Screen Space Curvature Shader\" by Evan Wallace:\n// http://madebyevan.com/shaders/curvature/\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n// Change shading type\n#define CURVATURE 0\n#define METAL 0\n#define RED_WAX 1\n\n\n// Shoe Model from my shader.\n// \"A man from 'A LOST MEMORY'\" by iYOYi:\n// https://www.shadertoy.com/view/Ws3yW4\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n#define PI 3.14159265\n#define TAU (2.0*PI)\n#define saturate(x) clamp(x, 0.0, 1.0)\n\n#define MIN_DIST 0.001\n#define MAX_DIST 30.0\n#define ITERATION 100\n\n#define SHOW_ANIM 0\nvec3 ro = vec3(0), rd = vec3(0);\n\n// Cheap Rotation by las:\n// http://www.pouet.net/topic.php?which=7931&page=1\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\nvec3 rot(vec3 p,vec3 r){\n    R(p.xz, r.y);\n    R(p.yx, r.z);\n    R(p.zy, r.x);\n    return p;\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 n, int rep){\n    float sum = 0.0;\n    float amp= 1.0;\n    for (int i = 0; i <rep; i++){\n        sum += noise(n) * amp;\n        n += n*4.0;\n        amp *= 0.25;\n    }\n    return sum;\n}\n\n// SDF functions by iq and HG_SDF\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// https://mercury.sexy/hg_sdf/\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat vmax(vec3 v){\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat sdBox( in vec2 p, in vec2 b ) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdEllipsoid(in vec3 p, in vec3 r) {\n    return (length(p/r)-1.0)*min(min(r.x,r.y),r.z);\n}\n\nfloat sdCappedTorus(vec3 p, vec2 r, float per) {\n    p.x = abs(p.x);\n    vec2 sc = vec2(sin(per),cos(per));\n    float k = (sc.y*p.x>sc.x*p.z) ? dot(p.xz,sc) : length(p.xz);\n    return sqrt( dot(p,p) + r.x*r.x - 2.0*r.x*k ) - r.y;\n}\n\nfloat sdBox(vec3 p,vec3 b) {\n    vec3 d=abs(p)-b;\n    return length(max(d,vec3(0)))+vmax(min(d,vec3(0.0)));\n}\n\nfloat fOpUnion(in float a,in float b) {\n    return a<b?a:b;\n}\n\nvec4 v4OpUnion(in vec4 a,in vec4 b) {\n    return a.x<b.x?a:b;\n}\n\nfloat fOpUnionSmooth(float a,float b,float r) {\n    vec2 u = max(vec2(r - a,r - b), vec2(0));\n    return max(r, min (a, b)) - length(u);\n}\n\nfloat fOpSubstraction(in float a,in float b) {\n    return max(-a, b);\n}\n\nfloat fOpSubstractionSmooth( float a,float b,float r) {\n    vec2 u = max(vec2(r + b,r + -a), vec2(0));\n    return min(-r, max (b, -a)) + length(u);\n}\n\nvoid pElongate(inout float p, in float h ) {\n    p = p-clamp(p,-h,h);\n}\n\nfloat sdFoot(vec3 p) {\n\tfloat d = MAX_DIST;\n\tfloat bsd = length(p), bsr=0.2500;\n\tif (bsd > 2.*bsr) return bsd-bsr;\n    \n\tvec3 cpFoot = p;\n\t{\n\t\tvec3 q = cpFoot;\n#if SHOW_ANIM\n        float patapata = -q.z*(sin(iTime*5.)*.5+.05)+cos(iTime*5.)*.5;\n#else\n        float patapata = -.3;\n#endif\n        q.yz*=mat2(cos(-q.z*1.25+patapata+vec4(0,11,33,0)));\n        cpFoot=q;\n\t}\n\tvec3 cpFoot_Main = cpFoot;\n\tcpFoot_Main.xyz += vec3(0.0000, 0.0000, 0.1273);\n\tpElongate(cpFoot_Main.y, 0.0125);\n\t{\n\t\tvec3 q=cpFoot_Main;\n        vec3 pq=q;pq.yz *= mat2(cos(.6 + vec4(0, 11, 33, 0)));\n        float ycl = smoothstep(.002,.2,q.y);\n        float zcl = 1.-smoothstep(-.2,.5,q.z);\n        float zcl2 = smoothstep(-.2,.0,q.z);\n        q.z+=fbm(vec2(pq.x*20.5,pq.y*80.), 1)*.075*ycl*zcl*zcl2;\n        cpFoot_Main=q;\n\t}\n\n    // Shoe\n    float d1,d2;\n\td1 = sdEllipsoid(rot(cpFoot_Main+vec3(-0.0005, 0.0274, 0.1042), vec3(0.0818, -0.6861, 0.0566)), vec3(0.1102, 0.1233, 0.1214));\n\td1 = fOpUnionSmooth(sdEllipsoid(rot(cpFoot_Main+vec3(0.0028, -0.0093, -0.1258), vec3(-0.0291, -0.2744, -0.0364)), vec3(0.0870, 0.2295, 0.0880)), d1, 0.1438);\n\td1 = fOpSubstractionSmooth(sdBox(cpFoot+vec3(0.0000, -0.194, 0.0019), vec3(0.1676, 0.0551, 0.1171)), d1, 0.0100);\n    d1 = fOpSubstractionSmooth(dot(cpFoot_Main, vec3(0,1,0)) - .001, d1, 0.0080);\n\td1 = fOpSubstraction(sdBox(rot(cpFoot+vec3(0.0000, 0.0171, 0.1521), vec3(-1.4413, 0.0000, 0.0000)), vec3(0.1676, 0.0912, 0.0116)), d1);\n\td1 = fOpUnionSmooth(sdCappedTorus(cpFoot+vec3(0.0028, -0.1578, 0.0014), vec2(0.0519, 0.0264), 3.1413), d1, 0.0100);\n\t\n\t// Shoe lace\n\td2 = sdCappedTorus(rot(cpFoot+vec3(0.0000, -0.0579, 0.1827), vec3(1.5708, 0.0000, 0.0000)), vec2(0.0636, 0.0064), 0.6283);\n\td2 = fOpUnion(sdCappedTorus(rot(cpFoot+vec3(0.0000, -0.1001, 0.0608), vec3(2.2401, -0.3407, 0.2843)), vec2(0.0636, 0.0064), 0.6283), d2);\n\td2 = fOpUnion(sdCappedTorus(rot(cpFoot+vec3(0.0000, -0.0639, 0.1321), vec3(1.7335, 0.4446, -0.0513)), vec2(0.0636, 0.0064), 0.6283), d2);\n\td2 = fOpUnion(sdCappedTorus(rot(cpFoot+vec3(0.0000, -0.1001, 0.0608), vec3(2.2463, 0.3180, -0.2669)), vec2(0.0636, 0.0064), 0.6283), d2);\n\td2 = fOpUnion(sdCappedTorus(rot(cpFoot+vec3(0.0000, -0.0639, 0.1321), vec3(1.7334, -0.4468, 0.0515)), vec2(0.0636, 0.0064), 0.6283), d2);\n\t\n\treturn min(d1,d2);\n}\n\nfloat sdScene(vec3 p) {\n    return sdFoot(p);\n}\n\nfloat intersect() {\n    float d = MIN_DIST;\n\n    for (int i = 0; i < ITERATION; i++) {\n        vec3 p = ro + d * rd;\n        float res = sdScene(p);\n        res*=.5;\n        if (abs(res) < MIN_DIST)break;\n        d += res;\n        if (d >= MAX_DIST) return MAX_DIST;\n    }\n    if(d>MAX_DIST) return MAX_DIST;\n    return d;\n}\n\n// from iq's shader\nvec3 normal(vec3 p) {\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ ) {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdScene(p+0.0005*e);\n    }\n    return normalize(n);\n}\n\n// Camera localized normal\nvec3 campos, camup;\nvec3 localNormal(vec3 p) {\n    vec3 n = normal(p), ln;\n    vec3 side = cross(campos, camup);\n    return vec3(dot(n,  side), dot(n,  camup), dot(n,  -rd));\n}\n\n// \"camera\": create camera vectors.\nvoid camera(vec2 uv) {\n    const float pY = .5;\n    const float cL = 10.;\n    const vec3 forcus = vec3(0,.08,-.137);\n    const float fov = .015;\n\n    vec3 up = vec3(0,1,0);\n    vec3 pos = vec3(0,0,0);\n    pos.xz = vec2(sin(iTime*.6),cos(iTime*.6))*cL;\n    if(iMouse.z>.5)\n        pos = vec3(sin(iMouse.x/iResolution.x*TAU),sin(iMouse.y/iResolution.y*TAU),cos(iMouse.x/iResolution.x*TAU))*cL;\n    vec3 dir = normalize(forcus-pos);\n    vec3 target = pos-dir;\n    vec3 cw = normalize(target - pos);\n    vec3 cu = normalize(cross(cw, up));\n    vec3 cv = normalize(cross(cu, cw));\n\tcampos = cw, camup = cv;\n    mat3 camMat = mat3(cu, cv, cw);\n    rd = normalize(camMat * normalize(vec3(sin(fov) * uv.x, sin(fov) * uv.y, -cos(fov))));\n    ro = pos;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = (uv*2.-1.);\n    uv.x *= iResolution.x / iResolution.y;\n\n    camera(uv);\n    float hit = intersect();\n    vec3 p = ro + hit * rd;\n\n    vec3 n = localNormal(p);\n    float depth = distance(ro, p)/MAX_DIST;\n    \n    // I've mostly just copied and pasted Evan's code.\n    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// Compute curvature\n\tvec3 dx = dFdx(n);\n\tvec3 dy = dFdy(n);\n\tvec3 xneg = n - dx;\n\tvec3 xpos = n + dx;\n\tvec3 yneg = n - dy;\n\tvec3 ypos = n + dy;\n\tfloat curvature = (cross(xneg, xpos).y - cross(yneg, ypos).x) * 2.0 / (depth*5.);\n\n\t// Compute surface properties\n    #if CURVATURE\n        vec3 light = vec3(0.0);\n        vec3 ambient = vec3(curvature + 0.5);\n        vec3 diffuse = vec3(0.0);\n        vec3 specular = vec3(0.0);\n        float shininess = 0.0;\n    #elif METAL\n        float corrosion = clamp(-curvature * 3.0, 0.0, 1.0);\n        float shine = clamp(curvature * 5.0, 0.0, 1.0);\n        vec3 light = normalize(vec3(0.0, 1.0, 10.0));\n        vec3 ambient = vec3(0.15, 0.1, 0.1)*.5;\n        vec3 diffuse = mix(mix(vec3(0.3, 0.25, 0.2), vec3(0.45, 0.5, 0.5), corrosion),\n        vec3(0.5, 0.4, 0.3), shine) - ambient;\n        vec3 specular = mix(vec3(0.0), vec3(1.0) - ambient - diffuse, shine);\n        float shininess = 128.0;\n    #elif RED_WAX\n        float dirt = clamp(0.25 - curvature * 4.0, 0.0, 1.0);\n        vec3 light = normalize(vec3(0.0, 1.0, 10.0));\n        vec3 ambient = vec3(0.05, 0.015, 0.0);\n        vec3 diffuse = mix(vec3(0.4, 0.15, 0.1), vec3(0.4, 0.3, 0.3), dirt) - ambient;\n        vec3 specular = mix(vec3(0.15) - ambient, vec3(0.0), dirt);\n        float shininess = 32.0;\n    #endif\n    \n    // Compute final color\n    float cosAngle = dot(n, light);\n    fragColor.rgb = ambient +\n    diffuse * max(0.0, cosAngle) +\n    specular * pow(max(0.0, cosAngle), shininess);\n    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    \n    fragColor.rgb = pow(fragColor.rgb*1.5, vec3(.9));\n    if(depth>.9) fragColor.rgb = vec3(.125);\n\tfragColor.a = 1.;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsGXzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[639, 766, 790, 790, 860], [862, 862, 882, 882, 954], [956, 956, 982, 982, 1318], [1320, 1320, 1347, 1347, 1518], [1520, 1729, 1748, 1748, 1786], [1788, 1788, 1825, 1825, 1905], [1907, 1907, 1948, 1948, 2002], [2004, 2004, 2052, 2052, 2235], [2237, 2237, 2265, 2265, 2346], [2348, 2348, 2387, 2387, 2409], [2411, 2411, 2448, 2448, 2474], [2476, 2476, 2523, 2523, 2614], [2616, 2616, 2662, 2662, 2687], [2689, 2689, 2744, 2744, 2838], [2840, 2840, 2884, 2884, 2911], [2913, 2913, 2935, 2935, 5199], [5201, 5201, 5224, 5224, 5248], [5250, 5250, 5269, 5269, 5574], [5576, 5596, 5617, 5715, 5912], [5914, 5961, 5987, 5987, 6117], [6119, 6155, 6177, 6177, 6899], [6901, 6901, 6956, 6956, 9050]]}
{"id": "fsGXzG", "name": "Extruded Pixelated Spiral", "author": "Shane", "description": "Extruded pixelated spiral", "tags": ["pixel", "spiral", "design", "extrude"], "likes": 43, "viewed": 463, "published": "Public API", "date": "1635163502", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n    Extruded Pixelated Spiral\n    -------------------------\n\n\tOn Shadertoy I often come across very simple 2D examples that I like.\n    Sometimes, if I think the base pattern is interesting enough, I might\n    extrude it just to see what it looks like. Extruded imagery is a bit\n    of a computer graphics cliche, but I like it.\n    \n    This particular image is loosely based on a minimal spiral image by\n    Foxic -- The link is below, for anyone interested. To adhere to the \n    spirit of the original, I've extruded it in a pixelized manner and kept \n    roughly the same palette. However, it looks pretty interesting in other \n    colors too.\n    \n    Technically, there's not a lot to this. Hopefully, it'll run fine on\n    most systems. It'd be a lot more efficient to render the 2D spiral on\n    a backbuffer first, but I wanted to keep things simple.\n    \n\n\n\tInspired by:\n    \n\t// I like the minimal design.\n    Pixelized IceCreamSwirl - foxic\n\thttps://www.shadertoy.com/view/NdVXWz\n    \n    // Tater's been putting up some pretty nice shaders lately.\n    Spiraled Layers - Tater\n    https://www.shadertoy.com/view/Ns3XWf\n\n\n*/\n\n\n// Global tile scale.\nvec2 scale = vec2(1./8., 1./8.);\n\n// Off the rows by half a cell to produce a brickwork feel. The staggered \n// effect can also make a quantized image look smoother.\n#define ROW_OFFSET\n\n// Use hexagon pylons instead of squares.\n//#define HEXAGON\n\n// Boring out holes on alternate blocks to give it more of a tech feel and\n// to provide a little extra visual stimuli. Without the holes, the image\n// looks cleaner, but less interesting, I feel.\n#define HOLES\n\n// Raising the faces of the pylon tops. I find it can help bounce the light \n// off the surface in a more reflective way.\n//#define RAISED\n\n// Putting a ridge decoraction on the pylon tops.        \n//#define RIDGES\n\n\n// The hexagons must use offset rows.\n#ifdef HEXAGON\n#ifndef ROW_OFFSET\n#define ROW_OFFSET\n#endif\n#endif\n\n// Max ray distance.\n#define FAR 20.\n\n\n\n// Scene object ID to separate the mesh object from the terrain.\nfloat objID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n\n// Height map value.\nfloat hm(in vec2 p){ \n\n    \n    // Render the swirl by adding polar coordinates. You can apply the logarithm to\n    // the length for a different kind of feel, but I'll leave it in its current form.\n    float swirl = fract(atan(p.y, p.x)/6.2831 + length(p)*1.25 - iTime/4.);\n    // Alternative octagon swirl -- Other metrics are also possible.\n    /*\n    vec2 ap = abs(p);\n    float oct =  max(max(ap.x, ap.y), (ap.x + ap.y)*.7071);\n    float swirl = fract(atan(p.y, p.x)/6.2831 + oct*1.5 - iTime/4.);\n    */\n\n    //swirl = abs(swirl - .5)*2.; swirl = smoothstep(.15, .85, swirl);\n    swirl = sin(swirl*6.2831)*.5 + .5;\n    \n    \n    // In the form above, the height transitions between zero and one.\n    // The following simply manipulates the way in which that happens.\n    \n    // Number of quantization levels.\n    #define lNum 4.\n    float iswirl = floor(swirl*lNum*.9999)/lNum;\n\n    // Arrange for the pylons to smoothly transition between quantization\n    // levels whilst honoring the pixelated look... I could have described\n    // that better, but hopefully, you know what I mean. :D\n    return mix(iswirl, iswirl + 1./lNum, smoothstep(0., 1., swirl));\n    // Popping unnaturally from one state to the next.\n    //return iswirl*lNum/(lNum - 1.); \n    // Continuous, smooth motion.\n    //return swirl; \n    \n    \n}\n\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h){\n    \n    vec2 w = vec2( sdf, abs(pz) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n\n    /*\n    // Slight rounding. A little nicer, but slower.\n    const float sf = .015;\n    vec2 w = vec2( sdf, abs(pz) - h - sf/2.);\n  \treturn min(max(w.x, w.y), 0.) + length(max(w + sf, 0.)) - sf;\n    */\n}\n\n#ifdef HEXAGON\n// Signed distance to a regular hexagon, with a hacky smoothing variable thrown\n// in. -- It's based off of IQ's more exact pentagon method.\nfloat sHexS(in vec2 p, float r, in float sf){\n    \n    \n      const vec3 k = vec3(-.8660254, .5, .57735); // pi/6: cos, sin, tan.\n     \n      // X and Y reflection.  \n      p = abs(p); \n      p -= 2.*min(dot(k.xy, p), 0.)*k.xy;\n\n      r -= sf;\n      // Polygon side.\n      return length(p - vec2(clamp(p.x, -k.z*r, k.z*r), r))*sign(p.y - r) - sf;\n    \n}\n#endif\n\n/*\n// IQ's unsigned box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  return length(max(abs(p) - b + sf, 0.)) - sf;\n}\n*/\n\n// IQ's signed box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  vec2 d = abs(p) - b + sf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - sf;\n}\n\n \n// A regular extruded block grid.\n//\n// The idea is very simple: Produce a normal grid full of packed square pylons.\n// That is, use the grid cell's center pixel to obtain a height value (read in\n// from a height map), then render a pylon at that height.\n\nvec4 blocks(vec3 q3){\n    \n    \n\n    // Brick dimension: Length to height ratio with additional scaling.\n    vec2 l = scale;\n\tvec2 s = scale*2.;\n    #ifdef HEXAGON\n    vec2 hSc = vec2(1, scale.y/scale.x*2./1.732);\n    #endif\n    \n    float minSc = min(scale.x, scale.y);\n    \n    // Distance.\n    float d = 1e5;\n    // Cell center, local coordinates and overall cell ID.\n    vec2 p, ip;\n    \n    // Individual brick ID.\n    vec2 id = vec2(0); \n    \n    // Four block corner postions.\n    #ifdef ROW_OFFSET\n    // Offset rows.\n    vec2[4] ps4 = vec2[4](vec2(-.25, .25), vec2(.25), vec2(.5, -.25), vec2(0, -.25)); \n    #else\n    vec2[4] ps4 = vec2[4](vec2(-.25, .25), vec2(.25), vec2(.25, -.25), vec2(-.25)); \n    #endif\n    \n    float data = 0.; // Extra data.\n    \n    for(int i = min(0, iFrame); i<4; i++){\n\n\n        // Local coordinates.\n        p = q3.xy;\n        ip = floor(p/s - ps4[i]) + .5; // Local tile ID.\n        \n        // Correct positional individual tile ID.\n        vec2 idi = (ip + ps4[i])*s;\n        \n        p -= idi; // New local position.\n\n\n        // The extruded block height. See the height map function, above.\n        float h = hm(idi);\n        \n        h *= .1;\n            \n         \n        #ifdef HEXAGON\n        // Hexagon option: Multiply scale by \"vec2(1, 1.732/2.),\"\n        // and have the ROW_OFFSET define turned on.\n        float di2D = sHexS(p.yx, minSc/1.732 - .008, .02);\n        #else\n        float di2D = sBoxS(p, l/2. - .008, .02);        \n        //float di2D = length(p) - l.x/2. + .004;\n        #endif\n        \n        \n        #ifdef HOLES\n        // Boring out some of the boxes.\n        if((i&1)==0) di2D = max(di2D, -(di2D + minSc/4.));\n        #endif\n        \n        // The extruded distance function value.\n        float di = opExtrusion(di2D, (q3.z + h - .5), h + .5);\n        \n        \n        #ifdef RAISED\n        // Raised tops.\n        di += di2D*.25;\n        #endif\n        \n        #ifdef RIDGES\n        // Putting ridges on the faces.\n        di += sin(di2D/minSc*6.2831*3.)*.005;\n        #endif\n        \n        /*\n        // Lego.\n        float cap = length(p) - scale.x/4.;\n        cap = opExtrusion(cap, (q3.z + h - .5 + .035), h + .5);\n        di = min(di, cap); //di = max(di, -cap)\n        */\n        \n        \n\n        // If applicable, update the overall minimum distance value,\n        // ID, and box ID. \n        if(di<d){\n            d = di;\n            id = idi;\n            // Extra data. In this case, the 2D distance field.\n            data = di2D;\n        }\n        \n    }\n    \n    // Return the distance, position-base ID and box ID.\n    return vec4(d, id, data);\n}\n\n\n// Block ID -- It's a bit lazy putting it here, but it works. :)\nvec4 gID;\n\n// The extruded image.\nfloat map(vec3 p){\n    \n    // Floor.\n    float fl = -p.z + .1;\n\n    // The extruded blocks.\n    vec4 d4 = blocks(p);\n    gID = d4; // Individual block ID.\n    \n \n    // Overall object ID.\n    objID = fl<d4.x? 1. : 0.;\n    \n    // Combining the floor with the extruded object.\n    return  min(fl, d4.x);\n \n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    for(int i = min(0, iFrame); i<96; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n        \n        t += d*.7; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\tconst vec2 e = vec2(.001, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\t\n                          map(p + e.yyx) - map(p - e.yyx)));\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not always affordable. :)\n    const int maxIterationsShad = 24; \n    \n    ro += n*.0015; // Coincides with the hit condition in the \"trace\" function.  \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), .0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, \n    // the lowest number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += clamp(d, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 3., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    #ifdef HEXAGON\n    scale *= vec2(2./1.732, 1);\n\t#endif\n    \n\t// Camera Setup.\n    // Tilted camera, just to prove it's 3D. :)\n\t//vec3 ro = vec3(0, -1.3, -2.2); // Camera position, doubling as the ray origin.\n\t//vec3 lk = ro + vec3(0, .12, .25);//vec3(0, -.25, iTime);  // \"Look At\" position.\n\t// Front on camera.\n    vec3 ro = vec3(0, 0, -2.2); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(0, 0, .25);//vec3(0, -.25, iTime);  // \"Look At\" position.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(-.25, .5, 1);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.333; // FOV - Field of view.\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    //vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n    // Swiveling the camera about the XY-plane.\n\trd.xy *= rot2( sin(iTime)/32. );\n    \n\t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    // Save the block field value, block ID and 2D data field value.\n    vec4 svGID = gID;\n    \n    float svObjID = objID;\n  \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n        vec3 sn = getNormal(sp, t);\n        \n            \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 16.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n        //sh = min(sh + ao*.25, 1.);\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        //diff = pow(diff, 4.)*2.; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 32.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow(clamp(1. - abs(dot(sn, rd))*.5, 0., 1.), 2.);\n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a hard clay consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\tfloat freS = mix(.15, 1., Schlick);  //F0 = .2 - Glass... or close enough. \n        \n          \n        // Obtaining the texel color. \n\t    vec3 texCol = vec3(.6);   \n\n        // The extruded grid.\n        if(svObjID<.5){\n            \n            float h = hm(svGID.yz);\n            \n            //texCol = mix(vec3(.05), vec3(1), h); // White.\n            texCol = mix(vec3(.05), vec3(1.4, .2, .6), h); // Pink.\n            //texCol = mix(vec3(.05), vec3(.5, 1, .25), h); // Green.\n            //texCol = mix(vec3(.05), vec3(.25, .7, 1.5), h); // Blue.\n            //texCol = mix(vec3(.05), mix(vec3(1.4, .2, .6), vec3(2, .3, .3), diff*diff*1.5), h);\n            \n            // Extra blending options.\n            //texCol = mix(texCol, texCol.xzy, h);\n            //texCol = mix(texCol, texCol.zyx, clamp((ld.y - ld.x) - .5, 0., 1.));\n            //texCol = mix(texCol.zyx, texCol, diff*diff*1.5);\n             \n            \n            /*\n            // Dark edges.\n            //vec2 lCoord = sp.xy - svGID.yz;\n            vec2 sc = scale;\n            float lw = .006;\n            float dS = abs(svGID.w) - lw; // 2D face field value.\n            //texCol = mix(texCol, min(texCol.xzy*1.35 + .1, 1.), (1. - smoothstep(0., .005, dS + lw)));\n            dS = max(dS, abs(sp.z + h*.1*2.) - lw/2.); // Just the rim.\n            texCol = mix(texCol, vec3(0), (1. - smoothstep(0., .005, dS))*.8);\n            */\n \n        }\n        else {\n            \n            // The dark floor in the background. Hidden behind the pylons, but\n            // you still need it.\n            texCol = vec3(0);\n        }\n       \n\n        \n        // Combining the above terms to produce the final color.\n        col = texCol*(diff*sh + .3 + vec3(.25, .5, 1)*fre*0. + vec3(1, .97, .92)*spec*freS*2.*sh);\n      \n        // Shading.\n        col *= ao*atten;\n        \n          \n\t\n\t}\n          \n    \n    // Rought gamma correction.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsGXzG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2067, 2100, 2122, 2122, 2180], [2183, 2211, 2232, 2232, 2295], [2298, 2319, 2339, 2517, 3642], [3645, 3672, 3729, 3729, 4035], [4691, 4719, 4766, 4766, 4856], [4860, 5116, 5137, 5220, 7763], [7842, 7865, 7883, 7902, 8172], [8176, 8197, 8233, 8282, 8720], [8723, 8823, 8859, 8859, 9043], [9046, 9237, 9289, 9370, 10638], [10641, 10793, 10828, 10828, 11073], [11076, 11076, 11132, 11165, 16290]]}
{"id": "fsKSDh", "name": "Twisting Gears", "author": "LoganLang", "description": "Twisting Gears", "tags": ["2d", "pattern", "rotation"], "likes": 9, "viewed": 87, "published": "Public", "date": "1634602180", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159;\n\nfloat sdCircle(vec2 st, float r) { \nreturn length(st) - r; \n} \n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat stroke(float x, float w){ \n    w *= .5; \n    return 1.-smoothstep(w-.01,w+.01,abs(x)); \n} \n\nfloat fill(float sdf){\n    return 1.-smoothstep(-.01,.01,sdf);\n}\n\nmat2 rotate2d(float angle){ \n    mat2 rot = mat2(cos(angle),-sin(angle), sin(angle),cos(angle)); \n    return rot; \n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(.4);\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    uv = (uv-vec2(1.,.5)) * rotate2d(iTime * .25);\n    uv = fract(uv);\n    float zoomMod = 6.;\n    uv *= zoomMod;\n    \n    float timeIndex = mod(iTime * 1.5, zoomMod);\n    for (int i = 0; i < 6; i++){\n        float j = float(i);\n        float rowIndex = step(j,uv.y) * 1.-step(j+1.,uv.y);\n        float colIndex = step(j,uv.x) * 1.-step(j+1.,uv.x);\n        \n        if (floor(timeIndex) < 3.) {\n            if (j == floor(timeIndex)) {\n                uv.x += rowIndex * -mod(timeIndex,1.);\n            }\n            if (mod(j+2.,zoomMod) == floor(timeIndex)) {\n                uv.x += rowIndex * mod(timeIndex,1.);\n            }\n        } else {\n            if (j == floor(timeIndex)) {\n                uv.y += colIndex * -mod(timeIndex,1.);\n            }\n            if (mod(j+2.,zoomMod) == floor(timeIndex)) {\n                uv.y += colIndex * mod(timeIndex,1.);\n            }\n        }\n    }\n    \n    vec2 st = (fract(uv)-.5)*2.;\n    \n    float turnMod = PI * .5;\n    for (int i = 0; i < 6; i++){\n        float j = float(i);\n        float rowIndex = step(j,uv.y) * 1.-step(j+1.,uv.y);\n        float colIndex = step(j,uv.x) * 1.-step(j+1.,uv.x);\n    \n        if (floor(timeIndex) < 3.) {\n            if (j == floor(timeIndex)) {\n                st = st * rotate2d(mod(timeIndex,1.) * turnMod * rowIndex);\n            }\n            if (mod(j+2.,zoomMod) == floor(timeIndex)) {\n                st = st * rotate2d(-mod(timeIndex,1.) * turnMod * rowIndex);\n            }\n        } else {\n            if (j == floor(timeIndex)) {\n                st = st * rotate2d(mod(timeIndex,1.) * turnMod * colIndex);\n            }\n            if (mod(j+2.,zoomMod) == floor(timeIndex)) {\n                st = st * rotate2d(-mod(timeIndex,1.) * turnMod * colIndex);\n            }\n        }\n    }\n    \n    float ring = abs(sdCircle(st, .4))-.12;\n    for(int i = 0; i < 8; i++){\n        float j = float(i);\n        st = st * rotate2d(PI*.25);\n        float square = sdBox(st-vec2(0.,.48),vec2(.07,.1))-.1;\n        ring = min(ring, square);\n    }\n    \n    col += fill(ring);\n    col = mix(col,vec3(.05),stroke(ring,.1));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsKSDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 61, 61, 88], [91, 91, 128, 128, 208], [210, 210, 241, 241, 305], [308, 308, 330, 330, 372], [374, 374, 401, 401, 490], [493, 493, 550, 550, 2795]]}
{"id": "fsKSDR", "name": "flying cloth", "author": "arnav_007", "description": "...", "tags": ["glsl", "cloth", "satisfying"], "likes": 1, "viewed": 43, "published": "Public", "date": "1634477036", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash(float n) { return fract(sin(n) * 1e4); }\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\nfloat noise(float x) {\n\tfloat i = floor(x);\n\tfloat f = fract(x);\n\tfloat u = f * f * (3.0 - 2.0 * f);\n\treturn mix(hash(i), hash(i + 1.0), u);\n}\n\nfloat noise(vec2 x) {\n\tvec2 i = floor(x);\n\tvec2 f = fract(x);\n\n\tfloat a = hash(i);\n\tfloat b = hash(i + vec2(1.0, 0.0));\n\tfloat c = hash(i + vec2(0.0, 1.0));\n\tfloat d = hash(i + vec2(1.0, 1.0));\n\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float time = iTime / 2.;\n    \n    uv.x += uv.y + sin(time + cos(time+uv.x));\n    uv.y += uv.x + cos(time + sin(time+uv.x));\n\n    float f = .5*noise(10.*uv);\n    \n    vec3 col = mix(vec3(.9,.0,0.), vec3(0.0,.0,.0), f);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsKSDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 51], [52, 52, 72, 72, 160], [162, 162, 184, 184, 304], [306, 306, 327, 327, 613], [615, 615, 672, 722, 1047]]}
{"id": "fsKSDt", "name": "Spectral Bar", "author": "antone", "description": "Spectral Colors", "tags": ["color", "grain", "spectral"], "likes": 13, "viewed": 112, "published": "Public", "date": "1635514674", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define RotateX(v,a) v.yz *= mat2(cos(a),sin(a),-sin(a),cos(a))\n#define RotateY(v,a) v.xz *= mat2(cos(a),sin(a),-sin(a),cos(a))\n#define RotateZ(v,a) v.xy *= mat2(cos(a),sin(a),-sin(a),cos(a))\n\n#define MIN_MARCH_DIST 0.0001\n#define MAX_MARCH_STEPS 500\n#define MAX_VOLUME_STEPS 5000\n#define VOLUME_STEP_SIZE 0.01\n\n// Simplex 2D noise\n//\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat snoise(vec2 v){\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\nvec3 spectral_zucconi (float w)\n{\n    // w: [400, 700]\n\t// x: [0,   1]\n\tfloat x = saturate((w - 400.0)/ 300.0);\n\tconst vec3 cs = vec3(3.54541723, 2.86670055, 2.29421995);\n\tconst vec3 xs = vec3(0.69548916, 0.49416934, 0.28269708);\n\tconst vec3 ys = vec3(0.02320775, 0.15936245, 0.53520021);\n\n\treturn bump3y (\tcs * (x - xs), ys);\n}\n\nvec3 spectral_zucconi6 (float w)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\tfloat x = saturate((w - 400.0)/ 300.0);\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n\nvec4 Volume(vec3 pos)\n{\n    float rand = 80.;\n    \n    //float vol = dot(normalize(pos),vec3(1,1,1));\n    float vol = normalize(pos.x);\n    vec3 col = mix(vec3(1.0,0.0,0.0),vec3(0.0,0.0,1.0),step(0.0,vol));\n    \n    vol = smoothstep(0.6,1.0,abs(vol));\n    \n \n\t//return vec4(snoise(vec2(1.0,pos.x)));\n    //float noise = (1.0/(1.0+exp(-2.*snoise(vec2(pos.x/6.-rand)))) - 0.5 ) * 2.0;\n    //noise -=  (1.0/(1.0+exp(-2.*snoise(vec2(pos.x/5.-rand)))) - 0.5 ) * 2.0;\n    //noise *=7.;\n    //noise = clamp(noise,0.0,1.0);\n    return vec4(spectral_zucconi((pos.x/3.+1.0)/2.0*200.0+450.0),clamp(0.12-length(vec2(pos.y,pos.z)/8.),0.0,1.0));\n    //return vec4(1.0,1.0,1.0,0.0002);\n}\n\nvec3 MarchVolume(vec3 orig, vec3 dir)\n{\n    //Ray march to find the cube surface.\n    float t = 0.0;\n    vec3 pos = orig;\n    for(int i = 0;i < MAX_MARCH_STEPS;i++)\n    {\n        pos = orig + dir * t;\n        float dist = 100.0;\n        \n        dist = min(dist, 12.0-length(pos));\n        dist = min(dist, max(max(abs(pos.x/5.),abs(pos.y)),abs(pos.z))-1.0);//length(pos)-1.0);\n        \n        t += dist;\n        \n        if(dist < MIN_MARCH_DIST){break;}\n    }\n    \n    //Step though the volume and add up the opacity.\n    vec4 col = vec4(0.0);\n    for(int i = 0;i < MAX_VOLUME_STEPS;i++)\n    {\n    \tt += VOLUME_STEP_SIZE;\n        \n    \tpos = orig + dir * t;\n        \n        //Stop if the sample becomes completely opaque or leaves the volume.\n        if(max(max(abs(pos.x/5.),abs(pos.y)),abs(pos.z))-1.0 > 0.0) {break;}\n        \n        vec4 vol = Volume(pos);\n        vol.rgb *= vol.w;\n        \n        col += vol;\n        //col = clamp(col,0.0,1.0);\n    }\n    \n    col.rgb = (1.0/(1.0+exp(-0.3*col.rgb)) - 0.5 ) * 2.0;\n    \n    return col.rgb;///2.2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n    vec3 dir = normalize(vec3(uv-res/2.0,1.0));\n    vec3 orig = vec3(0,0,-9.5);\n\n        \n    RotateX(dir,radians(iMouse.y));\n    RotateX(orig,radians(iMouse.y));\n    RotateY(dir,radians(-iMouse.x));\n    RotateY(orig,radians(-iMouse.x));\n\n    \n    vec3 color = MarchVolume(orig,dir);\n    vec2 seed = fragCoord.xy;\n    float x = (seed.x / 3.14159 + 4.) * (seed.y / 13. + 4.) * ((fract(iTime) + 1.) * 10.);\n    float grain = mod((mod(x, 13.) + 1.) * (mod(x, 123.) + 1.), 0.01) - 0.005;\n\n    \n\tfragColor = grain*20. + vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsKSDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[312, 335, 357, 357, 396], [398, 398, 419, 419, 1239], [1242, 1242, 1268, 1268, 1303], [1304, 1304, 1328, 1328, 1385], [1387, 1805, 1841, 1841, 1914], [1915, 1915, 1948, 1985, 2243], [2245, 2245, 2279, 2313, 2781], [2783, 2783, 2806, 2806, 3455], [3457, 3457, 3496, 3538, 4515], [4517, 4517, 4574, 4574, 5202]]}
{"id": "fsKSWD", "name": "swirls on sphere (2D swirl seed)", "author": "FabriceNeyret2", "description": "2D variant of https://shadertoy.com/view/ssGSDh\nPrinciple:\nWorley-like 2D grid on surface with 1 seed point per cell. \nrotate sur coordinates around it.\nclick: no noise texture.", "tags": ["procedural", "swirl", "texture", "planet", "short", "loopless", "jupiter"], "likes": 15, "viewed": 299, "published": "Public API", "date": "1634660845", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 2D version of https://shadertoy.com/view/ssGSDh\n// operate on a Worley grid on surface instead of Worley grid in volume.\n\n// WIP. Many discontinuities to fix.   \n// See options and coefs.\n\n#define H(p)       fract(sin((p)*mat2(246.1, 113.5, 271.9, 124.6 ))*43758.5453123)\n#define R(p,a)   (p)*mat2( cos(a),-sin(a),sin(a),cos(a) )\n#define hue(v)   ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( 2.*u - R ) / R.y;\n\n    O-=O;\n    float r = length(U), y,w=0., l=9., s = 4.;      // s: swirls size\n    int i,k;\n    if ( r > 1. ) return;\n    \n    vec3 p = vec3( U, sqrt(1.-r*r) );          // raytracing point in sphere\n    vec2 P0 = vec2( atan(p.z,p.x) - .1*iTime, atan(p.y,length(p.xz)) ),\n     // TODO: compress lattitudes near pole to get conform cells \n         P = s*P0, I,F, H,D;\n     //  F = abs(fract(P+.5)-.5); y = min(F.x,F.y); O += smoothstep(12./R.y,0.,y); // debug: grid\n         I = floor(P), F = fract(P);           // coords in 2D grid\n    y = P0.y;                                  // latitude ( to tune swirl direction & amplitude )\n    y = 4.*cos(4.*y); \n // if (mod(I.x+I.y,2.)>0.) y=-y;              // if checkered rotation direction\n    P-=P;\n#define dist2seed  \\\n        D = vec2( k%3, k/3 ) -1.;              /* cell offset         */    \\\n        D += H(I+D)-.5;                        /* random seed point   */    \\\n        r = length(F-D);                       /* distance to seed    */\n\n    for ( k = 0; k < 9; k++) {                 // visit neighbor cells to find closest seed point\n        dist2seed;\n     // y = -y;                                // checkered rotation direction\n        F  =   R( F-D, y*smoothstep(.5,0.,r) ) + D; P = F+I;\n     // P  =   R( F-D, y*smoothstep(.5,0.,r) ) + D+I;  I = floor(P),F = fract(P);\n     // P += ( R( F-D, y*smoothstep(.5,0.,r) ) + D+I )/r; w += 1./r;\n        r < l ? l = r, i = k : i;              // keep closest dot \n     }\n    // P /= w;\n/** k = i;\n    dist2seed;\n // if ( i%2 < 1 ) y = -y;                                        // checkered rotation direction\n    P = R( F-D, y * smoothstep(.5,0.,r) ) + D+I;                  // rotate coords around seed point\n/**/       \n // O += vec4(smoothstep(12./R.y,0., l-.2) ); return;             // test: plot seed points\n    \n    U = P/s; U.x -= .1*iTime;                                     // surface coordinates\n    O += ( iMouse.z > 0. ? vec4(.6) \n             : smoothstep(.8,.2, texture(iChannel0, U*vec2(1,3))))// swirled texture\n        * (.5+.5*hue(abs(U.y*2./3.14)))                           // color\n        * ( .3 + 1.2* max(0., dot(p,vec3(1,0,1))));               // shading\n}", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsKSWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[125, 401, 439, 439, 2698]]}
{"id": "fsKSzy", "name": "Waves Morphing (01)", "author": "spenceryonce", "description": "Was messing around with waves transformations and came up with this one. ", "tags": ["waves", "sin", "color", "cos", "trippy", "weird", "morphing"], "likes": 3, "viewed": 45, "published": "Public", "date": "1634851830", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int AMOUNT = 2;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = 20.0 * (fragCoord.xy - iResolution.xy / 2.0) / min(iResolution.y, iResolution.x);\n    \n    float len;\n    \n    for(int i = 0; i < AMOUNT; i++){\n        len = length(vec2(coord.x, coord.y));\n        \n        coord.x *= coord.x - cos(coord.y + sin(len)) + cos(iTime / 9.0);\n        coord.y = coord.y + sin(coord.x + cos(len)) + sin(iTime / 12.0);\n    }\n    \n    fragColor = vec4(cos(len * 1.1), cos(len * 1.2), cos(len * 1.4), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsKSzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 80, 80, 530]]}
{"id": "fsKXD3", "name": "Sine Wave Animation", "author": "SerialSniper", "description": "A cool sine wave animation", "tags": ["sine"], "likes": 2, "viewed": 19, "published": "Public", "date": "1635416135", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float min_thickness = 0.02;\nconst float max_thickness = 0.05;\nconst float freq = 30.0;\nconst float ampl = 0.1;\n\nfloat speed = 1.0;\nfloat thickness = 0.02;\nfloat invert = 1.0;\n\nvec3 mask(float min, float max, vec2 uv, vec3 col, vec3 background) {\n    const float tollerance = 0.000001;\n\n    float maxStep = smoothstep(max, max + tollerance, uv.y);\n    float minStep = smoothstep(min + tollerance, min, uv.y);\n    col = mix(col, background, maxStep);\n    col = mix(col, background, minStep);\n    \n    return col;\n}\n\nfloat sine(float angle, vec2 uv) {\n    return sin((angle + speed + uv.x) * freq) * invert * ampl + 0.5;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0, 2, 4));\n    vec3 background = vec3(0);\n    \n    speed = sin(iTime) + 1.0;\n    thickness = (cos(iTime) / 2.0 + 0.5) * (max_thickness - min_thickness) + min_thickness;\n    invert = cos(iTime);\n    \n    float wave = sine(iTime, uv) - thickness / 2.0;\n    float wave2 = sine(iTime, uv) + thickness / 2.0;\n    \n    background = mix(vec3(0), col, -cos(iTime) / 2.0 + 0.5);\n    col = mix(col, vec3(0), -cos(iTime) / 2.0 + 0.5);\n    \n    col = mask(wave, wave2, uv, col, background);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsKXD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[182, 182, 251, 251, 518], [520, 520, 554, 554, 625], [627, 627, 682, 682, 1290]]}
{"id": "fsKXzy", "name": "Waves Morph (04)", "author": "spenceryonce", "description": "Trying some more different things here. I like more.\n\nWarning: this is best viewed on a retina display, like a macbook pro, or just with at least 800 x 500 view, 1280 x 960 is even better", "tags": ["waves", "math", "sin", "color", "cos", "trippy", "weird", "morphing"], "likes": 0, "viewed": 57, "published": "Public", "date": "1634853748", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int AMOUNT = 12;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = 20.0 * (fragCoord.xy - iResolution.xy / 2.0) / min(iResolution.y, iResolution.x);\n    \n    float len;\n    \n    for(int i = 0; i < AMOUNT; i++){\n        len = length(vec2(coord.x, coord.y))*2.0;\n        \n        coord.x = coord.x - cos(coord.y + sin(len)) + cos(iTime / 12.0);\n        coord.y = coord.y + sin(coord.x + cos(len)) + sin(iTime / 9.0);\n    }\n    \n    fragColor = vec4(cos(len * 1.1), cos(len * 1.05), cos(len * 1.01), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsKXzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 81, 81, 536]]}
{"id": "fstSRl", "name": "Quadratic Isosurfaces", "author": "silentsiege", "description": "Isosurfaces of random quadratic polynomials, clipped by another isosurface. Inspired by some of the Windows 11 wallpapers (at least Microsoft's artists are still competent). I might try this again with cubics to get more complicated shapes.", "tags": ["3d", "raytracing"], "likes": 1, "viewed": 151, "published": "Public API", "date": "1633807911", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const uint antiA = 3u; //raise or lower this\n\nconst mat4x3 bgPal = mat4x3(0.5,0.5,0.5,0.5,0.5,0.5,1.0,1.0,1.0,0.0,0.33,0.67);\nconst mat4x3 sfPal = mat4x3(0.5,0.5,0.5,0.5,0.5,0.5,1.0,1.0,1.0,0.0,0.10,0.20);\n\nconst float err = 1e10;\nmat3  fA, cA;\nvec3  fB, cB;\nfloat fC, cC;\n\nvec3 bgCol;\nvec3 sfCol;\n\n\nvec3 hash3(uint n) \n{\n    //https://www.shadertoy.com/view/llGSzw\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    uvec3 k = n * uvec3(n,n*16807U,n*48271U);\n    return vec3( k & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nmat2x3 boxM(uint n) {\n    vec3 U = hash3(n), V = hash3(n + 2568758767u);\n    U = sqrt(-2.*log(U));\n    V *= 2.*3.14159265;\n    return mat2x3(U*cos(V), U*sin(V));\n}\n\nvec3 pal(float t, mat4x3 a) {\n    //https://www.shadertoy.com/view/ll2GD3\n    return a[0] + a[1]*cos(2.*3.14159265*(a[2]*t+a[3]));\n}\n\nvoid set(uint n) {\n    n *= 100u;\n    for (uint i = 0u; i < 3u; ++i) {\n        mat2x3 tmp = boxM(n++);\n        fA[i] = tmp[0];\n        cA[i] = tmp[1];\n        fA[i][i] /= sqrt(2.);\n        cA[i][i] /= sqrt(2.);\n    }\n\n    fB = 2.*(hash3(n++) - 1.);\n    cB = 2.*(hash3(n++) - 1.);\n    fA *= .3;\n    \n    cB *= .3;\n    cA *= .2;\n    cC = 0.;\n    fC = 0.;\n    \n    bgCol = pow(pal(hash3(n++).x, bgPal), vec3(.35));\n    sfCol = pow(pal(hash3(n++).x, sfPal), vec3(1.));\n    \n}\n\nfloat eval(vec3 x, mat3 A, vec3 B, float C) {\n    return dot(x, A*x) + dot(B, x) + C;\n}\n\nvec3 grad(vec3 x, mat3 A, vec3 B) {\n    return B + A*x + x*A;\n}\n\nvec3 param(vec3 x, vec3 d, mat3 A, vec3 B, float C) {\n    return vec3(eval(x,A,B,C), dot(grad(x,A,B), d), dot(d, A*d));\n}\n\nfloat func(vec3 x) {\n    return eval(x, fA, fB, fC);\n}\n\nfloat cond(vec3 x) { \n    return eval(x, cA, cB, cC);\n}\n\nvec3 funcGrad(vec3 x) {\n    return grad(x, fA, fB);\n}\n\nvec3 condGrad(vec3 x) {\n   return grad(x, cA, cB);\n}\n\nvec2 solve(vec3 p) {\n    float a = p.z, b = p.y, c = p.x;\n    float disc = b*b - 4.*a*c;\n\n    if (disc < 0.) return vec2(err);\n    \n    vec2 tmp;\n    \n    if (false && abs(a) < 1e-6 )\n        tmp = vec2(-c/b, err);\n    else if (false && abs(c) < 1e-6)\n        tmp = vec2(0., -a/b);\n    else {\n        tmp.x = (-b - sign(b)*sqrt(disc))/2./a;\n        tmp.y = c/a/tmp.x;\n    }\n    if (tmp.y < tmp.x) tmp = tmp.yx;\n    if (tmp.x < 0.)    tmp = vec2(tmp.y, err);\n    if (tmp.x < 0.)    tmp = vec2(err);\n    return tmp;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    const float duration = 3., speed = 1.;\n    set(uint(iTime/duration) + 0u);\n    fC -= iTime * speed;\n    \n    const float delta = 1.5, focal = 1.3;\n    \n    vec2 uv = (2.*fragCoord - iResolution.xy) / iResolution.y;\n    float pixel = 1./iResolution.y;\n    \n    vec3 ro = vec3(0., 0., 4.);\n    \n    vec3 colTot = vec3(0.);\n    \n    for (uint nAA = 0u; nAA < antiA*antiA; ++nAA) {\n        const float aaStep = 1./float(antiA);\n        vec2 uv1 = vec2(nAA/antiA, nAA%antiA)*aaStep + .5*aaStep;\n        uv1 = (uv1 - .5) * 2.*pixel;\n        vec3 rd = normalize(vec3(uv+uv1, -focal));\n        \n        vec3 fPar = param(ro, rd, fA, fB, fC);\n        vec3 cPar = param(ro, rd, cA, cB, cC);\n        vec2 cIsect = solve(cPar);\n        \n        vec3 col;\n        \n        if (cIsect.x < err) {\n            float hit = func(ro+rd*cIsect.x);\n            vec2 pot = delta * (floor(hit / delta) + vec2(0., 1.));\n            vec4 fIsect = vec4(solve(fPar-vec3(pot.x,0.,0.)), solve(fPar-vec3(pot.y,0.,0.)));\n\n            float t = err;\n            for (int i = 0; i < 4; ++i) {\n                if (fIsect[i] < min(t, cIsect.y) && fIsect[i] > cIsect.x)\n                    t = fIsect[i];\n            }\n\n            vec3 pos = ro + t*rd;\n            vec3 fGrad = funcGrad(pos)/delta;\n            vec3 cGrad = condGrad(pos)/abs(cond(pos));\n            \n            float occ = length(fGrad) / length(cGrad);\n            occ = sqrt(occ);\n            occ = 1. - occ/sqrt(1. + occ*occ);\n            occ = sqrt(occ);\n            \n            col = t < err ? sfCol * occ : bgCol;\n            col = mix(col, sfCol, smoothstep(-2.*pixel, -pixel, -1./cIsect.x));\n        }\n        else\n            col = bgCol;\n        colTot += col;\n    }\n    colTot /= float(antiA*antiA);\n\n    colTot = pow(colTot, vec3(1./2.2));\n    fragColor = vec4(colTot,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fstSRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 300, 321, 365, 548], [550, 550, 571, 571, 713], [715, 715, 744, 788, 847], [849, 849, 867, 867, 1320], [1322, 1322, 1367, 1367, 1409], [1411, 1411, 1446, 1446, 1474], [1476, 1476, 1529, 1529, 1597], [1599, 1599, 1619, 1619, 1653], [1655, 1655, 1675, 1675, 1710], [1712, 1712, 1735, 1735, 1765], [1767, 1767, 1790, 1790, 1819], [1821, 1821, 1841, 1841, 2336], [2338, 2338, 2393, 2393, 4219]]}
{"id": "fstXDf", "name": "Spinny outline segments", "author": "LoganLang", "description": "A little hypnotic", "tags": ["2d"], "likes": 9, "viewed": 100, "published": "Public", "date": "1634091935", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159;\n\nfloat sdBox( in vec2 p, in vec2 b ) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat stroke(float x, float w) {\n    float d = smoothstep(-.01,0.,x+w*.5) - smoothstep(0.,.01,x-w*.5);\n    return clamp(d,0.,1.);\n}\n\nfloat trim(vec2 st, float num) {\n    float m = (mod(num,2.) > 0.) ? 1. : -1.;\n    return smoothstep(0.,.01,cos(4.*atan(st.y,st.x)+m*num*(iTime*.7)));\n}\n\nvec2 rotate(float angle, vec2 st, vec2 pos){\n    mat2 rot = mat2(cos(angle),-sin(angle), sin(angle),cos(angle));\n    st -= pos;\n    return rot * st;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.);\n    vec2 st = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    for (int i = 0; i < 18; i++){\n        float f = float(i);\n        float s = stroke(sdBox(rotate(PI*.25,st,vec2(0.)),vec2(.1)*f),.025) * trim(st,f);\n        col += s;\n    }\n    \n    col = clamp(col,vec3(.15),vec3(.95));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fstXDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 64, 64, 144], [146, 146, 178, 178, 277], [279, 279, 311, 311, 430], [432, 432, 476, 476, 582], [584, 584, 641, 641, 992]]}
{"id": "fstXWX", "name": "Dark land", "author": "akmaaars", "description": "trivial 3d perlin noise, one 2d slice for heightmap, another for lighting", "tags": ["noise", "perlin", "isoline"], "likes": 1, "viewed": 138, "published": "Public API", "date": "1634073783", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = 3.1415926535;\nfloat randf(int counter) // -> [0, 1]\n{\n    return fract(sin(float(counter)) * 43.7585453);\n}\nvec2 randf2(int counter)\n{\n    float phi = randf(counter) * 2. * pi;\n    return vec2(cos(phi), sin(phi));\n}\nvec3 randf3(int counter)\n{\n    float phi = randf(counter) * 2. * pi;\n    float cos_theta = 2. * randf(counter * 2) - 1.;\n    float sin_theta = sqrt(1. - cos_theta * cos_theta);\n    return vec3(cos(phi) * sin_theta, sin(phi) * sin_theta, cos_theta);\n}\n\nfloat g(float t)\n{\n    return t * t * (3. - 2. * t);\n}\n\nfloat squareSize;\nfloat perlinNoise(vec3 P) // -> [0, 1]\n{\n    vec3 p = P / squareSize;\n    ivec3 i = ivec3(floor(p));\n    vec3 r = fract(p);\n\n    const int iL = 10;\n    const int iS = iL * iL;\n    int i00 = i.x + iL * i.y + iS * i.z;\n\n    float f000 = dot(r - vec3(0., 0., 0.), randf3(i00));\n    float f001 = dot(r - vec3(1., 0., 0.), randf3(i00 + 1));\n    float f010 = dot(r - vec3(0., 1., 0.), randf3(i00 + iL));\n    float f011 = dot(r - vec3(1., 1., 0.), randf3(i00 + iL + 1));\n    float f100 = dot(r - vec3(0., 0., 1.), randf3(i00 + iS));\n    float f101 = dot(r - vec3(1., 0., 1.), randf3(i00 + iS + 1));\n    float f110 = dot(r - vec3(0., 1., 1.), randf3(i00 + iS + iL));\n    float f111 = dot(r - vec3(1., 1., 1.), randf3(i00 + iS + iL + 1));\n    float f00 = f000 + (f001 - f000) * g(r.x);\n    float f01 = f010 + (f011 - f010) * g(r.x);\n    float f10 = f100 + (f101 - f100) * g(r.x);\n    float f11 = f110 + (f111 - f110) * g(r.x);\n    float f0 = f00 + (f01 - f00) * g(r.y);\n    float f1 = f10 + (f11 - f10) * g(r.y);\n    return f0 + (f1 - f0) * g(r.z) + 0.5;\n}\n\nfloat bell(float x, float s)\n{\n    return exp2(-x * x * s);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    squareSize = min(iResolution.x, iResolution.y) * 0.3;\n    float t = iTime * squareSize;\n    vec3 p = vec3(gl_FragCoord.xy, 0.02 * t);\n    float f = perlinNoise(p);\n\n    vec2 dF = vec2(dFdx(f), dFdy(f));\n    const float lineWidth = 0.6;\n    float s = 0.72134752 / (dot(dF, dF) * lineWidth * lineWidth);\n\n    float c = 0.;\n    c += 0.2 * bell(f - 0.1, s);\n    c += 0.4 * bell(f - 0.2, s);\n    c += 0.5 * bell(f - 0.3, s);\n    c += 0.6 * bell(f - 0.4, s);\n    c += 0.8 * bell(f - 0.5, s);\n    c += 0.6 * bell(f - 0.6, s);\n    c += 0.5 * bell(f - 0.7, s);\n    c += 0.4 * bell(f - 0.8, s);\n    c += 0.2 * bell(f - 0.9, s);\n\n    p.z = t * 0.2 + 100.;\n    float I = (perlinNoise(p) + 0.3) * 0.7;\n    c *= (I * I) * (I * I);\n\n    fragColor = vec4(vec3(0.0, 0.0, 0.0) + vec3(c), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fstXWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 70, 70, 124], [125, 125, 151, 151, 232], [233, 233, 259, 259, 483], [485, 485, 503, 503, 539], [559, 559, 599, 599, 1606], [1608, 1608, 1638, 1638, 1669], [1670, 1670, 1727, 1727, 2508]]}
{"id": "fsVSWV", "name": "rainbow pseudo voronoi thingy", "author": "_samuelcho_", "description": "The minimum distant to points give voronoi. Coloring the distance fields. ", "tags": ["voronoi", "colorful"], "likes": 5, "viewed": 138, "published": "Public API", "date": "1635320107", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv *= 5.0;\n\n    vec2 p1 = vec2(sin(iTime*0.6942),cos(iTime*0.4269));\n    vec2 p2 = vec2(cos(iTime*0.888+0.8989),sin(iTime*0.666+69.69));\n    vec2 p3 = vec2(cos(iTime*1.069428+69.8989),sin(iTime*0.96942+55.88));\n    \n    \n    float d1 = length(uv-p1);\n    float d2 = length(uv-p2);\n    float d3 = length(uv-p3);\n    \n    d1 = sin(d1+iTime*0.9);\n    d2 = sin(d2+iTime*0.8);\n    d3 = sin(d3 + iTime*0.87);\n    \n    float d = min(d1,d2);\n    d = min(d,d3);\n    \n    \n    \n    vec3 col = vec3(0);\n   \n    col = palette(\n    d*0.5,\n    vec3(0.5),\n    vec3(.5),\n    vec3(1.),\n    vec3(.0,.1,.2));\n    col = mix(col, palette(d*0.5,vec3(.5),vec3(.5),vec3(1.),vec3(.0,.33,.66)), d2 *0.5+0.5);\n    col = mix(col, palette(d*0.5,vec3(.5),vec3(.5),vec3(1.),vec3(.0,.0,.0)), d1*0.5+0.5);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsVSWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 72, 72, 115], [117, 117, 174, 174, 1058]]}
{"id": "fsVSWW", "name": " Fab19 #inktober2021 \"loop\" 2", "author": "FabriceNeyret2", "description": "[url]https://inktober.com/[/url]\n#inktober2021 themes: [img]https://i.imgur.com/QjhAdpd.png[/img]\n\nvariant of https://shadertoy.com/view/sdGXWD\nHard to get nice ribbon borders !  another approach here: https://www.shadertoy.com/view/fdVSDW", "tags": ["2d", "short", "fourierseries", "inktober2021"], "likes": 19, "viewed": 244, "published": "Public API", "date": "1634655375", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://shadertoy.com/view/sdGXWD\n// another approach here: https://www.shadertoy.com/view/fdVSDW\n\n// --- utils inspired from https://www.shadertoy.com/view/llySRh\n\n#define H(p)     fract( sin( (p) * 78.233 ) * 43758.5453 ) // hash\n#define hue(v) ( .88 + .18 * cos( v  + vec3(0,23,21)  ) )  // desaturated hue\n#define S(v)     smoothstep(  8./R.y, 0.,   v )            // AA draw\n#define s(a,b)   t=a, a=b, b=t                             // swap\n\nfloat line(vec2 p, vec2 a,vec2 b, out float h) { // h = pos on segment ( possibly out )\n    p -= a, b -= a;\n    return length( p - b * clamp( h = dot(p, b) / dot(b, b), 0., 1.) );\n}\n\n// -----------------------------------------------------------\n\nvec2 f(float t) {                               // curve P(t)\n    vec2 P = vec2(0);\n    for (float f, i = 0.; i < 6.; i++ )         // Fourier series \n        f = exp2(i)*t + 6.283*H(i) + i*iTime,\n        P += vec2(cos(f),sin(f)) / pow(1.4, i); // spectrum 1.4^-f, random phase\n    return P;\n}\n#define D(t)  l = dot( P = f(t) - U, P )        // distance² to curve(t)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, P,\n         U = 2.5*( u+u - R ) / R.y;\n    float l, d0 = 9., d1=d0, T0,T1,t0,t1,e,h0,h1,h_,c0,c1, t=0., dt = .015, dt2 = dt/4.;\n    O-=O;\n    for ( ; t < 6.283; t+=dt )                  // Sample the curve and get the 2 closests\n        D(t),                                   //   that are not on the same segment.\n          l < d0 ?  t<=T0+dt ? d0=l,T0=t        // Prev best was on same segment: don't update 2nd best\n                             : ( d1=d0, T1=T0, d0=l, T0=t ) // independant best: save old as 2nd best\n        : l < d1 && t> T0+dt ? d1=l,T1=t : t;   // update 2nd best only if not on best segment\n        \n    if (iMouse.z > 0.) O += smoothstep(8./R.y, 0., sqrt(min(d0,d1))-.01 ); // test: draw dots\n\n    t0=T0; t1=T1;    \n    for ( t = -dt; t < dt; t += dt2 )           // Look more accurately around 1st and second\n        D(T0+t), l < d0 ? d0=l,  t0=T0+t : t,   //   closest curve segments.\n        D(T1+t), l < d1 ? d1=l,  t1=T1+t : t;\n        \n   // draw upstream and dowstream segment for 1st and 2nd best\n   // the mess with h & c is to draw the borders pushed only at the right extra angle on the round segment junction\n#define  L(t,h,c) ( d0 = line(U, f(t-dt2), f(t), h  ),  h  = (abs(h -.5)-.5)*length(f(t)-f(t-dt2)), \\\n                    d1 = line(U, f(t+dt2), f(t), h_ ),  h_ = (abs(h_-.5)-.5)*length(f(t)-f(t-dt2)), \\\n                  c = dot( normalize( f(t) - f(t-dt2) ), normalize( f(t+dt2) - f(t) ) ),            \\\n                ( d1 < d0 ? h=h_, d1 : d0 ) -.06 ) \n    T0 = L(t0,h0,c0), T1 = L(t1,h1,c1);\n\nif ( cos(t1) < cos(t0) ) s(T0,T1), s(t0,t1), s(h0,h1), s(c0,c1); // z-sort\n                                       // ribbon pattern (up to a bit of the joint)         , ribbon color,  ribbon mask\n#define B(h,t,T,c) O += (1.-O.a)* vec4( ( h > sqrt(1.-c*c)*(.2+6./R.y) ? 1. : S(T + 6./R.y) ) * hue(t), 1 ) * S(T) // blend ribon pattern*mask\n    B(h0,t0,T0,c0);                             // draw top segment\n    B(h1,t1,T1,c1);                             // draw bottom segment\n    O +=  1.-O.a ;                              // background\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsVSWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[113, 462, 510, 549, 643], [645, 709, 726, 770, 1002], [1078, 1078, 1116, 1116, 3234]]}
{"id": "fsVSzy", "name": "Tundra", "author": "jarble", "description": "A snowy landscape with erosion and domain warping.", "tags": ["noise", "terrain", "fbm", "ice", "snow", "mountain", "tundra"], "likes": 5, "viewed": 183, "published": "Public API", "date": "1634852294", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SC (250.0)\n\nvec2 noise(in vec2 uv)\n{\n    //return sin(uv.x/1.6)+cos(-uv.y*1.6);\n    return vec2(sin(uv.x),cos(uv.y))+vec2(1.);\n}\n\n#define OCTAVES 8\nfloat fbm1(in vec2 uv,int octaves,float i1,float value1)\n{\n    //this function generates the terrain height\n    \n    float f = 2.15; //change this number to change the spacing of the mountains \n    //Another interesting variation:\n    //float f = 2.15+(sin(uv.x/i1)+cos(uv.x/i1))*value1;\n    \n    float value = value1;\n    float amplitude = i1*value1;\n    float freq = i1/f;\n    float n1 = 0.;\n    vec2 noise2,noise1;\n    for (int i = 0; i < octaves; i++)\n    {\n        \n        \n        noise2 = noise(noise1.yx-uv/freq);\n        noise1 = noise2-vec2(value)-noise1.yx*freq;\n        freq /= -f;\n        n1 = noise1.x+noise1.y;\n\n        value += n1*(amplitude-freq);\n\n        uv -= noise2.yx*freq;\n    }\n    \n    return value/(4.);\n}\n\nfloat fbm(vec2 uv, int oct){\n    float result = 0.;\n    //uv /= 2.;\n    for(float i = 1.; i < 3.; i++){\n        float i1 = i*i;\n        result = fbm1(uv,oct,i1,result-result/i1);\n        oct /= 2;\n    }\n    return result;\n}\n\nfloat fbm(in vec2 uv){\n    return fbm(uv,OCTAVES);\n}\n\nfloat f(in vec3 p,int iters)\n{   \n    float h = fbm(p.xz,iters);\n    return h;\n}\n\nfloat f(in vec3 p)\n{   \n    float h = fbm(p.xz,OCTAVES);\n    return h;\n}\n\nvec3 getNormal(vec3 p, float t)\n{\n    vec3 eps=vec3(.001 * t, .0, .0);\n    vec3 n=vec3(f(p - eps.xyy) - f(p + eps.xyy),\n                2. * eps.x,\n                f(p - eps.yyx) - f(p + eps.yyx));\n  \n    return normalize(n);\n}\n\nfloat rayMarching(in vec3 ro, in vec3 rd, float tMin, float tMax)\n{\n    float t = tMin;\n\tfor( int i = 0; i < 300; i++ )\n\t{\n        vec3 pos = ro + t * rd;\n\t\tfloat h = pos.y - f(pos,OCTAVES);\n\t\tif( abs(h) < (0.0015 * t) || t > tMax ) \n            break;\n\t\tt += 0.4 * h;\n\t}\n\n\treturn t;\n}\n\n/*\n//raymarching with LOD\nfloat rayMarching(in vec3 ro, in vec3 rd, float tMin, float tMax)\n{\n    float t = tMin;\n    int oct = 2;\n\tfor( int i = 0; i < 300; i++ )\n\t{\n        vec3 pos = ro + t * rd;\n\t\tfloat h = pos.y - f(pos,OCTAVES);\n\t\tif( abs(h) < (0.0015 * t) || t > tMax ) \n            if(oct < 8) oct += 2;\n            else break;\n\t\tt += 0.4 * h;\n\t}\n\n\treturn t;\n}\n*/\n\nvec3 lighting(vec3 p, vec3 normal, vec3 L, vec3 V)\n{\n    vec3 sunColor = vec3(1., .956, .839);\n    vec3 albedo = vec3(1.);\n   \tvec3 diff = max(dot(normal, L) * albedo, 0.);\n    \n    vec3 refl = normalize(reflect(L, normal));\n    float spec = max(dot(refl, -normalize(V)), 0.);\n    spec = pow(spec, 18.);\n    spec = clamp(spec, 0., 1.);\n    float sky = max(0.0, dot(vec3(0.,1.,0.), normal));\n    \n    //float amb = 0.5 * smoothstep(0.0, 2.0, p.y);\n    \n    vec3 col = diff * sunColor;\n    col += spec * sunColor;\n    col += sky * vec3(0., .6, 1.) * .1;\n    //col += amb * .2;\n    \n   \treturn col;\n}\n\nmat3 lookAt(vec3 origin, vec3 target, float roll)\n{\n    vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n    vec3 ww = normalize(target - origin);\n    vec3 uu = normalize(cross(ww, rr));\n    vec3 vv = normalize(cross(uu, ww));\n\n    return mat3(uu, vv, ww);\n}\n\nvec3 camerapath(float t)\n{\n    vec3 p=vec3(-13.0+3.5*cos(t),3.3,-1.1+2.4*cos(2.4*t+2.0));\n\treturn p;\n}\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\t\n    vec3 lightDir = normalize(vec3(0., 1., -1.));\n    \n    vec3 camStep = vec3(-1., 0., 0.) * (iTime+12.)/8.;\n    vec3 camPos = vec3(8., 2., 5.+sin(iTime/2.)/4.) + camStep;\n    vec3 camTarget = vec3(1., 1., 4.) + camStep;\n\n    \n    mat3 mat = lookAt(camPos, camTarget, 0.0);\n    \n    vec3 ro = camPos;\n    ro.y += fbm(ro.xz,OCTAVES)/2.-1.6;\n\n    vec3 rd = normalize(mat * vec3(uv.xy, 1.0));\n        \n    if (length(iMouse.xy) > 40.0) {\n        rd.yx *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        rd.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n\n    \n    float tMin = .1;\n    float tMax = 20.;\n    float t = rayMarching(ro, rd, tMin, tMax);\n    \n    vec3 col = vec3(0.);\n    \n    if (t > tMax)\n    {\n        // from iq's shader, https://www.shadertoy.com/view/MdX3Rr\n        float sundot = clamp(dot(rd, lightDir), 0.0, 1.0);\n        col = vec3(0.3,0.5,0.85) - rd.y*rd.y*0.5;\n        col = mix( col, 0.85*vec3(0.7,0.75,0.85), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n        // sun\n\t\tcol += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n\t\tcol += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n\t\tcol += 0.2*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );\n        // clouds\n\t\tvec2 sc = ro.xz + rd.xz*(SC*1000.0-ro.y)/rd.y;\n\t\tcol = mix( col, vec3(1.0,0.95,1.0), 0.5*smoothstep(0.5,0.8,fbm(0.0005*sc/SC)) );\n        // horizon\n        col = mix( col, 0.68*vec3(0.4,0.65,1.0), pow( 1.0-max(rd.y,0.0), 16.0 ) );\n    }\n    else\n    {\n        vec3 p = ro + rd * t;\n        vec3 normal = getNormal(p, t);\n        vec3 viewDir = normalize(ro - p);\n        \n        // lighting terrian\n        col = lighting(p, normal, lightDir, viewDir);\n        \n        // fog\n        float fo = 1.0-exp(-pow(30. * t/SC,1.5) );\n        vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n        col = mix( col, fco, fo);\n    }\n    \n    // Gama correction\n    col = pow(clamp(col, 0., 1.), vec3(.45)); \n    \n    fragColor = vec4(vec3(col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsVSzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 44, 87, 136], [156, 156, 214, 263, 888], [890, 890, 918, 918, 1113], [1115, 1115, 1137, 1137, 1167], [1169, 1169, 1199, 1199, 1249], [1251, 1251, 1271, 1271, 1323], [1325, 1325, 1358, 1358, 1552], [1554, 1554, 1621, 1621, 1839], [1841, 2213, 2265, 2265, 2810], [2812, 2812, 2863, 2863, 3064], [3066, 3066, 3092, 3092, 3168], [3236, 3236, 3293, 3293, 5260]]}
{"id": "fsVXWG", "name": "1_3_posterization", "author": "tomoe", "description": "sample code", "tags": ["ch1"], "likes": 1, "viewed": 89, "published": "Public API", "date": "1635217437", "time_retrieved": "2021-10-01T00:00:00", "image_code": "int channel;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy / iResolution.xy;\n    vec3[4] col4 = vec3[](\n        vec3(1.0, 0.0, 0.0),\n        vec3(1.0, 1.0, 0.0),\n        vec3(1.0, 0.0, 1.0),\n        vec3(1.0, 1.0, 1.0)\n    );\n    float n = 10.0;\n    pos *= n;\n    channel = int(2.0 * fragCoord.x / iResolution.x);\n    if (channel == 0){  //left: step\n        pos = floor(pos) + step(0.5, fract(pos));\n    } else {  //right: smoothstep\n        float thr = 0.25 * sin(iTime);\n        pos = floor(pos) + smoothstep(0.25 + thr, 0.75 - thr, fract(pos));\n    }\n    pos /= n;\n    vec3 col = mix(mix(col4[0], col4[1], pos.x), mix(col4[2], col4[3], pos.x), pos.y);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsVXWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[13, 13, 70, 70, 729]]}
{"id": "fsVXzR", "name": "Colorful donut", "author": "renansales", "description": "Just a simple test with shaders", "tags": ["test"], "likes": 0, "viewed": 44, "published": "Public", "date": "1634258457", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy -0.5)*2.0;\n    \n    float aspectRatio = iResolution.x/iResolution.y;\n    uv.x *= aspectRatio;\n    \n    fragColor.rg = uv;\n    fragColor.b = 1.0;\n    \n    float thickness = iMouse.x/iResolution.x;\n    float fade = 0.005;\n    thickness += fade;\n    float wfreq = 50.0;\n    float distance = 1.0 - length(uv);//sin(wfreq*length(uv));\n    vec3 col = vec3(smoothstep(0.0,fade,distance));\n    \n    //fragColor.rgb = vec3(distance);\n    //fragColor.rgb = vec3(1.0,0.50,0.4);\n    col*= vec3(smoothstep(thickness,thickness-fade,distance));\n    \n   \n    \n    fragColor.rgb = col;\n    fragColor.rgb *= cos(iMouse.x/iResolution.x+iTime+uv.xyx+vec3(0,2,4));//\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsVXzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 800]]}
{"id": "fsySDd", "name": "Grid Spiral Test", "author": "SnoopethDuckDuck", "description": "e", "tags": ["e"], "likes": 12, "viewed": 165, "published": "Public API", "date": "1635470296", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\n// idea:\n// change brightness depending on difference in radius from last frame to this one,\n// for each cell / circle\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    \n    float xr = 40.; float yr = 40.;\n    \n    vec2 ipos = vec2(floor(xr * uv.x) + 0.5, floor(yr * uv.y) + 0.5);\n    vec2 fpos = vec2(fract(xr * uv.x) - 0.5, fract(yr * uv.y) - 0.5);\n    \n    float id = length(ipos);//max(abs(ipos.x), abs(ipos.y));\n    float d = 1.- length(fpos);//max(abs(fpos.x), abs(fpos.y));\n   // d *= .5;\n    // 3.5 30. 3.5 // 30. / 37.\n   // float m = 30./37.;\n    float a = atan(ipos.y, ipos.x);\n    float b = .5 + .5 * cos(iTime + 0.1 * length(ipos));\n    //b = b * (1.-b) * 4.;\n    float e = 1.8 + 0.5 * cos(-0.8 * iTime + 1. * a + 0.5 * id);\n    float e2 = e + cos(0.8 * iTime + 3. * a - 0.5 * id);\n\n    //float e2= cos(0.1 * id + 0.8 * iTime);//\n    float c = step(max(0.5, pow(0.5 + 0.5 * (1.-b) * e,12.)), d);//(1.-b) * e);\n    \n    float c2 =  step(max(0.5, pow(0.5 + 0.5 * b * e2, 4.)), d);//(1.-b) * e);//step(0.5 + 0.5 * b * e2, d);\n    c = smoothstep(-0.1,0.1,c2-c) * c;\n    //c *= .5 + .5 * cos(c + iTime);\n    //c = clamp(c, 0., 1.);\n    \n    vec3 col = pal(e/c + 0.4 * h21(ipos), vec3(0.5), vec3(0.5), vec3(1.5), vec3(0.,0.333,0.666));\n    \n    // Time varying pixel color\n   // vec3 col = vec3(c * e);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsySDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 68, 68, 111], [113, 113, 133, 133, 208], [210, 329, 386, 436, 1703]]}
{"id": "fsySWG", "name": "truchet 3d", "author": "drschizzo", "description": "truchet test", "tags": ["raymarching", "truchet"], "likes": 2, "viewed": 133, "published": "Public API", "date": "1635251321", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float N21(vec2 p){\n    p+=12.245;\n    p=fract(p*vec2(1.432342,515.5621));\n    p+=dot(p,p+341.3535);\n    return fract(p.x*p.y*.12);\n    \n}\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  float r=length(q)-t.y;\n  return min(r,length(vec3(abs(p.x),p.y,abs(p.z))-vec3(.17,0,.18))-.06);\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  \n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat crossTorus(vec3 p,vec3 id){\n    float w=.035;\n    \n    float t1=sdTorus(vec3(abs(p.x)-.5,p.z,abs(p.y)-.5),vec2(.25,w));\n    //t1=min(t1,length(p-vec3(.25,-.25,-.25))-.2);\n       \n\n\n    float t2=sdTorus(vec3(abs(p.x)-.5,p.z,p.y),vec2(.25,w));\n    t2=min(t2,sdTorus(vec3(p.x,p.z,abs(p.y)-.5),vec2(.25,w)));\n   \n\n\n    float r=N21(id.xy+id.z+floor(iTime/3.));\n    float rn=N21(id.xy+id.z+floor(iTime/3.)+1.);\n    float t=r>.5?t1:t2;\n    float tn=rn>.5?t1:t2;\n    \n    return mix(t,tn,smoothstep(.8,.9,fract(iTime/3.)));\n\n    \n}\n\nfloat cube(vec3 p, vec3 id){\n    \n    float c=cos(1.57);\n    float s=sin(1.57);\n    mat2 m=mat2(c,s,-s,c);\n    vec2 a=p.yz*m;\n    vec2 b=p.xz*m;\n    float t=min(crossTorus(p,id),crossTorus(vec3(p.x,a.x,a.y),id));\n    t=min(crossTorus(vec3(a.x,p.y,b.y),id),t);\n    return max(sdBox(p,vec3(.52)),t);\n}\n\nvec3 transform(inout vec3 p){\n    float c=cos(sin(iTime/10.));\n    float s=sin(sin(iTime/10.));\n    \n    mat2 m=mat2(c,s,-s,c);\n    p.xy*=m;\n    vec3 op=p;\n    vec3 r=vec3(1.);\n    p=fract(p)-.5;\n    return floor(op-p); \n}\n\nfloat dist(vec3 p){\n    \n    vec3 id=transform(p);   \n    float cu=cube(p,id);\n       \n    return cu;\n}\n\nvec3 normal(vec3 p){\n    vec2 e=vec2(.001,0.0);\n    float d=dist(p);\n    vec3 n=vec3(\n        d-dist(p-e.xyy),\n        d-dist(p-e.yxy),\n        d-dist(p-e.yyx));\n    return normalize(n);\n}\n\n\n\nfloat rayMarch(vec3 ro, vec3 rd){\n    float d=0.;\n    float td=0.;\n    float i=0.;;\n    for(;i<50.;i++){\n        d=dist(ro+td*rd);\n        td+=d;\n        if(td>50. || d<.001)\n            break;\n    }\n    if(i>50.)\n        return 50.;\n    return float(td);    \n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n\n    for( float t=.001; t<100.; )\n    {\n        float h = dist(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\nvec3 shade(vec3 p,vec3 rd){\n    vec3 n=normal(p);\n    \n    \n    vec3 id=transform(p); \n    \n    vec3 col=vec3(.15,.55,.80);\n    //WIP color mix\n    vec3 col1=normalize(.5+.5*sin(iTime/2.+col*(id.x+id.y*10.)));\n    vec3 col2=normalize(.5+.5*sin(iTime/2.+col*((id.x+1.)+id.y*10.)));\n    vec3 col3=normalize(.5+.5*sin(iTime/2.+col*((id.x-1.)+id.y*10.)));\n    vec3 col4=normalize(.5+.5*sin(iTime/2.+col*((id.x)+(id.y-1.)*10.)));\n    vec3 col5=normalize(.5+.5*sin(iTime/2.+col*((id.x)+(id.y+1.)*10.)));\n    col1+=col3*smoothstep(.75,1.,length(p.x-vec2(.25)));\n    col1+=col2*smoothstep(.75,1.,length(p.x+vec2(.25)));\n    col1+=col4*smoothstep(.75,1.,length(p.y-vec2(.25)));\n    col1+=col5*smoothstep(.75,1.,length(p.y+vec2(.25)));\n    \n    vec3 a=col1/1.5*vec3(abs(dot(n,normalize(vec3(3.,2.,13.)-p))));\n    return a;//*softshadow(p+n*.1,normalize(-p+vec3(0,0.,0.-iTime/10.)),2.);\n}\n\n\n\n\n\n\nvoid mainImage0( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    float t=iTime/10.;\n    vec3 camera=vec3(0.,0.,6.-t);\n    vec3 lookAt=vec3(sin(iTime/3.),cos(iTime/3.),-t);\n    float zoom=.8;\n    vec3 f=normalize(camera-lookAt);\n    vec3 r=cross(vec3(0,1.,0),f);\n    vec3 u=cross(f,r);\n    vec3 c=camera-f*zoom;\n    vec3 i=c+uv.x*r+uv.y*u;\n    vec3 ray=normalize(i-camera);\n    \n    float d=rayMarch(c,ray);\n    \n    \n    vec3 p=c+ray*d;\n    vec3 n=normal(p);\n    vec3 col=shade(p,ray);\n    /*vec3 rf=reflect(n,ray);\n    float df=rayMarch(p+n*.01,rf);\n    float fresnel=clamp(pow(1.-dot(ray,n),5.),.2,.8);\n    col+=shade(p+rf*df,rf)*.3*fresnel;\n      */  \n    fragColor = vec4(col*max((1.-d*.15),.05),1.);\n}\n\n//from https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/ \nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if ( fwidth(length(O)) > .05 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n      //O.r++;                        // uncomment to see where the oversampling occurs\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsySWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 137], [140, 140, 173, 173, 312], [315, 315, 346, 346, 436], [438, 438, 471, 471, 967], [969, 969, 997, 997, 1268], [1270, 1270, 1299, 1299, 1492], [1494, 1494, 1513, 1513, 1597], [1599, 1599, 1619, 1619, 1787], [1791, 1791, 1824, 1824, 2052], [2054, 2054, 2107, 2107, 2322], [2324, 2324, 2351, 2351, 3201], [3208, 3208, 3266, 3266, 3972], [3974, 4052, 4088, 4088, 4428]]}
{"id": "fsySWm", "name": "Wave Rave Cube", "author": "Tater", "description": "One of my previous subdivision shaders but simplified without the random parts. ", "tags": ["3d", "raymarching", "cubes", "subdivision", "subdivide"], "likes": 54, "viewed": 1705, "published": "Public API", "date": "1634711496", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"Box Singularity\" by Tater. https://shadertoy.com/view/7dVGDd\n// 2021-10-20 06:09:34\n\n#define MDIST 350.0\n#define STEPS 200.0\n#define pi 3.1415926535\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define pmod(p,x) (mod(p,x)-0.5*(x))\n\n#define fs(i) (fract(sin((i)*114.514)*1919.810))\n\n//iq palette\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\n    return a + b*cos(2.*pi*(c*t+d));\n}\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\nfloat h11 (float a) {\n    return fract(sin((a)*12.9898)*43758.5453123);\n}\nfloat box(vec3 p, vec3 b){\n    vec3 d = abs(p)-b;\n    return max(d.x,max(d.y,d.z));\n}\n//iq box sdf\nfloat ebox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat swave(float x, float a){\n    return (sin(x*pi/3.-pi/2.)/sqrt(a*a+sin(x*pi/3.-pi/2.)*sin(x*pi/3.-pi/2.))+1./sqrt(a*a+1.))*0.5;\n}\nvec3 rdg = vec3(0);\n//No Cell bounds SDF of the blocks\nfloat nsdf = 0.;\nbool rnsdf = false;\nvec2 blocks(vec3 p, vec3 scl, vec3 rd){\n    float t = iTime;\n    \n    bvec3 isEdge = bvec3(true);\n    // the domain of the fractal being generated\n    // will be modified in the iteration part\n    vec3 dMin = vec3(-0.5) * scl;\n    vec3 dMax = vec3(0.5) * scl;\n    vec3 dMini = dMin;\n    vec3 dMaxi = dMax;\n    \n    float id = 0.;\n    float seed = floor(t/8.)+0.2;\n    \n    float ITERS = 5.;\n    \n    vec3 dim = dMax - dMin;\n    //Big thanks for @0b5vr for cleaner version of subdiv algo\n    for (float i = 0.; i < ITERS; i++) {\n\n        vec3 divHash = vec3(\n            0.49,\n            0.501,\n            0.511\n        );\n        vec3 divide = divHash * dim + dMin;\n        // update the box domain\n        dMax = mix( dMax, divide, step( p, divide ));\n        dMin = mix( divide, dMin, step( p, divide ));\n\n        float pad = 0.01;\n        if(dMaxi.x>dMax.x+pad&&dMini.x<dMin.x-pad)isEdge.x=false;\n        if(dMaxi.y>dMax.y+pad&&dMini.y<dMin.y-pad)isEdge.y=false;\n        if(dMaxi.z>dMax.z+pad&&dMini.z<dMin.z-pad)isEdge.z=false;\n        \n        // id will be used for coloring and hash seeding\n        \n        vec3 diff = mix( -divide, divide, step( p, divide));\n        id = length(diff + 10.0);\n    \n        // recalculate the dimension\n        dim = dMax - dMin;\n    }\n    float volume = dim.x*dim.y*dim.z;\n    vec3 center = (dMin + dMax)/2.0;\n    float b = 0.;\n    if(any(isEdge)) {\n    \n        float expand = 1.05+0.45*(sin(length(center+100.0)*0.35+t*3.0*pi/3.)*0.5+0.5);\n        //expand = 1.5; \n        if(isEdge.x){\n        dim.x+=abs(center.x*expand-center.x)*2.0;\n        center.x*=expand;\n        }\n        if(isEdge.y){\n        dim.y+=abs(center.y*expand-center.y)*2.0;\n        center.y*=expand;\n        }\n        if(isEdge.z){\n        dim.z+=abs(center.z*expand-center.z)*2.0;\n        center.z*=expand;\n        }\n        //id = 1.;\n    }\n    \n    vec3 edgeAxis = mix(dMin, dMax, step(0.0, rd));\n    vec3 dAxis = abs(p - edgeAxis) / (abs(rd) + 1E-4);\n    float dEdge = min(dAxis.x,min(dAxis.y,dAxis.z));\n    b= dEdge;\n    vec3 d = abs(center);\n    dim-=0.4;\n    float a = ebox(p-center,dim*0.5)-0.2;\n\n\n    nsdf = a;\n    a = min(a, b);\n\n    \n    id = h11(id)*1000.0;\n\n    return vec2(a,id);\n}\n\nvec3 map(vec3 p){\n    float t = iTime;\n\n    vec3 po = p;\n    vec2 a = vec2(1);\n\n    vec3 scl = vec3(15,15,15);\n    vec3 rd2 = rdg;\n    p.yz*=rot(t*0.5*pi/3.);\n    rd2.yz*=rot(t*0.5*pi/3.);\n    p.xy*=rot(t*0.5*pi/3.);\n    rd2.xy*=rot(t*0.5*pi/3.);\n    a = blocks(p,scl,rd2)+0.01;\n    \n   \n    a.x = max(box(p,vec3(scl*1.3)),a.x);\n    \n\n    return vec3(a,nsdf);\n}\nvec3 norm(vec3 p){\n    vec2 e = vec2(0.01,0.);\n    return normalize(map(p).x-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    float t = iTime;\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0,11.5,-20)*1.8;\n    if(iMouse.z>0.){\n    ro.yz*=rot(2.0*(iMouse.y/iResolution.y-0.5));\n    ro.zx*=rot(-7.0*(iMouse.x/iResolution.x-0.5));\n    }\n   // else ro.xz*=rot(t*0.3);\n    ro.xz*=rot(-pi/4.);\n    vec3 lk = vec3(0,0.,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = normalize(f*(0.99)+uv.x*r+uv.y*cross(f,r));    \n    rdg = rd;\n    vec3 p = ro;\n    float dO = 0.;\n    vec3 d = vec3(0);\n    bool hit = false;\n    for(float i = 0.; i<STEPS; i++){\n        p = ro+rd*dO;\n        d = map(p);\n        dO+=d.x*0.99;\n        if(abs(d.x)<0.0001||i==STEPS-1.){\n            hit = true;\n            break;\n        }\n        if(d.x>MDIST){\n            dO=MDIST;\n            break;\n        }\n    }\n    if(hit){\n        vec3 ld = normalize(vec3(0.5,0.9,-0.9));\n        vec3 n = norm(p);\n        vec3 r = reflect(rd,n);\n        vec3 e = vec3(0.5);\n        vec3 al = pal(fract(d.y+t*10.0/12.0)*0.6-0.2,e*1.5,e,e*2.0,vec3(0,0.33,0.66));\n        col = al;\n        \n        //lighting EQs from @blackle\n        float spec = length(sin(r*5.)*.5+.5)/sqrt(3.);\n        float fres = 1.-abs(dot(rd,n))*0.9;\n        \n        float diff = length(sin(n*2.)*.5+.7)/sqrt(3.);\n        \n        #define AO(a,n,p) smoothstep(-a,a,map(p+n*a).z)\n        float ao = AO(0.3,n,p)*AO(.5,n,p)*AO(.9,n,p);\n        col = al*diff+pow(spec,5.0)*fres*diff*vec3(1.000,0.878,0.792);\n        col*=pow(ao,0.4);\n        \n    }\n    //col = pow(col,vec3(0.99));\n    vec3 bg = mix(vec3(0.345,0.780,0.988),vec3(0.424,0.059,0.925),length(uv));\n    col = mix(col,bg,dO/MDIST);\n    fragColor = vec4(col,1.0);\n}\n/*\n#define AA 2.0\n#define ZERO min(0.0,iTime)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float px = 1.0/AA;\n    vec4 col = vec4(0);\n    \n    if(AA==1.0) {render(col,fragCoord); fragColor = col; return;}\n    \n    for(float i = ZERO; i <AA; i++){\n        for(float j = ZERO; j <AA; j++){\n            vec4 col2;\n            vec2 coord = vec2(fragCoord.x+px*i,fragCoord.y+px*j);\n            render(col2,coord);\n            col.rgb+=col2.rgb;\n            rdg = vec3(0);\n        }\n    }\n    col/=AA*AA;\n    fragColor = vec4(col);\n}\n*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsySWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[299, 312, 379, 379, 418], [419, 419, 439, 439, 510], [511, 511, 532, 532, 584], [585, 585, 611, 611, 670], [671, 684, 714, 714, 801], [803, 803, 833, 833, 936], [957, 1029, 1068, 1068, 3241], [3243, 3243, 3260, 3260, 3604], [3605, 3605, 3623, 3623, 3751], [3752, 3752, 3809, 3809, 5539]]}
{"id": "fsySWw", "name": "star flare", "author": "jcyuan", "description": "a basic material for complex proj", "tags": ["star", "flare", "material"], "likes": 7, "viewed": 101, "published": "Public", "date": "1634699993", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2. * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    float t = .001 + sin(iTime * 2.) * .0002;\n    float d = t / abs(uv.x * uv.y) * (1. - length(uv));\n    \n    fragColor = vec4(vec3(d), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsySWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 285]]}
{"id": "fsySzc", "name": "入门之路-4", "author": "jialouluo", "description": "用noise实现一个小案例", "tags": [], "likes": 1, "viewed": 108, "published": "Public API", "date": "1634989520", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 random(in vec2 _st ){\n    _st = vec2(\n            dot(_st,vec2(127.326,321.324)),\n            dot(_st,vec2(15.31,45.332))\n                    );\n    return 2.0*fract(sin(_st)*432.23) +1.0; //1.0 ~ 3.0\n}\nfloat noise(vec2 st){ //Gradient Noise\n    vec2 i = fract(st);//取小数\n    vec2 k = floor(st);//向负无穷取整\n    vec2 u = i*i*(3.0-2.0*i);//插值函数\n    return  mix(\n                    mix(dot(random(k + vec2(0.0,0.0)),i - vec2(0.0,0.0)),\n                        dot(random(k + vec2(0.0,1.0)),i - vec2(0.0,1.0)),\n                         u.y),\n                    mix(dot(random(k + vec2(1.0,0.0)),i - vec2(1.0,0.0)),\n                        dot(random(k + vec2(1.0,1.0)),i - vec2(1.0,1.0)),\n                         u.y),\n                       u.x\n                   );//二维noise\n}\n\nvec3 shape(vec2 st ,float r){\n    vec2 uv = st-vec2(0.5);\n    uv*=2.0;\n    float angle = atan(uv.y,uv.x);\n    float m = abs(mod(angle+iTime*2.,3.14*2.)-3.14)/3.6 ;\n    r += sin(angle*50.)*noise(uv+iTime*0.2)*.1 * (1.-step(0.5,iMouse.z));\n    r += (sin(angle*20.)*.1*pow(m,2.))* (1.-step(0.5,iMouse.z));\n    float c = 1.-smoothstep(r,r+0.007,dot(uv,uv));\n    vec3 color = 0.5 + 0.5*cos(6.28*(angle/6.28 +vec3(0.3,0.6,0.9)) );\n    return c*color;\n}\nvec3 createCircle(vec2 st,float radius,float width){\n    return shape(st,radius) - shape(st,radius-width);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//感觉以前似乎太啰嗦了反而效果不是那么美好，所以这次干脆就只留下代码吧。\n//试试点击图像看看会发生什么，这可能会帮助你理解这个效果是如何实现的（28,29行）\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3  color = createCircle(uv,0.5,0.07);\n    //color = vec3(noise(uv));//这里是使用noise算法之后结果的观察\n    \n\tfragColor = vec4(vec3(1.-color), 1.0 );\n}", "image_inputs": [{"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsySzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 207], [208, 208, 229, 246, 808], [810, 810, 839, 839, 1256], [1257, 1257, 1309, 1309, 1365], [1366, 1366, 1423, 1647, 1862]]}
{"id": "fsySzV", "name": "Swarm Thing 2", "author": "shyuriken", "description": "Swarm Thing 2", "tags": ["raymarching", "sdf", "ifs"], "likes": 4, "viewed": 58, "published": "Public", "date": "1634892846", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//!\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n\nfloat pBox(vec3 b, vec3 p) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nmat2 rot(float a) {\n\tfloat s = sin(a),\n\t      c = cos(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat hash(float x) { return fract(sin(x) * 43758.545) * 2. - 1.; }\nfloat rnd = 1.0;\nfloat sdf(vec3 p) {\n\tvec3 z = p;\n\tfloat sum = 1.5,\n\t      d = 1e5;\n\t     // rnd = 0.;\n\tfor (float i = 0.; i < 11.; i++) {\n\t\tfloat td = pBox(vec3(.5), z) / sum;\n\t\tz = abs(z) - vec3(1.2, 1.2, 0);\n\t\trnd = smoothstep(hash(rnd),1.5,2.0)*iTime*0.1;\n\t\td = min(td, d);\n\t\tz.xy *= rot(3.1415926 * .2 * rnd);\n\t\tz.yz *= rot(3.1415926 * .2 * rnd);\n        z.xz *= rot(3.1415926 * .2 * rnd);\n\t\tz *= 1.5;\n\t\tsum *= 1.5;\n\t}\n\n\treturn d;\n}\n\nvec3 calcNormal(vec3 pos) {\n\tconst vec2 e = vec2(1, -1) * 58e-5;\n\treturn normalize(e.xyy * sdf(pos + e.xyy) + e.yyx * sdf(pos + e.yyx) + e.yxy * sdf(pos + e.yxy) + e.xxx * sdf(pos + e.xxx));\n}\n\nfloat calcOcclusion(vec3 pos, vec3 nor) {\n\tfloat res = 0.;\n\tvec3 aopos = pos;\n\tfor (int i = 0; i < 4; i++) {\n\t\taopos = pos + nor * .2 * float(i);\n\t\tfloat d = sdf(aopos);\n\t\tres += d;\n\t}\n\n\treturn clamp(res, 0., 1.);\n}\n\nfloat castRay(vec3 ro, vec3 rd) {\n\tfloat t = 0.;\n\tfor (int i = 0; i < 100; i++) {\n\t\tvec3 pos = ro + t * rd;\n\t\tfloat h = sdf(pos);\n\t\tif (abs(h) < .001) break;\n\t\tt += h;\n\t\tif (t > 20.) break;\n\t}\n\n\tif (t > 20.) t = -1.;\n\treturn t;\n}\n\nvec3 env_color(vec3 dir) {\n\tif (dir.y > 0.) return mix(vec3(0, .5, 1), vec3(0, .1, .8), dir.y);\n\treturn mix(vec3(0, .5, 1), vec3(.8, .7, .6), pow(-dir.y, .5));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tvec2 p = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\tfloat t,\n\t      fi = 10. * iMouse.x / iResolution.x,\n\t      th = 10. * iMouse.y / iResolution.y;\n\tvec3 ro = vec3(5. * cos(fi) * sin(th), 5. * sin(th) * sin(fi), 5. * cos(th)),\n\t     ww = normalize(vec3(0) - ro),\n\t     uu = normalize(cross(ww, vec3(0, 1, 0))),\n\t     rd = normalize(p.x * uu + p.y * normalize(cross(uu, ww)) + 1.5 * ww),\n\t     col = vec3(.25, .72, .75) - .005 * rd.y;\n\tt = castRay(ro, rd);\n\tif (t > 0.) {\n\t\tcol = vec3(1);\n\t\tvec3 pos = ro + t * rd,\n\t\t     nor = calcNormal(pos);\n\t\tfloat occ = calcOcclusion(pos, nor);\n\t\tvec3 sun_dir = normalize(vec3(.8, .4, .2));\n\t\tfloat sun_sha = step(castRay(pos + nor * .001, sun_dir), 0.),\n\t\t      sun_dif = clamp(dot(nor, sun_dir), 0., 1.),\n\t\t      sky_dif = clamp(.5 + .5 * dot(nor, vec3(0, 1, 0)), 0., 1.),\n\t\t      bou_dif = clamp(.5 + .5 * dot(nor, vec3(0, -1, 0)), 0., 1.);\n\t\tcol = vec3(.18) * vec3(4) * sun_dif * sun_sha;\n\t\tcol += vec3(.18) * vec3(.5, .8, .9) * sky_dif * occ;\n\t\tcol += vec3(.18) * vec3(.7, .3, .2) * bou_dif * occ;\n\t}\n\telse col = env_color(rd);\n\n\tfragColor = vec4(pow(col, vec3(.4545)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsySzV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 100, 128, 128, 215], [217, 217, 236, 236, 303], [305, 305, 326, 326, 372], [390, 390, 409, 409, 810], [812, 812, 839, 839, 1004], [1006, 1006, 1047, 1047, 1221], [1223, 1223, 1256, 1256, 1452], [1454, 1454, 1480, 1480, 1615], [1617, 1617, 1669, 1669, 2799]]}
{"id": "fsyXWy", "name": "sunrise, sunset", "author": "droidkid", "description": "Trying out some exercises from the book of shaders.", "tags": ["bookofshaders"], "likes": 1, "viewed": 100, "published": "Public API", "date": "1635182732", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 background = vec3(0.2, 0.2, 0.2);\n    vec3 sunColor = vec3(0.996, 0.364, 0.160);\n    vec3 innerSun = vec3(1.00,0.65,0.00);\n    vec3 ground1 = vec3(0.301, 0.286, 0.274);\n    vec3 ground2 = vec3(0.552, 0.447, 0.270);\n\n    vec3 col;\n    if (uv.y > 0.3) {\n        vec2 sun_pos = vec2(0.5, sin(iTime) * 0.5 - 0.18);\n        float dist = distance(sun_pos, uv.xy);\n        vec3 rayCol = mix(sunColor, background, dist);\n        \n        vec3 innerSunCol = mix(innerSun, rayCol, smoothstep(0.0, 0.02, dist));\n        col = innerSunCol;\n\n    } else {\n        col = mix(ground1, ground2, uv.y / 0.2);\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsyXWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 741]]}
{"id": "ftc3Rn", "name": "Very nice function!", "author": "SnoopethDuckDuck", "description": "tanh(cos(x)) is very nice, please use it", "tags": ["e"], "likes": 4, "viewed": 120, "published": "Public API", "date": "1635549336", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// 1. / tanh(a*cos(0)) ensures it hits +-1.\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    \n    float t = thc(3.5, 0.8 * iTime);\n    \n    float r = 16. + 8. * t;\n    float ix = floor(r * uv.x) + 0.5;\n    uv.x = fract(r * uv.x) - 0.5;\n  \n    vec2 p = 0.2 * r * vec2(0., thc(2., 2. * iTime + 2. * ix));\n\n    float d = length(vec2(uv.x, r * uv.y) - p);\n    float s = step(d, (0.015 - 0.005 * t) * r);\n    \n    fragColor = vec4(s);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftc3Rn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 45, 74, 74, 115], [117, 117, 174, 174, 581]]}
{"id": "ftcGz8", "name": "[live] Inercia 2021 royale", "author": "w23", "description": "Coded live at Inercia 2021 shader royale compo. Continued coding after being wiped out 2nd, and this is what I ended up with.\nPoV VoD: https://www.youtube.com/watch?v=EZNpgjQnXVg", "tags": ["dof", "livecoding"], "likes": 14, "viewed": 222, "published": "Public API", "date": "1635654545", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float t;\n#define pi 3.1415927\n#define TT(t,v) texture(t, ((v)+.5)/vec2(textureSize(t,0)))\n//float fft(float f){return TT(texFFT,f).r;}\n//float ffts(float f){return TT(texFFTSmoothed,f).r;}\n//float ffti(float f){return TT(texFFTIntegrated,f).r;}\n\n//float fft(float f){return TT(iChannel0, vec2(f, t*32.)).r;}//TT(texFFT,f).r;}\nfloat ffts(float f){return .02 * pow(TT(iChannel0, vec2(f/1., t*10.)).r, 2.5);}//TT(texFFTSmoothed,f).r;}\n//float ffti(float f){return 0.;}//TT(texFFTIntegrated,f).r;}\n\n\n#define rep(v,s) (mod(v,s)-(s)*.5)\nfloat hash(float f){return fract(sin(f)*54353.42347);}\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nvec3 circ(vec2 uv, float h) {\n  float r=length(uv);\n  float a=atan(uv.x,uv.y);\n  a/=pi;a+=1.;\n  a+=2.;\n  float f = 4. * ffts(floor(a*(5. + 50. * hash(h))));\n  r -= f;\n  \n  float mask = step(abs(r-.3), .1);\n  float masz = .2 * hash(h+.1);\n  mask *= step(mod(a + sin(t+h*4.),.1+masz),.04+.1*masz);\n  \n  return mix(vec3(.1,.2,.3),vec3(.5,.2,.3),min(f*40., 3.)) * mask;\n}\n\nvec3 dots(vec2 p) {\n  //p = fract(p) - .5;\n  p = rep(p,vec2(.2));\n  return vec3(.1,.4,.6) * step(length(p), .01);\n}\n\nvec3 plane(float O, float D, float S, vec2 ouv, vec2 duv, float n) {\n  float l = (S - O) / D; if (l < 0.) return vec3(0.);\n  vec2 uv = ouv + duv * l;\n  \n  if (n == 1.)\n     uv.y += floor(t) + pow(fract(t), 2.);\n  \n  float xoffc = floor(uv.y);\n  float xoffp = t * (.2 - 1. * sin(2. * pi * hash(xoffc+.3))) + hash(xoffc);\n  //xoffp = \n  float xoff = floor(xoffp/2.)*2. + 2. * pow(fract(xoffp), 3.);\n  uv.x += xoff;\n  \n  vec2 pc = floor(uv);\n  vec2 p = fract(uv) - .5;\n  \n  vec3 c = vec3(0.);\n  \n  c += circ(p*1.5, hash(pc.x*.18+pc.y*34.)) * 4.;\n  \n  //c += vec3(.1, .2, .3) * step(length(p), .1);\n  c += dots(uv) * 4.;\n  \n  //c +\n  \n  return c / l;\n}\n\n\n/*void main(void) {\n\tvec2 uv = vec2(gl_FragCoord.x / v2Resolution.x, gl_FragCoord.y / v2Resolution.y);\n\tuv -= 0.5;\n\tuv /= vec2(v2Resolution.y / v2Resolution.x, 1);\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord/iResolution.xy - .5; uv.x *= iResolution.x/iResolution.y;\n  \n  vec3 C=vec3(0.);\n  \n  //t = iTime; fragColor.rgb = circ(uv, 1.); return;\n  \n  float seed = uv.x*45.43278 + uv.y*17.643 + iTime*3.4;\n\n  const float foc = 6.;\n  const float fov = 1./2.;\n  const float ls = .05;\n\n  const int NS = 16;\n  ///float tt = iTime;// * 130./120.;\n  for(int si = 0; si < NS; ++si) {\n    seed = fract(seed);\n    vec3 O,D;\n\n    t = iTime - hash(seed+=.01) * iTimeDelta;\n    vec2 dp = vec2(hash(seed+=.1), hash(seed+=.2));\n    \n    vec3 at = vec3(uv, fov) * foc;\n    O = vec3(dp * ls, 0.);\n    D = normalize(at - O);\n    \n    vec3 S=vec3(1., 1.1, 10.), DS=vec3(2.);\n    //O += vec3(.1 + .4*sin(t*.17 + ffti(.3)*.1), .4, 5.);\n    \n    float tp = t / 2.;\n    float tc = floor(tp);\n    float tct = /*1. -*/ pow(fract(tp), 1.);\n    \n    vec3 o0 = S * .9 * (1. - 2. * vec3(hash(tc   ),hash(tc+ .1),hash(tc+ .2)));\n    vec3 o1 = S * .9 * (1. - 2. * vec3(hash(tc+1.),hash(tc+1.1),hash(tc+1.2)));\n\n    O += mix(o0, o1, tct);\n    \n    D.xz *= rot(-.3 + .2 * (1. - 2. * mix(hash(tc+.3), hash(tc+1.3), tp)));\n    D.yz *= rot(-.2 + .3 * (1. - 2. * mix(hash(tc+.5), hash(tc+1.5), tp)));\n    D.xy *= rot(-.1 + .4 * (1. - 2. * mix(hash(tc+.6), hash(tc+1.6), tp)));\n    D = normalize(D);\n    //D.yz *= rot(-.2);\n\n\n    S *= sign(D);\n    DS *= sign(D);\n    \n    //C += circ(uv);\n    for (float ip = 0.; ip < 2.; ++ip, S+=DS) {\n      C += plane(O.y, D.y, S.y, O.xz, D.xz, 0.);\n      C += plane(O.x, D.x, S.x, O.yz, D.yz, 1.);\n      C += plane(O.z, D.z, S.z, O.xy, D.xy, 2.);\n    }\n  }\n  \n  C /= float(NS);\n  \n\t//out_color = vec4(sqrt(C), 0.);\n    fragColor = vec4(sqrt(C), 0.);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftcGz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[246, 326, 346, 346, 405], [405, 531, 551, 551, 585], [586, 586, 604, 604, 647], [649, 649, 678, 678, 1016], [1018, 1018, 1037, 1060, 1133], [1135, 1135, 1203, 1203, 1783], [1786, 1953, 2010, 2010, 3673]]}
{"id": "ftcGzr", "name": "Sperm", "author": "SnoopethDuckDuck", "description": "i shouldn't have made this (looks quite cool if you increase \"num\")", "tags": ["e"], "likes": 8, "viewed": 158, "published": "Public API", "date": "1635561768", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.14159\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    uv.y += 0.02 * cos(12. * uv.x + 8. * iTime);\n    const float num = 30.;\n    \n    float s = 0.;\n    for (float i=0.;i<num;i++) {\n        vec2 p = (0.2 + 0.6 * tanh(3. * cos(0.8 * iTime))) * vec2(tanh(1. *cos(0.5 * pi * tanh(1.5 * cos(iTime + 23. * i/num * pi)) + 1. - 0.5 * i/num * pi)), \n                            0.3 * cos(iTime + 11. * i/num * pi));\n        float d = length(uv - p);\n        s = max(s, step(d, 0.015 + 0.008 * sin(iTime + i/num * pi)));\n        \n        float y = uv.y + 0.01 * cos(50. * uv.x + iTime);\n        //float x = uv.x + .1 * cos(100. * uv.y + iTime);\n        s += smoothstep(-0.05, 0.1, uv.x - (p.x - 0.15 * (i+5.)/num)) * step(uv.x, p.x) * step(abs(y-p.y),0.001);\n    }\n   vec3 col = vec3(s);\n    \n    \n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftcGzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 77, 127, 1050]]}
{"id": "Nd3SRS", "name": "Fork Fractal v2", "author": "spenceryonce", "description": "super crazy fractal", "tags": ["3d", "fractal", "rainbow", "trippy", "surreal"], "likes": 3, "viewed": 92, "published": "Public", "date": "1633394170", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.5+vec3(0,23,21))*.5+.5)\n\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));\n    float i=0.,g=0.,e,s,h,a;\n    for(;++i<99.;)\n    {\n        p=g*d;\n        p.z+=iTime*0.5;\n        p=sin(p);\n        p=R(p,vec3(.577),iTime*.577);\n        p=abs(p)-.2;//-.2 is nice, \n        p=p.x<p.y?p.zxy:p.zyx;\n        p=p.x<p.y?p.zxy:p.zyx;\n        s=2.;\n        for(int i=0;i++<8;){\n          s*=e=2./clamp(dot(p,p),.3,1.2);\n          p=abs(p)*e-vec3(0.95,.01,4);\n        }\n        a=1.;\n        p-=clamp(p,-a,a);\n        g+=e=length(p)/s;\n        O.rgb+=(H(s*.01)+.5)*.01*exp(-.4*i*i*e);\n    }\n    O=pow(O,vec4(4));\n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd3SRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 107, 143, 143, 753]]}
{"id": "Nd3XDj", "name": "PetalRocks", "author": "rudros", "description": "Very small but (hopefully) readable ray-caster", "tags": ["raycasting", "mini"], "likes": 1, "viewed": 59, "published": "Public", "date": "1633931129", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415326\n\nmat2 rotate2D(float r) {\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\n// Distance of point p to wave #waveNum\nfloat distanceTo(vec3 p, float waveNum) {\n    float frequency = exp(waveNum);\n    return p.y+(abs(cos(p.x*frequency*PI))+sin(p.z*frequency*PI))/frequency;\n}\n\nfloat minimumDist(vec3 p) {\n    float minDist = 1000.;\n    // This loop determines the number of waves being vizualized\n    for(float j=0.; j<mod(iTime, 15.); j++) {\n        float curDist = distanceTo(p, j);\n        minDist = min(minDist, curDist);\n    }\n    return minDist;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float i;\n    float eyeDist, minDist;\n    \n    vec3 eyePos = vec3(0, 0, -1);\n    vec3 ray = vec3((fragCoord.xy-.5*iResolution.xy)/iResolution.x, 1.);\n    ray = normalize(ray);\n\n    // Camera motion\n    eyePos.yz *= rotate2D(5.);\n    eyePos.xz *= rotate2D(iTime);\n    ray.yz *= rotate2D(5.);\n    ray.xz *= rotate2D(iTime);\n\n    for(minDist = 1.; i<100. && minDist>0.001; i++) {\n        // Point to check\n        vec3 p = eyePos+eyeDist*ray;\n         \n        minDist = minimumDist(p);\n        // Move point forward\n        eyeDist += minDist*.25;\n    }\n    i += 2.*(minDist*1000.+eyePos.z);\n    fragColor = vec4(1.-i/100.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd3XDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 46, 46, 98], [100, 140, 181, 181, 296], [298, 298, 325, 325, 574], [576, 576, 631, 631, 1259]]}
{"id": "NdcXDf", "name": "My Square Rotation", "author": "Falco524", "description": "Square Rotation", "tags": ["test"], "likes": 0, "viewed": 23, "published": "Public", "date": "1634044802", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rotation(vec2 uv, float th)\n    {\n        return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;\n    }\n    \n\nbool isInSquare(vec2 center, vec3 position, float size)\n{\n    return max(abs(center.x - position.x),abs(center.y - position.y))<size;\n}\n\n/*vec3 drawSquare(vec2 center, vec3 position, float size, vec3 col)\n{\n        return col = vec3(1,1,1);\n}*/\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(uv.xyx+vec3(0,2,4));\n    \n    vec2 center = vec2(0.9,0.5);\n    \n    uv = rotation(uv.xy,iTime)*0.1;\n    \n     if(isInSquare(rotation(center,iTime)*0.1, vec3(uv.xy,0.0), 0.01))\n     {\n        \n        col = vec3(1,1,1);\n     }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdcXDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 107], [114, 114, 171, 171, 249], [251, 361, 418, 469, 854]]}
{"id": "NdcXDS", "name": "concrete tunnel", "author": "yasuo", "description": "concrete tunnel", "tags": ["concrete"], "likes": 10, "viewed": 185, "published": "Public API", "date": "1633797838", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define MAX_STEPS 80\n#define MAX_DIST 32.\n#define SURF_DIST .001\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define MATERIAL0 0\n#define SPEED 2.0\n#define ZERO (min(iFrame,0))\n\nfloat B3D(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return max(max(p.x,p.y),p.z);\n}\n\n// https://iquilezles.org/www/articles/fbmsdf/fbmsdf.htm\n// https://www.shadertoy.com/view/3dGSWR\nfloat sph( vec3 i, vec3 f, vec3 c )\n{\n    // random radius at grid vertex i+c (please replace this hash by\n    // something better if you plan to use this for a real application)\n    vec3  p = 17.0*fract( (i+c)*0.3183099+vec3(0.11,0.17,0.13) );\n    float w = fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n    float r = 0.8*w*w;\n    // distance to sphere at grid vertex i+c\n    return B3D((f-c),vec3(r));\n}\n\n// https://iquilezles.org/www/articles/fbmsdf/fbmsdf.htm\nfloat sdBase( in vec3 p)\n{\n    float t = iTime*0.5;\n    p.y-=t;\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    return min(min(min(sph(i,f,vec3(0,0,0)),\n                       sph(i,f,vec3(0,0,1))),\n                   min(sph(i,f,vec3(0,1,0)),\n                       sph(i,f,vec3(0,1,1)))),\n               min(min(sph(i,f,vec3(1,0,0)),\n                       sph(i,f,vec3(1,0,1))),\n                   min(sph(i,f,vec3(1,1,0)),\n                       sph(i,f,vec3(1,1,1)))));\n}\n\nvec3 path(float z)\n{\n    vec3 p = vec3(sin(z) * .6, cos(z * .5), z);\n    return p;\n}\n\nvec2 GetDist(vec3 p) {\n    vec3 prevP = p;\n    \n    p.xy -= path(p.z).xy;\n    \n    p.z += iTime*SPEED;\n    \n    float d = -length(p.xy) + 1.5;\n    \n    float d2 = sdBase(p);\n    \n    return vec2(max(-d2,d),MATERIAL0);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n\n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n                \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<4; i++ )\n    {\n        float h = 0.01 + 0.15*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    float occ = calcOcclusion(p,n);\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(p.x,p.y,-2));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(-0.5)*diff*occ;\n    diffCol += col*vec3(0.9)*skyDiff*occ;\n    diffCol += col*vec3(0.7)*bounceDiff*occ;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 20.)*occ; // spec\n        \n    return diffCol;\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    if(mat == MATERIAL0){\n        col = diffuseMaterial(n,rd,p,vec3(1.0));\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    float t = iTime*SPEED;\n    vec3 ro = path(t+1.5);\n \n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(1.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n        col *= exp( -0.0001*d.x*d.x*d.x*d.x );//fog\n    } else {\n        col = vec3(0.0);   \n    }\n    \n    // gamma correction\n    col = pow( col, vec3(0.9545) );    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdcXDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 247, 274, 274, 328], [330, 428, 465, 606, 823], [825, 882, 908, 908, 1360], [1362, 1362, 1382, 1382, 1446], [1448, 1448, 1470, 1470, 1667], [1669, 1669, 1727, 1727, 1998], [2000, 2000, 2024, 2024, 2225], [2227, 2227, 2269, 2269, 2464], [2466, 2507, 2556, 2556, 2847], [2849, 2849, 2906, 2906, 3439], [3441, 3441, 3500, 3500, 3599], [3601, 3601, 3658, 3658, 4260]]}
{"id": "NdcXzf", "name": "Fork InOut haleyhalcy 400", "author": "HaleyHalcyon", "description": "aa", "tags": ["a"], "likes": 2, "viewed": 44, "published": "Public", "date": "1633598511", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU (6.283185307)\n#define HEX(x) (vec3((x >> 16) & 255, (x >> 8) & 255, x & 255) / 255.)\n#define STRIPECOUNT 10.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float time = fract(iTime / 4.);\n  // Normalized pixel coordinates (from 0 to 1)\n  float scale = min(iResolution.x, iResolution.y);\n  vec2 uv = (gl_FragCoord.xy - 0.50 * iResolution.xy) / scale;\n  \n  float dist = length(uv);\n  float angle = atan(uv.y, uv.x);\n  // for calculating the parity of the stripe\n  float dark = floor(mod(angle * STRIPECOUNT / TAU - 2. * time, 2.));\n  // for calculating the stripes’ angle\n  float stripeAngle = ((dark - 0.5) * time * TAU) + (0.5 + floor(angle * STRIPECOUNT / TAU - 2. * time) + 2. * time) * TAU / STRIPECOUNT;\n  vec2 angleVec = vec2(cos(stripeAngle), sin(stripeAngle));\n  // for calculating which palette to use\n  float palette = step(fract(\n      log(dist + 0.01) + angle / TAU + time * 2.\n  ), 0.5);\n  \n  const vec3 col0L = HEX(0x840DaE);\n  const vec3 col1L = HEX(0x3BCEAC);\n  const vec3 col2L = HEX(0xFFD23F);\n  const vec3 col3L = HEX(0xEE4266);\n  \n  const vec3 col0D = HEX(0x118AB2);\n  const vec3 col1D = HEX(0xEF476F);\n  const vec3 col2D = HEX(0xFFD166);\n  const vec3 col3D = HEX(0x06D6A0);\n  \n  vec3 col0 = mix(col0L, col0D, palette);\n  vec3 col1 = mix(col1L, col1D, palette);\n  vec3 col2 = mix(col2L, col2D, palette);\n  vec3 col3 = mix(col3L, col3D, palette);\n  \n  float spiral = fract(\n      0.7 * log(\n          abs(\n              dot(uv, angleVec)\n          ) + 0.02\n      ) + (\n          8. * dark * time\n      ) + (\n          -11. * (1. - dark) * time\n      ) + (\n          dark * 0.2\n      )\n  );\n  \n  vec3 col = mix(\n      mix(\n          col0, col1, step(spiral, 0.75)\n      ), mix(\n          col2, col3, step(spiral, 0.25)\n      ), step(spiral, 0.5)\n  );\n  // Output to screen\n  fragColor = vec4(\n    col, 1.0\n  );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdcXzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[122, 122, 179, 179, 1857]]}
{"id": "NddSWB", "name": "Islands, mountain and sea", "author": "Viko", "description": "Islands, mountain and sea landscapes with SDF.\n/!\\ WORK IN PROGRESS /!\\", "tags": ["sdf", "implicitsurface"], "likes": 4, "viewed": 49, "published": "Public", "date": "1634072874", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Common\n#define PI 3.1415926538\n\n// Hashing function\n// Returns a random number in [-1,1]\nfloat Hash(float seed)\n{\n  return fract(sin(seed)*43758.5453);\n}\n\n// Cosine direction\nvec3 Cosine(in float seed,in vec3 nor)\n{\n  float u=Hash(78.233+seed);\n  float v=Hash(10.873+seed);\n  \n  // method 3 by fizzer: http://www.amietia.com/lambertnotangent.html\n  float a=6.2831853*v;\n  u=2.*u-1.;\n  return normalize(nor+vec3(sqrt(1.-u*u)*vec2(cos(a),sin(a)),u));\n}\n\n// Rotation matrix around z axis\n// a : Angle\nmat3 rotate_z(float a)\n{\n  float sa=sin(a);float ca=cos(a);\n  return mat3(ca,sa,0.,-sa,ca,0.,0.,0.,1.);\n}\n\n// Compute the ray\n// m : Mouse position\n// p : Pixel\n// ro, rd : Ray origin and direction\nvoid Ray(in vec2 m,in vec2 p,out vec3 ro,out vec3 rd)\n{\n  float a=3.*3.14*m.x;\n  float le=3.8;\n  \n  ro=vec3(20.,0.,5.);\n  ro*=rotate_z(3.*3.14*m.x);\n  \n  vec3 ta=vec3(0.,0.,1.);\n  vec3 ww=normalize(ta-ro);\n  vec3 uu=normalize(cross(ww,vec3(0.,0.,1.)));\n  vec3 vv=normalize(cross(uu,ww));\n  rd=normalize(p.x*uu+p.y*vv+le*ww);\n}\n\n// Main\n\nconst int Steps=1000;\nconst float Epsilon=.05;// Marching epsilon\nconst float T=.5;\n\nconst float rA=10.;// Maximum and minimum ray marching or sphere tracing distance from origin\nconst float rB=40.;\n\n// Transforms\nvec3 translateX(vec3 p, float t)\n{\n    return vec3(p.x + t, p.y,p.z);\n}\nvec3 translateY(vec3 p, float t)\n{\n    return vec3(p.x, p.y + t,p.z);\n}\nvec3 translateZ(vec3 p, float t)\n{\n    return vec3(p.x, p.y,p.z + t);\n}\n\nvec3 rotateX(vec3 p,float a)\n{\n  float sa=sin(a);\n  float ca=cos(a);\n  return vec3(p.x,ca*p.y-sa*p.z,sa*p.y+ca*p.z);\n}\n\nvec3 rotateY(vec3 p,float a)\n{\n  float sa=sin(a);\n  float ca=cos(a);\n  return vec3(ca*p.x+sa*p.z,p.y,-sa*p.x+ca*p.z);\n}\n\nvec3 rotateZ(vec3 p,float a)\n{\n  float sa=sin(a);\n  float ca=cos(a);\n  return vec3(ca*p.x+sa*p.y,-sa*p.x+ca*p.y,p.z);\n}\n\nvec3 scaleX(vec3 p, float s)\n{\n    return vec3(p.x*s,p.y,p.z);\n}\nvec3 scaleY(vec3 p, float s)\n{\n    return vec3(p.x,p.y*s,p.z);\n}\nvec3 scaleZ(vec3 p, float s)\n{\n    return vec3(p.x,p.y,p.z*s);\n}\nvec3 scaleUniform(vec3 p, float s)\n{\n    return vec3(p.x*s,p.y*s,p.z*s);\n}\n\n// Primitives\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : radius\nfloat point(vec3 p,vec3 c,float r)\n{\n  return length(p-c) - r;\n}\nvec4 pointColor(vec3 p, vec3 c, float r, vec3 color)\n{\n  float x = point(p, c, r);\n  return vec4(x, color);\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  return dot(p,n) + h;\n}\nvec4 colorPlane( vec3 p, vec3 n, float h, vec3 color)\n{\n    return vec4(sdPlane(p,n,h), color);\n}\n\n// Segment\nfloat segment(vec3 p, vec3 a, vec3 b, float e, float R)\n{\n  if (dot(b-a, p-a) < 0.0)\n  {\n    return dot(p-a, p-a);\n  }\n  else if (dot(b-a, p-b) > 0.0)\n  {\n    return dot(p-b, p-b);\n  }\n  else \n  {\n    vec3 u = (b-a)/length(b-a);\n    float sqLengthAP = dot(p-a, p-a);\n    return sqLengthAP - dot(dot((p-a), u), dot((p-a), u));\n  }\n}\n\nvec4 segmentColor(vec3 p, vec3 a, vec3 b, vec3 color, float e, float R)\n{\n  float x = segment(p, a, b, e, R);\n  return vec4(x, color);\n}\n\n// Circle\nfloat circle(vec3 p, vec3 c, float r, float e, float R)\n{\n  vec3 n = p -c;\n  vec3 u = vec3(1.0, 0.0, 0.0);\n  float h = dot(n, u);\n  float d = dot(n, n);\n  float y = d - h * h;\n  y = r - sqrt(y);\n\n  return (sqrt(y*y + h*h));\n}\nvec4 circleColor(vec3 p, vec3 c, float r, vec3 color, float e, float R)\n{\n  float x = circle(p, c, r, e, R);\n  return vec4(x, color);\n}\n\n// Disk\nfloat disk(vec3 p, vec3 c, float r)\n{\n  vec3 n = p -c;\n  vec3 u = vec3(1.0, 0.0, 0.0);\n  float h = dot(n, u);\n  float d = dot(n, n);\n  float y = d - h * h;\n\n  if (y < r*r)\n    return (abs(h));\n    \n  y = r - sqrt(y);\n  return (sqrt(y*y + h*h));\n}\nvec4 diskColor(vec3 p, vec3 c, float r, vec3 color)\n{\n  float x = disk(p,c,r);\n  return vec4(x, color);\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nvec4 colorTorus( vec3 p, vec2 t, vec3 color )\n{\n  return vec4(sdTorus(p,t), color);\n}\n\nvec4 sdRoundBox( vec3 p, vec3 b, float r, vec3 color)\n{\n  vec3 q = abs(p) - b;\n  return vec4(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r, color);\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\nvec4 colorRoundedCylinder(vec3 p, float ra, float rb, float h, vec3 color)\n{\n    return vec4(sdRoundedCylinder(p,ra,rb,h),color);\n}\n\n// Operators\n\n// Blending\n// a,b : field function of the sub-trees\nfloat Blend(float a,float b)\n{\n  return a+b;\n}\n\nvec4 BlendColor(vec4 a, vec4 b, float k)\n{\n  float h = clamp( 0.5 + 0.5*(b.x-a.x)/k, 0.0, 1.0 );\n  float value = mix( b.x, a.x, h ) - k*h*(1.0-h);\n  vec3 color = (a.yzw * b.x + b.yzw * a.x) / (a.x + b.x);\n  return vec4(value, color);\n}\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Union(float a,float b)\n{\n  return min(a,b);\n}\nvec4 UnionColor(vec4 a, vec4 b)\n{\n  if (a.x < b.x)\n    return a;\n  return b;\n}\n\nfloat Intersection(float a, float b)\n{\n  return max(a,b);\n}\n\nfloat Difference(float a, float b)\n{\n  return max(a,-b);\n}\n\nfloat BlendMinus(float a, float b)\n{\n  return a - b;\n}\nvec4 BlendMinusColor(vec4 a, vec4 b)\n{\n  return vec4(a.x - b.x, a.yzw);\n}\n\n/*float pillar (vec3 p)\n{\n  float v;\n  v = box(p, vec3(-1.,-1.,-3.), vec3(1., 1., 1.), 1.0, 1.0);\n  v = BlendMinus(v, segment(p, vec3(-1.,-1.,-1.5), vec3(-1.,-1.,2.), 0.7, .7));\n  v = BlendMinus(v, segment(p, vec3(1.,1.,-1.5), vec3(1.,1.,2.), 0.7, .7));\n  v = BlendMinus(v, segment(p, vec3(-1.,1.,-1.5), vec3(-1.,1.,2.), 0.7, .7));\n  v = BlendMinus(v, segment(p, vec3(1.,-1.,-1.5), vec3(1.,-1.,2.), 0.7, .7));\n  v = Blend(v, circle(rotateY(p, PI/2.), vec3(-3.,0.,0.), 1.7, 2.0, 1.0));\n\n  return v;\n}*/\nvec4 pillar2(vec3 p)\n{\n  vec4 v;\n\n  vec3 q = p;\n\n  //v = boxColor(p, vec3(-1.,-1.,-3.), vec3(1., 1., 3.), vec3(0.7,0.7,0.7), 1.0, 1.0);\n  //v = BlendColor(v, boxColor(p, vec3(-1.5,-1.5,2.), vec3(1.5, 1.5, 3.), vec3(0.5,0.5,0.5), 1.0, 1.0));\n  //v = BlendColor(v, circleColor(rotateY(p, PI/2.), vec3(-3.,0.,0.), 1.7, vec3(0.4,0.4,0.4), 2.0, 1.0));\n\n\n  return v;\n}\nvec4 bridge(vec3 p)\n{\n  vec4 v;\n  \n  //v = boxColor(p, vec3(-25.,-3.5,-4.), vec3(25., 3.5, -4.), vec3(0.8,0.8,0.8), 1.0, 2.0);\n  //v = BlendColor(v, segmentColor(p - vec3(0.0, 4, -5.0), vec3(-26., 0., 0.), vec3(26.0, 0.0, 0.0), vec3(0.5,0.0,1.), 1., 2.));\n  //v = BlendColor(v, segmentColor(p - vec3(0.0, -4, -5.0), vec3(-26., 0., 0.), vec3(26.0, 0.0, 0.0), vec3(0.5,0.0,1.), 1., 2.));\n\n  return v;\n}\n\n/*float car(vec3 p)\n{\n  float v;\n\n  // Wheels\n  v = disk(p, vec3(0., 0., 0.), 1., 1., 1.);\n  //v = Union(v, disk(p - vec3(3., 0., 0.), vec3(0., 0., 0.), 1., 1., 1.));\n  v = Union(v, disk(p - vec3(0., -6., 0.), vec3(0., 0., 0.), 1., 1., 1.));\n  //v = Union(v, disk(p - vec3(3., -6., 0.), vec3(0., 0., 0.), 1., 1., 1.));\n\n  // Body\n  v = Union(v, box(p - vec3(1.5, 0., -2.), vec3(-2., -10., 0.), vec3(2., 3., 1.), 1., 1.));\n\n  return v;\n}*/\n\n// Potential field of the object\n// p : point\n/*float Object(vec3 p)\n{\n  p.z=-p.z;\n  float v;\n  //float v=Blend(point(p,vec3(0.,1.,1.),1.,2.5),\n  //point(p,vec3(2.,0.,-3.),1.,4.5));\n  //float v = point(p, vec3(0.,0.,0.), 1., 2.5);\n  //v = Difference(v, point(p, vec3(0.5, .5, 3.), 1., 4.5));\n  //v=Intersection(v, point(p, vec3(0., 1., 1.), 1., 6.5));\n  \n  //v=Blend(v,point(p,vec3(-2.,2.,-3.),1.,4.5));\n  //v=Union(v,point(p,vec3(-1.,-1.,0.),1.,4.5));\n\n  //v = Blend(v,segment(p, vec3(0.,-0.,-0.), vec3(30.,0.,0.), 1., 5.));\n  //v = circle(p, vec3(0.,0.,0.), 3.0, 2.0, 1.0);\n  //v = disk(p, vec3(0., 0., 0.), 4.0, 3.0, 2.0);\n  vec3 scale = vec3(4.,4.,4.);\n  // Pillars\n  v = pillar2(p * scale);\n  //v = Union(v, pillar2((p - vec3(-5.0, 0.0, 0.0)) * scale));\n  //v = Union(v, pillar2((p - vec3(5.0, 0.0, 0.0)) * scale));\n  // Bridge\n  //v = Blend(v, bridge(p * scale));\n\n  // Car\n  //v = car(p * scale);\n\n  // Bridge\n  return v-T;\n}*/\n\n// 2D Random\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n// https://www.shadertoy.com/view/4sfGzS\nfloat hash(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n    vec2 u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n// Optional value t : time for animation\nfloat fbm (in vec2 st, float amplitude, int octaves, float t) {\n    // Initial values\n    float value = 0.0;\n    \n    // Loop of octaves\n    for (int i = 0; i < octaves; i++) {\n        value += amplitude * noise(st+t);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\nvec4 ObjectColored(vec3 p)\n{\n  p.z = -p.z;\n\n  vec3 scale = vec3(4.,4.,4.);\n\n  vec4 v;\n  // Pillars\n  vec4 pillars = pillar2(p * scale);\n  pillars = UnionColor(pillars, pillar2((p - vec3(-5.0, 0.0, 0.0)) * scale));\n  pillars = UnionColor(pillars, pillar2((p - vec3(5.0, 0.0, 0.0)) * scale));\n  // Bridge\n  //float a = iTime;\n  //vec4 bridge = BlendColor(pillars, bridge((p * scale)/* - vec3(a, 0., 0.))*/));\n\n  // Noise\n  float n = noise(vec2(p.x * sin(iTime * 0.1), p.y * cos(iTime * 0.1)));\n  float nx = noise(vec2(p.x, p.y * cos(iTime * 0.1)));\n  float n_rock = noise(vec2(p.y, p.x));\n\n  // Ground\n  //vec4 ground = boxColor(p, vec3(-15.,-15.,1.5), vec3(15., 15., 2.), vec3(0.,1.,0.3), 1.0, 1.0);\n  //vec4 ground = boxColor(p, vec3(-15.,-15.,1.5), vec3(15., 15., 2.), vec3(0.,1.,0.3), 1.0, 1.0);\n//   vec4 hills = pointColor(p, vec3(-7., -7., 3.), vec3(0.,1.,0.4), 1., 10.);\n//   hills = BlendColor(hills, pointColor(p, vec3(1., -7., 2.), vec3(0.,1.,0.4), 2., 7.));\n//   hills = BlendColor(hills, pointColor(p, vec3(1., -7., -1.), vec3(0.,1.,0.4), 2., 3.));\n//   ground = UnionColor(ground, hills);\n\n  // Sea\n  //vec4 sea = boxColor(p - n_sea_static, vec3(-15.,-15.,1.5), vec3(15., 15., 2.), vec3(0.,0.7,0.8), 1.0, 1.0);\n  // Rocks\n//   vec4 rocks = pointColor(p - n_rock, vec3(-7., 7., 3.), vec3(0.8,0.8,0.8), 1., 10.);\n//   rocks = BlendColor(rocks, pointColor(p - n_rock - n_rock, vec3(-2., 7., -1.), vec3(0.8,0.8,0.8), 1., 10.));\n\n  //sea = UnionColor(sea, rocks);\n\n  // Mountain\n  //vec4 mountain = pointColor(p - n_mountain, vec3(-7., 7., 3.), vec3(0.8,0.8,0.8), 1., 10.);\n  //vec4 mountain = boxColor(p - n_mountain, vec3(-3.,-4.,-2.), vec3(3., 4., 0.), vec3(0.8,0.8,0.8), 1.0, 1.0);\n  //mountain = BlendColor(mountain, boxColor((p - vec3(3.,0.,0.)) - n_mountain, vec3(-2.,-2.,-2.), vec3(2., 2., 0.), vec3(0.,0.8,0.8), 1.0, 1.0));\n  \n  // Tree\n  //vec4 trunk = segmentColor(p * vec3(2.,2.,2.) - vec3(0.,0.,10.), vec3(0.,0.,-10.), vec3(0.,0.,0.), vec3(0.5451, 0.2705, 0.0745), 1.0, 1.0);\n  //vec4 leafs = pointColor(p - vec3(0.,0.,-0.4) - Hash(p.x), vec3(0.,0.,0.), vec3(0.,1.,0.), 2., 2.);\n  //leafs = BlendColor(leafs, pointColor(p - vec3(0.,1.,1.) * Hash(p.x), vec3(0.,0.,0.), vec3(0.,1.,0.), 2., 2.));\n  //leafs = BlendColor(leafs, pointColor(p - vec3(0.,-1.,1.) * Hash(p.x), vec3(0.,0.,0.), vec3(0.,1.,0.), 2., 1.7));\n  //leafs = BlendColor(leafs, pointColor(p - vec3(1.,0.,1.2) * Hash(p.x), vec3(0.,0.,0.), vec3(0.,1.,0.), 2., 2.5));\n  //leafs = BlendColor(leafs, pointColor(p - vec3(-1.,0.,1.4) * Hash(p.x), vec3(0.,0.,0.), vec3(0.,1.,0.), 1.8, 2.));\n  //vec4 tree = UnionColor(trunk, leafs);\n  //ground = tree;\n\n  // House\n  //vec4 house = boxColor(p * scale, vec3(-3.5, -6., -10.), vec3(3.5, 6., 0.), vec3(1.,0.,0.), 1., .5);\n  //house = BlendColor(house, cylinderColor((p - vec3(0., 1.5, -3.2)) * vec3(.6, 0.5, 1.3), vec3(1.,0.,0.)));\n  //house = BlendColor(house, cylinderColor((p - vec3(0., -1.5, -3.2)) * vec3(.6, 0.5, 1.3), vec3(1.,0.,0.)));\n  // House : roof\n  vec3 transform1 = rotateX((p - vec3(0.,1.5,-4.3)),PI/2.) * vec3(1.1, 1.1, 1.1);\n  vec3 transform2 = rotateX((p - vec3(0.,-1.5,-4.3)),PI/2.) * vec3(1.1, 1.1, 1.1);\n  vec3 transform3 = rotateX((p - vec3(0.,0.,-4)),PI/2.) * vec3(1.5, 1.5, 1.1);\n  //vec4 cone1 = coneColor(transform1, vec2(sin(PI/5.), cos(PI/10.)), 2., vec3(0.,1.,0.), 1., 0.7);\n  //vec4 cone2 = coneColor(transform2, vec2(sin(PI/5.), cos(PI/10.)), 2., vec3(0.,1.,0.), 1., 0.7);\n  //vec4 cone3 = coneColor(transform3, vec2(sin(PI/5.), cos(PI/10.)), 2., vec3(0.,1.,0.), 1., 0.7);\n  //vec4 roof = BlendColor(cone1, cone2);\n  //roof = BlendColor(roof, cone3);\n  //house = UnionColor(house, roof);\n  // Windows\n  //vec4 window = diskColor(p, vec3(0.,0.,0.), 2., vec3(1.,0.,0.), 1., 1.);\n  //v = window;\n\n  // Door\n  vec3 translate = vec3(3., 0., 0.);\n  //vec4 door = boxColor(p * scale - translate, vec3(-1., -1., -3.), vec3(1., 1., 0.), vec3(1.,1.,0.), 1., .3);\n  vec3 trHandle1 = (p * scale * 1.5) - vec3(6.8,0.5,-2.);\n  vec3 trHandle2 = (p * scale * 1.5) - vec3(6.8,-0.5,-2.);\n//   vec4 handle1 = pointColor(trHandle1, vec3(0.,0.,0.), vec3(1.,0.,1.), 1., 1.);\n//   vec4 handle2 = pointColor(trHandle2, vec3(0.,0.,0.), vec3(1.,0.,1.), 1., 1.);\n//   handle1 = BlendColor(handle1, handle2);\n//   door = UnionColor(door, handle1);\n  \n  //house = BlendColor(house, door);\n  \n  //v = UnionColor(mountain, sea);\n  //v = UnionColor(v, ground);\n  //v = UnionColor(v, bridge);\n  //v = UnionColor(v, house);\n\n\n  // ==== Scene Objects ==== //\n\n  // Sea\n\n  // Beach\n  //vec4 beach = boxColor(p - vec3(12.,0.,0.), vec3(-10.,-15.,1.5), vec3(10., 15., 2.), vec3(1.,1.,0.7), 1.0, 1.0);\n  vec3 transform = (rotateY(p, PI/2.) - vec3(.9,0.,0.)) * vec3(2.,2.,2.);\n  //vec4 beach = diskColor(transform, vec3(0.,0.,0.), 12., vec3(1.,1.,0.7), 1., 0.7);\n  \n  // Grass\n  //vec4 grass = boxColor(p - vec3(25.,0.,-0.4), vec3(-15.,-15.,1.5), vec3(15., 15., 2.), vec3(0.,1.,0.3), 1.0, 1.0);\n  //vec4 grass = diskColor(transform - vec3(-0.5,0.,0.), vec3(0.,0.,0.), 10., vec3(0.,1.,0.3), 0.7, 0.7);\n\n  // Mountain\n  //vec4 mountain = boxColor((p - n_mountain) - vec3(2.,0.,0.),\n        //vec3(-1.,-2.,-2.), vec3(3., 2., 0.), vec3(0.8,0.8,0.8), 1.0, 1.0);\n\n  // Tree\n  vec4 trunk = segmentColor(p * vec3(8.,8.,1.) - vec3(0.,0.,0.), vec3(0.,0.,0.), vec3(0.,0.,1.), vec3(0.5451, 0.2705, 0.0745), 1.0, 1.0);\n//   vec4 leafs = pointColor(p * vec3(6.,6.,6.) - vec3(0.,0.,-4.), vec3(0.,0.,0.), vec3(0.,1.,0.), 2., 2.);\n//   leafs = BlendColor(leafs, pointColor(p * vec3(6.,6.,6.) - vec3(0.,1.,-3.), vec3(0.,0.,0.), vec3(0.,1.,0.), 2., 2.));\n//   leafs = BlendColor(leafs, pointColor(p * vec3(6.,6.,6.) - vec3(0.,-1.,-3.), vec3(0.,0.,0.), vec3(0.,1.,0.), 2., 2.));\n//   leafs = BlendColor(leafs, pointColor(p * vec3(6.,6.,6.) - vec3(1.,0.,-3.), vec3(0.,0.,0.), vec3(0.,1.,0.), 2., 2.));\n//   leafs = BlendColor(leafs, pointColor(p * vec3(6.,6.,6.) - vec3(-1.,0.,-3.), vec3(0.,0.,0.), vec3(0.,1.,0.), 2., 2.));\n//   vec4 tree = UnionColor(trunk, leafs);\n\n  // Big Island\n  //vec4 big_island = BlendColor(grass, beach);\n  //big_island = BlendColor(big_island, mountain);\n//   big_island = BlendColor(big_island, tree);\n\n  // Small Island\n  vec3 transform_s = (rotateY(p, PI/2.) - vec3(.9,-10.,0.)) * vec3(2.,2.,2.);\n  //vec4 beach_small_island = diskColor(transform_s, vec3(0.,0.,0.), 5., vec3(1.,1.,0.7), 1., 0.7);\n  //vec4 small_island_ = boxColor((p - vec3(-0.7,-10.,0.) - n_small_island),\n        //vec3(-0.5,-0.5,-0.5), vec3(0.5, 0.5, 0.), vec3(0.8,0.8,0.8), 1.0, 1.0);\n  //vec4 small_island = BlendColor(beach_small_island, small_island_);\n\n  // Islands\n  //vec4 islands = UnionColor(big_island, small_island);\n  //islands = UnionColor(islands, bridge);\n\n  //v = BlendColor(sea, islands);\n  \n  //v = cappedConeColor(p - vec3(0., 0., -5.), vec3(0., 0., 1.), vec3(0., 0., 5.), 0.1, 5., vec3(1.,0.,0.), 1., 1.);\n\n\n\n  \n//   vec4 b1 = pointColor(p * vec3(1.,1.2,1.), vec3(0.,0.,0.), vec3(0.,0.,1.), 2., 2.);\n//   b1 = BlendColor(b1, pointColor(p - vec3(0.,0.,-1.), vec3(0.,0.,0.), vec3(1.,0.,1.), 2., 1.));\n//   b1 = BlendColor(b1, pointColor(p - vec3(-0.7,0.,-0.8), vec3(0.,0.,0.), vec3(1.,0.,1.), 1., 1.));\n//   b1 = BlendColor(b1, pointColor(p - vec3(0.7,0.,-0.8), vec3(0.,0.,0.), vec3(1.,0.,1.), 1., 1.));\n\n  // Ears\n  vec3 tr = rotateX(p, PI/4.) * vec3(3.,3.,2.) - vec3(-3.,0.,0.);\n  //vec4 ears = diskColor(tr, vec3(0.,0.,0.), 1., vec3(.4,0.,0.7), 1., 0.7);\n  \n//   b1 = BlendColor(b1, ears);\n  \n  \n\n  v = pointColor(p, vec3(0.,0.,0.), 1., vec3(1.,0.,0.));\n  v = sdRoundBox(p, vec3(1.,2.,1.), 0.7, vec3(0.,1.,0.));\n  \n  p = scaleUniform(p, 3.);\n  \n  \n  float t = 0.01 * (-iTime * 130.0);\n  \n  // Sea\n  float noise_sea = fbm(vec2(p.x, p.y), 0.3, 2, t);\n  v = colorPlane(p - noise_sea, vec3(0.,0.,-1.), 2., vec3(0.,0.8,1.));\n  \n  // Island\n  v = BlendColor(v, colorRoundedCylinder(rotateX(translateZ(p,-3.5),PI/2.), 10.,1.,1.,vec3(0.5,0.5,0.5)), 1.);\n  v = BlendColor(v, colorRoundedCylinder(rotateX(translateZ(p,-3.2),PI/2.), 8.,1.,1.,vec3(0.1,1.,0.3)), 2.);\n  \n  // Mountain\n  float n_mountain = fbm(vec2(p.x, p.y), 1.5, 2, 0.);\n  v = BlendColor(v, colorRoundedCylinder(rotateX(translateZ(p - n_mountain,0.),PI/2.), 4.,3.,4.,vec3(0.7,0.7,0.7)), 5.);\n    \n\n  return vec4(v.x, v.y, v.z, v.w);\n}\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p)\n{\n  float eps=.0001;\n  vec3 n;\n  vec4 v=ObjectColored(p);\n  n.x=ObjectColored(vec3(p.x+eps,p.y,p.z)).x-v.x;\n  n.y=ObjectColored(vec3(p.x,p.y+eps,p.z)).x-v.x;\n  n.z=ObjectColored(vec3(p.x,p.y,p.z+eps)).x-v.x;\n  return normalize(n);\n}\n\nvec3 ObjectColor(in vec3 p)\n{\n  vec4 v = ObjectColored(p);\n  return vec3(v.y, v.z, v.w);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat Trace(vec3 o,vec3 u,float rB,out bool h,out int s)\n{\n  h=false;\n  \n  // Don't start at the origin, instead move a little bit forward\n  float t=rA;\n  \n  for(int i=0;i<Steps;i++)\n  {\n    s=i;\n    vec3 p=o+t*u;\n    //float v=Object(p);\n    vec4 v = ObjectColored(p);\n    // Hit object\n    if(v.x<0.)\n    {\n      s=i;\n      h=true;\n      break;\n    }\n    // Move along ray\n    t+=Epsilon;\n    // Escape marched far away\n    if(t>rB)\n    {\n      break;\n    }\n  }\n  return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o,vec3 u,float rB,out bool h,out int s)\n{\n  h=false;\n  \n  // Don't start at the origin, instead move a little bit forward\n  float t=rA;\n  \n  for(int i=0;i<Steps;i++)\n  {\n    s=i;\n    vec3 p=o+t*u;\n    //float v=Object(p);\n    vec4 v = ObjectColored(p);\n    // Hit object\n    if(v.x<0.)\n    {\n      s=i;\n      h=true;\n      break;\n    }\n    // Move along ray\n    t+=max(Epsilon,abs(v.x)/4.);\n    // Escape marched far away\n    if(t>rB)\n    {\n      break;\n    }\n  }\n  return t;\n}\n\n// Ambient occlusion\n// p : Point\n// n : Normal\n// a : Number of smaples\nfloat AmbientOcclusion(vec3 p,vec3 n,int a)\n{\n  if(a==0){return 1.;}\n  \n  float ao=0.;\n  \n  for(int i=0;i<a;i++)\n  {\n    vec3 d=Cosine(581.123*float(i),n);\n    \n    int s;\n    bool h;\n    float t=SphereTrace(p,d,10.,h,s);\n    if(!h){ao+=1.;}\n    else if(t>5.)\n    {\n      ao+=1.;\n    }\n  }\n  \n  ao/=float(a);\n  return ao;\n}\n\n// Background color\nvec3 background(vec3 rd)\n{\n  return mix(vec3(.652,.451,.995),vec3(.552,.897,.995),rd.z*.5+.5);\n}\n\nfloat Light(vec3 p,vec3 n)\n{\n  // point light\n  const vec3 lp=vec3(5.,10.,25.);\n  \n  vec3 l=normalize(lp-p);\n  \n  // Not even Phong shading, use weighted cosine instead for smooth transitions\n  float diff=pow(.5*(1.+dot(n,l)),2.);\n  \n  bool h;\n  int s;\n  float t=SphereTrace(p+.1*n,l,100.,h,s);\n  if(!h)\n  {\n    return diff;\n  }\n  return 0.;\n}\n\nfloat SmoothLight(vec3 p,vec3 n,int a)\n{\n  if(a==0)\n  return 1.;\n  \n  // point light\n  const vec3 lp=vec3(5.,10.,25.);\n  \n  vec3 l=normalize(lp-p);\n  \n  float lo=0.;\n  \n  for(int i=0;i<a;i++)\n  {\n    vec3 d=Cosine(581.123*float(i),n);\n    d=normalize(l+d*.15);\n    int s;\n    bool h;\n    float t=SphereTrace(p,d,10.,h,s);\n    if(!h){lo+=1.;}\n    else if(t>100.)\n    {\n      lo+=1.;\n    }\n  }\n  \n  lo/=float(a);\n  return lo;\n  \n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\nvec3 Shade(vec3 p,vec3 n)\n{\n  vec3 c=.25+.25*background(n);\n  c+=.15*AmbientOcclusion(p+.1*n,n,0)*vec3(1.,1.,1.);\n  c+=.35*Light(p,n);\n  return c;\n}\n\n// Shading with number of steps\nvec3 ShadeSteps(int n)\n{\n  float t=float(n)/(float(Steps-1));\n  return .5+mix(vec3(.05,.05,.5),vec3(.65,.39,.65),t);\n}\n\n// Picture in picture\n// pixel : Pixel\n// pip : Boolean, true if pixel was in sub-picture zone\nvec2 Pip(in vec2 pixel,out bool pip)\n{\n  // Pixel coordinates\n  vec2 p=(-iResolution.xy+2.*pixel)/iResolution.y;\n  if(pip==true)\n  {\n    const float fraction=1./4.;\n    // Recompute pixel coordinates in sub-picture\n    if((pixel.x<iResolution.x*fraction)&&(pixel.y<iResolution.y*fraction))\n    {\n      p=(-iResolution.xy*fraction+2.*pixel)/(iResolution.y*fraction);\n      pip=true;\n    }\n    else\n    {\n      pip=false;\n    }\n  }\n  return p;\n}\n\n// Image\nvoid mainImage(out vec4 color,in vec2 pxy)\n{\n  // Picture in picture on\n  bool pip=true;\n  \n  // Pixel\n  vec2 pixel=Pip(pxy,pip);\n  \n  // Mouse\n  vec2 m=iMouse.xy/iResolution.xy;\n  \n  // Camera\n  vec3 ro,rd;\n  Ray(m,pixel,ro,rd);\n\n  \n  float a=iTime*0.25;\n  //ro = rotateZ(ro, a);\n  //rd = rotateZ(rd, a);\n  // Trace ray\n  \n  // Hit and number of steps\n  bool hit;\n  int s;\n  \n  float t=SphereTrace(ro,rd,100.,hit,s);\n  //float t = Trace(ro, rd, 100., hit, s);\n  \n  // Position\n  vec3 pt=ro+t*rd;\n  \n  // Shade background\n  vec3 rgb=background(rd);\n  \n  if(hit)\n  {\n    // Compute normal\n    vec3 n=ObjectNormal(pt);\n\n    vec3 col = ObjectColor(pt);\n    \n    // Shade object with light\n    rgb=Shade(pt,n) * col;\n  }\n  \n  // Uncomment this line to shade image with false colors representing the number of steps\n  if(pip==true)\n  {\n    rgb=ShadeSteps(s);\n  }\n  \n  color=vec4(rgb,1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NddSWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 93, 117, 117, 157], [159, 179, 219, 219, 454], [456, 502, 526, 526, 607], [609, 700, 755, 755, 1026], [1237, 1251, 1285, 1285, 1322], [1323, 1323, 1357, 1357, 1394], [1395, 1395, 1429, 1429, 1466], [1468, 1468, 1498, 1498, 1586], [1588, 1588, 1618, 1618, 1707], [1709, 1709, 1739, 1739, 1828], [1830, 1830, 1860, 1860, 1894], [1895, 1895, 1925, 1925, 1959], [1960, 1960, 1990, 1990, 2024], [2025, 2025, 2061, 2061, 2099], [2116, 2224, 2260, 2260, 2288], [2289, 2289, 2343, 2343, 2398], [2400, 2400, 2442, 2442, 2467], [2468, 2468, 2523, 2523, 2565], [2567, 2578, 2635, 2635, 2909], [2911, 2911, 2984, 2984, 3047], [3049, 3059, 3116, 3116, 3284], [3285, 3285, 3358, 3358, 3420], [3422, 3430, 3467, 3467, 3676], [3677, 3677, 3730, 3730, 3782], [3783, 3783, 3816, 3816, 3881], [3882, 3882, 3929, 3929, 3967], [3969, 3969, 4024, 4024, 4128], [4130, 4130, 4194, 4194, 4311], [4312, 4312, 4388, 4388, 4443], [4459, 4512, 4542, 4542, 4558], [4560, 4560, 4602, 4602, 4795], [4797, 4885, 4915, 4915, 4936], [4937, 4937, 4970, 4970, 5015], [5017, 5017, 5055, 5055, 5076], [5078, 5078, 5114, 5114, 5136], [5138, 5138, 5174, 5174, 5192], [5193, 5193, 5231, 5231, 5266], [5268, 5770, 5792, 5792, 6132], [6133, 6133, 6154, 6154, 6533], [7911, 7924, 7951, 7951, 8068], [8069, 8110, 8130, 8130, 8225], [8226, 8226, 8252, 8252, 8726], [8728, 8815, 8841, 8841, 9279], [9281, 9322, 9385, 9407, 9609], [9611, 9611, 9639, 9639, 17814], [17816, 17856, 17886, 17886, 18117], [18119, 18119, 18148, 18148, 18209], [18211, 18316, 18374, 18374, 18793], [18795, 18900, 18964, 18964, 19400], [19402, 19475, 19520, 19520, 19798], [19800, 19820, 19846, 19846, 19916], [19918, 19918, 19946, 19963, 20261], [20263, 20263, 20303, 20303, 20691], [20693, 20754, 20781, 20781, 20902], [20904, 20936, 20960, 20960, 21054], [21056, 21151, 21189, 21212, 21594], [21596, 21605, 21649, 21676, 22489]]}
{"id": "NddXRj", "name": "random shader 2021-10-06", "author": "tak0294", "description": "random shader", "tags": ["random"], "likes": 2, "viewed": 35, "published": "Public", "date": "1635484181", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define delta 60.0/1000.0\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    //uv *= iTimeDelta*float(iFrame);\n\n    float randX = rand(uv+iTime*.05)*.5;\n    float randY = rand(vec2(uv.y+float(iFrame),0))*.0001;\n    ;\n    //float vecX = (uv.x - (uv.x+randX)) / 240.0;\n    //uv.x = uv.x + (vecX*iTime);\n    if(rand(vec2(iTime,0)) < .2) {\n    }\n    \n    //uv.y += randY;\n    //uv.x += randY;\n\n    \n    // Time varying pixel color\n    vec4 col = texture(iChannel0, uv);\n    vec4 col2 = texture(iChannel0, vec2(uv.x+.01+randX*.01, uv.y+.001+randY*.02));\n    vec4 col3 = texture(iChannel0, vec2(uv.x+.01+randY*.01, uv.y+.001+randX*.02));\n    \n\n    col.x += randX;\n    col.y += randX;\n    // Output to screen\n    fragColor = vec4(col.r,col2.g,col3.b,1.);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NddXRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 47, 47, 119], [121, 121, 178, 228, 946]]}
{"id": "NddXWH", "name": "Haru86_Ray", "author": "Haru86_", "description": "Haru86_", "tags": ["raymarching"], "likes": 4, "viewed": 88, "published": "Public", "date": "1633064507", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime;\n#define resolution iResolution;\n\n#define PI 3.14159265\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nvec2 pmod(vec2 p,float n){\n  float a=atan(p.x,p.y)+PI/n;\n  float num=2.0*PI/n;\n  a=floor(a/num)*num;\n  return rot(-a)*p;\n}\n\nfloat c(vec3 p,vec3 s){\n  return length(max(abs(p)-s,0.));\n}\n\nvec3 trs(vec3 p){\n  vec3 pos=p;\n  pos.z-=iTime*3.;\n  float k=8.;\n  pos=mod(pos,k)-k*.5;\n\n pos.xy=pmod(pos.xy,6.);\n pos.yz=pmod(pos.yz,5.);\n\npos.xz=pmod(pos.xz,12.);\n  pos=abs(pos)-.15;\n  pos.z=abs(pos.z)-.12;\n  pos.z=abs(pos.z)-.182;\n\n\n  return pos;\n}\n\nfloat m1m(vec3 p){\n  //rotation/////////////\n    // p.xz*=rot(time*0.1);\n  // TRS////////////////////////\n   p=trs(p);\n\n\n  p=abs(p);\n   vec3 o=p*1.5;\n  float s=1.;\n\n  \n  for(int i=0;i<5;i++){\n\n    if(p.x<p.y)p.xy=p.yx;\n    if(p.x<p.z)p.xz=p.zx;\n    if(p.y<p.z)p.yz=p.zy;\n\n    p.xy=pmod(p.xy,3.0*.25);\n    p.yz=pmod(p.yz,6.*.8);\n  p.xz=pmod(p.xz,4.*.85);\n\n     float r=0.55*clamp(5.38*max(dot(p,p)*3.2,5.01),.1,.98)*9.;\n\n     s*=r;\n     p*=r;\n     p=abs(p)-o;\n\n     p=abs(p)-0.5;\n     p.z=abs(p.z)-0.92;\n     p.x=abs(p.x)-0.45;\n    p.z-=0.12;\n    p.z-=0.8;\n    p=abs(p)-0.5;\n     p.xz=pmod(p.xz,12.);\n     p.xy=pmod(p.xy,6.);\n\n     p=abs(p)-0.15;\n     p.y=abs(p.y)-.6;\n\n     p.xy*=rot(0.23);\n     p.yz*=rot(0.74);\n     p.xz*=rot(0.623);\n\n     p.z-=0.3;\n     p.z-=0.1;\n     p.z=abs(p.z)-0.5;\n\n\n    p=abs(p)-0.25;\n\n    if(p.x<p.y)p.xy=p.yx;\n    if(p.x<p.z)p.xz=p.zx;\n    if(p.y<p.z)p.yz=p.zy;\n\n\n\n  }\n  p/=s;\n\np.xz=pmod(p.xz,12.);\np.z=abs(p.z)-.45;\np.z=abs(p.z)-0.12;\np.xy=pmod(p.xy,2.);\np.z=abs(p.z)-0.231;\np.xy=pmod(p.xy,3.);\n\n  float m=c(p,vec3(1.,1.,.3));\n  return m;\n}\n\nfloat map(vec3 p){\n  \n  float m1=m1m(p);\n  return m1;\n}\n\nvec3 gn(vec3 p){\n  vec2 e=vec2(0.001,0.);\n  return normalize(vec3(\n    map(p+e.xyy)-map(p-e.xyy),\n    map(p+e.yxy)-map(p-e.yxy),\n    map(p+e.yyx)-map(p-e.yyx)\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 st=(fragCoord.xy*2.-iResolution.xy)/min(iResolution.x,iResolution.y);\nst*=rot(iTime);\n float radius=0.1;\n   float phi=iTime*0.2;\n   \n  // vec3 ro=vec3(0.0,0.0,1.0);\n   vec3 ro=vec3(radius*cos(phi),0.0,radius*sin(phi));\n   //vec3 rd=normalize(vec3(uv.xy,-3.0));\n   vec3 ta=vec3(0.0,0.0,0.0);\n   \n   vec3 cDir=normalize(ta-ro);\n   vec3 side=cross(cDir,vec3(0.0,1.0,0.0));\n   vec3 up=cross(cDir,side);\n   float fov=0.6;\n   \n   vec3 rd=normalize(vec3(st.x*side+st.y*up+cDir*fov));\n\n  float d,t,acc=0.;\n  for(int i=0;i<128;i++){\n    d=map(ro+rd*t);\n    // d=min(d,.5);\n     d=min(abs(d),.2);\n    if(abs(d)<0.001||t>1000.0)break;\n    t+=d;\n    acc+=exp(-6.*d);\n  }\n\n/*\nvec3 n=gn(ro+rd*t);\n  float acc2=0.0;\nt=0.1;\nvec3 refro=ro+rd*t;\nrd=reflect(rd,n);\nro=refro;\n\nfor(int i=0;i<64;i++){\n  d=map(ro+rd*t);\n //  d=min(abs(d),.5);\n  if(d<0.001||t>1000.0)break;\n  t+=d;\n  acc2+=exp(-6.*d);\n}*/\n\n\n  vec3 col=vec3(.9,.8,.7)*acc*0.025;//+vec3(1.,0.25,0.5)*acc2*0.025;\n \n\n  fragColor=vec4(col,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NddXWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[126, 126, 152, 152, 248], [250, 250, 273, 273, 310], [312, 312, 329, 329, 563], [565, 565, 583, 670, 1634], [1636, 1636, 1654, 1654, 1691], [1693, 1693, 1709, 1709, 1861], [1863, 1863, 1920, 1920, 2911]]}
{"id": "NddXWs", "name": "pac land-house", "author": "jorge2017a2", "description": "pac land-house", "tags": ["2d", "house", "land", "pac"], "likes": 5, "viewed": 123, "published": "Public API", "date": "1634173123", "time_retrieved": "2021-10-01T00:00:00", "image_code": "///pac land-house-2d-JFP\n///por jorge2017a2...2021-oct-09\n///referencia\n//https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(antialiasing(0.05),b,d)\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n///---------------------------\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n    \nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  //colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.05,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.05,0.0));\n  return colOut;\n}\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n    return colOut;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{   vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{   p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n\nfloat sdParallelogram( in vec2 p, float wi, float he, float sk )\n{   vec2 e = vec2(sk,he);\n    p = (p.y<0.0)?-p:p;\n    vec2  w = p - e; w.x -= clamp(w.x,-wi,wi);\n    vec2  d = vec2(dot(w,w), -w.y);\n    float s = p.x*e.y - p.y*e.x;\n    p = (s<0.0)?-p:p;\n    vec2  v = p - vec2(wi,0); v -= e*clamp(dot(v,e)/dot(e,e),-1.0,1.0);\n    d = min( d, vec2(dot(v,v), wi*he-abs(s)));\n    return sqrt(d.x)*sign(-d.y);\n}\n\n\nvec3 Suelo1(vec2 p, vec3 col)\n{  col=DrawFig(vec3(0.75,0.35,0.2), col, p.y-0.5 );\n return col;\n}\n\nvec3 colina(vec2 p, vec3 col)\n{   p.x=opRep1D(p.x, 8.5 );\n    float d1= sdTriangleIsosceles(vec2(p.x,-p.y+0.5), vec2(4.0,2.0) );\n    col=DrawFigBordeCol(vec3(0.0,0.95,0.2), col, d1 , vec3(0.35));\n    return col;\n}\n\nvec3 colina2(vec2 p, vec3 col, float escala)\n{   p.x=opRep1D(p.x, 8.5 );\n    float d1= sdTriangleIsosceles(vec2(p.x,-p.y+0.5), vec2(4.0,5.0) );\n    col=DrawFigBordeCol(vec3(0.0,0.95,0.2)*escala, col, d1 , vec3(0.35));\n    return col;\n}\n\n\nvec3 casa1(vec2 p, vec3 col)\n{   float d1= sdBox(p, vec2(3.5,2.5) );\n    float d2=sdTriangleIsosceles(vec2(p.x,-p.y)-vec2(4.4,-5.0), vec2(1.1,2.5) );\n    float d3=sdBox(p-vec2(-1.5,-1.0), vec2(0.8,0.8) ); //ventana\n    float d4=sdBox(p-vec2(1.5,-1.0), vec2(0.8,1.5) ); //puerta\n    float d5= sdParallelogram(p-vec2(0.0,3.7), 4.0, 1.3, 0.5 );\n    float d6= sdParallelogram(p.yx-vec2(0.6,4.3), 2.5, 0.7, 0.5 );\n    col= DrawFigBorde(vec3(0.5,0.6,0.1),col, d1 );// frente\n    col= DrawFigBorde(vec3(0.1),col, d6 );\n    col= DrawFigBorde(vec3(0.0),col, d2 );\n    col= DrawFigBorde(vec3(0.0,0.5,0.5),col, d3 );\n    col= DrawFigBorde(vec3(0.0,0.0,1.0),col, d4 );\n    col= DrawFigBorde(vec3(1.0,0.0,0.0),col, d5 );\n    return col;\n}\n\n\nvec3 casa2(vec2 p, vec3 col)\n{   float d1= sdBox(p, vec2(3.5,2.5) );\n    float d2=sdTriangleIsosceles(vec2(p.x,-p.y)-vec2(4.4,-5.0), vec2(1.1,2.5) );\n    float d3=sdBox(p-vec2(-1.5,-0.4), vec2(0.8,0.8) ); //ventana\n    float d4=sdBox(p-vec2(1.5,-1.0), vec2(0.8,1.5) ); //puerta\n    float d5= sdParallelogram(p-vec2(0.0,3.7), 4.0, 1.3, 0.5 );\n    float d6= sdParallelogram(p.yx-vec2(0.6,4.3), 2.5, 0.7, 0.5 );\n    \n    float d7=sdBox(p-vec2(1.7,3.5), vec2(0.8,0.8));\n    float d8=sdBox(p-vec2(-1.7,3.5), vec2(0.8,0.8));\n    float d7a=sdTriangleIsosceles(vec2(p.x,p.y)-vec2(-0.8,2.8), vec2(1.0,1.5) );\n    float d8a=sdTriangleIsosceles(vec2(p.x,p.y)-vec2( 2.5,2.8), vec2(1.0,1.5) );\n    col= DrawFigBorde(vec3(0.4,0.8,1.00),col, d1 );// frente\n    col= DrawFigBorde(vec3(0.1),col, d6 );\n    col= DrawFigBorde(vec3(0.0),col, d2 );\n    col= DrawFigBorde(vec3(0.0,0.5,0.5),col, d3 );\n    col= DrawFigBorde(vec3(0.2,0.2,1.0),col, d4 ); //puerta\n    col= DrawFigBorde(vec3(1.0,0.0,0.0),col, d5 );\n    col= DrawFigBorde(vec3(0.0),col, d7a );\n    col= DrawFigBorde(vec3(0.0),col, d8a );\n    col= DrawFigBorde(vec3(0.0,0.0,1.0),col, d7 );\n    col= DrawFigBorde(vec3(0.0,0.0,1.0),col, d8 );\n    return col;\n}\n\n\nvec3 casa3(vec2 p, vec3 col)\n{   float d1= sdBox(p, vec2(3.5,2.5) );\n    float d2=sdTriangleIsosceles(vec2(p.x,-p.y)-vec2(4.5,-5.3), vec2(1.2,3.2) );\n    float d3=sdBox(p-vec2(-1.5,-0.4), vec2(0.8,0.8) ); //ventana\n    float d4=sdBox(p-vec2(1.5,-1.0), vec2(0.8,1.5) ); //puerta\n    float d5= sdParallelogram(p-vec2(0.0,3.6), 4.0, 1.9, 0.5 );\n    float d6= sdParallelogram(p.yx-vec2(0.6,4.3), 2.5, 0.7, 0.5 );\n    float d7=sdBox(p-vec2(1.7,3.5), vec2(0.8,0.8));\n    float d8=sdBox(p-vec2(-1.7,3.5), vec2(0.8,0.8));\n    float d7a=sdTriangleIsosceles(vec2(p.x,p.y)-vec2(-0.8,2.8), vec2(1.0,1.5) );\n    float d8a=sdTriangleIsosceles(vec2(p.x,p.y)-vec2( 2.5,2.8), vec2(1.0,1.5) );\n   \n   col= DrawFigBorde(vec3(1.0,0.8,0.1),col, d1 );// frente\n    col= DrawFigBorde(vec3(0.1),col, d6 );\n    col= DrawFigBorde(vec3(0.0),col, d2 );\n    col= DrawFigBorde(vec3(0.0,0.5,0.5),col, d3 );\n    col= DrawFigBorde(vec3(0.2,0.2,1.0),col, d4 ); //puerta\n    col= DrawFigBorde(vec3(1.0,0.0,0.0),col, d5 );\n    col= DrawFigBorde(vec3(0.0),col, d7a );\n    col= DrawFigBorde(vec3(0.0),col, d8a );\n    col= DrawFigBorde(vec3(0.0,0.0,1.0),col, d7 );\n    col= DrawFigBorde(vec3(0.0,0.0,1.0),col, d8 );\n    return col;\n}\n\n\nvec3 grupo1(vec2 uv, vec3 col)\n{   col=casa3(uv-vec2(0.0,-1.0), col);\n    col=casa2(uv-vec2(12.0,-1.0), col);\n    col=casa1(uv-vec2(25.0,-1.0), col);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    vec3  col=vec3(0.45,0.7,1.0)-uv.y*0.25;\n    uv*=8.0;\n    vec2 uv1=uv;\n    vec2 uv2=uv;\n    uv1.x=opRep1D(uv1.x,100.);\n    uv2.x=opRep1D(uv2.x,100.0);\n    float tt=mod(iTime,14.0)*4.0;\n    \n    uv1.x+=tt;\n    uv2.x+=tt;\n    //col=colina2(uv1-vec2(3.0,3.0), col,0.8);\n    col=colina(uv1-vec2(0.0,1.0), col);\n    col=Suelo1(uv1-vec2(0.0,-1.0), col);\n    col= grupo1(uv1-vec2(0.0,1.2), col);\n    col= grupo1(uv2*2.0-vec2(70.0,1.0), col);\n    col= grupo1(uv1-vec2(20.0,-7.0), col);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NddXWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 311, 345, 345, 440], [441, 472, 508, 508, 553], [558, 602, 649, 649, 676], [677, 677, 720, 720, 747], [748, 748, 796, 796, 824], [830, 830, 892, 892, 1088], [1090, 1090, 1171, 1171, 1298], [1300, 1300, 1357, 1357, 1427], [1429, 1429, 1466, 1466, 1544], [1546, 1546, 1581, 1581, 1604], [1606, 1606, 1657, 1657, 1963], [1966, 1966, 2032, 2032, 2372], [2375, 2375, 2406, 2406, 2471], [2473, 2473, 2504, 2504, 2686], [2688, 2688, 2734, 2734, 2923], [2926, 2926, 2956, 2956, 3651], [3654, 3654, 3684, 3684, 4851], [4854, 4854, 4884, 4884, 6048], [6051, 6051, 6083, 6083, 6218], [6221, 6221, 6278, 6278, 6891]]}
{"id": "NdGSRz", "name": "Newton's fractal with roots", "author": "ninofiliu", "description": "Following, 3b1b's excellent youtube video on Newton's fractal, I just HAD to code it!", "tags": ["newton", "polynomial", "3blue1brown", "3b1b", "threeblueoneblrown"], "likes": 4, "viewed": 171, "published": "Public API", "date": "1634221246", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct Closest {\n    int i;\n    float d;\n};\n\nvec2 mul(vec2 a, vec2 b) { return vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x); }\nvec2 inv(vec2 a) { return vec2(a.x, -a.y) / (a.x*a.x + a.y*a.y); }\n\nconst int deg = 10;\nvec2 roots[deg];\n\nvec2 f(vec2 a) {\n    vec2 ret = vec2(1.0, 0.0);\n    for (int i = 0; i < deg; i++) {\n        ret = mul(ret, a-roots[i]);\n    }\n    return ret;\n}\n\nvec2 fp(vec2 a) {\n    vec2 sum = vec2(0.0, 0.0);\n    for (int i = 0; i < deg; i++) {\n        sum += inv(a-roots[i]);\n    }\n    return inv(sum);\n}\n\nClosest getClosest(vec2 u) {\n    Closest closest = Closest(0, distance(u, roots[0]));\n    for (int i = 1; i < deg; i++) {\n        float d = distance(u, roots[i]);\n        if (d < closest.d) {\n            closest.i = i;\n            closest.d = d;\n        }\n    }\n    return closest;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 a = 2.5 * (fragCoord - iResolution.xy / 2.0) / min(iResolution.x, iResolution.y);\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    for (int i = 0; i < deg; i++) {\n        float rot = 0.1 * iTime * (float(i)+1.0);\n        roots[i] = vec2(cos(rot), sin(rot));\n    }\n    \n    vec2 u = a;\n    Closest c;\n    for (int i = 0; i < 100; i++) {\n        u -= fp(u);\n        c = getClosest(u);\n        if (c.d < 0.1) { break; }\n    }\n    \n    fragColor.rgb = vec3(float(c.i) / float(deg));\n    \n    for (int i = 0; i < deg; i++) {\n        if (distance(roots[i], a) < 0.05) {\n            fragColor.r = 1.0;\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdGSRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 45, 71, 71, 120], [121, 121, 139, 139, 187], [227, 227, 243, 243, 370], [372, 372, 389, 389, 517], [519, 519, 547, 547, 802], [804, 804, 859, 859, 1483]]}
{"id": "NdGXDD", "name": "Vessel Climbing", "author": "dr2", "description": "Virtually climbing the \"Vessel\" in NYC - now closed; mouseable", "tags": ["tower", "geometry", "architecture"], "likes": 19, "viewed": 176, "published": "Public API", "date": "1634630131", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Vessel Climbing\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Virtually climbing the \"Vessel\" in NYC - now closed; mouseable.\n\n/*\n  No. 4 in \"Vessel\" series\n    \"Stairs to Nowhere\"         (wtB3R3)\n    \"Submerging Tower\"          (wdcGWr)\n    \"Mountain Lake with Tower\"  (3tdcWj)\n*/\n\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat IFbm1 (float p);\nfloat Fbm2 (vec2 p);\n\nvec4 szFlr;\nvec3 ltDir, qHit, pvU[5], pvD[5];\nfloat dstFar, tCur, twrScl, flSpc, nFlr, twrRad, bSizeV, cIdV;\nint idObj;\nconst int idFlr = 1, idStr = 2, idRl = 3, idStn = 4, idCln = 5, idMovBU = 6, \n   idMovHU = 7, idMovBD = 8, idMovHD = 9, idWall = 10, idRfEx = 11, idGrEx = 12;\nconst float pi = 3.1415927, sqrt2 = 1.41421;\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat GObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, stSpc, xLim1, xLim2, bRad, r, a, x;\n  bool topFlr, botFlr;\n  dMin = dstFar / twrScl;\n  p /= twrScl;\n  r = length (p.xz) - twrRad;\n  d = r - 20.;\n  if (d < 1.) {\n    a = 2. * pi * ((floor (6. * atan (p.x, - p.z) / (2. * pi)) + 0.5) / 6.);\n    stSpc = 6.;\n    xLim1 = abs (dot (p.xz, sin (a + vec2 (0.5 * pi, 0.)))) - 22.;\n    xLim2 = xLim1 + 16.;\n    bRad = 0.5 * 0.5;\n    topFlr = (cIdV == 2. * nFlr - 1.);\n    botFlr = (cIdV == 0.);\n    if (topFlr) {\n      d = length (max (abs (vec2 (p.y + 0.5 * szFlr.w, r + szFlr.z + stSpc)) -\n         vec2 (0.5 * szFlr.w, szFlr.z), 0.));\n      DMIN (idFlr);\n      d = max (length (vec2 (p.y + 0.4, abs (r + szFlr.z + stSpc - 0.5)) - (szFlr.z - 0.1)) -\n         bRad, - xLim2);\n      DMIN (idRl);\n    }\n    d = max (length (max (abs (vec2 ((topFlr ? - p.y : abs (p.y)) - flSpc,\n       r - 0.4 * (szFlr.z + stSpc))) - vec2 (szFlr.w, 1.4 * (szFlr.z + stSpc)), 0.)), - xLim1);\n    DMIN (idFlr);\n    d = max (length (max (abs (vec2 (p.y + szFlr.w, r)) - vec2 (szFlr.w, 2. * szFlr.z + stSpc +\n       0.5), 0.)), xLim2);\n    DMIN (idFlr);\n    p.zx = Rot2D (p.zx, a);\n    p.z = abs (p.z) - twrRad;\n    x = abs (p.x) - szFlr.x;\n    for (float sz = -1.; sz <= 1.; sz += 2.) {\n      if (! topFlr || sz < 0.) {\n        q.x = x;\n        q.yz = p.yz - sz * vec2 (szFlr.y - szFlr.w, - (szFlr.z + stSpc));\n        d = abs (q.y) - (szFlr.y - szFlr.w - 0.005);\n        q.xy = vec2 (q.x + sz * q.y, - sz * q.x + q.y) / sqrt2;\n        d = max (max (max (q.y - 0.5 * sqrt2 - abs (0.5 * sqrt2 - mod (q.x, sqrt2)),\n           abs (q.z) - szFlr.z), -1. - q.y), d);\n        DMIN (idStr);\n      }\n    }\n    d = max (length (vec2 (p.y + flSpc - 4., abs (r - szFlr.z) - (2. * szFlr.z + stSpc -\n       0.8))) - bRad, - xLim1);\n    DMIN (idRl);\n    d = max (length (vec2 (p.y - 3.5, abs (r - 0.4) - (2. * szFlr.z + stSpc - 0.1))) - bRad, xLim2);\n    DMIN (idRl);\n    q = vec3 (x - 4., p.y + 0.5 * flSpc, abs (p.z - (szFlr.z + stSpc)) - szFlr.z);\n    d = max (length (vec2 ((q.x + q.y) / sqrt2, q.z)) - bRad, abs (x) - 8.);\n    DMIN (idRl);\n    q.xz = vec2 (x + 4., abs (p.z + szFlr.z + stSpc) - szFlr.z);\n    if (! botFlr) {\n      d = max (length (vec2 ((q.x - (p.y + 1.5 * flSpc)) / sqrt2, q.z)) - bRad, abs (x) - 8.);\n      DMIN (idRl);\n    }\n    if (! topFlr) {\n      d = max (length (vec2 ((q.x - (p.y - 0.5 * flSpc)) / sqrt2, q.z)) - bRad, abs (x) - 8.);\n      DMIN (idRl);\n    }\n    x = abs (p.x);\n    q.x = x - 22.;\n    d = min (length (vec2 (q.x, p.y + flSpc - 4.)), length (vec2 (x - 6., p.y - 3.5))) - bRad;\n    d = max (d, max (abs (p.z) - (2. * szFlr.z + stSpc), szFlr.z - abs (abs (p.z) - (szFlr.z + stSpc))));\n    DMIN (idRl);\n    q.yz = vec2 (p.y + flSpc - 2.5, abs (abs (p.z) - (szFlr.z + stSpc)) - szFlr.z);\n    d = PrCapsDf (q.xzy, 0.7 * 0.7, 2. + 0.2);\n    DMIN (idStn);\n    if (! topFlr) {\n      d = length (vec2 (q.x, p.z)) - 0.8 * 0.8;\n      DMIN (idCln);\n    }\n    d = PrCapsDf (vec3 (x - 6., p.y - 2.5, q.z).xzy, 0.7 * 0.7, 2. + 0.2);\n    DMIN (idStn);\n    dMin *= 0.7;\n  } else dMin = d;\n  return twrScl * dMin;\n}\n\nfloat GObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d, eps, sy;\n  eps = 0.0005;\n  dHit = eps;\n  if (rd.y == 0.) rd.y = 0.001;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ro + dHit * rd;\n    cIdV = floor (p.y / bSizeV);\n    sy = (bSizeV * (cIdV + step (0., rd.y)) - p.y) / rd.y;\n    d = abs (sy) + eps;\n    if (cIdV >= 0. && cIdV < 2. * nFlr) {\n       d = min (GObjDf (p - vec3 (0., bSizeV * (cIdV + 0.5), 0.)), d);\n    }\n    dHit += d;\n    if (d < eps || dHit > dstFar || p.y < 0.) break;\n  }\n  if (d >= eps || p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 GObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  cIdV = floor (p.y / bSizeV);\n  p.y -= bSizeV * (cIdV + 0.5);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = GObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, r, wz, h;\n  int idb;\n  dMin = dstFar;\n  p.y -= bSizeV * (nFlr - 0.5);\n  p /= twrScl;\n  h = bSizeV * (nFlr - 0.5) / twrScl;\n  q = p;\n  r = length (q.xz) - twrRad;\n  q.y -= 1.3 * flSpc + h;\n  q.xz = Rot2D (q.xz, 2. * pi * ((floor (3. * atan (q.z, - q.x) / (2. * pi)) + 0.5) / 3.));\n  d = dot (vec2 (q.x, abs (q.z)), sin (0.09 * pi + vec2 (0., 0.5 * pi)));\n  q.x = r + szFlr.z + 5.;\n  d = max (d, length (max (abs (q.xy) - vec2 (2.1, 0.3 * flSpc), 0.)) - 0.02);\n  DMINQ (idRfEx);\n  q = p;\n  q.y -= 0.25 * flSpc - h;\n  q.xz = Rot2D (q.xz, 2. * pi * ((floor (3. * atan (q.z, - q.x) / (2. * pi)) + 0.5) / 3.));\n  wz = q.z;\n  d = abs (abs (q.z) - 18.) - 5.;\n  q.x = r + szFlr.z + 1.3;\n  d = max (d, length (max (abs (q.xy) - vec2 (2.9, 0.3 * flSpc), 0.)) - 0.02);\n  DMINQ (idGrEx);\n  q = p;\n  q.y -= 0.4 * flSpc - h;\n  d = max (length (max (abs (vec2 (r - 2. * szFlr.z - 15., q.y)) -\n     vec2 (0.5, 0.4 * flSpc), 0.)) - 0.02, 0.2 - length (max (abs (vec2 (abs (wz) - 40., q.y)) -\n     vec2 (4., 0.3 * flSpc), 0.))); \n  DMINQ (idWall);\n  return twrScl * dMin;\n}\n\nvec4 SphHit (vec3 ro, vec3 rd, float r)\n{\n  vec3 vn;\n  float b, d, w, dMin;\n  dMin = dstFar;\n  b = dot (rd, ro);\n  w = b * b - dot (ro, ro) + r * r;\n  if (w > 0.) {\n    d = - b - sqrt (w);\n    if (d > 0.) {\n      dMin = d;\n      vn = (ro + d * rd) / r;\n    }\n  }\n  return vec4 (dMin, vn);\n}\n\nvec4 CapsHit (vec3 ro, vec3 rd, float r, float h)\n{\n  vec3 s, vn;\n  vec2 e;\n  e = vec2 (-1., 1.);\n  float dMin, d, a, b, w, drz;\n  dMin = dstFar;\n  ro.yz = ro.zy * e;\n  rd.yz = rd.zy * e;\n  a = dot (rd.xy, rd.xy);\n  b = dot (rd.xy, ro.xy);\n  w = b * b - a * (dot (ro.xy, ro.xy) - r * r);\n  if (w > 0.) {\n    d = - b - sqrt (w);\n    d /= max (a, 1e-6);\n    s = ro + d * rd;\n    if (d > 0. && abs (s.z) < h) {\n      dMin = d;\n      vn = vec3 (s.xy, 0.);\n    } else {\n      drz = - h * sign (s.z);\n      ro.z += drz;\n      b = dot (rd, ro);\n      w = b * b - (dot (ro, ro) - r * r);\n      if (w > 0.) {\n        d = - b - sqrt (w);\n        if (d > 0.) {\n          dMin = d;\n          vn = ro + d * rd;\n        }\n      }        \n    }\n  }\n  vn.yz = - vn.zy * e;\n  return vec4 (dMin, vn);\n}\n\nvoid PathVerts ()\n{\n  pvU[0] = vec3 (4., - flSpc, 5.);\n  pvU[1] = vec3 (-14., - flSpc, -2. * szFlr.z - 5.);\n  pvU[2] = vec3 (4., 0., - szFlr.z - 5.);\n  pvU[3] = vec3 (-4., 0., szFlr.z + 5.);\n  for (int k = 0; k < 4; k ++) pvU[k] += vec3 (1., 0., - twrRad);\n  pvU[4] = pvU[0];\n  pvU[2].xz = Rot2D (pvU[2].xz, - pi / 6.);\n  pvU[3].xz = Rot2D (pvU[3].xz, - pi / 6.);\n  pvU[4].xz = Rot2D (pvU[4].xz, - 2. * pi / 6.);\n  pvU[4].y += 2. * flSpc;\n  pvD[0] = vec3 (14., flSpc, -2. * szFlr.z - 5.);\n  pvD[1] = vec3 (-4., flSpc, 5.);\n  pvD[2] = vec3 (4., 0., szFlr.z + 5.);\n  pvD[3] = vec3 (-4., 0., - szFlr.z - 5.);\n  for (int k = 0; k < 4; k ++) pvD[k] += vec3 (-1., 0., - twrRad);\n  pvD[4] = pvD[0];\n  pvD[2].xz = Rot2D (pvD[2].xz, - pi / 6.);\n  pvD[3].xz = Rot2D (pvD[3].xz, - pi / 6.);\n  pvD[4].xz = Rot2D (pvD[4].xz, - 2. * pi / 6.);\n  pvD[4].y -= 2. * flSpc;\n}\n\nvec4 MovObjHit (vec3 ro, vec3 rd)\n{\n  vec4 dc4;\n  vec3 s[5], s1, s2, ss, vn;\n  float dMin, d, r, t, h, iDir;\n  int idb, iUD;\n  dMin = dstFar;\n  h = bSizeV * (nFlr - 0.5);\n  ro.y -= h;\n  h += 0.5 * flSpc * twrScl;\n  iDir = 1.;\n  for (float iMul = 0.; iMul < 6.; iMul ++) {\n    iDir = 1. - iDir;\n    idb = (iDir == 0.) ? idMovBU : idMovBD;\n    for (int j = 0; j < 5; j ++) s[j] = (iDir == 0.) ? pvU[j] : pvD[j];\n    t = fract (0.3 * tCur + 0.5 * iDir);\n    r = 2. * t - 0.5 * (sign (t - 0.5) + 1.);\n    for (int iSec = 0; iSec < 6; iSec ++) {\n      s1 = (t < 0.5) ? mix (s[0], s[1], r) : mix (s[1], s[2], r);\n      s2 = (t < 0.5) ? mix (s[2], s[3], r) : mix (s[3], s[4], r);\n      iUD = 1;\n      for (float iRep = 0.; iRep < 6.; iRep ++) {\n        iUD = 1 - iUD;\n        ss = (iUD == 0) ? s1 : s2;\n        ss.y += (4. - 12. * mod (iRep, 3.) + 4. * mod (iMul, 3.)) * flSpc *\n           sign (0.5 - iDir) + 2.9;\n        dc4 = CapsHit (ro - ss * twrScl, rd, 1.2 * twrScl, 1.5 * twrScl);\n        if (dc4.x < dMin && abs (ro.y + dc4.x * rd.y - flSpc * twrScl + 3.8 * twrScl) <\n           h + 3.8 * twrScl) {\n          dMin = dc4.x;\n          vn = dc4.yzw;\n          idObj = idb;\n        }\n        ss.y += 3.7;\n        dc4 = SphHit (ro - ss * twrScl, rd, 1.1 * twrScl);\n        if (dc4.x < dMin && abs (ro.y + dc4.x * rd.y - flSpc * twrScl + 3.8 * twrScl) <\n           h + 3.8 * twrScl) {\n          dMin = dc4.x;\n          vn = dc4.yzw;\n          idObj = idb + 1;\n        }\n      }\n      for (int j = 0; j < 5; j ++) {\n        s[j].xz = Rot2D (s[j].xz, - 2. * pi / 6.);\n        s[j].y += 2. * flSpc * sign (0.5 - iDir);\n      }\n    }\n  }\n  return vec4 (dMin, normalize (vn));\n}\n\nfloat ObjAO (vec3 p)\n{\n  vec3 q, w, s[5], s1, s2;\n  float d, r, t, iDir;\n  int iUD;\n  d = dstFar;\n  p.y -= bSizeV * (nFlr - 0.5);\n  p /= twrScl;\n  iDir = 1.;\n  for (float iMul = 0.; iMul < 6.; iMul ++) {\n    iDir = 1. - iDir;\n    q.xz = p.xz;\n    for (int j = 0; j < 5; j ++) s[j] = (iDir == 0.) ? pvU[j] : pvD[j];\n    t = fract (0.3 * tCur + 0.5 * iDir);\n    r = 2. * t - 0.5 * (sign (t - 0.5) + 1.);\n    for (int iSec = 0; iSec < 6; iSec ++) {\n      s1 = (t < 0.5) ? mix (s[0], s[1], r) : mix (s[1], s[2], r);\n      s2 = (t < 0.5) ? mix (s[2], s[3], r) : mix (s[3], s[4], r);\n      iUD = 1;\n      for (float iRep = 0.; iRep < 6.; iRep ++) {\n        iUD = 1 - iUD;\n        q.y = p.y - (4. - 12. * mod (iRep, 3.) + 4. * mod (iMul, 3.)) * flSpc * sign (0.5 - iDir);\n        q.y -= 3.;\n        w = q - ((iUD == 0) ? s1 : s2);\n        if (abs (w.y) < 4.) d = min (d, length (w.xz));\n      }\n      for (int j = 0; j < 5; j ++) {\n        s[j].xz = Rot2D (s[j].xz, - 2. * pi / 6.);\n        s[j].y += 2. * flSpc * sign (0.5 - iDir);\n      }\n    }\n  }\n  return 0.6 + 0.4 * smoothstep (1.3, 2.6, d);\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 60; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    if (d < 0.0002 || dHit > dstFar || p.y < 0.) break;\n    dHit += d;\n  }\n  if (p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec4 ObjCol (vec3 ro, vec3 vn)\n{\n  vec4 col4;\n  if (idObj == idFlr) {\n    col4 = vec4 (0.5, 0.2, 0., 0.1);\n    if (vn.y > 0.99) col4 *= 0.8 + 0.2 * smoothstep (0., 0.02,\n       abs (mod (0.25 * length (ro.xz) / twrScl + 0.5, 1.) - 0.5) - 0.07);\n  } else if (idObj == idStr) {\n    col4 = vec4 (0.6, 0.3, 0.1, 0.1);\n  } else if (idObj == idRl) {\n    col4 = vec4 (0.9, 0.9, 1., 0.2);\n  } else if (idObj == idStn) {\n    col4 = vec4 (0.8, 0.8, 1., 0.2);\n  } else if (idObj == idCln) {\n    col4 = vec4 (1., 0., 1., 0.2) * (0.8 + 0.2 * smoothstep (0., 0.02, abs (mod (ro.y / twrScl +\n       0.5, 1.) - 0.5) - 0.07));\n  } else if (idObj == idMovBU) {\n    col4 = vec4 (0.8, 0.8, 0., 0.2);\n  } else if (idObj == idMovHU) {\n    col4 = vec4 (0.8, 0.8, 0., -1.);\n  } else if (idObj == idMovBD) {\n    col4 = vec4 (0., 0.8, 0.8, 0.2);\n  } else if (idObj == idMovHD) {\n    col4 = vec4 (0., 0.8, 0.8, -1.);\n  } else if (idObj == idWall) {\n    col4 = vec4 (0.8, 0.4, 0.2, 0.) * (0.8 + 0.2 * smoothstep (0., 0.02, \n       abs (mod (64. * atan (qHit.z, - qHit.x) / pi + 0.5, 1.) - 0.5) - 0.05));\n  } else if (idObj == idRfEx) {\n    col4 = vec4 (0.8, 0.5, 0.3, 0.1) * (0.8 + 0.2 * smoothstep (0., 0.02, abs (mod (qHit.y +\n       0.5, 1.) - 0.5) - 0.07));\n    if (abs (qHit.y + 0.6) < 4.1 && qHit.x > 0. && abs (abs (qHit.z) - 2.6) < 1.7)\n       col4 = (qHit.z > 0.) ? vec4 (0.6, 0.6, 0., -1.) : vec4 (0., 0.6, 0.6, -1.);\n  } else if (idObj == idGrEx) {\n    col4 = vec4 (0.8, 0.5, 0.3, 0.1) * (0.8 + 0.2 * smoothstep (0., 0.02, abs (mod (qHit.y +\n       0.5, 1.) - 0.5) - 0.07));\n    if (abs (qHit.y + 0.6) < 4.1 && abs (qHit.z) - 18. > 0. && abs (qHit.x) < 1.7)\n       col4 = (qHit.z > 0.) ? vec4 (0.6, 0.6, 0., -1.) : vec4 (0., 0.6, 0.6, -1.);\n  }\n  return col4;\n}\n\nvec3 GrndNf (vec2 p)\n{\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  return vec3 (normalize (vec3 (Fbm2 (p) - vec2 (Fbm2 (p + e.xy),\n     Fbm2 (p + e.yx)), 4. * e.x)).xzy);\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol;\n  vec2 q;\n  float f, fd, ff;\n  if (rd.y > -0.02 && rd.y < 0.02 * (0.1 + 0.9 * IFbm1 (32. * atan (rd.z, - rd.x) / pi))) {\n    col = 0.8 * vec3 (0.35, 0.4, 0.5);\n  } else {\n    q = 0.01 * (ro.xz + 2. * tCur + ((200. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * ltDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    col = mix (vec3 (0.3, 0.4, 0.8), clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, dc4;\n  vec3 col, vn;\n  float dstObj, dstObjG, dstObjM, s;\n  int idObjG, idObjM;\n  PathVerts ();\n  dstObjG = GObjRay (ro, rd);\n  idObjG = idObj;\n  dc4 = MovObjHit (ro, rd);\n  dstObjM = dc4.x;\n  idObjM = idObj;\n  dstObj = ObjRay (ro, rd);\n  if (min (dstObj, min (dstObjM, dstObjG))  < dstFar) {\n    if (dstObj < min (dstObjM, dstObjG)) {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n    } else if (dstObjG < dstObjM) {\n      dstObj = dstObjG;\n      idObj = idObjG;\n      ro += dstObj * rd;\n      vn = GObjNf (ro);\n    } else {\n      dstObj = dstObjM;\n      idObj = idObjM;\n      ro += dstObj * rd;\n      vn = dc4.yzw;\n    }\n    col4 = ObjCol (ro, vn);\n    if ((idObj == idFlr || idObj == idStr) && vn.y > 0.) col4.rgb *= ObjAO (ro);\n    if (col4.a >= 0.) col = col4.rgb * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +\n       col4.a * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.);\n    else col = col4.rgb * (0.6 - 0.4 * dot (vn, rd));\n  } else if (rd.y < 0.) {\n    ro += (- ro.y / rd.y) * rd;\n    s = length (ro.xz);\n    if (s < (twrRad + 2. * szFlr.z + 15.) * twrScl) {\n      col = vec3 (0.2, 0.3, 0.2) * (0.7 + 0.3 * Fbm2 (4. * ro.xz));\n    } else {\n      vn = GrndNf (0.5 * ro.xz);\n      col = (0.4 * mix (vec3 (0.8, 1., 0.5), vec3 (0.7, 0.9, 0.5), 0.2 +\n         0.8 * smoothstep (0.3, 0.7, Fbm2 (4. * ro.xz)))) *\n         (0.2 + 0.8 * max (dot (vn, ltDir), 0.));\n      col *= 0.7 + 0.3 * smoothstep (0., 0.5, s - 9.3);\n      col = mix (col, 0.8 * vec3 (0.35, 0.4, 0.5), pow (1. + rd.y, 16.));\n    }\n    col *= 0.7 + 0.3 * smoothstep (0., 2., abs (s - (twrRad + 2. * szFlr.z + 15.) * twrScl));\n  } else {\n    col = SkyBgCol (ro, rd);\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define AA  0   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr, t;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  twrScl = 0.3;\n  szFlr = vec4 (14., 8.5, 4., 0.5);\n  flSpc = 2. * szFlr.y - szFlr.w;\n  nFlr = 4.;\n  twrRad = 60.;\n  bSizeV = 2. * flSpc * twrScl;\n  az = 0.;\n  el = -0.05 * pi;\n  ro = vec3 (0., 1.9 * flSpc * nFlr * twrScl, -120.);\n  if (mPtr.z > 0.) {\n    az -= 2. * pi * mPtr.x;\n    ro.y += 1.9 * 2. * flSpc * nFlr * twrScl * mPtr.y;\n  } else {\n    az += 0.05 * pi * tCur;\n    ro.y += 1.8 * flSpc * nFlr * twrScl * (2. * SmoothBump (0.25, 0.75, 0.22,\n       mod (0.022 * tCur, 1.)) - 1.);\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * ro;\n  zmFac = 2.2 / (1. - 0.85 * abs (mod (az + pi, 2. * pi) - pi) / pi);\n  dstFar = 150.;\n  ltDir = vuMat * normalize (vec3 (0.5, 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat IFbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 10.;\n  for (int j = 0; j < 3; j ++) {\n    f += floor (a * Noiseff (p));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / (1.75 * a));\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdGXDD.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[191, 1085, 1108, 1108, 4183], [4185, 4185, 4219, 4219, 4750], [4752, 4752, 4774, 4774, 5093], [5095, 5095, 5117, 5117, 6199], [6201, 6201, 6242, 6242, 6491], [6493, 6493, 6544, 6544, 7277], [7279, 7279, 7298, 7298, 8135], [8137, 8137, 8172, 8172, 9806], [9808, 9808, 9830, 9830, 10900], [10902, 10902, 10935, 10935, 11182], [11184, 11184, 11205, 11205, 11460], [11462, 11462, 11494, 11494, 13206], [13208, 13208, 13230, 13230, 13371], [13373, 13373, 13407, 13407, 14022], [14024, 14024, 14059, 14059, 15748], [15792, 15792, 15848, 15848, 17239], [17241, 17241, 17284, 17284, 17348], [17350, 17350, 17407, 17407, 17490], [17492, 17492, 17528, 17528, 17734], [17736, 17736, 17766, 17766, 17879], [17913, 17913, 17937, 17937, 17990], [17992, 17992, 18016, 18016, 18128], [18130, 18130, 18155, 18155, 18301], [18303, 18303, 18328, 18328, 18514], [18516, 18516, 18539, 18539, 18706], [18708, 18708, 18729, 18729, 18884]]}
{"id": "NdGXDt", "name": "concentric extrusion", "author": "do", "description": "extrusion", "tags": ["extrusion"], "likes": 8, "viewed": 93, "published": "Public", "date": "1635462873", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//concentric extrusion\n//2021\n//do\n\nconst int steps = 250;\nfloat eps = 0.001;\nfloat dmin = 0.;\nfloat dmax = 750.;\nconst int aa = 2;\n\nconst int octaves = 5;\nfloat hurst = 0.5;\n\nconst int seed = 123457;\n\nfloat h11(float p) {\n    uvec2 n = uint(int(p)) * uvec2(uint(int(seed)),2531151992.0);\n    uint h = (n.x ^ n.y) * uint(int(seed));\n    return float(h) * (1./float(0xffffffffU));\n}\n\nfloat h21(vec2 p) {\n    uvec2 n = uvec2(ivec2(p)) * uvec2(uint(int(seed)),2531151992.0);\n    uint h = (n.x ^ n.y) * uint(int(seed));\n    return float(h) * (1./float(0xffffffffU));\n}\n\nfloat n2(vec2 x) { \n\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f * f * (3.0 - 2.0 * f);  \n    float n = p.x + p.y * 57.;  \n\n    return mix(mix(h11(n+0.),h11(n+1.),f.x),\n               mix(h11(n+57.),h11(n+58.),f.x),f.y);  \n}\n\nfloat f2(vec2 x) {\n\n    float s = 0.;\n    float h = exp2(-hurst);     \n    float f = 1.;\n    float a = 0.5;\n\n    for(int i = 1; i < octaves; i++) {\n \n        s += a * n2(f * x);\n        f *= 2.;\n        a *= h;\n    }    \n\n    return s;\n}\n\nmat2 rot(float a) {\n\n    float c = cos(a);\n    float s = sin(a);\n    \n    return mat2(c,-s,s,c);\n}\n \nmat3 camOrthographic(vec3 ro,vec3 ta,float r) {\n     \n     vec3 w = normalize(ta - ro); \n     vec3 p = vec3(sin(r),cos(r),0.);           \n     vec3 u = normalize(cross(w,p)); \n     vec3 v = normalize(cross(u,w));\n\n     return mat3(u,v,w); \n} \n\nvec2 opu(vec2 d1,vec2 d2) {\n    return (d1.x < d2.x) ? d1 : d2;\n} \n\nfloat extr(vec3 p,float d,float h) {\n    vec2 w = vec2(d,abs(p.z) - h);\n    return min(max(w.x,w.y),0.) + length(max(w,0.));\n}\n\nfloat sdif(float d1,float d2,float k) {\n    float h = clamp(.5-.5*(d2+d1)/k,0.,1.);\n    return mix(d2,-d1,h) +k*h +(1.-h);\n}\n\nvec2 scene(vec3 p) {\n\n    vec2 res = vec2(1.,0.);\n\n    float d = 0.;\n\n    d = extr(p,sin(length(p.xy)*3.),1.5);\n    res = opu(res,vec2(sdif(d,p.z,.5)*.5,2.));  \n    return res;\n\n}\n\nvec2 rayScene(vec3 ro,vec3 rd) {\n    \n    float d = -1.0;\n    float s = dmin;\n    float e = dmax;  \n\n    for(int i = 0; i < steps; i++) {\n\n        vec3 p = ro + s * rd;\n        vec2 dist = scene(p);\n   \n        if(abs(dist.x) < eps || e <  dist.x ) { break; }\n        s += dist.x;\n        d = dist.y;\n\n        }\n \n        if(e < s) { d = -1.0; }\n        return vec2(s,d);\n\n}\n\nfloat shadow(vec3 ro,vec3 rd) {\n\n    float res = 1.0;\n    float t = 0.005;\n    float ph = 1e10;\n    \n    for(int i = 0; i < 95; i++ ) {\n        \n        float h = scene(ro + rd * t  ).x;\n\n        float y = h * h / (2. * ph);\n        float d = sqrt(h*h-y*y);         \n        res = min(res,125. * d/max(0.,t-y));\n        ph = h;\n        t += h;\n    \n        if(res < eps || t > 5.) { break; }\n\n        }\n\n        return clamp(res,0.0,1.0);\n\n}\n\nvec3 calcNormal(vec3 p) {\n\n    vec2 e = vec2(1.0,-1.0) * eps;\n\n    return normalize(vec3(\n    vec3(e.x,e.y,e.y) * scene(p + vec3(e.x,e.y,e.y)).x +\n    vec3(e.y,e.x,e.y) * scene(p + vec3(e.y,e.x,e.y)).x +\n    vec3(e.y,e.y,e.x) * scene(p + vec3(e.y,e.y,e.x)).x + \n    vec3(e.x,e.x,e.x) * scene(p + vec3(e.x,e.x,e.x)).x\n\n    ));\n    \n}\n\nvec3 renderScene(vec3 ro,vec3 rd) {\n \nvec2 d = rayScene(ro, rd);\n\nvec3 col = vec3(1.);\n\nif(d.y >= 0.) {\n\nvec3 p = ro + rd * d.x;\nvec3 n = calcNormal(p);\nvec3 l = normalize(vec3(10.));\n\nvec3 h = normalize(l - rd);\nvec3 r = reflect(rd,n);\n\ncol += vec3(f2(p.xz+f2(p.yx*3.)*5.));\n\nfloat amb = clamp(0.5 + 0.5 * n.y,0.,1.);\n\nfloat dif = clamp(dot(n,l),0.0,1.0);\n\nfloat fre = pow(clamp(1. + dot(n,rd),0.0,1.0),2.0);\nfloat ref = smoothstep(-.2,.2,r.y);\n\nvec3 linear = vec3(0.);\n \ndif *= shadow(p,l);\nref *= shadow(p,r);\n\nlinear += dif * vec3(.5);\nlinear += amb * vec3(0.01,0.05,0.05);\n\ncol = col * linear;\ncol = mix(col,vec3(1.),1.-exp(-0.00001 *d.x*d.x*d.x)); \n\n}\n\nreturn col;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord) {\n \nvec3 color = vec3(0.);\nvec3 ro = vec3(10.,10.,15.);\nvec3 ta = vec3(0.0);\n\nro.xy *= rot(iTime*.1);\n\nfor(int k = 0; k < aa; ++k) {\n    for(int l = 0; l < aa; ++l) {\n\n    vec2 o = vec2(float(l),float(k)) / float(aa) - .5;\n\n    vec2 uv = (2. * (fragCoord.xy + o) -\n    iResolution.xy) / iResolution.y; \n\n    mat3 cm = camOrthographic(ro,ta,0.);\n    vec3 rd = cm * normalize(vec3(uv.xy,2.));\n\n    vec3 col = renderScene(ro,rd);    \n\n    col = pow(col,vec3(.4545));\n    color += col;\n    }\n}\n\ncolor /= float(aa*aa);\nfragColor = vec4(color,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdGXDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 202, 222, 222, 381], [383, 383, 402, 402, 564], [566, 566, 584, 584, 803], [805, 805, 823, 823, 1042], [1044, 1044, 1063, 1063, 1142], [1145, 1145, 1192, 1192, 1386], [1389, 1389, 1416, 1416, 1454], [1457, 1457, 1493, 1493, 1583], [1585, 1585, 1624, 1624, 1709], [1711, 1711, 1731, 1731, 1890], [1892, 1892, 1924, 1924, 2266], [2268, 2268, 2299, 2299, 2709], [2711, 2711, 2736, 2736, 3043], [3045, 3045, 3080, 3080, 3717], [3719, 3719, 3773, 3773, 4317]]}
{"id": "NdGXDy", "name": "InScatter", "author": "shivaduke28", "description": "ref: https://blog.mmacklin.com/2010/06/10/faster-fog/", "tags": ["raymarching", "fog"], "likes": 20, "viewed": 178, "published": "Public", "date": "1635183067", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision highp float;\nconst float PI=3.141592;\n\nmat2 rot(float t){\n  return mat2(cos(t),-sin(t),sin(t),cos(t));\n}\n\nfloat sphere(vec3 p){\n  p.xz=mod(p.xz, 4.)-2.;\n  return length(p-vec3(0.,1.,0))-1.;\n}\n\nfloat plane(vec3 p){\n  return p.y;\n}\n\nfloat map(vec3 p){\n  return min(sphere(p),plane(p));\n}\n\nvec3 normal(vec3 p){\n  vec2 e=vec2(1,0)*0.01;\n  return normalize(vec3(\n    map(p+e.xyy)-map(p-e.xyy),\n    map(p+e.yxy)-map(p-e.yxy),\n    map(p+e.yyx)-map(p-e.yyx)\n    ));\n}\n\n// https://blog.mmacklin.com/2010/06/10/faster-fog/\nfloat InScatter(vec3 start, vec3 dir, vec3 lightPos, float d)\n{\n   vec3 q = start - lightPos;\n   float b = dot(dir, q);\n   float c = dot(q, q);\n   float s = 1.0 / max(0.001,sqrt(c - b*b));\n   float x = d*s;\n   float y = b*s;\n   float l = s * atan(x/max(0.001,1.+(x+y)*y));\n   return l;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 st = (fragCoord.xy - iResolution.xy * 0.5)/min(iResolution.x,iResolution.y);\n  vec3 col;\n  vec3 cam=vec3(0,4,0);\n  cam.z += iTime;\n  vec3 ray=cam;\n  vec3 dir=normalize(vec3(st,.5));\n  dir.yz *= rot(0.3);\n\n  vec3 lightpos = vec3(0,8,-4);\n  lightpos.xz *= rot(iTime);\n  lightpos.z += cam.z+16.;\n\n  float totald=0.;\n  for(int i=0;i<128;i++)\n  {\n    float d = map(ray);\n    if (d<0.001)\n    {\n      vec3 n=normal(ray);\n      vec3 l=normalize(lightpos-ray);\n      float lightDist = length(lightpos-ray);\n      vec3 lightColor = vec3(1,1,1)/(lightDist*lightDist)*10.;\n      col=lightColor*max(0.,dot(n,l));\n      float ocr=.6;\n      float oc=max(0.,1.-map(ray+l*ocr)/ocr);\n      oc=exp(-2.*pow(oc,2.));\n      col*=oc;\n      break;\n    }\n    totald+=d;\n    ray += dir*d;\n  }\n\n  float s = InScatter(cam, dir, lightpos,totald);\n  float fog=0.01;\n  col*=exp(-totald*fog);\n  col+= s;\n  fragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdGXDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 67, 67, 114], [116, 116, 137, 137, 201], [203, 203, 223, 223, 239], [241, 241, 259, 259, 295], [297, 297, 317, 317, 469], [471, 523, 586, 586, 810], [813, 813, 870, 870, 1779]]}
{"id": "NdGXR3", "name": "RGB-Tunnel III", "author": "turboplay", "description": "A variant of https://www.shadertoy.com/view/7dGXzK and https://www.shadertoy.com/view/7syXzV\n", "tags": ["simple", "tunnel", "short", "tweet", "golf"], "likes": 1, "viewed": 131, "published": "Public API", "date": "1634974953", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvoid mainImage(out vec4 o, vec2 u){\n   o += length(u= u/iResolution.x-0.25) - o;\n   o *= 4. / exp(6.*fract(atan(u.xyxx, u.xxyx)/0.393 - .2/o - iTime));\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdGXR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 36, 36, 154]]}
{"id": "NdGXWh", "name": "Octree Lightly Styld [Commented]", "author": "Yusef28", "description": "Still fairly barebones. No shadow, ambient occlusion or bump mapping going on here.\nMore issues arose while implementing the lighting so that is explained in comments at the top of the shader.\nBasic Commented version: https://www.shadertoy.com/view/fdyXDR", "tags": ["3d", "raycasting", "voxel", "quadtree", "octree"], "likes": 24, "viewed": 301, "published": "Public API", "date": "1634534596", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//////////////////////////////////////////////////////\n// Simplified Octree By Yusef28\n// Purpose: Demonstrates A simplified Octree Shader Implentation\n// Well commented and fit for some educational purposes\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n/*\n\n//Based on my basic version: https://www.shadertoy.com/view/fdyXDR\n\nNotably, the first octree shaders I stumbled on were from abje\nalthough it seems they are using a different approach.\nHere is the main one: https://www.shadertoy.com/view/4sVfWw\nHere is one with lighting and shadow: https://www.shadertoy.com/view/XdyfRy\n\nMy version is \"stackless\" there is no bidiretional movement\nbetween levels of the tree. We always start at the top and\nwe get spit out somewhere along the way down. \n\nSo for each step in our traversal we have to jump into the tree\nfrom the top again and work down to get the next cell scale factor.\n\nWith a stack and with bidirectional movement I'm guessing\nyou don't have to leave the tree between steps, you just swing\nfrom vine to vine. Not completely sure yet though.\n\n\nIssues I ran into while writing this where I had to just\nuse intuition and play around with things until things worked out\n\nInitially:\nI found the ray origin needed to be shifter by epsilon\nto avoid really bad artifacts\n\nCurrently:\nI found the t value returned from tCalc() need to have epsilon\nadded to it to avoid really bad artifacts\n\nCurrently:\nthe value FAR needs to be atleast 100 or we get some\nweird cloud things that arn't clouds at all.\n\nFixed:\nI needed a way to create a hole where the camera would \nbe with out any octree cells being rendered and\n\nFixed:\nI had to grab the normal backwards to avoid the ray \"catching\"\nmore than one level of cells which was showing up as all the levels\nbeing displayed for some blocks.\n\nso what I do is I step from the position a tiny bit in the ray direction\nso I am inside the box we hit. No confusion this way. Then I need\nto get the normal from inside,  so I pass in negative ray direction\nand calcN will find the closest wall on the way back towards us.\nIt uses that wall as the normal. So I jut flip the sign of the normal \nwhen I return it.\n\nvec3 n = -calcN(pos+rd*0.001, -rd, delta);\n\n\n\n*/\n\n\n#define pi acos(-1.)\n#define eps 1./iResolution.y\n#define MAX_LEVEL 8.\n#define FAR 100.\n\nmat2 rot(float a){\n    float c = cos(a), s = sin(a); return mat2(c,-s,s,c);}\n    \n\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3 = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n\n// SHORTER, NEATER, BRANCHLESS, UNIQUE, SINGULAR PURPOSE\n// This map function returns the largest scaling factor for a given posision\n// the inverse of that is the cell size\nfloat mapQ(vec3 p){\n  float s = 0.5;\n  for(float i = 1.; i < MAX_LEVEL; i++){\n    s *= 2.;\n    \n    //if we don't pass the random check, add max to index so we break\n    i += step( hash13(floor(p * s)), 0.5 ) * MAX_LEVEL;\n  }\n  return s;\n}\n\n\nvec2 rotate2d(vec2 v, float a) {\n\tfloat sinA = sin(a);\n\tfloat cosA = cos(a);\n\treturn vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA);\t\n}\n\n\n//This get's the distance to the nearest axis [at a given cellsize]\n//This is the main thing and I use it for traversing and for \n//getting the normal\n//The basic idea is well explained in the lodev raycasting tutorial\n//and my version explained in mmy quadtree examples are just\n//a modification of that to allow for traversing different scales.\nvec3 get_t_options(vec3 p, vec3 rd, vec3 delta, float s){\n    \n    vec3 t;\n    \n    t.x = rd.x < 0. ? ((p.x*s - floor(p.x*s))/s)*delta.x\n                    : ((ceil(p.x*s) - p.x*s)/s)*delta.x; \n                    \n    t.y = rd.y < 0. ? ((p.y*s - floor(p.y*s))/s)*delta.y\n                    : ((ceil(p.y*s) - p.y*s)/s)*delta.y; \n    \n    t.z = rd.z < 0. ? ((p.z*s - floor(p.z*s))/s)*delta.z\n                    : ((ceil(p.z*s) - p.z*s)/s)*delta.z; \n    return t;\n}\n\nfloat calcT(vec3 p, vec3 rd, vec3 delta){\n    float s = mapQ(p);\n    vec3 t = get_t_options(p,rd,delta,s);\n\n                    //+0.01 to get rid of a bunch of artifacts\n    return min(t.x,min(t.y,t.z))+0.01/s;\n}\n\nvec3 calcN(vec3 p, vec3 rd, vec3 delta){\n    float s = mapQ(p);\n    vec3 t = get_t_options(p,rd,delta,s);\n    vec3 n;\n             \n    if(t.x<t.y && t.x<t.z) n = vec3(1.,0.,0.)*sign(rd.x);\n    else if(t.y<t.x && t.y<t.z) n = vec3(0.,1.,0.)*sign(rd.y);\n    else n = vec3(0.,0.,1.)*sign(rd.z);\n \n    return n;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    vec3 co = vec3(0., iTime/6.,0.);\n    vec3 cd = vec3(0.,0.,1.);\n\n    vec3 up = vec3(0.,1.,0.);\n    vec3 right = normalize(cross(up,cd));\n    up = cross(cd,right);\n    vec3 ro = co;\n    vec3 rd = right*uv.x + up*uv.y + cd;\n    rd = normalize(rd);\n    \n    \n    rd.xz *= rot(iTime/6.);\n    \n\tvec3 delta = 1./max(abs(rd), eps);\n    float t = 0.;\n\n    vec3 pos;\n    for(float i = 0.; i < FAR; i++){\n        pos = ro + rd * t;\n        float ss = mapQ(pos);\n\n        //create the hole / shield so blocks stop\n        //hitting me in the face\n        vec3 shi = abs(floor(pos-ro)) - 1.0;\n        //the hole. Basically a vertical rectangular/square tunnel\n        float hole = max( shi.x, shi.z);\n        \n        //check the hole AND check the random missing squares\n        //if we are out of the hole AND not hitting a missint square\n        //then break!\n        if(hole > 0.001 && hash13(floor((pos)*ss)) > .4) break;\n        \n        //calcT\n        t += calcT(pos, rd, delta);\n    }\n    \n    //calc normal\n    //t += calcT(pos, rd, delta);\n    pos = ro + rd * t;\n    vec3 n = -calcN(pos+rd*0.0001, -rd, delta);\n    vec3 light = co+vec3(0.3);\n    \n    vec3 ld = normalize(light-pos);\n    float diff = max(dot(ld,-n),0.);\n    \n    //This is the scale of the cell in the octree. \n    //No reason it was named sss really.\n    float sss = mapQ(ro+rd*t);\n    \n    //getting an random id for each cell requires knowing it's scale\n    //and throwing the floor of the scaled position into  a hash.\n    float endID = hash13(floor((pos)*sss));\n    //This pallet has become my go to.\n    vec3 cellColor = 0.5+0.5*cos(vec3(1.,2.,4.)/2. + endID*800.);\n    //again to get the fract component of the cell I need to\n    //get the fract of the scaled position. I use abs\n    //so I can cut out squares. And a nice side effect is the texture\n    //calls end up with a sort of converging to center thing.\n    vec3 CF = abs(fract(pos*sss)-0.5)-0.26;\n    \n    //f is a soft border that will simply be shaded darker/lighter\n    //I use the normal to find the components for the texture\n    //which need to be the two components orthonormal to the normal\n    float f = abs(n.x) > 0.5 ? max(CF.y,CF.z) \n            : abs(n.y) > 0.5 ? max(CF.x,CF.z) \n            : max(CF.x,CF.y);\n            \n    float k = smoothstep(0.1,0.4,abs(fract(f*14.)-0.5))/12.;\n    //hackity hack hack\n    f = 1.-f;        \n    f = 1.-smoothstep(0.7,0.9,f);\n    \n    //a hard border that will be gold, based on f\n    float g = smoothstep(0.6,0.64,f);\n    //and perhaps a shador of that border for just underneath?\n    float gshat = smoothstep(0.53,0.64,f);\n    \n    //adjusting specular based on if it's hitting a border which\n    //I want to shine more\n    float spec = pow(max(dot(reflect(-ld,-n), -rd),0.), 2. + (1.-g)*20.);\n    \n    //using the same thing as above, getting the components ortho\n    //to the normal for texture calls.\n    vec3 tex = abs(n.x) > 0.5 ? texture(iChannel0,CF.yz).rgb \n            : abs(n.y) > 0.5 ? texture(iChannel0,CF.xz).rgb \n            : texture(iChannel0,CF.xy).rgb ;\n            \n    vec3 tex2 = abs(n.x) > 0.5 ? texture(iChannel1,CF.yz).rgb \n            : abs(n.y) > 0.5 ? texture(iChannel1,CF.xz).rgb \n            : texture(iChannel1,CF.xy).rgb ;  \n            \n    vec3 rdRefl = reflect(rd, n);\n    //vec3 reflCol = texture(iChannel0,rd).xyz;\n    \n    \n    //adding diffuse lighting with cell color minus f which shades the \n    //outside lightly\n    vec3 col = diff*tex.x*(cellColor+0.2)-f/6.;// + reflCol*0.2;\n    //gshat is the shadow right under the border\n    col = mix(col, vec3(0.), gshat);\n    //g is border, with a texture for a bit more life\n    col = mix(col, vec3(0.8, 0.5, 0.1)/2.-tex2.x/3., g);\n    //add specular at end for the shine\n    col += vec3(.5)*spec + spec*g;// + spec*(k-g/6.)*4.;\n    \n    col += k;//\n    //using the final t to make some fog\n    col = mix(col, vec3(0.), clamp(pow(t/5.,2.), 0., 1.));\n    //hacky gamma correction\n    col = pow(col, vec3(0.7));\n    fragColor = vec4(col,1.);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdGXWh.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[297, 2332, 2350, 2350, 2408], [2415, 2434, 2457, 2457, 2559], [2563, 2737, 2756, 2756, 2976], [2979, 2979, 3011, 3011, 3122], [3125, 3472, 3529, 3529, 3938], [3940, 3940, 3981, 3981, 4153], [4155, 4155, 4195, 4195, 4465], [4467, 4467, 4524, 4571, 8644]]}
{"id": "NdKSDD", "name": "line sdf composite study 1", "author": "_samuelcho_", "description": "Inspired by Zach Lieberman's compositions. ", "tags": ["sdf", "line", "zachlieberman"], "likes": 3, "viewed": 156, "published": "Public API", "date": "1634663227", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//inspired by https://twitter.com/zachlieberman/status/1450410944404852744\n\n\n\nfloat line_segment(in vec2 p, in vec2 a, in vec2 b) {\n\tvec2 ba = b - a;\n\tvec2 pa = p - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n\treturn length(pa - h * ba);\n}\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n \n    \n    float d = line_segment(uv, vec2(-0.5,0.0), vec2(0.5,0.0));\n    d *= 3.;\n    d = fract(d+iTime);\n    d = 1.-d;\n    vec3 c1 = palette(d - iTime*0.42,vec3(.5),vec3(.5),vec3(1.),vec3(.0,.33,.66)) * d;\n    \n    float d2 = line_segment(uv, vec2(cos(iTime)*0.4,cos(iTime*0.69)*0.3), vec2(0.4,0.4));\n    d2 *= 3.;\n    d2 = fract(d2);\n    d2 = 1.-d2;\n    vec3 c2 = palette(d2 - iTime*0.69,vec3(.5),vec3(.5),vec3(1.),vec3(.0,.33,.66)) * d2;\n    \n    float d3 = line_segment(uv, vec2(-0.3,sin(iTime*1.42)*0.2), vec2(0.3, sin(iTime*0.94)));\n    d3 *= 3.;\n    d3 = fract(d3);\n    d3 = 1.-d3;\n    vec3 c3 = palette(d3 - iTime*0.5,vec3(.5),vec3(.5),vec3(1.),vec3(.0,.33,.66)) * d3;\n    \n    vec3 col = max(max(c1,c2),c3);\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdKSDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 78, 131, 131, 251], [252, 252, 324, 324, 367], [368, 368, 425, 475, 1318]]}
{"id": "NdKSDR", "name": "SimpleCameraSystem", "author": "liaozixin", "description": "a simple 3d system include a camera", "tags": ["sdf", "camera"], "likes": 1, "viewed": 50, "published": "Public", "date": "1634481992", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST .01\n#define PI 3.14159\n\nstruct Ray\n{\n    vec3 ro;\n    vec3 rd;\n};\n\n\nfloat sdBox(vec3 p, vec3 size)\n{\n    return length(max(abs(p) - size, 0.));\n}\n\n\nfloat GetDist(vec3 p)\n{\n    vec3 pos = p;\n    float box = sdBox(pos, vec3(1, 1, 1));\n    \n    return box;\n}\n\nfloat RayMarching(vec3 ro, vec3 rd)\n{\n    float d = 0.;\n    vec3 p = ro;\n    \n    \n    for(int i = 0; i < MAX_STEPS; ++i)\n    {\n        float dS = GetDist(p);\n        d += dS;\n        p = ro + d * rd;\n        \n        if (d > MAX_DIST || dS < MIN_DIST)\n            break;\n    }\n    \n    return d;\n}\n\nvec3 Transform(vec3 p)\n{\n    float speed = 1.0;\n    mat3 m = mat3(\n        cos(iTime * speed), 0, -sin(iTime * speed),\n        0, 1, 0,\n        sin(iTime * speed), 0, cos(iTime * speed)\n    );\n    \n    p *= m;\n    return p;\n}\n\nvec3 InitCam(vec3 ro, vec2 uv)\n{   \n    vec3 lookat = vec3(0, 0, 0);\n    vec3 front = normalize(lookat - ro);\n    vec3 right = normalize(cross(vec3(0, 1, 0), front));\n    vec3 up = normalize(cross(front, right));\n    \n    float zoom = 1.;\n    \n    vec3 sc = ro + zoom * front;\n    vec3 uv_p = sc + uv.x * right + uv.y * up;\n    \n    vec3 rd = uv_p - ro;\n    return rd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro = vec3(0, 0, -6);\n    ro = Transform(ro);\n    \n    vec3 rd = InitCam(ro, uv);\n    \n    float d = RayMarching(ro, rd);\n    vec3 col = vec3(d / 7.);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdKSDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[129, 129, 161, 161, 206], [209, 209, 232, 232, 316], [318, 318, 355, 355, 616], [618, 618, 642, 642, 843], [845, 845, 877, 877, 1215], [1217, 1217, 1274, 1274, 1575]]}
{"id": "NdKSDz", "name": "Moiré pattern", "author": "hrtlacek", "description": "Moiré pattern demonstration for dsp course at https://github.com/hrtlacek/dspCourse", "tags": ["edu"], "likes": 0, "viewed": 42, "published": "Public", "date": "1634487151", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scaling = ((sin(iTime*0.25)+1.)/2.)*199. + 1.; //create scaling factor from time.\n    vec2 uv = fragCoord/iResolution.xy; //get normalized coordinates.\n    uv.x *= 1.6; // aspect ratio correction\n\tvec2 coords = fract(((uv*scaling)))-0.5; //scale the coordinates and center them.\n\tfloat r = length(coords); // calculate radius from the coordinates (convert to polar system from cartesian system, but dismiss the angle.)\n\tfloat circle = 1.-smoothstep(0.2,0.3, r); //use smooth step to make a circle fromm the radius.\n\tvec3 col = vec3(circle);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdKSDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 665]]}
{"id": "NdKXDm", "name": "Jelly Gateways", "author": "Tater", "description": "sss looks nice", "tags": ["3d", "raymarching", "sss", "bounce"], "likes": 34, "viewed": 465, "published": "Public API", "date": "1634862763", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MDIST 100.0\n#define STEPS 128.0\n#define pi 3.1415926535\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define pmod(p,x) (mod(p,x)-0.5*(x))\n\nvec3 rdg = vec3(0);\nvec3 hsv(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n//iq box sdf\nfloat ebox(vec3 p, vec3 b){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat ebox(vec2 p, vec2 b){\n  vec2 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\nfloat lim(float p, float s, float lima, float limb){\n    return p-s*clamp(round(p/s),lima,limb);\n}\nfloat idlim(float p, float s, float lima, float limb){\n    return clamp(round(p/s),lima,limb);\n}\n\nfloat dibox(vec3 p,vec3 b,vec3 rd){\n    vec3 dir = sign(rd)*b;   \n    vec3 rc = (dir-p)/rd;\n    float dc = min(rc.y,rc.z)+0.01;\n    return dc;\n}\nfloat easeOutBounce(float x) {\n    float n1 = 7.5625;\n    float d1 = 2.75;\n    if (x < 1. / d1) {\n        return n1 * x * x;\n    } \n    else if (x < 2. / d1) {\n        return n1 * (x -= 1.5 / d1) * x + 0.75;\n    } \n    else if (x < 2.5 / d1) {\n        return n1 * (x -= 2.25 / d1) * x + 0.9375;\n    } \n    else {\n        return n1 * (x -= 2.625 / d1) * x + 0.984375;\n    }\n}\nvec3 map(vec3 p){\n    float t = -iTime*0.8;\n    vec3 rd2 = rdg;\n    vec2 a = vec2(1);\n    vec2 b = vec2(2);\n    p.xz*=rot(t*0.3*pi/3.);\n    rd2.xz*=rot(t*0.3*pi/3.);\n    //p.xz*=rot(pi/4.);\n    //rd2.xz*=rot(pi/4.); \n    vec3 po = p;\n    float dsz = 0.45;\n    float m = 2.42-dsz;\n    float bs = 1.-dsz*0.5;\n    \n    //VERTIAL TRANSLATION\n    p.y+=t*m;\n    \n    //VERTIAL REP\n    float id1 = floor(p.y/m);\n    p.y = pmod(p.y,m);\n    \n    //ROTATE EACH LAYER\n    p.xz*=rot(id1*pi/2.);\n    rd2.xz*=rot(id1*pi/2.);\n\n    vec3 p2 = p; //dibox p1\n    \n    //Auxillary boxes positions\n    vec3 p3 = p;\n    vec3 rd3 = rd2;\n     \n    p3.xz*=rot(pi/2.);\n    rd3.xz*=rot(pi/2.);\n    vec3 p4 = p3; \n    \n    \n    //HORIZONTAL REP\n    p2.z = pmod(p2.z-m*0.5,m);\n    p4.z = pmod(p4.z-m*0.5,m);\n    \n    float cnt = 100.;\n    float id2 = idlim(p.z,m,-cnt,cnt);\n    float id3 = idlim(p3.z,m,-cnt,cnt);\n    p.z = lim(p.z,m,-cnt,cnt);\n    p3.z = lim(p3.z,m,-cnt,cnt);\n    \n    \n    //CLOSING ANIMATION \n    float close = max((id1-t)*1.,-2.);\n    float close2 = clamp(max((id1-t-0.3)*1.,-2.)*1.4,0.,1.);\n    close+=id2*0.025;\n    close = clamp(close*1.4,0.,1.);\n    close = easeOutBounce(close);\n    //close = 1.0-easeOutBounce(1.-close);\n\n    \n    \n    //CLOSING OFFSET\n    p.x = abs(p.x)-34.5*0.5-0.25*7.;\n    p.x-=close*34.5*0.52-0.055;\n    \n    p3.x = abs(p3.x)-36.5;\n\n    p.x-=((id1-t)*0.55)*close*2.4;\n    p3.x-=((id1-t)*0.55)*close2*2.4;\n    //WAVEY\n    p.x+=(sin(id1+id2-t*6.0)*0.18+4.)*close*2.4;\n    p3.x+=(sin(id1+id3-t*6.0)*0.18+4.)*smoothstep(0.,1.,close2)*2.4;\n    \n    \n    //BOX SDF\n    a = vec2(ebox(p,vec3(7.5*2.5,bs,bs))-0.2,id2);\n    \n    //AUXILLARY BOX\n    b = vec2(ebox(p3,vec3(7.5*2.5,bs,bs))-0.2,id3);\n    \n    a=(a.x<b.x)?a:b;\n    //ARTIFACT REMOVAL\n    float c = dibox(p2,vec3(1,1,1)*m*0.5,rd2)+.1;\n    //ARTIFACT REMOVAL 2\n    c = min(c,dibox(p4,vec3(1,1,1)*m*0.5,rd3)+.1);\n    \n\n    float nsdf = a.x;\n    \n    a.x = min(a.x,c); //Combine artifact removal\n    a.y = id1;\n    return vec3(a,nsdf);\n}\nvec3 norm(vec3 p){\n    vec2 e = vec2(0.005,0);\n    return normalize(map(p).x-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0,13,-5)*1.5;\n    if(iMouse.z>0.){\n    ro.yz*=rot(1.0*(iMouse.y/iResolution.y-0.2));\n    ro.zx*=rot(-7.0*(iMouse.x/iResolution.x-0.5));\n    }\n    vec3 lk = vec3(0,0,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = normalize(f*(0.5)+uv.x*r+uv.y*cross(f,r));  \n    rdg = rd;\n    vec3 p = ro;\n    float dO = 0.;\n\n    vec3 d= vec3(0);\n    for(float i = 0.; i<STEPS; i++){\n        p = ro+rd*dO;\n        d = map(p);\n        dO+=d.x;\n        if(abs(d.x)<0.005){\n            break;\n        }\n        if(dO>MDIST){\n            dO = MDIST;\n            break;\n        }\n    }\n\n    {\n        vec3 ld = normalize(vec3(0,45,0)-p);\n      \n        //sss from nusan\n        float sss=0.01;\n        for(float i=1.; i<20.; ++i){\n            float dist = i*0.09;\n            sss += smoothstep(0.,1.,map(p+ld*dist).z/dist)*0.023;\n        }\n        vec3 al = vec3(0.204,0.267,0.373);\n        vec3 n = norm(p);\n        vec3 r = reflect(rd,n);\n        float diff = max(0.,dot(n,ld));\n        float amb = dot(n,ld)*0.45+0.55;\n        float spec = pow(max(0.,dot(r,ld)),40.0);\n        float fres = pow(abs(.7+dot(rd,n)),3.0);     \n        //ao from blackle \n        #define AO(a,n,p) smoothstep(-a,a,map(p+n*a).z)\n        float ao = AO(.3,n,p)*AO(.5,n,p)*AO(.9,n,p);\n\n        col = al*\n        mix(vec3(0.169,0.000,0.169),vec3(0.984,0.996,0.804),mix(amb,diff,0.75))\n        +spec*0.3+fres*mix(al,vec3(1),0.7)*0.4;\n        col+=sss*hsv(vec3(fract(d.y*0.5+d.y*0.1+0.001)*0.45+0.5,0.9,1.35));\n        col*=mix(ao,1.,0.85);\n        col = pow(col,vec3(0.75));\n    }\n    col = clamp(col,0.,1.);\n    //col = smoothstep(0.,1.,col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdKXDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[172, 172, 189, 189, 358], [359, 372, 399, 399, 486], [487, 487, 514, 514, 592], [594, 594, 646, 646, 692], [693, 693, 747, 747, 789], [791, 791, 826, 826, 935], [936, 936, 966, 966, 1310], [1311, 1311, 1328, 1328, 3316], [3317, 3317, 3335, 3335, 3463], [3465, 3465, 3522, 3522, 5302]]}
{"id": "NdKXWm", "name": "Glacial valleys v10", "author": "jarble", "description": "A mountain terrain based on zchajax's [url=https://www.shadertoy.com/view/3dXcW2]\"simple terrain\"[/url] shader.", "tags": ["noise", "terrain", "fbm", "ice", "snow", "mountain", "erosion"], "likes": 15, "viewed": 322, "published": "Public API", "date": "1634755376", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SC (250.0)\n\nvec2 noise(in vec2 uv)\n{\n    //return sin(uv.x/1.6)+cos(-uv.y*1.6);\n    return vec2(sin(uv.x),cos(uv.y))+vec2(1.);\n}\n\n#define OCTAVES 8\nfloat fbm1(in vec2 uv,int octaves,float i1,float value1)\n{\n    //this function generates the terrain height\n    \n    float f = 2.15; //change this number to change the spacing of the mountains \n    //Another interesting variation:\n    //float f = 2.15+(sin(uv.x/i1)+cos(uv.x/i1))*value1;\n    \n    float value = value1;\n    float amplitude = i1*value1;\n    float freq = i1/f;\n    float n1 = 0.;\n    vec2 noise2,noise1;\n    for (int i = 0; i < octaves; i++)\n    {\n        \n        \n        noise2 = noise(noise1.yx+uv/freq);\n        noise1 = noise2-vec2(value)-noise1.yx*freq;\n        freq /= -f;\n        n1 = noise1.x+noise1.y;\n\n        value += n1*(amplitude-freq);\n\n        uv += noise2.yx*freq;\n    }\n    \n    return value/3.5;\n}\n\nfloat fbm(vec2 uv, int oct){\n    float result = 0.;\n    //uv /= 2.;\n    for(float i = 1.; i < 3.; i++){\n        float i1 = i*i;\n        result -= fbm1(uv,oct,i1,result/i1);\n        oct /= 2;\n    }\n    return result;\n}\n\nfloat fbm(in vec2 uv){\n    return fbm(uv,OCTAVES);\n}\n\nfloat f(in vec3 p,int iters)\n{   \n    float h = fbm(p.xz,iters);\n    return h;\n}\n\nfloat f(in vec3 p)\n{   \n    float h = fbm(p.xz,OCTAVES);\n    return h;\n}\n\nvec3 getNormal(vec3 p, float t)\n{\n    vec3 eps=vec3(.001 * t, .0, .0);\n    vec3 n=vec3(f(p - eps.xyy) - f(p + eps.xyy),\n                2. * eps.x,\n                f(p - eps.yyx) - f(p + eps.yyx));\n  \n    return normalize(n);\n}\n\nfloat rayMarching(in vec3 ro, in vec3 rd, float tMin, float tMax)\n{\n    float t = tMin;\n\tfor( int i = 0; i < 300; i++ )\n\t{\n        vec3 pos = ro + t * rd;\n\t\tfloat h = pos.y - f(pos,OCTAVES);\n\t\tif( abs(h) < (0.0015 * t) || t > tMax ) \n            break;\n\t\tt += 0.4 * h;\n\t}\n\n\treturn t;\n}\n\n/*\n//raymarching with LOD\nfloat rayMarching(in vec3 ro, in vec3 rd, float tMin, float tMax)\n{\n    float t = tMin;\n    int oct = 2;\n\tfor( int i = 0; i < 300; i++ )\n\t{\n        vec3 pos = ro + t * rd;\n\t\tfloat h = pos.y - f(pos,OCTAVES);\n\t\tif( abs(h) < (0.0015 * t) || t > tMax ) \n            if(oct < 8) oct += 2;\n            else break;\n\t\tt += 0.4 * h;\n\t}\n\n\treturn t;\n}\n*/\n\nvec3 lighting(vec3 p, vec3 normal, vec3 L, vec3 V)\n{\n    vec3 sunColor = vec3(1., .956, .839);\n    vec3 albedo = vec3(1.);\n   \tvec3 diff = max(dot(normal, L) * albedo, 0.);\n    \n    vec3 refl = normalize(reflect(L, normal));\n    float spec = max(dot(refl, -normalize(V)), 0.);\n    spec = pow(spec, 18.);\n    spec = clamp(spec, 0., 1.);\n    float sky = max(0.0, dot(vec3(0.,1.,0.), normal));\n    \n    //float amb = 0.5 * smoothstep(0.0, 2.0, p.y);\n    \n    vec3 col = diff * sunColor;\n    col += spec * sunColor;\n    col += sky * vec3(0., .6, 1.) * .1;\n    //col += amb * .2;\n    \n   \treturn col;\n}\n\nmat3 lookAt(vec3 origin, vec3 target, float roll)\n{\n    vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n    vec3 ww = normalize(target - origin);\n    vec3 uu = normalize(cross(ww, rr));\n    vec3 vv = normalize(cross(uu, ww));\n\n    return mat3(uu, vv, ww);\n}\n\nvec3 camerapath(float t)\n{\n    vec3 p=vec3(-13.0+3.5*cos(t),3.3,-1.1+2.4*cos(2.4*t+2.0));\n\treturn p;\n}\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\t\n    vec3 lightDir = normalize(vec3(0., 1., -1.));\n    \n    vec3 camStep = vec3(-1., 0., 0.) * (iTime+12.)/4.;\n    vec3 camPos = vec3(8., 2., 5.) + camStep;\n    vec3 camTarget = vec3(1., 1., 4.) + camStep;\n\n    \n    mat3 mat = lookAt(camPos, camTarget, 0.0);\n    \n    vec3 ro = camPos;\n    ro.y += fbm(ro.xz,OCTAVES)-1.8;\n\n    vec3 rd = normalize(mat * vec3(uv.xy, 1.0));\n        \n    if (length(iMouse.xy) > 40.0) {\n        rd.yx *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        rd.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n\n    \n    float tMin = .1;\n    float tMax = 20.;\n    float t = rayMarching(ro, rd, tMin, tMax);\n    \n    vec3 col = vec3(0.);\n    \n    if (t > tMax)\n    {\n        // from iq's shader, https://www.shadertoy.com/view/MdX3Rr\n        float sundot = clamp(dot(rd, lightDir), 0.0, 1.0);\n        col = vec3(0.3,0.5,0.85) - rd.y*rd.y*0.5;\n        col = mix( col, 0.85*vec3(0.7,0.75,0.85), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n        // sun\n\t\tcol += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n\t\tcol += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n\t\tcol += 0.2*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );\n        // clouds\n\t\tvec2 sc = ro.xz + rd.xz*(SC*1000.0-ro.y)/rd.y;\n\t\tcol = mix( col, vec3(1.0,0.95,1.0), 0.5*smoothstep(0.5,0.8,fbm(0.0005*sc/SC)) );\n        // horizon\n        col = mix( col, 0.68*vec3(0.4,0.65,1.0), pow( 1.0-max(rd.y,0.0), 16.0 ) );\n    }\n    else\n    {\n        vec3 p = ro + rd * t;\n        vec3 normal = getNormal(p, t);\n        vec3 viewDir = normalize(ro - p);\n        \n        // lighting terrian\n        col = lighting(p, normal, lightDir, viewDir);\n        \n        // fog\n        float fo = 1.0-exp(-pow(30. * t/SC,1.5) );\n        vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n        col = mix( col, fco, fo);\n    }\n    \n    // Gama correction\n    col = pow(clamp(col, 0., 1.), vec3(.45)); \n    \n    fragColor = vec4(vec3(col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdKXWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 44, 87, 136], [156, 156, 214, 263, 887], [889, 889, 917, 917, 1106], [1108, 1108, 1130, 1130, 1160], [1162, 1162, 1192, 1192, 1242], [1244, 1244, 1264, 1264, 1316], [1318, 1318, 1351, 1351, 1545], [1547, 1547, 1614, 1614, 1832], [1834, 2206, 2258, 2258, 2803], [2805, 2805, 2856, 2856, 3057], [3059, 3059, 3085, 3085, 3161], [3229, 3229, 3286, 3286, 5233]]}
{"id": "NdKXWV", "name": "Starstar", "author": "HaleyHalcyon", "description": "aa", "tags": ["a"], "likes": 8, "viewed": 57, "published": "Public", "date": "1635322782", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU (6.283185307)\n#define HEX(x) (vec3((x >> 16) & 255, (x >> 8) & 255, x & 255) / 255.)\n#define STRIPECOUNT 10.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float time = fract(iTime / 4.);\n  // Normalized pixel coordinates (from 0 to 1)\n  float scale = min(iResolution.x, iResolution.y);\n  vec2 uv = (gl_FragCoord.xy - 0.50 * iResolution.xy) / scale;\n  \n  float dist = length(uv);\n  float angle = atan(uv.y, uv.x);\n  // for calculating the parity of the stripe\n  float dark = floor(mod(angle * STRIPECOUNT / TAU + 2. * time, 2.));\n  // for calculating the stripes’ angle\n  float stripeAngle = (dark - .5) * time * TAU + (0.5 + floor(angle * STRIPECOUNT / TAU + 2. * time) - 2. * time) * TAU / STRIPECOUNT;\n  vec2 angleVec = vec2(cos(stripeAngle), sin(stripeAngle));\n  // for calculating which palette to use\n  float palette = step(fract(\n      log(dist + 0.01) + angle / TAU + time * 2.\n  ), 0.5);\n  \n  const vec3 col0L = HEX(0x840DaE);\n  const vec3 col1L = HEX(0x3BCEAC);\n  const vec3 col2L = HEX(0xFFD23F);\n  const vec3 col3L = HEX(0xEE4266);\n  \n  const vec3 col0D = HEX(0xFFD166);\n  const vec3 col1D = HEX(0xEF476F);\n  const vec3 col2D = HEX(0x118AB2);\n  const vec3 col3D = HEX(0x06D6A0);\n  \n  vec3 col0 = mix(col0L, col0D, palette);\n  vec3 col1 = mix(col1L, col1D, palette);\n  vec3 col2 = mix(col2L, col2D, palette);\n  vec3 col3 = mix(col3L, col3D, palette);\n  \n  float spiral = fract(\n      0.7 * log(\n          abs(\n              dot(uv, angleVec)\n          ) + 0.02\n      ) + (\n          3.2 * tan((0.5 - time) * TAU * 0.4)\n      ) + (\n          16. * time\n      )\n  );\n  \n  vec3 col = mix(\n      mix(\n          col0, col1, step(spiral, 0.75)\n      ), mix(\n          col2, col3, step(spiral, 0.25)\n      ), step(spiral, 0.5)\n  );\n  // Output to screen\n  fragColor = vec4(\n    col, 1.0\n  );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdKXWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[122, 122, 179, 179, 1825]]}
{"id": "NdKXzw", "name": "Art of code exercice", "author": "Loubi", "description": "A replication of smth seen in a video", "tags": ["circles"], "likes": 4, "viewed": 45, "published": "Public", "date": "1634420145", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\n#define MIN_DIAM .3\n#define MAX_DIAM .7\n\nfloat hash21(vec2 id) {\n    return fract(length(sin(id * 356.453)) * 34566.4325);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    float a = PI / 4.;\n    float c = cos(a);\n    float s = sin(a);\n    \n    uv *= mat2 (c, -s, s, c);\n    uv *= 10.0;\n    \n    vec2 gv = fract(uv);\n    vec2 id = floor(uv);\n    float m = 0.;\n    \n    float nd = 1.;\n    \n    for (float y = -nd; y <= nd; y++) {\n        for (float x = -nd; x <= nd; x++) {\n        \n            vec2 offset = vec2(x, y);\n            \n            float d = length(gv - offset);\n            float dist = length(id + offset);\n            \n            float truc = sin(dist - iTime * 2.) * .5 + .5;\n            \n            vec2 r = vec2(\n                mix(MIN_DIAM, MAX_DIAM, truc)\n            );\n            r.y -= .00009;\n            \n            m += smoothstep(r.x, r.y, d) * .3;\n        }\n    }\n    \n    vec3 col = vec3(m, m*.6, m*.5);\n    // col += mod(m, 2.);\n    // col.gb += id / 8.;\n    // col.r += length(uv);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdKXzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 63, 86, 86, 146], [147, 147, 204, 204, 1153]]}
{"id": "NdtSD2", "name": "Taste of Noise", "author": "leon", "description": "Result of experimentation with organic patterns", "tags": ["weird"], "likes": 8, "viewed": 271, "published": "Public API", "date": "1633991972", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// taste of noise by leon denise 2021/10/12\n// result of experimentation with organic patterns\n// using code from Inigo Quilez\n// Licensed under hippie love conspiracy\n\n// rotation matrix\nmat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\n\n// global variable\nfloat material;\n\n// sdf\nfloat map (vec3 p)\n{\n    // time\n    float t = iTime * 0.1;\n    \n    // rotation parameter\n    vec3 angle = vec3(78.,68.,78.) + t + p;\n    \n    // kif\n    const int count = 5;\n    float a = 1.0;\n    float scene = 1000.;\n    float shape = 1000.;\n    for (int index = 0; index < count; ++index)\n    {\n        // fold\n        p = abs(p)-.5*a;\n        \n        // rotate\n        p.xz *= rot(angle.y/a);\n        p.yz *= rot(angle.x/a);\n        p.yx *= rot(angle.z/a);\n        \n        // sphere\n        shape = length(p)-.6*a;\n        \n        // materialing\n        material = shape < scene ? float(index) : material;\n        \n        // add\n        scene = min(scene, shape);\n        \n        // falloff\n        a /= 1.89;\n    }\n    \n    // shell\n    scene = abs(scene);\n    \n    // surface details\n    float d = length(p);\n    float details = abs(sin(d*20.))*0.05;\n    scene -= details;\n    \n    return scene;\n}\n\n// return color from pixel coordinate\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // reset color\n    fragColor = vec4(0);\n    material = 0.0;\n    \n    // camera coordinates\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    vec3 eye = vec3(0,0,-1);\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    eye.xz *= rot(0.4+mouse.x);\n    eye.xy *= rot(0.6-mouse.y);\n    vec3 z = normalize(-eye);\n    vec3 x = normalize(cross(z, vec3(0,1,0)));\n    vec3 y = normalize(cross(x, z));\n    vec3 ray = normalize(vec3(z * 0.5 + uv.x * x + uv.y * y));\n    vec3 pos = eye + ray * .5;\n    \n    // raymarch\n    const int steps = 20;\n    for (int index = steps; index > 0; --index)\n    {\n        // volume estimation\n        float dist = map(pos);\n        if (dist < 0.01)\n        {\n            // Inigo Quilez color palette (https://iquilezles.org/www/articles/palettes/palettes.htm)\n            vec3 tint = vec3(0.2)+vec3(0.8)*cos(vec3(1,2,3)*material*0.2-length(pos)*2.);\n            \n            // pixel color\n            float shade = float(index)/float(steps);\n            fragColor.rgb = tint * shade;\n            \n            break;\n        }\n        \n        // raymarch\n        pos += ray * dist;\n    }\n}\n\n", "image_inputs": [{"id": "4dXGR8", "previewfilepath": "/media/previz/buffer00.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/previz/buffer00.png", "ctype": "buffer"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdtSD2.jpg", "access": "shaders20k", "license": "unknown-license-reference", "functions": [[170, 189, 208, 208, 253], [291, 298, 318, 330, 1207], [1209, 1247, 1304, 1323, 2443]]}
{"id": "NdtSDH", "name": "ray march sphere", "author": "dixie", "description": "ray marched sphere", "tags": ["raymarch"], "likes": 0, "viewed": 34, "published": "Public", "date": "1633066556", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float map(vec3 pos) {\n    vec4 sphere = vec4(0.0, 0.0, 2.0, 0.75);\n    return distance(pos, sphere.xyz) - sphere.w;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // center coordinates\n    vec2 uv = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n    // setup camera\n    vec3 camera_origin = vec3(0.0, 1.0, 0.0);\n    vec3 look_at_point = vec3(0.0, 0.0, 2.0);\n    float distance_to_image_plane = 1.5;\n    \n    // camera coordinate frame\n    vec3 gaze = look_at_point - camera_origin;\n    vec3 ww = normalize(gaze);\n    vec3 uu = normalize(cross(vec3(0, 1.0, 0), ww));\n    vec3 vv = normalize(cross(ww, uu));\n    \n\n    \n    // ray direction\n    vec3 ray_direction = normalize(uv.x * uu + uv.y * vv + ww * distance_to_image_plane);\n    \n    // ray march\n    float ray_march_distance = 0.0;\n    int max_ray_march_iterations = 256;\n    float min_distance = 0.001;\n    float max_distance = 500.0;\n    for (int i = 0; i < max_ray_march_iterations; i++) {\n        vec3 p = ray_march_distance * ray_direction + camera_origin;\n        float distance_to_scene = map(p);\n        ray_march_distance += distance_to_scene;\n        if (distance_to_scene < min_distance || ray_march_distance > max_distance)\n            break;\n\n    }\n    \n    // Black background\n    vec3 col = vec3(0.0);\n    \n    \n    // lamp\n    if (ray_march_distance < max_distance) {\n        vec4 lamp = vec4(cos(iTime), 4., sin(iTime), 1);\n        vec3 p = ray_march_distance * ray_direction + camera_origin;\n        vec3 n = calcNormal(p);\n        float illum = clamp(dot(n, normalize(lamp.xyz - p)), 0.0, 1.0) * lamp.w;\n        //illum = sqrt(illum);\n        col += illum;\n    }\n    \n\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdtSDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 117], [119, 119, 151, 151, 390], [392, 392, 449, 475, 1997]]}
{"id": "NdtSDj", "name": "Oleadas ", "author": "nictemeral", "description": "shader exploración de seno , inspirado por la web de solquemalhttps://curso.solquemal.com/clases/\n\n", "tags": ["waves", "sin", "color"], "likes": 1, "viewed": 91, "published": "Public API", "date": "1633974517", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//nictemeral\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n     vec3 color = vec3(0.960,0.113,0.003); \n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 -01.; \n          \n    color.rb = fract(abs(uv*3.0));  \n    color.rb *= floor(abs(uv*7.0))/5.0; \n\n    uv.y+=0.120;\n    uv.x+=sin(sin(iTime)*sin(uv.x));\n  \n    color.rb = floor(abs(uv*sin(atan(uv.s,uv.t))*10.272))/10.200; \n\n     \n    fragColor = vec4(color,1.0);\n\n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdtSDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 13, 69, 69, 437]]}
{"id": "NdtSRs", "name": "Mountains at dawn 3", "author": "jarble", "description": "Mountains at dawn\nUsing Yonatan clouds/mountains combined field", "tags": ["clouds", "mountains"], "likes": 9, "viewed": 246, "published": "Public API", "date": "1633728450", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by S. Guillitte 2021\n \n\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\nvec3 l = vec3(1.);\n\n//Yonatan clouds/mountains combined field\nvec2 field(in vec3 p) {\n\t\n\tfloat s=2.,e,f,o;\n    vec2 p2;\n\t\n\tfor(e=f=p.y;s<8.;s*=-1.45)\n            p2 = sin((p.xz+vec2(p2.y,p2.x+s))*s*.5)/s,\n            //p.xz*=rot(s),\n            e+=abs(dot((sin((p-vec3(0,0,iTime))*s)/s),.4*l)),\n            f+=abs(dot(p2,l.xz)),\n            p.xz += p2;\n\to = 1.+ (f>.001?e:-exp(-f*f));\n    return vec2(max(o,0.),min(f,max(e,.07)));\n}\n\n\nvec3 raycast( in vec3 ro, vec3 rd )\n{\n    float t = 2.5;\n    float dt = .035;\n    vec3 col= vec3(0.);\n    for( int i=0; i<100; i++ )\n\t{                \n        vec2 v = field(ro+t*rd);  \n        float c=v.x, f=v.y;\n        t+=dt*f;\n        dt *= 1.03;\n        col = .95*col+ .09*vec3(c*c*c, c*c, c);\t\n    }\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t = iTime;\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    \n\n    // camera\n\n    vec3 ro = vec3(2.);\n   \n    ro.yz*=rot(-1.5); \n    ro.y +=3.;\n    ro.xz*=rot(0.1*t);\n    \n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\n    ro.x -=t*.4;\n\n\t// raymarch \n    \n    vec3 col = raycast(ro,rd);\n    \n\t\n\t// shade\n    \n    col =  .5 *(log(1.+col));\n    col = clamp(col,0.,1.);\n    fragColor = vec4( col, 1.0 );\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdtSRs.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 122, 141, 141, 188], [210, 252, 275, 275, 622], [625, 625, 662, 662, 954], [957, 957, 1014, 1014, 1669]]}
{"id": "NdtXDN", "name": "Cheap Ocean", "author": "Krischan", "description": "A wet alteration of https://www.shadertoy.com/view/fddXWH\nHas some visual artifacts that are mostly covered by movement :D", "tags": ["clouds", "water", "ocean"], "likes": 11, "viewed": 267, "published": "Public API", "date": "1633189224", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision mediump float;\n\nmat2 rotate2D(float r){\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float i,e,f,s,g,k=.01;    \n    float o;    \n    o++;    \n    for(int i=0;i<100;i++)\n    {\n      s=2.;      \n      g+=min(f,max(.03,e))*.3;      \n      vec3 p=vec3((fragCoord.xy-iResolution.xy/s)/iResolution.y*g,g-s);\n      p.yz*=rotate2D(-.8);\n      p.y*=2.5;\n      p.z+=iTime*1.3;\n      e=p.y;\n      f=p.y;\n      for(;s<50.;)\n      {\n        s/=.66;\n        p.xz*=rotate2D(s);\n        e+=abs(dot(sin(p*s)/s,p-p+0.6));\n        f+=abs(dot(sin(p.xz*s*.33+(iTime*0.5))/s,iResolution.xy/iResolution.xy));\n      }\n\n      if(f>k*k)\n        o+=e*o*k;\n      else\n        o+=-exp(-f*f)*o*k;\n\n\n    }\n    fragColor = vec4(o*vec4(0.33,0.7,0.85,1.0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdtXDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 49, 49, 101], [103, 103, 160, 160, 805]]}
{"id": "NdtXW8", "name": "Tumble", "author": "ruojake", "description": "A noisy ball of fur for your enjoyment", "tags": ["raymarching", "fur"], "likes": 8, "viewed": 214, "published": "Public API", "date": "1633287447", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Tumble by Kristian Sivonen (ruojake)\n// CC BY-SA 4.0 (https://creativecommons.org/licenses/by-sa/4.0/)\n\n#define sat(x) (clamp((x), 0., 1.))\n\nfloat hash12(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(1.433, 1.512))) * 4313.441);\n}\n\nfloat hash13(vec3 p)\n{\n\treturn fract(sin(dot(p, vec3(1.433, 1.512, 2.421))) * 4313.441);\n}\n\nmat2 rot(float a)\n{\n    float s = sin(a),\n          c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nfloat noise(vec2 p)\n{\n\tvec2 i = floor(p);\n    vec2 f = smoothstep(0.,1.,p-i);\n    const vec2 o = vec2(1.,0.);\n    \n    return mix(mix(hash12(i),hash12(i+o),f.x),\n               mix(hash12(i+o.yx),hash12(i+1.),f.x),\n               f.y);\n}\n\nfloat noise3(vec3 p)\n{\n\tvec3 i = floor(p);\n    vec3 f = smoothstep(0.,1.,p-i);\n    const vec2 o = vec2(1.,0.);\n    \n    return mix(\n               mix(mix(hash13(i),hash13(i+o.xyy),f.x),\n                   mix(hash13(i+o.yxy),hash13(i+o.xxy),f.x),\n                   f.y),\n               mix(mix(hash13(i+o.yyx),hash13(i+o.xyx),f.x),\n                   mix(hash13(i+o.yxx),hash13(i+1.),f.x),\n                   f.y),\n               f.z);\n}\n\nfloat noiseBiplanar(vec3 n, float scale)\n{\n    vec2 uv0, uv1;\n    if(n.z < n.x && n.z < n.y)\n    {\n        n = n.zxy;\n    }\n    else if (n.y < n.x && n.y < n.z)\n    {\n        n = n.yxz;\n    }\n    uv0 = n.xz;\n    uv1 = n.xy;\n    float t = smoothstep(.025, .975, n.z / (n.z + n.y));\n    return mix(noise(uv0 * scale + scale * 2.), noise(uv1 * scale + scale * 2.), t);\n}\n\nfloat fur(vec3 p)\n{\n    float len = length(p);\n    p = normalize(p);\n    float thickness = noiseBiplanar(p, 140.);\n    return len - 2. + (thickness * len) * .25;\n}\n\nvec3 spin(vec3 p, float d)\n{\n    float t = iTime * .5 - d * d * .125;\n    p.xz *= rot(sin(t * 2.));\n    p.zy *= rot(sin(t * 1.5));\n    return p;\n}\n\nfloat scene(vec3 p)\n{\n    float d = length(p);\n    if(d <= 2.)\n    {\n        return fur(spin(p, d));\n    }\n    return d;\n}\n\nvec3 normal(vec3 p, float d)\n{\n    vec2 e = vec2(.0001, 0);\n    return normalize(d - vec3(\n        scene(p - e.xyy),\n        scene(p - e.yxy),\n        scene(p - e.yyx)));\n}\n\nfloat shadow(vec3 ro, vec3 rd, float maxDist)\n{\n    float res = 1.;\n    float d = 0.;\n    float t = .01;\n    for(int i = 0; i < 30 && t < maxDist; ++i)\n    {\n        d = scene(ro + rd * t);\n        t += d;\n    \tif(abs(d) < .00001)\n            return 0.;\n    }\n    return 1.;\n}\n\nvec3 color(vec3 p)\n{\n    float d = length(p);\n    p = normalize(p);\n    \n    float a = noiseBiplanar(spin(p, d).xyz, 20.);\n    vec3 c = vec3(1., .01, .8) * (a * .8 + .2);\n    return erot(c, normalize(vec3(1)), fract(a * 11.) * 2. - 1.);\n}\n\nvoid img( inout vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord-iResolution.xy * .5)/iResolution.y;\n\n    vec3 rd = normalize(vec3(uv, 1.));\n    vec3 ro = vec3(0, 0, -4);\n    vec3 p;\n    \n    float d, t = 2.;\n    float i = 0.;\n    // shorten the raymarching step at grazing angles\n    float tangentBias = 1. / (1. + smoothstep(.25, .5, length(uv)) * .75);\n    for(; i < 1. && t < 6.; i += 1./32.)\n    {\n        p = ro + rd * t;\n        d = scene(p);\n        t += d * tangentBias * sat(length(p) * .5);\n        if(abs(d) < .0001)\n            break;\n    }\n    \n    vec3 col = vec3(.025, .025, .035);\n    if (t < 6.)\n    {\n        \n        vec3 n = normal(p, d);\n        vec3 dirL = normalize(vec3(1, 1, -2));\n        n.xz *= rot(iTime * .4);\n        float l = dot(max(n, 0.), vec3(.4,.5,.3));\n        l *= shadow(p + n * .01, vec3(0,1,0), 10.);\n        col = color(p);\n        float lum = dot(col, vec3(.2,.7,.1));\n        col = mix(col * l + vec3(0.,.001,.002), vec3(1., .98, .95) * l, l*l*(.5 + lum));\n        float ao = (1. - max(i - l*l, 0.) * .8);\n        col *= ao;\n    }\n\n    fragColor += vec4(col,1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(0);\n    img(fragColor, fragCoord);\n    vec2 o = vec2(.03125, .015625);\n    for(float i = 0.; i < 4.; i++)\n    {\n        img(fragColor, fragCoord + o);\n        o = vec2(o.y,-o.x);\n    }\n    fragColor /= 5.;\n\n    fragColor.rgb = pow(fragColor.rgb, vec3(1./2.2));\n    float vignette = length((fragCoord - iResolution.xy * .5) / iResolution.xy) * 2.;\n    fragColor.rgb *= 1. - vignette * vignette * vignette * .15;\n    fragColor.rgb += noise3(vec3(fragCoord, iFrame)) * .01 - .005;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdtXW8.jpg", "access": "shaders20k", "license": "cc-by-sa-4.0", "functions": [[0, 144, 166, 166, 227], [229, 229, 251, 251, 319], [321, 321, 340, 340, 416], [418, 418, 456, 456, 521], [523, 523, 544, 544, 760], [762, 762, 784, 784, 1201], [1203, 1203, 1245, 1245, 1570], [1572, 1572, 1591, 1591, 1735], [1737, 1737, 1765, 1765, 1883], [1885, 1885, 1906, 1906, 2007], [2009, 2009, 2039, 2039, 2181], [2183, 2183, 2230, 2230, 2459], [2461, 2461, 2481, 2481, 2699], [2701, 2701, 2754, 2754, 3826], [3828, 3828, 3883, 3883, 4384]]}
{"id": "NdtXWl", "name": "Polynomial experimentations #2", "author": "ninofiliu", "description": "Playing around with broken implementations of the Newton's fractal", "tags": ["polynomial"], "likes": 2, "viewed": 128, "published": "Public API", "date": "1634162535", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int deg = 3;\nvec2 roots[deg];\n    \nvec2 mul(vec2 a, vec2 b) {\n    return vec2(\n        a.x*b.x - a.y*b.y,\n        a.x*b.y + a.y*b.y\n    );\n}\n\nvec2 div(vec2 a, vec2 b) {\n    return mul(a, vec2(b.x, -b.y))/(b.x*b.x+b.y*b.y);\n}\n\nvec2 inv(vec2 a) {\n    return vec2(a.x, -a.y) / (a.x*a.x + a.y*a.y);\n}\n\nvec2 f(vec2 a) {\n    vec2 ret = vec2(1.0, 0.0);\n    for (int i = 0; i < deg; i++) {\n        ret = mul(ret, a-roots[i]);\n    }\n    return ret;\n}\n\nvec2 fp(vec2 a) {\n    vec2 sum = vec2(0.0, 0.0);\n    for (int i = 0; i < deg; i++) {\n        sum += inv(a-roots[i]);\n    }\n    return inv(sum);\n}\n\nvec4 col(vec2 a) {\n    return vec4(1.0/(1.0+0.1*abs(a.x)), 1.0/(1.0+0.21*abs(a.y)), 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    roots[0] = vec2(cos(0.6*iTime), sin(0.3*iTime));\n    roots[1] = vec2(cos(0.4*iTime), sin(0.5*iTime));\n    roots[2] = vec2(cos(0.1*iTime), sin(0.1*iTime));\n    vec2 u = 2.0*(fragCoord-iResolution.xy/2.0)/min(iResolution.x, iResolution.y);\n    for(int i = 0; i < 3; i++) {\n        u -= div(f(u), fp(u));\n    }\n    fragColor = col(u);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdtXWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 41, 67, 67, 146], [148, 148, 174, 174, 230], [232, 232, 250, 250, 302], [304, 304, 320, 320, 447], [449, 449, 466, 466, 594], [596, 596, 614, 614, 692], [694, 694, 749, 749, 1087]]}
{"id": "NdtXWN", "name": "Fuzzy Spiral", "author": "d3v_null", "description": "fuzzy spiral", "tags": ["spiral", "fuzzy"], "likes": 2, "viewed": 36, "published": "Public", "date": "1633184810", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define tau 6.283185307\n#define pi tau/2.\n#define sharp 0\n#define arms 1.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float m = max(iResolution.x, iResolution.y);\n    vec2 uv = 0.5 * (fragCoord.xy - (0.5 * iResolution.xy)) / m;\n    // uv = uv * 2.0 - vec2(1.0);\n    \n    // rt is (r, θ) but both normalized [0,1]\n    vec2 rt = vec2(length(uv),atan(uv.y, uv.x)/tau + 0.5);\n    float a = 10.0 * cos(iTime/2.);\n    float b = iTime/3.;\n    float c = sin(iTime);\n    float d = mod((arms * rt.y + b) + rt.x * a, 1.0);\n#if sharp\n    if (d < 0.5) {\n        d = 0.;\n    } else {\n        d = 1.;\n    }\n#endif\n    fragColor = vec4(\n        d * d, \n        0., \n        (1. - d) * (1. -d), \n        1.\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdtXWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 75, 132, 182, 768]]}
{"id": "NdVSR1", "name": "newton's fractal", "author": "thacks42", "description": "simple implementation of newtons fractal\nFun fact: this works without evaluating the polynomial and its derivative.\nInstead it relies on the logarithmic derivative of the polynomial.\nThe newton iteration step can thus be calculated directly from the roots", "tags": ["fractal", "newton", "rootfinding", "polynom"], "likes": 1, "viewed": 175, "published": "Public API", "date": "1634329068", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define no_roots 4\n#define anti_alias 1\n#define no_iterations 15\n\nvec2 complex_reciprocal(vec2 z){ //computes 1/z\n    float div = z.x * z.x + z.y * z.y;\n    float div_r = 1.0f / div;\n    vec2 result = vec2(z.x * div_r, -z.y * div_r);\n    return result;\n}\n\n/*\n * Newton-rhapsody based root finding:\n * x_n+1 = x_n - f(x)/f'(x)\n * \n * interestingly the reciprocal of f(x)/f'(x) is the logarithmic derivative:\n * d/dx ln( f(x) ) = f'(x) / f(x)\n * \n * If we think of the polynomial in terms of its roots we have:\n * \n * P(x) = (x - x1) * (x - x2) * ... * (x - xn)\n * thus d/dx ln( P(x) ) = d/dx ln[ (x - x1) * (x - x2) * ... * (x - xn) ]\n * = d/dx [log(x - x1) + log(x - x2) + ... + log(x - xn)]\n * = 1/(x - x1) + 1/(x - x2) + ... + 1/(x - xn)\n * \n * which means that the reciprocal of this sum is equal to f(x)/f'(x)\n * So we can compute the newton iteration step directly from the zeros of our polynomial.\n * \n */\nvec2 newton_iteration(vec2 z, const vec2 roots[no_roots]){\n    vec2 sum = vec2(0.0f);\n    for(int i = 0; i < no_roots; i++){\n        vec2 delta = vec2(z.x - roots[i].x, z.y - roots[i].y); //calculate x - x0\n        float div = delta.x * delta.x + delta.y * delta.y;     //calculate the divisior for calculating the complex reciprocal\n        if(div < 0.0001f){                                     //if the divisor is close to zero, we've already found a root.\n            return z;\n        }\n        float div_r = 1.0f/div;\n        vec2 complex_reciprocal_delta = vec2(delta.x * div_r, -delta.y * div_r); //calculate the complex reciprocal\n        sum += complex_reciprocal_delta;                      //add the complex reciprocal to our sum\n    }\n    vec2 result = complex_reciprocal(sum);                    //calculate the complex reciprocal of the sum\n    return z - result;                                        //do the newton \"step\"\n}\n\nint find_closest_root(vec2 z, const vec2 roots[no_roots]){\n    int index = 0;\n    float dist = 10000.0f;\n    for(int i = 0; i < no_roots; i++){\n        float dx = (z.x - roots[i].x);\n        float dy = (z.y - roots[i].y);\n        float d = dx * dx + dy * dy;\n        if(d < dist){\n            dist = d;\n            index = i;\n        }\n    }\n    return index;\n}\n\nvec2 calculate_coord(vec2 c){\n    vec2 normalized_coord = c/iResolution.xy;\n    float t = iTime;\n    normalized_coord -= vec2(0.5f) + vec2(sin(t*0.1f)*0.3f, cos(t*0.1f)*0.3f);\n    normalized_coord *= 3.0 - cos(t*0.2)*2.0f;\n    return normalized_coord;\n}\n\nvec3 sample_no_AA(vec2 c, vec2 roots[no_roots], vec3 colors[no_roots]){\n    vec2 z1 = calculate_coord(c);\n    for(int i = 0; i < no_iterations; i++){\n        z1 = newton_iteration(z1, roots);\n    }\n    int index1 = find_closest_root(z1, roots);\n    \n    vec3 col = colors[index1];\n    return col;\n}\n\nvec3 sample_AA(vec2 c, vec2 roots[no_roots], vec3 colors[no_roots]){\n    vec2 z1 = calculate_coord(c + vec2( 0.114f, -0.377f));\n    vec2 z2 = calculate_coord(c + vec2( 0.351f,-0.105f));\n    vec2 z3 = calculate_coord(c + vec2(-0.123f,0.342f));\n    vec2 z4 = calculate_coord(c + vec2(-0.360f, -0.140f));\n    for(int i = 0; i < no_iterations; i++){\n        z1 = newton_iteration(z1, roots);\n        z2 = newton_iteration(z2, roots);\n        z3 = newton_iteration(z3, roots);\n        z4 = newton_iteration(z4, roots);\n    }\n    int index1 = find_closest_root(z1, roots);\n    int index2 = find_closest_root(z2, roots);\n    int index3 = find_closest_root(z3, roots);\n    int index4 = find_closest_root(z4, roots);\n    \n    vec3 col = colors[index1] + colors[index2] + colors[index3] + colors[index4];\n    col /= 4.0f;\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    float t = iTime;\n    vec2 roots[no_roots] = vec2[no_roots](\n                                 vec2(1.1f  + 0.326f * cos(t*0.162f), -1.4f + 0.25f * sin(t*0.072f)),\n                                 vec2(1.2f  + 0.217f * sin(t*0.417f),  1.9f + 0.43f * cos(t*0.109f)),\n                                 vec2(-1.3f + 0.421f * cos(t*0.481f),  1.3f + 0.51f * sin(t*0.542f)),\n                                 vec2(-1.7f + 0.517f * sin(t*0.378f), -1.5f + 0.67f * cos(t*0.379f)));\n    \n    const vec3 colors[no_roots] = vec3[no_roots](\n                                  vec3(0.098f, 0.521f, 0.56f),\n                                  vec3(0.290f, 0.043f, 0.345f),\n                                  vec3(0.122f, 0.627f, 0.812f),\n                                  vec3(0.345f, 0.722f, 0.369f));\n    \n    \n    vec3 col;\n    if(anti_alias == 1){\n        col = sample_AA(fragCoord, roots, colors);\n    }\n    else{\n        col = sample_no_AA(fragCoord, roots, colors);\n    }\n    fragColor = vec4(col,1.0);\n}\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdVSR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 98, 113, 254], [256, 912, 970, 970, 1854], [1856, 1856, 1914, 1914, 2217], [2219, 2219, 2248, 2248, 2472], [2474, 2474, 2545, 2545, 2772], [2774, 2774, 2842, 2842, 3603], [3605, 3605, 3659, 3659, 4652]]}
{"id": "NdVSWR", "name": "Square Moving", "author": "Desdby", "description": "A square moving.", "tags": ["simple", "animation", "square"], "likes": 0, "viewed": 31, "published": "Public", "date": "1634468575", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec4 rect (vec2 uv , float xc, float yc, float w, float h){\n\n\n    float x = uv.x;\n    float y = uv.y;\n    \n    h *= 1.77;\n    \n    if ( (xc-w/2.0 <= x && x <= xc+w/2.0) &&   (yc-h/2.0 <= y && y <= yc+h/2.0)  ){\n        \n        float ir = x;\n        float ig = y;\n        float ib = 0.0;\n        \n        // Output to screen\n        return vec4(ir,ig,ib,1.0);\n        \n    }\n    \n    \n    return vec4 (0.0) ;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float x = uv.x;\n    float y = uv.y; \n    float t = iTime;\n    \n    \n    // Output to screen\n    fragColor = vec4 (y*0.5 , x*0.5 , x+y*0.1 ,0.0 ) + rect (uv, 0.2*cos(t-sin(t)) + 0.5 , 0.2*sin(t) + 0.5 , 0.16,0.16);\n    \n    return;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdVSWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 60, 60, 411], [415, 415, 471, 521, 803]]}
{"id": "NdVSWV", "name": "uv Twist", "author": "mmggww", "description": "tranform uv to coord polar", "tags": ["uv"], "likes": 1, "viewed": 26, "published": "Public", "date": "1635318578", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float _Speed = 0.05;\nfloat _Num = 3.;\nfloat _Value = 2.;\nfloat _TwistFactor = 10.;\nfloat _LightPower = 1.3;\n\n#define PI 3.14159265\n\n//RGB To HSV\nvec3 RGBToHSV(vec3 col)\n{                \n    vec4 k = vec4(0., -1./3., 2./3., -1.);\n    vec4 p = mix(vec4(col.bg, k.wz), vec4(col.gb, k.xy), step(col.b, col.g));\n    vec4 q = mix(vec4(p.xyw, col.r), vec4(col.r, p.yzx), step(p.x, col.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    float hue = abs(q.z + (q.w - q.y)/(6. * d + e));\n    float sat = d / (q.x + e);\n    float val = q.x;\n    return vec3(hue, sat, val);\n}\n\n//https://www.shadertoy.com/view/MsS3Wc\n//HSV To RGB\nvec3 HSVToRGB(float hue, float saturation, float value)\n{\n    vec3 rgb = clamp(abs(mod(hue * 6. + vec3(0.,4.,2.),6.)-3.)-1., 0., 1.);\n    return value * mix(vec3(1.), rgb, saturation);\n}\n\nvec2 ToPolarCoord(vec2 pos)\n{\n    pos = pos - 0.5;\n    float len = length(pos);\n    float a = acos(pos.x/len) * pos.y / abs(pos.y) / PI / 2.;\n    return vec2(a * _Num + sin(len * _TwistFactor), len * _Value);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = 1.;\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv = ToPolarCoord(uv);   \n    uv.x = uv.x + iTime * _Speed;\n    uv.y = pow(uv.y, _LightPower);\n    \n    vec3 rgb = HSVToRGB(uv.x, uv.y, 1.);\n    \n    fragColor = vec4(rgb,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdVSWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[132, 145, 170, 170, 580], [582, 635, 692, 692, 821], [823, 823, 852, 852, 1033], [1035, 1035, 1092, 1092, 1338]]}
{"id": "NdVSzd", "name": "Neutron Star.", "author": "pancakespeople", "description": "Click with the mouse to zoom in or out, left of the screen = in, right = out.", "tags": ["space", "neutronstar"], "likes": 6, "viewed": 125, "published": "Public API", "date": "1635141012", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NUM_OCTAVES 5\n\nvec2 random2(vec2 st) {\n\tst = vec2(dot(st, vec2(127.1, 311.7)),\n\t\tdot(st, vec2(269.5, 183.3)));\n\treturn -1.0 + 2.0 * fract(sin(st) * 43758.5453123 * 0.3897);\n}\n\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec2 st) {\n\tvec2 i = floor(st);\n\tvec2 f = fract(st);\n\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\n\treturn mix(mix(dot(random2(i + vec2(0.0, 0.0)), f - vec2(0.0, 0.0)),\n\t\tdot(random2(i + vec2(1.0, 0.0)), f - vec2(1.0, 0.0)), u.x),\n\t\tmix(dot(random2(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0)),\n\t\t\tdot(random2(i + vec2(1.0, 1.0)), f - vec2(1.0, 1.0)), u.x), u.y);\n}\n\nfloat fbm(vec2 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n\t// Rotate to reduce axial bias\n\tmat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfor (int i = 0; i < NUM_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nmat2 rotate(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 mouse = iMouse.xy/iResolution.x * 8.0;\n    \n    if (mouse.x <= 0.0) mouse.x = 4.0;\n    \n    float zoom = mouse.x;\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x;\n    vec2 gv = fract(uv+0.5) - random2(uv);\n    uv *= zoom;\n    float dist = length(uv);\n    float angle = atan(uv.y, uv.x);\n    float c = fbm(vec2(cos(angle+iTime), sin(angle+dist)) / 2.0) * 2.0;\n    float f = (1.0 - sqrt(1.0 - dist)) / dist;\n\n    vec3 col = vec3(0.0);\n\n    vec2 nuv = uv;\n    nuv *= rotate(iTime);\n\n    // Neutron star\n    col += vec3(0.7, 0.9, 1.0) * smoothstep(0.17, 0.15, dist);\n    col += max((fbm(nuv*f*250.0)*2.0+0.5) * smoothstep(0.16, 0.15, dist) * vec3(0.7, 0.9, 1.0), 0.0);\n    \n    // Flaring\n    col += vec3(smoothstep(1.0, c, dist)) * vec3(0.7, 0.9, 1.0) * smoothstep(0.15, 0.16, dist);\n    \n    // Spikes\n    col += vec3(0.1 / abs(uv.y)) * smoothstep(2.0, -5.0, dist) * vec3(0.7, 0.9, 1.0) * smoothstep(1.0, 10.0, zoom);\n    \n    // Glow\n    col += vec3(smoothstep(1.1, 0.0, dist / 4.0) / 3.0) * vec3(0.7, 0.9, 1.0) * smoothstep(0.15, 0.16, dist);\n\n    // Stars\n    col += vec3(0.01 / length(gv));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdVSzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 46, 46, 182], [184, 269, 291, 291, 633], [635, 635, 654, 654, 922], [924, 924, 950, 950, 1034], [1036, 1036, 1093, 1093, 2267]]}
{"id": "NdVSzy", "name": "Waves Morph (03)", "author": "spenceryonce", "description": "Trying some different things here. I like.", "tags": ["waves", "math", "sin", "color", "cos", "trippy", "weird", "morphing"], "likes": 2, "viewed": 43, "published": "Public", "date": "1634852415", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int AMOUNT = 12;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = 20.0 * (fragCoord.xy - iResolution.xy / 2.0) / min(iResolution.y, iResolution.x);\n    \n    float len;\n    \n    for(int i = 0; i < AMOUNT; i++){\n        len = length(vec2(coord.x, coord.y));\n        \n        coord.x = coord.x - cos(coord.y + sin(len)) + cos(iTime / 9.0);\n        coord.y = coord.y + sin(coord.x + cos(len)) + sin(iTime / 12.0);\n    }\n    \n    fragColor = vec4(cos(len * 1.2), cos(len * 1.0), cos(len * 1.0), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdVSzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 81, 81, 530]]}
{"id": "NdVXDD", "name": "41/49", "author": "tono", "description": "41/49", "tags": ["49"], "likes": 11, "viewed": 141, "published": "Public", "date": "1634669573", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat pi = acos(-1.);\nvec3 ppp;\nvec2 map(vec3 p)\n{\n    float o = 10.;\n    float id = 0.;\n    vec3 op = p;\n    p.xz *= rot(sin(p.y/4.));\n    p.xz = abs(p.xz)-3.1;\n    p.xz *= rot(p.y/2.);\n    p.xz = abs(p.xz)-1.;\n    p.xz *= rot(sin(p.y));\n    vec3 pp = p;\n    p.xz *= rot(p.y * pi/3. + iTime);\n    p.y = sin(p.y * pi/3. + iTime);\n    o = length(vec2(length(p.xy)-1.,p.z))-.3;\n \tpp.z += sin(pp.y * pi/3. + iTime)*1.;\n    ppp = pp;\n    //o = min(o,length(pp.xz)-.6);\n    float r = sin(iTime + pp.y/3.) * .5 + .5;\n    float d = length(pp.xz)-r*.7;\n    if(o > d)\n    {\n        o = d;\n    \tid = 1.;\n        ppp = pp;\n    }\n    \n    o = mix(max(length(op)-6.,o),o,.9);\n    //o = (length(op)-3.)/o;\n    o/=1.7;\n\t\n    return vec2(o,id);\n}\n\nvec2 march(vec3 cp , vec3 rd)\n{\n    float depth = 0.;\n    for(int i = 0 ; i< 99 ; i++)\n    {\n        vec3 rp = cp + rd * depth;\n        vec2 d = map(rp);\n        if(abs(d.x) < 0.01)\n        {\n            return vec2(depth,d.y);\n        }\n        if(depth > 30.)break;\n        depth += d.x;\n    }\n    return vec2(-depth , 0.);\n\n}\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tvec3 cp = vec3(0.,0.,-28.);\n    vec3 target = vec3(0.);\n    \n    \n    //cp.xz *= rot(iTime + p.y * 12.);\n    //target.x += sin(iTime);\n    vec3 col = vec3(.0);\n    \n    vec3 cd = normalize(vec3(target - cp));\n    vec3 cs = normalize(cross(cd , vec3(0.,1.,0.)));\n    vec3 cu = normalize(cross(cd,cs));\n    \n    float fov = 2.5;\n    \n    vec3 rd = normalize(cd * fov + cs * p.x + cu * p.y);\n    \n    vec2 d = march(cp,rd);\n    if( d.x > 0.)\n    {\n        vec2 e = vec2(1.0, -1.0) * .01;\n        vec3 pos = cp + rd * d.x;\n        vec3 N = normalize(\n                  e.xyy * map(pos + e.xyy).x +\n                  e.yyx * map(pos + e.yyx).x +\n                  e.yxy * map(pos + e.yxy).x +\n                  e.xxx * map(pos + e.xxx).x);\n        vec3 sun = normalize(vec3(2.,4.,8.));\n        //sun.xz *= rot(iTime);\n        float diff = max(0.,dot(-sun,N));\n        diff = mix(diff , 1.,.1);\n        float sp = max(0.,dot(rd,reflect(N,sun)));\n        sp = pow(sp,33.6) * 10.;\n        float rim = pow(clamp(1. - dot(N, -rd), 0., 1.), 8.) * 3.;\n        vec3 mat = mix(vec3(1.),vec3(1.,0.1,0.1),d.y);\n        mat -= exp(sin(ppp*2.)) * d.y;\n        float up = max(dot(N,vec3(0.,-1.,0.)),0.);\n        float down = max(dot(N,vec3(0.,1.,0.)),0.);\n        \n        col = sp * mat + diff * mat;\n        col += up * vec3(.1) + down * vec3(0.,0.,1.);\n        \n    \tcol -= d.y * mat ;\n        col = floor(col * 3.)/3.;\n        col *= vec3(1.) * sin(pos * (60. + step(.9,sin(p.y+iTime))*30.) ) * max(col.r,max(col.g,col.b));\n    \tcol -= rim *10.;\n        col *= 10.;\n    }\n    //col.r = atan(col.r,col.g)/pi;\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdVXDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 61], [94, 94, 112, 112, 792], [794, 794, 825, 825, 1122], [1123, 1123, 1147, 1147, 1254], [1255, 1255, 1312, 1312, 3028]]}
{"id": "NdVXWz", "name": "Pixelized IceCreamSwirl", "author": "foxic", "description": "Yummy Pixelized IceCreamSwirl. :P", "tags": ["swirl", "pixel", "icecream", "pixelized"], "likes": 5, "viewed": 138, "published": "Public API", "date": "1634485906", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define PixelSize 32.\n\nvec2 rotate2D(vec2 _st,float _angle){\n    _st=mat2(cos(_angle),-sin(_angle),\n    sin(_angle),cos(_angle))*_st;\n    return _st;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy / 2.0) / iResolution.y;\n    uv = ceil(uv*PixelSize)/PixelSize; //pixelise\n\n    vec2 uv1 = rotate2D(uv, (length(uv*5.)+iTime)*2. );\n    uv += vec2(0.,0.025);\n    vec2 uv2 = rotate2D(uv, (length(uv*5.)+iTime)*2. );\n    \n    \n    vec3 col1 = vec3(0.97,0.5,0.74);\n    vec3 col2 = vec3(0.03);\n    vec3 col3 = mix(col1,col2,0.8);\n    col2 = mix(col3,col2,float((uv2.x) > 0.05));\n    \n    vec3 col = mix(col1,col2,float((uv1.x) > 0.));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdVXWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 61, 61, 152], [154, 154, 211, 211, 723]]}
{"id": "NdySDh", "name": "ship on moon 2d", "author": "jorge2017a2", "description": "ship on moon 2d", "tags": ["shiponmoon2d"], "likes": 6, "viewed": 126, "published": "Public API", "date": "1634523954", "time_retrieved": "2021-10-01T00:00:00", "image_code": "///ship on moon 2d-JFP\n///por jorge2017a2...2021-oct-09\n///referencia\n//https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(antialiasing(0.05),b,d)\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n///---------------------------\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n    \nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  //colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.05,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.05,0.0));\n  return colOut;\n}\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\nreturn colOut;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n\nvec4 construccion(vec2 uv,vec3 col)\n{\n\n    float d2= sdTriangleIsosceles(vec2(uv.x, -uv.y)-vec2(-14.0,0.0), vec2(2.0,3.0) );\n    float d3=sdBox(uv-vec2(0.0,-7.0), vec2(15.0,2.0) );\n    float d4=sdBox(uv-vec2(11.0,-3.0), vec2(3.0,2.0) );\n    float d5=sdBox(uv-vec2(-9.5,-4.0), vec2(5.0,1.0) );\n    float d6= sdTriangleIsosceles(vec2(uv.x, -uv.y)-vec2(-4.5,3.0), vec2(2.0,3.0) );\n    \n    float dtot=unionSDF(d2, d3);\n    dtot=unionSDF(dtot, d4);\n    dtot=unionSDF(dtot, d5);\n    dtot=unionSDF(dtot, d6);\n    \n    col= DrawFig(vec3(1.0), col, dtot );\n    return  vec4(col,dtot);\n}\n\nvec3 paisajeLineas(vec2 p, vec3 col)\n{   vec2 uv=p;\n    p.y=opRep1D(p.y, 0.025 );\n    float d1= sdBox(p, vec2(16.0,0.0032) );\n    vec4 col4= construccion(uv,col);   \n    float dt=intersectSDF(d1,col4.w);\n    col= DrawFig(vec3(1.0), col, dt);\n    return col;\n}\n\nvec3 casa1(vec2 p, vec3 col)\n{  float d1= sdBox(p-vec2(10.0,-0.7), vec2(1.0,0.25) ); \n   float d2= sdBox(p-vec2(10.0,-0.7), vec2(0.8,0.2) ); \n   vec2 pos=vec2(10.0,0.0);\n   float d3=sdCircle(p-pos, 1.0 );\n   float d4=sdCircle(p-pos, 0.8 );\n   d3= differenceSDF(d3,d1);\n   d4= differenceSDF(d4,d1);\n   d3= differenceSDF(d3, d4);\n   float dif= differenceSDF(d1, d2);\n   col= DrawFig(vec3(1.0), col, dif);\n   col= DrawFig(vec3(1.0), col,d3);  \n   return col;\n}\n\nvec3 nave(vec2 p, vec3 col)\n{  \n    vec2 uv=p;\n    p= rotatev2(p, radians(90.0));\n\n   float d1= sdTriangleIsosceles( p, vec2(1.5,1.5) ) ;\n   float d2= sdTriangleIsosceles( p-vec2(0.0,0.2), vec2(1.1,1.2) ) ;\n   float d3= sdTriangleIsosceles( p-vec2(0.0,0.95), vec2(1.2,1.2) ) ;\n   \n    d1= differenceSDF(d1, d3);\n    d2= differenceSDF(d2, d3);\n   float dif= differenceSDF(d1, d2);\n   \n   col= DrawFig(vec3(1.0), col,dif);\n   vec2 rep=uv;\n   rep.x=mod(uv.x-1.0+iTime*5.0,2.0);\n   float d5= sdBox(rep, vec2(0.5,0.05) );\n   float d6= sdBox(uv-vec2(7.5,0.0), vec2(8.0,0.5) );\n   d5= differenceSDF(d5, d6);\n   \n   float d5b= sdBox(rep, vec2(0.5,0.08) );\n   float d6b= sdBox(uv-vec2(7.5,0.0), vec2(8.0,0.8) );\n   d5b= differenceSDF(d5b, d6b);\n   \n   col= DrawFig(vec3(1.0,1.0,0.0), col,d5b);\n   col= DrawFig(vec3(1.0,0.0,0.0), col,d5);\n   return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    vec3  col=vec3(0.0);\n    uv*=8.0;\n    vec2 uv1=uv;\n    vec2 uv2=uv;\n        \n    col= paisajeLineas(uv, col);\n    col= casa1(uv, col);\n    col= nave(uv-vec2(sin(iTime), cos(iTime)), col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdySDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 309, 343, 343, 438], [440, 471, 507, 507, 552], [557, 601, 648, 648, 675], [676, 676, 719, 719, 746], [747, 747, 795, 795, 823], [829, 829, 891, 891, 1087], [1089, 1089, 1170, 1170, 1300], [1302, 1302, 1359, 1359, 1425], [1427, 1427, 1464, 1464, 1544], [1546, 1546, 1581, 1581, 1604], [1606, 1606, 1657, 1657, 1965], [1968, 1968, 2005, 2005, 2546], [2548, 2548, 2586, 2586, 2807], [2809, 2809, 2839, 2839, 3266], [3268, 3268, 3297, 3297, 4113], [4116, 4116, 4173, 4173, 4492]]}
{"id": "NdySWt", "name": "Circle-gradient", "author": "Taytweets", "description": "Mouse X - speed up/slowdown\nMouse Y - zoom in/out\n@killedbyapixel mod\n@FabriceNeyret - helped simplify & mouse animation", "tags": ["vogelspiral"], "likes": 1, "viewed": 71, "published": "Public", "date": "1635455418", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M iMouse\n#define R iResolution\n#define T iTime\n#define pi 3.14\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{vec2 m = ( iMouse.xy != vec2(0) ) ? M.xy/R.y*.5 : .5+.5*vec2(cos(T),sin(T)),\nu=25.*m.y*(gl_FragCoord.rg-R.rg/2.)/R.r;\nfloat d=pow(2.*length(u),1.2),\nt=.005*(T*15.*m.x),\ni=floor(d-atan(u.g,u.r)/pi/2.+.8),\na=atan(u.g,u.r)+pi*2.*i,\nh=.2*a+2.2*t,\ns=fract(a*.5/t)<.5?1.:0.,\nv=fract(a*.5/t)<1.5?0.:0.;\nfragColor=vec4(vec3(v+s*v*5.5)*vec3(s/v)+cos(pi*2.*(h+vec3(1.,.888,.666))),1.);}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdySWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 126, 126, 502]]}
{"id": "NdyXRG", "name": "Stroboscopic Display", "author": "rmccampbell7", "description": "*Flashing light warning*\nInspired by https://www.youtube.com/watch?v=2h312IVR6Ww&ab_channel=3DprintedLife", "tags": ["strobeeffect"], "likes": 3, "viewed": 49, "published": "Public", "date": "1634788678", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float DROPSPEED = 6.;\nconst vec2 DROPSPACING = vec2(.03, .04);\nconst float DROPSIZE = .015;\nconst float PERIOD = 1./DROPSPEED;\nconst float STROBEDUR = .1*PERIOD;\nconst vec3 DROPCOLOR = vec3(.5,.8,1);\n\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\n// Put any binary function in here which can change over time\nbool getImage(vec2 p, float t) {\n    float s = .2*sin(6.28*t)+1.;\n    return sdCircle(p*vec2(s,1./s), .3) < 0.;\n}\n\nstruct Coords {\n    vec2 local;\n    vec2 global;\n};\n\nCoords getDropCoords(vec2 p, float t, float t2) {\n    vec2 local = mod(p + vec2(0, t*DROPSPEED), DROPSPACING) - .5*DROPSPACING;\n    local += vec2(0, (t2-t)*DROPSPEED);\n    vec2 global = p - local;\n    return Coords(local, global);\n}\n\nfloat getDropsDist(vec2 p) {\n    float prevStrobeTime = floor(iTime/PERIOD)*PERIOD;\n    float nextStrobeTime = prevStrobeTime + PERIOD;\n    vec2 local = getDropCoords(p, iTime, iTime).local;\n    vec2 prevStrobePos = getDropCoords(p, iTime, prevStrobeTime).global;\n    vec2 nextStrobePos = getDropCoords(p, iTime, nextStrobeTime).global;\n    bool prevStrobeInImage = getImage(prevStrobePos, prevStrobeTime);\n    bool nextStrobeInImage = getImage(nextStrobePos, nextStrobeTime);\n    bool dropInImage = prevStrobeInImage || nextStrobeInImage;\n    float dropDist = sdCircle(local, DROPSIZE/2.);\n    return dropInImage ? dropDist : 1.;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 drop = smoothstep(.005, -.005, getDropsDist(uv)) * DROPCOLOR;\n    float strobe = step(mod(iTime+.5*STROBEDUR, PERIOD), STROBEDUR);\n    float lighting = mix(.2, 1., strobe);\n\n    vec3 col = drop * lighting;\n    // Uncomment to view image directly\n    //col = float(getImage(uv, iTime)) * DROPCOLOR;\n\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdyXRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[207, 207, 240, 240, 268], [270, 332, 364, 364, 445], [500, 500, 549, 549, 732], [734, 734, 762, 762, 1366], [1368, 1368, 1420, 1420, 1822]]}
{"id": "NdyXRt", "name": "drapes 2", "author": "FabriceNeyret2", "description": "Folds are modeled as circle sections of unit length curved to accommodate the target linear length.\nSee [url]https://www.desmos.com/calculator/umrflmd6dm[/url]\n\nMouse controls camera.", "tags": ["raymarching", "short", "folds", "drapes"], "likes": 13, "viewed": 178, "published": "Public API", "date": "1635083418", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rot(a)   mat2(cos(a+vec4(0,11,33,0)))                          // rotation\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\nvoid mainImage(out vec4 O, vec2 U) \n{\n    float t=9.,d, l,A,r,s,u,v;                           \n    vec3  R = iResolution,\n          D = normalize(vec3((U+U-R.xy)/R.y, -2.)),                    // ray direction\n          p = vec3(0,-2,22), q,a,                                      // marching point along ray \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(10,12,0)/1e2*cos(.3*iTime+vec3(0,11,0))+vec3(0,.12,0); \n\n    for ( O=vec4(1); O.x > 0. && t > .005; O-=.005 )          \n        q = p,\n        q.yz *= rot(.5-6.3*M.y),                                       // rotations\n        q.xz *= rot(-6.3*M.x), \n        a = abs(q), \n        v = .6 +.4*q.y/10.,                                            // normalized height\n        l = mix(1., v, .5+.5*sin(iTime) ) -1e-3,     // drape extension: 1 = no folds,  0.2 = max folds\n        u = floor(q.x/l),\n        A = 1.1*acos(2.*l-1.) +2.*acos(l), r = 1./A, // folds angle & radius, see https://www.desmos.com/calculator/umrflmd6dm\n        q.x = mod( q.x+l*float(q.z<0.) , 2.*l ) -l/2., \n        q.xz -= r * vec2( sin(A/2.),-sign(q.z)*cos(A/2.) ), \n        t = abs(length(q.xz) - r) -.01,\n        t = max(t, max(a.x-10.*l,a.y-10.) ) ,\n\n        p += .25*t*D;                                                  // step forward = dist to obj\n\n    O *= .5+.5*texture(iChannel0,vec2(.5+.05*( u + fract(atan(q.x,abs(q.z))/A) ) , v )); // material\n}\n", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdyXRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[149, 149, 186, 186, 1542]]}
{"id": "NdyXWd", "name": "jneen - 3d sprixels again", "author": "jneen", "description": "using sprites as pixels to render a 3d scene", "tags": ["sprixel", "jneen"], "likes": 11, "viewed": 139, "published": "Public", "date": "1635470429", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define I (1.)\n#define O (0.)\n#define time (iTime*.5)\n\nvec2 uv;\n\nfloat[16] T1 = float[16](\n  I,O,O,O,\n  O,O,O,O,\n  O,O,I,O,\n  O,O,O,O\n);\n\nfloat[16] T2 = float[16](\n  O,O,I,O,\n  O,I,O,O,\n  I,O,O,O,\n  O,I,O,O\n);\n\nfloat[16] T3 = float[16](\n  O,I,I,O,\n  I,O,I,I,\n  O,I,O,I,\n  O,O,I,O\n);\n\nfloat[16] T4 = float[16](\n  I,I,I,I,\n  I,O,I,I,\n  I,I,I,I,\n  I,I,O,I\n);\n\nfloat px(float[16] arr, vec2 p) {\n  p = fract(p);//mod(p, 1.);\n  int x = int(p.x*4.);\n  int y = int((1.-p.y)*4.);\n  return arr[4*y+x];\n}\n\nmat2 rot(float x) { float s=sin(x),c=cos(x); return mat2(c,s,-s,c); }\n\n\n#define nsin(x) (.5+.5*sin(x))\n#define pmod(x,j) (mod(x,j)-.5*(j))\n\n#define MISS(x) (x>1000.)\n\n\nfloat sphere(vec3 p, float r) { return length(p)-r; }\nfloat box(vec3 p, vec3 a) {\n  vec3 q = abs(p)-a;\n  return length(max(q, 0.)) + min(max(q.x,max(q.y,q.z)),0.);\n}\n\nfloat boxle(vec3 p, float r, float q) {\n  return max(box(p, vec3(r)),-sphere(p,q*r));\n}\n\nfloat S(vec3 p) {\n  //p+=vec3(.2,.2,2);\n  float rad = fract(time);\n  float S = 1001.;\n  \n  float ft=1.;\n  \n  for (float i=0.;i<=2.;i+=1.){\n    float r=rad+i;\n    p.xz *= rot(r*.35);\n    p.xy *= rot(r*.1);\n    p.xy *= rot(r*.05);\n\n    S = min(S, boxle(p, r, 1.+.07*r*r*r));\n  }\n \n\n\n  return S;\n}\n\nfloat ray(vec3 p, vec3 dir) {\n  float d=0.;\n  for(int i=0;i<50;i++){\n    float c=S(p+d*dir);\n    d+=c;\n    if (c<.1) return d;\n    if (MISS(d)) return d;\n  }\n  \n  return d;\n}\n\nvec3 normal(vec3 p) {\n  mat3 k = mat3(p,p,p)-mat3(1e-3);\n  return normalize(S(p)-vec3(S(k[0]), S(k[1]),S(k[2])));\n}\n\nfloat light(vec3 o, vec3 dir, float dist) {\n  vec3 hit = o+dir*dist;\n  vec3 n = normal(hit);\n  \n  float diff = dot(dir,-n);\n  \n  return diff;\n}\nvec3 HUE = vec3(0);\n\n\nfloat pxsel(float x, vec2 p) {\n  x *= 3.5;\n  x-=.1;\n  \n  if (x<1.) { HUE=vec3(0, p); return px(T1,p); }\n  if (x<2.) { HUE=vec3(p,0); return px(T2,p); }\n  if (x<3.) { HUE=vec3(p.y,0,p.x);return px(T3,p); }\n  return px(T4,p);\n}\n\n#define tri(x) (2.*abs(.5-fract(x)))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n     uv = fragCoord/iResolution.xy;\n    uv-=.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 C;\n    \n    float RES=mix(4., 64., tri(.1*time+.3));\n    \n    \n    vec2 px_aln = uv;\n    px_aln *= RES;\n    px_aln = floor(px_aln);\n    px_aln /= RES;\n    \n    vec3 o = vec3(0,0,-5);\n    vec3 dir = normalize(vec3(px_aln,1));\n    \n    float dist = ray(o,dir);\n    float l = light(o,dir,dist);\n\n    if (MISS(dist)) {\n      C=pxsel(.5, uv*RES)+HUE*.02;\n      C*=.5;\n    }\n    else {\n      float pix = pxsel(light(o,dir,dist),RES*(uv-px_aln));\n      C = vec3(rot(time)*uv+1.,0)*pix;\n    }\n    \n    C = C.zxy;\n    \n    // Output to screen\n    fragColor = vec4(sqrt(C),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdyXWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[357, 357, 390, 390, 493], [495, 495, 514, 514, 564], [663, 663, 694, 694, 716], [717, 717, 744, 744, 828], [830, 830, 869, 869, 917], [919, 919, 936, 958, 1213], [1215, 1215, 1244, 1244, 1389], [1391, 1391, 1412, 1412, 1506], [1508, 1508, 1551, 1551, 1651], [1674, 1674, 1704, 1704, 1899], [1939, 1939, 1996, 2046, 2720]]}
{"id": "Nlc3zn", "name": "Fractal weirdness 2", "author": "jarble", "description": "A simple fractal pattern.", "tags": ["fractal"], "likes": 1, "viewed": 101, "published": "Public API", "date": "1635553319", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;\n    vec2 uv1 = ((fragCoord)*10.0-iResolution.xy)/iResolution.y/40.;\n    uv1.y -= 2.3;\n    uv1 += iTime/160.;\n    for(int c=0;c<3;c++){\n        vec2 uv = uv1;\n        for(int i=0;i<6;i++)\n        {\n            uv = fract((uv.y+uv.x+uv)*(1.-col.y));\n            uv *= (uv.x-uv.y);\n            //col += col.yzx/16./16.;\n            col[c] += (uv.y-uv.x);\n        }\n\n\t}\n    \n    fragColor = vec4(fract(col),1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nlc3zn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 515]]}
{"id": "NlcGzr", "name": "Self tangling wires", "author": "NLIBS", "description": "This is what wires do when you're not looking", "tags": ["2d", "repetition", "wires"], "likes": 28, "viewed": 282, "published": "Public API", "date": "1635569190", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi acos(-1.)\n#define M1 1597334677U\n#define hash(n) float(n*(n^(n>>15)))/float(0xffffffffU)\n\nvoid mainImage(out vec4 O,vec2 U) {\n    vec2 R = iResolution.xy,\n         uv = (2.*U-R)/R.x;\n    \n    O = vec4(0.);\n    for (int k = 0; k<3; k++) { //Loop over layers of wires\n        for (int i = -10; i<=12; i++) { //Loop over neighboring wires\n            vec2 s = uv+vec2(i,0)/40.;\n            float sx0 = floor(s.x*40.+1e-4);\n            \n\n            vec2 p = vec2(0.);\n            float f = hash(uint(float(k*100)+s.x*40.+100.)*M1)*0.1;\n            for (int j = 1; j<10; j++) { //Create a wave function\n                f = f*1.3+.1;\n                float t = (s.y*f+iTime*(1.-s.y*.5)*.1)*12.+f*100.;\n                p += vec2(sin(t),(f-.04*iTime)*cos(t))/f*.1;\n            }\n            float x = uv.x*40.-p.x*float(1+k)*min(iTime*.3,1.);\n            x = (x-sx0-.5)/sqrt(p.y*p.y+1.)+sx0+.5; //Better thickness\n            \n            if (x>sx0 && x<1.+sx0) {\n                O = (pow(cos((hash(uint(x+100.)*M1)*2.4+vec3(-.1,.6,.7))*pi*.6)*.5+.6,vec3(1,2,3))*(1.-pow((fract(x)-.5)*1.9,2.))).rgbb;\n                \n                //Noodles variant\n                //O = ((vec3(.8,.6,.1)-vec3(0,.3,.06)*hash(uint(x+100.)*M1))*(1.-pow((fract(x)-.5)*1.9,2.))).rgbb;\n            } else\n                O = O*min((abs(x-sx0-.5)-.2)*.65,1.);\n        }\n    }\n    O = pow(O,vec4(1./2.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlcGzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 101, 136, 136, 1389]]}
{"id": "NldGRr", "name": "Footwear Design 002", "author": "yasuo", "description": "・Improved the outsole and upper shape\n・Added the herringbone traction pattern\n", "tags": ["footwear"], "likes": 8, "viewed": 133, "published": "Public API", "date": "1635616255", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define Slice(p,a) dot(p,vec2(cos(a),sin(a)))\n#define S(p,d,b) smoothstep(fwidth(p.y),0.0,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define MATERIAL_OUTSOLE 0\n#define MATERIAL_MIDSOLE1 1\n#define MATERIAL_MIDSOLE2 2\n#define MATERIAL_UPPER 3\n\n#define ZERO (min(iFrame,0))\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n// IQ's 3D noise function. It's faster than the FBM and enough for me to design.\n// The compile is also faster.\nfloat noise3d( vec3 p )\n{\n\tconst vec3 s = vec3(27, 111, 57);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); \n    //p *= p*p*(p*(p*6. - 15.) + 10.); // option\n    h = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); \n}\n\nvec2 combine(vec2 val1, vec2 val2 ){\n    return (val1.x < val2.x)?val1:val2;\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.yz),p.x)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdSimpleCylinder(vec3 p, float r, float h){\n    float d = length(p.xz)-r;\n    d = max(abs(p.y)-h,d);\n    return d;\n}\n\nfloat baseOutsole(vec3 p, float h){\n    vec3 prevP = p;\n    \n    p.xz*=Rot(radians(17.0));\n    p.z*=0.4;\n    p.x*=0.57;\n    p.x+=0.03;\n    p.z-=0.07;\n    \n    float d =sdSimpleCylinder(p,0.1,h);\n    \n    p = prevP;\n    p.xy*=Rot(radians(90.0));\n    p.y*=1.5;\n    p.z*=1.2;\n    float d2 = sdCappedCylinder(p-vec3(0.0,0.0,-0.25),h,0.2);\n    d = opSmoothUnion(d, d2,0.13);\n    \n    p = prevP;\n    d = max(abs(p.y)-h,d);\n    \n    return (d)*0.6;\n}\n\nfloat outsole(vec3 p){\n    vec3 prevP = p;\n    float d = baseOutsole(p,0.02);\n    \n    // herringbone traction\n    p.xz*=2.3;\n    p.xz = mod(p.xz,0.1)-0.05;\n    p.x=abs(p.x)-0.03;\n    p.xz*=Rot(radians(45.0));\n    float d2 = sdBox(p,vec3(0.01,0.02,0.06))*0.6;\n    \n    d = max(d,d2);\n    p = prevP;\n    d2 = baseOutsole(p-vec3(0.0,0.01,0.0),0.01);\n    d = min(d,d2);\n    \n    return d;\n}\n\nvec2 midsole(vec3 p){\n    float d = baseOutsole(p-vec3(0.0,0.06,0.0),0.04);\n    \n    p.yz*=Rot(radians(-3.0));\n    float mask = p.y-0.07;\n    d = max(mask,d);\n    \n    vec2 model = vec2(d,MATERIAL_MIDSOLE1);\n    \n    return model;\n}\n\nfloat upperBase(vec3 p){\n    vec3 prevP = p;\n\n    p.x*=1.2;\n    p.z*=0.8;\n    \n    float d =sdCappedCone(p-vec3(0.0,0.18,-0.15),0.13,0.15,0.09);\n    \n    p = prevP;\n    p.xz*=Rot(radians(15.0));\n    p.yz*=Rot(radians(-3.0));\n    p.x*=1.2;\n    p.z*=0.8;\n    \n    float d2 = sdEllipsoid(p-vec3(-0.05,0.1,0.13),vec3(0.2,0.08,0.2));\n    d = opSmoothUnion(d,d2,0.1);\n    \n    p = prevP;\n    p.xz*=Rot(radians(15.0));\n    p.x*=1.2;\n    p.z*=0.8;\n    p.yz*=Rot(radians(-35.0));\n    d2 = sdEllipsoid(p-vec3(0.0,0.21,-0.1),vec3(0.1,0.04,0.12));\n    d = opSmoothUnion(d,d2,0.15);\n\n    p = prevP;\n    p.yz*=Rot(radians(-15.0));\n    d2 = sdBox(p-vec3(0.0,0.14,-0.378),vec3(0.02,0.11,0.0005))-0.005;\n    d = opSmoothUnion(d,d2,0.03);\n\n    p = prevP;\n    p.yz*=Rot(radians(-3.0));\n    d2 = baseOutsole(p-vec3(0.0,0.08,0.0),0.01);\n    d = opSmoothUnion(d,d2,0.015);\n\n    return d;\n}\n\nfloat upper(vec3 p){\n    vec3 prevP = p;\n    float d = upperBase(p);\n    p.x*=1.4;\n    \n    \n    float d2 = upperBase(p-vec3(0.0,-0.02,0.0));\n    d = max(-d2,d);\n    \n    p = prevP;\n    \n    p.x*=1.8;\n    p.z*=0.9;\n    \n    d2 =sdCappedCone(p-vec3(0.0,0.3,-0.14),0.13,0.15,0.09)*0.6;\n    d = max(-d2,d);\n    \n    return d*0.8;\n}\n\n\n\nvec2 GetDist(vec3 p) {\n    p+=noise3d(p*300.0)*0.001;\n    vec3 prevP = p;\n    \n    p.y+=0.075;\n   // p.z+=0.1;\n    float d = outsole(p);\n    \n    vec2 model = vec2(d,MATERIAL_OUTSOLE);\n    \n    vec2 model2 = midsole(p);\n    \n    \n    d = upper(p);\n    \n    vec2 model3 =vec2(d,MATERIAL_UPPER);\n    \n    return combine(model,combine(model2,model3));\n    \n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n    \n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<4; i++ )\n    {\n        float h = 0.01 + 0.15*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    float occ = calcOcclusion(p,n);\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(1,2,-2));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    float shadow = step(RayMarch(p+n*0.3,lightDir,1.0, 15).x,0.9);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(-0.5)*diff*shadow*occ;\n    diffCol += col*vec3(1.0,1.0,0.9)*skyDiff*occ;\n    diffCol += col*vec3(0.3,0.3,0.3)*bounceDiff*occ;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 20.)*occ; // spec\n        \n    return diffCol;\n}\n\nvec3 upperTex(vec2 uv, vec3 col){\n        vec2 prevUV = uv;\n        uv = mod(uv,0.08)-0.04;\n        uv.y-=0.03;\n        uv.x=abs(uv.x)-0.05;\n        uv*=Rot(radians(45.0));\n        \n        float d = B(uv,vec2(0.01,0.08));\n        col = mix(col,vec3(0.2,0.3,0.5),S(prevUV,d,0.0));\n        return col;\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    float nn = noise3d(p*160.0)*0.05;\n     float nn2 = noise3d(p*20.0)*0.2;\n    if(mat == MATERIAL_OUTSOLE){\n        col = diffuseMaterial(n,rd,p,vec3(1.0,1.0,0.9))+nn;\n    } else if(mat == MATERIAL_MIDSOLE1){\n        col = diffuseMaterial(n,rd,p,vec3(0.4,0.3,0.5))+nn;\n    } else if(mat == MATERIAL_MIDSOLE2){\n        col = diffuseMaterial(n,rd,p,vec3(0.6,0.6,0.6))+nn;\n    } else if(mat == MATERIAL_UPPER){\n        \n        col = diffuseMaterial(n,rd,p,vec3(0.3,0.5,0.6)-upperTex(p.xz,col)+nn2+nn2);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec2 m =  iMouse.xy/iResolution.xy -.3;\n    \n    vec3 ro = vec3(0, 0, 1.0);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(radians(-30.0));\n    if(iMouse.z>0.){\n        ro.yz *= Rot(-m.y*3.14+1.);\n        ro.xz *= Rot(-m.x*6.2831);\n    } else {\n        ro.xz *= Rot(radians(-5.0+iTime*20.0));\n        \n        //ro.yz *= Rot(radians(120.0));\n        //ro.xz *= Rot(radians(45.0));\n    }\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(1.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n        //col *= exp( -0.038*d.x*d.x*d.x );//fog\n    } else {\n        //col = upperTex(uv,col);\n    }\n    \n    \n    // gamma correction\n    col = pow( col, vec3(0.9545) );    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NldGRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 479, 504, 504, 523], [524, 524, 549, 549, 568], [569, 569, 621, 621, 721], [723, 835, 860, 860, 1199], [1201, 1201, 1237, 1237, 1279], [1281, 1356, 1408, 1408, 1515], [1517, 1592, 1623, 1623, 1710], [1712, 1787, 1824, 1824, 1907], [1909, 1984, 2043, 2043, 2356], [2358, 2358, 2407, 2407, 2480], [2482, 2482, 2517, 2517, 2925], [2927, 2927, 2949, 2949, 3314], [3316, 3316, 3337, 3337, 3548], [3550, 3550, 3574, 3574, 4417], [4419, 4419, 4439, 4439, 4747], [4751, 4751, 4773, 4773, 5106], [5108, 5108, 5166, 5166, 5433], [5435, 5435, 5459, 5459, 5660], [5662, 5662, 5704, 5704, 5899], [5901, 5942, 5991, 5991, 6282], [6284, 6284, 6341, 6341, 6960], [6962, 6962, 6995, 6995, 7264], [7266, 7266, 7325, 7325, 7851], [7853, 7853, 7910, 7910, 8954]]}
{"id": "Ns3SWj", "name": "demo webgl vs canvas", "author": "ninofiliu", "description": "Same in canvas:\nhttps://jsfiddle.net/pr5gkc12/", "tags": ["demo"], "likes": 0, "viewed": 104, "published": "Public API", "date": "1633911541", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float s = sin(fragCoord.x/iResolution.x+iTime);\n    s += s < 0.0 ? 1.0 : 0.0;\n    fragColor = vec4(vec3(s), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns3SWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 175]]}
{"id": "Ns3XD7", "name": "Lesson-0126", "author": "xlat", "description": "Lesson-0126", "tags": ["fragmentshader"], "likes": 1, "viewed": 37, "published": "Public", "date": "1633281589", "time_retrieved": "2021-10-01T00:00:00", "image_code": "///----------------------------------------------------------------------------|\n/// XLAT\n/// www.cyberforum.ru\n///----------------------------------------------------------------------------:\n\n///----------------------------------|\n/// Координаты(верхнего левого угла) | \n/// квадрата и его размер.           |\n/// (уже нормированные)              |\n///----------------------------------:\nvec3 Q1 = vec3(0.2 , 0.5, 0.3);\nvec3 Q2 = vec3(0.51, 0.5, 0.2);\nvec3 Q3 = vec3(0.72, 0.5, 0.1);\n///----------------------------------.\n\nconst vec4  RED = vec4(0.6, 0. , 0. , 1.);\nconst float PI  = 3.14;\n\nvec4 tonsin(float minn, float maxx, float a)\n{   a = a - minn;\n    float x = PI / (maxx - minn);\n    float c  = 0.8  * sin(a * x)+0.1;\n    return vec4(0.1, c, 0.1, 0.9);\n}\n\n///----------------------------------|\n/// Пиксели фигуры.                  |\n///----------------------------------:\nvec4 colorquad(vec2 pos, vec3 q)\n{   float k = iResolution.y / iResolution.x;\n\n    if(     q.x < pos.x && pos.x < (q.x+q.z) &&\n            q.y < pos.y && pos.y < (q.y+q.z*k)  )\n    {   \n        return tonsin(q.x, q.x+q.z, pos.x);\n    }\n    return vec4(0.0);\n}\n\nvec2 get_center(vec3 q)\n{   return vec2(q[0] + q.z / 2., q[1]+q[2]/3.56);\n}\n\n///----------------------------------|\n/// Обводка.                         |\n///----------------------------------:\nvec4 colorborder(vec2 pos, vec3 q)\n{   \n    vec4 t = colorquad(pos, q);\n    if(t.a > 0.) return t;\n\n    float k = iResolution.y / iResolution.x;\n\n    vec2 center = get_center(q);\n    vec2 skyle  = (center - pos) * 0.9;\n    \n    pos = skyle + center;\n\n    if(     q.x < pos.x && pos.x < (q.x+q.z) &&\n            q.y < pos.y && pos.y < (q.y+q.z*k)  )\n    {   \n        return RED;\n    }\n    return vec4(0.0);\n}\n\n///----------------------------------------------------------------------------|\n/// Run.\n///----------------------------------------------------------------------------:\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord/iResolution.xy;\n         uv = vec2(1.- uv.y+cos(iTime)*0.1, uv.x+sin(iTime)*0.1);\n    \n    fragColor   = colorborder(uv, Q1)\n                + colorborder(uv, Q2)\n                + colorborder(uv, Q3);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns3XD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[548, 656, 702, 702, 827], [829, 959, 993, 993, 1218], [1220, 1220, 1245, 1245, 1295], [1297, 1421, 1457, 1457, 1828], [1830, 2001, 2058, 2058, 2290]]}
{"id": "Ns3XDf", "name": "TestFirstShader", "author": "Falco524", "description": "First shader", "tags": ["test"], "likes": 1, "viewed": 16, "published": "Public", "date": "1634044683", "time_retrieved": "2021-10-01T00:00:00", "image_code": "bool IsInLosange(vec3 o, vec3 p, float r)\n    {\n        if((abs(o.x - p.x) + abs(o.y - p.y) + abs(o.z - p.z))*0.333333<r )\n            return true;\n        else\n            return false;\n    }\n    \nbool IsInCircle(vec3 o, vec3 p, float r)\n    {\n        if(sqrt((o.x-p.x)*(o.x-p.x) + (o.y-p.y)*(o.y-p.y))<r)\n            return true;\n        else\n            return false;\n    }\n    \nbool IsInBedo(vec3 o, vec3 p, float r)\n    {\n        if(abs(o.x - p.x)<r && abs(o.y - p.y)<r/2.0 && abs(o.z - p.z)<r)\n            return true;\n        else\n            return false;\n    } \n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = vec3(0,0,0);\n    \n    vec3 o = vec3(0.5,0.5,0.3);\n    \n    vec3 eye1= vec3(sin(iTime + 0.5)*0.1+0.3,+sin(iTime +0.25+1.57)*0.1+0.6,0.3);\n    \n    vec3 eye2= vec3(sin(iTime + 0.5)*0.1+0.7,+sin(iTime +0.25+1.57)*0.1+0.6,0.3);\n    \n    float r = 0.1;\n    \n    if(IsInLosange(o, vec3(uv.xy,0.0),0.3))\n        col = 0.5 + 0.5*cos(iTime + uv.xyx+vec3(0,2,4));\n        \n    if(IsInCircle(vec3(0.3,0.6,0.5), vec3(uv.xy,0.0),0.15))\n        col = 0.5 + 0.5*sin(iTime + uv.xyx+vec3(0,2,4));\n        \n    if(IsInCircle(vec3(0.7,0.6,0.5), vec3(uv.xy,0.0),0.15))\n        col = 0.5 + 0.5*sin(iTime + uv.xyx+vec3(0,2,4));\n        \n    if(IsInCircle(vec3(0.5,0.2,0.5), vec3(uv.xy,0.0),0.2))\n        col = 0.5 + 0.5*sin(iTime + uv.xyx+vec3(0,2,4));\n    \n    if(IsInCircle(eye1, vec3(uv.xy,0.0),0.05))\n        col = vec3(1,1,1);\n    \n    if(IsInCircle(eye2, vec3(uv.xy,0.0),0.05))\n        col = vec3(1,1,1);\n        \n\n    if(IsInBedo(vec3(0.3,0.2,0.0), vec3(uv.xy,0.0),r))\n        col = vec3(0.4,0.15,0.15);\n    \n    if(IsInBedo(vec3(0.2,0.2,0.0), vec3(uv.xy,0.0),r))\n        col = vec3(1,1,1);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns3XDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 47, 47, 192], [198, 198, 244, 244, 376], [382, 382, 426, 426, 569], [575, 575, 632, 683, 1910]]}
{"id": "Ns3XDS", "name": "Spirally Spirals", "author": "SnoopethDuckDuck", "description": "Just messing about, neat code", "tags": ["cool"], "likes": 1, "viewed": 102, "published": "Public API", "date": "1633797159", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    float a = atan(uv.y, uv.x);\n    float r = length(uv);\n   \n    // uncomment me\n    // r = length(uv) * (1. + min(abs(1./uv.x), abs(1./uv.y)));\n    // r *= r;\n    \n          uv = vec2(cos(1. * r + a + iTime), sin(2. * r + a - iTime));\n    vec2 uv2 = vec2(cos(2. * r + a - iTime), sin(4. * r + a + iTime));\n \n    float b = .5 + .5 * cos(0.8 * iTime);   \n    uv = mix(uv, uv2, b);\n    \n    float val = smoothstep(.26, .34, (.3 + .05 * cos(iTime)) * length(cos(2. * uv)));\n    val *= 0.95 + h21(uv);\n    \n    fragColor = vec4(val);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns3XDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 95], [97, 97, 154, 154, 752]]}
{"id": "Ns3XWf", "name": "Spiraled Layers", "author": "Tater", "description": "I'm really enjoying using ray intersection to remove repetition artifacts, it opens up so many possibilities. \n\nIt also looks cool if you reverse time", "tags": ["3d", "raymarching", "sdf", "spiral", "roll", "rolling"], "likes": 163, "viewed": 6748, "published": "Public API", "date": "1634144285", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.1415926535\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n#define STEPS 200\n#define MDIST 100.0\n\n//some neat animation\n//#define FUN_MODE\n\n//Reverse time\n//#define iTime -iTime\n\n//Change to 2.0 for AA\n#define AA 1.0\n\nvec3 rdg = vec3(0);\nfloat ext(vec3 p, float s, float h){\n  vec2 b = vec2(s,abs(p.y)-h);\n  return min(max(b.x,b.y),0.)+length(max(b,0.));\n}\nfloat h11(float a) {\n    a+=0.65343;\n    return fract(fract(a*a*12.9898)*43758.5453123);\n}\nfloat diplane(vec3 p,vec3 b,vec3 rd){\n    vec3 dir = sign(rd)*b;   \n    vec3 rc = (dir-p)/rd;\n    return rc.z+0.01;\n}\nfloat lim(float p, float s, float lima, float limb){\n    return p-s*clamp(round(p/s),lima,limb);\n}\nfloat idlim(float p, float s, float lima, float limb){\n    return clamp(round(p/s),lima,limb);\n}\nfloat lim2(float p, float s,  float limb){\n    return p-s*min(round(p/s),limb);\n}\nfloat idlim2(float p, float s, float limb){\n    return min(round(p/s),limb);\n}\nfloat spiral(vec2 p, float t, float m, float scale, float size, float expand){\n    size-=expand-0.01;\n    //Offset Spiral To the left\n    t = max(t,0.);\n    \n    p.x+=pi*-t*(m+m*(-t-1.));\n    t-=0.25;\n    \n    vec2 po = p;\n    //Move Spiral Up\n    p.y+=-t*m-m*0.5;\n    \n    //Counter the rotation\n    p*=rot(t*pi*2.+pi/2.);\n    \n    //Polar Map\n    float theta = atan(p.y,p.x);\n    theta = clamp(theta,-pi,pi);\n    p = vec2(theta,length(p));\n    \n    //Create Spiral\n    p.y+=theta*scale*0.5;\n\n    //Duplicate Line outwards to fill spiral\n    float py = p.y;\n    float id = floor((p.y+m*0.5)/m);\n    p.y = lim(p.y,m,0.,floor(t));\n        \n    //Line SDF of the spiral\n    float a = abs(p.y)-size;\n    \n    //Calcuate moving outer spiral segment\n    p.y = py;\n    p.x -= pi;\n    p.y -= (floor(t)+1.5)*m-m*0.5;\n    float b = max(abs(p.y),abs(p.x)-(pi*2.)*fract(t)+size );\n    \n    //The unrolled Line SDF\n    a = min(a,b-size);\n    b = abs(po.y)-size;\n    b = max(po.x*30.,b);\n    \n    //Combine Them\n    a = min(a,b);\n\n    return a;\n}\nvec3 map(vec3 p){\n    vec2 a = vec2(1);\n    vec2 b = vec2(1);\n    float c = 0.;\n    float t = iTime; \n\n    float size = 0.062; //Thickness of spiral curls\n    float scale = size-0.01; //Space between spiral curls\n    \n    float expand = 0.04; //Corner Rounding Amount \n\n    float m2 = size*6.0; //Repetition Sizes\n    float m = pi*scale; //Repetition Sizes\n    \n    float ltime = 10.0; //How often the spirals rolls repeat\n    \n    p.y-=(t/ltime)*size*6.; //Move everything upwards so it stays in frame\n    \n    p.x-=3.;  //small offset for framing\n    \n    float width = 0.5; //Lane Width\n    float count = 6.0; //Number of spirals (x2)\n    \n    float modwidth = width*2.0+0.04+0.06;\n    \n    float id3 = idlim(p.z,modwidth,-count,count);\n    t+=h11(id3*0.76)*8.0; //it took like 15 minutes to find this seed\n    p.z = lim(p.z,modwidth,-count,count);\n    \n    #ifdef FUN_MODE\n        scale+=(sin(t)*0.5+0.5)*0.05;\n        m = pi*scale;\n    #endif\n    \n    float to = t;\n    vec3 po = p;\n\n    //Spiral 1\n    float stack = -floor(t/ltime);\n    float id2 = idlim2(p.y,m2,stack);\n    t+=id2*ltime;\n    p.y = lim2(p.y,m2,stack);\n    a.x = spiral(p.xy,t,m,scale,size,expand);\n    c = a.x;\n    \n    a.x = min(a.x,max(p.y+size*5.,p.x));//Artifact Removal\n    \n    //Spiral 2\n    p = po;\n    t = to;\n    p.y+=size*2.0;\n    t-=ltime/3.0;\n    stack = -floor(t/ltime);\n    id2 = idlim2(p.y,m2,stack);\n    t+=id2*ltime;\n    p.y = lim2(p.y,m2,stack);\n    b.x = spiral(p.xy,t,m,scale,size,expand);\n    c = min(c,b.x);\n    a=(a.x<b.x)?a:b;\n    \n    a.x = min(a.x,max(p.y+size*5.,p.x));//Artifact Removal\n    \n    //Spiral 3\n    p = po;\n    t = to;\n    p.y+=size*4.0;\n    t-=2.*ltime/3.0;\n    stack = -floor(t/ltime);\n    id2 = idlim2(p.y,m2,stack);    \n    t+=id2*ltime;\n    p.y = lim2(p.y,m2,stack);\n    b.x = spiral(p.xy,t,m,scale,size,expand);\n    c = min(c,b.x);\n    a=(a.x<b.x)?a:b;\n    \n    a.x = min(a.x,max(p.y+size*5.,p.x)); //Artifact Removal\n    \n    a.x = ext(po.yzx,a.x,width-expand*0.5+0.02)-expand;\n    //SDF without intersection boundries for AO\n    c = ext(po.yzx,c,width-expand*0.5+0.02)-expand; \n    \n    //Intersection distance to plane between each lane\n    b.x = diplane(po ,vec3(modwidth)*0.5, rdg); //Artifact Removal\n    b.y = 0.;\n\n    a=(a.x<b.x)?a:b; //Artifact Removal\n    \n    return vec3(a,c);\n}\nvec3 norm(vec3 p){\n    vec2 e = vec2(0.01,0);\n    return normalize(map(p).x-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\nvoid render( out vec4 fragColor,in vec2 fragCoord){\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n\n    vec3 ro = vec3(5,1.8,-12)*1.2;\n    ro.zx*=rot(0.09);\n    \n    //Mouse control\n    if(iMouse.z>0.5){\n    ro.yz*=rot(0.5*(iMouse.y/iResolution.y-0.5));\n    ro.zx*=rot(-0.5*(iMouse.x/iResolution.x-0.5));\n    }\n    //Camera Setup\n    vec3 lk = vec3(-2.5,0.,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = normalize(f*2.0+uv.x*r+uv.y*cross(f,r));  \n    rdg = rd;\n\n    vec3 p = ro;\n    vec3 d;\n    float dO = 0.;\n    bool hit = false;\n    \n    //Raymarcher\n    for(int i = 0; i<STEPS; i++){\n        p = ro+rd*dO;\n        d = map(p);\n        dO+=d.x;\n        if(d.x<0.001||i==STEPS-1){\n            hit = true;\n            break;\n        }\n        if(dO>MDIST){\n            dO = MDIST;\n            break;\n        }\n    }\n    //Color Surface\n    if(hit&&d.y!=0.){\n        vec3 ld = normalize(vec3(0.5,0.4,0.9));\n        vec3 n = norm(p);\n        rdg = ld;\n        float shadow = 1.;\n        for(float h = 0.09; h<7.0;){\n            vec3 dd = map(p+ld*h+n*0.005);\n            if(dd.x<0.001&&dd.y==0.0){break;}\n            if(dd.x<0.001){shadow = 0.0; break;}\n            shadow = min(shadow,dd.z*30.0);\n            h+=dd.x;\n        }\n        shadow = max(shadow,0.8);\n        #define AO(a,n,p) smoothstep(-a,a,map(p+n*a).z)\n        float ao = AO(0.05,n,p)*AO(.1,n,p);\n        ao = max(ao,0.1);\n        n.xz*=rot(4.*pi/3.);\n        col = n*0.5+0.5;\n        col = col*shadow;\n        col*=ao;\n    }\n    //Color Background\n    else{\n        col = mix(vec3(0.355,0.129,0.894),vec3(0.278,0.953,1.000),clamp((rd.y+0.05)*2.0,-0.15,1.5));\n    }\n    //Gamma Approximation\n    col = sqrt(col);\n    fragColor = vec4(col,0.0);  \n}\n\n//External AA (check render function for usual code)\n#define ZERO min(0.0,iTime)\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    float px = 1.0/AA; vec4 col = vec4(0);\n    if(AA==1.0) {render(col,fragCoord); fragColor = col; return;}\n    for(float i = ZERO; i <AA; i++){\n        for(float j = ZERO; j <AA; j++){\n            vec4 col2;\n            vec2 coord = vec2(fragCoord.x+px*i,fragCoord.y+px*j);\n            render(col2,coord);\n            col.rgb+=col2.rgb;\n        }\n    }\n    col/=AA*AA;\n    fragColor = vec4(col);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns3XWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[195, 254, 290, 290, 372], [373, 373, 393, 393, 463], [464, 464, 501, 501, 581], [582, 582, 634, 634, 680], [681, 681, 735, 735, 777], [778, 778, 820, 820, 859], [860, 860, 903, 903, 938], [939, 939, 1017, 1017, 1972], [1973, 1973, 1990, 1990, 4283], [4284, 4284, 4302, 4302, 4429], [4430, 4430, 4481, 4481, 6226], [6228, 6309, 6363, 6363, 6763]]}
{"id": "NsBSWy", "name": "black lodge", "author": "ntnl", "description": "raymarching the black lodge", "tags": ["raymarching", "twinpeaks", "davidlynch"], "likes": 5, "viewed": 73, "published": "Public", "date": "1633181073", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float tri(float y){\n    return abs(2.*fract(y)-1.);\n}\n\nvec4 texPiso(vec2 uv){\n    vec4 col1 = vec4(0.24,0.,0.,1.);\n    vec4 col2 = vec4(0.8,0.8,0.7,1.);\n    return tri(uv.y*6.+tri(fract(uv.x)*3.)) > 0.5 ? col1 : col2;\n}\n\nvec4 texCort(vec2 uv, float mod){\n    vec4 col1 = vec4(0.5,0.,0.,1.);\n    vec4 col2 = vec4(0.8,0.8,0.7,1.);\n    return vec4(vec3(tri(uv.y*(5.-mod)+tri(fract(uv.x)*3.))),1.)*col1;\n}\n\nfloat luma(vec3 rgb){\n    vec3 y = vec3(0.2126,0.7152,0.0722);\n    return dot(rgb,y);\n}\n\n///////////////////////////\nfloat det = .001;\nfloat maxdist = 30.;\nint maxsteps = 150;\n\nfloat objid;\n\nmat2 rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c,s,-s,c);\n}\nvec2 hash2( vec2  p )\n{\n    p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n    return fract(sin(p)*43758.5453);\n}\n\nfloat sphere(vec3 p, float rad) \n{\n    return length(p) - rad;\n}\n\nfloat box(vec3 p, vec3 c)\n{\n    p=abs(p)-c;\n    return length(max(p,0.))+min(0.,max(p.z,max(p.x,p.y)));\n}\n\nfloat ground(vec3 p, float y) \n{\n    p.y += y;\n    return abs(p.y);\n}\n\nfloat cortinas(vec3 p, float x){\n    p.x += x;\n    return(abs(p.x));\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\n// FUNCION DE ESTIMACION DE DISTANCIA\n\nfloat de(vec3 p) \n{\n    vec3 pos = p;\n\n    float piso = ground(pos, 2.);\n    \n    //float cortina1 = cortinas(p, 3.);\n    float depthPliegues = 5.;\n    float cortina1 = sdPlane(p, vec3(1.,0.,0.), 3.-depthPliegues*luma(texCort(p.zz*0.75,0.).rgb));\n    float cortina2 = sdPlane(p, vec3(-1.,0.,0.), 3.+depthPliegues*luma(texCort(p.zz*0.5,1.).rgb));\n    //float cortina2 = cortinas(p, -3.);\n    \n    //float d = min(piso, cortina1);\n    //cortina1 = max(cortina1, -p.y-1.25);//offset\n    float d = min(min(piso, cortina1),cortina2);\n\n    // en lugar de establecer el color de los objetos aquí, vamos a pasar un id\n    // que va a tomar la función shade para calcular el color allí\n    // esta es una forma de obtener un id que sería 1 para la esfera, 2 para el piso\n        \n    objid = step(piso, d) + step(cortina1, d) * 2. + step(cortina2, d) * 3.;\n\n    return d*.5;\n}\n\n// FUNCION NORMAL\n\nvec3 normal(vec3 p) \n{   \n    vec2 d = vec2(0., det);\n    \n    return normalize(vec3(de(p + d.yxx), de(p + d.xyx), de(p + d.xxy)) - de(p));\n}\n\n// FUNCION SHADOW\n// calcula la sombra, generando un efecto de suavizado de los bordes\n// a medida que se aleja del objeto\n\nfloat shadow(vec3 p, vec3 ldir) {\n    float td=.001,sh=1.,d=det;\n    for (int i=0; i<100; i++) {\n        p+=ldir*d;\n        d=de(p);\n        td+=d;\n        sh=min(sh,10.*d/td);\n        //el valor cambia la definicion del borde de la sombra\n        //sh=min(sh,50.*d/td);\n        if (sh<.001) break;\n    }\n    return clamp(sh,0.,1.);\n}\n\n// FUNCION SHADE\n\nvec3 shade(vec3 p, vec3 dir) {\n\n    // aquí definimos el color del objeto según la variable objcolor seteada en la funcion\n    // de distancia. La guardamos en col antes de llamar a la funcion normal\n\n    vec3 col;\n    //if (objid==2. || objid==3.) col=vec3(.5,.0,.1);\n    if (objid==2.) col=texCort(p.zz*0.5, 0.).rgb;\n    if (objid==3.) col=texCort(p.zz*0.5, 1.).rgb;    \n    //if (objid==1.) col=vec3(0.,.5,.6);\n    if (objid==1.) col=texPiso(p.xz*0.5).rgb;\n    \n    //vec3 lightdir = normalize(vec3(1.5, 2., -1.)); \n    //vec3 lightdir = normalize(vec3(0., iMouse.y, -10. + (iTime * 0.) * 5.));\n    //vec3 lightdir = normalize(vec3(iMouse.x/iResolution.x*10.-5., iMouse.y/iResolution.y*500.-250., 10.));\n    //vec3 lightdir = normalize(vec3(0, .5, iMouse.x/iResolution.x*10.-5.));\n    //hace falta que la luz se desplace también?\n     vec3 lightdir = normalize(vec3(0., .5, 5.));\n    \n    vec3 n = normal(p);\n\n    // llamamos a la función sombra que nos dará un valor entre 0 y 1\n    // segun el nivel de oclusión de la luminosidad\n    // luego multiplicamos la luz difusa y la especular por este valor\n    float sh = shadow(p, lightdir);    \n    \n    float diff = max(0., dot(lightdir, n)) * sh; // multiplicamos por sombra;\n    \n    vec3 refl = reflect(dir, n);\n    \n    float spec = pow(max(0., dot(lightdir, refl)), 20.) * sh; // multiplicamos por sombra;\n    \n    float amb = .1;\n    \n    //estrobo\n    //if(mod(hash2(vec2(iTime*0.001)).x,2.)<0.01)amb=tan(iTime);\n    \n    return col*(amb*4. + diff*5.) + spec * .7;\n    \n}\n\n// FUNCION DE RAYMARCHING\n\nvec3 march(vec3 from, vec3 dir) \n{\n\n    float d, td=0.;\n    vec3 p, col;\n\n\n    for (int i=0; i<maxsteps; i++) \n    {\n        p = from + td * dir;\n\n        d = de(p);\n\n        if (d < det || td > maxdist) break;\n\n        td += d;\n    }\n\n    if (d < det)\n    {\n        p -= det * dir;\n        col = shade(p, dir);\n    } else {\n        // si no golpeo con ningun objeto, llevamos la distancia a la máxima\n        // que se definió, o sea al fondo de la escena\n        // esto sirve para el correcto cálculo de la niebla\n        td = maxdist;\n    }\n    // efecto niebla\n    // mix entre el color obtenido y \n    //col = mix(vec3(.7),col, exp(-.004*td*td));\n    col = mix(vec3(abs(sin(iTime*0.01))*.5+.3),col, exp(-.004*td*td));\n    return col;    \n}\n///////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     vec2 uv = gl_FragCoord.xy/iResolution.xy - .5; \n\n    uv.x *= iResolution.x / iResolution.y; \n    \n    // oscilamos la posicion de la cámara en z\n    //vec3 from = vec3(0., 0., -10. + sin(iTime * .5) * 5.);\n    //vec3 from = vec3(0., 0., -10. + (iTime * .25) * 5.);\n    vec3 from = vec3(0., 0., -10. + (iTime * .25) * 5.);\n    //vec3 dir = normalize(vec3(uv, 1.));\n    vec3 dir = normalize(vec3(uv, 0.75));\n    //una forma simple de rotar la cámara\n    //es rotando en los mismos ejes tanto from como dir\n    from.xz *= rot(iTime*.0);\n    dir.xz *= rot(iTime*.0);\n\n    vec3 col = march(from, dir);\n\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsBSWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 53], [55, 55, 77, 77, 219], [221, 221, 254, 254, 401], [403, 403, 424, 424, 490], [492, 594, 613, 613, 672], [673, 673, 696, 696, 803], [805, 805, 839, 839, 869], [871, 871, 898, 898, 976], [978, 978, 1010, 1010, 1047], [1049, 1049, 1081, 1081, 1119], [1121, 1121, 1163, 1189, 1214], [1216, 1255, 1274, 1274, 2126], [2128, 2147, 2169, 2169, 2288], [2290, 2414, 2447, 2447, 2748], [2750, 2768, 2798, 2969, 4304], [4306, 4333, 4367, 4367, 5081], [5082, 5111, 5168, 5168, 5806]]}
{"id": "NscSRf", "name": "BloBot", "author": "Viko", "description": "Meet BloBot ! A robot made with blobs ! ༼ つ ◕_◕ ༽つ", "tags": ["blob", "robot", "id3d"], "likes": 4, "viewed": 75, "published": "Public", "date": "1633884030", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Common\n#define PI 3.1415926538\n\n// Hashing function\n// Returns a random number in [-1,1]\nfloat Hash(float seed)\n{\n  return fract(sin(seed)*43758.5453);\n}\n\n// Cosine direction\nvec3 Cosine(in float seed,in vec3 nor)\n{\n  float u=Hash(78.233+seed);\n  float v=Hash(10.873+seed);\n  \n  // method 3 by fizzer: http://www.amietia.com/lambertnotangent.html\n  float a=6.2831853*v;\n  u=2.*u-1.;\n  return normalize(nor+vec3(sqrt(1.-u*u)*vec2(cos(a),sin(a)),u));\n}\n\n// Rotation matrix around z axis\n// a : Angle\nmat3 rotate_z(float a)\n{\n  float sa=sin(a);float ca=cos(a);\n  return mat3(ca,sa,0.,-sa,ca,0.,0.,0.,1.);\n}\n\n// Compute the ray\n// m : Mouse position\n// p : Pixel\n// ro, rd : Ray origin and direction\nvoid Ray(in vec2 m,in vec2 p,out vec3 ro,out vec3 rd)\n{\n  float a=3.*3.14*m.x;\n  float le=3.8;\n  \n  ro=vec3(20.,0.,5.);\n  ro*=rotate_z(3.*3.14*m.x);\n  \n  vec3 ta=vec3(0.,0.,1.);\n  vec3 ww=normalize(ta-ro);\n  vec3 uu=normalize(cross(ww,vec3(0.,0.,1.)));\n  vec3 vv=normalize(cross(uu,ww));\n  rd=normalize(p.x*uu+p.y*vv+le*ww);\n}\n\n// Main\n\nconst int Steps=150;\nconst float Epsilon=.1;// Marching epsilon\nconst float T=.5;\n\nconst float rA=10.;// Maximum and minimum ray marching or sphere tracing distance from origin\nconst float rB=40.;\n\n\n// ..::= Transform =::.. //\n\nvec3 translateX(vec3 p, float t)\n{\n    return vec3(p.x + t, p.y,p.z);\n}\nvec3 translateY(vec3 p, float t)\n{\n    return vec3(p.x, p.y + t,p.z);\n}\nvec3 translateZ(vec3 p, float t)\n{\n    return vec3(p.x, p.y,p.z + t);\n}\n\nvec3 rotateX(vec3 p,float a)\n{\n  float sa=sin(a);\n  float ca=cos(a);\n  return vec3(p.x,ca*p.y-sa*p.z,sa*p.y+ca*p.z);\n}\n\nvec3 rotateY(vec3 p,float a)\n{\n  float sa=sin(a);\n  float ca=cos(a);\n  return vec3(ca*p.x+sa*p.z,p.y,-sa*p.x+ca*p.z);\n}\n\nvec3 rotateZ(vec3 p,float a)\n{\n  float sa=sin(a);\n  float ca=cos(a);\n  return vec3(ca*p.x+sa*p.y,-sa*p.x+ca*p.y,p.z);\n}\n\nvec3 scaleX(vec3 p, float s)\n{\n    return vec3(p.x*s,p.y,p.z);\n}\nvec3 scaleY(vec3 p, float s)\n{\n    return vec3(p.x,p.y*s,p.z);\n}\nvec3 scaleZ(vec3 p, float s)\n{\n    return vec3(p.x,p.y,p.z*s);\n}\nvec3 scaleUniform(vec3 p, float s)\n{\n    return vec3(p.x*s,p.y*s,p.z*s);\n}\n\n// Smooth cubic falloff function\n// x : distance\n// R : radius\nfloat falloff(float x,float R)\n{\n  float u=clamp(x/R,0.,1.);\n  float v=(1.-u*u);\n  return v*v*v;\n}\n\n\n// ..::= Primitives =::.. //\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : radius\nfloat point(vec3 p,vec3 c,float e,float R)\n{\n  return e*falloff(length(p-c),R);\n}\nvec4 pointColor(vec3 p, vec3 c, vec3 color, float e, float R)\n{\n  float x = point(p, c, e, R);\n  return vec4(x, color);\n}\n\n// ==== Segment ==== //\n// p : point\n// a : first point of segment\n// b : second point of segment\n// e : energy associated to skeleton\n// R : radius\nfloat segment(vec3 p, vec3 a, vec3 b, float e, float R)\n{\n  if (dot(b-a, p-a) < 0.0)\n  {\n    return e*falloff(dot(p-a, p-a), R);\n  }\n  else if (dot(b-a, p-b) > 0.0)\n  {\n    return e*falloff(dot(p-b, p-b), R);\n  }\n  else \n  {\n    vec3 u = (b-a)/length(b-a);\n    float sqLengthAP = dot(p-a, p-a);\n    return e*falloff( sqLengthAP - dot(dot((p-a), u), dot((p-a), u)), R );\n  }\n}\nvec4 segmentColor(vec3 p, vec3 a, vec3 b, vec3 color, float e, float R)\n{\n  float x = segment(p, a, b, e, R);\n  return vec4(x, color);\n}\n\n// ==== Circle ==== //\n// p : point\n// c : center of the circle\n// r : radius of the circle\n// e : energy associated to skeleton\n// R : radius\nfloat circle(vec3 p, vec3 c, float r, float e, float R)\n{\n  vec3 n = p -c;\n  vec3 u = vec3(1.0, 0.0, 0.0);\n  float h = dot(n, u);\n  float d = dot(n, n);\n  float y = d - h * h;\n  y = r - sqrt(y);\n\n  return e*falloff(sqrt(y*y + h*h), R);\n}\nvec4 circleColor(vec3 p, vec3 c, float r, vec3 color, float e, float R)\n{\n  float x = circle(p, c, r, e, R);\n  return vec4(x, color);\n}\n\n// ==== Disk ==== //\n// p : point\n// c : center of disk\n// r : radius of disk\n// e : energy associated to skeleton\n// R : radius\nfloat disk(vec3 p, vec3 c, float r, float e, float R)\n{\n  vec3 n = p -c;\n  vec3 u = vec3(1.0, 0.0, 0.0);\n  float h = dot(n, u);\n  float d = dot(n, n);\n  float y = d - h * h;\n\n  if (y < r*r)\n    return e*falloff(abs(h), R);\n    \n  y = r - sqrt(y);\n  return e*falloff(sqrt(y*y + h*h), R);\n}\nvec4 diskColor(vec3 p, vec3 c, float r, vec3 color, float e, float R)\n{\n  float x = disk(p,c,r,e,R);\n  return vec4(x, color);\n}\n\n// Utility function used for box distance function\nfloat box_plan(float coord_p, float coord_a, float coord_b)\n{\n  float result;\n  if (coord_p > coord_a && coord_p < coord_b)\n    result = 0.;\n  else if (coord_p < coord_a)\n    result = coord_a - coord_p;\n  else if (coord_p > coord_b)\n    result = coord_p - coord_b;\n\n  return result;\n}\n// ==== Box ==== //\n// p : point\n// a : min corner point of the box\n// b : max corner point of the box\n// e : energy associated to skeleton\n// R : radius\nfloat box(vec3 p, vec3 a, vec3 b, float e, float R)\n{\n  float xval = box_plan(p.x, a.x, b.x); // x\n  float yval = box_plan(p.y, a.y, b.y); // y\n  float zval = box_plan(p.z, a.z, b.z); // z\n\n  return e*falloff( (xval*xval + yval*yval + zval*zval), R );\n}\nvec4 boxColor(vec3 p, vec3 a, vec3 b, vec3 color, float e, float R)\n{\n  float x = box(p, a, b, e, R);\n\n  return vec4(x, color);\n}\n\n\n// ..::= Operators =::.. //\n\n// ==== Blending ==== //\n// a,b : field function of the sub-trees\nfloat Blend(float a,float b)\n{\n  return a+b;\n}\nvec4 BlendColor(vec4 a, vec4 b)\n{\n  if ((a.x + b.x) != 0.)\n  {\n    vec3 color = (a.yzw * a.x + b.yzw * b.x) / (a.x + b.x);\n    return vec4(a.x + b.x, color);\n  }\n   return vec4(a.x + b.x, a.yzw);\n}\n\n// ==== Union ==== //\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Union(float a,float b)\n{\n  return max(a,b);\n}\nvec4 UnionColor(vec4 a, vec4 b)\n{\n  if (a.x > b.x)\n    return a;\n  return b;\n}\n\n// ==== Intersection ==== //\nfloat Intersection(float a, float b)\n{\n  return min(a,b);\n}\n\n// ==== Difference ==== //\nfloat Difference(float a, float b)\n{\n  return min(a, 2.*T - b);\n}\nvec4 DifferenceColor(vec4 a, vec4 b)\n{\n  return vec4(Difference(a.x,b.x), a.yzw);\n}\n\n\n// ..::= Scene's objects =::.. //\n\nvec4 torso (vec3 p)\n{\n    vec4 torso;\n    \n    // Neck\n    vec4 neck = segmentColor(p, vec3(0.,0.,-1.), vec3(0.,0.,-1.5), vec3(0.25,0.25,0.25),0.6,0.8);\n    \n    // Body\n    vec4 body = boxColor(p, vec3(-0.3,-0.5,-0.8), vec3(0.3,0.5,0.8), vec3(1.0,0.8,0.0),1.0,1.0);\n    body = BlendColor(body, pointColor(p, vec3(1.0,0.0,0.4), vec3(1.0,0.8,0.0), -1.2,1.0));\n    body = BlendColor(body, pointColor(p, vec3(0.0,1.0,0.4), vec3(1.0,0.8,0.0), -1.0,1.0));\n    body = BlendColor(body, pointColor(p, vec3(0.0,-1.0,0.4), vec3(1.0,0.8,0.0), -1.0,1.0));\n    body = BlendColor(body, diskColor(rotateY(p,PI/2.), vec3(-0.9,0.,0.), 0.85, vec3(1.,0.8,0.),1.,1.));\n    body = UnionColor(body, diskColor(p, vec3(0.0,0.,0.), 0.85, vec3(0.25,0.25,0.25),1.,1.));\n    body = BlendColor(body, segmentColor(p, vec3(0.0,-1.0,-0.8), vec3(0.,1.0,-0.8), vec3(0.25,0.25,0.25),1.0,0.8));\n    body = BlendColor(body, segmentColor(p, vec3(0.0,0.0,1.25), vec3(0.,0.0,1.75), vec3(0.25,0.25,0.25),0.6,0.8));\n    \n    // Core\n    vec3 color = vec3 ( max(abs(Hash(iTime*0.15)),0.6), max(abs(Hash(iTime*0.75)),0.6), max(abs(Hash(iTime*0.5)),0.6));\n    body = UnionColor(body, pointColor(p, vec3(0.75,0.0,0.4), color, 1., 0.75));\n    \n    torso = BlendColor(neck,body);\n    \n    return torso;\n}\n\nvec4 wheelLeg (vec3 p)\n{\n    vec4 wheelLeg;\n    \n    wheelLeg = boxColor(p, vec3(-0.1,-0.3,-0.2), vec3(0.1,0.3,0.7), vec3(1.0,0.8,0.0),1.0,1.0);\n    wheelLeg = BlendColor(wheelLeg, diskColor(rotateZ(rotateY(p,PI/2.),PI/2.), vec3(0.,-0.5,-0.),0.5,vec3(1.0,0.8,0.0),-1.,1.));\n    wheelLeg = UnionColor(wheelLeg, circleColor(rotateZ(rotateY(scaleY(p,0.75),PI/2.),PI/2.), vec3(0.,-0.7,0.),0.6,vec3(0.2,0.2,0.2),0.75,0.75));\n    wheelLeg = UnionColor(wheelLeg, diskColor(rotateZ(rotateY(p,PI/2.),PI/2.), vec3(0.,-0.7,-0.),0.3,vec3(0.5,0.5,0.5),0.75,0.75));\n    wheelLeg = BlendColor(wheelLeg, segmentColor(p, vec3(0.,-0.8,0.75),vec3(0.,0.8,0.75),vec3(0.3,0.3,0.3),0.55,0.35));\n    \n    return wheelLeg;\n}\n\nvec4 leftArm (vec3 p)\n{\n    vec4 leftArm;\n    \n    leftArm = segmentColor(p, vec3(0.,1.5,0.),vec3(0.75,2.25,0.5),vec3(0.25,0.25,0.25),0.55,0.5);\n    leftArm = BlendColor(leftArm,segmentColor(p, vec3(0.75,2.25,0.5),vec3(1.75,1.75,0.5),vec3(0.25,0.25,0.25),0.55,0.5));\n    vec3 tr = rotateZ(translateZ(translateY(translateX(p,-1.75),-1.75),-0.5),-PI/6.);\n    leftArm = BlendColor(leftArm, segmentColor(tr, vec3(-0.25,0.0,0.0),vec3(0.25,0.,0.),vec3(1.,0.8,0.),0.55,0.55));\n    leftArm = UnionColor(leftArm, diskColor(tr, vec3(0.5,0.0,0.0),0.25,vec3(0.25,0.25,0.25),0.55,1.));\n    \n    vec4 finger1 = segmentColor(tr, vec3(0.65,0.,0.35),vec3(1.,0.,0.55),vec3(0.45,0.45,0.45),0.55,0.1);\n    finger1 = UnionColor(finger1, segmentColor(tr, vec3(1.,0.,0.55),vec3(1.3,0.,0.25),vec3(0.45,0.45,0.45),0.55,0.1));\n    \n    vec4 finger2 = segmentColor(rotateX(tr,PI/1.5), vec3(0.65,0.,0.35),vec3(1.,0.,0.55),vec3(0.45,0.45,0.45),0.55,0.1);\n    finger2 = UnionColor(finger2, segmentColor(rotateX(tr,PI/1.5), vec3(1.,0.,0.55),vec3(1.3,0.,0.25),vec3(0.45,0.45,0.45),0.55,0.1));\n    \n    vec4 finger3 = segmentColor(rotateX(tr,-PI/1.5), vec3(0.65,0.,0.35),vec3(1.,0.,0.55),vec3(0.45,0.45,0.45),0.55,0.1);\n    finger3 = UnionColor(finger3, segmentColor(rotateX(tr,-PI/1.5), vec3(1.,0.,0.55),vec3(1.3,0.,0.25),vec3(0.45,0.45,0.45),0.55,0.1));\n    \n    vec4 hand = UnionColor(finger1,finger2);\n    hand = UnionColor(hand, finger3);\n    \n    leftArm = UnionColor(leftArm, hand);\n    \n    return leftArm;\n}\n\nvec4 rightArm (vec3 p)\n{\n    vec4 rightArm;\n    \n    rightArm = segmentColor(p, vec3(0.,-1.5,0.),vec3(0.25,-2.25,.5),vec3(0.25,0.25,0.25),0.55,0.5);\n    rightArm = BlendColor(rightArm,segmentColor(p, vec3(0.25,-2.25,0.5),vec3(0.5,-2.5,1.),vec3(0.25,0.25,0.25),0.55,0.35));\n    vec3 tr = rotateZ(rotateY(translateZ(translateY(translateX(p,-0.5),2.5),-1.),PI/3.),-PI/10.);\n    rightArm = BlendColor(rightArm, segmentColor(tr, vec3(0.25,0.,0.),vec3(1.,0.0,0.0),vec3(1.,0.8,0.),1.,0.35));\n    rightArm = UnionColor(rightArm, diskColor(tr, vec3(1.4,0.0,0.0),0.25,vec3(0.25,0.25,0.25),0.55,1.));\n    \n    rightArm = UnionColor(rightArm, segmentColor(tr, vec3(1.5,0.,0.),vec3(2.,0.,0.),vec3(0.25,0.25,0.25),0.55,0.2));\n    rightArm = UnionColor(rightArm, segmentColor(rotateX(tr,PI/2.), vec3(2.,-0.25,0.),vec3(2.,0.25,0.),vec3(0.25,0.25,0.25),0.55,0.75));\n    rightArm = UnionColor(rightArm, diskColor(rotateY(tr,PI/2.), vec3(-0.5,0.,-2.),0.25,vec3(1.,0.8,0.),0.55,1.));\n    rightArm = UnionColor(rightArm, diskColor(rotateY(tr,PI/2.), vec3(0.5,0.,-2.),0.25,vec3(1.,0.8,0.),0.55,1.));\n    \n    return rightArm;\n}\n\nvec4 head (vec3 p)\n{\n    vec4 head;\n    \n    head = pointColor(p * vec3(1.,0.9,1.), vec3(0.,0.,0.), vec3(0.45,0.45,0.45), 1., 3.);\n    vec3 TR1 = rotateZ(p,PI/2.) * vec3(1.5,1.5,1.5) - vec3(1.5,0.,0.);\n    vec3 TR2 = rotateZ(p,PI/2.) * vec3(1.5,1.5,1.5) + vec3(1.5,0.,0.);\n\n    head = BlendColor(head, diskColor(TR1, vec3(0.,0.,0.),.7,vec3(0.25,0.25,0.25),1.2,1.1));\n    head = BlendColor(head, diskColor(TR2, vec3(0.,0.,0.),.7,vec3(0.25,0.25,0.25),1.2,1.1));\n    head = BlendColor(head, diskColor(scaleY(rotateX(translateX(TR1,-0.4), PI/3.), 0.5), vec3(0.,0.75,0.), 0.75, vec3(1.,0.8,0.), 0.75,0.75));\n    head = BlendColor(head, diskColor(scaleY(rotateX(translateX(TR2,0.4), PI/3.), 0.5), vec3(0.,0.75,0.), 0.75, vec3(1.,0.8,0.), 0.75,0.75));\n    head = BlendColor(head, pointColor(TR1, vec3(1.5,0.,0), vec3(0.,0.,0.), -0.75, 1.5));\n    head = BlendColor(head, pointColor(TR2, vec3(-1.5,0.,0), vec3(0.,0.,0.), -0.75, 1.5));\n    \n    // Eyes\n    head = UnionColor(head, segmentColor(scaleUniform(rotateX(p,-PI/6.),1.2), vec3(1.25,-0.95,-0.25), vec3(1.35,-0.75,-.25), vec3(0.7,0.1,0.1), 0.55,0.75));\n    head = UnionColor(head, segmentColor(scaleUniform(rotateX(p,PI/6.),1.2), vec3(1.35,0.75,-0.25), vec3(1.25,0.95,-.25), vec3(0.7,0.1,0.1), 0.55,0.75));\n    \n    // Mouth\n    head = UnionColor(head, pointColor(scaleY(p,0.5), vec3(1.25,0.,0.65), vec3(1.,0.,0.), 0.55, 1.));\n    \n    return head;\n}\n\nvec4 robot (vec3 p)\n{\n  vec4 robot;\n  \n  vec4 body = torso(translateZ(p,-2.6));\n  vec4 wheelLeg = wheelLeg(translateZ(p,-5.));\n  vec4 leftArm = leftArm(translateZ(p,-2.));\n  vec4 rightArm = rightArm(translateZ(p,-2.));\n  vec4 head = head(p);\n  \n  robot = body;\n  robot = UnionColor(robot,wheelLeg);\n  robot = UnionColor(robot, leftArm);\n  robot = UnionColor(robot, rightArm);\n  robot = UnionColor(robot, head);\n\n  return robot;\n}\n\n// Main object scene (root of CSG tree)\n// vec4 : \n// -- x : distance value\n// -- yzw : vec3 representing color rgb\nvec4 ObjectColored(vec3 p)\n{\n  p.z = -p.z;\n\n  vec3 scale = vec3(4.,4.,4.);\n\n  vec4 v;\n  \n  // ===== Robot ===== //\n  v = robot(p - vec3(0.,0.,-3.));\n\n\n  return vec4(v.x - T, v.y, v.z, v.w);\n}\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p)\n{\n  float eps=.0001;\n  vec3 n;\n  vec4 v=ObjectColored(p);\n  n.x=ObjectColored(vec3(p.x+eps,p.y,p.z)).x-v.x;\n  n.y=ObjectColored(vec3(p.x,p.y+eps,p.z)).x-v.x;\n  n.z=ObjectColored(vec3(p.x,p.y,p.z+eps)).x-v.x;\n  return normalize(n);\n}\n\nvec3 ObjectColor(in vec3 p)\n{\n  vec4 v = ObjectColored(p);\n  return vec3(v.y, v.z, v.w);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat Trace(vec3 o,vec3 u,float rB,out bool h,out int s)\n{\n  h=false;\n  \n  // Don't start at the origin, instead move a little bit forward\n  float t=rA;\n  \n  for(int i=0;i<Steps;i++)\n  {\n    s=i;\n    vec3 p=o+t*u;\n    //float v=Object(p);\n    vec4 v = ObjectColored(p);\n    // Hit object\n    if(v.x>0.)\n    {\n      s=i;\n      h=true;\n      break;\n    }\n    // Move along ray\n    t+=Epsilon;\n    // Escape marched far away\n    if(t>rB)\n    {\n      break;\n    }\n  }\n  return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o,vec3 u,float rB,out bool h,out int s)\n{\n  h=false;\n  \n  // Don't start at the origin, instead move a little bit forward\n  float t=rA;\n  \n  for(int i=0;i<Steps;i++)\n  {\n    s=i;\n    vec3 p=o+t*u;\n    //float v=Object(p);\n    vec4 v = ObjectColored(p);\n    // Hit object\n    if(v.x>0.)\n    {\n      s=i;\n      h=true;\n      break;\n    }\n    // Move along ray\n    t+=max(Epsilon,abs(v.x)/4.);\n    // Escape marched far away\n    if(t>rB)\n    {\n      break;\n    }\n  }\n  return t;\n}\n\n// Ambient occlusion\n// p : Point\n// n : Normal\n// a : Number of smaples\nfloat AmbientOcclusion(vec3 p,vec3 n,int a)\n{\n  if(a==0){return 1.;}\n  \n  float ao=0.;\n  \n  for(int i=0;i<a;i++)\n  {\n    vec3 d=Cosine(581.123*float(i),n);\n    \n    int s;\n    bool h;\n    float t=SphereTrace(p,d,10.,h,s);\n    if(!h){ao+=1.;}\n    else if(t>5.)\n    {\n      ao+=1.;\n    }\n  }\n  \n  ao/=float(a);\n  return ao;\n}\n\n// Background color\nvec3 background(vec3 rd)\n{\n  return mix(vec3(.652,.451,.995),vec3(.552,.897,.995),rd.z*.5+.5);\n}\n\nfloat Light(vec3 p,vec3 n)\n{\n  // point light\n  const vec3 lp=vec3(5.,10.,25.);\n  \n  vec3 l=normalize(lp-p);\n  \n  // Not even Phong shading, use weighted cosine instead for smooth transitions\n  float diff=pow(.5*(1.+dot(n,l)),2.);\n  \n  bool h;\n  int s;\n  float t=SphereTrace(p+.1*n,l,100.,h,s);\n  if(!h)\n  {\n    return diff;\n  }\n  return 0.;\n}\n\nfloat SmoothLight(vec3 p,vec3 n,int a)\n{\n  if(a==0)\n  return 1.;\n  \n  // point light\n  const vec3 lp=vec3(5.,10.,25.);\n  \n  vec3 l=normalize(lp-p);\n  \n  float lo=0.;\n  \n  for(int i=0;i<a;i++)\n  {\n    vec3 d=Cosine(581.123*float(i),n);\n    d=normalize(l+d*.15);\n    int s;\n    bool h;\n    float t=SphereTrace(p,d,10.,h,s);\n    if(!h){lo+=1.;}\n    else if(t>100.)\n    {\n      lo+=1.;\n    }\n  }\n  \n  lo/=float(a);\n  return lo;\n  \n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\nvec3 Shade(vec3 p,vec3 n)\n{\n  vec3 c=.25+.25*background(n);\n  c+=.15*AmbientOcclusion(p+.1*n,n,0)*vec3(1.,1.,1.);\n  c+=.35*Light(p,n);\n  return c;\n}\n\n// Shading with number of steps\nvec3 ShadeSteps(int n)\n{\n  float t=float(n)/(float(Steps-1));\n  return .5+mix(vec3(.05,.05,.5),vec3(.65,.39,.65),t);\n}\n\n// Picture in picture\n// pixel : Pixel\n// pip : Boolean, true if pixel was in sub-picture zone\nvec2 Pip(in vec2 pixel,out bool pip)\n{\n  // Pixel coordinates\n  vec2 p=(-iResolution.xy+2.*pixel)/iResolution.y;\n  if(pip==true)\n  {\n    const float fraction=1./4.;\n    // Recompute pixel coordinates in sub-picture\n    if((pixel.x<iResolution.x*fraction)&&(pixel.y<iResolution.y*fraction))\n    {\n      p=(-iResolution.xy*fraction+2.*pixel)/(iResolution.y*fraction);\n      pip=true;\n    }\n    else\n    {\n      pip=false;\n    }\n  }\n  return p;\n}\n\n// Image\nvoid mainImage(out vec4 color,in vec2 pxy)\n{\n  // Picture in picture on\n  bool pip=true;\n  \n  // Pixel\n  vec2 pixel=Pip(pxy,pip);\n  \n  // Mouse\n  vec2 m=iMouse.xy/iResolution.xy;\n  \n  // Camera\n  vec3 ro,rd;\n  Ray(m,pixel,ro,rd);\n\n  // Rotate Camera\n  float a=iTime*0.25;\n  ro = rotateZ(ro, a);\n  rd = rotateZ(rd, a);\n  \n  // Trace ray\n  \n  // Hit and number of steps\n  bool hit;\n  int s;\n  \n  float t=SphereTrace(ro,rd,100.,hit,s);\n  //float t = Trace(ro, rd, 100., hit, s);\n  \n  // Position\n  vec3 pt=ro+t*rd;\n  \n  // Shade background\n  vec3 rgb=background(rd);\n  \n  if(hit)\n  {\n    // Compute normal\n    vec3 n=ObjectNormal(pt);\n\n    vec3 col = ObjectColor(pt);\n    \n    // Shade object with light\n    rgb=Shade(pt,n) * col;\n  }\n  \n  // Uncomment this line to shade image with false colors representing the number of steps\n  if(pip==true)\n  {\n    rgb=ShadeSteps(s);\n  }\n  \n  color=vec4(rgb,1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NscSRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 93, 117, 117, 157], [159, 179, 219, 219, 454], [456, 502, 526, 526, 607], [609, 700, 755, 755, 1026], [1236, 1265, 1299, 1299, 1336], [1337, 1337, 1371, 1371, 1408], [1409, 1409, 1443, 1443, 1480], [1482, 1482, 1512, 1512, 1600], [1602, 1602, 1632, 1632, 1721], [1723, 1723, 1753, 1753, 1842], [1844, 1844, 1874, 1874, 1908], [1909, 1909, 1939, 1939, 1973], [1974, 1974, 2004, 2004, 2038], [2039, 2039, 2075, 2075, 2113], [2115, 2178, 2210, 2210, 2276], [2309, 2417, 2461, 2461, 2498], [2499, 2499, 2562, 2562, 2620], [2622, 2771, 2828, 2828, 3146], [3147, 3147, 3220, 3220, 3283], [3285, 3428, 3485, 3485, 3665], [3666, 3666, 3739, 3739, 3801], [3803, 3932, 3987, 3987, 4220], [4221, 4221, 4292, 4292, 4348], [4350, 4401, 4462, 4462, 4685], [4686, 4840, 4893, 4893, 5093], [5094, 5094, 5163, 5163, 5223], [5255, 5321, 5351, 5351, 5367], [5368, 5368, 5401, 5401, 5565], [5567, 5668, 5698, 5698, 5719], [5720, 5720, 5753, 5753, 5798], [5800, 5829, 5867, 5867, 5888], [5890, 5917, 5953, 5953, 5982], [5983, 5983, 6021, 6021, 6066], [6069, 6104, 6125, 6125, 7360], [7362, 7362, 7386, 7386, 8061], [8063, 8063, 8086, 8086, 9546], [9548, 9548, 9572, 9572, 10653], [10655, 10655, 10675, 10675, 12052], [12054, 12054, 12075, 12075, 12483], [12485, 12601, 12629, 12629, 12792], [12794, 12834, 12864, 12864, 13095], [13097, 13097, 13126, 13126, 13187], [13189, 13294, 13352, 13352, 13771], [13773, 13878, 13942, 13942, 14378], [14380, 14453, 14498, 14498, 14776], [14778, 14798, 14824, 14824, 14894], [14896, 14896, 14924, 14941, 15239], [15241, 15241, 15281, 15281, 15669], [15671, 15732, 15759, 15759, 15880], [15882, 15914, 15938, 15938, 16032], [16034, 16129, 16167, 16190, 16572], [16574, 16583, 16627, 16654, 17482]]}
{"id": "NscSWs", "name": "BRM Cellular Tiling Based Clouds", "author": "intrakits", "description": "This is my attempt at raymarching some clouds using cellular tiling rather than 3d noise. I added fractional brownian motion to make the clouds more fluffy.", "tags": ["clouds", "brownian", "motion", "cellular", "tiling", "density", "fractional"], "likes": 3, "viewed": 158, "published": "Public API", "date": "1634138845", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//3d cellular tiling reference: https://www.shadertoy.com/view/ld3Szs\n//cloud reference:              https://www.shadertoy.com/view/4sXGRM\n\n#define _StepSize 120.\n#define _VolDepth 80000.0\n#define _CloudScale 7.\n#define _CloudOffset 0.\n#define _DensityThreshold .1\n#define _DensityMultiplier .00005\n\n\n#define _DarknessThreshold .3\n#define _LightAbsorbtion 100.\n#define _LightAbsorbtionTowardsSun 100.\n#define  _NumStepsLight 6\n#define _PhaseVal 100.\n\nmat3 m = mat3(0.00, 1.60, 1.20, -1.60, 0.72, -0.96, -1.20, -0.96, 1.28);\n\nvec2 cloudHeight = vec2(-2000,2000);\n\nvec3 lightDir = normalize(vec3(0.1,.1,.5));\n\n\nfloat drawSphere(in vec3 p){\n    \n    p = fract(p)-.5;    \n    return dot(p, p);\n    \n    p = abs(fract(p)-.5);\n    return dot(p, vec3(.166));\n    \n}\n\nfloat cellTile(in vec3 p){\n    \n    float c = .25; // Set the maximum.\n    \n    c = min(c, drawSphere(p - vec3(.81, .62, .53)));\n    c = min(c, drawSphere(p - vec3(.39, .2, .11)));\n    \n    c = min(c, drawSphere(p - vec3(.62, .24, .06)));\n    c = min(c, drawSphere(p - vec3(.2, .82, .64)));\n    \n    p *= 1.4142;\n    \n    c = min(c, drawSphere(p - vec3(.48, .29, .2)));\n    c = min(c, drawSphere(p - vec3(.06, .87, .78)));\n\n    c = min(c, drawSphere(p - vec3(.6, .86, .0)));\n    c = min(c, drawSphere(p - vec3(.18, .44, .58)));\n        \n    return (c*4.);\n    \n}\n\n\nvec3 camera(float time)\n{\n    return vec3(0,5000.*sin(iTime), time*2000.);\n}\nfloat getDensity(vec3 pos){\n    float n1 = smoothstep(.7,.1,cellTile(pos*.00005));\n    float n2 = smoothstep(0.,.5,cellTile(pos*.0001));\n   // float n3 = smoothstep(0.,.4,cellTile(pos*.00001));\n   // float n4 = smoothstep(0.,.4,cellTile(pos*.0002));\n    float alpha = smoothstep(0.5, 1.0,n1*n2);\n    \n    alpha = max(0.,alpha-_DensityThreshold)*_DensityMultiplier;\n    return alpha;\n}\n\n// Fractional Brownian motion\nfloat fbm(vec3 p)\n{\n   // p*=.00025;\n    float f = 0.5000 * getDensity(p);\n    p = m * p;\n    f += 0.2500 * getDensity(p);\n    p = m * p;\n    f += 0.1666 * getDensity(p);\n    p = m * p;\n    f += 0.0834 * getDensity(p);\n    \n    return f;\n}\n\nfloat lightmarch(vec3 pos){\n    vec3 dirToLight = lightDir;\n    float totalDensity = 0.;\n    for(float i = 0.; i < _VolDepth; i += _StepSize*200.){\n\n        pos += dirToLight *_StepSize;\n       \n        float alpha = fbm(pos);//getDensity(pos);\n        \n        totalDensity += max(0.,alpha*_StepSize);\n    }\n    float transmittance = exp(-totalDensity * _LightAbsorbtionTowardsSun);\n    return _DarknessThreshold + transmittance * (1.-_DarknessThreshold);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float time = (iTime + 13.5 + 44.) * 1.0;\n    vec3 campos = camera(time);\n    vec3 camtar = camera(time + .1);\n\n    vec3 front = normalize(camtar - campos);\n    vec3 right = normalize(cross(front, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(right, front));\n    vec3 fragAt = normalize(uv.x * right + uv.y * up + front);\n    \n    // clouds\n    vec4 sum = vec4(0, 0, 0, 0);\n    vec3 lightE = vec3(0.);\n    float transmittance = 1.;\n    for (float depth = 0.0; depth < _VolDepth; depth += _StepSize)\n    {\n        vec3 ray = campos + fragAt * depth;\n        if (cloudHeight.x < ray.y && ray.y < cloudHeight.y)\n        {\n            \n            float alpha =fbm(ray);//getDensity(pos);\n            \n            alpha = (1.0 - sum.a) * alpha;\n            if(alpha >0.){\n                float lightTransmittance = lightmarch(ray);\n                lightE+=alpha*_StepSize*transmittance*lightTransmittance*_PhaseVal;\n                transmittance*= exp(-alpha*_StepSize*_LightAbsorbtion);\n                if(transmittance < 0.01){\n                  break;\n                }\n            }\n            sum += vec4(vec3(1) * alpha, alpha);\n        }\n    }\n    float alpha = smoothstep(0.7, 1.0, sum.a);\n    sum.rgb= lightE;\n    float sundot = clamp(dot(fragAt, lightDir), 0.0, 1.0);\n    vec3 col = 0.8 * (vec3(0,0,1));\n    col += 0.47 * vec3(1.6, 1.4, 1.0) * pow(sundot, 350.0);\n    col += 0.4 * vec3(0.8, 0.9, 1.0) * pow(sundot, 2.0);\n    col = mix(col, sum.rgb, 1.-transmittance);\n\n    //col=vec3(smoothstep(.0,.7,cellTile(vec3(uv.x,uv.y,0.)))*smoothstep(1.,.5,cellTile(vec3(uv.x,uv.y,0.)))*smoothstep(1.,.4,cellTile(vec3(uv.x*2.,uv.y*2.,0.))));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NscSWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 610, 638, 638, 759], [761, 761, 787, 787, 1323], [1326, 1326, 1351, 1351, 1402], [1403, 1403, 1430, 1430, 1787], [1789, 1819, 1838, 1855, 2058], [2060, 2060, 2087, 2087, 2518], [2519, 2519, 2576, 2576, 4383]]}
{"id": "NscSzB", "name": "Radiant Ember Orb", "author": "Tater", "description": "My first experiments with refraction. pretty pleased with how it turned out. \n\nuse mouse to zoom out", "tags": ["raymarching", "waves", "refraction", "particles", "orb"], "likes": 21, "viewed": 380, "published": "Public API", "date": "1633500478", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define pi 3.1415926535\n#define pmod(p,x) (mod(p,x)-0.5*(x))\n\n#define elon(p,h) (p-clamp(p,-h,h))\n\n//Enable exit ray\n#define refraction2\n\n\n//iq octohedron\nfloat oct( vec3 p, float s)\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nfloat box(vec3 p, vec3 b){\n    vec3 d = abs(p)-b;\n    return max(d.x,max(d.y,d.z));\n}\n\nfloat torus (vec3 p, vec2 b){\n  vec2 d = vec2(length(p.yz)-b.x,p.x);\n  return length(d)-b.y;\n}\nfloat torus2 (vec3 p, vec2 b){\n  vec2 d = vec2(length(p.yx)-b.x,p.z);\n  return length(d)-b.y;\n}\nfloat glow = 0.;\nfloat glow2 = 0.;\n\nbool inside = false;\nvec2 map(vec3 p){\n    float t= iTime;\n    vec3 po2 = p;\n    vec2 a = vec2(1.);\n    vec2 b = vec2(2.);\n    //Swing\n    p.y-=7.0;\n    p.xy*=rot(sin(t*2.0*pi/3.)*0.28);\n    p.y+=7.0;\n    vec3 po = p;\n    //Glass Displacment\n    p+=t*0.2;\n    float dis = sin(p.x*5.)*sin(p.y*5.)*sin(p.z*5.)*0.02;\n    p = po;\n    //Glass ball\n    a.x = length(p)-1.0+dis;\n    glow2+=0.5/(0.5+a.x*a.x);\n    a.x*=0.85;\n    if(inside){\n        //Octohedron\n        p.xz*=rot(t*0.8);\n        b.x = oct(p,0.3)-0.02;\n        \n        //Mini Octohedron\n        float s = sign(p.x*p.y*p.z);\n        p = abs(p)-0.25+sin(t)*0.05;\n        p.xz*=rot(-t*s*2.0);\n        b.x = min(b.x, oct(p,0.05)-0.01);\n\n        p = po;\n        //Particles\n        p.xz*=rot(t);\n        p.y-=t;\n        float m = 0.5;\n        vec3 id = floor(p/m)-0.5;\n        p.y+=sin(id.x*id.z)*4.0;\n\n        p = pmod(p,vec3(m));\n        b.x*=0.9;\n        b.x = min(b.x,length(p));\n\n        b.x = max(a.x,b.x);\n        glow+=0.005/(0.001+b.x);\n\n        a.x = max(a.x,-b.x);\n\n        a=(abs(a.x)<abs(b.x))?a:b;\n    }\n    //chain\n    b.y = 3.0;\n    float scl = 0.6;\n    float m2 = 1.5*scl;\n    po.y-=7.5*scl;\n    po.xz*=rot(t*0.8);\n    p = po;\n\n    p.y = pmod(max(p.y,-m2*4.),m2);\n    p.y = elon(p.y,0.3*scl);\n    b.x = torus(p,vec2(0.2,0.1)*scl);\n    \n    p = po;\n    p.y+=0.75*scl;\n    p.y = pmod(max(p.y,-m2*4.),m2);\n    p.y = elon(p.y,0.3*scl);\n    b.x = min(b.x,torus2(p,vec2(0.2,0.1)*scl));\n    \n    a=(abs(a.x)<abs(b.x))?a:b;\n    \n    if(!inside){\n        //Background\n        b.y = 4.0;\n        p = po2;\n        //technique idea taken from yonatan\n        for(float s = 1.; s<10.; s/=.55){\n            p.xz*=rot(s);\n            p.y+=abs(dot(sin(p.xz*s+t*0.8)/s,vec2(0.15)));\n            p.y+=(dot(sin(p.xz*s+t*0.4+pi/2.)/s,vec2(0.15)));\n        }\n        b.x = p.y+1.3;\n        b.x*=0.7;\n\n        b.x = max(b.x,(length(p)-9.0));\n        a=(a.x<b.x)?a:b;\n    }\n    return a;\n}\n\nvec3 norm(vec3 p){\n    vec2 e = vec2(0.001,0);\n    return normalize(map(p).x-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\n#define MDIST 50.0\nvec2 march(vec3 ro, vec3 rd, int steps){\n    float dO = 0.;\n    for(int i = 0; i<steps; i++){\n        vec3 p = ro+rd*dO;\n        vec2 d = map(p);\n        dO+=abs(d.x);\n        if(dO>MDIST){\n            return vec2(dO,-1.);\n        }\n        if(abs(d.x)<0.0001||i==steps-1){\n            return vec2(dO,d.y);\n        }\n    }\n}\n\nvec3 colorI(vec3 ro, vec3 rd, float dO, float mat){\n    vec3 col = vec3(0);\n    vec3 p = ro+rd*dO;\n    vec3 n = norm(p);\n \n    \n    vec3 ld = normalize(vec3(1));\n    vec3 h = normalize(ld-rd);\n    float ndotl = abs(dot( -rd, n ));\n    float rim = pow(1.0-ndotl, 5.0);\n    float spec = pow(max(dot(n,h),0.0),5.0);\n    \n    \n    vec3 bg = vec3(0.3);\n    if(mat==1.0) col = bg;\n    \n    col+=rim;\n    \n    float dens = 0.1;\n    vec3 gemCol = vec3(0.310,0.004,0.396);\n    vec3 coloredDens = (1.-log(gemCol))*dens;\n    vec3 optDist = exp(-dO*coloredDens);\n    \n    //float optDist = exp(-dO*dens);\n    col = mix(gemCol,col,optDist);\n\n    col = col*optDist*gemCol;\n    \n    if(mat==2.0)glow*=rim;\n    col+=clamp(glow*0.5,0.,2.0)*vec3(0.886,0.376,0.129);\n    \n    \n    return col;\n}\nbool refracted = false;\nvec3 colorO(vec3 ro, vec3 rd, float dO, float mat){\n    vec3 col = vec3(0);\n    vec3 p = ro+rd*dO;\n    vec3 n = norm(p);\n    vec3 ld = normalize(vec3(1));\n    vec3 h = normalize(ld-rd);\n    vec3 r = reflect(rd,n);\n    float ndotl = abs(dot( -rd, n ));\n    float rim = pow(1.0-ndotl, 3.0);\n    float spec = length(sin(r*2.)*.5+.5)/sqrt(3.);\n    \n    vec3 bg = vec3(0.);\n    col = mix(col,bg,1.0);\n    //col+=clamp(glow*0.3,0.,0.8)*vec3(0.886,0.376,0.129);\n    if(dO<MDIST&&mat!=4.0){\n        col+=pow(spec,4.0)*3.0*vec3(1,0,0);\n        col+=rim*5.0;\n    }\n    \n    col+=clamp(glow2*0.03,0.,2.0)*vec3(0.886,0.376,0.129);\n    if(refracted) col=glow2*rim*vec3(0.886,0.376,0.129)*0.1;\n    return col;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 col = vec3(0);\n    m.y+=0.1;\n    vec3 ro = vec3(0,0.5+m.y*5.0,-4.0-m.y*10.0);\n    \n    //ro.yz *= rot(-m.y*3.14+1.);\n    ro.xz *= rot(-m.x*6.2831);\n    \n    vec3 lk = vec3(0,0.3,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = normalize(f*0.99+uv.x*r+uv.y*cross(f,r));\n    vec2 dO = vec2(0);\n    vec3 rdo = rd;\n    //Index of Refraction\n    float ior = 1.4;\n    \n    dO = march(ro,rd,170);\n    vec3 p = ro+rd*dO.x;\n    //Yeah this lighting setup is janky but it looks better than how I intended it\n    //so I'm keeping it \n    col = colorO(ro,rd,dO.x,dO.y); //Color the outside\n    \n    //If hit the glass then march into it and color the inside\n    if(dO.y==1.0||dO.y==3.0){\n        inside = true; //optimize which geometry to check\n        glow = 0.;\n        ro = p;\n        vec3 n = norm(p);\n        ro-=n*0.05;\n        rd = refract(rd,n,1./ior);\n        if(dO.y==1.0)dO = march(ro,rd,90);\n        col = mix(col,colorI(ro,rd,dO.x,dO.y),0.9);\n        \n        //attempted reflection on the surface, might re-visit\n        /* \n        inside = false; //optimize which geometry to check\n        glow = 0.;\n        glow2 = 0.;\n        vec2 dO2 = vec2(0);\n        dO2 = march(p+n*0.05,reflect(rd,n),90);\n        refracted = true;\n        vec3 col2 = colorO(ro,rd,dO2.x,dO2.y);\n        float fres = pow(1.0-abs(dot(-rdo, n)),1.0);\n        col+=col2*fres;\n        */\n\n    #ifdef refraction2\n        if(dO.y==1.0){\n            inside = false; //optimize which geometry to check\n            refracted = true; //janky fix to make the background more defined\n            p =ro+rd*dO.x;\n            glow = 0.;\n            glow2 = 0.;\n            ro = p;\n            n = norm(p);\n            ro += n*0.05;\n            vec3 ref = refract(rd,-n,ior);\n            if(ref == vec3(0)) rd = reflect(rd,-n);\n            else rd = ref;\n            \n            //not accurate but maybe more visually apealing ray direction\n            //rd = rdo; \n            \n            dO = march(ro,rd,40);\n            \n            col = mix(col,colorO(ro,rd,dO.x,dO.y),0.1);    \n        }\n    #endif     \n\n    }\n\n    fragColor = vec4(col,1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NscSzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[189, 205, 234, 234, 514], [516, 516, 542, 542, 601], [603, 603, 632, 632, 697], [698, 698, 728, 728, 793], [851, 851, 868, 868, 2767], [2769, 2769, 2787, 2787, 2915], [2935, 2935, 2975, 2975, 3259], [3261, 3261, 3312, 3312, 4036], [4061, 4061, 4112, 4112, 4758], [4759, 4759, 4814, 4814, 7083]]}
{"id": "NscXRl", "name": "Amiga Boing Ball Hires", "author": "Krischan", "description": "As if my A500 had 4K resolution :-D The famous Amiga Boing ball demo in Hires. Found at https://glslsandbox.com/e#69071.0 and adjusted a little bit.", "tags": ["retro", "amiga", "boing", "ball", "hires"], "likes": 4, "viewed": 157, "published": "Public API", "date": "1633831761", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float tri(float x) { return min(fract(x), 1. - fract(x)) * 4. - 1.; }\n\nbool grid(vec2 p, float l, float h)\n{\n    return (fract(p.x * 10.) < .1 || fract(p.y * 10.) < .1) && abs(p.x - .025) < 1.25 && p.y > l && p.y < h;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = (2. * fragCoord.xy - iResolution.xy ) / min(iResolution.x, iResolution.y) + vec2(.0, .4);\n    vec4 col = vec4(.5);\n    float x = tri(iTime * .1) * 2.6;\n    vec2 s = 2. * pos - vec2(x, 1.5 * abs(sin(iTime * 1.7)));\n    \n    if (length(s) < .85)\n    {\n        col = vec4(1.0, .0, 0., .0);\n        s = s * mat2(.96, -.28, .28, .96) / sin(1.85 - length(s.xy)*1.4) + vec2(1. * x, 0.);\n        if (fract(s.x * 1.2) < .5 ^^ fract(s.y * 1.2) < 0.5) col += 1.1;\n    }\n    else\n    {\n        if (grid(pos, -.3, 1.205)) col.g = 0.;\n        pos = vec2(pos.x, 1.) / pos.y * -.3;\n        if (grid(pos, .7, 1.)) col.g = 0.;\n        if (length(s - vec2(.4, .1)) < .85) col /= 2.;\n    }\n    \n\tfragColor = vec4(col.rgb,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NscXRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 69], [71, 71, 108, 108, 219], [221, 221, 278, 278, 1002]]}
{"id": "NscXWS", "name": "Neutron Nebula", "author": "stusaysmoo", "description": "Neutron Nebula", "tags": ["neutronnebula"], "likes": 4, "viewed": 65, "published": "Public", "date": "1633794586", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CBS\n//Parallax scrolling fractal galaxy.\n//Inspired by JoshP's Simplicity shader: https://www.shadertoy.com/view/lslGWr\n\n// http://www.fractalforums.com/new-theories-and-research/very-simple-formula-for-fractal-patterns/\nfloat field(in vec3 p,float s) {\n\tfloat strength = 7. + .03 * log(1.e-6 + fract(sin(iTime) * 4373.11));\n\tfloat accum = s/4.;\n\tfloat prev = 0.;\n\tfloat tw = 0.;\n\tfor (int i = 0; i < 26; ++i) {\n\t\tfloat mag = dot(p, p);\n\t\tp = abs(p) / mag + vec3(-.5, -.4, -1.5);\n\t\tfloat w = exp(-float(i) / 7.);\n\t\taccum += w * exp(-strength * pow(abs(mag - prev), 2.2));\n\t\ttw += w;\n\t\tprev = mag;\n\t}\n\treturn max(0., 5. * accum / tw - .7);\n}\n\n// Less iterations for second layer\nfloat field2(in vec3 p, float s) {\n\tfloat strength = 7. + .03 * log(1.e-6 + fract(sin(iTime) * 4373.11));\n\tfloat accum = s/4.;\n\tfloat prev = 0.;\n\tfloat tw = 0.;\n\tfor (int i = 0; i < 18; ++i) {\n\t\tfloat mag = dot(p, p);\n\t\tp = abs(p) / mag + vec3(-.5, -.4, -1.5);\n\t\tfloat w = exp(-float(i) / 7.);\n\t\taccum += w * exp(-strength * pow(abs(mag - prev), 2.2));\n\t\ttw += w;\n\t\tprev = mag;\n\t}\n\treturn max(0., 5. * accum / tw - .7);\n}\n\nvec3 nrand3( vec2 co )\n{\n\tvec3 a = fract( cos( co.x*8.3e-3 + co.y )*vec3(1.3e5, 4.7e5, 2.9e5) );\n\tvec3 b = fract( sin( co.x*0.3e-3 + co.y )*vec3(8.1e5, 1.0e5, 0.1e5) );\n\tvec3 c = mix(a, b, 0.5);\n\treturn c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n\tvec2 uvs = uv * iResolution.xy / max(iResolution.x, iResolution.y);\n\tvec3 p = vec3(uvs / 4., 0) + vec3(1., -1.3, 0.);\n\tp += .2 * vec3(sin(iTime / 16.), sin(iTime / 12.),  sin(iTime / 128.));\n\t\n\tfloat freqs[4];\n\t//Sound\n\tfreqs[0] = texture( iChannel0, vec2( 0.01, 0.25 ) ).x;\n\tfreqs[1] = texture( iChannel0, vec2( 0.07, 0.25 ) ).x;\n\tfreqs[2] = texture( iChannel0, vec2( 0.15, 0.25 ) ).x;\n\tfreqs[3] = texture( iChannel0, vec2( 0.30, 0.25 ) ).x;\n\n\tfloat t = field(p,freqs[2]);\n\tfloat v = (1. - exp((abs(uv.x) - 1.) * 6.)) * (1. - exp((abs(uv.y) - 1.) * 6.));\n\t\n    //Second Layer\n\tvec3 p2 = vec3(uvs / (4.+sin(iTime*0.11)*0.2+0.2+sin(iTime*0.15)*0.3+0.4), 1.5) + vec3(2., -1.3, -1.);\n\tp2 += 0.25 * vec3(sin(iTime / 16.), sin(iTime / 12.),  sin(iTime / 128.));\n\tfloat t2 = field2(p2,freqs[3]);\n\tvec4 c2 = mix(.4, 1., v) * vec4(1.3 * t2 * t2 * t2 ,1.8  * t2 * t2 , t2* freqs[0], t2);\n\t\n\t\n\t//Let's add some stars\n\t//Thanks to http://glsl.heroku.com/e#6904.0\n\tvec2 seed = p.xy * 2.0;\t\n\tseed = floor(seed * iResolution.x);\n\tvec3 rnd = nrand3( seed );\n\tvec4 starcolor = vec4(pow(rnd.y,40.0));\n\t\n\t//Second Layer\n\tvec2 seed2 = p2.xy * 2.0;\n\tseed2 = floor(seed2 * iResolution.x);\n\tvec3 rnd2 = nrand3( seed2 );\n\tstarcolor += vec4(pow(rnd2.y,40.0));\n\t\n\tfragColor = mix(freqs[3]-.3, 1., v) * vec4(1.5*freqs[2] * t * t* t , 1.2*freqs[1] * t * t, freqs[3]*t, 1.0)+c2+starcolor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NscXWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 223, 255, 255, 642], [644, 680, 714, 714, 1101], [1103, 1103, 1127, 1127, 1310], [1313, 1313, 1370, 1370, 2789]]}
{"id": "NsdSRX", "name": "Filtre", "author": "rasterdog", "description": "lol", "tags": ["filtre"], "likes": 3, "viewed": 156, "published": "Public", "date": "1633627058", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec4 cam = texture(iChannel0, uv);\n    \n    float noise = sin(fragCoord.x * cos(fragCoord.y * iTime)) / 5.0;\n    \n    float color = max(clamp(sin(cam.x + cam.y + cam.z / cos(1.4)), 0.0, 0.8) * 1.25, sin(cam.y * fragCoord.y / 5.0 + iTime * 10.0));\n\n    // Output to screen\n    fragColor = vec4(color / fragCoord.x * 400.0 + noise, color / 2.0 + noise, color * color, 1.0);\n}\n", "image_inputs": [{"id": "4sf3zn", "previewfilepath": "/presets/webcam.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/webcam.png", "ctype": "webcam"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsdSRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 532]]}
{"id": "NsdSW4", "name": "Planet shader", "author": "pancakespeople", "description": "A shader of an earth-like planet\n\nUpdate 2021-10-9: Switched to side view perspective and added the sun", "tags": ["planet"], "likes": 3, "viewed": 133, "published": "Public API", "date": "1633154690", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NUM_OCTAVES 5\n\nvec2 random2(vec2 st) {\n\tst = vec2(dot(st, vec2(127.1, 311.7)),\n\t\tdot(st, vec2(269.5, 183.3)));\n\treturn -1.0 + 2.0 * fract(sin(st) * 43758.5453123 * 0.7897);\n}\n\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec2 st) {\n\tvec2 i = floor(st);\n\tvec2 f = fract(st);\n\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\n\treturn mix(mix(dot(random2(i + vec2(0.0, 0.0)), f - vec2(0.0, 0.0)),\n\t\tdot(random2(i + vec2(1.0, 0.0)), f - vec2(1.0, 0.0)), u.x),\n\t\tmix(dot(random2(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0)),\n\t\t\tdot(random2(i + vec2(1.0, 1.0)), f - vec2(1.0, 1.0)), u.x), u.y);\n}\n\nfloat fbm(vec2 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n\t// Rotate to reduce axial bias\n\tmat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfor (int i = 0; i < NUM_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nmat2 rotate(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x * 4.0;\n    vec3 sph = vec3(uv.x, uv.y, cos(length(uv)));\n\n    float r = length(uv);\n\tfloat f = (1.0 - sqrt(1.0 - r)) / r;\n    vec3 sunPos = vec3(cos(iTime / 4.0), 0.0, sin(iTime / 4.0));\n    float light = dot(sph, sunPos);\n    float reflectivity = 1.0;\n\n    float noiseVal = fbm((uv * f * 5.0) + 500.0) + 0.5;\n    float cloudNoise = fbm((uv * f * 2.0 + vec2(-iTime / 8.0, 0.0)) + 1000.0) + 0.5;\n    //cloudNoise *= rotate(iTime);\n    vec3 col = vec3(0.0);\n    \n    if (r < 1.0) {\n        if (noiseVal < 0.5) {\n            col = vec3(0.0, 0.0, 1.0);\n        }\n        else if (noiseVal > 0.65) {\n            col = vec3(1.0, 1.0, 1.0) * noiseVal;\n        }\n        else {\n            col = vec3(0.5, noiseVal, 0.0);\n        }\n        reflectivity = noiseVal * 2.0;\n        col += smoothstep(0.55, 0.6, cloudNoise);\n    }\n    else {\n        col = vec3(0.5, 0.8, 1.0) * smoothstep(1.1, 1.0, r);\n        reflectivity = 0.5;\n    }\n    \n    col *= light;\n    col += smoothstep(1.1, 1.0, r) * light * reflectivity;\n    \n    vec2 suv = uv - sunPos.xy * 3.0;\n    col += 0.1 / length(suv) * smoothstep(0.99, 1.0, r) * smoothstep(0.5, 0.8, -sunPos.z);\n    \n    float flareCol = 0.0;\n    vec2 fuv = suv;\n    float angle = atan(fuv.y, fuv.x) + 3.14159 / 8.0;\n    flareCol += 0.1/abs(sin(angle*4.0)*cos(angle*4.0)) * smoothstep(0.6, 0.0, length(fuv));\n    flareCol *= 0.1/abs(sin(angle*2.0)*cos(angle*2.0)) * smoothstep(0.6, 0.0, length(fuv));\n    //flareCol += 0.01 / abs(fuv.x*fuv.y) * smoothstep(1.0, 0.5, length(fuv)) / 4.0;\n    //fuv *= rotate(3.14159 / 4.0);\n    //flareCol += 0.01 / abs(fuv.x*fuv.y) * smoothstep(1.0, 0.5, length(fuv)) / 16.0;\n\n    flareCol *= smoothstep(0.7, 0.8, -sunPos.z);\n    flareCol *= smoothstep(0.99, 1.0, length(uv-suv));\n    //flareCol *= smoothstep(0.99, 1.0, r);\n    if (light < 0.01 && r < 1.0) col = vec3(0.0);\n    col += flareCol;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsdSW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 46, 46, 182], [184, 269, 291, 291, 633], [635, 635, 654, 654, 922], [924, 924, 950, 950, 1034], [1036, 1036, 1093, 1143, 3120]]}
{"id": "NsdSWj", "name": "Sombras", "author": "nictemeral", "description": "Pequeño shader alocado, jugando con funciones de distancia y un poco de noise para darle movimiento", "tags": ["noise", "shadows", "soft", "move", "sombras"], "likes": 4, "viewed": 126, "published": "Public API", "date": "1633972261", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Author: nictemeral\n//Title: sombras\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                * 43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord/iResolution.xy;\n     st.x *=iResolution.x/iResolution.y;\n     st*=1.1;\n     st.x-=0.34;\n     // st.y+=0.1;\n\n    float e=  distance(st,vec2(0.260,0.740));\n\tfloat a=  distance(vec2(e),vec2(0.510,0.360));\n    float b=  distance(vec2(e),vec2(a));\n    float r=  distance(st,vec2(0.460,0.400));\n\tfloat f=  distance(st,vec2(0.990,0.220));\n    float j=  distance(vec2(r),vec2(f));    \n    float q=  distance(st,vec2(0.440,-0.130));\n    float z=  distance(vec2(q),vec2(j));\n\n\n    vec2 toCenter = st-vec2(noise(st-iTime) ,noise(st+iTime));\n    float pct = length(toCenter);\n  \ttoCenter = st-vec2(noise(st-iTime*0.25) ,noise(st+iTime*0.25));\n    pct *= length(toCenter)*3.;\n    \n    vec3 color = .7212-vec3(j*pct*b*z)*50.000;\n\n\n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsdSWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 85, 112, 112, 228], [230, 308, 334, 334, 714], [716, 716, 773, 773, 1549]]}
{"id": "NsdSWS", "name": "Lapin crétin running higher FPS", "author": "moiup", "description": "Lapin crétin running animation. One can choose the Tracing algorithm. On the function SphereTrace (line 753), uncomment the wanted line and comment the unwanted line to render with a different method.", "tags": ["animation", "spheretracing", "fps", "running", "lapincrtin"], "likes": 2, "viewed": 47, "published": "Public", "date": "1633863912", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Common\nconst float INFINITY = 1e32;\n\nconst float DEG_TO_RAD = 0.0174533;\n\n// Hashing function\n// Returns a random number in [-1,1]\nfloat Hash(float seed) {\n  return fract(sin(seed) * 43758.5453);\n}\n\n// Cosine direction\nvec3 Cosine(in float seed, in vec3 nor) {\n  float u = Hash(78.233 + seed);\n  float v = Hash(10.873 + seed);\n\n  // method 3 by fizzer: http://www.amietia.com/lambertnotangent.html\n  float a = 6.2831853 * v;\n  u = 2. * u - 1.;\n  return normalize(nor + vec3(sqrt(1. - u * u) * vec2(cos(a), sin(a)), u));\n}\n\n// Rotation matrix around z axis\n// a : Angle\nmat3 rotate_z(float a) {\n  float sa = sin(a);\n  float ca = cos(a);\n  return mat3(ca, sa, 0., -sa, ca, 0., 0., 0., 1.);\n}\n\n// Compute the ray\n// m : Mouse position\n// p : Pixel\n// ro, rd : Ray origin and direction\nvoid Ray(in vec2 m, in vec2 p, out vec3 ro, out vec3 rd) {\n  float a = 3. * 3.14 * m.x;\n  float le = 3.8;\n\n  ro = vec3(20., 0., 5.);\n  ro *= rotate_z(3. * 3.14 * m.x);\n\n  vec3 ta = vec3(0., 0., 1.);\n  vec3 ww = normalize(ta - ro);\n  vec3 uu = normalize(cross(ww, vec3(0., 0., 1.)));\n  vec3 vv = normalize(cross(uu, ww));\n  rd = normalize(p.x * uu + p.y * vv + le * ww);\n}\n\n// Main\n\nconst int Steps = 1000;\nconst float Epsilon = .05;// Marching epsilon\nconst float T = .5;\n\nconst float rA = 10.;// Maximum and minimum ray marching or sphere tracing distance from origin\nconst float rB = 40.;\n\n// Transforms\nvec3 rotateX(vec3 p, float a) {\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(p.x, ca * p.y - sa * p.z, sa * p.y + ca * p.z);\n}\n\nvec3 rotateY(vec3 p, float a) {\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n}\n\nvec3 rotateZ(vec3 p, float a) {\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca * p.x + sa * p.y, -sa * p.x + ca * p.y, p.z);\n}\n\nvec3 translateX(vec3 p, float tx) {\n  return vec3(p.x - tx, p.yz);\n}\n\nvec3 translateY(vec3 p, float ty) {\n  return vec3(p.x, p.y - ty, p.z);\n}\n\nvec3 translateZ(vec3 p, float tz) {\n  return vec3(p.xy, p.z - tz);\n}\n\nvec3 translate(vec3 p, vec3 t) {\n  return p - t;\n}\n\nvec3 scaleX(vec3 p, float sx) {\n  return vec3(p.x / sx, p.yz);\n}\n\nvec3 scaleY(vec3 p, float sy) {\n  return vec3(p.x, p.y / sy, p.z);\n}\n\nvec3 scaleZ(vec3 p, float sz) {\n  return vec3(p.xy, p.z / sz);\n}\n\nvec3 scaleXYZ(vec3 p, vec3 s) {\n  return p / s;\n}\n\nvec3 scale(vec3 p, float s) {\n  return p / s;\n}\n\n// Smooth cubic falloff function\n// x : distance\n// R : radius\nfloat falloff(float x, float R) {\n  float u = clamp(x / R, 0., 1.);\n  float v = (1. - u * u);\n  return v * v * v;\n}\n\n// Primitives\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : radius\nvec4 point(vec3 p, vec3 c, float e, float R, vec3 color) {\n  return vec4(color, e * falloff(length(p - c), R));\n}\n\n// Disk\n// p : point\n// c : center of disk\n// r : radius of disk\n// e : energy associated to skeleton\n// R : radius\n// color : color vector\nvec4 disk(vec3 p, vec3 c, float r, float e, float R, vec3 color) {\n  vec3 cp = p - c;\n  vec3 u = vec3(1., 0., 0.);\n  float h = dot(cp, u);\n  h = h * h;\n  float d = dot(cp, cp);\n  float y = d - h * h;\n  if(y < r * r) {\n    return vec4(color, e * falloff(abs(h), R));\n  }\n  y = r - sqrt(y);\n  return vec4(color, e * falloff(sqrt(y * y + h * h), R));\n}\n\n// Circle\n// p : point\n// c : center of circle\n// r : radius of the circle\n// e : energy associated to skeleton\n// R : radius\n// color : color vector\nvec4 circle(vec3 p, vec3 c, float r, float e, float R, vec3 color) {\n  vec3 n = p - c;\n  vec3 u = vec3(1., 0., 0.);\n  float h = dot(n, u);\n  float d = dot(n, n);\n  float y = d - h * h;\n  y = r - sqrt(y);\n  return vec4(color, e * falloff(sqrt(y * y + h * h), R));\n}\n\n// Segment\n// p : point\n// a : starting coordinates\n// b : ending coordinates\n// e : energy associated to skeleton\n// R : radius\n// color : color vector\nvec4 segment(vec3 p, vec3 a, vec3 b, float e, float R, vec3 color) {\n  vec3 u = (b - a) / length(b - a);\n  float l = dot(p - a, u);\n\n  if(l < 0.0) {\n    float dist = length(p - a);\n    return vec4(color, e * falloff(dist, R));\n  }\n\n  if(l < length(b - a)) {\n    float left = dot(p - a, p - a);\n    float right = dot(p - a, u) * dot(p - a, u);\n\n    return vec4(color, e * falloff(sqrt(left - right), R));\n  }\n\n  return vec4(color, e * falloff(length(p - b), R));\n}\n\nfloat box_bis(float px, float ax, float bx) {\n  if(px < ax) {\n    return ax - px;\n  }\n\n  if(px > bx) {\n    return px - bx;\n  }\n\n  return 0.0;\n}\n\n// Box\n// p : point\n// a : coordinates of the cube\n// b : coordinate of the cube\n// e : energy associated to skeleton\n// R : radius\n// color : color vector\nvec4 box(vec3 p, vec3 a, vec3 b, float e, float R, vec3 color) {\n  float d1 = box_bis(p.x, a.x, b.x);\n  float d2 = box_bis(p.y, a.y, b.y);\n  float d3 = box_bis(p.z, a.z, b.z);\n\n  return vec4(color, e * falloff(sqrt(d1 * d1 + d2 * d2 + d3 * d3), R));\n}\n\n// Sphere\n// p : point\n// c : center of sphere\n// r : radius of the sphere\n// e : energy associated to skeleton\n// R : radius\n// color : color vector\nvec4 sphere(vec3 p, vec3 c, float r, float e, float R, vec3 color) {\n  return vec4(color, e * falloff(length(p - c) - r, R));\n}\n\n// Hemisphere\n// p : point\n// c : center of hemisphere\n// r : radius of the hemisphere\n// e : energy associated to skeleton\n// R : radius\n// color : color vector\nvec4 hemisphere(vec3 p, vec3 c, float r, float e, float R, vec3 color) {\n  vec3 n = p - c;\n  vec3 u = vec3(1.0, 0.0, 0.0);\n  if(dot(n, u) < 0.0) {\n    return disk(p, c, r, e, R, color);\n  }\n  return sphere(p, c, r, e, R, color);\n}\n\n// Operators\n\n// Blending\n// a,b : field function of the sub-trees\nvec4 Blend(vec4 a, vec4 b) {\n  float denom = a.w + b.w;\n  vec3 color;\n  if(denom == 0.0){\n    color = (a.rgb +  b.rgb) / 2.0;\n  }\n  else {\n    color = ( a.w * a.rgb + b.w * b.rgb) / (a.w + b.w); \n  }\n\n  return vec4(color, denom);\n}\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nvec4 Union(vec4 a, vec4 b) {\n  float v = max(a.w, b.w);\n  if(v == b.w){\n    return b;\n  }\n  return a;\n}\n\n// Intersection\n// a : filed function of left sub-tree\n// b : field function of right sub-tree\nvec4 Intersection(vec4 a, vec4 b) {\n  float v = min(a.w, b.w);\n  if(v == b.w){\n    return b;\n  }\n  return a;\n}\n\n// Difference\n// a : filed function of left sub-tree\n// b : field function of right sub-tree\nvec4 Difference(vec4 a, vec4 b) {\n  float comp = 2.0 * T - b.w;\n  float v = min(a.w, comp);\n\n  if(v == a.w){\n    return a;\n  }\n\n  return vec4(a.rgb, comp);\n}\n\n/**********************************/\n/* OBJECTS                        */\n/**********************************/\n// Rabbit ear\nvec4 lapin_oreille(vec3 p){\n    vec4 v;\n\n    v = Union(\n      disk(scaleXYZ(p, vec3(0.6, 0.7, 1.8)), vec3(0, 0, 0), 1.0, 1.0, 0.6, vec3(1, 1, 1)),\n      disk(translateX(scaleXYZ(p, vec3(0.5, 0.5, 1.6)), 0.2), vec3(0, 0, 0), 1.0, 1.0, 0.6, vec3(0.94, 0.80, 0.73))\n    );\n\n    return v;\n}\n\n// Rabbit eye\nvec4 lapin_oeil(vec3 p){\n    vec4 v;\n\n    v = Union(\n      disk(translateX(scale(p, 0.4), -0.3), vec3(0, 0, 0), 1.3, 1.0, 1.0, vec3(0.94, 0.80, 0.73)),\n      sphere(translateX(p, 0.3), vec3(0, 0, 0), 0.1, 1.0, 1.0, vec3(1, 1, 1))\n    );\n\n    v = Union(\n      v,\n      hemisphere(translateX(scale(p, 0.6), 1.0), vec3(0, 0, 0), 0.1, 1.0, 1.0, vec3(0, 0, 0))\n    );\n\n    return v;\n}\n\n// Rabbit mouth\nvec4 lapin_bouche(vec3 p){\n  vec4 v;\n  vec3 p_levre = scaleXYZ(translate(p, vec3(-0.1, 0, -1.0)), vec3(0.6, 0.45, 0.45));\n\n  v = Difference(\n    circle(p_levre, vec3(0, 0, 0), 3.0, 1.0, 0.5, vec3(0, 0, 0)),\n    box(scaleXYZ(translateZ(p_levre, -0.8), vec3(1.0, 3.0, 2.38)), vec3(-1, -1, -1), vec3(1, 1, 1), 1.0, 1.0, vec3(1.0, 1.0, 1.0))\n  );\n\n  v = Union(\n    v,\n    hemisphere(translate(p, vec3(-1.6, 0, 0)), vec3(0, 0, 0), 1.2, 1.0, 1.0, vec3(0.94, 0.80, 0.73))\n  );\n\n  return v;\n}\n\n// Rabbit head\nvec4 lapin_tete(vec3 p){\n    vec4 v;\n\n    v = sphere(scaleZ(p, 1.3), vec3(0, 0, 0), 2.0, 1.0, 1.0, vec3(1, 1, 1));\n\n    v = Blend(\n      v,\n      lapin_oreille(\n          rotateX(\n              translate(p, vec3(0, -1.7, -4.25)),\n              20.0 * DEG_TO_RAD\n              )\n          )\n  );\n\n  v = Blend(\n      v,\n      lapin_oreille(\n          rotateX(\n              translate(p, vec3(0, 1.7, -4.25)),\n              -20.0 * DEG_TO_RAD\n              )\n          )\n  );\n\n  v = Union(\n      v,\n      lapin_oeil(\n          translate(p, vec3(1.8, -1.3, -1.0))\n        )\n    );\n\n    v = Union(\n      v,\n      lapin_oeil(\n          translate(p, vec3(1.8, 1.3, -1.0))\n        )\n    );\n\n    v = Union(\n      v,\n      lapin_bouche(translate(p, vec3(2.5, 0, 0.5)))\n    );\n\n    return v;\n}\n\n// Rabbit belly\nvec4 lapin_ventre(vec3 p){\n    vec4 v;\n\n    v = Union(\n      sphere(scaleZ(p, 0.9), vec3(0, 0, 0), 2.0, 1.5, 1.0, vec3(1.0, 1.0, 1.0)),\n      sphere(translate(scaleXYZ(p, vec3(1.0, 1.1, 0.9)), vec3(1.1, 0, 0.11)), vec3(0, 0, 0), 1.1, 1.5, 1.0, vec3(0.94, 0.80, 0.73))\n    );\n\n    return v;\n}\n\n// Rabbit leg\nvec4 lapin_jambe(vec3 p){\n    vec4 v;\n\n    v = box(\n        p,\n        vec3(-0.5, -0.5, -0.5),\n        vec3(0.5, 0.5, 0.5),\n        1.3,\n        1.0,\n        vec3(1, 1, 1)\n    );\n\n    return v;\n}\n\n// Rabbit finger\nvec4 lapin_doigt(vec3 p){\n    vec4 v;\n\n    v = box(\n        scaleXYZ(p, vec3(0.25, 0.6, 0.4)),\n        vec3(-0.3, -0.3, -0.3),\n        vec3(0.3, 0.3, 0.3),\n        2.0,\n        1.7,\n        vec3(1, 1, 1)\n    );\n\n    return v;\n}\n\n// Rabbit hand\nvec4 lapin_main(vec3 p, float lr){\n    vec4 v;\n\n    p = scaleY(p, lr);\n    p = translateY(p, 2.0);\n\n    v = segment(\n        p,\n        vec3(0, -2.0, 0),\n        vec3(0, 2.0, 0),\n        3.0,\n        1.25,\n        vec3(1, 1, 1)\n    );\n\n    v = Blend(\n        v,\n        lapin_doigt(\n            rotateZ(translate(p, vec3(0.8, 2.5, 0.0)), -30.0 * DEG_TO_RAD)\n        )\n    );\n\n    v = Blend(\n        v,\n        lapin_doigt(\n            scaleXYZ(rotateZ(translate(p, vec3(0.4, 3.0, 0.0)), 0.0 * DEG_TO_RAD), vec3(0.7, 1.0, 1.0))\n        )\n    );\n\n    v = Blend(\n        v,\n        lapin_doigt(\n            scaleXYZ(rotateZ(translate(p, vec3(-0.1, 3.0, 0.0)), 0.0 * DEG_TO_RAD), vec3(0.7, 1.0, 1.0))\n        )\n    );\n\n    v = Blend(\n        v,\n        lapin_doigt(\n            scaleXYZ(rotateZ(translate(p, vec3(-0.6, 2.8, 0.0)), 10.0 * DEG_TO_RAD), vec3(0.7, 1.0, 1.0))\n        )\n    );\n\n    return v;\n}\n\n\n// Potential field of the object\n// p : point\nvec4 Object(vec3 p) {\n  vec4 v;\n    vec3 p_tete;\n    vec3 p_main;\n\n  p.z = -p.z;\n\n  p = scale(p, 0.6);\n\n    p_tete = translateZ(p, -3.0);\n\n    v = lapin_tete(rotateY(p_tete, sin(iTime * 7.0) * 10.0 * DEG_TO_RAD));\n\n    v = Blend(\n        v,\n        lapin_ventre(translateZ(p, 1.5))\n    );\n\n    // JAMBES\n    v = Blend(\n        v,\n        lapin_jambe(translate(rotateY(p, sin(iTime * 7.0) * 0.4), vec3(0, -1.1, 3.5)))\n    );\n\n    v = Blend(\n        v,\n        lapin_jambe(translate(rotateY(p, sin(iTime * 7.0) * -0.4), vec3(0, 1.1, 3.5)))\n    );\n\n    p_main = scaleXYZ(p, vec3(0.7, 1.0, 0.8));\n    v = Blend(\n        v,\n        lapin_main(rotateX(translateY(rotateY(p_main, sin(iTime * 7.0)), 1.0), -40.0 * DEG_TO_RAD), 1.0)\n    );\n\n    v = Blend(\n        v,\n        lapin_main(rotateX(translateY(rotateY(p_main, sin(iTime * -7.0)), -1.0), 40.0 * DEG_TO_RAD), -1.0)\n    );\n\n\n  return vec4(v.rgb, v.w - T);\n}\n\nfloat F(vec3 p){\n  return -Object(p).a;\n}\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p, out vec3 obj_colors) {\n  float eps = .0001;\n  vec3 n;\n  vec4 v = Object(p);\n  n.x = Object(vec3(p.x + eps, p.y, p.z)).w - v.w;\n  n.y = Object(vec3(p.x, p.y + eps, p.z)).w - v.w;\n  n.z = Object(vec3(p.x, p.y, p.z + eps)).w - v.w;\n  obj_colors = v.rgb;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat Trace(vec3 o, vec3 u, float rB, out bool h, out int s) {\n  h = false;\n  const int nb_iter = 500;\n\n  // Don't start at the origin, instead move a little bit forward\n  float t = rA;\n\n  for(int i = 0; i < nb_iter; i++) {\n    s = i;\n    vec3 p = o + t * u;\n    vec4 v = Object(p);\n    // Hit object\n    if(v.w > 0.) {\n      s = i;\n      h = true;\n      break;\n    }\n    // Move along ray\n    t += Epsilon;\n    // Escape marched far away\n    if(t > rB) {\n      break;\n    }\n  }\n  return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTraceOriginal(vec3 o, vec3 u, float rB, out bool h, out int s) {\n  h = false;\n  int nb_iter = 180;\n  // Don't start at the origin, instead move a little bit forward\n  float t = rA;\n\n  for(int i = 0; i < nb_iter; i++) {\n    s = i;\n    vec3 p = o + t * u; // <=> d * t + o    (Keinert and al.)\n    vec4 v = Object(p); // <=> f(d * t + o) (Keinert and al.)\n    // Hit object\n    if(v.a > 0.) {\n      s = i;\n      h = true;\n      break;\n    }\n    // Move along ray\n    t += max(Epsilon, abs(v.a) / 6.);\n    // Escape marched far away\n    if(t > rB) {\n      break;\n    }\n  }\n  return t;\n}\n\n// B. Keinert et al. Enhanced sphere tracing. In Proceedings of Smart Tools & Apps for Graphics, Eurographics Association, 2014.\nfloat SphereTraceOverRelaxing(vec3 o, vec3 u, float rB, out bool h, out int s) {\n  h = false;\n  int i;\n  float omega = 1.25;\n  float lmbd = 4.0;\n  float coeff = omega / lmbd;\n  float delta_i = 0.0;\n  float f_pi_minus = 0.0;\n  // Don't start at the origin, instead move a little bit forward\n  float t = rA;\n  const int nb_iter = 100;\n\n\n  for( i = 0; i < nb_iter; i++) {\n    s = i;\n    vec3 p = o + t * u; // <=> d * t + o    (Keinert and al.)\n    float f_pi = F(p); // <=> f(d * t + o) (Keinert and al.)\n    \n    // Hit object\n    if(f_pi < 0.0) {\n      h = true;\n      return t;\n    }\n\n    f_pi = abs(f_pi);\n\n    if((f_pi + f_pi_minus)/lmbd < delta_i){\n      delta_i = -omega * delta_i;\n      omega = 1.0;\n      coeff = omega / lmbd;\n      \n      t += delta_i;\n      while(i < nb_iter) {\n        s = i;\n        p = o + t * u; // <=> d * t + o    (Keinert and al.)\n        f_pi = F(p); // <=> f(d * t + o) (Keinert and al.)\n        \n        // Hit object\n        if(f_pi < 0.0) {\n          h = true;\n          return t;\n        }\n\n        delta_i = max(Epsilon, coeff * f_pi);\n\n        // Move along ray\n        t += delta_i;\n        \n        i++;\n      }\n      return INFINITY;\n    }\n\n    delta_i = max(Epsilon, coeff * f_pi);\n    \n\n    f_pi_minus = f_pi;\n\n\n    // Move along ray\n    t += delta_i;\n  }\n\n  return INFINITY;\n}\n\n// B. Keinert et al. Enhanced sphere tracing. In Proceedings of Smart Tools & Apps for Graphics, Eurographics Association, 2014.\nfloat SphereTraceScreenSpace(vec3 o, vec3 u, float rB, out bool h, out int s) {\n  int i;\n  float pixelRadius = 0.001;\n  float omega = 1.4;\n  float lmbd = 4.0;\n  float coeff = omega / lmbd;\n  float delta_i = 0.0;\n  float f_pi_minus = 0.0;\n  float candidate_error = INFINITY;\n  float candidate_t = rB;\n  float functionSign = F(o) < 0.0 ? -1.0 : 1.0;\n  // Don't start at the origin, instead move a little bit forward\n  float t = rA;\n  int nb_iter = 100;\n  float f;\n  float error;\n  h = false;\n\n\n  for( i = 0; i < nb_iter; i++) {\n    s = i;\n    f = F(u * t + o);\n    float signedRadius = functionSign * f;\n    float f_pi = abs(signedRadius);\n  \n    bool sorFail = omega > 1.0 && (f_pi + f_pi_minus < delta_i);\n    if(sorFail){\n      delta_i -= coeff * delta_i;\n      omega = 1.0;\n      lmbd = 40.0;\n      coeff = omega / lmbd;\n    }\n    else {\n      // delta_i = max(Epsilon * signedRadius, signedRadius * omega);\n      delta_i = max(Epsilon * signedRadius, signedRadius * coeff);\n      // delta_i = signedRadius * omega;\n    }\n\n    f_pi_minus = f_pi;\n    \n    error = f_pi / t;\n\n    if(!sorFail && error < candidate_error){\n      candidate_t = t;\n      candidate_error = error;\n    }\n\n    if(!sorFail && error < pixelRadius || t > rB){\n      break;\n    }\n\n    // Move along ray\n    t += delta_i;\n  }\n\n  if(t > rB && candidate_error > pixelRadius || i == nb_iter){\n    return INFINITY;\n  }\n\n  h = true;\n  return candidate_t;\n}\n\n\n\nfloat SphereTrace(vec3 o, vec3 u, float rB, out bool h, out int s){\n  // return Trace(o, u, rB, h, s);\n  // return SphereTraceOriginal(o, u, rB, h, s);\n  return SphereTraceOverRelaxing(o, u, rB, h, s);\n  // return SphereTraceScreenSpace(o, u, rB, h, s);\n}\n\n\n// Ambient occlusion\n// p : Point\n// n : Normal\n// a : Number of smaples\nfloat AmbientOcclusion(vec3 p, vec3 n, int a) {\n  if(a == 0) {\n    return 1.;\n  }\n\n  float ao = 0.;\n\n  for(int i = 0; i < a; i++) {\n    vec3 d = Cosine(581.123 * float(i), n);\n\n    int s;\n    bool h;\n    float t = SphereTrace(p, d, 10., h, s);\n    if(!h) {\n      ao += 1.;\n    } else if(t > 5.) {\n      ao += 1.;\n    }\n  }\n\n  ao /= float(a);\n  return ao;\n}\n\n// Background color\nvec3 background(vec3 rd) {\n  return mix(vec3(.652, .451, .995), vec3(.552, .897, .995), rd.z * .5 + .5);\n}\n\nfloat Light(vec3 p, vec3 n) {\n  // point light\n  const vec3 lp = vec3(5., 10., 25.);\n\n  vec3 l = normalize(lp - p);\n\n  // Not even Phong shading, use weighted cosine instead for smooth transitions\n  float diff = pow(.5 * (1. + dot(n, l)), 2.);\n\n  bool h;\n  int s;\n  // float t = SphereTrace(p + .1 * n, l, 100., h, s);\n  if(!h) {\n    return diff;\n  }\n  return 0.;\n}\n\nfloat SmoothLight(vec3 p, vec3 n, int a) {\n  if(a == 0)\n    return 1.;\n\n  // point light\n  const vec3 lp = vec3(5., 10., 25.);\n\n  vec3 l = normalize(lp - p);\n\n  float lo = 0.;\n\n  for(int i = 0; i < a; i++) {\n    vec3 d = Cosine(581.123 * float(i), n);\n    d = normalize(l + d * .15);\n    int s;\n    bool h;\n    float t = SphereTrace(p, d, 10., h, s);\n    if(!h) {\n      lo += 1.;\n    } else if(t > 100.) {\n      lo += 1.;\n    }\n  }\n\n  lo /= float(a);\n  return lo;\n\n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\nvec3 Shade(vec3 p, vec3 n) {\n  vec3 c = .25 + .25 * background(n);\n  c += .15 * AmbientOcclusion(p + .1 * n, n, 0) * vec3(1., 1., 1.);\n  c += .35 * Light(p, n);\n  return c;\n}\n\n// Shading with number of steps\nvec3 ShadeSteps(int n) {\n  float t = float(n) / (float(Steps - 1));\n  return .5 + mix(vec3(.05, .05, .5), vec3(.65, .39, .65), t);\n}\n\n// Picture in picture\n// pixel : Pixel\n// pip : Boolean, true if pixel was in sub-picture zone\nvec2 Pip(in vec2 pixel, out bool pip) {\n  // Pixel coordinates\n  vec2 p = (-iResolution.xy + 2. * pixel) / iResolution.y;\n  if(pip == true) {\n    const float fraction = 1. / 4.;\n    // Recompute pixel coordinates in sub-picture\n    if((pixel.x < iResolution.x * fraction) && (pixel.y < iResolution.y * fraction)) {\n      p = (-iResolution.xy * fraction + 2. * pixel) / (iResolution.y * fraction);\n      pip = true;\n    } else {\n      pip = false;\n    }\n  }\n  return p;\n}\n\n// Image\nvoid mainImage(out vec4 color, in vec2 pxy) {\n  // Picture in picture on\n  bool pip = true;\n\n  // Pixel\n  vec2 pixel = Pip(pxy, pip);\n\n  // Mouse\n  vec2 m = iMouse.xy / iResolution.xy;\n\n  // Camera\n  vec3 ro, rd;\n  Ray(m, pixel, ro, rd);\n\n  // Trace ray\n\n  // Hit and number of steps\n  bool hit;\n  int s;\n\n  float t = SphereTrace(ro, rd, 100., hit, s);\n\n  // Position\n  vec3 pt = ro + t * rd;\n\n  // Shade background\n  vec3 rgb = background(rd);\n\n  if(hit) {\n    // Compute normal\n    vec3 obj_colors;\n    vec3 n = ObjectNormal(pt, obj_colors);\n\n    // Shade object with light\n    rgb = Shade(pt, n) * obj_colors;\n  }\n\n  // Uncomment this line to shade image with false colors representing the number of steps\n  if(pip == true) {\n    rgb = ShadeSteps(s);\n  }\n\n  color = vec4(rgb, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsdSWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 134, 158, 158, 200], [202, 222, 263, 263, 524], [526, 572, 596, 596, 692], [694, 785, 843, 843, 1156], [1377, 1391, 1422, 1422, 1528], [1530, 1530, 1561, 1561, 1668], [1670, 1670, 1701, 1701, 1808], [1810, 1810, 1845, 1845, 1878], [1880, 1880, 1915, 1915, 1952], [1954, 1954, 1989, 1989, 2022], [2024, 2024, 2056, 2056, 2074], [2076, 2076, 2107, 2107, 2140], [2142, 2142, 2173, 2173, 2210], [2212, 2212, 2243, 2243, 2276], [2278, 2278, 2309, 2309, 2327], [2329, 2329, 2358, 2358, 2376], [2378, 2441, 2474, 2474, 2556], [2573, 2681, 2739, 2739, 2794], [2796, 2936, 3002, 3002, 3285], [3287, 3437, 3505, 3505, 3701], [3703, 3856, 3924, 3924, 4319], [4321, 4321, 4366, 4366, 4464], [4466, 4622, 4686, 4686, 4873], [4875, 5025, 5093, 5093, 5152], [5154, 5316, 5388, 5388, 5546], [5562, 5615, 5643, 5643, 5846], [5848, 5936, 5964, 5964, 6039], [6041, 6136, 6171, 6171, 6246], [6248, 6341, 6374, 6374, 6498], [6500, 6625, 6652, 6652, 6911], [6913, 6927, 6951, 6951, 7306], [7308, 7324, 7350, 7350, 7808], [7810, 7825, 7849, 7849, 8607], [8609, 8625, 8651, 8651, 8916], [8918, 8932, 8957, 8957, 9127], [9129, 9146, 9171, 9171, 9373], [9375, 9390, 9424, 9424, 10291], [10294, 10340, 10361, 10361, 11246], [11248, 11248, 11264, 11264, 11289], [11291, 11331, 11382, 11382, 11635], [11637, 11742, 11804, 11804, 12234], [12236, 12341, 12417, 12417, 12936], [12938, 13067, 13147, 13147, 14390], [14392, 14521, 14600, 14600, 15943], [15947, 15947, 16014, 16098, 16202], [16205, 16278, 16325, 16325, 16634], [16636, 16656, 16682, 16682, 16762], [16764, 16764, 16793, 16810, 17129], [17131, 17131, 17173, 17173, 17597], [17599, 17660, 17688, 17688, 17834], [17836, 17868, 17892, 17892, 18000], [18002, 18097, 18136, 18159, 18567], [18569, 18578, 18623, 18650, 19363]]}
{"id": "NsdXDs", "name": "Terraform", "author": "Xor", "description": "Just a fun little animation", "tags": ["animation"], "likes": 27, "viewed": 242, "published": "Public", "date": "1634186925", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AA 1\n#define EPS .001\n#define MAX 50.\n\nvec2 hash2(vec2 p)\n{\n    return fract(sin(p*mat2(98,-64,-73,69))*397.)*.8;\n}\nfloat height(vec2 p)\n{\n    return p.x+sin(p.y*.3)*3.-iTime;\n}\nfloat cell(vec3 p)\n{\n    vec2 f = floor(p.xz);\n    float d = 4.;\n    \n    for(int X = -1; X<=1; X++)\n    for(int Y = -1; Y<=1; Y++)\n    {\n        vec2 h = f+vec2(X,Y);\n        h += hash2(h)-p.xz;\n        \n        vec3 c = vec3(h,p.y+1.);\n        vec2 R = normalize(sin(c.xy+p.xz));\n        mat2 r = mat2(R,-R.y,R);\n\n        float off = height(p.xz+c.xy);\n        c.z -= sqrt(abs(off))-1.;\n        c.z = max(c.z,0.);\n\n        float s = .13*smoothstep(-.2,.2,off);\n        c.xy *= r;\n        float w = .15;\n        d = min(d, length(max(abs(c)-s,0.))+s-w);\n    }\n    \n    return d;\n}\nfloat dist(vec3 p)\n{\n    return min(p.y+1.,cell(p));\n}\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(2,-2)*EPS;\n    return normalize(dist(p+e.xxy)*e.xxy+dist(p+e.xyx)*e.xyx+\n    dist(p+e.yxx)*e.yxx+dist(p+e.y)*e.y);\n}\nvec3 color(vec3 p,vec3 r)\n{\n    float off = height(p.xz);\n    float s = smoothstep(-.2,.2,off);\n    \n    float l = cell(vec3(p.x,-2,p.z));\n    float e = smoothstep(.02,0.,l);\n\n\n    vec3 n = normal(p);\n    float ao = clamp(dist(p+n*.2)/.2,.1,1.);\n    vec3 sd = normalize(vec3(3,2,-1));\n    float dl = max(.3+.7*dot(n,sd),0.);\n    float sl = max(dot(reflect(r,n),sd)*1.2-1.,0.);\n    \n    for(float i = .02;i<.5; i*=1.3)\n    {\n        dl *= clamp(1.5-i/(i+dist(p+sd*i*2.)),.0,1.);\n    }\n    vec3 sh = mix(vec3(.1,.15,.2),vec3(1),dl);\n    \n    vec3 col = mix(vec3(0.7,1,.2),vec3(1,0.4,0.1),s);\n    return mix(vec3(.5,.7,.8),col*min((p.y+1.1)/.4,1.),e)*sh*sqrt(ao)+sl;\n}\nvec4 march(vec3 p,vec3 r)\n{\n    vec4 m = vec4(p+r,1);\n    for(int i = 0;i<200;i++)\n    {\n        float s = dist(m.xyz);\n        m += vec4(r,1)*s;\n        \n        if (s<EPS || m.w>MAX) return m;\n    }\n    return m;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 p = vec3(iTime-2.,.5+.5*cos(iTime*.2),1);\n    vec3 col = vec3(0);\n    for(int X = 0;X<AA;X++)\n    for(int Y = 0;Y<AA;Y++)\n    {\n        vec2 c = fragCoord+vec2(X,Y)/float(AA)-.5;\n        vec3 r = normalize(vec3(c-vec2(.5,.6)*iResolution.xy,iResolution.y));\n    \n        vec4 m = march(p,r);\n        float fog = smoothstep(MAX*.4,MAX,m.w);\n        col += mix(color(m.xyz,r),exp(-vec3(13,7,4)*r.y*r.y-.2),fog);\n    }\n    col /= float(AA*AA);\n    fragColor = vec4(pow(col,vec3(.45)),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsdXDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 67, 67, 123], [124, 124, 146, 146, 185], [186, 186, 206, 206, 767], [768, 768, 788, 788, 822], [823, 823, 844, 844, 979], [980, 980, 1007, 1007, 1645], [1646, 1646, 1673, 1673, 1862], [1863, 1863, 1918, 1918, 2413]]}
{"id": "NsdXzf", "name": "Torus Hive", "author": "Flopine", "description": "Still playing with torus knot :D ", "tags": ["raymarching", "animation", "glow", "isometric", "knot"], "likes": 33, "viewed": 189, "published": "Public", "date": "1633642754", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan, slerpy, wwrighter \n// BigWings, FabriceNeyret and Blackle for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  \n// https://twitter.com/CookieDemoparty\n\n\n// Based on BigWings tuts ~ https://youtu.be/2dzJZx0yngg\n\n\n#define PI acos(-1.)\n#define TAU (2.*PI)\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n#define hash21(x) fract(sin(dot(x,vec2(26.4,32.87)))*467.5)\n#define dt(sp) fract(iTime*sp)\n\nfloat hexa (vec2 p)\n{\n    p=abs(p);\n    return max(p.x,dot(p,normalize(vec2(1.,sqrt(3.)))));\n}\n\nfloat torus (vec3 p, vec2 rs)\n{\n    vec2 q = vec2(hexa(p.xy)-rs.x,p.z);\n    float a = atan(p.y, p.x);\n    q *= rot(a+iTime);\n    q = abs(abs(q)-.6)-0.3;\n    \n    return hexa(q)-rs.y;\n}\n\nfloat g1=0.;\nfloat SDF (vec3 p)\n{\n    p.yz *= rot(-atan(1./sqrt(2.)));\n    p.xz*=rot(PI/4.);\n    \n    float t = torus(p.xzy,vec2(3.,0.3));\n    p.y -= sin(dt(0.1)*TAU)*.5+.5;\n    float s = length(p)-0.8;\n    g1 += 0.01/(0.01+s*s);\n    \n    float d = min(t,s); \n    \n    return d;\n}\n\nvec3 getnorm(vec3 p)\n{\n    vec2 eps = vec2(0.001,0.);\n    return normalize(SDF(p)-vec3(SDF(p-eps.xyy),SDF(p-eps.yxy),SDF(p-eps.yyx)));\n}\n\nfloat AO (float eps, vec3 p, vec3 n)\n{return clamp(SDF(p+eps*n)/eps,0.,1.);}\n\nfloat spec (vec3 n, vec3 l, vec3 rd)\n{\n    vec3 h = normalize(l-rd);\n    return pow(max(dot(n,h),0.),35.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    float dither = hash21(uv);\n    vec3 ro=vec3(uv*3.8,-50.),rd=normalize(vec3(0.,0.0,1.)),p=ro,\n    col=vec3(0.),l=vec3(1.,2.,-2.);\n    \n    bool hit=false;\n    for (float i=0.; i<100.; i++)\n    {\n        float d = SDF(p);\n        if (d<0.01)\n        {\n            hit=true;break;\n        }\n        d *= .75+dither*0.15;\n        p += d*rd;\n    }\n    \n    if (hit)\n    {\n        vec3 n = getnorm(p);\n        \n        float light = max(dot(n,normalize(l)),0.),\n        ao=AO(0.1,p,n)+AO(0.25,p,n)+AO(0.65,p,n),\n        s = spec(n,l,rd);\n        \n        col = mix(vec3(0.5,0.1,0.5),vec3(0.,0.3,0.8),light)*ao/3.+s*vec3(0.,0.8,0.2);\n    }\n    col += g1*0.5;\n    \n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsdXzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[370, 613, 634, 634, 707], [709, 709, 740, 740, 893], [908, 908, 928, 928, 1175], [1177, 1177, 1199, 1199, 1313], [1315, 1315, 1353, 1353, 1391], [1393, 1393, 1431, 1431, 1501], [1503, 1503, 1560, 1560, 2324]]}
{"id": "NsG3Dw", "name": "Water Searchlight", "author": "itslinaaaa", "description": "A watery wonderland, that isn't so watery\n", "tags": ["water"], "likes": 4, "viewed": 72, "published": "Public", "date": "1635167787", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\n/* const matrices for 3d rotation */\nconst mat3 rot1 = mat3(-0.37, 0.36, 0.85,-0.14,-0.93, 0.34,0.92, 0.01,0.4);\nconst mat3 rot2 = mat3(-0.55,-0.39, 0.74, 0.33,-0.91,-0.24,0.77, 0.12,0.63);\nconst mat3 rot3 = mat3(-0.71, 0.52,-0.47,-0.08,-0.72,-0.68,-0.7,-0.45,0.56);\n\n/* directional artifacts can be reduced by rotating each octave */\nfloat noise(vec3 m) {\n    return   0.5333333*simplex3d(m*rot1)\n\t\t\t+0.2666667*simplex3d(2.0*m*rot2)\n\t\t\t+0.1333333*simplex3d(4.0*m*rot3)\n\t\t\t+0.0666667*simplex3d(8.0*m);\n}\n\n\n\n\n\n\n\n\n\n\nfloat planeSDF (vec3 position, vec3 start, vec3 normal ) {\n    float distance = dot( position - start, normal );\n    return distance;\n}\n\n\n\nfloat wave (float x, float y, float t) {\n    float wave = 0.3 * noise(vec3(0.3 * x - 2.1 * t, 0.5 * y,  2.0 * t))\n        ;\n        \n    return wave;\n}\n\nfloat waterSDF (vec3 position) {\n    float x = position.x;\n    float y = position.z;\n    float w = wave(position.x, position.z, iTime / 10.0);\n    vec3 pos = position + vec3(0, w, 0);\n    float floor = planeSDF(pos, vec3(0, -5, 0), vec3(0, 1, 0));\n    return floor;\n}\n\n\nfloat SDF (vec3 position) {\n    float water = waterSDF(position);\n    return water;\n}\n\n\nvec3 normal (vec3 position) {\n    float dt = 0.0001;\n    float dx = SDF(position + vec3(dt, 0, 0)) - SDF(position - vec3(dt, 0, 0));\n    float dy = SDF(position + vec3(0, dt, 0)) - SDF(position - vec3(0, dt, 0));\n    float dz = SDF(position + vec3(0, 0, dt)) - SDF(position - vec3(0, 0, dt));\n    vec3 normal = normalize(vec3(dx, dy, dz));\n    return normal;\n}\n\n\nfloat raymarch (vec3 start, vec3 direction) {\n    #define maxSteps 100\n    #define converged 0.0001\n    vec3 position = start;\n    float totalDistance = 0.0;\n    for (int i = 0; i < maxSteps; i++ ) {\n        // Step forward by the SDF distance\n        float currentDistance = SDF(position);\n        totalDistance += currentDistance;\n        position += direction * currentDistance;\n        \n        // If we are close to a surface, stop iterating\n        if ( currentDistance < converged ) break;\n    }\n    return totalDistance;\n}\n\n\nvec3 lighting ( vec3 surface ) {\n    // Define the lighting parameters\n    vec3 light = vec3(0, 2, 18) + 15.0 * vec3(cos(iTime), 0, sin(iTime));\n    float strength = 0.3;\n    vec3 specular = vec3(145, 228, 237) / 255.0;\n    vec3 diffuse = vec3(11, 45, 77) / 255.0;\n    \n    // Calculate the sphere's brightness\n    vec3 lightDelta = light - surface;\n    vec3 N = normal(surface);\n    vec3 L = normalize(lightDelta);\n    float lightDistance = raymarch(surface + 0.2 * N, L);\n    float brightness = strength * dot(N, L);\n    \n    // Add a reflection\n    \n    \n    // Add a Shadow color\n    float straightLightDistance = length(lightDelta);\n    bool occluded = straightLightDistance < 300.0\n        && straightLightDistance + 0.3 > lightDistance;\n    vec3 shadow = occluded\n        ? 1.0 * vec3(1, 1, 1)\n        : vec3(1, 1, 1);\n    \n    // Calculate the color\n\n    vec3 color = brightness * specular * shadow / pow(straightLightDistance, 2.0) * 300.0 + diffuse ;\n    return color;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Setup the camera and the pixel coordinates\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    vec3 start = vec3(uv, 0);\n    vec3 camera = vec3(0, 0.4, -0.3);\n    vec3 direction = normalize(start - camera);\n   \n    \n    // Get the distance to the nearest object\n    float distance = raymarch(start, direction);\n    if ( distance > 100.0 ) {\n        fragColor = vec4(17, 45, 79, 0)/255.0;\n        return;\n    }\n    \n    // Find the surface point and the corresponding normal \n    vec3 surface = start + distance * direction;\n    vec3 color = lighting(surface);\n    fragColor = vec4(color, 0.0);    \n    \n    // Output to screen\n    fragColor = vec4(color ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsG3Dw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 195], [302, 325, 350, 603, 1520], [1790, 1857, 1878, 1878, 2025], [2036, 2036, 2094, 2094, 2171], [2175, 2175, 2215, 2215, 2326], [2328, 2328, 2360, 2360, 2595], [2598, 2598, 2625, 2625, 2683], [2686, 2686, 2715, 2715, 3046], [3049, 3049, 3094, 3094, 3579], [3582, 3582, 3614, 3652, 4562], [4566, 4566, 4623, 4673, 5309]]}
{"id": "NsGSDh", "name": "Spirals-2", "author": "Loubi", "description": "An experiment on spirals, the first one actually", "tags": ["spiral", "fluid"], "likes": 3, "viewed": 49, "published": "Public", "date": "1634648881", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nfloat hash21(vec2 p) {\n\tp = fract(p*vec2(1.34, 435.345));\n    p += dot(p, p+34.23);\n    return fract(p.x*p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    \n    uv *= 10.;\n    \n    float t = iTime;\n    \n    float r = length(uv);\n    float theta = atan(uv.y, uv.x);\n    \n    float spiral1 = sin(theta + cos(r - t) * PI * 2.);\n    float spiral2 = sin(theta + PI + cos(r - t) * PI * 3.3);\n    // halve sin's amplitude (-1:1 -> -.5:.5)\n    spiral1 /= 2.;\n    spiral2 /= 2.;\n    // offset sin (-.5:.5 -> 0:1)\n    spiral1 += .5;\n    spiral2 += .5;\n    // halve again because there is 2 of them\n    spiral1 /= 2.;\n    spiral2 /= 2.;\n    // this sharpen spiral's border\n    float sm = smoothstep(.1, .4, spiral1);\n    float sm2 = smoothstep(.1, .4, spiral2);\n    \n    vec3 blue = vec3(0.237, 0.494, 0.686);\n    vec3 blue2 = vec3(0.215, 0.801, 0.731);\n    vec3 orange = vec3(0.821, 0.619, 0.321);\n    \n    vec3 color = vec3(orange);\n    \n    color = mix(color, blue2, sm);\n    color = mix(color, blue, sm2);\n    \n    // vignette\n    color = mix(color, blue, smoothstep(2.7, 7.8, r));\n    \n    float noise = hash21(uv);\n    color.r += noise * .13;\n    color.g += noise * .14;\n    color.b += noise * .18;\n    \n    color += mod(fragCoord.x, 2.) * .1;\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsGSDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 48, 48, 138], [140, 140, 197, 197, 1390]]}
{"id": "NsGSDm", "name": "ray maching demo", "author": "liuhaoqing", "description": "rayMac", "tags": ["raymac"], "likes": 0, "viewed": 9, "published": "Public", "date": "1634732265", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define Max_Steps 100    // 最大步数\n#define Max_Dist 100.\t // 最大距离\n#define Surf_Dist 0.01   // 每次步进距离\n#define sphere1 vec4(0, 1, 8 ,1)   //\n#define sphere2 vec4(-1, 2, 9 ,2)   //\n\n\nfloat sphere(vec3 pos , vec4 sphere)\n{\n\treturn length(pos - sphere.xyz) - sphere.w;   \n}\n\nfloat blob3(float d1, float d2, float d3)\n{\n    float k = 10.0;\n\treturn -log(exp(-k*d1)+exp(-k*d2)+exp(-k*d3))/k;\n}\n\nfloat collision(vec3 p){\n    float s1 = sphere(p, sphere1);\n    float s2 = sphere(p, sphere2);\n    float s3 =  p.y;\n    //return min(s1,min(s2,s3));\n    return blob3(s1, s2, s3);\n}\n\nfloat rayMaching(vec3 ro, vec3 rd){\n    float d0 = 0.0;\n    for(int i; i <= Max_Steps; i++){\n        vec3 p = ro + rd * d0;\n        float ds = collision(p);\n        d0 += ds;\n        if(d0 > Max_Dist || ds < Surf_Dist){\n            break;\n        }\n    }\n    return d0;   \n}\n\nvec3 getNormal(vec3 p){\n    float d = collision(p);\n    vec2 e = vec2(0.01,0);\n\n    vec3 n = d-vec3(\n        collision(p-e.xyy),\n        collision(p-e.yxy),\n        collision(p-e.yyx));\n       \n    return normalize(n);\n}\n\nfloat getLight(vec3 p){\n    vec3 lightPos = vec3(0,5,6);\n    lightPos.xz += vec2(sin(iTime),cos(iTime))*2.0;\n    vec3 l = normalize(lightPos-p);// 点光源\n    vec3 n = getNormal(p);\n    float dif = clamp(dot(n,l),0.,1.);//漫反射颜色\n    \n    float d = rayMaching(p + n*Surf_Dist*2.0,l);\n    if(d<length(lightPos-p))dif*=0.1;\n    \n    return dif;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0,0.5,0);\n    vec3 rd = normalize(vec3(uv,1));\n    float d = rayMaching(ro, rd);\n    vec3 p = ro + d * rd;\n    \n    vec3 col = vec3(getLight(p));\n    \n    fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsGSDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[206, 206, 244, 244, 294], [296, 296, 339, 339, 411], [413, 413, 437, 437, 593], [595, 595, 630, 630, 869], [871, 871, 894, 894, 1091], [1093, 1093, 1116, 1116, 1447], [1449, 1449, 1503, 1503, 1769]]}
{"id": "NsGSRd", "name": "Footwear Design 001", "author": "yasuo", "description": "slide moc EVA", "tags": ["footwear"], "likes": 11, "viewed": 150, "published": "Public API", "date": "1635085450", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define Slice(p,a) dot(p,vec2(cos(a),sin(a)))\n#define S(p,d,b) smoothstep(fwidth(p.y),0.0,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define MATERIAL_OUTSOLE 0\n#define MATERIAL_MIDSOLE1 1\n#define MATERIAL_MIDSOLE2 2\n#define MATERIAL_UPPER 3\n\n#define ZERO (min(iFrame,0))\n\n// IQ's 3D noise function. It's faster than the FBM and enough for me to design.\n// The compile is also faster.\nfloat noise3d( vec3 p )\n{\n\tconst vec3 s = vec3(27, 111, 57);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); \n    //p *= p*p*(p*(p*6. - 15.) + 10.); // option\n    h = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); \n}\n\nvec2 combine(vec2 val1, vec2 val2 ){\n    return (val1.x < val2.x)?val1:val2;\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.yz),p.x)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat baseOutsole(vec3 p, float h){\n    vec3 prevP = p;\n    \n    p.xy*=Rot(radians(90.0));\n    p.yz*=Rot(radians(15.0));\n    p.y*=1.5;\n    float d = sdCappedCylinder(p-vec3(0.0,0.0,0.25),h,0.3);\n    \n    p = prevP;\n    p.xy*=Rot(radians(90.0));\n    p.y*=1.5;\n    p.z*=1.2;\n    float d2 = sdCappedCylinder(p-vec3(0.0,0.0,-0.25),h,0.23);\n    d = min(d, d2);\n    \n    p = prevP;\n    d2 = sdBox(p-vec3(0,0.0,0.0),vec3(0.145,h,0.18));\n    d = min(d, d2);\n    \n    p = prevP;\n    p.xy*=Rot(radians(90.0));\n    p.yz*=Rot(radians(15.0));\n    p.y*=1.3;\n    d2 = sdCappedCylinder(p-vec3(-0.03,0.3,-0.01),0.2,0.125);\n    d = max(-d2,d);\n\n    return (d)*0.6;\n}\n\nfloat outsole(vec3 p){\n    vec3 prevP = p;\n    float d = baseOutsole(p,0.02);\n    \n    p.z = mod(p.z,0.04)-0.02;\n    p.y*=0.5;\n    p.xz*=Rot(radians(90.0));\n    p.xy*=Rot(radians(30.0));\n    float d2 = sdTriPrism(p-vec3(0.0,0.01,0.0),vec2(0.03,0.3));\n    \n    d = max(d,d2);\n    p = prevP;\n    d2 = baseOutsole(p-vec3(0.0,0.02,0.0),0.01);\n    d = min(d,d2);\n    \n    return d;\n}\n\nvec2 midsole(vec3 p){\n    float d = baseOutsole(p-vec3(0.0,0.03,0.0),0.01);\n    float d2 = baseOutsole(p-vec3(0.0,0.06,0.0),0.02);\n    \n    p.yz*=Rot(radians(-3.0));\n    float mask = p.y-0.07;\n    d2 = max(mask,d2);\n    \n    vec2 model = vec2(d,MATERIAL_MIDSOLE1);\n    vec2 model2 = vec2(d2,MATERIAL_MIDSOLE2);\n    \n    return combine(model,model2);\n}\n\nfloat upperBase(vec3 p){\n    vec3 prevP = p;\n    p.xz*=1.03;\n   \n    float d2 = baseOutsole(p-vec3(0,0.19,0),0.15);\n   \n    p.z-=0.06;\n    p.yz*=Rot(radians(40.0));\n    \n    float mask = p.y-0.2;\n    d2 = max(mask,d2);\n   \n    p = prevP;\n    p.yz*=Rot(radians(-10.0));\n    p.xz*=Rot(radians(15.0));\n    float d = sdEllipsoid(p-vec3(0.0,0.095,0.0),vec3(0.23,0.24,0.53));\n   \n    d = max(d,d2);\n    return d;\n}\n\nfloat upper(vec3 p){\n    vec3 prevP = p;\n    float d = upperBase(p);\n    p.x*=1.3;\n    \n    float d2 = upperBase(p-vec3(0.0,-0.02,-0.03));\n    d = max(-d2,d);\n    \n    float prevD = d;\n    \n    p = prevP;\n    p.yz*=Rot(radians(-10.0));\n    p.xz*=Rot(radians(15.0));\n    p.z*=0.6;\n    p = mod(p,0.11)-0.055;\n    d2 = length(p)-0.05;\n    \n    d = max(-d2,d);\n    \n    p = prevP;\n    p.z-=0.1;\n    p.yz*=Rot(radians(40.0));\n    \n    float mask = p.y-0.2;\n    d2 = max(-mask,prevD);    \n\n    return min(d,d2);\n}\n\nvec2 GetDist(vec3 p) {\n    p+=noise3d(p*300.0)*0.001;\n    vec3 prevP = p;\n    \n    p.y+=0.1;\n    p.z+=0.1;\n    float d = outsole(p);\n    \n    vec2 model = vec2(d,MATERIAL_OUTSOLE);\n    vec2 model2 = midsole(p);\n    \n    d = upper(p);\n    \n    vec2 model3 =vec2(d,MATERIAL_UPPER);\n    \n    return combine(model,combine(model2,model3));\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n    \n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<4; i++ )\n    {\n        float h = 0.01 + 0.15*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    float occ = calcOcclusion(p,n);\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(1,2,-2));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    float shadow = step(RayMarch(p+n*0.3,lightDir,1.0, 15).x,0.9);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(-0.5)*diff*shadow*occ;\n    diffCol += col*vec3(1.0,1.0,0.9)*skyDiff*occ;\n    diffCol += col*vec3(0.3,0.3,0.3)*bounceDiff*occ;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 20.)*occ; // spec\n        \n    return diffCol;\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    float nn = noise3d(p*80.0)*0.12;\n    if(mat == MATERIAL_OUTSOLE){\n        col = diffuseMaterial(n,rd,p,vec3(1.0,1.0,0.9)+nn);\n    } else if(mat == MATERIAL_MIDSOLE1){\n        col = diffuseMaterial(n,rd,p,vec3(1.0,0.6,0.0)+nn);\n    } else if(mat == MATERIAL_MIDSOLE2){\n        col = diffuseMaterial(n,rd,p,vec3(0.6,0.6,0.6))+nn;\n    } else if(mat == MATERIAL_UPPER){\n        \n        col = diffuseMaterial(n,rd,p,vec3(0.7,0.2, 0.3)+nn+nn);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec2 m =  iMouse.xy/iResolution.xy -.3;\n    \n    vec3 ro = vec3(0, 0, 1.0);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(radians(-30.0));\n    if(iMouse.z>0.){\n        ro.yz *= Rot(-m.y*3.14+1.);\n        ro.xz *= Rot(-m.x*6.2831);\n    } else {\n        ro.xz *= Rot(radians(-15.0+iTime*20.0));\n        \n        //ro.xz *= Rot(radians(45.0));\n    }\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(1.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n        col *= exp( -0.038*d.x*d.x*d.x );//fog\n    } else {\n        //col = vec3(1.0,1.0,0.2);\n        //col = vec3(0.95);\n    }\n    \n    \n    // gamma correction\n    col = pow( col, vec3(0.9545) );    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsGSRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[479, 591, 616, 616, 955], [957, 957, 993, 993, 1035], [1037, 1112, 1164, 1164, 1271], [1273, 1273, 1304, 1304, 1391], [1393, 1393, 1429, 1429, 1512], [1514, 1514, 1551, 1551, 1634], [1636, 1636, 1671, 1671, 2284], [2286, 2286, 2308, 2308, 2664], [2666, 2666, 2687, 2687, 3017], [3019, 3019, 3043, 3043, 3427], [3429, 3429, 3449, 3449, 3936], [3938, 3938, 3960, 3960, 4274], [4276, 4276, 4334, 4334, 4601], [4603, 4603, 4627, 4627, 4828], [4830, 4830, 4872, 4872, 5067], [5069, 5110, 5159, 5159, 5450], [5452, 5452, 5509, 5509, 6128], [6130, 6130, 6189, 6189, 6656], [6658, 6658, 6715, 6715, 7747]]}
{"id": "NsKSRz", "name": "Abstract Geometric Art Pattern", "author": "Shane", "description": "Applying a very simple procedure involving multiple colored square-shaped overlays and basic lighting to produce a greeble-like surface in the style of abstract art.", "tags": ["procedural", "voronoi", "texture", "abstract", "art", "greeble"], "likes": 57, "viewed": 460, "published": "Public API", "date": "1635163347", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n    Abstract Geometric Pattern\n    --------------------------\n\n    Applying a very simple procedure involving multiple colored square overlays \n    and basic lighting to produce a greeble-like surface in the style of abstract \n    art... or something to that effect. :)\n    \n    I'd been experimenting with procedural greebled surfaces a while ago, and this \n    was just a byproduct of that. I wouldn't call it a greebled surface per se, but \n    if you mapped it onto a 3D surface, it'd have that feel. Thanks to the basic \n    lighting, it also has a painted feel. On a side note, a lot of wrapped \n    procedural textures you see have usually been highlighted in a similar wrappable \n    unidirectional way.\n    \n    The technique is about as simple as it gets: Combine some offset squares to \n    form a polygon with squared sides. Construct a square grid and render these\n    in each cell. After that, combine a few resultant layers at various frequencies.\n    The method is different, but similar to stacking Voronoi layers.\n    \n    I didn't put a lot of effort into rendering speed, as this is the kind of thing\n    that you should probably prerender into one of the buffers prior to use. By the\n    way, I have a couple of 3D greeble examples that I'll post later.\n    \n    \n    Other examples:\n    // Similar principals, and a nice result. By the way Piyushslayer has\n    // some other really nice examples.\n    Abstract Squircles - piyushslayer \n    https://www.shadertoy.com/view/Wtc3D8\n    \n\n*/\n\n\n// Just the two palattes - Vibrant: 0, Earth: 1.\n#define PALETTE 0\n\n// Base shape -  Square: 0, Diamond: 1., Hexagon: 2, Octagon: 3, Circle: 4.\n#define SHAPE 0\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n\n// Compact, self-contained version of IQ's 2D value noise function.\nfloat n2D(vec2 p){\n   \n    // Setup.\n    // Any random integers will work, but this particular\n    // combination works well.\n    const vec2 s = vec2(1, 113);\n    // Unique cell ID and local coordinates.\n    vec2 ip = floor(p); p -= ip;\n    // Vertex IDs.\n    vec4 h = vec4(0., s.x, s.y, s.x + s.y) + dot(ip, s);\n   \n    // Smoothing.\n    p = p*p*(3. - 2.*p);\n    //p *= p*p*(p*(p*6. - 15.) + 10.); // Smoother.\n   \n    // Random values for the square vertices.\n    h = fract(sin(h)*43758.5453);\n   \n    // Interpolation.\n    h.xy = mix(h.xy, h.zw, p.y);\n    return mix(h.x, h.y, p.x); // Output: Range: [0, 1].\n}\n\n// FBM -- Accumulated noise layers of modulated amplitudes and frequencies.\nfloat fBm(vec2 p){ \n\n    // Layer the noise.\n    float ns = 0., sum = 0., a = 1.;\n    for(int i = 0; i<5; i++){\n    \n        ns += n2D(p)*a;\n        p *= 2.5;\n        sum += a;\n        a /= 1.5;\n    }\n    \n    return ns/sum; // Range: [0, 1].\n}\n\n/*\nfloat sBoxS(in vec2 p, in vec2 b, in float rf){\n  \n  vec2 d = abs(p) - b + rf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - rf;\n    \n}\n*/\n\n// Shape distance metrics. You could put whatever you feel like here.\nfloat dist(vec2 p, vec2 b){\n \n      \n      #if SHAPE == 0\n      // Square.\n      p = abs(p) - b;\n      return max(p.x, p.y);\n      #elif SHAPE == 1\n      // Diamond.\n      p = abs(p);\n      return (p.x + p.y)*.7071 - mix(b.x, b.y, .5);\n      #elif SHAPE == 2\n      // Hexagon.\n      p = abs(p);\n      return max(p.x*.8660254 + p.y*.5, p.y) - mix(b.x, b.y, .5);\n      #elif SHAPE == 3\n      // Octagon.\n      p = abs(p);\n      return max((p.x + p.y)*.7071, max(p.x, p.y)) - mix(b.x, b.y, .5);\n      #else\n      // Circle.\n      return length(p) - (b.x + b.y)/2.;\n      #endif\n      \n      //p = abs(p) - b;\n      //p = p*.8660254 + p.yx*.5;\n      //return max(p.x, p.y);\n      \n      //p = abs(p)-b;\n      //p = (p + p.yx)*.7071;\n      //return max(p.x, p.y);\n}\n\n\n// The cell shape: This is just a union of four offset shapes, but it could\n// be anything you can dream up. This particular random shape exceeds the\n// boundaries of the cell, so surrounding cells need to be accounted for.\n\nfloat cellShape(vec2 p, vec2 ip){\n    \n    float d = 1e5;\n    \n    for(int i = 0; i<4; i++){\n    \n        // Four random values.\n        float fi = 1./(1. + float(i));\n        vec4 rnd = vec4(hash21(ip + .15*fi), hash21(ip + .23*fi), \n                        hash21(ip + .32*fi), hash21(ip + .41*fi));\n        \n        // Offset position.\n        vec2 q = p - (rnd.xy - .5)*1.5;\n    \n        // Render a square, diamond, or whatever.\n        //float shape = sBoxS(q, .1 + rnd.zw*.3, min(rnd.z, rnd.w)*.07);\n        float shape = dist(q, .1 + rnd.zw*.3); // Rectangular dimensions.\n        //float shape = dist(q, vec2(.1 + length(rnd.zw)*.2)); // Square.\n        \n        // Take the minimum (union) of all combined shapes.\n        d = min(d, shape);\n    \n    }\n    \n    // Holes... Didn't work. :)\n    //d = abs(d  + .135) - .135;\n    \n    return d; // Return the random distance, or bound.\n    \n}\n\n\n\n// Constructing the grid pattern: Render a random shape in each cell.\nvec4 gridPattern(vec2 p, float sf){\n    \n    const vec2 sc = vec2(1);\n    \n    vec3 col = vec3(1);\n    \n    float alpha = .9;\n    float d = 1e5;\n    \n    // The cell shapes exceed the cell boundaries, which means covering all \n    // surrounding cells that the shape covers. In this case, there are 9.\n    for(int i=-1; i<=1; i++){\n        for(int j=-1; j<=1; j++){\n          \n            // Local cell coordinates and cell ID.\n            vec2 cntr = vec2(i, j) - .5;\n            vec2 q = p;\n            vec2 ip = floor(q/sc - cntr) + .5; \n            q -= ip*sc;\n        \n            // Cell shape.\n            float c = cellShape(q, ip);\n            \n            // Using the cell ID to produce some random number.\n            vec2 rnd = vec2(hash21(ip/23.), hash21(ip/113.)) - .5;\n            rnd.y = smoothstep(.985, .997, sin(rnd.y*6.2831 + iTime/2.)*.5 + .5);\n            \n            // Feeding the random cell-ID-based value into IQ's cool palette formula\n            // to produce the shape color.\n            #if PALETTE == 1\n            // Earth tones.\n            vec3 cellCol = (.5 + .46*cos(rnd.x*6.2831/2. + vec3(0, 1, 2)))/3.5;\n            // Blinking highlights.\n            cellCol = mix(cellCol, mix(cellCol, cellCol*vec3(1.8, .9, .3), 1.), rnd.y); \n            #else\n            // Vibrant palette.\n            vec3 cellCol = (.5 + .46*cos(rnd.x*6.2831/2.75 + vec3(0, 1, 2) + 2.2));\n            // Blinking highlights.\n            cellCol = mix(cellCol, mix(cellCol, cellCol.xzy, .6), rnd.y); \n            #endif\n            \n            // Greyscale.\n            //cellCol = vec3(dot(cellCol, vec3(.299, .587, .114)))/1.5;\n            \n            // Using the shape distance to produce a bit of shading.\n            float sh = max(.5 - c/.1, 0.)*max(1. - dot(q, q)*.5, 0.)*2.5;\n            \n            // Rendering to the canvas. This is the way I like to do it, but you can\n            // use whatever system you're comfortable with. The following are just some\n            // Photoshop type laters: Shadow, outer edge, shaded color and an inner\n            // edge for decoration.\n            col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., abs(c) - .01))*.5*alpha);\n            col = mix(col, vec3(0), (1. - smoothstep(0., sf, abs(c) - .01)));\n            col = mix(col, cellCol*sh, (1. - smoothstep(0., sf, c))*alpha);//\n            col = mix(col, vec3(0), (1. - smoothstep(0., sf, abs(c + .06) - .005)));\n            \n            // Keeping a copy of the minimum overall distance for the layering routine.\n            d = min(d, c);\n\n        }\n    } \n    \n    // Return the shaded shape color and associated distance.\n    return vec4(col, d);\n    \n}\n\n// Layering the grid pattern above.\nvec3 layeredPattern(vec2 p, vec3 col, float sf){\n    \n\n    // Frequency (associated with scale) and alpha (transparency) values.\n    float freq = 1., alpha = 1.;\n    \n    for(int i=0; i<4; i++){\n    \n        // Random values based on layer count.\n        float fi = 1./(1. + float(i));\n        vec2 rnd = vec2(hash21(vec2(0) + .1*fi), hash21(vec2(0) + .2*fi))*2.;\n        \n        // Render this particular grid layer.\n        \n        // Color and distance value.\n        vec4 gCol = gridPattern((p - rnd)*freq, sf*freq);\n        // Mix a drop shadow, edge and layer color onto the previous layer.\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*8.*freq, abs(gCol.w) - .01))*.5*alpha);\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*freq, abs(gCol.w) - .01))*alpha);\n        col = mix(col, gCol.xyz, (1. - smoothstep(0., sf*freq, gCol.w))/freq*alpha);\n        \n        // Increace the frequency\n        freq *= 1.4;\n        alpha *= .92;\n    }\n    \n    /*\n    // Overlayed diagonal stripe pattern.\n    float pat = (abs(fract((p.x - p.y)*64.) - .5)*2. - .125)/64./2.;\n    pat = smoothstep(0., sf, pat)*.5 + .65;\n    col *= pat;\n    */\n    \n    return col; // Overall texture value.\n    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n\n    // Screen coordinates: They're already in aspect correct form,\n    // so tranlation and scalar resizing is all that is necessary.\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    \n    // Scale and translation.\n    const float sc = 1.5;\n    vec2 p = uv*sc + vec2(1, .25)*iTime/5.;\n    \n    // Coordinate perturbation.\n    p += vec2(n2D(p*24.), n2D(p*24. + 5.))*.004;\n    \n    // Smoothing factor.\n    float sf = sc/iResolution.y;\n    \n    // Background color -- Most of this will be covered with colored shapes.\n    vec3 bg = vec3(.05);\n    \n    // Two layered pattern samples. The second will be used for \n    // highlighting.\n    float sDist = 3./450.;\n    vec3 col = layeredPattern(p, bg, sf);\n    vec3 col2 = layeredPattern(p - normalize(vec2(1, 1))*sDist, bg, sf);\n    \n    // Two bump values. One from each direction.\n    float b = max(dot(col2 - col, vec3(.299, .587, .114)), 0.)/sDist;\n    float b2 = max(dot(col - col2, vec3(.299, .587, .114)), 0.)/sDist;\n    \n    \n    // Applying some subtle fBm noise.\n    float ns = fBm(p*40.)*.8 + .5;\n    col *= ns;\n\n    \n    // Adding the bump highlights.\n    col = col*(vec3(.2, .4, 1)*b*b*.005 + vec3(1, .15, .05)*b2*.04 + .6);\n\n    \n\n    /*\n    // Subtle diagonal pattern overlay. Not used.\n    float pat = (abs(fract((p.x - p.y)*64.) - .5)*2. - .125)/64./2.;\n    pat = .25 + smoothstep(0., sf, pat);\n    col *= pat;\n    */\n \n    /*\n    // Cell borders.\n    vec2 q = abs(fract(p) - .5);\n    float bord = max(q.x, q.y) - .5;\n    col = mix(col, vec3(1), (1. - smoothstep(0., sf*4., abs(bord) - .0025))*.75);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, abs(bord) - .0025)));\n    */\n    \n    \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .0625);\n    // Colored variation.\n    //col = mix(col*vec3(1, .05, .15), col, pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125));\n    \n    // Rought gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsKSRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1677, 1705, 1726, 1726, 1788], [1791, 1859, 1877, 1984, 2472], [2474, 2550, 2568, 2594, 2794], [2948, 3018, 3045, 3045, 3778], [3781, 4006, 4039, 4039, 4904], [4908, 4978, 5013, 5013, 7660], [7662, 7698, 7746, 7826, 8903], [8905, 8905, 8959, 9095, 10963]]}
{"id": "NsKSW3", "name": "The Lodge", "author": "decripter37", "description": "What year is it?", "tags": ["twinpeaks", "liminal"], "likes": 4, "viewed": 136, "published": "Public API", "date": "1635406642", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float trn(float x){\n  float ret=0.;\n  ret = abs(x - floor(x+.5))*2.;\n  return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  vec2 xy = fragCoord.xy;\n  vec2 uv = xy/iResolution.xy;  \n  vec3 col = vec3(1., 1., 1.);\n  float band = 50.;\n  float bandrp = 30.;\n  float pro = (1.+uv.y);\n  vec4 w = vec4(-.006*pow((1.+uv.y),5.), .2, band*2., 0.);\n  bool flr =\n  mod(xy.x +\n      w.z*trn(w.y*iTime + w.x*xy.y + w.a),\n      band*2.)\n   >= band;\n  vec4 v = vec4(0.01*(.5-uv.x), 1., bandrp*sin(iTime)*(1.-uv.y), 0.);\n  bool drp =\n  mod(xy.x +\n    v.z*sin(v.y*iTime + v.x*xy.y + v.a),\n    bandrp*2.)\n  >= bandrp;\n  if(uv.y<.5){\n    if(flr){\n      col*=0.2;\n    }else{\n      col=vec3(1.);\n    }\n    col*=(.5-uv.y)*2.;\n    col.gb*=1.-uv.y;\n  }else{\n    if(drp){\n      col*=0.7;\n    }else{\n      col=vec3(1.);\n    }\n    col.gb*=pow(1.-uv.y, 2.);\n   col*=uv.y-.45;\n  }\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsKSW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 84], [86, 86, 142, 142, 903]]}
{"id": "NsKSz3", "name": "Water Punk", "author": "luckyballa", "description": "water dance", "tags": ["raymarching", "refraction", "webcam"], "likes": 0, "viewed": 81, "published": "Public", "date": "1635077803", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define MAX_STEPS 40\n#define MAX_DIST 40.\n#define SURF_DIST .005\n#define samples 32\n#define LOD 2\n\nfloat hash(vec2 n) {\n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 184.5453);\n}\n\nfloat noise(vec2 n) {\n    const vec2 d = vec2(0.0, 1.0);\n    vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(hash(b), hash(b + d.yx), f.x), mix(hash(b + d.xy), hash(b + d.yy), f.x), f.y);\n}\n\nfloat sdSphere( vec3 p, float s ) { return length(p)-s; }\n\n\nfloat smin( float a, float b, float k ) {\n    float h = max(k-abs(a-b), 0.0);\n    return min(a, b) - h*h*0.25/k; \n}\n\n\nfloat getDist(vec3 p) {\n    float matId;\n    float final = MAX_DIST;\n    float iTime = iTime; \n    p = p - vec3(0.,0.5, 5.);\n    p.x = abs(p.x);\n    vec3 tempP = p;\n    for (int i = 0; i < 10; i++) {\n        float fi = float(i + 1)  + floor(float(i) / 5.);\n        vec3 pos = p;\n        float xmov = -dot(p.xy, tempP.xy + tempP.xy * fi * 0.8) * 3.;\n        float ymov = sign(mod(fi, 2.)) - dot(tempP.xy, tempP.xy) * 0.2 - xmov * 0.2;\n\n        vec2 xy = vec2(xmov, ymov);\n        \n        pos.xy += xy * 0.2;\n        pos.xy -= noise(pos.xy * 15. / fi) * 0.3;\n        pos.xy += (vec2(sin(iTime + fi) * 2., cos(iTime / 2. - fi) * 0.5) * 0.1 * fi);  \n\n        pos.z += sin(iTime * cos(float(i * 4))) * 0.5;\n        float r = sin(fi) * 0.2;\n        float n = min(sin(pos.z * float(i) * 5.), cos(pos.x * pos.y * float(i) * 10.)) * 0.1;\n        float bubble = sdSphere(pos + vec3(n) * 0.1 - vec3(0.05), r);\n        final = smin(final, bubble, 0.3 + final * 0.04);\n        \n        tempP = pos;\n    }\n\n    \n    return final;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    float matId = -1.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float res = getDist(p);\n        float dS = res;\n        dO += dS;\n        \n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 normals(vec3 p, float of ) {\n\tfloat d = getDist(p);\n    vec2 e = vec2(of, 0);\n    \n    vec3 n = d - vec3(\n        getDist(p-e.xyy),\n        getDist(p-e.yxy),\n        getDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat diffuse(vec3 p, vec3 n, vec3 lp) {\n    vec3 l = normalize(lp-p);\n    float dif = clamp(dot(n, l), 0., 1.);\n\n    return dif;\n}\n\nfloat specular(vec3 rd, vec3 ld, vec3 n) {    \n    vec3 reflection = reflect(-ld, n);\n    float spec = max(dot(reflection, -normalize(rd)), 0.); \n    return spec;\n}\n\nfloat gaussian(vec2 i) {\nconst float sigma = float(samples) * .25;\n    return exp( -.5* dot(i/=sigma,i) ) / ( 6.28 * sigma*sigma );\n}\n\nvec4 blur(sampler2D sp, vec2 U, vec2 scale) {\n    const int  sLOD = 1 << LOD;\n    vec4 O = vec4(0);\n    int s = samples/sLOD;\n    \n    for ( int i = 0; i < s*s; i++ ) {\n        vec2 d = vec2(i%s, i/s)*float(sLOD) - float(samples)/2.;\n        O += gaussian(d) * texture(sp, U + scale * d);\n    }\n    \n    return O / O.a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.0);\n    \n    float iTime = iTime * 2.;\n\n\tvec3 ro = vec3(.0, 0., 1.);\n    vec3 rd = normalize(vec3(uv.x, uv.y + 0.2 , 2.));\n    vec3 ld =  vec3(0., 0., 1.);\n    float d = rayMarch(ro, rd);\n    vec3 p = ro + rd * d;\n    vec3 n = normals(p, 0.003);\n    float dif = diffuse(p, n, ld); \n    float spec = specular(rd, ld, n) * 0.1;\n    float fresnel = smoothstep(0.5, 0.2, dot(-rd, n));\n    vec3 dispersion = vec3(noise(n.xy * 2.7), noise(n.xy * 3.), noise(n.xy * 3.3)) * 0.4; \n    \n    vec2 camUV = fragCoord / iResolution.xy;\n    vec3 cam1 =  texture(iChannel0, camUV).xyz * 0.9;\n    camUV += n.xy * 0.05 * dif;\n    vec3 cam2 = blur(iChannel0, camUV, vec2(0.002)).xyz * 0.9;\n\n    col = dif * cam2;\n    col += spec;\n    col += cam2 * 0.15;         \n    col += dispersion;\n    col += fresnel * 0.2;\n    \n    if (d > MAX_DIST) { col = vec3(cam1);  }\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "4sf3zn", "previewfilepath": "/presets/webcam.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/webcam.png", "ctype": "webcam"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsKSz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 100, 120, 120, 187], [189, 189, 210, 210, 416], [418, 418, 453, 453, 475], [478, 478, 519, 519, 593], [596, 596, 619, 619, 1614], [1616, 1616, 1650, 1650, 1918], [1920, 1920, 1953, 1953, 2141], [2143, 2143, 2183, 2183, 2274], [2276, 2276, 2318, 2318, 2440], [2442, 2442, 2466, 2466, 2575], [2577, 2577, 2622, 2622, 2898], [2900, 2900, 2957, 2957, 3916]]}
{"id": "NsKXDR", "name": "shooter demo WIP", "author": "yasuo", "description": "shooter demo WIP", "tags": ["shooter"], "likes": 5, "viewed": 176, "published": "Public API", "date": "1634480000", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define MAX_STEPS 80\n#define MAX_DIST 32.\n#define SURF_DIST .001\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define MATERIAL0 0\n#define MATERIAL1 1\n#define MATERIAL2 2\n#define SPEED 2.0\n#define ZERO (min(iFrame,0))\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n\nvec3 tex(vec2 p, vec3 col, vec3 col2){\n    p*=3.0;\n    vec2 uv = fract(p)-0.5;\n    vec2 id = floor(p);\n    \n    vec2 randP = fract(sin(id*123.456)*567.89);\n    randP += dot(randP,randP*34.56);\n    float rand = fract(randP.x*randP.y);\n    \n    float speed = 0.8;\n    if(rand<0.5){\n        uv*=Rot(radians(90.0));\n        speed = 0.6;\n        uv.x+=0.4;\n    } else {\n        uv.x-=0.4;\n    }\n    \n    float dd = S(B(uv,vec2(0.04,0.5)),-0.05);\n    speed*=1.8;\n    uv.y*=0.5;\n    uv.y+=sin(iTime*speed)*0.4;\n    col=mix(col,col2,dd+S(length(uv)-0.18,-0.2));\n    return col;\n}\n\n// IQ's 3D noise function. It's faster than the FBM and enough for me to design.\n// The compile is also faster.\nfloat noise3d( vec3 p )\n{\n\tconst vec3 s = vec3(27, 111, 57);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); \n    //p *= p*p*(p*(p*6. - 15.) + 10.); // option\n    h = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); \n}\n\nvec2 combine(vec2 val1, vec2 val2 ){\n    return (val1.x < val2.x)?val1:val2;\n}\n\nfloat B3D(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return max(max(p.x,p.y),p.z);\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n    p = abs(p);\n    return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat ship(vec3 p){\n    p*=0.6;\n    vec3 prevP = p;\n    p.z*=0.8;\n    float d = sdOctahedron(p,0.3);\n    float d2 = sdOctahedron(p-vec3(0.0,0.0,-0.25),0.2);\n    d = min(d,d2);\n    d2 = sdOctahedron(p-vec3(0.0,0.0,-0.5),0.1);\n    d = min(d,d2);\n    \n    p.xy*=Rot(radians(iTime*-100.0));\n    p.z*=0.3;\n    p.x = abs(p.x);\n    p.x-=0.45;\n    d2 = sdOctahedron(p-vec3(0.0,0.0,-0.1),0.1);\n    d = min(d,d2);\n    return d;\n}\n\nfloat sdBase( in vec3 p)\n{\n    p = mod(p,4.2)-2.1;\n    float d = B3D(p, vec3(0.3));\n    for(float i = 1.; i<=2.; i++){\n        p = abs(p);\n        p -= 1.5*i;\n        p.xz *= Rot(radians(i*45.0));\n        p.yz *= Rot(radians(i*-30.0));\n        d = min(d,B3D(p+vec3(cos(i)*0.3,sin(i)*0.5,0.0), vec3(sin(i)*0.8)));\n    }\n    return d;\n}\n\nvec3 path(float z)\n{\n    vec3 p = vec3(sin(z) * 0.7, cos(z * .8), z);\n    return p;\n}\n\nvec2 GetDist(vec3 p) {\n    p+=noise3d(p*1000.0)*0.1;\n    \n    vec3 q = p+1.5;\n    q.z -= iTime*SPEED;\n    if(mod(iTime,20.0)<15.0){\n        q.z +=2.0;\n    } else {\n        q.z -=6.0;\n    }\n    \n    q.x-=1.5;\n    q.y-=1.5;\n    float sp = ship(q);\n    \n    vec3 prevP = p;\n    p.xy -= path(p.z).xy;\n    \n    p.z = 0.;\n    float d = B3D(p,vec3(3.0,2.5,2.5));\n    \n    p = prevP;\n    p.z += iTime*SPEED;\n    float d2 = sdBase(p);\n    \n    p.z += iTime*SPEED*1.05;\n    p.z = mod(p.z,2.0)-1.0;\n    p.x = abs(p.x);\n    p.x-=2.3;\n    p.xy*=Rot(radians(45.0));\n    float d3 = sdOctahedron(p,0.4);\n    \n    vec2 res = combine(vec2(max(-d,d2),MATERIAL0),vec2(d3,MATERIAL1));\n    res = combine(res,vec2(sp,MATERIAL2));\n    return res;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n\n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n                \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<4; i++ )\n    {\n        float h = 0.01 + 0.15*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    float occ = calcOcclusion(p,n);\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(p.x,p.y,-2));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(0.8,0.7,-1.5)*diff*occ;\n    diffCol += col*vec3(0.8,0.5,1.9)*skyDiff*occ;\n    diffCol += col*vec3(1.3,1.3,1.7)*bounceDiff*occ;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 20.)*occ; // spec\n        \n    return diffCol;\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    if(mat == MATERIAL0){\n        vec3 np = p;\n        np.z+=iTime*SPEED;\n        float nn = noise3d(np*5.0)*0.15;\n        col = diffuseMaterial(n,rd,p,tex(p.xy,vec3(0.2,0.3,0.9)*nn+0.3,vec3(0.9,0.3,0.3)));\n    } else if(mat == MATERIAL1){\n        col = diffuseMaterial(n,rd,p,vec3(0.6,0.3,0.7));\n    } else if(mat == MATERIAL2){\n        col = diffuseMaterial(n,rd,p,vec3(0.2,0.1,1.5)+tex(p.xy,vec3(0.2,0.3,1.5),vec3(0.9,0.9,1.2)));\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    float t = iTime*SPEED;\n    vec3 ro = path(t+1.5);\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 1.0);\n    \n    if(mod(iTime,20.0)<15.0){\n        rd*=matRotateZ(radians(iTime*15.0));\n    } else {\n        rd*=matRotateZ(radians(iTime*15.0))*matRotateX(radians(180.0));\n    }\n    \n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(1.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n        col *= exp( -0.0001*d.x*d.x*d.x*d.x );//fog\n    } else {\n        col = vec3(0.0);   \n    }\n    \n    // POST EFFECTS    \n    rd.z+=iTime*2.0;\n    \n    // dust effect\n    float c = noise3d(rd) * 0.5 + noise3d(rd * 5.0) * 0.25 + noise3d(rd * 10.0) * 0.1;    \n    col+=vec3(0.7,0.1,0.9)*c*0.3;    \n    \n    // gamma correction\n    col = pow( col, vec3(0.9545) );    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsKXDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 672, 710, 710, 1243], [1245, 1357, 1382, 1382, 1721], [1723, 1723, 1759, 1759, 1801], [1803, 1803, 1830, 1830, 1884], [1886, 1886, 1924, 1924, 1981], [1983, 1983, 2002, 2002, 2402], [2404, 2404, 2430, 2430, 2738], [2740, 2740, 2760, 2760, 2825], [2827, 2827, 2849, 2849, 3551], [3553, 3553, 3611, 3611, 3882], [3884, 3884, 3908, 3908, 4109], [4111, 4111, 4153, 4153, 4348], [4350, 4391, 4440, 4440, 4731], [4733, 4733, 4790, 4790, 5347], [5349, 5349, 5408, 5408, 5865], [5867, 5867, 5924, 5924, 6908]]}
{"id": "NsKXWD", "name": "Circles patterns", "author": "Loubi", "description": "Trying pattern repetition, really simple but really fun too !", "tags": ["noise", "wave", "color", "circle", "sine"], "likes": 5, "viewed": 50, "published": "Public", "date": "1634660930", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\n// Noise by IQ <3 https://www.shadertoy.com/view/Msf3WH\nvec2 hash( vec2 p ) { // replace this by something better\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\nfloat noise( in vec2 p ) {\n    const float K1 = (sqrt(3.)-1.)/2.;\n    const float K2 = (3.-sqrt(3.))/6.;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    uv *= 10.;\n    vec2 gv = fract(uv) + .5;\n    vec2 id = floor(uv);\n    \n    float circleX = sin(id.y * .1 + id.x * .32 + iTime * 2.) * .3 + 1.;\n    float circleY = sin(id.y * .1 + id.x * .2 + iTime * 3.) * .2 + 1.;\n    vec2 circlePos = vec2(circleX, circleY);\n    \n    float circle = length(gv - circlePos);\n    float circleRadius = noise(vec2(length(uv), iTime * .2)) * sin(id.y * .1 + id.x * .2 + iTime) * .25 + .3;\n    circle = smoothstep(circleRadius, circleRadius + .0001, circle) * .3;\n    \n    vec3 color = vec3(2., sin(length(gv) * 1.2), gv.x);\n    \n    color = mix(color, vec3(0.), circle);\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsKXWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 82, 103, 139, 254], [255, 255, 281, 281, 734], [736, 736, 793, 793, 1496]]}
{"id": "NsKXzh", "name": "psychedelic #1", "author": "warpGooblin", "description": "just an experiment... use your mouse as well...", "tags": ["raymarching", "psychedelic"], "likes": 6, "viewed": 97, "published": "Public", "date": "1634329117", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision highp float;\n\n\n#define mouse iMouse\n#define time iTime\n\nuniform float zoom;\n\nvec3 ti;  // tile index\n\n#define BOXES_STEPS 0.45\n#define MAX_STEPS 300\n#define MAX_DIST 90.\n#define SURF_DIST .001\n\n#define EPSILON 0.0001\n\nfloat tw()\n{\n    return sin(time) * 0.5 + 0.5;\n}\n\nmat2 Rot(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\nmat3 Rotation3d(vec3 axis, float angle)\n{\n  axis = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n\n  return mat3(\n    oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  \n    oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  \n    oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c           \n    \n    );\n}\n\n\nfloat smin(float a, float b, float k) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat sdSphere(vec3 p, float s)\n{\n  return length(p)-s;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    return length(p-c)-r;\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i;\n}\n\nfloat sdTorus(vec3 p, vec2 r) {\n    float x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec3 opRep(in vec3 p, in vec3 c)\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    ti = floor((p + c*0.5)/c);  // tile index global variable\n    return q;\n}\n\nvec3 opRepLim(in vec3 p, in float c, in vec3 limita, in vec3 limitb)\n{\n    //p.y -= 0.75;\n    return p - c * clamp(floor(p / c + 0.5), limita, limitb);\n}\n\n// www.mercury.sexy/hg_sdf version\n/* vec3 pMod3(inout vec3 p, vec3 size) {\n    vec3 c = floor((p + size*0.5)/size);\n    p = mod(p + size*0.5, size) - size*0.5;\n    return c;\n} */\n\n\n\nfloat GetDist(vec3 p) {\n    //float plane = p.y;\n    //float box = sdBox(p-vec3(0,1,0), vec3(1));\n\n    //vec3 r = opRepLim(p, 1.60, vec3(-2.00), vec3(2.00));\n    vec3 r = opRep(p, vec3(3.60));\n    float boxes = sdBox(r, vec3(0.40));\n    float spheres = sdSphere(r, 0.43);\n    float spheres2 = sdSphere(r, 0.35);\n    //float d; \n    //d = boxes;\n    //float d = min(plane, boxes);\n\n    float d = max(-spheres, boxes * BOXES_STEPS);\n    float d1 = min(spheres2, d);\n    //float d1 = smin(spheres2, d, 0.95);\n    d = mix(-d1, spheres2, 0.295);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n    float dO=0.0;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p);\n    vec2 e = vec2(EPSILON, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(3, 5, 4);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n   // if(p.y<.01 && d<length(lightPos-p)) dif *= .5;\n    \n    return dif;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float tw = tw();\n\n    vec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.x;\n    //vec2 uv = (gl_FragCoord.xy - 0.5 * resolution.xy)  / resolution.y;\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.y += 0.5;\n    \n    vec2 m = vec2(0.001, 0.005) * mouse.xy * vec2(- aspectRatio, -1.0);\n    //m += resolution.y / resolution.x;\n\n    vec3 col = vec3(0);\n\n    vec3 ro = vec3(0.0, 0.0, -3.0);   // i changed this ... this is flight through   \n    // ro vec3 (l..r, o..u, distance)\n    //vec3 ro = vec3(0.0);\n    \n    //ro.yz *= Rot(time);\n    \n    //ro *= Rotation3d(vec3(1.0, 0.0, 1.0), time);\n\n    ro.xz *= Rot(0.1*time);\n    \n    ro.yz *= Rot(-m.y*3.14+1.55);\n    ro.xz *= Rot(-m.x*8.);\n    //ro.z += 12.;\n    \n    vec3 rd = R(uv, ro, vec3(0.0, 0.0, 0.0), +1.0);  // i changed this from vec3(0,1,0)\n\n    float d = RayMarch(ro, rd);\n    \n    if(d < MAX_DIST)\n    {\n        vec3 p = ro + rd * d;\n    \n        float dif = GetLight(p);\n        //col = vec3(dif);   \n        col = GetNormal(p) * 0.5 + 0.5 - 0.5 * dif;\n        //col = 0.2 * col;\n        //float tpos = floor((sin(time*1.5)*0.5+0.5)*18.0);\n        /* if (length(ti) <= abs(tpos))                          // tile position\n        {\n            col *= 10.; \n        } */ \n        //float fog0 = smoothstep(6.0, MAX_DIST, d);   // fog\n        //col = mix(vec3(0.0), col, 90.1*fog0);\n    }\n    \n    col = pow(col, vec3(.4545));    // gamma correction\n    // fog #2\n    float fog = 0.005;\n    col *= 1.25 / (1.0  + pow(d, 3.0) * fog); // pow 2.0\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsKXzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 228, 240, 240, 276], [278, 278, 297, 297, 373], [376, 376, 417, 417, 881], [884, 884, 923, 923, 1012], [1014, 1014, 1047, 1047, 1071], [1073, 1073, 1123, 1123, 1294], [1296, 1296, 1347, 1347, 1660], [1662, 1662, 1693, 1693, 1764], [1766, 1766, 1795, 1795, 1879], [1881, 1881, 1915, 1915, 2028], [2030, 2030, 2100, 2119, 2183], [2185, 2368, 2391, 2525, 2924], [2926, 2926, 2960, 2960, 3178], [3180, 3180, 3204, 3204, 3400], [3402, 3402, 3426, 3426, 3698], [3700, 3700, 3742, 3742, 3937], [3940, 3940, 3995, 3995, 5555]]}
{"id": "NstSDs", "name": "Hyperbolic Group Limit Set", "author": "neozhaoliang", "description": "old version of https://www.shadertoy.com/view/WdGBz3", "tags": ["3d", "tiling", "hyperbolic", "limitset"], "likes": 32, "viewed": 327, "published": "Public API", "date": "1634176278", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n=============================================\n\nLimit set of rank 4 hyperbolic Coxeter groups\n\n                                by Zhao Liang\n=============================================\n\nThis program shows the limit set of rank 4 hyperbolic Coxeter groups.\n\nSome math stuff:\n\nLet G be a hyperbolic Coxeter group and x a point inside the hyperbolic\nunit ball, the orbit S_x = { gx, g \\in G } has accumulation points\n(under Euclidean metric) only on the boundary of the space. We call the\naccumulation points of S_x the limit set of the group, it can be proved that\nthis set is independent of the way x is chosen, and it's the smallest\nclosed subset of the boundary that is invariant under the action of the group.\n\nThe Coxeter-Dynkin diagram of a rank 4 Coxeter group of string type has the form\n\n   A --- B --- C --- D\n      p     q     r\n\nHere A, B, D can be chosen as ususal Euclidean planes, C is a sphere orthongonal\nto the unit ball. This is taken from mla's notation, and as far as I know this\nhas long been used by users on fractalforums. (fragmentarium)\n\nIn this animation these points are colored in \"brass metal\".\n\n==========\n!important\n==========\n\nThe limit set is a closed set with no interior points, to show them we have\nto use an approximate procedure: we simply try to reflect a point p on the\nboundary to the fundamental domain up to a maximum steps, once failed then we\nthink p belongs to the limit set.\n\n**So the number MAX_REFLECTIONS is an important param**, if' its set to a high\nthreshold then little limit set will be shown, or if it's not high enough then\nthe boundary of the set will look too coarse, so beware of this.\n\nAs always, you can do whatever you want to this work.\n\nUpdate: thanks @mla for helping fix some bugs!\n*/\n// ------------------------------------------\n\n// --------------------------\n// You can try more patterns like\n// (3, 7, 3), (4, 6, 3), (4, 4, 5), (5, 4, 4), (7, 3, 4), ..., etc. (5, 4, 4) is now\n// my favorite! set PQR below to see the result.\n// For large PQRs the limit set will become too small to be visible, you need to adjust\n// MAX_REFLECTIONS and tweak with the function chooseColor to get appealling results.\n\n#define inf        -1.\n\nconst vec3 PQR = vec3(3, 3, 7);\n\n// --------------------------\n// some global settings\n\n#define MAX_TRACE_STEPS  100\n#define MIN_TRACE_DIST   0.1\n#define MAX_TRACE_DIST   100.0\n#define PRECISION        0.0001\n#define AA               3\n#define MAX_REFLECTIONS  500\n#define PI               3.141592653\n\n// another pattern\n//#define CHECKER1  vec3(0.196078, 0.33, 0.82)\n//#define CHECKER2  vec3(0.75, 0.35, 0.196078)\n\n/*\n#define CHECKER1  vec3(0.82, 0.196078, 0.33)\n#define CHECKER2  vec3(0.196078, 0.35, 0.92)\n#define MATERIAL  vec3(0.71, 0.65, 0.26)\n#define FUNDCOL   vec3(0., 0.82, .33)\n*/\n\n// Shane's color scheme\n#define CHECKER1  vec3(0., 0., 0.05)\n#define CHECKER2  vec3(0.2)\n#define MATERIAL  vec3(10, 0.3, 0.2)\n#define FUNDCOL   vec3(.3, 1, 8)\n\n\n// used to highlight the limit set\n#define LighteningFactor 8.\n// --------------------------\n\nvec3 A, B, D;\nvec4 C;\nfloat orb;\n\nfloat dihedral(float x) { return x == inf ? 1. : cos(PI / x); }\n\n// minimal distance to the four mirrors\nfloat distABCD(vec3 p)\n{\n    float dA = abs(dot(p, A));\n    float dB = abs(dot(p, B));\n    float dD = abs(dot(p, D));\n    float dC = abs(length(p - C.xyz) - C.w);\n    return min(dA, min(dB, min(dC, dD)));\n}\n\n// try to reflect across a plane with normal n and update the counter\nbool try_reflect(inout vec3 p, vec3 n, inout int count)\n{\n    float k = dot(p, n);\n    // if we are already inside, do nothing and return true\n    if (k >= 0.0)\n    \treturn true;\n\n    p -= 2.0 * k * n;\n    count += 1;\n    return false;\n}\n\n// similar with above, instead this is a sphere inversion\nbool try_reflect(inout vec3 p, vec4 sphere, inout int count)\n{\n    vec3 cen = sphere.xyz;\n    float r = sphere.w;\n    vec3 q = p - cen;\n    float d2 = dot(q, q);\n    if (d2 == 0.0)\n    \treturn true;\n    float k = (r * r) / d2;\n    if (k < 1.0)\n    \treturn true;\n    p = k * q + cen;\n    count += 1;\n    orb *= k;\n    return false;\n}\n\n// sdf of the unit sphere at origin\nfloat sdSphere(vec3 p, float radius) { return length(p) - 1.0; }\n\n// sdf of the plane y=-1\nfloat sdPlane(vec3 p, float offset) { return p.y + 1.0; }\n\n// inverse stereo-graphic projection, from a point on plane y=-1 to\n// the unit ball centered at the origin\nvec3 planeToSphere(vec2 p)\n{\n    float pp = dot(p, p);\n    return vec3(2.0 * p, pp - 1.0).xzy / (1.0 + pp);\n}\n\n// iteratively reflect a point on the unit sphere into the fundamental cell\n// and update the counter along the way\nbool iterateSpherePoint(inout vec3 p, inout int count)\n{\n    bool inA, inB, inC, inD;\n    for(int iter=0; iter<MAX_REFLECTIONS; iter++)\n    {\n        inA = try_reflect(p, A, count);\n        inB = try_reflect(p, B, count);\n        inC = try_reflect(p, C, count);\n        inD = try_reflect(p, D, count);\n        p =  normalize(p);  // avoid floating error accumulation\n        if (inA && inB && inC && inD)\n            return true;\n    }\n    return false;\n}\n\n// colors for fundamental domain, checker pattern and limit set.\nvec3 chooseColor(bool found, int count)\n{\n    vec3 col;\n    if (found)\n    {\n        if (count == 0) return FUNDCOL;\n        else if (count >= 300) col = MATERIAL;\n        else\n            col = (count % 2 == 0) ? CHECKER1 : CHECKER2;\n\n    }\n    else\n        col = MATERIAL;\n\n    float t =  float(count) / float(MAX_REFLECTIONS);\n    col = mix(MATERIAL*LighteningFactor, col, 1. - t * smoothstep(0., 1., log(orb) / 32.));\n    return col;\n}\n\n// 2d rotation\nvec2 rot2d(vec2 p, float a) { return p * cos(a) + vec2(-p.y, p.x) * sin(a); }\n\nvec2 map(vec3 p)\n{\n    float d1 = sdSphere(p, 1.0);\n    float d2 = sdPlane(p, -1.0);\n    float id = (d1 < d2) ? 0.: 1.;\n    return vec2(min(d1, d2), id);\n}\n\n// standard scene normal\nvec3 getNormal(vec3 p)\n{\n    const vec2 e = vec2(0.001, 0.);\n    return normalize(\n        vec3(\n            map(p + e.xyy).x - map(p  - e.xyy).x,\n            map(p + e.yxy).x - map(p  - e.yxy).x,\n            map(p + e.yyx).x - map(p  - e.yyx).x\n            )\n        );\n}\n\n// get the signed distance to an object and object id\nvec2 raymarch(in vec3 ro, in vec3 rd)\n{\n    float t = MIN_TRACE_DIST;\n    vec2 h;\n    for(int i=0; i<MAX_TRACE_STEPS; i++)\n    {\n        h = map(ro + t * rd);\n        if (h.x < PRECISION * t)\n            return vec2(t, h.y);\n\n        if (t > MAX_TRACE_DIST)\n            break;\n\n        t += h.x;\n    }\n    return vec2(-1.0);\n}\n\nfloat calcOcclusion(vec3 p, vec3 n) {\n    float occ = 0.0;\n    float sca = 1.0;\n    for (int i = 0; i < 5; i++) {\n        float h = 0.01 + 0.15 * float(i) / 4.0;\n        float d = map(p + h * n).x;\n        occ += (h - d) * sca;\n        sca *= 0.75;\n    }\n    return clamp(1.0 - occ, 0.0, 1.0);\n}\n\n\nfloat softShadow(vec3 ro, vec3 rd, float tmin, float tmax, float k) {\n    float res = 1.0;\n    float t = tmin;\n    for (int i = 0; i < 12; i++) {\n        float h = map(ro + rd * t).x;\n        res = min(res, k * h / t);\n        t += clamp(h, 0.01, 0.2);\n        if (h < 0.0001 || t > tmax)\n            break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n\nvec3 getColor(vec3 ro, vec3 rd, vec3 pos, vec3 nor, vec3 lp, vec3 basecol)\n{\n    vec3 col = vec3(0.0);\n    vec3 ld = lp - pos;\n    float lDist = max(length(ld), .001);\n    ld /= lDist;\n    float ao = calcOcclusion(pos, nor);\n    float sh = softShadow(pos+0.001*nor, ld, 0.02, lDist, 32.);\n    float diff = clamp(dot(nor, ld), 0., 1.);\n    float atten = 2. / (1. + lDist * lDist * .01);\n\n    float spec = pow(max( dot( reflect(-ld, nor), -rd ), 0.0 ), 32.);\n    float fres = clamp(1.0 + dot(rd, nor), 0.0, 1.0);\n\n    col += basecol * diff;\n    col += basecol * vec3(1., 0.8, 0.3) * spec * 4.;\n    col += basecol * vec3(0.8) * fres * fres * 2.;\n    col *= ao * atten * sh;\n    col += basecol * clamp(0.8 + 0.2 * nor.y, 0., 1.) * 0.5;\n    return col;\n}\n\nmat3 sphMat(float theta, float phi)\n{\n    float cx = cos(theta);\n    float cy = cos(phi);\n    float sx = sin(theta);\n    float sy = sin(phi);\n    return mat3(cy, -sy * -sx, -sy * cx,\n                0,   cx,  sx,\n                sy,  cy * -sx, cy * cx);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 finalcol = vec3(0.);\n    int count = 0;\n    vec2 m = vec2(0.0, 1.0) + iMouse.xy / iResolution.xy;\n    float rx = m.y * PI;\n    float ry = -m.x * 2. * PI;\n    mat3 mouRot = sphMat(rx, ry);\n\n// ---------------------------------\n// initialize the mirrors\n\n    float P = PQR.x, Q = PQR.y, R = PQR.z;\n    float cp = dihedral(P), sp = sqrt(1. - cp*cp);\n    float cq = dihedral(Q);\n    float cr = dihedral(R);\n    A = vec3(0,  0,   1);\n    B = vec3(0, sp, -cp);\n    D = vec3(1,  0,   0);\n\n    float r = 1.0 / cr;\n    float k = r * cq / sp;\n    vec3 cen = vec3(1, k, 0);\n    C = vec4(cen, r) / sqrt(dot(cen, cen) - r * r);\n\n// -------------------------------------\n// view setttings\n\n    vec3 camera = vec3(3., 3.2, -3.);\n    vec3 lp = vec3(0.5, 3.0, -0.8); //light position\n    camera.xz = rot2d(camera.xz, iTime*0.3);\n    vec3 lookat  = vec3(0., -0.5, 0.);\n    vec3 up = vec3(0., 1., 0.);\n    vec3 forward = normalize(lookat - camera);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n\n// -------------------------------------\n// antialiasing loop\n\n    for(int ii=0; ii<AA; ii++)\n    {\n        for(int jj=0; jj<AA; jj++)\n        {\n            vec2 o = vec2(float(ii), float(jj)) / float(AA);\n            vec2 uv = (2. * fragCoord + o - iResolution.xy) / iResolution.y;\n            vec3 rd = normalize(uv.x * right + uv.y * up + 3.0 * forward);\n            orb = 1.0;\n            // ---------------------------------\n            // hit the scene and get distance, object id\n\n            vec2 res = raymarch(camera, rd);\n            float t = res.x;\n            float id = res.y;\n            vec3 pos = camera + t * rd;\n\n            bool found;\n            float edist;\n            vec3 col;\n            // the sphere is hit\n            if (id == 0.)\n            {\n                vec3 nor = pos;\n                vec3 q = pos * mouRot;\n                found = iterateSpherePoint(q, count);\n                edist = distABCD(q);\n                vec3 basecol = chooseColor(found, count);\n\n                col = getColor(camera, rd, pos, nor, lp, basecol);\n            }\n            // the plane is hit\n            else if (id == 1.)\n            {\n                vec3 nor = vec3(0., 1., 0.);\n                vec3 q = planeToSphere(pos.xz);\n                q = q * mouRot;\n                found = iterateSpherePoint(q, count);\n                edist = distABCD(q);\n                vec3 basecol = chooseColor(found, count);\n                col = getColor(camera, rd, pos, nor, lp, basecol) * .9;\n            }\n            // draw the arcs\n            col = mix(col, vec3(0.), (1.0 - smoothstep(0., 0.005, edist))*0.85);\n            col = mix(col, vec3(0.), 1.0 - exp(-0.01*t*t));\n            finalcol += col;\n        }\n    }\n    finalcol /= (float(AA) * float(AA));\n\n// ------------------------------------\n// a little post-processing\n\n    finalcol = mix(finalcol, 1. - exp(-finalcol), .35);\n    fragColor = vec4(sqrt(max(finalcol, 0.0)), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NstSDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[3016, 3081, 3106, 3106, 3144], [3146, 3186, 3210, 3210, 3392], [3394, 3464, 3521, 3521, 3701], [3703, 3761, 3823, 3823, 4093], [4095, 4131, 4169, 4169, 4195], [4197, 4222, 4259, 4259, 4279], [4281, 4389, 4417, 4417, 4498], [4500, 4616, 4672, 4672, 5071], [5073, 5138, 5179, 5179, 5577], [5579, 5594, 5623, 5623, 5671], [5673, 5673, 5691, 5691, 5828], [5830, 5855, 5879, 5879, 6127], [6129, 6183, 6222, 6222, 6509], [6511, 6511, 6548, 6548, 6806], [6809, 6809, 6878, 6878, 7157], [7160, 7160, 7236, 7236, 7909], [7911, 7911, 7948, 7948, 8166], [8169, 8169, 8224, 8224, 11208]]}
{"id": "NstSW2", "name": "moonsurface", "author": "aliva", "description": "noise", "tags": ["noise"], "likes": 0, "viewed": 151, "published": "Public API", "date": "1633982712", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Modified version from this shader https://www.shadertoy.com/view/7d3XD8\n\n\n#define hash(p)  fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n#define T(c)     texelFetch(c, ivec2(u) % textureSize(c,0).xy, 0).x \n\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, U, P = u/R;\n    u.x -= float(iFrame);\n    U = u / R;\n\n    float h =    P.y > 0.66 ? hash(U)\n               : P.y > 0.33 ? T(iChannel0) \n               :             T(iChannel1);\n    O = vec4 ( iMouse.z > 0.0 ? step(P.x,h)               // raw thresholding\n                             : R.x/64.* ( h - P.x) +0.5   // progressive appear\n             );             // 10.\n             \n    \n    \n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NstSW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 219, 257, 257, 684]]}
{"id": "NstSWf", "name": "Common Color Effects", "author": "chenglou", "description": "15 common color effects. See code for the effects names.\n\n[b]Click & drag horizontally[/b] to manually adjust the percentage value used for some effect, from 0 to 1.\n\nMore info: [url]http://redqueengraphics.com/category/color-adjustments[/url]", "tags": ["color", "contrast", "saturation", "blend", "gamma", "brightness", "inversion", "exposure", "vibrance", "luminence"], "likes": 9, "viewed": 243, "published": "Public API", "date": "1634106335", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Divide the canvas into grids\n    vec2 gridCount = vec2(5., 3.);\n    vec2 uv = fragCoord / iResolution.xy * gridCount; // x: [0, 5[ and y: [0, 3[\n    vec2 gridID = floor(uv); // same as uv but integers\n    // Map the 2D grid ID from (0, 0) -> 1 to (4, 2) -> 15\n    int mappedID = int((gridCount.y - gridID.y - 1.) * gridCount.x + gridID.x) + 1;\n    \n    // Base and overlay texture for blending. Sometime we only use base (t1)\n    vec4 t1 = texture(iChannel0, uv);\n    vec4 t2 = texture(iChannel1, uv);\n    // Shadertoy's (non-noise) textures are in sRGB. Turn them into linear space for manipulation. Turn them back at the end\n    t1 = pow(t1, vec4(2.2));\n    t2 = pow(t2, vec4(2.2));\n    \n    // Used by certain effects. from 0 to 1\n    float percentSlider = sin(iTime) / 2. + .5;\n    // Click & drag horizontally to manually adjust the percentage\n    if (iMouse.z > 0.) percentSlider = iMouse.x / iResolution.x;\n    \n    // === Ok, start!\n    vec4 color;\n    switch (mappedID) {\n        case 1: // blend: dissolve\n            color = mix(t1, t2, percentSlider);\n            break;\n        case 2: // blend: lighten\n            color = max(t1, t2);\n            break;\n        case 3: // blend: darken\n            color = min(t1, t2);\n            break;\n        case 4: // blend: subtract\n            color = t1 - t2;\n            break;\n        case 5: // blend: multiply. Would require more calculations for non-1 alpha\n            color = t2 * t1;\n            break;\n        case 6: // blend: add. Would require more calculations for non-1 alpha\n            color = t1 + t2;\n            break;\n        case 7: // blend: divide. Would require more calculations for non-1 alpha\n            color = t1 / t2;\n            break;\n        case 8: // luminence\n            vec3 weights = vec3(0.2125, 0.7154, 0.0721); // sums to 1\n            float luminance = dot(t1.rgb, weights);\n            color = vec4(vec3(luminance), 1.);\n            break;\n        case 9: // brightness\n            color = t1 + percentSlider;\n            break;\n        case 10: // contrast\n            color = (t1 - .5) * percentSlider * 2. + .5; // 0 to 2 contrast\n            break;\n        case 11: // exposure\n            color = t1 * pow(2., percentSlider);\n            break;\n        case 12: // gamma\n            color = pow(t1, vec4(percentSlider) * 2.2); // 0 to 2.2, by convention\n            break;\n        case 13: // saturation\n            vec3 weights_ = vec3(0.2125, 0.7154, 0.0721); // sums to 1\n            float luminance_ = dot(t1.rgb, weights_);\n            color = mix(vec4(luminance_), t1, vec4(percentSlider) * 5.);\n            break;\n        case 14: // vibrance\n            float average = (t1.r + t1.g + t1.b) / 3.;\n            float mx = max(t1.r, max(t1.g, t1.b));\n            float amount = (mx - average) * percentSlider * 3. * 5.;\n            color = t1 - (mx - t1) * amount;\n            break;\n        case 15: // inversion\n            color = 1. - t1;\n            break;\n    }\n\n    fragColor = pow(color, vec4(1./2.2)); // gamma correct back\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}, {"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NstSWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 93, 3112]]}
{"id": "NstSWs", "name": "Foggy Mandelbulb", "author": "ThomasVallentin", "description": "Small test to experiment with ray marching", "tags": ["raymarching", "fractal", "color", "fog"], "likes": 2, "viewed": 108, "published": "Public API", "date": "1634167785", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\n#define MAX_STEPS 100\n#define HIT_DISTANCE 0.0001\n#define MAX_DIST 100.\n\n\nfloat distToMandelbub(vec3 pos, int iterations, float bailout, float power) {\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r;\n    \n\tfor (int i = 0; i < iterations ; i++) {\n\t\tr = length(z);\n\t\tif (r > bailout) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r) * power;\n\t\tfloat phi = atan(z.y,z.x) * power;\n\t\tdr =  pow( r, power - 1.0) * power * dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow(r, power);\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));\n\t\tz += pos;\n\t}\n\treturn 0.5 * log(r) * r / dr;\n}\n\n\nfloat signedDistToPlane(vec3 origin) {\n    return origin.y;\n}\n\n\nfloat signedDistToSphere(vec4 sphere, vec3 origin) {\n    return length(sphere.xyz - origin) - sphere.w;\n}\n\n\nvec2 smoothMin(float dstA, float dstB, float k, float power) {\n    float h = max(k - abs(dstA - dstB), 0.0) /k;\n    float m = pow(h, power) * 0.5;\n    float s = m * k / power;\n    \n    return (dstA < dstB) ? vec2(dstA - s, m) : vec2(dstB - s, 1.0 - m);\n}\n\n\nvec4 marchOnce(vec3 pos) {\n\n    vec3 mdbColor = vec3(1., 0, .15);\n    vec3 sphColor = vec3(0, 0.1, 1);\n\n    float mdbDist = distToMandelbub(pos, 15, 2.0, (cos(iTime  / 25. - PI) * 0.5 + 0.5) * 15. + 1.);\n    float sphDist = signedDistToSphere(vec4(0, 0, sin(iTime / 3.5) * 2., 0.2), pos);\n    \n    vec2 smin = smoothMin(mdbDist, sphDist, 0.3, 3.);\n\n    return vec4(mix(mdbColor, sphColor, smin.y), smin.x);\n}\n\n\nvec4 rayMarch(vec3 origin, vec3 direction) {\n    vec4 result = vec4(0);\n    for (int i=0 ; i < MAX_STEPS ; i++ ) {\n        vec3 p = origin + direction * result.w;\n        vec4 tempResult = marchOnce(p);\n    \n        result.w += tempResult.w;\n        result.xyz = tempResult.xyz;\n        if (result.w > MAX_DIST)\n            return vec4(0, 0, 0, 100000);\n            \n        if (tempResult.w < HIT_DISTANCE)\n            break;\n    }\n    \n    return result;\n}\n\n\nvec3 applyFog(vec3 rgb, float dist) {\n    vec3 fogColor = vec3(0.05, 0.1, 0.2);\n    float fogDensity = 1.;\n    float fogStartDist = 1.2;\n    \n    dist = dist - fogStartDist;\n\n    float fogAmount = 1.0 - exp( -dist * fogDensity);\n    return mix(rgb, fogColor, fogAmount);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5*iResolution.xy) / iResolution.y;\n    float time = iTime / 5.0; \n    float rotationRadius = 2.5;\n    \n\n    vec3 origin = vec3(sin(time) * rotationRadius, 0, -cos(time) * rotationRadius);\n    vec3 direction = normalize(vec3(uv.x, uv.y, 1));\n    mat3 spin = mat3(cos(time), 0,  sin(time),\n                    0, 1, 0,\n                    -sin(time), 0, cos(time));\n    direction = spin * direction;\n    \n    vec4 result = rayMarch(origin, direction);\n    \n    vec3 col = vec3(result.xyz);\n    col = applyFog(col, result.w);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NstSWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[96, 96, 173, 173, 696], [699, 699, 737, 737, 760], [763, 763, 815, 815, 868], [871, 871, 933, 933, 1125], [1128, 1128, 1154, 1154, 1536], [1539, 1539, 1583, 1583, 1997], [2000, 2000, 2037, 2037, 2272], [2275, 2275, 2332, 2332, 2922]]}
{"id": "NstSzf", "name": "acid chaos", "author": "h3xb0y", "description": "colors chaos", "tags": ["fractal", "oil", "acid", "psy"], "likes": 3, "viewed": 106, "published": "Public", "date": "1633637993", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float timeRatio = .3;\n    float timeFlow = iTime * timeRatio;\n    float acidRatio = 5.;\n    \n    vec3 position = vec3(timeFlow, timeFlow, timeFlow);\n    vec3 color = vec3(acidRatio, acidRatio, acidRatio);\n    \n    for (int i = 0; i < 25; i++) \n    {\n        position += vec3(-sin(uv), sin(uv) - cos(uv));\n        \n    \tcolor += vec3(\n            -sin(color.g + sin(position.y)), \n            -sin(color.b + sin(position.z)), \n            -sin(color.r + sin(position.x)) \n        );\n    }\n    \n    color *= color * .005;\n    \n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NstSzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 663]]}
{"id": "NstXRX", "name": "Reef and waves", "author": "guil", "description": "Cheap reef and waves effect", "tags": ["waves", "reef"], "likes": 11, "viewed": 255, "published": "Public API", "date": "1633687146", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by S. Guillitte 2021\n \n\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\n\n//reef/waves combined field\nvec3 field(in vec3 p) {\n\t\n\tfloat s=2.,e,f,o=1.;\n    vec3 q=p;\n\tvec2 l = vec2(2.);\n\tfor(e=f=p.y;s<4e2;s*=1.6)\n            p.xz*=rot(s),\n            q=p,\n            q.x+=iTime,\n            e+=abs(dot(sin(q.xz*s*.1)/s,.8*l)),\n            f+=.2+.5*(dot(sin(p.xz*s*.5)/s,l));\n\to+=(f>.001 ? (e<0.01 ? -exp(-e*e):f*e):-exp(-f*f));\n    return vec3(max(o,0.),e,f);\n}\n\n\nvec3 raycast( in vec3 ro, vec3 rd )\n{\n    float t = 3.5, dt = .15,c,d,e,f;\n    vec3 col= vec3(0.);\n    for( int i=0; i<100; i++ )\n\t{        \n        vec3 v = field(ro+t*rd); \n        c=v.x; e=v.y; f=v.z; d=min(min(e,2.*e*f),f);\n        t+=dt*d;\n        dt *= 1.015;\n        e=exp(-e);f=exp(-f);\n        col = .95*col+ .5*c*(f*vec3(.5,.3, .2)+e*vec3(.1, .4, .7));        \n    }    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t = iTime;\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    \n    // camera\n\n    vec3 ro = vec3(2.);\n   \n    ro.yz*=rot(-1.5);\n    \n    ro.y +=3.;\n    ro.xz*=rot(0.1*t);\n    \n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\n    ro.x -= t*.4;\n    rd.xy*=rot(sin(t)*.1);\n    rd.xz*=rot(sin(t*1.3)*.1);\n\t// raymarch \n    \n    vec3 col = raycast(ro,rd);\n    \t\n\t// shade\n    \n    col =  .5 *(log(1.+col));\n    col = clamp(col,0.,1.);\n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NstXRX.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 122, 141, 141, 188], [191, 219, 242, 242, 577], [580, 580, 617, 617, 978], [981, 981, 1038, 1038, 1752]]}
{"id": "NsVSRw", "name": "Animated Phyllotaxis 2D ", "author": "mvaios", "description": "First attempt to visualize an animated phyllotaxis arrangement using shader.", "tags": ["colors", "animated", "phyllotaxis"], "likes": 3, "viewed": 160, "published": "Public API", "date": "1634415697", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// First attempt to visualize a phyllotaxis arrangement using shader.\n// I am a beginner with the shaders, so the code might not be very optimal.\n\n// A tshirt and probably a mug with this design will be available in my store soon. \n// Feel free to check it out here:\n// https://threadhub.store/products/phyllotaxis-t-shirt\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    uv.x = uv.x * ratio + (iResolution.y - iResolution.x)/iResolution.y / 2.;\n    float time = iTime + 1.;\n    float c = 0.025;\n    vec2 center = vec2(0.5, 0.5);\n    vec2 _uv = uv - center;\n    float minDiff = 1.;\n    float index = 0.;\n    for(float i = 0.; i < 400.; i++) {\n        float angle = 137.5 * (i + (i / 2300.) * iTime / 20.);\n        float radius = c * sqrt(i);\n        float x = radius * cos(angle);\n        float y = radius * sin(angle);\n        \n        vec2 pos = vec2(x, y);\n        float diff = abs(distance(pos, _uv)) * 60.;\n        \n        if(diff < minDiff) {\n            minDiff = diff;\n            index = i + 1.;\n        }\n    }\n    \n    minDiff = smoothstep(0., .5, minDiff);\n    minDiff = minDiff * minDiff;\n    minDiff = 1. - minDiff;\n    float changeRate = .05;\n    float r = minDiff * (sin((time * 1. * index) * changeRate) + 1.);\n    float g = minDiff * (sin((time * 2. * index) * changeRate) + 1.);\n    float b = minDiff * (sin((time * 3. * index) * changeRate) + 1.);\n\n    fragColor = vec4(r, g, b, 1);\n    return;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsVSRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[147, 324, 381, 381, 1520]]}
{"id": "NsVSWW", "name": "its also burning", "author": "Arrangemonk", "description": "tried to make waves for an ocean shader, ended up making a very inefficient noise function, then i added domain transformation and now ", "tags": ["wavesnoise"], "likes": 4, "viewed": 182, "published": "Public API", "date": "1634651983", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Arrangemonk 2021, innefficient noise function\n//in the unlikely event of someone forking this: yeah, do that\n\nfloat PI  = 3.14159265359;\nfloat TAU = 6.28318530718;\nfloat E = 2.71828182846;\nfloat iters = 4.;\nfloat octaves = 8.;\n\nfloat wave(float x,float time)\n{\n   return sin(x * PI - time) *.5 + .5;\n}\n\nvec2 rot(vec2 uv, float phi)\n{\n    return vec2(sin(phi)*uv.x + cos(phi)*uv.y,cos(phi)*uv.x - sin(phi)*uv.y);\n}\n\nfloat rotfbm(vec3 pos)\n{\nfloat result = 0.;\nfloat m = 0.;\nfor(float i = 1.; i < octaves;i++)\n    {\n    float tmp = 1./i;\n    m += tmp;\n    result += wave(rot(pos.xy*i,PI * E * i).x * iters,pos.z)* tmp;\n    }\nreturn result /m;\n}\n\nvec3 NormalMap(in vec2 uv)\n{ \n    float time = iTime * 0.2;\n    float p  = rotfbm(vec3(uv,time));\n    float h1 = rotfbm(vec3(uv + vec2(.1,0),time));\n    float v1 = rotfbm(vec3(uv + vec2(0,.1),time));      \n   \tvec2 normal = 0.5 + (p - vec2(h1, v1));\n    return normalize(vec3(normal, 1.));\n}\n\nfloat curvature(in vec2 uv)\n{\n    vec3 p  = NormalMap(uv);\n    vec3 h1 = NormalMap(uv + vec2(.001,0));\n    vec3 v1 = NormalMap(uv + vec2(0,.001));      \n\n    return (h1.x -p.x + v1.y -p.y - p.z)*.5;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x * 4.;\n\n    float val = rotfbm(vec3(uv,iTime));\n    vec2 pos = .25 * (uv + NormalMap(.5 *(uv + NormalMap(1. *(uv + NormalMap(uv + vec2(0,-iTime * 0.1)).xy)).yz)).zx);\n    vec3 col = NormalMap(pos);\n    float occ = curvature(pos);\n\n    fragColor = texture(iChannel0,uv + col.xy * col.z);\n    \n    fragColor = fragColor * fragColor * 4.;\n    \n    float amount = uv.y + col.y * col.z;\n    //amount = sqrt(amount);\n    \n    fragColor = mix(vec4(4,1.5,0,1),vec4(0,0,0.2,1),amount)+occ*.1;\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsVSWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 230, 262, 262, 303], [305, 305, 335, 335, 415], [417, 417, 441, 441, 644], [646, 646, 674, 674, 937], [939, 939, 968, 968, 1139], [1142, 1142, 1199, 1199, 1723]]}
{"id": "NsVSWy", "name": "Gaussian Filtered Rectangle", "author": "oneshade", "description": "Gaussian blurred rectangle.", "tags": ["blur", "filter", "rectangle", "gaussian"], "likes": 13, "viewed": 77, "published": "Public", "date": "1635224506", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// https://www.desmos.com/calculator/rnlcawwmf8\n\n// Error function approximation\nfloat erf(in float x) {\n    return sign(x) * sqrt(1.0 - exp2(-1.787776 * x * x));\n}\n\n// Gaussian filtered rectangle\nfloat grect(in vec2 p, in vec2 b, in float w) {\n    float u = erf((p.x + b.x) / w) - erf((p.x - b.x) / w);\n    float v = erf((p.y + b.y) / w) - erf((p.y - b.y) / w);\n    return u * v / 4.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    float w = mix(0.25, 0.5, 0.5 - 0.5 * cos(0.5 * iTime));\n    float h = mix(0.25, 0.4, 0.5 - 0.5 * sin(iTime));\n    float s = mix(0.001, 0.125, 0.5 - 0.5 * cos(iTime));\n\n    fragColor = vec4(grect(uv, vec2(w, h), s));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsVSWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 81, 104, 104, 164], [166, 197, 244, 244, 388], [390, 390, 445, 445, 734]]}
{"id": "NsVSzR", "name": "Planet - Jupiter", "author": "Zi7ar21", "description": "Trying to create a simple but faithful recreation of the beloved planet Jupiter.", "tags": ["procedural", "planet", "gasgiant", "gas", "jupiter", "giant"], "likes": 9, "viewed": 220, "published": "Public API", "date": "1634357982", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ####### Planet - Jupiter #######\n// Made by Jacob Bingham (Zi7ar21) on October 16th, 2021\n\n// Last Updated on October 18th, 2021 at 12:00 Mountain Standard Time\n\n// If you found this anywhere except Shadertoy, the original and possibly updated version can be found at:\n// https://www.shadertoy.com/view/NsVSzR\n\n// \"License\":\n// You can use this code in any way you want, as long as you keep credits to things that aren't mine\n// e.g. Triple32: https://nullprogram.com/blog/2018/07/31/\n// We are programmers, not lawyers! :)\n\n/*\nThis is my attempt at creating a simple but faithful recreation of the beloved planet Jupiter.\n*/\n\n// Check out my friends!\n// michael0884\n// https://www.shadertoy.com/user/michael0884\n// loicvdb\n// https://www.shadertoy.com/user/loicvdb\n// Dumb_Psycho\n// https://www.shadertoy.com/user/Dumb_Psycho\n// peabrainiac\n// https://www.shadertoy.com/user/peabrainiac\n\n// ##### Constants #####\n\nconst float pi = 3.141592653589793;\n\n// ##### Parameters #####\n\n#define fov 0.5\n\n#define exposure 1.0\n\n// ##### Hashes #####\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p *= 0.1031;\n    p  = fract(p);\n    p *= p+33.33;\n    p *= p+p;\n    return fract(p);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n    p3 *= 0.1031;\n    p3  = fract(p3);\n    p3 += dot(p3, p3.zyx+31.32);\n    return fract( (p3.x+p3.y)*p3.z );\n}\n\n// https://www.shadertoy.com/view/4djSRW\nvec4 hash44(vec4 p4)\n{\n    p4 *= vec4(0.1031, 0.1030, 0.0973, 0.1099);\n    p4  = fract(p4);\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract( (p4.xxyz+p4.yzzw)*p4.zywx );\n}\n\n// ##### Additional Functions #####\n\nfloat dotp(vec2 vector) { return dot(vector, vector); }\nfloat dotp(vec3 vector) { return dot(vector, vector); }\nfloat dotp(vec4 vector) { return dot(vector, vector); }\n\nvec2 rotate(vec2 vector, float rotation)\n{\n    float s = sin(rotation), c = cos(rotation);\n    return vec2(vector.x*c-vector.y*s, vector.x*s+vector.y*c);\n}\n\n// https://www.shadertoy.com/view/ll2GD3\nvec3 pal(float t, vec3 a, vec3 b, vec3 c, vec3 d)\n{\n    return a+b*cos( 2.0*pi*(c*t+d) );\n}\n\n// https://www.schemecolor.com/jupiter-planet-colors.php\nvec3 jupiter_palette(float t)\n{\n    const vec3 c0 = vec3( 64,  68,  54)/256.0; // #404436\n    const vec3 c1 = vec3(167, 156, 134)/256.0; // #A79C86\n    const vec3 c2 = vec3(210, 207, 218)/256.0; // #D2CFDA\n    const vec3 c3 = vec3(211, 156, 126)/256.0; // #D39C7E\n    const vec3 c4 = vec3(144,  97,  77)/256.0; // #90614D\n    const vec3 c5 = vec3(200, 139,  58)/256.0; // #C88B3A\n\n    vec3 interpolated_color =\n    t > 0.0/5.0 && t < 1.0/5.0 ? mix( c0, c1, smoothstep( 0.0, 1.0, fract(t/5.0) ) ) :\n    t > 1.0/5.0 && t < 2.0/5.0 ? mix( c1, c2, smoothstep( 0.0, 1.0, fract(t/5.0) ) ) :\n    t > 2.0/5.0 && t < 3.0/5.0 ? mix( c2, c3, smoothstep( 0.0, 1.0, fract(t/5.0) ) ) :\n    t > 3.0/5.0 && t < 4.0/5.0 ? mix( c3, c4, smoothstep( 0.0, 1.0, fract(t/5.0) ) ) :\n    t > 4.0/5.0 && t < 5.0/5.0 ? mix( c4, c5, smoothstep( 0.0, 1.0, fract(t/5.0) ) ) :\n    vec3(0.0);\n\n    return interpolated_color;\n}\n\n// ##### Noise #####\n\nfloat noise(float p)\n{\n    float i = floor(p);\n    float f = fract(p);\n\n    float u = smoothstep(0.0, 1.0, f);\n\n    float h0 = hash11(i+0.0);\n    float h1 = hash11(i+1.0);\n\n    return mix(h0, h1, u);\n}\n\nfloat noise(vec3 p, int octave)\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\n    vec3 u = smoothstep(0.0, 1.0, f);\n\n    vec2 h0 = hash44( vec4(i.x+0.0, i.y+0.0, i.z+0.0, octave) ).xy;\n    vec2 h1 = hash44( vec4(i.x+1.0, i.y+0.0, i.z+0.0, octave) ).xy;\n    vec2 h2 = hash44( vec4(i.x+0.0, i.y+1.0, i.z+0.0, octave) ).xy;\n    vec2 h3 = hash44( vec4(i.x+1.0, i.y+1.0, i.z+0.0, octave) ).xy;\n    vec2 h4 = hash44( vec4(i.x+0.0, i.y+0.0, i.z+1.0, octave) ).xy;\n    vec2 h5 = hash44( vec4(i.x+1.0, i.y+0.0, i.z+1.0, octave) ).xy;\n    vec2 h6 = hash44( vec4(i.x+0.0, i.y+1.0, i.z+1.0, octave) ).xy;\n    vec2 h7 = hash44( vec4(i.x+1.0, i.y+1.0, i.z+1.0, octave) ).xy;\n\n    /* // Not Spherically Uniform\n    vec3 v0 = hash44( vec4(i.x+0.0, i.y+0.0, i.z+0.0, octave) ).xyz;\n    vec3 v1 = hash44( vec4(i.x+1.0, i.y+0.0, i.z+0.0, octave) ).xyz;\n    vec3 v2 = hash44( vec4(i.x+0.0, i.y+1.0, i.z+0.0, octave) ).xyz;\n    vec3 v3 = hash44( vec4(i.x+1.0, i.y+1.0, i.z+0.0, octave) ).xyz;\n    vec3 v4 = hash44( vec4(i.x+0.0, i.y+0.0, i.z+1.0, octave) ).xyz;\n    vec3 v5 = hash44( vec4(i.x+1.0, i.y+0.0, i.z+1.0, octave) ).xyz;\n    vec3 v6 = hash44( vec4(i.x+0.0, i.y+1.0, i.z+1.0, octave) ).xyz;\n    vec3 v7 = hash44( vec4(i.x+1.0, i.y+1.0, i.z+1.0, octave) ).xyz;\n    */\n\n    vec2 r0 = vec2( 2.0*pi*h0.x, acos(2.0*h0.y-1.0) );\n    vec2 r1 = vec2( 2.0*pi*h1.x, acos(2.0*h1.y-1.0) );\n    vec2 r2 = vec2( 2.0*pi*h2.x, acos(2.0*h2.y-1.0) );\n    vec2 r3 = vec2( 2.0*pi*h3.x, acos(2.0*h3.y-1.0) );\n    vec2 r4 = vec2( 2.0*pi*h4.x, acos(2.0*h4.y-1.0) );\n    vec2 r5 = vec2( 2.0*pi*h5.x, acos(2.0*h5.y-1.0) );\n    vec2 r6 = vec2( 2.0*pi*h6.x, acos(2.0*h6.y-1.0) );\n    vec2 r7 = vec2( 2.0*pi*h7.x, acos(2.0*h7.y-1.0) );\n\n    vec2 s0 = sin(r0), c0 = cos(r0);\n    vec2 s1 = sin(r1), c1 = cos(r1);\n    vec2 s2 = sin(r2), c2 = cos(r2);\n    vec2 s3 = sin(r3), c3 = cos(r3);\n    vec2 s4 = sin(r4), c4 = cos(r4);\n    vec2 s5 = sin(r5), c5 = cos(r5);\n    vec2 s6 = sin(r6), c6 = cos(r6);\n    vec2 s7 = sin(r7), c7 = cos(r7);\n\n    vec3 v0 = vec3(c0.x*s0.y, s0.x*s0.y, c0.y);\n    vec3 v1 = vec3(c1.x*s1.y, s1.x*s1.y, c1.y);\n    vec3 v2 = vec3(c2.x*s2.y, s2.x*s2.y, c2.y);\n    vec3 v3 = vec3(c3.x*s3.y, s3.x*s3.y, c3.y);\n    vec3 v4 = vec3(c4.x*s4.y, s4.x*s4.y, c4.y);\n    vec3 v5 = vec3(c5.x*s5.y, s5.x*s5.y, c5.y);\n    vec3 v6 = vec3(c6.x*s6.y, s6.x*s6.y, c6.y);\n    vec3 v7 = vec3(c7.x*s7.y, s7.x*s7.y, c7.y);\n\n    float t0 = dot( v0, f-vec3(0.0, 0.0, 0.0) );\n    float t1 = dot( v1, f-vec3(1.0, 0.0, 0.0) );\n    float t2 = dot( v2, f-vec3(0.0, 1.0, 0.0) );\n    float t3 = dot( v3, f-vec3(1.0, 1.0, 0.0) );\n    float t4 = dot( v4, f-vec3(0.0, 0.0, 1.0) );\n    float t5 = dot( v5, f-vec3(1.0, 0.0, 1.0) );\n    float t6 = dot( v6, f-vec3(0.0, 1.0, 1.0) );\n    float t7 = dot( v7, f-vec3(1.0, 1.0, 1.0) );\n\n    return 0.5*(mix(mix(mix(t0, t1, u.x), mix(t2, t3, u.x), u.y), mix(mix(t4, t5, u.x), mix(t6, t7, u.x), u.y), u.z)+1.0);\n}\n\nvec3 distortion_noise(vec3 p, float t)\n{\n    const int octave = -1;\n\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\n    vec3 u = smoothstep(0.0, 1.0, f);\n\n    vec2 h0 = hash44( vec4(i.x+0.0, i.y+0.0, i.z+0.0, octave) ).xy;\n    vec2 h1 = hash44( vec4(i.x+1.0, i.y+0.0, i.z+0.0, octave) ).xy;\n    vec2 h2 = hash44( vec4(i.x+0.0, i.y+1.0, i.z+0.0, octave) ).xy;\n    vec2 h3 = hash44( vec4(i.x+1.0, i.y+1.0, i.z+0.0, octave) ).xy;\n    vec2 h4 = hash44( vec4(i.x+0.0, i.y+0.0, i.z+1.0, octave) ).xy;\n    vec2 h5 = hash44( vec4(i.x+1.0, i.y+0.0, i.z+1.0, octave) ).xy;\n    vec2 h6 = hash44( vec4(i.x+0.0, i.y+1.0, i.z+1.0, octave) ).xy;\n    vec2 h7 = hash44( vec4(i.x+1.0, i.y+1.0, i.z+1.0, octave) ).xy;\n\n    /* // Not Spherically Uniform\n    vec3 v0 = hash44( vec4(i.x+0.0, i.y+0.0, i.z+0.0, octave) ).xyz;\n    vec3 v1 = hash44( vec4(i.x+1.0, i.y+0.0, i.z+0.0, octave) ).xyz;\n    vec3 v2 = hash44( vec4(i.x+0.0, i.y+1.0, i.z+0.0, octave) ).xyz;\n    vec3 v3 = hash44( vec4(i.x+1.0, i.y+1.0, i.z+0.0, octave) ).xyz;\n    vec3 v4 = hash44( vec4(i.x+0.0, i.y+0.0, i.z+1.0, octave) ).xyz;\n    vec3 v5 = hash44( vec4(i.x+1.0, i.y+0.0, i.z+1.0, octave) ).xyz;\n    vec3 v6 = hash44( vec4(i.x+0.0, i.y+1.0, i.z+1.0, octave) ).xyz;\n    vec3 v7 = hash44( vec4(i.x+1.0, i.y+1.0, i.z+1.0, octave) ).xyz;\n    */\n\n    vec2 r0 = vec2( 2.0*pi*h0.x, acos(2.0*h0.y-1.0) );\n    vec2 r1 = vec2( 2.0*pi*h1.x, acos(2.0*h1.y-1.0) );\n    vec2 r2 = vec2( 2.0*pi*h2.x, acos(2.0*h2.y-1.0) );\n    vec2 r3 = vec2( 2.0*pi*h3.x, acos(2.0*h3.y-1.0) );\n    vec2 r4 = vec2( 2.0*pi*h4.x, acos(2.0*h4.y-1.0) );\n    vec2 r5 = vec2( 2.0*pi*h5.x, acos(2.0*h5.y-1.0) );\n    vec2 r6 = vec2( 2.0*pi*h6.x, acos(2.0*h6.y-1.0) );\n    vec2 r7 = vec2( 2.0*pi*h7.x, acos(2.0*h7.y-1.0) );\n\n    vec2 s0 = sin(r0), c0 = cos(r0);\n    vec2 s1 = sin(r1), c1 = cos(r1);\n    vec2 s2 = sin(r2), c2 = cos(r2);\n    vec2 s3 = sin(r3), c3 = cos(r3);\n    vec2 s4 = sin(r4), c4 = cos(r4);\n    vec2 s5 = sin(r5), c5 = cos(r5);\n    vec2 s6 = sin(r6), c6 = cos(r6);\n    vec2 s7 = sin(r7), c7 = cos(r7);\n\n    vec3 v0 = vec3(c0.x*s0.y, s0.x*s0.y, c0.y);\n    vec3 v1 = vec3(c1.x*s1.y, s1.x*s1.y, c1.y);\n    vec3 v2 = vec3(c2.x*s2.y, s2.x*s2.y, c2.y);\n    vec3 v3 = vec3(c3.x*s3.y, s3.x*s3.y, c3.y);\n    vec3 v4 = vec3(c4.x*s4.y, s4.x*s4.y, c4.y);\n    vec3 v5 = vec3(c5.x*s5.y, s5.x*s5.y, c5.y);\n    vec3 v6 = vec3(c6.x*s6.y, s6.x*s6.y, c6.y);\n    vec3 v7 = vec3(c7.x*s7.y, s7.x*s7.y, c7.y);\n\n    /*\n    v0 = vec3(rotate(v0.xz, t), v0.y).xzy;\n    v1 = vec3(rotate(v1.xz, t), v1.y).xzy;\n    v2 = vec3(rotate(v2.xz, t), v2.y).xzy;\n    v3 = vec3(rotate(v3.xz, t), v3.y).xzy;\n    v4 = vec3(rotate(v4.xz, t), v4.y).xzy;\n    v5 = vec3(rotate(v5.xz, t), v5.y).xzy;\n    v6 = vec3(rotate(v6.xz, t), v6.y).xzy;\n    v7 = vec3(rotate(v7.xz, t), v7.y).xzy;\n    */\n\n    v0 = vec3(rotate(v0.xy, t), v0.z);\n    v1 = vec3(rotate(v1.xy, t), v1.z);\n    v2 = vec3(rotate(v2.xy, t), v2.z);\n    v3 = vec3(rotate(v3.xy, t), v3.z);\n    v4 = vec3(rotate(v4.xy, t), v4.z);\n    v5 = vec3(rotate(v5.xy, t), v5.z);\n    v6 = vec3(rotate(v6.xy, t), v6.z);\n    v7 = vec3(rotate(v7.xy, t), v7.z);\n\n    return mix(mix(mix(v0, v1, u.x), mix(v2, v3, u.x), u.y), mix(mix(v4, v5, u.x), mix(v6, v7, u.x), u.y), u.z);\n}\n\nfloat fbm(vec3 p)\n{\n    float value = 0.0;\n    float accum = 0.0;\n    float atten = 0.5;\n    float scale = 1.0;\n\n    for(int i = 0; i < 8; i++)\n    {\n        value += atten*noise(scale*p, i);\n        accum += atten;\n        atten *= 0.5;\n        scale *= 2.0;\n    }\n\n    return value/accum;\n}\n\n// ##### Rendering #####\n\nstruct rayData {\n    float tMin;\n    float tMax;\n    bool hit;\n    bool expire;\n    vec3 normal;\n};\n\nrayData traceSphere(vec3 ro, vec3 rd, vec3 sphPos, float sphRad)\n{\n    rayData raycastOut;\n\n    raycastOut.tMin = -1.0;\n    raycastOut.tMax = -1.0;\n    raycastOut.hit = false;\n    raycastOut.expire = false;\n    raycastOut.normal = vec3(0.0);\n\n    vec3 oc = ro-sphPos;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc)-sphRad*sphRad;\n    float h = b*b-c;\n\n    if(h < 0.0)\n    {\n        return raycastOut;\n    }\n\n    h = sqrt(h);\n\n    raycastOut.tMin = -b-h;\n    raycastOut.tMax = -b+h;\n    raycastOut.hit = true;\n    raycastOut.normal = normalize(ro+rd*raycastOut.tMin);\n\n    return raycastOut;\n}\n\nrayData process_hit(rayData raycast0, rayData raycast1)\n{\n    if(raycast0.hit)\n    {\n        if(raycast1.hit)\n        {\n            rayData raycastOut;\n\n            raycastOut.tMin = min(raycast0.tMin, raycast1.tMin);\n            raycastOut.tMax = max(raycast0.tMax, raycast1.tMax);\n\n            raycastOut.hit  = true;\n\n            raycastOut.expire  = false;\n\n            raycastOut.normal  = raycast0.tMin < raycast1.tMin ? raycast0.normal : raycast1.normal;\n\n            return raycastOut;\n        }\n\n        return raycast0;\n    }\n\n    return raycast1;\n}\n\nrayData trace(vec3 ro, vec3 rd)\n{\n    return traceSphere(ro, rd, vec3(0.0), 0.5);\n}\n\nvec3 skyColor(vec3 rd)\n{\n    return vec3(0.000, 0.000, 0.000);\n}\n\nfloat shade_point(vec3 ro, vec3 rd, vec3 normal, vec3 hitPos, vec3 lightPos)\n{\n    vec3 lightDir = lightPos-hitPos;\n    float lightIntensity = ( 1.0/max(dot(lightDir, lightDir), 0.001) );\n    lightDir = normalize(lightDir);\n\n    return max(dot(normal, lightDir), 0.0)*lightIntensity;\n}\n\nfloat shade_sun(vec3 ro, vec3 rd, vec3 normal, vec3 lightDir)\n{\n    return max(dot(normal, lightDir), 0.0);\n}\n\nvec3 radiance(vec3 ro, vec3 rd)\n{\n    rayData t = trace(ro, rd);\n\n    if(!t.hit)\n    {\n        return skyColor(rd);\n    }\n\n    vec3 hitPos = ro+rd*t.tMin;\n    vec3 normal = t.normal;\n\n    //vec3 lightPos = vec3( 2.0*sin(0.25*pi*iTime), 2.0, 2.0*cos(0.25*pi*iTime) );\n    vec3 lightPos = vec3(10.0, 0.0, 10.0);\n\n    //float lambert = 500.0*shade_point( ro, rd, normal, hitPos, lightPos);\n    float lambert = 3.0*shade_sun( ro, rd, normal, normalize(lightPos) );\n\n    vec3 surfacePos = normalize(hitPos);\n\n    float noise0 = fbm( 10.0*(vec3(rotate(surfacePos.xz, -0.005*2.0*pi*iTime), surfacePos.y).xzy) )-0.5;\n    float noise1 = fbm(  8.0*(vec3(rotate(surfacePos.xz,  0.001*2.0*pi*iTime), surfacePos.y).xzy)+(surfacePos.y*4.0*noise0) );\n    //float noise1 = fbm(  8.0*(vec3(rotate(surfacePos.xz,  0.001*2.0*pi*iTime), surfacePos.y).xzy)+distortion_noise(20.0*surfacePos, 0.125*2.0*pi*iTime) );\n    float noise2 = noise( (48.0*surfacePos.y)+(6.0*noise1) );\n\n    vec3 baseColor = vec3(noise2);\n    //vec3 baseColor = jupiter_palette(noise2)*noise2;\n\n    return baseColor*lambert;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0*(fragCoord-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);\n\n    vec3 camPos = vec3(0.0, 0.0, 2.0);\n    vec3 target = vec3(0.0, 0.0, 0.0);\n    vec3 upvect = vec3(0.0, 1.0, 0.0);\n\n    if(iMouse.z > 0.0)\n    {\n        vec2 mouseUV = 2.0*(iMouse.xy-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);\n        //camPos = vec3(mouseUV, 2.0);\n        camPos = vec3( 2.0*sin(2.0*pi*mouseUV.x), 2.0*mouseUV.y, 2.0*cos(2.0*pi*mouseUV.x) );\n    }\n\n    mat3 rotmat;\n\n    rotmat[2] = normalize(target-camPos);\n    rotmat[0] = normalize( cross(rotmat[2], upvect) );\n    rotmat[1] = cross(rotmat[0], rotmat[2]);\n\n    vec3 ro = camPos;\n    vec3 rd = normalize( rotmat*vec3(fov*uv, 1.0) );\n\n    vec3 color = radiance(ro, rd);\n\n    color = clamp(1.0-exp(-max(color, 0.0)*exposure), 0.0, 1.0);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsVSzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1044, 1085, 1108, 1108, 1199], [1201, 1242, 1265, 1265, 1377], [1379, 1420, 1442, 1442, 1594], [1596, 1633, 1658, 1658, 1688], [1689, 1689, 1714, 1714, 1744], [1745, 1745, 1770, 1770, 1800], [1802, 1802, 1844, 1844, 1957], [1959, 2000, 2051, 2051, 2091], [2093, 2150, 2181, 2181, 3044], [3046, 3068, 3090, 3090, 3269], [3271, 3271, 3304, 3304, 6170], [6172, 6172, 6212, 6212, 9375], [9377, 9377, 9396, 9396, 9669], [9671, 9798, 9864, 9864, 10396], [10398, 10398, 10455, 10455, 10957], [10959, 10959, 10992, 10992, 11042], [11044, 11044, 11068, 11068, 11108], [11110, 11110, 11188, 11188, 11395], [11397, 11397, 11460, 11460, 11506], [11508, 11508, 11541, 11541, 12586], [12588, 12588, 12645, 12645, 13485]]}
{"id": "NsVXWd", "name": "conetests", "author": "Del", "description": "cone tests", "tags": ["cone"], "likes": 3, "viewed": 108, "published": "Public API", "date": "1635524071", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// capped cone / capped pyramid testing\n\n\n//https://iquilezles.org/www/articles/distfunctions/distfunctions.htm#\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n//float sdCappedConeTest( vec3 p, float h, float r1, float r2 )\n//{\n//  vec2 q = abs(p).xz-vec2(0.125);\n//  q = vec2(length(max(q,0.0)) + min(max(q.x,q.y),0.0),p.y);\n//  vec2 k1 = vec2(r2,h);\n//  vec2 k2 = vec2(r2-r1,2.0*h);\n//  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n//  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n//  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n//  return s*sqrt( min(dot2(ca),dot2(cb)) );\n//}\n\n\n\n\n\n// truncated pyramid - https://www.shadertoy.com/view/NsKSDc\nfloat sdCappedPyramid(vec3 position, float h, float r1, float r2 )\n{\n    float s1 = abs(position.y) - h;\n    // bottom\n    vec3 position1 = position;\n    position1.y -= -h;\n    position1 = abs(position1) - vec3(r1, 0.0, r1);\n    vec3 intersection1 = max(position1, 0.0);\n    float d1 = dot(intersection1, intersection1);\n    // top\n    vec3 position2 = position;\n    position2.y -= h;\n    position2 = abs(position2) - vec3(r2, 0.0, r2);\n    vec3 intersection2 = max(position2, 0.0);\n    float d2 = dot(intersection2, intersection2);\n    \n    position.x = abs(position.x);\n    position.z = abs(position.z);\n\n    vec3 p1 = vec3(r1, -h, 0.0);\n    vec3 p2 = vec3(r1, -h, r1);\n    vec3 p3 = vec3(0.0, -h, r1);\n    vec3 p4 = vec3(r2, h, 0.0);\n    vec3 p5 = vec3(r2, h, r2);\n    vec3 p6 = vec3(0.0, h, r2);\n    vec3 end = p5 - p2;\n    vec3 position3 = position - p2;\n  \n    // side\n    vec3 normal1 = cross(p1 - p2, end);\n    float s2 = dot(position3, normal1);\n    float d3;\n    if (dot(cross(normal1, p2 - p1), position - p2) < 0.0 && \n        dot(cross(normal1, p2 - p1), position - p5) > 0.0 &&\n        dot(cross(normal1, p5 - p2), position - p2) < 0.0) { \n        d3 = s2 * s2 / dot(normal1, normal1);\n    } else {\n        vec3 intersection = position3 - end * clamp(dot(position3, end) / dot(end, end), 0.0, 1.0);\n        d3 = dot(intersection, intersection);\n    }\n \n    // front/back\n    vec3 normal2 = cross(end, p3 - p2);\n    float s3 = dot(position3, normal2);\n    float d4;\n    if (dot(cross(normal2, p6 - p5), position - p2) < 0.0 &&\n        dot(cross(normal2, p6 - p5), position - p5) > 0.0 && \n        dot(cross(normal2, p2 - p5), position - p5) < 0.0) { \n        d4 = s3 * s3 / dot(normal2, normal2);\n    } else {\n        vec3 intersection = position3 - end * clamp(dot(position3, end) / dot(end, end), 0.0, 1.0);\n        d4 = dot(intersection, intersection);\n    }\n    return sqrt(min(min(min(d1, d2), d3), d4)) * sign(max(max(s1, s2), s3));\n}\n\nmat3 lookAtMatrix(vec3 from, vec3 to) {\n    vec3 forward = normalize(to - from);\n    vec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = cross(right, forward);\n    return mat3(right, up, forward);\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\nfloat sdf(in vec3 position)\n{ \n\n    position.xz*=rot(fract(iTime*0.1)*6.28);\n\n    float m = sin(iTime*2.2)*0.3;\n\n    \n    float r1 = 0.7-m;\n    float r2 = 0.7+m;\n    float halfHeight = 0.75;\n    float d1 = sdCappedPyramid(position-vec3(1.5,0.0,0.0), halfHeight, r1, r2);\n    float d2 = sdCappedCone(position+vec3(1.5,0.0,0.0), halfHeight, r1, r2);\n    \n    return min(d1,d2);\n}\n\nvec3 normal(vec3 position) {\n    float epsilon = 0.001;\n    vec3 gradient = vec3(\n        sdf(position + vec3(epsilon, 0, 0)) - sdf(position + vec3(-epsilon, 0, 0)),\n        sdf(position + vec3(0, epsilon, 0)) - sdf(position + vec3(0, -epsilon, 0)),\n        sdf(position + vec3(0, 0, epsilon)) - sdf(position + vec3(0, 0, -epsilon))\n    );\n    return normalize(gradient);\n}\n\n\n//https://www.shadertoy.com/view/ttGfz1\nfloat lighting(vec3 normal)\n{\n    //fake image based lighting (\"outdoor lighting\")\n    return length(sin(normal*2.)*.5+.5)/sqrt(3.)*smoothstep(-1.,1.,normal.z);\n}\n\n\nfloat raycast(vec3 rayOrigin, vec3 rayDirection) {\n    int stepCount = 128;\n    float maximumDistance = 15.0;\n    float t = 0.0;\n    for (int i = 0; i < stepCount; i++) {\n        if (t > maximumDistance) {\n            break;\n        }\n        vec3 currentPosition = rayOrigin + rayDirection * t;\n        float d = sdf(currentPosition);\n        if (d < 0.0001) {\n            return t;\n        }\n        t += d;\n    }\n    return 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\t//float angle = 0.5 * (iTime - 10.0);\n    float angle = 0.0;\n\tvec3 rayOrigin = 1.2 * vec3(3.0 * cos(angle), 1.5, 3.0 * sin(angle));\n    vec3 targetPosition = vec3(0.0);\n    mat3 cameraTransform = lookAtMatrix(rayOrigin, targetPosition);\n    vec3 result = vec3(0.0);\n    ivec2 sampleCount = ivec2(1.0, 1.0);\n    for (int y = 0; y < sampleCount.y; y++) {\n        for (int x = 0; x < sampleCount.x; x++) {\n            vec2 uv = fragCoord + (vec2(float(x), float(y)) / vec2(sampleCount) - 0.5);\n            uv = uv / iResolution.xy;\n            uv = (uv * 2.0) - 1.0;\n            uv.x *= iResolution.x / iResolution.y;\n            vec3 rayDirection = normalize(vec3(uv, 1.5));\n            rayDirection = cameraTransform * rayDirection;\n            float t = raycast(rayOrigin, rayDirection);\n            vec3 color = vec3(0.0);\n            if (t > 0.0) {\n                vec3 position = rayOrigin + rayDirection * t;\n                vec3 n = normal(position);\n                float ll = lighting(n);\n                color = vec3(0.9,0.9,0.5)*ll;\n\n                \n                if (iMouse.z>0.5)\n                {\n                    fragColor = vec4(n, 1.0);\n                    return;\n                }\n                \n            }\n            // gamma        \n            color = sqrt(color);\n            result += color;\n        }\n    }\n    result /= float(sampleCount.x * sampleCount.y);\n\tfragColor = vec4(result, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsVXWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 113, 138, 138, 157], [158, 158, 217, 217, 530], [992, 1053, 1121, 1121, 3006], [3008, 3008, 3047, 3047, 3229], [3231, 3231, 3252, 3252, 3320], [3321, 3321, 3350, 3350, 3698], [3700, 3700, 3728, 3728, 4073], [4076, 4116, 4145, 4198, 4278], [4281, 4281, 4331, 4331, 4714], [4716, 4716, 4771, 4810, 6200]]}
{"id": "NsySDc", "name": "shaderClass1", "author": "andreiJay", "description": "for my shaders class", "tags": ["educational"], "likes": 2, "viewed": 79, "published": "Public", "date": "1635375202", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec3 cameraCol=texture(iChannel0, uv).xyz;\n    \n    col+=cameraCol;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sf3zn", "previewfilepath": "/presets/webcam.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/webcam.png", "ctype": "webcam"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsySDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 371]]}
{"id": "NsySDD", "name": "Fractal 88_gaz_", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 11, "viewed": 122, "published": "Public", "date": "1634632368", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    vec3 p,r=iResolution,c=vec3(0),\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));\n    float i=0.,s,e,g=0.,t=iTime;\n    for(;++i<99.;)\n    {\n        p=g*d;\n        p.z-=t*.5;\n        p=R(p,vec3(.577),1.5+t*.02);\n        p.xy=asin(cos(p.xy/2.))*2.;\n        p.z=asin(cos(p.z/1.5))*1.5;\n        vec2 q=vec2(length(p.xy)-.5,p.z);\n        s=6.;\n        for(int i=0;i++<7;)\n        {\n            q=vec2(3.2+sin(t*.5)*.3,2.2)-abs(q-vec2(2.5,1.9+sin(t*1.5)*.07));\n            s*=e=7./min(dot(q,q),8.);\n            q=q*e;\n        }\n        g+=e=abs(q.y/s)+.004;\n        //c+=mix(vec3(1),H(log(s)*.3),.3)*.015*exp(-.01*i*i*e);\n        c+=mix(vec3(1),H(log(s)*.3),.3)*7e-5*exp(-.5*sin(i))/e;\n\n    }\n    c*=c*c*c*c;\n    O=vec4(c,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsySDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 142, 142, 860]]}
{"id": "NsySRy", "name": "Fab21 #inktober2021 \"fuzzy\"", "author": "FabriceNeyret2", "description": "[url]https://inktober.com/[/url]\n#inktober2021 themes: [img]https://i.imgur.com/QjhAdpd.png[/img]\n\nmouse controls camera", "tags": ["raymarching", "short", "inktober2021"], "likes": 13, "viewed": 271, "published": "Public API", "date": "1634807100", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rot(a)  mat2(cos(a+vec4(0,11,33,0)))                       // rotation\n\n#define r  q.yz *= rot(.5-6.*M.y),                                 \\\n           q.xz *= rot(2.-6.*M.x)                                  \\\n\n#define C(l,w)  (                         /* rotated cube SDF */   \\\n        r,                                                         \\\n        a = abs(q)-(l),                                            \\\n        t = min(t, min(length(max(a.xy,a.xz)),length(max(a.xy,a.zy))) - (w) ) )\n\nvoid mainImage(out vec4 O, vec2 U) \n{\n    float t=9.,h=0.,b,c;                                           // b,c: hit object id \n    vec3  R = iResolution,\n          D = normalize(vec3(U+U, -3.5*R.y) - R),                  // ray direction\n          p = 9./R, q, a,                                          // marching point along ray \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(20,8,0)/1e2*cos(.3*iTime+vec3(0,11,0)); \n     \n    for (c=1.; c > 0. && t > .01; c-=.01)                          // --- draw the fuzzy cube\n        q = p, t = 9., \n        r, C( 1.2, -.05 ), h += exp(-t*t), \n        p += .5*t*D;                                               // step forward = dist to obj\n\n    p = 9./R;\n    for (O=vec4(1); O.x > 0. && t > .01; O-=.01)                   // --- draw the sharp cubes\n        q = p, \n        c = C( 1.5, .04 ),\n        r,                                                         // ( frame of the fuzzy cube )\n        b = C( .8 , .03 ), \n        p += .2*t*D;                                               // step forward = dist to obj\n\n  O *= 1.5; t==c ? O *= vec4(.8,.9,1,1) : t==b ? O *= vec4(1,.9,.8,1) : O; // color scheme\n  O = max( O, .04*h*vec4(.8,1,.8,1) );                             // combine sharp + fuzzy\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsySRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[507, 507, 544, 544, 1762]]}
{"id": "NsySWt", "name": "julset precision test", "author": "vstelegin", "description": "Float precision test", "tags": ["fractal", "julia"], "likes": 1, "viewed": 29, "published": "Public", "date": "1635459935", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 z = (-iResolution.yx+2.0*fragCoord.yx)/iResolution.y;\n    z *= 2.0;\n    float s = sin(iTime *0.25);\n    z /= 64000.0 * (0.001 + s*s*s*s);\n    z.y += 0.054951;\n    z.x -= 0.00001;\n    vec2 c = vec2(0.25, 0.51 );\n    c = 0.44 *cos(c + 3.87) - 0.38*cos(c + 0.1);\n    float f = 0.1;\n    for (int i = 0; i < 256; i++)\n    {\n     \tz = vec2( z.x*z.x-z.y*z.y, 2.0*z.x*z.y ) + c;\n\t\tf = min( f, dot(z,z) );\n    }\n    \n    f = 1.0 - f;\n    float background = max(0.0 , 1.0 - f);\n    f = max(0.0, f);\n    f *= f*f;\n    f *= f*f;\n    \n    vec3 ca = vec3(1.0,0.5,0.0);\n    vec3 cb = vec3(0.0,0.0,1.0);\n    \n    vec3 color = mix(ca,cb,f);\n    color.x = sin(color.x *32.0 + sin(iTime));\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsySWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 772]]}
{"id": "NsySWw", "name": "Simple Raymarching Pt 1", "author": "dreymatic", "description": "first iteration raymarching", "tags": ["raymarch"], "likes": 2, "viewed": 43, "published": "Public", "date": "1634700095", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415925359\n#define TWO_PI 6.2831852\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURFACE_DIST .01\n\nfloat dot2(in vec2 v) { return dot(v,v); }\nfloat dot2(in vec3 v) { return dot(v,v); }\nfloat ndot(in vec2 a, in vec2 b) { return a.x*b.x - a.y*b.y; }\n\nfloat sdSphere( vec3 p, float s ) { return length(p) - s; }\n\n\nfloat GetDist(vec3 p) {\n    vec4 s = vec4(0, 1, 6. + sin(iTime)*3.,1);\n    float sphereDist = length(p-s.xyz) - s.w;\n    float planeDist = p.y;\n    float d = min(sphereDist, planeDist);\n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n    float dO = 0.;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd * dO;\n        float ds = GetDist(p);\n        dO += ds;\n        if(dO > MAX_DIST || ds < SURFACE_DIST) break;\n    }\n    return dO;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy-0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(0, 1, 0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    float d = RayMarch(ro, rd);\n    \n    d /= 10.;\n    \n    fragColor = vec4(vec3(d), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsySWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[119, 119, 142, 142, 161], [162, 162, 185, 185, 204], [205, 205, 239, 239, 267], [269, 269, 304, 304, 328], [331, 331, 354, 354, 537], [539, 539, 573, 573, 795], [797, 797, 854, 904, 1141]]}
{"id": "NsySWy", "name": "The first", "author": "schzna", "description": "my first shader", "tags": ["practice"], "likes": 0, "viewed": 22, "published": "Public", "date": "1635179542", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float ac = 1.5;\n\n    // Time varying pixel color\n    float d = distance(fragCoord, iResolution.xy/2.0)/distance(vec2(0.0, 0.0),iResolution.xy/2.0);\n    vec3 col = abs(\n        d * 100.0 *\n        cos(ac*vec3(1.0*iTime,1.0*iTime,0.6*iTime)+uv.xyx+vec3(2,2,2))) * \n        (1.0/(0.5+distance(uv, vec2(0.5, 0.5)))\n    );\n    \n    col *= exp(d*2.0);\n\n    // Output to screen\n    fragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsySWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 558]]}
{"id": "NsySzc", "name": "Simmetry linear - Variant", "author": "NoxWings", "description": "Simmetry linear - Variant", "tags": ["simmetrylinearvariant"], "likes": 7, "viewed": 157, "published": "Public API", "date": "1634990198", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant on https://www.shadertoy.com/view/3tKGzV\n\n#define SURF_HIT 0.001\n#define FAR_PLANE 50.\n#define animTime (mod(iTime, 10.))\n#define S(x,y,z) smoothstep(x,y,z)\n#define A(v1,v2,t1,t2) mix(v1,v2,S(t1,t2,animTime))\n\nconst float PI = 3.14159;\n\nmat2 r2d(float a) {float sa=sin(a), ca=cos(a);return mat2(ca, -sa, sa, ca);}\n\nfloat fold = 0.0;\nfloat map(vec3 p) {\n    vec3 q = p;\n    \n\n    q = mod(q, fold) - fold*.5;\n    float d = length(q.xy) - 0.4;\n    d = min(d, length(q.xz) - 0.4);\n    d = min(d, length(q.yz) - 0.4);\n    return d;\n}\n\nvec3 mapNormal(vec3 p) {\n    vec2 e = vec2(SURF_HIT, 0);\n    float m = map(p);\n    return normalize(vec3(\n    \tm - map(p - e.xyy),\n        m - map(p - e.yxy),\n        m - map(p - e.yyx)\n    ));\n}\n\nfloat mapTrace(vec3 ro, vec3 rd) {\n    float d = 0.;\n    for (int i=0;i<128;i++) {\n        float h = map(ro + rd * d);\n        if (h < SURF_HIT || d >= FAR_PLANE) break;\n        d += h;\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y * 1.0;\n\n    vec3 ro = vec3(0, 0, 0);\n    vec3 rd = normalize(vec3(uv, -1));\n    \n    fold = mix(0.1, 4.0, animTime);\n    fold = A(fold, 0.1, 7.0, 10.0);\n    \n    ro += vec3(0, 0, -1.* animTime * fold);\n    rd.xy *= r2d(PI * mix(animTime * 0.1, animTime * 0.1 - 0.3, sin(animTime * PI * 0.3)));\n\n    float d = mapTrace(ro, rd);\n    vec3 p = ro + rd*d;\n    vec3 n = mapNormal(p);\n\n    vec3 fogCol = vec3(1);\n    vec3 col = fogCol;\n    if (d < FAR_PLANE) {\n        vec3 outer = vec3(0.9);\n        vec3 inner = vec3(0.1, 0.1, 0.1);\n        \n        float f = pow(clamp(1.0 - dot(-rd, n), 0.0, 1.0), 1.5);\n        float fog = clamp(pow(d/FAR_PLANE, 1.), 0.0, 1.0);\n        \n        col = f * outer + (1.0 - f) * inner;        \n        col = mix(col, fogCol, vec3(fog));\n    }\n\n    fragColor = vec4(col, 1.0f);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsySzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 248, 267, 267, 324], [344, 344, 363, 363, 539], [541, 541, 565, 565, 736], [738, 738, 772, 772, 945], [947, 947, 1004, 1004, 1907]]}
{"id": "NsyXDV", "name": "Türk Bayrağı", "author": "mcetinkaya", "description": "Cumhuriyet bayramımız için küçük bir çalışma.\nThank You BigWings (https://www.shadertoy.com/user/BigWIngs)", "tags": ["bayrak", "trkbayra"], "likes": 4, "viewed": 42, "published": "Public", "date": "1635280090", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.14159265359\n#define S smoothstep\nvec3 BLACK = vec3(0.);\nvec3 WHITE = vec3(1);\nvec3 RED = vec3(227,10,23)/255.;\nvec3 BLUE = vec3(173,216,237)/255.;\nfloat Star(vec2 uv, float size) {\n    uv.x  -= 2.30; // Yıldızın yatay konumu\n    float tx = uv.x;\n    uv.x = uv.y;\n    uv.y = tx;\n    uv.x = abs(uv.x);\n    float a = 2.0*pi/5.;\n    float d1 = dot(uv, vec2(sin(a),cos(a)));\n    \n    a = 3.*2.*pi/5.;\n    float d2 = dot(uv, vec2(sin(a),cos(a)));\n    \n    \n    a = 2.*2.*pi/5.;\n    float d4 = dot(uv, vec2(sin(a),cos(a)));\n    \n    float d = min(max(d1, d2), max(uv.y, d4));\n    float w = min(fwidth(d), 0.05);\n    return smoothstep(w, -w, d-size); // d*6.\n}\nfloat Circle(vec2 uv, vec2 p, float r, float blur) {\n \tfloat d = length(uv-p);\n    float c= smoothstep(r, r-blur, d);\n    return c;\n}\nfloat Hilal(vec2 uv, float size) {\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    uv.x += .20; // Hilalin yatay konumu\n    vec3 col = RED;\n    float mask = Circle(uv / size, vec2(0.), .4, .007);\n    float mouth = Circle(uv / size, vec2(0., 0.), .3, .007);\n    mouth -= Circle(uv / size, vec2(0.08, 0.), .24, .007);\n    return mouth;\n}\nvec2 Remap(vec2 p, float b, float l, float t, float r) {\n    return vec2((p.x-l) / (r - l), (p.y - b) / (t - b));\n}\nvec3 Flag (vec2 uv) {\n    float y = sin(uv.y * pi * 13.);\n    float w = fwidth(y);\n\tfloat stripes = smoothstep(-w, w, y);\n    w = fwidth(uv.y);\n    vec3 col = RED;\n\n    vec2 st = Remap(uv, .445, .75, 1., .4);\n    float size = .375;\n    vec2 gv = st*vec2(6,5) - .5;\n    if (st.x <= -.7 || st.x >= 2.13) {\n        col = BLACK;\n        return col;\n    }\n\n    col = mix(\n        mix(col, RED, smoothstep(0., w*3., st.y)),\n        WHITE,\n        Hilal(uv, .90)\n        );\n\n    col = clamp(max(col, Star(gv, size)), RED, WHITE);\n    if (st.x >= 2.08) { // Uçkurluk\n        col = mix(col, WHITE, .9);\n\n    }\n    col *= smoothstep(w, 0., abs(uv.y-.51)-.51+w);\n\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    float t = uv.x*7.-2.*iTime+uv.y*3.; // Dalga efekti\n    uv.y += .011 + sin(t)*.03; // Dalga efekti\n    uv.x += sin(t)*.0009; // Dalga efekti\n\n\n    vec3 col = Flag(uv);\n    col *= .7+cos(t)*.3; // Dalga efekti\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsyXDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[160, 160, 193, 193, 668], [669, 669, 721, 721, 802], [803, 803, 837, 837, 1149], [1150, 1150, 1206, 1206, 1265], [1266, 1266, 1287, 1287, 1937], [1938, 1938, 1995, 1995, 2281]]}
{"id": "NsyXWw", "name": "Desert mesas v4", "author": "jarble", "description": "A desert terrain based on zchajax's [url=https://www.shadertoy.com/view/3dXcW2]\"simple terrain\"[/url] shader.", "tags": ["terrain", "fbm", "mountain", "desert", "erosion", "mesa"], "likes": 14, "viewed": 178, "published": "Public API", "date": "1634702411", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SC (250.0)\n\nvec2 noise(in vec2 uv)\n{\n    //return sin(uv.x/1.6)+cos(-uv.y*1.6);\n    return vec2(sin(uv.x),cos(uv.y))+vec2(1.);\n}\n\n#define OCTAVES 8\nfloat fbm1(in vec2 uv,int octaves,float i1,float value1)\n{\n    //this function generates the terrain height\n    float value = value1;\n    float amplitude = i1*value1;\n    float freq = i1/2.;\n    float n1 = 0.;\n    vec2 noise2;\n    for (int i = 0; i < octaves; i++)\n    {\n        \n        \n        noise2 = noise(noise2.yx+uv/(freq));\n        vec2 noise1 = noise2-value;\n        freq /= 2.15;\n        n1 = noise1.x+noise1.y;\n\n        value += n1*(amplitude-freq);\n\n        uv += (noise2.yx)*freq;\n    }\n    \n    return -value;\n}\n\nfloat fbm(vec2 uv, int oct){\n    float result = 0.;\n    uv /= 2.;\n    for(float i = 1.; i < 3.; i++){\n        float i1 = i*i;\n        result += fbm1(uv,oct,i1,result/i1);\n        oct /= 2;\n    }\n    return result/16.;\n}\n\nfloat fbm(in vec2 uv){\n    return fbm(uv,OCTAVES);\n}\n\nfloat f(in vec3 p,int iters)\n{   \n    float h = fbm(p.xz,iters);\n    return h;\n}\n\nfloat f(in vec3 p)\n{   \n    float h = fbm(p.xz,OCTAVES);\n    return h;\n}\n\nvec3 getNormal(vec3 p, float t)\n{\n    vec3 eps=vec3(.001 * t, .0, .0);\n    vec3 n=vec3(f(p - eps.xyy) - f(p + eps.xyy),\n                2. * eps.x,\n                f(p - eps.yyx) - f(p + eps.yyx));\n  \n    return normalize(n);\n}\n\nfloat rayMarching(in vec3 ro, in vec3 rd, float tMin, float tMax)\n{\n    float t = tMin;\n\tfor( int i = 0; i < 300; i++ )\n\t{\n        vec3 pos = ro + t * rd;\n\t\tfloat h = pos.y - f(pos,OCTAVES);\n\t\tif( abs(h) < (0.0015 * t) || t > tMax ) \n            break;\n\t\tt += 0.4 * h;\n\t}\n\n\treturn t;\n}\n\n/*\n//raymarching with LOD\nfloat rayMarching(in vec3 ro, in vec3 rd, float tMin, float tMax)\n{\n    float t = tMin;\n    int oct = 2;\n\tfor( int i = 0; i < 300; i++ )\n\t{\n        vec3 pos = ro + t * rd;\n\t\tfloat h = pos.y - f(pos,OCTAVES);\n\t\tif( abs(h) < (0.0015 * t) || t > tMax ) \n            if(oct < 8) oct += 2;\n            else break;\n\t\tt += 0.4 * h;\n\t}\n\n\treturn t;\n}\n*/\n\nvec3 lighting(vec3 p, vec3 normal, vec3 L, vec3 V)\n{\n    vec3 sunColor = vec3(1., .956, .839);\n    vec3 albedo = vec3(1.);\n   \tvec3 diff = max(dot(normal, L) * albedo, 0.);\n    \n    vec3 refl = normalize(reflect(L, normal));\n    float spec = max(dot(refl, -normalize(V)), 0.);\n    spec = pow(spec, 18.);\n    spec = clamp(spec, 0., 1.);\n    float sky = max(0.0, dot(vec3(0.,1.,0.), normal));\n    \n    //float amb = 0.5 * smoothstep(0.0, 2.0, p.y);\n    \n    vec3 col = diff * sunColor;\n    col += spec * sunColor;\n    col += sky * vec3(0., .6, 1.) * .1;\n    //col += amb * .2;\n    \n   \treturn col;\n}\n\nmat3 lookAt(vec3 origin, vec3 target, float roll)\n{\n    vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n    vec3 ww = normalize(target - origin);\n    vec3 uu = normalize(cross(ww, rr));\n    vec3 vv = normalize(cross(uu, ww));\n\n    return mat3(uu, vv, ww);\n}\n\nvec3 camerapath(float t)\n{\n    vec3 p=vec3(-13.0+3.5*cos(t),3.3,-1.1+2.4*cos(2.4*t+2.0));\n\treturn p;\n}\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\t\n    vec3 lightDir = normalize(vec3(0., 1., -1.));\n    \n    vec3 camStep = vec3(-1., 0., 0.) * (iTime+12.)/4.;\n    vec3 camPos = vec3(8., 2., 5.) + camStep;\n    vec3 camTarget = vec3(1., 1., 4.) + camStep;\n\n    \n    mat3 mat = lookAt(camPos, camTarget, 0.0);\n    \n    vec3 ro = camPos;\n    ro.y += fbm(ro.xz,OCTAVES)-1.8;\n\n    vec3 rd = normalize(mat * vec3(uv.xy, 1.0));\n        \n    if (length(iMouse.xy) > 40.0) {\n        rd.yx *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        rd.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n\n    \n    float tMin = .1;\n    float tMax = 20.;\n    float t = rayMarching(ro, rd, tMin, tMax);\n    \n    vec3 col = vec3(0.);\n    \n    if (t > tMax)\n    {\n        // from iq's shader, https://www.shadertoy.com/view/MdX3Rr\n        float sundot = clamp(dot(rd, lightDir), 0.0, 1.0);\n        col = vec3(0.3,0.5,0.85) - rd.y*rd.y*0.5;\n        col = mix( col, 0.85*vec3(0.7,0.75,0.85), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n        // sun\n\t\tcol += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n\t\tcol += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n\t\tcol += 0.2*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );\n        // clouds\n\t\tvec2 sc = ro.xz + rd.xz*(SC*1000.0-ro.y)/rd.y;\n\t\tcol = mix( col, vec3(1.0,0.95,1.0), 0.5*smoothstep(0.5,0.8,fbm(0.0005*sc/SC)) );\n        // horizon\n        col = mix( col, 0.68*vec3(0.4,0.65,1.0), pow( 1.0-max(rd.y,0.0), 16.0 ) );\n    }\n    else\n    {\n        vec3 p = ro + rd * t;\n        vec3 normal = getNormal(p, t);\n        vec3 viewDir = normalize(ro - p);\n        \n        // lighting terrian\n        col = lighting(p, normal, lightDir, viewDir);\n        \n        // fog\n        float fo = 1.0-exp(-pow(30. * t/SC,1.5) );\n        vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n        col = mix( col, fco, fo);\n    }\n    \n    // Gama correction\n    col = pow(clamp(col, 0., 1.), vec3(.45)); \n    \n    fragColor = vec4(vec3(col), 1.0);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsyXWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 44, 87, 136], [156, 156, 214, 263, 683], [685, 685, 713, 713, 904], [906, 906, 928, 928, 958], [960, 960, 990, 990, 1040], [1042, 1042, 1062, 1062, 1114], [1116, 1116, 1149, 1149, 1343], [1345, 1345, 1412, 1412, 1630], [1632, 2004, 2056, 2056, 2601], [2603, 2603, 2654, 2654, 2855], [2857, 2857, 2883, 2883, 2959], [3027, 3027, 3084, 3084, 5031]]}
{"id": "NsyXzz", "name": "Physically based area light", "author": "hyperknot", "description": "Physically based lightness calculation\nfor a rectangular area light perpendicular to a\nmatte (Lambertian) ground plane, expanding up and down.\ndetails: https://hyperknot.com/blog/area_lights_in_shaders/", "tags": ["light", "area", "physics"], "likes": 3, "viewed": 175, "published": "Public API", "date": "1634228485", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Physically based lightness calculation\n// for a rectangular area light perpendicular to a\n// matte (Lambertian) ground plane, expanding up and down.\n// details: https://hyperknot.com/blog/area_lights_in_shaders/\n\nfloat area_light_antideriv(vec2 uv, float i, float h, float t) {\n  float lxh = length(vec2(uv.x, h));\n  return -i * uv.x * atan((t-uv.y)/lxh) / lxh;\n}\n\nfloat area_light(vec2 uv, float i, float h_bottom, float h_top, float t_start, float t_end) {\n  // i - light's intensity\n  // h_top and h_bottom - the light's top and bottom above the ground\n  // t_start and t_end - the light's start and end on the y-axis\n  float v =\n  + area_light_antideriv(uv, i, h_top, t_end)\n  + area_light_antideriv(uv, i, h_bottom, t_start)\n  - area_light_antideriv(uv, i, h_bottom, t_end)\n  - area_light_antideriv(uv, i, h_top, t_start);\n  return max(0., v);\n}\n\n\nfloat lin_to_srgb ( float val ) {\n  if( val < 0.0031308 )\n    return val * 12.92;\n  else\n    return 1.055 * pow(val,1.0/2.4) - 0.055;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = ( fragCoord - .5*iResolution.xy ) / iResolution.y;\n    uv *= 2.;\n\n    float h_top = pow(sin(iTime/3.), 2.) * 0.1 + 0.001;\n\n    float v = area_light(uv, 0.05, 0.0, h_top, -0.5, 0.5);\n    v += area_light(uv, -0.5, 0.0, h_top, -0.5, 0.5);\n    v = lin_to_srgb(v);\n\n\t\n \tfragColor=vec4(v);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsyXzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 216, 280, 280, 366], [368, 368, 461, 623, 853], [856, 856, 889, 889, 991], [993, 993, 1049, 1049, 1349]]}
{"id": "Nt33Rn", "name": "Toxijuice_Blobs", "author": "Toxijuice", "description": "I initially was trying to make a lava lamp, but stopped at the blobs.", "tags": ["blobs", "lavalamp"], "likes": 3, "viewed": 41, "published": "Public", "date": "1635566796", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ss smoothstep\n#define saturate(x) clamp(x, 0.0, 1.0)\nconst float BUBBLE_AMOUNT = 30.0;\nconst float BUBBLE_SIZE_MULT = 0.9;\nconst float BUBBLE_SIZE_ADD = 0.3;\nconst vec2 BUBBLE_OFFS_MULT = vec2(0.35, 0.2);\n\n\n//From https://stackoverflow.com/a/17897228\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//From https://stackoverflow.com/a/17897228\nvec3 rgb2hsv(vec3 c){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// From Martijn Steinrucken\n// https://www.youtube.com/channel/UCcAlTqd9zID6aNX3TzwxJXg\n// https://www.shadertoy.com/user/BigWIngs\nfloat N21(vec2 p) {\n    p = fract(p*vec2(123.3,234.3));\n    p += dot(p, p+23.2);\n    return fract(p.x*p.y);\n}\n\nvec2 N22(vec2 p){\n    return vec2(N21(p), N21(vec2(fract(p.x*p.y*2.0), dot(p, p+723.27531))));\n}\n\nfloat spot(vec2 uv, vec2 pos, float size){\n    uv = (uv - 0.5) * 2.0;\n    return ss(1.0-saturate(length(uv * size - pos)), 0.0, 0.5);\n}\n\nfloat bubble(vec2 uv, float seed, float size){\n    vec2  sd = vec2(seed, seed);\n    vec2  ps = N22(sd)*size;\n    vec2  tm = N22(ps);\n    tm *= BUBBLE_OFFS_MULT;\n    tm = vec2(sin(iTime * (tm.x + 0.05)) * BUBBLE_OFFS_MULT.x, sin(iTime * (tm.y + 0.05)));\n    float sz = N21(ps + sd) * BUBBLE_SIZE_MULT + BUBBLE_SIZE_ADD;\n    sz *= size;\n    return spot(uv, ps + tm, sz);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 buv = fragCoord/iResolution.y;\n    buv.y *= 0.5;\n    buv.x *= 0.5;\n    buv += vec2(0.5, 0.25);\n    \n    float bub = 0.0;\n    \n    for(float i = 0.0; i < BUBBLE_AMOUNT; i += 1.0){\n        bub += bubble(buv, i * 2.0 + 1.0, 15.0);\n    }\n    \n     for(float i = 0.0; i < BUBBLE_AMOUNT; i += 1.0){\n        bub += bubble(buv, i * 22.0 + 5.0, 7.0);\n    }\n    \n    bub /= BUBBLE_AMOUNT * 2.0;\n    \n    float bubShade = ss(bub, 0.0, 0.0015);\n    bubShade *= bubShade * bubShade;\n    bub = ss(bubShade, 0.0, 0.1);\n    \n    \n    vec3 c1 = vec3(1.0, 0.0, 0.0);\n    vec3 c2 = vec3(0.5, 0.0, 0.1);\n    vec3 col = mix(c2, c1, bubShade) * bub;\n    col = mix(c2*0.5, col, col.r);\n    \n    vec3 hsv = rgb2hsv(col);\n    hsv.x += (iTime + uv.x * 16.0) * 0.01;\n    col = hsv2rgb(hsv);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt33Rn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[215, 259, 280, 280, 449], [451, 495, 516, 516, 847], [849, 980, 999, 999, 1089], [1091, 1091, 1108, 1108, 1187], [1189, 1189, 1231, 1231, 1324], [1326, 1326, 1372, 1372, 1696], [1699, 1699, 1756, 1756, 2624]]}
{"id": "Ntc3z8", "name": "Psychedelicx", "author": "function", "description": "x*y", "tags": ["xy"], "likes": 0, "viewed": 116, "published": "Public API", "date": "1635659589", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float col, col2, col3, col4;\n    vec4 color;\n    col = (fragCoord.x - iResolution.x / 2.0) * (fragCoord.y - iResolution.y / 2.0) * (150.0 + iTime / 300.0) / 10000.0;\n    col2 = mod(col + iTime / 0.3 + fragCoord.x / iResolution.x * 50.0, 2.0) ;\n    col3 = mod(col + iTime / 0.4 + fragCoord.y / iResolution.y * 50.0, 2.0) ;\n    col4 = mod(col + iTime / 0.5 + fragCoord.y / iResolution.x * 50.0, 2.0) ;\n    if (col2 > 1.0){ col2 = 2.0 - col2;}\n    if (col3 > 1.0){ col3 = 2.0 - col3;}\n    if (col4 > 1.0){ col4 = 2.0 - col4;}\n    fragColor = vec4(col2, col3, col4, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ntc3z8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 631]]}
{"id": "NtcGRr", "name": "Rotating ASCII donut", "author": "dkaraush", "description": "Inspired by ASCII donut.c", "tags": ["raymarching", "torus", "donut"], "likes": 22, "viewed": 214, "published": "Public API", "date": "1635558037", "time_retrieved": "2021-10-01T00:00:00", "image_code": "                  precision highp\n              int;/**/float G(vec3 p){\n           float s=sin(iTime),c=cos(iTime\n         ),n=1.-c,o=.7,k=o*o;vec4 D=mat4(n\n       *k+c,n*k,o*s,0,n*k,n*k+c,-o*s,0,-o*s,\n     o*s,c,0,0,0,0,0)*vec4(p+vec3(0,0,-4),1);\n    return length(vec2(length(D.xz)-1.,D.y))-.4\n   ;}void mainImage(out vec4 O,in vec2 I){vec2 R\n   =iResolution.xy,u=(I.xy-vec2((R.x-R.y)*.5,0))\n  /R.y*45.;/**/vec3 d=       normalize(vec3(floor\n  (u)/45.-.5,1)),C =           vec3(0);for(int i=\n  0;i<15;++i){C+=d*G           (C);}float D= max(\n  dot(normalize((vec3          (G(C+vec3(.1,0,0))\n  ,G(C+vec3(0,.1,0))           ,G(C+vec3(0,0,.1))\n  )-G(C))/.1),normalize     (-C)),.0); ivec2 b =\n   ivec2(floor(fract(u)*7.8))-(1,0);O=vec4(vec3(\n   length(C)<9.&&b.x>=0&&b.x<=4&&b.y>=0&&b.y<=6\n    &&/*#*/(int[13](0,0x40000,0xc0000,0x810200,\n    0x41038104, 0x28000, 0x3428000, 0x1428500,\n      0x5c000,0x141c500,0xb9cee73a,0xc2afea86\n         ,0xf55b305f)[int(D*13.)]&1<<int(b\n           .x*7+(6-b.y)-1))>0?D:0.),1);}\n             /*# made by @dkaraush #*/\n                 /*# dima.bio #*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtcGRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 56, 72, 72, 302], [302, 302, 339, 339, 1015]]}
{"id": "Ntt3Rr", "name": "Fractal weirdness 4", "author": "jarble", "description": "A fractal pattern that looks almost 3-dimensional.", "tags": ["fractal", "parallax"], "likes": 6, "viewed": 150, "published": "Public API", "date": "1635618139", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;\n    vec2 uv1 = ((fragCoord)*10.0-iResolution.xy)/iResolution.y/60.;\n    uv1.y -= 2.3;\n    //uv1 += iTime/160.;\n    for(int c=0;c<3;c++){\n        vec2 uv = uv1;\n        for(int i=0;i<6;i++)\n        {\n            uv = fract((uv.y+uv.x+uv-iTime/8.))-.5;\n            uv *= (uv.y-uv.x)*(3.);\n            col[c] += (uv.y-uv.x);\n            col.yx += (uv.xy/16.);\n            col = col.yzx;\n        }\n\n\t}\n    \n    fragColor = vec4(fract(col),1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ntt3Rr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 547]]}
{"id": "sd3SRf", "name": "vector pancake", "author": "Bl00dhound", "description": "extremely greedy, massive amounts of for loops \ntried to make things dynamic where i really cannot afford it\n\nif anyone knows a way to somehow reduce the internal resolution i could probably pull this off with dynamic sizes\n", "tags": ["shapes", "vector"], "likes": 2, "viewed": 38, "published": "Public", "date": "1633697485", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nfuck i want pancakes\n\na very greedy and slow attempt at implementing 3d vector math\nthis just doensn't work all that well without vertex shaders lol\n\ntried to make the sizes of the meshes dynamic, despite the fixed size arrays (using structs)\nmay just decide to store everything in 1 set, and hold a 2nd set with fake pointers (array indices as breakpoints)\n\ncould try using another channel to dump a texture\n\n*/\n\nprecision lowp float;\nfloat xy_ratio;\n#define pi 3.1415\n#define phi 1.61803\n#define mesh_vertlimit 64\n#define num_meshes 5\n\n// mesh structure\nstruct mesh {\n    vec3[mesh_vertlimit] vertices;  // vertices in the mesh\n    int vcount; // actual vertex count (constant array size workaround)\n};\n\nmesh[num_meshes] meshes;\nvec2 uv;\nfloat psize; //pixel size\n\n\n    // draw pixel from uv map\n    float draw_pix(vec2 pos) {\n    float pix=0.0;\n    pos-=uv;\n\n\n      if (pos.x<0.0) { return pix; }\n      else \n      if (pos.x>psize) { return pix; }\n      else\n      if (pos.y<0.0) { return pix; }\n      else \n      if (pos.y>psize) { return pix; }\n\n    return 1.0;\n    }\n\n\n    /* --- \n        mesh functions\n    */   \n    // make a vector mesh  with (count) points (3d. to allow for complex rotations)\n    mesh mesh_create_circle(int points,float scale) {\n    mesh msh_out;\n    vec3[mesh_vertlimit] vecs;\n    \n        for(int a=0; a<points; a++) {\n        float fac=float(a)/float(points);\n        float x=sin(fac*pi*2.0)*scale;\n        float y=cos(fac*pi*2.0)*scale;\n        vecs[a]=vec3(x,y,0.0);\n        }\n    \n    msh_out.vertices=vecs;\n    msh_out.vcount=points;\n    return msh_out;\n    }\n    \n\n    // draw a mesh \n    float mesh_draw(mesh msh) {\n    int points=msh.vcount;\n    float pix=0.0;\n    \n        for(int a=0; a<points; a++) {\n        //vec3 it=msh.vertices[a];\n        vec2 pos=vec2(msh.vertices[a].x,msh.vertices[a].y);\n        \n            if(uv.x-pos.x>.1) { continue; }\n        pix+=draw_pix(pos);  \n        }\n        \n    return pix;\n    }\n    \n    // rotate on X axis\n    mesh mesh_rotate_x(mesh msh,float angle) { \n    float sina=sin(angle);\n    float cosi=cos(angle);\n    int points=msh.vcount;\n    \n    mat3 rot_x = mat3(1.0,0.0, 0.0,\n                      0.0,cosi,-sina,\n                      0.0,sina,cosi);\n  \n        for(int a=0; a<points; a++) {\n        //vec3 it=msh.vertices[a];\n        \n        msh.vertices[a]*=rot_x;\n        }    \n        \n    \n    return msh;\n    }\n\n    // rotate on X axis\n    mesh mesh_rotate_y(mesh msh,float angle) { \n    float sina=sin(angle);\n    float cosi=cos(angle);\n    int points=msh.vcount;\n    \n    mat3 rot_y = mat3(cosi,0.0, sina,\n                      0.0, 1.0, 0.0,\n                      -sina,1.0,cosi);\n  \n        for(int a=0; a<points; a++) {\n        //vec3 it=msh.vertices[a];\n        \n        msh.vertices[a]*=rot_y;\n        }    \n        \n    \n    return msh;\n    }\n\n    // rotate on X axis\n    mesh mesh_rotate_z(mesh msh,float angle) { \n    float sina=sin(angle);\n    float cosi=cos(angle);\n    int points=msh.vcount;\n    \n    mat3 rot_z = mat3(cosi,-sina, 0.0,\n                      sina, cosi, 0.0,\n                      0.0,0.0,1.0);\n  \n        for(int a=0; a<points; a++) {\n        //vec3 it=msh.vertices[a];\n        \n        msh.vertices[a]*=rot_z;\n        }    \n        \n    \n    return msh;\n    }\n\n    // wave animation \n    mesh mesh_wave_animation(mesh msh,float time, float intensity) { \n    int points=msh.vcount;\n\n        for(int a=0; a<points; a++) {\n        //vec3 it=msh.vertices[a];\n        float sina=sin((msh.vertices[a].x*pi*2.0)+time);\n        float cosi=cos((msh.vertices[a].y*pi*2.0)+time);    \n\n        msh.vertices[a].x+=(sina-cosi)*intensity;\n        }    \n        \n    \n    return msh;\n    }\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\nxy_ratio=iResolution.x/iResolution.y; // resolution width:height ratio coefficient\npsize=(1.0/iResolution.y)*8.0; // 8 pixels in float\n\nfloat xy_diff=iResolution.x/((iResolution.x-iResolution.y)/2.0);\nuv=fragCoord/iResolution.xy;\nvec2 uv_float=uv;\nuv.x-=.25;\n//\nuv.x*=xy_ratio;\n//uv.x+=uv.x*.5;\n\n    // don't do shit out of bounds\n    if (uv.x<0.0 || uv.x>1.0) {\n    return;\n    }\n\nuv=-1.0+(uv*2.0);  // convert to unit vector space\nvec3 col=vec3(0.0);\n\n  /*\n  field of view stuff, not right now\n  float ang=45.0;\n  float fov=1.0/tan(ang/2.0);\n\n  \n  */\n\n    for (int m=0; m<num_meshes; m++) {\n    float scl=.25+(float(m)/float(num_meshes)-.125);\n    int num_points=int(floor(scl*float(mesh_vertlimit)));\n    meshes[m]=mesh_create_circle(num_points,scl);  // create_circle (vertex points,scale) - number of points cannot exceed mesh_vertlimit\n    meshes[m]=mesh_rotate_x(meshes[m],(iTime*.13));\n    meshes[m]=mesh_rotate_y(meshes[m],(iTime*.41));\n    meshes[m]=mesh_rotate_z(meshes[m],(-iTime*.127));\n    meshes[m]=mesh_wave_animation(meshes[m],iTime*3.45,float(m+3)*.008);  // (mesh/frequency/amplitude)\n    col+=vec3(mesh_draw(meshes[m]));\n    }\n\nvec3 col_bg=vec3(uv_float.x,uv_float.y,1.0-uv_float.x);\n\ncol*=col_bg;\n\nfragColor = vec4(col,1.0);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd3SRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[775, 805, 831, 831, 1075], [1082, 1211, 1260, 1260, 1598], [1609, 1629, 1656, 1656, 1964], [1974, 1998, 2040, 2040, 2406], [2412, 2436, 2478, 2478, 2846], [2852, 2876, 2918, 2918, 3286], [3292, 3315, 3379, 3379, 3700], [3703, 3703, 3758, 3758, 5010]]}
{"id": "sd3SWM", "name": "Wobble 2", "author": "pdkl95", "description": "Just a wobbly ring shape. Highly configurable with the #define constants at the top.", "tags": ["wobble", "ring"], "likes": 0, "viewed": 57, "published": "Public", "date": "1633285097", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// -- wobble2 by pdkl95 (2015) --\n\n#define TAU 6.283185307179586\n#define TAU_3 (TAU / 3.0)\n#define TAU_4 (TAU / 4.0)\n#define TAU_6 (TAU / 6.0)\n#define TAU_8 (TAU / 8.0)\n#define TAU_16 (TAU / 16.0)\n#define TAU_32 (TAU / 32.0)\n#define TAU_64 (TAU / 64.0)\n\n#define LAST_TIME_DELTA   (1.0/50.0)\n#define TS_MAG             3.4\n#define RV_MAG             0.0666\n#define RING_RADIUS        0.28\n#define RING_WIDTH         0.1\n#define RING_BORDER_WIDTH  0.01\n#define RIPPLE_MAG        85.0\n#define WOBBLE_MAG         0.02\n#define HUE_CYCLE_TIME     4.0\n\nvec3 rgb2hsv(in vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\n    vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(in vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec2 rotate(in vec2 point, in float rads) {\n\tfloat cs = cos(rads);\n\tfloat sn = sin(rads);\n\treturn point * mat2(cs, -sn, sn, cs);\n}\t\n\nfloat rectify(in float x) {\n    return ((x + 1.0) * 0.5);\n}\n\nfloat crectify(in float c) {\n    return 1.0 - clamp(c, 0.0, 1.0);\n}\n\nfloat mkring(in float width, in float ringwidth, in vec2 obj_pos, in vec2 pos, in vec2 dir) {\n    float d = distance(obj_pos, pos);\n    float rnear = width - ringwidth;\n    float rfar = width + ringwidth;\n    if (d <= (rfar - RING_BORDER_WIDTH)) {\n        float cyl_fade =  ((sin(iTime * 0.1) + 1.0) / 2.0) * 0.7 + 0.05;\n        vec3 cyl_normal = vec3(vec2(obj_pos - pos), d);\n\n        vec3 cyl_light_normal = vec3(-1.0, -1.0, -1.0);\n\n        float cyl = (dot(cyl_normal, vec3(dir, -0.9)) * 0.12) +\n            (dot(cyl_normal, cyl_light_normal) * 0.09);\n\n        return cyl * (cyl_fade);\n    }\n    if (abs(d - rfar) < RING_BORDER_WIDTH) {\n        return 1.0;\n    }\n    float rfar2 = 2.0 * rfar;\n    if (d < rfar2) {\n        return (rfar2 - d /rfar2);\n        float rf2 = clamp(((d/4.0)/rfar2), 0.0, 1.0) / 8.0;\n        return rf2;\n    } else {\n        return 0.0;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 position = (uv * 2.0) - 1.0;\n    position.y *= iResolution.y/iResolution.x;\n\n    float time_prev = iTime - LAST_TIME_DELTA;\n\n    float ts        = TS_MAG * iTime;\n    float ts_prev   = TS_MAG * time_prev;\n\n    vec2 spot_freq      = vec2(0.7, 0.4);\n    vec2 spot_amplitude = vec2(0.5, 0.3);\n\n    vec2 sfreq      = spot_freq + (sin(100.0 + ts)      * WOBBLE_MAG) / ts;\n    vec2 sfreq_prev = spot_freq + (sin(100.0 + ts_prev) * WOBBLE_MAG) / ts_prev;\n    vec2  spot      = vec2(spot_amplitude.x * sin(sfreq.x * ts),\n                           spot_amplitude.y * cos(sfreq.y * ts));\n    vec2  spot_prev = vec2(spot_amplitude.x * sin(sfreq_prev.x * ts_prev),\n                           spot_amplitude.y * cos(sfreq_prev.y * ts_prev));\n\n    float ring_radius = RING_RADIUS;\n    float ring_width  = RING_WIDTH;\n\n    vec2 mouse = iMouse.xy;\n    vec2 cmouse = (mouse * 2.0) - 1.;\n\n    float mwarp = ring_radius * 12.0;\n    float mdist = distance(spot, cmouse) + mwarp / 8.0;\n    float mfract = 1.01 - cos(TAU_64 - TAU_6 * ((mwarp - mdist) / mwarp));\n    float mforce = mix(0.0, mfract, step(mdist, mwarp));\n\n    vec2 mp = cmouse - position;\n    vec2 nmp = normalize(mp);\n    float dmp = distance(mouse, position);\n\n    vec2 mvec = mforce * (mwarp / 7.0) * nmp;\n\n    ring_radius = mix(ring_radius, ring_radius * 1.2,  mforce);\n    ring_width  = mix(ring_width,  ring_width  * 0.8,  mforce);\n    spot        = mix(spot,        spot        + (1.2 * mvec), mforce);\n    spot_prev   = mix(spot_prev,   spot_prev   + (2.2 * mvec), mforce);\n\n    vec2 pos = position;\n    pos -= mvec;\n\n    float mpd = 48.0 * (dmp/2.0 + 0.125);\n    \n    vec2 mpdvec = nmp / (mpd * mpd);\n    pos = pos - mpdvec;\n    \n    vec2 dir        = spot - spot_prev;\n\n    float d         = distance(spot,      pos);\n    float d_prev    = distance(spot_prev, pos);\n\n    float delta_d   = d - d_prev;\n\n    float ripple    = sin(ts + (delta_d * RIPPLE_MAG));\n    float rv        = RV_MAG * ripple;\n    float ringv = mkring(ring_radius + rv, ring_width, spot, pos, dir);\n\n    float tc = iTime * 5.0;\n\n    float hue_cycle = HUE_CYCLE_TIME;\n    float hue_time  = mod(iTime, hue_cycle);\n    float hue_fract = hue_time / hue_cycle;\n\n    vec3 top_color = mix(vec3(1.0, 1.0, 1.0), vec3(0.0, 0.0, 1.0), uv.x);\n    vec3 bot_color = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), uv.x);\n    vec3 basecolor = mix(bot_color, top_color, uv.y);\n\t\n    vec3 hsvcolor = rgb2hsv(basecolor.rgb);\n    hsvcolor.x = fract(hsvcolor.x + hue_fract);\n    vec3 rcolor = hsv2rgb(hsvcolor);\n\n    vec3 c = vec3( crectify(sin(1.5 * tc)) * rcolor.r,\n                   crectify(cos(2.1 * tc)) * rcolor.g,\n                   crectify(sin(3.7 * tc)) * rcolor.b );\n\n    vec3 cmix = mix(c, rcolor, 1.0 - (ringv / 4.0));\n    vec3 outc = cmix * ringv;\n    float a = ringv + 0.185;\n\n    fragColor = vec4(outc, clamp(a, 0.0, 1.0));\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd3SWM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 546, 571, 571, 886], [888, 888, 913, 913, 1082], [1084, 1084, 1127, 1127, 1214], [1217, 1217, 1244, 1244, 1276], [1278, 1278, 1306, 1306, 1345], [1347, 1347, 1440, 1440, 2219], [2221, 2221, 2276, 2276, 5175]]}
{"id": "sd3SWs", "name": "Fork Raymarchin malie77 360", "author": "malie77", "description": "trying to mix", "tags": ["procedural", "3d", "raymarching", "distancefields", "primitives"], "likes": 1, "viewed": 63, "published": "Public", "date": "1634156329", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org/\n\n// A list of useful distance function to simple primitives. All\n// these functions (except for ellipsoid) return an exact\n// euclidean distance, meaning they produce a better SDF than\n// what you'd get if you were constructing them from boolean\n// operations (such as cutting an infinite cylinder with two planes).\n\n// List of other 3D SDFs:\n//    https://www.shadertoy.com/playlist/43cXRl\n// and\n//    http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2   // make this 2 or 3 for antialiasing\n#endif\n\n//------------------------------------------------------------------\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdBoundingBox( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdOctogonPrism( in vec3 p, in float r, float h )\n{\n  const vec3 k = vec3(-0.9238795325,   // sqrt(2+sqrt(2))/2 \n                       0.3826834323,   // sqrt(2-sqrt(2))/2\n                       0.4142135623 ); // sqrt(2)-1 \n  // reflections\n  p = abs(p);\n  p.xy -= 2.0*min(dot(vec2( k.x,k.y),p.xy),0.0)*vec2( k.x,k.y);\n  p.xy -= 2.0*min(dot(vec2(-k.x,k.y),p.xy),0.0)*vec2(-k.x,k.y);\n  // polygon side\n  p.xy -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  vec2 d = vec2( length(p.xy)*sign(p.y), p.z-h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n// vertical\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n    vec2 q = h*vec2(c.x,-c.y)/c.y;\n    vec2 w = vec2( length(p.xz), p.y );\n    \n\tvec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n\treturn sqrt(d)*sign(s);\n}\n\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\n// c is the sin/cos of the desired cone angle\nfloat sdSolidAngle(vec3 pos, vec2 c, float ra)\n{\n    vec2 p = vec2( length(pos.xz), pos.y );\n    float l = length(p) - ra;\n\tfloat m = length(p - c*clamp(dot(p,c),0.0,ra) );\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n\n    // exact distance\n    #if 0\n    vec3 o = min(3.0*p - m, 0.0);\n    o = max(6.0*p - m*2.0 - o*3.0 + (o.x+o.y+o.z), 0.0);\n    return length(p - s*o/(o.x+o.y+o.z));\n    #endif\n    \n    // exact distance\n    #if 1\n \tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n    #endif\n    \n    // bound, not exact\n    #if 0\n\treturn m*0.57735027;\n    #endif\n}\n\nfloat sdPyramid( in vec3 p, in float h )\n{\n    float m2 = h*h + 0.25;\n    \n    // symmetry\n    p.xz = abs(p.xz);\n    p.xz = (p.z>p.x) ? p.zx : p.xz;\n    p.xz -= 0.5;\n\t\n    // project into face plane (2D)\n    vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n\tfloat b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n    // recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));;\n}\n\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n    p = abs(p);\n    vec2 b = vec2(la,lb);\n    float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n\tvec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\n//------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nfloat shape(int k, vec3 center, float arg) {\n  if (k == 0)\n    return sdSphere(center, arg);\n  else if (k == 1)\n    return sdOctahedron(center, arg);\n  else if (k == 2)\n    return sdBox(center, vec3(0.3, 0.2, 0.3));\n  else if (k == 3)\n    return sdPyramid(center, 0.5);\n  else if (k == 4)\n    return sdCappedCone(center, vec3(0.3, 0.1, 0), vec3(0.0, 0.3, 0.5),\n                        0.5, 0.6);\n  else if (k == 5)\n    return sdCone(center, vec2(0.5, 0.4), 0.8);\n  else return 1e10;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( 1e10, 0.0 );\n    int a = int(iTime*0.9)%6;\n    int b = int(iTime*0.14+3.9)%6;\n    float f = sin(iTime*2.7)*1.1+0.2;\n\n    vec3 pax = pos-vec3(0.0, 0.3, -1.0);    \n    vec2 axres = vec2(shape( a, pax, 0.35 ), 23.5);\n    vec3 pbx = pos-vec3(0.0+sin(iTime*0.9)*0.3,\n                        0.55+sin(iTime*0.8)*0.2,\n                        0.0);    \n    vec2 bxres = vec2(shape( b, pbx, 0.35 ), 9.8);\n\n    vec3 pa = pos-vec3(0.0, 0.3, 1.0);    \n    float ares = shape( a, pa, 0.35 );\n\n    vec3 pb = pbx - vec3(0, 0, 1.0); // pos-vec3(-0.0,0.05,-1.8);    \n    float bres = shape( b, pb, 0.35 );\n    \n    vec2 avgres = vec2((ares*f+bres*(1.0-f)), 16.9);\n    return opU(opU(axres, bxres), avgres);\n/*\n\n    res = opU(res, ares);\n    return res;\n\n    {\n      res = opU( res, vec2( sdSphere(    pos-vec3(-2.0,0.25, 0.0), 0.25 ), 26.9 ) );\n    }\n\n    // bounding box\n    if( sdBox( pos-vec3(0.0,0.3,-1.0),vec3(0.35,0.3,2.5) )<res.x )\n    {\n    // more primitives\n    res = opU( res, vec2( sdBoundingBox( pos-vec3( 0.0,0.25, 0.0), vec3(0.3,0.25,0.2), 0.025 ), 16.9 ) );\n\tres = opU( res, vec2( sdTorus(      (pos-vec3( 0.0,0.30, 1.0)).xzy, vec2(0.25,0.05) ), 25.0 ) );\n\tres = opU( res, vec2( sdCone(        pos-vec3( 0.0,0.45,-1.0), vec2(0.6,0.8),0.45 ), 55.0 ) );\n    res = opU( res, vec2( sdCappedCone(  pos-vec3( 0.0,0.25,-2.0), 0.25, 0.25, 0.1 ), 13.67 ) );\n    res = opU( res, vec2( sdSolidAngle(  pos-vec3( 0.0,0.00,-3.0), vec2(3,4)/5.0, 0.4 ), 49.13 ) );\n    }\n\n    // bounding box\n    if( sdBox( pos-vec3(1.0,0.3,-1.0),vec3(0.35,0.3,2.5) )<res.x )\n    {\n    // more primitives\n\tres = opU( res, vec2( sdCappedTorus((pos-vec3( 1.0,0.30, 1.0))*vec3(1,-1,1), vec2(0.866025,-0.5), 0.25, 0.05), 8.5) );\n    res = opU( res, vec2( sdBox(         pos-vec3( 1.0,0.25, 0.0), vec3(0.3,0.25,0.1) ), 3.0 ) );\n    res = opU( res, vec2( sdCapsule(     pos-vec3( 1.0,0.00,-1.0),vec3(-0.1,0.1,-0.1), vec3(0.2,0.4,0.2), 0.1  ), 31.9 ) );\n\tres = opU( res, vec2( sdCylinder(    pos-vec3( 1.0,0.25,-2.0), vec2(0.15,0.25) ), 8.0 ) );\n    res = opU( res, vec2( sdHexPrism(    pos-vec3( 1.0,0.2,-3.0), vec2(0.2,0.05) ), 18.4 ) );\n    }\n\n    // bounding box\n    if( sdBox( pos-vec3(-1.0,0.35,-1.0),vec3(0.35,0.35,2.5))<res.x )\n    {\n    // more primitives\n\tres = opU( res, vec2( sdPyramid(    pos-vec3(-1.0,-0.6,-3.0), 1.0 ), 13.56 ) );\n\tres = opU( res, vec2( sdOctahedron( pos-vec3(-1.0,0.15,-2.0), 0.35 ), 23.56 ) );\n    res = opU( res, vec2( sdTriPrism(   pos-vec3(-1.0,0.15,-1.0), vec2(0.3,0.05) ),43.5 ) );\n    res = opU( res, vec2( sdEllipsoid(  pos-vec3(-1.0,0.25, 0.0), vec3(0.2, 0.25, 0.05) ), 43.17 ) );\n\tres = opU( res, vec2( sdRhombus(   (pos-vec3(-1.0,0.34, 1.0)).xzy, 0.15, 0.25, 0.04, 0.08 ),17.0 ) );\n    }\n\n    // bounding box\n    if( sdBox( pos-vec3(2.0,0.3,-1.0),vec3(0.35,0.3,2.5) )<res.x )\n    {\n    // more primitives\n    res = opU( res, vec2( sdOctogonPrism(pos-vec3( 2.0,0.2,-3.0), 0.2, 0.05), 51.8 ) );\n    res = opU( res, vec2( sdCylinder(    pos-vec3( 2.0,0.15,-2.0), vec3(0.1,-0.1,0.0), vec3(-0.2,0.35,0.1), 0.08), 31.2 ) );\n\tres = opU( res, vec2( sdCappedCone(  pos-vec3( 2.0,0.10,-1.0), vec3(0.1,0.0,0.0), vec3(-0.2,0.40,0.1), 0.15, 0.05), 46.1 ) );\n    res = opU( res, vec2( sdRoundCone(   pos-vec3( 2.0,0.15, 0.0), vec3(0.1,0.0,0.0), vec3(-0.1,0.35,0.1), 0.15, 0.05), 51.7 ) );\n    res = opU( res, vec2( sdRoundCone(   pos-vec3( 2.0,0.20, 1.0), 0.2, 0.1, 0.3 ), 37.0 ) );\n    }\n    \n    return res;\n    */\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nvec2 raycast( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n        res = vec2( tp1, 1.0 );\n    }\n    //else return res;\n    \n    // raymarch primitives   \n    vec2 tb = iBox( ro-vec3(0.0,0.4,-0.5), rd, vec3(2.5,0.41,3.0) );\n    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        //return vec2(tb.x,2.0);\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<70 && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t,h.y); \n                break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<24; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    // filter kernel\n    vec2 w = abs(dpdx)+abs(dpdy) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy )\n{ \n    // background\n    vec3 col = vec3(0.7, 0.7, 0.9) - max(rd.y,0.0)*0.3;\n    \n    // raycast scene\n    vec2 res = raycast(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n        col = 0.2 + 0.2*sin( m*2.0 + vec3(0.0,1.0,2.0) );\n        float ks = 1.0;\n        \n        if( m<1.5 )\n        {\n            // project pixel footprint into the plane\n            vec3 dpdx = ro.y*(rd/rd.y-rdx/rdx.y);\n            vec3 dpdy = ro.y*(rd/rd.y-rdy/rdy.y);\n\n            float f = checkersGradBox( 3.0*pos.xz, 3.0*dpdx.xz, 3.0*dpdy.xz );\n            col = 0.15 + f*vec3(0.05);\n            ks = 0.4;\n        }\n\n        // lighting\n        float occ = calcAO( pos, nor );\n        \n\t\tvec3 lin = vec3(0.0);\n\n        // sun\n        {\n            vec3  lig = normalize( vec3(-0.5, 0.4, -0.6) );\n            vec3  hal = normalize( lig-rd );\n            float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n          //if( dif>0.0001 )\n        \t      dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n\t\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0);\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0-dot(hal,lig),0.0,1.0),5.0);\n            lin += col*2.20*dif*vec3(1.30,1.00,0.70);\n            lin +=     5.00*spe*vec3(1.30,1.00,0.70)*ks;\n        }\n        // sky\n        {\n            float dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n                  dif *= occ;\n            float spe = smoothstep( -0.2, 0.2, ref.y );\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0+dot(nor,rd),0.0,1.0), 5.0 );\n          //if( spe>0.001 )\n                  spe *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n            lin += col*0.60*dif*vec3(0.40,0.60,1.15);\n            lin +=     2.00*spe*vec3(0.40,0.60,1.30)*ks;\n        }\n        // back\n        {\n        \tfloat dif = clamp( dot( nor, normalize(vec3(0.5,0.0,0.6))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n                  dif *= occ;\n        \tlin += col*0.55*dif*vec3(0.25,0.25,0.25);\n        }\n        // sss\n        {\n            float dif = pow(clamp(1.0+dot(nor,rd),0.0,1.0),2.0);\n                  dif *= occ;\n        \tlin += col*0.25*dif*vec3(1.00,1.00,1.00);\n        }\n        \n\t\tcol = lin;\n\n        col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 32.0 + iTime*1.5;\n\n    // camera\t\n    vec3 ta = vec3( 0.5, -0.5, -0.6 );\n    vec3 ro = ta + vec3( 4.5*cos(0.1*time + 7.0*mo.x), 1.3 + 2.0*mo.y, 4.5*sin(0.1*time + 7.0*mo.x) );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n\n        // focal length\n        const float fl = 2.5;\n        \n        // ray direction\n        vec3 rd = ca * normalize( vec3(p,fl) );\n\n         // ray differentials\n        vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n        vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n        vec3 rdx = ca * normalize( vec3(px,fl) );\n        vec3 rdy = ca * normalize( vec3(py,fl) );\n        \n        // render\t\n        vec3 col = render( ro, rd, rdx, rdy );\n\n        // gain\n        // col = col*3.0/(2.5+col);\n        \n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd3SWs.jpg", "access": "shaders20k", "license": "mit", "functions": [[1718, 1787, 1812, 1812, 1831], [1832, 1832, 1857, 1857, 1876], [1877, 1877, 1913, 1913, 1941], [1943, 1943, 1968, 1968, 1983], [1985, 1985, 2020, 2020, 2046], [2048, 2048, 2079, 2079, 2170], [2172, 2172, 2220, 2220, 2508], [2509, 2509, 2568, 2568, 2657], [2659, 2659, 2692, 2692, 2747], [2749, 2749, 2819, 2819, 2959], [2961, 2961, 2997, 2997, 3308], [3310, 3310, 3366, 3366, 3868], [3870, 3870, 3922, 3922, 4036], [4038, 4038, 4102, 4102, 4380], [4382, 4382, 4445, 4509, 5096], [5098, 5098, 5134, 5134, 5484], [5486, 5498, 5534, 5534, 5637], [5639, 5664, 5715, 5715, 6070], [6072, 6084, 6131, 6131, 6476], [6478, 6478, 6549, 6549, 6887], [6889, 6889, 6953, 6953, 7513], [7515, 7561, 7609, 7609, 7778], [7780, 7780, 7817, 7817, 8411], [8413, 8413, 8455, 8455, 9055], [9057, 9097, 9161, 9161, 9419], [9421, 9491, 9521, 9521, 9554], [9656, 9726, 9770, 9770, 10210], [10212, 10212, 10237, 10237, 13666], [13668, 13736, 13787, 13787, 13992], [13994, 13994, 14034, 14034, 14844], [14846, 14908, 14986, 15009, 15396], [15398, 15462, 15494, 15494, 16064], [16066, 16066, 16108, 16108, 16417], [16419, 16495, 16559, 16580, 16813], [16815, 16815, 16880, 16899, 19379], [19381, 19381, 19433, 19433, 19610], [19612, 19612, 19669, 19669, 21046]]}
{"id": "sd3Szs", "name": "Fire_shader_sidps", "author": "kingcrimson1112", "description": "A fire shader using perlin noise and fractal noise.", "tags": ["noise", "perlinnoise", "fire", "fractals"], "likes": 0, "viewed": 53, "published": "Public", "date": "1633875875", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//----------------------------------------------------\n// PERLIN_NOISE_GENERATOR\n//----------------------------------------------------\n\nfloat fade(float t)\n{\n    return t * t * t * (t * ((t * 6.0f) - 15.0f) + 10.0f);\n}\n\nfloat grad(int hash, float x, float y, float z)\n{\n    int h = hash & 15;\n    // Convert lower 4 bits of hash into 12 gradient directions\n    float u = (h < 8) ? x : y,\n           v = ((h < 4) ? y : (h == 12 || h == 14 ? x : z));\n    return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v);\n}\n\nint[512] p=int[512](151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142,\n             8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117,\n             35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71,\n             134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41,\n             55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89,\n             18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226,\n             250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182,\n             189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167,\n             43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246,\n             97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239,\n             107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,\n             138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180,\n             151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142,\n             8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117,\n             35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71,\n             134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41,\n             55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89,\n             18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226,\n             250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182,\n             189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167,\n             43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246,\n             97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239,\n             107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,\n             138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180);\n\n// Returns noise value for position\nfloat noise(float x, float y, float z)\n{  \n    // Find the unit cube that contains the point\n    int X = int(floor(x)) & 255;\n    int Y = int(floor(y)) & 255;\n    int Z = int(floor(z)) & 255;\n\n    // Find relative x, y,z of point in cube\n    x -= floor(x);\n    y -= floor(y);\n    z -= floor(z);\n    \n    // Compute fade curves for each of x, y, z\n    float u = fade(x);\n    float v = fade(y);\n    float w = fade(z);\n\n    // Hash coordinates of the 8 cube corners\n    int A = p[X] + Y;\n    int AA = p[A] + Z;\n    int AB = p[A + 1] + Z;\n    int B = p[X + 1] + Y;\n    int BA = p[B] + Z;\n    int BB = p[B + 1] + Z;\n\n    // Add blended results from 8 corners of cube\n    float res = mix(\n        mix(\n            mix(grad(p[AA], x, y, z),\n                 grad(p[BA], x - 1.0f, y, z),\n                 u),\n            mix(grad(p[AB], x, y - 1.0f, z),\n                 grad(p[BB], x - 1.0f, y - 1.0f, z),\n                 u),\n            v),\n        mix(\n            mix(grad(p[AA + 1], x, y, z - 1.0f),\n                 grad(p[BA + 1], x - 1.0f, y, z - 1.0f),\n                 u),\n            mix(grad(p[AB + 1], x, y - 1.0f, z - 1.0f),\n                 grad(p[BB + 1], x - 1.0f, y - 1.0f, z - 1.0f),\n                 u),\n            v),\n        w);\n    return (res + 1.0f) / 2.0f;\n}\n//----------------------------------------------------\n//----------------------------------------------------\n\n\n//----------------------------------------------------\n// OCTAVE_NOISE_GENERATOR\n//----------------------------------------------------\n#define IMAGE_ROWS 50\n#define SCALE 17.5f\n#define SCALE_FROM_CENTER 1\n#define LEVEL_OF_DETAIL 0\n#define SMOOTH_INVERSE_LERP 1\n#define OCTAVES 4\n#define PERSISTANCE 0.5f\n#define LACUNARITY 2.0f\n#define NORMALIZE_OFFSET 1\n\n// Inverse Lerp Function\nfloat linear_step(float l, float u, float a)\n{\n    return clamp(((a - l) / (u - l)), 0.0f, 1.0f);\n}\n\n// Gets the perlin noise for point b/w 0.0 and 1.0\nfloat perlin(vec2 pos, float z)\n{\n    return noise(pos.x, pos.y, z);\n}\n\nfloat get_octave_noise(vec2 pos, float z, float s)\n{\n    float rows = float(IMAGE_ROWS);\n    pos *= rows;\n    float columns = rows * (iResolution.x / iResolution.y);\n    float scale = float(SCALE);\n    if(scale <= 0.0f)\n    {\n        scale = 0.001f;\n    }\n    \n    int octaves = int(OCTAVES);\n    float lacunarity = max(LACUNARITY, 1.0f);\n    float persistence = min(PERSISTANCE, 1.0f);\n    \n    float halfX = 0.0f;\n    float halfY = 0.0f;\n#if SCALE_FROM_CENTER\n    halfX = columns / 2.0f;\n    halfY = rows / 2.0f;\n#endif\n\n    float amplitude = 1.0f;\n    float frequency = 1.0f;\n    float noiseVal = 0.0f;\n    \n    // Add LODs\n#if LEVEL_OF_DETAIL\n    pos /= float(LEVEL_OF_DETAIL);\n    pos = vec2(floor(pos.x), floor(pos.y));\n    pos *= float(LEVEL_OF_DETAIL);\n#endif\n\n    vec2 offset = 3.0f * vec2(iTime * 0.00f, iTime * -1.25f)*s;\n    \n    for (int i = 0; i < octaves; i++)\n    {\n#if NORMALIZE_OFFSET\n        float sampleX = (((pos.x-halfX) / scale) * frequency) + offset.x;\n        float sampleY = (((pos.y-halfY) / scale) * frequency) + offset.y;\n#else\n        float sampleX = (((pos.x-halfX + offset.x*scale) / scale) * frequency);\n        float sampleY = (((pos.y-halfY + offset.y*scale) / scale) * frequency);\n#endif\n        float noise = (perlin(vec2(sampleX, sampleY),z) * 2.0f) - 1.0f;\n        noiseVal += noise * amplitude;\n        // Decrease A and increase F\n        amplitude *= persistence;\n        frequency *= lacunarity;\n    }    \n\n    // Inverser lerp so that noiseval lies between 0 and 1 \n#if SMOOTH_INVERSE_LERP\n    noiseVal = smoothstep(-0.95f, 1.1f, noiseVal);\n#else\n    noiseVal = linear_step(-0.7f,0.85f,noiseVal);\n#endif\n    return noiseVal;\n}\n//----------------------------------------------------\n//----------------------------------------------------\n\n\n//----------------------------------------------------\n// FRACTAL_NOISE_GENERATOR\n//----------------------------------------------------\n#define SHARPNESS 3.5f\n#define OFFSET 1.0f\n\nfloat get_fractal_noise(vec2 pos, float z, float s)\n{\n    float rows = float(IMAGE_ROWS);\n    pos *= rows;\n    float columns = rows * (iResolution.x / iResolution.y);\n    float scale = float(SCALE);\n    if(scale <= 0.0f)\n    {\n        scale = 0.001f;\n    }\n    \n    int octaves = int(OCTAVES);\n    float lacunarity = max(LACUNARITY, 1.0f);\n    float persistence = min(PERSISTANCE, 1.0f);\n    \n    float halfX = 0.0f;\n    float halfY = 0.0f;\n#if SCALE_FROM_CENTER\n    halfX = columns / 2.0f;\n    halfY = rows / 2.0f;\n#endif\n\n    float amplitude = 1.0f;\n    float frequency = 1.0f;\n    float noiseVal = 0.0f;\n    \n    // Add LODs\n#if LEVEL_OF_DETAIL\n    pos /= float(LEVEL_OF_DETAIL);\n    pos = vec2(floor(pos.x), floor(pos.y));\n    pos *= float(LEVEL_OF_DETAIL);\n#endif\n\n    vec2 offset = 1.0f * vec2(iTime * 0.0f, iTime * -1.25f)*s;\n    vec2 shift=vec2(45.0f);\n    mat2 rot = mat2(cos(1.5), sin(1.5),\n                    -sin(1.5), cos(1.5));\n    \n    for (int i = 0; i < octaves; i++)\n    {\n#if NORMALIZE_OFFSET\n        float sampleX = (((pos.x-halfX) / scale) * frequency) + offset.x;\n        float sampleY = (((pos.y-halfY) / scale) * frequency) + offset.y;\n#else\n        float sampleX = (((pos.x-halfX + offset.x*scale) / scale) * frequency);\n        float sampleY = (((pos.y-halfY + offset.y*scale) / scale) * frequency);\n#endif\n        float noise = (perlin(vec2(sampleX, sampleY),z) * 2.0f) - 1.0f;\n        noiseVal += abs(noise) * amplitude;\n        // Decrease A and increase F\n        amplitude *= persistence;\n        frequency *= lacunarity;\n        pos=pos*rot+shift;\n    }\n\n    // Inverser lerp so that noiseval lies between 0 and 1 \n    noiseVal=linear_step(0.0f,1.5f,noiseVal);\n    return noiseVal;\n}\n\nfloat get_fractal_height(vec2 pos, float z, float s)\n{\n    float h=get_fractal_noise(pos,z,s);\n    h = OFFSET-h;\n    h = pow(h,SHARPNESS);\n    return h;\n}\n//----------------------------------------------------\n//----------------------------------------------------\nvec3 lF = vec3(1.0f,0.0f,1.25f);\nvec3 lB = vec3(1.25f,0.15f,0.75f);\nvec4 limitsF = vec4(-1.5f,1.5f,-1.0f,0.6f);\nvec4 limitsB = vec4(-1.5f,1.5f,-1.0f,0.6f);\nvec3 cF=vec3(0.0f,-0.9f,1.35f);\nvec3 cB=vec3(0.0f,-0.8f,1.5f);\nvec3 darkCol=vec3(0.6f,0.1f,0.0f);\nvec3 lightCol=vec3(1.0f,0.7f,0.0f);\n\nvec3 get_color(vec2 pos)\n{  \n   darkCol=vec3(0.0f,0.05f,0.1f);\n   lightCol=vec3(0.0f,0.85f,0.15f);\n   \n   // Get Octave Height\n   float hF = get_octave_noise(pos*lF.x,lF.y,lF.z);\n   float hB = get_octave_noise(pos*lB.x,lB.y,lB.z);\n   hF=pow(hF,1.25f)*1.1f;\n   hB*=0.75f;\n   \n   // Get Fractal Height\n   float fF=get_fractal_height(pos*lF.x,lF.y,lF.z);\n   float fB=get_fractal_height(pos*lB.x,lB.y,lB.z);\n   \n   // Apply Limits\n   vec4 limF=limitsF;\n   if(pos.x<limF.x || pos.x>limF.y || pos.y<limF.z || pos.y > limF.w)\n   {\n       hF=0.0f;\n   }\n   vec4 limB=limitsB;\n   if(pos.x<limB.x || pos.x>limB.y || pos.y<limB.z || pos.y > limB.w)\n   {\n       hB=0.0f;\n   }\n   \n   // Apply Alpha Limits\n   float h1=distance(pos,cF.xy)/cF.z;\n   h1=clamp(h1,0.0f,1.0f);\n   h1=1.0f-h1;\n   hF*=h1*1.5f;\n   \n   float h2=distance(pos,cB.xy)/cB.z;\n   h2=clamp(h2,0.0f,1.0f);\n   h2=1.0f-h2;\n   hB*=h2*1.75f;\n   \n   // Apply Fractal\n   hF*=fF;\n   hF=smoothstep(0.0f,0.35f,hF);\n   hB*=fB;\n   hB=smoothstep(0.0f,0.35f,hB);\n    \n\n   // Apply Threshold\n   if(hF<0.25f)\n   {\n       hF=0.0f;\n   }\n   if(hB<0.05f)\n   {\n       hB=0.0f;\n   }\n     \n   // Apply Color\n   vec3 col=mix(darkCol, vec3(0.0f),pos.y-0.2f*sin(1.25f*iTime));\n   if(hB>0.0f)\n   {\n       col=mix(darkCol,mix(darkCol,lightCol,0.5f),hB*1.25f);\n       if(hB<=0.06f)\n       {\n           col=vec3(0.25f*darkCol);\n       }\n   }\n   if(hF>0.0f)\n   {\n       col=mix(darkCol,lightCol,hF);\n       if(hF<=0.28f)\n       {\n           col=vec3(0.5f*darkCol);\n       }\n   }\n   return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Get UVs\n    vec2 uv=fragCoord/iResolution.xy;\n    uv=uv*2.0f-1.0f;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    // Get Color\n    vec3 col=get_color(uv);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd3Szs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 137, 158, 158, 219], [221, 221, 270, 270, 513], [3176, 3212, 3252, 3304, 4490], [4960, 4985, 5031, 5031, 5084], [5086, 5137, 5170, 5170, 5207], [5209, 5209, 5261, 5261, 6879], [6992, 7173, 7226, 7226, 8889], [8891, 8891, 8945, 8945, 9045], [9046, 9447, 9473, 9473, 10963], [10965, 10965, 11022, 11037, 11247]]}
{"id": "sdcSWn", "name": "Box Node Connections", "author": "byt3_m3chanic", "description": "Something started over the break - and just playing around in the updated shadertoy.. ", "tags": ["raymarching", "fractal", "reflection", "refraction", "transparent"], "likes": 16, "viewed": 200, "published": "Public API", "date": "1633379926", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Box Node Connections\n    10/3/21 @byt3_m3chanic\n    \n    Just playing with a simple fold/mirror formula / simple box and tube with\n    a little refraction.\n\n*/\n\n#define R iResolution\n#define M iMouse\n#define T iTime\n\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\n// updaetd with some AA - reduce to 1.0 if too slow\n#define AA 2.0\n\n\nmat2 rot (float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21( vec2 p ) { return fract(sin(dot(p,vec2(23.43,84.21))) *4832.3234); }\nfloat lsp(float begin, float end, float t) { return clamp((t - begin) / (end - begin), 0.0, 1.0); }\nfloat eoc(float t) { return (t = t - 1.0) * t * t + 1.0; }\n\n//@iq thanks for the sdf's!\n\nfloat sdbox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdframe( vec3 p, vec3 b, float e ) {\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n//globals\nmat2 rx, ry;\nfloat tmod=0.,ga2=0.,ga4=0.,ga5=0.;\nvec3 hit,hitPoint;\n\n//fold\nvoid octa(inout vec4 p, float k1, float k2, float k3, float k4)  \n{\n    p.y = abs(p.y);\n    if (p.x + p.y<0.0) p.xy = -p.yx;\n    if (p.x + p.z<0.0) p.xz = -p.zx;\n    if (p.x - p.y<0.0) p.xy = p.yx;\n    if (p.x - p.z<0.0) p.xz = p.zx;\n    p.xyz = p.xyz*k1 - (k1 - 1.0);\n}\n\nconst float zoom = 23.5;\nconst float cell = 24.;\nconst float hlf = cell/2.;\n\nvec2 map(vec3 p) {\n    vec2 res =vec2(1e5,0.);\n\n    vec3 pp = p;\n    \n    if(ga4>0.) p.xz*=rot(ga4*PI/2.);\n    if(ga5>0.) p.y+=ga5*cell;\n    \n    p.y=mod(p.y+hlf,cell)-hlf;\n  \n    vec4 P = vec4(p.xyz, 1.0);\n    float spc = 6.;\n    \n    for(int j=0;j<2;j++) { \n        octa(P, 1.,1.,1.,1.); \n        P.xyz = abs(P.zxy)-spc;\n    }\n    vec3 q = P.xyz;\n\n    q.x = abs(q.x)-spc;\n    q.z = abs(q.z)-spc;\n\n    vec3 fq = q;\n    fq.x=abs(fq.x)-1.6;\n    fq.y=abs(abs(fq.y)-.4)-.2;\n    float mainbox = sdbox(q,vec3(1.25));\n    float cutbox =  sdbox(vec3(q.xy,abs(q.z))-vec3(0,0 ,1.35),vec3(.65,.65,3.75 ));\n    float frame = sdbox(fq,vec3(.1,.1,.75));\n\n    mainbox = min(mainbox, frame);\n    mainbox = max(mainbox, -cutbox);\n    if(mainbox<res.x) res = vec2(mainbox/P.w,2.);\n\n    float frame2 = sdframe(q,vec3(1.475),.225)-.0125;\n    if(frame2<res.x) res = vec2(frame2/P.w,4.);\n\n    float dv = .45+.25*sin(q.z*.75);\n    float beams = length(q.xy)-dv;\n\n    if(beams<res.x) {\n        res = vec2(beams/P.w,3.);\n        hit=pp+vec3(0,ga2*cell,0);\n    }\n    \n    return res;\n}\n\n//Tetrahedron technique\n//https://www.iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 normal(vec3 p, float t, float mindist) {\n    float e = mindist*t;\n    vec2 h = vec2(1.0,-1.0)*0.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n                      h.yyx*map( p + h.yyx*e ).x + \n                      h.yxy*map( p + h.yxy*e ).x + \n                      h.xxx*map( p + h.xxx*e ).x );\n}\n\n//iq of hsv2rgb\nvec3 hsv2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 render(vec3 p, vec3 rd, vec3 ro, float d, float m, inout vec3 n, inout float fresnel) {\n    n = normal(p,d,1.);\n    vec3 lpos =  vec3(18,18,18);\n    lpos.xz*=ry;\n    vec3 l = normalize(lpos-p);\n    float diff = clamp(dot(n,l),0.,1.);\n    \n    fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 9.);\n    fresnel = mix(.0, .9, fresnel);\n\n    vec3 h = vec3(.1);\n    if(m==3.) h = hsv2rgb(vec3(p.x*.003+hitPoint.y*.0125,.8,.5));\n    if(m==4.) h=vec3(.4);\n \n    return diff*h;\n}\n\nvoid image( out vec4 O, in vec2 F )\n{\n    // precal\n    float time = T;\n\n    tmod = mod(time, 10.);\n    float t7 = lsp(0.0, 5.0, tmod);\n    float t9 = lsp(4.0, 10.0, tmod);\n\n    ga4 = eoc(t7);\n    ga4 = ga4*ga4*ga4;\n    ga4 = ga4+floor(time*.1);\n    \n    t9 = eoc(t9);\n    t9 = t9*t9*t9;  \n    ga2 = t9+floor(time*.1);\n    ga5 = (t9);\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n\n    vec3 ro = vec3(0, 0, zoom);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    \n    float x = M.xy == vec2(0) ? 0. : -(M.y/R.y * .25 - .125) * PI;\n    float y = M.xy == vec2(0) ? 0. : -(M.x/R.x * 1.  - .5) * PI;\n\n    rx = rot(x+.18); ry = rot(y-.58);\n\n    ro.yz *= rx; ro.xz *= ry;\n    rd.yz *= rx; rd.xz *= ry;\n\n    vec3 C = vec3(.0015);\n    vec3 p = ro + rd;\n    \n    float atten = .95;\n    float k = 1., d = 0.;\n    \n    for(int i=0;i<100;i++)\n    {\n        vec2 ray = map(p);\n        vec3 n=vec3(0);\n        float m = ray.y;\n\n        d = ray.x*.75;\n        p += rd * d *k;\n        \n        float fresnel=0.;\n        if (d*d < 1e-7) {\n            hitPoint=hit;\n            C+=render(p,rd,ro,d,ray.y,n,fresnel)*atten;\n  \n            atten *= .55;\n            p += rd*.01;\n            k = sign(map(p).x);\n\n            if(m==4.||m==1.) {\n                rd=reflect(-rd,n);\n                p+=n*.025;\n            } else {\n                vec3 rr = refract(rd,n,.55);\n                rd=mix(rr,rd,.5-fresnel);\n            }\n\n        } \n       \n        if(distance(p,rd)>50.) { break; }\n    }\n\n    if(C.r<.008&&C.g<.008&&C.b<.008) C = hash21(uv)>.5 ? C+.005 : C;\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}\n\nvoid mainImage(out vec4 O, in vec2 F){\n    vec4 C = vec4(0);\n    float px=.25;\n    if(AA==1.0) {image(C,F); O=C; return;}\n   \n    vec4 C2;\n    \n    image(C2,F.xy+vec2(px,-px));\n    C.rgb+=C2.rgb;\n    image(C2,F.xy+vec2(-px,px));\n    C.rgb+=C2.rgb;\n    \n    C/=AA;\n    \n    O = vec4(C);\n}\n\n// end\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdcSWn.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[371, 440, 460, 460, 505], [506, 506, 530, 530, 588], [589, 589, 633, 633, 688], [689, 689, 709, 709, 747], [749, 778, 809, 809, 896], [898, 898, 940, 940, 1222], [1303, 1310, 1377, 1377, 1580], [1659, 1659, 1677, 1677, 2719], [2721, 2813, 2858, 2858, 3129], [3131, 3147, 3174, 3174, 3303], [3305, 3305, 3397, 3397, 3776], [3778, 3778, 3815, 3829, 5371], [5373, 5373, 5411, 5411, 5660]]}
{"id": "sdcXzB", "name": "multicamera view", "author": "FabriceNeyret2", "description": "interpolating between several cameras depending of the screen location.\nIn this example, just changing the camera height with U.y while looking at (0,0,0).\nMouse.x : range of camera change\nMouse.y : distance\ntry commented variants ;-)", "tags": ["raymarching", "camera", "distorsion", "short", "falseperspective"], "likes": 12, "viewed": 230, "published": "Public API", "date": "1633449966", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rot(a)        mat2(cos(a),sin(a),-sin(a),cos(a))  // rotation                  \n//#define fwidth(v)   sqrt( dFdx(v)*dFdx(v) + dFdy(v)*dFdy(v) )                 \n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    vec2  R =  iResolution.xy, \n          U = ( 2.*u - R ) / R.y,\n          M = iMouse.xy!=vec2(0) ? 2.*iMouse.xy/R - 1. : vec2(sin(iTime),0);\n    vec3  V,\n          D = normalize(vec3(U, 1)),             // ray direction\n          p = vec3(0,1,-1),                      // ray start \n          L = vec3(0);                           // lookat\n          \n // p.x += M.x*U.x; p.xz /=length(p.xz);         // Xcam changes with U.x\n // p.x += M.x*U.y;                              // Xcam changes with U.y\n    p.y += M.x*U.y;                              // Ycam changes with U.y\n // p.xz*= rot(M.x*(.5+.5*U.y));                 // XZcam rotate with U.y\n // p.y += M.x*U.x;                              // Ycam changes with U.x\n    p *= 1.+M.y;                                 // Zoom\n    \n    V = L - p;                                   // D from Lookat\n    float phi = atan( V.y, length(V.xz) ),\n          theta = atan(V.x,V.z);   \n    D.yz *= rot(phi); D.xz *= rot(theta); \n        \n    \n    float d = -p.y/D.y;                          // intersect plane\n    if (d<0.) { O-=O; return; }\n    p += d* D;\n    \n    O = 6.28*vec4(1,2,4,0);                      // color scheme (checker texture with AA )\n    O = sin(O*p.x) * sin(O*p.z);\n    O = .5 + .5* O/fwidth(O)  * smoothstep(1.,0.,length(fwidth(p.xz)));\n                              // * smoothstep(0.,-5.,log2(fwidth(p.z))); // AA at horizon\n    p = abs(p); if (min(p.x,p.z)>.5) O = O.rrrr; // B&W out of [-1,1]²\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdcXzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[88, 170, 206, 206, 1676]]}
{"id": "sddXRB", "name": "pulsating gradient line 2", "author": "SET001", "description": "pulsating gradient line using smoothstep", "tags": ["gradient"], "likes": 2, "viewed": 30, "published": "Public", "date": "1633463491", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    float col = 1.0;\n    float minLineThickness = 0.1;\n    float speed = 3.0;\n    float pulseWidth = 200.;\n    \n    float b = cos(iTime*speed+fragCoord.x/pulseWidth)*0.05+minLineThickness;\n    \n    col *= smoothstep(b, 0.00, abs(uv.y));\n    fragColor = vec4(.0, col, 0.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sddXRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 446]]}
{"id": "sddXRl", "name": "water using perlin", "author": "TheTUFGuy", "description": "noise", "tags": ["noise"], "likes": 1, "viewed": 65, "published": "Public", "date": "1633757205", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//----------------------------------------------------\n// PERLIN_NOISE_GENERATOR\n//----------------------------------------------------\nfloat fade(float t)\n{\n    return t * t * t * (t * ((t * 6.0f) - 15.0f) + 10.0f);\n}\n\nfloat grad(int hash, float x, float y, float z)\n{\n    int h = hash & 15;\n    // Convert lower 4 bits of hash into 12 gradient directions\n    float u = (h < 8) ? x : y,\n           v = ((h < 4) ? y : (h == 12 || h == 14 ? x : z));\n    return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v);\n}\n\nint[512] p=int[512](151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142,\n             8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117,\n             35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71,\n             134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41,\n             55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89,\n             18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226,\n             250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182,\n             189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167,\n             43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246,\n             97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239,\n             107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,\n             138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180,\n             151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142,\n             8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117,\n             35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71,\n             134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41,\n             55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89,\n             18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226,\n             250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182,\n             189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167,\n             43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246,\n             97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239,\n             107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,\n             138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180);\n\n// Returns noise value for position\nfloat noise(float x, float y, float z)\n{  \n    // Find the unit cube that contains the point\n    int X = int(floor(x)) & 255;\n    int Y = int(floor(y)) & 255;\n    int Z = int(floor(z)) & 255;\n\n    // Find relative x, y,z of point in cube\n    x -= floor(x);\n    y -= floor(y);\n    z -= floor(z);\n    \n    // Compute fade curves for each of x, y, z\n    float u = fade(x);\n    float v = fade(y);\n    float w = fade(z);\n\n    // Hash coordinates of the 8 cube corners\n    int A = p[X] + Y;\n    int AA = p[A] + Z;\n    int AB = p[A + 1] + Z;\n    int B = p[X + 1] + Y;\n    int BA = p[B] + Z;\n    int BB = p[B + 1] + Z;\n\n    // Add blended results from 8 corners of cube\n    float res = mix(\n        mix(\n            mix(grad(p[AA], x, y, z),\n                 grad(p[BA], x - 1.0f, y, z),\n                 u),\n            mix(grad(p[AB], x, y - 1.0f, z),\n                 grad(p[BB], x - 1.0f, y - 1.0f, z),\n                 u),\n            v),\n        mix(\n            mix(grad(p[AA + 1], x, y, z - 1.0f),\n                 grad(p[BA + 1], x - 1.0f, y, z - 1.0f),\n                 u),\n            mix(grad(p[AB + 1], x, y - 1.0f, z - 1.0f),\n                 grad(p[BB + 1], x - 1.0f, y - 1.0f, z - 1.0f),\n                 u),\n            v),\n        w);\n    return (res + 1.0f) / 2.0f;\n}\n\n//----------------------------------------------------\n//----------------------------------------------------\n#define TO_OFFSET 1\n#define LEVEL_OF_DETAIL 1\n#define SCALE 12.0f\n#define IMAGE_ROWS 200.0f\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Get UVs\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2.0f - 1.0f;\n    uv *= float(IMAGE_ROWS)/2.0f;\n    uv.x *= (iResolution.x / iResolution.y);\n    \n    // Get Height Map and Color Val\n#if LEVEL_OF_DETAIL\n     uv /= float(LEVEL_OF_DETAIL);\n     uv = vec2(floor(uv.x), floor(uv.y));\n     uv *= float(LEVEL_OF_DETAIL);\n#endif\n    \n    // Add Offset\n    vec2 offset=vec2(0.0f);\n#if TO_OFFSET\n    offset.x=iTime*5.0f;\n    offset.y=-sin(iTime*2.0f)*3.0f;\n#endif\n    uv+=offset*10.0f;\n    \n    // Final Color\n    uv/=float(SCALE);\n    float h = noise(uv.x, uv.y, iTime*1.2);\n    vec3 col = vec3(h);\n    vec3 waterCol=vec3(0.0f,0.34f,0.8f);\nvec3 highlightCol=vec3(0.2f,0.9f,1.0f);\nfloat p=8.5f;\n    h=clamp(h,0.0f,1.0f);\n    h=pow(h,p);\n     col=vec3(h)*highlightCol+waterCol;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sddXRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 136, 157, 157, 218], [220, 220, 269, 269, 512], [3175, 3211, 3251, 3303, 4489], [4491, 4694, 4749, 4764, 5595]]}
{"id": "sddXWf", "name": "Perlin Coaster Ride", "author": "42yeah", "description": "Free entry. Have fun!", "tags": ["procedural", "perlin", "headacheinducing"], "likes": 7, "viewed": 126, "published": "Public API", "date": "1634117286", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define FAR 200.0\n#define EPSILON 1e-3\n#define ID(func, nid) dist = func(pos); if (dist < closest) { closest = dist; id = nid; }\n\nvec2 rand2d(vec2 uv) {\n    return fract(sin(vec2(dot(uv, vec2(12.34, 45.67)),\n        dot(uv, vec2(78.9, 3.14)))) * 12345.67) * 2.0 - 1.0;\n}\n\nfloat perlin(vec2 uv) {\n    vec2 u = floor(uv);\n    vec2 f = fract(uv);\n    vec2 s = smoothstep(0.0, 1.0, f);\n    \n    vec2 a = rand2d(u);\n    vec2 b = rand2d(u + vec2(1.0, 0.0));\n    vec2 c = rand2d(u + vec2(0.0, 1.0));\n    vec2 d = rand2d(u + vec2(1.0, 1.0));\n    \n    return mix(mix(dot(a, f), dot(b, f - vec2(1.0, 0.0)), s.x),\n        mix(dot(c, f - vec2(0.0, 1.0)), dot(d, f - vec2(1.0, 1.0)), s.x), s.y);\n}\n\nfloat sol(vec3 pos) {\n    vec2 uv = pos.xz;\n    return pos.y - perlin(uv);\n}\n\nfloat ball(vec3 pos) {\n    return length(pos) - 0.5;\n}\n\nvec2 map(vec3 pos) {\n    float closest = 1000.0;\n    float id = -1.0;\n    float dist = 0.0;\n\n    ID(sol, 0.5);\n\n    return vec2(closest, id);\n}\n\nvec3 objectColor(vec3 pos, float id) {\n    if (id > 0.0 && id < 1.0) {\n        vec2 u = mod(floor(pos.xz), 2.0);\n        vec3 color = max(vec3(abs(u.x - u.y)), 0.8);\n        \n        return color;\n    }\n    if (id > 1.0 && id < 2.0) {\n        return vec3(0.5, 1.0, 0.0);\n    }\n    return vec3(1.0, 0.0, 0.0);\n}\n\nvec2 trace(vec3 ro, vec3 rd) {\n    float depth = 0.0;\n    float id = -1.0;\n    for (int i = 0; i < 800; i++) {\n        vec2 info = map(ro + depth * rd);\n        if (info.x < EPSILON) {\n            id = info.y;\n            break;\n        }\n        depth += info.x;\n        if (depth > FAR) {\n            break;\n        }\n    }\n    return vec2(depth, id);\n}\n\nvec3 getNormal(vec3 pos) {\n    float mapped = map(pos).x;\n    \n    return normalize(vec3(\n        mapped - map(pos - vec3(EPSILON, 0.0, 0.0)).x,\n        mapped - map(pos - vec3(0.0, EPSILON, 0.0)).x,\n        mapped - map(pos - vec3(0.0, 0.0, EPSILON)).x));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    float aspect = iResolution.x / iResolution.y;\n    uv.x *= aspect;\n    \n    vec3 ro = vec3(0.0, perlin(vec2(0.0, iTime)) + 0.2, iTime);\n    vec3 center = ro + vec3(0.0, perlin(vec2(0.0, ro.z + 1.0)), 1.0);\n    vec3 worldUp = getNormal(vec3(ro.x, ro.y - 0.2, ro.z));\n//    vec3 center = vec3(0.0, 0.1, 0.0);\n    vec3 front = normalize(center - ro);\n    vec3 right = normalize(cross(front, worldUp));\n    vec3 up = normalize(cross(right, front));\n    mat4 lookAt = mat4(\n        vec4(right, 0.0),\n        vec4(up, 0.0),\n        vec4(front, 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0));\n    vec3 rd = vec3(lookAt * normalize(vec4(uv, 1.0, 1.0)));\n    \n    vec2 info = trace(ro, rd);\n    \n    vec3 sky = mix(vec3(0.78, 0.9, 1.0), vec3(1.0), 1.0 - uv.y);\n    \n    if (info.y > 0.0) {\n        vec3 pos = ro + info.x * rd;\n        vec3 color = objectColor(pos, info.y);\n        \n        // Lighting calculations\n        vec3 norm = getNormal(pos);\n        \n        // World lights\n        vec3 ambient = 0.1 * vec3(1.0);\n        vec3 skyColor = clamp(dot(norm, vec3(0.0, 1.0, 0.0)), 0.0, 1.0) * vec3(1.0);\n        // Light 1\n         \n        fragColor = vec4(\n            (ambient + skyColor) * color, \n            1.0);\n        \n        // Falloff begins at depth > 5 and goes all the way to 10.0\n        float falloff = min(max(info.x - 5.0, 0.0) / 5.0, 1.0);\n        fragColor = mix(fragColor, vec4(sky, 1.0), falloff);\n    } else {\n        fragColor = vec4(sky, 1.0);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sddXWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[130, 130, 152, 152, 270], [272, 272, 295, 295, 684], [686, 686, 707, 707, 762], [764, 764, 786, 786, 818], [820, 820, 840, 840, 963], [965, 965, 1003, 1003, 1275], [1277, 1277, 1307, 1307, 1632], [1634, 1634, 1660, 1660, 1892], [1894, 1894, 1949, 1949, 3480]]}
{"id": "sdGSD1", "name": " Fab18 #inktober2021 \"moon\"", "author": "FabriceNeyret2", "description": "[url]https://inktober.com/[/url]\n#inktober2021 themes: [img]https://i.imgur.com/QjhAdpd.png[/img]\n", "tags": ["procedural", "swirl", "texture", "planet", "loopless", "jupiter", "inktober2021"], "likes": 16, "viewed": 222, "published": "Public API", "date": "1634556006", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// reuse \"swirls on sphere\"  https://shadertoy.com/view/ssGSDh\n\n#define H(p)       fract(sin((p)*mat3(127.1,311.7, 74.7,  269.5,183.3,246.1,  113.5,271.9,124.6))*43758.5453123)\n#define R(p,a,r) ( mix( a*dot(p,a), p, cos(r) ) + sin(r)*cross(p,a) )\n#define hue(v)     vec4( .6 + .6 * cos( 6.3*(v)  + vec3(0,23,21)  ) , 1 )\n#define S(v)       smoothstep( 0., -6./R.y, v )\n#define shad(P)    vec4(vec3( .2 + .8* max(0., dot(P,vec3(1,.5,1)))), 1)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, S,\n         U = 2.* ( 2.*u - R ) / R.y;\n\n    O-=O;\n    float r = length(U), y, l=9., t = -iTime; int i,k;\n    vec3 P;\n#define moon(d,v,w,h)                                         \\\n        S = d* vec2(2.*cos(v*t), .2*sin(v*t) );               \\\n        if ( r > 1. || S.y < 0.)                              \\\n            if ( length( S = (U-S)/w ) < 1.)                  \\\n                P = vec3( S, sqrt(1.-dot(S,S)) ),             \\\n                O +=    S( length(S) - 1. )                   \\\n                      * shad(P) * (.7+.3*hue(h)) \n    moon(1., 1.,.1,.0);\n    moon(2.,.4,.07,.5);\n    moon(3.,.2,.05,.3);\n    moon(4.,.15,.03,.0);\n    moon(5.,.1,.03,.5);\n    \n    if ( r > 1. ) return;\n    \n    vec3 P0 = vec3( U, sqrt(1.-r*r) ),         // raytracing point in sphere\n         I,F, H,D,A;\n         P = 4.*P0;\n         P.xz *= mat2(cos( .2*iTime + vec4(0,11,33,0) )); // planet rotation\n         I = floor(P), F = fract(P);           // coords in 3D grid\n\n#define dist2seed  \\\n        D = vec3( k%3, (k/3)%3, k/9 ) -1.;     /* cell offset         */  \\\n        D += H(I+D)-.5;                        /* random seed point   */  \\\n        A = normalize(I+D);                                               \\\n        D = 4.*A - I;                          /* project it on sphere ( for even radius ) */ \\\n        r = length(F-D);                       /* distance to seed    */\n\n    for ( k = 0; k < 27; k++) {                // visit neighbor cells to find closest seed point\n        dist2seed;\n     // P = R( F-D, A, 10.*smoothstep(.5,0.,r) ) + D+I; // shouldn't we blend effects ?\n        r < l ? l = r, i = k : i;              // keep closest dot \n     }\n    k = i;\n    dist2seed;\n    y = atan(P.y,length(P.xz));                                   // latitude ( to tune swirl direction & amplitude )\n    y = 4.*cos(4.*y);\n    P = R( F-D, A, y * smoothstep(.5,0.,r) ) + D+I;               // rotate coords around seed point\n       \n // O = vec4(smoothstep(12./R.y,0., l-.2) ); return;              // test: plot seed points\n    \n    S = vec2( atan(P.z,P.x) - .1*iTime, atan(P.y,length(P.xz)) ); // surface coordinates\n//  S = vec2(acos(U.x/sqrt(1.-U.y*U.y)) , asin(U.y) );            // debug\n    O += (1.-O.a) * mix( \n          smoothstep( .8, .2, texture(iChannel0, S*vec2(1,3) ) )  // swirled texture\n        * (.5+.5*hue(abs(U.y*2./3.14)))                           // color\n        , vec4(.7,.8,.9,0), 1.-abs(P0).z )                        // atmosphere\n        * S( length(U)-1.)                                        // antialiasing\n        * 1.5*shad(P0);                                           // shading\n    \n}", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdGSD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 443, 481, 481, 3150]]}
{"id": "sdGSWG", "name": "eindacor_bezier", "author": "Eindacor_DS", "description": "they're bezier curves, you dolt!", "tags": ["bezier"], "likes": 2, "viewed": 27, "published": "Public", "date": "1635187302", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// POINT_COUNT must be greater than 3 and be an even number!\n#define POINT_COUNT 12\n\n#define SEGMENT_COUNT 25\n#define ANTI_ALIAS .002\n#define SHOW_CONSTRUCTS true\n#define SHOW_LINES true\n#define SHOW_POINTS true\n#define HORIZONTAL true\n#define SHOW_CURVE_SEGMENTS false\n#define HARMONIC_MODE false\n\n// from https://www.shadertoy.com/view/4djSRW\nfloat hash(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat circleSmoothStepFill(vec2 center, float radius, vec2 p, float antiAlias) {\n\treturn 1.f - smoothstep(radius - antiAlias, radius + antiAlias, distance(center, p));\n}\n\nfloat circleSmoothStep(vec2 center, float radius, float thickness, vec2 p, float antiAlias) {\n    float distFromCenter = distance(center, p);\n    float halfThickness = thickness / 2.f;\n    if (distFromCenter < radius) {\n        return smoothstep(radius - halfThickness - antiAlias, radius - halfThickness + antiAlias, distFromCenter);\n    } else {\n        return 1.f - smoothstep(radius + halfThickness - antiAlias, radius + halfThickness + antiAlias, distFromCenter);\n    }\n}\n\n/*\n\treturns smoothstep value for line segment\n\texample usage:\n\t\toutColor = mix(outColor, lineColor, lineSegmentSmoothStep(start, end, uv, thickness, AA, true));\n*/\nfloat lineSegmentSmoothStep(vec2 start, vec2 end, vec2 p, float lineThickness, float antiAlias, bool roundEnds) {\n    float halfThickness = lineThickness / 2.f;\n    if (dot(p-end, start - end) < 0.f || dot(p - start, end - start) < 0.f) {\n        return !roundEnds ? 0.f : max(\n\t\t\tcircleSmoothStepFill(start, halfThickness, p, antiAlias),\n\t\t\tcircleSmoothStepFill(end, halfThickness, p, antiAlias)\n        );  \n    }\n    \n    vec2 lineVec = normalize(end - start);\n    vec2 pVec = normalize(p - start);\n\n    float angle = acos(dot(lineVec, pVec) / length(lineVec) * length(pVec));\n    float distFromLine = sin(angle) * distance(start, p);\n    \n    return 1.f - smoothstep(lineThickness / 2.f - antiAlias, halfThickness + antiAlias, distFromLine);\n}\n\nfloat getQuadraticBezierSmoothStep(vec2 p0, vec2 p1, vec2 p2, vec2 p3, vec2 uv, float lineThickness, float aa) {\n    vec2 previousPoint = p0;\n    \n    float val = 0.f;\n    \n    for (int i=0; i<SEGMENT_COUNT; i++) {\n        if (i==0) {\n            continue; // ignore the first segment\n        }\n\n        float t = float(i) / float(SEGMENT_COUNT);\n\n        vec2 a = mix(p0, p1, t);\n        vec2 b = mix(p1, p2, t);\n        vec2 c = mix(p2, p3, t);\n\n        vec2 d = mix(a, b, t);\n        vec2 e = mix(b, c, t);\n\n        vec2 p = mix(d, e, t);\n        val = mix(val, 1.0, lineSegmentSmoothStep(previousPoint, p, uv, lineThickness, aa, true));\n\n        previousPoint = p;\n    }\n    val = mix(val, 1.0, lineSegmentSmoothStep(previousPoint, p3, uv, lineThickness, aa, true));\n    \n    return val;\n}\n\nfloat getPointSmoothStep(vec2 p, vec2 uv, float radius, float antiAlias) {\n    float pDist = distance(uv, p);\n    return smoothstep(radius + antiAlias, radius - antiAlias, pDist);\n}\n\nfloat normalSin(float sinVal) {\n    return (sinVal + 1.f) / 2.f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (POINT_COUNT % 2 == 1 || POINT_COUNT < 4) {\n        fragColor = vec4(1.f, 0, 0, 1.f);\n        return;\n    }\n\n    vec4 curveColor = vec4(0.f, 1.f, 0.5f, 1.f);\n    float lineColorVal = .5f;\n    vec4 lineColor = vec4(lineColorVal, lineColorVal, lineColorVal, 1.f);\n    vec4 pointColor = vec4(1);\n     \n    float lineThickness = .005;\n    float pointRadius = .01;\n    \n    int lineSegments = 4;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.x *= aspectRatio;\n    \n    vec2[POINT_COUNT] points;\n    \n    float canvasBuffer = .05f;\n    \n    for (int i=0; i<POINT_COUNT; i++) {\n        if (HARMONIC_MODE) {\n            points[i].y = normalSin(sin(iTime * float(i + 1) * .5f));\n        } else {\n            points[i].y = normalSin(sin(iTime * hash(vec2(i + 1, i + 1))));\n        }\n        \n        points[i].y  = mix(canvasBuffer, 1.f - canvasBuffer, points[i].y);\n        \n        if (HORIZONTAL) {\n            points[i].x = float(i) * 1.f/float(POINT_COUNT-1);\n        } else {\n            points[i].x = normalSin(sin(iTime * hash(vec2(i - 1, i - 1))));\n        }\n        \n        points[i].x = mix(canvasBuffer, aspectRatio - canvasBuffer, points[i].x);\n    }\n    \n     // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    curveColor.x = col.x;\n    curveColor.y = col.y;\n    curveColor.z = col.z;\n\n    // Output to screen\n    fragColor = vec4(0.f, 0.f, 0.f,1.0);\n     \n    for (int i=1; i<POINT_COUNT; i++) {\n        vec2 p0 = points[i-1];\n        vec2 p1 = points[i];\n        \n        if (SHOW_CONSTRUCTS) {\n            if (SHOW_LINES) {\n                fragColor = mix(fragColor, lineColor, lineSegmentSmoothStep(p0, p1, uv, .002, ANTI_ALIAS, true));\n            }\n            \n            if (SHOW_POINTS) {\n                fragColor = mix(fragColor, pointColor, getPointSmoothStep(p0, uv, pointRadius, ANTI_ALIAS));    \n                if (i == POINT_COUNT - 1) {\n                    fragColor = mix(fragColor, pointColor, getPointSmoothStep(p1, uv, pointRadius, ANTI_ALIAS));\n                }\n            } \n        }\n    }\n    \n    int numCurves = (POINT_COUNT - 2) / 2;\n    \n    vec2 previousPoint = points[0];\n    for (int n=0; n<numCurves; n++) {\n        float lineValR = hash(vec2(n+1, n+1));\n        float lineValG = hash(vec2(n, n));\n        \n        if (SHOW_CURVE_SEGMENTS) {\n            curveColor = vec4(lineValR, lineValG, .5f, 1.f);\n        }\n        \n        vec2 p0 = previousPoint;\n        \n        int curveIndex = n * 2;\n        vec2 p1 = points[curveIndex + 1];\n        vec2 p2 = points[curveIndex + 2];\n        \n        vec2 p3 = curveIndex + 3 == POINT_COUNT - 1 ? points[curveIndex + 3] : mix(p2, points[curveIndex + 3], .5f);\n        previousPoint = p3;\n        \n        if (SHOW_POINTS && curveIndex + 3 != POINT_COUNT - 1) {\n            fragColor = mix(fragColor, pointColor * .5, getPointSmoothStep(p3, uv, pointRadius * .75, ANTI_ALIAS));\n        }\n        \n        fragColor = mix(fragColor, curveColor, getQuadraticBezierSmoothStep(p0, p1, p2, p3, uv, lineThickness, .002));\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdGSWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[299, 345, 365, 365, 431], [433, 433, 513, 513, 602], [604, 604, 697, 697, 1080], [1082, 1246, 1359, 1359, 1993], [1995, 1995, 2107, 2107, 2788], [2790, 2790, 2864, 2864, 2971], [2973, 2973, 3004, 3004, 3039], [3041, 3041, 3098, 3098, 6269]]}
{"id": "sdGSzt", "name": "The Alien", "author": "dean_the_coder", "description": "Following the theme of 'lets make a shader about a movie I like', may I present 'The Alien'. :D", "tags": ["3d", "raymarching", "animation", "alien", "gyroid", "movie", "cineshader"], "likes": 20, "viewed": 671, "published": "Public API", "date": "1635099465", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 'The Alien' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/sdGSzt (YouTube: https://youtu.be/2QoR8L16Lc0)\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// I nearly gave up several times on this shader. I knew modelling\n// a human face would be hard, so thought attempting an alien would\n// be easier. No two 'alien' references seem to be the same, so\n// I can use artistic license. Also there's no eyes/node to get wrong.\n// I'm quite happy with the result, but the body could do with some arms.\n// But hey - The framerate is still acceptable (for me), so...\n//\n// I'm also trying to improve my animation skills. I've added some\n// 'anticipations', where before a strike the alien pulls back a bit\n// to build up some 'power'.\n//\n// The skull pattern was simpler than I was expecting - I just threw\n// a simple gyroid at it and it looked good! Surprising! And fast\n// to calculate in real-time.\n//\n// Tricks to get the performance:\n//   - No 'max dist' needed in raymarching loop (all rays hit something).\n//   - Only the skull is reflective, and that reflects just a fake sky.\n//     (I know there's no sky in a corridor, but it looks good!)\n//   - I precalculate two smooth noises variables in the lighting\n//     code and reuse them as much as possible.\n//   - Lots of domain repetition.\n//     E.g. Each jaw only has one tooth!\n//          There's only one SDF for the wall pipe.\n//          The Weyland-Yutani logo is _nearly_ just one line.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane,\n// totetmatt, Blackle, Dave Hoskins, byt3_m3chanic, and a bunch\n// of others for sharing their time and knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define R\tiResolution\n#define U\tnormalize\n#define L\tlength\n#define Z0\tmin(iTime, 0.)\n#define sat(x)\tclamp(x, 0., 1.)\n#define S(a, b, c)\tsmoothstep(a, b, c)\n#define S01(a)\tS(0., 1., a)\n#define minH(a, b, c)\t{ float h_ = a; if (h_ < h.d) h = Hit(h_, b, c); }\n\nfloat t;\nstruct Hit {\n\tfloat d;\n\tint id;\n\tvec3 p;\n};\n\n// Thnx Dave_Hoskins - https://www.shadertoy.com/view/4djSRW\nfloat n31(vec3 p) {\n\tconst vec3 s = vec3(7, 157, 113);\n\n\t// Thanks Shane - https://www.shadertoy.com/view/lstGRB\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\tvec4 h = vec4(0, s.yz, s.y + s.z) + dot(ip, s);\n\th = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat fbm(vec3 p) {\n\tfloat i,\n\t      a = 0.,\n\t      b = .5;\n\tfor (i = Z0; i < 4.; i++) {\n\t\ta += b * n31(p);\n\t\tb *= .5;\n\t\tp *= 2.;\n\t}\n\n\treturn a * .5;\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat h = sat(.5 + .5 * (b - a) / k);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat smax(float a, float b, float k) { return -smin(-a, -b, k); }\n\nfloat min2(vec2 v) { return min(v.x, v.y); }\n\nmat2 rot(float a) {\n\tfloat c = cos(a),\n\t      s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat box(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn L(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat cyl(vec3 p, vec2 hr) {\n\tvec2 d = abs(vec2(L(p.xy), p.z)) - hr;\n\treturn min(max(d.x, d.y), 0.) + L(max(d, 0.));\n}\n\nfloat cap(vec3 p, float h, float r) {\n\tp.x -= clamp(p.x, 0., h);\n\treturn L(p) - r;\n}\n\nfloat arc(vec3 p) {\n\tp.x -= -3.83333;\n\tvec2 v = vec2(-.56464, .82534),\n\t     q = p.xy - 2. * v * max(0., dot(v, p.xy));\n\tv = vec2(-3.83333, 0);\n\tfloat u = -v.x - L(q);\n\treturn sqrt((q.y < 0. ? dot(q + v, q + v) : u * u) + p.z * p.z) - max(.001, .8 - (p.y > 0. ? atan(-p.y, p.x) * v.x : -p.x < 0. ? p.y : 4.6 - p.y) * .06);\n}\n\nfloat backInOut(float x) {\n\tfloat f = x < .5 ? 2. * x : 1. - (2. * x - 1.),\n\t      g = pow(f, 3.) - f * sin(f * 3.141);\n\treturn x < .5 ? .5 * g : .5 * (1. - g) + .5;\n}\n\nfloat bone(vec3 p, float h, float r, float s) {\n\tfloat f = S(.7, 1., abs(p.x / h - .5) * 2.) * .05 * s;\n\tp.y = abs(p.y) - f;\n\treturn cap(p, h, r - f * .6);\n}\n\nfloat sky(vec3 rd) {\n\tfloat d = 10. / rd.y,\n\t      den = 1.;\n\tif (d < 0.) return 0.;\n\tvec3 p = rd * d + vec3(1, .2, 1) * t * .8;\n\tp.xz *= .2;\n\tfor (int i = 0; i < 3; i++)\n\t\tden *= exp(-.12 * fbm(p));\n\n\treturn S(.9, 1., den) * (1. - sat(d / 64.));\n}\n\nfloat th(inout vec3 p) {\n\tfloat f = atan(p.z, p.x) + .25087;\n\tp.xz = L(p.xz) * cos(mod(f, .26174) - .13087 + vec2(0, 1.57));\n\tp = vec3(.04 - p.y, p.x - .36, p.z);\n\tf = .45 + abs(floor(f * 2.) * .01);\n\treturn cap(p, f, .05 * S(0., f * 1.5, cos(abs(p.x / f * 1.86 - 1. + p.x))));\n}\n\nHit map(vec3 p) {\n\tHit h;\n\th.d = 1e7;\n\tfloat d, lip, at, f, nd, s, O, x, o,\n\t      ph = S(0., 5., t);\n\tp.x -= 12. * (1. - ph);\n\tp.xz *= rot(sin(t * .5) * .02);\n\tp.yz *= rot(sin(t) * .01);\n\tvec3 r, np, pp,\n\t     op = p;\n\n\t// Corridor.\n\tp.xz *= mat2(.96891, -.2474, .2474, .96891);\n\tp.y = abs(p.y);\n\tp.z -= 30.;\n\td = -p.z - 2.;\n\tp.yz *= mat2(.87758, -.47943, .47943, .87758);\n\tp.y -= 2.5;\n\tminH(min(d, -p.z), 6, p);\n\tp.x = abs(p.x + 3.) - 15.;\n\tminH(box(p - vec3(0, 8.5, 0), vec3(5, 2.3, .1)), 8, p - vec3(0, 8.5, 0));\n\n\t// Pipework.\n\td = L(p.yz - vec2(14, 0)) - 1.5;\n\tp.y = abs(p.y - 2.5) - 1.1;\n\tminH(min(d, L(p.yz) - .8), 7, p);\n\n\t// Anim.\n\tlip = 0.;\n\tr = vec3(0);\n\n\t// Walk on.\n\top.x += 16. * (1. - ph);\n\tr.xy = sin(ph * 12.566 + vec2(0, 8)) * vec2(.05, .1) * S(1., .5, ph * ph);\n\tr.z = -r.x * .5;\n\top.y += abs(r.x);\n\n\t// Slight turn.\n\tph = S(4., 8., t);\n\tr.xy = mix(r.xy, sin(backInOut(ph) * -.25132 + vec2(0, 8)) * vec2(1, .12), S(0., .2, ph));\n\n\t// Sniff.\n\tph = S(8.2, 12., t);\n\tlip = abs(sin(ph * 6.283));\n\tr.x += sin(ph * -3.142) * .015;\n\n\t// Face forward.\n\tr.xy *= S(14., 11.5, t);\n\n\t// Whip-round anticipation.\n\tph = S(14.5, 15., t);\n\tr += vec3(.1, .05, .1) * ph;\n\top.y += ph * .1;\n\n\t// Whip.\n\tph = S(15., 15.3, t);\n\tr = mix(r, vec3(-.5, .12, 0), ph);\n\n\t// Mouth open.\n\tat = S(15.3, 20., t) * .2;\n\tf = S01(at * 30.);\n\tlip += f;\n\tr.yz = mix(r.yz, vec2(.34, -.1 + sin(t) * .07), at * 5.);\n\n\t// Inner mouth open.\n\tat += S(20., 23., t) * .25;\n\n\t// Strike anticipation.\n\top.z -= S(24., 24.2, t) * .5;\n\n\t// Strike.\n\tph = S(24.2, 24.5, t);\n\top.z += ph * 1.5;\n\tat += ph * .4;\n\n\t// Withdraw.\n\tph = S(29., 32., t);\n\tat += ph;\n\top.z -= ph;\n\tr.y *= S(34., 31., t);\n\n\t// Body position.\n\top += vec3(.9, 1.3, -3.6);\n\top.yz *= rot(r.y + .2);\n\top.xz *= rot(r.x - .2);\n\tr *= 3.;\n\n\t// Spine.\n\tp = op;\n\tp.xy *= mat2(-.73739, -.67546, .67546, -.73739);\n\tp.x++;\n\td = cap(p + vec3(0, .68, 0), 4., .1 + abs(sin(p.x * 26.) * .04));\n\tminH(d, 2, p);\n\n\t// Neck/body.\n\tp.z *= 1. - mix(.4, 1.2, S01(p.x)) * .42;\n\tf = abs(sin(p.x * 15.) * .07);\n\tf *= S(.01, .05, abs(p.z));\n\tf += S(0., .3, p.x) * .6 * S01(p.y);\n\tnd = cap(p, 4., mix(.3, .5, S01(p.x)) * (1. + f));\n\tnp = p;\n\n\t// Rotate head.\n\tp = op - vec3(1, .4, 0);\n\tr *= .5;\n\tp.xz *= rot(r.x);\n\tp.yz *= rot(r.z);\n\tp += vec3(1, .4, 0);\n\top = p;\n\n\t// Skull.\n\tp = op;\n\tp.x -= 1.5;\n\tp.xy *= mat2(.85252, -.52269, .52269, .85252);\n\tp.xy = vec2(p.y - 1., -p.x);\n\td = arc(p);\n\tp = op - vec3(.9, 0, 0);\n\tp.xy *= mat2(.995, -.09983, .09983, .995);\n\tf = .15 - box(p, vec3(2.6, cos((p.x + .3) * .4) * 1.71 - .5, 1));\n\td = smax(d, f, .06);\n\tminH(d, 1, p);\n\n\t// Head bulk.\n\tp = op;\n\tp.y -= .86;\n\td = min(d, L(p.yz) - .3 - .04 * abs(sin(p.x * 7.7)) - .02 * abs(sin(p.x * 23.1)));\n\tminH(max(d, abs(p.x) - 2.4), 2, p);\n\n\t// Frills.\n\tp = op;\n\tp.xy += vec2(1.8, -.88);\n\tp.z = abs(p.z) - .22;\n\tp.xy *= mat2(.99281, .11971, -.11971, .99281);\n\tp.xz *= mat2(.9968, .07991, -.07991, .9968);\n\td = max(cap(p, 3.5, .2 + .05 * abs(sin(p.x * 22.)) + sin(p.x) * .1), -p.y - .14);\n\n\t// Lower organs.\n\tpp = p + vec3(-1.8, .3, 0);\n\tpp.yz /= .8 + .5 * cos(pp.x);\n\tpp.yz *= rot(pp.x * -.3 + .8);\n\tf = sin(pp.x * 35.);\n\tf = max(smin(box(pp, vec3(2, vec2(.1 + .01 * abs(f * f)))), L(abs(pp.yz) - .116) - .02, .08), abs(pp.x) - 2.);\n\tminH(min(d, f), 2, pp);\n\tif (nd < d) minH(smin(d, nd, .5), 9, np);\n\n\t// Skull bone.\n\tp.yz += vec2(.21, -.15) - sin(p.x - .2) * .14;\n\tminH(bone(p, 3.6, .08, 1.), 3, p);\n\n\t// Cheek bone.\n\tp.x -= 3.63;\n\tp.xy *= mat2(.88699, -.46178, .46178, .88699);\n\tp.yz *= mat2(.5403, .84147, -.84147, .5403);\n\td = min(d, bone(p, .65, .06 - .01 * sin(p.x * 10. - 1.), .8));\n\tminH(d, 3, p);\n\n\t// Top gums.\n\tp = op;\n\tp.xy -= vec2(2.3, .76);\n\td = max(cyl(p.xzy, vec2(.4 + S(-.15, .1, p.y) * .17 - S(.2, -.2, p.y + p.x) * .09, .2 - sin(p.y * 77.) * .02 * lip)) - .1, 2.75 * p.y + p.x - .4);\n\tminH(d, 3, p);\n\n\t// Smooth connect organs to top gums.\n\tminH(max(max(smin(f, d, .25) + .01, -f), -d), 2, p);\n\n\t// Top teeth.\n\tp.x -= .08;\n\tminH(max(smax(th(p), p.y - .03, .02), 2.29 - op.x), 4, p);\n\n\t// Strike animation.\n\tf = S(1., .9, at);\n\ts = S(.5, .51, at);\n\tO = (S(0., .15, at) * .6 + s * .4) * f + sin(t) * .03;\n\tx = S(0., .2, at) * .22 + s * .5;\n\to = S(.15, .4, at) * .5 + s * (sin(t * 14.) - .8) * .2;\n\tx *= f * f;\n\to *= f * f;\n\n\t// Inner mouth.\n\tp = op;\n\tp.xy *= mat2(.87758, -.47943, .47943, .87758);\n\tp.xz *= rot(sin(t * 2.) * .014 * s);\n\tp.y -= 1.44;\n\tp.x -= x - .9;\n\tpp = p;\n\td = L(p.yz) - .1 - sin(p.x * 58.) * .01;\n\tp.yz = abs(p.yz) - .08;\n\td = max(smin(max(d, -d - .012), L(p.yz) - .03, .05), abs(p.x - 2.2) - .5);\n\tminH(d, 5, p);\n\tp = pp;\n\tp.y = abs(p.y) - .08;\n\tp.x -= 2.68;\n\tp.xy *= rot(o + .1);\n\tp.x -= .05;\n\tminH(smin(d, box(p, vec3(.035 + abs(sin(abs(p.z) * 81.) * .006), .008, .1)) - .014, .03), 5, p);\n\n\t// Inner teeth.\n\tp.x -= .025;\n\tp.z = abs(abs(p.z) - .034) - .017;\n\tp.y *= -1.;\n\tp.xy = p.yx;\n\td = cap(p, .06, .016 * cos(p.x * 22.));\n\tp.z = abs(pp.z) - .09;\n\tminH(min(d, cap(p, .1, .02 * cos(p.x * 17.))), 4, p);\n\n\t// Jaws.\n\to = O * -.4 - .9;\n\tp = op - vec3(1.6, .95, 0);\n\tp.xy *= rot(o);\n\tf = p.x * -.25;\n\tp.z -= clamp(p.z, -.6 - f, .6 + f);\n\td = bone(p, .9, .1 + f * .2, .8);\n\tp.x -= .9;\n\tp.xy *= mat2(.69671, .71736, -.71736, .69671);\n\td = smin(d, cap(p, .3, p.x * -.03 + .08), .1);\n\n\t// Bottom gums.\n\tp = op - vec3(1.6, .95, 0);\n\tp.xy *= rot(.8 + o);\n\tf = cyl(p.xzy * vec3(1, 1.3, 1) - vec3(.77, 0, -.73), vec2(.38 - .005 * sin(p.y * 126.), .04)) - .05;\n\tminH(smin(d, max(f, .7 - p.x), .1), 3, p);\n\n\t// Cheek skin.\n\tpp = p - vec3(.6, -.2, 0);\n\tf = S(-.32, .32, pp.y);\n\tpp.z = abs(pp.z) - .4 - f * .14;\n\tf = mix(.8, .5, O) * (.04 - .03 * sin(3.14 * f));\n\td = smin(d, min(box(pp + vec3(.2, -.2, -.05), vec3(.1 * pp.y + f, .32, 0)), box(pp, vec3(f, .35, 0))) - .02, .03);\n\tminH(d, 3, pp);\n\n\t// Bottom teeth.\n\tp.x -= .73;\n\tp.y += .9;\n\tp.xy *= mat2(-.98999, .14112, -.14112, -.98999);\n\tminH(max(max(p.x + .1, p.y + .3), th(p)), 4, p);\n\treturn h;\n}\n\nvec3 N(vec3 p, float t) {\n\tfloat h = t * .4;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * h).d;\n\t}\n\n\treturn U(n);\n}\n\nfloat shadow(vec3 p, vec3 lp) {\n\tfloat d,\n\t      s = 1.,\n\t      t = .1,\n\t      mxt = L(p - lp);\n\tvec3 ld = U(lp - p);\n\tfor (float i = Z0; i < 25.; i++) {\n\t\td = map(t * ld + p).d;\n\t\ts = min(s, 15. * d / t);\n\t\tt += max(.1, d);\n\t\tif (mxt - t < .5 || s < .001) break;\n\t}\n\n\treturn S01(s);\n}\n\n// Quick ambient occlusion.\nfloat ao(vec3 p, vec3 n, float h) { return sat(map(h * n + p).d / h); }\n\nvec3 strobe(vec3 p, vec3 c) {\n\tp.x -= 1.5;\n\tvec2 q = p.xz * rot(t * 2.);\n\treturn mix(c, pow(c, vec3(.7, 1, 1)), S(.8, .6, abs(q.x / q.y)));\n}\n\nvec3 lights(vec3 p, vec3 rd, vec3 n, Hit h) {\n\tvec3 ld = U(vec3(6, 3, -10) - p), c;\n\tvec2 spe = vec2(10, 1);\n\tfloat ao = mix(ao(p, n, .2), ao(p, n, 2.), .7),\n\t      nh = n31(h.p * 55.),\n\t      nl = n31(h.p * 23.);\n\tif (h.id == 1) {\n        // Gyroid.\n\t\tc = pow(abs((vec3(.005, .01, .01) * dot(sin(h.p * 26.), cos(h.p.zxy * 26.))\n\t\t + nh * .0046) * .5), vec3(1.12, map(ld + p).d * -.07 + 1.46, 1.43));\n\t\tc *= 1. - (.9 * S01(.9 + dot(rd, n)) + .5);\n\t\tspe = vec2(5, 28);\n\t}\n\telse if (h.id == 2 || h.id == 5 || h.id == 9) {\n\t\tc = vec3(ao * .001);\n\t\tc += S(.8, 1., ao) * vec3(1.4, 1.4, 1) * .009;\n\t\tc *= nh;\n\t\tc += 1e-4;\n\t\tspe = vec2(30. * ao, 3);\n\t\tif (h.id == 5) {\n\t\t\tc *= 4.5;\n\t\t\tspe = vec2(3, 13);\n\t\t}\n\t}\n\telse if (h.id == 3) {\n\t\tc = vec3(.56, .5, .6) * .001;\n\t\tc += S(.09, .88, abs(n.y) * nh) * .002 * vec3(1, .62, .65);\n\t\tn += (nl - .5) * .08;\n\t\tspe = vec2(18, 20);\n\t}\n\telse if (h.id == 6) {\n\t\tc = vec3(.01 + nl * .01);\n\t\tspe = vec2(19, 1);\n\t}\n\telse if (h.id == 7) {\n\t\tc = vec3(.03 + nl * .02);\n\t\tspe = vec2(42, 50);\n\t}\n\telse if (h.id == 8) {\n\t\th.p *= .3;\n        if (p.y < 0.0) h.p.y *= -1.;\n\t\tfloat w1 = abs(abs(abs(h.p.x) - .5) - h.p.y - .25);\n\t\tc = 5e-4 + min2(step(abs(h.p.xy), vec2(1.2, .4))) * (vec3(1, 1, 0) * S(.2, .15, w1) + vec3(.5) * S(.2, .15, min(abs(abs(h.p.x) - h.p.y - .15), max(h.p.y, abs(h.p.x) - .05))) * S(.25, .2, S(.4, .3, w1))) * .05 + nh * .001;\n\t}\n\telse {\n\t\tc = vec3(.01 + pow(sat(dot(rd, reflect(ld * vec3(-1, -1, 1), n))), 24.) * .6);\n\t\tspe = vec2(8, 5);\n\t}\n\n\tif (h.id == 9) c *= .4;\n\n\t// Combine into final color.\n\treturn (sat(.1 + .9 * dot(ld, n)) * (.1 + .9 * shadow(p, vec3(6, 3, -10))) * (.3 + .7 * ao) * ao + pow(sat(dot(rd, reflect(ld, n))), spe.x) * spe.y) * strobe(p, abs(c)) * 5.;\n}\n\nvec3 scene(vec3 rd) {\n    vec3 p = vec3(0);\n\tfloat i,\n\t      d = 0.;\n\tHit h;\n\tfor (i = Z0; i < 120.; i++) {\n\t\th = map(p);\n\t\tif (abs(h.d) < .0015) break;\n\t\td += h.d;\n\t\tp += h.d * rd;\n\t}\n\n\tvec3 n = N(p, d),\n\t     col = lights(p, rd, n, h) * exp(d * d * -.002);\n\tif (h.id == 1) {\n\t\t// We hit a reflective surface - Cheat and just reflect sky.\n\t\tn = U(n + (n31(h.p * 44.) - .5) * .05);\n\t\tcol += .015 * sky(reflect(rd, n));\n\t}\n\n\treturn col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tt = mod(iTime, 36.);\n\tvec2 uv = (fc - .5 * R.xy) / R.y,\n\t     v = fc.xy / R.xy;\n\tvec3 col = scene(U(vec3(uv, 1)));\n\tcol *= .5 + .5 * pow(16. * v.x * v.y * (1. - v.x) * (1. - v.y), .4);\n\tfragColor = vec4(pow(max(vec3(0), col), vec3(.45)) * sat(t) * S(34., 33., t), 0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdGSzt.jpg", "access": "shaders20k", "license": "artistic-2.0", "functions": [[2110, 2171, 2190, 2190, 2531], [2533, 2533, 2552, 2552, 2684], [2686, 2686, 2725, 2725, 2807], [2809, 2809, 2848, 2848, 2875], [2877, 2877, 2897, 2897, 2921], [2923, 2923, 2942, 2942, 3009], [3011, 3011, 3038, 3038, 3120], [3122, 3122, 3150, 3150, 3240], [3242, 3242, 3279, 3279, 3326], [3328, 3328, 3347, 3347, 3652], [3654, 3654, 3680, 3680, 3821], [3823, 3823, 3870, 3870, 3980], [3982, 3982, 4002, 4002, 4230], [4232, 4232, 4256, 4256, 4511], [4513, 4513, 4530, 4530, 10385], [10387, 10387, 10412, 10412, 10623], [10625, 10625, 10656, 10656, 10910], [10912, 10940, 10975, 10975, 11011], [11013, 11013, 11042, 11042, 11154], [11156, 11156, 11201, 11201, 12877], [12879, 12879, 12900, 12900, 13316], [13318, 13318, 13363, 13363, 13634]]}
{"id": "sdGXWD", "name": " Fab19 #inktober2021 \"loop\"", "author": "FabriceNeyret2", "description": "[url]https://inktober.com/[/url]\n#inktober2021 themes: [img]https://i.imgur.com/QjhAdpd.png[/img]\n\nTry to be smart by tracking the closest samples on 2 different curve segments.\nFourier-series based curves: see https://www.desmos.com/calculator/iej4fjazoe", "tags": ["2d", "short", "fourierseries", "inktober2021"], "likes": 16, "viewed": 218, "published": "Public API", "date": "1634650550", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// --- utils from https://www.shadertoy.com/view/llySRh\n\n#define H(p)     fract( sin( (p) * 78.233 ) * 43758.5453 )\n#define hue(v) ( .6 + .6 * cos( v  + vec4(0,23,21,0)  ) )\n\nfloat line(vec2 p, vec2 a,vec2 b) { \n    p -= a, b -= a;\n    return length( p - b * clamp(dot(p, b) / dot(b, b), 0., 1.) );\n}\n// -----------------------------------------------------------\n\nvec2 f(float t) {                               // curve P(t)\n    vec2 P = vec2(0);\n    for (float f, i = 0.; i < 6.; i++ )         // Fourier series \n        f = exp2(i)*t + 6.283*H(i) + i*iTime,\n        P += vec2(cos(f),sin(f)) / pow(1.4, i); // spectrum 1.4^-f, random phase\n    return P;\n}\n#define D(t)  l = dot( P = f(t) - U, P )        // distance² to curve(t)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, P,\n         U = 2.5*( u+u - R ) / R.y;\n    float l, d0 = 9., d1=d0, T0,T1,t0,t1,e, t=0., dt = .015, dt2 = dt/4.;\n    O-=O;\n    for ( ; t < 6.283; t+=dt )                  // Sample the curve and get the 2 closests\n        D(t),                                   //   that are not on the same segment.\n          l < d0 ?  t<=T0+dt ? d0=l,T0=t        // Prev best was on same segment: don't update 2nd best\n                             : ( d1=d0, T1=T0, d0=l, T0=t ) // independant best: save old as 2nd best\n        : l < d1 && t> T0+dt ? d1=l,T1=t : t;   // update 2nd best only if not on best segment\n        \n    if (iMouse.z > 0.) O += smoothstep(8./R.y, 0., sqrt(min(d0,d1))-.01 ); // test: draw dots\n \n    t0=T0; t1=T1;    \n    for ( t = -dt; t < dt; t += dt2 )           // Look more accurately around 1st and second\n        D(T0+t), l < d0 ? d0=l,  t0=T0+t : t,   //   closest curve segments.\n        D(T1+t), l < d1 ? d1=l,  t1=T1+t : t;\n        \n                           // draw upstream and dowstream segment for 1st and 2nd best\n#define  L(t) smoothstep(  8./R.y, 0.,                      \\\n                           min ( line(U, f(t-dt2), f(t) ),  \\\n                                 line(U, f(t+dt2), f(t) )   \\\n                        ) -.01 )                            \\\n              * hue(t) \n    O += max( L(t0), L(t1) );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdGXWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 175, 210, 210, 300], [301, 365, 382, 426, 658], [734, 734, 772, 772, 2147]]}
{"id": "sdGXWt", "name": "eindacor_bezierwave", "author": "Eindacor_DS", "description": "it's a shader, you dolt!", "tags": ["bezier"], "likes": 2, "viewed": 18, "published": "Public", "date": "1635480772", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TIME_SCALE .5\n#define SEGMENT_COUNT 25\n\n// from https://www.shadertoy.com/view/4djSRW\nfloat hash(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat circleSmoothStepFill(vec2 center, float radius, vec2 p, float antiAlias) {\n\treturn 1.f - smoothstep(radius - antiAlias, radius + antiAlias, distance(center, p));\n}\n\nfloat circleSmoothStep(vec2 center, float radius, float thickness, vec2 p, float antiAlias) {\n    float distFromCenter = distance(center, p);\n    float halfThickness = thickness / 2.f;\n    if (distFromCenter < radius) {\n        return smoothstep(radius - halfThickness - antiAlias, radius - halfThickness + antiAlias, distFromCenter);\n    } else {\n        return 1.f - smoothstep(radius + halfThickness - antiAlias, radius + halfThickness + antiAlias, distFromCenter);\n    }\n}\n\n/*\n\treturns smoothstep value for line segment\n\texample usage:\n\t\toutColor = mix(outColor, lineColor, lineSegmentSmoothStep(start, end, uv, thickness, AA, true));\n*/\nfloat lineSegmentSmoothStep(vec2 start, vec2 end, vec2 p, float lineThickness, float antiAlias, bool roundEnds) {\n    float halfThickness = lineThickness / 2.f;\n    if (dot(p-end, start - end) < 0.f || dot(p - start, end - start) < 0.f) {\n        return !roundEnds ? 0.f : max(\n\t\t\tcircleSmoothStepFill(start, halfThickness, p, antiAlias),\n\t\t\tcircleSmoothStepFill(end, halfThickness, p, antiAlias)\n        );  \n    }\n    \n    vec2 lineVec = normalize(end - start);\n    vec2 pVec = normalize(p - start);\n\n    float angle = acos(dot(lineVec, pVec) / length(lineVec) * length(pVec));\n    float distFromLine = sin(angle) * distance(start, p);\n    \n    return 1.f - smoothstep(lineThickness / 2.f - antiAlias, halfThickness + antiAlias, distFromLine);\n}\n\nfloat getQuadraticBezierSmoothStep(vec2 p0, vec2 p1, vec2 p2, vec2 p3, vec2 uv, int segmentCount, float lineThickness, float aa, bool deriv) {\n    vec2 previousPoint = p0;\n    \n    float val = 0.f;\n    \n    for (int i=0; i<segmentCount; i++) {\n        if (i==0) {\n            continue; // ignore the first segment\n        }\n\n        float t = float(i) / float(segmentCount);\n\n        float tSquared = pow(t, 2.);\n        float tCubed = pow(t, 3.);\n        float p0Val = -tCubed + 3.*tSquared - 3.*t + 1.;\n        float p1Val = 3.*tCubed - 6.*tSquared + 3.*t;\n        float p2Val = -3.*tCubed + 3.*tSquared;\n        float p3Val = tCubed;\n        \n        float p0Deriv = -3.*tSquared + 6.*t - 3.;\n        float p1Deriv = 9.*tSquared - 12.*t + 3.;\n        float p2Deriv = -9.*tSquared + 6.*t;\n        float p3Deriv = 3.*tSquared;\n        \n        vec2 pDeriv = p0 * p0Deriv + p1 * p1Deriv + p2 * p2Deriv + p3 * p3Deriv;\n        \n        vec2 p = p0 * p0Val + p1 * p1Val + p2 * p2Val + p3 * p3Val;\n\n        val = mix(val, 1.0, lineSegmentSmoothStep(previousPoint, p, uv, lineThickness, aa, true));\n\n        previousPoint = deriv ? pDeriv : p;\n    }\n    val = mix(val, 1.0, lineSegmentSmoothStep(previousPoint, p3, uv, lineThickness, aa, true));\n    \n    return val;\n}\n\nfloat getPointSmoothStep(vec2 p, vec2 uv, float radius, float antiAlias) {\n    float pDist = distance(uv, p);\n    return smoothstep(radius + antiAlias, radius - antiAlias, pDist);\n}\n\nfloat normalSin(float sinVal) {\n    return (sinVal + 1.f) / 2.f;\n}\n\nfloat getXVal(float x, float time) {\n    return (time * TIME_SCALE + x) * 2.f;\n}\n\nvec2 getPointFromXVal(float xVal, float time) {\n    float adjustedXVal = getXVal(xVal, time);\n    float hashVal = hash(vec2(floor(adjustedXVal))); \n    return vec2((xVal / 2.) - time, hashVal);\n}\n\nvec2 getPointFromXIndex(float xIndex, float time) {\n    float hashVal = hash(vec2(xIndex)); \n    return vec2((xIndex / 2.) - time, hashVal);\n}\n\nfloat getScreenCoordsFromXVal(float xVal, float time) {\n    return (xVal / 2.) - time * TIME_SCALE;\n}\n\nfloat getYFromXAndTwoPoints(float x, vec2 p0, vec2 p1) {\n    vec2 rightmost = p0.x > p1.x ?  p0 : p1;\n    vec2 leftmost =  p0.x > p1.x ?  p1 : p0;\n    \n    float slope = (rightmost.y - leftmost.y) / (rightmost.x - leftmost.x);\n\n    float deltaX = x - leftmost.x;\n    return slope * deltaX + leftmost.y;\n}\n\nfloat getYFromBezierCurve(float x, vec2 p0, vec2 p1, vec2 p2, vec2 p3, int segmentCount) {\n    vec2 previousPoint = p0;\n    \n    float val = 0.f;\n    \n    for (int i=0; i<segmentCount; i++) {\n        if (i==0) {\n            continue; // ignore the first segment\n        }\n\n        float t = float(i) / float(segmentCount);\n\n        float tSquared = pow(t, 2.);\n        float tCubed = pow(t, 3.);\n        float p0Val = -tCubed + 3.*tSquared - 3.*t + 1.;\n        float p1Val = 3.*tCubed - 6.*tSquared + 3.*t;\n        float p2Val = -3.*tCubed + 3.*tSquared;\n        float p3Val = tCubed;\n        \n        vec2 p = p0 * p0Val + p1 * p1Val + p2 * p2Val + p3 * p3Val;\n        \n        vec2 rightmost = p.x > previousPoint.x ?  p : previousPoint;\n        vec2 leftmost =  p.x > previousPoint.x ?  previousPoint : p;\n        \n        if (x > leftmost.x && x < rightmost.x) {\n            return getYFromXAndTwoPoints(x, p, previousPoint);\n        }\n\n        previousPoint = p;\n    }\n    \n    vec2 rightmost = p3.x > previousPoint.x ?  p3 : previousPoint;\n    vec2 leftmost =  p3.x > previousPoint.x ?  previousPoint : p3;\n\n    if (x > leftmost.x && x < rightmost.x) {\n        return getYFromXAndTwoPoints(x, p3, previousPoint);\n    }\n    \n    // this is prone to bugs but can't pass by ref in shaders so meh\n    return -1.;\n}\n\nfloat getUndulatingVal(float time, float seed) {  \n    float randVal1 = (sin(time * TIME_SCALE + hash(vec2(seed))) + 1.) / 2.;\n    float randVal2 = (sin(time * TIME_SCALE + hash(vec2(seed * -1.))) + 1.) / 2.;\n    float xVal = (time * TIME_SCALE * 2.f) + hash(vec2(seed, 1.));\n    float hashVal = hash(vec2(floor(xVal)));   \n    \n    float nextXValFloor = floor(xVal) + 1.;\n    float nextHashVal = hash(vec2(nextXValFloor));\n    vec2 nextPoint = vec2((nextXValFloor / 2.) - time, nextHashVal);\n    \n    float interpVal = xVal - floor(xVal);\n    \n    float xIndex = floor(xVal);\n    vec2 thisPoint = vec2((xIndex / 2.) - time, hashVal);\n    \n    float indexVal = mod(xIndex, 2.f);\n    \n    float zeroVal = xIndex - floor(indexVal);\n    \n    vec2 p0 = getPointFromXVal(thisPoint.x, time);\n    vec2 p1 = getPointFromXVal(floor(indexVal) + 2., time);\n    vec2 p2 = getPointFromXVal(floor(indexVal) + 2., time);\n    vec2 p3 = getPointFromXVal(floor(indexVal) + 3., time);\n\n    vec2 pn2, pn1;\n    \n    float xIndexAdjustment = indexVal < .99 ? -2. : -3.;\n\n    pn2 = vec2(getScreenCoordsFromXVal(xIndex + xIndexAdjustment, time), hash(vec2(xIndex + xIndexAdjustment)));\n    pn1 = vec2(getScreenCoordsFromXVal(xIndex + xIndexAdjustment + 1., time), hash(vec2(xIndex + xIndexAdjustment + 1.)));\n    p0 = vec2(getScreenCoordsFromXVal(xIndex + xIndexAdjustment + 2., time), hash(vec2(xIndex + xIndexAdjustment + 2.)));\n    p1 = vec2(getScreenCoordsFromXVal(xIndex + xIndexAdjustment + 3., time), hash(vec2(xIndex + xIndexAdjustment + 3.)));\n    p2 = vec2(getScreenCoordsFromXVal(xIndex + xIndexAdjustment + 4., time), hash(vec2(xIndex + xIndexAdjustment + 4.)));\n    p3 = vec2(getScreenCoordsFromXVal(xIndex + xIndexAdjustment + 5., time), hash(vec2(xIndex + xIndexAdjustment + 5.)));\n    \n    vec2 p05 = mix(p0, p1, .5f);\n    vec2 p25 = mix(p2, p3, .5f);\n    \n    vec2 pn15 = mix(pn2, pn1, .5f);\n    \n    p1.x = mix(p05.x, p25.x, .333f);\n    p2.x = mix(p05.x, p25.x, .666f);\n    \n    pn1.x = mix(pn15.x, p05.x, .333f);\n    p0.x = mix(pn15.x, p05.x, .666f);\n    float x = hash(vec2(seed)) * .2;\n    float midY = getYFromBezierCurve(x, p05, p1, p2, p25, SEGMENT_COUNT);\n    \n    if (midY < 0.) {\n        midY = getYFromBezierCurve(x, pn15, pn1, p0, p05, SEGMENT_COUNT);\n    }\n    \n    return midY;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;  \n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.x *= aspectRatio;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(vec3(0.),1.0);\n    \n    float xVal = getXVal(uv.x, iTime);\n    float hashVal = hash(vec2(floor(xVal)));   \n    \n    float nextXValFloor = floor(xVal) + 1.;\n    float nextHashVal = hash(vec2(nextXValFloor));\n    vec2 nextPoint = vec2((nextXValFloor / 2.) - iTime, nextHashVal);\n    \n    float interpVal = xVal - floor(xVal);\n    \n    //fragColor = vec4(vec3(interpVal), 1.f);\n    \n    float xIndex = floor(xVal);\n    vec2 thisPoint = vec2((xIndex / 2.) - iTime, hashVal);\n    \n    float indexVal = mod(xIndex, 2.f);\n    \n    //fragColor = mix(fragColor, vec4(1.f, 0.f, 0.f, 1.f), lineSegmentSmoothStep(thisPoint, nextPoint, uv, .01, .002, true));\n    //fragColor = vec4(vec3(hashVal), 1.f);\n    \n    //fragColor = mix(fragColor, vec4(1.f, 0.f, 0.f, 1.f), getPointSmoothStep(thisPoint, uv, .1, .002));\n    //fragColor = mix(fragColor, vec4(1.f, 0.f, 0.f, 1.f), getPointSmoothStep(nextPoint, uv, .1, .002));\n    \n    //fragColor = mix(fragColor, vec4(1.f, 1.f, 0.f, 1.f), lineSegmentSmoothStep(thisPoint, nextPoint, uv, .01, .002, true));\n    //fragColor = vec4(vec3(hashVal), 1.f);\n    \n    // indexVal is val between 0 and 4\n    // what the indexVal is determines which p point below is p0\n    \n    float zeroVal = xIndex - floor(indexVal);\n    \n    vec2 p0 = getPointFromXVal(thisPoint.x, iTime);\n    vec2 p1 = getPointFromXVal(floor(indexVal) + 2., iTime);\n    vec2 p2 = getPointFromXVal(floor(indexVal) + 2., iTime);\n    vec2 p3 = getPointFromXVal(floor(indexVal) + 3., iTime);\n\n    vec2 pn2, pn1;\n    \n    float xIndexAdjustment = indexVal < .99 ? -2. : -3.;\n    \n    //fragColor = vec4(vec3(indexVal / 2.), 1.f);\n    \n    pn2 = vec2(getScreenCoordsFromXVal(xIndex + xIndexAdjustment, iTime), hash(vec2(xIndex + xIndexAdjustment)));\n    pn1 = vec2(getScreenCoordsFromXVal(xIndex + xIndexAdjustment + 1., iTime), hash(vec2(xIndex + xIndexAdjustment + 1.)));\n    p0 = vec2(getScreenCoordsFromXVal(xIndex + xIndexAdjustment + 2., iTime), hash(vec2(xIndex + xIndexAdjustment + 2.)));\n    p1 = vec2(getScreenCoordsFromXVal(xIndex + xIndexAdjustment + 3., iTime), hash(vec2(xIndex + xIndexAdjustment + 3.)));\n    p2 = vec2(getScreenCoordsFromXVal(xIndex + xIndexAdjustment + 4., iTime), hash(vec2(xIndex + xIndexAdjustment + 4.)));\n    p3 = vec2(getScreenCoordsFromXVal(xIndex + xIndexAdjustment + 5., iTime), hash(vec2(xIndex + xIndexAdjustment + 5.)));\n    \n    vec2 p05 = mix(p0, p1, .5f);\n    vec2 p25 = mix(p2, p3, .5f);\n    \n    vec2 pn15 = mix(pn2, pn1, .5f);\n    \n    p1.x = mix(p05.x, p25.x, .333f);\n    p2.x = mix(p05.x, p25.x, .666f);\n    \n    pn1.x = mix(pn15.x, p05.x, .333f);\n    p0.x = mix(pn15.x, p05.x, .666f);\n    \n    fragColor = mix(fragColor, vec4(vec3(p05.y), 1.f), lineSegmentSmoothStep(vec2(p05.x, 0.), vec2(p05.x, 1.), uv, .005, .002, true));\n    fragColor = mix(fragColor, vec4(vec3(p1.y), 1.f), lineSegmentSmoothStep(vec2(p1.x, 0.), vec2(p1.x, 1.), uv, .005, .002, true));\n    fragColor = mix(fragColor, vec4(vec3(p2.y), 1.f), lineSegmentSmoothStep(vec2(p2.x, 0.), vec2(p2.x, 1.), uv, .005, .002, true));\n    \n    fragColor = mix(fragColor, vec4(1.f, 0.f, 1.f, 1.f), getQuadraticBezierSmoothStep(p05, p1, p2, p25, uv, SEGMENT_COUNT, .02, .002, false));\n    fragColor = mix(fragColor, vec4(1.f, 0.f, 1.f, 1.f), getQuadraticBezierSmoothStep(pn15, pn1, p0, p05, uv, SEGMENT_COUNT, .02, .002, false));\n    //fragColor = mix(fragColor, vec4(1.f, 0.f, 1.f, 1.f), getQuadraticBezierSmoothStep(p05, p1, p2, p25, uv, 15, .002, .002, true));\n    //fragColor = mix(fragColor, vec4(1.f, 0.f, 1.f, 1.f), getQuadraticBezierSmoothStep(pn15, pn1, p0, p05, uv, 15, .002, .002, true));\n    //fragColor = mix(fragColor, vec4(1.f, 0.f, 0.f, 1.f), getPointSmoothStep(p1, uv, .03, .002));\n    //fragColor = mix(fragColor, vec4(0.f, 1.f, 0.f, 1.f), getPointSmoothStep(p2, uv, .03, .002));\n    //fragColor = mix(fragColor, vec4(0.f, 0.f, 1.f, 1.f), getPointSmoothStep(p05, uv, .03, .002));\n    \n    float screenmid = .5 * aspectRatio;\n    float midY = getYFromBezierCurve(screenmid, p05, p1, p2, p25, SEGMENT_COUNT);\n    \n    if (midY < 0.) {\n        midY = getYFromBezierCurve(screenmid, pn15, pn1, p0, p05, SEGMENT_COUNT);\n    }\n    \n    vec2 pBez = vec2(screenmid, midY);\n    fragColor = mix(fragColor, vec4(vec3(midY), 1.f), getPointSmoothStep(pBez, uv, .03, .002));\n    \n    float undulatingX = getUndulatingVal(iTime, .5);\n    float undulatingY = getUndulatingVal(iTime, 200.25);\n    \n    vec2 randPoint = vec2(undulatingX * aspectRatio, undulatingY);\n    \n    fragColor = mix(fragColor, vec4(1.f, 0.2f, .8f, 1.f), getPointSmoothStep(randPoint, uv, .03, .002));\n\n    //fragColor = vec4(vec3(getUndulatingVal(iTime)), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdGXWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 94, 114, 114, 180], [182, 182, 262, 262, 351], [353, 353, 446, 446, 829], [831, 995, 1108, 1108, 1742], [1744, 1744, 1886, 1886, 3008], [3010, 3010, 3084, 3084, 3191], [3193, 3193, 3224, 3224, 3259], [3261, 3261, 3297, 3297, 3341], [3343, 3343, 3390, 3390, 3538], [3540, 3540, 3591, 3591, 3682], [3684, 3684, 3739, 3739, 3785], [3787, 3787, 3843, 3843, 4091], [4093, 4093, 4183, 4183, 5409], [5411, 5411, 5459, 5459, 7697], [7699, 7699, 7756, 7806, 12693]]}
{"id": "sdGXWw", "name": "Predators", "author": "CreaterOS", "description": "predator effect", "tags": ["predator"], "likes": 2, "viewed": 248, "published": "Public", "date": "1634724996", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 heat(float v) {\n    float value = 1.0 - (mod(iTime,2.0) + 0.5) * v;\n    return (0.5+0.5*smoothstep(0.0, 0.1, value))*vec3(\n      \tsmoothstep(0.5, 0.3, value),\n      \tvalue < 0.3 ? smoothstep(0.0, 0.3, value) : smoothstep(1.0, 0.6, value),\n    \tsmoothstep(0.4, 0.6, value)\n\t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float sum = iTimeDelta;\n    vec3 color = texture(iChannel0, uv).rgb;\n    sum += smoothstep(vec4(0.0).z, 0.0, distance(vec4(0.0).xy, uv));\n    float sum1 = iTimeDelta;\n    sum1 += smoothstep(color.z, 0.0, distance(color.xy, uv));\n    fragColor = vec4(mix(heat(sum),heat(sum1),0.5), 1.0);    \n}", "image_inputs": [{"id": "4sf3zn", "previewfilepath": "/presets/webcam.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/webcam.png", "ctype": "webcam"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdGXWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 282], [285, 285, 342, 342, 686]]}
{"id": "sdGXzK", "name": "Angular Distance", "author": "spalmer", "description": "a way to measure distance to points relative to ray cheaply such that you get basically free perspective correction", "tags": ["perspective"], "likes": 3, "viewed": 62, "published": "Public", "date": "1634914245", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// even more primitive idea than \n// AngularSeg from https://shadertoy.com/view/ssyXzy\n// I discovered this little trick first,\n// and only after much banging of my head\n// against the problem did I manage to \n// come up with AngularSeg\n\n// iirc I started with a simple angularly-computed disc\n// then noticed \"hey, I can get perspective correction\n// by removing a sqrt\" and wound up with this!\n\n// view vector d is assumed unit length\n\n//float angularDistance(vec3 d, vec3 a)\n//{\n//\treturn length(cross(d, a));\n//}\n\nfloat angularDistanceSquared(vec3 d, vec3 a)\n{\n    vec3 v = cross(d, a); return dot(v, v);\n}\n\n// going for cosines instead? it's an idea!\n//float angd2(vec3 d, vec3 a)\n//{\n//    return dot(d, a) / length(a);\n//}\n\n/*\n// stole quadratic solver from Orbit Camera just to verify this\nfloat Root(vec3 f) // first zero crossing of polynomial quadric function\n{\n    float dsc = .25 * f.y * f.y - f.x * f.z;\n    if (dsc < 0.) return -1.; // no intersection\n\tfloat d = sqrt(dsc);\n\tif (f.y * f.z < 0.) d = -d;\n\treturn (d - .5 * f.y) / f.z;\n}\n*/\n\n// minimum is not the best operator to use to combine them!\n// ok and that since it's just radial distances, it's not very good for lighting!\n// can maybe fake some rounded appearance by reshaping the distances near 0.\n// or by use of auto derivatives in more clever ways than I know.\n\n// another problem with this technique is that it also projects\n// in the backwards direction; nothing guards against projecting points\n// that are in fact behind the camera, and the length of their cross\n// products are the same.  So what we really need in practice is more of\n// a \"distance squared to ray\" function, instead of \"to infinite line\"\n// so must also limit somehow; getting into clamping line segments is\n// overkill for this toy, but should note that if the dot product\n// of the ray direction w the direction to point is negative, \n// the point is behind the camera and drawing of it should be skipped.\n// That never happens in this toy, or any of these example toys\n// of mine here, so it's not coded.\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    vec2 r = iResolution.xy;\n    vec3 d = normalize(vec3((p - .5*r) / r.y, 1));\n    float n = 5., h = 9e9, k = h, z = .5;\n    for (float i = 1.; i > 0.; i -= 1./n) {\n        vec3 a = vec3(0,0,9) + vec3(3.*sin(vec3(0,11,7) + .3*iTime + vec3(3,4,5) * .1*iTime + 6.*i));\n        //h = min(h, angularDistance(d, a));\n        h = min(h, angularDistanceSquared(d, a));\n        //float l = length(a), s = angularDistanceSquared(d, a);\n        //if (s + l < h + k) h = s, k = l; // TODO combine taking perspective into account - favors closer - needs apparent radius?       \n        //k = max(k, angd2(d, a));\n        \n        // simple sphere intersection to verify perspective\n        //if (Root(vec3(dot(a, a) - 1., -2. * dot(a, d), 1.)) >= 0.) z = 0.; // sure enough!  looks exactly the same\n    }\n    h = sqrt(h); //h *= z + .5; //h = acos(min(1., k)) * 7.;\n    // distance relative to 1.0 = white\n    // visualizes as a linear ramp, gamma close enough\n//    o = vec4(h);\n    o = vec4(pow(max(0., (sqrt(h) - 1.) * .04 * r.y + 1.), .45)); // sharp antialiased edge looks better blended, doesn't exhibit overlapping problems\n}\n\n// trig would even suffice (see acos above) - could work out the sphere with tangents instead,\n// idk how many ways I need to verify the same thing!\n\n// the entire point though is to avoid trigonometric transcendental computations\n\n// I've been using this trick for *years*,\n// I must have discovered this myself at least 10, 15 years ago.\n// But recently someone posted a toy tkasch https://shadertoy.com/view/stc3zN\n// which is based on The Art Of Code youtube tutorial https://youtube.com/watch?v=PBxuVlp7nuM\n// BigWIngs toy https://shadertoy.com/view/4dfBRf\n// BigWIngs simpler toy https://shadertoy.com/view/XdsfW8\n// corresponding video where he explains a bit more about the\n// projection technique, how the math behind it works,\n// which is cool, because it means I don't have to \n// explain cross products to you!  :D\n// https://youtube.com/watch?v=dKA5ZVALOhs\n// This explains the lack of excitement about the\n// technique, everyone here has seen it before!  ;)\n// But I bet nobody did splines with it yet!  haha  https://shadertoy.com/view/flt3Rr", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdGXzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[438, 518, 564, 564, 610], [1340, 2060, 2096, 2096, 3218]]}
{"id": "sdGXzy", "name": "Fab22 #inktober2021 \"open\"", "author": "FabriceNeyret2", "description": "[url]https://inktober.com/[/url]\n#inktober2021 themes: [img]https://i.imgur.com/QjhAdpd.png[/img]\n\nmouse controls camera.    line #18. try l / D distance of opening.\nSome artifacts remaining.", "tags": ["raymarching", "short", "inktober2021"], "likes": 16, "viewed": 210, "published": "Public API", "date": "1634842310", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rot(a)  mat2(cos(a+vec4(0,11,33,0)))                       // rotation\n#define door    max( a.x-1.,max(a.y-2.,a.z-.05))\n\nvoid mainImage(out vec4 O, vec2 U) \n{\n    float t=9.,h=0.,l, T=2.*iTime,d,f,k;                           // d,f,k: hit object id \n    vec3  R = iResolution,\n          D = normalize(vec3((U+U-R.xy)/R.y, -1.5)),               // ray direction\n          p = vec3(0,1,0), q, a,qd,                                // marching point along ray \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(2,.1,0)/1e2*cos(1.3*T+vec3(0,11,0))+vec3(0,.05,0); \n\n    for ( O=vec4(1); O.x > 0. && t > .01; O-=.005 )                // --- draw the sharp cubes\n        q = p,\n        q.yz *= rot(.5-6.3*M.y), \n        q.xz *= rot(-6.3*M.x),\n        q.z -= T, l = floor(q.z/3.+.8)*3.-1.+T,  // ( thanks to spalmer for the debug ! )\n        q.z = mod(q.z+1.8,3.) - 1.8,\n        a = q, a.x++, a.xz *= rot( -2.*smoothstep(-1.,0.,l/3.+.5) ), a.x--, // --- doors\n        qd= a, a = abs(a), t = d = door,\n        t = min(t, k = length(qd - vec3(.8,.1,.1))-.1),            // door knob\n        q.z = abs(q.z)-.02,                                        // --- walls\n        a = abs(q), \n        t = min(t, max( min( q.z, f= q.y+2.),                      // wall+floor\n                       -door ) ),                                  // door hole\n        p += .25*t*D;                                              // step forward = dist to obj\n        \n                                                                   // --- materials\n    O *= t==d ? texture(iChannel2,qd.yx) // vec4(.6,.3,.1,1);      // doors\n       : t==k ? vec4(.7,.6,0,1) + 1e2*pow(.58*(qd.x+qd.y+qd.z),15.)// knob\n       : t==f ? texture(iChannel0,q.xz ) // * vec4(.2,.2,.5,1);    // floor\n       :        texture(iChannel1,q.xy )*.2+.8;                    // walls\n}\n", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdGXzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[129, 129, 166, 166, 1840]]}
{"id": "sdGXzz", "name": "Colored shiny metaballs", "author": "J3r3m13", "description": "Thanks to guspash for the meta ball, ellipse and diamond code", "tags": ["color", "metaball", "breathing"], "likes": 4, "viewed": 55, "published": "Public", "date": "1634243328", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float metaball(vec2 p, vec2 pixel, float r)\n{\n    vec2 d = p-pixel;\n\treturn r / dot(d,d);\n}\nfloat metaDiamond(vec2 p, vec2 pixel, float r)\n{\n    vec2 d = abs(p-pixel);\n\treturn r / (d.x + d.y);\n}\nfloat metaDiamond2(vec2 p, vec2 pixel, float r)\n{\n    vec2 d = abs(p-pixel);\n\treturn r / (d.x + d.y);\n}\nfloat metaEllipsey(vec2 p, vec2 pixel, float r, float xM, float yM)\n{\n    vec2 d = p-pixel;\n    d.x /= xM;\n    d.y /= yM;\n\treturn r / dot(d,d);\n}\nfloat metaEllipsex(vec2 p, vec2 pixel, float r, float xM, float yM)\n{\n    vec2 d = p-pixel;\n    d.x /= yM;\n    d.y /= xM;\n\treturn r / dot(d,d);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tfloat r = metaball(iResolution.xy / 2., fragCoord, 200.);\n    \n\tfloat r1 = metaDiamond(iResolution.xy / 2. + vec2(sin(iTime) * 200.,  0.), fragCoord+cos(.5*iTime)*iResolution.xy / 2., 20.);\n    \n    float r2 = metaDiamond(iResolution.xy / 2. + vec2(0., sin(iTime) * 200.), fragCoord+sin(.7*iTime)*iResolution.xy / 2., 20.);\n    \n    float r5 = metaDiamond(iResolution.xy / 2. + vec2(0., sin(iTime) * 200.), fragCoord+sin(.7*iTime)*vec2(iResolution.y,iResolution.x) / 2., 20.);\n    \n    float r6 = metaDiamond(iResolution.xy / 2. + vec2(sin(iTime) * 200.,0.), fragCoord+cos(.5*iTime)*vec2(iResolution.y,iResolution.x) / 2., 20.);\n    \n\tfloat r3 = metaEllipsey(iResolution.xy / 2. + vec2(0., cos(iTime) * -200.), fragCoord, 50., 1., 5.);\n    \n    float r4 = metaEllipsex(iResolution.xy / 2. + vec2(sin(iTime) * 200.,0.), fragCoord, 50., 1., 5.);\n    \n    fragColor = vec4(vec3((r+r1+r2+r3+r4+r5+r6)*cos(iTime+vec3(0,2,4))), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdGXzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 45, 45, 91], [92, 92, 140, 140, 194], [195, 195, 244, 244, 298], [299, 299, 368, 368, 444], [445, 445, 514, 514, 590], [595, 595, 652, 652, 1588]]}
{"id": "sdKSD3", "name": "-1.253443441-0.384693578i", "author": "Zohnannor", "description": "Mandelbrot Set Zoom at -1.253443441-0.384693578i", "tags": ["mandelbrot"], "likes": 7, "viewed": 80, "published": "Public", "date": "1635435129", "time_retrieved": "2021-10-01T00:00:00", "image_code": "int mandelbrot(vec2 c) {\n    vec2 z = c;\n    for (int i = 0; i < 1500; i++) {\n        if (dot(z, z) > 4.0) return i;\n        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n    }\n    return 0;\n}\n\nfloat zoom(float t) {\n    float a = floor(t/24.0);\n    return 3.0 * (exp(-t+24.0*a) + exp(t-24.0-24.0*a));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 c = (fragCoord.xy * 2.0 - iResolution.xy) * zoom(iTime) / iResolution.x;\n    c += vec2(-1.253443441, 0.384693578);\n    float iters = float(mandelbrot(c));\n    \n    vec3 col = sin(vec3(0.1,0.2,0.5)*float(iters));\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdKSD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 200], [202, 202, 223, 223, 310], [312, 312, 367, 367, 622]]}
{"id": "sdKSDD", "name": "Fractal 89_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 8, "viewed": 137, "published": "Public", "date": "1634686135", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    vec3 p,q,r=iResolution,c=vec3(0),\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));\n    float i=0.,s,e,g=0.,t=iTime;\n    for(;++i<99.;)\n    {\n        p=g*d;\n        p.z-=5.;\n        p=R(p,vec3(.577),t*.2);      \n        q=p;\n        p=vec3(sin(atan(p.x,p.y)*3.1415),length(p.xy)-2.,asin(cos(p.z)));\n        s=2.;\n        for(int i;i++<8;)\n        {\n            p=abs(p)-vec3(1,.3,1.5);\n            s*=e=9./clamp(dot(p,p),.5+sin(t)*.5,8.);\n            p=p*e;\n        }\n        g+=e=max(length(q)-3.5,length(p.xy-clamp(p.xy,-.3,.3))/s);        \n        c+=mix(vec3(1),H(log(s)*.5),.3)*.012*exp(-i*i*e);\n    }\n    c*=c*c*c*c;\n    O=vec4(c,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdKSDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 142, 142, 780]]}
{"id": "sdKSDt", "name": "Another Spiral Test", "author": "SnoopethDuckDuck", "description": "kept adding equations and got to this somehow", "tags": ["e"], "likes": 6, "viewed": 145, "published": "Public API", "date": "1635532983", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat sqLength(vec2 a) {\n    return max(abs(a.x), abs(a.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\n    float sc = 192. / (1. + tanh(-length(uv) + iTime)) / (1. + 8. * length(uv) * (1. + 0.5 * cos(8. * sqLength(uv) + 0.5 * iTime)));\n    vec2 ipos = ceil(sc * uv) - 0.5;\n    vec2 fpos = fract(sc * uv) - 0.5;\n    float id = length(ipos);\n    float fd = length(fpos);\n    \n    float a = atan(ipos.y, ipos.x);\n    \n    float box = sqLength(fpos);\n    box = mix(0.5 - box * box, 0.5 - fd * fd, .5 + .5 * cos(id + iTime));\n    //box = 0.55 - box * box;\n    \n    float k = (1. + sin(id - a - iTime)) * (1. + cos(0.5 * id + iTime)) / (1. + cos(id - a - iTime));\n    float c = 0.8 * box + 0.08 * id + .5 * cos(id - iTime);\n    c *= 0.5 + 0.5 * cos(c);   \n    c *= step(0.2 + k,box) - step(0.3 + k, box);\n\n    vec3 col = pal(0.05 * length(ipos) / c, vec3(0.5), vec3(0.5), vec3(1.5), vec3(0.,0.333,0.666));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdKSDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 68, 68, 111], [113, 113, 137, 137, 175], [177, 177, 234, 234, 1134]]}
{"id": "sdKSRy", "name": "Fork Spiraled L with periodic t", "author": "froggynotacon", "description": "Original author said it looked cool if you inverted time.  Well, what if time was periodic?", "tags": ["3d", "raymarching", "sdf", "spiral", "roll", "rolling"], "likes": 6, "viewed": 87, "published": "Public", "date": "1634865471", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.1415926535\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n#define STEPS 200.0\n#define MDIST 100.0\n\n//some neat animation\n//#define FUN_MODE\n\n//Reverse time\n//#define iTime -iTime\n\n//Change to 2.0 for AA\n#define AA 1.0\n\nvec3 rdg = vec3(0);\nfloat ext(vec3 p, float s, float h){\n  vec2 b = vec2(s,abs(p.y)-h);\n  return min(max(b.x,b.y),0.)+length(max(b,0.));\n}\nfloat h11(float a) {\n    a+=0.65343;\n    return fract(fract(a*a*12.9898)*43758.5453123);\n}\nfloat diplane(vec3 p,vec3 b,vec3 rd){\n    p/=b;\n    vec3 dir = sign(rd)*.5;   \n    vec3 rc = (dir-p)/rd;\n    rc*=b;\n    float dc = rc.z+0.01;\n    return dc;\n}\nfloat lim(float p, float s, float lima, float limb){\n    return p-s*clamp(round(p/s),lima,limb);\n}\nfloat idlim(float p, float s, float lima, float limb){\n    return clamp(round(p/s),lima,limb);\n}\nfloat lim2(float p, float s,  float limb){\n    return p-s*min(round(p/s),limb);\n}\nfloat idlim2(float p, float s, float limb){\n    return min(round(p/s),limb);\n}\nfloat spiral(vec2 p, float t, float m, float scale, float size, float expand){\n    size-=expand-0.01;\n    //Offset Spiral To the left\n    t = max(t,0.);\n    \n    p.x+=pi*-t*(m+m*(-t-1.));\n    t-=0.25;\n    \n    vec2 po = p;\n    //Move Spiral Up\n    p.y+=-t*m-m*0.5;\n    \n    //Counter the rotation\n    p*=rot(t*pi*2.+pi/2.);\n    \n    //Polar Map\n    float theta = atan(p.y,p.x);\n    theta = clamp(theta,-pi,pi);\n    p = vec2(theta,length(p));\n    \n    //Create Spiral\n    p.y+=theta*scale*0.5;\n\n    //Duplicate Line outwards to fill spiral\n    float py = p.y;\n    float id = floor((p.y+m*0.5)/m);\n    p.y = lim(p.y,m,0.,floor(t));\n    \n    //float hel = -(theta+pi)/(2.*pi)+id;\n    \n    //Line SDF of the spiral\n    float a = abs(p.y)-size;\n    \n    //Calcuate moving outer spiral segment\n    p.y = py;\n    p.x -= pi;\n    p.y -= (floor(t)+1.5)*m-m*0.5;\n    float b = max(abs(p.y),abs(p.x)-(pi*2.)*fract(t)+size );\n    \n    //The unrolled Line SDF\n    a = min(a,b-size);\n    b = abs(po.y)-size;\n    b = max(po.x,b);\n    //if(b<a) hel = po.x-(pi*-t*(m+m*(-t-1.))-3.);\n    //else hel*=id;\n    \n    //Combine Them\n    a = min(a,b);\n\n    return a;\n}\nvec3 map(vec3 p){\n    vec2 a = vec2(1);\n    vec2 b = vec2(1);\n    float c = 0.;\n    float t = 10. * -sin(0.5*iTime)*sin(-iTime)*sin(iTime);\n\n    float size = 0.062; //Thickness of spiral curls\n    float scale = size-0.01 ; //Space between spiral curls\n    \n    float expand = 0.04; //Corner Rounding Amount \n\n    float m2 = size*6.0; //Repetition Sizes\n    float m = pi*scale; //Repetition Sizes\n    \n    float ltime = 10.; //How often the spirals rolls repeat\n    \n    //Move everything upwards so it stays in frame\n    p.y-=(t/ltime)*size*6.;\n    \n    //small offset for framing\n    p.x-=3.; \n    \n    float width = 0.5; //Lane Width\n    float count = 6.; //Number of spirals (x2)\n    \n    float modwidth = width*2.0+0.04+0.06;\n    \n    float id3 = idlim(p.z,modwidth,-count,count);\n    t+=h11(id3*0.76)*8.0;\n    p.z = lim(p.z,modwidth,-count,count);\n    \n    #ifdef FUN_MODE\n        scale+=(sin(t)*0.5+0.5)*0.05;\n        m = pi*scale;\n    #endif\n    \n    float to = t;\n    vec3 po = p;\n\n    //float id = 0.;\n\n    //Spiral 1\n    float stack = -floor(t/ltime);\n    float id2 = idlim2(p.y,m2,stack);\n    t+=id2*ltime;\n    p.y = lim2(p.y,m2,stack);\n    a.x = spiral(p.xy,t,m,scale,size,expand);\n    //a.y = id2*3.-2.;\n    c = a.x;\n    a.x = min(a.x,max(p.y+size*5.,p.x));//Artifact Removal\n    \n    //Spiral 2\n    p = po;\n    t = to;\n    p.y+=size*2.0;\n    t-=ltime/3.0;\n    stack = -floor(t/ltime);\n    id2 = idlim2(p.y,m2,stack);\n    t+=id2*ltime;\n    p.y = lim2(p.y,m2,stack);\n    \n    b.x = spiral(p.xy,t,m,scale,size,expand);\n    //b.y = id2*3.-1.;\n    c = min(c,b.x);\n    a=(a.x<b.x)?a:b;\n    a.x = min(a.x,max(p.y+size*5.,p.x));//Artifact Removal\n    \n    //Spiral 3\n    p = po;\n    t = to;\n    p.y+=size*4.0;\n    t-=2.*ltime/3.0;\n    stack = -floor(t/ltime);\n    id2 = idlim2(p.y,m2,stack);    \n    t+=id2*ltime;\n    p.y = lim2(p.y,m2,stack);\n    b.x = spiral(p.xy,t,m,scale,size,expand);\n    //b.y = id2*3.;\n    c = min(c,b.x);\n    a=(a.x<b.x)?a:b;\n    a.x = min(a.x,max(p.y+size*5.,p.x)); //Artifact Removal\n    \n    \n    a.x = ext(po.yzx,a.x,width-expand*0.5+0.02)-expand;\n    c = ext(po.yzx,c,width-expand*0.5+0.02)-expand;\n    \n    //Intersection distance to plane between each lane\n    b.x = diplane(po ,vec3(modwidth), rdg); //Artifact Removal\n    b.y = 0.;\n    \n    //a.y-=10.0;\n    //a.y+=h11(id3);\n    \n    a=(a.x<b.x)?a:b; //Artifact Removal\n    \n    return vec3(a,c);\n}\nvec3 norm(vec3 p){\n    vec2 e = vec2(0.01,0);\n    return normalize(map(p).x-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\nvoid render( out vec4 fragColor,in vec2 fragCoord){\n\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    float t = iTime;\n    float px = 8./iResolution.y;\n    vec3 col = vec3(0);\n\n    vec3 ro = vec3(5,1.8,-12)*1.2;\n    ro.zx*=rot(0.09);\n    \n    //Mouse control\n    if(iMouse.z>0.5){\n    ro.yz*=rot(0.5*(iMouse.y/iResolution.y-0.5));\n    ro.zx*=rot(-0.5*(iMouse.x/iResolution.x-0.5));\n    }\n    //Camera Setup\n    vec3 lk = vec3(-2.5,0.,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = normalize(f*2.0+uv.x*r+uv.y*cross(f,r));  \n    rdg = rd;\n\n    vec3 p = ro;\n    vec3 d;\n    float dO = 0.;\n    bool hit = false;\n    \n    //Raymarcher\n    for(float i = 0.; i<STEPS; i++){\n        p = ro+rd*dO;\n        d = map(p);\n        dO+=d.x;\n        if(d.x<0.001||i==STEPS-1.0){\n            hit = true;\n            break;\n        }\n        if(dO>MDIST){\n            dO = MDIST;\n            break;\n        }\n    }\n    //Color Surface\n    if(hit&&d.y!=0.){\n        vec3 ld = normalize(vec3(0.5,0.4,0.9));\n        vec3 n = norm(p);\n        vec3 r = reflect(rd,n);\n        rdg = ld;\n        float shadow = 1.;\n        for(float h = 0.09; h<7.0;){\n            vec3 dd = map(p+ld*h+n*0.005);\n            if(dd.x<0.001&&dd.y==0.0){break;}\n            if(dd.x<0.001){shadow = 0.0; break;}\n            shadow = min(shadow,dd.z*30.0);\n            h+=dd.x;\n        }\n        shadow = max(shadow,0.8);\n\n        #define AO(a,n,p) smoothstep(-a,a,map(p+n*a).z)\n        float ao = AO(0.05,n,p)*AO(.1,n,p);\n        ao = max(ao,0.1);\n        n.xz*=rot(4.*pi/3.);\n        col = n*0.5+0.5;\n        col = col*shadow;\n        col*=ao;\n\n    }\n    //Color Background\n    else{\n        col = mix(vec3(0.355,0.129,0.894),vec3(0.278,0.953,1.000),clamp((rd.y+0.05)*2.0,-0.15,1.5));\n    }\n    //Gamma Approximation\n    col = sqrt(col);\n    fragColor = vec4(col,1.0);  \n}\n\n//External AA (check render function for usual code)\n#define ZERO min(0.0,iTime)\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    float px = 1.0/AA; vec4 col = vec4(0);\n    if(AA==1.0) {render(col,fragCoord); fragColor = col; return;}\n    for(float i = ZERO; i <AA; i++){\n        for(float j = ZERO; j <AA; j++){\n            vec4 col2;\n            vec2 coord = vec2(fragCoord.x+px*i,fragCoord.y+px*j);\n            render(col2,coord);\n            col.rgb+=col2.rgb;\n        }\n    }\n    col/=AA*AA;\n    fragColor = vec4(col);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdKSRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[197, 256, 292, 292, 374], [375, 375, 395, 395, 465], [466, 466, 503, 503, 624], [625, 625, 677, 677, 723], [724, 724, 778, 778, 820], [821, 821, 863, 863, 902], [903, 903, 946, 946, 981], [982, 982, 1060, 1060, 2125], [2126, 2126, 2143, 2143, 4514], [4515, 4515, 4533, 4533, 4660], [4661, 4661, 4712, 4712, 6551], [6553, 6634, 6688, 6688, 7088]]}
{"id": "sdKXRV", "name": "ranbow_line_translate", "author": "yyf1994", "description": "ranbow_line_translate", "tags": ["ranbowlinetranslate"], "likes": 0, "viewed": 32, "published": "Public", "date": "1634954853", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float len = 0.46;\n    float PI = 3.14;\n    float offset = 0.4;\n    \n    if(uv.y>offset && uv.y<offset + len  ){\n         fragColor = vec4(.5*cos(6.283*(uv.x + iTime  +vec3(0.,-.33333,.33333)))+.5,1.0);\n         float x = uv.y-offset;\n         \n         float aa = sin(  x * PI/len  )  ;\n         \n         vec4 vv = vec4(aa ,aa,aa,0  );\n         \n         fragColor += vv;\n\n    }else{\n    \n             fragColor = vec4( 0.0 ,0.0 ,0.0,1.0);\n\n\n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdKXRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 59, 59, 561]]}
{"id": "sdKXW1", "name": "blocknote", "author": "4eckme", "description": "abc", "tags": ["text", "white", "black"], "likes": 14, "viewed": 463, "published": "Public", "date": "1634591040", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 c,in vec2 o)/*code*/{\no=vec2(floor(o/2.0));float r=o.x*o.x+o.y*o.y;\nc=vec4(ceil(sin(r+iTime)*4.0)+mod(o.y,8.0));}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdKXW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 45, 45, 137]]}
{"id": "sdKXzK", "name": "Trippy animation.", "author": "mvaios", "description": "Trippy shader effect", "tags": ["grid", "colors", "effect", "fx", "trippy"], "likes": 1, "viewed": 130, "published": "Public API", "date": "1634952620", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Original idea from this video with a great explenation of how this works: https://www.youtube.com/watch?v=cQXAbndD5CQ\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord.xy-iResolution.xy*.5)/iResolution.y;\n\t\n    uv *= mat2(.707, -.707, .707, .707);\n    uv *= 8. * (sin(iTime * .1) * .4 + 1.4);\n    \n    vec2 gv = fract(uv)-.5; \n\tvec2 id = floor(uv);\n    \n\tfloat m = 0.;\n    float t;\n    for(float y=-1.; y<=1.; y++) {\n    \tfor(float x=-1.; x<=1.; x++) {\n            vec2 offs = vec2(x, y);\n            \n            t = -iTime*.32+length(id-offs)*.42;\n            float r = mix(.4, 1.5, sin(t)*.5+.5);\n    \t\tfloat c = smoothstep(r, r*.99, length(gv+offs));\n    \t\tm = m*(1.-c) + c*(1.-m);\n        }\n    }\n    \n    float mult = sin(iTime) * 0.25 + 1.4;\n    float modBase = uv.x * uv.y;\n    fragColor = vec4(m * mod(modBase, mult * 1.3), m * mod(modBase * 2.3, (mult + 1.) / 1.3), m * mod(modBase, mult), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdKXzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 123, 180, 180, 945]]}
{"id": "sdtSRM", "name": "BB8 Camera Filter", "author": "ChutneyPot", "description": "Everyone in my meetings has a cool camera filter/background. So decided to make one for myself!", "tags": ["camera", "droid", "starwars", "bb8"], "likes": 9, "viewed": 220, "published": "Public", "date": "1634094031", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// BB8 Camera Filter, October 2021\n// by Tito Morab - ChutneyPot\n// https://www.shadertoy.com/view/sdtSRM\n//--------------------------------------------------------------------------\n#define BG1 vec4(0.96, 0.84, 0.55, 1.0)\n#define BG2 vec4(0.55, 0.35, 0.24, 1.0)\n#define BODY1 vec4(0.81, 0.79, 0.71, 1.0)\n#define BODY2 vec4(0.45, 0.42, 0.41, 1.0)\n#define BODY3 vec4(0.88, 0.49, 0.27, 1.0)\n#define BODY4 vec4(0.05, 0.05, 0.2, 1)\n#define BODY5 vec4(0.35, 0.32, 0.31, 1.0)\n#define BODY6 vec4(1.0, 0.92, 0.43, 1.0)\n#define OUTLINE vec4(0.18, 0.02, 0.07, 1.0)\n#define SCREEN vec4(0.0, 0.0, 0.1, 1.0)\n#define GREYSCALE vec3(0.3, 0.59, 0.11)\n\n#define ss(a, b, x) smoothstep(a, b, x)\n#define BLUR 4.0 / iResolution.y\n\n//https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat circle(in vec2 uv, float r)\n{\n    return length(uv) - r;\n}\n\nfloat box(in vec2 uv, in vec2 s)\n{\n    vec2 d = abs(uv) - s;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat line(in vec2 uv, in vec2 a, in vec2 b)\n{\n    vec2 pa = uv - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nfloat parallelogram(in vec2 uv, float wd, float ht, float sk)\n{\n    vec2 e = vec2(sk, ht);\n    uv = (uv.y < 0.0) ? -uv : uv;\n    vec2 w = uv - e; \n    w.x -= clamp(w.x, -wd, wd);\n    vec2 d = vec2(dot(w, w), -w.y);\n    float s = uv.x * e.y - uv.y * e.x;\n    uv = (s < 0.0) ? -uv : uv;\n    vec2 v = uv - vec2(wd, 0); \n    v -= e * clamp(dot(v, e) / dot(e, e), -1.0, 1.0);\n    d = min(d, vec2(dot(v, v), wd * ht - abs(s)));\n    return sqrt(d.x) * sign(-d.y);\n}\n\nvec2 rotate(in vec2 uv, float d)\n{\n    float rad = radians(d);\n    return uv * mat2(cos(rad), sin(rad), -sin(rad), cos(rad));\n}\n\nvec4 camera(in vec2 uv)\n{\n    float feed = dot(texture(iChannel0, uv * 1.6 - vec2(0.25, 0.37)).xyz, GREYSCALE);\n    \n    uv *= 4.0;\n    float l1 = step(fract(uv.y + iTime * 0.2), 0.005);\n    \n    uv *= 50.0;\n    float l2 = step(fract(uv.y + iTime * 0.7), 0.5);\n    \n    uv /= 200.0;\n    uv -=0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    float c = smoothstep(0.35, 0.2, length(uv));\n    \n    return vec4(mix(0.0, feed, (l1 + l2) * c)) + SCREEN; \n}\n\nvec4 bb8(in vec2 uv, in vec2 cuv)\n{\n    uv = rotate(uv, sin(iTime * 0.2) + sin(iTime * 0.4));\n    \n    //Head\n    float uo1 = ss(0.0, 0.0 - BLUR, circle((uv - vec2(0, -0.6)) * vec2(0.55, 0.66), 0.96));\n    float uo2 = ss(0.0, 0.0 - BLUR, circle(uv - vec2(0, -12.0), 11.06));\n    float uo = uo1 - min(uo1, uo2);\n    float ui1 = ss(0.0, 0.0 - BLUR, circle((uv - vec2(0.01, -0.61)) * vec2(0.55, 0.66), 0.95));\n    float ui2 = ss(0.0, 0.0 - BLUR, circle(uv - vec2(0.05, -11.997), 11.07));\n    float ui = ui1 - min(ui1, ui2);\n    \n    //Bottom bar\n    float bbo1 = ss(0.0, 0.0 - BLUR, circle(uv - vec2(0, -12.0), 11.26));\n    float bbo = min(uo, bbo1);\n    float bbi1 = ss(0.0, 0.0 - BLUR, circle(uv - vec2(-0.05, -12.0), 11.248));\n    float bbi = min(ui, bbi1);\n    \n    //Top bar\n    float tbo1 = ss(0.0, 0.0 - BLUR, circle(uv - vec2(0.2, -10.56), 11.26));\n    float tbo = uo - min(uo, tbo1);\n    float tbi1 = ss(0.0, 0.0 - BLUR, circle(uv - vec2(0.2, -10.56), 11.27));\n    float tbi = ui - min(ui, tbi1);\n    float tl1 = ss(0.01, 0.01 - BLUR, line(uv, vec2(0.4, 0.71), vec2(0.4, 0.79)));\n    float tl2 = ss(0.008, 0.008 - BLUR, line(uv, vec2(0.15, 0.71), vec2(0.15, 0.82)));\n    float tl3 = ss(0.01, 0.01 - BLUR, line(uv, vec2(-0.15, 0.7), vec2(-0.15, 0.82)));\n    float tl4 = ss(0.008, 0.008 - BLUR, line(uv, vec2(-0.4, 0.69), vec2(-0.4, 0.79)));\n    float tl = max(max(max(tl1, tl2), tl3), tl4);\n    \n    //Side bars\n    float sbro = ss(0.0, 0.0 - BLUR, parallelogram(uv - vec2(0.905, 0.45), 0.28, 0.1, -0.12));\n    float sbri = ss(0.0, 0.0 - BLUR, parallelogram(uv - vec2(0.905, 0.45), 0.26, 0.09, -0.12));\n    float sblo = ss(0.0, 0.0 - BLUR, parallelogram(rotate(uv - vec2(-0.95, 0.4), 5.5), 0.32, 0.1, 0.12));\n    float sbli = ss(0.0, 0.0 - BLUR, parallelogram(rotate(uv - vec2(-0.95, 0.4), 5.5), 0.3, 0.09, 0.11));\n    \n    //Centre\n    float cco = ss(0.0, 0.0 - BLUR, circle(uv - vec2(0, 0.08), 0.57));\n    float cbo = ss(0.0, 0.0 - BLUR, box(uv - vec2(-0.28, -0.2), vec2(0.29, 0.29)));\n    float co = max(cco, cbo);\n    float cci = ss(0.0, 0.0 - BLUR, circle(uv - vec2(0, 0.08), 0.555));\n    float cbi = ss(0.0, 0.0 - BLUR, box(rotate(uv, 0.5) - vec2(-0.28, -0.2), vec2(0.275, 0.275)));\n    float ci = max(cci, cbi);\n    float cc = ss(0.0, 0.0 - BLUR, circle(uv - vec2(0, 0.08), 0.54));\n    float c = ss(0.0, 0.0 - BLUR, circle(uv - vec2(0, 0.08), 0.51));\n    float clb = ss(0.0, 0.0 - BLUR, abs(box(uv - vec2(-0.82, -0.352), vec2(0.25, 0.12)) - 0.01) - 0.008);\n    float cll = ss(0.011, 0.011 - BLUR, line(uv, vec2(-0.557, -0.8), vec2(-0.557, -0.4)));\n    float cl = max(clb, cll);\n    float crtbo = ss(0.0, 0.0 - BLUR, box(uv - vec2(0.58, -0.4), vec2(0.3, 0.4)) - 0.1);\n    float crbbo = ss(0.0, 0.0 - BLUR, box(uv - vec2(1.1, -0.6), vec2(0.2, 0.3)));\n    float crco = ss(0.0, 0.0 - BLUR, circle(uv - vec2(0.9, -0.3), 0.4));\n    float cro = max(max(crbbo, crtbo - min(cco, crtbo)), crco);\n    float crtbi = ss(0.0, 0.0 - BLUR, box(uv - vec2(0.58, -0.4), vec2(0.29, 0.39)) - 0.1);\n    float crbbi = ss(0.0, 0.0 - BLUR, box(uv - vec2(1.1, -0.6), vec2(0.19, 0.3)));\n    float crci = ss(0.0, 0.0 - BLUR, circle(uv - vec2(0.9, -0.3), 0.39));\n    float cri = max(max(crbbi, crtbi - min(cco, crtbi)), crci);\n    float csr = ss(0.0, 0.0 - BLUR, abs(circle(uv - vec2(0.9, -0.3), 0.3)) - 0.03);\n    float csc = ss(0.0, 0.0 - BLUR, circle(uv - vec2(0.9, -0.3), 0.25));\n    float csci = ss(0.0, 0.0 - BLUR, circle(uv - vec2(0.9, -0.3), 0.2));\n    float cscr = ss(0.02, 0.017 - BLUR, parallelogram(uv - vec2(0.82, -0.22), 0.01, 0.01, 0.01));\n    float ccr = ss(0.02, 0.017 - BLUR, parallelogram(uv - vec2(-0.25, 0.35), 0.01, 0.01, 0.01));\n    \n    //Bottom panels\n    float brpo1 = ss(0.0, 0.0 - BLUR, box(uv - vec2(1.1, -0.76), vec2(0.06, 0.07)));\n    float brpi1 = ss(0.0, 0.0 - BLUR, box(uv - vec2(1.1, -0.76), vec2(0.05, 0.06)));\n    float brpo2 = ss(0.0, 0.0 - BLUR, box(uv - vec2(1.435, -0.76), vec2(0.15, 0.15)));\n    float brpi2 = ss(0.0, 0.0 - BLUR, box(uv - vec2(1.435, -0.76), vec2(0.14, 0.14)));\n    float brp = max(brpo1, brpo2);\n    float brpi = max(brpo1 - brpi1, brpo2 - brpi2);\n    float bco = ss(0.0, 0.0 - BLUR, abs(circle(uv - vec2(0, -0.615), 0.1)) - 0.01);\n    float bci = ss(0.0, 0.0 - BLUR, circle(uv - vec2(0, -0.615), 0.08));\n    float blpo1 = ss(0.0, 0.0 - BLUR, box(uv - vec2(-0.6, -0.63), vec2(0.05, 0.15)));\n    float blpi1 = ss(0.0, 0.0 - BLUR, box(uv - vec2(-0.6, -0.63), vec2(0.04, 0.14)));\n    float blpo2 = ss(0.0, 0.0 - BLUR, box(uv - vec2(-1.35, -0.72), vec2(0.27, 0.15)));\n    float blpi2 = ss(0.0, 0.0 - BLUR, box(uv - vec2(-1.35, -0.72), vec2(0.26, 0.14)));\n    float blp = max(blpo1, blpo2);\n    float blpi = max(blpo1 - blpi1, blpo2 - blpi2);\n    float blplo1 = ss(0.0, 0.0 - BLUR, box(uv - vec2(-1.2, -0.65), vec2(0.08, 0.03)));\n    float blpli1 = ss(0.0, 0.0 - BLUR, box(uv - vec2(-1.2, -0.65), vec2(0.07, 0.02)));\n    float blplo2 = ss(0.0, 0.0 - BLUR, box(uv - vec2(-1.2, -0.75), vec2(0.08, 0.03)));\n    float blpli2 = ss(0.0, 0.0 - BLUR, box(uv - vec2(-1.2, -0.75), vec2(0.07, 0.02)));\n    float blpl = max(blplo1, blplo2);\n    float blpli = max(blplo1 - blpli1, blplo2 - blpli2);\n    float blb = ss(0.007, 0.007 - BLUR, line(uv, vec2(-0.19, 0.94), vec2(-0.21, 0.93)));\n    \n    //Antennae\n    float abro = ss(0.0, 0.0 - BLUR, box(uv - vec2(0.15, 0.87), vec2(0.04, 0.04)));\n    float abri = ss(0.0, 0.0 - BLUR, box(uv - vec2(0.15, 0.87), vec2(0.03, 0.03)));\n    float atro = ss(0.0, 0.0 - BLUR, box(uv - vec2(0.15, 1.0), vec2(0.02, 0.1)));\n    float atri = ss(0.0, 0.0 - BLUR, box(uv - vec2(0.15, 1.0), vec2(0.01, 0.09)));\n    float alo = ss(0.0, 0.0 - BLUR, box(uv - vec2(-0.2, 0.92), vec2(0.025, 0.1)));\n    float ali = ss(0.0, 0.0 - BLUR, box(rotate(uv - vec2(-0.201, 0.92), 1.5), vec2(0.015, 0.09)));\n    float ald1 = ss(0.007, 0.007 - BLUR, line(uv, vec2(-0.19, 0.94), vec2(-0.21, 0.93)));\n    float ald2 = ss(0.007, 0.007 - BLUR, line(uv, vec2(-0.19, 0.9), vec2(-0.21, 0.89)));\n    float ald = max(ald1, ald2);\n    \n    vec4 col = vec4(0);\n    col = mix(col, OUTLINE, uo1);\n    col = mix(col, BODY1, uo);  \n    col = mix(col, BODY3, sbro);\n    col = mix(col, BODY3, sblo);\n    col = mix(col, BODY2, abro);\n    col = mix(col, BODY1, atro);\n    col = mix(col, BODY1, alo);\n    col = mix(col, BODY4, cc);    \n    col = mix(col, OUTLINE, sbro - sbri);\n    col = mix(col, OUTLINE, sblo - sbli);\n    col = mix(col, OUTLINE, abro - abri);\n    col = mix(col, OUTLINE, atro - atri);\n    col = mix(col, OUTLINE, alo - ali);\n    col = mix(col, OUTLINE, ald);\n    col = mix(col, OUTLINE, co - ci);\n    col = mix(col, OUTLINE, cl);\n    col = mix(col, OUTLINE, cro - cri);\n    col = mix(col, OUTLINE, csc);\n    col = mix(col, BODY4, csci);\n    col = mix(col, BODY5, csr);\n    col = mix(col, BODY3, brp);\n    col = mix(col, BODY3, blp);\n    col = mix(col, mix(BODY6, BODY2, round(sin(iTime) * 0.5 + 0.5)), blplo1);\n    col = mix(col, mix(BODY2, BODY6, round(sin(iTime) * 0.5 + 0.5)), blplo2);\n    col = mix(col, BODY5, bci);\n    col = mix(col, OUTLINE, brpi);\n    col = mix(col, OUTLINE, blpi);\n    col = mix(col, OUTLINE, blpli);\n    col = mix(col, OUTLINE, bco);\n    col = mix(col, BODY2, bbo);\n    col = mix(col, BODY2, tbo);\n    col = mix(col, OUTLINE, tl);\n    col = mix(col, OUTLINE, uo1 - ui);\n    col = mix(col, OUTLINE, bbo - bbi);\n    col = mix(col, OUTLINE, tbo - tbi);    \n    col = mix(col, camera(cuv), c);\n    col = mix(col, vec4(1), max(ccr, cscr));\n        \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    vec4 col = vec4(0);\n    col = mix(BG2, BG1, uv.y * 0.5 + 0.5);\n    \n    vec4 bb8 = bb8(uv, fragCoord / iResolution.xy); \n    col = mix(col, bb8, bb8.w);\n       \n    fragColor = col;\n}", "image_inputs": [{"id": "4sf3zn", "previewfilepath": "/presets/webcam.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/webcam.png", "ctype": "webcam"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdtSRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[710, 784, 819, 819, 848], [850, 850, 884, 884, 970], [972, 972, 1018, 1018, 1144], [1146, 1146, 1209, 1209, 1604], [1606, 1606, 1640, 1640, 1733], [1735, 1735, 1760, 1760, 2188], [2190, 2190, 2225, 2225, 9616], [9618, 9618, 9673, 9673, 9932]]}
{"id": "sdtSWB", "name": "Spinning Morphing Shapes", "author": "LoganLang", "description": "Look at em go", "tags": ["2d", "sdf", "translate"], "likes": 4, "viewed": 39, "published": "Public", "date": "1633895198", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159;\nconst vec3 sunglow = vec3(255., 202., 58.)/255.;\nconst vec3 skyBlue = vec3(76., 201., 240.)/255.;\nconst vec3 royalBlue = vec3(73., 109., 219.)/255.;\nconst vec3 rubineRed = vec3(202., 46., 85.)/255.;\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat stroke(float x, float w){\n    float d = smoothstep(0.,.01,x+w*.5) - smoothstep(0.,.01,x-w*.5);\n    return clamp(d,0.,1.);\n}\n\nfloat fill(float sdf){\n    return 1.-smoothstep(0.,.025,sdf);\n}\n\nfloat mixedSDF(vec2 st, vec2 pos){\n    float circleSDF = sdCircle(st-pos,.2);\n    float triSDF = sdTriangleIsosceles((st-vec2(0.,.2))-pos,vec2(.2,-.4));\n    float squareSDF = sdBox(st-pos,vec2(.2));\n    \n    float circleTimer = smoothstep(.1,.9,sin(iTime));\n    float triTimer = smoothstep(.1,.9,sin(iTime-2.1));\n    float squareTimer = smoothstep(.1,.9,sin(iTime-4.2));\n    \n    float mixSDF = 0.;\n    mixSDF += mix(0.,circleSDF,circleTimer);\n    mixSDF += mix(0.,triSDF,triTimer);\n    mixSDF += mix(0.,squareSDF,squareTimer);\n    \n    return mixSDF;\n}\n\nvec2 offset(float x){\n    return vec2(cos(iTime - x),sin(iTime - x))*.8;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.);\n    vec2 st = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    float bgCircle = sdCircle(st,.8);\n    float bgSquare = sdBox(st,vec2(.8));\n    float sinLine = st.y + .25*sin((st.x*2.*PI)/1.6);\n    \n    col += fill(bgSquare)*skyBlue*step(0.,sinLine);\n    col += fill(bgSquare)*royalBlue*step(0.,-sinLine);\n    if (bgCircle < 0. && sinLine > 0.) {\n        col = royalBlue;\n    } else if (bgCircle < 0. && sinLine < 0.) {\n        col = skyBlue;\n    }\n    \n    float bgShape = stroke(bgCircle,.025);\n    bgShape += stroke(bgSquare,.025);\n    bgShape += stroke(sinLine, .025) * fill(sdBox(st,vec2(.802)));\n    col *= 1.-bgShape;\n    col += clamp(bgShape,0.,1.) * sunglow;\n    if (bgShape > .7) {\n        col = sunglow;\n    }\n\n    float movingShapes = stroke(mixedSDF(st,offset(0.)),.05);\n    movingShapes += stroke(mixedSDF(st,offset(2.*PI / 3.)),.05);\n    movingShapes += stroke(mixedSDF(st,offset(4.*PI / 3.)),.05);\n    col = mix(col, rubineRed, movingShapes);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdtSWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[226, 226, 261, 261, 289], [291, 291, 342, 342, 650], [652, 652, 689, 689, 769], [771, 771, 802, 802, 900], [902, 902, 924, 924, 965], [967, 967, 1001, 1001, 1520], [1522, 1522, 1543, 1543, 1596], [1598, 1598, 1655, 1655, 2677]]}
{"id": "sdtXDB", "name": "Jumping blobs", "author": "ninofiliu", "description": "The scene consists in one plane, one sphere at the center, and 5 spheres orbiting around it. The distance from a point to the scene is pretty easy to compute, but I added the twist of smoothing the min function so that objects blur one into another.", "tags": ["3d", "raymarching", "smoothmin", "smoothmax", "directionallight"], "likes": 3, "viewed": 187, "published": "Public API", "date": "1633905330", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_STEPS = 100;\nconst float MIN_DISTANCE = 0.0001;\nconst float MAX_DISTANCE = 50.0;\nconst float EPSILON_NORMAL = 0.01;\n    \nvec3 getRay(vec2 fragCoord, vec3 camera, vec3 lookAt) {\n    const float zoom = 1.5;\n    vec2 uv = (fragCoord - (iResolution.xy / 2.0)) / iResolution.y;\n    vec3 c = normalize(lookAt - camera);\n    vec3 u = vec3(c.y, -c.x, 0.0);\n    vec3 v = normalize(vec3(c.z*c.x, c.z*c.y, c.x*c.x+c.y*c.y));\n    return normalize(c + (uv.x * u + uv.y * v) / zoom);\n}\n\nbool isInSphere(vec3 camera, vec3 ray, vec3 center, float radius) {\n    float d = distance(camera, center);\n    float dp = dot(ray, center-camera);\n    return dp*dp > d*d-radius*radius;\n}\n\nfloat getDS(vec3 marcher) {\n    const int len = 7;\n    const float a = 3.0;\n    \n    float mins[len];\n    \n    mins[0] = marcher.z;\n    mins[1] = distance(marcher, vec3(0.0, 0.0, 0.7)) - 1.0;\n    int nb = len - 2;\n    for (int i = 0; i < len-2; i++) {\n        float angle = radians(270.0 * float(i) / float(nb));\n        vec3 center = vec3(cos(angle), sin(angle), 0.5+1.0*sin(3.0*iTime+float(i)));\n        mins[2+i] = distance(marcher, center) - 0.7;\n    }\n    \n    float sa = 0.0;\n    float sb = 0.0;\n    for (int i = 0; i < len; i++) {\n        sa += mins[i] * exp(-a * mins[i]);\n        sb += exp(-a * mins[i]);\n    }\n    \n    return sa / sb;\n}\n\nvec3 march(vec3 camera, vec3 ray) {\n    vec3 marcher = camera;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float ds = getDS(marcher);\n        if (ds < MIN_DISTANCE || ds > MAX_DISTANCE) { break; }\n        marcher += ds * ray;\n    }\n    return marcher;\n}\n\nvec3 getNormal(vec3 camera, vec3 ray) {\n    vec3 surface = march(camera, ray);\n    float dx = getDS(surface+vec3(EPSILON_NORMAL, 0.0, 0.0));\n    float dy = getDS(surface+vec3(0.0, EPSILON_NORMAL, 0.0));\n    float dz = getDS(surface+vec3(0.0, 0.0, EPSILON_NORMAL));\n    return normalize(vec3(dx, dy, dz));\n}\n\nfloat getLight(vec3 camera, vec3 ray) {\n    vec3 source = vec3(4.0, 0.0, 5.0);\n    vec3 surface = march(camera, ray);\n    vec3 normal = getNormal(camera, ray);\n    return -dot(normal, normalize(surface-source));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float speed = 0.7;\n    vec3 camera = vec3(5.0 * vec2(cos(speed*iTime), sin(speed*iTime)), 1.0);\n    vec3 lookAt = vec3(0.0, 0.0, 0.5);\n    vec3 ray = getRay(fragCoord, camera, lookAt);\n    \n    fragColor = vec4(vec3(0.0), 1.0);\n    fragColor.rgb += 0.5+0.5*getLight(camera, ray);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdtXDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[135, 135, 190, 190, 485], [487, 487, 554, 554, 674], [676, 676, 703, 703, 1322], [1324, 1324, 1359, 1359, 1583], [1585, 1585, 1624, 1624, 1891], [1893, 1893, 1932, 1932, 2106], [2108, 2108, 2163, 2163, 2449]]}
{"id": "sdtXWj", "name": "petilepsja", "author": "Sfora", "description": "Doprawdy zadziwiające rzeczy.", "tags": ["learning"], "likes": 4, "viewed": 65, "published": "Public", "date": "1633992671", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n   \n\nfloat plot(vec2 uv, float y){\nreturn smoothstep(y-0.05,y,uv.y)-smoothstep(y,y+0.05,uv.y);\n}\n\nfloat plotc(vec2 uv, float y){ //ta funkcja jest tylko do czarnego środka potrzebna\nreturn smoothstep(y-1.,y+1.,uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\nvec2 uv = fragCoord.xy / iResolution.xy;\nuv = uv*2.-vec2(1.,1.);\nuv.x = uv.x*iResolution.x/iResolution.y;\nvec2 uva = vec2(atan(uv.x,uv.y), length(uv));\nvec3 col;\n  float t = iTime;\n  float p;\n  float off = -2.1;\n  //float p = 3.*sin(t*0.3)*cos(t*0.5)*2.;\n  p = 3.; //można różne p, generalnie to ilość płatków, przy p = 0.08 wychodzi spirala choć trochę nierówna jeszcze\n  //p = 0.08;\n  for (int i = 0; i < 20; i++){\n  col += vec3(plot(uva-(fract(t)+off),sin((uva.x-sin(t))*p))); //odkomentuj lub zakomentuj dla dodatkowego bujania\n  col += vec3(plot(uva-(fract(t)+off),sin((uva.x)*p))); //wersja \"zwinięta\"\n  //col += vec3(plot(uv-(fract(t)+off),sin((uv.x)*p))); //wersja \"rozwinięta\"\n  //col += vec3(plot(uv,sin((uv.x)*p))); ////wersja \"rozwinięta\" bez przesuwu i bez animacji \"tunelu\"\n  off = off + 0.5;\n  }\n  //col *= vec3(plotc(uva*8.-2.,sin((uva.x-sin(t))*p))); //ewentualne zasłonięcie środka\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdtXWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[6, 6, 35, 35, 97], [99, 99, 129, 183, 220], [222, 222, 278, 278, 1226]]}
{"id": "sdtXzj", "name": "Gaz Remix Fractal", "author": "MacroMachines", "description": "Gaz is killin it", "tags": ["fractalgaz"], "likes": 14, "viewed": 260, "published": "Public API", "date": "1633549822", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)cos((h)*6.3+vec3(0,23,21))*.5+.5\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));\n    float i=0.,g=0.,e,s;\n    for(;i++<99.;)\n    {\n        p=g*d-vec3(.05*sin(iTime*.5),.1,1.8);\n        p=R(p,normalize(vec3(1,-2,2)),iTime*.5);\n        s=2.;\n        vec4 q=vec4(p,sin(iTime*.4)*.5);\n\t\tfor(int j=0;j++<8;)\n        {\n            q=abs(q);\n            q=q.x<q.y?q.zwxy:q.zwyx;\n            s*=e=2.3/clamp(dot(q,q),.2,1.5);\n            q=q*e-vec4(1,4,2,1);\n        }\n        g+=e=min(\n                length(q.w)/s,\n                length(cross(q.xyw,vec3(.577)))/s-.3e-4\n            )+.001;\n        O.rgb+=mix(r/r,H(log(s)*2.),.3)*.015*exp(-.03*i*i*e);\n    }\n    O*=O*O*O;\n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdtXzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[104, 104, 140, 140, 812]]}
{"id": "sdtXzs", "name": "Burning inferno", "author": "guil", "description": "Nearly the same as my previous shader.", "tags": ["inferno"], "likes": 15, "viewed": 335, "published": "Public API", "date": "1633786733", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 R(float a){\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\n\nvoid mainImage( out vec4 C, vec2 FC )\n{\n    float o,i,e,f,s, g=4., t=iTime, k=.1;\n    vec3 p,q, r=iResolution, l=vec3(2.);\n    \n    for(;i++<1e2;g+=min(f,max(e,.4))*k){\n        s=2.;\n        p=vec3((FC.xy-r.xy/s)/r.y*g,g-5.);\n        k*=1.015;\n        p.yz*=R(-.7);\n        p.z+=t;\n        for(e=f=p.y;s<4e2;s/=.6)\n            p.xz*=R(s),\n            q=p,\n            q.x+=t*.2*log(s),\n            e+=abs(dot(sin(q.xz*s*.1)/s,l.xz*2.)),\n            f+=abs(dot(sin(p*s*.15)/s,l));\n         o=1.+(f>1e-3?(e>.01?f*e:-exp(-e*e)):-1.);\n         \n         C *= .96;\n         C.rgb += .1*max(o,.5)*(exp(-f)*vec3(.5,.3,.2)/4.+exp(-e)*vec3(.2,.1,.0));\n         }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdtXzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 16, 16, 68], [71, 71, 110, 110, 731]]}
{"id": "sdVSDz", "name": "Starboard", "author": "TJTTTTTTTTT", "description": "Pls don't look at the code it's seriously bad.", "tags": ["star", "checker", "rotating"], "likes": 0, "viewed": 40, "published": "Public", "date": "1634509568", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\nfloat time = 0.;\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat tri(float delta) {\n    if (delta > 1.) {\n        return 0.;\n    }\n    if (delta < 0.) {\n        return 0.;\n    }\n    return abs(2.*fract(delta)-1.);\n}\n\nfloat endlessTri(float delta) {\n    return abs(2.*fract(delta)-1.);\n}\n\nfloat saw(float delta) {\n    return delta-floor(delta);\n}\n\nvec3 checker(vec2 st) {\n    st += vec2(time/PI);\n    st *= 8.496;\n\n    vec3 color = vec3(0.);\n    color = vec3(floor(endlessTri((st.x+0.5)*1.)+(1.0-endlessTri(st.y))));\n\n    return color;\n}\n\nvec3 c;\nbool inside = false;\n\nvec3 diamond(vec2 st) {\n    float offset = -0.5;\n    float dd = st.y-offset;\n    float d = (st.x-0.25-offset)*2.;\n    if (d > 1.0 || d < 0.0) {\n        return vec3(0.);\n    }\n    if (dd > 1.0 || dd < 0.0) {\n        return vec3(0.);\n    }\n    return (vec3(1.0)-vec3(floor(tri((d)*1.)+tri(dd))));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    time = saw(iTime*0.2)*PI*2.;\n    \n    vec2 st = fragCoord/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n    vec3 backCol = vec3(0.343,0.131,0.490)-vec3(0.358,0.349,0.360)*(st.y);\n    st += vec2(-0.70,0.190);\n    st = rotate2d(0.568)*st;\n    st -= 0.5;\n    st *= 2.244;\n    \n    \n    st.x -= st.y*-0.864*(sin(time)+1.);\n    \n    st = rotate2d(time)*st;\n    \n    vec3 color = vec3(0.);\n    color = diamond(st);\n    \n    st = rotate2d(PI*0.5)*st;\n    c = vec3(st.x+0.564, 0., st.y+1.152);\n    c += checker(st)*0.192;\n    \n    if (color == vec3(0.)) {\n    \tcolor = diamond(st);\n\t    if (color == vec3(0.)) {\n        \tcolor = backCol;\n        }\n    }\n    \n    if (color == vec3(1.)) {\n        color *= c;\n    }\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdVSDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[115, 115, 143, 143, 229], [231, 231, 255, 255, 387], [389, 389, 420, 420, 458], [460, 460, 484, 484, 517], [519, 519, 542, 542, 708], [740, 740, 763, 763, 1036], [1039, 1039, 1096, 1096, 1854]]}
{"id": "sdVSRw", "name": "Something  gaz 229", "author": "gaz", "description": "inspired : https://www.shadertoy.com/view/4lGcz1", "tags": ["3d"], "likes": 7, "viewed": 50, "published": "Public", "date": "1634437266", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\n\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,d=normalize(vec3((C-.5*r.xy)/r.y,1.));\n    for(float i=0.,g,e=1.;++i<99.;){\n        p=g*d;\n        p.z-=5.;\n        p=R(p, normalize(vec3(1,2,3)), iTime*2.);\n        p+=cross(sin(p*.4+iTime*3.),cos(p.zxy*.3+iTime*2.));\n        g+=e=(length(p-clamp(p,-1.,1.))-.1)*.7;\n        O.xyz+=mix(vec3(1),H(dot(p,p)),.8)*.01*exp(-.05*i*i*e);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdVSRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 107, 143, 143, 522]]}
{"id": "sdVSWK", "name": "Figure-8 Seifert surface", "author": "DPiker", "description": "See this thread:\nhttps://twitter.com/KangarooPhysics/status/1453107086573850626\n", "tags": ["3d", "4d", "knot", "projective"], "likes": 4, "viewed": 73, "published": "Public", "date": "1635336584", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Daniel Piker 2021\n/* \nChanged to get the Seifert surface using (1/4πi) log (Q/Q∗)\n(added complex log line 85 and new field expression line 163)\n\nStill trying to make it work for keeping the knot fixed while varying the Seifert fiber like in \nhttps://twitter.com/KangarooPhysics/status/1381380025568616459\nan attempt here\nhttps://www.shadertoy.com/view/7sVXWK\n\n\n// Inigo Quilez 2021\n/*\n\nAn (appoximated) SDF that has a Figure-8 knot shape. It's not very\nsymmetric or pretty, but it counts (topologically).\n\nThe idea is described here https://arxiv.org/pdf/1610.02463.pdf and\ngoes like this:\n\nFrom R3, our regular 3D space, we do an inverse stereographic\nprojection to land in a 4D hyper sphere S3, a subset of R4.\n\nIn R4 we define a function F that returns a R2 field (or\ntwo scalar fields, if you want). We find the zero isosurface\n(the nodal set, or roots) of F by zeroing its two components.\n\nBecause we are only evaluating the subset of R4 that lays on S3,\nwe are really computing the intersection of the isosurfce of F\nwith the surface of the sphere S3. This creates a curve on the surface\nof the sphere, which thanks to the stereographic projection we started\nwith becomes a curve in R3, our 3D space. That's the curve we are\nraymarching.\n\nThe R4 parameter to F can be grouped as two complex numbers u and v.\nAnd in the case of this shader I'm using\n\nF(u,v) = 64v³ − 12v(3+2u²−2u*²) − (14u²+14u*²+u⁴-u*⁴)\n\nwhere u* is the conjugate of u. This curve is a figure 8 shape, as\ndescribed in the paper. You can change the SHAPE define below to\nsee another shape (a torus knot).\n\nLastly, there's more than one way to convert F into a R1 scalar field\nthan taking it's length |F|. For example, you can pass F through any\n2D SDF formula you want, such a square. Change the PROFILE define\nbellow to explore that.\n\n\nSee: https://www.shadertoy.com/view/tsBGzt\nSee: https://www.shadertoy.com/view/7sGSRd\n\n*/\n\n#define AA 1\n\n// 0: circular\n// 1: square\n#define PROFILE 0\n\n// 0: figure 8\n// 1: torus 5-2\n// 2: something i made\n#define SHAPE 0\n\n//------------------------------------------------------------\n// oldschool rand() from Visual Studio\n//------------------------------------------------------------\nint   seed = 1;\nvoid  srand(int s ) { seed = s; }\nint   rand(void) { seed = seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\n//------------------------------------------------------------\n// hash to initialize the random sequence (copied from Hugo Elias)\n//------------------------------------------------------------\nint hash( int n )\n{\n\tn = (n << 13) ^ n;\n    return n * (n * n * 15731 + 789221) + 1376312589;\n}\n\n//------------------------------------------------------------\n// complex number operations\n//------------------------------------------------------------\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 cdiv( vec2 a, vec2 b )  { float d = dot(b,b); return vec2( dot(a,b), a.y*b.x - a.x*b.y ) / d; }\nvec2 csqr( vec2 a ) { return vec2(a.x*a.x-a.y*a.y, 2.0*a.x*a.y ); }\nvec2 csqrt( vec2 z ) { float m = length(z); return sqrt( 0.5*vec2(m+z.x, m-z.x) ) * vec2( 1.0, sign(z.y) ); }\nvec2 conj( vec2 z ) { return vec2(z.x,-z.y); }\nvec2 cpow( vec2 z, float n ) { float r = length( z ); float a = atan( z.y, z.x ); return pow( r, n )*vec2( cos(a*n), sin(a*n) ); }\nvec2 clog( vec2 z) {return vec2 (log(sqrt(z.x*z.x+z.y*z.y)),atan(z.y,z.x));}\n//------------------------------------------------------------\n// https://en.wikipedia.org/wiki/Stereographic_projection\nvec4 inversestereographic(vec3 p)\n{\n    float r2 = 1.0+dot(p,p);\n    return vec4(2.0*p,r2-2.0)/r2;\n}\n//------------------------------------------------------------\n// https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdRoundSquare( in vec2 p, in float s, in float r ) \n{\n    vec2 q = abs(p)-s+r;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r;\n}\n//------------------------------------------------------------\n// https://iquilezles.org/www/articles/biplanar/biplanar.htm\nvec3 tex( sampler2D sam, in vec4 p, in vec4 n )\n{\n    n = n*n;\n    n = n*n;\n    vec3 col = vec3(0.0);\n    col += n.x*texture(iChannel0,p.yz).xyz;\n    col += n.y*texture(iChannel0,p.zw).xyz;\n    col += n.z*texture(iChannel0,p.wx).xyz;\n    col += n.w*texture(iChannel0,p.xy).xyz;\n    return col / (n.x+n.y+n.z+n.w);\n}\n//===============================================================================================\n\nvec4 r3_to_s3( in vec3 p )\n{\n    vec4 q = inversestereographic(p);\n    \n    // rotate in yw\n    float a = iTime*6.283185/6.0;\n    q.yw *= mat2(cos(a),sin(a),-sin(a),cos(a));\n    \n    return q;\n}\n\nvec2 F( in vec2 u, vec2 v )\n{\n    #if SHAPE==0\n    // figure-8\n    vec2 a = vec2(3.0,0.0) - 2.0*csqr(v) + 2.0*csqr(conj(v));\n    vec2 q = 64.0*cmul(u,csqr(u)) \n           - 12.0*cmul(u,a) \n           + 14.0*cmul(v,v) \n           + 14.0*csqr(conj(v)) \n           -      csqr(csqr(v)) \n           +      csqr(csqr(conj(v)));\n    return q;\n    #endif\n    \n    #if SHAPE==1\n    // torus\n    return 20.0*(cmul(u,csqr(csqr(u))) + csqr(v));\n    #endif    \n\n    #if SHAPE==2\n    // something I made\n    return    64.0*cmul(v,csqr(csqr(u)))\n           + 32.0*cmul(u,csqr(v))\n           + 32.0*csqr(v) \n           + 8.0;\n    #endif    \n\n}\n\nfloat field( in vec4 q )\n{\n    vec2 phi = F(q.xy,q.zw);\n    \n    #if PROFILE==0\n    //return length(phi) - 10.0;  \n    \n    //(1/4πi) log (Q/Q∗)  \n    return (length(cmul(vec2(0,0.785398163),clog(cdiv(phi,conj(phi))))));    \n    \n    #else\n    return sdRoundSquare( phi, 8.0, 0.5 );\n    #endif\n}\n\n// only used for texturing, not for distance-estimation\nvec4 field_grad( in vec4 q )\n{\n    float f = field(q);\n    const vec2 e = vec2(0.001,0.0);\n    return normalize(vec4(\n        field(q+e.xyyy),\n        field(q+e.yxyy),\n        field(q+e.yyxy),\n        field(q+e.yyyx))-f );\n}\n\nfloat map( in vec3 p )\n{\n    float d = field(r3_to_s3(p));\n\n    // could do some automatic differentiation here...\n    float eps = 0.0001;\n    vec3 g = (vec3(field(r3_to_s3(p+vec3(eps,0.0,0.0))),\n                   field(r3_to_s3(p+vec3(0.0,eps,0.0))),\n                   field(r3_to_s3(p+vec3(0.0,0.0,eps))))-d)/eps;\n    \n    // distance estimator\n    return d/length(g);\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos, in float eps )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\n// https://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat shadow( in vec3 ro, in vec3 rd, float k )\n{\n    const float tmax = 5.0;\n    float t = 0.001;\n    float sh = 1.0;\n    for( int i=0; i<256; i++ )\n    {\n        vec3 pos = ro + rd*t;\n        float h = map(pos);\n        sh = min( sh, clamp(k*h/t,0.0,1.0) );\n        if( sh<0.001 ) break;\n        t += clamp(h,0.001,0.1);\n        if( t>tmax ) break;\n    }\n    return sh;\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat ao = 0.0;\n\tfor( int i=0; i<32; i++ )\n\t{\n\t\tfloat h = frand();\n        vec3 kv = normalize( vec3(frand(), frand(), frand()) );\n        kv *= sign(dot(kv,nor));\n\t\tao += clamp( map(pos+nor*0.001+kv*h*2.0)*1.0, 0.0, 1.0 );\n\t}\n\tao /= 32.0;\n\t\n\treturn clamp( ao*1.5-0.1, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // init random seed\n    ivec2 q = ivec2(fragCoord);\n    srand( hash(q.x+hash(q.y+hash(iFrame))));\n\n    // camera movement\t\n    float an = -0.0*iTime/20.0;\n    vec3 ro = vec3( 5.0*sin(6.283185*an), 4.0, 5.0*cos(6.283185*an) );\n    #if SHAPE>0\n    ro.xz *= 1.5;\n    ro.y = 0.0;\n    #endif\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n\n        // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 3.0*ww );\n        \n        // raymarch\n        const float tmax = 15.0;\n        float t = 0.0;\n        for( int i=0; i<8192; i++ )\n        {\n            vec3 pos = ro + rd*t;\n            float d = map(pos);\n            if( d<0.001 ) break;\n            d = min(d*0.8,0.1);\n            t += d;\n            if( t>tmax ) break;\n        }\n        \n        vec3 col = vec3(0.0);\n        col = vec3(0.05 + 0.05*rd.y);\n        if( t<tmax )\n        {\n            vec3  pos = ro + rd*t;\n            vec3  nor = calcNormal( pos, 0.0001 );\n            float occ = calcAO( pos+nor*0.001, nor );\n\n            // we do texturing in R4\n            vec4 pos4 = r3_to_s3(  pos );\n            vec4 nor4 = field_grad( pos4 );\n            vec3 mate = tex(iChannel0,pos4,nor4);\n            mate = mate*mate;\n            mate *= 0.3;\n\n            // sun\n            {\n            vec3 lig = normalize(vec3(1.0,1.0,0.2));\n            float dif = clamp(dot(nor,lig),0.0,1.0);\n            if( dif>0.001 ) dif *= shadow(pos+nor*0.001, lig, 48.0);\n            vec3 hal = normalize(lig-rd);\n            float spe = pow(clamp(dot(nor,hal),00.,1.0),32.0);\n            spe *= 0.04 + 0.96*pow( clamp(1.0-dot(lig,hal), 0.0, 1.0), 5.0 );\n            spe *= 10.0;\n\n            col  = 0.6*mate*vec3(9.0,8.0,7.0)*dif;\n            col += spe*dif*mate.x*10.0;\n            \n            float fre = clamp(1.0+dot(rd,nor),0.0,1.0);\n            col += mate*fre*1.0*(0.25+0.75*dif)*vec3(1.0,0.7,0.4);\n            }\n            \n            // sky\n            {\n            vec3 ref = reflect(rd,nor);\n            float dif = 0.5+0.5*nor.y;\n            float spe = smoothstep(0.3,0.5,ref.y);\n            spe *= dif;\n            spe *= 0.04 + 0.96*pow( clamp(1.0+dot(rd,nor), 0.0, 1.0), 5.0 );\n            if( spe>0.001 ) spe *= shadow(pos+nor*0.001, ref, 8.0);\n            col += 3.0*occ*mate*dif*vec3(0.5,0.6,1.0)*1.5;\n            col += 1.0*spe;\n            }\n\n            // sun bounce\n            col += mate*(1.0-occ)*vec3(1.2,0.5,0.2)*0.2;\n        }\n        \n        // gain\n        col = col*1.5/(1.0+col);\n        \n        // to gamma space\n        col = pow( col, vec3(0.4545) );\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    // remove color banding through dithering\n    tot += (1.0/255.0)*frand();\n \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdVSWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2052, 2233, 2254, 2254, 2266], [2267, 2267, 2285, 2285, 2342], [2343, 2343, 2362, 2362, 2394], [2395, 2588, 2607, 2607, 2683], [2685, 2840, 2870, 2870, 2925], [2926, 2926, 2956, 2956, 3026], [3027, 3027, 3048, 3048, 3094], [3095, 3095, 3117, 3117, 3204], [3205, 3205, 3226, 3226, 3251], [3252, 3252, 3282, 3282, 3382], [3383, 3383, 3403, 3403, 3459], [3460, 3581, 3616, 3616, 3681], [3682, 3820, 3879, 3879, 3965], [3966, 4090, 4139, 4139, 4405], [4406, 4505, 4533, 4533, 4699], [4701, 4701, 4730, 4730, 5329], [5331, 5331, 5357, 5357, 5629], [5631, 5687, 5717, 5717, 5911], [5913, 5913, 5937, 5937, 6287], [6289, 6353, 6399, 6399, 6596], [6598, 6661, 6710, 6710, 7034], [7036, 7036, 7078, 7078, 7362], [7364, 7364, 7421, 7445, 10644]]}
{"id": "sdVSWy", "name": "sea of balls: shader LOD", "author": "FabriceNeyret2", "description": "mid: analytical scene average\ncf \"Fake fur rendering\" [url]https://www.researchgate.net/publication/220721859_Fake_fur_rendering[/url]\n& \"Real-time Realistic Rendering and Lighting of Forests\" [url]https://hal.inria.fr/hal-00650120[/url]\nmouse: camera", "tags": ["raymarching", "voronoi", "worley", "short"], "likes": 7, "viewed": 199, "published": "Public API", "date": "1635266058", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rot(a) mat2(cos(a+vec4(0,11,33,0))) // --- utils from https://www.shadertoy.com/view/llySRh\n#define H(p)   fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n\nvec4   lum = vec4(0,1,0,0),           // balls color on lit side\n      shad = vec4(0,0,1,0),           // balls color on shadow side\n        bg = vec4(1,0,0,0);           // background color\nfloat r = .3;                         // spheres radius\n      \nfloat map(vec3 q) {                   // --- scene  SDF ----------------\n    q *= 2.;\n    vec2 I = floor(q.yx), F = fract(q.yx), D;\n    float d, l=9.;\n    for( int k=0; k < 9; k++ )        // find closest seed within neihbors\n        D = vec2(k%3,k/3) -1.,\n        d = length( D + H(I+D) - F ), // offset to seed\n        l = min(l,d);                 // keep closest dist\n    return length(vec2(l,q.z)) - r;   // sphere SDF\n}\n\nvoid mainImage(out vec4 O, vec2 U)    // --- renderer ----------------\n{\n    vec3 R = iResolution;\n    U = (U+U-R.xy)/R.y;\n    float t=9., i; \n    vec3  N, e = vec3(1,-1,0)/1e2, \n          D = normalize(vec3(U, -2.)),                 // ray direction\n          p = vec3(0,-2,22),                           // marching point along ray \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(20,12,0)/1e2*cos(.3*iTime+vec3(0,11,0))+vec3(0,.2,0);\n    p.yz *= rot(.5-6.3*M.y),                           // rotations\n    p.xz *= rot(-6.3*M.x);\n    D.yz *= rot(.5-6.3*M.y),\n    D.xz *= rot(-6.3*M.x);\n    if (D.z*p.z>0.) { O=vec4(1); return; }             // sky\n\n    if ( abs(U.x) < .5 ) {                        // --- analytical average\n         t = -p.z/D.z;\n         if ( t < 0. ) { O = bg; return; }\n         p += t*D;                                     // ray-trace to plane\n         N = vec3(0,0,1);                              // plane normale\n         float d = 3.14*r*r,                           // sphere density\n               a = 1.- pow( 1.-d, 1./ abs(dot(N,D)) ), // apparent density\n               s = ( 1.+ D.x ) / 2. ; // D.x: dot(D,L) // sphere apparent shadowing proportion\n         O = mix( bg, mix( lum, shad, s ), a );        // compose contributions\n      }\n    else {     \n        for ( i=0.; i<200. && t>.01; i++ )        // --- explicit rendering\n            t = min(9., map(p)),                       // SDF\n            p += .25*t*D;                              // step forward = dist to obj\n\n        if (i<200.)                                    // hit\n             N = normalize(   map(p+e.xyy)/e.xyy +  map(p+e.yxy)/e.yxy // https://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\n                            + map(p+e.yyx)/e.yyx +  map(p+e.xxx)/e.xxx ),\n             O = N.x > 0. ? lum : shad;                // toon shading\n          // O = vec4( .3 + .7*max(0.,N.x) );          // ambient + diffuse\n        else O = bg;\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdVSWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[349, 432, 451, 504, 857], [859, 859, 931, 931, 2824]]}
{"id": "sdVXDm", "name": "newton fractal gaurav", "author": "gauravity", "description": "yuh", "tags": ["fractal"], "likes": 3, "viewed": 135, "published": "Public API", "date": "1634781872", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926538\n\nvec2 mult(vec2 a, vec2 b)\n{\n    return vec2(a.x*b.x - a.y*b.y, a.x * b.y + a.y * b.x);\n}\n//https://stackoverflow.com/questions/26070410/robust-atany-x-on-glsl-for-converting-xy-coordinate-to-angle\nfloat atan2(in float y, in float x)\n{\n    float s = (abs(x) > abs(y))?1.:0.;\n    return mix(PI/2.0 - atan(x,y), atan(y,x), s);\n}\n\nvec2 powc(vec2 x, float n) {\n     float ang = atan2(x.y, x.x);\n     float modulus = length(x);\n     float newAng = n * ang;\n     float newMod = pow(modulus, n);\n     return newMod*vec2(cos(newAng), sin(newAng));\n     \n}\n\n\nvec2 conj(vec2 a)\n{\n    return vec2(a.x, -a.y);\n}\n\nfloat mod2(vec2 a)\n{\n    return a.x*a.x + a.y*a.y;\n}\n\nvec2 inv(vec2 x) {\n    return conj(x) / mod2(x);\n}\nvec2 f(vec2 x) {\n    return vec2(-1, 0) + powc(x, 3.);\n}\n\nvec2 fp(vec2 x) {\n  \n     return 3.0*powc(x, 2.); //+ 2.0*x + vec2(1.0, 0);\n}\n\nvec2 newt(vec2 x) {\n     return x - mult(f(x), inv(fp(x)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n     vec2 uv = fragCoord/iResolution.x;\n    vec2 xy = uv*2.0 -vec2(1.0, iResolution.y/iResolution.x);\n    vec2 x = mult(xy*16.0 / pow(iTime, 2.), vec2(cos(iTime), sin(iTime)));\n    \n    vec3 col = vec3(152.,125.,124.)/255.;\n    for (int i =0; i < 100; i++){\n       float qTime = mod(iTime, 10.0);\n       if (qTime > 5.0) {\n       qTime = 10.0-qTime;\n       }\n       if (float(i) >= qTime*24.0) {\n           break;\n        }\n        x =newt(x);\n     \n    }\n    vec2 unity = vec2(cos(2.*PI/3.), sin(2.*PI/3.));\n    vec2 u2 = powc(unity, 2.);\n    vec2 o = vec2(1., 0.);\n    \n    float di = mod2(x - unity);\n    float dni = mod2(x - u2);\n    float dn1 = mod2(x - o);\n    if (dni < di && dni < dn1) {\n       col = vec3(160., 156., 176.)/255.;\n    }\n    else if (di < dn1) {\n       col = vec3(255.,193.,69.)/255.;\n    }\n\n    // Time varying pixel color\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdVXDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 52, 52, 113], [114, 222, 259, 259, 350], [352, 352, 380, 380, 571], [574, 574, 593, 593, 623], [625, 625, 645, 645, 677], [679, 679, 697, 697, 729], [730, 730, 746, 746, 786], [788, 788, 805, 805, 865], [867, 867, 886, 886, 928], [930, 930, 987, 1037, 1947]]}
{"id": "sdVXW1", "name": "Julia sets animation", "author": "JochemP", "description": "Julia set", "tags": ["julia"], "likes": 0, "viewed": 31, "published": "Public", "date": "1635108477", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Mandelbrot(vec2 z){\n    float radius = 180.;\n    float speed=.1;\n    vec2 screenPos = vec2(iResolution.x*.48,iResolution.y*.5) + vec2(cos(iTime*speed),sin(iTime*speed))*radius;\n    vec2 c;\n    c = (screenPos/iResolution.xy - vec2(.5,.5))*3.;\n    int iterations = 100;\n   \n    for(int i = 0; i < iterations; i++){\n        float a = z.x;\n        float b = z.y;\n        z = vec2(a*a-b*b, 2.*a*b) + c;\n        if(dot(z,z)>4.){\n            return float(i)/float(iterations);\n        }\n    }\n    return 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float v = Mandelbrot((fragCoord - iResolution.xy/2.)*3./iResolution.y);\n    fragColor = vec4(0.5 + 0.5*cos(v*500.+vec3(0,2,4)+iTime/2.),0.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdVXW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 508], [510, 510, 567, 567, 714]]}
{"id": "sdVXWK", "name": "hash density", "author": "FabriceNeyret2", "description": "top: hash density = 1 - length\nbottom right: average 8 values\nbottom left: analytic average", "tags": ["noise", "hash"], "likes": 7, "viewed": 174, "published": "Public API", "date": "1635334018", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define hash(p)  fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( u+u - R ) / R.y;\n\n#define H(s) vec4( hash( s+ U+iTime ) > length(U) )\n    O =   U.y > 0. ?   H()\n        : U.x > 0. ? ( H(.1)+H(.2)+H(.3)+H(.4)+H(.5)+H(.6)+H(.7)+H(.8) ) / 8.\n                   :   vec4(1. - length(U));\n    O = sqrt(O); // to sRGB\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdVXWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 73, 111, 111, 405]]}
{"id": "sdVXWw", "name": "interesting colors thing", "author": "bigbadbob234", "description": "Trying to make a shepard-tone-like thing but with colors (consistently moving from red to blue).\nI'm new to playing with shadertoy, sorry about the ugly code.", "tags": ["colors", "colorshift", "shepardtone", "russellbeat", "inventing", "newcolors"], "likes": 1, "viewed": 32, "published": "Public", "date": "1634770290", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec2 uv = fragCoord;\n    \n    float t = 1.0;\n    float a = .5 + .5*cos(iTime*3. + uv.x - (uv.x*floor(uv.x/3.0)) + uv.y - (uv.y*floor(uv.y/3.0)));\n    float b1 = (iTime-floor(iTime));\n    float b = a; // + b1;\n    //(uv.x*floor(uv.x / 7.0)) \n    float h = b - (b * floor(b/t));\n    float h2 = exp(h)/2.71;\n    \n    vec3 col = vec3(1.-h2*2., (.5-h2)*(.5-h), h2*(abs(.25-h)+1.));\n    // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdVXWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 241, 743]]}
{"id": "sdVXWz", "name": "Simple Truchet pattern", "author": "sinvec", "description": "Based on https://www.shadertoy.com/view/ssV3Dz", "tags": ["2d", "truchet"], "likes": 2, "viewed": 57, "published": "Public", "date": "1634504817", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n\nfloat hash21(vec2 p) {return fract(fract(dot(p,vec2(5.15123,2.1235)))*41.3151);}\nfloat circle (vec2 p, vec2 c, float r, float w) {return 1.-smoothstep(0.,.01,abs(length(p-c)-r)- w);}\nmat2 rot2(float a) {return mat2(cos(a), -sin(a), sin(a), cos(a));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n    vec2 uv = ( fragCoord.xy - iResolution.xy * .5 ) / iResolution.y;\n\n\tuv *= 3.;\n\tuv += vec2(iTime * .1, -iTime*.15);\n\t\n\tfloat steps = 7.; // play with this value :)\n\tfloat backclfun = clamp(sin(uv.x*2.)*sin(uv.y*2.)*.5+.5,1./abs(steps)-.01,1.)-.001;\n\tfloat bclffl = floor((backclfun)*abs(steps));\n\tfloat bclffr = backclfun*steps-bclffl;\n\t\n\tvec3 col = mix(vec3(.55, .55, .96), vec3(.96, .55, .52), clamp(bclffl / steps,0.,1.)) ;\n\t\n\tvec2 grid = floor(uv);\n\tfloat id = hash21(grid);\n\tvec2 cent = uv-grid-.5;\n\tcent = rot2(PI/2. * floor(id * 7.)) * cent;\n\n    vec3 cl = col;\n\tcol = mix(col, (1.-col)*1.2, circle(cent, vec2( .5, .5), .65, .001));\n\tcol = mix(col, (1.-col)*1.2, circle(cent, vec2( .5, .5), .35, .001));\n\tcol = mix(col, (1.-col)*1.2, circle(cent, vec2(-.5,-.5), .65, .001));\n\tcol = mix(col, (1.-col)*1.2, circle(cent, vec2(-.5,-.5), .35, .001));\n\t\n\tcol = mix(col, (1.-cl)*1.2, circle(cent, vec2(-.5,.5), .5, .063));\n\tcol = mix(col, (1.-cl)*1.2, circle(cent, vec2(.5,-.5), .5, .063));\n\tcol = mix(col, vec3(.9), circle(cent, vec2(-.5,.5), .5, .05));\n\tcol = mix(col, vec3(.9), circle(cent, vec2(.5,-.5), .5, .05));\n\n    col = mix(col, vec3(0.), float(texture(iChannel0, cent).xyz) * .2);\n\n\tcol = mix(col, vec3(PI*.1), pow(1.-bclffr, PI));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdVXWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 42, 42, 100], [101, 101, 150, 150, 202], [203, 203, 223, 223, 269], [271, 271, 328, 328, 1615]]}
{"id": "sdySDG", "name": "circular circle", "author": "schzna", "description": "やりたかったやつ", "tags": ["circle"], "likes": 6, "viewed": 72, "published": "Public", "date": "1635190537", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float PI = 3.14159265;\n\nfloat atan2(in float y, in float x){\n    return x == 0.0 ? sign(y)*PI/2.0 : atan(y, x);\n}\n\nfloat peek(in float x, in float spr, in float target){\n    return min(\n        spr/((x-target)*(x-target)+0.0000001),\n        1.0\n    );\n}\n\nfloat rand(float x){\n  return fract(sin(dot(vec2(x, x*1.34) ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 ring(float time, float ang, float d, float spr, float p1, float p2){\n    vec3 rgb;\n    rgb.x = sin(time*p2+ang*1.0);\n    rgb.y = cos(time*p2+ang*1.0);\n    rgb.z = sqrt(abs(1.5 - abs(rgb.x) - abs(rgb.y)));\n    \n    float b = 0.05*cos(cos(time));\n    float r = 0.15 + b * cos(cos(ang+time*p2) + 0.6*sin(ang*p1));\n    \n    float ringeff = peek(d, spr, r);\n    return ringeff*rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float d = distance(fragCoord, iResolution.xy/2.0)/distance(vec2(0.0, 0.0),iResolution.xy/2.0);\n    vec2 p = fragCoord - iResolution.xy/2.0;\n    float ang = atan2(p.y,p.x);\n    vec3 col;\n    \n    float time=iTime*5.0;\n    float offset=17.0;\n    \n    float spr = 0.0000004;\n    spr += spr*cos(time*1.0) + spr*0.8;\n    \n    col = ring(time, ang, d, spr, 4.0, 1.0);\n    col += ring(time, ang, d, spr, 3.0, 1.4);\n    col += ring(time, ang, d, spr, 5.0, 1.6);\n    col += vec3(1.0, 1.0, 1.0) * (1.0 - distance(vec3(0.,0.,0.),col));\n\n    // Output to screen\n    fragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdySDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 60, 60, 113], [115, 115, 169, 169, 253], [255, 255, 275, 275, 355], [357, 357, 430, 430, 740], [742, 742, 799, 849, 1474]]}
{"id": "sdySWV", "name": "Moomin Chasing Clouds", "author": "ytt", "description": "An animation attempt using SDF", "tags": ["clouds", "moomins"], "likes": 44, "viewed": 349, "published": "Public", "date": "1635289320", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// Moomin Chasing Clouds\n//\n// Based on Inigo Quilez wonderful tutorials\n//\n// Inspired by Happy Jumping and the Moomin Japanese animated series opening\n// https://youtu.be/c0vmjpJk1eo?t=27\n//\n\n#define RENDER_MOOMIN\n#define RENDER_CLOUDS\n#define RENDER_FLOWERS\n#define RENDER_TREES\n#define RENDER_MOUNTAINS\n\n#define RENDER_EYES\n#define RENDER_EARS\n#define RENDER_MOUTH\n#define RENDER_ARMS\n#define RENDER_LEGS\n#define RENDER_TAIL\n\n#define ANIMATION_SPEED 1.0\n#define CAMERA_HEIGHT 0.0\n#define CAMERA_DISTANCE 0.0\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST 0.001\n\n#define MATERIAL_SKIN 1.0\n#define MATERIAL_EAR 2.0\n#define MATERIAL_EYE 3.0\n#define MATERIAL_PUPIL 4.0\n#define MATERIAL_MOUTH 5.0\n#define MATERIAL_GRASS 6.0\n#define MATERIAL_FLOWER1 7.0\n#define MATERIAL_FLOWER2 8.0\n#define MATERIAL_STEM 9.0\n#define MATERIAL_TREE1 10.0\n#define MATERIAL_TREE2 11.0\n#define MATERIAL_MOUNTAIN 12.0\n#define MATERIAL_CLOUD 13.0\n\n#define RUN_SPEED 5.5\n#define CLOUDS_SPEED 8.0\n#define CLOUDS_HEIGHT 10.0\n\nvec3 SUN_DIRECTION = normalize(vec3(0.5, 0.5, -0.6));\n\n#define PI05 1.57079\n#define PI 3.14159\n#define PI2 6.28318\n\nstruct ArmPose\n{\n\tvec3 armAngle;\n\tvec3 elbowAngle;\n\tvec3 wristAngle;\n\tfloat fingersAngle;\n};\n\nstruct LegPose\n{\n\tvec3 legAngle;\n\tfloat kneeAngle;\n\tvec3 footAngle;\n};\n\nstruct Pose\n{\n\tvec3 offset;\n\tvec3 rotation;\n\tfloat cameraOffset;\n\tvec3 headRotation1;\n\tfloat headRotation2;\n\tfloat earsAngle;\n\tfloat eyesOpenFactor;\n\tvec3 eyesDirection;\n\tfloat eyebrowsHeight;\n\tfloat cheeksFactor;\n\tfloat mouthFactor;\n\tvec3 bodyRotation;\n\tvec3 bodyCurve;\n\tvec3 tailRotation;\n\n\tArmPose leftArm;\n\tArmPose rightArm;\n\tLegPose leftLeg;\n\tLegPose rightLeg;\n};\n\n// Cubic Smin\n// https://iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float a, float b, float k )\n{\n    k*=1.35; // This line is an adjustment to match the quadratic smin. It is safe to remove.\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat smax( float a, float b, float k )\n{\n    k*=1.35; // This line is an adjustment to match the quadratic smin. It is safe to remove.\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return max( a, b ) + h*h*h*k*(1.0/6.0);\n}\n\nvec2 smin(in vec2 a, vec2 b, float k) // material smooth min\n{\n\tfloat x = smin(a.x, b.x, k);\n\treturn vec2(x, a.x < b.x ? a.y : b.y);\n}\n\nvec2 smax(in vec2 a, vec2 b, float k) // material smooth max\n{\n\tfloat x = smax(a.x, b.x, k);\n\treturn vec2(x, a.x > b.x ? a.y : b.y);\n}\n\nvec2 min2(in vec2 a, vec2 b) // material min\n{\n\treturn a.x < b.x ? a : b;\n}\n\nvec2 max2(in vec2 a, vec2 b) // material max\n{\n\treturn a.x > b.x ? a : b;\n}\n\nfloat hash(float p)\n{\n\tp = fract(p * 0.1031);\n\tp *= p + 33.33;\n\tp *= p + p;\n\treturn fract(p);\n}\n\nfloat hash(vec3 p)\n{\n\tp  = fract(p * 0.1031);\n\tp += dot(p, p.yzx + 33.33);\n\treturn fract((p.x + p.y) * p.z);\n}\n\nfloat hash(vec2 p)\n{\n\treturn hash(p.xyx);\n}\n\nfloat noise(in vec3 pos)\n{\n\tvec3 p = floor(pos);\n\tvec3 f = fract(pos);\n\n\tf = f * f * (3.0 - 2.0 * f);\n\n\tfloat a = 7.2;\n\tfloat b = 9.3;\n\n\tfloat n = p.x + a * p.y + b * p.z;\n\n\tfloat res = mix(mix(mix(hash(n), hash(n + 1.0), f.x),\n\t\t\t\t\t\tmix(hash(n + a), hash(n + a + 1.0), f.x), f.y),\n\t\t\t\t\tmix(mix(hash(n + b), hash(n + b + 1.0), f.x),\n\t\t\t\t\t\tmix(hash(n + a + b), hash(n + a + b + 1.0), f.x), f.y), f.z);\n\treturn res;\n}\n\nfloat fbm(in vec3 p)\n{\n\tfloat f = 0.5 * noise(p);\n\tp *= 2.1; f += 0.25 * noise(p);\n\treturn f;\n}\n\nfloat linearstep(float edge0, float edge1, float x)\n{\n\treturn clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n}\n\nfloat getTimeSegment(float time, float start, float end)\n{\n\treturn clamp((time - start) / (end - start), 0.0, 1.0);\n}\n\nfloat easeIn(float time, float factor)\n{\n\treturn pow(time, factor);\n}\n\nfloat easeOut(float time, float factor)\n{\n\treturn 1.0 - pow(1.0 - time, factor);\n}\n\nfloat easeInOut(float time, float factor)\n{\n\treturn easeIn(time * 2.0, factor) * step(0.5, 0.5 - time) +\n\t\teaseOut(time * 2.0 - 1.0, factor) * step(0.5, time);\n}\n\nvec3 vec3x(in float x)\n{\n\treturn vec3(x, 0.0, 0.0);\n}\n\nvec3 vec3y(in float y)\n{\n\treturn vec3(0.0, y, 0.0);\n}\n\nvec3 vec3z(in float z)\n{\n\treturn vec3(0.0, 0.0, z);\n}\n\nfloat smoothNoise(float x)\n{\n\tfloat floorx = floor(x);\n\tfloat fractx = fract(x);\n\n\treturn mix(hash(floorx), hash(floorx + 1.0), smoothstep(0.0, 1.0, fractx));\n}\n\nfloat smoothNoise(float x, float f)\n{\n\tfloat floorx = floor(x);\n\tfloat fractx = fract(x);\n\n\treturn smoothstep(f, 0.0, fractx) * hash(floorx - 1.0) + smoothstep(0.0, f, fractx) * hash(floorx);\n}\n\nfloat sdSurface(in vec3 pos)\n{\n\treturn pos.y;\n}\n\nfloat sdSphere(in vec3 pos, float rad)\n{\n\treturn length(pos) - rad;\n}\n\nfloat sdEllipsoid(in vec3 pos, vec3 rad)\n{\n\tfloat k0 = length(pos / rad);\n\tfloat k1 = length(pos / rad / rad);\n\treturn k0 * (k0 - 1.0) / k1;\n}\n\nfloat sdArc(in vec3 pos, float len, float angle, float width, float taper)\n{\n\t// parameters\n\tvec2 sc = vec2(sin(angle), cos(angle));\n\tfloat ra = 0.5 * len / angle;\n\n\t// recenter\n\tpos.x -= ra;\n\n\t// reflect\n\tvec2 q = pos.xy - 2.0 * sc * max(0.0, dot(sc, pos.xy));\n\n\tfloat u = abs(ra) - length(q);\n\tfloat d2 = (q.y < 0.0) ? dot(q + vec2(ra, 0.0), q + vec2(ra, 0.0)) : u * u;\n\tfloat s = sign(angle);\n\n\tfloat t = (pos.y > 0.0) ? atan(s * pos.y, -s * pos.x) * ra : (s * pos.x < 0.0) ? pos.y : len - pos.y;\n\twidth = max(0.001, width - t * taper);\n\n\treturn sqrt(d2 + pos.z * pos.z) - width;\n}\n\nfloat sdCone(vec3 p, vec2 c, float h)\n{\n\tfloat q = length(p.xz);\n\treturn max(dot(c.xy, vec2(q, p.y)), -h - p.y);\n}\n\nvec2 rotate(in vec2 pos, float angle)\n{\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tmat2 m = mat2(c, s, -s, c);\n\treturn pos * m;\n}\n\nvec3 rotate_yzx(in vec3 pos, vec3 angle)\n{\n\tpos.xz = rotate(pos.xz, angle.y);\n\tpos.xy = rotate(pos.xy, angle.z);\n\tpos.yz = rotate(pos.yz, angle.x);\n\n\treturn pos;\n}\n\nvec3 rotate_xzy(in vec3 pos, vec3 angle)\n{\n\tpos.yz = rotate(pos.yz, angle.x);\n\tpos.xy = rotate(pos.xy, angle.z);\n\tpos.xz = rotate(pos.xz, angle.y);\n\n\treturn pos;\n}\n\nfloat getGroundHeight(in vec3 pos)\n{\n\tpos *= vec3(0.1, 0.0, 0.1);\n\tpos.xz *= mat2(0.93, 0.34, -0.34, 0.93);\n\n\treturn -2.0 +\n\t\t0.9 * (sin(pos.x) + sin(pos.z)) +\n\t\t0.6 * (sin(2.0 * pos.x) + sin(2.0 * pos.z));\n}\n\nvoid mixPose(inout ArmPose pose1, in ArmPose pose2, float f)\n{\n\tpose1.armAngle = mix(pose1.armAngle, pose2.armAngle, f);\n\tpose1.elbowAngle = mix(pose1.elbowAngle, pose2.elbowAngle, f);\n\tpose1.wristAngle = mix(pose1.wristAngle, pose2.wristAngle, f);\n\tpose1.fingersAngle = mix(pose1.fingersAngle, pose2.fingersAngle, f);\n}\n\nArmPose getArmPose3(float time, vec3 noise)\n{\n\tArmPose p;\n\n\tfloat time1 = sin(PI2 * time);\n\n\tp.fingersAngle = 1.2;\n\tp.armAngle = vec3(-0.3, -0.9, 0.3) + time1 * vec3(0.0, -0.2, 0.0);\n\tp.elbowAngle = vec3(0.3, -1.2, 0.1) + time1 * vec3(0.5, -0.6, 0.0);\n\tp.wristAngle = vec3(0.0, 0.0, 0.0);\n\n\tnoise = 2.0 * noise - 1.0;\n\n\tp.armAngle += noise.x * vec3(0.0, 0.1, 0.2);\n\tp.elbowAngle += noise.y * vec3(0.0, 0.3, 0.0);\n\n\treturn p;\n}\n\nArmPose getArmPose1(float time, vec3 noise)\n{\n\tArmPose p;\n\n\tfloat time1 = sin(PI2 * time);\n\n\tp.armAngle = vec3(-2.0, -0.5, 0.3) + time1 * vec3(0.0, 0.2, 0.4);\n\tp.elbowAngle = vec3(0.0, 0.0, 0.0) + time1 * vec3(0.0, 0.3, 0.0);\n\tp.wristAngle = vec3(0.0, -0.2, 0.0) + time1 * vec3(0.0, -0.1, 0.0);\n\n\tp.armAngle += noise.x * vec3(0.0, 0.3, 0.2) - vec3(0.0, 0.0, 0.2);\n\tp.elbowAngle += noise.y * vec3(0.0, 1.0, 0.0);\n\tp.wristAngle += noise.z * vec3(0.0, -0.1, 0.0);\n\n\treturn p;\n}\n\n\nArmPose getArmPose2(float time, vec3 noise)\n{\n\tArmPose p;\n\n\tfloat time1 = sin(PI2 * time);\n\n\tp.fingersAngle = 1.2;\n\tp.armAngle = vec3(-2.0, 0.0, 0.5) + time1 * vec3(0.0, 0.2, 0.2);\n\tp.elbowAngle = vec3(0.5, 0.0, 1.0) + time1 * vec3(0.0, 0.1, 0.0);\n\tp.wristAngle = vec3(0.0, 0.0, 0.0) + time1 * vec3(0.0, 0.3, 0.0);\n\n\tnoise = 2.0 * noise - 1.0;\n\n\tp.armAngle += noise.x * vec3(0.0, 0.2, 0.2);\n\tp.elbowAngle += noise.y * vec3(0.0, 0.2, 0.0);\n\tp.wristAngle += noise.z * vec3(0.0, 0.0, 0.0);\n\n\treturn p;\n}\n\nArmPose getArmPose(float time, vec3 noise, float pose1Factor, float pose2Factor)\n{\n\tArmPose p = getArmPose1(time, noise);\n\tmixPose(p, getArmPose2(time, noise), pose1Factor);\n\tmixPose(p, getArmPose3(time, noise), pose2Factor);\n\n\treturn p;\n}\n\nLegPose getLegPose(float time, vec3 noise, float speed, float pose1Factor)\n{\n\tLegPose p;\n\tfloat time1, t1, t2;\n\n\ttime1 = fract(time);\n\n\tfloat hop = pose1Factor;\n\tfloat range = 1.3 * speed;\n\n\tt1 = getTimeSegment(time1, 0.0, 0.6 - 0.4 * hop);\n\tt2 = getTimeSegment(time1, 0.6 - 0.4 * hop, 1.0);\n\tp.legAngle = vec3x(0.5 + (1.0 - hop * 0.4) * range * (1.0 - 2.3 * (easeOut(t1, 1.3) - easeOut(t2, 1.3))));\n\n\ttime1 = fract(time + 0.2);\n\n\tt1 = getTimeSegment(time1, 0.0, 0.3);\n\tt2 = getTimeSegment(time1, 0.4, 0.7);\n\tp.kneeAngle = -0.7 + range * (-1.0 + 1.5 * (easeOut(t1, 1.2) - easeIn(t2, 1.5)));\n\n\tt1 = getTimeSegment(time1, 0.0, 0.5);\n\tt2 = getTimeSegment(time1, 0.5, 1.0);\n\tp.footAngle = vec3x(0.5 - 0.6 * (easeOut(t1, 2.0) - easeOut(t2, 2.0)));\n\n\treturn p;\n}\n\nPose getPose(float time)\n{\n\tPose pose;\n\tfloat time1, time2;\n\tvec3 n1, n2, n3;\n\n\tfloat poseDuration = 4.0;\n\tfloat mode0 = floor(hash(floor(time / poseDuration) - 1.0) * 4.0);\n\tfloat mode1 = floor(hash(floor(time / poseDuration)) * 4.0);\n\n\tfloat mixFactor = smoothstep(0.0, 0.2, fract(time / poseDuration));\n\tfloat armsPose1Factor = mix(step(abs(mode0 - 2.0), 0.0), step(abs(mode1 - 2.0), 0.0), mixFactor);\n\tfloat armsPose2Factor = mix(step(abs(mode0 - 3.0), 0.0), step(abs(mode1 - 3.0), 0.0), mixFactor);\n\n\tposeDuration = 5.5;\n\tmixFactor = smoothstep(0.0, 0.2, fract(time / poseDuration));\n\tmode0 = floor(hash(0.1 + floor(time / poseDuration) - 1.0) * 4.0);\n\tmode1 = floor(hash(0.1 + floor(time / poseDuration)) * 4.0);\n\tfloat legsPoseFactor = mix(step(abs(mode0 - 2.0), 0.0), step(abs(mode1 - 2.0), 0.0), mixFactor);\n\tlegsPoseFactor *= max(0.0, 1.0 - armsPose1Factor - armsPose2Factor);\n\n\ttime1 = time * 0.4; // noise change interval\n\tn1 = vec3(smoothNoise(time1, 0.3), smoothNoise(time1 + 3.0, 0.3), smoothNoise(time1 + 5.0, 0.3));\n\tn2 = vec3(smoothNoise(time1 + 2.0, 0.3), smoothNoise(time1 + 4.0, 0.3), smoothNoise(time1 + 1.0, 0.3));\n\tn3 = 0.5 * (n1 + n2);\n\n\tpose.leftArm = getArmPose(time, n2, armsPose1Factor, armsPose2Factor);\n\tpose.rightArm = getArmPose(time + 0.5, n1, armsPose1Factor, armsPose2Factor);\n\n\ttime1 = time * 0.4;\n\tfloat runSpeed = 0.15 * (RUN_SPEED + 1.3 * (cos(time1) + cos(time1 / 2.0) / 2.0 + cos(time1 / 3.0) / 3.0 + cos(time1 / 5.0) / 5.0));\n\n\tpose.leftLeg = getLegPose(time, n1, runSpeed, legsPoseFactor);\n\tpose.rightLeg = getLegPose(time + 0.5, n2, runSpeed, legsPoseFactor);\n\n\tpose.headRotation1 = vec3(0.3, 0.0, 0.0) + (n3 * 2.0 - 1.0) * vec3(0.7, 0.2, 0.4);\n\tpose.bodyRotation = vec3(-0.2 - 0.3 * n1.y, 0.0, 0.0);\n\tpose.tailRotation = (n3 * 2.0 - 1.0) * vec3(0.0, 0.5, 0.0) +\n\t\tvec3(0.0, 0.0, 0.1 + 1.6 * (pose.bodyRotation.x + 0.5)) +\n\t\t(0.4 + 0.6 * legsPoseFactor) * vec3(0.0, 0.3 * sin(time * PI2), -0.6 * pow(abs(sin(time * PI2 - 0.1)), 1.4));\n\tpose.bodyCurve = vec3(0.1 - 0.2 * runSpeed, 0.1 * sin(PI05 + time * PI2), 0.0);\n\n\ttime1 = time / 2.5; // ears bounces interval\n\tpose.earsAngle = 0.7 * abs(sin(time1 * 30.0)) * // speed and amplitude\n\t\tmax(0.2 - fract(time1), 0.0) * // duration\n\t\tstep(hash(floor(time1)), 0.5); // probability\n\n\tpose.eyesDirection = 0.2 * vec3(n3.x, n3.y, -3.0 + pose.headRotation1.x * 4.0);\n\n\ttime1 = time / 1.5; // eyes blink interval\n\ttime2 = fract(time1);\n\n\tfloat open0 = step(hash(floor(time1) - 1.0), 0.8); // open probability\n\tfloat open1 = step(hash(floor(time1)), 0.8); // open probability\n\tfloat isBlinking = step(hash(floor(time1)), 0.7); // blink probability\n\tfloat isOpened = step(2.0, open0 + open1);\n\n\tfloat openPosition = open0 * linearstep(0.3, 0.0, time2) + open1 * linearstep(0.0, 0.2, fract(time1));\n\tfloat blinkPosition = 1.0 - isBlinking * (linearstep(0.0, 0.05, time2) - linearstep(0.1, 0.2, time2));\n\tpose.eyesOpenFactor = (1.0 - isOpened) * openPosition + isOpened * blinkPosition;\n\tpose.eyebrowsHeight = (1.0 - isOpened) * (1.0 - openPosition) + isOpened * blinkPosition * 0.1;\n\tpose.cheeksFactor = (1.0 - isOpened) * (1.0 - openPosition);\n\n\tpose.mouthFactor = clamp(5.0 * (pose.headRotation1.x - 0.2), 0.0, 1.0);\n\n\tpose.offset = (1.0 - legsPoseFactor) * vec3(0.0, -0.4 * pow(abs(sin(time * PI2 - 0.1)), 1.4), 0.0);\n\tpose.offset += legsPoseFactor * vec3(0.0, -0.9 * abs(sin(time * PI2 - 0.2)), 0.2 * abs(sin(time * PI2 - 0.2)));\n\n\ttime1 = time * 0.4;\n\tfloat runDistance = -(RUN_SPEED * time + 1.5 * (sin(time1) + sin(time1 / 2.0) + sin(time1 / 3.0) + sin(time1 / 5.0)));\n\tfloat h = getGroundHeight(vec3(0.0, 0.0, runDistance));\n\tfloat hx = getGroundHeight(vec3(-SURF_DIST, 0.0, runDistance));\n\n\tpose.offset -= vec3(0.0, h - runSpeed * 0.1, runDistance);\n\tpose.rotation = vec3(0.0, 0.0, -0.6 * atan(hx - h, SURF_DIST));\n\n\treturn pose;\n}  \n\nvec2 sdEars(in vec3 pos, float angle)\n{\n\tfloat bounds = sdSphere(pos - vec3(0.0, 1.0, 0.0), 0.7);\n\tif (bounds > 0.2) return vec2(bounds, 0.0); // optimization\n\n\tpos.x = abs(pos.x);\n\tpos.xy = rotate(pos.xy, -0.32 + angle);\n\tpos -= vec3(0.0, 0.9, 0.0);\n\n\tvec2 d1, d2;\n\tfloat y = -0.05;\n\td1 = vec2(sdEllipsoid(pos - vec3(0.14, y, 0.0), vec3(0.38, 0.5, 0.2)), MATERIAL_SKIN);\n\n\td2 = vec2(sdEllipsoid(pos - vec3(-0.14, y, 0.0), vec3(0.38, 0.5, 0.2)), MATERIAL_SKIN);\n\td1 = smax(d1, d2, 0.03);\n\n\td2 = vec2(sdEllipsoid(pos - vec3(0.0, y, 0.5), vec3(0.6,0.7,0.6)), MATERIAL_SKIN);\n\td1 = smax(d1, d2, 0.1);\n\n\td2 = vec2(sdEllipsoid(pos - vec3(0.0, y, -0.1), vec3(0.12, 0.33, 0.12)), MATERIAL_EAR);\n\td1 = smax(d1, vec2(-d2.x, d2.y), 0.05);\n\n\treturn d1;\n}\n\nvec2 sdArm(in vec3 pos, vec3 armAngle, vec3 elbowAngle, vec3 wristAngle, float fingersAngle)\n{\n\tfloat d1, d2, d3;\n\tvec3 pos1, pos2;\n\n\tpos1 = pos;\n\tpos1 = rotate_xzy(pos1, armAngle);\n\n\tfloat bounds = sdSphere(pos1 - vec3(0.9, 0.0, 0.0), 1.0);\n\tif (bounds > 0.2) return vec2(bounds, 0.0); // optimization\n\n\t// upper arm\n\tpos1.x -= 0.38;\n\td1 = sdEllipsoid(pos1 - vec3(0.52, 0.0, 0.0), vec3(0.54, 0.38, 0.38));\n\n\t// forearm\n\tpos1.x -= 0.77;\n\tpos1 = rotate_xzy(pos1, elbowAngle);\n\td2 = sdEllipsoid(pos1 - vec3(0.26, 0.0, 0.0), vec3(0.32, 0.26, 0.26));\n\td1 = smin(d1, d2, 0.1);\n\n\t// palm\n\tpos1.x -= 0.15;\n\tpos1 = rotate_xzy(pos1, wristAngle);\n\td2 = sdEllipsoid(pos1 - vec3(0.3, 0.0, 0.0), vec3(0.2, 0.22, 0.15));\n\td1 = smin(d1, d2, 0.1);\n\n\t// palm bend\n\td2 = sdEllipsoid(pos1 - vec3(0.4, 0.0, -0.2), vec3(0.05, 0.25, 0.07));\n\td1 = smax(d1, -d2, 0.1);\n\n\t// fingers\n\tpos2 = rotate_yzx(pos1, vec3(0.0, -0.4, 0.6));\n\tpos2 -= vec3(0.38, 0.0, 0.1);\n\tpos2 = rotate_yzx(pos2, fingersAngle * vec3(0.0, -1.5, -0.5));\n\td2 = sdEllipsoid(pos2 - vec3(0.05, 0.0, 0.0), vec3(0.1, 0.06, 0.06)); // thumb\n\n\tfloat spreadAngle = 0.2;\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tpos2 = rotate_yzx(pos1, vec3(-0.3, -0.4, float(i) * spreadAngle - 0.5));\n\t\tpos2 -= vec3(0.4, 0.0, 0.15);\n\t\tpos2 = rotate_yzx(pos2, fingersAngle * vec3(0.0, -1.3, 0.0));\n\t\td3 = sdEllipsoid(pos2 - vec3(0.05, 0.0, 0.0), vec3(0.1, 0.06, 0.06)); // finger\n\t\td2 = min(d2, d3);\n\t}\n\td1 = smin(d1, d2, 0.06);\n\n\treturn vec2(d1, MATERIAL_SKIN);\n}\n\nvec2 sdLeg(in vec3 pos, vec3 legAngle, float kneeAngle, vec3 footAngle)\n{\n\tfloat d1, d2, d3;\n\tvec3 pos1, pos2;\n\tfloat s = 1.15; // scale\n\n\tpos1 = pos;\n\n\tpos1.xz = rotate(pos1.xz, legAngle.y);\n\tpos1.yz = rotate(pos1.yz, legAngle.x);\n\tpos1.xy = rotate(pos1.xy, legAngle.z);\n\n\tfloat bounds = sdSphere(pos1 - vec3(0.0, -1.0, 0.0), 1.0);\n\tif (bounds > 0.2) return vec2(bounds, 0.0); // optimization\n\n\t// thigh\n\tpos1.y += 0.3 * s;\n\td1 = sdEllipsoid(pos1 + vec3(0.0, 0.3 * s, 0.0), vec3(0.4, 0.6, 0.4) * s);\n\n\t// shin\n\tpos1.y += 0.6 * s;\n\tpos1.yz = rotate(pos1.yz, kneeAngle);\n\td2 = sdEllipsoid(pos1 + vec3(0.0, 0.2 * s, 0.0), vec3(0.3, 0.34, 0.3) * s);\n\td1 = smin(d1, d2, 0.1);\n\n\t// foot\n\tpos1 += vec3(0.0, 0.38, -0.13) * s;\n\tpos1 = rotate_yzx(pos1, footAngle);\n\td2 = sdEllipsoid(pos1 + vec3(0.0, 0.0, 0.3) * s, vec3(0.22, 0.15, 0.25) * s * 1.2);\n\td1 = smin(d1, d2, 0.1);\n\n\td2 = sdEllipsoid(pos1 + vec3(0.0, 0.3, 0.3) * s, vec3(0.4, 0.2, 0.5) * s);\n\td1 = smax(d1, -d2, 0.1);\n\n\treturn vec2(d1, MATERIAL_SKIN);\n}\n\nvec2 sdTail(in vec3 pos, vec3 angle)\n{\n\tfloat bounds = sdSphere(pos - vec3(0.0, -0.4, 0.7), 1.0);\n\tif (bounds > 0.2) return vec2(bounds, 0.0); // optimization\n\n\tvec3 pos1 = pos;\n\n\tpos1 = pos;\n\tpos1 = rotate_yzx(pos1, angle);\n\tpos1.y = -pos1.y;\n\n\tfloat d1 = sdArc(pos1, 1.6, 0.7, 0.1, 0.04);\n\n\tpos1 += vec3(-0.93, -1.13, 0.0);\n\tpos1.xy = rotate(pos1.xy, -1.2);\n\tfloat d2 = sdArc(pos1, 0.2, 0.4, 0.15, 0.5);\n\td1 = smin(d1, d2, 0.1);\n\n\treturn vec2(d1, MATERIAL_SKIN);\n}\n\nvec2 sdEyelids(in vec3 pos, float openFactor, vec3 direction)\n{\n\tpos.x = abs(pos.x);\n\tpos.x -= 0.28;\n\n\tfloat bounds = sdSphere(pos, 0.3);\n\tif (bounds > 0.2) return vec2(bounds, 0.0); // optimization\n\n\tfloat s = 1.1;\n\n\tfloat eyelidsBounds = sdSphere(pos, 0.18 * s);\n\n\t// eyelids\n\tvec3 pos1 = pos;\n\tfloat directionBias = direction.z * openFactor;\n\tpos1.xy = rotate(pos1.xy, -0.3 - 0.2 * directionBias);\n\tpos1.yz = rotate(pos1.yz, -0.4 - 0.3 * openFactor + 0.5 * directionBias); // eyelids meeting angle\n\tpos1.z = abs(pos1.z);\n\tpos1.y += 0.5;\n\tpos1.yz = rotate(pos1.yz, 0.1 + 0.4 * openFactor);\n\tpos1.y -= 0.5;\n\tfloat d = smax(sdEllipsoid(pos1, vec3(0.17 * s)), eyelidsBounds, 0.01);\n\n\treturn vec2(d, MATERIAL_SKIN);\n}\n\nvec2 sdEyes(in vec3 pos, vec3 direction)\n{\n\tdirection.x *= sign(pos.x);\n\tpos.x = abs(pos.x);\n\tpos.x -= 0.28;\n\n\tfloat bounds = sdSphere(pos, 0.3);\n\tif (bounds > 0.2) return vec2(bounds, 0.0); // optimization\n\n\tfloat s = 1.1;\n\n\t// pupil distance\n\tfloat dist = length(pos - normalize(vec3(0.4, 1.0, -1.0) + direction));\n\n\t// eye\n\tfloat pupilSize = 0.87;\n\tfloat d = sdSphere(pos, 0.15 * s);\n\tfloat m = MATERIAL_EYE + step(dist, pupilSize) * (1.0 + 2.0 * (pupilSize - dist));\n\n\treturn vec2(d, m);\n}\n\nvec2 sdEyebrows(in vec3 pos, float height)\n{\n\tpos.x = abs(pos.x);\n\n\tpos.yz = rotate(pos.yz, 0.3);\n\tpos -= vec3(0.25, 0.46, -0.01);\n\tpos -= vec3(0.02, 0.2, 0.07) * height;\n\tpos.yz = rotate(pos.yz, 0.95);\n\tpos.xy = rotate(pos.xy, 0.2 - 0.1 * height);\n\tfloat d = sdEllipsoid(pos, vec3(0.25, 0.08, 0.25)) ;\n\n\treturn vec2(d, MATERIAL_SKIN);\n}\n\nvec2 sdMouth(in vec3 pos)\n{\n\tfloat d1, d2;\n\tfloat s = 0.2;\n\td1 = sdEllipsoid(pos, vec3(1.0 * s));\n\td2 = sdEllipsoid(pos + vec3(0.0, 0.0, -2.0) * s, vec3(2.0 * s));\n\td1 = smax(d1, d2, 0.1);\n\treturn vec2(d1, MATERIAL_MOUTH);\n}\n\nvec2 sdMoomin(in vec3 pos, inout Pose pose)\n{\n\tvec2 d1, d2, d3;\n\tvec3 pos1, pos2;\n\n\tpos += pose.offset;\n\tpos = rotate_xzy(pos, pose.rotation);\n\tpos.y -= 1.2;\n\tpos.z += 1.5;\n\n\tfloat bounds = MAX_DIST;\n\tbounds = min(bounds, sdSphere(pos - vec3(0.0, 2.0, 1.0), 1.6));\n\tbounds = min(bounds, sdSphere(pos - vec3(0.0, 0.2, 1.6), 2.2));\n\tbounds = min(bounds, sdSphere(pos - vec3(0.0, -0.0, 4.2), 1.4));\n\tif (bounds > 0.2) return vec2(bounds, 0.0); // optimization\n\n\t// head\n\tpos1 = pos - vec3(0.0, 1.6, 1.0);\n\tpos1 = rotate_yzx(pos1, pose.headRotation1 + vec3(0.4, 0.0, 0.0)); // head rotation\n\tpos1.y -= 0.3;\n\n\t// jaw\n\td1.x = sdEllipsoid(pos1 - vec3(0.0, -0.35, -0.7), vec3(0.65, 0.65, 0.7));\n\td2.x = sdEllipsoid(pos1 - vec3(0.0, -1.1, -0.5), vec3(1.2));\n\td1 = smax(d1, d2, 0.1);\n\n\td2.x = sdEllipsoid(pos1 - vec3(0.0, -0.2, -0.5), vec3(0.6, 0.3, 0.4) * (1.0 + 0.1 * pose.cheeksFactor));\n\td1 = smin(d1, d2, 0.25);\n\n\t// skull\n\tpos2 = pos1;\n\tpos2.yz = rotate(pos2.yz, pose.headRotation2); // head rotation\n\td2.x = sdEllipsoid(pos2 - vec3y(0.04), vec3(0.7, 0.91, 0.7));\n\td1 = smin(d1, d2, 0.2);\n\n\tpos2.yz = rotate(pos2.yz, 0.5);\n\tpos2 += vec3(0.0, 0.4, 0.1);\n\td2.x = sdEllipsoid(pos2, vec3(0.6, 0.6, 0.4));\n\n\td1 = smin(d1, d2, 0.2);\n\td1.y = MATERIAL_SKIN;\n\n#ifdef RENDER_EYES\n\tpos2 = pos1 - vec3(0.0, 0.05, -0.6);\n\n\t// eyes sockets\n\td2.x = sdSphere(vec3(abs(pos2.x) - 0.28, pos2.yz), 0.10);\n\td1.x = smax(d1.x, -d2.x, 0.2);\n\n\t// eyelids\n\td2 = sdEyelids(pos2 + vec3(0.0, 0.02, 0.0), pose.eyesOpenFactor, pose.eyesDirection);\n\td1 = smin(d1, d2, 0.09);\n\n\t// eyes\n\td2 = sdEyes(pos2 + vec3(0.0, 0.02, 0.0), pose.eyesDirection);\n\td1 = smin(d1, d2, 0.02);\n\n\td2 = sdEyebrows(pos2 + vec3(0.0, 0.3, 0.0), pose.eyebrowsHeight);\n\td1 = smin(d1, d2, 0.03);\n#endif\n\n#ifdef RENDER_EARS\n\t// ears\n\td2 = sdEars(pos1, pose.earsAngle);\n\td1 = smin(d1, d2, 0.05);\n#endif\n\n#ifdef RENDER_MOUTH\n\t// mouth\n\td2 = sdMouth(pos1 + vec3(0.0, 1.1 - 0.1 * pose.mouthFactor, 0.3));\n\td1 = smax(d1, vec2(-d2.x, d2.y), 0.04);\n#endif\n\n\tfloat t = 0.9; // taper\n\n\t// body\n\tpos1 = pos - vec3(0.0, 1.7, 1.1);\n\tpos1 = rotate_yzx(pos1,  pose.bodyRotation); // body rotation\n\n\tfloat y;\n\n\t// neck\n\ty = 0.5;\n\tpos2 = rotate_yzx(pos1, pose.bodyCurve * y);\n\tpos2.y += y;\n\td2 = vec2(sdSphere(pos2, 0.41 * (t + y)), MATERIAL_SKIN);\n\td1 = smin(d1, d2, 0.2);\n\n\td2 = vec2(sdEllipsoid(pos2 - vec3(0.0, -0.1, 0.1), vec3(0.6, 1.2, 0.7)), MATERIAL_SKIN);\n\td1 = smin(d1, d2, 0.2);\n\n\t// shoulders\n\ty = 1.0;\n\tpos2 = rotate_yzx(pos1, pose.bodyCurve * y);\n\tpos2.y += y;\n\td2 = vec2(sdSphere(pos2, 0.41 * (t + y)), MATERIAL_SKIN);\n\td1 = smin(d1, d2, 0.2);\n\n\t// ribcage\n\ty = 1.6;\n\tpos2 = rotate_yzx(pos1, pose.bodyCurve * y);\n\tpos2.y += y;\n\td2 = vec2(sdSphere(pos2, 0.41 * (t + y)), MATERIAL_SKIN);\n\td1 = smin(d1, d2, 0.2);\n\n\t// belly\n\ty = 1.9;\n\tpos2 = rotate_yzx(pos1, pose.bodyCurve * y);\n\tpos2.y += y;\n\n\tfloat bellyStretch = 0.09 * abs(pose.leftLeg.legAngle.x - pose.rightLeg.legAngle.x);\n\td2 = vec2(sdEllipsoid(pos2 - vec3y(bellyStretch), 0.41 * (t + y) * vec3(1.0, 1.0 - bellyStretch, 1.0)), MATERIAL_SKIN);\n\td1 = smin(d1, d2, 0.1);\n\n#ifdef RENDER_ARMS\n\t// arms\n\ty = 0.9;\n\tvec3 armsPos = rotate_yzx(pos1, pose.bodyCurve * y);\n\tarmsPos.y += y;\n\tvec3 armOffset = vec3(0.0, 0.0, 0.2);\n\n\t// right arm\n\tpos2 = armsPos - armOffset;\n\td2 = sdArm(pos2, pose.rightArm.armAngle, pose.rightArm.elbowAngle, pose.rightArm.wristAngle, pose.rightArm.fingersAngle);\n\n\t// left arm\n\tpos2 = vec3(-armsPos.x, armsPos.yz) - armOffset; // mirror\n\td3 = sdArm(pos2, pose.leftArm.armAngle, pose.leftArm.elbowAngle, pose.leftArm.wristAngle, pose.leftArm.fingersAngle);\n\td2 = min2(d2, d3);\n\n\td1 = smin(d1, d2, 0.08);\n#endif\n\n#ifdef RENDER_LEGS\n\t// legs\n\ty = 1.8;\n\tvec3 legsPos = rotate_yzx(pos1, pose.bodyCurve * y);\n\tlegsPos.y += y;\n\tvec3 legOffset = vec3(0.4, 0.0, 0.0);\n\n\t// right leg\n\tpos2 = legsPos - legOffset;\n\td2 = sdLeg(pos2, pose.rightLeg.legAngle, pose.rightLeg.kneeAngle, pose.rightLeg.footAngle);\n\n\t// left leg\n\tpos2 = vec3(-legsPos.x, legsPos.yz) - legOffset; // mirror\n\td3 = sdLeg(pos2, pose.leftLeg.legAngle, pose.leftLeg.kneeAngle, pose.leftLeg.footAngle);\n\td2 = min2(d2, d3);\n#endif\n\n#ifdef RENDER_TAIL\n\t// tail \n\ty = 2.6;\n\tvec3 tailPos = rotate_yzx(pos1, pose.bodyCurve * y);\n\ttailPos.y += y - 0.5 * bellyStretch;\n\ttailPos.z -= 0.6 - 0.5 * bellyStretch;\n\n\td3 = sdTail(tailPos, pose.tailRotation + vec3(0.0, 1.57, 0.2));\n\n\td2 = min2(d2, d3);\n#endif\n\n\td1 = smin(d1, d2, 0.1);\n\n\treturn d1;\n}\n\nvec2 sdGrass(in vec3 pos)\n{\n\tfloat height = getGroundHeight(pos);\n\tvec2 d1 = vec2(sdSurface(pos - vec3(0.0, height, 0.0)), MATERIAL_GRASS);\n\treturn d1;\n}\n\nfloat getSkyTextureCloud(in vec2 uv)\n{\n\treturn fbm(vec3(uv + 10.0, 0.0)) * 1.8;\n}\n\nvec4 getCloudPosIndex(in vec2 uv, float time, float offset)\n{\n\ttime *= CLOUDS_SPEED + 0.2 * offset;\n\ttime += 1000.0 * offset;\n\n\tfloat grid = 32.0;\n\n\tfloat index = floor((uv.y + time) / grid);\n\n\tfloat origin = index * grid;\n\tfloat p = 0.05 * (origin - 1.2 * time);\n\tvec2 pos = uv;\n\n\tpos.y -= origin - time;\n\tpos.y -= 0.5 * grid;\n\tpos.x *= 1.2; // stretch\n\tpos.x += 8.0 * sin(p) + 5.0 * sin(2.0 * p + 2.0) + sin(3.0 * p + 2.0);\n\n\treturn vec4(pos.x, 0.0, pos.y, index);\n}\n\nvec3 getSkyTexture(in vec3 rd)\n{\n\tvec3 color = vec3(0.05, 0.4, 0.95);\n\n\tvec2 uv = rd.xz / rd.y; // uv map\n\tfloat cloud = getSkyTextureCloud(uv);\n\tvec3 cloudColor = mix(vec3(1.0, 0.75, 1.0), vec3(0.6, 0.3, 0.6), (cloud - 0.5) * 0.3);\n\n\tcolor = mix(color, cloudColor, clamp((cloud - 1.0) * 10.0, 0.0, 1.0));\n\n\t// fog\n\tcolor = mix(color, vec3(0.5, 0.85, 0.95), clamp(1.0 - 2.0 * rd.y, 0.0, 1.0));\n\n\treturn color;\n}\n\nvec2 sdFlowers(in vec3 pos)\n{\n\tfloat grid = 2.0;\n\tvec2 cellIndex = floor(pos.xz / grid);\n\tfloat h1 = hash(cellIndex);\n\tif (h1 < 0.9)\n\t{\n\t\treturn vec2(MAX_DIST, 0.0);\n\t}\n\n\tfloat h2 = hash(cellIndex + 0.1);\n\n\tvec3 cellOrigin = vec3(grid * (cellIndex.x + 0.5), 0.0, grid * (cellIndex.y + 0.5));\n\tcellOrigin.xz += 0.2 * grid * (h2 * 2.0 - 1.0);\n\tcellOrigin.y = getGroundHeight(cellOrigin);\n\n\tvec3 pos1 = pos - cellOrigin;\n\tfloat bounds = length(pos1) - 0.3;\n\tif (bounds > 0.3) return vec2(bounds, 0.0); // optimization\n\n\tfloat h3 = hash(cellIndex + 0.2);\n\tfloat h4 = hash(cellIndex + 0.3);\n\n\tfloat hx = getGroundHeight(cellOrigin - vec3(SURF_DIST, 0.0, 0.0));\n\tfloat hz = getGroundHeight(cellOrigin - vec3(0.0, 0.0, SURF_DIST));\n\tpos1.xy = rotate(pos1.xy, -atan(hx - cellOrigin.y, SURF_DIST));\n\tpos1.yz = rotate(pos1.yz, atan(hz - cellOrigin.y, SURF_DIST));\n\tpos1.xz = rotate(pos1.xz, PI * h4);\n\n\tfloat stemLength = 0.1 + 0.3 * h3;\n\tfloat s = 0.3 + 0.5 * h4;\n\n\tvec2 d1 = vec2(length(pos1.xz) - 0.05 * s, MATERIAL_STEM);\n\tvec2 d2 = vec2(pos1.y - stemLength * s, MATERIAL_STEM);\n\n\tpos1.y -= stemLength * s;\n\td1 = max2(d1, d2);\n\td2 = vec2(sdSphere(pos1, 0.1 * s), MATERIAL_FLOWER2);\n\td1 = min2(d1, d2);\n\n\tvec3 pos2 = pos1;\n\tpos2.y += 0.07 * s;\n\n\tfloat a = atan(pos2.x, pos2.z);\n\tfloat l = length(pos2.xz);\n\n\ta = mod(a, PI2 / 5.0) - PI2 / 10.0;\n\tpos2.x = l * cos(a);\n\tpos2.z = l * sin(a);\n\tpos2.xy = rotate(pos2.xy, 0.4);\n\n\td2 = vec2(sdEllipsoid(pos2 - vec3(0.07 + s * 0.1, 0.0, 0.0), s * 0.2 * vec3(1.5 , 0.3, 1.0)), MATERIAL_FLOWER1);\n\td1 = min2(d1, d2);\n\n\treturn d1;\n}\n\nvec2 sdMountains(in vec3 pos)\n{\n\tfloat bounds = 80.0 - length(pos);\n\tif (bounds > 20.0) return vec2(bounds, 0.0); // optimization\n\n\tvec3 pos1 = pos;\n\n\tfloat a = atan(pos1.x, pos1.z);\n\tfloat l = length(pos1.xz);\n\n\tfloat c = 8.0;\n\tfloat index = floor(c * a / PI2);\n\n\tfloat h1 = hash(index + 0.1) * 2.0 - 1.0;\n\tfloat h2 = hash(index + 0.2) * 2.0 - 1.0;\n\tfloat h3 = hash(index + 0.3);\n\tfloat h4 = hash(index + 0.4);\n\n\ta = mod(a, PI2 / c) - PI / c;\n\ta += h2 * 0.1;\n\n\tpos1.x = l * cos(a);\n\tpos1.z = l * sin(a);\n\n\tpos1.x -= 102.0;\n\tpos1.y += 5.0;\n\tpos1.yz = rotate(pos1.yz, 0.5 * h2);\n\n\tfloat d1 = sdEllipsoid(pos1, 12.0 * (vec3(1.0) + vec3(1.0, h3 * 0.5, h4 * 2.0)));\n\n\tif (d1 < 5.0)\n\t{\n\t\tpos1 = pos * 0.23;\n\t\td1 += 2.0 * (sin(pos1.x) + sin(pos1.z));\n\t\td1 *= 0.8;\n\t}\n\n\treturn vec2(d1, MATERIAL_MOUNTAIN);\n}\n\nvec2 sdTrees(in vec3 pos)\n{\n\tfloat bounds = 55.0 - abs(pos.x);\n\tif (bounds > 1.0) return vec2(bounds, 0.0); // optimization\n\n\tvec2 grid = vec2(130.0, 20.0);\n\tvec2 cellIndex = floor(pos.xz / grid);\n\tif (abs(cellIndex.x + 0.5) > 1.0)\n\t{\n\t\treturn vec2(MAX_DIST, 0.0);\n\t}\n\n\tfloat h1 = hash(cellIndex);\n\tif (h1 > 0.8)\n\t{\n\t\treturn vec2(MAX_DIST, 0.0);\n\t}\n\n\tfloat h2 = hash(cellIndex + 0.1) * 2.0 - 1.0;\n\tfloat h3 = hash(cellIndex + 0.2) * 2.0 - 1.0;\n\n\tvec3 cellOrigin = vec3(grid.x * (cellIndex.x + 0.5), 0.0, grid.y * (cellIndex.y + 0.5));\n\tcellOrigin.x += 4.0 * h2;\n\tcellOrigin.z += 5.0 * h3;\n\n\tbounds = length(pos.xz - cellOrigin.xz) - 4.0;\n\tif (bounds > 1.0) return vec2(bounds, 0.0); // optimization\n\n\tcellOrigin.y = getGroundHeight(cellOrigin);\n\n\tvec3 pos1 = pos - cellOrigin;\n\n\tfloat h4 = hash(cellIndex + 0.3) * 2.0 - 1.0;\n\tfloat h5 = hash(cellIndex + 0.4) * 2.0 - 1.0;\n\tpos1.yz = rotate(pos1.yz, 0.2 * h4);\n\tpos1.xy = rotate(pos1.xy, 0.2 * h5);\n\n\tfloat s = 0.8 + 0.2 * h4;\n\tvec3 pos2 = pos1;\n\n\tvec2 d1 = vec2(sdCone(pos2 - vec3y(11.0 * s), vec2(0.866, 0.5), 5.0 * s), MATERIAL_TREE1);\n\tvec2 d2 = vec2(sdCone(pos2 - vec3y(8.5 * s), vec2(0.866, 0.5), 6.5 * s), MATERIAL_TREE1);\n\td1 = min2(d1, d2);\n\n\td2 = vec2(length(pos1.xz) - 0.5 * s, MATERIAL_TREE2);\n\tfloat d3 = pos1.y - 2.0 * s;\n\td2.x = max(d2.x, d3);\n\n\td1 = min2(d1, d2);\n\n\treturn d1;\n}\n\nfloat mapClouds(in vec3 pos, float time)\n{\n\tfloat d1, d2;\n\n\tvec4 pi = getCloudPosIndex(pos.xz + vec2(0.0, 0.0), time, 0.0);\n\tvec3 pos1 = vec3(pi.x, pos.y - (CLOUDS_HEIGHT - 3.0), pi.z);\n\td1 = sdEllipsoid(pos1, vec3(4.0, 2.0, 4.0));\n\n\tpi = getCloudPosIndex(pos.xz - vec2(0.0, 0.0), time, 1.0);\n\tpos1 = vec3(pi.x, pos.y - (CLOUDS_HEIGHT + 3.0), pi.z);\n\td2 = sdEllipsoid(pos1, vec3(4.0, 2.0, 4.0));\n\td1 = min(d1, d2);\n\n\treturn d1;\n}\n\nvec2 map(in vec3 pos, float time, inout Pose pose, bool includeClouds)\n{\n\tvec2 d1, d2;\n\n\td1 = vec2(MAX_DIST, 0.0);\n\n#ifdef RENDER_MOOMIN\n\td1 = sdMoomin(pos, pose);\n#endif\n\n#ifdef RENDER_FLOWERS\n\td2 = sdFlowers(pos);\n\td1 = min2(d1, d2);\n#endif\n\n#ifdef RENDER_MOUNTAINS\n\td2 = sdMountains(pos + vec3z(pose.offset.z));\n\td1 = min2(d1, d2);\n#endif\n\n#ifdef RENDER_TREES\n\td2 = sdTrees(pos);\n\td1 = min2(d1, d2);\n#endif\n\n\td2 = sdGrass(pos); \n\td1 = min2(d1, d2);\n \n#ifdef RENDER_CLOUDS\n\tif (includeClouds)\n\t{\n\t\td2 = vec2(mapClouds(pos, time), MATERIAL_CLOUD);\n\t\td1 = min2(d1, d2);\n\t}\n#endif\n\n\treturn d1;\n}\n\n// inspired by iq, tdhooper, and klems - a way to prevent the compiler from inlining map() 4 times\nvec3 getNormal(in vec3 pos, float time, inout Pose pose)\n{\n\tvec3 n = vec3(0.0);\n\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tvec3 e = 0.5773 * (2.0 * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.0);\n\t\tn += e * map(pos + 0.0005 * e, time, pose, false).x;\n\t}\n\n\treturn normalize(n);\n}\n\nvec2 castRay(in vec3 ro, vec3 rd, float time, inout Pose pose, bool includeClouds) // ray origin, ray direction\n{\n\tfloat d = 0.0; // distance from ray origin\n\tfloat m = 0.0; // material\n\n\tfor (int i = 0; i < MAX_STEPS; i++)\n\t{\n\t\tvec3 pos = ro + rd * d; // current position\n\t\tvec2 dm = map(pos, time, pose, includeClouds); // distance from current position to the scene\n\t\tm = dm.y;\n\n\t\tif (abs(dm.x) < SURF_DIST)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\td += dm.x;\n\n\t\tif (d > MAX_DIST)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn vec2(d, m);\n}\n\nfloat castCloudsRay(in vec3 ro, vec3 rd, float time) // ray origin, ray direction\n{\n\tfloat d = 0.0; // distance from ray origin\n\n\tfor (int i = 0; i < MAX_STEPS; i++)\n\t{\n\t\tvec3 pos = ro + rd * d; // current position\n\t\tfloat d1 = mapClouds(pos, time); // distance from current position to the scene\n\n\t\tif (abs(d1) < SURF_DIST)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\td += d1;\n\n\t\tif (d > MAX_DIST)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn d;\n}\n\nfloat calcOcclusion(in vec3 pos, float time, vec3 nor, inout Pose pose)\n{\n\tfloat occlusion = 0.0; // occlusion\n\tfloat scale = 1.0; // scale\n\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tfloat h = 0.01 + 0.11 * float(i) / 4.0;\n\t\tvec3 occlusionPos = pos + h * nor; // occlusion position\n\t\tfloat d = map(occlusionPos, time, pose, false).x;\n\t\tocclusion += (h - d) * scale;\n\t\tscale *= 0.95;\n\t}\n\n\treturn clamp(1.0 - 2.0 * occlusion, 0.0, 1.0);\n}\n\nfloat castShadow(in vec3 ro, vec3 rd, float time, inout Pose pose)\n{\n\tfloat result = 1.0;\n\tfloat t = 0.01; // position\n\n\tfloat maxT = MAX_DIST;\n\n\tfor (int i = 0; i < MAX_STEPS; i++)\n\t{\n\t\tvec3 pos = ro + t * rd;\n\t\tvec2 d = map(pos, time, pose, true);\n\t\tif (d.y > 0.0) // skip optimizations\n\t\t{\n\t\t\tresult = min(result, max(0.0, 16.0 * d.x / t)); // soft shadow\n\t\t}\n\n\t\tt += d.x;\n\n\t\tif (abs(d.x) < (t * 0.001) || t > maxT)\n\t\t\tbreak;\n\t}\n\n\treturn result;\n}\n\nvec3 getMaterialColor(in vec2 dm, vec3 pos, vec3 nor, vec3 rd, float time, inout Pose pose)\n{\n\tvec3 color = vec3(0.0);\n\n\tvec3 posOffset = pos + nor * SURF_DIST; // point with a small offset\n\tvec3 material;\n\n\tif (dm.y < 0.5)\n\t{\n\t\tmaterial = vec3(1.0, 1.0, 0.0); // missing\n\t}\n\telse if (dm.y < MATERIAL_SKIN + 0.5)\n\t{\n\t\tmaterial = vec3(0.3, 0.3, 0.35);\n\t}\n\telse if (dm.y < MATERIAL_EAR + 0.5)\n\t{\n\t\tmaterial = vec3(0.5, 0.3, 0.3);\n\t}\n\telse if (dm.y < MATERIAL_EYE + 0.5)\n\t{\n\t\tmaterial = vec3(0.4);\n\t}\n\telse if (dm.y < MATERIAL_PUPIL + 0.5)\n\t{\n\t\tmaterial = vec3(0.02, 0.15, 0.6) * (0.2 + 0.8 * step(dm.y, MATERIAL_PUPIL + 0.06));\n\t}\n\telse if (dm.y < MATERIAL_MOUTH + 0.5)\n\t{\n\t\tmaterial = vec3(0.3, 0.15, 0.15);\n\t}\n\telse if (dm.y < MATERIAL_GRASS + 0.5)\n\t{\n\t\tmaterial = vec3(0.25, 0.25, 0.0);\n\t}\n\telse if (dm.y < MATERIAL_FLOWER1 + 0.5)\n\t{\n\t\tmaterial = vec3(0.5);\n\t}\n\telse if (dm.y < MATERIAL_FLOWER2 + 0.5)\n\t{\n\t\tmaterial = vec3(0.5, 0.4, 0.0);\n\t}\n\telse if (dm.y < MATERIAL_STEM + 0.5)\n\t{\n\t\tmaterial = vec3(0.2, 0.4, 0.0);\n\t}\n\telse if (dm.y < MATERIAL_MOUNTAIN + 0.5)\n\t{\n\t\tmaterial = vec3(0.2, 0.3, 0.5);\n\t}\n\telse if (dm.y < MATERIAL_TREE1 + 0.5)\n\t{\n\t\tmaterial = vec3(0.04, 0.15, 0.1);\n\t}\n\telse if (dm.y < MATERIAL_TREE2 + 0.5)\n\t{\n\t\tmaterial = vec3(0.3, 0.05, 0.0);\n\t}\n\telse if (dm.y < MATERIAL_CLOUD + 0.5)\n\t{\n\t\tmaterial = vec3(0.6, 0.4, 0.5);\n\t}\n\n\tfloat occlusion = calcOcclusion(pos, time, nor, pose);\n\tfloat fresnel = clamp(1.0 + dot(rd, nor), 0.0, 1.0); // fresnel\n\n\t// sun\n\tfloat sunDiffuse = clamp(dot(nor, SUN_DIRECTION), 0.0, 1.0);\n\tfloat sunShadow = castShadow(posOffset, SUN_DIRECTION, time, pose);\n\n\tfloat bounceDiff = clamp(0.5 + 0.5 * dot(nor, vec3(0.0, -1.0, 0.0)), 0.0, 1.0); // bounce diffuse, from the ground\n\n\tvec3 sunLight = sunDiffuse * 4.0 * vec3(0.7, 0.4, 0.3); // sun color\n\tsunLight *= vec3(sunShadow, pow(sunShadow, 2.0), pow(sunShadow, 4.0)); // sun shadow transition color\n\tsunLight += vec3(0.25, 0.25, 0.0) * bounceDiff; // bounce light\n\tsunLight += fresnel * 3.0 * vec3(0.6, 0.8, 1.2) * (0.5 + 0.5 * sunDiffuse) * (0.9 + 0.1 * clamp(sunShadow, 0.0, 1.0)); // sun fresnel\n\n\t// sky light\n\tvec3 skyDirection = normalize(vec3(0.0, 1.0, 0.0));\n\tfloat skyDiffuse = clamp(0.5 + 0.5 * dot(nor, skyDirection), 0.0, 1.0); // sky diffuse\n\tfloat skyReflection = smoothstep(0.3, 0.5, reflect(rd, nor).y); // sky reflection\n\tvec3 skyColor = vec3(0.1, 0.8, 1.0);\n\tvec3 skyLight = 0.3 * skyDiffuse * skyColor + 0.02 * skyReflection * skyColor;\n\n\tfloat fog = pow(smoothstep(5.0, 80.0, dm.x), 2.0);\n\tfog *= clamp(1.0 - rd.y * 6.0, 0.0, 1.0);\n\n\tcolor = material;\n\tcolor *= sunLight;\n\tcolor += skyLight;\n\tcolor *= occlusion;\n\tcolor = mix(color, vec3(0.5, 0.85, 0.95), fog);\n\n\treturn color;\n}\n\nfloat getCloudDensity(vec3 pos, float time)\n{\n\tvec4 pi = getCloudPosIndex(pos.xz, time, step(CLOUDS_HEIGHT, pos.y));\n\tvec3 pos1 = vec3(pi.x, pos.y, pi.z * 0.7);\n\tfloat index = pi.w;\n\n\tpos1.z += pos.z * 0.5;\n\tfloat density = fbm(0.55 * (pos1 + vec3(index * 10.0))) - 0.1;\n\tdensity *= 0.2;\n\tdensity *= smoothstep(0.0, -1.5, mapClouds(pos, time)); // shape mask\n\n\treturn clamp(density, 0.0, 1.0);\n}\n\nvec3 composeClouds(vec3 ro, vec3 rd, float time, float d, vec3 color)\n{\n\tfloat cd = castCloudsRay(ro, rd, time); // cloud distance\n\n\tfloat f = 1.0; // composition factor\n\tf -= 0.008 * max(cd - 40.0, 0.0); // clouds distance fog\n\n\tfor (int i = 0; i < 2; i++) // number of overlapping clouds\n\t{\n\t\tif (cd >= d || cd >= MAX_DIST)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tfloat stepSize = 0.1;\n\t\tfor (int j = 0; j < 100; j++) // steps\n\t\t{\n\t\t\tif (cd >= d || f < 0.0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvec3 pos = ro + cd * rd;\n\n\t\t\tfloat density = getCloudDensity(pos, time);\n\t\t\tfloat density2 = 0.5 * (\n\t\t\t\tgetCloudDensity(pos + 0.1 * SUN_DIRECTION, time) +\n\t\t\t\tgetCloudDensity(pos + 0.2 * SUN_DIRECTION, time));\n\n\t\t\tvec3 stepColor = vec3(1.0, 0.5, 0.6);\n\t\t\tstepColor = mix(vec3(1.2), stepColor, clamp(density2 * 15.0, 0.0, 1.0)); // light\n\t\t\tstepColor = mix(vec3(0.2, 0.0, 0.1), stepColor, clamp(1.0 - density2 * 6.0, 0.0, 1.0)); // shadow\n\n\t\t\tcolor = mix(color , stepColor, density * f * 3.0);\n\t\t\tf -= density;\n\n\t\t\tcd += stepSize;\n\t\t}\n\n\t\tcd += castCloudsRay(ro + cd * rd, rd, time);\n\t}\n\n\treturn color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat time = iTime;\n\ttime += 0.2;\n\ttime *= ANIMATION_SPEED;\n\n\tvec2 uv = -1.0 + 2.0 * fragCoord/iResolution.xy;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tvec3 target = vec3(0.0, 1.0 + CAMERA_HEIGHT, -RUN_SPEED * time); // camera target\n\tfloat dist = 8.0 + CAMERA_DISTANCE; // camera distance\n\n\tfloat fov = 1.5; // field of view\n\n\tvec3 ro = vec3(0.0, 1.5 + CAMERA_HEIGHT, dist); // camera origin\n\n\tif (iMouse.z < 0.5)\n\t{\n\t\tvec2 an = vec2(-3.0 * sin(3.5 + time * 0.1), -0.7 + 0.5 * sin(1.0 + time * 0.2));\n\t\tdist = 10.0 + CAMERA_DISTANCE + 2.0 * sin(time * 0.3);\n\t\tfov = 1.2;\n\n\t\tvec3 dir = normalize(vec3(0.1, 0.3, 0.4)); // camera direction\n\t\tdir.yz = rotate(dir.yz, an.y);\n\t\tdir.xz = rotate(dir.xz, an.x);\n\t\tro = target + dir * dist;\n\t}\n\telse\n\t{\n\t\t// mouse camera angle\n\t\tvec2 an = vec2(3.0 + 12.0 * iMouse.x / iResolution.x, -3.0 * clamp(iMouse.y / iResolution.y, 0.0, 1.0));\n\n\t\tdist = 5.5 + CAMERA_DISTANCE + 2.0 * sin(time * 0.3);\n\t\tfov = 1.2;\n\n\t\tvec3 dir = normalize(vec3(0.1, 0.3, 0.4)); // camera direction\n\t\tdir.yz = rotate(dir.yz, an.y);\n\t\tdir.xz = rotate(dir.xz, an.x);\n\t\tro = target + dir * dist;\n\t}\n\n\tro.y = max(getGroundHeight(vec3(ro.x, 0.0, ro.z)) + 0.1, ro.y);\n\n\t// camera direction\n\tvec3 rdz = normalize(target - ro);\n\tvec3 rdx = normalize(cross(rdz, vec3(0.0, 1.0, 0.0)));\n\tvec3 rdy = cross(rdx, rdz);\n\tvec3 rd = normalize(uv.x * rdx + uv.y * rdy + fov * rdz);\n\n\tPose pose = getPose(time);\n\n\tvec2 dm = castRay(ro, rd, time, pose, false);\n\n\tvec3 color = vec3(0.0);\n\n\tif (dm.x < MAX_DIST)\n\t{\n\t\tvec3 pos = ro + dm.x * rd; // point in scene\n\t\tvec3 nor = getNormal(pos, time, pose); // point normal\n\t\tcolor = getMaterialColor(dm, pos, nor, rd, time, pose);\n\t}\n\telse\n\t{\n\t\t// sky texture\n\t\tcolor = getSkyTexture(rd);\n\t}\n\n#ifdef RENDER_CLOUDS\n\tcolor = composeClouds(ro, rd, time, dm.x, color);\n#endif\n\n\t// gamma correction\n\tcolor = pow(color, vec3(0.5));\n\n\tfragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdySWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1670, 1737, 1778, 1778, 1958], [1960, 1960, 2001, 2001, 2181], [2183, 2183, 2245, 2245, 2317], [2319, 2319, 2381, 2381, 2453], [2455, 2455, 2501, 2501, 2530], [2532, 2532, 2578, 2578, 2607], [2609, 2609, 2630, 2630, 2704], [2706, 2706, 2726, 2726, 2816], [2818, 2818, 2838, 2838, 2861], [2863, 2863, 2889, 2889, 3278], [3280, 3280, 3302, 3302, 3375], [3377, 3377, 3430, 3430, 3488], [3490, 3490, 3548, 3548, 3607], [3609, 3609, 3649, 3649, 3678], [3680, 3680, 3721, 3721, 3762], [3764, 3764, 3807, 3807, 3925], [3927, 3927, 3951, 3951, 3980], [3982, 3982, 4006, 4006, 4035], [4037, 4037, 4061, 4061, 4090], [4092, 4092, 4120, 4120, 4252], [4254, 4254, 4291, 4291, 4447], [4449, 4449, 4479, 4479, 4496], [4498, 4498, 4538, 4538, 4567], [4569, 4569, 4611, 4611, 4711], [4713, 4713, 4789, 4804, 5297], [5299, 5299, 5338, 5338, 5413], [5415, 5415, 5454, 5454, 5548], [5550, 5550, 5592, 5592, 5713], [5715, 5715, 5757, 5757, 5878], [5880, 5880, 5916, 5916, 6088], [6090, 6090, 6152, 6152, 6410], [6412, 6412, 6457, 6457, 6838], [6840, 6840, 6885, 6885, 7314], [7317, 7317, 7362, 7362, 7817], [7819, 7819, 7901, 7901, 8058], [8060, 8060, 8136, 8136, 8816], [8818, 8818, 8844, 8844, 12642], [12646, 12646, 12685, 12685, 13389], [13391, 13391, 13485, 13485, 14868], [14870, 14870, 14943, 14943, 15874], [15876, 15876, 15914, 15914, 16342], [16344, 16344, 16407, 16407, 17059], [17061, 17061, 17103, 17103, 17554], [17556, 17556, 17600, 17600, 17893], [17895, 17895, 17922, 17922, 18119], [18121, 18121, 18166, 18166, 22526], [22528, 22528, 22555, 22555, 22681], [22683, 22683, 22721, 22721, 22764], [22766, 22766, 22827, 22827, 23234], [23236, 23236, 23268, 23268, 23647], [23649, 23649, 23678, 23678, 25212], [25214, 25214, 25245, 25245, 26014], [26016, 26016, 26043, 26043, 27359], [27361, 27361, 27403, 27403, 27790], [27792, 27792, 27864, 27864, 28386], [28388, 28487, 28545, 28545, 28763], [28765, 28765, 28878, 28878, 29272], [29274, 29274, 29357, 29357, 29684], [29686, 29686, 29759, 29759, 30114], [30116, 30116, 30184, 30184, 30566], [30568, 30568, 30661, 30661, 33264], [33266, 33266, 33311, 33311, 33661], [33663, 33663, 33734, 33734, 34732], [34734, 34734, 34789, 34789, 36687]]}
{"id": "sdyXDt", "name": "SimpleWhiteNoise", "author": "liaozixin", "description": "A simple shader to generate a random number.", "tags": ["noise"], "likes": 1, "viewed": 35, "published": "Public", "date": "1635525062", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n\n\nfloat Random(vec2 uv)\n{    \n    float a = 79561.;\n    float b = 0.6;\n    \n    float random = fract(sin(dot(uv, vec2(12.98, 96.77)) + b) * a * fract(iTime));\n    return random;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 col = vec3(Random(uv));\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdyXDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[4, 4, 27, 27, 181], [186, 186, 243, 243, 386]]}
{"id": "sld3zn", "name": "Tater @ Inércia Shader Royale", "author": "Tater", "description": "My shader from the 2021 Inércia Shader Royale, I got eliminated just a few seconds before I finished the blue twisty and voronoi effect, but I finished it afterwards and include it here. \n\nVOD: [url]https://www.youtube.com/watch?v=6xvZTxv6QYc[/url]", "tags": ["3d", "raymarching", "voronoi", "terrain", "demoscene", "showdown", "livecode", "inercia", "royale"], "likes": 29, "viewed": 290, "published": "Public API", "date": "1635632184", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define STEPS 128.0\n#define MDIST 128.0\n#define pi 3.1415926535\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define sat(a) clamp(a,0.,1.)\n#define pmod(p,x) (mod(p,x)-0.5*(x))\n#define fGlobalTime iTime\n#define fft texelFetch( iChannel0, ivec2(10,0), 0 ).x*20.0\nfloat psin(float x, float b){\n  float xx = floor(b*x)/b;\n  return sin(xx)+(sin(floor(b*x+1.0)/b)-sin(xx))*mod(b*x,1.0);\n}\n//Voronoi Found in https://www.shadertoy.com/view/3ddGzn\n//Adapted it to 3d and fixed some of the artifacts\nvec2 vor(vec2 m, vec3 p, vec3 s){\n  float scl = 0.2;\n  vec3 c = round(scl*p+s);\n  c+=sin(fract(72985.*sin(dot(c,c.yzx+33.3)))*6.+fGlobalTime*3.)*0.3;\n  c*=(1./scl);\n  float v = length(c - p);\n  return v<m.x?vec2(v,m.x):v<m.y?vec2(m.x,v):m;\n}\n//I failed to understand Javad Taba's \n//Artical on rope fractals so this is my shitty\n//approximation\nvec3 spiral(vec3 p, float R){\n  p.xz*=rot(p.y/R);\n  vec2 s = sign(p.xz);\n  p.xz = abs(p.xz)-R*0.5;\n  p.xz*=rot(fGlobalTime);\n  float poy = p.y;\n  p.y = 0.;\n  p.yz*=rot(mix(0.,pi/4.,1./(R*0.5+1.5)))*-sign(s.x*s.y);\n  p.y = poy;\n  return p;\n}\nfloat wavey = 0.;\nvec2 map(vec3 p){\n\n  float t = mod(fGlobalTime,150.);\n  vec3 po2 = p;\n  p.z+=t*30.;\n  p.xz*=rot(0.4);\n  vec3 po = p;\n  vec2 a = vec2(1);\n  vec2 b = vec2(2);\n  vec2 c = vec2(3);\n  \n  //TRIANGLE PLANE\n  p.xz*=0.9;\n  p.y+=psin(p.x*0.1,2.)*4.*sin(t+p.x*0.01);\n  p.xz*=rot((2.*pi)/3.);\n  p.y+=psin(p.x,0.2)*3.*sin(t*2.+p.x*0.05);\n  p.xz*=rot((2.*pi)/3.);\n  p.y+=psin(p.x,0.2)*3.*sin(t*2.+p.x*0.04);\n  p.xz*=rot((2.*pi)/3.);\n  \n  //HEX LATTICE\n  vec3 p2 = p;\n  p2.y+=fft*0.01;\n  float m = 5.;\n  p.x = pmod(p.x-m*0.5,m);\n  b.x = length(p.xy)-0.2;\n  p = p2;\n  p.xz*=rot((2.*pi)/3.);\n  p.x = pmod(p.x-m*0.5,m);\n  b.x = min(b.x,length(p.xy)-0.2);\n  p = p2;\n  p.xz*=rot((2.*pi)/3.);\n  p.xz*=rot((2.*pi)/3.);\n  p.x = pmod(p.x-m*0.5,m);\n  b.x = min(b.x,length(p.xy)-0.2);\n \n  a.x = p.y+1.;\n  \n  a = (a.x<b.x)?a:b;\n  \n  //BIAS THE LATTICE\n  p = po;\n  a.x*=0.7;\n  c.x = p.y;\n  a.x = mix(c.x,a.x+0.1,1.15); //this was a lucky find\n  \n  //VORONOI\n  vec3 r = po2;\n  \n  r.y-=t*0.5;\n  r.xy*=rot(pi/4.);\n  vec2 s = vec2(0.5,-0.5);\n  vec2 vd =\n  vor(vor(vor(vor(vor(vor(vor(vor(vec2(5),\n  r,s.xxx) ,r,s.xxy) ,r,s.xyx) ,r,s.xyy),\n  r,s.yxx) ,r,s.yxy) ,r,s.yyx) ,r,s.yyy);\n  float h = vd.y-vd.x;\n  \n  //WAVES\n  p = po2;\n  float wav = 0.;\n  p.xz*=0.5;\n  wav+=sin(p.z*0.8+t)*0.1+sin(p.x*0.8+t)*0.2;\n  wav+=sin(p.z*0.3-t*2.)*0.2+sin(p.x*0.3-t*2.)*0.2;\n  wav+=sin(length(p.xz)*0.3+t*3.0);\n  p.y+=wav*5.0;\n  b.x = p.y;\n  \n  float v = mix(b.x,0.01,sat(1.-h));\n  b.x = max(b.x,v+0.1);\n  \n  //TWIST\n  p = po2;\n  p = spiral(p,25.+fft*0.3);\n  p = spiral(p,10.);\n  p = spiral(p,4.);\n  p = spiral(p,1.5);\n  \n  c.x = length(p.xz)-0.5;\n  c.x*=0.8;\n  b = (b.x<c.x)?b:c;\n  \n  \n  a.x = mix(a.x,b.x*0.8,wavey);\n  a.y = mix(a.y,b.y,wavey);\n  \n  return a;\n}\n\n//Anti-unroll normals (not live coded) \n#define ZERO (min(iFrame,0))\nvec3 norm(vec3 p){\n    \n   \n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*0.001).x;\n    }\n    return normalize(n);\n \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n  vec3 col = vec3(0.2);\n  float t= fGlobalTime+1.5;\n  wavey = smoothstep(-0.25,0.3,sin(t*0.4));\n  //wavey = 1.;\n  uv-=0.2*(1.0-wavey);\n  \n  uv.xy*=rot((1.0-wavey)*sin(t*1.5+pi/2.)*0.05);\n\n  vec3 ro = vec3(0,3,-5)*5.5;\n  ro.zy+=(sin(t*1.5)*8.+3.);\n  \n  vec3 ro2 = vec3(0,5,7)*10.;\n  ro2.xz*=rot(t*0.3);\n  ro = mix(ro,ro2,wavey);\n  \n  vec3 lk = vec3(0,0.+wavey*6.,30.*(1.0-wavey));\n  vec3 f = normalize(lk-ro);\n  vec3 r = normalize(cross(vec3(0,1,0),f));\n  vec3 rd = normalize(f*mix(0.3,0.7,wavey)+uv.x*r+uv.y*cross(f,r));\n  \n  vec3 p = ro;\n  vec2 d= vec2(0);\n  float dO = 0.;\n  float shad = 0.;\n  bool hit = false;\n  for(float i = 0.; i<STEPS; i++){\n    p = ro+rd*dO;\n    d = map(p);\n    dO+=d.x;\n    if(abs(d.x)<0.005||i==STEPS-1.){\n      shad = i/STEPS;\n      hit = true;\n      break;\n    }\n    if(dO>MDIST){\n      dO = MDIST;\n      break;\n    }\n  }\n  vec3 bg = mix(vec3(0.5,0.4,0.85),vec3(0.45,0.45,0.9),clamp(rd.y*5.,-1.,1.));\n  if(hit){\n    vec3 n = norm(p);\n    vec3 ld = normalize(vec3(20,45,0)-p);\n    vec3 rr = reflect(rd,n);\n    float diff = max(0.,dot(n,ld));\n    float amb = dot(n,ld)*0.5+0.5;\n    float spec = pow(max(0.,dot(rr,ld)),40.);\n    vec3 al = vec3(0.2,0.25,0.75);\n    #define AO(a,n,p) smoothstep(-a,a,map(p+n*a).x)\n    float ao = AO(0.3,n,p)*AO(0.5,n,p)*AO(0.9,n,p);\n    float sss = 0.;\n    for(float i = 0.; i<20.; i++){\n      float dist = i*0.09;\n      sss+=smoothstep(0.,1.,map(p+ld*dist).x/dist)*0.033; \n    }\n    \n    \n    if(d.y==2.0) al*=2.;\n    col = vec3(1.0-shad);\n    col = al*mix(vec3(0.3,0,0.3),vec3(1),mix(diff,amb,0.25));\n    col+=spec*0.3*bg;\n    col+=sss*0.3;\n    col*=mix(ao,1.0,0.3);\n    col = pow(col,vec3(0.7));\n    \n    //WAVEY COLOR\n    sss = 0.1;\n    float ssmag = 1.;\n    ld = normalize(vec3(0,120,0)-p);\n    if(d.y==3.0){ld = normalize(vec3(p.x,0,p.z));\n    ssmag = 1.5;\n    sss = 0.2;\n    }\n    spec = pow(max(.0,dot(rr,ld)),20.0);\n    vec3 wcol = vec3(0);\n    al = vec3(0.2,0.6,1);\n    //sss by nusan\n    for(float i = 0.; i<20.; i++){\n      float dist = i*0.3;\n      sss+=smoothstep(0.,1.,map(p+ld*dist).x/dist)*0.06*ssmag; \n    }\n    wcol = mix((1.0-shad),1.,0.5)*vec3(sss)*al;\n    wcol+=spec*0.3;\n    col = mix(col,wcol,wavey);\n  }\n  col = mix(col,bg,pow(dO/MDIST,2.5));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XdfGzn", "previewfilepath": "/media/ap/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sld3zn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[266, 266, 295, 295, 387], [388, 496, 529, 529, 737], [738, 841, 870, 870, 1081], [1100, 1100, 1117, 1117, 2813], [2815, 2884, 2902, 3009, 3212], [3215, 3215, 3272, 3272, 5590]]}
{"id": "sltGRn", "name": "Black hole V1", "author": "Taytweets", "description": "Mouse Left & right control time\nMouse Up & down control zoom\n\nvogel 2 -color xy - full gradient  @killedbyapixel mod", "tags": ["spiral", "blackhole", "vogel", "vogel2", "killedbyapixel", "fluxos"], "likes": 3, "viewed": 31, "published": "Public", "date": "1635625702", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M iMouse\n#define R iResolution\n#define T iTime\n#define pi 3.14\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n\n{vec2 m = ( iMouse.xy != vec2(0) ) ? M.xy/R.y*.5 : 5.5/vec2(10,10),\nu=50.*m.y*(gl_FragCoord.rg-R.rg/2.)/R.r;\n\nfloat \nd=pow(2.*length(u),1.2),\nt=.005*(T*5.*m.x),\ni=floor(d-atan(u.g,u.r)/pi/2.+.5),\na=atan(u.g,u.r)+pi*2.*i,\nh=.002*a+5.5*t,\ns=fract(a*.2*t)<.5?1.:0.,\nv=fract(a+t)<.5?0.:1.;\n\nfragColor=vec4(vec3(v+s*v*.5)*+sin(pi*2.*(h+vec3(1.,.888,.666))),1.);}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sltGRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 127, 127, 483]]}
{"id": "ss3SW7", "name": "Fast Raymarching w/ Reflections", "author": "N8Shader", "description": "A decent raymarcher with some tradeoffs for performance.", "tags": ["3d", "reflection", "primitives", "raymarcher"], "likes": 4, "viewed": 199, "published": "Public API", "date": "1633307779", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n float sdSphere(vec3 p, vec3 c, float r) {\n        return length(p - c) - r;\n    }\n    float sdDiamond(vec3 p, vec3 c, float r) {\n        vec3 cVector = abs(p - c);\n        return (cVector.x + cVector.y + cVector.z) - r;\n    }\n    float sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}  \nfloat sdTorus( vec3 p, vec3 c, vec2 t )\n{\n  p = p - c;\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat sdBox( vec3 p, vec3 c, vec3 b )\n{\n  p = p - c;\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCone( vec3 p, vec3 center, vec2 c, float h )\n{\n    p = p - center;\n  float q = length(p.xz);\n  return max(dot(c.xy,vec2(q,p.y)),-h-p.y);\n}\nfloat sdBoxFrame( vec3 p, vec3 c, vec3 b, float e )\n{\n    p = p - c;\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\nfloat random(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 uv)\n{\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    f = f * f * (3. - 2. * f);\n    \n    float lb = random(i + vec2(0., 0.));\n    float rb = random(i + vec2(1., 0.));\n    float lt = random(i + vec2(0., 1.));\n    float rt = random(i + vec2(1., 1.));\n    \n    return mix(mix(lb, rb, f.x), \n               mix(lt, rt, f.x), f.y);\n}\n\n#define OCTAVES 8\nfloat fbm(vec2 uv)\n{\n    float value = 0.;\n    float amplitude = .5;\n    \n    for (int i = 0; i < OCTAVES; i++)\n    {\n        value += noise(uv) * amplitude;\n        \n        amplitude *= .5;\n        \n        uv *= 2.;\n    }\n    \n    return value;\n}\n\nvec3 Sky(vec3 ro, vec3 rd)\n{\n    const float SC = 1e5;\n\n \t// Calculate sky plane\n    float dist = (SC - ro.y) / rd.y; \n    vec2 p = (ro + dist * rd).xz;\n    p *= 1.2 / SC;\n    \n    // from iq's shader, https://www.shadertoy.com/view/MdX3Rr\n    vec3 lightDir = normalize(vec3(-.8, .15, -.3));\n    float sundot = clamp(dot(rd, lightDir), 0.0, 1.0);\n    \n    vec3 cloudCol = vec3(1.);\n    //vec3 skyCol = vec3(.6, .71, .85) - rd.y * .2 * vec3(1., .5, 1.) + .15 * .5;\n    vec3 skyCol = vec3(0.3,0.5,0.85) - rd.y*rd.y*0.5;\n    skyCol = mix( skyCol, 0.85 * vec3(0.7,0.75,0.85), pow( 1.0 - max(rd.y, 0.0), 4.0 ) );\n    \n    // sun\n    vec3 sun = 0.25 * vec3(1.0,0.7,0.4) * pow( sundot,5.0 );\n    sun += 0.25 * vec3(1.0,0.8,0.6) * pow( sundot,64.0 );\n    sun += 0.2 * vec3(1.0,0.8,0.6) * pow( sundot,512.0 );\n    skyCol += sun;\n    \n    // clouds\n    float t = iTime * 0.1;\n    float den = fbm(vec2(p.x - t, p.y - t));\n    skyCol = mix( skyCol, cloudCol, smoothstep(.4, .8, den));\n    \n    // horizon\n    skyCol = mix( skyCol,  vec3(0.45, 0.55, 0.75), pow( 1.0 - max(rd.y, 0.0), 16.0 ) );\n    \n    return skyCol;\n}\nstruct Shifter {\n    vec3 position;\n    vec3 color;\n    float timeOffset;\n};\nShifter[9] shifters = Shifter[9](\n    Shifter(vec3(0.0, 0.0, 0.0), vec3(1.25, 0.0, 0.0), 0.0),\n    Shifter(vec3(5.0, 0.0, 0.0), vec3(0.0, 0.0, 1.25), 3.0),\n    Shifter(vec3(-5.0, 0.0, 0.0), vec3(0.0, 1.25, 0.0), 6.0),\n    Shifter(vec3(0.0, 0.0, -5.0), vec3(1.25, 1.25, 0.0), 1.0),\n    Shifter(vec3(5.0, 0.0, -5.0), vec3(0.0, 1.25, 1.25), 2.0),\n    Shifter(vec3(-5.0, 0.0, -5.0), vec3(1.25, 0.0, 1.25), 4.0),\n    Shifter(vec3(0.0, 0.0, 5.0), vec3(1.25, 0.65, 0.0), 5.0),\n    Shifter(vec3(5.0, 0.0, 5.0), vec3(0.0, 0.65, 1.25), 2.5),\n    Shifter(vec3(-5.0, 0.0, 5.0), vec3(0.0, 1.25, 0.65), 3.5)\n);\n    vec4 scene_dist(vec3 p) {\n        float obj_dist = 10000.0;\n        vec3 obj_color = vec3(1.0);\n        int s = 0;\n        float minDist = 10000.0;\n        for(int r= 0; r < shifters.length(); r++) {\n            float dist = length(p - shifters[r].position); \n            if (dist < minDist) {\n                s = r;\n                minDist = dist;\n            }\n        }\n        //for(int s = 0; s <= shifters.length(); s++) {\n        float s_dist = 0.0;\n        /*if (length(p - shifters[s].position) > 5.0) {\n            continue;\n        }*/\n        //float boxDist = length(shifters[s].position - p); //sdBox(p, shifters[s].position, vec3(1.0, 1.0, 1.0));\n        //if (boxDist > obj_dist) {\n            //continue;\n        //}\n       /*if (sdDiamond(p, shifters[s].position, 2.5) > obj_dist) {\n            continue;\n        }*/\n        /*if (time_period < 3.14 * 2.0) {\n            obj_dist = mix(sdBox(p, vec3(0.0, ((sin(time / 1000.0) + 1.0) / 2.0), 0.0), vec3(1.0, 1.0, 1.0)), sdTorus(p, vec3(0.0, (sin(time / 1000.0)), 0.0) + 0.05, vec2(1.0, 0.1)), (sin(time / 1000.0) + 1.0) / 2.0);\n        } else if (time_period < 3.14 * 4.0) {\n            obj_dist = mix(sdBox(p, vec3(0.0, ((sin(time / 1000.0) + 1.0) / 2.0), 0.0), vec3(1.0, 1.0, 1.0)), sdSphere(p, vec3(0.0, ((sin(time / 1000.0) + 1.0) / 2.0), 0.0), 1.0), (sin(time / 1000.0) + 1.0) / 2.0);\n        }*/\n        float time_period = mod(iTime + shifters[s].timeOffset, 5.0);\n        if (time_period <= 1.0) {\n            s_dist = mix(sdBoxFrame(p, shifters[s].position, vec3(0.9, 0.9, 0.9), 0.25), sdTorus(p, shifters[s].position, vec2(1.0, 0.2)), time_period);\n        } else if (time_period <= 2.0) {\n            s_dist = mix(sdTorus(p, shifters[s].position, vec2(1.0, 0.2)), sdSphere(p, shifters[s].position, 1.0), time_period - 1.0);\n        } else if (time_period <= 3.0) {\n            s_dist = mix(sdSphere(p, shifters[s].position, 1.0), sdCone(p, shifters[s].position, vec2(0.5, 0.5), 1.0), time_period - 2.0);\n        } else if (time_period <= 4.0) {\n            s_dist = mix(sdCone(p, shifters[s].position, vec2(0.5, 0.5), 1.0),  sdBox(p, shifters[s].position, vec3(0.9, 0.9, 0.9)), time_period - 3.0);\n        } else if (time_period <= 5.0) {\n            s_dist = mix(sdBox(p, shifters[s].position, vec3(0.9, 0.9, 0.9)),sdBoxFrame(p, shifters[s].position, vec3(0.9, 0.9, 0.9), 0.25), time_period - 4.0);\n        }\n       //s_dist = sdSphere(p, shifters[s].position, 1.0);\n            obj_dist = s_dist;\n            obj_color =  shifters[s].color;\n    //}\n        float ground_dist = sdBox(p, vec3(0.0, -1.0, 0.0), vec3(9.5, 0.0, 9.5));\n        vec3 color;\n        if (ground_dist < obj_dist) {\n            color = vec3(0.75);\n            if (mod(round(p.x), 2.0) == mod(round(p.z), 2.0)) {\n                color = vec3(0.1);\n            }\n        } else {\n            color = obj_color;\n        }\n        return vec4(min(ground_dist, obj_dist), color);\n    }\n    vec3 calculate_normal(vec3 p) {\n        const vec3 step = vec3(0.001, 0.0, 0.0);\n        float gradX = scene_dist(p + step.xyy).x - scene_dist(p - step.xyy).x;\n        float gradY = scene_dist(p + step.yxy).x - scene_dist(p - step.yxy).x;\n        float gradZ = scene_dist(p + step.yyx).x - scene_dist(p - step.yyx).x;\n        return normalize(vec3(gradX, gradY, gradZ));\n    }\n    bool ray_march_hit(vec3 rayOrigin, vec3 rayDir) {\n        float distanceTravelled = 0.0;\n        const int NUMBER_OF_STEPS = 32;\n        const float MINIMUM_HIT_DISTANCE = 0.001;\n        const float MAXIMUM_TRACE_DISTANCE = 1000.0;\n        for(int i = 0; i < NUMBER_OF_STEPS; i++) {\n            vec3 currPos = rayOrigin + distanceTravelled * rayDir;\n            float sceneDist = scene_dist(currPos).x;\n            if (sceneDist < MINIMUM_HIT_DISTANCE) {\n                return true;\n            }\n            if (sceneDist > MAXIMUM_TRACE_DISTANCE) {\n                break;\n            }\n            distanceTravelled += sceneDist;\n        }\n        return false;\n    }\n    vec3 ray_march_diffuse(vec3 rayOrigin, vec3 rayDir, vec3 diffuse) {\n        float distanceTravelled = 0.0;\n        const int NUMBER_OF_STEPS = 64;\n        const float MINIMUM_HIT_DISTANCE = 0.001;\n        const float MAXIMUM_TRACE_DISTANCE = 1000.0;\n        const int BOUNCE_AMOUNTS = 3;\n        vec3 finalDiffuse = diffuse;\n        bool done = false;\n        for(int r = 0; r < BOUNCE_AMOUNTS; r++) {\n            if (done) {\n                break;\n            }\n            for(int i = 0; i < NUMBER_OF_STEPS; i++) {\n                vec3 currPos = rayOrigin + distanceTravelled * rayDir;\n                vec4 sceneData = scene_dist(currPos);\n                float sceneDist = sceneData.x;\n                vec3 sceneDiffuse = sceneData.yzw;\n                if (sceneDist < MINIMUM_HIT_DISTANCE) {\n                    float addWeight = pow(0.5, float(r + 1));\n                    finalDiffuse = (1.0 - addWeight) * finalDiffuse + addWeight * sceneDiffuse;\n                    vec3 normal = calculate_normal(currPos);\n                    rayOrigin = currPos;\n                    rayDir = reflect(rayDir, normal);\n                    break;\n                }\n                if (sceneDist > MAXIMUM_TRACE_DISTANCE) {\n                    done = true;\n                    break;\n                }\n                distanceTravelled += sceneDist;\n            }\n        }\n        finalDiffuse = 0.6 * Sky(rayOrigin, rayDir) + 0.4 * finalDiffuse;\n        return finalDiffuse;\n    }\n    vec3 ray_march(vec3 rayOrigin, vec3 rayDir) {\n        float distanceTravelled = 0.0;\n        const int NUMBER_OF_STEPS = 2048;\n        const float MINIMUM_HIT_DISTANCE = 0.001;\n        const float MAXIMUM_TRACE_DISTANCE = 1000.0;\n        for(int i = 0; i < NUMBER_OF_STEPS; i++) {\n            vec3 currPos = rayOrigin + distanceTravelled * rayDir;\n            vec4 sceneData = scene_dist(currPos);\n            float sceneDist = sceneData.x;\n            vec3 sceneDiffuse = sceneData.yzw;\n            if (sceneDist < MINIMUM_HIT_DISTANCE) {\n                vec3 normal = calculate_normal(currPos);\n                vec3 lightPos = vec3(200.0, -500.0, 150.0);\n                vec3 dirToLight = normalize(currPos - lightPos);\n                float lightIntensity = max(0.2, dot(normal, dirToLight));\n                vec3 reflectDir = reflect(rayDir, normal);\n                sceneDiffuse = ray_march_diffuse(currPos + reflectDir * 0.002, reflectDir, sceneDiffuse);\n                if (ray_march_hit(currPos + dirToLight * 0.01, dirToLight)) {\n                    lightIntensity = 0.15;\n                }\n                return ((sceneDiffuse) / 2.0) * lightIntensity + 0.2 * vec3(1.0, 1.0, 1.0);\n            }\n            if (sceneDist > MAXIMUM_TRACE_DISTANCE) {\n                break;\n            }\n            distanceTravelled += sceneDist;\n        }\n        return Sky(rayOrigin, rayDir);\n        \n    }\n    mat4 makeViewMatrix(vec3 eye, vec3 center, vec3 up) {\n        vec3 f = normalize(center - eye);\n        vec3 s = normalize(cross(f, up));\n        vec3 u = cross(s, f);\n        return mat4(\n            vec4(s, 0.0),\n            vec4(u, 0.0),\n            vec4(-f, 0.0),\n            vec4(0.0, 0.0, 0.0, 1)\n        );\n    }\n    vec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n        vec2 xy = fragCoord - size / 2.0;\n        float z = size.y / tan(radians(fieldOfView) / 2.0);\n        return normalize(vec3(xy, -z));\n    }\n    void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n        vec3 viewDir = rayDirection(75.0, iResolution.xy, gl_FragCoord.xy);\n    vec3 eye =vec3(15.0 * sin(iTime), 7.5 + cos(iTime) * 5.0, 15.0 * cos(iTime));\n    \n    mat4 viewToWorld = makeViewMatrix(vec3(15.0 * sin(iTime), 7.5 + cos(iTime) * 5.0, 15.0 * cos(iTime)), vec3(0.0), vec3(0.0, 1.0, 0.0));\n   \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz; \n    vec3 shaded_color = ray_march(eye, worldDir);\n        fragColor = vec4(shaded_color, 1.0);\n    }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss3SW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 43, 43, 83], [88, 88, 130, 130, 227], [232, 232, 265, 291, 322], [325, 325, 366, 366, 444], [445, 445, 484, 484, 584], [586, 586, 640, 640, 732], [733, 733, 786, 786, 1083], [1084, 1084, 1106, 1106, 1173], [1175, 1175, 1197, 1197, 1525], [1545, 1545, 1565, 1565, 1794], [1796, 1796, 1824, 1824, 2902], [3581, 3581, 3606, 3606, 6513], [6518, 6518, 6549, 6549, 6894], [6899, 6899, 6948, 6948, 7569], [7574, 7574, 7641, 7641, 9046], [9051, 9051, 9096, 9096, 10455], [10460, 10460, 10513, 10513, 10779], [10784, 10784, 10849, 10849, 10997], [11002, 11002, 11057, 11057, 11525]]}
{"id": "ss3Sz2", "name": "yonatan mountains revisited", "author": "guil", "description": "yonatan mountains revisited \nhttps://twitter.com/User2E32/status/1443544969847918593", "tags": ["mountains", "snow"], "likes": 13, "viewed": 164, "published": "Public", "date": "1633529266", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rotate2D(float r){\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\n\nvoid mainImage( out vec4 C, in vec2 FC )\n{\n    float o,c,i,e,f,s,g,k=.01;\n    vec2 r = iResolution.xy;\n    float t = iTime;\n    for(o++,c++;i++<1e2;g+=min(f,max(.03,e))*.7)\n        {s=2.;vec3 p=vec3((FC.xy-r/s)/r.y*g,g-s);\n        p.yz*=rotate2D(-.8);\n        p.z+=t;\n        for(e=f=p.y;s<2e2;s/=.6)\n            p.xz*=rotate2D(s),\n            e+=abs(dot(sin(p*s)/s,p-p+.3)),\n            f+=abs(dot(sin(p.xz*s*.6)/s,r/r));\n    o+=(f>k*k?e:-exp(-f*f))*o*k;}\n    c+=e;\n    \n    C = vec4(o);\n    C.rg -= c*.04;\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss3Sz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 75], [78, 78, 120, 120, 592]]}
{"id": "ss3XW7", "name": "noisy concentric rings", "author": "cllsto", "description": "texture uv distortion by LordSK & Sintel", "tags": ["cyclical"], "likes": 0, "viewed": 28, "published": "Public", "date": "1633319126", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R 0.5\n#define PI 3.141592653589793238462643\n\nvec3 vstep( in float v, in float os, in float lev )\n{\n     vec3 vs = v+os > 0.0 ? vec3(0.0) : vec3(lev);\n     return vs;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy-0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    uv -= fract(texture(iChannel0, uv-vec2(iTime/2.0,0.0))/2.0).r*0.01;\n    \n    float d = length(uv)-R;\n    \n    float val = sin(16.0*(4.0*d-(PI/24.0)*iTime)+d*2.0)*cos(4.0*(16.0*d+(PI/24.0)*iTime)-d*2.0);\n    \n    vec3 vs = vstep(val,0.0,0.8);\n    vec3 v2s = vstep(val,0.5*d,0.8);\n    vec3 v3s = vstep(val,d,0.8);\n    \n    vec3 col = vec3(vs.r,v2s.g,v3s.b);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss3XW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 106, 106, 175], [177, 177, 234, 234, 722]]}
{"id": "ss3XWN", "name": "Breaking raymarching", "author": "SnoopethDuckDuck", "description": "messing around trying to break things", "tags": ["raymarching", "template", "artofcode"], "likes": 0, "viewed": 129, "published": "Public API", "date": "1633135025", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 50\n#define MAX_DIST 5.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n\nfloat GetDist(vec3 p) {\n    float a = atan(p.z, p.x);\n   // float b = .5 + .5 * cos(0.3 * iTime);\n    p = vec3(p.x,p.y +0.1 *  length(p.xz) * cos(6. * a + 4. * iTime),p.z);\n    float bd = sdBox(p, vec3(0.8)) - .2;\n    float sd = length(p) * length(p) - 1.2;// + 0.4 * cos(0.7 * iTime);\n    //return  0.2 * (0.8 + sin(16.* (0.2 * min(bd,sd) + (1. - abs(min(sd/(bd),bd/(sd)))))));\n    return  -0. * min(bd,sd) + 0.05 * (2. + sin(0.5 * iTime + 1. * (0.6 - abs(min(sd/(bd),bd/(sd))))));\n   \n   \n   //return bd;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 Bg(vec3 rd) {\n    float k = rd.y*.5 + .5;\n    //  vec3 col = mix(vec3(.5,0.,0.),vec3(0.),16. * k * (1.-k) * k * (1.-k));\n   // vec3 col = vec3(10.,0.,0.);\n    vec3 col = mix(vec3(.5,0.,0.),vec3(0.),16. * k * (1.-k) * k * (1.-k));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    float t = 0.35 * iTime;\n    vec3 ro = 2.5 * vec3(cos(t), cos(t + (2./3.) * 3.1415), cos(t + (4./3.) * 3.1415));\n   // vec3 ro = vec3(3.5 * cos(0.2 * iTime),2. * sin(0.5 * iTime), 3.5 * sin(0.2 * iTime));\n    // ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    vec3 col = vec3(0);\n    col += Bg(rd);\n   \n    float d = RayMarch(ro, rd);\n    float depth = 2.; //1.5 + cos(iTime);\n    \n    // comment / uncomment me\n    //d = RayMarch(ro + rd * (1. + depth) * d, -0.5 * depth * rd);\n    \n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(1.5*rd, n);\n        \n        float spec = pow(max(0., -r.y),32.);\n        spec = .5 + .5 * cos(0.00001*spec); // <-- absolute fudge but works alright\n       \n       float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n       float a = atan(p.x,p.z);\n       // dif = 16. * dif * dif * (1.-dif) * (1.-dif);\n       \n       col = 0.4 * vec3(dif) + 1.5 * cos(2. * a) * Bg(r);        \n       col *= (1. + spec);\n       \n       // comment / uncomment me\n       //col = vec3(dif);\n    }\n    col = pow(col, vec3(.4545));\t// gamma correction\n    //col *= 100000.;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss3XWN.jpg", "access": "shaders20k", "license": "mit", "functions": [[0, 1472, 1491, 1491, 1553], [1555, 1555, 1584, 1584, 1665], [1668, 1668, 1691, 1691, 2176], [2178, 2178, 2212, 2212, 2423], [2425, 2425, 2449, 2449, 2639], [2641, 2641, 2691, 2691, 2882], [2884, 2884, 2902, 2902, 3136], [3138, 3138, 3195, 3195, 4541]]}
{"id": "sscSW2", "name": "Smoldering", "author": "Kittyhawk", "description": ".", "tags": ["fire"], "likes": 4, "viewed": 81, "published": "Public", "date": "1633960081", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float scale = 3.0f;\nconst float intensivity = 0.05f;\nconst int iteration = 3;\nconst float speed = 85.0; // range 1 to 100\n\nconst mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\nvec2 hash( vec2 p ) {\n\tp = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    const float K1 = 0.366025404; \n    const float K2 = 0.211324865; ;\n\tvec2 i = floor(p + (p.x+p.y)*K1);\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot(n, vec3(70.0));\t\n}\n\nfloat fbm(vec2 n) {\n\tfloat total = 0.0, amplitude = 0.1;\n\tfor (int i = 0; i < 7; i++) {\n\t\ttotal += noise(n) * amplitude;\n\t\tn = m * n;\n\t\tamplitude *= 0.4;\n\t}\n\treturn total;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy;\n\tvec2 uv = p*vec2(iResolution.x/iResolution.y,1.0);    \n    float time = iTime*0.03f;\n    float q = fbm(uv  * 0.5);\n\n\tuv *= scale;\n    \n    float f = 0.0;\n    float weight = 0.7;\n    for (int i=0; i<iteration; i++){\n\t\tf += weight*noise( uv );\n        uv = m*uv + time;\n\t\tweight *= 0.6;\n    }\n    \n    f = fract(f+iTime/(101.-speed));\n    \n    float coeff = intensivity/abs(.5 - f);\n    vec3 result = vec3(.9,.2,.1)*coeff;\n        \n    fragColor = vec4(result,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sscSW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 176, 197, 197, 310], [312, 312, 338, 338, 772], [774, 774, 793, 793, 947], [950, 950, 1007, 1007, 1518]]}
{"id": "sscXD7", "name": "UNIVERSAL_FLOW", "author": "boldo", "description": "WIP", "tags": ["wip"], "likes": 11, "viewed": 179, "published": "Public", "date": "1634810290", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//ADJUST THESE as you like\n#define SPARKLESPEED .05\n#define ROTATIONSPEED .01\n#define MOVEMENTSPEED .05\n\n#define LAYERZOOM 10.\n#define LAYERMOVEMENTSPEED 0.03\n\n#define BGCOLOR vec3(0.024, 0.247, 0.306) * .5\n\n#define FGCOLOR vec3(0.475, 0.696, 0.702)\n\n//DON'T TOUCH THE REST :)\n\nmat2 Rot(float a) {\n   float s=sin(a), c=cos(a);\n   return mat2(c,s,-s,c);\n}\n\n\nfloat Hash21(vec2 p) {\n    p = fract(p * vec2(123.21, 552.53));\n    p += dot(p, p+34.21);\n    return fract(p.x * p.y);\n}\n\nvec2 Hash22(vec2 p) {\n   vec3 p3 = fract(vec3(p.xyx) * vec3(231.23,423.24, 521.23));\n   p3 += dot(p3, p3.yzx + 23.42);\n   return fract((p3.xx + p3.zy) * p3.zy);\n}\n\nfloat DistanceFromLine( in vec2 a, in vec2 b, in vec2 p) {\n    vec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);\t\n\treturn length(pa - ba * h);\n}\n\nfloat SimpleLine(vec2 a, vec2 b, vec2 uv) {\n    float d = DistanceFromLine(a, b, uv);\n    float m = smoothstep(.03, .01, d);\n    m*=smoothstep(1.2, .8, length(a-b));\n    return m;\n}\n\n\nvec2 GetPos(vec2 id, vec2 offs) {\n    vec2 n = Hash22(id + offs) * (223.23 + iTime * MOVEMENTSPEED);\n    return offs + sin(n) * .4;\n}\n\n\nfloat Layer(vec2 uv, float n) {\n    uv *= Rot(n * 20. + iTime * ROTATIONSPEED);\n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    \n    \n    vec2 p[9];\n    int i=0;\n    for (float y=-1.;y<=1.;y++) {\n        for (float x=-1.;x<=1.;x++) {\n            p[i++] = GetPos(id, vec2(x,y));// + Hash22(id - offs) * 0.5 * Rot(iTime * Hash21(id - offs) * 0.5);\n        }\n    }\n    \n    float m = 0.;\n    for (i = 0; i<9; i++) {\n        \n        vec2 j = (p[i] - gv) * 30.;\n        float sparkle = 1./dot(j,j);\n        m+=sparkle * (sin(iTime * SPARKLESPEED + (Hash21(p[i]) )) * .5 + .5);\n        \n        m += SimpleLine(p[4], p[i], gv);\n    }\n    m+= SimpleLine(p[1], p[3], gv);\n    m+= SimpleLine(p[1], p[5], gv);\n    m+= SimpleLine(p[7], p[3], gv);\n    m+= SimpleLine(p[7], p[5], gv);\n    \n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   \n    float t = iTime * LAYERMOVEMENTSPEED;\n    \n    // first row is frequency data (48Khz/4 in 512 texels, meaning 23 Hz per texel)\n\tfloat fft  = texelFetch( iChannel0, ivec2(0.2,0), 0 ).x; \n    \n    float m = 0.;\n    for (float i=0.; i<1.; i+=1./4.) {\n        float z = fract(t + i);\n        float size = mix(LAYERZOOM, 1., z);\n        float fade = smoothstep(0., .6, z) * smoothstep(1., .8, z);\n        m += Layer(uv * size, i) * fade;\n    }\n    \n    //vec3 currentCol = vec3(sin(iTime) * 0.5 + 0.5,cos(iTime) * 0.5 + 0.5,.9);\n    //m = mix(m, .1, smoothstep(.0, 2.0, (fft-uv.y)));\n    vec3 currentCol = m * FGCOLOR + (1. - m) * BGCOLOR;\n    vec3 col =  currentCol;\n    \n    \n    //col = (1.-step(.5, length(uv))) * col;\n    //col = i.xyz;\n\n    \n    //col = smoothstep(.5, .3, length(uv) - fft) * vec3(1.);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sscXD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[251, 278, 297, 297, 354], [357, 357, 379, 379, 477], [479, 479, 500, 500, 641], [643, 643, 701, 701, 817], [819, 819, 862, 862, 1000], [1003, 1003, 1036, 1036, 1136], [1139, 1139, 1170, 1170, 1941], [1943, 1943, 2000, 2000, 2909]]}
{"id": "sscXDs", "name": "Asymmetric smooth-abs", "author": "athibaul", "description": "Smooth-min/smooth-max functions, but with independent controls for the smoothing radius of each element.", "tags": ["sdf", "smooth", "smin", "smax", "sabs"], "likes": 5, "viewed": 122, "published": "Public API", "date": "1634160002", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// By Alexis THIBAULT\n// Stemmed from a question by Fabrice Neyret: \n// https://www.facebook.com/groups/shadertoy/permalink/961319301115763/\n\nfloat sabs(float x, float a, float b){\n    // Asymmetric smooth-abs\n    \n    // For -b < x < a the graph is a tilted quarter of an ellipse\n    // Coincides with abs() for x < -b or x > a\n    \n    float d = x/2.;\n    float det = a*b + 2.*(a-b)*d - 2.*d*d;\n    \n    float mu = (x > -b && x<a) ?\n     2.*(a*a*(b+d) + b*b*(a-d) - sqrt(2.)*a*b*sqrt(det))/(a*a+b*b)\n     : abs(x);\n    \n    return mu;\n}\n\nfloat smin(float d1, float d2, float r1, float r2)\n{\n    // Asymmetric smooth-min\n    // The zero-set of perpendicular planes is an elliptic surface with radii (r1, r2)\n    \n    return 0.5*(d1+d2 - sabs(d1-d2, r1, r2));\n}\n\nfloat smax(float d1, float d2, float r1, float r2)\n{\n    // Asymmetric smooth-max\n    // The zero-set of perpendicular planes is an elliptic surface with radii (r1, r2)\n    \n    return 0.5*(d1+d2 + sabs(d1-d2, r1, r2));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    float r1 = 0.5 + 0.4*sin(iTime);\n    float r2 = 0.5 + 0.4*cos(1.62*iTime);\n    float d = smin(uv.x, uv.y, r1, r2) + 0.5;\n    \n    \n    \n    // coloring by iq : https://www.shadertoy.com/view/fd3SRf\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n    //vec3 col = (d<0.0) ? vec3(0.5) : vec3(1.0);\n    col *= 1.0 - exp(-7.0*abs(d));\n\tcol *= 0.9 + 0.1*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sscXDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 142, 180, 328, 538], [540, 540, 592, 708, 761], [763, 763, 815, 931, 984], [986, 986, 1043, 1043, 1618]]}
{"id": "sscXWs", "name": "Polynomial experimentations #1", "author": "ninofiliu", "description": "Playing around with broken implementations of the Newton's fractal", "tags": ["polynomial"], "likes": 0, "viewed": 87, "published": "Public API", "date": "1634158759", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 mul(vec2 a, vec2 b) {\n    return vec2(a.x*b.x-a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\nvec2 f(vec2 x) {\n    return mul(mul(x-vec2(1.0,1.0), x-vec2(1.0,-1.0)), x-vec2(-1.0,0.0));\n}\n\nvec2 fp(vec2 x) {\n    return mul(x, 3.0*x-5.0*sin(0.5*iTime));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 u = vec2(\n        fragCoord.x - iResolution.x / 2.0,\n        fragCoord.y - iResolution.y / 2.0\n    ) / min(iResolution.x, iResolution.y);\n    for (int i = 0; i < 7; i++) {\n        u = u - f(u)/fp(u);\n    }\n    fragColor = vec4(10.0/abs(u.x), 10.0/abs(u.y), 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sscXWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 81], [83, 83, 99, 99, 175], [177, 177, 194, 194, 241], [243, 243, 298, 298, 577]]}
{"id": "ssdSDM", "name": "Cwiczonko", "author": "gunzes", "description": "sie ucze kolka robic", "tags": ["nauka"], "likes": 0, "viewed": 66, "published": "Public", "date": "1633455595", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float drawDisc(vec2 coord,float radiusOut){\n    return step(length(coord),radiusOut);\n}\nfloat drawCircle(vec2 coord, float radiusOut, float radiusIn){\n    return drawDisc(coord,radiusOut) - drawDisc(coord,radiusIn);\n}\nfloat drawDiscSmooth(vec2 uv, float borderThickness, float radius){\n\n    return 1.-smoothstep(0.,borderThickness,abs(radius-sqrt(dot(uv,uv))));\n}\n\nfloat col = .0;\nvec2 offset = vec2(0.,0.);\n//float radiusOut = .3;\n//float radiusIn = 0.;\nfloat radius = 1.2;\nint circleCount = 64;\n\n//float distanceBetweenCircles = 0.005;\nfloat speed = 1.;\n//float circleThickness = 0.002;\n//float circleThickness = 0.9;\nfloat borderThickness = 0.025;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates for y axis (from 0 to 1) + offset\n    vec2 uv = fragCoord/iResolution.y;\n    uv -= vec2(0.888888,0.5);\n    offset = vec2(uv.x+sin(iTime)*.1,uv.y+sin(iTime*2.)*.1);\n    \n    float circleCountFloat = float(circleCount);\n    //radiusIn = radiusOut*.9;\n    \n    //czas\n    \n    //rysowanie kolek\n    for (int i = 0; i < circleCount; i++){\n    float circleCounter = float(circleCount);\n    //col += 1./(circleCountFloat)*drawDiscSmooth(offset,borderThickness,radius);\n    col += 1./(circleCounter)*drawDiscSmooth(offset,borderThickness,radius);\n    \n    \n    \n    offset.x += .01*sin(iTime)*cos(iTime*.5);\n    \n    col *= 1.15;\n   // col += col*fract(iTime*3.)*.2;\n    radius -= (1./(circleCountFloat))*1.4;\n    borderThickness*=.99;\n    \n    }\n    \ncol+= 15.*col*drawDiscSmooth(offset-vec2(.1*sin(iTime)*cos(iTime*.5),0.),.05,fract(-iTime*1.)); \ncol+= 15.*col*drawDiscSmooth(offset-vec2(.1*sin(iTime)*cos(iTime*.5),0.),.05,fract((-iTime-0.33)*1.));\ncol+= 15.*col*drawDiscSmooth(offset-vec2(.1*sin(iTime)*cos(iTime*.5),0.),.05,fract((-iTime-0.66)*1.));    \n    /*\n    for (int i = -circleCount; i < circleCount; i++){\n   \n    col += drawCircle(uv-vec2(offset,.0),radiusOut,radiusIn);\n    offset += distanceBetweenCircles*cos(iTime);\n    radiusOut *= circleThickness;\n    radiusIn *= circleThickness;\n    distanceBetweenCircles *= .9;\n    \n    }\n    */\n    col *= (sin(iTime*2.)+1.)*.2;\nclamp(col,0.,1.);\n\n    // Output to screen\n    fragColor = vec4(col,col*((sin(iTime)+1.)*.5)*.2,0.,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssdSDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 43, 43, 87], [88, 88, 150, 150, 217], [218, 218, 285, 285, 363], [556, 652, 709, 779, 2232]]}
{"id": "ssdSDN", "name": "TIME FERRETS", "author": "d3v_null", "description": "TIME FERRETS", "tags": ["timeferrets"], "likes": 1, "viewed": 28, "published": "Public", "date": "1633193341", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define tau 6.283185307\n#define pi tau/2.\n#define sharp 0\n#define arms 2.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float m = max(iResolution.x, iResolution.y);\n    vec2 uv = 0.5 * (fragCoord.xy - (0.5 * iResolution.xy)) / m;\n    // uv = uv * 2.0 - vec2(1.0);\n    \n    // rt is (r, θ) but both normalized [0,1]\n    vec2 rt = vec2(length(uv),atan(uv.y, uv.x)/tau + 0.5);\n    float a = 10.0 * cos(iTime/2.);\n    float b = iTime/3.;\n    float c = sin(iTime);\n    float d = mod((4.0 * rt.y) + rt.x * a + c, 2.0);\n#if sharp\n    if (d < 0.5) {\n        d = 0.;\n    } else {\n        d = 1.;\n    }\n#endif\n    fragColor = vec4(\n        0.5 + 0.5 * sin(d * pi) , \n        0., \n        0.5 + 0.5 * sin((2.-d) * pi), \n        1.\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssdSDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 75, 132, 182, 796]]}
{"id": "ssdSW7", "name": "sine moire patterns", "author": "izutionix", "description": "­", "tags": ["moire"], "likes": 0, "viewed": 35, "published": "Public", "date": "1633379373", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (sin(fragCoord+iTime*.05)*(10.*iTime+1024.)-.5*iResolution.xy)/iResolution.y;\n    fragColor = vec4(smoothstep(1., 0., 64.*abs(length(uv)-.4)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssdSW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 217]]}
{"id": "ssdXD7", "name": "Fork Fractal 85", "author": "spenceryonce", "description": "fractal", "tags": ["3d", "fractal", "rainbow", "trippy", "surreal"], "likes": 4, "viewed": 116, "published": "Public", "date": "1633392487", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\n\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));\n    float i=0.,g=0.,e,s,h,a;\n    for(;++i<99.;)\n    {\n        p=g*d;\n        p.z+=iTime*0.1;\n        p=sin(p);\n        p=R(p,vec3(.577),iTime*.5);\n        p=abs(p)-.2;//-.2 is nice, \n        p=p.x<p.y?p.yzx:p.zyx;\n        p=p.x<p.y?p.zxy:p.zyx;\n        s=2.;\n        for(int i=0;i++<8;){\n          s*=e=2./clamp(dot(p,p),.3,1.2);\n          p=abs(p)*e-vec3(.8,8,.8);\n        }\n        a=1.;\n        p-=clamp(p,-a,a);\n        g+=e=length(p)/s;\n        O.rgb+=(H(s*.01)+.5)*.01*exp(-.2*i*i*e);\n    }\n    O=pow(O,vec4(4));\n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssdXD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 107, 143, 143, 748]]}
{"id": "ssdXRB", "name": "step time", "author": "gunzes", "description": "cwiczonko", "tags": ["time"], "likes": 5, "viewed": 57, "published": "Public", "date": "1633538681", "time_retrieved": "2021-10-01T00:00:00", "image_code": "    // int-float-int \n    /*\n    int ziomek = 1;\n    float ziomekFloat = float(ziomek);\n    int ziomekInt = int(ziomekFloat);\n    */\n    \n    //funkcje rysowania \nfloat drawDisc(vec2 coord,float radiusOut){\n    return step(length(coord),radiusOut);\n}\nfloat drawCircle(vec2 coord, float radiusOut, float radiusIn){\n    return drawDisc(coord,radiusOut) - drawDisc(coord,radiusIn);\n}\nfloat drawCircleSmooth(vec2 coord, float borderThickness, float radius, float color){\n\n    return (1.-smoothstep(0.,borderThickness,abs(radius-sqrt(dot(coord,coord)))))*color;\n}\n\n    //zmienne globalne\n\n\n\n    //main image\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates for y axis (from 0 to 1) + offset\n    vec2 uv = fragCoord/iResolution.y;\n    uv -= vec2(0.888888,0.5);\n    uv.x -= sin(iTime*.5)*.4;\n    uv.y -= sin(iTime)*.4;\n    //zmienne\n    \n    int stepNumberInt =15;\n    float col = .0;\n    float startRadius = 0.02;\n    float circleWidth = 0.02;\n    float stepSpeed = 5.;\n    float stepNumber = float(stepNumberInt);\n    float timeStep = 0.;\n    float czas     =  fract((iTime/stepNumber)*stepSpeed)*stepNumber;\n    float circleColor = 1.;\n    \n    //rysowanie kolek\n    for (int i=0; i<stepNumberInt; i++){\n        \n        if (czas>=timeStep){\n            col += drawCircleSmooth(uv,circleWidth,startRadius,circleColor);\n            startRadius += (1./stepNumber) *.5;\n            //startRadius *=  1.5;\n            timeStep+=1.;\n            circleWidth += (1./stepNumber)*0.02;\n            circleColor -= (1./stepNumber)*1.;\n            uv.x += sin(iTime*.5)*.4*(1./stepNumber);\n            uv.y += sin(iTime)*.4*(1./stepNumber);\n            uv.x += sin(iTime*.5)*(1./stepNumber)*.8;\n\n        }\n        //uv.x += cos(iTime*.5)*(1./stepNumber);\n        \n    }\n    col = pow(col,2.9);\n    col = clamp(col,0.,1.);\n    //output\n    fragColor = vec4(col,col,0.,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssdXRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[142, 163, 206, 206, 250], [251, 251, 313, 313, 380], [381, 381, 466, 466, 558], [590, 603, 660, 731, 1903]]}
{"id": "ssdXRs", "name": "Linear transformation", "author": "trinketMage", "description": "Linear transformation testing from 3Blue1Brown on YT\n", "tags": ["lineartransformation", "cineshader", "matrix2"], "likes": 1, "viewed": 480, "published": "Public API", "date": "1633781406", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n    uv -= 0.5;\n    float count = 16.;\n    \n    mat2 transformation = mat2(\n        cos(iTime), -sin(iTime),\n        sin(iTime), cos(iTime)\n    );\n    vec2 mvUv = transformation * uv;\n\n    vec2 cell = fract(mvUv * count);\n    \n    fragColor = vec4(cell.x * cell.y);\n    fragColor.a *= 0.25;\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Linear transformation\",\n\t\"description\": \"Linear transformation and matrices\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssdXRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 388]]}
{"id": "ssGGWc", "name": "Flaming Mandelbulb", "author": "seven_dc", "description": "rotating mandelbulb raymarcher", "tags": ["mandelbulbraymarch"], "likes": 1, "viewed": 102, "published": "Public", "date": "1633373345", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 2.\n#define SURF_DIST .0001\n\n#define ITERATIONS 8\n#define BAILOUT 50.1\n#define POWER 8.\n\nmat2 Rotate(float a) {\n  float s = sin(a);\n  float c = cos(a);\n  return mat2(c, -s, s, c);\n}\n\n// http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\nvec2 DE(vec3 pos) {\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n    int i = 0;\n\tfor (i = 0; i < ITERATIONS ; i++) {\n\t\tr = length(z);\n\t\tif (r>BAILOUT) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, POWER-1.0)*POWER*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,POWER);\n\t\ttheta = theta*POWER;\n\t\tphi = phi*POWER;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn vec2(0.5*log(r)*r/dr,i);\n}\n\nvec2 GetDistance(vec3 point) {\n    vec3 p = point;\n    p.yz *= Rotate(iTime/10.);\n    p.xy *= Rotate(iTime/10.);\n    return DE(p);\n}\n\nvec2 RayMarch(vec3 rayOrgin, vec3 rayDirection) {\n\tfloat distance=0.;\n    vec2 d = vec2(0.);\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 point = rayOrgin + rayDirection * distance;\n        d = GetDistance(point);\n        float surfaceDistance = d.x;\n        distance += surfaceDistance;\n        // Stop marching if we go too far or we are close enough of surface\n        if(distance>MAX_DIST || surfaceDistance<SURF_DIST) break;\n    }\n    \n    return vec2(distance, d.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // put 0,0 in the center\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n       \n    // camera   \n    float diff = iTime/10.;\n    vec3 rayOrgin = vec3(0.63-(sin(diff)*.3), 0.2-(sin(diff)*.05), -1.-(sin(diff)*.5));\n    vec3 rayDirection = normalize(vec3(uv.x, uv.y, 1));\n\n    vec2 data = RayMarch(rayOrgin, rayDirection);\n    float d = clamp(data.x,0.,1.) + .2;\n    float r = (data.y)/2. - d;\n    float g = data.y/5. -d;\n    float b = data.y/15. -d;\n    \n    vec3 col = vec3(r,g,b);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssGGWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[127, 127, 149, 149, 219], [221, 347, 366, 366, 913], [915, 915, 945, 945, 1047], [1049, 1049, 1098, 1098, 1530], [1532, 1532, 1589, 1618, 2124]]}
{"id": "ssGSDm", "name": "Quaternion Kinematics", "author": "spalmer", "description": "simple demo of my wee quaternion library", "tags": ["animation", "quaternion", "bones"], "likes": 16, "viewed": 220, "published": "Public API", "date": "1634740940", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define quat vec4\n\nconst quat qidentity = quat(0,0,0,1);\n\n// quaternion from 2 unit vectors\nquat qfromto(vec3 vsrc, vec3 vdst) // construct rotation that maps vsrc to vdst\n{\n    vec3 vhalf = vsrc + vdst;\n    vhalf *= length(vdst) / length(vhalf);\n    return quat(cross(vsrc, vhalf), dot(vsrc, vhalf));\n}\n\nquat qaxisangle(vec3 axis, float rad)\t// axis should be unit length!!\n{\n    rad *= .5;\n    return quat(sin(rad) * axis, cos(rad));\n}\n\n// conjugate\nquat qrev(quat q)\n{\n    q.w = -q.w;\n    return q;\n}\n\n// quaternion composition\nquat qmul(quat a, quat b)\n{\n\tvec3 va = a.xyz, vb = b.xyz;\n\treturn quat(b * a.w) - quat(cross(vb, va) - va * b.w, dot(va, vb));\n}\n\nquat qrenormalize(quat q)\n{\n    float l2 = dot(q, q);\n\treturn l2 == 1. ? q : .5 * (3. - l2) * q;\n}\n\nvec3 qrot(quat q, vec3 r)\n{\n\tvec3 axis = q.xyz;\n\tfloat w = q.w;\n\treturn 2.*((cross(axis,r) + r * w) * w + axis * dot(axis,r)) - r;\n}\n\n#if 0\n// unused here, enjoy\nquat qlog(quat q)\n{\n\tvec3 v = q.xyz;\n\tfloat l = length(v), s = 2. * atan(l / q.w) / l;\n\treturn quat(v * s, l);\n}\n\nquat qexp(quat v)\n{\n\tvec3 v3 = v.xyz;\n\tfloat a = dot(v3, v3);\n\tif (a < 1e-7) return qidentity;\n\ta = .5 * sqrt(a);\n\treturn quat(v3 * (sin(a) * .5 / a), cos(a));\n}\n\n// untested, just tossed together to demo qlog,qexp instead of porting original lol - probably backward\nquat qslerp(quat a, quat b, float i)\n{\n    // BUG yeah it'll go around the wrong long \n    // hyper-geodesic half the time, needs bit of work\n    if (dot(a, b) < 0.) b.w = -b.w; // should help\n    return qmul(a, qexp(qlog(qmul(qrev(a), b)) * i));\n}\n#endif\n\n// not super efficient,\n// just showing how to use this\n// mini quaternion library.\nvec3 QrbitCamera(vec2 a, vec3 d)\n{\n    a.y = clamp(a.y, -.5, .5);\n    const float pi = acos(-1.);  //3.141592\n    a *= pi;\n    quat q = qidentity;\n    q = qmul(q, qaxisangle(vec3(0,1,0), 2.*a.x));\n    q = qmul(q, qaxisangle(vec3(-1,0,0), a.y));\n    q = qrenormalize(q);\n    return qrot(q, d);\n}\n\nfloat dbox(vec3 p, vec3 e)\n{\n    p = abs(p); p -= e; \n    return all(lessThan(p, vec3(0)))\n     ? max(max(p.x, p.y), p.z)\n     : length(max(p, vec3(0)));\n}\n\nvec2 scene(vec3 e)\n{\n    e.xz = abs(e.xz); // duplicate scene into quadrants\n    //if (e.x > e.z) e.xz = e.zx;\n    e.zx -= 6.;\n    float dp = e.y + .1*(cos(9.*e.x) + cos(9.*e.z));\n    vec2 r = vec2(dp, 1);\n    vec3 p0 = vec3(0), p1;\n    float a = .2 * sin(iTime * 1.7);\n    quat q = qidentity, R = quat(normalize(vec3(.5,1,-.2)) * sin(a), cos(a));\n    for (int i = 8; i-- > 0; ) {\n        p1 = p0;\n        p0 += qrot(q, vec3(0,1,0));\n        float d = dbox(qrot(qrev(q), e - .5*(p0 + p1)), vec3(.1,.4,.1)) - .1;\n        if (d < r.x) r = vec2(d, i+2);\n        q = qmul(q, R);\n        q = qrenormalize(q);\n    }\n    return r;\n}\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    o = iMouse; // bonus: initializes o\n    vec3 e = iResolution,\n      d = normalize(vec3((p - .5 * e.xy) / e.y, 1));\n\to.xy /= e.xy; // last use of resolution, now e -> eye pos\n    if (abs(o.z) > 1.) // quality detail in lists and prior to click\n        o -= .5;\n    else\n        o.x += .1*sin(.2*iTime);    \n    d = QrbitCamera(o.xy, d); // quaternion look\n    d = normalize(d);\n    e -= e; e.y += 4.; // ray init    \n    float r = 24., t = 0.; // sphere caster\n    vec2 h;\n    for (int i = 40; \n      h = scene(e),\n      h.x *= .8,\n      t += h.x, e += h.x * d, // march\n      i-- > 0 && abs(h.x) >= .001 * t && t < r && e.y < 9.; );\n    o -= o - exp(-.06 * min(r, t)); // black fog\n    float g = (scene(e + vec3(.1)).x - scene(e).x) / length(vec3(.1)); // directed gradient\n    o.rgb *= clamp(g * .25 + .5, 0., 1.); // simple lighting\n    o.rgb *= cos(vec3(0,2,4)-1.+11.7*h.y) * .5 + .5; // albedo\n    if (e.y >= 9. || t > r) o *= 0.;\n    o = sqrt(o); // gamma\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssGSDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 92, 173, 173, 303], [305, 305, 376, 376, 437], [439, 452, 471, 471, 503], [505, 531, 558, 558, 659], [661, 661, 688, 688, 759], [761, 761, 788, 788, 893], [1561, 1645, 1679, 1679, 1939], [1941, 1941, 1969, 1969, 2096], [2098, 2098, 2118, 2118, 2723], [2725, 2725, 2761, 2761, 3728]]}
{"id": "ssGSzw", "name": "Fork Branchless deus0 598", "author": "deus0", "description": "Typical DDA algorithms used for voxel traversal use if statements to decide which axis to advance the ray along.  I have devised a modification that eliminates most of them, increasing the performance on GPUs, which do not cope well with branching code.", "tags": ["3d", "raymarching", "raycasting", "voxel"], "likes": 2, "viewed": 182, "published": "Public API", "date": "1634831912", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//The raycasting code is somewhat based around a 2D raycasting toutorial found here: \n//http://lodev.org/cgtutor/raycasting.html\n\nconst bool USE_BRANCHLESS_DDA = true;\nconst int MAX_RAY_STEPS = 64;\n\nfloat sdSphere(vec3 p, float d) { return length(p) - d; } \n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\t\nbool getVoxel(ivec3 c, float iTime) {\n    vec3 p = vec3(c) + vec3(0.5);\n    float d = min(max(-sdSphere(p, 7.5), sdBox(p, vec3(6.0))), -sdSphere(p, 42.0 + 16.0 * sin(iTime * 0.1)));\n    return d < 0.0;\n}\n\nvec2 rotate2d(vec2 v, float a) {\n\tfloat sinA = sin(a);\n\tfloat cosA = cos(a);\n\treturn vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA);\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 screenPos = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\tvec3 cameraDir = vec3(0.0, 0.0, 0.8);\n\tvec3 cameraPlaneU = vec3(1.0, 0.0, 0.0);\n\tvec3 cameraPlaneV = vec3(0.0, 1.0, 0.0) * iResolution.y / iResolution.x;\n\tvec3 rayDir = cameraDir + screenPos.x * cameraPlaneU + screenPos.y * cameraPlaneV;\n\tvec3 rayPos = vec3(0.0, 2.0 * sin(iTime * 0.5), -24.0);\n\t\t\n\trayPos.xz = rotate2d(rayPos.xz, 0.1 * iTime);\n\trayDir.xz = rotate2d(rayDir.xz, 0.1 * iTime);\n\t\n\tivec3 mapPos = ivec3(floor(rayPos + 0.));\n\n\tvec3 deltaDist = abs(vec3(length(rayDir)) / rayDir);\n\t\n\tivec3 rayStep = ivec3(sign(rayDir));\n\n\tvec3 sideDist = (sign(rayDir) * (vec3(mapPos) - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist; \n\t\n\tbvec3 mask;\n\t\n\tfor (int i = 0; i < MAX_RAY_STEPS; i++) {\n\t\tif (getVoxel(mapPos, iTime)) continue;\n\t\tif (USE_BRANCHLESS_DDA) {\n            //Thanks kzy for the suggestion!\n            mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));\n\t\t\t/*bvec3 b1 = lessThan(sideDist.xyz, sideDist.yzx);\n\t\t\tbvec3 b2 = lessThanEqual(sideDist.xyz, sideDist.zxy);\n\t\t\tmask.x = b1.x && b2.x;\n\t\t\tmask.y = b1.y && b2.y;\n\t\t\tmask.z = b1.z && b2.z;*/\n\t\t\t//Would've done mask = b1 && b2 but the compiler is making me do it component wise.\n\t\t\t\n\t\t\t//All components of mask are false except for the corresponding largest component\n\t\t\t//of sideDist, which is the axis along which the ray should be incremented.\t\t\t\n\t\t\t\n\t\t\tsideDist += vec3(mask) * deltaDist;\n\t\t\tmapPos += ivec3(vec3(mask)) * rayStep;\n\t\t}\n\t\telse {\n\t\t\tif (sideDist.x < sideDist.y) {\n\t\t\t\tif (sideDist.x < sideDist.z) {\n\t\t\t\t\tsideDist.x += deltaDist.x;\n\t\t\t\t\tmapPos.x += rayStep.x;\n\t\t\t\t\tmask = bvec3(true, false, false);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsideDist.z += deltaDist.z;\n\t\t\t\t\tmapPos.z += rayStep.z;\n\t\t\t\t\tmask = bvec3(false, false, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (sideDist.y < sideDist.z) {\n\t\t\t\t\tsideDist.y += deltaDist.y;\n\t\t\t\t\tmapPos.y += rayStep.y;\n\t\t\t\t\tmask = bvec3(false, true, false);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsideDist.z += deltaDist.z;\n\t\t\t\t\tmapPos.z += rayStep.z;\n\t\t\t\t\tmask = bvec3(false, false, true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvec3 color;\n\tif (mask.x) {\n\t\tcolor = vec3(0.5);\n\t}\n\tif (mask.y) {\n\t\tcolor = vec3(1.0);\n\t}\n\tif (mask.z) {\n\t\tcolor = vec3(0.75);\n\t}\n\tfragColor.rgb = color;\n\t//fragColor.rgb = vec3(0.1 * noiseDeriv);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssGSzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 199, 232, 232, 256], [259, 259, 290, 290, 386], [389, 389, 426, 426, 592], [594, 594, 626, 626, 737], [739, 739, 796, 796, 3071]]}
{"id": "ssGXDt", "name": "Polar Pattern ", "author": "Silas_Wang", "description": "Watched BigWIngs Space GIF video and tested on polar coordinate.", "tags": ["pattern"], "likes": 5, "viewed": 50, "published": "Public", "date": "1635562106", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// modification based on BigWIngs shader\n// https://www.shadertoy.com/view/wdlGRM\n\n#define PI 3.1415926535\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord.xy-iResolution.xy*.5)/iResolution.y;\n\t\n    uv *= 10.;\n    \n    float angle = atan(uv.y, uv.x);\n    float radius = length(uv) * 2.;\n    \n    // convert to polar coordinate\n    vec2 gv = mod(vec2(angle, radius), PI/3.); \n\tvec2 id = floor(vec2(angle, radius)/PI/1.) ;\n    \n\tfloat m = 0.;\n    float t;\n    for(float y=-1.; y<=1.; y++) {\n    \tfor(float x=-1.; x<=1.; x++) {\n            vec2 offs = vec2(x, y);\n            t = -iTime+length(id.y)*.2+4.; \n            float r = mix(.45, 2., sin(t)*.5+.5);\n    \t\tfloat c = smoothstep(r, r*.9, length(gv+offs));\n    \t\tm = m*(1.-c) + c*(1.-m);\n        }\n    }\n       \n    \n    fragColor = vec4(m );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssGXDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 108, 165, 165, 832]]}
{"id": "ssGXRG", "name": "Smiling Face - TAOC exercise", "author": "Sir_Dudard", "description": "Smiling face shader which has been done as an exercise.", "tags": ["smile"], "likes": 5, "viewed": 99, "published": "Public", "date": "1635677585", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(a,b,t) smoothstep(a,b,t)\n#define clamp01(x) clamp(x,0.,1.)\n#define white vec3(1.)\n#define red vec3(1.,0.,0.)\n#define black vec3(0.)\n#define v01 abs(sin(iTime))\n\nfloat remap01(float a, float b, float t)\n{\n    return clamp01((t-a)/(b-a));\n}\n\nfloat remap(float a, float b, float c, float d, float t)\n{\n    return remap01(a,b,t) * (d-c) + c;\n}\n\nvec2 within(vec2 uv, vec4 rect)\n{\n    return (uv - rect.xy)/(rect.zw-rect.xy);\n}\n\nvec4 Brow(vec2 uv, float smile)\n{    \n\n    float offset = mix(0.2,0.0,smile);\n    uv.y -= offset;\n    \n    float y = uv.y;\n        \n    uv.y += uv.x*mix(0.8,0.5,smile) - mix(.3,.1,smile);\n    uv.x -= mix(.1,0.,smile);\n    \n    uv -= 0.5;\n    \n    float d1 = length(uv);\n    float d2 = length(uv - vec2(0.05,-0.1));\n    \n    float blur = 0.1;\n    \n    float s1 = S(0.45,0.45-blur,d1);\n    float s2 = S(0.5,0.5-blur,d2);\n    \n    float browMask = clamp01(s1 - s2);\n    float glowMask = remap01(.7,.8,y);\n    glowMask *= S(0.3,0.7,browMask);\n    glowMask *= (1.-smile);\n    vec4 browColor = mix(vec4(.4,.2,.2,1.),vec4(1., .75, .5, 1.), glowMask);\n    \n    blur += 0.1 * smile;\n    \n    uv.y +=  offset;\n    \n    d1 = length(uv);\n    d2 = length(uv - vec2(0.05,-0.1));\n    \n    s1 = S(0.45,0.45-blur,d1);\n    s2 = S(0.5,0.5-blur,d2);\n    \n    float shadowMask = clamp01(S(0.45,0.45-blur,d1) - S(0.5,0.5-blur,d2));\n    \n    vec4 shadowColor = mix(vec4(0.,0.,0.,0.),vec4(0.,0.,0.,1.),S(0.,1.,shadowMask)*0.8);\n    \n    vec4 color = mix(shadowColor, browColor,  S(.1,.2,browMask));\n    \n    return color;\n}\n\nvec4 Eye(vec2 uv, vec2 mouse, float smile, float side)\n{\n    uv -= 1.;\n    uv.x *= side;\n    \n    float d = length(uv);\n\n    vec4 irisColor = vec4 (.3,.5,1.,1.);\n    vec4 color = mix(vec4(white,1.), irisColor,S(.1,1.8,d));\n    color.a = S(1.,0.96, d);\n    \n    color.rgb *= 1. - S(.9, 1., d) * 0.5 * clamp01(-uv.y - uv.x * side);\n    \n    d = length(uv - mouse * 0.5);\n    float irisMask =  S(.5,.48, d);\n    \n    color.rgb = mix(color.rgb, black, irisMask);\n    \n    irisColor.rgb *= 1. + S(.4,.1,d);\n    color.rgb = mix(color.rgb, irisColor.rgb, S(.45,.43, d));\n    \n    d = length(uv - mouse * 0.6);\n    \n    float pupilSize = mix(.25,.5,smile);\n    float pupilMask = S(pupilSize, pupilSize * .95, d) * irisMask;\n    color.rgb = mix(color.rgb, black, pupilMask);\n    \n    float t = iTime*3.;\n    vec2 offset = vec2(sin(t+uv.y*25.), sin(t+uv.x*25.));\n    offset *= .01*smile;\n    \n    uv += offset;\n    \n    float highlight = S(.2,.18, length(uv - vec2(-0.3,0.3)));\n    highlight += S(.1,.09, length(uv - vec2(0.12,-0.12)));\n    color.rgb = mix (color.rgb, white, highlight);\n    return color;\n}\n\nvec4 Mouth(vec2 uv, float smile)\n{\n    uv -=0.5;\n    \n    vec4 color = vec4(.5, .18, .05, 1.);\n    \n    uv.y *= 1.5;\n    uv.y -= uv.x * uv.x * (1. - smile);\n    uv.x *= mix(1., 2.5, smile);\n    \n    float d = length(uv);\n    color.a = S(1.,.98,d);\n    \n    vec2 tUv = uv;\n    tUv.y += (abs(uv.x)*.5+.1)*smile;\n    float td = length (tUv - vec2(0.,1.2));\n    \n    vec3 toothCol = white * S(1.4, .7, d);\n    \n    color.rgb = mix(color.rgb, toothCol, S(.9,.84,td));\n    \n    td = length (uv - vec2(0., -1.0));\n    color.rgb = mix(color.rgb, vec3(1., .5, .5), S(1.,.4, td));\n    \n    return color;\n}\n\nvec4 Head(vec2 uv)\n{\n\n    vec4 color = vec4(1, .65, .2,1.);\n    \n    float d = length(uv);\n    color.a = S(1.,.98,d);\n    \n    float edgeShade = remap01(0.7,1.,d);\n    edgeShade *= edgeShade;\n    color.rgb *= 1. - edgeShade*.5;\n   \n    color.rgb = mix(color.rgb, vec3(.7,.3,.1), S(0.94,0.95,d));\n   \n    float highlight = S(0.82,0.8, d);\n    highlight *= S(0.35,0.37, length(uv - vec2(0.43,0.13)));\n    highlight *= remap(1.,0., 0.95, 0.0,uv.y);\n    color.rgb = mix (color.rgb,white,highlight);\n    \n    //Left cheek\n    d = length(uv-vec2(.5,-.4));\n    float cheek = S(.4,.1,d) * 0.4;\n    cheek *= step(d,.36);\n    color.rgb = mix(color.rgb, vec3(1.,.1,.1), cheek);\n        \n    return color;\n}\n\nvec4 Smiley(vec2 uv, vec2 mouse, float smile)\n{\n    vec4 color = vec4(0.);\n    \n    float side = sign(uv.x);\n    uv.x = abs(uv.x);\n    \n    vec4 head = Head(uv);\n    vec4 eye = Eye(within(uv,vec4(.09,-.2,.415, .135)), mouse, smile, side);\n    vec4 mouth = Mouth(within(uv,vec4(-.3,-.7,.3, -.4)), smile);\n    vec4 brow = Brow(within(uv, vec4(0.03,0.3,0.8,0.85)), smile);\n    \n    color = mix(color, head, head.a);\n    color = mix(color, eye, eye.a);\n    color = mix(color, mouth, mouth.a);\n    color = mix(color, brow, brow.a);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy*2.0 - iResolution.xy)/iResolution.y;\n    vec2 mouse = iMouse.xy/iResolution.xy - 0.5;\n    float smile = (cos(iTime) + 1.)/2.;\n \n    float ratio = (iResolution.y/iResolution.x);\n    vec2 scaledUV = uv/2.;\n    uv -= mouse * (0.25-dot(scaledUV,scaledUV));\n    \n    fragColor = Smiley(uv, mouse, smile);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssGXRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[171, 171, 213, 213, 248], [250, 250, 308, 308, 349], [351, 351, 384, 384, 431], [433, 433, 466, 466, 1532], [1534, 1534, 1590, 1590, 2631], [2633, 2633, 2667, 2667, 3228], [3230, 3230, 3250, 3250, 3925], [3927, 3927, 3974, 3974, 4478], [4480, 4480, 4537, 4537, 4867]]}
{"id": "ssGXWW", "name": "Parallelepiped from 3-Simplex", "author": "paniq", "description": "Based on Varignon's Theorem. Performed here entirely in projective space.", "tags": ["parallelogram", "quadliteral", "varignon"], "likes": 14, "viewed": 200, "published": "Public API", "date": "1634639199", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// using 2d vector graphics library (https://www.shadertoy.com/view/lslXW8)\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1);\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1);\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r);\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r);\nvoid set_source(sampler2D image);\n// control how source changes are applied\nconst int Replace = 0; // default: replace the new source with the old one\nconst int Alpha = 1; // alpha-blend the new source on top of the old one\nconst int Multiply = 2; // multiply the new source with the old one\nvoid set_source_blend_mode(int mode);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add an ellipse path at P with radii RW and RH\nvoid ellipse(vec2 p, vec2 r);\nvoid ellipse(float x, float y, float rw, float rh);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n// add a rectangle at O with size S and rounded corner of radius R\nvoid rounded_rectangle(vec2 o, vec2 s, float r);\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// source channel for texture font\n#define font_texture_source iChannel1\n// draw a letter with the given texture coordinate\nvoid letter(ivec2 l);\nvoid letter(int lx, int ly);\n    \n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// non-uniformly scale the context by S\nvoid scale(vec2 s);\nvoid scale(float sx, float sy);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    vec2 clip;\n    vec2 scale;\n    float line_width;\n    bool premultiply;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n    int source_blend;\n    bool has_clip;\n};\n\n// save current stroke width, starting\n// point and blend mode from active context.\nContext _save();\n#define save(name) Context name = _save();\n// restore stroke width, starting point\n// and blend mode to a context previously returned by save()\nvoid restore(Context ctx);\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\nvoid debug_clip_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\n// your draw calls here\n//////////////////////////////////////////////////////////\n\nvec2 lissajous(float t, float a, float b) {\n    return vec2(sin(a*t), sin(b*t));\n}\n\nconst float R = 0.02;\nvoid paint_plane(vec2 p4, vec2 p5, vec2 p6, vec2 p7) {\n    circle(p4, R);\n    circle(p5, R);\n    circle(p6, R);\n    circle(p7, R);\n\tfill();\n\n    move_to(p4);\n\tline_to(p5);\n    line_to(p6);\n    line_to(p7);\n    close_path();\n    stroke();\n}\n\nvoid paint() {\n    float t = iTime * 0.1;\n\n    // clear screen with a subtle gradient\n\n    set_source_rgb(vec3(0.0));\n    clear();\n    \n    scale(0.7);\n    set_source_rgb(vec3(1.0));\n\tset_line_width_px(1.0);\n    \n    vec2 p0 = lissajous(t, 5.0, 4.0);\n    vec2 p1 = lissajous(t + 1.0, 5.0, 4.0);\n    vec2 p2 = lissajous(t + 2.0, 5.0, 4.0);\n    vec2 p3 = lissajous(t + 3.0, 5.0, 4.0);\n    \n    vec2 p01 = (p0 + p1)*0.5;\n    vec2 p02 = (p0 + p2)*0.5;\n    vec2 p03 = (p0 + p3)*0.5;\n    vec2 p12 = (p1 + p2)*0.5;\n    vec2 p13 = (p1 + p3)*0.5;\n    vec2 p23 = (p2 + p3)*0.5;\n    \n    // center\n    vec2 p0123 = (p0 + p1 + p2 + p3)*0.25;\n    // orthogonal vectors\n    float S = 1.0 / 3.0;\n    vec2 gx = (p23 - p0123) * S;\n    vec2 gy = (p13 - p0123) * S;\n    vec2 gz = (p12 - p0123) * S;\n    // cube vertices\n    vec2 c000 = p0123 - gx - gy - gz;\n    vec2 c001 = p0123 - gx - gy + gz;\n    vec2 c010 = p0123 - gx + gy - gz;\n    vec2 c011 = p0123 - gx + gy + gz;\n    vec2 c100 = p0123 + gx - gy - gz;\n    vec2 c101 = p0123 + gx - gy + gz;\n    vec2 c110 = p0123 + gx + gy - gz;\n    vec2 c111 = p0123 + gx + gy + gz;\n\n    circle(p0, R);\n    circle(p1, R);\n    circle(p2, R);\n    circle(p3, R);\n\tfill();\n    \n    set_source_rgba(1.0, 0.5, 0.5, 1.0);\n    move_to(p0);\n    line_to(p2);\n    stroke();\n\tmove_to(p1);\n    line_to(p3);\n    stroke();\n    paint_plane(p01, p12, p23, p03);\n    set_source_rgba(0.5, 1.0, 0.5, 1.0);\n    move_to(p0);\n\tline_to(p1);\n    stroke();\n    move_to(p2);\n\tline_to(p3);\n    stroke();\n    paint_plane(p02, p12, p13, p03);\n    set_source_rgba(0.5, 0.5, 1.0, 1.0);\n    move_to(p0);\n\tline_to(p3);\n    stroke();\n    move_to(p1);\n\tline_to(p2);\n    stroke();\n    paint_plane(p01, p13, p23, p02);\n    \n    \n    set_source_rgb(vec3(1.0));\n    move_to(c000);\n    line_to(c010);\n    line_to(c110);\n    line_to(c100);\n    close_path();\n    move_to(c001);\n    line_to(c011);\n    line_to(c111);\n    line_to(c101);\n    close_path();\n    move_to(c000);\n    line_to(c001);\n    move_to(c010);\n    line_to(c011);\n    move_to(c110);\n    line_to(c111);\n    move_to(c100);\n    line_to(c101);\n    stroke();\n    \n}\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\nfloat AA;\nfloat AAINV;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n#define DEFAULT_CLIP_V -1e+20\n\nContext _stack;\n\nvoid init (vec2 fragCoord) {\n    uv = fragCoord.xy / iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n\n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        vec2(DEFAULT_CLIP_V),\n        vec2(1.0),\n        1.0,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0),\n        Replace,\n        false\n    );\n}\n\nvec3 _color = vec3(1.0);\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n    _stack.clip.y = DEFAULT_CLIP_V;\n}\n\nContext _save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;\n    vec2 clip = _stack.clip;\n    bool has_clip = _stack.has_clip;\n    // preserve source\n    vec4 source = _stack.source;\n    _stack = ctx;\n    _stack.shape = shape;\n    _stack.clip = clip;\n    _stack.source = source;\n    _stack.has_clip = has_clip;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = vec2(1.0);\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;\n    _stack.scale = vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    _stack.scale *= vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(vec2 s) {\n    transform(mat3(s.x,0.0,0.0,0.0,s.y,0.0,0.0,0.0,1.0));\n}\n\nvoid scale(float sx, float sy) {\n    scale(vec2(sx, sy));\n}\n\nvoid scale(float s) {\n    scale(vec2(s));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color = mix(_color, _stack.source.rgb, _stack.source.a);\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(sqrt(_color), 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = _color;\n}\n\nvoid add_clip(vec2 d) {\n    d = d / _stack.scale;\n    _stack.clip = max(_stack.clip, d);\n    _stack.has_clip = true;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);\n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n    _stack.clip = vec2(DEFAULT_CLIP_V);\n    _stack.has_clip = false;\n}\n\nvoid debug_gradient() {\n    vec2 d = _stack.shape;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid debug_clip_gradient() {\n    vec2 d = _stack.clip;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color = _color * (1.0 - src_a) + rgba.rgb * dst_a;\n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat min_uniform_scale() {\n    return min(_stack.scale.x, _stack.scale.y);\n}\n\nfloat uniform_scale_for_aa() {\n    return min(1.0, _stack.scale.x / _stack.scale.y);\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA*uniform_scale_for_aa(), 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);\n\treturn wa * wb;\n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n    if (_stack.has_clip) {\n\t    write_color(_stack.source, calc_aa_blur(_stack.clip.x));        \n    }\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*min_uniform_scale() * AAINV;\n}\n\nfloat get_gradient_eps() {\n    return (1.0 / min_uniform_scale()) * AAINV;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    //c.rgb *= c.rgb;\n    c *= c;\n    if (_stack.source_blend == Multiply) {\n        _stack.source *= c;\n    } else if (_stack.source_blend == Alpha) {\n    \tfloat src_a = c.a;\n    \tfloat dst_a = _stack.premultiply?1.0:src_a;\n\t    _stack.source =\n            vec4(_stack.source.rgb * (1.0 - src_a) + c.rgb * dst_a,\n                 max(_stack.source.a, c.a));\n    } else {\n    \t_stack.source = c;\n    }\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) {\n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1) {\n    vec2 pa = _stack.position.xy - p0;\n    vec2 ba = p1 - p0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1) {\n    set_source_linear_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p0, p1);\n}\n\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r) {\n    float h = clamp( length(_stack.position.xy - p) / r, 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r) {\n    set_source_radial_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p, r);\n}\n\nvoid set_source_blend_mode(int mode) {\n    _stack.source_blend = mode;\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid letter(ivec2 l) {\n  vec2 p = vec2(l);\n  vec3 tx;\n  vec2 ip;\n  float d;\n  int ic;\n  ip = vec2(l);\n  p += clamp(_stack.position.xy, 0.0, 1.0);\n  ic = 0x21 + int (mod (16. + ip.x + 2. * ip.y, 94.));\n  tx = texture (font_texture_source, mod ((vec2 (mod (float (ic), 16.),\n     15. - floor (float (ic) / 16.)) + fract (p)) * (1. / 16.), 1.)).gba - 0.5;\n  d = tx.b + 1. / 256.;\n  add_field(d / min_uniform_scale());\n}\n\nvoid letter(int lx, int ly) {\n    letter(ivec2(lx,ly));\n}\n\nvoid rounded_rectangle(vec2 o, vec2 s, float r) {\n    s = (s * 0.5);\n    r = min(r, min(s.x, s.y));\n    o += s;\n    s -= r;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    vec2 df = max(dmin.xz, dmin.yw) + length2(dmax);\n    add_field(df - r);\n}\n\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), r);\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    rounded_rectangle(o, s, 0.0);\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), 0.0);\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\n// from https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n    if (l == 0.0) {\n        return length(p) - ab.x;\n    }\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 r = vec2( ab.x*co, ab.y*si );\n\t\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nvoid ellipse(vec2 p, vec2 r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(sdEllipse(c.xy, r), sdEllipse(c.zw, r)));\n}\n\nvoid ellipse(float x, float y, float rw, float rh) {\n    ellipse(vec2(x,y), vec2(rw, rh));\n}\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 s = sign(pa.xz*ba.y-pa.yw*ba.x);\n    vec2 d = length2(pa - ba.xyxy*h.xxyy);\n    add_field(d);\n    add_clip(d * s);\n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat test_cross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat bezier_sign(vec2 A, vec2 B, vec2 C, vec2 p) {\n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0,\n        step(test_cross(A, B, p) * test_cross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * test_cross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    vec2 shape = vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw));\n    add_field(abs(shape));\n    add_clip(shape);\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(abs(f_x) / length(df_x));\n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t aspect = vec2(iResolution.x / iResolution.y, 1.0);\n\t ScreenH = min(iResolution.x,iResolution.y);\n\t AA = ScreenH*0.4;\n\t AAINV = 1.0 / AA;\n\n    init(fragCoord);\n\n    paint();\n\n    blit(fragColor);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssGXWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[6041, 6125, 6168, 6168, 6207], [6231, 6231, 6285, 6285, 6470], [6472, 6472, 6486, 6486, 8576], [8753, 8813, 8840, 8840, 8866], [8868, 8928, 8949, 8949, 9056], [9058, 9058, 9095, 9095, 9181], [9183, 9183, 9229, 9229, 9262], [9264, 9402, 9430, 9430, 9890], [9918, 9918, 9937, 9937, 9970], [9972, 9972, 9990, 9990, 10023], [10025, 10025, 10049, 10049, 10153], [10155, 10155, 10172, 10172, 10193], [10195, 10195, 10222, 10244, 10527], [10529, 10529, 10557, 10557, 10791], [10793, 10793, 10817, 10817, 10903], [10905, 10905, 10932, 10932, 11145], [11147, 11147, 11173, 11173, 11401], [11403, 11403, 11425, 11425, 11551], [11553, 11553, 11573, 11573, 11633], [11635, 11635, 11667, 11667, 11694], [11696, 11696, 11717, 11717, 11739], [11741, 11741, 11765, 11765, 11825], [11827, 11827, 11861, 11861, 11885], [11887, 11887, 11901, 11901, 11965], [11967, 11967, 11993, 11993, 12031], [12033, 12033, 12059, 12059, 12080], [12082, 12082, 12105, 12105, 12200], [12202, 12202, 12226, 12226, 12295], [12297, 12297, 12322, 12322, 12369], [12371, 12371, 12388, 12388, 12501], [12503, 12503, 12526, 12526, 12655], [12657, 12657, 12685, 12685, 12813], [12815, 12815, 12839, 12839, 12979], [12981, 12981, 13019, 13019, 13153], [13155, 13155, 13192, 13192, 13227], [13229, 13229, 13256, 13256, 13306], [13308, 13308, 13338, 13338, 13394], [13396, 13396, 13425, 13425, 13606], [13608, 13608, 13630, 13630, 13797], [13799, 13799, 13812, 13812, 13851], [13853, 13853, 13883, 13883, 13912], [13914, 13914, 13947, 13947, 14004], [14006, 14006, 14032, 14032, 14082], [14084, 14084, 14105, 14105, 14170], [14172, 14172, 14196, 14196, 14279], [14281, 14281, 14296, 14296, 14337], [14339, 14339, 14355, 14355, 14393], [14395, 14395, 14413, 14413, 14470], [14472, 14472, 14502, 14524, 14906], [14908, 14908, 14966, 14966, 15004], [15006, 15006, 15035, 15035, 15071], [15073, 15073, 15121, 15121, 15152], [15154, 15154, 15188, 15188, 15247], [15249, 15249, 15326, 15326, 15491], [15493, 15493, 15570, 15570, 15650], [15652, 15652, 15728, 15728, 15844], [15846, 15846, 15922, 15922, 16000], [16002, 16002, 16040, 16040, 16074], [16076, 16076, 16098, 16098, 16144], [16146, 16146, 16173, 16173, 16217], [16219, 16219, 16241, 16241, 16635], [16637, 16637, 16666, 16666, 16694], [16696, 16696, 16745, 16745, 17006], [17008, 17008, 17081, 17081, 17135], [17137, 17137, 17169, 17169, 17205], [17207, 17207, 17263, 17263, 17319], [17321, 17321, 17351, 17351, 17444], [17445, 17445, 17485, 17485, 17508], [17510, 17556, 17595, 17595, 18751], [18753, 18753, 18783, 18783, 18885], [18887, 18887, 18939, 18939, 18979], [18981, 18981, 19003, 19003, 19054], [19056, 19056, 19088, 19088, 19110], [19112, 19127, 19149, 19149, 19441], [19443, 19443, 19475, 19475, 19497], [19499, 19499, 19518, 19518, 19550], [19599, 19662, 19704, 19704, 19770], [19772, 19842, 19893, 19893, 20245], [20247, 20281, 20327, 20327, 20839], [20841, 20910, 20956, 20956, 21462], [21464, 21464, 21497, 21497, 21713], [21715, 21715, 21774, 21774, 21819], [21821, 21821, 21864, 21864, 21925], [21927, 21927, 21969, 21969, 22011], [22013, 22073, 22130, 22130, 22329]]}
{"id": "ssK3DR", "name": "Postcard of a Mirage ", "author": "byt3_m3chanic", "description": "A shader I've kicked around for a while - parts of the noise from various @iq's examples / and add in some anisotropic glitter and floating shapes. ", "tags": ["raymarching", "fbm", "water", "anisotropic", "sand", "glitter"], "likes": 20, "viewed": 217, "published": "Public API", "date": "1635381703", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    Postcard of a Mirage \n    10/27/21 @byt3_m3chanic\n\n    A shader I've kicked around for a while. \n    Parts of the noise from various @iq's examples.\n    Add in some anisotropic glitter and floating \n    shapes, and you have a abstract isometric shader! \n*/\n\n\n#define S\tsmoothstep\n#define R   iResolution\n#define M   iMouse\n#define T   iTime\n#define PI  3.14159265\n#define PI2 6.28318530\n#define ZRO 0\n\n#define MAX_DIST    50.\n#define MIN_DIST    .001\n\nvec2 hash2( vec2 p ){ return fract(sin(vec2(dot(p,vec2(127.1,211.7)),dot(p,vec2(219.5,183.3))))*43758.5453); }\nfloat hash21(vec2 p) { return fract(sin(dot(p,vec2(23.86,48.32)))*4374.432); }\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\n// @gaz\nfloat zag(vec3 p, float s) {\n    p = abs(p)-s;\n    if (p.x < p.z) p.xz = p.zx;\n    if (p.y < p.z) p.yz = p.zy;\n    if (p.x < p.y) p.xy = p.yx;\n    return dot(p,normalize(vec3(s*.42,s,0)));\n}\n\nfloat box(vec2 p,vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// @iq\nvec3 noised( in vec2 x ){\n    vec2 f = fract(x);\n    vec2 u = f*f*(3.0-2.0*f);\n    // texel fetch version\n    vec2 p = vec2(floor(x));\n    float a = hash21( p+vec2(0,0) );\n\tfloat b = hash21( p+vec2(1,0) );\n\tfloat c = hash21( p+vec2(0,1) );\n\tfloat d = hash21( p+vec2(1,1) );\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t   6.0*f*(1.0-f)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n// @iq\nfloat fbm ( in vec2 _st, float oct) {\n    oct = min(oct,5.);\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(.5), sin(.5),-sin(.5), cos(.5));\n    for (float i = 0.; i < 8.25-oct; ++i) {\n        v += a * noised(_st).x;\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n//generate terrain using above noise algorithm\nfloat terrain( vec2 p, float freq ) {\t\n\tfloat h = -1.;\n\tfloat w = 2.6;\n\tfloat m = 0.35;\n\tfor (float i = 0.; i < freq; i++) {\n\t\th += w * noised((p * m)).x;\n\t\tw *= 0.5;\n\t\tm *= 2.0;\n\t}\n\treturn h;\n}\n\n//globals\nvec3 hitPoint,hit;\nvec2 vuv;\nmat2 r45,turn,tilt;\nfloat mvt = 0.,ghs,shs;\nfloat midpt;\n\n//constants\nconst float sz = .5;\nconst float hf = sz*.5;\nconst float db = sz *2.;\n\nvec2 map(vec3 p) {\n\tvec2 res = vec2(1e5,0.);\n    p.y+=4.;\n    vec3 pp = p;\n\n    if(vuv.x<midpt) p.z-=T*.3;\n    \n    float ter = terrain(p.xz*sz,2.)*.85;\n    float d2 = p.y - ter;\n    \n    if(d2<res.x && vuv.x<midpt) {\n       res = vec2(d2,2.);\n       hit=p;\n    }\n    \n    float d3 = pp.y-1.-(ter*.75);\n    if(d3<res.x && vuv.x>midpt) {\n        res=vec2(d3,1.);\n        hit=p;\n    }\n\n    vec2 id = floor(p.xz*sz) + .5; \n    vec2 r = p.xz - id/sz;\n    vec3 qx = vec3(r.x,p.y,r.y);\n    float hs = hash21(id);\n    float xtr = terrain(id,2.)*.85;\n    vec3 qqx=qx-vec3(0,xtr+.1,0);\n    \n    float bf = length(qqx)-(.3*hs);\n    if(bf<res.x && vuv.x<midpt && hs>.4 && xtr>1.15) {\n        res=vec2(bf,4.);\n        hit=qqx;\n        shs=hs;\n    }\n\n    float cells = 8.;\n    vec3 q = pp-vec3(0,4.5,0);\n    q.xz*=turn;\n\n    // @Shane Polar Repetion \n    float a = atan(q.z, q.x);\n    // Partitioning the angle into \"aNum\" cells.\n    float ia = floor(a/6.2831853*cells);\n    ia = (ia + .5)/cells*6.2831853;\n\n    // find object via mod and cells and wave\n    float ws = -mod(ia,.0);\n    float cy = sin( ws*4. + (T * .25) * PI) * 1.5;\n    q.y +=cy;\n\n    // Converting the radial centers to their positions.\n    q.xz *= rot(ia);\n    q.x -= 5.75;\n \n    q.zy*=rot(ws+T);\n    q.xz*=rot(ws);\n\n    float df = zag(q,.295);\n    if(df<res.x) {\n        res=vec2(df,3.);\n        hit=q;\n    }\n    \n    return res;\n}\n\n// normal\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h = vec2(1.,-1.)*.5773;\n    return normalize( \n        h.xyy*map( p + h.xyy*e ).x + \n        h.yyx*map( p + h.yyx*e ).x + \n        h.yxy*map( p + h.yxy*e ).x + \n        h.xxx*map( p + h.xxx*e ).x );\n}\n\n// water ripples - using bmp map to add extra\n// depth to water effects\nvec3 fxBumpMap( vec3 p, vec3 n, float bf, float per) {\n    vec2 e = vec2(per*MIN_DIST, 0);   \n    mat3 m = mat3( \n        vec3(fbm(p.xz - e.xy, 3.)), \n        vec3(fbm(p.xz - e.yx, 2.)), \n        vec3(fbm(p.xz - e.yy, 3.))\n    );\n    vec3 g = vec3(.3, .59, .12) * m; \n    g = (g - dot(vec3(fbm(p.xz , 3.)), vec3(.3, .59, .12)) )/e.x; g -= n*dot(n, g);  \n    return normalize( n + g*bf );\n}\n\n// reduced voronoi based off @iq\n// https://www.shadertoy.com/view/ldl3W8\n// used for the glitter pattern\nvec3 voronoi( in vec2 x) {\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\tvec2 mg, mr;\n    float md = 8.,ox = 0.;\n    for( float j=-1.; j<=1.; j++ )\n    for( float i=-1.; i<=1.; i++ )\n    {\n        vec2 g = vec2(i,j);\n\t\tvec2 o = hash2( n + g );\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n        if( d<md ){\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n    md = 8.;\n    //reduced to 1\n    for( float j=-1.; j<=1.; j++ )\n    for( float i=-1.; i<=1.; i++ )\n    {\n        vec2 g = mg + vec2(i,j);\n\t\tvec2 o = hash2( n + g );\n        ox = o.x;\n    }\n    return vec3(md,ox,mr.x);\n}\n\n// lame based off the tex3D and used\n// to add texture for glintz\nvec3 vor3D(in vec3 p, in vec3 n ){\n    n = max(abs(n), MIN_DIST);\n    n /= dot(n, vec3(1));\n\tvec3 tx = voronoi(p.yz).xyz;\n    vec3 ty = voronoi(p.zx).xyz;\n    vec3 tz = voronoi(p.xy).xyz;\n    //return mat3(tx*tx, ty*ty, tz*tz)*n;\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\nvec3 glintz( vec3 lcol, vec3 hitPoint, vec3 n, vec3 rd, vec3 lpos) {\n    vec3 mate = vec3(0);\n    vec3 pos = hitPoint;\n    \n    vec3 h = normalize(lpos-rd);\n    float nh = abs(dot(n,h)), nl = dot(n,lpos);\n    vec3 light = lcol*max(.0,nl)*1.5;\n    vec3 coord = pos*1.5, coord2 = coord;\n\n    vec3 ww = fwidth(pos);\n    vec3 glints=vec3(0);\n    float pw,q,anisotropy;\n    vec3 tcoord;\n \n    //build layers\n    for(int i = 0; i < 2;i++) {\n\n        if( i==0 ) {\n            anisotropy=.55;\n            pw=R.x*.20;\n            tcoord=coord;\n        } else {\n            anisotropy=.62;\n            pw=R.x*.10;\n            tcoord=coord2;\n        }\n        \n        vec3 aniso = vec3(vor3D(tcoord.zyx*pw,n).yy, vor3D(tcoord.xyz*vec3(pw,-pw,-pw),n).y)*1.0-.5;\n        if(i==0) {\n            aniso -= n*dot(aniso,n);\n            aniso /= min(1.,length(aniso));\n        }\n\n        float ah = abs(dot(h,aniso));\n \n        if( i==0 ) {\n            q = exp2((1.15-anisotropy)*2.5);\n            nh = pow( nh, q*4.);\n            nh *= pow( 1.-ah*anisotropy, 10.);\n        } else {\n            q = exp2((.1-anisotropy)*3.5);\n            nh = pow( nh, q*.4);\n            nh *= pow( 1.-ah*anisotropy, 150.);\n        }     \n\n        glints += \n        (lcol*nh*exp2(((i==0?1.25:1.)-anisotropy)*1.3))*smoothstep(.0,.5,nl);\n    }\n\n    return \n        mix(light*vec3(0.3), vec3(.05), .1) +\n        glints +\n        lcol * .3;\n}\n\nvec3 sky = vec3(0);\n// modified slim sky based on \n// @Shane https://www.shadertoy.com/view/WdtBzn\nvec3 ACESFilm(in vec3 x) { return clamp((x*(.6275*x+.015))/(x*(.6075*x+.295)+.14),0.,1.); }\nvec3 getSky(vec3 ro, vec3 rd, vec3 ld, float ison) { \n    rd.z *= .95 - length(rd.xy)*.5;\n    rd = normalize(rd);\n    // rayleigh / mie\n    vec3 betaR = vec3(5.8e-2, 1.35e-1, 3.31e-1), betaM = vec3(4e-2); \n    float zAng = max(2e-6, rd.y);\n    // scatter - Klassen's model.\n    vec3 extinction = exp(-(betaR*1. + betaM*1.)/zAng);\t\n    vec3 col = 2.*(1. - extinction);\n    float t = (1e5 - ro.y - .15)/(rd.y + .45);\n    vec2 vuv = (ro + t*rd).xz;\n\tif(t>0.&&ison>0.) {\n        col = mix(col, vec3(3), smoothstep(.45, 1., fbm(3.*vuv/1e5,1.))*\n                                smoothstep(.25, .65, rd.y*.5 + .5)*.4);  \n    }\n    return clamp(ACESFilm(col), 0., 1.);\n} \n\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool last, inout float d) {\n\n    vec3 sky = getSky(ro,rd,vec3(.0,.02,1.01),1.);\n    vec3 C = vec3(0);\n\n    float  m = 0.;\n    vec3 p = ro;\n    for (int i = 0; i<128;i++) {\n     \tp = ro + rd * d;\n        vec2 ray = map(p);\n        if(abs(ray.x)<d*MIN_DIST || d>MAX_DIST)break;\n        d += i<32? ray.x*.45 : ray.x*.85; \n        m = ray.y;\n    }\n    \n    hitPoint=hit;\n    ghs=shs;\n    float alpha = 0.;\n    \n    if(d<MAX_DIST){\n        alpha = d;\n      \tvec3 n = normal(p, d);\n         \n        vec3 lpos = vec3(-14.,9,-4.);\n        vec3 l = normalize(lpos-p);   \n        vec3 h = vec3(.5);\n\n        float fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 9.);\n        fresnel = mix(.0, 1., fresnel);\n        ref=vec3(.01); \n        // materials and bump\n        if(m==1.) {    \n            n = fxBumpMap(.05*T+hitPoint*.025, n, .15 ,d);\n            h = glintz(vec3(0.114,0.361,0.447), .01*T+hitPoint*.015, n, normalize(p-lpos), l);\n            ref = (h+.2)-fresnel;\n        }\n        if(m==2.) {   \n            h = glintz(vec3(0.945,0.753,0.533), hitPoint.zyx*.055, n, rd, l);\n            ref = (h*.5)-fresnel;\n        }\n        if(m==3.) {\n            ref = vec3(.7)-fresnel;\n        }\n        if(m==4.) {\n            h = mix(vec3(0.624,0.169,0.016),vec3(0.737,0.588,0.043),clamp(ghs*.85,0.,1.));\n            ref = (h*.5)-fresnel;\n        }\n        // diff and shadows\n        float diff = clamp(dot(n,l),.03,1.);\n        float shdw = 1., t = .3;\n        for(int i=0; i<18; i++){\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) {shdw = .03; break;}\n            shdw = min(shdw, 24.*h/t);\n            t += h;\n            if( shdw<MIN_DIST || t>32. ) break;\n        }\n        diff = mix(diff,diff*shdw,.65);\n\n        vec3 view = normalize(p - ro);\n        vec3 ret = reflect(normalize(lpos), n);\n        float spec = .5 * pow(max(dot(view, ret), 0.), 24.);\n\n        C += h * diff+spec;\n        C = mix(sky,C,  exp(-.000025*d*d*d));\n\n        ro = p+n*.1;\n        rd = reflect(rd,n);\n       \n    } else {\n        C = sky;\n    }\n    return vec4(C,alpha);\n}\n\nvoid topLayer(inout vec3 C, vec2 uv) {\n    float px = fwidth(uv.x);\n    //uv*=tilt;\n    float bx = box(uv-vec2(.0,.02),vec2(.9,.475))-.0025;\n    float dx = abs(bx)-.001;\n    dx=smoothstep(px,-px,dx);\n    bx=smoothstep(-px,px,bx);\n\n    float bd = box(uv-vec2(.001,-.015),vec2(.86,.435))-.0025;\n    float sd =smoothstep(.085-px,px,bd);\n\n    vec3 ln = mix(vec3(0.647,0.545,0.435),vec3(0.208,0.588,0.753),.5+uv.y*.75);\n    C=mix(C,ln,bx);\n    if(hash21(uv)>.7)C=mix(C,C*.8,bx);\n    C=mix(C,C*.15,min(sd,bx));\n    \n    float en = noised(vec2(uv.y*20.,.1)).x*.05;\n    float tp = box(uv-vec2(en*.5,.5),vec2(.2,.025));\n    float ts = smoothstep(px,-px,tp);\n    tp = abs(tp)-.001;\n    tp=smoothstep(px,-px,tp);\n    C=mix(C,C*.2,ts);\n    C=mix(C,C*.6,tp);\n\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n    // precal\n    mvt+= T*.5;\n    turn=rot(T*.2);\n\n    // uv + ro + rd\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vuv=uv;\n    float vv = uv.y;\n    midpt = .45*sin(vv*5.+T*1.15);\n\n    float zoom = 10.;\n    vec3 ro = vec3(uv*zoom,-zoom);\n    vec3 rd = vec3(0.,0.,1.);\n\n    float x = M.xy==vec2(0)?0.:(M.x/R.x * 1. - .5) * PI;\n    mat2 rx = rot(-.38531); mat2 ry = rot(-.38531+x);\n    ro.yz *= rx; ro.xz *= ry;\n    rd.yz *= rx; rd.xz *= ry;\n\n    vec3 C = vec3(0);\n    vec3 ref=vec3(0);\n    vec3 fil=vec3(1.);\n    \n    // ref loop @BigWIngs\n    float d =0.;\n    // if slow reduce to 2\n    for(float i=0.; i<3.; i++) {\n        vec4 pass = render(ro, rd, ref, i==3.-1., d);\n        C += pass.rgb*fil;\n        fil*=ref;\n    }\n\n    \n    \n    C=clamp(C,vec3(0),vec3(1));\n    topLayer(C,uv);\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}\n// end\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssK3DR.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 549, 570, 570, 659], [660, 660, 682, 682, 738], [739, 739, 758, 758, 803], [805, 813, 841, 841, 1003], [1005, 1005, 1031, 1031, 1111], [1113, 1120, 1145, 1145, 1501], [1502, 1509, 1546, 1546, 1884], [1885, 1932, 1969, 1969, 2126], [2225, 2308, 2326, 2326, 3696], [3698, 3708, 3738, 3738, 3974], [3976, 4048, 4102, 4102, 4437], [4439, 4545, 4571, 4571, 5164], [5166, 5232, 5266, 5266, 5511], [5513, 5513, 5581, 5581, 6917], [6939, 7018, 7044, 7044, 7109], [7110, 7110, 7162, 7162, 7772], [7775, 7775, 7860, 7860, 9898], [9900, 9900, 9938, 9938, 10648], [10650, 10650, 10691, 10705, 11529]]}
{"id": "ssKSD3", "name": "WhiteNoise", "author": "Zohnannor", "description": "Simple White noise. Random function from https://stackoverflow.com/a/4275343", "tags": ["noise"], "likes": 1, "viewed": 32, "published": "Public", "date": "1635435210", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 co){\n    return fract(sin(dot(co*iTime, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float col = rand(fragCoord);\n    fragColor = vec4(vec3(.7)*col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssKSD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 96], [98, 98, 155, 155, 230]]}
{"id": "ssKSDz", "name": "Desert mesas", "author": "jarble", "description": "A desert terrain based on zchajax's [url=https://www.shadertoy.com/view/3dXcW2]\"simple terrain\"[/url] shader.", "tags": ["terrain", "fbm", "mountain", "desert", "erosion", "mesa"], "likes": 6, "viewed": 150, "published": "Public API", "date": "1634508636", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SC (250.0)\n\nvec2 noise(in vec2 uv)\n{\n    //return sin(uv.x/1.6)+cos(-uv.y*1.6);\n    return vec2(sin(uv.x),cos(uv.y))+vec2(1.);\n}\n\n#define OCTAVES 8\nfloat fbm1(in vec2 uv,int octaves,float i1,float value1)\n{\n    //this function generates the terrain height\n    float value = value1;\n    float amplitude = .65/i1;\n    //float amplitude = .6/(i1+value1/4.);\n    \n    float freq = 2.1/i1;\n    float n1 = 0.;\n    vec2 noise2;\n    for (int i = 0; i < octaves; i++)\n    {\n        \n        \n        noise2 = noise(noise2.yx+uv*(freq));\n        vec2 noise1 = noise2-value;\n        freq *= 2.1;\n        n1 = noise1.x+noise1.y;\n\n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        value = (value+abs(n1) * amplitude)-n1/freq;\n        //value += n1/freq;\n        \n        amplitude *= amplitude;\n        uv -= (n1)/freq;\n        \n\n        //uv += (noise1+vec2(1.))/freq;\n        //uv1 = uv*freq;\n\n        //uv = uv.yx;\n    }\n    \n    return value;\n}\n\nfloat fbm(vec2 uv, int oct){\n    //uv *= 2.;\n    float result = 0.;\n    for(float i = 1.; i < 3.; i++){\n        float i1 = i*i;\n        result -= fbm1(uv/i1,oct,i1,result/i1);\n        oct -= 2;\n    }\n    return result/6.;\n}\n\nfloat fbm(in vec2 uv){\n    return fbm(uv,OCTAVES);\n}\n\nfloat f(in vec3 p,int iters)\n{   \n    float h = fbm(p.xz,iters);\n    return h;\n}\n\nfloat f(in vec3 p)\n{   \n    float h = fbm(p.xz,OCTAVES+4);\n    return h;\n}\n\nvec3 getNormal(vec3 p, float t)\n{\n    vec3 eps=vec3(.001 * t, .0, .0);\n    vec3 n=vec3(f(p - eps.xyy) - f(p + eps.xyy),\n                2. * eps.x,\n                f(p - eps.yyx) - f(p + eps.yyx));\n  \n    return normalize(n);\n}\n\nfloat rayMarching(in vec3 ro, in vec3 rd, float tMin, float tMax)\n{\n    float t = tMin;\n\tfor( int i = 0; i < 300; i++ )\n\t{\n        vec3 pos = ro + t * rd;\n\t\tfloat h = pos.y - f(pos,OCTAVES);\n\t\tif( abs(h) < (0.0015 * t) || t > tMax ) \n            break;\n\t\tt += 0.4 * h;\n\t}\n\n\treturn t;\n}\n\n/*\n//raymarching with LOD\nfloat rayMarching(in vec3 ro, in vec3 rd, float tMin, float tMax)\n{\n    float t = tMin;\n    int oct = 2;\n\tfor( int i = 0; i < 300; i++ )\n\t{\n        vec3 pos = ro + t * rd;\n\t\tfloat h = pos.y - f(pos,OCTAVES);\n\t\tif( abs(h) < (0.0015 * t) || t > tMax ) \n            if(oct < 8) oct += 2;\n            else break;\n\t\tt += 0.4 * h;\n\t}\n\n\treturn t;\n}\n*/\n\nvec3 lighting(vec3 p, vec3 normal, vec3 L, vec3 V)\n{\n    vec3 sunColor = vec3(1., .956, .839);\n    vec3 albedo = vec3(1.);\n   \tvec3 diff = max(dot(normal, L) * albedo, 0.);\n    \n    vec3 refl = normalize(reflect(L, normal));\n    float spec = max(dot(refl, -normalize(V)), 0.);\n    spec = pow(spec, 18.);\n    spec = clamp(spec, 0., 1.);\n    float sky = max(0.0, dot(vec3(0.,1.,0.), normal));\n    \n    //float amb = 0.5 * smoothstep(0.0, 2.0, p.y);\n    \n    vec3 col = diff * sunColor;\n    col += spec * sunColor;\n    col += sky * vec3(0., .6, 1.) * .1;\n    //col += amb * .2;\n    \n   \treturn col;\n}\n\nmat3 lookAt(vec3 origin, vec3 target, float roll)\n{\n    vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n    vec3 ww = normalize(target - origin);\n    vec3 uu = normalize(cross(ww, rr));\n    vec3 vv = normalize(cross(uu, ww));\n\n    return mat3(uu, vv, ww);\n}\n\nvec3 camerapath(float t)\n{\n    vec3 p=vec3(-13.0+3.5*cos(t),3.3,-1.1+2.4*cos(2.4*t+2.0));\n\treturn p;\n}\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\t\n    vec3 lightDir = normalize(vec3(0., 1., -1.));\n    \n    vec3 camStep = vec3(-1., 0., 0.) * (iTime+12.)/4.;\n    vec3 camPos = vec3(8., 2., 5.) + camStep;\n    vec3 camTarget = vec3(1., 1., 4.) + camStep;\n\n    \n    mat3 mat = lookAt(camPos, camTarget, 0.0);\n    \n    vec3 ro = camPos;\n    ro.y += fbm(ro.xz,OCTAVES)-1.8;\n\n    vec3 rd = normalize(mat * vec3(uv.xy, 1.0));\n        \n    if (length(iMouse.xy) > 40.0) {\n        rd.yx *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        rd.xz *= rot(3.14-iTime/8.-iMouse.x/iResolution.x*3.14*2.0);\n    }\n\n    \n    float tMin = .1;\n    float tMax = 20.;\n    float t = rayMarching(ro, rd, tMin, tMax);\n    \n    vec3 col = vec3(0.);\n    \n    if (t > tMax)\n    {\n        // from iq's shader, https://www.shadertoy.com/view/MdX3Rr\n        float sundot = clamp(dot(rd, lightDir), 0.0, 1.0);\n        col = vec3(0.3,0.5,0.85) - rd.y*rd.y*0.5;\n        col = mix( col, 0.85*vec3(0.7,0.75,0.85), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n        // sun\n\t\tcol += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n\t\tcol += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n\t\tcol += 0.2*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );\n        // clouds\n\t\tvec2 sc = ro.xz + rd.xz*(SC*1000.0-ro.y)/rd.y;\n\t\tcol = mix( col, vec3(1.0,0.95,1.0), 0.5*smoothstep(0.5,0.8,fbm(0.0005*sc/SC)) );\n        // horizon\n        col = mix( col, 0.68*vec3(0.4,0.65,1.0), pow( 1.0-max(rd.y,0.0), 16.0 ) );\n    }\n    else\n    {\n        vec3 p = ro + rd * t;\n        vec3 normal = getNormal(p, t);\n        vec3 viewDir = normalize(ro - p);\n        \n        // lighting terrian\n        col = lighting(p, normal, lightDir, viewDir);\n        \n        // fog\n        float fo = 1.0-exp(-pow(30. * t/SC,1.5) );\n        vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n        col = mix( col, fco, fo);\n    }\n    \n    // Gama correction\n    col = pow(clamp(col, 0., 1.), vec3(.45)); \n    \n    fragColor = vec4(vec3(col), 1.0);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssKSDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 44, 87, 136], [156, 156, 214, 263, 974], [976, 976, 1004, 1020, 1199], [1201, 1201, 1223, 1223, 1253], [1255, 1255, 1285, 1285, 1335], [1337, 1337, 1357, 1357, 1411], [1413, 1413, 1446, 1446, 1640], [1642, 1642, 1709, 1709, 1927], [1929, 2301, 2353, 2353, 2898], [2900, 2900, 2951, 2951, 3152], [3154, 3154, 3180, 3180, 3256], [3324, 3324, 3381, 3381, 5337]]}
{"id": "ssKXD3", "name": "Color Interpolation 2", "author": "Livie", "description": "part 2", "tags": ["color", "interpolation"], "likes": 1, "viewed": 42, "published": "Public", "date": "1635437819", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//  conversion fns from Iñigo Quiles @ https://www.shadertoy.com/view/MsS3Wc\nvec3 rgb2hsb( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                d / (q.x + e),\n                q.x);\n}\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvec3 calculateIDW(vec2 p) {\n    vec2 v1 = vec2(sin(5.+iTime*.1)*.5+.5, sin(iTime*1.2)*.5+.5);\n    vec2 v2 = vec2(sin(4.+iTime*.2)*.5+.5, sin(iTime*.9)*.5+.5);\n    vec2 v3 = vec2(sin(3.+iTime*.3)*.5+.5, sin(iTime*.6)*.5+.5);\n    vec2 v4 = vec2(sin(2.+iTime*.4)*.5+.5, sin(iTime*.3)*.5+.5);\n    vec2 v5 = vec2(sin(1.+iTime*.5)*.5+.5, sin(iTime*.1)*.5+.5);\n   \n    // convert to actual pixels to deal with stretching with non-square aspect ratios\n    float pWidth = 5.;\n    if (distance(p*iResolution.xy, v1*iResolution.xy) < pWidth ||\n        distance(p*iResolution.xy, v2*iResolution.xy) < pWidth ||\n        distance(p*iResolution.xy, v3*iResolution.xy) < pWidth ||\n        distance(p*iResolution.xy, v4*iResolution.xy) < pWidth ||\n        distance(p*iResolution.xy, v5*iResolution.xy) < pWidth) {\n        return vec3(0., 0., 1.);\n    }\n    \n    // Shepard's method\n    // https://en.wikipedia.org/wiki/Inverse_distance_weighting\n    float powerParam = 10. + 5.*sin(iTime);\n    float w1 = 1./pow(distance(p, v1), powerParam);\n    float w2 = 1./pow(distance(p, v2), powerParam);\n    float w3 = 1./pow(distance(p, v3), powerParam);\n    float w4 = 1./pow(distance(p, v4), powerParam);\n    float w5 = 1./pow(distance(p, v5), powerParam);\n    \n    vec3 u1 = vec3(.4,  1., .4);\n    vec3 u2 = vec3(.1,  1., 1.);\n    vec3 u3 = vec3(.5,  1., 1.);\n    vec3 u4 = vec3(.6, 1., 1.);\n    vec3 u5 = vec3(.7,  1., .4);\n    \n    /*\n    \n    vec3 u1 = vec3(.0, 1., 1.);\n    vec3 u2 = vec3(.2, 1., 1.);\n    vec3 u3 = vec3(.4, 1., 1.);\n    vec3 u4 = vec3(.6, 1., 1.);\n    vec3 u5 = vec3(.8, 1., 1.);\n    \n    vec3 u1 = vec3(217., 156., 94.)/255.;\n    vec3 u2 = vec3(231., 201., 125.)/255.;\n    vec3 u3 = vec3(11., 207, 139.)/255.;\n    vec3 u4 = vec3(34, 214., 153.)/255.;\n    vec3 u5 = vec3(122., 132., 94.)/255.;\n    */\n    vec3 u = (w1*u1 + w2*u2 + w3*u3 + w4*u4 + w5*u5)/(w1+w2+w3+w4+w5);\n    return u;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = calculateIDW(uv);\n    fragColor = vec4(hsb2rgb(col), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssKXD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 78, 104, 104, 534], [535, 535, 561, 561, 793], [795, 795, 822, 822, 2681], [2683, 2683, 2740, 2740, 2855]]}
{"id": "ssKXRc", "name": "almost hyperblue (too cyan)", "author": "bigbadbob234", "description": "very nearly gives the qualia/feeling/illusion of a bluer-than-blue color, but looks a little bit too cyan.\nturn up the brightness on your monitor to increase the feeling a little bit", "tags": ["colors", "colorshift", "shepardtone", "inventingacolor"], "likes": 1, "viewed": 26, "published": "Public", "date": "1635066326", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec2 uv = fragCoord;\n    \n    float t = iTime * 1.;\n    float k = 6.;\n    float doodle = iTime*9.;\n    float a = .5 + .5*cos(doodle + uv.x - (uv.x*floor(uv.x/k)) + uv.y - (uv.y*floor(uv.y/k)));\n    float b1 = (t-floor(t));\n    float b = a; // + b1;\n    //(uv.x*floor(uv.x / 7.0)) \n    float h = b - (b * floor(b/t));\n    float h2 = exp(h)/2.718;\n    \n       \n    //vec3 midcol = vec3(1.,1.,1.);\n    //vec3 cola = mix(vec3(1.,.0,1.), vec3(1.,0.,0.), h2);\n    //vec3 colb = mix(vec3(0.,1.,1.), vec3(0.,.5,1.), h2);\n    \n    //vec3 cola = mix(vec3(2.,.0,.0), vec3(0.,1.,2.), h);\n    //vec3 colb = mix(vec3(1.,1.,1.), vec3(0.,.0,2.), h2);\n    //vec3 col = mix(cola, colb, h);\n    \n    //vec3 cola = mix(vec3(1,1,0), vec3(1,0,1), h);\n    //vec3 colb = mix(vec3(1,0,1), vec3(0,1,12), h2*h);\n    //vec3 col = mix(cola, colb, h2);\n\n    vec3 cola = mix(vec3(1,1,1), vec3(0,1,0), h2*h2);\n    vec3 colb = mix(vec3(1,0,0), vec3(0,1,3), h2);\n    vec3 col = mix(cola, colb, (h2+h)*.5);\n    \n    \n    //vec3 col = vec3(1.-h2*2., (.5-h2)*(.5-h), h2*(abs(.25-h)+1.));\n    // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssKXRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 241, 1417]]}
{"id": "ssKXWt", "name": "Raymarching_Trainning", "author": "AYAYA2", "description": "This is a learnning of raymarching support by:\nhttps://www.youtube.com/watch?v=Vmb7VGBVZJA\nhttps://www.shadertoy.com/view/Xds3zN", "tags": ["raymarch"], "likes": 0, "viewed": 96, "published": "Public API", "date": "1635530597", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nfloat dot2( in vec2 v ) { return dot(v,v); }// 自点乘\nfloat dot2( in vec3 v ) { return dot(v,v); }// 三维\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdPlane(vec3 p){\n    return p.y;\n}\n\nfloat dSphere(vec3 p,vec3 o,float radius){\n    return length(p-o.xyz)-radius;\n}\n\nfloat dBox(vec3 p,vec3 s){\n    return length(max(abs(p)-s,0.));\n}\n\nfloat sdCapsule(vec3 p,vec3 a,vec3 b,float radius){\n    vec3 ap=p-a;\n    vec3 ab=b-a;\n    \n    float t=dot(ap,ab)/dot(ab,ab);\n    t=clamp(t,0.,1.);\n    \n    vec3 c=a+t*ab;\n    return length(p-c)-radius;\n}\n\n// 方框盒子 b-方框三维、e-方框粗细\nfloat sdBoundingBox(vec3 p,vec3 b,float e){\n    p=abs(p)-b;\n    vec3 q = abs(p+e)-e;\n    \n    return min(min(\n        length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n        length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n        length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// 椭球体\nfloat sdEllipsoid(vec3 p,vec3 radius){\n    float k0=length(p/radius);\n    float k1=length(p/(radius*radius));\n    return k0*(k0-1.)/k1;\n}\n\n\n// 圆柱体，只能渲染竖着的，弃用\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// 圆柱体\nfloat sdCylinder(vec3 p,vec3 a,vec3 b,float radius){\n    vec3 ap=p-a;\n    vec3 ab=b-a;\n    \n    float t=dot(ap,ab)/dot(ab,ab);\n    \n    vec3 c=a+t*ab;\n    \n    float x= length(p-c)-radius;\n    float y=(abs(t-.5)-.5)*length(ab);\n    float e=length(max(vec2(x,y),0.));\n    float i=min(max(x,y),0.);// 消除步进过多光线进入柱体内的错误\n    \n    return e+i;\n}\n\n// 甜甜圈\nfloat sdTours(vec3 p,vec2 radius){\n    float x=length(p.xz)-radius.x;\n    return length(vec2(x,p.y))-radius.y;\n}\n\n// 缺口甜甜圈 sc-缺口弧度,缺口半径 ra-外圈半径 rb-体半径（粗细）\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\n// 六边形？ h-半径,厚度\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// 八边形 r-半径 h-厚度\nfloat sdOctogonPrism( in vec3 p, in float r, float h )\n{\n  const vec3 k = vec3(-0.9238795325,   // sqrt(2+sqrt(2))/2 \n                       0.3826834323,   // sqrt(2-sqrt(2))/2\n                       0.4142135623 ); // sqrt(2)-1 \n  // reflections\n  p = abs(p);\n  p.xy -= 2.0*min(dot(vec2( k.x,k.y),p.xy),0.0)*vec2( k.x,k.y);\n  p.xy -= 2.0*min(dot(vec2(-k.x,k.y),p.xy),0.0)*vec2(-k.x,k.y);\n  // polygon side\n  p.xy -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  vec2 d = vec2( length(p.xy)*sign(p.y), p.z-h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// 三角椭锥体 r1-下盘半径 r2-上盘半径 h-高度,弃用\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\n// 椭锥体 a,b-分别为上下球心坐标（可以控制偏斜和高度h） r1-下盘半径 r2-上盘半径\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\n// 三角柱体 h-大小，高度\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// 三角锥 c-半径？ h-高度\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n    vec2 q = h*vec2(c.x,-c.y)/c.y;\n    vec2 w = vec2( length(p.xz), p.y );\n    \n\tvec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n\treturn sqrt(d)*sign(s);\n}\n\n// 圆柱锥体 无控制点版本，弃用\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n// 圆柱锥体 a,b-控制点\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\n// 球底圆锥体 ra-底部曲面半径\n// c is the sin/cos of the desired cone angle\nfloat sdSolidAngle(vec3 pos, vec2 c, float ra)\n{\n    vec2 p = vec2( length(pos.xz), pos.y );\n    float l = length(p) - ra;\n\tfloat m = length(p - c*clamp(dot(p,c),0.0,ra) );\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\n// 八面体 s-边长\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n\n    // exact distance\n    #if 0\n    vec3 o = min(3.0*p - m, 0.0);\n    o = max(6.0*p - m*2.0 - o*3.0 + (o.x+o.y+o.z), 0.0);\n    return length(p - s*o/(o.x+o.y+o.z));\n    #endif\n    \n    // exact distance\n    #if 1\n \tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n    #endif\n    \n    // bound, not exact\n    #if 0\n\treturn m*0.57735027;\n    #endif\n}\n\n// 四棱锥金字塔\nfloat sdPyramid( in vec3 p, in float h )\n{\n    float m2 = h*h + 0.25;\n    \n    // symmetry\n    p.xz = abs(p.xz);\n    p.xz = (p.z>p.x) ? p.zx : p.xz;\n    p.xz -= 0.5;\n\t\n    // project into face plane (2D)\n    vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n\tfloat b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n    // recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));;\n}\n\n// \n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n    p = abs(p);\n    vec2 b = vec2(la,lb);\n    float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n\tvec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\n// 距离长遍历\nfloat GetDist(vec3 p)\n{\n    vec4 s=vec4(0,1,6,1);// A sphere's pos.xyzr\n    \n    float planeDist=sdPlane(p);// ground\n    \n    // 遍历形式所有物体 物体摆放 从远至近-行\n    float bd=dBox(p-vec3(-6,.75,6),vec3(.6));\n    float td=sdTours(p-vec3(-3,.75,6),vec2(.75,0.3));\n    float cd=sdCapsule(p,vec3(0,.75,6),vec3(1,2,6),.4);\n    float sd=dSphere(p,vec3(3,.75,6),.75);\n    float bbd=sdBoundingBox(p-vec3(6,.75,6),vec3(0.6,0.6,0.6),0.05);  \n    \n    float cyld=sdCylinder(p-vec3(-1,.75,0),vec3(0,.3,4),vec3(2,.3,5),.2);\n    float ed=sdEllipsoid(p-vec3(-5.5,.75,4),vec3(0.2,0.15,0.25));\n    float ctd=sdCappedTorus(p-vec3(-3,.75,4),vec2(0.866025,-0.5),0.5, 0.1);\n    float hpd=sdHexPrism(p-vec3(3,0.75,4.4),vec2(0.6,0.1));\n    float opd=sdOctogonPrism(p-vec3(6,0.75,4.3),0.6,0.1);\n    \n    //float rcd0=sdRoundCone(p-vec3(-6,0.75,3.5),0.2,0.1,0.5);\n    float rcd=sdRoundCone(p-vec3(-6,0.75,3.5), vec3(0.1,0.0,0.0), vec3(-0.3,0.4,0.1), 0.15, 0.05);\n    float tpd=sdTriPrism(p-vec3(-3.3,0.75,3.4),vec2(0.5,0.05));\n    float coned=sdCone(p-vec3(5.3,1.1,3.4),vec2(0.3,0.8),0.85);\n    float ccd=sdCappedCone(p-vec3(0.0,0.75,3.5),vec3(0.1,0.0,0.0),vec3(-0.3,0.40,0.1),0.3,0.15);\n    float sad=sdSolidAngle(p-vec3(3,0.05,3.5), vec2(1.5,2)/2.5, 1.);\n    \n    float odd=sdOctahedron(p-vec3(-3.0,0.5,2),0.45);// 四棱锥因为正交投影的问题很难看\n    float pd=sdPyramid(p-vec3(2,0.5,2.0), 0.9);\n    float rbd= sdRhombus(p-vec3(-0.2,0.34,2.0),0.15,0.25,0.04,0.08);\n    \n    float d=min(cd,planeDist);\n    d=min(d,sd);\n    d=min(d,td);\n    d=min(d,bd);\n    d=min(d,cyld);\n    d=min(d,bbd);\n    d=min(d,ed);\n    d=min(d,ctd);\n    d=min(d,hpd);\n    d=min(d,opd);\n    d=min(d,rcd);\n    d=min(d,tpd);\n    d=min(d,coned);\n    d=min(d,ccd);\n    d=min(d,sad);\n    d=min(d,odd);\n    d=min(d,pd);\n    d=min(d,rbd);\n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro,vec3 rd)\n{\n    float dO=0.;\n    \n    for(int i=0;i<MAX_STEPS;i++){\n        vec3 p=ro+rd*dO;\n        float dS=GetDist(p);\n        dO+=dS;\n        if(dO>MAX_DIST||dS<SURF_DIST)break;\n    }\n    return dO;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    float d=GetDist(p);\n    vec2 e=vec2(.01,0);\n    \n    vec3 n=d-vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    return normalize(n);\n}\n\nfloat GetLight(vec3 p)\n{\n    vec3 lightPos=vec3(0,5,6);// a light's pos.xyz\n    lightPos.xz+=vec2(sin(iTime),cos(iTime))*2.;\n    vec3 l =normalize(lightPos-p);\n    vec3 n=GetNormal(p);\n    \n    float dif=clamp(dot(n,l),0.,1.);\n    float d=RayMarch(p+n*SURF_DIST*2.,l);\n    if(d<length(lightPos-p)) dif*=.1;\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    // Time varying pixel color\n    vec3 col = vec3(0);\n    \n    vec3 ro=vec3(0,3,0);// cameraPos\n    vec3 rd=normalize(vec3(uv.x,uv.y-.3,.35));// cameraDir\n    \n    float d=RayMarch(ro,rd);\n    \n    vec3 p=ro+rd*d;\n    float dif=GetLight(p);\n    col=vec3(dif);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssKXWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 92, 92, 111], [111, 124, 149, 149, 168], [168, 178, 214, 214, 242], [244, 244, 266, 266, 284], [286, 286, 328, 328, 365], [367, 367, 393, 393, 432], [434, 434, 485, 485, 638], [640, 688, 731, 731, 1026], [1028, 1041, 1079, 1079, 1178], [1181, 1227, 1263, 1263, 1366], [1368, 1381, 1433, 1433, 1751], [1753, 1766, 1800, 1800, 1878], [1880, 1969, 2039, 2039, 2179], [2181, 2213, 2249, 2249, 2560], [2562, 2593, 2649, 2649, 3151], [3153, 3220, 3284, 3284, 3562], [3564, 3675, 3738, 3802, 4389], [4391, 4425, 4461, 4461, 4811], [4813, 4847, 4894, 4894, 5239], [5241, 5285, 5356, 5356, 5694], [5696, 5726, 5790, 5790, 6350], [6352, 6439, 6487, 6487, 6656], [6658, 6680, 6717, 6717, 7311], [7313, 7335, 7377, 7377, 7977], [7979, 8023, 8087, 8087, 8345], [8347, 8366, 8389, 8389, 10204], [10206, 10206, 10239, 10239, 10432], [10434, 10434, 10458, 10458, 10636], [10638, 10638, 10662, 10662, 10967], [10969, 10969, 11026, 11076, 11460]]}
{"id": "ssKXzG", "name": "Waves Morph (05)", "author": "spenceryonce", "description": "And again here I go making some more fun things here. I just love creating things like this so much.", "tags": ["waves", "math", "sin", "color", "cos", "trippy", "weird", "morphing"], "likes": 2, "viewed": 69, "published": "Public", "date": "1634863563", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int AMOUNT = 10;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = 20.0 * (fragCoord.xy - iResolution.xy / 2.0) / min(iResolution.y, iResolution.x);\n    \n    float len;\n    \n    for(int i = 0; i < AMOUNT; i++){\n        len = length(vec2(coord.x, coord.y))*1.0;\n        \n        coord.x = coord.x - cos(coord.y + sin(len)) + cos(iTime / 12.0);\n        coord.y = coord.y + sin(coord.x + cos(len)) + sin(iTime / 9.0);\n    }\n    \n    fragColor = vec4(cos(len * 1.1), cos(len * 1.05), cos(len * 1.01), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssKXzG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 81, 81, 536]]}
{"id": "sstSD2", "name": "Fork pentagonal tiling variation", "author": "alvarobyrne", "description": "Same as original: Click and drag to set vertex position. \n\nInspired by [url]https://twitter.com/cs_kaplan[/url]. See [url]https://en.wikipedia.org/wiki/Cairo_pentagonal_tiling[/url] for details.", "tags": ["tiling", "pentagonal", "variations", "cairo"], "likes": 8, "viewed": 154, "published": "Public API", "date": "1634012917", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//////////////////////////////////////////////////////////////////////\n//original at https://www.shadertoy.com/view/fs3SWj\n// \"pentagonal tiling variations\" by mattz\n// License https://creativecommons.org/licenses/by/4.0/\n//\n// Click and drag to set vertex position.\n//\n// Renders \"type 4\" Cairo pentagonal tilings. See\n// https://en.wikipedia.org/wiki/Cairo_pentagonal_tiling\n// for details.\n//\n// Inspired by https://twitter.com/cs_kaplan\n//\n// Related shaders:\n//\n//   - \"Cairo tiling\" by nimitz\n//      https://www.shadertoy.com/view/4ssSWf\n//\n//   - \"More Cairo Tiles\" by mla\n//     https://www.shadertoy.com/view/MlSfRd\n//\n//   - \"Extruded Pentagon Tiling\" by Shane\n//     https://www.shadertoy.com/view/3t2cDK\n//\n//   - \"15th Pentagonal tiling\" by tomkh\n//      https://www.shadertoy.com/view/4lBXRV\n//\n//   - \"pentagonal tiling\" by FabriceNeyret2\n//     https://www.shadertoy.com/view/ltBBzK\n//     (golfed at https://www.shadertoy.com/view/XljfRV)\n//\n// Noise function from iq's \"Noise - gradient - 2D\"\n// https://www.shadertoy.com/view/XdXGW8\n//\n//////////////////////////////////////////////////////////////////////\n\n// vector rotated by 90 degrees CCW\nvec2 perp(vec2 u) {\n    return vec2(-u.y, u.x);\n}\n\n// rotate vector by rotation vector (cos(t), sin(t))\nvec2 rotate(vec2 rvec, vec2 p) {\n    return p.x * rvec + p.y * vec2(-rvec.y, rvec.x);\n}\n\n// rotate vector by rotation vector (cos(t), sin(t))\nvec2 unrotate(vec2 rvec, vec2 p) {\n    return p.x * vec2(rvec.x, -rvec.y) + p.y * rvec;\n}\n\n// distance from point to line segment\nfloat dseg(vec2 p, vec2 a, vec2 b) {\n\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    \n    float u = dot(pa, ba) / dot(ba, ba);\n    \n    u = clamp(u, 0.0, 1.0);\n    \n    return length(pa - u * ba);\n    \n}\n\n// half-plane test\nbool in_half_plane(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    return dot(pa, perp(ba)) > 0.0;\n}\n\n// point in triangle\nbool in_triangle(vec2 p, vec2 a, vec2 b, vec2 c) {\n    return in_half_plane(p, a, b) && in_half_plane(p, b, c) && in_half_plane(p, c, a);\n}\n\n// from https://www.shadertoy.com/view/XdXGW8 - used for noise below\nvec2 grad( ivec2 z ) {\n\n    // 2D to 1D  (feel free to replace by some other)\n    int n = z.x+z.y*11111;\n\n    // Hugo Elias hash (feel free to replace by another one)\n    n = (n<<13)^n;\n    n = (n*(n*n*15731+789221)+1376312589)>>16;\n\n    // Perlin style vectors\n    n &= 7;\n    \n    vec2 gr = vec2(n&1,n>>1)*2.0-1.0;\n    \n    return ( n>=6 ) ? vec2(0.0,gr.x) : \n           ( n>=4 ) ? vec2(gr.x,0.0) :\n           gr;\n           \n}\n\n// from https://www.shadertoy.com/view/XdXGW8\nfloat noise( in vec2 p ) {\n\n    ivec2 i = ivec2(floor( p ));\n    vec2 f = fract( p );\n\t\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix( mix( dot( grad( i+ivec2(0,0) ), f-vec2(0.0,0.0) ), \n                     dot( grad( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( grad( i+ivec2(0,1) ), f-vec2(0.0,1.0) ), \n                     dot( grad( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n\n}\n\n\n// colors for each cell\nconst vec3 CELL_COLORS[4] = vec3[4](\n    vec3(0.9, 0.0, 0.05),\n    vec3(0.95, 0.85, 0.0),\n    vec3(0.1, 0.8, 0.05),\n    vec3(0.1, 0.5, 0.8)\n);\n\n// rotation vectors for theta = 0, pi/2, pi, 3*pi/2\nconst vec2 ROT_VECTORS[4] = vec2[4](\n    vec2(1, 0),\n    vec2(0, 1),\n    vec2(-1, 0),\n    vec2(0, -1)\n);\n\n// un-rotated cell geometry \n// \n//\n//           C\n//         _*_____\n//       _-       -----____\n//  D  _*------------------* B ---\n//   _- |                 ||\n//  *   |                 ||\n//  |   |                | |    \n//  |   |                | |    t\n//   |  |               |  |   \n//   |  |            A  |  |\n//    | |            __*   |   ---\n//    | |        __--   \\  |    \n//     ||    __--        \\ |    y\n//     ||__--             \\|    \n//    O *------------------* X ---\n//\n//      |       x      | s |\n// \n// notes:\n//\n//   square is 0.5 x 0.5\n//\n//   A = O + (x, y)\n//   B = O + (0.5, 0.5)\n//   C = B + (-t, s) = B + (y - 0.5, 0.5 - x)\n//   D = O + (-y, x)\n//   X = O + (0.5, 0)\n//\n//   segments OD and OA are congruent and perpendicular\n//   segments AB and BC are congruent and perpendicular\n//  \n//   there are four rotated copies of polygon OABCD around point O \n\n// polygon points\nvec2 O, A, B, C, D;\n\n// for bump-mapped shading\nvec2 heightmap(vec2 p) {\n\n    // get polygon distance\n    float dpoly = dseg(p, O, A);\n    dpoly = min(dpoly, dseg(p, A, B));\n    dpoly = min(dpoly, dseg(p, B, C));\n    dpoly = min(dpoly, dseg(p, C, D));\n    dpoly = min(dpoly, dseg(p, D, O));\n    \n    // offset from edge\n    float k = 0.08;\n    \n    // base height\n    float z = k + 0.01 * noise(5.*p);\n    \n    if (dpoly < k) {\n        // semicircular shoulder\n        float w = (dpoly/k - 1.0);\n        z *= sqrt(1.0 - w*w);\n    } else {\n        // depression inwards from edge\n        z *= (1.0 - 0.03*smoothstep(k, 2.0*k, dpoly));\n    }\n    \n    // return height and polygon distance\n    return vec2(z, dpoly);\n    \n}\n\n// do the things!\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // global rotation by 45 degrees\n    vec2 global_rot = vec2(0.5*sqrt(2.0));\n    \n    // image should be six blocks high\n    float scl = 10.0 * global_rot.x / iResolution.y;\n    \n    // uv in [0,1] x [0, 1] holds vertex position\n    vec2 uv = vec2(0.7886751345948132, 0.21132486540518713);\n    \n    // light coords relative to center\n    vec2 lcoord = vec2(0);\n\n    if (iMouse.z > 0.) {\n    \n        // set vertex coords by dragging - light is fixed\n        \n        uv = clamp(iMouse.xy / iResolution.xy, 0.0, 1.0);\n        lcoord = vec2(-0.0, 0.5);\n        \n    } else {\n    \n        // set vertex coords varying over screen\n        // and move light\n        uv = (fragCoord.xy - 0.5 * iResolution.xy) / (max(iResolution.x, iResolution.y));\n        \n        const float repeat = 30.0; // seconds\n        const float wraps_per_repeat = 5.0;\n        \n        const float x_lobes = 3.0;\n        const float y_lobes = 2.0;\n        \n        const float two_pi = 6.283185307179586;\n        \n        float t = iTime * two_pi / repeat;\n        \n        float t_wrap = t * wraps_per_repeat;\n       \n        float c = cos(t_wrap);\n        float s = sin(t_wrap);\n        \n        uv = rotate(vec2(s, -c), uv);\n        \n        uv = clamp(uv + 0.5, 0.0, 1.0);\n        \n        lcoord = vec2(-sin(t * x_lobes), cos(t * y_lobes));\n \n    }\n    lcoord = vec2(-10.0);\n    \n    // z coordinate of camera and light (tiles live at z=0)\n    const float cz = 10.5;\n    \n    // set light pos in 3D\n    vec3 lpos = vec3(lcoord * 0.5 * iResolution.xy * scl, cz);\n    //lpos=vec3(1.,0.0,-10.00);\n    // camera pos in 3D\n    const vec3 cpos = vec3(0, 0, cz);\n\n    // map frag cords to scene coords (before global rotation)\n    vec2 porig = (fragCoord + vec2(0.13, 0.17) - 0.5*iResolution.xy) * scl;\n    \n    // apply global rotation\n    vec2 p = rotate(porig, global_rot);\n\n    // find starting origin of tile cluster -- note this could change below\n    O = floor(p + 0.5);\n            \n    // figure out which quadrant we are in relative to the origin\n    ivec2 qstep = ivec2(step(p, O));\n    int quadrant = (qstep.x ^ qstep.y) + 2*qstep.y;\n    \n    // each quadrant rotates by 90 degrees\n    vec2 rvec = ROT_VECTORS[quadrant];\n    \n    // form some critical points of the polygon in this cell\n    vec2 xy = 0.5*uv;\n    vec2 st = 0.5 - xy;\n    \n    A = O + rotate(rvec, xy);\n    B = O + rotate(rvec, vec2(0.5));\n    vec2 X = O + rotate(rvec, vec2(0.5, 0));\n\n    // get distance from point to semgent AX\n    float dline = dseg(p, A, X);\n\n    // figure out whether we are in the main upper-left part of the\n    // cell or one of the two triangles\n    int cell = quadrant;\n    \n    if (in_triangle(p, X, B, A)) {\n        // in triangle XBA -- rotate polygon CCW by 90 degrees and translate it over by 1 cell\n        cell = (quadrant + 1) & 3;\n        O += rvec;\n        rvec = perp(rvec);\n    } else if (in_triangle(p, O, X, A)) {\n        // in trangle OXA -- rotate polygon CW by 90 degrees\n        cell = (quadrant + 3) & 3;\n        rvec = -perp(rvec);\n    } \n\n    // now we know which polygonal tile p is in, so get the distance to the\n    // polygon\n    \n    A = O + rotate(rvec, xy);\n    B = O + rotate(rvec, vec2(0.5));\n\n    C = B + rotate(rvec, perp(st));\n    D = O + rotate(rvec, perp(xy));\n    \n    vec2 hm = heightmap(p);\n    \n    const float h = 1e-3;\n    const vec2 eps = vec2(h, 0);\n    \n    vec2 hgrad = (0.5 / h) * vec2(\n        heightmap(p + eps.xy).x - heightmap(p - eps.xy).x,\n        heightmap(p + eps.yx).x - heightmap(p - eps.yx).x\n    );\n    hgrad = vec2(0.5/h);\n    \n    hgrad = unrotate(global_rot, hgrad);\n    \n    float z = hm.x;\n        \n    dline = min(dline, hm.y);\n    \n    // bump-mapped surface normal\n    vec3 N = normalize(cross(vec3(1, 0, hgrad.x), vec3(0, 1, hgrad.y)));\n\n    // get color of this cell\n    vec3 color;\n    color = CELL_COLORS[cell];\n    color= vec3(1.);\n    color *= color; // gamma un-correct\n    \n    // desaturate a bit\n    color = mix(color, vec3(0.5), 0.08);\n    \n    //color = vec3(0.5);\n    \n    // get 3D point position\n    vec3 pos = vec3(porig, z);\n\n    // fake phong lighting\n    vec3 L = normalize(lpos - pos);\n    vec3 V = -normalize(cpos - pos);\n\n    vec3 R;\n    R=reflect(L, N);\n    R= vec3(1.0);\n    \n    color *= 0.1 + 0.9 * clamp(dot(N, L), 0.0, 1.0);\n    color += 0.3*pow(clamp(dot(V, R), 0.0, 1.0), 10.0)*vec3(1);\n\n    // darken by lines\n    color *= smoothstep(0., 10./iResolution.y, dline);\n    \n    // gamma \"correct\"\n    color = sqrt(color);\n\n    // done!\n    fragColor = vec4(color, 1);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sstSD2.jpg", "access": "shaders20k", "license": "cc-by-4.0", "functions": [[1128, 1164, 1183, 1183, 1213], [1215, 1268, 1300, 1300, 1355], [1357, 1410, 1444, 1444, 1499], [1501, 1540, 1576, 1576, 1742], [1744, 1763, 1807, 1807, 1887], [1889, 1910, 1960, 1960, 2049], [2051, 2120, 2142, 2197, 2549], [2551, 2597, 2623, 2623, 3018], [4274, 4301, 4325, 4354, 4973], [4975, 4993, 5050, 5088, 9594]]}
{"id": "sstSW2", "name": "worker -2d", "author": "jorge2017a2", "description": "worker -2d", "tags": ["worker2d"], "likes": 7, "viewed": 102, "published": "Public API", "date": "1634005076", "time_retrieved": "2021-10-01T00:00:00", "image_code": "///worker 2d-JFP\n///por jorge2017a2...2021-oct-11\n///referencia\n//https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(antialiasing(0.05),b,d)\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n///---------------------------\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n    \nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  //colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.05,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.05,0.0));\n  return colOut;\n}\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\nreturn colOut;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\nfloat sdUnevenCapsule( vec2 p, float r1, float r2, float h )\n{\n    p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\n\n\nvec3 ojo(vec2 p, vec3 col)\n{\n    float posOjox=1.0;\n    float d1izq= sdUnevenCapsule( p-vec2(-posOjox,1.2), 0.7, 0.7, 0.7 );\n    float db1=sdBox(p-vec2(-1.0,0.2),vec2(0.9,1.0) );\n    float  d1ojoizqA= sdCircle( p-vec2(-0.7,1.2), 0.7 );\n    float  d1ojoizqB= sdCircle( p-vec2(-0.7,1.2), 0.3 );\n    \n    d1izq=differenceSDF(d1izq,db1);\n    d1ojoizqA=intersectSDF(d1ojoizqA,d1izq);\n    d1ojoizqB=intersectSDF(d1ojoizqB,d1izq);\n    \n    col=DrawFigBorde(vec3(1.0), col,d1izq );\n    col=DrawFig(vec3(0.4), col,d1ojoizqA );\n    col=DrawFig(vec3(1.0,0.9,0.2), col,d1ojoizqB );\n    return col;\n}\n\nfloat sdRoundedX( in vec2 p, in float w, in float r )\n{    p = abs(p);\n    return length(p-min(p.x+p.y,w)*0.5) - r;\n}\n\n\nvec3 sombrero(vec2 p, vec3 col)\n{   float dso1= sdUnevenCapsule( p, 3.25, 3.25, 2.0 );\n    float db1=sdBox(p-vec2(0.0,-1.0),vec2(3.4,3.0) );\n    float difso1=differenceSDF(dso1,db1);\n    float db0= sdBox(p-vec2(0.0,1.5),vec2(5.0,0.15) )-0.5;\n    col=DrawFigBorde(vec3(1.0,1.5,0.2), col,difso1 );\n    col=DrawFigBorde(vec3(0.3), col,db0 );\n    \n    float sr1=sdRoundedX(p-vec2(0.0,3.5), 1.5, 0.35 );\n    col=DrawFigBorde(vec3(1.0,0.0,0.3), col,sr1 );\n    return col;\n}\n\nvec3 boca(vec2 p, vec3 col)\n{  float anc=1.5;\n   float d1= sdUnevenCapsule( p, anc, anc, 1.0 );\n   float db0= sdBox(p-vec2(0.0,1.5),vec2(2.5,2.0) );\n   float d2=sdCircle(p-vec2(0.5,-1.5), 0.8 );\n    d1=differenceSDF(d1,db0);\n    d2=intersectSDF(d2,d1);\n    \n   col=DrawFigBorde(vec3(0.0), col,d1 );\n   col=DrawFigBorde(vec3(1.0,0.0,0.0), col,d2 );\n   return col;\n}\n\nvec3 rostro(vec2 p, vec3 col)\n{ float d1= sdUnevenCapsule( p, 3.0, 3.0, 2.0 );\n    col=DrawFigBorde(vec3(1.0,0.5,0.2), col,d1 );\n    float px=0.25*sin(iTime);\n    float py=0.25*cos(iTime);\n    \n    col= ojo(p-vec2(0.0+px,-1.5+py), col);\n    col= ojo(p-vec2(2.0+px,-1.5+py), col);\n    col= sombrero(p-vec2(0.0,0.2), col);\n    col=boca( p-vec2(0.0,-0.5), col);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    vec3  col=vec3(0.45,0.7,1.0)-uv.y*0.25;\n    uv*=8.0;\n    \n    vec2 uv1=uv;\n    float tt=iTime*5.0;\n    uv1.y=opRep1D(uv1.y-tt, 12.0 );\n    col= rostro(uv1,col);\n    \n    vec2 uv2=uv;\n    uv2.y=mod(uv2.y+tt,10.0);\n    uv2=abs(uv2*1.5-vec2(0.0,-2.0))-10.0;\n    col= rostro(uv2,col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sstSW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 303, 337, 337, 432], [434, 465, 501, 501, 546], [551, 595, 642, 642, 669], [670, 670, 713, 713, 740], [741, 741, 789, 789, 817], [823, 823, 885, 885, 1081], [1083, 1083, 1164, 1164, 1294], [1296, 1296, 1353, 1353, 1419], [1421, 1421, 1458, 1458, 1537], [1539, 1539, 1574, 1574, 1597], [1599, 1599, 1661, 1661, 1900], [1903, 1903, 1931, 1931, 2490], [2492, 2492, 2547, 2547, 2609], [2612, 2612, 2645, 2645, 3079], [3081, 3081, 3110, 3110, 3445], [3447, 3447, 3478, 3478, 3823], [3825, 3825, 3882, 3882, 4294]]}
{"id": "sstSW7", "name": "The little grid that could", "author": "krh", "description": "WIP", "tags": ["grid"], "likes": 3, "viewed": 159, "published": "Public API", "date": "1633424377", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord.y = iResolution.y - fragCoord.y;\n    vec2 size = vec2(64.0, 80.0);    \n    vec2 cell = floor(fragCoord / size);\n    vec2 s = fragCoord /size - cell;\n    fragCoord = cell * size;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    col.rgb += s.xxx * s.yyy;\n    \n    s = floor(s * size);\n    if (s.x == 0.0  || s.y == 0.0)\n        col.rgb = vec3(0.0);\n    else if (s.x == 10.0 || s.y == 10.0)\n        col.rgb = vec3(0.0);\n    else if (s.x < 10.0 || s.y < 10.0)\n        col.rgb = vec3(0.5);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sstSW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 725]]}
{"id": "sstSWj", "name": "Physically based point light", "author": "hyperknot", "description": "Physically based lightness calculation for a point light above a 100% matte (Lambertian) ground plane.\ndetails: https://hyperknot.com/blog/area_lights_in_shaders/", "tags": ["pointlight", "physics"], "likes": 1, "viewed": 175, "published": "Public API", "date": "1633992221", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Physically based lightness calculation \n// for a point light above a 100% matte (Lambertian) ground plane,\n// moving up and down.\n// details: https://hyperknot.com/blog/area_lights_in_shaders/\n\nfloat point_light(vec2 uv, float h, float i) {\n  // h - light's height over the ground\n  // i - light's intensity\n  return i * h * pow(dot(uv,uv) + h*h, -1.5);\n}\n\nfloat lin_to_srgb ( float val ) {\n  if( val < 0.0031308 )\n    return val * 12.92;\n  else\n    return 1.055 * pow(val,1.0/2.4) - 0.055;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = ( fragCoord - .5*iResolution.xy ) / iResolution.y;\n\n    float h = pow(sin(iTime/3.), 2.) * 0.1 + 0.001;\n    float v = point_light(uv, h, 0.005);\n    v = lin_to_srgb(v);\n\t\n \tfragColor=vec4(v);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sstSWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 197, 243, 310, 358], [360, 360, 393, 393, 495], [497, 497, 553, 553, 761]]}
{"id": "sstSWS", "name": "black&white heart", "author": "Kornelius", "description": "2d heart.", "tags": ["gradient", "heart", "blackwhite"], "likes": 1, "viewed": 98, "published": "Public API", "date": "1633959509", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float dot2( in vec2 v ) { return dot(v,v); }\n\n float heart( in vec2 p, in float r ) \n{\n    vec2 s = vec2(1.0, 0.0);\n    \n    p = p-s.xy;\n    p.x = abs(p.x);\n\n    if( p.y+p.x>1.0 )\n        return sqrt(dot2(p-vec2(.25,.75))) - sqrt(2.0)/4.0;\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n                    dot2(p-.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (3.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    \n\tfloat d = heart(p,.5);\n    \n\t// coloring\n    vec3 col = vec3(.1) - sign(d)*sin(iTime+p.y+vec3(0,0,0));\n     \n    col *= 1.0 - exp(-9.0*abs(d));\n\t\n\n   \n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sstSWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 44], [47, 47, 86, 86, 353], [357, 357, 414, 414, 663]]}
{"id": "ssVSDR", "name": "jneen - 3d sprites", "author": "jneen", "description": "rendering 3d objects using sprites", "tags": ["3d", "sprites"], "likes": 2, "viewed": 61, "published": "Public", "date": "1634498411", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define I (1.)\n#define O (0.)\n\n#define T (.2*(iTime))\n\n#define PI (acos(-1.))\n#define TAU (2.*PI)\n\nfloat[16] T1 = float[16](\nI,I,O,O,\nI,I,I,O,\nO,I,I,I,\nO,O,I,I\n);\n                         \nfloat[16] T2 = float[16](\nO,O,I,I,\nO,I,I,I,\nI,I,I,O,\nI,I,O,O\n);\n\nfloat[16] T3 = float[16](\nI,I,I,I,\nI,O,O,I,\nO,O,O,O,\nI,I,I,I\n);\n\nfloat box(vec3 p, vec3 a) {\n  vec3 q=abs(p)-abs(a);\n  return min(length(max(q,0.)),max(q.x,max(q.y,q.z)));\n}\n\nvec3 erot(vec3 p,vec3 ax,vec3 ro) {\n  return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\n#define MISS(D) (D>1000.)\n\n\nvec3 erot(vec3 p,vec3 ax,float o) {\n  return mix(dot(ax,p)*ax,p,cos(o))+sin(o)*cross(ax,p);\n}\n\n#define bump(X) (sqrt(abs(sin(X))))\n\n\nmat2 rot(float t) { float s=sin(t),c=cos(t);return mat2(c,s,-s,c); }\n#define nsin(X) (.5+.5*sin(X))          \nfloat warp(vec2 p) {\n  //p *= rot(bump(T));\n  //p *= rot(pow(2.,length(p)));\n  //p.x-=3.*sin(T);\n  p*=(2.+10.*nsin(T));\n  return tan(p.x)*tan(p.x)-tan(p.y)*tan(p.y);\n}\n\nfloat sph(vec3 p, float r) { return length(p)-r; }\n\nfloat boxle(vec3 p, float r) {\n  return max(box(p,vec3(r)), -sph(p,r*(4./3.)));\n}\n\nfloat S(vec3 p) {\n  p.x+=sin(T);\n  p = erot(p, normalize(vec3(1)), T*4.);\n  float D= boxle(p,1.5);\n  p = erot(p, normalize(vec3(11,-1,0)),-T*16.);\n  D=min(D,boxle(p,.5));\n  return D;\n}\n\n\nfloat ray(vec3 p, vec3 dir) {\n  float dist=0.;\n  for (int i=0; i<100;i++) {\n    float m=S(p+dist*dir);\n    dist+=m;\n    if (m<0.01) return dist;\n    if (MISS(dist)) return dist;\n  }\n  return 1001.;\n}\n\nvec3 norm(vec3 p) {\n  mat3 K=mat3(p,p,p)-mat3(.001);\n  return normalize(S(p)-vec3(S(K[0]),S(K[1]),S(K[2])));\n}\n\nfloat RES;\n\nvec3 stext(vec2 uv) {\n    vec2 xy = floor(uv*RES)/RES;\n    vec2 idx = (clamp((uv-xy)*RES*4.,0.,4.));\n    // Time varying pixel color\n    float w = nsin(T)-warp(xy);\n    int i=4*int(idx.y)+int(idx.x);\n    vec3 c1 = 1.-mix(vec3(1),vec3(0),T1[i]);\n    vec3 c2 = 1.-mix(vec3(1),vec3(0),T2[i]);\n    vec3 c3 = 1.-mix(vec3(1),vec3(0),T3[i]);//erot(mix(vec3(uv,.6),vec3(.3,.1,.9),T3[i]),vec3(1.,.5,.4),T)/2.+.1;\n    return vec3(mix(c1,mix(c2,c3,step(2.,w)),step(0.,w)));\n\n}\nvec3 text(vec2 uv) {\n    uv = uv+0.;\n    uv /= max(1.-1.*length(uv),.5);\n    uv *= rot(length(uv));\n    \n    uv.y = -uv.y;\n    return stext(uv);\n\n}\nvec3 light(vec3 cam, vec3 dir, float dist,vec3 bg) {\n  vec3 p = cam+dir*dist;\n  vec3 n = norm(p);\n  vec3 R = cross(dir,n);\n  float inc = dot(dir,-n);\n  float ring = n.y;\n  float angle = atan(n.x, n.z)/TAU;\n  \n  //vec3 R = mix(dir,n,.05*inc);\n  return mix(bg,stext(p.xx),step(.1,inc));//inc*text(n.xy);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    RES=floor(20.+20.*nsin(.25+T*3.523));\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uu = fragCoord/iResolution.xy;\n    \n    vec2 uv=uu-.5;\n    \n    \n    uv.x*=iResolution.x/iResolution.y;\n    \n//        uv += rot(T*5.)*vec2(bump(T*5.)-.5);\n\n    // Output to screen\n    vec3 C = text(uv);\n    vec3 cam=vec3(0,0,-5);\n    vec3 dir=normalize(vec3(floor(uv*RES*4.)/RES/4.,1));\n    float dist = ray(cam,dir);\n    if (!MISS(dist)) C=light(cam,dir,dist,C);\n    C -= vec3(.8,.5,sin(uv.x+T));\n    fragColor = vec4(C,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssVSDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[319, 319, 346, 346, 427], [429, 429, 464, 464, 524], [554, 554, 589, 589, 647], [687, 687, 706, 706, 755], [797, 797, 817, 893, 964], [966, 966, 994, 994, 1016], [1018, 1018, 1048, 1048, 1099], [1101, 1101, 1118, 1118, 1285], [1288, 1288, 1317, 1317, 1487], [1489, 1489, 1508, 1508, 1599], [1613, 1613, 1634, 1634, 2078], [2079, 2079, 2099, 2099, 2226], [2227, 2227, 2279, 2279, 2530], [2534, 2534, 2591, 2591, 3124]]}
{"id": "ssVSRc", "name": "入门之路-5", "author": "jialouluo", "description": "noise + mix", "tags": [], "likes": 1, "viewed": 109, "published": "Public API", "date": "1635065707", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 random(in vec2 _st ){\n    _st = vec2(\n            dot(_st,vec2(127.326,321.324)),\n            dot(_st,vec2(15.31,45.332))\n                    );\n    return 2.0*fract(sin(_st)*432.23) +1.0; //1.0 ~ 3.0\n}\nfloat snoise(vec2 st){ //Gradient Noise\n    vec2 i = fract(st);//取小数\n    vec2 k = floor(st);//向负无穷取整\n    vec2 u = i*i*(3.0-2.0*i);//插值函数\n    return  mix(\n                    mix(dot(random(k + vec2(0.0,0.0)),i - vec2(0.0,0.0)),\n                        dot(random(k + vec2(0.0,1.0)),i - vec2(0.0,1.0)),\n                         u.y),\n                    mix(dot(random(k + vec2(1.0,0.0)),i - vec2(1.0,0.0)),\n                        dot(random(k + vec2(1.0,1.0)),i - vec2(1.0,1.0)),\n                         u.y),\n                       u.x\n                   );//二维noise\n}\nfloat Model(vec2 st,float N){\n    st = st*2.-1.;\n    float a = atan(st.x,st.y)+3.14;\n    float r = 6.28/N;\n    return abs(cos(floor(.5+a/r)*r-a)*length(st));\n}\nfloat getModel(vec2 st,vec2 size){\n    return Model(st*size,4.);\n}\nfloat createModel(in vec2 st,in float num[4]){\n    float exy =4.;\n    float exx =2.;\n    st*=vec2(exx,exy);\n    vec2 fi = fract(st);\n    vec2 df = floor(st);\n    fi.x = mix(fi.x,1.-fi.x,step(1.0,df.x));\n    return mix(getModel(fi,vec2(0.83,1.)),getModel(fi - vec2(0.03,0.),vec2(1.0)),num[int(df.y)]);\n}\nfloat getWork(vec2 st,float t){\n    float exy =4.;\n    float exx =2.;\n    float num[4];\n    float j = floor(mod(t,pow(2.,exy)));\n    for(int i=0;i<4;i++){\n        num[i] =0.0;\n        num[i] = step(1.0,mod(j,2.));\n        j = ceil(j/2.);\n    }\n    return createModel(st,num);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 vUv = fragCoord/iResolution.xy;\n    vec2 uv = fract(vUv);\n  //  uv.x*=iResolution.x/iResolution.y;\n    float t = iTime;\n    float c = mix(getWork(uv,t),getWork(uv,t + 1.0),fract(t));\n    c += snoise(uv*7.)*0.08;\n    float angle = atan(uv.y,uv.x);\n    vec3 color = (0.5 + 0.5*cos(6.28*(angle/6.28 +vec3(0.3,0.6,0.9)) ))*c;\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssVSRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 207], [208, 208, 230, 247, 809], [810, 810, 839, 839, 969], [970, 970, 1004, 1004, 1036], [1037, 1037, 1083, 1083, 1339], [1340, 1340, 1371, 1371, 1617], [1618, 1618, 1675, 1675, 2066]]}
{"id": "ssVSW1", "name": "chungaTest4.1", "author": "chungaloid", "description": "use mouse to change function constant\nthe seed is the pixel coordinate instead of 0 in this version", "tags": ["test"], "likes": 1, "viewed": 34, "published": "Public", "date": "1634589563", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define complex vec2\n// z.s is real part; z.t is imaginary part\n\nconst float infinity = 100000.0;\nconst int maxSteps = 50;\n\nvec2 rot(vec2 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return vec2 (\n        c*p.x - s*p.y,\n        s*p.x + c*p.y\n    );\n}\n\ncomplex pow2(complex z) {\n    return complex(z.s*z.s - z.t*z.t, 2.0*z.s*z.t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( 2.0*fragCoord - iResolution.xy ) / iResolution.y;\n    vec2 m = ( 2.0*iMouse.xy - iResolution.xy ) / iResolution.y;\n\n    complex z = uv * 2.0;\n    complex c = m * 2.0;\n    if (iMouse.xy == vec2(0, 0)) {\n        c = complex(1.0, 0.0);\n        c = rot(c, (iTime + 5.7) * 0.5);\n    }\n    \n    int i = 0;\n    for (; i < maxSteps; i++) {\n        z = pow2(z) + c;\n        if (z.s >= infinity || z.t >= infinity)\n            break;\n    }    \n    \n    vec3 col = mix(vec3(0.0), vec3(1.0), vec3(float(i) / float(maxSteps)));\n    \n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssVSW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 124, 151, 151, 267], [269, 269, 294, 294, 348], [351, 351, 408, 408, 983]]}
{"id": "ssVSWG", "name": "3am", "author": "lambmeow", "description": "I am an idiot and drank coffee at 8pm so here i am coding something to pass time and help me fall asleep", "tags": ["sdf", "code", "nosleep", "3am"], "likes": 2, "viewed": 120, "published": "Public API", "date": "1635241723", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\n#define resolution iResolution\nfloat ss(vec3 p)\n{\n\tvec2 xz = vec2(p.x, p.y + p.z * .05);\n\n\tp.xz = mod(p.xz + 1.,2.) - 1.; \n\treturn length(p + sin(time + xz.y *2. - xz.x *0.2)* vec3(0,1,0)) - 1.;\n}\n\nvec3 rt(vec3 ro, vec3 rd)\n{\n\tfloat dist = 0.0;\n\tfor(int i = 0; i < 255; i++)\n\t{\n\t\tfloat ll = ss(ro+rd*dist);\n\t\t\n\t\tif(ll < 0.01)\n\t\t\treturn (ro+rd*dist);\n\t\t\t\n\t\tdist += ll;\n\t\tif(dist > 130.)\n\t\t\tbreak;\n\t\t\n\t\t\n\t}\n\t\n\treturn vec3(200);\n}\n\n\nvec3 nn(vec3 p)\n{\n\tvec2 xx = vec2(0.001, 0);\n\treturn normalize(vec3(\n\t\tss(p + xx.xyy) - ss(p -  xx.xyy),\n\t\tss(p + xx.yxy) - ss(p - xx.yxy),\n\t\tss(p + xx.yyx) - ss(p - xx.yyx)));\n}\n\nvec4 cc(vec3 p, vec2 u)\n{\n\t\n\tvec4 amb =  mix(vec4(0.1,0,0,1), vec4(1,.2,.5,1), (u.y  + 1.) );\n\tif(p.z == 200.)\n\t\treturn amb;\n\tvec3 n = nn(p);\n\tvec4 col =  dot(n, normalize(vec3(0,1,-1)))* vec4(1,0.4,.5,1) * p.z /100. + abs(p.y) * vec4(1, 0,.4,1)  + amb * 0.1;\n\treturn col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 uv )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 r = resolution.xy, u = (2.* (uv) - r)/r.y;\n\t\n\tvec3 rd = normalize(vec3(u, 2.0)),\n\tro = vec3(0,4. + cos(time * 0.05) * 0.5,-10.);\t\n \t\n\tfragColor = cc(rt(ro,rd), u);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssVSWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 50, 68, 68, 215], [217, 217, 244, 244, 446], [449, 449, 466, 466, 627], [629, 629, 654, 654, 903], [907, 907, 957, 1007, 1182]]}
{"id": "ssVSWW", "name": "Nested colors, first attempt", "author": "Loubi", "description": "Trying to make different levels of shape / color.\nNot what I did want in the first place but I find it beautiful.", "tags": ["noise", "wave", "sin", "color"], "likes": 5, "viewed": 74, "published": "Public", "date": "1634672771", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\n// Noise by IQ <3 https://www.shadertoy.com/view/Msf3WH\nvec2 hash( vec2 p ) { // this is good for me\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\nfloat noise( in vec2 p ) {\n    const float K1 = (sqrt(3.)-1.)/2.;\n    const float K2 = (3.-sqrt(3.))/6.;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    vec3 color = vec3(uv.x, uv.y, length(uv));\n    uv.x += 1.;\n    for (float i = 12.1; i >= 0.; i--) {\n        float r = .2 + i * uv.x * .08;\n\n        float c1 = length(uv + sin(iTime - i * (uv.y + uv.x)) * .03);\n        float cc1 = smoothstep(r+.0001, r, c1);\n        color = mix(\n            color,\n            vec3(\n                length(uv) * i * .1,\n                uv.y + i * .22,\n                i * .23\n            ),\n            cc1 * i * .006\n        );\n    }\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssVSWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 82, 103, 126, 241], [242, 242, 268, 268, 721], [723, 723, 779, 779, 1356]]}
{"id": "ssVSzt", "name": "hex tiling test 2", "author": "FabriceNeyret2", "description": "hex truchet  ( adapted from [url]drschizzo. https://shadertoy.com/view/NsVSWw[/url] ).\n\nplay with the profile function P(h) !", "tags": ["truchet", "tiling", "hex"], "likes": 12, "viewed": 157, "published": "Public API", "date": "1635160504", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of golfed version of \"hex tiling test\" by drschizzo. https://shadertoy.com/view/NsVSWw\n\n  #define H(a)   fract(1e4*sin(dot(ceil(a),vec2(17,71))))\n  #define S(v)   smoothstep(20./R.y, 0., v ) \n//#define F3(h)  length(h)*cos(mod(atan(h.y,h.x),2.1)-1.05 - vec2(0,1.57) ) // --- 3-fold rotational symmetry\n  #define F3(h)  length(h)*cos(mod(atan(h.y,h.x)+1.05*.5,2.1)-1.05*.5 - vec2(0,1.57) )\n\n//#define P(h) S( abs(h.xyxy)-.1 )                   // --- play with the profile function !\n//#define P(h) S( abs(length(vec2(abs(h.x)-.9,h.y))-.78) ) \n//#define P(h) S( abs(length(h)-.5) ) \n//#define P(h) .5+.5*cos(30.*length(F3(h)-vec2(.5,0)))\n//#define P(h) .5+.5*cos(60.*length(F3(h)-.575*J.yx))\n//#define P(h) S( abs( length(F3(h)-.575*J.yx) -.285 ) -.15 )\n//#define P(h) S( abs( abs( length(F3(h)-.575*J.yx) -.285 ) -.15  ))\n  #define P(h) .5*S( w = abs( length(F3(h)-.575*J.yx) -.285 ) -.15 ) + S( abs(w) )\n//#define P(h) min(1., S( abs(length(vec2(abs(h.x)-.9,h.y))-.78)-w ) + 4.5*dot(h,h)* S(abs(h.y)-w))\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R =  iResolution.xy,\n         U = 13.*(u-.5*R)/R.y + iTime*1.3,\n         J = vec2(.5,.87),                                  // hexuv\n         a = mod(U+J,J+J) - J,\n         b = mod(U  ,J+J) - J,\n         G = dot(a,a) < dot(b,b) ? a : b;                   // G: hex coords.  U-G : hex id\n    \n    float s = fract(1e4*sin(dot(ceil(U-G+floor(5.+iTime)),vec2(17,71)))), w=.08;  // tile angle attribute\n  \n    G *= mat2(cos( (s<.33 ? 3.14/3. : s<.66 ? -3.14/3. : 0.) + vec4(0,11,33,0))); // random rot tile\n    O += P(G) -O;                                           // apply profile shape\n // O *= S(.5-length(O)) *s;                                // debug: show tile Id\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssVSzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[913, 1014, 1052, 1052, 1731]]}
{"id": "ssVXWc", "name": "color-stuff red-blue mash", "author": "bigbadbob234", "description": "still trying to make pixel-outputs (blue, a fixed wavelength, can't rly change physics) feel more-blue-than blue.", "tags": ["colors", "colorshift", "newcolors", "exploringcolor"], "likes": 3, "viewed": 34, "published": "Public API", "date": "1635446503", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat rand(vec2 co){\n    return fract(sin(dot(co*iTime, vec2(12.9898, 78.233))) * 43758.5453);\n}\n    \n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 uv = fragCoord;\n    \n    float t = iTime * 3.;\n    float k = 2.;\n    float doodle = t; //(t*3.+sin(t*.75)*.5+sin(t*.33)*.25+sin(t*.25)*.125);\n    //float a = .5 + .5*cos(doodle + uv.x - (uv.x*floor(uv.x/k)) + uv.y - (uv.y*floor(uv.y/k)));\n    float a = cos(uv.x*.55)*(doodle)*.2 + sin(uv.y*3.14)*1.+cos(uv.y*.01); \n    a = a-floor(a);\n    float b1 = (t-floor(t));\n    float b = a; // + b1;\n    //(uv.x*floor(uv.x / 7.0)) \n    float h = b - (b * floor(b/t));\n    float h2 = (exp(h)/2.718*2.-1.);\n    \n       \n    //vec3 midcol = vec3(1.,1.,1.);\n    //vec3 cola = mix(vec3(1.,.0,1.), vec3(1.,0.,0.), h2);\n    //vec3 colb = mix(vec3(0.,1.,1.), vec3(0.,.5,1.), h2);\n\n    //vec3 cola = mix(vec3(2.,.0,.0), vec3(0.,1.,2.), h);\n    //vec3 colb = mix(vec3(1.,1.,1.), vec3(0.,.0,2.), h2);\n    //vec3 col = mix(cola, colb, h);\n    \n    float rval = rand(fragCoord);\n    vec3 cola = mix(vec3(1.-h2,0,1.-rval), vec3(0,0,1), h);\n    vec3 colb = mix(vec3(1.-h2,0.-2.,0), vec3(.5-rval,rval*h2,2.*h2+rval), h);\n    vec3 col = mix(cola, colb, h);\n\n    //vec3 cola = mix(vec3(.3,0,1), vec3(1,1,0), h);\n    //vec3 colb = mix(vec3(1,.3,0), vec3(0,.5,2), h);\n    //vec3 col = mix(cola, colb, (h2));\n    \n    \n    //vec3 col = vec3(1.-h2*2., (.5-h2)*(.5-h), h2*(abs(.25-h)+1.));\n    // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssVXWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 21, 21, 97], [108, 108, 165, 257, 1640]]}
{"id": "ssVXWG", "name": "入门之路-7", "author": "jialouluo", "description": "网格噪声 + Voronoi算法", "tags": [], "likes": 0, "viewed": 132, "published": "Public API", "date": "1635246403", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 random( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv*=3.;\n    vec2 f = fract(uv);//取小数部分 -单元网格坐标\n    vec2 k = floor(uv);//取整\n    vec3 color =vec3(0.0);\n    float m = 2.0;\n    vec2 dir = vec2(0.0);\n    for(int i=-1;i<=1;i++){\n        for(int j =-1;j<=1;j++){\n            vec2 rand = vec2(float(i),float(j));\n            vec2 result = random(rand+ k );\n            result = 0.5 + 0.5*sin(iTime + result*6.28 ) + rand ;\n            float dis = length(result - f);\n            if(dis<m){\n                m = dis;\n                dir = result;\n            }\n        }\n    }\n    //简单的理解为 找到每个像素与多个（这里是9个--上下左右四个斜角还有像素自身存在的网格的特殊点(伪随机点)）单元网格特殊点(伪随机点)的最短距离特殊点，然后将其距离的值存储下来\n    color+=m;\n    color-=abs(sin(35.43 * m))*0.3;\n    color.rg =dir; \n    \n    color = step(0.05,color)*color;\n    \n    \n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssVXWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 116], [118, 118, 175, 225, 1250]]}
{"id": "ssySDK", "name": "Сubic cave", "author": "sinvec", "description": "Based on [url=https://www.shadertoy.com/view/fsVXR3]Glowing cobweb[/url]", "tags": ["3d", "sdf", "cube", "cubic"], "likes": 5, "viewed": 70, "published": "Public", "date": "1635337950", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define U (10.)\n#define Y (2.)\n#define dd(a) (floor(clamp((a),-1.+Y*(1./U),1.-Y*(1./U))*U)*(1./U))\n#define r(a) (mat2(cos(a),sin(a),-sin(a),cos(a)))\nvoid mainImage(out vec4 e, in vec2 v) {\n    e=vec4(0.);\n    vec3 d=vec3((v.xy-iResolution.xy*.5)/iResolution.y,.3),p;\n    d.yz*=r(iTime*.2); d.xz*=r(iTime*.2);\n    for(float o,i=0.;i<53.;i++){\n        o=1.2-length(dd(cos(p.xy))+dd(sin(p.yz-vec2(-1.,iTime*5.))));\n        p+=(o-.01)*d;\n        e.xyz+=vec3(.3,.3,.3)*(.0009/clamp(abs(o),.01,9.));\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssySDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[149, 149, 188, 188, 501]]}
{"id": "ssySDy", "name": "Blob chain", "author": "op", "description": "Raymarching in sliced  blob chain of balls and  point lights", "tags": ["3d", "raymarching", "distancefield", "blob", "ball", "kerning"], "likes": 4, "viewed": 176, "published": "Public API", "date": "1635210272", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst vec3 g_lightDir = normalize(vec3(-1.0, 0.6, -1.0));\nconst vec3 g_bakLightDir = normalize(vec3(1.0, -0.7, 1.5));\n\nconst float g_tg = 0.98; // point light trigger\n\n// ------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n#define saturate(_a) clamp(_a, 0.0,1.0)\n\n\nfloat hash13(ivec3 p)\n{\n    vec3 p3  = fract(vec3(p) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n// from IQ\nvec3 hash33( uvec3 x )\n{\n    const uint k = 1103515245U;\n\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nvec3 hash33( ivec3 x )\n{\n    return hash33( uvec3(x) );\n}\n\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( in vec3 p, in vec3 c, in float r )\n{\n    return length(p-c) - r;\n}\n\n\n// smin for 2 components, driven by first one(distance)\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = max(k-abs(a.x-b.x),0.0);\n    h = h*h*0.25/k;\n    \n    \n    float g = (b.y-a.y)*h;\n    \n    \n    return a.x<b.x ? vec2(a.x-h, a.y+g) : vec2(b.x-h, b.y-g);    \n}\n\n\n#define RING_RADIUS 1.0\n#define RING_AMPLITUDE 1.0\n\nconst float distErr = max(0.0, sqrt(pow(RING_RADIUS+RING_AMPLITUDE,2.0)*2.0) - 1.5);\n\nvec2 map( in bool highOnly, in vec3 p )\n{\n\n    vec2 res = vec2(1000000.0, 1.0);\n\n    float s = 1.0;\n    p *= s;\n    \n\n    // animate smin\n    float sm = 0.01 + 0.99*max(0.0,sin(iTime*0.2));\n\n    // scan 3 rings of ball (left, center, right)\n    for(int i=-1; i<=1; i++)\n    {                                \n        vec3 f = fract(p);\n        f.y = p.y;\n        f.z = p.z;\n\n\n        vec3 cc = vec3(i,0,0);\n        vec3 cw = p-f + cc;\n        ivec3 bid = ivec3(cw);\n        cc += 0.5;// center\n\n        cc.y += RING_AMPLITUDE * sin( cw.x +  iTime*1.33);\n        cc.z += RING_AMPLITUDE * cos( cw.x +  iTime*1.23);\n\n\n        const int nb = 8;\n        float a = iTime*(1.17 + sin(cw.x*7.27) ); // twist !\n        for(int j=0; j<nb; j++, a+=2.0*3.14159/float(nb))\n        {\n            ivec3 id = bid; id.y += j;\n            vec3 hs = hash33( id );\n\n            float e = fract(hs.x+hs.z);  // random color scale                    \n            if(highOnly && e<g_tg) continue;\n\n            vec3 c=cc;\n            c.z += RING_RADIUS * cos(a) * (0.4 + 0.6*hs.y);\n            c.y += RING_RADIUS * sin(a) * (0.4 + 0.6*hs.z);\n\n            // Random radius\n            float r = 0.1 + 0.3*hs.x*(0.7 + 0.3*sin( (0.1 +hs.z*7.31) *  iTime));\n\n            // Random offset\n            float o = fract(hs.x+hs.y)*(1.0-2.0*r) - (0.5-r);                   \n            o *= 0.5 + 0.5*sin( (0.1 + hs.x*5.51)*iTime)*sin(iTime*(0.2 + 11.1*hs.y));\n            c.x += o;\n\n            // sdf\n            float d = length(f-c) - r;\n\n            res = smin(res, vec2(d, e), sm );\n\n            res.y = min(1.0, res.y);                                        \n        }\n\n        if(res.x<=0.0) break;\n    }\n    \n    res.x /= s;\n    \n    return res;\n}\n\n\n\nvec3 calcNormal(in vec3 pos, in float eps )\n{\n#if 0    \n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*map( pos + e.xyy,outside, MAP_DETAIL_STD ).x + \n       e.yyx*map( pos + e.yyx).x ) + \n       e.yxy*map( pos + e.yxy).x ) + \n       e.xxx*map( pos + e.xxx).x ) );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(false, pos+0.001*e).x;\n    }\n    return normalize(n);\n\n#endif    \n}\n\n\nvec2 intersect(in float maxdist, in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0, 0);\n\n\n    float t = 0.0;\n\n    for( int i=0; i<100; i++ )\n    {\n        vec3 p = ro + t*rd;\n        vec2 h = map( false, p );\n        \n        if( h.x<(0.0001*t) ||  t>maxdist ) return vec2(t, h.y);\n\n        // we should have perfect distance:\n        // but since we offset in a vertical slice, and only scan left&right neigboor,\n        // then we need to detect potentially over evaluated distances\n      \n        t+= h.x<=distErr ? h.x : max(distErr, h.x-distErr);\n\n    }\n\n    return vec2(maxdist, 0.0); //res;\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n\n    float tmax = 120.0;\n    \n    float t = 0.02;\n    for( int i=ZERO; i<50; i++ )\n    {\n        float h = map(false, ro + rd*t ).x;\n          \n#if 1\n        res = min( res, 4.0*h/t );// soft\n#else        \n        if(t>0.1 && h<=0.0) return 0.0;// hard\n#endif        \n\n        t += clamp( h, 0.05, 0.40 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return max(.0, res );\n}\n\n\n\nfloat specular(vec3 ld, vec3 n, vec3 rd, float s)\n{\n    return pow( max(0.0, dot(reflect(ld,n), rd )), s);\n}\n\nfloat diffuse(vec3 ld, vec3 n)\n{\n    return saturate( dot(n , ld) );\n}\n\n\nvec3 background(vec3 p, vec3 n)\n{\n    return vec3(0.3,0.4,0.5)*0.3 * (0.5 + 0.5*dot(n,g_lightDir)  );\n}\n\nvec3 calcPointColor(float id)\n{\n    id = saturate( (id-g_tg)/(1.0-g_tg) );\n    float tm = iTime * ( 0.7 + 0.3*id);\n    \n    float tc = pow(sin(0.1*tm),2.0);\n    vec3 c1 = mix( 1.5*vec3(1.0,0.5 + tc ,0.0), 1.5*vec3(0.0, tc+0.5,tc*tc), tc );\n    \n    vec3 c2 = mix( 1.5*vec3(1.0,tc*2.0, 0.0), 1.5*vec3(1.0,0.0, tc), tc );\n        \n    tc = saturate( sin(tm*0.23)*4.0 );\n    \n    return mix(c1, c2, tc );       \n}\n\n\nvec3 render(in vec2 fragCoord, in vec3 ro, in vec3 rd, out float tt )\n{\n    float maxDist = 50.0;\n    vec2 t = intersect(maxDist, ro,rd);\n    \n    tt = t.x;\n    \n    vec3 col, colBackground = background(ro,rd);\n    \n    if(t.x>=maxDist)\n        col = colBackground; // background\n    else\n    {\n\n        vec3 p = ro + rd*t.x;\n        vec3 n  = calcNormal(p , 0.0001);\n\n\n        if(t.y>g_tg)\n        { // point light/self illum\n            col  = calcPointColor(t.y);\n\n            // small halo..\n            float r= 0.5; // max radius of a sphere\n            float e = map(true, p+rd*r).x;\n            col *= smoothstep(0.8, 0.0, e/r);\n\n        }\n        else\n        {\n            // ambient\n            vec3 amb = 0.2*textureLod( iChannel3, n.xy, 0.0 ).xyz;\n            amb += 0.5*background(ro,n);\n\n            // Ball color\n            float ty = t.y / g_tg;            \n            vec3 colBall = 0.5*mix(vec3(0.3, 0.1, 0.5), vec3(0.9, 0.3, 0.5), ty);\n\n\n            // directional lighting\n            float atten = 0.5 + 0.5*calcSoftshadow(p, g_lightDir);\n            col = colBall * ( amb + atten*diffuse(g_lightDir, n) );\n            col+= atten*specular(g_lightDir, n, rd, 16.0);\n\n\n            // animation: show shadowed only\n            {\n                float u = saturate( sin(iTime*0.2 + fragCoord.x*0.001)*4.0 );\n                col = mix(vec3(atten), col, u );\n            }\n    \n    \n            // back light\n            float d = 1.0 - min(1.0, 0.1*length(p-vec3(0)) );\n            col += /*atten**/0.6*vec3(0.0, 0.7, 1.0)* diffuse(g_bakLightDir, n) * d;\n\n\n            // lighting with closest point light, by calculating the distance variation along normal, in the light field !\n            {\n                const float rl = 3.0; // point light radius\n                vec2 pl = map( true, p ); // closest point light\n                if(pl.x < rl)\n                {\n                    float dl = (rl-pl.x) * max(0.0, pl.r-map(true, p+n).x) / rl;\n                    // lighting + some 'reflectivity'\n                    vec3  cl = calcPointColor(pl.y);\n                    col += cl*(colBall + 0.2) * dl * 4.0;\n                }\n            }\n        }\n        \n        // fog\n        col = mix(colBackground, col \n                        , smoothstep(maxDist, -3.0, t.x) );\n                        //,min(1.0,exp(-.05*t.x + 1.0)) );\n    }\n\n    \n    return col;\n}\n\n\n\n\nmat3 setCamera( in vec3 ro, in vec3 rt, in float cr )\n{\n    vec3 cw = normalize(rt-ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    \n    return mat3( cu, cv, cw );\n}\n\nvec3 pathCamera(out vec3 ta)\n{\n    float cTime = iTime*0.3;\n\n    // camera\n    float an = 0.025*sin(0.5*cTime) - 1.25;\n    vec3 ro = vec3(5.7,1.6, 5.7);\n    \n    ro.x = 0.0+ cos(0.5*cTime)*10.0;  \n    ro.z = 0.0+ sin(0.5*cTime)*12.0;\n\n    ro.y += sin(0.351*cTime)*16.0;\n\n    ta = vec3(0.0,0.0 + 0.0*sin(0.1*cTime),0);    \n\n    return ro;\n}\n\n\nvec3 ACESFilm(vec3 x)\n{\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (2.0*(fragCoord)-iResolution.xy)/iResolution.y;\n\n    // camera\n    vec3 ta, ro=pathCamera(ta);\n\n\n    // ray\n    const float fl = 3.5;\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    vec3 rd = normalize( ca * vec3(p,fl) );\n\n    vec3 col = vec3(0.0);\n\n\n    // render\n    float t;    col += render(fragCoord, ro, rd, t);\n\n\n    // vignetting\t\n\tcol *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 );\n\n    \n    // Output to screen    \n    fragColor = vec4( ACESFilm(col), 1.0);\n}\n", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssySDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[169, 293, 316, 316, 432], [435, 446, 470, 470, 636], [638, 638, 662, 662, 695], [698, 750, 791, 791, 863], [865, 917, 958, 958, 1030], [1033, 1104, 1156, 1156, 1186], [1189, 1245, 1283, 1283, 1457], [1598, 1598, 1639, 1639, 3321], [3325, 3325, 3370, 3370, 3936], [3939, 3939, 3998, 3998, 4540], [4542, 4604, 4652, 4652, 5054], [5058, 5058, 5109, 5109, 5166], [5168, 5168, 5200, 5200, 5238], [5241, 5241, 5274, 5274, 5344], [5346, 5346, 5377, 5377, 5756], [5759, 5759, 5830, 5830, 8144], [8149, 8149, 8204, 8204, 8398], [8400, 8400, 8430, 8430, 8739], [8742, 8742, 8765, 8821, 9007], [9010, 9010, 9067, 9067, 9602]]}
{"id": "ssySDz", "name": "Something  gaz 232", "author": "gaz", "description": "3d", "tags": ["3d"], "likes": 6, "viewed": 94, "published": "Public", "date": "1634462392", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\n\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,q,r=iResolution,d=normalize(vec3((C-.5*r.xy)/r.y,1.));\n    for(float i=0.,g,e=1.;++i<99.;){\n        p=g*d;\n        p.z+=iTime*6.;\n        q=sin(p);\n        p+=cross(sin(p*1.5+iTime*3.),cos(p.zxy*1.2+iTime*2.));\n        p=cos(p/3.);\n        g+=e=abs(length(p)-1.)+1e-3;\n        O.xyz+=mix(vec3(1),H(dot(q,q)*.3),.8)*.014*exp(-1e-3*i*i*e);\n    }\n    O*=O*O*O*O;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssySDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 107, 143, 143, 531]]}
{"id": "ssySRz", "name": "Moving Grid", "author": "andregoncalvesvc", "description": "Based on https://www.shadertoy.com/view/Xt2cDt.", "tags": ["grid", "movinggrid"], "likes": 0, "viewed": 68, "published": "Public", "date": "1634238741", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float grid(vec2 uv)\n{\n    #define VANTAGE vec2(0, -0.21)\n\n    uv = uv - VANTAGE;\n\n    float m = max(sign(-uv.y), 0.0);\n\n    uv /= 1.0;\n    \n    float d = -1.0 / uv.y;\n    vec2 pv = vec2(uv.x * d, d);\n\n    pv *= 1.4545;\n    pv.y += iTime;\n\n    const float N = 32.0;\n\n    vec2 w = fwidth(pv) + 0.001;\n    vec2 a = pv + 0.5 * w;\n    vec2 b = pv - 0.5 * w;\n    vec2 i = (floor(a) + min(fract(a) * N, 1.0) - floor(b) - min(fract(b) * N, 1.0)) / (N * w);\n\n    return (i.x + i.y - i.x * i.y) * m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uvo = (fragCoord.xy * 2. / iResolution.xy) - vec2(1);\n\tvec2 uv = uvo * vec2(iResolution.x/iResolution.y, 1);\n    \n    float g = grid(uv);\n    \n    fragColor.rgb += g;\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssySRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 491], [493, 493, 550, 550, 748]]}
{"id": "ssySWt", "name": "Misc 1", "author": "Livie", "description": "Idk there's weird stuff going on at lower radii, only just starting looking into the mod/repeating math side of things", "tags": ["misc"], "likes": 2, "viewed": 34, "published": "Public", "date": "1635479123", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float CLOSE_ENOUGH = 0.001;\nconst float RENDER_DISTANCE = 30.0;\nconst vec3 COLOR = vec3(227., 186., 129.)/255.;\nconst vec3 BG_COLOR = vec3(.05,.7,.025);\nconst vec3 SHADOW_COLOR = vec3(.1,.9,.8);\n\nconst vec2 v1params = vec2(1.0,  .5);\nconst vec2 v2params = vec2(2.0, 1.3);\nconst vec2 v3params = vec2(1.5,  .6);\nconst vec2 v4params = vec2(0.5,  .3);\nconst vec2 v5params = vec2(0.75,1.0);\n\n//  Conversion fns from Iñigo Quiles @ https://www.shadertoy.com/view/MsS3Wc\nvec3 rgb2hsb( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                d / (q.x + e),\n                q.x);\n}\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nstruct sphere\n{\n\tvec3 c;\n    float r;\n};\n\n\nfloat sphereDist(vec3 p, sphere s)\n{\n\treturn distance(p, s.c) - s.r;\n}\n\n//from iq : https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat opSmoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat sdf(vec3 p)\n{\n    float returnVal = .0;\n    \n    \n    vec3 rep = vec3(1.5, 1.5, 1.5);\n\tvec3 pr = mod(p, rep) - .5 * rep; \n        \n    sphere s1 = sphere(vec3(sin(iTime*v1params.x)*0.4, sin(iTime*v1params.y)*0.4, 1.), .4+0.05*sin(iTime));\n    //sphere s2 = sphere(vec3(sin(iTime*v2params.x)*0.2, sin(iTime*v2params.y)*0.2, 1.), .4);\n    //sphere s3 = sphere(vec3(sin(iTime*v3params.x), sin(iTime*v3params.y), 1.), .45);\n    //sphere s4 = sphere(vec3(sin(iTime*v4params.x), sin(iTime*v4params.y), 1.), .2);\n    //sphere s5 = sphere(vec3(sin(iTime*v5params.x), sin(iTime*v5params.y), 1.), .2);\n    \n    float smoothness = .2;\n    //returnVal = opSmoothUnion(sphereDist(pr, s1), sphereDist(pr,s2), smoothness);\n    //returnVal = opSmoothUnion(returnVal, sphereDist(pr, s3), smoothness);\n    //returnVal = opSmoothUnion(returnVal, sphereDist(pr, s4), smoothness);\n    //returnVal = opSmoothUnion(returnVal, sphereDist(pr, s5), smoothness);\n    \n    return sphereDist(pr, s1);\n\t//return returnVal; \n}\n\n//from iq https://www.iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 p )\n{\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*sdf( p + k.xyy*CLOSE_ENOUGH ) + \n                      k.yyx*sdf( p + k.yyx*CLOSE_ENOUGH ) + \n                      k.yxy*sdf( p + k.yxy*CLOSE_ENOUGH ) + \n                      k.xxx*sdf( p + k.xxx*CLOSE_ENOUGH ) );\n}\n\n\n// Inverse Distance Weighting - for color interpolation\nvec3 calculateIDW(vec2 p) {\n    vec3 v1 = vec3(sin(iTime*v1params.x), sin(iTime*v1params.y), 1.);\n    vec3 v2 = vec3(sin(iTime*v2params.x), sin(iTime*v2params.y), 1.);\n    vec3 v3 = vec3(sin(iTime*v3params.x), sin(iTime*v3params.y), 1.);\n    vec3 v4 = vec3(sin(iTime*v4params.x), sin(iTime*v4params.y), 1.);\n    vec3 v5 = vec3(sin(iTime*v5params.x), sin(iTime*v5params.y), 1.);\n       \n    // Shepard's method\n    // https://en.wikipedia.org/wiki/Inverse_distance_weighting\n    float powerParam = 5.;\n    float w1 = 1./pow(distance(vec3(p.x, p.y, 1.), v1), powerParam);\n    float w2 = 1./pow(distance(vec3(p.x, p.y, 1.), v2), powerParam);\n    float w3 = 1./pow(distance(vec3(p.x, p.y, 1.), v3), powerParam);\n    float w4 = 1./pow(distance(vec3(p.x, p.y, 1.), v4), powerParam);\n    float w5 = 1./pow(distance(vec3(p.x, p.y, 1.), v5), powerParam);\n    vec3 u1 = vec3(.4,  1., 1.);\n    vec3 u2 = vec3(.7,  1., .7);\n    vec3 u3 = vec3(.8,  1., .5);\n    //vec3 u4 = vec3(.89,  1., 1.);\n    //vec3 u5 = vec3(.5,  1., 1.);\n    \n    //vec3 u = (w1*u1 + w2*u2 + w3*u3 + w4*u4 + w5*u5)/(w1+w2+w3+w4+w5);\n    vec3 u = (w1*u1 + w2*u2 + w3*u3)/(w1+w2+w3);\n    return u;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n\tvec2 uv    = fragCoord.xy / iResolution.xy - vec2(0.5);\n         uv.x *= iResolution.x / iResolution.y;\n\tvec3 cameraPos = vec3(.0, .0, .0);//vec3(.0,sin(iTime)*.5,.0);// + iTime);\n    \n    // Time varying pixel color\n    vec3 ro = vec3(cameraPos.x + uv.x, cameraPos.y + uv.y, cameraPos.z);\n\tvec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n    vec3 col = hsb2rgb(BG_COLOR);\n    //col = calculateIDW(uv.xy); \n    float dist = .0;\n    \n    float pWidth = .005;\n    if (false) {\n        /*distance(uv.xy*2., vec2(sin(iTime*v1params.x), sin(iTime*v1params.y))) < pWidth ||\n        distance(uv.xy*2., vec2(sin(iTime*v2params.x), sin(iTime*v2params.y))) < pWidth ||\n        distance(uv.xy*2., vec2(sin(iTime*v3params.x), sin(iTime*v3params.y))) < pWidth ||\n        distance(uv.xy*2., vec2(sin(iTime*v4params.x), sin(iTime*v4params.y))) < pWidth ||\n        distance(uv.xy*2., vec2(sin(iTime*v5params.x), sin(iTime*v5params.y))) < pWidth) {\n        fragColor = vec4(1.,1.,1., 1.0);*/\n    }\n    else{    \n        vec3 lightDir = normalize(vec3(sin(iTime*0.125), sin(iTime*0.25), -1.0));\n\n        while(dist < RENDER_DISTANCE)\n        {\n            float d = sdf(ro + rd * dist);\n            if(d < CLOSE_ENOUGH)\n            {\n\n\n                vec3 hit = ro + rd * dist;\n                col = calculateIDW(hit.xy);//BLUE; \n                col *= mix(hsb2rgb(SHADOW_COLOR), col, max(dot(calcNormal(hit), lightDir), .0));\n                col = hsb2rgb(col);\n                break;\n            }\n            dist += d;\n        }\n\n        // Output to screen\n        fragColor = vec4(col, 1.0);\n        }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssySWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[393, 471, 497, 497, 927], [928, 928, 954, 954, 1186], [1231, 1231, 1267, 1267, 1301], [1303, 1387, 1440, 1440, 1540], [1542, 1542, 1561, 1561, 2543], [2545, 2621, 2651, 2651, 2928], [2931, 2987, 3014, 3014, 4145], [4148, 4148, 4205, 4255, 5845]]}
{"id": "ssySz1", "name": "Fireworks Shader", "author": "cam93", "description": "this is a demonstration of a shader that simulates the behavior of fireworks", "tags": ["fireworks"], "likes": 17, "viewed": 201, "published": "Public", "date": "1634310774", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NUM_EXPLOSIONS 5.\n#define NUM_PARTICLES 75.\n\nvec2 Hash12(float t){\n\nfloat x = fract(sin(t*674.3)*453.2);\nfloat y = fract(sin((t+x)*714.3)*263.2);\n\nreturn vec2(x, y);\n}\n\nvec2 Hash12_Polar(float t){\n\nfloat p_Angle = fract(sin(t*674.3)*453.2)*6.2832;\nfloat p_Dist = fract(sin((t+p_Angle)*714.3)*263.2);\n\nreturn vec2(sin(p_Angle), cos(p_Angle))*p_Dist;\n}\n\nfloat Explosion(vec2 uv, float t){\n \n float sparks = 0.;\n \n    for(float i = 0.; i<NUM_PARTICLES; i++){\n    \n        vec2 dir = Hash12_Polar(i+1.)*.5;\n        float dist = length(uv-dir*t);\n        float brightness = mix(.0005, .0005, smoothstep(.05, 0., t));\n        \n        brightness *= sin(t*20.+i)*.5+.5; \n        brightness*= smoothstep(1., .6, t);\n        sparks += brightness/dist;\n    }\n    return sparks;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord -.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    for(float i = 0.; i<NUM_EXPLOSIONS; i++){\n    float t =iTime+i/NUM_EXPLOSIONS;\n    float ft = floor(t);\n        vec3 color = sin(4.*vec3(.34,.54,.43)*ft)*.25+.75;\n\n       \n        vec2 offset = Hash12(i+1.+ft)-.5;\n        offset*=vec2(1.77, 1.);\n        //col+=.0004/length(uv-offset);\n        \n         col += Explosion(uv-offset, fract(t))*color;\n       }\n   \n   col*=2.;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssySz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 74, 74, 175], [177, 177, 204, 204, 358], [360, 360, 394, 394, 777], [779, 779, 836, 836, 1337]]}
{"id": "ssySzR", "name": "Square, Circle and a line", "author": "leeinbar", "description": "Drawing squares, circles and lines,\nsome anti aliasing as well.", "tags": ["line", "circle", "antialiasing", "square", "shapes"], "likes": 0, "viewed": 28, "published": "Public", "date": "1634234430", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float map(float value, float min1, float max1, float min2, float max2)\n{\n    return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nbool in_rect(vec2 pos, vec2 size, vec2 fragCoord)\n{\n    return (fragCoord.x >= pos.x && fragCoord.x <= pos.x+size.x\n        && fragCoord.y >= pos.y && fragCoord.y <= pos.y+size.y);\n}\n\nbool in_circle(vec2 center, float r, vec2 fragCoord)\n{\n    return (length(fragCoord - center) <= r);\n}\n\nfloat aa_circle(vec2 center, float r, float glow, vec2 fragCoord)\n{\n    return min(1.0, (-length(fragCoord - center) + r)*glow);\n}\n\nbool in_line(vec2 a, vec2 b, float t, vec2 fragCoord)\n{\n    if (b.x - a.x == 0.0)\n    {\n        float highest = max(a.y, b.y);\n        float lowest = min(a.y, b.y);\n        return (fragCoord.x <= a.x + t && fragCoord.x >= a.x - t && fragCoord.y <= highest && fragCoord.y >= lowest);\n    }\n    else\n    {\n        float slope = (b.y- a.y)/(b.x - a.x);\n        float c = a.y - slope*a.x;\n        float f_x = slope*fragCoord.x + c;\n       \n        float highest = max(a.x, b.x);\n        float lowest = min(a.x, b.x);\n        return (fragCoord.y <= f_x+t && fragCoord.y >= f_x-t && fragCoord.x <= highest && fragCoord.x >= lowest);\n    }\n}\n\nfloat aa_line(vec2 a, vec2 b, float t, vec2 fragCoord)\n{\n    if (b.x - a.x == 0.0)\n    {\n        float highest = max(a.y, b.y);\n        float lowest = min(a.y, b.y);\n        if (fragCoord.y <= highest && fragCoord.y >= lowest)\n        {\n            return map(abs(fragCoord.x - a.x), 0.0, t, 1.0, 0.0);\n        }\n        else\n        {\n            return 0.0;\n        }\n    }\n    else\n    {\n        float slope = (b.y- a.y)/(b.x - a.x);\n        t += abs(slope*0.7);\n        float c = a.y - slope*a.x;\n        float f_x = slope*fragCoord.x + c;\n        vec2 highest = vec2(max(a.x, b.x), max(a.y, b.y));\n        vec2 lowest = vec2(min(a.x, b.x), min(a.y, b.y));\n        if (fragCoord.x <= highest.x && fragCoord.y <= highest.y && fragCoord.x >= lowest.x && fragCoord.y >= lowest.y)\n        {\n            return map(abs(fragCoord.y - f_x), 0.0, t, 1.0, 0.0);\n        }\n        else\n        {\n            return 0.0;\n        }\n        //( && fragCoord.x <= highest && fragCoord.x >= lowest);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    vec2 p1 = vec2(100.0, 100.0);\n    float r = 0.0; //aa_line(p1, iMouse.xy, 2.0, fragCoord);\n    float g = in_circle(vec2(250.0, 250.0 + abs(sin(2.0*iTime))*27.0), 200.0, fragCoord) ? 1.0 : 0.0;\n    float b = aa_circle(vec2(655.0, 250.0 + abs(sin(2.0*iTime + 1.6))*27.0), 200.0, 1.0, fragCoord);\n    fragColor += vec4(r, g, b, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssySzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 72, 72, 140], [142, 142, 193, 193, 324], [326, 326, 380, 380, 428], [430, 430, 497, 497, 560], [562, 562, 617, 617, 1196], [1198, 1198, 1254, 1254, 2194], [2196, 2196, 2253, 2253, 2632]]}
{"id": "ssySzz", "name": "Simple Flower color version", "author": "J3r3m13", "description": "A colored version of cacheflowe's shader", "tags": ["flower", "breathing"], "likes": 2, "viewed": 39, "published": "Public", "date": "1634243173", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float TWO_PI = 6.28318530718,\n        distThresh = 0.4,\n        baseRadius = 0.2,\n      brightAdjust = 5.,\n  numControlPoints = 16.,\n             speed = 1.;\n\n#define SC(a) vec2(sin(a),cos(a))\n\nvoid mainImage( out vec4 O,  vec2 U )\n{\n    U = (2. * U - iResolution.xy) / iResolution.y;\n\n    float time = iTime * speed,\n        radius = baseRadius * ( 1. + .7 * sin(time) ),\n          dist = 0., d;\n    \n    for (float i=0.; i < 1.; i+=1./numControlPoints) {\n        d = distance (U, 2.*radius * SC(i*TWO_PI) );\n        if (d < distThresh) dist += d;\n    }\n    //vec3 r =0.5 + 0.5*cos(iTime+vec3(0,2,4))\n\n    O = vec4(cos(iTime+vec3(0,2,4))*dist/numControlPoints * brightAdjust,0);\n    \n    \n   // O = vec4(dist/numControlPoints * brightAdjust);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssySzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[200, 200, 239, 239, 751]]}
{"id": "ssyXDw", "name": "Extruded Circle Animation", "author": "Shane", "description": "A quarter circle animation in extruded form.", "tags": ["circle", "design", "extrude", "propeller"], "likes": 41, "viewed": 300, "published": "Public API", "date": "1635163329", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n    Extruded Circle Animation\n    -------------------------\n\n\tAs previously mentioned, I on occasion like to take a simple flat 2D \n    example, then extrapolate it to a quasi 3D setting to see if it looks\n    interesting. In this case, I've extruded a 2D animation I've seen in \n    various forms. I think this particular one was originally written by \n    FLRN (Florian).\n    \n    I got the idea to do it after looking at a version on Shadertoy written\n    by Vamoss -- The links to it and the original it was based on are below,\n    for anyone interested.\n    \n    The extruded version is interesting, but it's really hard to beat the \n    simplicity of the original. Anyway, there's nothing technically\n    challenging here, but I've provided a heap of options below, for anyone\n    who wishes to play around with various rendering styles.\n\t\n    \n\n\tBased on the following:\n    \n\tSquare Circle Dance - vamoss\n    https://www.shadertoy.com/view/ldK3Dc\n    \n    Which in turn was based  on:\n    FLORIAN (FLRN)\n    https://flrn-gif.tumblr.com/post/116319247625\n\n\n\n*/\n\n// Textured, metallic and environmental lighting options. Turning them\n// all off looks a little cleaner, which is sometimes preferred, but I've\n// defaulted to a weathered appearance.\n#define TEXTURE\n#define METALLIC\n#define ENVIRONMENT\n\n// Palette - Spectrum: 0, Golden brown: 1, Green and blue: 2, Blinking: 3, \n// Mondrian: 4, White: 5.\n#define PALETTE 0\n\n// Paint the sides a lighter color.\n#define SIDES\n\n// Bump map the background cells.\n#define BUMP_BG\n\n// Giving the camera a subltle tilt.\n#define CAM_TILT\n// Lens warp.\n#define LENS_WARP\n\n\n\n\n// Grayscale (and slightly sepia), for that pretentious artistic look. :)\n//#define GRAYSCALE\n\n// Max ray distance.\n#define FAR 20.\n\n// Scale.\nconst vec2 gScale = vec2(.5);\n\n\n\n// Scene object ID to separate the mesh object from the terrain.\nfloat objID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial by Ryan Geiss.\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n){ \n    \n    n = max(abs(n) - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n);\n    \n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\n\n\n// Getting the video texture. I've deliberately stretched it out to fit across the screen,\n// which means messing with the natural aspect ratio.\n//\n// By the way, it'd be nice to have a couple of naturally wider ratio videos to choose from. :)\n//\nvec3 getTex(vec2 p){\n    \n    // Strething things out so that the image fills up the window. You don't need to,\n    // but this looks better. I think the original video is in the oldschool 4 to 3\n    // format, whereas the canvas is along the order of 16 to 9, which we're used to.\n    // If using repeat textures, you'd comment the first line out.\n    //p *= vec2(iResolution.y/iResolution.x, 1);\n    vec3 tx = texture(iChannel0, fract(p)).xyz;\n    return tx*tx; // Rough sRGB to linear conversion.\n}\n\n// Height map value, which is just the pixel's greyscale value.\nfloat hm(in vec2 p){ return dot(getTex(p), vec3(.299, .587, .114)); }\n\n\n// Two different angles. One for each alternate checkered set.\nvec2 gAng;\n\n// Moving the extruded tiles: There are two sets split into\n// alternate checkers. There are 8 key frames.\nvoid move(){\n\n    \n    float n = mod(floor(iTime), 8.); // 8 keyframe.\n    float t = mod(iTime, 8.); // Fractional time.\n    float st = smoothstep(.3, .7, fract(t)); // Smoothing.\n\n    // Each checkered set moves differently: Rotating back and forth,\n    // or rotating by a quarter whilst stopping and resting on alternate\n    // frames. It's mostly common sense.\n    \n    // Angle one.\n    float ndiv2 = floor(n/2.);\n    if(mod(n, 2.) == 0.) gAng.x = mix(ndiv2*3.14159/2., (ndiv2 + 1.)*3.14159/2., st);\n    else gAng.x = (ndiv2 + 1.)*3.14159/2.;\n\n\n    // Angle two.\n    if(mod(floor(t), 2.)<.5){\n        gAng.y = mix(3.14159/2., 0., st);\n    }\n    else {\n        gAng.y = mix(0., 3.14159/2., st);\n    }\n       \n\n}\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h){\n    \n    vec2 w = vec2( sdf, abs(pz) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n\n    /*\n    // Slight rounding. A little nicer, but slower.\n    const float sf = .025;\n    vec2 w = vec2( sdf, abs(pz) - h - sf/2.);\n  \treturn min(max(w.x, w.y), 0.) + length(max(w + sf, 0.)) - sf;\n    */\n}\n\n\n// IQ's unsigned box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  return length(max(abs(p) - b + sf, 0.)) - sf;\n}\n\n/*\n// IQ's signed box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n   \n\n  vec2 d = abs(p) - b + sf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - sf;\n}\n*/\n\n#define SHAPE 2\n\n// Shape distance metrics. You could put whatever you feel like here.\nfloat dist(vec2 p, vec2 b){\n \n      \n      #if SHAPE == 0\n      // Square.\n      p = abs(p) - b;\n      return max(p.x, p.y);\n      #elif SHAPE == 1\n      // Diamond.\n      p = abs(p);\n      return (p.x + p.y)*.7071 - mix(b.x, b.y, .5);\n      #elif SHAPE == 2\n      // Octagon.\n      //p *= rot2(3.14159/8.);\n      p = abs(p);\n     \n      return max((p.x + p.y)*.7071, max(p.x, p.y)) - mix(b.x, b.y, .5);\n      \n      // Dodecahedron.\n      // vec2 p2 = p*.8660254 + p.yx*.5;\n      // p = vec2(max(p2.x, p2.y), max(p.y, p.x));\n      // p = abs(p) - mix(b.x, b.y, .5);\n      return max(p.x, p.y);\n      \n      \n      #else\n      // Circle.\n      return length(p) - (b.x + b.y)/2.;\n      #endif\n      \n      //p = abs(p) - b;\n      //p = p*.8660254 + p.yx*.5;\n      //return max(p.x, p.y);\n      \n      //p = abs(p)-b;\n      //p = (p + p.yx)*.7071;\n      //return max(p.x, p.y);\n}\n\n\nfloat faceDist;\n \n// A regular extruded block grid.\n//\n// The idea is very simple: Produce a normal grid full of packed square pylons.\n// That is, use the grid cell's center pixel to obtain a height value (read in\n// from a height map), then render a pylon at that height.\n\nvec4 blocks(vec3 q3){\n    \n    \n\n    // Brick dimension: Length to height ratio with additional scaling.\n\tconst vec2 l = gScale;\n    // A helper vector, but basically, it's the size of the repeat cell.\n\tconst vec2 s = l*2.;\n    \n    // Distance.\n    float d = 1e5;\n    // Cell center, local coordinates and overall cell ID.\n    vec2 p, ip;\n    \n    // Individual brick ID.\n    vec2 id = vec2(0);\n    vec2 cntr = vec2(0);\n    \n    // For block corner postions.\n    //vec2[4] ps4 = vec2[4](vec2(-l.x, l.y), l, -l, vec2(l.x, -l.y));\n    vec2[4] ps4 = vec2[4](vec2(-.5, .5), vec2(.5), vec2(.5, -.5), vec2(-.5)); \n    \n    float boxID = 0.; // Box ID. Not used in this example, but helpful.\n    \n    for(int i = 0; i<4; i++){\n\n        // Block center.\n        cntr = ps4[i]/2.;\n\n\n        // Local coordinates.\n        p = q3.xy;\n        ip = floor(p/s - cntr) + .5; // Local tile ID.\n        \n        // Correct positional individual tile ID.\n        vec2 idi = (ip + cntr)*s;\n        \n        p -= idi; // New local position.\n\n\n        // The extruded block height. See the height map function, above.\n        float h = 1.;//hm(idi);\n        \n        //h = floor(h*15.999)/15.*.1; // Or just, \"h *= .15,\" for nondiscreet heights.\n        h *= .025;\n        \n        \n            \n        // One larger extruded block.\n        //float di2D = sBoxS(p, l/2. - .0*scale, .02);\n        \n        \n        vec2 q = p;\n        \n        float t = mod(iTime, 4.);\n;\n        \n        if((i&1)==0){\n            q *= rot2(-gAng.x);\n        }\n        else {\n            q *= rot2(-gAng.y);\n        }\n        \n        //float pin = dist(q, vec2(.09*gScale.x));\n        float pin = length(q) - .08*gScale.x;\n        \n        float di2D = length(q) - (l.x/2. - .01);\n        //float di2D = dist(q, l/2. - .01);\n        di2D = max(di2D, -(max(abs(q.x - .5), abs(q.y - .5)) - .5-.01));\n        di2D = max(di2D, -(max(abs(q.x + .5), abs(q.y + .5)) - .5-.01));\n        \n        di2D = max(di2D, -pin);\n        \n        //pin = abs(pin + .02*gScale.x) - .02*gScale.x;\n        \n\n        \n           \n    \n\n        // Boring out some of the lower boxes. I like it, but thought it\n        // confused matters.\n        //if(h<1./15.*.15 + .001) di2D = max(di2D, -(di2D + .3*scale));\n\n        // The extruded distance function value.\n        float di = opExtrusion(di2D, (q3.z + h), h);\n        \n        //di -= min(-di2D*.7, .02);\n        di += di2D*.35;\n        \n        //float pat = (abs(fract(di2D*32.) - .5)*2. - .125)/32.;\n        //di -= (pat)*.1;\n        \n        \n        pin = opExtrusion(pin, (q3.z + h - .5), h + .5 + .01);\n        \n //       di = min(di,  opExtrusion(abs(di2D + .01+.002) -.01, (q3.z + h + .005), h + .005));\n        \n        // Cell object ID -- Hacked in at the last minute.\n        float cOID = di<pin? 0. : 1.;\n        di = min(di, pin);\n\n        // If applicable, update the overall minimum distance value,\n        // ID, and box ID. \n        if(di<d){\n            d = di;\n            id = idi;\n            // Not used in this example, so we're saving the calulation.\n            boxID = cOID;\n            \n            faceDist = di2D;  \n        }\n        \n    }\n    \n    // Return the distance, position-base ID and box ID.\n    return vec4(d, id, boxID);\n}\n\n\n// Block ID -- It's a bit lazy putting it here, but it works. :)\nvec4 gID;\n\n// The extruded image.\nfloat map(vec3 p){\n    \n    // Floor.\n    float fl = -p.z + .05;\n/*    \n    vec2 sc = gScale/2.*vec2(1, 1);\n    vec2 q = p.xy;// + vec2(sc.x/2.*1., sc.y/2.);\n            //if(mod(floor(q.y/sc.y), 2.)==0.) q.x += sc.x/2.;\n    vec2 iq = floor(q/sc) + .5;\n    q -= iq*(sc);\n    q = abs(q);\n    float block = max(max(q.x, q.y) - sc.x/2. + .025, abs(p.z - sc.x/8.) - sc.x/8.);\n    fl = min(fl + .04, block + (max(q.x, q.y) - sc.x/2.)/8.);\n*/\n    // The extruded blocks.\n    vec4 d4 = blocks(p);\n    gID = d4; // Distance, block ID, and cell object ID.\n    \n    \n \n    // Overall object ID.\n    objID = fl<d4.x? 1. : 0.;\n    \n    // Combining the floor with the extruded image\n    return  min(fl, d4.x);\n \n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    for(int i = min(iFrame, 0); i<80; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n        \n        //t += i<32? d*.75 : d; \n        t += d*.7; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\tconst vec2 e = vec2(.001, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\t\n                          map(p + e.yyx) - map(p - e.yyx)));\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow \n    // test machine, anyway.\n    const int maxIterationsShad = 24; \n    \n    ro += n*.0015;\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;//.0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 3., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n    \n}\n\n\n\n// Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n// example that explains it, if you require it.\nfloat n3D(in vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// Very basic pseudo environment mapping... and by that, I mean it's fake. :) However, it \n// does give the impression that the surface is reflecting the surrounds in some way.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 envMap(vec3 p){\n    \n    p *= 4.;\n    p.y += iTime/4.;\n    \n    float n3D2 = n3D(p*2.);\n   \n    // A bit of fBm.\n    float c = n3D(p)*.57 + n3D2*.28 + n3D(p*4.)*.15;\n    c = smoothstep(.45, 1., c); // Putting in some dark space.\n    \n    p = vec3(c*c*c, c*c, c); // Blueish tinge.\n    \n    return mix(p.zxy, p, n3D2); // Mixing in a bit of red.\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n    #ifdef CAM_TILT\n    vec3 ro = vec3(-.125, -.125, -2.5); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(.005, .01, .25);//vec3(0, -.25, iTime);  // \"Look At\" position.\n    #else\n    vec3 ro = vec3(0, 0, -2.5); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(0, 0, .25);//vec3(0, -.25, iTime);  // \"Look At\" position.\n    #endif\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(.25, .5, 1);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.; // FOV - Field of view.\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    //vec3 rd = mat3(rgt, up, fwd)*normalize(vec3(uv, 1./FOV));\n    #ifdef LENS_WARP\n    // Ray warping, lens warping, etc -- One of many variations.\n    rd = normalize(vec3(rd.xy, sqrt(max(rd.z*rd.z + (.5 - dot(rd.xy, rd.xy))*.5, 0.))));\n    #endif\n    \n    // Swiveling the camera about the XY-plane.\n\t//rd.yz *= rot2( sin(-3.14159/3.)/3. );\n\t//rd.xz *= rot2( sin(iTime/1.)/64. );\n\t//rd.xy *= rot2( cos(iTime/2.)/64. );\n\n    \n    // Retrieve the two angular postions of the alternating\n    // grid cell objects.\n    move();\n\t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    // Save the block distance, ID and cell object ID.\n    vec4 svGID = gID;\n    \n    float svfaceDist = faceDist;\n    \n    float svObjID = objID;\n  \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp, t);\n        \n        \n            \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 16.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n        //sh = min(sh + ao*.25, 1.);\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        //diff = pow(diff, 4.)*2.; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 32.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow(clamp(1. - abs(dot(sn, rd))*.5, 0., 1.), 2.);\n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a hard clay consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\tfloat freS = mix(.15, 1., Schlick);  //F0 = .2 - Glass... or close enough.        \n\n        \n          \n        // Obtaining the texel color. \n\t    vec3 texCol = vec3(0);   \n\n        \n        // Object: Forground or background.\n        if(svObjID<.5){\n            \n            \n            // The extruded propeller grid.\n            \n            // Coloring.\n            \n            vec2 sc = gScale;\n            vec3 q = sp;\n            vec2 iq = floor(q.xy/sc) + .5;\n            q.xy -= iq*sc;\n            int check = mod(iq.x + iq.y, 2.)<.5? 1 : 0;\n            \n            if(check==1) q.xy *= rot2(-gAng.x);\n            else q.xy *= rot2(-gAng.y);\n\n            \n            // Random value based on cell ID.\n            float rnd = (svGID.y + svGID.z)/4.;\n            \n            //rnd = floor(rnd*16.)/16.;\n            \n            #if PALETTE == 0\n            // Spectrum.\n            vec3 texCol1 = .5 + .45*cos(-rnd*6.2831 + vec3(0, 1, 2)*2. - 2.15);\n            #elif PALETTE == 1\n            // Golden brown.\n            vec3 texCol1 = .5 + .45*cos(-rnd*6.2831/4.5 + vec3(0, 1, 2) + .35);\n            #elif PALETTE == 2\n            // Green and blue.\n            vec3 texCol1 = .5 + .45*cos(-rnd*6.2831/4.5 + vec3(0, 1, 2) + .35);\n            if(check == 1) texCol1 = texCol1.zyx;\n            else texCol1 = texCol1.yxz;//vec3(dot(texCol1, vec3(.299, .587, .114)));\n            //if(check == 1 && q.x>q.y) texCol1 = texCol1.yxz;\n            //if(check == 0 && q.x>q.y) texCol1 = texCol1.yxz;\n            #elif PALETTE == 3\n            // Blinking earthtone quarter colors.\n            vec2 iq2 = iq;\n            if(q.x>0.) iq2 += 1./2.;\n            if(q.y<0.) iq2 += 1./4.;\n            rnd = hash21(iq2);\n            float rnd2 = hash21(iq2 + .13);\n            vec3 texCol1 = .5 + .45*cos(-rnd*6.2831/3. + vec3(0, 1, 2) + 1.65);\n            texCol1 = mix(texCol1, mix(texCol1.xzy, texCol1, .25), \n                          smoothstep(.8, .9, sin(rnd2*6.2831 + iTime*2.)*.5 + .5));\n            #elif PALETTE == 4\n            // Mondrian.\n            vec3 texCol1 = vec3(.7);\n            if(check == 1 && q.x<q.y) texCol1 = vec3(1, .07, .06);\n            if(check == 1 && q.x>q.y) texCol1 = vec3(0, .5, 1);\n            if(check == 0 && q.x>q.y) texCol1 = vec3(1, .9, .1);\n            /*\n            // Alternative.\n            vec3 texCol1 = vec3(.7);\n            vec2 qID = mod(floor(svGID.yz*2.), 2.);\n            if(qID.x == 1. && qID.y == 0.) texCol1 = vec3(1, .07, .06);\n            if(qID.x == 0. && qID.y == 1.) texCol1 = vec3(0, .5, 1);\n            if(qID.x == 1. && qID.y == 1.) texCol1 = vec3(1, .9, .1);\n            */\n            #else\n            // White.\n            vec3 texCol1 = vec3(.65);\n            #endif\n             \n            // The outer propellor rim color.\n            vec3 texCol2 = mix(vec3(1.5), texCol1, dot(texCol1, vec3(.299, .587, .114)));//tx/1.5;//\n            #if PALETTE == 4\n            texCol2 = vec3(.85);\n            #endif\n     \n            // Applying the texture, if defined.\n            #ifdef TEXTURE\n            vec3 tx = tex3D(iChannel0, vec3(q.xy + iq/2. - .125, q.z)/2., sn);\n            tx = smoothstep(-.1, .5, tx);\n            texCol1 = mix(texCol1, texCol1*tx*1.75, .65);\n            texCol2 = tx;\n            #endif\n            \n            // Setting the outer and inner propellor colors.\n            if(svGID.w == 1.) texCol = texCol2;\n            else texCol = texCol1;\n\n            \n            \n           \n        \n            // Constructing the dark propeller edge markings.          \n            float ht = 1.;//hm(svGID.yz);\n            vec2 lCoord = sp.xy - svGID.yz;\n            sc = gScale;\n            float lw = gScale.x*.06;//.05;\n            float dS = abs(svfaceDist) - lw;\n\n            // Tapering the sides, or not.\n            #ifndef SIDES\n            dS = max(dS, abs(sp.z + ht*.025*2.) - lw); // Just the rim.\n            #endif\n            \n\n            \n            if(svGID.w == 0.){\n                // Rendering the propeller colors and dark edge markings. \n                texCol = mix(texCol, vec3(0), (1. - smoothstep(0., .005, dS))*.95);\n                texCol = mix(texCol, texCol2*.7, (1. - smoothstep(0., .005, dS + .015)));\n            }\n            else {\n                // Inner markings.\n                float cir = length(lCoord) - lw/2.  -.005;\n                texCol = mix(texCol, vec3(0), (1. - smoothstep(0., .007, cir)));\n                texCol = mix(texCol, texCol2, (1. - smoothstep(0., .007, cir + .015)));\n            }\n              \n           \n \n        }\n        else {\n            \n            // The dark floor in the background.\n            //\n            // Scaling, ID and local square cell coordinates.\n            vec2 sc = gScale/2.*vec2(1, 1);\n            vec2 q = sp.xy;// + vec2(sc.x/2.*1., sc.y/2.);\n            //if(mod(floor(q.y/sc.y), 2.)==0.) q.x += sc.x/2.; // Brickwork.\n            vec2 iq = floor(q/sc) + .5;\n            q -= iq*(sc);\n            \n            // Two square samples for bump mapping purposes. In case it isn't obvious,\n            // this is a very cheap and hacky procedure, but it's good enough.\n            float sq = max(abs(q.x) - sc.x/2., abs(q.y) - sc.y/2.);\n            vec2 ld2 = normalize(ld.xy);\n            float sq2 = max(abs(q.x + ld2.x*.01) - sc.x/2., abs(q.y + ld2.y*.01) - sc.y/2.);\n            float bord = abs(sq) - .005;\n            bord = abs(bord - .015) - .005;\n            \n            float b = max((sq2 - sq)/.01, 0.); // Bump value.\n            texCol = vec3(.05);\n            #ifdef BUMP_BG\n            texCol += b*b*.05; // Adding the bump value.\n            #endif\n            // Extra bordering.\n            texCol = mix(texCol, texCol*2., (1. - smoothstep(0., .005*4., bord)));\n            texCol = mix(texCol, texCol/8., (1. - smoothstep(0., .005, bord)));\n            \n            // If the texture is set, apply it.\n            #ifdef TEXTURE\n            vec3 tx = getTex(sp.xy/3.);\n            tx = smoothstep(-.1, .55, tx);\n            texCol *= tx*2.;\n            #endif\n            \n        }\n        \n        // Greyscale values.\n        #ifdef GRAYSCALE\n        texCol = vec3(1.1, .95, .8)*dot(texCol, vec3(.299, .587, .114));\n        #endif\n        \n        \n        // Ramping up the diffuse values, depending on what part of the scene we've hit.\n        vec2 sc = gScale;\n        float lw = gScale.x*.06;\n        float dS = abs(svfaceDist) - lw;\n        \n        #ifdef METALLIC\n        \n        if(svObjID == 0.){\n           // Outer and inner propeller diffuse values.\n           diff = mix(diff, pow(diff, 4.)*1.5, 1. - smoothstep(0., .005, dS));\n           if(svGID.w == 1.) diff = pow(diff, 4.)*1.5;\n           //diff = pow(diff, 4.)*1.5;\n        }\n        else {\n           // Making the dark background more metallic.\n           diff = pow(diff, 6.)*2.35;\n        }\n        #endif\n        \n        \n        \n        \n        // Combining the above terms to procude the final color.\n        col = texCol*(diff*sh + .3 + vec3(.25, .5, 1)*fre*0. + vec3(1, .97, .9)*spec*freS*2.*sh);\n\n        \n        #ifdef ENVIRONMENT\n        // Fake environment mapping.\n        vec3 cTex = envMap(reflect(rd, sn));\n        \n        if(svObjID == 0.){\n            // Adding more environment lighting to the out propeller.\n            col = mix(col + (col)*cTex*2., col + (col)*cTex*6., 1. - smoothstep(0., .005, dS));\n        }\n        else col = col + (col)*cTex*2.; // Just a bit of environment lighting to the background.\n        #endif\n        \n        // Shading.\n        col *= ao*atten;\n        \n        // Debug AO, shadows, etc.\n        //col = vec3(ao);\n\t\n\t}\n    \n    \n    // Rought gamma correction.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n\t\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssyXDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1880, 1913, 1935, 1935, 1993], [1996, 2024, 2045, 2045, 2108], [2110, 2190, 2236, 2236, 2800], [2804, 3051, 3071, 3448, 3552], [3554, 3618, 3638, 3638, 3687], [3765, 3872, 3884, 3884, 4587], [4589, 4616, 4673, 4673, 4979], [4982, 5012, 5059, 5059, 5110], [5306, 5376, 5403, 5403, 6253], [6274, 6530, 6551, 6634, 9792], [9871, 9894, 9912, 9931, 10595], [10599, 10620, 10656, 10705, 11176], [11179, 11279, 11315, 11315, 11499], [11502, 11693, 11745, 11870, 13190], [13193, 13345, 13381, 13381, 13635], [13639, 13782, 13803, 13803, 14149], [14151, 14450, 14470, 14470, 14802], [14805, 14805, 14861, 14894, 26182]]}
{"id": "ssyXzR", "name": "Image horizontal transition", "author": "therepo90", "description": "For some reason doesnt work on mac for now.\nHold mouse left button and swipe horizontally\n", "tags": ["transition"], "likes": 2, "viewed": 45, "published": "Public", "date": "1634249670", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float PI=3.141592653589;\n\nvoid addLight(float t,out vec3 col, vec2 mouse, float offset1, vec2 uv, vec3 barCol, float yOffset){\n    vec3 lightCol=mix(vec3(1.,1.0,1.0),barCol,0.3);\n    float lightY=0.1+(yOffset - t*0.1);//1.-mod(t*0.1+yOffset, 1.2)-yOffset+0.1;\n    lightY=1.-mod(1.-lightY,1.1);\n    \n    float lightDst = distance(vec2(mouse.x-offset1,lightY),vec2(uv));\n    float r = abs(sin(t*2.+yOffset*t*2.))*0.03+0.06;\n    float lightF=smoothstep(r,0.,lightDst);\n    col=mix(col,lightCol,lightF*1.5);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    vec3 col=vec3(0);\n    float thk=0.01;\n    vec3 col1=texture(iChannel0, uv).xyz;\n    vec3 col2=texture(iChannel1, uv).xyz;\n    //vec3 col1=vec3(0.);\n    //vec3 col2=vec3(1.);\n    vec3 barCol=vec3(0,1.0,1.0);\n    float t = iTime;\n    //t=0.;\n    float offset1=sin(uv.y*PI*4.+t*7.)*0.005;\n    offset1+=-cos(uv.y*PI*8.+t*3.)*0.007;\n    offset1+=cos(uv.y*PI*8.+t*3.)*0.007 * cos(4.+uv.y*PI*3.+t*6.);//\n    //offset1+=-sin(PI+uv.y*PI*13.+t*4.)*0.002;//\n    //offset1+=-cos(7.+uv.y*PI*13.+t*14.)*0.003*sin(3.+uv.y*PI*3.+t*4.);//\n    //float offset2=0.;//abs(sin(2.+uv.y*PI*14.))*0.015;\n    float edgeCloseFactor = smoothstep(mouse.x-thk-offset1-0.03,mouse.x-offset1,uv.x);\n    float barFactor = edgeCloseFactor* smoothstep(mouse.x+thk-offset1,mouse.x-offset1, uv.x);\n    \n    \n    \n    col=mix(col1,col2,step(mouse.x-offset1, uv.x));\n    col=mix(col,barCol,barFactor);\n    \n    //addLight(t, col, mouse, offset1, uv, barCol,1.0);\n    //addLight(t, col, mouse, offset1, uv, barCol,0.4);\n    //addLight(t, col, mouse, offset1, uv, barCol,0.);\n    \n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssyXzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 126, 126, 505], [506, 506, 563, 613, 1837]]}
{"id": "ssyXzy", "name": "AngularSeg", "author": "spalmer", "description": "working on optimizing my angular pill function based on cross products", "tags": ["cross", "segment", "pill", "capsule", "golf"], "likes": 4, "viewed": 71, "published": "Public", "date": "1634832688", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// computes a perspective-corrected form of distance\n// to a 3d line segment, but, uh, angularly?\n\n// if you want to understand the theory behind this,\n// first grok Angular Distance https://shadertoy.com/view/sdGXzK\n\n// another simple example of use is\n// Angular Tetrahedra at https://shadertoy.com/view/7sGXRV\n\n// view/query vector d assumed unit length throughout\n\n// I figure it's good for simple line drawings\n// or for use as a bounding shape intersection test\n\n// this is a really old HACK of mine\n// just cleaned up and golfed a bit.\n// calculated \"angularly\" with cross products.  Bizarre.\n// it's weird and midpoint-y and I'm unsure even I\n// understand how it works, completely.  \n// But it's equivalent to angularSeg2!\n/*float angularSeg(vec3 d, vec3 a, vec3 b)\n{\n    vec3 x = cross(d, (b + a) * .5)\n\t, m = (cross(d, a) - cross(d, b)) * .5;\n    return length(x - m * clamp(dot(x, m) / dot(m, m), -1., 1.));\n}*/\n\n// the perspective is still fake as heck,\n// well actually it's, like, accurate,\n// based on what I tested over in Angular Distance.\n// and there seems to be some sort of visual\n// bend or kink in the shape near where\n// I approx the center distance.  But I think that\n// is simply bad gamma correction on the linear ramp!\n// cross followed by length takes perpendicular distances\n// which is basically what we're after, so\n// seems what I have done is implement a screwball form\n// of 3d segment distance, but in this cross-d space.\n\n// want to hear something really bizarre?\n// I get the same image using angularSeg\n// as I do using angularSeg2!  which both\n// validates that this \"works\", I guess, but\n// also that angularSeg was in fact computing the actual distance somehow?\n// because this is computing distance.\n// it's been so long since I made the original I forgot\n// precisely how it worked in the first place,\n// but that must have been how I got there originally.\n// just via different construction...\n// moved the segment calculation into the cross-d space relative origin.\n// iirc I started with a simple angularly-computed disc\n// then noticed \"hey, I can make this perspective corrected\n// by removing a sqrt\" and wound up with Angular Distance\n// then later was fiddling with 3d line vs. line stuff\n// and merged the techniques together.  I did\n// infinite \"rods\" first then later learned how to make\n// segments, then I shifted to the midpoint parameterization\n// to make \"swept dots\" for like fake motion blur.\n// Anyway I think I sorted it back out now to simple segments.\n\n/*float angularSeg2(vec3 d, vec3 a, vec3 b)\n{\n    // a completely different idea, simpler even.\n    // project the 2 points to 2d along the infinite line d\n    // looking down d, the 2d coordinate system is the distances we want\n    // must transform everything d relative\n    // all this transformation will wind up making algo too big though.\n    // transform into a 2d segment problem with d as the origin\n    // it seems it would be far easier to construct an\n    // orthogonal basis to d first, then the transformation would be simple.\n    // there's various ways could do that, simpler is better\n    // if d is +Z, unit length, we need +X and +Y\n    vec3 u = d.yzx; u.z = -u.z; //vec3 u = d.zxy; u.x = -u.x; //\n    vec3 v = normalize(cross(u, d)); u = cross(d, v); // being more careful than I usually am here\n    //vec3 v = normalize(cross(d, u)); // because usually I would assume u is already unit length and perpendicular to d - doesn't work though\n    \n    vec2 a2 = vec2(dot(a, u), dot(a, v)), b2 = vec2(dot(b, u), dot(b, v));\n    // now it's a 2d segment problem, can use iq's traditional segment distance formula\n    // one problem is that's usually posed relative to a; I have relative to q\n    //argh, just go back to that way\n    vec2 q2 = -a2; b2 -= a2;\n    // do 2d segment calculation iq way to find nearest point on segment to origin\n    return length(q2 - b2 * clamp(dot(b2, q2) / dot(b2, b2), 0., 1.));\n    // now perspective project that distance by the distance along the view ray\n    // wait!! already done somehow by the above.  I mean, it looks correct already!\n    // before I proceed, I should somehow determine how the heck I\n    // managed to get the perspective effect, without any division by distance.\n}*/\n    // or I can keep going or try different ways\n\n// SURELY that can be simplified!\n// in fact I'm sure if I simply fed it all into Maxima,\n// that it would just spit out the reduced equation.\n\n// tried this morning when I had coffee and still failed!\n\n// BUT I had a breakthrough and now\n// one of the 0.5 kludges has been removed\n/*\nfloat angularSeg3(vec3 d, vec3 a, vec3 b)\n{\n    vec3 x = cross(d, (b + a) * .5)\n\t, m = cross(d, a) - cross(d, b); // removing .5 here doubles length of segment! don't want that.  So must cancel out some other way\n    return length(x - m * clamp(dot(x, m) / dot(m, m), -.5, .5)); // oh, DUH!  how easy is that!\n}\n*/\n// my main goal is to simply\n// remove the midpoint stuff from angularSeg\n// and bias it such that the clamp works 0..1 instead of -1..1\n// that should eliminate some work and simplify things\n// so that it only involves the endpoints\n/*\nfloat angularSeg4(vec3 d, vec3 a, vec3 b)\n{\n    vec3 x = cross(d, a), m = x - cross(d, b);\n    return length(x - m * clamp(dot(x, m) / dot(m, m), .0, 1.));\n}\n*/\n// oh, come on!  It can't be that easy.  Surely someone has done this before!\n\n// some day I must go back and properly clean up these 1 letter local variable identifiers!\n\nfloat angularSeg5(vec3 d, vec3 a, vec3 b)\n{\n    a = cross(d, a), b = cross(d, b);\n    vec3 m = b - a;\n    m = mix(b, a, clamp(dot(b, m) / dot(m, m), .0, 1.)); \n    return length(m);\n}\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    vec2\n      r = iResolution.xy\n    , q = (p - .5*r) / r.y;    \n    vec3\n      d = normalize(vec3(q, 1)) * mat3(1,0,0, 0,.866,-.5, 0.,.5,.866)\n    , e = vec3(0,1.7,-4)\n    , a = vec3(2.*sin(vec2(0,11) + .3*iTime), 0).xzy\n    , b = -a\n    ;\n    a -= e; b -= e;\n    // angularSeg4 inlined:\n    //vec3 x = cross(d, a)\n\t//, m = x - cross(d, b);\n    //float g = length(x - m * clamp(dot(x, m) / dot(m, m), 0., 1.));\n\t//float g = angularSeg(d, a, b);\n    //float g = angularSeg2(d, a, b);\n    //float g = angularSeg3(d, a, b);\n    //float g = angularSeg4(d, a, b);\n    float g = angularSeg5(d, a, b);\n    o = vec4(g); //pow(g, .5));\n}\n\n    // dots at endpoints for debugging, both crap\n    //o.r += pow(dot(d,a)/length(a), 5e3);\n    //o.g += pow(dot(d,b)/length(b), 5e3);\n    //o.r += 1.-min(1., .2 * r.y * length(cross(d,a)) / length(a));\n    //o.g += 1.-min(1., .2 * r.y * length(cross(d,b)) / length(b));   ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssyXzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[5388, 5481, 5524, 5524, 5664], [5666, 5666, 5702, 5702, 6333]]}
{"id": "st3GRr", "name": "octtree truchet", "author": "flockaroo", "description": "multiscale octtree truchet", "tags": ["truchet", "multiscale", "octtree"], "likes": 30, "viewed": 433, "published": "Public API", "date": "1635594250", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// created by florian berger (flockaroo) - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// 3D-generalization of multi-scale-truchets (Octtree truchet)\n//\n// ...like Shanes 2D version (not sure, but i think he did it first in 2D)\n// \"Quadtree Truchet\" https://www.shadertoy.com/view/4t3BW4\n//\n// wasnt sure if it works visually in 3D - kind of crowded, but i like it a lot...\n// different regions with different truchet-scale can easily be seen.\n//\n// golfed it down, but i guess there's still potential...\n//\n// also here a (only single-scale) version on twigl in under 1 tweet:\n// https://twitter.com/flockaroo/status/1454405159224754184\n\n//my original version:\n//\n//#define Res iResolution.xy\n//#define ROT(v,x) v=mat2(cos(x),sin(x),-sin(x),cos(x))*v;\n//#define R(p) cos(((p)+(p).zxy*1.1+(p).yzx*1.3)*10.)\n//#define L(n,c) for(int i=0;i<n;i++){c;}\n//#define t iTime\n//\n//#define dd(X,p2) \\\n//{ \\\n//    vec3 p=p2; \\\n//    p+=R(p*.3)*.05; float l,d=1e3,s=2.; \\\n//    vec3 q,r; \\\n//    L(4,s*=.5;q=floor(p/s)*s;r=R(q);if(r.x<.5) break) \\\n//    p=((p-q)/s-.5)*sign(r); s*=8.; \\\n//    L(3,l=length(p.xy+.5)*s; d=min(d,length(vec2(l-(min(floor(l),s-1.)+.5),(fract(p.z*s+.5*s)-.5)))/s); p.zxy=p*vec3(-1,-1,1) ) \\\n//    X+=(d*s/8.-2e-3)*.6; \\\n//}\n//\n//void mainImage( out vec4 C, in vec2 FC )\n//{\n//    vec3 p,d=vec3((FC-Res*.5)/Res.x*2.,-.7);\n//    ROT(d.yz,t*.2);\n//    ROT(d.xy,t*.07);\n//    p=vec3(7,2,1)*t/1e2;\n//    float x=0.;\n//    L(200,dd(x,p+d*x))\n//    C=-C+1.-exp(-x/3.);\n//    C.w=1.;\n//}\n\n// wow!! fabrices take with 548 chars:\n//\n//#define R2(a)  mat2(cos( iTime*a +vec4(0,33,11,0)))\n//#define H(p)   cos( p/.1 +p.zxy*11. + p.yzx*13. )\n//#define L(n)   for( int i=0 ; i++ < n ; )\n//\n//void mainImage( out vec4 C, vec2 U )\n//{\n//    vec3 R = iResolution,\n//         P = vec3(7,2,1) * iTime/1e2, q,r,p,\n//         D = vec3( ( U+U - R.xy ) / R.x, -.7 );\n//    D.yz *= R2(.2);\n//    D.xy *= R2(.07);\n//  \n//    float x=0.,l,d,s;\n//    L( 200 ) { \n//        p = P+D*x;\n//        p += H(.3*p)*.05;\n//        d=1e3; s=2.; r=R/R;\n//        L( 4 && r.x>.5 ) { s*=.5; q = floor(p/s)*s; r = H(q); }\n//        p = ( (p-q)/s - .5 ) * sign(r);\n//        s *= 8.;\n//        L( 3 ) { \n//           l = length(p.xy+.5)*s;\n//           d = min(d, length(vec2( l - min(floor(l),s-1.) , \n//                                   fract(p.z*s+.5*s) ) -.5\n//                            ) /s);\n//           p.zxy = p * vec3(-1,-1,1) ;\n//        }\n//        x += d*s*.075 -1.2e-3 ;\n//    }\n//    C = 1.-C-exp(-x/3.);\n//}\n\n//!!!and even smaller Xor with 539 chars:\n//(and i took another 11 off by (sloppily) replacing the exp by a linear fog\n// and using fabrices loop condition) - so now 526 chars:\n// ...and a lot of fabrice changes added!\n#define A    mat2( cos(vec4(0,33,11,0)+t*//\n#define R(p) cos( p/.1+p.zxy*11.+p.yzx*13. )//\n#define L(n) for(int i=0; i++<n;)\n\n\nvoid mainImage(out vec4 C, vec2 F)\n{\n    float t = iTime,l,D,s;C-=C;\n    vec3 R = iResolution,\n    d = vec3((F+F-R.xy)/R.x,-.7),\n    p = vec3(7,2,1)*t/1e2,P,q,r;\n    \n    d.yz *= A .2));\n    d.xy *= A .07));\n    \n    L(200)\n    {\n        P = p+d*C.x*3.;\n        P += R(.3*P)*.05;\n        l = D = 1e3, s = 2., r=R;\n        \n        L(4 && r.x>.5)\n            s *= .5,\n            q = floor(P/s),\n            r = R(s*q);\n        \n        P = (P/s-q-.5)*sign(r); s*=8.;\n        \n        L(3)\n            D = min(D,length(.5-vec2(min(ceil(l=length(P.xy+.5)*s),s)-l,fract(P.z*s+.5*s)))/s),\n            P.zxy=P,P.zx*= -1.;\n        \n        C += D*s*.025-4e-4;\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st3GRr.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[2553, 2899, 2935, 2935, 3560]]}
{"id": "stcGRH", "name": "Persian carpet 7", "author": "jarble", "description": "A Persian carpet fractal pattern.", "tags": ["fractal", "carpet", "rug"], "likes": 4, "viewed": 166, "published": "Public API", "date": "1635688861", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//change these constants to get different patterns!\n#define c2 1.5\n\n#define c1 vec4(1.0+c2,.5+c2,-1.5,0)\n\n//to do: drag and drop using https://www.shadertoy.com/view/WdGGWh\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   //from David Hoskins' \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    \n\n    \n    vec3 col;  \n    float t1 = 4.5*3./2.;\n    float t = 45.87+iTime/2.;\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/128.0/2.;\n    uv += vec2(t/2.0,t/3.0)/t1/128.0/4.;\n    //vec3 random1 = hash31(floor((iTime)/10.0+uv.x))*10.*.0;\n    float t2 = floor((t+4.)/20.0+uv.x);\n    //vec3 random2 = hash31(1.+t2);\n    \n    \n    float offset = -.05;\n    \n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        float t3 = float(c)+t2;\n\n        for(int i=0;i<3;i++)\n        {\n            vec3 col_prev = col;\n            float factor = .7;\n            float factor1 = 8.;\n            \n            uv = -triangle_wave(uv.yx+scale,scale)+triangle_wave(uv,scale);\n            //uv.y /= .9;\n            uv.x *= factor;\n            for(int j = 0; j < 3;j++){\n                uv = triangle_wave((uv*(1.+offset)),scale);\n            }\n            uv.x /= -factor;\n            \n            if(i>0) col = abs(col.yzx*col.x + col_prev*col.y)/(col.x-col.y);\n            \n            col[c] = fract((uv.x*(1.+col.x/factor1))-(uv.y*(col.y/factor1+1.)));\n        }\n    }\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stcGRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[175, 285, 307, 352, 485], [487, 487, 526, 526, 571], [573, 573, 630, 630, 1788]]}
{"id": "std3Rr", "name": "Yet More Another Voronoi", "author": "tkasch", "description": "Made by this awesome tutorial https://www.youtube.com/watch?v=l-07BXzNdPw&ab_channel=TheArtofCode", "tags": ["voronoi"], "likes": 3, "viewed": 52, "published": "Public", "date": "1635634940", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 N22(vec2 p)\n{\n    vec3 a = fract(p.xyx * vec3(123.34, 234.34, 345.65));\n    a += dot(a, a + 34.45);\n    return fract(vec2(a.x*a.y, a.y*a.z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n    \n    float m = 0.0;\n    float t = iTime *0.2;\n    \n    float minDist = 100.0;\n    float cellIndex = 0.0;\n        \n    vec3 col = vec3(0);\n    \n    if(false){    \n    for(float i=0.0; i < 50.0; i++)\n    {\n        vec2 n = N22(vec2(i));\n        vec2 p = sin(n*t);\n        \n        float d = length(uv - p);\n        m += smoothstep(0.02, 0.01, d);\n        \n        if(d < minDist)\n        {\n            minDist = d;\n            cellIndex = i;\n        }\n    }\n    }else{\n        uv *= 3.0;\n        vec2 gv =fract(uv) - 0.5;\n        vec2 id =  floor(uv);\n        vec2 cid = vec2(0);\n        \n        for(float y=-1.0; y<=1.0;y++)\n            for(float x=-1.0; x<=1.0; x++)\n            {\n                vec2 offs = vec2(x,y);\n                \n                vec2 n = N22(id + offs);\n                vec2 p = offs + sin(n*t) * 0.5;                \n                p -= gv;\n                float ed = length(p);\n                float md = abs(p.x) + abs(p.y);\n                float d = mix(ed, md, sin(iTime)*0.5 + 0.5);\n                \n                 if(d < minDist)\n                {\n                    minDist = d;\n                    cid = id + offs;\n                }\n            }\n            \n         col = vec3(minDist);\n         \n    }\n    \n\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/std3Rr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 148], [150, 150, 207, 207, 1557]]}
{"id": "stt3zr", "name": "Blobs in circle", "author": "Raffa", "description": "My first shadertoy shader", "tags": ["blob"], "likes": 1, "viewed": 24, "published": "Public", "date": "1635640313", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float x0 = (sin(iTime) + 1.0) / 2.0;\n    float y0 = (cos(iTime) + 1.0) / 2.0;\n    \n    float x1 = (sin(-iTime) + 1.0) / 2.0;\n    float y1 = (cos(-iTime) + 1.0) / 2.0;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 blob0 = vec2(x0, y0);\n    vec2 blob1 = vec2(x1, y1);\n    \n    uv.y /= aspect;\n    blob0.y /= aspect;\n    blob1.y /= aspect;\n    \n    float sum = 0.0;\n    \n    sum += (1.0 / sqrt(pow(blob0.x - uv.x, 2.0) + pow(blob0.y - uv.y, 2.0))) * 0.05;\n    sum += (1.0 / sqrt(pow(blob1.x - uv.x, 2.0) + pow(blob1.y - uv.y, 2.0))) * 0.05;\n\n    // Output to screen\n    vec3 color = vec3(sum - 1.5, sum - 3.0, sum);\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stt3zr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 812]]}
{"id": "tddyDr", "name": "PerlinNoiseEffect", "author": "celns", "description": "PerlinNoise", "tags": ["perlinnoise"], "likes": 0, "viewed": 51, "published": "Public API", "date": "1635473525", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Hash2D based on: http://www.shadertoy.com/view/4djSRW\n\nvec2 Hash2D(vec2 p)\n{\n \tp = vec2( dot(p, vec2(127.1, 311.7)),\n              dot(p, vec2(269.5, 183.3)));\n    return  -1.0 + 2.0 * fract(sin(p)*43758.5453123);\n}\n\nfloat PerlinNoise2D(vec2 seed)\n{\n    vec2 intFloorValue = floor(seed);\n    vec2 intCeilValue = ceil(seed);\n    vec2 fractValue = fract(seed);\n    \n    //vec2 interValue = smoothstep(0.0, 1.0, fractValue);\n    vec2 interValue = fractValue*fractValue*fractValue*(fractValue*(fractValue*6.0-15.0)+10.0);\n    \n    return mix(mix(dot(Hash2D(intFloorValue), fractValue),\n                   dot(Hash2D(intFloorValue + vec2(1.0, 0.0)), fractValue - vec2(1.0, 0.0)),\n                   interValue.x),\n               mix(dot(Hash2D(intFloorValue + vec2(0.0, 1.0)), fractValue - vec2(0.0, 1.0)),\n                   dot(Hash2D(intCeilValue), fractValue - vec2(1.0, 1.0)),\n                   interValue.x),\n               interValue.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    uv+=0.5;\n    \n    float scaler = 10.;\n\tuv *= 2. * scaler;\n    \n    float amp = 50.;\n    uv.x+=sin(iTime);\n    uv.y+=cos(iTime);\n    \n\n    float value = PerlinNoise2D(uv+iTime);\n    \n    vec3 col = vec3(0.);\n    if(uv.y < scaler*1.5)\n    {\n        col = vec3(1.0/value);\n    }\n    else if(uv.y < scaler* 2.0)\n    {\n        col = vec3(uv.x +uv.y+1.0/value);\n    }   \n    else if(uv.y < scaler* 2.5)\n    {\n        \n        col = vec3(tan(1.0/value));\n    }\n    else\n    {\n        col = vec3(value * 0.5 + 0.5);\n    }\n    \n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tddyDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 57, 78, 78, 217], [219, 219, 251, 251, 944], [947, 947, 1004, 1054, 1721]]}
{"id": "tlfXR8", "name": "Mandala Playground", "author": "xx3000", "description": "Having some fun with polar coordinates.\nClicking + moving the mouse causes some interesting changes to the patterns.", "tags": ["polarcoordinates"], "likes": 4, "viewed": 52, "published": "Public", "date": "1634904312", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\n\n#define REFLECTION_PLANES 6.0\n\n// cosine based palette, by iq\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 smoothTransition(vec3 a, vec3 b, vec3 c, float t)\n{\n    float p = fract(t);\n    int id = int(mod(t, 3.0));\n    \n    vec3 outCol = vec3(0,0,0);\n    switch (id)\n    {\n        case 0:\n            outCol = mix(a,b,smoothstep(0.0,1.0,p));\n            break;\n        case 1:\n            outCol = mix(b,c,smoothstep(0.0,1.0,p));\n            break;\n        case 2:\n            outCol = mix(c,a,smoothstep(0.0,1.0,p));\n            break;\n    }\n    \n    return outCol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float line = 0.5;\n    float yshift = 0.0;  //0.2\n    float xshift = 0.3; //0.5 //0.05\n    \n    vec3 white = vec3(1.0,1.0,1.0);\n    \n    vec2 uv = fragCoord/iResolution.y;\n\n    vec3 col = vec3(1.0,1.0,1.0);\n    \n    \n    {\n        uv -= vec2(0.5*iResolution.x/iResolution.y,0.5);\n\n\n        float centerrepeat = 2.0*PI/REFLECTION_PLANES;\n\n        float repeat = 2.0;\n\n        vec2 ipol = vec2(atan(uv.y,uv.x),length(uv));\n\n        ipol.x = abs(mod(ipol.x,centerrepeat)-centerrepeat*0.5);\n\n        uv = vec2(ipol.y*cos(ipol.x),ipol.y*sin(ipol.x));\n\n        vec4 bg1= vec4(palette((1.0-(ipol.y)+iTime*0.25),vec3(0.8, 0.5, 0.4),vec3(0.2, 0.4, 0.2),vec3(2.0, 1.0, 1.0),vec3(0.00, 0.25, 0.25)),1.0);\n\n        uv*=7.0;    \n\n        uv+=vec2(-iTime*xshift,iTime*yshift);\n\n        uv.x= abs(mod(uv.x,repeat)-repeat*0.5);\n\n        uv.y= abs(mod(uv.y,repeat)-repeat*0.5);\n\n        vec2 coord = vec2(uv.y,uv.x);\n        vec2 polar = vec2(atan(uv.y,uv.x),length(uv));\n\n        coord = mix(coord, polar,sin(iTime)*0.5+0.5);\n\n        vec3 pre1 = vec3(1.0,1.0,1.0)*polar.y*0.2;\n        vec3 pre2 = palette((1.0-(polar.y)+iTime*0.05),vec3(0.2, 0.2, 0.2),vec3(0.5),vec3(2.0, 1.0, 1.0),vec3(0.00, 0.33, 0.67));\n\n        float res = sin(6.0*coord.x+iTime*1.0) * (iMouse.x/iResolution.x) + (3.0 * iMouse.y/iResolution.y);\n            \n        vec3 col1 = mix(bg1.xyz,pre1,abs(abs(res-coord.y)-line));\n        vec3 col2 = mix(bg1.xyz,pre2,abs(abs(res-coord.y)-line));\n        vec3 col3  = texture( iChannel0, col1.x * 0.12 + coord*0.15 ).xyz;\n        col = smoothTransition(col1,col2, col3,iTime * 0.2);\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlfXR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 85, 157, 157, 200], [202, 202, 258, 258, 667], [669, 669, 726, 726, 2355]]}
{"id": "tscBRM", "name": "colors_001", "author": "catafest", "description": "test normalize", "tags": ["normalize"], "likes": 2, "viewed": 87, "published": "Public API", "date": "1633168271", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nfloat add_Plane( vec3 p )\n{\n\treturn p.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = ((fragCoord)-iResolution.xy)/iResolution.y+1.0;\n    vec3 col =  normalize( vec3(p,cos(iTime)));\n    float a = add_Plane(col);\n    // Time varying pixel color\n    vec3 col2 = normalize(vec3(a*cos(iTime)/iTime*a-col));\n    vec3 col3 = normalize(vec3(col*a/cos(iTime+col2)));\n    // Output to screen\n    fragColor = vec4(col3,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tscBRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 94, 94, 109], [111, 111, 168, 218, 602]]}
{"id": "WdcyzN", "name": "SpaceToy_RotatingPetals", "author": "SpaceToy", "description": "Rotating petals using cos/sin and smoothstep", "tags": ["rotatingpetals"], "likes": 0, "viewed": 15, "published": "Public", "date": "1634905780", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Default background color\n    vec4 color = vec4(1.0, 0.5, 0.0, 0.0); //orange\n    \n    // Define the center\n    vec2 center = vec2(0.5, 0.5);\n    \n    // Distance of a normalized pixel coordinate from the center\n    vec2 gradient = uv - center;\n    \n    // Default radius for a circle\n    float radius = 0.2;\n    \n    // Number of petals to generate from a circle\n    float numPetals = 4.0;\n    \n    // Radius of circle changed based on the cos function for which angle\n    // is defined by number of petals multiplied by angle projected by a pixel to\n    // the center of the screen defined above\n    // iTime is used to make the petals rotate, add iTime for clockwise,\n    // subtract it to get anti-clockwise rotation\n    float changingRadius = radius * cos(iTime + numPetals * atan(gradient.y, gradient.x));\n\n    // A constant value of smooth function will never give us a circle\n    // float changingSmoothValue = 1.0;\n    \n    // This is what will give us a black circle around the center of the screen\n    // The smootstep function will interpolate a value for pixels within the two edges\n    // and the source value is defined by the length of th gradient.\n    float smoothValue = smoothstep(changingRadius, changingRadius+0.001, length(gradient));\n\n\n    // Multiply smoothness with color\n    color *= smoothValue;\n    \n    // Time varying pixels, dont do this to have static color background \n    color *= 1.0 + 0.5*sin(iTime+uv.xyxx);\n    \n    // Output to screen\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdcyzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 106, 1652]]}
{"id": "WdtyzN", "name": "SpaceToy_PalmTree", "author": "SpaceToy", "description": "Create palm tree and background changes with time, kind of from dark to dawn and daylight to dusk to dark.", "tags": ["palmtree"], "likes": 0, "viewed": 15, "published": "Public", "date": "1634905829", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Default background color\n    vec4 color = vec4(0.7, 0.5, 0.0, 0.0); //orange\n    \n    // Define the center\n    vec2 center = vec2(0.3, 0.6);\n    \n    // Distance of a normalized pixel coordinate from the center\n    vec2 gradient = uv - center;\n    \n    // Default radius for a circle\n    float radius = 0.2;\n    \n    // Number of petals to generate from a circle\n    float numPetals = 8.0;\n    \n    // Radius of circle changed based on the cos function for which angle\n    // is defined by number of petals multiplied by angle projected by a pixel to\n    // the center of the screen defined above.\n    // iTime is used to make the petals rotate, add iTime for clockwise,\n    // subtract it to get anti-clockwise rotation\n    // Add x component of gradient to bring a little bend at the end of the\n    // petals. 15.0 is a magic value.\n    float changingRadius = radius * cos(15.0 + numPetals * \n                                        atan(gradient.y, gradient.x) +\n                                        20.0 * gradient.x);\n\n    \n    // This is what will give us petals position and correct shape.\n    // The smootstep function will interpolate a value for pixels within the\n    //  two edges and the source value is defined by the length of th gradient.\n    float smoothValue = smoothstep(changingRadius, changingRadius+0.001, \n                                   length(gradient));\n \t\n    // Multiply smoothness with color to get petals\n    color *= smoothValue;\n    \n    float barkRadius = 0.015;\n    \n    // Absolute value of x gradient times some sine angle of y gradient\n    // Subtract both to get the reverse shape.\n    float barkCurve = abs(gradient.x - 0.2 * sin(3.0 * gradient.y));\n    \n    // Let's get the bark. Need to subtract 1 from smootstep o/p to get the \n    // complement value for pixels.\n    float smoothValueY = 1.0 - ((1.0 - smoothstep(barkRadius, barkRadius+0.0001, \n                                                  barkCurve)) *\n                                ((1.0 - smoothstep(0.0, 0.0001, (gradient.y)))));\n\n    color *= smoothValueY;\n    \n    // Time varying pixels, dont do this to have static color background \n    color *= 0.5 + 0.5*sin(iTime+uv.xyxx);\n    \n    // Output to screen\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdtyzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 106, 2398]]}
{"id": "Wstcz4", "name": "SpaceToy_RevolvingCircle", "author": "SpaceToy", "description": "Describe a circle that revolves around the center", "tags": ["revolvingcircle"], "likes": 0, "viewed": 12, "published": "Public", "date": "1634905803", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Default background color\n    vec4 color = vec4(1.0, 0.5, 0.0, 0.0); //orange\n    \n    // Define the center\n    vec2 center = vec2(0.5, 0.5);\n    \n    // Distance of a normalized pixel coordinate from the center\n    vec2 gradient = uv - center;\n    \n    // Default radius for a circle\n    float radius = 0.2;\n    \n    // Number of petals to generate from a circle\n    float numPetals = 1.0;\n    \n    // Radius of circle changed based on the cos function for which angle\n    // is defined by number of petals multiplied by angle projected by a pixel to\n    // the center of the screen defined above\n    // iTime is used to make the petals rotate, add iTime for clockwise,\n    // subtract it to get anti-clockwise rotation\n    float changingRadius = radius * cos(iTime + numPetals * atan(gradient.y, gradient.x));\n\n    // A constant value of smooth function will never give us a circle\n    // float changingSmoothValue = 1.0;\n    \n    // This is what will give us a black circle around the center of the screen\n    // The smootstep function will interpolate a value for pixels within the two edges\n    // and the source value is defined by the length of th gradient.\n    float smoothValue = smoothstep(changingRadius, changingRadius+0.001, length(gradient));\n\n\n    // Multiply smoothness with color\n    color *= smoothValue;\n    \n    // Time varying pixels, dont do this to have static color background \n    color *= 1.0 + 0.5*sin(iTime+uv.xyxx);\n    \n    // Output to screen\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wstcz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 106, 1652]]}
{"id": "wsXcW7", "name": "Eikonal Voronoise 1D", "author": "spalmer", "description": "extending concept of [url]https://shadertoy.com/view/wlt3z8[/url] and [url]https://shadertoy.com/view/Ws3XWl[/url] to 1D then probably back up to 2D and 3D my way", "tags": ["noise", "distance"], "likes": 2, "viewed": 52, "published": "Public", "date": "1634472775", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// idk why I never public'd this.\n// Guess I never got around to cleaning it up?\n// Got used in Biker 2D  https://shadertoy.com/view/tdjBzW\n\nconst int LEVELS = 4;\nconst float SCALE = 12.;//10.; //8.; //12.; //16.; //256.; //64.; //\n// FIXME I get the feeling if I did this unsigned\n// it wouldn't be nearly so complicated to sum up.\nfloat tent1(float x)\n{\n    return max(0., 1.-abs(x)); //fract(x); //\n}\n// FIXME if had some y coordinate available, could estimate some point distance at vertex, better than nothing!\n// but seems only viable for 2+ dimensions?  unsure what is proper for 1D.\n\nfloat noise1(float x)\n{\n//    return sin(1.5*x);\n    float o = x;\n    x = mod(x - 1., 2.) - 1.;\n    float y = sin(3.1415927*(sqrt(5.)+1.)*floor((o-1.)/2.)); // some pseudorandom hash\n    //if (x < 0.) x += 2.;\n\tfloat v = tent1(x); // - y);\n    v *= sqrt(.5); // fix sheared 'distance' measurements - but this is 1D so unsure it's even a good thing to try\n    if (y < 0.) v = -v; //v *= sign(y);\n    return v;\n    // TODO 1D voronoise stuff\n}\n// basically want to integrate a bunch of step function derivatives or something\n// Eikonal is trivial in 1D, doesn't even involve square roots,\n// but extending it back to 2D and above is trickier.\nfloat fbm1(float x)\n{\n    float d = -1. //1. //0. //\n    , s = 1.;\n    for (int i = LEVELS; --i >= 0; s *= .5, x *= 2.) {\n        //d += noise1(x);\n        float n = s * noise1(x);\n        //d += n;\n        //if (n < d)\n        //d = min(d, n);\n        //else\n        d = max(d, n);\n        //d = n; //\n    }\n    //d *= .5 / (1.-s); // 'normalize' after adding\n    //d /= float(LEVELS);\n    return d;\n}\n\nfloat lodshape(float dshape, float dlod, float fade)\n{\n    float b = abs(dlod);\n    if (b >= fade) return dlod;\n    if (b <= 0.) return dshape;\n    float a = abs(dshape);\n    return mix(dshape, dlod, b / fade); //pow(b / fade, .7)); //clamp(b / fade, 0., 1.));\n}\n\nconst float fade = 9., slab = 1.;\n\n// lod blend to a linear eikonal slab function if outside -1..1 range\n// seems like it's cheating, kinda; technique could be used on\n// any noisy pseudo-SDF that approximates a slab, such as sin or cos.\n// But even in 1D I don't want steps far away to have to deal with the\n// fluctuations from the details.  From a far distance, every shape\n// appears to fill its entire volume even if up close the details\n// make that volume full of small gaps.  Plus LOD is important to\n// prevent evaluating expensive functions unnecessarily when far away from them.\n// so this is basically just an LOD bounding slab shape for the noise.\n// but it seems if I did the noise eikonally, I wouldn't need this?\n// and it still doesn't fix sdf problems near the shape surface.\nfloat lnoise1(float x, float y)\n{\n    float n = fbm1(x);\n    float d0 = y - n, d1 = sign(y) * max(0., abs(y) - slab); //abs(y) < slab ? 0. : sign(y) * (abs(y) - slab)\n    return lodshape(d0, d1, fade);\n    float a = abs(y);\n    if (a > fade + slab) return sign(y) * max(0., a - slab);\n    float d = y - n;\n    if (abs(y) > slab) {\n        float dlod = sign(y) * (a - slab);\n        d = mix(d, dlod, clamp((a - slab) / fade, 0., 1.));\n    }\n    return d;\n}\n        \t//mix(dlod, d, exp2(-3.*(abs(y) - 1.)));\n\n\n// \"standard\" sdf gradient debugging by iq   \nvec3 DebugSDFa(float d)\n{\n    vec3 col = vec3(1) - sign(d)*vec3(.1,.5,.9);\n\tcol *= 1. - exp(-2.*abs(d));\n\tcol *= .8 + .2*cos(120.*d);\n    return mix(col, vec3(1), 1.-smoothstep(.0,.02,abs(d))); // white at zero\n}\n// some other thing, different colors\nvec3 DebugSDFb(float d)\n{\n    vec2 R = iResolution.xy;\n    float g = .5-.5*cos(d * R.y * .5);\n\tvec3 c = vec3(g);\n    if (d < 0.) c.rb *= 0.; else c.rg *= 0.2; //c.rg = 1.-c.rg; else c.gb = 1.-c.gb;\n    c += exp2(-.5*iResolution.y * abs(d));\n//    if (abs(abs(q.y) - 1./SCALE) <= 2./R.y) c.r += .3; // verify vertical range\n//    if (abs(abs(q.y) - (fade + slab)/SCALE) <= 2./R.y) c.bg += vec2(.3); // verify vertical range of fade\n    return c;\n}\n\nvec3 DebugSDF(float d)\n{\n    return \n        DebugSDFa //DebugSDFb //\n        (d);\n}\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    vec2 R = iResolution.xy, q = (p+p-R)/R.y;\n    q.x += .02 * iTime; if (iMouse.z >= 0.) q *= .6; // scroll, click to zoom\n    float d = lnoise1(q.x * SCALE, q.y * SCALE) / SCALE;\n    vec3 c = DebugSDF(d);\n\tc = pow(c, vec3(.4545));\n    o = vec4(c, 1);\n}\n\n    //vec3 c = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsXcW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[187, 333, 355, 355, 403], [404, 592, 615, 640, 1033], [1034, 1233, 1254, 1254, 1635], [1637, 1637, 1691, 1691, 1899], [1936, 2695, 2728, 2728, 3150], [3203, 3249, 3274, 3274, 3461], [3462, 3500, 3525, 3525, 3946], [3948, 3948, 3972, 3972, 4032], [4034, 4034, 4070, 4070, 4325]]}
