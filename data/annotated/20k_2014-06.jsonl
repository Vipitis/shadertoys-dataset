{"id": "4dfSW7", "name": "Foggy Terrain", "author": "andrewsantamaria", "description": "The title says it all.", "tags": ["procedural", "terrain"], "likes": 14, "viewed": 542, "date": "1401986133", "time_retrieved": "2024-06-20T18:11:19.566232", "image_code": "// IÃ±igo Quilez's noise functions\nfloat hash(float n)\n{\n  return fract(cos(n) * 41415.92653);\n}\nfloat noise( in vec3 x )\n{\n  vec3 p  = floor(x);\n  vec3 f  = smoothstep(0.0, 1.0, fract(x));\n  float n = p.x + p.y*57.0 + 113.0*p.z;\n\n  return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n    mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\nmat3 m = mat3( 0.00,  1.60,  1.20, \n\t\t\t  -1.60,  0.72, -0.96, \n\t\t\t  -1.20, -0.96,  2.28 );\nfloat fbm( vec3 p ) // experimented with and kind of modified\n{\n  float f = 0.5000 * noise( p ); p = m * p * 0.72;\n  f += 0.2500 * noise( p ); p = m * p * 0.73;\n  f += 0.1250 * noise( p ); p = m * p * 0.74;\n  f += 0.0625 * noise( p ); p = m * p * 0.75; \n  f += 0.03125 * noise( p ); p = m * p;// * 0.76;\n  //f += 0.015625 * noise( p );// p = m * p;\n  //f += 0.0078125 * noise( p ); \t\n  return f;\n}\n\n// scene stuff\nfloat objFloor(in vec3 p, in float height) // terrain's just a noisy floor\n{\n\treturn p.y + height * fbm(vec3(p.xz, 10));\n}\nvec2 scene(in vec3 p)\n{\n\t#define FLOOR_HEIGHT 2.5\n\tvec2 floorPlane = vec2(objFloor(p, FLOOR_HEIGHT),\n\t\t\t\t\t\t   1.0);\n\treturn floorPlane;\n}\n\n// raymarching stuff\nvec3 calcNormal(in vec3 p)\n{\n\tvec3 e = vec3(0.001, 0.0, 0.0);\n\t\n\tvec3 n;\n\tn.x = scene(p + e.xyy).x - scene(p - e.xyy).x;\n\tn.y = scene(p + e.yxy).x - scene(p - e.yxy).x;\n\tn.z = scene(p + e.yyx).x - scene(p - e.yyx).x;\n\t\n\treturn normalize(n);\n}\n\n#define MAX_STEPS 64\n#define MAX_DEPTH 24.0\nvec2 intersect(in vec3 origin, in vec3 direction)\n{\n\tfloat rayLength = 0.0;\n\tvec2 hit = vec2(1.);\n\tfor (int i = 0; i < MAX_STEPS; ++i)\n\t{\n\t\tif (hit.x < 0.001 || rayLength > MAX_DEPTH)\n\t\t\tbreak;\n\t\t\n\t\thit = scene(origin + direction * rayLength);\n\t\t \n\t\t// increment by a slightly reduced length to lessen wavy artifacts\n\t\trayLength += hit.x * 0.6;\n\t}\n\t\t\n\treturn vec2(rayLength, rayLength > MAX_DEPTH ? \n\t\t\t\t\t\t   0. : hit.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// setup space\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 p = (uv * 2.0 - 1.0); p.x *= iResolution.x / iResolution.y;\n\t\n\t// setup camera\n\t#define SPEED_SCALE 0.125\n\tvec3 origin = vec3(3. * cos(SPEED_SCALE * iTime),\n\t\t\t\t\t   1,\n\t\t\t\t\t   2. * sin(SPEED_SCALE * iTime));\n\tvec3 target = vec3(0,0,0);\n\t\n\t// camera direction\n\tvec3 direction = normalize(target - origin);\n\t// right\n\tvec3 right = normalize(cross(direction, vec3(0,1,0)));\n\t// up vector\n\tvec3 up = normalize(cross(right, direction));\n\t// ray direction\n\tvec3 rayDirection = normalize(p.x * right + p.y * up + 1.5 * direction);\n\t\n\t// shade scene\n\tvec3 color = mix(vec3(32./255.), //background\n\t\t\t\t\tvec3(225./255.),\n\t\t\t\t\tuv.y);\n\t// x is the proper distance to the intersection point, y is the material\n\tvec2 result = intersect(origin, rayDirection);\n\t\n\tif (result.y > 0.5)\n\t{\n\t\tvec3 position = origin + rayDirection * result.x;\n\t\tvec3 normal = calcNormal(position);\n\t\tvec3 light = normalize(vec3(0., 3., -1.));\n\t\t\n\t\tcolor = vec3(fbm(vec3(position.xz, 10))) /*\n\t\t\t\t max(0., dot(normal, light))*/;\n\t}\n\t\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dfSW7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 37, 58, 58, 98], [99, 99, 125, 125, 442], [534, 534, 597, 597, 931], [933, 948, 1024, 1024, 1070], [1071, 1071, 1094, 1094, 1208], [1210, 1231, 1259, 1259, 1473], [1519, 1519, 1570, 1570, 1942], [1944, 1944, 2001, 2017, 3094]]}
{"id": "4dlXWM", "name": "Mandelbrot Glow Grow", "author": "TekF", "description": "More mandelbrot animations...\nBest viewed full screen.", "tags": ["fractal"], "likes": 25, "viewed": 2642, "date": "1402249635", "time_retrieved": "2024-06-20T18:11:19.960269", "image_code": "// this looks prettier, but makes it less obvious that it's the same warp each time.\n#define LERP_AFTER\n\n//#define ZOOM\n\nvec3 Sample( vec2 p )\n{\n//\treturn vec3(pow(fract(5.0/(1.0+dot(p,p))),.1));\n\tfloat a = fract(4.0/(4.0+dot(p,p)));\n//\treturn pow(a,.1)*((sin(vec3(1)*a*6.28+vec3(1,2,3)*.6)*.5+.5)*.5+.5);\n\treturn vec3(1.2,.8,.7)*pow(vec3(a),vec3(10,1,.1));\n\t//return step(vec3(.1,.01,.001),vec3(a)); unknown error?!\n}\n\nvec3 fractal( vec2 pos )\n{\n\tfloat F = fract(.04*iTime);\n    // speed up the first few\n    F = pow(F,.5);\n\t\n\tvec2 C = (2.0*pos.xy-iResolution.xy) / iResolution.x;\n\t// position better to see the fractal\n#ifdef ZOOM\n\tC = mix( C*8.0+vec2(-4,0), C*.001+vec2(-1,-.3), pow(F,.2) );\n#else\n\tC = mix( C*8.0+vec2(-4,0), C*2.0+vec2(-1,0), pow(F,.5) );\n#endif\n\t\n\tvec2 Z = vec2(0);\n\t\n\t#define MAX 25\n\tfloat m = float(MAX);\n\tfloat n = exp2(F*log2(m))-1.0;//fract(.3*iTime/m)*m;\n\t\n#ifndef LERP_AFTER\n\t// blend towards the next one\n\tZ = C*fract(n);\n#endif\n\t\n\tfor ( int i=0; i < MAX; i++ )\n\t{\n\t\tif ( float(i) > n || dot(Z,Z) > exp2(120.0) ) // trap really big vals to prevent NaNs\n\t\t\tcontinue;\n\t\tZ = vec2( Z.x*Z.x-Z.y*Z.y, 2.0*Z.x*Z.y ) + C;\n\t}\n\n#ifdef LERP_AFTER\n\t// blend from the last one\n\tZ = mix( Z, vec2( Z.x*Z.x-Z.y*Z.y, 2.0*Z.x*Z.y ) + C, pow(smoothstep(0.0,1.0,fract(n)),4.0) );\n#endif\n\n\t// image map\n\tvec3 col = Sample(Z);\n\t\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// anti-aliasing\n\tfragColor.rgb  = fractal( fragCoord.xy + vec2(5,1)/8.0 );\n\tfragColor.rgb += fractal( fragCoord.xy + vec2(1,3)/8.0 );\n\tfragColor.rgb += fractal( fragCoord.xy + vec2(7,5)/8.0 );\n\tfragColor.rgb += fractal( fragCoord.xy + vec2(3,7)/8.0 );\n\tfragColor.rgb /= 4.0;\n\n\tfragColor.rgb = pow(fragColor.rgb,vec3(1.0/2.2));\n\tfragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dlXWM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[105, 121, 144, 195, 418], [420, 420, 446, 446, 1351], [1353, 1353, 1410, 1428, 1761]]}
{"id": "4dXXW7", "name": "Raymarch Hello World", "author": "villain749", "description": "My first attempt at understanding raymarching. Completely inefficient and very rough but by jove it works!", "tags": ["raymarch", "helloworld"], "likes": 3, "viewed": 252, "date": "1401869898", "time_retrieved": "2024-06-20T18:11:20.402649", "image_code": "// My first attempt at understanding raymarching. \n// Completely inefficient but by jove it works!\n\n\nconst int RAY_STEPS = 35;\nconst float cubeSize = 4.0;\nconst float speed = 30.0;\n\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t// uv coord\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\t// camera stuff\n\tvec3 camPos = vec3(15.0, 8.0,15.0);\n\tvec3 camNorm = vec3(0.653, 0.383, 0.653);\n\t//animated spin camera\n\tfloat rads = iTime * speed * 0.01745;\n\tmat3 spin = mat3(vec3(cos(rads), 0.0, -sin(rads)), vec3(0.0, 1.0, 0.0), vec3(sin(rads), 0.0, cos(rads)));\n\tcamPos = spin * camPos;\n\tcamNorm = spin * camNorm;\n\t// camera attributes\n\tfloat camNear = .5;\n\tfloat camFar = 55.0;\n\tfloat camHFOV = 65.0;\n\tfloat camVFOV = 35.0;\n\t// camera matrix\n\tvec3 camXAxis = cross(vec3(0.0, 1.0, 0.0), camNorm);\n\tcamXAxis =  normalize(camXAxis);\n\tvec3 camYAxis = cross(camNorm, camXAxis);\n\tmat3 camRotMat = mat3(camXAxis, camYAxis, camNorm);\n\t\n\t//ray vector\n\tvec3 raySt = vec3(0.0, 0.0, -camNear);\n\tfloat nearW = tan(camHFOV * .5 * .01745) * abs(camNear);\n\traySt.x = (nearW * uv.s * 2.0) - nearW;\n\tfloat nearH = tan(camVFOV * .5 * .01745) * abs(camNear);\n\traySt.y = (nearH * uv.t * 2.0) - nearH;\n\t// run the ray through the cameras rotation matrix, and add it's position\n\traySt = (camRotMat * raySt) + camPos;\n\tvec3 rayDir = normalize(raySt - camPos);\n\tvec3 rayInc = rayDir * ((abs(camFar) - abs(camNear)) / float(RAY_STEPS));\n\t\n\t// march\n\tvec3 result = vec3(1.0, 0.0, 1.0);\n\tvec3 curPos = raySt;\n    float cur_step_size = 0.1;\n\tfor (int i = 0; i < RAY_STEPS; ++i) {\n\t\tif (i == RAY_STEPS - 1) {\n\t\t\tresult = mix(vec3(0.15, 0.15, 0.15), vec3(0.6, 0.05, 0.8), uv.t);\t\n        }\n\t\t\n        vec3 wave = vec3(curPos.x + sin(curPos.y * 4.0) * 0.25, curPos.y, curPos.z); \n        float dist = sdBox( wave, vec3(2.0, 4.0, 2.0) );\n        float dist2 = sdCone(wave, vec2(1.0, 0.2));\n        dist = min(dist, dist2);\n\t\tif (abs(dist) < 0.2) {\n\t\t\t//return curPos;\n\t\t\tresult = vec3(0.0,  float(i) / float(RAY_STEPS) * 1.5, 1.0);\n\t\t\tbreak;\n\t\t}\n        cur_step_size = dist;\n\t\tcurPos += rayDir * cur_step_size;\n\t}\n\t\n\n\tfragColor = vec4(result, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dXXW7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 183, 214, 214, 301], [304, 304, 336, 364, 425], [428, 428, 485, 498, 2367]]}
{"id": "4dXXzS", "name": "Origami Toggles", "author": "TekF", "description": "Toggle demo mode auto-cycle: D, Lens effects: L, Printed paper: P, Static object: A>\nDiffuse toggles: 1,2,3,4,5 toggle all: 0>\nSpecular toggles: Q,W,E,R toggle all: 9 (more toggles in code->)", "tags": ["fractal", "lighting", "ambientocclusion", "specularocclusion"], "likes": 23, "viewed": 742, "date": "1402924332", "time_retrieved": "2024-06-20T18:11:22.457659", "image_code": "// Hazel Quantock 2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// keys\nconst int kA=65,kB=66,kC=67,kD=68,kE=69,kF=70,kG=71,kH=72,kI=73,kJ=74,kK=75,kL=76,kM=77,kN=78,kO=79,kP=80,kQ=81,kR=82,kS=83,kT=84,kU=85,kV=86,kW=87,kX=88,kY=89,kZ=90;\nconst int k0=48,k1=49,k2=50,k3=51,k4=52,k5=53,k6=54,k7=55,k8=56,k9=57;\nconst int kSpace=32,kLeft=37,kUp=38,kRight=39,kDown=40;\n\n\n// TOGGLES:\n\n// demo mode - cycle through the effects\nint kDemoMode = kD;\n\n// aesthetic toggles\nint kAnimate = kA;  float pauseTime = 3.6;\nint kPrintedPaper = kP;\nint kLensFX = kL;\n\n// lighting\nint kLighting = k0; // turn all diffuse illumination on/off (to see reflections better)\nint kAlbedo = k1;\nint kShadow = k2;\nint kDirectLight = k3;\nint kAmbientGradient = k4;\nint kAmbientOcclusion = k5;\n\n// specular\nint kSpecular = k9; // turn all specular on/off (to see diffuse better)\nint kSpecularHighlight = kQ;\nint kFresnel = kW;\nint kReflectionOcclusion = kE;\nint kReflections = kR;\n\n\n// key is javascript keycode: http://www.webonweboff.com/tips/js/event_key_codes.aspx\nbool ReadKey( int key, bool toggle )\n{\n\tfloat keyVal = textureLod( iChannel3, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ), 0.0 ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\n\nbool Toggle( int val, int index )\n{\n\tfloat cut = fract(iTime/30.0)*11.0;\n\tif ( !ReadKey( kDemoMode, true ) && float(index) > cut )\n\t{\n\t\treturn false;\n\t}\n\t\n\t// default everything to \"on\"\n\treturn !ReadKey( val, true );\n}\n\n\n\nvec3 tetOffset = vec3(-.1);\n\nvec3 Transform( vec3 p )\n{\n\t// fractalise space, rotate then mirror on axis\n\tconst float tau = 6.2831853;\n\tconst float phi = 1.61803398875;\n\t\n\tfloat T = pauseTime;\n\tif ( Toggle(kAnimate,-1) ) T = iTime;\n\tT *= 1.0;\n\tfloat a0 = .2*phi*(T+sin(T));\n\tfloat a1 = .05*phi*(T-sin(T))*phi;\n\tfloat c0 = cos(a0);\n\tvec2 s0 = vec2(1,-1)*sin(a0);\n\tfloat c1 = cos(a1);\n\tvec2 s1 = vec2(1,-1)*sin(a1);\n\t\n\t\n\tconst int n = 9;\n\tfloat o = 1.0;\n\n\t// centre on the first mirror\n// actually I prefer the off-centre look.\n//\tp.x -= o;\n\t\n\t// and the second\n//\tp.y += o*.75*s0.x;\n//\tp.z -= o*.75*s1.x;\n\t\n\tfor ( int i=0; i < n; i++ )\n\t{\n\t\tp.x = abs(p.x+o)-o;\n\t\tp.xy = p.xy*c0 + p.yx*s0;\n\t\tp.xz = p.xz*c1 + p.zx*s1;\n\t\t//o = o/sqrt(2.0);\n\t\to = o*.75;\n\t\t//o = max( o*.8 - .02, o*.7 );\n\t\t//o = o-1.0/float(n);\n\t\t//o = o*(float(n-i-1)/float(n-i)); // same as^\n\t\t//o = o*.8*(float(n-i-1)/float(n-i));\n\t\t//o = o*.9*(float(n-i-1)/float(n-i));\n\t\t//o = o/phi;\n\t}\n\n\treturn p;\n}\n\nfloat DistanceField( vec3 pos )\n{\n\tvec3 p = Transform(pos);\n\n\t// spheres\t\n//\treturn length(p)-.15;\n\n\t// cubes\n//\treturn max(abs(p.x),max(abs(p.y),abs(p.z)))-.14;\n\n\t// octahedra\t\n//\treturn (abs(p.x)+abs(p.y)+abs(p.z))/sqrt(3.0)-.1;\n\t\n\t// spikes! Precision issues, but wow!\n//\treturn (abs(p.z)*.05+length(p.xy)*sqrt(1.0-.05*.05))-.1;\n\n\t// stretched octahedra\n//\tvec3 s = vec3(1,1,.3);\tp = abs(p)*s/length(s);\treturn dot(p,vec3(1))-.2;\n\t\n\t// tetrahedra\n\tp -= tetOffset; // offset tetrahedra, for more variety\n\treturn max( max( p.x+p.y+p.z, -p.x-p.y+p.z), max( p.x-p.y-p.z, -p.x+p.y-p.z ) )/sqrt(3.0) -.2;\n\t\n\t// cones\n//\treturn max( -p.z, p.z*7.0/25.0+length(p.xy)*24.0/25.0 ) - .2;\n}\n\n\nvec3 Sky( vec3 ray )\n{\n\treturn mix( vec3(.8), vec3(0), exp2(-(1.0/max(ray.y,.01))*vec3(.4,.6,1.0)) );\n}\n\n\nvec3 Shade( vec3 pos, vec3 ray, vec3 normal, vec3 lightDir, vec3 lightCol, float distance )\n{\n\tvec3 uv = Transform(pos);\n\tfloat grain = texture( iChannel0, uv.xy/.2 ).r;\n\t\n\tvec3 ambient = vec3(.5);\n\tif ( Toggle(kAmbientGradient,2) )\n\t\tambient = mix( vec3(.2,.27,.4), vec3(.4), (-normal.y*.5+.5) ); // ambient\n//\t\tambient = mix( vec3(.03,.05,.08), vec3(.1), (-normal.y+1.0) ); // ambient\n\t// ambient occlusion, based on my DF Lighting: https://www.shadertoy.com/view/XdBGW3\n\tfloat aoRange = distance/10.0;\n\tfloat occlusion = max( 0.0, 1.0 - DistanceField( pos + normal*aoRange )/aoRange ); // can be > 1.0\n\tocclusion = exp2( -2.0*pow(occlusion,2.0) ); // tweak the curve\n\tocclusion *= mix(.5,1.0,pow(grain,.2));\n\tif ( Toggle(kAmbientOcclusion,1) )\n\t\tambient *= occlusion;\n\n\tfloat ndotl = max(.0,dot(normal,lightDir));\n\tfloat lightCut = smoothstep(.0,.1,ndotl);//pow(ndotl,2.0);\n\tvec3 light = vec3(0);\n\n\tif ( Toggle(kDirectLight,3) )\n\t\t\tlight += lightCol*ndotl;\n\n\tlight += ambient;\n\t\n\t\n\tfloat specularity = grain;\n\t\n\tvec3 h = normalize(lightDir-ray);\n\tfloat specPower = exp2(1.0+1.0*specularity);\n\tvec3 specular = lightCol*pow(max(.0,dot(normal,h))*lightCut, specPower)*specPower/32.0;\n\t\n\tvec3 rray = reflect(ray,normal);\n\tvec3 reflection = vec3(0);\n\t\n\tif ( Toggle(kReflections,6) )\n\t\treflection = Sky( rray );\n\t\n\t// prevent sparkles in heavily occluded areas\n\tif ( Toggle(kReflectionOcclusion,7) )\n\t\treflection *= occlusion;\n\t\n\t// specular occlusion, adjust the divisor for the gradient we expect\n\tocclusion = max( 0.0, 1.0 - DistanceField( pos + rray*aoRange )/(aoRange*dot(rray,normal)) ); // can be > 1.0\n\tocclusion = exp2( -2.0*pow(occlusion,2.0) ); // tweak the curve\n\t\n\tif ( Toggle(kReflectionOcclusion,7) )\n\t\treflection *= occlusion; // could fire an additional ray for more accurate results\n\t\n\tfloat fresnel = pow( 1.0+dot(normal,ray), 5.0 );\n\tfresnel = mix( mix( .0, .05, specularity ), .8, fresnel );\n\t\n\tif ( !Toggle(kFresnel,8) )\n\t\tfresnel = 1.0; // chrome\n\t\n\t//vec3 albedo = vec3(.1,.7,.05);//.02,.06,.1);//.04);//.6,.3,.15);//.8,.02,0);\n\tuv -= tetOffset;\n\tvec3 uv2 = uv;\n\tif ( uv2.x+uv2.z < .0 ) uv2.xz = -uv2.zx;\n\tif ( uv2.z < uv2.x ) uv2.x = uv2.z;\n\tfloat side = uv2.x+uv2.y;\n\t\n\tvec3 print = vec3(.1,.7,.05);\n\tif ( Toggle(kPrintedPaper,-1) )\n\t{\n\t\tvec3 tex = texture(iChannel2,uv.xy*.7).rgb;\n\t\tprint = mix( vec3(1,0,0), vec3(0,0,.5), smoothstep(.38,.47,tex.r) );\n\t\tprint = mix( print, vec3(1,.7,.05), smoothstep(.012,.008,abs(tex.b-.5)) );\n//\tvec3 print = mix( vec3(0,.3,0), vec3(.1,.03,.0), smoothstep(.3,.6,tex.r) );\n//\tprint = mix( print, vec3(1,.7,.05), smoothstep(.012,.008,abs(tex.b-.5)) );\n\t}\n\tvec3 albedo = mix( print, vec3(1), step(.0,side) );\n\t\n\tif ( !Toggle(kAlbedo,5) ) albedo = vec3(1);\n\t\n\tvec3 result = vec3(0);\n\tif ( Toggle(kLighting,-1) )\n\t\tresult = light*albedo;\n\n\tif ( Toggle(kSpecular,6) )\n\t{\n\t\tresult = mix( result, reflection, fresnel );\n\t\n\t\tif ( Toggle(kSpecularHighlight,9) )\n\t\t\tresult += specular;\n\t}\n\n\treturn result;\n}\n\n\n\n\n// Isosurface Renderer\n\nfloat traceStart = .1; // set these for tighter bounds for more accuracy\nfloat traceEnd = 20.0;\nfloat Trace( vec3 pos, vec3 ray )\n{\n\tfloat t = traceStart;\n\tfloat h;\n\tfor( int i=0; i < 60; i++ )\n\t{\n\t\th = DistanceField( pos+t*ray );\n\t\tif ( h < .001 || t > traceEnd )\n\t\t\tbreak;\n\t\tt = t+h;\n\t}\n\t\n\tif ( t > traceEnd )//|| h > .001 )\n\t\treturn 0.0;\n\t\n\treturn t;\n}\n\nfloat TraceMin( vec3 pos, vec3 ray )\n{\n\tfloat Min = traceEnd;\n\tfloat t = traceStart;\n\tfloat h;\n\tfor( int i=0; i < 60; i++ )\n\t{\n\t\th = DistanceField( pos+t*ray );\n\t\tMin = min(h,Min);\n\t\tif ( /*h < .001 ||*/ t > traceEnd )\n\t\t\tbreak;\n\t\tt = t+max(h,.1);\n\t}\n\t\n\treturn Min;\n}\n\nvec3 Normal( vec3 pos, vec3 ray, float distance )\n{\n\t// in theory we should be able to get a good gradient using just 4 points\n//\tvec2 d = vec2(-1,1) * .01;\n\tvec2 d = vec2(-1,1) * .5 * distance / iResolution.x;\n\tvec3 p0 = pos+d.xxx; // tetrahedral offsets\n\tvec3 p1 = pos+d.xyy;\n\tvec3 p2 = pos+d.yxy;\n\tvec3 p3 = pos+d.yyx;\n\t\n\tfloat f0 = DistanceField(p0);\n\tfloat f1 = DistanceField(p1);\n\tfloat f2 = DistanceField(p2);\n\tfloat f3 = DistanceField(p3);\n\t\n\tvec3 grad = p0*f0+p1*f1+p2*f2+p3*f3 - pos*(f0+f1+f2+f3);\n\t\n\t// prevent normals pointing away from camera (caused by precision errors)\n\tfloat gdr = dot ( grad, ray );\n\tgrad -= max(.0,gdr)*ray;\n\t\n\treturn normalize(grad);\n}\n\n\n// Camera\n\nvec3 Ray( float zoom, vec2 fragCoord )\n{\n\treturn vec3( fragCoord.xy-iResolution.xy*.5, iResolution.x*zoom );\n}\n\nvec3 Rotate( inout vec3 v, vec2 a )\n{\n\tvec4 cs = vec4( cos(a.x), sin(a.x), cos(a.y), sin(a.y) );\n\t\n\tv.yz = v.yz*cs.x+v.zy*cs.y*vec2(-1,1);\n\tv.xz = v.xz*cs.z+v.zx*cs.w*vec2(1,-1);\n\t\n\tvec3 p;\n\tp.xz = vec2( -cs.w, -cs.z )*cs.x;\n\tp.y = cs.y;\n\t\n\treturn p;\n}\n\n\n// Camera Effects\n\nvoid BarrelDistortion( inout vec3 ray, float degree )\n{\n\t// would love to get some disperson on this, but that means more rays\n\tray.z /= degree;\n\tray.z = ( ray.z*ray.z - dot(ray.xy,ray.xy) ); // fisheye\n\tray.z = degree*sqrt(ray.z);\n}\n\nvec3 LensFlare( vec3 ray, vec3 light, float lightVisible, float sky, vec2 fragCoord )\n{\n\tvec2 dirtuv = fragCoord.xy/iResolution.x;\n\t\n\tfloat dirt = 1.0-texture( iChannel1, dirtuv ).r;\n\t\n\tfloat l = (dot(light,ray)*.5+.5);\n\t\n\treturn (((pow(l,30.0)+.1)*dirt*.1 + 1.0*pow(l,200.0))*lightVisible + sky*1.0*pow(l,5000.0))*vec3(1.05,1,.95);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 ray = Ray(1.0,fragCoord);\n\t\n\tif ( Toggle(kLensFX,10) )\n\t\tBarrelDistortion( ray, .5 );\n\t\n\tray = normalize(ray);\n\tvec3 localRay = ray;\n\n\tvec2 mouse = .5-iMouse.yx/iResolution.yx;\n\tvec3 pos = 8.0*Rotate( ray, vec2(-.2,-2.5)+vec2(1.0,-6.3)*mouse );\n\t\n\tvec3 col;\n\n\tvec3 lightDir = normalize(vec3(3,2,-1));\n\t\n\tfloat t = Trace( pos, ray );\n\tif ( t > .0 )\n\t{\n\t\tvec3 p = pos + ray*t;\n\t\t\n\t\t// shadow test\n\t\tfloat s = 0.0;\n\t\tif ( Toggle(kShadow,4) ) s = Trace( p, lightDir );\n\t\t\n\t\tvec3 n = Normal(p, ray, t);\n\t\tcol = Shade( p, ray, n, lightDir, (s>.0)?vec3(0):vec3(1.1,1,.9), t );\n\t\t\n\t\t// fog\n\t\tfloat f = 1000.0;\n\t\tcol = mix( vec3(.8), col, exp2(-t*vec3(.4,.6,1.0)/f) );\n\t}\n\telse\n\t{\n\t\tcol = Sky( ray );\n\t}\n\t\n\tif ( Toggle(kLensFX,10) )\n\t{\n\t\t// lens flare\n\t\tfloat sun = TraceMin( pos, lightDir );\n\t\tcol += LensFlare( ray, lightDir, smoothstep(-.04,.1,sun), step(t,.0), fragCoord );\n\t\n\t\t// vignetting:\n\t\tcol *= smoothstep( .5, .0, dot(localRay.xy,localRay.xy) );\n\t\n\t\t// compress bright colours, ( because bloom vanishes in vignette )\n\t\tvec3 c = (col-1.0);\n\t\tc = sqrt(c*c+.05); // soft abs\n\t\tcol = mix(col,1.0-c,.48); // .5 = never saturate, .0 = linear\n\t\t\n/* oops, ran out of texture channels\n\t\t// grain\n\t\tvec2 grainuv = fragCoord.xy + floor(iTime*60.0)*vec2(37,41);\n\t\tvec2 filmNoise = texture( iChannel0, .5*grainuv/iChannelResolution[0].xy ).rb;\n\t\tcol *= mix( vec3(1), mix(vec3(1,.5,0),vec3(0,.5,1),filmNoise.x), .1*filmNoise.y );*/\n\t}\n\t\n\tfragColor = vec4(pow(col,vec3(1.0/2.2)),1);\n}\n", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 3, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dXXzS.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1000, 1086, 1124, 1124, 1253], [1256, 1256, 1291, 1291, 1474], [1507, 1507, 1533, 1582, 2445], [2447, 2447, 2480, 2480, 3127], [3130, 3130, 3152, 3152, 3233], [3236, 3236, 3329, 3329, 6192], [6244, 6317, 6352, 6352, 6576], [6578, 6578, 6616, 6616, 6845], [6847, 6847, 6898, 7003, 7518], [7521, 7532, 7572, 7572, 7642], [7644, 7644, 7681, 7681, 7896], [7899, 7918, 7973, 8044, 8151], [8153, 8153, 8240, 8240, 8487], [8490, 8490, 8547, 8547, 10026]]}
{"id": "4sfSW7", "name": "Squares and Hexes", "author": "jjcoolkl", "description": "Comparison of hex-based sampling with square samples.", "tags": ["2d", "math", "filtering"], "likes": 7, "viewed": 654, "date": "1401931129", "time_retrieved": "2024-06-20T18:11:23.609163", "image_code": "//---------------------------------------------------------------------------------------------\n//---------------------------------------------------------------------------------------------\n// Name: Squares and Hexes\n//\n// Author: John Kloetzli \n//         @JJcoolkl\n//\n// Description: Comparison of square and hex lattice sampling patterns with equal sample density.  Includes \n// point and linear reconstruction filters.  Hex math routines from Innchyn Her[1] and hex b-spline \n// formulation from Van De Ville[2].  Test fuction inspired by test volume by Marschner and Lobb[3].\n//\n// Top: Hex point filter\n// Left: Hex linear filter\n// Bottom: Square point filter\n// Right: Square linear filter\n//\n// References:\n//\n// [1] Innchyn Her: Geometric Transformations on the Hexagonal Grid, IEEE Transactions on Image Processing,\n//     Vol.4, No.9, Sept. 2995.\n//\n// [2] Dimitri Van De Ville et al.: Hex-Splines: A Novel Spline Family for Hexagonal Lattices, IEEE \n//     Transactions on Image Processing, Vol. 13, No. 6, June 2004\n//     http://infoscience.epfl.ch/record/63112/files/vandeville0402.pdf\n//\n// [3] Stephen Marschner and Richard Lobb: An Evaluation of Reconstruction Filters for Volume Rendering,\n//     Proceedings of Visualization '94, pages 100-107, Oct. 1994.\n//     http://www.cs.cornell.edu/~srm/publications/Vis94-filters.pdf\n// \n//---------------------------------------------------------------------------------------------\n//---------------------------------------------------------------------------------------------\n\n#define FREQ \t\t20.0\n#define PI \t\t\t3.14159\n#define SQRT3 \t\t1.73205\n#define HEX_NORM \t1.07456 // sqrt( 2 / sqrt(3) )\n\n//#define SHOW_SQR_ERROR\n\n\n//filtering test function\nfloat EvalTestSignal( vec2 pos )\n{\n\tpos.x += sin( iTime ) * .2;\n\tpos.y += cos( iTime ) * .2;\n\t\n\tfloat fDist = sqrt( pos.x * pos.x + pos.y * pos.y );\n\tfloat fEval = PI * fDist * FREQ;\n\t\n\treturn sin(fEval * sqrt(fDist) ) / 4.0 + 0.5;\n}\n\n//---------------------------------------------------------------------------------------------\n// Project between square and hex basis.  I am not representing the z term of hex coordinate since it\n// is mathematically redundent.  Correct for smaller voronoi region produced by hex basis so we are\n// comparing equal sample density.\n//---------------------------------------------------------------------------------------------\nvec2 ToHex( vec2 pos )\n{\n\tpos.y *= (sqrt(3.0)/2.0);\n\tpos.y -= 0.5 * pos.x;\n\t\n\treturn pos * HEX_NORM;\n}\nvec2 FromHex( vec2 hex_pos )\n{\n\thex_pos /= HEX_NORM;\n\t\n\thex_pos.y += 0.5 * hex_pos.x;\n\thex_pos.y *= (2.0 / sqrt(3.0));\n\treturn hex_pos;\n}\n\n\n//---------------------------------------------------------------------------------------------\n// Sample wrapper in square basis.  Put whatever you want in here.\n//---------------------------------------------------------------------------------------------\nfloat Sample( vec2 pos )\n{\n\treturn EvalTestSignal( pos );\n\t//return texture( iChannel0, pos*0.5 + 0.5 ).x;\n}\nfloat Sample_Hex( vec2 hex_pos )\n{\n\treturn Sample( FromHex( hex_pos ) );\n}\n\n//---------------------------------------------------------------------------------------------\n// Rounding in square and hex domains.\n//---------------------------------------------------------------------------------------------\nvec2 hex_round( vec2 hex_val )\n{\n\tvec3 temp = vec3( hex_val.x, hex_val.y, -hex_val.x-hex_val.y );\n\tvec3 ret = round( temp );\n\t\n\tvec3 relative = ret - temp;\n\tif( (ret.x + ret.y + ret.z) > 0.0 )\n\t\trelative = temp - ret;\n\t\n\tif( relative.x < relative.y && relative.x < relative.z ){\n\t\tret.x = -ret.y -ret.z;\n\t}else if( relative.y < relative.z ){\n\t\tret.y = -ret.x - ret.z;\n\t}\n\t\n\treturn ret.xy;\n}\n\n//Linear hex spline basis function in hex basis from [2], updated to be evaluated in hex space.\n#define MIRROR( x,y,z ) { x=-x; float temp=y; y=-z; z=-temp; }\nfloat linear_hex_spline( vec2 hex_pos )\n{\n\tfloat hex_pos_z = -hex_pos.x -hex_pos.y;\n\tif( hex_pos_z > 0.0 ) MIRROR( hex_pos_z, hex_pos.x, hex_pos.y );\n\tif( hex_pos.x < 0.0 ) MIRROR( hex_pos.x, hex_pos.y, hex_pos_z );\n\tif( hex_pos.y > 0.0 ) MIRROR( hex_pos.y, hex_pos_z, hex_pos.x );\n\tif( hex_pos.y <= hex_pos_z )\n\t{\n\t\tfloat temp = hex_pos_z;\n\t\thex_pos_z = hex_pos.y;\n\t\thex_pos.y = temp;\n\t}\n\tif( hex_pos.y > hex_pos.x - 1.0 )\n\t{\n\t\tfloat a = hex_pos.x - hex_pos.y;\n\t\tfloat b = hex_pos.x + 2.0 * hex_pos.y;\n\n\t\treturn \n\t\t\t( (1.0-a) * (1.0-b) ) + \n\t\t\t( a * (1.0-b) + (1.0-a) * b ) / 3.0;\n\t}\n\tif( hex_pos_z > hex_pos.x - 2.0 )\n\t{\n\t\tfloat a = 2.0 - (2.0 * hex_pos.x) - hex_pos.y;\n\t\tfloat b = -hex_pos.x + hex_pos.y + 2.0;\n\n\t\treturn a * b / 3.0;\n\n\t}\n\n\treturn 0.0;\n}\n\n//---------------------------------------------------------------------------------------------\n// Vairous reconstruction filtering functions for square and hex domains\n//---------------------------------------------------------------------------------------------\nfloat Square_Point( vec2 pos, float sample_dist )\n{\n\tvec2 sample_pos = round( pos / sample_dist ) * sample_dist;\n\t\n\treturn Sample( sample_pos );\n}\nfloat Square_Linear( vec2 pos, float sample_dist )\n{\n\tpos /= sample_dist;\n\tvec2 base_pos = vec2( floor( pos.x ), floor( pos.y ) );\n\tvec2 interp = pos - base_pos;\n\tvec2 interp_i = vec2(1.0,1.0) - interp;\n\t\n\tvec2 sample_0;\n\tvec2 sample_1;\n\t\n\tvec2 temp;\n\ttemp = base_pos * sample_dist; \tsample_0.x = Sample( temp );\n\ttemp.x += sample_dist;\t\t\tsample_0.y = Sample( temp );\n\ttemp.y += sample_dist;\t\t\tsample_1.y = Sample( temp );\n\ttemp.x -= sample_dist;\t\t\tsample_1.x = Sample( temp );\n\t\n\tvec2 sample_3 = sample_1 * interp.y + sample_0 * interp_i.y;\n\treturn sample_3.y * interp.x + sample_3.x * interp_i.x;\n}\n\nfloat Hex_Point( vec2 pos, float sample_dist )\n{\n\tpos = hex_round( ToHex( pos / sample_dist ) ) * sample_dist;\n\t\n\treturn Sample_Hex( pos );\n}\nfloat Hex_Linear( vec2 pos, float sample_dist )\n{\n\tvec2 hex_pos = ToHex( pos / sample_dist );\n\t\n\tvec2 hex_center = hex_round( hex_pos );\n\tvec2 hex_frac = hex_pos - hex_center;\n\t\n\tfloat \n\tret  = linear_hex_spline( hex_frac               ) * Sample_Hex( (hex_center               ) * sample_dist );\n\tret += linear_hex_spline( hex_frac - vec2( 1, 0) ) * Sample_Hex( (hex_center + vec2( 1, 0) ) * sample_dist );\n\tret += linear_hex_spline( hex_frac - vec2( 0, 1) ) * Sample_Hex( (hex_center + vec2( 0, 1) ) * sample_dist );\n\tret += linear_hex_spline( hex_frac - vec2( 1,-1) ) * Sample_Hex( (hex_center + vec2( 1,-1) ) * sample_dist );\n\tret += linear_hex_spline( hex_frac - vec2(-1, 1) ) * Sample_Hex( (hex_center + vec2(-1, 1) ) * sample_dist );\n\tret += linear_hex_spline( hex_frac - vec2(-1, 0) ) * Sample_Hex( (hex_center + vec2(-1, 0) ) * sample_dist );\n\tret += linear_hex_spline( hex_frac - vec2( 0,-1) ) * Sample_Hex( (hex_center + vec2( 0,-1) ) * sample_dist );\n\t\n\treturn ret;\n}\n\n\n//---------------------------------------------------------------------------------------------\n//---------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//Position of pixel in sample space\n\tvec2 pos = ((fragCoord.xy / iResolution.xy) - vec2(.5,.5)) * vec2(2,2);\n\tfloat aspect_ratio = iResolution.x / iResolution.y;\n\tpos.y /= aspect_ratio;\n\t\n\t//Distance between samples in the virtual sampling grid\n\tfloat lerp = sin(iTime * .2)*.5 + .5;\n\tfloat sample_dist = .02;//.015 * lerp + .025 * (1.0 - lerp);\n\t\n\t//Window management\n\tfloat fHeight = Sample( pos );\n\tif( pos.x*2.0 > -pos.y )\n\t{\n\t\tif( pos.y < pos.x*2.0 ){\n\t\t\tfHeight = Square_Linear( pos, sample_dist );\n\t\t}else{\n\t\t\tfHeight = Hex_Point( pos, sample_dist );\n\t\t}\n\t}else{\n\t\tif( pos.y > pos.x*2.0 ){\n\t\t\tfHeight = Hex_Linear( pos, sample_dist );\n\t\t}else{\n\t\t\tfHeight = Square_Point( pos, sample_dist );\n\t\t}\n\t}\n\t\n#ifdef SHOW_SQR_ERROR\n\tfloat diff = (fHeight - Sample( pos ));\n\tfHeight = diff * diff * 80.0;\n#endif\n\t\n\tfragColor = vec4( fHeight, fHeight, fHeight, 1 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sfSW7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1688, 1714, 1748, 1748, 1947], [1949, 2378, 2402, 2402, 2480], [2481, 2481, 2511, 2511, 2618], [2621, 2880, 2906, 2906, 2988], [2989, 2989, 3023, 3023, 3063], [3065, 3296, 3328, 3328, 3686], [3688, 3847, 3888, 3888, 4603], [4605, 4870, 4921, 4921, 5016], [5017, 5017, 5069, 5069, 5617], [5619, 5619, 5667, 5667, 5760], [5761, 5761, 5810, 5810, 6740], [6743, 6935, 6992, 7029, 7856]]}
{"id": "4sfXRB", "name": "Acid! at the Disco", "author": "TomoAlien", "description": "Remixed my shader into something super gnarly.", "tags": ["plasma", "colorful", "trippy", "disco", "strange", "acid", "trip"], "likes": 10, "viewed": 697, "date": "1403012272", "time_retrieved": "2024-06-20T18:11:23.609163", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfloat time = iTime;\n\tfloat depth = sin(uv.y*2.0+sin(time)*1.5+1.0+sin(uv.x*3.0+time*1.2))*cos(uv.y*2.0+time)+sin((uv.x*3.0+time));\n\tfloat texey = (uv.x-0.5);\n\tfloat xband = sin(sqrt(uv.y/uv.y)*16.0/(depth)+time*3.0);\n\tfloat final = (\n\t\tsin(texey/abs(depth)*32.0+time*16.0+sin(uv.y*uv.x*32.0*sin(depth*3.0)))*(depth)*xband\n\t);\n\n\t\n\tfragColor = vec4(-final*abs(sin(time)),(-final*sin(time)*2.0),(final),1.0)*1.5;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sfXRB.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 512]]}
{"id": "4slSzB", "name": "FunctionSupport", "author": "cyanux", "description": "Another method for plotting function. (TN definition : good value is 0.01 ; 0.5 is fun). Compatible with any functions ! No iteration !    [ <8O~ enabled (support rotation) ]", "tags": ["plot", "support"], "likes": 3, "viewed": 141, "date": "1403447018", "time_retrieved": "2024-06-20T18:11:23.615243", "image_code": "// Created by vincent francois - cyanux/2014\n// Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported License (CC BY-NC-ND 3.0)\n//\n// Plotting function on support\n//\n// From https://www.shadertoy.com/view/4slSzB\n//\n// vfrancois.pro@hotmail.fr\n\n#define TN 0.5\n\nvec2 R(vec2 p, float t) {\n\tfloat C = cos(t), S = sin(t);\n\treturn vec2(C*p.x-S*p.y,S*p.x+C*p.y);\n}\nfloat fn(vec2 A, vec2 B, vec2 U, float t, float f) {\n\tvec2 a = B - A;\n\tvec2 i = normalize(vec2(a.y, -a.x)) * f * .5 + a * t + A;\n\treturn dot(i-U,i-U);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat M = 6.28 * iMouse.x / iResolution.x;\n\tfloat T = iTime * .25;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 A = R(vec2( .5, .0), M) + .5;\n\tvec2 B = R(vec2(-.5, .0), M) + .5;\n\n\tfloat t = dot(B - A, uv - A);\n\tfloat d = 1024. * fn(A, B, uv, t, sin(T + t * 12.) * sin(T + t * 5.));\n\n\tuv = R(uv - 0.5, -M);\n\t\t   \n\tif(d < TN && d < .95)\n\t\tfragColor = vec4(d);\n\telse if(mod(uv.x, .1) < .005 || mod(uv.y, .1) < .005)\n\t\tfragColor = vec4(1., 0., 0., 0.);\n\telse\n\t\tfragColor = vec4(1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-nd-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4slSzB.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 271, 296, 296, 368], [369, 369, 421, 421, 521], [522, 522, 579, 579, 1064]]}
{"id": "4slXD7", "name": "Mandel Glow Swirl", "author": "TekF", "description": "The colours! Psychadelic version ", "tags": ["fractal"], "likes": 12, "viewed": 1708, "date": "1402517503", "time_retrieved": "2024-06-20T18:11:24.136311", "image_code": "// this looks prettier, but makes it less obvious that it's the same warp each time.\n#define LERP_AFTER\n\n#define ZOOM\n\n#define SPIN\n\nconst float tau = 6.2831853;\n\n//vec3 i = vec3(.5)+vec3(.5,-.5,-.5);\n//=> fcos st fcos(0) = 1, fcos(1/3) = -1, fcos(2/3) = -1\n// cos(tau/3) = -.5\n// = cos(tau*a); [-.5,1] -> [-1,1] = x+.5)/1.5)*2-1 = x*2/1.5-1/1.5\nfloat fcos( float a )\n{\n\t//return max(0.0,(cos( a )+.5)/1.5);\n\treturn pow( cos(a)*.5+.5, 2.0 );\n}\n\nvec3 Sample( vec2 p )\n{\n//\treturn vec3(pow(fract(5.0/(1.0+dot(p,p))),.1));\n\tfloat a = fract(4.0/(4.0+dot(p,p)));\n//\treturn pow(a,.1)*((sin(vec3(1)*a*6.28+vec3(1,2,3)*.6)*.5+.5)*.5+.5);\n\tvec3 col = vec3(1)*pow(vec3(a),vec3(10,1,.1));\n\t//return step(vec3(.1,.01,.001),vec3(a)); unknown error?!\n\n// todo: this is cos(atan()), which can be simplified\t\n\tfloat q = atan(p.x,p.y);\n#ifdef SPIN\n\tq -= iTime*1.0;\n#endif\n\tvec3 fc = vec3( fcos(q), fcos(q+tau/3.0), fcos(q+tau*2.0/3.0) );\n\treturn col.x*fc.xyz + col.y*fc.zxy + col.z*fc.yzx;\n}\n\nvec3 fractal( vec2 pos )\n{\n\tfloat F = fract(.02*iTime);\n\t\n\tvec2 C = (2.0*pos.xy-iResolution.xy) / iResolution.x;\n\t// position better to see the fractal\n#ifdef ZOOM\n\tC = mix( C*8.0+vec2(-4,0), C*.001+vec2(-1,-.3), smoothstep(0.2,1.0,F) );\n#else\n\tC = mix( C*8.0+vec2(-4,0), C*2.0+vec2(-1,0), pow(F,.5) );\n#endif\n\t\n\tvec2 Z = vec2(0);\n\t\n\t#define MAX 25\n\tfloat m = float(MAX);\n\tfloat n = exp2(F*log2(m))-1.0;//fract(.3*iTime/m)*m;\n\t\n#ifndef LERP_AFTER\n\t// blend towards the next one\n\tZ = C*fract(n);\n#endif\n\t\n\tfor ( int i=0; i < MAX; i++ )\n\t{\n\t\tif ( float(i) > n || dot(Z,Z) > exp2(120.0) ) // trap really big vals to prevent NaNs\n\t\t\tcontinue;\n\t\tZ = vec2( Z.x*Z.x-Z.y*Z.y, 2.0*Z.x*Z.y ) + C;\n\t}\n\n#ifdef LERP_AFTER\n\t// blend from the last one\n\tZ = mix( Z, vec2( Z.x*Z.x-Z.y*Z.y, 2.0*Z.x*Z.y ) + C, pow(smoothstep(0.0,1.0,fract(n)),4.0) );\n#endif\n\n\t// image map\n\tvec3 col = Sample(Z);\n\t\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// anti-aliasing\n\tfragColor.rgb  = fractal( fragCoord.xy + vec2(5,1)/8.0 );\n\tfragColor.rgb += fractal( fragCoord.xy + vec2(1,3)/8.0 );\n\tfragColor.rgb += fractal( fragCoord.xy + vec2(7,5)/8.0 );\n\tfragColor.rgb += fractal( fragCoord.xy + vec2(3,7)/8.0 );\n\tfragColor.rgb /= 4.0;\n\n\tfragColor.rgb = pow(fragColor.rgb,vec3(1.0/2.2));\n\tfragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4slXD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[163, 346, 369, 407, 443], [445, 445, 468, 519, 974], [976, 976, 1002, 1002, 1870], [1872, 1872, 1929, 1947, 2280]]}
{"id": "4slXW7", "name": "2D Voxels", "author": "nimitz", "description": "Insipred by iq's \"Hexagons - distance\" (https://www.shadertoy.com/view/Xd2GR3).  \n\nAny SDF can be used with the voxelize function, it also performs rather well with degenerate SDFs. Feel free to reuse for your shadertoys.", "tags": ["2d", "voxels", "sdf"], "likes": 61, "viewed": 2546, "date": "1402436501", "time_retrieved": "2024-06-20T18:11:24.136311", "image_code": "//2D Voxels by nimitz (stormoid.com) (twitter: @stormoid)\n\n//try the other maps\n#define MAP 1\n#define NUM_LAYERS 46.\n\n#define time iTime\n\nmat3 rotXY( vec2 angle ) \n{\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\t\n\treturn mat3(c.y      ,  0.0, -s.y,\n\t\t\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\t\t\ts.y * c.x, -s.x,  c.y * c.x\t);\n}\n\n#if MAP == 1\nfloat map( vec3 p ) \n{\n\t//vec3 q = mod(pos,c)-0.5*c;\n\tp *= rotXY(vec2(time*.9,time*0.6));\n\tconst float w = 1.5;\n\tvec3 q = abs(p);\n\tfloat d = max(max(q.z,q.y),q.x*0.15)-w;\n\tq*= .7;\n\td = min(d,max(max(q.z,q.x),q.y*0.15))-w;\n\tq*= .5;\n\td = min(d,max(max(q.x,q.y),q.z*0.15))-w;\n\t\n\treturn d;\n}\n#elif MAP == 2\n//sphere/cube subtract\nfloat map( vec3 p )\n{\n\tp *= rotXY(vec2(time*0.6,time*.9));\n\t\t\n\tfloat d1 = length(p)-20.;\n\tfloat d2 = length(max(abs(p)-16., 0.));\n\t\n\treturn max(d2, -d1);\t\n}\n#else\n//heightmap (can handle many layers, 200 works fine here)\nfloat map( vec3 p ) \n{\n\tp *= rotXY(vec2(0.5,10.6));\n\tp.y += sin(p.z*0.1+time)*(3.+sin(time)*1.);\n\tp.y += sin(p.x*0.5+time)*(3.+sin(time)*1.);\n\treturn length(p.y)-2.;\n}\n#endif\n\nvec3 lgt;\n\n//modified from iq's \"Hexagons - distance\" (https://www.shadertoy.com/view/Xd2GR3)\n//return values: x = trigger, y = voxel shading, z = distance to voxel edge, w = lighting\nvec4 voxelize( vec2 p, float bias ) \n{\n\t//displace based on layer\n\tp.x += 0.866025*bias;\n\tp.y += 0.5*bias;\n\t\n\t//setup coord system\n\tvec2 q = vec2( p.x*2.0*0.5773503, p.y + p.x*0.5773503 );\n\tvec2 pi = floor(q);\n\tvec2 pf = fract(q);\n\n\tfloat v = mod(pi.x + pi.y, 3.0);\n\n\tfloat ca = step(1.0,v);\n\tfloat cb = step(2.0,v);\n\tvec2  ma = step(pf.xy,pf.yx);\n\t\n    // distance to borders\n\tvec2 bz = 1.0-pf.yx + ca*(pf.x+pf.y-1.0) + cb*(pf.yx-2.0*pf.xy);\n\tfloat e = dot( ma, bz );\t\n\t\n\t//voxel shading\n\tfloat top = cb*ma.y+clamp((1.-(ca+ma.y)),0.,1.);\n\tfloat left = 0.5+step(ca,cb)*0.75;\n\t\n\tvec2 j = pi + ca - cb*ma;\n\tfloat sdf = map(vec3(j,bias));\n\t\n\t//faked light (using the normal only, actual lighting gets pretty heavy)\n\tfloat nl = max(dot(normalize(lgt),normalize(vec3(j,bias))),0.);\n\treturn vec4( step(sdf,.01),left+top, e, nl*2. );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    lgt =  vec3(4.+sin(time*0.4)*20.,4.+sin(time*.1)*10.,5.);\n    vec2 p = fragCoord.xy/iResolution.xy-0.5;\n\tp.x *= iResolution.x/iResolution.y;\n\tvec2 bp = p;\n\tp *= 100.+sin(time*0.5)*80.;\n\tp.x += sin(time)*10.;\n\tp.y += cos(time*0.9+0.5)*4.;\n\t\n\tfloat st = sin(time*0.2)*0.3+1.;\n\tvec3 col = vec3(0.);\n\tfor (float i=-NUM_LAYERS/2.;i<NUM_LAYERS/2.;i++) \n\t{\n\t\tvec4 rz = voxelize(p,i);\n\t\t//vec3 colx = (.95 + 0.8*sin( hash11(rz.x+i)*1.5 + 2.0 + vec3(1.5+i*0.2, st*1.5+i*0.1, 1.0+i*0.01) ))*rz.x*4.;\n\t\tvec3 colx = vec3(0.15+cos(time+0.1)*0.1,0.2,0.3+sin(time)*0.1)*rz.x*3.;\n\t\t//borders\n\t\t//colx *= smoothstep(0., 0.1, rz.z);\n\t\t//simple shading\n\t\tcolx *= .4+rz.z*.9;\n\t\t//voxel shading\n\t\tcolx *= rz.y*.5;\n\t\t//faked lighting\n\t\tcolx *= rz.w*0.5+0.5;\n\t\t//painter's algo\n\t\tcol = col*step(colx,vec3(0.))+colx;\n\t\t//max blending (transparency! :P)\n\t\t//col += colx*0.4;\n\t}\n\t\n\tfloat d = distance(lgt,vec3(p,1.));\n\tcol += 1.-smoothstep(0.92,1.,(d*.24));\n\t\n\tfragColor = vec4( col*1.3, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4slXW7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[59, 138, 165, 165, 320], [1069, 1242, 1280, 1307, 2070], [2073, 2073, 2131, 2131, 3106]]}
{"id": "4ssXW7", "name": "Rave Spiral", "author": "daeken", "description": "Having fun with distance fields over polar coords.", "tags": ["polar", "shaderforth"], "likes": 9, "viewed": 469, "date": "1402437848", "time_retrieved": "2024-06-20T18:11:24.578885", "image_code": "/* Compiled with Shaderforth: https://github.com/daeken/Shaderforth\n:globals\n\t@vec3 uniform =iResolution\n\t@float uniform =iTime\n\t@vec4 uniform =iDate\n;\n:m time iDate .w ;\n:m mtime iTime ;\n\n:m circle ( p r )\n\tp length r -\n;\n:m box ( p d )\n\t( p abs d - 0 max length )\n\tp abs d - =t\n\t\tt \\max 0 min\n\t\tt 0 max length\n\t+\n;\n:m roundbox ( p r d )\n\t p d box r -\n;\n\n:m intersect \\max ;\n:m union \\min ;\n:m subtract \\{ neg max } ;\n\n:m repeat! ( p c ) p c mod .5 c * - ;\n:m repeat ( f p c ) p c repeat! *f ;\n:m scale ( f p s ) p s / *f s length * ;\n:m rotate-cart ( f p a ) p a rotate-2d *f ;\n:m rotate ( f p a ) p [ a 0 ] + polar-norm *f ;\n\n: distance-field ( p:vec2 -> vec4 )\n\tp .y mtime 10 / p .y mtime + + sin 2 * * =a\n\t{ ( tp )\n\t\t{ ( rp )\n\t\t\tp [ a 0 ] + rp - logpolar->cart =xp\n\t\t\t[\n\t\t\t\t\t\trp\n\t\t\t\t\t\ttau 40 /\n\t\t\t\t\tbox\n\t\t\t\t\t\trp\n\t\t\t\t\t\ttau 40 /\n\t\t\t\t\tcircle\n\t\t\t\t\txp .y 10 * sin abs\n\t\t\t\tmix\n\t\t\t\t[\n\t\t\t\t\txp .y xp .x + 10 * sin 360 * abs\n\t\t\t\t\txp .x 17 * sin abs\n\t\t\t\t\txp .y 13 * sin abs\n\t\t\t\t] hsv->rgb\n\t\t\t]\n\t\t} tp tau 20 / repeat\n\t} p mtime - a rotate\n;\n\n:m texture ( d p )\n\tp distance-field .yzw =mat\n\t[ d neg 20 * 0 1 clamp mat * ]\n;\n\niResolution frag->position cart->logpolar =p\n[ p { distance-field .x } gradient p texture 1 ] =fragColor\n*/\n\nvec2 cart_logpolar(vec2 p) {\n\treturn vec2(atan((p).y, (p).x), log(length(p)));\n}\nvec3 hsv_rgb(vec3 hsv) {\n\treturn (mix(vec3(1.0, 1.0, 1.0), clamp((abs((mod((((hsv).x) / 60.0) + (vec3(0.0, 4.0, 2.0)), 6.0)) - 3.0)) - 1.0, 0.0, 1.0), (hsv).y)) * ((hsv).z);\n}\nvec2 polar_norm(vec2 p) {\n\treturn vec2(mod(((p).x) + 6.28318, 6.28318), (p).y);\n}\nvec2 logpolar_cart(vec2 p) {\n\treturn (vec2(cos((p).x), sin((p).x))) * (pow(2.71828, (p).y));\n}\nvec4 distance_field(vec2 p) {\n\tfloat a = ((p).y) * ((sin(((iTime) / 10.0) + (((p).y) + (iTime)))) * 2.0);\n\tvec2 xp = logpolar_cart(((p) + (vec2(a, 0.0))) - ((mod(polar_norm(((p) - (iTime)) + (vec2(a, 0.0))), 0.314159)) - 0.1570795));\n\tvec2 t = (abs((mod(polar_norm(((p) - (iTime)) + (vec2(a, 0.0))), 0.314159)) - 0.1570795)) - 0.1570795;\n\treturn vec4(mix((min(max((t).x, (t).y), 0.0)) + (length(max(t, 0.0))), (length((mod(polar_norm(((p) - (iTime)) + (vec2(a, 0.0))), 0.314159)) - 0.1570795)) - 0.1570795, abs(sin(((xp).y) * 10.0))), hsv_rgb(vec3(abs((sin((((xp).y) + ((xp).x)) * 10.0)) * 360.0), abs(sin(((xp).x) * 17.0)), abs(sin(((xp).y) * 13.0)))));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = cart_logpolar((((((fragCoord).xy) / ((iResolution).xy)) * 2.0) - 1.0) * (vec2(1.0, ((iResolution).y) / ((iResolution).x))));\n\tvec2 h = vec2(0.001, 0.0);\n\tvec3 mat = (distance_field(p)).yzw;\n\tfragColor = vec4(vec3((clamp((- (((distance_field(p)).x) / (abs(length((vec2(((distance_field((p) + (h))).x) - ((distance_field((p) - (h))).x), ((distance_field((p) + ((h).yx))).x) - ((distance_field((p) - ((h).yx))).x))) / (2.0 * ((h).x))))))) * 20.0, 0.0, 1.0)) * (mat)), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ssXW7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 1227, 1255, 1255, 1307], [1308, 1308, 1332, 1332, 1483], [1484, 1484, 1509, 1509, 1565], [1566, 1566, 1594, 1594, 1660], [1661, 1661, 1690, 1690, 2317], [2318, 2318, 2375, 2375, 2858]]}
{"id": "4ssXzB", "name": "Commodore", "author": "sander", "description": "Commodore sign in a flag like motion", "tags": ["commodore"], "likes": 2, "viewed": 201, "date": "1403470396", "time_retrieved": "2024-06-20T18:11:24.585052", "image_code": "const vec3 black = vec3(0);\nconst vec3 white = vec3(1);\nconst vec3 blue = vec3(0,0,192./255.);\nconst vec3 red = vec3(1,40./255.,0);\n\nbool cosign(vec2 t) {\n\treturn (t.x > 0. && t.x < 49. && t.y > 0. && t.y < 23.) &&\n\t\t! (t.x > 26. && (t.x - 26.) > t.y);\n}\n\nvec3 commodore(vec2 p) {\n\t\n\tif(length(p) < 62.0 && length(p) > 34.0 && p.x < 17.0) {\n\t\treturn blue;\n\t}\n\t\n\tvec2 t = p - vec2(20., 2.);\n\tif(cosign(t)) {\n\t\treturn blue;\n\t}\n\n\tp.y *= -1.;\n\t\n\tvec2 t2 = p - vec2(20., 2.);\n\tif(cosign(t2)) {\n\t\treturn red;\n\t}\n\treturn white;\n}\n\nconst float wave = 5.0;\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 color;\n\t\n\tvec2 p = (fragCoord.xy/iResolution.xy)-vec2(0.5);\n\tp.x *= iResolution.x/iResolution.y;\n\n\tfloat t = iTime * 2.0;\n\t\n\tvec2 zp = p * 150.;\n\t\n\tvec2 displace = vec2( sin(t - (p.y*wave)), -cos(t - (p.x*wave)) );\n\tzp += 5. * displace;\n\t\n\tcolor = commodore(zp);\n\n\tif(color == white) {\n\t\tfloat interlace = mod(fragCoord.y,2.);\n\t\tcolor = mix(black, white, 0.5 + 0.5 * interlace);\n\t}\n\t\n\t// stolen from:\n\t// https://www.shadertoy.com/view/4djGz1\n\tvec2 uv = fragCoord.xy / iResolution.xy*2.-1.;\n\tcolor = mix(black, color, 0.5 + pow(max(0.,1.0-length(uv*uv*uv*vec2(1.00,1.1))),1.));\n\t\n\tfragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ssXzB.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[133, 133, 154, 154, 254], [256, 256, 280, 280, 522], [549, 549, 569, 569, 641], [643, 643, 700, 700, 1318]]}
{"id": "4sXSz2", "name": "Chrono Trigger : Sides", "author": "bluebug", "description": "Created to help a fellow programmer", "tags": ["2d"], "likes": 5, "viewed": 710, "date": "1403815473", "time_retrieved": "2024-06-20T18:11:24.585052", "image_code": "float PI = 3.14159265359;\n\nfloat RATIO_SPINS_PEED = 5.2;\nfloat RATIO_SPIN_POWER = .1;\nfloat RATIO_DIVIDE = 20.0;\nfloat getAngle(vec2 uvCenter){\n\tfloat angle = atan(uvCenter.y,uvCenter.x )/(2.0*PI);\n\tif(angle <0.0) angle +=1.0;\n\treturn angle;\n}\nfloat getDis(vec2 v){\n\treturn sqrt(v.x* v.x + v.y*v.y);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 uvCenter = uv - vec2(.5,1.0);\n\tfloat angle = getAngle(uvCenter);\n\tfloat dis = getDis(uvCenter) ;\n\tangle = angle+ cos(dis*PI - iTime*RATIO_SPINS_PEED)*RATIO_SPIN_POWER;\n\t\n\tfloat color = cos(angle*2.0*PI*RATIO_DIVIDE);\n\tfragColor = vec4(color*0.2, color*.1,color*.9,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sXSz2.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[113, 113, 143, 143, 243], [244, 244, 265, 265, 301], [302, 302, 359, 359, 677]]}
{"id": "4sXXD7", "name": "Terrain, Light, Fog, Hello World", "author": "villain749", "description": "Another super basic attempt at learning the basics... Raymarching, terrain intersection, generating normals, creating lights. All of this is super rough, as I just trying to get the basic concepts.", "tags": ["terrain", "raymarch", "helloworld", "light", "fog"], "likes": 4, "viewed": 229, "date": "1401951749", "time_retrieved": "2024-06-20T18:11:25.124283", "image_code": "// An attempt at learning the basics... Raymarching, terrain intersection, \n// generating normals, creating lights. All of this is super rough, as I just \n// trying to get the basic concepts. It actally looks really cool if you \n// turn the ray steps down to 10 or 15\n\n\nconst int RAY_STEPS = 400;\nconst float MIN_DIST = 0.5;\nconst float NORM_SEARCH_DIST = 0.5;\nconst float SPEED = 0.55;\nconst vec3 LIGHT = vec3(0.15, .22, 0.3);\n\n\n// using animated sin and cos to make a floor terrain\nvec3 intersectFloor(const vec3 test){ \n\tfloat sinHeight = sin((test.z + iTime * -SPEED * 2.0) * 0.5);\n\tfloat cosHeight = cos(test.x + iTime * -SPEED);\n\tfloat bigWave = sin((test.z + iTime * -SPEED * 6.0) * 0.15) * 2.8;\n\treturn vec3(test.x, max(sinHeight, cosHeight) + bigWave, test.z);\n}\n\n// make a triangle by sampling the depth at 3 points, \n// then get the cross product;\nvec3 calculateFloorNormal(const vec3 base ) {\n\tvec3 A = intersectFloor(base);\n\tvec3 B = intersectFloor(vec3(base.x + NORM_SEARCH_DIST, base.yz));\n\tvec3 C = intersectFloor(vec3(base.xy, base.z + NORM_SEARCH_DIST));\n\treturn normalize(cross(C - A, B - A));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t// uv coord\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\t// camera stuff\n\tvec3 camPos = vec3(15.0, 8.0,15.0);\n\tvec3 camNorm = vec3(0.653, 0.383, 0.653);\n\t// camera attributes\n\tfloat camNear = 10.0;\n\tfloat camFar = 45.0;\n\tfloat camHFOV = 65.0;\n\tfloat camVFOV = 35.0;\n\t// camera matrix\n\tvec3 camXAxis = cross(vec3(0.0, 1.0, 0.0), camNorm);\n\tcamXAxis =  normalize(camXAxis);\n\tvec3 camYAxis = cross(camNorm, camXAxis);\n\tmat3 camRotMat = mat3(camXAxis, camYAxis, camNorm);\n\t\n\t//ray vector\n\tvec3 raySt = vec3(0.0, 0.0, -camNear);\n\tfloat nearW = tan(camHFOV * .5 * .01745) * abs(camNear);\n\traySt.x = (nearW * uv.s * 2.0) - nearW;\n\tfloat nearH = tan(camVFOV * .5 * .01745) * abs(camNear);\n\traySt.y = (nearH * uv.t * 2.0) - nearH;\n\t// run the ray through the cameras rotation matrix, and add it's position\n\traySt = (camRotMat * raySt) + camPos;\n\tvec3 rayDir = normalize(raySt - camPos);\n\tvec3 rayInc = rayDir * ((abs(camFar) - abs(camNear)) / float(RAY_STEPS));\n\t\n\t// march\n\tvec3 result = vec3(1.0, 0.0, 1.0);\n\tvec3 curPos = raySt;\n\tfor (int i = 0; i < RAY_STEPS; ++i) {\n\t\tif (i == RAY_STEPS - 1) {\n\t\t\tresult = mix(vec3(0.15, 0.15, 0.15), vec3(0.6, 0.05, 0.8), uv.t);\t\t\t\n\t\t}\n\t\tif (distance(curPos, intersectFloor(curPos)) < MIN_DIST) {\n\t\t\t// getting a depth map of sorts?\n\t\t\tfloat dist = float(i) / float(RAY_STEPS) * .75;\n\t\t    vec3 depth = vec3(1.0 - dist);\n\t\t\t// find surface normal\n\t\t\tvec3 norm = calculateFloorNormal(curPos);\n\t\t\t// use dot product to find angle between light and floor..\n\t\t\t// The light seems upside down for some reason?\n\t\t\tfloat lightAngle =  dot(norm, LIGHT) * 2.0;\n\t\t\tresult = vec3(0.15, 0.85, 0.2) * lightAngle;\n\t\t\t// trying to do specularity, but this doesnt work very well\n\t\t\tresult += pow(lightAngle, 35.25) * 60000.0;\n\t\t\t// mixing depth against background color to make a fog effect\n\t\t\tresult =   mix(result, vec3(0.6, 0.05, 0.8), clamp(1.0 - depth * 1.5, 0.0, 1.0));\n\t\t\tbreak;\n\t\t}\n\t\tcurPos += rayInc;\n\t}\n\t\n\n\tfragColor = vec4(result, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sXXD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[430, 484, 521, 521, 771], [773, 859, 904, 904, 1114], [1118, 1118, 1175, 1188, 3140]]}
{"id": "4sXXWM", "name": "metaballss", "author": "pailhead", "description": "kept getting unknown error\nI've been meaning to play with shadertoy examples for a while but i've been too intimidated :)\nI figured, before i jump in, try a simple 2d effect.\nWith quads:\nhttp://dusanbosnjak.com/test/webGL/new/gui_color/ring.html\n", "tags": ["metaball"], "likes": 16, "viewed": 1773, "date": "1401673549", "time_retrieved": "2024-06-20T18:11:25.724300", "image_code": "\n\n#define NUMmb 3\n\n\n//heya, \n//quick n dirty effect\n//pretty much the same thing but\n//with quads and generated textures:\n//http://dusanbosnjak.com/test/webGL/new/gui_color/ring.html\n\n\n\nfloat  rn(float xx){\n        float v0 = fract(sin(xx*.4686)*3718.927);          \n        return v0;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat ts = iTime *.6;//time scaled\n\t\n\tvec3 COLOR_MASKS[16];//blob colors\n\tCOLOR_MASKS[0] = vec3( 0.20, 0.30, 1.0 );\n  \tCOLOR_MASKS[1] = vec3( 0.53, 0.85, 0.25 );\n  \tCOLOR_MASKS[2] = vec3( 1.0, 0.56, 0.15 );\n  \tCOLOR_MASKS[3] = vec3( 1.0, 0.0, 0.3 );\n  \tCOLOR_MASKS[4] = vec3( 0.05, 0.55, .30 );\n\tCOLOR_MASKS[5] = vec3( 0.5, 1.0, .40 );\n  \tCOLOR_MASKS[6] = vec3( 1.0, 0.15, 1.0 );\n  \tCOLOR_MASKS[7] = vec3( .20, .30, 0.5 );\n  \tCOLOR_MASKS[8] = vec3( .350, 1.0, 0.5 );\n  \tCOLOR_MASKS[9] = vec3( .70, .60, 0.5 );\n  \tCOLOR_MASKS[10] = vec3( .34, 1., 0.5 );\n  \tCOLOR_MASKS[11] = vec3( .20, .50, 0.5 );\n  \tCOLOR_MASKS[12] = vec3( 0.60, .10, 0.65 );\n  \tCOLOR_MASKS[13] = vec3( .40, .40, 0.85 );\n  \tCOLOR_MASKS[14] = vec3( 1.0, .30, 0.35 );\n  \tCOLOR_MASKS[15] = vec3( 1.0, 0.0, 0.5 );\n\t\n\t//screen space\n\tvec2 fragP = ( fragCoord.xy / iResolution.xy );\n\tvec2 fragPN = fragP * 2. - 1.; //-1 1\n\tfloat as = iResolution.x/iResolution.y;\n\tfragPN.x *= as; //aspect\n\t// vec2 mouseP = fragP - mouse; //mouse\n\tfloat vH = 10.0;//camera disance - fov\n\tvec3 vD = normalize(vec3(-fragPN,vH));//view dir\n\tvec3 lD = normalize(vec3(cos(iTime),.750,sin(iTime)));//light dir\t\n\t//vec3 ld = normalize(vec3(.7, .750,2.));\n\t\n\tvec2 mbPos[NUMmb];\n\tvec3 nn = vec3(.0);\n\tvec3 cc = vec3(.0);\n\n\tfor(int i=0; i<NUMmb; i++){\n\t\tfloat rn1 = rn(float(i+54));\n\t\tfloat rn2 = rn(float(i-222));\n\t\tfloat rn3 = rn(float(i-262));\n\t\tmbPos[i] = vec2(\n\t\t\tsin(rn1*6.14+ts * rn2)*as,\n\t\t\tcos(rn2*6.14+ts * rn3)\n\t\t);\n\t\tmbPos[i] = fragPN - mbPos[i]*.8;\n\t\tfloat rr = cos(rn3*6.28+ts * rn1)*.2+.5;\n\t\tmbPos[i] *= rr*20.;//blob coord\n\t\tfloat bL = length( mbPos[i] );//bl length\n\t\tfloat bA = smoothstep( 1.0, 0.97, bL );\n\t\tfloat bH = exp(-bL*2.15678);\n\t\tvec3 bN = vec3(mbPos[i]*.3*bH,bH-.01);\n\t\tvec3 bC=COLOR_MASKS[i];\n\t\tbC*=bH;\n\t\tnn += vec3(mbPos[i]*.5*bH,bH);\n\t\tcc += bC;\n\t}\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\t\n\tvec2 mB = fragPN - (mouse.xy*2.-1.)*vec2(as,1.);\n\tmB*=6.;\n\tfloat mBL = length( mB );\n\tfloat mBH = exp(-mBL*2.15678);\n\tvec3 mBN = vec3(mB*.5*mBH, mBH);\n\tvec3 mBC = vec3(1.,.0,.0);\n\tmBC*=mBH;\n\t\n\t\t//float sq = float( //quad\n\t\t//\t(mB.x<1.&&mB.x>-1.)\n\t\t//\t&&\n\t\t//\t(mB.y<1.&&mB.y>-1.)\n\t\t//);\n\t\n\tnn+=mBN;\n\t\n\t\n\tvec3 n = normalize( vec3(nn.x,nn.y,nn.z-.01) );\n\tfloat aB = smoothstep(0.0,.01,n.z);\n\tcc+=mBC;\n\tcc/=nn.z;\n\t//n *= aB;\n\tfloat ndl = dot(n,lD)*.5+.5;//wrap\t\n\t//float ndl = dot(n,lD);//wrap\n\tndl = ndl*.7+.3;\n\tvec3 h = normalize(vD+lD);\n\tfloat ndh = dot(n,h);\n\tndh = ndh*.5+.5;\n\tndh = pow(ndh,70.5)*.35;\n\tvec3 fc = cc*ndl+ndh;\n\t\n\tfloat frs = dot(n,vD);\n\tfrs = 1.0-clamp(frs,.0,1.);\n\tfrs = pow(frs,2.0);\n\tfrs = frs*.4+.121;\n\tfc+=frs;\n\t\n\tfloat color = 0.0;\n\tfragColor = vec4( fc*aB, 1.);\n\t\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sXXWM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[20, 186, 206, 206, 287], [288, 288, 345, 345, 2995]]}
{"id": "ldfXzB", "name": "Ray Fog", "author": "demofox", "description": "Some raytraced fog.  Using definite integrals of sine waves to make some variation in the fog density.  Could probably be refined some more to look nicer.  No reflect or refract due to instruction count limits ):\nDrag the mouse to move the camera.", "tags": ["3d", "raytracing", "fog"], "likes": 7, "viewed": 920, "date": "1403370610", "time_retrieved": "2024-06-20T18:11:28.888431", "image_code": "// TODO: try different amplitudes and frequencies\n\n\n/*\n  Written by Alan Wolfe\n  http://demofox.org/\n  http://blog.demofox.org/\n*/\n\n//=======================================================================================\n\n#define FLT_MAX 3.402823466e+38\n\n//=======================================================================================\nstruct SMaterial\n{\n\tvec3 m_diffuseColor;\n\tfloat m_specular;\n\tvec3 m_specularColor;\n};\n\n//=======================================================================================\nstruct SCollisionInfo\n{\n\tint\t\t\tm_Id;\n\tbool\t\tm_foundHit;\n\tbool \t\tm_fromInside;\n\tfloat \t\tm_collisionTime;\n\tvec3\t\tm_intersectionPoint;\n\tvec3\t\tm_surfaceNormal;\n\tSMaterial \tm_material;\n};\n\n//=======================================================================================\nstruct SSphere\n{\n\tint\t\t\tm_Id;\n\tvec3   \t\tm_center;\n\tfloat  \t\tm_radius;\n\tSMaterial\tm_material;\n};\n\t\n//=======================================================================================\nstruct SAxisAlignedBox\n{\n\tint\t\t\tm_Id;\n\tvec3\t\tm_pos;\n\tvec3\t\tm_scale;\n\tSMaterial\tm_material;\n};\n\t\n//=======================================================================================\nstruct SPointLight\n{\n\tvec3\t\tm_pos;\n\tvec3\t\tm_color;\n};\n\t\n//=======================================================================================\nstruct SDirLight\n{\n\tvec3\t\tm_reverseDir;\n\tvec3\t\tm_color;\n};\n\t\n//=======================================================================================\nstruct SShadingStackItem\n{\n\tvec3\t\tm_addColor;\n\tvec4\t\tm_fogColorAndAmount;\n};\n\t\n//=======================================================================================\n// Scene parameters\n//=======================================================================================\n\t\n//----- settings\n#define DO_SHADOWS true // setting this to false will speed up rendering\n\t\n//----- camera\n#define mouse (iMouse.xy / iResolution.xy)\n\nvec3 getCameraPos ()\n{\n\treturn iMouse.z > 0.0 ? vec3(mouse.x * -8.0 + 4.0, 1.0, mouse.y*8.0 - 8.0) : vec3(0,1.0,-4.0);\n}\n\nvec3 getCameraAt ()\n{\n\tvec3 pos = getCameraPos();\n\t\n\treturn pos + vec3(0.0,-1.0,4.0);\n}\n\n#define cameraPos\t getCameraPos()\n#define cameraAt \tgetCameraAt()\n\n#define cameraFwd  normalize(cameraAt - cameraPos)\n#define cameraLeft  normalize(vec3(-1.0,0.0,0.0))\n#define cameraUp   normalize(cross(cameraLeft, cameraFwd))\n\n#define cameraViewWidth\t6.0\n#define cameraViewHeight cameraViewWidth * iResolution.y / iResolution.x\nfloat cameraDistance\t= 6.0;  // intuitively backwards!\n\n//----- shading stack\nSShadingStackItem shadingStack;\n\n//----- lights\nvec3 lightAmbient\t\t\t\t= vec3(0.1,0.1,0.1);\n\nvec3 fogColor = vec3(0.5,0.5,0.5);\n\nSDirLight lightDir1 =\n\tSDirLight\n\t(\n\t\tnormalize(vec3(-1.0,1.0,-1.0)),\n\t\tvec3(1.0,1.0,1.0)\n\t);\n\nSPointLight GetLightPoint1()\n{\n\treturn SPointLight\n\t(\n\t\tvec3(sin(1.57 + iTime*1.3),0.3,cos(1.57 + iTime*1.3)),\n\t\tvec3(0.7,0.3,0.7)\n\t);\n}\n\n\n#define lightPoint1 GetLightPoint1()\n\n//----- primitives\nSSphere GetLightPoint1Sphere()\n{\n\treturn SSphere\n\t(\n\t\t1,\t\t\t\t\t\t//id\n\t\tlightPoint1.m_pos,\t\t//center\n\t\t0.06,\t\t\t\t\t//radius\n\t\tSMaterial\n\t\t(\n\t\t\tlightPoint1.m_color,//diffuse color\n\t\t\t1.0,\t\t\t\t//specular amount\n\t\t\tvec3(0.0,0.0,0.0)\t//specular color\n\t\t)\n\t);\t\n}\n\n#define lightPoint1Sphere GetLightPoint1Sphere()\n\nSSphere GetSphere1()\n{\n\treturn SSphere\n\t(\n\t\t2,\t\t\t\t\t\t//id\n\t\tvec3(0.0,0.0,0.0),\t\t//center\n\t\t0.2,\t\t\t\t\t//radius\n\t\tSMaterial\n\t\t(\n\t\t\tvec3(0.0,1.0,0.0),\t//diffuse color\n\t\t\t10.0,\t\t\t\t//specular amount\n\t\t\tvec3(1.0,1.0,1.0)\t//specular color\n\t\t)\n\t);\n}\n\n#define sphere1 GetSphere1()\n\nSSphere GetSphere2()\n{\n\treturn SSphere\n\t(\n\t\t3,\t\t\t\t\t\t//id\n\t\tvec3(sin(iTime*1.3),sin(3.14 + iTime * 1.4)*0.25,cos(iTime*1.3)),\t//center\n\t\t0.15,\t\t\t\t\t//radius\n\t\tSMaterial\n\t\t(\n\t\t\tvec3(0.0,1.0,1.0),\t//diffuse color\n\t\t\t3.0,\t\t\t\t//specular amount\n\t\t\tvec3(1.0,1.0,1.0)\t//specular color\n\t\t)\n\t);\n}\n\n#define sphere2 GetSphere2()\n\nSAxisAlignedBox GetOrbitBox()\n{\n\treturn SAxisAlignedBox\n\t(\n\t\t4,\t\t\t\t\t\t//Id\n\t\tvec3(sin(2.0 + iTime*1.3),-0.2,cos(2.0 + iTime*1.3)),\t//center\n\t\tvec3(0.5,0.5,0.5),\t//scale\n\t\tSMaterial\n\t\t(\n\t\t\tvec3(1.0,0.0,0.0),\t//diffuse color\n\t\t\t20.0,\t\t\t\t//specular amount\n\t\t\tvec3(1.0,1.0,1.0)\t//specular color\n\t\t)\n\t);\n}\n\n#define orbitBox GetOrbitBox()\n\nSAxisAlignedBox GetFloorBox()\n{\n\treturn SAxisAlignedBox\n\t(\n\t\t5,\t\t\t\t\t\t//Id\n\t\tvec3(0.0,-1.6,0.0),\t\t//center\n\t\tvec3(10.0,0.1,10.0),\t//scale\n\t\tSMaterial\n\t\t(\n\t\t\tvec3(1.0,1.0,1.0),\t//diffuse color\n\t\t\t20.0,\t\t\t\t//specular amount\n\t\t\tvec3(0.0,0.0,0.0)\t//specular color\n\t\t)\n\t);\n}\n\n#define floorBox GetFloorBox()\n\nSAxisAlignedBox GetbackBox1()\n{\n\treturn SAxisAlignedBox\n\t(\n\t\t6,\t\t\t\t\t\t//Id\n\t\tvec3(0.0,0.0,3.0),\t\t//center\n\t\tvec3(10.0,3.0,0.1),\t\t//scale\n\t\tSMaterial\n\t\t(\n\t\t\tvec3(0.0,0.0,0.8),  //diffuse color\n\t\t\t20.0,\t\t\t\t//specular amount\n\t\t\tvec3(0.0,0.0,0.0)\t//specular color\n\t\t)\n\t);\n}\n\n#define backBox1 GetbackBox1()\n\nSSphere GetfloorSphere1()\n{\n\treturn SSphere\n\t(\n\t\t7,\t\t\t\t\t\t//id\n\t\tvec3(1.5, -1.0, 0.0),\t//center\n\t\t0.2,\t\t\t\t\t//radius\n\t\tSMaterial\n\t\t(\n\t\t\tvec3(0.8,0.8,0.0),\t//diffuse color\n\t\t\t3.0,\t\t\t\t//specular amount\n\t\t\tvec3(1.0,1.0,1.0)\t//specular color\n\t\t)\n\t);\n}\n\nSSphere GetfloorSphere2()\n{\n\treturn SSphere\n\t(\n\t\t8,\t\t\t\t\t\t//id\n\t\tvec3(1.5, -1.0, 1.0),\t//center\n\t\t0.2,\t\t\t\t\t//radius\n\t\tSMaterial\n\t\t(\n\t\t\tvec3(0.8,0.8,0.0),\t//diffuse color\n\t\t\t3.0,\t\t\t\t//specular amount\n\t\t\tvec3(1.0,1.0,1.0)\t//specular color\n\t\t)\n\t);\n}\n\nSSphere GetfloorSphere3()\n{\n\treturn SSphere\n\t(\n\t\t9,\t\t\t\t\t\t//id\n\t\tvec3(1.5, -1.0, 2.0),\t//center\n\t\t0.2,\t\t\t\t\t//radius\n\t\tSMaterial\n\t\t(\n\t\t\tvec3(0.8,0.8,0.0),\t//diffuse color\n\t\t\t3.0,\t\t\t\t//specular amount\n\t\t\tvec3(1.0,1.0,1.0)\t//specular color\n\t\t)\n\t);\n}\n\n#define floorSphere1 GetfloorSphere1()\n#define floorSphere2 GetfloorSphere2()\n#define floorSphere3 GetfloorSphere3()\n\n//----- macro lists\n\n// sphere primitive list\n#define SPHEREPRIMLIST PRIM(sphere1) PRIM(sphere2) PRIM(floorSphere1) PRIM(floorSphere2) PRIM(floorSphere3)\n\n// sphere primitive list with light primitives\n#define SPHEREPRIMLISTWITHLIGHTS SPHEREPRIMLIST PRIM(lightPoint1Sphere)\n\n// box primitive list\n#define BOXPRIMLIST PRIM(orbitBox) PRIM(floorBox) PRIM(backBox1)\n\n// point light list\n#define POINTLIGHTLIST LIGHT(lightPoint1)\n\n// directional light list\n#define DIRLIGHTLIST LIGHT(lightDir1)\n\n//=======================================================================================\nbool RayIntersectSphere (in SSphere sphere, inout SCollisionInfo info, in vec3 rayPos, in vec3 rayDir, in int ignorePrimitiveId)\n{\n\tif (ignorePrimitiveId == sphere.m_Id)\n\t\treturn false;\n\n\t//get the vector from the center of this circle to where the ray begins.\n\tvec3 m = rayPos - sphere.m_center;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.m_radius * sphere.m_radius;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn false;\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn false;\n\n\t//not inside til proven otherwise\n\tbool fromInside = false;\n\n\t//ray now found to intersect sphere, compute smallest t value of intersection\n\tfloat collisionTime = -b - sqrt(discr);\n\n\t//if t is negative, ray started inside sphere so clamp t to zero and remember that we hit from the inside\n\tif(collisionTime < 0.0)\n\t{\n\t\tcollisionTime = -b + sqrt(discr);\n\t\tfromInside = true;\n\t}\n\n\t//enforce a max distance if we should\n\tif(info.m_collisionTime >= 0.0 && collisionTime > info.m_collisionTime)\n\t\treturn false;\n\n\t// set all the info params since we are garaunteed a hit at this point\n\tinfo.m_fromInside = fromInside;\n\tinfo.m_collisionTime = collisionTime;\n\tinfo.m_material = sphere.m_material;\n\n\t//compute the point of intersection\n\tinfo.m_intersectionPoint = rayPos + rayDir * info.m_collisionTime;\n\n\t// calculate the normal\n\tinfo.m_surfaceNormal = info.m_intersectionPoint - sphere.m_center;\n\tinfo.m_surfaceNormal = normalize(info.m_surfaceNormal);\n\n\t// we found a hit!\n\tinfo.m_foundHit = true;\n\tinfo.m_Id = sphere.m_Id;\n\treturn true;\n}\n\n//=======================================================================================\nbool RayIntersectAABox (in SAxisAlignedBox box, inout SCollisionInfo info, in vec3 rayPos, in vec3 rayDir, in int ignorePrimitiveId)\n{\n\tif (ignorePrimitiveId == box.m_Id)\n\t\treturn false;\n\t\n\tfloat rayMinTime = 0.0;\n\tfloat rayMaxTime = FLT_MAX;\n\t\n\t//enforce a max distance\n\tif(info.m_collisionTime >= 0.0)\n\t{\n\t\trayMaxTime = info.m_collisionTime;\n\t}\t\n\t\n\t// find the intersection of the intersection times of each axis to see if / where the\n\t// ray hits.\n\tfor(int axis = 0; axis < 3; ++axis)\n\t{\n\t\t//calculate the min and max of the box on this axis\n\t\tfloat axisMin = box.m_pos[axis] - box.m_scale[axis] * 0.5;\n\t\tfloat axisMax = axisMin + box.m_scale[axis];\n\n\t\t//if the ray is paralel with this axis\n\t\tif(abs(rayDir[axis]) < 0.0001)\n\t\t{\n\t\t\t//if the ray isn't in the box, bail out we know there's no intersection\n\t\t\tif(rayPos[axis] < axisMin || rayPos[axis] > axisMax)\n\t\t\t\treturn false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//figure out the intersection times of the ray with the 2 values of this axis\n\t\t\tfloat axisMinTime = (axisMin - rayPos[axis]) / rayDir[axis];\n\t\t\tfloat axisMaxTime = (axisMax - rayPos[axis]) / rayDir[axis];\n\n\t\t\t//make sure min < max\n\t\t\tif(axisMinTime > axisMaxTime)\n\t\t\t{\n\t\t\t\tfloat temp = axisMinTime;\n\t\t\t\taxisMinTime = axisMaxTime;\n\t\t\t\taxisMaxTime = temp;\n\t\t\t}\n\n\t\t\t//union this time slice with our running total time slice\n\t\t\tif(axisMinTime > rayMinTime)\n\t\t\t\trayMinTime = axisMinTime;\n\n\t\t\tif(axisMaxTime < rayMaxTime)\n\t\t\t\trayMaxTime = axisMaxTime;\n\n\t\t\t//if our time slice shrinks to below zero of a time window, we don't intersect\n\t\t\tif(rayMinTime > rayMaxTime)\n\t\t\t\treturn false;\n\t\t}\n\t}\n\t\n\t//if we got here, we do intersect, return our collision info\n\tinfo.m_fromInside = (rayMinTime == 0.0);\n\tif(info.m_fromInside)\n\t\tinfo.m_collisionTime = rayMaxTime;\n\telse\n\t\tinfo.m_collisionTime = rayMinTime;\n\tinfo.m_material = box.m_material;\n\t\n\tinfo.m_intersectionPoint = rayPos + rayDir * info.m_collisionTime;\n\n\t// figure out the surface normal by figuring out which axis we are closest to\n\tfloat closestDist = FLT_MAX;\n\tfor(int axis = 0; axis < 3; ++axis)\n\t{\n\t\tfloat distFromPos= abs(box.m_pos[axis] - info.m_intersectionPoint[axis]);\n\t\tfloat distFromEdge = abs(distFromPos - (box.m_scale[axis] * 0.5));\n\n\t\tif(distFromEdge < closestDist)\n\t\t{\n\t\t\tclosestDist = distFromEdge;\n\t\t\tinfo.m_surfaceNormal = vec3(0.0,0.0,0.0);\n\t\t\tif(info.m_intersectionPoint[axis] < box.m_pos[axis])\n\t\t\t\tinfo.m_surfaceNormal[axis] = -1.0;\n\t\t\telse\n\t\t\t\tinfo.m_surfaceNormal[axis] =  1.0;\n\t\t}\n\t}\n\n\t// we found a hit!\n\tinfo.m_foundHit = true;\n\tinfo.m_Id = box.m_Id;\n\treturn true;\t\n}\n\n//=======================================================================================\nbool PointCanSeePoint(in vec3 startPos, in vec3 targetPos, in int ignorePrimitiveId)\n{\n\t// see if we can hit the target point from the starting point\n\tSCollisionInfo collisionInfo =\n\t\tSCollisionInfo\n\t\t(\n\t\t\t0,\n\t\t\tfalse,\n\t\t\tfalse,\n\t\t\t-1.0,\n\t\t\tvec3(0.0,0.0,0.0),\n\t\t\tvec3(0.0,0.0,0.0),\n\t\t\tSMaterial(\n\t\t\t\tvec3(0.0,0.0,0.0),\n\t\t\t\t1.0,\n\t\t\t\tvec3(0.0,0.0,0.0)\n\t\t\t)\n\t\t);\t\n\t\n\tvec3 rayDir = targetPos - startPos;\n\tcollisionInfo.m_collisionTime = length(rayDir);\n\trayDir = normalize(rayDir);\n\n\t// run intersection against all non light primitives. return false on first hit found\n\treturn true\n\t#define PRIM(x) && !RayIntersectSphere(x, collisionInfo, startPos, rayDir, ignorePrimitiveId)\n\tSPHEREPRIMLIST\n\t#undef PRIM\n\t#define PRIM(x) && !RayIntersectAABox(x, collisionInfo, startPos, rayDir, ignorePrimitiveId)\n\tBOXPRIMLIST\n\t#undef PRIM\n\t;\n}\n\n//=======================================================================================\nvoid ApplyPointLight (inout vec3 pixelColor, in SCollisionInfo collisionInfo, in SPointLight light, in vec3 rayDir)\n{\n\tif (DO_SHADOWS == false || PointCanSeePoint(collisionInfo.m_intersectionPoint, light.m_pos, collisionInfo.m_Id))\n\t{\n\t\t// diffuse\n\t\tvec3 hitToLight = normalize(light.m_pos - collisionInfo.m_intersectionPoint);\n\t\tfloat dp = dot(collisionInfo.m_surfaceNormal, hitToLight);\n\t\tif(dp > 0.0)\n\t\t\tpixelColor += collisionInfo.m_material.m_diffuseColor * dp * light.m_color;\n\t\t\t\t\n\t\t// specular\n\t\tvec3 reflection = reflect(hitToLight, collisionInfo.m_surfaceNormal);\n\t\tdp = dot(rayDir, reflection);\n\t\tif (dp > 0.0)\n\t\t\tpixelColor += collisionInfo.m_material.m_specularColor * pow(dp, collisionInfo.m_material.m_specular) * light.m_color;\n\t}\n}\n\n//=======================================================================================\nvoid ApplyDirLight (inout vec3 pixelColor, in SCollisionInfo collisionInfo, in SDirLight light, in vec3 rayDir)\n{\n\tif (DO_SHADOWS == false || PointCanSeePoint(collisionInfo.m_intersectionPoint, collisionInfo.m_intersectionPoint + light.m_reverseDir * 1000.0, collisionInfo.m_Id))\n\t{\n\t\t// diffuse\n\t\tfloat dp = dot(collisionInfo.m_surfaceNormal, light.m_reverseDir);\n\t\tif(dp > 0.0)\n\t\t\tpixelColor += collisionInfo.m_material.m_diffuseColor * dp * light.m_color;\n\t\t\n\t\t// specular\n\t\tvec3 reflection = reflect(light.m_reverseDir, collisionInfo.m_surfaceNormal);\n\t\tdp = dot(rayDir, reflection);\n\t\tif (dp > 0.0)\n\t\t\tpixelColor += collisionInfo.m_material.m_specularColor * pow(dp, collisionInfo.m_material.m_specular) * light.m_color;\t\t\t\n\t}\n}\n\n//=======================================================================================\nfloat DefiniteIntegral (in float x, in float amplitude, in float frequency, in float motionFactor)\n{\n\t// Fog density on an axis:\n\t// (1 + sin(x*F)) * A\n\t//\n\t// indefinite integral:\n\t// (x - cos(F * x)/F) * A\n\t//\n\t// ... plus a constant (but when subtracting, the constant disappears)\n\t//\n\tx += iTime * motionFactor;\n\treturn (x - cos(frequency * x)/ frequency) * amplitude;\n}\n\n//=======================================================================================\nfloat AreaUnderCurveUnitLength (in float a, in float b, in float amplitude, in float frequency, in float motionFactor)\n{\n\t// we calculate the definite integral at a and b and get the area under the curve\n\t// but we are only doing it on one axis, so the \"width\" of our area bounding shape is\n\t// not correct.  So, we divide it by the length from a to b so that the area is as\n\t// if the length is 1 (normalized... also this has the effect of making sure it's positive\n\t// so it works from left OR right viewing).  The caller can then multiply the shape\n\t// by the actual length of the ray in the fog to \"stretch\" it across the ray like it\n\t// really is.\n\treturn (DefiniteIntegral(a, amplitude, frequency, motionFactor) - DefiniteIntegral(b, amplitude, frequency, motionFactor)) / (a - b);\n}\n\n//=======================================================================================\nfloat FogAmount (in vec3 src, in vec3 dest, in float fogMod)\n{\n\tfloat len = length(dest - src);\n\t\n\t// calculate base fog amount (constant density over distance)\t\n\tfloat amount = len * 0.1;\n\t\n\t// calculate definite integrals across axes to get moving fog adjustments\n\tfloat adjust = 0.0;\n\tadjust += AreaUnderCurveUnitLength(dest.x, src.x, 0.01, 0.6, 2.0);\n\tadjust += AreaUnderCurveUnitLength(dest.y, src.y, 0.01, 1.2, 1.4);\n\tadjust += AreaUnderCurveUnitLength(dest.z, src.z, 0.01, 0.9, 2.2);\n\tadjust *= len;\n\t\n\treturn min(amount+adjust+fogMod, 1.0);\n}\n\n//=======================================================================================\nvoid TraceRay (in vec3 rayPos, in vec3 rayDir, in float fogMod)\n{\n\tint lastHitPrimitiveId = 0;\n\t\n\tvec3 rayToCameraDir = rayDir;\n\t\n\tvec3 pixelColor = vec3(0.0,0.0,0.0);\t\n\tSCollisionInfo collisionInfo =\n\t\tSCollisionInfo\n\t\t(\n\t\t\t0,\n\t\t\tfalse,\n\t\t\tfalse,\n\t\t\t-1.0,\n\t\t\tvec3(0.0,0.0,0.0),\n\t\t\tvec3(0.0,0.0,0.0),\n\t\t\tSMaterial(\n\t\t\t\tvec3(0.0,0.0,0.0),\n\t\t\t\t1.0,\n\t\t\t\tvec3(0.0,0.0,0.0)\n\t\t\t)\n\t\t);\n\n\t// run intersection against all objects, including light objects\t\t\n\t#define PRIM(x) RayIntersectSphere(x, collisionInfo, rayPos, rayDir, lastHitPrimitiveId);\n\tSPHEREPRIMLISTWITHLIGHTS\n\t#undef PRIM\n\t\t\t\n\t// run intersections against all boxes\n\t#define PRIM(x) RayIntersectAABox(x, collisionInfo, rayPos, rayDir, lastHitPrimitiveId);\n\tBOXPRIMLIST\n\t#undef PRIM\n\n\tif (collisionInfo.m_foundHit)\n\t{\t\n\t\t\t\n\t\t// do texture sampling for the floorbox\n\t\tif (collisionInfo.m_Id == floorBox.m_Id)\n\t\t{\n\t\t\tcollisionInfo.m_material.m_diffuseColor = \n\t\t\ttexture(iChannel0, collisionInfo.m_intersectionPoint.xz * 0.25).xyz;\n\t\t}\n\t\t\t\n\t\t// point lights\n\t\t#define LIGHT(light) ApplyPointLight(pixelColor, collisionInfo, light, rayDir);\n\t\tPOINTLIGHTLIST\n\t\t#undef LIGHT\n\t\t\t\t\n\t\t// directional lights\n\t\t#define LIGHT(light) ApplyDirLight(pixelColor, collisionInfo, light, rayDir);\n\t\tDIRLIGHTLIST\t\t\t\t\n\t\t#undef LIGHT\n\n\t\t// ambient light\n\t\tpixelColor += lightAmbient * collisionInfo.m_material.m_diffuseColor;\n\t\t\t\t\t\n\t\tvec4 fog = vec4(fogColor, FogAmount(rayPos, collisionInfo.m_intersectionPoint, fogMod));\n\n\t\tshadingStack.m_addColor = pixelColor;\n\t\tshadingStack.m_fogColorAndAmount = fog;\n\t}\n\t// no hit means all fog\n\telse\n\t\tshadingStack.m_fogColorAndAmount = vec4(fogColor,1.0);\n}\n\n//=======================================================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 rawPercent = (fragCoord.xy / iResolution.xy);\n\tvec2 percent = rawPercent - vec2(0.5,0.5);\n\t\n\tvec3 rayPos;\n\tvec3 rayTarget;\n\t\n\trayTarget = (cameraFwd * cameraDistance)\n\t\t\t  + (cameraLeft * percent.x * cameraViewWidth)\n\t          + (cameraUp * percent.y * cameraViewHeight);\n\t\t\n\trayPos = cameraPos;\n\t\n\tvec3 rayDir = normalize(rayTarget);\n\n\tfloat fogMod = mod( fragCoord.x + fragCoord.y, 2.0 ) / 255.0;\n\t\n\tTraceRay(rayPos, rayDir, fogMod);\n\t\n\tvec3 pixelColor = mix(shadingStack.m_addColor, shadingStack.m_fogColorAndAmount.xyz, shadingStack.m_fogColorAndAmount.w);\n\t\n\tfragColor = vec4(pixelColor, 1.0);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldfXzB.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1841, 1900, 1922, 1922, 2020], [2022, 2022, 2043, 2043, 2109], [2551, 2740, 2770, 2770, 2876], [2917, 2936, 2968, 2968, 3187], [3239, 3239, 3261, 3261, 3478], [3510, 3510, 3532, 3532, 3795], [3827, 3827, 3858, 3858, 4126], [4160, 4160, 4191, 4191, 4428], [4462, 4462, 4493, 4493, 4730], [4764, 4764, 4791, 4791, 5009], [5011, 5011, 5038, 5038, 5256], [5258, 5258, 5285, 5285, 5503], [6114, 6204, 6334, 6334, 7955], [7957, 8047, 8181, 8181, 10589], [10591, 10681, 10767, 10830, 11508], [11510, 11600, 11717, 11717, 12348], [12350, 12440, 12553, 12553, 13173], [13175, 13265, 13365, 13552, 13639], [13641, 13731, 13851, 14383, 14520], [14522, 14612, 14674, 14674, 15162], [15164, 15254, 15319, 15319, 16886], [16888, 16978, 17035, 17035, 17643]]}
{"id": "ldfXzj", "name": "big blue mandelboo", "author": "bigblueboo", "description": "re-acquainting myself with mandelbrot\n\nscrewing around before I take another read of iq's articles", "tags": ["2d", "fractal", "mandelbrot", "bigblueboo"], "likes": 2, "viewed": 142, "date": "1403924230", "time_retrieved": "2024-06-20T18:11:29.391522", "image_code": "float PI = 3.1415926;\n#define AA 1.0\n#define AA_SAMPS 8\n#define SPEED .05\n#define ITERATIONS 128.0\n//mmalex's random functions\nfloat srand(vec2 a) { return fract(sin(dot(a,vec2(1233.224,1743.335)))); }\nvec2 rand(vec2 r) { return fract(3712.65*r+0.61432); }\n\nfloat easeWithSteps(float t, float steps)\n{\n\tfloat frac = 1.0 / steps;\t\n\tfloat eT = mod(t, frac);\n\tfloat x = eT / frac;\n\treturn t - eT + frac * x*x*x*(x*(x*6.0 - 15.0) + 10.0); // fancy smoothstep (see wikipeed)\n}\n\nfloat map(float x, float xmin, float xmax, float ymin, float ymax)\n{\n\t// miss u processing\n\treturn clamp(ymin + (x - xmin) / (xmax - xmin) * (ymax - ymin), ymin, ymax);\n}\n\n\nvec2 iterate( vec2 v, vec2 c)\n{\n\treturn vec2(v.x * v.x - v.y * v.y + c.x, 2.0 * v.x * v.y + c.y);\n}\n\nvec4 colorAtCoord(vec2 uv, float t)\n{\n\tuv =uv.xy / iResolution.y;\n\tvec2 p = uv -vec2(.5 * iResolution.x / iResolution.y,.5);\n\tfloat sT =  .5 + .5 * sin(-PI/2.0 + easeWithSteps(t, 2.0) * PI * 2.0);\n\tfloat scale = 2.000 - 1.999*sT;//10.0 - sT * 9.99;\n\t//scale = .001;\n\tp.x -= .2;\n\tp *= scale;\n\t// framing\n\tp.x += .2799 * sT;\n\tp.y += -.01025 * sT;\n\tfloat phaseR = iMouse.x / iResolution.x * PI;\n\tfloat phaseC = iMouse.y / iResolution.y * PI;\n\t\n\t\n\tvec2 z = vec2(0.0);\n\t\n\tfloat iters = 0.0;\n\tfloat limit = 10.0;\n\tfloat dist = 0.0;\n\tfloat dist2 = 0.0;\n\tfloat dx = 0.0;\n\tfloat dy = 0.0;\n\tfor ( float i = 0.0; i < ITERATIONS; i+=1.0)\n\t{\n\t\tz = iterate(z, p);\n\t\tif (abs(z.x + z.y) > 4.0)\n//\t\tif (max(abs(z.x), abs(z.y)) > 2.0) \n\t\t{\n\t\t\titers = i;\n\t\t\t\n\t\t\tdx = z.x - p.x;\n\t\t\tdy = z.y - p.y;\n\t\t\tdist = abs(dx + dy);\n\t\t\tdist2 = max(abs(z.x), abs(z.y));\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tvec4 color = vec4(sqrt(dist) / (10.0));//iters / ITERATIONS;\n\tcolor.g = (dist2) / 100.0;\n\tcolor.b = iters / 10.0; // beep boop nfi what i'm doing\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// assume 60fps\n\tfloat t = iTime * SPEED;\n\tvec4 c=vec4(0.);\n\t\n\t// mmalex's AA/blur code.\n\tvec2 aa=vec2( srand(fragCoord.xy), srand(fragCoord.yx) );\n\tt+=1.0/60.0/float(AA_SAMPS)*aa.x*SPEED;\t\n\t\n\tfor (int i=0;i<(AA_SAMPS);i++) {\n\t\taa=rand(aa);\n\t\tc+=colorAtCoord(fragCoord.xy+aa,t);\n\t\tt+=1.0/60.0/float(AA_SAMPS)*SPEED;\n\t}\t\n\tc=sqrt(c/float(AA_SAMPS));\n\t//c.g=sqrt(c/float(AA_SAMPS));\n\t//c.b=sqrt(c/float(AA_SAMPS));\t\n\tfragColor = c;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldfXzj.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[99, 127, 148, 148, 201], [202, 202, 221, 221, 256], [258, 258, 301, 301, 471], [473, 473, 541, 563, 643], [646, 646, 677, 677, 745], [747, 747, 784, 784, 1767], [1769, 1769, 1826, 1843, 2258]]}
{"id": "ldfXzS", "name": "Wet Sand", "author": "TekF", "description": "Trying the nice surface shading tricks from my  on a landscape.>\nToggle Ambient Occlusion: A, Toggle Reflection Occlusion: S. View modes:Q,W,L", "tags": ["ambientocclusion", "specularocclusion"], "likes": 78, "viewed": 7410, "date": "1403188726", "time_retrieved": "2024-06-20T18:11:31.567378", "image_code": "// Hazel Quantock 2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// artefacts from noise texture interpolation\n//#define FAST\n\n// keys\nconst int kA=65,kB=66,kC=67,kD=68,kE=69,kF=70,kG=71,kH=72,kI=73,kJ=74,kK=75,kL=76,kM=77,kN=78,kO=79,kP=80,kQ=81,kR=82,kS=83,kT=84,kU=85,kV=86,kW=87,kX=88,kY=89,kZ=90;\nconst int k0=48,k1=49,k2=50,k3=51,k4=52,k5=53,k6=54,k7=55,k8=56,k9=57;\nconst int kSpace=32,kLeft=37,kUp=38,kRight=39,kDown=40;\n\n\n// TOGGLES:\n\n// demo mode - cycle through the effects\nconst int kDemoMode = kD;\n\n// aesthetic toggles\nint kAnimate = kA;  float pauseTime = 3.6;\n//int kPrintedPaper = kP;\nint kLensFX = kL;\n\n// lighting\n//int kLighting = k0; // turn all diffuse illumination on/off (to see reflections better)\n//int kAlbedo = k1;\n//int kShadow = k2;\n//int kDirectLight = k3;\n//int kAmbientGradient = k4;\nint kAmbientOcclusion = kA;\nint kShowAmbientOcclusion = kQ;\n\n// specular\n//int kSpecular = k9; // turn all specular on/off (to see diffuse better)\n//int kSpecularHighlight = kQ;\n//int kFresnel = kW;\nint kReflectionOcclusion = kS;\n//int kReflections = kR;\nint kShowSpecularOcclusion = kW;\n\n\n// key is javascript keycode: http://www.webonweboff.com/tips/js/event_key_codes.aspx\nbool ReadKey( int key, bool toggle )\n{\n\tfloat keyVal = textureLod( iChannel3, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ), 0.0 ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\n\nbool Toggle( int val, int index )\n{\n// Toggles are breaking the compile! AARGH!\n// try removing a few of them, or something\n// mostly want to see spec/amb occ\n\t\n/*\tfloat cut = fract(iTime/30.0)*11.0;\n\tif ( !ReadKey( kDemoMode, true ) && float(index) > cut )\n\t{\n\t\treturn false;\n\t}*/\n\t\n\t// default everything to \"on\"\n\treturn !ReadKey( val, true );\n}\n\n\nvec2 Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\n\t// On Chrome 36 I get an artefact where the texture wraps, so do the wrap manually\t\n\tuv = fract(uv/256.0)*256.0;\n\n#ifdef FAST\n\tvec4 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0 );\n#else\n\t// high precision interpolation, if needed\n\tvec4 rg = mix( mix(\n\t\t\t\ttextureLod( iChannel0, (floor(uv)+0.5)/256.0, 0.0 ),\n\t\t\t\ttextureLod( iChannel0, (floor(uv)+vec2(1,0)+0.5)/256.0, 0.0 ),\n\t\t\t\tfract(uv.x) ),\n\t\t\t\t  mix(\n\t\t\t\ttextureLod( iChannel0, (floor(uv)+vec2(0,1)+0.5)/256.0, 0.0 ),\n\t\t\t\ttextureLod( iChannel0, (floor(uv)+1.5)/256.0, 0.0 ),\n\t\t\t\tfract(uv.x) ),\n\t\t\t\tfract(uv.y) );\n#endif\t\t\t  \n\n\treturn mix( rg.yw, rg.xz, f.z );\n}\n\nfloat Granite( in vec3 x )\n{\n\treturn (\n\t\t\t abs(Noise(x* 1.0).x-.5)/1.0\n\t\t\t+abs(Noise(x* 2.0).x-.5)/2.0\n\t\t\t+abs(Noise(x* 4.0).x-.5)/4.0\n\t\t\t+abs(Noise(x* 8.0).x-.5)/8.0\n\t\t\t+abs(Noise(x*16.0).x-.5)/16.0\n\t\t)*32.0/31.0;\n//\t\t\t+abs(Noise(x*32.0).x-.5)/32.0\n//\t\t\t+abs(Noise(x*64.0).x-.5)/64.0\n//\t\t)*128.0/127.0;\n}\n\n\nfloat DistanceField( vec3 p, float t )\n{\n\t//return p.y;\n\t//return (p.y - max(.0,Granite(p.xzy*vec3(1,1,0))-.5)) / 1.2;\n\n// this doesn't get good occlusion, because the lumps don't have a gradient to their sides\n\t//return min(p.y, ( p.y - (Granite(p.xzy*vec3(1,1,0))-.5) ) / 1.2);\n\n\treturn min(p.y, ( p.y - (Granite(p)-.5) ) * (.65-.2*2.0/max(2.0,t)) ); // adjust accuracy with depth\n}\n\nfloat DistanceField( vec3 p )\n{\n\treturn DistanceField( p, 0.0 );\n}\n\n\nvec3 Sky( vec3 ray )\n{\n\treturn mix( vec3(.8), vec3(0), exp2(-(1.0/max(ray.y,.01))*vec3(.4,.6,1.0)) );\n}\n\n\nvec3 Shade( vec3 pos, vec3 ray, vec3 normal, vec3 lightDir, vec3 lightCol, float shadowMask, float distance )\n{\n\tvec3 ambient = vec3(.5);\n//\tif ( Toggle(kAmbientGradient,2) )\n\t\tambient = mix( vec3(.2,.27,.4), vec3(.4), (-normal.y*.5+.5) ); // ambient\n//\t\tambient = mix( vec3(.03,.05,.08), vec3(.1), (-normal.y+1.0) ); // ambient\n\t// ambient occlusion, based on my DF Lighting: https://www.shadertoy.com/view/XdBGW3\n\tfloat aoRange = distance/20.0;\n\t\n\tfloat occlusion = max( 0.0, 1.0 - DistanceField( pos + normal*aoRange )/aoRange ); // can be > 1.0\n//\tocclusion = min( 1.0, occlusion ); // prevent excessive occlusion\n\tocclusion = exp2( -2.0*pow(occlusion,2.0) ); // tweak the curve\n//\tocclusion *= mix(.5,1.0,pow(grainq,.2));\n\tif ( Toggle(kAmbientOcclusion,1) )\n\t\tambient *= occlusion;\n\n\tfloat ndotl = max(.0,dot(normal,lightDir));\n\tfloat lightCut = smoothstep(.0,.1,ndotl);//pow(ndotl,2.0);\n\tvec3 light = vec3(0);\n\n//\tif ( Toggle(kDirectLight,3) )\n\t\t\tlight += lightCol*shadowMask*ndotl;\n\n\tlight += ambient;\n\n\n\t// And sub surface scattering too! Because, why not?\n\tfloat transmissionRange = .1;//distance/5.0;\n\tfloat transmission = max( 0.0, DistanceField( pos + lightDir*transmissionRange )/transmissionRange );\n\tvec3 subsurface = vec3(1,.8,.5) * .5 * lightCol * transmission;\n//\tcommented out because it's a little buggy with small distances, and sand shouldn't have a lot of sss\n//\tlight += subsurface;\n\n\n\tfloat specularity = smoothstep( .5,1.0, texture( iChannel0, pos.xz/256.0 ).r )\n\t\t\t\t\t\t*pow(smoothstep( 0.05, 0.0, pos.y ),2.0); // don't let the lumps be too shiny\n\t\n\tvec3 h = normalize(lightDir-ray);\n\tfloat specPower = exp2(3.0+6.0*specularity);\n\tvec3 specular = lightCol*shadowMask*pow(max(.0,dot(normal,h))*lightCut, specPower)*specPower/32.0;\n\t\n\tvec3 rray = reflect(ray,normal);\n\tvec3 reflection = vec3(0);\n\t\n//\tif ( Toggle(kReflections,6) )\n\t\treflection = Sky( rray );\n\t\n\t\n\t// specular occlusion, adjust the divisor for the gradient we expect\n\tfloat specOcclusion = max( 0.0, 1.0 - DistanceField( pos + rray*aoRange )/(aoRange*max(.01,dot(rray,normal))) ); // can be > 1.0\n\tspecOcclusion = exp2( -2.0*pow(specOcclusion,2.0) ); // tweak the curve\n\t\n\t// prevent sparkles in heavily occluded areas\n\tspecOcclusion *= occlusion;\n\n\tif ( Toggle(kReflectionOcclusion,7) )\n\t\treflection *= specOcclusion; // could fire an additional ray for more accurate results\n\t\n\tfloat fresnel = pow( 1.0+dot(normal,ray), 5.0 );\n\tfresnel = mix( mix( .0, .05, specularity ), mix( .4, 1.0, specularity ), fresnel );\n\t\n//\tif ( !Toggle(kFresnel,8) )\n//\t\tfresnel = 1.0; // chrome\n\t\n\tvec3 albedo = vec3(.5,.3,.13);\n\t\n//\tif ( !Toggle(kAlbedo,5) ) albedo = vec3(1);\n\t\n\tvec3 result = vec3(0);\n//\tif ( Toggle(kLighting,-1) )\n\t\tresult = light*albedo;\n\n//\tif ( Toggle(kSpecular,6) )\n\t{\n\t\tresult = mix( result, reflection, fresnel );\n\t\n//\t\tif ( Toggle(kSpecularHighlight,9) )\n\t\t\tresult += specular;\n\t}\n\n\tif ( !Toggle(kShowAmbientOcclusion,-1) )\n\t\tresult = vec3(occlusion);\n\n\tif ( !Toggle(kShowSpecularOcclusion,-1) )\n\t\tresult = vec3(specOcclusion);\n\t\n\treturn result;\n}\n\n\n\n\n// Isosurface Renderer\n#ifdef FAST\nconst int traceLimit=40;\nconst float traceSize=.005;\n#else\nconst int traceLimit=60;\nconst float traceSize=.002;\n#endif\t\n\nfloat Trace( vec3 pos, vec3 ray, float traceStart, float traceEnd )\n{\n\tfloat t = traceStart;\n\tfloat h;\n\tfor( int i=0; i < traceLimit; i++ )\n\t{\n\t\th = DistanceField( pos+t*ray, t );\n\t\tif ( h < traceSize || t > traceEnd )\n\t\t\tbreak;\n\t\tt = t+h;\n\t}\n\t\n\tif ( t > traceEnd )//|| h > .001 )\n\t\treturn 0.0;\n\t\n\treturn t;\n}\n\nfloat TraceMin( vec3 pos, vec3 ray, float traceStart, float traceEnd )\n{\n\tfloat Min = traceEnd;\n\tfloat t = traceStart;\n\tfloat h;\n\tfor( int i=0; i < traceLimit; i++ )\n\t{\n\t\th = DistanceField( pos+t*ray, t );\n\t\tMin = min(h,Min);\n\t\tif ( /*h < .001 ||*/ t > traceEnd )\n\t\t\tbreak;\n\t\tt = t+max(h,.1);\n\t}\n\t\n\treturn Min;\n}\n\nvec3 Normal( vec3 pos, vec3 ray, float t )\n{\n\t// in theory we should be able to get a good gradient using just 4 points\n\n\tfloat pitch = .5 * t / iResolution.x;\n#ifdef FAST\n\t// don't sample smaller than the interpolation errors in Noise()\n\tpitch = max( pitch, .005 );\n#endif\n\t\n\tvec2 d = vec2(-1,1) * pitch;\n\n\tvec3 p0 = pos+d.xxx; // tetrahedral offsets\n\tvec3 p1 = pos+d.xyy;\n\tvec3 p2 = pos+d.yxy;\n\tvec3 p3 = pos+d.yyx;\n\t\n\tfloat f0 = DistanceField(p0,t);\n\tfloat f1 = DistanceField(p1,t);\n\tfloat f2 = DistanceField(p2,t);\n\tfloat f3 = DistanceField(p3,t);\n\t\n\tvec3 grad = p0*f0+p1*f1+p2*f2+p3*f3 - pos*(f0+f1+f2+f3);\n\t\n\t// prevent normals pointing away from camera (caused by precision errors)\n\tfloat gdr = dot ( grad, ray );\n\tgrad -= max(.0,gdr)*ray;\n\t\n\treturn normalize(grad);\n}\n\n\n// Camera\n\nvec3 Ray( float zoom, in vec2 fragCoord )\n{\n\treturn vec3( fragCoord.xy-iResolution.xy*.5, iResolution.x*zoom );\n}\n\nvec3 Rotate( inout vec3 v, vec2 a )\n{\n\tvec4 cs = vec4( cos(a.x), sin(a.x), cos(a.y), sin(a.y) );\n\t\n\tv.yz = v.yz*cs.x+v.zy*cs.y*vec2(-1,1);\n\tv.xz = v.xz*cs.z+v.zx*cs.w*vec2(1,-1);\n\t\n\tvec3 p;\n\tp.xz = vec2( -cs.w, -cs.z )*cs.x;\n\tp.y = cs.y;\n\t\n\treturn p;\n}\n\n\n// Camera Effects\n\nvoid BarrelDistortion( inout vec3 ray, float degree )\n{\n\t// would love to get some disperson on this, but that means more rays\n\tray.z /= degree;\n\tray.z = ( ray.z*ray.z - dot(ray.xy,ray.xy) ); // fisheye\n\tray.z = degree*sqrt(ray.z);\n}\n\nvec3 LensFlare( vec3 ray, vec3 light, float lightVisible, float sky, in vec2 fragCoord )\n{\n\tvec2 dirtuv = fragCoord.xy/iResolution.x;\n\t\n\tfloat dirt = 1.0-texture( iChannel1, dirtuv ).r;\n\t\n\tfloat l = (dot(light,ray)*.5+.5);\n\t\n\treturn (((pow(l,30.0)+.05)*dirt*.1 + 1.0*pow(l,200.0))*lightVisible + sky*1.0*pow(l,5000.0))*vec3(1.05,1,.95);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 ray = Ray(1.0, fragCoord);\n\t\n\tif ( Toggle(kLensFX,10) )\n\t\tBarrelDistortion( ray, .5 );\n\t\n\tray = normalize(ray);\n\tvec3 localRay = ray;\n\n\tvec2 mouse = vec2(0);\n\tif ( iMouse.z > 0.0 )\n\t\tmouse = .5-iMouse.yx/iResolution.yx;\n\t\t\n\tfloat T = iTime*.1;\n\tvec3 pos = 2.0*Rotate( ray, vec2(.2,2.8-T)+vec2(-.5,-6.3)*mouse );\n\tpos += vec3(0,.3,0) + T*vec3(0,0,-1);\n\t\n\tfloat top = .5, bottom = .0;\n\t\n\tvec3 col;\n\n\tvec3 lightDir = normalize(vec3(3,1,-2));\n\t\n\tfloat topIntersection = (top-pos.y)/ray.y;\n\tfloat bottomIntersection = (bottom-pos.y)/ray.y;\n\t\n\tfloat traceStart = .5;\n\tfloat traceEnd = 40.0;\n\t\n\tif ( ray.y > 0.0 )\n\t\ttraceEnd = min(traceEnd,topIntersection);\n\telse if ( ray.y < 0.0 )\n\t{\n\t\ttraceEnd = min(traceEnd,bottomIntersection);\n\t\tif ( pos.y > top )\n\t\t\ttraceStart = min(traceEnd,topIntersection);\n\t}\n\t\n\tfloat t = Trace( pos, ray, traceStart, traceEnd );\n\tif ( t > .0 )\n\t{\n\t\tvec3 p = pos + ray*t;\n\t\t\n\t\t// shadow test\n\t\tfloat s = 0.0;\n//\t\tif ( Toggle(kShadow,4) )\n\t\t\ts = Trace( p, lightDir, .05, (top-p.y)/lightDir.y );\n\t\t\n\t\tvec3 n = Normal(p, ray, t);\n\t\tcol = Shade( p, ray, n, lightDir, vec3(1.1,1,.9), (s>.0)?0.0:1.0, t );\n\t\t\n\t\t// fog\n\t\tfloat f = 80.0;\n\t\tcol = mix( vec3(.8), col, exp2(-t*vec3(.4,.6,1.0)/f) );\n\t}\n\telse\n\t{\n\t\tcol = Sky( ray );\n\t}\n\t\n\tif ( Toggle(kLensFX,10) )\n\t{\n\t\t// lens flare\n\t\tfloat sun = 1.0;//TraceMin( pos, lightDir, .5, 40.0 );\n\t\tcol += LensFlare( ray, lightDir, smoothstep(-.04,.1,sun), step(t,.0),fragCoord );\n\t\n\t\t// vignetting:\n\t\tcol *= smoothstep( .5, .0, dot(localRay.xy,localRay.xy) );\n\t\n\t\t// compress bright colours, ( because bloom vanishes in vignette )\n\t\tvec3 c = (col-1.0);\n\t\tc = sqrt(c*c+.05); // soft abs\n\t\tcol = mix(col,1.0-c,.48); // .5 = never saturate, .0 = linear\n\t\t\n\t\t// grain\n\t\tvec2 grainuv = fragCoord.xy + floor(iTime*60.0)*vec2(37,41);\n\t\tvec2 filmNoise = texture( iChannel0, .5*grainuv/iChannelResolution[0].xy ).rb;\n\t\tcol *= mix( vec3(1), mix(vec3(1,.5,0),vec3(0,.5,1),filmNoise.x), .1*filmNoise.y );\n\t}\n\t\n\tfragColor = vec4(pow(col,vec3(1.0/2.6)),1);\n}\n", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 3, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldfXzS.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1153, 1239, 1277, 1277, 1406], [1409, 1409, 1444, 1723, 1756], [1759, 1759, 1784, 1784, 2520], [2522, 2522, 2550, 2550, 2827], [2830, 2830, 2870, 3109, 3214], [3216, 3216, 3247, 3247, 3282], [3285, 3285, 3307, 3307, 3388], [3391, 3391, 3502, 3502, 6436], [6441, 6597, 6666, 6666, 6906], [6908, 6908, 6980, 6980, 7220], [7222, 7222, 7266, 7341, 7997], [8000, 8011, 8054, 8054, 8124], [8126, 8126, 8163, 8163, 8378], [8381, 8400, 8455, 8526, 8633], [8635, 8635, 8725, 8725, 8973], [8976, 8976, 9033, 9033, 11037]]}
{"id": "ldlXDN", "name": "drop splash", "author": "FabriceNeyret2", "description": "Real drop splashes are *not* sin(k(d-ct)) !\n- wave speed depends on wavelenght (dispertion). slowest=.4 cm; faster for larger (gravity) and smaller (capillary)\n- vertical displ = A.sin, horiz displ = A.cos -> trochoids, not sinusoids (not drawn here).", "tags": ["waves"], "likes": 18, "viewed": 2557, "date": "1401643370", "time_retrieved": "2024-06-20T18:11:32.106736", "image_code": "#define Wmin 50.    // spectrum shape of exciter \n#define Wmax 200.\n#define Wsamples 150.\n#define AMP(w) (1./(w))\n\n#define COL 0\t\t// water reflects\n#define CAM 1\t\t// perspective camera\n#define PULSE 1     // time shape of exciter  1: square 2: smooth\n// SPACE to toggle spreaded source\n\n\nbool keyToggle(int ascii) {\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\n}\n\n// --- rand\nfloat hash(float x) { return fract(sin(3234.*x)*6563.234); }\n\n// --- solve degree 3 equation\nfloat solveP3(float a, float c, float d) {\n\tc /= a; d /= a;\n\tfloat C = -d/2.*(1.+sqrt(1.+(c*c*c)/(d*d)*4./27.));  \n\tC = sign(C)*pow(abs(C),1./3.);\n    return C-c/(3.*C);\n}\n\n// --- Pierson-Moskowitz oceanographic spectrum   V = wind at 20m height\nfloat PM(float w,float V) { return 8.1E-3*9.81*9.81/pow(w,5.)*exp(-0.74*pow(9.81/(V*w),4.)); }\n\n// --- drop exciter\nfloat pulse(float t) {\n#if   PULSE==1\n\treturn (mod(t,1.)<.1) ? 1.: 0.;      // square signal\n#elif PULSE==2\n\treturn pow(.5+.5*cos(6.283*t),20.);  // smoothed signal\n#endif\n}\n\n// === main loop\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t = .3*iTime;\n    vec2 uv = 2.*(fragCoord.xy / iResolution.y - vec2(.9,.5));\n\tvec2 m  =      2.*( iMouse.xy / iResolution.y - vec2(.9,.5));\n\tif (length(iMouse.zw)==0.) m = vec2(1e-5);\n\t\n#if CAM\n\t// set view conditions and get water plane position viewed in the pixel\n\tfloat b = 3.14*length(m), a = atan(m.y,m.x);\n\tvec3 eye = vec3(sin(b)*cos(a),sin(b)*sin(a),cos(b)); // vec3(2.*m,2.);\n\tmat3 M; \t\t\t\t\t// view matrix\n\tM[0] = normalize(-eye);\n\tM[2] = normalize(vec3(0.,0.,1.)-M[0].z*M[0]);\n\tM[1] = cross(M[0],M[2]);\n\tvec3 ray = normalize(M*vec3(1.,uv));\n\tif (abs(ray.z)>1e-3) {\n\t\tfloat l = -eye.z/ray.z; vec3 P = eye + l*ray; // point on water plane\n\t\tuv = P.xy;\n\t}\n#endif\n\t\n\tvec2 dir = normalize(uv);\n\tfloat d = 10.*length(uv);\n\tfloat x = 0., y = 0.; vec4 col = vec4(0.);\n\t\n\t// k = 2Pi/L , w = 2Pi/T\n\t// complete waves dispertion equation: w^2 = (gk + sigma/rho k^3) tanh(kh)\n\t// here, ignore tan(kh) ( = deep water case )\n\t\n\t// sum on wave spectrum // < 85: gravity waves  > 85: capillary waves\n\tfor (float w = Wmin; w < Wmax; w += (Wmax-Wmin)/Wsamples) \n\t{  \n\t    float k = solveP3(9.81, 0.074/1000.,-w*w);  // k(w)\n\t\tif (keyToggle(32)) d = 10.*length(uv+.03*(2.*vec2(hash(1./w),1.+hash(1./w))-1.));\n\t\tfloat phi =k*d-w*t ,\t\t\t\t\t\t// wave phase\n\t\t\t  phi0 = 6.283*hash(w);   \t\t\t\t// random phasing(w)\n\t\tfloat A = 2.*AMP(w) * pulse(-phi/w);\t\t// amplitude\n#if !COL\n\t\ty += A*sin(phi+phi0);\n\t\t// x += A*cos(phi+phi0);\n#else\n\t\tA *= 1.;\n\t\t// normal to the surface, and ray reflection in the cubemap.\n\t\tvec3 N = normalize(vec3( A*k*cos(phi+phi0)*dir,-(1.-A*k*sin(phi+phi0)))),\n\t\t\t V = reflect(ray,N);\n\t\tcol += texture(iChannel0, V.xzy );\n#endif\n\t}\n\t\n#if COL\n\tfragColor = vec4(col/Wsamples); \n#else\n\tfragColor = vec4(.5+y); fragColor.b += .1;\n#endif\n}", "image_inputs": [{"id": "XsX3zn", "previewfilepath": "/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap"}, {"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldlXDN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[251, 288, 315, 315, 388], [390, 402, 423, 423, 462], [464, 495, 537, 537, 666], [668, 741, 768, 768, 835], [837, 857, 879, 879, 1030], [1032, 1050, 1107, 1107, 2852]]}
{"id": "ldlXRS", "name": "Noise animation - Electric", "author": "nimitz", "description": "Playing with different ways of animating noise. In this version, the domain is displaced by two random fbm noise calls (one for each axis).", "tags": ["procedural", "2d", "noise"], "likes": 457, "viewed": 24619, "date": "1403493968", "time_retrieved": "2024-06-20T18:11:32.537286", "image_code": "// Noise animation - Electric\n// by nimitz (stormoid.com) (twitter: @stormoid)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n//The domain is displaced by two fbm calls one for each axis.\n//Turbulent fbm (aka ridged) is used for better effect.\n\n#define time iTime*0.15\n#define tau 6.2831853\n\nmat2 makem2(in float theta){float c = cos(theta);float s = sin(theta);return mat2(c,-s,s,c);}\nfloat noise( in vec2 x ){return texture(iChannel0, x*.01).x;}\n\nfloat fbm(in vec2 p)\n{\t\n\tfloat z=2.;\n\tfloat rz = 0.;\n\tvec2 bp = p;\n\tfor (float i= 1.;i < 6.;i++)\n\t{\n\t\trz+= abs((noise(p)-0.5)*2.)/z;\n\t\tz = z*2.;\n\t\tp = p*2.;\n\t}\n\treturn rz;\n}\n\nfloat dualfbm(in vec2 p)\n{\n    //get two rotated fbm calls and displace the domain\n\tvec2 p2 = p*.7;\n\tvec2 basis = vec2(fbm(p2-time*1.6),fbm(p2+time*1.7));\n\tbasis = (basis-.5)*.2;\n\tp += basis;\n\t\n\t//coloring\n\treturn fbm(p*makem2(time*0.2));\n}\n\nfloat circ(vec2 p) \n{\n\tfloat r = length(p);\n\tr = log(sqrt(r));\n\treturn abs(mod(r*4.,tau)-3.14)*3.+.2;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//setup system\n\tvec2 p = fragCoord.xy / iResolution.xy-0.5;\n\tp.x *= iResolution.x/iResolution.y;\n\tp*=4.;\n\t\n    float rz = dualfbm(p);\n\t\n\t//rings\n\tp /= exp(mod(time*10.,3.14159));\n\trz *= pow(abs((0.1-circ(p))),.9);\n\t\n\t//final color\n\tvec3 col = vec3(.2,0.1,0.4)/rz;\n\tcol=pow(abs(col),vec3(.99));\n\tfragColor = vec4(col,1.);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldlXRS.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[216, 382, 410, 410, 475], [476, 476, 501, 501, 537], [539, 539, 561, 561, 712], [714, 714, 740, 796, 954], [956, 956, 977, 977, 1060], [1062, 1062, 1119, 1135, 1443]]}
{"id": "ldlXWN", "name": "Bouncy Circle", "author": "dylan", "description": "hello world", "tags": ["2d", "simple", "atom"], "likes": 1, "viewed": 181, "date": "1401592271", "time_retrieved": "2024-06-20T18:11:32.779560", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (-1.+2.*fragCoord.xy/iResolution.xy)*vec2(iResolution.x/iResolution.y,1.);\n\tvec4 scene = vec4(0.0);\n\t\n\t// parameters\n\tfloat baseRadius = 0.02;\n\tfloat blur = 0.0065;\t\n\tvec4 background = vec4(0,0,0,0);\n\n\tfor(float i=0.;i<100.;i++) {\n\t\t// animate\n\t\tvec2 lCenter,rCenter,mCenter,noise;\n\t\tlCenter.x = sin(.001+i*.5+iTime)*(.75);\n\t\tlCenter.y = sin(.001+i*.5+iTime)*(0.5)+cos(i*.5+iTime)*.2;\n\t\trCenter.x = -1.*sin(.001+i*.5+iTime)*(.75);\n\t\trCenter.y = sin(.001+i*.5+iTime)*(0.5)+cos(i*.5+iTime)*.2;\n\t\tmCenter.x = 0.-cos(iTime+i)*-.2;\n\t\tmCenter.y = sin(iTime+i)*(0.8);\n\t\tnoise.x = 0.-cos(.001+.8*i*.2+iTime)*(1.5);\n\t\tnoise.y = 0.-cos(.001+i+iTime)*1.2;\n\t\t\n\t\tfloat radius = baseRadius*2./4.+cos(i*.5+iTime)*baseRadius/4.;\n\t\t\n\t\tfloat distL = length(uv-lCenter);\t\n\t\tfloat distR = length(uv-rCenter);\t\n\t\tfloat distM = length(uv-mCenter);\n\t\tfloat bg = length(uv-noise);\n\n\t\tvec4 rightRing = vec4(.91,.4,.91,smoothstep(0.,blur,distR-radius));\n\t\tvec4 leftRing = vec4(.91,.4,.91,smoothstep(0.,blur,distL-radius));\n\t\tvec4 middleRing = vec4(.91,.4,.91,smoothstep(0.,blur,distM-radius));\n\t\tvec4 bgCircles = vec4(.21,.4,.21,smoothstep(0.,blur,bg-radius/2.));\n\n\t\tscene += mix(bgCircles, background,bgCircles.a);\t\t\n\t\tscene += mix(rightRing,background,rightRing.a);\n\t\tscene += mix(leftRing,background,leftRing.a);\n\t\tscene += mix(middleRing,background,middleRing.a);\n\t\tscene.rgb = min(scene.rgb,vec3(.91,.4,.91));\n\t}\n\t\n\tfragColor = scene;\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldlXWN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 1485]]}
{"id": "ldsSDM", "name": "Glowing Grass", "author": "saschaheld", "description": "glowing grass effect for one of my new games.", "tags": ["procedural"], "likes": 12, "viewed": 576, "date": "1402645980", "time_retrieved": "2024-06-20T18:11:32.779560", "image_code": "#define BLADES 10\n\n\nvec4 grass(vec2 p, float x)\n{\n\tfloat s = mix(0.9, 1.4, 0.5 + sin(x * 11.0) * 0.2);\n\tp.x += pow(1.0 + p.y, 2.0) * 0.1 * cos(x * 0.5 + iTime);\n\tp.x *= s;\n\tp.y = (1.0 + p.y) * s - 1.0;\n\tfloat m = 1.0 - smoothstep(0.0, clamp(1.0 - p.y * 1.5, 0.1, 0.9) * 1.3 * s, pow(abs(p.x) * 80.0, 2.0) + p.y - 0.1);\n\treturn vec4(vec3(1, 0.2, 0.9), m * smoothstep(-1.0, -0.9, p.y));\n}\n\nvec3 backg(vec3 ro, vec3 rd)\n{\n\tvec3 ground = vec3(0.0, 0.0, 0.0);\n\treturn ground;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 ct = vec3(0.0, 2.0, 5.0);\n\tvec3 cp = vec3(0.0, 0.6, 0.0);\n\tvec3 cw = normalize(cp - ct);\n\tvec3 cu = normalize(cross(cw, vec3(0.0, 1.0, 0.0)));\n\tvec3 cv = normalize(cross(cu, cw));\n\t\n\tmat3 rm = mat3(cu, cv, cw);\n\t\n\tvec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - vec2(1.0);\n\tvec2 t = uv;\n\t\n\t\n\tvec3 ro = cp, rd = rm * vec3(t, -1.3);\n\t\n\tvec3 fcol = backg(ro, rd);\n\t\n\tfor(int i = 0; i < BLADES; i += 1)\n\t{\n\t\tfloat z = -(float(BLADES - i) * 0.1 + 1.0);\n\t\tvec4 pln = vec4(0.0, 0.0, -1.0, z);\n\t\tfloat t = (pln.w - dot(pln.xyz, ro)) / dot(pln.xyz, rd);\n\t\tvec2 tc = ro.xy + rd.xy * t;\n\t\t\n\t\ttc.x += cos(float(i) * 3.0) * 4.0;\n\t\t\n\t\tfloat cell = floor(tc.x);\n\t\t\n\t\ttc.x = (tc.x - cell) - 0.5;\n\t\t\n\t\tvec4 c = grass(tc, float(i) + cell * 10.0);\n\t\t\n\t\tfcol = mix(fcol, c.rgb, step(0.0, t) * c.w);\n\t}\n\t\n\tfcol = pow(fcol * 1.1, vec3(0.8));\n\t\n\t\n\tfragColor.rgb = fcol + vec3(0);\n\tfragColor.a = 1.0;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldsSDM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[20, 20, 49, 49, 386], [388, 388, 418, 418, 472], [474, 474, 531, 531, 1418]]}
{"id": "ldsSRS", "name": "Akiyoshi's Dream", "author": "bigblueboo", "description": "dark areas will seem to sparkle (optical illusion)\n\nsee: http://www.psy.ritsumei.ac.jp/~akitaoka/opart-e.html", "tags": ["opticalillusion", "perception"], "likes": 4, "viewed": 226, "date": "1403478827", "time_retrieved": "2024-06-20T18:11:32.779560", "image_code": "float PI = 3.1415926;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\tvec2 coord = uv - vec2(.5,.5);\n\tcoord.y *= iResolution.y / iResolution.x;\n\tfloat angle = atan(coord.y, coord.x);\n\tfloat dist = length(coord);\n\t\n\tfloat brightness = .25 + .25 * \n\t\tsin(48.0*angle + dist*PI + sin(angle*1.0)*(dist + (.5+.5*sin(-PI/2.0+iTime*PI))*mod(iTime,2.0)) * 2.0 * PI);\n\tbrightness += .25 + .25 * sin(pow(dist,.5) / .707 * PI * 32.0 - iTime * PI * .5);\n\tif (dist < .01) brightness *= (dist / .01);\n\tvec4 color = vec4( brightness, brightness, brightness, 1.0);\n\tfragColor = color;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldsSRS.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[23, 23, 80, 80, 625]]}
{"id": "ldXXWM", "name": "distance noise", "author": "zugamifk", "description": "some voronoi noise using different distance metrics", "tags": ["voronoi", "lp", "manhatten"], "likes": 0, "viewed": 147, "date": "1401987149", "time_retrieved": "2024-06-20T18:11:32.779560", "image_code": "float usin(float x){return .5+.5*sin(x);}\nfloat ucos(float x){return .5+.5*cos(x);}\nvec2 mv(float x) {\n return vec2(sin(x + iTime)+4.*cos(x+iTime), cos(x + iTime)+2.*sin(iTime));\t\n}\n\nvec4 vn(vec2 uv) {\n\tvec4 col = vec4(0.);\n\tvec2 pt;\n\tfloat stp = .2;\n\tvec2 ptp = vec2(stp);\n\tfloat c = 0.1;\n\tfloat m = 3.;\n\tfloat d;\n\tfloat e;\n\tvec2 o;\n\tfloat t = iTime;\n\tfor(int i = 0; i < 50; i++) {\n\t\tptp.x = mod(ptp.x + stp, iResolution.x/iResolution.y);\n\t\tptp.y = mod(ptp.y + stp, 1.);\n\t\tpt = ptp + mv(c)*.1;\n\t\tc += stp;\n\t\t\n\t\to = uv-pt;\n\t\tfloat p = 2.5;\n\t\t// wonky metric\n\t\td = length(o) + .1*ucos(atan(o.y, o.x))*sign(o.y);\n\t\t// Lp metric\n\t\t//d = pow(pow(o.x, p)+pow(o.y, p), 1./p);\n\t\t// manhatten\n\t\t//d = abs(o.x)+abs(o.y);\n\t\t//euclidean\n\t\t//d = length(o);\n\t\tif (d < m) {\n\t\t\te = ucos(abs(d-m)*25.);\n\t\t\tm = d;\n\t\t\tcol = vec4(usin(c)-e, ucos(c*e), usin(e+c), 1.);\n\t\t}\n\t}\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec4 col = vn(uv);\n\tfragColor = col;\n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldXXWM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 20, 20, 41], [42, 42, 62, 62, 83], [84, 84, 102, 102, 181], [183, 183, 201, 201, 870], [872, 872, 929, 929, 1011]]}
{"id": "lsfSRj", "name": "test clouds with warping", "author": "antonOTI", "description": "I'm playing with iq's tutorial on warping:\nhttp://www.iquilezles.org/www/articles/warp/warp.htm", "tags": ["clouds", "fbm", "warping"], "likes": 6, "viewed": 612, "date": "1403870868", "time_retrieved": "2024-06-20T18:11:32.779560", "image_code": "mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0;\n\n    float res = mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n    return res;\n}\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.50000*noise( p ); p = m*p*2.02;\n    f += 0.25000*noise( p ); p = m*p*2.03;\n    f += 0.12500*noise( p ); p = m*p*2.01;\n    f += 0.06250*noise( p ); p = m*p*2.04;\n    f += 0.03125*noise( p );\n\n    return f/0.984375;\n}\n\nfloat beat = 0.;\n\nfloat pattern(vec2 p,out vec2 q,out vec2 r,out vec2 s)\n{\n\tfloat ct = 0.;\n\t\n\tfloat time = (iTime + sin(beat * 3.1416))*.1 ;\n\tq = vec2(fbm(p-vec2(cos(time),sin(time) )),fbm(p+vec2(4. +time*.25 ,2.8765-time*.25 )));\n\t\n\tr = vec2( fbm( p + 4.0*(q + vec2(1.7 - cos(time*.6),9.2 -  + time*.6 )) ),\n\t\t\t\t  fbm( p + 4.0*(q + vec2(8.3 - time*.6,2.8 + time*.6)) ) );\n\t\n\ts = vec2( fbm( r + 4.0*r + vec2(2.4 - sin(time*.6) , 15.01 + cos(time*.6)) ),\n\t\t\t\t   fbm( r + 4.0*(r + vec2(21.3 + time, 1.03 -time)) ) );\n\t\n\treturn fbm(p + 4. * s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy *10.;\n\tvec2 q,r,s;\n\tfloat f = pattern(uv,q,r,s);\n\tvec3 col = mix(vec3(dot(q,r)),vec3(dot(q,s)),f);\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsfSRj.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[45, 45, 68, 68, 107], [110, 110, 136, 136, 383], [385, 385, 406, 406, 653], [673, 673, 729, 729, 1198], [1200, 1200, 1257, 1257, 1427]]}
{"id": "lsfXRS", "name": "Sine Clouds", "author": "demofox", "description": "an attempt at a 2d cloud texture using sine waves\n\nadapated from info here: https://www.cs.drexel.edu/~david/Classes/Talks/RezaPres.pdf", "tags": ["procedural", "2d", "clouds", "sine"], "likes": 4, "viewed": 213, "date": "1403121580", "time_retrieved": "2024-06-20T18:11:33.210046", "image_code": "// adapated from info here: https://www.cs.drexel.edu/~david/Classes/Talks/RezaPres.pdf\n\n#define DEBUG_UNDER_OVER_FLOW 0\n\nfloat GetC(int i)\n{\n\treturn pow(0.707, float(i));\n}\n\nfloat GetF(int i)\n{\n\treturn pow(2.0, float(i));\n}\n\nfloat GetP(float axis, int i)\n{\n\treturn 1.57 * sin(0.5*GetF(i)*axis);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// input parameters\n\tconst float scale = 0.75;\n\tconst float timeMultiplier = 0.125;\n\tconst float speedX = 1.0;\n\tconst float speedY = 2.0;\n\tconst int numLoops = 6;\n\tconst float T0 = 0.0;\n\tconst float K = 0.4;\n\n\t// scale it and make it square\n\tvec2 uv = scale * fragCoord.xy / iResolution.xy;\n\tuv.x *= iResolution.x / iResolution.y;\n\t\n\t// advance time\n\tuv.x += iTime * timeMultiplier * speedX;\n\tuv.y += iTime * timeMultiplier * speedY;\n\t\n\tfloat color = 0.0;\n\tfor (int i = 0; i < numLoops; ++i)\n\t{\n\t\tfloat thisY = GetC(i) * sin(GetF(i)*uv.y + GetP(uv.x,i)) + T0;\n\n\t\tfloat thisX = 0.0;\n\t\tfor (int j = 0; j < numLoops; ++j)\n\t\t{\n\t\t\tif (j >= i)\n\t\t\t{\n\t\t\t\tthisX += GetC(j) * sin(GetF(j)*uv.x + GetP(uv.y,j)) + T0;\n\t\t\t}\n\t\t}\n\t\tcolor += thisX * thisY;\n\t}\n\tcolor *= K;\n\t\n\tfloat red = 0.0;\n\tfloat green = 0.0;\n\tfloat blue = 0.0;\n\t\n\t#if DEBUG_UNDER_OVER_FLOW\n\tif (color > 1.0)\n\t{\n\t\tred = 1.0;\n\t}\n\telse if (color < 0.0)\n\t{\n\t\tblue = 1.0;\n\t}\n\telse\n\t#endif\n\t{\n\t\tred = color;\n\t\tgreen = color;\n\t\tblue = color;\n\t}\n\t\n\tfragColor = vec4(red,green,blue,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsfXRS.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 122, 141, 141, 173], [175, 175, 194, 194, 224], [226, 226, 257, 257, 297], [299, 299, 356, 377, 1392]]}
{"id": "lsfXWM", "name": "Stained", "author": "slade", "description": "A little ray tracing experiment with colored light transmittance and Fresnel reflectance with Voronoi \"stained glass\".  Mouse left/right to rotate the scene.", "tags": ["ray", "light", "glass", "transmittance", "fresnel", "trace", "stained"], "likes": 3, "viewed": 1125, "date": "1402363733", "time_retrieved": "2024-06-20T18:11:35.373825", "image_code": "#define M_PI 3.1415926535\n\nstruct ray {\n\tvec3 origin;\n\tvec3 direction;\n\tvec4 lightColor;\n\tfloat transmittance;\n\tfloat rayLength;\n\tint lastHitObject;\n};\n\n\n//Camera position setup\nvec3 startingLocation = vec3(0.0, 5.0, 15.0);\n\t\n//Floor setup\nconst vec4 sceneFloor = vec4(0.0, 1.0, 0.0, 0.0);\nconst float floorTransmission = 0.7;\n\n//Window setup\nconst vec4 sceneWindow = vec4(-1.0, 0.0, 0.0, -7.5);\nconst vec2 windowStart = vec2(-10.0, 1.0);\nconst vec2 windowWidthHeight = vec2(20.0, 15.0);\nconst float glassTransmission = 0.5;\n\n//Random meaningless sphere setup\nconst vec4 sceneSphere = vec4(0.0, 3.0, 3.0, 3.0);\nconst float sphereTransmission = 0.5;\n\n//Light setup\nvec4 light = vec4(-480.0, 0.0, 0.0, 110.0);\n\nconst float tau = 6.28318530717958647692;\n\n// Using modified Fast Voronoi Pattern (https://www.shadertoy.com/view/Msl3Rl) for the stained glass effect\n// Created by Ben Weston - 2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nvec4 Rand( ivec2 pos ) {\n\treturn texture( iChannel0, (.5+vec2(pos.xy))/256.0, -100.0 );\n}\n\nvec3 Voronoi( vec2 pos ) {\n\tvec2 d[8];\n\td[0] = vec2(0);\n\td[1] = vec2(1,0);\n\td[2] = vec2(0,1);\n\td[3] = vec2(1);\n\t\n\tconst float maxDisplacement = .7;//.518; //tweak this to hide grid artefacts\n\t\n\tfloat closest = 12.0;\n\tvec4 result;\n\tfor ( int i=0; i < 8; i++ )\n\t{\n\t\tvec4 r = Rand(ivec2(floor(pos+d[i])));\n\t\tvec2 p = d[i] + maxDisplacement*(r.xy-.5);\n\t\tp -= fract(pos);\n\t\tfloat lsq = dot(p,p);\n\t\tif ( lsq < closest )\n\t\t{\n\t\t\tclosest = lsq;\n\t\t\tresult = r;\n\t\t}\n\t}\n\treturn fract(result.xyz+result.www); // random colour\n}\n\nmat4 rotateX(float theta) {\n\tfloat cosTheta = cos(theta);\n\tfloat sinTheta = sin(theta);\n\treturn mat4(1.0, 0.0, 0.0, 0.0,\n\t\t\t\t0.0, cosTheta, -sinTheta, 0.0,\n\t\t\t\t0.0, sinTheta, cosTheta, 0.0,\n\t\t\t\t0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 rotateY(float theta) {\n\tfloat cosTheta = cos(theta);\n\tfloat sinTheta = sin(theta);\n\treturn mat4(cosTheta, 0.0, sinTheta, 0.0,\n\t\t\t\t0.0, 1.0, 0.0, 0.0,\n\t\t\t\t-sinTheta, 0.0, cosTheta, 0.0,\n\t\t\t\t0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 translate(vec3 v) {\n\treturn mat4(1.0, 0.0, 0.0, v.x,\n\t\t\t\t0.0, 1.0, 0.0, v.y,\n\t\t\t\t0.0, 0.0, 1.0, v.z,\n\t\t\t\t0.0, 0.0, 0.0, 1.0);\n}\n\nfloat iPlane(in ray sceneRay, in vec4 plane) {\n\treturn -(dot(sceneRay.origin, normalize(plane.xyz)) + plane.w) / dot(sceneRay.direction, plane.xyz);\n}\n\nfloat iRectangle(in ray sceneRay, in vec4 plane, in vec2 constraintsXY, in vec2 widthHeight, out vec2 uvCoord) {\n\tfloat planeIntersection = iPlane(sceneRay, plane);\n\tvec3 hitPoint = sceneRay.origin + sceneRay.direction*planeIntersection;\n\tif (hitPoint.z < constraintsXY.x || hitPoint.z > constraintsXY.x+widthHeight.x) {\n\t\tplaneIntersection = -1.0;\n\t}\n\telse if (hitPoint.y < constraintsXY.y || hitPoint.y > constraintsXY.y+widthHeight.y) {\n\t\tplaneIntersection = -1.0;\n\t}\n\t\n\tif (planeIntersection >= 0.0) {\n\t\tuvCoord = vec2(hitPoint.z - constraintsXY.x, hitPoint.y - constraintsXY.y);\n\t}\n\telse {\n\t\tuvCoord = vec2(-1.0);\n\t}\n\treturn planeIntersection;\n}\n\nvec2 iSphere(in ray sceneRay, in vec4 sph) {\n\t//sphere at origin has equation |xyz| = r\n\t//so |xyz|^2 = r^2.\n\t//Since |xyz| = rayOrigin + t*rayDirection (where t is the distance to move along the ray),\n\t//we have rayOrigin^2 + 2*rayOrigin*t*rayDirection + t^2 - r^2. This is a quadratic equation, so:\n\tvec3 oc = sceneRay.origin - sph.xyz; //distance ray origin - sphere center\n\t\n\tfloat b = dot(oc, sceneRay.direction);\n\tfloat c = dot(oc, oc) - sph.w * sph.w; //sph.w is radius\n\tfloat h = b*b - c; //Commonly known as delta. The term a is 1 so is not included.\n\t\n\tvec2 t;\n\tif(h < 0.0) \n\t\tt = vec2(-1.0);\n\telse  {\n\t\tfloat sqrtH = sqrt(h);\n\t\tt.x = (-b - sqrtH); //Again a = 1.\n\t\tt.y = (-b + sqrtH);\n\t}\n\treturn t;\n}\n\n//Get sphere normal.\nvec3 nSphere(in vec3 pos, in vec4 sph) {\n\treturn normalize((pos - sph.xyz)/sph.w);\n}\n\nfloat fancyLight(ray primaryRay, vec4 light) {\n\tfloat luminance = 0.0;\n\t//vector from origin to light center\n\tvec3 originToLight = light.xyz - primaryRay.origin;\n\t\n\t//check to see if the light is behind us\n\tif(dot(primaryRay.direction, originToLight) >= 0.0) {\n\t\t//see if our ray is within the light boundary\n\t\tvec3 nearest = -(originToLight\n\t\t\t\t\t\t + primaryRay.direction * dot(-originToLight, primaryRay.direction));\n\t\tfloat dist = length(nearest);\n\t\tif(dist <= light.w) {\n\t\t\tfloat lightness = (light.w - dist) / light.w;\n\t\t\tluminance = pow(lightness, 22.0);\n\t\t}\n\t}\n\treturn luminance;\n}\n\n//check for ray intersection against scene elements\nint intersect(in ray sceneRay, out vec2 t, out vec2 uvCoord) {\n\tt = vec2(1000.0);\n\tint hitId = -1;\n\t\n\t//check against the floor\n\tfloat tFloor = iPlane(sceneRay, sceneFloor);\n\tif (tFloor > 0.0 && tFloor < t.x) {\n\t\tt = vec2(tFloor);\n\t\thitId = 0;\n\t}\n\t\n\t//check against the stained glass window\n\tfloat tWindow = iRectangle(sceneRay, sceneWindow, windowStart, windowWidthHeight, uvCoord);\n\tif (tWindow > 0.0 && tWindow < t.x) {\n\t\tt = vec2(tWindow);\n\t\thitId = 1;\n\t}\n\t\n\tvec2 tSphere = iSphere(sceneRay, sceneSphere);\n\tif (tSphere.x > 0.0 && tSphere.x < t.x) {\n\t\tt = tSphere;\n\t\thitId = 2;\n\t}\n\t\n\treturn hitId;\n}\n\nvec4 doLighting(vec3 eyePoint, vec3 objPoint, vec3 normalAtPoint, vec3 lightPos, vec4 lightParams) {\n\tfloat fresnelBias = lightParams.x;\n\tfloat fresnelPower = lightParams.y;\n\tfloat fresnelScale = lightParams.z;\n\tfloat constAttenuation = 9000000.0;\n\tfloat linearAttenuation = 0.22;\n\tfloat quadraticAttenuation = 0.2;\n\tfloat dist = length(lightPos-objPoint);\n\tfloat attenuation = constAttenuation / ((1.0+linearAttenuation*dist)*(1.0+quadraticAttenuation*dist*dist));\n\tfloat shininess = lightParams.w;\n\tvec3 I = normalize(objPoint - eyePoint);\n\tvec3 lightDirection = normalize(lightPos-objPoint);\n\tvec3 viewDirection = normalize(eyePoint-objPoint);\n\tvec3 halfVector = normalize(lightDirection + viewDirection);\n\tfloat dif = clamp(dot(normalAtPoint, lightDirection), 0.0, 1.0);\n\tfloat spec = max(0.0, pow(dot(normalAtPoint, halfVector), shininess));\n\tfloat fresnel = clamp(fresnelBias + fresnelScale * pow(1.0 + dot(I, normalAtPoint), fresnelPower), 0.0, 1.0);\n\treturn attenuation * vec4(vec3(mix(spec, dif, fresnel)), 1.0);\n}\n\nvec4 doLighting(vec3 eyePoint, vec3 objPoint, vec3 normalAtPoint, vec3 lightPos) {\n\tfloat fresnelBias = 0.25;\n\tfloat fresnelPower = 5.0;\n\tfloat fresnelScale = 1.0;\n\tfloat shininess = 20.0;\n\tvec4 lightParams = vec4(fresnelBias, fresnelPower, fresnelScale, shininess);\n\treturn doLighting(eyePoint, objPoint, normalAtPoint, lightPos, lightParams); \n}\n\nvoid doShadowColor(in ray primaryRay, inout vec4 col) {\n\tvec4 returnColor = vec4(0.0);\n\tvec2 shadowUV;\n\tvec2 shadowT;\n\tint shadowId;\n\tfloat shadowCheckDelta = light.w;\n\tray shadowRay;\n\tshadowRay.lightColor = primaryRay.lightColor;\n\tshadowRay.transmittance = primaryRay.transmittance;\n\tvec3 pos = primaryRay.origin + primaryRay.rayLength*primaryRay.direction;\n\tshadowRay.origin = pos - 0.001*primaryRay.direction;\n\tfor (int i = 0; i < 7; i++) {\n\t\t//soft shadows\n\t\tif (i == 0) {\n\t\t\tvec4 tempLight = light;\n\t\t\ttempLight.x += shadowCheckDelta;\n\t\t\tshadowRay.direction = normalize(tempLight.xyz-pos);\n\t\t}\n\t\telse if (i == 1) {\n\t\t\tvec4 tempLight = light;\n\t\t\ttempLight.x -= shadowCheckDelta;\n\t\t\tshadowRay.direction = normalize(tempLight.xyz-pos);\n\t\t}\n\t\telse if (i == 2) {\n\t\t\tvec4 tempLight = light;\n\t\t\ttempLight.y += shadowCheckDelta;\n\t\t\tshadowRay.direction = normalize(tempLight.xyz-pos);\n\t\t}\n\t\telse if (i == 3) {\n\t\t\tvec4 tempLight = light;\n\t\t\ttempLight.y -= shadowCheckDelta;\n\t\t\tshadowRay.direction = normalize(tempLight.xyz-pos);\n\t\t}\n\t\telse if (i == 4) {\n\t\t\tvec4 tempLight = light;\n\t\t\ttempLight.z += shadowCheckDelta;\n\t\t\tshadowRay.direction = normalize(tempLight.xyz-pos);\n\t\t}\n\t\telse if (i == 5) {\n\t\t\tvec4 tempLight = light;\n\t\t\ttempLight.z -= shadowCheckDelta;\n\t\t\tshadowRay.direction = normalize(tempLight.xyz-pos);\n\t\t}\n\t\telse\n\t\t\tshadowRay.direction = normalize(light.xyz-pos);\n\t\tshadowId = intersect(shadowRay, shadowT, shadowUV);\n\t\tvec3 shadowHit = shadowRay.origin + shadowT.x * shadowRay.direction;\n\t\t\n\t\t//if we have a non-negative id, we've hit something\n\t\tif (shadowId >= 0 && primaryRay.lastHitObject >= 0) {\n\t\t\tvec4 tempColor;\n\t\t\tif (light.y > 0.0) {\n\t\t\t\tif (primaryRay.lastHitObject != 1\n\t\t\t\t\t&& shadowId == 1\n\t\t\t\t\t&& length(light.xyz-shadowRay.origin) > length(shadowHit-shadowRay.origin)) {\n\t\t\t\t\t//shade objects that are shadowed by the window\n\t\t\t\t\tvec3 nor = sceneWindow.xyz;\n\t\t\t\t\tshadowRay.lightColor = doLighting(primaryRay.origin, shadowHit, nor, light.xyz);\n\t\t\t\t\tshadowRay.lightColor *= 1.0 - vec4(Voronoi(shadowUV),1.0);\n\t\t\t\t\tshadowRay.transmittance = primaryRay.transmittance * glassTransmission;\n\t\t\t\t\ttempColor = mix(shadowRay.lightColor, col, shadowRay.transmittance);\n\t\t\t\t}\n\t\t\t\telse if (primaryRay.lastHitObject == 1) {\n\t\t\t\t\t//shade the back side of the window\n\t\t\t\t\tvec3 nor = -sceneWindow.xyz;\n\t\t\t\t\tshadowRay.lightColor = doLighting(primaryRay.origin, shadowHit, nor, light.xyz);\n\t\t\t\t\tshadowRay.lightColor *= vec4(Voronoi(shadowUV),1.0);\n\t\t\t\t\tshadowRay.transmittance = primaryRay.transmittance * glassTransmission;\n\t\t\t\t\ttempColor = mix(shadowRay.lightColor, col, shadowRay.transmittance);\n\t\t\t\t}\n\t\t\t\tif (primaryRay.lastHitObject != 1 && shadowId != 1) {\n\t\t\t\t\t//shadows for everything else in the scene\n\t\t\t\t\tshadowRay.lightColor = shadowRay.lightColor;\n\t\t\t\t\tshadowRay.transmittance = 0.5*primaryRay.transmittance;\n\t\t\t\t\ttempColor = mix(shadowRay.lightColor, col, 1.0-shadowRay.transmittance);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (primaryRay.lastHitObject >= 0) {\n\t\t\t\t//before \"sunrise\"\n\t\t\t\tshadowRay.lightColor = shadowRay.lightColor;\n\t\t\t\tshadowRay.transmittance = 0.5*primaryRay.transmittance;\n\t\t\t\ttempColor = mix(shadowRay.lightColor, col, shadowRay.transmittance);\n\t\t\t}\n\t\t\treturnColor += tempColor;\n\t\t}\n\t}\n\t//if we use a number slightly higher than our iteration count,\n\t//then we get dark, but not black, shadows.  This also washes\n\t//out the color of the color of the glass, so it's kind of a\n\t//trade-off.\n\tcol -= returnColor*(1.0/8.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//pixel coordinates from 0 to 1\n\tfloat aspectRatio = iResolution.x/iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\tfloat time = mod(0.1*iTime, M_PI);\n\tfloat sinTime = sin(time);\n\tlight.y = light.y + 500.0 * sinTime-100.0;\n\tlight.z = 450.0 * cos(time);\n\t\n\tvec2 mouse0To2PI = iMouse.xy/iResolution.xy*2.0*M_PI;\n\tmat4 cameraRotation = rotateY(mouse0To2PI.x);\n\tvec4 ro = vec4(startingLocation, 1.0);\n\tmat4 compound = translate(-ro.xyz) * cameraRotation * translate(ro.xyz);\n\tro = compound * ro;\n\t\n\t//generate a ray with origin ro and direction rd\n\tray primaryRay;\n\tprimaryRay.origin = ro.xyz;\n\tprimaryRay.direction = (cameraRotation * vec4(normalize(vec3( (-1.0+2.0*uv) * vec2(aspectRatio, 1.0), -1.0)), 1.0)).xyz;\n\tprimaryRay.lightColor = vec4(1.0);\n\tprimaryRay.transmittance = 1.0;\n\tprimaryRay.rayLength = -1.0;\n\tprimaryRay.lastHitObject = -1;\n\t\n\tray traceRay = primaryRay;\n\t\n\t\n\tvec4 col = vec4(1.0);\n\t//intersect the ray with scene\n\tvec2 uvCoord;\n\tvec2 t;\n\t//did we hit something?\n\tfor (int i = 0; i < 8; i++) {\n\t\tint id = intersect(traceRay, t, uvCoord);\n\t\tif (traceRay.transmittance > 0.01) {\n\t\t\ttraceRay.lastHitObject = id;\n\t\t\tif (primaryRay.lastHitObject < 0)\n\t\t\t\tprimaryRay.lastHitObject = traceRay.lastHitObject;\n\t\t\t//find the point where we hit\n\t\t\ttraceRay.rayLength = t.x;\n\t\t\tif (primaryRay.rayLength < 0.0)\n\t\t\t\tprimaryRay.rayLength = traceRay.rayLength;\n\t\t\t\n\t\t\tvec3 pos = traceRay.origin + traceRay.rayLength*traceRay.direction;\n\t\t\ttraceRay.origin = pos + 0.001 * traceRay.direction;\n\t\t\t\n\t\t\tif (id == 0) {\n\t\t\t\tcol = doLighting(primaryRay.origin, pos, sceneFloor.xyz, light.xyz);\n\t\t\t\ttraceRay.direction = reflect(traceRay.direction, sceneFloor.xyz);\n\t\t\t\ttraceRay.transmittance *= floorTransmission;\n\t\t\t\ttraceRay.lightColor = col;\n\t\t\t\tvec4 groundTextureColor = texture(iChannel1, 0.125*pos.xz, 0.0);\n\t\t\t\tcol = mix(primaryRay.lightColor, col, traceRay.transmittance);\n\t\t\t\tcol *= vec4(groundTextureColor.rgb, 1.0);\n\t\t\t}\n\t\t\telse if (id == 1) {\n\t\t\t\ttraceRay.lightColor = vec4(Voronoi(uvCoord),1.0);\n\t\t\t\ttraceRay.transmittance *= glassTransmission;\n\t\t\t\tray glassRay = traceRay;\n\t\t\t\ttraceRay.direction = reflect(traceRay.direction, sceneWindow.xyz);\n\t\t\t\t//did we hit something after the glass?\n\t\t\t\tint id = intersect(glassRay, t, uvCoord);\n\t\t\t\tif (id != 1 && glassRay.transmittance > 0.0) {\n\t\t\t\t\tglassRay.lastHitObject = id;\n\t\t\t\t\tglassRay.rayLength = t.x;\n\t\t\t\t\t\n\t\t\t\t\t//do stained glass coloring on the other side... effectively another shadow call\n\t\t\t\t\tvec4 stainedShadowColor = col;\n\t\t\t\t\t//This appears to break in Firefox, but not Chrome:\n\t\t\t\t\t//doShadowColor(glassRay, stainedShadowColor);\n\t\t\t\t\tvec3 pos = glassRay.origin + glassRay.rayLength*glassRay.direction;\n\t\t\t\t\t\n\t\t\t\t\tif (id == 0) {\n\t\t\t\t\t\tvec4 groundTextureColor = texture( iChannel1, 0.125*pos.xz, 0.0 );\n\t\t\t\t\t\tcol = mix(groundTextureColor, col, 1.0-glassRay.transmittance);\n\t\t\t\t\t}\n\t\t\t\t\tvec4 lighting = 0.25*doLighting(primaryRay.origin, pos, sceneFloor.xyz, light.xyz);\n\t\t\t\t\tcol = mix(lighting, col, 1.0-glassRay.transmittance);\n\t\t\t\t\t\n\t\t\t\t\tcol = mix(stainedShadowColor, col, 1.0-glassRay.transmittance);\n\t\t\t\t\t\n\t\t\t\t\tcol = mix(glassRay.lightColor, col, 1.0-glassRay.transmittance);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (id == 2) {\n\t\t\t\tvec3 sphNormal = nSphere(pos, sceneSphere);\n\t\t\t\ttraceRay.direction = reflect(traceRay.direction, sphNormal);\n\t\t\t\ttraceRay.transmittance *= sphereTransmission;\n\t\t\t\tfloat fresnelBias = 0.25;\n\t\t\t\tfloat fresnelPower = 5.0;\n\t\t\t\tfloat fresnelScale = 1.0;\n\t\t\t\tfloat shininess = 5.0;\n\t\t\t\tvec4 lightParams = vec4(fresnelBias, fresnelPower, fresnelScale, shininess);\n\t\t\t\tcol = doLighting(primaryRay.origin, pos, sphNormal, light.xyz, lightParams);\n\t\t\t\ttraceRay.lightColor = col;\n\t\t\t\tcol = mix(traceRay.lightColor, col, traceRay.transmittance);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//sky\n\t\t\t\tcol = vec4(0.7*sinTime, 0.65*sinTime, sinTime, 1.0);\n\t\t\t\ttraceRay.lightColor = col;\n\t\t\t}\n\t\t}\n\t}\n\tif (primaryRay.lastHitObject < 0 || primaryRay.lastHitObject == 1) {\n\t\tif (light.y > 0.0) {\n\t\t\tfloat lightValue = 2.0*fancyLight(primaryRay, light);\n\t\t\tcol += vec4(vec3(1.0-col.rgb)*lightValue*primaryRay.lightColor.rgb, 1.0);\n\t\t}\n\t}\n\t\n\tdoShadowColor(primaryRay, col);\n\t\n\tfragColor = clamp(col, vec4(0.0), vec4(1.0));\n}", "image_inputs": [{"id": "XsXGRn", "previewfilepath": "/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsfXWM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[752, 979, 1003, 1003, 1068], [1070, 1070, 1096, 1096, 1584], [1586, 1586, 1613, 1613, 1802], [1804, 1804, 1831, 1831, 2020], [2022, 2022, 2046, 2046, 2154], [2156, 2156, 2202, 2202, 2306], [2308, 2308, 2420, 2420, 2958], [2960, 2960, 3004, 3260, 3671], [3673, 3694, 3734, 3734, 3778], [3780, 3780, 3826, 3826, 4367], [4369, 4421, 4483, 4483, 5023], [5025, 5025, 5125, 5125, 6048], [6050, 6050, 6132, 6132, 6397], [6399, 6399, 6454, 6454, 9842], [9844, 9844, 9901, 9934, 14072]]}
{"id": "lssSRS", "name": "mirror ball (mouse interactive)", "author": "bigblueboo", "description": "interactive illusion inspired by the incomparable akiyoshi takaoka (see:http://www.psy.ritsumei.ac.jp/~akitaoka/opart10e.html)\n\ni'm not doing raymarching extravaganzas but shadertoy is fun 8)", "tags": ["2d", "mouse", "interactive", "opticalillusion", "mirrorball", "takaoka"], "likes": 0, "viewed": 246, "date": "1403481423", "time_retrieved": "2024-06-20T18:11:35.373825", "image_code": "float PI = 3.1415926;\n\nfloat easeWithSteps(float t, float steps)\n{\n\tfloat frac = 1.0 / steps;\t\n\tfloat eT = mod(t, frac);\n\tfloat x = eT / frac;\n\treturn t - eT + frac * x*x*x*(x*(x*6.0 - 15.0) + 10.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 mouse = iMouse.xy / iResolution.xy- vec2(.5,.5);\n\tvec2 coord = uv - vec2(.5,.5);\n\tcoord.y *= iResolution.y / iResolution.x;\n\t\n\tfloat angle = atan(coord.y, coord.x);\n\tfloat dist = length(coord);\n\t\n\tfloat t = mod(iTime / 10.0, 1.0);\n\tfloat eT = easeWithSteps(t, 4.0);\n\tfloat sT = sin(eT * PI * 2.0);\n\tfloat baseFactor = 48.0 + 2.0 * sin(.1 * iTime * PI);\n\tfloat factor = baseFactor;\n\tif (dist < .20) factor = baseFactor + sT * 24.0;\n\tfloat brightness = .5 + .25 * sin(1.0 * PI * 2.0 *mouse.x + coord.x * factor) +\n\t\t.25 * sin(1.0 * PI * 2.0 *mouse.y+coord.y * factor);\n\t\n\t//float brightness = .25 + .25 * \n\t\t//sin(48.0*angle + dist*PI + sin(angle*1.0)*(dist + (.5+.5*sin(-PI/2.0+iTime*PI))*mod(iTime,2.0)) * 2.0 * PI);\n\t///brightness += .25 + .25 * sin(pow(dist,.5) / .707 * PI * 32.0 - iTime * PI * .5);\n//\tif (dist < .01) brightness *= (dist / .01);\n\tvec4 color = vec4( brightness, brightness, brightness, 1.0);\n\tfragColor = color;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lssSRS.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[23, 23, 66, 66, 201], [202, 202, 259, 259, 1241]]}
{"id": "lssSWM", "name": "Kaleidoscopy", "author": "TekF", "description": "Trying to make a 3D fractal with what I've learnt from messing with mandelbrots. I can't work out how to centre the camera on it!\nN.B. uses cheap ambient occlusion and specular occlusion (see Shade() function).", "tags": ["fractal"], "likes": 42, "viewed": 878, "date": "1402671523", "time_retrieved": "2024-06-20T18:11:36.846543", "image_code": "// Hazel Quantock 2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat DistanceField( vec3 pos )\n{\n\t//pos = abs(pos);\n\t//return max( pos.x, max( pos.y, pos.z ) )-1.0;\n\t\n//\treturn (length(pos-vec3(0,-1,0))-2.0 + sin(sqrt(pow(atan(length(pos.xz),pos.y),2.0)+1.0)*20.0-iTime)/20.0)*.707;\n\t\n\t//return (pos.y + sin(pos.x*1.0)*sin(pos.z*1.0)/1.0)*.7;\n\t\n\t// fractalise space, rotate then mirror on axis\n\tconst float tau = 6.2831853;\n\tconst float phi = 1.61803398875;\n\t\n\tvec3 p = pos;\n\tfloat T = .3*iTime;\n\tfloat a0 = .2*phi*(T+sin(T));//.5*tau/phi;\n\tfloat a1 = .05*phi*(T-sin(T))*phi;//tau/phi;\n\tfloat c0 = cos(a0);\n\tvec2 s0 = vec2(1,-1)*sin(a0);\n\tfloat c1 = cos(a1);\n\tvec2 s1 = vec2(1,-1)*sin(a1);\n\t\n\tconst int n = 32;\n\tfloat o = 1.0;\n\n\t// centre on the first mirror\n\tp.x -= o;\n\t\n\t// and the second\n\tp.y += o*s0.x;\n\tp.z -= o*s1.x;\n\t\n\tfor ( int i=0; i < n; i++ )\n\t{\n\t\tp.x = abs(p.x+o)-o;\n\t\tp.xy = p.xy*c0 + p.yx*s0;\n\t\tp.xz = p.xz*c1 + p.zx*s1;\n\t\t//o = o/sqrt(2.0);\n\t\t//o = o*.8;\n\t\t//o = max( o*.8 - .02, o*.7 );\n\t\t//o = o-1.0/float(n);\n\t\t//o = o*(float(n-i-1)/float(n-i)); // same as^\n\t\t//o = o*.8*(float(n-i-1)/float(n-i));\n\t\to = o*.9*(float(n-i-1)/float(n-i));\n\t\t//o = o/phi;\n\t}\n\n\n\t// spheres\t\n//\treturn length(p)-.15;\n\n\t// cubes\n//\treturn max(abs(p.x),max(abs(p.y),abs(p.z)))-.14;\n\n\t// octahedra\t\n//\treturn (abs(p.x)+abs(p.y)+abs(p.z))/sqrt(3.0)-.1;\n\t\n\t// spikes! Precision issues, but wow!\n//\treturn (abs(p.z)*.05+length(p.xy)*sqrt(1.0-.05*.05))-.1;\n\n\t// stretched octahedra\n//\tvec3 s = vec3(1,1,.3);\tp = abs(p)*s/length(s);\treturn dot(p,vec3(1))-.2;\n\t\n\t// tetrahedra\n\treturn max( max( p.x+p.y+p.z, -p.x-p.y+p.z), max( p.x-p.y-p.z, -p.x+p.y-p.z ) )/sqrt(3.0) -.1;\n\n\t// offset tetrahedra, for more variety\n//\tp -= .1;\n//\treturn max( max( p.x+p.y+p.z, -p.x-p.y+p.z), max( p.x-p.y-p.z, -p.x+p.y-p.z ) )/sqrt(3.0) - .1;\n}\n\n\nvec3 Sky( vec3 ray )\n{\n\treturn mix( vec3(.8), vec3(0), exp2(-(1.0/max(ray.y,.01))*vec3(.4,.6,1.0)) );\n}\n\n\nvec3 Shade( vec3 pos, vec3 ray, vec3 normal, vec3 lightDir, vec3 lightCol, float distance )\n{\n\tvec3 ambient = mix( vec3(.03,.05,.08), vec3(.1), (-normal.y+1.0) ); // ambient\n\t// ambient occlusion, based on my DF Lighting: https://www.shadertoy.com/view/XdBGW3\n\tfloat aoRange = distance/20.0;\n\tfloat occlusion = max( 0.0, 1.0 - DistanceField( pos + normal*aoRange )/aoRange ); // can be > 1.0\n\tocclusion = exp2( -3.0*pow(occlusion,2.0) ); // tweak the curve\n\tambient *= occlusion;\n\n\tvec3 light = lightCol*max(.0,dot(normal,lightDir));\n\tlight += ambient;\n\t\n\tvec3 h = normalize(lightDir-ray);\n\tvec3 specular = lightCol*pow(max(.0,dot(normal,h)), 100.0)*100.0/32.0;\n\t\n\tvec3 rray = reflect(ray,normal);\n\tvec3 reflection = Sky( rray );\n\t// prevent sparkles in heavily occluded areas\n\treflection *= occlusion;\n\t// specular occlusion, adjust the divisor for the gradient we expect\n\tocclusion = max( 0.0, 1.0 - DistanceField( pos + rray*aoRange )/(aoRange*dot(rray,normal)) ); // can be > 1.0\n\tocclusion = exp2( -2.0*pow(occlusion,2.0) ); // tweak the curve\n\treflection *= occlusion; // could fire an additional ray for more accurate results\n\t\n\tfloat fresnel = pow( 1.0+dot(normal,ray), 5.0 );\n\tfresnel = mix( .0, .5, fresnel );\n\t\n\tvec3 albedo = vec3(1);//.6,.3,.15);//.8,.02,0);\n\t\n\treturn mix( light*albedo, reflection, fresnel ) + specular;\n}\n\n\n\n\n// Isosurface Renderer\n\nfloat traceStart = .1; // set these for tighter bounds for more accuracy\nfloat traceEnd = 25.0;\nfloat Trace( vec3 pos, vec3 ray )\n{\n\tfloat t = traceStart;\n\tfloat h;\n\tfor( int i=0; i < 60; i++ )\n\t{\n\t\th = DistanceField( pos+t*ray );\n\t\tif ( h < .001 || t > traceEnd )\n\t\t\tbreak;\n\t\tt = t+h;\n\t}\n\t\n\tif ( t > traceEnd )//|| h > .001 )\n\t\treturn 0.0;\n\t\n\treturn t;\n}\n\nfloat TraceMin( vec3 pos, vec3 ray )\n{\n\tfloat Min = traceEnd;\n\tfloat t = traceStart;\n\tfloat h;\n\tfor( int i=0; i < 60; i++ )\n\t{\n\t\th = DistanceField( pos+t*ray );\n\t\tMin = min(h,Min);\n\t\tif ( /*h < .001 ||*/ t > traceEnd )\n\t\t\tbreak;\n\t\tt = t+max(h,.1);\n\t}\n\t\n\treturn Min;\n}\n\nvec3 Normal( vec3 pos, vec3 ray, float distance )\n{\n\t// in theory we should be able to get a good gradient using just 4 points\n//\tvec2 d = vec2(-1,1) * .01;\n\tvec2 d = vec2(-1,1) * .5 * distance / iResolution.x;\n\tvec3 p0 = pos+d.xxx; // tetrahedral offsets\n\tvec3 p1 = pos+d.xyy;\n\tvec3 p2 = pos+d.yxy;\n\tvec3 p3 = pos+d.yyx;\n\t\n\tfloat f0 = DistanceField(p0);\n\tfloat f1 = DistanceField(p1);\n\tfloat f2 = DistanceField(p2);\n\tfloat f3 = DistanceField(p3);\n\t\n\tvec3 grad = p0*f0+p1*f1+p2*f2+p3*f3 - pos*(f0+f1+f2+f3);\n\t\n\t// prevent normals pointing away from camera (caused by precision errors)\n\tfloat gdr = dot ( grad, ray );\n\tgrad -= max(.0,gdr)*ray;\n\t\n\treturn normalize(grad);\n}\n\n\n// Camera\n\nvec2 fragCoord;\n\nvec3 Ray( float zoom )\n{\n\treturn vec3( fragCoord.xy-iResolution.xy*.5, iResolution.x*zoom );\n}\n\nvec3 Rotate( inout vec3 v, vec2 a )\n{\n\tvec4 cs = vec4( cos(a.x), sin(a.x), cos(a.y), sin(a.y) );\n\t\n\tv.yz = v.yz*cs.x+v.zy*cs.y*vec2(-1,1);\n\tv.xz = v.xz*cs.z+v.zx*cs.w*vec2(1,-1);\n\t\n\tvec3 p;\n\tp.xz = vec2( -cs.w, -cs.z )*cs.x;\n\tp.y = cs.y;\n\t\n\treturn p;\n}\n\n\n// Camera Effects\n\nvoid BarrelDistortion( inout vec3 ray, float degree )\n{\n\t// would love to get some disperson on this, but that means more rays\n\tray.z /= degree;\n\tray.z = ( ray.z*ray.z - dot(ray.xy,ray.xy) ); // fisheye\n\tray.z = degree*sqrt(ray.z);\n}\n\nvec3 LensFlare( vec3 ray, vec3 light, float lightVisible )\n{\n\tvec2 dirtuv = fragCoord.xy/iResolution.x;\n\t\n\tfloat dirt = 1.0-texture( iChannel1, dirtuv ).r;\n\t\n\tfloat l = (dot(light,ray)*.5+.5)*lightVisible;\n\t\n\treturn ((pow(l,40.0)+.04)*dirt*.1 + 1.0*pow(l,200.0))*vec3(1.05,1,.95);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 _fragCoord )\n{\n    fragCoord = _fragCoord;\n\tvec3 ray = Ray(1.0);\n\tBarrelDistortion( ray, .5 );\n\tray = normalize(ray);\n\tvec3 localRay = ray;\n\n\tvec2 mouse = iMouse.yx/iResolution.yx - .5;\n\tvec3 pos = 8.0*Rotate( ray, vec2(.2,-3.0+iTime*.1)+vec2(1.6,-6.3)*mouse );\n\t\n\tvec3 col;\n\n\tvec3 lightDir = normalize(vec3(3,2,-1));\n\t\n\tfloat t = Trace( pos, ray );\n\tif ( t > .0 )\n\t{\n\t\tvec3 p = pos + ray*t;\n\t\t\n\t\t// shadow test\n\t\tfloat s = Trace( p, lightDir );\n\t\t\n\t\tvec3 n = Normal(p, ray, t);\n\t\tcol = Shade( p, ray, n, lightDir, (s>.0)?vec3(0):vec3(1.1,1,.9), t );\n\t\t\n\t\t// fog\n\t\tfloat f = 40.0;\n\t\tcol = mix( vec3(.8), col, exp2(-(t-3.0)*vec3(.4,.6,1.0)/f) );\n\t}\n\telse\n\t{\n\t\tcol = Sky( ray );\n\t}\n\t\n\t// lens flare\n\tfloat sun = TraceMin( pos, lightDir );\n\tcol += LensFlare( ray, lightDir, smoothstep(-.5,.0,sun) );\n\n\t// vignetting:\n\tcol *= smoothstep( .5, .0, dot(localRay.xy,localRay.xy) );\n\n\t// compress bright colours, ( because bloom vanishes in vignette )\n\tvec3 c = (col-1.0);\n\tc = sqrt(c*c+.01); // soft abs\n\tcol = mix(col,1.0-c,.48); // .5 = never saturate, .0 = linear\n\t\n\t// grain\n\tvec2 grainuv = fragCoord.xy + floor(iTime*60.0)*vec2(37,41);\n\tvec2 filmNoise = texture( iChannel0, .5*grainuv/iChannelResolution[0].xy ).rb;\n\tcol *= mix( vec3(1), mix(vec3(1,.5,0),vec3(0,.5,1),filmNoise.x), .1*filmNoise.y );\n\n\t\n\tfragColor = vec4(pow(col,vec3(1.0/2.2)),1);\n}\n", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lssSWM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 111, 144, 441, 1860], [1863, 1863, 1885, 1885, 1966], [1969, 1969, 2062, 2062, 3304], [3356, 3429, 3464, 3464, 3688], [3690, 3690, 3728, 3728, 3957], [3959, 3959, 4010, 4115, 4630], [4633, 4661, 4685, 4685, 4755], [4757, 4757, 4794, 4794, 5009], [5012, 5031, 5086, 5157, 5264], [5266, 5266, 5326, 5326, 5548], [5551, 5551, 5609, 5609, 6941]]}
{"id": "MdlXRB", "name": "Trivial 2D Lighting Bumpmapping", "author": "KrunoSaho", "description": "Procedurally generates a perturbed normal via partial derivatives using the dFdx, dFdy functions that take noise as input. My main goal was to trivialise lighting as much as possible for my game, as it is 2D, orthographic, and using a birds eye view.", "tags": ["procedural", "2d", "bumpmapping"], "likes": 5, "viewed": 410, "date": "1403610846", "time_retrieved": "2024-06-20T18:11:37.204197", "image_code": "const int LIGHT_COUNT = 4;\n\nstruct Light {\n\tvec3 position;\n\tvec3 colour;\n\tfloat falloff;\n} lights[LIGHT_COUNT];\n\n\nvoid setUpLights() {\n\tlights[0].position = vec3(sin(iTime)*0.5 + 0.5, sin(iTime)*0.5 + 0.5, 0.0);\n\tlights[0].colour = vec3(1.0);\n\tlights[0].falloff = 3.0;\n\t\n\tlights[1].position = vec3(0.0, 1.0, 0.0);\n\tlights[1].colour = vec3(1.0, 0.0, 0.0);\n\tlights[1].falloff = 3.0;\n\t\n\tlights[2].position = vec3(1.0, 0.0, 0.0);\n\tlights[2].colour = vec3(0.0, 1.0, 0.0);\n\tlights[2].falloff = 12.0;\n\t\n\tlights[3].position = vec3(1.0, 1.0, 0.0);\n\tlights[3].colour = vec3(0.0, 0.0, 1.0);\n\tlights[3].falloff = 3.0;\n}\n\n\nvec3 computeLight(const vec3 surface, const vec3 normal, \n\t\t\t\t  const vec3 lightOrigin, const vec3 lcolour,\n\t\t\t\t  const float falloff) {\n\tvec3 lightDir = lightOrigin - surface;\n\tvec3 ray = -normalize(lightDir);\n\t\n\tfloat intensity = dot(normal, ray);\n\treturn pow(intensity, falloff) * lcolour / length(lightDir);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tsetUpLights();\n\t\n\tvec3 uv = vec3(fragCoord.xy / iResolution.xy, 1.0);\n\t\n\t// Generate the normal and perturb\n\tfloat noise = texture(iChannel0, uv.xy).r;\n\tvec3 normal = normalize(vec3(dFdx(noise), dFdy(noise), 1.0));\n\t\n\t// Aggregate all light interactions\n\tvec3 colour = vec3(0.0);\n\tfor(int i=0; i < LIGHT_COUNT; i++)\n\t\tcolour += computeLight(uv, normal, lights[i].position, lights[i].colour, lights[i].falloff);\n\tcolour /= float(LIGHT_COUNT);\n\t\n\t// Gamma correction\n\tcolour = pow(colour, vec3(1.0/1.4));\n\t\n\tfragColor = vec4(colour, 1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdlXRB.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[114, 114, 134, 134, 607], [610, 610, 746, 746, 923], [926, 926, 983, 983, 1523]]}
{"id": "MdlXRS", "name": "Noise animation - Flow", "author": "nimitz", "description": "Playing with different ways of animating noise. In this version, the noise is made using a technique similar to \"flow noise\" (maybe it even qualifies as flow noise)", "tags": ["procedural", "2d", "noise"], "likes": 236, "viewed": 12272, "date": "1403494492", "time_retrieved": "2024-06-20T18:11:37.695075", "image_code": "// Noise animation - Flow\n// 2014 by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/MdlXRS\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n\n//Somewhat inspired by the concepts behind \"flow noise\"\n//every octave of noise is modulated separately\n//with displacement using a rotated vector field\n\n//normalization is used to created \"swirls\"\n//usually not a good idea, depending on the type of noise\n//you are going for.\n\n//Sinus ridged fbm is used for better effect.\n\n#define time iTime*0.1\n#define tau 6.2831853\n\nmat2 makem2(in float theta){float c = cos(theta);float s = sin(theta);return mat2(c,-s,s,c);}\nfloat noise( in vec2 x ){return texture(iChannel0, x*.01).x;}\nmat2 m2 = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat grid(vec2 p)\n{\n\tfloat s = sin(p.x)*cos(p.y);\n\treturn s;\n}\n\nfloat flow(in vec2 p)\n{\n\tfloat z=2.;\n\tfloat rz = 0.;\n\tvec2 bp = p;\n\tfor (float i= 1.;i < 7.;i++ )\n\t{\n\t\tbp += time*1.5;\n\t\tvec2 gr = vec2(grid(p*3.-time*2.),grid(p*3.+4.-time*2.))*0.4;\n\t\tgr = normalize(gr)*0.4;\n\t\tgr *= makem2((p.x+p.y)*.3+time*10.);\n\t\tp += gr*0.5;\n\t\t\n\t\trz+= (sin(noise(p)*8.)*0.5+0.5) /z;\n\t\t\n\t\tp = mix(bp,p,.5);\n\t\tz *= 1.7;\n\t\tp *= 2.5;\n\t\tp*=m2;\n\t\tbp *= 2.5;\n\t\tbp*=m2;\n\t}\n\treturn rz;\t\n}\n\nfloat spiral(vec2 p,float scl) \n{\n\tfloat r = length(p);\n\tr = log(r);\n\tfloat a = atan(p.y, p.x);\n\treturn abs(mod(scl*(r-2./scl*a),tau)-1.)*2.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy-0.5;\n\tp.x *= iResolution.x/iResolution.y;\n\tp*= 3.;\n\tfloat rz = flow(p);\n\tp /= exp(mod(time*3.,2.1));\n\trz *= (6.-spiral(p,3.))*.9;\n\tvec3 col = vec3(.2,0.07,0.01)/rz;\n\tcol=pow(abs(col),vec3(1.01));\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdlXRS.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[522, 615, 643, 643, 708], [709, 709, 734, 734, 770], [817, 817, 837, 837, 880], [882, 882, 905, 905, 1282], [1284, 1284, 1317, 1317, 1427], [1429, 1429, 1486, 1486, 1752]]}
{"id": "MdlXzS", "name": "Point within triangle or quad", "author": "Coldberg", "description": "Check if point within triangle or quad", "tags": ["2dpointtrianglequad"], "likes": 2, "viewed": 347, "date": "1403550129", "time_retrieved": "2024-06-20T18:11:37.695075", "image_code": "\nfloat _sd (vec2 p1, vec2 p2, vec2 p3) {\n\treturn \n\t(p1.x - p3.x) * (p2.y - p3.y)- \n\t(p2.x - p3.x) * (p1.y - p3.y);\n}\n\nfloat _istri (vec2 pt, vec2 p1, vec2 p2, vec2 p3) {\n\tfloat v = length (vec3 (\n\t\tstep (0.0, _sd (pt, p1, p2)),\n\t\tstep (0.0, _sd (pt, p2, p3)),\n\t\tstep (0.0, _sd (pt, p3, p1))));\n\treturn 1.0 - step (1.0, v) + step (1.5, v);\n}\n\nfloat _isquad (vec2 pt, vec2 p1, vec2 p2, vec2 p3, vec2 p4) {\n\treturn step (1.0, \n\t\t_istri (pt, p1, p2, p3)+\n\t\t_istri (pt, p3, p4, p1));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / min (iResolution.x, iResolution.y);\n\t\n\tfloat cfi = cos (iTime);\n\tfloat sfi = sin (iTime);\n\tuv *= mat2 (-sfi, cfi, cfi, sfi);\n\t\n\tfragColor = vec4 (1.0) * _isquad (uv, \n\t\tvec2 (-0.5, -0.5),\n\t\tvec2 (+0.5, -0.5),\n\t\tvec2 (+0.5, +0.5),\n\t\tvec2 (-0.5, +0.5)) ;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdlXzS.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1, 1, 40, 40, 116], [118, 118, 169, 169, 340], [342, 342, 403, 403, 480], [483, 483, 540, 540, 846]]}
{"id": "MdsSDM", "name": "Twisties", "author": "TomoAlien", "description": "Look ma, My first shader! Just wanted to play around with the shaders! It's so much fun ^^\n\nEDIT 18.06.2014: Improved it with some nice shading and fixed diving by zero (d'oh!)", "tags": ["2d", "fake3d", "tube", "first", "twist"], "likes": 8, "viewed": 619, "date": "1402644630", "time_retrieved": "2024-06-20T18:11:37.695075", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfloat rurka = sin(uv.x*32.0-tan(uv.y*4.0+sin(iTime+uv.x*6.0-sin(iTime)*4.0)-2.0)*12.0+iTime*10.0);\n\tfloat shadey = -abs(tan(uv.y*4.0+sin(iTime+uv.x*6.0-sin(iTime)*4.0)-0.5));\n\t\n\tfloat komplet = rurka-cos(uv.x*125.0+iTime*32.0);\n\tfloat ouch = clamp((shadey+3.0)/3.0,0.0,1.0)*2.0;\n\n\tfragColor = vec4(komplet-ouch,abs(komplet*0.5)-ouch,0.1-komplet*1.0-ouch,komplet);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdsSDM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 466]]}
{"id": "MdsXDM", "name": "Psychedelix", "author": "TomoAlien", "description": "Super colorful. Dutch color scheme goes boom!", "tags": ["2d", "plasma", "colorful", "psychedelic", "weird", "acid", "dutchcolorscheme", "rainbows"], "likes": 13, "viewed": 1047, "date": "1402666864", "time_retrieved": "2024-06-20T18:11:37.695075", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 pos = (uv.xy-0.5);\n\tvec2 cir = ((pos.xy*pos.xy+sin(uv.x*18.0+iTime)/25.0*sin(uv.y*7.0+iTime*1.5)/1.0)+uv.x*sin(iTime)/16.0+uv.y*sin(iTime*1.2)/16.0);\n\tfloat circles = (sqrt(abs(cir.x+cir.y*0.5)*25.0)*5.0);\n\tfragColor = vec4(sin(circles*1.25+2.0),abs(sin(circles*1.0-1.0)-sin(circles)),abs(sin(circles)*1.0),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdsXDM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 420]]}
{"id": "MdXSzS", "name": "Galaxy of Universes", "author": "Dave_Hoskins", "description": "Big Bang? *pfft* It's just a small explosion somewhere in a rotating Galaxy of Universes!\nThanks to Kali for his fractal formula.", "tags": ["galaxy", "universes"], "likes": 224, "viewed": 25664, "date": "1403191786", "time_retrieved": "2024-06-20T18:11:38.010282", "image_code": "// https://www.shadertoy.com/view/MdXSzS\n// The Big Bang - just a small explosion somewhere in a massive Galaxy of Universes.\n// Outside of this there's a massive galaxy of 'Galaxy of Universes'... etc etc. :D\n\n// To fake a perspective it takes advantage of the screen being wider than it is tall.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy) - .5;\n\tfloat t = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .07)) * 2.2;\n\tfloat si = sin(t);\n\tfloat co = cos(t);\n\tmat2 ma = mat2(co, si, -si, co);\n\n\tfloat v1, v2, v3;\n\tv1 = v2 = v3 = 0.0;\n\t\n\tfloat s = 0.0;\n\tfor (int i = 0; i < 90; i++)\n\t{\n\t\tvec3 p = s * vec3(uv, 0.0);\n\t\tp.xy *= ma;\n\t\tp += vec3(.22, .3, s - 1.5 - sin(iTime * .13) * .1);\n\t\tfor (int i = 0; i < 8; i++)\tp = abs(p) / dot(p,p) - 0.659;\n\t\tv1 += dot(p,p) * .0015 * (1.8 + sin(length(uv.xy * 13.0) + .5  - iTime * .2));\n\t\tv2 += dot(p,p) * .0013 * (1.5 + sin(length(uv.xy * 14.5) + 1.2 - iTime * .3));\n\t\tv3 += length(p.xy*10.) * .0003;\n\t\ts  += .035;\n\t}\n\t\n\tfloat len = length(uv);\n\tv1 *= smoothstep(.7, .0, len);\n\tv2 *= smoothstep(.5, .0, len);\n\tv3 *= smoothstep(.9, .0, len);\n\t\n\tvec3 col = vec3( v3 * (1.5 + sin(iTime * .2) * .4),\n\t\t\t\t\t(v1 + v3) * .3,\n\t\t\t\t\t v2) + smoothstep(0.2, .0, len) * .85 + smoothstep(.0, .6, v3) * .3;\n\n\tfragColor=vec4(min(pow(abs(col), vec3(1.2)), 1.0), 1.0);\n}", "image_inputs": [{"id": "4dl3Rr", "previewfilepath": "https://soundcloud.com/paper-bag-records/young-galaxy-new-summer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/paper-bag-records/young-galaxy-new-summer", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdXSzS.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[211, 299, 356, 356, 1363]]}
{"id": "MdXXz2", "name": "wolf128", "author": "finalpatch", "description": "a webgl implementation of the wolf128.asm demo, analyzed and explained in my blog post http://finalpatch.blogspot.com.au/2014/06/dissecting-128-byte-raycaster.html", "tags": ["raycaster"], "likes": 15, "viewed": 3271, "date": "1404050581", "time_retrieved": "2024-06-20T18:11:38.016340", "image_code": "int imod(int a, int b)\n{\n\treturn a - a / b * b;\n}\nint xor(int a, int b)\n{\n\tint result = 0;\n\tint x = 1;\n\tfor(int i = 0; i <= 8; ++i)\n    {\n        if (imod(a,2) != imod(b,2))\n            result += x;\n        a /= 2;\n        b /= 2;\n        x *= 2;\n\t}\n\treturn result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 xy = uv * vec2(320.0,200.0);\n\tfloat z;\n    vec2 dist;\n    for(int i = 0; i < 256; ++i)\n    {\n\t\tz = float(i) / 255.0;\n\t\tdist = (xy - vec2(160.0,100.0)) * z;\t\t\n\t\tz = mod(z + iTime/4.0, 1.0);\n\t\tdist.x += sin(iTime*3.14)*15.0;\t\t\n\t\tint zz = int(z * 2.0);\n\t\tif (zz == 0) dist.x -= 10.0;\n\t\telse dist.x += 10.0;\t\t\n\t\tif ( (abs(dist.x) >= 25.0 && (imod(int(z*8.0),2)==0)) || abs(dist.y) >= 16.0)\n            break;\n\t}\n\tint texel = xor(xor(int(dist.x), int(dist.y)), int(mod(z, 0.25)*255.0));\n    texel = imod(texel, 16);\n    float c = float(texel) / 16.0;\n\tfragColor = vec4(c,c,c,1.0);\n\t//fragColor = vec4(z,z,z,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdXXz2.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 24, 24, 49], [50, 50, 73, 73, 267], [269, 269, 326, 326, 987]]}
{"id": "MsfXRj", "name": "You are feeling sleepy ... 2", "author": "Coldberg", "description": "Simple spiral checkerboard pattern", "tags": ["simplespiralcheckerboardpattern"], "likes": 8, "viewed": 237, "date": "1403900405", "time_retrieved": "2024-06-20T18:11:38.016340", "image_code": " #define PI 3.14159265359\n\n#define MSAA 4.0\n\nfloat hill (float t, float w, float p) {\t\n\treturn min (step (t-w/2.0,p), 1.0 - step (t+w/2.0,p));\n}\n\nmat2 rotate (float fi) {\n\tfloat cfi = cos (fi);\n\tfloat sfi = sin (fi);\t\n\treturn mat2 (-sfi, cfi, cfi, sfi);\t\n}\n\nvec4 compute_spiral (vec2 uv, float iTime) {\n\tfloat fi = length (uv) * 50.0;\n\tfloat g = atan (uv.y, uv.x);\n\tuv *= rotate (iTime*7.0);\n\tuv *= sin (g*15.0);\n\tuv *= rotate (fi);\n\t\n\t\n\treturn mix (vec4 (1.0), vec4 (0.0), min (\n\t\tstep (0.0, uv.x), \n\t\thill (0.0, fi/25.0, uv.y)));\n}\n\t\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat fact =  1.0/min (iResolution.x, iResolution.y);\n\tvec2 uv = (2.0*fragCoord.xy - iResolution.xy) * fact;\n\t\n\t#ifdef MSAA\n\tvec4 ac = vec4 (0.0);\n\tfor (float y = 0.0; y < MSAA; ++y) {\n\t\tfor (float x = 0.0; x < MSAA; ++x) {\t\t\t\n\t\t\tvec2 c =  vec2 (\n\t\t\t\t(x-MSAA/2.0)*fact/MSAA,\n\t\t\t\t(y-MSAA/2.0)*fact/MSAA);\n\t\t\tac += compute_spiral (uv + c, iTime) / (MSAA*MSAA);\n\t\t}\n\t}\t\n\tfragColor = ac;\n\t#else \n\tfragColor = compute_spiral (uv*1.0, iTime);\t\t\n\t#endif\n\t\n\t\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsfXRj.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[45, 45, 85, 85, 144], [146, 146, 170, 170, 256], [258, 258, 302, 302, 533], [537, 537, 594, 594, 1049]]}
{"id": "MsfXW7", "name": "Terrain Marcher", "author": "faturan", "description": "Terrain marcher made for a computer graphics course. Click and hold to move light source.", "tags": ["raymarcher"], "likes": 0, "viewed": 157, "date": "1402173031", "time_retrieved": "2024-06-20T18:11:39.155816", "image_code": "// Raymarching steps\n#define STEP 0.05\n#define TMIN 1.0\n#define TMAX 4.5\n// Partial derivative step\n#define DSTEP 0.01\n\n// Colors\n#define DIFFUSE vec4(1,0,0,1)\n#define SPECULAR vec4(1,1,1,1)\n#define AMBIENT vec4(0.2,0.2,0.2,1)\n#define LIGHT vec4(0.9,0.8,0,1)\n#define SHINE 100.0\n\n// Fbm parameters\n#define OCTAVES 6\n#define GAIN 0.5\n#define LACUNARITY 2.0\n\nprecision highp float;\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\n// GLSL textureless classic 2D noise \"cnoise\",\n// with an RSL-style periodic variant \"pnoise\".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n// Copyright (C) 2011 by Ashima Arts (Simplex noise)\n// Copyright (C) 2011 by Stefan Gustavson (Classic noise)\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec2 fade(vec2 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec2 P)\n{\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod289(Pi); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute(permute(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n  vec4 gy = abs(gx) - 0.5 ;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;  \n  g01 *= norm.y;  \n  g10 *= norm.z;  \n  g11 *= norm.w;  \n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\n// Fractal Brownian Motion\nfloat fbm(vec2 P)\n{\n  float total = 0.0;\n  float frequency = 1.0;\n  float amplitude = GAIN;\n\n  for (int i = 0; i < OCTAVES; i++)\n  {\n    float noise = cnoise( P * frequency );\n    total += (noise + 1.0) / 2.0 * amplitude;         \n    frequency *= LACUNARITY;\n    amplitude *= GAIN;\n  }\n\n  return total;\n}\n\nfloat map(vec2 P)\n{\n  return fbm(P + iTime/5.0);\n}\n/////////////////////////////////////////////////////////////////////\n\n// Ray marching\nfloat intersect(Ray r)\n{\n  float lastError = 0.0;\n\n  for (float t = TMIN; t < TMAX; t += STEP)\n  {\n    vec3 p = r.origin + t*r.direction;\n    float h = map(p.xy);\n    float error = p.z - h;\n    \n    if( error < 0.0 ) // Hit\n    {\n      float alpha = error/(lastError - error);\n      return t + alpha*STEP;\n    }\n    else\n    {\n      lastError = error;\n    }\n  }\n  return 0.0;\n}\n\nvec3 calcNorm(vec2 P)\n{\n  vec2 dx = vec2(DSTEP/2.0,0);\n  vec2 dy = vec2(0,DSTEP/2.0);\n  float partialx = (map(P + dx) - map(P - dx))/DSTEP;\n  float partialy = (map(P + dy) - map(P - dy))/DSTEP;\n  return normalize(vec3(-partialx, -partialy, 1));\n}\n\nvec4 shade(vec2 P, vec3 dir, vec3 light)\n{\n  vec3 l = normalize(light - vec3(P, map(P)));\n  vec3 n = calcNorm(P);\n  float nl = max(0.0, dot(n,l));\n\n  vec3 h = normalize(-dir + l);\n  float nh = max(0.0, pow(dot(n,h), SHINE));\n\n  return DIFFUSE*AMBIENT + LIGHT*(DIFFUSE*nl + SPECULAR*nh);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 pos = fragCoord.xy/iResolution.xy;\n  vec3 u = normalize(vec3(0, 1, -1));\n  vec3 v = vec3(1,0,0);\n  vec3 w = normalize(vec3(0,1,1));\n  vec3 camera = -2.0*u;\n  vec3 dir = u + 0.7*(pos.x*v + pos.y*w);\n  Ray r = Ray(camera, dir);\n  vec3 light = vec3((4.0*iMouse.xy/iResolution.xy) - vec2(1,1),1);\n  float t = intersect(r);\n\n  if(t == 0.0)\n  {\n    fragColor = vec4(0,0,0,1);\n  }\n  else\n  {\n    fragColor = shade((r.origin + r.direction*t).xy, r.direction, light);\n  }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsfXW7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[435, 2063, 2084, 2084, 2133], [2135, 2135, 2157, 2157, 2194], [2196, 2196, 2224, 2224, 2276], [2278, 2278, 2297, 2297, 2337], [2339, 2363, 2385, 2385, 3427], [3429, 3456, 3475, 3475, 3761], [3763, 3763, 3782, 3782, 3813], [3885, 3901, 3925, 3925, 4278], [4280, 4280, 4303, 4303, 4526], [4528, 4528, 4570, 4570, 4816], [4818, 4818, 4875, 4875, 5347]]}
{"id": "MslSDN", "name": "Morphing", "author": "iapafoto", "description": "[Mouse available]\n3D morphing between 2 distance fields is just a \"mix\" between the distances of the 2 scenes  :) (possible to extend it to colors of course).", "tags": ["distancefield", "bezier", "hsv", "teapot", "morphing"], "likes": 86, "viewed": 8117, "date": "1401636158", "time_retrieved": "2024-06-20T18:11:40.046900", "image_code": "// Created by Sebastien Durand - 2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define U(a,b) (a.x*b.y-b.x*a.y)\n\nvec2 A[15];\nvec2 T1[5];\nvec2 T2[5];\n\nconst vec3 L = normalize(vec3(1,.72, 1)), Y = vec3(0,1,0), E = Y*.01;\n\nfloat tMorph;\nmat2 mat2Rot;\n\n// Distance to Bezier\n// inspired by [iq:https://www.shadertoy.com/view/ldj3Wh]\n// calculate distance to 2D bezier curve on xy but without forgeting the z component of p\n// total distance is corrected using pytagore just before return\nvec2 B(vec2 m, vec2 n, vec2 o, vec3 p) {\n\tvec2 q = p.xy;\n\tm-= q; n-= q; o-= q;\n\tfloat x = U(m, o), y = 2. * U(n, m), z = 2. * U(o, n);\n\tvec2 i = o - m, j = o - n, k = n - m, \n\t\t s = 2. * (x * i + y * j + z * k), \n\t\t r = m + (y * z - x * x) * vec2(s.y, -s.x) / dot(s, s);\n\tfloat t = clamp((U(r, i) + 2. * U(k, r)) / (x + x + y + z), 0.,1.); // parametric position on curve\n\tr = m + t * (k + k + t * (j - k)); // distance on 2D xy space\n\treturn vec2(sqrt(dot(r, r) + p.z * p.z), t); // distance on 3D space\n}\n\n\nfloat smin(float a, float b, float k){\n    float h = clamp(.5+.5*(b-a)/k, 0., 1.);\n    return mix(b,a,h)-k*h*(1.-h);\n}\n\n// Distance to scene\nfloat M(vec3 p) {\n\n// Distance to Teapot --------------------------------------------------- \n\t// precalcul first part of teapot spout\n\tvec2 h = B(T1[2],T1[3],T1[4], p);\n\tfloat a = 99., \n    // distance to teapot handle (-.06 => make the thickness) \n\t\tb = min(min(B(T2[0],T2[1],T2[2], p).x, B(T2[2],T2[3],T2[4], p).x) - .06, \n    // max p.y-.9 => cut the end of the spout \n                max(p.y - .9,\n    // distance to second part of teapot spout (abs(dist,r1)-dr) => enable to make the spout hole \n                    min(abs(B(T1[0],T1[1],T1[2], p).x - .07) - .01, \n    // distance to first part of teapot spout (tickness incrase with pos on curve) \n                        h.x * (1. - .75 * h.y) - .08)));\n\t\n    // distance to teapot body => use rotation symetry to simplify calculation to a distance to 2D bezier curve\n    vec3 qq= vec3(sqrt(dot(p,p)-p.y*p.y), p.y, 0);\n    // the substraction of .015 enable to generate a small thickness arround bezier to help convergance\n    // the .8 factor help convergance  \n\tfor(int i=0;i<13;i+=2) \n\t\ta = min(a, (B(A[i], A[i + 1], A[i + 2], qq).x - .015) * .7); \n    // smooth minimum to improve quality at junction of handle and spout to the body\n\tfloat dTeapot = smin(a,b,.02);\n\n// Distance to other shapes ---------------------------------------------\n\tfloat dShape;\n\tint idMorph = int(mod(floor(.5+(iTime)/(2.*3.141592658)),3.));\n\t\n\tif (idMorph == 1) {\n\t\tp.xz *= mat2Rot;\n   \t \tvec3 d = abs(p-vec3(.0,.5,0)) - vec3(.8,.7,.8);\n   \t\tdShape = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n\t} else if (idMorph == 2) { \n\t\tp -= vec3(0,.55,0);\n\t\tvec3 d1 = abs(p) - vec3(.67,.67,.67*1.618),\n\t\t     d3 = abs(p) - vec3(.67*1.618,.67,.67);\n   \t\tdShape = min(max(d1.x,max(d1.y,d1.z)),0.) + length(max(d1,0.));\n   \t\tdShape = min(dShape,min(max(d3.x,max(d3.y,d3.z)),0.) + length(max(d3,0.)));\n\t} else {\n\t\tdShape = length(p-vec3(0,.45,0))-1.1;\n\t}\n\t\n\t// !!! The morphing is here !!!\n    return mix(dTeapot, dShape, abs(tMorph));\n}\n\n// HSV to RGB conversion \n// [iq: https://www.shadertoy.com/view/MsS3Wc]\nvec3 hsv2rgb_smooth(float x, float y, float z) {\n    vec3 rgb = clamp( abs(mod(x*6.+vec3(0.,4.,2.),6.)-3.)-1., 0., 1.);\n\trgb = rgb*rgb*(3.-2.*rgb); // cubic smoothing\t\n\treturn z * mix( vec3(1), rgb, y);\n}\n\nvec3 normal(in vec3 p, in vec3 ray, in float t) {\n\tfloat pitch = .4 * t / iResolution.x;\n    vec2 d = vec2(-1,1) * pitch;\n\tvec3 p0 = p+d.xxx, p1 = p+d.xyy, p2 = p+d.yxy, p3 = p+d.yyx; // tetrahedral offsets\n\tfloat f0 = M(p0), f1 = M(p1), f2 = M(p2), f3 = M(p3);\n\tvec3 grad = p0*f0+p1*f1+p2*f2+p3*f3 - p*(f0+f1+f2+f3);\n\t// prevent normals pointing away from camera (caused by precision errors)\n\treturn normalize(grad - max(.0,dot (grad,ray ))*ray);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat aa=3.14159/4.;\n\tmat2Rot = mat2(cos(aa),sin(aa),-sin(aa),cos(aa));\n\t\n\t// Morphing step\n\ttMorph = cos(iTime*.5);\n\ttMorph*=tMorph*tMorph*tMorph*tMorph;\n\t\n\t// Teapot body profil (8 quadratic curves) \n\tA[0]=vec2(0,0);A[1]=vec2(.64,0);A[2]=vec2(.64,.03);A[3]=vec2(.8,.12);A[4]=vec2(.8,.3);A[5]=vec2(.8,.48);A[6]=vec2(.64,.9);A[7]=vec2(.6,.93);\n    A[8]=vec2(.56,.9);A[9]=vec2(.56,.96);A[10]=vec2(.12,1.02);A[11]=vec2(0,1.05);A[12]=vec2(.16,1.14);A[13]=vec2(.2,1.2);A[14]=vec2(0,1.2);\n\t// Teapot spout (2 quadratic curves)\n\tT1[0]=vec2(1.16, .96);T1[1]=vec2(1.04, .9);T1[2]=vec2(1,.72);T1[3]=vec2(.92, .48);T1[4]=vec2(.72, .42);\n\t// Teapot handle (2 quadratic curves)\n\tT2[0]=vec2(-.6, .78);T2[1]=vec2(-1.16, .84);T2[2]=vec2(-1.16,.63);T2[3]=vec2(-1.2, .42);;T2[4]=vec2(-.72, .24);\n\n\t// Configure camera\n\tvec2 r = iResolution.xy, m = iMouse.xy / r,\n\t     q = fragCoord.xy/r.xy, p =q+q-1.;\n\tp.x *= r.x/r.y;\n\tfloat j=.0, s=1., h = .1, t=5.+.2*iTime + 4.*m.x;\n\tvec3 o = 2.9*vec3(cos(t), .7- m.y,sin(t)),\n\t     w = normalize(Y * .4 - o), u = normalize(cross(w, Y)), v = cross(u, w),\n         d = normalize(p.x * u + p.y * v + w+w), n, x;\n\t\t\t\n\t// Ray marching\n\tt=0.;\n    for(int i=0;i<48;i++) { \n\t\tif (h<.0001 || t>4.7) break;\n        t += h = M(o + d*t);\n    }\n    \n\t// Background colour change as teapot complementaries colours (using HSV)\n\tvec3 c = mix(hsv2rgb_smooth( .5+iTime*.02,.35,.4), \n\t\t\t \t hsv2rgb_smooth(-.5+iTime*.02,.35,.7), q.y);\n\t\t\n    // Calculate color on point\n\tif (h < .001) {\n\t\tx = o + t * d;\n\t\tn = normal(x,d,t);//normalize(vec3(M(x+E.yxx)-M(x-E.yxx),M(x+E)-M(x-E),M(x+E.xxy)-M(x-E.xxy)));\n\t\t// Calculate Shadows\n\t\tfor(int i=0;i<20;i++){\n\t\t\tj += .02;\n\t\t\ts = min(s, M(x+L*j)/j);\n\t\t}\n\t\t// Teapot color rotation in HSV color space\n\t\tvec3 c1 = hsv2rgb_smooth(.9+iTime*.02, 1.,1.); \n\t\t// Shading\n\t    c = mix(c,mix(sqrt((clamp(3.*s,0.,1.)+.3)*c1),\n\t\t\t          vec3(pow(max(dot(reflect(L,n),d),0.),99.)),.4),2.*dot(n,-d));\n\t} \n\n\tc *= pow(16.*q.x*q.y*(1.-q.x)*(1.-q.y), .16); // Vigneting\n\tfragColor=vec4(c,1);\t\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MslSDN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[297, 532, 572, 572, 1038], [1041, 1041, 1079, 1079, 1159], [1161, 1182, 1199, 1316, 3154], [3156, 3229, 3277, 3277, 3433], [3435, 3435, 3484, 3484, 3884], [3887, 3887, 3944, 3944, 5969]]}
{"id": "MslSRS", "name": "winder", "author": "bigblueboo", "description": "woah.  spirals", "tags": ["2d", "spiral", "moire", "oscillating", "looping"], "likes": 4, "viewed": 181, "date": "1403478028", "time_retrieved": "2024-06-20T18:11:40.046900", "image_code": "float PI = 3.1415926;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\tvec2 coord = uv - vec2(.5,.5);\n\tcoord.y *= iResolution.y / iResolution.x;\n\tfloat angle = atan(coord.y, coord.x);\n\tfloat dist = length(coord);\n\t\n\tfloat brightness = .5 + .5 * \n\t\tsin(96.0*angle + \n\t\t\tsin(iTime*PI*1.0)*PI*196.0*dist / .707);\n\tvec4 color = vec4( brightness, brightness, brightness, 1.0);\n\tfragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MslSRS.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[23, 23, 80, 80, 448]]}
{"id": "MslSzS", "name": "3dNoise", "author": "bytewave", "description": "\n", "tags": ["3dnoise"], "likes": 5, "viewed": 414, "date": "1403537074", "time_retrieved": "2024-06-20T18:11:40.046900", "image_code": "float rand3d(vec3 co,float seed)\n{\n\treturn sin(fract((sin(dot(co ,vec3(30.233 * seed,7.233 * seed,20.2352 * seed)))) * 815150.5453)*321.321);\n}\n\nfloat Noise3d(vec3 pos,float Size,float seed)\n{\t    \n\tfloat GridX = floor(pos.x * Size);\n\tfloat NextGridX = floor( (pos.x  +(1./Size)) * Size);\n\tfloat GridY = floor(pos.y * Size);\n\tfloat NextGridY = floor( (pos.y  +(1./Size)) * Size);\n\tfloat GridZ = floor(pos.z * Size);\n\tfloat NextGridZ = floor( (pos.z  +(1./Size)) * Size);\t\n\tvec3 PosGrid = mod((pos),1./Size) * Size ;\n\t\n    PosGrid = smoothstep(0.,1.,PosGrid);\n    \n\t//FrontFace\n\tfloat CornerUpLeftFrontRandom = rand3d(vec3(GridX,GridY,GridZ),1.);\n\tfloat CornerUpRightFrontRandom = rand3d(vec3(NextGridX,GridY,GridZ),1.);\n\tfloat CornerDownLeftFrontRandom = rand3d(vec3(GridX,NextGridY,GridZ),1.);\n\tfloat CornerDownRightFrontRandom = rand3d(vec3(NextGridX,NextGridY,GridZ),1.);\n\tfloat MixUp_Front = mix(CornerUpLeftFrontRandom,CornerUpRightFrontRandom,PosGrid.x);\n\tfloat MixDown_Front = mix(CornerDownLeftFrontRandom,CornerDownRightFrontRandom,PosGrid.x);\t\t\n\t//BackFace\n\tfloat CornerUpLeftBackRandom = rand3d(vec3(GridX,GridY,NextGridZ),1.);\n\tfloat CornerUpRightBackRandom = rand3d(vec3(NextGridX,GridY,NextGridZ),1.);\n\tfloat CornerDownLeftBackRandom = rand3d(vec3(GridX,NextGridY,NextGridZ),1.);\n\tfloat CornerDownRightBackRandom = rand3d(vec3(NextGridX,NextGridY,NextGridZ),1.);\n\tfloat MixUp_Back = mix(CornerUpLeftBackRandom,CornerUpRightBackRandom,PosGrid.x);\n\tfloat MixDown_Back = mix(CornerDownLeftBackRandom,CornerDownRightBackRandom,PosGrid.x);\t\n\t//FrontFace\n\tfloat MixFrontFace = mix(MixUp_Front,MixDown_Front,PosGrid.y);\n\t//BackFace\n\tfloat MixBackFace = mix(MixUp_Back,MixDown_Back,PosGrid.y);\t\n\t//MixCube\n\tfloat MixCube = mix(MixFrontFace,MixBackFace,PosGrid.z);\t\n\treturn MixCube;\n}\n\nfloat perlinNoise3d(vec3 pos,float Size,float seed,float Iteration)\n{\n    float r =0.;\n\tfor(float i = 0.;i < Iteration;i++)\n    {\n        float freq = pow(2.,i);\n        r += Noise3d(pos,Size*freq,seed )*(1./freq);\n    }\n\treturn r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat Speed = 0.05;\n\t\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    \n    vec3 pos =vec3(uv.xy ,1.);\n    pos += (perlinNoise3d(pos + iTime*0.02,5.,1.,21. )*0.5+0.5)*0.1;\n        \n    float size = 10.;\n    float seed = 1.;\n    float iteration = 21.;\n    \n    \n    float r = perlinNoise3d(pos+ iTime*0.02,size,seed,iteration )*0.25+0.5;\n    \n\tfragColor = vec4(r,r,r,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MslSzS.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 34, 34, 143], [145, 145, 192, 192, 1789], [1791, 1791, 1860, 1860, 2024], [2026, 2026, 2083, 2083, 2468]]}
{"id": "MssSDM", "name": "Sound experiment", "author": "Nrx", "description": "Rework of https://www.shadertoy.com/view/MdsXWM", "tags": ["sound"], "likes": 5, "viewed": 400, "date": "1402650846", "time_retrieved": "2024-06-20T18:11:40.046900", "image_code": "// From https://www.shadertoy.com/view/MdsXWM\n\nconst float samples = 6.0;\n\nvec3 hsv2rgb (in vec3 hsv) {\n\thsv.yz = clamp (hsv.yz, 0.0, 1.0);\n\treturn hsv.z * (1.0 + 0.5 * hsv.y * (cos (2.0 * 3.14159 * (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0))) - 1.0));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 p = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\tp.x += 0.05 * cos (iTime + p.y * 20.0);\n\tvec3 color = vec3(0.0, 0.0, 0.2);\n\tfloat r = texture (iChannel0, vec2 (0.0)).x * 0.4;\n\tfor(float d = 0.0; d < 1.0; d += 1.0 / samples) {\n\t\tvec3 c = hsv2rgb (vec3 (d + iTime, 1.0, 1.0));\n\t\tfloat v = texture (iChannel0, vec2 (d, 0.0)).x * 0.7;\n\t\tfloat a = 2.0 * 3.14159 * d + iTime;\n\t\tvec2 o = r * vec2 (cos (a), sin (a));\n\t\tcolor += c * v / length (p - o);\n\t}\n\tcolor /= samples;\n\tcolor = mix (vec3 (length (color)), color, smoothstep (r + 0.02, r + 0.05, length (p)));\n\tfragColor = vec4 (pow (color, vec3 (0.6 + r)), 1.0);\n}", "image_inputs": [{"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MssSDM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 75, 103, 103, 253], [255, 255, 311, 311, 942]]}
{"id": "MssSRS", "name": "Noise animation - Watery", "author": "nimitz", "description": "Playing with different ways of animating noise. In this version every point in the domain is rotated by random (fbm) value.", "tags": ["procedural", "2d", "noise"], "likes": 125, "viewed": 3895, "date": "1403492597", "time_retrieved": "2024-06-20T18:11:40.440829", "image_code": "// Noise animation - Watery by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/MssSRS\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n//The domain is rotated by the values of a preliminary fbm call\n//then the fbm function is called again to color the screen.\n//Turbulent fbm (aka ridged) is used for better effect.\n//define centered to see the rotation better.\n\n//#define CENTERED\n\n#define time iTime*0.2\n\nmat2 makem2(in float theta){float c = cos(theta);float s = sin(theta);return mat2(c,-s,s,c);}\nfloat noise( in vec2 x ){return texture(iChannel0, x*.01).x;}\n\nmat2 m2 = mat2( 0.80,  0.60, -0.60,  0.80 );\nfloat fbm( in vec2 p )\n{\t\n\tfloat z=2.;\n\tfloat rz = 0.;\n\tfor (float i= 1.;i < 7.;i++ )\n\t{\n\t\trz+= abs((noise(p)-0.5)*2.)/z;\n\t\tz = z*2.;\n\t\tp = p*2.;\n\t\tp*= m2;\n\t}\n\treturn rz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy*2.-1.;\n\tp.x *= iResolution.x/iResolution.y;\n\tvec2 bp = p;\n\t#ifndef CENTERED\n\tp += 5.;\n\tp *= 0.6;\n\t#endif\n\tfloat rb = fbm(p*.5+time*.17)*.1;\n\trb = sqrt(rb);\n\t#ifndef CENTERED\n\tp *= makem2(rb*.2+atan(p.y,p.x)*1.);\n\t#else\n\tp *= makem2(rb*.2+atan(p.y,p.x)*2.);\n\t#endif\n\t\n\t//coloring\n\tfloat rz = fbm(p*.9-time*.7);\n\trz *= dot(bp*5.,bp)+.5;\n\trz *= sin(p.x*.5+time*4.)*1.5;\n\tvec3 col = vec3(.04,0.07,0.45)/(.1-rz);\n\tfragColor = vec4(sqrt(abs(col)),1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MssSRS.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[465, 509, 537, 537, 602], [603, 603, 628, 628, 664], [711, 711, 735, 735, 883], [885, 885, 942, 942, 1431]]}
{"id": "MssXWM", "name": "Raymarch Tut Thingy", "author": "squeakyneb", "description": "simple newbie stuff that hopefully explains some shit in terms of actually implementing sphere-tracing/ray-marching\n\nupdated 2019 - after five years of mediocre raymarching code 😁", "tags": ["raymarching", "example", "simple", "raymarched", "tutorial", "sample"], "likes": 12, "viewed": 426, "date": "1402632982", "time_retrieved": "2024-06-20T18:11:41.119702", "image_code": "const float EPS = 0.001; // this defines \"close enough\", because raymarching doesn't actually hit\nconst int MAXI = 400;\t // how much work we are willing to do (speed vs. accuracy)\nconst float MAXD = 30.; // if we are this far away from everything, we are lost in the skies of eternity\n\n// OK NOW YOU SHOULD GO SCROLL DOWN TO MAIN AND FOLLOW THE FUNCTION CALLS FROM THERE OK\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nvec3 hsv(float h,float s,float v) { // this is just a hue/saturation/luminance to RGB conversion\n\treturn mix(vec3(1.),clamp((abs(fract(h+vec3(3.,2.,1.)/3.)*6.-3.)-1.),0.,1.),s)*v;\n}\n\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nfloat scenedist(vec3 p){ // this defines what is actually in the scene\n\tfloat s1 = length(p)-1.; \t\t\t\t// this is just a sphere\n\tfloat s2 = length(p-vec3(.8, 0., 0.))-.5;\n\treturn min(s1,s2); // add them together (like boolean OR)\n    // min combines them because it will return the distance to the closest, the other is irrelevant right?\n\t// other fun mixes are max(s1,s2) (boolean AND) and max(s1,-s2) (volume subtraction)\n}\n\nvec3 getNormal(vec3 pos){ // this gets the normal\n\t/* So we're gonna check the distance field at little steps in each direction\n\t\tthe subtractions will give us the gradient in each direction\n\t\tso if distance goes up in a direction we get positive that way\n*/\n\tvec2 eps = vec2(0.0, EPS);\n\treturn normalize(vec3( // always normalise directions godammit\n\t\t\tscenedist(pos + eps.yxx) - scenedist(pos - eps.yxx),\n\t\t\tscenedist(pos + eps.xyx) - scenedist(pos - eps.xyx),\n\t\t\tscenedist(pos + eps.xxy) - scenedist(pos - eps.xxy)));\n}\n\nvec3 renderworld(vec2 uv){ // this is where we do everything\n\t\n\t// put the camera somewhere\n\t// sin and cos are useful for making circles, so we spin around\n\tvec3 camPos = normalize(vec3(2.*sin(iTime),2.*cos(iTime),1. + sin(iTime*.33)))*3.;\n\t// what to look at (the center for now)\n\tvec3 camTarg = vec3(0.);\n\t// which way is up? I like Z. This is world-relative for now.\n\tvec3 camUp = normalize(vec3(0.,0.,1.));\n\t\n\t// camera points to target from camera\n\t// remember that all directions must be normalised, or shit goes craycray\n\tvec3 camDir = normalize(camTarg - camPos);\n\t// right is perpendicular to up and forwards\n\tvec3 camRight = normalize(cross(camUp,camDir));\n\t// change UP to be relative to camera\n\tcamUp = normalize(cross(camDir,camRight));\n\t\n\t// This pixel will cast ray in the camera direction, but a bit up/down and sidewise\n\tvec3 rayDir = normalize(camDir+uv.x*camRight+uv.y*camUp);\n\t\n\t// the first distance we will jump - randomised slightly to reduce some banding effects\n\tfloat dist = scenedist(camPos) * rand(rayDir.xy);\n\t// must maintain the total or we will not know where we hit when we do\n\tfloat total = dist;\n\t\n\t// now we march along the ray a lot\n    int i;\n\tfor(i = 0;i<MAXI;i++){\n\t\tdist = scenedist(camPos+rayDir*total); // distance to closest thing (safe jump distance)\n\t\ttotal += dist;\t\t\t\t\t\t   // add it to our progress\n\t\tif(dist<EPS || dist>MAXD){break;}   // quit if we hit something or are lost\n\t}\n\tvec3 dest = camPos+rayDir*total; // this is where we ended up\n\tvec3 c;\t\t\t\t\t\t\t // this will be our pixel colour\n\tif(dist<EPS){\t\t\t\t\t // if we score a hit\n        // \"free\" ambient occlusion based on iteration count\n        float ao = 1.-float(i)/(float(MAXI)*.3);\n\t\tc = .5+.5*getNormal(dest);\n        c *= ao;\n\t}else{\t\t\t\t\t\t\t // no hit, we are lost in the sky\n\t\tc = hsv(.55,smoothstep(-1.5,1.,uv.y),1.); // make teh pretty blue skies\n\t}\n\t\t\n\treturn c; // give the colour back\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) // IS LIKE C(++), you start with the main\n{\n\t// uv is our screen position\n\t// remember this all runs per-pixel, so so this is how we know which we are!\n\tvec2 uv = (fragCoord.xy / iResolution.xy - 0.5) // -.5 to centre it (is now in range [-.5,.5])\n\t\t* vec2(2.0,2.0/(iResolution.x/iResolution.y)); //*2 to normalise x to [-1,1]\n\t\t\t\t\t\t\t\t\t\t\t//y adjusts aspect (typical widescreen is >1 in both directions\n\t\n\t// step 1: figure out where you are\n\t// step 2: do everything else\n\tvec3 c = renderworld(uv);\n\t\n\tfragColor = vec4(c,1.0);// make this pixel pretty colours\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MssXWM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[286, 375, 395, 395, 462], [464, 464, 499, 560, 645], [648, 648, 716, 716, 759], [762, 762, 786, 832, 1185], [1187, 1187, 1212, 1445, 1709], [1711, 1711, 1737, 1867, 3614], [3616, 3616, 3715, 3823, 4233]]}
{"id": "XdfXzS", "name": "[BRCompo #1] The Mine", "author": "vgs", "description": "An old, abandoned mine.\nThis is my entry for the first BRCompo by Danguafer.", "tags": ["3d", "mine", "shaft", "cart", "minecart"], "likes": 20, "viewed": 779, "date": "1403109628", "time_retrieved": "2024-06-20T18:11:42.010736", "image_code": "// created by Vinicius Graciano Santos - vgs/2014\n// http://viniciusgraciano.com/blog/making-of-the-mine/\n\n// increase/decrease the STEPS value if you have a fast/slow gpu\n#define STEPS 100\n#define EPS 0.01\n\n// uncomment to enable bump mapping (crashes on ANGLE-based browsers)\n//#define BUMP 5.0\n\n// iq's 3D noise function: https://www.shadertoy.com/view/4sfGzS.\nfloat hash(float n ) { return fract(sin(n)*43758.5453123); }\nfloat noise(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nfloat fbm(vec3 p) {\n\tfloat k = 0.0;\n\t\t\n\tk += 1.000*noise(p); p*=2.0;\n\tk += 0.500*noise(p); p*=2.0;\n\tk += 0.250*noise(p);\n\treturn k/1.75;\n}\n\nvec2 track(float z) {\n\t// play with these constants for some fun!\n\tfloat x = cos(0.2*z);\n\tfloat y = -cos(0.2*z) - 0.1*sin(0.8*z - 2.0);\n\treturn vec2(x, y);\n}\n\nfloat cave(vec3 p) {\n\tconst float k = 4.0;\n\treturn 1.6-pow(pow(abs(p.x), k) + pow(abs(p.y), k), 1.0/k);\n}\n\nfloat box(vec2 p, vec2 b, float r) {\n\treturn length(max(abs(p)-b, 0.0)) - r;\n}\n\nfloat box(vec3 p, vec3 b, float r) {\n\treturn length(max(abs(p)-b, 0.0)) - r;\n}\n\nfloat support(vec3 p) {\n\tconst vec4 c = vec4(0.15, 0.2, 2.0, 1.2);\n\tvec3 q = vec3(abs(p.x) - c.z, p.y - c.z, mod(p.z, 6.0) - 3.0);\n\tfloat d = box(q.xz, c.xx, 0.05);\n\td = min(d, box(q.yz, c.yx, 0.05)); \n\tq.x += q.y + c.w;\n\treturn min(d, box(q.xz, c.xx, 0.05));\n}\n\nfloat plank(vec3 p) {\n\tvec3 q = vec3(p.x, p.y + 1.9, mod(p.z, 2.0) - 1.0);\n\treturn box(q, vec3(1.5, 0.05, 0.2), 0.01);\n}\n\nfloat rails(vec3 p) {\n\tvec2 q = vec2(abs(p.x)-1.0, p.y + 1.7);\n\tfloat d = box(q, vec2(0.1), 0.01); q.x += 0.2;\n\treturn max(d, 0.11 - length(q));\n}\n\nvec2 dist_field(vec3 p) {\n\tp.xy += track(p.z);\n\tvec2 res = vec2(cave(p) + fbm(p), 0.0);\n\t\n\tfloat d = support(p);\n\tif (d < res.x) res = vec2(d, 1.0);\n\td = plank(p);\n\tif (d < res.x) res = vec2(d, 1.0);\n\td = rails(p);\n\tif (d < res.x) res = vec2(d, 2.0);\n\treturn res;\n}\n\nvec3 normal(vec3 p) {\n\tvec2 q = vec2(0.01, 0.0);\n\treturn normalize(vec3(dist_field(p+q.xyy).x - dist_field(p-q.xyy).x,\n\t\t\t\t\t\t  dist_field(p+q.yxy).x - dist_field(p-q.yxy).x,\n\t\t\t\t\t\t  dist_field(p+q.yyx).x - dist_field(p-q.yyx).x));\n}\n\nvec3 cubeMap(sampler2D samp, vec3 q, vec3 n) {\n\tvec3 x = texture(samp, q.zy).rgb;\n\tvec3 y = texture(samp, q.zx).rgb;\n\tvec3 z = texture(samp, q.xy).rgb;\n\treturn abs(n.x)*x + abs(n.y)*y + abs(n.z)*z;\n}\n\n#ifdef BUMP\nvec3 normalMap(sampler2D samp, vec2 q) {\n\tvec2 p = vec2(0.01, 0.0);\n\tvec3 a = BUMP*(texture(samp, q+p.xy).rgb - texture(samp, q-p.xy).rgb);\n\tvec3 b = BUMP*(texture(samp, q+p.yx).rgb - texture(samp, q-p.yx).rgb);\n\treturn normalize(cross(vec3(1.0, 0.0,  (a.x+a.y+a.z)/3.0),\n\t\t   \t               vec3(0.0, 1.0, (b.x+b.y+b.z)/3.0)));\n}\n\nvec3 cubeNormalMap(sampler2D samp, vec3 q, vec3 n) {\n\tvec3 x = normalMap(samp, q.zy);\n\tvec3 y = normalMap(samp, q.zx);\n\tvec3 z = normalMap(samp, q.xy);\n\treturn abs(n.x)*x + abs(n.y)*y + abs(n.z)*z;\n}\n#endif\n\nvec3 shade(in vec3 ro, in vec3 rd, float t, float id) {\n\tvec3 key_l = -rd;\n\tvec3 key_c = vec3(243.0, 141.0, 21.0)/25.5;\n\t\n\tvec3 fill_l = vec3(0.0, 0.0, -1.0);\n\tvec3 fill_c = 0.2*key_c;\n\t\n\tvec3 q = ro + t*rd;\n\tvec3 n = normal(q);\n\n\tvec3 mat = vec3(1.0); float shin = 0.0;\n\tif (id == 0.0) {\n\t\tshin = 25.0;\n\t\tmat = mix(cubeMap(iChannel0, q, n), cubeMap(iChannel1, q, n), noise(q));\n\t} else if (id == 1.0) {\n\t\tshin = 50.0;\n\t\tmat = cubeMap(iChannel2, q, n);\n\t\t#ifdef BUMP\n\t\tn = normalize(n + cubeNormalMap(iChannel2, q, n));\n\t\t#endif\n\t} else {\n\t\tshin = 75.0;\n\t\tmat = cubeMap(iChannel3, q, n);\n\t\t#ifdef BUMP\n\t\tn = normalize(n + cubeNormalMap(iChannel3, q, n));\n\t\t#endif\n\t}\n\tmat = pow(abs(mat), vec3(2.2));\n\tvec3 col = vec3(0.0);\n\t\n\t// key light.\n\tfloat lamb = max(0.0, dot(n, key_l));\n\tfloat spec = lamb > 0.0 ? pow(max(0.0, dot(n, normalize(key_l-rd))), shin) : 0.0;\n\tcol += key_c*mat*(0.6*lamb + 0.4*spec)*pow(max(-dot(-rd,normalize(q)), 0.0), 10.0)/(0.1*t*t);\n\t\n\t// fill light.\n\tlamb = max(0.0, dot(n, fill_l));\n\tspec = lamb > 0.0 ? pow(max(0.0, dot(n, normalize(fill_l-rd))), shin) : 0.0;\n\tcol += fill_c*mat*(0.6*lamb + 0.4*spec)/(0.4*t*t);\n\t\n\tcol = mix(vec3(0.05), col, exp(-0.05*t));\n\treturn col/(col+1.0);\n\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n\t\n\tvec3 ro = vec3(0.0, 0.0, -5.0*iTime-10.0);\n\tro.xy -= track(ro.z);\n\tvec3 rd = normalize(vec3(uv, -1.0));\n\t\n\tfloat t = 0.0; vec2 res = vec2(3.0);\n\tfor (int i = 0; i < STEPS; ++i) {\n\t\tif (res.x < EPS || t > 32.0) continue;\n\t\tres = dist_field(ro + t*rd); t += 0.7*res.x;\n\t}\n\t\n\tvec3 col = shade(ro, rd, t, res.y);\n\tcol = pow(abs(col), vec3(1.0/2.2));\n\tcol = smoothstep(0.0, 1.0, col);\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "XsXGRn", "previewfilepath": "/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture"}, {"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdfXzS.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[298, 364, 386, 386, 424], [425, 425, 446, 446, 815], [817, 817, 836, 836, 955], [957, 957, 978, 1022, 1114], [1116, 1116, 1136, 1136, 1221], [1223, 1223, 1259, 1259, 1301], [1303, 1303, 1339, 1339, 1381], [1383, 1383, 1406, 1406, 1644], [1646, 1646, 1667, 1667, 1766], [1768, 1768, 1789, 1789, 1914], [1916, 1916, 1941, 1941, 2181], [2183, 2183, 2204, 2204, 2415], [2417, 2417, 2463, 2463, 2616], [3171, 3171, 3226, 3226, 4381], [4383, 4383, 4440, 4440, 4945]]}
{"id": "XdlSRj", "name": "Burning desire", "author": "rakesh111989", "description": "Made it when playing with my favourite shaders made by IQ, JoÃ£o Portela and XT \nOn an interactive GLSLEditor developed by me\n[url]http://github.com/rakesh-malviya/GLSLEditor[/url]\nPlease goto the link and try it (Qt and glut required)", "tags": ["procedural", "3d", "distancefield", "flame", "heart"], "likes": 11, "viewed": 717, "date": "1404078258", "time_retrieved": "2024-06-20T18:11:42.023568", "image_code": "// Original shader created by XT95 - flame\n//AND\n// Original shader created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// modified by JoÃ£o Portela. Heart3\n\n//Wanted to try some shaders on an interactive GLSLEditor developed by me\n//https://github.com/rakesh-malviya/GLSLEditor\n//Please goto the link and try it\n\n\nfloat noise(vec3 p) //Thx to Las^Mercury\n{\n        vec3 i = floor(p);\n        vec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n        vec3 f = cos((p-i)*acos(-1.))*(-.5)+.5;\n        a = mix(sin(cos(a)*a),sin(cos(1.+a)*(1.+a)), f.x);\n        a.xy = mix(a.xz, a.yw, f.y);\n        return mix(a.x, a.y, f.z);\n}\n\nfloat sphere(vec3 p, vec4 spr)\n{\n        return length(spr.xyz-p) - spr.w;\n}\n\nfloat flame(vec3 p)\n{\n        float d = sphere(p*vec3(0.4,0.5,1.0), vec4(.0,-1.,.0,1.));\n        return d + (noise(p+vec3(.0,iTime*2.,.0)) + noise(p*3.)*.5)*.25*(p.y) ;\n}\n\nfloat scene(vec3 p)\n{\n        return min(100.-length(p) , abs(flame(p)) );\n}\n\nvec4 raymarch(vec3 org, vec3 dir)\n{\n        float d = 0.0, glow = 0.0, eps = 0.02;\n        vec3  p = org;\n        bool glowed = false;\n\n        for(int i=0; i<64; i++)\n        {\n                d = scene(p) + eps;\n                p += d * dir;\n                if( d>eps )\n                {\n                        if(flame(p) < .0)\n                                glowed=true;\n                        if(glowed)\n                        glow = float(i)/64.;\n                }\n        }\n        return vec4(p,glow);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    p.y -= 0.25;\n\n    // background color\n    vec3 bcol = vec3(1.0,0.7,0.8-0.07*p.y)*(1.0-0.35*length(p));\n\n    // animate\n    float tt = abs(sin(iTime))*1.5;\n    float ss = pow(tt,.2)*0.5 + 0.5;\n    ss -= ss*0.2*sin(tt*6.2831*3.0)*exp(-tt*4.0);\n    p *= vec2(0.5,1.5) + ss*vec2(0.5,-0.5);\n\n\n    // shape\n    float a = atan(p.x,p.y)/3.141593;\n    float r = length(p);\n    float h = abs(a);\n    float d = (13.0*h - 22.0*h*h + 10.0*h*h*h)/(6.0-5.0*h);\n\n        // color\n        float s = 1.0-0.5*clamp(r/d,0.0,1.0);\n        s = 0.75 + 0.75*p.x;\n        s *= 1.0-0.25*r;\n        s = 0.5 + 0.6*s;\n        s *= 0.5+0.5*pow( 1.0-clamp(r/d, 0.0, 1.0 ), 0.1 );\n        vec3 hcol = vec3(1.0,0.5*r,0.3)*s;\n\n    vec3 col = mix( bcol, hcol, smoothstep( -0.01, 0.01, d-r) );\n\n    vec2 vXT = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    vXT.x *= iResolution.x/iResolution.y;\n\n    vec3 orgXT = vec3(0., -2., 4.);\n    vec3 dirXT = normalize(vec3(vXT.x*1.6, -vXT.y, -1.5));\n\n    vec4 pXT = raymarch(orgXT, dirXT);\n    float glowXT = pXT.w;\n\n    vec4 colXT = mix(vec4(0.7,0.4,.1,1.), vec4(0.1,.5,1.,1.), pXT.y*(-0.02)+.4);\n\n    fragColor = mix(vec4(col,1.0),colXT, pow(glowXT*2.,4.));\n\n    //fragColor = vec4(col,1.0);\n}\n\n\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        vec2 v = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n        v.x *= iResolution.x/iResolution.y;\n\n        vec3 org = vec3(0., -2., 4.);\n        vec3 dir = normalize(vec3(v.x*1.6, -v.y, -1.5));\n\n        vec4 p = raymarch(org, dir);\n        float glow = p.w;\n\n        vec4 col = mix(vec4(1.,.5,.1,1.), vec4(0.1,.5,1.,1.), p.y*.02+.4);\n\n        fragColor = mix(vec4(0.), col, pow(glow*2.,4.));\n        //fragColor = mix(vec4(1.), mix(vec4(1.,.5,.1,1.),vec4(0.1,.5,1.,1.),p.y*.02+.4), pow(glow*2.,4.));\n\n}\n*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdlSRj.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[229, 386, 428, 428, 707], [709, 709, 741, 741, 785], [787, 787, 808, 808, 957], [959, 959, 980, 980, 1035], [1037, 1037, 1072, 1072, 1552], [1557, 1557, 1614, 1614, 2882]]}
{"id": "XdlSzB", "name": "the power of sin", "author": "antonOTI", "description": "I found this gif http://imgur.com/gallery/2wlcFxE \nI wanted to make one myself", "tags": ["sin", "circle", "gif"], "likes": 22, "viewed": 919, "date": "1403438246", "time_retrieved": "2024-06-20T18:11:42.023568", "image_code": "#define NB 35.\n#define MODE1\nfloat circle(vec2 center , float radius,float thickness,float la,float ha)\n{\n\tfloat f = length(center);\n\t\n\tfloat a = atan(center.y,center.x) ;\n\treturn(smoothstep(f,f+0.01,radius) * smoothstep(radius - thickness,radius - thickness+0.01,f) * step(la,a)*step(a,ha));\n}\n\nfloat cable(vec2 p,float dx,float dy,float r,float thick,float la,float ha)\n{\n\tp.x-=dx;\n\tp.y -= dy;\n\treturn (circle(p,r,thick,la,ha));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n\t\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 p = -1. + 2. * uv;\n\tp.x*=iResolution.x/iResolution.y;\n\t#ifdef MODE1\n\tvec2 ap = p * vec2(-1.,-1.);\n\t#else\n\tvec2 ap = p * vec2(1.,-1.);\n\t#endif\n\t\n\tfloat f = 0.;\n\tfor(float i = 0.; i < NB; ++i)\n\t{\n\t\tfloat divi = i/NB;\n\t\tf += cable(p,0.,0.,.99 - divi,.025,0.,(sin(iTime - divi*5.)*.5+.5) * 3.14);\n\t\tf += cable(ap,0.,0.,.99 - divi,.025,0.,(sin(iTime - divi*5.)*.5+.5) * 3.14);\n\t}\n\tvec3 col = mix(vec3(0.,0.,0.),vec3(1.,1.,1.),f);\n\t\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdlSzB.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[29, 29, 105, 105, 294], [296, 296, 373, 373, 432], [434, 434, 491, 491, 1000]]}
{"id": "XdXSRB", "name": "Sine Noise", "author": "demofox", "description": "Trying to make some monochromatic noise using the sum and product of sine waves of various frequencies and amplitudes.\n\nGot a completely different effect though and I can't seem to be able to rename a shader once it's a draft!", "tags": ["2d"], "likes": 1, "viewed": 253, "date": "1403065532", "time_retrieved": "2024-06-20T18:11:42.024565", "image_code": "\n#define SinLayerX(frequency, amplitude, delta) amplx += amplitude; colorx += (sin(uv.x*6.28*frequency*correct + (iTime*delta*timeMultiplier))*(amplitude*0.5)+(amplitude*0.5));\n#define SinLayerY(frequency, amplitude, delta) amply += amplitude; colory += (sin(uv.y*6.28*frequency + (iTime*delta*timeMultiplier))*(amplitude*0.5)+(amplitude*0.5));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\tconst float timeMultiplier = 1.0;\n\t\n\tfloat correct = iResolution.x / iResolution.y;\n\t\n\tfloat colorx = 0.0;\n\tfloat colory = 0.0;\n\tfloat amplx  = 0.0;\n\tfloat amply  = 0.0;\n\t\n\tSinLayerY( 8.0, 0.5 , -0.6);\n\tSinLayerY( 3.0, 0.3 ,  2.0); \n\tSinLayerY( 7.0, 0.15, -3.0);\n\tSinLayerY(17.0, 0.05,  5.0);\n\n\tSinLayerX( 8.0, 0.05,  3.0);\n\tSinLayerX( 3.0, 0.5,  -5.0); \n\tSinLayerX( 7.0, 0.3,   0.6);\n\tSinLayerX( 5.0, 0.15, -2.0);\n\t\n\t#if 1\n\t\tfloat color = colorx/amplx * colory/amply;\n\t#else\n\t\tfloat color = (colorx + colory) / (amplx + amply);\n\t#endif\n\t\n\tcolor = clamp(color, 0.0, 1.0);\n\t\n\tfloat red = color;\n\tfloat green = color;\n\tfloat blue = color;\n\t\n\t\n\tfragColor = vec4(red,green,blue,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdXSRB.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[346, 346, 403, 403, 1130]]}
{"id": "XdXXRS", "name": "trochoids", "author": "FabriceNeyret2", "description": "Gerstner swell model: surface points displace along stationary circles -> trochoidal wave\nMouse tune wavelengh (x) and amplitude (y).\n(NB: Computing distance to displacement is not so easy... But I hate coslty iterative scheme ! :-p )", "tags": ["trochoid"], "likes": 19, "viewed": 2445, "date": "1402853180", "time_retrieved": "2024-06-20T18:11:42.416754", "image_code": "float L = .6,  \t\t  // wavelength\n\t  A = .2,         // amplitude  \n\t  C = 1.;         // wave celerity = omega/K = 2PI/TK, with T = period\n\n#define PI 3.1415927\n\n// === distance to trochoid\n\nfloat trochoid(vec2 uv, float A, float L, float C) {\n    float t = iTime;\n    float K=6.28/L; // wave number\n\t\n\t// --- 1st, intersection with uv.y (or closest)\n\tfloat y = uv.y/A;\n\tif (abs(y)>1.) y /= abs(y);\n\t\n\t// solve for x :  y = Asin(phi) with phi = K(x-Ct)\n\tfloat phi = asin(y),\n\t\t\tx = phi/K+C*t,\n\t\t   x1 = x+A*cos(phi); // x+A*sqrt(1-y*y)\n\t\n\t// 2nd solution for asin\n\tphi = PI-phi;\n\tx = phi/K+C*t;\n\tfloat x2 =  x+A*cos(phi);\n\t\t\n\t// find branch closest to x,y\n\tx1 = uv.x-x1; \tx1 = min(mod(x1,L), mod(-x1,L));\n\tx2 = uv.x-x2; \tx2 = min(mod(x2,L), mod(-x2,L));\n\tx = min(x1,x2);\n\tif (x1<x2) phi = PI-phi;\n\t\n\t// --- 2nd, get the tangent line and find the closest sitance to uv\n\tvec2 dP = vec2( 1.-A*K*sin(phi), A*K*cos(phi) ); \n\ty = A*y; // A*sin(phi)\n\ty = uv.y-y;\n\tvec2 P = vec2(x,y);\n\tfloat l = dot(P,dP)/dot(dP,dP);\n\t//float d = length(P-l*dP);\n\n\t// --- still ambiguous for horizontal tangent\n\t// accounting for curvature should fix it. \n\t// here, we do half-way to avoid solving degree 3 polynomial\n\tvec2 d2P = -A*K*K* vec2( cos(phi), sin(phi) ); \n\tfloat d = length(P-l*dP-l*l/10.*d2P);\n\t\n\treturn d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.*(fragCoord.xy / iResolution.y - vec2(.9,.5));\n\n\t// --- tuning\n\tvec2 m = iMouse.xy/iResolution.xy;\n\tif (iMouse.z>0.) {\n\t\tL *= m.x; A *= m.y;\n\t}\n\t\n\t// === distance to trochoids\n\tfloat d;\n\t\n\td =        trochoid(uv-vec2(0., .5), A,L   ,C);\n\td = min(d, trochoid(uv-vec2(0., .0), A,L*2.,C));\n\td = min(d, trochoid(uv-vec2(0.,-.5), A,L*4.,C));\n\t\n\t\n  \tfloat v = smoothstep(.01,0.,d);\t\n\t\n\tfragColor = vec4(v);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdXXRS.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[162, 191, 243, 243, 1296], [1298, 1298, 1355, 1355, 1771]]}
{"id": "XsfSRB", "name": "Bubblegummy", "author": "TomoAlien", "description": "Some kinda bubblegum thingy", "tags": ["metaball", "pink", "shiny", "gum", "bubblegum"], "likes": 2, "viewed": 202, "date": "1402993254", "time_retrieved": "2024-06-20T18:11:42.416754", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfloat time = iTime*1.25;\n\t\n\tfloat blob1x = (-0.5+sin(time*0.8)/3.0);\n\tfloat blob1y = (-0.5-cos(time*2.2)/3.0);\n\tfloat blob1  = sqrt(pow(uv.x+blob1x,2.0)*2.5+pow(uv.y+blob1y,2.0));\n\t\n\tfloat blob2x = (-0.5+sin(time*0.7+0.3)/3.0);\n\tfloat blob2y = (-0.5-cos(time*1.0-0.2)/3.0);\n\tfloat blob2  = sqrt(pow(uv.x+blob2x,2.0)*2.5+pow(uv.y+blob2y,2.0));\n\t\n\tfloat blob3x = (-0.5+sin(time*1.5+0.6)/3.0);\n\tfloat blob3y = (-0.5-cos(time*0.4-0.85)/3.0);\n\tfloat blob3  = sqrt(pow(uv.x+blob3x,2.0)*2.5+pow(uv.y+blob3y,2.0));\n\t\n\tfloat final = (1.0-(blob1*blob2*blob3)*16.0+1.0)/2.0;\n\t\n\tvec3 gum = vec3((final)*1.0+final*0.8*abs(-final+0.1),-(final*-1.0*abs(final)),(final*1.0));\n\t\n\tfragColor = vec4(clamp(-gum.brr/16.0*2.0,0.0,1.0)+clamp(gum.rgb,0.0,1.0),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsfSRB.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 844]]}
{"id": "XsfXRB", "name": "Flip Disco", "author": "TomoAlien", "description": "Wanted to make a mode7 lookalike, ended up with this. Still cool tho.", "tags": ["2d", "fake", "disco", "floor", "fake3d", "morph", "mode7"], "likes": 1, "viewed": 290, "date": "1403011401", "time_retrieved": "2024-06-20T18:11:42.422674", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfloat time = iTime;\n\tfloat depth = sin(uv.y*2.0+sin(time)*1.5+1.0)*cos(uv.y*2.0+time);\n\tfloat texey = (uv.x-0.5);\n\tfloat xband = sin(sqrt(uv.y/uv.y)*16.0/(depth)+time*3.0);\n\tfloat final = (\n\t\tsin(texey/abs(depth)*32.0+time*2.0)*(depth)*xband\n\t);\n\tfragColor = vec4(final*final,-final,abs(final),1.0)*1.5;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsfXRB.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 406]]}
{"id": "XslSRj", "name": "Circular", "author": "r1", "description": "Simple black and white. Increased the amplitude of the sine wave to provide some pseudo antialiasing. ", "tags": ["2d"], "likes": 9, "viewed": 380, "date": "1404120627", "time_retrieved": "2024-06-20T18:11:42.422830", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n\tfloat d = distance(fragCoord.xy, iResolution.xy * vec2(0.5,0.5).xy);\n\t\n\tfloat x = sin(5.0+0.1*d + iTime*-4.0) * 5.0;\n\t\n\t// some drivers don't appear to cope with over ranged values. \n\tx = clamp( x, 0.0, 1.0 );\n\t\n\tfragColor = vec4( x, x, x, 1 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XslSRj.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 307]]}
{"id": "XssXRB", "name": "Wood", "author": "bytewave", "description": "Procedural wood", "tags": ["noise"], "likes": 0, "viewed": 274, "date": "1403432380", "time_retrieved": "2024-06-20T18:11:42.683359", "image_code": "\nfloat rand2(vec2 co,float seed)\n{\n\treturn fract(sin(dot(co.xy ,vec2(seed,78.233))) * 43758.5453);\n}\n\nfloat rand(float n,float seed)\n{\n\treturn fract(sin(n*4532.63264)*5375.52465 * seed);\n}\n\nfloat CosInterpolate(float v1, float v2, float a)\n{\n\tfloat angle = a * 3.14159;\n\tfloat prc = (1. - cos(angle)) * 0.5;\n\treturn  v1*(1.0 - prc) + v2*prc;\n}\n\nfloat noise(float pos,float Size,float seed)\n{\t\n\tfloat grid = floor(pos * Size) * 0.1;\n\tfloat PosGrid = mod((pos),1./Size) * Size ;\n\tfloat nextGrid =  floor((pos + (1./Size))* Size) * 0.1;\n\tfloat sample1 = ((rand(grid,seed)));\n\tfloat sample2 = ((rand(nextGrid,seed)));\n\t\n\t//return nextGrid;\n\treturn CosInterpolate(sample1,sample2,PosGrid);\n}\n\t\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 uv = vec3(fragCoord.xy / iResolution.xy , .15);\t\t\n\tfloat u = noise(uv.x + (iTime * 0.1),110. / (10. + (iMouse.x/30.)),272.);\n\tu *= noise(uv.y + (iTime * 0.1),10.,272.) ;\n\tu += noise(uv.y + (iTime * 0.1),10.,272.) ;\n\t\n\tfloat v = noise(uv.y + (u * 0.1),110.,272.);\n\t\n\t\n\tfloat Val  = u * v;\n\tvec3 ColorA = vec3(0.15,0.13,0.134) * 2.;\n\tColorA *= ColorA;\n\t\n\tvec3 ColorB = vec3(0.6,0.25,0.1354) * 1.2;\n\tColorB *= ColorB;\n\t\n\t\n\t\n\tvec3 Wood = mix(ColorA,ColorB,Val);\n\t\n\t\n\tfragColor = vec4(Wood,1. )  ;\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XssXRB.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1, 1, 34, 34, 100], [102, 102, 134, 134, 188], [190, 190, 241, 241, 343], [345, 345, 391, 391, 686], [690, 690, 747, 747, 1249]]}
{"id": "XsXSDM", "name": "pdex_third", "author": "pdex", "description": "CIRCLES! OVALS!", "tags": ["n00b"], "likes": 0, "viewed": 155, "date": "1401716375", "time_retrieved": "2024-06-20T18:11:42.689205", "image_code": "vec2 ellipse(vec2 point, vec4 object) {\n\tvec2 two = vec2(2,2);\n\treturn pow(point.xy - object.xy, two) / pow(object.zw, two);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 point = fragCoord.xy;\n\n\t\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n\n\t\n\tvec2 exp = vec2(iResolution.x,iResolution.y);\n\t\n\tvec2 center = iResolution.xy / 2.0;\n\tif ( length(point - center) > 150.0 ) {\n\t\tfragColor = vec4(0,0,0,1);\n\t}\n\t\n\t\n\tif (length(uv - vec2(0.25, 0.25)) < 0.09 + 0.05 * cos(iTime)) {\n\t\tfragColor = vec4(1,0,0,1);\n\t}\n\t\n\tvec4 ellipse = vec4(-150,100,10,20);\n\tellipse.xy += center.xy;\n\n/*\t\n\tfloat fEllipse = pow(point.x-ellipse.x,2.0) / pow(ellipse.z,2.0) + \n\t\t\t\t\t pow(point.y-ellipse.y,2.0) / pow(ellipse.w,2.0);\n*/\n\t\n\tfloat fEllipse = pow(((point.x-ellipse.x)*cos(iTime)+(point.y-ellipse.y)*sin(iTime)),2.0) / pow(ellipse.z,2.0) + \n\t\t\t \t\t pow(((point.x-ellipse.x)*sin(iTime)-(point.y-ellipse.y)*cos(iTime)),2.0) / pow(ellipse.w,2.0);\n\n\t\n\t\n\tvec2 two = vec2(2,2);\n\tvec2 poop = pow(point.xy - ellipse.xy, two) / pow(ellipse.zw, two);\n    float fDistance = abs(1.0-fEllipse);\n\tfloat fDumb = abs(1.0-(poop.x+poop.y));\n\tif (fDistance < 1.0 + abs(5.0*sin(iTime))) {\n\t\tfragColor = vec4(0,1,0,1);\n\t}\n\t\n\t//if (length(point - ellipse(\n\t\n\t/*\n\tif (length(point - (center + vec2(-150,100))) < 15.0) {\n\t\tfragColor = vec4(0,1,0,1);\n\t}\n\t*/\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsXSDM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 39, 39, 126], [128, 128, 185, 185, 1375]]}
{"id": "XsXXDM", "name": "Light and Shadow", "author": "slade", "description": "Basic ray cast shadows on a bunch of spheres.", "tags": ["ray", "basic", "shadow", "light", "sphere", "cast"], "likes": 10, "viewed": 578, "date": "1401856196", "time_retrieved": "2024-06-20T18:11:42.689472", "image_code": "//Based on https://www.shadertoy.com/view/MdXSD8\n\n#define SPHERE_SIZE 3.0\n#define NO_HIT_ID -1\n#define LIGHT_ID -2\n\n//Light setup\nvec3 light = vec3(0, 0.0, 25.0);\n\n//Functions \n\nmat4 rotateY(float theta) {\n\tfloat cosTheta = cos(theta);\n\tfloat sinTheta = sin(theta);\n\treturn mat4(cosTheta, 0.0, sinTheta, 0.0,\n\t\t\t\t0.0, 1.0, 0.0, 0.0,\n\t\t\t\t-sinTheta, 0.0, cosTheta, 0.0,\n\t\t\t\t0.0, 0.0, 0.0, 1.0);\n}\n\nvec2 iSphere(in vec3 rayOrigin, in vec3 rayDirection, in vec4 sph) {\n\t//sphere at origin has equation |xyz| = r\n\t//so |xyz|^2 = r^2.\n\t//Since |xyz| = rayOrigin + t*rayDirection (where t is the distance to move along the ray),\n\t//we have rayOrigin^2 + 2*rayOrigin*t*rayDirection + t^2 - r^2. This is a quadratic equation, so:\n\tvec3 oc = rayOrigin - sph.xyz; //distance ray origin - sphere center\n\t\n\tfloat b = dot(oc, rayDirection);\n\tfloat c = dot(oc, oc) - sph.w * sph.w; //sph.w is radius\n\tfloat h = b*b - c; //Commonly known as delta. The term a is 1 so is not included.\n\t\n\tvec2 t;\n\tif(h < 0.0) \n\t\tt = vec2(-1.0);\n\telse  {\n\t\tfloat sqrtH = sqrt(h);\n\t\tt.x = (-b - sqrtH); //Again a = 1.\n\t\tt.y = (-b + sqrtH);\n\t}\n\treturn t;\n}\n\n//Get sphere normal.\nvec3 nSphere(in vec3 pos, in vec4 sph ) {\n\treturn normalize((pos - sph.xyz)/sph.w);\n}\n\nint intersect(in vec3 rayOrigin, in vec3 rayDirection, out vec2 resT, out vec4 sph) {\n\tresT = vec2(1000.0);\n\tint hitId = NO_HIT_ID;\n\tint sphId = hitId;\n\tmat4 rotationAngle = rotateY(-0.1 * iTime);\n\t\n\t//check against spheres in the scene\n\tfor (float x = -20.0; x <= 20.0; x += 10.0) {\n\t\tfor (float y = -20.0; y <= 20.0; y += 10.0) {\n\t\t\tfor (float z = -20.0; z <= 20.0; z += 10.0) {\n\t\t\t\tvec3 pos = vec3(x, y, z);\n\t\t\t\tsphId += 1;\n\t\t\t\tvec4 posSph = vec4(pos, 1.0);\n\t\t\t\tposSph = rotationAngle * posSph;\n\t\t\t\tvec4 sphTry = vec4(posSph.x + 0.5*posSph.x*sin(0.3*iTime), \n\t\t\t\t\t\t\t\t   posSph.y + 0.25*posSph.y*sin(0.4*iTime),\n\t\t\t\t\t\t\t\t   posSph.z + 0.25*posSph.z*sin(0.5*iTime),\n\t\t\t\t\t\t\t\t   SPHERE_SIZE);\n\t\t\t\tvec2 tsph = iSphere(rayOrigin, rayDirection, sphTry);\n\t\t\t\tif(tsph.x > 0.0 && resT.y > tsph.x) {\n\t\t\t\t\tsph = sphTry;\n\t\t\t\t\tresT = tsph;\n\t\t\t\t\thitId = sphId;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//check against the light\n\tvec4 lightSph = vec4(light, 0.5);\n\tvec2 tsph = iSphere(rayOrigin, rayDirection, lightSph);\n\tif (tsph.x > 0.0 && resT.y > tsph.x) {\n\t\tsph = lightSph;\n\t\tresT = tsph;\n\t\thitId = LIGHT_ID;\n\t}\n\treturn hitId;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t//pixel coordinates from 0 to 1\n\tfloat aspectRatio = iResolution.x/iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\t//generate a ray with origin ro and direction rd\n\tvec3 rayOrigin = vec3(0.0, 0.0, 40.0);\n\tvec3 rayDirection = normalize(vec3( (-1.0+2.0*uv) * vec2(aspectRatio, 1.0), -1.0));\n\t\n\tmat4 rotY = rotateY(iTime);\n\tlight.y += 10.0*sin(iTime);\n\tlight = (vec4(light, 1.0) * rotY).xyz;\n\n\t//intersect the ray with scene\n\tvec2 t;\n\tvec4 sphHit;\n\tint id = intersect(rayOrigin, rayDirection, t, sphHit);\n\t\n\tvec3 color;\n\t//If we hit a sphere\n\tif(id >= 0)\n\t{\n\t\t//find the point where we hit the sphere and evaluate luminance\n\t\tvec3 pos = rayOrigin + t.x*rayDirection;\n\t\tvec3 nor = nSphere(pos, sphHit);\n\t\tfloat dif = clamp(dot(nor, normalize(light-pos)), 0.0, 1.0);\n\t\t\n\t\t//check to see if this point is in shadow\n\t\tvec2 shadowT;\n\t\tvec4 shadowHit;\n\t\t//check for intersect between the sphere and the light\n\t\tint shadowId = intersect(pos, normalize(light-pos), shadowT, shadowHit);\n\t\t\n\t\t//if we have a non-negative id, we've hit something other than the light\n\t\tif (shadowId >= 0) {\n\t\t\tcolor = vec3(0.0);\n\t\t}\n        else {\n            color = vec3(dif);\n        }\n\t}\n\t//If we hit the light\n\telse if (id == LIGHT_ID) {\n\t\tcolor = vec3(1.0);\n\t}\n    else {\n        color = vec3(0.1);\n    }\n\t\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsXXDM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[164, 178, 205, 205, 394], [396, 396, 464, 720, 1119], [1121, 1142, 1183, 1183, 1227], [1229, 1229, 1314, 1314, 2328], [2330, 2330, 2387, 2420, 3715]]}
