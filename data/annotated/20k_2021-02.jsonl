{"id": "3l3BDr", "name": "Art Of Code Smiley Tutorial", "author": "shellshear", "description": "Following along (mostly) the Art of Code youtube tutorial https://www.youtube.com/watch?v=ZlNnrpM0TRg&t=1328s and https://www.youtube.com/watch?v=vlD_KOrzGDc&t=0s", "tags": ["theartofcode"], "likes": 3, "viewed": 52, "published": "Public", "date": "1612485076", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Remap v to be 0 at a and 1 at b and clamped to between 0 and 1\nfloat remap_simple(float a, float b, float v)\n{\n    return clamp((v-a)/(b-a), 0., 1.);\n}\n \n// Remap v so that output is linearly c at a and d at b\nfloat remap(float a, float b, float c, float d, float v)\n{\n    return (d-c)*remap_simple(a,b,v) + c;\n}\n\n// map coordinates to be within the rect, as defined by xy = top left\n// and zw = bottom right.\n// coords go from -.5 to .5\nvec2 within(vec2 uv, vec4 rect)\n{\n    return (uv-rect.xy)/(rect.zw-rect.xy)-.5;\n}\n\nvec4 Mouth(vec2 uv, float smile)\n{\n    uv.y += uv.x*uv.x * smile*2.;\n    uv.x *= mix(2., 1., smile);\n    vec4 col = vec4(.6, .2, .1, smoothstep(.5, .46, length(uv)));\n    \n    float d = length(uv);\n    \n    // Teeth\n    vec3 teethCol = vec3(1.)*smoothstep(.6,.35,d);\n\n    float td = length(uv-vec2(0., -.7));\n    float teethVal = smoothstep(.6,.55,td);\n    col.rgb = mix(col.rgb, teethCol, teethVal);\n    \n    // tongue\n    float tongued = length(uv-vec2(0.,.4));\n    float tongueval = smoothstep(.3, .15, tongued);\n    col.rgb = mix(col.rgb, vec3(1.0, .5, .5), tongueval);\n    \n    return col;\n}\n\n\nvec4 Eye(vec2 uv, float side, vec2 mousePos, float smile)\n{\n    // Flip x if we're on the left side so eyes\n    // have the same highlights/movement\n    uv.x *= side; \n    \n    vec4 col = vec4(1.);\n    float d = length(uv);\n    col.a = smoothstep(.5, .48, d);\n    vec3 irisColour = vec3(0.3, .5, .9);\n    \n    float d2 = length(uv-mousePos*.5);\n    float d3 = length(uv-mousePos*.55);\n    \n    // add shade to eyeball\n    float innereyeShade = smoothstep(.45, .47, d) * (1.0-length(uv+vec2(.5*side,.5)));\n    col.rgb = mix(col.rgb, irisColour, innereyeShade);\n    \n    float irisSize = .28;\n    float pupilSize = mix(.3, .18, smile);\n    \n    // add iris\n    float irisVal = smoothstep(irisSize, irisSize*.9, d2);\n    col.rgb = mix(col.rgb, irisColour, irisVal);\n    \n    // add pupil\n    float pupilVal = smoothstep(pupilSize, pupilSize*.8, d3);\n    pupilVal *= irisVal;\n    col.rgb = mix(col.rgb, vec3(0.), pupilVal);\n    \n    // Add highlights\n    float t = iTime * 10.;\n    uv.x+= sin(t+uv.y*20.)*.02*(1.-smile);\n    uv.y+= sin(t+uv.x*20.)*.02*(1.-smile);\n\n    col.rgb = mix(col.rgb, vec3(1.), \n        smoothstep(.1, .07, length(uv-vec2(-.1,.1))));\n    col.rgb = mix(col.rgb, vec3(1.), \n        smoothstep(.05, .03, length(uv-vec2(.1,-.1))));\n    \n    \n    return col;\n}\n\n\nvec4 Head(vec2 uv, float smile)\n{\n    vec4 col = vec4(.9, .6, .1, 1.0);\n    float d = length(uv);\n    col.a = smoothstep(0.5, .48, d);\n    \n    // Shade outside\n    float shade = remap_simple(0.35, .5, d);\n    col.rgb *= 1.-shade*shade*.5;\n    \n    // Add rim\n    vec3 rim = vec3(.8, .4, .1);\n    col.rgb = mix(col.rgb, rim, smoothstep(.47, .48, d));\n    \n    // Add highlight\n    float highlight = smoothstep(.41, .4, d);\n    highlight *= remap(.41, -.1, .75, .0, uv.y);\n    highlight *= smoothstep(.18, .2, length(uv-vec2(.21, .08)));\n    \n    col.rgb = mix(col.rgb, vec3(1.), highlight);\n    \n    // Add cheeks\n    d = length(uv-vec2(.25,-.2));\n    float cheek = smoothstep(.2, .01, d) * .5;\n    col.rgb = mix(col.rgb, vec3(.9,.3,.1), cheek*smile);\n    \n    return col;\n}\n\nvec4 Smiley(vec2 uv, vec2 mousePos, float smile)\n{\n    vec4 col = vec4(.0, .0, .0, 1.0);\n    float side = sign(uv.x);\n    uv.x = abs(uv.x);\n    vec4 head = Head(uv, smile);\n    vec4 eye = Eye(within(uv, vec4(.03, -.1, .37, .25)), side, mousePos, smile);\n    vec4 mouth = Mouth(within(uv, vec4(-.3, -.2, .3, -.4)), smile);\n    \n    \n    col = mix(col, head, head.a);\n    col = mix(col, eye, eye.a);\n    col = mix(col, mouth, mouth.a);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float smile = cos(iTime)*.5+.5;\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy - .5;\n\n    uv -= mousePos*(.25-dot(uv, uv))*.5;\n    // Time varying pixel color\n    fragColor = Smiley(uv, mousePos, smile);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l3BDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 66, 113, 113, 154], [157, 213, 271, 271, 315], [317, 441, 474, 474, 522], [524, 524, 558, 558, 1120], [1123, 1123, 1182, 1271, 2398], [2401, 2401, 2434, 2434, 3175], [3177, 3177, 3227, 3227, 3633], [3635, 3635, 3692, 3742, 4058]], "test": "valid"}
{"id": "3l3fRB", "name": "formographik__002", "author": "formographik", "description": "wip", "tags": ["opartwip"], "likes": 0, "viewed": 36, "published": "Public", "date": "1612923210", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Nicole Vella\n// 2021\n\nvec2 createGrid(in vec2 st,in vec2 grid,out vec2 cells){\n    st*=grid;\n    cells=floor(st);\n    st=fract(st);\n    return st;\n}\n\nfloat drawRectangle(vec2 st,vec2 pos,vec2 size){\n    \n    float result=1.;\n    vec2 border=(1.-size)/2.200;\n    \n    st=st-pos+vec2(.5);\n    \n    result=step(border.x,st.x);\n    result*=step(border.x,1.-st.x);\n    result*=step(border.y,1.-st.y);\n    result*=step(border.y,st.y);\n    \n    return result;\n}\n\nvec2 animationPosition(float t){\n    \n    vec2 p1,p2,p3,p4;\n    \n    p1=vec2(1.,1.);\n    p2=vec2(0.,0.5);\n    p3=vec2(0.,0.);\n    p4=vec2(0.5,0.0);\n    \n    vec2 result;\n        \n    t*=4.;\n         \n    if(t<1.){\n        result=mix(p1,p2,smoothstep(0.,1.,fract(t)));\n    } else if(t<2.){\n        result=mix(p2,p3,smoothstep(0.,1.,fract(t)));\n    } else if(t<3.){\n        result=mix(p3,p4,smoothstep(0.,1.,fract(t)));\n    } else if(t<4.){\n        result=mix(p4,p1,smoothstep(0.,1.,fract(t)));\n    }\n   \n    return result;\n}\n    \n#define drawCircle(st,pos,size)smoothstep(0.,10./iResolution.y,size-length(pos-st))\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n  vec2 st=fragCoord.xy/iResolution.xy;\n    st.x*=iResolution.x/iResolution.y;\n\n    vec2 cells;\n    st=createGrid(st,vec2(6.,6.),cells);\n\n    float circSize=.5;\n    vec2 size=vec2(.25,.25);\n    vec2 pos=vec2(.5,.5);\n\n    pos=animationPosition(fract(iTime*.04));\n\n    vec3 white=vec3(1.);\n    vec3 black=vec3(0.);\n    vec3 canvas=vec3(0.);\n\n    // bg rect\n    float rect=drawRectangle(st,vec2(.5),vec2(1.));\n    float circleC=drawCircle(st,pos,circSize);\n    float circleCC=drawCircle(st,-pos+1.,circSize);\n\n    if (mod(cells.x+cells.y,2.)==1.) {\n        canvas=mix(canvas,black,rect);\n        canvas=mix(canvas,white,circleC);\n        canvas=mix(canvas,white,circleCC);\n     }else{\n        canvas=mix(canvas,white,rect);\n        canvas=mix(canvas,black,circleC);\n        canvas=mix(canvas,black,circleCC);\n     }\n\n     fragColor=vec4(canvas,1.);\n    }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l3fRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 25, 81, 81, 151], [153, 153, 201, 201, 457], [459, 459, 491, 491, 982], [1077, 1077, 1134, 1134, 1986]], "test": "valid"}
{"id": "3l3fRH", "name": "fork-e#70957.0", "author": "jorge2017a1", "description": "fork-e#70957.0", "tags": ["forke709570"], "likes": 3, "viewed": 57, "published": "Public", "date": "1612188209", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//modificado por jorge2017a1\n// fork e#70957.0\n\n#define BITS 10\n\nfloat xor(float a, float b) {\n\tfloat mask = pow(2.0, float(BITS));\n\tfloat c = 0.0;\n\n\tif (a < 0.0) a = mask - a;\n\tif (b < 0.0) b = mask - b;\n\n\tfor (int i = 0; i < BITS; i++) {\n\t\tmask *= 0.5;\n\t\tc *= 2.0;\n\t\tc += mod(floor(a / mask) + floor(b / mask), 2.0);\n        c+=2.0*abs(sin(c*0.5));\n\t}\n\n\treturn c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat x = floor(fragCoord.x);\n\tfloat t = floor(fragCoord.y + iTime * 20.0);\n\tfloat a = xor(x - t, x + t);\n\tfloat c = (mod(abs(t + a*a*a), 997.0) < 97.0) ? 1.0 : 0.0;\n\tfloat c1 = (mod(abs(t + a*a*a), 997.0) < 37.0) ? 1.0 : 0.0;\n\tfloat c2 = (mod(abs(t + a*a*a), 997.0) < 161.0) ? 1.0 : 0.0;\n\tfragColor = vec4(c2, c, c1, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l3fRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 65, 94, 94, 367], [369, 369, 426, 426, 751]], "test": "valid"}
{"id": "3l3fW4", "name": "Keyboard tester", "author": "sig", "description": "Left to right: keycodes, each 10 with blue, each 100 with green\nBottom to top: 0 = down, 1 = press, 2 = toggle", "tags": ["keyboard"], "likes": 2, "viewed": 43, "published": "Public", "date": "1612701547", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Integer coordinates for the 256 x 3 keyboard \"texture\", plus some border space\n    ivec2 pi = ivec2(uv.x*300.0 - 20., uv.y*6.0 - 2.);    \n\n    // Read keyboard data with texelFetch(channel, coordinate, lod_level)\n    vec3 col =\n        pi.x < 0 || pi.x > 256 || pi.y < 0 || pi.y > 2 ? 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)) :\n        texelFetch(iChannel3, pi, 0).x > 0.5 ? vec3(1., 0., 0.) :\n        pi.x % 100 == 0 ? vec3(0., 1., 0.) :\n        pi.x % 10 == 0 ? vec3(0., 0., 1.) :\n        pi.x % 2 == 0 ? vec3(0., 0., 0.3) :\n        vec3(0);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l3fW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 761]], "test": "error"}
{"id": "3lcBD2", "name": "Perfect Pistons Example 2", "author": "blackle", "description": "See [url=https://youtu.be/I8fmkLK1OKg]the tutorial video this is from[/url]", "tags": ["domainrepetition", "pistons"], "likes": 18, "viewed": 406, "published": "Public API", "date": "1613442932", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//In this example we extend the \"assume-the-worst\" trick to 2 dimensional domain repetition.\n\nfloat piston(vec2 p, float width, float height) {\n    p.x = abs(p.x) - width;\n    p.y -= height;\n    return length(max(p,0.0)) + min(0.0, max(p.x,p.y));\n}\n\nfloat piston3D(vec3 p, float width, float height) {\n    vec2 p2 = vec2(length(p.xy), p.z);\n    return piston(p2, width, height);\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nvec2 edge(vec2 p) {\n    vec2 p2 = abs(p);\n    if (p2.x > p2.y) return vec2((p.x < 0.) ? -1. : 1., 0.);\n    else             return vec2(0., (p.y < 0.) ? -1. : 1.);\n}\n\nfloat scene(vec3 p) {\n    vec2 center = floor(p.xy) + .5;\n    vec2 neighbour = center + edge(p.xy - center);\n    float height = sin(center.y + center.x+iTime)*2.;\n    float width = .3;\n    float me = piston3D(p - vec3(center, 0), width, height)-.03;\n    float next = piston3D(p - vec3(neighbour, 0), width, 2.)-.03;\n    return min(me, next);\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.01);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n    vec3 cam = normalize(vec3(1.5,uv));\n    vec3 init = vec3(-7,0,0);\n    \n    float yrot = .5;\n    float zrot = iTime*.2;\n    if (iMouse.z > 0.) {\n        yrot = clamp(1.-4.*mouse.y,-0.,3.14/2.);\n        zrot = 4.*mouse.x;\n    }\n    \n    cam = erot(cam,vec3(0,1,0),yrot);\n    init = erot(init,vec3(0,1,0),yrot);\n    cam = erot(cam,vec3(0,0,1),zrot);\n    init = erot(init,vec3(0,0,1),zrot);\n    init.z += 1.;\n\n    vec3 p =init;\n    bool hit = false;\n    for (int i = 0; i < 200 && !hit; i++) {\n        float dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p += dist*cam;\n        if(distance(p,init)>50.)break;\n    }\n    vec3 n = norm(p);\n    vec3 r = reflect(cam, n);\n    float col = length(sin(r*2.)*.5+.5)/sqrt(3.);\n    col = col*.1 + pow(col, 6.);\n    fragColor = hit ? vec4(col) : vec4(0.03);\n    fragColor = sqrt(fragColor);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lcBD2.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[194, 288, 337, 337, 442], [444, 444, 495, 495, 574], [576, 576, 614, 614, 676], [678, 678, 697, 697, 843], [845, 845, 866, 866, 1188], [1190, 1190, 1209, 1209, 1324], [1326, 1326, 1383, 1383, 2346]], "test": "valid"}
{"id": "3lcBDl", "name": "Truchetted Menger", "author": "dr2", "description": "Mengerized Truchet structure (mouseable)", "tags": ["fractal", "menger", "truchet"], "likes": 20, "viewed": 258, "published": "Public API", "date": "1613644058", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Truchetted Menger\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0   // (= 0/1) optional antialiasing\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat Minv3 (vec3 p);\nfloat SmoothMax (float a, float b, float r);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashfv2 (vec2 p);\n\nvec3 ltDir;\nvec2 gId, cMid;\nfloat tCur, dstFar, hgSize, cDir;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\n// Blended from \"Menger Helix\" and \"Truchet Passages\"\n\nfloat MengDf (vec3 p)\n{\n  vec3 b;\n  float sclFac, r, r0, a, s;\n  const float nIt = 3.;\n  sclFac = 2.4;\n  r0 = 0.6 * 18. / pi;\n  p /= (0.5 / r0);\n  b = (sclFac - 1.) * vec3 (1., 1.125, 0.625);\n  r = length (p.xz);\n  a = (r > 0.) ? atan (p.z, - p.x) / (2. * pi) : 0.;\n  p.x = mod (18. * a + 1., 2.) - 1.;\n  p.z = r - r0;\n  s = 1.;\n  for (float n = 0.; n < nIt; n ++) {\n    p = abs (p);\n    p.xy = (p.x > p.y) ? p.xy : p.yx;\n    p.xz = (p.x > p.z) ? p.xz : p.zx;\n    p.yz = (p.y > p.z) ? p.yz : p.zy;\n    p = sclFac * p - b;\n    p.z += b.z * step (p.z + 0.5 * b.z, 0.);\n    s *= sclFac;\n  }\n  return (0.5 / r0) * PrRoundBoxDf (p, vec3 (1.) - 0.1, 0.1) / s;\n}\n\nfloat ObjDf (vec3 p)\n{\n  p.xz -= cMid;\n  p /= hgSize;\n  p.xz = Rot2D (p.xz, cDir * pi / 6.);\n  p.xz = Rot2D (p.xz, 2. * pi * floor (3. * atan (p.z, - p.x) / (2. * pi) + 0.5) / 3.);\n  p.x += 1.;\n  p.xz = Rot2D (p.xz, mod (0.2 * cDir * tCur + pi / 3., 2. * pi / 3.) - pi / 3.);\n  return MengDf (p);\n}\n\nvoid SetTrConf ()\n{\n  cMid = HexToPix (gId * hgSize);\n  cDir = 2. * step (Hashfv2 (gId), 0.5) - 1.;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s, eps;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  eps = 0.0005;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2])) / hgSize;\n  pM = HexToPix (PixToHex (ro.xz / hgSize));\n  hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n  s = Minv3 (hv);\n  gIdP = vec2 (-999.);\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ro + dHit * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetTrConf ();\n    }\n    d = ObjDf (p);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n      hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n      s = Minv3 (hv);\n    }\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.002, -0.002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 gIdP;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  gIdP = vec2 (-999.);\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    p = ro + d * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetTrConf ();\n    }\n    h = ObjDf (p);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += clamp (h, 0.02, 0.5);\n    if (sh < 0.05 ) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec3 BgCol (vec3 rd)\n{\n  float t, gd, b;\n  t = 2. * tCur;\n  b = dot (vec2 (atan (rd.x, rd.z), 0.5 * pi - acos (rd.y)), vec2 (2., sin (rd.x)));\n  gd = clamp (sin (5. * b + t), 0., 1.) * clamp (sin (3.5 * b - t), 0., 1.) +\n     clamp (sin (21. * b - t), 0., 1.) * clamp (sin (17. * b + t), 0., 1.);\n  return mix (vec3 (0.25, 0.5, 1.), vec3 (0., 0.3, 0.4), 0.5 * (1. - rd.y)) *\n     (0.65 + 0.35 * rd.y) * (1. + 0.2 * gd);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float dstObj, sh;\n  dstObj = ObjRay (ro, rd);\n  col = BgCol (rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    sh = ObjSShadow (ro + 0.01 * vn, ltDir);\n    col = mix (col, vec3 (0.3, 0.9, 0.5) * (0.3 + 0.7 * sh * max (dot (vn, ltDir), 0.)),\n       exp (min (0., 1. - 8. * dstObj / dstFar)));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvec2 TrkPath (float t)\n{\n  vec2 r;\n  float tt;\n  tt = mod (t, 4.);\n  if (tt < 1.) r = mix (vec2 (sqrt3/2., -0.5), vec2 (sqrt3/2., 0.5), tt);\n  else if (tt < 2.) r = mix (vec2 (sqrt3/2., 0.5), vec2 (0., 1.), tt - 1.);\n  else if (tt < 3.) r = mix (vec2 (0., 1.), vec2 (0., 2.), tt - 2.);\n  else r = mix (vec2 (0., 2.), vec2 (sqrt3/2., 2.5), tt - 3.);\n  r += vec2 (0.001, 3. * floor (t / 4.));\n  return r * hgSize;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvv, p1, p2, vd;\n  float el, az, zmFac, asp, sr, vel;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  hgSize = 2.;\n  vel = 0.1;\n  p1 = TrkPath (vel * tCur + 0.3);\n  p2 = TrkPath (vel * tCur - 0.3);\n  ro.xz = 0.5 * (p1 + p2);\n  ro.x += 0.2;\n  ro.y = 4.;\n  vd = p1 - p2;\n  az = atan (vd.x, vd.y);\n  el = -0.2 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  el = clamp (el, -0.3 * pi, 0.3 * pi);\n  vuMat = StdVuMat (el, az);\n  zmFac = 4.;\n  dstFar = 40.;\n  ltDir = normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) * pi)) / zmFac;\n    rd = vuMat * normalize (vec3 ((2. * tan (0.5 * atan (uvv.x / asp))) * asp, uvv.y, 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lcBDl.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[571, 626, 649, 649, 1281], [1283, 1283, 1305, 1305, 1581], [1583, 1583, 1602, 1602, 1684], [1686, 1686, 1719, 1719, 2961], [2963, 2963, 2984, 2984, 3239], [3241, 3241, 3278, 3278, 3687], [3689, 3689, 3711, 3711, 4110], [4112, 4112, 4147, 4147, 4521], [4523, 4523, 4547, 4547, 4936], [4938, 4938, 4994, 4994, 6250], [6252, 6252, 6298, 6298, 6345], [6347, 6347, 6371, 6371, 6601], [6603, 6603, 6627, 6627, 6687], [6689, 6689, 6711, 6711, 6749], [6751, 6751, 6796, 6796, 6899], [6901, 6901, 6946, 6946, 6984], [6986, 6986, 7022, 7022, 7228], [7230, 7230, 7260, 7260, 7373], [7407, 7407, 7431, 7431, 7491]], "test": "error"}
{"id": "3lcBz2", "name": "Raymarching Fork - Soft Shadows", "author": "Vasky", "description": "Soft shadows were added\nOriginal shader: https://www.shadertoy.com/view/WsByzK", "tags": ["raymarchingheightmapplanedepth"], "likes": 2, "viewed": 99, "published": "Public", "date": "1613041960", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// @author ciphered <https://ciphrd.com>\n// @license MIT\n//\n// -----------\n//\n// This shader was made to be working with a vertical plane, parallel to the view screen,\n// passing by (0;0;0). This constraint allows for great optimizations, because this shader \n// is intended to be working along texture manipulations to play with the surface.\n//\n// 2 parallel planes are defined in the space, in front of the camera, with a gap between\n// them corresponding to the DEPTH parameter. For each ray casted from the camera, we first\n// find the intersection between the ray and the first plane. From there, we start marching\n// along the ray and sample the height map at each step to find if whether we're in the\n// volume or not. Once we reach a point within the volume, we can find the point that belongs\n// to the surface and light it accordingly by computing the height map gradient.\n//\n// This is basically a fancy 3d texture renderer\n//\n// If you change the input texture, adjust the DEPTH accordingly\n//\n// Keep in mind that the textures do not represent to height of the elements within, only\n// the default one works correctly for this example\n//\n//\n// LIMITATIONS\n//\n// I coudln't find a way to get soft shadows, if you do feel free to make me know in the comments\n// This version does not provide a COLOR MAP, however it's pretty easy to color the surface using a\n// color map, just copy the getHeightMapValue function to sample from a color map instead of a depthmap\n//\n//\n// ## Soft shadows were added by Vasky ##\n\n\n#define PI 3.14159265359\n#define MAX_ITERATIONS 200\n\n// needs to be adujested to match the input texture\n#define DEPTH 0.6\n\n// the step size for the ray marching\n#define PRECISION 0.006\n\n// the lower this is, the more precise the normals get (too much precision results in the\n// apparition of normal artifacts\n#define EPSILON 0.002\n\n//shading algorithm (1 - hard shadows, 2 (or any other number) - soft shadows)\n#define VAR 2\n\n\n// returns the intersection point between the ray and the hightest point on the plane\nvec3 boundsSDF (vec3 ro, vec3 rd, float h) {\n    // the z length of the target vector\n    float dz = ro.z - h;\n    float t = dz / rd.z;\n    return vec3(\n    \tro.x - rd.x * t,\n        ro.y - rd.y * t,\n        ro.z - rd.z * t\n    );\n}\n\n// returns the height map value of any point in space\n// this is done by projecting the point on the vertical plane\nfloat getHeightMapValue (vec3 p) {\n    // yes this is a projection\n    vec2 tuv = p.xy;\n    tuv.x+= iTime * .1;\n    tuv = fract(tuv - .5);\n    \n    vec3 hm = texture(iChannel0, tuv).rgb;\n    \n    return .9 * (hm.r+hm.g+hm.b)/3. + 0.1;\n}\n\nvec3 calcNormal (vec3 p) {\n\tfloat hx1 = getHeightMapValue(vec3(p.x - EPSILON, p.y, 0.0)) * DEPTH;   \n    float hx2 = getHeightMapValue(vec3(p.x + EPSILON, p.y, 0.0)) * DEPTH;\n    vec3 pu = normalize(vec3(2.0 * EPSILON, 0.0, hx2 - hx1));\n    \n    float hy1 = getHeightMapValue(vec3(p.x, p.y, 0.0)) * DEPTH;\n    float hy2 = getHeightMapValue(vec3(p.x, p.y + EPSILON, 0.0)) * DEPTH;\n    vec3 pv = normalize(vec3(0.0, EPSILON, hy2 - hy1));\n    \n    return cross(pu, pv);\n}\n\nvec3 calcLight( in vec3 pos , in vec3 lightp, in vec3 lightc, in vec3 camdir, float spec)\n{    \n\tvec3 normal = calcNormal(pos);\n    vec3 lightdir = normalize(pos - lightp);\n    float cosa = pow(0.5+0.5*dot(normal, -lightdir), 3.0);\n    float cosr = max(dot(-camdir, reflect(lightdir, normal)), 0.0);\n    \n    vec3 ambiant = vec3(0.1);\n    vec3 diffuse = vec3(0.5 * cosa);\n    vec3 phong = vec3(0.1 * pow(cosr, spec)) * .4;\n    \n    return lightc * (ambiant + diffuse + phong);\n}\n\nvec4 raymarching (vec3 p, vec3 dir) {\n    vec3 prev = p;\n    vec3 curr = p;\n    float lastD = p.z;\n    float hmap = 0.;\n    float df = 0.;\n    \n    for (int i = 0; i < MAX_ITERATIONS; i++) {\n    \tprev = curr;\n        curr = prev + dir * PRECISION;\n        \n        if (curr.z < 0.0) {\n        \treturn vec4(0, 0, 1, 0);    \n        }\n        \n        hmap = getHeightMapValue(curr);\n        // distance to the displaced surface\n        float df = curr.z - hmap * DEPTH;\n        \n        // if we have an intersection\n        if (df < 0.0) {\n        \t// linear interpolation to find more precise df\n            float t = lastD / (abs(df)+lastD);\n            vec3 pi = prev + t * (curr - prev);\n            float h = getHeightMapValue(pi);\n            return vec4(pi, h);\n        } else {\n         \tlastD = df;\n        }\n    }\n    \n    //return vec4(0, 0, 1, 0);\n}\n\n// computes a sharp shadow for a given point p of the surface\nfloat shadow (vec3 p, vec3 lpos) {\n    vec3 dir = normalize(lpos - p);\n    vec3 curr = p;\n    float hmap;\n      \n    if (VAR==1)\n    {\n        //hard shadows\n        for (int i = 0; i < MAX_ITERATIONS; i++) \n        {\n            curr+= dir * PRECISION;\n\n            if (curr.z < 0.0) \n            {\n                return 0.0;\n            }\n\n            hmap = getHeightMapValue(curr);\n\n            // distance to the displaced surface\n            float df = curr.z - hmap * DEPTH;\n\n            if (df < 0.0) \n            {\n                return 1.0;\n            }\n        }\n    }\n    else\n    {\n        //Soft shadows\n        //the idea was taken from shader by Inigo Quilez: https://www.shadertoy.com/view/MdX3Rr\n        //And from his article about soft shadow: https://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\n        float sh = 1.0;\n        \n        //detail level\n        float t = 0.0005;\n        \n        for (int i=0;i<400; i++)\n        {\n            vec3 pos = p + t*lpos; \n            hmap = getHeightMapValue(pos);\n            float h = pos.z-DEPTH*hmap;\n            float softness = 0.2;\n            sh = min(sh, softness*h/t);\n            //t += t*h; //standart solution\n            t += clamp(h,0.0,0.0001); //works a little bit better with extreme light angles\n            \n        }\n        return clamp( sh, 0.0, 1.0 );\n    }\n    \n    \n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - .5;\n    uv.x*= iResolution.x/iResolution.y;\n    \n    float camZ = 1.2;// + cos(iTime*.1) * .1;\n    \n    vec3 ro = vec3(0.0, 0.0, camZ);\n    vec3 cw = normalize(vec3(0.0, 0.0, 0.0) - ro);\n    vec3 cu = normalize(cross(cw, vec3(0.0, 1.0, 0.0)));\n    vec3 cv = normalize(cross(cu, cw));\n    vec3 rd = mat3(cu, cv, cw) * normalize(vec3(uv, 1.0));\n    \n    vec4 col = vec4(0, 0, 0, 1);\n    \n    // the intersection to the highest plane\n    vec3 inter = boundsSDF(ro, rd, DEPTH);\n    \n    // the raymarching\n    vec4 rm = raymarching(inter.xyz, rd);\n    \n    if (rm.w > 999.0) {\n        fragColor = vec4(0);\n        return;\n    }\n    \n    vec3 normal = calcNormal(rm.xyz);\n    \n    vec3 lpos = vec3(cos(iTime)*20., sin(iTime)*20., 7.0);\n    //vec3 lpos = vec3(4.0, 4.0, 2.0);\n    \n    col.rgb = calcLight(rm.xyz , lpos, vec3(1.0, 1.0, 1.0), rd, 0.5);\n    \n    // we get the shadow\n    float shad = shadow(rm.xyz, lpos);\n    if (VAR==1)\n    {\n       col.rgb*= 0.5 + .5 * (1. - shad);\n    }\n    else\n    {\n        float diff = 0.2;\n        col.rgb *= vec3(diff + (1.0-diff) * (shad));\n    }\n    \n    //col.rgb = normal;\n   \n    fragColor = vec4(col.rgb, 1.0);\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lcBz2.jpg", "access": "shaders20k", "license": "mit", "functions": [[1953, 2039, 2083, 2124, 2271], [2273, 2389, 2423, 2455, 2625], [2627, 2627, 2653, 2653, 3095], [3097, 3097, 3188, 3188, 3575], [3577, 3577, 3614, 3614, 4438], [4440, 4502, 4536, 4536, 5875], [5877, 5877, 5934, 5984, 7179]], "test": "error"}
{"id": "3lcBzH", "name": "abyss in your eye ", "author": "YitingLiu", "description": "Making an eye using fbm", "tags": ["noise", "mix", "fbm", "eye", "color", "random", "galaxy", "smoothstep", "frequency", "amplitude", "similarity", "octaves"], "likes": 2, "viewed": 221, "published": "Public API", "date": "1612193541", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// followed the tutorial here https://youtu.be/emjuqqyq_qc\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n// for fbm, increase f, decrease amplitude \n/****\nfloat fbm(vec2 p){\n    float f=0.;\n    f+= 0.5000*noise(p); p*=2.02;\n    f+=0.2500*noise(p); p*=2.03;\n    f+=0.1250*noise(p); p*2.01;\n    f+=0.0625*noise(p); p*=2.04;\n    f/= 0.9375;\n    return f; \n\n}\n***/\n\n// code from https://thebookofshaders.com/13/\n#define OCTAVES 4\n\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x*=iResolution.x/iResolution.y;\n    vec2 p = -1.+2.*uv;\n    \n    p.x-=0.75;\n    float f = fbm(2.*p);\n    \n    float r = sqrt(dot(p,p));\n    float a = atan(p.y,p.x);\n    vec3 col = vec3(1.);\n    \n    float ss = 0.5+0.5*sin(iTime);\n    float anim = 1.+0.5*ss*clamp(1.-r,0.,1.);;\n    r*=anim;\n    \n    if(r<0.8){\n    \n    col = vec3(0.,0.,0.8);\n    \n    float f=fbm(p);\n    col = mix(col, vec3(0.2,0.5,0.4),f);\n   \n    \n    a+=0.08*fbm(32.*p);\n    \n    f=fbm(vec2(5.*r,20.*a));\n    col= mix(col, vec3(1.),f);\n    \n    f= smoothstep (0.2,.8,fbm(vec2(4.*r,a*18.)));\n    col *=0.5-f;\n    \n    f=1. - smoothstep(0.2,clamp(r,0.,0.5),r);\n    col*=1.-0.5*f;\n    \n    f=1.-smoothstep(0.2,0.5,r);\n    col += mix(col, vec3(sin(iTime),0.6,0.2),f);\n\n    \n    f=1.-smoothstep(0.2,0.25,r);\n    col*=1.-f;\n     \n    //adding reflections to the eye  \n    f = 1.-smoothstep(0.,0.5,length(p- vec2(0.3,0.3)*rotate2d(3.14*iTime*0.3) ));\n    col +=vec3(sin(iTime),0.9,0.5)*f*0.6;\n    \n    f=smoothstep(0.6,0.8,r);\n    col = mix(col, vec3(0.9),r);\n     \n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lcBzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 60, 87, 87, 194], [196, 196, 224, 224, 310], [312, 312, 338, 338, 718], [977, 1042, 1066, 1088, 1342], [1345, 1345, 1402, 1402, 2518]], "test": "valid"}
{"id": "3lcfR8", "name": "Ellipse - gradient 2D", "author": "iq", "description": "Signed distance and gradient to an ellipse. Faster than central differences or automatic differentiation/dual numbers most probably.", "tags": ["2d", "distancefield", "sdf", "gradient", "distance", "ellipse"], "likes": 9, "viewed": 322, "published": "Public API", "date": "1612186680", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and gradient to an ellipse. Probably\n// faster than central differences or automatic\n// differentiation/dual numbers.\n//\n// It uses 4 iterations of Newton's root solver, but could need more for\n// very eccentric ellipses (see line 46). For an analytic solver see\n// https://www.shadertoy.com/view/4sS3zz\n\n// List of other 2D distances+gradients:\n// https://iquilezles.org/www/articles/distgradfunctions2d/distgradfunctions2d.htm\n//\n// Circle:             https://www.shadertoy.com/view/WltSDj\n// Pie:                https://www.shadertoy.com/view/3tGXRc\n// Arc:                https://www.shadertoy.com/view/WtGXRc\n// Isosceles Triangle: https://www.shadertoy.com/view/3dyfDd\n// Triangle:           https://www.shadertoy.com/view/tlVyWh\n// Box:                https://www.shadertoy.com/view/wlcXD2\n// Quad:               https://www.shadertoy.com/view/WtVcD1\n// Cross:              https://www.shadertoy.com/view/WtdXWj\n// Segment:            https://www.shadertoy.com/view/WtdSDj\n// Hexagon:            https://www.shadertoy.com/view/WtySRc\n// Vesica:             https://www.shadertoy.com/view/3lGXRc\n// Ellipse:            https://www.shadertoy.com/view/3lcfR8\n// Smooth-Minimum:     https://www.shadertoy.com/view/tdGBDt\n\n// .x = f(p)\n// .y = ∂f(p)/∂x\n// .z = ∂f(p)/∂y\n// .yz = ∇f(p) with ‖∇f(p)‖ = 1\nvec3 sdgEllipse( vec2 p, in vec2 ab )\n{\n    // symmetry\n    vec2 sp = sign(p);\n\tp = abs( p );\n    \n    // determine in/out and initial value\n    bool s = dot(p/ab,p/ab)>1.0;\n\tfloat w = atan(p.y*ab.x, p.x*ab.y);\n    if(!s) w=(ab.x*(p.x-ab.x)<ab.y*(p.y-ab.y))? 1.570796327 : 0.0;\n    \n    // Newton root solver\n    for( int i=0; i<4; i++ )\n    {\n        vec2 cs = vec2(cos(w),sin(w));\n        vec2 u = ab*vec2( cs.x,cs.y);\n        vec2 v = ab*vec2(-cs.y,cs.x);\n        w = w + dot(p-u,v)/(dot(p-u,u)+dot(v,v));\n    }\n    vec2  q = ab*vec2(cos(w),sin(w));\n\n    // compute distance and gradient (everything above\n    // could probably be replaced by something better)\n    float d = length(p-q);\n    return vec3( d, sp*(p-q)/d ) * (s?1.0:-1.0);\n}\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n        // animation\n        vec2 ab = 0.7 + vec2(0.4,0.2)*cos(iTime*0.52+vec2(1,2));\n\n        // sdf(p) and gradient(sdf(p))\n        vec3  dg = sdgEllipse(p,ab);\n        float d = dg.x;\n        vec2  g = dg.yz;\n\n        // central differenes based gradient, for comparison\n        //g = vec2(dFdx(d),dFdy(d))/(2.0/iResolution.y);\n\n        // coloring\n        vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n        col *= 1.0 + vec3(0.5*g,0.0);\n      //col = vec3(0.5+0.5*g,1.0);\n        col *= 1.0 - 0.5*exp(-16.0*abs(d));\n        col *= 0.9 + 0.1*cos(150.0*d);\n        col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n        \n        // draw gradient discontinuty\n        if( sin(3.1415927*iTime)>0.0 )\n        {\n            float f2 = ab.x*ab.x - ab.y*ab.y;\n            if( ab.x>ab.y )\n            {\n                float foc = f2/ab.x;\n                p.x -= clamp(p.x,-foc,foc);\n            }\n            else\n            {\n                float foc = -f2/ab.y;\n                p.y -= clamp(p.y,-foc,foc);\n            }\n            d = length(p);\n            col = mix( col, vec3(1.0), 1.0-smoothstep(0.005,0.010,abs(d)) );\n        }\n    \n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lcfR8.jpg", "access": "shaders20k", "license": "mit", "functions": [[2323, 2418, 2457, 2473, 3159], [3175, 3175, 3232, 3232, 4879]], "test": "valid"}
{"id": "3lcfRX", "name": "Fractal 24_gaz", "author": "gaz", "description": "3d", "tags": ["fractal"], "likes": 5, "viewed": 151, "published": "Public", "date": "1613122572", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)cos(h*6.3+vec3(0,23,21))*.5+.5\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 r=iResolution,p;  \n    for(float i=0.,g,e,s,a;\n        ++i<99.;\n        (e<.001)?O.xyz+=mix(r/r,H(log(s)*.15),.5)*1.5/i:p\n    )\n    {\n        p=g*vec3((C-.5*r.xy)/r.y,1);\n        p.z-=2.5;\n        p=R(p,vec3(0,1,0),iTime*.2);\n        p.y-=a=sin(iTime*.1)*16.;\n        s=3.;\n        for(int j=0;j++<8;)\n            s*=e=3.8/clamp(dot(p,p),max(0.,sign(a))*.2,2.),\n            p=abs(p)*e-vec3(1,15,1);\n        g+=e=length(cross(p,vec3(1,1,-1)*.577))/s;\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lcfRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 102, 138, 138, 620]], "test": "valid"}
{"id": "3ldBzM", "name": "Moiré 3b", "author": "FabriceNeyret2", "description": "Shadows of 2 identical parallel plates with hexa-tiled holes. Slight perspective cause moiré.\nHere, the 2 plates are rotated by pi/2.\nRéférence:\n[img]https://img.srgcdn.com/e/w:750//UlJBQm5VN2xnbnBnU1N3WTBWR2sucG5n.jpg[/img]", "tags": ["aliasing", "interference", "moir", "reproduction"], "likes": 6, "viewed": 186, "published": "Public API", "date": "1612432479", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://shadertoy.com/view/WltBzM\n// adapted from https://shadertoy.com/view/ttd3D7\n\n#define D   length( mod( U += T/2. , T ) - R )               //\n#define P   clamp( 1.- ( min( D, D ) -.8*R.y )/5. ,0.,1.)    // draw an hexa tiling of disks\n\nvoid mainImage(out vec4 O, vec2 U) {\n    U *= 3.;\n    vec2 R = iResolution.yy/8., T = vec2( 2, 3.5 )*R;\n    O += P -O;\n\n    U = 1.1*U.yx + 10.*iTime;\n    O *= P;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ldBzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 257, 293, 293, 420]], "test": "valid"}
{"id": "3ldBzs", "name": "random pixel sprites - golf (583", "author": "FabriceNeyret2", "description": "golfing  [url]https://shadertoy.com/view/WltBzs[/url],\nshort version of \"random pixel sprites\" by stb. [url]https://shadertoy.com/view/3ttfzl[/url]\n", "tags": ["procedural", "pixel", "random", "sprite", "sprites"], "likes": 12, "viewed": 227, "published": "Public API", "date": "1613291665", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Golfing https://shadertoy.com/view/WltBzs ( 866 chars )\n// Short version of \"random pixel sprites\" by stb. https://shadertoy.com/view/3ttfzl ( 2371 chars )\n\n\n#define H(p)     fract( sin(p) * 4e3 )\n#define h(p)     H( (p+floor(q)) * mat2x3(R,K,.7*R) )\n#define N(p,z) ( q = vec3(p,z) / .1,                     \\\n                 f = fract(q), f *= f*(3.-f-f),          \\\n                 mix( mix( h()     , h(o.xyy), f.x ),    \\\n                      mix( h(o.yxy), h(o.xxy), f.x ),    \\\n                      f.y ) - .5                         \\\n               )\n\nvoid mainImage( out vec4 O, vec2 p ) {\n    vec2 R = iResolution.xy, K = R.yx, o = vec2(1,0);\n    vec3 q,f;\n\tp = ( p - iMouse.xy ) / 72.;   \n    p.y += .5 * iTime; \n    \n    float z = 54. * H( dot( ceil(p), R ) );\n    \n    p = fract( ceil(p*24.) / 24. ) - .5; \n    p.x = abs(p.x); \n\n#define M(p)   length( p - .3* N(p,z) ) > .27 \n    bool m = M(p), b = m;\n    for ( int k=0; k<9; k++ )\n        b = b && M( p - vec2(k%3-1,k/3-1) / 24. );    \n        \n     O.rgb =  b||m  ? vec3( b )\n                    : pow( H(  vec3( ceil( p/.213  - 2.17*N(p,0) - z ), z )\n                             * mat3(R,K,.7*K,.7*R,.9*R)), \n                           vec3(.75) ); \n}\n\n\n\n\n\n\n/* // --- 596 chars\n\n#define R        iResolution.xy\n#define H(p)     fract( sin(p) * 4e3 )\n#define h(p)     H( (p+i) * mat2x3(R.xyyx,.7*R) )\n#define N(p,z) ( q = vec3(p,z) / .1,                     \\\n                 i = floor(q),                           \\\n                 f = fract(q), f *= f*(3.-f-f),          \\\n                 mix( mix( h()     , h(o.xyy), f.x ),    \\\n                      mix( h(o.yxy), h(o.xxy), f.x ),    \\\n                      f.y ) - .5                         \\\n               )\n\nvoid mainImage( out vec4 O, vec2 p ) {\n    vec3 q,i,f, o = vec3(1,0,0);\n\tp = 5.* ( p - iMouse.xy ) / R.y;   \n    p.y += .5 * iTime; \n    \n    float z = 54. * H( dot( ceil(p), R ) );\n    \n    p = fract( ceil(p*24.) / 24. ) - .5; \n    p.x = abs(p.x); \n\n#define M(p)   length( p - .3* N(p,z) ) > .27 \n    bool m = M(p), b = m;\n    for ( int k=0; k<9; k++ )\n        b = b && M( p - vec2(k%3-1,k/3-1) / 24. );    \n        \n     O.rgb =  b||m  ? vec3( b )\n                    : pow( H(  vec3( ceil( p/.213  - 2.17*N(p,0) - z ), z )\n                             * mat3(R.xyyx,.7*R.yxxy,.9*R)), \n                           vec3(.75) ); \n}\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ldBzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 567, 605, 605, 1225]], "test": "error"}
{"id": "3ldfD7", "name": "Worley blue noise", "author": "FabriceNeyret2", "description": "Blue noise by mutually-repulsing Worley dots.\n- Red: Worley dots    \n- Blue: average of 8 neighbor dots\n- Green: mouse.x interpolate between\nIndeed, 100% average (=blue) is too ordered for blue noise !  Or better (and cheaper) on triangle grid ?\nTry #41.", "tags": ["worley", "sampling", "bluenoise"], "likes": 8, "viewed": 241, "published": "Public API", "date": "1612885808", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define hash(p)  fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n#define hash2(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n\n\n\nvec4 Worley0(vec2 U) {\n    vec2 I = floor(U), P,I1,N;\n    \n    float m = 1e5, l;\n    int k,c;\n    for ( k=0; k<9; k++) {\n        I1 = I + vec2(k%3,k/3)-1.;   \n        P = I1 + hash2(I1)-.5;                      // random dot in the current neighbor cell\n        l = dot(P-U,P-U);\n        if (l<m)  m=l, c=k, N=P;\n      }\n    return vec4(m, N, k);                           // closest point, its coordinates, its local id\n}\n\n\nvec4 Worley(vec2 U, float a) {\n    vec2 I = floor(U), P,P0, N, I1,I2;\n    \n    float m = 1e5, l;\n    int k,c;\n    for ( k=0; k<9; k++) {\n        I1 = I + vec2(k%3,k/3)-1.;\n#if 0                                               // classical Worley:\n        P = I1 + hash2(I1)-.5;                      // random dot in the current neighbor cell\n#else\n        P-=P;                                       // averaged Worley:\n        for (int j=0; j<9; j += j==3?2:1 ) {\n            I2 = I1+vec2(j%3,j/3)-1.;\n            P += I2 +hash2(I2)-.5;                  // dot = average neighbor random dots\n        }\n        P /= 8.;\n#  if 1    \n        P0 = I1 + hash2(I1)-.5;\n        P = mix( P0, P,  a);                        // interpolates between both.\n     // P = P0  + a*( P - P0 );                     // neighbors apply force a ( equivalent !)\n     // P = P0  + a*( P - P0 )*smoothstep(1.,0.,length(P-P0)); // force decreasing with distance.\n#  endif\n#endif\n        l = dot(P-U,P-U);\n        if (l<m)  m=l, c=k, N=P;\n      }\n    return vec4(m, N, k);                           // closest point, its coordinates, its local id\n}\n\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 15.* ( u - .5*R ) / R.y;\n         \n    float  a = iMouse.x==0. ? .5+.5*sin(iTime) : iMouse.x/iResolution.x,\n          d0 = sqrt( Worley(U,0.).x ),              // classical Worley\n          d2 = sqrt( Worley(U,1.).x ),              // average of 8-neighborh\n          d1 = sqrt( Worley(U,a ).x );              // interpolation between both\n\n    O = smoothstep(22./R.y,0., vec4( d0,d1,d2,0 )-.15 ) *vec4(.5,1,1,1);\n  //O = 5. - vec4( d0,d1,d2,0 ) *R.y/15. ;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ldfD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[154, 154, 176, 176, 576], [579, 579, 609, 609, 1700], [1703, 1703, 1741, 1741, 2242]], "test": "valid"}
{"id": "3ldfRS", "name": "2D Panini Projection Visualizer", "author": "public_int_i", "description": "Visualization showing panini projection top compared to planar projection bottom. Click to change field of view.\ntop = 180 deg fov,\nbottom = 90 deg fov.", "tags": ["visualization", "projection", "panini"], "likes": 6, "viewed": 253, "published": "Public API", "date": "1612974732", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*Top is painini projection, red shows the projection cylinder.\nBottom is planar projection, red shows the projection plane.\n\nClick to change field of view.\ntop = 180 deg fov,\nbottom = 90 deg fov.\n\nCredit to TinyTexel for the Panini projection code https://www.shadertoy.com/view/Wt3fzB*/\n\n\n//more sample lines = slower\n#define SAMPLES 10\n\n\n#define PI 3.141592653589793\n\n\n//create color interpolation value from distance field\n#define dlv(d) clamp(1.-(d)*iResolution.y*.5,0.,1.)\n\n//blend color a to b based on b.w*c\n#define blend(a,b,c) mix(a,b,(b).w*(c))\n\n\n//draw 2d line from a to b at uv\nvec4 line(vec4 bgCol, vec2 uv, vec2 a, vec2 b, float sz, vec4 lineCol) {\n    vec2 d = uv-a, c = b-a;\n    return blend(bgCol, lineCol,\n        dlv(length(d-c*clamp(dot(d,c)/dot(c,c),0.,1.))-sz));\n}\n\n\nfloat twave(float x) {\n    return 1.-abs(fract(x)-.5)*2.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\n    //2d drawing(back to front)\n    vec4 col = vec2(.05,1).xxxy;//grey background\n    \n    //middle divider line\n    col = blend(col,vec2(.5,1).xxxy, dlv(abs(uv.y)-.01));\n    \n    //projection field of view angle in degrees\n    float FIELD_OF_VIEW = 100.+twave(iTime*.2)*79.;\n    if (iMouse.z > 0.) FIELD_OF_VIEW = 90.+90.*iMouse.y/iResolution.y;\n    \n    //panini projection\n    float fovRad = FIELD_OF_VIEW*.5*PI/180.;\n    const vec2 paniniOrigin = vec2(0.,.2);\n    \n    for (float x = -1.; x <= 1.+1e-6; x += 2./float(SAMPLES-1)) {\n        //ray direction\n        float d = 1., d2 = d*d;\n        float h = x;\n        float v = 0.;\n        {\n            float fo = PI*.5 - fovRad;\n            if (fo == 0.) fo = 1e-6;\n\n            float f = cos(fo)/sin(fo) * 2.0;\n            float f2 = f*f;\n\n            float b = (sqrt(max(0.0, pow(d+d2,2.)*(f2+f2*f2))) - (d*f+f)) / (d2+d2*f2-1.0);\n            h *= b*(.25+.75*fovRad/(PI*.5));\n        }\n        \n\n        float h2 = h*h;\n\n        float k = h2/pow(d+1.0,2.);\n        float k2 = k*k;\n\n        float discr = max(0.0, k2*d2 - (k+1.0)*(k*d2-1.0));\n\n        float cosPhi = (-k*d+sqrt(discr))/(k+1.0);\n        float S = (d+1.0)/(d+cosPhi);\n        float tanTheta = v/S;\n\n        float sinPhi = sqrt(max(0.0, 1.0-pow(cosPhi,2.)));\n        if(x < 0.0) sinPhi *= -1.0;\n\n        float s = inversesqrt(1.0+pow(tanTheta,2.));\n\n        vec2 rd = normalize(vec2(sinPhi, cosPhi));\n    \n        float rx = x*fovRad;\n        //rd = vec2(sin(rx),cos(rx));\n        \n        //draw ray line\n        col = line(col,uv, paniniOrigin,paniniOrigin+rd*.5, .01, vec4(1.,.6,.2,1));\n    }\n    \n    //draw panini projection cylinder\n    vec2 cylPos = uv-paniniOrigin;\n    col = blend(col,vec4(1,0,0,1),\n        dlv(max((abs(atan(cylPos.x,cylPos.y))-fovRad),abs(length(cylPos)-.5)-.015)));    \n    \n    \n    //standard planar projection\n    float fovTangent = tan((90.-.5*FIELD_OF_VIEW)*PI/180.);\n    const vec2 planarOrigin = vec2(0.,-.8);\n    vec2 pleft, pright;\n    \n    for (float x = -1.; x <= 1.+1e-6; x += 2./float(SAMPLES-1)) {\n        vec2 rd = normalize(vec2(x,fovTangent));//ray direction\n        \n        //map to plane\n        float pdst = (planarOrigin.y-(-.3))/-rd.y;\n        if (x <= -1.) pleft = planarOrigin+rd*pdst;\n        else pright = planarOrigin+rd*pdst;\n        \n        //draw ray line\n        col = line(col,uv, planarOrigin,planarOrigin+rd*pdst, .01, vec4(1.,.6,.2,1));\n    }\n    \n    //draw planar projection plane\n    col = line(col,uv, pleft,pright, .015, vec4(1,0,0,1));\n         \n        \n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ldfRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[558, 591, 663, 663, 787], [790, 790, 812, 812, 849], [852, 852, 909, 909, 3538]], "test": "valid"}
{"id": "3ldfWf", "name": "Failed lissajous experiment xdd", "author": "pema99", "description": "newton raphson is apparently pretty shit for this", "tags": ["lissajous"], "likes": 1, "viewed": 74, "published": "Public", "date": "1613601446", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 lissajous(float t, float a, float b, float omega, float delta)\n{\n    t = clamp(t, 0.0, 6.28);\n    return vec2(a*sin(omega*t+delta), b*sin(t));\n}\n\nfloat lissajousDist(vec2 p, float a, float b, float omega, float delta)\n{\n    float minSqrMag = 10.0;\n    \n    for (float j = 0.0; j < 6.28; j += 6.28/16.0)\n    {\n        float t = j;\n        \n        float sqrMag;\n        for (int i = 0; i < 8; i++)\n        {\n            vec2 curve = lissajous(t, a, b, omega, delta);\n            sqrMag = pow(curve.x - p.x, 2.0) + pow(curve.y - p.y, 2.0) - 0.01;\n            float deriv = 2.0*(a*sin(omega*t+delta)-p.x)*a*omega*cos(omega*t+delta)+2.0*(b*sin(t)-p.y)*b*cos(t);\n            t = t - (sqrMag / deriv); \n        }\n        \n        minSqrMag = min(sqrMag, minSqrMag);\n    }\n    \n    return sqrt(minSqrMag);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy - 0.5) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n    uv *= 1.33;\n    \n    float a = 1.0;\n    float b = 1.0;\n    float omega = (sin(iTime*0.3)*0.5+0.5)*3.14*2.0;//m.x*3.14*2.0;\n    float delta = (cos(iTime*0.3)*0.5+0.5)*3.14/2.0;//3.14/2.0*m.y;\n    \n    float c1 = 0.0;\n    for (float i = 0.0; i < 6.28; i += 0.01)\n    {\n        vec2 d = lissajous(i, a, b, omega, delta);\n        c1 = max(c1, smoothstep(0.02, 0.0, distance(d, uv)));\n    }\n    \n    float c2 = lissajousDist(uv, a, b, omega, delta);\n\n    fragColor = vec4(c1, c2, 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ldfWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 69, 69, 149], [151, 151, 224, 224, 805], [807, 807, 864, 864, 1494]], "test": "valid"}
{"id": "3ldfWM", "name": "🧩 Puzzles 📷", "author": "rmmcal", "description": "🌳", "tags": ["2d"], "likes": 6, "viewed": 89, "published": "Public", "date": "1613297478", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/////////////////////////////////////////////////////////////\n////       ...  🧩 Puzzles 📷 ...             ////\n/////////////////////////////////////////////////////////////\n// Brasil/Amazonas/Manaus\n// Created by Rodrigo Cal (twitter: @rmmcal)🧙🧞\n// - Started: 2021/02 - Published: 2021/02\n// - https://www.shadertoy.com/view/3ldfWM\n/////////////////////////////////////////////////////////////\n// -----------------------------------------------------------\n//\n//  🧩 Puzzles  📷\n//  \n//\tPass: _Peças_ \n//  \n//      ... @rmmcal 2021/02 \n//  \n// -----------------------------------------------------------\n/////////////////////////////////////////////////////////////\n//\n\nfloat time1(float s) {\n    return fract((iTime*s+.4));\n}\n\nfloat hash2(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(3.97531, 7.2357))) * 135.54321);\n}\n\nfloat shash2(vec2 p)\n{\n\treturn (hash2(p)*2.-1.);\n}\n\nvec2 vshash2(vec2 p){\n    return vec2(shash2(p+.12357),shash2(p));\n}\n\nvoid drawImage (inout vec4 c, vec2 p, vec2 t, vec2 l, vec2 s, float a )\n{\n    mat2 rot = mat2(cos(a),sin(a),-sin(a),cos(a));\n    vec2 tr = t+(s-l)/2.;\n    vec2 pt = (p - tr)*rot + tr - t;\n    vec2 pl = pt;\n    vec2 sl = s-l;\n    if (step(vec2(0.),pl)*step(pl, sl) == vec2(1.0)){\n        c =  texture(iChannel0, pt + l);\n        vec2 cc = smoothstep(vec2(0.002),vec2(0.00),pl);\n        cc += smoothstep(sl-vec2(0.002),pl,sl);\n        float b = (cc.x+cc.y);\n        c = mix(c,vec4(.3),b*.5);\n    } \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    const float s = 10.;\n    const float sx = s;\n    const float sy = s;\n\n    float t = iTime;\n    float tf = fract(t*.2);\n\n    vec4 col = texture(iChannel1, uv)*.3;\n    \n    float tcb = pow(abs(time1(.02)*2.0-1.0),1.5)*2.;\n    float tc = pow(abs(time1(.02)*2.0-1.0),3.)*2.;\n\n    for (int i = 0; i < int(sx); i++)\n    for (int j = 0; j < int(sy); j++) \n    {\n        vec2 pv = vec2(i,j);\n        vec2 pf = pv/vec2(sx,sy);\n        vec2 ps = 1./vec2(sx,sy);\n        \n        vec2 pm = tc*vshash2(pv)*5.;\n        float a = tcb*(pm.x+pm.y*pm.y)*35.;\n        \n        drawImage(col, uv, pf+pm, pf, ps+pf, a);\n     }\n\n    col = mix(col, vec4(0.),length(uv-.5)-.2);\n    fragColor = col;\n    \n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}, {"id": "XtXSz7", "previewfilepath": "https://soundcloud.com/instrumental-1/first-love-joe-hisaishi", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/instrumental-1/first-love-joe-hisaishi", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ldfWM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 687, 709, 709, 743], [745, 745, 766, 766, 831], [833, 833, 855, 855, 883], [885, 885, 906, 906, 953], [955, 955, 1028, 1028, 1453], [1456, 1456, 1513, 1513, 2240]], "test": "error"}
{"id": "3ldfWr", "name": "Moiré 3d - rev", "author": "FabriceNeyret2", "description": "Shadows of 2 identical parallel plates with hexa-tiled disks. \nHere, the second plates is distorted (show alone on left).\n( you might try a slight perspective effect by changing the coef line 16. )", "tags": ["aliasing", "interference", "moir", "reproduction", "glasspatterns"], "likes": 2, "viewed": 195, "published": "Public API", "date": "1612538616", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// reverse pattern of https://shadertoy.com/view/wl3fWr\n\n#define D   length( mod( U += T/2. , T ) - k )           //\n#define P   clamp( ( min( D, D ) -.6*k.y )/10. ,0.,1.)   // draw an hexa tiling of disks\n\nvoid mainImage(out vec4 O, vec2 u) {\n    O-=O;\n    vec2 R = iResolution.xy,\n        U = 6.*(u-R/2.),\n        V =   U // * mat2(cos(.01 +vec4(0,11,33,0))) \n            + 30.* sin( U*mat2(1,-.7,.4,-1)/300. + iTime ),\n  \n        k = vec2(360)/8., T = vec2( 2, 3.5 )*k;\n    O += U.x>0. ? P : 1.;\n\n    U = 1.0*V; // try 1.1\n    O *= P;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ldfWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 207, 243, 243, 539]], "test": "valid"}
{"id": "3lGBDh", "name": "Pretty Flower", "author": "lmno", "description": "Just wow.\n", "tags": ["lmnorose"], "likes": 2, "viewed": 38, "published": "Public", "date": "1614222175", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License CC0: Voronot Rose\n//  Based upon: https://https://www.shadertoy.com/view/wtVBRw\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          -5.1401592654\n#define TAU         (0.5*PI)\n#define L2(x)       dot(x, x)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.15+0.15*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat pabs(float a, float k) {\n  return pmax(a, -a, k);\n}\n\nfloat height(vec2 p) {\n  p *= 0.4;\n  float d = length(p);\n  p *= ROT(TIME*0.1-1.5*d) ;\n  float c = 1E6;\n  float x = pow(d, 0.1);\n  float y = atan(p.x, p.y) / TAU;\n  \n  for (float i = 0.; i < 3.; ++i) {\n    float v = length(fract(vec2(x - TIME*(i)*.005123, fract(y + i*.125)*.5)*20.)*2.-1.);\n    c = pmin(c, v, 0.125);\n  }\n\n  return -0.0125*pabs(tanh_approx(5.5*d-80.*c*c*d*d*(.55-d))-0.25*d, 0.25);\n}\n\nvec3 normal(vec2 p) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(4.0/RESOLUTION.y, 0);\n  \n  vec3 n;\n  n.x = height(p + e.xy) - height(p - e.xy);\n  n.y = -1.0*e.x;\n  n.z = height(p + e.yx) - height(p - e.yx);\n  \n  return normalize(n);\n}\n\nvec3 color(vec2 p) {\n  const float s = 1.0;\n  const vec3 lp1 = vec3(1.0, 1.25, 1.0)*vec3(s, 1.0, s);\n  const vec3 lp2 = vec3(-1.0, 1.25, 1.0)*vec3(s, 1.0, s);\n\n  float h = height(p);\n  vec3  n = normal(p);\n\n  vec3 ro = vec3(0.0, -10.0, 0.0);\n  vec3 pp = vec3(p.x, 0.0, p.y);\n\n  vec3 po = vec3(p.x, h, p.y);\n  vec3 rd = normalize(ro - po);\n\n  vec3 ld1 = normalize(lp1 - po);\n  vec3 ld2 = normalize(lp2 - po);\n  \n  float diff1 = max(dot(n, ld1), 0.0);\n  float diff2 = max(dot(n, ld2), 0.0);\n\n  vec3  rn    = n;\n  vec3  ref   = reflect(rd, rn);\n  float ref1  = max(dot(ref, ld1), 0.0);\n  float ref2  = max(dot(ref, ld2), 0.0);\n\n  vec3 lcol1 = vec3(1.5, 1.5, 2.0).xzy;\n  vec3 lcol2 = vec3(2.0, 1.5, 0.75).zyx;\n  vec3 lpow1 = 0.15*lcol1/L2(ld1);\n  vec3 lpow2 = 0.5*lcol2/L2(ld2);\n  vec3 dm = vec3(1.0)*tanh(-h*10.0+0.125);\n  vec3 col = vec3(0.0);\n  col += dm*diff1*diff1*lpow1;\n  col += dm*diff2*diff2*lpow2;\n  vec3 rm = vec3(1.0)*mix(0.25, 1.0, tanh_approx(-h*1000.0));\n  col += rm*pow(ref1, 10.0)*lcol1;\n  col += rm*pow(ref2, 10.0)*lcol2;\n\n  return col;\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.5);\n  col = pow(col, 1.0/vec3(2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.55+0.55*pow(19.5*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = color(p);\n\n  col = 4.0*col;\n  // Workaround for some environments that seems to lack a vec3 version of tanh\n  col = vec3(tanh(col.x), tanh(col.y), tanh(col.z));\n  col = 0.99 -col;\n  \n  col = postProcess(col, q);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lGBDh.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[0, 301, 329, 349, 425], [427, 427, 466, 466, 553], [555, 555, 594, 594, 623], [625, 625, 655, 655, 682], [684, 684, 706, 706, 1084], [1086, 1086, 1107, 1107, 1314], [1316, 1316, 1336, 1336, 2368], [2370, 2370, 2406, 2406, 2641], [2643, 2643, 2698, 2698, 3055]], "test": "valid"}
{"id": "3lGBzw", "name": "Raiden Ray Marching", "author": "rvanbronkhorst", "description": "Learning Ray marching", "tags": ["raymarching"], "likes": 0, "viewed": 50, "published": "Public", "date": "1614141149", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define T_MAX 20.0\n#define T_INTERSECT 0.001\n\nfloat sphereSDF( in vec3 p, in vec3 c, in float rad)\n{\n    return length(p - c) - rad;\n}\n\nfloat cylinderSDF( in vec3 p, in float rad ) {\n    return length(p.xy) - rad;\n}\n\nfloat map( in vec3 p )\n{\n    float d1 = sphereSDF(p, vec3(0, 0, -3.0), 0.5);\n    float d2 = cylinderSDF(p, 0.45);\n    float d3 = sphereSDF(p, vec3(0, 0, -3.0), 0.25);\n    return min(d3, max(d1, -d2));\n}\n\n// https://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 estimateNormal( in vec3 p )\n{\n    vec3 epsilon = vec3(0.0001, 0., 0.);\n    // Estimate normals centered at p\n    return normalize(vec3(map(p + epsilon.xyy) - map(p - epsilon.xyy), \n                          map(p + epsilon.yxy) - map(p - epsilon.yxy),\n                          map(p + epsilon.yyx) - map(p - epsilon.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Screen coordinates [-0.5, 0.5]\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y) - 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n    \n    vec3 viewpoint = vec3(0.0, 0.0, -3.0);\n    vec3 e = vec3(1.5 * sin(iTime), 0.0, 1.5 * cos(iTime) - 3.);\n    vec3 v = vec3(0.0, 1.0, 0.0);\n    vec3 w = -normalize(viewpoint - e);\n    vec3 u = normalize(cross(v, w));\n    \n    mat4 view = mat4(\n        u, 0.0,\n        v, 0.0,\n        w, 0.0,\n        e, 1.0\n    );\n    \n    // Fragment world coordinates\n    vec3 p = (view * vec4(uv, -1., 1.)).xyz;\n    \n    // Ray marching\n    float t = 0.0;\n     \n    vec3 d = normalize(p - e);\n    vec3 position;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        \n        position = e + t * d;\n        \n        float h = map(position);\n        \n        if (h < T_INTERSECT || t > T_MAX)\n            break;\n            \n        t += h;\n        h /= 2.;\n    }\n    \n    // Color the pixel\n    vec3 ka = vec3(0.2, 0.4, 0.6);\n    float Ia = 0.15;\n    \n    vec3 kd = vec3(clamp(t/2., 0., 1.), clamp(1.-t/2., 0., 1.), clamp(1.-t/2., 0., 1.));\n    float Id = 1.0;\n    \n    vec3 color;\n    if (t <= T_MAX) {\n    \n        vec3 n = estimateNormal(position);\n        \n        color = ka * Ia + kd * Id * clamp(dot(n, normalize(vec3(1, 1, 1))), 0., 1.);\n    } else {\n        color = ka;\n    }\n    \n    // Gamma correction (from iq)\n    color = pow(color, vec3(0.45));\n    \n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lGBzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 122, 122, 156], [158, 158, 204, 204, 237], [239, 239, 263, 263, 441], [443, 508, 542, 542, 839], [841, 841, 898, 936, 2358]], "test": "valid"}
{"id": "3lGfDw", "name": "Kaleidoscopic fractal", "author": "jarble", "description": "This simple fractal formula makes a kaleidoscope pattern.", "tags": ["fractal", "mechanical", "robotic"], "likes": 2, "viewed": 146, "published": "Public API", "date": "1614394607", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 fract1(vec2 a,vec2 random,float scale1){\n    return (abs(fract(a*scale1+100.0*random)-.5));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;\n    float t;\n    float t2=iTime/20.0;\n    float t3 = 1.5;\n    for(int c=0;c<3;c++){\n\t    vec2 uv = (fragCoord*5.0-iResolution.xy)/iResolution.y/10.0*t3;\n        uv += vec2(iTime/2.0,iTime/3.0)/8.0*t3;\n        t = iTime+float(c)/10.;\n        //float scale = 4.0;\n        float scale1 = 2.5;\n        //uv = fract(uv/scale);\n        \n        //vec3 random = vec3(sin(t2/13.0),sin(t2/17.0),sin(t2/19.0))/2.0+.5;\n        vec3 random = hash31(floor((iTime+uv.x)/5.0));\n        //vec3 random = hash31(21.0);\n        \n        for(int i=0;i<6;i++)\n        {\n            uv = fract1(uv/scale1,random.xy,scale1)+fract1(uv/scale1,random.xy,scale1);\n            //scale *= 1.0+fract((uv.x+uv.y)/50.0)/1000.0;\n            uv=fract(uv/(scale1)+(uv.yx));\n            uv /= scale1;\n\n            uv=uv.yx+col.x;\n            uv.y *= scale1;\n            uv = uv.yx;\n            //col = fract(col.yzx);\n        }\n     col[c] = fract((uv.x)-(uv.y));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lGfDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 111, 133, 179, 312], [314, 314, 359, 359, 412], [414, 414, 471, 471, 1492]], "test": "valid"}
{"id": "3lGfWD", "name": "Alien Waters", "author": "lmno", "description": "a sea of unknown glowy non-newtonian GOOP", "tags": ["sea", "alien"], "likes": 1, "viewed": 31, "published": "Public", "date": "1614313861", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define CONTOUR_SPACING 50.0\n#define CONTOUR_THICKNESS 0.005\n#define DELTA 0.01\n\n// Hardware derivatives don't seem to produce good contours on my computer\n//#define USE_HARDWARE_DERIVATIVES\n\n// Hue to RGB function from Fabrice's shadertoyunofficial blog:\n#define hue2rgb(hue) 2.5 + 2.5 * cos(0.3 * hue + vec3(0.0, 23.0, 21.0))\n\nfloat f(in vec2 p) {\n    p *= 3.0;\n    vec3 p3 = vec3(p, iTime);\n    return dot(sin(p3), cos(p3.zxy));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 1.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = CONTOUR_THICKNESS / iResolution.y * 5.0;\n\n    float hSpacing = 1.5 * CONTOUR_SPACING;\n    float fRes = f(uv);\n\n    #ifdef USE_HARDWARE_DERIVATIVES\n    float grad = length(fwidth(fRes)) * iResolution.y / -0.0;\n\n    #else\n    float grad = length(vec2(f(uv + vec2(DELTA, 1.0)) - f(uv - vec2(DELTA, 0.0)),\n                             f(uv + vec2(1.0, DELTA)) - f(uv - vec2(0.0, DELTA)))) / (2.0 * DELTA);\n    #endif\n\n    float contour = abs(mod(fRes + hSpacing, CONTOUR_SPACING) - hSpacing) / grad;\n\n    fragColor = vec4(hue2rgb(fRes * 0.5) - smoothstep(unit, 0.0, contour), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lGfWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[192, 329, 349, 349, 433], [435, 435, 490, 490, 1159]], "test": "valid"}
{"id": "3lGfzD", "name": "Circle Rect experience", "author": "colinb", "description": "Shader avec des cercles et des rectangles réagissant au son", "tags": ["circlerect"], "likes": 3, "viewed": 66, "published": "Public", "date": "1613944531", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n#define PI 3.1415926535897932384626433832795\n#define TAU 6.283185307179586476925286766559\n\nfloat circle(vec2 st) {\n    return length(st-.5)*2.;\n}\n\nfloat rect(vec2 st, vec2 s) {\n    st = st*2.-1.;\n    return max( abs(st.x/s.x),\n                abs(st.y/s.y) );\n}\n\nfloat stroke(float x, float size, float w) {\n    float d = step(size, x+w*.5) - step(size, x-w*.5);\n    return clamp(d, 0., 1.);\n}\n\nfloat fill(float x, float size) {\n    return 1.-step(size, x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // the sound texture is 512x2\n    int tx = int(uv.x*512.0);\n    \n\t// first row is frequency data (48Khz/4 in 512 texels, meaning 23 Hz per texel)\n\tfloat fft  = texelFetch( iChannel0, ivec2(tx,0), 0 ).x; \n    \n    // second row is the sound wave, one texel is one mono sample\n    float wave = texelFetch( iChannel0, ivec2(tx,1), 0 ).x;\n    \n    float col = 0.;\n    \n    for (int i = 0 ; i < 20 ; ++i) {\n        col += stroke(circle(uv),0.1*float(i)*cos(0.4*iTime+float(i)*0.2)+fft*0.01*float(i),0.04*cos(5.0*iTime)+0.021);\n    }\n    col = clamp(col, 0., 1.);\n    \n    vec2 s = vec2(1.);\n    for (int i = 0 ; i < 20 ; ++i) {\n        float c = stroke(rect(uv,s),0.1*float(i)*cos(0.5*iTime+float(i)*0.22)+fft*0.01*float(i), 0.04*cos(4.0*iTime)+0.027);\n        if(col>0.5)\n            col = 1.-c;\n        else\n            col = c;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,col,col,1.0);\n}", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lGfzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 93, 116, 116, 147], [149, 149, 178, 178, 263], [265, 265, 309, 309, 395], [397, 397, 430, 430, 461], [463, 463, 520, 570, 1517]], "test": "error"}
{"id": "3lKBWR", "name": "Rounds waw psych", "author": "Nashoute", "description": "Little test to see what I can do with the tuto of GreenChicken", "tags": ["raymarching"], "likes": 1, "viewed": 61, "published": "Public", "date": "1614174661", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//thank you Iq https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n//and thank you GreenChicken for your tutorials https://www.shadertoy.com/user/GreenChicken\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat hash21(vec2 p){ //fonction pour donner un aspect aléatoire\n    p = fract(p*vec2(234.34,435.345));\n    p += dot(p,p+35.14);\n    return fract(p.x*p.y);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nfloat sdBox( vec3 p, vec3 b){\n    vec3 q = abs(p) -b;\n    return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nvec3 opRepet(vec3 pos,vec3 bound){\n    return mod(pos+0.5*bound,bound)-0.5*bound;\n}\n\nfloat opCheapBend( vec3 p )\n{\n    const float k = 1.0; // or some other amount\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return sdBox(q , vec3(1.) );\n}\n\nfloat map(vec3 pos){\n    \n    pos = opRepet(pos, vec3(4.0,4.0,4.0));\n    \n\n    float world = sdRoundBox(pos,vec3(0.05+sin(iTime+4.8)/8.+0.5,0.05+sin(iTime)/8.+0.3,0.05+sin(iTime)/8.+0.4),01.);\n    //world = opSmoothUnion(opCheapBend(pos) ,world, 0.1);\n    return world;\n}\n\nvec3 GetNormal (vec3 p)\n{\n    float c = map(p);\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n        map(p + e.xyy), \n        map(p + e.yxy), \n        map(p + e.yyx)) - c);\n}\n\nfloat CastRay(vec3 ro, vec3 rd){\n    float c = 0.0; //si y'a contact, on aura la distance\n    \n    for(int i = 0; i<128; i++){\n    \n        float ray = map(ro + rd*c);\n        \n        if(ray < (0.0001*c)){\n            return float(i)/32.;\n        }\n        \n        c+=ray;\n    }\n    \n    return -1.0;\n}\n\nvec3 render(vec3 ro,vec3 rd){ //rayon origin, rayon direction\n    \n    float contact = CastRay(ro,rd);     \n    vec3 nor = GetNormal(ro + rd * contact);\n    \n    \n    \n    vec3 col = vec3(0.);\n    \n    if(contact == -1.){\n        col = palette(iTime,vec3(0.8,0.4,0.32),vec3(0.4,0.4,0.32),vec3(0.7,0.8,0.32),vec3(0.4,0.4,0.32));\n    }else{\n        //col = vec3(1.-contact);\n        col = nor;\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float fov = 2.; //fieldOfView\n    vec2 uv = 2.*fragCoord/iResolution.xy-1.;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    //Camera\n    vec3 cameraPos = vec3(0.-iTime*2.,2,5.-iTime*4.);\n    vec3 cameraTarget = vec3(0.-iTime*2.,0.+sin(iTime),0.-iTime*4.);\n    \n    //view Direction/ RayD Direction\n    vec3 forward = normalize(cameraTarget-cameraPos);\n    vec3 right = normalize(cross(vec3(0.,-1.,0.),forward));\n    vec3 up = normalize(cross(right,forward));\n    vec3 viewDir = normalize(uv.x * right+uv.y*up+forward*fov);\n    viewDir.xy*=rot(iTime);\n\n    \n    vec3 col = vec3(uv.x,uv.y,0.0);\n    \n    col = render(cameraPos,viewDir);\n\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKBWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 232, 304, 304, 347], [349, 349, 370, 414, 507], [509, 509, 561, 561, 660], [663, 663, 692, 692, 781], [783, 783, 828, 828, 919], [921, 921, 955, 955, 1004], [1006, 1006, 1035, 1035, 1233], [1235, 1235, 1255, 1255, 1506], [1508, 1508, 1533, 1533, 1695], [1697, 1697, 1729, 1729, 2001], [2003, 2003, 2032, 2064, 2418], [2420, 2420, 2477, 2477, 3155]], "test": "valid"}
{"id": "3lKfR1", "name": "Starfield Experiment", "author": "YitingLiu", "description": "playing around with the grid and layers ", "tags": ["grid", "rotate", "star", "starfield", "infinite", "artofthecode"], "likes": 9, "viewed": 317, "published": "Public API", "date": "1613881410", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// followed tutorials https://youtu.be/rvDo9LvfoVE\n//https://youtu.be/dhuigO4A7RY\n\n#define NUM_LAYERS 5.\n\nmat2 Rot(float a){\n    float s=sin(a), c=cos(a);\n    return mat2(c,-s,s,c);\n\n}\n\nfloat Star(vec2 uv, float flare){\n    float d = length(uv);//distance to the center \n    float m = .03/d;//more light like than smoothstep(.1,.05,d);\n    \n    float rays= max(0.,1.-abs(uv.x*uv.y*1000.)); \n    m +=rays*flare;\n    \n    uv*=Rot(3.1415/4.);\n    rays= max(0.,1.-abs(uv.x*uv.y*1000.));\n    m+=rays*.5*flare;\n    m*=smoothstep(.5,.2,d);\n    \n    return m;\n\n\n}\n\nfloat Hash21(vec2 p){\n    p = fract(p*vec2(123.34,456.21));\n    p += dot(p, p+45.32);\n    return fract(p.x*p.y);\n    \n\n}\n\nvec3 StarLayer(vec2 uv) {\n\tvec3 col = vec3(0);\n\t\n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    \n    // should add <=\n    for(int y=-1;y<=1;y++) {\n    \tfor(int x=-1;x<=1;x++) {\n            vec2 offs = vec2(x, y);\n            \n    \t\tfloat n = Hash21(id+offs); // random between 0 and 1\n            float size = fract(n*345.32);\n            \n    \t\tfloat star = Star(gv-offs-vec2(n, fract(n*34.))+.5, smoothstep(.6, 1., size)*.6);\n            \n            vec3 color = sin(vec3(.5, .1, .9)*fract(n*2345.2)*123.2)*.5+.5;\n            color = color*vec3(1,.2,.8+size)+vec3(.2, .2, .1)*2.;\n            \n            star *= sin(iTime*2.+n*6.2831)*.5+1.;\n            col += star*size*color;\n        }\n    }\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 M = (iMouse.xy-.5*iResolution.xy)/iResolution.y;\n    \n    float t = iTime*.03;\n   \n\n    uv*=Rot(t);\n    uv.x+=max(t*.0001,1.);\n    uv.y-=max(t*.0001,.5);\n\n    vec3 col = vec3(0);\n    \n    for (float i =0.; i <1.;i+=1./NUM_LAYERS){\n\n        float depth = fract(i+t);\n        float scale = mix (50.,2.,depth);\n        float fade = depth*smoothstep(1., .9, depth);\n        col += StarLayer(uv*scale+i*4532.-M)*fade;\n\n    }\n    \n        col = pow(col, vec3(.85));\t// gamma correction\n \n    \n    //if(gv.x>.48|| gv.y>.48) col.r=1.;//coloring the grid\n  \n    //col+=Hash21(id);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKfR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 106, 124, 124, 184], [186, 186, 219, 219, 555], [557, 557, 578, 578, 677], [679, 679, 704, 704, 1404], [1405, 1405, 1462, 1462, 2140]], "test": "valid"}
{"id": "3lKfRh", "name": "lissajous electric boogaloo", "author": "pema99", "description": "local bezier approximation https://www.geogebra.org/classic/sx9g2rsw", "tags": ["lissajous"], "likes": 1, "viewed": 39, "published": "Public", "date": "1613866518", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// from iq: https://www.shadertoy.com/view/MlKcDD\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat cross2( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\nfloat udBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if( h>=0.0 ) \n    {   // 1 root\n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d+(c+b*t)*t);\n    }\n    else \n    {   // 3 roots\n        float z = sqrt(-p);\n        float v = acos(q/(p*z*2.0))/3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0 );\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n    }\n    \n    return res; // edit: no need for sqrt here, it can be added after marching\n}\n\n// My code starts here\n#define LINES 0 // Use line segments instead of bezier\n#define DOTS 0 // Show dots evaluated along the curve\n#define CUTOFF 1 // Makes the DE easier to visualize\n\nvec2 lissajous(float t, float a, float b, float omega, float delta)\n{\n    t = clamp(t, 0.0, 6.28);\n    return vec2(a*sin(omega*t+delta), b*sin(t));\n}\n\nfloat lissajousDist(vec2 p, float a, float b, float omega, float delta)\n{\n    float minDist = 1000.0;\n    \n    float iters = 24.0;\n    float inc = 6.28 / iters;\n    float incHalf = inc / 2.0;\n    \n    for (float t = 0.0; t < 6.28; t += inc)\n    {\n        vec2 pa = lissajous(t, a, b, omega, delta);\n        vec2 pc = lissajous(t + inc, a, b, omega, delta);\n        \n        vec2 mid = lissajous(t + incHalf, a, b, omega, delta);\n        vec2 pb = vec2(2.0*mid.x-(pa.x/2.0)-(pc.x/2.0), 2.0*mid.y-(pa.y/2.0)-(pc.y/2.0));\n        \n        #if LINES\n        pb = pa;\n        #endif\n        \n        minDist = min(minDist, udBezier(p, pa, pb, pc));\n    }\n    \n    return sqrt(minDist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy - 0.5) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n    uv *= 1.33;\n    \n    float a = 1.0;\n    float b = 1.0;\n    float omega = (sin(iTime*0.3)*0.5+0.5)*3.14*2.0;//m.x*3.14*2.0;\n    float delta = (cos(iTime*0.3)*0.5+0.5)*3.14/2.0;//3.14/2.0*m.y;\n    \n    float c1 = 0.0;\n    for (float i = 0.0; i < 6.28; i += 0.01)\n    {\n        vec2 d = lissajous(i, a, b, omega, delta);\n        c1 = max(c1, smoothstep(0.02, 0.0, distance(d, uv)));\n    }\n    #if !DOTS\n    c1 = 0.0;\n    #endif\n    \n    float c2 = lissajousDist(uv, a, b, omega, delta);\n    #if CUTOFF\n    if (c2 <= 0.01) c2 = 1.0;\n    #endif\n\n    fragColor = vec4(c1, c2, 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKfRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 50, 75, 75, 94], [95, 95, 133, 133, 161], [162, 162, 226, 226, 1251], [1253, 1439, 1508, 1508, 1588], [1590, 1590, 1663, 1663, 2272], [2274, 2274, 2331, 2331, 3056]], "test": "valid"}
{"id": "3lKfWw", "name": "Random procedural textures 2", "author": "jarble", "description": "This shader makes procedural textures with many different colors and patterns.", "tags": ["procedural", "texture", "random"], "likes": 2, "viewed": 134, "published": "Public API", "date": "1614462354", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nvec2 fract1(vec2 a,vec2 random,float scale1){\n    return (abs(fract(a*scale1+100.0*random)-.5));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;\n    float t;\n    float t2=iTime/20.0;\n    float t3 = 8.0;\n    for(int c=0;c<3;c++){\n\t    vec2 uv = (fragCoord*5.0-iResolution.xy)/iResolution.y/10.0*t3;\n        uv += vec2(iTime/2.0,iTime/3.0)/8.0*t3;\n        float scale = 3.0;\n        \n        \n        //vec3 random = vec3(sin(t2/13.0),sin(t2/17.0),sin(t2/19.0))/2.0+.5;\n        vec3 random = hash31(floor((iTime+uv.x)/5.0))*2.0;\n        float scale1 = .5+(random.z)/2.0;\n        //random.xy = random.z;\n        //vec3 random = hash31(10.0);\n        scale = scale1 * 3.0;\n        \n        for(int i=0;i<3;i++)\n        {\n            \n            random = (hash33(random)-vec3(.5))*2.0;\n            //scale1 *= 1.+random.z/1.7/2.0;\n            uv.y /= scale1;\n            uv=fract(uv/(scale1)+(uv.yx/(scale1))/scale);\n            uv = fract1(uv/scale1,random.yx,scale1)*scale1;\n            uv /= scale;\n            uv=uv.yx+col.yx;\n            uv.y *= -scale+uv.x;\n        }\n     col[c] = fract((uv.x)-(uv.y));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKfWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 111, 133, 179, 312], [314, 425, 447, 447, 572], [574, 574, 619, 619, 672], [674, 674, 731, 731, 1785]], "test": "valid"}
{"id": "3ltBD8", "name": "Treasure", "author": "butadiene", "description": "treasure", "tags": ["fractal", "rarmarching"], "likes": 19, "viewed": 537, "published": "Public API", "date": "1612639160", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Copyright (c) 2021 Butadiene\n//Released under the MIT license\n//https://opensource.org/licenses/mit-license.php\n\nfloat PI = acos(-1.);\n\nvec2 pmod(vec2 p,float n){\n  float np = 2.*PI/n;\n  float r = atan(p.x,p.y)-0.5*np;\n  r = mod(r,np)-0.5*np;\n  return length(p.xy)*vec2(cos(r),sin(r));\n}\nmat2 rot(float r){\n    vec2 s = vec2(cos(r),sin(r));\n    return mat2(s.x,s.y,-s.y,s.x);\n}\nfloat cube(vec3 p,vec3 s){\n    vec3 q = abs(p);\n    vec3 m = max(s-q,0.);\n    return length(max(q-s,0.))-min(min(m.x,m.y),m.z);\n}\nvec4 tetcol(vec3 p,vec3 offset,float scale,vec3 col){\n    vec4 z = vec4(p,1.);\n    for(int i = 0;i<12;i++){\n        if(z.x+z.y<0.0)z.xy = -z.yx,col.z+=1.;\n        if(z.x+z.z<0.0)z.xz = -z.zx,col.y+=1.;\n        if(z.z+z.y<0.0)z.zy = -z.yz,col.x+=1.;       \n        z *= scale;\n        z.xyz += offset*(1.0-scale);\n    }\n    return vec4(col,(cube(z.xyz,vec3(1.5)))/z.w);\n}\n\nfloat bpm = 128.;\nvec4 dist(vec3 p,float t){\n    p.xy *= rot(PI);\n    p.xz = pmod(p.xz,24.);\n    p.x -= 5.1;\n    p.xy *= rot(0.3);\n    p.xz *= rot(0.25*PI);\n    p.yz *= rot(PI*0.5);\n\n    float s =1.;\n    p.z = abs(p.z)-3.;\n    p = abs(p)-s*8.;\n    p = abs(p)-s*4.;\n    p = abs(p)-s*2.;\n    p = abs(p)-s*1.;\n\n    vec4 sd = tetcol(p,vec3(1),1.8,vec3(0.));\n    float d= sd.w;\n    vec3 col = 1.-0.1*sd.xyz-0.3;\n    col *= exp(-2.5*d)*2.;\n    return vec4(col,d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (uv-0.5)*2.;\n    p.y *= iResolution.y/iResolution.x;\n   \n    float rsa =0.1+mod(iTime*0.2,32.);\n    float rkt = iTime*0.+0.5*PI+1.05;\n    vec3 of = vec3(0,0,0);\n    vec3 ro = of+vec3(rsa*cos(rkt),-1.2,rsa*sin(rkt));\n    vec3 ta = of+vec3(0,-1.3,0);\n    vec3 cdir = normalize(ta-ro);\n    vec3 side = cross(cdir,vec3(0,1,0));\n    vec3 up = cross(side,cdir);\n    vec3 rd = normalize(p.x*side+p.y*up+0.4*cdir);\n  \n    float d,t= 0.;\n    vec3 ac = vec3(0.);\n    float ep = 0.0001;\n    for(int i = 0;i<66;i++){\n        vec4 rsd = dist(ro+rd*t,t);\n        d = rsd.w;\n        t += d;\n        ac += rsd.xyz;\n        if(d<ep) break;\n    }\n\n    vec3 col = vec3(0.04*ac);\n \n    if(col.r<0.1&&(col.b<0.1&&col.g<0.1)) col =vec3(0.);\n\tfragColor = vec4(col, 1.0 );\n\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltBD8.jpg", "access": "shaders20k", "license": "mit", "functions": [[0, 138, 164, 164, 289], [290, 290, 308, 308, 379], [380, 380, 406, 406, 509], [510, 510, 563, 563, 880], [900, 900, 926, 926, 1341], [1343, 1343, 1400, 1400, 2205]], "test": "valid"}
{"id": "3ltBR8", "name": "Nefertiti Statue", "author": "oneshade", "description": "Another neural model.", "tags": ["3d", "raymarching", "sdf", "neuralnetwork", "siren", "statue", "nefertiti", "bust"], "likes": 3, "viewed": 85, "published": "Public", "date": "1612227943", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Nefertiti model\n\nvec3 IntersectSphere(in vec3 ro, in vec3 rd, in float r) {\n    float a = dot(rd, rd);\n    float b = dot(2.0 * ro, rd);\n    float c = dot(ro, ro) - r * r;\n\n    vec3 intersect = vec3(0.0);\n\n    float discr = b * b - 4.0 * a * c;\n    if (discr > 0.0) {\n        float root = sqrt(discr);\n        float denom = 2.0 * a;\n        float t1 =  (root - b) / denom; // 1st root\n        float t2 = -(root + b) / denom; // 2nd root\n        intersect = vec3(t1, t2, 1.0);\n    }\n\n    return intersect;\n}\n\nfloat sdNefertiti(in vec3 p) {\n    if (length(p) > 1.2) return length(p) - 1.0;\n    p = p.yxz * vec3(1.0, 1.0, -1.0);\n    vec4 f0_0=sin(p.y*vec4(3.51,-3.13,-.40,.35)+p.z*vec4(-.86,-1.62,-3.98,3.57)+p.x*vec4(3.59,5.25,-3.42,4.02)+vec4(-8.49,-10.08,8.78,-6.04));\n    vec4 f0_1=sin(p.y*vec4(-1.63,-2.98,3.49,1.58)+p.z*vec4(.52,-4.85,-1.08,1.32)+p.x*vec4(.01,1.37,4.03,3.90)+vec4(-13.95,-7.99,4.53,-5.74));\n    vec4 f0_2=sin(p.y*vec4(-3.29,-1.02,3.65,4.56)+p.z*vec4(1.07,-.72,-1.34,-1.61)+p.x*vec4(-3.36,4.21,-4.95,-4.13)+vec4(-11.44,.60,-6.32,-2.63));\n    vec4 f0_3=sin(p.y*vec4(.58,-1.38,3.34,-1.44)+p.z*vec4(.05,3.23,-2.07,3.21)+p.x*vec4(3.88,-3.73,-1.75,-3.57)+vec4(-1.33,-11.77,-1.04,6.43));\n    vec4 f1_0=sin(mat4(.22,-.86,.36,-.54,-.07,-.24,-.06,-.15,.13,-.26,-.64,.19,.10,.03,.61,-.16)*f0_0+\n        mat4(.09,-.67,.43,.06,.04,.28,-.16,.14,.16,.74,-.06,.00,.27,.35,-.53,.29)*f0_1+\n        mat4(.66,.45,.54,-.43,.28,.24,-.25,.45,-.14,.19,-.08,-.00,-.22,.04,.13,-.13)*f0_2+\n        mat4(-.46,-.57,-.45,.26,.88,1.04,-.13,-.26,-.05,-.43,-.00,-.27,-.30,-1.25,-.02,-.62)*f0_3+\n        vec4(4.81,-.98,6.28,-.74))/1.0+f0_0;\n    vec4 f1_1=sin(mat4(-.27,.42,-.36,.32,-.08,-.20,-.26,-.02,.29,.29,.20,-.02,-.20,-.35,-.30,.02)*f0_0+\n        mat4(1.66,-1.29,-.06,-.21,.05,.08,.15,-.06,.27,-.36,.28,-.34,-.15,-.54,.26,-.63)*f0_1+\n        mat4(.35,.21,-.38,-.52,-.08,-.10,.06,.66,.07,-.16,-.32,-.12,.27,-.65,-.07,-.34)*f0_2+\n        mat4(-.07,.78,.46,-.01,.54,-.32,-.94,.17,-.29,-.23,-.20,.06,-.45,-.15,.62,.10)*f0_3+\n        vec4(-1.89,1.74,-.76,-.96))/1.0+f0_1;\n    vec4 f1_2=sin(mat4(-.87,-.24,1.15,-.29,-.15,.03,.38,-.11,.08,-.11,-.86,.64,-.49,.53,.66,-.60)*f0_0+\n        mat4(-.71,-1.29,-1.90,.82,-.04,.07,-.61,-.32,.46,1.63,-1.38,1.04,-.01,-.78,.18,.13)*f0_1+\n        mat4(-.07,1.04,-1.08,1.20,-.09,.41,-.85,-.72,-.32,-.48,-.20,.62,-.18,-.37,.04,.25)*f0_2+\n        mat4(.45,.78,-.19,.47,-.52,.66,-.36,.12,.28,.78,.43,.22,.38,-1.23,-.20,-.15)*f0_3+\n        vec4(.60,1.14,-6.51,-1.79))/1.0+f0_2;\n    vec4 f1_3=sin(mat4(-.41,.70,.41,-.73,.14,.38,.27,.20,.11,.11,-.59,.07,-.18,-.25,.42,-.10)*f0_0+\n        mat4(-.28,-.63,1.12,-.41,-.34,-.43,.19,-.04,.15,-.73,-1.26,.16,.68,.39,-.15,-.22)*f0_1+\n        mat4(-.42,-.54,-.83,-.19,.04,.28,.99,.48,.13,.10,-.20,-.20,-.35,.17,-.08,-.18)*f0_2+\n        mat4(.10,.49,-.16,-.17,.48,1.18,-.31,.88,.20,.61,.04,.08,-.23,-.93,.22,-1.21)*f0_3+\n        vec4(3.90,-.94,-3.29,-1.35))/1.0+f0_3;\n    vec4 f2_0=sin(mat4(.24,-.06,.61,-.51,-.19,.21,.23,-.06,1.15,.42,-.74,.79,-.63,-.64,.25,-.38)*f1_0+\n        mat4(.70,-.21,-1.04,2.07,.36,.20,-.16,.18,-.71,-.09,-.90,-.17,.97,.82,-.08,1.25)*f1_1+\n        mat4(-.15,-.55,.15,-.33,-.27,-.03,-.02,-.11,-.31,.22,-.10,-.01,-.15,-.20,-.03,.25)*f1_2+\n        mat4(.42,.42,-.54,.36,.36,.26,.07,.09,-.54,.20,.35,-.22,-.49,-.84,-.59,.14)*f1_3+\n        vec4(6.07,-2.37,6.11,-.52))/1.4+f1_0;\n    vec4 f2_1=sin(mat4(-.62,.67,-1.20,1.23,-.16,-.56,.31,.00,1.21,.40,.54,-.50,-.89,-.76,-.26,.18)*f1_0+\n        mat4(1.84,-1.51,1.06,-2.01,-.23,-.11,-.24,-.28,.13,.16,.10,-.21,.59,-.08,.78,-1.07)*f1_1+\n        mat4(-.72,.58,-.23,.79,-.03,.32,.04,.39,-.20,.50,-.66,-.22,.20,.31,-.44,-.76)*f1_2+\n        mat4(1.10,-.44,1.30,-.81,-.31,-.63,.87,-.41,-.23,-.10,-.34,-.12,.03,.43,-.75,-1.37)*f1_3+\n        vec4(-.97,-5.92,-1.36,4.12))/1.4+f1_1;\n    vec4 f2_2=sin(mat4(.18,-.08,-1.15,.44,-.04,.34,.32,-.10,-.36,-.11,-.88,.12,.53,.39,-.17,.05)*f1_0+\n        mat4(-1.51,-.88,-1.64,-1.42,.17,.32,-.64,-.39,.35,.01,.05,.30,-.67,.28,1.26,-1.26)*f1_1+\n        mat4(.64,.74,-2.54,.82,.16,.09,-.81,.17,-.41,.80,-.17,-.11,-.56,-.00,-1.03,-.64)*f1_2+\n        mat4(-.67,.07,1.58,-1.46,-.35,.17,-.50,-.03,.28,.45,-.10,-.61,.85,-.02,.70,-1.91)*f1_3+\n        vec4(-2.05,-2.64,-6.35,.91))/1.4+f1_2;\n    vec4 f2_3=sin(mat4(-.14,.63,-.10,-.10,.03,1.54,.35,-.15,.35,-1.13,-.32,.77,-.64,.85,-.27,-.90)*f1_0+\n        mat4(-.74,2.39,-1.83,.94,.27,-.73,-.13,.18,-.65,-1.80,.31,-.33,.57,-1.26,-.17,.36)*f1_1+\n        mat4(-.57,-2.96,.40,-.89,-.09,.41,-.20,-.64,-.00,-.05,.01,.26,.05,-.13,-.33,.43)*f1_2+\n        mat4(.74,1.25,-.18,.51,-.27,-.71,.35,-.53,.24,-.45,.16,.05,.50,-.22,.36,.63)*f1_3+\n        vec4(-1.12,3.49,-2.69,-4.95))/1.4+f1_3;\n    return dot(f2_0,vec4(-.08,-.10,.13,-.16))+\n        dot(f2_1,vec4(-.10,.07,-.07,-.04))+\n        dot(f2_2,vec4(-.13,-.06,-.02,-.03))+\n        dot(f2_3,vec4(-.11,.01,-.08,-.11))+\n        -0.175;\n}\n\nvec3 getStatueNormal(in vec3 p) {\n    vec3 e = vec3(0.01, 0.0, 0.0);\n    return normalize(vec3(sdNefertiti(p + e.xyy) - sdNefertiti(p - e.xyy),\n                          sdNefertiti(p + e.yxy) - sdNefertiti(p - e.yxy),\n                          sdNefertiti(p + e.yyx) - sdNefertiti(p - e.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenCenter = 0.5 * iResolution.xy;\n\n    vec2 mouse = vec2(iTime, 0.0);\n    if (iMouse.z > 0.0) {\n        mouse = (iMouse.xy - screenCenter) / iResolution.y * 3.14;\n    }\n\n    vec2 uv = (fragCoord - screenCenter) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 2.5);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    vec3 skyColor = mix(vec3(1.0, 0.6, 0.0), vec3(1.0, 1.0, 0.8), 0.5 + 0.5 * rd.y);\n\n    vec3 bSphereIntersect = IntersectSphere(ro, rd, 1.0);\n    if (bSphereIntersect.z > 0.5) {\n        float tMin = min(bSphereIntersect.x, bSphereIntersect.y);\n        float tMax = max(bSphereIntersect.x, bSphereIntersect.y);\n\n        vec3 p;\n        bool hitModel = false;\n        float t = tMin;\n        for (int i=0; i < 100; i++) {\n            p = ro + rd * t;\n            float d = sdNefertiti(p);\n            if (d < 0.001) {\n                hitModel = true;\n                break;\n            }\n\n            if (t > tMax) {\n                break;\n            }\n\n            t += d;\n        }\n\n        if (hitModel) {\n            vec3 n = getStatueNormal(p);\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n            vec3 refr = refract(rd, n, 1.0003 / 1.5);\n\n            fragColor.rgb += vec3(0.7, 0.4, 0.0) + 0.1;\n\n            float lambertian = dot(n, l);\n            fragColor.rgb *= max(0.3, lambertian);\n\n            if (lambertian > 0.0) {\n                vec3 r = reflect(l, n);\n                float specAngle = max(0.0, dot(r, rd));\n                fragColor.rgb += max(0.0, pow(specAngle, 16.0)) / 3.0;\n            }\n        }\n\n        else {\n            fragColor.rgb += skyColor;\n        }\n    }\n\n    else {\n        fragColor.rgb += skyColor;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltBR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 20, 78, 78, 508], [510, 510, 540, 540, 4867], [4869, 4869, 4902, 4902, 5166], [5168, 5168, 5223, 5223, 7180]], "test": "valid"}
{"id": "3ltBRX", "name": "Roman temple", "author": "MatthieuJacquemet", "description": "sdf temple", "tags": ["temple", "day", "nightcycle"], "likes": 12, "viewed": 150, "published": "Public", "date": "1613167482", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Jacquemet Matthieu\n\n// Contants --------------------------------------------------------------------------------------------\nconst float PI   = 3.141592653589793238462643383279502884197169;\nconst float PI_2 = 1.570796326794896619231321691639751442098585;\n\n#define TONEMAP_LINEAR 0 \n#define TONEMAP_FILMIC 1\n#define TONEMAP_REINHARD 2\n#define TONEMAP_FILMIC_REINHARD 3\n#define TONEMAP_UNCHARTED2 4\n#define TONEMAP_ACES 5\n\n// Configuration ----------------------------------------------------------------------------------------\n\nconst int MAX_STEPS = 200; // Number of steps\nconst float EPSILON = 0.01; // Marching epsilon\nconst float FLOOR_LEVEL = -5.0; // floor height\nconst float TIME_SCALE = 0.05; // time speed\n\n#define TONEMAP_MODE TONEMAP_ACES // Tone mapping mode\n#define _DEBUG 0                  // set 1 to enable debuging\n\n\n\n#if _DEBUG\n    vec3 _debug_color;\n    bool _is_debug = false;\n    #define DEBUG(color) if (_is_debug) _debug_color = color; // use this to debug a color\n    #define CATCH_DEBUG(expr) _is_debug = true; expr ; _is_debug = false;\n#else\n    #define DEBUG(color)\n    #define CATCH_DEBUG(expr) expr // any call to DEBUG(color) in this macro will output de color\n#endif\n\n// TODO: moon shadowing\n\n// Primitive functions -----------------------------------------------------------------------------------\n\n// Hashing function\n// Returns a random number in [-1,1]\nfloat Hash(float seed)\n{\n    return fract(sin(seed)*43758.5453 );\n}\n\n// Map value from [Imin, Imax] to [Omin, Omax]\nfloat map(float value, float Imin, float Imax, float Omin, float Omax) \n{  \n  return Omin + (value - Imin) * (Omax - Omin) / (Imax - Imin);\n}\n\n// Translate point p\nvec3 Translate(vec3 pos, vec3 p) {\n\n    return p - pos;\n}\n\n// Scale point p\nvec3 Scale(vec3 scale, vec3 p) {\n\n    return vec3(p.x/scale.x, p.y/scale.y, p.z/scale.z);\n}\n\n// Rotate point p around X axis (radians)\nvec3 RotateX(float theta, vec3 p)\n{   \n    float _sin = sin(theta);\n    float _cos = cos(theta);\n\n    mat3 M = mat3(  1,     0,     0,\n                    0,  _cos, -_sin,\n                    0,  _sin,  _cos);\n    \n    return M*p;\n}\n\n// Rotate point p around Y axis (radians)\nvec3 RotateY(float theta, vec3 p)\n{   \n    float _sin = sin(theta);\n    float _cos = cos(theta);\n\n    mat3 M = mat3( _cos,    0,  -_sin,\n                    0,      1,      0,\n                   _sin,    0,   _cos);\n    \n    return M*p;\n}\n\n// Rotate point p around Z axis (radians)\nvec3 RotateZ(float theta, vec3 p)\n{   \n    float _sin = sin(theta);\n    float _cos = cos(theta);\n\n    mat3 M = mat3(  _cos,  -_sin,   0,\n                    _sin,   _cos,   0,\n                    0,      0,      1);\n\n    return M*p;\n}\n\n// Rotate point p\nvec3 Rotate(vec3 rot, vec3 p)\n{\n    p = RotateX(rot.x, p);\n    p = RotateY(rot.y, p);\n    p = RotateZ(rot.z, p);\n\n    return p;\n}\n\n\n// Create scaling matrix\nmat3 Scaling(vec3 scale) {\n\n    return mat3(1.0/scale.x,0,          0,\n                0,          1.0/scale.y,0,\n                0,          0,          1.0/scale.z);\n}\n\n// Create rotation matrix for theta angle around X axis (radians)\nmat3 RotationX(float theta)\n{   \n    float _sin = sin(theta);\n    float _cos = cos(theta);\n\n    return mat3(    1,     0,     0,\n                    0,  _cos, -_sin,\n                    0,  _sin,  _cos);\n}\n\n// Create rotation matrix for theta angle around Y axis (radians)\nmat3 RotationY(float theta)\n{   \n    float _sin = sin(theta);\n    float _cos = cos(theta);\n\n    return mat3( _cos,     0, -_sin,\n                    0,     1,     0,\n                 _sin,     0,  _cos);\n}\n\n// Create rotation matrix for theta angle around Z axis (radians)\nmat3 RotationZ(float theta)\n{   \n    float _sin = sin(theta);\n    float _cos = cos(theta);\n\n    return mat3(_cos, -_sin,  0,\n                _sin,  _cos,  0,\n                0,     0,     1);\n}\n\n// Create rotation matrix for the 3 axes (radians)\nmat3 Rotation(float x, float y, float z) \n{\n    return RotationZ(z) * RotationY(y) * RotationX(x);\n}\n\n// Create rotation matrix for the 3 axes (radians)\nmat3 Rotation(vec3 rot)\n{\n    return Rotation(rot.x, rot.y, rot.y);\n}\n\n// Create translation matrix\nmat4 Translation(vec3 trans) {\n\n    mat4 M = mat4(1.0);\n    M[3] = vec4(-trans, 1.0);\n\n    return M;\n}\n\n// Create transform matrix \nmat4 Transform(vec3 scale, vec3 rot, vec3 trans) \n{\n    return mat4(Scaling(scale) * Rotation(rot)) * Translation(trans);\n}\n\n// Transform of point p\nvec3 Transform(vec3 scale, vec3 rot, vec3 trans, vec3 p)\n{\n    p = Scale(scale, p);\n    p = Rotate(rot, p);\n    p = Translate(trans, p);\n\n    return p;\n}\n\n\nvoid Ray(in vec2 m, in vec2 p,out vec3 ro,out vec3 rd)\n{\n    // focal length\n   \tfloat le = 2.0;\n    \n    // position camera\n    ro=vec3(-40.0,0.0,0.0);\n    \n    // reset camera position\n    // shadertoy initialize mouse pos at (0,0)\n    if (m == vec2(0))\n        m = vec2(0.9, 0.51);\n    \n    m = (m*2.0 - vec2(1.0))*3.0;\n    m.y = clamp(-m.y, -PI_2 + 0.1, PI_2 - 0.1); // clamp camera y rotation\n\n    ro = RotateY(m.y, ro);\n    ro = RotateZ(m.x, ro);\n\n    vec3 ww = normalize(-ro);\n    vec3 uu = normalize( cross(ww,vec3(0.0,0.0,1.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n\trd = normalize( p.x*uu + p.y*vv + le*ww );\n}\n\n\nvec3 Cosine( in float seed, in vec3 n)\n{\n    float u = Hash( 78.233 + seed);\n    float v = Hash( 10.873 + seed);\n\n    // Method by fizzer: http://www.amietia.com/lambertnotangent.html\n    float a = 6.2831853 * v;\n    u = 2.0 * u - 1.0;\n    return normalize( n + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u) );\n}\n\n\n// SDF COMBINATION ---------------------------------------------------------------------------\n\n// Union \n// a : Field function of left sub-tree, \n// b : Field function of right sub-tree\nfloat Union(float a,float b)\n{\n    return min(a,b);\n}\n\n// difference \n// a : Field function of left sub-tree, \n// b : Field function of right sub-tree\nfloat Diff(float a,float b)\n{\n    return max(a,-b);\n}\n\n// Intersection \n// a : Field function of left sub-tree, \n// b : Field function of right sub-tree\nfloat Inter(float a, float b)\n{\n    return max(a,b);\n}\n\n\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.html\n\n// Union with smoothing\n// a : Field function of left sub-tree, \n// b : Field function of right sub-tree\nfloat SmoothUnion( float a, float b, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// Difference with smoothing\n// a : Field function of left sub-tree, \n// b : Field function of right sub-tree\nfloat SmoothDiff( float a, float b, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(a+b)/k, 0.0, 1.0 );\n    return mix( a, -b, h ) + k*h*(1.0-h); \n}\n\n// Intersection with smoothing\n// a : field function of left sub-tree, \n// b : field function of right sub-tree\nfloat SmoothInter( float a, float b, float k )\n{\n    float h = clamp( 0.5 - 0.5*(a-b)/k, 0.0, 1.0 );\n    return mix( a, b, h ) + k*h*(1.0-h);\n}\n\n// SDF Primitives --------------------------------------------------------------------------\n\nfloat Plane(vec3 point, vec3 nor, vec3 pos) {\n\n    return dot(point - pos, nor);\n}\n\nfloat Sphere(vec3 point, vec3 pos, float radius) {\n\n    return length(point - pos) - radius;\n}\n\nfloat Circle(vec3 point, float radius) {\n\n    vec2 p;\n    p.x = length(point.xy) - radius;\n    p.y = point.z;\n\n    return length(p);\n}\n\nfloat Box(vec3 point, vec3 box) {\n\n  vec3 q = abs(point) - box;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nfloat Torus(vec3 point, float radius, float r) {\n    \n    return Circle(point, radius) - r; \n}\n\nfloat Segment(vec3 point, vec3 a, vec3 b) {\n\n    vec3 ba = b-a;\n    vec3 pa = point-a;\n    float t = dot(pa, ba) / dot(ba, ba);\n    vec3 c = ba*clamp(t, 0.0, 1.0);\n    \n    return length(pa - c);\n}\n\n\nfloat Capsule(vec3 point, vec3 a, vec3 b, float radius) {\n\n    return Segment(point, a, b) - radius;\n}\n\nfloat Cylinder(vec3 point, vec3 a, vec3 b, float radius) {\n\n    float v = Diff( Capsule(point, a, b, radius),\n                    Plane(point, normalize(a-b), b));\n    \n    v = Diff(v, Plane(point, normalize(b-a), a));\n    return v;\n}\n\n\n// Returns a smooth noise in [-1,1] \n// x : Point \nfloat Noise(in vec3 x) {\n\n    vec3 p = floor(x); \n    vec3 f = fract(x); \n\n    p*=1.0;\n    f*=1.0;\n\n    f = f*f*(3.-2.*f); \n    float n = p.x+p.y*157.+113.*p.z;\n\n    float nn = mix(\n        mix(\n            mix(Hash(n+0.),   Hash(n+1.0),f.x), \n            mix(Hash(n+157.0),Hash(n+158.0),f.x),f.y\n        ), \n        mix(\n            mix(Hash(n+113.0),Hash(n+114.0),f.x), \n            mix(Hash(n+270.0),Hash(n+271.0),f.x),f.y\n        ),f.z);\n\n    return -1.0 + 2.0*nn; \n}\n\n\n// Create a column\n// len : Column's length\n// radius : Column's radius\nfloat Column(vec3 p, float len, float radius) {\n\n    const float base_height = 0.2;\n    const float top_height = 0.2;\n    const float deco0_radius = 0.3;\n    const float deco1_radius = 0.2;\n    \n    float half_base_height = base_height*0.5;\n    float half_top_height = top_height*0.5;\n\n    vec3 base_size = vec3(radius + 0.2, radius + 0.3, half_base_height);\n    vec3 top_size = vec3(radius + 0.2, radius + 0.2, half_top_height);\n\n    vec3 base_p = vec3(p.x, p.y, p.z - half_base_height - .15);\n    vec3 top_p = vec3(p.x, p.y, p.z - (len-half_top_height));\n\n    vec3 deco0_pos = vec3(0,0,base_height+deco0_radius+0.5);\n    vec3 deco1_pos = deco0_pos + vec3(0,0,deco0_radius*0.9+deco1_radius);\n\n    vec3 col_start = vec3(0,0,base_height);\n    vec3 col_end = vec3(0,0,len-top_height);\n\n    // column's base block\n    float base = Box(base_p, base_size) - 0.1;\n    float v = base;\n\n\n    float offset = pow(abs(p.z-len*0.45)*0.2,2.0)*-0.15 + 0.15;\n    float cut = pow(abs(fract(p.z*0.4 + 0.33)-0.5), 15.0)*2000.0;\n\n    float column = Cylinder(p, col_start, col_end, radius+offset-cut+0.05);\n\n    v = SmoothUnion(column, base, 0.7);\n\n\n    // loower column decoration\n    float base0_deco = Torus(p-deco0_pos, radius, deco0_radius);\n    float base1_deco = Torus(p-deco1_pos, radius, deco1_radius);\n\n    float base_deco = SmoothUnion(base0_deco, base1_deco,0.1);\n\n    v = SmoothUnion(v, base_deco,0.05);\n\n\n    // cannelure autour de la colonne\n    const float theta = PI/8.0;\n\n    float angle = atan(p.x,p.y);\n    angle = fract(angle/theta) - 0.5;\n    vec3 cp = vec3(sin(angle)*0.5, length(p.xy) - (radius+0.05)*1.3, p.z);\n    cp.y -= offset;\n\n    vec3 start = vec3(0, 0, col_start.z + 2.0*deco0_radius + 1.3);\n    vec3 end = vec3(0, 0, col_end.z - 0.6);\n    v = SmoothDiff(v, Capsule(cp, start, end, theta*radius*1.2), 0.02);\n\n\n    float top = Box(top_p, top_size);\n\n    // upper column decoration\n    vec3 top_a = vec3( top_size.x,  top_size.x, len-top_height);\n    vec3 top_b = vec3(-top_size.x,  top_size.x, len-top_height);\n    \n    vec3 tp = p;\n    tp.y = abs(tp.y);\n    top = Union(top, Cylinder(tp, top_a, top_b, top_height));\n\n    v = Union(v, top);\n\n    return v;\n}\n\n// p : Point\n// size : Size of the stairs\n// num_step : number of stair's steps\nfloat TempleStairs(vec3 p, vec3 size, int num_step) {\n\n    \n    float step_height = size.z / float(num_step);\n    float half_step_height = step_height*0.5;\n    const float k = 0.1;\n\n    vec3 step_size = size;\n    step_size.z = half_step_height - k;\n\n    vec3 pos = p;\n    pos.z -= half_step_height;\n    float v = Box(pos, step_size) - k;\n\n    for (int i=1; i<num_step; ++i) {\n        pos.z -= step_height;\n        step_size.xy -= step_height*1.5;\n        // one step\n        v = Union(v, Box(pos, step_size) - k);\n    }\n    return v;\n}\n\nfloat TempleRoof(vec3 p, vec3 size) {\n\n    size.z *= 0.5;\n    const float k = 0.1;\n\n    float top_size_x = size.x - 0.5;\n    vec3 left_normal = normalize(vec3(0,1,size.z));\n    vec3 right_normal = left_normal;\n    right_normal.y *= -1.0;\n\n    vec3 tp = p - vec3(0,0,1.9);\n\n    // left\n    float v = Plane(tp, left_normal, vec3(0,size.y,0));\n    // right\n    v = SmoothInter(v, Plane(tp, right_normal, vec3(0,-size.y,0)), k);\n    // forward\n    v = SmoothInter(v, Plane(tp, vec3(1,0,0), vec3(top_size_x,0,0)), k);\n    // backward\n    v = SmoothInter(v, Plane(tp, vec3(-1,0,0), vec3(-top_size_x,0,0)), k);\n    // underneath\n    v = SmoothInter(v, Plane(tp, vec3(0,0,-1), vec3(0,0,0)), k);\n\n    vec3 lower_part_size = size;\n\n    const float lp_h = 1.0;\n    lower_part_size.z = lp_h;\n    float lower_part = Box(p-vec3(0,0,1.12), lower_part_size) - 0.01;\n\n    float cap_z = lower_part_size.z * -0.0;\n    float cap_x = lower_part_size.x + lower_part_size.z*2.3;\n    float cap_y = lower_part_size.y + lower_part_size.z*2.3;\n\n    vec3 a = vec3( cap_x,  cap_y, cap_z);\n    vec3 b = vec3(-cap_x,  cap_y, cap_z);\n    vec3 c = vec3( cap_x, -cap_y, cap_z);\n\n    float cap_size = lower_part_size.z*3.0;\n    vec3 cap_pos = p;\n    cap_pos.xy = abs(cap_pos.xy);\n    lower_part = SmoothDiff(lower_part, Capsule(cap_pos, a, b, cap_size),0.1);\n    lower_part = SmoothDiff(lower_part, Capsule(cap_pos, a, c, cap_size),0.1);\n\n\n    return SmoothUnion(v, lower_part-0.1, 0.1);\n}\n\n// Potential field of the object -> p : point\nfloat object(vec3 p)\n{\n\n    const float stars_height = 2.0;\n    const float columns_level = FLOOR_LEVEL + stars_height;\n    const float columns_height = 12.0;\n    const float columns_radius = 0.7;\n    const float roof_level = columns_level + columns_height;\n\n    // destruction\n    vec3 destroy_pos = (p + vec3(9,0,0))*0.10 + vec3(4.4,3.7,12.09);\n    float destroy_noise = Noise(destroy_pos)*2.0;\n    // float destroy_factor = max(-p.z*0.05 + 0.1, 0.0)*10.0;\n    // destroy_noise -= destroy_factor;\n\n    // fractal destruction\n    for (int i=2; i<5; ++i) {\n        float k = float(i);\n        destroy_noise += Noise(p*k)/(15.0*k);\n    }\n\n    // columns part\n    vec3 pc = p;\n    pc.xy = fract(pc.xy*0.25) * 4.0 - vec2(2.0,2.0);\n    pc.yz -= vec2(0,columns_level);\n    \n    float columns = Column(pc, columns_height, columns_radius);\n\n    columns = Inter(columns, Box(p, vec3(11.0+columns_radius, 7.0+columns_radius, columns_height)));\n    columns = Diff(columns, Box(p, vec3(9.0-columns_radius, 5.0-columns_radius, columns_height)));\n\n    vec3 fallen_col_p = Rotate(vec3(-PI_2,1.0,-3.2), p);\n    fallen_col_p = Translate(vec3(1.0,-2.0,-10.0),fallen_col_p);\n    fallen_col_p.z = 13.0 - fallen_col_p.z;\n\n    float fallen_col = Column(fallen_col_p, columns_height, columns_radius);\n    columns = Union(columns, fallen_col);\n\n    // roof part\n    float roof = TempleRoof(p-vec3(0,0, roof_level), vec3(12.7,8.9,5));\n    float v = SmoothInter(Union(roof, columns), destroy_noise, 0.2);\n\n\n    // stairs part\n    vec3 sp = Translate(vec3(0,0,FLOOR_LEVEL), p);\n    float stairs = TempleStairs(sp,vec3(14,10,stars_height), 4);\n\n    v = Union(v, stairs);\n\n    return v;\n}\n\n\n// Analysis of the scalar field --------------------------------------------------------------------------\n\n// Calculate object normal\n// p : Point\nvec3 ObjectNormal(vec3 p)\n{\n    float eps = 0.002;\n    vec3 n;\n    float v = object(p);\n    n.x = object( vec3(p.x+eps, p.y, p.z) ) - v;\n    n.y = object( vec3(p.x, p.y+eps, p.z) ) - v;\n    n.z = object( vec3(p.x, p.y, p.z+eps) ) - v;\n\n    return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// e : Maximum distance \n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, float e,out bool h,out int s)\n{\n    h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=0.0;\n\n    for(int i=0; i<MAX_STEPS; i++) {\n        s=i;\n        vec3 p = o+t*u;\n        float v = object(p);\n        // Hit object\n        if (v < 0.0) {\n            s=i;\n            h = true;\n            break;\n        }\n        // Move along ray\n        t += max(EPSILON,v);\n        // Escape marched too far away\n        if (t>e)\n            break;\n    }\n    return t;\n}\n\n// Lighting --------------------------------------------------------------------\n\nstruct PointLight {\n    vec3 position;\n    vec3 color;\n    float energy;\n    float radius;\n    float shadow_dist;\n};\n\nstruct DirectionalLight {\n    vec3 direction;\n    vec3 color;\n    float energy;\n    float shadow_dist;\n};\n\nconst int max_light = 16;\nint num_lights = 0;\n\nPointLight lights[max_light];\n\n// Add point light to the scene\nint addPointLight(vec3 position, vec3 color, float energy, float radius, float shadow_dist)\n{ \n    lights[num_lights] = PointLight(position, color, energy, radius, shadow_dist);\n    ++num_lights;\n\n    return num_lights;\n}\n\n// Shading ---------------------------------------------------------------------\n\n\n// Get random vector in [0,1]\nvec3 Hash3(vec3 vec, in float seed)\n{\n    float x = dot(vec, vec3(12.9898,78.233,81.564));\n    float y = dot(vec, vec3(54.6515,25.445,13.848));\n    float z = dot(vec, vec3(89.5405,95.540,99.244));\n\n    const vec3 seed3 = vec3(43758.5453, 15605.8033, 84053.4468);\n\n    return fract(sin(vec3(x,y,z)*seed3)*seed);                  \n}\n\n\n\nfloat Stars(vec3 viewDir, float grid, float seed)\n{    \n    vec3 scaled = viewDir*grid;\n    vec3 local = fract(scaled);\n    vec3 cell = floor(scaled);\n\n    // Random vector and scalar for each grid cell\n    vec3 randv = Hash3(cell, seed);\n    float f = Hash(dot(randv, cell))*0.5 + 0.5;\n\n    float radius = dot(viewDir, normalize(cell+randv));\n    radius = sqrt(1.0 - radius*radius) / f*700.0;\n    radius = clamp(1.0-radius*radius, 0.0, 1.0);\n\n    return radius * pow(f,2.0)* 0.5;\n}\n\n\nvec3 SkyStars(vec3 viewDir)\n{    \n\n    const float grid = 50.0; // spacing between stars\n    float light = 0.0;\n\n    light += Stars(viewDir, grid, 123456.789);\n    light += Stars(RotateY(321.0654,viewDir), grid, 345678.912);\n    light += Stars(RotateZ(876.2523, viewDir), grid, 541214.541);\n\n    return vec3(light);\n}\n\n\n\n\n\n// Atmospheric scattering based on preetham's analytical model\n// https://github.com/vorg/pragmatic-pbr/blob/master/local_modules/glsl-sky/index.glsl\n\n\nconst float turbidity = 10.0;\nconst float reileighCoefficient = 2.0;\nconst float mieCoefficient = 0.005;\nconst float mieDirectionalG = 0.75;\n\n// constants for atmospheric scattering\n\nconst float n = 1.0003; // refractive index of air\nconst float N = 2.545E25; // number of molecules per unit volume for air at\n// 288.15K and 1013mb (sea level -45 celsius)\nconst float pn = 0.035; // depolatization factor for standard air\n\n// wavelength of used primaries, according to preetham\nconst vec3 lambda = vec3(680E-9, 550E-9, 450E-9);\n\n// mie stuff\n// K coefficient for the primaries\nconst vec3 K = vec3(0.686, 0.678, 0.666);\nconst float V = 4.0;\n\n// optical length at zenith for molecules\nconst float rayleighZenithLength = 8.4E3;\nconst float mieZenithLength = 1.25E3;\nconst vec3 up = vec3(0.0, 0.0, 1.0);\n\nconst float EE = 1000.0;\nconst float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;\nconst float moonAngularDiameterCos = 0.99996192303;\n// 66 arc seconds -> degrees, and the cosine of that\n\n// earth shadow hack\nconst float cutoffAngle = PI/1.95;\nconst float steepness = 1.5;\n\n\nvec3 totalRayleigh(vec3 lambda)\n{\n    return (8.0 * pow(PI, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn));\n}\n\nfloat rayleighPhase(float cosTheta)\n{\n    return (3.0 / (16.0*PI)) * (1.0 + pow(cosTheta, 2.0));\n    // return (1.0 / (3.0*PI)) * (1.0 + pow(cosTheta, 2.0));\n    // return (3.0 / 4.0) * (1.0 + pow(cosTheta, 2.0));\n}\n\nvec3 totalMie(vec3 lambda, vec3 K, float T)\n{\n    float c = (0.2 * T ) * 10E-18;\n    return 0.434 * c * PI * pow((2.0 * PI) / lambda, vec3(V - 2.0)) * K;\n}\n\nfloat hgPhase(float cosTheta, float g)\n{\n    return (1.0 / (4.0*PI)) * ((1.0 - pow(g, 2.0)) / pow(1.0 - 2.0*g*cosTheta + pow(g, 2.0), 1.5));\n}\n\nfloat sunIntensity(float zenithAngleCos)\n{\n    return max(0.0, 1.0 - exp(-((cutoffAngle - acos(zenithAngleCos))/steepness)));\n}\n\n\n\nvoid AtmosphericScattering(DirectionalLight light, vec3 worldNormal, \n    out float cosTheta, out vec3 Lin, out vec3 Fex) \n{\n\n    vec3 lightDirection = light.direction;\n    float lightEnergy = light.energy;\n\n    float sunfade = 1.0-clamp(1.0- exp(light.direction.z / 450000.0) ,0.0,1.0);\n\n    float reileigh = reileighCoefficient - (1.0-sunfade);\n\n    // extinction (absorbtion + out scattering)\n    // rayleigh coefficients\n    vec3 betaR = totalRayleigh(lambda) * reileigh;\n\n    // mie coefficients\n    vec3 betaM = totalMie(lambda, K, turbidity) * mieCoefficient;\n\n    // optical length\n    // cutoff angle at 90 to avoid singularity in next formula.\n    //float zenithAngle = acos(max(0.0, dot(up, normalize(vWorldPosition - cameraPos))));\n    float zenithAngle = acos(max(0.0, dot(up, worldNormal)));\n    float sR = rayleighZenithLength / (cos(zenithAngle) + 0.15 * pow(93.885 - ((zenithAngle * 180.0) / PI), -1.253));\n    float sM = mieZenithLength / (cos(zenithAngle) + 0.15 * pow(93.885 - ((zenithAngle * 180.0) / PI), -1.253));\n\n\n    // combined extinction factor\n    Fex = exp(-(betaR * sR + betaM * sM));\n\n    // in scattering\n    cosTheta = dot(worldNormal, lightDirection);\n\n    float rPhase = rayleighPhase(cosTheta*0.5+0.5);\n    vec3 betaRTheta = betaR * rPhase;\n\n    float mPhase = hgPhase(cosTheta, mieDirectionalG);\n    vec3 betaMTheta = betaM * mPhase;\n\n\n    Lin = pow(lightEnergy * ((betaRTheta + betaMTheta) / (betaR + betaM)) * (1.0 - Fex),vec3(1.5));\n    Lin *= mix(vec3(1.0),pow(lightEnergy * ((betaRTheta + betaMTheta) / (betaR + betaM)) * Fex,vec3(1.0/2.0)),clamp(pow(1.0-dot(up, lightDirection),5.0),0.0,1.0));\n}\n\n\nvec3 AtmosphericScattering(DirectionalLight sun, DirectionalLight moon, vec3 viewDir) {\n\n    float cosTheta;\n    float moonCosTheta;\n    vec3 sunLin;\n    vec3 moonLin;\n    vec3 sunFex;\n    vec3 moonFex;\n\n    AtmosphericScattering(sun, viewDir, cosTheta, sunLin, sunFex);\n    AtmosphericScattering(moon, viewDir, cosTheta, moonLin, moonFex);\n\n    \n    vec3 texColor = moonLin + sunLin;\n    texColor += (sunFex + moonFex)*0.1;\n    texColor *= 0.04;\n    texColor += vec3(0.0,0.001,0.0025)*0.3;\n\n    return texColor;\n}\n\nvec3 GetSkyFex(DirectionalLight light) \n{\n\n    float sunfade = 1.0-clamp(1.0-exp(light.direction.z),0.0,1.0);\n\n    float reileigh = reileighCoefficient - (1.0-sunfade);\n\n    // rayleigh coefficients\n    vec3 betaR = totalRayleigh(lambda) * reileigh;\n\n    // mie coefficients\n    vec3 betaM = totalMie(lambda, K, turbidity) * mieCoefficient;\n\n    // sun optical length\n    float zenithAngle = acos(max(0.0, dot(up, light.direction)));\n    float sR = rayleighZenithLength / (cos(zenithAngle) + 0.15 * pow(93.885 - ((zenithAngle * 180.0) / PI), -1.253));\n    float sM = mieZenithLength / (cos(zenithAngle) + 0.15 * pow(93.885 - ((zenithAngle * 180.0) / PI), -1.253));\n\n    // combined extinction factor\n    return exp(-(betaR * sR + betaM * sM));\n}\n\n\n// Get sky ambient color\n// sunDirection : Sun direction\n// worldNormal : Ray direction\nvec3 SkyAmbient(DirectionalLight sun) {\n\n    float cosTheta;\n    vec3 Lin;\n    vec3 Fex;\n\n    vec3 normal = normalize(sun.direction*1.5 + up);\n\n    AtmosphericScattering(sun, normal, cosTheta, Lin, Fex);\n\n    vec3 L0 = Fex * 0.1;\n\n    vec3 texColor = (Lin+L0) * 0.04;\n    texColor += vec3(0.0,0.001,0.0025)*0.3;\n\n\n    return texColor;\n}\n\n\n// Get sky color\n// sunPosition : Sun direction\n// worldNormal : Ray direction\nvec3 Sky(DirectionalLight sun, DirectionalLight moon, vec3 viewDir, vec3 stallarViewDir) {\n\n    float sunCosTheta;\n    float moonCosTheta;\n    vec3 sunLin;\n    vec3 moonLin;\n    vec3 sunFex;\n    vec3 moonFex;\n\n    // sun scattering\n    AtmosphericScattering(sun, viewDir, sunCosTheta, sunLin, sunFex);\n\n    // moon scattering\n    AtmosphericScattering(moon, viewDir, moonCosTheta, moonLin, moonFex);\n\n\n    //nightsky\n    vec3 L0 = SkyStars(stallarViewDir) * moonFex;\n\n    \n    float sundisk = smoothstep(sunAngularDiameterCos,sunAngularDiameterCos+0.00002,sunCosTheta);\n    L0 += sun.energy * 19000.0 * sundisk * sunFex;\n\n    float moondisk = smoothstep(moonAngularDiameterCos,moonAngularDiameterCos+0.00002,moonCosTheta);\n    L0 += moon.energy * 20.0 * moondisk * moonFex;\n\n    vec3 texColor = (moonLin + sunLin + L0) * 0.04;\n    texColor += vec3(0.0,0.001,0.0025)*0.3;\n\n\n    return texColor;\n}\n\n\n\n\n// Cast soft shadow based on https://www.shadertoy.com/view/tlBcDK\n// p : Point\n// n : Normal at point\n// l : Point to light vector\n// d : Max tracing distance\nfloat Shadow(vec3 p,vec3 n,vec3 l, float d)\n{\n    // float v;\n    // int s;\n    // bool h;\n    // SphereTrace(p+0.1*n,l,d,h,s);\n\n    // if (!h)\n    //  return 1.0;\n\n    // return 0.0;\n\n    const float k = 20.0;\n\n    float res = 1.0;\n    float t = 0.1;\n\n    for (int i = 0; i < MAX_STEPS; ++i) {\n\n        if (res < 0.0 || t > d)\n            break;\n    \n        float h = object(p+t*l);\n\n        res = min(res, k * h / t);\n        t += h;    \n    }    \n\n    return clamp(res, 0.0, 1.0);\n}\n\n\n// Compute ambient occlusion based on https://www.shadertoy.com/view/3lXyWs\n// p : Point\n// n : Normal at point\nfloat AmbientOcclusion(vec3 p,vec3 n) {\n\n    const int AO_STEPS = 4;\n    const float AO_MAX_DIST = 3.0;\n\n    const float SCALE = AO_MAX_DIST / pow(2.0, float(AO_STEPS))*2.0;\n    float ocl = 0.0;\n\n    for(int i = 1; i <= AO_STEPS; ++i) {\n        float dist = pow(2.0, float(i)) * SCALE;\n        ocl += 1.0 - (max(0.0, object(p + n * dist)) / dist);\n    }\n    \n    return min(1.0-(ocl / float(AO_STEPS)),1.0);\n    // return pow(abs(object(p + 2.0 * n)),0.9);\n}\n\n\n// Background color\n// r : View ray direction\n// cd : Celestial ray direction\nvec3 background(vec3 r, vec3 cd, DirectionalLight sun,  DirectionalLight moon)\n{   \n    return Sky(sun, moon, r, cd);\n\n    // return mix(vec3(0.452,0.551,0.995),vec3(0.652,0.697,0.995), d.z*0.5+0.5);\n}\n\n// Compute Blinn-Phong specular\n// l : Vector to light\n// n : Normal at point\n// r : View ray direction\n// k : glossyness\nfloat Specular(vec3 l, vec3 n, vec3 r, float k)\n{\n    vec3 half_dir = normalize(l + r);\n    float spec_angle = max(dot(half_dir, n), 0.0);\n    return pow(spec_angle, k);\n\n    // Phong\n//     vec3 ref = reflect(r, n);\n//     float c = max(dot(ref, r), 0.0);\n//     return pow(c, k/4.0);\n}\n\n\n// Compute point light\n// p : Point\n// n : Normal at point\n// r : View ray direction\n// light : light's data\n// specular : Specular output\nvec3 ComputePointLight(vec3 p,vec3 n, vec3 r, PointLight light, inout vec3 specular) {\n\n    vec3 l = light.position - p;\n    float distance = length(l);\n    vec3 l_nor = l/distance;\n\n    float lambertian = max(dot(n, l_nor),0.0);\n\n    if (lambertian == 0.0)\n        return vec3(0);\n\n    float attenuation =  1.0/(distance*distance + 1.0);\n    float s = 1.0;\n\n    if (distance < light.shadow_dist)\n        s = Shadow(p, n ,l_nor, distance);\n\n    vec3 c = s * light.energy * light.color * attenuation;\n\n    specular += Specular(l_nor, n, -r, 100.0) * c;\n\n    return lambertian * c;\n\n}\n\n// Compute sun light\n// p : Point\n// n : Normal at point\n// r : View ray direction\n// color : color of light\n// shadow_dist : Max shadow tracing distance\n// specular : Specular output\nvec3 ComputeDirectionalLight(vec3 p, vec3 n, vec3 r, DirectionalLight light, inout vec3 specular) {\n\n    float s = Shadow(p, n, light.direction, light.shadow_dist);\n\n    vec3 c = light.color*s;\n\n    specular += Specular(light.direction, n, -r, 100.0) * c;\n    \n    return c*max(dot(n , light.direction), 0.0);\n}\n\n// Shading and lighting\n// p : Point\n// n : Normal at point\n// r : View ray direction\n// sun_dir : Sun direction\nvec3 Shade(vec3 p, vec3 n, vec3 r, DirectionalLight sun, DirectionalLight moon)\n{\n     // Point light\n    const vec3 lp = vec3(-20.0, -20.0, 10.0);\n    \n    // Light direction to point light\n    vec3 l = normalize(lp - p);\n\n    // Ambient color\n    vec3 ambient = SkyAmbient(sun) * 0.3;\n\n    // Ambient occlusion\n    ambient *= AmbientOcclusion(p, n);\n\n    vec3 surface = vec3(1);\n\n    // Lambert diffuse\n    vec3 diffuse = vec3(0);\n    vec3 specular = vec3(0);\n\n    // Compute all points lights\n    for (int i=0; i<num_lights; ++i) {\n\n        PointLight light = lights[i];\n\n        diffuse += ComputePointLight(p, n, r, light, specular);\n    }\n\n    // Compute sun and moon lighting\n    if (sun.direction.z > 0.0)\n        diffuse += ComputeDirectionalLight(p, n, r, sun, specular);\n\n    if (moon.direction.z > 0.0)\n        diffuse += ComputeDirectionalLight(p, n, r, moon, specular);\n\n    return (ambient + diffuse)*surface + specular;\n}\n\n\n// light scattering based on https://ijdykeman.github.io/graphics/simple_fog_shader\n// ray_dir : View ray direction\n// light_dir : View to light vector\n// ray_dist : View ray length\n// radius : radius of the light\nfloat Scatter(vec3 ray_dir, vec3 light_dir,float ray_dist, float radius)\n{\n    const float anisotropy = 0.3;\n\n    float a = dot(-light_dir, ray_dir);\n    float c = dot(light_dir, light_dir);\n    float h = 1.0/max(sqrt(c-a*a), radius);\n\n    float b = a+ray_dist;\n\n    // approximate mie scattering, but not physically accurate\n    h = pow(h, anisotropy + 1.0); \n\n    return (atan(b*h) - atan(a*h))*h;\n}\n\n// Gather in-scattering of all lights\n// rd : View ray direction\n// ro : View ray origin\n// t  : View ray length\nvec3 Scattering(vec3 rd, vec3 ro, float t) {\n\n    const float density = 0.02;\n    vec3 total_scatter = vec3(0);\n\n    for (int i=0; i<num_lights; ++i) {\n\n        PointLight light = lights[i];\n        vec3 lp = light.position;\n        float radius = light.radius;\n        vec3 lv = lp-ro;\n\n        float scatter = Scatter(rd, lv, t, radius);\n\n        total_scatter += scatter*light.color*light.energy;\n    }\n\n    return total_scatter * density;\n}\n\n\n// Shading according to the number of steps in sphere tracing\n// n : Number of steps\nvec3 ShadeSteps(int n)\n{\n   float t=float(n)/(float(MAX_STEPS-1));\n   return 0.5+mix(vec3(0.05,0.05,0.5),vec3(0.65,0.39,0.65),t);\n}\n\n// Picture in picture\n// pixel : Pixel\n// pip : Boolean, true if pixel was in sub-picture zone\nvec2 Pip(in vec2 pixel, out bool pip)\n{\n    // Pixel coordinates\n    vec2 p = (-iResolution.xy + 2.0*pixel)/iResolution.y;\n   if (pip==true)\n   {    \n    const float fraction=1.0/4.0;\n    // Recompute pixel coordinates in sub-picture\n    if ((pixel.x<iResolution.x*fraction) && (pixel.y<iResolution.y*fraction))\n    {\n        p=(-iResolution.xy*fraction + 2.0*pixel)/(iResolution.y*fraction);\n        pip=true;\n    }\n       else\n       {\n           pip=false;\n       }\n   }\n   return p;\n}\n\n\n// Tone mappin -------------------------------------------------------------------\n\n// based on https://www.shadertoy.com/view/ldcSRN\n\nconst float W =11.2; // white scale\n\n// filmic (John Hable)\n\n\nconst float A = 0.22; // shoulder strength\nconst float B = 0.3; // linear strength\nconst float C = 0.1; // linear angle\nconst float D = 0.20; // toe strength\nconst float E = 0.01; // toe numerator\nconst float F = 0.30; // toe denominator\n\nvec3 LinearToSRGB(vec3 x) \n{\n    vec3 t = step(x,vec3(0.0031308));\n    return mix(1.055*pow(x, vec3(1./2.4)) - 0.055, 12.92*x, t);\n}\n\nvec3 Gamma(vec3 color, float gamma) \n{\n    return pow(color, vec3(gamma));\n}\n\nvec3 Uncharted2Curve(vec3 x)\n{\n    float A = 0.15;\n    float B = 0.50;\n    float C = 0.10;\n    float D = 0.20;\n    float E = 0.02;\n    float F = 0.30;\n\n    return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n}\n\nvec3 Uncharted2(vec3 color)\n{\n    vec3 white_scale = Uncharted2Curve(vec3(W));\n    return Uncharted2Curve(color) / white_scale;\n}\n\n\nvec3 ReinhardCurve (vec3 x)\n{\n\treturn x / (1.0 + x);\n}\n\nvec3 Reinhard(vec3 color) \n{\n    vec3 white_scale = ReinhardCurve(vec3(W));\n    return ReinhardCurve(color) / white_scale;\n}\n\n\nvec3 FilmicReinhardCurve (vec3 x) \n{\n    const float T = 0.01;\n    vec3 q = (T + 1.0)*x*x;\n\treturn q / (q + x + T);\n}\n\nvec3 FilmicReinhard(vec3 color) \n{\n    vec3 white_scale = FilmicReinhardCurve(vec3(W));\n    return FilmicReinhardCurve(color) / white_scale;\n}\n\n\nvec3 FilmicCurve(vec3 x)\n{\n\treturn ((x*(0.22*x+0.1*0.3)+0.2*0.01)/(x*(0.22*x+0.3)+0.2*0.3))-0.01/0.3;\n}\n\nvec3 Filmic(vec3 color)\n{\n    vec3 white_scale = FilmicCurve(vec3(W));\n    return FilmicCurve(color) / white_scale;\n}\n\n\nvec3 ACESFitted(vec3 color) {\n\n    color = pow(color, vec3(0.833));\n    color *= 1.07;\n\n    const mat3 ACESInput = mat3(\n        0.59719, 0.35458, 0.04823,\n        0.07600, 0.90834, 0.01566,\n        0.02840, 0.13383, 0.83777\n    );\n\n    const mat3 ACESOutput = mat3(\n        1.60475, -0.53108, -0.07367,\n        -0.10208,  1.10813, -0.00605,\n        -0.00327, -0.07276,  1.07602\n    );\n\n\n    color = color * ACESInput;\n\n    // Apply RRT and ODT\n    vec3 a = color * (color + 0.0245786) - 0.000090537;\n    vec3 b = color * (0.983729 * color + 0.4329510) + 0.38081;\n    color = a/b;\n\n    return color * ACESOutput;\n}\n\n\nvec3 ToneMapping(vec3 color) {\n\n    color = Gamma(color,1.0);\n\n    #if TONEMAP_MODE == TONEMAP_FILMIC\n        color = Filmic(color);\n    #elif TONEMAP_MODE == TONEMAP_REINHARD\n        color = Reinhard(color);\n    #elif TONEMAP_MODE == TONEMAP_FILMIC_REINHARD\n        color = FilmicReinhard(color);\n    #elif TONEMAP_MODE == TONEMAP_UNCHARTED2\n        color = Uncharted2(color);\n    #elif TONEMAP_MODE == TONEMAP_ACES\n        color = ACESFitted(color);\n    #endif\n\n    color = clamp(LinearToSRGB(color), 0.0, 1.0);\n\n    return color;\n}\n\n\nfloat smoothRand(float seed) {\n\n    float amplitude = 1.;\n    float frequency = 1.;\n    float y = sin((iTime+seed) * frequency);\n    float t = 0.01*(-(iTime+seed)*130.0);\n    y += sin(frequency*2.1 + t)*4.5;\n    y += sin(frequency*1.72 + t*1.121)*4.0;\n    y += sin(frequency*2.221 + t*0.437)*5.0;\n    y += sin(frequency*3.1122+ t*4.269)*2.5;\n    y *= amplitude*0.06;\n\n    return y;\n}\n\n// Image\nvoid mainImage( out vec4 color, in vec2 pxy )\n{\n    // central blue light\n    float x, y = 0.0;\n    float z = 2.0;\n\n    float r = 0.0;\n    float g = 0.5;\n    float b = 1.0;\n\n    addPointLight(vec3(x,y,z), vec3(r,g,b), 1.0, 0.3, 0.0);\n\n    // Picture in picture on\n    bool pip=true;\n\n    // Pixel\n    vec2 pixel=Pip(pxy, pip);\n\n    // Mouse\n    vec2 m=iMouse.xy/iResolution.xy;\n\n    // Camera\n    vec3 ro,rd;\n    Ray(m,pixel,ro,rd);\n\n\n    // Hit and number of steps\n    bool hit;\n    int s;\n\n\n    CATCH_DEBUG(float t = SphereTrace(ro, rd, 1000.0, hit, s));\n\n    const float latitude = 0.0;\n    const float orbital_axis = 0.41015;\n    \n    // Position \n    vec3 pt = ro + t * rd;\n\n    DirectionalLight sun;\n    DirectionalLight moon;\n    \n    const float sunAzimuth = 1.5;\n    const float moonAzimuth = 1.0;\n    \n    float curr_time = iTime*TIME_SCALE + PI;\n\n    // curr_time = 6.7; // day\n    // curr_time = 9.3; // night\n    // curr_time = 1.6; // sunset\n\n    float earthRotTheta = curr_time;\n\n    mat3 celestial_rot = RotationX(earthRotTheta);\n    celestial_rot = RotationZ(earthRotTheta) * celestial_rot;\n    celestial_rot = RotationX(orbital_axis) * celestial_rot;\n\n    const vec3 sun_pos = vec3(cos(sunAzimuth), sin(sunAzimuth),0);\n    \n    float moonRotTheta = curr_time * 0.0338983;\n    mat3 moon_rot = RotationZ(moonRotTheta); // moon around earth\n    moon_rot *= RotationX(0.08970992); // moon orbit\n    vec3 moon_pos = moon_rot[0];\n\n    sun.direction = celestial_rot * sun_pos;\n    moon.direction = celestial_rot * moon_pos;\n\n    sun.energy = sunIntensity(sun.direction.z) * EE;\n    moon.energy = sunIntensity(moon.direction.z) * 5.0;\n\n    float elevation = acos(sun.direction.z) / PI_2;\n\n    vec3 rgb;\n\n    moon.color = GetSkyFex(moon)*0.005;\n    sun.color = GetSkyFex(sun)*19.0;\n    \n    // Some optimization for preventing useless shadow computation\n    if (sun.direction.z < 0.0) {\n        sun.shadow_dist = 0.0;\n        moon.shadow_dist = 100.0;\n    } else {\n        sun.shadow_dist = 100.0;\n        moon.shadow_dist = 0.0;\n    }\n\n\n    if (hit || rd.z < 0.0) {\n        vec3 n;\n\n        if (hit)\n            n = ObjectNormal(pt);\n        \n        else { // infinite ground plane \n            n = up;\n    \n            float co = rd.z;\n            float si = sqrt(1.0-co*co);\n            float ta = si/co;\n            \n            float a = ro.z - FLOOR_LEVEL;\n            float b = ta*a;\n\n            t = length(vec2(a,b));\n            pt = ro + t * rd;\n        }\n\n        // Shade object with light\n        rgb = Shade(pt, n, rd, sun, moon);\n\n        vec3 atmosphere = AtmosphericScattering(sun, moon, rd);\n        float fog = clamp(smoothstep(40.0,1000.0,t), 0.0, 1.0);\n        rgb = mix(rgb, atmosphere, fog);\n    }\n    else {\n        // Shade background\n        CATCH_DEBUG(rgb = background(rd, rd*celestial_rot, sun, moon));\n    }\n\n    // Volumetric lighting\n    rgb += Scattering(rd, ro, t);\n\n\n    // Auto exposure\n    float sun_ext = clamp(map(elevation, 0.98, 1.2, 0.0, 1.0), 0.0, 1.0);\n    sun_ext = smoothstep(0.0, 1.0, sun_ext);\n    float exposure_bias = mix(0.2, 20.0, sun_ext);\n    rgb *= exposure_bias;\n\n    rgb = ToneMapping(rgb);\n\n    // Uncomment this line to shade image with false colors representing the number of steps\n    if (pip==true)\n        rgb = ShadeSteps(s);\n\n#if _DEBUG\n    rgb = _debug_color;\n#endif\n\n    color = vec4(rgb, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltBRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1336, 1393, 1417, 1417, 1460], [1462, 1509, 1582, 1582, 1650], [1652, 1673, 1707, 1707, 1730], [1732, 1749, 1781, 1781, 1840], [1842, 1884, 1919, 1919, 2116], [2118, 2160, 2195, 2195, 2398], [2400, 2442, 2477, 2477, 2676], [2678, 2696, 2727, 2727, 2825], [2828, 2853, 2879, 2879, 3022], [3024, 3090, 3119, 3119, 3295], [3297, 3363, 3392, 3392, 3568], [3570, 3636, 3665, 3665, 3829], [3831, 3882, 3925, 3925, 3982], [3984, 4035, 4060, 4060, 4104], [4106, 4135, 4165, 4165, 4237], [4239, 4267, 4318, 4318, 4390], [4392, 4416, 4474, 4474, 4569], [4572, 4572, 4628, 4648, 5199], [5202, 5202, 5242, 5242, 5514], [5613, 5704, 5734, 5734, 5757], [5759, 5855, 5884, 5884, 5908], [5910, 6008, 6039, 6039, 6062], [6143, 6248, 6297, 6297, 6392], [6394, 6504, 6552, 6552, 6649], [6651, 6763, 6811, 6811, 6906], [6908, 7002, 7047, 7047, 7084], [7086, 7086, 7136, 7136, 7180], [7182, 7182, 7222, 7222, 7316], [7318, 7318, 7351, 7351, 7445], [7448, 7448, 7496, 7496, 7542], [7544, 7544, 7587, 7587, 7741], [7744, 7744, 7801, 7801, 7846], [7848, 7848, 7906, 7906, 8082], [8085, 8136, 8160, 8160, 8607], [8610, 8682, 8729, 8729, 10850], [10852, 10932, 10985, 10985, 11467], [11469, 11469, 11506, 11506, 12923], [12925, 12971, 12993, 12993, 14631], [14742, 14782, 14809, 14809, 15044], [15046, 15176, 15241, 15241, 15711], [16098, 16130, 16223, 16223, 16351], [16436, 16466, 16503, 16503, 16796], [16800, 16800, 16851, 16851, 17282], [17285, 17285, 17314, 17314, 17602], [18789, 18876, 18909, 18909, 19049], [19051, 19051, 19088, 19088, 19266], [19268, 19268, 19313, 19313, 19423], [19425, 19425, 19465, 19465, 19567], [19569, 19569, 19611, 19611, 19696], [19700, 19700, 19824, 19824, 21339], [21342, 21342, 21429, 21429, 21856], [21858, 21858, 21899, 21899, 22603], [22606, 22694, 22733, 22733, 23030], [23033, 23112, 23202, 23202, 24007], [24012, 24172, 24217, 24355, 24658], [24661, 24773, 24812, 24812, 25231], [25234, 25312, 25392, 25392, 25513], [25515, 25637, 25686, 25686, 25924], [25927, 26066, 26152, 26152, 26648], [26650, 26834, 26933, 26933, 27145], [27147, 27260, 27341, 27361, 28197], [28200, 28414, 28488, 28488, 28815], [28817, 28930, 28974, 28974, 29374], [29377, 29462, 29486, 29486, 29593], [29595, 29690, 29729, 29754, 30178], [30400, 30617, 30645, 30645, 30749], [30751, 30751, 30789, 30789, 30827], [30829, 30829, 30859, 30859, 31034], [31036, 31036, 31065, 31065, 31165], [31168, 31168, 31197, 31197, 31222], [31224, 31224, 31252, 31252, 31348], [31351, 31351, 31387, 31387, 31468], [31470, 31470, 31504, 31504, 31612], [31615, 31615, 31641, 31641, 31718], [31720, 31720, 31745, 31745, 31837], [31840, 31840, 31869, 31869, 32454], [32457, 32457, 32487, 32487, 32991], [32994, 32994, 33024, 33024, 33377], [33379, 33388, 33435, 33461, 36762]], "test": "valid"}
{"id": "3ltBWH", "name": "Polar Visualizer Fork", "author": "oneshade", "description": "Trying to avoid as many texture() calls as possible.", "tags": ["ray", "raymarch", "circle", "visualizer", "polar", "march"], "likes": 3, "viewed": 74, "published": "Public", "date": "1612653452", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159265359;\nconst float TAU = 6.28318530718;\nconst float HALF_PI = 1.57079632679;\n\nconst float        COUNT = 12.0;  // Number of bars to draw in the visualizer\nconst float    THICKNESS = 0.01;  // Line thickness\nconst float INNER_RADIUS =  0.1;  // Inner circle radius\nconst float OUTER_RADIUS =  0.5;  // Outer circle radius\nconst float  START_ANGLE =  0.0;  // Rotation\n\nconst vec3 OFFSET = vec3(0.0, 0.1, 0.0);\n\nconst float  MIN_DIST = 0.001;\nconst float  MAX_DIST =   4.0;\nconst   int MAX_STEPS =    50;\n\nmat2 Rotate(in float r) {\n    float s = sin(r), c = cos(r);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdLine(in vec3 p, in vec3 a, in vec3 b, in float r) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\nfloat mapScene(in vec3 p) {\n    float angle = atan(p.z, p.x);\n    float cell = floor(angle / TAU * COUNT) / COUNT;\n\n    float repAngle = TAU / COUNT;\n    float hRepAngle = repAngle * 0.5;\n    p.xz = sin(mod(angle + START_ANGLE, repAngle) - hRepAngle + vec2(HALF_PI, 0.0)) * length(p.xz);\n\n    float amplitude = texture(iChannel0, vec2(cell, 0.0)).x;    \n    float musicBars = sdLine(p - OFFSET, vec3(INNER_RADIUS, 0.0, 0.0), vec3(INNER_RADIUS + amplitude * (OUTER_RADIUS - INNER_RADIUS), 0.0, 0.0), THICKNESS);\n\n    return min(p.y, musicBars);\n}\n\nvec3 getNormal(in vec3 p) {\n    vec2 e = vec2(MIN_DIST, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy) - mapScene(p - e.xyy),\n                          mapScene(p + e.yxy) - mapScene(p - e.yxy),\n                          mapScene(p + e.yyx) - mapScene(p - e.yyx)));\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n    float t = MIN_DIST;\n    for(int i=0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * t;\n        float d = mapScene(p);\n        t += d;\n        if ((t > MAX_DIST) || (abs(d) < MIN_DIST)) break;\n    }\n\n    return t;\n}\n\nfloat pointLight(in vec3 p, in vec3 pos, in float range) {\n    vec3 k = pos - p;\n    float m = length(k);\n    vec3 l = k / m;\n    vec3 n = getNormal(p);\n\n    float dif = clamp(dot(n, l), 0.0, 1.0);\n    dif *= smoothstep(range, 0.0, m);\n\n    dif *= step(length(pos - p), RayMarch(p + n * MIN_DIST, l));\n\n    return dif;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.5, -0.7);\n    vec3 rd = normalize(vec3(uv, 1.0));\n\n    rd.zy *= Rotate(-radians(30.0));\n    ro.xz *= Rotate(iTime * radians(10.0));\n    rd.xz *= Rotate(iTime * radians(10.0));\n\n    float t = RayMarch(ro, rd);\n    vec3 p = ro + rd * t;\n\n    vec3 color = vec3(0.0);\n\n    vec3 lp = vec3(1.0, 0.5, 0.0);\n    lp.xz *= Rotate(radians(120.0));\n    color += pointLight(p, lp, 3.0) * vec3(1.0, 0.4, 0.4);\n\n    lp.xz *= Rotate(radians(120.0));\n    color += pointLight(p, lp, 3.0) * vec3(0.4, 1.0, 0.4);\n\n    lp.xz *= Rotate(radians(120.0));\n    color += pointLight(p, lp, 3.0) * vec3(0.4, 0.4, 1.0);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltBWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[137, 530, 555, 555, 621], [623, 623, 682, 682, 811], [813, 813, 840, 840, 1358], [1360, 1360, 1387, 1387, 1632], [1634, 1634, 1668, 1668, 1889], [1891, 1891, 1949, 1949, 2211], [2213, 2213, 2268, 2268, 2988]], "test": "error"}
{"id": "3ltfD4", "name": "Fractal 15_gaz", "author": "gaz", "description": "3d", "tags": ["fractal"], "likes": 10, "viewed": 164, "published": "Public", "date": "1612761257", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 r=iResolution,p;\n    \n    for(float i=0.,g,e,l,s;\n        ++i<99.;\n        (e<.003)?O.xyz+=cos(vec3(1,2,3)+log(s)*.5)*.5/i:p\n        )\n    {\n        p=g*vec3((C-.5*r.xy)/r.y,1);\n        p.z-=.3;\n        p=R(p,vec3(.577),iTime*.5);\n        p.x<-p.y?p.xy=-p.yx:C,\n        p.x<-p.z?p.xz=-p.zx:C,\n        p.y<-p.z?p.zy=-p.yz:C;\n        s=3.;\n        for(int j=0;j++<5;)\n            s*=l=2./clamp(dot(p,p),.1,1.),\n            p=abs(p)*l-vec3(1,1,5);\n        g+=e=length(cross(p,r/r))/s;\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltfD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 95, 95, 609]], "test": "valid"}
{"id": "3ltfDN", "name": "shape_practice02", "author": "cghow", "description": "shape_practice01", "tags": ["shapepractice01"], "likes": 0, "viewed": 20, "published": "Public", "date": "1612777744", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\n\tuv.x *=  iResolution.x / iResolution.y;\n     vec3 col =  vec3(0.502,0.502,0.502);\n    \n    \n   \tfor( int i=0; i<400; i++ )\n\t{ \n    float siz = pow( sin(float(i)*641.74+5.0)*.5 + 0.5, 4.0 );\n    \n      float rad = 0.01 + .5*siz;\n      uv += vec2(cos(iTime),sin(iTime))*rad;\n\n        vec2 pos = vec2(rad*.001,rad*.001);\n        float f = length(uv-pos)*5.;\n\n       f = clamp(f,0.0,1.0);\n       f = 1.-f;\n       col-=f;\n\n    \n      }\n\n\nfragColor = vec4(col,1.0);\n\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltfDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 576]], "test": "valid"}
{"id": "3ltfR4", "name": "Pulsing Dot", "author": "misfit", "description": "A pulsing trail of dots on and abstract animated background", "tags": ["abstract"], "likes": 1, "viewed": 49, "published": "Public", "date": "1612500913", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float TAU = 6.28318530718;\n\n\nvec2 Rotate(float a, vec2 p)\n{\n    return p * mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -.5 to .5)\n    vec2 uv = fragCoord/iResolution.xy-.5;\n    \n    // Draw Background\n    float a = fract(iTime * .1) * TAU;\n    vec2 yelUV = Rotate(a, uv);\n    float width = 0.1 * abs(sin(iTime));\n    float height = 0.25 * abs(cos(iTime));\n    float ew = 0.01;\n    float c = .5 / max(width, 0.01);\n    vec3 col = vec3(.5 / c);\n    for(int i = 1; i < int(c); i++)\n    {\n        col.rg += 1. / (c+1.) * max(0.1, smoothstep(width * float(i), width * float(i) + ew, abs(yelUV.x)));\n        col.b += 1. / (c+1.) * max(0.1, smoothstep(height * float(i), height * float(i) + ew, abs(yelUV.y)));\n    }\n    \n    // Draw Dots\n    int dotCount = 5;\n    for(int i = 0; i < dotCount; i++)\n    {\n        float t = iTime - float(i) / float(dotCount) + float(i) * .075;\n        float radius = 0.012 + 0.01 * sin(t * 1.75) - float(i) * 0.0001;\n        vec2 offset = vec2(0.5 * sin(t * TAU / 3.), 0.3 * cos(t) + .1 * cos(t * TAU));\n        vec2 uvc = vec2(uv.x + offset.x, uv.y - offset.y);\n        float p = uvc.x * uvc.x + uvc.y * uvc.y * .5 * iResolution.y/iResolution.x;\n        //ew += (float(i) / (float(dotCount) -  1.)) * 0.0009;\n        float cir = smoothstep(radius, radius + ew, p);\n        float val = .6 + radius * 20.;\n        col = mix(vec3(val, uvc.y * 1.75, uvc.y * 1.75), col, cir);\n    } \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltfR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 65, 65, 121], [123, 123, 180, 233, 1567]], "test": "valid"}
{"id": "3ltfWf", "name": "bokeh expe 02", "author": "YitingLiu", "description": "experimenting with bokeh and struct ", "tags": ["bokeh", "lights", "drive", "street", "artofcode"], "likes": 0, "viewed": 184, "published": "Public API", "date": "1613601099", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(x, y, t) smoothstep(x, y, t)\n\n\nstruct ray {\n    vec3 o,d;\n};\n\nray GetRay(vec2 uv, vec3 camPos, vec3 lookat, float zoom){\n    ray a;\n    a.o = camPos;\n    \n    vec3 f = normalize(lookat-camPos);\n    vec3 r = cross(vec3(0,1,0),f);\n    vec3 u = cross(f,r);\n    vec3 c = a.o + f*zoom;\n    vec3 i = c+uv.x*r+uv.y *u;\n    a.d=normalize(i-a.o);\n    \n    return a;\n}\n\nvec3 ClosetPoint(ray r, vec3 p){\n    return r.o+max(0.,dot(p-r.o,r.d))*r.d;\n\n}\n\nfloat DistRay(ray r, vec3 p){\n    return length(p-ClosetPoint(r,p));\n}\n\nfloat Bokeh (ray r, vec3 p, float size, float blur){\n    size*=length(p);\n    float d = DistRay(r,p);\n    float c = S(size, size*(1.-blur),d);\n    c*=mix(.6,1.,S(size*.8,size,d));\n    return c;\n\n}\n\nvec3 Streetlights(ray r, float t){\n    float side = step(r.d.x,0.);\n   \n    r.d.x=abs(r.d.x);\n\n    float s = 1./10.;\n    float m = 0.;\n    \n    for(float i=0.; i < 1.; i+=s){\n    float ti = fract(t+i+side*s*.5);\n    vec3 p = vec3(2.,2.,100.-ti*100.);\n    m+= Bokeh(r,p,.1,.1)*ti*ti*ti*ti;\n    }\n    return  vec3(1.,.7,.3)*m;\n\n}\n\nfloat N(float t){\n    return fract(sin(t*3456.)*6578.);\n}\nvec3 Headlights(ray r, float t){\n    t*=.2;\n   \n   float w1 = .25;// distance between headlight \n   float w2 = w1*1.2;\n\n    float s = 1./30.;// divider is the number of cars \n    float m = 0.;\n    \n    for(float i=0.; i < 1.; i+=s){\n        \n        float n = N(i);// randomize the headlight using noise \n        if(n>.1) continue;// jump back to for loop while not executing below \n        \n        float ti = fract(t+i);\n        float z = 100.-ti*100.;\n        float fade =ti*ti*ti*ti;\n        \n        float focus = S(.8,1.,ti);\n        float size = mix(.05,.03,focus);        \n   \n        m+= Bokeh(r,vec3(-1.-w1,.15,z),size,.1)*fade;\n        m+= Bokeh(r,vec3(-1.+\n        w1,.15,z),size,.1)*fade;\n        \n        m+= Bokeh(r,vec3(-1.-w2,.15,z),size,.1)*fade;\n        m+= Bokeh(r,vec3(-1.+\n        w2,.15,z),size,.1)*fade;\n        \n        \n        float ref = 0.; //reflection \n        ref+= Bokeh(r,vec3(-1.-w2,-.15,z),size*3.,1.)*fade;\n        ref+= Bokeh(r,vec3(-1.+\n        w2,-.15,z),size*3.,1.)*fade;\n        \n        m+=ref*focus;//only show reflection when in focus \n    }\n    \n    return vec3(.9,.9,1.)*m;//blue and green \n\n}\n\nvec3 Taillights(ray r, float t){\n\n    t *=.25;\n   \n    float w1 = .25;// distance between headlight \n    float w2 = w1*1.2;\n\n    float s = 1./15.;// divider is the number of cars \n    float m = 0.;\n    \n    for(float i=0.; i < 1.; i+=s){\n        \n        float n = N(i);// 0 1 randomize the headlight using noise \n        \n        if(n>.1) continue;// jump back to for loop while not executing below \n        \n        // n = 0 0.5 \n        float lane = step(.5,n);// 0 1 \n        \n        float ti = fract(t+i);\n        float z = 100.-ti*100.;\n        float fade =ti*ti*ti*ti*ti;\n        \n        float focus = S(.9,1.,ti);\n        float size = mix(.05,.03,focus);\n        \n        float laneShift = S(.99,.96,ti);\n        float x = 1.5 -lane*laneShift;\n        \n        float blink = step(0.,sin(t*10000.))*7.*lane*step(.96,ti);\n   \n        m+= Bokeh(r,vec3(x-w1,.15,z),size,.1)*fade;\n        m+= Bokeh(r,vec3(x+\n        w1,.15,z),size,.1)*fade;\n        \n        m+= Bokeh(r,vec3(x-w2,.15,z),size,.1)*fade;\n        m+= Bokeh(r,vec3(x+\n        w2,.15,z),size,.1)*fade*(1.+blink);\n        \n        \n        float ref = 0.; //reflection \n        ref+= Bokeh(r,vec3(x-w2,-.15,z),size*3.,1.)*fade;\n        ref+= Bokeh(r,vec3(x+\n        w2,-.15,z),size*3.,1.)*fade*(1.+blink*.1);\n        \n        m += ref*focus;//only show reflection when in focus \n    }\n    \n    return vec3(1.,.1,.03)*m;//red\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv-=.5;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    vec2 m = iMouse.xy/iResolution.xy;\n    vec3 camPos = vec3(.5,.2,0.);\n    vec3 lookat = vec3(.5,.2,1.);\n    \n    ray r = GetRay(uv,camPos,lookat,2.);\n   \n    float t = iTime*.5+m.x;  \n\n    vec3 col = Streetlights(r,t);\n    col += Headlights(r,t);\n    col += Taillights(r,t);\n\n\n\nfragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltfWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 130, 130, 368], [370, 370, 402, 402, 448], [450, 450, 479, 479, 520], [522, 522, 574, 574, 718], [720, 720, 754, 754, 1047], [1049, 1049, 1066, 1066, 1106], [1107, 1107, 1139, 1139, 2247], [2249, 2249, 2281, 2281, 3642], [3643, 3643, 3699, 3749, 4157]], "test": "valid"}
{"id": "3ltfz4", "name": "I love aliasing ( sometime :-) )", "author": "FabriceNeyret2", "description": ".", "tags": ["aliasing"], "likes": 8, "viewed": 228, "published": "Public API", "date": "1612357946", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// from https://shadertoy.com/view/Wttfz4\n\nvoid mainImage( out vec4 O,  vec2 u )\n{\n    vec2 R = iResolution.xy;\n    u -= .5* R;\n \n    O = vec4( cos( exp(15.*length(u/R.x)) - 10.*iTime  + vec4(0,1,2,0) ) );\n    \n // if ( u.x > 0.) O /= fwidth(O);           // right: normalize to get B/W strips\n    \n    O = sqrt(.5+.5*O);                       // to sRGB\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltfz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 43, 82, 82, 357]], "test": "valid"}
{"id": "3ltfzM", "name": "Metallic Tubeworms", "author": "dr2", "description": "Seen on another planet", "tags": ["life", "tube", "kinematics"], "likes": 14, "viewed": 227, "published": "Public API", "date": "1612434241", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Metallic Tubeworms\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0  // (=0/1) optional antialising\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrRound4Box2Df (vec2 p, vec2 b, float r);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrEllips2Df (vec3 p, vec2 r);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Maxv3 (vec3 p);\nfloat Minv3 (vec3 p);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nvec3 HsvToRgb (vec3 c);\nfloat Hashfv2 (vec2 p);\nvec4 Hashv4v2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir, qHit;\nvec2 gId;\nfloat tCur, dstFar, hgSize, grLim, sLoop, hBase, lEnd, tubRot, bkAop, szFac, ghMax;\nint idObj;\nconst int idTube = 1, idEx = 2, idEnd = 3, idBk = 4;\nconst float pi = 3.14159, sqrt3 = 1.732051;\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat GrndHt (vec2 p)\n{\n  vec2 gIdL;\n  float h, hh, nl, nf;\n  nf = 0.5;\n  p = (floor (nf * p) +  smoothstep (0.1, 1., mod (nf * p, 1.))) / nf;\n  hh = Fbm2 (0.1 * p);\n  nl = 10.;\n  h = ghMax * (floor (nl * hh) + smoothstep (0.4, 0.6, mod (nl * hh, 1.))) / nl + 0.05 * hh;\n  gIdL = PixToHex (p / hgSize);\n  if (Maxv3 (abs (vec3 (gIdL, dot (gIdL, vec2 (1.))))) <= grLim)\n     h *= 0.2 + 0.8 * smoothstep (0., 2., length (p - HexToPix (gIdL * hgSize)) - 1.5);\n  return h;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.5, 0.8 * h);\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = VAR_ZERO; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (p.y > GrndHt (p.xz)) sLo = s;\n      else sHi = s;\n    }\n    dHit = 0.5 * (sLo + sHi);\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  return normalize (vec3 (GrndHt (p.xz) - vec2 (GrndHt (p.xz + e.xy), GrndHt (p.xz + e.yx)), e.x).xzy);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq;\n  float dMin, d, dLoop, aLoop, rCyl, rc, s, dc, dy;\n  dLoop = 6. * sLoop;\n  aLoop = 0.25 * pi / sLoop;\n  rCyl = 0.6;\n  rc = 0.6;\n  dMin = dstFar / szFac;\n  p.xz -= HexToPix (gId * hgSize);\n  p /= szFac;\n  q = p;\n  dy = - q.y;\n  q.y -= 0.3;\n  d = max (PrRoundCylDf (q.xzy, rCyl + 0.4, 0.1, 0.3), dy);\n  DMINQ (idEx);\n  q = p;\n  q.y -= 2. * lEnd + hBase + 0.3;\n  s = mod (3. * q.y + 0.5, 1.);\n  d = max (max (PrRound4Box2Df (q.xz, vec2 (rCyl * (1. - 0.03 * SmoothBump (0.2, 0.8, 0.15, s))) - rc, rc),\n     abs (q.y + lEnd) - lEnd - 0.01), dy);\n  DMINQ (idEnd);\n  q.xz = Rot2D (q.xz, tubRot);\n  q.xy = Rot2D (q.xy, 0.5 * pi);\n  q.xy = Rot2D (vec2 (q.x, q.y - dLoop), aLoop - 0.5 * pi);\n  s = mod (3. * dLoop * atan (q.y, - q.x) + 0.5, 1.);\n  qq = q;\n  dc = dot (vec2 (q.x, abs (q.y)), sin (aLoop + vec2 (0., 0.5 * pi)));\n  q.xz = Rot2D (vec2 (length (q.xy) - dLoop, q.z), tubRot);\n  d = max (max (PrRound4Box2Df (q.xz, vec2 (rCyl * (1. - 0.03 * SmoothBump (0.2, 0.8, 0.15, s)) - rc),\n     rc), dc), dy);\n  DMINQ (idTube);\n  q = qq;\n  q.xy = Rot2D (q.xy, aLoop) + vec2 (dLoop, 0.);\n  q.xz = Rot2D (q.xz, - tubRot);\n  s = mod (3. * q.y + 0.5, 1.);\n  d = max (max (PrRound4Box2Df (q.xz, vec2 (rCyl * (1. - 0.03 * SmoothBump (0.2, 0.8, 0.15, s))) - rc, rc),\n     abs (q.y - lEnd) - lEnd - 0.01), dy);\n  DMINQ (idEnd);\n  q.y -= 2. * lEnd + 0.1;\n  d = PrRoundCylDf (q.xzy, rCyl + 0.1, 0.05, 0.05);\n  DMINQ (idEx);\n  q.y -= 0.2;\n  d = PrCapsDf (q.xzy, 0.25, 0.25);\n  DMINQ (idEx);\n  q.y -= 1.2;\n  q.xz = abs (q.xz);\n  q.xz = (q.x + q.z * vec2 (-1., 1.)) / sqrt(2.);\n  q.yz = Rot2D (q.yz + vec2 (0.7, 0.), bkAop) - vec2 (0.8, 0.);\n  d = max (abs (PrEllips2Df (q.xzy, vec2 (0.5, 1.))) - 0.02, - 0.01 - (q.z - abs (q.x)) / sqrt(2.));\n  DMINQ (idBk);\n  return 0.8 * szFac * dMin;\n}\n\nvoid SetObjConf ()\n{\n  vec4 r4;\n  float tCyc, t;\n  r4 = Hashv4v2 (19.1 * gId + 99.1);\n  tCyc = 20. + 10. * r4.x;\n  t = (tCur + 13.1) / tCyc;\n  tubRot = mod ((10. + 5. * r4.y) * t, 2. * pi) * sign (r4.z - 0.5);\n  t = mod (t, 1.);\n  sLoop = (1. / (1. + 0.25 * r4.w)) / (0.01 + 0.99 * SmoothBump (0.25, 0.75, 0.15, t));\n  lEnd = 1.;\n  hBase = - (6. * (0.5 * pi) + 4. * lEnd) * (1. - SmoothBump (0.1, 0.9, 0.08, t));\n  bkAop = -0.5 * pi * SmoothBump (0.25, 0.75, 0.15, mod ((12. - 0.6 * r4.y) * t, 1.)) *\n     SmoothBump (0.3, 0.7, 0.1, t);\n  szFac = 0.7 + 0.3 * r4.w;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s, eps;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  eps = 0.0005;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]), dot (ro.xz, edN[2])) / hgSize;\n  pM = HexToPix (PixToHex (ro.xz / hgSize));\n  hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n  s = Minv3 (hv);\n  gIdP = vec2 (-999.);\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + dHit * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (Maxv3 (abs (vec3 (gId, dot (gId, vec2 (1.))))) <= grLim) {\n      if (gId != gIdP) {\n        gIdP = gId;\n        SetObjConf ();\n      }\n      d = ObjDf (p);\n    } else d = dstFar;\n    if (dHit + d < s) dHit += d;\n    else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n      hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n      s = Minv3 (hv);\n    }\n    if (d < eps || dHit > dstFar || p.y < 0.) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.002, -0.002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat GrndSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    p = ro + d * rd;\n    h = p.y - GrndHt (p.xz);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += clamp (h, 0.01, 1.);\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 gIdP;\n  float sh, d, h;\n  sh = 1.;\n  gIdP = vec2 (-999.);\n  d = 0.05;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    p = ro + d * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (Maxv3 (abs (vec3 (gId, dot (gId, vec2 (1.))))) <= grLim) {\n      if (gId != gIdP) {\n        gIdP = gId;\n        SetObjConf ();\n      }\n      h = ObjDf (p);\n      sh = min (sh, smoothstep (0., 0.05 * d, h));\n    } else h = 0.1;\n    d += clamp (h, 0.01, 1.);\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 SkyBg (vec3 rd)\n{\n  return mix (vec3 (0.2, 0.3, 0.7), vec3 (0.4, 0.4, 0.55), pow (1. - max (rd.y, 0.), 8.));\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  float f;\n  ro.x -= tCur;\n  f = Fbm2 (0.01 * (ro + rd * (200. - ro.y) / (rd.y + 0.0001)).xz);\n  return mix (SkyBg (rd), vec3 (1.), clamp (f * rd.y, 0., 1.));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstGrnd, dstObj, nDotL, sh;\n  dstObj = ObjRay (ro, rd);\n  dstGrnd = GrndRay (ro, rd);\n  if (min (dstObj, dstGrnd) < dstFar) {\n    if (dstObj < dstGrnd) {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      col4 = vec4 (HsvToRgb (vec3 (0.9 * Hashfv2 (17.1 * gId), 0.3, 0.9)), 0.1);\n      if (idObj == idTube || idObj == idEnd) col4 = col4 * (0.93 + 0.07 * smoothstep (-0.1, 0.,\n         cos (32. * atan (qHit.z, - qHit.x))));\n      else if (idObj == idEx) col4 *= 0.9;\n      else if (idObj == idBk) col4 = (PrEllips2Df (qHit.xzy, vec2 (0.5, 1.)) < -0.01) ?\n         vec4 (0.8 + 0.2 * sin (32. * pi * tCur), 0., 0., -1.) : col4 *\n         (0.9 + 0.1 * smoothstep (-0.7, -0.6, cos (64. * qHit.y)));\n      if (col4.a >= 0.) {\n        nDotL = max (dot (vn, sunDir), 0.);\n        nDotL *= nDotL;\n        sh = ObjSShadow (ro + 0.01 * vn, sunDir);\n        col = col4.rgb * (0.2 + 0.8 * sh * nDotL) + col4.a * step (0.95, sh) *\n           pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n      } else col = col4.rgb * (0.6 - 0.4 * dot (vn, rd));\n    } else {\n      ro += dstGrnd * rd;\n      vn = GrndNf (ro);\n      vn = VaryNf (ro, vn, 1.);\n      col = mix (vec3 (0.4, 0.4, 0.1), vec3 (0.8, 0.7, 0.7), mod (floor (10. * ro.y / ghMax) / 10., 1.));\n      col *= 1. - 0.2 * Fbm2 (64. * ro.xz);\n      sh = GrndSShadow (ro + 0.01 * vn, sunDir);\n      gId = PixToHex (ro.xz / hgSize);\n      if (Maxv3 (abs (vec3 (gId, dot (gId, vec2 (1.))))) <= grLim)\n         sh = min (sh, ObjSShadow (ro + 0.01 * vn, sunDir));\n      col *= 0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.);\n    }\n    col = mix (col, SkyBg (rd), pow (min (dstObj, dstGrnd) / dstFar, 4.));\n  } else {\n    col = SkyCol (ro, rd);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvv;\n  float el, az, zmFac, asp, sr, t, ar;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  hgSize = 12.;\n  grLim = 12.;\n  ghMax = 1.5;\n  el = -0.08 * pi;\n  az = 0.;\n  if (mPtr.z > 0.) {\n    az += 0.4 * pi * mPtr.x;\n    el += 0.25 * pi * mPtr.y;\n  }\n  t = mod (0.003 * tCur, 2.);\n  ar = -0.5 * pi + 2.5 * pi * (0.5 - abs ((floor (32. * t) + smoothstep (0.8, 1.,\n     mod (32. * t, 1.))) / 32. - 1.));\n  az -= ar;\n  ro = vec3 (0., 15., - 1.02 * sqrt3 * hgSize * grLim);\n  ro.xz = Rot2D (ro.xz, ar);\n  sunDir = normalize (vec3 (1., 1., -1.));\n  sunDir.xz = Rot2D (sunDir.xz, ar);\n  el = clamp (el, -0.2 * pi, -0.01 * pi);\n  vuMat = StdVuMat (el, az);\n  zmFac = 3.;\n  dstFar = 2. * sqrt3 * hgSize * grLim;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi)) / zmFac;\n    rd = vuMat * normalize (vec3 ((2. * tan (0.5 * atan (uvv.x / asp))) * asp, uvv.y, 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat Length4 (vec2 p)\n{\n  p *= p;\n  return sqrt (sqrt (dot (p, p)));\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrRound4Box2Df (vec2 p, vec2 b, float r)\n{\n  return Length4 (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nfloat PrEllips2Df (vec3 p, vec2 r)\n{\n  return (length (p / r.xxy) - 1.) * min (r.x, r.y);\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39);\n  return fract (sin (dot (p, cHashVA2) + vec4 (0., cHashVA2.xy, cHashVA2.x + cHashVA2.y)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltfzM.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 1128, 1151, 1151, 1597], [1599, 1599, 1633, 1633, 2113], [2115, 2115, 2137, 2137, 2276], [2278, 2278, 2300, 2300, 4082], [4084, 4084, 4104, 4104, 4650], [4652, 4652, 4685, 4685, 6025], [6027, 6027, 6048, 6048, 6303], [6305, 6305, 6343, 6343, 6621], [6623, 6623, 6660, 6660, 7167], [7169, 7169, 7191, 7191, 7284], [7286, 7286, 7318, 7318, 7479], [7481, 7481, 7516, 7516, 9273], [9275, 9275, 9328, 9328, 10764], [10766, 10766, 10790, 10790, 10837], [10839, 10839, 10872, 10872, 10899], [10901, 10901, 10949, 10949, 10997], [10999, 10999, 11056, 11056, 11132], [11134, 11134, 11177, 11177, 11250], [11252, 11252, 11288, 11288, 11343], [11345, 11345, 11367, 11367, 11405], [11407, 11407, 11429, 11429, 11467], [11469, 11469, 11493, 11493, 11723], [11725, 11725, 11749, 11749, 11809], [11811, 11811, 11847, 11847, 12053], [12055, 12055, 12085, 12085, 12198], [12200, 12200, 12257, 12257, 12340], [12342, 12342, 12366, 12366, 12483], [12517, 12517, 12541, 12541, 12601], [12603, 12603, 12627, 12627, 12757], [12759, 12759, 12783, 12783, 12920], [12922, 12922, 12947, 12947, 13133], [13135, 13135, 13156, 13156, 13311], [13313, 13313, 13342, 13342, 13554], [13556, 13556, 13595, 13595, 13775]], "test": "error"}
{"id": "3lVBz1", "name": "nonlinear ripples in aether x", "author": "sense", "description": "hack of https://www.shadertoy.com/view/XtVczV  i have no idea what im doing :) .. ", "tags": ["mod", "learning", "hack"], "likes": 0, "viewed": 47, "published": "Public", "date": "1613889105", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// http://bit.ly/supersinfulsilicon\n// @Carandiru on twitter - follow me!\n\n//hack of ^ i have no idea what im doing :) .. \n\nvoid pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tp = mod(p + halfsize, size) - halfsize;\n}\n\nvoid pMod3(inout vec3 p, vec3 size) {\n    \n\tp = mod(p - size*1.5, size) - size*0.5;\n}\n\nfloat sphere(vec3 p, float radius){\n    return length(p)-radius;\n\n}\n\n\nfloat map(vec3 p)\n{\n    vec3 q = p;\n\tvec3 qa = p;\n    pMod3(q, vec3(0.8, 1., 0.23));\n\tpMod3(qa, vec3(0.8, 1., 0.18));\n    pMod1(p.x, 1.);\n    \n    float s1 = sphere(p, 0.75); \n    float s2 = sphere(q, 0.5);  \t    \t\n    float s3 = sphere(qa, 0.555);\n    \n  \tfloat df1 = min(min(s1, s2),s3); // Union\n\n    return df1;\n}\n\n\nfloat trace(vec3 origin, vec3 r) \n{\n  float t = cos(1.0);\n    for (int i = 0; i < 64; ++i) {\n        vec3 p = iTime*origin *iResolution *0.00000005 +iTime*0.000005 -r  - t*5.1;\n        float d = map(p);\n        t += d*0.222;\n        }\n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord-tan(iResolution.xy)+fragCoord+sin(iResolution.yx)+cos(iTime)*0.00000045;\n    vec3 color = vec3(0.324, 0.12, 0.536);\n    uv = uv /1.-1.; // Remap the space to -1. to 1.\n    uv.x += iResolution.y/iResolution.x+iResolution.x*iResolution.y*0.00004;\n    \n    \t\n   \tfloat FOV = 0.25/iResolution.x-iResolution.y - 0.0025/iResolution.y+iResolution.x;\n   \tvec3 ray = normalize(vec3(uv, FOV));\n    \n    \n    vec3 origin = vec3(iTime, 10.0, 1.75);\n    float t = trace(origin, ray);\n    \n    float expFog = 0.5 / (t*t* 0.55);\n    \n    vec3 fc = vec3(expFog);\n    \n    if ( t < -0.9f ) {\n        color = 0.25-(0.5/t*color);\n        vec3 maincolor = exp(-(fc*color)*3.6f);\n        color = (1.0f - maincolor);\n        color = cos(color) * maincolor;\n    }\n    else\n        color = sinh(vec3(0));\n    \n    fragColor = vec4(color,dot(color, vec3(0.5)) * exp(-expFog));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVBz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 124, 163, 163, 234], [236, 236, 273, 273, 321], [323, 323, 358, 358, 390], [393, 393, 412, 412, 710], [713, 713, 748, 748, 963], [966, 966, 1023, 1023, 1901]], "test": "error"}
{"id": "3lVfR1", "name": "Whoa my kinda beams hack  ", "author": "sense", "description": "hack of  Carandiru https://www.shadertoy.com/view/XtVczV\n\nI have no idea what im doing i am just playing around hacking this code.. please advise me of any objections.. im just trying to learn :D \nrespect.. ", "tags": ["n00b", "mod", "hack"], "likes": 0, "viewed": 36, "published": "Public", "date": "1613885582", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// http://bit.ly/supersinfulsilicon\n// @Carandiru on twitter - follow me!\n\n//hack of ^ i have no idea what im doing :) .. \n\n\nvoid pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tp = mod(p + halfsize, size) - halfsize;\n}\n\nvoid pMod3(inout vec3 p, vec3 size) {\n    \n\tp = mod(p - size*1.5, size) - size*0.5;\n}\n\nfloat sphere(vec3 p, float radius){\n    return length(p)-radius;\n\n}\n\n\nfloat map(vec3 p)\n{\n    vec3 q = p;\n\tvec3 qa = p;\n    pMod3(q, vec3(0.8, 1., 0.23));\n\tpMod3(qa, vec3(0.8, 1., 0.18));\n    pMod1(p.x, 1.);\n    \n    float s1 = sphere(p, 0.75); \n    float s2 = sphere(q, 0.5);  \t    \t\n    float s3 = sphere(qa, 0.555);\n    \n  \tfloat df1 = min(min(s1, s2),s3); // Union\n\n    return df1;\n}\n\n\nfloat trace(vec3 origin, vec3 r) \n{\n  float t = cos(1.0);\n    for (int i = 0; i < 32; ++i) {\n        vec3 p = iTime*origin *iResolution *0.00000001 *iTime +r + t*7.2;\n        float d = map(p);\n        t += d*0.222;\n        }\n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord-tan(iResolution.xy)+fragCoord-sin(iResolution.yx)+cos(iTime)*0.00000045;\n    vec3 color = vec3(0.324, 0.12, 0.536);\n    uv = uv /1.-1.; // Remap the space to -1. to 1.\n    uv.x += iResolution.y/iResolution.x+iResolution.x*iResolution.y*0.00004;\n    \n    \t\n   \tfloat FOV = 0.25/iResolution.x-iResolution.y - 0.0025/iResolution.y+iResolution.x;\n   \tvec3 ray = normalize(vec3(uv, FOV));\n    \n    \n    vec3 origin = vec3(iTime, 10.0, 1.75);\n    float t = trace(origin, ray);\n    \n    float expFog = 0.5 / (t*t* 0.55);\n    \n    vec3 fc = vec3(expFog);\n    \n    if ( t < -0.9f ) {\n        color = 0.25-(0.5/t*color);\n        vec3 maincolor = exp(-(fc*color)*3.6f);\n        color = (1.0f - maincolor);\n        color = cos(color) * maincolor;\n    }\n    else\n        color = sinh(vec3(0));\n    \n    fragColor = vec4(color,dot(color, vec3(0.5)) * exp(-expFog));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVfR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 125, 164, 164, 235], [237, 237, 274, 274, 322], [324, 324, 359, 359, 391], [394, 394, 413, 413, 711], [714, 714, 749, 749, 954], [957, 957, 1014, 1014, 1892]], "test": "error"}
{"id": "3lVfzh", "name": "Lightning and Sunshine", "author": "timeisbeautifulhere", "description": "For a good friend of mine.\n\nThe code is hilariously sloppy though, please don't scrutinize it :P", "tags": ["sun", "lightning", "thunder", "sunshine"], "likes": 3, "viewed": 175, "published": "Public API", "date": "1613876186", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define LIGHTNING_POINTS 12\n\n#define LIGHTNING_COLOR vec3(0.0,0.0,1.0)\n#define OFFSET 0.05\n#define OFFSET_TIMECONST 45.0\n//This looks interesting\n//#define OFFSET_TIMECONST 175.0\n#define SCALE_FACTOR 0.95\n#define WHITE vec3(1.0)\n\n#define SUN_POS vec2(0.0,0.7)\n#define SUN_RADIUS 0.2\n#define SUN_COLOR vec3(1.0,0.84,0.0)\n\n#define SUNRAY_RADIUS 0.7\n#define SUNRAY_COUNT 14.0\n#define SUNRAY_STRIPE_COUNT 10.0\n#define SUNRAY_SCALE 0.5\n#define SUNRAY_STRIPE_THICKNESS 0.01\n#define SUNRAY_COLOR vec3(1.0,0.41,0.0)\n#define SUNRAY_TIME_CONST 0.3\n\n#define PI 3.14159\n\n#define L_CLOSE 1\n#define L_MID 2\n#define L_FAR 3\n#define L_NONE 0\n#define L_DEBUG 10\n#define L_DEBUG2 11\n\n#define S_ORB 1\n#define S_RAY 2\n#define S_NONE 0\n\n#define BEAN_COUNT_X 8.0\n#define BEAN_COUNT_Y 5.0\n#define BEAN_THICKNESS 0.02\n#define BEAN_LENGTH 0.03\n#define BEAN_TIME_CONST 0.05\n#define BEAN_COLOR vec3(0.5,0.05,0.0)\n\nint lightning_check(vec2 uv){\n\n    float sun_y = (SUN_POS.y+1.0)/2.0;\n    if(uv.y>sun_y)\n        return L_NONE;\n    uv.y /= sun_y;\n    if(uv.y>0.95)\n        return L_NONE;\n    \n    float lightning_width = SUNRAY_RADIUS/2.0;\n    \n    int l_points = LIGHTNING_POINTS;\n    \n    int lightning_n1 = int(floor(uv.y*float(l_points)));\n    int lightning_n2 = int(ceil(uv.y*float(l_points)));\n    \n    float lightning_y1 = float(lightning_n1)/float(l_points);\n    float lightning_y2 = float(lightning_n2)/float(l_points);\n    \n    float width_n1 = lightning_width*lightning_y1,\n        width_n2 = lightning_width*lightning_y2;\n    \n    float scale1 = pow(SCALE_FACTOR, float(l_points)-float(lightning_n1)),\n        scale2 = pow(SCALE_FACTOR, float(l_points)-float(lightning_n2));\n    width_n1 *= scale1;\n    width_n2 *= scale2;\n    \n    float uv_interp = (lightning_y2-uv.y)/(lightning_y2-lightning_y1);\n    float width_uv = mix(width_n2, width_n1, uv_interp);\n    \n    float offset_offset = sin(iTime*OFFSET_TIMECONST);\n\n    float offset1 = OFFSET * scale1 * offset_offset,\n        offset2 = -1.0 * OFFSET * scale2 * offset_offset;\n    if(lightning_n1%2==0){\n        offset1*=-1.0;\n        offset2*=-1.0;\n    }\n    \n    if(lightning_n1==0)\n        offset1 = 0.0;\n    \n    float left_n1 = (-1.0)*width_n1/2.0+offset1,\n        right_n1 = width_n1/2.0+offset1,\n        left_n2 = (-1.0)*width_n2/2.0+offset2,\n        right_n2 = width_n2/2.0+offset2;\n\n    float left_uv = mix(left_n2, left_n1, uv_interp),\n        right_uv = mix(right_n2, right_n1, uv_interp),\n        middle_uv = (left_uv+right_uv)/2.0;\n    \n    if(uv.x < left_uv || uv.x > right_uv)\n        return L_NONE;\n    \n    float dist_uv = abs(uv.x-middle_uv);\n    float dist_proportion = 2.0*dist_uv/width_uv;\n    \n    if(dist_proportion<0.4)\n        return L_CLOSE;\n    if(dist_proportion<0.8)\n        return L_MID;\n    else if(dist_proportion<=1.0)\n        return L_FAR;\n    else if(dist_proportion>1.0)\n        return L_FAR;\n    else\n        return L_NONE;\n}\n\nint sun_check(vec2 uv){\n    vec2 sun_pos = SUN_POS;\n    uv.y = 2.0*uv.y-1.0;\n    vec2 relative_uv = uv - sun_pos;\n    vec2 relative_pc = vec2(\n        atan(relative_uv.y, relative_uv.x),\n        length(relative_uv)\n    );\n    \n    if(relative_pc[1]>SUNRAY_RADIUS)\n        return S_NONE;\n    \n    if(relative_pc[1]<=SUN_RADIUS)\n        return S_ORB;\n    \n    if(relative_pc[1]<=SUNRAY_RADIUS){\n        \n        //angle = [0,2PI]\n        float uv_angle = relative_pc[0]+PI;\n        float angle_displace = mod(iTime*SUNRAY_TIME_CONST, 2.0*PI);\n        uv_angle += angle_displace;\n        \n        float ray_angle_size = 2.0*PI/SUNRAY_COUNT;\n        float ray_n = floor(uv_angle/ray_angle_size);\n        float ray_angle_displace = (ray_angle_size - (ray_angle_size*SUNRAY_SCALE))/2.0;\n        \n        float ray_start = ray_n * ray_angle_size + ray_angle_displace,\n            ray_end = (ray_n+1.0) * ray_angle_size - ray_angle_displace;\n        \n        //Check if angle is in \"bounds\" of closest ray\n        if(uv_angle<ray_start || uv_angle>ray_end)\n            return S_NONE;\n        \n        //Finally, check if distance from sun puts\n        //uv on a \"ray stripe\"\n        float dist_outside_sun = relative_pc[1]-SUN_RADIUS;\n        float ray_length = SUNRAY_RADIUS-SUN_RADIUS;\n        float stripe_dist = ray_length/SUNRAY_STRIPE_COUNT;\n        \n        float closest_stripe_n = floor(dist_outside_sun/stripe_dist),\n            closest_stripe = closest_stripe_n * stripe_dist;\n        \n        if(closest_stripe_n<0.001)\n            return S_NONE;\n        \n        if(abs(closest_stripe-dist_outside_sun)<SUNRAY_STRIPE_THICKNESS)\n            return S_RAY;\n        \n        \n        return S_NONE;\n    }\n    return S_NONE;\n}\n\nbool bean_check(vec2 uv){\n    //[0,1]\n    uv.x = (uv.x+1.0)/2.0;\n    uv.x = fract(uv.x - iTime*BEAN_TIME_CONST);\n\n    float bean_dy = 1.0/BEAN_COUNT_Y,\n        bean_dx = 1.0/BEAN_COUNT_X;\n    \n    float closest_bean_y_n = round(uv.y/bean_dy),\n        closest_bean_x_n = round(uv.x/bean_dx);\n    \n    float closest_bean_y = closest_bean_y_n * bean_dy,\n        closest_bean_x = closest_bean_x_n * bean_dx;\n    \n    if(abs(closest_bean_y-uv.y)<BEAN_THICKNESS\n        && abs(closest_bean_x-uv.x)<BEAN_LENGTH){\n        //return true;\n        \n        float x_relative = uv.x-closest_bean_x;\n        if(abs(x_relative)<(BEAN_LENGTH-BEAN_THICKNESS))\n            return true;\n    \n        //Check if inside bounds of a rounded edge\n        //by making ends semicircles\n        vec2 bean_edge = vec2(0.0);\n        \n        if(x_relative<0.0){\n            bean_edge = vec2(\n                closest_bean_x-BEAN_LENGTH+BEAN_THICKNESS,\n                closest_bean_y\n            );\n        }else{\n            bean_edge = vec2(\n                closest_bean_x+BEAN_LENGTH-BEAN_THICKNESS,\n                closest_bean_y\n            );\n        }\n        \n        return distance(uv,bean_edge)<=BEAN_THICKNESS;\n            \n    }\n    else\n        return false;\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // x = [-1,1], y = [0,1]\n    vec2 uv = vec2(\n        (2.0*fragCoord.x-iResolution.x)/iResolution.x,\n        fragCoord.y/iResolution.y\n    );\n    vec3 col = vec3(0.0);\n    \n    if(bean_check(uv))\n        col = BEAN_COLOR;\n    \n    int s_check = sun_check(uv);\n    int l_check = lightning_check(uv);\n    \n    if(s_check == S_RAY)\n        col = SUNRAY_COLOR;\n    \n    if(l_check == L_CLOSE)\n        col = mix(LIGHTNING_COLOR, WHITE, 0.7);\n    else if(l_check == L_MID)\n        col = mix(LIGHTNING_COLOR, WHITE, 0.3);\n    else if(l_check == L_FAR)\n        col = LIGHTNING_COLOR;\n    \n    if(s_check == S_ORB)\n        col = SUN_COLOR;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVfzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[122, 888, 917, 917, 2897], [2899, 2899, 2922, 2922, 4625], [4627, 4627, 4652, 4664, 5871], [5878, 5878, 5935, 5964, 6631]], "test": "valid"}
{"id": "3lVfzR", "name": "Blob physics (forked from LeWIZ)", "author": "Johnrobmiller", "description": "A simplified version I made purely for the purposes of studying these interesting blob physics.  I also renamed some variables and did some other things to make it more readable.  Original link: https://www.shadertoy.com/view/4ll3R7\n", "tags": ["metaballs", "blob", "lewiz", "softbodyphysics"], "likes": 1, "viewed": 137, "published": "Public", "date": "1613766119", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ---------------- //\n// MAKING THE BLOBS //\n// ---------------- //\n\nfloat sphere(vec3 pos) {\n    float distanceFromCenter = length(pos);\n    float sphereRadius = 1.0;\n\treturn distanceFromCenter - sphereRadius;\n}\n\nfloat makeBlobs(float s1, float s2) {\n    float k = -6.0;\n    return log( exp(k*s1) + exp(k*s2)) / k; // THE MAIN EQUATION THAT MAKES THE BLOBS BUD OFF OF EACH OTHER\n}\n\nfloat makeScene(vec3 pos) {\n    float blobVelocity = 1.0;\n    \n    // BECAUSE THIS IS THE CENTER BLOB, THE POSITION IS LEFT EXACTLY AS IT IS\n    float s1 = sphere(pos);\n    \n    // BECAUSE THIS BLOB ROTATES AROUND THE CENTER BLOB, ITS POSITION IS OFFSET USING SIN/COS OSCILLATION.\n    // IF THE CENTER OF THE NEW BLOB IS, FOR EXAMPLE, (2,1) AWAY FROM THE TRUE CENTER, THEN WE CALL THE\n    // \"SPHERE\" FUNCTION AGAIN USING THE NEW OFFSET VALUE OF (2,1).\n    vec3 posOffset = pos + blobVelocity * vec3(cos(iTime * 0.7),cos(iTime *1.9),cos(iTime * 2.3));\n    float s2 = sphere(posOffset);\n    \n    return makeBlobs(s1, s2);\n}\n\n// -------------------------------- //\n// GETTING THE DISTANCE FROM CAMERA //\n// -------------------------------- //\n\nfloat intersection( in vec3 camPos, in vec3 camDir ) {\n\tconst float maxD = 20.0;\n\tconst float precis = 0.001;\n    float h = precis * 2.0;\n    float t = 0.0;\n    for( int i = 0; i < 90; i++ ) {\n        if(h < precis || t > maxD) break;\n\t    h = makeScene(camPos + camDir * t);\n        t += h;\n    }\n\n    if( t > maxD ) t = 0.0;\n    return t;\n}\n\n// ------------------- //\n// CALCULATING NORMALS //\n// ------------------- //\n\nvec3 calcNormal( in vec3 pos ) {\n    const float eps = 0.1;\n\n    // AN ORTHOGONAL 4X3 MATRIX USED FOR THE MATHS BELOW\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n    // IF THERE WERE ONLY ONE SPHERE IN THE MIDDLE, YOU COULD GET THE NORMALS BY MERELY\n    // NORMALIZING THE POSITION. HOWEVER, WHEN THERE IS MORE THAN ONE SPHERE, YOU\n    // GET THE NORMALS BY NORMALIZING THE POSITION RELATIVE TO THE POSITION OF THE CENTER\n    // OF EACH SPHERE. THE \"MAKE SCENE\" FUNCTION DOES JUST THAT.\n\treturn normalize( v1 * makeScene( pos + v1 * eps ) + \n\t\t\t\t\t  v2 * makeScene( pos + v2 * eps ) + \n\t\t\t\t\t  v3 * makeScene( pos + v3 * eps ) + \n\t\t\t\t\t  v4 * makeScene( pos + v4 * eps ) );\n\n}\n\n\n// ------------------------- //\n// CAMERA AND LIGHTING STUFF //\n// ------------------------- //\n\nfloat shineLightAtBlobs( in vec3 pos , in vec3 camDir) {\n    vec3 normal = calcNormal(pos);\n    \n    return acos(dot(normal, camDir)) / 3.14159;\n    // equation for lighting found here: https://onlinemschool.com/math/library/vector/angl/\n}\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll ) {\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n\n// ---- //\n// MAIN //\n// ---- //\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 xy = (fragCoord.xy - iResolution.xy/2.0) / min(iResolution.xy.x, iResolution.xy.y);\n\n    vec2 mouse = (iMouse.xy - iResolution.xy/2.0) / min(iResolution.xy.x, iResolution.xy.y);\n    \n    float t = 0.5;\n    vec3 camPos = vec3(8.0*sin(0.3*t + 3.0*mouse.x),0.0,-8.0*cos(0.3*t + 3.0*mouse.x));\n    vec3 camTar = vec3(0.0,0.0,0.0);\n    \n    mat3 camMat = calcLookAtMatrix( camPos, camTar, 0.0 );  // 0.0 is the camera roll\n\tvec3 camDir = normalize( camMat * vec3(xy,1.5) ); // 2.0 is the lens length\n    \n    float distanceFromCam = intersection(camPos, camDir);\n    //fragColor = vec4(distanceFromCam / 15.0);\n    \n    vec3 inters = camPos + 1.1*distanceFromCam*camDir;\n    vec3 finalOutput = vec3(shineLightAtBlobs(inters, camDir));\n    //fragColor = vec4(calcNormal(inters), 1.0);\n\tfragColor = vec4(finalOutput, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVfzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 70, 94, 94, 213], [215, 215, 252, 252, 382], [384, 384, 411, 411, 1006], [1008, 1126, 1180, 1180, 1468], [1470, 1549, 1581, 1581, 2347], [2350, 2447, 2503, 2503, 2686], [2687, 2687, 2751, 2751, 2929], [2932, 2966, 3023, 3023, 3850]], "test": "valid"}
{"id": "3lyBDw", "name": "Something  227", "author": "gaz", "description": "3d", "tags": ["3d"], "likes": 10, "viewed": 105, "published": "Public", "date": "1614391376", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(t)(cos((vec3(0,2,-2)/3.+t)*6.24)*.5+.5)\n#define D(a)length(vec2(fract(log(length(a.xy))-iTime*.5)-.5,a.z))/3.-.005*pow(l,.03)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution;\n    for(float g,e,i=0.,l;\n        ++i<99.;\n        e<.005?O.xyz+=mix(vec3(1),H(l),.7)/i:p\n        )\n    {\n        p=R(g*normalize(vec3((C-.5*r.xy)/r.y,1.))-vec3(0,0,6),\n            normalize(vec3(1,2,0)),\n            iTime*.2\n        );\n        l=length(p);\n        g+=e=min(min(D(p),D(p.zxy)),D(p.yzx));    \n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lyBDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[195, 195, 231, 231, 589]], "test": "valid"}
{"id": "3lyBW1", "name": "Anya's Rose", "author": "lmno", "description": "Just wow.\n(for my sis ;) )", "tags": ["lmnorose"], "likes": 4, "viewed": 52, "published": "Public", "date": "1614223540", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License CC0: Voronot Rose\n//  Based upon: https://https://www.shadertoy.com/view/wtVBRw\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          5.1401592654\n#define TAU         (3.0*PI)\n#define L2(x)       dot(x, x)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat pabs(float a, float k) {\n  return pmax(a, -a, k);\n}\n\nfloat height(vec2 p) {\n  p *= 0.4;\n  float d = length(p);\n  p *= ROT(TIME*0.1-1.5*d) ;\n  float c = 1E6;\n  float x = pow(d, 0.1);\n  float y = atan(p.x, p.y) / TAU;\n  \n  for (float i = 0.; i < 3.; ++i) {\n    float v = length(fract(vec2(x - TIME*(i)*.005123, fract(y + i*.125)*.5)*20.)*2.-1.);\n    c = pmin(c, v, 0.125);\n  }\n\n  return -0.0125*pabs(tanh_approx(5.5*d-80.*c*c*d*d*(.55-d))-0.25*d, 0.25);\n}\n\nvec3 normal(vec2 p) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(4.0/RESOLUTION.y, 0);\n  \n  vec3 n;\n  n.x = height(p + e.xy) - height(p - e.xy);\n  n.y = 10.0*e.x;\n  n.z = height(p + e.yx) - height(p - e.yx);\n  \n  return normalize(n);\n}\n\nvec3 color(vec2 p) {\n  const float s = 1.0;\n  const vec3 lp1 = vec3(1.0, 1.25, 1.0)*vec3(s, 1.0, s);\n  const vec3 lp2 = vec3(-1.0, 1.25, 1.0)*vec3(s, 1.0, s);\n\n  float h = height(p);\n  vec3  n = normal(p);\n\n  vec3 ro = vec3(0.0, -10.0, 0.0);\n  vec3 pp = vec3(p.x, 0.0, p.y);\n\n  vec3 po = vec3(p.x, h, p.y);\n  vec3 rd = normalize(ro - po);\n\n  vec3 ld1 = normalize(lp1 - po);\n  vec3 ld2 = normalize(lp2 - po);\n  \n  float diff1 = max(dot(n, ld1), 0.0);\n  float diff2 = max(dot(n, ld2), 0.0);\n\n  vec3  rn    = n;\n  vec3  ref   = reflect(rd, rn);\n  float ref1  = max(dot(ref, ld1), 0.0);\n  float ref2  = max(dot(ref, ld2), 0.0);\n\n  vec3 lcol1 = vec3(1.5, 1.5, 2.0).xzy;\n  vec3 lcol2 = vec3(2.0, 1.5, 0.75).zyx;\n  vec3 lpow1 = 0.15*lcol1/L2(ld1);\n  vec3 lpow2 = 0.5*lcol2/L2(ld2);\n  vec3 dm = vec3(1.0)*tanh(-h*10.0+0.125);\n  vec3 col = vec3(0.0);\n  col += dm*diff1*diff1*lpow1;\n  col += dm*diff2*diff2*lpow2;\n  vec3 rm = vec3(1.0)*mix(0.25, 1.0, tanh_approx(-h*1000.0));\n  col += rm*pow(ref1, 10.0)*lcol1;\n  col += rm*pow(ref2, 10.0)*lcol2;\n\n  return col;\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.5);\n  col = pow(col, 1.0/vec3(2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.55+0.55*pow(19.5*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = color(p);\n\n  col = 4.0*col;\n  // Workaround for some environments that seems to lack a vec3 version of tanh\n  col = vec3(tanh(col.x), tanh(col.y), tanh(col.z));\n  col = 0.99 -col;\n  \n  col = postProcess(col, q);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lyBW1.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[0, 300, 328, 348, 424], [426, 426, 465, 465, 550], [552, 552, 591, 591, 620], [622, 622, 652, 652, 679], [681, 681, 703, 703, 1081], [1083, 1083, 1104, 1104, 1311], [1313, 1313, 1333, 1333, 2365], [2367, 2367, 2403, 2403, 2638], [2640, 2640, 2695, 2695, 3052]], "test": "valid"}
{"id": "3lyBzw", "name": "Shader projet GOPL 2021", "author": "tselmek", "description": "Shader pour le projet de Graphisme par Ordinateur 2021 à TELECOM Nancy", "tags": ["raytracing", "colors", "graphisme"], "likes": 2, "viewed": 47, "published": "Public", "date": "1614035034", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float FARAWAY = 1e30;\nconst float EPSILON = 1e-6;\nconst float PI = 3.1415926535;\n\nconst vec3 zero3 = vec3(0.0, 0.0, 0.0);\nconst vec3 one3  = vec3(1.0, 1.0, 1.0);\n\nstruct Camera {\n    vec3 position;\n    vec3 view;\n    vec3 up;\n    vec3 horizon;\n    float height;\n    float width;\n    float z;\n};\n\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\n\nstruct Sphere {\n    vec3 center;\n    float radius;\n};\n\n\nstruct Material {\n    vec3 Kd; // diffuse color\n    vec3 Ke; // emissive color\n    vec3 Kr; // reflective material\n};\n\n\nstruct Ball {\n    Sphere sphere;\n    Material material;\n};\n\n\n\nCamera camera(in vec3 position, in vec3 target, in float aperture) {\n    Camera C;\n    C.position  = position;\n    C.view      = normalize(target - position);\n    C.horizon   = normalize(cross(vec3(0.0, 0.0, 1.0), C.view));\n    C.up        = cross(C.view, C.horizon);\n    C.width     = float(iResolution.x);\n    C.height    = float(iResolution.y);\n    C.z         = (C.height/2.0) / tan((aperture * PI / 180.0) / 2.0);\n    return C;\n}\n\n\nRay launch(in Camera C, in vec2 pixel) {\n    return Ray(\n        C.position,\n        C.z * C.view + (pixel.x - C.width / 2.0) * C.horizon + (pixel.y - C.height / 2.0) * C.up \n    );\n}\n\n\nMaterial diffuse(in vec3 Kd) {\n    return Material(Kd, zero3, zero3);\n}\n\n\nMaterial light(in vec3 Ke) {\n    return Material(zero3, Ke, zero3);\n}\n\n\nMaterial mirror(in vec3 Kd, in vec3 Kr) {\n    return Material(Kd, zero3, Kr);\n}\n\n// All components are in the range [0…1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nBall SCENE[40];\n\n\nvoid init_scene() {\n    float beta = float(iFrame)/30.0;\n    float s = sin(beta);\n    float c = cos(beta);\n    int k = 0;\n    \n    // Initialisation des sphères\n    for (float x = -1.0; x < 2.0; x = x + 1.0) {\n        for (float y = -1.0; y < 2.0; y = y + 1.0) {\n            for (float z = -1.0; z < 2.0; z = z + 1.0) {\n                SCENE[k++] = Ball(\n                    Sphere(\n                        /* Position */ vec3(x, y, z),\n                        /* Rayon    */ 0.5\n                    ),\n                    /* Couleur */ diffuse(vec3(0.5*(x+1.0), 0.5*(y+1.0), 0.5*(z+1.0)))\n                );\n            }\n        }\n    }\n\n    SCENE[k++] = Ball(\n        Sphere(\n            /* Position */ vec3(0.0, 0.0, -500.0),\n            /* Rayon    */ 495.0\n        ),\n        /* Couleur */ diffuse(vec3(0.5))\n    );\n\n    \n    float alpha = 0.0;\n    for (int K = 0; K < 8; K++) {\n        alpha = float(K) * PI / 4.0;\n        SCENE[k++] = Ball(\n            Sphere(\n                /* Position */ vec3(-5.0 * cos(beta + alpha), 5.0 * sin(beta + alpha), 3.0 * sin(beta + alpha) * cos(alpha + beta)),\n                /* Rayon    */ 0.6\n            ),\n            /* Couleur */ diffuse(hsv2rgb(vec3(float(K)/8.0, 1.0, 1.0)))\n        );\n    }\n\n    SCENE[k++] = Ball(\n        Sphere(\n            /* Position */ vec3(6.0 * cos(beta/1.5), 6.0 * sin(beta/1.5), 9.0),\n            /* Rayon    */ 3.0\n        ),\n        /* Couleur */ light(one3)\n    );\n    SCENE[k++] = Ball(\n        Sphere(\n            /* Position */ vec3(-6.0 * cos(beta), 6.0 * sin(beta), 7.0),\n            /* Rayon    */ 2.0\n        ),\n        /* Couleur */ light(hsv2rgb(vec3(0.5 + 0.5*cos(beta/2.0), 0.5, 1.0)))\n    );\n\n    SCENE[k++] = Ball(\n        Sphere(\n            /* Position */ vec3(0.0, 0.0, 2.0),\n            /* Rayon    */ 1.0\n        ),\n        /* Couleur */ mirror(one3, one3)\n    );\n\n}\n\nbool intersect_sphere(in Ray R, in Sphere S, out float t) {\n    vec3 CO = R.origin - S.center;\n    float a = dot(R.dir, R.dir);\n    float b = 2.0*dot(R.dir, CO);\n    float c = dot(CO, CO) - S.radius * S.radius;\n    float delta = b*b - 4.0*a*c;\n    if(delta < 0.0) {\n        return false;\n    }\n    t = (-b-sqrt(delta)) / (2.0*a);\n    return true;\n}\n\nRay reflect_vector(in Ray I, in vec3 P, in vec3 N) {\n    return Ray(\n        P,\n        -2.0 * dot(N, I.dir) * N + I.dir\n    );\n}\n\nbool shadow(in Ray R) {\n    for(int i = 0; i < SCENE.length(); ++i) {\n        float t;\n        if (\n            SCENE[i].material.Ke == vec3(0.0, 0.0, 0.0)\n            && intersect_sphere(R, SCENE[i].sphere, t)\n            && t > EPSILON\n            && t < 1.0\n        ) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvec3 lighting(in vec3 P, in vec3 N, in Material material) {\n    if(material.Ke != vec3(0.0, 0.0, 0.0)) {\n        return material.Ke;\n    }  \n\n    vec3 result = vec3(0.0, 0.0, 0.0);\n\n    for(int i = 0; i < SCENE.length(); ++i) {\n        if(SCENE[i].material.Ke != vec3(0.0, 0.0, 0.0)) {\n            Ray R2 = Ray(P, SCENE[i].sphere.center);\n            if (!shadow(R2)) {\n                vec3 E = SCENE[i].sphere.center - P;\n                float lamb = max(0.0, dot(E,N) / length(E));\n                result += lamb * material.Kd * SCENE[i].material.Ke;\n            }\n        }\n    }\n\n    return result;\n}\n\nbool nearest_intersection(\n    in Ray R, \n    out vec3 P, out vec3 N, out Material material\n) {\n    float t = FARAWAY;\n\n    for(int i = 0; i < SCENE.length(); ++i) {\n        float cur_t;\n        if (\n            intersect_sphere(R, SCENE[i].sphere, cur_t) \n            && cur_t < t\n            && cur_t > EPSILON\n        ) {\n            t = cur_t;\n            P = R.origin + t*R.dir;\n            N = normalize(P - SCENE[i].sphere.center);\n            material = SCENE[i].material;\n        } \n    }\n    return (t != FARAWAY);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    init_scene();\n\n    float banane = float(iFrame);\n\n    Camera C = camera(\n        /* position */ vec3(4.0 * cos(banane/60.0), 10.0 * sin(banane/60.0), 3.0),\n        /* target   */ vec3(0.0, 0.0, 0.0),\n        /* aperture */ 70.0\n    );\n    Ray R = launch(C, fragCoord);\n\n\n    fragColor = vec4(0.15, 0.15, 0.20, 1.0);\n\n\n    vec3 P;  // Point courant\n    vec3 N;  // Normale\n    Material material; // Couleur\n\n    if(nearest_intersection(R, P, N, material)) {\n        fragColor.rgb = lighting(P, N, material);\n        if(material.Kr != zero3) {\n            vec3 Kr = material.Kr;\n            R = reflect_vector(R, P, N);   \n            if(nearest_intersection(R, P, N, material)) {\n                fragColor.rgb = \n                    Kr*lighting(P,N,material);\n            } else {\n                fragColor = vec4(0.30, 0.30, 0.40, 1.0);\n            }\n\n        }\n    } \n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lyBzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[590, 590, 658, 658, 1024], [1027, 1027, 1067, 1067, 1210], [1213, 1213, 1243, 1243, 1284], [1287, 1287, 1315, 1315, 1356], [1359, 1359, 1400, 1400, 1438], [1440, 1499, 1521, 1521, 1690], [1711, 1711, 1730, 1730, 3576], [3578, 3578, 3637, 3637, 3926], [3928, 3928, 3980, 3980, 4057], [4059, 4059, 4082, 4082, 4392], [4394, 4394, 4453, 4453, 4998], [5000, 5000, 5095, 5095, 5526], [5528, 5528, 5585, 5585, 6462]], "test": "valid"}
{"id": "3lyfRW", "name": "Fractal Experiment - 2 Mandelbro", "author": "Learner_CC", "description": "Mandelbro Demo", "tags": ["2dmandelbro"], "likes": 3, "viewed": 24, "published": "Public", "date": "1613924836", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Mandelbrot Fractor Demo\nvec3 MandelbrotFractor(vec2 st, int depth) {\n    vec2 frac = vec2(0.0);\n    float pct = 0.0;\n    for (int i = 0; i < depth; ++i) {\n        frac = vec2(frac.x * frac.x - frac.y * frac.y, 2.0 * frac.x * frac.y) + st;\n        if (dot(frac, frac) > 4.0) {\n            float s = 0.05 * float(i);\n            pct = cos(s + 0.5) * 0.4 + 0.6;\n            return vec3(pct);\n        }\n    }\n    return vec3(0.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy / iResolution.xy;\n    vec2 uv = 2.0 * st - 1.0;\n    uv -= vec2(0.0, 0.3);\n    uv *= 2.0;\n    \n    uv *= mat2(0.0, 1.0, -1.0, 0.0);\n   \n    float n = 128.0;\n    float time = n * smoothstep(0.0, n, abs(mod(iTime * 20.0 + n, n * 2.0) - n));\n    int depth = int(time) + 2;\n    vec3 color = MandelbrotFractor(uv, depth);\n \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lyfRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 27, 71, 71, 431], [432, 432, 489, 489, 870]], "test": "valid"}
{"id": "3lyfzw", "name": "Neural Fox", "author": "PauloFalcao", "description": "A fox\n\nMade using blackle https://www.shadertoy.com/view/wtVyWK\nAnd this wonderful tutorial https://www.youtube.com/watch?v=8pwXpfi-0bU\n\nUsing Ida Faber model - CC Attribution\nhttps://sketchfab.com/3d-models/stylized-fox-92c2a35e54664974b8564c674cc712da\n", "tags": ["fox", "neuralnetworks"], "likes": 21, "viewed": 332, "published": "Public API", "date": "1614043700", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n// Model trained by PauloFalcao\n//\n// Made using blackle https://www.shadertoy.com/view/wtVyWK\n// And this wonderful tutorial https://www.youtube.com/watch?v=8pwXpfi-0bU\n//\n// Using Ida Faber model - CC Attribution - https://creativecommons.org/licenses/by/4.0/\n// https://sketchfab.com/3d-models/stylized-fox-92c2a35e54664974b8564c674cc712da\n//\n\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat scene(vec3 p) {\n    //sdf is undefined outside the unit sphere, uncomment to witness the abominations\n    if (length(p) > 1.) {\n        return length(p)-.8;\n    }\n    p.y=-sqrt(p.y*p.y+0.001)+0.01;\n    //neural networks can be really compact... when they want to be\nvec4 f0_0=sin(p.y*vec4(1.627,-3.273,.822,-1.929)+p.z*vec4(4.114,.716,-3.074,2.185)+p.x*vec4(2.235,.937,3.908,-1.072)+vec4(6.915,3.461,-1.359,1.899));\nvec4 f0_1=sin(p.y*vec4(-.001,-3.255,1.831,.966)+p.z*vec4(-3.328,.890,1.475,-.323)+p.x*vec4(.290,-1.169,-4.054,3.146)+vec4(-4.517,-2.674,6.099,.070));\nvec4 f0_2=sin(p.y*vec4(3.113,-1.089,2.397,-.459)+p.z*vec4(-4.309,1.202,1.134,2.052)+p.x*vec4(-1.018,.550,-3.955,4.027)+vec4(-7.136,2.863,-1.640,-5.590));\nvec4 f0_3=sin(p.y*vec4(.343,1.509,4.401,-1.962)+p.z*vec4(1.198,1.852,2.207,-4.658)+p.x*vec4(2.067,.056,-.156,-.631)+vec4(-4.943,.051,7.095,3.128));\nvec4 f1_0=sin(mat4(.234,.264,-.181,.015,1.018,-.023,.417,-.338,.527,-.030,.056,-.005,-.843,.446,-.139,-.079)*f0_0+\n    mat4(-.512,.346,-.264,.380,.135,.249,.118,-.188,-.110,.210,.101,-.157,.126,.259,.262,.446)*f0_1+\n    mat4(.595,.318,.262,-.279,.802,.891,-.050,-.347,.131,-.369,.420,-.025,-.217,-.197,.152,.931)*f0_2+\n    mat4(.522,.906,-.530,.246,.685,.684,-.106,.175,.437,.507,-.459,.127,.342,-.398,-.243,.008)*f0_3+\n    vec4(.376,-.814,1.500,-1.007))/1.0+f0_0;\nvec4 f1_1=sin(mat4(.124,.489,-.159,-.094,.099,.611,-.257,-.614,-.108,.309,-.121,-.389,.049,-.606,.030,-.723)*f0_0+\n    mat4(.511,.456,-.645,-1.008,.009,-.461,-.198,-.754,.978,.413,-.641,-.412,-1.068,-.308,.291,-.170)*f0_1+\n    mat4(.428,-.220,-.163,-.356,.744,.548,.221,.563,.242,-.214,-.224,-.567,.391,.045,-.061,-.186)*f0_2+\n    mat4(-.001,-.252,.747,-.435,.539,.003,-.305,-.643,-.261,.164,-.336,.295,.383,-.395,-.136,-.008)*f0_3+\n    vec4(-1.007,-1.304,1.076,1.194))/1.0+f0_1;\nvec4 f1_2=sin(mat4(-.502,.308,-.174,.023,-.560,-.534,.624,-.555,.309,.630,-.122,.310,.368,.878,-.206,-.350)*f0_0+\n    mat4(.684,.334,-.702,.420,-.698,.960,-.053,-.676,-.272,.365,-.074,.407,-.375,.202,.532,-.207)*f0_1+\n    mat4(-.116,-.269,.153,-.453,-.530,.488,-.724,.065,.405,.667,-.642,.043,-.103,.430,-.562,.346)*f0_2+\n    mat4(.472,-.026,-.433,.070,-.210,-.057,-.253,.310,-.344,.047,.386,.552,.246,-.111,.331,.350)*f0_3+\n    vec4(-.725,-1.197,.825,-3.455))/1.0+f0_2;\nvec4 f1_3=sin(mat4(.027,.173,.253,-.822,-.478,.458,.101,.045,.025,.248,.759,.184,-.317,-.014,-.077,-.353)*f0_0+\n    mat4(-.283,-.201,.219,-.248,-.571,-.458,.401,-.226,.432,.245,-.160,-.065,-.421,-1.315,-.569,-.520)*f0_1+\n    mat4(.313,-.258,.291,-.284,-.732,.295,-.087,-.441,.836,-.701,.566,.889,-.116,-.252,-.542,-.396)*f0_2+\n    mat4(-.381,-.907,.516,.431,-.273,.257,.027,-.179,-.214,.077,-.130,-.282,-.368,-.270,.618,-.041)*f0_3+\n    vec4(2.580,-.950,1.416,.227))/1.0+f0_3;\nvec4 f2_0=sin(mat4(.288,.277,.179,.290,-.968,-1.492,.495,-.421,.153,-.177,.580,-.388,.971,-.335,.007,.032)*f1_0+\n    mat4(-.194,-.137,.202,.157,-.160,1.025,-.550,-.053,.485,.030,-.537,.065,.021,-.384,-.109,-.452)*f1_1+\n    mat4(-.748,.241,.386,-.441,-.620,-.869,.559,.681,.367,.256,-.459,-1.047,.260,.241,-.793,.494)*f1_2+\n    mat4(-.958,-.093,-.110,-.074,-.260,-.856,.521,.613,-.562,.079,.238,.056,-.413,-1.011,.118,-.104)*f1_3+\n    vec4(.980,1.564,-2.935,-.589))/1.4+f1_0;\nvec4 f2_1=sin(mat4(.181,.166,-.082,.469,.474,.703,.969,.559,.998,-.016,.193,-.363,.452,.152,.543,-.394)*f1_0+\n    mat4(-.711,-.586,.015,.459,.404,.538,.575,-.249,-.562,-.484,.549,.673,-1.160,.144,-.010,-.093)*f1_1+\n    mat4(.663,.424,.164,.089,1.168,.000,.636,-.309,.088,-.779,.352,-.722,-1.071,-.059,-.089,.310)*f1_2+\n    mat4(-.156,-.515,.176,-.125,.034,.431,.367,.228,.394,.263,.039,.195,1.077,.460,-.456,-.031)*f1_3+\n    vec4(.495,.756,-2.986,-1.239))/1.4+f1_1;\nvec4 f2_2=sin(mat4(-.586,-.569,-.492,-.407,-.224,-.624,.373,-.080,-.216,.279,.704,.072,-.780,-.607,.575,.568)*f1_0+\n    mat4(.070,-.760,.980,.566,-.124,-.326,.463,.559,-.297,.161,-.449,-.236,-.369,-.591,-.190,-.548)*f1_1+\n    mat4(.054,.276,-.894,-.120,.795,1.111,-.473,.031,.387,.292,.974,1.024,.150,.184,.253,-.287)*f1_2+\n    mat4(.435,1.658,.294,-.403,-.377,.175,-.493,.204,-.499,-.614,.119,-.557,-.799,-.168,-.481,-.192)*f1_3+\n    vec4(-2.130,-2.233,-.605,-3.251))/1.4+f1_2;\nvec4 f2_3=sin(mat4(.884,.369,.064,-.009,.434,.437,-.618,.117,.046,-.601,-.376,-.182,1.130,-.913,-.029,.602)*f1_0+\n    mat4(.314,-1.064,.861,-.572,-.633,.111,-.122,-.179,.277,-.615,-.069,.678,.109,.024,-1.124,-.553)*f1_1+\n    mat4(.243,.009,.461,.333,-.624,-.670,.328,.350,1.132,-.523,-.099,.402,.183,.245,-.232,.186)*f1_2+\n    mat4(-.057,.076,.660,-.139,.729,.450,.109,-.177,.088,-.111,.020,-.546,-.487,-1.286,.100,.117)*f1_3+\n    vec4(.529,-2.910,3.311,2.936))/1.4+f1_3;\nreturn dot(f2_0,vec4(.021,-.057,.076,-.038))+\n    dot(f2_1,vec4(-.022,-.081,.064,-.063))+\n    dot(f2_2,vec4(-.049,-.057,.048,.076))+\n    dot(f2_3,vec4(.014,-.049,.060,.071))+\n    -0.010;\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 cam = normalize(vec3(1.5,uv));\n    vec3 init = vec3(-3.,0,0);\n    \n    float yrot = 0.5;\n    float zrot = iTime*.2;\n    if (iMouse.z > 0.) {\n        yrot += -4.*mouse.y;\n        zrot = 4.*mouse.x;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n    \n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 150 && !hit; i++) {\n        float dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p+=dist*cam;\n        if (distance(p,init)>5.) break;\n    }\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    //don't ask how I stumbled on this texture\n    vec3 nz = p - erot(p, vec3(1), 2.) + erot(p, vec3(1), 4.);\n    float spec = length(sin(r*3.5+sin(nz*120.)*.15)*.4+.6)/sqrt(3.);\n    spec *= smoothstep(-.3,.2,scene(p+r*.2));\n    vec3 col = vec3(.1,.1,.12)*spec + pow(spec,8.);\n    float bgdot = length(sin(cam*8.)*.4+.6)/2.;\n    vec3 bg = vec3(.1,.1,.11) * bgdot + pow(bgdot, 10.);\n    fragColor.xyz = hit ? col : bg;\n    fragColor = smoothstep(-.02,1.05,sqrt(fragColor)) * (1.- dot(uv,uv)*.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lyfzw.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[0, 419, 457, 457, 519], [521, 521, 542, 628, 5368], [5370, 5370, 5389, 5389, 5505], [5507, 5507, 5564, 5564, 6832]], "test": "valid"}
{"id": "3sGBDm", "name": "Rolling Polygon", "author": "Shane", "description": "A simulation of an n-gon rolling along an undulating surface.", "tags": ["terrain", "square", "physics", "polygon", "ngon", "roll"], "likes": 46, "viewed": 528, "published": "Public API", "date": "1614427130", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\tRolling Polygon\n\t---------------\n\n\tThis is yet another shader that has been sitting in my account for too \n    long. I was going to code a rolling polyhedron on terrain, but it'd been \n    a while since I'd applied collision-based physics, rigid body or otherwise, \n    so I decided to quickly code up a 2D n-gon rolling across an undulating 1D \n    noisy surface. It took me longer than the five minutes I expected it to \n    take, and that was without applying proper physical forces... The math and \n    physics student in me would be disappointed in what I've become. :D\n    \n    Even so, the idea is very simple: The lowest vertex is always in contact \n    with the ground, so determine which vertex it is and its distance from the \n    contact surface, then use it to offset all vertices... You could use repeat \n    polar coordinates to do this. However, I wanted to test the mid points \n    between vertices to gain a little more ground contact collision accuracy. \n    Plus, I also wanted infrastructure that could deal with haphazard shapes.\n    \n    Anyway, this example is not that important, and the code was rushed. I've \n    also added a heap of window dressing. Everything works, but there'd be \n    cleaner ways to do what I'm doing here, so you can ignore most of it. \n    Having said that, there isn't a great deal of code featuring rolling 2D \n    polygons along an undulating surface, so at least this is a start. :)\n    \n\n\n    Other examples:\n    \n    // Much... much more difficult terrain collision, and far more interesting, \n    // but still based on similar principles. By the way, Dr2 has dozens more\n    // collision based examples worth looking at.\n    Leaping Snakes 2 - dr2\n    https://www.shadertoy.com/view/3lBXWV\n\t\n\n*/\n\n\n// Number of Polygon vertices:\n// Positive integers ranging from 2 to about 8 will work.\n// 2 (just a line) looks a bit odd, but is interesting.\n// Also, the speeds below may need adjusting.\n#define VERTICES 5\n\n\n// Polygon speed and rotation speed -- Technically, the forward motion should be\n// based mostly on the rotation speed, but I'm fudging things a little.\nfloat speed = .4;\n// Higher rotational speeds simulate spinning on the surface... Kind of. :)\nfloat rotSpeed = .42;\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n \n\n// I searched Shadertoy for a robust regular polygon routine and came across\n// the following example:\n//\n// Regular Polygon SDF - BasmanovDaniil\n// https://www.shadertoy.com/view/MtScRG\n//\n// To use the functions in more intensive scenes, some optimization would be\n// necessary, but I've left them in their original form to show the working.\n\nfloat Polygon(vec2 p, float vertices, float radius){\n\n    float segmentAngle = 6.2831853/vertices;\n    \n    float angleRadians = atan(p.x, p.y);\n    float repeat = mod(angleRadians, segmentAngle) - segmentAngle/2.;\n    float inradius = radius*cos(segmentAngle/2.);\n    float circle = length(p);\n    float x = sin(repeat)*circle;\n    float y = cos(repeat)*circle - inradius;\n\n    float inside = min(y, 0.);\n    float corner = radius*sin(segmentAngle/2.);\n    float outside = length(vec2(max(abs(x) - corner, 0.0), y))*step(0.0, y);\n    return inside + outside;\n}\n\n\n\n// Cheap and nasty 2D smooth noise function with inbuilt hash function -- based on IQ's \n// original. Very trimmed down. In fact, I probably went a little overboard. I think it \n// might also degrade with large time values.\nfloat n2D(vec2 p) {\n\n\tvec2 i = floor(p); p -= i; p *= p*(3. - p*2.); // p *= p*p*(p*(p*6. - 15.) + 10.); //\n    \n\treturn dot(mat2(fract(sin(vec4(0, 1, 113, 114) + dot(i, vec2(1, 113)))*43758.5453))*\n                vec2(1. - p.y, p.y), vec2(1. - p.x, p.x) );\n\n}\n\n\nfloat height(vec2 p){\n    \n    \n    p.x += iTime*speed;\n    p *= 3.;\n    float ns = n2D(p)*.57 + n2D(p*2.)*.28 + n2D(p*4.)*.15;\n    //float ns = n2D(p)*.67 + n2D(p*2.)*.33;\n    return (mix(ns, smoothstep(.25, 1., ns), .5) - .5)*.25;\n}\n\n// The map function. Just two layers of gradient noise. Way more interesting\n// functions are possible, but we're keeping things simple.\nfloat map(vec2 p){\n\n    float ns = height(vec2(p.x, 0.));\n    float ter = p.y + ns + .075;\n    \n    return ter;\n  \n}\n\n\n\n// 2D derivative function.\nvec2 getNormal(in vec2 p, float m) {\n\t\n    vec2 e = vec2(.001, 0);\n    \n    // Four extra samples. Slightly better, but not really needed here.\n\t//return (vec2(map(p + e.xy, i) - map(p - e.xy, i), map(p + e.yx, i) - map(p - e.yx, i)))/e.x*.7071;\n\n    // Three samples, but only two extra sample calculations. \n    return vec2(m - map(p - e.xy), m - map(p - e.yx))/e.x*1.4142;\n}\n\n\n\n// A hatch-like algorithm, or a stipple... or some kind of textured pattern.\nfloat doHatch(vec2 p){\n    \n    float res = iResolution.y;\n    \n    // Produce the pattern.\n    \n    \n        \n    \n        // The pattern is physically based, so needs to factor in screen resolution.\n        p *= res/16.;\n    \n    \t// Just a hack to deal with large \"p\" values as time progresses.\n    \tp = mod(p, 1024.);\n\n        // Random looking diagonal hatch lines.\n        float hatch = clamp(sin((p.x - p.y)*3.14159*200.)*2. + .5, 0., 1.); // Diagonal lines.\n\n        // Slight randomization of the diagonal lines, but the trick is to do it with\n        // tiny squares instead of pixels.\n        float hRnd = hash21(floor(p*6.) + .73);\n        if(hRnd>.66) hatch = hRnd;  \n\n\n        hatch = hatch*.2 + .8;\n        \n\n        return hatch;\n    \n}\n\n\n\n// The polygon line pattern.\nfloat linePattern(vec2 p, vec2 a, vec2 b){\n  \n    // Determine the angle between the vertical 12 o'clock vector and the edge\n    // we wish to decorate (put lines on), then rotate \"p\" by that angle prior\n    // to decorating. Simple.\n    vec2 v1 = vec2(0, 1);\n    vec2 v2 = (b - a); \n \n    // Angle between vectors.\n    //float ang = acos(dot(v1, v2)/(length(v1)*length(v2))); // In general.\n    float ang = acos(v2.y/length(v2)); // Trimed down.\n    p = rot2(ang)*p; // Putting the angle slightly past 90 degrees is optional.\n\n    float ln = doHatch(p);//clamp(cos(p.x*96.*6.2831)*.35 + .95, 0., 1.);\n\n    return ln;// *clamp(sin(p.y*96.*6.2831)*.35 + .95, 0., 1.); // Ridges.\n \n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Coordinates.\n    float res = min(iResolution.y, 800.);\n    vec2 uv = (fragCoord - iResolution.xy*.5)/res;\n    \n    // Scaling, translation, etc.\n    vec2 p = uv - vec2(.25, 0);\n    \n    // Keep a copy.\n    vec2 oP = p;\n\n    // Smoothing factor.\n    float sf = 1./iResolution.y;\n    \n    // Number of Polygon vertices:\n    // Positive integers ranging from 2 to about 8 will work.\n    // 2 (just a line) looks a bit odd, but is interesting.\n    const int sNum = VERTICES;\n    const float fsNum = float(sNum);\n    \n    \n    // Gradient at the center of the shape.\n    float grad = (map(vec2(.03, 0)) - map(vec2(-.03, 0)));\n\n    // Rotating time, based on vertice number.\n    float t = fract(iTime*min(mix(fsNum, 5., .5), 6.)*rotSpeed);\n    t = pow(t, .8);\n    t *= 6.283185/fsNum;\n    t -= sign(grad)*grad*grad*4.;\n   \n    \n    // Emulating friction -- very badly. :)\n    p.xy += vec2(-.5, 1.5)*(cos(t*fsNum - 1.57*.5)*.5 + .5)*.005;\n \n    \n    // Various distance field values, etc.\n    float d = 1e5, vert = d, vert2 = d, poly = d, ln = d, gP = d, ico = d, ico2 = d;\n    \n    // Polygon side length and vertex size.\n    float l = .18;\n    float pSz = .015;\n    \n    \n    // Point and transformed point holders.\n    vec2[sNum] pnt;\n    vec2[sNum] tPnt;\n    \n    // Create the points, then rotate them.\n    for(int i = 0; i<sNum; i++){\n        \n        pnt[i] = rot2(6.283185/fsNum*float(i))*vec2(0, 1./sqrt(2.))*l;\n        tPnt[i] = rot2(t)*pnt[i];\n    }\n    \n    // Line pattern.\n    float sLinePat = linePattern(p - vec2(-iTime*speed*1.2, 0), vec2(1, 1), vec2(1, -1));\n    \n    // Bottom dashed line:\n    float xOffs = -.15 - .25;//-.35\n    float yOffs = -.43;\n    if(res>500.) yOffs -= .1;\n    float g = abs(p.y - yOffs + .018) - .0025;\n    vec2 q = mod(p + vec2(iTime*speed, 0), 1./32.) - .5/32.;\n    float dash = abs(q.x) - .2/32.;\n    g = max(g, -dash);\n    \n\n    // Find the minimum vertex point height, since that will be the vertex\n    // in contact with the ground.\n    int lvert = 0;\n    for(int i = 0; i<sNum; i++){ \n        \n        if(tPnt[i].y<gP) {\n            gP = tPnt[i].y;\n            lvert = i;\n        }\n\n    }\n    // Adjust every transformed point by the minimum. \n    for(int i = 0; i<sNum; i++) tPnt[i].y -= gP - yOffs;\n   \n    // Keeping a copy for the ground based polygon below. Normally, this \n    // wouldn't be necessary.\n    float gP2 = gP;\n\n    \n    // Previous and next vertex numbers.\n    int lvertp = int(mod(float(lvert) + 1., fsNum));\n    int lvertn = int(mod(float(lvert) - 1., fsNum));\n    \n    // Number of midpoints between successive vertices. We test these against\n    // the terrain also. More contact points mean more accurate collision.\n    const int midPoints = 2;\n    \n    gP = 1e5;\n    \n    for(int i = 0; i<sNum; i++){ \n        \n        // Terrain height.\n        float h = map(vec2(tPnt[i].x, 0));\n        \n        // If the current vertex plus height is lowest, it becomes the new lowest point.\n        if(tPnt[i].y + h<gP) {\n            gP = tPnt[i].y + h;\n        }\n        \n        // Add the vertex point to the overall distance field.\n        vert2 = min(vert2, length(p - tPnt[i]*.16/.18 - vec2(xOffs, .115*yOffs)) - pSz);\n        \n        // Get the next vertex point index.\n        int inext = (i + sNum - 1)%sNum;\n        \n        // Check the midpoints between the current and next point, the perform a\n        // collision check with the terrain.\n        for(int j = 0; j<midPoints; j++){\n            \n            // Current midpoint... Hmm, midpoint was probably a poor choice of \n            // word, since there can be more than one... Pretend that I mean, waypoint. :)\n            vec2 mid = mix(tPnt[i], tPnt[inext], float(j + 1)/float(midPoints + 1));\n            float hmid = map(vec2(mid.x, 0)); // Midpoint height.\n\n            // If the current midpoint plus height is lowest, it becomes the new lowest point.\n            if(mid.y + hmid<gP) {\n                gP = mid.y + hmid;\n            }\n            \n            // Add the midpointto the overall distance field.\n            vert2 = min(vert2, length(p - mid*.16/.18 - vec2(xOffs, .115*yOffs)) - pSz*.5);\n             \n             \n        }\n    } \n \n   \n \n    \n    ///////////////////\n    \n    // Terrain calculations.\n    \n    float ter = map(p);\n    vec2 n = getNormal(p, ter);\n    float len = length(n);\n   \n    vec2 p2 = p*vec2(1, -1) - vec2(75.3, -.3);\n    float ter2 = map(p2); \n    vec2 n2 = getNormal(p2, ter2);\n    float len2 = length(n2);\n \n    \n    // Polygon contruction.\n    q = rot2(-t)*(p - vec2(0, -gP  - (gP2 - yOffs)));\n    poly = Polygon(q, fsNum, l/sqrt(2.)); \n    poly = max(poly, -(poly + .06)); // Hole.\n   \n    \n    // Polygon line pattern. \n    float t2 = (iTime*rotSpeed*(4.));\n    t2 *= 6.283185/4.;\n    vec2 qp = rot2(-t2)*(p - vec2(0, -gP  - (gP2 - yOffs)));\n    float patPoly = clamp(sin((qp.y)*6.283185*50.*sqrt(2.))*.5 + 1., 0., 1.);\n    //\n    vec2 qq = rot2(-t2)*(p - vec2(0, -gP  - (gP2 - yOffs)));\n    //qq = (rot2(-t2))*(p - vec2(0, -gP  - (gP2 - yOffs)));\n    patPoly = linePattern(qq, pnt[0], pnt[1]);\n    \n\n    \n    // Polygon vertices.\n    q = rot2(6.283185/2./fsNum)*q;\n    float a = atan(q.x, q.y);\n    float ia = (floor(a*fsNum/6.283185) + .5)/fsNum;\n    q = rot2(-ia*6.283185)*q;\n    q.y -= l/sqrt(2.);\n    // \n    vert = min(vert, length(q) - pSz);\n    \n    \n    // Terrain overlay line pattern.\n    float pat = linePattern(p - vec2(-iTime*speed, 0), vec2(1, 1), vec2(1, -1));\n    \n    // Dashes.\n    q = p;\n    q.x = mod(q.x + iTime*speed, 1./36.) - .5/36.;\n    q.y -= -map(vec2(p.x, 0));//-gP - (gP2 - yOffs);\n    // Rotating by the half the tangent. Normally, you'd use the whole tangent, but\n    // I wanted to rotate the lines toward the curve, but not all the way, for \n    // aesthetic purposes.\n    q = rot2(atan(-n.x, n.y)/2.)*q;\n    dash = abs(q.x) - .2/36.;\n    \n    q = p2;\n    q.x = mod(q.x + iTime*speed, 1./36.) - .5/36.;\n    q.y -= -map(vec2(p2.x, 0));//-gP - (gP2 - yOffs);\n    // Rotating by the half the tangent. Normally, you'd use the whole tangent, but\n    // I wanted to rotate the lines toward the curve, but not all the way, for \n    // aesthetic purposes.\n    q = rot2(atan(-n2.x, n2.y)/2.)*q;\n    float dash2 = abs(q.x) - .2/36.;\n    \n    \n    // Noise texture.\n    q = (p - vec2(-iTime*speed, 0));\n    q *= vec2(2, 4. + ter)*32.;\n    float ns = n2D(q)*.57 + n2D(q*2.)*.28 + n2D(q*4.)*.15;\n    vec3 tx = vec3(1);//*(smoothstep(0., .1, ns - .5)*.1 + .9);\n\n\n \n    // Tunnel background.\n    vec3 col = vec3(1, .92, .75)*.8;\n    col *= sLinePat;\n    \n    // Resolution shadow factor.\n    float shF = res/450.;\n   \n    // Top terrain overlay.    \n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*length(n2)*8.*shF, ter2 - length(n2)*.00))*.3);    \n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*length(n2), max(ter2, -dash2))));//vec3(.7, .8, .5)\n    col = mix(col, vec3(1, .94, .78)*pat*tx, (1. - smoothstep(0., sf*length(n2), ter2 + length(n2)*.005)));\n    \n    // Bottom terrain overlay.\n    float sh = clamp(clamp(sin(ter*250. - 3.14159) + .9, 0., 1.), 0., 1.);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*length(n)*8.*shF, ter - length(n)*.00))*.3);    \n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*length(n), max(ter, -dash))));//vec3(.7, .8, .5)\n    col = mix(col, vec3(1, .94, .78)*pat*tx, (1. - smoothstep(0., sf*length(n), ter + length(n)*.005)));\n   \n    \n   \n    // Polygon lines.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8.*shF, min(poly, vert - .003) - .004))*.3);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, poly - .004));\n    col = mix(col, vec3(1, .97, .92)*patPoly, 1. - smoothstep(0., sf, poly + .004));\n\n    // Bottom straight faded line.\n    float fade = min(abs(uv.x - (xOffs + .25)), 1.);\n    col = mix(col, mix(col, vec3(0), 1. - smoothstep(0., .15, fade - .3)), (1. - smoothstep(0., sf, g)));\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, ln));\n   \n    // Polygon vertices.\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, vert - .003));\n    col = mix(col, mix(vec3(1, .8, .42), vec3(.8, 1, .35)*1.3, .4), 1. - smoothstep(0., sf, vert + .003));\n\n    // Bottom polygon vertices.\n    vec3 bg = col;\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, vert2 - .003));  \n    col = mix(col, mix(vec3(1, .8, .42), vec3(.8, 1, .35)*1.3, .2), 1. - smoothstep(0., sf, vert2 + .003));  \n    \n    \n    // Render some border objects to frame things a little bit.\n    //\n    // Border sights: The background corners looked a little empty, so I threw \n    // these in to balance things out... Not sure if it worked, but it's done now. :)\n    vec2 b = vec2(iResolution.x/iResolution.y, 1) - .1;\n    q = (uv*2.);\n    q.x = abs(q.x);\n    q.y = -q.y;\n    float bord = max(q.x - b.x, q.y - b.y);\n    bord = max(bord, -(bord + .11));\n    bord = max(bord, -min(q.x - b.x + .22, q.y - b.y + .22));\n    //bord = max(bord, -(bord + .02));\n\n    \n    // Render the border sight... edge things, or whatever they are.\n    float falloff = 1./res;\n    col = mix(col, vec3(0), (1. - smoothstep(0., falloff*12.*shF, bord ))*.35);\n    col = mix(col, vec3(0), (1. - smoothstep(0., falloff, bord))*.7);\n    col = mix(col, bg*1., (1. - smoothstep(0., falloff, bord + .01)));\n    col = mix(col, vec3(0), (1. - smoothstep(0., falloff, bord + .035)));\n    col = mix(col, bg*1.3, (1. - smoothstep(0., falloff, bord + .044)));    \n    ////\n     \n    // Very subtle sepia tone with a sprinkling of noise, just to even things up a bit more.\n    p.xy += iTime*speed*vec2(1, .0);\n    col *= vec3(1.03, 1, .97);\n    // Noise, with custom frequency and amplitude distribution.\n    col *= ((n2D(p*16.)*.4 + n2D(p*36.)*.25 + n2D(p*80.)*.2 + n2D(p*180.)*.15)*.2 + .9);\n    \n    // Failed color experiment.\n    //col = mix(col, col.zyx, uv.y*.5);\n  \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*(1. - uv.x)*(1. - uv.y)*uv.x*uv.y, 1./16.)*1.05;\n\n    // Output to screen\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sGBDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2243, 2276, 2298, 2298, 2356], [2359, 2387, 2408, 2408, 2470], [2475, 2820, 2872, 2872, 3381], [3385, 3609, 3628, 3628, 3870], [3873, 3873, 3894, 3894, 4107], [4109, 4246, 4264, 4264, 4362], [4366, 4393, 4429, 4429, 4770], [4774, 4851, 4873, 4873, 5603], [5607, 5636, 5678, 5869, 6317], [6321, 6321, 6375, 6396, 16355]], "test": "error"}
{"id": "3t3BD2", "name": "Perfect Pistons Example 1", "author": "blackle", "description": "See [url=https://youtu.be/I8fmkLK1OKg]the tutorial video this is from[/url]", "tags": ["domainrepetition", "pistons"], "likes": 11, "viewed": 344, "published": "Public API", "date": "1613442817", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nfloat piston(vec2 p, float width, float height) {\n    p.x = abs(p.x) - width;\n    p.y -= height;\n    return length(max(p,0.0)) + min(0.0, max(p.x,p.y));\n}\n\nfloat scene(vec2 p) {\n    float center = floor(p.x) + 0.5;\n    float neighbour = center + ((p.x < center) ? -1.0 : 1.0);\n\n    float width = 0.3;\n    float height = sin(iTime + center)*2.;\n    float me = piston(p - vec2(center, 0), width, height);\n    float next = piston(p - vec2(neighbour, 0), width, 2.0);\n    return min(me, next);\n}\n\nvec3 shadeDistance(float d) {\n    float dist = d*100.0;\n    float banding = max(sin(dist), 0.0);\n    float strength = sqrt(1.-exp(-abs(d)*2.));\n    float pattern = mix(strength, banding, (0.6-abs(strength-0.5))*0.3);\n    \n    vec3 color = vec3(pattern);\n    \n    color *= d > 0.0 ? vec3(1.0,0.56,0.4) : vec3(0.4,0.9,1.0);\n\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n    uv*=5.;\n    mouse*=5.;\n\n    float mousedist = scene(mouse);\n    vec3 col = shadeDistance(scene(uv));\n    if (distance(mouse, uv) < abs(mousedist) && iMouse.z > 0.) col *=0.5;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t3BD2.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[0, 194, 243, 243, 348], [350, 350, 371, 371, 685], [687, 687, 716, 716, 1029], [1031, 1031, 1088, 1138, 1474]], "test": "valid"}
{"id": "3t3BW2", "name": "Quadratic surface", "author": "JeanArthurDeda", "description": "Homage to quadratic surfaces rendering", "tags": ["raytrace", "quadratic"], "likes": 8, "viewed": 95, "published": "Public", "date": "1613434934", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Quadratic surface:\n// - A surface that contains all the points p for which qsample(p, q)=0\n// - They have some beautiful props which allows for easy calculation of the projective\n// curve and even further the calculation of the hor&ver min&max making them a \n// great candidate for scanline rendering alongside polys.\n\n// They were used extensively by Jim Blinn in the Voyanger film for NASA ~'78:\n// https://www.youtube.com/watch?v=SQk7AFe13CY\n// and in the movie \"The works\" by New York Institute of Technology ~'79\n// https://www.youtube.com/watch?v=g_q38qWv1fo\n// https://www.worthpoint.com/worthopedia/byte-magazine-nov-1980-volume-number-1856336512\n\n// As the CG world moved towards triangles, quads and splines the quadratic surfaces \n// become just a mathematical curiosity lost in hystory.\n// Here I'm doing just a ray trace over 1 quadratic surface as an homage to the pioneers\n// who used them a long time ago.\n\n#define PI 3.141592653589793238f\n\n// Quadratic surface helpers.All done with respect to homogenous coordonates.Old school.\nfloat qsample(vec4 a,mat4 q,vec4 b){return dot(a,q*b);}\nfloat qsample(vec4 p,mat4 q){return qsample(p,q,p);}\nfloat qray(vec4 p,vec4 d,mat4 q)\n{\n    float dqp=qsample(d,q,p);\n    float dqd=qsample(d,q,d);\n    float pqp=qsample(p,q,p);\n    float delta = dqp*dqp-dqd*pqp;\n    if (delta < .0) return -1.;\n    float oo_dqd = 1.0/dqd;\n    float sq_delta = sqrt (delta);\n    float t1 = (-dqp - sq_delta) * oo_dqd;\n    float t2 = (-dqp + sq_delta) * oo_dqd;\n    return min(t1, t2);\n}\nvec4 qplane(vec4 p, mat4 q) {return p*q;}\nvec3 qnor(vec4 p, mat4 q) {return normalize (qplane(p,q).xyz);}\nmat4 qtransf(mat4 i,mat4 it, mat4 q){return i*q*it;}\n\nvec2 map(vec3 n, vec3 p)\n{\n    float v[3] = float[3](n.x,n.y,n.z);\n    int m = 0;\n    for (int i = 1; i < 3;i++)\n        if (abs(v[i])>abs(v[m]))\n            m = i;\n    v = float[3](p.x,p.y,p.z);\n    return vec2 (v[(m+1)%3],v[(m+2)%3]);\n}\n\nfloat saw(float v){return 1.-abs(1.-fract(v)*2.);}\n\nfloat s(float t, float p, float r)\n{\n    float v = fract(t/p)/r;\n    return floor(v) < 1.f?clamp(saw(v)*3.,.0,1.):0.;\n}\n\n//-------------------------Noise--------------------------\n// IQ's noise\nfloat pn( in vec3 p )\n{\n    vec3 ip = floor(p);\n    p = fract(p);\n    p *= p*(3.0-2.0*p);\n    vec2 uv = (ip.xy+vec2(37.0,17.0)*ip.z) + p.xy;\n    uv = texture( iChannel1, (uv+ 0.5)/256.0, -100.0 ).yx;\n    return mix( uv.x, uv.y, p.z );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera movement (from IQ)\n\tfloat an = 0.2*iTime;\n\tvec3 ro = vec3( 3.2*cos(an), 2.5, 3.2*sin(an) );\n    vec3 ta = vec3( 0.0, -0.05, 0.0 );\n    // camera matrix (from IQ)\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    // create view ray (from IQ)\n    vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww);\n    \n    \n    float time=iTime+111.;\n    // primitive\n    mat4 q = mat4 \n    (\n        1.0-s(time+0.,12.0,.5), -s(time*.2,5.,.5)*.1,0.0, 0.0,\n        -s(time*.2,5.,.5)*.1, 1.0-s(time+4.,10.0,.3), 0.0, 0.0,\n        0.0, 0.0, 1.0-s(time+8.,10.0,.4), 0.0,\n        0.0, 0.0, 0.0, -.25\n    );\n    // a primitive from the future\n    time+=.25;\n    mat4 q2 = mat4 \n    (\n        1.0-s(time+0.,12.0,.5), -s(time*.2,5.,.5)*.1,0.0, 0.0,\n        -s(time*.2,5.,.5)*.1, 1.0-s(time+4.,10.0,.3), 0.0, 0.0,\n        0.0, 0.0, 1.0-s(time+8.,10.0,.4), 0.0,\n        0.0, 0.0, 0.0, -.25\n    );\n    fragColor = vec4(0);\n\n    // raytrace\n    float t = qray(vec4(ro,1),vec4(rd,0),q);\n    if (t >= 0.0)\n    {\n        vec3 hit = ro+t*rd;\n        vec3 n = qnor(vec4(hit,1),q);\n        float d = clamp(dot(n,normalize(vec3(0.7,0.6,0.3))), 0.0, 1.0 );        \n        fragColor = (d+.2)*texture (iChannel0, map(n,hit));\n        vec3 l = smoothstep(vec3(0.01),vec3(0),abs(fract (hit-vec3(.3,.6,.3))-vec3(.5)));\n        fragColor += vec4(max(l.y,max(l.x,l.z)))*vec4(.2,0.4,.4,.0);\n    }\n    else\n    {\n        // background stars based on https://www.shadertoy.com/view/ltjSWV\n        fragColor += vec4(smoothstep(0.95, 1.0, pn(rd*30.0)*.5+.5));\n    }\n    \n    // Render some '80s CGI tech info\n    float ar = iResolution.x / iResolution.y;\n    vec2 m = fragCoord/iResolution.xy * vec2 (ar, 1.0) * 2.0 - vec2 (ar, 1.0);\n    for (int i = 0; i < 10; ++i)\n    {\n        vec3 p = vec3 (m, cos(float(i)/5.));\n        m*=1.05;\n        // render q slice\n        float v = abs(qsample(vec4(p, 1), q2)) / 0.02;\n        fragColor += vec4(clamp(0.5-v,.0,1.),0,0,1);\n    }\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t3BW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[960, 1049, 1085, 1085, 1104], [1105, 1105, 1134, 1134, 1157], [1158, 1158, 1192, 1192, 1524], [1525, 1525, 1554, 1554, 1566], [1567, 1567, 1594, 1594, 1630], [1631, 1631, 1668, 1668, 1683], [1685, 1685, 1711, 1711, 1923], [1925, 1925, 1944, 1944, 1975], [1977, 1977, 2013, 2013, 2096], [2098, 2171, 2194, 2194, 2407], [2409, 2409, 2466, 2499, 4554]], "test": "error"}
{"id": "3t3Bzs", "name": "The Lost Self", "author": "YitingLiu", "description": "a sense of self-lost in the gyroid shape. ", "tags": ["raymarching", "template", "artofcode"], "likes": 4, "viewed": 197, "published": "Public API", "date": "1613226340", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34,233.53));\n    p += dot(p, p+23.234);\n    return fract(p.x*p.y);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdGyroid(vec3 p,float scale, float thickness, float bias){\n    p*=scale;\n    \n    // can also play with the p and p.zxy by adding some numbers \n    // scale needs to add the largest multiplers in either p or p.zxy \n    // return abs(dot(sin(p*2.),cos(p.zxy*1.23))-bias)/(scale*2.)-thickness;\n\n    return abs(dot(sin(p),cos(p.zxy))-bias)/scale-thickness;\n    \n    }\n\nfloat GetDist(vec3 p) {\n    float box = sdBox(p, vec3(1));\n    \n    // wanting something organic? the scales for two should not be multiplicable by each other (ex.: can't be 4 and 8)\n    float g1 = sdGyroid(p,5.,.02,1.5);\n    float g2 = sdGyroid(p+vec3(1.),8.85,.02,2.);\n    float g3 = sdGyroid(p+vec3(2.),15.85,.03,0.32);\n    float g4 = sdGyroid(p+vec3(3.),28.85,.04,1.2);\n    float g5 = sdGyroid(p+vec3(3.),34.20,.05,1.3);\n    \n    //float g = max(g1,g2);//union \n  //float g = max(g1,-g2);//subtraction \n    \n    g1-=g2*.3;//bump mapper \n    g1-=g3*.2;//bump mapper \n    g1+=g4*.1;//bump mapper \n    \n    //float d=max(box,g1*.8);// intersect the box \n   \t\n    float d = g1*.8;\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    float fft  = texture( iChannel0, vec2(uv.x-1.)).x; \n\t\n    // second texture row is the sound wave\n\tfloat wave = texture( iChannel0, vec2(uv.x-1.,0.1) ).x;\n\t\n\t// convert frequency to colors\n\tvec3 soundEl = vec3(fft,0.5*fft*(1.0-fft),fft );// * fft;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 3, -3)*S(-.01,0.01,fft)*0.5;\n    ro.yz *= Rot(abs(sin(iTime*.2))*S(-.01,0.028,fft)*3.14+1.);\n    ro.xz *= Rot(cos(iTime*.5*S(-.01,0.01,fft))*6.2831);\n    \n    // mouse controls 3d \n    //ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    \n    //zoom factor \n    vec3 rd = GetRayDir(uv, ro, vec3(0),2.*sin(iTime*0.5*S(-0.01,0.1,fft)));// S(0.,0.2,fft)*5.\n\n    float d = RayMarch(ro, rd);\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \tvec3 n = GetNormal(p);\n        \n    \tfloat dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n    \tcol+=n*.5+.5;// 0 <> 1 \n        col -= dif*soundEl;  \n    \n        //ambient occulusion - cheaper \n    float g2 = sdGyroid(p+vec3(1.),8.85,.02,2.);\n        col*=S(-.1,.1,g2)-soundEl;\n\n    }\n    \n   // col*=0.;// for 2d\n    d = sdGyroid(vec3(uv.x,uv.y,iTime*.1),10.,.02,.3);\n   //col+=d*.8; // for 2d \n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "llXXRM", "previewfilepath": "https://soundcloud.com/yitingliu/you", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/yitingliu/you", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t3Bzs.jpg", "access": "shaders20k", "license": "mit", "functions": [[0, 1475, 1494, 1494, 1556], [1558, 1558, 1580, 1580, 1674], [1676, 1676, 1705, 1705, 1786], [1788, 1788, 1852, 1852, 2158], [2160, 2160, 2183, 2183, 2856], [2858, 2858, 2892, 2892, 3103], [3105, 3105, 3129, 3129, 3319], [3321, 3321, 3371, 3371, 3562], [3566, 3566, 3623, 3623, 4975]], "test": "error"}
{"id": "3t3fDn", "name": "Fireworks 6", "author": "valinion", "description": "fireworks", "tags": ["fireworks"], "likes": 1, "viewed": 107, "published": "Public", "date": "1612475219", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NUM_PART 25.\n#define NUM_EXP 5.\nvec2 hash12(float seed){\n    float x = fract(sin(seed*674.2)*463.2);\n     float y = fract(sin((x+seed)*614.2)*263.2);\n    return vec2(x,y);\n}\nvec2 hash12_polar(float seed){\n    float a = fract(sin(seed*674.2)*463.2)*6.28;\n     float d = 0.1 + fract(sin((a+seed)*714.2)*263.2);\n    return vec2(sin(a),cos(a))*d;\n}\n\nfloat explosion(vec2 uv,float t){\nfloat sparks = 0.;\n for(float i = 0. ;i<NUM_PART;i++){\n        vec2 dir = hash12_polar(i+1.)*.5;\n        float d = length(uv-dir*t);\n        float brightness = mix(.0005,.002,smoothstep(.05,0.,t));\n        brightness *= sin(t*20.+i)*.5+.5;\n        brightness *= smoothstep(1.,.5 + (0.5-i/NUM_PART),t);\nsparks += brightness/ d; \n    }\n    return sparks;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (center is origin)\n     vec2 uv = (fragCoord - .5 *iResolution.xy)/iResolution.y;\n\n        // Time varying pixel color\n    vec3 col =vec3(0);\n    \n    for(float i=0.;i<NUM_EXP;i++){\n    float t = iTime + i/NUM_EXP;\n        float ft = floor(iTime);\n       vec3 color = sin(vec3(.34,.54,.43)*(ft)*i)*.25 + .75;\n       vec2 offset = hash12(i+1.+ft)-.5;\n       offset *= vec2(1.77,1.);\n        col+=explosion(uv -offset,fract(t))*color;\n    }\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t3fDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[40, 40, 64, 64, 181], [182, 182, 212, 212, 352], [354, 354, 387, 387, 742], [744, 744, 801, 856, 1335]], "test": "valid"}
{"id": "3t3fRH", "name": "fork-e#71005.0", "author": "jorge2017a1", "description": "http://glslsandbox.com/e#71005.0", "tags": ["forke710050"], "likes": 1, "viewed": 48, "published": "Public", "date": "1612187047", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//modificado por jorge2017a1\n//http://glslsandbox.com/e#71005.0\nvec2 surfacePosition;\n\n\n#define EPS 0.001\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nfloat sdBox(vec2 p, vec2 b) \n{\n\tvec2 q = abs(p) - b;\n\treturn length(max(q, 0.0)) + min(max(q.x, q.y), 0.0);\n}\n\nfloat sdBox(vec3 p, vec3 b) \n{\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdCross(vec3 p, float h) {\n\tvec2 b = vec2(h);\n\tfloat da = sdBox(p.xy, b);\n\tfloat db = sdBox(p.yz, b);\n\tfloat dc = sdBox(p.zx, b);\n\treturn min(da, min(db, dc));\n}\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n\nfloat ifsCross(vec3 p) \n{\n\t//float d = 1.0 / 0.0;\n    float d = 99999.9;\n\tfloat h = 3.0;\n\n     \n\tfloat m = floor(mod(iTime, 10.0));\n\tint M = int(min(m, 10.0 - m));\n    \n    \n    //int M =2;\n    \n\tfor (int i = 0; i < 3; i++) {\n\t\tif (i >= M) {\n\t\t\tbreak;\n\t\t}\n\t\tvec3 q = mod(p + h, h * 2.0) - h;\n\t\th /= 3.0;\n\t\td = min(d, sdCross(q, h));\n\t}\n\n    float sd2= sdBox(p, vec3(4.5) ) ;\n    \n    d= differenceSDF( sd2,d);\n\n\treturn d;\n}\n\nfloat map(vec3 p) {\n\tp.yz *= rot(radians(30.0));\n\tp.zx *= rot(iTime * 0.5);\n\tfloat db = sdBox(p, vec3(3));\n\tfloat dc = ifsCross(p);\n//\treturn min(db, dc);\n\treturn max(db, -dc);\n}\n\nvec3 getNormal(vec3 p) {\n\tconst vec2 eps = vec2(EPS, 0);\n\tfloat d = map(p);\n\treturn normalize(vec3(\n\t\tmap(p + eps.stt) - d,\n\t\tmap(p + eps.tst) - d,\n\t\tmap(p + eps.tts) - d));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    surfacePosition=uv;\n\tvec3 rd = normalize(vec3(surfacePosition, 1));\n\tvec3 ro = vec3(0, 0, -10);\n\tvec3 light = normalize(vec3(1, 2, -3));\n\tfloat dist = 0.0;\n\tfloat bright = 0.0;\n\n\tfor (int i = 0; i < 100; i++)\n    {\n\t\tvec3 p = ro + rd * dist;\n\t\tfloat d = map(p);\n\t\tif (d < EPS) {\n\t\t\tbright = max(dot(light, getNormal(p)), 0.1);\n\t\t\tbreak;\n\t\t}\n\t\tdist += d;\n\t\tif (dist > 30.0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfragColor = vec4(vec3(2,1,1) * bright, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t3fRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 157, 187, 187, 266], [268, 268, 298, 298, 387], [389, 389, 421, 421, 556], [558, 602, 649, 649, 676], [678, 678, 721, 721, 748], [750, 750, 798, 798, 826], [827, 874, 899, 923, 1297], [1299, 1299, 1318, 1318, 1477], [1479, 1479, 1503, 1503, 1654], [1657, 1657, 1714, 1714, 2222]], "test": "valid"}
{"id": "3t3fzf", "name": "hemisphere", "author": "kithy", "description": "hemisphere made from 2 spheres & plane", "tags": ["raymarching", "boolean", "hemisphere"], "likes": 2, "viewed": 76, "published": "Public", "date": "1613142788", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 64\n#define EPS vec2(1e-5,0.0)\n#define PI 3.1415926\n\n\nvec3 rotate(vec3 p,float angle,vec3 axis){\n\tvec3 a=normalize(axis);\n\tfloat s=sin(angle);\n\tfloat c=cos(angle);\n\tfloat r=1.0-c;\n\tmat3 m=mat3(\n\t\ta.x*a.x*r+c,\n\t\ta.y*a.x*r+a.z*s,\n\t\ta.z*a.x*r-a.y*s,\n\t\ta.x*a.y*r-a.z*s,\n\t\ta.y*a.y*r+c,\n\t\ta.z*a.y*r+a.x*s,\n\t\ta.x*a.z*r+a.y*s,\n\t\ta.y*a.z*r-a.x*s,\n\t\ta.z*a.z*r+c\n\t\t);\n\treturn m*p;\n}\n\nfloat sphere(vec3 p,float r){\n\treturn length(p)-r;\n}\n\nfloat plane(vec3 p){\n\treturn dot(p,vec3(0.2,3.0,0.0)+0.5);\n}\n\nfloat distFunc(vec3 p){\n\tvec3 q=rotate(p,radians(PI)*iTime*10.0,vec3(0.0,0.0,1.0));\n\t//vec3 q=rotate(p,radians(iTime)*20.0,vec3(1.0,0.0,1.0));\n\tfloat s1=sphere(q+vec3(0.0,0.0,0.0),1.0);\n\tfloat s2=sphere(q-vec3(0.0,0.0,0.0),0.95);\n\tfloat p1=plane(q);\n\treturn max(max(s1,-s2),p1);\n}\n\nvec3 sceneNormal(vec3 p){\n\tfloat d=distFunc(p);\n\treturn normalize(vec3(distFunc(p+EPS.xyy)-d,distFunc(p+EPS.yxy)-d,distFunc(p+EPS.yyx)-d));\n}\n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n\tvec2 p=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\n\tvec3 ro=vec3(0.0,0.0,2.0);\n\tvec3 rd=normalize(vec3(p,-1.0));\n\tfloat d,t=0.0;\n\tvec3 n,rp;\n\n\tfor(int i=0;i<MAX_STEPS;i++){\n\t\trp=ro+rd*t;\n\t\td=distFunc(rp);\n\t\tif(abs(d)<1e-4)break;\n\t\tt+=d;\n\t\t}\n\t\t\n\t\tn=sceneNormal(rp);\t\n\t\n\tfragColor=vec4(n,1.0);\n\t\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t3fzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 113, 113, 388], [390, 390, 419, 419, 442], [444, 444, 464, 464, 504], [506, 506, 529, 529, 786], [788, 788, 813, 813, 929], [932, 932, 985, 985, 1288]], "test": "valid"}
{"id": "3tcBDN", "name": "Projet GOPL", "author": "Noxerinno", "description": "Projet GOPL", "tags": ["projetgopl"], "likes": 1, "viewed": 61, "published": "Public", "date": "1614117676", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float FARAWAY=1e30;\nconst float EPSILON=1e-6;\n\n\n// Structure de la caméra\nstruct Camera {\n    vec3 Obs;    // Position de l'observateur\n    vec3 View;   // Vecteur unitaire pointant sur la cible\n    vec3 Horiz;  // Vecteur unitaire de la direction horizontale\n    vec3 Up;     // Vecteur unitaire de la direction verticale\n    float H;     // Hauteur de l'écran (px)\n    float W;     // Largeur de l'écran (px)\n    float z;     // Décalage de l'écran\n};\n\n// Structure du ray\nstruct Ray {\n    vec3 Origin;\n    vec3 Dir;\n};\n\n// Structure d'une sphère\nstruct Sphere {\n   vec3 Center;\n   float R;\n};\n\n// Initialisation de la caméra (Obs -> position de l'observateur; Target -> cible le point central & aperture -> angle d'ouverture)\nCamera camera(in vec3 Obs, in vec3 Target, in float aperture) {\n   Camera C;\n   C.Obs = Obs;\n   C.View = normalize(Target - Obs);\n   C.Horiz = normalize(cross(vec3(0.1, 0.1, 0.5), C.View));\n   C.Up = cross(C.View, C.Horiz);\n   C.W = float(iResolution.x);\n   C.H = float(iResolution.y);\n   C.z = (C.H/2.0) / tan((aperture * 3.1415 / 180.0) / 2.0);\n   return C;\n}\n\n// Fonction d'initialisation de la lumière\nRay launch(in Camera C, in vec2 XY) {\n   return Ray(\n      C.Obs,\n      C.z*C.View+(XY.x-C.W/2.0)*C.Horiz+(XY.y-C.H/2.0)*C.Up \n   );\n}\n\n// Gère les ombres des objets\nstruct Material {\n    vec3 Kd;       // diffuse color\n    vec3 Ke;       // emissive color\n    vec3 Kr;       // reflective material\n    float checker; // checkerboard size\n    vec3 Ks;       // specular\n    float s;       // specular factor\n};\n\n// Vecteur nul\nconst vec3 zero3 = vec3(0.0, 0.0, 0.0);\n\n// Créé un materiel diffus \nMaterial diffuse(in vec3 Kd) {\n   return Material(Kd, zero3, zero3, 0.0, zero3, 0.0);\n}\n\n// Source de lumière\nMaterial light(in vec3 Ke) {\n   return Material(zero3, Ke, zero3, 0.0, zero3, 0.0);\n}\n\n// Créé une surface réfléchissante\nMaterial mirror(in vec3 Kd, in vec3 Kr) {\n   return Material(\n     Kd, zero3, Kr, 0.0, vec3(1.0, 1.0, 1.0), 30.0\n   );\n}\n\n// Créé un damier\nMaterial checkerboard(in vec3 Kd, in vec3 Kr, in float sz) {\n   return Material(Kd, zero3, Kr, sz, zero3, 0.0);\n}\n\n// Structure d'un objet (forme + materiel)\nstruct Object {\n   Sphere sphere;\n   Material material;\n};\n\n// La scène est stockée dans un array global\nObject scene[18];\n\n\n// \\brief Initialise la scène\nvoid init_scene() {\n\n   scene[0] = Object(\n      Sphere(vec3(0.0, 0.0, -10000.0),9999.5),\n      // mirror(vec3(0.2, 0.5, 0.2), vec3(0.5, 0.5, 0.5))\n      checkerboard(vec3(0, 0, 0), vec3(0.5, 0.5, 0.5), 0.5)\n   );\n\n   //scene[1] = Object(\n   //   Sphere(vec3(1.0, 0.0, 1.0),0.02),\n   //   light(vec3(1.0, 1.0, 1.0))\n   //);\n   \n   scene[1] = Object(\n      Sphere(vec3(0.0, 0.0, 1.0),0.5), \n      mirror(vec3(0.5, 0.5, 0.5), vec3(1.0, 1.0, 1.0))\n   );\n   \n   //Haut\n   for(int i=0; i<5; ++i) {\n     float beta = float(iFrame)/30.0 + float(i)*6.28/5.0;\n     float s = sin(beta);\n     float c = cos(beta); \n\n     scene[i+2] = Object(\n        Sphere(vec3(0.7*s, 0.7*c, 2.0),0.1), \n        light(vec3(0.5, 0.5, 0.5))\n        //mirror(vec3(1.0, 0.7, 0.7), vec3(0.3, 0.3, 0.3))\n     );\n   }\n   \n   //Bas\n   for(int i=0; i<5; ++i) {\n     float beta = float(iFrame)/30.0 + float(i)*6.28/5.0;\n     float s = sin(beta);\n     float c = cos(beta); \n\n     scene[i+7] = Object(\n        Sphere(vec3(0.7*s, 0.7*c, 0.0),0.1), \n        light(vec3(0.5, 0.5, 0.5))\n        //mirror(vec3(1.0, 0.7, 0.7), vec3(0.3, 0.3, 0.3))\n     );\n   }\n   \n   //Ceinture\n   for(int i=0; i<5; ++i) {\n     float beta = -float(iFrame)/60.0 + float(i)*6.28/5.0;\n     float s = sin(beta);\n     float c = cos(beta); \n\n     scene[i+13] = Object(\n        Sphere(vec3(1.2*s, 1.2*c, 1.0),0.1), \n        mirror(vec3(1.0, 0.7, 0.7), vec3(0.3, 0.3, 0.3))\n     );\n   }\n}\n\n// Affichage d'une sphère\nbool intersect_sphere(in Ray R, in Sphere S, out float t) {\n   vec3 CO = R.Origin - S.Center;\n   float a = dot(R.Dir, R.Dir);\n   float b = 2.0*dot(R.Dir, CO);\n   float c = dot(CO, CO) - S.R*S.R;\n   float delta = b*b - 4.0*a*c;\n   if(delta < 0.0) {\n      return false;\n   }\n   t = (-b-sqrt(delta)) / (2.0*a);\n   return true;\n}\n\n// Calcule la réflexion de lumière\nRay reflect_ray(in Ray I, in vec3 P, in vec3 N) {\n   return Ray(\n      P,\n      -2.0*dot(N,I.Dir)*N + I.Dir\n   );\n}\n\n// \\brief Tests whether a Ray is in shadow\n// \\param[in] R a Ray that connects a point to a lightsource\n// \\retval true if the point is in shadow w.r.t. the lightsource\n// \\retval false otherwise\nbool shadow(in Ray R) {\n   for(int i=0; i<scene.length(); ++i) {\n        float t;\n        if(\n          scene[i].material.Ke == vec3(0.0, 0.0, 0.0) &&\n          intersect_sphere(R, scene[i].sphere, t) &&\n          t > EPSILON && t < 1.0\n        ) {\n          return true;\n        }\n    }\n    return false;\n}\n\n// \\brief Computes the lighting\n// \\param[in] P the intersection point\n// \\param[in] N the normal to the intersected surface at P\n// \\param[in] material the material\n// \\param[in] Ray the incident Ray\n// \\return the computed color\nvec3 lighting(\n   in vec3 P, in vec3 N, in Material material, in Ray R\n) {\n\n   // If it is a lightsource, then return its color\n   // (and we are done) \n   if(material.Ke != vec3(0.0, 0.0, 0.0)) {\n      return material.Ke;\n   }  \n\n   vec3 result = vec3(0.0, 0.0, 0.0);\n\n   // Compute the influence of all lightsources\n   for(int i=0; i<scene.length(); ++i) {\n      if(scene[i].material.Ke != vec3(0.0, 0.0, 0.0)) {\n         Ray R2 = Ray(P, scene[i].sphere.Center);\n         if(!shadow(R2)) {\n           vec3 E = scene[i].sphere.Center - P;\n  \n           // Diffuse lighting\n           float lamb = max(0.0, dot(E,N) / length(E));\n           vec3 Kd = material.Kd;\n           if(material.checker != 0.0 && \n              sin(P.x/material.checker)*\n              sin(P.y/material.checker) > 0.0) {\n               Kd = vec3(1.0, 1.0, 1.0) - Kd;\n           }\n           result += lamb * Kd * scene[i].material.Ke;\n\n           // Specular lighting\n           if(material.Ks != zero3) {\n               vec3 Er = 2.0*dot(N,E)*N - E;\n               vec3 View = R.Origin - P;\n               float spec=max(dot(Er,View),0.0);\n               spec /= sqrt(dot(Er,Er)*dot(View,View));\n               spec = pow(spec, material.s);\n               result += \n                  spec * material.Ks * scene[i].material.Ke;\n           }\n         }\n      }\n   }\n\n   return result;\n}\n\n// \\brief Computes the nearest intersection along a Ray\n// \\param[in] R the ray\n// \\param[out] P the intersection point\n// \\param[out] N the normal to the intersected surface at P\n// \\param[out] material the material of the intersected object\nbool nearest_intersection(\n   in Ray R, \n   out vec3 P, out vec3 N, out Material material\n) {\n   const float FARAWAY=1e30; \n   float t = FARAWAY;\n\n   for(int i=0; i<scene.length(); ++i) {\n       float cur_t;\n\n       if( intersect_sphere(R, scene[i].sphere, cur_t) \n          && cur_t < t && cur_t > EPSILON ) {\n           t = cur_t;\n           P = R.Origin + t*R.Dir;\n           N = normalize(P - scene[i].sphere.Center);\n           material = scene[i].material;\n       } \n   }\n   \n   return (t != FARAWAY);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n   // Yes, it is a bit stupid to call this for each pixel,\n   // but well, does not cost that much...\n   init_scene();\n\n   float beta = float(iFrame)/400.0;\n   float s = sin(beta);\n   float c = cos(beta); \n\n   // Initialize the Camera (and make it orbit around the\n   // origin)\n   Camera C = camera(\n       vec3(4.0*c, 4.0*s, 1.5),\n       vec3(1.0, 1.0, 1.0),\n       60.0       \n   );\n\n   // Lauch the primary ray that corresponds to this pixel\n   Ray R = launch(C, fragCoord);\n   \n   \n   fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n   vec3 P;  // Current intersected point\n   vec3 N;  // Normal to the intersected object at P\n   Material material; // Material of the intersected object\n \n   // Compute up to 5 ray bounces\n   vec3 Kr_cumul = vec3(1.0, 1.0, 1.0);\n   for(int k=0; k<5; ++k) {\n       if(nearest_intersection(R, P, N, material)) {\n          fragColor.rgb += Kr_cumul * lighting(P,N,material,R);\n          if(material.Kr == zero3) {\n              break;\n          }\n          Kr_cumul *= material.Kr;\n          R = reflect_ray(R, P, N);\n       } else {\n          fragColor.rgb += Kr_cumul * vec3(0, 0, 0);\n          break;\n       }\n   }\n}", "image_inputs": [{"id": "4llSRM", "previewfilepath": "https://soundcloud.com/oster-lapwass/la-baie-des-chiens-instrum", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/oster-lapwass/la-baie-des-chiens-instrum", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tcBDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[609, 742, 805, 805, 1103], [1105, 1149, 1186, 1186, 1283], [1618, 1648, 1678, 1678, 1735], [1737, 1759, 1787, 1787, 1844], [1846, 1885, 1926, 1926, 2005], [2007, 2027, 2087, 2087, 2140], [2312, 2343, 2362, 2362, 3762], [3764, 3791, 3850, 3850, 4116], [4118, 4155, 4204, 4204, 4270], [4272, 4468, 4491, 4491, 4775], [4777, 5008, 5082, 5160, 6369], [6371, 6614, 6707, 6707, 7123], [7125, 7125, 7182, 7285, 8330]], "test": "valid"}
{"id": "3tcBDX", "name": "bokeh experiment_01", "author": "YitingLiu", "description": "experimenting with bokeh and struct ", "tags": ["bokeh", "lights", "drive", "street", "artofcode"], "likes": 1, "viewed": 188, "published": "Public API", "date": "1613529060", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(x, y, t) smoothstep(x, y, t)\n\n\nstruct ray {\n    vec3 o,d;\n};\n\nray GetRay(vec2 uv, vec3 camPos, vec3 lookat, float zoom){\n    ray a;\n    a.o = camPos;\n    \n    vec3 f = normalize(lookat-camPos);\n    vec3 r = cross(vec3(0,1,0),f);\n    vec3 u = cross(f,r);\n    vec3 c = a.o + f*zoom;\n    vec3 i = c+uv.x*r+uv.y *u;\n    a.d=normalize(i-a.o);\n    \n    return a;\n}\n\nvec3 ClosetPoint(ray r, vec3 p){\n    return r.o+max(0.,dot(p-r.o,r.d))*r.d;\n\n}\n\nfloat DistRay(ray r, vec3 p){\n    return length(p-ClosetPoint(r,p));\n}\n\nfloat Bokeh (ray r, vec3 p, float size, float blur){\n    size*=length(p);\n    float d = DistRay(r,p);\n    float c = S(size, size*(1.-blur),d);\n    c*=mix(.6,1.,S(size*.8,size,d));\n    return c;\n\n}\n\nvec3 Streetlights(ray r, float t){\n    float side = step(r.d.x,0.);\n   \n    r.d.x=abs(r.d.x);\n\n    float s = 1./10.;\n    float m = 0.;\n    \n    for(float i=0.; i < 1.; i+=s){\n    float ti = fract(t+i+side*s*.5);\n    vec3 p = vec3(2.,2.,100.-ti*100.);\n    m+= Bokeh(r,p,.1,.1)*ti*ti*ti*ti;\n    }\n    return  vec3(1.,.7,.3)*m;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv-=.5;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    vec3 camPos = vec3(0,.2,0);\n    vec3 lookat = vec3(0,.2,1.);\n    \n    ray r = GetRay(uv,camPos,lookat,2.);\n   \n     float t = iTime*.1;  \n\n    vec3 col = Streetlights(r,t);\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tcBDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 130, 130, 368], [370, 370, 402, 402, 448], [450, 450, 479, 479, 520], [522, 522, 574, 574, 718], [720, 720, 754, 754, 1047], [1049, 1049, 1105, 1155, 1463]], "test": "valid"}
{"id": "3tcBz7", "name": "[phreax]  butterfly effect", "author": "phreax", "description": "Raymarching, kifs, non-linear time", "tags": ["raymarching", "kifs"], "likes": 5, "viewed": 227, "published": "Public API", "date": "1613272663", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Creative Commons Licence Attribution-NonCommercial-ShareAlike \n   phreax 2021\n*/\n\n#define PI 3.141592\n#define SIN(x) (sin(x)*.5+.5)\n#define hue(v) ( .6 + .6 * cos( 6.3*(v) + vec3(0,23,21) ) )\n#define RAINBOW 0\n#define SYMMETRICAL 0\n\nfloat tt;\n\nmat2 rot2(float a) { return mat2(cos(a), sin(a), -sin(a), cos(a)); }\n\n\n// by Nusan\nfloat curve(float t, float d) {\n  t/=d;\n  return mix(floor(t), floor(t)+1., pow(smoothstep(0.,1.,fract(t)), 10.));\n}\n\n\nvec3 transform(vec3 p) {\n    float a = PI*.5*curve(iTime, 4.);\n    \n    // rotate object\n    p.xz *= rot2(a);\n    p.xy *= rot2(a);\n    return p;\n}\n\nfloat map(vec3 p) {\n\n    vec3 bp = p;\n\n    p = transform(p);\n\n    #if SYMMETRICAL\n    p.y = -(abs(p.y) -.3);  \n    #endif\n    \n    p.x *= 1.+SIN(curve(iTime, 4.))*(smoothstep(-0.9, 0.9, -p.y));\n    p.z *= 1.+.5*(smoothstep(-0.9, 1.5, -p.y));\n\n\n    p.x = abs(p.x) -.5*SIN(tt*.5);\n    p.y = abs(p.y) -.9*SIN(tt*.8);\n    p.y -= 0.1;\n    p.y = abs(p.y) -.1;\n    p.x -= 0.2;\n    p.x = abs(p.x) -.9; \n    p.z = abs(p.z) -.5;\n\n    p.zy -= 0.5;\n    p.xy *= rot2(0.1*tt);\n    p.zy *= rot2(-.04*tt);\n                           \n\n    // torus\n    float r1 = 1.0;\n    float r2 = 0.03;\n    \n    vec2 cp = vec2(length(p.xz) - r1, p.y);\n    vec2 cp2 = cp;\n    \n    // torus knots by BigWings\n    float a = atan(p.z, p.x);\n    cp *= rot2(3.*a+tt);\n    cp.x = abs(cp.x) - .3;\n\n    cp *= rot2(3.*a);\n    \n    // kifs\n    float n = 10.;\n    for(float i = 0.; i< n; i++) {\n    \n        cp.y = abs(cp.y) -.05*(.5*sin(tt)+.9);\n        \n        cp *= rot2(0.1*a*sin(0.1*iTime));\n        cp -= i*0.01/n;\n    }\n\n    \n    float d = length(cp) - r2;\n  \n    return .4*d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    float cz = -5.+1.5*sin(curve(iTime, 4.));\n    \n    vec3 ro = vec3(0, .0, cz),\n         rd = normalize(vec3(uv, .7));\n         \n    vec3 p = ro;\n    vec3 col;\n    \n    float t, d = 0.1;\n    \n    tt = iTime;  \n    tt = tt+2.*curve(tt, 2.);\n    \n    float acc = 0.0;\n    for(float i=.0; i<200.; i++) {\n    \n        d = map(p);\n        \n        if(d < 0.0001 || t > 100.) break;\n        \n        // Phantom mode https://www.shadertoy.com/view/MtScWW\n        d = max(abs(d), 0.009);\n        acc += 0.07;\n        \n        t += d;\n        p += rd*d;\n    }\n       \n    if(d < 0.001) {\n        col += acc*clamp(1., 0., 1.2*abs(cz)/(t*t));\n          \n        float sl = dot(p,p);\n        #if RAINBOW\n            col *= 0.5*hue(1.-0.1*sqrt(sl)+0.05*p.z+.25*iTime+curve(iTime, 8.));\n        #else\n            col *= mix(vec3(0, .85, .75), vec3(1.000,0.541,0.141), 1.-0.1*sl+0.1*p.z);\n        #endif\n    }\n    \n    \n    col = pow(col, vec3(1.3));\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0 - t * 0.3);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tcBz7.jpg", "access": "shaders20k", "license": "cc-by-nc-4.0", "functions": [[0, 247, 267, 267, 315], [318, 330, 361, 361, 446], [449, 449, 473, 473, 595], [597, 597, 616, 616, 1641], [1643, 1643, 1700, 1700, 2775]], "test": "valid"}
{"id": "3tcBz8", "name": "Neural cat 3D", "author": "iuryBorgesRodrigues", "description": "Neural cat 3D", "tags": ["sdf", "cat", "neural"], "likes": 4, "viewed": 75, "published": "Public", "date": "1612179926", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//like the last few shaders I've published, this is a neural network experiment.\n//this time, the neural network reproduces an SDF given the x,y,z coordinates\n//using siren networks with skip connections: https://vsitzmann.github.io/siren/\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat scene(vec3 p) {\n    //sdf is undefined outside the unit sphere, uncomment to witness the abominations\n    if (length(p) > 1.) {\n        return length(p)-.8;\n    }\n    //neural networks can be really compact... when they want to be\n    vec4 f0_0=sin(p.y*vec4(1.502,-1.184,3.061,.227)+p.z*vec4(.000,-1.418,-2.788,-1.376)+p.x*vec4(1.857,3.782,2.983,-4.282)+vec4(-3.023,5.317,-5.555,-.046));\nvec4 f0_1=sin(p.y*vec4(2.890,-.295,-3.610,2.310)+p.z*vec4(-1.802,-3.118,-2.365,-1.544)+p.x*vec4(1.200,1.345,-2.545,.916)+vec4(7.336,-6.956,-.152,-4.236));\nvec4 f0_2=sin(p.y*vec4(-.374,.646,4.128,2.860)+p.z*vec4(-3.812,-.837,-1.259,1.401)+p.x*vec4(.961,-1.831,-1.602,1.766)+vec4(-4.958,3.274,3.618,1.220));\nvec4 f0_3=sin(p.y*vec4(-.441,4.009,3.048,2.976)+p.z*vec4(.452,-1.903,-1.973,3.610)+p.x*vec4(.266,.127,-.481,-2.975)+vec4(5.864,2.952,-7.839,-5.747));\nvec4 f1_0=sin(mat4(-.193,.063,-.129,-.036,-.214,-.700,.473,.520,.326,.289,-.305,.212,-.405,.545,.024,.094)*f0_0+\n    mat4(-.001,-.020,.376,-1.006,-1.017,-.381,.729,.030,.280,.597,.559,-.431,-.148,-.269,-.285,-1.297)*f0_1+\n    mat4(-.514,-.293,-.146,.769,.069,.792,-.344,.780,-.035,.001,.435,.196,.166,.468,-.697,.217)*f0_2+\n    mat4(.135,.055,-.886,1.651,-.524,.554,-.153,-.358,-.382,-.117,-1.086,-.758,-.064,.213,.620,.459)*f0_3+\n    vec4(-2.677,.044,-1.291,-.712))/1.0+f0_0;\nvec4 f1_1=sin(mat4(-.587,-.047,-.527,-.206,.110,-.282,-.944,.255,.337,.072,.572,-.138,.530,.121,-.040,-.170)*f0_0+\n    mat4(.038,.302,-.095,-.096,-.256,.368,-.923,.219,.279,.281,.028,-.081,-.377,.222,-.281,.247)*f0_1+\n    mat4(-.339,.527,-.283,-.211,.070,-.534,-.119,-.447,-.751,-.126,.021,-.325,-.189,.087,.600,-.344)*f0_2+\n    mat4(.343,-.563,.197,-.704,-.426,-.587,.103,-.430,.201,.186,-.344,.378,.791,.244,-.308,-.167)*f0_3+\n    vec4(-2.308,-2.232,-.857,-2.855))/1.0+f0_1;\nvec4 f1_2=sin(mat4(-.319,-.484,-.032,-.113,.307,-.238,.349,.408,.267,-.387,.430,.131,-.386,-.028,-.201,.492)*f0_0+\n    mat4(.206,.207,-.351,.047,1.026,-.256,.875,.251,-.142,-.137,-.202,.261,-.515,-.068,-.383,.706)*f0_1+\n    mat4(.046,-.215,-.645,-1.272,-.412,.731,-1.112,-.048,.145,.429,-.074,-.132,.425,.570,.752,-.621)*f0_2+\n    mat4(-.660,.434,.224,.812,-.433,-.023,-.659,-.517,.150,-.005,-.196,.512,-.079,.054,.111,-.029)*f0_3+\n    vec4(-1.488,2.032,-1.831,-.031))/1.0+f0_2;\nvec4 f1_3=sin(mat4(-1.361,-1.373,-.623,-.686,-.163,-.643,-.374,.518,.025,-.008,-.122,-.138,-.323,-.177,-.324,.563)*f0_0+\n    mat4(.289,.064,-.279,.869,.203,1.391,-.790,-.989,-.231,.192,.288,.186,.071,.078,.159,-1.050)*f0_1+\n    mat4(.795,-.065,-.585,-.512,-.397,-.598,.370,.502,-.225,.315,.773,.162,.320,.498,-.613,.157)*f0_2+\n    mat4(-.217,-.566,-.783,.548,-.683,-.097,.219,-.207,.617,.949,-.401,-.921,.392,.099,-.594,-.474)*f0_3+\n    vec4(-1.889,-.884,-2.029,1.328))/1.0+f0_3;\nvec4 f2_0=sin(mat4(.942,.177,-.155,-.237,-.632,1.088,.021,1.177,.060,.129,.499,.204,-.112,.049,.120,-.574)*f1_0+\n    mat4(.328,.990,-.708,-.116,.199,-.353,1.515,-.681,-.624,.185,.692,-.817,.808,-.321,-.164,-.386)*f1_1+\n    mat4(.368,.169,.637,-.681,.943,-1.384,1.048,-.876,-.390,-.028,1.109,-.901,-.718,.850,.263,-.034)*f1_2+\n    mat4(-.200,.228,.077,1.050,-.298,-.563,.017,-.617,.782,.557,-.303,-.310,.085,-.072,-.486,-.531)*f1_3+\n    vec4(.064,1.607,3.346,-2.004))/1.4+f1_0;\nvec4 f2_1=sin(mat4(-.383,-.092,.159,-.262,-2.544,1.476,.812,.239,.437,.016,.372,.086,.364,-.415,-.396,-.578)*f1_0+\n    mat4(.221,.019,-.557,-.060,.107,-.889,.562,-.535,.451,-.446,.459,-.138,-.163,.188,-1.000,.882)*f1_1+\n    mat4(.144,-.461,.849,.169,-.172,-.000,.230,.625,.517,.043,.512,-.307,.604,.056,-.140,-.223)*f1_2+\n    mat4(.097,.818,-.766,-.152,-.173,.173,-.359,-.351,-.526,.694,-1.364,.040,-.147,-.958,-.190,-.214)*f1_3+\n    vec4(-1.796,-.087,-2.996,-2.751))/1.4+f1_1;\nvec4 f2_2=sin(mat4(.609,.274,-.368,-.554,-.154,-.247,1.479,.328,-.179,.623,-.109,-.898,-.228,-.399,-.476,-.207)*f1_0+\n    mat4(-.213,-.356,-.549,1.001,-.885,.178,.383,-.894,.245,-.311,-1.100,-.177,-.146,-.643,.025,-1.632)*f1_1+\n    mat4(-.633,.567,.584,.272,.197,.327,.243,-.242,.212,-.028,-.087,.277,-.064,-.341,-.779,.671)*f1_2+\n    mat4(-.588,-.377,.191,1.527,.121,-.120,-.885,-.863,-.025,-.164,.171,.740,.088,-.039,-.150,.035)*f1_3+\n    vec4(-3.244,.714,.341,-.007))/1.4+f1_2;\nvec4 f2_3=sin(mat4(.127,-.231,-.265,-.454,-.666,-.326,.326,-.894,-.034,.302,.122,-.790,.373,.858,-.778,.274)*f1_0+\n    mat4(.689,.367,-.290,-.492,.216,-1.088,.431,-.385,.290,.222,-.536,-.088,.540,.812,.147,.954)*f1_1+\n    mat4(1.184,-.418,-.105,.891,.356,.213,.498,.095,.458,.086,.176,.139,.866,-.951,.070,.332)*f1_2+\n    mat4(-.112,.110,-.095,1.258,-.428,.318,.187,-.477,.190,-.109,.074,.650,-.026,-.522,-.040,.605)*f1_3+\n    vec4(.449,1.689,1.221,.431))/1.4+f1_3;\nreturn dot(f2_0,vec4(.062,-.055,.033,.031))+\n    dot(f2_1,vec4(.044,-.060,-.034,-.092))+\n    dot(f2_2,vec4(-.103,.072,.046,.019))+\n    dot(f2_3,vec4(-.068,.061,.108,-.019))+\n    0.265;\n\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 cam = normalize(vec3(1.5,uv));\n    vec3 init = vec3(-3.,0,0);\n    \n    float yrot = 0.5;\n    float zrot = iTime*.2;\n    if (iMouse.z > 0.) {\n        yrot += -4.*mouse.y;\n        zrot = 4.*mouse.x;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n    \n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 150 && !hit; i++) {\n        float dist = scene(p/vec3(1.0));\n        hit = dist*dist < 1e-6;\n        p+=dist*cam;\n        if (distance(p,init)>5.) break;\n    }\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    //don't ask how I stumbled on this texture\n    vec3 nz = p - erot(p, vec3(1), 2.) + erot(p, vec3(1), 4.);\n    float spec = length(sin(r*3.5+sin(nz*120.)*.15)*.4+.6)/sqrt(3.);\n    spec *= smoothstep(-.3,.2,scene(p+r*.2));\n    vec3 col = vec3(.1,.1,.12)*spec + pow(spec,8.);\n    float bgdot = length(sin(cam*8.)*.4+.6)/2.;\n    vec3 bg = vec3(.1,.1,.11) * bgdot + pow(bgdot, 10.);\n    fragColor.xyz = hit ? col : bg;\n    fragColor = smoothstep(-.02,1.05,sqrt(fragColor)) * (1.- dot(uv,uv)*.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tcBz8.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[194, 435, 473, 473, 535], [537, 537, 558, 644, 5389], [5391, 5391, 5410, 5410, 5526], [5528, 5528, 5585, 5585, 6863]], "test": "valid"}
{"id": "3tcBzH", "name": "Perlin noise fire shader", "author": "trinketMage", "description": "Perlin Noise generation, fire shader after @febucci\nhttps://www.febucci.com/2019/05/fire-shader/\nAvailable on Cineshader here: https://cineshader.com/view/3tcBzH", "tags": ["perlinnoise", "fire", "cineshader"], "likes": 10, "viewed": 2642, "published": "Public API", "date": "1612193263", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat hermite(float t)\n{\n  return t * t * (3.0 - 2.0 * t);\n}\n\nfloat noise(vec2 co, float frequency)\n{\n  vec2 v = vec2(co.x * frequency, co.y * frequency);\n\n  float ix1 = floor(v.x);\n  float iy1 = floor(v.y);\n  float ix2 = floor(v.x + 1.0);\n  float iy2 = floor(v.y + 1.0);\n\n  float fx = hermite(fract(v.x));\n  float fy = hermite(fract(v.y));\n\n  float fade1 = mix(rand(vec2(ix1, iy1)), rand(vec2(ix2, iy1)), fx);\n  float fade2 = mix(rand(vec2(ix1, iy2)), rand(vec2(ix2, iy2)), fx);\n\n  return mix(fade1, fade2, fy);\n}\n\nfloat pnoise(vec2 co, float freq, int steps, float persistence)\n{\n  float value = 0.0;\n  float ampl = 1.0;\n  float sum = 0.0;\n  for(int i=0 ; i<steps ; i++)\n  {\n    sum += ampl;\n    value += noise(co, freq) * ampl;\n    freq *= 2.0;\n    ampl *= persistence;\n  }\n  return value / sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float gradient = 1.0 - uv.y;\n    float gradientStep = 0.2;\n    \n    vec2 pos = fragCoord.xy / iResolution.x;\n    pos.y -= iTime * 0.3125;\n    \n    vec4 brighterColor = vec4(1.0, 0.65, 0.1, 0.25);\n    vec4 darkerColor = vec4(1.0, 0.0, 0.15, 0.0625);\n    vec4 middleColor = mix(brighterColor, darkerColor, 0.5);\n\n    float noiseTexel = pnoise(pos, 10.0, 5, 0.5);\n    \n    float firstStep = smoothstep(0.0, noiseTexel, gradient);\n    float darkerColorStep = smoothstep(0.0, noiseTexel, gradient - gradientStep);\n    float darkerColorPath = firstStep - darkerColorStep;\n    vec4 color = mix(brighterColor, darkerColor, darkerColorPath);\n\n    float middleColorStep = smoothstep(0.0, noiseTexel, gradient - 0.2 * 2.0);\n    \n    color = mix(color, middleColor, darkerColorStep - middleColorStep);\n    color = mix(vec4(0.0), color, firstStep);\n\tfragColor = color;\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Fire shader\",\n\t\"description\": \"Fire shader after @febucci\",\n\t\"model\": \"nothing\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tcBzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 92], [94, 94, 118, 118, 154], [156, 156, 195, 195, 608], [610, 610, 675, 675, 894], [896, 896, 953, 953, 1857]], "test": "valid"}
{"id": "3tcfW4", "name": "Mandelbox MB-4", "author": "darkeclipz", "description": "Another variation of the Mandelbox.", "tags": ["fractal", "raymarch", "mandelbox"], "likes": 5, "viewed": 237, "published": "Public API", "date": "1612702966", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R iResolution.xy\n#define MaxSteps 50.\n#define MinDistance 0.001\n#define eps 0.001\n\n// more ideas for different Mandelboxes:\n// http://archive.bridgesmathart.org/2018/bridges2018-547.pdf\n\nfloat distFromOrigin = 0.0;\nfloat lissoujasSize = 3.5;\n\nvec3 magma(float t) { // from Mattz\n    t *= 2.0;\n    if(t > 1.0) { t = 2.0-t; }\n    const vec3 c0 = vec3(-0.002136485053939582, -0.000749655052795221, -0.005386127855323933);\n    const vec3 c1 = vec3(0.2516605407371642, 0.6775232436837668, 2.494026599312351);\n    const vec3 c2 = vec3(8.353717279216625, -3.577719514958484, 0.3144679030132573);\n    const vec3 c3 = vec3(-27.66873308576866, 14.26473078096533, -13.64921318813922);\n    const vec3 c4 = vec3(52.17613981234068, -27.94360607168351, 12.94416944238394);\n    const vec3 c5 = vec3(-50.76852536473588, 29.04658282127291, 4.23415299384598);\n    const vec3 c6 = vec3(18.65570506591883, -11.48977351997711, -5.601961508734096);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\nvec3 viridis_quintic( float x )\n{\n    x *= 2.0;\n    if(x > 1.0) { x = 2.0-x; }\n\t//x = saturate( x );\n\tvec4 x1 = vec4( 1.0, x, x * x, x * x * x ); // 1 x x2 x3\n\tvec4 x2 = x1 * x1.w * x; // x4 x5 x6 x7\n\treturn vec3(\n\t\tdot( x1.xyzw, vec4( +0.280268003, -0.143510503, +2.225793877, -14.815088879 ) ) + dot( x2.xy, vec2( +25.212752309, -11.772589584 ) ),\n\t\tdot( x1.xyzw, vec4( -0.002117546, +1.617109353, -1.909305070, +2.701152864 ) ) + dot( x2.xy, vec2( -1.685288385, +0.178738871 ) ),\n\t\tdot( x1.xyzw, vec4( +0.300805501, +2.614650302, -12.019139090, +28.933559110 ) ) + dot( x2.xy, vec2( -33.491294770, +13.762053843 ) ) );\n}\n\nmat3 rotateX(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(1, 0, 0, 0, c, -s, 0, s, c);\n}\n\nmat3 rotateY(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n}\n\nmat3 rotateZ(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(c,-s,0,s,c,0,0,0,1);\n}\n\nfloat sdSphere(vec3 p, float r) {\n\treturn length(p) - r;    \n}\n\n// from iq\nfloat sdPlane(in vec3 p, in vec4 n)\n{\n  return dot(p,n.xyz) + n.w;\n}\n\n// from iq\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0));\n        \n}\n\n// https://github.com/HackerPoet/MarbleMarcher/blob/master/assets/frag.glsl\nvec3 boxFold(vec3 z, vec3 r) {\n\treturn clamp(z.xyz, -r, r) * 2.0 - z.xyz;\n}\n\n// http://www.fractalforums.com/fragmentarium/fragmentarium-an-ide-for-exploring-3d-fractals-and-other-systems-on-the-gpu/15/\nvoid sphereFold(inout vec3 z, inout float dz) {\n    // float c2 = distFromOrigin / lissoujasSize * 3.5;\n    float c2 = distFromOrigin / lissoujasSize * 3.8;\n    float fixedRadius2 = 6.5 - c2;\n    float minRadius2 = 0.3;\n\tfloat r2 = dot(z,z);\n\tif (r2< minRadius2) {\n\t\tfloat temp = (fixedRadius2/minRadius2);\n\t\tz*= temp;\n\t\tdz*=temp;\n\t} \n    else if (r2<fixedRadius2) {\n\t\tfloat temp =(fixedRadius2/r2);\n\t\tz*=temp;\n\t\tdz*=temp;\n\t}\n}\n\n// https://github.com/HackerPoet/MarbleMarcher/blob/master/assets/frag.glsl\nvec3 mengerFold(vec3 z) {\n\tfloat a = min(z.x - z.y, 0.0);\n\tz.x -= a;\n\tz.y += a;\n\ta = min(z.x - z.z, 0.0);\n\tz.x -= a;\n\tz.z += a;\n\ta = min(z.y - z.z, 0.0);\n\tz.y -= a;\n\tz.z += a;\n    return z;\n}\n\n\n\n// http://blog.hvidtfeldts.net/index.php/2011/11/distance-estimated-3d-fractals-vi-the-mandelbox/\nvec2 DE(vec3 z)\n{\n    float Iterations = 20.;\n    \n    float c1 = (distFromOrigin/lissoujasSize)*2.5;\n    float Scale = 2. + c1;\n    \n    //Scale = 5.8-(distFromOrigin/lissoujasSize)*1.5;\n\n\tvec3 offset = z;\n\tfloat dr = 1.0;\n    float trap = 1e10;\n\tfor (float n = 0.; n < Iterations; n++) {\n        //z = mengerFold(z);\n        z = boxFold(z, vec3(2.2));       // Reflect\n        sphereFold(z, dr);    // Sphere Inversion\n        z.xz = -z.zx;\n        //sphereFold(z, dr);    // Sphere Inversion\n\t\tz = boxFold(z, vec3(0.9));       // Reflect\n        \n\t\tsphereFold(z, dr);    // Sphere Inversion\n        z=Scale*z + offset;  // Scale & Translate\n        dr = dr*abs(Scale)+1.0;\n        trap = min(trap, length(z));\n\t}\n\tfloat r = length(z);\n\treturn vec2(r/abs(dr), trap);\n}\n\nvec2 scene(vec3 p) {  \n    \n    vec2 box = DE(p);\n\treturn box;\n}\n\nfloat shadowScene(vec3 p){\n\treturn DE(p).x;\n}\n\n// from iq\nvec3 calcNormal(vec3 p) {\n    float h = 0.001;\n    vec2 k = vec2(1,-1);\n    vec3 n = normalize( k.xyy*scene( p + k.xyy*h ).x + \n                  k.yyx*scene( p + k.yyx*h ).x + \n                  k.yxy*scene( p + k.yxy*h ).x + \n                  k.xxx*scene( p + k.xxx*h ).x );    \n    return n;\n}\n\n// ro: ray origin, rd: ray direction\n// returns t and the occlusion as a vec2\nvec3 march(vec3 ro, vec3 rd) {\n    float t = 0.2, i = 0.;\n    for(i=0.; i < MaxSteps; i++) {\n    \tvec3 p = ro + t * rd;\n        vec2 hit = scene(p);\n        float dt = hit.x;\n        t += dt;\n        if(dt < MinDistance*(1.0+t/10.0)) {\n        \treturn vec3(t-MinDistance, 1.-i/MaxSteps, hit.y);  \n        }\n    }\n    return vec3(0.);\n}\n\nfloat marchShadow(vec3 ro, vec3 rd) {\n\tfloat t = 0., i = 0.;\n    for(i=0.; i < MaxSteps; i++) {\n    \tvec3 p = ro + t * rd;\n        float dt = shadowScene(p);\n        t += dt;\n        if(dt < MinDistance) {\n        \treturn t-MinDistance;    \n        }\n    }\n    return 0.;\n}\n\nfloat G1V(float dotNV, float k) {\n    return 1.0 / (dotNV * (1.0 - k) + k);\n}\n\n// http://filmicworlds.com/blog/optimizing-ggx-shaders-with-dotlh/\nfloat brdf_ggx(vec3 N, vec3 V, vec3 L, float roughness, float F0) {\n    float alpha = roughness * roughness;\n    vec3 H = normalize(V+L);\n    float dotNL = clamp(dot(N,L), 0., 1.);\n    float dotNV = clamp(dot(N,V), 0., 1.);\n    float dotNH = clamp(dot(N,H), 0., 1.);\n    float dotLH = clamp(dot(L,H), 0., 1.);\n    float alphaSqr = alpha*alpha;\n    float pi = 3.14159;\n    float denom = dotNH * dotNH * (alphaSqr - 1.0) + 1.0;\n    float D = alphaSqr / (pi * denom * denom);\n    float dotLH5 = pow(1.0 - dotLH, 5.0);\n    float F = F0 + (1.0 - F0) * dotLH5;\n    float k = alpha / 2.0;\n    float vis = G1V(dotNL, k) * G1V(dotNV, k);\n    return dotNL * D * F * vis;\n}\n\nvec3 calcLight(vec3 P, vec3 N, vec3 Lpos, vec3 V, vec3 diffuse, vec3 specular) {\n    vec3 L = normalize(Lpos-P);\n    float NdotL = max(dot(N, L), 0.0);\n    vec3 diff = NdotL * diffuse;\n    vec3 spec = brdf_ggx(N, V, L, 0.3, 0.02) * specular;\n    return diff + spec;\n}\n\n// p: point, sn: surface normal, rd: ray direction (view dir/ray from cam)\nvec3 light(vec3 p, vec3 sn, vec3 rd, vec3 ro, float trap) {\n    \n    vec3 V = normalize(ro-p);\n    vec3 L = normalize(ro-p);\n    vec3 N = sn;\n    vec3 Refl = reflect(L, N);\n    float NdotL = max(0.0, dot(N, L));\n    \n\n    float pulse = smoothstep(.2, -.2, abs(fract(0.25*trap + 0.1)-0.5));\n    \n    vec3 ambient = vec3(0.);\n    vec3 diffuse = magma(fract(0.15*trap)) \n        + 1.0*magma(fract(0.15*trap)) * pulse\n        ;\n\n    vec3 specular = magma(fract(0.15*trap));\n    \n    //diffuse = vec3(1.0);\n    //specular = vec3(1.0);\n    \n    \n    vec3 front = calcLight(p, N, ro, V, diffuse, vec3(1.0));\n    vec3 bac = calcLight(p, N, vec3(0,1,0), V, diffuse, vec3(1.0));\n    vec3 center = calcLight(p, N, vec3(0,0,0), V, diffuse, vec3(1.0));\n    \n    return ambient + 0.8*front + 0.3*bac + 0.55*center;\n}\n\n// https://iquilezles.org/www/articles/palettes/palettes.htm\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos(6.28318 * (c*t + d));\n}\n\nvec3 camPos(float t) {\n    float x = cos(5.0*t);\n    float y = sin(3.0*t);\n    float z = cos(7.0*t);\n    return lissoujasSize*vec3(x,y,z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-R)/R.y;\n    vec3 fog = vec3(.3,.2,.3) * 0.5;\n    vec3 col = vec3(fog);\n\n    float speed = 0.02;\n    float time = (iTime +93.6) * speed;\n    \n    vec3 ro = camPos(time);\n    \n    distFromOrigin = length(ro);\n    \n    \n    vec3 ta = camPos(time+speed);\n    vec3 ww = normalize(ta-ro);\n    vec3 uu = normalize(cross(ww, vec3(0,1,0)));\n    vec3 vv = normalize(cross(uu,ww));\n    vec3 rd = normalize(uv.x*uu + uv.y*vv + 1.0*ww);\n    \n    //mat3 rot = rotateX(0.2) * rotateZ(-3.1415/2. - 0.2) * rotateY(iTime/16.);\n    \n    //ro -= vec3(0,1,15);\n    \n    vec3 hit = march(ro, rd); // returns t and the occlusion value \n    float t = hit.x;\n    \n    if(t > eps) {\n        vec3 p = ro + t * rd;\n    \tvec3 n = calcNormal(p);\n        col = clamp(light(p, n, rd, ro, hit.z), 0.0, 1.0);\n        col *= (.5*hit.y+.5);   // occlusion \n        \n        float fog_max = 5.5,\n              fog_min = 4.;\n        float fog_alpha = clamp(1. - (fog_max - t) / (fog_max - fog_min), 0.0, 1.0);\n        col = mix(col, fog, fog_alpha);\n    }\n    else {\n        col = vec3(fog);\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tcfW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 251, 272, 286, 990], [992, 992, 1025, 1025, 1615], [1617, 1617, 1644, 1644, 1730], [1732, 1732, 1759, 1759, 1845], [1847, 1847, 1874, 1874, 1952], [1954, 1954, 1987, 1987, 2016], [2018, 2029, 2066, 2066, 2097], [2099, 2110, 2141, 2141, 2204], [2206, 2282, 2312, 2312, 2357], [2359, 2485, 2532, 2588, 2912], [2914, 2990, 3015, 3015, 3181], [3185, 3283, 3300, 3300, 4053], [4055, 4055, 4075, 4075, 4119], [4121, 4121, 4147, 4147, 4166], [4168, 4179, 4204, 4204, 4476], [4478, 4556, 4586, 4586, 4891], [4893, 4893, 4930, 4930, 5166], [5168, 5168, 5201, 5201, 5245], [5247, 5314, 5381, 5381, 5976], [5978, 5978, 6058, 6058, 6245], [6247, 6322, 6381, 6381, 7124], [7126, 7187, 7255, 7255, 7300], [7302, 7302, 7324, 7324, 7442], [7444, 7444, 7501, 7501, 8623]], "test": "valid"}
{"id": "3tcfWj", "name": "Peebeearray", "author": "ruojake", "description": "Taking physically based rendering for a spin", "tags": ["3d", "raymarching", "brdf"], "likes": 11, "viewed": 258, "published": "Public API", "date": "1613417810", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Peebeearray by Kristian Sivonen (ruojake)\n// CC BY-SA 4.0 (https://creativecommons.org/licenses/by-sa/4.0/)\n\n// 2021-02-16:\n// - Separated metallic and roughness parameters,\n//   resulting in more diverse materials\n// - Added random offset to noise per sphere\n// - Adjusted color selection\n// - Removed negative light (oops!) and\n//   darkened the bottom of the sky accordingly\n// - Boosted diffuse lighting\n// - Made light shape less awkward\n// - Moved camera back and tightened FOV\n\n// 2021-02-17:\n// - Fixed some enormous goofs re: noise,\n//   now pattern sharpness has variation\n// - Improved noise interpolation\n\n// 2021-02-22:\n// - Squared glare falloff and boosted it a bit\n\n#define sat(x) clamp(x, 0., 1.)\n\nvec3 hash32(vec2 p)\n{\n    vec3 q = vec3(p, fract(p.x * 31.));\n    return fract(sin(q * vec3(11.312, 17.415, 13.651)) * 5131.931);\n}\n\nvec3 hash33(vec3 p)\n{\n    return fract(sin(p * vec3(11.312, 17.415, 13.651) + dot(p, vec3(.523))) * 41251.931) * 2. - 1.;\n}\n\nmat2 rot(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat index(vec3 p)\n{\n    p -= vec3(0,0,3);\n    return fract(.621 + 6143.21 * sin(dot(floor(p.xy * .5 + .5), vec2(31.73, 23.46))));\n}\n\nfloat scene(vec3 p)\n{\n    p -= vec3(0,0,3);\n    p.xy = fract(p.xy * .5 + .5) * 2. - 1.;\n    return length(p) - .8;\n}\n\nvec3 normal(vec3 p, float d)\n{\n    const vec2 e = vec2(.001, 0.);\n    return normalize(d - vec3(\n        scene(p - e.xyy),\n        scene(p - e.yxy),\n        scene(p - e.yyx)\n    ));\n}\n\nvec3 color(float v)\n{\n    vec3 res = vec3(1.,0,0);\n    res.xy *= rot(v * 139.);\n    res.yz *= rot(v * 199.);\n    res *= res;\n    float lum = dot(res, vec3(.2126, .7152, .0722));\n    return mix(vec3(lum), res, fract(v * 311.)) * fract(v * 239.);\n}\n\nvec3 sky(vec3 rd, vec3 ld, float k)\n{\n    vec3 col = mix(vec3(.005, .02, .05), vec3(1., .1, .5) * 1.25, rd.y * .5 + .5);\n    float sun = sat(dot(rd, ld));\n    k = max(k, .0001);\n    col += pow(sat((sun - .9992 + k) / k), 5. / k) * (30. - 25. * k * (2. - k)) + sun * sun * vec3(1.,.9,.8) * (.25 + k);\n    return col;\n}\n\nfloat fresnel(float v)\n{\n    return pow(1. - v, 5.);\n}\n\n// https://google.github.io/filament/Filament.md.html#table_texturedfg\nvec3 DFGAppr(vec3 f0, float ndv, float roughness)\n{\n    vec4 c0 = vec4(-1., -.0275, -.572, .022);\n    vec4 c1 = vec4(1., .0425, 1.04, -.04);\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * ndv)) * r.x + r.y;\n    vec2 ab = vec2(-1.04, 1.04) * a004 + r.zw;\n    return f0 * ab.x + ab.y;\n}\n\nfloat noise(vec3 p)\n{\n    vec3 i = floor(p);  \n    vec3 f = fract(p);\n    vec3 f3 = f * f * f;\n    vec3 u = 6. * f3 * f * f - 15. * f3 * f + 10. * f3;\n    vec2 o = vec2(1,0);\n    \n    return mix(\n        mix(\n            mix(dot(hash33(i + o.yyy), f - o.yyy), dot(hash33(i + o.xyy), f - o.xyy), u.x),\n            mix(dot(hash33(i + o.yxy), f - o.yxy), dot(hash33(i + o.xxy), f - o.xxy), u.x),\n            u.y\n        ),\n        mix(\n            mix(dot(hash33(i + o.yyx), f - o.yyx), dot(hash33(i + o.xyx), f - o.xyx), u.x),\n            mix(dot(hash33(i + o.yxx), f - o.yxx), dot(hash33(i + o.xxx), f - o.xxx), u.x),\n            u.y\n        ),\n        u.z);\n}\n\nfloat fbm(vec3 p)\n{\n    return (noise(p)\n        + noise(p * 2. + 1.) * .5\n        + noise(p * 4. + 2.) * .25\n        + noise(p * 8. + 4.) * .125)\n        / 1.875;\n}\n\nfloat pattern(vec3 p, float h)\n{\n    p -= vec3(0,0,3);\n    p = fract(p * .5 + .5) * 2. - 1.;\n    float t = iTime * .5;\n    p.xz *= rot((fract(h * 1111.) * 2. - 1.) * t);\n    p.xy *= rot((fract(h * 773.) * 2. - 1.) * t);\n    float n = fbm(p * (.5 + fract(h * 127.)) + h * 541.);\n    float q = fract(h * 41.) * .5 + .49;\n    return smoothstep(-1. + q, 1. - q, n) * (fract(h * 229.) * .5 + .5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\n    vec3 ro = vec3(0,iTime * .2,-7);\n    vec3 rd = normalize(vec3(uv, 2.));\n    float t = 7.;\n    float d = 0.;\n    vec3 p = vec3(0);\n    float i = 0.;\n    \n    for(; i < 1. && p.z < 4.; i += 1./128.)\n    {\n        p = ro + rd * t;\n        d = scene(p);\n        t += d * 1.1;\n        if(abs(d) < .001) break;\n    }\n    \n    vec3 ld = normalize(vec3(1,sin(iTime * .125) * .35 + .4,1));\n    ld.xz *= rot(iTime * .25);\n    vec3 col = vec3(0);\n    \n    if (p.z < 4.)\n    {\n        float h = index(p);\n        vec3 n = normal(p, d);\n        float pat = pattern(p, h);\n        vec3 abd = mix(color(h), color(h * 47.), pat);\n        float mtl = mix(fract(h * 113.), fract(h * 311.), pat);\n        float rgh = mix(fract(h * 487.), fract(h * 83.), pat);\n        vec3 spec = sky(reflect(rd, n), ld, max(rgh, .0001));\n        \n        vec3 diff = abd * sky(n, ld, 1.) * mtl;\n        vec3 f0 = max(abd * (1. - mtl), vec3(.04));\n        col = mix(diff, spec, DFGAppr(f0, dot(-rd, n), rgh));\n    }\n    else\n        col = sky(rd, ld, .01);\n        \n    col = col * (1. + col / 20.) / (1. + col);\n    col = pow(col, vec3(1./2.2));\n    col += hash32(fragCoord) / 255.;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tcfWj.jpg", "access": "shaders20k", "license": "cc-by-sa-4.0", "functions": [[621, 718, 739, 739, 849], [851, 851, 872, 872, 974], [976, 976, 995, 995, 1071], [1073, 1073, 1094, 1094, 1206], [1208, 1208, 1229, 1229, 1324], [1326, 1326, 1356, 1356, 1509], [1511, 1511, 1532, 1532, 1757], [1759, 1759, 1796, 1796, 2076], [2078, 2078, 2102, 2102, 2132], [2134, 2205, 2256, 2256, 2521], [2523, 2523, 2544, 2544, 3182], [3184, 3184, 3203, 3203, 3349], [3351, 3351, 3383, 3383, 3744], [3746, 3746, 3803, 3803, 5054]], "test": "valid"}
{"id": "3tcfWN", "name": "Infinite structures travel", "author": "TambakoJaguar", "description": "After a long time away, I came with a new idea!\nJust let yourself guided on a travel through infinite and surprising structures... Enjoy this fantastic (and psychedelic?) trip!\nIt was fun implementing cool things!\nUse the mouse to look all around you!", "tags": ["fast", "colorful", "modulo", "metal", "infinite", "beams", "repetitive", "rollercoaster", "progressive", "metallic", "structure", "plates", "screws"], "likes": 9, "viewed": 185, "published": "Public", "date": "1613323488", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\"Infinite mod structures\" by Emmanuel Keller aka Tambako - February 2021\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n\nToDo:\n* Distortion X/Y axes\n  * Camdir\n  * Tilt scene when turning\n    - tilt depends on spedfac (pow 2?)\n* Sometimes intersections missing for a longer time or colors different (every nth)\n  * Or sometimes only along path\n* Crazy lights visible\n* Correct bug screws\n* Ambient occlusion\n* speed variations\n* Fog at times\n  * Vary between blue gray and brown gray\n  * Color also depends on the crazy lights colors (use showCrazyLights)\n* Sometimes jump to the parallel lanes\n* Rusty parts\n* 180° tilt at a few times (smoothstep iTtime + mod)\n* Tunnel at times\n* More variations tiles\n* Speed indicator at bottom of screen (gradient)\n* Reflections (use different coefficients depending on object)\n- Improve shadows?\n- Improve abocc\n* Add comments\n- Try https://www.shadertoy.com/view/ws3Bzf\n\n*/\n\n#define pi 3.14159265359\n\n// Switches, you can play with them!\n#define specular              // Enables specular highlights of light sources on the surfaces\n//#define shadow              // Enables shadows. Doesn't really look good :P\n//#define ambocc              // Enables ambient occlusion. Doesn't really look good :P\n#define plates                // Enables random colored plates\n#define obliques              // Enables random oblique beams\n#define intersections         // Enables the cubes and spheres at the beam's intersections\n#define textures              // Enables the textures on the beams and plates\n#define crazylights           // Enables two lights \"dancing\" in front of the camera and changing its color\n#define showcrazylights       // Enables the display of the crazy lights as \"orbs\"\n#define bumps                 // Enables the screws on the beams and other details as bumps (only for normal)\n#define distortion            // Enables the distortion of the beams in the x and y axes, which is visible at times\n#define fog                   // Enables the fog, visible at times\n#define fognoise              // Enables noise in the fog, making it look like clouds\n#define rust                  // Enables the rust on the beams, visible at times\n#define tunnel                // Enables tunnels, visible at times\n#define varspeed              // Enables variable speed of the camera\n#define tilt                  // Enables tilting of the camera in curves, which is stonger when travelling faster\n#define tilt180               // Enables the tilting of the view to 180° (upside down) at times\n#define sidejumps             // Enables the jumping to parallel \"lanes\" on every 4 direction, at times\n#define shaking               // Enables the shaking of the camera occuring at high speeds\n#define speedindic            // Enables the speed indicator on the bottom of the screen\n//#define keys                // Enables the key function: modification of the zoom factor and retrn in time\n#define spy                   // Enables the appearance of the spy (UFO-like) at times\n//#define spyglitches         // Enables the glitches on the appearance of the spy\n//#define reflections         // Enables the reflections of the beams and spy\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\n//#define antialias\nconst float aawidth = 0.65;\nconst int aasamples = 2;\n\n// Ambient light\nconst vec3 ambientColor = vec3(1.);\nconst float ambientint = 0.0;\n\n// Specular options\nconst float specint = 0.55;\nconst float specshin = 55.;\n\n// Shadow options\nconst float shi = 0.5;\nconst float aoint = 0.5;\n\n// Tracing options\nconst float normdelta = 0.0012;\nconst float maxdist = 100.;\n\n// Color options\nconst float gamma = 1.4;\nconst vec3 structure_color1 = vec3(0.8, 0.8, 0.88);\nconst vec3 structure_color2 = vec3(0.78, 0.61, 0.45);\nconst vec3 tunnel_color1 = vec3(0.38, 0.57, 0.49);\nconst vec3 tunnel_color2 = vec3(0.28, 0.51, 0.38);\nconst vec3 tunnel_colord = vec3(0.39, 0.25, 0.21);\n#ifdef reflections\nconst vec3 spy_color = vec3(0.88, 0.77, 0.72);\n#else\nconst vec3 spy_color = vec3(0.64, 0.68, 0.75);\n#endif\n\n// Geometry options\nconst float ssize = 2.8;\nconst float structure_s1 = 0.12;\nconst float ws = 0.83;\nconst float ws2 = 0.05;\nconst float intscale = 0.85;\nconst float bumpheight = 0.004;\nconst float plth = 0.1;\nconst float spysize = 2.8;\n\n// Fog\nconst vec3 fogColor1 = vec3(0.54, 0.63, 0.71);\nconst vec3 fogColor2 = vec3(0.71, 0.59, 0.51);\nvec3 fogColor;\nconst float fogdens0 = 0.18;\nfloat fogdensf;\nfloat fogd;\n\n// Campera options\nvec3 campos = vec3(0., 0., 0.);\nvec3 camtarget = vec3(0., 0., 0.);\nvec3 camdir = vec3(0., 0., 0.);\nfloat fov = 2.2;\nfloat camspeed = 13.;\nfloat camposdist = 1.8;\nfloat camposint = 0.3;\nfloat camtiltf = -0.58;\nfloat camtilt;\nconst float shakeint = 0.0012;\nconst float axm = 2.*pi;\nconst float aym = 0.8;\nfloat camtilt2;\n\nfloat spindh = 0.027;\n\nstruct Lamp\n{\n  \tvec3 position;\n  \tvec3 color;\n  \tfloat intensity;\n  \tfloat attenuation;\n};\n\nstruct RenderData\n{\n  \tvec3 col;\n  \tvec3 pos;\n  \tvec3 norm;\n    float dist;\n};\n   \n#ifdef crazylights\nLamp lamps[3];\n#else\nLamp lamps[1];\n#endif\n\n// Misc variables definition\nvec3 colors[9];\nint aai;\nint aaj;\nfloat time2;\nfloat speedfact;\nfloat mainLampInt;\nbool getSpy = true;\nbool isSpy;\nfloat spyBump;\nfloat refFactor;\nfloat tunnelse;\n\n#ifdef keys\n// Detects if keys are pressed\nconst float KEY_Z = 90.5/256.0;\nconst float KEY_U = 85.5/256.0;\nconst float KEY_H = 72.5/256.0;\nconst float KEY_J = 74.5/256.0;\nconst float KEY_N = 78.5/256.0;\nconst float KEY_M = 77.5/256.0;\nconst float KEY_1 = 49.5/256.0;\nconst float KEY_2 = 50.5/256.0;\nconst float KEY_3 = 51.5/256.0;\nconst float KEY_4 = 52.5/256.0;\nconst float KEY_5 = 53.5/256.0;\nconst float KEY_6 = 54.5/256.0;\nconst float KEY_7 = 55.5/256.0;\nconst float KEY_8 = 56.5/256.0;\nconst float KEY_9 = 57.5/256.0;\nbool isKeyPressed(float key)\n{\n\treturn texture(iChannel3, vec2(key, 0.25) ).x > .0;\n}\n#endif\n\n// Gets the virtual time, which enables a variable speed\nfloat getTime(float time)\n{\n    //time2 = camspeed*(iTime + 158.);\n    float time2 = camspeed*time;\n    \n    #ifdef keys\n    // When pressing numeric keys, you can go back a different distance\n    if (isKeyPressed(KEY_1)) time2-= 2.;\n    if (isKeyPressed(KEY_2)) time2-= 5.;\n    if (isKeyPressed(KEY_3)) time2-= 10.;\n    if (isKeyPressed(KEY_4)) time2-= 20.;\n    if (isKeyPressed(KEY_5)) time2-= 50.;\n    if (isKeyPressed(KEY_6)) time2-= 100.;\n    if (isKeyPressed(KEY_7)) time2-= 200.;\n    if (isKeyPressed(KEY_8)) time2-= 500.;\n    if (isKeyPressed(KEY_9)) time2-= 1000.;\n    #endif\n    \n    #ifdef varspeed\n    time2-= 58.*sin(time/9.) + 25.*cos(time/17.) - 12.*cos(time/5.7);\n    #endif\n    \n    return time2;\n}\n\n// Initializes different things\nvoid init()\n{    \n    // Lamps init\n    lamps[0] = Lamp(vec3(0.5, 0., 0.), vec3(1., 1., 1.), 1.6, 0.03);\n    #ifdef crazylights\n    lamps[1] = Lamp(vec3(0.5, 0., 0.), vec3(1., 0., 0.), 2.8, 0.25);\n    lamps[2] = Lamp(vec3(0.5, 0., 0.), vec3(1., 0., 0.), 2.8, 0.25);\n    #endif\n    \n    // Colors of the plates\n    colors[0] = vec3 (1., 0., 0.);\n    colors[1] = vec3 (1., 1., 0.);\n    colors[2] = vec3 (0., 1., 0.);\n    colors[3] = vec3 (0., 1., 1.);\n    colors[4] = vec3 (0., 0., 1.);\n    colors[5] = vec3 (1., 0., 1.);\n    colors[6] = vec3 (1., 0.65, 0.);\n    colors[7] = vec3 (0.33);\n    colors[8] = vec3 (0.67);\n    \n    // Gets the virtual time and calculates the travel speed\n    time2 = getTime(iTime);\n    speedfact = getTime(iTime+0.1) - getTime(iTime);\n    \n}\n\n// RGB to HSV color conversion\nvec3 hsv2rgb(vec3 c)\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\trgb = rgb*rgb*(3.0-2.0*rgb);\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n// HSV to RGB color conversion\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// 2D vector rotation\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) - vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) + vect.y*cos(angle);\n    return rv;\n}\n\n// 1D hash function\nfloat hash(vec3 p)\n{\n    //p  = 17.0*fract(p*0.3183099+.1);\n\t//return fract(p.x*p.y*p.z*(p.x+p.y+p.z));\n\n    p  = 442.0*fract(p*0.3183099+.131249);\n    return fract(dot(p.xyz, p.zxy));\n    \n\t/*p  = fract(p * .1031);\n    p += dot(p, p.zyx + 31.32);\n    return fract((p.x + p.y) * p.z);  */\n}\n\n#ifdef fognoise\nfloat noise(vec3 p)\n{\n\tvec3 ip=floor(p);\n    p-=ip; \n    vec3 s=vec3(7,157,113);\n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip.xyz,s);\n    p=p*p*(3.-2.*p); \n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z); \n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\n// From https://www.shadertoy.com/view/4sfGzS\nfloat noise2(vec3 pos)\n{\n    vec3 q = 8.0*pos;\n    float f  = 0.5000*noise(q) ; q = m*q*2.01;\n    f+= 0.2500*noise(q); q = m*q*2.02;\n    f+= 0.1250*noise(q); q = m*q*2.03;\n    f+= 0.0625*noise(q); q = m*q*2.01;\n    return f;\n}\n#endif\n\n// Distorts the whole structure with waves along the x and y axes for a cool effect!\nvec3 distort(vec3 pos)\n{\n    #ifdef distortion\n    float zfac = 0.85;\n    float time3 = mod(time2, 1900.);\n    float dint = 1.2*smoothstep(135., 370., time3)*smoothstep(790., 610., time3);\n    dint+= 2.2*smoothstep(1050., 1290., time3)*smoothstep(1780., 1650., time3);\n    if (dint>0.02)\n    {\n        pos.x+= 1.05*dint*(cos(zfac*pos.z*0.05) + 0.5*sin(zfac*pos.z*0.12) + 0.22*sin(zfac*pos.z*0.19) + 0.07*sin(zfac*pos.z*0.35));\n        pos.y+= 0.85*dint*(sin(zfac*pos.z*0.05) + 0.5*cos(zfac*pos.z*0.14) + 0.18*sin(zfac*pos.z*0.18) + 0.09*sin(zfac*pos.z*0.32));\n    }\n    #endif\n    return pos;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\nfloat sdTorus(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// Gets the bump (actually screws) which are only applied on the normal, not during the raymarching, for better speed\n#ifdef bumps\nfloat getNormalBump(vec3 pos)\n{\n    if (isSpy)\n        return 0.;\n\n    pos = distort(pos);\n\n    float bump = 0.;\n    vec3 pos2 = mod(pos, ssize);\n    \n    // Avoids to put screws on intersections!\n    #ifdef intersections\n    vec3 n = floor(pos/ssize);\n    float ns = n.x+n.y+n.z;    \n    float ints;\n    float intprob = 0.77*(0.5 + 0.5*sin(-2.3 + n.z/73.)) + 0.17*(0.5 + 0.5*sin(0.84 + n.z/23.)) + 0.06*(0.5 + 0.5*sin(n.z/11.5));\n    if ((intprob<0.85 || (intprob<0.92 && (n.x==-1. || n.x==0.) && (n.y==-1. || n.y==0.))) && hash(n*571.6518)>0.026)\n    {    \n        if (mod(ns, 2.)==1.)\n           ints = length(pos2-vec3(0.5*ssize))-structure_s1*2.*intscale;\n        else\n           ints = max(max(abs(pos2.x-0.5*ssize)-structure_s1*1.5*intscale, abs(pos2.y-0.5*ssize)-structure_s1*1.5*intscale), abs(pos2.z-0.5*ssize)-structure_s1*1.5*intscale);\n        if (ints<bumpheight)\n            return 0.;\n    }\n    #endif\n    \n    // Avoids to put screws on plates!\n    vec3 n2;\n    vec3 n3;\n    #ifdef plates\n    n2 = floor(pos/ssize-vec3(0., 0.5, 0.5));\n    n3 = floor(pos/ssize-vec3(0.5, 0., 0.5));\n    float platesprob = 0.3*(1.-cos(n2.z/75.)) + 0.07*(1.-cos(n2.z/16.));\n    float wx = max(abs(pos2.x-0.5*ssize)-structure_s1*plth, max(1.-abs(pos2.y-0.5*ssize)-ws, 1.-abs(pos2.z-0.5*ssize)-ws));\n    float wy = max(abs(pos2.y-0.5*ssize)-structure_s1*plth, max(1.-abs(pos2.x-0.5*ssize)-ws, 1.-abs(pos2.z-0.5*ssize)-ws));\n    if (hash(n2*752.56258)<platesprob && wx<bumpheight)\n       return 1.8*texture(iChannel1, 0.25*pos.yz).r;\n    if (hash(n3*842.84329)<platesprob && wy<bumpheight)\n       return 1.8*texture(iChannel1, 0.25*pos.xz).r;       \n    #endif\n\n    float tx = abs(pos2.x-0.5*ssize)-structure_s1*0.5;\n    float ty = abs(pos2.y-0.5*ssize)-structure_s1*0.5;\n    float tz = abs(pos2.z-0.5*ssize)-structure_s1*0.5;\n    \n    float bz = max(tx, ty);\n    float by = max(tx, tz);\n    float bx = max(ty, tz);\n    \n    vec3 posb = mod(100.*pos2/ssize, 1.);\n    n3 = 100.*pos2/ssize;\n    \n    float scs = 15.;\n    \n    // Screws on perpendicular beams\n    if (bz<=bumpheight)\n    {\n        bump = (int(n3.x)==51 || int(n3.x)==48)?(-sqrt(clamp(1. - scs*pow(posb.x - 0.5, 2.) - scs*pow(posb.z - 0.5, 2.), 0., 1.))):0.;\n        bump+= (int(n3.y)==51 || int(n3.y)==48)?(-sqrt(clamp(1. - scs*pow(posb.y - 0.5, 2.) - scs*pow(posb.z - 0.5, 2.), 0., 1.))):0.;\n    }\n    if (bx<=bumpheight)\n    {\n        bump = (int(n3.z)==51 || int(n3.z)==48)?(-sqrt(clamp(1. - scs*pow(posb.x - 0.5, 2.) - scs*pow(posb.z - 0.5, 2.), 0., 1.))):0.;\n        bump+= (int(n3.y)==51 || int(n3.y)==48)?(-sqrt(clamp(1. - scs*pow(posb.x - 0.5, 2.) - scs*pow(posb.y - 0.5, 2.), 0., 1.))):0.;\n    } \n    if (by<=bumpheight)\n    {\n        bump = (int(n3.x)==51 || int(n3.x)==48)?(-sqrt(clamp(1. - scs*pow(posb.x - 0.5, 2.) - scs*pow(posb.y - 0.5, 2.), 0., 1.))):0.;\n        bump+= (int(n3.z)==51 || int(n3.z)==48)?(-sqrt(clamp(1. - scs*pow(posb.z - 0.5, 2.) - scs*pow(posb.y - 0.5, 2.), 0., 1.))):0.;\n    }\n    \n    // Screws on oblique beams\n    #ifdef obliques\n    vec3 pos3 = mod(pos+ssize*(0., 0.5, 0.5), ssize);\n    vec3 pos4 = mod(pos+ssize*(0.5, 0., 0.5), ssize);\n    float tyz2 = abs(pos3.y+pos3.z-ssize)-structure_s1*0.5;\n    float tyz3 = abs(pos3.y-pos3.z)-structure_s1*0.5;     \n    float txz2 = abs(pos4.x+pos4.z-ssize)-structure_s1*0.5;\n    float txz3 = abs(pos4.x-pos4.z)-structure_s1*0.5;     \n    float bz2 = max(tx, tyz2);\n    float bz3 = max(tx, tyz3);\n    float by2 = max(ty, txz2);\n    float by3 = max(ty, txz3); \n    \n    if (by2<=bumpheight && by3>bumpheight)\n    {\n        bump = (int(n3.y)==51 || int(n3.y)==48)?(-sqrt(clamp(1. - scs*pow(posb.y - 0.5, 2.) - scs*pow(1.414*posb.z - 0.5, 2.), 0., 1.))):0.;\n        bump+= (int(n3.x+n3.z)==98 || int(n3.x+n3.z)==101)?(-sqrt(clamp(1. - scs*pow(posb.x - 0.25, 2.) - scs*pow(posb.z- 0.25, 2.), 0., 1.))):0.;\n    } \n    else if (by3<=bumpheight && by2>bumpheight)\n    {\n        bump = (int(n3.y)==51 || int(n3.y)==48)?(-sqrt(clamp(1. - scs*pow(posb.y - 0.5, 2.) - scs*pow(1.414*posb.z - 0.5, 2.), 0., 1.))):0.;\n        bump+= (int(-n3.x+n3.z)==1 || int(-n3.x+n3.z)==-1)?(-sqrt(clamp(1. - scs*pow(posb.x - 0.75, 2.) - scs*pow(posb.z - 0.35, 2.), 0., 1.))):0.;\n    }\n    else if (bz2<=bumpheight && bz3>bumpheight)\n    {\n        bump = (int(n3.x)==51 || int(n3.x)==48)?(-sqrt(clamp(1. - scs*pow(posb.x - 0.5, 2.) - scs*pow(1.414*posb.z - 0.5, 2.), 0., 1.))):0.;\n        bump+= (int(n3.y+n3.z)==98 || int(n3.y+n3.z)==101)?(-sqrt(clamp(1. - scs*pow(posb.y - 0.25, 2.) - scs*pow(posb.z- 0.25, 2.), 0., 1.))):0.;\n    } \n    else if (bz3<=bumpheight && bz2>bumpheight)\n    {\n        bump = (int(n3.x)==51 || int(n3.x)==48)?(-sqrt(clamp(1. - scs*pow(posb.x - 0.5, 2.) - scs*pow(1.414*posb.z - 0.5, 2.), 0., 1.))):0.;\n        bump+= (int(-n3.y+n3.z)==1 || int(-n3.y+n3.z)==-1)?(-sqrt(clamp(1. - scs*pow(posb.y - 0.75, 2.) - scs*pow(posb.z- 0.35, 2.), 0., 1.))):0.;\n    }     \n    #endif    \n        \n    return bump;\n}\n#endif\n\n// Maps the spy\n#ifdef spy\nvec3 spypos;\nfloat map_spy(vec3 pos)\n{\n    float zpos = -1000.*(smoothstep(85., 65., mod(iTime, 280.)) - smoothstep(120., 140., mod(iTime, 280.)));\n    //float zpos = -700.*(smoothstep(15., -5., mod(iTime, 280.)) - smoothstep(120., 140., mod(iTime, 280.)));\n    if (abs(zpos)>maxdist)\n        return maxdist;\n    \n    pos.z-= -time2 -7.8 - zpos;\n    pos.x+= 0.09*sin(time2*0.17 + 1.);\n    pos.y+= 0.13*sin(iTime*2.5);\n    pos.z+= 1.2*sin(time2*1.34/camspeed) + 0.52*sin(time2*0.58/camspeed);\n    pos.y*= 1.27;\n    \n    spypos = pos;\n    spypos.x+= 0.09*sin(time2*0.07 + 1.);\n    spypos.y+= 0.13*sin(iTime*2.5);\n    spypos.z+= 0.2*sin(iTime*1.23);  \n    \n    float spyo = length(pos) - 0.26*spysize;\n    \n    // Adds a torus\n    spyo = smin(spyo, sdTorus(pos, spysize*vec2(0.25, 0.05)), spysize*0.02);\n    \n    // Adds a structure\n    float a = atan(pos.x, pos.z) + iTime*0.5;\n    spyBump = .0037*smoothstep(0.88, 0.72, sin(a*24.))*smoothstep(0.15*spysize, 0.145*spysize, abs(pos.y));\n    spyBump-= 0.0037*smoothstep(0.165*spysize, 0.160*spysize, abs(pos.y));\n    spyo+= spyBump;\n    \n    return spyo;\n}\n#endif\n\n// Maps the tunnel on sometimes travels through\n#ifdef tunnel\nfloat map_tunnel(vec3 pos)\n{   \n    float tunnelo = length(pos.xy) - ssize*0.46;\n    float posz = -mod(-pos.z, 3300.);\n    \n    vec3 pos2 = pos;\n    pos2.z = mod(posz, ssize) - ssize*0.3;\n    \n    // Side openings\n    float tunnelf = -length(pos2.yz) + ssize*0.2;\n    tunnelo = max(tunnelo, tunnelf);    \n    \n    // Inside with waves\n    tunnelo = max(tunnelo, -length(pos.xy) + ssize*0.447 + 0.008*abs(sin(posz*15.))*smoothstep(-0.032, -0.042, tunnelf));\n    \n    // Where there is the tunnel, where not\n    // Already calculated in map()\n    //float tunnelse = smoothstep(-604., -602., posz) + smoothstep(-830., -832., posz) - 0.002;\n    //tunnelse*= smoothstep(-2053., -2051., posz) + smoothstep(-2260.5, -2262.5, posz) - 0.002;\n    //tunnelse*= smoothstep(-2932.2, -2930.2, posz) + smoothstep(-2979.7, -2981.7, posz) - 0.002;\n    tunnelo = max(tunnelo, tunnelse);\n    \n    return tunnelo;\n}\n#endif\n\n// Main mapping function\nfloat map(vec3 pos)\n{\n    pos = distort(pos);\n\n    #ifdef spy\n    float spyo;\n    if (getSpy)\n        spyo = map_spy(pos);\n    #endif\n    \n    // The perpendicular beams\n    vec3 pos2 = mod(pos, ssize);\n    \n    float tx = abs(pos2.x-0.5*ssize)-structure_s1*0.5;\n    float ty = abs(pos2.y-0.5*ssize)-structure_s1*0.5;\n    float tz = abs(pos2.z-0.5*ssize)-structure_s1*0.5;\n    \n    float bz = max(tx, ty);\n    float by = max(tx, tz);\n    float bx = max(ty, tz);\n    \n    float str = min(bx, min(by, bz));  \n    \n    // The intersections (alternatively spheres and cubes)\n    #ifdef intersections\n    vec3 n = floor(pos/ssize);\n    float intprob = 0.77*(0.5 + 0.5*sin(-2.3 + n.z/73.)) + 0.17*(0.5 + 0.5*sin(0.84 + n.z/23.)) + 0.06*(0.5 + 0.5*sin(n.z/11.5));\n    if ((intprob<0.85 || (intprob<0.92 && (n.x==-1. || n.x==0.) && (n.y==-1. || n.y==0.))) && hash(n*571.6518)>0.026)\n    {\n        float ns = n.x+n.y+n.z;\n        if (mod(ns, 2.)==1.)\n           str = min(str, length(pos2-vec3(0.5*ssize))-structure_s1*2.*intscale);\n        else\n           str = min(str, max(max(abs(pos2.x-0.5*ssize)-structure_s1*1.5*intscale, abs(pos2.y-0.5*ssize)-structure_s1*1.5*intscale), abs(pos2.z-0.5*ssize)-structure_s1*1.5*intscale));\n    }\n    #endif\n    \n    // The colored plates!\n    #ifdef plates\n    vec3 n2 = floor(pos/ssize-vec3(0., 0.5, 0.5));\n    vec3 n3 = floor(pos/ssize-vec3(0.5, 0., 0.5));\n    \n    // How often the plates should come, depends on the travel path\n    float platesprob = 0.3*(1.-cos(n2.z/75.)) + 0.07*(1.-cos(n2.z/16.));\n    \n    // Adds the plates\n    if (hash(n2*752.56258)<platesprob)\n    {\n        // Vertical\n        float wx = max(abs(pos2.x-0.5*ssize)-structure_s1*plth, max(1.-abs(pos2.y-0.5*ssize)-ws, 1.-abs(pos2.z-0.5*ssize)-ws));\n    \n        // Sometimes there are 4 square holes in the plate (vertical plates)\n        if (hash(n2*829.7685)<0.15)\n        {\n            float wxh = max(abs(pos2.x-0.5*ssize)-structure_s1*(plth+0.02), max(1.-abs(mod(2.*pos2.y+0.8, ssize))+0.65, 1.-abs(mod(2.*pos2.z+0.8, ssize))+0.65));\n            wx = max(wx, -wxh);\n        }\n        // Or only one bigger square hole...\n        else if (hash(n3*843.4276)<0.032)\n        {\n            float wxh2 = max(abs(pos2.x-0.5*ssize)-structure_s1*(plth+0.02), max(1.-abs(pos2.x-0.5*ssize)-ws*0.23, 1.-abs(pos2.z-0.5*ssize)-ws*0.23));\n            wx = max(wx, -wxh2);    \n        }      \n    \n        str = min(str, wx);\n    }\n    else\n    {\n    #endif\n    #ifdef obliques\n        // Adds oblique beams, but not when there are plates\n        vec3 pos3 = mod(pos+ssize*(0., 0.5, 0.5), ssize);\n        float bz2prob = 0.45*(1.-0.7*cos((n2.z+5.)/85.)-0.3*cos((n2.z-4.)/40.));\n        float bz3prob = 0.45*(1.-0.7*cos((n2.z+8.)/65.)-0.3*cos((n2.z+5.)/125.));\n        if (hash(n2*462.14823)<bz2prob)\n        {\n            float tyz2 = abs(pos3.y+pos3.z-ssize)-structure_s1*0.5;\n            float bz2 = max(tx, tyz2);\n            str = min(str, bz2);\n        }\n        if (hash(n2*576.17496)<bz3prob)\n        {\n            float tyz3 = abs(pos3.y-pos3.z)-structure_s1*0.5; \n            float bz3 = max(tx, tyz3);\n            str = min(str, bz3);\n         }\n    #endif\n    #ifdef plates\n    }\n    if (hash(n3*842.84329)<platesprob)\n    {\n        // Horizontal\n        float wy = max(abs(pos2.y-0.5*ssize)-structure_s1*plth, max(1.-abs(pos2.x-0.5*ssize)-ws, 1.-abs(pos2.z-0.5*ssize)-ws));    \n    \n        // Sometimes there are 4 square holes in the plate (horizontal plates)\n        if (hash(n3*134.7126)<0.15)\n        {\n            float wyh = max(abs(pos2.y-0.5*ssize)-structure_s1*(plth+0.02), max(1.-abs(mod(2.*pos2.x+0.8, ssize))+0.65, 1.-abs(mod(2.*pos2.z+0.8, ssize))+0.65));\n            wy = max(wy, -wyh);\n        }\n        // Or only one bigger square hole...\n        else if (hash(n3*843.4276)<0.028)\n        {\n            float wyh2 = max(abs(pos2.y-0.5*ssize)-structure_s1*(plth+0.02), max(1.-abs(pos2.x-0.5*ssize)-ws*0.23, 1.-abs(pos2.z-0.5*ssize)-ws*0.23));\n            wy = max(wy, -wyh2);    \n        }      \n        str = min(str, wy);\n    }\n    else\n    {\n    #endif\n    #ifdef obliques\n        // Adds oblique beams, but not when there are plates\n        vec3 pos4 = mod(pos+ssize*(0.5, 0., 0.5), ssize);\n        float by2prob = 0.45*(1.-0.7*cos((n3.z+12.)/80.)-0.3*cos((n3.z-7.)/65.));\n        float by3prob = 0.45*(1.-0.7*cos((n3.z+15.)/35.)-0.3*cos((n3.z-12.)/105.));        \n        if (hash(n3*127.6359)<by2prob)\n        {\n            float txz2 = abs(pos4.x+pos4.z-ssize)-structure_s1*0.5;\n            float by2 = max(ty, txz2);\n            str = min(str, by2);\n        }\n        if (hash(n3*319.5628)<by3prob)\n        {\n            float txz3 = abs(pos4.x-pos4.z)-structure_s1*0.5; \n            float by3 = max(ty, txz3);\n            str = min(str, by3);\n        }\n    #endif\n    #ifdef plates\n    }\n    \n    // Adds the facing plates with holes, but not in the tunnel\n    float posz = -mod(-pos.z, 3300.);\n    tunnelse = smoothstep(-605., -603., posz) + smoothstep(-830., -832., posz) - 0.002;\n    tunnelse*= smoothstep(-2053., -2051., posz) + smoothstep(-2260.5, -2262.5, posz) - 0.002;\n    tunnelse*= smoothstep(-2932.2, -2930.2, posz) + smoothstep(-2979.7, -2981.7, posz) - 0.002;    \n    \n    vec3 n4 = floor(pos/ssize-vec3(0.5, 0.5, 0.5));\n    if (hash(n4*184.567)<platesprob*0.1 && n4.x==-1. && n4.y==-1. && tunnelse>0.)\n    {\n        // Plates on the path facing the camera, with a hole in it\n        float wz = max(abs(pos2.z-0.5*ssize)-structure_s1*plth, max(1.-abs(pos2.x-0.5*ssize)-ws, 1.-abs(pos2.y-0.5*ssize)-ws));\n        wz = max(wz, -length(pos.xy) + ssize*0.34);    \n    \n        str = min(str, wz);    \n    }\n    #endif\n    \n    // Adds the spy\n    #ifdef spy\n    if (getSpy)\n        str = min(str, spyo);\n    #endif    \n    \n    // Adds the tunnel\n    #ifdef tunnel\n    if (tunnelse<0.4)\n    {\n        float tunnelo = map_tunnel(pos);\n        str = min(str, tunnelo);\n    }\n    #endif\n    \n    return str;\n}\n\n// Main tracing function\nfloat trace(vec3 cam, vec3 ray, float maxdist) \n{\n    float t = 0.1;\n    float objnr = 0.;\n    vec3 pos;\n    float dist;\n    \n  \tfor (int i = 0; i < 145; ++i)\n    {\n    \tpos = ray*t + cam;\n        dist = map(pos);\n        if (t>maxdist || abs(dist)<0.0002)\n            break;\n        t+= dist*0.86;\n  \t}\n  \treturn t;\n}\n\n// Simpler tracing function for crazy lights\n#ifdef showcrazylights\nfloat tracel(vec3 cam, vec3 ray, float maxdist) \n{\n    float t = 1.2;\n    float objnr = 0.;\n    vec3 pos;\n    float dist;\n    \n  \tfor (int i = 0; i < 25; ++i)\n    {\n    \tpos = ray*t + cam;\n        dist = map(pos);\n        if (t>maxdist || abs(dist)<0.0002)\n            break;\n        t+= dist*1.2;\n  \t}\n  \treturn t;\n}\n#endif\n\n// Gets the normal\nvec3 getNormal(vec3 pos, float e)\n{  \n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e2 = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        // Adds the bumps (screws)\n        #ifdef bumps\n        n += e2*(map(pos + e*e2)+bumpheight*getNormalBump(pos + e*e2));\n        #else\n        n += e2*(map(pos + e*e2));\n        #endif\n    }\n    return normalize(n);\n}\n\n// Calculates a soft shadow\n#ifdef shadow\nfloat calcSoftshadow(in vec3 ro, in vec3 rd)\n{\n    float res = 1.0;\n    float tmax = 12.0;  \n    \n    float t = 0.02;\n    for( int i=0; i<40; i++ )\n    {\n\t\tfloat h = map(ro + rd*t);\n        res = min( res, 24.0*h/t );\n        t += clamp( h, 0.0, 0.80 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n#endif\n\n// Combines the colors\nvec3 getColor(vec3 norm, vec3 pos, vec3 ray)\n{ \n    vec3 pos0 = pos;\n    pos = distort(pos);\n    refFactor = 0.;\n    \n    // Spy coplor\n    isSpy = false;\n    #ifdef spy\n    if (map_spy(pos)<0.002)\n    {\n        isSpy = true;\n        refFactor = 0.71;\n        return mix(spy_color, 1.4*spy_color*texture(iChannel0, 0.8*(pos.xy+spypos.xy)/spysize).rgb, 0.6)*smoothstep(-0.015, 0., spyBump)*mix(vec3(0.98, 0.72, 0.65), vec3(1.), smoothstep(0., 0.24*spysize, abs(pos.y+spypos.y)));\n    }\n    #endif    \n    \n    // Tunnel color\n    #ifdef tunnel\n    if (map_tunnel(pos)<0.001)\n    {\n        float tl = -length(pos.xy) + ssize*0.417;\n        vec3 tcol = mix(tunnel_color1, tunnel_color2, smoothstep(0., -0.008, tl));\n        \n        // Changes the color a bit over the path\n        vec3 tcolhsv = rgb2hsv(tcol);\n        tcolhsv.x = mod(tcolhsv.x - pos.z*.00012 - 0.08, 1.);\n        tcol = hsv2rgb(tcolhsv);\n        \n        // Adds dirt\n        float td1 = texture(iChannel1, 0.3*rotateVec(pos.xz, 1.)).r;\n        float td2 = texture(iChannel1, 0.6*rotateVec(pos.xz, 1.4)).g;\n        float td3 = texture(iChannel1, 1.3*rotateVec(pos.xz, 2.25)).b;\n        float td = 0.45*td1 + 0.35*td2 + 0.2*td3;\n        float dpos = smoothstep(-ssize*0.47, 0., pos.y + 0.07*cos(pos.z*0.8));\n        tcol = mix(tcol, tunnel_colord*smoothstep(dpos + 0.95, dpos + 0.47, td), 0.8*smoothstep(dpos, dpos + 0.62, td));\n        \n        return tcol;\n    }\n    #endif\n\n    vec3 pos2 = mod(pos, ssize);\n\n    vec3 n = floor(pos/ssize);\n    float ns = n.x+n.y+n.z;    \n    vec3 n2 = floor(pos/ssize-vec3(0., 0.5, 0.5));\n    vec3 n3 = floor(pos/ssize-vec3(0.5, 0., 0.5));\n    \n    float scolorprob = 0.7*(0.5+0.5*sin(0.35 + n.z/50.)) + 0.16*(0.5+0.5*sin(n.z/16.)) + 0.14*(0.5+0.5*sin(n.z/4.67));\n    \n    // Colorizes the intersections\n    #ifdef intersections\n    float intprob = 0.77*(0.5 + 0.5*sin(-2.3 + n.z/73.)) + 0.17*(0.5 + 0.5*sin(0.84 + n.z/23.)) + 0.06*(0.5 + 0.5*sin(n.z/11.5));\n    if ((intprob<0.85 || (intprob<0.92 && (n.x==-1. || n.x==0.) && (n.y==-1. || n.y==0.))) && hash(n*571.6518)>0.026)\n    {    \n        if (mod(ns, 2.)==1.)\n        {\n           if (length(pos2-vec3(0.5*ssize))-structure_s1*2.*intscale<0.0008)\n               return scolorprob<0.21?0.8*structure_color1:(hash(n*2.8436)>0.986?vec3(1., 0.03, 0.23):vec3(0.8, 0.65, 0.4));\n        }\n        else\n        {\n            if (max(max(abs(pos2.x-0.5*ssize)-structure_s1*1.5*intscale, abs(pos2.y-0.5*ssize)-structure_s1*1.5*intscale), abs(pos2.z-0.5*ssize)-structure_s1*1.5*intscale)<0.0008)\n                return vec3(0.5, 0.6, 0.7);\n        }\n    }\n    #endif\n    \n    // Colorizes the plates using one of the 6 predefined colors\n    #ifdef plates\n    // Vertical\n    float wx = max(abs(pos2.x-0.5*ssize)-structure_s1*plth, max(1.-abs(pos2.y-0.5*ssize)-ws, 1.-abs(pos2.z-0.5*ssize)-ws));\n    // Horizontal\n    float wy = max(abs(pos2.y-0.5*ssize)-structure_s1*plth, max(1.-abs(pos2.x-0.5*ssize)-ws, 1.-abs(pos2.z-0.5*ssize)-ws));\n    // Plates on the path facing the camera, with a hole in it\n    float wz = max(abs(pos2.z-0.5*ssize)-structure_s1*plth, max(1.-abs(pos2.x-0.5*ssize)-ws, 1.-abs(pos2.y-0.5*ssize)-ws));\n    float platesprob = 0.3*(1.-cos(n2.z/75.)) + 0.07*(1.-cos(n2.z/16.));\n    \n    // Vertical\n    if (wx<0.01 && hash(n2*752.56258)<platesprob)\n    {\n        vec3 col = colors[int(7.*hash(n2*54.251))];\n        float h = hash(n2*42.519);\n        if (h<0.04)\n            col = colors[7];\n        if (h>0.96)\n            col = colors[8];        \n        #ifdef textures\n        float mc = texture(iChannel1, 0.3*vec2(pos.y, pos.z)).r;\n        return col*(0.7+0.3*mc);\n        #else\n        return col;\n        #endif\n        \n    }\n    // Horizontal\n    else if (wy<0.01 && hash(n3*842.84329)<platesprob)\n    {\n        vec3 col = colors[int(7.*hash(n3*71.849))];\n        float h = hash(n3*39.758);\n        if (h<0.04)\n            col = colors[7];\n        if (h>0.96)\n            col = colors[8];            \n        #ifdef textures\n        float mc = texture(iChannel1, 0.3*vec2(pos.x, pos.z)).r;\n        return col*(0.7+0.3*mc);\n        #else\n        return col;\n        #endif        \n    }\n    // Plates on the path facing the camera, with a hole in it\n    else if (wz<0.01)\n    {\n        vec3 n4 = floor(pos/ssize-vec3(0.5, 0.5, 0.5));\n        if (hash(n4*184.567)<platesprob*0.1 && n4.x==-1. && n4.y==-1.)\n        {\n            vec3 col = colors[int(7.*hash(n4*71.849))];\n            #ifdef textures\n            float mc = texture(iChannel1, 0.3*vec2(pos.x, pos.y)).r;\n            return col*(0.7+0.3*mc);\n            #else\n            return col;\n            #endif             \n        }\n    }\n    else\n    {\n    #endif\n        // Sometimes the structure has a different color\n        vec3 scolor = scolorprob<0.21?structure_color2:structure_color1;\n        \n        // Makes the screws darker and browner\n        #ifdef bumps\n        float bmp = getNormalBump(pos0);\n        if (bmp<0.)\n            scolor = mix(vec3(0.5, 0.32, 0.23), scolor, 0.45);\n        #endif\n        \n        // So that the textures are correct on the different angles of the beams\n        #ifdef textures\n        vec2 tpos;\n        if (abs(norm.x)>0.9 && abs(norm.y)<0.1 && abs(norm.z)<0.1)\n            tpos = vec2(pos.y, pos.z + 1.2);\n        if (abs(norm.x)<0.1 && abs(norm.y)>0.9 && abs(norm.z)<0.1)\n            tpos = vec2(pos.x, pos.z);\n        if (abs(norm.x)<0.1 && abs(norm.y)<0.1 && abs(norm.z)>0.9)\n            tpos = vec2(pos.x+ 0.6, pos.y);\n        if (abs(norm.x)<0.1 && abs(norm.y)>0.45 && abs(norm.z)>0.45)\n            tpos = vec2(pos.x, 1.41*pos.y);\n        if (abs(norm.x)>0.45 && abs(norm.y)<0.1 && abs(norm.z)>0.45)\n            tpos = vec2(1.41*pos.z, pos.y);              \n        vec3 mc = texture(iChannel0, 0.2*tpos).rgb;\n        scolor = mix(scolor, mc, 0.34);\n        \n        refFactor = 0.18;\n        \n        // At some portions of the path, the beams are rusty!\n        #ifdef rust\n        float rustpos = (0.39 + smoothstep(40., 30., iTime) + clamp(0.48*sin(pos.z*0.054) + 0.09*sin(pos.z*0.0298) + 0.1*sin(pos.z*0.0527) + 0.635, 0., 0.6));\n        if (rustpos<0.9)\n        {\n            vec3 n4 = floor(pos/ssize-vec3(0.5 + structure_s1*0.6, 0.5 + structure_s1*0.6, 0.5 + structure_s1*0.6));\n            float rustsize = 0.4 + 1.7*hash(n4*174.1796);\n            float rustrot = 2.*pi*hash(n4*749.5723);\n            vec2 rustoffset = 94.74*vec2(hash(n4*857.236), hash(n4*457.128));\n            tpos = rotateVec(tpos, rustrot)+ rustoffset;\n            vec3 mcr = texture(iChannel0, rustsize*1.1*tpos).rgb;\n            vec3 mcr2 = texture(iChannel1, rustsize*2.1*tpos).rgb;\n            vec3 rustcolor = (0.8 + 0.2*smoothstep(rustpos + 0.02, rustpos + 0.04, 0.6*mcr.r + 0.4*mcr))*mix(vec3(0.43, 0.27, 0.12), vec3(0.84, 0.49, 0.12), 0.5*clamp(6.*mcr2.r - 2.5, 0., 1.) + 0.5*smoothstep(rustpos + 0.02, rustpos + 0.4*(1. - rustpos), mcr.r));\n            float rustFactor = smoothstep(rustpos, rustpos + 0.02, mcr.r);\n            scolor = mix(scolor, rustcolor, rustFactor);\n            refFactor*= 1. - rustFactor;\n        }\n        #endif\n        #endif\n        \n        return scolor;        \n    #ifdef plates\n    }\n    #endif\n}\n\n// Shading of the objects pro lamp\nvec3 lampShading(Lamp lamp, vec3 norm, vec3 pos, vec3 ocol, int lampnr)\n{   \n    float lampint = lamp.intensity;\n    vec3 lampcolor = lamp.color;\n    #ifdef crazylights\n    float lint = smoothstep(30., 180., time2);\n    if (lampnr==0)\n    {\n        // Changes the intensity of the main (camera) lamp with time\n        mainLampInt = 1. -lint + lint*clamp(0.25 + (1. + 1.15*sin(time2*0.018) + 0.215*sin(time2*0.104) + 0.033*sin(time2*0.248)), 0., 1.);\n        lampint*= mainLampInt;\n        lamps[0].intensity = lampint;\n    }\n    if (lampnr==1)\n    {\n        // Changes the intensity and color of the first crazy lamp with time\n        lampint*= lint*(1. + 0.33*sin(time2*0.035));\n        lampcolor = hsv2rgb(vec3(0.5+0.5*cos(time2*0.015), 1., 1.));\n        lamps[1].intensity = lampint;\n        lamps[1].color = lampcolor;\n    }\n    if (lampnr==2)\n    {\n        // Changes the intensity and color of the first crazy lamp with time\n        lampint*= lint*(1. + 0.33*sin(time2*0.043));\n        lampcolor = hsv2rgb(vec3(1.+0.5*cos(time2*0.015), 1., 1.));\n        lamps[2].intensity = lampint;\n        lamps[2].color = lampcolor;       \n    }\n    #else\n    mainLampInt = 1.;\n    #endif\n\n    vec3 lamppos;\n    if (lampnr==0)\n        // Sets the position of the main (camera) lamp\n        lamppos = campos - vec3(pos.x*0.15, pos.y*0.6 - 0.6, 0.8);\n    #ifdef crazylights\n    if (lampnr==1)\n    {\n        // The position variation of the first crazy lamp with time\n        float lpx = 5.5*sin(time2*0.15) + 1.5*sin(time2*0.65) + 0.71*sin(time2*1.05);\n        float lpy = 4.2*sin(time2*0.11) + 1.2*sin(time2*0.55) + 0.65*sin(time2*0.95);\n        float lpz = 5.8*sin(time2*0.18) + 1.9*sin(time2*0.45) + 0.92*sin(time2*1.35) + 8.5;\n        lamppos = campos - vec3(lpx, lpy, lpz);\n        lamps[1].position = lamppos;\n    }\n    if (lampnr==2)\n    {\n        // The position variation of the second crazy lamp with time\n        float lpx = 3.8*sin(time2*0.09 + 3.) + 1.3*sin(time2*0.48) + 0.48*sin(time2*1.12);\n        float lpy = 4.7*sin(time2*0.13 + 2.) + 1.6*sin(time2*0.59) + 0.71*sin(time2*1.03);\n        float lpz = 6.2*sin(time2*0.20 + 1.) + 1.8*sin(time2*0.38) + 0.88*sin(time2*1.28) + 8.5;\n        lamppos = campos - vec3(lpx, lpy, lpz);\n        lamps[2].position = lamppos;\n    }\n    #endif\n    vec3 pl = normalize(lamppos - pos);\n    float dlp = distance(lamppos, pos);\n    float dnp = (0.2+0.8*dot(norm, pl))/pow(1. + lamp.attenuation*dlp, 2.);\n      \n    // Diffuse shading\n    vec3 col = ocol*lampcolor*lampint*smoothstep(-0.1, 1., dnp); //clamp(dnp, 0., 1.);\n    \n    // Specular shading\n    #ifdef specular\n    if (dot(norm, lamppos - pos) > 0.0)\n        col+= lampcolor*lampint*specint*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - lamppos))), specshin)/pow(1. + lamp.attenuation*dlp, 2.);\n    #endif\n    \n    // Softshadow\n    #ifdef shadow\n    col*= shi*calcSoftshadow(pos, pl) + 1. - shi;\n    #endif\n    \n    return col;\n}\n\n// Shading of the objects over all lamps\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol)\n{\n    vec3 col = vec3(0.);\n    for (int l=0; l<lamps.length(); l++)\n        col+= lampShading(lamps[l], norm, pos, ocol, l);\n    \n    return col;\n}\n\n#ifdef showcrazylights\n// This functions shows the crazy lamps as a kind of orb (using specular like dot function)\nvec3 showCrazyLights(vec3 camPos, vec3 ray, vec3 lampPos, float lampInt, vec3 lampCol)\n{\n    float ld = distance(lampPos, camPos);\n    float lvint = (0.7 + 0.7/ld)*lampInt*pow(clamp(dot(normalize(lampPos - camPos), ray), 0., 1.), ld*3000.);\n    if (lvint>0.06)\n    {\n        // Doesn't show the lamps when they are hidden behind an object\n        float tx = tracel(camPos, ray, ld+0.1);\n        if (ld<tx)\n        {\n            return mix(lampCol, vec3(1.), 0.37)*lvint;\n        }\n        else\n            return vec3(0.);\n    }\n    else\n        return vec3(0.);    \n}\n#endif\n\n// Gets the color of the fog depending on the position and ray direction\nvec3 getFogColor(vec3 camPos, vec3 ray)\n{\n    // Varies over time between two defined fog colors\n    float fcfac = 0.5 + 0.32*sin(time2*0.015) + 0.13*sin(time2*0.037) + 0.05*sin(time2*0.066);\n    vec3 fogcol = mix(fogColor1, fogColor2, fcfac)*(0.15 + 0.85*fogdensf);\n    \n    // This changes the color of the fog accordingly to the crazy lights, for a... crazy effect!\n    #ifdef crazylights\n    float ld1 = distance(lamps[1].position, camPos);\n    float ld2 = distance(lamps[2].position, camPos);\n    float lvint1 = (1. - 0.8*mainLampInt)*(0.7 + 0.7/ld1*ld1)*lamps[1].intensity*pow(clamp(dot(normalize(lamps[1].position - camPos), ray), 0., 1.), 6.6/pow(fogdensf, 2.));    \n    float lvint2 = (1. - 0.8*mainLampInt)*(0.7 + 0.7/ld2*ld2)*lamps[2].intensity*pow(clamp(dot(normalize(lamps[2].position - camPos), ray), 0., 1.), 6.6/pow(fogdensf, 2.));\n    \n    fogcol+= 0.1*mix(lamps[1].color, vec3(1.), 0.37)*lvint1;\n    fogcol+= 0.1*mix(lamps[2].color, vec3(1.), 0.37)*lvint2;\n    #endif\n    \n    return fogcol;\n}\n\n// Ambient occlusion\n// From https://www.shadertoy.com/view/Xds3zN\n#ifdef ambocc\nfloat calcAO(in vec3 pos, in vec3 nor)\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for(int i=0; i<9; i++)\n    {\n        float hr = 0.012 + 0.045*float(i);\n        vec3 aopos =  nor*hr + pos;\n        float dd = map(aopos);\n        occ+= clamp(-(dd - hr)*sca, 0.007, 0.2);\n        sca*= 0.55;\n    }\n    occ = 2.*smoothstep(0.06, 0.5, occ);\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n#endif\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\n// Sets the position of the camera with the mouse and calculates its direction\nvoid setCamera()\n{\n    // Travel position\n    campos.z = -time2;\n    campos = distort(campos);\n    campos.xy*= -1.;\n    \n    // At high speeds, the camera is shaking!\n    #ifdef shaking\n    campos.y+= pow(speedfact, 3.)*shakeint*(sin(time2*2.87) + 0.85*sin(time2*4.23) + 0.65*sin(time2*7.02) + 0.35*sin(time2*11.12) + 0.1*sin(time2*15.62));\n    #endif\n\n    // Changes the camera direction accordingly to the mouse position, so that you can look around!\n   \tvec2 iMouse2;\n   \tif (iMouse.x==0. && iMouse.y==0.)\n      \tiMouse2 = iResolution.xy*vec2(0.5, 0.5);\n   \telse\n      \tiMouse2 = iMouse.xy; \n   \n    float camAngleX = -2.*pi*(iMouse2.x/iResolution.x - 0.5);\n    float camAngleY = pi*(iMouse2.y/iResolution.y - 0.5);\n    if (abs(camAngleX)>pi*0.5)\n       camdir = vec3(-tan(camAngleX), tan(camAngleY), 1.);\n    else\n       camdir = vec3(tan(camAngleX), tan(camAngleY), -1.);\n       \n    // At some times, the camera suddenly tilts to 180°!\n    #ifdef tilt180\n    float t2cs = 0.4;\n    float time3 = mod(iTime, 212.);       \n    camtilt2 = smoothstep(82., 82. + t2cs, time3);\n    camtilt2-= smoothstep(137., 137. + t2cs, time3);\n    camtilt2+= smoothstep(193., 193. + t2cs, time3);\n    camtilt2-= smoothstep(211., 211. + t2cs, time3);\n    #else\n    camtilt2 = 0.;\n    #endif\n    camdir.xy*= 1. - 2.*camtilt2;\n       \n    // Calculates the horizontal bending of the distorded curve and then tilts the camera accordingly, but more at higher speeds\n    vec3 campos2 = vec3(0., 0., -time2 - camposdist);\n    campos2 = distort(campos2);\n    campos2.xy*= -1.;\n    #ifdef tilt\n    camdir+= camposint*vec3(campos2.x - campos.x, campos2.y - campos.y, 0.);\n    camtilt = campos2.x - campos.x;\n    camtilt*= 0.07 + 0.41*pow(speedfact, 2.);\n    #else\n    camtilt = 0.;\n    #endif\n    \n    // Sometimes jump to the parallel lanes\n    #ifdef sidejumps\n    float smxv = 0.81*sin(time2*0.0038) + 0.13*sin(time2*0.0138) + 0.06*sin(time2*0.0267);\n    campos.x+= ssize*smoothstep(0.79, 0.813, smxv);\n    campos.x-= ssize*smoothstep(-0.87, -0.893, smxv);\n    float smyv = 0.82*sin((time2 - 695.)*0.0044 + 0.2) + 0.15*sin((time2 - 695.)*0.0127) + 0.03*sin((time2 - 695.)*0.0312);\n    smyv*= smoothstep(25., 30., iTime);\n    campos.y+= ssize*smoothstep(0.77, 0.793, smyv);\n    campos.y-= ssize*smoothstep(-0.70, -0.723, smyv);\n    #endif\n    \n    #ifdef keys\n    // Pressing some keys change the field of view\n    if (isKeyPressed(KEY_Z)) fov*= 1.4;\n    if (isKeyPressed(KEY_U)) fov/= 1.4;\n    if (isKeyPressed(KEY_H)) fov*= 2.;\n    if (isKeyPressed(KEY_J)) fov/= 2.;\n    if (isKeyPressed(KEY_N)) fov*= 4.;\n    if (isKeyPressed(KEY_M)) fov/= 4.;\n    #endif\n}\n\n// Tracing and rendering a ray\nRenderData trace0(vec3 tpos, vec3 ray, float maxdist)\n{\n    float tx = trace(tpos, ray, maxdist);\n    vec3 col;\n    vec3 pos = tpos + tx*ray;\n    vec3 norm;\n    \n    norm = getNormal(pos, normdelta);\n    col = getColor(norm, pos, ray);\n\n    // Shading\n    col = col*ambientColor*ambientint + lampsShading(norm, pos, col);\n\n    // Ambient occlusion\n    #ifdef ambocc\n    col*= 1. - aoint + aoint*vec3(calcAO(pos, norm));\n    #endif\n\n    // Fog\n    fogd = 1.;\n    #ifdef fog\n    //fogdensf = 1.;\n    fogdensf = clamp(-0.15 + 1.03*sin(campos.z/218.) + 0.27*sin(campos.z/66.) + 0.11*sin(campos.z/18.) , 0., 1.);\n    if (fogdensf>0.)\n    {\n        #ifdef fognoise\n        vec3 fogpos = 0.38*ray.xyz;\n        fogpos.z+= 0.012*campos.z;\n        float fni = (0.8 + 0.15*fogdensf)*(0.5 + 0.3*sin(campos.z/27.5) + 0.15*sin(campos.z/11.2));\n        fogdensf*= ((1. - fni) + fni*noise2(fogpos));\n        #endif\n        float fogdens = fogdensf*fogdens0;\n        fogColor = getFogColor(tpos, ray);\n        fogd = clamp(exp(-pow(fogdens*tx, 2.)), 0., 1.);\n    }\n    col = mix (fogColor*(0.28 + 0.72*mainLampInt), col, fogd);\n    #endif  \n\n    return RenderData(col, pos, norm, tx);\n}\n\n// Main render function\nvec4 render(vec2 fragCoord)\n{   \n  \tvec2 uv0 = fragCoord.xy / iResolution.xy; \n  \tvec2 uv = uv0*2.0 - 1.0;\n  \tuv.x*= iResolution.x / iResolution.y;\n    \n    // Tilts the uv vector\n    #ifdef tilt180\n    camtilt*= 1. - 2.*camtilt2;\n    uv = rotateVec(uv, -camtilt*camtiltf + pi*camtilt2);\n    #endif\n\n    // Main tracing\n  \tvec3 ray = GetCameraRayDir(uv, camdir, fov);\n  \tRenderData traceinf = trace0(campos, ray, maxdist);\n  \tvec3 col = traceinf.col;\n    \n    float fogd1 = fogd;\n    \n    // Reflections\n    #ifdef reflections\n    bool isSpy0 = isSpy;\n    if (refFactor>0.)\n    {\n        float rf2;\n        rf2 = refFactor*fogd;\n        vec3 refray = reflect(ray, traceinf.norm);\n        traceinf = trace0(traceinf.pos, refray, maxdist*0.5);\n        col = mix(col, traceinf.col, rf2);    \n    }\n    isSpy = isSpy0;\n    #endif    \n    \n    #ifdef spyglitches\n    if (isSpy)\n    {\n        getSpy = false;\n        RenderData traceinf2 = trace0(campos, ray, maxdist);\n        float glitchint = 0.7*smoothstep(0.73, 1.02, sin(iTime*1.6) + 0.5*sin(iTime*2.9) + 0.3*sin(iTime*5.8));\n        col*= 1. + 0.6*glitchint*sin(310.*uv.y - 5.*iTime);\n        col+= 0.55*glitchint*vec3(hash(vec3(uv.y + 0.04*uv.x)*542.15), hash(vec3(uv.y + 0.05*uv.x)*742.56), hash(vec3(uv.y + 0.06*uv.x)*246.35))*(1. + 0.5*sin(55.*uv.y + 5.*uv.x - 32.*iTime))*(1. + 0.5*sin(315.*uv.y + 17.*iTime));\n        col = mix(col, traceinf2.col, 0.5*glitchint*(1. + sin(80.*uv.y + 15.*iTime)));\n    }\n    #endif\n    \n    // Shows the crazy lights\n    #ifdef crazylights\n    #ifdef showcrazylights\n    col+= fogd1*showCrazyLights(campos, ray, lamps[1].position, lamps[1].intensity, lamps[1].color);\n    col+= fogd1*showCrazyLights(campos, ray, lamps[2].position, lamps[2].intensity, lamps[2].color);\n    #endif\n    #endif\n    \n    // Displays a speed indicator at the bottom of the screen\n    #ifdef speedindic\n    if  (uv0.y<spindh)\n    {\n        float spind = smoothstep(speedfact*0.3 + 0.03, speedfact*0.3 - 0.03, uv0.x);\n        vec3 spindcol = vec3(smoothstep(0.0, 0.33, uv0.x), smoothstep(0.75, 0.33, uv0.x), 0.45*pow(smoothstep(0., spindh*0.5, uv0.y)*smoothstep(spindh, spindh*0.5, uv0.y), 10.));\n        spindcol*= 0.75 + 0.25*smoothstep(0., spindh*0.5, uv0.y)*smoothstep(spindh, spindh*0.5, uv0.y);\n        // (0.75 + 0.25*smoothstep(0., spindh*0.25, uv0.y)*smoothstep(spindh, spindh*0.75, uv0.y))*        \n        col = mix(col, spindcol, spind*0.75) + 0.12*spindcol*spind;\n    }\n    #endif\n    \n    //col = vec3(hash(574.56*vec3(uv.x, uv.y, 1.)));\n    \n  \treturn vec4(pow(col, vec3(gamma)), 1.0);\n}\n\n// Main image function, with antialiasing\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    init();\n    setCamera();\n    \n    // Antialiasing\n    #ifdef antialias\n    vec4 vs = vec4(0.);\n    for (aaj=0;aaj<aasamples ;aaj++)\n    {\n       float oy = float(aaj)*aawidth/max(float(aasamples-1), 1.);\n       for (aai=0;aai<aasamples ;aai++)\n       {\n          float ox = float(aai)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render(fragCoord + vec2(ox, oy));\n       }\n    }\n    fragColor = vs/vec4(aasamples*aasamples);\n    #else\n    fragColor = vec4(render(fragCoord));\n    #endif   \n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}, {"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tcfWN.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[5975, 6032, 6059, 6098, 6747], [6749, 6781, 6794, 6816, 7549], [7551, 7582, 7604, 7604, 7760], [7762, 7793, 7815, 7815, 8146], [8148, 8170, 8210, 8210, 8340], [8342, 8362, 8382, 8465, 8652], [9354, 9439, 9463, 9463, 10033], [10035, 10035, 10076, 10076, 10148], [10150, 10150, 10181, 10181, 10246]], "test": "error"}
{"id": "3tdBDj", "name": "[RGR] Ray marching 2D (v3)", "author": "deeplo", "description": "ray marching", "tags": ["raymarching"], "likes": 4, "viewed": 121, "published": "Public", "date": "1613564590", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//-------------------------------------\n// DEFINITIONS\n//-------------------------------------\n#define S smoothstep\n\n#define EPSILON 0.000001\n\n#define BG_COLOR      vec3(0.01,0.01,0.01)\n\n#define MAX_DISTANCE  100.0\n#define MAX_RM_STEPS  256\n#define MIN_DISTANCE  0.00001\n\n#define SPHERE_CENTER vec2(0.3,0.35)\n#define SPHERE_RADIUS 0.2\n\n#define BOX_CENTER    vec2(-0.55,-0.0)\n#define BOX_SIZE      vec2(0.6,0.2)\n#define BOX_ANGLE     (3.14159/6.0)\n\n#define CAPS_CENTER   vec2(1.1,0.0)\n#define CAPS_RADIUS   0.12\n#define CAPS_IN_H     0.4\n#define CAPS_ANGLE    (0.2*3.14159)\n\n#define TRI_P0 vec2(0.1,-0.2)\n#define TRI_P1 (TRI_P0+vec2(0.4,-0.2))\n#define TRI_P2 (TRI_P1+vec2(-0.45,-0.1))\n\n#define LIGHT_POWER 2.0\n#define LIGHT_RADIUS 0.05\n\n\n\n//-------------------------------------\n// SHAPE TYPES\n//-------------------------------------\nstruct Sphere {\n    vec2 c;\n    float r;\n};\nstruct Box {\n    vec2 c;\n    vec2 s;\n    float a;\n};\nstruct Capsule {\n    vec2  c;\n    float r;\n    float h;\n    float a;\n};\nstruct Triangle {\n    vec2 p0;\n    vec2 p1;\n    vec2 p2;\n};\n\n\n\n//-------------------------------------\n// SHAPE CONSTRUCTORS\n//-------------------------------------\nSphere NewSphere(vec2 pos, float rad) {\n    Sphere s;\n    s.c = pos;\n    s.r = rad;\n    return s;\n}\nBox NewBox(vec2 pos, vec2 size, float angle) {\n    Box bx;\n    bx.c = pos;\n    bx.s = size;\n    bx.a = angle;\n    return bx;\n}\nCapsule NewCapsule(vec2 pos, float radius, float innerH, float angle) {\n    Capsule cp;\n    cp.c = pos;\n    cp.r = radius;\n    cp.h = innerH;\n    cp.a = angle;\n    return cp;\n}\nTriangle NewTriangle(vec2 p0, vec2 p1, vec2 p2) {\n    Triangle t;\n    t.p0 = p0;\n    t.p1 = p1;\n    t.p2 = p2;\n    return t;\n}\n\n\n\n\n//-------------------------------------\n// MATH FUNCTIONS\n//-------------------------------------\nmat2 Rot(float a){\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\n\n\n//-------------------------------------\n// DISTANCE FUNCTIONS\n//-------------------------------------\nfloat GetDistSphere(vec2 position, Sphere sph){\n    // get parameters\n    vec2 center  = sph.c;\n    float radius = sph.r;\n    // Init distance\n    float d = MAX_DISTANCE;\n    // Set origin on the sphere center\n    position -= center;\n    // compute length\n    d = length(position) - radius;\n//    d = max(0.0, d);\n    // Return distance\n    return d;\n}\nfloat GetDistBox(vec2 position, Box box){\n    // get parameters\n    vec2  center = box.c;\n    vec2  size   = box.s;\n    float angle  = box.a;\n    // Init distance\n    float d = MAX_DISTANCE;\n    // Set origin on the box center\n    position -= center;\n    // Change origin according to box angle\n    position *= Rot(angle);\n    // compute lengths\n    vec2  dir = abs(position)-size*0.5;\n    float dOut = length(max(dir,vec2(0))); \n    float inner = S(-1.9, -2.0, sign(dir.x)+sign(dir.y) );\n    float dIn = inner*min(abs(dir.x),abs(dir.y));    \n    d = dOut-dIn;\n    // Return distance\n    return d;\n}\nfloat GetDistCapsule(vec2 position, Capsule caps){\n    // get parameters\n    vec2  center = caps.c;\n    float radius = caps.r;\n    float innerH = caps.h;\n    float angle  = caps.a;\n    // Init distance\n    float d = MAX_DISTANCE;\n    // Set origin on the capsule center\n    position -= center;\n    // Change origin according to capsue angle\n    position *= Rot(angle);\n    // compute length\n    vec2  A  = vec2(0.0, innerH*0.5);\n    vec2  B  = vec2(0.0,-innerH*0.5);    \n    vec2  AB = B-A;\n    vec2  AP = position - A;\n    float t  = clamp( dot(AB,AP)/dot(AB,AB), 0.0, 1.0 );\n    vec2  C  = A + t*AB;\n    d = length(position-C)-radius;\n    // Return distance\n    return d;\n}\nfloat GetDistTriangle(vec2 p, Triangle tri )\n{\n    vec2 p0 = tri.p0;\n    vec2 p1 = tri.p1;\n    vec2 p2 = tri.p2;\n    \n    // function retrieved from : https://www.shadertoy.com/view/XsXSz4\n    // Need to take knowledge from it ;)\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = e0.x*e2.y - e0.y*e2.x;\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\tfloat dist = -sqrt(d.x)*sign(d.y);\n//    dist = max(0.0, dist);\n    return dist;\n}\n\n\n\n\n//-------------------------------------\n// RAY MARCHING ALGORITHM\n//-------------------------------------\nfloat RayMarching(vec2 rayOrigin, vec2 rayDirection){\n    // Init algo\n    float dMin      = MAX_DISTANCE;\n    float marchDist = 0.0;\n    vec2  p         = rayOrigin;\n    vec2  normal    = vec2(0,0);\n    // Ray Marching Loop\n    for(int i=0; i<MAX_RM_STEPS && dMin>=MIN_DISTANCE && marchDist<=MAX_DISTANCE;i++){\n        // Get minimum distance to sphere\n        float dMin1 = GetDistSphere(p, NewSphere(SPHERE_CENTER, SPHERE_RADIUS) );\n        // Get minimum distance to box\n        float dMin2 = GetDistBox(p, NewBox(BOX_CENTER, BOX_SIZE, BOX_ANGLE) );\n        // Get minimum distance to capsule\n        float dMin3 = GetDistCapsule(p, NewCapsule(CAPS_CENTER, CAPS_RADIUS, CAPS_IN_H,CAPS_ANGLE) );\n        // Get minimum distance to triangle\n        float dMin4 = GetDistTriangle(p, NewTriangle(TRI_P0, TRI_P1, TRI_P2) );\n        // get minimum from all the minimum\n        dMin = dMin1;\n        dMin = min(dMin,dMin2);\n        dMin = min(dMin,dMin3);\n        dMin = min(dMin,dMin4);\n        // Increase total distance\n        marchDist += dMin;\n        // Set the next marching point (origin + direction * distance)\n        p = rayOrigin + normalize(rayDirection) * marchDist;                \n    }\n    // shadow modifier\n    float shadow = S(-0.0001,0.0001,length(p-rayOrigin)-length(rayDirection));    \n    return shadow;\n}\n\n\n\n//-------------------------------------\n// UTIL FUNCTIONS\n//-------------------------------------\nfloat shapeAlpha(float dist){\n    float cS = 0.0;\n    cS += S(0.1, 0.0, abs(dist));\n    cS *= S(0.0, -0.0000001, dist);\n    return cS;\n}\nvec2 moveLight(float t){  \n\n    float x = cos(t);\n    float y = sin(t);\n    \n    x += cos(4.0*t);\n    y += sin(4.0*t);\n    \n    x*= 1.5;\n    return vec2(x,y)*0.5;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Get coords normallized according to Y resolution. Screen displays uv between -1/+1  \n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    // Background color\n    vec3 bg = BG_COLOR*uv.x;\n    vec4 col = vec4(bg,1.0);\n\n    // Light source (mouse position)\n    vec2 lightPos = iMouse.xy;\n    bool autoAnim = (lightPos == vec2(0));\n    lightPos = (2.0*lightPos-iResolution.xy)/iResolution.y;\n    \n    // Auto anim\n    if(autoAnim){\n        lightPos = moveLight(iTime*0.3);\n    }\n    \n    // Set ray origin + direction\n    vec2 rayOrigin = lightPos;\n    vec2 targetDirection = uv-rayOrigin;\n\n    // Ray marching algorithm\n    float shadow = RayMarching(rayOrigin, targetDirection);\n\n    // Prepare light source (disc)\n    float lightDist  = length(uv-lightPos);\n    float lightAlpha = S(LIGHT_RADIUS ,0.0, lightDist); \n    float fading = length(targetDirection);\n    fading = S(LIGHT_POWER,0.0,fading);\n    \n    // Light field (using shadow) + light source\n    vec3 lightColor = vec3(abs(sin(iTime*0.1287))*0.5+0.5,\n                           abs(sin(iTime*0.5687))*0.5+0.5,\n                           abs(sin(iTime*0.3154))*0.5+0.5);\n    col.rgb += lightColor*fading*shadow;\n    col.rgb += lightColor * vec3(lightAlpha);\n\n\n    // Draw elements\n    float d0 = 0.0;\n    float cS = 0.0;\n    d0  = GetDistSphere(uv, NewSphere(SPHERE_CENTER, SPHERE_RADIUS) );\n    cS += shapeAlpha(d0);\n    d0  = GetDistBox(uv, NewBox(BOX_CENTER, BOX_SIZE, BOX_ANGLE) );\n    cS += shapeAlpha(d0);\n    d0  = GetDistCapsule(uv, NewCapsule(CAPS_CENTER, CAPS_RADIUS, CAPS_IN_H,CAPS_ANGLE) );\n    cS += shapeAlpha(d0);\n    d0  = GetDistTriangle(uv, NewTriangle(TRI_P0, TRI_P1, TRI_P2) );\n    cS += shapeAlpha(d0);\n    \n    // apply shadow on shapes\n    col.rgb += vec3(0.5*cS,0.5*cS,cS) * fading*fading;\n\n    // Final Output\n    fragColor = col;    \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tdBDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1065, 1167, 1206, 1206, 1266], [1267, 1267, 1313, 1313, 1393], [1394, 1394, 1465, 1465, 1570], [1571, 1571, 1620, 1620, 1697], [1702, 1800, 1818, 1818, 1894], [1898, 2000, 2047, 2069, 2352], [2353, 2353, 2394, 2416, 2952], [2953, 2953, 3003, 3025, 3628], [3629, 3629, 3675, 3675, 4511], [4516, 4622, 4675, 4692, 5949], [5953, 6051, 6080, 6080, 6187], [6188, 6188, 6212, 6212, 6352], [6355, 6355, 6412, 6505, 8253]], "test": "valid"}
{"id": "3tdBRs", "name": "Distance to Box", "author": "oneshade", "description": "Finally derived the distance to a box myself ;)", "tags": ["2d", "sdf", "box", "oneliner"], "likes": 2, "viewed": 104, "published": "Public", "date": "1613276585", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdBox(in vec2 p, in vec2 s) {\n    return length(p - clamp(p, -s, s)) + min(0.0, max(abs(p.x) - s.x, abs(p.y) - s.y));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n    float time = iTime * 2.0;\n\n    float w = 0.5 + 0.25 * sin(iTime);\n    float h = 0.25 + 0.2 * cos(iTime);\n    float d = sdBox(uv, vec2(w, h));\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(d) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 1.0 - exp(-4.0 * abs(d));\n\tcolor *= 0.8 + 0.2 * cos(140.0 * d);\n\tcolor = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(d)));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tdBRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 125], [127, 127, 182, 182, 695]], "test": "valid"}
{"id": "3tdBWN", "name": "Fractal 16_gaz", "author": "gaz", "description": "3d", "tags": ["fractal"], "likes": 16, "viewed": 130, "published": "Public", "date": "1612766585", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)cos(h*6.3+vec3(0,23,21))*.5+.5\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 r=iResolution,p;  \n    for(float i=0.,g,e,l,s;\n        ++i<99.;\n        (e<.002)?O.xyz+=mix(r/r,H(g*.5),.5)*.5/i:p\n    )\n    {\n        p=g*vec3((C-.5*r.xy)/r.y,1);\n        p.z-=.4;\n        p=R(p,normalize(vec3(1,3,3)),iTime*.2);\n        p=mod(p-1.,2.)-1.;\n        p.x<-p.z?p.xz=-p.zx:C;\n        s=3.;\n        for(int j=0;j++<6;)\n            s*=l=2./min(dot(p,p),1.),\n            p=abs(p)*l-vec3(1,1,15);\n        g+=e=length(cross(p,r/r))/s;\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tdBWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 102, 138, 138, 611]], "test": "valid"}
{"id": "3tdfD2", "name": "大龙猫 - Vortex", "author": "totetmatt", "description": "React better on Bonzo, especially the fft part", "tags": ["tunnel", "music", "rainbow"], "likes": 8, "viewed": 276, "published": "Public API", "date": "1613507942", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define PI 3.141592\nmat2 rot(float a){\n  float c=cos(a),s=sin(a);\n    return mat2(c,-s,s,c);\n  }\n  \n   \n    \nfloat stargate(vec2 uv,float offset)\n{\n\n  vec2 uuv = uv;\n  uuv*=rot(offset*23.);\n  float c = sin(atan(uuv.x,uuv.y))*.5+.5;\n\tfloat f = texture(iChannel0,vec2(abs(floor(20.*c)/20.))).r*exp(1.+c)*.10;\n  \n  float d = abs(length(uv)-(.4+f*1.5))-.04;\n\n   return d;  \n  }\n  \n  vec3 pal(float t){\n    return +vec3(.5,.7,.5)+vec3(.5,.7,.5)*cos(2.*PI*(vec3(1.,10.1,1.)*t+vec3(.3,.0,.7)));\n    \n    }\n    \n    float grid(vec2 uv){\n      return abs(fract(uv.x*10.))<.02 || abs(fract(uv.y*10.))<.02  ? 1.: 0.;\n      }\n      \n      \n      \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n float tt = texture(iChannel0,vec2(.3,uv.y)).r*.1;\n\n  float d = 1.;      \n  float lim = 10.;\n  vec3 col  = vec3(0.);\n  for(float i=0.;i<=lim;++i){\n         float it = i/lim;\n       \n          float pit = fract(it+iTime*.1);\n           float qq = tt*25. > pit? tt*50.0:1.;\n          it = mix(50.,.001,pit);\n    \n    vec2 coord = (uv-.05*vec2(it*tt*sin(iTime),it*tt *cos(iTime)))*it;\n    float g = pit*grid(uv*it*rot(pit*2.)) * smoothstep(.01,.021,(length(coord)-.55));\n        d = .1/abs(.01+stargate(coord,i/lim));\n        d = (d*3.*g)+d;    \n    col += mix(vec3(.1),pal((i/lim)+tt)*pit,d*qq)/lim;\n    }\n   \n    \n    \n\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "ltfXzM", "previewfilepath": "https://soundcloud.com/h0ffman/hoffman-pingit-1984-soundtrack", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/h0ffman/hoffman-pingit-1984-soundtrack", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tdfD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 39, 39, 97], [110, 110, 148, 148, 374], [380, 380, 398, 398, 499], [509, 509, 529, 529, 614], [636, 636, 693, 743, 1481]], "test": "error"}
{"id": "3tdfRS", "name": "002_simplex.frag", "author": "jorge2017a1", "description": "002_simplex.frag", "tags": ["002simplexfrag"], "likes": 1, "viewed": 37, "published": "Public", "date": "1612971549", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//https://github.com/willstall/30-days-of-shade/blob/master/assets/shaders/002_simplex.frag\n\n/*\n    daily: 002\n    author: Will Stallwood\n    insta: https://www.instagram.com/willstall/\n    \n*/\n\n\n\n#define PI 3.14159265359\n#define HALF_PI 1.57079632675\n#define TWO_PI 6.283185307\n\n\nvec3 palette(float t,vec3 a,vec3 b,vec3 c,vec3 d )\n{\n    return a + b * cos( TWO_PI * (c*t+d));\n}\n\nfloat random(float x)\n{\n    return fract(sin(x*100.00)*10000.0);\n}\n\nfloat random(vec2 st)\n{\n    return fract(\n        dot(\n            sin(st.x*100.00),\n            sin(st.y*100.00)        \n        )*10000.0);\n}\n\nfloat smoothCellRandom(float x,float scale)\n{   \n    float iPos = floor(x*scale);\n    float fPos = fract(x*scale);\n\n    return mix(random(iPos), random(iPos + 1.0), smoothstep(0.,1.,fPos));\n}\n\nfloat peakCellRandom(float x,float scale)\n{   \n    float iPos = floor(x*scale);\n    float fPos = fract(x*scale);\n\n    return mix(random(iPos), random(iPos + 1.0), fPos);\n}\n\nfloat cellRandom(float x,float scale)\n{   \n    float iPos = floor(x*scale);\n    float fPos = fract(x*scale);\n\n    return random(iPos);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 st = fragCoord.xy / iResolution.xy;\n\n    vec3 color = vec3(0.0);\n    //    color.x = abs(sin(u_time));\n    float t = iTime * .33;\n    float scale = 20.;\n\n    float cell = cellRandom(st.x+t,scale);\n    float r = floor(cell*st.y*scale);\n    float f = st.y * abs(sin( cell*100.0 + iTime));\n    r *= f;\n    r = 1.0 - step(1.0,r);\n    r += 1.0-f;\n\n    float d = smoothCellRandom(st.x+t,scale);\n    // d *= r;\n    d = r;\n\n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(0.0,.1,0.2);\n\n    color = palette(d+fract(t)*2.0,vec3(0.5),a,b,c);\n    // color += d;\n\n    fragColor = vec4(color,1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tdfRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 281, 333, 333, 378], [380, 380, 403, 403, 446], [448, 448, 471, 471, 591], [593, 593, 638, 638, 784], [786, 786, 829, 829, 957], [959, 959, 998, 998, 1095], [1097, 1097, 1154, 1154, 1786]], "test": "error"}
{"id": "3tdfWB", "name": "Ludicrous Speed", "author": "GaryCXJk", "description": "They've gone plaid!\n\nThis is an attempted recreation of the Ludicrous Speed scene of Spaceballs. It's not perfect, but it does come close.", "tags": ["tunnel"], "likes": 6, "viewed": 90, "published": "Public", "date": "1613409521", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Ludicrous Speed\n// Author: GaryCXJk\n#define PI 3.1415926538\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec2 getRatio() {\n    vec2 ratio = vec2(1.0, 1.0);\n    \n    if (iResolution.x < iResolution.y) {\n        ratio.y = iResolution.x / iResolution.y;\n    } else if (iResolution.y < iResolution.x) {\n        ratio.x = iResolution.y / iResolution.x;\n    }\n    return ratio;\n}\n\nvec4 centerGlow(vec2 uv, float glowSize, vec4 glowColor, vec4 glowColorShift) {\n    vec2 ratio = getRatio();\n    \n    vec4 col = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    vec4 box = 0.5 + vec4(-ratio.x, -ratio.y, ratio.x, ratio.y) * glowSize;\n    \n    if (uv.x >= box.x && uv.x <= box.z && uv.y >= box.y && uv.y <= box.w) {\n        vec2 miniUV = uv;\n        miniUV-= box.xy;\n        miniUV/= ratio * 2.0 * glowSize;\n        float angle = atan(miniUV.y - 0.5, miniUV.x - 0.5);\n        vec2 pos = vec2(cos(angle), sin(angle));\n        float mag = distance(miniUV, vec2(0.5, 0.5));\n        mag += sin(angle * 3.0 + iTime * 24.0) * cos(angle * 5.0 - iTime * 26.0) * sin(angle * 4.0 + iTime * 48.0) * 0.02;\n        mag += sin(angle * 3.0 + 0.2 + iTime * 32.0) * cos(angle * 7.0 - iTime * 40.0) * sin(angle * 4.0 - iTime * 68.0) * 0.01;\n        mag += sin(angle * 7.0 + 0.3 + iTime * 20.0) * cos(angle * 2.0 - iTime * 24.0) * sin(angle * 4.0 + iTime * 88.0) * 0.03;\n        float dist = 2.0 * (0.5 - mag);\n        dist = smoothstep(0.1, 1.14, dist) * 2.0;\n        col.xyz = vec3(dist);\n        float colorRatio = (1.0 - clamp(dist, 0.0, 1.0));\n        vec4 realColor = glowColor * (1.0 - colorRatio) + glowColorShift * colorRatio;\n        col*= realColor;\n    }\n    \n    return col;\n}\n\nvec4 plaid(vec2 uv, float yPos, float tunnelOffset) {\n    vec4 plaidCol = vec4(0.0);\n    float brightness = 1.2 - yPos * 0.6;\n    \n    if ((uv.x > 0.025 && uv.x < 0.1) || (uv.x > 0.9 && uv.x < 0.975)) {\n        return vec4(1.0, 0.6, 0.0, 1.0) * 0.9 * brightness;\n    } else {\n        float darkMultiplier = 1.0;\n        if (yPos > tunnelOffset) {\n            if ((uv.y > 0.025 && uv.y < 0.1) || (uv.y > 0.9 && uv.y < 0.975)) {\n                plaidCol+= vec4(1.0, 0.6, 0.0, 1.0) * 0.7;\n            }\n            if ((uv.y > 0.65 && uv.y < 0.725) || (uv.y > 0.775 && uv.y < 0.85)) {\n                plaidCol+= vec4(0.8, 0.0, 0.0, 1.0) * 0.3;\n            }\n            brightness = 1.6 - yPos * 1.2;\n        } else {\n            darkMultiplier = 0.65;\n            brightness = 1.0;\n        }\n        if ((uv.x > 0.15 && uv.x < 0.225) || (uv.x > 0.275 && uv.x < 0.35)) {\n            plaidCol+= vec4(0.8, 0.0, 0.0, 1.0) * 0.5;\n        }\n        if ((uv.x > 0.525 && uv.x < 0.6) || (uv.x > 0.775 && uv.x < 0.85)) {\n            plaidCol+= vec4(0.0, 0.0, 0.8, 1.0) * 0.5 * darkMultiplier;\n        }\n        if ((uv.x > 0.4 && uv.x < 0.475) || (uv.x > 0.65 && uv.x < 0.725)) {\n            plaidCol+= vec4(0.2, 0.2, 0.2, 1.0) * 0.5 * darkMultiplier;\n        }\n    }\n    \n    return plaidCol * brightness;\n}\n\nvec4 wall(vec2 uv, float angle, float tunnelOffset) {\n    // For now horizon isn't used.\n    // float horizon = max(iResolution.x, iResolution.y);\n    \n    // Initialize the ratio, as well as the ratio adjusted UV.\n    vec2 ratio = getRatio();\n    vec2 newUV = -(uv - 0.5) / ratio;\n    \n    // We'll calculate the distance from origin, as well as the angle relative to origin.\n    float dist = distance(newUV, vec2(0.0, 0.0));\n    float cAngle = atan(newUV.y, newUV.x);\n    \n    // Convert the angle in degrees to radians.\n    float rad = angle / 180.0 * PI;\n    \n    // Now we'll rotate the UV accordingly.\n    newUV.x = dist * cos(cAngle + rad);\n    newUV.y = dist * sin(cAngle + rad);\n    \n    float yPos = newUV.y;\n    \n    // Originally we defined the horizon, from which we'd calculate the Z.\n    // float z = newUV.y * horizon;\n    float scale = 0.0;\n    if (newUV.y > 0.0) {\n        scale = 1.0 / newUV.y;\n    }\n    \n    if (newUV.x < -newUV.y) {\n        return vec4(0.0);\n    }\n    \n    if (newUV.x > newUV.y) {\n        return vec4(0.0);\n    }\n    \n    float invScale = 0.0;\n    if (newUV.y < 1.0) {\n        invScale = 1.0 / (1.0 - newUV.y);\n    }\n    \n    newUV.x*= 1.3;\n    \n    newUV.x = mod(newUV.x * scale + 0.3, 1.0);\n    newUV.y = mod(newUV.y + iTime + scale * 4.0, 1.0);\n    \n    return plaid(newUV, yPos, tunnelOffset);\n}\n\nvec4 plaidSquare(vec2 uv, float tunnelOffset, float tunnelSpawnSize) {\n    vec2 ratio = getRatio();\n    \n    vec4 col = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    vec4 box = 0.5 + vec4(-ratio.x, -ratio.y, ratio.x, ratio.y) * tunnelOffset;\n    \n    float tunnelSpawnOffset = 1.0 - tunnelSpawnSize;\n    \n    if (uv.x >= box.x && uv.x <= box.z && uv.y >= box.y && uv.y <= box.w) {\n        vec2 miniUV = uv;\n        miniUV-= box.xy;\n        miniUV/= ratio * 2.0 * tunnelOffset;\n        \n        vec2 boxUV = abs((miniUV.xy * 2.0) - 1.0);\n        \n        float maxDist = max(boxUV.x, boxUV.y);\n        \n        float distVal = clamp((maxDist - tunnelSpawnOffset) / tunnelSpawnSize, 0.0, 1.0);\n        distVal = 1.0 - mod(distVal - iTime, 1.0);\n        \n        if (maxDist < tunnelSpawnOffset) {\n          distVal = 0.0;\n        }\n        \n        if ((distVal > 0.0 && distVal < 0.015) || (distVal > 0.02 && distVal < 0.035)) {\n            col = vec4(0.8, 0.0, 0.0, 1.0) * 0.3;\n        }\n        if ((distVal > 0.04 && distVal < 0.055) || (distVal > 0.06 && distVal < 0.075)) {\n            col = vec4(1.0, 0.6, 0.0, 1.0) * 0.7;\n        }\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float iGlowSize = 0.12;\n    vec4 iGlowColor = vec4(1.0, 0.9, 0.5, 1.0);\n    vec4 iGlowColorShift = vec4(1.0, 0.1, 0.0, 1.0);\n    float iTunnelOffset = 0.15;\n    float iTunnelSpawnSize = 0.375;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 glowCol = centerGlow(uv, iGlowSize, iGlowColor, iGlowColorShift);\n    vec4 wallCol = wall(uv, 0.0, iTunnelOffset) + wall(uv, 90.0, iTunnelOffset) + wall(uv, 180.0, iTunnelOffset) + wall(uv, 270.0, iTunnelOffset);\n\n    // Output to screen\n    // fragColor = glowCol;\n    fragColor = glowCol + wallCol + plaidSquare(uv, iTunnelOffset, iTunnelSpawnSize);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tdfWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 64, 86, 86, 417], [419, 419, 441, 441, 610], [612, 612, 629, 629, 880], [882, 882, 961, 961, 2153], [2155, 2155, 2208, 2208, 3452], [3454, 3454, 3507, 3668, 4793], [4795, 4795, 4865, 4865, 5950], [5952, 5952, 6009, 6009, 6669]], "test": "valid"}
{"id": "3tGBRm", "name": "Jupiter-ish Domain Warping", "author": "pvnetto", "description": "Just some simple domain warping exercise inspired on the gas giants", "tags": ["noisefbmwarping"], "likes": 4, "viewed": 80, "published": "Public", "date": "1614046924", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 p) {\n    return fract(\n        cos(\n            dot(p, vec2(5981.43, 85749.43))\n        ) * 28497.41\n    );\n}\n\nfloat noise(vec2 p) {\n    vec2 pi = floor(p);\n    vec2 pf = fract(p);\n    \n    float ca = rand(pi);\n    float cb = rand(pi + vec2(1., 0.));\n    float cc = rand(pi + vec2(0., 1.));\n    float cd = rand(pi + vec2(1., 1.));\n    \n    vec2 u = smoothstep(0., 1., pf);\n    return mix(\n        mix(ca, cb, u.x),\n        mix(cc, cd, u.x),\n        u.y\n    );\n}\n\nfloat fbm(vec2 p) {\n    const int octaves = 12;\n    const float lacunarity = 2.;\n    const float gain = 0.55;\n    \n    float freq = 1.;\n    float amp = 0.5;\n    \n    float n = 0.;\n    for(int i = 0; i < octaves; i++) {\n        n += noise(p * freq) * amp;\n    \n        freq *= lacunarity;\n        amp *= gain;\n    }\n    \n    return n;\n}\n\nfloat pattern(vec2 p, out vec2 q, out vec2 r) {\n    q = vec2(\n        fbm(p + vec2(4., 0.5) + iTime * 0.2),\n        fbm(p + vec2(2., 32.))\n    );\n    \n    r = vec2(\n        fbm(p + q + iTime * 0.3),\n        fbm(p + q + vec2(1.3, 2.4))\n    );\n    \n    return fbm(p + r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 p = uv * 8.;\n    vec2 q, r;\n    float pct = pattern(p, q, r); \n    vec3 col = mix(vec3(0.8), vec3(1., 0.43, 0.), q.x);\n    col = mix(col, vec3(1.0, 0.75, 0.4), p.x / q.x * r.x / 12.);\n    col *= pct;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGBRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 125], [127, 127, 148, 148, 477], [479, 479, 498, 498, 814], [816, 816, 863, 863, 1087], [1089, 1089, 1146, 1146, 1434]], "test": "valid"}
{"id": "3tGBWR", "name": "2D Rotation Example", "author": "inspirnathan", "description": "An example on how to rotate 2D shapes. Visit my tutorial to learn more: [url]https://inspirnathan.com/posts/49-shadertoy-tutorial-part-3[/url]", "tags": ["2d", "rotation", "2drotation", "inspirnathan"], "likes": 1, "viewed": 97, "published": "Public", "date": "1614126934", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Learn more in my tutorial: https://inspirnathan.com/posts/49-shadertoy-tutorial-part-3\n\nvec2 rotate(vec2 uv, float th) {\n    return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;\n}\n\nvec3 sdfSquare(vec2 uv, float size, vec2 offset) {\n    float x = uv.x - offset.x;\n    float y = uv.y - offset.y;\n    vec2 rotated = rotate(vec2(x,y), iTime);\n    float d = max(abs(rotated.x), abs(rotated.y)) - size;\n    \n    return d > 0. ? vec3(1.) : vec3(1., 0., 0.);\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n    uv -= 0.5; // <-0.5,0.5>\n    uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n    vec2 offset = vec2(0.0, 0.0);\n\n    vec3 col = sdfSquare(uv, 0.2, offset);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGBWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 91, 123, 123, 184], [186, 186, 236, 236, 462], [465, 465, 522, 522, 800]], "test": "valid"}
{"id": "3tGfzz", "name": "Attractive Background", "author": "encompass", "description": "A background for my webpage.", "tags": ["background"], "likes": 0, "viewed": 90, "published": "Public", "date": "1613730617", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define INTENSITY 1.6\n#define GLOW 1.2\n\nvec3 blob(vec2 uv, vec3 color, vec2 speed, vec2 size, float time) {\n    vec2 point = vec2(\n        sin(speed.x * time) * size.x,\n        cos(speed.y * time) * size.y\n    );\n\n    float d = distance(uv, point);\n    d = pow(d / INTENSITY, GLOW);\n    \n    return vec3(color.r * d, color.g * d, color.b * d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = -1.0 + 2.0 * (fragCoord.xy / iResolution.xy);\n\n    float time = iTime * 0.2;\n\n    float freqBlue = texture(iChannel0, vec2(0.01,0.25)).x * 4.0;\n    float freqGreen = texture(iChannel0, vec2(0.1,0.25)).x * 2.0;\n    \n    //Colours for the blobs\n    //0B0F32 = 11, 15, 50 = 0.043 0.059 0.196\n    //111744 = 17, 23, 68 = 0.067 0.090 0.267\n    vec4 color = vec4(0.043, 0.059, 0.196, 1.0);\n    color.rgb += blob(uv,\n                      vec3(0.024, 0.031, 0.071),\n                      vec2(2.5, 2.2),\n                      vec2(0.9, 0.4),\n                      time);\n    color.rgb += blob(uv,\n                      vec3(0.024, 0.031, 0.071),\n                      vec2(1.2, 2.3),\n                      vec2(0.4, 0.3),\n                      time);\n    color.rgb += blob(uv,\n                      vec3(-0.024, -0.031, -0.071),\n                      vec2(2.3, 2.1),\n                      vec2(0.4, 0.6),\n                      time);\n    color.rgb += blob(uv,\n                      vec3(-0.024, -0.031, -0.071),\n                      vec2(2.1, 1.0),\n                      vec2(0.2, 0.8),\n                      time);\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGfzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[40, 40, 107, 107, 345], [347, 347, 404, 404, 1553]], "test": "error"}
{"id": "3tKBDz", "name": "Wind Waker Ocean 2D Texture", "author": "rooksword", "description": "Modified shader code to make this 2d ocean texture.\n\nFork of https://www.shadertoy.com/view/ltfGD7.", "tags": ["sea", "ocean", "zelda", "windwaker"], "likes": 3, "viewed": 492, "published": "Public", "date": "1614200042", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define WATER_COL vec3(0.0, 0.4453, 0.7305)\n#define WATER2_COL vec3(0.0, 0.4180, 0.6758)\n#define FOAM_COL vec3(0.8125, 0.9609, 0.9648)\n\n#define M_2PI 6.283185307\n#define M_6PI 18.84955592\n\nfloat circ(vec2 pos, vec2 c, float s)\n{\n    c = abs(pos - c);\n    c = min(c, 1.0 - c);\n\n    return smoothstep(0.0, 0.002, sqrt(s) - sqrt(dot(c, c))) * -1.0;\n}\n\n// Foam pattern for the water constructed out of a series of circles\nfloat waterlayer(vec2 uv)\n{\n    uv = mod(uv, 1.0); // Clamp to [0..1]\n    float ret = 1.0;\n    ret += circ(uv, vec2(0.37378, 0.277169), 0.0268181);\n    ret += circ(uv, vec2(0.0317477, 0.540372), 0.0193742);\n    ret += circ(uv, vec2(0.430044, 0.882218), 0.0232337);\n    ret += circ(uv, vec2(0.641033, 0.695106), 0.0117864);\n    ret += circ(uv, vec2(0.0146398, 0.0791346), 0.0299458);\n    ret += circ(uv, vec2(0.43871, 0.394445), 0.0289087);\n    ret += circ(uv, vec2(0.909446, 0.878141), 0.028466);\n    ret += circ(uv, vec2(0.310149, 0.686637), 0.0128496);\n    ret += circ(uv, vec2(0.928617, 0.195986), 0.0152041);\n    ret += circ(uv, vec2(0.0438506, 0.868153), 0.0268601);\n    ret += circ(uv, vec2(0.308619, 0.194937), 0.00806102);\n    ret += circ(uv, vec2(0.349922, 0.449714), 0.00928667);\n    ret += circ(uv, vec2(0.0449556, 0.953415), 0.023126);\n    ret += circ(uv, vec2(0.117761, 0.503309), 0.0151272);\n    ret += circ(uv, vec2(0.563517, 0.244991), 0.0292322);\n    ret += circ(uv, vec2(0.566936, 0.954457), 0.00981141);\n    ret += circ(uv, vec2(0.0489944, 0.200931), 0.0178746);\n    ret += circ(uv, vec2(0.569297, 0.624893), 0.0132408);\n    ret += circ(uv, vec2(0.298347, 0.710972), 0.0114426);\n    ret += circ(uv, vec2(0.878141, 0.771279), 0.00322719);\n    ret += circ(uv, vec2(0.150995, 0.376221), 0.00216157);\n    ret += circ(uv, vec2(0.119673, 0.541984), 0.0124621);\n    ret += circ(uv, vec2(0.629598, 0.295629), 0.0198736);\n    ret += circ(uv, vec2(0.334357, 0.266278), 0.0187145);\n    ret += circ(uv, vec2(0.918044, 0.968163), 0.0182928);\n    ret += circ(uv, vec2(0.965445, 0.505026), 0.006348);\n    ret += circ(uv, vec2(0.514847, 0.865444), 0.00623523);\n    ret += circ(uv, vec2(0.710575, 0.0415131), 0.00322689);\n    ret += circ(uv, vec2(0.71403, 0.576945), 0.0215641);\n    ret += circ(uv, vec2(0.748873, 0.413325), 0.0110795);\n    ret += circ(uv, vec2(0.0623365, 0.896713), 0.0236203);\n    ret += circ(uv, vec2(0.980482, 0.473849), 0.00573439);\n    ret += circ(uv, vec2(0.647463, 0.654349), 0.0188713);\n    ret += circ(uv, vec2(0.651406, 0.981297), 0.00710875);\n    ret += circ(uv, vec2(0.428928, 0.382426), 0.0298806);\n    ret += circ(uv, vec2(0.811545, 0.62568), 0.00265539);\n    ret += circ(uv, vec2(0.400787, 0.74162), 0.00486609);\n    ret += circ(uv, vec2(0.331283, 0.418536), 0.00598028);\n    ret += circ(uv, vec2(0.894762, 0.0657997), 0.00760375);\n    ret += circ(uv, vec2(0.525104, 0.572233), 0.0141796);\n    ret += circ(uv, vec2(0.431526, 0.911372), 0.0213234);\n    ret += circ(uv, vec2(0.658212, 0.910553), 0.000741023);\n    ret += circ(uv, vec2(0.514523, 0.243263), 0.0270685);\n    ret += circ(uv, vec2(0.0249494, 0.252872), 0.00876653);\n    ret += circ(uv, vec2(0.502214, 0.47269), 0.0234534);\n    ret += circ(uv, vec2(0.693271, 0.431469), 0.0246533);\n    ret += circ(uv, vec2(0.415, 0.884418), 0.0271696);\n    ret += circ(uv, vec2(0.149073, 0.41204), 0.00497198);\n    ret += circ(uv, vec2(0.533816, 0.897634), 0.00650833);\n    ret += circ(uv, vec2(0.0409132, 0.83406), 0.0191398);\n    ret += circ(uv, vec2(0.638585, 0.646019), 0.0206129);\n    ret += circ(uv, vec2(0.660342, 0.966541), 0.0053511);\n    ret += circ(uv, vec2(0.513783, 0.142233), 0.00471653);\n    ret += circ(uv, vec2(0.124305, 0.644263), 0.00116724);\n    ret += circ(uv, vec2(0.99871, 0.583864), 0.0107329);\n    ret += circ(uv, vec2(0.894879, 0.233289), 0.00667092);\n    ret += circ(uv, vec2(0.246286, 0.682766), 0.00411623);\n    ret += circ(uv, vec2(0.0761895, 0.16327), 0.0145935);\n    ret += circ(uv, vec2(0.949386, 0.802936), 0.0100873);\n    ret += circ(uv, vec2(0.480122, 0.196554), 0.0110185);\n    ret += circ(uv, vec2(0.896854, 0.803707), 0.013969);\n    ret += circ(uv, vec2(0.292865, 0.762973), 0.00566413);\n    ret += circ(uv, vec2(0.0995585, 0.117457), 0.00869407);\n    ret += circ(uv, vec2(0.377713, 0.00335442), 0.0063147);\n    ret += circ(uv, vec2(0.506365, 0.531118), 0.0144016);\n    ret += circ(uv, vec2(0.408806, 0.894771), 0.0243923);\n    ret += circ(uv, vec2(0.143579, 0.85138), 0.00418529);\n    ret += circ(uv, vec2(0.0902811, 0.181775), 0.0108896);\n    ret += circ(uv, vec2(0.780695, 0.394644), 0.00475475);\n    ret += circ(uv, vec2(0.298036, 0.625531), 0.00325285);\n    ret += circ(uv, vec2(0.218423, 0.714537), 0.00157212);\n    ret += circ(uv, vec2(0.658836, 0.159556), 0.00225897);\n    ret += circ(uv, vec2(0.987324, 0.146545), 0.0288391);\n    ret += circ(uv, vec2(0.222646, 0.251694), 0.00092276);\n    ret += circ(uv, vec2(0.159826, 0.528063), 0.00605293);\n\treturn max(ret, 0.0);\n}\n\n// Procedural texture generation for the water\nvec3 water(vec2 uv, vec3 cdir)\n{\n    uv *= vec2(0.25);\n\n    // Parallax height distortion with two directional waves at\n    // slightly different angles.\n    vec2 a = 0.025 * cdir.xz / cdir.y; // Parallax offset\n    float h = sin(uv.x + iTime); // Height at UV\n    uv += a * h;\n    h = sin(0.841471 * uv.x - 0.540302 * uv.y + iTime);\n    uv += a * h;\n    \n    // Texture distortion\n    float d1 = mod(uv.x + uv.y, M_2PI);\n    float d2 = mod((uv.x + uv.y + 0.25) * 1.3, M_6PI);\n    d1 = iTime * 0.07 + d1;\n    d2 = iTime * 0.5 + d2;\n    vec2 dist = vec2(\n    \tsin(d1) * 0.15 + sin(d2) * 0.05,\n    \tcos(d1) * 0.15 + cos(d2) * 0.05\n    );\n    \n    vec3 ret = mix(WATER_COL, WATER2_COL, waterlayer(uv + dist.xy));\n    ret = mix(ret, FOAM_COL, waterlayer(vec2(1.0) - uv - dist.yx));\n    return ret;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(water(fragCoord/32., vec3(0,1,0)),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKBDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[189, 189, 228, 228, 347], [349, 418, 445, 445, 4912], [4914, 4961, 4993, 4993, 5756], [5759, 5759, 5816, 5816, 5877]], "test": "valid"}
{"id": "3tKBRm", "name": "raymarchingbasicTuTo", "author": "gourki", "description": "first raymarching shader made in a cours at my university", "tags": ["raymarching"], "likes": 2, "viewed": 205, "published": "Public API", "date": "1614093066", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//thanks remy\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n//thanks iq\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n   p.x += sin(p.y*10.+iTime*2.0)*0.1;\n   p.y += sin(p.z*10.+iTime*5.0)*0.1;\n   p.z += sin(p.x*10.+iTime*2.0)*0.1;\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\n\nvec3 opRep(vec3 p, vec3 c){\n    return mod(p+0.5*c,c) -0.5*c;\n\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nfloat map(vec3 pos)\n{\n    pos = opRep(pos,vec3(6));\n    \n    float world = sdRoundBox(pos, vec3(0.5),0.5);\n    pos.xz *= rot(iTime);\n    pos.yz *= rot(iTime);\n    pos.xy += sin(iTime)*2.0;\n    world = opSmoothUnion(world, sdRoundBox(pos, vec3(0.5),0.5),0.5);\n    return world;\n}\n\n\n\n\nfloat CastRay(vec3 ro, vec3 rd)\n{\n    float c = 0.0;\n    \n    for(int i = 0; i<64; i++)\n    {\n        float ray = map(ro + rd *c);\n        \n        if(ray < (0.001*c))\n        {\n            return float(i)/32.;\n        }\n        \n        c += ray;\n    }    \n\n    return -1.0;\n}\n\n\nvec3 render(vec3 ro, vec3 rd)// ray origin & ray direction )\n{\n    float contact = CastRay(ro,rd); \n    \n    \n    vec3 col = vec3(0.0);\n    \n    if (contact == -1.0)\n    {\n    col = vec3(mix(vec3(0.0,1.0,1.0),vec3(0.,0.,1.),abs(rd.y)));\n    }\n    else{\n        col = palette(contact, vec3(0.5), vec3(0.5),vec3(1.0),vec3(0.0,0.33,0.));\n        //col = mix(vec3(0.2,0.0,0.0),vec3(1.0,0.0,0.0),(1.0-contact));\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   //Centrer camera \n   vec2 uv = 2.0 * fragCoord/iResolution.xy - 1.0;\n   uv.x *= iResolution.x/iResolution.y;\n   \n   //Camera\n   \n   vec3 cameraPos = vec3(iTime*10.0,-10.*cos(iTime*1.), -10.*sin(iTime*1.));\n   vec3 cameraTar = vec3(iTime,0.0,5.0);\n   \n   // view Direction / Ray Direction \n   vec3 forward = normalize(cameraTar - cameraPos);\n   vec3 right = normalize(cross(vec3(0.0, -1.0,0.0), forward));\n   vec3 up = normalize(cross(right, forward));\n   vec3 viewDir = normalize(uv.x* right + uv.y * up + forward * 2.0);\n   \n   //Time varying pixel color\n   vec3 col = vec3(uv.x, uv.y, 0.0);\n   \n   col = render(cameraPos, viewDir);\n   \n   //output to screen \n   fragColor = vec4(col,1.0);\n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKBRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 77, 122, 122, 327], [329, 329, 401, 401, 444], [448, 448, 475, 475, 512], [514, 514, 566, 566, 665], [668, 668, 689, 689, 946], [951, 951, 984, 984, 1228], [1231, 1231, 1293, 1293, 1661], [1663, 1663, 1720, 1741, 2420]], "test": "valid"}
{"id": "3tKBz1", "name": "Finite Repetition", "author": "oneshade", "description": "Reinventing the wheel to understand, I'm pretty sure its exact.", "tags": ["sdf", "repetition", "exact", "limited", "finite"], "likes": 4, "viewed": 111, "published": "Public", "date": "1613887745", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// i: repeat interval\n// b: repetition bounds\n// Note: b must be evenly divisible by i!\nvec2 repFinite(in vec2 p, in vec2 i, in vec2 b) {\n    return p - 0.5 * i - clamp(i * floor(p / i + 0.5), -b, b);\n}\n\nfloat sdBox(in vec2 p, in vec2 b) {\n    vec2 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(0.0, max(q.x, q.y));\n}\n\nfloat map(in vec2 p) {\n    float t = iTime;\n    vec2 i = vec2(1.0 + 0.5 * sin(t));\n\n    t *= 0.25;\n    vec2 r = mod(vec2(floor(3.0 + 3.0 * cos(t)), floor(3.0 + 3.0 * sin(t))), 3.0);\n\n    p = repFinite(p, i, i * r) + 0.5 * i;\n    return sdBox(p, vec2(0.1));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 2.0 / iResolution.y;\n    float time = iTime * 2.0;\n\n    float d = map(uv);\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(d) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 1.0 - exp(-4.0 * abs(d));\n\tcolor *= 0.8 + 0.2 * cos(140.0 * d);\n\tcolor = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(d)));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKBz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 88, 137, 137, 202], [204, 204, 239, 239, 324], [326, 326, 348, 348, 584], [586, 586, 641, 641, 1068]], "test": "valid"}
{"id": "3tKfW1", "name": "Sine Moiré", "author": "dlozeve", "description": "Moiré pattern with high-frequency sine curve", "tags": ["moire", "trig"], "likes": 1, "viewed": 162, "published": "Public API", "date": "1614263906", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float angle(vec2 u, vec2 v) {\n  return acos(dot(u, v) / (length(u) * length(v)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 p = fragCoord.xy / iResolution.xy;\n  float color = 0.0;\n  vec2 c = vec2(0.5);\n  float i = float(int(iFrame) % 1000) / 200.0;\n  float border = 0.5 * sin(i * 1000.0 * angle(fract(p) - c, vec2(1.0, 0.0)));\n  if (length(fract(p) - c) < border) {\n    color = 1.0;\n  }\n  fragColor = vec4(vec3(color), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKfW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 83], [86, 86, 143, 143, 453]], "test": "valid"}
{"id": "3tKfWh", "name": "Agnes Hailstone's caribou hunt", "author": "evvvvil", "description": "Agnes Hailstone's caribou hunt - Result of an improvised live coding session on Twitch\nLIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 20:00 Uk time:\nhttps://www.twitch.tv/evvvvil_", "tags": ["demoscene", "glow", "ghost", "life", "monster", "god", "zero", "horror", "spirit", "ghoul", "deity", "goddess", "below", "witch"], "likes": 17, "viewed": 483, "published": "Public API", "date": "1614258933", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Agnes Hailstone's caribou hunt - Result of an improvised live coding session on Twitch\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 20:00 Uk time: \n// https://www.twitch.tv/evvvvil_\n\n// \"I just gave this caribou its last drink.\" - Agnes Hailstone \n\n//EDIT 27-02-21: LINE 26: Found a nifty way to drastically reduce artifact as it swirls by reusing the swirl value to contrl the definition of the distance field, does a cool \"warpy motion blur\"\n\nvec2 z,v,e=vec2(.001,-.001);float t,tt,b,ct,g=0.,gg=0.,tnoi;vec3 bp,pp,po,no,ld,al,cp,op;\nfloat bo(vec3 p,vec3 r){p=abs(p)-r;return max(max(p.x,p.y),p.z);}\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}\nfloat smin(float a,float b,float k){float h=max(k-abs(a-b),0.);return min(a,b)-h*h*.25/k;}\nvec4 texNoise(vec2 uv,sampler2D tex ){ float f = 0.; f+=texture(tex, uv*.125).r*.5; f+=texture(tex,uv*.25).r*.25;\n                       f+=texture(tex,uv*.5).r*.125; f+=texture(tex,uv*1.).r*.125; f=pow(f,1.2);return vec4(f*.45+.05);}\nvec2 mp( vec3 p, float ga )\n{\n  op=p;p.xy+=v;  \n  p.yz*=r2(-1.2+sin(op.z*.02-tt)*0.5);  \n  float bro=smoothstep(0.,1.,(clamp(cos(p.y*.04+tt*0.5+1.),-.33,.33)+.33)*1.51);\n  p.xz*=r2(ct*.75+bro*6.28);\n  tnoi=texNoise(p.xy*.12+3.,iChannel0).r;  \n  float sinner =sin(p.y*.5+1.0),xd=sin(p.x*(10.-sinner*5.))*.15,zd=pow((cos(p.y*.5+tt))*1.3,2.); \n  cp=p+tnoi; cp.xz+=xd; cp.z-=zd;  \n  float head=abs(length(cp-vec3(xd,6,0))-2.)-.1;//HOOD\n  head=0.6*max(head,-cp.z);    \n  float art=clamp(sin(bro*-3.14)*.5+.5,0.1,0.5);\n  float coat=bo(cp,vec3(2.+sinner*1.75+sin(p.y*10.)*0.03,6,0.04 ));/////CLOAK\n  coat=max(coat,-(length(cp.xz)+sin(p.y*.5+0.75)-tnoi*2.));  \n  pp=p-vec3(0,2,0);pp.xy=abs(pp.xy)-vec2(1.+sin(p.y+p.x*.2-.1)*1.5,1);\n  pp.x=abs(pp.x)-1.;\n  coat=art*max(coat,-(length(pp.yx)+.2-tnoi*3.8));\n  vec2 h,t=vec2(coat,5);  \n  t.x=smin(t.x,head,.25);  \n  vec3 ep=p-vec3(0,6.4,0); ////EYESSSSSS   \n  ep.xz=vec2(abs(ep.x)-0.5,ep.z-zd+.1);\n  ep.xy*=r2(.3);\n  float eyes=0.6*length(ep)-cos(clamp(ep.y*15.,-5.,5.))*.2;  \n  t.x=min(t.x,eyes);   \n  pp=p-vec3(0,0,2.7);//SPINES\n  pp.x=abs(pp.x)-.5+(p.y-9.)*.3; pp.xz-=vec2(xd*.5,zd); \n  pp.yz*=r2(-0.3);\n  float spines=length(pp.xz)-0.1+sin(p.y*.2-1.8)*.5;\n  spines=max(spines,abs(p.y-1.)-9.);\n  t.x=smin(art*spines,t.x,.5);     \n  pp=p-vec3(0,5.5,zd+1.);//FACE\n  cp=pp;\n  h=vec2(length(pp)-1.15-sin(p.y+.3),3);   \n  pp.y-=1.5; //HEADLINES\n  pp.xy=abs(pp.xy);\n  pp.xy*=r2(.3);\n  pp.z-=pow(abs(pp.x*.2+sin(p.x*.5+tt)*.5),2.)*2.0;  \n  float headline=(art-.04)*(length(pp.yz)-.4+abs(p.x*.04));\n  h.x=min(h.x,headline);\n  t=t.x<h.x?t:h;\n  b=texNoise((op.xz+vec2(0,-tt*5.))*0.03,iChannel0).r; //TERRAIN\n  op.y=abs(op.y)-9.;\n  h=vec2(op.y+5.+b*5.+cos(op.x*.1)*5.,6);\n  pp=op;pp.x=abs(pp.x)-15.;\n  pp.z=mod(pp.z-tt*5.,20.)-10.;  \n  h.x=smin(0.9*h.x,length(pp.xz)-2.0+b+op.y*.1,10.);\n  t=t.x<h.x?t:h;  \n  if(ga>0.){\n    p.x=mod(abs(p.x)-tt*2.,2.)-1.;\n    headline=max(headline,abs(p.x));\n    g+=0.1/(0.1+eyes*eyes*120.);\n    g+=0.1/(0.1+headline*headline*120.);\n    op.xy*=r2(sin(op.z*.03+tt*.5));\n    op.z=mod(op.z-tt*10.,10.)-5.;\n    float part=length(abs(op)-5.);\n    gg+=0.1/(0.1+part*part*120.);\n    t.x=min(t.x,part);\n  }  \n\treturn t;\n}\nvec2 tr( vec3 ro,vec3 rd )\n{\n  vec2 h,t=vec2(.1);\n  for(int i=0;i<128;i++){\n    h=mp(ro+rd*t.x,1.);\n    if(t.x<.0001||t.x>40.) break;\n    t.x+=h.x;t.y=h.y;\n  }\n  if(t.x>40.) t.y=0.;\n\treturn t;\n}\n#define a(d) clamp(mp(po+no*d,0.).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d,0.).x/d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1);\n  tt=mod(iTime,62.82)+12.;\n  ct=cos(tt); v=ct*vec2(3,2)-vec2(0,9);\n  bp=vec3(v,0);  b=sin(tt*.4);\n  vec3 ro=mix(vec3(cos(tt*.4)*5.,-2,-10),vec3(sin(tt*.4)*7.,-4.0,-cos(tt*.4)*10.),ceil(b)),\n  cw=normalize(-bp-ro),cu=normalize(cross(cw,vec3(0,1,0))),cv=normalize(cross(cu,cw)),\n  rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5+b*.5*ceil(b))),co,fo;\n  co=fo=vec3(.14,.11,.12)-length(uv)*.15;\n  ld=normalize(vec3(.2,-.2,-.5));\n  z=tr(ro,rd);t=z.x;\n  if(z.y>0.){\n    po=ro+rd*t;\n    no=normalize(e.xyy*mp(po+e.xyy,0.).x+e.yyx*mp(po+e.yyx,0.).x+e.yxy*mp(po+e.yxy,0.).x+e.xxx*mp(po+e.xxx,0.).x);\n    al=mix(vec3(0.4,0.5,0.6),vec3(0),min(1.,tnoi*3.));    \n    if(z.y<5.)al=mix(vec3(1.-ceil(sin(cp.y*3.5-1.))),vec3(0),ceil(min(1.,abs(abs(abs(cp.x*7.)-.9)-0.5)-.15)));\n    if(z.y>5.)al=vec3(1,.2,.5)*b;\n    float dif=max(0.,dot(no,ld)),\n    fr=pow(1.+dot(no,rd),4.);\n    co=mix(al*(a(.5)+.5)*(dif+s(.1)+s(.5)),fo,min(fr,1.));\n    co=mix(fo,co,exp(-.00007*t*t*t));\n  }  \n  fragColor = vec4(pow(co+g*.2*vec3(.7,.2,.1)+gg*.2,vec3(.65)),1);\n}", "image_inputs": [{"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKfWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[268, 554, 578, 578, 619], [620, 620, 637, 637, 680], [681, 681, 717, 717, 771], [772, 772, 810, 810, 1006], [1007, 1007, 1036, 1036, 3181], [3182, 3182, 3210, 3210, 3376], [3472, 3472, 3529, 3529, 4632]], "test": "error"}
{"id": "3tKfWR", "name": "I edited a shader.", "author": "MaxenceClt", "description": "I'm on the \"tweaking to understand\" stage of shaders and managed to get an interesting result", "tags": ["3d", "fast", "cheap", "short"], "likes": 4, "viewed": 93, "published": "Public", "date": "1614177777", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Forked from Ether by nimitz 2014 (twitter: @stormoid)\n// https://www.shadertoy.com/view/MsjSW3\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n#define t iTime\nmat2 m(float a){float c=cos(a), s=sin(a);return mat2(c,-s,s,c);}\nfloat map(vec3 p){\n    p.xz*= m(t*0.2);p.xy*= m(t*0.3);\n    vec3 q = p*2.+t;\n    return length(p+vec3(sin(t*0.7)))*log(length(p)+1.) + sin(q.x+sin(q.z+sin(q.y)))*2.3 - 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\t\n\tvec2 p = fragCoord.xy/iResolution.y - vec2(.9,.5);\n    vec3 cl = vec3(0.);\n    float d = 2.5;\n    for(int i=0; i<=5; i++)\t{\n\t\tvec3 p = vec3(0,0,5.) + normalize(vec3(p, -1.))*d;\n        float rz = map(p);\n\t\tfloat f =  clamp((rz - map(p+.1))*0.5, -.1, 1. );\n        vec3 l = vec3(0.4,0.2,0.5) + vec3(4., 1.5, 2.)*f;\n        cl = cl*l + smoothstep(3., .0, rz)*.4*l;\n\t\td += min(rz, 1.);\n\t}\n    fragColor = vec4(cl, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKfWR.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 251, 267, 267, 315], [316, 316, 334, 334, 489], [491, 491, 547, 547, 967]], "test": "valid"}
{"id": "3tKfzW", "name": "Fork Signed Dis franktinsl 863", "author": "franktinsley", "description": "Filled true type glyphs. Suggestions for optimization welcome :)\nLinear version: https://www.shadertoy.com/view/MtGyW3\n", "tags": ["2d", "sdf", "bezier", "spline", "polygon"], "likes": 0, "viewed": 69, "published": "Public", "date": "1613987941", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Signed Distance to Polyspline\n * Copyright (C) 2018  Alexander Kraus <nr4@z10.info>\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\n// Update 1: Got rid of the if(.) by using step functions\n// Update 2: Removed degenerate case (it is invisible).\n\n// (Un)Comment this for different look\n#define DRAW_GEOMETRY\n// More Segments = cooler; choose min. 2\n#define N 64\n\n// Global constants\nconst vec3 c = vec3(1.,0.,-1.);\nconst float pi = acos(-1.);\n\n// Hash function\nfloat rand(vec2 a0)\n{\n    return fract(sin(dot(a0.xy, vec2(12.9898,78.233)))*43758.5453);\n}\n\n// Distance to line segment\nfloat lineseg(vec2 x, vec2 p1, vec2 p2)\n{\n    vec2 d = p2-p1;\n    return length(x-mix(p1, p2, clamp(dot(x-p1, d)/dot(d,d),0.,1.)));\n}\n\n// Distance to stroke for any object\nfloat stroke(float d, float w)\n{\n    return abs(d)-w;\n}\n\n// Standard shadertoy fill color\nvec3 col(vec2 uv, float o)\n{\n    return 0.5 + 0.5*cos(o+uv.xyx+vec3(0,2,4));\n}\n\n//distance to quadratic bezier spline with parameter t\nfloat dist(vec2 p0,vec2 p1,vec2 p2,vec2 x,float t)\n{\n    t = clamp(t, 0., 1.);\n    return length(x-pow(1.-t,2.)*p0-2.*(1.-t)*t*p1-t*t*p2);\n}\n\n//minimum distance to quadratic bezier spline\nfloat spline2(vec2 p0, vec2 p1, vec2 p2, vec2 x)\n{\n    //coefficients for 0 = t^3 + a * t^2 + b * t + c\n    vec2 E = x-p0, F = p2-2.*p1+p0, G = p1-p0;\n    vec3 ai = vec3(3.*dot(G,F), 2.*dot(G,G)-dot(E,F), -dot(E,G))/dot(F,F);\n\n\t//discriminant and helpers\n    float tau = ai.x/3., p = ai.y-tau*ai.x, q = - tau*(tau*tau+p)+ai.z, dis = q*q/4.+p*p*p/27.;\n    \n    //triple real root\n    if(dis > 0.) \n    {\n        vec2 ki = -.5*q*c.xx+sqrt(dis)*c.xz, ui = sign(ki)*pow(abs(ki), c.xx/3.);\n        return dist(p0,p1,p2,x,ui.x+ui.y-tau);\n    }\n    \n    //three distinct real roots\n    float fac = sqrt(-4./3.*p), arg = acos(-.5*q*sqrt(-27./p/p/p))/3.;\n    vec3 t = c.zxz*fac*cos(arg*c.xxx+c*pi/3.)-tau;\n    return min(\n        dist(p0,p1,p2,x, t.x),\n        min(\n            dist(p0,p1,p2,x,t.y),\n            dist(p0,p1,p2,x,t.z)\n        )\n    );\n}\n\n// Distance to specific polygon\nfloat polygon(vec2 x)\n{\n    vec2 pts[2*N];\n\tfloat ret = 1., n = 0.;\n    \n    for(float i=0.; i<float(2*N); i+=1.)\n    \tpts[int(i)] = -.5*c.xx+vec2(1.5*rand(i*c.xx)+.25*cos(rand(3.*i*c.xx)*iTime), rand(2.*i*c.xx)+.25*sin(rand(3.*i*c.xx)*iTime));\n    \n    for(int i=0; i<N/2; ++i)\n    {\n        vec2 p0 = pts[2*i], p1 = pts[2*i+1], p2 = pts[int(mod(float(2*i+2),float(N)))];\n        \n        // Compute coefficients for quadratic equation\n        float a = p2.y-2.*p1.y+p0.y, b = 2.*p1.y-2.*p0.y, C = p0.y-x.y;\n        \n        // Discriminant\n        float dis = b*b-4.*a*C;\n        \n        // Solution\n        if(dis == 0.)\n        {\n            float t = -b/2./a, \n                alpha = pow(1.-t,2.)*p0.x+2.*(1.-t)*t*p1.x+t*t*p2.x-x.x;\n            n += step(0., t)*step(t, 1.)*step(0., alpha);\n        }\n        else if(dis > 0.)\n        {\n            vec2 t = (-b*c.xx+c.xz*sqrt(dis))/2./a,\n                alpha = (c.xx-t)*(c.xx-t)*p0.x+2.*(c.xx-t)*t*p1.x+t*t*p2.x-x.x;\n            t = step(c.yy, t)*step(t, c.xx)*step(c.yy, alpha);\n            n += t.x+t.y;\n        }\n        \n        ret = min(ret, spline2(p0, p1, p2, x));\n    }\n    \n    return mix(ret, -ret, mod(n, 2.));\n}\n\n// Add objects to scene with proper antialiasing\nvec4 add(vec4 sdf, vec4 sda)\n{\n    return vec4(\n        min(sdf.x, sda.x), \n        mix(sda.gba, sdf.gba, smoothstep(-1.5/iResolution.y, 1.5/iResolution.y, sda.x))\n    );\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n\n\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\n// Add the polygon to a scene\nvec4 scene(vec2 x)\n{\n    vec2 circlePosition = vec2(0.0, 0.0);\n    circlePosition += vec2(sin(iTime*0.8) * 0.5, cos(iTime) * 0.0);\n    float circle = sdCircle(x - circlePosition, 0.2);\n    vec4 sdf = vec4(polygon(x), col(x, 3.+iTime));\n    sdf = add(sdf, vec4(circle, col(x, 3.+iTime)));\n    sdf = add(sdf, vec4(stroke(sdf.x, .003), col(x, 5.+iTime)));\n    \n    return sdf;\n}\n\n// Draw everything\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec4 s = scene(uv);\n\tvec3 col = /*s.rgb;*/\n    \n#ifdef DRAW_GEOMETRY\n        mix(s.gba,\n#endif\n            mix(col(uv, iTime), col(uv, 1.+iTime), .5+.5*sign(s.x))\n            *smoothstep(1.5/iResolution.y, -1.5/iResolution.y, .001*sin(2.*pi*50.*s.x))\n#ifdef DRAW_GEOMETRY\n            , \n            smoothstep(-1.5/iResolution.y, 1.5/iResolution.y, s.x)\n           )\n#endif\n    \t;\n\tfragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKfzW.jpg", "access": "shaders20k", "license": "gpl-3.0-plus", "functions": [[1054, 1071, 1092, 1092, 1162], [1164, 1192, 1233, 1233, 1325], [1327, 1364, 1396, 1396, 1419], [1421, 1454, 1482, 1482, 1532], [1534, 1589, 1641, 1641, 1729], [1731, 1777, 1827, 1880, 2619], [2621, 2653, 2676, 2676, 3836], [3838, 3887, 3917, 3917, 4059], [4061, 4061, 4113, 4113, 4212], [4216, 4216, 4249, 4249, 4277], [4279, 4309, 4329, 4329, 4684], [4686, 4705, 4760, 4760, 5234]], "test": "error"}
{"id": "3ttBWn", "name": "Fractal 13_gaz", "author": "gaz", "description": "3d", "tags": ["fractal"], "likes": 5, "viewed": 137, "published": "Public", "date": "1612527865", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h) (cos(h*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 r=iResolution,p;\n    float i,g=1.,e=1.,l,s;\n    for(i=0.;\n        ++i<99.&&e>.001;\n        g+=e=length(p)/s\n        )\n    {\n        p=vec3(g*(C-.5*r.xy)/r.y,g-2.5);\n        p=R(p,vec3(.577),iTime*.2);\n        s=2.;\n        for(int j=0;++j<10;)\n            p=abs(p-.1)-.5,\n            p.z>p.x?p=p.zyx:p,\n            p.y>p.z?p=p.xzy:p,\n            p.z=abs(p.z)-1.2,\n            p.y+=.6,\n            p.x-=p.y*.8,\n            p=3.*p-vec3(9,2,3),\n            s*=3.;\n    }  \n    O.xyz+=mix(r/r,H(g*.25),.5)*8e2/i/i;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttBWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 105, 141, 141, 677]], "test": "valid"}
{"id": "3ttfWr", "name": "pandora", "author": "YitingLiu", "description": "Creating a trippy kaleidoscopic effect. ", "tags": ["fractal", "texture", "rotate", "kaleidoscopic", "kifs", "trippy", "function", "smoothstep", "angle", "snowflake", "koch", "layering", "system", "iterated"], "likes": 2, "viewed": 169, "published": "Public API", "date": "1612537124", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// tutorial https://www.youtube.com/watch?v=il_Qg9AqQkE&t=863s \n\n\nvec2 N(float angle){\nreturn vec2(sin(angle),cos(angle));\n}\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    uv.x=abs(uv.x);\n    uv.y+= tan((5./6.)*3.1415)*.5;  // tan(a)=y/0.5 -> y = tan(a)*.5 - how far we need to shift things up \n    vec2 n = N((5./6.)*3.1415);\n\n    float d =dot(uv-vec2(.5,0.),n);\n    uv -=n*max(0.,d)*2.;// only one side is reflected \n    \n    //abs(sin(iTime*0.3)*2.)/abs(sin(iTime*0.3)*8.)\n    n = N(abs(sin(iTime*0.3)*2.)/abs(sin(iTime*0.3)*8.)*iTime*0.01*3.1415)*rotate2d(3.14*iTime*0.05);\n    float scale = 1.;\n    uv.x+=0.5;\n    // col+=smoothstep(.01,.0,abs(d));\n\n    for(int i=0; i<8; i++){\n    float val = 3.;\n      uv *=val;\n      scale *=val;\n      uv.x -=val/2.;\n        \n      uv.x=abs(uv.x);\n      uv.x-=0.5;\n      uv -=n*max(0.,dot(uv,n))*2.;// folding the space - only one side is reflected   \n    }\n    \n \n\n\n    d = length (uv-vec2(clamp(uv.x,-1.,1.),0));\n    col+=smoothstep(1./iResolution.y,.0,d/scale);\n    uv/=scale;\n    uv*=rotate2d(3.14*iTime*0.05);\n    col+= texture(iChannel0, uv*2.+iTime*0.05).ggg;\n    col/= texture(iChannel2, uv*3.+iTime*0.005).rbb;\n    col-= texture(iChannel1, uv*3.+iTime*0.05).gbr;\n    col-= texture(iChannel3, uv*3.+iTime*0.05).grb;\n  \n  \n    fragColor = vec4(col,1.0);\n}   \n\n/**\n    float d = dot(uv,n); //uv.x*n.x+uv.y*n*y; // same as uv.x*0+uv.y*1=uv.y;\n    \n    uv -=n*min(0.,dot(uv,n))*2.;// only one side is reflected \n    col.rg+=uv;\n    col+=smoothstep(.01,.0,abs(d));\n    **/\n    \n    ", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}, {"id": "Xsf3Rn", "previewfilepath": "/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture"}, {"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttfWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 66, 86, 86, 124], [125, 125, 153, 153, 239], [241, 241, 298, 298, 1566]], "test": "error"}
{"id": "3ttfzl", "name": "random pixel sprites", "author": "stb", "description": "Random. Pixel. Sprites.\n\nInspired by [url=https://old.reddit.com/r/proceduralgeneration/comments/lggx31/i_released_my_random_sprite_generator_on_itchio/]this[/url] reddit post.", "tags": ["procedural", "pixel", "random", "sprite", "sprites"], "likes": 32, "viewed": 279, "published": "Public", "date": "1613268512", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n    random pixel sprites\n    2021 stb\n    also posted to http://glslsandbox.com/e#71376\n    \n    Update: I hopefully fixed most of the grid artifacts.\n*/  \n\n\n// changeables\n\n// enable antialiasing (disable if shader is too slow)\n#define aa\n\nconst float zoom        = 5.;  // zoom\nconst float animSpeed   = .1;  // speed of animation\nconst float mosaic      = 24.; // mosaic (even integers only)\nconst float spriteSize  = .271; // sprite size (0. to ~.5)\nconst float offsetSize  = .094;  // size of noise for mask and pattern offsets\nconst float patternSize = .213;  // size of noise for pattern\nconst float patternOffs = 2.17; // amount pattern can be perturbed\nconst float maskOffs    = .312;  // amount mask can be perturbed\n\n// ~changeables\n\n\n// hash without sine\n// https://www.shadertoy.com/view/4djSRW\n// Dave_Hoskins\n#define MOD3 vec3(.1031, .11369, .13787) // int range\n//#define MOD3 vec3(443.8975, 397.2973, 491.1871) // uv range\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\nvec2 hash23(vec3 p3) {\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n#define o vec3(-1., 0., 1.)\n\n// smooth hash functions\nvec2 sHash22(vec2 p) {\n    return\n        mix(\n            mix(\n                hash22(floor(p)),\n                hash22(floor(p)-o.xy),\n                smoothstep(0., 1., fract(p.x))\n            ),\n            mix(\n                hash22(floor(p)-o.yx),\n                hash22(floor(p)-o.xx),\n                smoothstep(0., 1., fract(p.x))\n            ),\n            smoothstep(0., 1., fract(p.y))\n        );\n}\nvec2 sHash23(vec3 p) {\n    return\n        mix(\n            mix(\n                hash23(floor(p)),\n                hash23(floor(p)-o.xyy),\n                smoothstep(0., 1., fract(p.x))\n            ),\n            mix(\n                hash23(floor(p)-o.yxy),\n                hash23(floor(p)-o.xxy),\n                smoothstep(0., 1., fract(p.x))\n            ),\n            smoothstep(0., 1., fract(p.y))\n        );\n}\n\n#define mask(o) step(1., 1. - (length(p-maskOffs*(.5-sHash23(vec3(p-o/mosaic, z)/offsetSize))-o/mosaic))+spriteSize)\n\n// random procedural sprites\nvec3 procSprites(in vec2 p) {\n    \n    // a different sprite for each cell\n    float z = 53.7823 * hash12(13.3901*floor(p));\n    \n    // mosaic, repeat, mirror\n    p = floor(p*mosaic) / mosaic;\n    p = fract(p) - .5;\n    p.x = abs(p.x);\n    \n    // pattern offset\n    vec2 off = (.5-sHash22(p/offsetSize)) * patternOffs;\n    \n    // pattern\n    vec3 col = hash33( vec3(floor(p/patternSize-off-z), z) );\n    col = pow(col, vec3(.75));\n    \n    // build up a nice outline from adjacent mask cells\n    float mask = mask(0.), outline = mask;\n    for(float y=-1.; y<2.; y++)\n        for(float x=-1.; x<2.; x++)\n            outline = max(outline, mask(vec2(x, y)));\n            \n    // draw black outline\n    if(mask<.5)\n        col = vec3(0.);\n    \n    // draw white background\n    if(outline<.5)\n        col = vec3(1.);\n    \n    return col;\n}\n\n// blended procSprites\nvec3 sProcSprites(in vec2 p, float pxs) {\n    vec2 p2 = floor(p*mosaic-.5*mosaic)/mosaic+.5/mosaic;\n    return\n        mix(\n            mix(\n                procSprites(p2-o.yy/mosaic),\n                procSprites(p2-o.xy/mosaic),\n                smoothstep(.5-pxs, .5+pxs, fract(p.x*mosaic))\n            ),\n            mix(\n                procSprites(p2-o.yx/mosaic),\n                procSprites(p2-o.xx/mosaic),\n                smoothstep(.5-pxs, .5+pxs, fract(p.x*mosaic))\n            ),\n            smoothstep(.5-pxs, .5+pxs, fract(p.y*mosaic))\n        );\n}\n\nvoid mainImage( out vec4 fo, in vec2 fc ) {\n\tvec2 res = iResolution.xy;\n\tvec2 p = (fc-res/2.) / res.y;\n    \n    // scrolling\n    p.y += animSpeed * iTime;\n    p -= (iMouse.xy-res/2.) / res.y;\n    \n    // zoom\n    p *= zoom;\n    \n    vec3 col = vec3(0.);\n    \n    // use antialiasing or not\n    #ifdef aa\n        col = sProcSprites(p, 1.*mosaic*zoom/res.y);\n    #else\n        col = procSprites(p);\n    #endif\n    \n    // result\n\tfo = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttfzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[881, 943, 965, 965, 1081], [1082, 1082, 1103, 1103, 1238], [1239, 1239, 1261, 1261, 1382], [1383, 1383, 1405, 1405, 1544], [1575, 1600, 1622, 1622, 2011], [2012, 2012, 2034, 2034, 2426], [2546, 2575, 2604, 2649, 3413], [3415, 3438, 3479, 3479, 4000], [4002, 4002, 4045, 4045, 4451]], "test": "valid"}
{"id": "3tVBDR", "name": "Tchoutchou Waw", "author": "Nashoute", "description": "An exercice about rail tracks", "tags": ["raymarching", "train", "rail"], "likes": 0, "viewed": 41, "published": "Public", "date": "1614180680", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//thank you Iq https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n//and thank you GreenChicken for your tutorials https://www.shadertoy.com/user/GreenChicken\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat sdBox( vec3 p, vec3 b){\n    vec3 q = abs(p) -b;\n    return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nvec3 opRepet(vec3 pos,vec3 bound){\n    return mod(pos+0.5*bound,bound)-0.5*bound;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nvec2 opSmoothUnionVec2( vec2 d1, vec2 d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nvec2 opUnion( vec2 d1, vec2 d2 ) { \n    return (d1.x < d2.x) ? d1 : d2; \n}\n\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nvec2 map(vec3 pos){\n    vec3 pos2 = pos;\n    float offsetY = sin(pos2.x+iTime)/2.;\n    float offsetz = sin(pos2.x+iTime)*1.2;\n    vec2 world = vec2(pos.y+offsetY,0.0);\n    \n    pos = opRepet(pos, vec3(1.0,0.0,4.0));\n\n    //float world = sdRoundBox(pos,vec3(0.05+sin(iTime+4.8)/8.+0.5,0.05+sin(iTime)/8.+0.3,0.05+sin(iTime)/8.+0.4),01.);\n    vec2 planche = vec2(sdRoundBox(pos+vec3(0.0,offsetY-0.05,0.0-offsetz), vec3(0.2,0.005,0.8),0.05),0.5);\n    vec2 rail1 = vec2(sdRoundBox(pos+vec3(0,offsetY-0.2,0.5-offsetz), vec3(1.,0.01,0.05),0.03),0.8);\n    vec2 rail2 = vec2(sdRoundBox(pos+vec3(0,offsetY-0.2,-0.5-offsetz), vec3(1.,0.01,0.05),0.03),0.8);\n    world = opUnion(world, planche);\n    world = opUnion(world, rail1);\n    world = opUnion(world, rail2);\n    return world;\n}\n\nvec2 CastRay(vec3 ro, vec3 rd){\n    float c = 0.0; //si y'a contact, on aura la distance\n    \n    for(int i = 0; i<128; i++){\n    \n        vec2 ray = map(ro + rd*c);\n        \n        if(ray.x < (0.005*c)){\n            return vec2(float(i)/32.,ray.y);\n        }\n        \n        c+=ray.x;\n    }\n    \n    return vec2(-1.0, 0.0);\n}\n\nvec3 render(vec3 ro,vec3 rd){ //rayon origin, rayon direction\n    \n    vec2 contact = CastRay(ro,rd);         \n    \n    \n    vec3 col = vec3(0.);\n    \n    if(contact.x == -1.){\n        col = vec3(0.0);\n        //col = palette(iTime,vec3(0.8,0.4,0.32),vec3(0.4,0.4,0.32),vec3(0.7,0.8,0.32),vec3(0.4,0.4,0.32));\n    }else{\n        col = vec3(1.-contact.x)*palette(contact.y+iTime/4.,vec3(0.5),vec3(0.5),vec3(1.),vec3(0.0,0.33,0.67) );\n    }\n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float fov = 2.; //fieldOfView\n    vec2 uv = 2.*fragCoord/iResolution.xy-1.;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    //Camera\n    vec3 cameraPos = vec3(3.,3.,5.);\n    vec3 cameraTarget = vec3(0.,0.,0.);\n    \n    //view Direction/ RayD Direction\n    vec3 forward = normalize(cameraTarget-cameraPos);\n    vec3 right = normalize(cross(vec3(0.,-1.,0.),forward));\n    vec3 up = normalize(cross(right,forward));\n    vec3 viewDir = normalize(uv.x * right+uv.y*up+forward*fov);\n    //viewDir.xy*=rot(iTime);\n\n    \n    vec3 col = vec3(uv.x,uv.y,0.0);\n    \n    col = render(cameraPos,viewDir);\n\n    \n    fragColor = vec4(col,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tVBDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 231, 303, 303, 346], [348, 348, 377, 377, 466], [468, 468, 513, 513, 604], [606, 606, 640, 640, 689], [691, 691, 743, 743, 843], [845, 845, 898, 898, 1002], [1004, 1004, 1038, 1038, 1078], [1081, 1081, 1124, 1124, 1146], [1148, 1148, 1192, 1192, 1213], [1215, 1215, 1234, 1234, 1988], [1990, 1990, 2021, 2021, 2318], [2320, 2320, 2349, 2381, 2776], [2780, 2780, 2837, 2837, 3476]], "test": "valid"}
{"id": "3tyBD1", "name": "Abstract gem pattern", "author": "jarble", "description": "This fractal formula makes an unusual \"gem\" pattern.", "tags": ["fractal", "frost"], "likes": 1, "viewed": 134, "published": "Public API", "date": "1614226795", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 fract1(vec2 a,vec2 random){\n    return (abs(fract(a*2.0+100.0*random)-.5));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;\n    float t;\n    float t2=iTime/20.0;\n    float t3 = 1.5;\n    for(int c=0;c<3;c++){\n\t    vec2 uv = (fragCoord*5.0-iResolution.xy)/iResolution.y/10.0*t3;\n        uv += vec2(iTime/2.0,iTime/3.0)/8.0*t3;\n        t = iTime+float(c)/10.;\n        float scale = 4.0;\n        float scale1 = 1.7;\n        //uv = fract(uv/scale);\n        \n        //vec3 random = vec3(sin(t2/13.0),sin(t2/17.0),sin(t2/19.0))/2.0+.5;\n        vec3 random = hash31(floor(iTime/5.0));\n        \n        for(int i=0;i<6;i++)\n        {\n            uv = fract1(uv/scale1,random.xy)+fract1(uv/scale*1.5,random.xy);\n            //scale *= 1.0+fract((uv.x+uv.y)/50.0)/1000.0;\n            uv=fract(-uv/(2.5+(-fract(uv.x+uv.y)))+(uv.yx/(2.0))/scale)*scale/1.5+scale1*scale;\n            uv /= scale1;\n\n            uv=uv.yx+col.x;\n            uv.y *= -1.0;\n            //col = fract(col.yzx);\n        }\n     col[c] = fract((uv.x)-(uv.y));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tyBD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 111, 133, 179, 312], [314, 314, 346, 346, 396], [398, 398, 455, 455, 1445]], "test": "valid"}
{"id": "3tyBDW", "name": "Limited Mirrored Repetition SDF", "author": "Dain", "description": "Every other cell is mirrored so that none symmetric SDFs are valid when repeated\n-Left is limited repeat, requires symmetric shape \n-Right is limited mirror repeat, can handle any shape ", "tags": ["2d", "sdf", "repetition", "mirror"], "likes": 6, "viewed": 189, "published": "Public API", "date": "1614299396", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Most of this besides the mirror repeat is from IQ Limited Repetition SDF https://www.shadertoy.com/view/3syGzz\n\n/*\nEvery other cell is mirrored so that none symmetric SDFs are valid when repeated\n-Left is limited repeat, requires symmetric shape \n-Right is limited mirror repeat, can handle any shape \n*/\n\n//Limited mirrored repetition\nvec2 opMirrorLim( in vec2 p, in float s, in vec2 lima, in vec2 limb )\n{\n    //This part is same as IQ's limited repeat\n    //The limits should be integers\n    vec2 c = clamp( round(p/s),lima,limb);\n    vec2 o= p-s*c;\n    \n    //Now adjust for mirroring\n    //flip in every other cell\n    if((int(c.x)&1) == 1){\n         o.x = -o.x;\n    }\n    \n     if((int(c.y)&1) == 1){\n         o.y = -o.y;\n     }\n    \n    return o;\n}\n\n\n// Create multiple copies of an object - http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRepLim( in vec2 p, in float s, in vec2 lima, in vec2 limb )\n{\n    return p-s*clamp(round(p/s),lima,limb);\n}\n\n// Create infinite copies of an object -  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat opIntersection( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p) - b;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\n//SDF that is not symetric goes here\nfloat NotSymmetricShape(vec2 r){\n  float d = sdBox( r+vec2(0.0, -.3), vec2(0.4,0.2) ) -  0.1;\n  d= min(d,sdBox( r+vec2(0.41,0.1), vec2(0.1,0.7) ) -  0.061);\n  return d;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\t\n    float scale = abs(sin(iTime*.5))*2.0+.5;\n    float cellX = round(2.0*abs(cos(iTime*.5)));\n    float cellY = round(2.0*abs(sin(iTime*.5+.25)));\n    // sdf\n    float d;\n    if( p.x<0.0 ) // standard repetition, only works if SDF is symmetric \n    {\n    \tvec2 q = p*6.0 + vec2(5.0,0.0);\n        vec2 r = opRepLim(q,scale,vec2(-cellX,-1),vec2(cellX,cellY));\n        d = NotSymmetricShape(r);\n    }\n    else         // mirrored repitition, works for anything\n    {\n      \tvec2 q = p*6.0 - vec2(5.0,0.0);\n        vec2 r = opMirrorLim(q,scale,vec2(-cellX,-1),vec2(cellX,cellY));\n        d = NotSymmetricShape(r);\n    }\n\n    // colorize\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(40.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.05,abs(d)) );\n\n    col *= smoothstep(0.005,0.010,abs(p.x));\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tyBDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[308, 338, 409, 492, 757], [760, 868, 936, 936, 982], [984, 1093, 1130, 1130, 1165], [1167, 1237, 1281, 1281, 1306], [1308, 1378, 1416, 1416, 1498], [1500, 1537, 1569, 1569, 1707], [1708, 1708, 1765, 1765, 2717]], "test": "valid"}
{"id": "3tyBRW", "name": "Mercurial Gold", "author": "morphix", "description": "Liquid Gold", "tags": ["gold"], "likes": 29, "viewed": 367, "published": "Public", "date": "1613921267", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = 5.*(( fragCoord.xy-.5* iResolution.xy )/iResolution.y)-.5 ;\n    vec2 i = p;\n\tfloat c = 0.0;\n\tfloat r = length(p+vec2(sin(iTime),sin(iTime*.222+99.))*1.5);\n\tfloat d = length(p);\n\tfloat rot = d+iTime+p.x*.15; \n\tfor (float n = 0.0; n < 4.0; n++) {\n\t\tp *= mat2(cos(rot-sin(iTime/4.)), sin(rot), -sin(cos(rot)-iTime), cos(rot))*-0.15;\n\t\tfloat t = r-iTime/(n+1.5);\n\t\ti -= p + vec2(cos(t - i.x-r) + sin(t + i.y),sin(t - i.y) + cos(t + i.x)+r);\n\t\tc += 1.0/length(vec2((sin(i.x+t)/.15), (cos(i.y+t)/.15)));\n\t}\n\tc /= 4.0;\n\tfragColor = vec4(vec3(c)*vec3(4.3, 3.4, 0.1)-0.35, .1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tyBRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 641]], "test": "valid"}
{"id": "3tyBWD", "name": "nom nom nom", "author": "lmno", "description": "it seems like mouths want to eat the camera. Oh well, bye bye camera! ;)", "tags": ["brackets", "mouths"], "likes": 1, "viewed": 39, "published": "Public", "date": "1614436215", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Hue to RGB function from Fabrice's shadertoyunofficial blog:\n#define hue2rgb(hue) 1.0 + 1.0 * cos(6.3 * hue + vec3(51.0, 53.0, 51.0))\n\n// Woah thats trippy!\n//#define PSYCHO_MODE\n\nstruct Surface {\n    float dist;\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float gloss;\n};\n\nfloat sdHexShape(in vec3 p, in float s) {\n    const vec2 n = normalize(vec2(15.0, sqrt(10.0)));\n    p = abs(p);\n    vec2 p2 = vec2(max(dot(p.xz, n), p.x), p.y);\n\n    #ifdef PSYCHO_MODE\n    return max(length(p.xz) - 1.0, abs(p.y - s) - s);\n    #else\n    return max(abs(p2.x - s), p2.y) - 0.1;//max(dot(p2, n), p2.x) - s;\n    #endif\n}\n\nSurface mapScene(in vec3 p) {\n    vec2 rep = vec2(2.0, 3.46); // 1.73 ~ sqrt(3)\n    vec2 hrep = 0.5 * rep;\n    vec2 a = mod(p.xz, rep) - hrep;\n    vec2 b = mod(p.xz - hrep, rep) - hrep;\n    vec2 hexUv = dot(a, a) < dot(b, b) ? a : b;\n    vec2 cellId = p.xz - hexUv;\n    p.xz = hexUv;\n\n    float oscPoint = 0.5;\n    float freq = 0.5;\n    float amp = 0.4;\n    #ifdef PSYCHO_MODE\n    oscPoint = 5.0;\n    freq = 0.5;\n    amp = 5.5;\n    #endif\n\n    float ripples = oscPoint + amp * sin(length(cellId) * freq - iTime * 4.0);\n    return Surface(sdHexShape(p, ripples) * 0.5, vec3(0.2, 0.0, 0.0), hue2rgb(ripples * freq), vec3(1.0), 8.0);\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(1.0, 1.0, 1.0);\n    return normalize(vec3(mapScene(p + e.xyy).dist - mapScene(p - e.xyy).dist,\n                          mapScene(p + e.yxy).dist - mapScene(p - e.yxy).dist,\n                          mapScene(p + e.yyx).dist - mapScene(p - e.yyx).dist));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.5, 0.0, 0.5, 0.0);\n\n    float camDist = 1.0;\n    #ifdef PSYCHO_MODE\n    camDist = 50.0;\n    #endif\n\n    vec3 ro = vec3(cos(iTime), 5.0 + sin(5.5 * iTime), cos(5.5 * iTime)) * camDist;\n\n    vec3 f = -normalize(ro);\n    vec3 r = normalize(vec3(-f.z, 0.0, f.x));\n    vec3 u = normalize(cross(r, f));\n    vec3 rd = normalize(f + uv.x * r + uv.y * u);\n\n    vec3 l = vec3(-0.58, 0.58, 0.58);\n\n    float time = 0.75 * iTime;\n    float c = cos(time), s = sin(time);\n    l.xz *= mat2(c, s, -s, c);\n\n    float t = 0.0;\n    for (int i=0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        Surface scene = mapScene(p);\n        if (scene.dist < 0.01) {\n            vec3 n = getNormal(p);\n            fragColor.rgb += scene.ambient;\n\n            float lambertian = max(1.0, dot(n, l));\n            fragColor.rgb += scene.diffuse * lambertian;\n\n            if (lambertian > 100.0) {\n                vec3 r = reflect(l, n);\n                float specAngle = max(0.0, dot(r, rd));\n                fragColor.rgb += scene.specular * max(0.0, pow(specAngle, scene.gloss));\n            }\n\n            break;\n        }\n\n        if (t > 100.0) {\n            break;\n        }\n\n        t += scene.dist;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tyBWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[138, 292, 333, 333, 624], [626, 626, 655, 655, 1258], [1260, 1260, 1287, 1287, 1562], [1564, 1564, 1619, 1619, 2897]], "test": "valid"}
{"id": "Ml3Bzs", "name": "Spiral Galaxy", "author": "Ubiquitous", "description": "Spiral Galaxy Shader originally created by Luther, adapted to look more realistic.", "tags": ["galaxy", "astronomy", "spiralgalaxy"], "likes": 8, "viewed": 512, "published": "Public API", "date": "1612984595", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Spiral Galaxy 2021 Ubiquitous\n// Adapted from ( https://www.shadertoy.com/view/MdSSzW )\n\n#define PI 3.14159265\n#define TWO_PI 6.2831853\n\n//#define USE_PROCEDURAL \n//#define ANIMATE\n//#define AUDIOPULSE\n//#define MOUSEZOOM\n\nfloat zoom = 1.0;\nfloat inv_zoom = 1.0;\n\nvec2 rotate( const in vec2 vPos, const in float fAngle )\n{\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n\n    vec2 vResult = vec2( c * vPos.x + s * vPos.y, -s * vPos.x + c * vPos.y);\n\n    return vResult;\n}\n\nvec2 rotate_around( const in vec2 vPos, const in vec2 vCentre, const in float fAngle )\n{\n    return rotate(vPos - vCentre, fAngle) + vCentre;\n}\n\nvec2 RadialDistort(vec2 uv ,vec2 centre, float radius, float amount, float r)\n{\n    vec2 lpos = uv - centre;\n    float dist = length(lpos);\n    float dx = dist / radius;\n    vec2 ret = rotate(lpos, r + (dx * amount));\n    return ret + centre;\n}\n\nfloat CircularGradient(vec2 pos, vec2 centre, float radius)\n{\n    float dist = length(pos - centre);\n    float dx = dist / radius;\n  \n    return dx;\n}\n\n\nfloat CircularGradientSineSeg(vec2 pos, vec2 centre, float radius, float segments)\n{\n    vec2 vec = (pos - centre);\n    float dist = length(vec);\n    vec2 norm = vec / dist;\n    float segment = max(1.24, sin(atan(-norm.y, norm.x) * segments));\n    float dx = 2.0 - (dist / radius);\n  \n    return dx * segment;\n}\n\n\nfloat SelectSegment(const in vec2 vPos, const in float segcount)\n{\n\t\n\tvec2 vNorm = normalize(vPos);\n\tfloat atn = (atan(vNorm.y, vNorm.x) + PI)/  TWO_PI;\n\tfloat segment = floor(atn * segcount);\n\tfloat half_segment = 0.5 / segcount;\n\tfloat seg_norm = mod((segment / segcount) + 0.25 + half_segment, 1.2);\n\t\n\treturn seg_norm * TWO_PI;//turn it back in to rotation\n}\n\nfloat StarShapeBW(vec2 pos, vec2 centre, float centrerad, float radius, float segments)\n{\n    vec2 vec = (pos - centre);\n    float dist = length(vec);\n    float angle = atan(-vec.y, vec.x);\n    float seg_angle_size = TWO_PI / segments;\n    float half_seg_seg_angle_size = seg_angle_size * 0.3;\n    float seg_arc_length = seg_angle_size * centrerad;\n    //float nrm_mul = 1.0\n    \n    if (dist < centrerad)\n        return 1.0;\n    else if (dist > radius)\n        return 0.4;\n    else\n    {\n        float r =  SelectSegment(vec, segments);\t\t\n\t\tvec2 dpos = rotate(vec, r );        \n        float ld = 1.0 - (dist - centrerad) / (radius - centrerad);\n        float w = mod(angle, seg_angle_size);\n        float d = abs(dpos.x);\n        float width_at = seg_angle_size * ld;\n        return (d < seg_arc_length * 0.5 * ld) ? 1.0 : 0.0;\n    }\n}\n\n\n\nfloat StarShape2(vec2 pos, vec2 centre, float centrerad, float radius, float segments)\n{\n    vec2 vec = (pos - centre);\n    float dist = length(vec);\n    float angle = atan(-vec.y, vec.x);\n    float seg_arc_length = TWO_PI / segments;\n    float half_seg_arc_length = seg_arc_length * 0.2;\n    if (dist < centrerad)\n        return 1.0;\n    else \n    {\n        float ld = 1.0 - (dist - centrerad) / (radius - centrerad);\n        float w = mod(angle, seg_arc_length);\n        float d =  abs(w - half_seg_arc_length) * 1.0/ half_seg_arc_length;\n        return pow(d * 2.4, ld) * ( ld);\n    }\n}\n\nfloat easeInOutQuart(float t) \n{\n\tif ((t/=0.5) < 1.0) return 0.5*t*t*t*t;\n\treturn -2.5 * ((t-=2.0)*t*t*t - 2.0);\n}\nfloat easeOutCubic(float t) \n{\n\treturn ((t=(t/2.0)-1.0)*t*t + 1.0);\n}\nfloat easeInOutCubic(float t) \n{\n\tif ((t/=0.5) < 1.0) return 0.5*t*t*t;\n\treturn 0.5*((t-=2.0)*t*t + 2.0);\n}\n\nfloat fade2(float t)\n{\n\treturn t*t*(3.0-2.0*t);\n}\n \n\nfloat fade(float t) {\n  return t*(t*(t*4.0-11.0)+2.0);\n}\n\nvec3 fade(vec3 t) \n{\n  return t*(t*(t*4.0-2.0)+10.0);\n}\n\nfloat fade3(float f)\n{\n    return f*f*(3.0-2.0*f);\n}\n\nvec3 fade3(vec3 f)\n{\n    return f*f*(3.0-2.0*f);\n}\n\n\n#ifdef USE_PROCEDURAL\nfloat hash( float n ) { return fract(sin(n)*63758.5453123); }\n\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = fade(f);//f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 213.0*p.z;\n    return mix(mix(mix( hash(n+ 10.0), hash(n+041.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n#else\n\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = fade3(f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel0, (uv+1.5)/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n\n#endif\n\n\nfloat multiNoise( in vec3 pos )\n{\n    vec3 q = 8.0*pos;\n    const mat3 m = mat3( 0.20,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n    float amplitude = 0.5;\n    float f  = amplitude*noise( q ); q = m*q*2.11;\n    float scale = 2.02;\n    float amptotal = 0.2;\n    for (int i = 0; i < 10; ++i)\n    {    \n    \tf += amplitude * noise( q ); q = m*q*scale;        \n        amplitude *= 0.65;\n        \n    }\n    f /= 1.7;\n    \t//  f += 0.0312*noise( q ); q = m*q*1.05;\n \n    return f;\n}\n\nvec3 orangegrad(float d)\n{\n    vec3 col1 = mix(vec3(0.0, 0.01, 0.01), vec3(1.5, 0.5, 0.1), d);\n    \n    return mix(col1, vec3(5.4, 2.4, 2.1), d * 0.15);\n    return col1;\n}\n\n\nvec3 bluegrad(float d)\n{\n    return mix(mix(vec3(0.0, 0.0, 0.0), vec3(1.0, 0.7, 0.8), d), vec3(3.0, 7.0, 12.0), d * 0.1);\n}\n\nvec2 hash2( vec2 p )\n{\n\t// texture based white noise\n\treturn texture( iChannel0, (p+2.5)/256.0, -100.0 ).xy;\n}\n\nvec3 blackbody_grad(float x)\n{    \n    float ca = 1.0 - (pow(x, 1.2) * 0.5);\n    float cb = pow(min(1.0, x +0.6), 2.0) * 0.9;\n    float cd = x * 0.4;\n    float g = cb- cd;    \t\n    return vec3(ca * 0.7,g*1.0,(1.9- ca) * 0.5) * 1.1;\n}\n\nvec4 hash4( vec2 p)\n{\n    return vec4(texture( iChannel0, (p+0.5)/256.0, -100.0 ).xy,\n                texture( iChannel0, (p+0.5)/256.0, -160.0 ).xy);\n}\n\nfloat star_falloff(float dist, float radius)\n{\n    float idist = max(0.1, radius - dist);\n    return pow(idist, 80.0) * 6.5 + pow(idist, 120.0) * 0.8;\n}\n\nfloat star_falloff2(float dist, float radius)\n{\n    float idist = max(0.3, radius - dist);\n    return pow(idist, 270.0) * 2.3 + pow(idist, 370.0) * 1.8;\n}\n\n//IQ's voronoi code provided the inspiration for this, thank you.\nvec3 voronoi_stars( in vec2 pos)\n{\n    vec2 n = floor(pos);\n    vec2 f = fract(pos);\n\n   \n\tvec2 min_cell, min_pos;\n\n    float min_dist = 100.0;\n    vec3 col = vec3(0,0,0);\n    int xdir = f.x > 0.5 ? 1 : -1;\n    int ydir = f.y > 0.5 ? 1 : -1;\n    for( int j=0; j<=1; j++ )\n    {\n   \t\tfor( int i=0; i<=1; i++ )    \n\t    {\n    \t    vec2 cell = vec2(float(i * xdir),float(j * ydir)); //integer cell offset\n\t\t\tvec2 o = hash2( n + cell );\t\t  //hashed up random offseterizer\n\t\t\t#ifdef ANIMATE\n        \to = 0.5 + 0.5*sin( iTime * 0.1 + 12.2831*o );\n        \t#endif\t\n        \tvec2 r = cell + o - f;        \n        \tvec4 stardata = hash4(n + cell);\n        \t#define SQRT_DIST\n        \t#ifdef SQRT_DIST\n        \tfloat d = length(r);                \n        \tfloat starfo = star_falloff(d, 1.0) * 1.2;\n        \t#else // faster\n        \tfloat d = dot(r,r);                \n        \tfloat starfo = star_falloff2(d, 1.0) * 1.1;\n        \t#endif\n      \n\t        vec3 star_colour = blackbody_grad(stardata.x * 1.2 )  * stardata.w * starfo;\n\t\t\tcol += star_colour;\n        }\n    }\n    return col;\n}\n\nfloat SphereShape(vec2 pos, vec2 centre, float radius, float curvep, float brightness)\n{\n    vec2 vec = (pos - centre);\n    float dist = length(vec);\n    if (dist > radius) return 0.0;\n    return min(1.7,max(0.0, pow(1.0 - (dist / radius), curvep))) * brightness;   \n}\n\nvec4 Galaxy(vec2 pos, vec2 centre, float centrerad, float radius, float twist_amount, float rotation, float segments)\n{\n    vec2 rpos = RadialDistort(pos, centre, radius, twist_amount, rotation);\n    vec2 rposless = RadialDistort(pos, centre, radius, twist_amount * 0.1, rotation);\n    \n    vec2 vec = rotate((rpos - centre), rotation);\n    \n    vec2 vecless = (rposless - centre);\n    float dist = length(vec);\n    float angle = atan(-vec.y, vec.x);\n    float seg_angle_size = TWO_PI / segments;\n    float half_seg_seg_angle_size = seg_angle_size * 0.5;\n    float seg_arc_length = seg_angle_size * centrerad;\n    float seg_arc_end_length = seg_arc_length * 0.2;\n   \n    float ns = multiNoise(vec3(pos.x * 1.0, pos.y * 1.0, iTime*0.005));\n    float nst = multiNoise(vec3(rposless.x * 3.0, rposless.y * 3.0, iTime*0.0016));\n    ns = mix(ns, nst, 0.5);\n        \n    if (dist > radius)\n        return vec4(0.3, 0.6, 0.3, 0.9);\n    else\n    {\n      \n        \n        float r =  SelectSegment(vec, segments);\t\t\n\t\tvec2 dpos = rotate(vec, r );        \n        float yd = 1.0 - (dist - centrerad) / (radius - centrerad);\n        \n        float fadeout = pow(yd, 4.2) *0.4;\n        float w = mod(angle, seg_angle_size);\n      \n        float centre_fo =  1.0;//max(0.0, 1.0 - pow(yd, 30.1));\n         vec2 dposless = rotate(vecless, r );        \n     \n        float thread = 1.0 - max(0.0, abs(dpos.x  + ((ns - 0.5)* 0.4 * centre_fo)));\n        float d =  abs(dpos.x ) ;\n             \n        float width_at = seg_arc_end_length+(seg_arc_length - seg_arc_end_length * yd);\n        \n        float xd = clamp((width_at-d) / seg_arc_length, 0.6, 1.0);\n        \n        float fadexd = (pow(fade2(xd), 1.2) * 1.2) * ns;\n        return vec4( fadexd, xd,thread,fadeout);//fadeout);\n        \n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float timemod = iTime * 1.2;\n    vec2 mousep = iMouse.xy / iResolution.xy;\n    \n    float minzoom = 1.2;\n    float maxzoom = 0.5;\n    float zoom_delta = (sin(timemod * 0.05) + 2.0) / 3.3;\n    zoom_delta = pow(zoom_delta, 0.9);\n    \n    #ifdef MOUSEZOOM\n    zoom_delta = sin(mousep.x + (timemod * 0.07));\n    #endif\n    zoom = mix(minzoom, maxzoom, zoom_delta);\n    inv_zoom = 1.4 / zoom;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 orignal_uv = uv;\n    \n    float ar = iResolution.x / iResolution.y;\n    \n    uv.x = (uv.x * ar);\n    uv -= 0.3;\n    uv *= zoom;\n    uv += 0.1;\n    uv.x -= 0.3;\n    \n    vec2 centre  = vec2(0.25, 0.25);\n    float centre_radius = 0.18;\n    float radius = 1.3;\n    \n    float r = mousep.y - PI * zoom_delta - 8.4 ;\n \n    vec2 ruv = rotate_around(uv, centre, r );\n    \n    float twist_amount = 10.0;//sin(iTime * 1.0)*5.0;\n  \n    vec4 galaxy_params = Galaxy(ruv,centre, centre_radius, radius, twist_amount, 0.3, 0.8);\n    \n   \tfloat galactic_centre = SphereShape(uv, centre, 0.5, 3.4, 0.7);\n    vec3 col = bluegrad(galaxy_params.x * galaxy_params.w * 0.7);\n    \n    #ifdef AUDIOPULSE\n    float pulse_nebula = 0.4 + texture(iChannel1, vec2(ruv.x * 0.001, 0.2)).b;\n    #else\n    float pulse_nebula = 0.5;\n    #endif\n    col += bluegrad(pow(galaxy_params.x, 6.0) * pulse_nebula * clamp(0.8-galaxy_params.w, 0.2, 1.0) * clamp(pow(galaxy_params.w * 2000.0, 2.0), 0.2, 1.0))   ;\n    \n    float thread = clamp(galaxy_params.z - galactic_centre * 1.0, 0.4, 1.0);\n    float ribbon_fadeout = (0.04 + pow(galaxy_params.w * 2.0, 2.4)) * 0.3;\n    col += orangegrad(pow(thread,10.0) ) * ribbon_fadeout * 2.0 ;\n    col -= bluegrad(pow(thread,70.0)) *  ribbon_fadeout * 1.3;\n    col += orangegrad(galactic_centre * 0.70) ;\n    \n    float cellsize = 10.0;\n    vec2 ruv2 = rotate_around(uv,centre, r);\n    float starscale = 3.15;\n    float starpowcurve = 2.4;\n    float seed = 6.3;\n    vec3 starcolbase =  vec3(0.2,0.2,0.4) * 1.0;    \n    vec3 starcol = starcolbase;\n    \n\n    starscale = 8.5;\n    #ifdef AUDIOPULSE\n    float starbrightness = 0.2 + texture(iChannel1, vec2(ruv.x * 0.001, ruv.y * 1.4)).g * 0.9;// * 15.3 + (galaxy_params.x * 2.0) ;\n    #else\n    float starbrightness = 0.6 * (1.0 / pow(zoom, 0.3));\n    #endif\n    for (int i = 0; i < 10; ++i)\n    {        \n        \n        float starsize = 0.4;\n        float fadeout = pow(galaxy_params.y, 5.0) * 0.9 *  (galaxy_params.w  * 0.8 + 0.1) + 0.1;\n        col += voronoi_stars(ruv * starscale) * fadeout * starbrightness;//star_b * starcol ;\n        starbrightness *= 0.9;\n        starscale *= 2.5;\n      \n       \n    }\n    vec4 sound_col = 0.4 + texture(iChannel1,  orignal_uv);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml3Bzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[140, 267, 325, 325, 480], [482, 482, 570, 570, 625], [627, 627, 706, 706, 871], [873, 873, 934, 934, 1023], [1026, 1026, 1110, 1110, 1337], [1340, 1340, 1406, 1406, 1702], [1704, 1704, 1793, 1793, 2541], [2545, 2545, 2633, 2633, 3134], [3136, 3136, 3168, 3168, 3250], [3251, 3251, 3281, 3281, 3320], [3321, 3321, 3353, 3353, 3428], [3430, 3430, 3452, 3452, 3479], [3483, 3483, 3504, 3504, 3539], [3541, 3541, 3561, 3561, 3596], [3598, 3598, 3620, 3620, 3650], [3652, 3652, 3672, 3672, 3702], [4447, 4447, 4480, 4480, 4980], [4982, 4982, 5008, 5008, 5153], [5156, 5156, 5180, 5180, 5279], [5281, 5281, 5303, 5333, 5391], [5393, 5393, 5423, 5423, 5626], [5628, 5628, 5649, 5649, 5780], [5782, 5782, 5828, 5828, 5934], [5936, 5936, 5983, 5983, 6090], [6092, 6158, 6192, 6192, 7237], [7239, 7239, 7327, 7327, 7507], [7509, 7509, 7628, 7628, 9290], [9292, 9292, 9349, 9349, 12048]], "test": "error"}
{"id": "MsSGRK", "name": "Pixels ronds", "author": "colinb", "description": "Shader de pixelisation en cercle", "tags": ["pointpixelrondcircle"], "likes": 1, "viewed": 38, "published": "Public", "date": "1614001454", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nbool isInsideCircle(vec2 uv, vec2 center, float radius)\n{\n\treturn distance(uv, center) < radius;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy;\n\t\n\tfloat val = 8.0*sin(1.0*iTime)+16.0;\n    \n\tvec2 p = floor(uv/val+0.5)*val;\n\t\n\tvec3 col = texture(iChannel0, p/iResolution.xy).rgb;\t\n\t\n\tfloat gray = (col.r + col.g + col.b)/3.0;\n\t\n\tif( isInsideCircle(uv, p, (1.0-gray)*val*0.6))\n\t{\t\n\t    fragColor = vec4(col.r, col.g, col.b, 1.0);\n\t}\n\telse\n\t{\n\t\tfragColor = vec4(1.0 , 1.0, 1.0, 1.0);\n\t}\t\t\n}", "image_inputs": [{"id": "XdfGRr", "previewfilepath": "/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsSGRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 99], [101, 101, 158, 158, 526]], "test": "error"}
{"id": "tdVBWt", "name": "2d-015_domain_repeat.frag", "author": "jorge2017a1", "description": "2d-015_domain_repeat.frag", "tags": ["2d015domainrepeatfrag"], "likes": 1, "viewed": 68, "published": "Public", "date": "1612189319", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n    daily: 015\n    author: Will Stallwood\n    insta: https://www.instagram.com/willstall/\n    \n*/\n\n//https://github.com/willstall/30-days-of-shade/blob/master/assets/shaders/015_domain_repeat.frag\n\n#define PI 3.14159265359\n#define HALF_PI 1.57079632675\n#define TWO_PI 6.283185307\n\n#define SAMPLES 34\n\n\n\n\n\nfloat linearstep(float begin, float end, float t) {\n    return clamp((t - begin) / (end - begin), 0.0, 1.0);\n}\n\nfloat cubicPulse( float c, float w, float x )\n{\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\nfloat random( in vec2 st )\n{\n\treturn fract( sin( dot(st.xy, vec2(-30.950,-10.810) )) * 43758.5453123  );\t    \n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nmat2 rotate(float angle)\n{\n    return mat2( cos(angle),-sin(angle),sin(angle),cos(angle) );\n}\n\nvec2 center(vec2 st)\n{\n    float aspect = iResolution.x/iResolution.y;\n    st.x = st.x * aspect - aspect * 0.5 + 0.5;\n    return st;\n}\n\nvec3 debug_sdf(float sdf, bool full)\n{\n   vec3 color = vec3(1.0) - sign(sdf)*vec3(0.1,0.4,0.7);\n   if(full)\n   {\n\tcolor *= 1.0 - exp(-2.0*abs(sdf));\n\tcolor *= 0.89 + .5*cos(80.0*sdf);\n\tcolor = mix( color, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(sdf)) );\n   }\n\n    return color;\n}\n\nfloat cell(vec2 st)\n{\n    st -= 0.5;\n    // st /= 0.25;\n    st *= rotate(PI*.25);\n\n    float d = sdBox(st,vec2(1.5,1.5));      // change box size because of space\n    return d;\n}\n\nvec4 scene(vec2 st, float t)\n{   \n    st *= 6.0;\n\n    // timing\n    float iT = floor(t / .25);\n    float fT = fract(t / .25);\n        fT = pow(fT,.20);\n\n    float spacing = 2.0;        \n    vec2 pos = vec2(0.5,0.5);\n\n    // ugh\n    if(iT == -.0)    \n        pos += vec2(0.0,-spacing)*fT;\n    else if(iT == 1.0)    \n        pos += vec2(0.0,-spacing) +\n        vec2(-spacing,0.0)*fT;\n    else if(iT == 2.0)    \n        pos += vec2(-spacing,-spacing) + \n        vec2(0.0,spacing) *fT;\n    else if(iT == 3.0)    \n        pos += vec2(-spacing,0.0)+ \n        vec2(spacing,0.0) *fT;\n\n    \n    // crazy animation\n    st -= pos * 2.0;\n    st *= 0.8 * (1.0-fT);\n    st *= rotate( TWO_PI / 4.0 * (iT + fT));\n\n    // sdf\n    vec4 sdf = vec4(0.0);\n        sdf.x = cell(fract(st));\n\n        // sdf.y = sdBox(st-pos,vec2(.25));\n\n        // sdf.y = cell(st-pos)+1.15;\n\n    return sdf;\n}\n\nfloat traceShadows(vec2 position, vec2 lightPosition,float t){\n    vec2 direction = normalize(lightPosition - position);\n    float lightDistance = length(lightPosition - position);\n\n    float rayProgress =  0.0001;\n    float nearest = 9999.0;\n    float hardness = 8.50 + random(position) * .50;\n\n    for(int i=0 ;i<SAMPLES; i++){\n        vec4 scene = scene(position + direction * rayProgress,t);\n        float sceneDist = scene.y;\n\n        if(sceneDist <= 0.0){\n            return 0.0;\n        }\n        if(rayProgress > lightDistance){\n            return clamp(nearest,0.0,1.0);\n            //return 1.0;\n        }\n\n        nearest = min(nearest, hardness * sceneDist / rayProgress);\n        rayProgress = rayProgress + sceneDist;\n    }\n\n    return 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // space\n    vec2 st = gl_FragCoord.xy / iResolution.xy;\n    st=st*1.5;\n    st = center( st );\n    st = st * 2.0 - 1.0;\n\n    // timing\n    float seconds = 6.0;\n    float t = fract(iTime/seconds);\n\n    // sdf\n    vec4 sdf = scene(st,t);\n\n    // light & shadows\n    vec2 light = vec2(0.0,0.0);\n    float shadows = traceShadows(st,light,t);\n\n    // colors\n    vec3 background = vec3(254.0,226.0,223.0) / 255.0;\n    vec3 shadow = vec3(0.07);\n\n    vec3 cyan = vec3(51.0,180.0,182.0) / 255.0;\n    vec3 blue = vec3(36.0,39.0,90.0) / 255.0;\n    vec3 yellow = vec3(245.0,177.0,71.0) / 255.0;\n    vec3 pink = vec3(240.0,41.0,86.0) / 255.0;\n\n    const int COLOR_COUNT = 8;\n\n    vec3 colors[COLOR_COUNT];\n        colors[0] = cyan;\n        colors[1] = background;\n        colors[2] = blue;\n        colors[3] = background;\n        colors[4] = yellow;\n        colors[5] = background;\n        colors[6] = pink;\n        colors[7] = background;\n\n    // color\n    vec3 color = vec3(0.07);\n        color = background;        \n\n    // color = mix(color,vec3(0.04),smoothstep(0.0,1.0,1.0-shadows));\n    // color = mix(color,vec3(1.0), 1.0 - smoothstep(0.0,0.002,sdf.x));\n\n    // color = mix(color,pink,ceil(fract(sdf.x*10.0)+1.0));\n    // color = mix(color,pink,\n    //     floor(mod(sdf.x*10.0,4.0))\n    // );\n    t = t * float(COLOR_COUNT) - 1.0;\n\n    int color_index = int(floor(mod(sdf.x*20.0+t,float(COLOR_COUNT))));\n    // float color_index = floor(mod(sdf.x*24.0,4.0));\n\n    for(int i = 0; i < COLOR_COUNT; i++)\n    {     \n        vec3 c = colors[i];\n\n        if(i == int(color_index)){\n            color = mix(color,c,1.0 - smoothstep(0.0,0.003,sdf.x));\n        }\n    }\n\n    // color -= background*.9 * (1.0 - smoothstep(0.0,0.003,shadows));\n    // color = mix(color,shadow,smoothstep(0.0,1.0,1.0-shadows));\n\n    // color correction\n    // color -= pow(length(st)-.1,1.8) * 0.1;\n    // color += .07;\n\n    // moving cell\n    // color = mix(color,pink,1.0-sign(sdf.y));\n\n    // int color_index = int(floor(mod(sdf.x*20.0,float(COLOR_COUNT*2))));\n\n    // for(int i = 0; i < COLOR_COUNT+COLOR_COUNT; i++)\n    // {\n    //     vec3 c = colors[i];\n\n    //     if(mod(float(i),2.0) == 1.00)\n    //     {\n    //         c = background;\n\n    //     }else if(i == color_index){\n    //         color = mix(color,c,1.0 - smoothstep(0.0,0.003,sdf.x));\n    //     }\n\n    //     // color = mix(color,c*sdf.x,sdf.z)/.999;\n    // }\n\n\n\n    // color = mix(color,pink,fract(sdf.x*10.0));\n    // color = mix(color,pink,floor(mod(fract(sdf.x*10.0),2.0)+1.0));\n\n    // color = mix(color,vec3(1.0),sign(sdf.xyz));        \n    // color = mix(color,vec3(1.0),sdf.xyz);\n    // color = mix(color,debug_sdf(sdf.y,true),1.0);\n    // color = mix(color,vec3(1.0),\n    //     max(\n    //         step( -0.0015 , st.x ) * step( st.x, 0.0015 ),\n    //         step( -0.0015 , st.y ) * step( st.y, 0.0015 )\n    //     )\n    // );\n\n    fragColor = vec4(color, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdVBWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 308, 359, 359, 418], [420, 420, 467, 467, 561], [563, 563, 591, 591, 674], [676, 676, 702, 702, 1219], [1221, 1221, 1258, 1258, 1342], [1344, 1344, 1370, 1370, 1437], [1439, 1439, 1461, 1461, 1573], [1575, 1575, 1613, 1613, 1853], [1855, 1855, 1876, 1876, 2033], [2035, 2035, 2065, 2065, 2905], [2907, 2907, 2969, 2969, 3663], [3665, 3665, 3722, 3735, 6642]], "test": "error"}
{"id": "tl3BDB", "name": "Volume Scattering Clouds", "author": "vinkna", "description": "Volumetric clouds. Use the mouse to look around. Clouds shape and shading can be adjusted by changing the constants at the top of the file.", "tags": ["raymarching", "clouds", "volumetric", "scattering"], "likes": 3, "viewed": 223, "published": "Public API", "date": "1613355091", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Volume Scattering Clouds\n// by Vincent Knauss @vinkna, 2021\n// https://www.shadertoy.com/view/tl3BDB\n\n// Based on the course notes\n// Real-Time Volumetric Rendering by Patapom / Bomb!, 2013\n// https://patapom.com/topics/Revision2013/Revision%202013%20-%20Real-time%20Volumetric%20Rendering%20Course%20Notes.pdf\n\nconst vec3 blueSkyColor = vec3(0.2, 0.8, 2.0);\n\nconst float cloudiness = 0.35;  // controls how much of the sky is covered by clouds\nconst float cloudDensity = 0.15;  // scales the density of the clouds, a multiplier to the scattering and extinction coeffs\n\n// sigma_t and sigma_s in the volumetric rendering equation\n// properly, sigma_t = sigma_s + sigma_a and for clouds sigma_a ~= 0 so sigma_s ~= sigma_t\n// however I found this makes the clouds too dark. probably because there is no multiple scattering\nconst float fExtinction = 0.0275;\nconst float fScattering = 0.0375;\n\nconst float PI = 3.141592653;\n\nconst float rPlanet = 1000000.0;  // controls how fast clouds drop below the horizon. further clouds show more undersampling aritfacts\n\n// clouds are drawn in a spherical shell with inner radius rPlanet + cloudBottom and outer radius rPlanet + cloudTop\n// the ray march steps are aligned to the surface of this shell, meaning the distance for each step depends on the angle of the ray\nconst float cloudBottom = 1500.0;\nconst float cloudTop = 6000.0;\nconst int cloudSteps = 64;\n\n// shadow steps are raymarched out from each point, and accumulate extinction values to approximate how much direct\n// sunlight is transmitted to the point\nconst int shadowSteps = 6;\nconst float shadowStepDist = 100.0;\n\nconst float noiseFrequency = 0.0001;  // base scale applied to the coordinates when noise is sampled. multiplied by 3 on the y axis\n\nconst vec3 sunDirection = normalize(vec3(-5, -3, -1));  // direction of the sunlight, not to the sun\nconst vec3 sunIntensity = vec3(5.0, 5.0, 5.0);\n\nconst vec2 cloudVelocity = vec2(300, 200);\n\n\n// 2D Random from The Book of Shaders\n// https://thebookofshaders.com/11/\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\nfloat random(in vec3 c) {\n    return random(vec2(random(c.xy), c.z));\n}\n\n// 3D Value Noise based on:\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec3 st) {\n    vec3 i = floor(st);\n    vec3 fr = fract(st);\n\n    // 8 corners in 3D of a tile\n    float a = random(i);\n    float b = random(i + vec3(1.0, 0.0, 0.0));\n    float c = random(i + vec3(0.0, 1.0, 0.0));\n    float d = random(i + vec3(1.0, 1.0, 0.0));\n    float e = random(i + vec3(0.0, 0.0, 1.0));\n    float f = random(i + vec3(1.0, 0.0, 1.0));\n    float g = random(i + vec3(0.0, 1.0, 1.0));\n    float h = random(i + vec3(1.0, 1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec3 u = fr*fr*(3.0-2.0*fr);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 8 corners percentages\n    return mix(mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y,\n                mix(e, f, u.x) + (g - e)* u.y * (1.0 - u.x) + (h - f) * u.x * u.y, u.z);\n}\n\nfloat fbm(vec3 coord, int octave, float baseScale) {\n    float influence = 0.5;\n    float scale = baseScale;\n    float sum = 0.0;\n    for (int i = 0; i < octave; ++i) {\n        sum += influence * noise(coord * scale);\n        influence *= 0.5;\n        scale *= 2.0;\n    }\n    return sum;\n}\n\n// Formula for distance from a point at the top of a circle with radius r to the edge of a circle with radius r + d along a ray with vertical angle theta:\n// d = sqrt(r^2 * cos^2(theta) + 2*r*d + d^2) - r * cos(theta)\nfloat distanceToSphereEdge(float r, float d, float cst) {\n    return sqrt(r*r*cst*cst + 2.0*r*d + d*d) - r*cst;\n}\n\n// Henyey-Greenstein phase function\nfloat phaseHG(float g, float cst) {\n    float gg = g*g;\n    return (1.0 - gg) / (4.0*PI*pow(1.0+gg-2.0*g*cst, 1.5));\n}\n\nfloat cloud(vec3 coord, float dist, float startDist, float endDist) {\n    float d = fbm(coord * vec3(1, 3, 1), 8, noiseFrequency);\n    \n    d = cloudDensity * clamp((d-1.0+cloudiness)/cloudiness, 0.0, 1.0);\n\n    // ramp the density to 0 at the top and bottom of the cloud layer\n    d *= clamp((dist - startDist) / 700.0, 0.0, 1.0);\n    d *= clamp((endDist - dist) / 10.0, 0.0, 1.0);\n    \n    return d;\n}\n\nvec2 rotate(vec2 v, float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, s, -s, c) * v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 worldDir = normalize(vec3((fragCoord - 0.5 * iResolution.xy)/iResolution.y, 1.0));\n    worldDir.yz = rotate(worldDir.yz, clamp((iMouse.y - abs(iMouse.w)) / iResolution.y * 5.0, -PI/2.0, PI/2.0));\n    worldDir.xz = rotate(worldDir.xz, (iMouse.x - abs(iMouse.z)) / iResolution.x * 5.0);\n    \n       \n    if (worldDir.y > 0.0) {\n        vec3 cloudLuminance = vec3(0, 0, 0);\n        float cloudExtinction = 1.0;\n\n        // cos(theta) is equal to worldDir.y here\n        float cloudStartDist = distanceToSphereEdge(rPlanet, cloudBottom, worldDir.y);\n        float cloudEndDist = distanceToSphereEdge(rPlanet, cloudTop, worldDir.y);\n\n        float cloudDist = cloudStartDist;\n        float cloudStepDist = (cloudEndDist - cloudStartDist) / float(cloudSteps - 1);\n\n        float cosTheta = -dot(worldDir, sunDirection);\n        float phaseSun = 0.01 * phaseHG(0.8, cosTheta) + 0.8 * phaseHG(0.1, cosTheta) + 0.19 * phaseHG(-0.2, cosTheta);\n\n        float phaseAmbient = 1.0 / (4.0 * PI);\n\n        int inCloud = 0;\n        float sumDensity = 0.0;\n        for (int i = 0; i < cloudSteps; ++i) {\n            vec3 cloudPos = worldDir * cloudDist + vec3(cloudVelocity.x, 0, cloudVelocity.y) * iTime;\n            float thisStepDist = cloudStepDist;\n\n            float density = cloud(cloudPos, cloudDist, cloudStartDist, cloudEndDist);\n\n            if (density > 0.0) {\n                inCloud = 2;\n            } else {\n                --inCloud;\n            }\n            \n            if (inCloud > 0) {\n                float sunExtinction = 1.0;\n                for (int j = 0; j < shadowSteps; ++j) {\n                    vec3 shadowPos = cloudPos - sunDirection * shadowStepDist * float(j+1);\n\n                    float shadowCloudDensity = cloud(shadowPos, length(worldDir * cloudDist + sunDirection * shadowStepDist * float(j+1)), cloudStartDist, cloudEndDist);\n\n                    sunExtinction *= exp(-fExtinction * shadowCloudDensity * shadowStepDist);\n                }\n\n                vec3 ambientColor = sunIntensity;\n                vec3 sunColor = sunExtinction * sunIntensity;\n\n               \n                cloudExtinction *= exp(-fExtinction * density * cloudStepDist);\n                \n                if (cloudExtinction <= 0.001) {\n                    cloudExtinction = 0.0;\n                    break;\n                }\n\n                vec3 sampleLuminance = cloudExtinction * fScattering * density * cloudStepDist * (phaseAmbient * ambientColor + phaseSun * sunColor);\n                if (any(lessThan(sampleLuminance, vec3(0.0)))) cloudLuminance = vec3(10, 0, 0);\n                else cloudLuminance += clamp(1.0 -sumDensity, 0.0, 1.0) * sampleLuminance;\n            }\n\n            cloudDist += cloudStepDist;\n            sumDensity += density;\n        }\n        \n        float distBlend = 1.0 - clamp((cloudStartDist-cloudBottom)/500000.0, 0.0, 1.0);\n        distBlend *= distBlend;\n\n        float sunFactor = clamp(-dot(worldDir, sunDirection)-0.998, 0.0, 0.002) * 500.0;\n        sunFactor *= sunFactor;\n        vec3 skyColor = blueSkyColor + sunFactor * sunIntensity;\n        skyColor = distBlend * cloudLuminance + skyColor * cloudExtinction + blueSkyColor * (1.0 - cloudExtinction) * (1.0 - distBlend);\n        \n        fragColor = vec4(skyColor, 1.0);\n    } else {\n        fragColor = vec4(vec3(0.2), 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3BDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1949, 2023, 2050, 2050, 2167], [2169, 2169, 2194, 2194, 2240], [2242, 2357, 2383, 2383, 3172], [3174, 3174, 3226, 3226, 3463], [3465, 3683, 3740, 3740, 3796], [3798, 3834, 3869, 3869, 3952], [3954, 3954, 4023, 4023, 4357], [4359, 4359, 4393, 4393, 4481], [4483, 4483, 4540, 4540, 7884]], "test": "error"}
{"id": "tl3Bzs", "name": "objets lifgraphique", "author": "FranckyTax", "description": "objets graphiques", "tags": ["etiquette"], "likes": 1, "viewed": 44, "published": "Public", "date": "1613249807", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Modeling\n// Eric Galin\n\n// Hashing function\n// Returns a random number in [-1,1]\nfloat Hash(float seed)\n{\n    return fract(sin(seed)*43758.5453 );\n}\n\n// Cosine direction \n// seed : Random seed\n//    n : Normal\nvec3 Cosine( float seed, vec3 n)\n{\n    float u = Hash( 78.233 + seed);\n    float v = Hash( 10.873 + seed);\n\n    // Method by fizzer: http://www.amietia.com/lambertnotangent.html\n    float a = 6.2831853 * v;\n    u = 2.0 * u - 1.0;\n    return normalize( n + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u) );\n}\n\n// Rotation matrix around z axis\n// a : Angle\nmat3 Rz(float a)\n{\n    float sa = sin(a); float ca = cos(a); \n    return mat3(ca,sa,0.0,    -sa,ca,0.0,  0.0,0.0,1.0);\n}\n\n// Compute the ray\n//      m : Mouse position\n//      p : Pixel\n// ro, rd : Ray origin and direction\nvoid Ray(vec2 m, vec2 p,out vec3 ro,out vec3 rd)\n{\n    float a = 3.0*3.14*m.x;\n   \tfloat le = 3.5;\n    \n    // Origin\n    ro=vec3(37.0,0.0,10.0);\n    ro*=Rz(3.0*3.14*m.x); \n\n    // Target\n    vec3 ta = vec3(0.0,0.0,1.0);\n    \n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,0.0,1.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\trd = normalize( p.x*uu + p.y*vv + le*ww );\n}\n\n// Modeling - 2020.07.20\n// Eric Galin \n\nconst int Steps = 200;      // Number of steps\nconst float Epsilon = 0.01; // Marching epsilon\n\n// Primitive functions -----------------------------------------------------------------------------------\n\n// Sphere \n// p : point\n// c : center of skeleton\n// r : radius\nfloat Sphere(vec3 p, vec3 c,float r)\n{\n  return length(p-c)-r;\n}\n\n// Sphere \n// p : point\n// n : Normal of plane\n// o : Point on plane\nfloat Plane(vec3 p, vec3 n, vec3 o)\n{\n    return dot((p-o),n);\n}\n\n// Union\n// a,b : field function of left and right sub-trees\nfloat Union(float a,float b)\n{\n    return min(a,b);\n}\n\n// Intersection\n// a,b : field function of left and right sub-trees\nfloat Intersection(float a,float b)\n{\n    return max(a,b);\n}\n\n//Difference\nfloat difference(float a,float b)\n{\n    return max(a, -b);\n}\n\n//p, centre du tore, t.x = rayon du tore, t.y = rayon de l'anneau\n//ces fonctions ont été récupérer à partir de ce site : https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdTorus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\n\n//Distance signé de la boîte\n//p : point\n//b : dimensions de la boîte\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n//Distance signé par rapport à un cylindre\n//Cette fonction a été légèrement modifié car les paramètres r et h étaient inversé.\n//p : point\n//h : hauteur\n//r : rayon\n\nfloat sdCappedCylinder( vec3 p, float r, float h)\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n///////FIN DES FONCTIONS DU SITE \n\n//translation\n//pos : vecteur\n//p : point\nvec3 Translate(vec3 vec, vec3 p)\n{\n    return p - vec;\n}\n\n//mise à l'échelle\n//scale: vecteur comportant les facteurs x, y, z pour agrandir/retrécir\n//p : point\nvec3 Scale(vec3 scale, vec3 p)\n{\n    return vec3(p.x / scale.x, p.y/ scale.y, p.z / scale.z);\n}\n\n//rotation sur l'axe des X\n//p : point\n//theta : angle de roration demandé ici en radians\nvec3 RotateX(float theta, vec3 p)\n{\n    float sinVal = sin(theta);\n    float cosVal = cos(theta);\n\n    //matrice de rotation sur l'axe X\n    mat3 M = mat3(  1,     0,     0,\n                    0,  cosVal, -sinVal,\n                    0,  sinVal,  cosVal);\n\n    //application de la rotation par le produit de la matrice et du point\n    return M*p;\n}\n\n//rotation sur l'axe des Y\n//p : point\n//theta : angle de roration demandé ici en radians\nvec3 RotateY(float theta, vec3 p)\n{\n    float sinVal = sin(theta);\n    float cosVal = cos(theta);\n\n    mat3 M = mat3( cosVal,    0,  -sinVal,\n                    0,      1,      0,\n                   sinVal,    0,   cosVal);\n\n    return M*p;\n}\n\n//rotation sur l'axe des Z\n//p : point\n//theta : angle de roration demandé ici en radians\nvec3 RotateZ(float theta, vec3 p)\n{\n\n    float sinVal = sin(theta);\n    float cosVal = cos(theta);\n\n    mat3 M = mat3(  cosVal,  -sinVal,   0,\n                    sinVal,   cosVal,   0,\n                    0,      0,      1);\n                    \n    return M*p;\n}\n\n//converse des degrés en radian\n//theta: valeur en degré\nfloat rad(float theta)\n{\n    return theta * 0.0174532925199432957692369;\n}\n\n//p: point\n//tête du personnage\nfloat Head(vec3 p)\n{\n    //chapeau\n    p = RotateY(rad(90.0), p);\n    float v = Sphere(p, vec3(0.0, 0.0, 0.0), 2.0);\n    v = Intersection(v, Sphere(p, vec3(2.8, 0.0, 0.0), 2.0));\n    v = Union(v, Sphere(p, vec3(2.2, 0.0, 0.0), 0.3));\n\n    \n    //rotation de 90 degré puis déplacer du tore\n    vec3 tmp = RotateZ(rad(120.0), p);\n    tmp = Translate(vec3(0.1, 0.2, 0.0), tmp);\n    v = Union(v, sdTorus(tmp, vec2(0.4, 0.04)));\n\n\n    //visage\n    v = Union(v, Sphere(p, vec3(1.0, 0.0, 0.0), 1.0));\n\n    //nez\n    p = Scale(vec3(0.2, 0.2, 0.2), p);\n    p = Translate(vec3(2.0, 4.0, 0.0), p);\n    v = Union(v, sdCappedCylinder(p, 1.0, 2.0));\n\n    //eyes\n    p = Translate(vec3(2.0, -1.0, 2.0), p);\n    v = Union(v, Sphere(p, vec3(0.0, 0.0, 0.0), 1.8));\n\n    p = Translate(vec3(0.0, 0.0, -4.0), p);\n    v = Union(v, Sphere(p, vec3(0.0, 0.0, 0.0), 1.8));\n\n    //cou\n    //p = Translate(vec3(-7.0, 0.0, 0.0), p);\n    p = RotateZ(rad(90.0), p);\n    p = Translate(vec3(-3.0, 5.0, 2.0), p);\n    v = Union(v, sdCappedCylinder(p, 1.5, 2.0));\n    \n    return v;\n}\n\n//p : point\n// les bras du personnage\nfloat Arms(vec3 p)\n{\n    //translation vers la droite\n    p = Translate(vec3(-1.6, 0.0, 0.0), p);\n\n    //rotation dans le sens inverse des aiguilles d'une montre\n    p = RotateY(rad(-20.0), p);\n\n    //représentation du bras sous la forme d'un pavé droit\n    float v = sdBox(p, vec3(0.5, 0.5, 1.0));\n\n    //translation vers la gauche \n    p = Translate(vec3(3.0, 0.0, 1.1), p);\n\n    ////rotation dans le sens des aiguilles d'une montre\n    p = RotateY(rad(40.0), p);\n\n    v = Union(v, sdBox(p, vec3(0.5, 0.5, 1.0)));\n\n    return v;\n}\n\n//p : point\n// le corps du personnage\nfloat Body(vec3 p)\n{\n    //translation du torse du personnage\n    p = Translate(vec3(0.0, 0.0, -1.5), p);\n    float v = sdBox(p, vec3(1.5, 0.5, 1.0));\n\n    //ajout de perspective avec un second pavé\n    v = Union(v, sdBox(p, vec3(1.0, 1.0, 1.0)));\n\n    //ajout des bras\n    v = Union(v, Arms(p));\n    return v;\n}\n\n//p : point\n//le personnage\nfloat Pinoccio(vec3 p)\n{\n    float v = Union(Body(p), Head(p));\n    return v;\n}\n\n\n\n// Potential field of the object\n// p : point\n\nfloat object(vec3 p)\n{\n    //rotation de l'obet et agrandissement de l'objet\n    p = Scale(vec3(2.0, 2.0, 2.0), p);\n    p = RotateZ(iTime, p);\n    float v = Pinoccio(p);\n\n  //float tete = difference(v, Sphere(p, vec3(0.0, 0.0, 0.0), 2.0));\n    \n  //v = Plane(p,vec3(0.0,0.0,1.0),vec3(0.0,0.0,-4.0));\n  //v = difference(Sphere(p, vec3(0.0, 0.0, 1.3), 1.0), v);\n\n\n  return v;\n}\n\n// Analysis of the scalar field --------------------------------------------------------------------------\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(vec3 p)\n{\n  float eps = 0.001;\n  vec3 n;\n  float v = object(p);\n  n.x = object( vec3(p.x+eps, p.y, p.z) ) - v;\n  n.y = object( vec3(p.x, p.y+eps, p.z) ) - v;\n  n.z = object( vec3(p.x, p.y, p.z+eps) ) - v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// e : Maximum distance \n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, float e,out bool h,out int s)\n{\n  h = false;\n\n  // Start at the origin\n  float t=0.0;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p);\n    // Hit object\n      if (v < 0.0)\n      {\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += max(Epsilon,v);\n      // Escape marched too far away\n      if (t>e)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n// Lighting ----------------------------------------------------------------------------------------------\n\n// Ambient occlusion\n// p : Point\n// n : Normal\n// r : Radius for ambient occlusion\n// a : Number of smaples\nfloat AmbientOcclusion(vec3 p,vec3 n, float r, int a)\n{\n    if (a==0) { return 1.0; }\n    \n\tfloat ao=0.0; \n    \n    for (int i=0;i<a;i++)\n    {\n \t\tvec3 d = Cosine(581.123*float(i) , n);\n\n        int s;\n        bool h;\n        float t=SphereTrace(p,d,r,h,s);\n        if (!h) {ao+=1.0;}\n    }\n    \n    ao/=float(a);\n\treturn ao;\n}\n\n// Background color\n// d : Ray direction\nvec3 background(vec3 d)\n{\n    return mix(vec3(0.452,0.551,0.995),vec3(0.652,0.697,0.995), d.z*0.5+0.5);\n}\n\n// Shadowing\n// p : Point\n// n : Normal\n// l : Light direction\nfloat Shadow(vec3 p,vec3 n,vec3 l)\n{\n    bool h;\n    int s;\n    float t = SphereTrace(p+0.1*n,l,100.0,h,s);\n    if (!h)\n    {\n     return 1.0;\n    }\n    return 0.0; \n}\n\n// Shading and lighting\n// p : Point\n// n : Normal at point\n// e : Eye direction\nvec3 Shade(vec3 p, vec3 n, vec3 e)\n{\n     // Point light\n    const vec3 lp = vec3(5.0, 10.0, 25.0);\n    \n    // Light direction to point light\n    vec3 l = normalize(lp - p);\n\n    // Ambient color\n    vec3 ambient = 0.25+0.25*background(n);\n    \n    // Ambient occlusion\n    ambient += 0.15 * AmbientOcclusion(p+0.1*n,n,5.0,50) * vec3(1.0,1.0,1.0);\n    \n    // Shadow computation\n    float s = Shadow(p,n,l);\n    \n    // Phong diffuse\n    vec3 diffuse = 0.35  * clamp(dot(n, l),0.0,1.0) * vec3(1.0,1.0,1.0);\n\n    // Specular\n    vec3 r = reflect(e,n);\n    vec3 specular = 0.25 * pow(clamp(dot(r,l),0.0,1.0),18.0) * vec3(1.0,1.0,1.0);\n    vec3 c = ambient + s * (diffuse + specular);\n    return c;\n}\n\n// Shading according to the number of steps in sphere tracing\n// n : Number of steps\nvec3 ShadeSteps(int n)\n{\n   float t = float(n)/(float(Steps-1));\n   return 0.5+mix(vec3(0.05,0.05,0.5),vec3(0.65,0.39,0.65),t);\n}\n\n// Picture in picture\n// pixel : Pixel\n// pip : Boolean, true if pixel was in sub-picture zone\nvec2 Pip(in vec2 pixel, out bool pip)\n{\n    // Pixel coordinates\n    vec2 p = (-iResolution.xy + 2.0*pixel)/iResolution.y;\n   if (pip==true)\n   {    \n    const float fraction=1.0/4.0;\n    // Recompute pixel coordinates in sub-picture\n    if ((pixel.x<iResolution.x*fraction) && (pixel.y<iResolution.y*fraction))\n    {\n        p = (-iResolution.xy*fraction + 2.0*pixel)/(iResolution.y*fraction);\n        pip = true;\n    }\n       else\n       {\n           pip = false;\n       }\n   }\n   return p;\n}\n\n\n// Image\nvoid mainImage( out vec4 color, in vec2 pxy )\n{\n    // Picture in picture on\n    bool pip=true;\n    \n    // Pixel\n    vec2 pixel=Pip(pxy, pip);\n    \n    // Mouse\n    vec2 m=iMouse.xy/iResolution.xy;\n\n    // Camera\n    vec3 ro,rd;\n    Ray(m,pixel,ro,rd);\n\n    // Trace ray\n\n    // Hit and number of steps\n    bool hit;\n    int s;\n\n    float t = SphereTrace(ro, rd, 100.0,hit, s);\n  \n    // Position \n    vec3 pt = ro + t * rd;\n    \n    // Shade background\n    vec3 rgb = background(rd);\n\n    if (hit)\n    {\n        // Compute normal\n        vec3 n = ObjectNormal(pt);\n\n        // Shade object with light\n        rgb = Shade(pt, n, rd);\n    }\n\n    // Uncomment this line to shade image with false colors representing the number of steps\n    if (pip==true)\n    {\n        rgb = ShadeSteps(s); \n    }\n\n\n    color=vec4(rgb, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3Bzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 84, 108, 108, 151], [153, 213, 247, 247, 519], [521, 567, 585, 585, 687], [689, 790, 840, 840, 1194], [1441, 1505, 1543, 1543, 1569], [1571, 1640, 1677, 1677, 1704], [1706, 1767, 1797, 1797, 1820], [1822, 1890, 1927, 1927, 1950], [1952, 1965, 2000, 2000, 2025], [2027, 2226, 2257, 2257, 2326], [2329, 2402, 2433, 2433, 2524], [2526, 2703, 2754, 2754, 2865], [2902, 2944, 2978, 2978, 3000], [3002, 3108, 3140, 3140, 3203], [3205, 3296, 3331, 3331, 3645], [3647, 3738, 3773, 3773, 3981], [3983, 4074, 4109, 4109, 4338], [4340, 4399, 4423, 4423, 4473], [4475, 4508, 4528, 4542, 5558], [5560, 5598, 5618, 5651, 6132], [6134, 6172, 6192, 6233, 6485], [6487, 6515, 6539, 6539, 6594], [6598, 6645, 6667, 6721, 7020], [7130, 7170, 7197, 7197, 7417], [7419, 7549, 7614, 7614, 8000], [8110, 8219, 8274, 8274, 8546], [8548, 8589, 8614, 8614, 8694], [8696, 8759, 8795, 8795, 8926], [8928, 9009, 9045, 9065, 9707], [9709, 9794, 9818, 9818, 9923], [9925, 10020, 10059, 10084, 10514], [10517, 10526, 10573, 10602, 11351]], "test": "valid"}
{"id": "tl3fD4", "name": "Rainbow snowflake", "author": "Tarquin", "description": "Rainbow snowflake created with Von Koch fractals", "tags": ["fractals", "rainbow", "snowflake", "vonkoch"], "likes": 9, "viewed": 116, "published": "Public", "date": "1612734141", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Arthur Jacquin - 2021\n// https://www.linkedin.com/in/arthur-jacquin-631921153/\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//Inspired by https://www.youtube.com/watch?v=il_Qg9AqQkE&t=369s\n\n#define PI 3.14159265359\n\nvec2 GetDirection(float angle)\n{\n    return vec2(sin(angle), cos(angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y; //UVs centré\n\n    //Pour les symetries\n    st *= 1.25;\n    st.x = abs(st.x);\n\n    float angle = 5.0 / 6.0 * PI;\n    st.y += tan(angle) * 0.5; //Centrage en hauteur\n    vec2 n = GetDirection(angle); //Direction de l'axe de symetrie\n    float axeSym = dot(st - vec2(.5, 0), n); //Axe de symetrie\n    st -= n * max(0., axeSym) * 2.; //On applique la symétrie\n\n    angle = 2.0 / 3.0 * PI;\n    n = GetDirection(angle); //Direction de l'axe de symetrie\n    \n    const int it = 4; //Nombre d'iterations\n    float scale = 1.; //scale appliqué pour décompression plus tard\n    \n    st.x += .5; //Centrage\n    for(int i = 0; i < it; i++)\n    {\n        scale *= 3.;\n        st *= 3.;\n        st.x -= 1.5;\n\n        st.x = abs(st.x); //Symetrie en X\n        st.x -= 0.5; //Aggrandissement de la ligne\n        \n        float axe = dot(st, n); //Axe de symetrie\n        st -= n * min(0., axe) * 2.; //On applique la symétrie\n\n    }\n\n    //line shape 1 pixel d'épaisseur\n    vec3 col = 0.5 + 0.5*cos(iTime - st.yyy + vec3(6,4,2));\n    float d = length(st - vec2(clamp(st.x, -1., 1.), 0));\n    col.rg += st / scale;\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3fD4.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 272, 304, 304, 347], [349, 349, 406, 406, 1618]], "test": "valid"}
{"id": "tl3fDl", "name": "Parabolas -> Triangle", "author": "branc116", "description": "Stacked parabolas converge to trinagle. :)", "tags": ["triangle", "parabola"], "likes": 2, "viewed": 148, "published": "Public API", "date": "1613670379", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define zoom 16.0\n#define t 0.01\n\nvec4 vclamp(in vec4 a) {\n    return vec4(\n        min(max(a.x, 0.0), 1.0),\n        min(max(a.y, 0.0), 1.0),\n        min(max(a.z, 0.0), 1.0),\n        min(max(a.w, 0.0), 1.0)\n    );\n}\n\nvec4 color(vec3 uv) {\n\tvec4 oc;\n    uv.y -= 1.0;\n    uv *=  max(1.0, 39.0 * pow(abs(sin(.1*uv.z)), 2.));\n    uv.x *= 1.7;\n    oc = vec4(0.0);\n   \toc += vec4(abs(uv.x) < 0.1 && uv.y > -1.0 ? 1.0 : 0.0) * .5;\n\tfloat i = float(int(uv.y));\n    if (i >= 0.0)\n    \treturn oc;\n    \n    uv.y = mod(uv.y, -1.0);\n    uv.x += float(i);\n    float j = float(int(uv.x + 1.0));\n\tuv.x = mod(uv.x, 2.0);\n\tuv.x -=1.0;\n    uv.y += 0.09;\n\tif (j >= 1.0)\n\t\treturn oc;\n\tif ( j < (i + 1.0) * 2.0)\n\t\treturn oc;\n\tfloat e = abs(-uv.x * uv.x - uv.y);\n    oc += vec4(exp(-e*30.0));\n\t//oc += e < t ? 1.4 : 0.0;\n\treturn oc;\n}\n#define mt 0.02\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tconst ivec3 msaa = ivec3(4, 4, 4);\n    const vec3 msaaf = vec3(msaa);\n\tvec3 uv = vec3((fragCoord.xy/iResolution.xy * vec2(1.0, 1.) - vec2(.5))  * zoom, iTime);\n\tfragColor = vclamp(color(uv));\n\tfor (int i = 0 ; i <= msaa.x ; i++) {\n\t\tfloat l = ((msaaf.x / -2.0) + float(i))/msaaf.x * 1.0;\n\t\t\tfor (int j = 0 ; j <= msaa.y ; j++) {\n                float tt = (-(msaaf.y / 2.0) + float(j))/msaaf.y * 1.0;\n                for (int k = 0; k <= msaa.z ; k++) {\n                    float time = iTime + (-mt + 2.0*mt*(float(k)/msaaf.z));\n                    uv = vec3(((fragCoord.xy + vec2(l, tt)) /iResolution.xy * vec2(1.0, 1.) - vec2(.5)) * zoom, time * 2.0);\n                    fragColor += vclamp(color(uv));\n                }\n\t\t}\n\t}\n\tfragColor /=msaaf.x;\n    fragColor /=msaaf.y;\n    fragColor /=msaaf.z;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3fDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 59, 59, 216], [218, 218, 239, 239, 812], [829, 829, 886, 886, 1693]], "test": "valid"}
{"id": "tl3fRM", "name": "analytical_spiral", "author": "Ecter", "description": "used to answer following SE question. https://gamedev.stackexchange.com/q/188814/,  creates Archimedes spirals, left is spiral length varying based on time, right is theta length varying based on time. EDIT: Now restarts after 24 seconds. ", "tags": ["spiral"], "likes": 3, "viewed": 58, "published": "Public", "date": "1612407910", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi \t= 3.1415926535897932384626433832795;\nconst float sqrt3 = 1.7320508075688772935274463415059;\nconst float sqrt2 = 1.4142135623730950488016887242096;\nconst float inf = uintBitsToFloat(0x7F800000u);\n\n\n//takes uv in 0->1 coordinates and turns it into normalized cordinates centered at 0,0. \nvec2 center_corrected_uv(vec2 uv, vec2 resolution){\n    vec2 uvn = (uv - 0.5);\n    //this accounts for aspect ratio, so the spiral is not skewed. \n     if(iResolution.y > iResolution.x){\n        uvn.y *= resolution.y/resolution.x;\n    }else{\n        uvn.x *= resolution.x/resolution.y;\n    }\n    return uvn; \n}\n//\"atan + normalized\" (0 -> 2*pi)\nfloat atann(float y, float x){\n    float theta = atan(y, x);\n    //we add 2*pi because the result of atan in GLSL is pi -> -pi, and we want 0 -> 2*pi\n    if(theta < 0.0){\n        theta += 2.0*pi;\n    }\n    return theta; \n}\n\n\nbool approx_eq(float a, float b, float threshold){\n    return abs(a - b) < threshold; \n}\n\n\n\n//this is the same thing as the spiral length function, mathematically, I just wasn't sure if this was more or less performant. \n//these functions are basically the analytic integral of r = coef*theta, the equation of an archimedes spiral (a spiral with evenly spaced rings). \nfloat spiral_length_sinh(float theta, float coef){\n    //integral from https://math.stackexchange.com/a/424722/\n    //and from wolfram alpha\n    return coef*(1.0/2.0) * (sqrt(theta*theta + 1.0)*theta + asinh(theta));\n}\n\nfloat spiral_length(float theta, float coef){\n    //integral from https://math.stackexchange.com/a/424722/\n    //and from wolfram alpha\n    float sqrt_theta_1 = sqrt(theta*theta + 1.0);\n    return coef*(1.0/2.0) * (sqrt_theta_1*theta + log(sqrt_theta_1 + theta));\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    //increase this to \"zoom out\"\n    const float image_scale = 100.0;\n    //increase this to increase the speed of the spiral. \n    const float speed = 100.0; \n    //*decrease* this to INCREASE fade length\n    const float fade = 0.3; \n    //need a seperate additional fade modifier for the right side\n    //otherwise will be transparent. \n    const float right_fade_mod = 4.0; \n    //decrease this to increase fade spacing. \n    //pi gaurantees filled in distance, going smaller will make a \"gapped\" spiral. \n    const float swirl_radius = pi;\n    //this controls the swirl of the marker (the white line that shows up periodically)\n    const float marker_swirl_radius = 0.05*pi; \n    //time before whole animation restarts. \n    const float restart_interval_s = 24.0;\n    //time interval for blinking spiral line. \n    const float blink_interval_s = 4.0; \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color (this is what will display as the background if we make swirl radius even smaller). \n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    \n    //I want to display two different types of swirls, one which increases with spiral length, and one that increases with theta. \n    bool display_right = uv.x > 0.5; \n    if(display_right){\n        uv.x -= 0.5; \n    }\n    uv.x /= 0.5;\n    //divide resolution by two to account for split screen. \n    vec2 uvn = center_corrected_uv(uv, vec2(iResolution.x/2.0, iResolution.y)) * image_scale; \n    float r = length(uvn)*1.0;\n    float theta = 1.0*atann(uvn.y, uvn.x); \n\n    //theta needs to be incresed to with r increasing value, ever 2pi r we need to add 2 pi to theta, since it will reset to zero. \n    // we assume every 2*pi r we want to wrap around, our r = coef*theta is actually r = 1.0*theta.  \n    // This would need to change to account for a different coeff. \n    float theta_fixed = theta + 2.0*pi*floor(r/(2.0*pi)); \n\n    float time = mod(iTime,restart_interval_s) * speed; \n    //right side too fast if we don't do this\n    if(display_right){\n        time *= 0.1; \n    }\n    //if we only check for the distance from the adjusted theta we'll get this odd semi circular pattern,\n    //because inner radii will not pass the threshold for the next theta, so we need to look at 2*pi back \n    //and forward to actually get the proper distance to spiral line from current pixel \n    bool theta_the_eq = approx_eq(r, theta_fixed, swirl_radius);\n    bool theta_min_eq = approx_eq(r, theta_fixed - 2.0*pi,swirl_radius);\n    bool theta_max_eq = approx_eq(r, theta_fixed + 2.0*pi,swirl_radius);\n    bool within_swirl_radius = theta_the_eq || theta_min_eq || theta_max_eq;\n    float relative_theta; \n    if(theta_the_eq){\n        relative_theta = theta_fixed;\n    }else if(theta_min_eq){\n        relative_theta = theta_fixed - 2.0*pi;\n    }else if(theta_max_eq){\n        relative_theta = theta_fixed + 2.0*pi;\n     }\n    \n    if(theta_the_eq || theta_min_eq || theta_max_eq){\n        float final_value = 0.0;\n        \n        if(display_right){\n        //on the right, we show theta used as the time/distance modifier.  \n        // Notice that it appears to get \"faster\" the further out it goes.  \n        // This is because it is covering larger amounts of spiral length in the same angle space (theta). \n        // this may or may not be the effect you want. \n        //Notice, we have to use the appropriate theta which passed the approximate equal threshold, for similar reasons to why\n        //we needed to test three different distance metrics in the first place. \n        \n            //we use log in addition to the fade coefficient to create a more athsetically pleasing fade, but this isn't actually necessary. \n            //using only fade will still work, just with a linear ramp up to color. \n            col = vec3(fade*right_fade_mod*log(-(relative_theta - time)));\n        }else{ \n        //on the LEFT, we show the actual spiral distance used as the time/distance modifier.  \n        // Notice that it appears to get \"slower\" the further out it goes.  \n        // This is because it is covering larger amounts of spiral length, and as it gets further out theres more spiral to cover per angle area. \n        // this may or may not be the effect you want. \n        //Notice, we have to use the appropriate theta which passed the approximate equal threshold, for similar reasons to why\n        //we needed to test three different distance metrics in the first place. \n\n            //we use log in addition to the fade coefficient to create a more athsetically pleasing fade, but this isn't actually necessary. \n            //using only fade will still work, just with a linear ramp up to color. \n            col = vec3(fade*log(-(spiral_length(relative_theta, 1.0) - time)));\n        }\n    }\n\n    // this is used to display the white line, so you can be sure this is an archimedes spiral (again, an equally ringed distance spiral), \n    //if you removed this code, it would not display the line. \n    if(approx_eq(r, theta_fixed, marker_swirl_radius) \n    || approx_eq(r, theta_fixed - 2.0*pi,marker_swirl_radius) \n    || approx_eq(r, theta_fixed + 2.0*pi, marker_swirl_radius)){\n    //we blink this to show this is only temporary. \n        if(mod(mod(iTime,restart_interval_s), blink_interval_s) < 2.0){\n            col = vec3(1.0);\n        }\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3fRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[213, 302, 353, 353, 612], [613, 647, 677, 677, 869], [872, 872, 922, 922, 960], [964, 1241, 1291, 1381, 1459], [1461, 1461, 1506, 1596, 1726], [1731, 1731, 1788, 1823, 7246]], "test": "error"}
{"id": "tl3fWH", "name": "Voronoi study (poincare disc)", "author": "sig", "description": "Simple voronoi using different \"hyperbolic space\" metrics.", "tags": ["geometric"], "likes": 3, "viewed": 44, "published": "Public", "date": "1612624676", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 point(int i) {\n    float r = 0.4 + 0.3 * sin(float((i * 123) % 9 + 4) * iTime * 0.05 + 0.5);\n    float a = float((i * 345) % 7 + 4) * iTime * 0.05 + r;\n    return r * vec2(cos(a), sin(float((i * 143) % 3 + 2) * a));\n}\n\nfloat switch_interval = 2.0;\nfloat dist(vec2 a, vec2 b) {\n    float T = mod(iTime, switch_interval * 6.) / switch_interval;\n    switch(int(T)) {\n    case 0: return abs(a.x-b.x) + abs(a.y-b.y); // 1-d \"manhattan\"\n    case 1:\n    case 2: \n    case 3: \n    case 4: return pow(pow(abs(a.x-b.x), T) + pow(abs(a.y-b.y), T), 1./T);\n    case 5: return max(abs(a.x-b.x), abs(a.y-b.y)); // inf-d \"\"\n    }\n}\n\nfloat BORDER_R = 0.01;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    if (length(p) > 1.01) {\n        p *= 1. / dot(p, p);\n    }\n\n    float min_d = 666.;\n    vec2 min_c = p;\n    float hilite = 0.;\n    float border = 0.;\n    for (int i = 0; i < 10; i++) {\n        vec2 c = point(i);\n        \n        float d = dist(c, p);\n        // poincare metric stolen from https://www.shadertoy.com/view/MsSBWR\n        d /= 1.0 - dot(c, c);\n        d /= 1.0 - dot(p, p);\n        d = acosh(1.0 + d);\n        \n        hilite += d < 0.4 ? d : 0.0;\n        float dd = d - min_d;\n        if (dd < BORDER_R) {\n            if (dd < -BORDER_R) {\n                min_d = d;\n                min_c = c;\n                border = 0.0;\n            } else {\n                border = 1.0 - abs(dd) / BORDER_R;\n            }\n        }\n    }\n\n    vec3 col = 0.5 + hilite + 0.5*cos(iTime+min_c.xyx+vec3(0,2,4)) - border ;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3fWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 222], [253, 253, 281, 281, 620], [645, 645, 702, 702, 1625]], "test": "error"}
{"id": "tl3fWs", "name": "Circuit board fractal", "author": "jarble", "description": "I found a fractal pattern that looks like a printed circuit board.", "tags": ["fractal", "circuit"], "likes": 8, "viewed": 199, "published": "Public API", "date": "1613676100", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 triangle_wave(vec2 a,float scale){\n    return (abs(fract(a*scale)-.5));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    for(int c=0;c<3;c++){\n        float t1 = 5.0;\n\t    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1;\n        uv += vec2(iTime/2.0,iTime/3.0)/t1;\n        \n        float offset = .4;\n        float scale = 1.5;\n        for(int i=0;i<6;i++)\n        {\n          \n            uv = triangle_wave(uv.yx+offset,scale)+triangle_wave(uv,scale);\n            uv= uv+col.xy;\n        }\n     col[c] = fract((uv.x)-(uv.y));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3fWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 78], [80, 80, 137, 137, 648]], "test": "valid"}
{"id": "tl3fzH", "name": "Random little fractal", "author": "mrange", "description": "License CC0: Random little fractal\nWeird but to me appealing results after a bit of tinkering with no clear goals\n\n", "tags": ["2d"], "likes": 12, "viewed": 293, "published": "Public API", "date": "1612220495", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License CC0: Random little fractal\n// Weird but to me appealing results after a bit of tinkering with no clear goals\n\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define L2(x)           dot(x, x)\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PSIN(x)         (0.5+0.5*sin(x))\n#define LESS(a,b,c)     mix(a,b,step(0.,c))\n#define SABS(x,k)       LESS((.5/(k))*(x)*(x)+(k)*.5,abs(x),abs(x)-(k))\n\nconst float fixed_radius2 = 1.9;\nconst float min_radius2   = 0.5;\nconst float folding_limit = 1.0;\nconst float scale         = -2.8;\n\nvoid sphere_fold(inout vec3 z, inout float dz) {\n    float r2 = dot(z, z);\n    if(r2 < min_radius2) {\n        float temp = (fixed_radius2 / min_radius2);\n        z *= temp;\n        dz *= temp;\n    } else if(r2 < fixed_radius2) {\n        float temp = (fixed_radius2 / r2);\n        z *= temp;\n        dz *= temp;\n    }\n}\n\nvec3 polySoftMin3(vec3 a, vec3 b, vec3 k) {\n  vec3 h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0);\n  \n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nvoid box_fold(inout vec3 z, inout float dz) {\n  const float k = 0.05;\n  // Soft clamp after suggestion from ollij\n  vec3 zz = sign(z)*polySoftMin3(abs(z), vec3(folding_limit), vec3(k));\n  // Hard clamp\n  // z = clamp(z, -folding_limit, folding_limit);\n  z = zz * 2.0 - z;\n}\n\nfloat sphere(vec3 p, float t) {\n  return length(p)-t;\n}\n\nfloat torus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat mb(vec3 z) {\n    vec3 offset = z;\n    float dr = 1.0;\n    float fd = 0.0;\n    for(int n = 0; n < 5; ++n) {\n        box_fold(z, dr);\n        sphere_fold(z, dr);\n        z = scale * z + offset;\n        dr = dr * abs(scale) + 1.0;        \n        float r1 = sphere(z, 5.0);\n        float r2 = torus(z, vec2(8.0, 1));\n        r2 = abs(r2) - 0.25;\n        float r = n < 4 ? r2 : r1;        \n        float dd = r / abs(dr);\n        if (n < 3 || dd < fd) {\n          fd = dd;\n        }\n    }\n    return fd;\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\nfloat modMirror1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize,size) - halfsize;\n  p *= mod(c, 2.0)*2.0 - 1.0;\n  return c;\n}\n\nfloat smoothKaleidoscope(inout vec2 p, float sm, float rep) {\n  vec2 hp = p;\n\n  vec2 hpp = toPolar(hp);\n  float rn = modMirror1(hpp.y, TAU/rep);\n\n  float sa = PI/rep - SABS(PI/rep - abs(hpp.y), sm);\n  hpp.y = sign(hpp.y)*(sa);\n\n  hp = toRect(hpp);\n\n  p = hp;\n\n  return rn;\n}\n\nfloat weird(vec2 p) {\n  const float s = 0.55;\n  p /= s;\n  float rep = 20.0;\n  float ss = 0.05*6.0/rep;\n  vec3 p3 = vec3(p.x, p.y, PSIN(TIME*0.53));\n  p3.yz *= ROT(TIME*0.1);\n  float n = smoothKaleidoscope(p3.xy, ss, rep);\n  return mb(p3)*s;\n}\nfloat df(vec2 p) {\n  float d = weird(p);\n  return d;\n}\n\nvec3 color(vec2 p) {\n  float aa   = 2.0/RESOLUTION.y;\n  const float lw = 0.0235;\n  const float lh = 1.25;\n\n  const vec3 lp1 = vec3(0.5, lh, 0.5);\n  const vec3 lp2 = vec3(-0.5, lh, 0.5);\n\n  float d = df(p);\n\n  float b = -0.125;\n  float t = 10.0;\n\n  vec3 ro = vec3(0.0, t, 0.0);\n  vec3 pp = vec3(p.x, 0.0, p.y);\n\n  vec3 rd = normalize(pp - ro);\n\n  vec3 ld1 = normalize(lp1 - pp);\n  vec3 ld2 = normalize(lp2 - pp);\n\n  float bt = -(t-b)/rd.y;\n  \n  vec3 bp   = ro + bt*rd;\n  vec3 srd1 = normalize(lp1-bp);\n  vec3 srd2 = normalize(lp2-bp);\n  float bl21= L2(lp1-bp);\n  float bl22= L2(lp2-bp);\n\n  float st1= (0.0-b)/srd1.y;\n  float st2= (0.0-b)/srd2.y;\n  vec3 sp1 = bp + srd1*st1;\n  vec3 sp2 = bp + srd2*st1;\n\n  float sd1= df(sp1.xz);\n  float sd2= df(sp2.xz);\n\n  vec3 col  = vec3(0.0);\n  const float ss =15.0;\n  \n  col       += vec3(1.0)*(1.0-exp(-ss*(max((sd1+0.0*lw), 0.0))))/bl21;\n  col       += vec3(0.5)*(1.0-exp(-ss*(max((sd2+0.0*lw), 0.0))))/bl22;\n  col       = mix(col, vec3(1.0), smoothstep(-aa, aa, -d));  \n  return col;\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(1.0/2.2)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // saturation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  \n  vec3 col = color(p);\n  \n  col = postProcess(col, q);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3fzH.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[0, 644, 692, 692, 962], [964, 964, 1007, 1007, 1095], [1097, 1097, 1142, 1142, 1370], [1372, 1372, 1403, 1403, 1427], [1429, 1429, 1458, 1458, 1523], [1525, 1525, 1543, 1543, 2032], [2034, 2034, 2056, 2056, 2100], [2102, 2102, 2123, 2123, 2168], [2170, 2170, 2215, 2215, 2369], [2371, 2371, 2432, 2432, 2645], [2647, 2647, 2668, 2668, 2889], [2890, 2890, 2908, 2908, 2944], [2946, 2946, 2966, 2966, 3970], [3972, 3972, 4009, 4009, 4262], [4264, 4264, 4319, 4319, 4509]], "test": "error"}
{"id": "tlBfzz", "name": "Fyrecean Ray Tracer", "author": "Fyrecean", "description": "A simple ray sphere ray tracer", "tags": ["raytracing"], "likes": 2, "viewed": 58, "published": "Public", "date": "1614075799", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define far 1000.\n#define bg vec3(.1,.1,.1)\n#define n 4\n\nstruct Hit {\n    float t;\n    vec3 pos;\n    vec3 normal;\n    vec3 color;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nstruct Sphere {\n    vec3 center;\n    float rad;\n    vec3 color;\n};\n\nstruct Light {\n    vec3 dir;\n};\n\n// Create direcitonal light\nLight light = Light(normalize(vec3(1.,-0.2,1.)));\n\n// Find the intersection between a ray and a sphere\nHit intersectSphere(Sphere sphere, Ray ray) {\n    vec3 origin = ray.origin - sphere.center;\n    float od = dot(origin, ray.dir);\n    float sqr = (od * od) - dot(origin, origin) + (sphere.rad * sphere.rad);\n    if (sqr < 0.) {\n        return Hit(far, vec3(0.), vec3(0.), vec3(0.));\n    }\n    float root = sqrt(sqr);\n    float t = min(-od - root, -od + root);\n    vec3 pos = ray.origin + (t * ray.dir);\n    return Hit(t, pos, normalize(pos - sphere.center), sphere.color);\n}\n\n// Find closest object intersected\nHit raytrace(Sphere[n] objects, Ray startRay) {\n    Hit closest = Hit(far, vec3(0.), vec3(0.), vec3(1.));\n    for (int i = 0; i < n; i++) {\n        Hit hit = intersectSphere(objects[i], startRay);\n        if (hit.t > .001 && hit.t < closest.t) {\n            closest = hit;\n        }\n    }\n    \n    return closest;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Place spheres in scene\n    Sphere[n] objects = Sphere[n](\n        Sphere(vec3(-4.,1. + sin(iTime + .5), -5.), 1., vec3(1., 0., 0.)),\n        Sphere(vec3(0.,1., -6. + sin(iTime * .95)), 2., vec3(1., 0., 1.)),\n        Sphere(vec3(4.,1. + cos(iTime * 1.05), -5.), 1., vec3(0., 1., 0.)),\n        Sphere(vec3(0.,-10, -5.), 10., vec3(0., 1., 1.))\n    );\n\n    // Convert pixel coordinates to screen space coordiantes\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n    \n    // Create ray from camera (at origin) through pixel\n    Ray v = Ray(vec3(0.), normalize(vec3(uv, -1.)));\n\n    // Initialize array to store color data for each reflection\n    vec3[3] colors = vec3[3](bg, bg, bg);\n    \n    for (int i = 0; i < 3; i++) {\n        // Get closest intersection\n        Hit hit = raytrace(objects, v);\n        if (hit.t == far) {\n            // If ray hit background, stop\n            break;\n        }\n        \n        // Check if ray is in shadow\n        Ray shadow = Ray(hit.pos, light.dir);\n        if (raytrace(objects, shadow).t < far) {\n            hit.color /= 4.;\n        }\n        \n        // Create shading using Lambertian model\n        colors[i] = hit.color * max(0., dot(light.dir, hit.normal));\n        \n        // Create a new ray that bounces off the surface of the intersection\n        v = Ray(hit.pos, reflect(v.dir, hit.normal));\n    }\n    // Combine all the colors\n    vec3 color = colors[0] * .5 + (colors[1] * .5 + colors[2] * .5) * .5;\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlBfzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[362, 414, 459, 459, 886], [888, 923, 970, 970, 1238], [1240, 1240, 1297, 1326, 2909]], "test": "valid"}
{"id": "tlcBR2", "name": "Wave sim with mouse", "author": "Kuba_S", "description": "interactive simulation", "tags": ["waves", "interactive", "physics"], "likes": 0, "viewed": 43, "published": "Public", "date": "1613056465", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Two sources of waves\n//Points A and B\n//all values have to have a decimal point (float)\n\n//point A\nconst float aX = 0.0;   //  X value of point A\nconst float aY = 0.0;    //  Y value of point A\n\nconst float brightness = 0.85;\n\n\n\n//wave properties\nconst float speed = 10.0;    //  how quickly waves propagate forwards\nconst float wavelength = 0.4;//  wavelength \n// ALL VALUES HAVE TO HAVE A DECIMAL POINT!!!!!\n\n// red = peak\n// green = trough\n\n\nfloat getDis(float x, float y,float xA,float yA){\n    return pow(\n    (pow((x-xA),2.)+pow((y-yA),2.))\n    ,0.5);\n    }\n    \nfloat getHeight(float x, float y,float xA,float yA,float wl,float t){\n    return sin((wl*t-6.28318530718*(getDis(x,y,xA,yA)/wl)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    \n \n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    \n    vec2 uvMouse = iMouse.xy/iResolution.xy;\n    uvMouse = uvMouse * 2.0 - 1.0;\n    uvMouse.x *= iResolution.x / iResolution.y;\n    \n    float bX = uvMouse.x;\n    float bY = uvMouse.y;\n    \n    float t = iTime*speed;\n    float col = ((\n    ((\n    getHeight(uv.x,uv.y,aX,aY,wavelength,t)+\n    getHeight(uv.x,uv.y,bX,bY,wavelength,t)\n    +2.)/4.) // change from range -2 - 2 to range 0 - 1\n    \n    ));\n\n    float red;\n    float grn;\n    if(col > 0.5){\n        grn = 2.0 - (2.0 * col);\n        red = 1.0;\n    }\n    if(col <= 0.5){\n        grn = 1.0;\n        red = (2.0*col);\n    }\n    fragColor = vec4(red*brightness,grn*brightness,0.0, 1.0);        \n    \n    if(getDis(uv.x,uv.y,aX,aY)<0.02){\n        fragColor = vec4(1.,0.,1., 1.0);\n    }\n    if(getDis(uv.x,uv.y,bX,bY)<0.02){\n        fragColor = vec4(1.,0.,1., 1.0);\n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcBR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[413, 447, 496, 496, 565], [571, 571, 640, 640, 703], [705, 705, 762, 762, 1719]], "test": "valid"}
{"id": "tlcBRH", "name": "modulo_n_001", "author": "catafest", "description": "Given two positive numbers a and n, a modulo n (abbreviated as a mod n) is the remainder of the Euclidean division of a by n, where a is the dividend and n is the divisor. ", "tags": ["math", "division", "turcoaz"], "likes": 0, "viewed": 202, "published": "Public API", "date": "1612212510", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// modulo with tree colors \nvoid mainImage(out vec4 O, vec2 U) {\n    U += U - iResolution.xy;\n    O = vec4(\n    int(iTime - atan(U.y, U.x)) / ivec2(1,7) % 6,\n    int(iTime - atan(U.y, U.x)) / ivec2(0,2) % 3\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcBRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 28, 64, 64, 215]], "test": "error"}
{"id": "tlcBW2", "name": "Distance to Triangle Wave", "author": "oneshade", "description": "Exact distance to a triangle wave.", "tags": ["2d", "distancefield", "sdf", "distance", "periodic", "trianglewave", "exact"], "likes": 6, "viewed": 111, "published": "Public", "date": "1613455762", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float udTriangleWave(in vec2 p, in float freq, in float amp) {\n    float pw = 1.0 / freq, qw = 0.25 * pw;\n    vec2 sc = vec2(2.0 * amp, pw);\n    float l = length(sc);\n    p.x = abs(mod(p.x + qw, pw) - 0.5 * pw) - qw;\n    p *= mat2(sc, -sc.y, sc.x) / l;\n    return length(vec2(p.x, max(0.0, abs(p.y) - 0.25 * l)));\n}\n\nfloat sdTriangleWave(in vec2 p, in float freq, in float amp) {\n    float pw = 1.0 / freq, qw = 0.25 * pw;\n    vec2 sc = vec2(2.0 * amp, pw);\n    float l = length(sc);\n    p.x = abs(mod(p.x + qw, pw) - 0.5 * pw) - qw;\n    p *= mat2(sc, -sc.y, sc.x) / l;\n    return length(vec2(p.x, max(0.0, abs(p.y) - 0.25 * l))) * sign(p.x);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n    float time = iTime * 2.0;\n\n    float freq = 5.125 + 4.875 * sin(iTime);\n    float amp = 0.5 + 0.5 * cos(iTime);\n    if (iMouse.z > 0.0) {\n        freq = 1.0 / abs(mouse.x);\n        amp = mouse.y * 2.0;\n        uv.x *= sign(mouse.x);\n    }\n\n    float d = int(iTime * 0.25) % 2 == 0 ? udTriangleWave(uv, freq, amp) : sdTriangleWave(uv, freq, amp);\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(d) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 1.0 - exp(-4.0 * abs(d));\n\tcolor *= 0.8 + 0.2 * cos(140.0 * d);\n\tcolor = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(d)));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcBW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 62, 62, 315], [317, 317, 379, 379, 644], [646, 646, 701, 701, 1499]], "test": "valid"}
{"id": "tlcBW4", "name": "Genuary 2021 – 08 – Inter (A)", "author": "endymion", "description": "Genuary 2021 – 08 – Interference Patterns (A)\n\nSlightly more dynamic (more circles) version here: https://www.shadertoy.com/view/3ttfWN", "tags": ["trippy", "interferencepatterns"], "likes": 0, "viewed": 40, "published": "Public", "date": "1612728379", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n#define PI 3.14159265359\n\n#define CIRCLES 2\n\n/**\n * Map range to new range\n */\nfloat map(float value, float min1, float max1, float min2, float max2) {\n    return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\n/**\n * Simplex noise\n * @src https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83#simplex-noise\n */\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat snoise(vec2 v){\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return map(130.0 * dot(m, g), -1., 1., 0., 1.);\n}\n\n/** \n * Circle distance function\n * @src https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n */\nfloat sdCircle(in vec2 point, in vec2 center, in float radius) {\n    return distance(point, center) / radius;\n}\n \n/**\n * HSB to RGB\n * All components are in the range [0…1], including hue.\n * @src https://stackoverflow.com/a/17897228\n */\nvec3 hsb2rgb(in vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n/** \n * Get color\n */\nvec3 getColor(in vec2 point, in vec2 centerA, in vec2 centerB, in vec3 colorA, in vec3 colorB) {\n    float distA = distance(point, centerA);\n    float distB = distance(point, centerB);\n    \n    float dist;\n    dist = distA / (distB + distA);\n    return mix(colorA, colorB, dist);\n}\n\n/**\n * @main\n */\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 centerA = vec2(\n        snoise(vec2(2.25, 2.5) * iTime * .005),\n        snoise(vec2(3.25, 0.5) * iTime * .0010)\n    );\n    vec2 centerB = vec2(\n        snoise(vec2(20., 2000.) + vec2(0.25, 2.5) * iTime * .008),\n        snoise(vec2(2000., 20.) + vec2(1.75, 0.5) * iTime * .0015)\n    );\n    \n    float distA = sdCircle(uv, centerA, 0.05 + 0.25 * sin(iTime * 0.025));\n    float distB = sdCircle(uv, centerB, 0.25 + 0.125 * sin(iTime * 0.1));\n    \n    vec3 colorA = vec3(0.75 + 0.25 * cos(iTime * 0.1), 0.5, 0.5);\n    vec3 colorB = vec3(0.25 + 0.125 * cos(iTime), 0.5, 0.5);\n    //vec3 colorA = vec3(0.65 + 0.25 * cos(iTime * 0.1), 0.5, 0.5);\n    //vec3 colorB = vec3(0.85 + 0.125 * cos(iTime), 0.5, 0.5);\n    vec3 color = getColor(uv, centerA, centerB, colorA, colorB);\n    \n    float pattern = smoothstep(0.2, 0.9, fract(distA) + fract(distB));\n    float pixelNoise = snoise(uv * 300.);\n    \n    fragColor = vec4(hsb2rgb(vec3(\n        color.x + pattern * .15,\n        color.y,\n        1. - pixelNoise * 0.05\n    )), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcBW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 81, 153, 153, 221], [223, 336, 358, 358, 397], [399, 399, 420, 420, 1262], [1264, 1385, 1449, 1449, 1496], [1499, 1625, 1650, 1650, 1819], [1821, 1843, 1939, 1939, 2124], [2126, 2143, 2198, 2198, 3279]], "test": "valid"}
{"id": "tlcBWH", "name": "Tunneling through apollian frac", "author": "mrange", "description": "Licence CC0: Tunneling through apollian fractals\nThe result of a few hours of saturday coding", "tags": ["2d", "apollian"], "likes": 17, "viewed": 340, "published": "Public API", "date": "1612623360", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Licence CC0: Tunneling through apollian fractals\n//  The result of a few hours of saturday coding\n\n// -----------------------------------------------------------------------------\n// COMMON\n// -----------------------------------------------------------------------------\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PSIN(x)         (0.5+0.5*sin(x))\n#define LESS(a,b,c)     mix(a,b,step(0.,c))\n#define SABS(x,k)       LESS((.5/(k))*(x)*(x)+(k)*.5,abs(x),abs(x)-(k))\n#define L2(x)           dot(x, x)\n\nconst vec3 std_gamma        = vec3(2.2, 2.2, 2.2);\n\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\nfloat modMirror1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize,size) - halfsize;\n  p *= mod(c, 2.0)*2.0 - 1.0;\n  return c;\n}\n\nfloat smoothKaleidoscope(inout vec2 p, float sm, float rep) {\n  vec2 hp = p;\n\n  vec2 hpp = toPolar(hp);\n  float rn = modMirror1(hpp.y, TAU/rep);\n\n  float sa = PI/rep - SABS(PI/rep - abs(hpp.y), sm);\n  hpp.y = sign(hpp.y)*(sa);\n\n  hp = toRect(hpp);\n\n  p = hp;\n\n  return rn;\n}\n\nvec4 alphaBlend(vec4 back, vec4 front) {\n  float w = front.w + back.w*(1.0-front.w);\n  vec3 xyz = (front.xyz*front.w + back.xyz*back.w*(1.0-front.w))/w;\n  return w > 0.0 ? vec4(xyz, w) : vec4(0.0);\n}\n\nvec3 alphaBlend(vec3 back, vec4 front) {\n  return mix(back, front.xyz, front.w);\n}\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0);\n  \n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat apollian(vec4 p, float s) {\n  float scale = 1.0;\n\n  for(int i=0; i<7; ++i) {\n    p = -1.0 + 2.0*fract(0.5*p+0.5);\n\n    float r2 = dot(p,p);\n    \n    float k  = s/r2;\n    p       *= k;\n    scale   *= k;\n  }\n  \n  return abs(p.y)/scale;\n}\n\nvec2 mod2_1(inout vec2 p) {\n  vec2 c = floor(p + 0.5);\n  p = fract(p + 0.5) - 0.5;\n  return c;\n}\n\nfloat hex(vec2 p, float r) {\n  const vec3 k = vec3(-sqrt(3.0)/2.0,1.0/2.0,sqrt(3.0)/3.0);\n  p = p.yx;\n  p = abs(p);\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  return length(p)*sign(p.y);\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// -----------------------------------------------------------------------------\n// PATH\n// -----------------------------------------------------------------------------\n\n// The path function\nvec3 offset(float z) {\n  float a = z;\n  vec2 p = -0.10*(vec2(cos(a), sin(a*sqrt(2.0))) + vec2(cos(a*sqrt(0.75)), sin(a*sqrt(0.5))));\n  return vec3(p, z);\n}\n\n// The derivate of the path function\n//  Used to generate where we are looking\nvec3 doffset(float z) {\n  float eps = 0.1;\n  return 0.5*(offset(z + eps) - offset(z - eps))/eps;\n}\n\n// The second derivate of the path function\n//  Used to generate tilt\nvec3 ddoffset(float z) {\n  float eps = 0.1;\n  return 0.125*(doffset(z + eps) - doffset(z - eps))/eps;\n}\n\n// -----------------------------------------------------------------------------\n// PLANE MARCHER\n// -----------------------------------------------------------------------------\n\nfloat weird(vec2 p, float h) {\n  float z = 4.0;\n  float tm = 0.1*TIME+h*10.0;\n  p *= ROT(tm*0.5);\n  float r = 0.5;\n  vec4 off = vec4(r*PSIN(tm*sqrt(3.0)), r*PSIN(tm*sqrt(1.5)), r*PSIN(tm*sqrt(2.0)), 0.0);\n  vec4 pp = vec4(p.x, p.y, 0.0, 0.0)+off;\n  pp.w = 0.125*(1.0-tanh_approx(length(pp.xyz)));\n  pp.yz *= ROT(tm);\n  pp.xz *= ROT(tm*sqrt(0.5));\n  pp /= z;\n  float d = apollian(pp, 0.8+h);\n  return d*z;\n}\n\nfloat circles(vec2 p) {\n  vec2 pp = toPolar(p);\n  const float ss = 0.25;\n  pp.x = fract(pp.x*ss)/ss;\n  p = toRect(pp);\n  float d = circle(p, 1.0);\n  return d;\n}\n\nfloat onionize(float d) {\n  d = abs(d) - 0.02;\n  d = abs(d) - 0.005;\n  d = abs(d) - 0.0025;\n  return d;\n}\n\nvec2 df(vec2 p, float h) {\n  vec2 wp = p;\n  float rep = 10.0;\n  float ss = 0.05*6.0/rep;\n  float n = smoothKaleidoscope(wp, ss, rep);\n  \n  float d0 = weird(wp, h);\n  d0 = onionize(d0);\n  float d1 = hex(p, 0.25)-0.1;\n  float d2 = circles(p);\n  const float lw = 0.0125;\n  d2 = abs(d2)-lw;\n  float d  = pmin(pmin(d0, d2, 0.1), abs(d1)-lw, 0.05);\n  return vec2(d, d1+lw);\n}\n\n// Plane generating function returns rgba\n//  pp is point on plane\n//  off is path at plane z\n//  aa is estimated pixel size at the plane\n//  n is plane number\nvec4 plane(vec3 ro, vec3 rd, vec3 pp, vec3 off, float aa, float n) {\n  float h = hash(n);\n  float s = 0.25*mix(0.5, 0.25, h);\n  float dd= length(pp-ro);\n\n  const vec3 nor  = vec3(0.0, 0.0, 1.0);\n  const vec3 loff = vec3(0.25*0.5, 0.125*0.5, -0.125);\n  vec3 lp1  = ro + loff;\n  vec3 lp2  = ro + loff*vec3(-1.0, 1.0, 1.0);\n  vec3 ld1  = normalize(pp - lp1);\n  vec3 ld2  = normalize(pp - lp2);\n  float lpw1= 0.2/L2(pp - lp1);\n  float lpw2= 0.2/L2(pp - lp2);\n  vec3 ref  = reflect(rd, nor);\n  float ref1= pow(max(dot(nor, ld1), 0.0), 20.0);\n  float ref2= pow(max(dot(nor, ld2), 0.0), 20.0);\n  vec3  col1= vec3(0.75, 0.5, 1.0);\n  vec3  col2= vec3(1.0, 0.5, 0.75);\n  \n  vec3 hn;\n  vec2 p = (pp-off*vec3(1.0, 1.0, 0.0)).xy;\n  p *= ROT(TAU*h);\n  vec2 d2 = df(p/s, h)*s;   \n\n  float ha = smoothstep(-aa, aa, d2.y);\n  float d = d2.x;\n  vec4 col = vec4(0.0);\n\n  float l   = length(10.0*p);\n  float ddf = 1.0/((1.0+2.0*dd));\n  float hue = fract(0.75*l-0.1*TIME)+0.3+0.15;\n  float sat = 0.75*tanh_approx(2.0*l)*ddf;\n  float vue = sqrt(ddf);\n  vec3 hsv  = vec3(hue, sat, vue);\n  vec3 bcol = hsv2rgb(hsv);\n  col.xyz   = mix(col.xyz, bcol, smoothstep(-aa, aa, -d));  \n  float glow = (exp(-(10.0+100.0*tanh_approx(l))*10.0*max(d, 0.0)*ddf));\n  col.xyz   += 0.5*sqrt(bcol.zxy)*glow;\n  col.w     = ha*mix(0.75, 1.0, ha*glow);\n  col.xyz   += 0.125*col.w*(col1*ref1+col2*ref2);\n\n  return col;\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  float ld = max(dot(rd, vec3(0.0, 0.0, 1.0)), 0.0);\n  return 1.25*vec3(1.0, 0.75, 0.85)*vec3(tanh_approx(3.0*pow(ld, 100.0)));\n}\n\nvec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p) {\n  float lp = length(p);\n  vec2 np = p + 1.0/RESOLUTION.xy;\n  float rdd = (2.0+0.5*tanh_approx(lp));  // Playing around with rdd can give interesting distortions\n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n  vec3 nrd = normalize(np.x*uu + np.y*vv + rdd*ww);\n\n  const float planeDist = 1.0-0.75;\n  const int furthest = 8;\n  const int fadeFrom = max(furthest-3, 0);\n  const float fadeDist = planeDist*float(furthest - fadeFrom);\n  float nz = floor(ro.z / planeDist);\n\n  vec3 skyCol = skyColor(ro, rd);\n\n  // Steps from nearest to furthest plane and accumulates the color\n\n  vec4 acol = vec4(0.0);\n  const float cutOff = 0.95;\n  bool cutOut = false;\n  \n  for (int i = 1; i <= furthest; ++i) {\n    float pz = planeDist*nz + planeDist*float(i);\n\n    float pd = (pz - ro.z)/rd.z;\n\n    if (pd > 0.0 && acol.w < cutOff) {\n      vec3 pp = ro + rd*pd;\n      vec3 npp = ro + nrd*pd;\n\n      float aa = 3.0*length(pp - npp);\n\n      vec3 off = offset(pp.z);\n\n      vec4 pcol = plane(ro, rd, pp, off, aa, nz+float(i));\n\n      float nz = pp.z-ro.z;\n      float fadeIn = exp(-2.5*max((nz - planeDist*float(fadeFrom))/fadeDist, 0.0));\n      float fadeOut = smoothstep(0.0, planeDist*0.1, nz);\n      pcol.xyz = mix(skyCol, pcol.xyz, (fadeIn));\n      pcol.w *= fadeOut;\n\n      pcol = clamp(pcol, 0.0, 1.0);\n\n      acol = alphaBlend(pcol, acol);\n    } else {\n      cutOut = true;\n      break;\n    }\n\n  }\n\n  vec3 col = alphaBlend(skyCol, acol);\n// To debug cutouts due to transparency  \n//  col += cutOut ? vec3(1.0, -1.0, 0.0) : vec3(0.0);\n  return col;\n}\n\n// Classic post processing\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, 1.0/std_gamma);\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  float tm  = TIME*0.2;\n  vec3 ro   = offset(tm);\n  vec3 dro  = doffset(tm);\n  vec3 ddro = ddoffset(tm);\n\n  vec3 ww = normalize(dro);\n  vec3 uu = normalize(cross(normalize(vec3(0.0,1.0,0.0)+ddro), ww));\n  vec3 vv = normalize(cross(ww, uu));\n\n  vec3 col = color(ww, uu, vv, ro, p);\n  col = postProcess(col, q);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect(p, q);\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcBWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 716, 738, 738, 786], [788, 788, 810, 810, 854], [856, 856, 877, 877, 922], [924, 924, 969, 969, 1123], [1125, 1125, 1186, 1186, 1399], [1401, 1401, 1441, 1441, 1600], [1602, 1602, 1642, 1642, 1684], [1686, 1686, 1714, 1734, 1810], [1812, 1812, 1851, 1851, 1940], [1942, 1942, 1964, 1964, 2133], [2135, 2135, 2168, 2168, 2376], [2378, 2378, 2405, 2405, 2474], [2476, 2476, 2504, 2504, 2704], [2706, 2706, 2737, 2737, 2763], [2936, 2957, 2979, 2979, 3112], [3114, 3193, 3216, 3216, 3291], [3293, 3363, 3387, 3387, 3466], [3468, 3648, 3678, 3678, 4054], [4056, 4056, 4079, 4079, 4216], [4218, 4218, 4243, 4243, 4323], [4325, 4325, 4351, 4351, 4694], [4696, 4856, 4924, 4924, 6229], [6231, 6231, 6264, 6264, 6394], [6396, 6396, 6452, 6452, 7991], [7993, 8020, 8056, 8056, 8289], [8291, 8291, 8320, 8320, 8646], [8648, 8648, 8703, 8703, 8861]], "test": "error"}
{"id": "tlcBzS", "name": "Fractal 21_gaz", "author": "gaz", "description": "3d", "tags": ["fractal"], "likes": 14, "viewed": 126, "published": "Public", "date": "1613000990", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 r=iResolution,p;  \n    for(float i=0.,g=1.,e,s;\n        ++i<99.;\n        e<.004?O.xyz+=mix(\n                r/r,\n                cos(vec3(1,2,3)+log(s)*10.)*.5+.5,\n                .8\n            )*.5/i:p\n    )\n    {\n        p=vec3(g*(C-.5*r.xy)/r.y,g-10.);\n        p=R(p,normalize(R(vec3(1,2,3),vec3(.577),iTime*.3)),iTime*.1);\n        s=2.;\n        p.y=abs(p.y);\n        for(int j=0;++j<7;)\n            p.xz=abs(p.xz)-2.3,\n            p.z>p.x?p=p.zyx:p,\n            p.z=1.5-abs(p.z-1.3+sin(p.z)*.2),\n            p.y>p.x?p=p.yxz:p,\n            p.x=3.-abs(p.x-5.+sin(p.x*3.)*.2),\n            p.y>p.x?p=p.yxz:p,\n            p.y=.9-abs(p.y-.4),\n            e=12.*clamp(.3/min(dot(p,p),1.),.0,1.)+\n            2.*clamp(.1/min(dot(p,p),1.),.0,1.),\n            p=e*p-vec3(7,1,1),\n            s*=e;\n        g+=e=length(p)/s;\n    }\n    O=pow(O,vec4(1.5,2,1.2,1));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcBzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 95, 95, 977]], "test": "valid"}
{"id": "tlcfRX", "name": "Simple Fireworks", "author": "moranzcw", "description": "Fireworks.", "tags": ["2d", "random", "fireworks"], "likes": 4, "viewed": 210, "published": "Public API", "date": "1613219973", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Simple Fireworks - by moranzcw - 2021\n// Email: moranzcw@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n#define Gravitational_ACCE vec2(0, -0.2)\n#define NumSpark 30.0\n#define NumFirework 5.0\n#define Period 5.0\n\nfloat rand(float co)\n{ \n    return fract(sin(co*(91.3458)) * 47453.5453);\n}\n\n\nvec3 spark(vec2 coord, vec2 origin, vec3 sparkColor, vec2 velocity, float periodTime, float seed)\n{\n    vec2 displacement = velocity * periodTime + 0.5 * Gravitational_ACCE * periodTime * periodTime;\n    vec2 sparkPos = origin + displacement;\n    float len = length(coord - sparkPos);\n    \n    // glow color\n    vec3 color = sparkColor * pow(smoothstep(0.05, 0.001, len),8.0);\n    // core color\n    color += vec3(1.0) * smoothstep(0.005, 0.001, len);\n    // attenuation\n    color *= smoothstep(Period, 0.0, periodTime);\n    // twinkle\n    color *= sin(periodTime*50.0 + seed)*0.4 + 0.6;\n    return color;\n}\n\nvec3 firework(vec2 coord, float currentPeriod, float periodTime)\n{   \n    vec2 origin;\n    origin.x = (0.2 + 0.6*rand(currentPeriod)) * iResolution.x/iResolution.y ;\n    origin.y = (0.4 + 0.4*rand(currentPeriod));\n\n    vec3 color = vec3(0.0);\n    for(float i=0.0; i < NumSpark; i++) \n    {\n        vec2 velocity;\n        velocity.x = 0.5*(rand(currentPeriod+i*0.4)-0.5);\n        velocity.y = 0.5*(rand(currentPeriod+i*0.5)-0.5);\n        velocity = normalize(velocity);\n        velocity *= 0.2 + rand(currentPeriod+i*0.6) * 0.3;\n        \n        vec3 sparkColor;\n        sparkColor.r = 0.3+0.7*rand(currentPeriod+i*0.1);\n        sparkColor.g = 0.3+0.7*rand(currentPeriod+i*0.2);\n        sparkColor.b = 0.3+0.7*rand(currentPeriod+i*0.3);\n        color += spark(coord, origin, sparkColor, velocity, periodTime, i);\n    }\n    return color;\n}\n\nvec3 background(float yCoord) \n{\t    \n    return mix(vec3(0.1515, 0.2375, 0.5757), vec3(0.0546, 0.0898, 0.1953), yCoord);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = fragCoord/iResolution.y;\n\n    vec3 color = vec3(0.0f);\n    for(float i=0.0; i < NumFirework; i++)\n    {\n        float timeOffset = Period / NumFirework * (0.5 + rand(i));\n        float time = iTime + i*timeOffset;\n        float periodTime = mod(time,Period);\n        \n        float periodOffset = i*10.0; // for random\n        float currentPeriod = floor(time/Period + periodOffset);\n        \n        color += firework(coord, currentPeriod, periodTime);\n    }\n    color = background(coord.y)+color;\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcfRX.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 266, 288, 288, 341], [344, 344, 443, 443, 950], [952, 952, 1018, 1018, 1789], [1791, 1791, 1823, 1823, 1914], [1917, 1917, 1974, 1974, 2525]], "test": "valid"}
{"id": "tlcfWX", "name": "AO (Ambient Occlusion)", "author": "moranzcw", "description": "A brute force AO.", "tags": ["raytracing", "raycast", "ao"], "likes": 8, "viewed": 409, "published": "Public API", "date": "1613566769", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// AO (Ambient Occlusion) - by moranzcw - 2021\n// Email: moranzcw@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define Epsilon 1e-2\n#define PI 3.14159265359\n#define Samples 48.0\n#define AOradius 2.5\n\n// --------------------------------------\n// oldschool rand() from Visual Studio\n// --------------------------------------\nint   seed = 1;\nvoid  srand(int s ) { seed = s; }\nint   rand(void)  { seed=seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\n// --------------------------------------\n// hash by Hugo Elias\n// --------------------------------------\nint hash( int n ) { n=(n<<13)^n; return n*(n*n*15731+789221)+1376312589; }\n\nstruct Ray \n{ \n    vec3 origin, direction;\n};\n\nstruct Sphere \n{\n\tfloat radius;\n\tvec3 position;\n};\n\nSphere spheres[4];\n\nvoid initSpheres()\n{\n    spheres[0] = Sphere(0.5, vec3(-1.7, 0.5, -1.6));\n    spheres[1] = Sphere(1.0, vec3(1.8, 1.0, -0.5));\n    spheres[2] = Sphere(2.0, vec3(0.0, 2.0, -2.8));\n    spheres[3] = Sphere(1000.0, vec3(0.0, -1000.0, 0.0));\n}\n\nfloat intersect(Sphere sphere, Ray ray)\n{\n\tvec3 op = sphere.position - ray.origin;\n\tfloat t1, t2 = Epsilon;\n    float b = dot(op, ray.direction);\n    float det = b * b - dot(op, op) + sphere.radius * sphere.radius;\n    \n\tif (det < 0.0)\n        return 0.0;\n    else\n        det = sqrt(det);\n    \n    t1 = b - det;\n    t2 = b + det;\n    if(t1 > Epsilon)\n        return t1;\n    if(t2 > Epsilon)\n        return t2;\n    return 0.0;\n}\n\nRay cameraRay(vec3 camPosition, vec3 lookAt, vec2 fragCoord)\n{\n    vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n\n    vec3 cz = normalize(lookAt - camPosition);\n\tvec3 cx = normalize(cross(cz, vec3(0.0, 1.0, 0.0)));\n\tvec3 cy = normalize(cross(cx, cz));\n    \n    return Ray(camPosition, normalize(0.53135 * (iResolution.x/iResolution.y*uv.x * cx + uv.y * cy) + cz));\n}\n\nvec3 hemiSpherePoint(vec3 normal)\n{\n    float theta = 2.0 * PI * frand();\n    float cosPhi = frand();\n    float sinPhi = sqrt(1.0-cosPhi*cosPhi);\n    \n    vec3 zAxis = normal;\n    vec3 xAxis = normalize(cross(normal, vec3(1.0, 0.0, 0.0)));\n    vec3 yAxis = normalize(cross(normal, xAxis));\n    \n    vec3 x = cos(theta) * xAxis;\n    vec3 y = sin(theta) * yAxis;\n    vec3 horizontal = normalize(x + y) * sinPhi;\n    vec3 z = cosPhi * zAxis;\n    vec3 p = horizontal + z;\n    \n    return p;\n}\n\nfloat AO(vec3 point, vec3 normal)\n{\n    float li = 0.0;\n    float count = 0.0;\n    for(float i=0.0; i<Samples; i++)\n    {\n        Ray ray = Ray(point, hemiSpherePoint(normal));\n        \n        float t = 1e10;\n        for(int i=0; i<4; i++)\n        {\n            float temp = intersect(spheres[i], ray);\n            t = step(Epsilon, temp) * min(temp, t) + step(temp, Epsilon) * t;\n        }\n        li += dot(ray.direction, normal) * smoothstep(0.0, AOradius, t);\n        count += dot(ray.direction, normal);\n    }\n    return sqrt(li / count);\n}\n\nvec3 background(float yCoord) \n{\t    \n    return mix(vec3(0.1515, 0.2375, 0.5757), vec3(0.0546, 0.0898, 0.1953), yCoord);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    // init random seed\n    ivec2 q = ivec2(fragCoord);\n    srand( hash(q.x+hash(q.y+hash(1117*iFrame))));\n    \n    // init spheres\n    initSpheres();\n    \n    // camera ray\n    vec3 camPosition = mix(vec3(-2.0, 3.0, 6.0), vec3(2.0, 3.0, 6.0), sin(iTime*0.3));\n    vec3 lookAt = vec3(0.0, 2.0, 0.0);\n    Ray ray = cameraRay(camPosition, lookAt, fragCoord);\n    \n\tvec3 color=vec3(0.0);\n    \n    // intersect\n    float t = 1e10;\n    int id;\n    float hitAnything = 0.0;\n    for(int i=0; i<4; i++)\n    {\n        float temp = intersect(spheres[i], ray);\n        if(temp > Epsilon && temp < t)\n        {\n            t = temp;\n            id = i;\n            hitAnything = 1.0;\n        }\n    }\n    \n    // AO\n    float ao = 0.0;\n    if(hitAnything > 0.0)\n    {\n        vec3 point = ray.origin + t * ray.direction;\n        vec3 normal = normalize(point - spheres[id].position);\n        ao = AO(point, normal);\n    }\n    \n    color = mix(background(fragCoord.y/iResolution.y), vec3(.9)*ao, 1. - smoothstep(0., .99, t*t/1e3));;\n    \n    color = pow(color,vec3(1.0/2.2)); // gamma\n\tfragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcfWX.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[253, 392, 413, 413, 425], [426, 426, 445, 445, 500], [501, 501, 520, 520, 552], [553, 659, 678, 678, 733], [854, 854, 874, 874, 1091], [1093, 1093, 1134, 1134, 1521], [1523, 1523, 1585, 1585, 1894], [1896, 1896, 1931, 1931, 2384], [2386, 2386, 2421, 2421, 2932], [2934, 2934, 2966, 2966, 3057], [3059, 3059, 3117, 3141, 4221]], "test": "valid"}
{"id": "tlcfz7", "name": "neural head sdf (warning: heavy)", "author": "kylegrover", "description": "an extremely heavy demo of SDFs generated by AI, clocking in at 37.5 sec compile time and 32 fps on my 1080, due to the large net size (24,4) and my comically lazy copy-pasteing of the output code twice to average the halves\n\nbased on work by blackle mori", "tags": ["sdf", "head", "slow", "neural"], "likes": 8, "viewed": 245, "published": "Public", "date": "1612427156", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//like the last few shaders I've published, this is a neural network experiment.\n//this time, the neural network reproduces an SDF given the x,y,z coordinates\n//using siren networks with skip connections: https://vsitzmann.github.io/siren/\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat scene(vec3 p) {\n    //sdf is undefined outside the unit sphere, uncomment to witness the abominations\n    if (length(p) > 1.) {\n        return length(p)-.8;\n    }\n    p.y = -p.y;\n    //neural networks can be really compact... when they want to be\n    vec4 f0_0=sin(p.y*vec4(-.36,3.91,-3.69,4.22)+p.z*vec4(2.66,2.44,3.63,.17)+p.x*vec4(4.17,-3.60,2.72,3.83)+vec4(-4.46,5.05,5.55,3.40));\n    vec4 f0_1=sin(p.y*vec4(-1.06,.99,2.93,-2.01)+p.z*vec4(4.36,4.04,-3.04,3.80)+p.x*vec4(1.44,-.18,-3.28,3.02)+vec4(-4.20,-1.99,-6.45,-7.70));\n    vec4 f0_2=sin(p.y*vec4(1.32,-2.91,-3.22,2.16)+p.z*vec4(.47,1.89,4.12,-3.69)+p.x*vec4(1.70,2.75,-3.95,2.05)+vec4(7.41,7.30,-3.35,4.89));\n    vec4 f0_3=sin(p.y*vec4(-.10,-1.56,3.64,-3.34)+p.z*vec4(-3.91,-1.39,-3.21,-1.08)+p.x*vec4(3.88,1.33,-1.01,2.47)+vec4(-.38,-7.95,-1.31,2.00));\n    vec4 f0_4=sin(p.y*vec4(2.73,-4.30,3.91,3.05)+p.z*vec4(4.31,4.08,3.19,-.84)+p.x*vec4(2.73,2.84,-2.84,-.57)+vec4(.31,-3.00,-4.98,4.69));\n    vec4 f0_5=sin(p.y*vec4(1.47,-1.32,-1.36,-1.11)+p.z*vec4(-.58,-.16,4.40,.07)+p.x*vec4(1.70,.12,3.56,2.22)+vec4(-3.33,-3.22,.81,6.42));\n    vec4 f0_6=sin(p.y*vec4(2.95,-2.96,2.12,-3.19)+p.z*vec4(-2.98,-.25,-3.79,-2.67)+p.x*vec4(.03,2.63,-.60,3.66)+vec4(-5.86,-5.04,-.64,6.42));\n    vec4 f0_7=sin(p.y*vec4(.33,-2.89,-2.13,-.34)+p.z*vec4(-3.16,.97,3.91,1.84)+p.x*vec4(-.42,-3.11,-.39,-4.40)+vec4(6.18,-7.99,-1.16,-3.38));\n    vec4 f1_0=sin(mat4(.24,-.06,.27,-.20,.24,-.25,.19,-.28,-.18,.34,.14,-.09,.25,-.19,.17,-.30)*f0_0+\n        mat4(.00,.19,-.04,.08,-.02,-.20,.07,-.16,-.27,-.18,-.37,-.21,-.19,-.15,.15,.07)*f0_1+\n        mat4(.19,.03,-.25,.39,-.02,-.15,.03,.23,.09,.02,.07,-.05,-.20,.25,-.19,-.34)*f0_2+\n        mat4(-.27,-.31,-.05,-.15,-.02,-.04,-.12,.01,.20,-.33,-.15,-.07,-.05,.04,-.77,.15)*f0_3+\n        mat4(.17,.10,-.14,-.21,.30,.04,-.23,-.11,.11,-.13,.33,-.17,.11,.03,-.32,-.38)*f0_4+\n        mat4(.01,-.17,.16,-.02,.02,.22,-.11,.09,.00,-.01,.28,.02,.11,.20,.40,-.26)*f0_5+\n        mat4(-.33,.07,.20,-.08,-.22,.22,.07,.19,.27,-.32,-.23,-.08,.13,-.22,-.10,.01)*f0_6+\n        mat4(.01,-.22,.35,-.00,.19,.28,-.04,-.46,-.31,-.05,.24,-.24,-.30,-.33,-.01,.00)*f0_7+\n        vec4(-2.22,-.05,-.81,-.60))/1.0+f0_0;\n    vec4 f1_1=sin(mat4(.18,.12,.28,.64,.07,-.11,-.02,.11,-.33,-.50,-.14,-.11,-.57,-.17,.05,.15)*f0_0+\n        mat4(-.23,-.10,-.32,-.20,-.13,.24,.26,.23,-.18,.06,-.26,.39,-.12,.35,.04,.20)*f0_1+\n        mat4(.10,-.12,.14,.34,-.12,.04,.39,-.19,.25,.24,-.29,-.31,.11,.12,.07,-.20)*f0_2+\n        mat4(-.03,.08,-.17,-.16,.14,-.18,-.25,.06,-.08,.35,-.02,.33,.31,.09,-.10,-.10)*f0_3+\n        mat4(.14,-.36,-.12,-.67,.08,.04,.11,.19,.22,.43,-.21,-.21,-.11,.40,-.32,.25)*f0_4+\n        mat4(-.04,.13,-.01,.23,.29,.31,-.15,.08,-.30,-.24,-.38,-.16,-.25,-.40,.21,.06)*f0_5+\n        mat4(.29,-.13,.14,.09,.40,-.22,.24,-.43,.23,.42,-.07,.16,.04,-.20,.26,-.16)*f0_6+\n        mat4(-.03,.20,-.15,.34,-.27,-.20,.00,-.45,.05,.39,-.16,-.24,.25,.04,-.17,-.12)*f0_7+\n        vec4(1.74,-1.39,-.15,-.86))/1.0+f0_1;\n    vec4 f1_2=sin(mat4(-.54,.29,.36,.34,-.01,-.05,-.28,.16,.30,.25,-.34,.05,.21,.06,-.16,-.22)*f0_0+\n        mat4(.05,.31,-.43,.30,.21,-.25,-.05,-.04,-.33,-.06,.65,-.27,-.15,-.17,-.07,.19)*f0_1+\n        mat4(-.42,-.11,-.04,.29,-.06,-.26,.06,.21,-.12,.36,-.31,-.20,-.38,-.11,.20,-.19)*f0_2+\n        mat4(-.04,.28,.20,.33,.17,.12,-.48,-.04,-.34,-.24,-.01,-.09,-.20,.13,.47,-.28)*f0_3+\n        mat4(.23,.17,.37,.11,-.30,-.22,.42,-.20,.08,-.03,.36,-.40,.02,-.36,.13,-.04)*f0_4+\n        mat4(.01,.33,-.26,.16,-.21,-.21,.43,.01,.34,-.09,-.05,.12,.19,-.15,.34,.31)*f0_5+\n        mat4(-.43,.16,.22,-.14,-.12,.11,.27,.13,-.16,.08,.22,-.54,.19,-.02,-.32,.15)*f0_6+\n        mat4(-.38,-.25,.33,-.25,-.25,-.64,.30,-.23,.20,-.01,.25,.03,-.07,.47,-.02,-.11)*f0_7+\n        vec4(-1.57,1.30,1.31,-.69))/1.0+f0_2;\n    vec4 f1_3=sin(mat4(-.04,-.21,-.27,-.16,.38,.03,-.12,-.03,.32,.18,.27,-.25,-.43,.50,-.35,.13)*f0_0+\n        mat4(.37,.17,-.20,-.04,.40,-.59,.20,.39,.05,.14,-.17,-.20,.16,.18,.21,-.07)*f0_1+\n        mat4(.12,-.25,.40,-.46,-.36,-.16,-.11,.09,.26,-.48,.00,-.28,-.36,.21,-.11,-.01)*f0_2+\n        mat4(.13,-.20,-.06,-.25,.14,.29,-.31,.24,-.04,.29,.05,.16,-.18,.07,.28,-.28)*f0_3+\n        mat4(-.19,-.12,.33,-.12,.03,.32,-.03,.08,-.56,.19,.25,.08,.01,.32,.05,.14)*f0_4+\n        mat4(.55,-.02,.21,.13,-.26,.41,.02,-.29,.12,-.17,-.16,-.04,-.58,.10,.05,.20)*f0_5+\n        mat4(-.03,-.14,.13,.13,-.16,.19,.02,.09,-.34,.09,.02,.01,-.01,-.20,-.09,.13)*f0_6+\n        mat4(.19,-.19,-.17,.04,-.57,.08,.18,.32,.02,-.01,-.29,-.22,.22,.11,-.02,.04)*f0_7+\n        vec4(-2.23,.27,-.36,.14))/1.0+f0_3;\n    vec4 f1_4=sin(mat4(-.22,-.17,.03,.13,.20,.35,-.18,-.10,-.13,.31,-.29,.17,-.23,.23,.47,-.01)*f0_0+\n        mat4(.34,.19,.04,-.14,-.09,.48,.24,-.27,-.19,.29,-.06,.12,.16,-.18,.27,.06)*f0_1+\n        mat4(-.17,-.25,-.30,-.38,.15,-.18,.16,-.12,.21,-.18,.18,-.19,.25,.30,.11,.27)*f0_2+\n        mat4(.29,-.15,-.06,.07,-.19,-.00,.13,.14,.36,.11,.42,.21,.25,-.21,-.28,-.03)*f0_3+\n        mat4(.69,-.28,-.19,.01,-.03,-.05,-.09,-.02,-.01,.15,-.06,.02,.15,.24,.04,-.15)*f0_4+\n        mat4(-.26,.02,.21,-.45,.11,-.08,.14,.36,.19,-.32,-.05,-.17,.40,-.06,.12,-.01)*f0_5+\n        mat4(-.06,.39,-.00,.02,-.16,.09,-.18,-.20,.36,.32,-.07,.19,.12,-.26,-.10,.29)*f0_6+\n        mat4(-.38,.38,.16,-.04,.32,.04,-.08,.07,.34,.13,-.04,.08,.25,-.26,-.13,.02)*f0_7+\n        vec4(-.71,-1.58,-2.04,-.56))/1.0+f0_4;\n    vec4 f1_5=sin(mat4(.19,.20,-.43,-.12,.07,-.08,-.22,.18,.34,-.31,.29,.18,.16,.01,-.25,.13)*f0_0+\n        mat4(.25,.00,.02,-.13,-.14,.31,.30,.20,.22,-.11,.04,-.23,.17,-.19,-.18,-.16)*f0_1+\n        mat4(.30,.20,.13,-.43,.07,.03,.29,-.07,.36,.01,-.27,.24,-.35,-.15,.25,-.22)*f0_2+\n        mat4(-.02,-.04,.01,.25,.04,-.24,-.09,.38,.16,.14,.15,-.06,.33,.17,.11,-.04)*f0_3+\n        mat4(-.14,.05,.42,-.09,.13,-.04,.02,.20,-.02,-.29,-.46,.04,-.06,.08,-.19,.33)*f0_4+\n        mat4(.14,-.29,.08,-.31,-.20,.09,-.08,-.14,.01,.05,.18,-.08,-.39,-.04,.16,.20)*f0_5+\n        mat4(.00,-.01,-.26,.04,.05,.30,.12,-.18,.08,.44,-.05,-.40,.07,.48,-.11,.19)*f0_6+\n        mat4(.15,.13,-.13,.03,-.26,-.25,.01,-.32,-.26,-.16,-.09,-.04,-.06,-.37,-.25,.26)*f0_7+\n        vec4(-.39,1.49,-.68,-1.91))/1.0+f0_5;\n    vec4 f1_6=sin(mat4(.50,-.02,-.69,.07,.06,-.07,-.06,-.12,-.25,-.01,.36,-.01,-.10,.17,.35,-.60)*f0_0+\n        mat4(.31,.07,-.18,-.35,.66,.17,-.34,-.07,-.15,.39,-.14,.14,-.16,-.15,.18,-.03)*f0_1+\n        mat4(-.11,.14,.21,-.07,.16,-.33,-.24,.08,-.12,.06,-.20,-.20,.21,-.23,-.21,.24)*f0_2+\n        mat4(.06,-.27,-.25,.11,.11,.24,-.18,.25,.28,-.24,-.13,-.17,-.22,-.39,-.23,.46)*f0_3+\n        mat4(-.61,.14,.33,.63,.22,-.01,-.29,.20,-.46,-.10,.36,.46,.29,.01,.08,-.34)*f0_4+\n        mat4(.33,.33,-.26,-.02,-.48,-.13,-.03,-.28,-.03,-.26,.16,.22,.31,.04,-.28,-.09)*f0_5+\n        mat4(-.13,-.04,-.25,.22,-.45,.01,.19,.28,.36,-.27,-.22,-.05,-.12,-.05,.01,.34)*f0_6+\n        mat4(-.06,.11,.20,-.00,.06,.01,.30,.16,-.17,.03,.20,-.05,-.21,-.27,-.35,.09)*f0_7+\n        vec4(1.97,2.24,-1.04,-1.98))/1.0+f0_6;\n    vec4 f1_7=sin(mat4(.14,.48,-.15,-.37,.21,.26,-.16,-.14,-.17,.04,.35,.27,-.30,-.34,.26,-.18)*f0_0+\n        mat4(.13,-.13,-.46,-.43,-.02,.54,-.21,.03,.39,-.14,.23,-.00,.30,-.12,-.04,-.02)*f0_1+\n        mat4(.01,-.02,-.32,.13,.23,.01,-.22,-.16,.15,-.17,-.23,.00,-.45,.15,-.09,-.49)*f0_2+\n        mat4(.23,.10,-.10,.41,.16,.34,-.47,.18,-.12,.03,-.15,-.20,-.19,-.37,.08,-.03)*f0_3+\n        mat4(-.29,-.26,.17,.08,-.19,.05,.11,-.01,-.15,-.27,.26,-.20,-.25,-.40,-.22,-.17)*f0_4+\n        mat4(.37,-.14,.25,.31,.30,-.25,.15,-.35,-.09,-.13,-.07,.11,-.15,.17,-.29,.27)*f0_5+\n        mat4(-.16,.04,-.17,-.11,.23,.15,-.25,.01,.22,.16,.08,-.26,.41,-.14,-.17,.17)*f0_6+\n        mat4(-.15,-.03,-.29,-.06,-.68,-.18,.22,-.45,.25,-.12,-.11,-.27,.10,.24,.13,-.18)*f0_7+\n        vec4(-.06,-.40,1.48,-1.43))/1.0+f0_7;\n    vec4 f2_0=sin(mat4(.31,.34,.12,.13,-.10,.27,-.33,-.21,-.19,.27,-.03,.13,.18,-.29,-.25,-.03)*f1_0+\n        mat4(.21,-.36,-.45,.11,.00,.05,-.36,-.32,-.06,.24,.21,.07,-.14,.15,-.22,.31)*f1_1+\n        mat4(.32,-.14,-.17,.21,.17,.09,-.15,-.26,-.13,.12,.27,-.35,.21,.11,-.15,-.13)*f1_2+\n        mat4(-.25,-.08,.01,.37,-.27,.17,.04,-.21,-.03,-.16,.14,.08,-.13,-.04,.33,-.27)*f1_3+\n        mat4(-.02,.18,.03,-.32,.06,-.20,.06,.05,-.05,.26,.15,-.15,-.14,-.22,-.05,.18)*f1_4+\n        mat4(.16,-.05,-.31,-.07,.27,.15,-.08,.39,.19,.14,-.28,-.06,-.33,.03,.04,-.16)*f1_5+\n        mat4(.13,-.20,-.09,-.06,-.14,.15,.16,.14,-.29,-.32,.17,.07,.29,.32,.22,-.09)*f1_6+\n        mat4(-.20,-.04,.18,.10,.28,.31,-.14,-.24,.17,-.15,-.03,.16,.34,-.31,.30,-.14)*f1_7+\n        vec4(-.75,-.96,1.04,1.19))/1.4+f1_0;\n    vec4 f2_1=sin(mat4(.05,-.44,-.16,-.17,.03,.19,-.28,.36,-.18,-.10,.31,-.06,.19,.14,-.13,.08)*f1_0+\n        mat4(-.46,-.46,-.42,-.13,.08,.06,-.22,-.10,.41,-.47,.11,.15,-.14,.37,.13,.43)*f1_1+\n        mat4(.40,.35,.25,.51,-.21,.06,-.28,.35,-.08,-.39,.02,.19,-.21,-.25,.00,.34)*f1_2+\n        mat4(.60,.17,-.03,.45,-.39,-.29,.01,.03,.24,.50,.28,.12,.06,-.54,-.06,.36)*f1_3+\n        mat4(.41,-.07,.25,.34,.18,.18,-.18,.30,.31,.47,-.01,.28,-.02,.12,-.17,-.30)*f1_4+\n        mat4(.20,-.40,-.04,-.54,-.16,.22,-.05,.10,-.02,.28,-.49,.21,.17,-.16,.02,.24)*f1_5+\n        mat4(-.03,.06,-.01,.25,-.22,-.18,-.17,-.01,.01,.03,-.07,-.02,.36,.23,-.26,.52)*f1_6+\n        mat4(.28,.09,.25,-.02,.11,-.10,-.21,.07,.29,.11,.06,-.30,-.22,-.43,-.07,-.44)*f1_7+\n        vec4(-1.37,-1.80,-.48,-2.17))/1.4+f1_1;\n    vec4 f2_2=sin(mat4(.17,.06,.09,.15,-.07,-.21,-.27,.19,-.00,-.30,.03,-.02,-.19,.29,.05,-.06)*f1_0+\n        mat4(-.17,-.31,-.06,-.12,-.23,-.63,.02,-.33,.23,.31,.07,.33,-.08,-.83,-.49,.21)*f1_1+\n        mat4(.07,.79,.27,.06,.05,.44,.10,.08,-.15,.26,-.18,-.04,.37,-.02,.30,-.19)*f1_2+\n        mat4(-.08,.46,.09,-.03,-.09,-.44,-.01,.33,.08,.10,-.06,-.13,-.22,.54,.08,.26)*f1_3+\n        mat4(-.16,-.17,-.23,.32,-.03,-.15,.38,.03,-.15,.15,.43,-.45,.20,-.12,.23,.23)*f1_4+\n        mat4(.49,-.44,.29,.40,-.29,-.08,-.39,.16,.06,-.36,.01,-.21,-.02,.20,.21,.17)*f1_5+\n        mat4(.03,-.07,-.08,-.12,.13,-.19,.06,-.17,.44,.94,.38,.39,-.11,.18,.18,.09)*f1_6+\n        mat4(-.05,.26,.01,-.06,.15,.30,-.06,.25,-.06,-.06,-.30,.41,.25,-.22,.04,.10)*f1_7+\n        vec4(-.45,-.38,1.48,-1.50))/1.4+f1_2;\n    vec4 f2_3=sin(mat4(.14,.23,.30,.17,.04,.06,.20,-.36,-.16,.15,-.05,-.20,-.10,.04,.01,-.19)*f1_0+\n        mat4(-.19,.13,-.06,-.20,.34,-.24,-.20,.37,-.25,.01,.00,-.14,.32,-.14,-.39,-.08)*f1_1+\n        mat4(.12,.15,.02,-.26,-.09,-.13,.32,-.20,.12,-.09,-.08,.13,-.11,.20,.03,-.09)*f1_2+\n        mat4(-.29,-.02,.03,.13,.01,.34,.26,.01,.46,-.25,-.31,-.01,.13,-.27,.03,-.05)*f1_3+\n        mat4(.21,.15,-.73,.01,.06,.34,.05,-.03,.20,.34,-.08,-.19,-.09,.02,-.04,.33)*f1_4+\n        mat4(-.07,-.02,.15,-.07,-.28,.39,-.09,.03,.35,.08,-.05,-.05,.34,.12,-.01,.22)*f1_5+\n        mat4(-.28,.25,.31,.15,.09,-.13,-.46,-.12,-.42,-.30,.28,.20,.20,.33,-.25,-.10)*f1_6+\n        mat4(.45,-.04,.43,.41,.14,-.03,.27,.32,-.06,-.07,-.26,.02,.13,.11,-.14,.20)*f1_7+\n        vec4(-2.16,-1.49,-1.83,.87))/1.4+f1_3;\n    vec4 f2_4=sin(mat4(-.31,.13,.18,.04,.16,.34,-.03,-.10,.26,-.24,.17,-.09,-.25,-.23,.13,.07)*f1_0+\n        mat4(.51,-.22,.40,.07,.51,-.33,.06,.23,-.08,-.31,.23,.01,.42,.44,-.09,.09)*f1_1+\n        mat4(-.35,.29,-.01,-.17,.13,-.06,-.22,-.34,.12,-.19,.04,-.12,.24,-.05,-.07,.02)*f1_2+\n        mat4(.26,.39,-.17,-.25,-.21,.10,.26,.24,-.14,.02,-.11,-.20,.24,-.01,-.14,-.20)*f1_3+\n        mat4(.22,.54,-.11,.09,.39,.19,-.03,.03,.34,.02,-.06,-.33,.01,.12,.33,.11)*f1_4+\n        mat4(-.19,.15,-.10,.17,-.00,.16,-.43,-.02,.48,-.09,.18,.08,.59,.03,-.10,.05)*f1_5+\n        mat4(.10,-.38,-.04,.40,-.18,-.01,-.08,-.11,-.64,-.37,.29,.19,.43,.22,-.11,-.04)*f1_6+\n        mat4(.07,-.34,-.11,.40,.10,.01,.30,.27,-.06,.35,-.36,.07,-.04,.12,.28,.18)*f1_7+\n        vec4(-.80,1.64,-.76,.72))/1.4+f1_4;\n    vec4 f2_5=sin(mat4(.01,.04,-.06,-.02,-.31,.10,.24,-.08,.35,.10,.35,.05,.10,-.06,-.04,.11)*f1_0+\n        mat4(.21,.43,.57,-.10,.38,.18,-.14,-.21,-.19,.18,-.39,.07,.17,.27,.42,.29)*f1_1+\n        mat4(-.33,-.60,-.18,-.04,.01,.32,.01,-.08,.03,-.19,.08,.16,-.55,.16,-.44,-.27)*f1_2+\n        mat4(-.02,-.18,-.20,.30,.05,-.12,-.24,-.29,-.10,.07,.01,.11,-.33,.15,-.38,-.21)*f1_3+\n        mat4(.05,-.19,.22,.11,-.35,.24,-.05,.03,-.23,.35,-.32,.15,.18,.31,.16,-.12)*f1_4+\n        mat4(.13,-.23,.06,.42,.16,.27,.48,.33,.08,-.13,-.29,-.01,-.09,-.02,.03,.23)*f1_5+\n        mat4(-.42,-.02,-.09,-.25,.08,.16,.11,.22,-.37,-.05,.14,-.23,.08,.15,-.02,.16)*f1_6+\n        mat4(-.22,.18,-.20,.03,-.57,-.30,.03,-.19,.29,.14,.38,.23,.06,.18,-.03,-.05)*f1_7+\n        vec4(.92,1.27,.72,-1.02))/1.4+f1_5;\n    vec4 f2_6=sin(mat4(.05,.50,.23,.09,.09,.20,-.14,-.19,-.13,-.04,-.15,.22,-.05,.13,-.04,.49)*f1_0+\n        mat4(.41,.09,-.21,.54,-.10,.24,.21,.46,-.21,-.01,-.29,-.27,.34,-.08,.29,-.22)*f1_1+\n        mat4(.40,-.28,-.47,-.25,.20,-.08,-.31,-.50,-.48,.42,-.08,.19,-.24,.27,.13,.13)*f1_2+\n        mat4(.04,.41,.10,-.09,-.12,.41,.07,.30,.33,-.04,-.10,-.17,-.09,.00,.24,.04)*f1_3+\n        mat4(-.05,-.09,.27,-.17,-.13,.01,-.05,.01,-.23,-.02,.32,-.25,-.26,.15,-.20,-.19)*f1_4+\n        mat4(.15,.23,.02,.12,.21,-.44,.16,-.30,-.12,.16,-.06,.03,.11,-.21,-.25,.01)*f1_5+\n        mat4(-.38,.50,.13,.50,-.27,.11,-.25,.08,-.24,.16,.04,-.52,.03,.13,.08,-.30)*f1_6+\n        mat4(-.06,.29,-.07,.25,-.22,.21,.04,.10,.21,-.31,-.00,-.29,-.39,-.08,.07,.20)*f1_7+\n        vec4(-1.72,-.71,-1.40,.83))/1.4+f1_6;\n    vec4 f2_7=sin(mat4(-.09,-.29,-.24,-.26,.33,-.33,.39,.13,-.06,-.17,.24,-.26,.23,.09,.21,-.08)*f1_0+\n        mat4(.50,.11,.17,.13,.40,-.03,.22,-.14,.22,.31,.26,-.16,.34,-.18,.29,.26)*f1_1+\n        mat4(-.04,.33,-.26,-.18,.16,-.12,.34,-.02,.11,-.11,-.25,-.26,.27,.54,-.03,-.45)*f1_2+\n        mat4(-.05,.08,.16,.03,-.25,-.07,-.16,.15,.32,.01,-.03,.29,-.09,-.07,.24,.24)*f1_3+\n        mat4(.04,-.14,-.03,.30,-.02,.08,.05,.14,-.27,-.19,.47,.03,-.02,.17,.04,.03)*f1_4+\n        mat4(-.09,.14,-.39,-.30,-.42,-.31,.11,.09,-.02,.28,.32,-.25,.36,-.06,.18,.12)*f1_5+\n        mat4(.11,.36,-.07,-.47,-.23,.11,-.19,.14,-.18,.16,-.34,-.13,.18,.09,.32,.12)*f1_6+\n        mat4(-.05,.05,-.34,-.23,.04,.08,-.29,-.15,-.37,-.05,.17,.44,-.38,-.28,-.06,.32)*f1_7+\n        vec4(.89,-.88,-.86,1.29))/1.4+f1_7;\n    vec4 f3_0=sin(mat4(-.25,-.17,-.39,-.08,.27,.19,.12,.14,.28,.02,-.27,-.09,-.41,.06,.22,-.31)*f2_0+\n        mat4(-.09,-.21,-.44,-.11,-.08,-.14,-.06,.07,.19,.13,-.11,.22,.35,-.46,.27,.16)*f2_1+\n        mat4(.41,-.01,-.14,-.12,.02,.04,-.17,.33,-.07,-.04,.13,.53,.46,.02,-.01,.13)*f2_2+\n        mat4(.09,.09,.05,-.31,-.09,.28,.05,-.17,.28,.10,.14,.11,.07,-.08,.18,-.26)*f2_3+\n        mat4(-.01,-.08,.44,.26,-.21,-.04,.06,-.16,.39,.22,-.20,.25,.05,.06,-.19,-.17)*f2_4+\n        mat4(-.19,-.06,.12,-.34,-.26,-.28,-.16,.35,-.06,-.09,.06,.09,-.20,-.21,-.26,-.05)*f2_5+\n        mat4(-.00,.14,-.02,.24,-.00,-.11,-.18,.33,-.03,.15,.10,-.11,.28,-.26,.31,-.04)*f2_6+\n        mat4(.22,-.26,-.09,-.12,.17,-.32,.13,.30,.19,.14,.02,-.30,.25,-.09,.03,-.13)*f2_7+\n        vec4(.23,-1.25,-1.21,.23))/1.7+f2_0;\n    vec4 f3_1=sin(mat4(-.16,-.30,-.08,-.12,.11,-.18,.27,.24,-.07,.29,.12,-.13,-.01,.05,-.06,-.30)*f2_0+\n        mat4(.11,.21,.37,-.09,-.09,.07,-.10,-.11,-.10,-.25,.22,-.02,.13,-.34,.35,.10)*f2_1+\n        mat4(.05,-.05,.20,-.25,.19,-.48,.10,.03,.11,.23,.02,-.15,-.02,-.40,.50,-.04)*f2_2+\n        mat4(-.45,-.08,.35,.08,-.19,-.16,.27,.08,-.43,.09,.03,.06,.06,.09,-.03,.06)*f2_3+\n        mat4(.00,-.16,.22,.14,.08,.44,.22,.04,-.01,.45,.03,.41,-.30,.06,-.07,.16)*f2_4+\n        mat4(-.16,.29,-.23,.07,.23,-.01,.33,.04,-.15,.16,.02,-.16,.08,-.33,.18,.14)*f2_5+\n        mat4(.21,.21,-.27,.08,.26,-.08,.32,-.18,-.19,.29,-.23,.02,-.19,.30,.23,.43)*f2_6+\n        mat4(-.24,.41,-.27,-.18,.11,-.24,.00,-.06,.26,.35,.01,-.16,-.09,.23,.14,.03)*f2_7+\n        vec4(.75,.13,-1.05,2.00))/1.7+f2_1;\n    vec4 f3_2=sin(mat4(-.23,-.30,.01,-.13,-.21,-.06,-.12,-.04,.03,.14,-.30,-.24,.03,.31,.20,.14)*f2_0+\n        mat4(.04,.16,.45,.22,-.49,-.12,.32,-.33,-.12,.03,.06,.05,-.11,-.65,.07,.17)*f2_1+\n        mat4(.56,-.07,.14,.05,-.06,.33,-.06,.49,-.35,.10,-.31,.09,-.30,-.18,-.35,-.03)*f2_2+\n        mat4(.35,.04,.13,.39,-.17,-.07,-.50,.02,.24,-.02,.21,.14,.19,.23,-.05,.05)*f2_3+\n        mat4(-.12,-.11,-.58,-.25,-.03,-.00,-.15,.47,.01,-.24,.16,.27,-.16,-.07,-.05,.03)*f2_4+\n        mat4(.11,.35,.12,.10,.05,-.14,.01,.23,-.02,.07,.17,.11,-.27,.05,.36,.18)*f2_5+\n        mat4(-.25,-.60,-.32,-.05,-.23,-.07,-.19,.03,-.11,-.14,.12,-.20,-.53,-.09,-.29,.44)*f2_6+\n        mat4(-.02,-.09,-.36,-.46,-.16,.08,-.26,-.09,.15,.18,.51,.47,-.13,-.48,.51,.09)*f2_7+\n        vec4(1.98,.39,-.47,1.49))/1.7+f2_2;\n    vec4 f3_3=sin(mat4(.06,.09,.19,.31,-.21,.19,-.18,-.26,-.17,-.36,.19,-.39,-.09,-.37,-.12,.28)*f2_0+\n        mat4(.42,.56,-.40,.60,-.05,.13,-.25,.18,.02,.17,-.14,.01,-.43,.61,-.17,.49)*f2_1+\n        mat4(.23,-.42,.27,.46,-.33,.04,.06,-.13,-.39,-.21,.25,-.19,-.10,.00,.24,.14)*f2_2+\n        mat4(.18,-.18,-.16,.15,-.02,.07,-.01,-.02,.13,.37,.56,.18,-.07,-.17,.35,-.21)*f2_3+\n        mat4(-.15,.36,-.11,-.20,.37,.38,.31,-.16,-.04,-.04,-.06,.04,.23,-.34,.01,.29)*f2_4+\n        mat4(.31,.02,.14,.27,.06,.18,-.21,.03,-.32,.46,-.16,.14,-.14,.36,-.27,.23)*f2_5+\n        mat4(.05,-.40,.16,-.28,-.17,.08,.22,-.02,.17,-.13,-.27,.30,-.44,.66,.19,-.04)*f2_6+\n        mat4(.25,-.11,-.25,-.55,.08,.09,-.18,-.08,.02,.00,.20,-.20,.30,.44,-.29,.46)*f2_7+\n        vec4(.70,1.07,.01,-1.23))/1.7+f2_3;\n    vec4 f3_4=sin(mat4(-.17,-.15,.12,.28,-.46,.34,.31,.42,-.24,.45,.10,-.06,.16,.47,.07,-.34)*f2_0+\n        mat4(-.35,-.09,.20,-.29,.46,-.07,-.26,-.07,-.22,-.20,-.03,-.09,-.66,.34,-.21,.01)*f2_1+\n        mat4(-.26,-.23,.33,.03,.19,-.45,-.27,-.10,.43,-.15,-.21,.30,.28,.27,.26,.22)*f2_2+\n        mat4(-.07,.28,.32,-.22,.23,-.39,.17,.07,-.23,-.09,-.23,-.02,-.10,-.11,.08,.22)*f2_3+\n        mat4(-.28,-.10,.18,.26,-.27,.03,.24,-.44,-.26,.38,-.01,.02,.15,-.18,-.33,-.01)*f2_4+\n        mat4(-.24,.16,.22,-.34,-.34,.08,-.02,-.32,-.26,.10,-.03,-.34,-.15,-.04,.05,-.29)*f2_5+\n        mat4(.57,.31,-.10,.52,.31,.02,-.26,.46,.25,-.46,-.22,.08,-.36,.31,.18,.13)*f2_6+\n        mat4(.10,.04,.27,-.13,.27,-.14,-.09,.30,.26,-.19,-.18,-.00,-.30,-.25,-.03,-.47)*f2_7+\n        vec4(-.08,.24,-.37,-.53))/1.7+f2_4;\n    vec4 f3_5=sin(mat4(.13,.05,-.11,.11,.21,.11,-.40,-.02,.02,.31,.12,.14,.06,.25,.39,.16)*f2_0+\n        mat4(.11,.16,-.06,.11,-.04,-.08,.05,-.13,.02,.30,-.05,-.15,-.09,-.27,-.42,-.16)*f2_1+\n        mat4(.30,-.24,-.18,-.06,-.36,-.07,.01,-.67,-.01,.14,-.09,.03,-.18,-.13,-.22,-.08)*f2_2+\n        mat4(-.11,-.09,.31,.36,-.23,-.16,.00,.07,.48,-.28,-.34,.04,-.23,-.13,-.18,-.15)*f2_3+\n        mat4(-.22,-.07,-.36,-.19,-.09,.22,.02,.23,.18,.22,.16,.29,-.06,-.19,.39,-.20)*f2_4+\n        mat4(-.05,.35,.26,.33,-.26,-.00,-.34,-.06,.13,-.24,-.25,-.27,-.07,.03,-.34,-.28)*f2_5+\n        mat4(.15,.01,.03,.20,.31,.24,.18,-.03,.09,-.23,.31,-.05,-.13,-.22,-.28,-.07)*f2_6+\n        mat4(-.27,.11,.16,.35,-.18,-.25,.35,-.18,.30,.17,-.12,-.23,.12,.03,-.01,.04)*f2_7+\n        vec4(.96,-1.20,-1.14,-1.00))/1.7+f2_5;\n    vec4 f3_6=sin(mat4(.22,-.36,.21,-.35,-.24,.22,.17,-.28,-.06,-.15,-.20,.07,.15,-.26,-.16,.13)*f2_0+\n        mat4(.14,-.19,.37,-.01,.25,.32,-.10,-.19,.21,.39,-.26,-.29,.16,.00,.63,.51)*f2_1+\n        mat4(.18,-.04,.11,-.23,.04,.28,.14,.00,-.04,.03,.04,.10,.24,.51,-.07,.20)*f2_2+\n        mat4(-.14,.08,.01,.12,-.12,-.16,-.32,-.04,.00,-.10,.17,.45,.16,.18,.07,.37)*f2_3+\n        mat4(.18,-.32,-.01,.12,-.32,-.28,.04,.10,.01,.21,.12,-.05,.04,.17,-.30,.11)*f2_4+\n        mat4(-.28,.08,-.39,.22,.11,-.15,-.05,.14,-.02,-.15,.08,.02,-.32,.36,.22,-.09)*f2_5+\n        mat4(.13,.31,-.19,.27,-.10,.06,-.21,.01,.07,.11,.17,.34,.15,.09,.19,.18)*f2_6+\n        mat4(-.02,-.23,-.07,-.01,.34,.29,.02,-.17,-.08,-.04,.11,.23,-.11,-.44,-.07,-.44)*f2_7+\n        vec4(-1.22,1.17,-1.00,.20))/1.7+f2_6;\n    vec4 f3_7=sin(mat4(-.14,-.11,-.12,.12,-.14,.21,.11,-.03,.04,.39,.18,-.07,.06,-.18,.00,-.17)*f2_0+\n        mat4(.23,.18,-.08,-.40,-.01,.39,-.26,.13,.03,.23,-.28,.06,-.07,.45,.28,.01)*f2_1+\n        mat4(.14,.18,-.06,-.15,.07,-.22,-.24,.36,.04,-.21,-.05,.29,.09,.14,-.09,.25)*f2_2+\n        mat4(-.13,-.39,.18,-.04,.07,-.45,-.08,.30,-.43,.30,.14,-.34,-.25,.28,.04,.04)*f2_3+\n        mat4(.13,.26,-.03,.55,.18,.43,-.18,-.03,.34,-.16,.16,-.14,.01,-.02,-.08,-.01)*f2_4+\n        mat4(.45,.15,-.20,-.34,.31,.09,.01,-.22,-.27,.22,.19,-.20,.37,.02,.08,-.03)*f2_5+\n        mat4(.19,-.47,.24,.33,.01,-.20,.15,.01,.22,-.03,.22,-.15,.02,.07,.08,.14)*f2_6+\n        mat4(-.23,.06,-.22,-.09,.16,-.05,.19,.05,-.42,-.31,-.31,-.38,.08,.05,-.16,-.15)*f2_7+\n        vec4(-.23,1.33,-1.81,.90))/1.7+f2_7;\n    vec4 f4_0=sin(mat4(.01,.04,-.20,-.10,-.04,-.06,.10,.07,-.19,-.03,.17,-.26,-.40,-.14,-.21,.30)*f3_0+\n        mat4(-.54,.00,-.02,-.07,-.13,.38,-.32,.32,-.43,-.10,-.35,.38,.24,.24,-.10,-.11)*f3_1+\n        mat4(.14,-.19,.02,.16,.11,.13,.38,-.14,.31,-.19,.25,-.67,-.44,.04,-.03,-.47)*f3_2+\n        mat4(-.05,.08,.01,.30,.04,.25,.39,-.37,.02,-.36,.12,.39,.56,-.05,-.10,-.20)*f3_3+\n        mat4(.40,.14,-.11,-.60,.34,.15,.03,-.39,-.04,-.05,-.26,-.18,-.14,-.25,.16,-.22)*f3_4+\n        mat4(.08,-.16,-.23,.31,.39,-.09,-.14,-.10,-.55,.10,.09,.39,-.04,.22,.01,.61)*f3_5+\n        mat4(.35,.15,-.10,-.34,.22,-.09,.02,-.41,-.36,.04,.06,.35,-.13,.10,-.02,-.02)*f3_6+\n        mat4(-.37,.14,.04,-.41,-.34,.30,.18,-.32,-.04,-.06,-.26,.46,-.70,.07,-.17,.28)*f3_7+\n        vec4(.12,-.45,-.01,-1.54))/2.0+f3_0;\n    vec4 f4_1=sin(mat4(.33,-.00,.47,-.21,-.01,.01,.27,-.33,-.02,-.07,.05,-.05,-.44,-.08,-.50,-.18)*f3_0+\n        mat4(.26,-.00,-.19,-.21,.00,-.10,.18,-.23,-.16,.15,.20,.18,-.35,-.23,.53,.09)*f3_1+\n        mat4(-.11,.05,-.06,-.13,.11,.55,-.10,-.20,-.08,.47,.18,.37,-.04,.30,.51,-.16)*f3_2+\n        mat4(.14,-.34,-.20,-.07,-.21,.27,.49,-.21,-.18,-.54,.06,.02,.10,.11,.13,-.16)*f3_3+\n        mat4(.08,.34,.19,-.24,-.30,-.26,.42,-.12,-.10,-.20,-.14,-.15,-.18,-.07,-.09,.19)*f3_4+\n        mat4(-.28,-.56,.21,.12,.11,.07,-.18,.41,-.02,-.07,.33,-.30,.03,.11,.37,.03)*f3_5+\n        mat4(-.19,.08,-.52,-.12,.15,.41,-.02,.40,-.07,-.30,.03,.02,-.12,.13,.18,-.33)*f3_6+\n        mat4(.24,-.10,-.21,.12,.29,.17,.38,-.08,-.21,-.07,.09,.12,.22,-.30,.18,-.01)*f3_7+\n        vec4(-.92,-.70,-.39,-.30))/2.0+f3_1;\n    vec4 f4_2=sin(mat4(.34,-.02,-.18,.27,.36,-.43,.22,-.06,.62,-.21,-.14,.18,-.33,.12,-.21,.06)*f3_0+\n        mat4(-.18,.01,.27,.20,-.50,-.10,-.15,.13,-.10,-.30,-.22,.01,.53,-.05,-.24,.13)*f3_1+\n        mat4(.11,.31,-.18,.13,-.63,-.59,.08,-.07,.18,-.55,.01,-.09,-.43,-.21,-.24,.09)*f3_2+\n        mat4(-.31,.41,.17,-.02,.29,-.40,.35,-.43,.11,.55,.08,-.12,.01,-.34,-.20,-.15)*f3_3+\n        mat4(.45,-.21,-.19,-.26,.62,-.06,.08,.36,.69,-.01,-.22,-.10,-.33,.16,-.11,-.29)*f3_4+\n        mat4(-.18,.41,.33,-.16,-.22,-.42,.26,-.44,-.21,.51,-.22,.14,-.69,.18,.18,.21)*f3_5+\n        mat4(.00,.07,-.15,-.10,.02,-.49,-.24,-.28,.25,.29,-.24,.13,.81,-.20,.06,.40)*f3_6+\n        mat4(.22,.27,.06,.17,.23,-.34,.08,.22,.05,.20,.23,-.06,-.21,.69,-.15,.59)*f3_7+\n        vec4(1.56,-.72,1.94,-.17))/2.0+f3_2;\n    vec4 f4_3=sin(mat4(.13,.24,.07,.17,-.05,.08,.13,.23,-.12,-.18,.01,-.01,.20,.02,.29,-.08)*f3_0+\n        mat4(-.24,-.03,.12,-.23,.55,.19,.21,.01,.24,-.43,-.04,.11,-.08,-.10,.02,.14)*f3_1+\n        mat4(-.05,.02,.03,.09,.14,-.09,-.60,.09,-.11,-.27,-.12,.45,-.52,-.05,-.08,-.00)*f3_2+\n        mat4(-.17,-.25,-.08,.12,-.03,.31,.23,.25,.30,.26,.23,.05,.43,.37,.18,.21)*f3_3+\n        mat4(.03,-.18,-.14,.30,.15,-.09,.31,.32,-.38,-.07,.49,.01,-.25,-.28,-.02,-.14)*f3_4+\n        mat4(.34,.24,.34,-.15,.15,.19,.19,.17,-.19,-.30,.22,-.39,.66,.39,.48,.11)*f3_5+\n        mat4(-.50,-.02,-.01,-.11,-.54,-.09,.10,-.02,.07,-.04,.22,-.01,-.31,-.00,.09,.01)*f3_6+\n        mat4(-.27,.31,.23,.09,-.21,-.38,.21,.05,-.05,.34,-.11,-.15,-.23,-.04,.42,-.01)*f3_7+\n        vec4(.53,-1.43,-.37,-1.15))/2.0+f3_3;\n    vec4 f4_4=sin(mat4(.16,.29,-.21,-.25,-.03,.26,.24,-.41,.18,.04,.11,-.07,.49,-.14,.17,.47)*f3_0+\n        mat4(.19,-.24,.23,-.01,.06,.06,.71,.05,-.09,.06,-.05,-.18,.55,.24,-.10,-.95)*f3_1+\n        mat4(.43,.12,-.30,-.07,-.54,-.00,-.09,.37,-.66,.04,-.42,.01,-.35,-.02,.03,-.02)*f3_2+\n        mat4(.11,.29,-.03,.24,-.68,.03,.07,-.23,.38,-.01,-.33,-.12,.13,.23,-.14,.35)*f3_3+\n        mat4(-.74,.08,-.04,-.37,-.06,.28,.16,-.59,-.06,.37,-.36,-.11,.01,.00,-.05,.24)*f3_4+\n        mat4(.55,-.31,.45,.08,-.29,-.14,.10,.15,.24,-.22,-.03,.03,.13,-.29,-.17,.11)*f3_5+\n        mat4(-.48,.16,-.23,.45,-.27,-.07,-.02,.14,.47,.17,-.14,.02,-.20,.00,-.40,-.66)*f3_6+\n        mat4(-.35,-.56,.14,.30,-.35,.02,.07,-.11,.27,.01,-.32,-.17,.69,-.21,.22,.39)*f3_7+\n        vec4(2.07,-1.26,-1.56,-.64))/2.0+f3_4;\n    vec4 f4_5=sin(mat4(.47,.13,.16,.03,.27,-.16,.22,-.18,.33,.24,-.12,.44,.22,.06,.07,-.17)*f3_0+\n        mat4(-.05,.04,.30,.10,.15,.30,-.23,-.26,-.07,.09,.27,.05,-.20,.05,.15,.12)*f3_1+\n        mat4(-.51,-.03,-.09,.18,-.39,.27,.36,-.35,.03,-.07,-.21,-.08,.35,-.26,.09,-.23)*f3_2+\n        mat4(.24,-.35,.03,.33,-.22,.11,-.21,-.23,-.21,-.10,.29,.31,.17,-.07,-.31,-.18)*f3_3+\n        mat4(-.17,-.35,-.02,-.02,-.22,-.34,.21,.09,-.31,-.19,.20,.32,-.13,-.25,-.26,-.06)*f3_4+\n        mat4(.04,.22,.14,.20,-.23,-.00,-.15,-.01,.30,-.09,.52,.09,.45,.21,.25,-.31)*f3_5+\n        mat4(-.15,.19,-.65,-.11,-.04,.01,-.29,-.03,-.34,-.13,.28,.21,.02,.30,.36,.30)*f3_6+\n        mat4(-.11,-.09,-.33,.53,-.15,-.34,.19,-.24,.10,.28,.10,-.03,-.25,.30,.21,.55)*f3_7+\n        vec4(-1.41,-.90,.92,-.08))/2.0+f3_5;\n    vec4 f4_6=sin(mat4(.30,-.15,.38,.17,-.14,.13,-.18,-.14,.05,.02,.09,.35,-.09,.15,-.34,.19)*f3_0+\n        mat4(-.01,.40,-.35,-.02,-.16,-.49,-.48,-.10,-.00,.34,.17,.14,.03,-.16,-.06,.04)*f3_1+\n        mat4(-.05,.11,-.16,-.23,.13,-.16,-.20,-.23,.22,.32,.56,.50,-.01,.21,-.10,-.04)*f3_2+\n        mat4(.23,-.15,-.22,-.00,-.29,-.01,-.06,.32,.18,-.15,-.08,.08,.00,.35,.12,.08)*f3_3+\n        mat4(.07,.14,.09,.22,.11,.11,.45,-.16,.12,.16,-.27,-.06,-.16,.21,.02,.05)*f3_4+\n        mat4(.04,.02,-.53,.08,-.45,.04,-.30,-.16,.19,.11,-.04,.07,.14,-.10,-.51,-.23)*f3_5+\n        mat4(.16,.24,-.02,.04,-.25,-.28,.28,-.09,.38,-.16,-.46,-.07,.88,-.47,-.40,.10)*f3_6+\n        mat4(-.22,.03,.12,.23,.10,.14,-.15,-.06,.10,-.28,.10,-.05,-.47,-.13,.09,.01)*f3_7+\n        vec4(.84,-1.33,1.65,.47))/2.0+f3_6;\n    vec4 f4_7=sin(mat4(-.29,.06,.06,.03,-.17,.38,-.21,-.36,.19,.21,.12,-.43,.24,-.13,.15,.63)*f3_0+\n        mat4(.46,.09,-.10,.12,-.24,.03,-.05,.14,.38,.21,-.09,.10,-.25,.30,.22,-.38)*f3_1+\n        mat4(.23,.16,.40,.48,-.26,-.29,.13,-.12,-.34,.10,-.08,-.69,.11,.04,-.11,-.43)*f3_2+\n        mat4(-.09,.47,.00,.19,.08,-.38,.18,-.69,.09,.30,.09,.24,-.15,.37,-.08,-.27)*f3_3+\n        mat4(-.17,-.13,-.31,-.41,.03,.39,-.09,.22,.16,.35,.14,-.11,-.29,-.53,.17,-.16)*f3_4+\n        mat4(-.13,-.36,.20,.31,-.41,-.35,.25,.06,.26,-.34,.05,.18,.21,-.16,.22,.12)*f3_5+\n        mat4(.23,.01,-.51,.10,-.10,-.02,.21,-.11,.10,.29,-.27,-.16,-.34,.71,.09,-.26)*f3_6+\n        mat4(.16,-.36,.01,-.21,-.21,.30,-.32,.11,-.11,-.01,-.23,-.14,.21,-.37,-.20,.46)*f3_7+\n        vec4(.17,1.06,-.47,-.56))/2.0+f3_7;\n    vec4 f5_0=sin(mat4(-.23,-.01,-.19,-.00,.07,.33,-.13,.16,.23,.21,.10,.28,.84,.33,-.07,-.49)*f4_0+\n        mat4(.13,-.30,.08,-.20,.16,-.05,.10,-.28,.43,.41,.21,-.23,-.25,.37,.12,-.16)*f4_1+\n        mat4(-.08,-.33,.19,.06,.02,-.38,-.26,.20,-.34,-.39,-.34,.06,.14,.31,-.04,-.13)*f4_2+\n        mat4(.43,-.05,.03,.17,-.03,.29,-.18,.44,.17,.06,-.14,-.15,.27,-.17,-.34,.17)*f4_3+\n        mat4(-.25,-.09,.63,.43,.45,-.04,.04,.19,.36,.35,.02,.03,-.03,-.13,-.07,.04)*f4_4+\n        mat4(.14,.17,.25,.09,-.08,-.01,-.04,.26,.10,-.11,.16,-.31,-.07,.10,-.15,-.16)*f4_5+\n        mat4(-.11,.32,.15,-.23,-.08,-.05,-.07,.11,-.14,.27,-.15,-.11,.22,-.28,-.15,-.08)*f4_6+\n        mat4(.18,-.49,-.38,.04,-.35,.24,-.24,-.38,.24,.25,.09,.29,.66,.17,-.41,-.46)*f4_7+\n        vec4(.64,-.50,1.60,-1.73))/2.2+f4_0;\n    vec4 f5_1=sin(mat4(.13,-.21,.52,.28,-.26,.20,.35,.09,-.20,.11,-.36,-.22,-.35,.02,.60,-.11)*f4_0+\n        mat4(.23,-.09,-.07,.10,.11,-.02,.30,-.48,.25,.04,.27,-.62,.05,.52,.21,-.08)*f4_1+\n        mat4(-.22,-.24,-.20,.25,.29,.40,.14,.11,.22,.06,.10,.11,.21,-.08,.01,-.05)*f4_2+\n        mat4(-.06,-.26,.28,-.23,-.08,-.29,.09,.18,-.12,-.06,-.02,.14,.01,.64,.06,-.06)*f4_3+\n        mat4(.27,-.09,-.51,.48,-.13,-.14,.07,-.10,-.25,-.07,.15,.44,.05,-.22,-.28,.34)*f4_4+\n        mat4(-.08,-.41,.39,-.03,.10,-.26,-.34,-.14,.16,.06,.06,-.26,-.01,.19,.08,-.33)*f4_5+\n        mat4(.19,.05,.07,-.09,.14,-.41,.06,.03,-.31,.03,.20,.10,-.43,.37,-.17,.38)*f4_6+\n        mat4(-.07,-.41,-.35,-.26,.33,.12,.63,.15,-.16,.01,-.40,.10,.10,-.11,-.14,.03)*f4_7+\n        vec4(.33,-.29,-.38,.02))/2.2+f4_1;\n    vec4 f5_2=sin(mat4(-.40,-.32,.28,-.40,.35,.02,.23,-.04,-.03,.14,.31,-.27,-.33,-1.01,-.34,-.16)*f4_0+\n        mat4(.31,-.42,.11,-.13,-.26,-.51,-.35,-.45,-.24,-.35,-.09,-.11,-.12,-.19,-.16,.26)*f4_1+\n        mat4(.18,.40,.45,.06,.21,.24,-.09,.50,.12,-.11,.20,-.04,-.11,-.39,-.34,-.29)*f4_2+\n        mat4(-.26,.15,-.27,.03,.46,.02,.16,-.38,-.24,-.25,-.13,-.26,.08,.29,.07,-.25)*f4_3+\n        mat4(.26,.93,.62,.24,.05,.18,-.21,.24,-.05,-.03,.01,-.04,.46,.49,.22,.02)*f4_4+\n        mat4(.18,-.10,-.47,.11,.14,.20,.15,.44,-.07,-.24,.30,-.12,-.14,-.30,-.19,-.33)*f4_5+\n        mat4(-.13,-.63,-.18,-.05,-.02,.67,.10,-.09,.13,-.18,.07,-.52,-.04,.05,-.32,-.14)*f4_6+\n        mat4(.26,.06,.04,-.37,-.37,-.16,-.25,-.18,-.05,.41,.02,.04,-.14,-.32,-.03,-.07)*f4_7+\n        vec4(.01,.00,-1.25,.87))/2.2+f4_2;\n    vec4 f5_3=sin(mat4(-.38,.20,-.10,.02,-.25,.18,.32,.14,.45,-.04,.13,.33,-.26,-.23,-.36,-.64)*f4_0+\n        mat4(1.09,-.06,.18,.23,-.22,-.34,.21,-.22,-.01,-.16,-.09,-.49,-.13,.24,-.19,-.15)*f4_1+\n        mat4(.36,.09,.26,.46,.37,.18,.19,.38,-.16,-.26,.27,.34,-.37,.09,.30,-.35)*f4_2+\n        mat4(.35,-.11,.21,.20,-.15,.03,-.35,.52,-.37,-.05,-.06,-.27,.21,.00,.04,.20)*f4_3+\n        mat4(.65,.32,.07,.79,.46,.21,.28,.49,-.13,-.26,-.30,.09,.54,-.15,-.12,.61)*f4_4+\n        mat4(.20,-.08,-.21,-.16,.04,-.23,.14,.38,.07,-.02,-.12,-.39,-.12,.14,-.24,-.46)*f4_5+\n        mat4(-.18,.20,.37,-.27,.09,-.30,.01,.37,.18,.09,.35,-.14,.13,.31,.41,.29)*f4_6+\n        mat4(-.22,-.14,-.34,-.14,-.76,.24,.12,-.24,.09,-.13,-.19,-.09,-.15,.05,-.31,-.78)*f4_7+\n        vec4(.64,-1.60,1.17,-1.50))/2.2+f4_3;\n    vec4 f5_4=sin(mat4(.31,.59,-.26,.16,.05,-.02,-.22,.26,-.25,-.00,-.15,-.02,.21,.79,.30,.45)*f4_0+\n        mat4(-.18,.06,-.24,.17,.33,.12,.07,-.22,-.26,.27,-.15,.03,.39,.20,-.01,-.15)*f4_1+\n        mat4(-.35,-.40,-.25,-.61,-.03,-.48,-.21,-.31,.31,.01,.35,.02,.08,.12,.04,.55)*f4_2+\n        mat4(-.47,.04,.44,.16,-.41,-.00,-.26,-.00,.39,.57,.09,.25,-.24,-.06,-.08,-.15)*f4_3+\n        mat4(-.60,-.81,-.09,-.78,-.21,.02,-.17,-.05,.13,.19,.18,-.21,-.37,-.57,.07,-.22)*f4_4+\n        mat4(.09,.52,.08,.05,.19,-.29,.01,-.39,-.09,.34,-.32,.10,.18,.14,-.24,.30)*f4_5+\n        mat4(.22,.56,.17,.48,.15,.15,-.04,-.30,.27,.19,-.05,-.15,-.18,-.59,.50,.09)*f4_6+\n        mat4(-.27,-.08,.53,.21,.32,.29,-.17,.29,-.18,.13,-.04,.03,.09,.46,.21,.23)*f4_7+\n        vec4(1.63,-1.72,1.93,2.00))/2.2+f4_4;\n    vec4 f5_5=sin(mat4(.13,-.07,.21,-.17,.26,-.14,-.11,.09,.45,.07,-.25,.15,-.12,.12,.39,-.54)*f4_0+\n        mat4(-.11,-.02,-.07,.23,.14,.35,.47,-.38,.06,.56,.24,-.31,-.06,-.03,.04,-.06)*f4_1+\n        mat4(.20,-.14,-.47,.53,.28,-.08,-.16,.72,-.14,-.35,-.10,.34,.13,.14,.05,-.28)*f4_2+\n        mat4(.17,-.06,.10,.18,.13,-.11,-.24,.57,.52,.07,.01,-.30,.13,-.38,-.24,.24)*f4_3+\n        mat4(.12,-.26,-.40,1.04,.15,-.02,-.21,.51,.46,.19,-.21,.08,-.05,.14,-.63,1.08)*f4_4+\n        mat4(.18,-.13,-.26,-.28,-.07,-.33,.15,-.01,.13,.04,.35,-.18,-.23,.32,.43,-.87)*f4_5+\n        mat4(-.16,-.19,.20,-.18,.07,-.05,-.04,.37,-.06,-.19,-.02,-.12,-.02,.21,-.16,.52)*f4_6+\n        mat4(-.40,.16,.00,.07,.33,-.08,-.03,-.46,.05,-.19,.31,-.14,-.03,.29,.45,-.63)*f4_7+\n        vec4(.60,.40,-.34,1.19))/2.2+f4_5;\n    vec4 f5_6=sin(mat4(.01,-.12,-.34,-.17,.13,.02,-.39,-.40,.26,-.03,.31,.01,.51,.36,.10,.55)*f4_0+\n        mat4(.15,-.04,.14,.43,-.04,.25,.12,.09,-.30,-.10,-.39,-.32,-.26,-.01,-.37,-.10)*f4_1+\n        mat4(-.14,-.77,.63,.07,-.10,.30,.23,.14,.09,.60,.04,-.09,.36,-.03,.15,-.24)*f4_2+\n        mat4(-.25,.06,-.17,.52,.03,-.23,.47,.05,.18,-.09,-.32,-.09,-.04,.05,-.23,-.12)*f4_3+\n        mat4(-.08,.54,.57,.33,-.21,.59,.23,.38,-.26,-.76,-.47,-.25,-.41,-.06,.18,.16)*f4_4+\n        mat4(-.10,.25,-.31,.18,.00,-.05,-.22,.45,.32,.08,.07,.70,-.17,.78,-.11,-.37)*f4_5+\n        mat4(-.24,.18,-.17,-.36,-.02,.28,.22,.46,.13,-.43,-.39,-.33,-.03,-.28,.14,.10)*f4_6+\n        mat4(-.02,.14,.01,-.09,.19,-.12,-.32,-.09,-.50,-.10,.02,-.23,.26,.58,.42,.40)*f4_7+\n        vec4(-1.28,1.50,1.33,-1.03))/2.2+f4_6;\n    vec4 f5_7=sin(mat4(.43,.36,.17,-.20,-.34,.30,-.05,.16,-.04,-.08,-.06,.00,.54,.05,-.14,-.79)*f4_0+\n        mat4(-.15,-.02,-.16,-.19,.09,.61,-.44,-.45,-.22,.08,-.16,-.33,.03,.19,-.36,-.07)*f4_1+\n        mat4(-.42,-.17,.08,.58,-.26,-.23,.36,.56,-.02,-.13,-.20,.25,.14,.28,.08,-.22)*f4_2+\n        mat4(.05,-.25,.18,.05,-.03,-.16,.50,.27,.28,-.11,-.15,-.41,.04,.09,.18,.25)*f4_3+\n        mat4(-.32,.15,.01,1.00,-.22,-.08,-.02,.33,.24,-.13,.35,.02,-.12,-.21,.17,.57)*f4_4+\n        mat4(-.08,.36,-.04,-.40,-.10,-.46,-.20,.18,.05,-.18,.18,-.01,.17,.32,.05,-.20)*f4_5+\n        mat4(.28,.13,-.20,-.15,.19,.18,.21,.20,.29,.11,.23,-.27,-.02,-.13,.12,-.05)*f4_6+\n        mat4(.24,-.45,.01,.17,-.18,.18,.20,-.46,.03,.06,-.22,-.01,.36,-.20,-.25,-.48)*f4_7+\n        vec4(-.87,.99,-1.68,.86))/2.2+f4_7;\n    vec4 f6_0=sin(mat4(-.11,-.16,-.08,-.14,-.43,-.26,.18,-.22,.12,.32,.20,.16,.39,-.41,-.76,.48)*f5_0+\n        mat4(.42,-.07,-.04,.35,-.42,-.28,-.34,-.13,-.11,-.48,-.10,.25,-.14,.18,.21,-.01)*f5_1+\n        mat4(-.05,.02,.59,-.21,-.09,.07,.39,-.40,-.37,.35,.38,-.35,-.20,-.20,-.29,.17)*f5_2+\n        mat4(.56,-.35,.32,.26,-.29,.04,.10,-.12,-.29,-.05,-.13,.20,.15,.02,.29,-.54)*f5_3+\n        mat4(.06,.24,.65,-.25,.08,.00,.36,-.30,-.19,-.42,.50,-.09,-.11,-.03,.49,-.24)*f5_4+\n        mat4(.16,.07,.29,.36,.20,.07,.31,.36,-.08,-.01,-.41,.40,-.15,-.18,-.89,.54)*f5_5+\n        mat4(-.10,.16,.05,-.21,.33,.13,-.12,.21,-.48,-.30,-.14,.04,.04,.12,-.02,.37)*f5_6+\n        mat4(.36,-.69,-.26,.22,-.40,-.08,-.05,.01,.32,-.11,-.10,.05,.34,-.39,-.30,.83)*f5_7+\n        vec4(2.05,1.37,.22,-.66))/2.4+f5_0;\n    vec4 f6_1=sin(mat4(.02,-.27,-.37,.17,-.10,-.11,-.21,-.10,-.30,-.10,.08,-.34,.81,-.07,.02,.71)*f5_0+\n        mat4(-.06,.02,-.05,.03,.50,-.19,.14,.04,.11,.06,-.31,.08,-.25,.34,-.09,.08)*f5_1+\n        mat4(-.65,.61,.06,-.65,-.53,.40,-.07,-.20,-.39,-.05,.48,-.45,.04,-.32,.07,-.09)*f5_2+\n        mat4(-.58,.47,.03,-.35,.07,-.20,.12,-.19,.00,.15,-.17,.15,-.17,.13,.06,-.12)*f5_3+\n        mat4(-.70,.59,.04,-.72,-.45,.40,-.04,-.45,-.35,.10,-.04,-.27,-.50,.13,.13,-.23)*f5_4+\n        mat4(.28,.05,.11,.17,.08,-.17,-.23,-.17,.43,-.27,-.31,.47,.73,-.64,-.34,.86)*f5_5+\n        mat4(.12,-.21,-.19,.37,-.58,-.26,-.11,-.43,.61,-.16,.17,.03,-.34,-.09,-.28,-.45)*f5_6+\n        mat4(.11,-.13,-.14,-.15,.28,.00,-.00,.28,-.26,.05,-.28,-.00,.68,-.42,-.24,.89)*f5_7+\n        vec4(-.26,1.81,.08,-.78))/2.4+f5_1;\n    vec4 f6_2=sin(mat4(.01,-.03,-.23,.16,.31,-.16,-.36,.17,-.26,.09,.19,-.46,.17,-.23,.35,.24)*f5_0+\n        mat4(.10,-.19,-.32,.39,.45,.08,.24,-.06,.06,-.40,.22,.24,-.19,-.07,.13,-.25)*f5_1+\n        mat4(-.36,.11,-.24,-.20,.02,-.26,-.62,.13,-.29,.38,.03,-.25,-.04,-.30,.39,.18)*f5_2+\n        mat4(-.19,.09,.16,-.39,-.13,.01,.01,.03,.02,.18,.24,.03,-.25,.14,-.02,-.21)*f5_3+\n        mat4(-.37,.10,-.18,-.30,-.20,.09,-.27,-.56,-.16,-.21,.01,.00,-.29,.25,-.29,-.50)*f5_4+\n        mat4(.16,.03,.20,-.03,.18,.08,.06,-.10,-.01,-.47,.15,.27,.46,-.45,.14,.30)*f5_5+\n        mat4(.28,-.20,-.06,-.04,-.34,-.03,.26,-.22,.06,-.22,.05,.02,.12,.12,.17,-.29)*f5_6+\n        mat4(.26,-.15,.46,.04,-.09,.05,.00,.09,-.46,.19,-.11,-.13,.27,-.28,.79,.82)*f5_7+\n        vec4(1.81,-.15,-.93,-.04))/2.4+f5_2;\n    vec4 f6_3=sin(mat4(-.31,.32,.30,-.70,.09,.06,.21,.05,-.16,-.44,-.34,.15,-.49,.12,.71,-.72)*f5_0+\n        mat4(.18,.19,-.20,-.01,-.05,.30,.14,-.40,-.17,.37,.48,-.07,.10,.02,-.32,-.11)*f5_1+\n        mat4(.23,-.28,-.54,.65,.34,-.27,-.95,.43,-.19,.19,-.11,-.35,-.02,-.13,.45,-.19)*f5_2+\n        mat4(.41,-.14,-.46,.40,.33,.10,-.19,-.07,-.41,-.03,.50,.08,.12,-.54,-.78,.64)*f5_3+\n        mat4(.40,-.93,-1.05,.62,.03,-.44,-.72,.20,.16,.11,-.22,.52,.16,-.21,-.82,.43)*f5_4+\n        mat4(-.29,.17,.07,-.15,.17,-.02,-.23,-.00,.02,.31,.48,-.09,-.47,.53,1.34,-.69)*f5_5+\n        mat4(-.24,.03,.53,-.24,.04,-.13,-.08,.21,-.27,.08,.51,-.63,-.15,.18,-.28,.09)*f5_6+\n        mat4(-.15,.21,.17,-.31,.15,.21,.27,-.31,.16,.12,-.34,.24,-.39,.67,1.19,-.87)*f5_7+\n        vec4(1.19,.75,-.43,1.05))/2.4+f5_3;\n    vec4 f6_4=sin(mat4(-.31,-.44,-.37,-.03,.04,-.15,.09,-.23,-.18,.44,.58,.53,-.80,.37,-.90,-.66)*f5_0+\n        mat4(-.15,.11,-.02,.09,-.16,.07,-.43,-.23,-.09,-.02,-.49,-.36,.27,-.02,.20,.40)*f5_1+\n        mat4(.50,.01,.74,.25,.31,.02,1.05,-.21,.38,-.20,.29,.02,-.53,-.17,-.30,.12)*f5_2+\n        mat4(.46,-.10,.45,-.08,.47,-.04,.29,.21,-.41,-.03,-.64,.03,.49,.18,.73,.10)*f5_3+\n        mat4(.52,-.15,1.24,.33,.44,.27,.91,.21,.18,-.22,.53,.19,.48,-.03,.97,-.03)*f5_4+\n        mat4(-.05,-.25,-.09,.26,.07,-.17,.09,.05,-.55,.02,-.67,-.42,-.95,-.54,-1.53,-.44)*f5_5+\n        mat4(-.03,.02,-.48,-.23,-.06,.04,.25,.08,-.50,-.21,-.66,-.34,.04,.32,.52,.37)*f5_6+\n        mat4(.00,-.29,-.19,.34,-.10,.16,-.31,.09,-.03,.06,.19,-.03,-.62,-.08,-1.31,-.83)*f5_7+\n        vec4(.22,1.33,1.39,-1.35))/2.4+f5_4;\n    vec4 f6_5=sin(mat4(-.22,-.06,-.19,-.06,-.55,-.47,.16,.01,-.25,-.01,.41,-.40,.15,-.07,-.91,.01)*f5_0+\n        mat4(.25,.29,-.28,.19,.02,-.57,.14,.18,-.04,.43,.27,.37,.15,-.09,.18,.01)*f5_1+\n        mat4(.25,.62,.02,-.22,-.33,-.30,.48,-.21,-.20,-.21,.37,-.19,-.16,.14,.14,-.02)*f5_2+\n        mat4(.30,.55,-.16,-.77,.07,-.04,-.16,-.15,.32,.23,-.53,.02,-.06,-.52,.34,-.37)*f5_3+\n        mat4(-.35,.38,.71,-.52,.10,.28,.43,-.39,.28,.28,.06,.03,-.17,-.01,.01,-.38)*f5_4+\n        mat4(.12,-.03,-.36,.17,.18,-.05,-.16,.21,-.17,.21,-.32,.20,.12,.31,-.19,.49)*f5_5+\n        mat4(-.37,-.05,.09,.12,.10,.01,.07,-.20,.01,-.32,-.31,.04,-.20,-.05,-.02,-.38)*f5_6+\n        mat4(.32,.09,-.17,.19,-.30,-.15,.28,.12,.33,-.15,-.20,-.13,.64,.25,-.83,.57)*f5_7+\n        vec4(-.45,.30,1.30,.01))/2.4+f5_5;\n    vec4 f6_6=sin(mat4(.50,.07,.04,-.31,.42,.26,-.07,.11,-.19,.36,-.44,.15,.18,-.52,.46,-.34)*f5_0+\n        mat4(-.10,-.12,.31,.09,.17,.29,-.04,.03,-.07,-.62,-.13,-.34,-.14,.34,-.30,-.00)*f5_1+\n        mat4(-.11,-.24,-.30,.21,-.28,-.03,.01,.59,.00,.18,-.45,.17,.16,-.47,.26,-.34)*f5_2+\n        mat4(-.57,-.31,-.20,.63,.09,.02,.27,.17,.04,-.06,.31,.06,-.21,.41,-.59,.23)*f5_3+\n        mat4(-.16,-.43,-.18,.67,-.49,.08,-.33,.15,.17,-.22,-.25,-.28,.06,-.06,-.15,.41)*f5_4+\n        mat4(-.04,-.03,.09,.16,-.09,.27,-.24,.19,.04,-.13,.30,-.14,.50,-.66,.43,-.68)*f5_5+\n        mat4(.30,-.02,.10,-.59,-.00,.42,.11,-.17,.20,-.10,.37,-.01,-.42,.19,-.09,.29)*f5_6+\n        mat4(.40,-.49,.06,.27,.30,-.02,.25,-.06,-.13,.24,.19,-.07,.53,-.38,.20,-.65)*f5_7+\n        vec4(.16,-.30,1.82,.75))/2.4+f5_6;\n    vec4 f6_7=sin(mat4(-.16,.40,-.33,.55,-.16,.32,-.04,-.09,-.09,.06,.01,.01,-.15,.12,-.05,.34)*f5_0+\n        mat4(-.01,.45,-.28,.04,-.16,.15,.16,.12,-.28,-.10,.19,.33,-.12,-.41,.14,-.09)*f5_1+\n        mat4(.15,.11,.43,-.11,.25,.50,.52,-.30,.38,-.17,-.17,-.13,-.15,-.53,-.12,.29)*f5_2+\n        mat4(.38,.35,.12,.10,.11,-.06,-.06,-.28,.22,.42,.16,.21,.02,.17,.54,.37)*f5_3+\n        mat4(.17,.01,-.06,-.03,.06,-.19,.38,-.18,-.14,.22,-.03,.06,-.14,.22,.06,-.36)*f5_4+\n        mat4(.28,-.09,-.00,.01,-.06,-.04,-.12,.03,.21,.34,-.21,.37,-.33,.10,-.35,.54)*f5_5+\n        mat4(-.13,-.38,-.09,.44,-.16,.03,-.47,-.09,-.14,.03,.25,.38,.40,-.15,.27,-.15)*f5_6+\n        mat4(-.10,-.18,-.06,.14,-.24,-.08,-.01,.13,-.10,.29,.35,.30,-.31,.09,-.21,.69)*f5_7+\n        vec4(1.51,.86,-.69,.35))/2.4+f5_7;\n    float return_val1 = dot(f6_0,vec4(-.04,-.02,.05,-.06))+\n        dot(f6_1,vec4(.05,.02,.00,.04))+\n        dot(f6_2,vec4(.02,.01,-.03,-.02))+\n        dot(f6_3,vec4(.02,-.02,-.03,.03))+\n        dot(f6_4,vec4(.03,.03,-.03,.02))+\n        dot(f6_5,vec4(-.03,-.03,-.04,-.03))+\n        dot(f6_6,vec4(-.03,.01,-.04,.03))+\n        dot(f6_7,vec4(-.04,-.03,-.02,-.04))+\n        -0.058* sin(iTime);\n        \n        // comment this line out to view averaged version\n        return return_val1;\n        \n        p.y = -p.y;\n    //neural networks can be really compact... when they want to be\n    vec4 ff0_0=sin(p.y*vec4(-.36,3.91,-3.69,4.22)+p.z*vec4(2.66,2.44,3.63,.17)+p.x*vec4(4.17,-3.60,2.72,3.83)+vec4(-4.46,5.05,5.55,3.40));\n    vec4 ff0_1=sin(p.y*vec4(-1.06,.99,2.93,-2.01)+p.z*vec4(4.36,4.04,-3.04,3.80)+p.x*vec4(1.44,-.18,-3.28,3.02)+vec4(-4.20,-1.99,-6.45,-7.70));\n    vec4 ff0_2=sin(p.y*vec4(1.32,-2.91,-3.22,2.16)+p.z*vec4(.47,1.89,4.12,-3.69)+p.x*vec4(1.70,2.75,-3.95,2.05)+vec4(7.41,7.30,-3.35,4.89));\n    vec4 ff0_3=sin(p.y*vec4(-.10,-1.56,3.64,-3.34)+p.z*vec4(-3.91,-1.39,-3.21,-1.08)+p.x*vec4(3.88,1.33,-1.01,2.47)+vec4(-.38,-7.95,-1.31,2.00));\n    vec4 ff0_4=sin(p.y*vec4(2.73,-4.30,3.91,3.05)+p.z*vec4(4.31,4.08,3.19,-.84)+p.x*vec4(2.73,2.84,-2.84,-.57)+vec4(.31,-3.00,-4.98,4.69));\n    vec4 ff0_5=sin(p.y*vec4(1.47,-1.32,-1.36,-1.11)+p.z*vec4(-.58,-.16,4.40,.07)+p.x*vec4(1.70,.12,3.56,2.22)+vec4(-3.33,-3.22,.81,6.42));\n    vec4 ff0_6=sin(p.y*vec4(2.95,-2.96,2.12,-3.19)+p.z*vec4(-2.98,-.25,-3.79,-2.67)+p.x*vec4(.03,2.63,-.60,3.66)+vec4(-5.86,-5.04,-.64,6.42));\n    vec4 ff0_7=sin(p.y*vec4(.33,-2.89,-2.13,-.34)+p.z*vec4(-3.16,.97,3.91,1.84)+p.x*vec4(-.42,-3.11,-.39,-4.40)+vec4(6.18,-7.99,-1.16,-3.38));\n    vec4 ff1_0=sin(mat4(.24,-.06,.27,-.20,.24,-.25,.19,-.28,-.18,.34,.14,-.09,.25,-.19,.17,-.30)*ff0_0+\n        mat4(.00,.19,-.04,.08,-.02,-.20,.07,-.16,-.27,-.18,-.37,-.21,-.19,-.15,.15,.07)*ff0_1+\n        mat4(.19,.03,-.25,.39,-.02,-.15,.03,.23,.09,.02,.07,-.05,-.20,.25,-.19,-.34)*ff0_2+\n        mat4(-.27,-.31,-.05,-.15,-.02,-.04,-.12,.01,.20,-.33,-.15,-.07,-.05,.04,-.77,.15)*ff0_3+\n        mat4(.17,.10,-.14,-.21,.30,.04,-.23,-.11,.11,-.13,.33,-.17,.11,.03,-.32,-.38)*ff0_4+\n        mat4(.01,-.17,.16,-.02,.02,.22,-.11,.09,.00,-.01,.28,.02,.11,.20,.40,-.26)*ff0_5+\n        mat4(-.33,.07,.20,-.08,-.22,.22,.07,.19,.27,-.32,-.23,-.08,.13,-.22,-.10,.01)*ff0_6+\n        mat4(.01,-.22,.35,-.00,.19,.28,-.04,-.46,-.31,-.05,.24,-.24,-.30,-.33,-.01,.00)*ff0_7+\n        vec4(-2.22,-.05,-.81,-.60))/1.0+ff0_0;\n    vec4 ff1_1=sin(mat4(.18,.12,.28,.64,.07,-.11,-.02,.11,-.33,-.50,-.14,-.11,-.57,-.17,.05,.15)*ff0_0+\n        mat4(-.23,-.10,-.32,-.20,-.13,.24,.26,.23,-.18,.06,-.26,.39,-.12,.35,.04,.20)*ff0_1+\n        mat4(.10,-.12,.14,.34,-.12,.04,.39,-.19,.25,.24,-.29,-.31,.11,.12,.07,-.20)*ff0_2+\n        mat4(-.03,.08,-.17,-.16,.14,-.18,-.25,.06,-.08,.35,-.02,.33,.31,.09,-.10,-.10)*ff0_3+\n        mat4(.14,-.36,-.12,-.67,.08,.04,.11,.19,.22,.43,-.21,-.21,-.11,.40,-.32,.25)*ff0_4+\n        mat4(-.04,.13,-.01,.23,.29,.31,-.15,.08,-.30,-.24,-.38,-.16,-.25,-.40,.21,.06)*ff0_5+\n        mat4(.29,-.13,.14,.09,.40,-.22,.24,-.43,.23,.42,-.07,.16,.04,-.20,.26,-.16)*ff0_6+\n        mat4(-.03,.20,-.15,.34,-.27,-.20,.00,-.45,.05,.39,-.16,-.24,.25,.04,-.17,-.12)*ff0_7+\n        vec4(1.74,-1.39,-.15,-.86))/1.0+ff0_1;\n    vec4 ff1_2=sin(mat4(-.54,.29,.36,.34,-.01,-.05,-.28,.16,.30,.25,-.34,.05,.21,.06,-.16,-.22)*ff0_0+\n        mat4(.05,.31,-.43,.30,.21,-.25,-.05,-.04,-.33,-.06,.65,-.27,-.15,-.17,-.07,.19)*ff0_1+\n        mat4(-.42,-.11,-.04,.29,-.06,-.26,.06,.21,-.12,.36,-.31,-.20,-.38,-.11,.20,-.19)*ff0_2+\n        mat4(-.04,.28,.20,.33,.17,.12,-.48,-.04,-.34,-.24,-.01,-.09,-.20,.13,.47,-.28)*ff0_3+\n        mat4(.23,.17,.37,.11,-.30,-.22,.42,-.20,.08,-.03,.36,-.40,.02,-.36,.13,-.04)*ff0_4+\n        mat4(.01,.33,-.26,.16,-.21,-.21,.43,.01,.34,-.09,-.05,.12,.19,-.15,.34,.31)*ff0_5+\n        mat4(-.43,.16,.22,-.14,-.12,.11,.27,.13,-.16,.08,.22,-.54,.19,-.02,-.32,.15)*ff0_6+\n        mat4(-.38,-.25,.33,-.25,-.25,-.64,.30,-.23,.20,-.01,.25,.03,-.07,.47,-.02,-.11)*ff0_7+\n        vec4(-1.57,1.30,1.31,-.69))/1.0+ff0_2;\n    vec4 ff1_3=sin(mat4(-.04,-.21,-.27,-.16,.38,.03,-.12,-.03,.32,.18,.27,-.25,-.43,.50,-.35,.13)*ff0_0+\n        mat4(.37,.17,-.20,-.04,.40,-.59,.20,.39,.05,.14,-.17,-.20,.16,.18,.21,-.07)*ff0_1+\n        mat4(.12,-.25,.40,-.46,-.36,-.16,-.11,.09,.26,-.48,.00,-.28,-.36,.21,-.11,-.01)*ff0_2+\n        mat4(.13,-.20,-.06,-.25,.14,.29,-.31,.24,-.04,.29,.05,.16,-.18,.07,.28,-.28)*ff0_3+\n        mat4(-.19,-.12,.33,-.12,.03,.32,-.03,.08,-.56,.19,.25,.08,.01,.32,.05,.14)*ff0_4+\n        mat4(.55,-.02,.21,.13,-.26,.41,.02,-.29,.12,-.17,-.16,-.04,-.58,.10,.05,.20)*ff0_5+\n        mat4(-.03,-.14,.13,.13,-.16,.19,.02,.09,-.34,.09,.02,.01,-.01,-.20,-.09,.13)*ff0_6+\n        mat4(.19,-.19,-.17,.04,-.57,.08,.18,.32,.02,-.01,-.29,-.22,.22,.11,-.02,.04)*ff0_7+\n        vec4(-2.23,.27,-.36,.14))/1.0+ff0_3;\n    vec4 ff1_4=sin(mat4(-.22,-.17,.03,.13,.20,.35,-.18,-.10,-.13,.31,-.29,.17,-.23,.23,.47,-.01)*ff0_0+\n        mat4(.34,.19,.04,-.14,-.09,.48,.24,-.27,-.19,.29,-.06,.12,.16,-.18,.27,.06)*ff0_1+\n        mat4(-.17,-.25,-.30,-.38,.15,-.18,.16,-.12,.21,-.18,.18,-.19,.25,.30,.11,.27)*ff0_2+\n        mat4(.29,-.15,-.06,.07,-.19,-.00,.13,.14,.36,.11,.42,.21,.25,-.21,-.28,-.03)*ff0_3+\n        mat4(.69,-.28,-.19,.01,-.03,-.05,-.09,-.02,-.01,.15,-.06,.02,.15,.24,.04,-.15)*ff0_4+\n        mat4(-.26,.02,.21,-.45,.11,-.08,.14,.36,.19,-.32,-.05,-.17,.40,-.06,.12,-.01)*ff0_5+\n        mat4(-.06,.39,-.00,.02,-.16,.09,-.18,-.20,.36,.32,-.07,.19,.12,-.26,-.10,.29)*ff0_6+\n        mat4(-.38,.38,.16,-.04,.32,.04,-.08,.07,.34,.13,-.04,.08,.25,-.26,-.13,.02)*ff0_7+\n        vec4(-.71,-1.58,-2.04,-.56))/1.0+ff0_4;\n    vec4 ff1_5=sin(mat4(.19,.20,-.43,-.12,.07,-.08,-.22,.18,.34,-.31,.29,.18,.16,.01,-.25,.13)*ff0_0+\n        mat4(.25,.00,.02,-.13,-.14,.31,.30,.20,.22,-.11,.04,-.23,.17,-.19,-.18,-.16)*ff0_1+\n        mat4(.30,.20,.13,-.43,.07,.03,.29,-.07,.36,.01,-.27,.24,-.35,-.15,.25,-.22)*ff0_2+\n        mat4(-.02,-.04,.01,.25,.04,-.24,-.09,.38,.16,.14,.15,-.06,.33,.17,.11,-.04)*ff0_3+\n        mat4(-.14,.05,.42,-.09,.13,-.04,.02,.20,-.02,-.29,-.46,.04,-.06,.08,-.19,.33)*ff0_4+\n        mat4(.14,-.29,.08,-.31,-.20,.09,-.08,-.14,.01,.05,.18,-.08,-.39,-.04,.16,.20)*ff0_5+\n        mat4(.00,-.01,-.26,.04,.05,.30,.12,-.18,.08,.44,-.05,-.40,.07,.48,-.11,.19)*ff0_6+\n        mat4(.15,.13,-.13,.03,-.26,-.25,.01,-.32,-.26,-.16,-.09,-.04,-.06,-.37,-.25,.26)*ff0_7+\n        vec4(-.39,1.49,-.68,-1.91))/1.0+ff0_5;\n    vec4 ff1_6=sin(mat4(.50,-.02,-.69,.07,.06,-.07,-.06,-.12,-.25,-.01,.36,-.01,-.10,.17,.35,-.60)*ff0_0+\n        mat4(.31,.07,-.18,-.35,.66,.17,-.34,-.07,-.15,.39,-.14,.14,-.16,-.15,.18,-.03)*ff0_1+\n        mat4(-.11,.14,.21,-.07,.16,-.33,-.24,.08,-.12,.06,-.20,-.20,.21,-.23,-.21,.24)*ff0_2+\n        mat4(.06,-.27,-.25,.11,.11,.24,-.18,.25,.28,-.24,-.13,-.17,-.22,-.39,-.23,.46)*ff0_3+\n        mat4(-.61,.14,.33,.63,.22,-.01,-.29,.20,-.46,-.10,.36,.46,.29,.01,.08,-.34)*ff0_4+\n        mat4(.33,.33,-.26,-.02,-.48,-.13,-.03,-.28,-.03,-.26,.16,.22,.31,.04,-.28,-.09)*ff0_5+\n        mat4(-.13,-.04,-.25,.22,-.45,.01,.19,.28,.36,-.27,-.22,-.05,-.12,-.05,.01,.34)*ff0_6+\n        mat4(-.06,.11,.20,-.00,.06,.01,.30,.16,-.17,.03,.20,-.05,-.21,-.27,-.35,.09)*ff0_7+\n        vec4(1.97,2.24,-1.04,-1.98))/1.0+ff0_6;\n    vec4 ff1_7=sin(mat4(.14,.48,-.15,-.37,.21,.26,-.16,-.14,-.17,.04,.35,.27,-.30,-.34,.26,-.18)*ff0_0+\n        mat4(.13,-.13,-.46,-.43,-.02,.54,-.21,.03,.39,-.14,.23,-.00,.30,-.12,-.04,-.02)*ff0_1+\n        mat4(.01,-.02,-.32,.13,.23,.01,-.22,-.16,.15,-.17,-.23,.00,-.45,.15,-.09,-.49)*ff0_2+\n        mat4(.23,.10,-.10,.41,.16,.34,-.47,.18,-.12,.03,-.15,-.20,-.19,-.37,.08,-.03)*ff0_3+\n        mat4(-.29,-.26,.17,.08,-.19,.05,.11,-.01,-.15,-.27,.26,-.20,-.25,-.40,-.22,-.17)*ff0_4+\n        mat4(.37,-.14,.25,.31,.30,-.25,.15,-.35,-.09,-.13,-.07,.11,-.15,.17,-.29,.27)*ff0_5+\n        mat4(-.16,.04,-.17,-.11,.23,.15,-.25,.01,.22,.16,.08,-.26,.41,-.14,-.17,.17)*ff0_6+\n        mat4(-.15,-.03,-.29,-.06,-.68,-.18,.22,-.45,.25,-.12,-.11,-.27,.10,.24,.13,-.18)*ff0_7+\n        vec4(-.06,-.40,1.48,-1.43))/1.0+ff0_7;\n    vec4 ff2_0=sin(mat4(.31,.34,.12,.13,-.10,.27,-.33,-.21,-.19,.27,-.03,.13,.18,-.29,-.25,-.03)*ff1_0+\n        mat4(.21,-.36,-.45,.11,.00,.05,-.36,-.32,-.06,.24,.21,.07,-.14,.15,-.22,.31)*ff1_1+\n        mat4(.32,-.14,-.17,.21,.17,.09,-.15,-.26,-.13,.12,.27,-.35,.21,.11,-.15,-.13)*ff1_2+\n        mat4(-.25,-.08,.01,.37,-.27,.17,.04,-.21,-.03,-.16,.14,.08,-.13,-.04,.33,-.27)*ff1_3+\n        mat4(-.02,.18,.03,-.32,.06,-.20,.06,.05,-.05,.26,.15,-.15,-.14,-.22,-.05,.18)*ff1_4+\n        mat4(.16,-.05,-.31,-.07,.27,.15,-.08,.39,.19,.14,-.28,-.06,-.33,.03,.04,-.16)*ff1_5+\n        mat4(.13,-.20,-.09,-.06,-.14,.15,.16,.14,-.29,-.32,.17,.07,.29,.32,.22,-.09)*ff1_6+\n        mat4(-.20,-.04,.18,.10,.28,.31,-.14,-.24,.17,-.15,-.03,.16,.34,-.31,.30,-.14)*ff1_7+\n        vec4(-.75,-.96,1.04,1.19))/1.4+ff1_0;\n    vec4 ff2_1=sin(mat4(.05,-.44,-.16,-.17,.03,.19,-.28,.36,-.18,-.10,.31,-.06,.19,.14,-.13,.08)*ff1_0+\n        mat4(-.46,-.46,-.42,-.13,.08,.06,-.22,-.10,.41,-.47,.11,.15,-.14,.37,.13,.43)*ff1_1+\n        mat4(.40,.35,.25,.51,-.21,.06,-.28,.35,-.08,-.39,.02,.19,-.21,-.25,.00,.34)*ff1_2+\n        mat4(.60,.17,-.03,.45,-.39,-.29,.01,.03,.24,.50,.28,.12,.06,-.54,-.06,.36)*ff1_3+\n        mat4(.41,-.07,.25,.34,.18,.18,-.18,.30,.31,.47,-.01,.28,-.02,.12,-.17,-.30)*ff1_4+\n        mat4(.20,-.40,-.04,-.54,-.16,.22,-.05,.10,-.02,.28,-.49,.21,.17,-.16,.02,.24)*ff1_5+\n        mat4(-.03,.06,-.01,.25,-.22,-.18,-.17,-.01,.01,.03,-.07,-.02,.36,.23,-.26,.52)*ff1_6+\n        mat4(.28,.09,.25,-.02,.11,-.10,-.21,.07,.29,.11,.06,-.30,-.22,-.43,-.07,-.44)*ff1_7+\n        vec4(-1.37,-1.80,-.48,-2.17))/1.4+ff1_1;\n    vec4 ff2_2=sin(mat4(.17,.06,.09,.15,-.07,-.21,-.27,.19,-.00,-.30,.03,-.02,-.19,.29,.05,-.06)*ff1_0+\n        mat4(-.17,-.31,-.06,-.12,-.23,-.63,.02,-.33,.23,.31,.07,.33,-.08,-.83,-.49,.21)*ff1_1+\n        mat4(.07,.79,.27,.06,.05,.44,.10,.08,-.15,.26,-.18,-.04,.37,-.02,.30,-.19)*ff1_2+\n        mat4(-.08,.46,.09,-.03,-.09,-.44,-.01,.33,.08,.10,-.06,-.13,-.22,.54,.08,.26)*ff1_3+\n        mat4(-.16,-.17,-.23,.32,-.03,-.15,.38,.03,-.15,.15,.43,-.45,.20,-.12,.23,.23)*ff1_4+\n        mat4(.49,-.44,.29,.40,-.29,-.08,-.39,.16,.06,-.36,.01,-.21,-.02,.20,.21,.17)*ff1_5+\n        mat4(.03,-.07,-.08,-.12,.13,-.19,.06,-.17,.44,.94,.38,.39,-.11,.18,.18,.09)*ff1_6+\n        mat4(-.05,.26,.01,-.06,.15,.30,-.06,.25,-.06,-.06,-.30,.41,.25,-.22,.04,.10)*ff1_7+\n        vec4(-.45,-.38,1.48,-1.50))/1.4+ff1_2;\n    vec4 ff2_3=sin(mat4(.14,.23,.30,.17,.04,.06,.20,-.36,-.16,.15,-.05,-.20,-.10,.04,.01,-.19)*ff1_0+\n        mat4(-.19,.13,-.06,-.20,.34,-.24,-.20,.37,-.25,.01,.00,-.14,.32,-.14,-.39,-.08)*ff1_1+\n        mat4(.12,.15,.02,-.26,-.09,-.13,.32,-.20,.12,-.09,-.08,.13,-.11,.20,.03,-.09)*ff1_2+\n        mat4(-.29,-.02,.03,.13,.01,.34,.26,.01,.46,-.25,-.31,-.01,.13,-.27,.03,-.05)*ff1_3+\n        mat4(.21,.15,-.73,.01,.06,.34,.05,-.03,.20,.34,-.08,-.19,-.09,.02,-.04,.33)*ff1_4+\n        mat4(-.07,-.02,.15,-.07,-.28,.39,-.09,.03,.35,.08,-.05,-.05,.34,.12,-.01,.22)*ff1_5+\n        mat4(-.28,.25,.31,.15,.09,-.13,-.46,-.12,-.42,-.30,.28,.20,.20,.33,-.25,-.10)*ff1_6+\n        mat4(.45,-.04,.43,.41,.14,-.03,.27,.32,-.06,-.07,-.26,.02,.13,.11,-.14,.20)*ff1_7+\n        vec4(-2.16,-1.49,-1.83,.87))/1.4+ff1_3;\n    vec4 ff2_4=sin(mat4(-.31,.13,.18,.04,.16,.34,-.03,-.10,.26,-.24,.17,-.09,-.25,-.23,.13,.07)*ff1_0+\n        mat4(.51,-.22,.40,.07,.51,-.33,.06,.23,-.08,-.31,.23,.01,.42,.44,-.09,.09)*ff1_1+\n        mat4(-.35,.29,-.01,-.17,.13,-.06,-.22,-.34,.12,-.19,.04,-.12,.24,-.05,-.07,.02)*ff1_2+\n        mat4(.26,.39,-.17,-.25,-.21,.10,.26,.24,-.14,.02,-.11,-.20,.24,-.01,-.14,-.20)*ff1_3+\n        mat4(.22,.54,-.11,.09,.39,.19,-.03,.03,.34,.02,-.06,-.33,.01,.12,.33,.11)*ff1_4+\n        mat4(-.19,.15,-.10,.17,-.00,.16,-.43,-.02,.48,-.09,.18,.08,.59,.03,-.10,.05)*ff1_5+\n        mat4(.10,-.38,-.04,.40,-.18,-.01,-.08,-.11,-.64,-.37,.29,.19,.43,.22,-.11,-.04)*ff1_6+\n        mat4(.07,-.34,-.11,.40,.10,.01,.30,.27,-.06,.35,-.36,.07,-.04,.12,.28,.18)*ff1_7+\n        vec4(-.80,1.64,-.76,.72))/1.4+ff1_4;\n    vec4 ff2_5=sin(mat4(.01,.04,-.06,-.02,-.31,.10,.24,-.08,.35,.10,.35,.05,.10,-.06,-.04,.11)*ff1_0+\n        mat4(.21,.43,.57,-.10,.38,.18,-.14,-.21,-.19,.18,-.39,.07,.17,.27,.42,.29)*ff1_1+\n        mat4(-.33,-.60,-.18,-.04,.01,.32,.01,-.08,.03,-.19,.08,.16,-.55,.16,-.44,-.27)*ff1_2+\n        mat4(-.02,-.18,-.20,.30,.05,-.12,-.24,-.29,-.10,.07,.01,.11,-.33,.15,-.38,-.21)*ff1_3+\n        mat4(.05,-.19,.22,.11,-.35,.24,-.05,.03,-.23,.35,-.32,.15,.18,.31,.16,-.12)*ff1_4+\n        mat4(.13,-.23,.06,.42,.16,.27,.48,.33,.08,-.13,-.29,-.01,-.09,-.02,.03,.23)*ff1_5+\n        mat4(-.42,-.02,-.09,-.25,.08,.16,.11,.22,-.37,-.05,.14,-.23,.08,.15,-.02,.16)*ff1_6+\n        mat4(-.22,.18,-.20,.03,-.57,-.30,.03,-.19,.29,.14,.38,.23,.06,.18,-.03,-.05)*ff1_7+\n        vec4(.92,1.27,.72,-1.02))/1.4+ff1_5;\n    vec4 ff2_6=sin(mat4(.05,.50,.23,.09,.09,.20,-.14,-.19,-.13,-.04,-.15,.22,-.05,.13,-.04,.49)*ff1_0+\n        mat4(.41,.09,-.21,.54,-.10,.24,.21,.46,-.21,-.01,-.29,-.27,.34,-.08,.29,-.22)*ff1_1+\n        mat4(.40,-.28,-.47,-.25,.20,-.08,-.31,-.50,-.48,.42,-.08,.19,-.24,.27,.13,.13)*ff1_2+\n        mat4(.04,.41,.10,-.09,-.12,.41,.07,.30,.33,-.04,-.10,-.17,-.09,.00,.24,.04)*ff1_3+\n        mat4(-.05,-.09,.27,-.17,-.13,.01,-.05,.01,-.23,-.02,.32,-.25,-.26,.15,-.20,-.19)*ff1_4+\n        mat4(.15,.23,.02,.12,.21,-.44,.16,-.30,-.12,.16,-.06,.03,.11,-.21,-.25,.01)*ff1_5+\n        mat4(-.38,.50,.13,.50,-.27,.11,-.25,.08,-.24,.16,.04,-.52,.03,.13,.08,-.30)*ff1_6+\n        mat4(-.06,.29,-.07,.25,-.22,.21,.04,.10,.21,-.31,-.00,-.29,-.39,-.08,.07,.20)*ff1_7+\n        vec4(-1.72,-.71,-1.40,.83))/1.4+ff1_6;\n    vec4 ff2_7=sin(mat4(-.09,-.29,-.24,-.26,.33,-.33,.39,.13,-.06,-.17,.24,-.26,.23,.09,.21,-.08)*ff1_0+\n        mat4(.50,.11,.17,.13,.40,-.03,.22,-.14,.22,.31,.26,-.16,.34,-.18,.29,.26)*ff1_1+\n        mat4(-.04,.33,-.26,-.18,.16,-.12,.34,-.02,.11,-.11,-.25,-.26,.27,.54,-.03,-.45)*ff1_2+\n        mat4(-.05,.08,.16,.03,-.25,-.07,-.16,.15,.32,.01,-.03,.29,-.09,-.07,.24,.24)*ff1_3+\n        mat4(.04,-.14,-.03,.30,-.02,.08,.05,.14,-.27,-.19,.47,.03,-.02,.17,.04,.03)*ff1_4+\n        mat4(-.09,.14,-.39,-.30,-.42,-.31,.11,.09,-.02,.28,.32,-.25,.36,-.06,.18,.12)*ff1_5+\n        mat4(.11,.36,-.07,-.47,-.23,.11,-.19,.14,-.18,.16,-.34,-.13,.18,.09,.32,.12)*ff1_6+\n        mat4(-.05,.05,-.34,-.23,.04,.08,-.29,-.15,-.37,-.05,.17,.44,-.38,-.28,-.06,.32)*ff1_7+\n        vec4(.89,-.88,-.86,1.29))/1.4+ff1_7;\n    vec4 ff3_0=sin(mat4(-.25,-.17,-.39,-.08,.27,.19,.12,.14,.28,.02,-.27,-.09,-.41,.06,.22,-.31)*ff2_0+\n        mat4(-.09,-.21,-.44,-.11,-.08,-.14,-.06,.07,.19,.13,-.11,.22,.35,-.46,.27,.16)*ff2_1+\n        mat4(.41,-.01,-.14,-.12,.02,.04,-.17,.33,-.07,-.04,.13,.53,.46,.02,-.01,.13)*ff2_2+\n        mat4(.09,.09,.05,-.31,-.09,.28,.05,-.17,.28,.10,.14,.11,.07,-.08,.18,-.26)*ff2_3+\n        mat4(-.01,-.08,.44,.26,-.21,-.04,.06,-.16,.39,.22,-.20,.25,.05,.06,-.19,-.17)*ff2_4+\n        mat4(-.19,-.06,.12,-.34,-.26,-.28,-.16,.35,-.06,-.09,.06,.09,-.20,-.21,-.26,-.05)*ff2_5+\n        mat4(-.00,.14,-.02,.24,-.00,-.11,-.18,.33,-.03,.15,.10,-.11,.28,-.26,.31,-.04)*ff2_6+\n        mat4(.22,-.26,-.09,-.12,.17,-.32,.13,.30,.19,.14,.02,-.30,.25,-.09,.03,-.13)*ff2_7+\n        vec4(.23,-1.25,-1.21,.23))/1.7+ff2_0;\n    vec4 ff3_1=sin(mat4(-.16,-.30,-.08,-.12,.11,-.18,.27,.24,-.07,.29,.12,-.13,-.01,.05,-.06,-.30)*ff2_0+\n        mat4(.11,.21,.37,-.09,-.09,.07,-.10,-.11,-.10,-.25,.22,-.02,.13,-.34,.35,.10)*ff2_1+\n        mat4(.05,-.05,.20,-.25,.19,-.48,.10,.03,.11,.23,.02,-.15,-.02,-.40,.50,-.04)*ff2_2+\n        mat4(-.45,-.08,.35,.08,-.19,-.16,.27,.08,-.43,.09,.03,.06,.06,.09,-.03,.06)*ff2_3+\n        mat4(.00,-.16,.22,.14,.08,.44,.22,.04,-.01,.45,.03,.41,-.30,.06,-.07,.16)*ff2_4+\n        mat4(-.16,.29,-.23,.07,.23,-.01,.33,.04,-.15,.16,.02,-.16,.08,-.33,.18,.14)*ff2_5+\n        mat4(.21,.21,-.27,.08,.26,-.08,.32,-.18,-.19,.29,-.23,.02,-.19,.30,.23,.43)*ff2_6+\n        mat4(-.24,.41,-.27,-.18,.11,-.24,.00,-.06,.26,.35,.01,-.16,-.09,.23,.14,.03)*ff2_7+\n        vec4(.75,.13,-1.05,2.00))/1.7+ff2_1;\n    vec4 ff3_2=sin(mat4(-.23,-.30,.01,-.13,-.21,-.06,-.12,-.04,.03,.14,-.30,-.24,.03,.31,.20,.14)*ff2_0+\n        mat4(.04,.16,.45,.22,-.49,-.12,.32,-.33,-.12,.03,.06,.05,-.11,-.65,.07,.17)*ff2_1+\n        mat4(.56,-.07,.14,.05,-.06,.33,-.06,.49,-.35,.10,-.31,.09,-.30,-.18,-.35,-.03)*ff2_2+\n        mat4(.35,.04,.13,.39,-.17,-.07,-.50,.02,.24,-.02,.21,.14,.19,.23,-.05,.05)*ff2_3+\n        mat4(-.12,-.11,-.58,-.25,-.03,-.00,-.15,.47,.01,-.24,.16,.27,-.16,-.07,-.05,.03)*ff2_4+\n        mat4(.11,.35,.12,.10,.05,-.14,.01,.23,-.02,.07,.17,.11,-.27,.05,.36,.18)*ff2_5+\n        mat4(-.25,-.60,-.32,-.05,-.23,-.07,-.19,.03,-.11,-.14,.12,-.20,-.53,-.09,-.29,.44)*ff2_6+\n        mat4(-.02,-.09,-.36,-.46,-.16,.08,-.26,-.09,.15,.18,.51,.47,-.13,-.48,.51,.09)*ff2_7+\n        vec4(1.98,.39,-.47,1.49))/1.7+ff2_2;\n    vec4 ff3_3=sin(mat4(.06,.09,.19,.31,-.21,.19,-.18,-.26,-.17,-.36,.19,-.39,-.09,-.37,-.12,.28)*ff2_0+\n        mat4(.42,.56,-.40,.60,-.05,.13,-.25,.18,.02,.17,-.14,.01,-.43,.61,-.17,.49)*ff2_1+\n        mat4(.23,-.42,.27,.46,-.33,.04,.06,-.13,-.39,-.21,.25,-.19,-.10,.00,.24,.14)*ff2_2+\n        mat4(.18,-.18,-.16,.15,-.02,.07,-.01,-.02,.13,.37,.56,.18,-.07,-.17,.35,-.21)*ff2_3+\n        mat4(-.15,.36,-.11,-.20,.37,.38,.31,-.16,-.04,-.04,-.06,.04,.23,-.34,.01,.29)*ff2_4+\n        mat4(.31,.02,.14,.27,.06,.18,-.21,.03,-.32,.46,-.16,.14,-.14,.36,-.27,.23)*ff2_5+\n        mat4(.05,-.40,.16,-.28,-.17,.08,.22,-.02,.17,-.13,-.27,.30,-.44,.66,.19,-.04)*ff2_6+\n        mat4(.25,-.11,-.25,-.55,.08,.09,-.18,-.08,.02,.00,.20,-.20,.30,.44,-.29,.46)*ff2_7+\n        vec4(.70,1.07,.01,-1.23))/1.7+ff2_3;\n    vec4 ff3_4=sin(mat4(-.17,-.15,.12,.28,-.46,.34,.31,.42,-.24,.45,.10,-.06,.16,.47,.07,-.34)*ff2_0+\n        mat4(-.35,-.09,.20,-.29,.46,-.07,-.26,-.07,-.22,-.20,-.03,-.09,-.66,.34,-.21,.01)*ff2_1+\n        mat4(-.26,-.23,.33,.03,.19,-.45,-.27,-.10,.43,-.15,-.21,.30,.28,.27,.26,.22)*ff2_2+\n        mat4(-.07,.28,.32,-.22,.23,-.39,.17,.07,-.23,-.09,-.23,-.02,-.10,-.11,.08,.22)*ff2_3+\n        mat4(-.28,-.10,.18,.26,-.27,.03,.24,-.44,-.26,.38,-.01,.02,.15,-.18,-.33,-.01)*ff2_4+\n        mat4(-.24,.16,.22,-.34,-.34,.08,-.02,-.32,-.26,.10,-.03,-.34,-.15,-.04,.05,-.29)*ff2_5+\n        mat4(.57,.31,-.10,.52,.31,.02,-.26,.46,.25,-.46,-.22,.08,-.36,.31,.18,.13)*ff2_6+\n        mat4(.10,.04,.27,-.13,.27,-.14,-.09,.30,.26,-.19,-.18,-.00,-.30,-.25,-.03,-.47)*ff2_7+\n        vec4(-.08,.24,-.37,-.53))/1.7+ff2_4;\n    vec4 ff3_5=sin(mat4(.13,.05,-.11,.11,.21,.11,-.40,-.02,.02,.31,.12,.14,.06,.25,.39,.16)*ff2_0+\n        mat4(.11,.16,-.06,.11,-.04,-.08,.05,-.13,.02,.30,-.05,-.15,-.09,-.27,-.42,-.16)*ff2_1+\n        mat4(.30,-.24,-.18,-.06,-.36,-.07,.01,-.67,-.01,.14,-.09,.03,-.18,-.13,-.22,-.08)*ff2_2+\n        mat4(-.11,-.09,.31,.36,-.23,-.16,.00,.07,.48,-.28,-.34,.04,-.23,-.13,-.18,-.15)*ff2_3+\n        mat4(-.22,-.07,-.36,-.19,-.09,.22,.02,.23,.18,.22,.16,.29,-.06,-.19,.39,-.20)*ff2_4+\n        mat4(-.05,.35,.26,.33,-.26,-.00,-.34,-.06,.13,-.24,-.25,-.27,-.07,.03,-.34,-.28)*ff2_5+\n        mat4(.15,.01,.03,.20,.31,.24,.18,-.03,.09,-.23,.31,-.05,-.13,-.22,-.28,-.07)*ff2_6+\n        mat4(-.27,.11,.16,.35,-.18,-.25,.35,-.18,.30,.17,-.12,-.23,.12,.03,-.01,.04)*ff2_7+\n        vec4(.96,-1.20,-1.14,-1.00))/1.7+ff2_5;\n    vec4 ff3_6=sin(mat4(.22,-.36,.21,-.35,-.24,.22,.17,-.28,-.06,-.15,-.20,.07,.15,-.26,-.16,.13)*ff2_0+\n        mat4(.14,-.19,.37,-.01,.25,.32,-.10,-.19,.21,.39,-.26,-.29,.16,.00,.63,.51)*ff2_1+\n        mat4(.18,-.04,.11,-.23,.04,.28,.14,.00,-.04,.03,.04,.10,.24,.51,-.07,.20)*ff2_2+\n        mat4(-.14,.08,.01,.12,-.12,-.16,-.32,-.04,.00,-.10,.17,.45,.16,.18,.07,.37)*ff2_3+\n        mat4(.18,-.32,-.01,.12,-.32,-.28,.04,.10,.01,.21,.12,-.05,.04,.17,-.30,.11)*ff2_4+\n        mat4(-.28,.08,-.39,.22,.11,-.15,-.05,.14,-.02,-.15,.08,.02,-.32,.36,.22,-.09)*ff2_5+\n        mat4(.13,.31,-.19,.27,-.10,.06,-.21,.01,.07,.11,.17,.34,.15,.09,.19,.18)*ff2_6+\n        mat4(-.02,-.23,-.07,-.01,.34,.29,.02,-.17,-.08,-.04,.11,.23,-.11,-.44,-.07,-.44)*ff2_7+\n        vec4(-1.22,1.17,-1.00,.20))/1.7+ff2_6;\n    vec4 ff3_7=sin(mat4(-.14,-.11,-.12,.12,-.14,.21,.11,-.03,.04,.39,.18,-.07,.06,-.18,.00,-.17)*ff2_0+\n        mat4(.23,.18,-.08,-.40,-.01,.39,-.26,.13,.03,.23,-.28,.06,-.07,.45,.28,.01)*ff2_1+\n        mat4(.14,.18,-.06,-.15,.07,-.22,-.24,.36,.04,-.21,-.05,.29,.09,.14,-.09,.25)*ff2_2+\n        mat4(-.13,-.39,.18,-.04,.07,-.45,-.08,.30,-.43,.30,.14,-.34,-.25,.28,.04,.04)*ff2_3+\n        mat4(.13,.26,-.03,.55,.18,.43,-.18,-.03,.34,-.16,.16,-.14,.01,-.02,-.08,-.01)*ff2_4+\n        mat4(.45,.15,-.20,-.34,.31,.09,.01,-.22,-.27,.22,.19,-.20,.37,.02,.08,-.03)*ff2_5+\n        mat4(.19,-.47,.24,.33,.01,-.20,.15,.01,.22,-.03,.22,-.15,.02,.07,.08,.14)*ff2_6+\n        mat4(-.23,.06,-.22,-.09,.16,-.05,.19,.05,-.42,-.31,-.31,-.38,.08,.05,-.16,-.15)*ff2_7+\n        vec4(-.23,1.33,-1.81,.90))/1.7+ff2_7;\n    vec4 ff4_0=sin(mat4(.01,.04,-.20,-.10,-.04,-.06,.10,.07,-.19,-.03,.17,-.26,-.40,-.14,-.21,.30)*ff3_0+\n        mat4(-.54,.00,-.02,-.07,-.13,.38,-.32,.32,-.43,-.10,-.35,.38,.24,.24,-.10,-.11)*ff3_1+\n        mat4(.14,-.19,.02,.16,.11,.13,.38,-.14,.31,-.19,.25,-.67,-.44,.04,-.03,-.47)*ff3_2+\n        mat4(-.05,.08,.01,.30,.04,.25,.39,-.37,.02,-.36,.12,.39,.56,-.05,-.10,-.20)*ff3_3+\n        mat4(.40,.14,-.11,-.60,.34,.15,.03,-.39,-.04,-.05,-.26,-.18,-.14,-.25,.16,-.22)*ff3_4+\n        mat4(.08,-.16,-.23,.31,.39,-.09,-.14,-.10,-.55,.10,.09,.39,-.04,.22,.01,.61)*ff3_5+\n        mat4(.35,.15,-.10,-.34,.22,-.09,.02,-.41,-.36,.04,.06,.35,-.13,.10,-.02,-.02)*ff3_6+\n        mat4(-.37,.14,.04,-.41,-.34,.30,.18,-.32,-.04,-.06,-.26,.46,-.70,.07,-.17,.28)*ff3_7+\n        vec4(.12,-.45,-.01,-1.54))/2.0+ff3_0;\n    vec4 ff4_1=sin(mat4(.33,-.00,.47,-.21,-.01,.01,.27,-.33,-.02,-.07,.05,-.05,-.44,-.08,-.50,-.18)*ff3_0+\n        mat4(.26,-.00,-.19,-.21,.00,-.10,.18,-.23,-.16,.15,.20,.18,-.35,-.23,.53,.09)*ff3_1+\n        mat4(-.11,.05,-.06,-.13,.11,.55,-.10,-.20,-.08,.47,.18,.37,-.04,.30,.51,-.16)*ff3_2+\n        mat4(.14,-.34,-.20,-.07,-.21,.27,.49,-.21,-.18,-.54,.06,.02,.10,.11,.13,-.16)*ff3_3+\n        mat4(.08,.34,.19,-.24,-.30,-.26,.42,-.12,-.10,-.20,-.14,-.15,-.18,-.07,-.09,.19)*ff3_4+\n        mat4(-.28,-.56,.21,.12,.11,.07,-.18,.41,-.02,-.07,.33,-.30,.03,.11,.37,.03)*ff3_5+\n        mat4(-.19,.08,-.52,-.12,.15,.41,-.02,.40,-.07,-.30,.03,.02,-.12,.13,.18,-.33)*ff3_6+\n        mat4(.24,-.10,-.21,.12,.29,.17,.38,-.08,-.21,-.07,.09,.12,.22,-.30,.18,-.01)*ff3_7+\n        vec4(-.92,-.70,-.39,-.30))/2.0+ff3_1;\n    vec4 ff4_2=sin(mat4(.34,-.02,-.18,.27,.36,-.43,.22,-.06,.62,-.21,-.14,.18,-.33,.12,-.21,.06)*ff3_0+\n        mat4(-.18,.01,.27,.20,-.50,-.10,-.15,.13,-.10,-.30,-.22,.01,.53,-.05,-.24,.13)*ff3_1+\n        mat4(.11,.31,-.18,.13,-.63,-.59,.08,-.07,.18,-.55,.01,-.09,-.43,-.21,-.24,.09)*ff3_2+\n        mat4(-.31,.41,.17,-.02,.29,-.40,.35,-.43,.11,.55,.08,-.12,.01,-.34,-.20,-.15)*ff3_3+\n        mat4(.45,-.21,-.19,-.26,.62,-.06,.08,.36,.69,-.01,-.22,-.10,-.33,.16,-.11,-.29)*ff3_4+\n        mat4(-.18,.41,.33,-.16,-.22,-.42,.26,-.44,-.21,.51,-.22,.14,-.69,.18,.18,.21)*ff3_5+\n        mat4(.00,.07,-.15,-.10,.02,-.49,-.24,-.28,.25,.29,-.24,.13,.81,-.20,.06,.40)*ff3_6+\n        mat4(.22,.27,.06,.17,.23,-.34,.08,.22,.05,.20,.23,-.06,-.21,.69,-.15,.59)*ff3_7+\n        vec4(1.56,-.72,1.94,-.17))/2.0+ff3_2;\n    vec4 ff4_3=sin(mat4(.13,.24,.07,.17,-.05,.08,.13,.23,-.12,-.18,.01,-.01,.20,.02,.29,-.08)*ff3_0+\n        mat4(-.24,-.03,.12,-.23,.55,.19,.21,.01,.24,-.43,-.04,.11,-.08,-.10,.02,.14)*ff3_1+\n        mat4(-.05,.02,.03,.09,.14,-.09,-.60,.09,-.11,-.27,-.12,.45,-.52,-.05,-.08,-.00)*ff3_2+\n        mat4(-.17,-.25,-.08,.12,-.03,.31,.23,.25,.30,.26,.23,.05,.43,.37,.18,.21)*ff3_3+\n        mat4(.03,-.18,-.14,.30,.15,-.09,.31,.32,-.38,-.07,.49,.01,-.25,-.28,-.02,-.14)*ff3_4+\n        mat4(.34,.24,.34,-.15,.15,.19,.19,.17,-.19,-.30,.22,-.39,.66,.39,.48,.11)*ff3_5+\n        mat4(-.50,-.02,-.01,-.11,-.54,-.09,.10,-.02,.07,-.04,.22,-.01,-.31,-.00,.09,.01)*ff3_6+\n        mat4(-.27,.31,.23,.09,-.21,-.38,.21,.05,-.05,.34,-.11,-.15,-.23,-.04,.42,-.01)*ff3_7+\n        vec4(.53,-1.43,-.37,-1.15))/2.0+ff3_3;\n    vec4 ff4_4=sin(mat4(.16,.29,-.21,-.25,-.03,.26,.24,-.41,.18,.04,.11,-.07,.49,-.14,.17,.47)*ff3_0+\n        mat4(.19,-.24,.23,-.01,.06,.06,.71,.05,-.09,.06,-.05,-.18,.55,.24,-.10,-.95)*ff3_1+\n        mat4(.43,.12,-.30,-.07,-.54,-.00,-.09,.37,-.66,.04,-.42,.01,-.35,-.02,.03,-.02)*ff3_2+\n        mat4(.11,.29,-.03,.24,-.68,.03,.07,-.23,.38,-.01,-.33,-.12,.13,.23,-.14,.35)*ff3_3+\n        mat4(-.74,.08,-.04,-.37,-.06,.28,.16,-.59,-.06,.37,-.36,-.11,.01,.00,-.05,.24)*ff3_4+\n        mat4(.55,-.31,.45,.08,-.29,-.14,.10,.15,.24,-.22,-.03,.03,.13,-.29,-.17,.11)*ff3_5+\n        mat4(-.48,.16,-.23,.45,-.27,-.07,-.02,.14,.47,.17,-.14,.02,-.20,.00,-.40,-.66)*ff3_6+\n        mat4(-.35,-.56,.14,.30,-.35,.02,.07,-.11,.27,.01,-.32,-.17,.69,-.21,.22,.39)*ff3_7+\n        vec4(2.07,-1.26,-1.56,-.64))/2.0+ff3_4;\n    vec4 ff4_5=sin(mat4(.47,.13,.16,.03,.27,-.16,.22,-.18,.33,.24,-.12,.44,.22,.06,.07,-.17)*ff3_0+\n        mat4(-.05,.04,.30,.10,.15,.30,-.23,-.26,-.07,.09,.27,.05,-.20,.05,.15,.12)*ff3_1+\n        mat4(-.51,-.03,-.09,.18,-.39,.27,.36,-.35,.03,-.07,-.21,-.08,.35,-.26,.09,-.23)*ff3_2+\n        mat4(.24,-.35,.03,.33,-.22,.11,-.21,-.23,-.21,-.10,.29,.31,.17,-.07,-.31,-.18)*ff3_3+\n        mat4(-.17,-.35,-.02,-.02,-.22,-.34,.21,.09,-.31,-.19,.20,.32,-.13,-.25,-.26,-.06)*ff3_4+\n        mat4(.04,.22,.14,.20,-.23,-.00,-.15,-.01,.30,-.09,.52,.09,.45,.21,.25,-.31)*ff3_5+\n        mat4(-.15,.19,-.65,-.11,-.04,.01,-.29,-.03,-.34,-.13,.28,.21,.02,.30,.36,.30)*ff3_6+\n        mat4(-.11,-.09,-.33,.53,-.15,-.34,.19,-.24,.10,.28,.10,-.03,-.25,.30,.21,.55)*ff3_7+\n        vec4(-1.41,-.90,.92,-.08))/2.0+ff3_5;\n    vec4 ff4_6=sin(mat4(.30,-.15,.38,.17,-.14,.13,-.18,-.14,.05,.02,.09,.35,-.09,.15,-.34,.19)*ff3_0+\n        mat4(-.01,.40,-.35,-.02,-.16,-.49,-.48,-.10,-.00,.34,.17,.14,.03,-.16,-.06,.04)*ff3_1+\n        mat4(-.05,.11,-.16,-.23,.13,-.16,-.20,-.23,.22,.32,.56,.50,-.01,.21,-.10,-.04)*ff3_2+\n        mat4(.23,-.15,-.22,-.00,-.29,-.01,-.06,.32,.18,-.15,-.08,.08,.00,.35,.12,.08)*ff3_3+\n        mat4(.07,.14,.09,.22,.11,.11,.45,-.16,.12,.16,-.27,-.06,-.16,.21,.02,.05)*ff3_4+\n        mat4(.04,.02,-.53,.08,-.45,.04,-.30,-.16,.19,.11,-.04,.07,.14,-.10,-.51,-.23)*ff3_5+\n        mat4(.16,.24,-.02,.04,-.25,-.28,.28,-.09,.38,-.16,-.46,-.07,.88,-.47,-.40,.10)*ff3_6+\n        mat4(-.22,.03,.12,.23,.10,.14,-.15,-.06,.10,-.28,.10,-.05,-.47,-.13,.09,.01)*ff3_7+\n        vec4(.84,-1.33,1.65,.47))/2.0+ff3_6;\n    vec4 ff4_7=sin(mat4(-.29,.06,.06,.03,-.17,.38,-.21,-.36,.19,.21,.12,-.43,.24,-.13,.15,.63)*ff3_0+\n        mat4(.46,.09,-.10,.12,-.24,.03,-.05,.14,.38,.21,-.09,.10,-.25,.30,.22,-.38)*ff3_1+\n        mat4(.23,.16,.40,.48,-.26,-.29,.13,-.12,-.34,.10,-.08,-.69,.11,.04,-.11,-.43)*ff3_2+\n        mat4(-.09,.47,.00,.19,.08,-.38,.18,-.69,.09,.30,.09,.24,-.15,.37,-.08,-.27)*ff3_3+\n        mat4(-.17,-.13,-.31,-.41,.03,.39,-.09,.22,.16,.35,.14,-.11,-.29,-.53,.17,-.16)*ff3_4+\n        mat4(-.13,-.36,.20,.31,-.41,-.35,.25,.06,.26,-.34,.05,.18,.21,-.16,.22,.12)*ff3_5+\n        mat4(.23,.01,-.51,.10,-.10,-.02,.21,-.11,.10,.29,-.27,-.16,-.34,.71,.09,-.26)*ff3_6+\n        mat4(.16,-.36,.01,-.21,-.21,.30,-.32,.11,-.11,-.01,-.23,-.14,.21,-.37,-.20,.46)*ff3_7+\n        vec4(.17,1.06,-.47,-.56))/2.0+ff3_7;\n    vec4 ff5_0=sin(mat4(-.23,-.01,-.19,-.00,.07,.33,-.13,.16,.23,.21,.10,.28,.84,.33,-.07,-.49)*ff4_0+\n        mat4(.13,-.30,.08,-.20,.16,-.05,.10,-.28,.43,.41,.21,-.23,-.25,.37,.12,-.16)*ff4_1+\n        mat4(-.08,-.33,.19,.06,.02,-.38,-.26,.20,-.34,-.39,-.34,.06,.14,.31,-.04,-.13)*ff4_2+\n        mat4(.43,-.05,.03,.17,-.03,.29,-.18,.44,.17,.06,-.14,-.15,.27,-.17,-.34,.17)*ff4_3+\n        mat4(-.25,-.09,.63,.43,.45,-.04,.04,.19,.36,.35,.02,.03,-.03,-.13,-.07,.04)*ff4_4+\n        mat4(.14,.17,.25,.09,-.08,-.01,-.04,.26,.10,-.11,.16,-.31,-.07,.10,-.15,-.16)*ff4_5+\n        mat4(-.11,.32,.15,-.23,-.08,-.05,-.07,.11,-.14,.27,-.15,-.11,.22,-.28,-.15,-.08)*ff4_6+\n        mat4(.18,-.49,-.38,.04,-.35,.24,-.24,-.38,.24,.25,.09,.29,.66,.17,-.41,-.46)*ff4_7+\n        vec4(.64,-.50,1.60,-1.73))/2.2+ff4_0;\n    vec4 ff5_1=sin(mat4(.13,-.21,.52,.28,-.26,.20,.35,.09,-.20,.11,-.36,-.22,-.35,.02,.60,-.11)*ff4_0+\n        mat4(.23,-.09,-.07,.10,.11,-.02,.30,-.48,.25,.04,.27,-.62,.05,.52,.21,-.08)*ff4_1+\n        mat4(-.22,-.24,-.20,.25,.29,.40,.14,.11,.22,.06,.10,.11,.21,-.08,.01,-.05)*ff4_2+\n        mat4(-.06,-.26,.28,-.23,-.08,-.29,.09,.18,-.12,-.06,-.02,.14,.01,.64,.06,-.06)*ff4_3+\n        mat4(.27,-.09,-.51,.48,-.13,-.14,.07,-.10,-.25,-.07,.15,.44,.05,-.22,-.28,.34)*ff4_4+\n        mat4(-.08,-.41,.39,-.03,.10,-.26,-.34,-.14,.16,.06,.06,-.26,-.01,.19,.08,-.33)*ff4_5+\n        mat4(.19,.05,.07,-.09,.14,-.41,.06,.03,-.31,.03,.20,.10,-.43,.37,-.17,.38)*ff4_6+\n        mat4(-.07,-.41,-.35,-.26,.33,.12,.63,.15,-.16,.01,-.40,.10,.10,-.11,-.14,.03)*ff4_7+\n        vec4(.33,-.29,-.38,.02))/2.2+ff4_1;\n    vec4 ff5_2=sin(mat4(-.40,-.32,.28,-.40,.35,.02,.23,-.04,-.03,.14,.31,-.27,-.33,-1.01,-.34,-.16)*ff4_0+\n        mat4(.31,-.42,.11,-.13,-.26,-.51,-.35,-.45,-.24,-.35,-.09,-.11,-.12,-.19,-.16,.26)*ff4_1+\n        mat4(.18,.40,.45,.06,.21,.24,-.09,.50,.12,-.11,.20,-.04,-.11,-.39,-.34,-.29)*ff4_2+\n        mat4(-.26,.15,-.27,.03,.46,.02,.16,-.38,-.24,-.25,-.13,-.26,.08,.29,.07,-.25)*ff4_3+\n        mat4(.26,.93,.62,.24,.05,.18,-.21,.24,-.05,-.03,.01,-.04,.46,.49,.22,.02)*ff4_4+\n        mat4(.18,-.10,-.47,.11,.14,.20,.15,.44,-.07,-.24,.30,-.12,-.14,-.30,-.19,-.33)*ff4_5+\n        mat4(-.13,-.63,-.18,-.05,-.02,.67,.10,-.09,.13,-.18,.07,-.52,-.04,.05,-.32,-.14)*ff4_6+\n        mat4(.26,.06,.04,-.37,-.37,-.16,-.25,-.18,-.05,.41,.02,.04,-.14,-.32,-.03,-.07)*ff4_7+\n        vec4(.01,.00,-1.25,.87))/2.2+ff4_2;\n    vec4 ff5_3=sin(mat4(-.38,.20,-.10,.02,-.25,.18,.32,.14,.45,-.04,.13,.33,-.26,-.23,-.36,-.64)*ff4_0+\n        mat4(1.09,-.06,.18,.23,-.22,-.34,.21,-.22,-.01,-.16,-.09,-.49,-.13,.24,-.19,-.15)*ff4_1+\n        mat4(.36,.09,.26,.46,.37,.18,.19,.38,-.16,-.26,.27,.34,-.37,.09,.30,-.35)*ff4_2+\n        mat4(.35,-.11,.21,.20,-.15,.03,-.35,.52,-.37,-.05,-.06,-.27,.21,.00,.04,.20)*ff4_3+\n        mat4(.65,.32,.07,.79,.46,.21,.28,.49,-.13,-.26,-.30,.09,.54,-.15,-.12,.61)*ff4_4+\n        mat4(.20,-.08,-.21,-.16,.04,-.23,.14,.38,.07,-.02,-.12,-.39,-.12,.14,-.24,-.46)*ff4_5+\n        mat4(-.18,.20,.37,-.27,.09,-.30,.01,.37,.18,.09,.35,-.14,.13,.31,.41,.29)*ff4_6+\n        mat4(-.22,-.14,-.34,-.14,-.76,.24,.12,-.24,.09,-.13,-.19,-.09,-.15,.05,-.31,-.78)*ff4_7+\n        vec4(.64,-1.60,1.17,-1.50))/2.2+ff4_3;\n    vec4 ff5_4=sin(mat4(.31,.59,-.26,.16,.05,-.02,-.22,.26,-.25,-.00,-.15,-.02,.21,.79,.30,.45)*ff4_0+\n        mat4(-.18,.06,-.24,.17,.33,.12,.07,-.22,-.26,.27,-.15,.03,.39,.20,-.01,-.15)*ff4_1+\n        mat4(-.35,-.40,-.25,-.61,-.03,-.48,-.21,-.31,.31,.01,.35,.02,.08,.12,.04,.55)*ff4_2+\n        mat4(-.47,.04,.44,.16,-.41,-.00,-.26,-.00,.39,.57,.09,.25,-.24,-.06,-.08,-.15)*ff4_3+\n        mat4(-.60,-.81,-.09,-.78,-.21,.02,-.17,-.05,.13,.19,.18,-.21,-.37,-.57,.07,-.22)*ff4_4+\n        mat4(.09,.52,.08,.05,.19,-.29,.01,-.39,-.09,.34,-.32,.10,.18,.14,-.24,.30)*ff4_5+\n        mat4(.22,.56,.17,.48,.15,.15,-.04,-.30,.27,.19,-.05,-.15,-.18,-.59,.50,.09)*ff4_6+\n        mat4(-.27,-.08,.53,.21,.32,.29,-.17,.29,-.18,.13,-.04,.03,.09,.46,.21,.23)*ff4_7+\n        vec4(1.63,-1.72,1.93,2.00))/2.2+ff4_4;\n    vec4 ff5_5=sin(mat4(.13,-.07,.21,-.17,.26,-.14,-.11,.09,.45,.07,-.25,.15,-.12,.12,.39,-.54)*ff4_0+\n        mat4(-.11,-.02,-.07,.23,.14,.35,.47,-.38,.06,.56,.24,-.31,-.06,-.03,.04,-.06)*ff4_1+\n        mat4(.20,-.14,-.47,.53,.28,-.08,-.16,.72,-.14,-.35,-.10,.34,.13,.14,.05,-.28)*ff4_2+\n        mat4(.17,-.06,.10,.18,.13,-.11,-.24,.57,.52,.07,.01,-.30,.13,-.38,-.24,.24)*ff4_3+\n        mat4(.12,-.26,-.40,1.04,.15,-.02,-.21,.51,.46,.19,-.21,.08,-.05,.14,-.63,1.08)*ff4_4+\n        mat4(.18,-.13,-.26,-.28,-.07,-.33,.15,-.01,.13,.04,.35,-.18,-.23,.32,.43,-.87)*ff4_5+\n        mat4(-.16,-.19,.20,-.18,.07,-.05,-.04,.37,-.06,-.19,-.02,-.12,-.02,.21,-.16,.52)*ff4_6+\n        mat4(-.40,.16,.00,.07,.33,-.08,-.03,-.46,.05,-.19,.31,-.14,-.03,.29,.45,-.63)*ff4_7+\n        vec4(.60,.40,-.34,1.19))/2.2+ff4_5;\n    vec4 ff5_6=sin(mat4(.01,-.12,-.34,-.17,.13,.02,-.39,-.40,.26,-.03,.31,.01,.51,.36,.10,.55)*ff4_0+\n        mat4(.15,-.04,.14,.43,-.04,.25,.12,.09,-.30,-.10,-.39,-.32,-.26,-.01,-.37,-.10)*ff4_1+\n        mat4(-.14,-.77,.63,.07,-.10,.30,.23,.14,.09,.60,.04,-.09,.36,-.03,.15,-.24)*ff4_2+\n        mat4(-.25,.06,-.17,.52,.03,-.23,.47,.05,.18,-.09,-.32,-.09,-.04,.05,-.23,-.12)*ff4_3+\n        mat4(-.08,.54,.57,.33,-.21,.59,.23,.38,-.26,-.76,-.47,-.25,-.41,-.06,.18,.16)*ff4_4+\n        mat4(-.10,.25,-.31,.18,.00,-.05,-.22,.45,.32,.08,.07,.70,-.17,.78,-.11,-.37)*ff4_5+\n        mat4(-.24,.18,-.17,-.36,-.02,.28,.22,.46,.13,-.43,-.39,-.33,-.03,-.28,.14,.10)*ff4_6+\n        mat4(-.02,.14,.01,-.09,.19,-.12,-.32,-.09,-.50,-.10,.02,-.23,.26,.58,.42,.40)*ff4_7+\n        vec4(-1.28,1.50,1.33,-1.03))/2.2+ff4_6;\n    vec4 ff5_7=sin(mat4(.43,.36,.17,-.20,-.34,.30,-.05,.16,-.04,-.08,-.06,.00,.54,.05,-.14,-.79)*ff4_0+\n        mat4(-.15,-.02,-.16,-.19,.09,.61,-.44,-.45,-.22,.08,-.16,-.33,.03,.19,-.36,-.07)*ff4_1+\n        mat4(-.42,-.17,.08,.58,-.26,-.23,.36,.56,-.02,-.13,-.20,.25,.14,.28,.08,-.22)*ff4_2+\n        mat4(.05,-.25,.18,.05,-.03,-.16,.50,.27,.28,-.11,-.15,-.41,.04,.09,.18,.25)*ff4_3+\n        mat4(-.32,.15,.01,1.00,-.22,-.08,-.02,.33,.24,-.13,.35,.02,-.12,-.21,.17,.57)*ff4_4+\n        mat4(-.08,.36,-.04,-.40,-.10,-.46,-.20,.18,.05,-.18,.18,-.01,.17,.32,.05,-.20)*ff4_5+\n        mat4(.28,.13,-.20,-.15,.19,.18,.21,.20,.29,.11,.23,-.27,-.02,-.13,.12,-.05)*ff4_6+\n        mat4(.24,-.45,.01,.17,-.18,.18,.20,-.46,.03,.06,-.22,-.01,.36,-.20,-.25,-.48)*ff4_7+\n        vec4(-.87,.99,-1.68,.86))/2.2+ff4_7;\n    vec4 ff6_0=sin(mat4(-.11,-.16,-.08,-.14,-.43,-.26,.18,-.22,.12,.32,.20,.16,.39,-.41,-.76,.48)*ff5_0+\n        mat4(.42,-.07,-.04,.35,-.42,-.28,-.34,-.13,-.11,-.48,-.10,.25,-.14,.18,.21,-.01)*ff5_1+\n        mat4(-.05,.02,.59,-.21,-.09,.07,.39,-.40,-.37,.35,.38,-.35,-.20,-.20,-.29,.17)*ff5_2+\n        mat4(.56,-.35,.32,.26,-.29,.04,.10,-.12,-.29,-.05,-.13,.20,.15,.02,.29,-.54)*ff5_3+\n        mat4(.06,.24,.65,-.25,.08,.00,.36,-.30,-.19,-.42,.50,-.09,-.11,-.03,.49,-.24)*ff5_4+\n        mat4(.16,.07,.29,.36,.20,.07,.31,.36,-.08,-.01,-.41,.40,-.15,-.18,-.89,.54)*ff5_5+\n        mat4(-.10,.16,.05,-.21,.33,.13,-.12,.21,-.48,-.30,-.14,.04,.04,.12,-.02,.37)*ff5_6+\n        mat4(.36,-.69,-.26,.22,-.40,-.08,-.05,.01,.32,-.11,-.10,.05,.34,-.39,-.30,.83)*ff5_7+\n        vec4(2.05,1.37,.22,-.66))/2.4+ff5_0;\n    vec4 ff6_1=sin(mat4(.02,-.27,-.37,.17,-.10,-.11,-.21,-.10,-.30,-.10,.08,-.34,.81,-.07,.02,.71)*ff5_0+\n        mat4(-.06,.02,-.05,.03,.50,-.19,.14,.04,.11,.06,-.31,.08,-.25,.34,-.09,.08)*ff5_1+\n        mat4(-.65,.61,.06,-.65,-.53,.40,-.07,-.20,-.39,-.05,.48,-.45,.04,-.32,.07,-.09)*ff5_2+\n        mat4(-.58,.47,.03,-.35,.07,-.20,.12,-.19,.00,.15,-.17,.15,-.17,.13,.06,-.12)*ff5_3+\n        mat4(-.70,.59,.04,-.72,-.45,.40,-.04,-.45,-.35,.10,-.04,-.27,-.50,.13,.13,-.23)*ff5_4+\n        mat4(.28,.05,.11,.17,.08,-.17,-.23,-.17,.43,-.27,-.31,.47,.73,-.64,-.34,.86)*ff5_5+\n        mat4(.12,-.21,-.19,.37,-.58,-.26,-.11,-.43,.61,-.16,.17,.03,-.34,-.09,-.28,-.45)*ff5_6+\n        mat4(.11,-.13,-.14,-.15,.28,.00,-.00,.28,-.26,.05,-.28,-.00,.68,-.42,-.24,.89)*ff5_7+\n        vec4(-.26,1.81,.08,-.78))/2.4+ff5_1;\n    vec4 ff6_2=sin(mat4(.01,-.03,-.23,.16,.31,-.16,-.36,.17,-.26,.09,.19,-.46,.17,-.23,.35,.24)*ff5_0+\n        mat4(.10,-.19,-.32,.39,.45,.08,.24,-.06,.06,-.40,.22,.24,-.19,-.07,.13,-.25)*ff5_1+\n        mat4(-.36,.11,-.24,-.20,.02,-.26,-.62,.13,-.29,.38,.03,-.25,-.04,-.30,.39,.18)*ff5_2+\n        mat4(-.19,.09,.16,-.39,-.13,.01,.01,.03,.02,.18,.24,.03,-.25,.14,-.02,-.21)*ff5_3+\n        mat4(-.37,.10,-.18,-.30,-.20,.09,-.27,-.56,-.16,-.21,.01,.00,-.29,.25,-.29,-.50)*ff5_4+\n        mat4(.16,.03,.20,-.03,.18,.08,.06,-.10,-.01,-.47,.15,.27,.46,-.45,.14,.30)*ff5_5+\n        mat4(.28,-.20,-.06,-.04,-.34,-.03,.26,-.22,.06,-.22,.05,.02,.12,.12,.17,-.29)*ff5_6+\n        mat4(.26,-.15,.46,.04,-.09,.05,.00,.09,-.46,.19,-.11,-.13,.27,-.28,.79,.82)*ff5_7+\n        vec4(1.81,-.15,-.93,-.04))/2.4+ff5_2;\n    vec4 ff6_3=sin(mat4(-.31,.32,.30,-.70,.09,.06,.21,.05,-.16,-.44,-.34,.15,-.49,.12,.71,-.72)*ff5_0+\n        mat4(.18,.19,-.20,-.01,-.05,.30,.14,-.40,-.17,.37,.48,-.07,.10,.02,-.32,-.11)*ff5_1+\n        mat4(.23,-.28,-.54,.65,.34,-.27,-.95,.43,-.19,.19,-.11,-.35,-.02,-.13,.45,-.19)*ff5_2+\n        mat4(.41,-.14,-.46,.40,.33,.10,-.19,-.07,-.41,-.03,.50,.08,.12,-.54,-.78,.64)*ff5_3+\n        mat4(.40,-.93,-1.05,.62,.03,-.44,-.72,.20,.16,.11,-.22,.52,.16,-.21,-.82,.43)*ff5_4+\n        mat4(-.29,.17,.07,-.15,.17,-.02,-.23,-.00,.02,.31,.48,-.09,-.47,.53,1.34,-.69)*ff5_5+\n        mat4(-.24,.03,.53,-.24,.04,-.13,-.08,.21,-.27,.08,.51,-.63,-.15,.18,-.28,.09)*ff5_6+\n        mat4(-.15,.21,.17,-.31,.15,.21,.27,-.31,.16,.12,-.34,.24,-.39,.67,1.19,-.87)*ff5_7+\n        vec4(1.19,.75,-.43,1.05))/2.4+ff5_3;\n    vec4 ff6_4=sin(mat4(-.31,-.44,-.37,-.03,.04,-.15,.09,-.23,-.18,.44,.58,.53,-.80,.37,-.90,-.66)*ff5_0+\n        mat4(-.15,.11,-.02,.09,-.16,.07,-.43,-.23,-.09,-.02,-.49,-.36,.27,-.02,.20,.40)*ff5_1+\n        mat4(.50,.01,.74,.25,.31,.02,1.05,-.21,.38,-.20,.29,.02,-.53,-.17,-.30,.12)*ff5_2+\n        mat4(.46,-.10,.45,-.08,.47,-.04,.29,.21,-.41,-.03,-.64,.03,.49,.18,.73,.10)*ff5_3+\n        mat4(.52,-.15,1.24,.33,.44,.27,.91,.21,.18,-.22,.53,.19,.48,-.03,.97,-.03)*ff5_4+\n        mat4(-.05,-.25,-.09,.26,.07,-.17,.09,.05,-.55,.02,-.67,-.42,-.95,-.54,-1.53,-.44)*ff5_5+\n        mat4(-.03,.02,-.48,-.23,-.06,.04,.25,.08,-.50,-.21,-.66,-.34,.04,.32,.52,.37)*ff5_6+\n        mat4(.00,-.29,-.19,.34,-.10,.16,-.31,.09,-.03,.06,.19,-.03,-.62,-.08,-1.31,-.83)*ff5_7+\n        vec4(.22,1.33,1.39,-1.35))/2.4+ff5_4;\n    vec4 ff6_5=sin(mat4(-.22,-.06,-.19,-.06,-.55,-.47,.16,.01,-.25,-.01,.41,-.40,.15,-.07,-.91,.01)*ff5_0+\n        mat4(.25,.29,-.28,.19,.02,-.57,.14,.18,-.04,.43,.27,.37,.15,-.09,.18,.01)*ff5_1+\n        mat4(.25,.62,.02,-.22,-.33,-.30,.48,-.21,-.20,-.21,.37,-.19,-.16,.14,.14,-.02)*ff5_2+\n        mat4(.30,.55,-.16,-.77,.07,-.04,-.16,-.15,.32,.23,-.53,.02,-.06,-.52,.34,-.37)*ff5_3+\n        mat4(-.35,.38,.71,-.52,.10,.28,.43,-.39,.28,.28,.06,.03,-.17,-.01,.01,-.38)*ff5_4+\n        mat4(.12,-.03,-.36,.17,.18,-.05,-.16,.21,-.17,.21,-.32,.20,.12,.31,-.19,.49)*ff5_5+\n        mat4(-.37,-.05,.09,.12,.10,.01,.07,-.20,.01,-.32,-.31,.04,-.20,-.05,-.02,-.38)*ff5_6+\n        mat4(.32,.09,-.17,.19,-.30,-.15,.28,.12,.33,-.15,-.20,-.13,.64,.25,-.83,.57)*ff5_7+\n        vec4(-.45,.30,1.30,.01))/2.4+ff5_5;\n    vec4 ff6_6=sin(mat4(.50,.07,.04,-.31,.42,.26,-.07,.11,-.19,.36,-.44,.15,.18,-.52,.46,-.34)*ff5_0+\n        mat4(-.10,-.12,.31,.09,.17,.29,-.04,.03,-.07,-.62,-.13,-.34,-.14,.34,-.30,-.00)*ff5_1+\n        mat4(-.11,-.24,-.30,.21,-.28,-.03,.01,.59,.00,.18,-.45,.17,.16,-.47,.26,-.34)*ff5_2+\n        mat4(-.57,-.31,-.20,.63,.09,.02,.27,.17,.04,-.06,.31,.06,-.21,.41,-.59,.23)*ff5_3+\n        mat4(-.16,-.43,-.18,.67,-.49,.08,-.33,.15,.17,-.22,-.25,-.28,.06,-.06,-.15,.41)*ff5_4+\n        mat4(-.04,-.03,.09,.16,-.09,.27,-.24,.19,.04,-.13,.30,-.14,.50,-.66,.43,-.68)*ff5_5+\n        mat4(.30,-.02,.10,-.59,-.00,.42,.11,-.17,.20,-.10,.37,-.01,-.42,.19,-.09,.29)*ff5_6+\n        mat4(.40,-.49,.06,.27,.30,-.02,.25,-.06,-.13,.24,.19,-.07,.53,-.38,.20,-.65)*ff5_7+\n        vec4(.16,-.30,1.82,.75))/2.4+ff5_6;\n    vec4 ff6_7=sin(mat4(-.16,.40,-.33,.55,-.16,.32,-.04,-.09,-.09,.06,.01,.01,-.15,.12,-.05,.34)*ff5_0+\n        mat4(-.01,.45,-.28,.04,-.16,.15,.16,.12,-.28,-.10,.19,.33,-.12,-.41,.14,-.09)*ff5_1+\n        mat4(.15,.11,.43,-.11,.25,.50,.52,-.30,.38,-.17,-.17,-.13,-.15,-.53,-.12,.29)*ff5_2+\n        mat4(.38,.35,.12,.10,.11,-.06,-.06,-.28,.22,.42,.16,.21,.02,.17,.54,.37)*ff5_3+\n        mat4(.17,.01,-.06,-.03,.06,-.19,.38,-.18,-.14,.22,-.03,.06,-.14,.22,.06,-.36)*ff5_4+\n        mat4(.28,-.09,-.00,.01,-.06,-.04,-.12,.03,.21,.34,-.21,.37,-.33,.10,-.35,.54)*ff5_5+\n        mat4(-.13,-.38,-.09,.44,-.16,.03,-.47,-.09,-.14,.03,.25,.38,.40,-.15,.27,-.15)*ff5_6+\n        mat4(-.10,-.18,-.06,.14,-.24,-.08,-.01,.13,-.10,.29,.35,.30,-.31,.09,-.21,.69)*ff5_7+\n        vec4(1.51,.86,-.69,.35))/2.4+ff5_7;\n    float return_val2 = dot(ff6_0,vec4(-.04,-.02,.05,-.06))+\n        dot(ff6_1,vec4(.05,.02,.00,.04))+\n        dot(ff6_2,vec4(.02,.01,-.03,-.02))+\n        dot(ff6_3,vec4(.02,-.02,-.03,.03))+\n        dot(ff6_4,vec4(.03,.03,-.03,.02))+\n        dot(ff6_5,vec4(-.03,-.03,-.04,-.03))+\n        dot(ff6_6,vec4(-.03,.01,-.04,.03))+\n        dot(ff6_7,vec4(-.04,-.03,-.02,-.04))+\n        -0.058* -sin(iTime);\n        \n        return (return_val1 + return_val2 ) / 2.0;\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 cam = normalize(vec3(1.5,uv));\n    vec3 init = vec3(-3.,0,0);\n    \n    float yrot = 0.;\n    float zrot = iTime*.2;\n    zrot = 3.14;\n    if (iMouse.z > 0.) {\n        yrot += -4.*mouse.y;\n        zrot = 4.*mouse.x;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n    \n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 150 && !hit; i++) {\n        float dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p+=dist*cam;\n        if (distance(p,init)>5.) break;\n    }\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    // don't ask how I stumbled on this texture\n    vec3 nz = p;\n    float spec = length(sin(r*3.5+sin(n)*.15)*.4+.6)/sqrt(3.);\n    spec *= smoothstep(-.3,.2,scene(p+r*.2));\n    vec3 basecol = vec3(abs(n));\n    vec3 col = vec3(basecol)*spec + pow(spec,8.);\n    float bgdot = length(sin(cam*8.)*.4+.6)/2.;\n    vec3 bg = vec3(.1,.1,.11) * bgdot + pow(bgdot, 10.);\n    fragColor.xyz = hit ? col : bg;\n    fragColor = smoothstep(-.02,1.05,sqrt(fragColor)) * (1.- dot(uv,uv)*.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcfz7.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[194, 435, 473, 473, 535], [537, 537, 558, 644, 80362], [80364, 80364, 80383, 80383, 80499], [80501, 80501, 80558, 80558, 81822]], "test": "valid"}
{"id": "tldBzl", "name": "[RGR] Water Surface", "author": "deeplo", "description": "water surface usig voronoi", "tags": ["water"], "likes": 2, "viewed": 196, "published": "Public API", "date": "1613311013", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S smoothstep\n#define BG_COLOR vec3(0.05,0.35,0.75)\n#define T (iTime)\n#define NB_POINTS 100.0\n\nmat2 Rot(float angle){\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c,-s,s,c);\n}\n\nvec2 Hash22(vec2 p){\n    vec3 a = fract(p.xyx * vec3(129.23,348.45,677.78));\n    a += dot(a,a+-87.65);\n    return fract(vec2(a.x*a.y,a.y*a.z));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Get coords normallized according to Y resolution. Screen displays uv between -1/+1  \n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    // Background color\n    vec3 bg = BG_COLOR;\n    vec4 col = vec4(bg,0);\n\n    // Time flow\n    float time = iTime/2.0;\n    \n    // Scale viewport\n    uv *= 3.0;  \n    \n    // Apply sine wave\n    uv.y += sin((125.45+time)*.2)+sin(0.5*(uv.x+time)) ;\n\n    // Prepare voronoi loop (using 3x3 grid)\n    vec2 id  = floor(uv);\n    vec2 gv  = fract(uv) - 0.5;\n    float minDist = 1000.0;\n\n    // Grid loop\n    for(float dx=-1.0;dx<=1.0 ;dx+=1.0){\n        for(float dy=-1.0;dy<=1.0 ;dy+=1.0){\n            vec2 offset = vec2(dx,dy);\n            vec2 h = Hash22(id+offset);\n            vec2 p = offset+sin(h*(time+125.87))*0.5;\n            p -= gv;\n            float d = length(p);\n            if (d< minDist){\n                minDist = min(minDist,d);\n            }\n        }\n    }\n    \n    // Voronoi color\n    \n    float a = sin(iTime*0.05235);\n    a = abs(a)*0.5;              // 0 / +0.5\n    a *= 0.1;\n    \n    float b = sin(iTime*0.1235);\n    b = abs(b)*0.5+0.5;          // +0.5 / +1\n    b *= 3.0;\n    \n    float c = S(a,b,minDist*minDist);\n    col.rgb += vec3(c);\n\n\n    // Output\n    fragColor = col;    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldBzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 102, 124, 124, 205], [207, 207, 227, 227, 352], [355, 355, 412, 504, 1671]], "test": "valid"}
{"id": "tldBzS", "name": "Fractal Ball", "author": "oneshade", "description": "Fractal.", "tags": ["fractal", "ball", "kifs"], "likes": 4, "viewed": 83, "published": "Public", "date": "1612991061", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float mapScene(in vec3 p) {\n    float c = cos(1.875), s = sin(1.875);\n    float d = 1000000.0;\n    float size = 1.0;\n    for (int i=0; i < 10; i++) {\n        d = min(d, max(abs(p.x), max(abs(p.y), abs(p.z))) - size);\n        float c1 = cos(s), s1 = sin(s);\n        float c2 = cos(c), s2 = sin(c);\n        p.xz *= mat2(c1, -s1, s1, c1);\n        p.yz *= mat2(c2, -s2, s2, c2);\n        p = abs(p) - 0.3;\n        size *= 0.75;\n    }\n\n    return d - 0.1;\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy) - mapScene(p - e.xyy),\n                          mapScene(p + e.yxy) - mapScene(p - e.yxy),\n                          mapScene(p + e.yyx) - mapScene(p - e.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenCenter = 0.5 * iResolution.xy;\n\n    vec2 mouse = vec2(iTime);//(iMouse.xy - screenCenter) / iResolution.y * 6.28;\n    vec2 uv = (fragCoord.xy - screenCenter) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 10.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    float t = 0.0;\n    for (float iters=0.0; iters < 150.0; iters++) {\n        vec3 p = ro + rd * t;\n\n        p.yz *= mat2(cp, -sp, sp, cp);\n        p.xz *= mat2(cy, -sy, sy, cy);\n\n        float d = mapScene(p / 1.5) * 1.5;\n        if (d < 0.001) {\n            vec3 n = getNormal(p / 1.5) * 1.2;\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n\n            n.xz *= mat2(cy, sy, -sy, cy);\n            n.yz *= mat2(cp, sp, -sp, cp);\n\n            fragColor.rgb += max(0.2, dot(n, l));\n            break;\n        }\n\n        if (t > 50.0) {\n            break;\n        }\n\n        t += d;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldBzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 451], [453, 453, 480, 480, 727], [729, 729, 784, 784, 1780]], "test": "valid"}
{"id": "tldfRB", "name": "molvania hearts", "author": "psenough", "description": "tunnel of love in the land untouched by modern dentistry", "tags": ["heart"], "likes": 4, "viewed": 94, "published": "Public", "date": "1613312925", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float distCustom(float x, float y)\n{\n    float n = -0.45 * abs(x) + y;\n    return log(\n        x * x + 1.8 * n * n\n    );\n}\n\nfloat fn(float x, float multi, float offset)\n{\n    return max(0.0, min(1.0, (sin(x * 3.14159265) + offset) * multi));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float PI = 3.14159265;\n    const float PI_3 = PI / 3.;\n    const float density = 1.5;\n    const float period = 2.;\n    float shift = sin(iTime)*0.15 + 0.15;\n    vec3 color1 = vec3(1.0, shift, shift);\n    vec3 color2 = vec3(1.0, 1.0, shift);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    float scale = min(iResolution.x, iResolution.y);\n    vec2 uv = fragCoord / scale;\n\tuv -= vec2(iResolution.x / scale, iResolution.y / scale) / 2.;\n    uv *= 2.0;\n    \n    float dist = log(uv.x*uv.x+uv.y*uv.y) / 2.;\n    float distH = distCustom(uv.x, uv.y);\n    float angle = atan(uv.y, uv.x);\n    \n    float timeH = -iTime*0.5;\n\n    vec2 muv = vec2( cos(0.5-uv.x + sin(uv.x*uv.y + iTime)),\n                     sin(0.5+uv.y) + cos(0.5+uv.y) + 0.15*sin(sin(uv.x*20.0)*0.2));\n    vec3 col2 = floor(mod(muv.xxx + (sin(iTime*0.1)-muv.yxx)*0.8-iTime*0.25,0.15)*50.0);\n\n\n    // Time varying pixel color\n    float c1 = fn((distH + timeH) * density + 0.1, 1.1, -0.3) * col2.y;\n    float c2 = fn((distH + timeH) * density + 1.1, 1.5, -0.3) * col2.x;\n    //float c3 = fn(dist * 4.0 + angle / PI + iTime * speed + PI, 3.0, -0.8);\n    \n    \n    // Output to screen\n    fragColor = vec4(\n\t\tc1 * color1 + c2 * color2,\n        1.\n    );\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldfRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 123], [125, 125, 171, 171, 244], [246, 246, 303, 303, 1541]], "test": "valid"}
{"id": "tldfRl", "name": "Hemisphere Repetition", "author": "kithy", "description": "Hemisphere Repetition used Polarmod", "tags": ["raymarching", "hemisphere", "polarmod"], "likes": 1, "viewed": 46, "published": "Public", "date": "1613308665", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 64\n#define EPS vec2(1e-5,0.0)\n#define PI 3.1415926\n\n\nvec3 rotate(vec3 p,float angle,vec3 axis){\n\tvec3 a=normalize(axis);\n\tfloat s=sin(angle);\n\tfloat c=cos(angle);\n\tfloat r=1.0-c;\n\tmat3 m=mat3(\n\t\ta.x*a.x*r+c,\n\t\ta.y*a.x*r+a.z*s,\n\t\ta.z*a.x*r-a.y*s,\n\t\ta.x*a.y*r-a.z*s,\n\t\ta.y*a.y*r+c,\n\t\ta.z*a.y*r+a.x*s,\n\t\ta.x*a.z*r+a.y*s,\n\t\ta.y*a.z*r-a.x*s,\n\t\ta.z*a.z*r+c\n\t\t);\n\treturn m*p;\n}\n\nvec2 pmod(vec2 p,float n){\n\tfloat np=3.141592*2.0/n;\n\tfloat r=atan(p.x,p.y)-0.5*np;\n\tr=mod(r,np)-0.5*np;\n\treturn length(p)*vec2(cos(r),sin(r));\n}\n\nfloat sphere(vec3 p,float r){\n\treturn length(p)-r;\n}\n\nfloat plane(vec3 p){\n\treturn dot(p,vec3(0.2,3.0,0.0)+0.5);\n}\n\nfloat distFunc(vec3 p){\n\tvec3 q=rotate(p,radians(PI)*iTime*10.0,vec3(0.0,0.0,1.0));\n\t\n\tq.xy=pmod(q.xy,6.0);\n\t\n\n\tfloat s1=sphere(q+vec3(0.0,0.0,0.0),max(1.0,sin(iTime)*2.0));\n\tfloat s2=sphere(q-vec3(0.0,0.0,0.0),max(1.0,sin(iTime)*1.9));\n\tfloat p1=plane(q);\n\treturn max(max(s1,-s2),p1);\n}\n\nvec3 sceneNormal(vec3 p){\n\tfloat d=distFunc(p);\n\treturn normalize(vec3(distFunc(p+EPS.xyy)-d,distFunc(p+EPS.yxy)-d,distFunc(p+EPS.yyx)-d));\n}\n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n\tvec2 p=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\n\tvec3 ro=vec3(0.0,0.0,2.0);\n\tvec3 rd=normalize(vec3(p,-1.0));\n\tfloat d,t=0.0;\n\tvec3 n,rp;\n\n\tfor(int i=0;i<MAX_STEPS;i++){\n\t\trp=ro+rd*t;\n\t\td=distFunc(rp);\n\t\tif(abs(d)<1e-5)break;\n\t\tt+=d;\n\t\t}\n\t\t\n\t\tn=sceneNormal(rp);\t\n\t\n\tfragColor=vec4(n,1.0);\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldfRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 113, 113, 388], [390, 390, 416, 416, 535], [537, 537, 566, 566, 589], [591, 591, 611, 611, 651], [653, 653, 676, 676, 940], [942, 942, 967, 967, 1083], [1086, 1086, 1139, 1139, 1442]], "test": "valid"}
{"id": "tldfWj", "name": "Distance to Triangle Wave - 3D", "author": "oneshade", "description": "Exact distance to a 3D triangle wave.", "tags": ["3d", "raymarching", "sdf", "distance", "periodic", "trianglewave", "exact"], "likes": 8, "viewed": 97, "published": "Public", "date": "1613523784", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// f: frequency\n// a: amplitude\n// d: depth\n// t: thickness\nfloat sdTriangleWave(in vec3 p, in float f, in float a, in float d, in float t) {\n    float pw = 1.0 / f, qw = 0.25 * pw;\n    vec2 sc = vec2(2.0 * a, pw);\n    float l = length(sc);\n    p.x = abs(mod(p.x + qw, pw) - 0.5 * pw) - qw;\n    p.xy *= mat2(sc, -sc.y, sc.x) / l;\n    return length(vec3(p.x, max(abs(p.yz) - vec2(0.25 * l, d), 0.0))) - t;\n}\n\nfloat mapScene(in vec3 p) {\n    float frac = fract(iTime * 0.5);\n    float freq = frac * (1.0 - frac) * 4.0 + 0.1;\n    float amp = 2.1 + 2.0 * cos(iTime);\n    float depth = 0.5 + 0.5 * sin(iTime);\n    float thickness = 0.251 + 0.25 * sin(iTime * 0.5);\n    return sdTriangleWave(p, freq, amp, depth, thickness);\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy) - mapScene(p - e.xyy),\n                          mapScene(p + e.yxy) - mapScene(p - e.yxy),\n                          mapScene(p + e.yyx) - mapScene(p - e.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenCenter = 0.5 * iResolution.xy;\n\n    vec2 mouse = (iMouse.xy - screenCenter) / iResolution.y * 3.14;\n    vec2 uv = (fragCoord - screenCenter) / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    fragColor = vec4(vec2(0.5 + 0.5 * rd.y), 1.0, 1.0);\n    float t = 0.0;\n    for (int i=0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        float d = mapScene(p);\n        if (d < 0.001) {\n            vec3 n = getNormal(p);\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n            fragColor.rgb = (0.5 + 0.5 * n) * max(0.1, dot(n, l));\n            break;\n        }\n\n        if (t > 100.0) {\n            break;\n        }\n\n        t += d;\n    }\n\n    fragColor.rgb = pow(fragColor.rgb, vec3(0.4545));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldfWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 60, 141, 141, 406], [408, 408, 435, 435, 720], [722, 722, 749, 749, 996], [998, 998, 1053, 1053, 2053]], "test": "valid"}
{"id": "tldfz7", "name": "Spiral and lines", "author": "DukeOfStraylight", "description": "Rough reproduction of https://i.imgur.com/RDMFHkf.mp4", "tags": ["spiral"], "likes": 1, "viewed": 95, "published": "Public", "date": "1612465709", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// this setting does affect performance but 100 doesn't seem too bad\nconst float DOTS = 100.;\n\nmat2 rotate(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, -s, s, c);\n}\n\nvec2 shellCircle(float shell) {\n    float t = iTime * shell;\n    return vec2(1.0, 0.) * rotate(iTime*shell*0.05) * (shell + 0.5);\n}\n\nfloat shellCircleDistance(float shell, vec2 uv) {\n    vec2 origin = shellCircle(shell);\n    return length(origin - uv);\n}\n\n// iq's line segment SDF from\n// https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.);\n\n    uv *= (DOTS * 2.);\n    float phi = atan(uv.y, uv.x);\n    float dist = length(uv);\n    float shell = floor(dist);\n    if (shell > DOTS) {\n        fragColor = vec4(0.);\n        return;\n    }\n    // the circles overlap, so let's draw a bit of the previous or next shell's circle as\n    // needed\n    col.rgb += smoothstep(0.9, 0.7, shellCircleDistance(shell, uv));\n    float edge = step(0.5, fract(dist)) * 2. - 1.; // -1 or 1\n    // meh, very first circle wants to be so special\n    if (shell + edge >= 0.) {\n        col.rgb += smoothstep(0.9, 0.7, shellCircleDistance(shell + edge, uv));\n    }\n\n    // for line-drawing, we can only ever see lines on our own shell or ones further out,\n    // never ones from further in\n    for (float i = shell; i <= DOTS; i += 1.) {\n        vec2 that = shellCircle(i);\n        vec2 other = shellCircle(i + edge);\n        // meh, again edge cases\n        if (i == DOTS && edge == 1.) {\n            break;\n        }\n        col.r += 0.2 * smoothstep(0.4, 0.1, sdSegment(uv, that, other));\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldfz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 95, 121, 121, 205], [207, 207, 238, 238, 338], [340, 340, 389, 389, 461], [463, 572, 624, 624, 743], [745, 745, 802, 802, 1957]], "test": "valid"}
{"id": "tldfzn", "name": "Something 225", "author": "gaz", "description": "inspired : https://www.shadertoy.com/view/MtScWW", "tags": ["3d"], "likes": 13, "viewed": 101, "published": "Public", "date": "1612139706", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(t) (cos((vec3(0,2,-2)/3.+t)*6.24)*.5+.5)\nvoid mainImage( out vec4 O, vec2 C)\n{\n    for(float g,d,e,i=0.;\n        ++i<99.;\n        g+=e*.5\n        )\n    {\n        vec3 r=iResolution,\n        p=R(vec3(g*(C-.5*r.xy)/r.y,g+iTime*1.),\n            vec3(.577),\n            iTime*.02\n            );\n        p.xz=mod(p.xz,6.)-3.;\n        e=max(\n            .02,\n            abs(length(p.xz)-2.)+\n            (\n                (abs(\n                    dot(\n                        vec2(atan(p.x,p.z)/3.14,mod(p.y+iTime,4.)-2.),\n                        vec2(.7)\n                    )\n                )>.7\n            )?.2:0.));\n        O.xyz+=mix(vec3(1),H(g*.1),.8)*exp(-e*9.)*.03;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldfzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 110, 147, 147, 749]], "test": "valid"}
{"id": "tlGBRW", "name": "weird pixelated spiral", "author": "morphix", "description": "pixelated spiral", "tags": ["pixelatedspiral"], "likes": 3, "viewed": 103, "published": "Public", "date": "1613947700", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 uv;\nvec3 rainbow1(float h )\n{\n\th = fract(h);\n\treturn vec3(smoothstep(0.9, 1.0, h) + smoothstep(0.5, 0.4, h), \n\t\t    smoothstep(0.3, 0.2, h) * smoothstep(0.6, 0.5, h),\n\t\t    smoothstep(0.1, 0.2, h) * smoothstep(7.0, 0.8, h));\n}\n\nfloat pxl=200000.;\n\nvec2 cln(vec2 v){\t\n\treturn vec2(log(length(uv) - 0.001), atan(uv.y, uv.x)) / 6.283 +pxl;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(mod(iTime,4.)>2.)pxl=0.;\n    uv =  (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\tuv = cln(uv);\n\n\tvec3 bg_color = mix(\n\t\trainbow1(uv.x*7.0+(uv.y-0.25*iTime*4.)),\n\t\tvec3(0),\n\t\t.6);\n\t\t\n\tvec3 fg_color = mix(\n\t\trainbow1(uv.x+(uv.y*3.0)),\n\t\tvec3(0),\n\t\t0.1);\n\t\n\tfragColor = vec4(fg_color-bg_color * 1.5, 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlGBRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[9, 9, 34, 34, 231], [253, 253, 270, 270, 343], [345, 345, 402, 402, 715]], "test": "valid"}
{"id": "tlGBWW", "name": "Colorful Illusion", "author": "lmno", "description": "i might make a microphone version (if i learn how to)", "tags": ["bubbles", "weird", "cooleffect"], "likes": 1, "viewed": 49, "published": "Public", "date": "1614313963", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// http://www.pouet.net/prod.php?which=57245\n// credits to: Danilo Guanabara\n\n#define t iTime\n#define r iResolution.xy\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec3 c;\n\tfloat l,z=t;\n\tfor(int i=-12;i<5;i++) {\n\t\tvec2 uv,p=fragCoord.xy/r;\n\t\tuv=p;\n\t\tp-=.15;\n\t\tp.x*=r.x/r.y;\n\t\tz+=.09;\n\t\tl=length(p);\n\t\tuv+=p/l*(sin(z)+10.)*abs(sin(l*10.-z*5.));\n\t\tc[i]= .100/length(abs(mod(uv,1.)-.100));\n\t}\n\tfragColor=vec4(c/l,t);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlGBWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 120, 176, 176, 429]], "test": "valid"}
{"id": "tlGfDD", "name": "Tower of the Ocean dreams", "author": "Nashoute", "description": "On the ocean waves", "tags": ["ati"], "likes": 2, "viewed": 57, "published": "Public", "date": "1614332479", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//thank you Iq https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n//and thank you GreenChicken for your tutorials https://www.shadertoy.com/user/GreenChicken\n// And my thanks to Flopine as well https://www.shadertoy.com/user/Flopine\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define dt(speed) fract(iTime*speed)\n#define looptime(speed) abs(-1.+2.*dt(speed))\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat sdBox( vec3 p, vec3 b){\n    vec3 q = abs(p) -b;\n    return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nvec3 opRepet(vec3 pos,vec3 bound){\n    return mod(pos+0.5*bound,bound)-0.5*bound;\n}\n\n\nvec2 opSmoothUnionVec2( vec2 d1, vec2 d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nvec3 opSmoothUnionVec3( vec3 d1, vec3 d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nvec3 opUnion( vec3 d1, vec3 d2 ) { \n    return (d1.x < d2.x) ? d1 : d2; \n}\n\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nvec3 map(vec3 pos){\n    vec3 pos2 = pos;\n    float offsetY = sin(pos2.x+iTime*1.5)/1.;\n    float offsetz = sin(pos2.x+iTime)*1.2;\n    \n    \n    vec3 world = vec3(pos.y+offsetY,0.0,64.0);\n    \n    vec3 prism = vec3(sdTriPrism(pos+vec3(0.,0.,-1.5), vec2(2.,1.)),0.5,64.);\n    pos2*=vec3(rot(2.));\n    vec3 prism2 = vec3(sdTriPrism(vec3(pos2.x-2.,pos2.y,pos2.z-0.8 ), vec2(2.,1.)),0.5,64.);\n    vec3 prism3 = vec3(sdTriPrism(vec3(pos2.x+1.1,pos2.y,pos2.z-0.6 ), vec2(2.,1.)),0.5,64.);\n    \n    vec3 towerBase = vec3( sdRoundedCylinder(pos,1.,0.5,8. ),pos.y/10.*pos.x*0.5,64.);\n    vec3 towerMid = vec3( sdRoundedCylinder(pos+vec3(0.,-8.,0.),1.4,0.2,0.6 ), 0.8,64.);\n    \n    \n    \n    world = opSmoothUnionVec3(world,prism,0.5);\n    world = opSmoothUnionVec3(world,prism2,0.5);   \n    world = opSmoothUnionVec3(world,prism3,0.5);\n    world = opSmoothUnionVec3(world,towerBase,0.4);\n    world = opSmoothUnionVec3(world,towerMid,0.2);\n    \n    for(int i = 0; i<8;i++){\n        vec3 pillar = vec3( sdRoundedCylinder(pos+vec3(sin(float(i)/1.)*2.,-10.1,cos(float(i)/1.)*2. ),0.1,0.,1.1 ), 0.5,64.);\n        world = opSmoothUnionVec3(world,pillar,0.2);\n    }\n    \n    towerMid = vec3( sdRoundedCylinder(pos+vec3(0.,-12.,0.),1.2,0.2,0.3 ), 0.8,64.);\n    world = opSmoothUnionVec3(world,towerMid,0.2);\n\n\n    return world;\n}\n\nvec2 CastRay(vec3 ro, vec3 rd){\n    float c = 0.0; //si y'a contact, on aura la distance\n    int nbMax = int( map(ro + rd*c).z );\n    \n    for(int i = 0; i<nbMax; i++){\n    \n        vec3 ray = map(ro + rd*c);\n        \n        if(ray.x < (0.01*c)){\n            return vec2(float(i)/float(nbMax),ray.y);\n        }\n        \n        c+=ray.x;\n    }\n    \n    return vec2(-1.0, 0.0);\n}\n\nvec3 render(vec3 ro,vec3 rd){ //rayon origin, rayon direction\n    \n    vec2 contact = CastRay(ro,rd);         \n    \n    \n    vec3 col = vec3(0.);\n    \n    if(contact.x == -1.){\n        col = vec3(0.0);\n        //col = palette(iTime,vec3(0.8,0.4,0.32),vec3(0.4,0.4,0.32),vec3(0.7,0.8,0.32),vec3(0.4,0.4,0.32));\n    }else{\n        col = vec3(1.-contact.x)*palette(contact.y+iTime/4.,vec3(0.5),vec3(0.5),vec3(1.),vec3(0.0,0.33,0.67) );\n    }\n    return col;\n}\n\nfloat procedural_2d (vec2 uv)\n{\n    float size = 0.1 + sin(looptime(.8))*1.5;\n    float circle = step(0.15,\n                        abs(length(uv)-size)\n                        );\n    return circle;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float fov = 2.; //fieldOfView\n    vec2 uv = 2.*fragCoord/iResolution.xy-1.;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    \n    //effects\n    uv.x = uv.x-sin(uv.x+iTime)/4.;    \n    uv = floor(uv*48.)/48.;\n    uv = uv+vec2((sin(uv.x)+1.)/2.)/2.*rot(iTime*0.);\n    \n    //Camera\n    vec3 cameraPos = vec3(4.+sin(iTime)*6.,7.,10.+cos(iTime)*6.);\n    vec3 cameraTarget = vec3(0.,2.+(sin(iTime)+1.)*3.,0.);\n    \n    //view Direction/ RayD Direction\n    vec3 forward = normalize(cameraTarget-cameraPos);\n    vec3 right = normalize(cross(vec3(0.,-1.,0.),forward));\n    vec3 up = normalize(cross(right,forward));\n    vec3 viewDir = normalize(uv.x * right+uv.y*up+forward*fov);\n\n    \n    vec3 col = vec3(uv.x,uv.y,0.0)/4.;\n    \n    vec3 rend = render(cameraPos,viewDir);\n    if(rend == vec3(0.)){\n        if( fract(uv.x-0.05)-uv.y <= 0.3 && fract(-uv.x+0.05)-uv.y <= 0.3) {\n            rend = palette(iTime,vec3(0.8,0.4,0.32),vec3(0.4,0.4,0.32),vec3(0.7,0.8,0.32),vec3(0.4,0.4,0.32));\n        }\n        \n    }\n    \n    col = rend;\n    \n    col = floor(col*32.)/32.;\n    \n    fragColor = vec4(col,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlGfDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 389, 461, 461, 504], [506, 506, 535, 535, 624], [626, 626, 671, 671, 762], [764, 764, 828, 828, 945], [947, 947, 983, 983, 1066], [1068, 1068, 1102, 1102, 1151], [1154, 1154, 1207, 1207, 1311], [1313, 1313, 1366, 1366, 1470], [1472, 1472, 1506, 1506, 1546], [1549, 1549, 1592, 1592, 1614], [1616, 1616, 1660, 1660, 1681], [1683, 1683, 1702, 1702, 2995], [2997, 2997, 3028, 3028, 3376], [3378, 3378, 3407, 3439, 3834], [3836, 3836, 3867, 3867, 4036], [4039, 4039, 4096, 4096, 5202]], "test": "valid"}
{"id": "tlGfDz", "name": "Weekly_21", "author": "Defonsia", "description": "Weekly_21 ", "tags": ["ball"], "likes": 1, "viewed": 34, "published": "Public", "date": "1614173200", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// thanks FranciscoGarcia, IQ\n\n#define rot(a) mat2(cos(a),sin(a), -sin(a), cos(a))\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p)-s;\n}\n\nvec3 opRep(in vec3 p, in vec3 c)\n{\n    return mod(p+0.5 * c, c) -0.5*c;\n    \n}\n\nfloat circulo(in vec3 p, float rad, vec3 pos){\n    \n    p -=pos;\n    p = p-vec3(0.0,4.0,0.0);\n\tp.y -= 0.6*abs(cos(cos(p.x*1.4) + 4.2*iTime));\n    float bouing = sdSphere(p, 1.);\n    return 1.-step(rad, length(p));\n}\n\n\n\n\n\n\n//################MAP##################\n\nfloat map(vec3 pos)// position 3d de la marche\n{   \n    \n    pos = opRep(pos, vec3(6.0,6.0,6.0));\n\n    pos.y -= 0.6*abs(cos(cos(pos.x*1.4) + 4.2*iTime));\n    \n    \n\n    \n    float bouing = sdSphere(pos, 1.);\n\n        \n    return bouing;\n    \n     \n}\n\n//#########################################\n\n\n\nfloat CastRay(vec3 ro, vec3 rd) \n{\n    float c = 0.0; //contact par defaut\n    \n    for (int i=0; i<64; i++) // 64 =nombre de arches max\n    {         \n        float ray = map(ro + rd * c); //nous changeronscette ligne apres\n        \n        if(ray<(0.0001*c))// distance min contact\n        { \n            return float (i)/32.;\n        }        \n        c += ray;    \n    }\n    return -1.0;\n}\n\nvec3 render (vec3 ro, vec3 rd) \n{    \n    float contact = CastRay(ro,rd); //appeldu raycast\n    \n    vec3 col =vec3 (0.0); //couleur par defaut du pixel\n    \n    if (contact == -1.0)//s'il ny a pas de contact en raymarch\n    {\n        col = vec3(0.0);//couleur du fond\n    }\n    else //s'il y a contact\n    {\n        col = vec3(1.0-contact);//couleur du volume\n    }\n    return col;    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //center les uvs et l'echelle x=y\n    vec2 uv =-1.+2.* fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    //definir les parametres denotre camera\n    vec3 cameraPos = vec3 (iTime*5.,1.,4.0);\n    vec3 cameraTar = vec3 (2.0,1.,0.0);\n    \n    //definir le vecteur de direction depuis la camera\n    vec3 forward = normalize (cameraTar- cameraPos);\n    vec3 right = normalize(cross(vec3(0.0, -1.0,0.0), forward));\n    vec3 up = normalize (cross(right, forward));\n    vec3 viewDir = normalize(uv.x * right + uv.y * up +2. * forward);\n    \n    vec3 col= vec3(uv.x, uv.y,0.0);\n    \n    //la couleur de chaque pixel interroge la fonction render\n    col = render(cameraPos,viewDir);    \n    \n    \n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlGfDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 83, 116, 116, 142], [144, 144, 178, 178, 222], [224, 224, 270, 270, 439], [446, 487, 535, 535, 736], [738, 785, 819, 819, 1178], [1180, 1180, 1213, 1213, 1568], [1572, 1572, 1629, 1667, 2378]], "test": "valid"}
{"id": "tlKBRh", "name": "Fractal 27_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 8, "viewed": 104, "published": "Public", "date": "1613894093", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define t iTime\n#define bpm 60.\n#define B (60./bpm)\n#define b (mod(t,B)/B)\n\n#define f(p)if(p.x<p.y)p=p.yx;\n\nvec3 rot(vec3 p,vec3 a,float t){\n  a=normalize(a);\n  return mix(a*dot(p,a),p,cos(t))+sin(t)*cross(p,a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.* gl_FragCoord.xy - iResolution.xy )/iResolution.y;\n    vec3 p,c=vec3(0),d=normalize(vec3(uv,2));\n    float g=0.,e,s,a;\n    for(float i=0.;i<99.;i++){\n        p=g*d;\n        p.z-=7.;\n        p=rot(p,vec3(1,1,1),mix(.5,1.2,mod(t,4.)/4.));\n        s=2.;\n        p=abs(p)-1.8;\n        f(p.xy)\n        f(p.xz)\n        for(int i=0;i<10;i++){\n            p=.8-abs(p-1.2);\n            f(p.xz)\n            s*=e=3./clamp(dot(p,p),.0,1.2);\n            p=abs(p)*e-vec3(.3,9.+b*b*5.,6);\n        }\n        a=1.;\n        p-=clamp(p,-a,a);\n        g+=e=length(p)/s;\n        e<.001?c+=pow(cos(i/64.),5.)*.02\n            *mix(vec3(1),(cos(vec3(1,2,3)+log(s)+t)*.5+.5),.5)\n            :p;\n    }\n    fragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKBRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[108, 108, 140, 140, 213], [215, 215, 272, 272, 997]], "test": "valid"}
{"id": "tlKBWw", "name": "Fork Re Cypher anotherpla 424", "author": "anotherplatypus", "description": "Experimenting with clubber.js and shaders edited by wizgrav\nAudio reactive version of https://www.shadertoy.com/view/MlsGRS by  @dila,  rewired for clubber. \n", "tags": ["block", "world", "ass", "clubber"], "likes": 7, "viewed": 185, "published": "Public API", "date": "1614495029", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The following block is needed for Clubber integration\n#ifndef CLUBBER\nvec4 iMusic[4];\nconst float iTransition = 1.0;\n#define CLUBBER_R len * 0.3\n#define CLUBBER_G len * 0.3\n#define CLUBBER_B len * 0.3\n#define CLUBBER_A 0.0\n#endif\n// Clubber end\n\n#define PI 3.14159\n\nmat3 xrot(float t)\n{\n    return mat3(1.0, 0.0, 0.0,\n                0.0, cos(t), -sin(t),\n                0.0, sin(t), cos(t));\n}\n\nmat3 yrot(float t)\n{\n    return mat3(cos(t), 0.0, -sin(t),\n                0.0, 1.0, 0.0,\n                sin(t), 0.0, cos(t));\n}\n\nmat3 zrot(float t)\n{\n    return mat3(cos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat map(vec3 pos)\n{\n    float speed = 1.0;\n    vec3 grid = floor(pos);\n    vec3 gmod = mod(grid, 3.);\n    vec3 rmod = mod(grid, 4.0) - 2.0;\n    float j = iTime * speed + (CLUBBER_A);\n    float tm = fract(j);\n    rmod *= (cos(tm*PI)-1.0);\n    \n    float g = floor(mod(j,2.0));\n    if (g==0.0){\n        if (gmod.y*gmod.x==1.0) {\n            pos.z += rmod.x*rmod.y*0.5;\n        }\n    } else if (g==1.0){\n        if (gmod.y*gmod.z==1.0) {\n            pos.x += rmod.y;\n        }\n    } else if (g==2.0){\n        if (gmod.z==0.0) {\n            pos.y += rmod.z*rmod.x*0.5;\n        }\n    }\n        \n    grid = floor(pos);\n    pos = pos - grid;\n    pos = pos * 2.0 - 1.0;\n\n    float len = 0.9;\n\tvec3 sc = mix(vec3(0.5), vec3(0.96), vec3(CLUBBER_R,CLUBBER_G,CLUBBER_B));\n    float d = sdBox(pos, sc);\n\n    bool skip = false;\n\n    if (mod(grid.x,2.0)==0.0 && mod(grid.y,2.0)==0.0) {\n        skip = true;\n    }\n\n    if (mod(grid.x,2.0)==0.0 && mod(grid.z,2.0)==0.0) {\n        skip = true;\n    }\n\n    if (mod(grid.y,2.0)==0.0 && mod(grid.z,2.0)==1.0) {\n        skip = true;\n    }\n\t\n    if (skip) {\n        d = 100.0;\n        vec3 off = vec3(2.0,0.0,0.0);\n        for (int i = 0; i < 3; ++i) {\n            float a = sdBox(pos + off,vec3(sc));\n            float b = sdBox(pos - off,vec3(sc));\n            d = min(d,min(a,b));\n            off = off.zxy;\n        }\n        d *= 0.5 *(sc.x+sc.y +sc.z) * 0.33 ;\n    } else {\n        d *= 0.8 * (sc.x+sc.y +sc.z) * 0.33;   \n    }\n    \n    return d;\n}\n\nvec3 surfaceNormal(vec3 pos) {\n \tvec3 delta = vec3(0.01, 0.0, 0.0);\n    vec3 normal;\n    normal.x = map(pos + delta.xyz) - map(pos - delta.xyz);\n    normal.y = map(pos + delta.yxz) - map(pos - delta.yxz);\n    normal.z = map(pos + delta.zyx) - map(pos - delta.zyx);\n    return normalize(normal);\n}\n\nfloat aoc(vec3 origin, vec3 ray)\n{\n    float delta = 0.05;\n    const int samples = 8;\n    float r = 0.0;\n    for (int i = 1; i <= samples; ++i) {\n        float t = delta * float(i);\n     \tvec3 pos = origin + ray * t;\n        float dist = map(pos);\n        float len = abs(t - dist);\n        r += len * pow(2.0, -float(i));\n    }\n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n\tvec3 eye = normalize(vec3(uv, 1.0 - dot(uv,uv) * 0.33));\n    vec3 origin = vec3(0.0);\n    \n    eye = eye * yrot(iTime) * xrot(iTime);\n    \n    float speed = 0.5;\n    \n    float j = iTime * speed + CLUBBER_A;\n    \n    float f = fract(j);\n    float g = 1.0 - f;\n    f = f*f * g + (1.0-g*g) * f;\n    f = f * 2.0 - 1.0;\n\tfloat a = floor(j) + f * floor(mod(j,2.0));\n    float b = floor(j) + f * floor(mod(j+1.0,2.0));\n    \n    origin.x += 0.5 + a;\n    origin.y += 0.5;\n    origin.z += 0.5 + b;\n    \n    float t = 0.0;\n    float d = 0.0;\n    \n    for (int i = 0; i < 32; ++i){\n        vec3 pos = origin + eye * t;\n        d = map(pos);\n        t += d;\n    }\n    \n    vec3 worldPos = origin + eye * t;\n    \n    vec3 norm = surfaceNormal(worldPos);\n    \n    float prod = max(0.0, dot(norm, -eye));\n    \n    float amb = aoc(worldPos, -eye);\n    \n    vec3 ref = reflect(eye, norm);\n    \n    vec3 spec = vec3(0.0);//texture(iChannel0, ref).xyz;\n    \n    prod = pow(1.0 - prod, 2.0);\n    \n    vec3 col = vec3(0.1, 0.3, 0.5);\n    \n    spec *= col;\n    \n    col = mix(col, spec, prod);\n    \n    float shade = pow(max(1.0 - amb, 0.0), 4.0);\n    \n    float fog = 1.0 / (1.0 + t * t * 0.2) * shade;\n    \n    vec3 final = col;\n    \n    final = mix(final, vec3(1.0), fog);\n    \n    fog = 1.0 / (1.0 + t * t * 0.1);\n    \n    float len = 0.9;\n\tvec3 sc = mix(vec3(0.5), vec3(0.96), vec3(CLUBBER_R,CLUBBER_G,CLUBBER_B));\n    \n\tfragColor = vec4(final*fog*sc,0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKBWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[233, 269, 289, 289, 398], [400, 400, 420, 420, 529], [531, 531, 551, 551, 660], [662, 662, 693, 693, 789], [791, 791, 812, 812, 2272], [2274, 2274, 2304, 2304, 2570], [2572, 2572, 2606, 2606, 2916], [2918, 2918, 2975, 2975, 4533]], "test": "valid"}
{"id": "tlsGDf", "name": "My first raymarcher", "author": "Tarquin", "description": "This is my first raymarching shader :)", "tags": ["raymarching"], "likes": 2, "viewed": 51, "published": "Public", "date": "1612621935", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rotation(float a)\n{\n   float c = cos(a);\n   float s = sin(a);\n   return mat2(c, s, -s, c);\n}\n\nfloat sphere(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\nfloat cylinder(vec3 pos, float radius)\n{\n    return length(pos.xz) - radius;\n}\n\nfloat box(vec3 pos, float radius)\n{\n    pos = abs(pos);\n    return max(pos.x, max(pos.y, pos.z)) - radius;\n}\n\nfloat map(vec3 pos)\n{\n    //animate the pos of the origin\n    pos.xy *= rotation(sin(pos.z) * .7);\n    pos.z += iTime * 1.;\n    \n    float size = 2.5;\n    pos = mod(pos, size)-size/2.;\n    \n    float radius = 0.5;\n    float geometry = 10.;\n    geometry = min(geometry, cylinder(pos, radius * 0.05));\n    geometry = min(geometry, cylinder(pos.xzy, radius * .1));\n    \n    return geometry;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 eye = vec3(0,0,0);\n    vec3 ray = normalize(vec3(uv,1.));\n    vec3 pos = eye;\n    float shade = 0.0;\n    for(int index = 0; index < 20;  index++) \n    {\n        float dis = map(pos);\n        if(dis < 0.0001) \n        {\n            shade = 1.0-float(index)/20.;\n            break;\n        }\n        pos += ray * dis;\n    }\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(shade);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlsGDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 97], [99, 99, 137, 137, 172], [174, 174, 214, 214, 252], [254, 254, 289, 289, 362], [364, 364, 385, 421, 753], [755, 755, 812, 862, 1448]], "test": "valid"}
{"id": "tltBzj", "name": "Fractal mercury pool", "author": "jarble", "description": "mouse x controls fractal loop", "tags": ["fractal"], "likes": 5, "viewed": 164, "published": "Public API", "date": "1613090508", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u = 3.*(2.*fragCoord-iResolution.xy)/iResolution.y;\n         u = -u.yx;\n         u += vec2(1.,0.);\n    vec2 v = u;\n         u = u/dot(u,u);\n    \n    float t = 8.0;\n    if(iMouse.z > 0.) t = 10.*iMouse.x/iResolution.x;\n\n    float pi = 3.14159265359;\n    vec4 sum = vec4(0.);\n    for(float i = 0.; i < t; ++i)\n    {\n        u /= cos(u.y-vec2(.0,.5*pi))*exp(sin(u.x+iTime));\n        u+= v;\n        sum+= (1.0+.5*cos(i*4.+vec4(0,1,2,0)))/length(u);\n    }\n    fragColor = sqrt(sum)*.25;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tltBzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 550]], "test": "valid"}
{"id": "tltBzS", "name": "infinity knots", "author": "YitingLiu", "description": "Torus Knots practice ", "tags": ["3d", "shape", "primitive"], "likes": 2, "viewed": 162, "published": "Public API", "date": "1612992693", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//tutorial https://youtu.be/2dzJZx0yngg\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\n\nmat2 Rot(float a){\n    float s=sin(a);\n    float c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat Hash21(vec2 p){\n    p = fract(p*vec2(123.34,233.53));\n    p+=dot(p,p+23.234);\n    return fract(p.x*p.y);\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r){\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap)/dot(ab,ab);\n    t = clamp(t,0.,1.);//never fall outside of A and B\n    vec3 c= a+t*ab;\n    float d = length(p-c)-r;\n    return d;\n    \n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r){\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap)/dot(ab,ab);\n    t = clamp(t,0.,1.);//never fall outside of A and B\n    \n    vec3 c= a+t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x,y),0.));\n    float i = min(max(x,y),0.);//performance penalty \n    \n    //make it smoother \n    return e+i;\n    \n}\n\nfloat sdTorus(vec3 p, vec2 r){\n    //r.x would be r1, r.y would be r2\n    float x = length(p.xz)-r.x;\n    vec2 cp = vec2(x,p.y);\n    float a = atan(p.x,p.z);\n    cp*=Rot(a*3.+iTime);    \n    cp.y=abs(cp.y)-mix(0.2,.5,abs(sin(iTime)));//-mix(0.2,.5,abs(sin(iTime)))\n    float d = length(cp)-r.y;\n    \n    return d*0.5;\n}\n\nfloat dBox(vec3 p, vec3 s){\n    return length(max(abs(p)-s,0.));\n}\n\nfloat GetDist(vec3 p){\n    vec4 s = vec4(0,3.,6.,1);\n    float sphereDist = length(p-s.xyz)-s.w;\n    float planeDist = p.y;\n   \n    //bounce from left to right \n    //float xDis = mix(-1.5,1.5,sin(iTime));\n    float td = sdTorus(p-vec3(1.),vec2(2.,.25));//vec3(3.,2.,8)\n\n  /***  \n    float cd = sdCapsule(p, vec3(0,1,6), vec3(1,2,6),.2);\n    float cd1 = sdCapsule(p, vec3(0,2,6), vec3(1,2,6),.5);\n    float cd2 = sdCapsule(p, vec3(0,3,6), vec3(1,2,6),.2);\n    float cd3 = sdCapsule(p, vec3(1,2,6), vec3(1.5,2,6),.2);\n    float bd = dBox(p-vec3(0.,2.,8),vec3(.8));\n    float cyld = sdCylinder(p, vec3(0,.3,3), vec3(3,1,5),.2);\n  ***/\n    \n    float d = min(td,planeDist);\n    \n    return d; \n    \n}\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.;\n    for (int i =0; i<MAX_STEPS; i++){\n        vec3 p = ro+dO*rd;\n        float dS = GetDist(p);\n        dO +=dS;\n        if (dS<SURF_DIST|| dO>MAX_DIST) break;\n    }\n    return dO;\n}\n\nvec3 GetNormal(vec3 p){\n   vec2 e = vec2(.01,0.);\n   float d = GetDist(p);\n   vec3 n = d-vec3(\n           GetDist(p-e.xyy),\n           GetDist(p-e.yxy),\n           GetDist(p-e.yyx));\n   return normalize(n);\n}\n\nfloat GetLight (vec3 p){\n    vec3 lightPos = vec3(0,5,6);\n    lightPos.xz+=vec2(sin(iTime),cos(iTime))*2.;\n    \n    vec3 l = normalize (lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n,l),0.,1.);\n    float d = RayMarch(p+n*SURF_DIST*2.,l);\n   \n    if (d<length(lightPos-p)) dif*=.1;\n     \n    return dif;\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n//getting the background using ray direction\nvec3 Bg(vec3 rd){\n    float k = rd.y*.5+.5;\n    vec3 col = mix(vec3(.2,abs(sin(iTime))*.2,.1),vec3(.2,.5,abs(sin(iTime))),k);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 col = vec3(0);\n    vec3 ro = vec3(1,4,-4);\n    ro.yz*=Rot(-m.y*3.14+1.);\n    ro.xz*= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv,ro,vec3(0),1.);\n\n    col+=Bg(rd);\n    float d = RayMarch(ro,rd);\n    \n    if(d<MAX_DIST){\n    vec3 p = ro+rd*d;\n    vec3 n = GetNormal(p);\n    vec3 r = reflect(rd,n);\n    \n    \n    float spec = pow(max(0.,r.y),5.*mix(0.5,.8,cos(sin(iTime))));\n    \n    //float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n    //get diffused light     \n    float dif = GetLight(p);\n    col=mix(Bg(r*abs(tan(iTime))),vec3(dif),.2)+spec;\n    //col=vec3(spec);\n  }\n\n    col=pow(col,vec3(.4545));//gamma creation\n   \n\n    fragColor = vec4(col,1.);\n}\n\n\n", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tltBzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 109, 127, 127, 198], [200, 200, 221, 221, 312], [314, 314, 363, 363, 569], [571, 571, 621, 621, 1004], [1006, 1006, 1036, 1075, 1325], [1327, 1327, 1354, 1354, 1393], [1395, 1395, 1417, 1417, 2092], [2094, 2094, 2127, 2127, 2329], [2331, 2331, 2354, 2354, 2539], [2541, 2541, 2565, 2565, 2871], [2873, 2873, 2923, 2923, 3114], [3116, 3161, 3178, 3178, 3304], [3306, 3306, 3362, 3362, 4132]], "test": "valid"}
{"id": "tltfD2", "name": "Hashless Noise Experiment", "author": "Xor", "description": "I'm experimenting with possible alternatives to the typical Perlin/value noise. What do you think?", "tags": ["noise"], "likes": 8, "viewed": 125, "published": "Public", "date": "1613518489", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 c = fragCoord/50.;\n    \n    float g = 0.;\n    vec2 d = vec2(1,0);\n    for(float i = 1.;i++<=64.;)\n    {\n        //Use precomputed kernels here?\n        d = cos(cos(i*i-i)*246.+vec2(0,1.57));\n        //Or just rotate?\n        //d *= mat2(.8,.6,-.6,.8);\n        g += cos(dot(c++,d*sqrt(i))+iTime)/i;\n    }\n\n    vec3 col = vec3(g/4.+.5);\n\n    fragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tltfD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 433]], "test": "valid"}
{"id": "tltfWf", "name": " Pick Points On Hemisphere", "author": "moranzcw", "description": "Uniform distribution and cosine distribution.", "tags": ["3d"], "likes": 4, "viewed": 200, "published": "Public API", "date": "1613664244", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Pick Points On Hemisphere - by moranzcw - 2021\n// Email: moranzcw@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define Epsilon 1e-2\n#define PI 3.14159265359\n\n\n// --------------------------------------\n// oldschool rand() from Visual Studio\n// --------------------------------------\nint   seed = 1;\nvoid  srand(int s ) { seed = s; }\nint   rand(void)  { seed=seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\n// --------------------------------------\n// hash by Hugo Elias\n// --------------------------------------\nint hash( int n ) { n=(n<<13)^n; return n*(n*n*15731+789221)+1376312589; }\n\nstruct Ray \n{ \n    vec3 origin, direction;\n};\n\nstruct Sphere \n{\n\tfloat radius;\n\tvec3 position;\n};\n\nSphere sphere1 = Sphere(1.0, vec3(-1.2, 0.0, 0.0));\nSphere sphere2 = Sphere(1.0, vec3(1.2, 0.0, 0.0));\n\nfloat intersect(Sphere sphere, Ray ray)\n{\n\tvec3 op = sphere.position - ray.origin;\n\tfloat t1, t2 = Epsilon;\n    float b = dot(op, ray.direction);\n    float det = b * b - dot(op, op) + sphere.radius * sphere.radius;\n    \n\tif (det < 0.0)\n        return 0.0;\n    else\n        det = sqrt(det);\n    \n    t1 = b - det;\n    t2 = b + det;\n    if(t1 > Epsilon)\n        return t1;\n    if(t2 > Epsilon)\n        return t2;\n    return 0.0;\n}\n\nRay cameraRay(vec3 camPosition, vec3 lookAt, vec2 fragCoord)\n{\n    vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n\n    vec3 cz = normalize(lookAt - camPosition);\n\tvec3 cx = normalize(cross(cz, vec3(0.0, 1.0, 0.0)));\n\tvec3 cy = normalize(cross(cx, cz));\n    \n    return Ray(camPosition, normalize(0.53135 * (iResolution.x/iResolution.y*uv.x * cx + uv.y * cy) + cz));\n}\n\n// unifrom picking\nvec3 hemiSpherePoint(vec3 normal)\n{\n    float theta = 2.0 * PI * frand();\n    float cosPhi = frand();\n    float phi = acos(cosPhi);\n    \n    vec3 zAxis = normal;\n    vec3 xAxis = normalize(cross(normal, vec3(1.0, 0.0, 0.0)));\n    vec3 yAxis = normalize(cross(normal, xAxis));\n    \n    vec3 x = cos(theta) * xAxis;\n    vec3 y = sin(theta) * yAxis;\n    vec3 horizontal = normalize(x + y);\n    vec3 z = cosPhi * zAxis;\n    vec3 p = horizontal * sin(phi) + z;\n    \n    return normalize(p);\n}\n\n// Cosine distribution picking by iq\nvec3 hemiSpherePointCos(vec3 normal)\n{\n    float u = frand();\n    float v = frand();\n    float a = 6.2831853 * v;\n    u = 2.0*u - 1.0;\n    return normalize( normal + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    ivec2 q = ivec2(fragCoord);\n    srand(hash(1117));\n    \n    // camera ray\n    vec3 camPosition = mix(vec3(0.0, 0.0, 4.0), vec3(0.0, 3.0, 3.0), 0.5*sin(iTime*0.2)+0.5);\n    vec3 lookAt = vec3(0.0, 0.0, 0.0);\n    Ray ray = cameraRay(camPosition, lookAt, fragCoord);\n    \n\tvec3 color = vec3(0.0);\n    \n    // intersect\n    float t = intersect(sphere1, ray);\n    if(t > 0.0)\n    {\n        vec3 point = ray.origin + t * ray.direction;\n        for(float i=0.0; i<5000.0; i++)\n        {\n            vec3 p = sphere1.position + hemiSpherePoint(vec3(0.0, 1.0, 0.0));\n            \n            float tt = 0.5*sin(iTime)+0.5;\n            vec3 color1 = vec3(1.0,0.0,0.0) * step(length(point-p), 0.007) * step(0.0, point.y);\n            vec3 color2 = vec3(0.006,0.0,0.0) * step(length(point-p), 0.2) * step(0.0, point.y);\n            color += mix(color1, color2 , tt);\n        }\n    }\n    \n    t = intersect(sphere2, ray);\n    if(t > 0.0)\n    {\n        vec3 point = ray.origin + t * ray.direction;\n        for(float i=0.0; i<5000.0; i++)\n        {\n            vec3 p = sphere2.position + hemiSpherePointCos(vec3(0.0, 1.0, 0.0));\n            float tt = 0.5*sin(iTime)+0.5;\n            vec3 color1 = vec3(0.0,1.0,0.0) * step(length(point-p), 0.007) * step(0.0, point.y);\n            vec3 color2 = vec3(0.0,0.006,0.0) * step(length(point-p), 0.2) * step(0.0, point.y);\n            color += mix(color1, color2 , tt);\n        }\n    }\n\tfragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tltfWf.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[215, 354, 375, 375, 387], [388, 388, 407, 407, 462], [463, 463, 482, 482, 514], [515, 621, 640, 640, 695], [900, 900, 941, 941, 1328], [1330, 1330, 1392, 1392, 1701], [1703, 1722, 1757, 1757, 2209], [2211, 2248, 2286, 2286, 2464], [2467, 2467, 2525, 2525, 3977]], "test": "valid"}
{"id": "tltfWl", "name": "Looping 1D Noise (take 2)", "author": "airtight", "description": "Looping 1 noise (take 2). Optimized version of: https://www.shadertoy.com/view/tddfWB\n\nBased on: http://connorbell.ca/2017/09/09/Generating-Looping-Noise.html (Method 2)\n", "tags": ["noise", "loop", "1d"], "likes": 1, "viewed": 68, "published": "Public", "date": "1613695802", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash(float n) { return fract(sin(n) * 1e4); }\n\n// looping noise\n// note x range must be same size or bigger than loopLen\n// use bigger loopLen for more detail in loop\nfloat loopNoise(float x, float loopLen) {\n\n    // cycle the edges\n    x = mod(x, loopLen);\n\n    float i = floor(x); // floored integer component\n    float f = fract(x); // fractional component\n    float u = f*f*f*(f*(f*6.-15.)+10.); // use f to generate a curve\n\n    // interpolate from the current edge to the next one wrt cycles\n    return mix(hash(i), hash(mod(i + 1.0,  loopLen)), u); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //looping 1d noise every 2 seconds\n    float nloop = loopNoise(uv.x * 12. + iTime * 2., 12.);\n    vec3 col = vec3(step(nloop,uv.y));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tltfWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 51], [53, 173, 214, 238, 564], [566, 566, 623, 673, 913]], "test": "valid"}
{"id": "tltfWN", "name": "Vortex_", "author": "YitingLiu", "description": "invitation to another dimension ", "tags": ["3d", "time", "torus", "texture", "camera", "shader", "trippy", "material", "ichannel", "visuals", "lookat", "normalize", "artofcode"], "likes": 2, "viewed": 196, "published": "Public API", "date": "1612794734", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//tutorial https://www.youtube.com/watch?v=rA9NmBRqfjI\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t = iTime*0.2;\n    vec3 ro = vec3(0,0,-1.5);//camera pos // if y is -1. we are in the middle \n    //vec3 lookat = vec3(0); // look at the center \n    vec3 lookat = mix(vec3(0,0,0),vec3(-1,-3,2),sin(t*1.56)*.5+.5);\n    float zoom = mix(.1,.5,abs(cos(t)));//.1*sin(t)+.1;//1.;\n   \n    vec3 f = normalize(lookat-ro),\n        r = normalize(cross(vec3(0,1,0),f)),\n        u = cross(f,r),\n        c= ro+f*zoom,\n        i = c+uv.x*r+uv.y*u,\n        rd=normalize(i-ro);\n        \n        float dS, dO;\n        vec3 p;\n        \n        for (int i =0; i <100; i++){\n            p = ro+rd*dO;\n            dS = -(length(vec2(length(p.xz)-1.,p.y))-.75);\n            if(dS<.001)break;\n            dO+=dS;\n        }\n    \n    \n    \n    vec3 col = vec3(0.);\n    \n    //creating torus \n    if(dS<.001){\n        float x = atan(p.x,p.z)+t;\n        float y = atan(length(p.xz)-1.,p.y);//distance to the circle \n        float ratio = mix(2.,8.,max(0.,sin(t)));\n        float i = 2.;\n        float e = i*ratio; \n        \n        float bands = sin(y*i+x*e);\n        float ripples = sin((x*i-y*e)*3.)*.5+.5;\n        float waves = sin(x*i/2.-y*e/2.+t*.5 );\n        \n        float b1 = smoothstep(-.2,.2,bands);\n        float b2 = smoothstep(-.2,.2,bands-.5);\n        \n        float m = b1*(1.-b2);\n        \n        //need to keep the ratio of x and y below \n        m=max(m,ripples*b2*max(0.,waves));\n        m+=max(0.,waves*.5);\n       \n       float offset = 0.2;\n       col+=texture(iChannel0,vec2(m,sin(t))).rgb;\n       col-=vec3(m);\n\n       col/=vec3(m,m-offset*t/10.,m-offset/t);\n\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tltfWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 56, 113, 113, 1780]], "test": "error"}
{"id": "tltfzS", "name": "AOC tutorial", "author": "Mattiabrr", "description": "This is a tutorial from art of code", "tags": ["tutorial"], "likes": 1, "viewed": 38, "published": "Public", "date": "1613000149", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Circle(vec2 uv, vec2 p, float r, float blur){\n    \n    float d = length(uv-p);\n    float c = smoothstep(r, r-blur, d);\n    \n    return c;\n}\n\nfloat Band(float t, float start, float end, float blur){\n    float step1 = smoothstep(start-blur, start+blur, t);\n    float step2 = smoothstep(end+blur, end-blur, t);\n    return step1*step2;\n}\n\nfloat Rect(vec2 uv, float left, float right, float bottom, float top, float blur){\n    \n    float band1 = Band(uv.x, left, right, blur);\n    float band2 = Band(uv.y, bottom, top, blur);\n    \n    return band1*band2;\n\n}\n\nfloat Smiley(vec2 uv, vec2 p, float size) {\n    uv -= p; //translating coordinate system\n    uv /= size; //scaling coordinate system\n\n    float mask = Circle(uv,vec2(0.), .4, .01);\n    \n    mask -= Circle(uv,vec2(-.13, .2), .07, .01);\n    mask -= Circle(uv,vec2(.13, .2), .07, .01);\n    \n    float mouth = Circle(uv, vec2(0., 0.), .3, .02);\n    mouth -= Circle(uv, vec2(0., 0.1), .3, .02);\n    \n    mask -= mouth;\n    \n    return mask;\n}\n\nfloat remap01(float a, float b, float t){\n    return (t-a) / (b-a);\n}\n\nfloat remap(float a, float b, float c, float d, float t){\n    return remap01(a, b, t) * (d-c) + c;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy /iResolution.xy;// 0 <> 1.\n    \n    float t = iTime;\n    uv -= .5;  // -0.5 <> 0.5\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = vec3(0.);\n   \n    float mask = 0.;\n    \n    float x = uv.x;\n    \n    float m = sin(t+x*8.)*.1;\n    float y = uv.y-m;\n    \n    //Smiley(uv, vec2(0., 0.), 1.);\n    \n    //x += y;\n    float blur = remap(-.5, .5, .01, .25, x);\n    //blur = pow(blur*4., 3.); \n    mask = Rect(vec2(x,y), -.5, .5, -.1, .1, blur);\n    col = vec3(1.,1.,1.)*mask;\n    \n    fragColor = vec4(col, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tltfzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 51, 145], [147, 147, 203, 203, 339], [341, 341, 423, 423, 558], [560, 560, 603, 603, 997], [999, 999, 1040, 1040, 1068], [1070, 1070, 1127, 1127, 1170], [1171, 1171, 1228, 1228, 1777]], "test": "valid"}
{"id": "tlVBRm", "name": "Bouncy Castle Outerspace", "author": "YitingLiu", "description": "Made customizable functions for paired toruses. I made four pairs of toruses with blend function. ", "tags": ["raymarching", "template", "artofcode"], "likes": 0, "viewed": 141, "published": "Public API", "date": "1614119776", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    return length(p-c)-r;\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    //t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i;\n}\n\nfloat sdTorus(vec3 p, vec2 r) {\n\tfloat x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat dBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat torus(vec3 p, vec2 offs, mat2 rotVal, float t, float merge){\n\n    //offs=vec2(1.5,.2);\n    \n    vec3 bp = p;\n    bp -= vec3(0,.75,3);\t\t// translation\n    \n    float y = -fract(t)*(fract(t)-1.)*merge;\t\t\t// repeating parabola\n    vec3 tp = p;\n    tp -= vec3(-5, .8+2.*y, -5.*(sin(t)*.5+.5));\t\t\t\t\t// translate\n   \n    float squash = 1.+smoothstep(.5, .25, y)*2.;// scale\n    tp.y *= squash;\n    tp = tp.xzy;\t\t\t\t\t\t\t\t// flip torus on its side\n   \n    vec3 tp2 = p;\n   \n    tp2 -= vec3(-3, .8+1.*y, -3.*(cos(t)*.5+.5));\t\t\t\t\t// translate\n    tp2.y *= squash;\n    tp2 = tp2.xyz;\t\t\t\t\t\t\t\t// flip torus on its side\n\n    tp.yz*=rotVal;\n    tp2.xy*=Rot(t);\n    float scale = sdTorus(tp, offs)/squash;\n    float scale2 = sdTorus(tp2, vec2(offs*(sin(t)*.5+1.)))/squash;\n    \n   // vec2 pairs = vec2(scale,scale2);\n        \n    float blendTorus = smin(\n        scale,\n        scale2,\n        .8\n    );\n    return blendTorus; \n\n}\n\nfloat mergeBoxes(vec3 p, vec3 offs, vec3 size1, vec3 size2, float strength, float t){\n    vec3 bp = p;\n    bp -= vec3(0,.75,3);\t\t// translation\n    bp.xz *= Rot(iTime);\t\t// rotation\n    float rotate = dBox(bp, vec3(.75));\n    \n    /**\n    offs=vec3(3,1.,-3);\n    size1 =vec3(.5,.8*sin(t),.5*cos(t));\n    size2 = vec3(.5,.2,1.);\n    **/\n    float blendBoxes = smin(\n        dBox(p-offs, size1),    \n        dBox(p-offs, size2),strength);\n        \n   return blendBoxes;\n}\n\nfloat subtract(vec3 p, vec3 s, vec3 offs){\n// -dBox(p-vec3(1.+sin(t)*.5,1,0), vec3(1,.5,2)), \n//offs vec3(0,1,0)\n    float subtract = max(\n        -dBox(p,s), \n        length(p-offs)-.8\n    );\n    \n    return subtract; \n}\n\n\n\nfloat GetDist(vec3 p) {\n    \n    float t = iTime;\n    \n    // ground plane\n    float pd = p.y;\n    float blendTorus = torus(p,vec2(2.,.5),Rot(t),t,1.);\n    float blendTorus2 = torus(p-.5,vec2(7.,.1),Rot(t*2.),t*.5,.7);\n    float blendTorus3 = torus(p-2.,vec2(5.,.2),Rot(sin(t)),t,1.);\n    float blendTorus4 = torus(p-3.,vec2(4.,.3),Rot(sin(t)),t,1.);\n    \n    //merging boxes in 90 degrees \n    vec3 offs=vec3(3,1.,-3), size1 =vec3(2.,.8*(sin(t)*.5+.5),2.*cos(t)), size2 = vec3(.5,2.,1.);\n    float strength = 1.; // 0 1 \n    float blendBoxes = mergeBoxes(p,offs, size1, size2,strength, t);\n    \n  \n   float subVal = subtract(p-vec3(3.+sin(t)*.5,2.,0.8), vec3(2.,.5,2),vec3(0,2.5,0));\n\n /**   // rotating box\n    vec3 bp = p;\n    bp -= vec3(0,.75,3);\t\t// translation\n    //bp.xz *= Rot(iTime);\t\t// rotation\n    float rotate = dBox(bp, vec3(.75));\n    \n    // jumping torus\n    float y = -fract(t)*(fract(t)-1.);\t\t\t// repeating parabola\n    vec3 tp = p;\n    tp -= vec3(-3, .8+1.*y, -3.*(sin(t)*.5+.5));\t\t\t\t\t// translate\n   \n    float squash = 1.+smoothstep(.5, .25, y)*.5;// scale\n    tp.y *= squash;\n    tp = tp.xzy;\t\t\t\t\t\t\t\t// flip torus on its side\n   \n   vec3 tp2 = p;\n   \n    tp2 -= vec3(-3, .8+1.*y, -3.*(cos(t)*.5+.5));\t\t\t\t\t// translate\n    tp2.y *= squash;\n    tp2 = tp2.xyz;\t\t\t\t\t\t\t\t// flip torus on its side\n\n    tp.yz*=Rot(t);\n    tp2.xy*=Rot(t);\n    float scale = sdTorus(tp, vec2(1.5, .2))/squash;\n    float scale2 = sdTorus(tp2, vec2(.5*(sin(t)*.5+2.), .1))/squash;\n    \n    float torus= sdTorus(p-vec3(sin(iTime)*.5-1.,2.,0.5), vec2(.5,.2));\n    float torus2 =sdTorus(p+vec3(sin(iTime)*.8-2.,0.,2.), vec2(.2*(sin(t)*.5+2.),.5));\n\n  \n    float morph2 = mix(\n        length(p-vec3(4,1,2))-1., \n        torus2,\n        sin(t)*.5+.5\n    );\n    \n    float morph3= mix(\n       torus2,\n       torus,\n        sin(t)*.5+.5\n    );\n  \n   \n    float morph = mix(\n        length(p-vec3(4,1,2))-1., \n        dBox(p-vec3(4,1,2), vec3(1,1,1)), \n        sin(t)*.5+.5\n    );\n    \n    float subtract = max(\n        -dBox(p-vec3(1.+sin(t)*.5,1,0), vec3(1,.5,2)), \n        length(p-vec3(0,1,0))-.8\n    );\n    \n    float intersect = max(\n        dBox(p-vec3(sin(iTime)*.5-3.,1,0), vec3(1,.5,2)), \n        length(p-vec3(-4,1,0))-1.\n    );\n    \n    float blend = smin(\n        length(p-vec3(1.,(sin(t)*.5+.5),-2))-(sin(t)*.5+.5)*.8-.2,\n        dBox(p-vec3(1,1,-2), vec3(.5,1.,.2*(sin(t)*.5+.6))),\n        .2\n    );\n    \n    float blendBoxes = smin(\n        dBox(p-vec3(3,1.,-3), vec3(.5,.8*sin(t),.5*cos(t))),    \n        dBox(p-vec3(3,1,-3), vec3(.5,.2,1.)),.2);\n      **/\n      \n  \n    \n    /**\n      float subtract = max(\n        -sdCapsule(p-vec3(1.+sin(t)*.5,1,0), vec3(1,.2,2),vec3(1,.25,2.),2.), \n        length(p-vec3(0,1,0))-.5\n    );\n    \n    **/\n   /*** \n    float morph = mix(\n        length(p-vec3(4,1,2))-1., \n        dBox(p-vec3(4,1,2), vec3(1,1,1)), \n        sin(t)*.5+.5\n    );\n    \n    float subtract = max(\n        -dBox(p-vec3(1.+sin(t)*.5,1,0), vec3(1,.5,2)), \n        length(p-vec3(0,1,0))-.8\n    );\n    \n    float intersect = max(\n        dBox(p-vec3(sin(iTime)*.5-3.,1,0), vec3(1,.5,2)), \n        length(p-vec3(-4,1,0))-1.\n    );\n    \n    float blend = smin(\n        length(p-vec3(3,1,-3))-.75,\n        length(p-vec3(3.+.5,1.5,-3))-.5,\n        .2\n    );\n    \n    **/\n    \n    \n    float d;\n //d=pd;\n    d=min(pd,blendTorus);\n   //d= min(morph, pd);\n   //d = min(d, subVal);\n   //d = min(d, intersect);\n   //d = min(d, rotate);\n   // d = min(d, scale2);\n   // d=min(d,blend);\n   // d=min(d,blendBoxes);\n    d = min(d, blendTorus);\n    d = min(d, blendTorus2);\n    d = min(d, blendTorus3);\n    d = min(d, blendTorus4);\n    d *= min(blendTorus, blendTorus4);\n    d /= min(blendTorus2, blendTorus3);\n   // d = mix(blendTorus, blendTorus4,pd*.8);\n    //d = 100.*(sin(d*.2)*.5+.5);\n\n    //d = min(d, blendTo2rus);\n\n   // d = min(d, blend);\n    \n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = abs( GetDist(p) );\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(3, 5, 4);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    if(p.y<.01 && d<length(lightPos-p)) dif *= .5;\n    \n    return dif;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 8, -8);\n    \n    ro.yz *= Rot(-m.y+.4);\n    ro.xz *= Rot(iTime*.2-m.x*6.2831);\n    \n    vec3 rd = R(uv, ro, vec3(0,0,0), .7);\n\n    float d = RayMarch(ro, rd);\n    float gradient = rd.y+.5;\n    col=texture(iChannel0, 2.*rd.xy*Rot(iTime*0.05)).rgb;\n\n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \n    \tfloat dif = GetLight(p);\n\n    \tcol = vec3(dif);\n\n    }\n     col = pow(col, vec3(.4545));\t// gamma correction\n //adding filter \n     col -= mix(vec3((cos(iTime)*.5+.5),.5,.2)*max((cos(iTime)*.5+.5),.8),vec3(.8,.2,.3),rd.y);\n\n    col+=vec3(.2*gradient);\n\n\n   \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlVBRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 87, 87, 163], [165, 165, 206, 206, 297], [299, 299, 349, 349, 517], [519, 519, 570, 570, 882], [884, 884, 915, 915, 983], [985, 985, 1013, 1013, 1094], [1096, 1096, 1162, 1188, 2014], [2016, 2016, 2101, 2101, 2485], [2487, 2487, 2529, 2599, 2708], [2712, 2712, 2735, 2735, 6578], [6581, 6581, 6615, 6615, 6828], [6830, 6830, 6854, 6854, 7044], [7046, 7046, 7070, 7070, 7340], [7342, 7342, 7384, 7384, 7579], [7583, 7583, 7640, 7640, 8389]], "test": "error"}
{"id": "tlVBW1", "name": "My first ray tracing", "author": "DosU", "description": "Thanks to Roman Petrov's tutorial: https://medium.com/@megus/creativity-through-limitation-shadertoy-7dc3fa80c14e", "tags": ["raytracingmouse3d"], "likes": 3, "viewed": 54, "published": "Public", "date": "1614283787", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define COUNT 12\n#define SIZE 2\n\n#define LIGHT_POWER 80.\n#define SPECULAR_POWER 20.\n#define AMBIENT .3\n\nvec4 spheres[] = vec4[COUNT * SIZE](\n    // Spheres: center and radius, color, movement speed, movement amplitude\n    // Light source\n    vec4(0., 0., 35., 0.25), vec4(1., 1., 1., 1.),\n    // 1.1\n    vec4(-3, 2.595, 40, 0.5), vec4(1., 0., 0., 1.),\n    // 1.2\n    vec4(-1, 2.595, 40, 0.5), vec4(.66, .33, 0., 1.),\n    // 1.3\n    vec4(1, 2.595, 40, 0.5), vec4(.33, .66, 0., 1.),\n    // 1.4\n    vec4(3, 2.595, 40, 0.5), vec4(0., 1., 0., 1.),\n    // 2.1\n    vec4(-2., 0.865, 40, 0.5), vec4(.66, .33, .33, 1.),\n    // 2.2\n    vec4(0., 0.865, 40, 0.5), vec4(.55, .55, .33, 1.),\n    // 2.3\n    vec4(2., 0.865, 40, 0.5), vec4(.33, .66, .33, 1.),\n    // 3.1\n    vec4(-1, -0.865, 40, 0.5), vec4(.33, 0., .66, 1.),\n    // 3.2\n    vec4(1, -0.865, 40, 0.5), vec4(0., .33, .66, 1.),\n    // 4.1\n    vec4(0, -2.595, 40, 0.5), vec4(0., 0., 1., 1.),\n    // \"Floor\"\n    vec4(0, 0, 800050, 800000), vec4(1.7, 1.0, .7, 1)\n);\nvec2 vel = vec2(0., 0.);\nvec2 acc = vec2(0., 0.);\nfloat oldTime = 0.;\n\nfloat random[] = float[20]( 0.95, 0.34, 0.25, 0.15, 0.91,\n                      0.55, 0.34, 0.67, 0.23, 0.38,\n                      0.12, 0.34, 0.89, 0.57, 0.11,\n                      0.98, 0.95, 0.45, 0.24, 0.87);\nint randIndex = 0;\nfloat rand() {\n    if(randIndex > 19) randIndex = 0;\n    else randIndex++;\n    return random[randIndex];\n}\n\n// Calculate a moving sphere center\nvec3 sphereCenter(int sphere) {\n    if(sphere != 0){\n        return spheres[sphere * SIZE].xyz;\n    } else {\n        //if (oldTime == 0.0){\n          //  acc.x = rand();\n            //acc.y = rand();\n            //oldTime = iTime;\n        //} else{\n            //float t = iTime - oldTime;\n            //oldTime = iTime;\n            //spheres[0].x += vel.x*t+acc.x*t*t/2.0;\n            //spheres[0].y += vel.y*t+acc.y*t*t/2.0;\n            //vel.x += acc.x*t;\n            //vel.y += acc.y*t;\n            //if(spheres[0].x > 3.0){\n                //acc.x -= rand()/10.;\n            //}else if(spheres[0].x < 3.0){\n            //    acc.x += rand()/10.;\n            //} else {\n            //    acc.x += rand()/10.-0.5;\n            //}\n            //if(spheres[0].y > 3.0){\n            //    acc.y -= rand()/10.;\n            //}else if(spheres[0].y < 3.0){\n            //    acc.y += rand()/10.;\n            //} else {\n            //    acc.y += rand()/10.-0.5;\n            //}\n        //}\n    }\n    return spheres[sphere * SIZE].xyz;\n}\n\n// Find a nearest ray-sphere intersection\n// o - ray origin\n// l - ray direction (normalized)\n// ignore - sphere to ignore when detecting intersection (used for shadows)\n// d - distance output\n// Returns sphere number, -1 if no intersection found\nint findIntersection(vec3 o, vec3 l, int ignore, out float d) {\n    int sphere = -1;\n    d = 1e5;\n    \n    for (int i = 0; i < COUNT; i++) {\n        if (i == ignore) {\n            continue;\n        }\n        vec3 c = sphereCenter(i);\n        float r = spheres[i * SIZE].w;\n\n        // Ray-sphere intersection formula\n        vec3 t1 = o - c;\n        float t1l = length(t1);\n        float t2 = dot(l, t1);\n        float s = t2 * t2 - t1l * t1l + r * r;\n        if (s >= 0.) {\n            float ss = sqrt(s);\n            float sd = min(-t2 + ss, -t2 - ss);\n            if (sd >= 0. && sd < d) {\n                sphere = i;\n                d = sd;\n            }\n        }\n    }\n    return sphere;\n}\n\n// Trace a single ray\n// camO - camera origin\n// camL - camera ray direction (normalized)\n// Returns a fragment color\nvec3 trace(vec3 camO, vec3 camL) {\n    float d = 0.;\n    int sphere = findIntersection(camO, camL, -1, d);\n    \n    if (sphere == -1) {\n        // There was no intersection, return background color\n        return vec3(0, 0, 0);\n    }\n    \n    vec3 lightColor = spheres[1].xyz;\n\n    if (sphere == 0) {\n        // It's a light source, don't need to shade it\n        return lightColor;\n    }\n    \n    vec3 lightPoint = sphereCenter(0);\n    \n    // Sphere color\n    vec3 sColor = spheres[sphere * SIZE + 1].xyz;\n    vec3 aColor = sColor * vec3(AMBIENT, AMBIENT, AMBIENT);\n\n    // Intersection point\n    vec3 iPoint = camO + camL * d;\n    vec3 iNormal = normalize(iPoint - sphereCenter(sphere));\n\n    // Light direction vector\n    vec3 lightDir = normalize(lightPoint - iPoint);\n    \n    // Check if there's another sphere between this one and the light source\n    float dShadow = 0.;\n    int shadowedBy = findIntersection(iPoint, lightDir, sphere, dShadow);\n    dShadow = float(shadowedBy + 1) / 5.0;\n    if (shadowedBy != 0) {\n        // We're under shadow, use ambient color\n        return aColor;\n    }\n    \n    // Lighting (diffusion and specular)\n    float cosA = clamp(dot(iNormal, lightDir), 0., 1.);\n    float cosS = clamp(dot(-camL, reflect(-lightDir, iNormal)), 0., 1.);\n\n    float dSquared = pow(length(iPoint - lightPoint), 2.);\n    \n    return aColor +\n        sColor * lightColor * cosA * LIGHT_POWER / dSquared +\n        lightColor * pow(cosS, SPECULAR_POWER) * LIGHT_POWER / dSquared;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n    m = m * 2.0 - 1.0;\n    m.x *= iResolution.x / iResolution.y;\n    m = m * 5.08;\n    spheres[0].xy = m.xy;\n    \n    // Camera\n    vec3 camO = vec3(0, 0, 0);\n    vec3 camL = normalize(vec3(uv.x, uv.y, 7));\n    \n    spheres[0].z = 34. + 5.*cos(iTime);\n    spheres[1].x = 0.7 + 0.3*sin(iTime);\n    spheres[1].y = 0.7 + 0.3*cos(iTime);\n    spheres[1].z = 0.7 + 0.3*(2. - sin(iTime) + cos(iTime))/2.;\n    \n    // Ray-tracing\n    fragColor = vec4(trace(camO, camL), 1.);      \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlVBW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1313, 1313, 1327, 1327, 1419], [1421, 1457, 1488, 1488, 2490], [2492, 2739, 2802, 2802, 3434], [3436, 3554, 3588, 3588, 5052], [5054, 5054, 5111, 5161, 5790]], "test": "error"}
{"id": "tlVfz1", "name": "Color swirly", "author": "morphix", "description": "Color swirl", "tags": ["colorswirl"], "likes": 3, "viewed": 70, "published": "Public", "date": "1613921328", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// I also posted a version here: http://glslsandbox.com/e#71503.0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n    for(float i=1.; i<9.; i++){\n        uv.x += .5/i*sin(1.9 * i * uv.y + iTime / 2. - cos(iTime / 66. + uv.x))+21.;\n        uv.y += .4/i*cos(1.6 * i * uv.x + iTime / 3. + sin(iTime / 55. + uv.y))+31.;\n    }\n    fragColor = vec4(sin(3. * uv.x - uv.y), sin(3. * uv.y), sin(3. * uv.x), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlVfz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 66, 123, 123, 481]], "test": "valid"}
{"id": "tlyBDD", "name": "Raymarching - Infinite Space", "author": "Victor000_1", "description": "First raymarching test", "tags": ["ati"], "likes": 2, "viewed": 48, "published": "Public", "date": "1614332611", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nvec3 opRep(in vec3 p, in vec3 c)\n{\n    return mod(p+0.5 * c, c)-.5*c;  \n}\n\nfloat map(vec3 pos) \n{\n    \n    //pos = vec3(2*rot(time));\n    pos = opRep(pos,vec3(6));\n    \n    float world = sdOctahedron(pos, sin(iTime));\n\n    world = opSmoothUnion(world, sdSphere(pos, 0.5), 0.5);\n    \n    return world;\n}\n\nfloat castRay(vec3 ro, vec3 rd)\n{\n    float c = 0.; //si y'a contact, on aura la distance\n    int multiplier = 128;\n    \n    for(int i = 0; i<multiplier; i++)\n    {\n        float ray = map(ro + rd*c);\n        \n        if(ray < (0.0001*c))\n        {\n            return float (i)/(float(multiplier)/2.);\n        }\n        c+=ray;\n    } \n    return -1.0;\n}\n\n\nvec3 render(vec3 ro, vec3 rd) \n{\n    \n    float contact = castRay(ro ,rd); \n    \n    vec3 col = vec3(0.);\n    \n    if(contact == -1.){\n        col = vec3(0.);\n    }else{\n        col = vec3(1.-contact);\n    }\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Première initialisation\n    float fov = 2.5; //fieldOfView\n    vec2 uv = 2.*fragCoord/iResolution.xy-1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // Centrer la caméra\n    vec3 camPos = vec3(10.*rot(iTime/2.));\n    vec3 camTar = vec3(0);\n    \n    // Direction de la vue / du rayon\n    vec3 forward = normalize(camTar - camPos);\n    vec3 right = normalize(cross(vec3(0, -1, 0), forward));\n    vec3 up = normalize(cross(right, forward));\n    vec3 viewDir = normalize(uv.x * right + uv.y * up+ forward*fov);\n    \n    vec3 col = vec3(uv.x,uv.y,0.0);\n    col = render(camPos,viewDir);\n    fragColor = vec4(col, 1);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlyBDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 103, 103, 202], [204, 204, 239, 239, 263], [265, 265, 296, 296, 383], [385, 385, 423, 423, 703], [705, 705, 739, 739, 778], [780, 780, 802, 838, 1007], [1009, 1009, 1042, 1042, 1362], [1365, 1365, 1397, 1397, 1590], [1593, 1593, 1650, 1682, 2284]], "test": "valid"}
{"id": "tlyBDz", "name": "Double sided rasterizer", "author": "Epixu", "description": "Just testing a double sided rasterizer performance, based on iq's example", "tags": ["rasterizer"], "likes": 4, "viewed": 78, "published": "Public", "date": "1614171887", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat4 setRotation( float x, float y, float z )\n{\n    float a = sin(x); float b = cos(x); \n    float c = sin(y); float d = cos(y); \n    float e = sin(z); float f = cos(z); \n\n    float ac = a*c;\n    float bc = b*c;\n\n    return mat4( d*f,      d*e,       -c, 0.0,\n                 ac*f-b*e, ac*e+b*f, a*d, 0.0,\n                 bc*f+a*e, bc*e-a*f, b*d, 0.0,\n                 0.0,      0.0,      0.0, 1.0 );\n}\n\nmat4 setTranslation( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,     y,   z, 1.0 );\n}\n\nstruct Triangle\n{\n    vec3 a; vec2 aUV;\n    vec3 b; vec2 bUV;\n    vec3 c; vec2 cUV;\n    vec3 n;\n};\n\n\nTriangle triangles[2];\n\nvoid createCube( void )\n{\n    vec3 verts[4];\n\n    verts[0] = vec3( 0.0, -1.5, -1.0 );\n    verts[1] = vec3( 0.0, -1.5,  1.0 );\n    verts[2] = vec3( 0.0,  1.5, -1.0 );\n    verts[3] = vec3( 0.0,  1.5,  1.0 );\n\n    triangles[0].a = verts[1];\n    triangles[0].aUV = vec2(1.0,0.0);\n    triangles[0].b = verts[2];\n    triangles[0].bUV = vec2(0.0,1.0);\n    triangles[0].c = verts[0];\n    triangles[0].cUV = vec2(0.0,0.0);\n    triangles[0].n = vec3( -1.0, 0.0, 0.0 );\n    \n    triangles[1].a = verts[1]; \n    triangles[1].aUV = vec2(1.0,0.0);\n    triangles[1].b = verts[3]; \n    triangles[1].bUV = vec2(1.0,1.0);\n    triangles[1].c = verts[2]; \n    triangles[1].cUV = vec2(0.0,1.0);\n    triangles[1].n = vec3( -1.0, 0.0, 0.0 );\n}\n\n\nfloat cross2d( vec2 a, vec2 b )\n{\n    return a.x*b.y - a.y*b.x;\n}\n\nvec3 lig = normalize( vec3( 0.3,0.7,0.5) );\n\nvec3 pixelShader( in vec3 nor, in vec2 uv, in float z, in bool material )\n{\n    vec3 normal = material ? nor : -nor;\n    float dif = clamp( dot( normal, lig ), 0.0, 1.0 );\n    float brdf = 0.4 + 0.8*dif;\n    //brdf *= 6.0 * exp( -0.5*abs(z) );\n\t\t\t\n\tvec3 mate = material\n        ? texture( iChannel0, uv ).xyz\n        : texture( iChannel1, uv ).xyz;\n\t\n    vec3 col = brdf * mate;\t\n    \n    vec3 V = vec3(0.0, 0.0, -1.0);\n\tvec3 R = reflect(lig, normal);\n    vec3 H = normalize(lig + V);\n    float NdotH = dot(normal, H);\n    \n    // phong specular\n    float k = pow(max(0.0, dot(R,V)), 2.0);\n    return col + k;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 px = (-iResolution.xy + 2.0 * fragCoord) / iResolution.y;\n    float animation = sin(0.3 * iTime);\n\tmat4 mdv = setTranslation( 0.0, 0.5, -5.0 ) * \n\t\t       setRotation( 0.0, px.y * animation, 0.0 ) * \n\t\t       setRotation( 0.0, 3.1 * animation, 0.0 );\n\n    createCube();\n\n    vec3 color = vec3( 0.0, 0.0, 0.0 );\n\n    // clear zbuffer\n    float mindist = -1000000.0;\n\n    // render 2 triangles\n    for( int i=0; i<2; i++ )\n    {\n        // transform to eye space\n        vec3 ep0 = (mdv * vec4(triangles[i].a, 1.0)).xyz;\n        vec3 ep1 = (mdv * vec4(triangles[i].b, 1.0)).xyz;\n        vec3 ep2 = (mdv * vec4(triangles[i].c, 1.0)).xyz;\n        vec3 nor = (mdv * vec4(triangles[i].n, 0.0)).xyz;\n\n        // transform to clip space\n        float w0 = 1.0 / ep0.z;\n        float w1 = 1.0 / ep1.z;\n        float w2 = 1.0 / ep2.z;\n\n        vec2 cp0 = 2.0 * ep0.xy * -w0;\n        vec2 cp1 = 2.0 * ep1.xy * -w1;\n        vec2 cp2 = 2.0 * ep2.xy * -w2;\n\n        // fetch vertex attributes, and divide by z\n        vec2 u0 = triangles[i].aUV * w0;\n        vec2 u1 = triangles[i].bUV * w1;\n        vec2 u2 = triangles[i].cUV * w2;\n\n        //-----------------------------------\n        // rasterize\n        //-----------------------------------\n\n        // calculate areas for subtriangles\n        vec3 di = vec3( cross2d( cp1 - cp0, px - cp0 ), \n\t\t\t\t\t    cross2d( cp2 - cp1, px - cp1 ), \n\t\t\t\t\t    cross2d( cp0 - cp2, px - cp2 ) );\n\t\t\n        bool frontFaced = all(greaterThan(di,vec3(0.0)));\n        bool backFaced = all(lessThan(di,vec3(0.0)));\n        \n        if (!frontFaced && !backFaced)\n            continue;      \n        \n        // calc barycentric coordinates\n        vec3 ba = di.yzx / (di.x + di.y + di.z);\n\n        // barycentric interpolation of attributes and 1/z\n        float iz = ba.x*w0 + ba.y*w1 + ba.z*w2;\n        vec2  uv = ba.x*u0 + ba.y*u1 + ba.z*u2;\n\n        // recover interpolated attributes\n        mindist = 1.0 / iz;\n        uv *= mindist;\n        \n        // perform lighting/shading\n        color = pixelShader( nor, uv, mindist, frontFaced );\n    }\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlyBDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 47, 47, 404], [406, 406, 456, 456, 572], [699, 699, 724, 724, 1419], [1422, 1422, 1455, 1455, 1487], [1534, 1534, 1609, 1609, 2145], [2147, 2147, 2204, 2204, 4321]], "test": "error"}
{"id": "tlyBWz", "name": "two balls neo version", "author": "gourki", "description": "deux boules qui se traversent", "tags": ["raymarching", "balls"], "likes": 1, "viewed": 190, "published": "Public API", "date": "1614164650", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n//thanks inigo quilez !\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p)-s;\n}\n\n\n\n\n        \nvec2 opSmoothUnionVec2( vec2 d1, vec2 d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n    }\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n \nvec2 minVec2(vec2 d1, vec2 d2)\n{\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\n// ****** MAP ******\nvec2 map(vec3 pos)\n{\n\n    vec2 s1 = vec2(sdSphere(pos+vec3(2.*sin(2.*iTime),.0,2.*cos(2.*iTime)), 1.0), 0.0);\n    vec2 s2 = vec2(sdSphere(pos+vec3(-2.*sin(iTime),.0,-2.*cos(iTime)), 1.0), 1.0);\n    vec2 ground = vec2(pos.z+1.0,2.0);\n    \n    vec2 world = opSmoothUnionVec2(s1, s2,0.5);\n    world = opSmoothUnionVec2(ground, world,0.5);\n   \n    return world;\n}\n\nfloat shadow( in vec3 ro, in vec3 rd, float mint, float maxt )\n{\n    for( float t=mint; t<maxt; )\n    {\n        vec2 h = map(ro + rd*t);\n        if( h.x<0.001 )\n            return 0.0;\n        t += h.x;\n    }\n    return 1.0;\n}\n\nvec3 Getnormal(vec3 pos)\n{\n    float v = map(pos).x;\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n        map(pos+e.xyy).x,\n        map(pos+e.yxy).x,\n        map(pos+e.yyx).x) - v);\n}\n\n\nvec2 CastRay(vec3 ro, vec3 rd)\n{\n    float c = 0.0; // si y a contact, \"c\" va stocker sa distance\n    \n    for(int i=0; i<64; i++)\n    {\n        vec2 ray = map(ro + rd * c); \n    \n        if(ray.x < (0.0001*c))\n        {\n            return vec2(c, ray.y);\n        }\n        \n        c += ray.x;\n    }\n    \n    // si la marche est trop longue, ca renvoit -1.0\n    return vec2(-1.0, 0.0);\n}\n\nvec3 render(vec3 ro, vec3 rd) // ray origin & ray direction)\n{\n    // *** RAYMARCHING\n    vec2 contact = CastRay(ro, rd); // ici on ajoutera le raymarching\n    // simulation de raymarching\n    \n    vec3 nor = Getnormal(ro + rd * contact.x);\n    \n    vec3 lightPos = vec3(0.,2.,2.);\n    lightPos.xz *=rot(0.33*iTime);\n    vec3 lightTar = vec3(0.,0.,0.);\n    vec3 lightDir = normalize(lightTar - lightPos);\n    \n    float shade = shadow(lightPos, lightDir,0.0,1.0);\n    \n    float lambert = dot(nor,lightDir);\n    float blinn = pow(lambert,16.0);\n    float toon = step(lambert, 0.5);\n    // *** Traitement du contact\n    vec3 col = vec3(0.0);\n    \n    if(contact.x == -1.0)\n    {\n        // y a pas de contact\n        col = vec3(mix(vec3(0.0, 1.0, 1.0), vec3(0.0, 0.0, 1.0), abs(rd.y)));\n    }\n    else\n    {\n        if(contact.y == 0.0)\n        {\n            col = vec3(1.0, 0.0, 0.0);\n        }\n        else\n        {\n            col = vec3(0.0, 1.0, 0.0);\n        }\n        //col *= lambert*(1.-contact.y);\n        //col -= nor;\n         \n        col *= shade*(lambert*.8)+.2;\n        //col += blinn*.8;\n        //col*=(1.0-toon)*.5+.5;\n        \n        float fresnel = pow((dot(nor, rd)+.9)*.8,1.)*2.0;\n       \n        col += fresnel;\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Centrer camera\n    vec2 uv = 2.0 * fragCoord/iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // Camera\n    vec3 cameraPos = vec3(0.0, 0.0, 5.0);\n    vec3 cameraTar = vec3(0.0, 0.0, 0.0);\n    \n    // view Direction / Ray Direction\n    vec3 forward = normalize(cameraTar - cameraPos);\n    vec3 right = normalize(cross(vec3(0.0, -1.0, 0.0), forward));\n    vec3 up = normalize(cross(right, forward));\n    vec3 viewDir = normalize(uv.x * right + uv.y * up + forward * 2.0);\n    \n    // Time varying pixel color\n    vec3 col = vec3(uv.x, uv.y, 0.0);\n\n    col = render(cameraPos, viewDir);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlyBWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 75, 108, 108, 134], [148, 148, 201, 201, 309], [311, 311, 383, 383, 426], [429, 429, 461, 461, 499], [501, 522, 542, 542, 881], [883, 883, 947, 947, 1109], [1111, 1111, 1137, 1137, 1307], [1310, 1310, 1342, 1342, 1698], [1700, 1700, 1762, 1785, 2965], [2967, 2967, 3024, 3046, 3700]], "test": "valid"}
{"id": "tlycDK", "name": "Trilinear Surface Intersect", "author": "oneshade", "description": "Analytic intersection with the zero isosurface of a trilinear interpolation. It involves solving a cubic.", "tags": ["raytracing", "ray", "intersection", "cubic", "trilinear", "analytic", "interpolation"], "likes": 6, "viewed": 88, "published": "Public", "date": "1614499058", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nI finally have a working ray vs. trilinear surface intersector!\n\na, b, c, d, e, f, g, and h correspond to the corners of a cube through which they\nare trilinearly interpolated. ASCII figure showing the orientation:\n\n c        d\n |\\‾‾‾‾‾‾‾|\\\n | \\        \\\n |  \\g    |  \\h\n |   |‾‾‾‾‾‾‾‾|\na|- -| - -|b  |\n  \\  |     \\  |\n   \\ |      \\ |\n    \\|_______\\|\n    e         f\n\na is at (0, 0, 0) and h is at (1, 1, 1).\n*/\n\n// Cubic solver\nvec4 solveCubic(in float a, in float b, in float c, in float d) {\n    float aa = a * a, bb = b * b;\n\n    float denom = 3.0 * aa;\n    float inflect = b / (3.0 * a);\n\n    float p = c / a - bb / denom;\n    float q = bb * b / (13.5 * aa * a) - b * c / denom + d / a;\n    float ppp = p * p * p, qq = q * q;\n\n    float p2 = abs(p);\n    float v1 = 1.5 / p * q;\n\n    vec4 roots = vec4(0.0, 0.0, 0.0, 1.0);\n    if (qq * 0.25 + ppp / 27.0 > 0.0) {\n        float v2 = v1 * sqrt(3.0 / p2);\n        if (p < 0.0) roots[0] = sign(q) * cosh(acosh(v2 * -sign(q)) / 3.0);\n        else roots[0] = sinh(asinh(v2) / 3.0);\n        roots[0] = -2.0 * sqrt(p2 / 3.0) * roots[0] - inflect;\n    }\n\n    else {\n        float ac = acos(v1 * sqrt(-3.0 / p)) / 3.0; // 0π/3,       2π/3,               4π/3\n        roots = vec4(2.0 * sqrt(-p / 3.0) * cos(vec3(ac, ac - 2.09439510239, ac - 4.18879020479)) - inflect, 3.0);\n    }\n\n    return roots;\n}\n\n// mla's suggestion to reverse the coefficients and reciprocate the results\n// Better at handling extreme cases and seems to work fine here\nvec4 solveCubic2(in float a, in float b, in float c, in float d) {\n    vec4 roots = solveCubic(d, c, b, a);\n    roots[0] = 1.0 / roots[0];\n    if (roots[3] > 1.0) roots.yz = 1.0 / roots.yz;\n    return roots;\n}\n\n/*\n// Old trilinear surface intersection and normal\nvec4 IntersectTrilinearSurf(in vec3 ro, in vec3 rd, in float a, in float b, in float c, in float d, in float e, in float f, in float g, in float h) {\n    float x = ro.x, y = ro.y, z = ro.z;\n    float u = rd.x, v = rd.y, w = rd.z;\n\n    // Basically three nested linear interpolations expanded and regrouped\n    float coeff1 = -a * u * v * w + b * u * v * w + c * u * v * w - d * u * v * w + e * u * v * w - f * u * v * w - g * u * v * w + h * u * v * w;\n    float coeff2 = a * u * w + a * v * w + a * u * v - a * x * v * w - a * u * y * w - a * u * v * z - b * u * w - b * u * v + b * x * v * w + b * u * y * w + b * u * v * z - c * v * w - c * u * v + c * x * v * w + c * u * y * w + c * u * v * z + d * u * v - d * x * v * w - d * u * y * w - d * u * v * z - e * u * w - e * v * w + e * x * v * w + e * u * y * w + e * u * v * z + f * u * w - f * x * v * w - f * u * y * w - f * u * v * z + g * v * w - g * x * v * w - g * u * y * w - g * u * v * z + h * x * v * w + h * u * y * w + h * u * v * z;\n    float coeff3 = -a * w - a * u + a * x * w + a * u * z - a * v + a * y * w + a * v * z + a * x * v + a * u * y - a * x * y * w - a * x * v * z - a * u * y * z + b * u - b * x * w - b * u * z - b * x * v - b * u * y + b * x * y * w + b * x * v * z + b * u * y * z + c * v - c * y * w - c * v * z - c * x * v - c * u * y + c * x * y * w + c * x * v * z + c * u * y * z + d * x * v + d * u * y - d * x * y * w - d * x * v * z - d * u * y * z + e * w - e * x * w - e * u * z - e * y * w - e * v * z + e * x * y * w + e * x * v * z + e * u * y * z + f * x * w + f * u * z - f * x * y * w - f * x * v * z - f * u * y * z + g * y * w + g * v * z - g * x * y * w - g * x * v * z - g * u * y * z + h * x * y * w + h * x * v * z + h * u * y * z;\n    float coeff4 = a - a * z - a * x + a * x * z - a * y + a * y * z + a * x * y - a * x * y * z + b * x - b * x * z - b * x * y + b * x * y * z + c * y - c * y * z - c * x * y + c * x * y * z + d * x * y - d * x * y * z + e * z - e * x * z - e * y * z + e * x * y * z + f * x * z - f * x * y * z + g * y * z - g * x * y * z + h * x * y * z;\n\n    return solveCubic2(coeff1, coeff2, coeff3, coeff4);\n}\n\n// Normalized partial derivatives with respect to x, y, and z of:\n// f(x, y, z) = a - az - ax + axz - ay + ayz + axy - axyz + bx - bxz - bxy + bxyz + cy - cyz - cxy + cxyz + dxy - dxyz + ez - exz - eyz + exyz + fxz - fxyz + gyz - gxyz + hxyz\nvec3 getTrilinearSurfNormal(in vec3 p, in float a, in float b, in float c, in float d, in float e, in float f, in float g, in float h) {\n    float x = p.x, y = p.y, z = p.z;\n\n    float pdx = -a + a * z + a * y - a * y * z + b - b * z - b * y + b * y * z - c * y + c * y * z + d * y - d * y * z - e * z + e * y * z + f * z - f * y * z - g * y * z + h * y * z;\n    float pdy = -a + a * z + a * x - a * x * z - b * x + b * x * z + c - c * z - c * x + c * x * z + d * x - d * x * z - e * z + e * x * z - f * x * z + g * z - g * x * z + h * x * z;\n    float pdz = -a + a * x + a * y - a * x * y - b * x + b * x * y - c * y + c * x * y - d * x * y + e - e * x - e * y + e * x * y + f * x - f * x * y + g * y - g * x * y + h * x * y;\n\n    return normalize(vec3(pdx, pdy, pdz));\n}\n*/\n\n// Simplified trilinear surface intersection and normal\nvec4 IntersectTrilinearSurf(in vec3 ro, in vec3 rd, in float a, in float b, in float c, in float d, in float e, in float f, in float g, in float h) {\n    float x = ro.x, y = ro.y, z = ro.z;\n    float u = rd.x, v = rd.y, w = rd.z;\n\n    // Reused values (reusing themselves too :D)\n    float ba = b - a, ca = c - a, ea = e - a;\n    float q = ba + c - d + e - f - g + h;\n    float dbac = d - ba - c, fbae = f - ba - e, gcae = g - ca - e;\n    float xy = x * y, uv = u * v;\n    float xvuy = x * v + u * y;\n\n    // Coefficients of the cubic intersection function\n    float coeff1 = q * uv * w;\n    float coeff2 = dbac * uv + (fbae * u + gcae * v) * w + (xvuy * w + uv * z) * q;\n    float coeff3 = ba * u + ca * v + ea * w + xvuy * dbac + (x * w + u * z) * fbae + (y * w + v * z) * gcae + (xy * w + xvuy * z) * q;\n    float coeff4 = a + ba * x + ca * y + ea * z + dbac * xy + (fbae * x + gcae * y) * z + q * xy * z;\n\n    return solveCubic2(coeff1, coeff2, coeff3, coeff4);\n}\n\n/*\nNormalized partial derivatives with respect to x, y, and z of:\nf(x, y, z) = a - az - ax + axz - ay + ayz + axy - axyz + bx - bxz - bxy + bxyz + cy - cyz - cxy + cxyz + dxy - dxyz + ez - exz - eyz + exyz + fxz - fxyz + gyz - gxyz + hxyz\n*/\nvec3 getTrilinearSurfNormal(in vec3 p, in float a, in float b, in float c, in float d, in float e, in float f, in float g, in float h) {\n    float x = p.x, y = p.y, z = p.z;\n\n    float ba = b - a, ca = c - a;\n    float q = ba + c - d + e - f - g + h, qx = q * x;\n    float dbac = d - ba - c, fbae = f - ba - e, gcae = g - ca - e;\n\n    float dx = ba + dbac * y + (fbae + q * y) * z;\n    float dy = ca + dbac * x + (gcae + qx) * z;\n    float dz = e - a + fbae * x + (gcae + qx) * y;\n\n    return normalize(vec3(dx, dy, dz));\n}\n\n// To see only the unit cube, change the return statement to:\n// return t > 0.0 && all(lessThan(abs(p - 0.5), vec3(0.5)));\n// You may want to bring the ray origin closer to the origin though.\nbool intersectIsValid(in vec3 p, in float t) {\n    return t > 0.0 && all(lessThan(abs(p - 0.5), vec3(2.0)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenCenter = 0.5 * iResolution.xy;\n    float time = iTime;\n\n    vec2 mouse = iMouse.z > 0.0 ? (iMouse.xy - screenCenter) / iResolution.y * 3.14 : vec2(-0.85, -0.5);\n    vec2 uv = (fragCoord - screenCenter) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 8.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    ro += 0.5;\n\n    // Isovalues\n    float a = sin(time * 0.5) * 2.0;\n    float b = -cos(time);\n    float c = cos(time * 1.25);\n    float d = sin(time * 2.0) * 0.5;\n    float e = cos(time * 0.5) * 1.5;\n    float f = -sin(time * 1.5) * 0.25;\n    float g = sin(time);\n    float h = cos(time) * 0.75;\n\n    vec4 intersect = IntersectTrilinearSurf(ro, rd, a, b, c, d, e, f, g, h);\n    int numIntersects = int(intersect[3]);\n\n    // Find closest valid intersection\n    vec3 hitPos;\n    float tMin = 1000000.0;\n    bool intersecting = false;\n    for (int i=0; i < numIntersects; i++) {\n        vec3 posCandid = ro + rd * intersect[i];\n        float tCandid = intersect[i];\n        if (intersectIsValid(posCandid, tCandid) && tCandid < tMin) {\n            hitPos = posCandid;\n            tMin = tCandid;\n            intersecting = true;\n        }\n    }\n\n    if (intersecting) {\n        vec3 n = getTrilinearSurfNormal(hitPos, a, b, c, d, e, f, g, h);\n        fragColor = vec4(abs(n), 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlycDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[446, 462, 527, 527, 1380], [1382, 1522, 1588, 1588, 1731], [4944, 5000, 5149, 5149, 5967], [5969, 6211, 6347, 6347, 6734], [6736, 6928, 6974, 6974, 7038], [7040, 7040, 7095, 7095, 8706]], "test": "valid"}
{"id": "tlyfRm", "name": "sudden", "author": "tusu11", "description": "my first shader", "tags": ["raymarching"], "likes": 0, "viewed": 24, "published": "Public", "date": "1614072703", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdBox(vec3 p, float s){\n\tp = abs(p) - s;\n\treturn max(max(p.x, p.y), p.z) ;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 p = ( fragCoord.xy * 2. - iResolution.xy ) / min(iResolution.x, iResolution.y);\n\n\tvec3 cameraPos = vec3(sin(iTime), sin(iTime), -5.);\n\tfloat screenZ = 2.5*iTime*0.001*cos(iTime*2.);\n\tvec3 rayDirection = normalize(vec3(p, screenZ));\n\n\tfloat depth = 0.;\n\tfloat accum =0.;\n\tvec3 col = vec3(mod(abs(p.xy/.3), .5), 0.);\n\n\tfor (int i=0; i<99; i++){\n\t\tvec3 rayPos = cameraPos + rayDirection * depth;\n\t\trayPos = mod(rayPos-2., 4.);\n\t\tfloat dist = max(abs(sdBox(rayPos, 0.5)), 0.02);\n\t\tif (dist < 0.002 || depth > 80.){\n\t\t\tcol = vec3(0., 0., fract(dist*3000.));\n\t\t\tbreak;\n\t\t}\n\n\t\tdepth += dist * 0.5;\n\t\taccum += 0.005;\n\t}\n\n\tfragColor = vec4(0) + accum * (1. - exp(-0.001*depth*depth));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlyfRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 82], [83, 83, 140, 140, 825]], "test": "valid"}
{"id": "tssfz7", "name": "Cross SDF fractal", "author": "bradjamesgrant", "description": "Same setup as https://www.shadertoy.com/view/tsXBzS. Starts with 2 rectangles (1 rotating to try break up continuity). Added transparency to raymarching and also time dilution to create tempo. Colour changes depending on marches rather than dist to center", "tags": ["transparencyraymarching"], "likes": 5, "viewed": 92, "published": "Public", "date": "1612681243", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 palette(float d){\n    d = d/50.;\n    return mix(vec3(.0,.2,.2),vec3(.8,.2,.5),1.-d)*3.5;\n}\nfloat rnd(vec2 p){\n\treturn fract(sin(p.x+100. + p.y*6574.)*45233.);\n}\n\nvec2 rotate(vec2 p, float a){\n\tfloat c = cos(a);\n    float s = sin(a);\n    return mat2(c,s,-s,c)*p;\n}\n\nfloat box(vec3 p, vec3 s){\n\tp= abs(p)-s;\n    return max(p.x,max(p.y,p.z));\n}\nfloat map(vec3 p){\n    float t=iTime+385.;\n    //CHANGE TEMPO HERE\n     //t = t*1.59;\n    t = t*1.;\n    float tfract = fract(t);\n    tfract*=tfract;\n    t = floor(t) + tfract;\n    t = t*0.2;\n    for( int i = 0; i<13; ++i){\n        \n        p.xz =rotate(p.xz,t);\n        p.xy =rotate(p.xy,t*1.89);\n        p.xz = abs(p.xz);\n        p.xz-=1.0;\n    }\n    vec3 q = p;\n    q.xy = rotate(p.xy,t*1000.*.02);//*p.x*30.; add artifacts\n    return min(box(p,vec3(2.,.5,.3)),box(q,vec3(.5,2.,.3)));\n}\n\n\n\n\nvec3 castRay (vec3 ro, vec3 rd){\n\tfloat t=0.;\n    vec3 col = vec3(0.);\n    int i = 0;\n    for(i = 0; i<50; i++){\n    \tvec3 p = ro+t*rd;\n        float d = map(p)*.5;\n        if(d>200.)\n            break;\n        if(d<0.01){\n            d = 0.1;\n        }\n        \n        t+=d;\n        col+=palette(float(i))*0.005/(0.2+abs(d));\n        //col+=palette(length(p))*0.005/(0.2+abs(d));\n       \n    }\n    return col;\n        \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    vec2 uv = (fragCoord-(iResolution.xy/2.))/iResolution.y;\n\tvec3 ro = vec3(0.,0.,-40.);\n\tvec3 cf = normalize(-ro);\n    vec3 cs = normalize(cross(cf,vec3(0.,1.,0.)));\n    vec3 cu = normalize(cross(cf,cs));\n    \n    vec3 uuv = ro+ cs*uv.x + cu*uv.y;\n\n   \tvec3 rd = uuv-ro;\n    \n    rd = normalize(vec3(-uv,1.));\n    \n    vec3 col = castRay(ro,rd);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "MlsXz2", "previewfilepath": "https://soundcloud.com/particlehouse/mai-tai", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/particlehouse/mai-tai", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tssfz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 95], [96, 96, 114, 114, 165], [167, 167, 196, 196, 268], [270, 270, 296, 296, 346], [347, 347, 365, 365, 835], [840, 840, 872, 872, 1262], [1264, 1264, 1321, 1321, 1717]], "test": "valid"}
{"id": "tt3BDH", "name": "Shifting Landscapes", "author": "icylavah", "description": "Shifting landscapes using simplex noise and a color palette.\nVideo at https://twitter.com/icylavah/status/1358086037461958663", "tags": ["noise", "random"], "likes": 5, "viewed": 230, "published": "Public API", "date": "1612626449", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \t<www.shadertoy.com/view/XsX3zB>\n//\tnoise functions by Nikita Miropolskiy\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n    \n\t/*vec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;*/\n    \n    return fract(j*vec3(64,8,512)) -.5;\n}\n\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\nfloat snoise(vec3 p) {\n\n\tvec3 s = floor(p + dot(p, vec3(F3)));\n\tvec3 x = p - s + dot(s, vec3(G3));\n\t \n\tvec3 e = step(vec3(0.0), x - x.yzx);\n\tvec3 i1 = e*(1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\tvec3 x1 = x - i1 + G3;\n\tvec3 x2 = x - i2 + 2.0*G3;\n\tvec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\tvec4 w, d;\n\t \n\tw.x = dot(x, x);\n\tw.y = dot(x1, x1);\n\tw.z = dot(x2, x2);\n\tw.w = dot(x3, x3);\n\t \n\tw = max(0.6 - w, 0.0);\n\t \n\td.x = dot(random3(s), x);\n\td.y = dot(random3(s + i1), x1);\n\td.z = dot(random3(s + i2), x2);\n\td.w = dot(random3(s + 1.0), x3);\n\t \n\tw *= w;\n\tw *= w;\n\td *= w;\n\t \n\treturn dot(d, vec4(52.0));\n}\n\nfloat snoiseFractal(vec3 m) {\n\treturn   0.5333333* snoise(m)\n\t\t\t\t+0.2666667* snoise(2.0*m)\n\t\t\t\t+0.1333333* snoise(4.0*m)\n\t\t\t\t+0.0666667* snoise(8.0*m);\n}\n\n// ------\n\n#define fast false // Change to true for faster algorithm with AA\nconst int compareDistance = 4; // >= 1\n\nconst int r2 = compareDistance * compareDistance;\nconst int steps = 6;\nconst vec3 colors[steps] = vec3[](vec3(0.133, 0.223, 0.345), vec3(0.270, 0.458, 0.690), vec3(0.458, 0.725, 0.745), vec3(0.815, 0.839, 0.709), vec3(0.976, 0.709, 0.674), vec3(0.933, 0.462, 0.454));\n\nint getPixelStepi(vec2 pixel, vec2 dimensions, float t) {\n    return min(max(int(((snoiseFractal(vec3(pixel / dimensions.y, t * 0.05)) + 0.5)) * float(steps)), 0), steps - 1);\n}\n\nfloat getPixelStepf(vec2 pixel, vec2 dimensions, float t) {\n    return ((snoiseFractal(vec3(pixel / dimensions.y, t * 0.05)) + 0.5)) * float(steps);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(fast) {\n        float step = getPixelStepf(fragCoord, iResolution.xy, iTime);\n        fragColor = vec4(colors[int(step)],1) * smoothstep(2.,4., abs(fract(step+.5)-.5) / fwidth(step) ) ;\n    } else {\n        int step = getPixelStepi(fragCoord.xy, iResolution.xy, iTime) - 0;\n\n        for (int y = -compareDistance; y <= compareDistance; y++) {\n            for (int x = -compareDistance; x <= compareDistance; x++) {\n                if (x * x + y * y > r2) continue;\n                if (getPixelStepi(fragCoord.xy + vec2(x, y), iResolution.xy, iTime) != step) {\n                    fragColor = vec4(vec3(0.0), 1.0);\n                    return;\n                }\n            }\n        }\n\n        fragColor = vec4(colors[int(step)], 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt3BDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 151, 173, 173, 400], [460, 460, 482, 482, 1062], [1064, 1064, 1093, 1093, 1217], [1327, 1605, 1662, 1662, 1782], [1784, 1784, 1843, 1843, 1934], [1936, 1936, 1993, 1993, 2743]], "test": "valid"}
{"id": "tt3BR2", "name": "Wave sim 4 points", "author": "Kuba_S", "description": "weave interference", "tags": ["waves", "physics"], "likes": 1, "viewed": 43, "published": "Public", "date": "1613055777", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Two sources of waves\n//Points A and B\n//all values have to have a decimal point (float)\n\n//point A\nconst float aX = 0.8;   //  X value of point A\nconst float aY = 0.8;    //  Y value of point A\n\n//point B\nconst float bX = -0.3;  //  X value of point B\nconst float bY = 0.0;    //  Y value of point B\n\nconst float cX = -0.8;  //  X value of point B\nconst float cY = -0.8; \n\nconst float dX = 0.3;  //  X value of point B\nconst float dY = 0.0; \n\n//wave properties\nconst float speed = 10.0;    //  how quickly waves propagate forwards\nconst float wavelength = 0.3;//  wavelength \n// ALL VALUES HAVE TO HAVE A DECIMAL POINT!!!!!\n\n// red = peak\n// green = trough\n\n\nfloat getDis(float x, float y,float xA,float yA){\n    return pow(\n    (pow((x-xA),2.)+pow((y-yA),2.))\n    ,0.5);\n    }\n    \nfloat getHeight(float x, float y,float xA,float yA,float wl,float t){\n    return sin((wl*t-6.28318530718*(getDis(x,y,xA,yA)/wl)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n \n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float t = iTime*speed;\n    float col = ((\n    ((\n    getHeight(uv.x,uv.y,aX,aY,wavelength,t)+\n    getHeight(uv.x,uv.y,bX,bY,wavelength,t)+\n    getHeight(uv.x,uv.y,cX,cY,wavelength,t)+\n    getHeight(uv.x,uv.y,dX,dY,wavelength,t)\n    +2.)/4.) // change from range -2 - 2 to range 0 - 1\n    \n    ));\n\n    float red;\n    float grn;\n    if(col > 0.5){\n        grn = 2.0 - (2.0 * col);\n        red = 1.0;\n    }\n    if(col <= 0.5){\n        grn = 1.0;\n        red = (2.0*col);\n    }\n    fragColor = vec4(red,grn,0.0, 1.0);        \n    \n    if(getDis(uv.x,uv.y,aX,aY)<0.02){\n        fragColor = vec4(1.,0.,1., 1.0);\n    }\n    if(getDis(uv.x,uv.y,bX,bY)<0.02){\n        fragColor = vec4(1.,0.,1., 1.0);\n    }\n    if(getDis(uv.x,uv.y,cX,cY)<0.02){\n        fragColor = vec4(1.,0.,1., 1.0);\n    }\n    if(getDis(uv.x,uv.y,dX,dY)<0.02){\n        fragColor = vec4(1.,0.,1., 1.0);\n    }\n    \n   \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt3BR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[627, 661, 710, 710, 779], [785, 785, 854, 854, 917], [919, 919, 976, 976, 1984]], "test": "valid"}
{"id": "tt3BWn", "name": "Missile Reticle Test!", "author": "Dutracgi", "description": "Doing some tests to understand how it works... links for more info below:\nhttps://medium.com/@OpenSeason/1946-germany-has-been-defeated-and-its-military-technology-put-under-the-microscope-the-west-e60b82926b40\n", "tags": ["rocket", "reticle", "gun", "missile", "segments", "war", "guidance"], "likes": 1, "viewed": 164, "published": "Public API", "date": "1612491911", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Thanks to https://www.shadertoy.com/view/4tl3Dj for the stripes/sections!\n\nfloat circle(vec2 uv, vec2 off, float r){\n    float cir = pow(uv.x-off.x,2.) + pow(uv.y-off.y,2.);\n    return step(cir,pow(r,2.));\n}\nfloat counter =0.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - vec2(0.5,0.5);\n    //Aspect ratio correction\n    uv.x *= iResolution.x/iResolution.y;\n      \n    //Calculate the angle from the center + offset\n    uv+=vec2(0.3,0.);\n    vec2 uvo = uv + 0.1*vec2(cos(0.5*iTime),sin(0.5*iTime));\n    float angle = atan(uvo.y,uvo.x)+(2.*iTime);\n    \n    //8 strips representing the offset reticle.\n    vec3 intensity = vec3(step(0.01,sin(angle*8.0)) * circle(uvo,vec2(0),0.5));\n    \n    //Target position -> fixed\n    vec2 uvx = vec2(0.0);\n    \n    //Draw target\n    float cx = circle(uv,uvx,0.05);\n    intensity+= vec3(cx,-cx,-cx);\n    \n    //How to send the target intersection to my scope shader -> target over black strip = hit ?\n    \n    //if(hit) square wave = 1.0 else square wave = 0.0\n    \n    //https://www.shadertoy.com/view/wldfWr <- This one\n    \n    \n    //Set the final color\n    fragColor = vec4(intensity, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt3BWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 77, 118, 118, 209], [229, 229, 286, 286, 1195]], "test": "valid"}
{"id": "tt3Bz2", "name": "Clooud City", "author": "eiffie", "description": "reupload - Clooooouds!", "tags": ["clooouds"], "likes": 35, "viewed": 1590, "published": "Public API", "date": "1613058766", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//cloud city by eiffie\n#define size iResolution \n#define time iTime \n \nfloat focalDistance=1.0,aperture=0.01,shadowCone=0.3; \n \nfloat Rect(in vec3 z, vec3 r){return max(abs(z.x)-r.x,max(abs(z.y)-r.y,abs(z.z)-r.z));} \n#define TAO 6.283 \nvoid Kaleido(inout vec2 v,float power){float a=floor(.5+atan(v.x,-v.y)*power/TAO)*TAO/power;v=cos(a)*v+sin(a)*vec2(v.y,-v.x);} \n \n// See http://www.iquilezles.org/www/articles/morenoise/morenoise.htm \nfloat hash(float n) {return fract(sin(n) * 4378.54533);} \nfloat noyz(vec3 x) { \n vec3 p=floor(x),j=fract(x); \n const float tw=7.0,tx=13.0; \n float n=p.x+p.y*tw+p.z*tx; \n float a=hash(n),b=hash(n+1.0),c=hash(n+tw),d=hash(n+tw+1.0); \n float e=hash(n+tx),f=hash(n+1.0+tx),g=hash(n+tw+tx),h=hash(n+1.0+tw+tx); \n vec3 u=j*j*(3.0-2.0*j); \n return mix(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,e+(f-e)*u.x+(g-e)*u.y+(e-f-g+h)*u.x*u.y,u.z); \n} \n \nfloat fbm(vec3 p) { \n float h=noyz(p); \n h+=0.5*noyz(p*=2.3); \n return h+0.25*noyz(p*2.3);\n} \n \nvec4 mcol=vec4(0.0); \nconst float scl=0.08; \n \nfloat DE(vec3 z0){ \n float dW=100.0,dD=100.0; \n float dC=fbm(z0*0.25+vec3(100.0))*0.5+sin(z0.y)*0.1+sin(z0.z*0.4)*0.1+min(z0.y*0.04+0.1,0.1); \n vec2 v=floor(vec2(z0.x,abs(z0.z))*0.5+0.5); \n z0.xz=clamp(z0.xz,-2.0,2.0)*2.0-z0.xz; \n float r=length(z0.xz); \n float dS=r-0.6; \n if(r<1.0){ \n  float shape=0.285-v.x*0.02;//0.21-0.36 \n  z0.y+=v.y*0.2; \n  vec3 z=z0*10.0; \n  dS=max(z0.y-2.5,r-max(0.11-z0.y*0.1,0.01)); \n  float y2=max(abs(abs(mod(z.y+0.5,2.0)-1.0)-0.5)-0.05,abs(z.y-7.1)-8.3); \n  float y=sin(clamp(floor(z.y)*shape,-0.4,3.4))*40.0; \n  Kaleido(z.xz,8.0+floor(y));\n  dW=Rect(z,vec3(0.9+y*0.1,22.0,0.9+y*0.1))*scl; \n  dD=max(z0.y-1.37,max(y2,r*10.0-1.75-sin(clamp((z.y-0.5)*shape,-0.05,3.49))*4.0))*scl; \n  dS=min(dS,min(dW,dD)); \n } \n dS=min(dS,dC); \n if(dS==dW)mcol+=vec4(0.8,0.9,0.9,1.0);//+a for reflection \n else if(dS==dD)mcol+=vec4(0.6,0.4,0.3,0.0); \n else if(dS==dC)mcol+=vec4(1.0,1.0,1.0,-1.0);//-a for clouds \n else mcol+=vec4(0.7+sin(z0.y*100.0)*0.3,1.0,0.8,0.0); \n return dS; \n} \n \nfloat pixelSize; \nfloat CircleOfConfusion(float t){//calculates the radius of the circle of confusion at length t \n return max(abs(focalDistance-t)*aperture,pixelSize*(1.0+t)); \n} \nmat3 lookat(vec3 fw,vec3 up){ \n fw=normalize(fw);vec3 rt=normalize(cross(fw,normalize(up)));return mat3(rt,cross(rt,fw),fw); \n} \nfloat linstep(float a, float b, float t){return clamp((t-a)/(b-a),0.,1.);}// i got this from knighty and/or darkbeam \n//random seed and generator \nfloat randSeed;\nfloat randStep(){//a simple pseudo random number generator based on iq's hash \n return  (0.8+0.2*fract(sin(++randSeed)*4375.54531)); \n} \n \nfloat FuzzyShadow(vec3 ro, vec3 rd, float coneGrad, float rCoC){ \n float t=rCoC*2.0,d=1.0,s=1.0; \n for(int i=0;i<6;i++){ \n  if(s<0.1)continue; \n  float r=rCoC+t*coneGrad;//radius of cone \n  d=DE(ro+rd*t)+r*0.4; \n  s*=linstep(-r,r,d); \n  t+=abs(d)*randStep(); \n } \n return clamp(s*0.75+0.25,0.0,1.0); \n} \n \nvoid mainImage(out vec4 O, in vec2 U) {\n randSeed=fract(sin(time+dot(U,vec2(9.123,13.431)))*473.719245);\n pixelSize=2.0/size.y; \n float tim=time*0.25; \n vec3 ro=vec3(cos(tim),sin(tim*0.7)*0.5+0.3,sin(tim))*(1.8+.5*sin(tim*.41)); \n vec3 rd=lookat(vec3(0.0,0.6,sin(tim*2.3))-ro,vec3(0.1,1.0,0.0))*normalize(vec3((2.0*U.xy-size.xy)/size.y,2.0)); \n vec3 L=normalize(vec3(0.5,0.75,-0.5)); \n vec4 col=vec4(0.0);//color accumulator \n float t=DE(ro)*randSeed*.8;//tep();//distance traveled \n ro+=rd*t; \n for(int i=0;i<72+min(iFrame,0);i++){//march loop \n  if(col.w>0.9 || t>20.0)continue;//bail if we hit a surface or go out of bounds \n  float rCoC=CircleOfConfusion(t);//calc the radius of CoC \n  float d=DE(ro); \n  float fClouds=max(0.0,-mcol.a); \n  if(d<max(rCoC,fClouds*0.5)){//if we are inside add its contribution \n   vec3 p=ro; \n   if(fClouds<0.1)p-=rd*abs(d-rCoC);//back up to border of CoC \n   vec2 v=vec2(rCoC*0.333,0.0);//use normal deltas based on CoC radius \n   vec3 N=normalize(vec3(-DE(p-v.xyy)+DE(p+v.xyy),-DE(p-v.yxy)+DE(p+v.yxy),-DE(p-v.yyx)+DE(p+v.yyx))); \n   if(N!=N)N=-rd; \n   mcol*=0.143; \n   vec3 scol; \n   float alpha; \n   if(fClouds>0.1){//clouds \n    float dn=clamp(0.5-d,0.0,1.0);dn=dn*2.0;dn*=dn;//density \n    alpha=(1.0-col.w)*dn; \n    scol=vec3(1.0)*(0.6+dn*dot(N,L)*0.4); \n    scol+=dn*max(0.0,dot(reflect(rd,N),L))*vec3(1.0,0.5,0.0); \n     \n   }else{ \n    scol=mcol.rgb*(0.2+0.4*(1.0+dot(N,L))); \n    scol+=0.5*pow(max(0.0,dot(reflect(rd,N),L)),32.0)*vec3(1.0,0.5,0.0); \n    if(d<rCoC*0.25 && mcol.a>0.9){//reflect the ray if we hit a bulb \"directly enough\" \n     rd=reflect(rd,N);d=-rCoC*0.25;ro=p;t+=1.0; \n    } \n    scol*=FuzzyShadow(p,L,shadowCone,rCoC); \n    alpha=(1.0-col.w)*linstep(-rCoC,rCoC,-d-0.5*rCoC);//calculate the mix like cloud density \n   } \n   col+=vec4(scol*alpha,alpha);//blend in the new color \n  } \n  mcol=vec4(0.0);//clear the color trap \n  d=abs(d+0.33*rCoC)*randStep();//add in noise to reduce banding and create fuzz \n  ro+=d*rd;//march \n  t+=d; \n }//mix in background color \n vec3 scol=vec3(0.4,0.5,0.6)+rd*0.05+pow(max(0.0,dot(rd,L)),100.0)*vec3(1.0,0.75,0.5); \n col.rgb+=scol*(1.0-clamp(col.w,0.0,1.0)); \n \n O = vec4(clamp(col.rgb,0.0,1.0),1.0); \n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt3Bz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 128, 158, 158, 215], [236, 236, 275, 275, 362], [366, 437, 458, 458, 493], [495, 495, 515, 515, 870], [874, 874, 893, 893, 966], [1017, 1017, 1035, 1035, 2013], [2035, 2035, 2068, 2131, 2196], [2198, 2198, 2227, 2227, 2325], [2327, 2327, 2368, 2368, 2401], [2401, 2490, 2507, 2568, 2625], [2629, 2629, 2693, 2693, 2931], [2935, 2935, 2974, 2974, 5138]], "test": "valid"}
{"id": "tt3fRj", "name": "[290 min char] Hyper swirls", "author": "public_int_i", "description": "quick min shader sketch", "tags": ["swirl", "projection", "4d", "sketch", "minimal", "min", "point"], "likes": 3, "viewed": 170, "published": "Public API", "date": "1613052084", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0, public domain, freeware\n\nvoid mainImage(out vec4 o, in vec2 u)\n{\n    vec2 c = (u*2.-iResolution.xy)/iResolution.y;//2d world coordinate\n    o -= o;\n    for (float i = 1.; i < 100.; i += .1) {\n        //4d point\n        vec4 p = cos(i*vec4(.87,.276,.587,1.1));\n        float a = iTime+length(p.zy);\n        p.zw *= mat2(cos(a),-sin(a),sin(a),cos(a));\n        \n        //4d to 3d projection\n        p.xyz /= p.w+2.;\n        \n        //additively draw points + 3d to 2d projection\n        p.z += 2.;\n        o += clamp(1./p.z-length(c-p.xy/p.z)*20.,0.,.1);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt3fRj.jpg", "access": "shaders20k", "license": "public-domain", "functions": [[0, 32, 71, 71, 568]], "test": "valid"}
{"id": "tt3fWH", "name": "Voronoi study (flat space)", "author": "sig", "description": "Simple voronoi using different \"flat space\" metrics.", "tags": ["geometric"], "likes": 1, "viewed": 53, "published": "Public", "date": "1612624358", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 point(int i) {\n    float r = 0.5 + 0.3 * sin(float((i * 123) % 9 + 4) * iTime * 0.05 + 0.5);\n    float a = float((i * 345) % 7 + 4) * iTime * 0.05 + r;\n    return r * vec2(cos(a), sin(float((i * 143) % 3 + 2) * a));\n}\n\nfloat switch_interval = 2.0;\nfloat dist(vec2 a, vec2 b) {\n    float T = mod(iTime, switch_interval * 6.) / switch_interval;\n    switch(int(T)) {\n    case 0: return abs(a.x-b.x) + abs(a.y-b.y); // 1-d \"manhattan\"\n    case 1:\n    case 2: \n    case 3: \n    case 4: return pow(pow(abs(a.x-b.x), T) + pow(abs(a.y-b.y), T), 1./T);\n    case 5: return max(abs(a.x-b.x), abs(a.y-b.y)); // inf-d \"\"\n    }\n}\n\nfloat BORDER_R = 0.01;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n    float min_d = 666.;\n    vec2 min_c = p;\n    float hilite = 0.;\n    float border = 0.;\n    for (int i = 0; i < 10; i++) {\n        vec2 c = point(i);\n        float d = dist(c, p);\n        hilite += d < 0.1 ? d : 0.0;\n        float dd = d - min_d;\n        if (dd < BORDER_R) {\n            if (dd < -BORDER_R) {\n                min_d = d;\n                min_c = c;\n                border = 0.0;\n            } else {\n                border = 1.0 - abs(dd) / BORDER_R;\n            }\n        }\n    }\n\n    vec3 col = 0.5 + hilite + 0.5*cos(iTime+min_c.xyx+vec3(0,2,4)) - border ;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt3fWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 222], [253, 253, 281, 281, 620], [645, 645, 702, 702, 1379]], "test": "error"}
{"id": "tt3fzH", "name": "Genuary 2021 – 06 – Triangle Sub", "author": "endymion", "description": "Genuary 2021 – 06 – Triangle Subdivision", "tags": ["fbm", "triangle", "subdivision", "genuary"], "likes": 2, "viewed": 61, "published": "Public", "date": "1612220208", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\n/**\n * Utils\n */\n\n// @src https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat dot2(in vec2 v) { return dot(v, v); }\nfloat ndot(in vec2 a, in vec2 b) { return a.x * b.x - a.y*b.y; }\n\nfloat random(in float seed) {\n    return fract(sin(seed)*1e4);\n}\n\nfloat random(in vec2 seed) {\n    return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nvec2 random2(vec2 seed) {\n    return fract(sin(vec2(dot(seed, vec2(127.1, 311.7)), dot(seed, vec2(269.5, 183.3)))) * 43758.5453);\n}\n\nfloat map(in float value, in float min1, in float max1, in float min2, in float max2) {\n    return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\n/**\n * Basic noise\n */\nfloat noise(vec2 p, float freq){\n    float unit = iResolution.x / freq;\n    vec2 ij = floor(p / unit);\n    vec2 xy = .5 * (1. - cos(PI * mod(p, unit) / unit));\n    float a = random((ij + vec2(0., 0.)));\n    float b = random((ij + vec2(1., 0.)));\n    float c = random((ij + vec2(0., 1.)));\n    float d = random((ij + vec2(1., 1.)));\n    float x1 = mix(a,b,xy.x);\n    float x2 = mix(c,d,xy.x);\n    return mix(x1,x2,xy.y);\n}\n\n/**\n * Simplex noise\n * @src https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n */\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat snoise(vec2 v){\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n/**\n* Fractional Brownian Motion\n* @src https://thebookofshaders.com/13/\n*/\nfloat fbm(in vec2 _st, in int octaves) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n    for (int i = 0; i < octaves; ++i) {\n        v += a * noise(_st, 2000. + abs(1000. * sin(iTime * 0.0009)));\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n/**\n * RGB to HSB\n * All components are in the range [0…1], including hue.\n * @src https://stackoverflow.com/a/17897228\n */\nvec3 rgb2hsb(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n \n/**\n * HSB to RGB\n * All components are in the range [0…1], including hue.\n * @src https://stackoverflow.com/a/17897228\n */\nvec3 hsb2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n/**\n * Triangle\n * @src https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n */\nfloat sdTriangle(in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2) {\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0 * clamp(dot(v0, e0) / dot(e0, e0), 0.0, 1.0);\n    vec2 pq1 = v1 - e1 * clamp(dot(v1, e1) / dot(e1, e1), 0.0, 1.0);\n    vec2 pq2 = v2 - e2 * clamp(dot(v2, e2) / dot(e2, e2), 0.0, 1.0);\n    float s = sign(e0.x * e2.y - e0.y * e2.x);\n    vec2 d = min(\n        min(\n            vec2(dot(pq0, pq0), s * (v0.x * e0.y - v0.y * e0.x)),\n            vec2(dot(pq1, pq1), s * (v1.x * e1.y - v1.y * e1.x))\n        ),\n        vec2(dot(pq2, pq2), s * (v2.x * e2.y - v2.y * e2.x))\n    );\n    \n    return -sqrt(d.x) * sign(d.y);\n}\n\n/**\n * Triangular subdivision\n */\nvoid getNewTrianglePoints(in float seed, inout vec2 a, inout vec2 b, inout vec2 c) {\n    float side = random(seed) * 3.;\n    float tilt = (0.5 + sin(snoise(vec2(iTime * 0.05))) * 0.5);\n    \n    if (side < 1.) {\n        a = mix(a, b, tilt);\n    } else if (side < 2.) {\n        b = mix(b, c, tilt);\n    } else {\n        c = mix(c, a, tilt);\n    }\n}\n\n/**\n * Subdivide triangle and give color and points back\n */\nvec3 getSubTriangle(in vec2 uv, in float seed, inout vec2 a, inout vec2 b, inout vec2 c, vec3 prevColor, vec3 newColor) {\n    getNewTrianglePoints(seed, a, b, c);\n    float d = sdTriangle(uv, a, b, c);\n    vec3 color = d >= 0. ? prevColor : newColor;\n    return color;\n}\n\n/**\n * FbM colors ftw\n */\n    \nvec3 getColor(in vec2 uv, in float f, in float t, in vec3 colorA, in vec3 colorB) {\n    vec3 color = hsb2rgb(mix(\n        vec3(1, 1 ,1 ),\n        mix(\n                vec3(colorA.x, colorA.y, 0.75 + 0.25 * sin(iTime * 0.1)),\n                vec3(colorB.x, colorB.y, 0.75 + 0.25 * sin(iTime * 0.1)),\n                t * 0.5 + uv.y * 0.5\n        ),\n        clamp(f * 4.0, 0.0, 1.0)\n    ));\n    \n    return (1.5 * f) * color;\n}\n\n/**\n * @main\n */\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float subs = floor(mod(iTime * 2., 30.));\n    \n    // Outer triangle bounds\n    vec2 a = vec2(0.1, 0.1);\n    vec2 b = vec2(0.1, 0.9);\n    vec2 c = vec2(0.9, 0.9);\n    \n    // FbM colors ftw\n    vec2 r = vec2(0.);\n    r.x = fbm(uv  + 0.10, 1);\n    float f = fbm(uv + r, 10);\n    f = f * 0.5 + fbm(vec2(f * 0.5), 2);\n    f = f * 0.5 + fbm(vec2(f * 0.5), 2);\n    float t = smoothstep(0., 1., abs(map(fract(iTime * .075), 0., 1., -1., 1.)));\n    \n    vec3 colors[10];\n    colors[0] = vec3(0.7, 0.725, 0.75);\n    colors[1] = vec3(0.995, 0.625, 0.75);\n    colors[2] = vec3(0.52, 0.725, 0.75);\n    colors[3] = vec3(0.7, 0.635, 0.75);\n    colors[4] = vec3(0.8, 0.725, 0.75);\n    \n    float d = sdTriangle(uv, a, b, c);\n    vec3 color = d >= 0. ? vec3(.2, .2, .2) : getColor(uv, f, t, colors[0], colors[1]);\n    \n    color = getSubTriangle(uv, 3., a, b, c, color, getColor(uv, f, t, colors[1], colors[2]));\n    color = getSubTriangle(uv, 8., a, b, c, color, getColor(uv, f, t, colors[2], colors[3]));\n    color = getSubTriangle(uv, 3., a, b, c, color, getColor(uv, f, t, colors[3], colors[4]));\n    color = getSubTriangle(uv, 4., a, b, c, color, getColor(uv, f, t, colors[4], colors[0]));\n    color = getSubTriangle(uv, 3., a, b, c, color, getColor(uv, f, t, colors[0], colors[1]));\n    color = getSubTriangle(uv, 6., a, b, c, color, getColor(uv, f, t, colors[1], colors[2]));\n    color = getSubTriangle(uv, 7., a, b, c, color, getColor(uv, f, t, colors[2], colors[3]));\n    color = getSubTriangle(uv, 8., a, b, c, color, getColor(uv, f, t, colors[3], colors[4]));\n\n    // Output\n    fragColor = vec4(color, 1.);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt3fzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 128, 151, 151, 171], [172, 172, 206, 206, 236], [238, 238, 267, 267, 302], [304, 304, 332, 332, 410], [412, 412, 437, 437, 543], [545, 545, 632, 632, 700], [702, 725, 757, 757, 1146], [1148, 1247, 1269, 1269, 1308], [1310, 1310, 1331, 1331, 2151], [2153, 2229, 2269, 2269, 2625], [2627, 2753, 2775, 2775, 3106], [3109, 3235, 3257, 3257, 3426], [3428, 3532, 3597, 3597, 4224], [4226, 4260, 4344, 4344, 4606], [4608, 4669, 4790, 4790, 4939], [4941, 4972, 5055, 5055, 5396], [5398, 5415, 5470, 5470, 7135]], "test": "valid"}
{"id": "ttcBD7", "name": "Weird fishy thing", "author": "jarble", "description": "This a modified version of [url=https://www.shadertoy.com/view/WtSfzd]3D_Gyroid_IceCave_LO[/url] with a distorted perspective.\n\nThe [code]RayMarch[/code] function is modified to change the camera's direction with each step.", "tags": ["gyroid"], "likes": 3, "viewed": 199, "published": "Public API", "date": "1612852373", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100. //WE PUT A DECIMEL HERE AND NOT ON MAX STEPS BECAUSE MAX STEPS IS AN INT\n\t\t\t\t\t  //WHEREAS MAX_DIST IS A FLOAT\n#define SURF_DIST 1e-3 //OUR \"SURFACE DIST\" IS WHEN THE SPHERE THAT SEEKS A HIT DURING OUR MARCH REACHES A SMALL SIZE, IN THIS CASE .01\n\t\t\t\t\t  //THEN WE HAVE A HIT\n\n#define S(a, b, t) smoothstep (a, b, t)\n\nmat2 Rot(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    \n    return mat2(c, -s, s, c); \n}\n\nfloat sdBox (vec3 p, vec3 s)\n{\n  p = abs(p)-s; \n    \n    return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdGyroid(vec3 p, float scale, float thickness, float bias) \n    {       \n        p *= scale;  //WE SCALE THE POSITION TO SCALE THE GYROID. BUT WHENEVER WE MULTIPLY THE POSITION, WE NEED TO DIVIDE IT BY WHAT WE MULTIPLIED. \n        \n        return abs(dot(sin(p), cos(p.zxy)) - bias)/scale-thickness; //WE DIVIDE IT HERE.  ALSO !! -- IF PLAYING WITH A 2D GYROID WE CAN\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   //CHANGE THE SHAPE BY MULTIPLYING THE POSITION'S SIN\n    }\n\nvec3 Transform(vec3 p)\n{\n    p.xy *= Rot(p.z*.18); \n    p.z -= iTime*1.0;\n    p.y -= .3; \n    \n    return p;\n}\n\nfloat GetDist(vec3 p) //THIS TAKES A POINT  IN 3D SPACE AS AN INPUT\n    {\n                  \n        p = Transform(p);  //THIS IS HOW WE'LL MOVE OUR STRUCTURE. WE DON'T WANT TO MOVE OUR CAMERA POSITION BECAUSE THE MORE WE MOVE\n        \t\t\t\t  //OUR CAMERA AWAY FROM THE ORIGIN POINT, THE LESS DETAILED WE'LL GET BECAUSE THIS IS, IN ESSENCE, BUILT AROUND\n        \t\t\t\t  //A RAYMARCHER THAT MARCHES A RAY TO A POINT \n        \n        float box = sdBox(p, vec3(1)); \n\n        float g1 = sdGyroid(p, 5.76, .03, 1.5);\n        float g2 = sdGyroid(p, 10.76, .03, .3);\n        float g3 = sdGyroid(p, 20.76, .03, .3);\n        float g4 = sdGyroid(p, 35.76, .03, .3);\n        float g5 = sdGyroid(p, 60.76, .03, .3);\n        float g6 = sdGyroid(p, 100.23, .03, .3);\n\n\n        //float g = min(g1, g2); //Union method of combining gyroids\n        // float g = max(g1, -g2); //Subraction method of combining gyroids\n        \n        g1 -= g2*.4;   //Bumpmap method\n        g1 -= g3 *.2;\n        g1 += g4 *.2;\n        g1 += g5 *.2;\n        g1 -= g6 *.1;\n       \n            \n       \n       // float d = max(box, g1*.8); //WE MULTIPLY BY A NUMBER LESS THAN 1 TO REDUCE THE STEP SIZE SO WE DON'T OVERSTEP WHEN\n        \t\t\t\t\t\t\t   //WE ADJUST THE SCALE ABOVE IN sdGyroid.\n \n        float d = g1*.6; \n        return d;\n    }\n\nfloat RayMarch(vec3 ro, vec3 rd)\n    {\n        float dO = 0.,eps=SURF_DIST; //Distance origin, or how far away we've marched from the origin. \n        \n        for(int i=0; i < MAX_STEPS; i++) //Loop that goes until you've reached max # of steps. \n        {\n            rd.xy *= Rot(rd.z/10.0); \n            vec3 p = ro+dO*rd; //Point P is the blue point (\n            float dS = GetDist(p); //Distance to the scene. \n            dO += 1.0; //We add the distance to the scene to how far we've marched away from origin. \n            \n            if(dS<eps*(1.0+dO*.25) || dO > MAX_DIST) break; //If distance to scene  is smaller than some defined surface distance, we have a hit. \n            eps *= 1.01;\t\t\t\t\t\t\t\t\t\t    //Or if it's past our max distance and we haven't hit anything, we break out of it. \n        }\n        return dO; \n    }\n\nvec3 GetNormal(vec3 p) //THIS IS HOW WE FIND THE NORMAL VECTOR, IE THE ORIENTATION OF A SURFACE\n    \t\t\t\t\t//ESSENTIALLY BY DOING THE SAME ALGORITHM TO DETERMINE A SLOPE. WE MAKE 2 POINTS\n    \t\t\t\t\t//VERY CLOSE TOGETHER, THEN SUBTRACT THE DISTANCE A LITTLE TO THE RIGHT, UP AND\n    \t\t\t\t\t//BEHIND THE SURFACE BETWEEN THEM TO FIND WHICH WAY IT'S PORIENTED. \n{\n    \n    vec2 e = vec2(.01, 0); //THIS IS OUR NEW POINT. OUR X VALUE IS .01 AND OUR Y VALUE IS 0.\n    float d = GetDist(p); //THIS IS OUR ORIGINAL POINT IN 3D SPACE WE MADE ABOVE\n    \n    vec3 n = d - vec3( //THESE ARE THE SUBTRACTIONS TO GIVE US OUR NORMAL \n        GetDist(p-e.xyy), //TO THE RIGHT, IE - .01, 0, 0\n        GetDist(p-e.yxy), //UP, IE 0, .01, 0 BECAUSE WE USE THE XY VALUES DEFINED ABOVE, WHEN WE DEFINE VEC2 E\n        GetDist(p-e.yyx)); //BEHIND\n        \n        return normalize(n); \n    \n}\n        \nfloat GetLight(vec3 p)\n        {\n            vec3 lightPos = vec3(0,5,6); //HARDCODE THE LIGHT POSITION. FOR NOW WE'LL SAY IT'S AT THESE POINTS. \n            lightPos.xy += vec2(sin(iTime), cos(iTime))*2.; \n            vec3 l = normalize(lightPos-p); //THIS CALCULATES WHERE LIGHT IS COMING FROM, FROM THE PERSPECTIVE OF THE SURFACE POINT\n            vec3 n = GetNormal(p); \n            \n            float dif = clamp(dot(n, l), 0., 1.); //IF WE DON'T CLAMP IT BETWEEN 0 AND 1, THIS ACTUALLY GIVES US A VALUE BETWEEN -1 AND 1\n            \t\t\t\t\t\t\t\t\t  //WHICH IS FINE WITH A SIMPLE SHAPE LIKE A SPHERE BUT IF WE WANT TO WORK WITH MORE COMPLEX\n            \t\t\t\t\t\t\t\t\t  //STUFF, IT WOULD GIVE US TROUBLE. SO WE CLAMP IT BETWEEN 0 AND 1 \n            \n            float d = RayMarch(p+n*SURF_DIST, l); //THIS IS HOW WE CALCULATE SHADOW. WE RAYMARCH BETWEEN SURFACE POINT AND LIGHT POS AND RETURN A VALUE.\n            \n            if(d<length(lightPos - p)) dif *= .1; //IF THE VALUE WE GET IS SMALLER THAN THE LIGHT POS - SURFACE POSITION, WE KNOW THAT \n            \t\t\t\t\t\t\t\t\t  //WE'RE IN SHADOW. TO MAKE A SHADOW, WE JUST TAKE THE LIGHT VALUE DIF AND MULTIPLY IT BY \n            \t\t\t\t\t\t\t\t\t  //A SMALL AMOUNT TO CREATE THE SHADOW\n            return dif;\n        }\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z)\n{\n    vec3 f = normalize (l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z, \n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d; \n}  \n        \nvec3 Background(vec3 rd)  //WE ONLY NEED TO CALCULATE OUR BKG'S RD BECAUSE WE DON'T CARE ABOUT WHERE WE ARE, WE ONLY CARE ABOUT WHAT\n    \t\t\t\t\t   //DIR WE'RE LOOKING IN. \n    \n{\n    \n    vec3 col = vec3(0); \n    float t = iTime; \n    \n    float y = rd.y * .5 +.5; //Here we map our color to the ray direction y and then multiply it so that we lock its value between 0 and 1. \n    \t\t\t\t\t\t//At 1 (straight), it's its brightest and at 0 (straight down) it's at its dimmest, giving us a gradient in the\n    \t\t\t\t\t\t//middle. \n    \n    col += y*vec3(.1, .7, 1)*2.;  //This bakes it in so that our color is brighter the higher our Y is. \n    \t\t\t\t\t\t\t  //If we wanted it reverse, we'd do col += (1.-y); \n    \n    float a = atan(rd.x, rd.z); //XZ plane to give us our angle so we can determine our NSEW direction \n    \n    float flames = sin(a*10. +t)*sin(a*7.-t)*sin(a*3.); //We find the sin wav of our angle and multiply to get multiple sin waves on our image. \n    \t\t\t\t\t\t\t\t\t\t\t\t //We then marry it to iTime so it comes in and out on a timer. Then repeat, but \n    \t\t\t\t\t\t\t\t\t\t\t\t//multiply it by negative t so we don't see the movement of the light coming in. Then,\n    \t\t\t\t\t\t\t\t\t\t\t\t//we multiply it again by the sin wave of the angle and diminish it so it feels random. \n    \t\t\t\t\t\t\t\t\t\t\t\t//We could keep repeating this again and again to make it feel more and more random, but\n    \t\t\t\t\t\t\t\t\t\t\t    //Ehh. It looks fine now.\n    \n    flames *= S(.8, .5, y); //We don't want this to reach the poles, so we smoothstep the flame's Y so at .5 it starts fading out\n    \t\t\t\t\t  //and at .8 it's completely faded out   \n        \n    col += flames; \n    col = max(col, 0.); //This makes it so our color can never go negative. \n    //col += S(.5, .2, y); \n    return col; \n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    float t = iTime;\n    vec3 col = vec3(0);\n    \n    uv += sin(uv*30.*t)*.0001; //\"Heat\" distortion    IF REALLY HIGH THEN IT CAN BE USED FOR DOPE MOSAIC STUFF\n    vec3 ro = vec3(0,0,-.01); //ray origin, or position of camera   \n    //ro.yz *= Rot(-m.y*3.14+1.+sin(iTime*5.0/7.0*2.0)/2.0); \n    //ro.xz *= Rot(-m.x*6.2831+cos(iTime*2.0)/2.0);\n    \n    ro.yz *= Rot(-m.y*3.14+(iTime*5.0/7.0)/2.0); \n    ro.xz *= Rot(-m.x*6.2831+(iTime)/2.0);\n    \n    vec3 lookat = vec3(0,0,0); \n    vec3 rd = GetRayDir(uv, ro, lookat, .8); //THE FLOAT AT THE END OF THIS IS THE ZOOM FACTOR\n    \n    float d = RayMarch(ro, rd);\n    \n    if(d<MAX_DIST) //THIS IS WHERE WE MAKE OUR MATERIAL, WHICH INCLUDES COLOR AND SHADOWS\n    {\n        vec3 p = ro + rd * d; \n        vec3 n = GetNormal(p); \n        \n        float height = p.y; \n\n        p = Transform(p); \n        \n        float dif = n.y * .5+.5; //n.y gives us light from direct above because it's the normal's y. We then wrap it with .5 + .5\n        \t\t\t\t\t\t //to prevent it shooting us back a negative value, keeping it always between 0 and 1. \n        col += dif*dif;\n        \n        float g2 = sdGyroid(p, 10.76, .03, .3); //Ambient occlusion.\n        col *= S(-.1, .1, g2); //Blackening \n        \n        \n        //CRACKS: \n        \n        float crackWidth = -.01 + S(0., -.5, n.y)*.01; //We set the crack width but then put in the smoothstep to say \"If it's between\n        \t\t\t\t\t\t\t\t\t\t\t\t//These values (ie 0 and -.5), then make it thicker. In this case, it tranlsates \n        \t\t\t\t\t\t\t\t\t\t\t\t//to being thicker on the bottom than the top.  \n        float cracks = S(crackWidth, -.03, g2); //  \n        float g3 = sdGyroid(p+t*.1, 5.76, .03, .0);\n        float g4 = sdGyroid(p-t*.07, 3.76, .03, .0);\n        \n        cracks *= g3*g4*30.+.3*S(.0, .3, n.y); //THE LAST NUMBER HERE DETERMINES THE BRIGHTNESS OF THE COLOR IN THE CRACKS\n        \t\t\t\t\t\t\t\t\t   //WE USE SMOOTHSTEP HERE TO KEEP IT FROM GOING FULLY BLACK AT A CERTAIN HEIGHT.\n        \t\t\t\t\t\t\t\t\t   //BECAUSE I WANT THIS TO BE ICE, I WANT IT TO NOT GO FULL BLACK UP TOP, BUT DOWN BELOW IS FINE.\n        \t\t\t\t\t\t\t\t\t   //IF I WANTED THE REVERSE, I'D REVERSE THE NUMBERS. \n        \n        \n        col += cracks*vec3(.1, .7, 1)*3.; //This allows us to change the color of the cracks in RGB code. Our primary color should\n        \t\t\t\t\t\t\t\t  //Always be 1 or greater and no value should be 0 because if it is, if we then multiply the\n        \t\t\t\t\t\t\t\t  //colors, it will get funky in not a good way. \n        \n        //FLICKERING\n        \n        float g5 = sdGyroid(p-vec3(t,0,0), 3.76, .03, .0); //The vec3 allows us to determine the direction the flickering happens.\n        \t\t\t\t\t\t\t\t\t\t\t\t   //We marry it to Time to give it a rhythm. If the T is in X, the flickering\n        \t\t\t\t\t\t\t\t\t\t\t\t  //goes along the X, if in Y then the Y,  etc.\n           \n        col += g5*vec3(.1, .7, 1); //determines the color of our flicker\n        \n        col += S(0., 8., height)*vec3(.1, .7, 1)*2.; //gives us a glow to wash it out. I have the glow start at 0 and reach max at 5\n        \n        \t\n        \n    }\n    \n    //DEPTH FOG/BACKGROUND: \n    \n    col = mix(col, Background(rd), S(0., 9., d)); //This is where we blend our background with our structure.  \n   \n    col *= 1. -dot(uv, uv); //THIS IS A VIGNETTE. WE MULTIPLY UV BY UV (UV SQUARED) TO GIVE US A BLACK CENTER. TO PUSH IT OUT TO THE EDGES\n    \t\t\t\t\t\t//OF THE SCREEN, WE MULTIPLY IT BY NEGATIVE DOT. \n    fragColor = vec4(col,1.0);\n}\n    \n    \n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcBD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[297, 360, 379, 379, 461], [463, 463, 493, 493, 583], [585, 585, 656, 656, 1043], [1045, 1045, 1069, 1069, 1155], [1157, 1157, 1230, 1230, 2456], [2458, 2458, 2496, 2496, 3296], [3298, 3298, 3652, 3652, 4161], [4171, 4171, 4203, 4203, 5423], [5425, 5425, 5475, 5475, 5673], [5685, 5685, 5861, 5861, 7436], [7439, 7439, 7496, 7496, 11069]], "test": "valid"}
{"id": "ttcBDj", "name": "random emotes", "author": "stb", "description": "Basic random emoticons.", "tags": ["procedural", "random", "happy", "smiley", "sad", "emoji", "emote", "emotion", "emoticons", "smilies", "skeptical", "concerned", "suspicious"], "likes": 26, "viewed": 184, "published": "Public", "date": "1613438772", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n    random emotes\n    2021 stb\n*/\n\n// hash without sine\n// https://www.shadertoy.com/view/4djSRW\n//#define MOD3 vec3(.1031, .11369, .13787) // int range\n#define MOD3 vec3(443.8975, 397.2973, 491.1871) // uv range\nvec2 hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n// circle inversion function\nvec2 cInv(vec2 p, vec2 o, float r) {\n    return (p-o) * r * r / dot(p-o, p-o) + o;\n}\n\n// a line of width w, warped by circle inversion, offset by o\nfloat arc(in vec2 p, float w, in vec2 o) {\n    p = cInv(p, vec2(0.), 1.);\n    p = cInv(p, vec2(0., o.y), 1.);\n    p.y -= o.y;\n\n    return  length(vec2(max(0., abs(p.x-o.x)-w), p.y));\n}\n\nfloat emote(vec2 p, vec2 h, float aa) {\n    float f=1., eyes, eyebrows=-.065, mouth, head;\n    vec2 o = vec2(0., 1.);\n    \n    // look variable (where the face is facing)\n    vec2 lk = .5 * (h-.5);\n    \n    // get eyes\n    eyes = length(vec2(abs(p.x-lk.x)-.36+.25*pow(lk.x, 2.), p.y-.27-lk.y)) - .15;\n    \n    // get eyebrows (symmetrical or not)\n    if(fract(3.447*h.x) < .5)\n        eyebrows += arc(vec2(abs(p.x-lk.x)-.35, p.y-lk.y-.5*fract(1.46*lk.y)-.35), .2, 2.*fract(h*2.31)*h.y*o-.5*o);\n    else\n        eyebrows +=\n            min(\n                arc(vec2(p.x-lk.x-.35, p.y-lk.y-.25*fract(2.31*lk.y)-.4), .2, 2.*fract(h*2.31)*h.y*o-.5*o),\n                arc(vec2(-p.x+lk.x-.35, p.y-lk.y-.25*fract(-1.81*lk.y)-.4), .2, 2.*fract(-h*1.92)*h.y*o-.5*o)\n            );\n    \n    // get mouth\n    mouth = arc(p+vec2(0., .35)-.5*lk, .4*pow(h.x, .5), vec2(.35, 1.)*(fract(2.772*h)-.5)) - .08;\n    \n    // get head\n    head = abs(length(p)-1.) - .075;\n    \n    // combine everything\n    f = min(f, eyes);\n    if(fract(4.932*h.x) < .65) // some emotes have eyebrows\n        f = min(f, eyebrows);\n    f = min(f, mouth);\n    f = min(f, head);\n    \n    // result\n    return smoothstep(-aa, aa, f);\n}\n\nvoid mainImage( out vec4 fo, in vec2 fc )\n{\n    vec2 res = iResolution.xy;\n    vec2 p   = (fc-res/2.) / res.y;\n    vec2 m   = (iMouse.xy-res/2.) / res.y;\n    \n    float zoom     = iMouse.x>0. ? .0125 + .5 * iMouse.y / res.y : .2;\n    float headSize = 1.3;\n    float aa       = 2. / zoom / res.y * headSize;\n    \n    // zoom\n    p /= zoom;\n    \n    // scroll\n    p.y -= .5 * iTime;\n    \n    // one hash22 to rule them all\n    vec2 h = hash22(ceil(p)+.371);\n    \n    // get emote\n    float f = emote(headSize*(fract(p)*2.-1.), h, aa);\n    \n    // set initial color to black/white emote\n    vec3 col = vec3(f);\n    \n    // apply circles of color\n    if(length(fract(p)-.5) < .5/headSize) {\n        col *= fract(vec3(pow(h.x, .15), pow(fract(1.314*h.y), .15), fract(1.823*h.y)));\n        col *= clamp(2.*(.75-length(fract(p)-vec2(.5, .6))), 0., 1.);\n    }\n    \n    // output\n    fo = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcBDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 216, 237, 237, 372], [374, 403, 439, 439, 487], [489, 551, 593, 593, 735], [737, 737, 776, 776, 1931], [1933, 1933, 1976, 1976, 2829]], "test": "valid"}
{"id": "ttcBDs", "name": "Refactoring Blackpool", "author": "evvvvil", "description": "Refactoring Blackpool - Result of improvised live code session on Twitch\nLIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 20:00 Uk time:\nhttps://www.twitch.tv/evvvvil_", "tags": ["demoscene", "glow", "alien", "city", "scifi", "cut", "lazer", "network", "structure", "industrial", "building", "extrusion", "brutalist", "modernist"], "likes": 24, "viewed": 561, "published": "Public API", "date": "1613678655", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Refactoring Blackpool - Result of an improvised live coding session on Twitch\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 20:00 Uk time: \n// https://www.twitch.tv/evvvvil_\n\n// \"One day kids, I'll refactor Blackpool\" - Le Corbusier \n\nvec2 z,v,e=vec2(.00035,-.00035);float t,tt,b,g=0.,gg=0.;vec3 np,pp,po,no,al,ld,cp,op;\nfloat bo(vec2 p, vec2 b ){ p= abs(p)-b;return length(max(p,0.))+min(max(p.x,p.y),0.);}\nfloat box(vec3 p, vec3 b ){ p= abs(p)-b;return max(max(p.x,p.y),p.z);}\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}\nfloat ex(vec3 p,float sdf,float h){vec2 w=vec2(sdf,abs(p.y)-h);return min(max(w.x,w.y),0.0)+length(max(w,0.0));}\nvec2 mp( vec3 p)\n{\n  op=p;\n  p.x=mod(p.x-tt*0.7,20.)-10.;\n  np=vec3(p.xz*.5,1.0);\n  pp=p-vec3(0,3,0);  \n  pp.xz=mod(pp.xz,5.)-2.5;\n  pp.yz*=r2(.785);\n  vec2 h=vec2(1000,6),t=vec2(1000,5);  \n  float cutBox=box(pp,vec3(2.0,1.5,2.5));    \n  for(int i=0;i<4;i++){\n    b=float(i);\n    np.xy=abs(np.xy)-2.0;    \n    np.xy*=r2(.785*(b+1.));\n    np*=1.8;\n    np.y=abs(np.y)-1.5;         \n    t.x=min(t.x,ex(p,max(bo(np.xy,vec2(5,.2))/np.z*2.0,-cutBox),1.0+b*.5)); \n    t.x=abs(t.x)-.02*max(sin(p.y*10.),0.1)-.04*clamp(sin(np.x*2.5),.1,.5); \n    h.x=min(h.x,ex(p,bo(np.xy,vec2(5.,0.01))/np.z*2.0,.25+b*.5-0.1*cos(op.x*1.3+1.5)));    \n    t.x=max(t.x,abs(p.y)-0.3-b*.5);     \n  } \n  h.x=max(h.x,-cutBox+.1);    \n  g+=0.1/(0.1+h.x*h.x*(1.-sin(op.x*1.3)*.9)*1600.);    \n  cp=vec3(np.xy,p.y*2.);\n  h.x=min(h.x,box(cp+vec3(-5.,2,0),vec3(1.7,1,5.+sin(p.x*.7)))/np.z*2.);\n  float part=length(cos(cp.yz*20.));   \n  part=max(part,p.y-1.5);\n  gg+=0.1/(0.1+part*part*12.);\n  t.x=min(t.x,part);\n  t=t.x<h.x?t:h;\n  return t;\n}\nvec2 tr( vec3 ro, vec3 rd)\n{\n  vec2 h,t=vec2(.1);\n  for(int i=0;i<128;i++){\n    h=mp(ro+rd*t.x);\n    if(t.x<.0001||t.x>20.) break;\n    t.x+=h.x;t.y=h.y;\n  }\n  if(t.x>20.) t.y=0.;\n  return t;\n}\n#define a(d) clamp(mp(po+no*d).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d).x/d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1);\n  tt=mod(iTime,62.82);\n  vec3 ro=vec3(10.,2.9-sin(tt*.2)*.8,-4.+ceil(cos(tt*.2))*8.+cos(tt*0.4)*2.),\n  cw=normalize(vec3(0,-6,0)-ro),cu=normalize(cross(cw,vec3(0,1,0))),\n  cv=normalize(cross(cu,cw)),rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo;  \n  co=fo=vec3(.18,.16,.2)-length(uv)*.25;\n  ld=normalize(vec3(.2,.4,-.3));  \n  z=tr(ro,rd);t=z.x;\n  if(z.y>0.){    \n    po=ro+rd*t;\n    no=normalize(e.xyy*mp(po+e.xyy).x+\n    e.yyx*mp(po+e.yyx).x+\n    e.yxy*mp(po+e.yxy).x+\n    e.xxx*mp(po+e.xxx).x);\n    no-=0.3*ceil(abs(sin(cp*10.))-.1);no=normalize(no);\n    al=mix(vec3(0.4),vec3(0.0,0.15,0.75 ),cp.y*.5);\n    if(z.y>5.) al=vec3(1.2);\n    float dif=max(0.,dot(no,ld)),\n    fr=pow(1.+dot(no,rd),4.),\n    sp=pow(max(dot(reflect(-ld,no),-rd),0.),40.);\n    co=mix(sp+al*(a(.12)+.2)*(dif+s(2.)),fo,min(fr,0.4));    \n    co=mix(fo,co,exp(-.0007*t*t*t));\n  }\n  fragColor = vec4(pow(co+g*.1*vec3(.1,.2,.7)+gg*.05*vec3(.4,.1,.1),vec3(.65)),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcBDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[193, 339, 365, 365, 425], [426, 426, 453, 453, 496], [497, 497, 514, 514, 557], [558, 558, 593, 593, 670], [671, 671, 689, 689, 1675], [1676, 1676, 1704, 1704, 1868], [1958, 1958, 2015, 2015, 3033]], "test": "valid"}
{"id": "ttcBRs", "name": "[RGR] Hearts", "author": "deeplo", "description": "falling hearts like tree leaves", "tags": ["hearts"], "likes": 3, "viewed": 244, "published": "Public API", "date": "1613254894", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S smoothstep\n#define HEART_COLOR_F vec3(1.0,.05,0.05)\n#define HEART_COLOR_B vec3(1.0,0.25,0.25)\n#define BG_COLOR vec3(0.5,0.05,0.05)\n#define T (iTime)\n#define NB_HEARTS 50.0\n\nmat2 Rot(float angle){\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c,-s,s,c);\n}\n\nfloat smax(float a, float b, float k){\n    float h = clamp((b-a)/k+0.5, 0., 1.);\n    return mix(a, b, h) + h*(1.0-h)*k*0.5;\n}\n\nvec4 Heart(vec2 uv, float radius, float blur){\n    float angle = sin(iTime*0.1)*0.25;    \n    blur *= radius;\n    uv -= vec2(0.0,-radius);\n    uv *= Rot(angle*length(uv)*2.);\n    uv -= vec2(0.0,+radius);\n    uv.x *= 0.7;\n    uv.y -= smax(sqrt(abs(uv.x))*.5, blur, 0.1) -.1 - blur*0.5;\n    float d = length(uv);\n    float c = S(radius+blur,radius-blur-0.01,d);\n    return vec4(vec3(1),c);\n}\n\nvec3 Transform(vec3 p, float a){\n    p.xz *= Rot(a);\n    p.xy *= Rot(a*0.765);\n    return p;\n}\n\nvec4 HeartBall(vec3 ro, vec3 rd, vec3 pos, float radius, float angle, float blur){\n\n    vec4 col = vec4(0);\n    float t  = dot(pos-ro, rd);\n    vec3  p  = ro + rd*t;\n    float y  = length(pos-p);    \n    if (y<1.0){\n        float x = sqrt(1.0-y);\n        vec3 pF = ro + rd*(t-x) - pos;         // front intersection\n        vec3 pB = ro + rd*(t+x) - pos;         // back intersection\n        pF = Transform(pF,angle);\n        pB = Transform(pB,angle);    \n        vec2 uvF = vec2(atan(pF.x,pF.z),pF.y);\n        vec2 uvB = vec2(atan(pB.x,pB.z),pB.y);\n        vec4 front = Heart(uvF, radius, blur);\n        vec4 back = Heart(uvB, radius, blur);\n        front.xyz *= HEART_COLOR_F;\n        back.xyz  *= HEART_COLOR_B;\n        col = mix(back, front, front.a) ;\n    }\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Get coords normallized according to Y resolution. Screen displays uv between -1/+1  \n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n\n    // Mouse vector\n    vec2 M = iMouse.xy/iResolution.xy;\n\n    // output color\n    vec3 bg = BG_COLOR*(uv.y+1.0);\n    vec4 col = vec4(bg,1.0);\n    vec3 ro = vec3(0,0,-4);\n    vec3 rd = normalize(vec3(uv,1));\n    \n    for(float i=0.0; i<1.0 ; i+=1.0/NB_HEARTS){\n        float x = mix(-4.0, 4.0, fract(sin(i*735.25)*457.56));\n        float y = mix(-5.0,5.0,fract(i-T*0.1));\n        float z = mix(3.0, 0.0, i);\n        float radius = S(3.0,0.0,z)*0.3+0.3 ;\n        float angle = T+i*985.989;\n        // blur in the background / Blur in the foreground \n        float blur = S(0.25,0.75,abs(z-1.5))/4.0;\n        vec3 pos = vec3(x,y,z);\n        vec4 heart = HeartBall(ro, rd, pos, radius, angle, blur); \n        //heart.xyz = vec3(abs(1.5-z)/1.5 );\n        col = mix(col, heart, heart.a);\n    }\n\n\n\n    \n\n\n    fragColor = col;\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcBRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[183, 183, 205, 205, 286], [288, 288, 326, 326, 413], [415, 415, 461, 461, 804], [806, 806, 838, 838, 900], [902, 902, 984, 984, 1682], [1685, 1685, 1742, 1834, 2723]], "test": "valid"}
{"id": "ttcBWH", "name": "Explore Sierpinski gasket", "author": "butadiene", "description": "Explore Sierpinski gasket", "tags": ["raymarching", "fractal", "tetrahedron", "sierpinski"], "likes": 3, "viewed": 243, "published": "Public API", "date": "1612623091", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float PI = acos(-1.);\nmat2 rot(float r){\n    vec2 s = vec2(cos(r),sin(r));\n    return mat2(s.x,s.y,-s.y,s.x);\n}\nfloat cube(vec3 p,vec3 s){\n    vec3 q = abs(p);\n    vec3 m = max(s-q,0.);\n    return length(max(q-s,0.))-min(min(m.x,m.y),m.z);\n}\n\nvec4 tetcol(vec3 p,vec3 offset,float scale,vec3 col){\n    vec4 z = vec4(p,1.);\n    for(int i = 0;i<12;i++){\n        if(z.x+z.y<0.0)z.xy = -z.yx,col.z+=1.;\n        if(z.x+z.z<0.0)z.xz = -z.zx,col.y+=1.;\n        if(z.z+z.y<0.0)z.zy = -z.yz,col.x+=1.;\n        \n        z *= scale;\n      //  z.xyz = clamp(z.xyz,-1.,1.);\n        z.xyz += offset*(1.0-scale);\n    }\n    \n    return vec4(col,(cube(z.xyz,vec3(1.5)))/z.w);\n}\nvec4 dist(vec3 p,float t){\n    float s = 1.;\n    p = abs(p)-4.*s;\n    p = abs(p)-2.*s;\n    p = abs(p)-1.*s;\n\n    vec4 sd = tetcol(p,vec3(1),1.8,vec3(0.));\n    float d= sd.w;\n    vec3 col = 1.-0.1*sd.xyz;\n    col *= exp(-2.5*d)*2.6;\n    return vec4(col,d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (uv-0.5)*2.;\n    p.y *= iResolution.y/iResolution.x;\n\n    float rsa =1.2;\n    float time = iTime+17.5;\n    float rkt = time*0.3;\n    vec3 ro = vec3(rsa*cos(rkt)-0.05,2.2*sin(time*0.2)+0.025,rsa*sin(rkt));\n    vec3 ta = vec3(0);\n    vec3 cdir = normalize(ta-ro);\n    vec3 side = cross(cdir,vec3(0,1,0));\n    vec3 up = cross(side,cdir);\n    vec3 rd = normalize(p.x*side+p.y*up+0.5*cdir);\n    rd.xz *= rot(time*0.13+1.);\n    float d,t= 0.;\n    vec3 ac = vec3(0.);\n    vec3 ac2 = vec3(0.);\n    float frag = 0.;\n    float ep = 0.0005;\n    for(int i = 0;i<66;i++){\n        vec4 rsd = dist(ro+rd*t,t);\n        d = rsd.w;\n        t += d;\n        ac += rsd.xyz;\n        if(d<ep) break;\n    }\n\n    vec3 col = vec3(0);\n    \n    col  =0.04*ac;\n    \tfragColor = vec4(col, 1.0 );\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcBWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 40, 40, 111], [112, 112, 138, 138, 241], [243, 243, 296, 296, 659], [660, 660, 686, 686, 917], [919, 919, 976, 976, 1798]], "test": "valid"}
{"id": "ttcBWn", "name": "Strange Life", "author": "oneshade", "description": "An interesting variant of fractal noise.", "tags": ["noise", "strange", "hairynoise", "hairy"], "likes": 7, "viewed": 132, "published": "Public", "date": "1612493619", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float WhiteNoise(in vec3 p) {\n    return fract(1853.475 * cos(dot(p, vec3(1385.846, 1548.847, 4.837))));\n}\n\nfloat SmoothNoise(in vec3 p) {\n    vec3 c = floor(p);\n    vec3 l = fract(p);\n    l *= l * (3.0 - 2.0 * l);\n\n    float ldb = WhiteNoise(c);\n    float rdb = WhiteNoise(c + vec3(1.0, 0.0, 0.0));\n    float lub = WhiteNoise(c + vec3(0.0, 1.0, 0.0));\n    float rub = WhiteNoise(c + vec3(1.0, 1.0, 0.0));\n    float ldf = WhiteNoise(c + vec3(0.0, 0.0, 1.0));\n    float rdf = WhiteNoise(c + vec3(1.0, 0.0, 1.0));\n    float luf = WhiteNoise(c + vec3(0.0, 1.0, 1.0));\n    float ruf = WhiteNoise(c + 1.0);\n\n    return mix(mix(mix(ldb, rdb, l.x), mix(lub, rub, l.x), l.y),\n               mix(mix(ldf, rdf, l.x), mix(luf, ruf, l.x), l.y),\n               l.z);\n}\n\nfloat HairyNoise(in vec3 p, in float scale, in float octaves) {\n    p *= scale;\n\n    float value = 0.0;\n    float nscale = 1.0;\n    float tscale = 0.0;\n\n    for (float octave=0.0; octave < octaves; octave++) {\n        // Magic numbers\n        p.xz *= mat2(-0.48406725864, -0.87503079323, 0.87503079323, -0.48406725864);\n        p.yz *= mat2(0.15022546991, -0.98865176285, 0.98865176285, 0.15022546991);\n\n        value += abs(SmoothNoise(p) * 2.0 - 1.0) * nscale;\n        tscale += nscale;\n        nscale *= 0.25;\n\n        p *= 2.0;\n    }\n\n    return value / tscale;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(pow(1.0 - HairyNoise(vec3(uv * 5.0, 0.25 * iTime), 1.0, 10.0), 5.0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcBWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 106], [108, 108, 138, 138, 755], [757, 757, 820, 820, 1324], [1326, 1326, 1381, 1381, 1540]], "test": "valid"}
{"id": "ttcBWr", "name": "Disney vs Deadmau5", "author": "lumic", "description": "Morphs between Mickey Mouse and Deadmau5\nBased on https://www.shadertoy.com/view/XsyGRW\nPlease excuse the messy code.", "tags": ["2d", "sdf"], "likes": 5, "viewed": 136, "published": "Public", "date": "1612511427", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 0 = Distance Field Display\n// 1 = Raymarched Edges\n// 2 = Resulting Solid\n#define DISPLAY 0\n\nconst float PI = 3.14159265359;\n\nvec2 squareFrame(vec2 screenSize, vec2 coord) {\n  vec2 position = 2.0 * (coord.xy / screenSize.xy) - 1.0;\n  position.x *= screenSize.x / screenSize.y;\n  return position;\n}\n\nvec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n  return a + b * cos(6.28318 * (c * t + d));\n}\n\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nvec3 draw_line(float d, float thickness) {\n  const float aa = 3.0;\n  return vec3(smoothstep(0.0, aa / iResolution.y, max(0.0, abs(d) - thickness)));\n}\n\nvec3 draw_line(float d) {\n  return draw_line(d, 0.0025);\n}\n\nfloat draw_solid(float d) {\n  return smoothstep(0.0, 3.0 / iResolution.y, max(0.0, d));\n}\n\nvec3 draw_distance(float d, vec2 p) {\n  float t = clamp(d * 0.85, 0.0, 1.0);\n  vec3 grad = mix(vec3(1, 0.8, 0.5), vec3(0.3, 0.8, 1), t);\n\n  float d0 = abs(1.0 - draw_line(mod(d + 0.1, 0.2) - 0.1).x);\n  float d1 = abs(1.0 - draw_line(mod(d + 0.025, 0.05) - 0.025).x);\n  float d2 = abs(1.0 - draw_line(d).x);\n  vec3 rim = vec3(max(d2 * 0.85, max(d0 * 0.25, d1 * 0.06125)));\n\n  grad -= rim;\n  grad -= mix(vec3(0.05, 0.35, 0.35), vec3(0.0), draw_solid(d));\n\n  return grad;\n}\n\nfloat ellipse( in vec2 p, in vec2 ab )\n{\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}\n\nfloat box( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvec2 rotate(vec2 p, float deg) {\n    float r = length(p);\n    float angle = atan(p.y, p.x);\n    float radians = angle + deg / 360.0 * (2.0 * PI);\n    return vec2(r * cos(radians), r * sin(radians));\n}\n\n\nfloat combine( float d1, float d2 ) { return min(d1,d2); }\nfloat difference( float d1, float d2 ) { return max(d1,-d2); }\nfloat intersect( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nfloat mixer() {\n    return (sin(iTime * 1.5) + 1.0) * 0.5;\n}\n\nfloat ear(vec2 p, float angle, float scale, vec2 e) {\n    return ellipse(rotate(p * scale, -angle), e);\n}\n\nfloat mickey(vec2 p) {\n    float d = circle(p, 0.5);\n    d = min(d, ear(p - vec2(0.5, 0.5), 120.0, 1.1,  vec2(0.4, 0.35)));\n    d = min(d, ear(p - vec2(-0.5, 0.5), -120.0, 1.1, vec2(0.4, 0.35)));\n    return d;\n}\n\nfloat eye(vec2 p, float angle, float t) {\n    float d = 2.0;\n    vec2 pr = rotate(p, angle);\n    return opSmoothIntersection(        \n        circle(pr * d, 0.25 * t),\n        circle(pr * d - vec2(0, 0.25), 0.35 * t), 0.05);\n}\n\n// t = 0 : disney, t = 1 : deadmau5\nfloat deadmau5(vec2 p, float t) {\n    float headSize = mix(0.5, 0.45, t);\n    float face = circle(p, headSize);\n\n    float earAngle = mix(60.0, 40.0, t); \n    vec2 ellipseAB = mix(vec2(0.35, 0.4), vec2(0.4, 0.3), t);\n    float earInvScale = mix(1.1, 0.94, t);\n    \n    face = combine(face, ear(p - vec2(0.5, 0.5), earAngle, earInvScale, ellipseAB));\n    face = combine(face, ear(p - vec2(-0.5, 0.5), -earAngle, earInvScale, ellipseAB));\n    \n    float fullmouth = circle(p, 0.3 + 0.1 * t);\n    float mouth = difference(fullmouth, circle(p - vec2(0, 10.0 - (1.0 - t) * 1.0), 10.0));\n    face = difference(face, mouth);\n    \n    face = difference(face, eye(p - vec2(0.21, 0.21), 45.0, t));\n    face = difference(face, eye(p - vec2(-0.21, 0.21), -45.0, t));\n    \n    return face;\n    //return ear(p - vec2(0.5, 0.5), 15.0);\n}\n\nfloat scene(vec2 p) {\n    // return mix(deadmau5(p), mickey(p), mixer());\n    return deadmau5(p - vec2(0.0, -0.15), mixer());\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float t = 0.0f;\n  vec2 uv = squareFrame(iResolution.xy, fragCoord);\n  float d;\n  vec3 col;\n  vec2 ro = vec2(iMouse.xy / iResolution.xy) * 2.0 - 1.0;\n  ro.x *= squareFrame(iResolution.xy, iResolution.xy).x;\n\n  vec2 rd = normalize(-ro);\n\n  d = scene(uv);\n\n  #if DISPLAY == 0\n    col = vec3(draw_distance(d, uv.xy));\n  #endif\n  #if DISPLAY == 1\n    col += 1.0 - vec3(draw_line(d));\n    col = 1. - col;\n  #endif\n  #if DISPLAY == 2\n    col = vec3(draw_solid(d));\n  #endif\n\n  fragColor.rgb = col;\n  fragColor.a   = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcBWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 129, 176, 176, 300], [302, 302, 357, 357, 404], [407, 407, 438, 438, 464], [466, 466, 508, 508, 616], [618, 618, 643, 643, 676], [678, 678, 705, 705, 767], [769, 769, 806, 806, 1239], [1241, 1241, 1281, 1281, 2303], [2305, 2305, 2340, 2340, 2420], [2422, 2422, 2454, 2454, 2622], [2625, 2625, 2662, 2662, 2683], [2684, 2684, 2724, 2724, 2746], [2747, 2747, 2786, 2786, 2807], [2809, 2809, 2861, 2861, 2960], [2962, 2962, 3020, 3020, 3120], [3122, 3122, 3181, 3181, 3280], [3282, 3282, 3297, 3297, 3342], [3344, 3344, 3397, 3397, 3449], [3451, 3451, 3473, 3473, 3662], [3664, 3664, 3705, 3705, 3890], [3892, 3928, 3961, 3961, 4750], [4752, 4752, 4773, 4825, 4879], [4881, 4881, 4936, 4936, 5454]], "test": "valid"}
{"id": "ttcBz2", "name": "CellLab", "author": "kinonik", "description": "рисую жгутоцит из CellLab", "tags": ["noob"], "likes": 5, "viewed": 76, "published": "Public", "date": "1613066586", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 inputcoord = vec2(fragCoord.x*0.7 + fragCoord.y*0.3,\n\t\tfragCoord.y*0.7 - fragCoord.x*0.3 + iResolution.y / 4.) * 4.;\n\tinputcoord.x -= (pow(fract(-iTime / 4. + 0.2), 0.8) - 0.1)*6.*iResolution.x;\n\tinputcoord.y -= iResolution.y;\n\tvec2 pos = inputcoord / iResolution.y;\n\tvec2 uv = inputcoord / iResolution.xy;\n\tuv.y -= 0.5;\n\tpos -= 0.5;\n\tfloat t = iTime;\n\tfloat mask = 0.;\n\tif (uv.x > 0.0) {\n\t\tuv.y += sin(-t * 30. + uv.x * 15.)*0.3*uv.x;\n\t\tmask = 0.2 - abs(uv.y) - pow(uv.x / 3., 1.);\n\t\tif (mask > 0.) {\n\t\t\tmask = sin(mask * 3.14 / 2. / min(1., max(0., (0.2 - uv.x / 3.))));\n\t\t}\n\t}\n\tif (mask < 0.)\n\t\tmask = 0.;\n\tmask += pow(max(0., 1.45 - length(pos - vec2(-0.79, 0.))), 40.);\n\tif (mask > 0.5)\n\t\tmask = 1.;\n\telse\n\t\tmask = 0.;\n\n\tvec3 col;\n\tfloat ling = 0.9 - length(fragCoord / iResolution.x - 0.3);\n\tcol.r = min(255.f, 0.745f + ling / 2.f);\n\tcol.g = 0.745f + ling / 5.f;\n\tcol.b = 1.f - ling * ling * 0.3f;\n\tfloat radius = length(pos - vec2(-0.79, 0.));\n\tif (radius<0.41 && radius>0.1)\n\t\tcol = (col + (vec3(0.1, 0.4, 0.6) * mask) * 2.f) / 3.f;\n\telse\n\t\tif (mask > 0.)\n\t\t\tcol = vec3(0.1, 0.4, 0.6) * mask / 2.;\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcBz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 1198]], "test": "valid"}
{"id": "ttcBzB", "name": "test10022021", "author": "logicaldesign", "description": "test", "tags": ["test"], "likes": 0, "viewed": 139, "published": "Public API", "date": "1612960459", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    // vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    // fragColor = vec4(col,1.0);\n    \n\n    \n     vec2 xy = fragCoord.xy; //We obtain our coordinates for the current pixel\n    xy.x = xy.x / iResolution.x; //We divide the coordinates by the screen size\n    xy.y = xy.y / iResolution.y;\n    // Now x is 0 for the leftmost pixel, and 1 for the rightmost pixel\n    //vec4 solidRed = vec4(0,0.0,0.0,1.0); //This is actually black right now\n    // solidRed.r = xy.x; //Set its red component to the normalized x value\n    vec4 solidRed =  texture(iChannel0,xy);\n    solidRed.r = abs(sin(iTime));\n    solidRed.g *= abs(cos(iTime));\n    solidRed.b *= abs(sin(iTime) * cos(iTime));\n    fragColor = solidRed;  \n}", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcBzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 301, 921]], "test": "error"}
{"id": "ttcfD7", "name": "Glass bubble lamp", "author": "jarble", "description": "mouse x controls fractal loop", "tags": ["fractal"], "likes": 10, "viewed": 257, "published": "Public API", "date": "1612854226", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u = 3.*(2.*fragCoord-iResolution.xy)/iResolution.y;\n         u = -u.yx;\n         u += vec2(1.,0.);\n    vec2 v = u;\n         u = u*dot(u,u);\n    \n    float t = iTime*.8;\n    //float t = (1.0+sin(iTime/32.0))*32.0;\n\n    if(iMouse.z > 0.) t = 10.*iMouse.x/iResolution.x;\n\n    float pi = 3.14159265359;\n    vec4 sum = vec4(0.);\n    for(float i = 0.; i < t; ++i)\n    {\n        u = cos(u.y-vec2(.0,.5*pi))*exp(sin(u.x+iTime)+cos(u.y+iTime));\n        u+= v;\n        sum += (.5+.5*cos(i*4.+vec4(0,1,2,0)))/length(u);\n    }\n    fragColor = sqrt(sum)*.25;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcfD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 614]], "test": "valid"}
{"id": "ttcfRH", "name": "Something like the Night Sky", "author": "Zi7ar21", "description": "Not Physically accurate, but it sure is pretty. See the code for details.", "tags": ["noise", "fbm", "sky", "night"], "likes": 16, "viewed": 604, "published": "Public API", "date": "1612215306", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Something like the Night Sky by Zi7ar21 --- February 1st, 2020\n// Updated February 1st, 17:15 Mountain Time\n\n// If you didn't find this on Shadertoy, the original can be found at:\n// https://www.shadertoy.com/view/ttcfRH\n\n/*\nThis is a somewhat Night-Sky like scene. It is rendered in 2D, and is NOT physically accurate.\nI didn't take into account proper gas colors, gas distribution, etc.\nAlso the stars have a Blackbody pallete but the probability of a random sampled star's\ncolor and luminance is not based on something accurate like Hertzsprung-Russell.\n*/\n\n// Hashes https://www.shadertoy.com/view/4djSRW\n\nfloat hash11(float p){\n    p = fract(p*0.1031);\n    p *= p+33.33;\n    p *= p+p;\n    return fract(p);\n}\n\nfloat hash12(vec2 pos){\n\tvec3 p3  = fract(vec3(pos.xyx)*0.1031);\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.x+p3.y)*p3.z);\n}\n\nfloat hash13(vec3 p3){\n\tp3 = fract(p3*0.1031);\n    p3 += dot(p3, p3.zyx+31.32);\n    return fract((p3.x+p3.y)*p3.z);\n}\n\nvec3 hash33(vec3 p3){\n\tp3 = fract(p3*vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yxx)*p3.zyx);\n\n}\n\nfloat noise(vec2 n){\n    vec4 b = vec4(floor(n), ceil(n)); \n    vec2 f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(hash12(b.xy), hash12(b.zy), f.x), mix(hash12(b.xw), hash12(b.zw), f.x), f.y);\n}\n\n// Atmospheric Distortion \"Twinkling\"\nfloat noise(vec2 coord, float n){\n    float componenta = hash13(vec3(coord, round(n-0.5)));\n    float componentb = hash13(vec3(coord, round(n+0.5)));\n    float componentc = mix(componenta, componentb, mod(n, 1.0));\n    return componentc;\n}\n\n// FBM Terrain Line\nfloat noise(float coord){\n    float componenta = hash11(round(coord-0.5));\n    float componentb = hash11(round(coord+0.5));\n    return mix(componenta, componentb, mod(coord, 1.0));\n}\n\n// Color Offset, as Reccomended by user \"elenzil\"\n// https://www.shadertoy.com/user/elenzil\nvec3 colorednoise(vec2 coord, float n){\n    vec3 componenta = hash33(vec3(coord, round(n-0.5)));\n    vec3 componentb = hash33(vec3(coord, round(n+0.5)));\n    vec3 componentc = mix(componenta, componentb, mod(n, 1.0));\n    return componentc;\n}\n\n// FBM https://www.shadertoy.com/view/3dSBRh\n#define octaves 8\nfloat fbm(vec2 x){\n\tfloat v = 0.0;\n\tfloat a = 0.4;\n\tfor (int i = 0; i < octaves; i++){\n\t\tv += a*noise(x);\n\t\tx = x*2.0;\n\t\ta *= 0.6;\n\t}\n\treturn v;\n}\n\nfloat fbm(float x){\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tfor (int i = 0; i < octaves; i++){\n\t\tv += a*noise(x);\n\t\tx = x*2.0;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n// Blackbody Coloration (Made into a Function by LoicVDB)\n// https://www.shadertoy.com/view/4tdGWM\nvec3 blackbody(float temperature){\n    vec3 O = vec3(0.0);\n    for (float i = 0.0; i < 3.0; i += 0.1){\n        float f = 1.0+0.5*i; \n        O[int(i)] += 10.0*(f*f*f)/(exp((19E3*f/temperature))-1.0);\n    }\n    return O;\n}\n\n// Stars\nvec3 stars(vec2 coord){\n    float luminance = max(0.0, (hash12(coord)-0.985));\n    float temperature = (hash12(coord+iResolution.xy)*6000.0)+4000.0;\n    vec3 colorshift = normalize(colorednoise(coord, float(iTime*16.0)));\n    return (luminance*noise(coord, iTime*4.0))*blackbody(temperature)*4.0*(colorshift*0.5+1.0);\n}\n\n// Galaxy\nfloat galaxygas(vec2 coord){\n    return max(0.0, fbm((coord*4.0)+fbm(coord*4.0))-0.35);\n}\n\nfloat galaxydust(vec2 coord){\n    return max(0.0, fbm((coord*2.0)+fbm(coord*2.0)+vec2(4.0, 4.0))-0.5);\n}\n\n// Nebula\nfloat nebula(vec2 coord){\n    float gas0 = max(0.0, fbm((coord*2.0)+fbm(coord*2.0)+vec2(4.0, 4.0))-length(coord));\n    float gas1 = max(0.0, fbm((coord*4.0)+fbm(coord*2.0)+vec2(4.0, 4.0))-length(coord*1.01));\n    return max(0.0, gas0-gas1);\n}\n\n// Main Image\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n    vec2 uv = 2.0*(fragCoord.xy-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);\n    if(fbm((uv.x+4.0)*4.0) > (uv.y+0.5)*4.0){\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        return;\n    }\n    vec3 star = stars(fragCoord);\n    float gas = galaxygas(uv);\n    vec3 dust = galaxydust(uv)*vec3(0.5, 0.4, 0.3);\n    vec3 nebulae = nebula(uv)*vec3(0.6, 0.5, 0.75);\n    vec3 color = star+mix(vec3(gas), dust*0.5, 0.75)+nebulae;\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcfRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[564, 613, 635, 635, 715], [717, 717, 740, 740, 852], [854, 854, 876, 876, 971], [973, 973, 994, 994, 1118], [1120, 1120, 1140, 1140, 1332], [1334, 1372, 1405, 1405, 1611], [1613, 1633, 1658, 1658, 1815], [1817, 1909, 1948, 1948, 2151], [2153, 2216, 2234, 2234, 2362], [2364, 2364, 2383, 2383, 2511], [2513, 2612, 2646, 2646, 2833], [2835, 2844, 2867, 2867, 3163], [3165, 3175, 3203, 3203, 3264], [3266, 3266, 3295, 3295, 3370], [3372, 3382, 3407, 3407, 3624], [3626, 3640, 3691, 3691, 4159]], "test": "valid"}
{"id": "ttcfRs", "name": "N-Focal Ellipse DE", "author": "oneshade", "description": "Distance estimate to n-focal ellipse.", "tags": ["distance", "de", "ellipse", "bound", "nfocalellipse", "foci"], "likes": 4, "viewed": 54, "published": "Public", "date": "1613248714", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define FOCI 10\n\n// Not exact (but it tries to be)\nfloat sdNFocalEllipse(in vec2 p, in vec2[FOCI] foci, in float e) {\n    vec2 g = vec2(0.0);\n    float d = length(p - foci[0]);\n    for (int fp=1; fp < foci.length(); fp++) {\n        vec2 tf = p - foci[fp];\n        float l = length(tf);\n        g += tf / l;\n        d += l;\n    }\n\n    return (d - e) / length(g);\n}\n\nfloat Hash11(in float x) {\n    return fract(593.594 * cos(x * 695.395));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n    float time = iTime * 2.0;\n\n    float fd = 1000000.0;\n    vec2[FOCI] foci;\n    for (int fp=0; fp < FOCI; fp++) {\n        float id = float(fp);\n        float o11 = Hash11(id * 594.394 + 284.958) + 0.5;\n        float o21 = Hash11(id * 264.596 + 476.694) + 0.5;\n        float o12 = Hash11(id * 395.472 + 395.483) + 0.5;\n        float o22 = Hash11(id * 953.385 + 395.584) + 0.5;\n        float s1 = Hash11(id * 294.495 + 284.585) + 0.5;\n        float s2 = Hash11(id * 848.384 + 385.485) + 0.5;\n\n        vec2 scale = vec2(0.25 * (iResolution.x / iResolution.y), 0.25);\n        foci[fp] = vec2(cos(time * o11 + o21) * s1, sin(time * o12 + o22) * s2) * scale;\n        fd = min(fd, length(uv - foci[fp]) - 0.02);\n    }\n\n    float d = sdNFocalEllipse(uv, foci, 4.5);\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(d) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 1.0 - exp(-4.0 * abs(d));\n\tcolor *= 0.8 + 0.2 * cos(140.0 * d);\n\tcolor = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(d)));\n\n    fragColor = vec4(mix(color, vec3(0.25, 0.25, 1.0), smoothstep(unit, 0.0, fd)), 1.0);\n    fragColor -= smoothstep(unit * 0.75, 0.0, abs(fd));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcfRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 51, 117, 117, 363], [365, 365, 391, 391, 439], [441, 441, 496, 496, 1734]], "test": "valid"}
{"id": "ttcfzS", "name": "voronoi_practice02", "author": "cghow", "description": "voronoi_practice02", "tags": ["voronoipractice02"], "likes": 1, "viewed": 58, "published": "Public", "date": "1612949680", "time_retrieved": "2021-10-01T00:00:00", "image_code": " vec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n\n  { \n\n    vec2 uv = fragCoord.xy/iResolution.xy;\n   \n    vec3 color = vec3(.0);\n\n    // Scale\n    uv *= 5.;\n    uv = uv*2.-1.;\nuv = atan(uv)*10.;\n    \n    vec2 i_st = floor(uv);\n    vec2 f_st = fract(uv);\n\n    float m_dist = 1.;  \n\n    for (int y= -1; y <= 1; y++) {\n        for (int x= -1; x <= 1; x++) {\n            \n            vec2 neighbor = vec2(float(x),float(y));\n\n            \n            vec2 point = random2(i_st + neighbor);\n\n\t\t\t\n            point = 0.5 + 0.5*sin(iTime + 6.2831*point);\n\n\t\t\t\n            vec2 diff = neighbor + point - f_st;\n\n           \n            float dist = length(diff);\n\n          \n            m_dist = min(m_dist, dist);\n        }\n    }\n\n    \n    color += m_dist;\n\n    \n    color += 1.-step(.02, m_dist);\n\n    \n    color.r += step(.98, f_st.x) + step(.98, f_st.y);\n\n \n\n    fragColor = vec4(color,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcfzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 25, 25, 118], [119, 119, 179, 179, 1015]], "test": "valid"}
{"id": "ttdBRf", "name": "Fractal 26_gaz", "author": "gaz", "description": "3d", "tags": ["fractal"], "likes": 13, "viewed": 222, "published": "Public", "date": "1613188661", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)cos(h*6.3+vec3(0,23,21))*.5+.5\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 r=iResolution,p;  \n    for(float i=0.,g,e,s;\n        ++i<99.;\n        (e<.002)?O.xyz+=mix(r/r,H(log(s)*.25),.7)*1./i:p\n    )\n    {\n        p=g*vec3((C-.5*r.xy)/r.y,1);\n        p.z-=6.;\n        p=R(p,normalize(vec3(1,1,0)),iTime*.3);\n        p.y-=.5;\n        p.xz=vec2(atan(p.z,p.x),length(p.xz)-2.5);\n        \n        // Added at Lumos request\n        #if 1\n        if(length(p.yz)<.5)p=R(p,vec3(1,0,0),-iTime);\n        else if(length(p.yz)<1.2)p=R(p,vec3(1,0,0),iTime);\n        #else\n        if(length(p.yz)<.5)p.x-=iTime;\n        else if(length(p.yz)<1.2)p.x+=iTime;;\n        p.x=mod(p.x,6.28)-3.14;\n        #endif\n        // -----------------------\n        \n        p.yz=vec2(atan(p.z,p.y),length(p.yz)-1.);\n        p.z=abs(p.z)-.3;\n        p.z=abs(p.z)-.3;\n        s=3.;\n        for(int j=0;j++<8;)\n            s*=e=2.3/clamp(dot(p,p),.1,1.6),\n            p=abs(p)*e-vec3(6.5,2,.005);\n        g+=e=length(p.xz)/s;\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttdBRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 102, 138, 138, 1088]], "test": "valid"}
{"id": "ttdBz7", "name": "Floating Heart", "author": "icaroleles1", "description": "Floating Heart. Very Simple water by voronoi on a plane ", "tags": ["heart"], "likes": 10, "viewed": 182, "published": "Public", "date": "1612543938", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float r) {\n    float s = sin(r);\n    float c = cos(r);\n    return mat2(c, -s, s, c);\n}\n\n\nvec2 h22(vec2 p)\n{\n    vec3 a = fract(p.xyx * vec3(123.34, 234.34, 345.65));\n    a += dot(a, a + 34.45);\n    return fract(vec2(a.x * a.y, a.y * a.z));\n}\n\nvec2 hashQuad(float t){\n\n    return vec2(fract (sin(8324.*t)*144455.), fract(sin(1138754.*t)*432.));\n\n}\n\nfloat voronoi(vec2 uv, float t) {\n    float minDist = 100.0;\n    float cellIndex = 0.0;\n    \n\n    vec2 gv = fract(uv)-0.5;\n    vec2 id = floor(uv);\n    vec2 cid = vec2(0.0);\n\n    for(float y = -1.0; y <= 1.0; y++)\n    {\n        for(float x = -1.0; x <= 1.0; x++)\n        {\n            vec2 offs = vec2(x, y);\n\n            vec2 n = h22(id+offs);\n            vec2 p = offs+sin(n*t)*0.5;\n            float d = length(gv-p);\n\n            if(d<minDist)\n            {\n                minDist = d;\n                cid = id+offs;\n            }\n        }\n    }\n    \n    return minDist;\n}\n\nvec2 mapScene(vec3 p ){\n\n      float v = voronoi(p.xz*0.1, (iTime*1.5));\n    v *= voronoi(p.xz*0.15*rot(3.141*0.125), (iTime*1.952)+251.0);\n    v *= 0.75;\n    v += 0.5;\n    \n    float pd = smoothstep(p.y, 0.0, v);\n    \n    return vec2(pd*p.y,1.0);\n}\n\nvec2 rayMarch(vec3 ro,vec3 rd){\n    float dO = 0.;\n    vec2 d;\n    for(int i=0;i<100;i++){\n     vec3 p = ro + rd*dO;\n        d = mapScene(p);\n        \n\n        dO+=d.x;\n        if(d.x >100.0|| abs(d.x)<.01)\n            break;\n\n    }\n        float id=d.y;\n        float dist = dO;\n    \n    return vec2(dist,id);\n}\n\n\n\nvec3 shadeWater(vec3 p){\n\n      vec3 color = vec3(.4,.5,.7) *.6*p.y*1.3;\n  for(float i = 0. ; i < 100.; i++){\n       vec2 dir = hashQuad(i)-.5;\n       \n      float d = length(p.xz - vec2(dir.x*50.7,dir.y*80.4));\n      float brightness = .0192;\n      color +=(brightness /d) * vec3(.9,.7,.1);\n       }\n       \n\n\n\treturn  color;\n}\n\nvec3 shadeScene(vec3 p,vec3 ro,vec3 uv,float geometry){\n    \n\nreturn shadeWater(p);\n   \n}\n\nvec3 heart(vec3 uv, float time){\n\n    vec3 col = vec3(0);\n     uv.z+= sqrt(abs(uv.x))*.5;\n     \n     float d = length(uv.xz);\n     float brightness = 2.12;\n     col+=(brightness/d*.5) * vec3(.9,.3,.5);\n       \n     \n    \nreturn col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n \n \n    vec3 color = vec3(-.2);\n    \n    vec3 ro = vec3(cos(iTime*.09)*10.    ,6.9,14. );\n    vec3 ta = vec3(0,5,2);\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 rd = ca *normalize(vec3(uv,1.0));\n\n    vec2 scene = rayMarch(ro,rd);\n    vec3 point = ro + rd*scene.x;\n  \n    if(scene.x<=100. && scene.x>.01){\n    \n            color = shadeScene(point,ro,rd,scene.y);  \n            color+= mix(color *.1,vec3(smoothstep(.01,.09,.006/length(uv-vec2(.0,.2)))),abs(point.z)*(uv.y*.88));\n            \n            color+=heart(point ,.0);\n            \n         }\n\n    else{\n       color +=vec3(.4,.3,.5);\n       color+= smoothstep(.001,.03,.003/(length(uv-vec2(.0,.2))))*vec3(.8768,.865,.98322775);\n\n\n       for(float i = 0. ; i < 30.; i++){\n       vec2 dir = hashQuad(i)-.5;\n       \n      float d = length(uv.xy - vec2(dir.x*1.7,.3+dir.y*.4));\n      \n      float brightness = .00112;\n      color +=(brightness /d) * vec3(.9,.7,.1);\n      color +=1.2/length(point.xz) * vec3(.9,.7,.9);\n\n       }\n    }\n        // Output to screen\n    float GAMMA = 2.2;\n    color = pow(color,vec3(GAMMA));\n    \n  //  color = color / (vec3(vec3(1)+color));\n    fragColor = vec4((color.xyz),1.0);\n}", "image_inputs": [{"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttdBz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 95], [98, 98, 116, 116, 250], [252, 252, 275, 275, 355], [357, 357, 390, 390, 935], [937, 937, 960, 960, 1186], [1188, 1188, 1219, 1219, 1500], [1504, 1504, 1528, 1528, 1832], [1834, 1834, 1889, 1889, 1923], [1925, 1925, 1957, 1957, 2159], [2161, 2161, 2213, 2213, 2390], [2393, 2393, 2450, 2450, 3685]], "test": "valid"}
{"id": "ttdBzH", "name": "Made something really weird", "author": "LowSpecCorgi", "description": "idfk what this is supposed to be", "tags": ["noise", "random", "weird"], "likes": 3, "viewed": 212, "published": "Public API", "date": "1612281246", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author:\n// Title:\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Plot a line on Y using a value between 0.0-1.0\nfloat plot(vec2 st, float pct) {    \n    return smoothstep( pct-0.01, pct, st.y) -\n          smoothstep( pct, pct+0.970, st.y);\n}\n\n\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = gl_FragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n    st *= tan(st.x);\n    vec3 color = vec3(sin(iTime)-plot(st, snoise(cos(st * 1.5) * 4.456 + iTime)) * 50.0,sin(iTime * 3.0)-plot(st, snoise(sin(st * 2.0) * 4.456 + iTime)) * 50.0,  sin(iTime * 2.0)-plot(st, snoise(tan(st * 1.392) * 4.456 + iTime)) * 50.0);\n\n    fragColor = vec4(color,2.000);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttdBzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 69, 90, 90, 137], [138, 138, 159, 159, 206], [207, 207, 229, 229, 264], [266, 266, 290, 290, 397], [399, 449, 481, 481, 578], [582, 582, 604, 604, 1652], [1654, 1654, 1711, 1711, 2095]], "test": "valid"}
{"id": "ttdBzl", "name": "Misty Terraces", "author": "dr2", "description": "Terraced landscape with gliders and varying fog (mouseable)", "tags": ["terrain", "fog", "glider", "flight"], "likes": 15, "viewed": 199, "published": "Public API", "date": "1613310785", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Misty Terraces\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat BumpFbm3 (vec3 p);\nfloat Hashfv3 (vec3 p);\nvec2 Noisev2v4 (vec4 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define AA  0   // (= 0/1) optional antialiasing\n\nmat3 flyerMat[3], flMat;\nvec3 flyerPos[3], qHit, flPos, trkA, trkF, sunDir, noiseDisp;\nfloat tCur, dstFar, grhtMax, fogAmp, fogTop;\nint idObj;\nconst float pi = 3.14159;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat GrndHtS (vec2 p)\n{\n  p = vec2 (p.x + p.y, p.x - p.y) / sqrt(2.);\n  return grhtMax * Fbm2 (0.1 * p);\n}\n\nfloat GrndHt (vec2 p)\n{\n  float h, hh, nf, nl;\n  p = vec2 (p.x + p.y, p.x - p.y) / sqrt(2.);\n  nf = 0.5;\n  p = (floor (nf * p) +  smoothstep (0.2, 1., mod (nf * p, 1.))) / nf;\n  hh = Fbm2 (0.1 * p);\n  nl = 32.;\n  h = grhtMax * (floor (nl * hh) + smoothstep (0.4, 0.6, mod (nl * hh, 1.))) / nl + 0.05 * hh;\n  return h;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.1, 0.5 * h);\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = VAR_ZERO; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (p.y > GrndHt (p.xz)) sLo = s;\n      else sHi = s;\n    }\n    dHit = 0.5 * (sLo + sHi);\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  return normalize (vec3 (GrndHt (p.xz) - vec2 (GrndHt (p.xz + e.xy), GrndHt (p.xz + e.yx)), e.x).xzy);\n}\n\nfloat GrndSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    p = ro + d * rd;\n    h = p.y - GrndHt (p.xz);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq;\n  float dMin, d, a, szFac;\n  szFac = 1.3;\n  a = 0.22 * pi;\n  dMin = dstFar / szFac;\n  for (int k = VAR_ZERO; k < 3; k ++) {\n    q = flyerMat[k] * (p - flyerPos[k]) / szFac;\n    q.x = abs (q.x);\n    q.z += 0.25;\n    qq = q;\n    qq.xy = Rot2D (vec2 (abs (qq.x), qq.y), - a);\n    d = abs (max (max (abs (Rot2D (vec2 (abs (Rot2D (vec2 (qq.x, qq.z - 1.1), -0.012 * pi).x), qq.y), a).y) -\n       0.002, 0.), max (dot (q.xz, sin (0.15 * pi + vec2 (0.5 * pi, 0.))) - 0.5, - q.z - 0.5))) - 0.002;\n    DMINQ (1 + k);\n  }\n  return szFac * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0005, -0.0005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 SkyBg (vec3 rd)\n{\n  return mix (vec3 (0.3, 0.4, 0.8), vec3 (0.7, 0.7, 0.8), pow (1. - max (rd.y, 0.), 8.));\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col, skyCol, p, clCol;\n  float fd, f, ff;\n  if (rd.y > 0.) {\n    p = 0.01 * (rd * (100. - ro.y) / max (rd.y, 0.0001) + ro + 4. * tCur);\n    ff = Fbm2 (p.xz);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (p.xz + 0.01 * sunDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.8) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    fd = smoothstep (0.01, 0.1, rd.y);\n    col = mix (mix (vec3 (0.7, 0.7, 0.75), vec3 (0.5, 0.6, 0.9), 0.3 + 0.7 * fd),\n       clCol, 0.1 + 0.9 * f * fd) + 0.2 * vec3 (1., 1., 0.9) * pow (max (dot (rd, sunDir), 0.), 2048.);\n    col = mix (col, SkyBg (rd), pow (1. - max (rd.y, 0.), 8.));\n  } else col = SkyBg (rd);\n  return col;\n}\n\nfloat FogHt (vec2 p)\n{\n  mat2 qRot;\n  vec4 t4;\n  vec2 q, t, tw;\n  float a, h;\n  qRot = mat2 (0.8, -0.6, 0.6, 0.8);\n  q = p + vec2 (0., 0.05 * tCur);\n  a = 1.;\n  h = 0.;\n  tw = 0.05 * tCur * vec2 (1., -1.);\n  for (int j = 0; j < 5; j ++) {\n    q *= 2. * qRot;\n    t4 = abs (sin (2. * (q.xyxy + tw.xxyy) + 2. * Noisev2v4 (t4).xxyy - 1.));\n    t4 = (1. - t4) * (t4 + sqrt (1. - t4 * t4));\n    t = 1. - sqrt (t4.xz * t4.yw);\n    t *= t;\n    h += a * dot (t, t);\n    a *= 0.5;\n  }\n  return fogTop - 0.5 * h;\n}\n\nfloat FogDens (vec3 p)\n{\n  return fogAmp * (0.2 + 0.8 * smoothstep (0., 1., 1. - p.y / fogTop)) *\n     BumpFbm3 (0.03 * (p + noiseDisp)) * smoothstep (0., 1., FogHt (0.1 * p.xz) - p.y);\n}\n\nvec3 FogCol (vec3 col, vec3 ro, vec3 rd, float dHit)\n{  // updated from \"Sailing Home\"\n  float s, ds, f, fn;\n  s = 1.;\n  ds = 1.;\n  fn = FogDens (ro + s * rd);\n  for (int j = VAR_ZERO; j < 40; j ++) {\n    s += ds;\n    f = fn;\n    fn = FogDens (ro + (s + 0.5 * ds * Hashfv3 (16. * rd)) * rd);\n    col = mix (col, vec3 (0.9, 0.9, 0.95) * (1. - clamp (f - fn, 0., 1.)),\n       min (f * (1. - smoothstep (0.3 * dHit, dHit, s)), 1.));\n    if (s > dHit) break;\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 roo, col, c, vn;\n  float dstGrnd, dstObj, sh, df;\n  noiseDisp = 0.02 * vec3 (-1., 0., 1.) * tCur + 0.5 * sin (vec3 (0.2, 0.1, 0.3) * pi * tCur);\n  fogAmp = 0.2 + 0.8 * SmoothBump (0.25, 0.75, 0.22, mod (0.03 * tCur, 1.));\n  fogTop = grhtMax + 3.;\n  roo = ro;\n  dstGrnd = GrndRay (ro, rd);\n  dstObj = ObjRay (ro, rd);\n  if (min (dstObj, dstGrnd) < dstFar) {\n    if (dstObj < dstGrnd) {\n      ro += dstObj * rd;\n      c = vec3 (0.3, 0.3, 1.);\n      col = (idObj == 1) ? c : ((idObj == 2) ? c.gbr : c.brg);\n      col = mix (col, 1. - col, smoothstep (0.02, 0.04, abs (length (vec2 (qHit.xz - vec2 (0.3, -0.1))) - 0.17)) *\n        (1. - smoothstep (0.95, 0.97, qHit.z)));\n      vn = ObjNf (ro);\n      sh = ObjSShadow (ro + 0.01 * vn, sunDir);\n    } else if (dstGrnd < dstFar) {\n      ro += dstGrnd * rd;\n      df = dstGrnd / dstFar;\n      vn = GrndNf (ro);\n      vn = VaryNf ((1. + 4. * smoothstep (0.8, 0.9, vn.y)) * ro, vn, 1. - smoothstep (0.3, 0.7, df));\n      col = mix (vec3 (0.8, 0.7, 0.4) * (1. - 0.15 * (1. - smoothstep (0.3, 0.7, df)) *\n         smoothstep (0.4, 0.45, abs (mod (16. * ro.y, 1.) - 0.5))), vec3 (0.4, 1., 0.4), smoothstep (0.8, 0.9, vn.y));\n      col *= 0.4 + 0.6 * smoothstep (0.1, 0.9, ro.y / grhtMax);\n      col *= 1. - 0.3 * Fbm2 (128. * ro.xz);\n      sh = GrndSShadow (ro + 0.01 * vn, sunDir);\n    }\n    col *= 0.2 + 0.2 * max (dot (vn, normalize (vec3 (- sunDir.xz, 0.).xzy)), 0.) +\n       0.8 * sh * max (dot (vn, sunDir), 0.);\n    col = mix (col, SkyBg (rd), pow (df, 8.));\n  } else {\n    col = SkyCol (ro, rd);\n  }\n  col = FogCol (col, roo, rd, min (dstGrnd, dstObj));\n  return clamp (col, 0., 1.);\n}\n\nvec3 GlareCol (vec3 rd, vec3 sd, vec2 uv)\n{\n  vec3 col, e;\n  vec2 sa, hax;\n  e = vec3 (1., 0., -1.);\n  hax = vec2 (0.5 * sqrt (3.), 0.5);\n  uv *= 2.;\n  col = vec3 (0.);\n  if (sd.z > 0.) {\n    sa = uv + 0.3 * sd.xy;\n    col = 0.1 * pow (sd.z, 8.) * (1.5 * e.xyy * max (dot (normalize (rd + vec3 (0., 0.3, 0.)), sunDir), 0.) +\n       e.xxy * (1. - smoothstep (0.11, 0.12, max (abs (sa.y), max (abs (dot (sa, hax)), abs (dot (sa, hax * e.xz)))))) +\n       e.xyx * SmoothBump (0.32, 0.4, 0.04, length (uv - 0.7 * sd.xy)) +\n       0.8 * e.yxx * SmoothBump (0.72, 0.8, 0.04, length (uv + sd.xy)));\n  }\n  return col;\n}\n\nvec3 TrkPath (float t)\n{\n  return vec3 (dot (trkA, sin (trkF * t)), 0., t);\n}\n\nvec3 TrkVel (float t)\n{\n  return vec3 (dot (trkF * trkA, cos (trkF * t)), 0., 1.);\n}\n\nvec3 TrkAcc (float t)\n{\n  return vec3 (dot (trkF * trkF * trkA, - sin (trkF * t)), 0., 0.);\n}\n\nvoid FlyerPM (float t, int isOb)\n{\n  vec3 vel, va, flVd;\n  vec2 cs;\n  float oRl;\n  flPos = TrkPath (t);\n  vel = TrkVel (t);\n  va = cross (TrkAcc (t), vel) / length (vel);\n  flVd = normalize (vel);\n  oRl = ((isOb > 0) ? 5. : 10.) * length (va) * sign (va.y);\n  cs = sin (oRl + vec2 (0.5 * pi, 0.));\n  flMat = mat3 (cs.x, - cs.y, 0., cs.y, cs.x, 0., 0., 0., 1.) *\n     mat3 (flVd.z, 0., flVd.x, 0., 1., 0., - flVd.x, 0., flVd.z);\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, flyVel, vDir, hSum, t, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.07 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  el = clamp (el, -0.3 * pi, 0.3 * pi);\n  grhtMax = 11.;\n  flyVel = 2.;\n  trkA = 0.2 * vec3 (1.9, 2.9, 4.3);\n  trkF = vec3 (0.23, 0.17, 0.13);\n  vDir = sign (0.5 * pi - abs (az));\n  for (int k = VAR_ZERO; k < 3; k ++) {\n    t = flyVel * tCur + vDir * (8. + 5. * float (k));\n    FlyerPM (t, 0);\n    flyerMat[k] = flMat;\n    flyerPos[k] = flPos;\n    flyerPos[k].x += 0.5 * sin (0.1 * pi * t);\n    hSum = 0.;\n    for (float j = float (VAR_ZERO); j < 7.; j ++) hSum += GrndHtS (TrkPath (t + vDir * (j - 1.)).xz);\n    flyerPos[k].y = grhtMax - 2. + hSum / 7.;\n  }\n  t = flyVel * tCur;\n  FlyerPM (t, 1);\n  ro = flPos;\n  hSum = 0.;\n  for (float j = float (VAR_ZERO); j < 7.; j ++) hSum += GrndHtS (TrkPath (t + 1.5 * vDir * (j - 1.)).xz);\n  ro.y = grhtMax + hSum / 7.;\n  vuMat = StdVuMat (el, az);\n  sunDir = normalize (vec3 (0., 1.3, -1.));\n  sunDir.xz = Rot2D (sunDir.xz, 0.6 * pi * sin (0.02 * pi * tCur));\n  zmFac = 3.;\n  dstFar = 120.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    rd = (vuMat * rd) * flMat;\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  col += GlareCol ((vuMat * normalize (vec3 (uv, zmFac))) * flMat, (flMat * sunDir) * vuMat, uv);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat PerBumpf (float p)\n{\n  return 0.5 * smoothstep (0., 0.5, abs (fract (p) - 0.5));\n}\n\nvec3 PerBumpv3 (vec3 p)\n{\n  return 0.5 * smoothstep (0., 0.5, abs (fract (p) - 0.5));\n}\n\nfloat BumpFbm3 (vec3 p)\n{  // from \"Energy Temple\"\n  vec3 q;\n  float a, f;\n  a = 1.;\n  f = 0.;\n  q = p;\n  for (int j = 0; j < 4; j ++) {\n    p += PerBumpv3 (q + PerBumpv3 (q).yzx);\n    p *= 1.5;\n    f += a * (PerBumpf (p.z + PerBumpf (p.x + PerBumpf (p.y))));\n    q = 2. * q + 0.5;\n    a *= 0.75;\n  }\n  return f;\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, vec3 (37., 39., 41.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + vec4 (0., 1., 57., 58.)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nvec2 Noisev2v4 (vec4 p)\n{\n  vec4 ip, fp, t1, t2;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t1 = Hashv4f (dot (ip.xy, vec2 (1., 57.)));\n  t2 = Hashv4f (dot (ip.zw, vec2 (1., 57.)));\n  return vec2 (mix (mix (t1.x, t1.y, fp.x), mix (t1.z, t1.w, fp.x), fp.y),\n               mix (mix (t2.x, t2.y, fp.z), mix (t2.z, t2.w, fp.z), fp.w));\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttdBzl.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 705, 729, 729, 812], [814, 814, 837, 837, 1133], [1135, 1135, 1169, 1169, 1649], [1651, 1651, 1673, 1673, 1812], [1814, 1814, 1852, 1852, 2112], [2114, 2114, 2136, 2136, 2686], [2688, 2688, 2721, 2721, 2904], [2906, 2906, 2927, 2927, 3184], [3186, 3186, 3223, 3223, 3452], [3454, 3454, 3476, 3476, 3568], [3570, 3570, 3602, 3602, 4329], [4331, 4331, 4353, 4353, 4835], [4837, 4837, 4861, 4861, 5024], [5026, 5026, 5080, 5112, 5500], [5502, 5502, 5537, 5537, 7188], [7190, 7190, 7233, 7233, 7801], [7803, 7803, 7827, 7827, 7880], [7882, 7882, 7905, 7905, 7966], [7968, 7968, 7991, 7991, 8061], [8063, 8063, 8097, 8097, 8492], [8494, 8494, 8547, 8547, 10425], [10427, 10427, 10484, 10484, 10567], [10569, 10569, 10605, 10605, 10811], [10813, 10813, 10843, 10843, 10956], [10958, 10958, 10984, 10984, 11046], [11048, 11048, 11073, 11073, 11135], [11137, 11137, 11162, 11187, 11451], [11485, 11485, 11509, 11509, 11574], [11576, 11576, 11600, 11600, 11730], [11732, 11732, 11756, 11756, 11819], [11821, 11821, 11846, 11846, 12032], [12034, 12034, 12059, 12059, 12396], [12398, 12398, 12419, 12419, 12574], [12576, 12576, 12605, 12605, 12817], [12819, 12819, 12858, 12858, 13038]], "test": "error"}
{"id": "ttdBzS", "name": "Sine flow", "author": "DukeOfStraylight", "description": "Late-night sine sins.", "tags": ["sin"], "likes": 3, "viewed": 171, "published": "Public API", "date": "1612990713", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = 3.14159;\n\nfloat hash11(float n) {\n    return fract(sin(n*434.4)*543.2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    uv *= 10.;\n    uv.x += iTime * .5;\n    vec3 col = vec3(0.);\n    float f = floor(uv.y - 1.);\n\n    for (float i = 0.; i < 4.; i += 1.0) {\n        float n = i + f;\n        float c = smoothstep(0.8, 0.5, abs(uv.y - n - sin(uv.x*0.5)));\n        col = col + (c * cos(uv.x*0.5 + hash11(n)*10.*iTime*vec3(.2,.5,.7)));\n    }\n\n\n// Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttdBzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 50, 50, 90], [92, 92, 149, 149, 563]], "test": "valid"}
{"id": "ttdfz2", "name": "Fractal 23_gaz", "author": "gaz", "description": "3d", "tags": ["fractal"], "likes": 14, "viewed": 177, "published": "Public", "date": "1613117379", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)cos(h*6.3+vec3(0,23,21))*.5+.5\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 r=iResolution,p;  \n    for(float i=0.,g,e,s;\n        ++i<99.;\n        (e<.001)?O.xyz+=mix(r/r,H(g),.6)*.8/i:p\n    )\n    {\n        p=g*vec3((C-.5*r.xy)/r.y,1);\n        p.z-=1.;\n        p=R(p,normalize(vec3(1,3,3)),iTime*.2);\n        s=3.;\n        for(int j=0;++j<5;)\n            s*=e=1./min(dot(p,p),1.),\n            p=abs(p)*e-1.5;\n        g+=e=length(p.xy)/s;\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttdfz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 102, 138, 138, 531]], "test": "valid"}
{"id": "ttGBRG", "name": "Strange projections", "author": "vegardno", "description": "Asdf", "tags": ["asdf"], "likes": 3, "viewed": 52, "published": "Public", "date": "1614546475", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 mul(vec2 a, vec2 b)\n{\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    uv *= 1.2;\n\n    uv = mul(uv, uv) + vec2(.5, .9);\n    uv = mul(uv, uv) + vec2(cos(radians(30.) * iTime), sin(radians(35.) * iTime));\n    uv = mul(uv, uv) + vec2(10., -2.);\n    uv = mix(uv, normalize(uv), 1.5);\n    uv.x = abs(uv.x) - 5.;\n    uv.y = abs(uv.y) - 3.;\n    uv = mul(uv, uv) + 0. * iTime;\n\n    uv = mix(uv, 3. * uv / normalize(uv), sin(radians(15.) * iTime));\n\n    vec3 col = 0.5 + 0.5*cos(radians(360.) * iTime+uv.xyx+vec3(0,2,4));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGBRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 91], [93, 93, 150, 150, 694]], "test": "valid"}
{"id": "ttGBWR", "name": "Blotting", "author": "bboettcher3", "description": "neon blot filter. Click and drag your mouse vertically to change the color and smile type.", "tags": ["lines", "x", "smile", "neon", "blot", "blotting"], "likes": 4, "viewed": 100, "published": "Public", "date": "1614252236", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance to a 2D rounded X shape. It is exact in the\n// exterior, and a bound in the interior.\n\n// List of some other 2D distances:\n//\n// Circle:               https://www.shadertoy.com/view/3ltSW2\n// Segment:              https://www.shadertoy.com/view/3tdSDj\n// Triangle:             https://www.shadertoy.com/view/XsXSz4\n// Isosceles Triangle:   https://www.shadertoy.com/view/MldcD7\n// Regular Triangle:     https://www.shadertoy.com/view/Xl2yDW\n// Regular Pentagon:     https://www.shadertoy.com/view/llVyWW\n// Regular Octogon:      https://www.shadertoy.com/view/llGfDG\n// Rounded Rectangle:    https://www.shadertoy.com/view/4llXD7\n// Rhombus:              https://www.shadertoy.com/view/XdXcRB\n// Trapezoid:            https://www.shadertoy.com/view/MlycD3\n// Polygon:              https://www.shadertoy.com/view/wdBXRW\n// Hexagram:             https://www.shadertoy.com/view/tt23RR\n// Regular Star:         https://www.shadertoy.com/view/3tSGDy\n// Star5:                https://www.shadertoy.com/view/wlcGzB\n// Ellipse 1:            https://www.shadertoy.com/view/4sS3zz\n// Ellipse 2:            https://www.shadertoy.com/view/4lsXDN\n// Quadratic Bezier:     https://www.shadertoy.com/view/MlKcDD\n// Uneven Capsule:       https://www.shadertoy.com/view/4lcBWn\n// Vesica:               https://www.shadertoy.com/view/XtVfRW\n// Cross:                https://www.shadertoy.com/view/XtGfzw\n// Pie:                  https://www.shadertoy.com/view/3l23RK\n// Arc:                  https://www.shadertoy.com/view/wl23RK\n// Horseshoe:            https://www.shadertoy.com/view/WlSGW1\n// Parabola:             https://www.shadertoy.com/view/ws3GD7\n// Parabola Segment:     https://www.shadertoy.com/view/3lSczz\n// Rounded X:            https://www.shadertoy.com/view/3dKSDc\n// Joint:                https://www.shadertoy.com/view/WldGWM\n// Simple Egg:           https://www.shadertoy.com/view/Wdjfz3\n//\n// and many more here:   http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\nfloat intensity = 2.;\nfloat ra = 0.04;\nfloat wi = .15;\nvec2 faceCenter = vec2(0.5, .8);\nvec2 eyeOffset = vec2(.15, 0.0);\nvec2 mouthOffset = vec2(0.0, -0.5);\nfloat smileLen = .79; /* Arc len */\nfloat smileWidth = 0.05; /* Width */\nfloat smileRa = .6;\n\nfloat sdRoundedX( in vec2 p, in float w, in float r )\n{\n    p = abs(p);\n    return length(p-min(p.x+p.y,w)*0.5);\n}\n\nfloat sdCircle( in vec2 p, in float r ) \n{\n    return abs(length(p)-r);\n}\n\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h =clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa-h*ba);\n}\n\n// scb is the sin/cos of the aperture\nfloat sdArc( in vec2 p, in vec2 scb, in float ra, in float rb )\n{\n    p *= mat2(1.,0.,0.,1.);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p);\n    k *= 2.;\n    return sqrt( dot(p,p) + ra * (ra - k) ) - rb;\n}\n\nfloat sdSmile(in vec2 p, in float radius) {\n    return abs(sdArc(p,vec2(sin(smileLen),cos(smileLen)), radius, smileWidth));\n}\n\nfloat getGlow(float dist, float radius, float intensity){\n    return pow(radius/dist, intensity);\n}\n\n/* Returns rgb vec from input 0-1 */\nvec3 getRainbowColor(in float val) {\n    /*convert to rainbow RGB*/\n    float a = (1.0 - val) * 6.0;\n    int X = int(floor(a));\n    float Y = a - float(X);\n    float r = 0.;\n    float g = 0.;\n    float b = 0.;\n    if (X == 0) {\n        r = 1.; g = Y; b = 0.;\n    } else if (X == 1) {\n        r = 1. - Y; g = 1.; b = 0.;\n    } else if (X == 2) {\n        r = 0.; g = 1.; b = Y;\n    } else if (X == 3) {\n        r = 0.; g = 1. - Y; b = 1.;\n    } else if (X == 4) {\n        r = Y; g = 0.; b = 1.;\n    } else if (X == 5) {\n        r = 1.; g = 0.; b = 1. - Y;\n    } else {\n        r = 0.; g = 0.; b = 0.;\n    }\n    return vec3(r, g, b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float widthHeightRatio = iResolution.x/iResolution.y;\n    vec2 eye1Center = faceCenter - eyeOffset;\n    vec2 eye2Center = faceCenter + eyeOffset;\n    vec2 mouthCenter = faceCenter + mouthOffset;\n    vec2 eye1Pos = eye1Center - uv;\n    vec2 eye2Pos = eye2Center - uv;\n    vec2 mouthPos = mouthCenter - uv;\n    vec2 smilePos = faceCenter - uv;\n    vec2 linePos1 = vec2(0.1, 0.1);\n    vec2 linePos2 = vec2(0.1, 0.9);\n    eye1Pos.y /= widthHeightRatio;\n    eye2Pos.y /= widthHeightRatio;\n    mouthPos.y /= widthHeightRatio;\n    smilePos.y /= widthHeightRatio;\n    //linePos1.y /= widthHeightRatio;\n    //linePos2.y /= widthHeightRatio;\n\n    float lineDist = udSegment(uv, linePos1, linePos2);\n\tfloat eye1Dist = sdRoundedX( eye1Pos, wi, ra );\n    float eye2Dist = sdRoundedX( eye2Pos, wi, ra );\n    float mouthDist = sdCircle(mouthPos, .1);\n    float smileDist = sdSmile(smilePos, smileRa / widthHeightRatio);\n    float glowLine = getGlow(lineDist, ra, intensity);\n    float glowEye1 = getGlow(eye1Dist, ra, intensity);\n    float glowEye2 = getGlow(eye2Dist, ra, intensity);\n    float glowMouth = getGlow(mouthDist, ra, intensity);\n    float glowSmile = getGlow(smileDist, ra, intensity);\n    \n    vec3 col = vec3(0.0);\n    float timeNorm = mod(iTime, 5.) / 5.;\n    vec3 glowCol = getRainbowColor(timeNorm);\n    col += 10.0*vec3(smoothstep(0.006, 0.003, lineDist));\n    col += glowLine * glowCol;\n    col += 10.0*vec3(smoothstep(0.006, 0.003, eye1Dist));\n    col += glowEye1 * glowCol;\n    col += 10.0*vec3(smoothstep(0.006, 0.003, eye2Dist));\n    col += glowEye2 * glowCol;\n    if (timeNorm > 0.5) {\n      col += 1.0*vec3(smoothstep(0.006, 0.003, mouthDist));\n      col += glowMouth * glowCol;\n    } else {\n      col += 10.0*vec3(smoothstep(0.006, 0.003, smileDist));\n      col += glowSmile * glowCol;\n    }\n    \n    \n    /*Tone mapping*/\n    col = 1.0 - exp(-col);\n    /*Gamma*/\n    col = pow(col, vec3(0.6));\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGBWR.jpg", "access": "shaders20k", "license": "mit", "functions": [[3270, 3342, 3397, 3397, 3456], [3458, 3458, 3500, 3500, 3531], [3533, 3533, 3585, 3585, 3708], [3710, 3748, 3813, 3813, 3991], [3993, 3993, 4036, 4036, 4118], [4120, 4120, 4177, 4177, 4219], [4221, 4258, 4294, 4325, 4890], [4892, 4892, 4949, 4949, 6931]], "test": "valid"}
{"id": "ttGfW1", "name": "Wave Distorter", "author": "fluxtransistor", "description": "experiment", "tags": ["experiment"], "likes": 1, "viewed": 34, "published": "Public", "date": "1614249743", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float plot(float y,float yb, float diff) { \n    return smoothstep(yb - diff, yb, y) - smoothstep(yb,yb+diff,y);\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat sine(float x, float y, float iTime, float loc){\n    float n = sin( x*50.0  //frequency\n                              + 5.0  *iTime //speed\n                              + 0.0  *iTime*(loc-0.5) //speed variance\n                              + 0.00  *rand(vec2(loc))*0.0)  //randomness\n                              * 0.02  //amplitude\n                              + loc;\n    return n;\n}\n\nfloat bar(float minx,float maxx,float f, float i, float x, float y){\n    float diff = (maxx-minx)*0.1;\n    if (x>minx && x<maxx && i<0.5) {\n            float s = 1.0 - (1.0- smoothstep(0.0, 0.5,i) ) * (1.0-(1.0-smoothstep(minx,minx+diff,x)*(1.0-smoothstep(maxx-diff,maxx,x))) );\n            return s * (f-i) + i + (1.0-s)*-0.05;\n        }\n    if (x>minx && x<maxx) {\n            float s = 1.0 - (smoothstep(0.5, 1.0,i) ) * (1.0-(1.0-smoothstep(minx,minx+diff,x)*(1.0-smoothstep(maxx-diff,maxx,x))) );\n            return s * (f-i) + i + (1.0-s)*0.05;\n        }\n    return f;\n}\n\nfloat sines(float x, float y, float iTime){\n    float n = 0.0;\n    for(float i=0.0875; i<0.93; i+=0.05){\n        float f = sine(x,y,iTime,i);\n        \n        f = bar(0.46, 0.82, f, i, x, y);\n        f = bar(0.2, 0.3, f, i, x, y);\n       \n        n+=plot(y,f,2.0 / iResolution.y);\n        \n        \n    }\n    return n;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos((iTime*0.1)+uv.xyx+vec3(0,2,4));\n\n    float val = sines(uv.x, uv.y, iTime);\n    \n    vec3 col = vec3(0);\n    col[1] += val;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGfW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 42, 42, 113], [115, 115, 135, 135, 207], [209, 209, 262, 262, 601], [603, 603, 671, 671, 1178], [1180, 1180, 1223, 1223, 1500], [1504, 1504, 1561, 1611, 1901]], "test": "valid"}
{"id": "ttKBWR", "name": "Circle Pulse", "author": "lambmeow", "description": " ", "tags": ["circle"], "likes": 1, "viewed": 156, "published": "Public API", "date": "1614194348", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define PI 3.1415926535\n\n#define time iTime\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //get uv coordinates\n   vec2 uv = (fragCoord.xy - iResolution.xy)/iResolution.y;\n   \n   //set offset and scale\n   uv += vec2(1.4, 1);\n   uv *= 0.5;\n   \n   //store color\n   vec3 color = vec3(0);\n   \n   //create overlap pattern\n  \n   //get circle shape\n   float circle = sin((uv.x + uv.y)* PI ) + cos( (uv.y - uv.x) * PI);\n   \n   //create pulse pattern\n   circle = 1.- mod(circle + time , .3 * pow(time * 0.8, .06));\n        \n   //apply color to pattern\n   color = (vec3(0., .5, .7) * sin(time + circle) + vec3(.5, 0,1) * cos(circle + time * PI) + vec3(1, 0,0))  * circle;\n   \n   \n   fragColor = vec4(color, 0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttKBWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 103, 128, 724]], "test": "valid"}
{"id": "ttKfzD", "name": "Color Distortion & Brick", "author": "csgradle", "description": "Go into full screen mode and stare at the center. makes you feel like you're being sucked in!\n\nI made the brick shader for this, then added noise distortion and chromatic aberration. ", "tags": ["grid", "chromaticaberration", "distortion", "color", "brick", "brick"], "likes": 4, "viewed": 95, "published": "Public", "date": "1614043743", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);\n}\n\n\n\nfloat brick(vec2 st, vec2 size, float thickness) {\n    float xt = fract(st.x*size.x);\n    float yt = fract(st.y*size.y);\n    return step(1.-thickness*(size.x/size.y), xt)+step(1.-thickness,yt);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // fix coordinate pixels\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv-0.5;\n    float screenRatio = iResolution.x/iResolution.y;\n    uv.x *= screenRatio;\n\n    // distort the space with noise\n    vec2 st = uv;\n    float noise = (noise(uv*3.))*2.+0.5;\n    st = uv * scale(vec2(1.+noise));\n    \n    //BRICKS:\n    // green (no scale)\n    float brickScale = 10.*sin(iTime*0.5)+10.001;\n    float green = brick(st, vec2(brickScale), 0.1);\n    // blue and red (scale down and scale up based on distance to center) \n    float difference = length(st)*0.01;\n    vec2 contract = st * scale(vec2(1.-difference));\n    float blue = brick(contract, vec2(brickScale), 0.1);\n    vec2 expand = st * scale(vec2(1.+difference));\n    float red = brick(expand, vec2(brickScale), 0.1);\n    \n    \n    // final color \n    vec3 col = vec3(red, green, blue);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttKfzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 23, 23, 162], [163, 163, 191, 191, 277], [278, 363, 385, 385, 789], [790, 790, 814, 814, 877], [881, 881, 931, 931, 1076], [1077, 1077, 1134, 1163, 2008]], "test": "valid"}
{"id": "tttBRX", "name": "Cubes are dancing", "author": "Flopine", "description": "Improvised during OMZG Shader Royale, here are some cube vibin' to the muuuusiiiiiic ", "tags": ["raymarching", "fft", "animation", "geometry", "isometric"], "likes": 68, "viewed": 2596, "published": "Public", "date": "1613173124", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan, slerpy and wwrighter for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n\n#define PI acos(-1.)\n#define TAU 6.283581\n#define ITER 80.\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define crep(p,c,l) p=p-c*clamp(round(p/c),-l,l)\n\n#define dt(sp,off) fract((iTime+off)*sp)\n#define bouncy(sp,off) sqrt(sin(dt(sp,off)*PI))\n\nstruct obj\n{\n  float d;\n  vec3 cs; \n  vec3 cl;\n};\n\nobj minobj (obj a, obj b)\n{\n  if (a.d<b.d) return a;\n  else return b;\n}\n\nfloat stmin(float a, float b, float k, float n)\n{\n  float st = k/n;\n  float u = b-k;\n  return min(min(a,b),0.5*(u+a+abs(mod(u-a+st,2.*st)-st)));\n}\n\nvoid mo (inout vec2 p, vec2 d)\n{\n  p = abs(p)-d;\n  if(p.y>p.x) p = p.yx;\n}\n\nfloat box (vec3 p, vec3 c)\n{\n  vec3 q = abs(p)-c;\n  return min(0.,max(q.x,max(q.y,q.z)))+length(max(q,0.));\n}\n\nfloat sc (vec3 p, float d)\n{\n  p=abs(p);\n  p=max(p,p.yzx);\n  return min(p.x,min(p.y,p.z))-d;\n}\n\nobj prim1 (vec3 p)\n{\n  p.x = abs(p.x)-3.;\n  float per = 0.9;\n  float id = round(p.y/per);\n  p.xz *= rot(sin(dt(0.8,id*1.2)*TAU));\n  crep(p.y, per,4.);\n  mo(p.xz,vec2(0.3));\n  p.x += bouncy(2.,0.)*0.8;\n  float pd = box(p,vec3(1.5,0.2,0.2));\n  return obj(pd,vec3(0.5,0.,0.),vec3(1.,0.5,0.9));\n}\n\nobj prim2 (vec3 p)\n{\n  p.y = abs(p.y)-6.;\n  p.z = abs(p.z)-4.;\n  mo(p.xz, vec2(1.));\n  vec3 pp = p;\n  mo(p.yz, vec2(0.5));\n  p.y -= 0.5;\n  float p2d = max(-sc(p,0.7),box(p,vec3(1.)));\n  p = pp;\n  p2d = min(p2d, max(box(p,vec3(bouncy(2.,0.))*4.),sc(p,0.2)));\n  return obj(p2d, vec3(0.2),vec3(1.));\n}\n\nobj prim3 (vec3 p)\n{\n  p.z = abs(p.z)-9.;\n  float per = 0.8;\n  vec2 id = round(p.xy/per)-.5;\n  float height = 1.*bouncy(2.,sin(length(id*0.05)));\n  float p3d = box(p,vec3(2.,2.,0.2));\n  crep(p.xy,per,2.);\n  p3d = stmin(p3d,box(p+vec3(0.,0.,height*0.9),vec3(0.15,.15,height)),0.2,3.);\n  return obj (p3d, vec3(0.1,0.7,0.),vec3(1.,0.9,0.));\n}\n\nobj prim4 (vec3 p)\n{\n  p.y = abs(p.y)-5.;\n  mo(p.xz, vec2(1.));\n  float scale = 1.5;\n  p *= scale;\n  float per = 2.*(bouncy(0.5,0.));\n  crep(p.xz,per,2.);\n  float p4d = max(box(p,vec3(0.9)),sc(p,0.25));\n  return obj (p4d/scale, vec3(0.1,0.2,0.4),vec3(0.1,0.8,0.9));\n}\n\nfloat squared (vec3 p,float s)\n{\n  mo(p.zy,vec2(s));\n  return box(p,vec3(0.2,10.,0.2));\n}\n\nobj prim5 (vec3 p)\n{\n  p.x = abs(p.x)-8.;\n  float id = round(p.z/7.);\n  crep(p.z,7.,2.);\n  float scarce = 3.;\n  float p5d=1e10;\n  for(int i=0;i<4; i++)\n  {\n    p.x += bouncy(1.,id*0.9)*0.6;\n    p5d = min(p5d,squared(p,scarce));\n    p.yz *= rot(PI/4.);\n    scarce -= 1.;    \n  }\n  return obj(p5d,vec3(0.5,0.2,0.1),vec3(1.,0.9,0.1));\n}\n\nobj SDF (vec3 p)\n{\n  p.yz *= rot(-atan(1./sqrt(2.)));\n  p.xz *= rot(PI/4.);\n\n  obj scene = prim1(p);\n  scene = minobj(scene,prim2(p));\n  scene = minobj(scene,prim3(p));\n  scene = minobj(scene,prim4(p));\n  scene = minobj(scene, prim5(p));\n  return scene;\n}\n\nvec3 getnorm (vec3 p)\n{\n  vec2 eps = vec2(0.001,0.);\n  return normalize(SDF(p).d-vec3(SDF(p-eps.xyy).d,SDF(p-eps.yxy).d,SDF(p-eps.yyx).d));\n}\n\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n vec2 uv = (2.*fragCoord.xy-iResolution.xy)/ iResolution.y;\n\nvec3 ro = vec3(uv*5.,-30.),rd = vec3(0.,0.,1.),\n  p = ro,\n  col = vec3(smoothstep(0.3,0.65,texture(iChannel0, vec2(length(uv*0.5),0.025)).xxx)),\n  l = normalize(vec3(1.,1.4,-2.));\n\n  obj O; bool hit = false;\n\n  for (float i=0.; i<ITER;i++)\n  {\n   O = SDF(p);\n   if (O.d<0.001)\n   {hit = true; break;}\n   p += O.d*rd;\n  }\n\n  if (hit)\n  {\n    vec3 n = getnorm(p);\n    float light = max(dot(n,l),0.);\n    col = mix(O.cs,O.cl, light);\n  }\n    fragColor = vec4(sqrt(col),1.);\n}", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tttBRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[180, 630, 657, 657, 701], [703, 703, 752, 752, 849], [851, 851, 883, 883, 925], [927, 927, 955, 955, 1036], [1038, 1038, 1066, 1066, 1132], [1134, 1134, 1154, 1154, 1426], [1428, 1428, 1448, 1448, 1726], [1728, 1728, 1748, 1748, 2067], [2069, 2069, 2089, 2089, 2336], [2338, 2338, 2370, 2370, 2427], [2429, 2429, 2449, 2449, 2762], [2764, 2764, 2782, 2782, 3019], [3021, 3021, 3044, 3044, 3162], [3165, 3165, 3221, 3221, 3755]], "test": "error"}
{"id": "tttBWM", "name": "Implosive [HurleybirdJr]", "author": "HurleybirdJr", "description": "Coloured circle with slightly implosive behaviours.", "tags": ["basic"], "likes": 1, "viewed": 52, "published": "Public", "date": "1612883029", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5 * iResolution.xy) / iResolution.xy;\n\n    uv.x *= iResolution.x / iResolution.y; // Fix Aspect Ratio\n\n    float er = 1.5/iResolution.y; // Radius with scaleable AA\n    float d = length(uv); // Distance calcuation\n\n    // Time varying pixel color // Radius, AA\n    vec3 c = fract(smoothstep(sin(iTime), 0.2-er, length(uv))-cos(iTime*.2+uv.xyx+vec3(2,2,6)));\n\n    // Output to screen\n    fragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tttBWM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 549]], "test": "valid"}
{"id": "tttfDn", "name": "Carpet pattern #0 remix: Shining", "author": "TWal", "description": "Remix of [url=https://www.shadertoy.com/view/ttcfR4]Carpet pattern #0[/url] to implement the Overlook Hotel carpet from The Shining.\nThanks to [url=https://www.shadertoy.com/user/ollj]ollj[/url] for noticing the similarity of the carpet from The Shining!", "tags": ["hexagon", "tiling", "carpet", "wallpapergroup", "shining", "pmg"], "likes": 6, "viewed": 86, "published": "Public", "date": "1612551381", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/////////////////////\n//Version using sdf//\n/////////////////////\n#if 1\n//Thanks iq for the 2d sdf!\nfloat sdHexagon( in vec2 p, in float r ) {\n    p = p.yx;\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nfloat sdBox( in vec2 p, in vec2 b ) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdThreeHexagon(vec2 p, float r) {\n    return min(sdHexagon(p-vec2(0.0, 0.5*sqrt(3.)), r),\n           min(sdHexagon(p-vec2(0.5, 0.0), r),\n               sdHexagon(p-vec2(0.5, (2.+3./7.)/sqrt(3.)), r)));\n}\n\nvec2 carpet_shining(vec2 uv, float blur) {\n    float modulus = (2.+3./7.)/sqrt(3.);\n    uv.x = abs(fract(uv.x+0.5)-0.5);\n    uv.y = mod(uv.y, modulus);\n    float sdSmallHex = sdThreeHexagon(uv, 1./7.);\n    float sd = max(sdThreeHexagon(uv, 2./7.), -sdSmallHex);\n    sd = max(sdThreeHexagon(uv, 3./7.), -sd);\n    float sdb = min(sdBox(uv-vec2(0.0, 1.25), vec2(0.5/7., 0.15)),\n                    sdBox(uv-vec2(0.5, 1.0), vec2(0.5/7., 0.15)));\n    sd = max(sd, -sdb);\n    return vec2(smoothstep(blur, -blur, sd), sdSmallHex < 0.1);\n}\n\n//////////////////////////////////\n//Version using hexagonal tiling//\n//////////////////////////////////\n#else\n\n#define ANTIALIAS 1\n\nvec2 carpet_shining(vec2 uv, float blur) {\n    uv = uv.yx;\n    vec2 off = vec2(sqrt(3.), 1.);\n    float modulus = (2.+3./7.)/sqrt(3.);\n    int id = int(floor(uv.x/modulus));\n    uv.y = abs(fract(uv.y+0.5)-0.5);\n    uv.x = mod(uv.x, modulus);\n    uv.x += 2./sqrt(3.);\n    if(dot(vec2(uv.x, -abs(uv.y)), normalize(off)) < 1.) {\n        uv.x += modulus;\n        id += 1;\n    }\n    vec2 uv1 = mod(uv, off)-off/2.;\n    vec2 uv2 = mod(uv+off/2., off)-off/2.;\n    vec2 nuv = (length(uv1) < length(uv2)) ? uv1 : uv2;\n    float d = max(abs(nuv.y), dot(abs(nuv), normalize(off)));\n    float N = 3.5;\n#if ANTIALIAS == 1\n    // There is still a little glitch on the connexion with the adjacent tiling :(\n    // (Hopefully we have to zoom in to see it!)\n    float b = smoothstep(0.5/N+blur, 0.5/N     , mod(d, 1./N))\n            * smoothstep(0.5/N     , 0.5/N-blur, mod(d, 1./N))\n            * smoothstep(0., blur, mod(d, 1./N))\n            * smoothstep(1./N, 1./N-blur, mod(d, 1./N));\n    if(uv.x < (2.+4./7.)/sqrt(3.) && uv.y < 0.6/7.) {\n        b = 0.;\n    }\n    if(uv.x < (2.+3.5/7.)/sqrt(3.)) {\n        float s = smoothstep(0.5/7.+blur, 0.5/7.     , uv.y)\n                + smoothstep(1.5/7.-blur, 1.5/7.     , uv.y);\n        b = 1.-s*(1.-b);\n    }\n    if(d < 0.25/9.) b = 1.;\n#else\n    bool b = mod(d, 1./N) < 0.5/N;\n    b = b && !(uv.x < (2.+4./7.)/sqrt(3.) && uv.y < 0.5/7.);\n    b = b ||  (uv.x < (2.+3.5/7.)/sqrt(3.) && 0.5/7. < uv.y && uv.y < 1.5/7.);\n#endif\n    bool ii = d < 1.5/7.;\n    \n    return vec2(b, ii);\n}\n\n#endif\n\nconst vec3 red = vec3(161., 28., 31.)/255.;\nconst vec3 orange = vec3(225., 99., 40.)/255.;\nconst vec3 brown = vec3(71., 38., 31.)/255.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.y;\n    uv *= 5.;\n    uv.y += iTime/4.;\n    float pixelSize = 5./iResolution.y;\n    \n    vec2 res = carpet_shining(uv, 1.5*pixelSize/2.);\n    float b = res.x;\n    float ii = res.y;\n    vec3 col = mix(brown, mix(orange, red, ii), b);\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tttfDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 3004, 3061, 3061, 3362]], "test": "valid"}
{"id": "tttfR2", "name": "Jello Lights", "author": "yozic", "description": "Almost a stained glass feel too? You decide. ", "tags": ["colorful", "abstract"], "likes": 21, "viewed": 620, "published": "Public API", "date": "1613104758", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592\n#define ORBS 20.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n  uv *= 279.27;\n  for (float i = 0.; i < ORBS; i++) {\n    uv.y -= i / 1000. * (uv.x); \n    uv.x += i / 0.05 * sin(uv.x / 9.32 + iTime) * 0.21 * cos(uv.y / 16.92 + iTime / 3.) * 0.21;\n    float t = 5.1 * i * PI / float(ORBS) * (2. + 1.) + iTime / 10.;\n    float x = -1. * tan(t);\n    float y = sin(t / 3.5795); \n    vec2 p = (115. * vec2(x, y)) / sin(PI * sin(uv.x / 14.28 + iTime / 10.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + i / 5.)) * 0.5 + 0.5;\n    fragColor += vec4(i / 40. * 55.94 / length(uv - p * 0.9) * col, 3.57);\n  }\n  fragColor.xyz = pow(fragColor.xyz, vec3(3.57));\n  fragColor.w = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tttfR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 93, 93, 781]], "test": "valid"}
{"id": "tttfW7", "name": "Mandelbrot time iterations", "author": "ptemoche", "description": "I testing with fractals, today tested with mandelbrot.\nI used the palette color function from https://iquilezles.org/www/articles/palettes/palettes.htm", "tags": ["fractal", "mandelbrot", "iterations"], "likes": 2, "viewed": 61, "published": "Public", "date": "1612890946", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//https://iquilezles.org/www/articles/palettes/palettes.htm\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat mandelbrot(vec2 uv){\n    \n    float iterations = 100.*(sin(iTime*0.5)*0.5+0.5);\n    vec2 st = vec2(0.);\n    for(float i = 0. ;i < iterations;++i){\n        //zn = (zn-1)^2+c\n        \n        //(a+bi)^2 = a^2+(bi)^2 + 2.0*a*bi\n        st = uv+vec2(st.x*st.x-st.y*st.y,2.0*st.x*st.y);\n        if(length(st)>4.)\n            return i/iterations;\n    \n    }\n    return 1.0;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.5*(fragCoord-iResolution.xy*0.5)/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = 1.0-palette(mandelbrot(uv),vec3(0.5),vec3(0.5),vec3(1.0),vec3(0.,0.1,0.2));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tttfW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 60, 132, 132, 175], [177, 177, 203, 203, 553], [555, 555, 612, 662, 908]], "test": "valid"}
{"id": "tttfzB", "name": "Revolving Gear Train", "author": "oneshade", "description": "Cool geartrain.", "tags": ["3d", "raymarching", "gears", "repetition", "revolving", "geartrain"], "likes": 11, "viewed": 97, "published": "Public", "date": "1613006176", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdBox(in vec3 p, in vec3 d) {\n    vec3 q = abs(p) - d;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdBox2D(in vec2 p, in vec2 d) {\n    vec2 q = abs(p) - d;\n    return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0);\n}\n\nvec2 pModPolar(in vec2 p, in float offs, in float reps) {\n    float rep = 6.28 / reps, hRep = 0.5 * rep;\n    return sin(mod(atan(p.y, p.x) + offs + hRep, rep) - hRep + vec2(1.57, 0.0)) * length(p);\n}\n\nfloat mapScene(in vec3 p) {\n    float turn = iTime;\n\n    float c = cos(turn), s = sin(turn);\n    vec3 p1 = p, p2 = p;\n\n    float cell = mod(floor(atan(p1.z, p1.x) / 6.28 * 6.0 + 0.5), 2.0);\n    float dir = cell * 2.0 - 1.0, lock = cell * 0.157;\n    p1.xz = pModPolar(p1.xz, 0.0, 6.0) - vec2(3.0, 0.0);\n    p1.xy *= mat2(c, -s, s, c);\n\n    float teeth1 = sdBox(vec3(pModPolar(p1.xz, turn * dir + lock, 20.0), p1.y).xzy - vec3(1.35, 0.0, 0.0), vec3(0.25, 0.175, 0.075));\n    float ring1 = sdBox2D(vec2(length(p1.xz) - 1.1, p1.y), vec2(0.25));\n    float gears1 = min(ring1, teeth1);\n\n    cell = mod(floor(atan(p2.z, p2.x) / 6.28 * 6.0), 2.0);\n    dir = cell * 2.0 - 1.0, lock = cell * 0.157;\n    p2.xz = pModPolar(p2.xz, 0.52, 6.0) - vec2(2.75, 0.0);\n    p2.xy *= mat2(c, -s, s, c);\n    p2.xy = p2.yx;\n\n    float teeth2 = sdBox(vec3(pModPolar(p2.xz, turn * dir + lock, 20.0), p2.y).xzy - vec3(1.35, 0.0, 0.0), vec3(0.25, 0.175, 0.075));\n    float ring2 = sdBox2D(vec2(length(p2.xz) - 1.1, p2.y), vec2(0.25));\n    float gears2 = min(ring2, teeth2);\n\n    return min(gears1, gears2) - 0.025;\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.01, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy) - mapScene(p - e.xyy),\n                          mapScene(p + e.yxy) - mapScene(p - e.yxy),\n                          mapScene(p + e.yyx) - mapScene(p - e.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenCenter = 0.5 * iResolution.xy;\n\n    vec2 mouse = (iMouse.xy - screenCenter) / iResolution.y * 3.14;\n    vec2 uv = (fragCoord.xy - screenCenter) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 10.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    vec2 rot = vec2(iTime, -0.6);\n    if (iMouse.z > 0.0) rot += mouse;\n\n    float cy = cos(rot.x), sy = sin(rot.x);\n    float cp = cos(rot.y), sp = sin(rot.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    float t = 0.0;\n    for (float i=0.0; i < 100.0; i++) {\n        vec3 p = ro + rd * t;\n        float d = mapScene(p);\n        if (d < 0.001) {\n            vec3 n = getNormal(p);\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n\n            l.yz *= mat2(cp, -sp, sp, cp);\n            l.xz *= mat2(cy, -sy, sy, cy);\n\n            float fogginess = 1.0 - exp(-t * 0.05);\n            fragColor.rgb = mix(vec3(max(0.0, dot(n, l))), vec3(0.25, 0.25, 1.0), fogginess);\n            break;\n        }\n\n        if (t > 50.0) {\n            fragColor.rgb = mix(vec3(0.25, 0.25, 1.0), vec3(1.0), 0.5 + 0.5 * rd.y);\n            break;\n        }\n\n        t += d;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tttfzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 130], [132, 132, 169, 169, 254], [256, 256, 313, 313, 455], [457, 457, 484, 484, 1544], [1546, 1546, 1573, 1573, 1819], [1821, 1821, 1876, 1876, 3134]], "test": "valid"}
{"id": "tttfzl", "name": "Fire Within", "author": "YitingLiu", "description": "creating fire with gyroid shapes", "tags": ["raymarching", "template", "artofcode"], "likes": 5, "viewed": 187, "published": "Public API", "date": "1613313717", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S(a, b, t) smoothstep(a, b, t)\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34,233.53));\n    p += dot(p, p+23.234);\n    return fract(p.x*p.y);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdGyroid(vec3 p,float scale, float thickness, float bias){\n    p*=scale;\n    \n    // can also play with the p and p.zxy by adding some numbers \n    // scale needs to add the largest multiplers in either p or p.zxy \n    // return abs(dot(sin(p*2.),cos(p.zxy*1.23))-bias)/(scale*2.)-thickness;\n\n    return abs(dot(sin(p),cos(p.zxy))-bias)/scale-thickness;\n}\n    \n    \n    \nvec3 Transform(vec3  p){\n   p.xy*=Rot(p.z*.15);\n\n    p.z -=iTime*.1;\n    p.y -= .3;\n    \n    return p;\n\n}\n\nfloat GetDist(vec3 p) {\n    p=Transform(p);\n    float box = sdBox(p, vec3(1));\n    \n    // wanting something organic? the scales for two should not be multiplicable by each other (ex.: can't be 4 and 8)\n   \t\n   \tfloat g1 = sdGyroid(p, 5.23, .03, 1.4);\n    float g2 = sdGyroid(p, 10.76, .03, .3);\n    float g3 = sdGyroid(p, 20.76, .03, .3);\n    float g4 = sdGyroid(p, 35.76, .03, .3);\n    float g5 = sdGyroid(p, 60.76, .03, .3);\n    float g6 = sdGyroid(p, 110.76, .03, .3);\n    float g7 = sdGyroid(p, 210.76, .03, .3);\n    \n    //float g = max(g1,g2);//union \n  //float g = max(g1,-g2);//subtraction \n    //bump mapper\n    g1 -= g2*.4;\n    g1 -= g3*.3;\n    g1 += g4*.2;\n    g1 += g5*.2;\n    g1 += g6*.3;\n    g1 += g7*.5;\n    \n    //float d=max(box,g1*.8);// intersect the box \n   \t\n    float d = g1*.8;\n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    \n//    the e.x determines the smoothness\n    vec2 e = vec2(.025, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 Background(vec3 rd){\nfloat t = iTime*.2;\n    vec3 col = vec3(0);\n    vec3 fireCol = vec3(1,.45,.1);\n\n    \n    float y = rd.y*.5+.5;\n    \n    col+=(1.-y)*fireCol;\n    \n    //make flames\n    //smoothstep to make the top dark and bottom bright \n    \n    float a = atan(rd.x,rd.z);\n    float flames = sin(a*10.+t)*sin(a*7.-t)*sin(a*3.);\n    flames *=S(0.8,0.6,y);\n    col*=flames;\n    col = max(col,0.);\n    col+=S(.3,.0,y);\n    return col;\n\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    float t = iTime*0.2;\n    vec3 col = vec3(0);\n    vec3 fireCol = vec3(1,.45,.1);\n  \n\n    //distort effect \n    uv +=sin(uv*20.+t)*.01;\n    vec3 ro = vec3(0, 0, -1);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 lookat = vec3(0,0,0);\n    //zoom factor 1\n    vec3 rd = GetRayDir(uv, ro, lookat, .8);\n\n    float d = RayMarch(ro, rd);\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \tvec3 n = GetNormal(p);\n        float height = p.y;\n        p = Transform (p);\n        \n    \tfloat dif = n.y*.5+.5;\n    \tcol+=dif*dif*dif;// 0 <> 1 \n   \n    \n        //ambient occulusion - cheaper \n        float g2 = sdGyroid(p, 10.76, .03, .3);\n        \n        col*=S(-.1,.05,g2);//blackening \n        \n        float crackWidth = -.02+S(0., -.5, n.y)*.04;\n        float cracks = S(crackWidth,-.025,g2);\n        float g3 = sdGyroid(p+t*.1, 5.76, .03, .0);\n        float g4 = sdGyroid(p-t*.05, 4.76, .03, .0);\n        cracks *=g3*g4*20.+.1*S(.2,.0,n.y);\n\n        col+=cracks*fireCol*3.;\n        \n        float g5 = sdGyroid(p-vec3(0,t,0),1.85,.02,1.3);\n        \n        col+=g5*fireCol;\n\n        col +=S(0.,-2.,height)*fireCol;\n       \n\n    }\n    \n    col = mix(col, Background(rd), S(0., 7., d));\n    //col = Background(rd);\n\n    col*=1.-dot(uv,uv);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tttfzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[124, 124, 143, 143, 205], [207, 207, 229, 229, 323], [325, 325, 354, 354, 435], [437, 437, 501, 501, 798], [814, 814, 838, 838, 919], [921, 921, 944, 944, 1738], [1741, 1741, 1775, 1775, 1986], [1988, 1988, 2012, 2012, 2242], [2244, 2244, 2294, 2294, 2485], [2487, 2487, 2512, 2512, 2932], [2935, 2935, 2992, 2992, 4394]], "test": "valid"}
{"id": "tttfzr", "name": "Ellipse - distance 2D II No Trig", "author": "iq", "description": "Computing the distance to an ellipse like in [url]https://www.shadertoy.com/view/4lsXDN[/url] but without trigonometric functions (not necessarily faster). Also see [url]https://www.shadertoy.com/view/4sS3zz[/url]", "tags": ["2d", "distance", "ellipse"], "likes": 7, "viewed": 405, "published": "Public API", "date": "1612169670", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Computing the distance to an ellipse like in \n// https://www.shadertoy.com/view/4lsXDN, ie, using a\n// Newtwon root solver, but realizing that the deltas\n// in the variable of the solver can be interpreted as\n// rotations, hence removing all sin/cos calls, but\n// introducing a square root. This might or might not\n// be any faster than the trigonometric version, since\n// GPUs are really good at trigs.\n//\n// More information here:\n//\n// https://iquilezles.org/www/articles/ellipsedist/ellipsedist.htm\n//\n//\n// Ellipse distances related shaders:\n//\n// Analytical     : https://www.shadertoy.com/view/4sS3zz\n// Newton Trig    : https://www.shadertoy.com/view/4lsXDN\n// Newton No-Trig : https://www.shadertoy.com/view/tttfzr \n// ?????????????? : https://www.shadertoy.com/view/tt3yz7\n//\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\n\nfloat sdEllipse( vec2 p, vec2 ab )\n{\n    // symmetry\n\tp = abs( p );\n    \n    // initial value\n    vec2 q = ab*(p-ab);\n    vec2 cs = normalize( (q.x<q.y) ? vec2(0.01,1) : vec2(1,0.01) );\n    \n    // find root with Newton solver (see https://www.shadertoy.com/view/4lsXDN)\n    for( int i=0; i<5; i++ )\n    {\n        vec2 u = ab*vec2( cs.x,cs.y);\n        vec2 v = ab*vec2(-cs.y,cs.x);\n        \n        float a = dot(p-u,v);\n        float c = dot(p-u,u) + dot(v,v);\n        float b = sqrt(c*c-a*a);\n        \n        cs = vec2( cs.x*b-cs.y*a, cs.y*b+cs.x*a )/c;\n    }\n    \n    // compute final point and distance\n    float d = length(p-ab*cs);\n    \n    // return signed distance\n    return (dot(p/ab,p/ab)>1.0) ? d : -d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\t\n    vec2 ra = vec2(0.5,0.2) + 0.2*cos(iTime*vec2(1.1,1.3)+vec2(0.0,1.0) );\n    \n\tfloat d = sdEllipse( p, ra );\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = sdEllipse(m, ra);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4( col, 1.0 );;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tttfzr.jpg", "access": "shaders20k", "license": "mit", "functions": [[1078, 2032, 2068, 2084, 2749], [2751, 2751, 2808, 2808, 3501]], "test": "valid"}
{"id": "ttVBDm", "name": "Rectangular Bezier Stroke", "author": "nr4", "description": "Quadratic bezier distance, closest point on curve and normal, used for computing the distance to a rectangular stroke.\n\nSuggestions for optimizations welcome! :)", "tags": ["2d", "sdf", "stroke", "spline", "distance", "normal", "box", "quadratic"], "likes": 7, "viewed": 122, "published": "Public", "date": "1614522913", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n * Rectangular Bezier Stroke\n * \n * Copyright (C) 2021  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n \nconst vec3 c = vec3(1.,0.,-1.);\nconst float pi = acos(-1.);\n\n// minimum distance to spline, nearest point on spline and normal in that point\nvoid spline2(in vec2 x, in vec2 p0, in vec2 p1, in vec2 p2, out float ds, out vec2 xn, out vec2 n)\n{\n    //coefficients for 0 = t^3 + a * t^2 + b * t + c\n    vec2 E = x-p0, F = p2-2.*p1+p0, G = p1-p0;\n    vec3 ai = vec3(3.*dot(G,F), 2.*dot(G,G)-dot(E,F), -dot(E,G))/dot(F,F);\n\n\t//discriminant and helpers\n    float tau = ai.x/3., p = ai.y-tau*ai.x, q = -tau*(tau*tau+p)+ai.z, dis = q*q/4.+p*p*p/27.;\n    \n    //triple real root\n    if(dis > 0.)\n    {\n        vec2 ki = -.5*q*c.xx+sqrt(dis)*c.xz, ui = sign(ki)*pow(abs(ki), c.xx/3.);\n        float np = clamp(ui.x+ui.y-tau,0.,1.);\n        \n        xn = mix(mix(p0,p1,np),mix(p1,p2,np),np);\n        ds = length(x-xn);\n        n = normalize(2.*mix(p1-p0, p2-p1, np));\n        \n        return;\n    }\n    \n    //three distinct real roots\n    float fac = sqrt(-4./3.*p), arg = acos(-.5*q*sqrt(-27./p/p/p))/3.,\n        dsa;\n    vec3 t = clamp(c.zxz*fac*cos(arg*c.xxx+c*pi/3.)-tau,0.,1.);\n    vec2 xna;\n    \n    xn = mix(mix(p0,p1,t.x),mix(p1,p2,t.x),t.x);\n    ds = length(x-xn);\n    n = 2.*mix(p1-p0, p2-p1, t.x);\n    \n    xna = mix(mix(p0,p1,t.y),mix(p1,p2,t.y),t.y);\n    dsa = length(x-xna);\n    if(dsa < ds)\n    {\n        xn = xna;\n        ds = dsa;\n        n = 2.*mix(p1-p0, p2-p1, t.y);\n    }\n    \n    xna = mix(mix(p0,p1,t.z),mix(p1,p2,t.z),t.z);\n    dsa = length(x-xna);\n    if(dsa < ds)\n    {\n        xn = xna;\n        ds = dsa;\n        n = 2.*mix(p1-p0, p2-p1, t.z);\n    }\n    n = normalize(n);\n}\n\n// minimum distance to line, nearest point on line and normal in that point\nvoid linesegment(in vec2 x, in vec2 p1, in vec2 p2, out float d, out vec2 xn, out vec2 n)\n{\n    vec2 da = p2-p1;\n    float t = clamp(dot(x-p1, da)/dot(da,da),0.,1.);\n    xn = mix(p1, p2, t);\n    d = length(x-xn);\n    n = normalize(p2-p1).yx*c.xz;\n}\n\n// regular box distance\nvoid dbox(in vec2 x, in vec2 b, out float d)\n{\n    vec2 da = abs(x)-b;\n    d = length(max(da,c.yy)) + min(max(da.x,da.y),0.0);\n}\n\n// apply the box distance to arbitrary curve distance functions\nvoid rect_stroke(in vec2 x, in float d2d, in float size, in vec2 xn, in vec2 n, out float d)\n{\n    dbox(mat2(n, n.yx*c.xz)*(x-xn), size*c.xx, d);\n}\n\n// paint with antialiasing\nfloat sm(in float d)\n{\n    return smoothstep(1.5/iResolution.y, -1.5/iResolution.y, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Ignore the drawing code, it's messy, I know :)\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    \n    float d, \n        da;\n    vec2 xn, n;\n    spline2(uv, -.3*vec2(cos(iTime),sin(iTime)), -.2*c.xz*vec2(cos(1.4*iTime), sin(-1.1*iTime)), .1*vec2(cos(1.4*iTime),-1.1*sin(iTime)), d, xn, n);\n    \n    // Try this with lines as well:\n    // linesegment(uv, -.3*vec2(cos(iTime),sin(iTime)), -.2*c.xz*vec2(cos(1.4*iTime), sin(-1.1*iTime)), d, xn, n);\n    \n    rect_stroke(uv, d, .025, xn, n, d);\n    \n    float interval = clamp(.03 * (d-mod(d,.025))/.025, 0., 1.);\n    vec3 col = mix(vec3(1.00,0.90,0.68), vec3(0.98,0.64,0.67), 2.*interval);\n    if(interval > .5) col = mix(col, vec3(0.54,0.80,0.80), 2.*(interval-.5));\n    col = mix(col, c.yyy, sm(d));\n    \n    col = mix(col, .4*c.xxx, sm(abs(mod(d+.0125,.025)-.0125)-.001));\n   \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVBDm.jpg", "access": "shaders20k", "license": "gpl-3.0-plus", "functions": [[809, 889, 989, 1042, 2337], [2339, 2415, 2506, 2506, 2663], [2665, 2689, 2735, 2735, 2817], [2819, 2883, 2977, 2977, 3030], [3032, 3059, 3081, 3081, 3148], [3150, 3150, 3207, 3261, 4089]], "test": "error"}
{"id": "ttVBDw", "name": "Sunday fractals 2", "author": "mrange", "description": "License CC0: Sunday Fractals 2\nInspired by: http://www.fractalforums.com/new-theories-and-research/very-simple-formula-for-fractal-patterns/\nSABS from ollj", "tags": ["2d", "fractals"], "likes": 7, "viewed": 238, "published": "Public API", "date": "1614505148", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License CC0: Sunday Fractals 2\n// Inspired by: http://www.fractalforums.com/new-theories-and-research/very-simple-formula-for-fractal-patterns/\n// SABS from ollj\n\n#define RESOLUTION      iResolution\n#define TIME            iTime\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define LESS(a,b,c)     mix(a,b,step(0.,c))\n#define SABS(x,k)       LESS((.5/(k))*(x)*(x)+(k)*.5,abs(x),abs(x)-(k))\n#define L2(x)           dot(x,x)\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n\nfloat hash(float co) {\n  co += 1234.;\n  return fract(sin(dot(co, 12.9898)) * 13758.5453);\n}\n\nfloat maxComp(vec3 c) {\n  return max(c.x, max(c.y, c.z));\n}\n\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat pabs(float a, float k) {\n  return pmax(a, -a, k);\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\nfloat modMirror1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize,size) - halfsize;\n  p *= mod(c, 2.0)*2.0 - 1.0;\n  return c;\n}\n\nfloat smoothKaleidoscope(inout vec2 p, float sm, float rep) {\n  vec2 hp = p;\n\n  vec2 hpp = toPolar(hp);\n  float rn = modMirror1(hpp.y, TAU/rep);\n\n  float sa = PI/rep - SABS(PI/rep - abs(hpp.y), sm);\n  hpp.y = sign(hpp.y)*(sa);\n\n  hp = toRect(hpp);\n\n  p = hp;\n\n  return rn;\n}\n\nfloat fractal(vec2 p, vec2 c, vec2 ot) {\n  vec2 u = p;\n  float lx = 1E6;\n  float ly = 1E6;\n  float lp = 1E6;\n  const int maxi = 9;\n  float s = 1.0;\n\n  for (int i = 0; i < maxi; ++i) {\n    float m = dot(u, u);\n    u = SABS(u, 0.075)/m + c;\n    s *= m;\n    float dx = abs(u.x - ot.x);\n    float dy = abs(u.y - ot.y);\n    float dp = abs(1.65-length(u));\n    if(m > 0.033) {\n      lx = min(lx, dx);\n      ly = min(ly, dy);\n    }\n    lp = min(lp, dp);\n  }\n  \n  float l = lp;\n  l = pmin(l, lx, 0.05);\n  l = pmin(l, ly, 0.05);\n  l -= 0.025;\n  return l*s;\n}\n\nfloat df(vec2 p, vec2 c, float hh) {\n  p *= ROT(TIME*TAU/120.0);\n  float rep = 2.0*round(mix(3.0, 12.0, hh));\n  float sm = 0.025*10.0/rep;\n  smoothKaleidoscope(p, sm, rep);\n  p *= ROT(hh*TAU+0.05);\n  vec2 u = p;\n  vec2 ot = mix(1.5, -1.5, hh)*vec2(cos(TAU*hh*sqrt(0.5)), sin(TAU*hh));\n  return fractal(p, c, ot);\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, 1.0/vec3(2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvec3 color(vec2 p, vec2 c, float hh, float aa) {\n  float d = df(p, c, hh);\n  vec3 col = vec3(0.0);\n  float l2 = tanh_approx(L2(p));\n  vec3 hsv = vec3(0.0+hh+l2*0.5, mix(0.5, 0.75, l2), 1.0);\n  vec3 glowCol = hsv2rgb(hsv)*2.0;\n//  vec3 glowCol = vec3(0.5, 0.5, 1.0)*mix(2.0, 2.0, l2);\n  glowCol = d < 0.0 ? glowCol : glowCol.zxy;\n  col += glowCol*exp(-mix(300.0, 900.0, l2)*max(abs(d), 0.0));\n  col += glowCol*abs(tanh_approx(d));\n//  col = mix(col, vec3(1.0), smoothstep(-aa, aa, -d));\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa = 2.0/RESOLUTION.y;\n  const float period = 10.0;\n  float nperiod = floor(TIME/period);\n  float tperiod = mod(TIME, period);\n  float hh = hash(nperiod);\n  vec2  c = vec2(-1.30,  -1.30)+0.2*vec2(sin(0.05*TIME+TAU*hh*vec2(1.0, sqrt(0.5)*0.5)));\n  \n  vec2 o1 = vec2(1.0/8.0, 3.0/8.0)*aa;\n  vec2 o2 = vec2(-3.0/8.0, 1.0/8.0)*aa;\n  \n  vec3 col = color(p+o1, c, hh, aa);\n  float mc = maxComp(clamp(col, 0.0, 1.0));\n  float dmc = length(vec2(dFdx(mc), dFdy(mc)))/(mc+0.075);\n  if (dmc > 0.5) {\n    col += color(p-o1, c, hh, aa);\n    col += color(p+o2, c, hh, aa);\n    col += color(p-o2, c, hh, aa);\n    col *= 0.25;\n//    col += vec3(1.0, 0.0, 0.0);\n  }\n  col = clamp(col, 0.0, 1.0);\n  col *= smoothstep(0.0, 0.5, tperiod);\n  col *= 1.0-smoothstep(period-0.5, period, tperiod);\n  col = postProcess(col, q);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVBDw.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[0, 513, 535, 535, 604], [606, 606, 629, 629, 665], [667, 667, 689, 689, 858], [860, 860, 888, 908, 984], [986, 986, 1025, 1025, 1110], [1112, 1112, 1151, 1151, 1180], [1182, 1182, 1212, 1212, 1239], [1241, 1241, 1263, 1263, 1307], [1309, 1309, 1330, 1330, 1375], [1377, 1377, 1422, 1422, 1576], [1578, 1578, 1639, 1639, 1852], [1854, 1854, 1894, 1894, 2403], [2405, 2405, 2441, 2441, 2719], [2721, 2721, 2757, 2757, 2990], [2992, 2992, 3040, 3040, 3493], [3495, 3495, 3547, 3547, 4486]], "test": "error"}
{"id": "ttVBWm", "name": "petals storm", "author": "sukupaper", "description": "Code is messed up but the I enjoy the result a lot.. 👀\"", "tags": ["raymarching", "experimental", "petals", "storm"], "likes": 5, "viewed": 84, "published": "Public", "date": "1614509775", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author: paperu\n// Title: petals storm\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\n#define P 6.28318530717\nfloat t;\n\nvec3 SpectrumPoly(float x) {\n    // https://www.shadertoy.com/view/wlSBzD\n    return (vec3( 1.220023e0,-1.933277e0, 1.623776e0)\n          +(vec3(-2.965000e1, 6.806567e1,-3.606269e1)\n          +(vec3( 5.451365e2,-7.921759e2, 6.966892e2)\n          +(vec3(-4.121053e3, 4.432167e3,-4.463157e3)\n          +(vec3( 1.501655e4,-1.264621e4, 10.375260e4)\n          +(vec3(-2.904744e4, 1.969591e4,-2.330431e4)\n          +(vec3( 3.068214e4,-1.698411e4, 2.229810e4)\n          +(vec3(-1.675434e4, 7.594470e3,-1.131826e4)\n          + vec3( 3.707437e3,-1.366175e3, 2.372779e3)\n            *x)*x)*x)*x)*x)*x)*x)*x)*x;\n}\n\nmat2 rot(in float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\nfloat sph(in vec3 p, in float r) { return length(p) - r; }\nfloat box(in vec3 p, in vec3 s, in float r) { return length(max(abs(p) - s,0.)) - r; }\n\nfloat df(in vec3 p) {\n    p.xz *= rot(P*.125);\n    p.yz *= rot(P*.125 - t*4.);\n    float d = 10e9, v = 1.;\n    mat2 rotV1 = rot(P*.125 + t), rotV2 = rot(P*.125 + t*2.), rotV3 = rot(P*.125 + t*4.);\n    for(int i = 0; i < 5; i++) {\n        d = min(d,max(-box(p, vec3(.5)*v, .015),sph(p, .55*v)));\n        p.xz *= rotV1;\n        p.xy *= rotV2;\n        p.yz *= rotV3;\n        p.z = abs(p.z) - 0.378;\n        v *= .75;\n    }\n    return d;\n}\n\nvec3 normal(in vec3 p) { float d = df(p); vec2 u = vec2(0.,.00001); return normalize(vec3(df(p + u.yxx),df(p + u.xyx),df(p + u.xxy)) - d); }\n\nvec3 rm(in vec3 c, in vec3 r) {\n    const float MAX_D = 5., LIM = .0001;\n    const int MAX_IT = 150;\n    vec3 color = vec3(-1.);\n    vec3 p = c;\n    bool h = false;\n    for(int i = 0; i < MAX_IT; i++) {\n        float d = df(p);\n        if(d < LIM) { h = true; break; }\n        if(distance(c,p) > MAX_D) { break; }\n        p += d*r;\n    }\n    if(h) {\n        vec3 n = normal(p);\n        color = SpectrumPoly(clamp(dot(n,-r),0.,1.));\n    }     \n    \n    return color;\n}\n\nvec3 rgb2hsv(in vec3 c) {\n    vec4 K = vec4(0., -1./3., 2./3., -1.);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1e-10;\n    return vec3(abs(q.z + (q.w - q.y)/(6.0*d + e)), d/(q.x + e), q.x);\n}\n\nvec3 hsv2rgb(in vec3 c) {\n    vec4 K = vec4(1., 2./3., 1./3., 3.);\n    return c.z * mix(K.xxx, clamp(abs(fract(c.xxx + K.xyz)*6. - K.www) - K.xxx, 0., 1.), c.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = (fragCoord.xy - .5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy - .5;\n    float g = -4.312 - m.x*.1;\n    t = g*.25 + cos(g*.5)*8.2 + pow(length(st)*0.7,2.) + iTime*.1;\n    \n    vec3 c = vec3(st*1.75,-2.);\n    vec3 r = normalize(vec3(0.,0.,1.));\n\n    vec3 color = rm(c,r);\n    st += g;\n    color += vec3(fract(st*5. + cos(st.x*10.)*cos(st.y*10.)),1.);\n    st *= rot(P*.125);\n    color = mix(color,color.bgr,step(0.,fract(st.x*8.) - .5));\n    color *= .5;\n    color = clamp(color,0.03,1.);\n    vec3 colHSV = rgb2hsv(color);\n    color = hsv2rgb(vec3(colHSV.x,colHSV.y*.985,colHSV.z));\n    \n    fragColor = vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVBWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 194, 222, 267, 796], [798, 798, 820, 820, 865], [867, 867, 901, 901, 925], [926, 926, 971, 971, 1012], [1014, 1014, 1035, 1035, 1449], [1451, 1451, 1475, 1475, 1591], [1593, 1593, 1624, 1624, 2060], [2062, 2062, 2087, 2087, 2400], [2402, 2402, 2427, 2427, 2565], [2567, 2567, 2622, 2622, 3281]], "test": "error"}
{"id": "ttVfWm", "name": "folding (paper)", "author": "sukupaper", "description": "\"Minimalist\" aesthetic is quite interesting 🤔", "tags": ["raymarching", "folding", "paper", "minimalist", "redandwhite"], "likes": 10, "viewed": 97, "published": "Public", "date": "1614512334", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author: paperu\n// Title: folding\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\n#define PRC .0001\n#define MAX_D 10.\n#define MAX_IT 20\n\n#define P 3.14159265359\n\nmat2 rotv, rotv2;\n\nfloat rand(in vec2 st){ return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.585); }\n\n\nmat2 rot(in float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat rcub(in vec2 p, in float s, in float r) { return length(max(abs(p) - s, 0.)) - r; }\nfloat cub(in vec2 p, in float s) { p = abs(p); return max(p.x,p.y) - s; }\nfloat anim1(in float x, in float s) { x += .5; return smoothstep(-s,s,mod(x, 1.) - .5) + floor(x); }\nfloat df(in vec3 p) {\n    p.yz *= rotv2;\n    float d = 10e9;\n    const float maxI = 10.;\n    for(float i = 1.; i <= maxI; i++) {\n    \tp.xz *= rotv;\n        p.x = abs(p.x);\n    \tp.xy *= rotv;\n        p.y = abs(p.y);\n    \tp.xy *= rot(P/8.);\n        d = min(d,cub(vec2(rcub(p.xy, .2 - i/maxI*.15, 0.), p.z), .0001));\n    }\n    return d;\n}\n\nvec3 normal(in vec3 p) { vec2 u = vec2(0., PRC); float d = df(p); return normalize(vec3(df(p + u.yxx), df(p + u.xyx), df(p + u.xxy)) - d); }\n\nstruct rmres { vec3 p; bool h; int i; };\nrmres rm(in vec3 c, in vec3 r) {\n    rmres res;\n    res.h = false;\n    res.p = c;\n    for(int i = 0; i < MAX_IT; i++) {\n        float d = df(res.p);\n        if(d < PRC) { res.h = true; res.i = i; break; }\n        if(distance(c, res.p) > MAX_D) { res.i = i; break; }\n        res.p += r*d;\n    }\n    return res;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = (fragCoord.xy - .5*iResolution.xy)/iResolution.y;\n    vec2 m = (iMouse.xy/iResolution.xy) - .5;\n\n    st -= m*.05;\n    \n    if(abs(cub(st,.49) + .02) - .01 < 0.) {\n        fragColor = vec4(vec3(1.), 1.);\n    } else {\n        float t = iTime*.5 + length(st*.5) + rand(floor(st*100.))*.15;\n        float tt = iTime;\n        \n    \trotv = rot(P*anim1(t,.3)/3.);\n        rotv2 = rot(P*anim1(t*.5,.1)/12.);\n        \n        st += m*.1;\n\n        rmres res = rm(vec3(st*.6,-5.), normalize(vec3(0.,0.,1.)));\n\n        vec3 color = res.h ? vec3(1.) : vec3(0.900,0.247,0.325);\n\n        fragColor = vec4(color, 1.);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVfWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 254, 277, 277, 341], [344, 344, 366, 366, 411], [412, 412, 459, 459, 501], [502, 502, 536, 536, 575], [576, 576, 613, 613, 676], [677, 677, 698, 698, 1012], [1014, 1014, 1038, 1038, 1154], [1197, 1197, 1229, 1229, 1508], [1510, 1510, 1565, 1565, 2189]], "test": "error"}
{"id": "ttVfz1", "name": "Animated voronoi", "author": "morphix", "description": "voronoi", "tags": ["voronoi"], "likes": 3, "viewed": 59, "published": "Public", "date": "1613924438", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//original - http://glslsandbox.com/e#71176.0\n//This is only a remix\nconst float Radius = 1.; // cell radius\nconst float Bounds = 1.; // round number, adjust this to accomodate Radius\n\n// hash without sine\n// https://www.shadertoy.com/view/4djSRW\n#define MOD3 vec3(443.8975, 397.2973, 491.1871)\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+23.47);\n    return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n// map offset and value\nvec3 mapOV(vec2 p, vec2 o, float z) {\n    return\n        mix(\n            hash33(vec3(floor(p)-o, floor(z)-1.)),\n            hash33(vec3(floor(p)-o, floor(z))),\n            smoothstep(0., 1., fract(z))\n        );\n}\n\nfloat map(vec2 p) {\n    float f = 0.;\n    for(float y=-Bounds; y<=Bounds; y++) {\n        for(float x=-Bounds; x<=Bounds; x++) {\n            float t = iTime + hash12(floor(p)-vec2(x, y));\n            vec3 ov = mapOV(p, vec2(x, y), t);\n            float cell = 1. - length(fract(p)-ov.xy+vec2(x, y)) / Radius;\n            f = max(f, cell * ov.z);\n        }\n    }\n    return f;\n}\n\nmat2 rotate(float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 res = iResolution.xy;\n    vec2 p = 8.*(2.+sin(iTime/9.))*(fragCoord.xy-res/2.)/res.y;\n    p.x+=49.*sin(iTime/9.);\n    p.y+=39.*cos(iTime/7.);\n    p*=rotate(iTime/6.);\n    fragColor = vec4(mix(\n                        .7-vec3(.9), \n                        1.3-vec3(\n                            abs(cos(iTime/2.)), \n                            1.-abs(cos(iTime/3.)), \n                            abs(sin(iTime/4.))),\n                          map(p)), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVfz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[185, 295, 317, 317, 433], [434, 434, 456, 456, 595], [597, 621, 658, 658, 835], [837, 837, 856, 856, 1213], [1215, 1215, 1237, 1237, 1304], [1306, 1306, 1363, 1363, 1826]], "test": "valid"}
{"id": "ttVfzR", "name": "Circuit Truchet", "author": "oneshade", "description": "Circuit board looking truchet pattern.", "tags": ["truchet", "pattern", "caustic", "circuit", "pcb"], "likes": 9, "viewed": 179, "published": "Public", "date": "1613791534", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 Rotate(in vec2 p, in float r) {\n    float c = cos(r), s = sin(r);\n    return p * mat2(c, -s, s, c);\n}\n\n// Hashes from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nfloat Hash21(in vec2 p) {\n\tvec3 p3 = fract(p.xyx * 0.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat Hash31(in vec3 p) {\n\tvec3 p3 = fract(p * 0.1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Smooth 3D noise\nfloat snoise(in vec3 p) {\n    vec3 c = floor(p);\n    vec3 l = fract(p);\n    l *= l * (3.0 - 2.0 * l);\n\n    float ldb = Hash31(c);\n    float rdb = Hash31(c + vec3(1.0, 0.0, 0.0));\n    float lub = Hash31(c + vec3(0.0, 1.0, 0.0));\n    float rub = Hash31(c + vec3(1.0, 1.0, 0.0));\n    float ldf = Hash31(c + vec3(0.0, 0.0, 1.0));\n    float rdf = Hash31(c + vec3(1.0, 0.0, 1.0));\n    float luf = Hash31(c + vec3(0.0, 1.0, 1.0));\n    float ruf = Hash31(c + 1.0);\n\n    return mix(mix(mix(ldb, rdb, l.x), mix(lub, rub, l.x), l.y),\n               mix(mix(ldf, rdf, l.x), mix(luf, ruf, l.x), l.y),\n               l.z);\n}\n\n// Hairy looking noise\nfloat hnoise(in vec3 p, in float scale, in float octaves) {\n    p *= scale;\n\n    float value = 0.0;\n    float nscale = 1.0;\n    float tscale = 0.0;\n\n    for (float octave=0.0; octave < octaves; octave++) {\n        // Magic numbers\n        p.xz *= mat2(-0.48406725864, -0.87503079323, 0.87503079323, -0.48406725864);\n        p.yz *= mat2(0.15022546991, -0.98865176285, 0.98865176285, 0.15022546991);\n\n        value += abs(snoise(p) * 2.0 - 1.0) * nscale;\n        tscale += nscale;\n        nscale *= 0.25;\n\n        p *= 2.0;\n    }\n\n    return value / tscale;\n}\n\n// Tile patterns\nfloat tile1(in vec2 cuv) {\n    float e = dot( cuv, vec2(0.71));\n    return min(abs(max( max(cuv.x, cuv.y), e + 0.2)), abs(max(-min(cuv.x, cuv.y), 0.2 - e))) - 0.025;\n}\n\nfloat tile2(in vec2 cuv) {\n    return abs(abs(dot(cuv, vec2(0.71))) - 0.355) - 0.02;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y + iTime * 0.1;\n    float unit = 10.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    uv *= 5.0;\n    vec2 cid = floor(uv);\n    vec2 cuv = fract(uv) - 0.5;\n\n    float h21 = Hash21(cid);\n    cuv = Rotate(cuv, floor(h21 * 4.0) * 1.57);\n\n    float d = h21 < 0.5 ? tile1(cuv) : tile2(cuv);\n    color.gb += vec2(0.25 + 0.25 * sin(uv.x + uv.y - iTime), 1.0) * smoothstep(unit, 0.0, d);\n\n    color.b += 0.5 * sin(d * 100.0);\n    color *= pow(1.0 - hnoise(vec3(uv, iTime), 1.0, 5.0), 3.0) * 2.0;\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVfzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 106], [108, 199, 224, 224, 335], [337, 337, 362, 362, 469], [471, 490, 515, 515, 1100], [1102, 1125, 1184, 1184, 1683], [1685, 1702, 1728, 1728, 1869], [1871, 1871, 1897, 1897, 1957], [1959, 1959, 2014, 2014, 2604]], "test": "valid"}
{"id": "ttyBW1", "name": "Yusef28's lens flare examined", "author": "jstrom2002", "description": "Breakdown of Yusef28's lens flare shadertoy with some minor changes and tidying of the code for clarity. Customizing the look of the flare is possible by editing values in the 'LensHighlight()' function.", "tags": ["lensflare"], "likes": 4, "viewed": 245, "published": "Public API", "date": "1614249155", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Based on an OpenGL implementation of Yusef28's code.\n// Yusef28's ' Circle & Polygon Lens Flare' shadertoy: https://www.shadertoy.com/view/Xlc3D2\n// This shadertoy is a work-in-progress.\n\n// Uniforms. Hardcoded for this shadertoy, pass in vals for your impl.\nint MAX_ITERATIONS = 4;\nvec3 cameraPosition = vec3(0.0);\n//vec3 lightPosition;//replace local var in 'mainImage()' w/ your uniform here\nvec3 lightColor = vec3(1.0);\nmat4 viewProjection;//Unused in shadertoy, use in your 3D impl.\n\n// Tweakable uniforms\nfloat lensFlareExposure = 1.0;\nfloat lensFlareBrightness = 1.0;\nfloat lensFlareScale = 0.175;\nfloat lensFlareFade = 1.0;//fades over 3D position between light and camera, unused for this shadertoy\n\n\n\nvec3 modelToScreen(vec3 v){//Unused in shadertoy, use in your 3D impl.\n\tvec4 v_2 = viewProjection * vec4(v,1.0);\n\tv_2.xyz = v_2.xyz / v_2.w;//to NDC\n\treturn vec3(v_2.xy * 0.5 + 0.5, v_2.z);//to [0,1]\n}\nfloat rnd(float w){\n    //Use bluenoise texture for fast lds random values in range [0,1]\n    return texture(iChannel0, vec2(w)).r;\n}\n\nfloat regularPolygon(vec2 p, int N){// Produces a regular polygon defined by N points on the unit circle.\n    float a=atan(p.x,p.y)+.2;\n    float b=6.28319/float(N);\n    return smoothstep(.5,.51, cos(floor(.5+a/b)*b-a)*length(p.xy));        \n}\n\nfloat renderSmallCircle(vec2 pos, vec2 ltpos, float dist, vec2 offsetFromCenter, float size)\n{\n\tvec2 coord = pos - ltpos * dist/2.0 + offsetFromCenter;\n\tfloat radiusVal =  0.04 / length(coord)*size;\n\tradiusVal = max(radiusVal, 0.0);//filter negative vals.\n\treturn radiusVal;\n}\n\nfloat renderBigCircle(vec2 pos, vec2 ltpos, float dist, vec2 offsetFromCenter, float size)\n{\n\tvec2 coord = pos + ltpos*dist + offsetFromCenter;\n\tfloat radiusVal =  0.01 - pow(length(coord), size * 1.4);\n\tradiusVal = max(radiusVal, 0.0);//filter negative vals.\n\treturn radiusVal;\t\n}\n\nfloat renderRing(float r, float offsetFromCenter, float fade)\n{\n\tfloat radiusVal = 0.001 - pow(r - offsetFromCenter, 1.0/fade) + sin(r * 30.0);\n\tradiusVal = max(radiusVal, 0.0);//filter negative vals.\n\treturn radiusVal;\t\n}\n\nfloat renderHexagon(vec2 uv, vec2 lightPos, vec2 offsetFromCenter, \n\tfloat hexagonIntervalDist, float size)\n{\n\tconst int hexagonPoints = 6;\n\tvec2 hexagonCoord = uv*size + lightPos*hexagonIntervalDist*size + offsetFromCenter;\n\tfloat hexValue = 0.01 - regularPolygon(hexagonCoord, hexagonPoints);\n   \thexValue = max(hexValue, 0.0);//filter negative vals.\n\treturn hexValue;\n}\n\nvec3 chromaticAberration(vec3 color, vec2 pos, vec2 ltpos, int iter)\n{   // NOTE: This function still needs some work.\n\n\tconst float intensity = 0.075;//adjust as needed.\n\tfloat amount = intensity * length(pos-ltpos) * \n\t\trnd(float(iter)*0.713) * float(iter);\t\n\n\t// Rotate which channels are being offset per iteration (i).\n\tvec3 cyclic_amt = (vec3(-0.95,-0.98,-1.0) + amount * \n\t\tvec3(iter%3,(iter+1)%3,(iter+2)%3));//vec3 of ints ranged [-1,1]\n\n    vec3 col = color + cyclic_amt;\n\treturn col * (1.0 - amount * 0.5);\n}\n\n// 'LensHighlight()' -- Generates 4 lens artifacts: a single large circle, small circle, ring, and hexagon.\n// Params:\n// pos: current fragment's screen-space position\n// lightPos: light's screen-space position\n// color: base color of highlight\n// size: size of lens highlight diameter\n// dist: distance between lens flare highlights in screen space\nvec3 LensHighlight(vec2 pos, vec2 lightPos, vec3 color, float size, float dist, int i)\n{   \n    // Create a big circle, ring, small circle, and hexagon and control blending with a vec4.\n\tconst vec4 blend_val = 0.01 * vec4(2500.0, 20.0, 1.50, 2000.0);//adjust as necessary per-object.\n\t\n    float bigCircle_size = size * 0.2 * float(i);\n    vec2 bigCircle_offset = -lightPos * vec2(2.0);\n    float bigCircle = renderBigCircle(pos,lightPos,dist,bigCircle_offset, bigCircle_size) * blend_val.x;    \n    \n    float ring_fade = 7.0 * float(i);\n\tvec2 ring_offset = \n        //vec2(0.0);//<== rings around light source.\n        -lightPos * vec2(2.5) * float(i);//<== ring halos in light ray.\n    float ring_size = size * 5.0 * float(i);\n    float lt_coord = length(pos - lightPos - ring_offset);\n    float ring_radius  = lt_coord + ring_size; \n\tfloat ring = renderRing(ring_radius, ring_size, ring_fade) * blend_val.y;   \n\n\tvec2 smallCircle_offset = lightPos * vec2(0.0159);\n    float smallCircle_size = 84.0;\n\tfloat smallCircle = renderSmallCircle(pos,lightPos,dist,smallCircle_offset, smallCircle_size) * blend_val.z;\n    \n    // Draws hexagons in order closest to light to farthest.\n\tvec2 hexagon_offset = -lightPos * vec2(1.5) * float(i) + lightPos * 0.32;\n\tfloat hexagon_size = 11.0 - 2.0 * float(i);\n    float hexagon_fade = 0.25 * pow(float(i), 2.5);\n\tfloat hexagon  = renderHexagon(pos,lightPos,hexagon_offset,dist,hexagon_size)*hexagon_fade*blend_val.w;\n    \n\t// Slightly offset colors to simulate chromatic abberration.\n\tcolor = chromaticAberration(color, pos, lightPos, i);\n \treturn (smallCircle + bigCircle + ring + hexagon) * color;\n}\n\n// 'LensFlare()' -- Main function for accumulating flare color.\n// Params:\n// currPos: current fragment's screen-space position\n// lightPos: light's screen-space position\n// distToLight: world space distance between camera and light.\nvec3 Lensflare(vec2 currPos, vec2 lightPos, float distToLight)\n{\n\n\tvec3 flareColor = vec3(0.0);\n\tfloat lt_dist = distToLight+1.0f;//prevent division by val < 1.\n\tfloat proximity_divisor = length(currPos-lightPos);\n\tfloat loopVal = 1.0f;\n\tint i = 1;\n\n\tconst float epsiln = 0.0001f;\n\twhile(loopVal > epsiln && i < MAX_ITERATIONS)\n\t{\n\t\tfloat i_f = float(i);\n\t\tvec2 pos = currPos;//square value to produce appropriate warping effect\n\t\tvec2 lpos = lightPos;\n\t\tvec3 color_rand = 2.0 * i_f * vec3(rnd(i_f * 3.0913));\n\t\tvec3 col = lightColor + clamp(color_rand, 0.0, 1.0);\n\t\tfloat flareSize = \n\t\t\t i_f*i_f*pow(rnd(i_f * 21.773) * 1.8, 1.0) + 0.5;\n\t\tfloat flareInterval = \n\t\t\t(lensFlareScale/lt_dist) * pow(rnd(i_f * 7.11) * 3.0, 2.5) + 0.05;\n\t\t\t\t\t\n\t\tvec3 passColor = LensHighlight(pos,lpos,col,flareSize,flareInterval,i); \n\n\t\tpassColor *= lensFlareBrightness / (i_f * 1.15);\n\t\tflareColor += passColor;\n\t\tloopVal /= proximity_divisor;\n\t\ti++;\n\t}\n\n\treturn flareColor;\n}\nfloat scaleDepth(float depth)\n{// Intended to map values in range d = (0,1] to range (1,0] to rolloff values by distance.\n\treturn exp(-abs(depth * lensFlareFade * 0.01));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\t// Get screen space pixel position. Note that in view space, camera is at vec3(0).\n\tvec3 uv = vec3(fragCoord/iResolution.xy,0)-0.5;\n\tuv.x *= iResolution.x/iResolution.y; // aspect correct\n    \n\t// Get screen space light position.\n    vec3 lightPosition = 0.25*(vec3(cos(iTime),sin(iTime),-0.1) - 0.5);//hardcoded for shader\n\tvec3 lightPos = lightPosition;\n    //vec3 lightPos = modelToScreen(lightPosition3D)-0.5; <== implementation for world space light pos\t\n    lightPos.x *= iResolution.x/iResolution.y; // aspect correct\n\n\tfloat distToLight = length(lightPosition - cameraPosition);\n\n\t// Bail early conditions.\n\tif(lensFlareScale <= 0.000001 || distToLight <= 0.00001)\n\t\treturn;\n\n\t// Calculate lens flare effect.\n\tfloat depthFade = scaleDepth(distToLight);\n\tvec3 color = Lensflare(uv.xy, lightPos.xy, distToLight);\n\t\n\t// Post-process, scaling strength by distance of observer to light source.\n\tcolor *= depthFade;//Adjust lens flare for camera distance to light.\n\tcolor = vec3(1.0) - exp(-color.rgb * lensFlareExposure * depthFade);// exposure tone mapping\n\tcolor = max(color, 0.0);//remove negative values\n\n    // Add faked light source.\n    float uvDistToLight = length(uv.xy - lightPos.xy);\n    float lightsrc = clamp(1.0-uvDistToLight*7.0, 0.0, 1.0);\n    \n    // Add rays from light source -- a rough approximation of volumetric light rays.\n    float ray_factor = 1.00;\n    float a = ray_factor * atan(uv.y-lightPos.y, uv.x-lightPos.x);\n    lightsrc += max(0.1/pow(length(uvDistToLight)*5., 5.), 0.0)*abs(sin(a*5.+cos(a*9.)))/20.;\n    lightsrc += max(0.1/pow(length(uvDistToLight)*10., 1./20.), .0)+abs(sin(a*3.+cos(a*9.)))/8.*(abs(sin(a*9.)))/1.;\n    float lightsrc_attenuation = depthFade * (1.0-uvDistToLight*uvDistToLight) * 1.0;\n    color += lightsrc * lightsrc_attenuation;\n\n    // Output final color.\n\tfloat alpha = depthFade*(color.r + color.g + color.b) / 3.0f; //optional alpha blending.\n\tfragColor = vec4(color.rgb, alpha);\n}", "image_inputs": [{"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttyBW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[634, 714, 741, 784, 915], [916, 916, 935, 1005, 1049], [1051, 1051, 1087, 1156, 1294], [1296, 1296, 1390, 1390, 1572], [1574, 1574, 1666, 1666, 1855], [1857, 1857, 1920, 1920, 2079], [2081, 2081, 2190, 2190, 2453], [2455, 2455, 2525, 2573, 2974], [2976, 3326, 3414, 3511, 4966], [4968, 5202, 5266, 5266, 6160], [6161, 6161, 6192, 6282, 6333], [6335, 6335, 6392, 6477, 8339]], "test": "error"}
{"id": "ttycz1", "name": "Projet Graphisme", "author": "Heven", "description": "Project", "tags": ["test"], "likes": 0, "viewed": 39, "published": "Public", "date": "1612714427", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float FARAWAY=1e30;\nconst float EPSILON=1e-3;\n\nstruct Camera {\n    vec3 Obs;\n    vec3 View;\n    vec3 Up;\n    vec3 Horiz;\n    float H;\n    float W;\n    float z;\n};\n\nstruct Ray {\n    vec3 Origin;\n    vec3 Dir;\n};\n\nvec3 Grid(Ray R) {\n    float alpha = float(iFrame)/60.0;\n    vec3 Origin = R.Origin;\n    vec3 Dir = R.Dir;\n\tfloat d = -Origin.z/Dir.z;\n    \n    if (d <= 0.0) return vec3(abs(0.8*cos(alpha*.5)), abs(0.8*sin(alpha)), abs(0.8*sin(alpha*.7)));\n    \n   \tvec2 p = (Origin.xy + Dir.xy*d);\n    \n    vec2 e = min(vec2(1.0), fwidth(p));\n    \n    vec2 l = smoothstep(vec2(1.0), 1.0 - e, fract(p)) + smoothstep(vec2(0.0), e, fract(p)) - (1.0 - e);\n\n    return mix(vec3(0.4), vec3(0.8) * (l.x + l.y) * 0.5, exp(-d*0.01));\n}\n\nCamera camera(in vec3 Obs, in vec3 LookAt, in float aperture) {\n   Camera C;\n   C.Obs = Obs;\n   C.View = normalize(LookAt - Obs);\n   C.Horiz = normalize(cross(vec3(0.0, 0.0, 1.0), C.View));\n   C.Up = cross(C.View, C.Horiz);\n   C.W = float(iResolution.x);\n   C.H = float(iResolution.y);\n   C.z = (C.H/2.0) / tan((aperture * 3.1415 / 180.0) / 2.0);\n   return C;\n}\n\nRay launch(in Camera C, in vec2 XY) {\n   return Ray(\n      C.Obs,\n      C.z*C.View+(XY.x-C.W/2.0)*C.Horiz+(XY.y-C.H/2.0)*C.Up \n   );\n}\n\nstruct Sphere {\n   vec3 Center;\n   float R;\n};\n\nstruct Material{\n    vec3 object;//couleur de l'objet\n    vec3 light;//couleur de la lumière\n    vec3 reflect;//objet réfléchissant\n};\n\nstruct Object{\n    Sphere sphere;\n    Material material;\n    int type;//0 pour un objet, 1 pour la lumière et 2 pour un objet réfléchissant\n};\n\nObject object[29];\n\nMaterial material(in vec3 color){\n    return Material(color,vec3(0,0,0),vec3(0,0,0));\n}\n\nMaterial light(in vec3 color){\n    return Material(color,color,vec3(0,0,0));\n}\n\nMaterial reflect(in vec3 color, in vec3 reflect){\n    return Material(color,vec3(0,0,0),reflect);\n}\n\n\nbool intersect_sphere(in Ray R, in Sphere S, out float t) {\n   vec3 CO = R.Origin - S.Center;\n   float a = dot(R.Dir, R.Dir);\n   float b = 2.0*dot(R.Dir, CO);\n   float c = dot(CO, CO) - S.R*S.R;\n   float delta = b*b - 4.0*a*c;\n   if(delta < 0.0) {\n      return false;\n   }\n   t = (-b-sqrt(delta)) / (2.0*a);\n   return true;\n}\n\nvoid intersect_sphere2(in Ray R, in Object O, out vec3 Color, \ninout float t, inout vec3 P, out vec3 N, out int type) {\n    float current_t;\n    if(intersect_sphere(R,O.sphere,current_t) \n    && current_t < t && current_t > EPSILON && current_t > 0.0) {\n      Color = O.material.object;\n      t = current_t;\n      P = R.Origin + t*R.Dir;\n      N = normalize(P - O.sphere.Center);\n      type = O.type;\n   }\n}\n\nbool shadow(in Ray R) {\n   float t;\n   for(int i=0; i<object.length(); ++i) {\n        if(\n          (object[i].type==0 || object[i].type==2) &&\n          intersect_sphere(R, object[i].sphere, t) &&\n          t > EPSILON && t < 1.0\n        ) {\n          return true;\n        }\n    }\n    return false;\n}\n\nfloat minFloat(in float a, in float b){\n    if (a<b){\n        return a;\n    }\n    else{\n        return b;\n    }\n}\n\nvec3 addColors(in vec3 color1, in vec3 color2){\n    float r=minFloat(color1.x+color2.x,1.0);\n    float g=minFloat(color1.y+color2.y,1.0);\n    float b=minFloat(color1.z+color2.z,1.0);\n    return vec3(r,g,b);\n}\n\nvec3 midColors(in vec3 color1, in vec3 color2){\n    float r=(color1.x+color2.x)/2.;\n    float g=(color1.y+color2.y)/2.;\n    float b=(color1.z+color2.z)/2.;\n    return vec3(r,g,b);\n}\n\n\nvoid init(){\n    float alpha = float(iFrame)/60.0;\n    float s = sin(0.5*alpha);\n    float c = cos(0.5*alpha);\n    float X2 = 2.0*c;\n    float Y2 = 2.0*s;\n    float s2 = sin(-1.0*alpha);\n    float c2 = cos(-1.0*alpha);\n    float X3 = X2+0.5*c2;\n    float Y3 = Y2+0.5*s2;\n    float Z3 = cos(-1.0*alpha);\n    Sphere S1 = Sphere(vec3(0.0, 0.0, 0.0), 1.0);\n    Sphere S2 = Sphere(vec3(X2, Y2, 0.0), 0.3);\n    Sphere S4 = Sphere(vec3(X3, Y3, Z3), 0.1);\n    Object O1 = Object(S1, material(vec3(1.0, 0.0, 0.0)),0);//objet rouge\n    Object O2 = Object(S2, material(vec3(1.0, 1.0, 1.0)),0);//objet blanc\n    Object O3 = Object(S4, material(vec3(1.0, 1.0, 1.0)),0);//objet blanc\n    Sphere S3 = Sphere(vec3(3.0,1.0,0.2), 0.1);\n    Sphere S5 = Sphere(vec3(-1.0,3.0,0.2), 0.1);\n    Object L1 = Object(S3, light(vec3(abs(cos(alpha*.5)), abs(sin(alpha)), abs(sin(alpha*.7)))),1);//lumière multicolore\n    Object L2 = Object(S5, light(vec3(1.-abs(sin(alpha*0.9)), abs(0.8*sin(alpha*0.1)), abs(1.-cos(alpha*2.0)))),1);//lumière multicolore\n    object[0]=O1;\n    object[1]=O2;\n    object[2]=L1;\n    object[3]=O3;\n    object[4]=L2;\n    for(float i=-3.; i<6.; i++) {\n        float s = sin(0.5*(alpha+i/2.5));\n        float c = cos(0.5*(alpha+i/2.5));\n        float X2 = (1.50-(1.-abs(cos(i/3.))))*c;\n        float Y2 = (1.50-(1.-abs(cos(i/3.))))*s;\n        Sphere S2 = Sphere(vec3(X2, Y2, i/1.9), 0.1);\n        vec3 color;\n        if (abs(int(i))%4==0){\n            color=vec3(0.78,.0,.99);\n        }else if (abs(int(i))%4==1){\n            color=vec3(0.,.9,1);\n        }else if (abs(int(i))%4==2){\n            color=vec3(1,.43,.0);\n        }else if (abs(int(i))%4==3){\n            color=vec3(0.,.02,1);\n        }\n        Object O = Object(S2, material(color),0);\n        object[int(i)+8]=O;\n    }\n    for(float i=-3.; i<6.; i++) {\n        float s = sin(0.5*(-170.+alpha+i/2.5));\n        float c = cos(0.5*(-170.+alpha+i/2.5));\n        float X2 = (1.50-(1.-abs(cos(i/3.))))*c;\n        float Y2 = (1.50-(1.-abs(cos(i/3.))))*s;\n        vec3 color;\n        if (abs(int(i))%4==0){\n            color=vec3(0.78,.0,.99);\n        }else if (abs(int(i))%4==1){\n            color=vec3(0.,.9,1);\n        }else if (abs(int(i))%4==2){\n            color=vec3(1,.43,.0);\n        }else if (abs(int(i))%4==3){\n            color=vec3(0.,.02,1);\n        }\n        Sphere S2 = Sphere(vec3(X2, Y2, i/1.9), 0.1);\n        Object O = Object(S2, material(color),0);\n        object[int(i)+20]=O;\n    }\n    /*Sphere S6 = Sphere(vec3(-1.0, -3.0, 2.0), 1.0);\n    Object L3 = Object(S6, light(vec3(0.9,0.5,1.)),1);\n    object[27]=L3;*/\n    Sphere SR = Sphere(vec3(1.0, -3.0, 0.0), 1.0);\n    Object OR = Object(SR, reflect(vec3(0.88, .80, 0.85), vec3(0.8, 0.8, 0.8)),2);\n    object[28]=OR;\n}\n\nvec3 lightning(in vec3 P,in vec3 N, in vec3 Color, in int type){\n    vec3 intensity=vec3(0,0,0);// intensité de la lumière en 1 point\n    for(int i=0; i<object.length(); ++i) {\n        if (object[i].type==1){//Si c'est une source de lumière\n            Ray R2=Ray(P,object[i].sphere.Center);\n            if (!shadow(R2)){\n                vec3 E = object[i].sphere.Center - P;\t// Calcul du vecteur d'éclairement\n                float costheta = dot(N,E) / (length(N)*length(E));\n                costheta = max(costheta, 0.0);\n                intensity += costheta *midColors(Color,object[i].material.light);\n            }\n            if (type == 1){\n                intensity=Color;\n            }\n        }\n    }\n    return intensity;\n}\n\nRay raytrace(in Ray R, in vec3 P, in vec3 N){\n    return Ray(\n      P,\n      -2.0*dot(N,R.Dir)*N + R.Dir\n   );\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n   init();\n   float mouseX = (8.35 * float(iMouse.x/iResolution.x))-2.0;\n   float mouseY = (8.35 * float(iMouse.y/iResolution.y)-1.5)*2.0;\n   Camera C = camera(\n       vec3(2.0, 2.0, 2.0),\n       vec3(mouseX,sin(mouseX),mouseY),\n       100.0       \n   );\n   Ray R = launch(C, fragCoord);\n  \n   vec3 Color = Grid(R);//Couleur du fond \n   float t = FARAWAY;\n   vec3 P;\n   vec3 N;\n   int type;\n\n   for(int i=0; i<object.length(); ++i) {\n       intersect_sphere2(R,object[i],Color,t,P,N,type);\n   }\n\n   if(t != FARAWAY) {\n        Color = lightning(P, N, Color, type);\n        if(type==2) {\n            R = raytrace(R, P, N);\n            for(int i=0; i<object.length(); ++i) {\n                intersect_sphere2(R, object[i], Color, t, P, N, type);\n                if(t != FARAWAY) {\n                    Color = object[i].material.reflect*lightning(P, N, Color, type);\n                }\n            }\n        }\n    }\n   \n   fragColor = vec4(Color, 1.0);\n}", "image_inputs": [{"id": "XtfSzM", "previewfilepath": "https://soundcloud.com/relaxdaily/relaxing-music-calm-studying-yoga", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/relaxdaily/relaxing-music-calm-studying-yoga", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttycz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[218, 218, 236, 236, 728], [730, 730, 793, 793, 1091], [1093, 1093, 1130, 1130, 1227], [1583, 1583, 1616, 1616, 1670], [1672, 1672, 1702, 1702, 1750], [1752, 1752, 1801, 1801, 1851], [1854, 1854, 1913, 1913, 2179], [2181, 2181, 2300, 2300, 2588], [2590, 2590, 2613, 2613, 2891], [2893, 2893, 2932, 2932, 3006], [3008, 3008, 3055, 3055, 3216], [3218, 3218, 3265, 3265, 3399], [3402, 3402, 3414, 3414, 6144], [6146, 6146, 6210, 6210, 6885], [6887, 6887, 6932, 6932, 6999], [7002, 7002, 7059, 7059, 8014]], "test": "valid"}
{"id": "ttyfW1", "name": "Mondrian by Liv", "author": "Livie", "description": "Generative Mondrian", "tags": ["2d", "colors", "geometric", "mondrian", "primary"], "likes": 1, "viewed": 147, "published": "Public", "date": "1614249959", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat paintregion (float col1, float col2, float colx, float row1, float row2, float rowx) {\n    vec2 st = gl_FragCoord.xy/iResolution.xy;\n    float region = step(min(col1, col2),st.x) * step(st.x, max(col1, col2)); // between col2 and col1\n    region *= max(step(colx, col2) * step(colx, col1), step(col2, colx) * step(col1, colx)); // only if both are < or > colx\n    region *= step(min(row1, row2),st.y) * step(st.y, max(row1, row2)); // between row2 and row1\n    region *= max(step(rowx, row2) * step(rowx, row1), step(row2, rowx) * step(row1, rowx)); // only if both are < or > rowx\n    return region;  \n}\n\nfloat paintminicol(float miniwidth, float col1, float col2, float colx, float row1, float row2, float rowx) {\n    vec2 st = gl_FragCoord.xy/iResolution.xy; \n    float mini = step((col1+col2)/2.0-miniwidth,st.x) * step(st.x, (col1+col2)/2.0+miniwidth); // between col2 and col1\n    mini *= max(step(colx, col2) * step(colx, col1), step(col2, colx) * step(col1, colx)); // only if both are < or > colx\n    mini *= step(min(row1, row2),st.y) * step(st.y, max(row1, row2)); // between row2 and row1\n    mini *= max(step(rowx, row2) * step(rowx, row1), step(row2, rowx) * step(row1, rowx)); // only if both are < or > rowx\n    return mini;  \n}\n\nfloat paintminirow(float miniheight, float col1, float col2, float colx, float row1, float row2, float rowx) {\n    vec2 st = gl_FragCoord.xy/iResolution.xy; \n    float mini = step((row1+row2)/2.0-miniheight,st.y) * step(st.y, (row1+row2)/2.0+miniheight); // between row2 and row1\n    mini *= max(step(rowx, row2) * step(rowx, row1), step(row2, rowx) * step(row1, rowx)); // only if both are < or > rowx\n    \n    \n    mini *= step(min(col1, col2),st.x) * step(st.x, max(col1, col2)); // between col2 and col1\n    mini *= max(step(colx, col2) * step(colx, col1), step(col2, colx) * step(col1, colx)); // only if both are < or > colx\n    return mini;  \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n    vec2 st = fragCoord.xy/iResolution.xy;\n    vec3 color = vec3(0.0);\n\n    float xwide = 0.02;\n    float xthin = 0.01;\n    float ywide = 0.02;\n    float ythin = 0.01;\n    \n    float spda = 0.06;\n    float spdb = 0.09;\n    float spdc = -0.07;\n    float spdd = 0.1;\n    float spde = -0.08;\n    float spdf = 0.12;\n    \n    float cola = mod(0.1+iTime*spda, 1.2) - 0.1;\n    float all = 1.0 - step(cola,st.x) * step(st.x, cola+xwide);\n    float colb = mod((0.3+iTime*spdb), 1.2) - 0.1;\n    all *= 1.0 - step(colb,st.x) * step(st.x, colb+xthin);\n    float colc = mod((0.5+iTime*spdc), 1.2) - 0.1;\n    all *= 1.0 - step(colc,st.x) * step(st.x, colc+xwide);\n    \n    float rowd = mod(0.1+iTime*spdd, 1.2) - 0.1;\n    all *= 1.0 - step(rowd,st.y) * step(st.y, rowd+ythin);\n    float rowe = mod((0.3+iTime*spde), 1.2) - 0.1;\n    all *= 1.0 - step(rowe,st.y) * step(st.y, rowe+ywide);\n    float rowf = mod((0.5+iTime*spdf), 1.2) - 0.1;\n    all *= 1.0 - step(rowf,st.y) * step(st.y, rowf+ywide);\n    \n    color = vec3(all);\n    \n    float pred;\n    pred = paintregion(colb, colc, cola, rowe, rowf, rowd); \t\t// BC EF\n    color *= vec3(1.0-0.1*pred,1.0-0.8*pred, 1.0-0.75*pred);\n    pred = paintregion(cola, colb, colc, rowd, rowe, rowf); \t\t// AB DE\n    color *= vec3(1.0-0.1*pred,1.0-0.8*pred, 1.0-0.75*pred);\n    \n    float pblue;\n    pblue = paintregion(cola, colc, colb, rowe, rowf, rowd); \t\t// AC EF\n    color *= vec3(1.0-0.75*pblue,1.0-0.8*pblue, 1.0-0.1*pblue);\n    pblue = paintregion(cola, colb, colc, rowd, rowf, rowe); \t\t// AB DF\n    color *= vec3(1.0-0.75*pblue,1.0-0.8*pblue, 1.0-0.1*pblue);\n        \n    float pyellow;\n    pyellow = paintregion(colb, colc, cola, rowd, rowe, rowf); \t\t// BC DE\n    color *= vec3(1.0-0.1*pyellow,1.0-0.2*pyellow, 1.0-0.8*pyellow);\n    \n    float pgrey;\n    pgrey = paintregion(cola, colc, colb, rowd, rowf, rowe); \t\t// AC DF\n    color *= vec3(1.0-0.3*pgrey,1.0-0.3*pgrey, 1.0-0.3*pgrey);\n    \n    float mwidth = 0.005; \n    float minicol;\n    minicol = paintminicol(mwidth, cola, colc, colb, rowd, rowe, rowf); \t\t// AC DE\n    color *= 1.0 - minicol;\n    minicol = paintminicol(mwidth, colb, colc, cola, rowd, rowf, rowe); \t\t// BC DF\n    color *= 1.0 - minicol;\n    \n    float mheight = 0.005; \n    float minirow = paintminirow(mheight, cola, colb, colc, rowe, rowf, rowd); \t// AB EF\n    color *= 1.0 - minirow;\n\n    //gl_FragColor = vec4(color,1.0);\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttyfW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 93, 93, 611], [613, 613, 722, 722, 1251], [1253, 1253, 1363, 1363, 1904], [1907, 1907, 1964, 2056, 4496]], "test": "valid"}
{"id": "wdKBWh", "name": "Menger Noise Prison", "author": "Parcle", "description": "Sometimes things go so wrong that they make their way back to right.\n\nTell your GPU that I am sorry.\n\nby Connor Alexander Haskins - Parcle - https://twitter.com/Lucodivo", "tags": ["noise", "mengersponge"], "likes": 2, "viewed": 126, "published": "Public API", "date": "1613457331", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n * \"Menger Noise Prison\" by Connor Alexander Hasking - 2021\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * Contact: ConnorAHaskins@gmail.com\n */\n\n#define MAX_STEPS 60 // less steps will increase performance but narrow viewing distance, and lower detail & overall brightness\n#define MISS_DIST 200.0\n#define HIT_DIST 0.01\n    \nint distanceRayToScene(vec3 rayOrigin, vec3 rayDir);\nfloat distPosToScene(vec3 rayPos);\n\nmat2 rotate(float angle);\n\nfloat sdRect(vec2 rayPos, vec2 dimen);\nfloat sdCross(vec3 rayPos, vec3 dimen);\nfloat sdCube(vec3 rayPos);\nfloat sdMengerNoisePrison(vec3 rayPos);\n\nfloat rayNoiseValue(vec3 rayPos);\n\nconst vec3 missColor = vec3(0.1, 0.1, 0.1);\nconst float boxDimen = 20.0;\nconst float halfBoxDimen = boxDimen / 2.0;\n\nconst int mengerSpongeIterations = 3;\nconst float pi = 3.14159265;\nconst float piOver4 = pi * 0.25;\nconst float tau = pi * 2.0f;\nconst vec3 startingRayOrigin = vec3(0.0, 0.0, -boxDimen);\n\nconst float velocityUnit = boxDimen; // velocity in terms of length of the largest menger cube\nconst float velocity = 0.5; // velocity units per second\nconst float secondsPerCycle = 4.0 / velocity;\nconst float cyclesPerSecond = 1.0 / secondsPerCycle;\n\nint cycleModulo6 = 0;\nint noiseIndex0 = 0;\nint noiseIndex1 = 1;\nfloat cycleFract = 0.0;\n\nconst float highYLevel[3] = float[](1.0, 0.5 + (3.0 / 18.0), 0.5 + (3.0 / 54.0));\nconst vec2 upRightLeftDownVecs[4] = vec2[](vec2(0.0, 1.0), vec2(1.0, 0.0), vec2(0.0, -1.0), vec2(-1.0, 0.0));\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n    vec2 pixelCoord = fragCoord.xy - (iResolution.xy * 0.5);\n    pixelCoord = pixelCoord / iResolution.y;\n    \n    float cycle = iTime * cyclesPerSecond;\n    int cycleTrunc = int(cycle);\n    float cosY = -cos(tau * cycle); // cycles per second\n    float smoothY = smoothstep(-0.60, 0.60, cosY);\n    int upRightLeftDownIndex = cycleTrunc % 4;\n    int highYLevelIndex = cycleTrunc % 3;\n    float highLevelY = highYLevel[highYLevelIndex];\n    \n    float offset1d = smoothY * boxDimen * highLevelY;\n    vec3 offset3d = vec3(offset1d * upRightLeftDownVecs[upRightLeftDownIndex], iTime * velocity * velocityUnit);\n    vec3 rayOrigin = startingRayOrigin + offset3d;\n    vec3 fragmentPos = vec3(pixelCoord.x, pixelCoord.y, 0.0);\n    const vec3 focalPoint = vec3(0.0, 0.0, -1.0);\n    vec3 rayDir = fragmentPos - focalPoint;\n    \n    // special case as the mouse starts in the lower left when we want it to start in the center\n    vec2 normalizedMouseCoord = iMouse.x > 0.0 ?(((iMouse.xy / iResolution.xy) - vec2(0.5)) * 2.0) : vec2(0,0);\n    if(length(normalizedMouseCoord) > 1.0) { // reduce maximum distance of mouse from center to be 1 unit\n        normalizedMouseCoord = normalize(normalizedMouseCoord);\n    }\n    mat2 rotateYaw = rotate(normalizedMouseCoord.x * piOver4);\n    mat2 rotatePitch = rotate(normalizedMouseCoord.y * piOver4);\n    rayDir = vec3(rayDir.x, rotatePitch * rayDir.yz);\n    rayDir = vec3(rotateYaw * rayDir.xz, rayDir.y).xzy;\n    rayDir = normalize(rayDir);\n\n    cycleModulo6 = (cycleTrunc - 1) % 6; // offset cycleTrunc so that noise transition occurs during highYLevel[0], instead of highYLevel[2]\n    noiseIndex0 = cycleModulo6 / 3;\n    noiseIndex1 = abs(noiseIndex0 - 1);\n    // when cycleModulo is 2 or 5, enable cycleFract for lerping between noise\n    cycleFract = step(2.0, float(cycleModulo6 % 3)) * fract(iTime * cyclesPerSecond);\n    \n    int iteration = distanceRayToScene(rayOrigin, rayDir);\n\n    if(iteration < MAX_STEPS) { // hit\n        vec3 col = vec3(1.0 - (float(iteration)/float(MAX_STEPS)));\n        fragColor = vec4(col, 1.0);\n    } else { // miss\n        fragColor = vec4(missColor, 1.0);\n    }\n}\n\n\n// returns num iterations\n// NOTE: ray dir arguments are assumed to be normalized\nint distanceRayToScene(vec3 rayOrigin, vec3 rayDir) {\n\n\tfloat dist = 0.0;\n\n\tfor(int i = 0; i < MAX_STEPS; i++) {\n        vec3 pos = rayOrigin + (dist * rayDir);\n        float posToScene = sdMengerNoisePrison(pos) + rayNoiseValue(pos);\n        dist += posToScene;\n        if(abs(posToScene) < HIT_DIST) return i; // absolute value for posToScene incase the ray makes its way inside an object\n        if(posToScene > MISS_DIST) break;\n    }\n\n    return MAX_STEPS;\n}\n\n\n// NOTE: Piggy status of this function more directly related to the fairly random distance which results from the noise\n// NOTE: and, in turn, results in larger iterations that each ray takes. It is NOT simply the tripple sin calculations\n// NOTE: below (though I'm sure that doesn't help :()\nfloat rayNoiseValue(vec3 rayPos) {\n  // removing one creates a weird \"light source\" and \"tubes\" effect in the direction of the light\n  // removing two creates a plane of light\n  const float noiseFudgeMult = 20.0;\n  \n  vec3 rayPosFudge = noiseFudgeMult * rayPos;\n  float noiseVals[2] = float[](\n      sin(rayPosFudge.x)*sin(rayPosFudge.y)*sin(rayPosFudge.z), // normal?\n      fract(rayPosFudge.z) // ghost\n  );\n  \n  return mix(noiseVals[noiseIndex0], noiseVals[noiseIndex1], cycleFract);\n}\n\nfloat sdCube(vec3 rayPos) {\n\tconst vec3 corner = vec3(halfBoxDimen);\n    vec3 ray = abs(rayPos); // fold ray into positive octant\n    vec3 cornerToRay = ray - corner;\n    float cornerToRayMaxComponent = max(max(cornerToRay.x, cornerToRay.y), cornerToRay.z);\n    float distToInsideRay = min(cornerToRayMaxComponent, 0.0);\n    vec3 closestToOutsideRay = max(cornerToRay, 0.0);\n\treturn length(closestToOutsideRay) + distToInsideRay;\n}\n\n\nfloat sdCross(vec3 rayPos) {\n    const vec3 corner = vec3(halfBoxDimen);\n\tvec3 ray = abs(rayPos); // fold ray into positive quadrant\n\tvec3 cornerToRay = ray - corner;\n\n    float smallestComp = min(min(cornerToRay.x, cornerToRay.y), cornerToRay.z);\n\tfloat largestComp = max(max(cornerToRay.x, cornerToRay.y), cornerToRay.z);\n\tfloat middleComp = cornerToRay.x + cornerToRay.y + cornerToRay.z\n\t\t\t\t\t\t\t- smallestComp - largestComp;\n            \n\tvec2 closestOutsidePoint = max(vec2(smallestComp, middleComp), 0.0);\n\tvec2 closestInsidePoint = min(vec2(middleComp, largestComp), 0.0);\n\n\treturn (middleComp > 0.0) ? length(closestOutsidePoint) : -length(closestInsidePoint);\n}\n\nfloat sdMengerNoisePrison(vec3 rayPos) {\n  vec3 prisonRay = mod(rayPos, boxDimen * 2.0);\n  prisonRay -= boxDimen;\n\n  float mengerPrisonDist = sdCross(prisonRay, vec3(halfBoxDimen));\n\n  float scale = 1.0;;\n  for(int i = 0; i < 3; ++i) {\n    float boxedWorldDimen = boxDimen / scale;\n    vec3 ray = mod(rayPos + boxedWorldDimen / 2.0, boxedWorldDimen);\n    ray -= boxedWorldDimen * 0.5;\n    ray *= scale;\n    float crossesDist = sdCross(ray * 3.0, vec3(halfBoxDimen));\n    scale *= 3.0;\n    crossesDist /= scale;\n    mengerPrisonDist = max(mengerPrisonDist, -crossesDist);\n  }\n\n  return mengerPrisonDist;\n}\n\n\nfloat sdRect(vec2 rayPos, vec2 dimen) {\n  vec2 rayToCorner = abs(rayPos) - dimen;\n  // maxDelta is the maximum negative value if the point exists inside of the box, otherwise 0.0\n  float maxDelta = min(max(rayToCorner.x, rayToCorner.y), 0.0);\n  return length(max(rayToCorner, 0.0)) + maxDelta;\n}\n\nfloat sdCross(vec3 rayPos, vec3 dimen) {\n  float da = sdRect(rayPos.xy, dimen.xy);\n  float db = sdRect(rayPos.xz, dimen.xz);\n  float dc = sdRect(rayPos.yz, dimen.yz);\n  return min(da,min(db,dc));\n}\n\nmat2 rotate(float angle) {\n    float sine = sin(angle);\n    float cosine = cos(angle);\n    return mat2(cosine, -sine, sine, cosine);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdKBWh.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1011, 1508, 1563, 1563, 3704], [3707, 3789, 3842, 3842, 4252], [4255, 4548, 4582, 4723, 5036], [5038, 5038, 5065, 5065, 5469], [5472, 5472, 5500, 5500, 6140], [6142, 6142, 6182, 6182, 6746], [6749, 6749, 6788, 6788, 7044], [7046, 7046, 7086, 7086, 7243], [7245, 7245, 7271, 7271, 7379]], "test": "error"}
{"id": "wl3BDj", "name": "pixel chest generator", "author": "cody_shader", "description": ".", "tags": ["pixel", "random", "chest"], "likes": 8, "viewed": 120, "published": "Public", "date": "1613438615", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float noise2 (float a, float b) {\n    float buff1 = fract((10000.f + abs(b + a)) * fract(a * fract((100.f + b) * fract(a * 0.0171 + b))));\n    return(buff1 * 1.0038 - 0.00185) + 0.001;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    float displase = floor (iResolution.y/250.0)*5.0;\n    float lenght = iResolution.y/displase;\n    \n    \n    float sdvig = sign(fract(floor(uv.y*displase)*0.5)-0.25);\n    uv.x += iTime*0.1*sdvig;\n    \n    float floory = floor(uv.y*displase);\n   \n    float pix = 16.0;\n    //pix = 8.0+floory*2.0; //pixel size variation\n    float fracty = fract(uv.y*displase); \n    float floorx = floor(uv.x*displase-2.5);\n    if (abs(floorx)<0.1) floorx = 100.0;\n    float fractx = fract(uv.x*displase);\n   \n    float fractxx = fract(fractx*2.0);\n    if (fractx*2.0 < 1.0) fractxx = 1.0-fractxx;\n    \n    float flooryyy = floor(fracty*pix);\n    float floorxxx = floor(fractxx*pix*0.5);\n    \n    float rand = noise2(floorxxx*(floorx)*(floory+1.0), flooryyy);\n    \n    float bright = (flooryyy)*0.1*rand;\n    \n    float color = noise2(floory+1., floorx);\n    \n    vec3 col = vec3(\n    noise2(floory+1., floorx), \n    noise2(floory+15., floorx),\n    noise2(floory+40., floorx)\n    ) * 2.0 * bright;\n    \n    \n    //col = vec3((flooryyy*floorxxx)*0.1*rand); // mask generator\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl3BDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 33, 33, 186], [188, 188, 245, 245, 1375]], "test": "valid"}
{"id": "wl3BRS", "name": "Interesting Shape Discovery", "author": "oneshade", "description": "I accidentally discovered this interesting shape by averaging distances.", "tags": ["3d", "raymarching", "distancefield", "sdf", "shape", "discovery"], "likes": 18, "viewed": 153, "published": "Public", "date": "1612938132", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Cube(in vec3 p) {\n    vec3 q = abs(p) - 0.75;\n    return max(q.x, max(q.y, q.z));\n}\n\nfloat mapScene(in vec3 p) {\n    float c = cos(iTime), s = sin(iTime);\n    p.xz *= mat2(c, -s, s, c);\n    p.yz *= mat2(c, -s, s, c);\n\n    return (Cube(p + vec3(-0.5,  0.0,  0.0)) +\n            Cube(p + vec3( 0.5,  0.0,  0.0)) +\n            Cube(p + vec3( 0.0, -0.5,  0.0)) +\n            Cube(p + vec3( 0.0,  0.5,  0.0)) +\n            Cube(p + vec3( 0.0,  0.0, -0.5)) +\n            Cube(p + vec3( 0.0,  0.0,  0.5))) / 6.0 + 0.08;\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy) - mapScene(p - e.xyy),\n                          mapScene(p + e.yxy) - mapScene(p - e.yxy),\n                          mapScene(p + e.yyx) - mapScene(p - e.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float t = 0.0;\n    for (int i=0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        float d = mapScene(p / 2.0) * 2.0;\n        if (d < 0.001) {\n            vec3 n = getNormal(p / 2.0);\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n            fragColor.rgb += n * max(0.2, dot(n, l));\n            break;\n        }\n\n        if (t > 100.0) {\n            break;\n        }\n\n        t += d;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl3BRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 89], [91, 91, 118, 118, 520], [522, 522, 549, 549, 796], [798, 798, 853, 853, 1440]], "test": "valid"}
{"id": "Wl3BW8", "name": "Fractal 14_gaz", "author": "gaz", "description": "3d", "tags": ["fractal"], "likes": 15, "viewed": 213, "published": "Public", "date": "1612569681", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)cos(h*6.3+vec3(0,23,21))*.5+.5\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 r=iResolution,p;\n    float i,g,e,l,s;\n    for(i=0.;\n        ++i<99.;\n        e<.002?O.xyz+=mix(r/r,H(g),.5)*.8/i:p\n        )\n    {\n    p=g*vec3((C-.5*r.xy)/r.y,1);\n    p=R(p,R(normalize(vec3(2,5,3)),vec3(.577),iTime*.3),.4);\n    p.z+=iTime;\n    p=mod(p-2.,4.)-2.;\n    for(int k=0;k++<3;)\n        p=abs(p),\n        p=p.x<p.y?p.zxy:p.zyx;\n    s=2.;\n    for(int j=0;j++<5;)\n        s*=l=2./clamp(dot(p,p),.1,1.),\n        p=abs(p)*l-vec3(1,1,8);\n    g+=e=length(p.xz)/s;}\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3BW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 102, 138, 138, 632]], "test": "valid"}
{"id": "Wl3BWM", "name": "Minecraft rendering", "author": "kosmaks", "description": "Petproject. Attempt to implement rendering of terrain minecraft style", "tags": ["raymarching", "minecraft"], "likes": 8, "viewed": 142, "published": "Public", "date": "1612903085", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MIN_STEP (0.001)\n#define MAX_STEP (5.)\n#define MAX_COUNT (200)\n\n#define MAX_HEIGHT (1.)\n#define QF (30.)\n#define QC (1. / QF)\n#define HQC (QC * 0.5)\n#define QUANTIZE(x) (floor((x) * QF) / QF)\n\n#define C_SKY (vec3(0.69, 0.78, 0.81))\n#define C_GRASS (vec3(0.8, 0.9, 0.4))\n#define C_DIRT (vec3(0.48, 0.32, 0.2))\n\nfloat noise(in vec2 uv) {\n    //return texture(iChannel0, uv * 0.9).x;\n    return (cos(uv.x * 10.) + sin(uv.y)) * 0.5 + 0.5;\n    return fract(sin(uv.x * 1233.52 + uv.y * 99.23423) * 324.234);\n}\n\nfloat blocksOld(in vec2 uv) {\n    return (cos(uv.x * 2.) + sin(uv.y)) * 0.5 + 0.5;\n    vec2 uvs = floor(uv);\n    vec2 d = fract(uv);\n    vec2 s = vec2(1., 0.);\n    float tl = noise(uvs);\n    float tr = noise(uvs + s.xy);\n    float bl = noise(uvs + s.yx);\n    float br = noise(uvs + s.xx);\n    float top = mix(tl, tr, d.x);\n    float bottom = mix(bl, br, d.x);\n    float mx = mix(top, bottom, d.y);\n    return max(0., mx);\n}\n\n//#define DEBUG_TERR\nfloat blocks(in vec2 uv) {\n    vec2 bump1Pos = vec2(-0.5, 0.4);\n    float bump1Size = 0.8;\n    \n    vec2 bump2Pos = vec2(0.2, 0.45);\n    float bump2Size = 1.4;\n    \n    vec2 bump3Pos = vec2(0.5, -0.5);\n    float bump3Size = 0.7;\n    \n    float height = 0.;\n    height = bump1Size * max(0., 1. - distance(uv, bump1Pos));\n    height = max(height, bump2Size * max(0., 1. - distance(uv, bump2Pos)));\n    height *= cos(uv.y * 5. - 1.8 + uv.x * 2.) * 0.2 + 0.2 ;\n    \n    height += \n        pow(bump3Size * max(0., 1. - distance(uv, bump3Pos)), 2.)\n        + pow(min(1., distance(uv, bump3Pos)), 4.) * 0.1 - 0.1;\n        \n    height -= HQC;\n    \n    return height;\n}\n\nfloat sdBox(in vec3 p, vec3 size) {\n    return length(max(abs(p) - size, 0.)); \n}\n\nfloat sdSphere(in vec2 p) {\n    return length(p) - HQC;\n}\n\nvec3 boxLocalTerr(in vec2 p) {\n    float h = QUANTIZE(blocks(p));\n    vec3 res = p.xyy + HQC;\n    res.y = h - HQC;\n    return res;\n}\n\nfloat getSurfaceDist(vec3 p) {\n#ifdef DEBUG_TERR\n    return p.y;\n#endif\n\n    vec2 coord = p.xz;\n    vec2 qcoord = QUANTIZE(coord);\n    vec2 center = qcoord + HQC;\n    \n    float h = QUANTIZE(blocks(qcoord));\n    float dist = (p.y - h) * 0.5;\n    \n    vec3 size = vec3(HQC);\n    \n    vec2 dir = sign(coord - center) * QC;\n    vec3 next = boxLocalTerr(qcoord + vec2(0., dir.y));\n    dist = min(dist, sdBox(p - next, size));\n    next = boxLocalTerr(qcoord + vec2(dir.x, 0.));\n    dist = min(dist, sdBox(p - next, size));\n    next = boxLocalTerr(qcoord + dir);\n    dist = min(dist, sdBox(p - next, size));\n    \n    \n    return dist;\n}\n\nvec2 getTree(vec3 pOrig) {\n    vec3 p = pOrig - vec3(0., HQC * 10., 0.);\n    \n    float dist = MAX_STEP;\n    \n    vec3 size = vec3(HQC * 2., HQC * 10., HQC * 2.);\n    \n    dist = sdBox(p, size);\n    \n    float leafs = sdBox(p - vec3(0., 0., 0. ), vec3(HQC) * vec3(6., 2., 6.));\n    leafs = min(leafs, sdBox(p - vec3(0., QC * 2., 0. ), vec3(HQC) * vec3(8., 2., 8.)));\n    leafs = min(leafs, sdBox(p - vec3(0., QC * 4., 0. ), vec3(HQC) * vec3(6., 2., 6.)));\n    leafs = min(leafs, sdBox(p - vec3(0., QC * 6., 0. ), vec3(HQC) * vec3(4., 2., 4.)));\n\n    if (leafs < dist) {\n        return vec2(leafs, 5.);\n    }\n\n    return vec2(dist, 4.);\n}\n\nvec2 getDist(vec3 p) {\n    float surface = getSurfaceDist(p);\n    float water = p.y - abs((\n        sin(p.z * 20. + iTime * 4.) * 0.55 +\n        cos(p.z * 123.3 + p.x * 10.442 + iTime * 10.) * 0.10 +\n        cos(p.x * 10.) * 0.35\n    ) * 0.003) + 0.003;\n    \n    if (water < -0.001) { water = MAX_STEP; }\n\n    \n    float box = sdBox(p - vec3(0., 0.4, 0.), vec3(2.));\n    if (box > surface) {\n        return vec2(box, 2.);\n    }\n    \n    if (water < surface) {\n        return vec2(water, 3.);\n    }\n    \n    vec2 tree = getTree(p + vec3(20., 0., 10.) * QC);\n    if (tree.x < surface) {\n        return tree;\n    }\n    \n    return vec2(surface, 1.);\n}\n\nvec3 getNormal(vec3 p) {\n    float dist = getDist(p).x;\n    vec2 e = vec2(0.001, 0.);\n    vec3 n = dist - vec3(\n        getDist(p - e.xyy).x,\n        getDist(p - e.yxy).x,\n        getDist(p - e.yyx).x);\n    return normalize(n);\n}\n\nvec2 rayCast(vec3 ro, vec3 rd) {\n    float total = 0.;\n    \n    for (int i = 0; i < MAX_COUNT; ++i) {\n        vec2 hit = getDist(ro + rd * total);\n        float d = hit.x;\n        total += d;\n        if ((d) < MIN_STEP) return vec2(total, hit.y);\n        if (total > MAX_STEP) return vec2(total, -1.);\n    }\n    \n    return vec2(MAX_STEP + 1., -1.);\n}\n\nvec3 castToColor(vec3 ro, vec3 rd, out vec2 hit, out vec3 touch, out vec3 n) {\n    hit = rayCast(ro, rd);\n    float d = hit.x;\n    vec3 sunPos = vec3(-5., 5., -5.);\n    vec3 sunPower = vec3(1.) * 100.;\n    vec3 col;\n    \n    if (d < MAX_STEP) {\n        col = vec3(0.8, 0.9, 0.4);\n        touch = ro + rd * d;\n        n = getNormal(touch);\n        \n        if (int(hit.y) == 4) {\n            col = C_DIRT;\n        } else if (int(hit.y) == 5) {\n            col = C_GRASS;\n        } else if (int(hit.y) == 3) {\n            col = vec3(0.1, 0.3, 0.5);\n        } else {\n            col = C_DIRT;\n            \n            float qy = QUANTIZE(touch.y - QC * 0.1);\n            if (touch.y - qy > QC * 0.9) {\n                col = C_GRASS;\n            }\n        }\n        \n        vec3 toSun = sunPos - touch;\n        float distToSun = length(toSun);\n        vec3 toSunNorm = normalize(toSun);\n        float toSunDist = 1. / (distToSun*distToSun);        \n        float shadow = rayCast(touch + toSunNorm * 0.01, toSunNorm).y > 0. ? 0.5 : 1.;\n        \n        col *= sunPower * toSunDist * dot(toSunNorm, n);\n        col = max(vec3(0.2), col);\n        col *= shadow;\n#ifdef DEBUG_TERR\n        col = vec3(QUANTIZE(blocks(QUANTIZE(touch.xz))));\n#endif\n        return col;\n    }\n    \n    return vec3(0.7, 0.8, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 vpShift = vec2(iResolution.x/iResolution.y, 1.);\n    vec2 vp = fragCoord/iResolution.y*2. - vpShift;\n    \n    float time = iTime * 0.3;\n    vec3 origin = vec3(sin(time) * 2., 0.5, -2. * cos(time));\n    vec3 target = vec3(0., 0., 0.);\n    vec3 up = vec3(0., 1., 0.);\n     \n    vec3 camPos = origin;\n    vec3 camTarget = target;\n    vec3 camForward = normalize(camTarget - camPos);\n    vec3 camRight = normalize(cross(up, camForward));\n    vec3 camUp = cross(camForward, camRight);\n    \n    vec3 ro = camPos;\n    vec3 rd = normalize(3.3 * camForward + camRight * vp.x + camUp * vp.y);\n\n    vec2 hit;\n    vec3 normal;\n    vec3 touch;\n    vec3 col = castToColor(ro, rd, hit, touch, normal);\n    \n    if (int(hit.y) == 3) {\n        vec2 h;\n        vec3 t, n;\n        vec3 refl = reflect(rd, normal);\n        vec3 rro = touch + refl * 0.01;\n        vec3 reflCol = castToColor(rro, refl, h, t, n);\n        if (hit.x < MAX_STEP) {\n            col += reflCol * 0.3;\n            col = smoothstep(0., 1., col);\n        }\n        \n        vec3 refr = refract(rd, normal, 0.6);\n        vec3 refrRo = touch + rd * 0.01;\n        vec3 refrCol = castToColor(refrRo, refr, h, t, n);\n        if (hit.x < MAX_STEP) {\n            col += refrCol * 0.2;\n            col = smoothstep(0., 1.2, col);\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3BWM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[318, 318, 343, 388, 511], [513, 513, 542, 542, 936], [938, 959, 985, 985, 1619], [1621, 1621, 1656, 1656, 1702], [1704, 1704, 1731, 1731, 1761], [1763, 1763, 1793, 1793, 1895], [1897, 1897, 1927, 1927, 2527], [2529, 2529, 2555, 2555, 3166], [3168, 3168, 3190, 3190, 3816], [3818, 3818, 3842, 3842, 4047], [4049, 4049, 4081, 4081, 4400], [4402, 4402, 4480, 4480, 5706], [5708, 5708, 5765, 5765, 7123]], "test": "valid"}
{"id": "Wl3Bz2", "name": "rain practice1", "author": "cghow", "description": "rain practice1", "tags": ["rainpractice1"], "likes": 1, "viewed": 88, "published": "Public", "date": "1613039862", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//original shader - https://www.shadertoy.com/view/MssBWj\n// just for practice\n\n\n\nvoid mainImage( out vec4 fragcolor, vec2 fragCoord )\n{\n \nvec2 uv = fragCoord/iResolution.xy;\n\nuv*=500.;\n\n\nfloat a = (uv.y*.01+uv.x*.4);\nfloat b = fract(uv.x*.61);\nfloat c = 1.-fract((a*b)+iTime)*7.\n\n\n  ;\n    fragcolor = vec4(c);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3Bz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 82, 136, 136, 313]], "test": "valid"}
{"id": "Wl3cDH", "name": "2d-robinson_filled.frag", "author": "jorge2017a1", "description": "2d-robinson_filled.frag", "tags": ["2drobinsonfilledfrag"], "likes": 0, "viewed": 27, "published": "Public", "date": "1612187563", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Robinson R1 tiling\n//https://github.com/isohedral/frag/blob/master/Examples/robinson_filled.frag\n\nfloat getSquares( vec2 p, float th, float fw )\n{\n\tvec2 m = mod( p, 2.0 );\n\tm = min( m, 2.0 - m );\n\tfloat s = min(m.x,m.y);\n\n\tfloat d = abs( 0.5 - s );\n\n\tif( s > 0.5 ) {\n\t\treturn 0.8 * smoothstep( th - fw, th + fw, d );\n\t} else {\n\t\treturn smoothstep( th - fw, th + fw, d );\n\t}\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n\t vec4 col; \n    vec2 wpos=fragCoord*0.15*sin(iTime*0.25);\n    \n    float c = 1.0;\n\tfloat th = 0.125;\n\tfloat fw = 0.001;\n\tvec2 p = wpos;\n\n\tfor( int idx = 0; idx < 20; ++idx ) {\n\t\tc *= getSquares( p, th, fw );\n\n\t\tp *= 0.5;\n\t\tth *= 0.5;\n\t\tfw *= 0.5;\n\t}\n\n\tcol = vec4( c, c, c, 1.0 );\n    fragColor = col;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3cDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 101, 149, 149, 378], [380, 380, 437, 437, 742]], "test": "valid"}
{"id": "wl3fDM", "name": "Fractal 18_gaz", "author": "gaz", "description": "3d", "tags": ["fractal"], "likes": 19, "viewed": 175, "published": "Public", "date": "1612839236", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 r=iResolution,p;  \n    for(float i=0.,g=0.,e,l,s;\n        ++i<99.;\n        e<.003?O.xyz+=mix(\n                r/r,\n                cos(vec3(8,3,12)+g*3.)*.5+.5,\n                .6\n            )*.9/i:p\n    )\n    {\n        p=vec3(g*(C-.5*r.xy)/r.y,g-2.);\n        p=R(p,normalize(vec3(1,2,3)),iTime*.2);\n        p=.7-abs(abs(p-1.+sin(p*.1))-1.);\n        for(int k=0;k++<2;)\n            p=abs(p),\n            p=p.x<p.y?p.zxy:p.zyx;\n        s=4.;\n        for(int j=0;j++<4;)\n            s*=l=2./min(dot(p,p),2.),\n            p=abs(p)*l-vec3(2,1,3);\n        g+=e=length(p.yz)/s;\n    }\n    O=pow(O,vec4(.8,.6,1.3,1));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl3fDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 95, 95, 732]], "test": "valid"}
{"id": "wl3fDN", "name": "Radioactive Spacerock", "author": "oneshade", "description": "Lots of things going on all at once. Really needs some sound.", "tags": ["space", "glow", "stars", "motion", "rock"], "likes": 7, "viewed": 132, "published": "Public", "date": "1612743110", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// New hash based on hash13() from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\n// 4 in, 1 out\nfloat Hash41(in vec4 p) {\n\tp = fract(p * 0.1031);\n    p += dot(p, p.zwyx + 31.32);\n    return fract((p.x + p.y) * p.z - p.x * p.w);\n}\n\n// Hashes from \"Hash without Sine\"\nfloat Hash21(in vec2 p) {\n\tvec3 p3 = fract(p.xyx * 0.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 Hash22(in vec2 p) {\n\tvec3 p3 = fract(p.xyx * vec3(0.1031, 0.103, 0.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nfloat SmoothNoise4D(in vec4 p) {\n    vec4 cell = floor(p);\n    vec4 local = fract(p);\n    local *= local * (3.0 - 2.0 * local);\n\n    float ldbq = Hash41(cell);\n    float rdbq = Hash41(cell + vec4(1.0, 0.0, 0.0, 0.0));\n    float ldfq = Hash41(cell + vec4(0.0, 0.0, 1.0, 0.0));\n    float rdfq = Hash41(cell + vec4(1.0, 0.0, 1.0, 0.0));\n    float lubq = Hash41(cell + vec4(0.0, 1.0, 0.0, 0.0));\n    float rubq = Hash41(cell + vec4(1.0, 1.0, 0.0, 0.0));\n    float lufq = Hash41(cell + vec4(0.0, 1.0, 1.0, 0.0));\n    float rufq = Hash41(cell + vec4(1.0, 1.0, 1.0, 0.0));\n    float ldbw = Hash41(cell + vec4(0.0, 0.0, 0.0, 1.0));\n    float rdbw = Hash41(cell + vec4(1.0, 0.0, 0.0, 1.0));\n    float ldfw = Hash41(cell + vec4(0.0, 0.0, 1.0, 1.0));\n    float rdfw = Hash41(cell + vec4(1.0, 0.0, 1.0, 1.0));\n    float lubw = Hash41(cell + vec4(0.0, 1.0, 0.0, 1.0));\n    float rubw = Hash41(cell + vec4(1.0, 1.0, 0.0, 1.0));\n    float lufw = Hash41(cell + vec4(0.0, 1.0, 1.0, 1.0));\n    float rufw = Hash41(cell + 1.0);\n\n    return mix(mix(mix(mix(ldbq, rdbq, local.x),\n                       mix(lubq, rubq, local.x),\n                       local.y),\n\n                   mix(mix(ldfq, rdfq, local.x),\n                       mix(lufq, rufq, local.x),\n                       local.y),\n\n                   local.z),\n\n               mix(mix(mix(ldbw, rdbw, local.x),\n                       mix(lubw, rubw, local.x),\n                       local.y),\n\n                   mix(mix(ldfw, rdfw, local.x),\n                       mix(lufw, rufw, local.x),\n                       local.y),\n\n                   local.z),\n\n               local.w);\n}\n\nfloat FractalNoise4D(in vec4 p, in float scale, in float octaves) {\n    p *= scale;\n    float nscale = 1.0;\n    float tscale = 0.0;\n    float value = 0.0;\n\n    for (float octave=0.0; octave < octaves; octave++) {\n        value += SmoothNoise4D(p) * nscale;\n        tscale += nscale;\n        nscale *= 0.5;\n        p *= 2.0;\n    }\n\n    return value / tscale;\n}\n\nfloat mapScene(in vec3 p) {\n    return length(p) - 1.5 - FractalNoise4D(vec4(p, iTime), 1.0, 5.0) * 0.4;\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy) - mapScene(p - e.xyy),\n                          mapScene(p + e.yxy) - mapScene(p - e.yxy),\n                          mapScene(p + e.yyx) - mapScene(p - e.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenCenter = 0.5 * iResolution.xy;\n    float unit = 2.0 / iResolution.y;\n\n    vec2  mouse = (iMouse.xy - screenCenter) / iResolution.y * 3.14;\n    vec2 uv = (fragCoord - screenCenter) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    float t = 0.0;\n    bool hit = false;\n    float iter = 0.0;\n\n    vec3 p;\n    for (float iters=0.0; iters < 30.0; iters++) {\n        p = ro + rd * t;\n        float d = mapScene(p);\n        if (d < 0.001) {\n            hit = true;\n            break;\n        }\n\n        if (t > 15.0) {\n            break;\n        }\n\n        t += d;\n        iter++;\n    }\n\n    if (hit) {\n        vec3 n = getNormal(p);\n        vec3 l = vec3(-0.58, 0.58, 0.58);\n        fragColor.rgb += max(0.0, dot(n, l));\n    }\n\n    else {\n        vec2 skyUv = rd.xy - iTime * sign(rd.xy);\n        if (all(greaterThan(vec2(abs(rd.y)), abs(rd.xz)))) skyUv = rd.xz - vec2(0.0, iTime);\n        if (all(greaterThan(vec2(abs(rd.x)), abs(rd.yz)))) skyUv = rd.yz - vec2(0.0, iTime);\n\n        skyUv *= 10.0;\n        vec2 cell = floor(skyUv);\n        vec2 local = fract(skyUv);\n\n        vec2 position = Hash22(cell);\n        float size = 0.05 * Hash21(cell);\n        float brightness = Hash21(cell + 347.583);\n\n        fragColor.rgb += smoothstep(unit, 0.0, length(local - position) - size) * brightness;\n        fragColor.rgb += (0.25 + 0.25 * sin(atan(uv.y, uv.x) * 6.0)) / (1.0 + length(uv) * 4.0);\n    }\n\n    fragColor.gb += iter / 30.0;\n    fragColor.rgb *= mod(dot(floor(fragCoord), vec2(1.0)), 2.0); // Checkerboard dither\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl3fDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 126, 151, 151, 259], [261, 296, 321, 321, 432], [434, 434, 458, 458, 593], [595, 595, 627, 627, 2219], [2221, 2221, 2288, 2288, 2580], [2582, 2582, 2609, 2609, 2688], [2690, 2690, 2717, 2717, 2964], [2966, 2966, 3021, 3021, 4885]], "test": "valid"}
{"id": "wl3fR7", "name": "Slicing a 4D apollian", "author": "mrange", "description": "License CC0: Slicing a 4D apollian\nWas experimenting with slicing 3D fractals in 2D.\n", "tags": ["3d", "4d", "apollian"], "likes": 16, "viewed": 281, "published": "Public API", "date": "1612423823", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License CC0: Slicing a 4D apollian\n// Was experimenting with slicing 3D fractals in 2D.\n// Naturally I wondered how it looks if we +1 dimension\n// Based upon: https://www.shadertoy.com/view/4ds3zn\n#define PI  3.141592654\n\nconst int   max_iter      = 130;\nconst vec3  bone          = vec3(0.89, 0.855, 0.788);\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat box(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat apollian(vec4 p, float s) {\n  float scale = 1.0;\n\n  for(int i=0; i<7; ++i) {\n    p        = -1.0 + 2.0*fract(0.5*p+0.5);\n\n    float r2 = dot(p,p);\n    \n    float k  = s/r2;\n    p       *= k;\n    scale   *= k;\n  }\n  \n  return 0.45*abs(p.y)/scale;\n}\n\nfloat df(vec3 p) { \n  vec4 p4 = vec4(p, 0.125);\n  float tm = 0.1*iTime;\n  rot(p4.xw, tm*sqrt(0.5));\n  rot(p4.yw, tm*sqrt(0.4));\n  rot(p4.zw, tm*sqrt(0.3));\n  float d1 = apollian(p4, 1.5);\n  float db = box(p - vec3(0.0, 0.5, 0.0), vec3(0.75,1.0, 0.75)) - 0.5;\n  float dp = p.y;\n  return max(d1, db); \n} \n\n\nfloat intersect(vec3 ro, vec3 rd, out int iter) {\n  float res;\n  float t = 0.2;\n  iter = max_iter;\n    \n  for(int i = 0; i < max_iter; ++i) {\n    vec3 p = ro + rd * t;\n    res = df(p);\n    if(res < 0.0003 * t || res > 20.) {\n      iter = i;\n      break;\n    }\n    t += res;\n  }\n    \n  if(res > 20.) t = -1.;\n  return t;\n}\n\nfloat ambientOcclusion(vec3 p, vec3 n) {\n  float stepSize = 0.012;\n  float t = stepSize;\n\n  float oc = 0.0;\n\n  for(int i = 0; i < 12; i++) {\n    float d = df(p + n * t);\n    oc += t - d;\n    t += stepSize;\n  }\n\n  return clamp(oc, 0.0, 1.0);\n}\n\nvec3 normal(in vec3 pos) {\n  vec3  eps = vec3(.001,0.0,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nvec3 lighting(vec3 p, vec3 rd, int iter) {\n  vec3 n = normal(p);\n  float fake = float(iter)/float(max_iter);\n  float fakeAmb = exp(-fake*fake*9.0);\n  float amb = ambientOcclusion(p, n);\n\n  vec3 col = vec3(mix(1.0, 0.125, pow(amb, 3.0)))*vec3(fakeAmb)*bone;\n  return col;\n}\n\nvec3 post(vec3 col, vec2 q) {\n  col=pow(clamp(col,0.0,1.0),vec3(0.65)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.5);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )  { \n  vec2 q=fragCoord.xy/iResolution.xy;\n  vec2 uv = -1.0 + 2.0*q; \n  uv.y += 0.225;\n  uv.x*=iResolution.x/iResolution.y; \n    \n  vec3 la = vec3(0.0, 0.0, 0.0); \n  vec3 ro = vec3(-4.0, 1., -0.0);\n  rot(ro.xz, 2.0*PI*iTime/120.0);\n  vec3 cf = normalize(la-ro); \n  vec3 cs = normalize(cross(cf,vec3(0.0,1.0,0.0))); \n  vec3 cu = normalize(cross(cs,cf)); \n  vec3 rd = normalize(uv.x*cs + uv.y*cu + 3.0*cf);  // transform from view to world\n\n  vec3 bg = mix(bone*0.5, bone, smoothstep(-1.0, 1.0, uv.y));\n  vec3 col = bg;\n\n  vec3 p=ro; \n\n  int iter = 0;\n  \n  float t = intersect(ro, rd, iter);\n    \n  if(t > -0.5) {\n    p = ro + t * rd;\n    col = lighting(p, rd, iter); \n    col = mix(col, bg, 1.0-exp(-0.001*t*t)); \n  } \n    \n\n  col=post(col, q);\n  fragColor=vec4(col.x,col.y,col.z,1.0); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl3fR7.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[0, 313, 346, 346, 431], [433, 433, 460, 460, 547], [549, 549, 582, 582, 802], [804, 804, 822, 822, 1105], [1109, 1109, 1158, 1158, 1430], [1432, 1432, 1472, 1472, 1674], [1676, 1676, 1702, 1702, 1910], [1912, 1912, 1954, 1954, 2184], [2186, 2186, 2215, 2215, 2464], [2466, 2466, 2524, 2524, 3308]], "test": "valid"}
{"id": "wl3fRf", "name": "Y-Function Graph", "author": "Zi7ar21", "description": "All the other shaders that are supposed to plot functions kinda suck because they have variations in line thickness. However, this shader aims to solve that problem with supersampling.", "tags": ["utility", "function", "plot", "tool", "visualize"], "likes": 2, "viewed": 288, "published": "Public API", "date": "1613162623", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ##### Y-Function Graph #####\n// Made by Zi7ar21 on February 12th, 2021\n// Last Updated: February 12th, 2021 at 13:30 Mountain Time\n\n// If you found this anywhere except Shadertoy, the original and possibly a newer version can be found at:\n// https://www.shadertoy.com/view/wl3fRf\n\n/*All of the other shaders that are supposed to plot functions (that I have used at least)\nseem to have variations in line thickness due to the fact that they simply take a function's\ndifference from the screen's y coordinate and draw it if it is a certain distance from the\ny coordinate at that point, however this shader solves that problem by drawing an aliased line\nwith uniform-ish thickness and then superampling it.*/\n\n// Super-Sample Levels\n#define samples 4\n\n// Y-Scale\n#define yscale 2.5\n\n// X-Scale\n#define xscale 4.0/iResolution.x\n\n// Pi (used for the example function)\n#define pi 3.1415926535897932384626433832795028841971693993751058209749445923078164\n\n// Example Function: y = (sin(x*pi*2.0+t)+cos(x*pi))/2.0\nfloat function(float x){\n    return (sin(x*pi*2.0+iTime)+cos(x*pi))/2.0;\n}\n\n// Plot\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Initialize the Color\n    vec3 color  = vec3(0.0);\n    // Initialize the Coordinates\n    vec2 coord = fragCoord;\n    // The Super-Sampling Loop\n    for(int y = -samples; y < samples; y++){for(int x = -samples; x < samples; x++){\n    // Set the Super-Sampled Coordinate\n    coord = (fragCoord+(vec2(x, y)/float(samples)));\n    // Find The Points for a Smooth yet Aliased Line\n    bool pointa =     round(function((coord.x-1.0)*xscale)*iResolution.y) >= yscale*(coord.y-0.5*iResolution.y);\n    bool pointb =     round(function((coord.x    )*xscale)*iResolution.y) <= yscale*(coord.y-0.5*iResolution.y);\n    bool pointc =     round(function((coord.x    )*xscale)*iResolution.y) >= yscale*(coord.y-0.5*iResolution.y);\n    bool pointd =     round(function((coord.x-1.0)*xscale)*iResolution.y) <= yscale*(coord.y-0.5*iResolution.y);\n    // Some Points take less than 2x to move up a pixel so we sample a point where the line is at every point\n    bool pointe = abs(round(function( coord.x*xscale)*iResolution.y)-yscale*(coord.y-0.5*iResolution.y)) <= 1.0;\n    // Check if the pixel is part of the line\n    if((pointa && pointb) || (pointc && pointd) || pointe){\n        color += vec3(1.0);\n    }\n    }}\n    // Output the Super-Sampled Line\n    fragColor = vec4(color/float(samples*samples*4), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl3fRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[951, 1008, 1032, 1032, 1082], [1084, 1092, 1146, 1174, 2447]], "test": "valid"}
{"id": "Wl3fW4", "name": "Omg it's infinite cubes", "author": "VinesOfCode", "description": "and they're rotating.\n\nLearning shader programming and playing around with raymarching.", "tags": ["raymarching", "reflection"], "likes": 5, "viewed": 107, "published": "Public", "date": "1612704722", "time_retrieved": "2021-10-01T00:00:00", "image_code": " /*\n    Raymarching with rounded cubes to illustrate\n    - infinite number of objects because it's not necessary to model the \n      scene with all objects per loops but use distance to nearest object instead. \n    - roundness of cubes edges comes with almost zero cost.\n    - reflection\n    \n    For nicer visuals:\n    - cube rotation!\n    - shift of the object coordinates (with y-shift dependent on x)\n    - object density on y axis decreased by factor\n    - 3d checker pattern (needs to take into account the shift)\n    - color cycling\n    - camera angle and camera zoom cycling\n    - simple and unrealistic diffuse lighting with squaring for more contrast\n    Due to shifting and rotation, its not straight forward to get the nearest object,\n    instead of caculating correctly, the effect of potential error is mitigated\n    by a factor on the ray marching step distance, unless close enough\n*/\n\n#define maxSteps 50.   // max raymarching steps\n#define maxRayLen 50.  // max raymarching ray lenght \n#define reflections 2  // max number of reflections\n#define eps 0.001      // 'very' small number, 'almost' zero\n#define PI 3.1416128\n#define yStep 1.4      // factor for y-axis steps\n#define yLevel0 -2.    // max y level with objects (pre shift), nothing above, but camera above\n#define waves 0.4      // factor on sinus for y-shift\n#define v3null vec3(0., 0., 0.)\n#define cubeSize      0.12 * vec3(1., 1., 1.) \n#define cubeRoundness 0.07\n#define lightPos vec3(-3.,5.,-1.) // diffuse light\n\n/* return 'integer' index for y with 0 at yLevel0, \n   called roundY because round gives the index for x / z */\nfloat roundY(float y)\n{\n    return round((y - yLevel0) / yStep);\n}\n\n/* y value of closest y level (with integer index) */\nfloat roundedY(float y)\n{\n    return yLevel0 + (roundY(y) * yStep );\n}\n\nvec3 rotX(vec3 coord, vec3 center, float phi)\n{\n    return vec3(\n        coord.x,\n        center.y +(coord.y - center.y)*cos(phi)\n                 -(coord.z - center.z)*sin(phi),\n        \n        center.z +(coord.y - center.y)*sin(phi)\n                 +(coord.z - center.z)*cos(phi));\n}\n\nvec3 rotZ(vec3 coord, vec3 center, float phi)\n{   // = rotX(coord.zxy , center, phi).yzx;\n    return vec3(\n        center.x +(coord.x - center.x)*cos(phi)\n                 -(coord.y - center.y)*sin(phi),\n        center.y +(coord.x - center.x)*sin(phi)\n                 +(coord.y - center.y)*cos(phi),\n        coord.z);\n}\n\nvec3 rotY(vec3 coord, vec3 center, float phi)\n{\n    return vec3(\n        center.x +(coord.x - center.x)*cos(phi)\n                 -(coord.z - center.z)*sin(phi),\n        coord.y,\n        center.z +(coord.x - center.x)*sin(phi)\n                 +(coord.z - center.z)*cos(phi));\n}\n\n/* time and location dependent shift */\nvec3 getShift (vec3 p) \n{\n    float xIndex = round(p.x);\n    return vec3(\n            sin(iTime * .4) * 3., \n            sin(xIndex + iTime) * waves, // y-shift depends on xIndex\n            -iTime * 2.);\n}\n\n/* get original point from shifted (inverse of getShift) */\nvec3 getPFromShifted (vec3 p) \n{\n    float xShift   = sin(iTime * .4) * 3.;\n    float oriX = p.x - xShift;\n    float xIndex = round(oriX);\n    return vec3(\n            oriX, \n            p.y - sin(xIndex + iTime) * waves,\n            p.z + iTime * 2.);\n}\n\n/* distance from box at <0,0,0> with border size b per axis */\nfloat distBox(vec3 p, vec3 b )\n{\n    return length(max(abs(p) - b, 0.0));\n}\n\n/* distance from rotating rounded cube, center 0,0,0 \n    obj center is only for pos/index dependent rotation */\nfloat distObject(vec3 p, vec3 objCenter) {\n    vec3 pRot = rotX(\n            rotY(p, v3null, iTime + 0.2 * objCenter.z), \n            v3null, iTime * .5);\n    return distBox (pRot, cubeSize) - cubeRoundness; \n}\n\n/* distance from close object in relevant layer\n   it is based on rounding position to index, close is not closest, but not too bad */\nfloat distObjLayers(vec3 p) {\n    vec3 o = getPFromShifted(p); // calculating distance to shifted object, o is the corresponding unshifted position\n    vec3 c = vec3(round(o.x), roundedY(o.y), round(o.z)); // original unshifted center (xyz-index)\n    if (c.y  > yLevel0 + eps) c.y = yLevel0; // nothing above us\n    return distObject(o - c, c);\n}\n\n\nfloat distBigObject(vec3 p) {\n    vec3 pos = vec3(2.,1.5,1.5);\n    float d1 = distBox(rotY(rotX(p, pos, 0.3+sin(iTime*0.5)*0.4), pos, iTime) - pos, vec3(1.,1.,1.)*1.1) ;\n    return d1 -0.02;\n}\n\nvec2 normCoord(vec2 coord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv  = coord/iResolution.xy;\n    //Shift to center\n    uv.xy -= vec2(.5, .5);\n\t//Rescale axis\n    uv.x *= iResolution.x/iResolution.y;\n    return uv * 2.; // y: [-1 : +1]\n}\n\n\n\n/* ~ distance of point to scene */\nfloat dist(vec3 p) {\n    return min(distObjLayers(p), distBigObject(p));\n}\n\n/* normal vector to scene */\nvec3 distNorm (vec3 p)\n{\n    float d = dist(p);\n    \n    vec3 n  = vec3(d - dist(p-vec3(eps, 0.,  0. )),\n                   d - dist(p-vec3(0.,  eps, 0. )),\n                   d - dist(p-vec3(0.,  0.,  eps)));\n    return normalize(n);\n}\n\nstruct Hit \n{\n    vec3 p; // point on surface\n    vec3 n; // normal vector (normalized)\n    float l; // ray length\n    int nSteps;\n};\n\n\n/* dot product of normalized light vector and scene normal vector */\nfloat diffuseLight (Hit h)\n{\n    return dot(h.n, normalize(lightPos - h.p));\n}\n\n/* raymarching, return hit position, normal and ray lenght */\nHit rayMarch(vec3 p0, vec3 normRayDir)\n{\n    vec3  p      = p0;\n    float d      = dist(p);\n    float rayLen = 0.;\n    int n = 0;\n    for (float i = 0.; i < maxSteps; i++)\n    {\n        d = dist(p);\n        d = (d > 0.1) ? d *.8 : d; // above dist 0.1, scale step down because dist can give a distance to the not closest bust quite close object\n        p += normRayDir * d;\n        rayLen += d;\n        if ( rayLen > maxRayLen || d < 0.005)\n            break;\n        n++;\n    }\n    return Hit(p, distNorm(p), rayLen, n);\n}\n\n/* return color for a hit on object */ \nvec3 getColor(Hit h) \n{    \n    float b = diffuseLight(h) * smoothstep(11., 0.5, h.l + 0.2);\n    b +=.25; // brightness\n    b *= b;  // drama\n    if (h.p.y > yLevel0 +1.+waves)\n        return vec3(1., 1., 1.) *.9*b;\n    \n    vec3 pOri = getPFromShifted(h.p); // object colors based on xyz-index, need original position \n\n    float fCont =  mod(pOri.x + pOri.z + (yLevel0 + pOri.y) / yStep, 2.);\n    float fDisc =  mod(round(pOri.x) + round(pOri.z) + roundY(pOri.y), 2.);\n    float checker = 0.; //fCont;//fDisc;\n    \n    return vec3(b * fDisc , b*(0.5+0.5*abs(sin(iTime+checker*PI *0.5))), b*(0.5+0.5*abs(cos(iTime+checker*PI*0.5))));\n}\n\n/* return normalized reflection vector of r, n is normal of reflecting surface*/\nvec3 getReflectionRay(vec3 n, vec3 r) {\n    return r - 2. * dot(r, n) * n;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2  uv   = normCoord(fragCoord);\n\n    // Camera setup\n    float angX = .7 + sin(iTime) * 0.2;  // camera rotation X - time dependent\n    float angZ = sin(iTime * 0.3) * 0.4; // camera rotation Z - time dependent\n    vec3  cam  = rotZ(rotX(vec3 (0., 1., -5.), v3null, angX), v3null, angZ);\n    float cs   = 2.5 + sin(iTime * 0.3) * 1.3; // camera zoom (time dependent)\n    vec3  rayDir     = rotZ(rotX(cs * vec3(uv.x, uv.y, 0.),v3null, angX), v3null, angZ) - cam;\n    vec3  p    = cam + rayDir * 0.5; // image plane can intersect with objects, goingonly 0.5 times ray dir helps\n    \n    // Ray marching\n    rayDir = normalize(rayDir);\n    Hit  h   = rayMarch(p, rayDir);\n    vec3 col = getColor(h);\n    \n    // Reflections\n    float b = length(col); \n    for (int i = 0; i < reflections && h.l < maxRayLen; i++)\n    {\n        vec3 rayDir = getReflectionRay(h.n, rayDir);\n        h = rayMarch(h.p+ 0.1*rayDir, rayDir);\n        col += b * (1./(1.+h.l)) *min(getColor(h), vec3(1.,1.,1.));\n        col = min(col, vec3(1., 1., 1.));\n        b*=length(col);\n    }\n    \n    fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3fW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1496, 1608, 1631, 1631, 1674], [1676, 1730, 1755, 1755, 1800], [1802, 1802, 1849, 1849, 2089], [2091, 2091, 2138, 2180, 2411], [2413, 2413, 2460, 2460, 2691], [2693, 2733, 2758, 2758, 2939], [2941, 3001, 3033, 3033, 3255], [3257, 3320, 3352, 3352, 3395], [3397, 3510, 3552, 3552, 3720], [3722, 3857, 3886, 3886, 4203], [4206, 4206, 4235, 4235, 4398], [4400, 4400, 4428, 4478, 4659], [4663, 4698, 4718, 4718, 4772], [4774, 4803, 4827, 4827, 5039], [5177, 5246, 5274, 5274, 5324], [5326, 5388, 5428, 5428, 5911], [5913, 5953, 5976, 5976, 6589], [6591, 6672, 6711, 6711, 6748], [6750, 6750, 6807, 6857, 7959]], "test": "valid"}
{"id": "wl3fWr", "name": "Moiré 3d", "author": "FabriceNeyret2", "description": "Shadows of 2 identical parallel plates with hexa-tiled holes. \nHere, the second plates is distorted (show alone on left).\n( you might try a slight perspective effect by changing the coef line 17. )", "tags": ["aliasing", "interference", "moir", "reproduction"], "likes": 7, "viewed": 181, "published": "Public API", "date": "1612514962", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://shadertoy.com/view/wt3fWr\n// adapted from https://shadertoy.com/view/ttd3D7\n\n#define D   length( mod( U += T/2. , T ) - k )               //\n#define P   clamp( 1.- ( min( D, D ) -.8*k.y )/10. ,0.,1.)   // draw an hexa tiling of disks\n\nvoid mainImage(out vec4 O, vec2 u) {\n    O-=O;\n    vec2 R = iResolution.xy,\n        U = 6.*(u-R/2.),\n        V =   U // * mat2(cos(.01 +vec4(0,11,33,0))) \n            + 30.* sin( U*mat2(1,-.7,.4,-1)/300. + iTime ),\n  \n        k = vec2(360)/8., T = vec2( 2, 3.5 )*k;\n    O += U.x>0. ? P : 1.;\n\n    U = 1.0*V; // try 1.1\n    O *= P;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl3fWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 257, 293, 293, 589]], "test": "valid"}
{"id": "Wl3fWS", "name": "Happy Chinese New Year ", "author": "Learner_CC", "description": "Learn from olympus223’s Fireworks night, and make some adjustment.\nAt last, happy Chinese new year. ", "tags": ["firework", "2dparticle"], "likes": 3, "viewed": 106, "published": "Public", "date": "1613320717", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define s(a, b, t) smoothstep(a, b, t)\n#define g -9.81\n\n// -------- 随机数 -------- //\nfloat N21(vec2 p) {\n\tp = fract(p * vec2(233.34, 851.73));\n    p += dot(p, p + 23.45);\n    return fract(p.x * p.y);\n}\n\nvec2 N22(vec2 p) {\n\tfloat n = N21(p);\n    return vec2(n, N21(p + n));\n}\n\nfloat N11(float n) {\n    return fract(sin(dot(vec2(cos(n), sin(n)) ,vec2(27.9898, 38.233))) * 88.5453);\n}\n\n// -------- 烟花相关的三个函数 -------- //\nvec2 p1(vec2 p, float h, float t) {\n    // 返回烟花绽放前的高度\n    // p 烟花初始位置\n    // h 上升的高度\n    // t 时间\n    return vec2(p.x, p.y + clamp(pow(t, 5.0), 0.0, h));\n}\nvec2 p2(vec2 p, float h, float t) {\n    // 上升中烟花尾部的位置\n    return vec2(p.x, p.y + clamp(pow(0.95 * t, 5.0), 0.0, h));\n}\nfloat endTime(float h) {\n    // 计算烟花绽放的时间\n    return pow(h, 1.0 / 5.0) * 1.1;\n}\nfloat seed = 0.0;\nfloat particle(vec2 uv, vec2 p, vec2 v, float r, float t) {\n    float x = p.x + v.x * t;\n    float y = p.y + v.y * t + g / 2.0 * t * t;\n    vec2 j = (vec2(x, y) - uv) * 20.0;\n    float sparkle = 1.0 / dot(j, j);\n    return sparkle;\n}\nfloat explosion(vec2 uv, vec2 p, float s, float n, float t) {  \n    // n 生成粒子的个数\n    // t 烟花出现的时间\n    float m = 0.0;\n    float dt = 0.5;\n    // 通过循环分出粒子\n    for(float i = 0.0; i < n; i++) {\n        seed += i;\n        vec2 rand = vec2(1.0, 1.8) * (vec2(-1.0, 1.0) + 2.0 * N22(vec2(seed, i)));\n        vec2 v = vec2(cos(seed), sin(seed)) + rand;\n        // 第一个s控制烟花粒子出现时机\n        // 第二个s控制烟花粒子消失的时机\n        m += particle(uv, p, v, s, t)\n            * s(0.0, dt, t)\n            * s(1.0, 1.0 - dt, t);\n    }\n    return m;\n}\n\nfloat fireworks(vec2 uv, vec2 p, float h, float n, float s, float t) {\n    vec2 p1 = p1(p, h, t);\n    float e = endTime(h);\n    return explosion(uv, p1, s, n, t - e * 0.9);\n}\n\nfloat distLine(vec2 p, vec2 a, vec2 b) {\n\tvec2 pa = p - a;\n    vec2 ba = b - a;\n    float t = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * t);\n}\n\nfloat line(vec2 uv, vec2 a, vec2 b, float w) {\n    return w / distLine(uv, a, b);\n}\n\nfloat shaft(vec2 uv, vec2 p, float w, float h, float t) {\n    vec2 head = p1(p, h, t) + vec2(0.0, 0.3);\n    vec2 tail = p2(p, h, t);\n    float e = 1.0 / 0.95 * endTime(h);\n    vec2 j = (head - uv) * 15.0;\n    float sparkle = 1.0 / dot(j, j);\n    return (line(uv, head, tail, w) + sparkle) * s(e, e - 0.5, t) * 0.5;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    float pct = 0.0;\n\n    vec2 st = uv - 0.5;\n    float t = iTime / 10.0;\n    float scale = 10.0;\n    \n    st *= scale;\n    \n    vec3 color = mix(vec3(0.1515, 0.2375, 0.5757), vec3(0.0546, 0.0898, 0.1953), uv.y);\n    \n    for (float i = 0.0; i < 1.0; i += 0.125) {\n        float ti = mod(t * 9.0 - i * 5.0, 4.0);\n        float scale = mix(2.0, 0.3, ti / 4.0);\n        vec2 uvs = st * scale;\n        float rand = N11(i);\n        float h = 10.0 + rand * 4.0;\n        float w = 0.02;\n        float n = 80.0;\n        float s = 0.9;\n        vec2 p = vec2(mix(-8.0, 8.0, rand), -10.0);\n\n        pct += fireworks(uvs, p, h, n, s, ti) + shaft(uvs, p, w, h, ti);\n        vec3 sparkColor = vec3(0.0);\n        rand = N11(rand);\n        sparkColor.x = rand;\n        rand = N11(rand);\n        sparkColor.y = rand;\n        rand = N11(rand);\n        sparkColor.z = rand;\n\n        color += fireworks(uvs, p, h, n, s, ti) * sparkColor + shaft(uvs, p, w, h, ti);\n    }\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3fWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[56, 90, 109, 109, 206], [208, 208, 226, 226, 279], [281, 281, 301, 301, 386], [388, 440, 475, 582, 640], [641, 641, 676, 714, 779], [780, 780, 804, 839, 877], [896, 896, 955, 955, 1129], [1130, 1130, 1191, 1255, 1747], [1749, 1749, 1819, 1819, 1923], [1925, 1925, 1965, 1965, 2096], [2098, 2098, 2144, 2144, 2181], [2183, 2183, 2240, 2240, 2499], [2501, 2501, 2556, 2556, 3591]], "test": "valid"}
{"id": "Wl3fz4", "name": "Fork Lyapunov rsiqueira 526", "author": "rsiqueira", "description": "dwitter: https://www.dwitter.net/d/21550 \n\n\nMarkus-Lyapunov diagram for AAAAABBBBBB. More info: http://www.iquilezles.org/www/articles/lyapunovfractals/lyapunovfractals.htm. It was 12 years I didn't code one of these :)", "tags": ["2d", "fractal", "logistic", "lyapunov"], "likes": 1, "viewed": 37, "published": "Public", "date": "1612397440", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// More info here:  http://www.iquilezles.org/www/articles/lyapunovfractals/lyapunovfractals.htm\n        \n\n//for(i=2e3;i--;x.fillRect(i,t*240,h/=9,4)){I=i/430,Y=t/8-1,h=X=.5\n//for(n=9;n--;\n// X*=Y*I*(1-X)*(1-I*X*(1-X)));\n//h+=Math.log2((Y*I*(1-1.5*X))**2)}\n\n        \nvec3 calc( in vec2 p )\n{\n    float x = 0.5;\n\tfloat h = 0.5;\n\tfor( int i=0; i<9; i++ )\n\t{\n    \n//x *= p.y * p.x * (1.-x) * ( 1. - p.y * p.x * (1.-x) ) ;\n//h += log(abs(p.y * p.x * (1. - 1.5*x)));\n\n//x = p.x * x *(1.0-x);\n\n\nx *= p.y* p.x *(1.0-x+ sin(iTime)/29. ) * (1.1-(p.x * x *(1.0-x)));\n\n//h += log2( abs( p.x*(1.0-2.0*x + p.y - p.y*1.5*x )) );\n\nh += log2( abs( p.y*p.x*(1.0-1.5*x )) );\n\n\n//h+=Math.log2((Y*I*(1-1.5*X))**2)\n\n\n//h += log2(abs(p.x*(1.0-2.0*x) + p.y*(1.0-2.0*x))); //+ log2(abs());\n\n//\t\tx = p.x*x*(1.0-x);\n\n\n\n// esse eh **2 ao inves de abs:\n  //  h += log2( pow(2.,( p.x*(1.0-2.0*x + p.y - p.y*1.0*x )) ));\n\n\n//    h += log2( abs( p.x*(1.0-2.0*x + p.y - p.y*1.0*x )) );\n\n\n\n\n\n//\t\tx = p.x*x*(1.0-x); h += log2(abs(p.x*(1.0-2.0*x)));\n//\tx = p.x*x*(1.0-x); h += log2(abs(p.x*(1.0-2.0*x)));\n//\t\tx = p.x*x*(1.0-x); h += log2(abs(p.x*(1.0-2.0*x)));\n\n//\t\tx = p.y*x*(1.0-x);\n//        h += log2(abs(p.y*(1.0-2.0*x)));\n\n//\t\tx = p.y*x*(1.0-x);\n//h += log2(abs(p.y*(1.0-2.0*x)));\n//\t\tx = p.y*x*(1.0-x); h += log2(abs(p.y*(1.0-2.0*x)));\n//\t\tx = p.y*x*(1.0-x); h += log2(abs(p.y*(1.0-2.0*x)));\n//\t\tx = p.y*x*(1.0-x); h += log2(abs(p.y*(1.0-2.0*x)));\n\t}\n    h /= 9.0;\n\t\n\t\n\tvec3 col = vec3(0.0);\n\n\t\t//h = abs(h);\n\t\tcol = 1.0*( vec3(1.0,0.4,0.7) + h );\n//\t\tcol *= pow(h,0.1);\n\n\n\n\treturn col;\n}\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 col = calc( vec2(0.7,2.1) + 4.0*(fragCoord)/ iResolution.x );\n    col /= 3.0;\n\n\t\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3fz4.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[232, 392, 416, 416, 1685], [1688, 1688, 1745, 1745, 1869]], "test": "valid"}
{"id": "Wl3fzM", "name": "Apollian with a twist", "author": "mrange", "description": "License CC0: Apollian with a twist\nPlaying around with apollian fractal\n", "tags": ["2d", "apollian"], "likes": 145, "viewed": 3835, "published": "Public API", "date": "1612391093", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License CC0: Apollian with a twist\n// Playing around with apollian fractal\n\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define L2(x)           dot(x, x)\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PSIN(x)         (0.5+0.5*sin(x))\n\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat apollian(vec4 p, float s) {\n  float scale = 1.0;\n\n  for(int i=0; i<7; ++i) {\n    p        = -1.0 + 2.0*fract(0.5*p+0.5);\n\n    float r2 = dot(p,p);\n    \n    float k  = s/r2;\n    p       *= k;\n    scale   *= k;\n  }\n  \n  return abs(p.y)/scale;\n}\n\nfloat weird(vec2 p) {\n  float z = 4.0;\n  p *= ROT(TIME*0.1);\n  float tm = 0.2*TIME;\n  float r = 0.5;\n  vec4 off = vec4(r*PSIN(tm*sqrt(3.0)), r*PSIN(tm*sqrt(1.5)), r*PSIN(tm*sqrt(2.0)), 0.0);\n  vec4 pp = vec4(p.x, p.y, 0.0, 0.0)+off;\n  pp.w = 0.125*(1.0-tanh(length(pp.xyz)));\n  pp.yz *= ROT(tm);\n  pp.xz *= ROT(tm*sqrt(0.5));\n  pp /= z;\n  float d = apollian(pp, 1.2);\n  return d*z;\n}\n\nfloat df(vec2 p) {\n  const float zoom = 0.5;\n  p /= zoom;\n  float d0 = weird(p);\n  return d0*zoom;\n}\n\nvec3 color(vec2 p) {\n  float aa   = 2.0/RESOLUTION.y;\n  const float lw = 0.0235;\n  const float lh = 1.25;\n\n  const vec3 lp1 = vec3(0.5, lh, 0.5);\n  const vec3 lp2 = vec3(-0.5, lh, 0.5);\n\n  float d = df(p);\n\n  float b = -0.125;\n  float t = 10.0;\n\n  vec3 ro = vec3(0.0, t, 0.0);\n  vec3 pp = vec3(p.x, 0.0, p.y);\n\n  vec3 rd = normalize(pp - ro);\n\n  vec3 ld1 = normalize(lp1 - pp);\n  vec3 ld2 = normalize(lp2 - pp);\n\n  float bt = -(t-b)/rd.y;\n  \n  vec3 bp   = ro + bt*rd;\n  vec3 srd1 = normalize(lp1-bp);\n  vec3 srd2 = normalize(lp2-bp);\n  float bl21= L2(lp1-bp);\n  float bl22= L2(lp2-bp);\n\n  float st1= (0.0-b)/srd1.y;\n  float st2= (0.0-b)/srd2.y;\n  vec3 sp1 = bp + srd1*st1;\n  vec3 sp2 = bp + srd2*st1;\n\n  float bd = df(bp.xz);\n  float sd1= df(sp1.xz);\n  float sd2= df(sp2.xz);\n\n  vec3 col  = vec3(0.0);\n  const float ss =15.0;\n  \n  col       += vec3(1.0, 1.0, 1.0)*(1.0-exp(-ss*(max((sd1+0.0*lw), 0.0))))/bl21;\n  col       += vec3(0.5)*(1.0-exp(-ss*(max((sd2+0.0*lw), 0.0))))/bl22;\n  float l   = length(p);\n  float hue = fract(0.75*l-0.3*TIME)+0.3+0.15;\n  float sat = 0.75*tanh(2.0*l);\n  vec3 hsv  = vec3(hue, sat, 1.0);\n  vec3 bcol = hsv2rgb(hsv);\n  col       *= (1.0-tanh(0.75*l))*0.5;\n  col       = mix(col, bcol, smoothstep(-aa, aa, -d));  \n  col       += 0.5*sqrt(bcol.zxy)*(exp(-(10.0+100.0*tanh(l))*max(d, 0.0)));\n\n  return col;\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(1.0/2.2)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // saturation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  \n  vec3 col = color(p);\n  col = postProcess(col, q);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3fzM.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[0, 352, 374, 374, 543], [545, 545, 578, 578, 793], [795, 795, 816, 816, 1178], [1180, 1180, 1198, 1198, 1280], [1282, 1282, 1302, 1302, 2618], [2620, 2620, 2657, 2657, 2910], [2912, 2912, 2967, 2967, 3154]], "test": "valid"}
{"id": "WlcBD2", "name": "Mandelbox slices", "author": "mrange", "description": "License CC0: Mandelbox slices\nMore slices through 4D space", "tags": ["mandelbox"], "likes": 12, "viewed": 331, "published": "Public API", "date": "1613427262", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License CC0: Mandelbox slices\n//  More slices through 4D space\n\n#define TOLERANCE       0.0001\n#define MAX_RAY_LENGTH  8.0\n#define MAX_RAY_MARCHES 100\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define LESS(a,b,c)     mix(a,b,step(0.,c))\n#define SABS(x,k)       LESS((.5/(k))*(x)*(x)+(k)*.5,abs(x),abs(x)-(k))\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n\n#define PERIOD          20.0\n#define FADE            2.5\n#define TIMEPERIOD      mod(TIME,PERIOD)\n#define NPERIOD         floor(TIME/PERIOD)\n\nconst float fixed_radius2 = 1.8;\nconst float min_radius2   = 0.5;\nconst vec4  folding_limit = vec4(1.0);\nconst float scale         = -2.9-0.2;\n\nfloat rand                = 0.5;\n\nfloat hash(float co) {\n  co += 6.0;\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  \n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nvec4 pmin(vec4 a, vec4 b, vec4 k) {\n  vec4 h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nvoid rot(inout vec2 v, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  v.xy = vec2(v.x*c + v.y*s, -v.x*s + v.y*c);\n}\n\nfloat box(vec4 p, vec4 b) {\n  vec4 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(max(q.x, q.w),max(q.y,q.z)),0.0);\n}\n\nvoid sphere_fold(inout vec4 z, inout float dz) {\n  float r2 = dot(z, z);\n    \n  float t1 = (fixed_radius2 / min_radius2);\n  float t2 = (fixed_radius2 / r2);\n\n  if (r2 < min_radius2) {\n    z  *= t1;\n    dz *= t1;\n  } else if (r2 < fixed_radius2) {\n    z  *= t2;\n    dz *= t2;\n  }\n}\n\nvoid box_fold(float k, inout vec4 z, inout float dz) {\n  // Soft clamp after suggestion from ollij\n  vec4 zz = sign(z)*pmin(abs(z), folding_limit, vec4(k));\n  z = zz * 2.0 - z;\n}\n\nfloat mb(vec4 z) {\n  float off = iTime*0.25;\n  vec4 offset = z;\n  float dr = 1.0;\n  float d = 1E6;\n  float k = mix(0.05, 0.25, fract(37.0*rand));\n  for(int n = 0; n < 4; ++n) {\n    box_fold(k/dr, z, dr);\n    sphere_fold(z, dr);\n    z = scale * z + offset;\n    dr = dr * abs(scale) + 1.0;\n    float dd = min(d, (length(z) - 2.5)/abs(dr));\n    if (n < 2) d = dd;\n  }\n\n  float d0 = (box(z, vec4(3.5, 3.5, 3.5, 3.5))-0.2) / abs(dr);\n  return fract(17.0*rand) > 0.5 ? pmin(d0, d, 0.05) : d0;\n}\n\nfloat df(vec3 p) {\n  const float s = 1.0/6.0;\n  p -= vec3(0.0, 1.0, 0.0);\n  p /= s;\n\n  float a = fract(3.0*rand);\n  const float aa = PI/4.0;\n  const float bb = PI/4.0-aa*0.5;\n  float b = bb+aa*fract(5.0*rand);\n  float c = bb+aa*fract(7.0*rand);\n  float d = bb+aa*fract(13.0*rand);\n  vec4 pp = vec4(p.x, p.y, p.z, 2.0*a*a);\n\n  rot(pp.xw, b);\n  rot(pp.yw, c);\n  rot(pp.zw, d);\n  return mb(pp)*s;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, out int iter) {\n  float t = 0.1;\n  int i = 0;\n  for (i = 0; i < MAX_RAY_MARCHES; i++) {\n    float d = df(ro + rd*t);\n    if (d < TOLERANCE || t > MAX_RAY_LENGTH) break;\n    t += d;\n  }\n  iter = i;\n  return t;\n}\n\nvec3 normal(vec3 pos) {\n  vec3  eps = vec3(.0005,0.0,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat softShadow(vec3 pos, vec3 ld, float ll, float mint, float k) {\n  const float minShadow = 0.25;\n  float res = 1.0;\n  float t = mint;\n  for (int i=0; i<24; i++) {\n    float d = df(pos + ld*t);\n    res = min(res, k*d/t);\n    if (ll <= t) break;\n    if(res <= minShadow) break;\n    t += max(mint*0.2, d);\n  }\n  return clamp(res,minShadow,1.0);\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(1.0/2.2)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 lightPos = 2.0*vec3(1.5, 3.0, 1.0);\n\n  vec3 skyCol = vec3(0.0);\n\n  int iter = 0;\n  float t = rayMarch(ro, rd, iter);\n\n  float ifade = 1.0-tanh_approx(3.0*float(iter)/float(MAX_RAY_MARCHES));\n\n  vec3 pos = ro + t*rd;    \n  vec3 nor = vec3(0.0, 1.0, 0.0);\n  \n  vec3 color = vec3(0.0);\n  \n  float h = hash(NPERIOD);\n  \n  if (t < MAX_RAY_LENGTH && pos.y > 0.0) {\n    // Ray intersected object\n    nor       = normal(pos);\n    vec3 hsv  = (vec3(fract(h - 0.6 + 0.4+0.25*t), 1.0-ifade, 1.0));\n    color     = hsv2rgb(hsv);\n  } else if (pos.y > 0.0) {\n    // Ray intersected sky\n    return skyCol*ifade;\n  } else {\n    // Ray intersected plane\n    t   = -ro.y/rd.y;\n    pos = ro + t*rd;\n    nor = vec3(0.0, 1.0, 0.0);\n    vec2 pp = pos.xz*1.5;\n    float m = 0.5+0.25*(sin(3.0*pp.x+TIME*2.1)+sin(3.3*pp.y+TIME*2.0));\n    m *= m;\n    m *= m;\n    pp = fract(pp+0.5)-0.5;\n    float dp = pmin(abs(pp.x), abs(pp.y), 0.025);\n    vec3 hsv = vec3(0.4+mix(0.15,0.0, m), tanh_approx(mix(100.0, 10.0, m)*dp), 1.0);\n    color = 5.5*hsv2rgb(hsv)*exp(-mix(30.0, 10.0, m)*dp);\n  }\n\n  vec3 lv   = lightPos - pos;\n  float ll2 = dot(lv, lv);\n  float ll  = sqrt(ll2);\n  vec3 ld   = lv / ll;\n  float sha = softShadow(pos, ld, ll, 0.01, 64.0);\n\n  float dm  = min(1.0, 40.0/ll2);\n  float dif = max(dot(nor,ld),0.0)*dm;\n  float spe = pow(max(dot(reflect(-ld, nor), -rd), 0.), 10.);\n  float l   = dif*sha;\n\n  float lin = mix(0.2, 1.0, l);\n\n  vec3 col = lin*color + spe*sha;\n\n  float f = exp(-20.0*(max(t-3.0, 0.0) / MAX_RAY_LENGTH));\n    \n  return mix(skyCol, col , f)*ifade;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q=fragCoord.xy/RESOLUTION.xy; \n  vec2 p = -1.0 + 2.0*q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  rand = hash(NPERIOD);\n\n  vec3 ro = mix(0.3, 0.4, fract(23.0*rand))*vec3(2.0, 0, 0.2)+vec3(0.0, 1.25, 0.0);\n  rot(ro.xz, sin(TIME*0.05));\n  rot(ro.yz, sin(TIME*0.05*sqrt(0.5))*0.25);\n\n  vec3 ww = normalize(vec3(0.0, 1.0, 0.0) - ro);\n  vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize( p.x*uu + p.y*vv + (2.0+0.5*tanh_approx(length(p)))*ww);\n\n  vec3 col = render(ro, rd);\n  col = clamp(col, 0.0, 1.0);\n  col *= smoothstep(0.0, FADE, TIMEPERIOD);\n  col *= 1.0-smoothstep(PERIOD-FADE, PERIOD, TIMEPERIOD);\n  fragColor = vec4(postProcess(col, q),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlcBD2.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[0, 788, 810, 810, 871], [873, 873, 901, 921, 997], [999, 999, 1038, 1038, 1126], [1128, 1128, 1163, 1163, 1248], [1250, 1250, 1283, 1283, 1371], [1373, 1373, 1400, 1400, 1497], [1499, 1499, 1547, 1547, 1779], [1781, 1781, 1835, 1879, 1959], [1961, 1961, 1979, 1979, 2449], [2451, 2451, 2469, 2469, 2846], [2848, 2848, 2896, 2896, 3091], [3093, 3093, 3116, 3116, 3325], [3327, 3327, 3395, 3395, 3674], [3676, 3676, 3713, 3713, 3965], [3967, 3967, 3989, 3989, 4158], [4160, 4160, 4191, 4191, 5744], [5746, 5746, 5801, 5801, 6514]], "test": "valid"}
{"id": "WlcBR2", "name": "IT312G-Galaxy2", "author": "pyknic", "description": "Attempt at creating a galaxy in GLSL", "tags": ["galaxy"], "likes": 4, "viewed": 123, "published": "Public", "date": "1613043303", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float ArmCount = 5.;\nconst float ArmCurvature = 1.4f;\nconst float StarDensity = 30.;\nconst float StarSize = .2;\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n \nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n \nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n \nfloat permutes(float vx)\n{\n      return mod((34.0 * vx + 1.0) * vx, 289.0);      \n}\n \nfloat snoise(vec3 v) { \n      const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n      const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n      \n      // First corner\n      vec3 i  = floor(v + dot(v, C.yyy) );\n      vec3 x0 =   v - i + dot(i, C.xxx) ;\n      \n      // Other corners\n      vec3 g = step(x0.yzx, x0.xyz);\n      vec3 l = 1.0 - g;\n      vec3 i1 = min( g.xyz, l.zxy );\n      vec3 i2 = max( g.xyz, l.zxy );\n      \n      //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n      //   x1 = x0 - i1  + 1.0 * C.xxx;\n      //   x2 = x0 - i2  + 2.0 * C.xxx;\n      //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n      vec3 x1 = x0 - i1 + C.xxx;\n      vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n      vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n      \n      // Permutations\n      i = mod289(i); \n      vec4 p = permute( permute( permute( \n                i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n              + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n              + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n      \n      // Gradients: 7x7 points over a square, mapped onto an octahedron.\n      // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n      float n_ = 0.142857142857; // 1.0/7.0\n      vec3  ns = n_ * D.wyz - D.xzx;\n      \n      vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n      \n      vec4 x_ = floor(j * ns.z);\n      vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n      \n      vec4 x = x_ *ns.x + ns.yyyy;\n      vec4 y = y_ *ns.x + ns.yyyy;\n      vec4 h = 1.0 - abs(x) - abs(y);\n      \n      vec4 b0 = vec4( x.xy, y.xy );\n      vec4 b1 = vec4( x.zw, y.zw );\n      \n      //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n      //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n      vec4 s0 = floor(b0)*2.0 + 1.0;\n      vec4 s1 = floor(b1)*2.0 + 1.0;\n      vec4 sh = -step(h, vec4(0.0));\n      \n      vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n      vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n      \n      vec3 p0 = vec3(a0.xy,h.x);\n      vec3 p1 = vec3(a0.zw,h.y);\n      vec3 p2 = vec3(a1.xy,h.z);\n      vec3 p3 = vec3(a1.zw,h.w);\n      \n      //Normalise gradients\n      vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n      p0 *= norm.x;\n      p1 *= norm.y;\n      p2 *= norm.z;\n      p3 *= norm.w;\n      \n      // Mix final noise value\n      vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n      m = m * m;\n      return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );\n}\n \nfloat fBm (vec3 P, float octaves, float lacunarity, float gain)\n{\n  float amp = 1.0;\n  float sum = 0.0;\n  float i;\n  \n  for (i = 0.0;  i < octaves;  i += 1.0) {\n    sum += amp * snoise (P);\n    amp *= gain;\n    P *= lacunarity;\n  }\n  return sum;\n}\n \nfloat Turbulence (vec3 P, float octaves, float lacunarity, float gain)\n{\n  float amp = 1.0;\n  float sum = 0.0;\n  float i;\n  \n  for (i = 0.0;  i < octaves;  i += 1.0) {\n    sum += abs(amp * snoise (P));\n    amp *= gain;\n    P *= lacunarity;\n  }\n  return sum;\n}\n\nuniform vec4 mainColor;\n\nvec3 colorAtTime(float armMask, vec2 polar, float t) {\n    float time0 = polar.y + t;\n    vec3 noiseCoord = 0.4 * vec3(\n        cos(polar.x) * time0, \n        sin(polar.x) * time0,\n        iTime * .05\n    );\n    \n    vec3 color1 = vec3(47., 110., 168.)/255.;\n    float layer1 = abs(fBm(noiseCoord * 3., 6., 2.1, 0.5));\n    vec3 color2 = vec3(179., 97., 199.)/255.;\n    float layer2 = pow(Turbulence(noiseCoord * 4., 6., 2.1, 0.45)*.6, 1.5);\n    vec3 col = layer1 * color1 + layer2 * color2;\n    return col * armMask;\n}\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n\n\n// Compound versions of the hashing algorithm I whipped together.\nuint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\nuint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\nuint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\n\n\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\n\n\n// Pseudo-random value in half-open range [0:1].\nfloat random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }\nfloat random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n\nvec2 GetCellCenter(vec2 uv) {\n    return vec2(\n        mod(mod(uv, 1.) * StarDensity, 1.) * 2. - 1.\n    );\n}\n\nvec2 RandomCellOffset(vec2 uv) {\n    vec3 grid = vec3(floor(uv*StarDensity)/StarDensity, 0.);\n    vec3 gridNoise = vec3(\n        random(grid+vec3(20., 50., -10.)),\n        random(grid+vec3(10., -30., -26.)),\n        random(grid+vec3(-78., -29., 50.))\n    );\n    \n    return normalize(gridNoise.xy * 2. - 1.) * \n        clamp(0., 1., gridNoise.z);\n}\n\nvec2 RandomActualCellOffset(vec2 uv) {\n    float d = 1./StarDensity;\n    vec2 center = GetCellCenter(uv);\n    vec2 c0 = RandomCellOffset(uv);\n    for (int i = 0; i < 9; i++) {\n        int dx = i % 3 - 1; // -1, 0 or 1\n        int dy = i / 3 - 1; // -1, 0 or 1\n        vec2 offset = vec2(dx, dy);\n        vec2 c1 = RandomCellOffset(uv + d*offset) + 2.*offset;\n        if (distance(center, c0) > distance(center, c1)) {\n            c0 = c1;\n        }\n    }\n    return c0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // -1 to 1\n    //vec2 uv = 2.0 * ((fragCoord + vec2(0.0, iResolution.x*.20))/iResolution.x - .5);\n    \n    vec2 uv = fragCoord/iResolution.x + vec2(0., .15);\n    \n    \n    vec2 backUV = uv;\n    {\n        // We center texture coordinates around 0.0\n        // Perspective plane equation \n        float pcenter=0.1;\n        float pmult=1.6; \n        float vc=(uv.y-pcenter)*pmult;\n        float uu=((uv.x-0.5)*1.0)/(1.0-vc);\n        float vv=((vc-0.6)/(1.0-vc)); \n        uv=vec2(uu,vv);\n    }\n    \n    vec2 middle = (uv + .5) * 2. - 1.;\n    //backUV += normalize(middle) * \n    //    (.2*pow(length(middle), .3)) * .5;\n    \n    \n    \n    \n    vec2 blackHoleUV = uv * .125;\n    \n    float yShift = max(0.0, 1.8 - pow(length(blackHoleUV),0.2));\n    blackHoleUV.y += yShift*.4;\n    \n    vec2 blackholePolar = vec2(\n        atan(blackHoleUV.y,blackHoleUV.x),\n        length(blackHoleUV)\n    );\n    \n    //uv.y += yShift;\n    \n    vec2 polar = vec2(\n        atan(uv.y, uv.x), // The angle (radians)\n        length(uv)        // The distance (0 - sqrt(2))\n    );\n    \n    // Bend the arms\n    float curveFactor = pow(polar.y, 0.7) * ArmCurvature;\n    curveFactor -= pow(max(0.0, 1.3 - length(uv)*2.),10.);\n    polar.x += curveFactor;\n    \n    blackholePolar.x += pow(blackholePolar.y, 0.7) * ArmCurvature;\n    blackholePolar.x += curveFactor;\n    \n    // Masks out the arms (0 - 1)\n    float armU = mod(polar.x*ArmCount, 6.28)/6.28; // 0 to 1\n    armU = armU * 2. - 1.;                   // -1 to 1\n    armU = abs(armU);                        // 0 to 1\n    armU = smoothstep(0.0, 1.0, armU);       // 0 to 1\n    \n    float barmU = mod(blackholePolar.x*ArmCount, 6.28)/6.28; // 0 to 1\n    barmU = barmU * 2. - 1.;                   // -1 to 1\n    barmU = abs(barmU);                        // 0 to 1\n    barmU = smoothstep(0.0, 1.0, barmU);       // 0 to 1\n\n    // Distance along the arm (0 - inf)\n    float armV = curveFactor * armU;\n\n    // Which arm? (0.0, 0.25, 0.5, 0.75, 1.0)\n    float armW = floor(\n        mod(polar.x+3.14, 6.28)*ArmCount / 6.28\n    ) / (ArmCount - 1.0);\n    \n    // Noise Coordinate\n    float time0 = polar.y/10.0 + mod(iTime, 5.0) / 5.0;\n    float time1 = polar.y/10.0 + mod(iTime + 2.5, 5.0) / 5.0;\n    float t     = abs(mod(iTime, 5.0) * 0.4 - 1.0);\n    vec3 col0 = colorAtTime(armU, polar, time0);\n    vec3 col1 = colorAtTime(armU, polar, time1);\n    vec3 col = mix(col0, col1, t);\n    \n    // Noise Coordinate\n    float btime0 = blackholePolar.y/10.0 + mod(iTime, 5.0) / 5.0;\n    float btime1 = blackholePolar.y/10.0 + mod(iTime + 2.5, 5.0) / 5.0;\n    vec3 bcol0 = colorAtTime(barmU, blackholePolar, btime0);\n    vec3 bcol1 = colorAtTime(barmU, blackholePolar, btime1);\n    vec3 bcol = mix(bcol0, bcol1, t);\n    \n    float hole = clamp(pow(length(uv)*5.,3.), 0.0, 1.0);\n    float light = clamp(pow(1.0-length(uv),3.), 0.0, 1.0);\n    \n    float galaxyMask = clamp(1.0 - length(uv)*0.3, 0.0, 1.0);\n    vec3 galaxy = galaxyMask * clamp( \n        vec3(pow(hole,1.3)*(pow(armU,1.5)*light+col)),\n        vec3(0.0), vec3(1.0));\n        \n    \n    \n    float backNoise0 = pow(abs(fBm(vec3(backUV*3., -1.),\n        6., 2.4, 0.4)), 1.5);\n    float backNoise1 = clamp(abs(Turbulence(vec3(backUV, 5.),\n        7., 2.2, 0.4)-0.3), 0., 1.);   \n    float backNoise2 = clamp(1.0-pow(abs(Turbulence(vec3(backUV*3., -1.),\n        6., 2.4, 0.4)), 0.5), 0.0, 1.0);\n        \n    vec3 backCol = \n        //vec3(39., 78., 145.)/255. * backNoise0 * .7 +\n        vec3(121., 34., 168.)/255. * backNoise1 * 0.4 +\n        vec3(49., 187., 212.)/255. * backNoise2 * .7\n    ;\n    \n    fragColor = vec4(backCol + galaxy, 1.0);\n    \n    \n    \n    vec2 gridNoise = RandomActualCellOffset(backUV);\n    \n    vec2 cellCenter = GetCellCenter(backUV);\n    \n    float starSizeT = abs(2.*mod(iTime*.1+random(RandomCellOffset(backUV)), 1.0)-1.);\n    float starSize = starSizeT * StarSize + 0.001;\n    float stars = (1.0/starSize)*(clamp(1.-distance(gridNoise, cellCenter),1.-starSize,1.)-(1.-starSize));\n    \n    stars = pow(stars, 5.);\n    \n    fragColor += vec4(vec3(stars), 1.);\n    \n    //fragColor = vec4(vec3(vec2(stars), 0.), 1.);\n    //fragColor = vec4(vec3(gridNoise.xy, 0.), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlcBR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[119, 119, 140, 140, 189], [192, 192, 213, 213, 262], [264, 264, 286, 286, 326], [329, 329, 357, 357, 409], [412, 412, 438, 438, 495], [498, 498, 520, 520, 2950], [2953, 2953, 3018, 3018, 3200], [3203, 3203, 3275, 3275, 3462], [3489, 3489, 3543, 3543, 4007], [4009, 4080, 4101, 4101, 4232], [4236, 4302, 4324, 4324, 4382], [4383, 4383, 4405, 4405, 4463], [4464, 4464, 4486, 4486, 4544], [4548, 4706, 4738, 4738, 5158], [5162, 5211, 5236, 5236, 5287], [5288, 5288, 5313, 5313, 5364], [5365, 5365, 5390, 5390, 5441], [5442, 5442, 5467, 5467, 5518], [5520, 5520, 5549, 5549, 5628], [5630, 5630, 5662, 5662, 5978], [5980, 5980, 6018, 6018, 6451], [6453, 6453, 6510, 6612, 10687]], "test": "error"}
{"id": "wlcBR4", "name": "Nueral Helmet 3D", "author": "iuryBorgesRodrigues", "description": "Nueral Helmet 3D", "tags": ["helmet", "neural"], "likes": 1, "viewed": 59, "published": "Public", "date": "1612311677", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//like the last few shaders I've published, this is a neural network experiment.\n//this time, the neural network reproduces an SDF given the x,y,z coordinates\n//using siren networks with skip connections: https://vsitzmann.github.io/siren/\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat scene(vec3 p) {\n    //sdf is undefined outside the unit sphere, uncomment to witness the abominations\n    if (length(p) > 1.) {\n        return length(p)-.8;\n    }\n    //neural networks can be really compact... when they want to be\n   vec4 f0_0=sin(p.y*vec4(-2.280,1.490,1.519,3.512)+p.z*vec4(3.027,-2.504,4.144,3.486)+p.x*vec4(2.450,.851,3.784,1.658)+vec4(4.338,4.013,-3.046,-.408));\nvec4 f0_1=sin(p.y*vec4(2.395,2.440,-.888,1.076)+p.z*vec4(-3.238,3.056,-4.287,-1.556)+p.x*vec4(.182,-2.615,-3.416,.825)+vec4(5.898,5.345,-5.378,-6.814));\nvec4 f0_2=sin(p.y*vec4(-1.159,-.499,3.208,1.353)+p.z*vec4(.601,-.612,1.365,.170)+p.x*vec4(-2.835,-3.950,-.073,-2.562)+vec4(7.754,4.879,6.752,-5.154));\nvec4 f0_3=sin(p.y*vec4(-2.592,.123,-2.826,-1.663)+p.z*vec4(-.690,-.043,-1.191,-3.286)+p.x*vec4(-1.349,-3.936,3.146,2.947)+vec4(3.810,-.518,-8.153,5.817));\nvec4 f1_0=sin(mat4(.513,-.225,.144,-.052,.130,.166,.327,-.055,-.159,.153,.245,-.034,.177,-.276,.166,-.353)*f0_0+\n    mat4(.460,.249,-.343,.310,-.091,-.340,.313,-.169,.328,-.367,-.010,.263,-.852,-.017,-.191,.654)*f0_1+\n    mat4(-.253,-.484,.107,.436,-.386,.418,.396,-.383,.625,.587,-.271,-.352,.651,-.056,.688,-.085)*f0_2+\n    mat4(.195,.377,-.088,.175,.484,.260,-.509,-.396,.331,.381,.092,.359,-.088,-.094,.169,-.375)*f0_3+\n    vec4(1.709,.735,-2.442,-2.796))/1.0+f0_0;\nvec4 f1_1=sin(mat4(-.260,-.193,-.113,.161,.855,.228,-.625,.706,.177,.008,.040,-.010,.166,-.160,.042,.149)*f0_0+\n    mat4(-.110,.338,.814,.058,-.170,-.117,-.350,.489,-.431,-.065,.019,.102,.003,.055,-.099,-.163)*f0_1+\n    mat4(.725,-.174,-.081,.392,.168,.090,.629,-.489,-.069,-.234,.529,.190,.070,-.244,.658,-.134)*f0_2+\n    mat4(-.062,-.659,.189,.207,.238,.361,-.749,-.095,.289,-.193,.331,.046,-.335,.136,.464,-.497)*f0_3+\n    vec4(2.707,.097,-2.717,1.043))/1.0+f0_1;\nvec4 f1_2=sin(mat4(-.274,.282,-.225,.027,-.548,.502,-.019,-.432,-.791,.026,-.150,.159,.255,-.190,.002,.063)*f0_0+\n    mat4(-.221,.241,.105,.079,-.127,.020,.157,.172,.202,-.110,-.273,.311,.026,-.284,.335,-.315)*f0_1+\n    mat4(.125,-.249,-.138,-.588,.019,-.477,-.201,.428,-.146,-.488,.401,-.016,-.128,-.140,-.356,-.344)*f0_2+\n    mat4(-.117,-.069,.061,.507,.055,-.046,-.280,-.391,-.102,-.309,-.374,-.198,-.235,.287,.227,-.189)*f0_3+\n    vec4(-.751,-.834,-2.697,-1.682))/1.0+f0_2;\nvec4 f1_3=sin(mat4(.000,.202,-.212,.102,.171,.099,.319,-.177,.131,-.105,.053,.252,-.090,-.165,.119,.323)*f0_0+\n    mat4(-.540,.027,-.175,.100,.063,.175,.009,.010,-.589,.322,.152,.058,.569,.258,-.463,-.151)*f0_1+\n    mat4(-.046,-.357,.312,-.151,.296,-.064,.622,.275,.036,.307,-.519,-.278,-.083,-.121,-.081,-.002)*f0_2+\n    mat4(.255,.306,-.034,-.145,-.292,.183,.229,.310,.264,.678,.478,.022,.253,.065,-.019,.387)*f0_3+\n    vec4(1.798,.550,.445,1.028))/1.0+f0_3;\nvec4 f2_0=sin(mat4(-.033,-.433,.386,.036,.504,.325,.297,-.400,.242,.256,-.117,.446,-.179,.057,-.637,.219)*f1_0+\n    mat4(-.412,-.438,.493,.417,-.515,-.172,.135,.068,.403,.246,-.496,-.412,.230,.546,.088,.130)*f1_1+\n    mat4(-.229,.010,.254,.129,-.172,.456,.113,-.401,.231,-.449,.318,-.270,-.094,-.128,-.092,.497)*f1_2+\n    mat4(-.143,.106,-.330,-.233,.064,-.540,-.148,-.183,-.056,-.419,-.309,-.376,-.150,.252,.170,.066)*f1_3+\n    vec4(-2.813,-.877,-.340,-1.659))/1.4+f1_0;\nvec4 f2_1=sin(mat4(-.608,-.337,.080,-.029,-.374,-.091,-.208,.589,.127,.265,.427,.005,-.156,.357,-.058,-.324)*f1_0+\n    mat4(-.160,.385,.456,-.213,-.288,.322,.228,.309,-.300,-.189,-.131,.066,.589,.393,-.202,.033)*f1_1+\n    mat4(-.524,-.163,-.337,.100,-.199,-.012,.087,.194,-.202,.083,-.286,-.120,.613,-.283,.089,.201)*f1_2+\n    mat4(.023,-.368,-.377,-.451,-.262,.059,.033,.014,.151,-.090,-.416,-.498,.025,.118,-.135,-.000)*f1_3+\n    vec4(-2.146,.331,2.617,.948))/1.4+f1_1;\nvec4 f2_2=sin(mat4(.336,.186,.709,.127,-.032,.211,-.007,.361,-.220,.573,.283,.397,-.025,.102,.004,.123)*f1_0+\n    mat4(.032,-.344,-.031,.131,-.009,.532,-.225,.061,.055,-.249,-.340,-.254,.201,.338,-.136,-.094)*f1_1+\n    mat4(-.131,-.009,.095,.408,.005,.272,.238,.420,.480,.054,.440,.463,-.402,.126,.344,-.514)*f1_2+\n    mat4(.384,-.384,-.207,.094,-.301,.205,.066,.299,-.338,-.321,.170,.406,-.177,-.510,-.091,-.131)*f1_3+\n    vec4(-2.949,.095,-1.105,.117))/1.4+f1_2;\nvec4 f2_3=sin(mat4(.026,-.765,.514,-.220,.064,.293,-.056,.185,.504,.335,-.120,.269,-.071,.462,-.080,-.298)*f1_0+\n    mat4(-.441,-.008,.569,-.489,.553,.123,.453,.123,.208,.109,-.366,-.205,-.250,.565,.186,.249)*f1_1+\n    mat4(-.210,.094,-.366,.383,.122,.831,.238,-.133,.070,-.142,-.267,.008,.241,-.235,-.011,-.316)*f1_2+\n    mat4(-.346,.662,-.406,-.311,-.487,.448,-.275,.673,-.049,.055,.172,-.172,-.172,-.127,.391,-.194)*f1_3+\n    vec4(-1.311,-2.546,2.208,3.121))/1.4+f1_3;\nvec4 f3_0=sin(mat4(-.461,.357,-.347,-.992,-.223,.305,-.689,-.070,.540,.183,-.065,-.545,.612,-.030,-.380,.043)*f2_0+\n    mat4(-.234,.250,.094,.052,.304,-.103,-.213,-.542,-.049,.570,-.116,-.021,.559,-.471,.236,-.231)*f2_1+\n    mat4(-.081,-.249,.316,.578,-.155,-.424,-.120,-.232,.101,.181,-.242,.555,.137,.036,-.079,-.299)*f2_2+\n    mat4(-.372,.230,-.325,.013,.115,.101,.241,.637,-.718,.317,-.249,-.409,-.405,.042,-.527,.460)*f2_3+\n    vec4(-.919,.395,-1.426,-1.472))/1.7+f2_0;\nvec4 f3_1=sin(mat4(.336,-.396,.167,-.240,-.537,-.657,.434,-.037,-.041,.037,.552,.191,.410,.059,.000,.156)*f2_0+\n    mat4(-.140,.940,.331,-.281,.311,.073,.435,-.253,.057,-.581,.414,.355,-.043,.146,.184,.377)*f2_1+\n    mat4(.692,-.038,.006,.290,-.026,-.932,-.606,.262,.245,-.047,.248,.241,-.038,.303,.261,.203)*f2_2+\n    mat4(-.140,-.089,-.094,-.239,.064,.195,-.055,.159,-.254,-.209,.194,-.033,-.199,-.817,-.377,.667)*f2_3+\n    vec4(3.223,1.243,-2.910,1.378))/1.7+f2_1;\nvec4 f3_2=sin(mat4(.336,-.091,-.036,-.122,.232,.033,.124,.260,.444,-.329,.075,.028,-.535,.096,.387,-.279)*f2_0+\n    mat4(.030,-.187,-.061,.326,.428,-.422,.408,-.433,.314,.005,-.410,-.029,.326,.143,.049,.600)*f2_1+\n    mat4(-.605,.286,-.646,-.192,-.579,.369,-.484,-.701,-.220,.232,.126,.397,-.100,.087,-.213,.096)*f2_2+\n    mat4(.396,.189,.195,-.007,-.309,-.441,-.230,.443,.032,.047,-.396,-.154,-.288,-.260,-.302,-.224)*f2_3+\n    vec4(1.797,1.805,2.134,1.084))/1.7+f2_2;\nvec4 f3_3=sin(mat4(-.581,.118,-.359,-.124,.596,-.349,.102,.344,-.252,.566,.214,-.650,-.053,.299,-.066,.185)*f2_0+\n    mat4(-.111,.011,.197,.153,.354,-.374,-.243,-.055,.314,-.309,.102,-.133,-.133,.370,-.071,.176)*f2_1+\n    mat4(-.155,.633,.193,-.084,.005,.203,.284,-.185,.319,-.119,-.152,-.151,.551,-.087,-.513,.160)*f2_2+\n    mat4(.649,.521,.627,.606,-1.001,-.452,-.185,.189,.073,-.435,-.479,.487,.276,.206,-.460,-.457)*f2_3+\n    vec4(.222,-3.386,-.446,2.975))/1.7+f2_3;\nvec4 f4_0=sin(mat4(-.158,-.127,-.382,-.271,.185,.553,-.130,.577,-.091,-.145,-.124,-.527,.246,.066,.587,-.430)*f3_0+\n    mat4(.407,.047,-.110,.360,.353,.492,.265,-.540,-.298,.063,-.248,-.847,-.084,.327,-.213,.058)*f3_1+\n    mat4(.122,-.044,.293,-.032,-.143,.555,.004,-.184,-.535,-.255,.315,-.235,.268,.362,-.278,-.402)*f3_2+\n    mat4(.361,-.012,-.130,-.313,.213,.130,-.007,-.046,.381,-.183,-.007,-.492,-.320,-.023,.095,.359)*f3_3+\n    vec4(1.516,2.335,1.185,-3.037))/2.0+f3_0;\nvec4 f4_1=sin(mat4(-.074,.211,.530,-.229,-.132,.571,.060,.125,.071,.461,.337,-.049,.031,-.338,.328,.070)*f3_0+\n    mat4(.002,-.125,-.390,.185,.623,-.121,.353,-.096,.421,-.352,.432,.387,.225,-.222,.469,.162)*f3_1+\n    mat4(-.566,-.414,-.091,.053,-.052,.513,.046,-.058,-.115,.070,.446,.203,-.401,-.069,.155,.397)*f3_2+\n    mat4(.075,.361,.154,.021,.645,-.420,.524,.102,-.017,.415,-.485,.280,-.241,.545,.167,-.365)*f3_3+\n    vec4(-.741,2.790,2.109,1.900))/2.0+f3_1;\nvec4 f4_2=sin(mat4(-.314,-.098,-.005,-.677,-.235,-.122,.211,-.008,.183,.533,-.192,-.133,-.531,.330,-.367,.154)*f3_0+\n    mat4(-.234,.249,-.153,.216,.123,-.225,-.071,-.100,.157,.258,-.407,-.483,-.388,-.289,-.584,.276)*f3_1+\n    mat4(.317,.310,-.085,.404,.349,.216,.124,-.505,-.257,.290,-.565,-.126,.480,-.197,-.330,-.702)*f3_2+\n    mat4(-.188,-.277,.480,-.125,-.488,-.704,.290,.835,.252,-.022,.432,-.144,-.403,.633,-.385,.248)*f3_3+\n    vec4(-2.083,.133,2.590,1.280))/2.0+f3_2;\nvec4 f4_3=sin(mat4(.005,-.101,.437,.468,.042,.041,-.528,.192,.570,-.141,-.302,-.206,.026,-.160,.155,.310)*f3_0+\n    mat4(-.246,.094,-.019,.254,-.263,.585,.613,-.290,.092,-.073,.089,-.074,-.307,.039,-.309,-.080)*f3_1+\n    mat4(.384,-.034,.566,-.172,.639,.698,.334,.139,-.719,-.050,.445,.417,.399,-.014,-.429,.023)*f3_2+\n    mat4(-.689,-.038,-.261,.029,-.353,-.075,-.403,.193,-.668,-.015,.074,.323,.362,.118,-.218,.472)*f3_3+\n    vec4(-1.181,-.177,-.355,.543))/2.0+f3_3;\nvec4 f5_0=sin(mat4(-.217,-.457,.384,-.132,.159,-.297,-.239,.475,-.348,.621,-.038,-.078,-.474,.701,.118,.210)*f4_0+\n    mat4(-.010,.096,-.359,.228,.303,.002,-.298,.018,.016,-.459,.158,.127,.470,.797,.201,-.227)*f4_1+\n    mat4(-.457,.509,.076,-.369,-.174,.004,.192,-.168,-.194,-.117,.639,.003,-.027,-.326,.465,-.300)*f4_2+\n    mat4(-.166,-.767,-.250,.369,.160,-.458,-.003,.075,.523,-.405,.226,.601,-.324,-.255,.368,.367)*f4_3+\n    vec4(.290,-1.713,.352,-.123))/2.2+f4_0;\nvec4 f5_1=sin(mat4(-.007,-.024,-.256,-.071,-.163,-.360,.159,.182,.019,-.149,-.044,-.071,.149,.210,.289,.186)*f4_0+\n    mat4(-.332,-.391,-.113,.364,.573,.116,.168,-.632,-.111,-.268,.225,-.050,.150,-.212,-.546,.320)*f4_1+\n    mat4(-.419,-.138,.237,.281,-.063,.214,.162,-.080,-.159,.304,-.209,-.087,-.332,.272,.415,-.062)*f4_2+\n    mat4(-.102,-.320,.194,.287,.659,-.316,-.106,-.399,.234,-.341,-.307,-.009,-.530,.096,.046,-.029)*f4_3+\n    vec4(-2.505,-1.322,2.637,.862))/2.2+f4_1;\nvec4 f5_2=sin(mat4(-.160,-.223,-.016,-.243,-.078,-.406,.513,-.081,.456,.436,-.433,.253,-.226,.330,.043,-.240)*f4_0+\n    mat4(-.196,.035,-.085,.122,.221,-.580,-.235,-.058,.378,-.718,.115,-.116,.232,-.196,-.184,.218)*f4_1+\n    mat4(.133,-.051,.328,.572,-.405,-.318,-.279,-.505,.073,-.091,.036,.048,.074,.349,-.260,-.205)*f4_2+\n    mat4(.183,.078,.125,-.006,-.048,.067,-.428,.150,-.074,-.580,-.474,-.424,.541,-.468,-.480,.459)*f4_3+\n    vec4(-1.968,-1.399,.969,1.456))/2.2+f4_2;\nvec4 f5_3=sin(mat4(-.485,.249,.051,-.649,-.225,-.131,-.751,.503,.235,-.232,-.466,-.482,-.320,.511,.356,-.261)*f4_0+\n    mat4(-.103,.081,.384,-.212,.553,.184,-.303,-.627,-.488,-.272,.367,.051,-.048,.083,.219,-.408)*f4_1+\n    mat4(-.645,-.229,.698,.067,-.319,.161,-.126,.182,.199,.286,.379,-.017,-.054,.532,.285,-.239)*f4_2+\n    mat4(-.250,-.473,-.208,-.397,-.527,.068,-.308,.583,.399,.162,-.567,.285,-.431,-.013,-.441,.726)*f4_3+\n    vec4(1.136,1.440,-2.654,-1.841))/2.2+f4_3;\nvec4 f6_0=sin(mat4(-.327,-.475,.241,.564,.437,.168,.298,-.466,.261,-.638,-.439,-.199,.406,-.112,-.138,-.321)*f5_0+\n    mat4(.220,.047,.716,-.319,-.584,.205,.477,-.069,-.075,.414,-.349,.190,-.001,-.255,.514,.179)*f5_1+\n    mat4(-.287,.150,.342,-.102,.213,-.322,-.374,.114,-.560,.035,.326,.758,-.604,.445,.207,.286)*f5_2+\n    mat4(.274,-.179,.261,.070,-.134,-.143,-.191,-.015,.582,.163,-.283,-.267,.191,.279,-.308,-.017)*f5_3+\n    vec4(-2.820,-1.032,1.598,3.016))/2.4+f5_0;\nvec4 f6_1=sin(mat4(.220,.216,-.247,.138,.083,.092,-.036,.761,.362,-.309,-.147,-.341,.476,-.431,.363,.217)*f5_0+\n    mat4(-.003,-.646,-.209,.641,-.054,.375,.581,.266,.005,-.138,.184,.209,.013,.357,-.803,.053)*f5_1+\n    mat4(.032,-.186,.531,-.079,.151,-.005,.563,1.069,-.395,-.736,.414,.040,-.574,-.090,-.408,-.243)*f5_2+\n    mat4(-.017,.083,-.477,-.276,.169,.335,-.085,-.001,-.216,-.168,-.138,-.308,.128,.119,-.316,.021)*f5_3+\n    vec4(1.801,1.232,-2.060,-1.157))/2.4+f5_1;\nvec4 f6_2=sin(mat4(-.085,.071,-.186,.090,-.133,.724,-.680,.377,-.684,.295,-.147,.132,-.033,.407,-.087,-.490)*f5_0+\n    mat4(-.079,-.732,-.071,.232,.017,.528,-.168,-.653,-.108,-.102,-.067,.024,.371,.551,.177,.307)*f5_1+\n    mat4(-.828,-.033,.383,.244,-.421,.457,-.728,-.138,-.363,-.765,.406,-.365,-.091,-.069,.121,.163)*f5_2+\n    mat4(.244,-.140,-.149,.680,.135,.122,.090,.150,-.479,-.084,-.322,.162,-.359,.090,.144,-.039)*f5_3+\n    vec4(-3.476,2.131,-.850,-2.476))/2.4+f5_2;\nvec4 f6_3=sin(mat4(.223,-.104,.858,-.049,-.644,-.133,.825,-.506,-.041,.112,-.203,.103,-.562,.135,-.142,.250)*f5_0+\n    mat4(.036,-.109,-.602,.319,.333,.496,-.430,-.312,-.631,.192,-.415,-.200,.269,-.016,-.028,-.552)*f5_1+\n    mat4(-.087,-.853,.555,-.140,-.302,-.141,-.010,-.059,-.285,-.161,.016,-.451,-.276,.606,-.196,.371)*f5_2+\n    mat4(-.208,.109,-.090,-.201,-.403,-.187,.188,-.763,.630,-.267,.138,-.339,-.290,.257,-.067,-.128)*f5_3+\n    vec4(.884,1.026,-.594,-1.012))/2.4+f5_3;\nvec4 f7_0=sin(mat4(-.432,-.336,-.131,-.106,-.194,.551,.006,.432,.369,-.406,.430,-.461,.427,-.029,.053,-.337)*f6_0+\n    mat4(.086,.377,-.291,.239,-.086,-.827,.068,.257,.299,-.372,-.163,.160,.160,-.110,-.484,.502)*f6_1+\n    mat4(.215,-.683,-.085,-.133,-.399,.621,.527,.570,-.060,-.286,.325,-.609,-.641,.259,.788,-.206)*f6_2+\n    mat4(-.448,-.061,.025,.227,-.367,-.009,-.194,-.144,-.088,.267,-.405,-.682,-.690,-.080,.249,.453)*f6_3+\n    vec4(-2.560,1.568,2.800,.061))/2.6+f6_0;\nvec4 f7_1=sin(mat4(.057,-.616,-.359,.164,.111,-.234,-.177,.330,-.459,.122,-.172,-.347,-.199,-.296,-.093,-.101)*f6_0+\n    mat4(-.513,.030,-.141,.436,-.342,.122,-.409,-.134,-.352,.108,.162,.484,-.255,.629,-.336,-.130)*f6_1+\n    mat4(-.164,-.102,-.547,-.098,.236,-.357,.016,.530,-.189,.046,-.265,-.218,.050,-.321,-.764,-.097)*f6_2+\n    mat4(-.552,-.126,.167,.440,.261,-.280,-.483,.759,-.244,.409,.025,.490,.519,.644,-.149,.397)*f6_3+\n    vec4(1.788,-1.499,1.190,.363))/2.6+f6_1;\nvec4 f7_2=sin(mat4(.051,.457,-.380,-.354,-.516,-.481,-.648,.845,.660,.558,-.336,.610,.434,-.304,-.116,-.116)*f6_0+\n    mat4(-.487,.211,-.192,-.290,.324,-.090,.114,-.008,.302,.138,.138,-.488,-.133,-.323,.447,-.036)*f6_1+\n    mat4(.139,-.189,-.360,-.666,-.527,-.527,-.419,.097,.386,-.023,-.135,-.271,-.485,-.071,.306,-.380)*f6_2+\n    mat4(-.050,.019,.011,-.398,-.128,.262,-.274,-.085,.563,-.675,-.222,.339,-.691,.617,-.496,.517)*f6_3+\n    vec4(1.194,.110,-.157,-1.846))/2.6+f6_2;\nvec4 f7_3=sin(mat4(.120,-.444,-.441,-.416,-.555,.424,.500,.816,-.232,-.240,.102,.293,-.073,.410,-.234,-.220)*f6_0+\n    mat4(-.568,-.024,.287,.380,.013,.272,.690,.181,.513,.434,.431,-.091,.315,.184,-.340,.032)*f6_1+\n    mat4(-.523,-.097,-.132,-.770,.183,-.091,-.025,.548,-.303,-.039,-.000,-.119,-.201,-.031,-.350,.431)*f6_2+\n    mat4(-.362,.099,.400,-.374,.781,-.523,.063,-.348,-.058,.153,.366,.029,.396,.156,.277,.222)*f6_3+\n    vec4(2.963,-1.577,1.097,.645))/2.6+f6_3;\nvec4 f8_0=sin(mat4(.151,.214,.229,-.374,.353,.452,-.662,-.070,-.061,-.706,.295,-.197,.269,-.101,-.203,-.245)*f7_0+\n    mat4(-.500,-.070,.241,.497,.743,-.369,.132,-.249,.323,-.409,.243,.008,.466,.221,-.037,-.344)*f7_1+\n    mat4(-.645,-.707,-.271,-.028,-.071,.270,.040,.287,-.432,-.632,-.278,.482,-.418,.062,.620,.387)*f7_2+\n    mat4(.565,-.464,.745,.410,.525,.080,.437,-.272,.111,-.072,-.252,.541,-.129,.745,-.133,-.033)*f7_3+\n    vec4(-.368,.808,.183,-2.188))/2.8+f7_0;\nvec4 f8_1=sin(mat4(-.771,.171,-.586,-.122,.211,-.394,-.116,-.400,.196,-.729,.073,.607,.027,-.211,.450,.484)*f7_0+\n    mat4(.280,-.072,-.442,.525,.116,-.238,.509,-.787,.045,-.667,.210,-.428,-.293,-.301,.056,-.085)*f7_1+\n    mat4(-.882,.165,.179,.226,.326,.584,.279,-.408,.270,.017,.225,-.548,.118,-.615,-.732,.001)*f7_2+\n    mat4(.242,-.185,-.051,-.329,-.108,-.462,-.056,.225,-.552,-.522,.156,-.341,.255,.150,-.791,-.065)*f7_3+\n    vec4(-1.590,.547,.092,.596))/2.8+f7_1;\nvec4 f8_2=sin(mat4(-.028,-.046,.059,-.040,.480,-.354,-.527,.031,-.537,.178,.302,.043,.112,.323,-.153,.151)*f7_0+\n    mat4(-.457,.205,-.271,-.282,-.432,.571,-.069,-.220,-.293,-.466,.235,-.328,-.053,.105,-.628,-.682)*f7_1+\n    mat4(-.216,.366,-.108,.394,.383,.221,.491,.392,.398,-.878,.061,-.363,-.120,.775,.188,.366)*f7_2+\n    mat4(-.049,.214,-.202,.499,-.948,-.506,.156,.050,-.203,.502,.467,-.288,.709,-.177,.215,-.539)*f7_3+\n    vec4(.047,-1.743,-.615,-2.845))/2.8+f7_2;\nvec4 f8_3=sin(mat4(.583,.127,-.332,-.060,.159,.887,-.398,.215,.509,-.029,.071,.173,-.464,-.302,.373,.177)*f7_0+\n    mat4(.803,-.040,.246,-.417,-.310,.448,.783,-.270,.279,-.082,-.103,-.119,.542,-.580,.002,.690)*f7_1+\n    mat4(-.255,-.133,.117,-.609,-.103,.031,-.312,.206,.358,.510,.607,-.582,.703,-.343,.201,.381)*f7_2+\n    mat4(-.020,.202,.164,.041,.148,-.207,-.134,-.268,-.044,.389,.161,.335,.198,.823,-.462,-.166)*f7_3+\n    vec4(.501,-2.360,-2.924,.725))/2.8+f7_3;\nreturn dot(f8_0,vec4(.037,-.044,.038,.045))+\n    dot(f8_1,vec4(.039,-.027,.041,.045))+\n    dot(f8_2,vec4(-.026,-.008,-.065,.047))+\n    dot(f8_3,vec4(-.013,.051,.037,.023))+\n    0.080;\n\n\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 cam = normalize(vec3(1.5,uv));\n    vec3 init = vec3(-3.,0,0);\n    \n    float yrot = 0.5;\n    float zrot = iTime*.2;\n    if (iMouse.z > 0.) {\n        yrot += -4.*mouse.y;\n        zrot = 4.*mouse.x;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n    \n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 150 && !hit; i++) {\n        float dist = scene(p)-0.02;\n        hit = dist*dist < 1e-6;\n        p+=dist*cam;\n        if (distance(p,init)>5.) break;\n    }\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    //don't ask how I stumbled on this texture\n    vec3 nz = p - erot(p, vec3(1), 2.) + erot(p, vec3(1), 4.);\n    float spec = length(sin(r*3.5+sin(nz*120.)*.15)*.4+.6)/sqrt(3.);\n    spec *= smoothstep(-.3,.2,scene(p+r*.2));\n    vec3 col = vec3(.1,.1,.12)*spec + pow(spec,8.);\n    float bgdot = length(sin(cam*8.)*.4+.6)/2.;\n    vec3 bg = vec3(.1,.1,.11) * bgdot + pow(bgdot, 10.);\n    fragColor.xyz = hit ? col : bg;\n    fragColor = smoothstep(-.02,1.05,sqrt(fragColor)) * (1.- dot(uv,uv)*.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlcBR4.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[194, 435, 473, 473, 535], [537, 537, 558, 644, 16676], [16678, 16678, 16697, 16697, 16813], [16815, 16815, 16872, 16872, 18145]], "test": "valid"}
{"id": "WlcBW7", "name": "Newton root for e^z-z-c", "author": "jayprich", "description": "Newton's method  x -> x - ( f - x0 ) / f'  is very stable near solutions but allows a series of jumps at the boundary between convergent basins if the iterate happens to also land near a boundary", "tags": ["newton"], "likes": 1, "viewed": 48, "published": "Public", "date": "1612815206", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// https://www.volkerschatz.com/art/miscart.html\n// Newton root seek e^z-z-const .. the \"const\" changes over time\n// plot the root found by the initial z \n\n\nvec2 cexp(vec2 a){return exp(a.x)*vec2(cos(a.y), sin(a.y));}\nvec2 cdiv(vec2 a, vec2 b){return vec2(a.x*b.x+a.y*b.y,a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y);}\nvec2 cmul(vec2 a, vec2 b){return vec2(a.x*b.x-a.y*b.y,a.x*b.y+b.x*a.y);}\n\nvec4 newton(vec2 c)\n{\n vec2 x, xn;\n xn = c;\n x = xn - cdiv(cexp(xn)-xn-vec2(5.*cos(.1*iTime)*(1.+sin(.5*iTime)),12.*sin(.12*iTime)),cexp(xn)-1.);\n float i=0.;\n for(;i<45.&&length(x-xn)>1.e-3;i++)\n {\n  xn = x;\n  x = xn - cdiv(cmul(xn,cmul(xn,xn))-vec2(1.0,0),(3.0*cmul(xn,xn)));\n }\n return vec4(i/45.0,0.5+i*0.05*x.y,0.5+0.25*x.x,1.0);\n}\t\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n vec2 uv = 6.*(fragCoord-iMouse.xy)/iResolution.y-vec2(2.,0.) ;\n fragColor = newton(uv);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlcBW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 157, 175, 175, 217], [218, 218, 244, 244, 308], [309, 309, 335, 335, 381], [383, 383, 404, 404, 719], [722, 722, 779, 779, 870]], "test": "valid"}
{"id": "WlcBWf", "name": "Spiral study", "author": "sig", "description": "Study for simple map generation for https://ball-game-v1.vercel.app/", "tags": ["geometric"], "likes": 1, "viewed": 69, "published": "Public", "date": "1613548613", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = 10.0 * ((2.0 * fragCoord - iResolution.xy) / iResolution.y);\n    \n    float a = atan(p.y, p.x) / PI + 1.;\n    float r = length(p);\n\n    vec3 col = 0.5 + 0.5*cos(iTime + vec3(0,2,4))\n        + step(mod((r - 0.5)/2. + a, 2.), 0.5) * vec3(0.2, 0.02, -0.02)\n        + step(mod(floor(r/2. + a + 1.) * a + mod(iTime, 2.0), 0.5), 0.2) * vec3(0.4, 0.02, 0.03);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlcBWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 77, 77, 501]], "test": "valid"}
{"id": "wlcfDB", "name": "2D Particle Generator", "author": "Learner_CC", "description": "A simple particle generator", "tags": ["2dparticle"], "likes": 1, "viewed": 70, "published": "Public", "date": "1613363050", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define g -9.81\n// -------- Hash -------- //\nfloat N21(vec2 p) {\n\tp = fract(p * vec2(233.34, 851.73));\n    p += dot(p, p + 23.45);\n    return fract(p.x * p.y);\n}\n\nvec2 N22(vec2 p) {\n\tfloat n = N21(p);\n    return vec2(n, N21(p + n));\n}\n\nfloat N11(float n) {\n    return fract(sin(dot(vec2(cos(n), sin(n)) ,vec2(27.9898, 38.233))) * 88.5453);\n}\n// -------- Particle -------- //\nfloat particle(vec2 uv, vec2 p, vec2 v, float t) {\n    float x = p.x + v.x * t;\n    float y = p.y + v.y * t + g / 2.0 * t * t;\n    vec2 l = (vec2(x, y) - uv) * 15.0;\n    float pct = 1.0 / dot(l, l) * smoothstep(1.0, 0.5, t);;\n    return pct;\n}\n\nfloat particleGenerator1(vec2 uv, vec2 p, float t, float n) {\n    float pct = 0.0;\n    float ti = mod(t, 4.0);\n    for (float i = 0.0; i < n; i++) {\n        float x = (1.0 + i) * cos(i);\n        float y = (1.0 + i) * sin(i);\n        vec2 rand = vec2(x, y);\n        vec2 velocity = rand / 2.0;\n        pct += particle(uv, vec2(0.0, 1.0), velocity, t);\n    }\n    return pct;\n}\n\nfloat seed = 0.32;\nfloat particleGenerator2(vec2 uv, vec2 p, float t, float n) {\n    float pct = 0.0;\n    float ti = mod(t, 4.0);\n    for (float i = 0.0; i < n; i++) {\n        seed += i;\n        vec2 rand = vec2(1.0, 1.6) * (vec2(-1.0, 1.0) + 2.0 * N22(vec2(seed, i)));\n        float randi = 8.0 * N21(rand) - 4.0;\n        vec2 position = vec2(cos(randi), sin(randi));\n        vec2 velocity = vec2(position.y, position.x) * 20.0;\n        pct += particle(uv, position, velocity, t);\n    }\n    return pct;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    vec2 st = 2.0 * uv - 1.0;\n\n    st*= 10.0;\n    \n    float t = iTime / 4.0;\n    float pct = 0.0;\n    float n = 10.0;\n    for (float i = 0.0; i < 1.0; i += 1.0 / n) {\n        float ti = mod(t - i * (n - 1.0), 1.0);\n        pct += particleGenerator2(st, vec2(0.0, 1.0), ti, 72.0);\n    }\n\n    fragColor = vec4(pct);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlcfDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[16, 45, 64, 64, 161], [163, 163, 181, 181, 234], [236, 236, 256, 256, 341], [342, 375, 425, 425, 618], [620, 620, 681, 681, 994], [1015, 1015, 1076, 1076, 1501], [1502, 1502, 1557, 1557, 1922]], "test": "valid"}
{"id": "wlcfR8", "name": "MandelOct", "author": "nimitz", "description": "Octahedral folding instead of box folding.", "tags": ["fractal"], "likes": 18, "viewed": 444, "published": "Public", "date": "1612216158", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// MandelOct by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/wlcfR8\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define ITR 200\n#define FAR 200.\n\nconst float fov = 1.4;\nfloat dfog = 0.;\nfloat matid = 0.;\n\n#define FLIP_SPEED 0.22\n#define FLIP_REV 0.5\n#define FLIP_CURVE 0.3\n\n\nfloat an = 0.;\n\nvoid sphere_fold(inout vec3 z, inout float dz, float rd1, float rd2) {\n    float r2 = dot(z, z);\n    if(r2 < rd1) \n    {\n        float temp = (rd2 / rd1);\n        z *= temp;\n        dz *= temp;\n    }\n    else if(r2 < rd2) {\n        float temp = (rd2 / r2);\n        z *= temp;\n        dz *= temp;\n    }\n}\n\nvoid octfold(inout vec3 z, float octsize, float limit) {\n    \n    float odst = dot(abs(z), vec3(0.57735));\n    \n    if (odst > octsize)\n    {\n        vec3 sn = vec3(lessThanEqual(vec3(0.0), z))*2.0 - 1.0;\n        vec3 n = vec3(sn)*0.57735;   \n        float fdist = (odst - octsize);\n        fdist = clamp(fdist, -limit, limit);\n        z -= 2.0*n*fdist;\n    }\n}\n\nmat2 rot(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\n\nfloat smoothfloor(in float x, in float k)\n{\n    k = clamp(k, 0., 1.);\n    float xk = x+k*0.5;\n    return floor(xk)+smoothstep(0.,1.,smoothstep(0.,k,fract(xk)));\n}\n\nfloat map(vec3 p)\n{\n    p.yz *= rot(an);\n    p.xz *= rot(an);\n    \n    float an1 = sin(an*1.1*2.)*.2;\n    float an2 = sin(an*1.4*2. + 1.)*3.;\n    float an3 = cos(an*2.1*2.)*4.;\n    \n    float fixed_radius2 = 15.;\n\tfloat min_radius2 = 0.;\n\tfloat folding_limit = 8. + an2*.2;\n\tfloat scale = -1.85 + an1;\n\tfloat octsize = 8. + an3;\n    \n    vec3 c = p;\n    float ds = 1.;\n    for(int n = 0; n < 18; ++n) \n    {\n        octfold(p, octsize, folding_limit);\n        sphere_fold(p, ds, min_radius2, fixed_radius2);\n        p = scale*p + c;\n        ds = ds * abs(scale) + 1.;\n    }\n    return length(p)/abs(ds)*.8;\n}\n\nvec3 normal(const in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.04;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\nfloat shadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<18; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.2, 0.5);\n        if( h<0.0005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nfloat curvM(in vec3 p, in float w, vec3 n)\n{\n    float t1 = map(p + n*w*1.0), t2 = map(p - n*w*1.0);\n    float t3 = map(p + n*w*3.0), t4 = map(p - n*w*3.0);\n    float t5 = map(p + n*w*9.0), t6 = map(p - n*w*9.0);\n    float t0 = map(p);\n    return smoothstep(-.1, .9, (10.*(t1 + t2) + 1.*(t3 + t4) + 1.*(t5+t6) - 40.*t0))*3.0;\n}\n\nstruct mtl{float rough; vec3 alb; vec3 f0;};\nvec3 lgt = normalize( vec3(-.5, 0.3, -0.2) );\nvec3 lcol = vec3(1.,0.9,0.8);\n\nmat3 rot_x(float a){float sa = sin(a); float ca = cos(a); return mat3(1.,.0,.0,    .0,ca,sa,   .0,-sa,ca);}\nmat3 rot_y(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,.0,sa,    .0,1.,.0,   -sa,.0,ca);}\nmat3 rot_z(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,sa,.0,    -sa,ca,.0,  .0,.0,1.);}\n\n//http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\nvec3 shade(in vec3 pos, in vec3 rd)\n{\n    vec3 nor = normal(pos);\n    \t\n    mtl m; //Material\n    m.alb = vec3(0.25,0.4,0.8);\n    m.rough = 0.5;\n    m.f0 = vec3(.04);\n    m.alb *= rot_y(sin(an*0.2 + 3.5)*0.2);\n    \n\tfloat nl = clamp(dot(nor,lgt), 0., 1.);\n\tvec3 col = vec3(0.);\n    \n    if (nl > 0.)\n    {\n        nl *= shadow(pos, lgt, .8,15.)+0.0001;\n        vec3 haf = normalize(lgt - rd);\n        float nh = clamp(dot(nor, haf), 0., 1.); \n        float nv = clamp(dot(nor, -rd), 0., 1.);\n        float lh = clamp(dot(lgt, haf), 0., 1.);\n        float a = m.rough*m.rough;\n        float a2 = a*a;\n        float dnm = nh*nh*(a2 - 1.) + 1.;\n        float D = a2/(3.14159*dnm*dnm);\n        float k = pow(m.rough + 1., 2.)/8.; //hotness reducing\n\t\tfloat G = (1./(nl*(1. - k) + k))*(1./(nv*(1. - k) + k));\n        vec3 F = m.f0 + (1. - m.f0) * exp2((-5.55473*lh - 6.98316) * lh); //\"optimization\"\n        vec3 spec = nl*D*F*G;\n        col = lcol*nl*(spec + m.alb*(1. - m.f0));\t\t\n    }\n    col += 0.015*m.alb;\n    float crv = curvM(pos, .17,nor);\n    col *= sin(vec3(1.,1.9,2.9) + crv*.8 + an*1.5)*vec3(0.2,0.2,0.3) + vec3(0.9,0.8,0.55);\n    col *= crv;\n    return col;\n}\n\n//From eiffie: https://www.shadertoy.com/view/XsSXDt\nvec3 marchAA(in vec3 ro, in vec3 rd, in vec3 bgc, in float px, in mat3 cam)\n{\n    float precis = px*0.1;\n    float prb = precis;\n    float t=map(ro);\n\tvec3 col = vec3(0);\n\tfloat dm=100.0,tm=0.0,df=100.0,tf=0.0,od=1000.0,d=0.;\n\tfor(int i=0;i<ITR;i++)\n    {\n\t\td=map(ro+rd*t)*1.2;\n\t\tif(df==100.0)\n        {\n\t\t\tif(d>od)\n            {\n\t\t\t\tif(od<px*(t-od))\n                {\n\t\t\t\t\tdf=od;tf=t-od;\n                    t += .01; //step forward a bit when the first occluder is found\n\t\t\t\t}\n\t\t\t}\n\t\t\tod=d;\n\t\t}\n\t\tif(d<dm){tm=t;dm=d;}\n\t\tt+=d;\n\t\tif(t>FAR || d<precis)break;\n\t}\n\tcol=bgc;\n    \n\tif(dm<px*tm)\n        col=mix(shade((ro+rd*tm) - rd*(px*(tm-dm)) ,rd),col,clamp(dm/(px*tm),0.0,1.0));\n    \n\tfloat qq=0.0;\n\t\n    if((df==100.0 || tm==tf) && t < FAR)\n    {\n        ro+=cam*vec3(0.5,0.5,0.)*px*tm*1.;\n        tf=tm;\n        df=dm;\n        qq= .01;\n\t}\n    dfog = tm;\n    return mix(shade((ro+rd*tf) - rd*(px*tf-df),rd),col,clamp(qq+df/(px*tf),0.0,1.0));\n}\n\nvec3 bgt(in vec3 rd)\n{\n    float sun = clamp(dot(lgt,rd),0.0,1.0 );\n\tvec3 c2 = mix( vec3(0.8,.95,1.1), vec3(1.,.8,0.55), sun );\n    vec3 col = mix( vec3(0.2,0.6,.9), c2, exp(-(4.0+2.0*(1.0-sun))*max(0.0,rd.y-0.1)) );\n    col *= 0.6;\n\tcol += 0.8*vec3(1.0,0.8,0.7)*pow(sun,128.0);\n\tcol += 0.3*vec3(1.0,0.6,0.2)*pow(sun,32.0);\n    col += 0.1*vec3(1.0,0.6,0.2)*pow(sun,4.0);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    float px= 1./(iResolution.y*fov);\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = q - 0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(0.,-0.02):mo;\n\tmo.x *= iResolution.x/iResolution.y;\n    mo*=4.14;\n    mo.y *= 0.6;\n    mo.x += sin(iTime*0.2) + 2.5;\n\t\n    vec3 ro = vec3(12.,-0.0, 70. + sin(iTime*0.5 + .5)*10.);\n    vec3 rd = normalize(vec3(p,-fov));\n    \n    //an = smoothfloor((iTime + 20.)*FLIP_SPEED, FLIP_CURVE)*6.2831853*FLIP_REV;\n    an = smoothfloor((iTime + 6.)*FLIP_SPEED, FLIP_CURVE)*6.2831853*FLIP_REV;\n    \n    mat3 cam = rot_x(-mo.y)*rot_y(-mo.x);\n   \tro *= cam;\n\trd *= cam;\n    \n    vec3 bg = bgt(rd);\n    vec3 col = bg;\n    \n    col = marchAA(ro, rd, bg, px, cam);\n    col = clamp(col, 0.,1.);\n    col = mix(col, bg, smoothstep(70.,FAR, dfog)); //Distance fog\n    \n\tcol = pow(clamp(col,0.,1.), vec3(0.416667))*1.055 - 0.055; //sRGB\n\n    col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1)*0.7+0.3;\n    \n\tfragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlcfR8.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 351, 421, 421, 654], [656, 656, 712, 712, 1017], [1019, 1019, 1040, 1040, 1092], [1094, 1094, 1137, 1137, 1256], [1258, 1258, 1277, 1277, 1866], [1868, 1868, 1898, 1898, 2059], [2061, 2061, 2131, 2131, 2388], [2390, 2390, 2434, 2434, 2717], [2841, 2841, 2861, 2861, 2948], [2949, 2949, 2969, 2969, 3056], [3057, 3057, 3077, 3077, 3163], [3165, 3262, 3299, 3299, 4430], [4432, 4485, 4562, 4562, 5428], [5430, 5430, 5452, 5452, 5818], [5820, 5820, 5877, 5877, 6908]], "test": "error"}
{"id": "WlcfRS", "name": "Golden apollian", "author": "mrange", "description": "Licence CC0: Golden apollian\nMore late night coding\n", "tags": ["2d", "fractal", "apollian"], "likes": 43, "viewed": 606, "published": "Public API", "date": "1612911149", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Licence CC0: Golden apollian\n// More late night coding\n\n// -----------------------------------------------------------------------------\n// COMMON\n// -----------------------------------------------------------------------------\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PSIN(x)         (0.5+0.5*sin(x))\n#define LESS(a,b,c)     mix(a,b,step(0.,c))\n#define SABS(x,k)       LESS((.5/(k))*(x)*(x)+(k)*.5,abs(x),abs(x)-(k))\n#define L2(x)           dot(x, x)\n#define PLANE_PERIOD    5.0\n\nconst vec3 std_gamma   = vec3(2.2, 2.2, 2.2);\nconst vec3 planeCol    = vec3(1.0, 1.2, 1.5);\nconst vec3 baseRingCol = pow(vec3(1.0, 0.65, 0.25), vec3(0.6));\nconst vec3 sunCol      = vec3(1.25, 1.0, 1.1)/1.25;\n\nstruct effect {\n  float lw;\n  float tw;\n  float sk;\n  float cs;\n};\n\nconst effect effects[] = effect[](\n    effect(0.125, 0.0, 0.0, 0.0)\n  , effect(0.125, 0.0, 0.0, 1.0)\n  , effect(0.125, 0.0, 1.0, 1.0)\n  , effect(0.125, 1.0, 1.0, 1.0)\n  , effect(0.125, 1.0, 1.0, 0.0)\n  , effect(0.125, 1.0, 0.0, 0.0)\n  );\neffect current_effect = effects[5];\n\nfloat hash(float co) {\n  co += 100.0;\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\nfloat modMirror1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize,size) - halfsize;\n  p *= mod(c, 2.0)*2.0 - 1.0;\n  return c;\n}\n\nfloat smoothKaleidoscope(inout vec2 p, float sm, float rep) {\n  vec2 hp = p;\n  vec2 hpp = toPolar(hp);\n  float rn = modMirror1(hpp.y, TAU/rep);\n  float sa = PI/rep - SABS(PI/rep - abs(hpp.y), sm);\n  hpp.y = sign(hpp.y)*(sa);\n  hp = toRect(hpp);\n  p = hp;\n  return rn;\n}\n\nvec4 alphaBlend(vec4 back, vec4 front) {\n  float w = front.w + back.w*(1.0-front.w);\n  vec3 xyz = (front.xyz*front.w + back.xyz*back.w*(1.0-front.w))/w;\n  return w > 0.0 ? vec4(xyz, w) : vec4(0.0);\n}\n\nvec3 alphaBlend(vec3 back, vec4 front) {\n  return mix(back, front.xyz, front.w);\n}\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  \n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat hex(vec2 p, float r) {\n  const vec3 k = vec3(-sqrt(3.0)/2.0,1.0/2.0,sqrt(3.0)/3.0);\n  p = p.yx;\n  p = abs(p);\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  return length(p)*sign(p.y);\n}\n\nfloat apollian(vec4 p, float s) {\n  float scale = 1.0;\n  for(int i=0; i<7; ++i) {\n    p = -1.0 + 2.0*fract(0.5*p+0.5);\n    float r2 = dot(p,p);\n    float k  = s/r2;\n    p       *= k;\n    scale   *= k;\n  }\n\n  float lw = 0.00125*current_effect.lw;\n  \n  float d0 = abs(p.y)-lw*scale;\n  float d1 = abs(circle(p.xz, 0.005*scale))-lw*scale;\n  float d = d0;\n  d = mix(d, min(d, d1), current_effect.tw);\n  return (d/scale);\n}\n\n// -----------------------------------------------------------------------------\n// PATH\n// -----------------------------------------------------------------------------\n\n// The path function\nvec3 offset(float z) {\n  float a = z;\n  vec2 p = -0.075*(vec2(cos(a), sin(a*sqrt(2.0))) + vec2(cos(a*sqrt(0.75)), sin(a*sqrt(0.5))));\n  return vec3(p, z);\n}\n\n// The derivate of the path function\n//  Used to generate where we are looking\nvec3 doffset(float z) {\n  float eps = 0.1;\n  return 0.5*(offset(z + eps) - offset(z - eps))/eps;\n}\n\n// The second derivate of the path function\n//  Used to generate tilt\nvec3 ddoffset(float z) {\n  float eps = 0.1;\n  return 0.125*(doffset(z + eps) - doffset(z - eps))/eps;\n}\n\n// -----------------------------------------------------------------------------\n// PLANE MARCHER\n// -----------------------------------------------------------------------------\n\nfloat weird(vec2 p, float h) {\n  float z = 4.0;\n  float tm = 0.1*TIME+h*10.0;\n  p *= ROT(tm*0.5);\n  float r = 0.5;\n  vec4 off = vec4(r*PSIN(tm*sqrt(3.0)), r*PSIN(tm*sqrt(1.5)), r*PSIN(tm*sqrt(2.0)), 0.0);\n  vec4 pp = vec4(p.x, p.y, 0.0, 0.0)+off;\n  pp.w = 0.125*(1.0-tanh_approx(length(pp.xyz)));\n  pp.yz *= ROT(tm);\n  pp.xz *= ROT(tm*sqrt(0.5));\n  pp /= z;\n  float d = apollian(pp, 0.8+h);\n  return d*z;\n}\n\nfloat circles(vec2 p) {\n  vec2 pp = toPolar(p);\n  const float ss = 2.0;\n  pp.x = fract(pp.x/ss)*ss;\n  p = toRect(pp);\n  float d = circle(p, 1.0);\n  return d;\n}\n\nvec2 df(vec2 p, float h) {\n  vec2 wp = p;\n  float rep = 2.0*round(mix(5.0, 15.0, h*h));\n  float ss = 0.05*6.0/rep;\n\n  if (current_effect.sk > 0.0) {\n    smoothKaleidoscope(wp, ss, rep);\n  }\n  \n  float d0 = weird(wp, h);\n  float d1 = hex(p, 0.25)-0.1;\n  float d2 = circles(p);\n  const float lw = 0.0125;\n  d2 = abs(d2)-lw;\n  float d = d0;\n\n  if (current_effect.cs > 0.0) {\n    d  = pmin(d, d2, 0.1);\n  }\n\n  d  = pmin(d, abs(d1)-lw, 0.1);\n  d  = max(d, -(d1+lw));\n  return vec2(d, d1+lw);\n}\n\nvec2 df(vec3 p, vec3 off, float s, mat2 rot, float h) {\n  vec2 p2 = p.xy;\n  p2 -= off.xy;\n  p2 *= rot;\n  return df(p2/s, h)*s;\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  float ld = max(dot(rd, vec3(0.0, 0.0, 1.0)), 0.0);\n  return 1.0*sunCol*tanh_approx(3.0*pow(ld, 100.0));\n}\n\nvec4 plane(vec3 ro, vec3 rd, vec3 pp, float pd, vec3 off, float aa, float n) {\n  int pi = int(mod(n/PLANE_PERIOD, float(effects.length())));\n  current_effect = effects[pi];\n  \n  float h = hash(n);\n  float s = 0.25*mix(0.5, 0.25, h);\n  const float lw = 0.0235;\n  const float lh = 1.25;\n\n  const vec3 nor  = vec3(0.0, 0.0, -1.0);\n  const vec3 loff = 2.0*vec3(0.25*0.5, 0.125*0.5, -0.125);\n  vec3 lp1  = ro + loff;\n  vec3 lp2  = ro + loff*vec3(-2.0, 1.0, 1.0);\n\n  vec2 p = pp.xy-off.xy;\n\n  mat2 rot = ROT(TAU*h);\n\n  vec2 d2 = df(pp, off, s, rot, h);\n\n  vec3 ld1   = normalize(lp1 - pp);\n  vec3 ld2   = normalize(lp2 - pp);\n  float dif1 = pow(max(dot(nor, ld1), 0.0), 5.0);\n  float dif2 = pow(max(dot(nor, ld2), 0.0), 5.0);\n  vec3 ref   = reflect(rd, nor);\n  float spe1= pow(max(dot(ref, ld1), 0.0), 30.0);\n  float spe2= pow(max(dot(ref, ld2), 0.0), 30.0);\n\n  const float boff = 0.0125*0.5;\n  float dbt = boff/rd.z;\n  \n  vec3 bpp = ro + (pd + dbt)*rd;\n  vec2 bp = bpp.xy - off.xy;\n\n  vec3 srd1 = normalize(lp1-bpp);\n  vec3 srd2 = normalize(lp2-bpp);\n  float bl21= L2(lp1-bpp);\n  float bl22= L2(lp2-bpp);\n\n  float st1 = -boff/srd1.z;\n  float st2 = -boff/srd2.z;\n\n  vec3 spp1 = bpp + st1*srd1;\n  vec3 spp2 = bpp + st2*srd2;\n  \n  vec2 bd  = df(bpp, off, s, rot, h);\n  vec2 sd1 = df(spp1, off, s, rot, h);\n  vec2 sd2 = df(spp2, off, s, rot, h);\n\n  vec3 col  = vec3(0.0);\n  const float ss = 200.0;\n\n  col       += 0.1125*planeCol*dif1*(1.0-exp(-ss*(max((sd1.x), 0.0))))/bl21;\n  col       += 0.1125*planeCol*dif2*0.5*(1.0-exp(-ss*(max((sd2.x), 0.0))))/bl22;\n  \n  vec3 ringCol = baseRingCol;\n  ringCol *= vec3(clamp(0.1+2.5*(0.1+0.25*((dif1*dif1/bl21+dif2*dif2/bl22))), 0.0, 1.0));\n  ringCol += sqrt(baseRingCol)*spe1*2.0;\n  ringCol += sqrt(baseRingCol)*spe2*2.0;\n  col       = mix(col, ringCol, smoothstep(-aa, aa, -d2.x));  \n\n  float ha = smoothstep(-aa, aa, bd.y);\n\n  return vec4(col, mix(0.0, 1.0, ha));\n}\n\nvec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p) {\n  float lp = length(p);\n  vec2 np = p + 1.0/RESOLUTION.xy;\n  float rdd = (2.0-0.5*tanh_approx(lp));  // Playing around with rdd can give interesting distortions\n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n  vec3 nrd = normalize(np.x*uu + np.y*vv + rdd*ww);\n\n  const float planeDist = 1.0-0.75;\n  const int furthest = 9;\n  const int fadeFrom = max(furthest-4, 0);\n  const float fadeDist = planeDist*float(furthest - fadeFrom);\n  float nz = floor(ro.z / planeDist);\n\n  vec3 skyCol = skyColor(ro, rd);\n\n  // Steps from nearest to furthest plane and accumulates the color\n\n  vec4 acol = vec4(0.0);\n  const float cutOff = 0.95;\n  bool cutOut = false;\n  \n  for (int i = 1; i <= furthest; ++i) {\n    float pz = planeDist*nz + planeDist*float(i);\n\n    float pd = (pz - ro.z)/rd.z;\n\n    if (pd > 0.0 && acol.w < cutOff) {\n      vec3 pp = ro + rd*pd;\n      vec3 npp = ro + nrd*pd;\n\n      float aa = 3.0*length(pp - npp);\n\n      vec3 off = offset(pp.z);\n\n      vec4 pcol = plane(ro, rd, pp, pd, off, aa, nz+float(i));\n\n      float nz = pp.z-ro.z;\n      float fadeIn = exp(-2.5*max((nz - planeDist*float(fadeFrom))/fadeDist, 0.0));\n      float fadeOut = smoothstep(0.0, planeDist*0.1, nz);\n      pcol.xyz = mix(skyCol, pcol.xyz, (fadeIn));\n      pcol.w *= fadeOut;\n\n      pcol = clamp(pcol, 0.0, 1.0);\n\n      acol = alphaBlend(pcol, acol);\n    } else {\n      cutOut = true;\n      break;\n    }\n\n  }\n\n  vec3 col = alphaBlend(skyCol, acol);\n// To debug cutouts due to transparency  \n//  col += cutOut ? vec3(1.0, -1.0, 0.0) : vec3(0.0);\n  return col;\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, 1.0/std_gamma);\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvec3 color(vec2 p, vec2 q) {\n  float tm  = TIME*0.125;\n  vec3 ro   = offset(tm);\n  vec3 dro  = doffset(tm);\n  vec3 ddro = ddoffset(tm);\n\n  vec3 ww = normalize(dro);\n  vec3 uu = normalize(cross(normalize(vec3(0.0,1.0,0.0)+ddro), ww));\n  vec3 vv = normalize(cross(ww, uu));\n\n  vec3 col = color(ww, uu, vv, ro, p);\n  col = clamp(col, 0.0, 1.0);\n  col *= smoothstep(0.0, 5.0, TIME);\n  col = postProcess(col, q);\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = color(p, q);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlcfRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 1201, 1223, 1223, 1286], [1288, 1288, 1310, 1310, 1354], [1356, 1356, 1377, 1377, 1422], [1424, 1424, 1469, 1469, 1623], [1625, 1625, 1686, 1686, 1894], [1896, 1896, 1936, 1936, 2095], [2097, 2097, 2137, 2137, 2179], [2181, 2181, 2209, 2229, 2305], [2307, 2307, 2346, 2346, 2434], [2436, 2436, 2467, 2467, 2493], [2495, 2495, 2523, 2523, 2723], [2725, 2725, 2758, 2758, 3142], [3315, 3336, 3358, 3358, 3492], [3494, 3573, 3596, 3596, 3671], [3673, 3743, 3767, 3767, 3846], [3848, 4028, 4058, 4058, 4434], [4436, 4436, 4459, 4459, 4595], [4597, 4597, 4623, 4623, 5085], [5087, 5087, 5142, 5142, 5215], [5217, 5217, 5250, 5250, 5358], [5360, 5360, 5438, 5438, 7258], [7260, 7260, 7316, 7316, 8859], [8861, 8861, 8897, 8897, 9130], [9132, 9132, 9160, 9160, 9556], [9558, 9558, 9613, 9613, 9769]], "test": "error"}
{"id": "WlcfWf", "name": "Exercise: Basic Truchet Tiling", "author": "endymion", "description": "Big props to *BigWIngs* for their instructional videos: https://www.youtube.com/watch?v=2R7h76GoIJM", "tags": ["truchet", "tiling"], "likes": 1, "viewed": 44, "published": "Public", "date": "1613549838", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n * Pseudo-random with 2d vector input\n * @src https://thebookofshaders.com/10/\n * @param coordinate {vec2}\n * @return {float}\n */\nfloat random(vec2 coordinate) {\n    return fract(\n        sin(dot(\n            coordinate,\n            vec2(12.9898, 78.233)\n        )) \n    * 43758.5453123);\n}\n\n/**\n * @main\n * @src https://www.youtube.com/watch?v=2R7h76GoIJM\n */\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Zoom;\n    float scale = 25. + 24. * sin(iTime);\n    uv *= scale; \n    \n    // Tiles from -.5 to .5\n    vec2 gv = fract(uv) - .5;\n    \n    // Rotate\n    vec2 id = floor(uv);\n    float r = random(id);\n    if (r < .5) gv.x *= -1.;\n    \n    // Curves\n    float sgn = sign(gv.x + gv.y);\n    sgn = sgn == 0. ? 1. : sgn;\n    float dist = abs(abs(gv.x + gv.y) - .5);\n    dist = length(gv - sgn * .5) - .5;\n    float width = 0.002 * scale;\n    dist = smoothstep(scale/iResolution.y, -scale/iResolution.y, abs(dist) - width);\n    \n    // Color\n    vec3 col = vec3(0);\n    col += dist;\n    \n    // Tile border\n    //if (gv.x > .48 || gv.y > .48) col.r = 1;\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlcfWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 134, 165, 165, 294], [296, 365, 420, 420, 1185]], "test": "valid"}
{"id": "wlcfWn", "name": "CIE Lab visualizer", "author": "pacaro", "description": "Animates through the CIE Lab colorspace, varying l with time", "tags": ["lab", "colorspace", "cie"], "likes": 3, "viewed": 69, "published": "Public", "date": "1612501337", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec4 kLight = vec4(0.75, 0.75, 0.75, 1.0);\nconst vec4 kDark = vec4(0.5, 0.5, 0.5, 1.0);\n\nvec4 checkerBoard(in vec2 fragCoord) {\n    return (int(fragCoord.x / 16.0) + int(fragCoord.y / 16.0)) % 2 == 1 ? kLight : kDark;\n}\n\nconst vec3 kD65 = vec3(95.047, 100.00, 108.883);\n\nfloat xyzF(in float t) {\n  const float kThreshold = 6.0 / 29.0;\n  const float kFactor = 3.0 * pow(6.0 / 29.0, 2.0);\n  const float kConstant = 4.0 / 29.0;\n \n  return t > kThreshold ? pow(t, 3.0) : kFactor * (t - kConstant);\n}\n\nfloat gamma(in float c) {\n  return c < 0.0031308 ? 12.92 * c : 1.055 * pow(c, 1.0 / 2.4) - 0.055;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float xCenter = iResolution.x / 2.0;\n    float yCenter = iResolution.y / 2.0;\n    float scale = 110.0 / (min(iResolution.x, iResolution.y) / 2.0);\n    \n    float a = scale * (fragCoord.x - xCenter);\n    float b = scale * (fragCoord.y - yCenter);\n    \n    if (a < -100.0 || a > 100.0 || b < -100.0 || b > 100.0) {\n      fragColor = checkerBoard(fragCoord);\n    } else {\n      // animate l\n      float l = sin(iTime / 2.0) * 50.0 + 50.0;\n      // mouse control of l\n      // float l = clamp(100.0 * iMouse.y / iResolution.y, 0.0, 100.0);\n      \n      float lf = (l + 16.0) / 116.0;\n  \n      vec3 colorXyz = vec3(\n          kD65.x * xyzF(lf + a / 500.0),\n          kD65.y * xyzF(lf),\n          kD65.z * xyzF(lf - b / 200.0));\n      \n      float r = gamma(( 3.2406 * colorXyz.x - 1.5372 * colorXyz.y - 0.4986 * colorXyz.z) / 100.0);\n      float g = gamma((-0.9689 * colorXyz.x + 1.8758 * colorXyz.y + 0.0415 * colorXyz.z) / 100.0);\n      float b = gamma(( 0.0557 * colorXyz.x - 0.2040 * colorXyz.y + 1.0570 * colorXyz.z) / 100.0);\n      \n      if (r < 0.0 || r > 1.0 || g < 0.0 || g >= 1.0 || b < 0.0 || b >= 1.0) {\n          fragColor = checkerBoard(fragCoord);\n      } else {\n          fragColor = vec4(r, g, b, 1.0);\n      }\n    }    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlcfWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[95, 95, 133, 133, 225], [277, 277, 301, 301, 501], [503, 503, 528, 528, 602], [605, 605, 662, 662, 1902]], "test": "valid"}
{"id": "Wlcfz4", "name": "Golden Triangle Zoom", "author": "fizzer", "description": "Another 'infinite' zoom, similar to my previous [url=https://www.shadertoy.com/view/WlcSD8]Golden Section Zoom[/url] shader. This one is based on the golden isosceles triangle, which has inner angles in ratio 1:2:2 and sides in ratio φ:φ:1.", "tags": ["zoom", "phi", "infinite", "goldenratio"], "likes": 12, "viewed": 121, "published": "Public", "date": "1612379513", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// https://en.wikipedia.org/wiki/Golden_triangle_(mathematics)\n\nconst float pi = 3.14159265358979323;\nconst float phi = (sqrt(5.) + 1.) / 2.;\nconst float th = pi * 2. / 5.;\n\nvec2 cMul(vec2 a, vec2 b)\n{\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvec2 cDiv( vec2 a, vec2 b)\n{\n    return cMul(a, vec2(b.x, -b.y)) / dot(b, b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy *.5) / iResolution.y * 40.;\n\n    float t = iTime + texelFetch(iChannel0, ivec2(fragCoord.xy) & 1023, 0).r / 60.;\n    \n    vec3 col = vec3(0);\n\n    // Represent the following transformation with complex numbers:\n    // mat3(rot(pi - th)) * mat3(vec3(phi, 0, 0), vec3(0, phi, 0), vec3(vec2(-cos(th), sin(th)), 1.)); \n    vec2 c0 = vec2(cos(pi - th), sin(pi - th)) * phi;\n    vec2 c1 = vec2(cos(th), -sin(th)) / phi;\n    \n    // Solve (z - c1) * c0 - z = 0 to find the fixed point of the transformation.\n    vec2 zc = cDiv(cMul(c1, c0), c0 - vec2(1, 0));\n    \n    uv += vec2(cos(t / 3.), sin(t / 2.)) * 8.;\n    \n    float a = t;\n    mat2 m = mat2(cos(a), sin(a), -sin(a), cos(a));\n    \n    // Exponential scaling transform, for a seamless (self-similar) zooming animation.\n    uv = m * uv * pow(pow(phi - 1., 10.), 1. + fract(t / 3.)) + zc;\n    \n    vec2 z = uv;\n    \n    float j = 0.;\n    \n    for(int i = 0; i < 32; ++i)\n    {\n        if(dot(z, vec2(sin(th), cos(th))) > 0.)\n        {\n            j = float(i) + floor(t / 3.) * 10.;\n            break;\n        }\n        z = cMul(z - c1, c0);\n    }\n\n    col = sin(vec3(j, j * 2., j * 3.)) * .5 + .5;\n\n    fragColor = vec4(sqrt(col), 1.0);\n}", "image_inputs": [{"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wlcfz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 174, 201, 201, 266], [268, 268, 296, 296, 347], [349, 349, 406, 406, 1637]], "test": "error"}
{"id": "WlcfzH", "name": "Neural human 3d", "author": "iuryBorgesRodrigues", "description": "Neural human 3d", "tags": ["neural", "humam"], "likes": 6, "viewed": 165, "published": "Public", "date": "1612195601", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//like the last few shaders I've published, this is a neural network experiment.\n//this time, the neural network reproduces an SDF given the x,y,z coordinates\n//using siren networks with skip connections: https://vsitzmann.github.io/siren/\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat scene(vec3 p) {\n    //sdf is undefined outside the unit sphere, uncomment to witness the abominations\n    if (length(p) > 1.) {\n        return length(p)-.9;\n    }\n    \n    //neural networks can be really compact... when they want to be\n    vec4 f0_0=sin(p.y*vec4(2.057,-2.118,-3.094,2.111)+p.z*vec4(-2.209,1.484,1.337,-3.312)+p.x*vec4(-4.227,1.529,-2.733,-1.672)+vec4(-8.017,1.715,.814,4.908));\nvec4 f0_1=sin(p.y*vec4(-1.590,-2.353,1.392,1.726)+p.z*vec4(-3.486,-1.055,-2.756,.048)+p.x*vec4(-2.446,-2.044,.194,-2.526)+vec4(-8.674,7.417,7.120,1.235));\nvec4 f0_2=sin(p.y*vec4(-2.957,.489,-1.138,-2.165)+p.z*vec4(2.529,-1.467,-2.774,3.574)+p.x*vec4(2.126,2.909,1.262,-2.823)+vec4(-7.604,-7.397,6.981,4.360));\nvec4 f0_3=sin(p.y*vec4(2.796,3.212,-1.945,3.542)+p.z*vec4(-.590,.789,-.475,-3.595)+p.x*vec4(.906,-.806,-.280,-3.517)+vec4(-2.332,2.753,-4.574,-1.273));\nvec4 f1_0=sin(mat4(.399,-.163,.484,.010,-.005,.277,.241,-.590,-.117,.343,-.637,.038,.070,-.190,-.619,-.123)*f0_0+\n    mat4(.194,.145,-.249,.356,.261,.484,.094,-.510,-.810,.079,-.769,1.155,-.186,.491,.622,.220)*f0_1+\n    mat4(-.123,.054,-.046,-.087,.280,.060,.238,.024,.681,-.346,.799,.180,-.045,.038,-.425,-.408)*f0_2+\n    mat4(-.170,-.073,-.869,-.980,-.340,.647,-.007,.668,.131,-.717,-.179,-.278,.292,-.003,-.052,-.141)*f0_3+\n    vec4(1.340,-.908,2.484,-1.047))/1.0+f0_0;\nvec4 f1_1=sin(mat4(-.491,-.310,.285,-.771,.161,-.809,-.445,-.236,-.503,-.303,-.502,-.670,-.170,-.322,-.405,-.089)*f0_0+\n    mat4(-.206,-.081,-.575,-.080,.621,-.635,.394,-.085,1.414,-.603,-.595,-.401,-.094,-.382,-.441,-.241)*f0_1+\n    mat4(.040,-.110,.694,.071,.329,-.269,-.148,.365,.771,-.784,.932,-.435,-.079,-.039,.255,-.197)*f0_2+\n    mat4(.569,-.044,.065,-.339,.241,.005,-.266,-.350,.596,-.816,-1.244,-.138,-.042,.029,-.084,.061)*f0_3+\n    vec4(3.492,-1.592,-3.910,-3.144))/1.0+f0_1;\nvec4 f1_2=sin(mat4(.437,.170,.087,-.622,.564,.469,-.338,.212,.465,.312,.495,.518,1.220,-.354,-.390,-.010)*f0_0+\n    mat4(-1.219,-.096,-.347,.394,-.592,.496,.411,.774,.325,.287,.516,-.245,.688,.420,-.281,.351)*f0_1+\n    mat4(-.188,.080,-.285,.094,-.324,-.140,-.083,-.801,.301,-.220,1.100,-.188,.729,.489,.095,-.209)*f0_2+\n    mat4(-.798,-.085,.525,.092,-.435,.202,-.048,-.521,.564,-.023,.701,.449,-.416,.024,.132,-.007)*f0_3+\n    vec4(1.176,2.539,-.878,2.372))/1.0+f0_2;\nvec4 f1_3=sin(mat4(-.006,-.649,-.079,-.097,-.052,-.168,-.030,.235,-.600,-.489,-.703,.122,.738,.085,.355,.125)*f0_0+\n    mat4(.635,-.490,.109,-.291,.127,.060,.160,-.253,.474,.442,-.055,.556,.353,-.115,-.171,.288)*f0_1+\n    mat4(-.544,-.435,-.455,-.200,.278,.273,.853,.675,-.974,-.046,.182,.035,-.238,.557,.003,.454)*f0_2+\n    mat4(.770,.539,.029,.025,-.733,.085,.009,.006,.867,.396,-.604,-.334,.178,1.159,.080,-.226)*f0_3+\n    vec4(.482,-.570,1.079,3.577))/1.0+f0_3;\nvec4 f2_0=sin(mat4(.296,.359,-1.390,-.018,-.508,-.728,-2.673,1.130,.033,-.251,-.933,-.538,-.648,.282,-1.108,-.730)*f1_0+\n    mat4(.234,-.231,-.865,-.171,.324,-.522,.093,.303,-.287,-.741,.576,-.022,-.659,-.110,.064,-.420)*f1_1+\n    mat4(.544,-.584,.750,.597,-.067,.375,-1.151,.461,-.229,.002,-.011,-.305,.057,-.471,.271,-.706)*f1_2+\n    mat4(-.818,-.359,.207,.711,.093,.603,-.301,.187,.112,-.188,-.568,1.188,.183,.145,.325,.097)*f1_3+\n    vec4(-1.898,-2.423,3.352,3.075))/1.4+f1_0;\nvec4 f2_1=sin(mat4(-1.133,-.241,.444,-.863,-.693,-.534,-.046,.292,-.047,-.107,-.710,-.109,-.369,-.028,.519,.208)*f1_0+\n    mat4(-.443,-.437,-.420,-.412,.169,.604,.515,.086,.677,.249,-.126,.465,.416,.188,.019,.898)*f1_1+\n    mat4(-.359,.222,-.465,-.316,-.118,-.434,.308,.439,-.596,.318,.555,-.721,-.229,.133,-.367,.465)*f1_2+\n    mat4(.236,.557,.885,-.145,-.813,.153,.460,.432,.921,.160,-.260,-.508,.007,-.488,-.125,.023)*f1_3+\n    vec4(-2.122,-1.079,1.690,.545))/1.4+f1_1;\nvec4 f2_2=sin(mat4(-.590,.116,.008,.383,.691,-.787,-.551,-.133,-.124,-.315,-.360,.444,.136,.403,-.120,1.350)*f1_0+\n    mat4(.212,.204,-.806,-.413,1.343,.148,.449,-.241,.168,.066,-.084,-.515,-.136,.471,.576,.465)*f1_1+\n    mat4(-.171,.084,-.722,.080,.085,.567,.513,.085,.320,-.212,-.593,-.403,.478,.682,.200,-.082)*f1_2+\n    mat4(.622,-.019,-.949,.167,.382,-.174,-.017,-.041,.234,-.739,-.327,.200,-.074,.076,.437,.044)*f1_3+\n    vec4(-1.055,.376,-2.075,2.178))/1.4+f1_2;\nvec4 f2_3=sin(mat4(-1.025,-.739,-.826,-.406,.815,1.078,-.042,-.302,-.173,.038,-.105,-.219,.364,.260,.547,.331)*f1_0+\n    mat4(.496,.624,-.611,.839,.298,.038,-.625,-.311,.448,-.508,.302,.240,-.485,.367,.016,.519)*f1_1+\n    mat4(-.190,-.918,-.224,-.139,.443,.027,-.638,-.199,-.140,-.536,.205,-.121,.688,.679,.477,.167)*f1_2+\n    mat4(-.568,.227,-.550,.147,-.524,-.495,.042,.264,-1.729,-.024,-1.016,-.479,.741,1.574,.613,.063)*f1_3+\n    vec4(-3.090,.562,-2.917,1.186))/1.4+f1_3;\nreturn dot(f2_0,vec4(.077,-.050,.041,-.048))+\n    dot(f2_1,vec4(-.037,-.077,.057,-.056))+\n    dot(f2_2,vec4(-.036,.042,.060,-.026))+\n    dot(f2_3,vec4(.060,.026,.081,-.080))+\n    0.236;\n\n\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 cam = normalize(vec3(1.5,uv));\n    vec3 init = vec3(-3.,0,0);\n    \n    float yrot = 0.5;\n    float zrot = iTime*.2;\n    if (iMouse.z > 0.) {\n        yrot += -4.*mouse.y;\n        zrot = 4.*mouse.x;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n    \n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 150 && !hit; i++) {\n        float dist = scene(p/vec3(1.0))-0.02;\n        hit = dist*dist < 1e-6;\n        p+=dist*cam;\n        if (distance(p,init)>5.) break;\n    }\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    //don't ask how I stumbled on this texture\n    vec3 nz = p - erot(p, vec3(1), 2.) + erot(p, vec3(1), 4.);\n    float spec = length(sin(r*3.5+sin(nz*120.)*.15)*.4+.6)/sqrt(3.);\n    spec *= smoothstep(-.3,.2,scene(p+r*.2));\n    vec3 col = vec3(.1,.1,.12)*spec + pow(spec,8.);\n    float bgdot = length(sin(cam*8.)*.4+.6)/2.;\n    vec3 bg = vec3(.1,.1,.11) * bgdot + pow(bgdot, 10.);\n    fragColor.xyz = hit ? col : bg;\n    fragColor = smoothstep(-.02,1.05,sqrt(fragColor)) * (1.- dot(uv,uv)*.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlcfzH.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[194, 435, 473, 473, 535], [537, 537, 558, 644, 5386], [5388, 5388, 5407, 5407, 5523], [5525, 5525, 5582, 5582, 6865]], "test": "valid"}
{"id": "WldBD4", "name": "Ball rows", "author": "DukeOfStraylight", "description": "Reproduction of a random gif seen on a random Discord: https://cdn.discordapp.com/attachments/553619379540066304/795702582252404767/straightdownup-1.gif ... with a bit of added randomness.", "tags": ["hex"], "likes": 3, "viewed": 151, "published": "Public API", "date": "1612756274", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float headingchaos = 0.01;\nconst float directionchaos = 0.1;\n\nvec2 hex = vec2(sqrt(3.), 1.).yx;\n\n// HexDist and HexCoords from The Art of Code: https://www.youtube.com/watch?v=VmrIDyYiJBA\nfloat HexDist(vec2 p) {\n  p = abs(p);\n  float c = dot(p, normalize(hex));\n  return max(c, p.x);\n}\n\nstruct HexCoord {\n  vec2 gv;\n  vec2 id;\n};\n\nHexCoord HexCoords(vec2 uv) {\n  vec2 r = hex;\n  vec2 h = r*.5;\n    \n  vec2 a = mod(uv, r)-h;\n  vec2 b = mod(uv-h, r)-h;\n    \n  vec2 gv = dot(a, a) < dot(b,b) ? a : b;\n    \n  vec2 id = uv-gv;\n  return HexCoord(gv, id);\n}\n\nfloat hash11(in float x) {\n    return fract(sin(x)*1e4);\n}\n\nvec2 rotate90(vec2 p) {\n  return vec2(p.y, -p.x);\n}\n\nconst float pi = 3.14159;\n\nfloat circledistance(float time, HexCoord hexcoord, vec2 hexdir) {\n  float second = floor(time);\n  float ind = fract(second*0.5)*2.0;\n  float sign = round(max(0.0, hash11(second) - (1.0 - directionchaos))); // 0 or 1\n\n  float slope = cos(time * pi) * 0.5 + 0.5;\n  float up = ind*slope + (1.0-ind)*(1.0-slope);\n\n  float parity = round(fract(dot(rotate90(hexdir), hexcoord.id - 0.5) * sqrt(3.0)));\n  sign = sign == parity ? 0.0 : 1.0; // a bit of a silly way to do xor, but these both came out of round() so equality does work\n  float t = sign * up + (1.0 - sign) * (1.0 - up);\n  \n  return min(length(hexcoord.gv + t * hexdir),\n\t     length(hexcoord.gv + (t - 1.0) * hexdir));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 st = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n\n  st *= 10.;\n\n  HexCoord hex_coord = HexCoords(st);\n  vec2 xy = hex_coord.gv;\n\n  float time = iTime * 1.5;\n  float second = floor(time );\n  float regularheading = mod(second, 3.0);\n  float randomheading = floor(hash11(second + 543.) * 3.0 + 0.5);\n  float heading = hash11(second + 47.) < headingchaos ? randomheading : regularheading;\n  \n  vec2 hexdir1 = vec2(1.0, 0.0);\n  vec2 hexdir2 = normalize(hex);\n  vec2 hexdir3 = normalize(hexdir2 - hexdir1);\n\n  vec2 hexdir = heading == 0.0 ? hexdir1 : heading == 1.0 ? hexdir2 : hexdir3;\n\n  float c = smoothstep(0.22, 0.19, circledistance(time, hex_coord, hexdir));\n  \n  fragColor =\n    vec4(c,\n\t c,\n\t c,\n     1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WldBD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 194, 217, 217, 291], [337, 337, 366, 366, 556], [558, 558, 584, 584, 616], [618, 618, 641, 641, 669], [698, 698, 764, 764, 1374], [1376, 1376, 1433, 1433, 2155]], "test": "valid"}
{"id": "wldBDN", "name": "Moiré 3b2", "author": "FabriceNeyret2", "description": "coloring [url]https://shadertoy.com/view/3ldBzM[/url]", "tags": ["aliasing", "interference", "moir", "reproduction"], "likes": 7, "viewed": 193, "published": "Public API", "date": "1612799649", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// color variant of https://shadertoy.com/view/3ldBzM\n\n#define D   length( mod( U += T/2. , T ) - R )               //\n#define P   clamp( 1.- ( min( D, D ) -.8*R.y )/5. ,0.,1.)    // draw an hexa tiling of disks\n\nvoid mainImage(out vec4 O, vec2 U) {\n    U *= 3.;\n    vec2 R = vec2(360)/8., T = vec2( 2, 3.5 )*R;\n    float v = P;\n\n    U = 1.1*U.yx + 10.*iTime;\n    v += P;\n    \n    O =  ( .6 + .6 * cos( 6.3*v/3.  + vec4(0,23,21,0)  ) );  // hue: https://www.shadertoy.com/view/ll2cDc\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wldBDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 213, 249, 249, 485]], "test": "valid"}
{"id": "wldBR2", "name": "Fractal 22_gaz", "author": "gaz", "description": "3d", "tags": ["fractal"], "likes": 15, "viewed": 154, "published": "Public", "date": "1613105648", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)cos(h*6.3+vec3(0,23,21))*.5+.5\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 r=iResolution,p;  \n    for(float i=0.,g,e,s;\n        ++i<99.;\n        (e<.005)?O.xyz+=mix(r/r,H(g*.5),.6)*.05*exp(-g*10.):p\n    )\n    {\n        p=g*vec3((C-.5*r.xy)/r.y,1);\n        p-=vec3(.02,.01,.08);\n        p=R(p,normalize(vec3(1,3,3)),iTime*.2);\n        p+=p;\n        s=2.;\n        for(int j=0;++j<7;)\n            s*=e=1.8/min(dot(p,p),1.2),\n            p=abs(p)*e-3.;\n        g+=e=length(p.yz)/s;\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wldBR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 102, 138, 138, 573]], "test": "valid"}
{"id": "WldBW2", "name": "Soul creature", "author": "kosmaks", "description": "Experiments with trying to create visuals from movie Soul. First time implementing fog effects, animation, futuristic grass and using aces film filter for color grading.\n\n(it looks nothing like soul, but still pretty cool imo :)\n\ngh: kosmaks", "tags": ["raytracing", "gi", "raymarcher", "render", "soul"], "likes": 20, "viewed": 320, "published": "Public API", "date": "1613681589", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_COUNT (150)\n#define MIN_DIST (0.001)\n#define MAX_DIST (3.)\n\n#define SOUL_SIZE (0.2)\n\n#define M_SOUL_BODY 1\n#define C_SOUL_BODY (vec3(0.24, 0.97, 0.37) + 0.2)\n#define M_SOUL_EYE 2\n#define C_SOUL_EYE (vec3(1.))\n#define M_SOUL_EYEBALL 3\n#define C_SOUL_EYEBALL (vec3(0.1))\n#define M_SOUL_EYEBROW 4\n#define C_SOUL_EYEBROW (vec3(0.2, 0.4, 0.4))\n#define M_SOUL_CHEEK 5\n#define C_SOUL_CHEEK (vec3(0.74, 0.57, 0.17))\n#define M_TREE 6\n#define C_TREE (vec3(0.6, 0.2, 0.6) * 0.9)\n\n#define M_TERRAIN 10\n#define C_TERRAIN (vec3(0.1, 0.6, 1.7))\n#define M_GRASS 11\n#define C_GRASS1 (vec3(1.24, 4.97, 3.37))\n#define C_GRASS (vec3(3.9, 0.37, 3.9))\n\n#define C_SKY_UP (vec3(0.29, 0.44, 1.56))\n#define C_SKY_DOWN (vec3(4.5, 0.94, 4.57))\n\nstruct M {\n    vec3 emission;\n    vec3 diffuse;\n};\n\nfloat noise(in vec2 uv) {\n    return fract(sin(uv.x * 1233.52 + uv.y * 99.23423) * 324.234);\n}\n\nfloat noiseSmooth(in vec2 uv) {\n    vec2 uvs = floor(uv);\n    vec2 d = fract(uv);\n    vec2 s = vec2(1., 0.);\n    float tl = noise(uvs);\n    float tr = noise(uvs + s.xy);\n    float bl = noise(uvs + s.yx);\n    float br = noise(uvs + s.xx);\n    float top = mix(tl, tr, d.x);\n    float bottom = mix(bl, br, d.x);\n    float mx = mix(top, bottom, d.y);\n    return max(0., mx);\n}\n\nfloat rayPlane(vec3 ro, vec3 rd, vec3 n, float d) {\n    float denom = dot(n, rd);\n    if (abs(denom) > 1e-6) {\n        return dot(n*d - ro, n) / denom;\n    }\n    return -1.;\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0., 1.);\n}\n\nfloat getSoulCurve(in float time) {\n    return cos(time) * 0.5 + 0.5;\n}\n\nfloat sdSoulHead(in vec3 p, in float size, in float curve) {\n    float d;\n    vec3 mir = p * vec3(sign(p.x), 1., 1.);\n\n    float lowSphere = length((p) * vec3(1., 1.7, 1.) - vec3(0., -0.5, 0.) * size) - size;\n    float hiSphere = length(p * vec3(1., 1.5, 1.) - vec3(0., 0.3, 0.) * size) - size * 0.9;\n    float head = smin(lowSphere, hiSphere, 0.5 * size);\n    d = head;\n    \n    float eye = length(mir - vec3(0.7, 0.15, -1.2) * size) - size * 0.33;\n    d = smax(d, -eye, 0.4 * size);\n    \n    return d;\n}\n\n#define SEPOS (vec3(0.4, 0.05, -0.65))\nfloat sdSoulEye(in vec3 p, in float size) {\n    vec3 mir = p * vec3(sign(p.x), 1., 1.);\n    return length(mir - vec3(0.4, 0.05, -0.65) * size) - size * 0.2;\n}\n\nfloat sdSoulEyebrow(in vec3 p, in float size, in float curve) {\n    float jump = max(0., curve - 0.6);\n    vec3 mir = p * vec3(sign(p.x), 1., 1.);\n    return length((mir - vec3(0.4, 0.4 + jump * 1. * size, -.55) * size) * vec3(1., 5., 1.) ) - size * 0.2;\n}\n\nfloat sdSoulMouth(in vec3 p, in float size, in float curve) {\n    return length((p - vec3(0., -0.3 + p.x*p.x*20., -0.9) * size) * vec3(1.2, mix(9., 3., curve), 1.)) - size * 0.2;\n}\n\nfloat sdBody(in vec3 p, in float size, in float curve) {\n    p -= vec3(0., -1.4, 0.) * size;\n    \n    float spread = min(0., -cos((p.y / size) * 2.)) * mix(0.4, 0., curve) + 1.;\n    float shrink = mix(1.4, 1., curve);\n    p *= vec3(spread, shrink, spread);\n    \n    return max(\n        smin(\n            length(p.xz) - size * 0.3,\n            length(p - vec3(0., -0.6, 0.) * size) - size * 0.5,\n            0.35 * size\n        ),\n        length(p) - size * 0.8\n    );\n}\n\nvec2 modSoul(in vec3 pOrig, in float size, in float time) {\n    float curve = getSoulCurve(time);\n    vec3 p = pOrig;\n    \n    float jump = max(0., curve - 0.6);\n    \n    p -= vec3(0., 2.1 + mix(-0.2, 0., curve) + jump, 0.) * size;\n    \n    float body = sdBody(p, size, curve);\n    float head = sdSoulHead(p, size, curve);\n    \n    float cheekDot = abs(dot(\n        normalize(p * vec3(sign(p.x), 1., 1.)), \n        normalize(vec3(0.8, -0.45, -1.))\n    ));\n    \n    vec2 res = vec2(\n        smin(head, body, 0.5 * size), \n        cheekDot > 0.988 ? M_SOUL_CHEEK : M_SOUL_BODY\n    );\n    \n    \n    \n    float mouth = sdSoulMouth(p, size, curve);\n    if (-mouth > res.x) { res = vec2(mouth, vec3(0.1)); }\n    \n    float eye = sdSoulEye(p, size);\n    if (eye < res.x) { \n        vec3 eyePos = normalize(p * vec3(sign(p.x), 1., 1.) - SEPOS * size);\n        bool ball = dot(eyePos, normalize(vec3(0.3, 0., -1.))) > 0.95;\n        res = vec2(eye, ball ? M_SOUL_EYEBALL : M_SOUL_EYE); \n    }\n    \n    float eyebrow = sdSoulEyebrow(p, size, curve);\n    if (eyebrow < res.x) { res = vec2(eyebrow, M_SOUL_EYEBROW); }\n    \n    return res;\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdTerr(vec3 p) {\n    float cell = 0.01;\n    p -= vec3(0., -0.01, 0.);\n    vec2 fl = mod(p.xz, cell);\n    vec3 rp = vec3(fl.x, p.y, fl.y) - vec3(cell, 0., cell) / 2.;\n    \n    vec2 corner = floor(p.xz / cell) * cell;\n    \n    float disp = noise(corner * 200.);\n    disp = mix(-0.4, 0.05, disp);\n    \n    rp -= vec3(0., 0. + disp, 0.);\n    \n    float dist = sdSphere(\n        rp * vec3(1., 0.1, 1.), \n        0.004\n    );\n    \n    return min(p.y, dist);\n}\n\nfloat sdTree(vec3 p) {\n    float r = 0.3;\n    return sdSphere((p - vec3(0., r + 0.2, 0.)) * vec3(3., 1., 2.), r) * 0.8;\n}\n\n///\n///\n///\n\nvec2 getDist(vec3 p, bool ignoreSouls) {\n    vec2 res = vec2(MAX_DIST, -1.);\n    \n    vec2 temp;\n    \n    if (!ignoreSouls) {\n        temp = modSoul(p - vec3(0., 0.03, 0.), SOUL_SIZE, iTime * 8.);\n        if (temp.x < res.x) { res = temp; };\n    }\n    \n    temp = vec2(sdTerr(p), M_GRASS);\n    if (temp.x < res.x) { res = temp; }\n    \n    temp = vec2(sdTree(p - vec3(-0.95, sin(iTime) * 0.03, 0.5)), M_TREE);\n    if (temp.x < res.x) { res = temp; }\n    \n    temp = vec2(sdTree((p - vec3(0.8, sin(iTime + 3.) * 0.03, 0.8)) * 1.2), M_TREE);\n    if (temp.x < res.x) { res = temp; }\n    \n    temp = vec2(sdTree((p - vec3(0.7, sin(iTime * 2.) * 0.03 - 0.4, -0.5)) * 0.4), M_TREE);\n    if (temp.x < res.x) { res = temp; }\n    \n    return res;\n}\n\n///\n///\n///\n\nvec3 getNormal(vec3 p, bool ignoreSouls) {\n    float dist = getDist(p, ignoreSouls).x;\n    vec2 e = vec2(0.001, 0.);\n    vec3 n = dist - vec3(\n        getDist(p - e.xyy, ignoreSouls).x,\n        getDist(p - e.yxy, ignoreSouls).x,\n        getDist(p - e.yyx, ignoreSouls).x);\n    return normalize(n);\n}\n\nvec2 rayCast(vec3 ro, vec3 rd, bool ignoreSouls) {\n    float total = 0.;\n    \n    for (int i = 0; i < MAX_COUNT; ++i) {\n        vec2 hit = getDist(ro + rd * total, ignoreSouls);\n        float d = hit.x;\n        total += d;\n        if ((d) < MIN_DIST) return vec2(total, hit.y);\n        if (total > MAX_DIST) return vec2(total, -1.);\n    }\n    \n    return vec2(MAX_DIST + 1., -1.);\n}\n\nM getMaterial(float m, vec3 rd, vec3 touch) {\n    int im = int(m);\n    vec3 z = vec3(0.);\n    \n    if (im == M_SOUL_BODY) return M(z, C_SOUL_BODY);\n    if (im == M_SOUL_EYE) return M(z, C_SOUL_EYE);\n    if (im == M_SOUL_EYEBALL) return M(z, C_SOUL_EYEBALL);\n    if (im == M_SOUL_EYEBROW) return M(z, C_SOUL_EYEBROW);\n    if (im == M_SOUL_CHEEK) return M(z, C_SOUL_CHEEK);\n    \n    if (im == M_GRASS) {\n        float cell = 0.4;\n        vec2 corner = floor(touch.xz / cell) * cell;\n        float cf = noise(corner * 100.);\n        vec3 col = mix(C_GRASS1, C_GRASS, cf);\n        float f = clamp(touch.y, 0., 0.1) / 0.1;\n        return M(z, mix(C_TERRAIN, col * 3., f));\n    }\n    \n    if (im == M_TERRAIN) {\n        return M(z, C_TERRAIN);\n    }\n    \n    float angle = dot(rd, vec3(0., 1., 0.));\n    float axis = dot(rd, vec3(-1., 0., 0.));\n    \n    float skypow = clamp(angle, 0., 1.);\n    vec3 sky = mix(C_SKY_DOWN, C_SKY_UP, smoothstep(-0.3, 0.25, skypow));\n    \n    \n    float mount;\n    \n    mount = (sin(axis * 5.5 + 2.5)) * 0.1 - 0.;\n    mount = exp(-max(0., angle - mount)*25.);\n    sky = mix(sky, vec3(0.6, 0.5, 4.9) * mix(0.5, 1., angle/0.2), mount);\n    \n    mount = (sin(axis * 6.) * 0.5 + 0.5) * 0.1 - 0.15;\n    mount = exp(-max(0., angle - mount)*65.);\n    sky = mix(sky, vec3(0.8, 0.9, 1.9) * mix(0.4, 0.3, angle/0.2), mount);\n    \n    mount = (sin(axis * 6.) * 0.5 + 0.5) * 0.1 - 0.23;\n    mount = exp(-max(0., angle - mount)*65.);\n    sky = mix(sky, vec3(3.4, 2.9, 1.9) * mix(0.4, 0.3, angle/0.2), mount);\n    \n    \n    if (im == M_TREE) {\n        return M(z, C_TREE);\n    }\n    \n    return M(sky, z);\n}\n\nvec3 getLightWithPos(in vec3 lightPos, in vec3 lightCol, in vec3 p, in vec3 n, bool occlusion) {\n    vec3 toLight = lightPos - p;\n    vec3 nToLight = normalize(toLight);\n    float dToLight = length(toLight);\n    float pLight = max(0., dot(n, nToLight));\n    if (occlusion) {\n        float occlDist = rayCast(p + nToLight * 0.01, nToLight, false).x;\n        pLight *= min(1., pow(occlDist / dToLight, 1.));\n    }\n    return pLight * lightCol;\n}\n\nvec3 getLight(in vec3 p, in vec3 n, bool occlusion) {\n    return getLightWithPos(vec3(1., 1., -1.), vec3(1.3), p, n, occlusion) + \n        getLightWithPos(vec3(-1., 0.4, 1.), vec3(5., .2, .2) * 2., p, n, occlusion);\n}\n\nvec3 castToLight(in vec3 ro, in vec3 rd, out vec2 hit, out vec3 n, out vec3 touch, bool ignoreSouls) {\n    vec3 col = vec3(0.);\n    \n    hit = rayCast(ro, rd, ignoreSouls);\n    if (hit.x >= MAX_DIST) {\n        return getMaterial(-1., rd, touch).emission;\n    }\n    \n    touch = ro + rd * hit.x;\n    M m = getMaterial(hit.y, rd, touch);\n    \n    vec3 ambient = C_SKY_UP;\n    col += m.diffuse * ambient;\n    \n    vec3 lightPos = vec3(2., 1.5, -3.);\n    vec3 lightCol = vec3(1.) * 2.;\n    \n    col += m.emission;\n    \n    if (length(m.diffuse) > 0.01) {\n        n = getNormal(touch, ignoreSouls);\n        col += m.diffuse * getLight(touch, n, true);\n    }\n    \n    return col;\n}\n\nvec3 renderScene(in vec3 ro, in vec3 rd) {\n    vec2 hit;\n    vec3 n, touch;\n    vec3 col = castToLight(ro, rd, hit, n, touch, false);\n    \n    int mid = int(hit.y);\n    if (mid == M_SOUL_BODY || mid == M_SOUL_CHEEK) {\n        float f = 1.-max(0., -dot(n, rd));\n        f = clamp(f, 0.5, 0.8) - 0.5;\n        f /= 0.3;\n        if (f > 0.1) {\n            vec3 sub = castToLight(ro, rd, hit, n, touch, true);\n            col = mix(col, sub, f) * (1. - abs(n) * 0.3);\n        }\n    }\n    \n    if (mid == M_TREE) {\n        vec3 sky = getMaterial(-1., rd, touch).emission;\n        float f = 1.-max(0., -dot(n, rd));\n        f = clamp(f, 0.0, 1.);\n        f /= 0.9;\n        f = max(0., f);\n        col = mix(col, sky, f);\n    }\n    \n    if (hit.x < MAX_DIST && touch.y < 0.1) {\n        vec3 planeN = vec3(0., 1., 0.);\n        float upDist = rayPlane(ro, rd, planeN, 0.1);\n        if (upDist > 0.) {\n            vec3 plane = ro + rd * upDist;\n            float dist = length(plane - touch);\n            \n            float scaterring = 1. - exp(-dist * 10.);\n            float absorbing = 1. - exp(-dist * 35.);\n            \n            vec3 diffuse = C_TERRAIN;\n            \n            col = mix(col, vec3(0.), absorbing) + \n                scaterring * diffuse * getLight(plane + 0.5 * dist * rd, planeN, false);\n        }\n    }\n    \n    if (hit.x < MAX_DIST && touch.y < 0.15) {\n        vec3 planeN = vec3(0., 1., 0.);\n        float upDist = rayPlane(ro, rd, planeN, 0.15);\n        if (upDist > 0.) {\n            vec3 plane = (ro + rd * upDist);\n            \n            vec3 diffuse = vec3(noiseSmooth(plane.xz * 9. + vec2(0., iTime * 0.3)));\n            col += diffuse * 0.2 * getLight(plane, planeN, false);\n            \n        }\n    }\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 vpShift = vec2(iResolution.x/iResolution.y, 1.);\n    vec2 vp = fragCoord/iResolution.y*2. - vpShift;\n    \n    float time = iTime * 0.5;\n    vec3 origin = vec3(sin(time) * 0.2, 0.5, -2.);\n    vec3 target = vec3(0., 0.4, 0.);\n    vec3 up = vec3(0., 1., 0.);\n     \n    vec3 camForward = normalize(target - origin);\n    vec3 camRight = normalize(cross(up, camForward));\n    vec3 camUp = cross(camForward, camRight);\n    \n    vec3 ro = origin;\n    vec3 rd = normalize(3. * camForward + camRight * 1. * vp.x + camUp * vp.y);\n\n    vec3 col = renderScene(ro, rd);\n    \n    //fragColor = vec4(col, 1.);\n    fragColor = vec4(ACESFilm(col), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WldBW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[781, 781, 806, 806, 875], [877, 877, 908, 908, 1249], [1251, 1251, 1302, 1302, 1426], [1428, 1428, 1467, 1467, 1560], [1562, 1562, 1601, 1601, 1632], [1634, 1634, 1657, 1657, 1817], [1819, 1819, 1854, 1854, 1890], [1892, 1892, 1952, 1952, 2397], [2438, 2438, 2481, 2481, 2596], [2598, 2598, 2661, 2661, 2854], [2856, 2856, 2917, 2917, 3036], [3038, 3038, 3094, 3094, 3507], [3509, 3509, 3568, 3568, 4636], [4638, 4638, 4671, 4671, 4699], [4701, 4701, 4723, 4723, 5160], [5162, 5162, 5184, 5184, 5283], [5285, 5298, 5338, 5338, 6036], [6038, 6051, 6093, 6093, 6350], [6352, 6352, 6402, 6402, 6734], [6736, 6736, 6781, 6781, 8354], [8356, 8356, 8452, 8452, 8799], [8801, 8801, 8854, 8854, 9018], [9020, 9020, 9122, 9122, 9695], [9697, 9697, 9739, 9739, 11449], [11451, 11451, 11508, 11508, 12155]], "test": "valid"}
{"id": "WldBWl", "name": "Triangle by points", "author": "Osakazaur", "description": "I was practicing but I hope it will be useful for someone.\n\nThis is how to draw the triangle by its vertices' coordinates.\nThere are two ways to set coordinates: absolute and relative.\n\nIf something is wrong with your triangle, try to change < > sigths.", "tags": ["geometry", "studyind"], "likes": 1, "viewed": 76, "published": "Public", "date": "1613680716", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n//absolute coordinates\nvec2 A = vec2(50., 50.);\nvec2 B = vec2(200., 375.);\nvec2 C = vec2(600., 50.);\n*/\n\n//relative coordinates\nvec2 A = vec2(.125, .125);\nvec2 B = vec2(.35, .85);\nvec2 C = vec2(.85, .125);\n\nvec4 triangleColor = vec4(0.75, 0.75, 0.75, 1.);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec4 baseColor = vec4(col,1.0);\n    \n    /*\n    //absolute triangle\n    vec2 xy = fragCoord;\n    if ((xy.x - A.x)/(B.x - A.x) < (xy.y - A.y)/(B.y - A.y) ||\n        (xy.x - B.x)/(C.x - B.x) > (xy.y - B.y)/(C.y - B.y) ||\n        (xy.x - C.x)/(A.x - C.x) > (xy.y - C.y)/(A.y - C.y))\n    {fragColor = baseColor;}\n    else {fragColor = triangleColor;};\n    */\n    \n    //relative triangle\n    if ((uv.x - A.x)/(B.x - A.x) < (uv.y - A.y)/(B.y - A.y) ||\n        (uv.x - B.x)/(C.x - B.x) > (uv.y - B.y)/(C.y - B.y) ||\n        (uv.x - C.x)/(A.x - C.x) > (uv.y - C.y)/(A.y - C.y))\n    {fragColor = baseColor;}\n    else {fragColor = triangleColor;};\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WldBWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[108, 261, 318, 318, 1064]], "test": "valid"}
{"id": "WldfD2", "name": "Retro Style Audio Visualizer", "author": "ChutneyPot", "description": "My attempt at a retro-inspired music visualizer.\n\nSoundcloud track: Modern Knight - Who Ha - Magenta Teal Desert Cruise\nlink: https://soundcloud.com/modernknightly/who-ha-magenta-teal-desert-cruise\n\nEdit: Replaced track with ShaderToy's track.", "tags": ["retro", "audio", "visualizer", "soundcloud"], "likes": 3, "viewed": 236, "published": "Public", "date": "1613498320", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Retro Style Audio Visualizer, February 2021\n// by Tito Morab - ChutneyPot\n// https://www.shadertoy.com/view/WldfD2\n// soundcloud track: Modern Knight - Who Ha - Magenta Teal Desert Cruise\n// link: https://soundcloud.com/modernknightly/who-ha-magenta-teal-desert-cruise\n//--------------------------------------------------------------------------\n#define col1 vec4(0.07, 0.02, 0.35, 1.0)\n#define col2 vec4(1.0, 0.46, 1.0, 1.0)\n#define col3 vec4(0.99, 0.0, 1.0, 1.0)\n#define col4 vec4(0.1, 0.7, 1.0, 1.0)\n#define col5 vec4(0.1, 0.6, 1.0, 1.0)\n#define col6 vec4(0.02, 0.85, 0.91, 1.0)\n\nfloat Remap(in float val, in vec2 old, in vec2 new)\n{\n    float t = clamp((val - old.x) / (old.y - old.x), 0.0, 1.0);\n    float result = t * (new.y - new.x) + new.x;\n    return result;\n}\n\nvoid Pixellize(inout vec2 uv, float value)\n{\n    uv *= value;\n    uv = floor(uv);\n    uv /= value;\n}\n\nvec4 Background(in vec2 uv)\n{\n    uv *= 0.56;\n    \n    Pixellize(uv, 30.0);\n    \n    float t = Remap(sin((iTime - 20.0) * 0.1), vec2(-1.0, 1.0), vec2(-0.1, 0.4));\n    vec4 col = mix(col1, col2, uv.y + t);\n    \n    return col;\n}\n\nvec4 Bars(in vec2 uv)\n{    \n    uv *= 0.566; \n    uv.x = abs(uv.x);\n    uv.y += 0.882;\n    \n    float bars = 1.0 - abs(mod(uv.x * 320.0, 2.0) - 1.0);\n    \n    Pixellize(uv, 80.0);\n     \n    float aud = step(uv.y, texture(iChannel0, vec2(uv.x, 0.0)).r);           \n    \n    vec4 col = mix(vec4(0.0), col1, bars * aud);\n    col = mix(col, col3, col.w);\n    \n    return col;\n}\n\nvec4 Bass(in vec2 uv)\n{\n    uv.y += 1.5;\n    \n    float aud = texture(iChannel0, vec2(0.0, 0.0)).r;\n    float b0 = smoothstep(1.2 + aud, 1.15 + aud, length(uv));\n    \n    Pixellize(uv, 40.0);\n    \n    float b1 = smoothstep(1.0 + aud, 0.4 + aud, length(uv));\n    float b2 = smoothstep(1.0, 0.8, length(uv));\n    float b = mix(mix(b0 + b1 + b2, b1 + b2, step(aud, 0.7)), b2, step(aud, 0.3));\n    \n    vec4 col = mix(vec4(0.0), col6, b0);\n    col = mix(col, col5, b1);\n    col = mix(col, col4, b2);\n\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n        \n    vec4 bg = Background(uv);\n    vec4 bars = Bars(uv);\n    vec4 bass = Bass(uv);\n       \n    vec4 col = mix(vec4(0.0), bg, bg.w);\n    col = mix(col, bass, bass.w);\n    col = mix(col, bars, bars.w);\n    \n    fragColor = vec4(col);\n}", "image_inputs": [{"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WldfD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 586, 639, 639, 772], [774, 774, 818, 818, 874], [876, 876, 905, 905, 1103], [1105, 1105, 1128, 1128, 1478], [1480, 1480, 1503, 1503, 1994], [1996, 1996, 2051, 2051, 2359]], "test": "error"}
{"id": "wldfDM", "name": "Pulses [HurleybirdJr]", "author": "HurleybirdJr", "description": " Pulse and combine merge.", "tags": ["basic"], "likes": 1, "viewed": 41, "published": "Public", "date": "1612899108", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Shape Functions\nfloat circle(vec2 uv) {\n    float r = 0.3; // Radius\n    float er = 1.5/iResolution.y; // Edge Radius with scaleable AA\n    float d = length(uv); // Distance calcuation\n    float c = smoothstep(r, r-er, d); // Set colours to distance values\n    \n    return c;\n}\n\nfloat square(vec2 uv) {\n    uv += .5;\n    \n    vec2 bl = step(vec2(0.2),uv);\n    vec2 tr = step(vec2(0.2),1.-uv);\n    float pct = bl.x * bl.y * tr.x * tr.y;\n    \n    float c = pct;\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalize pixel coordinates\n    vec2 uv = (fragCoord-0. * iResolution.xy) / iResolution.xy; // 0 <> 1\n    \n    uv -= 0.5; // Remap UV // -0.5 <> 0.5\n    uv.x *= iResolution.x / iResolution.y; // Fix Aspect Ratio\n\n    //float combine = smoothstep(-square(uv), -circle(uv), sin(iTime));\n    float combine = circle(uv*sin(iTime))+square(uv*cos(iTime));\n    \n    float pulse = circle(uv*fract(length(uv)+iTime));\n\n    fragColor = vec4(vec3(combine, pulse, 0.5), 1.0);   \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wldfDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 19, 42, 42, 280], [282, 282, 305, 305, 478], [480, 480, 537, 572, 1013]], "test": "valid"}
{"id": "wldfDr", "name": "Sparkly explosion", "author": "lukaszk159", "description": "Lets say that this is a simple particle explosion...right? :D", "tags": ["explosion", "practicles"], "likes": 5, "viewed": 141, "published": "Public", "date": "1612567679", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PRACTICLES_COUNT 23.\n\nvec2 Hash12(float t)\n{\n    float x = fract( sin(t* 674.3) * 453.2);\n    float y = fract( sin( (t + x) * 714.3) * 263.2);\n    \n    return vec2(x,y);\n\n}\n\nvec2 Hash12Polar(float t)\n{\n    float a = fract( sin(t* 674.3) * 453.2) * 6.2832; // * 2 PI\n    float d = fract( sin( (t + a) * 714.3) * 263.2);\n    \n    return vec2(sin(a),cos(a))*d;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y; // Współrzędne od środka\n    \n   // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));     // Time varying pixel color\n    vec3 col = vec3(0);\n    vec3 color = sin(vec3(.34,.54,.43) *floor(iTime)* .5 + .5);\n    float t = fract(iTime);\n    for( float i =0.0; i < PRACTICLES_COUNT; i++)\n    {\n        vec2 dir = Hash12Polar(i + 1.0) * .5;\n        \n        float d = length(uv - dir* t);\n        \n        float brightness = mix( 0.005, .0001, smoothstep(0.05, 0.0, t) );\n        brightness *= sin(t*20.0 + i)* .5 +.5;\n        brightness*= smoothstep(1.,.5,t);\n        col += brightness/d * color;\n    }\n    \n    col*= 2.0;\n    fragColor = vec4(col,1.0);     // Output to screen\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wldfDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 52, 52, 180], [182, 182, 209, 209, 368], [370, 370, 427, 427, 1173]], "test": "valid"}
{"id": "wldfW8", "name": "Warped gyroid ice cave", "author": "jarble", "description": "This a modified version of [url=https://www.shadertoy.com/view/WtSfzd]3D_Gyroid_IceCave_LO[/url] with a distorted perspective.\n\nThe [code]RayMarch[/code] function is modified to change the camera's direction with each step.", "tags": ["gyroid"], "likes": 1, "viewed": 229, "published": "Public API", "date": "1612674313", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100. //WE PUT A DECIMEL HERE AND NOT ON MAX STEPS BECAUSE MAX STEPS IS AN INT\n\t\t\t\t\t  //WHEREAS MAX_DIST IS A FLOAT\n#define SURF_DIST 1e-3 //OUR \"SURFACE DIST\" IS WHEN THE SPHERE THAT SEEKS A HIT DURING OUR MARCH REACHES A SMALL SIZE, IN THIS CASE .01\n\t\t\t\t\t  //THEN WE HAVE A HIT\n\n#define S(a, b, t) smoothstep (a, b, t)\n\nmat2 Rot(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    \n    return mat2(c, -s, s, c); \n}\n\nfloat sdBox (vec3 p, vec3 s)\n{\n  p = abs(p)-s; \n    \n    return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdGyroid(vec3 p, float scale, float thickness, float bias) \n    {       \n        p *= scale;  //WE SCALE THE POSITION TO SCALE THE GYROID. BUT WHENEVER WE MULTIPLY THE POSITION, WE NEED TO DIVIDE IT BY WHAT WE MULTIPLIED. \n        \n        return abs(dot(sin(p), cos(p.zxy)) - bias)/scale-thickness; //WE DIVIDE IT HERE.  ALSO !! -- IF PLAYING WITH A 2D GYROID WE CAN\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   //CHANGE THE SHAPE BY MULTIPLYING THE POSITION'S SIN\n    }\n\nvec3 Transform(vec3 p)\n{\n    p.xy *= Rot(p.z*.18); \n    p.z -= iTime*1.0;\n    p.y -= .3; \n    \n    return p;\n}\n\nfloat GetDist(vec3 p) //THIS TAKES A POINT  IN 3D SPACE AS AN INPUT\n    {\n                  \n        p = Transform(p);  //THIS IS HOW WE'LL MOVE OUR STRUCTURE. WE DON'T WANT TO MOVE OUR CAMERA POSITION BECAUSE THE MORE WE MOVE\n        \t\t\t\t  //OUR CAMERA AWAY FROM THE ORIGIN POINT, THE LESS DETAILED WE'LL GET BECAUSE THIS IS, IN ESSENCE, BUILT AROUND\n        \t\t\t\t  //A RAYMARCHER THAT MARCHES A RAY TO A POINT \n        \n        float box = sdBox(p, vec3(1)); \n\n        float g1 = sdGyroid(p, 5.76, .03, 1.5);\n        float g2 = sdGyroid(p, 10.76, .03, .3);\n        float g3 = sdGyroid(p, 20.76, .03, .3);\n        float g4 = sdGyroid(p, 35.76, .03, .3);\n        float g5 = sdGyroid(p, 60.76, .03, .3);\n        float g6 = sdGyroid(p, 100.23, .03, .3);\n\n\n        //float g = min(g1, g2); //Union method of combining gyroids\n        // float g = max(g1, -g2); //Subraction method of combining gyroids\n        \n        g1 -= g2*.4;   //Bumpmap method\n        g1 -= g3 *.2;\n        g1 += g4 *.2;\n        g1 += g5 *.2;\n        g1 -= g6 *.1;\n       \n            \n       \n       // float d = max(box, g1*.8); //WE MULTIPLY BY A NUMBER LESS THAN 1 TO REDUCE THE STEP SIZE SO WE DON'T OVERSTEP WHEN\n        \t\t\t\t\t\t\t   //WE ADJUST THE SCALE ABOVE IN sdGyroid.\n \n        float d = g1*.6; \n        return d;\n    }\n\nfloat RayMarch(vec3 ro, vec3 rd)\n    {\n        float dO = 0.,eps=SURF_DIST; //Distance origin, or how far away we've marched from the origin. \n        \n        for(int i=0; i < MAX_STEPS; i++) //Loop that goes until you've reached max # of steps. \n        {\n            rd.xy *= Rot(rd.z/10.0); \n            vec3 p = ro+dO*rd; //Point P is the blue point (\n            float dS = GetDist(p); //Distance to the scene. \n            dO += dS; //We add the distance to the scene to how far we've marched away from origin. \n            \n            if(dS<eps*(1.0+dO*.25) || dO > MAX_DIST) break; //If distance to scene  is smaller than some defined surface distance, we have a hit. \n            eps *= 1.01;\t\t\t\t\t\t\t\t\t\t    //Or if it's past our max distance and we haven't hit anything, we break out of it. \n        }\n        return dO; \n    }\n\nvec3 GetNormal(vec3 p) //THIS IS HOW WE FIND THE NORMAL VECTOR, IE THE ORIENTATION OF A SURFACE\n    \t\t\t\t\t//ESSENTIALLY BY DOING THE SAME ALGORITHM TO DETERMINE A SLOPE. WE MAKE 2 POINTS\n    \t\t\t\t\t//VERY CLOSE TOGETHER, THEN SUBTRACT THE DISTANCE A LITTLE TO THE RIGHT, UP AND\n    \t\t\t\t\t//BEHIND THE SURFACE BETWEEN THEM TO FIND WHICH WAY IT'S PORIENTED. \n{\n    \n    vec2 e = vec2(.01, 0); //THIS IS OUR NEW POINT. OUR X VALUE IS .01 AND OUR Y VALUE IS 0.\n    float d = GetDist(p); //THIS IS OUR ORIGINAL POINT IN 3D SPACE WE MADE ABOVE\n    \n    vec3 n = d - vec3( //THESE ARE THE SUBTRACTIONS TO GIVE US OUR NORMAL \n        GetDist(p-e.xyy), //TO THE RIGHT, IE - .01, 0, 0\n        GetDist(p-e.yxy), //UP, IE 0, .01, 0 BECAUSE WE USE THE XY VALUES DEFINED ABOVE, WHEN WE DEFINE VEC2 E\n        GetDist(p-e.yyx)); //BEHIND\n        \n        return normalize(n); \n    \n}\n        \nfloat GetLight(vec3 p)\n        {\n            vec3 lightPos = vec3(0,5,6); //HARDCODE THE LIGHT POSITION. FOR NOW WE'LL SAY IT'S AT THESE POINTS. \n            lightPos.xy += vec2(sin(iTime), cos(iTime))*2.; \n            vec3 l = normalize(lightPos-p); //THIS CALCULATES WHERE LIGHT IS COMING FROM, FROM THE PERSPECTIVE OF THE SURFACE POINT\n            vec3 n = GetNormal(p); \n            \n            float dif = clamp(dot(n, l), 0., 1.); //IF WE DON'T CLAMP IT BETWEEN 0 AND 1, THIS ACTUALLY GIVES US A VALUE BETWEEN -1 AND 1\n            \t\t\t\t\t\t\t\t\t  //WHICH IS FINE WITH A SIMPLE SHAPE LIKE A SPHERE BUT IF WE WANT TO WORK WITH MORE COMPLEX\n            \t\t\t\t\t\t\t\t\t  //STUFF, IT WOULD GIVE US TROUBLE. SO WE CLAMP IT BETWEEN 0 AND 1 \n            \n            float d = RayMarch(p+n*SURF_DIST, l); //THIS IS HOW WE CALCULATE SHADOW. WE RAYMARCH BETWEEN SURFACE POINT AND LIGHT POS AND RETURN A VALUE.\n            \n            if(d<length(lightPos - p)) dif *= .1; //IF THE VALUE WE GET IS SMALLER THAN THE LIGHT POS - SURFACE POSITION, WE KNOW THAT \n            \t\t\t\t\t\t\t\t\t  //WE'RE IN SHADOW. TO MAKE A SHADOW, WE JUST TAKE THE LIGHT VALUE DIF AND MULTIPLY IT BY \n            \t\t\t\t\t\t\t\t\t  //A SMALL AMOUNT TO CREATE THE SHADOW\n            return dif;\n        }\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z)\n{\n    vec3 f = normalize (l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z, \n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d; \n}  \n        \nvec3 Background(vec3 rd)  //WE ONLY NEED TO CALCULATE OUR BKG'S RD BECAUSE WE DON'T CARE ABOUT WHERE WE ARE, WE ONLY CARE ABOUT WHAT\n    \t\t\t\t\t   //DIR WE'RE LOOKING IN. \n    \n{\n    \n    vec3 col = vec3(0); \n    float t = iTime; \n    \n    float y = rd.y * .5 +.5; //Here we map our color to the ray direction y and then multiply it so that we lock its value between 0 and 1. \n    \t\t\t\t\t\t//At 1 (straight), it's its brightest and at 0 (straight down) it's at its dimmest, giving us a gradient in the\n    \t\t\t\t\t\t//middle. \n    \n    col += y*vec3(.1, .7, 1)*2.;  //This bakes it in so that our color is brighter the higher our Y is. \n    \t\t\t\t\t\t\t  //If we wanted it reverse, we'd do col += (1.-y); \n    \n    float a = atan(rd.x, rd.z); //XZ plane to give us our angle so we can determine our NSEW direction \n    \n    float flames = sin(a*10. +t)*sin(a*7.-t)*sin(a*3.); //We find the sin wav of our angle and multiply to get multiple sin waves on our image. \n    \t\t\t\t\t\t\t\t\t\t\t\t //We then marry it to iTime so it comes in and out on a timer. Then repeat, but \n    \t\t\t\t\t\t\t\t\t\t\t\t//multiply it by negative t so we don't see the movement of the light coming in. Then,\n    \t\t\t\t\t\t\t\t\t\t\t\t//we multiply it again by the sin wave of the angle and diminish it so it feels random. \n    \t\t\t\t\t\t\t\t\t\t\t\t//We could keep repeating this again and again to make it feel more and more random, but\n    \t\t\t\t\t\t\t\t\t\t\t    //Ehh. It looks fine now.\n    \n    flames *= S(.8, .5, y); //We don't want this to reach the poles, so we smoothstep the flame's Y so at .5 it starts fading out\n    \t\t\t\t\t  //and at .8 it's completely faded out   \n        \n    col += flames; \n    col = max(col, 0.); //This makes it so our color can never go negative. \n    //col += S(.5, .2, y); \n    return col; \n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    float t = iTime;\n    vec3 col = vec3(0);\n    \n    uv += sin(uv*30.*t)*.0001; //\"Heat\" distortion    IF REALLY HIGH THEN IT CAN BE USED FOR DOPE MOSAIC STUFF\n    vec3 ro = vec3(0,0,-.01); //ray origin, or position of camera   \n    //ro.yz *= Rot(-m.y*3.14+1.+sin(iTime*5.0/7.0*2.0)/2.0); \n    //ro.xz *= Rot(-m.x*6.2831+cos(iTime*2.0)/2.0);\n    \n    ro.yz *= Rot(-m.y*3.14+sin(iTime*5.0/7.0)/2.0); \n    ro.xz *= Rot(-m.x*6.2831+cos(iTime)/2.0);\n    \n    vec3 lookat = vec3(0,0,0); \n    vec3 rd = GetRayDir(uv, ro, lookat, .8); //THE FLOAT AT THE END OF THIS IS THE ZOOM FACTOR\n    \n    float d = RayMarch(ro, rd);\n    \n    if(d<MAX_DIST) //THIS IS WHERE WE MAKE OUR MATERIAL, WHICH INCLUDES COLOR AND SHADOWS\n    {\n        vec3 p = ro + rd * d; \n        vec3 n = GetNormal(p); \n        \n        float height = p.y; \n\n        p = Transform(p); \n        \n        float dif = n.y * .5+.5; //n.y gives us light from direct above because it's the normal's y. We then wrap it with .5 + .5\n        \t\t\t\t\t\t //to prevent it shooting us back a negative value, keeping it always between 0 and 1. \n        col += dif*dif;\n        \n        float g2 = sdGyroid(p, 10.76, .03, .3); //Ambient occlusion.\n        col *= S(-.1, .1, g2); //Blackening \n        \n        \n        //CRACKS: \n        \n        float crackWidth = -.01 + S(0., -.5, n.y)*.01; //We set the crack width but then put in the smoothstep to say \"If it's between\n        \t\t\t\t\t\t\t\t\t\t\t\t//These values (ie 0 and -.5), then make it thicker. In this case, it tranlsates \n        \t\t\t\t\t\t\t\t\t\t\t\t//to being thicker on the bottom than the top.  \n        float cracks = S(crackWidth, -.03, g2); //  \n        float g3 = sdGyroid(p+t*.1, 5.76, .03, .0);\n        float g4 = sdGyroid(p-t*.07, 3.76, .03, .0);\n        \n        cracks *= g3*g4*30.+.3*S(.0, .3, n.y); //THE LAST NUMBER HERE DETERMINES THE BRIGHTNESS OF THE COLOR IN THE CRACKS\n        \t\t\t\t\t\t\t\t\t   //WE USE SMOOTHSTEP HERE TO KEEP IT FROM GOING FULLY BLACK AT A CERTAIN HEIGHT.\n        \t\t\t\t\t\t\t\t\t   //BECAUSE I WANT THIS TO BE ICE, I WANT IT TO NOT GO FULL BLACK UP TOP, BUT DOWN BELOW IS FINE.\n        \t\t\t\t\t\t\t\t\t   //IF I WANTED THE REVERSE, I'D REVERSE THE NUMBERS. \n        \n        \n        col += cracks*vec3(.1, .7, 1)*3.; //This allows us to change the color of the cracks in RGB code. Our primary color should\n        \t\t\t\t\t\t\t\t  //Always be 1 or greater and no value should be 0 because if it is, if we then multiply the\n        \t\t\t\t\t\t\t\t  //colors, it will get funky in not a good way. \n        \n        //FLICKERING\n        \n        float g5 = sdGyroid(p-vec3(t,0,0), 3.76, .03, .0); //The vec3 allows us to determine the direction the flickering happens.\n        \t\t\t\t\t\t\t\t\t\t\t\t   //We marry it to Time to give it a rhythm. If the T is in X, the flickering\n        \t\t\t\t\t\t\t\t\t\t\t\t  //goes along the X, if in Y then the Y,  etc.\n           \n        col += g5*vec3(.1, .7, 1); //determines the color of our flicker\n        \n        col += S(0., 8., height)*vec3(.1, .7, 1)*2.; //gives us a glow to wash it out. I have the glow start at 0 and reach max at 5\n        \n        \t\n        \n    }\n    \n    //DEPTH FOG/BACKGROUND: \n    \n    col = mix(col, Background(rd), S(0., 9., d)); //This is where we blend our background with our structure.  \n   \n    col *= 1. -dot(uv, uv); //THIS IS A VIGNETTE. WE MULTIPLY UV BY UV (UV SQUARED) TO GIVE US A BLACK CENTER. TO PUSH IT OUT TO THE EDGES\n    \t\t\t\t\t\t//OF THE SCREEN, WE MULTIPLY IT BY NEGATIVE DOT. \n    fragColor = vec4(col,1.0);\n}\n    \n    \n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wldfW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[297, 360, 379, 379, 461], [463, 463, 493, 493, 583], [585, 585, 656, 656, 1043], [1045, 1045, 1069, 1069, 1155], [1157, 1157, 1230, 1230, 2456], [2458, 2458, 2496, 2496, 3295], [3297, 3297, 3651, 3651, 4160], [4170, 4170, 4202, 4202, 5422], [5424, 5424, 5474, 5474, 5672], [5684, 5684, 5860, 5860, 7435], [7438, 7438, 7495, 7495, 11074]], "test": "valid"}
{"id": "wldfWr", "name": "Square / Sine Wave FM", "author": "Dutracgi", "description": "Made this utility to help in another projet :) Feel Free to use it in your own, please reffer the original link :) !", "tags": ["waves", "oscilloscope", "wave", "square", "graph", "plot", "physics", "amplitude", "radio"], "likes": 1, "viewed": 188, "published": "Public API", "date": "1612561773", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Line Thickness\n#define tk 0.02\nfloat sqr_plot(float t, float low, float high, vec2 uv){\n    float l = 0.;\n    if(t<0.5){\n        float t2=low;\n        if(t2>uv.y && t2 < uv.y+tk){\n            l = 1.;\n        }\n        if(t>0.45-tk && t2<uv.y && uv.y<high) l = 1.0;\n    }\n    if(t>0.5){float t2=high; if(t2>uv.y && t2 < uv.y+tk) l = 1.;}\n    return l;\n}\n\nfloat sin_plot(float t, float low, float high, vec2 uv){\n  float l = 0.;\n  t*= high-low;\n  t+=low;\n  if(t>uv.y && t < uv.y+tk) l = 1.;\n  return l;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = 2.*fragCoord/iResolution.xy-1.;\n    uv.x*=iResolution.x/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = vec3(0);\n    \n    //frequency base (move mouse aroung screen to change it!)\n    float f = 8.+8.*(iMouse.y/iResolution.y);\n    //wave generator (sine)\n    float t = 0.5*sin(uv.x*f+iTime)+0.5;\n    \n    //Plotter sqr_plot(wave, lowest point, highest point, screen uv)\n    float l = sqr_plot(t,-0.9,0.9,uv);\n    \n    //Plotter sin_plot(wave, lowest point, highest point, screen uv)\n    //l = sin_plot(t,-0.9,0.9,uv); //<- Uncomment Here to see the original wave!\n\n    col = vec3(l);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wldfWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 33, 89, 89, 354], [356, 356, 412, 412, 504], [506, 506, 563, 614, 1284]], "test": "valid"}
{"id": "wldfzS", "name": "Puzzle", "author": "theott", "description": "experiment", "tags": ["sinus"], "likes": 1, "viewed": 88, "published": "Public", "date": "1613333759", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Wave(float x, float y, float f)\n{\n    float fx = sin(x) * 0.5 +.5;\n    fx = pow(fx, 1.);\n    if (abs(fx - y) < (sin(iTime) * 0.05 + 0.1)) {\n        return 1.;\n    }\n    return 0.;\n}\n\n\nfloat GetDist(vec3 p) {\n    return p.x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x -= 0.25;\n    uv.x *= iResolution.x/iResolution.y;\n    uv = fract(uv);\n    \n    // Time varying pixel color\n    vec3 col = vec3(0.);\n    \n    // mouse controls\n    vec2 mo = vec2(iMouse.x * 6.28 / iResolution.x, iMouse.y * 3.14 / iResolution.y);\n    \n    // number of repetitions\n    float n = 50.;\n    // for each frequency\n    for (float i = 1.; i <= n; i++) {\n        vec3 nextcol = vec3(uv.x, uv.y, i/n);\n        nextcol *= i/n;\n        float x = Wave(uv.x * 6.283185307179586 * i + mo.x, uv.y, float(i));\n        float y = Wave(uv.y * 6.283185307179586 * i + mo.y, uv.x, float(i));\n        nextcol *= x * y;\n        if (col == vec3(0.)) {\n            col += nextcol;\n        }\n    }\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wldfzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 187], [190, 190, 213, 213, 231], [233, 233, 290, 340, 1139]], "test": "valid"}
{"id": "wldyz8", "name": "sphere_fog23", "author": "edwardbraed", "description": "Simple fog realization..", "tags": ["raymarch", "sphere", "fog"], "likes": 3, "viewed": 104, "published": "Public", "date": "1612733304", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS_MARCH 64\n#define SPHERE_RADIUS 0.5\n#define FOG_COLOR vec3(0.5, 0.7, 0.0)\n\nvec2 calcAspect(vec2 iRes)\n{\n    vec2 aspect = vec2(float(iRes.x < iRes.y) * iRes.x / iRes.y,\n\t\t\t\t\t   float(iRes.y < iRes.x) * iRes.y / iRes.x);\n    aspect.x += float(aspect.x == 0.0);\n    aspect.y += float(aspect.y == 0.0);\n    return aspect;\n}\n\nvec3 raymarch(vec3 ro, vec3 rd, vec3 lp)\n{\n    float t = 0.0;\n    float d = 0.0;\n    vec3 color = vec3(0.0);\n    float depth = 0.0;\n    for(int x = 0; x < MAX_STEPS_MARCH; x++)\n    {\n        vec3 pos = ro + t * rd;\n        float d = length(pos) - SPHERE_RADIUS;\n        if(d < 0.001)\n        {\n            vec3 n = normalize(pos);\n            vec3 l = normalize(-lp - ro);\n\t\t\tvec3 v = normalize(pos - ro);\n\t\t\tvec3 r = normalize(reflect(-l, n));\n\t\t\tfloat spec = 0.7 * clamp(pow(max(dot(r, v), 0.0), 128.0), 0.0, 1.0);\n            float deff = dot(normalize(lp), n);\n            color = vec3(deff + spec);\n            depth = 1.0 - clamp(abs(ro.z - pos.z), 0.0, 1.0);\n            break;\n        }\n        \n        t += d;\n    }\n    \n    return mix(FOG_COLOR, color, depth);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // aspect ratio for correction rays..\n    vec2 aspect = calcAspect(iResolution.xy);\n    \n    // pseudo perspective pyramid (directions rays)\n    vec2 dTr = vec2(1.0, 1.0);\n    vec2 dTl = vec2(-1.0, 1.0);\n    vec2 dBr = vec2(1.0, -1.0);\n    vec2 dBl = vec2(-1.0, -1.0);\n    \n    // common uv ray direction\n    vec3 rd = vec3(mix(mix(dBl, dBr, uv.x),\n                       mix(dTl, dTr, uv.x), uv.y) * aspect,\n                   1.0);\n    \n    // origin direction (or pseudo camera position)\n    float roZ = (sin(iTime) + 1.0) * 0.5 * 0.25; // 0.0-0.25\n    vec3 ro = vec3(0.0, 0.0, -1.2 - roZ);\n    // light vector\n    vec3 lv = vec3(sin(iTime) * 5.0, 5.0, cos(iTime) * 5.0);\n    \n    vec3 rgb = raymarch(ro, rd, lv);\n\n    // Output to screen\n    fragColor = vec4(rgb, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wldyz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[92, 92, 120, 120, 337], [339, 339, 381, 381, 1112], [1114, 1114, 1171, 1221, 2046]], "test": "valid"}
{"id": "wlGBDD", "name": "Shroomyfix", "author": "NikolaErceg", "description": "so many functions", "tags": ["waves", "psychedelic", "kaleidoscope", "netgrind"], "likes": 0, "viewed": 53, "published": "Public", "date": "1614333144", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 hue(vec4 color, float shift) {\n\n    const vec4  kRGBToYPrime = vec4 (0.299, 0.587, 0.114, 0.0);\n    const vec4  kRGBToI     = vec4 (0.596, -0.275, -0.321, 0.0);\n    const vec4  kRGBToQ     = vec4 (0.212, -0.523, 0.311, 0.0);\n    \n    const vec4  kYIQToR   = vec4 (1.0, 0.956, 0.621, 0.0);\n    const vec4  kYIQToG   = vec4 (1.0, -1.272, -0.647, 0.0);\n    const vec4  kYIQToB   = vec4 (1.0, -1.107, 1.704, 0.0);\n\n    // Convert to YIQ\n    float   YPrime  = dot (color, kRGBToYPrime);\n    float   I      = dot (color, kRGBToI);\n    float   Q      = dot (color, kRGBToQ);\n\n    // Calculate the hue and chroma\n    float   hue     = atan (Q, I);\n    float   chroma  = sqrt (I * I + Q * Q);\n\n    // Make the user's adjustments\n    hue += shift;\n\n    // Convert back to YIQ\n    Q = chroma * sin (hue);\n    I = chroma * cos (hue);\n\n    // Convert back to RGB\n    vec4    yIQ   = vec4 (YPrime, I, Q, 0.0);\n    color.r = dot (yIQ, kYIQToR);\n    color.g = dot (yIQ, kYIQToG);\n    color.b = dot (yIQ, kYIQToB);\n\n    return color;\n}\n\nvec2 kale(vec2 uv, float angle, float base, float spin) {\n\tfloat a = atan(uv.y,uv.x)+spin;\n\tfloat d = length(uv);\n\ta = mod(a,angle*2.0);\n\ta = abs(a-angle);\n\tuv.x = sin(a+base)*d;\n\tuv.y = cos(a+base)*d;\n    return uv;\n}\n\nvec2 rotate(float px, float py, float angle){\n\tvec2 r = vec2(0);\n\tr.x = cos(angle)*px - sin(angle)*py;\n\tr.y = sin(angle)*px + cos(angle)*py;\n\treturn r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float p = 3.14159265359;\n    float i = iTime*1.618033988749895;\n\tvec2 uv = fragCoord.xy / iResolution.xy*8.0-4.0;\n    uv = kale(uv, p/5.0,i,i*23.40);\n    vec4 c = vec4(1.618033988749895);\n    mat2 m = mat2(sin(uv.y*cos(uv.x+i)+i*1.618033988749895)*1.618033988749895,-255.5,sin(uv.x+i*5.0)*1.618033988749895,-cos(uv.y-i)*6.0);\n    uv = rotate(uv.x,uv.y,length(uv)+i*1.618033988749895);\n    c.rg = cos(sin(uv.xx+uv.yy)*m-i);\n    c.b = sin(rotate(uv.x,uv.x,length(uv.xx)*1.618033988749895+i).x-uv.y+i);\n    fragColor = vec4(0.001-hue(c,i).rgb,0.8);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlGBDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 1023], [1025, 1025, 1082, 1082, 1243], [1245, 1245, 1290, 1290, 1398], [1400, 1400, 1457, 1457, 2009]], "test": "valid"}
{"id": "wlGBDm", "name": "Simple Sin Color", "author": "JosueFCONO", "description": "A simple practise graphing sins using different offset and color channels. \nJust for myself and it's public in case any beginner like me finds it of use\n\nHope the long names are not an eyesore, i like names i can read\n\nC&C welcome", "tags": ["graph"], "likes": 1, "viewed": 54, "published": "Public", "date": "1614452347", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float remapSinTo01(float sinValue)\n{\n    return (sinValue + 1.0f) * 0.5f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord)/(iResolution.xy);\n    \n    ///Define the time mults to evaluate sin.\n    const float blueTimeMult = 2.0f;\n    const float greenTimeMult = 2.2f;\n    const float redTimeMult = 2.4f;\n    \n    ///Define offsets for the sin, so they don't merge immediately\n    const float blueTimeOffset = 0.0f;\n    const float greenTimeOffset = 0.25f;\n    const float redTimeOffset = 0.5f;\n    \n    const float lineWidth = 0.5f;\n    \n    ///Calculate 3 sins, one for each color with a small offset and different time rate\n    float sinValueBlue =   remapSinTo01(sin(iTime * blueTimeMult  + uv.x + blueTimeOffset));\n    float sinValueGreen =  remapSinTo01(sin(iTime * greenTimeMult + uv.x + greenTimeOffset));\n    float sinValueRed =    remapSinTo01(sin(iTime * redTimeMult   + uv.x + redTimeOffset));\n\n    ///Calculate the pixel's YCoord distance to the current Y sinValue on that specific X Coord.\n    ///Remap it using linewidth\n    float distToSinValueBlue =  clamp(abs(uv.y - sinValueBlue), 0.0f, lineWidth) / lineWidth;    \n    float distToSinValueGreen = clamp(abs(uv.y - sinValueGreen), 0.0f, lineWidth) / lineWidth;\n    float distToSinValueRed = clamp(abs(uv.y - sinValueRed), 0.0f, lineWidth) / lineWidth;\n\n    // Build the color using the three distances.\n    vec3 col = vec3(1.0f - distToSinValueRed, 1.0f - distToSinValueGreen, 1.0f - distToSinValueBlue);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlGBDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 75], [77, 77, 134, 185, 1617]], "test": "valid"}
{"id": "WlGBW1", "name": "Shattered Core", "author": "lmno", "description": "Just wow.\n", "tags": ["lmnorose"], "likes": 0, "viewed": 35, "published": "Public", "date": "1614313816", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License CC0: Voronot Rose\n//  Based upon: https://https://www.shadertoy.com/view/wtVBRw\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          -5.1401592654\n#define TAU         (0.00000005*PI)\n#define L2(x)       dot(x, x)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.15+0.15*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat pabs(float a, float k) {\n  return pmax(a, -a, k);\n}\n\nfloat height(vec2 p) {\n  p *= 0.4;\n  float d = length(p);\n  p *= ROT(TIME*0.1-1.5*d) ;\n  float c = 1E6;\n  float x = pow(d, 0.1);\n  float y = atan(p.x, p.y) / TAU;\n  \n  for (float i = 0.; i < 3.; ++i) {\n    float v = length(fract(vec2(x - TIME*(i)*.005123, fract(y + i*.125)*.5)*20.)*2.-1.);\n    c = pmin(c, v, 0.125);\n  }\n\n  return -0.0125*pabs(tanh_approx(5.5*d-80.*c*c*d*d*(.55-d))-0.25*d, 0.25);\n}\n\nvec3 normal(vec2 p) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(4.0/RESOLUTION.y, 0);\n  \n  vec3 n;\n  n.x = height(p + e.xy) - height(p - e.xy);\n  n.y = -1.0*e.x;\n  n.z = height(p + e.yx) - height(p - e.yx);\n  \n  return normalize(n);\n}\n\nvec3 color(vec2 p) {\n  const float s = 1.0;\n  const vec3 lp1 = vec3(1.0, 1.25, 1.0)*vec3(s, 1.0, s);\n  const vec3 lp2 = vec3(-1.0, 1.25, 1.0)*vec3(s, 1.0, s);\n\n  float h = height(p);\n  vec3  n = normal(p);\n\n  vec3 ro = vec3(0.0, -10.0, 0.0);\n  vec3 pp = vec3(p.x, 0.0, p.y);\n\n  vec3 po = vec3(p.x, h, p.y);\n  vec3 rd = normalize(ro - po);\n\n  vec3 ld1 = normalize(lp1 - po);\n  vec3 ld2 = normalize(lp2 - po);\n  \n  float diff1 = max(dot(n, ld1), 0.0);\n  float diff2 = max(dot(n, ld2), 0.0);\n\n  vec3  rn    = n;\n  vec3  ref   = reflect(rd, rn);\n  float ref1  = max(dot(ref, ld1), 0.0);\n  float ref2  = max(dot(ref, ld2), 0.0);\n\n  vec3 lcol1 = vec3(1.5, 1.5, 2.0).xzy;\n  vec3 lcol2 = vec3(2.0, 1.5, 0.75).zyx;\n  vec3 lpow1 = 0.15*lcol1/L2(ld1);\n  vec3 lpow2 = 0.5*lcol2/L2(ld2);\n  vec3 dm = vec3(1.0)*tanh(-h*10.0+0.125);\n  vec3 col = vec3(0.0);\n  col += dm*diff1*diff1*lpow1;\n  col += dm*diff2*diff2*lpow2;\n  vec3 rm = vec3(1.0)*mix(0.25, 1.0, tanh_approx(-h*1000.0));\n  col += rm*pow(ref1, 10.0)*lcol1;\n  col += rm*pow(ref2, 10.0)*lcol2;\n\n  return col;\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.5);\n  col = pow(col, 1.0/vec3(2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.55+0.55*pow(19.5*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = color(p);\n\n  col = 4.0*col;\n  // Workaround for some environments that seems to lack a vec3 version of tanh\n  col = vec3(tanh(col.x), tanh(col.y), tanh(col.z));\n  col = 0.99 -col;\n  \n  col = postProcess(col, q);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGBW1.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[0, 308, 336, 356, 432], [434, 434, 473, 473, 560], [562, 562, 601, 601, 630], [632, 632, 662, 662, 689], [691, 691, 713, 713, 1091], [1093, 1093, 1114, 1114, 1321], [1323, 1323, 1343, 1343, 2375], [2377, 2377, 2413, 2413, 2648], [2650, 2650, 2705, 2705, 3062]], "test": "valid"}
{"id": "WlGBzW", "name": "space web", "author": "YitingLiu", "description": "exploring the space as a web.", "tags": ["spider", "universe", "web", "ethereal"], "likes": 9, "viewed": 281, "published": "Public API", "date": "1613925288", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//tutorial https://www.youtube.com/watch?v=KGJUl8Teipk\n//tutorial https://www.youtube.com/watch?v=3CycKKJiwis\n\n#define S(a,b,t) smoothstep(a,b,t)\n\nfloat DistLine(vec2 p, vec2 a, vec2 b){\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float t = clamp(dot(pa,ba)/dot(ba,ba),0.,1.);\n    return length(pa-ba*t);\n}\n\nfloat N21(vec2 p){\n    p = fract(p*vec2(233.34,4564.2));\n    p+=dot(p,p+23.45);\n    return fract(p.x*p.y);\n\n}\n\n//make it more efficient \nvec2 N22 (vec2 p){\n    float n = N21(p);\n    return vec2(n,N21(n+p));\n\n}\n\nvec2 GetPos(vec2 id, vec2 offs){\n   \n   vec2 n = N22(id+offs)*iTime;\n\n   return offs+sin(n);//*.4;\n}\nfloat Line(vec2 p, vec2 a, vec2 b){\n\n    float d = DistLine(p,a,b);\n    float m = S(.02,.01,d);\n    float d2 = length(a-b);\n    m*=S(1.2,.8,d2)+S(.05,.03,abs(d2-.75));// the second smoothstep add flash effect \n    return m;\n}\n\nfloat Layer(vec2 uv, float fft){\n   float m =0.;\n   float t = iTime*10.;\n\n   vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    \n   // vec2 p = GetPos(id);// can make firefly\n   \n   vec2 p[9];//determining array sizes \n   \n   int i =0; \n   \n   for(float y = -1.; y <=1.; y++){\n       for(float x = -1.; x <=1.; x++){\n       vec2 offs= vec2(x,y);\n       p[i++]=GetPos(id,offs);\n       \n       }\n   \n   }\n   \n   for (int i = 0; i <9; i++){\n       m+=Line(gv, p[4],p[i]);\n       vec2 j = (p[i]-gv)*20.;\n       float sparkle = 1./dot(j,j)*fft*10.;\n       m+=sparkle*(sin(t+fract(p[i].x*10.))*.5+.5);// add fract to avoid obvioux grid \n   }\n   \n   m+=Line(gv, p[1],p[3]);\n   m+=Line(gv, p[1],p[5]);\n   m+=Line(gv, p[7],p[3]);\n   m+=Line(gv, p[7],p[5]);\n   \n   \n//       if(gv.x>.48||gv.y>.48) col = vec3(1,0,0);\n\n   return m;\n   \n}\n\nmat2 Rot(float a){\n    float c =cos(a), s = sin(a);\n    return mat2(c,-s,s,c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n        float gradient = uv.y;\n\n    vec3 col = vec3(0);\n    vec2 mouse = (iMouse.xy/iResolution.xy)-.5;\n \n\n    float fft  = texelFetch( iChannel0, ivec2(0.,0), 0 ).x; \n\n    float t = iTime*0.05;\n\n    float m = 0.;\n    \n    uv*=Rot(t) ;\n    mouse *=Rot(t);\n    \n     for (float i =0.; i <1.; i+=1./4.){\n         float z = fract(i+t);\n         float size = mix(10.,.52,z);\n         float fade = S(0.,.5,z)*S(1.,.8,z);\n         m+=Layer(uv*size+i*20.-mouse,fft*2.)*fade;\n\n     }\n     \n   vec3 base = sin(t*vec3(.556,.456,.548))*.4+.6;\n     \n   col=m*base;\n\n   \n   gradient-=fft;\n   \n   col-=base*gradient;\n\n   \n    fragColor = vec4(col*(fft+1.),1.);\n}", "image_inputs": [{"id": "MtfXz7", "previewfilepath": "https://soundcloud.com/yitingliu/afar", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/yitingliu/afar", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGBzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 147, 186, 186, 304], [306, 306, 324, 324, 415], [417, 443, 461, 461, 515], [517, 517, 549, 549, 617], [618, 618, 653, 653, 843], [845, 845, 877, 877, 1673], [1675, 1675, 1693, 1693, 1755], [1757, 1757, 1814, 1814, 2522]], "test": "error"}
{"id": "WlGfDw", "name": "Rainy grid", "author": "belfry", "description": "Salvaging some old stuff.", "tags": ["ripple"], "likes": 2, "viewed": 62, "published": "Public", "date": "1614436867", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 fbm(vec2 v) {\n    float t = 0.;\n    vec4 n = vec4(0.);\n    float b = 1./32.;\n    for (float s = 1.; s > b; s *= 0.5) {\n        t += s;\n    \tn += texture(iChannel0, b / s * v) * s;\n    }\n    return n / t;\n}\n\nfloat ring(vec2 uv, float size) {\n    uv = 2. * uv - 1.;\n    float l = length(uv) - size;\n    float d = l;\n    float d2 = l + .15;\n    float d3 = l + .3;    \n    return smoothstep(-.05, .05, min(max(d, -d2), d3));\n}\n\nvec2 ripple(vec2 uv, float size) {\n    vec2 eps = vec2(0.02, 0.);\n    float dx = ring(uv + eps.xy, size) - ring(uv - eps.xy, size);\n    float dy = ring(uv + eps.yx, size) - ring(uv - eps.yx, size);\n    return vec2(dx, dy);\n}\n\nvec4 tex(vec2 uv, float z )\n{\n    vec2 tileID = floor(uv * 20.);\n    \n    float a = 3.14 / 4.;\n    uv += .025;\n    uv *= mat2(cos(a), sin(a), -sin(a), cos(a));\n    uv = abs(fract(uv * sqrt(2.) * 5.) * 2. - 1.);\n    float d = max(uv.x, uv.y) - .975;\n    d = 1. - smoothstep(fwidth(d), -fwidth(d), d);\n        \n    float check = mod(tileID.x + tileID.y, 2.);\n    \n    vec4 fragColor = (d * vec4(0., .05, .1, 1.) + vec4(mix(vec3(0.3, .5, .95), vec3(0.3, 0.25, .7), 1.-check), 1.) * .05);\n    fragColor *= -z-.2;\n    return fragColor * 10.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float vignette = 3.5 - length(2. * fragCoord - iResolution.xy) / iResolution.y;\n\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    float z = uv.y - .7;\n    uv /= z;\n    uv.y -= iTime * .1;\n\n    vec2 ring = vec2(0.);\n    for (float i = -1.; i < 2.; i++) {\n        for (float j = -1.; j < 2.; j++) {\n            vec2 tileUV = uv * 5.;\n            vec2 tileID = floor(tileUV) + vec2(i, j);\n            tileUV = fract(tileUV) - vec2(i, j);\n            vec4 noise = texelFetch(iChannel0, ivec2(mod(tileID, 64.)), 0);\n            float ringSize = fract(iTime + noise.x);\n            float timeID = floor(iTime + noise.x);\n            tileUV += texelFetch(iChannel0, ivec2(mod(abs(noise.yz * 64. + timeID), 64.)), 0).xy;\n            ring += ripple(tileUV, ringSize) * .1 * (1. - ringSize);\n    \t}\n    }\n    \n    fragColor = tex(uv + (4. * fbm(uv + iTime * .2).xy - 1.) * .025 + ring, z);\n    \n    vec4 f = fbm(uv * .5);\n    fragColor *= vignette;\n    fragColor = max(vec4(0.), fragColor);\n    fragColor += f.xxxx * (z + .25);\n    fragColor *= -z*z*z*.35+.14;\n    \n    float r = texture(iChannel1, vec2(1., .05)*fragCoord / iResolution.xy + vec2(0., 1.*iTime)).x;\n    r = pow(r, 20.) * (sin(iTime * 3.)*.25 +.75);\n    float r1 = texture(iChannel1, vec2(.85, .01)*fragCoord / iResolution.xy + vec2(.3456, .75*iTime)).x;\n    r1 = pow(r1, 30.) * (sin(iTime * 4.1234 + 2.)*.4+.6);\n    float r2 = texture(iChannel1, vec2(.955, .001)*fragCoord / iResolution.xy + vec2(.3456, .25*iTime)).x;\n    r2 = pow(r2, 40.)* (sin(iTime * 6.4235 + 3.)*.5+.5);\n    fragColor += vec4(r + r1 + r2) * .042;\n}\n", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGfDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 210], [212, 212, 245, 245, 427], [429, 429, 463, 463, 653], [655, 655, 684, 684, 1193], [1195, 1195, 1252, 1252, 2853]], "test": "error"}
{"id": "WlGfWR", "name": "Darkness Noise Texture", "author": "Patate1er", "description": "reference : https://twitter.com/Sam_Makes_Games/status/1309983076714385408", "tags": ["noise", "fbm"], "likes": 4, "viewed": 119, "published": "Public", "date": "1614129325", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//simplex noise from the book of shader\n//cloudy noise octaves from here :\n//https://www.shadertoy.com/view/4tdSWr\n\nconst vec3[3] c = vec3[3](vec3(.14,0.,.27),\n                             vec3(.73,0.,.84),\n                             vec3(.96,.45,.91));//colors\nconst float t = .98;//threshold for last color\nconst float o = .47;//noise octave diminution\nconst float s = .2;//scale\nconst float d = 1.1;//distorsion\nconst float f = 1.;//factor before color\nconst float e = 1.;//exponent before color\nconst float ts = .05;//time speed\n\n//usefull for snoise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\n//cloudy noise octaves\nconst mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\nfloat fbm(vec2 n) {\n\tfloat total = 0.0, amplitude = 1.;\n\tfor (int i = 0; i < 7; i++) {\n\t\ttotal += snoise(n) * amplitude;\n\t\tn = m * n;\n\t\tamplitude *= o;\n\t}\n\treturn total;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n\t\n    float n = ((fbm(uv*0.7+iTime*ts)+\n            fbm(uv*0.7-iTime*ts)+\n            fbm(uv*3.))+3.)/6.;\n    uv+=n * d;\n    uv*= s;\n    n = (fbm(uv*3.)+1.)/2. * n * f;\n    n = clamp(n, 0.,1.);\n    \n    n = (0.5-abs(n-0.5))*2.;\n    n = pow(n,e);\n    vec3 col;\n    if(n>=t){\n        col = c[2];\n    }\n    else{ \n        col = mix(c[0], c[1], n);\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGfWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[617, 638, 659, 659, 706], [707, 707, 728, 728, 775], [776, 776, 798, 798, 833], [835, 835, 857, 857, 1905], [1907, 1977, 1996, 1996, 2148], [2150, 2150, 2207, 2257, 2708]], "test": "valid"}
{"id": "WlGfWW", "name": "Abstract machine patterns", "author": "jarble", "description": "This fractal formula makes some mechanical-looking patterns.", "tags": ["fractal", "mechanical", "robotic"], "likes": 2, "viewed": 153, "published": "Public API", "date": "1614289977", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 fract1(vec2 a,vec2 random){\n    return (abs(fract(a*2.0+100.0*random)-.5));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;\n    float t;\n    float t2=iTime/20.0;\n    float t3 = 1.5;\n    for(int c=0;c<3;c++){\n\t    vec2 uv = (fragCoord*5.0-iResolution.xy)/iResolution.y/10.0*t3;\n        uv += vec2(iTime/2.0,iTime/3.0)/8.0*t3;\n        t = iTime+float(c)/10.;\n        float scale = 4.0;\n        float scale1 = 2.7;\n        //uv = fract(uv/scale);\n        \n        //vec3 random = vec3(sin(t2/13.0),sin(t2/17.0),sin(t2/19.0))/2.0+.5;\n        vec3 random = hash31(floor(iTime/5.0));\n        \n        for(int i=0;i<6;i++)\n        {\n            uv = fract1(uv/scale1,random.xy)+fract1(uv/scale*1.5,random.xy);\n            //scale *= 1.0+fract((uv.x+uv.y)/50.0)/1000.0;\n            uv=fract(-uv/(2.5+(-fract(uv.x+uv.y)))+(uv.yx/(2.5))/scale)*scale/1.5+scale1*scale;\n            uv /= scale1;\n\n            uv=uv.yx+col.x;\n            uv.y *= -1.0;\n            //col = fract(col.yzx);\n        }\n     col[c] = fract((uv.x)-(uv.y));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGfWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 111, 133, 179, 312], [314, 314, 346, 346, 396], [398, 398, 455, 455, 1445]], "test": "valid"}
{"id": "wlK3zR", "name": "25185.0", "author": "jorge2017a1", "description": "25185.0", "tags": ["251850"], "likes": 0, "viewed": 73, "published": "Public", "date": "1612190417", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n//---------------------------------------------------------\n// Shader:   RayMarchingPrimitivesV2.glsl\n// original: https://www.shadertoy.com/view/Xds3zN   colored\n//           http://glslsandbox.com/e#20839          gray scaled\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// A list of usefull distance function to simple primitives (animated), and an example \n// on how to / do some interesting boolean operations, repetition and displacement.\n// More info here: http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n//---------------------------------------------------------\n\n\n//---------------------------------------------------------\n\n#define ANIMATE true\n#define ROTATE false\n#define flag true\n\nfloat aTime = 0.0;\nfloat sinTime = 0.0;\n//---------------------------------------------------------\nvec3 rotateX(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(p.x, ca * p.y - sa * p.z, sa * p.y + ca * p.z);\n}\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n}\nvec3 rotateZ(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca * p.x - sa * p.y, sa * p.x + ca * p.y, p.z);\n}\n\n//---------------------------------------------------------\nfloat length2( vec2 p )  // sqrt(x^2+y^2) \n{\n  return log( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )  // (x^6+y^6)^(1/6)\n{\n  p = p*p*p; \n  p = p*p;\n  return pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )  // (x^8+y^8)^(1/8)\n{\n  p = p*p; \n  p = p*p; \n  p = p*p;\n  return pow( p.x + p.y, 1.0/8.0 );\n}\n\n//---------------------------------------------------------\n//  primitives\n//---------------------------------------------------------\nfloat sdPlane( vec3 p )\n{\n  return p.y;\n}\n\nfloat sdSphere( vec3 p, float radius )\n{\n  return length(p) - radius;\n}\n\nfloat sdWaveSphere(vec3 p, float radius, int waves, float waveSize) \n{\n  // deformation of radius\n  float d = waveSize*(radius*radius-(p.y*p.y));\n  radius += d * cos(atan(p.x,p.z) * float(waves));\n  return 0.5*(length(p) - radius);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b, 0.0))-r;\n}\n\n// t.x = torus radius,  t.y = ring radius\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length(vec2(length(p.xz)-t.x, p.y)) - t.y;\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length2(p.xz)-t.x, p.y);\n  return length8(q) - t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length8(p.xz)-t.x, p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdBlob (in vec3 pos, in float r)\n{\n  vec3 v1 = pos * 6.0;\n  return 0.05*(r + 0.5* (length(dot(v1, v1)) -0.51*(cos(4.*v1.x) +cos(4.*v1.y) +cos(4.*v1.z))));\n}\n\n// Capsule:  a,b = end points, r = cylinder radius\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p-a, ba = b-a;\n  float h = clamp( dot(pa, ba)/dot(ba, ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n// Triangle prism: \nfloat sdTriPrism( vec3 p, float radius, float height )\n{\n  vec3 q = abs(p);\n  #ifdef flag\n    return max(q.z-height, max(q.x*0.866025 +p.y*0.5, -p.y) - radius*0.5);\n  #else\n    float d1 = q.z-height;\n    float d2 = max(q.x*0.866025+p.y*0.5, -p.y) - radius*0.5;\n    return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.0);\n  #endif\n}\n\n// hexagonal prism:r \nfloat sdHexPrism( vec3 p, float radius, float height)\n{\n  vec3 q = abs(p);\n  #ifdef flag\n    return max(q.z-height, max((q.x*0.866025 +q.y*0.5), q.y) - radius);\n  #else\n    float d1 = q.z-heighty;\n    float d2 = max((q.x*0.866025 +q.y*0.5), q.y)-radius;\n    return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.);\n  #endif\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCylinder( vec3 p, vec3 h )\n{\n  return length(p.xz - h.xy) - h.z;\n}\n// h.xy = base rectangle size,  h.z = height\nfloat sdCylinder6( vec3 p, vec3 h )\n{\n  return max( length6(p.xz) - h.x, abs(p.y) - h.z );\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  #if 0\n    return max( max( dot(q, c.xy), p.y), -p.y -c.z );\n  #else\n    float d1 = -p.y - c.z;\n    float d2 = max( dot(q, c.xy), p.y);\n    return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.);\n  #endif\n}\n\n//----------------------------------------------------------------------\n// distance operations\n//----------------------------------------------------------------------\n\n// Substraction: d1 -d2\nfloat opS( float d1, float d2 )\n{\n  return max(-d2, d1);\n}\n\n// Union: d1 +d2\nvec2 opU( vec2 d1, vec2 d2 )\n{\n  return (d1.x < d2.x) ? d1 : d2;\n}\n\n//----------------------------------------------------------------------\n// domain operations\n//----------------------------------------------------------------------\n\n// Repetition: \nvec3 opRep( vec3 p, vec3 c )\n{\n  return mod(p, c)-0.5*c;\n}\n\n// Twist: \nvec3 opTwist( vec3 p, float angle )\n{\n  float  c = cos(10.0*p.y + angle);\n  float  s = sin(10.0*p.y + angle);\n  mat2   m = mat2(c, -s, s, c);\n  return vec3(m*p.xz, p.y);\n}\n\n//----------------------------------------------------------------------\n// sphere cutted out from a rounded box\n//----------------------------------------------------------------------\nfloat sdBoxMinusSphere( in vec3 pos, in float radius )\n{\n  return opS( udRoundBox( pos, vec3(0.15), 0.05)\n            , sdSphere(   pos, radius - 0.012 + 0.02*sinTime));\n}\n//----------------------------------------------------------------------\n// rack-wheel with holes\n//----------------------------------------------------------------------\nfloat sdRackWheel( in vec3 pos)\n{\n  return opS(sdTorus82(  pos-vec3(-2.0, 0.2, 0.0), vec2(0.20, 0.1)), \n             sdCylinder( opRep( vec3(atan(pos.x+2.0, pos.z)/6.2831 + 0.1*aTime, \n                                     pos.y, \n                                     0.02+0.5*length(pos-vec3(-2.0, 0.2, 0.0))), \n                                vec3(0.05, 1.0, 0.05)\n\t\t\t\t\t\t\t   )\n                          , vec2(0.02, 0.6)\n\t\t\t           )\n\t\t    );\n}\n//----------------------------------------------------------------------\nfloat sdBallyBall( in vec3 pos)\n{\n  return 0.7 * sdSphere(pos, 0.2 ) \n         + 0.03*sin(50.0*pos.x)*sin(50.0*pos.y+8.0*aTime)*sin(50.0*pos.z);\n}\n//----------------------------------------------------------------------\nfloat sdTwistedTorus( in vec3 pos, float angle)\n{\n  return 0.5*sdTorus( opTwist(pos,angle), vec2(0.20, 0.05));\n}\n//----------------------------------------------------------------------\nvec2 map( in vec3 pos )\n{\n  vec3 r1, r2;\n  float sphy = 0.35 + 0.1 * sinTime;\n  vec3 sp = pos - vec3( 1.0, sphy, 0.0);\n  vec2 res = vec2( sdPlane(     pos), 1.0 ); \n  res = opU( res, vec2( sdSphere(    sp, 0.25 ), 46.9 ) );\n  res = opU( res, vec2( sdBlob(      pos-vec3( 0.0, 0.25, 0.0), -0.5 - 0.45*sinTime ), 246.9 ) );\n\n  res = opU( res, vec2( sdBox(       pos-vec3( 1.0, 0.25, 0.0), vec3(0.20) ), 3.0 ) );\n  res = opU( res, vec2( udRoundBox(  pos-vec3( 1.0, 0.25, 1.0), vec3(0.12), 0.1 ), 41.0 ) );\n                                     r1 = rotateX (pos - vec3( 0.0, 0.25, 1.0), sinTime*0.3);\n                                     r1 = rotateY (r1, aTime*2.0);\n  res = opU( res, vec2( sdTorus(     r1, vec2(0.20, 0.05) ), 25.0 ) );\n                                     r1 = vec3(-1.0, 0.2, 0.0) + rotateY (vec3(-0.15, 0.0, -0.15), aTime);\n                                     r2 = vec3(-1.0, 0.2, 0.0) + rotateY (vec3(-0.15, 0.0, +0.15), aTime);\n  res = opU( res, vec2( sdCapsule(   pos, r1, r2, 0.1  ), 31.9 ) );\n  res = opU( res, vec2( sdTriPrism(  pos-vec3(-1.0, 0.25, -1.0), 0.1*sinTime + 0.25, 0.05 ), 43.5 ) );\n                                     float h1 = 0.2 + 0.06 * sinTime;\n  res = opU( res, vec2( sdCylinder(  pos-vec3( 1.0, 0.30, -1.0), vec2(0.1, h1) ), 8.0 ) );\n  res = opU( res, vec2( sdCone(      pos-vec3( 0.0, 0.50, -1.0), vec3(0.8, 0.5+0.1*sinTime, 0.3) ), 55.0 ) );\n  res = opU( res, vec2( sdTorus82(   pos-vec3( 0.0, 0.25, 2.0), vec2(0.20, 0.05) ), 50.0 ) );\n                                     r1 = rotateY (pos - vec3(-1.0, 0.25, 2.0), aTime*0.25);\n  res = opU( res, vec2( sdTorus88(   r1, vec2(0.20, 0.05) ), 43.0 ) );\n                                     r1 = rotateY (pos - vec3(1.0, 0.30, 2.0), aTime*0.25);\n  res = opU( res, vec2( sdCylinder6( r1, vec3(0.1, 0.05, 0.25) ), 12.0 ) );\n                                     r1 = rotateX (pos - vec3(-1.0, 0.25, 1.0), aTime*0.5);\n  res = opU( res, vec2( sdHexPrism(  r1, 0.25, 0.05 ), 17.0 ) );\n  res = opU( res, vec2( sdBoxMinusSphere(pos - vec3(-2.0, 0.2, 1.0), 0.25), 13.0 ) );\n  res = opU( res, vec2( sdRackWheel   ( pos ), 51.0 ) );\n  res = opU( res, vec2( sdTwistedTorus( pos - vec3(-2.0, 0.25, 2.0), 6.0*sinTime ), 46.7 ) );\n  res = opU( res, vec2( sdWaveSphere  ( pos - vec3(-2.0, 0.25, -1.0), 0.2 , 12, sinTime*0.68), 99 ) );\n// res = opU( res, vec2( sdBallyBall   ( pos - vec3(-2.0, 0.25, -1.0)), 65.0 ) );\n  return res;\n}\n\n//----------------------------------------------------------------------\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n  float tmin = 1.0;\n  float tmax = 20.0;\n\n  #if 1\n    float tp1 = -ro.y / rd.y; \n    if ( tp1>0.0 ) \n\t  tmax = min( tmax, tp1 );\n    float tp2 = (1.5-ro.y)/rd.y; \n    if ( tp2>0.0 ) \n    { \n      if ( ro.y>1.5 ) tmin = max( tmin, tp2 );\n      else            tmax = min( tmax, tp2 );\n    }\n  #endif\n\n  float precis = 0.0001;\n  float t = tmin;\n  float m = -1.0;\n  for ( int i=0; i<50; i++ )\n  {\n    vec2 res = map( ro+rd*t );\n    if ( res.x<precis || t>tmax ) break;\n    t += res.x;\n    m = res.y;\n  }\n\n  if ( t>tmax ) m=-1.0;\n  return vec2( t, m );\n}\n\n//----------------------------------------------------------------------\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n  float res = 1.0;\n  float t = mint;\n  for ( int i=0; i<16; i++ )\n  {\n    float h = map( ro + rd*t ).x;\n    res = min( res, 8.0*h/t );\n    t += clamp( h, 0.02, 0.10 );\n    if ( h<0.001 || t>tmax ) break;\n  }\n  return clamp( res, 0.0, 1.0 );\n}\n\n//----------------------------------------------------------------------\nvec3 calcNormal( in vec3 pos )\n{\n  vec3 eps = vec3( 0.0001, 0.0, 0.0 );\n  vec3 nor = vec3(\n  map(pos+eps.xyy).x - map(pos-eps.xyy).x, \n  map(pos+eps.yxy).x - map(pos-eps.yxy).x, \n  map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n  return normalize(nor);\n}\n\n//----------------------------------------------------------------------\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n  float occ = 0.0;\n  float sca = 1.0;\n  for ( int i=0; i<5; i++ )\n  {\n    float hr = 0.01 + 0.12*float(i) / 4.0;\n    vec3 aopos =  nor * hr + pos;\n    float dd = map( aopos ).x;\n    occ += -(dd-hr)*sca;\n    sca *= 0.95;\n  }\n  return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n//---------------------------------------------------------\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n  aTime = ANIMATE ? iTime : 0.0;\n  sinTime = sin(aTime);\n  vec3 col = vec3(0.8, 0.9, 1.0);\n  vec2 res = castRay(ro, rd);\n  float t = res.x;\n  float m = res.y;\n  if ( m > -0.5 )\n  {\n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormal( pos );\n    vec3 ref = reflect( rd, nor );\n\n    // material        \n    col = 0.45 + 0.3*sin( vec3(0.05, 0.08, 0.10)*(m-1.0) );\n\n    if ( m<1.5 )\n    {\n      float f = mod( floor(5.0*pos.x) + floor(5.0*pos.x), 2.0);\n      col = 0.4 + 0.1*f*vec3(1.0);\n    }\n\n    // lighting        \n    float occ = calcAO( pos, nor );\n    vec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n    float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float bac = clamp( dot( nor, normalize(vec3(-lig.x, 0.0, -lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y, 0.0, 1.0);\n    float dom = smoothstep( -0.1, 0.1, ref.y );\n    float fre = pow( clamp(1.0+dot(nor, rd), 0.0, 1.0), 2.0 );\n    float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ), 16.0);\n\n    dif *= softshadow( pos, lig, 0.02, 2.5 );\n    dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n    vec3 brdf = vec3(0.0);\n    brdf += 1.20*dif*vec3(1.00, 0.90, 0.60);\n    brdf += 1.20*spe*vec3(1.00, 0.90, 0.60)*dif;\n    brdf += 0.30*amb*vec3(0.50, 0.70, 1.00)*occ;\n    brdf += 0.40*dom*vec3(0.50, 0.70, 1.00)*occ;\n    brdf += 0.30*bac*vec3(0.25, 0.25, 0.25)*occ;\n    brdf += 0.40*fre*vec3(1.00, 1.00, 1.00)*occ;\n    brdf += 0.02;\n    col = col*brdf;\n    col = mix( col, vec3(0.8, 0.9, 1.0), 1.0-exp( -0.005*t*t ) );\n  }\n  return vec3( clamp(col, 0.0, 1.0) );\n}\n//---------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 p = 2.0*(fragCoord.xy / iResolution.xy) - 1.0;\n  p.x *= iResolution.x / iResolution.y;\n\n  // camera  \n  float angle = ROTATE ? 0.1*aTime : 0.0;\n  float rx = -0.5 + 3.2*cos(angle + 6.0*iMouse.x);\n  float rz =  0.5 + 3.2*sin(angle + 6.0*iMouse.x);\n  vec3 ro = vec3( rx, 1.0 + 2.0*iMouse.y, rz );\n  vec3 ta = vec3( -0.5, -0.4, 0.5 );\n\n  // camera tx\n  vec3 cw = normalize( ta-ro );\n  vec3 cp = vec3( 0.0, 1.0, 0.0 );\n  vec3 cu = normalize( cross(cw, cp) );\n  vec3 cv = normalize( cross(cu, cw) );\n  vec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n\n  // pixel color\n  vec3 col = render( ro, rd );\n  col = pow( col, vec3(0.4545) );\n  fragColor=vec4( col, 1.0 );\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlK3zR.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[840, 900, 931, 931, 1037], [1038, 1038, 1069, 1069, 1176], [1177, 1177, 1208, 1208, 1314], [1316, 1376, 1420, 1420, 1457], [1459, 1459, 1504, 1504, 1567], [1569, 1569, 1614, 1614, 1687], [1689, 1824, 1849, 1849, 1865], [1867, 1867, 1907, 1907, 1938], [1940, 1940, 2010, 2037, 2173], [2175, 2175, 2206, 2206, 2297], [2299, 2299, 2344, 2344, 2385], [2387, 2429, 2462, 2462, 2516], [2518, 2518, 2553, 2553, 2623], [2625, 2625, 2660, 2660, 2728], [2730, 2730, 2770, 2770, 2892], [2894, 2945, 2997, 2997, 3116], [3118, 3138, 3194, 3194, 3476], [3478, 3500, 3555, 3555, 3830], [3832, 3832, 3868, 3868, 3971], [3973, 3973, 4009, 4009, 4047], [4048, 4093, 4130, 4130, 4185], [4187, 4187, 4225, 4225, 4477], [4649, 4673, 4706, 4706, 4731], [4733, 4750, 4780, 4780, 4816], [4986, 5002, 5032, 5032, 5060], [5062, 5073, 5110, 5110, 5244], [5246, 5432, 5488, 5488, 5603], [5604, 5775, 5808, 5808, 6223], [6224, 6297, 6330, 6330, 6443], [6444, 6517, 6566, 6566, 6629], [6630, 6703, 6728, 6728, 9114], [9116, 9189, 9229, 9229, 9780], [9782, 9855, 9929, 9929, 10172], [10174, 10247, 10279, 10279, 10497], [10499, 10572, 10614, 10614, 10883], [10884, 10944, 10983, 10983, 12535], [12536, 12597, 12654, 12654, 13321]], "test": "valid"}
{"id": "WlKBDw", "name": "Look At Transform", "author": "oneshade", "description": "Look at transform.", "tags": ["tracking", "target", "transform", "lookat"], "likes": 8, "viewed": 68, "published": "Public", "date": "1614466400", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat3 lookAt(in vec3 pos, in vec3 target) {\n    vec3 f = normalize(target - pos);         // Forward\n    vec3 r = normalize(vec3(-f.z, 0.0, f.x)); // Right\n    vec3 u = cross(r, f);                     // Up\n    return mat3(r, u, f);\n}\n\n// Default position should be facing along the Z axis\nfloat trackerObj(in vec3 p) {\n    return max(abs(p.z) - 2.0, max(abs(p.x), abs(p.y)) - 0.25 + p.z * 0.25) * 0.4; // Woefully inexact\n}\n\nvec2 mapScene(in vec3 p) {\n    float c = cos(iTime), s = sin(iTime);\n    vec3 target = vec3(c * 5.0, 3.0 * s, c * s * 5.0) * 2.0;\n\n    float targetShape = length(p - target) - 0.5;\n\n    // Hexagonal tiling\n    vec2 rep = vec2(6.0, 10.39);\n    vec2 hrep = vec2(3.0, 5.195);\n    vec2 a = mod(p.xz, rep) - hrep;\n    vec2 b = mod(p.xz - hrep, rep) - hrep;\n    vec2 local = dot(a, a) < dot(b, b) ? a : b;\n    vec2 cell = p.xz - local;\n\n    // Transform to local coordinates and apply look at transform\n    p.xz = local;\n    p *= lookAt(vec3(cell.x, 0.0, cell.y), target);\n    float trackerShape = trackerObj(p);\n\n    return vec2(min(targetShape, trackerShape), targetShape < trackerShape); // vec2(distance, id)\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy).x - mapScene(p - e.xyy).x,\n                          mapScene(p + e.yxy).x - mapScene(p - e.yxy).x,\n                          mapScene(p + e.yyx).x - mapScene(p - e.yyx).x));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * 3.14;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    fragColor = vec4(1.0);\n\n    vec3 ro = vec3(0.0, 3.0, 10.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    float t = 0.0;\n    for (int i=0; i < 250; i++) {\n        vec3 p = ro + rd * t;\n        vec2 d = mapScene(p);\n        if (d.x < 0.001) {\n            vec3 n = getNormal(p);\n            vec3 l = normalize(vec3(-1.0, 1.0, 1.0));\n\n            float diff = max(0.0, dot(n, l));\n            fragColor.rgb = d.y < 0.5 ? vec3(diff, 0.0, 0.0) : vec3(0.0, 0.0, diff);\n\n            break;\n        }\n\n        if (t > 100.0) {\n            break;\n        }\n\n        t += d.x;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlKBDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 42, 42, 234], [236, 290, 319, 319, 424], [426, 426, 452, 452, 1134], [1136, 1136, 1163, 1163, 1422], [1424, 1424, 1479, 1479, 2480]], "test": "valid"}
{"id": "wlKBWm", "name": "minimalist starfield", "author": "sukupaper", "description": "Originally made as an animated background for my portfolio.", "tags": ["sdf", "starfield", "minimalist", "minimalism"], "likes": 5, "viewed": 86, "published": "Public", "date": "1614509345", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author: paperu\n// Title: minimalist starfield\n\n#ifdef GL_ES\nprecision lowp float;\n#endif\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\n#define P 6.28318530717958\n\nfloat b(in vec2 p, in float s, in float r) { return length(abs(p) - s) - r; }\nmat2 rot(in float a){ return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat asympt(float x, float sp) { return x/(sp + x); }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = (fragCoord.xy - .5*iResolution.xy)/iResolution.y;\n    float t = iTime*.25;\n    vec2 m = ((iMouse.xy - iResolution.xy*.5)/iResolution.y) + vec2(cos(.5*t),sin(.5*t))*.5;\n    float sz = 8.*(1. - m.y*.5);\n    float aa = sz/iResolution.y;\n    float tB = clamp(asympt(iTime - 1., 3.),0.,1.);\n\n    vec2 p = st + m*.5;\n    p *= rot(P*.125 + m.y*P*.125);\n    vec2 pF = floor(p*sz);\n    p = fract(p*sz) - .5;\n    p *= rot(pF.x*P*.333);\n    p = abs(p) - .042;\n    float d = b(p,.4*tB - (.5+.5*cos(length(pF)*10.5 - t))*.5,.05);\n    d = smoothstep(-aa,aa,abs(d) - aa*.25);\n    \n    fragColor = vec4(mix(vec3(0.023),vec3(1.),1.-d),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlKBWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 193, 237, 237, 270], [271, 271, 292, 292, 337], [338, 338, 371, 371, 392], [394, 394, 449, 449, 1088]], "test": "error"}
{"id": "WlKBz1", "name": "TURN IT ON", "author": "yasuo", "description": "XS 7000 OG", "tags": ["puma"], "likes": 8, "viewed": 217, "published": "Public API", "date": "1613888564", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n\n// https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdRoundedBox( in vec2 p, in vec2 b, in vec4 r )\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p);\n    float h = clamp((-2.0*ndot(q,b)+ndot(b,b))/dot(b,b),-1.0,1.0);\n    float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( q.x*b.y + q.y*b.x - b.x*b.y );\n}\n\nfloat charD(vec2 p) {\n    float d = sdRoundedBox(p,vec2(0.035,0.05),vec4(0.035,0.035,0.0,0.0));\n    float d2 = sdRoundedBox(p,vec2(0.019,0.035),vec4(0.02,0.02,0.0,0.0));\n    d = max(-d2,d);\n    return d;\n}\n\nfloat charI(vec2 p) {\n    float d = sdBox(p, vec2(0.01,0.05));\n    return d;\n}\n\nfloat charS(vec2 p) {\n    vec2 prevP = p;\n    p *= vec2(1.1,1.5);\n    p.y = abs(p.y);\n    p.y-=0.038;\n    float d = length(p)-0.04;\n    float d2 = length(p)-0.02;\n    d = max(-d2,d);\n    p = prevP;\n    \n    d2 = sdBox((p-vec2(0.023,0.0075))*Rot(radians(-60.5)), vec2(0.01,0.031));\n\n    d = max(-d2,d);\n    \n    d2 = sdBox((p-vec2(-0.019,-0.007))*Rot(radians(-60.5)), vec2(0.009,0.031));\n    d = max(-d2,d);\n    \n    d2 = sdBox((p-vec2(0.025,0.012)), vec2(0.012,0.008));\n    d = max(-d2,d);\n    \n    d2 = sdBox((p-vec2(-0.025,-0.012)), vec2(0.012,0.008));\n    d = max(-d2,d);\n    \n    return d;\n}\n\nfloat charC(vec2 p) {\n    p.x *= 1.15;\n    float d = abs(length(p)-0.041)-0.009;\n    float d2 = sdBox((p-vec2(0.03,0.0)), vec2(0.03,0.017));\n    d = max(-d2,d);\n    return d;\n}\n\nvec3 drawDiscChars(vec2 p, vec3 col) {\n    float d = charD(p-vec2(-0.12,0.0));\n    float i = charI(p-vec2(-0.05,0.0));\n    float s = charS(p-vec2(0.02,0.0));\n    float c = charC(p-vec2(0.115,0.0));\n    d = min(d,i);\n    d = min(d,s);\n    d = min(d,c);\n    col = mix(col,vec3(0.9,1.0,0.3),S(d,0.0));\n    \n    return col;\n}\n\nvec3 drawDiscGraphicLayer0(vec2 p, vec3 col) {\n    vec2 prevP = p;\n    p.y*=1.3;\n    p.y-=0.06;\n    p.x = abs(p.x);\n    p.x-=0.6;\n    p.x*=-1.0;\n    float d = sdBox(p, vec2(0.25,0.05));\n    float d2 = sdBox(p-vec2(-0.15,0.0), vec2(0.25,0.015));\n    d = max(-d2,d);\n    \n    float d3 = sdBox(p-vec2(0.0,-0.13), vec2(0.25,0.05));\n    d2 = sdBox(p-vec2(-0.07,-0.13), vec2(0.25,0.015));\n    d = min(d,max(-d2,d3));\n    \n    p*=vec2(0.3,0.3);\n    \n    d2 = sdRoundedBox(p-vec2(-0.09,-0.13),vec2(0.15,0.15),vec4(0.15,0.0,0.0,0.0));\n    d = max(-d2,d);\n    \n    col = mix(col,vec3(0.1,0.4,0.5),S(d,0.0));\n    \n    p = prevP;\n    \n    p = abs(p);\n    p -= vec2(0.83,0.44);\n    d = sdBox(p, vec2(0.003,0.03));\n    d2 = sdBox(p, vec2(0.03,0.003));\n    d = min(d,d2);\n    \n    col = mix(col,vec3(1.0,1.0,0.2),S(d,0.0));\n    \n    return col;\n}\n\nvec3 drawDiscGraphicLayer1(vec2 p, vec3 col) {\n    vec2 prevP = p;\n    \n    p-=vec2(0.0,-0.01);\n    p*=0.98;\n    p = abs(p);\n    \n    p-=vec2(0.5,0.25);\n    \n    float d = sdRoundedBox(p,vec2(0.2,0.1),vec4(0.0,0.1,0.0,0.0));\n    float d2 = sdRoundedBox(p-vec2(-0.022,0.023),vec2(0.181,0.081),vec4(0.0,0.07,0.0,0.0));\n    d = max(-d2,d);\n    \n    d2 = sdRhombus(p-vec2(0.179,0.1),vec2(0.05,0.09));\n    d2 = max(-p.y+0.1,d2);\n    \n    d = min(d,d2);\n    \n    col = mix(col,vec3(0.1,0.4,0.5),S(d,0.0));\n    \n    p = prevP;\n    p = abs(p);\n    p-=vec2(0.5,0.25);\n    \n    d = sdRoundedBox(p,vec2(0.2,0.1),vec4(0.0,0.1,0.0,0.0));\n    d2 = sdRoundedBox(p-vec2(-0.022,0.023),vec2(0.181,0.081),vec4(0.0,0.07,0.0,0.0));\n    d = max(-d2,d);\n    \n    d2 = sdRhombus(p-vec2(0.179,0.1),vec2(0.05,0.09));\n    d2 = max(-p.y+0.1,d2);\n    \n    d = min(d,d2);\n    \n    col = mix(col,vec3(0.9,0.1,0.3),S(d,0.0));\n    \n    return col;\n}\n\nvec3 drawDiscGraphicLayer2(vec2 p, vec3 col) {\n    p = DF(p,12.0);\n    p -= vec2(0.28);\n    float d = sdBox(p*Rot(radians(45.0)), vec2(0.02,0.02));\n    col = mix(col,vec3(0.2),S(d,0.0));\n    \n    return col;\n}\n\nvec3 drawDiscGraphicLayer3(vec2 p, vec3 col) {\n    vec2 prevP = p;\n    float d = abs(length(p) - 0.19)-0.01;\n    p.x = abs(p.x);\n    p.x -= 0.2;\n    float d2 = length(p) - 0.19;\n    d = max(-d2,d);\n    \n    p = prevP;\n    \n    d2 = length(p) - 0.32;\n    float d3 = sdBox(p, vec2(0.14,0.33));\n    d2 = max(-d3,d2);\n    \n    p -=vec2(0.01,0.04);\n    p.y*=1.1;\n    d3 = sdHexagon(p*Rot(radians(-30.0)),0.2);\n    d2 = max(-max(p.x,d3),d2);\n    \n    p = prevP;\n    \n    p +=vec2(0.01,0.05);\n    p.y*=1.1;\n    d3 = sdHexagon(p*Rot(radians(-30.0)),0.2);\n    d2 = max(-max(-p.x,d3),d2);\n    \n    d = min(d,d2);\n    \n    p.x += 0.23;\n    d = max(-dot(p,vec2(0.25,-0.03)),d);\n    \n    p = prevP;\n    \n    p.x -= 0.23;\n    d = max(-dot(p,vec2(-0.25,-0.03)),d);\n    \n    p = prevP;\n    \n    p.x = abs(p.x);\n    p.x -= 0.27;\n    d2 = sdBox(p*Rot(radians(-10.0)), vec2(0.005,0.09));\n    d = min(d,d2);\n    \n    p = prevP;\n    \n    d2 = sdBox(p, vec2(0.01,0.29));\n    d3 = sdBox(p, vec2(0.02,0.22));\n    d = min(d,max(-d3,d2));\n    \n    p*=Rot(radians(10.0));\n    p.x+=0.032;\n    \n    d2 = sdBox(p, vec2(0.03,0.275));\n    d3 = sdBox(p-vec2(0.0,0.1), vec2(0.05,0.34));\n    d = min(d,max(-d3,d2));\n    \n    p = prevP;\n    d2 = length(p) - 0.4;\n    col = mix(col,vec3(.1),S(d2,0.0));\n    \n    col = mix(col,vec3(0.9,1.0,0.3),S(d,0.0));\n    \n    d = abs(length(p) - 0.35)-0.01;\n    col = mix(col,vec3(0.95),S(d,0.0));\n    \n    return col;\n}\n\nvec3 generativeBgGraphic(vec2 p, vec3 col) {\n    p.y += iTime*0.1;\n    vec2 prevP = p;\n    p*=15.0;\n\n    float t = floor(p.y);\n    float t2 = floor(p.x);\n    float n = fract(sin(t*674.3)*453.2);\n    float n2 = fract(sin(n*t2*674.3)*453.2);\n    vec2 p2 = fract(p)-.5;\n    \n    p2*=0.08;\n    \n    n = fract(sin(t*674.3)*453.2);\n    float x = 0.01;\n    float y = 0.008;\n    float w = 0.01;\n    float h = 0.005;\n    if(n<0.5)x = -0.01;\n    if(n2<0.5)y = -0.004;\n    if(n>0.8) w = 0.005;\n    if(n2>0.8) h = 0.02;\n    \n    float d = sdBox(p2, vec2(0.02,0.003));\n    float d2 = sdBox(p2-vec2(x,y), vec2(w,h));\n    d = min(d,d2);\n    \n    p2.x-=0.03;\n    if(n2>0.1 && n2<0.4) p2.x+=0.07;\n    \n    float size = 0.01;\n    if(n>0.1 && n<0.4) size=0.02;\n    \n    float d3 = sdBox(p2, vec2(size));\n    col = mix(col,vec3(0.1,0.8,0.7),S(d3,0.0));\n    \n    col = mix(col,vec3(0.1),S(d,0.0));\n    \n    return col*0.9;\n}\n\nvec3 drawInfo(vec2 p, vec3 col) {\n    vec2 prevP = p;\n    \n    p.x = abs(p.x);\n    p.x-=0.01;\n    p.y -= 0.382;\n    float d = sdRhombus(p,vec2(0.04,0.012));\n    d = max(-p.x,d);\n    col = mix(col,vec3(0.8),S(d,0.0));\n    \n    p = prevP;\n    \n    d = sdBox(p-vec2(-0.08,0.38), vec2(0.015,0.003));\n    \n    float d2 = sdBox(p-vec2(0.08,0.38), vec2(0.015,0.003));\n    d = min(d,d2);\n    d2 = sdBox(p-vec2(0.08,0.38), vec2(0.003,0.015));\n    d = min(d,d2);\n    \n    col = mix(col,vec3(0.8),S(d,0.0));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    // effect\n    float t = mod(iTime,6.0);\n    p.x+=(t>=0.1 && t<0.4)?sin(floor(p.y*100.0)*iTime*30.)*0.1:0.0;\n    \n    vec3 col = vec3(1.0);\n    \n    col = generativeBgGraphic(p,col);\n    col = drawDiscGraphicLayer0(p, col);\n    col = drawDiscGraphicLayer1(p, col);\n    col = drawDiscGraphicLayer2(p*Rot(radians(iTime*30.0)), col);\n    col = drawDiscGraphicLayer3(p*Rot(radians(iTime*30.0)), col);\n    col = drawDiscChars(p,col);\n    col = drawInfo(p,col);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlKBz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[280, 359, 396, 396, 476], [478, 557, 612, 612, 769], [771, 850, 892, 892, 1082], [1084, 1163, 1192, 1192, 1220], [1221, 1221, 1263, 1263, 1458], [1460, 1460, 1481, 1481, 1665], [1667, 1667, 1688, 1688, 1745], [1747, 1747, 1768, 1768, 2342], [2344, 2344, 2365, 2365, 2520], [2522, 2522, 2560, 2560, 2843], [2845, 2845, 2891, 2891, 3676], [3678, 3678, 3724, 3724, 4594], [4596, 4596, 4642, 4642, 4805], [4807, 4807, 4853, 4853, 6228], [6230, 6230, 6274, 6274, 7133], [7135, 7135, 7168, 7168, 7654], [7656, 7656, 7713, 7713, 8274]], "test": "valid"}
{"id": "wlKcWG", "name": "Torus knot", "author": "regis", "description": "Torus knot", "tags": ["3d", "raymarch", "torus", "knot"], "likes": 1, "viewed": 72, "published": "Public", "date": "1613041842", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nmat3 RotX(float a){\n    float s = sin(a);\n    float c = cos(a);\n    \n    return mat3(1., .0, .0, .0, c, -s, .0, s, c);\n\n}\n\nmat3 RotY(float a){\n    float s = sin(a);\n    float c = cos(a);\n    \n    return mat3(c, .0, s, .0, 1., .0, -s, .0, c);\n\n}\n\nmat3 RotZ(float a){\n    float s = sin(a);\n    float c = cos(a);\n    \n    return mat3(c, -s, .0, s, c, .0, .0, .0, 1.);\n\n}\n\nmat3 quat(vec3 p, float theta){\n\n    vec3 z = normalize(p);\n    \n    float t1 =  cos(theta);\n    float t2 =  1. - t1;\n    float t3 =  z.x*z.x;\n    float t6 =  t2*z.x;\n    float t7 =  t6*z.y;\n    float t8 =  sin(theta);\n    float t9 =  t8*z.z;\n    float t11 = t6*z.z;\n    float t12 = t8*z.y;\n    float t15 = z.y*z.y;\n    float t19 = t2*z.y*z.z;\n    float t20 = t8*z.x;\n    float t24 = z.z*z.z;\n    return mat3( t1 + t2*t3, t7 - t9, t11 + t12, t7 + t9, t1 + t2*t15, t19 - t20, t11 - t12, t19 + t20, t1 + t2*t24);\n\n}\n\nmat3 quaternion(vec3 v, float an){\n\n    vec3 z = normalize(v);\n    \n    float a = cos(an/2.0);\n    float s = sin(an/2.0);\n    float b = s*z.x;\n    float c = s*z.y;\n    float d = s*z.z;\n    float a2 = a*a;\n    float b2 = b*b;\n    float c2 = c*c;\n    float d2 = d*d;\n    float _2ab = 2.*a*b;\n    float _2ac = 2.*a*c;\n    float _2ad = 2.*a*d;\n    float _2bc = 2.*b*c;\n    float _2bd = 2.*b*d;\n    float _2cd = 2.*c*d;\n    \n    return mat3(a2+b2-c2-d2  , _2bc-_2ad, _2ac+_2bd, \n                _2ad+_2bc, a2-b2+c2-d2  , _2cd-_2ab,\n                _2bd-_2ac, _2ab+_2cd, a2-b2-c2+d2);\n\n\n}\n\nfloat Box(vec3 p, vec3 sc, float r){\n    return length(max(abs(p)-sc, 0.))-r;\n}\n\nfloat Box2d(vec2 p, vec2 sc, float r){\n    return length(max(abs(p)-sc, 0.))-r;\n}\n\nfloat N21(vec2 p){\n    p = fract(p*vec2(233.34, 851.73));\n    p += dot(p, p+23.45);\n    return fract(p.x*p.y);\n\n}\n\nvec2 map(vec3 p){\n\n    vec2 d = vec2(0.0);\n    \n    float r1 = 3.0, r2 = 0.5;\n    vec3 pp = p - vec3(0.0, 4.0, 0.0);\n    float x = length(pp.xz) - r1;\n    float y = pp.y;\n    vec2 cp = vec2(x, y);\n    float a = atan(pp.x, pp.z);\n    cp *= Rot(a*2.5+iTime);\n    cp.y = abs(cp.y)-0.7;\n    //float tp = length(cp) - r2;\n    \n    float tp = Box2d(cp, vec2(.1, .1*sin(a)*.5+0.5), 0.05)*.5;\n   \n    d.x = tp;\n    d.y = 1.0;\n    \n    \n    \n  \n    \n    return d;\n\n}\n\nvec3 RM(vec3 ro, vec3 rd, float _d){\n    vec3 d = vec3(_d, 0.0, 0.0);\n    for(int i = 0;i < 100;i++){\n        d.yz = map(ro + d.x * rd).xy;\n        \n        if(abs(d.y) <(0.001))\n            break;\n            \n        d.x += d.y;\n        \n        if(d.x > 30.0)break;\n    \n    }\n    if(d.x > 30.0)d.x = -1.0;\n    \n    return d;\n    \n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n\n\nvec3 getLight(vec3 p, vec3 ro, vec3 rd, vec3 lightpos, out vec3 n, vec2 uv){\n    vec2 e = vec2(0.01, 0.0);\n    vec2 nd = map(p);\n\n    n = nd.x - vec3(map(p - e.xyy).x ,\n                        map(p- e.yxy).x ,\n                        map(p- e.yyx).x );\n\n    n = normalize(n);\n    \n        \n    \n    vec3 l = normalize(lightpos-p);\n    \n    float occ = calcAO(p, n); \n    float dif = clamp(dot(n, l), 0.0, 1.0);\n    dif += occ;\n    \n   \n    \n    \n    vec3 sh = RM(p+n*0.01, l, 0.0);\n    p = ro + rd * sh.x;\n    \n   \n    \n    float spec = pow(max( dot( reflect(-l, n), -rd ), 0.), 8.);\n    \n    vec3 col = vec3(0.0);\n       \n    if((sh.x > 0.0) && (sh.x < length(lightpos-p))){\n\n        if(sh.z == 1.0){\n\n            col = vec3(dif);\n            return col;\n\n            \n        }\n        else\n             return vec3(dif);\n     \n            \n    }\n    else\n         return vec3(dif);\n   \n   \n}\n\nvec3 Bg(vec3 rd){\n\n    float k = rd.y*.5+.5;\n    \n    \n    vec3 col = mix(vec3(.2, .1, .1), vec3(.2, .5, 1.), k);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv /= vec2(iResolution.y/iResolution.x, 1.0);\n    \n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n    \n       \n    vec3 p;\n    vec3 ro = vec3(-2.0, 3.0, -7.0); \n    vec3 lookat = vec3((iMouse.x/iResolution.x)*10.0, (iMouse.y/iResolution.y)*30.0, 30.0);\n    vec3 lightpos = vec3(0.0, 5.0, -1.0);\n        \n    vec3 dirc = vec3(0.0, 2.0, 0.0);\n        \n    float an = (iMouse.x/iResolution.x)*10.0;\n    float anx = (iMouse.y/iResolution.y)*10.0;\n    ro -= dirc;\n    lookat -= dirc;\n    ro *= quaternion(vec3(0.0, 0.0, 1.0), anx);\n    lookat *= quaternion(vec3(0.0, 0.0, 1.0), anx);\n    ro *= quaternion(vec3(1.0, 0.0, 0.0), anx);\n    lookat *= quaternion(vec3(1.0, 0.0, 0.0), anx);\n    ro *= quaternion(vec3(0.0, 1.0, 0.0), an);\n    lookat *= quaternion(vec3(0.0, 1.0, 0.0), an);\n    \n    ro += dirc;\n    lookat += dirc;\n      \n    vec3 n = cross(vec3(0.0, 2.0, 0.0), vec3(iMouse.xy, 0.0));\n    float a = acos(dot(vec3(0.0, 2.0, 0.0), vec3(iMouse.xy, 0.0)));\n    \n    \n    \n    lightpos -= dirc;\n    lightpos *= quaternion(vec3(0.0, 0.0, 1.0), anx);\n    lightpos *= quaternion(vec3(1.0, 0.0, 0.0), anx);\n    lightpos *= quaternion(vec3(0.0, 1.0, 0.0), an);\n    lightpos += dirc;\n    \n       \n    \n    float zoom = 1.0;    \n    vec3 f = normalize(lookat-ro),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f, r),\n        c = ro + f * zoom,\n        i = c + uv.x * r + uv.y * u,\n        rd = normalize(i-ro);\n        \n    col += Bg(rd);\n    \n    float dan = 0.0;\n    vec3 d = RM(ro, rd, dan);\n    \n    vec4 rc;\n    if(d.x > 0.0){\n        p = ro + d.x * rd;\n        \n        vec3 n;\n        vec3 dif = getLight(p, ro, rd, lightpos, n, uv);\n    \n        if(d.z == 1.0){\n            \n            vec3 r = reflect(rd, n);\n            float spec = pow(max(0.0, r.y), 20.);\n            col += mix(Bg(r), dif, .5)+spec ;\n                     \n           \n        \n        }\n        else if(d.z == 2.0){\n            col += dif * vec3(1.0, 1.0, 0.1);\n        \n        \n        }\n\n    }                 \n                        \n    \n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlKcWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 94], [96, 96, 115, 115, 217], [219, 219, 238, 238, 340], [342, 342, 361, 361, 463], [465, 465, 496, 496, 978], [980, 980, 1014, 1014, 1562], [1564, 1564, 1600, 1600, 1643], [1645, 1645, 1683, 1683, 1726], [1728, 1728, 1746, 1746, 1841], [1843, 1843, 1860, 1860, 2300], [2302, 2302, 2338, 2338, 2637], [2640, 2640, 2682, 2682, 2981], [2986, 2986, 3062, 3062, 3881], [3883, 3883, 3900, 3900, 4014], [4016, 4016, 4073, 4123, 6291]], "test": "valid"}
{"id": "WltBD8", "name": "Coulomb plasma", "author": "DukeOfStraylight", "description": "I probably saw something like this on my PC in 1994, but hey, this time I made (some of) it myself.", "tags": ["plasma"], "likes": 3, "viewed": 167, "published": "Public API", "date": "1612639241", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = 3.14159;\n\nfloat hash11(float x) {\n    return fract(sin(x*543.543)*1364.34);\n}\n\nconst float charges = 8.;\n\nvec2 gradient(vec2 x)\n{\n    float charge = -1.;\n    vec2 rv = vec2(0.);\n    for (float n = 0.; n < charges; n += 1.) {\n        float t = (n * 2. * pi / charges) + iTime * 0.5 + hash11(n) * iTime;\n        vec2 pos = vec2(cos(t), sin(t) * n / charges);\n        vec2 d = x - pos;\n        float l = length(d);\n        rv += normalize(d)/l * charge;\n        charge = -charge;\n    }\n    return rv;\n}\n\n// original numeric gradient calculation\n/*\nfloat potential(vec2 uv) {\n    float charge = 1.;\n    float pot = 0.;\n    const int charges = 8;\n    for (int n = 0; n < charges; n += 1) {\n        float t = (float(n) * 2. * pi / float(charges)) + iTime * 0.5 + hash11(float(n)) * iTime;\n        pot += charge / length(uv - vec2(cos(t), sin(t) * float(n) / float(charges)));\n        charge = -charge;\n    }\n    return pot;\n}\n\nvec2 gradient(vec2 x)\n{\n    vec2 h = vec2( 0.01, 0.0 );\n    return vec2( potential(x+h.xy) - potential(x-h.xy),\n                 potential(x+h.yx) - potential(x-h.yx) )/(2.0*h.x);\n}\n*/\n\n// from https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\n// All components are in the range [0…1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor.a = 1.;\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    uv *= 3.;\n\n    vec2 f = gradient(uv);\n    float dir = atan(f.y, f.x);\n    fragColor.rgb = hsv2rgb(vec3(fract((dir/pi+1.)*0.5), 1., 1.));\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WltBD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 50, 50, 94], [123, 123, 146, 146, 516], [1124, 1267, 1289, 1289, 1458], [1461, 1461, 1518, 1518, 1744]], "test": "valid"}
{"id": "WltBW2", "name": "Hexagon Loop", "author": "kithy", "description": "Hexagon Loop made from Box and Sphere", "tags": ["raymarching", "hexagon", "polarmod"], "likes": 2, "viewed": 58, "published": "Public", "date": "1613488963", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 16\n#define EPS 1e-4\n\nfloat cube(vec3 p,vec3 s){\n\tvec3 q=abs(p);\n\tvec3 m=max(s-q,0.0);\n\treturn length(max(q-s,0.0))-min(min(m.x,m.y),m.z);\n}\nfloat sphere(vec2 p){\n\treturn length(p)-0.1;\n}\n\nvec2 pmod(vec2 p,float n){\n\tfloat np=3.141592*2.0/n;\n\tfloat r=atan(p.x,p.y)-0.5*np;\n\tr=mod(r,np)-0.5*np;\n\treturn length(p)*vec2(cos(r),sin(r));\n}\n\nfloat sd(vec3 p){\n\tp.xy=pmod(p.xy,6.0);\n\tp=mod(p,0.8)-0.4;\n\tfloat c1=cube(p,vec3(0.3));\n\tfloat c2=cube(p,vec3(0.1,0.4,0.1));\n\tfloat s1=sphere(vec2(0.2));\n\treturn min(c2,s1); //OR\n\t//return max(c2,s1); //AND\n\t//return max(-c2,s1);\n\t//return max(c2,-s1);\n}\n\nvec3 genNormal(vec3 p){\n\treturn normalize(vec3(\n\t\tsd(p+vec3(EPS,0.0,0.0))-sd(p+vec3(-EPS,0.0,0.0)),\n\t\tsd(p+vec3(0.0,EPS,0.0))-sd(p+vec3(0.0,-EPS,0.0)),\n\t\tsd(p+vec3(0.0,0.0,EPS))-sd(p+vec3(0.0,0.0,-EPS))\n\t\t));\n}\n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n\tvec2 p=(2.0*fragCoord.xy-iResolution.xy)/min(iResolution.x,iResolution.y);\n\n\tfloat radius=0.1;\n\tfloat phi=iTime*0.5;\n\n\t//vec3 ro=vec3(0.0,0.0,iTime*0.3);\n\tvec3 ro=vec3(cos(phi)*radius,-sin(phi)*radius,sin(phi)*radius);\n\tvec3 target=vec3(0.0);\n\n\tvec3 cdir=normalize(target-ro);\n\tvec3 side=cross(cdir,vec3(0.0,1.0,0.0));\n\tvec3 up=cross(side,cdir);\n\tfloat fov=0.6;\n\n\tvec3 rd=normalize(p.x*side+p.y*up+cdir*fov);\n\n\t//vec3 rd=normalize(vec3(p,1.0));\n\n\tfloat d,t=0.0;\n\tvec3 n,rp;\n\t\n\tfor(int i=0;i<MAX_STEPS;i++){\n\t\trp=ro+rd*t;\n\t\td=sd(rp);\n\t\tif(d<EPS)break;\n\t\tn=genNormal(rp);\n\t\tt+=d;\n\t}\n\n\t\n\tfragColor=vec4(n,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WltBW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 39, 65, 65, 157], [158, 158, 179, 179, 204], [206, 206, 232, 232, 351], [353, 353, 370, 370, 607], [609, 609, 632, 632, 819], [822, 822, 875, 875, 1487]], "test": "valid"}
{"id": "WltBzM", "name": "Moiré 3", "author": "FabriceNeyret2", "description": "Shadows of 2 identical parallel plates with hexa-tiled holes. Slight perspective cause moiré.\nInspiration:\n[img]https://img.srgcdn.com/e/w:750//UlJBQm5VN2xnbnBnU1N3WTBWR2sucG5n.jpg[/img]", "tags": ["aliasing", "interference", "moir", "reproduction"], "likes": 12, "viewed": 180, "published": "Public API", "date": "1612432063", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// adapted from https://shadertoy.com/view/ttd3D7\n\n#define D   length( mod( U += T/2. , T ) - R )               //\n#define P   clamp( 1.- ( min( D, D ) -.8*R.y )/6. ,0.,1.)    // draw an hexa tiling of disks\n\nvoid mainImage(out vec4 O, vec2 U) {\n    U *= 4.;\n    vec2 R = iResolution.yy/8., T = vec2( 2, 3.5 )*R;\n    O += P -O;\n\n    U = 1.1*U + 10.*iTime;\n    O *= P;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WltBzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 209, 245, 245, 369]], "test": "valid"}
{"id": "WltfDH", "name": "Color Curl", "author": "luckorloss", "description": "Stare at it.", "tags": ["color", "trippy", "whoa"], "likes": 2, "viewed": 75, "published": "Public", "date": "1612666377", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265358979323846\n\nfloat spiral(vec2 uv, float rep, float twist, float phase, float angV){\n    angV  *= iTime * PI * rep;\n    phase += angV;\n    \n    float ang = atan(uv.y, uv.x) / 2. * rep + phase;\n    float len = length(uv) * twist;\n    float off = len + ang / PI;\n    \n    return mod(off, 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv    =  fragCoord / iResolution.xy;\n    vec2 pos   =  uv * 2.;\n         pos   -= 1.;\n         pos.x *= iResolution.x / iResolution.y;\n    \n    float sp1 = spiral(pos, 1., sin(iTime / 2.0) *  3., 0., 1.0);\n    float sp2 = spiral(pos, 1., sin(iTime / 2.1) * -5., 0., -2.);\n    float sp3 = spiral(pos, 1., sin(iTime / 2.2) *  4., 0., 2.7);\n    \n    vec3 col = vec3(sp1, sp2, sp3);\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WltfDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 106, 106, 314], [316, 316, 371, 371, 797]], "test": "valid"}
{"id": "wltfDX", "name": "Weierstrass smoke", "author": "bakugod", "description": "some test", "tags": ["math", "simulation", "smoke"], "likes": 5, "viewed": 145, "published": "Public", "date": "1613618639", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 5\n\nfloat fbm ( in vec2 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n// https://en.wikipedia.org/wiki/Weierstrass_function\nfloat weie(in float x) {\n    float a = 3.0;\n    float pi = 3.14;\n    float b = 0.5;\n    \n    for(int n = -2; n<2;n++) {\n        x += pow(b,float(n)) * cos( pow(a, float(n)) *pi*x);\n    }\n    \n    return x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 color = vec3(0.0, 0.0, 0.0);\n    \n    vec2 q = vec2(0.);\n    q.x = fbm( uv + 0.00*iTime);\n    q.y = fbm( uv + vec2(1.0));\n    \n    vec2 r = vec2(0.);\n    r.x = fbm( uv + 1.0*q + vec2(1.7,9.2)+ 0.15*iTime );\n    r.y = fbm( uv + 1.0*q + vec2(8.3,2.8)+ 0.126*iTime);\n\n    float f = fbm(uv+r);\n\n\n\n    \n    vec2 pos = fragCoord.xy;\n    \n    if( tan(r.x)*1.6 > sin(cos(weie(iTime*10.))) ){\n        \n        color = mix(vec3(0.101961,0.619608,0.666667),\n                vec3(0.666667,0.666667,0.498039),\n                clamp((f*f)*4.0,0.0,1.0));\n                \n        color = mix(color,\n                vec3(0,0,0.164706),\n                clamp(length(q),0.0,1.0));\n\n        color = mix(color,\n                vec3(0.666667,1,1),\n                clamp(length(r.x),0.0,1.0));\n    }\n    else{\n        color = mix(vec3(0.454,0.165,0.667),\n                    vec3(0.667,0.140,0.444),\n                    clamp((f*f)*4.0,0.0,1.0));\n\n        color = mix(color,\n                    vec3(0.165,0.137,0.118),\n                    clamp(length(q),0.0,1.0));\n\n        color = mix(color,\n                    vec3(0.993,1.000,0.946),\n                    clamp(length(r.x),0.0,1.0));\n    }\n    \n    \n    \n\n    // fract( dot( pos, vec2(weie(iTime, -2, 2))\n    // Output to screen\n    // fragColor = vec4( vec3( fract( weie(iTime, -2, 2) ) ), 1. );\n    fragColor = vec4((f*f*f+.6*f*f+.5*f)*color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wltfDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 136], [138, 216, 243, 243, 625], [650, 650, 676, 676, 1014], [1016, 1070, 1094, 1094, 1277], [1279, 1279, 1336, 1336, 2774]], "test": "valid"}
{"id": "WltfzM", "name": "大龙猫 -  Quicky#050", "author": "totetmatt", "description": "quicky", "tags": ["quicky"], "likes": 13, "viewed": 241, "published": "Public API", "date": "1612434199", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float bbox(vec2 uv, vec2 a,vec2 b,float t){\n    float l = length(b-a);\n    vec2 d = (b-a)/l;\n    vec2 q = uv - (a+b)*.5;\n    q = mat2(d.x,-d.y,d.y,d.x)*q;\n    q = abs(q) - vec2(l,t)*.5;\n    return length(max(q,vec2(0.))) + min(max(d.x,d.y),0.);\n}\nfloat tt (vec2 uv,vec2 offset){\n    float d = bbox(uv,vec2(.0,.2)+offset,vec2(.2,-.2)-offset,.001);\n     d = min(d,bbox(uv,vec2(-.2,-.2)-(offset/offset),vec2(0,.2)+offset,.001));\n      d = min(d,bbox(uv,vec2(-.2,-.2)+offset,vec2(.2,-.2)-offset,.001));\n    d = (.01+sin(uv.y*20.+uv.x*10.+iTime)*.005)/d;\n    return d;\n}\nvec2 h21(float t){\n    float x = fract(sin(t*546.54)*815.2);\n    float y = fract(sin(t*461.541)*401.5);\n    return vec2(x,y);\n}\n\nmat2 r(float a){\n    float c=cos(a),s= sin(a);\n    return mat2(c,-s,s,c);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy -.5* iResolution.xy) / iResolution.y;\n    uv*=2.0;\n    vec3 col = vec3(0.);\n    const float lim = 10.;\n    for(float i=0.;i<lim;i++){\n      float rr = fract((-iTime-100.)*i/lim);\n      rr = mix(.05,10.,rr);\n      vec2 lv = uv;\n      \n    float d = tt((lv*r(iTime+100.+i)*rr),h21(floor(100.+iTime*.05+i))*.09);\n      col += vec3(d,d-.1,d-.2);\n    }\n   \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WltfzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 43, 43, 246], [247, 247, 278, 278, 565], [566, 566, 584, 584, 693], [695, 695, 711, 711, 770], [771, 771, 826, 826, 1239]], "test": "valid"}
{"id": "wlVBRR", "name": "Funny rain", "author": "rabbitator", "description": "beads ", "tags": ["2d", "rain", "dots", "falling", "beads"], "likes": 7, "viewed": 221, "published": "Public", "date": "1613779235", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat sin_n(float v)\n{\n    return sin(v)*0.5+0.5;\n}\n\n// shadertoy.com/view/4ssXRX\nfloat rand(vec2 n)\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= iMouse.xy/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= 40.0;\n    \n    uv += vec2(234.0, 6.0*iTime*rand(floor(uv.xx+123.0)));\n    vec2 id = floor(uv);\n    vec2 gv = fract(uv);\n    gv -= 0.5+vec2(sin((id.y+2.0)*(id.x+2.0)+iTime*10.0)*0.1, 0.0);\n\n    vec3 col = vec3(1.0-smoothstep(0.1, sin_n(iTime+id.x*id.y)*0.2+0.1, length(gv)));\n    \n    col *= (sin(iTime * 2.0 + id.xyx*0.002 + vec3(0, 2, 4))*0.25+0.75)*rand(id);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVBRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 23, 23, 52], [54, 83, 103, 103, 171], [174, 174, 231, 231, 758]], "test": "valid"}
{"id": "WlVBWm", "name": "Random procedural textures 3", "author": "jarble", "description": "This shader makes procedural textures with many different colors and patterns.", "tags": ["procedural", "texture", "random"], "likes": 3, "viewed": 187, "published": "Public API", "date": "1614478737", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nvec2 fract1(vec2 a,vec2 random,float scale1){\n    return (abs(fract(a*scale1+100.0*random)-.5));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;\n    float t;\n    float t2=iTime/20.0;\n    float t3 = 8.0;\n    for(int c=0;c<3;c++){\n\t    vec2 uv = (fragCoord*5.0-iResolution.xy)/iResolution.y/10.0*t3;\n        uv += vec2(iTime/2.0,iTime/3.0)/8.0*t3;\n        float scale = 3.0;\n        \n        \n        //vec3 random = vec3(sin(t2/13.0),sin(t2/17.0),sin(t2/19.0))/2.0+.5;\n        vec3 random = hash31(floor((iTime+uv.x)/5.0))*2.0;\n        float scale1 = .5+(random.z)/2.0;\n        //random.xy = random.z;\n        //vec3 random = hash31(10.0);\n        scale = scale1 * 1.5;\n        \n        for(int i=0;i<3;i++)\n        {\n            \n            random = (hash33(random)+vec3(.5))*2.0;\n            //scale1 *= 1.+random.z/1.7/2.0;\n            uv.y /= -scale1;\n            //uv=fract(uv.yx+(uv)/scale);\n            uv=fract(uv/scale1+uv.yx/scale);\n\n            uv = fract1(uv/scale1,random.yx,scale1)*scale1;\n            uv /= scale;\n            uv=uv.yx+col.yx;\n            uv.y *= -scale+uv.y;\n            col = col.yzx;\n        }\n     col[c] = fract((uv.x)-(uv.y));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVBWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 111, 133, 179, 312], [314, 425, 447, 447, 572], [574, 574, 619, 619, 672], [674, 674, 731, 731, 1843]], "test": "valid"}
{"id": "WlVBzz", "name": "PixelSpirit First Draw", "author": "netgrind", "description": "The Emperor - Merge - Bundle\nremixed from Patricio Gonzalez Vivo's PixelSpirit oracle deck - https://patriciogonzalezvivo.github.io/PixelSpiritDeck/", "tags": ["pixel", "spirit", "pixelspirit"], "likes": 15, "viewed": 348, "published": "Public API", "date": "1613777792", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The Emperor - Merge - Bundle\n// Remixed from Patricio Gonzalez Vivo's PixelSpirit oracle deck - https://patriciogonzalezvivo.github.io/PixelSpiritDeck/\n\n// I read this draw as a sign to solidify and consolidate code into proper bundles, increasing stability and security of mind, so this magician knows their tools are organized and at the ready for what battles lay ahead\n\nfloat smoothing = .01;\n\n// 04\nfloat stroke(float x, float s, float w){\n    float d = smoothstep(s, s+smoothing, x+w*.5) - smoothstep(s, s+smoothing, x-w*.5);\n    return clamp(d, 0., 1.);\n}\n\n// 08\nfloat circleSDF(vec2 st) {\n    return length(st-.5)*2.;\n}\n\n// 09\nfloat fill(float x, float s){\n    return 1.-smoothstep(s, s+smoothing, x);\n}\n\n// 10\nfloat rectSDF( vec2 st, vec2 s){\n    st = st*2.-1.;\n    return max(abs(st.x/s.x), abs(st.y/s.y));\n}\n\n// 12\nfloat flip(float v, float pct){\n    return mix(v, 1.-v, pct);\n}\n\n// 27\nfloat hexSDF(vec2 st){\n    st = abs(st*2.-1.);\n    return max(abs(st.y), st.x * 0.866025 + st.y*0.5);\n}\n\nfloat draw0(vec2 uv, float a, float d, float time){\n    float col = 0.;\n    float sTime = time*6.28;\n    \n    // The Emperor\n    vec2 st = vec2(sin(a), cos(a))*(d*(1.1+sin(sTime+a)*.1))+.5;\n    float sdf = rectSDF(st, vec2(1.));\n    col += stroke(sdf, .6, .125);\n    col += fill(sdf, min(mod(time, 2.),1.)*.5375);    \n    col += fill(sdf, min(mod(time, 2.)-1.,1.)*.5375);    \n    col += fill(sdf, .1);\n\n    // Merge\n    st = uv;\n    vec2 offset = vec2(sin(sTime), cos(sTime))*(pow(cos(sTime)*.5+.5, 1.5)*.2);\n    float left = circleSDF(st+offset);\n    float right = circleSDF(st-offset);\n    col += flip(stroke(left, .5, .05), fill(right, .52));\n    \n    // Bundle\n    st = uv.yx;\n    col += stroke(hexSDF(st), .5+cos(sTime)*.2, .1);\n    //st = vec2(sin(a-sTime), cos(a-sTime))*d+.5;\n    float amp = sin(sTime);\n    amp = pow(abs(amp), .6)*sign(amp);\n    amp*=1.5;\n    col += fill(hexSDF(st-vec2(-.06, -.1)*amp), .15);\n    col += fill(hexSDF(st-vec2(-.06, .1)*amp), .15);\n    col += fill(hexSDF(st-vec2(.11, 0.)*amp), .15);\n    \n    col = abs(mod(col+1., 2.)-1.);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*.5)/min(iResolution.x, iResolution.y);\n    uv*=1.25;\n    uv+=.5;\n    float a = atan(uv.y-.5, uv.x -.5);\n    float d = length(uv-.5);\n    float time = iTime*.25;\n    float sTime = time*6.28;\n    vec4 col = vec4(0., 0., 0., 1.);\n    \n    for(float i = -10.; i< 10.; i++){\n        float t = i*(sin(uv.x*10.+sTime+uv.y*2.+cos(uv.y*5.+sTime)*2.+sin(uv.x*3.-sTime))*.5+.5)*.01;\n        col += vec4(draw0(uv, a, d, time-.01+t),\n                    draw0(uv, a, d, time+t),\n                    draw0(uv, a, d, time+.01+t),\n                    1.);\n    }\n    col/=20.;\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVBzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[401, 407, 447, 447, 565], [567, 573, 599, 599, 630], [632, 638, 667, 667, 714], [716, 722, 754, 754, 821], [823, 829, 860, 860, 892], [894, 900, 922, 922, 1003], [1005, 1005, 1056, 1056, 2086], [2088, 2088, 2145, 2195, 2818]], "test": "valid"}
{"id": "WlVfDm", "name": "Fork Waves Remi anotherpla 266", "author": "anotherplatypus", "description": "simple audio visualizer (also pretty without audio) based upon \"waves\" by bonniem, with added travelling pulse effect, color cycling, and of course, the requested audio sensitivity. Each wave is particularly responsive to a specific range of frequencies.", "tags": ["waves", "sound", "wave", "music", "colors", "beginner", "audio", "visualizer", "easy", "sounds"], "likes": 5, "viewed": 195, "published": "Public API", "date": "1614491589", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The following block is needed for Clubber integration\n#ifndef CLUBBER\nvec4 iMusic[4];\nconst float iTransition = 1.0;\n\n#define CLUBBER_R 0.3\n#define CLUBBER_G 0.3\n#define CLUBBER_B 0.3\n#define CLUBBER_A 0.0\n#endif\n// Clubber end\n\nfloat squared(float value) { return value * value; }\n\nfloat getAmp(float frequency) { return texture(iChannel0, vec2(frequency / 512.0, 0)).x; }\n\nfloat getWeight(float f) {\n    return (+ getAmp(f-2.0) + getAmp(f-1.0) + getAmp(f+2.0) + getAmp(f+1.0) + getAmp(f)) / 5.0; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\tvec2 uvTrue = fragCoord.xy / iResolution.xy;\n    vec2 uv = -1.0 + 2.0 * uvTrue;\n    \n\tfloat lineIntensity;\n    float glowWidth;\n    vec3 color = vec3(0.0);\n    \n\tfor(float i = 0.0; i < 5.0; i++) {\n        \n\t\tuv.y += (0.2 * sin(uv.x + i/7.0 - iTime * 0.6));\n        float Y = uv.y + getWeight(squared(i) * 20.0) *\n            (texture(iChannel0, vec2(uvTrue.x, 1)).x - 0.5);\n        lineIntensity = 0.4 + squared(1.6 * abs(mod(uvTrue.x + i / 1.3 + iTime,2.0) - 1.0));\n\t\tglowWidth = abs(lineIntensity / (150.0 * Y));\n\t\tcolor += vec3(glowWidth * (2.0 + sin(iTime * 0.13)),\n                      glowWidth * (2.0 - sin(iTime * 0.23)),\n                      glowWidth * (2.0 - cos(iTime * 0.19)));\n\t}\t\n\t\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVfDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[216, 232, 260, 260, 284], [286, 286, 317, 317, 376], [378, 378, 404, 404, 502], [504, 504, 561, 561, 1298]], "test": "error"}
{"id": "WlVfDw", "name": "Ondas", "author": "ChemaSerrano", "description": "...", "tags": ["2"], "likes": 1, "viewed": 52, "published": "Public", "date": "1614477806", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define t iTime\n#define r iResolution.xy\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec3 c;\n\tfloat l,z=t;\n\tfor(int i=0;i<15;i++) {\n\t\tvec2 uv,p=fragCoord.xy/r;\n\t\tuv=p;\n\t\tp-=.50;\n        p+=.50;\n        p.x*=r.y/r.y;\n\t\tp.y*=r.x/r.x;\n\t\tz+=.780;\n\t\tl=length(p);\n\t\tuv+=p/l*(sin(z)+1.)*abs(sin(l*10.-z*25.5));\n\t\tc[i]=.01/length(abs(mod(uv,1.5)-.50));\n\t}\n    \n    for(int i=5;i<15;i++) {\n\t\tvec2 uv,p=fragCoord.xy/r;\n\t\tuv=p;\n\t\tp-=.80;\n\t\tp.y*=r.x/r.y;\n\t\tz+=.80;\n\t\tl=length(p);\n\t\t\n\t}\n\t\n   for(int i=2;i<15;i++) {\n\t\tvec2 uv,p=fragCoord.xy/r;\n\t\tuv=p+r;\n\t\tp-=.80;\n\t\tz+=.80;\n\t\tl=length(p);\n\t\t\n\t}\n\t\n   \n    \n    \n\tfragColor=vec4(c/l,t);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVfDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 42, 98, 98, 638]], "test": "valid"}
{"id": "WlVfR1", "name": "nonlinear ripples in aether ", "author": "sense", "description": "hack of https://www.shadertoy.com/view/XtVczV  i have no idea what im doing :) .. \nplease let me know if you have objections i will remove it .. \n", "tags": ["mod", "hack", "try"], "likes": 0, "viewed": 35, "published": "Public", "date": "1613887729", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// http://bit.ly/supersinfulsilicon\n// @Carandiru on twitter - follow me!\n\n//hack of ^ i have no idea what im doing :) .. \n\nvoid pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tp = mod(p + halfsize, size) - halfsize;\n}\n\nvoid pMod3(inout vec3 p, vec3 size) {\n    \n\tp = mod(p - size*1.5, size) - size*0.5;\n}\n\nfloat sphere(vec3 p, float radius){\n    return length(p)-radius;\n\n}\n\n\nfloat map(vec3 p)\n{\n    vec3 q = p;\n\tvec3 qa = p;\n    pMod3(q, vec3(0.8, 1., 0.23));\n\tpMod3(qa, vec3(0.8, 1., 0.18));\n    pMod1(p.x, 1.);\n    \n    float s1 = sphere(p, 0.75); \n    float s2 = sphere(q, 0.5);  \t    \t\n    float s3 = sphere(qa, 0.555);\n    \n  \tfloat df1 = min(min(s1, s2),s3); // Union\n\n    return df1;\n}\n\n\nfloat trace(vec3 origin, vec3 r) \n{\n  float t = cos(1.0);\n    for (int i = 0; i < 64; ++i) {\n        vec3 p = iTime*origin *iResolution *0.00000001 +iTime*0.00000005 -r  - t*8.0;\n        float d = map(p);\n        t += d*0.222;\n        }\n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord-tan(iResolution.xy)+fragCoord+sin(iResolution.yx)+cos(iTime)*0.00000045;\n    vec3 color = vec3(0.324, 0.12, 0.536);\n    uv = uv /1.-1.; // Remap the space to -1. to 1.\n    uv.x += iResolution.y/iResolution.x+iResolution.x*iResolution.y*0.00004;\n    \n    \t\n   \tfloat FOV = 0.25/iResolution.x-iResolution.y - 0.0025/iResolution.y+iResolution.x;\n   \tvec3 ray = normalize(vec3(uv, FOV));\n    \n    \n    vec3 origin = vec3(iTime, 10.0, 1.75);\n    float t = trace(origin, ray);\n    \n    float expFog = 0.5 / (t*t* 0.55);\n    \n    vec3 fc = vec3(expFog);\n    \n    if ( t < -0.9f ) {\n        color = 0.25-(0.5/t*color);\n        vec3 maincolor = exp(-(fc*color)*3.6f);\n        color = (1.0f - maincolor);\n        color = cos(color) * maincolor;\n    }\n    else\n        color = sinh(vec3(0));\n    \n    fragColor = vec4(color,dot(color, vec3(0.5)) * exp(-expFog));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVfR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 124, 163, 163, 234], [236, 236, 273, 273, 321], [323, 323, 358, 358, 390], [393, 393, 412, 412, 710], [713, 713, 748, 748, 965], [968, 968, 1025, 1025, 1903]], "test": "error"}
{"id": "wlVfRm", "name": "logistic adherances", "author": "Lordinator", "description": "Represents the logistic serie adherance graph. Logistic series arerelated to mandelbrot, population growth & water drips. If you want to learn more about the logisitc series, https://www.youtube.com/watch?v=ovJcsL7vyrk", "tags": ["mathematics"], "likes": 1, "viewed": 169, "published": "Public API", "date": "1614120180", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define minX 0.1\n#define maxX 4.0\n\n#define minY -0.01\n#define maxY 1.0\n\n#define nbRep 1000\n\nfloat closeNumberOfNumberInLogistic(float r, float goal, float epsilon){\n    float res = 0.0;//cumulated closeness to the goal\n    float u = 0.5 + .25 * sin(iTime); //series calc\n    for (int i = 0; i < nbRep; i +=1){\n        u = r * u * (1.0-u); //next logistic term calculated\n        res += (epsilon - min(epsilon, (goal - u)*(goal - u)))/epsilon; //close to 1.0 if u is close to goal in epsilon range\n    }\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float r = minX + uv.x * (maxX - minX);\n    float goal = minY + uv.y * (maxY - minY);\n    \n    fragColor = vec4(log(1.0 + closeNumberOfNumberInLogistic(r,goal,1e-6)/log(100.0*float(nbRep))));\n    //log (1+x)/log(nbRep) heuristic order of repetition \n    //but this formula might --> to give all the adherance values when nbRep --> +inf\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVfRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[92, 92, 164, 164, 520], [522, 522, 579, 579, 960]], "test": "valid"}
{"id": "wlVfRR", "name": "Migraine Aura Fractal", "author": "jarble", "description": "I found a fractal pattern that looks like a migraine aura (\"scintillating scotoma.\")", "tags": ["fractal", "circuit"], "likes": 0, "viewed": 184, "published": "Public API", "date": "1613786840", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 triangle_wave(vec2 a,float scale){\n    return (abs(fract(a*scale)-.5));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    for(int c=0;c<3;c++){\n        float t1 = 5.0;\n\t    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1;\n        uv += vec2(iTime/2.0,iTime/3.0)/t1/2.0;\n        \n        float offset = .2;\n        float scale = 1.5;\n        for(int i=0;i<6;i++)\n        {\n          \n            uv = triangle_wave(uv.yx+offset*uv.y,scale)+triangle_wave(uv,scale);\n            //uv= uv+col.xy;\n            uv = triangle_wave(uv+col.xy,scale);\n\n        }\n     col[c] = fract((uv.x)-(uv.y));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVfRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 78], [80, 80, 137, 137, 709]], "test": "valid"}
{"id": "wlVfz1", "name": "Fractal Experiment - 1", "author": "Learner_CC", "description": "Fractal experiment - 1", "tags": ["2d", "fractal"], "likes": 0, "viewed": 43, "published": "Public", "date": "1613920222", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float FractalFun(vec3 p) {\n    float pct = 0.0;\n    float lL = length(p);\n    float nL = lL;\n    for (int i = 0; i < 15; i++) {\n        p = abs(p) / (lL * lL);\n        nL = length(p);\n        pct += abs(nL - lL);\n        lL = nL;\n    }\n    return pct;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy / iResolution.xy;\n    vec2 uv = 2.0 * st - 1.0;\n    float n = 10.0;\n    // angle\n    float a = atan(uv.y, uv.x);\n    // radius\n    float r = length(uv);\n    // color \n    vec3 topColor = vec3(0.6);\n    vec3 bottomColor = vec3(0.4);\n    vec3 color = mix(topColor, bottomColor, sqrt(st).y);\n    \n    // fractal\n    float fc = a * n  - iTime * 3.0;\n    fc -= FractalFun(vec3(uv, 0.0));\n    fc -= 0.5 * FractalFun(vec3(uv * 2.5, 0.0));   \n    color += cos(fc) + 0.05 / dot(uv, uv);\n    color *= smoothstep(0.0, 1.0, 1.0 - r);\n    color += vec3(0.1546, 0.0898, 0.1953);\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVfz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 253], [255, 255, 312, 312, 940]], "test": "valid"}
{"id": "wlyBWm", "name": "Smooth Repetition", "author": "PauloFalcao", "description": "Smooth Repetition by @paulofalcao\nIt's possible to create a smooth repetition using asin(sin(x)*S) like blackle said in the comments :)\nMade a video playing with this and Material Maker https://www.youtube.com/watch?v=HoAQ7DFRzQE\n", "tags": ["repetition"], "likes": 21, "viewed": 386, "published": "Public API", "date": "1614449666", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Smooth Repetition\n// by @paulofalcao\n//\n// CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//\n// Twitter: @paulofalcao\n// https://twitter.com/paulofalcao/status/1365726720695934979\n//\n// YouTube playing with this and Material Maker\n// https://www.youtube.com/watch?v=HoAQ7DFRzQE\n//\n// I was using smooth abs p=sqrt(p*p+a) introduced by omeometo\n// at https://shadertoy.com/view/wljXzh\n// and iteratively doing smooth abs and translations\n// the number of objects is exponencial\n//\n// But it's possible to use asin(sin(x)*S) with S between 0 and 1 \n// like blackle said in the comments!\n// Creates infinite repetitions and it's even faster! :)\n// Change asin_sin_mode to true to use this mode (this is now the default mode)\n//\n// Using IQ \"Raymarching - Primitives\" as sandbox\n// https://www.shadertoy.com/view/Xds3zN\n//\n\n#define asin_sin_mode true\n\n//Change asin_sin_mode to true to use this mode (default)\n//blackle mode asin(sin(x)*S) with S between 0 and 1 (higher values less smooth)\nvec2 smoothrepeat_asin_sin(vec2 p,float smooth_size,float size){\n    p/=size;\n    p=asin(sin(p)*(1.0-smooth_size));\n    return p*size;\n}\n\n//Change asin_sin_mode to false to use this mode\n//6 iterations create 2^6 objects for each axis\n#define smoothrepeat_iterations 6\nvec2 smoothrepeat(vec2 p,float smooth_size,float size){\n    size/=2.0;\n    float w=pow(2.0,float(smoothrepeat_iterations));\n\tfor(int i=0;i<smoothrepeat_iterations;i++){\n        p=sqrt(p*p+smooth_size);//smooth abs\n\t\tp-=size*w;//translate\n\t\tw=w/2.0;\n\t}\n\treturn p;\n}\n\n\n//\n// The code from now on is the same as IQ \"Raymarching - Primitives\"\n// with minor modifications and different map function\n// https://www.shadertoy.com/view/Xds3zN\n//\n\n#if HW_PERFORMANCE==1\n#define AA 1\n#else\n#define AA 2   // make this 2 or 3 for antialiasing\n#endif\n\n//------------------------------------------------------------------\n// PRIMITIVES\n//------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\n\n//------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 rot(vec2 p, float r) {\n\tfloat s=sin(r);float c=cos(r);\n\treturn p*mat2(c,-s,s,c);\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( 1e10, 0.0 );\n\n    {\n\n      float sm=(smoothstep(0.0,1.0,sin(iTime)+0.5)-0.5)*0.01+0.005;\n      float dist=sin(iTime*0.35)*0.2+0.3;\n      \n      if (asin_sin_mode){\n          pos.xz=smoothrepeat_asin_sin(pos.xz,sm*10.0,dist);\n      } else {\n          pos.xz=smoothrepeat(pos.xz,sm,dist);\n      }\n\n      \n      pos.xz=rot(pos.xz,sin(iTime*0.5));\n      pos.xy=rot(pos.xy,sin(iTime*0.7)*0.4);\n      pos.yz=rot(pos.yz,sin(iTime)*0.3);\n\n      pos-=vec3(0.0,0.2, 0.0);\n      float b=sdRoundBox( pos, vec3(0.4,0.02,0.1),0.02);\n      \n      res = opU( res, vec2(b ,1.5) );\n    }\n\n    \n    return res;\n}\n\nvec2 raycast( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 0.1;\n    float tmax = 20.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n        res = vec2( tp1, 1.0 );\n    }\n    //else return res;\n    \n\n    float t = tmin;\n    for( int i=0; i<70 && t<tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<24; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    // filter kernel\n    vec2 w = abs(dpdx)+abs(dpdy) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy )\n{ \n    // background\n    vec3 col = vec3(0.7, 0.7, 0.9) - max(rd.y,0.0)*0.3;\n    \n    // raycast scene\n    vec2 res = raycast(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n        col = 0.2 + 0.2*sin( m*2.0 + vec3(0.0,1.0,2.0) );\n        float ks = 1.0;\n        \n        if( m<1.5 )\n        {\n            // project pixel footprint into the plane\n            vec3 dpdx = ro.y*(rd/rd.y-rdx/rdx.y);\n            vec3 dpdy = ro.y*(rd/rd.y-rdy/rdy.y);\n\n            float f = checkersGradBox( 3.0*pos.xz, 3.0*dpdx.xz, 3.0*dpdy.xz );\n            col = 0.15 + f*vec3(0.05);\n            ks = 0.4;\n        }\n\n        // lighting\n        float occ = calcAO( pos, nor );\n        \n\t\tvec3 lin = vec3(0.0);\n\n        // sun\n        {\n            vec3  lig = normalize( vec3(-0.5, 0.4, -0.6) );\n            vec3  hal = normalize( lig-rd );\n            float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n          //if( dif>0.0001 )\n        \t      dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n\t\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0);\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0-dot(hal,lig),0.0,1.0),5.0);\n            lin += col*2.20*dif*vec3(1.30,1.00,0.70);\n            lin +=     10.00*spe*vec3(1.30,1.00,0.70)*ks;\n        }\n        // sky\n        {\n            float dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n                  dif *= occ;\n            float spe = smoothstep( -0.2, 0.2, ref.y );\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0+dot(nor,rd),0.0,1.0), 5.0 );\n          //if( spe>0.001 )\n                  spe *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n            lin += col*0.60*dif*vec3(0.40,0.60,1.15);\n            lin +=     2.00*spe*vec3(0.40,0.60,1.30)*ks;\n        }\n        // back\n        {\n        \tfloat dif = clamp( dot( nor, normalize(vec3(0.5,0.0,0.6))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n                  dif *= occ;\n        \tlin += col*0.55*dif*vec3(0.25,0.25,0.25);\n        }\n        // sss\n        {\n            float dif = pow(clamp(1.0+dot(nor,rd),0.0,1.0),2.0);\n                  dif *= occ;\n        \tlin += col*0.25*dif*vec3(1.00,1.00,1.00);\n        }\n        \n\t\tcol = lin;\n\n        col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.001*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 32.0 + iTime*1.5;\n\n    // camera\t\n    vec3 ta = vec3( 0, 0, 0 );\n    \n    vec3 ro = ta + vec3( 4.5*cos(0.1*time + 7.0*mo.x), 1.0 + 4.0*mo.y, 4.5*sin(0.1*time + 7.0*mo.x) );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n\n        // focal length\n        const float fl = 2.5;\n        \n        // ray direction\n        vec3 rd = ca * normalize( vec3(p,fl) );\n\n         // ray differentials\n        vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n        vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n        vec3 rdx = ca * normalize( vec3(px,fl) );\n        vec3 rdy = ca * normalize( vec3(py,fl) );\n        \n        // render\t\n        vec3 col = render( ro, rd, rdx, rdy );\n\n        // gain\n        // col = col*3.0/(2.5+col);\n        \n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlyBWm.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[873, 1012, 1076, 1076, 1148], [1150, 1281, 1336, 1336, 1545], [1821, 1974, 1999, 1999, 2014], [2016, 2016, 2061, 2061, 2152], [2154, 2154, 2187, 2187, 2242], [2245, 2315, 2345, 2345, 2378], [2380, 2380, 2407, 2407, 2467], [2569, 2639, 2664, 2664, 3279], [3281, 3281, 3321, 3321, 3837], [3839, 3901, 3979, 4002, 4389], [4391, 4455, 4487, 4487, 5057], [5059, 5059, 5101, 5101, 5410], [5412, 5488, 5552, 5573, 5806], [5808, 5808, 5873, 5892, 8372], [8374, 8374, 8426, 8426, 8603], [8605, 8605, 8662, 8662, 10036]], "test": "valid"}
{"id": "WlyfDh", "name": "Rippling Fractal", "author": "lmno", "description": "Just wow.\n", "tags": ["lmnorose"], "likes": 2, "viewed": 45, "published": "Public", "date": "1614223093", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License CC0: Voronot Rose\n//  Based upon: https://https://www.shadertoy.com/view/wtVBRw\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          -5.1401592654\n#define TAU         (0.000000000000000000000000000005*PI)\n#define L2(x)       dot(x, x)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.15+0.15*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat pabs(float a, float k) {\n  return pmax(a, -a, k);\n}\n\nfloat height(vec2 p) {\n  p *= 0.4;\n  float d = length(p);\n  p *= ROT(TIME*0.1-1.5*d) ;\n  float c = 1E6;\n  float x = pow(d, 0.1);\n  float y = atan(p.x, p.y) / TAU;\n  \n  for (float i = 0.; i < 3.; ++i) {\n    float v = length(fract(vec2(x - TIME*(i)*.005123, fract(y + i*.125)*.5)*20.)*2.-1.);\n    c = pmin(c, v, 0.125);\n  }\n\n  return -0.0125*pabs(tanh_approx(5.5*d-80.*c*c*d*d*(.55-d))-0.25*d, 0.25);\n}\n\nvec3 normal(vec2 p) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(4.0/RESOLUTION.y, 0);\n  \n  vec3 n;\n  n.x = height(p + e.xy) - height(p - e.xy);\n  n.y = -1.0*e.x;\n  n.z = height(p + e.yx) - height(p - e.yx);\n  \n  return normalize(n);\n}\n\nvec3 color(vec2 p) {\n  const float s = 1.0;\n  const vec3 lp1 = vec3(1.0, 1.25, 1.0)*vec3(s, 1.0, s);\n  const vec3 lp2 = vec3(-1.0, 1.25, 1.0)*vec3(s, 1.0, s);\n\n  float h = height(p);\n  vec3  n = normal(p);\n\n  vec3 ro = vec3(0.0, -10.0, 0.0);\n  vec3 pp = vec3(p.x, 0.0, p.y);\n\n  vec3 po = vec3(p.x, h, p.y);\n  vec3 rd = normalize(ro - po);\n\n  vec3 ld1 = normalize(lp1 - po);\n  vec3 ld2 = normalize(lp2 - po);\n  \n  float diff1 = max(dot(n, ld1), 0.0);\n  float diff2 = max(dot(n, ld2), 0.0);\n\n  vec3  rn    = n;\n  vec3  ref   = reflect(rd, rn);\n  float ref1  = max(dot(ref, ld1), 0.0);\n  float ref2  = max(dot(ref, ld2), 0.0);\n\n  vec3 lcol1 = vec3(1.5, 1.5, 2.0).xzy;\n  vec3 lcol2 = vec3(2.0, 1.5, 0.75).zyx;\n  vec3 lpow1 = 0.15*lcol1/L2(ld1);\n  vec3 lpow2 = 0.5*lcol2/L2(ld2);\n  vec3 dm = vec3(1.0)*tanh(-h*10.0+0.125);\n  vec3 col = vec3(0.0);\n  col += dm*diff1*diff1*lpow1;\n  col += dm*diff2*diff2*lpow2;\n  vec3 rm = vec3(1.0)*mix(0.25, 1.0, tanh_approx(-h*1000.0));\n  col += rm*pow(ref1, 10.0)*lcol1;\n  col += rm*pow(ref2, 10.0)*lcol2;\n\n  return col;\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.5);\n  col = pow(col, 1.0/vec3(2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.55+0.55*pow(19.5*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = color(p);\n\n  col = 4.0*col;\n  // Workaround for some environments that seems to lack a vec3 version of tanh\n  col = vec3(tanh(col.x), tanh(col.y), tanh(col.z));\n  col = 0.99 -col;\n  \n  col = postProcess(col, q);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlyfDh.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[0, 330, 358, 378, 454], [456, 456, 495, 495, 582], [584, 584, 623, 623, 652], [654, 654, 684, 684, 711], [713, 713, 735, 735, 1113], [1115, 1115, 1136, 1136, 1343], [1345, 1345, 1365, 1365, 2397], [2399, 2399, 2435, 2435, 2670], [2672, 2672, 2727, 2727, 3084]], "test": "valid"}
{"id": "WlyfRy", "name": "Tunneling through golden fractal", "author": "mrange", "description": "Licence CC0: Tunneling through golden fractal III\n", "tags": ["2d", "fractal"], "likes": 13, "viewed": 304, "published": "Public API", "date": "1614540506", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Licence CC0: Tunneling through golden fractal III\n\n// -----------------------------------------------------------------------------\n// COMMON\n// -----------------------------------------------------------------------------\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PSIN(x)         (0.5+0.5*sin(x))\n#define LESS(a,b,c)     mix(a,b,step(0.,c))\n#define SABS(x,k)       LESS((.5/(k))*(x)*(x)+(k)*.5,abs(x),abs(x)-(k))\n#define L2(x)           dot(x, x)\n#define PLANE_PERIOD    5.0\n\nconst vec3 std_gamma   = vec3(2.2, 2.2, 2.2);\nconst vec3 planeCol    = vec3(1.0, 1.15, 1.5)*0.95;\nconst vec3 baseRingCol = pow(vec3(1.0, 0.65, 0.25), vec3(0.6));\nconst vec3 sunCol      = vec3(1.25, 1.0, 1.1)/1.25;\n\nstruct effect {\n  float lw;\n  float tw;\n  float sk;\n  float cs;\n};\n\nconst effect effects[] = effect[](\n    effect(0.5, 0.0, 0.0, 0.0)\n  , effect(0.5, 0.0, 0.0, 1.0)\n  , effect(0.5, 0.0, 1.0, 1.0)\n  , effect(0.5, 1.0, 1.0, 1.0)\n  , effect(0.5, 1.0, 1.0, 0.0)\n  , effect(0.5, 1.0, 0.0, 0.0)\n  );\neffect current_effect = effects[5];\n\nfloat hash(float co) {\n  co += 100.0;\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\nfloat modMirror1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize,size) - halfsize;\n  p *= mod(c, 2.0)*2.0 - 1.0;\n  return c;\n}\n\nfloat smoothKaleidoscope(inout vec2 p, float sm, float rep) {\n  vec2 hp = p;\n  vec2 hpp = toPolar(hp);\n  float rn = modMirror1(hpp.y, TAU/rep);\n  float sa = PI/rep - SABS(PI/rep - abs(hpp.y), sm);\n  hpp.y = sign(hpp.y)*(sa);\n  hp = toRect(hpp);\n  p = hp;\n  return rn;\n}\n\nvec4 alphaBlend(vec4 back, vec4 front) {\n  float w = front.w + back.w*(1.0-front.w);\n  vec3 xyz = (front.xyz*front.w + back.xyz*back.w*(1.0-front.w))/w;\n  return w > 0.0 ? vec4(xyz, w) : vec4(0.0);\n}\n\nvec3 alphaBlend(vec3 back, vec4 front) {\n  return mix(back, front.xyz, front.w);\n}\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  \n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat hex(vec2 p, float r) {\n  const vec3 k = vec3(-sqrt(3.0)/2.0,1.0/2.0,sqrt(3.0)/3.0);\n  p = p.yx;\n  p = abs(p);\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  return length(p)*sign(p.y);\n}\n\nfloat apollian(vec4 p, float s) {\n  float scale = 1.0;\n  for(int i=0; i<7; ++i) {\n    p = -1.0 + 2.0*fract(0.5*p+0.5);\n    float r2 = dot(p,p);\n    float k  = s/r2;\n    p       *= k;\n    scale   *= k;\n  }\n\n  float lw = 0.00125*current_effect.lw;\n  \n  float d0 = abs(p.y)-lw*scale;\n  float d1 = abs(circle(p.xz, 0.005*scale))-lw*scale;\n  float d = d0;\n  d = mix(d, min(d, d1), current_effect.tw);\n  return (d/scale);\n}\n\n// -----------------------------------------------------------------------------\n// PATH\n// -----------------------------------------------------------------------------\n\n// The path function\nvec3 offset(float z) {\n  float a = z;\n  vec2 p = -0.075*(vec2(cos(a), sin(a*sqrt(2.0))) + vec2(cos(a*sqrt(0.75)), sin(a*sqrt(0.5))));\n  return vec3(p, z);\n}\n\n// The derivate of the path function\n//  Used to generate where we are looking\nvec3 doffset(float z) {\n  float eps = 0.1;\n  return 0.5*(offset(z + eps) - offset(z - eps))/eps;\n}\n\n// The second derivate of the path function\n//  Used to generate tilt\nvec3 ddoffset(float z) {\n  float eps = 0.1;\n  return 0.125*(doffset(z + eps) - doffset(z - eps))/eps;\n}\n\n// -----------------------------------------------------------------------------\n// PLANE MARCHER\n// -----------------------------------------------------------------------------\n\nfloat weird3(vec2 p, float h) {\n  vec2  c = vec2(-1.25,  -1.25)+0.15*vec2(sin(0.2*TIME+TAU*h*vec2(1.0, sqrt(0.5)*0.5)));\n  vec2 ot = mix(1.5, -1.5, h)*vec2(cos(TAU*h*sqrt(0.5)), sin(TAU*h));\n  vec2 u = p;\n  float lx = 1E6;\n  float ly = 1E6;\n  float lp = 1E6;\n  const int maxi = 7;\n  float s = 1.0;\n\n  for (int i = 0; i < maxi; ++i) {\n    float m = dot(u, u);\n    u = SABS(u, 0.05)/m + c;\n    s *= m;\n    float dx = abs(u.x - ot.x);\n    float dy = abs(u.y - ot.y);\n    float dp = abs(1.65-length(u));\n    if(m > 0.05) {\n      lx = min(lx, dx);\n      ly = min(ly, dy);\n    }\n    lp = min(lp, dp);\n  }\n  \n  \n  float l = lp;\n  l = pmin(l, lx, 0.05);\n  l = pmin(l, ly, 0.05);\n  l -= 0.025;\n  return l*s;\n}\n\n\nfloat circles(vec2 p) {\n  vec2 pp = toPolar(p);\n  const float ss = 2.0;\n  pp.x = fract(pp.x/ss)*ss;\n  p = toRect(pp);\n  float d = circle(p, 1.0);\n  return d;\n}\n\nvec2 df(vec2 p, float h) {\n  vec2 wp = p;\n  float rep = 2.0*round(mix(3.0, 12.0, h*h));\n  float ss = 0.05*6.0/rep;\n\n  if (current_effect.sk > 0.0) {\n    smoothKaleidoscope(wp, ss, rep);\n  }\n  \n  float sss = mix(3.0, 6.0, h*h);\n  float d0 = weird3(wp/sss, h)*sss;\n  float d1 = hex(p, 0.25)-0.1;\n  float d2 = circles(p);\n  const float lw = 0.0125;\n  d2 = abs(d2)-lw;\n  float d = d0;\n\n  if (current_effect.cs > 0.0) {\n    d  = pmin(d, d2, 0.1);\n  }\n\n  d  = pmin(d, abs(d1)-lw, 0.1);\n  d  = max(d, -(d1+lw));\n  return vec2(d, d1+lw);\n}\n\nvec2 df(vec3 p, vec3 off, float s, mat2 rot, float h) {\n  vec2 p2 = p.xy;\n  p2 -= off.xy;\n  p2 *= rot;\n  return df(p2/s, h)*s;\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  float ld = max(dot(rd, vec3(0.0, 0.0, 1.0)), 0.0);\n  return 1.0*sunCol*tanh_approx(3.0*pow(ld, 100.0));\n}\n\nvec4 plane(vec3 ro, vec3 rd, vec3 pp, float pd, vec3 off, float aa, float n) {\n  int pi = int(mod(n/PLANE_PERIOD, float(effects.length())));\n  current_effect = effects[pi];\n  \n  float h = hash(n);\n  float s = 0.25*mix(0.5, 0.25, h);\n  const float lw = 0.0235;\n  const float lh = 1.25;\n\n  const vec3 loff = 2.0*vec3(0.25*0.5, 0.125*0.5, -0.125);\n  vec3 lp1  = ro + loff;\n  vec3 lp2  = ro + loff*vec3(-2.0, 1.0, 1.0);\n\n  vec2 p = pp.xy-off.xy;\n\n  mat2 rot = ROT(TAU*h);\n\n  vec2 d2 = df(pp, off, s, rot, h);\n\n  float hh = -1.0*smoothstep(-aa, aa*3.0, -d2.x);\n  // Well this doesn't seem to work in shadertoy.\n  float hhx = dFdx(hh);\n  float hhy = dFdy(hh);\n  vec3  hn = normalize(vec3(hhx, hhy, -1));\n\n  const vec3 nn  = vec3(0.0, 0.0, -1.0);\n  vec3 ld1   = normalize(lp1 - pp);\n  vec3 ld2   = normalize(lp2 - pp);\n  float dif1 = pow(max(dot(nn, ld1), 0.0), 5.0);\n  float dif2 = pow(max(dot(nn, ld2), 0.0), 5.0);\n  vec3 ref   = reflect(rd, hn);\n  float spe1= pow(max(dot(ref, ld1), 0.0), 30.0);\n  float spe2= pow(max(dot(ref, ld2), 0.0), 30.0);\n\n  const float boff = 0.0125*0.5;\n  float dbt = boff/rd.z;\n  \n  vec3 bpp = ro + (pd + dbt)*rd;\n  vec2 bp = bpp.xy - off.xy;\n\n  vec3 srd1 = normalize(lp1-bpp);\n  vec3 srd2 = normalize(lp2-bpp);\n  float bl21= L2(lp1-bpp);\n  float bl22= L2(lp2-bpp);\n\n  float st1 = -boff/srd1.z;\n  float st2 = -boff/srd2.z;\n\n  vec3 spp1 = bpp + st1*srd1;\n  vec3 spp2 = bpp + st2*srd2;\n  \n  vec2 bd  = df(bpp, off, s, rot, h);\n  vec2 sd1 = df(spp1, off, s, rot, h);\n  vec2 sd2 = df(spp2, off, s, rot, h);\n\n  vec3 col  = vec3(0.0);\n  const float ss = 200.0;\n\n  col       += 0.1125*planeCol*dif1*(1.0-exp(-ss*(max((sd1.x), 0.0))))/bl21;\n  col       += 0.1125*planeCol*dif2*0.5*(1.0-exp(-ss*(max((sd2.x), 0.0))))/bl22;\n  \n  vec3 ringCol = baseRingCol;\n  ringCol *= vec3(clamp(0.1+2.5*(0.1+0.25*((dif1*dif1/bl21+dif2*dif2/bl22))), 0.0, 1.0));\n  ringCol += sqrt(baseRingCol)*spe1*2.0;\n  ringCol += sqrt(baseRingCol)*spe2*2.0;\n  col       = mix(col, ringCol, smoothstep(-aa, aa, -d2.x));  \n\n  float ha = smoothstep(-aa, aa, bd.y);\n\n  return vec4(col, mix(0.0, 1.0, ha));\n}\n\nvec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p) {\n  float lp = length(p);\n  vec2 np = p + 1.0/RESOLUTION.xy;\n  float rdd = (2.0-0.5*tanh_approx(lp));  // Playing around with rdd can give interesting distortions\n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n  vec3 nrd = normalize(np.x*uu + np.y*vv + rdd*ww);\n\n  const float planeDist = 1.0-0.75;\n  const int furthest = 9;\n  const int fadeFrom = max(furthest-4, 0);\n  const float fadeDist = planeDist*float(furthest - fadeFrom);\n  float nz = floor(ro.z / planeDist);\n\n  vec3 skyCol = skyColor(ro, rd);\n\n  // Steps from nearest to furthest plane and accumulates the color\n\n  vec4 acol = vec4(0.0);\n  const float cutOff = 0.95;\n  bool cutOut = false;\n  \n  for (int i = 1; i <= furthest; ++i) {\n    float pz = planeDist*nz + planeDist*float(i);\n\n    float pd = (pz - ro.z)/rd.z;\n\n    if (pd > 0.0 && acol.w < cutOff) {\n      vec3 pp = ro + rd*pd;\n      vec3 npp = ro + nrd*pd;\n\n      float aa = 3.0*length(pp - npp);\n\n      vec3 off = offset(pp.z);\n\n      vec4 pcol = plane(ro, rd, pp, pd, off, aa, nz+float(i));\n\n      float nz = pp.z-ro.z;\n      float fadeIn = exp(-2.5*max((nz - planeDist*float(fadeFrom))/fadeDist, 0.0));\n      float fadeOut = smoothstep(0.0, planeDist*0.1, nz);\n      pcol.xyz = mix(skyCol, pcol.xyz, (fadeIn));\n      pcol.w *= fadeOut;\n\n      pcol = clamp(pcol, 0.0, 1.0);\n\n      acol = alphaBlend(pcol, acol);\n    } else {\n      cutOut = true;\n      break;\n    }\n\n  }\n\n  vec3 col = alphaBlend(skyCol, acol);\n// To debug cutouts due to transparency  \n//  col += cutOut ? vec3(1.0, -1.0, 0.0) : vec3(0.0);\n  return col;\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, 1.0/std_gamma);\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvec3 color(vec2 p, vec2 q) {\n  float tm  = TIME*0.15+0.3;\n  vec3 ro   = offset(tm);\n  vec3 dro  = doffset(tm);\n  vec3 ddro = ddoffset(tm);\n\n  vec3 ww = normalize(dro);\n  vec3 uu = normalize(cross(normalize(vec3(0.0,1.0,0.0)+ddro), ww));\n  vec3 vv = normalize(cross(ww, uu));\n\n  vec3 col = color(ww, uu, vv, ro, p);\n  col = postProcess(col, q);\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = color(p, q);\n\n  fragColor = vec4(col, 1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlyfRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 1190, 1212, 1212, 1275], [1277, 1277, 1299, 1299, 1343], [1345, 1345, 1366, 1366, 1411], [1413, 1413, 1458, 1458, 1612], [1614, 1614, 1675, 1675, 1883], [1885, 1885, 1925, 1925, 2084], [2086, 2086, 2126, 2126, 2168], [2170, 2170, 2198, 2218, 2294], [2296, 2296, 2335, 2335, 2423], [2425, 2425, 2456, 2456, 2482], [2484, 2484, 2512, 2512, 2712], [2714, 2714, 2747, 2747, 3131], [3304, 3325, 3347, 3347, 3481], [3483, 3562, 3585, 3585, 3660], [3662, 3732, 3756, 3756, 3835], [3837, 4017, 4048, 4048, 4717], [4720, 4720, 4743, 4743, 4879], [4881, 4881, 4907, 4907, 5412], [5414, 5414, 5469, 5469, 5542], [5544, 5544, 5577, 5577, 5685], [5687, 5687, 5765, 5765, 7774], [7776, 7776, 7832, 7832, 9375], [9377, 9377, 9413, 9413, 9646], [9648, 9648, 9676, 9676, 10008], [10010, 10010, 10065, 10065, 10222]], "test": "error"}
{"id": "Wlyfzw", "name": "Oriental rug", "author": "jarble", "description": "This fractal pattern looks like an oriental rug!", "tags": ["fractal", "carpet", "rug"], "likes": 3, "viewed": 257, "published": "Public API", "date": "1614043983", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//vec3 c1 = vec3(7.0,5.0,1.4); //change this constant to get different patterns!\n//vec3 c1 = vec3(7.0,9.0,1.4);\nvec3 c1 = vec3(2.0,2.5,1.4); //looks like a carpet\n//vec3 c1 = vec3(1.7,1.9,1.3);\n\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    float t1 = 4.0;\n    float offset = .16;\n    float scale2 = 1.02;\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    for(int c=0;c<3;c++){\n        float scale = c1.z;   \n        for(int i=0;i<6;i++)\n        {          \n            uv = triangle_wave(uv+offset,scale)+triangle_wave(uv.yx,scale);\n            uv = triangle_wave(uv+col.xy,scale);\n            scale /= scale2+col.x;\n            offset /= scale2;\n            uv.y /= -1.0;\n        }\n     col[c] = fract((uv.x)-(uv.y));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wlyfzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 196, 235, 235, 280], [282, 282, 339, 339, 978]], "test": "valid"}
{"id": "wt3BR4", "name": "Constant thickness grid", "author": "hamtarodeluxe", "description": "Trying to draw an anti-aliased constant thickness grid, as if its lines were screen space.\nThere might be room for improvement. Wish I could go thinner without pattern :)\n", "tags": ["grid", "lines", "antialiasing"], "likes": 10, "viewed": 184, "published": "Public", "date": "1612309607", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Trying to draw an anti-aliased constant thickness grid, as if its lines were screen space.\n// After intersecting the ground plane, grid collisions are searched along the view ray. Grid dilates with distance.\n// Right is the naive constant thickness 2D grid render.\n\nfloat linStep(float x0, float x1, float t)\n{\n    return smoothstep(x0, x1, t);\n    return clamp((t - x0) / (x1 - x0), 0.f,1.f);\n}\n\n// Intersect the 2D unit grid.\n// Returns first and second intersections\n// distances along the ray.\nvec2 intersectGrid(vec2 p, vec2 r)\n{\n    vec2 t = fract(sign(r) * p ) / abs(r);\n    return t.x < t.y ? t.xy : t.yx;\n/*\n    vec2 s = sign(r);\n    vec2 t = vec2(s.x < 0.0f ? fract(p.x) : 1.0f-fract(p.x),\n                  s.y < 0.0f ? fract(p.y) : 1.0f-fract(p.y)) / r;\n    t = abs(t.xy);\n\n    return t.x < t.y ? t.xy : t.yx;\n*/\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy ) / iResolution.x;\n   \n    // Camera\n    vec3 camPos = vec3 ( 5.*sin(0.1*iTime),2.3,5.0*cos(0.1*iTime));\n   \tvec3 lookAt = vec3 (0.,0.,0.);\n    vec3 fw = normalize(lookAt-camPos);\n    vec3 right = cross(vec3(0.,1.,0.), fw);\n    vec3 up = cross (fw, right);\n    vec3 rd = normalize( fw * 0.6 + right * uv.x + up * uv.y);\n    \n    // Raycast ground\n    vec3 isec = camPos + (camPos.y)* (rd/abs(rd.y));\n    \n    vec2 p = isec.xz;\n    vec2 rdGrid = normalize(rd.xz);\n    \n    vec2 scale = vec2(0., 1.7) / iResolution.x;    \n    float v = 1.0f;\n    vec2 t;\n    vec2 rdSearch2D;\n    vec3 rdSearch;\n    \n    // Intesects in direction +rd\n    rdSearch2D = rdGrid;\n    rdSearch = rd;\n    t = intersectGrid(p, rdSearch2D);\n    {\n        // First intersection\n        vec3 isec2 = isec + (rdSearch/abs(rdSearch.x)) *  abs(rdSearch2D.x*t.x);\n        float s = length(camPos - vec3(isec2.x, 0, isec2.z));\n        v *= linStep(scale.x * s, scale.y * s, abs(isec2.y));\n    }\n    {\n        // Second intersection\n        vec3 isec2 = isec + (rdSearch/abs(rdSearch.x)) *  abs(rdSearch2D.x*t.y);\n        float s = length(camPos - vec3(isec2.x, 0, isec2.z));\n        v *= linStep(scale.x * s, scale.y * s, abs(isec2.y));\n    }\n    \n    // Intesects in direction -rd\n    rdSearch2D = -rdGrid;\n    rdSearch = -rd;\n    t = intersectGrid(p, rdSearch2D);\n    {\n        // First intersection\n        vec3 isec2 = isec + (rdSearch/abs(rdSearch.x)) *  abs(rdSearch2D.x*t.x);\n        float s = length(camPos - vec3(isec2.x, 0, isec2.z));\n        v *= linStep(scale.x * s, scale.y * s, abs(isec2.y));\n    }\n    {\n        // Second intersection\n        vec3 isec2 = isec + (rdSearch/abs(rdSearch.x)) *  abs(rdSearch2D.x*t.y);\n        float s = length(camPos - vec3(isec2.x, 0, isec2.z));\n        v *= linStep(scale.x * s, scale.y * s, abs(isec2.y));\n    }\n\n    // Naive 2D grid render, for\n    // view forward parallel rays.\n    // Also used for reference.\n    {\n        vec2 frp = fract(p);\n        vec2 ceilp = ceil(p);\n        vec2 floorp = floor(p);\n        vec2 d = vec2(frp.x > 0.5f ? ceilp.x : floorp.x, frp.y > 0.5f ? ceilp.y :floorp.y);\n        vec2 dd = abs(p - d);\n        vec2 closest = dd.x < dd.y ? vec2(d.x, p.y) :  vec2(p.x, d.y);               \n        float s = length(camPos - vec3(closest.x, 0., closest.y));\n        float sdf = length(p-closest);\n        \n        float v0 = linStep(scale.x * s, scale.y * s, sdf);\n        v *= v0;\n        \n        // Naive method reference.\n        if (uv.x>0.)\n            v = linStep(scale.x * s, scale.y * s, sdf);\n    }\n    \n    fragColor = rd.y < 0.0f ? vec4(mix(0.53, 0.006, v)) : vec4(0.);\n    fragColor = pow(fragColor, vec4(1./2.2) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3BR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 269, 313, 313, 398], [400, 501, 537, 537, 829], [831, 831, 888, 888, 3607]], "test": "valid"}
{"id": "wt3BR7", "name": "someLockdownstuff", "author": "antoinefortin", "description": "jj", "tags": ["firework"], "likes": 3, "viewed": 63, "published": "Public", "date": "1613021489", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NUM_PARTICLES 100.\n\nvec2 rotate(vec2 pos, float angle)\n{\n\tfloat c = cos(angle);\n    float s = sin(angle);\n    \n    return mat2(c,s,-s,c) * pos;\n\n}\n\n\nvec2 Hash12(float t)\n{\n\n    float x = fract(sin(t * 425.) * 389.);\n    \n    float y = fract(sin((t + x) * 545.) * 435.);\n    \n    \n    return vec2(x,y);\n}\n\n\nvec2 Hash12Polar(float t)\n{\n\n    float a = fract(sin(t * 425.) * 389.) * 6.2832;\n    float d = fract(sin((t + a) * 545.) * 435.);\n    \n    \n    return vec2(sin(a), cos(a)) * d;\n}\n\n\nfloat Explosion(vec2 uv, float t)\n{\n\n\n    float sparks = 0.;\n    for(float i = 0.; i< NUM_PARTICLES; i++)\n    {\n        vec2 dir= Hash12Polar(i) * .5;  \n        float d = length(uv  - dir * t);\n        float brightness = .0005;\n        sparks += brightness/d;\n    }\n    \n    return sparks;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord -.5 * iResolution.xy)/iResolution.y;\n    \n    uv.xy = rotate(uv.xy, iTime + abs(cos(iTime)) + abs(sin(iTime)));\n    // Time varying pixel color\n    vec3 col = vec3(0);\n   \n    vec3 color = abs( sin(vec3(.34, .55, .65) * floor(iTime))) * .5 + .5;\n    col += Explosion(uv, abs(sin(iTime)) + .5 * cos(uv.x * iTime * uv.y * 5.)) * color;\n    col *= (1.5);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3BR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 28, 64, 64, 154], [157, 157, 179, 179, 311], [314, 314, 341, 341, 492], [495, 495, 530, 530, 786], [789, 789, 846, 896, 1331]], "test": "valid"}
{"id": "wt3BRX", "name": "Uniform Distribution on Disk", "author": "katayu", "description": "A pseudorandom sampling from the uniform  probability distribution on disk.", "tags": ["raymarching"], "likes": 3, "viewed": 1135, "published": "Public API", "date": "1613149731", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n * Modification of the following are used in this shader.\n * - Random Function: https://www.shadertoy.com/view/Xt23Ry\n * - Raymarching part1: https://www.shadertoy.com/view/llt3R4\n*/\n\n\n/**\n * Generate random values\n*/\nfloat fade(float value, float start, float end)\n{\n    return (clamp(value,start,end)-start)/(end-start);\n}\nfloat rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\nfloat rand(vec3 co){ return rand(co.xy+rand(co.z));}\n\n\n/*\n * Raymarching\n*/\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\n/**\n * Signed distance function for a sphere centered at the origin with radius 1.0;\n */\nfloat sphereSDF(vec3 samplePoint) {\n    return length(samplePoint) - 1.0;\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {\n    return sphereSDF(samplePoint);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 dir = rayDirection(45., iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.0, 5.1);\n    float dist = shortestDistanceToSurface(eye, dir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.,0, 0., 0.0);\n\t\treturn;\n    }\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float sampling= rand(vec3(uv, iTime));\n    sampling = (sampling > 0.5) ? 1.:0.;\n    //vec3 color = vec3(0., 0.5, 0.5);\n    vec3 color = vec3(1.,1.,1.);\n    color *= sampling;\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3BRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[189, 222, 271, 271, 328], [329, 329, 351, 351, 399], [400, 400, 420, 420, 488], [489, 489, 509, 509, 541], [690, 779, 814, 814, 854], [856, 1096, 1130, 1130, 1167], [1169, 1590, 1681, 1681, 1987], [2002, 2256, 2321, 2321, 2453], [2456, 2456, 2513, 2513, 3071]], "test": "valid"}
{"id": "wt3BW2", "name": "Genuary 2021 – 10 – TREE (A01)", "author": "endymion", "description": "Trying desperately to understand fractal math. \nProps to Passion (https://www.shadertoy.com/view/Xdy3RK) for the original fractal math. ", "tags": ["fractal", "noise", "fbm"], "likes": 3, "viewed": 63, "published": "Public", "date": "1613450149", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define PI 3.14159265359\n\n/**\n * Noise\n * @src https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83#perlin-noise\n */\n \n // Noise: Random\nfloat rand(vec2 c){\n    return fract(sin(dot(c.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Noise: Basic noise\nfloat noise(vec2 p, float freq){\n    float unit = iResolution.x / freq;\n    vec2 ij = floor(p / unit);\n    vec2 xy = .5 * (1. - cos(PI * mod(p, unit) / unit));\n    float a = rand((ij + vec2(0., 0.)));\n    float b = rand((ij + vec2(1., 0.)));\n    float c = rand((ij + vec2(0., 1.)));\n    float d = rand((ij + vec2(1., 1.)));\n    float x1 = mix(a,b,xy.x);\n    float x2 = mix(c,d,xy.x);\n    return mix(x1,x2,xy.y);\n}\n\n/**\n * Fractional Brownian Motion\n * @src https://thebookofshaders.com/13/\n */\nfloat fbm(in vec2 _st, in int octaves) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n    for (int i = 0; i < octaves; ++i) {\n        v += a * noise(_st, 2000. + abs(1000. * sin(iTime * 0.009)));\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n/**\n * Fractal, aka. black magic\n * @src https://www.shadertoy.com/view/Xdy3RK\n * @author Passion, 2016\n */\n// 2D Rotation\nmat2 rot(float deg){    \n    return mat2(cos(deg),-sin(deg),\n                sin(deg), cos(deg));\n}\n    \n// The Fractal\nvec2 fractal(vec2 uv, float time, int iterations) {    \n    for(int i = 0; i<iterations; i++){\n        uv = abs(uv) / dot(uv, uv);\n        uv.x = abs(uv.x + cos(time * .6) * .5);\n        uv.x = abs(uv.x - .8);\n        uv = abs(rot(-time * .3) * uv);\n        uv.y = abs(uv.y - .5);\n        uv.y = abs(uv.y + .03 +sin(time) * .25);\n    }\n    uv = abs(uv) / float(iterations);\n    \n    return uv;\n}\n \n/**\n * HSB to RGB\n * All components are in the range [0…1], including hue.\n * @src https://stackoverflow.com/a/17897228\n */\nvec3 hsb2rgb(in vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n/**\n * Map range to new range\n */\nfloat map(float value, float min1, float max1, float min2, float max2) {\n    return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\n/**\n * Simplex noise\n * @src https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83#simplex-noise\n */\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat snoise(vec2 v){\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return map(130.0 * dot(m, g), -1., 1., 0., 1.);\n}\n\n/** \n * Get color\n */\nvec3 getColor(in vec2 point, in vec3 colorA, in vec3 colorB) {\n    float dist = point.x / (point.x + point.y);\n    return mix(colorA, colorB, dist);\n}\n\n/**\n * @main\n */\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Time\n    float k2 = 0.5; // getLPD8Value(LPD8_K2);\n    float time = iTime * (k2 + 0.05);\n    \n    // Center uv coordinates\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n   \n    // Rotation\n    float k3 = 0.55; // getLPD8Value(LPD8_K3);\n    uv *= rot(time * (.1 + .5 * k3));\n    \n    // Fractal\n    float k1 = 0.2; // getLPD8Value(LPD8_K1);\n    uv = fractal(uv, time, int(floor(1. + 10. * k1)));\n    \n    // Colors\n    float k5 = 0.3; //getLPD8Value(LPD8_K5);\n    float k6 = 0.75; //getLPD8Value(LPD8_K6);\n    float k7 = 0.6; //getLPD8Value(LPD8_K7);\n    float k8 = 0.6; //getLPD8Value(LPD8_K7);\n    \n    vec3 color = getColor(uv, vec3(k5, k7, uv.x), vec3(k6, k8, uv.y));\n    \n    // Noise\n    float pixelNoise = snoise(uv * 300.);\n    \n    fragColor = vec4(hsb2rgb(vec3(\n        color.x,\n        color.y,\n        color.z * 1.6 + pixelNoise * 0.1\n    )), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3BW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[134, 151, 170, 170, 242], [244, 266, 298, 298, 679], [681, 760, 800, 800, 1155], [1157, 1280, 1300, 1300, 1379], [1385, 1400, 1451, 1451, 1795], [1798, 1924, 1949, 1949, 2118], [2120, 2154, 2226, 2226, 2294], [2296, 2409, 2431, 2431, 2470], [2472, 2472, 2493, 2493, 3335], [3337, 3359, 3421, 3421, 3509], [3511, 3528, 3583, 3595, 4518]], "test": "valid"}
{"id": "Wt3BWr", "name": "Basic raymarch lava lamp", "author": "tupto", "description": "The result of my first day learning how to create raymarching shaders", "tags": ["3d", "raymarching", "lava"], "likes": 4, "viewed": 82, "published": "Public", "date": "1612476845", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//The result of my first day learning how to create raymarching shaders\n//Massive shoutout to Inigo Quiles and Jamie Wong for their tutorials\n\nconst int MAX_STEPS = 100;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\nconst int NUM_BUBBLES = 20;\n\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sunion(float obj1, float obj2, float k) { return smin(obj1, obj2, k); }\n\nfloat sdfSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\nfloat hash(float x)\n{\n    return fract(sin(x * 171.2972) * 18267.978 + 31.287);\n}\nvec2 hash2(in vec2 p)\n{\n\treturn fract(1965.5786 * vec2(sin(p.x * 591.32 + p.y * 154.077), cos(p.x * 391.32 + p.y * 49.077)));\n}\n\nfloat map(vec3 p)\n{\n\tfloat final = MAX_DIST;\n\tfor (int i = 0; i < NUM_BUBBLES; i++)\n\t{\n\t\tvec3 pos = p;\n\t\tpos.xy += (hash2(vec2(float(i)))) * 2.0 - 1.0;\n\t\tpos.y += sin(iTime * hash(float(i)) + hash(float(i)));\n\t\tfloat r = hash(float(i) * 0.6) * 0.6;\n\t\tfloat bubble = sdfSphere(pos, r);\n\t\t\n\t\tfinal = sunion(final, bubble, 0.2);\n\t}\n\t\n\treturn final;\n}\n\nvec3 rayDirection(float fov, vec2 res, vec2 fragCoord)\n{\n\tvec2 xy = fragCoord - res / 2.0;\n\tfloat z = res.y / tan(radians(fov) / 2.0);\n\t\n\treturn normalize(vec3(xy, -z));\n}\n\nfloat rayMarch(vec3 cam, vec3 dir, float start, float end)\n{\n\tfloat depth = start;\n\t\n\tfor (int i = 0; i < MAX_STEPS; i++)\n\t{\n\t\tfloat dist = map(cam + depth * dir);\n\t\tif (dist < EPSILON)\n\t\t{\n\t\t\treturn depth;\n\t\t}\n\t\t\n\t\tdepth += dist;\n\t\tif (depth >= end)\n\t\t{\n\t\t\treturn end;\n\t\t}\n\t}\n\t\n\treturn end;\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        map(vec3(p.x + EPSILON, p.y, p.z)) - map(vec3(p.x - EPSILON, p.y, p.z)),\n        map(vec3(p.x, p.y + EPSILON, p.z)) - map(vec3(p.x, p.y - EPSILON, p.z)),\n        map(vec3(p.x, p.y, p.z  + EPSILON)) - map(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 gouraud(vec3 pos, vec3 normal, vec3 lightPos, vec3 lightCol, vec3 cam)\n{\n\tvec3 camVec = normalize(pos - cam);\n\tvec3 reflection = reflect(camVec, normal);\n\t\n\tfloat dist = length(lightPos - pos);\n\tvec3 toLight = normalize(lightPos - pos);\n\t\n\tfloat diffuse = clamp(max(dot(normal, toLight), 0.0), 0.0, 1.0);\n\treturn diffuse * lightCol;\n}\n\nvoid fragment()\n{\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n\t\n\tvec3 cam = vec3(0.0, 0.0, 5.0);\n\tfloat dist = rayMarch(cam, dir, MIN_DIST, MAX_DIST);\n\t\n\tvec3 lightpos = vec3(0.0, 0.0, 10.0);\n\t//vec3 lightpos = vec3(5.0 * cos(TIME * 0.25), 5.0 * sin(TIME * 0.5), sin(TIME) * 2.0);\n\t\n\tif (dist > MAX_DIST - EPSILON)\n\t{\n\t\t//MISS\n\t\tfragColor = vec4(vec3(0.0), 1.0);\n\t}\n\telse\n\t{\n\t\t//HIT\n\t\tvec3 pos = cam + dir * dist;\n\t\tfragColor.xyz = gouraud(pos, estimateNormal(pos), lightpos, vec3(1.0, 0.0, 0.0), cam);\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt3BWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 289, 330, 330, 420], [422, 422, 469, 469, 499], [501, 501, 537, 537, 561], [564, 564, 585, 585, 645], [646, 646, 669, 669, 773], [775, 775, 794, 794, 1122], [1124, 1124, 1180, 1180, 1295], [1297, 1297, 1357, 1357, 1590], [1592, 1592, 1621, 1621, 1901], [1903, 1903, 1980, 1980, 2242], [2244, 2244, 2261, 2261, 2264], [2266, 2266, 2323, 2323, 2828]], "test": "valid"}
{"id": "wt3fWr", "name": "Moiré 3c", "author": "FabriceNeyret2", "description": "Shadows of 2 identical parallel plates with hexa-tiled holes. \nHere, the second plates rotate over time. \n( you might try a slight perspective effect by changing the coef line 16. )", "tags": ["aliasing", "interference", "moir", "reproduction"], "likes": 5, "viewed": 166, "published": "Public API", "date": "1612514071", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://shadertoy.com/view/3ldBzM\n// variant of https://shadertoy.com/view/WltBzM\n// adapted from https://shadertoy.com/view/ttd3D7\n\n#define D   length( mod( U += T/2. , T ) - k )               //\n#define P   clamp( 1.- ( min( D, D ) -.8*k.y )/5. ,0.,1.)    // draw an hexa tiling of disks\n\nvoid mainImage(out vec4 O, vec2 u) {\n   vec2 R = iResolution.xy,\n        U = 4.*(u-R/2.),\n        V = U * mat2( cos( .05*iTime + vec4(0,11,33,0) ) ),\n\n        k = R.yy/8., T = vec2( 2, 3.5 )*k;\n    O += P -O;\n\n    U = 1.0*V; // try 1.1\n    O *= P;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3fWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 305, 341, 341, 554]], "test": "error"}
{"id": "Wt3fzN", "name": "Diffeomorphism with gradient", "author": "bakugod", "description": "test test", "tags": ["gradient", "diffeomorphism"], "likes": 0, "viewed": 56, "published": "Public", "date": "1612306949", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float grid(vec2 st, float res, float scale)\n{\n  vec2 grid = fract(st*res);\n  return (pow(scale,grid.x) * pow(scale,grid.y));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy /iResolution.xy;\n\n    float a = uv[0];\n    float b = uv[1];\n    \n    vec2 manifold = vec2(\n        pow(a, 2.0) + \n        pow(b, 3.0), \n        pow(a, 2.0) - \n        pow(b, 3.0));\n    //ceil\n    vec2 manifold2 = vec2(\n        sin(pow(manifold[0], 2.0) + pow(manifold[1], 2.0)), \n        cos(pow(manifold[0], 2.0) + pow(manifold[1], 2.0)) );\n        \n    vec2 sur_def = vec2(\n    clamp(dFdx(manifold[0]/ manifold2[0])* iTime, .001, .002),\n    clamp(dFdy(manifold[0]/ manifold2[1])* iTime, .001, .002) );\n   \n   \n    float r = ceil( iTime + (manifold2[0]) + cos((manifold2[1])) );\n    // scale = 5.15\n    float x = grid( ( manifold2 - manifold  + sin(iTime*.02) ), 15.0, .15 );\n\n\n    vec3 col = 0.6 + 0.3*cos(iTime+uv.xyx+vec3(0,8,16));\n    // first pow = 1.2\n    fragColor.rgb = vec3( clamp(reflect(col * x, pow(col,vec3(2.2)) - pow(x,1.5)), .0, .6) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt3fzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 45, 45, 126], [129, 129, 186, 186, 1068]], "test": "valid"}
{"id": "wt3fzX", "name": "Glowing Flower", "author": "yozic", "description": "More domain warping fun.", "tags": ["kaleidoscope", "trippy"], "likes": 11, "viewed": 303, "published": "Public API", "date": "1613155104", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592\n#define orbs 20.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n}\n\nvec4 orb(vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate(float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = 23.09 * (2. * fragCoord - iResolution.xy) / iResolution.y;\n  float dist = length(uv);\n  uv *= rotate(iTime / 20.);\n  uv = kale(uv, vec2(6.97), 6.);\n  uv *= rotate(iTime / 5.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += 0.57 * sin(0.3 * uv.y + iTime);\n    uv.y -= 0.63 * cos(0.53 * uv.x + iTime);\n    float t = i * PI / orbs * 2.;\n    float x = 4.02 * tan(t + iTime / 10.);\n    float y = 4.02 * cos(t - iTime / 30.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / 5.37)) * 0.5 + 0.5;\n    fragColor += orb(uv, 1.39, position, color, 1.37);\n  }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3fzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 84, 84, 340], [342, 342, 416, 416, 496], [498, 498, 524, 524, 590], [592, 592, 647, 647, 1266]], "test": "valid"}
{"id": "wtcBD8", "name": "ghostly circle ", "author": "anemolo", "description": "its a cghostly circle bc mario said so", "tags": ["circle"], "likes": 1, "viewed": 37, "published": "Public", "date": "1612615109", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circleSDF(vec2 uv, float time){\n    uv += sin(time + uv *10.) * 0.01;\n    return length(uv);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    float ghost = 0.;\n    for(int i =0; i < 20; i++){\n        float ni = float(i)/20.;\n        float sdf = circleSDF(uv, iTime + float(ni) * 10.);\n        ghost += step(\n        abs(sdf - 0.25 - ni * 0.1 ),0.05  - ni * 0.1) * ni;\n    \n    }\n    // Output to screen\n    \n    col = 1.-vec3(ghost);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtcBD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 100], [101, 101, 158, 208, 680]], "test": "valid"}
{"id": "wtcBR7", "name": "neural sdf human head (sloppy)", "author": "kylegrover", "description": "based on work by Blackle Mori\n\nCurrently really sloppy but I'm just amazed that something like this is possible. I'm averaging 2 separate SDFs from 2 runs of the neural net. Compile time is a little absurd but it seems to still run really smooth.", "tags": ["sdf", "siren"], "likes": 2, "viewed": 151, "published": "Public", "date": "1612421691", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//like the last few shaders I've published, this is a neural network experiment.\n//this time, the neural network reproduces an SDF given the x,y,z coordinates\n//using siren networks with skip connections: https://vsitzmann.github.io/siren/\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat scene(vec3 p) {\n    //sdf is undefined outside the unit sphere, uncomment to witness the abominations\n    if (length(p) > 0.75) {\n        return length(p)-.65;\n    }\n    // p.y = -abs(p.y);\n    p.y = -(sqrt(p.y*p.y + 0.005) - sqrt(0.001));\n    \n    // take 2\n    vec4 f0_0=sin(p.y*vec4(1.48,-1.68,-3.32,2.95)+p.z*vec4(-.12,-.83,-1.70,-.47)+p.x*vec4(-.36,1.70,1.77,1.85)+vec4(1.67,-.03,2.51,-7.18));\nvec4 f0_1=sin(p.y*vec4(1.02,1.82,-3.30,-1.41)+p.z*vec4(-2.81,2.35,-3.88,-4.47)+p.x*vec4(-1.21,-.52,.19,-2.17)+vec4(-6.88,-5.92,-3.90,-4.66));\nvec4 f0_2=sin(p.y*vec4(3.00,-.87,4.30,-4.43)+p.z*vec4(2.27,2.32,-1.08,-2.96)+p.x*vec4(-3.65,-3.97,2.94,-1.32)+vec4(.40,-7.63,-5.64,1.98));\nvec4 f0_3=sin(p.y*vec4(-2.64,1.06,4.59,4.02)+p.z*vec4(1.99,2.35,1.39,-3.11)+p.x*vec4(3.32,-4.37,3.49,-1.95)+vec4(4.58,1.26,4.87,1.04));\nvec4 f0_4=sin(p.y*vec4(-.21,3.74,-2.31,-3.79)+p.z*vec4(3.30,.70,1.28,.20)+p.x*vec4(-1.55,-.11,3.81,3.74)+vec4(-7.32,4.56,8.31,5.06));\nvec4 f0_5=sin(p.y*vec4(-3.34,-4.36,-3.70,-1.42)+p.z*vec4(-.49,-.31,2.22,-2.62)+p.x*vec4(-1.34,-4.12,1.47,-2.72)+vec4(-5.52,3.75,-6.40,7.51));\nvec4 f0_6=sin(p.y*vec4(1.31,-.77,1.90,-1.95)+p.z*vec4(-3.67,.84,.56,-.37)+p.x*vec4(-.34,2.11,-3.65,-4.04)+vec4(4.30,-7.84,3.96,-7.10));\nvec4 f0_7=sin(p.y*vec4(-1.83,-1.40,.55,-.75)+p.z*vec4(-1.07,4.73,4.49,3.75)+p.x*vec4(1.69,2.75,.40,2.46)+vec4(8.26,-.92,.82,6.15));\nvec4 f1_0=sin(mat4(.21,-.60,.04,.14,-.09,.34,-.27,.49,.31,-.14,-.94,1.29,-.29,.12,.21,-.33)*f0_0+\n    mat4(-.17,.69,.04,-.10,.05,-.38,.25,-1.09,.02,.34,-.05,-.39,.22,-.36,-.86,-.02)*f0_1+\n    mat4(.27,-.18,-.44,-1.55,-.34,-.01,.40,-.67,-.06,.40,-.25,-.64,.53,.24,-.53,.10)*f0_2+\n    mat4(-.43,-.98,-.23,1.46,-.56,-.00,.35,-.70,.34,-.11,-1.15,-.50,.16,.66,-.04,-.48)*f0_3+\n    mat4(-.01,-.26,-.42,.81,-.06,-.01,-.62,-.31,.31,-1.00,-.58,.47,-.11,-.41,-.70,-.95)*f0_4+\n    mat4(-.14,-.10,-.04,.07,-.34,-.30,.74,.73,-.13,.24,.24,.08,-.23,-.07,.49,-.01)*f0_5+\n    mat4(-.22,.11,-.44,.44,-.33,.35,.39,-.00,-.01,-.44,.14,-.95,-.09,.09,-.14,.54)*f0_6+\n    mat4(-.05,-.10,.35,.54,.09,.34,-.68,.27,-.35,-.37,.78,-.21,-.29,-.15,.38,.67)*f0_7+\n    vec4(1.15,-1.90,-.09,-2.53))/1.0+f0_0;\nvec4 f1_1=sin(mat4(.17,.21,-.41,.16,.46,-.64,-.03,.11,-.75,-.66,.20,.28,-.21,.04,-.06,-.16)*f0_0+\n    mat4(-.19,.84,.09,.57,.20,.09,-.30,.36,-.01,-.24,.98,-.16,-.06,.64,-.20,-.63)*f0_1+\n    mat4(.21,.37,-.08,-.14,-.43,.38,-.02,-.11,-.04,.21,-.55,-.40,-.01,-1.00,-.50,.07)*f0_2+\n    mat4(-.27,.23,.74,.28,.15,.34,.08,-.30,.90,.09,-.14,.54,-.33,1.17,.18,-.21)*f0_3+\n    mat4(-.21,.26,.43,.35,.03,-.67,.50,.44,-.41,-1.00,.32,.12,-.54,.18,.27,-.56)*f0_4+\n    mat4(.47,.75,-.43,-.17,-.57,-.24,.29,-.25,-.50,.50,.50,.10,.11,.94,.42,-.04)*f0_5+\n    mat4(-.79,.41,.48,-.29,-.15,.94,.55,-.12,.22,-.21,-.27,.02,-.14,-1.06,-.27,-.05)*f0_6+\n    mat4(.06,-.33,.44,-.21,.06,.82,-.25,-.54,-.35,.35,-.18,.01,-.37,.34,.27,-.05)*f0_7+\n    vec4(-1.75,-.77,-2.09,.05))/1.0+f0_1;\nvec4 f1_2=sin(mat4(.82,-.08,.28,-.35,-.07,-.12,-.01,-.02,-.12,.20,.76,-.27,-.62,-.14,.02,.16)*f0_0+\n    mat4(-.17,.49,.03,.41,-.46,.01,-.22,-.17,.23,-.26,-.40,.40,.44,.35,-.14,.36)*f0_1+\n    mat4(-.31,-.55,-1.02,-.10,.04,.18,-.29,.51,.22,.21,.18,-.44,.32,-.25,.59,-.20)*f0_2+\n    mat4(.62,.09,.26,.76,.28,.13,-.18,.09,.95,-.07,-.76,-.67,-.14,.11,-.14,-.32)*f0_3+\n    mat4(-.02,-.36,.15,.34,.40,-.35,.19,-.33,.21,.41,.71,.84,-.29,-.33,-.23,.04)*f0_4+\n    mat4(.28,-.20,-.23,-.23,-1.22,-.14,.64,.94,.09,-.03,.17,.05,-.09,-.21,-.56,.38)*f0_5+\n    mat4(-.35,-.25,.90,-.04,-.26,-.13,-.00,.24,-.26,.19,-.03,.00,.06,.07,1.08,-1.05)*f0_6+\n    mat4(.47,-.31,.49,.71,.31,-.08,-.67,.93,-.27,-.11,.19,-.32,-.31,.43,.35,-.60)*f0_7+\n    vec4(-1.13,2.28,1.93,.90))/1.0+f0_2;\nvec4 f1_3=sin(mat4(.27,-.33,-.31,.28,-.38,.35,-.04,.16,-.12,.58,.14,.41,-.06,.43,-.53,-.28)*f0_0+\n    mat4(.47,.64,-.05,.63,-.10,.01,.43,.30,-.30,.54,.48,-.44,-.20,-.01,.22,.35)*f0_1+\n    mat4(.16,.02,-.41,-.01,.13,-.53,.19,.55,.52,.26,-.30,.19,-.10,-.18,-.67,-.32)*f0_2+\n    mat4(-.07,-.00,1.46,.33,-.44,-.06,.31,-.40,.26,-.33,-.42,1.85,-.58,.76,.27,.12)*f0_3+\n    mat4(.23,.08,.08,.48,-.01,.06,.13,-.03,1.00,-.33,.14,-.40,-.25,-.56,-.75,.28)*f0_4+\n    mat4(.55,-.04,.28,.97,-.51,-.17,.28,-1.60,-.39,.15,.21,-.06,-.08,-.46,.10,.96)*f0_5+\n    mat4(-.18,.07,.09,.01,-.15,-.29,-.62,.91,1.40,-.24,.42,-.39,.18,-.13,-.70,-.89)*f0_6+\n    mat4(.02,-.68,.34,.73,-.36,-.30,.21,.16,.34,.19,-.36,-.23,-.11,.34,.25,.51)*f0_7+\n    vec4(-.78,.66,1.45,1.27))/1.0+f0_3;\nvec4 f1_4=sin(mat4(-.28,-.23,.31,.75,-.75,-.12,-.09,.35,-1.00,.24,-.40,-.83,.13,-.21,.52,-.09)*f0_0+\n    mat4(.37,.01,.39,-.09,.06,.19,-.14,-.08,.58,-.01,.25,-.29,.56,.14,.84,-.57)*f0_1+\n    mat4(.20,.25,-.10,.84,-.79,.04,-.50,-.45,-.07,-.21,.37,-.60,-.20,-.04,-.21,-.28)*f0_2+\n    mat4(.28,-.15,-.17,.57,.11,.02,.22,-.45,-.34,.29,-.60,-.44,.83,-.60,-.08,-.09)*f0_3+\n    mat4(-.76,-.40,-.66,.50,-.51,-.22,-.45,.16,-.90,.02,-.44,-.22,.08,.50,-.35,-.27)*f0_4+\n    mat4(.01,.03,.62,-.21,.11,-.20,.08,.52,.86,-.27,-.43,.08,.43,.56,-.46,.15)*f0_5+\n    mat4(.48,-.01,-.14,.30,.33,.09,.15,-.81,-.62,.04,.36,.50,-.29,-.26,-.32,.04)*f0_6+\n    mat4(-.39,-.59,-.53,.97,.59,.46,.92,-.41,-.35,.12,-.15,.12,-.37,-.44,.18,.32)*f0_7+\n    vec4(.89,-.31,1.57,.07))/1.0+f0_4;\nvec4 f1_5=sin(mat4(.30,-.33,-.87,.29,.38,-.10,.31,-.71,.89,-.33,1.21,-.02,.01,.40,-.31,.10)*f0_0+\n    mat4(-.25,-.34,-.10,-.77,-.31,.35,-.35,.11,-.13,.34,.32,-.11,-.65,.09,.90,.26)*f0_1+\n    mat4(-.45,-.33,-1.09,-.11,-.29,-.40,.98,-.70,.13,-1.05,.28,-.71,.55,-.46,.86,-.10)*f0_2+\n    mat4(-.44,.73,.02,1.16,.11,-.46,.66,-.46,-.47,-.27,.55,-.71,-.77,-1.88,.37,.10)*f0_3+\n    mat4(-.14,-.27,-.52,-.29,.12,-1.05,1.55,.04,.68,.48,.85,.55,-.31,-1.20,.89,-.29)*f0_4+\n    mat4(-.76,-.69,-.35,-.57,.48,.51,-.58,1.12,-.43,-1.00,.98,.28,-.90,.03,.30,-.74)*f0_5+\n    mat4(-.34,-1.34,.49,.14,-.49,.11,-.34,-.28,.10,.69,-.44,.06,.97,.51,-.37,.61)*f0_6+\n    mat4(.74,.23,-.35,.23,-1.26,.32,.43,-.17,.18,-.58,.33,-.16,.42,.41,-.03,.34)*f0_7+\n    vec4(-1.93,1.05,-.88,-.25))/1.0+f0_5;\nvec4 f1_6=sin(mat4(-.69,.18,.20,-.18,.18,.41,-.04,.66,-.04,-.49,-.03,-.53,-.15,.83,-.62,-.28)*f0_0+\n    mat4(.97,-.35,.15,.10,-.08,.59,-.56,-.05,.03,-.47,.05,.42,1.17,-.41,.30,.22)*f0_1+\n    mat4(-.10,.25,-.07,.29,-.05,.22,.10,-.08,-.40,.27,-.05,.13,-.01,.35,.08,-.89)*f0_2+\n    mat4(1.06,.76,.36,-.66,.26,-.35,.04,.34,-.28,.54,-.03,-1.17,1.33,.96,-.06,-.04)*f0_3+\n    mat4(.21,-.36,-.15,.00,.15,-.09,-.46,-.77,-.39,-.39,-.30,.05,.61,-.70,-.00,.52)*f0_4+\n    mat4(-.02,-.50,-.04,.19,.33,-.73,.13,.74,1.55,.58,.16,-.61,-.27,.42,-.06,.07)*f0_5+\n    mat4(.46,-.14,-.61,.24,-.18,-.73,.34,.57,-1.09,.25,-.71,.06,-.23,-.81,-.58,.31)*f0_6+\n    mat4(-.11,-.17,.74,-.04,1.52,-.88,-.11,.05,.36,.02,.16,.45,-.84,.75,-.00,.12)*f0_7+\n    vec4(-1.72,-1.66,-2.78,-1.78))/1.0+f0_6;\nvec4 f1_7=sin(mat4(.16,.07,.11,-.03,-.23,.03,-.31,.27,.68,-.88,-.27,-.08,.04,-.45,.46,.49)*f0_0+\n    mat4(.17,.61,-.17,-.32,-.54,-.74,-.80,.22,.12,.62,-.03,-.13,-.34,.64,-.35,-.09)*f0_1+\n    mat4(.09,.17,.31,.21,-.21,-.89,-.31,-.08,.15,.72,.38,.04,-.19,-.21,.09,.17)*f0_2+\n    mat4(-.49,-.11,.41,-.80,.08,-.23,.22,.23,-.22,-.85,-.09,-.01,-.25,.03,.35,.44)*f0_3+\n    mat4(-.24,-.47,.38,-.27,-.12,.04,-.46,.28,-.45,.09,-.30,-1.25,-.42,.06,-.49,.06)*f0_4+\n    mat4(.15,-.56,-.24,-.02,-.18,.09,-.17,-.30,.08,.22,.39,-.01,.37,-.78,.58,.28)*f0_5+\n    mat4(.54,.37,.26,-.28,.13,.26,.36,.07,.29,-.17,-.23,-.13,.06,.56,-.14,-.12)*f0_6+\n    mat4(-.10,-.40,.27,-.28,-.51,.21,-.05,-.88,.39,-.30,-.47,-.14,.67,.59,.49,.58)*f0_7+\n    vec4(-1.78,-.23,.14,1.78))/1.0+f0_7;\nvec4 f2_0=sin(mat4(.39,.48,-.20,-1.13,-.28,.95,-.60,.50,-.32,.26,-.67,1.08,-.75,-.83,.25,-.39)*f1_0+\n    mat4(-.87,-.58,.45,.30,-2.46,-2.21,.64,.74,.65,.66,-.10,-.16,2.14,1.17,-.95,-1.10)*f1_1+\n    mat4(-.95,-1.01,.26,1.13,.48,.34,-.27,-.33,1.92,1.34,-.43,-.30,-.83,-.45,-.04,-.61)*f1_2+\n    mat4(-.83,-.86,-.04,-.42,.35,.55,-.20,-.59,-1.17,-.76,.07,.67,-2.14,-1.72,.02,.77)*f1_3+\n    mat4(1.09,1.20,-.54,.74,-.64,.10,-.67,.29,.52,-.13,-.06,.07,.97,.28,-.51,-.26)*f1_4+\n    mat4(1.38,.97,-.31,-1.08,-1.28,-1.05,.14,.56,-.17,-.29,.14,.03,2.82,1.79,-.23,-2.02)*f1_5+\n    mat4(.50,.89,-.21,.58,.62,.34,-.03,.41,.14,.32,.31,-.19,.26,.19,-.16,.24)*f1_6+\n    mat4(1.06,1.49,-.96,.59,.73,.71,-.18,.04,-1.03,-.83,-.17,.24,-.36,-.73,.75,.14)*f1_7+\n    vec4(-3.46,-1.50,-.87,-1.22))/1.4+f1_0;\nvec4 f2_1=sin(mat4(1.57,-1.40,-.23,-.01,-1.77,.17,.34,-.07,-1.71,-.11,.49,.57,1.20,-.81,-.85,-.71)*f1_0+\n    mat4(-1.00,.16,-.01,.41,-.47,-.35,-.67,-.78,-1.43,.53,1.21,.32,1.99,-.22,.24,.42)*f1_1+\n    mat4(-.20,.38,-.20,-.43,-.02,-.87,.01,.47,.41,-1.37,.86,1.00,1.15,-.37,-.68,-.76)*f1_2+\n    mat4(1.45,1.16,-1.21,-1.13,.36,-.27,.02,.22,-.69,.30,-.63,-.75,-1.17,.82,-.83,-.30)*f1_3+\n    mat4(-1.87,-.37,1.42,1.07,-1.17,.32,-.08,.94,1.32,-.65,.21,.03,.34,.82,-.05,-.10)*f1_4+\n    mat4(1.35,-.51,-.10,.08,-1.14,.56,.00,-.07,.60,.39,-.34,-.30,2.47,-.32,1.76,.75)*f1_5+\n    mat4(-1.72,.15,.36,.56,-.52,-.61,.95,.45,.52,-.20,-.27,-.02,-1.06,-.84,.05,.20)*f1_6+\n    mat4(-1.87,1.89,-.40,.85,.03,.05,.34,.34,-.28,.99,-1.26,-.34,.86,-.44,.20,-1.20)*f1_7+\n    vec4(.86,-.81,1.77,1.69))/1.4+f1_1;\nvec4 f2_2=sin(mat4(-.28,-.34,.01,.32,1.49,.11,.45,.44,1.58,-.14,-.12,.06,-1.09,.10,-.77,-.32)*f1_0+\n    mat4(-.02,.28,.36,.17,-.76,.77,.89,-.11,1.38,-.46,.62,-.11,-.81,-1.54,-.04,.26)*f1_1+\n    mat4(-.57,-.25,-.67,.25,-.49,.59,.15,-.24,1.24,-1.30,-.37,.40,-1.19,.02,-.34,-1.00)*f1_2+\n    mat4(-1.07,.60,-.94,-.66,-.05,-.18,.08,.18,-1.21,.60,-.35,-.57,-.30,1.21,-.66,-.07)*f1_3+\n    mat4(2.84,-.58,-.22,.53,.85,-.51,.48,-.41,-.18,-.27,-.36,.18,-.10,-.60,.16,.29)*f1_4+\n    mat4(-.51,-.16,-1.07,-.03,.79,.44,.12,.31,-.72,-.45,.25,.11,-.24,-.77,.33,.40)*f1_5+\n    mat4(1.82,-.39,-.34,.04,1.12,-.44,.12,.45,-1.53,-.48,-.10,-.14,2.21,.09,.94,.29)*f1_6+\n    mat4(1.78,-.43,.53,-.57,1.02,-.75,.22,.32,-1.30,-.05,1.03,-.44,-1.16,.09,-.88,.93)*f1_7+\n    vec4(.86,1.76,-.42,1.24))/1.4+f1_2;\nvec4 f2_3=sin(mat4(-.87,-.10,-.45,-.70,-.24,-.04,-.47,-.48,.32,.54,-.37,-.14,-.29,-.95,-.28,.21)*f1_0+\n    mat4(.79,.16,-.53,.37,.39,-2.00,-1.33,.23,1.11,1.15,.90,.31,-1.37,1.87,1.50,1.11)*f1_1+\n    mat4(-.45,-.42,-.48,.18,.79,.78,.07,-.48,-.57,1.94,1.07,.62,-.91,-1.12,-.57,-.28)*f1_2+\n    mat4(-.30,-1.76,-.12,.71,-.88,-.37,-.21,1.01,-.37,-1.43,-.83,.05,1.02,-1.42,-1.06,-.48)*f1_3+\n    mat4(.65,2.10,.28,-.19,1.52,.15,-.55,-.05,-.51,.30,.36,.04,-.61,1.44,.16,.44)*f1_4+\n    mat4(-.61,.59,.46,.23,.66,-.52,-.76,.15,.00,-.50,.36,.57,-.59,1.93,2.00,.25)*f1_5+\n    mat4(.46,.98,-.26,.04,.29,.75,.80,-.09,-.67,-.15,.58,.38,-.19,.76,-.48,.15)*f1_6+\n    mat4(.28,.03,.96,.17,-.59,.69,.13,.34,.28,-1.16,.56,.04,-.28,-.24,-.91,.76)*f1_7+\n    vec4(2.50,.81,-2.11,.01))/1.4+f1_3;\nvec4 f2_4=sin(mat4(-.12,-.89,-.14,1.15,-.28,.52,-1.04,-.68,.38,.28,-.76,-1.42,-.29,-.56,1.12,.92)*f1_0+\n    mat4(-.70,.63,-.26,.06,-.55,.79,.79,1.35,.64,1.12,-1.77,-1.03,-.03,-1.08,-.41,-.85)*f1_1+\n    mat4(.58,.35,.45,-.12,-.75,-.48,-.14,.17,.34,-.02,-1.08,-1.28,-.21,-.86,1.17,.74)*f1_2+\n    mat4(-.02,-.66,.76,.71,-.18,-.28,-.22,-.17,-.43,-.35,.99,.52,-.31,.28,.31,.65)*f1_3+\n    mat4(.38,1.84,-2.00,-2.09,.12,-.80,-.52,.29,.58,-.73,-.07,.35,-.15,.49,.23,-.46)*f1_4+\n    mat4(-.36,-.98,.50,.38,.30,.72,-.19,-.21,.28,-.15,.63,.57,.71,-.20,-.77,.15)*f1_5+\n    mat4(.29,1.28,-1.23,-1.45,.82,.71,-1.45,-.93,.13,-.94,1.03,.87,.08,1.07,-.34,-.72)*f1_6+\n    mat4(1.20,-.34,-.09,-.73,.12,-.31,-.90,-1.29,.00,-.30,1.83,1.25,-.33,.43,.57,.08)*f1_7+\n    vec4(.63,1.70,-.50,-1.32))/1.4+f1_4;\nvec4 f2_5=sin(mat4(.47,-.04,-.25,.75,-1.32,.86,1.02,-.20,-1.04,.98,.28,-.34,.13,-.27,-.55,.87)*f1_0+\n    mat4(-.14,-.06,-.34,-.30,.07,.45,-1.57,-.43,-.07,.72,-.40,-.45,-.26,.11,.30,1.17)*f1_1+\n    mat4(-.90,.25,-.56,-.18,.20,-.37,.75,.70,-.05,-.16,-.39,-.33,-.07,-.36,.80,.51)*f1_2+\n    mat4(.18,-.90,.75,.10,.95,-.71,1.25,.37,-.91,-.08,.47,-.18,-.41,-.04,-.25,-.19)*f1_3+\n    mat4(-.88,.77,-.35,.25,.00,-.27,-.23,-.34,-.76,-.65,-.21,-.33,-.63,.08,-.14,-.49)*f1_4+\n    mat4(-.24,-1.20,-.03,-.40,.07,-.09,-.87,-.18,.42,.44,-.61,-.18,.91,.01,.15,.31)*f1_5+\n    mat4(-.44,.50,.45,.05,-.34,.37,.04,-.05,-.09,.00,-.19,.09,-.09,-.27,.10,-.06)*f1_6+\n    mat4(.06,.09,1.09,-.62,-.70,-.35,.24,-.29,.22,.38,-.40,-.96,.27,-.13,-1.12,1.38)*f1_7+\n    vec4(-.37,-.49,-.70,-1.62))/1.4+f1_5;\nvec4 f2_6=sin(mat4(-.57,.07,.23,-1.00,2.18,.60,.37,.53,2.00,-.98,.05,.60,-1.13,.20,-.67,.06)*f1_0+\n    mat4(.89,.96,.65,.39,-1.10,.64,-.64,.89,1.64,-.05,1.12,.82,-.08,-.53,-.14,-.51)*f1_1+\n    mat4(-.46,-.92,-.02,.81,.52,-.45,.22,-.26,1.45,-.27,.27,-.08,-1.40,.57,-.07,-.21)*f1_2+\n    mat4(-1.52,.45,-.65,1.02,.09,-.01,.39,-.37,-.89,-.01,-.65,.22,-.11,-.20,-.70,1.37)*f1_3+\n    mat4(3.13,-1.49,.07,.43,1.51,-.24,.53,.95,-.37,-.61,-.37,.30,-.06,-.91,.95,.59)*f1_4+\n    mat4(-.59,.50,-.02,-.75,.69,-.11,.39,.92,-.84,.28,.40,-.24,-.85,.43,.70,-1.46)*f1_5+\n    mat4(2.18,-.88,.18,.66,1.29,-.39,.36,.22,-1.23,.06,.41,-.32,1.53,-.22,.57,-.20)*f1_6+\n    mat4(.96,-1.01,-1.02,-.47,1.37,-.74,.06,-.07,-1.48,.07,-.10,.10,-.64,.77,-.35,-.43)*f1_7+\n    vec4(-.34,.10,-3.62,-2.99))/1.4+f1_6;\nvec4 f2_7=sin(mat4(-.61,-.03,.47,.05,.87,-.54,.17,.01,.79,.29,-.48,.18,-.24,-.37,.66,-.50)*f1_0+\n    mat4(.19,-.19,.20,-.67,-.00,-.90,-.64,-.77,-.02,-.02,-.29,-.27,-.60,.47,.92,.98)*f1_1+\n    mat4(.76,.16,-.35,.12,-.35,.73,.54,.61,.01,.07,.73,.18,-.36,-.49,.38,.37)*f1_2+\n    mat4(-.49,-1.30,.07,-.14,-.15,.16,.38,.54,-.45,-.64,.24,.42,.69,-.38,-.76,-.65)*f1_3+\n    mat4(.34,-.02,.06,-.04,.97,.04,.22,-.52,.17,.03,.54,.44,-.46,-.68,.84,.56)*f1_4+\n    mat4(-.26,.06,.86,.25,.52,-.24,-.38,-.79,.36,-.28,-.19,-.35,-1.00,.36,.06,.65)*f1_5+\n    mat4(.30,.46,-.04,.15,.54,.32,-.51,-.21,.51,.45,-.02,-.09,.30,-.01,-.22,.14)*f1_6+\n    mat4(.43,.99,.09,.45,-.03,.79,.13,.51,.01,-.92,-.52,-.19,-.27,-.44,.27,-.31)*f1_7+\n    vec4(.42,1.68,-.10,.53))/1.4+f1_7;\nfloat output_val = dot(f2_0,vec4(.08,-.08,-.10,.07))+\n    dot(f2_1,vec4(-.05,.03,-.09,.11))+\n    dot(f2_2,vec4(-.06,.07,-.04,.08))+\n    dot(f2_3,vec4(.11,.08,.06,-.08))+\n    dot(f2_4,vec4(-.08,-.07,.08,.08))+\n    dot(f2_5,vec4(.06,-.06,.04,.06))+\n    dot(f2_6,vec4(-.07,-.05,.05,.05))+\n    dot(f2_7,vec4(-.10,.04,.07,.09))+\n    -0.160;\n    \n    //neural networks can be really compact... when they want to be\n      \n    vec4 f20_0=sin(p.y*vec4(1.55,-2.62,-1.94,-3.54)+p.z*vec4(-.91,3.15,-1.31,-1.34)+p.x*vec4(-2.16,4.16,-3.83,1.52)+vec4(-6.73,-1.64,-.68,3.42));\nvec4 f20_1=sin(p.y*vec4(-.09,-3.64,3.53,-.75)+p.z*vec4(-3.44,2.22,-1.07,1.22)+p.x*vec4(-.43,.19,.27,-4.54)+vec4(6.04,-8.30,1.75,-1.03));\nvec4 f20_2=sin(p.y*vec4(-2.15,2.54,1.52,-2.81)+p.z*vec4(.02,-.97,-.50,-1.22)+p.x*vec4(-4.46,1.49,1.88,2.51)+vec4(2.20,-5.10,-.40,-4.95));\nvec4 f20_3=sin(p.y*vec4(-3.55,-4.01,.08,-1.06)+p.z*vec4(-3.28,-2.77,.64,2.05)+p.x*vec4(2.48,2.23,-.30,3.93)+vec4(1.43,.91,-2.43,5.35));\nvec4 f21_0=sin(mat4(1.04,.89,-.26,-.81,.15,1.24,-.27,.02,-.22,-.76,-.03,-.09,.46,.00,.39,.32)*f20_0+\n    mat4(-.05,-.01,-.55,-1.16,.09,-.92,-.17,.52,.08,-.94,1.52,-.19,-.30,-.13,-.71,-.82)*f20_1+\n    mat4(-.27,-.55,.55,-1.60,.20,.10,-.48,.95,.09,.29,-.46,-.21,-.08,1.46,-.87,.29)*f20_2+\n    mat4(.60,-.82,-.12,-.17,-.29,.32,.30,.88,.07,.05,.87,-.73,-.38,-.82,.51,-.08)*f20_3+\n    vec4(-2.09,-2.36,3.49,4.24))/1.0+f20_0;\nvec4 f21_1=sin(mat4(-.22,.32,-.98,-.75,-.82,-.20,-.06,-.03,.55,-.61,-.98,.74,-.59,-.79,-.90,.91)*f20_0+\n    mat4(.01,.12,-.35,-.74,-.67,-.18,.60,.55,-.65,1.85,-.48,-.52,1.74,-.72,.34,-.92)*f20_1+\n    mat4(1.73,.56,.08,-1.16,.90,-.67,.51,.61,.09,.29,-.22,-.19,.51,-1.01,.39,.51)*f20_2+\n    mat4(-.27,.75,.01,-.89,.11,-1.62,-.68,1.31,.39,-.75,-.81,1.06,.30,.77,-.01,-.59)*f20_3+\n    vec4(.65,-3.36,.20,-.47))/1.0+f20_1;\nvec4 f21_2=sin(mat4(.45,-.86,-.29,-.49,-.72,.36,-1.00,-.43,-.70,-.47,.51,.11,-.10,.45,-.18,.25)*f20_0+\n    mat4(.23,.33,-.02,-.49,-.47,-.26,.61,.26,-.30,-.07,1.42,.30,.80,.09,1.12,-.08)*f20_1+\n    mat4(.25,-.62,1.58,.20,.99,-.46,.62,.28,.81,-.32,1.28,.93,.49,-.89,-.07,-.88)*f20_2+\n    mat4(-.56,-.36,-.61,-.82,-.08,.16,-.04,1.14,-1.20,-.66,-.02,-.24,.93,-1.20,1.47,.62)*f20_3+\n    vec4(.10,3.78,-2.18,-1.09))/1.0+f20_2;\nvec4 f21_3=sin(mat4(-.97,-.20,.97,1.10,.08,-.32,.64,.24,.18,-.45,-.25,-.16,.06,.63,-.79,-.16)*f20_0+\n    mat4(-.56,.09,-.09,-.08,.21,-.36,.25,.71,.58,-.29,.61,.27,-.13,-.26,-.02,.22)*f20_1+\n    mat4(.35,-.11,.22,.28,.16,.11,.03,-.19,-.17,-.34,-.91,-.13,-.97,.24,.35,.39)*f20_2+\n    mat4(-.14,-.45,.21,-.36,.14,.75,-.88,.16,-1.60,.07,.85,.07,-.09,-.67,.03,-.73)*f20_3+\n    vec4(-.83,2.40,.19,1.59))/1.0+f20_3;\nvec4 f22_0=sin(mat4(-1.28,-1.22,-.27,.75,-1.20,.20,.20,-.59,.12,.53,.31,.47,-.37,-1.36,1.32,.83)*f21_0+\n    mat4(-.86,-1.07,.48,.42,.02,-.47,-.34,-.43,.02,.92,-.01,-.20,.53,1.27,-1.13,-.27)*f21_1+\n    mat4(.06,1.44,-.80,.02,-.46,.54,-.46,-.69,-.22,1.37,-.79,-.55,-.65,-1.24,-.34,-.72)*f21_2+\n    mat4(.25,.28,-.63,-.70,.50,.24,.40,.77,.85,.48,.76,.49,-.03,.94,-1.60,-1.06)*f21_3+\n    vec4(-2.45,2.88,-2.05,-2.72))/1.4+f21_0;\nvec4 f22_1=sin(mat4(.07,-2.06,-.68,1.07,-.03,-.65,-.70,.19,-.02,.38,-.20,.85,-.65,-.50,.58,.49)*f21_0+\n    mat4(-.16,-.93,-.20,.47,.01,-.58,.01,-.84,.57,-.05,.35,.24,.68,.30,-.44,-1.06)*f21_1+\n    mat4(.49,1.23,-.60,-.13,.87,.71,-.79,-.04,.57,1.94,-.82,-.32,-.52,-1.75,-1.81,-1.27)*f21_2+\n    mat4(-.41,-.67,-1.89,.11,.12,.91,2.48,-.23,.72,-.35,-.83,-.61,-.09,.97,-.99,.12)*f21_3+\n    vec4(.46,2.66,-1.00,-.44))/1.4+f21_1;\nvec4 f22_2=sin(mat4(-1.26,1.91,1.20,-1.40,-.93,-.89,-.52,.57,-.12,.30,.56,.76,.11,1.12,-.30,-1.14)*f21_0+\n    mat4(-.11,.43,.04,-1.05,.20,.44,-.87,-.70,-.28,-.29,-.76,.50,-.05,-.73,.44,1.10)*f21_1+\n    mat4(.16,.57,.91,1.05,.53,.00,1.32,.14,.80,-.23,1.22,.43,-.64,-.25,-.46,-.29)*f21_2+\n    mat4(-.17,-.05,.04,.00,-.30,-.25,-.68,.18,.52,-1.40,.63,1.05,-.09,.78,-.03,.22)*f21_3+\n    vec4(-.37,2.59,3.01,-1.09))/1.4+f21_2;\nvec4 f22_3=sin(mat4(-1.46,1.19,-1.65,.51,.06,-.31,-.30,-.93,.35,1.23,-.82,1.49,-.19,.99,-1.18,.68)*f21_0+\n    mat4(-.71,.79,-.84,.38,-.28,-1.36,1.14,-1.27,.77,-.79,1.07,-.68,.50,-1.08,.92,-.64)*f21_1+\n    mat4(1.54,.24,-.13,.48,.04,.12,-.06,.16,.99,.20,.19,.61,.34,-1.44,.36,-2.20)*f21_2+\n    mat4(-.84,-.21,.83,.33,.26,-.05,.05,-.16,-.16,-.41,.45,.35,-.14,.05,.23,.43)*f21_3+\n    vec4(-2.07,-1.94,-2.34,1.26))/1.4+f21_3;\nfloat output_val2 = dot(f22_0,vec4(-.09,.18,.11,-.13))+\n    dot(f22_1,vec4(-.15,-.09,.08,.11))+\n    dot(f22_2,vec4(.18,-.06,.11,-.18))+\n    dot(f22_3,vec4(-.09,.20,-.14,.13))+\n    -0.052;\n    \n    return (output_val2 + output_val ) / 2.0;\n    \n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 cam = normalize(vec3(1.5,uv));\n    vec3 init = vec3(-3.,0,0);\n    \n    float yrot = 0.5;\n    float zrot = iTime*.2;\n    if (iMouse.z > 0.) {\n        yrot += -4.*mouse.y;\n        zrot = 4.*mouse.x;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n    \n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 150 && !hit; i++) {\n        float dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p+=dist*cam;\n        if (distance(p,init)>5.) break;\n    }\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    //don't ask how I stumbled on this texture\n    vec3 nz = p - erot(p, vec3(1), 2.) + erot(p, vec3(1), 4.);\n    float spec = length(sin(r*3.5+sin(nz*120.)*.15)*.4+.6)/sqrt(3.);\n    spec *= smoothstep(-.3,.2,scene(p+r*.2));\n    vec3 col = vec3(.1,.1,.12)*spec + pow(spec,8.);\n    float bgdot = length(sin(cam*8.)*.4+.6)/2.;\n    vec3 bg = vec3(.1,.1,.11) * bgdot + pow(bgdot, 10.);\n    fragColor.xyz = hit ? col : bg;\n    fragColor = smoothstep(-.02,1.05,sqrt(fragColor)) * (1.- dot(uv,uv)*.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtcBR7.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[194, 435, 473, 473, 535], [537, 537, 558, 644, 18788], [18790, 18790, 18809, 18809, 18925], [18927, 18927, 18984, 18984, 20252]], "test": "valid"}
{"id": "wtcBRj", "name": "Material Maker: Gears", "author": "RodzLabs", "description": "This is a shader generated with Material Maker from a project created by ydobemos.", "tags": ["generated"], "likes": 4, "viewed": 58, "published": "Public", "date": "1613046977", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//---\n\nfloat rand(vec2 x) {\n    return fract(cos(dot(x, vec2(13.9898, 8.141))) * 43758.5453);\n}\n\nvec2 rand2(vec2 x) {\n    return fract(cos(vec2(dot(x, vec2(13.9898, 8.141)),\n\t\t\t\t\t\t  dot(x, vec2(3.4562, 17.398)))) * 43758.5453);\n}\n\nvec3 rand3(vec2 x) {\n    return fract(cos(vec3(dot(x, vec2(13.9898, 8.141)),\n                          dot(x, vec2(3.4562, 17.398)),\n                          dot(x, vec2(13.254, 5.867)))) * 43758.5453);\n}\n\nvec3 rgb2hsv(vec3 c) {\n\tvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n\tvec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\n\tvec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n\n\tfloat d = q.x - min(q.w, q.y);\n\tfloat e = 1.0e-10;\n\treturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c) {\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat sdArc(vec2 p, float a1, float a2, float ra, float rb) {\n\tfloat amid = 0.5*(a1+a2)+1.6+3.14*step(a1, a2);\n\tfloat alength = 0.5*(a1-a2)-1.6+3.14*step(a1, a2);\n\tvec2 sca = vec2(cos(amid), sin(amid));\n\tvec2 scb = vec2(cos(alength), sin(alength));\n    p *= mat2(vec2(sca.x,sca.y),vec2(-sca.y,sca.x));\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\nvec2 transform2_clamp(vec2 uv) {\n\treturn clamp(uv, vec2(0.0), vec2(1.0));\n}\n\nvec2 transform2(vec2 uv, vec2 translate, float rotate, vec2 scale) {\n \tvec2 rv;\n\tuv -= translate;\n\tuv -= vec2(0.5);\n\trv.x = cos(rotate)*uv.x + sin(rotate)*uv.y;\n\trv.y = -sin(rotate)*uv.x + cos(rotate)*uv.y;\n\trv /= scale;\n\trv += vec2(0.5);\n\treturn rv;\t\n}float shape_circle(vec2 uv, float sides, float size, float edge) {\n    uv = 2.0*uv-1.0;\n\tedge = max(edge, 1.0e-8);\n    float distance = length(uv);\n    return clamp((1.0-distance/size)/edge, 0.0, 1.0);\n}\n\nfloat shape_polygon(vec2 uv, float sides, float size, float edge) {\n    uv = 2.0*uv-1.0;\n\tedge = max(edge, 1.0e-8);\n    float angle = atan(uv.x, uv.y)+3.14159265359;\n    float slice = 6.28318530718/sides;\n    return clamp((size-cos(floor(0.5+angle/slice)*slice-angle)*length(uv))/(edge*size), 0.0, 1.0);\n}\n\nfloat shape_star(vec2 uv, float sides, float size, float edge) {\n    uv = 2.0*uv-1.0;\n\tedge = max(edge, 1.0e-8);\n    float angle = atan(uv.x, uv.y);\n    float slice = 6.28318530718/sides;\n    return clamp((size-cos(floor(angle/slice-0.5+2.0*step(mod(angle, slice), 0.5*slice))*slice-angle)*length(uv))/(edge*size), 0.0, 1.0);\n}\n\nfloat shape_curved_star(vec2 uv, float sides, float size, float edge) {\n    uv = 2.0*uv-1.0;\n\tedge = max(edge, 1.0e-8);\n    float angle = 2.0*(atan(uv.x, uv.y)+3.14159265359);\n    float slice = 6.28318530718/sides;\n    return clamp((size-cos(floor(0.5+0.5*angle/slice)*2.0*slice-angle)*length(uv))/(edge*size), 0.0, 1.0);\n}\n\nfloat shape_rays(vec2 uv, float sides, float size, float edge) {\n    uv = 2.0*uv-1.0;\n\tedge = 0.5*max(edge, 1.0e-8)*size;\n\tfloat slice = 6.28318530718/sides;\n    float angle = mod(atan(uv.x, uv.y)+3.14159265359, slice)/slice;\n    return clamp(min((size-angle)/edge, angle/edge), 0.0, 1.0);\n}\n\nvec2 uvmirror_h(vec2 uv, float offset) {\n\treturn vec2(max(0.0, abs(uv.x-0.5)-0.5*offset)+0.5, uv.y);\n}\nvec2 uvmirror_v(vec2 uv, float offset) {\n\treturn vec2(uv.x, max(0.0, abs(uv.y-0.5)-0.5*offset)+0.5);\n}vec2 kal_rotate(vec2 uv, float count, float offset) {\n\tfloat pi = 3.14159265359;\n\toffset *= pi/180.0;\n\toffset += pi*(1.0/count+0.5);\n\tuv -= vec2(0.5);\n\tfloat l = length(uv);\n\tfloat a = mod(atan(uv.y, uv.x)+offset, 2.0*pi/count)-offset;\n\treturn vec2(0.5)+l*vec2(cos(a), sin(a));\n}vec3 blend_normal(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*c1 + (1.0-opacity)*c2;\n}\n\nvec3 blend_dissolve(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\tif (rand(uv) < opacity) {\n\t\treturn c1;\n\t} else {\n\t\treturn c2;\n\t}\n}\n\nvec3 blend_multiply(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*c1*c2 + (1.0-opacity)*c2;\n}\n\nvec3 blend_screen(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*(1.0-(1.0-c1)*(1.0-c2)) + (1.0-opacity)*c2;\n}\n\nfloat blend_overlay_f(float c1, float c2) {\n\treturn (c1 < 0.5) ? (2.0*c1*c2) : (1.0-2.0*(1.0-c1)*(1.0-c2));\n}\n\nvec3 blend_overlay(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*vec3(blend_overlay_f(c1.x, c2.x), blend_overlay_f(c1.y, c2.y), blend_overlay_f(c1.z, c2.z)) + (1.0-opacity)*c2;\n}\n\nvec3 blend_hard_light(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*0.5*(c1*c2+blend_overlay(uv, c1, c2, 1.0)) + (1.0-opacity)*c2;\n}\n\nfloat blend_soft_light_f(float c1, float c2) {\n\treturn (c2 < 0.5) ? (2.0*c1*c2+c1*c1*(1.0-2.0*c2)) : 2.0*c1*(1.0-c2)+sqrt(c1)*(2.0*c2-1.0);\n}\n\nvec3 blend_soft_light(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*vec3(blend_soft_light_f(c1.x, c2.x), blend_soft_light_f(c1.y, c2.y), blend_soft_light_f(c1.z, c2.z)) + (1.0-opacity)*c2;\n}\n\nfloat blend_burn_f(float c1, float c2) {\n\treturn (c1==0.0)?c1:max((1.0-((1.0-c2)/c1)),0.0);\n}\n\nvec3 blend_burn(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*vec3(blend_burn_f(c1.x, c2.x), blend_burn_f(c1.y, c2.y), blend_burn_f(c1.z, c2.z)) + (1.0-opacity)*c2;\n}\n\nfloat blend_dodge_f(float c1, float c2) {\n\treturn (c1==1.0)?c1:min(c2/(1.0-c1),1.0);\n}\n\nvec3 blend_dodge(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*vec3(blend_dodge_f(c1.x, c2.x), blend_dodge_f(c1.y, c2.y), blend_dodge_f(c1.z, c2.z)) + (1.0-opacity)*c2;\n}\n\nvec3 blend_lighten(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*max(c1, c2) + (1.0-opacity)*c2;\n}\n\nvec3 blend_darken(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*min(c1, c2) + (1.0-opacity)*c2;\n}\n\nvec3 blend_difference(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*clamp(c2-c1, vec3(0.0), vec3(1.0)) + (1.0-opacity)*c2;\n}\nvec2 rotate(vec2 uv, vec2 center, float rotate) {\n \tvec2 rv;\n\tuv -= center;\n\trv.x = cos(rotate)*uv.x + sin(rotate)*uv.y;\n\trv.y = -sin(rotate)*uv.x + cos(rotate)*uv.y;\n\trv += center;\n    return rv;\t\n}const float p_o74913_amount = 1.000000000;\nconst float p_o74911_amount = 1.000000000;\nconst float p_o74908_amount = 1.000000000;\nconst float p_o74864_translate_x = -0.130000000;\nconst float p_o74864_translate_y = 0.000000000;\nconst float p_o74864_scale_x = 0.450000000;\nconst float p_o74864_scale_y = 0.450000000;\nconst float p_o74817_bevel = 0.000000000;\nconst float p_o74813_r = 0.050000000;\nconst float p_o74813_cx = 0.130000000;\nconst float p_o74813_cy = -0.070000000;\nconst float p_o74814_r = 0.050000000;\nconst float p_o74814_cx = -0.130000000;\nconst float p_o74814_cy = -0.070000000;\nconst float p_o74811_a1 = 30.000000000;\nconst float p_o74811_a2 = 150.000000000;\nconst float p_o74811_r1 = 0.250000000;\nconst float p_o74811_r2 = 0.030000000;\nconst float p_o74810_r = 0.400000000;\nconst float p_o74810_cx = 0.000000000;\nconst float p_o74810_cy = 0.000000000;\nconst float p_o74818_amount = 1.000000000;\nconst float p_o74808_amount = 1.000000000;\nconst float p_o74725_amount = 1.000000000;\nconst float p_o74821_translate_x = -0.130000000;\nconst float p_o74821_translate_y = 0.000000000;\nconst float p_o74821_scale_x = 0.660000000;\nconst float p_o74821_scale_y = 0.660000000;\nconst float p_o74784_amount = 1.000000000;\nconst float p_o74785_sides = 0.000000000;\nconst float p_o74785_radius = 0.600000000;\nconst float p_o74785_edge = 0.000000000;\nconst float p_o74783_count = 20.000000000;\nconst float p_o74783_offset = 0.000000000;\nconst float p_o74782_offset = 0.070000000;\nconst float p_o74781_translate_x = 0.000000000;\nconst float p_o74781_translate_y = -0.450000000;\nconst float p_o74781_rotate = 0.000000000;\nconst float p_o74781_scale_x = -1.000000000;\nconst float p_o74781_scale_y = 1.000000000;\nconst float p_o74780_value = 0.500000000;\nconst float p_o74780_width = 0.000000000;\nconst float p_o74767_repeat = 1.000000000;\nconst float p_o74767_rotate = 10.000000000;\nconst float p_o74767_gradient_0_pos = 0.000000000;\nconst float p_o74767_gradient_0_r = 0.000000000;\nconst float p_o74767_gradient_0_g = 0.000000000;\nconst float p_o74767_gradient_0_b = 0.000000000;\nconst float p_o74767_gradient_0_a = 1.000000000;\nconst float p_o74767_gradient_1_pos = 1.000000000;\nconst float p_o74767_gradient_1_r = 1.000000000;\nconst float p_o74767_gradient_1_g = 1.000000000;\nconst float p_o74767_gradient_1_b = 1.000000000;\nconst float p_o74767_gradient_1_a = 1.000000000;\nvec4 o74767_gradient_gradient_fct(float x) {\n  if (x < p_o74767_gradient_0_pos) {\n    return vec4(p_o74767_gradient_0_r,p_o74767_gradient_0_g,p_o74767_gradient_0_b,p_o74767_gradient_0_a);\n  } else if (x < p_o74767_gradient_1_pos) {\n    return mix(vec4(p_o74767_gradient_0_r,p_o74767_gradient_0_g,p_o74767_gradient_0_b,p_o74767_gradient_0_a), vec4(p_o74767_gradient_1_r,p_o74767_gradient_1_g,p_o74767_gradient_1_b,p_o74767_gradient_1_a), ((x-p_o74767_gradient_0_pos)/(p_o74767_gradient_1_pos-p_o74767_gradient_0_pos)));\n  }\n  return vec4(p_o74767_gradient_1_r,p_o74767_gradient_1_g,p_o74767_gradient_1_b,p_o74767_gradient_1_a);\n}\nconst float p_o74820_translate_x = 0.300000000;\nconst float p_o74820_translate_y = 0.000000000;\nconst float p_o74820_scale_x = 0.330000000;\nconst float p_o74820_scale_y = 0.330000000;\nconst float p_o74744_amount = 1.000000000;\nconst float p_o74745_sides = 0.000000000;\nconst float p_o74745_radius = 0.400000000;\nconst float p_o74745_edge = 0.000000000;\nconst float p_o74743_count = 10.000000000;\nconst float p_o74743_offset = 0.000000000;\nconst float p_o74742_offset = 0.085000000;\nconst float p_o74741_translate_x = 0.000000000;\nconst float p_o74741_translate_y = -0.450000000;\nconst float p_o74741_rotate = 0.000000000;\nconst float p_o74741_scale_x = -1.000000000;\nconst float p_o74741_scale_y = 1.000000000;\nconst float p_o74740_value = 0.500000000;\nconst float p_o74740_width = 0.000000000;\nconst float p_o74727_repeat = 1.000000000;\nconst float p_o74727_rotate = 10.000000000;\nconst float p_o74727_gradient_0_pos = 0.000000000;\nconst float p_o74727_gradient_0_r = 0.000000000;\nconst float p_o74727_gradient_0_g = 0.000000000;\nconst float p_o74727_gradient_0_b = 0.000000000;\nconst float p_o74727_gradient_0_a = 1.000000000;\nconst float p_o74727_gradient_1_pos = 1.000000000;\nconst float p_o74727_gradient_1_r = 1.000000000;\nconst float p_o74727_gradient_1_g = 1.000000000;\nconst float p_o74727_gradient_1_b = 1.000000000;\nconst float p_o74727_gradient_1_a = 1.000000000;\nvec4 o74727_gradient_gradient_fct(float x) {\n  if (x < p_o74727_gradient_0_pos) {\n    return vec4(p_o74727_gradient_0_r,p_o74727_gradient_0_g,p_o74727_gradient_0_b,p_o74727_gradient_0_a);\n  } else if (x < p_o74727_gradient_1_pos) {\n    return mix(vec4(p_o74727_gradient_0_r,p_o74727_gradient_0_g,p_o74727_gradient_0_b,p_o74727_gradient_0_a), vec4(p_o74727_gradient_1_r,p_o74727_gradient_1_g,p_o74727_gradient_1_b,p_o74727_gradient_1_a), ((x-p_o74727_gradient_0_pos)/(p_o74727_gradient_1_pos-p_o74727_gradient_0_pos)));\n  }\n  return vec4(p_o74727_gradient_1_r,p_o74727_gradient_1_g,p_o74727_gradient_1_b,p_o74727_gradient_1_a);\n}\nconst float p_o74819_translate_x = 0.300000000;\nconst float p_o74819_translate_y = -0.210000000;\nconst float p_o74819_scale_x = 0.200000000;\nconst float p_o74819_scale_y = 0.200000000;\nconst float p_o74704_amount = 1.000000000;\nconst float p_o74705_sides = 0.000000000;\nconst float p_o74705_radius = 0.300000000;\nconst float p_o74705_edge = 0.000000000;\nconst float p_o74703_count = 5.000000000;\nconst float p_o74703_offset = 0.000000000;\nconst float p_o74702_offset = 0.150000000;\nconst float p_o74701_translate_x = 0.000000000;\nconst float p_o74701_translate_y = -0.450000000;\nconst float p_o74701_rotate = 0.000000000;\nconst float p_o74701_scale_x = -1.000000000;\nconst float p_o74701_scale_y = 1.000000000;\nconst float p_o74700_value = 0.500000000;\nconst float p_o74700_width = 0.000000000;\nconst float p_o74687_repeat = 1.000000000;\nconst float p_o74687_rotate = 10.000000000;\nconst float p_o74687_gradient_0_pos = 0.000000000;\nconst float p_o74687_gradient_0_r = 0.000000000;\nconst float p_o74687_gradient_0_g = 0.000000000;\nconst float p_o74687_gradient_0_b = 0.000000000;\nconst float p_o74687_gradient_0_a = 1.000000000;\nconst float p_o74687_gradient_1_pos = 1.000000000;\nconst float p_o74687_gradient_1_r = 1.000000000;\nconst float p_o74687_gradient_1_g = 1.000000000;\nconst float p_o74687_gradient_1_b = 1.000000000;\nconst float p_o74687_gradient_1_a = 1.000000000;\nvec4 o74687_gradient_gradient_fct(float x) {\n  if (x < p_o74687_gradient_0_pos) {\n    return vec4(p_o74687_gradient_0_r,p_o74687_gradient_0_g,p_o74687_gradient_0_b,p_o74687_gradient_0_a);\n  } else if (x < p_o74687_gradient_1_pos) {\n    return mix(vec4(p_o74687_gradient_0_r,p_o74687_gradient_0_g,p_o74687_gradient_0_b,p_o74687_gradient_0_a), vec4(p_o74687_gradient_1_r,p_o74687_gradient_1_g,p_o74687_gradient_1_b,p_o74687_gradient_1_a), ((x-p_o74687_gradient_0_pos)/(p_o74687_gradient_1_pos-p_o74687_gradient_0_pos)));\n  }\n  return vec4(p_o74687_gradient_1_r,p_o74687_gradient_1_g,p_o74687_gradient_1_b,p_o74687_gradient_1_a);\n}\nconst float p_o74909_translate_x = 0.300000000;\nconst float p_o74909_translate_y = 0.210000000;\nconst float p_o74909_scale_x = 0.200000000;\nconst float p_o74909_scale_y = 0.200000000;\nconst float p_o74809_cx = 0.000000000;\nconst float p_o74809_cy = 0.000000000;\nconst float p_o74809_rotate = 180.000000000;\nconst float p_o74840_amount = 1.000000000;\nconst float p_o74841_sides = 0.000000000;\nconst float p_o74841_radius = 0.300000000;\nconst float p_o74841_edge = 0.000000000;\nconst float p_o74839_count = 5.000000000;\nconst float p_o74839_offset = 0.000000000;\nconst float p_o74838_offset = 0.150000000;\nconst float p_o74837_translate_x = 0.000000000;\nconst float p_o74837_translate_y = -0.450000000;\nconst float p_o74837_rotate = 0.000000000;\nconst float p_o74837_scale_x = -1.000000000;\nconst float p_o74837_scale_y = 1.000000000;\nconst float p_o74836_value = 0.500000000;\nconst float p_o74836_width = 0.000000000;\nconst float p_o74823_repeat = 1.000000000;\nconst float p_o74823_rotate = 10.000000000;\nconst float p_o74823_gradient_0_pos = 0.000000000;\nconst float p_o74823_gradient_0_r = 0.000000000;\nconst float p_o74823_gradient_0_g = 0.000000000;\nconst float p_o74823_gradient_0_b = 0.000000000;\nconst float p_o74823_gradient_0_a = 1.000000000;\nconst float p_o74823_gradient_1_pos = 1.000000000;\nconst float p_o74823_gradient_1_r = 1.000000000;\nconst float p_o74823_gradient_1_g = 1.000000000;\nconst float p_o74823_gradient_1_b = 1.000000000;\nconst float p_o74823_gradient_1_a = 1.000000000;\nvec4 o74823_gradient_gradient_fct(float x) {\n  if (x < p_o74823_gradient_0_pos) {\n    return vec4(p_o74823_gradient_0_r,p_o74823_gradient_0_g,p_o74823_gradient_0_b,p_o74823_gradient_0_a);\n  } else if (x < p_o74823_gradient_1_pos) {\n    return mix(vec4(p_o74823_gradient_0_r,p_o74823_gradient_0_g,p_o74823_gradient_0_b,p_o74823_gradient_0_a), vec4(p_o74823_gradient_1_r,p_o74823_gradient_1_g,p_o74823_gradient_1_b,p_o74823_gradient_1_a), ((x-p_o74823_gradient_0_pos)/(p_o74823_gradient_1_pos-p_o74823_gradient_0_pos)));\n  }\n  return vec4(p_o74823_gradient_1_r,p_o74823_gradient_1_g,p_o74823_gradient_1_b,p_o74823_gradient_1_a);\n}\nconst float p_o74910_translate_x = 0.300000000;\nconst float p_o74910_translate_y = -0.360000000;\nconst float p_o74910_scale_x = 0.200000000;\nconst float p_o74910_scale_y = 0.200000000;\nconst float p_o74883_amount = 1.000000000;\nconst float p_o74884_sides = 0.000000000;\nconst float p_o74884_radius = 0.120000000;\nconst float p_o74884_edge = 0.000000000;\nconst float p_o74882_count = 2.000000000;\nconst float p_o74882_offset = 0.000000000;\nconst float p_o74881_offset = 0.060000000;\nconst float p_o74880_translate_x = 0.000000000;\nconst float p_o74880_translate_y = -0.450000000;\nconst float p_o74880_rotate = 0.000000000;\nconst float p_o74880_scale_x = -1.000000000;\nconst float p_o74880_scale_y = 1.000000000;\nconst float p_o74879_value = 0.500000000;\nconst float p_o74879_width = 0.000000000;\nconst float p_o74866_repeat = 1.000000000;\nconst float p_o74866_rotate = 10.000000000;\nconst float p_o74866_gradient_0_pos = 0.000000000;\nconst float p_o74866_gradient_0_r = 0.000000000;\nconst float p_o74866_gradient_0_g = 0.000000000;\nconst float p_o74866_gradient_0_b = 0.000000000;\nconst float p_o74866_gradient_0_a = 1.000000000;\nconst float p_o74866_gradient_1_pos = 1.000000000;\nconst float p_o74866_gradient_1_r = 1.000000000;\nconst float p_o74866_gradient_1_g = 1.000000000;\nconst float p_o74866_gradient_1_b = 1.000000000;\nconst float p_o74866_gradient_1_a = 1.000000000;\nvec4 o74866_gradient_gradient_fct(float x) {\n  if (x < p_o74866_gradient_0_pos) {\n    return vec4(p_o74866_gradient_0_r,p_o74866_gradient_0_g,p_o74866_gradient_0_b,p_o74866_gradient_0_a);\n  } else if (x < p_o74866_gradient_1_pos) {\n    return mix(vec4(p_o74866_gradient_0_r,p_o74866_gradient_0_g,p_o74866_gradient_0_b,p_o74866_gradient_0_a), vec4(p_o74866_gradient_1_r,p_o74866_gradient_1_g,p_o74866_gradient_1_b,p_o74866_gradient_1_a), ((x-p_o74866_gradient_0_pos)/(p_o74866_gradient_1_pos-p_o74866_gradient_0_pos)));\n  }\n  return vec4(p_o74866_gradient_1_r,p_o74866_gradient_1_g,p_o74866_gradient_1_b,p_o74866_gradient_1_a);\n}\nconst float p_o74912_translate_x = 0.300000000;\nconst float p_o74912_translate_y = 0.360000000;\nconst float p_o74912_scale_x = 0.200000000;\nconst float p_o74912_scale_y = 0.200000000;\nconst float p_o74666_amount = 1.000000000;\nconst float p_o74667_sides = 0.000000000;\nconst float p_o74667_radius = 0.120000000;\nconst float p_o74667_edge = 0.000000000;\nconst float p_o74665_count = 2.000000000;\nconst float p_o74665_offset = 0.000000000;\nconst float p_o74664_offset = 0.060000000;\nconst float p_o74663_translate_x = 0.000000000;\nconst float p_o74663_translate_y = -0.450000000;\nconst float p_o74663_rotate = 0.000000000;\nconst float p_o74663_scale_x = -1.000000000;\nconst float p_o74663_scale_y = 1.000000000;\nconst float p_o74662_value = 0.500000000;\nconst float p_o74662_width = 0.000000000;\nconst float p_o74649_repeat = 1.000000000;\nconst float p_o74649_rotate = 10.000000000;\nconst float p_o74649_gradient_0_pos = 0.000000000;\nconst float p_o74649_gradient_0_r = 0.000000000;\nconst float p_o74649_gradient_0_g = 0.000000000;\nconst float p_o74649_gradient_0_b = 0.000000000;\nconst float p_o74649_gradient_0_a = 1.000000000;\nconst float p_o74649_gradient_1_pos = 1.000000000;\nconst float p_o74649_gradient_1_r = 1.000000000;\nconst float p_o74649_gradient_1_g = 1.000000000;\nconst float p_o74649_gradient_1_b = 1.000000000;\nconst float p_o74649_gradient_1_a = 1.000000000;\nvec4 o74649_gradient_gradient_fct(float x) {\n  if (x < p_o74649_gradient_0_pos) {\n    return vec4(p_o74649_gradient_0_r,p_o74649_gradient_0_g,p_o74649_gradient_0_b,p_o74649_gradient_0_a);\n  } else if (x < p_o74649_gradient_1_pos) {\n    return mix(vec4(p_o74649_gradient_0_r,p_o74649_gradient_0_g,p_o74649_gradient_0_b,p_o74649_gradient_0_a), vec4(p_o74649_gradient_1_r,p_o74649_gradient_1_g,p_o74649_gradient_1_b,p_o74649_gradient_1_a), ((x-p_o74649_gradient_0_pos)/(p_o74649_gradient_1_pos-p_o74649_gradient_0_pos)));\n  }\n  return vec4(p_o74649_gradient_1_r,p_o74649_gradient_1_g,p_o74649_gradient_1_b,p_o74649_gradient_1_a);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\nfloat minSize = min(iResolution.x, iResolution.y);\nvec2 UV = vec2(0.0, 1.0) + vec2(1.0, -1.0) * (fragCoord-0.5*(iResolution.xy-vec2(minSize)))/minSize;\nfloat o74813_0_1_sdf2d = length((transform2_clamp(transform2((UV), vec2(p_o74864_translate_x*(2.0*1.0-1.0), p_o74864_translate_y*(2.0*1.0-1.0)), (iTime*80.00)*0.01745329251*(2.0*1.0-1.0), vec2(p_o74864_scale_x*(2.0*1.0-1.0), p_o74864_scale_y*(2.0*1.0-1.0)))))-vec2(p_o74813_cx+0.5, p_o74813_cy+0.5))-p_o74813_r;\nfloat o74814_0_1_sdf2d = length((transform2_clamp(transform2((UV), vec2(p_o74864_translate_x*(2.0*1.0-1.0), p_o74864_translate_y*(2.0*1.0-1.0)), (iTime*80.00)*0.01745329251*(2.0*1.0-1.0), vec2(p_o74864_scale_x*(2.0*1.0-1.0), p_o74864_scale_y*(2.0*1.0-1.0)))))-vec2(p_o74814_cx+0.5, p_o74814_cy+0.5))-p_o74814_r;\nfloat o74815_0_1_sdf2d = min( o74813_0_1_sdf2d, o74814_0_1_sdf2d);\nfloat o74811_0_1_sdf2d = sdArc((transform2_clamp(transform2((UV), vec2(p_o74864_translate_x*(2.0*1.0-1.0), p_o74864_translate_y*(2.0*1.0-1.0)), (iTime*80.00)*0.01745329251*(2.0*1.0-1.0), vec2(p_o74864_scale_x*(2.0*1.0-1.0), p_o74864_scale_y*(2.0*1.0-1.0)))))-vec2(0.5), mod(p_o74811_a1, 360.0)*0.01745329251, mod(p_o74811_a2, 360.0)*0.01745329251, p_o74811_r1, p_o74811_r2);\nfloat o74810_0_1_sdf2d = length((transform2_clamp(transform2((UV), vec2(p_o74864_translate_x*(2.0*1.0-1.0), p_o74864_translate_y*(2.0*1.0-1.0)), (iTime*80.00)*0.01745329251*(2.0*1.0-1.0), vec2(p_o74864_scale_x*(2.0*1.0-1.0), p_o74864_scale_y*(2.0*1.0-1.0)))))-vec2(p_o74810_cx+0.5, p_o74810_cy+0.5))-p_o74810_r;\nfloat o74812_0_1_sdf2d = max(- o74811_0_1_sdf2d, o74810_0_1_sdf2d);\nfloat o74816_0_1_sdf2d = max(- o74815_0_1_sdf2d, o74812_0_1_sdf2d);\nfloat o74817_0_1_f = clamp(-o74816_0_1_sdf2d/max(p_o74817_bevel, 0.00001), 0.0, 1.0);\nvec4 o74864_0_1_rgba = vec4(vec3(o74817_0_1_f), 1.0);\nfloat o74785_0_1_f = shape_circle((transform2_clamp(transform2((UV), vec2(p_o74821_translate_x*(2.0*1.0-1.0), p_o74821_translate_y*(2.0*1.0-1.0)), (iTime*80.0)*0.01745329251*(2.0*1.0-1.0), vec2(p_o74821_scale_x*(2.0*1.0-1.0), p_o74821_scale_y*(2.0*1.0-1.0))))), p_o74785_sides, p_o74785_radius*1.0, p_o74785_edge*1.0);\nfloat o74767_0_r = 0.5+(cos(p_o74767_rotate*0.01745329251)*((transform2_clamp(transform2((uvmirror_h((kal_rotate((transform2_clamp(transform2((UV), vec2(p_o74821_translate_x*(2.0*1.0-1.0), p_o74821_translate_y*(2.0*1.0-1.0)), (iTime*80.0)*0.01745329251*(2.0*1.0-1.0), vec2(p_o74821_scale_x*(2.0*1.0-1.0), p_o74821_scale_y*(2.0*1.0-1.0))))), p_o74783_count, p_o74783_offset)), p_o74782_offset)), vec2(p_o74781_translate_x*(2.0*1.0-1.0), p_o74781_translate_y*(2.0*1.0-1.0)), p_o74781_rotate*0.01745329251*(2.0*1.0-1.0), vec2(p_o74781_scale_x*(2.0*1.0-1.0), p_o74781_scale_y*(2.0*1.0-1.0))))).x-0.5)+sin(p_o74767_rotate*0.01745329251)*((transform2_clamp(transform2((uvmirror_h((kal_rotate((transform2_clamp(transform2((UV), vec2(p_o74821_translate_x*(2.0*1.0-1.0), p_o74821_translate_y*(2.0*1.0-1.0)), (iTime*80.0)*0.01745329251*(2.0*1.0-1.0), vec2(p_o74821_scale_x*(2.0*1.0-1.0), p_o74821_scale_y*(2.0*1.0-1.0))))), p_o74783_count, p_o74783_offset)), p_o74782_offset)), vec2(p_o74781_translate_x*(2.0*1.0-1.0), p_o74781_translate_y*(2.0*1.0-1.0)), p_o74781_rotate*0.01745329251*(2.0*1.0-1.0), vec2(p_o74781_scale_x*(2.0*1.0-1.0), p_o74781_scale_y*(2.0*1.0-1.0))))).y-0.5))/(cos(abs(mod(p_o74767_rotate, 90.0)-45.0)*0.01745329251)*1.41421356237);vec4 o74767_0_1_rgba = o74767_gradient_gradient_fct(fract(o74767_0_r*p_o74767_repeat));\nvec3 o74780_0_false = clamp((o74767_0_1_rgba.rgb-vec3(p_o74780_value))/max(0.0001, p_o74780_width)+vec3(0.5), vec3(0.0), vec3(1.0));\nvec3 o74780_0_true = vec3(1.0)-o74780_0_false;vec4 o74780_0_1_rgba = vec4(o74780_0_false, o74767_0_1_rgba.a);\nvec4 o74781_0_1_rgba = o74780_0_1_rgba;\nvec4 o74782_0_1_rgba = o74781_0_1_rgba;\nvec4 o74783_0_1_rgba = o74782_0_1_rgba;\nvec4 o74784_0_s1 = vec4(vec3(o74785_0_1_f), 1.0);\nvec4 o74784_0_s2 = o74783_0_1_rgba;\nfloat o74784_0_a = p_o74784_amount*1.0;\nvec4 o74784_0_2_rgba = vec4(blend_difference((transform2_clamp(transform2((UV), vec2(p_o74821_translate_x*(2.0*1.0-1.0), p_o74821_translate_y*(2.0*1.0-1.0)), (iTime*80.0)*0.01745329251*(2.0*1.0-1.0), vec2(p_o74821_scale_x*(2.0*1.0-1.0), p_o74821_scale_y*(2.0*1.0-1.0))))), o74784_0_s1.rgb, o74784_0_s2.rgb, o74784_0_a*o74784_0_s1.a), min(1.0, o74784_0_s2.a+o74784_0_a*o74784_0_s1.a));\nvec4 o74821_0_1_rgba = o74784_0_2_rgba;\nfloat o74745_0_1_f = shape_circle((transform2_clamp(transform2((UV), vec2(p_o74820_translate_x*(2.0*1.0-1.0), p_o74820_translate_y*(2.0*1.0-1.0)), (-iTime*160.00)*0.01745329251*(2.0*1.0-1.0), vec2(p_o74820_scale_x*(2.0*1.0-1.0), p_o74820_scale_y*(2.0*1.0-1.0))))), p_o74745_sides, p_o74745_radius*1.0, p_o74745_edge*1.0);\nfloat o74727_0_r = 0.5+(cos(p_o74727_rotate*0.01745329251)*((transform2_clamp(transform2((uvmirror_h((kal_rotate((transform2_clamp(transform2((UV), vec2(p_o74820_translate_x*(2.0*1.0-1.0), p_o74820_translate_y*(2.0*1.0-1.0)), (-iTime*160.00)*0.01745329251*(2.0*1.0-1.0), vec2(p_o74820_scale_x*(2.0*1.0-1.0), p_o74820_scale_y*(2.0*1.0-1.0))))), p_o74743_count, p_o74743_offset)), p_o74742_offset)), vec2(p_o74741_translate_x*(2.0*1.0-1.0), p_o74741_translate_y*(2.0*1.0-1.0)), p_o74741_rotate*0.01745329251*(2.0*1.0-1.0), vec2(p_o74741_scale_x*(2.0*1.0-1.0), p_o74741_scale_y*(2.0*1.0-1.0))))).x-0.5)+sin(p_o74727_rotate*0.01745329251)*((transform2_clamp(transform2((uvmirror_h((kal_rotate((transform2_clamp(transform2((UV), vec2(p_o74820_translate_x*(2.0*1.0-1.0), p_o74820_translate_y*(2.0*1.0-1.0)), (-iTime*160.00)*0.01745329251*(2.0*1.0-1.0), vec2(p_o74820_scale_x*(2.0*1.0-1.0), p_o74820_scale_y*(2.0*1.0-1.0))))), p_o74743_count, p_o74743_offset)), p_o74742_offset)), vec2(p_o74741_translate_x*(2.0*1.0-1.0), p_o74741_translate_y*(2.0*1.0-1.0)), p_o74741_rotate*0.01745329251*(2.0*1.0-1.0), vec2(p_o74741_scale_x*(2.0*1.0-1.0), p_o74741_scale_y*(2.0*1.0-1.0))))).y-0.5))/(cos(abs(mod(p_o74727_rotate, 90.0)-45.0)*0.01745329251)*1.41421356237);vec4 o74727_0_1_rgba = o74727_gradient_gradient_fct(fract(o74727_0_r*p_o74727_repeat));\nvec3 o74740_0_false = clamp((o74727_0_1_rgba.rgb-vec3(p_o74740_value))/max(0.0001, p_o74740_width)+vec3(0.5), vec3(0.0), vec3(1.0));\nvec3 o74740_0_true = vec3(1.0)-o74740_0_false;vec4 o74740_0_1_rgba = vec4(o74740_0_false, o74727_0_1_rgba.a);\nvec4 o74741_0_1_rgba = o74740_0_1_rgba;\nvec4 o74742_0_1_rgba = o74741_0_1_rgba;\nvec4 o74743_0_1_rgba = o74742_0_1_rgba;\nvec4 o74744_0_s1 = vec4(vec3(o74745_0_1_f), 1.0);\nvec4 o74744_0_s2 = o74743_0_1_rgba;\nfloat o74744_0_a = p_o74744_amount*1.0;\nvec4 o74744_0_2_rgba = vec4(blend_difference((transform2_clamp(transform2((UV), vec2(p_o74820_translate_x*(2.0*1.0-1.0), p_o74820_translate_y*(2.0*1.0-1.0)), (-iTime*160.00)*0.01745329251*(2.0*1.0-1.0), vec2(p_o74820_scale_x*(2.0*1.0-1.0), p_o74820_scale_y*(2.0*1.0-1.0))))), o74744_0_s1.rgb, o74744_0_s2.rgb, o74744_0_a*o74744_0_s1.a), min(1.0, o74744_0_s2.a+o74744_0_a*o74744_0_s1.a));\nvec4 o74820_0_1_rgba = o74744_0_2_rgba;\nvec4 o74725_0_s1 = o74821_0_1_rgba;\nvec4 o74725_0_s2 = o74820_0_1_rgba;\nfloat o74725_0_a = p_o74725_amount*1.0;\nvec4 o74725_0_2_rgba = vec4(blend_screen((UV), o74725_0_s1.rgb, o74725_0_s2.rgb, o74725_0_a*o74725_0_s1.a), min(1.0, o74725_0_s2.a+o74725_0_a*o74725_0_s1.a));\nfloat o74705_0_1_f = shape_circle((transform2_clamp(transform2((UV), vec2(p_o74819_translate_x*(2.0*1.0-1.0), p_o74819_translate_y*(2.0*1.0-1.0)), (iTime*320.00)*0.01745329251*(2.0*1.0-1.0), vec2(p_o74819_scale_x*(2.0*1.0-1.0), p_o74819_scale_y*(2.0*1.0-1.0))))), p_o74705_sides, p_o74705_radius*1.0, p_o74705_edge*1.0);\nfloat o74687_0_r = 0.5+(cos(p_o74687_rotate*0.01745329251)*((transform2_clamp(transform2((uvmirror_h((kal_rotate((transform2_clamp(transform2((UV), vec2(p_o74819_translate_x*(2.0*1.0-1.0), p_o74819_translate_y*(2.0*1.0-1.0)), (iTime*320.00)*0.01745329251*(2.0*1.0-1.0), vec2(p_o74819_scale_x*(2.0*1.0-1.0), p_o74819_scale_y*(2.0*1.0-1.0))))), p_o74703_count, p_o74703_offset)), p_o74702_offset)), vec2(p_o74701_translate_x*(2.0*1.0-1.0), p_o74701_translate_y*(2.0*1.0-1.0)), p_o74701_rotate*0.01745329251*(2.0*1.0-1.0), vec2(p_o74701_scale_x*(2.0*1.0-1.0), p_o74701_scale_y*(2.0*1.0-1.0))))).x-0.5)+sin(p_o74687_rotate*0.01745329251)*((transform2_clamp(transform2((uvmirror_h((kal_rotate((transform2_clamp(transform2((UV), vec2(p_o74819_translate_x*(2.0*1.0-1.0), p_o74819_translate_y*(2.0*1.0-1.0)), (iTime*320.00)*0.01745329251*(2.0*1.0-1.0), vec2(p_o74819_scale_x*(2.0*1.0-1.0), p_o74819_scale_y*(2.0*1.0-1.0))))), p_o74703_count, p_o74703_offset)), p_o74702_offset)), vec2(p_o74701_translate_x*(2.0*1.0-1.0), p_o74701_translate_y*(2.0*1.0-1.0)), p_o74701_rotate*0.01745329251*(2.0*1.0-1.0), vec2(p_o74701_scale_x*(2.0*1.0-1.0), p_o74701_scale_y*(2.0*1.0-1.0))))).y-0.5))/(cos(abs(mod(p_o74687_rotate, 90.0)-45.0)*0.01745329251)*1.41421356237);vec4 o74687_0_1_rgba = o74687_gradient_gradient_fct(fract(o74687_0_r*p_o74687_repeat));\nvec3 o74700_0_false = clamp((o74687_0_1_rgba.rgb-vec3(p_o74700_value))/max(0.0001, p_o74700_width)+vec3(0.5), vec3(0.0), vec3(1.0));\nvec3 o74700_0_true = vec3(1.0)-o74700_0_false;vec4 o74700_0_1_rgba = vec4(o74700_0_false, o74687_0_1_rgba.a);\nvec4 o74701_0_1_rgba = o74700_0_1_rgba;\nvec4 o74702_0_1_rgba = o74701_0_1_rgba;\nvec4 o74703_0_1_rgba = o74702_0_1_rgba;\nvec4 o74704_0_s1 = vec4(vec3(o74705_0_1_f), 1.0);\nvec4 o74704_0_s2 = o74703_0_1_rgba;\nfloat o74704_0_a = p_o74704_amount*1.0;\nvec4 o74704_0_2_rgba = vec4(blend_difference((transform2_clamp(transform2((UV), vec2(p_o74819_translate_x*(2.0*1.0-1.0), p_o74819_translate_y*(2.0*1.0-1.0)), (iTime*320.00)*0.01745329251*(2.0*1.0-1.0), vec2(p_o74819_scale_x*(2.0*1.0-1.0), p_o74819_scale_y*(2.0*1.0-1.0))))), o74704_0_s1.rgb, o74704_0_s2.rgb, o74704_0_a*o74704_0_s1.a), min(1.0, o74704_0_s2.a+o74704_0_a*o74704_0_s1.a));\nvec4 o74819_0_1_rgba = o74704_0_2_rgba;\nvec4 o74808_0_s1 = o74725_0_2_rgba;\nvec4 o74808_0_s2 = o74819_0_1_rgba;\nfloat o74808_0_a = p_o74808_amount*1.0;\nvec4 o74808_0_2_rgba = vec4(blend_screen((UV), o74808_0_s1.rgb, o74808_0_s2.rgb, o74808_0_a*o74808_0_s1.a), min(1.0, o74808_0_s2.a+o74808_0_a*o74808_0_s1.a));\nfloat o74841_0_1_f = shape_circle((rotate((transform2_clamp(transform2((UV), vec2(p_o74909_translate_x*(2.0*1.0-1.0), p_o74909_translate_y*(2.0*1.0-1.0)), (iTime*320.00)*0.01745329251*(2.0*1.0-1.0), vec2(p_o74909_scale_x*(2.0*1.0-1.0), p_o74909_scale_y*(2.0*1.0-1.0))))), vec2(0.5+p_o74809_cx, 0.5+p_o74809_cy), p_o74809_rotate*0.01745329251)), p_o74841_sides, p_o74841_radius*1.0, p_o74841_edge*1.0);\nfloat o74823_0_r = 0.5+(cos(p_o74823_rotate*0.01745329251)*((transform2_clamp(transform2((uvmirror_h((kal_rotate((rotate((transform2_clamp(transform2((UV), vec2(p_o74909_translate_x*(2.0*1.0-1.0), p_o74909_translate_y*(2.0*1.0-1.0)), (iTime*320.00)*0.01745329251*(2.0*1.0-1.0), vec2(p_o74909_scale_x*(2.0*1.0-1.0), p_o74909_scale_y*(2.0*1.0-1.0))))), vec2(0.5+p_o74809_cx, 0.5+p_o74809_cy), p_o74809_rotate*0.01745329251)), p_o74839_count, p_o74839_offset)), p_o74838_offset)), vec2(p_o74837_translate_x*(2.0*1.0-1.0), p_o74837_translate_y*(2.0*1.0-1.0)), p_o74837_rotate*0.01745329251*(2.0*1.0-1.0), vec2(p_o74837_scale_x*(2.0*1.0-1.0), p_o74837_scale_y*(2.0*1.0-1.0))))).x-0.5)+sin(p_o74823_rotate*0.01745329251)*((transform2_clamp(transform2((uvmirror_h((kal_rotate((rotate((transform2_clamp(transform2((UV), vec2(p_o74909_translate_x*(2.0*1.0-1.0), p_o74909_translate_y*(2.0*1.0-1.0)), (iTime*320.00)*0.01745329251*(2.0*1.0-1.0), vec2(p_o74909_scale_x*(2.0*1.0-1.0), p_o74909_scale_y*(2.0*1.0-1.0))))), vec2(0.5+p_o74809_cx, 0.5+p_o74809_cy), p_o74809_rotate*0.01745329251)), p_o74839_count, p_o74839_offset)), p_o74838_offset)), vec2(p_o74837_translate_x*(2.0*1.0-1.0), p_o74837_translate_y*(2.0*1.0-1.0)), p_o74837_rotate*0.01745329251*(2.0*1.0-1.0), vec2(p_o74837_scale_x*(2.0*1.0-1.0), p_o74837_scale_y*(2.0*1.0-1.0))))).y-0.5))/(cos(abs(mod(p_o74823_rotate, 90.0)-45.0)*0.01745329251)*1.41421356237);vec4 o74823_0_1_rgba = o74823_gradient_gradient_fct(fract(o74823_0_r*p_o74823_repeat));\nvec3 o74836_0_false = clamp((o74823_0_1_rgba.rgb-vec3(p_o74836_value))/max(0.0001, p_o74836_width)+vec3(0.5), vec3(0.0), vec3(1.0));\nvec3 o74836_0_true = vec3(1.0)-o74836_0_false;vec4 o74836_0_1_rgba = vec4(o74836_0_false, o74823_0_1_rgba.a);\nvec4 o74837_0_1_rgba = o74836_0_1_rgba;\nvec4 o74838_0_1_rgba = o74837_0_1_rgba;\nvec4 o74839_0_1_rgba = o74838_0_1_rgba;\nvec4 o74840_0_s1 = vec4(vec3(o74841_0_1_f), 1.0);\nvec4 o74840_0_s2 = o74839_0_1_rgba;\nfloat o74840_0_a = p_o74840_amount*1.0;\nvec4 o74840_0_2_rgba = vec4(blend_difference((rotate((transform2_clamp(transform2((UV), vec2(p_o74909_translate_x*(2.0*1.0-1.0), p_o74909_translate_y*(2.0*1.0-1.0)), (iTime*320.00)*0.01745329251*(2.0*1.0-1.0), vec2(p_o74909_scale_x*(2.0*1.0-1.0), p_o74909_scale_y*(2.0*1.0-1.0))))), vec2(0.5+p_o74809_cx, 0.5+p_o74809_cy), p_o74809_rotate*0.01745329251)), o74840_0_s1.rgb, o74840_0_s2.rgb, o74840_0_a*o74840_0_s1.a), min(1.0, o74840_0_s2.a+o74840_0_a*o74840_0_s1.a));\nvec4 o74809_0_1_rgba = o74840_0_2_rgba;\nvec4 o74909_0_1_rgba = o74809_0_1_rgba;\nvec4 o74818_0_s1 = o74808_0_2_rgba;\nvec4 o74818_0_s2 = o74909_0_1_rgba;\nfloat o74818_0_a = p_o74818_amount*1.0;\nvec4 o74818_0_2_rgba = vec4(blend_screen((UV), o74818_0_s1.rgb, o74818_0_s2.rgb, o74818_0_a*o74818_0_s1.a), min(1.0, o74818_0_s2.a+o74818_0_a*o74818_0_s1.a));\nvec4 o74908_0_s1 = o74864_0_1_rgba;\nvec4 o74908_0_s2 = o74818_0_2_rgba;\nfloat o74908_0_a = p_o74908_amount*1.0;\nvec4 o74908_0_2_rgba = vec4(blend_screen((UV), o74908_0_s1.rgb, o74908_0_s2.rgb, o74908_0_a*o74908_0_s1.a), min(1.0, o74908_0_s2.a+o74908_0_a*o74908_0_s1.a));\nfloat o74884_0_1_f = shape_circle((transform2_clamp(transform2((UV), vec2(p_o74910_translate_x*(2.0*1.0-1.0), p_o74910_translate_y*(2.0*1.0-1.0)), (sin(iTime*10.00)*64.0)*0.01745329251*(2.0*1.0-1.0), vec2(p_o74910_scale_x*(2.0*1.0-1.0), p_o74910_scale_y*(2.0*1.0-1.0))))), p_o74884_sides, p_o74884_radius*1.0, p_o74884_edge*1.0);\nfloat o74866_0_r = 0.5+(cos(p_o74866_rotate*0.01745329251)*((transform2_clamp(transform2((uvmirror_h((kal_rotate((transform2_clamp(transform2((UV), vec2(p_o74910_translate_x*(2.0*1.0-1.0), p_o74910_translate_y*(2.0*1.0-1.0)), (sin(iTime*10.00)*64.0)*0.01745329251*(2.0*1.0-1.0), vec2(p_o74910_scale_x*(2.0*1.0-1.0), p_o74910_scale_y*(2.0*1.0-1.0))))), p_o74882_count, p_o74882_offset)), p_o74881_offset)), vec2(p_o74880_translate_x*(2.0*1.0-1.0), p_o74880_translate_y*(2.0*1.0-1.0)), p_o74880_rotate*0.01745329251*(2.0*1.0-1.0), vec2(p_o74880_scale_x*(2.0*1.0-1.0), p_o74880_scale_y*(2.0*1.0-1.0))))).x-0.5)+sin(p_o74866_rotate*0.01745329251)*((transform2_clamp(transform2((uvmirror_h((kal_rotate((transform2_clamp(transform2((UV), vec2(p_o74910_translate_x*(2.0*1.0-1.0), p_o74910_translate_y*(2.0*1.0-1.0)), (sin(iTime*10.00)*64.0)*0.01745329251*(2.0*1.0-1.0), vec2(p_o74910_scale_x*(2.0*1.0-1.0), p_o74910_scale_y*(2.0*1.0-1.0))))), p_o74882_count, p_o74882_offset)), p_o74881_offset)), vec2(p_o74880_translate_x*(2.0*1.0-1.0), p_o74880_translate_y*(2.0*1.0-1.0)), p_o74880_rotate*0.01745329251*(2.0*1.0-1.0), vec2(p_o74880_scale_x*(2.0*1.0-1.0), p_o74880_scale_y*(2.0*1.0-1.0))))).y-0.5))/(cos(abs(mod(p_o74866_rotate, 90.0)-45.0)*0.01745329251)*1.41421356237);vec4 o74866_0_1_rgba = o74866_gradient_gradient_fct(fract(o74866_0_r*p_o74866_repeat));\nvec3 o74879_0_false = clamp((o74866_0_1_rgba.rgb-vec3(p_o74879_value))/max(0.0001, p_o74879_width)+vec3(0.5), vec3(0.0), vec3(1.0));\nvec3 o74879_0_true = vec3(1.0)-o74879_0_false;vec4 o74879_0_1_rgba = vec4(o74879_0_false, o74866_0_1_rgba.a);\nvec4 o74880_0_1_rgba = o74879_0_1_rgba;\nvec4 o74881_0_1_rgba = o74880_0_1_rgba;\nvec4 o74882_0_1_rgba = o74881_0_1_rgba;\nvec4 o74883_0_s1 = vec4(vec3(o74884_0_1_f), 1.0);\nvec4 o74883_0_s2 = o74882_0_1_rgba;\nfloat o74883_0_a = p_o74883_amount*1.0;\nvec4 o74883_0_2_rgba = vec4(blend_difference((transform2_clamp(transform2((UV), vec2(p_o74910_translate_x*(2.0*1.0-1.0), p_o74910_translate_y*(2.0*1.0-1.0)), (sin(iTime*10.00)*64.0)*0.01745329251*(2.0*1.0-1.0), vec2(p_o74910_scale_x*(2.0*1.0-1.0), p_o74910_scale_y*(2.0*1.0-1.0))))), o74883_0_s1.rgb, o74883_0_s2.rgb, o74883_0_a*o74883_0_s1.a), min(1.0, o74883_0_s2.a+o74883_0_a*o74883_0_s1.a));\nvec4 o74910_0_1_rgba = o74883_0_2_rgba;\nvec4 o74911_0_s1 = o74908_0_2_rgba;\nvec4 o74911_0_s2 = o74910_0_1_rgba;\nfloat o74911_0_a = p_o74911_amount*1.0;\nvec4 o74911_0_2_rgba = vec4(blend_screen((UV), o74911_0_s1.rgb, o74911_0_s2.rgb, o74911_0_a*o74911_0_s1.a), min(1.0, o74911_0_s2.a+o74911_0_a*o74911_0_s1.a));\nfloat o74667_0_1_f = shape_circle((transform2_clamp(transform2((UV), vec2(p_o74912_translate_x*(2.0*1.0-1.0), p_o74912_translate_y*(2.0*1.0-1.0)), (sin(iTime*10.00)*64.0)*0.01745329251*(2.0*1.0-1.0), vec2(p_o74912_scale_x*(2.0*1.0-1.0), p_o74912_scale_y*(2.0*1.0-1.0))))), p_o74667_sides, p_o74667_radius*1.0, p_o74667_edge*1.0);\nfloat o74649_0_r = 0.5+(cos(p_o74649_rotate*0.01745329251)*((transform2_clamp(transform2((uvmirror_h((kal_rotate((transform2_clamp(transform2((UV), vec2(p_o74912_translate_x*(2.0*1.0-1.0), p_o74912_translate_y*(2.0*1.0-1.0)), (sin(iTime*10.00)*64.0)*0.01745329251*(2.0*1.0-1.0), vec2(p_o74912_scale_x*(2.0*1.0-1.0), p_o74912_scale_y*(2.0*1.0-1.0))))), p_o74665_count, p_o74665_offset)), p_o74664_offset)), vec2(p_o74663_translate_x*(2.0*1.0-1.0), p_o74663_translate_y*(2.0*1.0-1.0)), p_o74663_rotate*0.01745329251*(2.0*1.0-1.0), vec2(p_o74663_scale_x*(2.0*1.0-1.0), p_o74663_scale_y*(2.0*1.0-1.0))))).x-0.5)+sin(p_o74649_rotate*0.01745329251)*((transform2_clamp(transform2((uvmirror_h((kal_rotate((transform2_clamp(transform2((UV), vec2(p_o74912_translate_x*(2.0*1.0-1.0), p_o74912_translate_y*(2.0*1.0-1.0)), (sin(iTime*10.00)*64.0)*0.01745329251*(2.0*1.0-1.0), vec2(p_o74912_scale_x*(2.0*1.0-1.0), p_o74912_scale_y*(2.0*1.0-1.0))))), p_o74665_count, p_o74665_offset)), p_o74664_offset)), vec2(p_o74663_translate_x*(2.0*1.0-1.0), p_o74663_translate_y*(2.0*1.0-1.0)), p_o74663_rotate*0.01745329251*(2.0*1.0-1.0), vec2(p_o74663_scale_x*(2.0*1.0-1.0), p_o74663_scale_y*(2.0*1.0-1.0))))).y-0.5))/(cos(abs(mod(p_o74649_rotate, 90.0)-45.0)*0.01745329251)*1.41421356237);vec4 o74649_0_1_rgba = o74649_gradient_gradient_fct(fract(o74649_0_r*p_o74649_repeat));\nvec3 o74662_0_false = clamp((o74649_0_1_rgba.rgb-vec3(p_o74662_value))/max(0.0001, p_o74662_width)+vec3(0.5), vec3(0.0), vec3(1.0));\nvec3 o74662_0_true = vec3(1.0)-o74662_0_false;vec4 o74662_0_1_rgba = vec4(o74662_0_false, o74649_0_1_rgba.a);\nvec4 o74663_0_1_rgba = o74662_0_1_rgba;\nvec4 o74664_0_1_rgba = o74663_0_1_rgba;\nvec4 o74665_0_1_rgba = o74664_0_1_rgba;\nvec4 o74666_0_s1 = vec4(vec3(o74667_0_1_f), 1.0);\nvec4 o74666_0_s2 = o74665_0_1_rgba;\nfloat o74666_0_a = p_o74666_amount*1.0;\nvec4 o74666_0_2_rgba = vec4(blend_difference((transform2_clamp(transform2((UV), vec2(p_o74912_translate_x*(2.0*1.0-1.0), p_o74912_translate_y*(2.0*1.0-1.0)), (sin(iTime*10.00)*64.0)*0.01745329251*(2.0*1.0-1.0), vec2(p_o74912_scale_x*(2.0*1.0-1.0), p_o74912_scale_y*(2.0*1.0-1.0))))), o74666_0_s1.rgb, o74666_0_s2.rgb, o74666_0_a*o74666_0_s1.a), min(1.0, o74666_0_s2.a+o74666_0_a*o74666_0_s1.a));\nvec4 o74912_0_1_rgba = o74666_0_2_rgba;\nvec4 o74913_0_s1 = o74911_0_2_rgba;\nvec4 o74913_0_s2 = o74912_0_1_rgba;\nfloat o74913_0_a = p_o74913_amount*1.0;\nvec4 o74913_0_2_rgba = vec4(blend_screen((UV), o74913_0_s1.rgb, o74913_0_s2.rgb, o74913_0_a*o74913_0_s1.a), min(1.0, o74913_0_s2.a+o74913_0_a*o74913_0_s1.a));\nfragColor = o74913_0_2_rgba;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtcBRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 7, 27, 27, 95], [97, 97, 117, 117, 229], [231, 231, 251, 251, 436], [438, 438, 460, 460, 757], [759, 759, 781, 781, 941], [943, 943, 1004, 1004, 1387], [1388, 1388, 1420, 1420, 1463], [1465, 1465, 1533, 1533, 1718], [1718, 1718, 1784, 1784, 1921], [1923, 1923, 1990, 1990, 2228], [2230, 2230, 2294, 2294, 2557], [2559, 2559, 2630, 2630, 2882], [2884, 2884, 2948, 2948, 3175], [3177, 3177, 3217, 3217, 3279], [3280, 3280, 3320, 3320, 3382], [3382, 3382, 3435, 3435, 3661], [3661, 3661, 3722, 3722, 3763], [3765, 3765, 3828, 3828, 3896], [3898, 3898, 3961, 3961, 4005], [4007, 4007, 4068, 4068, 4130], [4132, 4132, 4175, 4175, 4241], [4243, 4243, 4305, 4305, 4435], [4437, 4437, 4502, 4502, 4583], [4585, 4585, 4631, 4631, 4726], [4728, 4728, 4793, 4793, 4932], [4934, 4934, 4974, 4974, 5027], [5029, 5029, 5088, 5088, 5209], [5211, 5211, 5252, 5252, 5297], [5299, 5299, 5359, 5359, 5483], [5485, 5485, 5547, 5547, 5597], [5599, 5599, 5660, 5660, 5710], [5712, 5712, 5777, 5777, 5850], [5851, 5851, 5900, 5900, 6050], [8422, 8422, 8466, 8466, 9050], [10427, 10427, 10471, 10471, 11055], [12432, 12432, 12476, 12476, 13060], [14559, 14559, 14603, 14603, 15187], [16564, 16564, 16608, 16608, 17192], [18568, 18568, 18612, 18612, 19196], [19198, 19198, 19253, 19253, 38580]], "test": "valid"}
{"id": "WtcBRl", "name": "first shot", "author": "Safergo", "description": "This is my hello shader :D", "tags": ["2d", "amateur"], "likes": 2, "viewed": 65, "published": "Public", "date": "1613205690", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float remap01(float a, float b, float t) {\n    return (t - a) / (b - a);\n}\n\nfloat remap(float a, float b, float c, float d, float t) {\n    return remap01(a, b, t) * (d - c) + c;\n}\n\nvec4 Circle(float r,vec3 color, float blur, vec2 uv) {\n    float new_circle = smoothstep(r, r - blur, length(uv));\n    return vec4(vec3(new_circle) * color, 1.0);\n}\n\nmat2 rotate(float angle) {\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nfloat Band(float a, float b, float t, float blur) {\n    float band1 = smoothstep(a - blur, a + blur, t);\n    float band2 = smoothstep(b + blur, b - blur, t);\n    \n    return band1 * band2;\n}\n\nvec4 Rect(float x1, float x2, float y1, float y2, vec2 uv, float blur, vec3 color) {\n    float rect1 = Band(x1, x2, uv.x, blur);\n    float rect2 = Band(y1, y2, uv.y, blur);\n    return vec4(vec3(rect1 * rect2) * color, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Bright circle\n\n    vec2 new_uv = uv;\n    new_uv *= rotate(cos(iTime * 2.0) * 2.0);\n    new_uv.x *= remap(-1.0, 1.0, 1.0, 0.8, sin(iTime * 3.0)) + 0.1;\n    new_uv.y *= remap(-1.0, 1.0, 1.0, 0.8, sin(iTime * 4.0));\n    float size_circle = remap(0.0, -2.0, 0.02, 0.3, cos(iTime * 0.5) - 1.0);\n    vec3 color_mod = vec3(smoothstep(size_circle, 0.0, length(new_uv)));\n    vec4 circle = Circle(0.26, vec3(0.32, 0.2, 1) * 4.0 * color_mod, 0.025, new_uv);\n\n    // Sticks\n\n    new_uv = uv;\n    float a = (new_uv.y - 0.6) * (new_uv.y + 0.5);\n    a *= sin(iTime * 2.7 + new_uv.y) / 3.5;\n    new_uv.x += a + 0.4;\n    \n    float x1 = remap(-0.5, 0.5, 0.0, 0.05, uv.y);\n    float height = sin(iTime + 5.0)*0.5;\n    color_mod = vec3(smoothstep(-0.65, 0.5, new_uv.y));\n    vec4 stickBlue = Rect(x1, 0.05, -0.5, height, new_uv, 0.005, vec3(0.1, 0.56, 0.71) * 2.0 * color_mod);\n\n    /////////////////\n    \n    new_uv = uv;\n    a = (new_uv.y - 0.6) * (new_uv.y + 0.5);\n    a *= cos(iTime * 2.7 + new_uv.y) / 2.5;\n\n    x1 = remap(-0.5, 0.5, 0.5, 0.52, uv.y * 1.5);\n    new_uv.x += a + 0.4;\n    height = sin(iTime * 0.5 + 5.0) * 0.5;\n    color_mod = vec3(smoothstep(-0.62, 0.5, new_uv.y));\n    vec4 stickGreen = Rect(x1, 0.52, -0.5, height, new_uv, 0.005, vec3(0.07, 0.92, 0.47) * 2.0 * color_mod);\n\n    ////////////////\n\n    new_uv = uv;\n    a = (new_uv.y - 0.6) * (new_uv.y + 0.5);\n    a *= cos(iTime * 2.7 + new_uv.y) / 2.5;\n\n    x1 = remap(-0.5, 0.5, 0.785, 0.8, uv.y * 3.0);\n    new_uv.x += a + 0.4;\n    height = remap(-2.0, 1.0, -1.0, 0.01, sin(iTime * 0.65 + 4.8));\n    color_mod = vec3(smoothstep(-0.55, 0.01, new_uv.y));\n    vec4 stickOrange = Rect(x1, 0.8, -0.5, height, new_uv, 0.005, vec3(0.97, 0.58, 0) * 2.0 * color_mod);\n\n    // Red flames\n    new_uv = uv;\n    new_uv.y += remap(-1.0, 1.0, 0.0, 0.4, sin(new_uv.x * 10.0 + iTime * 2.0) * 0.3);\n    new_uv *= rotate(0.7);\n    vec4 flameR = Rect(-0.5, 0.7, 0.65, 0.7, new_uv, 0.05, vec3(1, 0, 0.33) * 2.0);\n\n    ////////////////\n\n    new_uv = uv;\n    new_uv.y += remap(-1.0, 1.0, 0.0, 0.4, cos(new_uv.x * 10.0 + iTime * 2.0) * 0.3);\n    new_uv *= rotate(-0.7);\n    vec4 flameL = Rect(-0.7, 0.5, 0.65, 0.7, new_uv, 0.05, vec3(1, 0, 0.33) * 2.0);\n\n    fragColor = circle + stickBlue + stickGreen + stickOrange + flameR + flameL;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtcBRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 42, 42, 74], [76, 76, 134, 134, 179], [181, 181, 235, 235, 345], [347, 347, 373, 373, 441], [443, 443, 494, 494, 633], [635, 635, 719, 719, 860], [862, 862, 917, 917, 3298]], "test": "valid"}
{"id": "wtcBRN", "name": "A Pie Chart", "author": "ivomontigatti", "description": "a pie chart", "tags": ["chart", "pie"], "likes": 2, "viewed": 73, "published": "Public", "date": "1612324450", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float HPI = 1.5707963269;\nfloat PI = 3.1415926538;\nfloat PI2 = 6.2831853076;\nfloat radius = 0.4;\nfloat innerRadius = 0.25;\n\nfloat ratios[5] = float[5](0.2, 0.3, 0.6, 0.9, 1.0);\nvec4 colors[5] = vec4[5](\n    vec4(0.17254, 0.24313, 0.254901, 1.0),\n    vec4(0.94901, 0.18823, 0.25490, 1.0),\n    vec4(0.5490, 0.14901, 0.22352, 1.0),\n    vec4(0.4705, 0.7490, 0.69803, 1.0),\n    vec4(0.94901, 0.0745, 0.0745, 1.0));\n    \nfloat nsin(float t, float from, float to){\n    return ((sin(t) + 1.0) / 2.0) * (to - from) + from;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x / iResolution.y;\n    float u = ((fragCoord.x - iResolution.x * 0.5) / iResolution.x) * aspect;\n    float v = ((fragCoord.y - iResolution.y * 0.5) / iResolution.y);\n    vec2 uv = vec2(u, v);\n    vec2 nuv = normalize(uv);\n    vec2 up = normalize(vec2(radius, 0.0));\n    float l = length(uv);\n    float _dot = up.x*nuv.x + up.y*nuv.y;\n    float _det = up.x*nuv.y - up.y*nuv.x;\n    float angle = atan(_dot, _det);\n    if(angle < 0.0) angle = PI + (PI + angle);\n    angle /= PI2 * nsin(iTime, 0.0, 1.0);\n    \n    fragColor = vec4(1.0);\n    if(l < radius && l > innerRadius){\n        for(int i = 0; i < 5; i+=1) {\n            float r = ratios[i];\n            if(angle < r) {\n                vec4 color = colors[i];\n                fragColor = color;\n                break;\n            }\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtcBRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[415, 415, 457, 457, 515], [517, 517, 574, 574, 1406]], "test": "valid"}
{"id": "WtcBzl", "name": "[OMZG] Shader Royale - 福", "author": "totetmatt", "description": "Version at the end of the Shader Royale, not my favourite version to be honnest. Will create a new version later that go back to the point where I was liking it.", "tags": ["shaderroyale"], "likes": 5, "viewed": 208, "published": "Public API", "date": "1613215870", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n\nfloat bbox(vec2 uv, vec2 a, vec2 b, float t){\n    float l = length(b-a);\n    vec2 d = (b-a)/l;\n    vec2 q = uv - (a+b)*.5;\n  \n    q = mat2(d.x,-d.y,d.y,d.x)*q;\n    float tt = max(texture(iChannel0,vec2(abs(q.x+q.y*20.)*.01)).r*.02,.001);\n    q = abs(q) - vec2(l+(t/tt)*.0001,t-tt)*.5;\n    return length(max(q,vec2(0.))) + min(max(q.x,q.y),0.);\n  }\n  \n  \n  float left_fu(vec2 uv){\n   float h =  bbox(uv,vec2(-.1,-.2), vec2(-.1,.1),.01);\n    \n    float t = bbox(uv,vec2(-.2,.2), vec2(.0,.2),.01);\n    h = min(t,h);\n    \n     t = bbox(uv,vec2(.0,.2), vec2(-.2,.1),.01);\n    h = min(t,h);\n    \n     t = bbox(uv,vec2(-.05,.1), vec2(.01,.05),.01);\n    h = min(t,h);\n    \n      t = bbox(uv,vec2(-.15,.30), vec2(-.10,.25),.01);\n    h = min(t,h);\n    return h;\n    }\n       \n  float right_fu(vec2 uv){\n     float h =  bbox(uv,vec2(.35,.25), vec2(.05,.25),.01);\n    \n      float t = abs(bbox(uv,vec2(.3,.13), vec2(.1,.13),.1))-.01;\n      h = min(t,h);\n\n    \n     uv +=vec2(.05,.0);\n      t = bbox(uv,vec2(.25,.00), vec2(.25,-.20),.01);\n      h = min(t,h);\n    uv *=.5;\n   \n    t = abs(bbox(uv,vec2(.2,-.05), vec2(.05,-.05),.1))-.001;\n      h = min(t,h);\n    \n     t = bbox(uv,vec2(.2,-.05), vec2(.05,-.05),.001);\n      h = min(t,h);\n    return h;\n    \n  }\n  float fu(vec2 uv){\n    float h =  left_fu(uv);\n    float r = right_fu(uv);\n    h = min(h,r);\n    \n    \n    return h ;\n      \n    }\n    \nvec3 pal(float t){\n\n    return vec3(.5)+.5*cos(2.*3.141592*(1.*t+vec3(.0,.3,.7)));\n  }\n  \n  \n float mandel(vec2 uv){\n     float tt = texture(iChannel0,vec2(.3)).r*.1;\n      vec2 c = vec2(.41-tt,.42+tt);\n      vec2 z = uv;\n      float limit = 200.;\n      float cpt =  0.;\n   \n   for(float i = 0.;i<=limit; i++){\n   \n        z = vec2(z.x*z.x-z.y*z.y,2.*z.x*z.y)+c;\n        if(length(z) >2.) break;\n        cpt ++;\n     \n     }\n     \n     return cpt /limit;\n   }\n   #define fGlobalTime iTime\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    float t1 = texture(iChannel0,vec2(.3)).r*.01;\n \n  float t2 = texture(iChannel0,vec2(.7)).r*.01;\n  uv *=(fract(-fGlobalTime*.5+length(uv)));\n  uv *=2.;\n  uv.x +=fract(fGlobalTime+t1*.1);\n   uv.y += sin(fGlobalTime)+t2*10.;\n  vec2 id = floor(uv);\n  uv = fract(uv)-.5;\n float d = fu(uv);\n   float mandal = mandel(abs(uv)+.1);\n  d = abs(.01/(d));\n  if(mod(id.x,2.) ==0.){\n     d = 1.-d;\n  }\n  vec3 col = vec3(d)*pal(mandal*10.+d*.001+fract(fGlobalTime)+uv.x);\n\n    // Output to screen\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [{"id": "MlfSRM", "previewfilepath": "https://soundcloud.com/h0ffman/hoffman-ziphead", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/h0ffman/hoffman-ziphead", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtcBzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[3, 3, 48, 48, 350], [359, 359, 382, 382, 760], [771, 771, 795, 795, 1248], [1251, 1251, 1269, 1269, 1381], [1387, 1387, 1405, 1405, 1473], [1481, 1481, 1503, 1503, 1846], [1876, 1876, 1933, 1983, 2567]], "test": "error"}
{"id": "WtcfDB", "name": "Menger sponge space base", "author": "mrange", "description": "License CC0: Menger sponge space base\n Tweaking menger sponges revealed a space based hidden inside\n", "tags": ["sponge"], "likes": 9, "viewed": 239, "published": "Public API", "date": "1613337483", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License CC0: Menger sponge space base\n//  Tweaking menger sponges revealed a space based hidden inside\n\n#define TIME            iTime\n#define TOLERANCE       0.0001\n#define MAX_RAY_LENGTH  9.0\n#define HIT_SKY         1E6\n#define MAX_RAY_MARCHES 100\n#define LESS(a,b,c)     mix(a,b,step(0.,c))\n#define SABS(x,k)       LESS((.5/(k))*(x)*(x)+(k)*.5,abs(x),abs(x)-(k))\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define PSIN(x)         (0.5+0.5*sin(x))\n#define PERIOD          20.0\n#define PERIODTIME      mod(TIME,PERIOD)\n#define PERIODN         int(mod(floor(TIME/PERIOD), 3.0))\n#define FADE            1.0\n\nconst vec3  sunDirection        = normalize(vec3(-2.5, 3.5, -10.0));\nconst vec3  sunColor1           = vec3(1.0, 0.8, 0.8);\nconst vec3  sunColor2           = vec3(1.0, 0.8, 0.9);\nconst vec3  smallSunDirection   = normalize(vec3(0.5, 0, -10.0));\nconst vec3  smallSunColor1      = vec3(1.0, 0.6, 0.6);\nconst vec3  smallSunColor2      = vec3(1.0, 0.3, 0.6);\nconst vec3  ringColor           = sqrt(vec3(0.95, 0.65, 0.45));\nconst vec4  planet              = vec4(150.0, 0.0, 180.0, 50.0)*1000.0;\nconst vec3  planetCol           = sqrt(vec3(0.3, 0.5, 0.9))*1.5;\nconst vec3  ringsNormal         = normalize(vec3(1.0, 02.25, 0.0));\nconst vec4  rings               = vec4(ringsNormal, -dot(ringsNormal, planet.xyz));\nconst mat2  rot45               = ROT(PI/4.0);\nconst mat2  rot1                = ROT(1.0);\nconst mat2  rot2                = ROT(2.0);\nconst vec3  center              = vec3(0.0, 0.0, 0.0);\nconst vec4  glowSphere          = vec4(center, 1.2);\nconst vec3  glowCol             = vec3(3.0, 2.0, 1.);\nconst vec3  baseCol             = vec3(0.45, 0.45, 0.5)*0.5;\n\nfloat sphered(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n    float ndbuffer = dbuffer/sph.w;\n    vec3  rc = (ro - sph.xyz)/sph.w;\n  \n    float b = dot(rd,rc);\n    float c = dot(rc,rc) - 1.0;\n    float h = b*b - c;\n    if( h<0.0 ) return 0.0;\n    h = sqrt( h );\n    float t1 = -b - h;\n    float t2 = -b + h;\n\n    if( t2<0.0 || t1>ndbuffer ) return 0.0;\n    t1 = max( t1, 0.0 );\n    t2 = min( t2, ndbuffer );\n\n    float i1 = -(c*t1 + b*t1*t1 + t1*t1*t1/3.0);\n    float i2 = -(c*t2 + b*t2*t2 + t2*t2*t2/3.0);\n    return (i2-i1)*(3.0/4.0);\n}\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nfloat sphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat box(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat box(vec4 p, vec4 b) {\n  vec4 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(max(q.x, q.w),max(q.y,q.z)),0.0);\n}\n\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nvec2 raySphere(vec3 ro, vec3 rd, vec3 ce, float ra) {\n  vec3 oc = ro - ce;\n  float b = dot(oc, rd);\n  float c = dot(oc, oc) - ra*ra;\n  float h = b*b - c;\n  if (h<0.0) return vec2(-1.0); // no intersection\n  h = sqrt(h);\n  return vec2( -b-h, -b+h );\n}\n\nvec3 gasGiant(vec3 ro, vec3 rd, vec3 sunDir) {\n  vec2 si = raySphere(ro, rd, planet.xyz, planet.w);\n  float pi = rayPlane(ro, rd, rings);\n  \n  vec3 planetSurface = ro + si.x*rd;\n  vec3 planetNormal = normalize(planetSurface - planet.xyz);\n  float planetDiff = max(dot(planetNormal, sunDir), 0.0);\n  float planetBorder = max(dot(planetNormal, -rd), 0.0);\n  float planetLat = (planetSurface.x+planetSurface.y)*0.0005;\n  vec3 planetCol = mix(1.3*planetCol, 0.3*planetCol, pow(PSIN(planetLat+1.0)*PSIN(sqrt(2.0)*planetLat+2.0)*PSIN(sqrt(3.5)*planetLat+3.0), 0.5));\n\n  vec3 ringsSurface = ro + pi*rd;\n\n  float borderTransparency = smoothstep(0.0, 0.1, planetBorder);\n  \n  float ringsDist = length(ringsSurface - planet.xyz)*1.0;\n  float ringsPeriod = ringsDist*0.001;\n  const float ringsMax = 150000.0*0.655;\n  const float ringsMin = 100000.0*0.666;\n  float ringsMul = pow(PSIN(ringsPeriod+1.0)*PSIN(sqrt(0.5)*ringsPeriod+2.0)*PSIN(sqrt(0.45)*ringsPeriod+4.0)*PSIN(sqrt(0.35)*ringsPeriod+5.0), 0.25);\n  float ringsMix = PSIN(ringsPeriod*10.0)*PSIN(ringsPeriod*10.0*sqrt(2.0))*(1.0 - smoothstep(50000.0, 200000.0, pi));\n\n  vec3 ringsCol = mix(vec3(0.125), 0.75*ringColor, ringsMix)*step(-pi, 0.0)*step(ringsDist, ringsMax)*step(-ringsDist, -ringsMin)*ringsMul;\n  \n  vec3 final = vec3(0.0);\n    \n  final += ringsCol*(step(pi, si.x) + step(si.x, 0.0));\n  \n  final += step(0.0, si.x)*pow(planetDiff, 0.75)*mix(planetCol, ringsCol, 0.0)*borderTransparency + ringsCol*(1.0 - borderTransparency);\n\n  return final;\n}\n\nvec3 sunColor(vec3 ro, vec3 rd) {\n  float diff = max(dot(rd, sunDirection), 0.0);\n  float smallDiff = max(dot(rd, smallSunDirection), 0.0);\n  vec3 col = vec3(0.0);\n\n  col += pow(diff, 800.0)*sunColor1*8.0;\n  col += pow(diff, 150.0)*sunColor2;\n\n  col += pow(smallDiff, 8000.0)*smallSunColor1*1.0;\n  col += pow(smallDiff, 400.0)*smallSunColor2*0.5;\n  col += pow(smallDiff, 150.0)*smallSunColor2*0.5;\n\n  return col;\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  vec3 scol = sunColor(ro, rd);\n  vec3 gcol = gasGiant(ro+vec3(0.0, 0.0, 200000.0), rd, sunDirection);\n  \n  return scol+gcol;\n}\n\nfloat minda = 1E6;\n\nfloat mengerSponge(vec4 p) {\n  float db = box(p, vec4(1.175, 1.-0.1, 1.05, 1.0));\n  if(db > .125) return db;\n    \n  float res = db;\n\n  float s = 1.0;\n  const int mc = 4;\n  for(int m = 0; m < mc; ++m) {\n\n    vec4 a = mod(p*s, 2.0)-1.0;\n    s *= 3.0;\n    vec4 r = abs(1.0 - 3.0*abs(a));\n\n    r -= vec4(2.0, 2.0, 2.0, 2.0)+vec4(0.1, 0.1, 0.1, 0)*-2.;\n    float da = sphere(r.xyz, 1.0); // w\n    float db = box(r.yzw, vec3(1)); // x\n    float dc = box(r.xzw, vec3(1)); // y\n    float dd = box(r.xyw, vec3(1.2)); // z\n\n    minda = min(minda, max(da, da));\n\n    float du = da;\n    du = min(du, db);\n    du = min(du, dc);\n    du = min(du, dd);\n    float lw = mix(0.215, 0.05, float(m)/float(mc-1));\n    du = abs(du)-lw;\n    du /= s;\n\n    res = max(res, -du);\n  }\n  \n  return (res);\n}\n\nfloat df(vec3 p) {\n  p -= center;\n  vec4 pp = vec4(p, 0.);\n  pp.xz *= rot1;\n  pp.yz *= rot2;\n  pp.zw *= rot45;\n  pp.yw *= rot45;\n  pp.xw *= rot45;\n  float dm = mengerSponge(pp);\n  return dm;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, out int iter) {\n  float it = df(ro);\n  float t = it;\n  int i = 0;\n  float mrl = MAX_RAY_LENGTH + it;\n  for (i = 0; i < MAX_RAY_MARCHES; i++) {\n    float d = df(ro + rd*t);\n    if (d < TOLERANCE || t > mrl) break;\n    t += d;\n  }\n  iter = i;\n  return t > mrl ? HIT_SKY : t;\n}\n\nvec3 normal(vec3 pos, float e) {\n  vec2  eps = vec2(e,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat softShadow(vec3 pos, vec3 ld, float ll, float mint, float k) {\n  const float minShadow = 0.25;\n  float res = 1.0;\n  float t = mint;\n  for (int i=0; i<24; i++) {\n    float distance = df(pos + ld*t);\n    res = min(res, k*distance/t);\n    if (ll <= t) break;\n    if(res <= minShadow) break;\n    t += max(mint*0.2, distance);\n  }\n  return clamp(res,minShadow,1.0);\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(1.0/2.2)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 skyCol = skyColor(ro, rd);\n\n  int iter = 0;\n  float id = df(ro);\n  float t = rayMarch(ro, rd, iter);\n\n  float ifade = 1.0-tanh_approx(3.0*float(iter)/float(MAX_RAY_MARCHES));\n\n  vec3 pos = ro + t*rd;    \n\n  minda = 1E6;\n  vec3 nor = normal(pos,0.00001+t*0.00075);\n  float mind = 1.0;\n\n  vec3 color = vec3(0.0);\n  \n  float sd = sphered(ro, rd, glowSphere, t);\n\n  if (t < HIT_SKY) {\n    // Ray intersected object\n    color = baseCol*tanh_approx(2.5*max(minda*minda, 0.0));\n  } else {\n    // Ray intersected sky\n    return mix(skyCol*sqrt(ifade), glowCol, sd);\n  }\n\n  vec3 ld1   = sunDirection;\n  vec3 ld2   = smallSunDirection;\n\n  float sha = softShadow(pos, ld1, 4.0, 0.01, 64.0);\n\n  float dif1 = max(dot(nor,ld1),0.0);\n  float spe1 = pow(max(dot(reflect(rd, nor), ld1), 0.), 10.);\n  float lin1 = mix(0.2, 1.0, dif1*sha);\n\n  float dif2 = max(dot(nor,ld2),0.0);\n  float spe2 = pow(max(dot(reflect(rd, nor), ld2), 0.), 10.);\n  float lin2 = mix(0.1, 1.0, dif1*sha);\n\n  vec3 col = vec3(0.0);\n  col += sunColor1*lin1*color;\n  col += sunColor2*lin2*color;\n  col *= 0.5;\n  col += sunColor1*spe1*sha;\n  col += sunColor2*spe2*sha;\n  \n  const float minds = 2.0;\n  col = mix(mix(0.1*col, col, 1.0-mind), col, tanh_approx(minds*abs(minda*minds))/minds);\n\n  col = col*ifade;\n  \n  col = mix(col, glowCol, sd);\n  \n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q=fragCoord.xy/iResolution.xy; \n  vec2 p = -1.0 + 2.0*q;\n  p.x *= iResolution.x/iResolution.y;\n\n  vec3 ro = vec3(3, 3.0, -9.0);\n  vec3 la = center;\n  vec3 up = vec3(0.0, 1.0, 0.0);\n  \n  switch(PERIODN) {\n  case 0:\n    ro *= 0.25+0.05*PERIODTIME/PERIOD;\n    ro.xz *= ROT(PERIODTIME/PERIOD);\n    break;\n  case 1:\n    ro *= 1.0-0.6*PERIODTIME/PERIOD;\n    ro.xz *= ROT(1.0+PERIODTIME/PERIOD);\n    ro.xy *= ROT(-0.5*PERIODTIME/PERIOD);\n    break;\n  case 2:\n    ro = vec3(5.0-15.0*PERIODTIME/PERIOD, -3.0+6.0*PERIODTIME/PERIOD, 30.0-40.0*PERIODTIME/PERIOD);\n    break;\n  default:\n    break;\n  }\n  \n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.5*ww );\n\n  vec3 col = render(ro, rd);\n  \n  col *= smoothstep(0.0, FADE, PERIODTIME);\n  col *= 1.0-smoothstep(PERIOD-FADE, PERIOD, PERIODTIME);\n\n  fragColor = vec4(postProcess(col, q),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtcfDB.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[0, 1764, 1822, 1822, 2303], [2305, 2305, 2333, 2353, 2429], [2431, 2431, 2462, 2462, 2488], [2490, 2490, 2517, 2517, 2604], [2606, 2606, 2633, 2633, 2730], [2732, 2732, 2774, 2774, 2821], [2823, 2823, 2876, 2876, 3073], [3075, 3075, 3121, 3121, 4578], [4580, 4580, 4613, 4613, 4994], [4996, 4996, 5029, 5029, 5157], [5179, 5179, 5207, 5207, 5955], [5957, 5957, 5975, 5975, 6149], [6151, 6151, 6199, 6199, 6458], [6460, 6460, 6492, 6492, 6693], [6695, 6695, 6763, 6763, 7063], [7065, 7065, 7102, 7102, 7354], [7356, 7356, 7387, 7387, 8708], [8710, 8710, 8765, 8765, 9704]], "test": "error"}
{"id": "wtcfRB", "name": "Nobody Puts Blobby In The Corner", "author": "jjmsteen", "description": "Using barycentric coordinates and products of those coordinates' components to create a nice blob in the middle of a triangle\n\nUses some code from https://www.shadertoy.com/view/lsl3Wn, thanks!", "tags": ["blob", "barycentric"], "likes": 3, "viewed": 66, "published": "Public", "date": "1612957157", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 bary(in vec3 v0, in vec3 v1, in vec3 v2, in vec3 p, in vec3 normal)\n{\n\tfloat area = dot(cross(v1 - v0, v2 - v0), normal);\n\t\n\tif(abs(area) < 0.0001) {\n\t\treturn vec3(0.0, 0.0, 0.0);\n\t}\n\t\n\tvec3 pv0 = v0 - p;\n\tvec3 pv1 = v1 - p;\n\tvec3 pv2 = v2 - p;\n\t\n\tvec3 asub = vec3(dot(cross(pv1, pv2), normal),\n\t\t\t\t\t dot(cross(pv2, pv0), normal),\n\t\t\t\t\t dot(cross(pv0, pv1), normal));\n\treturn abs(asub) / vec3(abs(area)).xxx;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 aspect = vec2(iResolution.x / iResolution.y, 1.0);\n\tvec3 v0 = vec3(0.0, 0.7, 0.0) * aspect.xyy;\n\tvec3 v1 = vec3(0.5, -0.6, 0.0) * aspect.xyy;\n\tvec3 v2 = vec3(-0.5, -0.5, 0.0) * aspect.xyy;\n    vec3 v3 = vec3(0.6, 0.65, 0.0) * aspect.xyy;\n\n    vec2 uv = (2.0 * fragCoord.xy / iResolution.xy - 1.0) * aspect;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec3 t0bc = bary(v0, v1, v2, vec3(uv, 0.0), vec3(0.0, 0.0, 1.0));\n    float t0bcSum = t0bc.x + t0bc.y + t0bc.z;\n    float t0bcProd = t0bc.x * t0bc.y * t0bc.z;\n    \n    vec3 t1bc = bary(v0, v3, v1, vec3(uv, 0.0), vec3(0.0, 0.0, 1.0));\n    float t1bcSum = t1bc.x + t1bc.y + t1bc.z;\n    float t1bcProd = t1bc.x * t1bc.y * t1bc.z;\n\n    vec3 backgroundCol = vec3(0.3, 0.3, 0.3);\n    \n    // Outside triangle 0 - background\n    if(t0bcSum > 1.00001 && t1bcSum > 1.0001) {\n\t\tcol = backgroundCol;\n\t}\n    // Exaggerated triangle boundary\n    else if (any(lessThanEqual(t0bc, vec3(0.01)))\n          || any(lessThanEqual(t1bc, vec3(0.01)))) {\n        col = vec3(1.0);\n    }\n    else {//if (any(lessThanEqual(bc, vec3(0.1)))) {\n        //col = backgroundCol;\n        \n        float comparator = 0.015;\n        \n        if(t0bcProd < comparator || t1bcProd < comparator) {\n            col = backgroundCol;\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtcfRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 74, 74, 415], [417, 417, 474, 474, 1855]], "test": "valid"}
{"id": "WtcfWS", "name": "T-Virus", "author": "dean_the_coder", "description": "A quick and simple scene inspired by the Resident Evil movie, with a fair bit of artistic license thrown in.\nNeeearly 4Kb...", "tags": ["3d", "raymarching", "evil", "umbrella", "movie", "resident", "cineshader"], "likes": 13, "viewed": 2289, "published": "Public API", "date": "1613321333", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 'T-Virus' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/WtcfWS\n//\n// Audio: https://soundcloud.com/chrisse/resident-evil-main-extended\n//\n// A quick and simple scene inspired by the Resident Evil\n// movie, with a fair bit of artistic license thrown in.\n//\n// I think in the future I'll spend some time trying\n// to improve my raymarching code when it has reflection\n// and refraction. I suspect there's a more performant\n// method.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\n// and a bunch of others for sharing their knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define BLUE vec3(.01, .48, .83)\n\n#define Z0 min(iTime, 0.)\n\nfloat T;\nbool inFluid;\n\n// #define AA\t// Enable this line if your GPU can take it!\n\nstruct Hit {\n\tfloat d; // SDF Distance\n\tint id;  // Material ID\n};\n\nfloat h31(vec3 p3)\n{\n\tp3 = fract(p3 * .1031);\n\tp3 += dot(p3, p3.yzx + 3.3456);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n\nvoid minH(inout Hit a, Hit b) {\n\tif (b.d < a.d) a = b;\n}\n\nmat2 rot(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nvec2 opModPolar(vec2 p, float n, float o)\n{\n\tfloat t = 3.141 / n,\n\t\t  a = mod(atan(p.y, p.x) + t + o, 2. * t) - t;\n\treturn length(p) * vec2(cos(a), sin(a));\n}\n\nfloat sdCyl(vec3 p, vec2 hr) {\n\tvec2 d = abs(vec2(length(p.xz), p.y)) - hr;\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat sdTwist(vec3 p, vec2 r, float g, float o) {\n\tfloat gb2 = g * .5,\n\t\t  a = abs((atan(p.x, p.z) + 3.141 * o) * gb2 - mod(p.y, 3.141 * g));\n\treturn length(vec2(length(p.xz) - r.x, a > 3.141 * gb2 ? 3.141 * g - a : a)) - r.y;\n}\n\nvec3 rayDir(vec3 ro, vec3 at, vec2 uv) {\n\tvec3 f = normalize(at - ro),\n\t\t r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nfloat bblz(vec3 p) {\n\tp.x += sin(T * .2 + floor(p.z) * 22.34) * .4;\n\tp.y -= (T + 1.23) * (.3 + h31(floor(p.xzx)));\n\treturn max(length(fract(p - .1) - .5) - mix(.02, .1, h31(floor(p))), length(p.xz) - 6.);\n}\n\nfloat helix(vec3 p) {\n\tp.xz *= rot(1.57);\n\treturn min(sdTwist(p, vec2(4.8, 1), 3., 1.), sdTwist(p, vec2(4.8, 1), 3., 2.));\n}\n\nHit tube(vec3 p) {\n\tHit cyl = Hit(sdCyl(p, vec2(8, 18)), 3);\n\tif (cyl.d > 5.) return cyl;\n\n\tHit h = Hit(max(helix(p), cyl.d), 2);\n\n\tcyl.d = max(cyl.d - .5, abs(abs(p.y) - 18.) - 5.);\n\tminH(h, cyl);\n\n\treturn h;\n}\n\nvec3 tube2Map(vec3 p) {\n\tp.xz *= rot(.4);\n\tp.x -= 30.;\n\tp.y += 9.5;\n\tp.yz *= rot(1.57);\n\treturn p;\n}\n\nHit glass(vec3 p) {\n\tvec2 v = vec2(8, 13);\n\treturn Hit(min(sdCyl(p, v), sdCyl(tube2Map(p), v)), 4);\n}\n\nHit tubez(vec3 p) {\n\tHit h = tube(p);\n\tminH(h, tube(tube2Map(p)));\n\treturn h;\n}\n\nHit map(vec3 p) {\n\tif (inFluid)\n\t\treturn Hit(bblz(p), 1);\n\n\tHit h = Hit(abs(p.y + 18.5), 5);\n\tminH(h, tubez(p));\n\tminH(h, Hit(140. - length(p.xz), 6));\n\n\treturn h;\n}\n\nvec3 logo(vec3 p) {\n\tfloat a = atan(p.x, p.z) + 3.14;\n\n\tp.xz = opModPolar(p.xz, 8., .4);\n\tp.x -= 140.;\n\n\tvec3 rw = mix(vec3(1, 0, 0), vec3(1), mod(floor(a * 1.27), 2.));\n\treturn mix(vec3(.2), rw, step(80., length(p.xz)));\n}\n\nvec3 calcN(vec3 p, float t) {\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .0026 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * t).d;\n\t}\n\n\treturn normalize(n);\n}\n\nvec3 glassN(vec3 p, float t) {\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .0026 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * glass(p + e * t).d;\n\t}\n\n\treturn normalize(n);\n}\n\nfloat calcShadow(vec3 p, vec3 ld) {\n\t// Thanks iq.\n\tfloat s = 1., t = .1;\n\tfor (float i = Z0; i < 30.; i++)\n\t{\n\t\tfloat h = tubez(t * ld + p).d;\n\t\ts = min(s, 20. * h / t);\n\t\tt += h;\n\t\tif (s < .01 || t > 25.) break;\n\t}\n\n\treturn clamp(s, 0., 1.);\n}\n\n// Quick ambient occlusion.\nfloat ao(vec3 p, vec3 n, float h) {\n\tp += n * h;\n\treturn clamp(min(glass(p).d, map(p).d) / h, 0., 1.);\n}\n\n/**********************************************************************************/\n\nvec3 vignette(vec3 c, vec2 fc) {\n\tvec2 q = fc.xy / iResolution.xy;\n\tc *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn c;\n}\n\nvec3 lights(vec3 p, vec3 rd, float d, Hit h) {\n\tvec3 ld = normalize(vec3(6, 3, -10) - p),\n\t\t n = h.id == 4 ? glassN(p, d) : calcN(p, d),\n\t\t c = vec3(0);\n\tfloat ss = 0.;\n\n\tif (h.id == 1)\n\t\tc = BLUE;\n\telse if (h.id == 2) {\n\t\tc = BLUE;\n\n\t\t// Sub-surface scattering.\n\t\tss = smoothstep(0., 1., tubez(3. * ld + p).d / 3.);\n\t} else if (h.id == 3)\n\t\tc = vec3(1);\n\telse if (h.id == 5)\n\t\tc = logo(p);\n\telse c = vec3(.05, .1, .15);\n\n\t// Primary light.\n\tfloat l1 = max(0., .1 + .9 * dot(ld, n)),\n\n\t// Secondary(/bounce) light.\n\tl2 = max(0., .1 + .9 * dot(ld * vec3(-1, 0, -1), n)),\n\n\t// Specular.\n\tspe = smoothstep(0., 1., pow(max(0., dot(rd, reflect(ld, n))), 30.)) * 10.;\n\n\t// Bubblez/glass.\n\tif (h.id == 1 || h.id == 4)\n\t\treturn c + l2 + (spe + l1) * .15;\n\n\t// Fresnel.\n\tfloat fre = smoothstep(.7, 1., 1. + dot(rd, n)) * .5,\n\t\t  _ao = dot(vec2(ao(p, n, .2), ao(p, n, 2.)), vec2(.4, .6));\n\n\tif (h.id == 6)\n\t\treturn c + (l1 + spe) * .02;\n\n\tl1 *= (.3 + .7 * calcShadow(p, ld)) // ...with shadow.\n\t\t  * (.3 + .7 * _ao); // ...and _some_ AO.\n\n\t// Combine into final color.\n\tfloat lig = l1 + (l2 * .3 + spe) * _ao + ss;\n\treturn mix(lig * c * vec3(2, 1.8, 1.7), vec3(.1), fre);\n}\n\nvec3 march(vec3 ro, vec3 rd, float x) {\n\t// Raymarch.\n\tvec3 p = ro,\n\t\t col = vec3(0);\n\n\tfloat md = -1., d = .01, o = 1.;\n\n\tif (inFluid) {\n\t\tfloat bubbleO = 1.;\n\t\tcol = BLUE;\n\t\tfor (float i = Z0; i < 40.; i++) {\n\t\t\tp = d * rd + ro;\n\t\t\tHit h = Hit(bblz(p), 1);\n\n\t\t\tif (d > 15.)\n\t\t\t\tbreak;\n\n\t\t\tif (abs(h.d) < .0015) {\n\t\t\t\t// Not physically accurate, but looks ok.\n\t\t\t\td++;\n\t\t\t\tcol += lights(p, rd, d, h) * .3 * bubbleO;\n\t\t\t\tbubbleO *= .25;\n\t\t\t}\n\n\t\t\td += h.d; // No hit, so keep marching.\n\t\t}\n\n\t\treturn col;\n\t}\n\n\tbool inGlass = false;\n\tfloat shine = 0.;\n\tfor (float i = Z0; i < 140.; i++) {\n\t\tp = d * rd + ro;\n\t\tHit gh, h = map(p);\n\n\t\tif (abs(h.d) < .0015) {\n\t\t\tcol += (lights(p, rd, d, h) + shine) * o;\n\t\t\tif (md < 0.)\n\t\t\t\tmd = d;\n\t\t\telse\n\t\t\t\tbreak;\n\n\t\t\to *= h.id == 6 ? .02 : .1;\n\t\t\tro = p;\n\t\t\trd = reflect(rd, calcN(ro, d));\n\t\t\td = .5;\n\t\t} else if (!inGlass && (gh = glass(p)).d < .0015) {\n\t\t\tinGlass = true;\n\t\t\tshine = lights(p, rd, d, gh).r;\n\t\t\tro = p + gh.d * rd;\n\t\t\trd = refract(rd, glassN(ro, d), .8);\n\t\t\td = .5;\n\t\t\tcontinue;\n\t\t}\n\n\t\td += h.d; // No hit, so keep marching.\n\t}\n\n\treturn col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc)\n{\n\tT = iTime;\n\n\tfloat ph = smoothstep(16., 22., T) - smoothstep(40., 50., T);\n\tvec3 lookAt = mix(vec3(0, 2, 0), vec3(30, -5, 0), ph);\n\tfloat m = max((cos((T - 13.) * .25) + 1.) / 2., .01);\n\tvec3 ro = vec3(m * m * 40., 2. + m * m * 25., -2. - 60. * m)\n\t\t\t  - vec3(40, -25, 40) * ph;\n\n\tinFluid = length(ro.xz) < 6.5;\n\n\tvec2 uv = (fc - .5 * iResolution.xy) / iResolution.y;\n\tvec3 col = march(ro, rayDir(ro, lookAt, uv), uv.x);\n\n#ifdef AA\n    // My attempt at 'quick' anti-aliasing...\n\tif (length(fwidth(col)) > .08) {\n\t\tfor (float dx = Z0; dx <= 1.; dx++)\n\t\t\tfor (float dy = Z0; dy <= 1.; dy++)\n\t\t\t\tcol += march(ro, rayDir(ro, lookAt, uv + (vec2(dx, dy) - .5) / iResolution.xy), uv.x);\n\n\t\tcol /= 5.;\n\t}\n#endif\n\n\tfragColor = vec4(vignette(pow(col * min(iTime, 1.), vec3(.45)), fc), 0);\n}\n", "image_inputs": [{"id": "MtXSzM", "previewfilepath": "https://soundcloud.com/chrisse/resident-evil-main-extended", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/chrisse/resident-evil-main-extended", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtcfWS.jpg", "access": "shaders20k", "license": "artistic-2.0", "functions": [[752, 880, 900, 900, 997], [999, 999, 1030, 1030, 1055], [1057, 1057, 1076, 1076, 1136], [1138, 1138, 1181, 1181, 1296], [1298, 1298, 1328, 1328, 1428], [1430, 1430, 1479, 1479, 1658], [1660, 1660, 1700, 1700, 1829], [1831, 1831, 1851, 1851, 2037], [2039, 2039, 2060, 2060, 2163], [2165, 2165, 2183, 2183, 2376], [2378, 2378, 2401, 2401, 2478], [2480, 2480, 2499, 2499, 2581], [2583, 2583, 2602, 2602, 2662], [2664, 2664, 2681, 2681, 2829], [2831, 2831, 2850, 2850, 3054], [3056, 3056, 3085, 3085, 3283], [3285, 3285, 3315, 3315, 3515], [3517, 3517, 3552, 3567, 3762], [3764, 3792, 3827, 3827, 3896], [3898, 3984, 4016, 4016, 4131], [4133, 4133, 4179, 4179, 5296], [5298, 5298, 5337, 5351, 6392], [6394, 6394, 6439, 6439, 7221]], "test": "valid"}
{"id": "wtcfz8", "name": "Neural clothes 3d", "author": "iuryBorgesRodrigues", "description": "Neural clothes 3d", "tags": ["sdf", "neural", "clothes"], "likes": 4, "viewed": 108, "published": "Public", "date": "1612208895", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//like the last few shaders I've published, this is a neural network experiment.\n//this time, the neural network reproduces an SDF given the x,y,z coordinates\n//using siren networks with skip connections: https://vsitzmann.github.io/siren/\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\nfloat smax( float d1, float d2, float k )\n{\n    float h = max(k-abs(-d1-d2),0.0);\n    return max(-d1, d2) + h*h*0.25/k;\n\t//float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n\t//return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat smin( float d1, float d2, float k )\n{\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n\t//float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n\t//return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat scene(vec3 p) {\n    //sdf is undefined outside the unit sphere, uncomment to witness the abominations\n    if (length(p) > 1.) {\n        return length(p)-0.9;\n    }\n    \n    //neural networks can be really compact... when they want to be\n   vec4 f0_0=sin(p.y*vec4(-3.043,-.393,.869,-1.995)+p.z*vec4(-.417,-1.409,-1.252,-3.029)+p.x*vec4(1.519,-.251,-2.510,1.232)+vec4(1.795,-5.318,4.642,-3.404));\nvec4 f0_1=sin(p.y*vec4(-2.001,1.483,-1.080,.599)+p.z*vec4(-.516,-1.032,.658,2.989)+p.x*vec4(-3.106,1.587,1.558,.450)+vec4(-.764,6.521,-6.044,-2.375));\nvec4 f0_2=sin(p.y*vec4(-1.168,3.040,-2.926,.911)+p.z*vec4(1.965,-3.790,1.906,3.849)+p.x*vec4(-1.151,-1.834,-2.789,.576)+vec4(.133,3.795,8.209,1.911));\nvec4 f0_3=sin(p.y*vec4(-.366,-3.850,-.871,-2.136)+p.z*vec4(-.420,.204,-2.406,-3.245)+p.x*vec4(2.844,-1.442,-1.793,-3.235)+vec4(-1.792,4.750,6.307,-4.889));\nvec4 f1_0=sin(mat4(.894,-.962,-.027,.033,-.170,-.654,-.789,-.188,-.364,.060,.099,-1.014,-.888,.508,.109,.096)*f0_0+\n    mat4(-.124,.011,.568,-.203,-.588,-.483,.035,.088,.691,-.578,.003,1.285,-.194,.920,.306,-.004)*f0_1+\n    mat4(-.360,.218,.074,.599,-.384,-.103,-.095,.110,-.247,-.342,.125,-.150,.218,.694,.570,1.176)*f0_2+\n    mat4(-.186,1.158,.026,1.227,.036,.242,-.164,.161,1.029,.002,.037,-.363,.240,-.032,-.227,-.303)*f0_3+\n    vec4(-3.052,.295,.903,-1.355))/1.0+f0_0;\nvec4 f1_1=sin(mat4(-.037,.276,-.177,.360,-.419,.864,-.031,.820,-.040,-.088,-.101,.683,-.182,-.132,.269,-1.170)*f0_0+\n    mat4(.110,-.151,.084,.196,-.866,-.053,-.199,-.822,.716,-.100,-.653,-.506,.922,-.344,.523,.646)*f0_1+\n    mat4(.691,-.329,-.051,-.717,.063,-.422,-.246,-.913,-.351,-.008,-.180,-.335,.301,.372,.102,1.258)*f0_2+\n    mat4(-.120,-.512,.398,-.329,-.243,-.466,-.058,-.596,.003,-.091,.517,.862,-.195,.290,.364,.299)*f0_3+\n    vec4(-.411,-1.364,-2.518,2.061))/1.0+f0_1;\nvec4 f1_2=sin(mat4(.125,-.243,-.454,-.469,-.054,.902,.018,.932,-.086,-.255,-.288,-.741,-.393,.118,.684,1.130)*f0_0+\n    mat4(.573,.040,-.062,-.090,-.378,-.138,-.019,.999,.038,-.514,.307,.373,-.153,-1.723,-.179,-1.284)*f0_1+\n    mat4(.516,-.259,.594,.794,-.208,.308,.397,1.036,.114,.404,-.330,.490,-.213,-1.270,-.403,-1.953)*f0_2+\n    mat4(-.375,.158,.132,.431,-.181,.207,.067,.648,-.030,-.688,-.794,-1.129,.286,-.038,-.193,-.250)*f0_3+\n    vec4(-.967,1.241,-1.499,-3.799))/1.0+f0_2;\nvec4 f1_3=sin(mat4(.956,.964,-.010,.677,-1.148,-1.695,-.143,.175,.883,-.676,.122,1.453,-1.097,-.661,-.409,-.305)*f0_0+\n    mat4(-.034,.760,.320,-.277,-1.062,.051,-.400,-.101,-.348,-.268,.626,.565,1.351,.062,.606,-1.338)*f0_1+\n    mat4(-.634,-.408,.240,-.565,-.936,.066,-.050,.037,-.139,.440,-.108,.428,1.533,.297,.595,-1.483)*f0_2+\n    mat4(-.588,.185,-.664,-.968,-.619,-1.090,-.044,.075,.760,.803,-.305,-.060,.019,.577,-.098,.056)*f0_3+\n    vec4(2.337,-2.361,1.797,1.739))/1.0+f0_3;\nvec4 f2_0=sin(mat4(.583,.025,.586,.709,.678,-.301,-.025,.455,-.316,.205,.437,-.708,.163,.226,.115,.037)*f1_0+\n    mat4(.342,.263,.145,.387,.144,1.296,-.022,1.120,1.264,-1.575,.125,-.908,.517,-2.593,-1.753,-.810)*f1_1+\n    mat4(.107,1.517,.437,.831,-.180,1.313,.588,.141,.244,.925,.311,.233,.482,-2.037,-1.796,-.708)*f1_2+\n    mat4(.051,1.455,.833,.713,-.596,1.189,.318,.041,-.798,-.295,-.140,-.252,.236,-.802,-.165,-.151)*f1_3+\n    vec4(2.588,-2.844,-1.694,-.162))/1.4+f1_0;\nvec4 f2_1=sin(mat4(-.016,.088,-.334,.214,-.118,.743,-1.079,-.433,-.321,-1.362,-.664,.312,-1.385,-.062,.382,.004)*f1_0+\n    mat4(-.134,.049,.657,-.248,-.254,.855,1.010,-.181,-.230,.605,-.805,.688,-1.079,-1.055,-.664,.215)*f1_1+\n    mat4(-.241,-.151,.345,.927,.185,.120,.035,.013,-.756,.286,.414,-.188,-.630,-.985,-.422,.373)*f1_2+\n    mat4(.847,.656,.694,-.151,.295,.316,.747,.171,.070,.098,.232,-.262,-.134,-.430,-.609,.071)*f1_3+\n    vec4(-2.479,-1.096,2.595,-1.178))/1.4+f1_1;\nvec4 f2_2=sin(mat4(.016,.732,-.014,-.308,.220,-1.114,-.252,-.178,-.692,-.690,.668,-.113,.112,-.209,.235,.464)*f1_0+\n    mat4(.525,-.082,.614,.134,1.573,1.424,.137,-1.053,.161,-1.552,-.291,-.483,-4.279,-1.798,.686,1.084)*f1_1+\n    mat4(.682,-.386,.089,.095,1.538,.430,-.987,-.427,1.281,.143,.190,-.005,-3.874,-1.463,.932,1.140)*f1_2+\n    mat4(2.269,1.057,-.536,-.697,1.265,.597,-.126,-.388,.407,-.375,-.390,.629,-.609,-.812,.472,.102)*f1_3+\n    vec4(.441,-3.570,-1.204,-.728))/1.4+f1_2;\nvec4 f2_3=sin(mat4(-.538,.394,.429,.127,-.230,.070,.045,.641,.290,.200,-.361,-.181,.631,.963,-.040,.128)*f1_0+\n    mat4(-.732,1.136,.296,.123,-.561,.083,.795,1.425,-.865,-.257,.182,.984,2.387,.772,-3.162,-.529)*f1_1+\n    mat4(.282,-.102,.470,1.088,-.672,-.800,1.181,.897,-.412,.436,.958,-.449,2.201,.612,-3.065,-.547)*f1_2+\n    mat4(-1.150,.335,1.710,-.334,-.419,.575,.850,.502,.892,1.301,.201,.509,.105,.340,-.475,-.104)*f1_3+\n    vec4(3.366,-.390,.914,.320))/1.4+f1_3;\n\n\nfloat corte1=sdBox(p+vec3(-0.2,0.0,0.0),vec3(0.4,0.2,0.9));\n\n\n\nfloat d=dot(f2_0,vec4(.099,.105,.126,-.160))+\n    dot(f2_1,vec4(-.064,-.100,.130,-.133))+\n    dot(f2_2,vec4(-.097,.066,-.079,-.136))+\n    dot(f2_3,vec4(.094,.050,.135,.042))+\n    -0.092;\n    \n    \n    d=smax(corte1,d,0.1);\n\n\nreturn d;\n\n\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 cam = normalize(vec3(1.5,uv));\n    vec3 init = vec3(-3.,0,0);\n    \n    float yrot = 0.5;\n    float zrot = iTime*.2;\n    if (iMouse.z > 0.) {\n        yrot += -4.*mouse.y;\n        zrot = 4.*mouse.x;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n    \n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 150 && !hit; i++) {\n        float dist = scene(p/vec3(1.0))-0.017;\n        hit = dist*dist < 1e-6;\n        p+=dist*cam;\n        if (distance(p,init)>5.) break;\n    }\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    //don't ask how I stumbled on this texture\n    vec3 nz = p - erot(p, vec3(1), 2.) + erot(p, vec3(1), 4.);\n    float spec = length(sin(r*3.5+sin(nz*120.)*.15)*.4+.6)/sqrt(3.);\n    spec *= smoothstep(-.3,.2,scene(p+r*.2));\n    vec3 col = vec3(.1,.1,.12)*spec + pow(spec,8.);\n    float bgdot = length(sin(cam*8.)*.4+.6)/2.;\n    vec3 bg = vec3(.1,.1,.11) * bgdot + pow(bgdot, 10.);\n    fragColor.xyz = hit ? col : bg;\n    fragColor = smoothstep(-.02,1.05,sqrt(fragColor)) * (1.- dot(uv,uv)*.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtcfz8.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[194, 435, 473, 473, 535], [536, 536, 579, 579, 753], [755, 755, 798, 798, 969], [972, 972, 1003, 1003, 1090], [1092, 1092, 1113, 1199, 6087], [6089, 6089, 6108, 6108, 6224], [6226, 6226, 6283, 6283, 7567]], "test": "valid"}
{"id": "Wtcfzl", "name": "RotoPlasma", "author": "workingclasshacker", "description": "a simple 2d plasma effect using trig to manipulate colors and motion.", "tags": ["2d", "plasma"], "likes": 2, "viewed": 56, "published": "Public", "date": "1613220046", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float grid_rotation = 1.;\nfloat grid_distort = 0.1;\nfloat grid_resolution = .4;\n\nvec2 rotate(vec2 v, float a) {\n    return vec2(v.x*cos(a) + v.y*sin(a), -v.x*sin(a) + v.y*cos(a));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float aspect_ratio = iResolution.x / iResolution.y;\n    grid_rotation = (tan(.5*iTime)+1.0)/2.;\n    grid_resolution = 2.*cos(2.*iTime);\n    vec2 coord = (2.* fragCoord.xy / iResolution.xy - 1.) * vec2(aspect_ratio, 1.);\n    grid_distort = pow(sin(iTime),2.)+pow(cos(iTime),2.);\n    coord *= grid_resolution;\n    \n    coord = rotate(coord, grid_rotation*(1.+grid_distort*length(coord)));\n    \n    float grid_factor = cos(coord.x*10.) * cos(coord.y*10.)*sin(iTime);\n\n    vec3 color = mix(vec3((1.+sin(5.*iTime))/2., (1.0+cos(.5*iTime))/2., (1.+sin(iTime))/2.), vec3(.0, sin(2.*iTime), cos(2.*iTime)), (1.+grid_factor)*0.5);\n    float ex = 2.2;\n    color = vec3(pow(color.x, ex), pow(color.y, ex), pow(color.z,ex));\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wtcfzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 111, 111, 181], [183, 183, 239, 239, 992]], "test": "valid"}
{"id": "wtcfzM", "name": "Torus - gradient 3D", "author": "iq", "description": "Computes the analytic gradient/normal of a torus SDF, which is much faster than doing it numerically (useful when the normal is needed inside the SDF evaluation itself or inside the raymarching loop for example).", "tags": ["3d", "sdf", "torus", "gradient", "normal", "analytic"], "likes": 16, "viewed": 449, "published": "Public API", "date": "1612442284", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// sdgTorus() returns the torus SDF and its gradient, by \n// computing it analytically. This means the normal to\n// the torus surface can be used during the raymarch loop\n// rather inexpensivelly (compared to sampling the SDF\n// multiple times to evaluate a normal for it)\n\n// Other SDF analytic gradients:\n//\n// Torus:   https://www.shadertoy.com/view/wtcfzM\n// Capsule: https://www.shadertoy.com/view/WttfR7\n\n\n// .x = f(p)\n// .y = ∂f(p)/∂x\n// .z = ∂f(p)/∂y\n// .w = ∂f(p)/∂z\n// .yzw = ∇f(p) with ‖∇f(p)‖ = 1\nvec4 sdgTorus( vec3 p, float ra, float rb )\n{\n    float h = length(p.xz);\n    return vec4( length(vec2(h-ra,p.y))-rb,\n                 normalize(p*vec3(h-ra,h,h-ra)) );\n}\n\n\n#define AA 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*(iTime-10.0);\n\tvec3 ro = 1.2*vec3( 1.0*cos(an), 0.65, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, -0.15, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n   \n    // animate torus\n    float ra = 0.5;\n    float rb = 0.2+0.1*sin(iTime);\n    \n    // render    \n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 5.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = sdgTorus(pos,ra,rb).x;\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = sdgTorus(pos,ra,rb).yzw;\n\n            // compute normal numerically, for comparison\n            // http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\n            #if 0\n            const vec2 e = vec2(1,-1);\n            const float eps = 0.0002;\n            nor = normalize( e.xyy*sdgTorus( pos + e.xyy*eps, ra, rb ).x + \n                             e.yyx*sdgTorus( pos + e.yyx*eps, ra, rb ).x + \n                             e.yxy*sdgTorus( pos + e.yxy*eps, ra, rb ).x + \n                             e.xxx*sdgTorus( pos + e.xxx*eps, ra, rb ).x );\n\n            #endif\n\n            float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.85,0.75,0.65)*dif;\n            col *= (0.5+0.5*nor)*(0.5+0.5*nor);\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtcfzM.jpg", "access": "shaders20k", "license": "mit", "functions": [[1490, 1607, 1652, 1652, 1777], [1794, 1794, 1851, 1876, 4125]], "test": "valid"}
{"id": "WtdBDM", "name": "Glass bubble lamp fork", "author": "jolle", "description": "Based on \"Glass bubble lamp\" by jarble https://www.shadertoy.com/view/ttcfD7\n\nTries to focus on the most interesting part, and overlaps two fractals so it has less empty space.", "tags": ["fractal"], "likes": 8, "viewed": 130, "published": "Public", "date": "1612870061", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Based on Glass bubble lamp by jarble https://www.shadertoy.com/view/ttcfD7\n\n// Tries to focus on the most interesting part,\n// and overlaps two fractals so it has less empty space\n\nconst float pi = 3.14159265359;\nconst float t = 9.0;\n\nvec4 fractal(vec2 v, float ph1, float ph2)\n{\n    vec2 u = v * dot(v, v);\n    vec4 sum = vec4(0.);\n    for (float i = 0.; i < t; ++i)\n    {\n        u = cos(u.y-vec2(.0,.5*pi))*exp(sin(u.x+ph1)+cos(u.y+ph2));\n        u+= v;\n        sum += (.5+.5*cos(i*4.+vec4(0,1,2,0)))/length(u);\n    }\n    return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u = 1.25*(2.*fragCoord.xy-iResolution.xy)/iResolution.y * vec2(-1.0, 1.0);\n    float ph1 = iTime * 0.6;\n    float ph2 = sin(iTime * 0.31) * 0.3;\n    fragColor = sqrt(fractal(u, ph1, ph2) + fractal(u, ph1 + pi, ph2)) * 0.25 - 0.25;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtdBDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[79, 238, 282, 282, 541], [543, 543, 600, 600, 842]], "test": "valid"}
{"id": "wtdBWl", "name": "some cellular noise", "author": "cody_shader", "description": ". ", "tags": ["noise"], "likes": 7, "viewed": 140, "published": "Public", "date": "1613692030", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return fract(abs(sin(st)*43758.5453123));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord/iResolution.y;\n    st.y -= iTime*0.1;\n    \n    const float scale = 10.;\n    st *= scale;\n\n    vec2 i_st = floor(st);\n    vec2 f_st = fract(st);\n    \n    vec2 m_dist = vec2(100.0);\n\n    for (int y= -1; y <= 1; y++) {\n        for (int x= -1; x <= 1; x++) {\n            vec2 neighbor = vec2(float(x),float(y));\n            vec2 point = random2(i_st + neighbor);\n            point = 0.5+0.5*sin(iTime + 6.2831*point);\n            vec2 diff = neighbor + point - f_st; \n            float dist = length(diff);\n            \n            if ( dist < m_dist.x || dist < m_dist.y) {\n                if (m_dist.x > m_dist.y) m_dist.x = dist;\n                else m_dist.y = dist;\n            }\n        }\n    }\n    \n    float min_dist = min(m_dist.x, m_dist.y);\n    float max_dist = max(m_dist.x, m_dist.y);\n    \n    float col1 = float(max_dist-min_dist);\n    float col2 = float(min_dist*max_dist);\n    float col3 = float(cos(max_dist)-sin(min_dist));\n    float col4 = float(17.-st.x-min_dist*15.0);\n    float col5 = float(st.x-(min_dist/max_dist)*15.0);\n    float col6 = float((0.5+0.5*sin((cos(max_dist)-sin(min_dist))*20.0)));\n    \n    float m1 = mix(col1, col2, .5+.2*sin(iTime*0.7));\n    float m2 = mix(col3, col4, .5+.2*sin(iTime*1.3));\n    float m3 = mix(col5, col6, .5+.2*sin(iTime*1.9));\n    float m4 = mix(col4, m2, m3);\n     \n    vec3 col7 = vec3(m4,m3,m2);\n    vec3 col8 = vec3(m2,m4,m1);\n    vec3 col9 = vec3(m1,m2,m3);\n    \n    vec3 col10 = mix(col7, col8, col7);\n    vec3 col = col10;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtdBWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 155], [157, 157, 214, 214, 1757]], "test": "valid"}
{"id": "wtdBWN", "name": "Formful", "author": "ruojake", "description": "Getting some serious mileage out of a 4D box. Press space to toggle rounding.", "tags": ["3d", "raymarching", "4d"], "likes": 8, "viewed": 200, "published": "Public API", "date": "1612821129", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Formful by Kristian Sivonen (ruojake)\n// CC BY-SA 4.0 (https://creativecommons.org/licenses/by-sa/4.0/)\n\nmat2 rot(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat box(in vec4 p, in vec4 b)\n{\n  vec4 d = abs(p) - b;\n  return length(max(d, 0.)) + min(max(d.x, max(d.y, max(d.z, d.w))), 0.);\n}\n\nfloat scene(in vec3 p)\n{\n    vec4 q = vec4(p, sin(dot(p.xz * 3., -p.yz) * .125 + iTime * .25) * .4);\n    q -= vec4(0,0,4,0);\n    float t = iTime * .03125;\n    q.xw *= rot(t);\n    q.yw *= rot(t*7.+q.w*.9);\n    q.zw *= rot(t*13.-q.w*.5);\n    q.xz *= rot(t*11.+q.y*.7);\n    \n    float r = texelFetch( iChannel0, ivec2(32,2), 0 ).x > 0.5 ? .003 : .06;\n    return box(q, vec4(2.5,2,1.5,.5)) * .15 - r;\n}\n\nvec3 normal(vec3 p)\n{\n\tfloat d = scene(p);\n    vec2 e = vec2(.002, .0);\n    return normalize(d - vec3(\n        scene(p - e.xyy),\n        scene(p - e.yxy),\n        scene(p - e.yyx)));\n}\n\nvec3 dither(vec2 p)\n{\n    float r = dot(vec3(p,float(iFrame % 60)), vec3(7., 11., 9.) / 13.);\n    return fract(vec3(r, r + .3334, r + .6667)) * 2. - 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n\n    vec3 ro = vec3(uv * .025, 0.);\n    vec3 rd = normalize(vec3(uv, .5));\n    float t = 1.4;\n    vec3 p;\n    float i = 0.;\n    \n    for(; i < 1. && t < 10.; i += 1./256.)\n    {\n        p = ro + rd * t;\n        float d = scene(p);\n        t += d;\n        if (abs(d) < .0025) break;\n    }\n\n    vec3 col = vec3(0);\n    if (t >= 10.)\n    {\n        col = vec3(.15 + uv.y * -.15, .35, .6) + smoothstep(.1, .8, i);\n    }\n    else\n    {\n        vec3 n = normal(p);\n        vec3 r = reflect(rd, n);\n        float refl = smoothstep(.8, .4, length(sin(r * 2.+ 2.)));   \n        float l = n.y * .4 + .7;\n        vec3 ao = mix(vec3(1), vec3(.3, .6, 1.) * .3, i * .8);\n        col = vec3(pow(refl,8.) * 2. + pow(l, 3.) * 4. * ao * mix(vec3(.35, .8, 0.), vec3(1., 1., .8), pow(l,9.) * .4));\n    }\n     \n    col = col * (1. + col / 20.) / (1. + col);\n    col = pow(col, vec3(1. / 2.2));\n\n    fragColor = vec4(col.rgb + dither(fragCoord) / 255., 1.0);\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtdBWN.jpg", "access": "shaders20k", "license": "cc-by-sa-4.0", "functions": [[0, 108, 127, 127, 203], [205, 205, 238, 238, 337], [339, 339, 363, 363, 737], [739, 739, 760, 760, 923], [925, 925, 946, 946, 1079], [1081, 1081, 1138, 1138, 2135]], "test": "error"}
{"id": "WtdBzH", "name": "Ray Marcher Simple", "author": "ArenaGrenade", "description": "A simple Ray marching shader.", "tags": ["raymarching"], "likes": 0, "viewed": 54, "published": "Public", "date": "1612256865", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST 0.01\n\nfloat signedDstToSphere(vec3 p, vec4 sphere) {\n    return length(sphere.xyz - p) - sphere.w;\n}\n\nfloat signedDstToBox(vec3 p, vec3 center, vec3 size) {\n    vec3 offset = abs(p - center) - size;\n    float unsignedDst = length(max(offset, 0.0));\n    float dstInsideBox = max(max(min(offset.x, 0.0), min(offset.y, 0.0)), min(offset.z, 0.0));\n    return unsignedDst + dstInsideBox;\n}\n\nfloat smoothMin(float dstA, float dstB, float k) {\n    float h = max(k - abs(dstA - dstB), 0.0) / k;\n    return min(dstA, dstB) - h * h * h * k * 1.0 / 6.0;\n}\n\nfloat GetDist(vec3 p) {    \n    float boxDist = signedDstToBox(p, vec3(-1, 1, 6), vec3(1, 1, 1));\n    float sphereDist = signedDstToSphere(p, vec4(1, 1, 6, 1));\n    float planeDist = p.y;\n    float d = smoothMin(smoothMin(sphereDist, planeDist, 0.0), smoothMin(boxDist, planeDist, 0.0), 0.0);\n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n    float d0 = 0.0;\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * d0;\n        float dS = GetDist(p);\n        d0 += dS;\n        \n        if (d0 > MAX_DIST || dS < SURF_DIST) break;\n    }\n    \n    return d0;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p);\n    vec2 e = vec2(0.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p - e.xyy),\n        GetDist(p - e.yxy),\n        GetDist(p - e.yyx)\n    );\n    \n    return normalize(n);\n}\n\nfloat GetLight (vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime)) * 2.0;\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    \n    float diff = clamp(dot(n, l), 0.0, 1.0);\n    \n    float d = RayMarch(p + n * SURF_DIST * 2.0, l);\n    if (d < length(lightPos - p)) diff *= 0.1;\n    \n    return diff;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 1, 0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d;\n    float diff = GetLight(p);\n    \n    col = vec3(diff);\n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtdBzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 115, 115, 163], [165, 165, 219, 219, 447], [449, 449, 499, 499, 607], [609, 609, 632, 632, 917], [920, 920, 954, 954, 1190], [1192, 1192, 1216, 1216, 1420], [1422, 1422, 1447, 1447, 1780], [1782, 1782, 1839, 1839, 2169]], "test": "valid"}
{"id": "wtdBzn", "name": "Neural  Monkey", "author": "iuryBorgesRodrigues", "description": "Monkey", "tags": ["monkey"], "likes": 4, "viewed": 199, "published": "Public", "date": "1612138139", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//like the last few shaders I've published, this is a neural network experiment.\n//this time, the neural network reproduces an SDF given the x,y,z coordinates\n//using siren networks with skip connections: https://vsitzmann.github.io/siren/\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat scene(vec3 p) {\n    //sdf is undefined outside the unit sphere, uncomment to witness the abominations\n    if (length(p) > 1.) {\n        return length(p)-.8;\n    }\n    //neural networks can be really compact... when they want to be\n    vec4 f0_0=sin(p.y*vec4(-.810,-.479,-1.629,2.114)+p.z*vec4(-1.353,3.836,.544,-.242)+p.x*vec4(-3.646,3.086,4.005,1.374)+vec4(5.029,-.860,-4.521,-7.561));\nvec4 f0_1=sin(p.y*vec4(.551,-3.838,-1.237,-3.779)+p.z*vec4(-2.141,-1.009,-.282,-.317)+p.x*vec4(-2.583,1.946,-.381,1.358)+vec4(8.011,-7.240,7.978,6.555));\nvec4 f0_2=sin(p.y*vec4(.292,.009,.083,-3.117)+p.z*vec4(2.295,1.412,-.507,-4.047)+p.x*vec4(-3.354,-1.616,-4.604,-1.501)+vec4(5.055,.519,3.222,3.231));\nvec4 f0_3=sin(p.y*vec4(.644,1.538,-1.473,-2.874)+p.z*vec4(2.361,-4.293,-1.496,3.907)+p.x*vec4(-.440,2.221,-2.129,-.953)+vec4(-2.102,7.426,-6.489,-2.261));\nvec4 f1_0=sin(mat4(.469,-.455,-.016,.000,.041,-.230,.641,.877,-.771,.400,.439,.275,.240,-.504,.618,.868)*f0_0+\n    mat4(.497,-.162,.044,.878,.289,-.741,.552,.162,.043,.296,.299,.988,.103,.027,.242,.600)*f0_1+\n    mat4(-.030,-.218,.097,.515,-1.296,.868,-.517,.854,.024,-.069,.573,.398,-.072,-.068,-.196,-.232)*f0_2+\n    mat4(-.913,.914,-.583,.229,.201,-1.052,-.087,-.908,-.354,-.067,.446,-.428,.458,.056,-.531,.221)*f0_3+\n    vec4(2.389,3.737,2.563,1.536))/1.0+f0_0;\nvec4 f1_1=sin(mat4(-.213,-.215,.364,-.477,-.218,-.111,.141,-.462,.724,-.350,-.379,.120,-.372,.407,-.094,1.104)*f0_0+\n    mat4(-.065,.780,.630,-.243,.039,-.759,-.154,.121,-.828,.536,.678,-.823,.513,.830,-.145,.553)*f0_1+\n    mat4(.764,.387,.054,-.431,-.049,.524,.044,.891,-.159,.182,.217,.611,.119,-.355,.228,.030)*f0_2+\n    mat4(.526,.020,-.521,-.366,-.465,.357,.082,-.368,.160,.649,-.506,-.260,.154,.482,.222,.393)*f0_3+\n    vec4(-.538,.688,-1.270,.721))/1.0+f0_1;\nvec4 f1_2=sin(mat4(-.587,-.235,.031,-.583,.384,.405,.167,.339,.778,-.499,-.311,-.154,-.279,1.064,-.609,-.058)*f0_0+\n    mat4(-.191,.059,.284,.086,-.658,.495,-.015,-.757,1.143,.597,.475,.298,-.124,-.505,-.401,-.212)*f0_1+\n    mat4(.221,.421,-.376,.462,.568,.661,.542,-.524,.471,-.726,-.520,.528,.069,.454,.352,.780)*f0_2+\n    mat4(.359,-.025,-.730,-.488,-.865,-.103,-.015,.098,.592,.204,.398,-.472,.072,.396,-.346,-.258)*f0_3+\n    vec4(3.503,3.117,1.734,-2.248))/1.0+f0_2;\nvec4 f1_3=sin(mat4(-.786,.057,.116,.141,-.233,-.241,.325,-.200,.092,-.531,-.053,.152,-.605,-.351,.413,-.274)*f0_0+\n    mat4(.104,-.249,.320,-.261,-.095,.060,.786,-.063,-.070,-.468,.052,-.558,-.557,.009,-.192,.280)*f0_1+\n    mat4(-.664,.297,-.124,.113,-.284,.734,.425,-.340,.081,-.133,-.049,-.209,-.310,.368,-.003,-.391)*f0_2+\n    mat4(.015,-.185,.427,-.442,.191,.139,-.420,-.262,.254,-.068,.632,.151,.395,-.000,.067,.670)*f0_3+\n    vec4(-3.185,1.715,3.541,1.726))/1.0+f0_3;\nvec4 f2_0=sin(mat4(-.876,-.128,.620,-.979,-.052,.201,.492,.232,-.393,-1.020,-.527,-.172,-.143,.127,.526,.223)*f1_0+\n    mat4(.643,.102,1.161,-.555,-.587,-1.253,.246,-.111,.884,-.944,-.620,.048,.468,-.753,-.040,-.534)*f1_1+\n    mat4(.257,-.309,.046,.005,-.313,1.355,-.042,-.088,-.046,-.452,.437,.431,.142,-.044,.253,-.020)*f1_2+\n    mat4(-.040,.884,-.167,.816,-.312,-.448,-.929,.809,.502,.072,.851,-1.144,.023,.736,-.080,.056)*f1_3+\n    vec4(3.092,-.379,-.619,3.235))/1.4+f1_0;\nvec4 f2_1=sin(mat4(.324,-.439,-.328,-.771,-.307,-.151,.168,.269,-.978,-1.237,.658,-.216,.229,-.954,-.225,-.464)*f1_0+\n    mat4(.514,.160,-.566,-.157,-.830,-.443,-.369,-.660,-1.208,1.357,.158,.107,.275,-.202,-.144,.006)*f1_1+\n    mat4(.757,-.337,-.144,-1.115,.723,.438,-.499,-.044,.046,-.262,.427,-.044,.183,.316,-.389,-.124)*f1_2+\n    mat4(-1.063,.047,-.112,.194,.351,-.459,-.209,-.313,-1.771,.433,-.779,.359,.213,.522,-.227,.788)*f1_3+\n    vec4(-1.385,-.939,-2.511,-.512))/1.4+f1_1;\nvec4 f2_2=sin(mat4(.562,.796,.458,-.584,-1.463,.710,.360,.128,.025,.451,-.141,.300,.276,.329,-.382,-.444)*f1_0+\n    mat4(.377,.319,-.050,.104,.513,-.419,-.201,-.242,.129,.014,-.087,.316,-.012,-.618,-.390,-.426)*f1_1+\n    mat4(.299,-.244,.703,-.758,.281,-.135,.835,.354,.241,-.139,.414,.848,-.815,.236,.800,.217)*f1_2+\n    mat4(.591,-.381,.696,.199,-.191,-.221,.618,-.531,-.554,.518,-.982,-.010,.194,.181,.784,-1.140)*f1_3+\n    vec4(3.316,.154,1.061,2.237))/1.4+f1_2;\nvec4 f2_3=sin(mat4(.052,-.589,-1.287,-.338,-.999,.079,.048,.152,-.585,.255,-.721,-.240,-.659,.360,-.016,-.408)*f1_0+\n    mat4(.186,.057,-.968,.225,.450,-1.048,-.710,.375,.821,-.730,-.037,.656,.333,.159,.292,.066)*f1_1+\n    mat4(.296,.372,-.202,-.562,.510,.041,.037,-.401,-.064,-.203,-.500,-.026,-.587,-.020,.603,-.177)*f1_2+\n    mat4(.758,.219,.271,-.131,-.116,-.485,.337,.013,-.380,-.716,-.644,.468,-.297,.552,1.275,-.132)*f1_3+\n    vec4(2.659,.165,-2.731,2.476))/1.4+f1_3;\nreturn dot(f2_0,vec4(.062,-.040,-.074,-.047))+\n    dot(f2_1,vec4(-.057,-.039,-.071,-.057))+\n    dot(f2_2,vec4(-.025,-.054,.044,.045))+\n    dot(f2_3,vec4(.048,.066,-.058,.100))+\n    0.102;\n\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 cam = normalize(vec3(1.5,uv));\n    vec3 init = vec3(-3.,0,0);\n    \n    float yrot = 0.5;\n    float zrot = iTime*.2;\n    if (iMouse.z > 0.) {\n        yrot += -4.*mouse.y;\n        zrot = 4.*mouse.x;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n    \n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 150 && !hit; i++) {\n        float dist = scene(p)-0.02;\n        hit = dist*dist < 1e-6;\n        p+=dist*cam;\n        if (distance(p,init)>5.) break;\n    }\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    //don't ask how I stumbled on this texture\n    vec3 nz = p - erot(p, vec3(1), 2.) + erot(p, vec3(1), 4.);\n    float spec = length(sin(r*3.5+sin(nz*120.)*.15)*.4+.6)/sqrt(3.);\n    spec *= smoothstep(-.3,.2,scene(p+r*.2));\n    vec3 col = vec3(.1,.1,.12)*spec + pow(spec,8.);\n    float bgdot = length(sin(cam*8.)*.4+.6)/2.;\n    vec3 bg = vec3(.1,.1,.11) * bgdot + pow(bgdot, 10.);\n    fragColor.xyz = hit ? col : bg;\n    fragColor = smoothstep(-.02,1.05,sqrt(fragColor)) * (1.- dot(uv,uv)*.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtdBzn.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[194, 435, 473, 473, 535], [537, 537, 558, 644, 5360], [5362, 5362, 5381, 5381, 5497], [5499, 5499, 5556, 5556, 6829]], "test": "valid"}
{"id": "WtdfDM", "name": "raymarchin", "author": "mtybadger", "description": "using a simple raymarcher to render the mandelbulb fractal \n\nmade by spruce :)", "tags": ["raymarching", "fractal"], "likes": 4, "viewed": 79, "published": "Public", "date": "1613175212", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Let's declare our Ray objects with an origin and a direction.\nstruct Ray { \n\tvec3 origin;\n\tvec3 dir;\n};\n    \n//boilerplate function for rotating points - I wrote one myself but it was much less impressive and concise than this so I replaced it.\n//still don't really get matrices but this takes a point and axes and does some magic. will come back later to figure this whole\n//matrix multiplication thing out.\nvec3 rotate( vec3 pos, float x, float y, float z )\n{\n\tmat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0, cos( x ), -sin( x ), 0.0, sin( x ), cos( x ) );\n\tmat3 rotY = mat3( cos( y ), 0.0, sin( y ), 0.0, 1.0, 0.0, -sin(y), 0.0, cos(y) );\n\tmat3 rotZ = mat3( cos( z ), -sin( z ), 0.0, sin( z ), cos( z ), 0.0, 0.0, 0.0, 1.0 );\n\n\treturn rotX * rotY * rotZ * pos;\n}\n\n//THIS is the actual mandelbulb formula - again still some reading to do but the point of this function, like any SDF, is to take\n//in a test point and figure out the distance to the fractal edge itself, positive or negative. \nfloat hit( vec3 r )\n{\n\tr = rotate( r, sin(iTime / 4.0), cos(iTime / 4.0), 0.0 );\n\tvec3 zn = vec3( r.xyz );\n\tfloat rad = 0.0;\n\tfloat hit = 0.0;\n\tfloat p = 8.0;\n\tfloat d = 1.0;\n\tfor( int i = 0; i < 10; i++ )\n\t{\n\t\t\n\t\t\trad = length( zn );\n\n\t\t\tif( rad > 2.0 )\n\t\t\t{\t\n\t\t\t\thit = 0.5 * log(rad) * rad / d;\n\t\t\t}else{\n\n\t\t\tfloat th = atan( length( zn.xy ), zn.z );\n\t\t\tfloat phi = atan( zn.y, zn.x );\t\t\n\t\t\tfloat rado = pow(rad,8.0);\n\t\t\td = pow(rad, 7.0) * 7.0 * d + 1.0;\n\t\t\t\n\n\n\t\t\tfloat sint = sin( th * p );\n\t\t\tzn.x = rado * sint * cos( phi * p );\n\t\t\tzn.y = rado * sint * sin( phi * p );\n\t\t\tzn.z = rado * cos( th * p ) ;\n\t\t\tzn += r;\n\t\t\t}\n\t\t\t\n\t}\n\t\n\treturn hit;\n}\n\n//Bridge between the fragment shader and the mandelbulb formula above: converts Rays to 3d vector points to test with. \nfloat distToScene(in Ray r) {\n    return hit(r.origin);\n}\n\nvec3 lerp(vec3 colorone, vec3 colortwo, float value)\n{\n\treturn (colorone + value*(colortwo-colorone));\n}\n\n//The actual fragment shader: this runs once for every pixel in the image\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //Normalize the pixel coords coming in and account for aspect ratio etc etc. \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.y *= iResolution.y / iResolution.x;\n    //The important part: Make a ray at 0,0 and slightly in front of the origin, and with a direction based on the pixel it's coming from\n\tRay ray = Ray(vec3(0.0, 0.0, -2.0 + (sin(iTime) * 0.5)), normalize(vec3(uv, 1.)));\n\tvec3 col = vec3(0.);\n    //now march it!\n    for (int i=0; i<100; i++) {\n        //run this part 100 times: calculate the distance between the current ray position and the fractal\n        float dist = distToScene(ray); \n    \tif (dist < 0.001) {\n            //if we're less than 0.001 away from it then assume we've hit it, and set the color accordingly\n            col = vec3(1.0 / (float(i)/8.0));\n            break;\n        }\n        //otherwise march forward the maximum amount and try again. if you never hit the fractal, the color will remain black.\n        ray.origin += ray.dir * dist;\n    }\n    //output the colour we got multiplied by a tint: in this case red with a smidge of green and blue. Try messing with the vec3 arguments below to produce other colours.\n\t//fragColor.rgb = col * vec3(0.6, 0.15, 0.05);\n    vec3 black = vec3(0.0, 0.0, 0.0);\n    vec3 red = vec3(0.6, 0.15, 0.05);\n\tvec3 orange = vec3(1.0, 0.62, 0.13) * 0.15;\n    vec3 main = lerp(black, red, col.r);\n\tvec3 edge = lerp(black, orange, pow(col.r, 3.5));\n    vec3 lerpcolor = main + edge;\n    \n    fragColor.rgb = lerpcolor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtdfDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[111, 411, 463, 463, 757], [759, 986, 1007, 1007, 1634], [1636, 1756, 1785, 1785, 1813], [1815, 1815, 1869, 1869, 1919], [1921, 1995, 2052, 2134, 3570]], "test": "valid"}
{"id": "wtdfDn", "name": "The End", "author": "EmmaChase", "description": "My take on the \"End\" shader from minecraft.", "tags": ["procedural", "noise"], "likes": 6, "viewed": 123, "published": "Public", "date": "1612553721", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NOISE_CUTOFF 0.66\n#define SPEED 10.0\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nfloat samplePoint(vec2 p) {\n    float n = noise(p);\n    n *= n * n * n;\n    n = step(NOISE_CUTOFF, n);\n    \n    return n;\n}\n\nfloat layer(vec2 fragCoord, float scale) {\n    float n = 0.0;\n    \n    vec2 squared = floor((fragCoord + vec2(0, SPEED*iTime))/scale);\n    n += samplePoint(squared);\n    n += 0.5*samplePoint(squared - vec2(0., 1.));\n    n += 0.25*samplePoint(squared - vec2(0., 2.));\n    n += 0.125*samplePoint(squared - vec2(0., 3.));\n\n    return n;\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvec3 decodeSRGB(vec3 screenRGB)\n{\n    vec3 a = screenRGB / 12.92;\n    vec3 b = pow((screenRGB + 0.055) / 1.055, vec3(2.4));\n    vec3 c = step(vec3(0.04045), screenRGB);\n    return mix(a, b, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 c = vec3(0.);\n    c += 1.4*layer(rotate2d(0.2)*fragCoord, 2.0) * vec3(32./255., 57./255., 99./255.);\n    c += 1.73*layer(rotate2d(-0.4)*fragCoord, 4.0) * vec3(34./255., 67./255., 75./255.);\n    c += 1.87*layer(rotate2d(1.5)*fragCoord, 6.0) * vec3(37./255., 72./255., 72./255.);\n    c += 2.*layer(rotate2d(-0.8)*fragCoord, 10.0) * vec3(41./255., 74./255., 61./255.);\n\n    fragColor = vec4(decodeSRGB(c),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtdfDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 66, 66, 133], [135, 135, 155, 155, 364], [366, 366, 393, 393, 489], [491, 491, 533, 533, 826], [828, 828, 856, 856, 942], [944, 944, 977, 977, 1139], [1141, 1141, 1198, 1198, 1617]], "test": "valid"}
{"id": "wtdfDS", "name": "15/02/2021 stream", "author": "anticore", "description": "coded live on twitch\nhttps://www.twitch.tv/antic0re_", "tags": ["raymarch", "glow", "live", "stream"], "likes": 4, "viewed": 224, "published": "Public API", "date": "1613401923", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nfloat ni(float x) {\n    //return texture(texFFTIntegrated, x).x;\n    return texelFetch( iChannel0, ivec2(x * 512.,0), 0 ).x * 2.;\n}\n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n  \n    return mat2(c, s, -s, c);\n}\n\nvec3 rep(vec3 p, vec3 c) {\n    return mod(p + .5 * c, c) - .5 * c;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.) - 0.1;\n}\n\nvec3 a = vec3(0);\n\nfloat sdBlock(vec3 p, vec3 pos) {\n     p += pos;\n     //p.xy *= rot(fGlobalTime);\n     //p.xz *= rot(fGlobalTime);\n  \n    return sdBox(p, vec3(.3, .3, .3));\n}\n\nvec2 sdBlocks(vec3 p) {\n    p.yz *= rot(0.6);\n    p.xz *= rot(-.6);\n    vec3 v = round(p);\n    float d = sdBlock(rep(p, vec3(1., 0., 1.)), vec3(0., 2. + sin(v.z * 10. + v.x * 10. + iTime + ni(0.) * 15.) * 0.04, 0.));\n    if (mod(v.x, 3.) == 0. && mod(v.z, 3.) == 0.) { \n      //a = vec3(1); \n      return vec2(d, 1);\n    }\n    else { \n      a = vec3(sin(v.x * 0.5 + v.z * 0.5 + iTime), cos(v.z * 0.8 + v.x * 0.2 + iTime * 0.5), sin(v.x + iTime)); \n      return vec2(d, 0);\n    }\n}\n\nfloat sdSphere(vec3 p, vec3 pos, float r) {\n    return length(p + pos) - r;\n}\n\nvec2 map(vec3 p) {\n    p += vec3(iTime / 2., 0., 0.);\n    //float box = sdBlocks(p);\n    return sdBlocks(p);\n}\n\nvec3 bg(vec2 uv) {\n    return vec3(0.);\n}\n\nvec3 dirlight(vec3 lp, vec3 lc, vec3 p, vec3 n) {\n    vec3 ld = normalize(lp - p);\n    float diff = max(dot(n, ld), 0.01);\n    return diff * lc;\n}\n\nvec3 spec(vec3 lp, vec3 lc, vec3 p, vec3 n) {\n    vec3 ld = normalize(lp - p);\n    vec3 r = reflect(-ld, n);\n    vec3 v = normalize(-p);\n    float speca = max(dot(r, v), 0.);\n    return pow(speca, 10.) * lc;\n}\n\nvec3 light(vec3 lp, vec3 lc, vec3 p, vec3 n) {\n    vec3 d = dirlight(lp, lc, p, n);\n    float kd = 0.5;\n    vec3 s = spec(lp, lc, p, n);\n    float ks = 0.5;\n  \n    return kd * d + ks * s;\n}\n\nvec3 norm(vec3 p) {\n  float E = 0.01;\n  vec2 k = vec2(1, -1);\n  \n  return normalize(\n    k.xyy * map(p + k.xyy * E).x +\n    k.yyx * map(p + k.yyx * E).x +\n    k.yxy * map(p + k.yxy * E).x +\n    k.xxx * map(p + k.xxx * E).x\n  );\n}\n\nvec3 fog(vec3 c, vec3 fc, float d) {\n  float fa = .5 - exp(-d * 0.01);\n  return mix(c, fc, fa);\n}\n\nvec3 blockcolor(vec3 p, vec3 n) {\n  return light(vec3(20,20,20), vec3(1), p, n) * 0.8 + a * 0.2;\n}\n\nvec3 lightblocksub(vec3 p, vec3 n, float d) {\n  return vec3(0,0,1) * 0.01;\n}\n\nvec3 tr(vec3 ro, vec3 rd, vec2 uv) {\n    float td = 1.;\n    vec2 h;\n  \n    vec3 tbc = vec3(0);\n    vec3 tbg = vec3(0);\n  \n    for (int i = 0; i < 200; i++) {\n      h = map(ro + rd * td);\n      \n      if (h.x > 0.001) {\n        td += h.x;\n      } else {\n          td += 0.01;\n      }\n      \n      \n      if (h.y == 1. && h.x < 0.3 && h.x > 0.0) {\n          tbg += vec3(0.3, 0.1, 0.3) *  0.1;\n      }\n      \n      if (h.x < 0.01) {\n          vec3 ip = ro + rd * td;\n          vec3 inorm = norm(ip);\n        \n          if (h.y == 0.) {\n              //return fog(light(vec3(20,20,20), vec3(1), ip, inorm) * 0.8 + a * 0.2, bg(uv), length(ip)); \n              return (blockcolor(ip, inorm)) + tbc + tbg;\n              //return inorm;\n          } else \n          \n          if (h.y == 1. && h.x < 0.001) {\n              tbc += lightblocksub(ip, inorm, h.x);\n          } else {\n              tbc += 0.05 * inorm + spec(vec3(20,20,20), vec3(1), ip, inorm) * 0.5;\n          } \n      }\n    }\n    \n    return bg(uv) + tbc + tbg;\n}\n\n//void main(void)\n//{\n//  vec2 uv = vec2(gl_FragCoord.x / v2Resolution.x, gl_FragCoord.y / v2Resolution.y);\n//  uv -= 0.5;\n//  uv /= vec2(v2Resolution.y / v2Resolution.x, 1);\n  \n//  vec3 ro = vec3(0,0,2);\n//  vec3 rd = normalize(vec3(uv, 0) - ro);\n  \n//  out_color = vec4(tr(ro, rd, uv), 1);\n//}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 ro = vec3(0,0,2);\n  vec3 rd = normalize(vec3(uv, 0) - ro);\n\n    // Output to screen\n    fragColor =  vec4(tr(ro, rd, uv), 1);\n}", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtdfDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 21, 66, 133], [135, 135, 154, 154, 233], [235, 235, 261, 261, 303], [305, 305, 334, 334, 429], [450, 450, 483, 483, 608], [610, 610, 633, 633, 1090], [1092, 1092, 1135, 1135, 1169], [1171, 1171, 1189, 1189, 1281], [1283, 1283, 1301, 1301, 1324], [1326, 1326, 1375, 1375, 1472], [1474, 1474, 1519, 1519, 1683], [1685, 1685, 1731, 1731, 1874], [1876, 1876, 1895, 1895, 2105], [2107, 2107, 2143, 2143, 2204], [2206, 2206, 2239, 2239, 2304], [2306, 2306, 2351, 2351, 2382], [2384, 2384, 2420, 2420, 3403], [3656, 3702, 3759, 3809, 3987]], "test": "error"}
{"id": "WtdfRS", "name": "fork-002_simplex.frag", "author": "jorge2017a1", "description": "fork-002_simplex.frag", "tags": ["fork002simplexfrag"], "likes": 1, "viewed": 34, "published": "Public", "date": "1612971651", "time_retrieved": "2021-10-01T00:00:00", "image_code": "///modificado por jorge.flores.p\n//referencia my avatar\n//https://www.shadertoy.com/view/lslfz4\n\n\n//original code.  by  Will Stallwood\n//https://github.com/willstall/30-days-of-shade/blob/master/assets/shaders/002_simplex.frag\n\n/*\n    daily: 002\n    author: Will Stallwood\n    insta: https://www.instagram.com/willstall/\n    \n*/\n\n\n\n#define PI 3.14159265359\n#define HALF_PI 1.57079632675\n#define TWO_PI 6.283185307\n\n\nvec3 palette(float t,vec3 a,vec3 b,vec3 c,vec3 d )\n{\n    return a + b * cos( TWO_PI * (c*t+d));\n}\n\nfloat random(float x)\n{\n    return fract(sin(x*100.00)*10000.0);\n}\n\nfloat random(vec2 st)\n{\n    return fract(\n        dot(\n            sin(st.x*100.00),\n            sin(st.y*100.00)        \n        )*10000.0);\n}\n\nfloat smoothCellRandom(float x,float scale)\n{   \n    float iPos = floor(x*scale);\n    float fPos = fract(x*scale);\n\n    return mix(random(iPos), random(iPos + 1.0), smoothstep(0.,1.,fPos));\n}\n\nfloat peakCellRandom(float x,float scale)\n{   \n    float iPos = floor(x*scale);\n    float fPos = fract(x*scale);\n\n    return mix(random(iPos), random(iPos + 1.0), fPos);\n}\n\nfloat cellRandom(float x,float scale)\n{   \n    float iPos = floor(x*scale);\n    float fPos = fract(x*scale);\n\n    return random(iPos);\n}\n\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro) \n{\n    vec3 l = lp - p;\n    float dist = max(length(l), 0.01);\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= dist;\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    float spe = pow(clamp(dot(r, -rd), 0.0, 1.0), 8.0);\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n    \n    vec3 lin = vec3(0.2);\n    lin += 1.0*dif*vec3(1, .97, .85);\n    lin += 2.5*spe*vec3(1, .97, .85)*dif;\n    lin += 2.5*fre*vec3(1);\n    lin += 0.5*dom*vec3(1);\n    \n    vec3 V = normalize(p-ro);\n   \n    return lin*atten;\n}\n\nfloat GetDist2D(vec2 st)\n{\n    float t = iTime * .33;\n    float scale = 20.;\n    float cell = cellRandom(st.x+t,scale);\n    float r = floor(cell*st.y*scale);\n    float f = st.y * abs(sin( cell*1000.0 + iTime));\n    r *= f;\n    r = 1.0 - step(1.0,r);\n    r += 1.0-f;\n\n    float d = smoothCellRandom(st.x+t,scale);\n    // d *= r;\n    d = r;\n\n    \n    return d+fract(t)*2.0;\n }   \n\nfloat maskSharp(vec2 p) {\n    return clamp(GetDist2D(p - vec2(0.0, 0.5))*400.0  , 0.0, 1.0);\n}\n\nfloat maskBlurry(vec2 p) {\n    return clamp((GetDist2D(p - vec2(0.0, 0.5)) + 0.003) * 75.0, 0.0, 1.0);\n}\n\nvec3 normalAt(vec2 p) \n{\n    float ps = 1.0 / iResolution.x;\n    float x = maskBlurry(p - vec2( ps, 0.0)) - maskBlurry(p + vec2( ps, 0.0));\n    float y = maskBlurry(p - vec2(0.0,  ps)) - maskBlurry(p + vec2(0.0,  ps));\n    return normalize(vec3(x, y, 1.0));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 st = fragCoord.xy / iResolution.xy;\n    //vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 color = vec3(0.0);\n    vec2 p = fragCoord.xy / iResolution.xy;\n    \n    vec3 p0=vec3(p, 0.0);\n    vec3 ro=p0;\n    vec3 rd=normalize(vec3(p,1.0));\n    \n    vec3 lightPos = vec3(cos(iTime), sin(iTime), 1.0);\n    \n    vec3 toLight = lightPos - p0;\n    vec3 normal = normalAt(p);\n    float shade = 0.3 + maskSharp(p) * 0.7;\n   \n    \n    \n    float t = iTime * .33;\n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(0.0,.1,0.2);\n    \n    float d= GetDist2D(st);\n    color = palette(d+fract(t)*2.0,vec3(0.5),a,b,c);\n    // color += vec3(clamp(dot(normalize(toLight), normal), 0.0, 1.0) / length(toLight)*0.5) * d;\n    vec3 noise = vec3((texture(iChannel0, p * 4.0).x - 0.5) / 32.0);\n    \n    vec3 col2= lightingv3(normal,p0, lightPos, rd, ro) *color;\n     color /= d;\n    color +=noise;\n    \n    \n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtdfRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[228, 416, 468, 468, 513], [515, 515, 538, 538, 581], [583, 583, 606, 606, 726], [728, 728, 773, 773, 919], [921, 921, 964, 964, 1092], [1094, 1094, 1133, 1133, 1230], [1233, 1233, 1298, 1298, 1916], [1918, 1918, 1944, 1944, 2292], [2297, 2297, 2322, 2322, 2391], [2393, 2393, 2419, 2419, 2497], [2499, 2499, 2523, 2523, 2758], [2762, 2762, 2819, 2819, 3795]], "test": "error"}
{"id": "wtdfRX", "name": "Fractal 25_gaz", "author": "gaz", "description": "3d", "tags": ["fractal"], "likes": 13, "viewed": 116, "published": "Public", "date": "1613179366", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)cos(h*6.3+vec3(0,23,21))*.5+.5\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 r=iResolution,p;  \n    for(float i=0.,g,e,s;\n        ++i<99.;\n        (e<.002)?O.xyz+=mix(r/r,H(log(s)*.25),.5)*1./i:p\n    )\n    {\n        p=g*vec3((C-.5*r.xy)/r.y,1);\n        p.z-=2.;\n        p=R(p,normalize(vec3(1,1,0)),iTime*.3);\n        p.y-=sin(iTime*.2)*5.;\n        p.xz=abs(p.xz)-1.;\n        p.x>p.z?p=p.zyx:p;\n        s=3.;\n        for(int j=0;j++<7;)\n            s*=e=2.7/clamp(dot(p,p),.1,1.7),\n            p=abs(p)*e-vec3(1,5,.003);\n        g+=e=length(p.xz)/s;\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtdfRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 102, 138, 138, 643]], "test": "valid"}
{"id": "WtdfWr", "name": "Moiré 3c - rev", "author": "FabriceNeyret2", "description": "Shadows of 2 identical parallel plates with hexa-tiled disks. \nHere, the second plates rotate over time. \n( you might try a slight perspective effect by changing the coef line 14. )", "tags": ["aliasing", "interference", "moir", "reproduction", "glasspatterns"], "likes": 7, "viewed": 158, "published": "Public API", "date": "1612538504", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// reverse pattern of https://shadertoy.com/view/wt3fWr\n\n#define D   length( mod( U += T/2. , T ) - k )               //\n#define P   clamp(  ( min( D, D ) -.6*k.y )/5. ,0.,1.)    // draw an hexa tiling of disks\n\nvoid mainImage(out vec4 O, vec2 u) {\n   vec2 R = iResolution.xy,\n        U = 4.*(u-R/2.),\n        V = U * mat2( cos( .05*iTime + vec4(0,11,33,0) ) ),\n\n        k = R.yy/8., T = vec2( 2, 3.5 )*k;\n    O += P -O;\n\n    U = 1.0*V; // try 1.1\n    O *= P;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtdfWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 212, 248, 248, 461]], "test": "error"}
{"id": "wtdfz8", "name": "Serpents ", "author": "YitingLiu", "description": "Creating the evil moving snake", "tags": ["noise", "texture", "evil", "snake", "truchet", "flow", "floor", "mask", "angle", "fract", "width"], "likes": 2, "viewed": 203, "published": "Public API", "date": "1612269891", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Hash21(vec2 p){\n    p = fract(p*vec2(234.34,435.345));\n    p += dot(p, p+34.23);\n    return fract(p.x*p.y);\n\n\n\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 UV = fragCoord/iResolution.xy;\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col =vec3(0);\n    \n    uv*=4.;\n    uv+=iTime*0.5;\n    vec2 gv = fract(uv)-0.5;\n    vec2 id = floor(uv);//checking each box \n    \n    float n = Hash21(id);// random number between 0 to 1 \n    \n    float width =0.3*UV.y;\n    \n    if(n<.5) gv.x*=-1.;//reverse tiling depending on the random num\n    float d = abs(abs(gv.x+gv.y));\n    vec2 cUv =gv-0.5*sign(gv.x+gv.y+0.001); // give -PI to PI \n    d = length(cUv);\n    // sign returns 1 when x is positive, -1 when x is negative, 0 when x is 0\n    \n    float mask = smoothstep(.01,-.01,abs(d-.5)-width);\n    float angle = atan(cUv.x, cUv.y);\n    float checker = mod(id.x+id.y,2.)*2.-1.;\n    float flow = sin( iTime+checker*angle*10.);\n    //col+=flow*mask;// checker allows it to flow consistently - works with quart truchet\n    //col+=n;\n    \n    float x = fract(checker*angle/1.57-iTime*0.5); //divide by half PI - get the range from 0 to 1 by using fract \n    float y = (d-(.5-width))/(2.*width);\n    y = abs(y-.5)*2.;\n    vec2 tUv = vec2(x,y);\n    col.rb+=1.-tUv/mask;\n    \n    // apply any texture\n    col *=texture(iChannel0,tUv).rgb*mask;\n\n    col +=texture(iChannel1,tUv).rgb-mask;\n    col +=1.-tUv.y;\n    //if(gv.x>.48||gv.y>.48) col=vec3(1,0,0);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "Xsf3Rn", "previewfilepath": "/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture"}, {"id": "XdXGzr", "previewfilepath": "/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtdfz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 119], [122, 122, 179, 179, 1524]], "test": "error"}
{"id": "WtGBDD", "name": "Cereal for Dinner?", "author": "YitingLiu", "description": "Cereal rings in the galaxy. Who wouldn't want that?", "tags": ["grid", "rotate", "star", "galaxy", "starfield", "infinite", "food", "artofthecode", "cereal", "dinner"], "likes": 2, "viewed": 187, "published": "Public API", "date": "1614310317", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// followed tutorials https://youtu.be/rvDo9LvfoVE\n//https://youtu.be/dhuigO4A7RY\n\n#define NUM_LAYERS 5.\n\nmat2 Rot(float a){\n    float s=sin(a), c=cos(a);\n    return mat2(c,-s,s,c);\n\n}\n\nfloat Star(vec2 uv, float flare){\n    float d = length(uv);//distance to the center \n    float m = .03/d;//more light like than smoothstep(.1,.05,d);\n    \n    //float rays= max(0.,1.-abs(uv.x*uv.y*1000.)); \n    //m +=rays*flare;\n    \n    //uv*=Rot(3.1415/4.);\n    //rays= max(0.,1.-abs(uv.x*uv.y*1000.));\n    //m+=rays*.5*flare;\n    m=2.*smoothstep(.3,.1,d);\n    m-=smoothstep(.2,.0,d);\n    m*=smoothstep(1.,mix(.8,.5,uv.y),d);\n\n    return m;\n\n\n}\n\nfloat Hash21(vec2 p){\n    p = fract(p*vec2(123.34,456.21));\n    p += dot(p, p+45.32);\n    return fract(p.x*p.y);\n    \n\n}\n\nvec3 StarLayer(vec2 uv) {\n\tvec3 col = vec3(0);\n\t\n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    \n    // should add <=\n    for(int y=-1;y<=1;y++) {\n    \tfor(int x=-1;x<=1;x++) {\n            vec2 offs = vec2(x, y);\n            \n    \t\tfloat n = Hash21(id+offs); // random between 0 and 1\n            float size = fract(n*345.32);\n            \n    \t\tfloat star = Star(gv-offs-vec2(n, fract(n*34.))+.5, smoothstep(.6, 1., size)*.6);\n            \n            vec3 color = sin(vec3(.5, .1, .9)*fract(n*2345.2)*123.2)*.5+.5;\n            color = color*vec3(1,.2,.8+size)+vec3(.2, .2, .1)*2.;\n            \n            star *= sin(iTime*2.+n*6.2831)*.5+1.;\n            col += star*size*color;\n        }\n    }\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 M = (iMouse.xy-.5*iResolution.xy)/iResolution.y;\n    \n    float t = iTime*.03;\n       float fft  = texelFetch( iChannel0, ivec2(0.,0), 0 ).x; \n    \n\n \n    vec3 col = vec3(0);\n    \n    for (float i =0.; i <1.;i+=1./NUM_LAYERS){\n\n        float depth = fract(i+t);\n        //if mouse is engaged\n        float scale = mix (mix(0.,100.,length(uv-M)),2.,depth);\n        // if mouse is not engaged \n       // float scale = mix (mix(0.,100.,length(uv-(mix(0.4,0.9,fft)))),2.,depth);\n//https://www.shadertoy.com/img/close2.png\n        float fade = depth*smoothstep(1., .8, depth);\n        col += StarLayer(uv*scale+i*532.*M)*fade-.2*Hash21(uv);\n\n    }\n       uv*=Rot(t);\n    uv.x+=max(t*.0001,1.);\n    uv.y-=max(t*.0001,.5);\n\n    \n        col = pow(col, vec3(.85));\t// gamma correction\n \n    \n    //if(gv.x>.48|| gv.y>.48) col.r=1.;//coloring the grid\n  \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGBDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 106, 124, 124, 184], [186, 186, 219, 219, 632], [634, 634, 655, 655, 754], [756, 756, 781, 781, 1481], [1482, 1482, 1539, 1539, 2491]], "test": "error"}
{"id": "WtGBWz", "name": "Procedural Warping", "author": "ArenaGrenade", "description": "Organic looking Procedural warping with colourful shading.", "tags": ["noisewarpingproceduralorganic"], "likes": 4, "viewed": 228, "published": "Public API", "date": "1614141051", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NUM_OCTAVES 3\n#define SPEED_SCALE 0.5\n\n// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83 - one of the best gists to exist\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\n// Rotation matrix\nconst mat2 rot_mat = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nvoid rotate_point(inout vec2 p) {\n    // This line just generates a random value between 2.01 and 2.04\n    float factor = 2.01 + float(int(rand(p) * 100.0) % 4) * 0.01;\n    p *= (rot_mat * 2.04);\n}\nfloat calculate_iteration(inout float frequency, inout float amplitude, vec2 p, float addend) {\n    float f = amplitude * noise(frequency * p + addend);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n    return f;\n}\nfloat fbm(vec2 p) {\n    float amplitude = 0.5;\n    float frequency = 0.5;\n    float f = 0.0;\n    \n    for (int i = 0 ; i < NUM_OCTAVES; i++) {\n        if (i == 0) {\n            f += calculate_iteration(frequency, amplitude, p, iTime * SPEED_SCALE);\n        } else {\n            f += calculate_iteration(frequency, amplitude, p, sin(iTime * SPEED_SCALE + noise(p)));\n        }\n        rotate_point(p);\n    }\n    \n    return f / 0.96975;\n}\n\n// A very simple warping\nfloat warp(vec2 p, int depth) {\n    float val = fbm(p);\n    for (int i = 0; i < depth; i++) val = fbm(p + val);\n    return val;\n}\n\nvec3 calculate_normal(vec2 p) {\n    float d = warp(p, 2);\n    vec2 e = vec2(0.01, 0);\n    \n    vec3 n = d - vec3(\n        warp(p - e.xy, 2),\n        2.0 * e.x,\n        warp(p - e.yx, 2)\n    );\n    \n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float density = warp(uv, 2);\n    \n    vec3 col = vec3(0.0);\n    // Apply Density based color-gradient from a lagoon blue\n    col = mix(vec3(2.0, 83.0, 125.0) / 255.0, vec3(1.0, 132.0, 169.0) / 255.0, smoothstep(0.0, 0.05, density));\n    col = mix(col, vec3(1.0, 191.0, 196.0) / 255.0, smoothstep(0.05, 0.3, density));\n    col = mix(col, vec3(169.0, 232.0, 219.0) / 255.0, smoothstep(0.3, 0.5, density));\n    col = mix(col, vec3(224.0, 247.0, 230.0) / 255.0, smoothstep(0.5, 0.7, density));\n    \n    col = 1.0 - col;\n    \n    // Lighting\n    vec3 n = calculate_normal(uv);\n    vec3 l = vec3(0.9, -0.02, -0.4);\n    // vec3 lig = normalize(l - vec3(uv.xy, density));\n    vec3 lig = l;\n    \n    float diffuse_intensity = 0.3;\n    float diffuse = clamp(diffuse_intensity + (1.0 - diffuse_intensity) * dot(n, lig), 0.0, 1.0);\n\n    vec3 i = vec3(0.85,0.90,0.95);\n    vec3 bdrf = clamp(i * (n.y * 0.5 + 0.5) + (1.0 - i) * diffuse, 0.8, 1.0);\n    \n    col *= bdrf;\n    col = vec3(1.0)-col;\n    col = col*col;\n    col *= vec3(1.2,1.2,1.2);\n    col = clamp(col, 0.0, 1.0);\n    \n    fragColor = vec4(vec3(col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGBWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 149, 169, 169, 236], [238, 238, 258, 258, 467], [469, 545, 578, 647, 742], [743, 743, 838, 838, 955], [956, 956, 975, 975, 1393], [1395, 1420, 1451, 1451, 1549], [1551, 1551, 1582, 1582, 1775], [1777, 1777, 1834, 1834, 2985]], "test": "valid"}
{"id": "WtGcRK", "name": "Ray Marching Jiggle", "author": "BGrater", "description": "Ray marching some simple shapes with a lil' jiggle.\n\nMouse (hold left click):  Move camera", "tags": ["3d", "raymarching", "artofcode"], "likes": 2, "viewed": 91, "published": "Public", "date": "1613447504", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_STEPS = 100;\nconst float MAX_DIST = 100.0;\nconst float SURF_DIST = 0.01;\n\nconst float CAM_AUTO_SPEED = 0.1;\nconst float MOUSE_SPEED = 8.0;\n\n\nmat2 Rot2D(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return mat2(c, -s, s, c);\n}\n\n\nfloat Sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n\nfloat Capsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0.0, 1.0);\n    \n    vec3 c = a + t * ab;\n    return length(p - c) - r;\n}\n\n\nfloat Cylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    \n    vec3 c = a + t * ab;\n    float x = length(p - c) - r;\n    float y = abs(t - 0.5) - length(ab);\n    float e = length(max(vec2(x, y), 0.0));\n    float i = min(max(x, y), 0.0);\n    \n    return e + i;\n}\n\n\nfloat Torus(vec3 p, vec2 r)\n{\n    float x = length(p.xz) - r.x;\n    return length(vec2(x, p.y)) - r.y;\n}\n\n\nfloat Box(vec3 p, vec3 s)\n{\n    return length(max(abs(p) - s, 0.0));\n}\n\n\nfloat GetDist(vec3 p)\n{\n    // Jiggle\n    float st = sin((iTime - 2.0) * 0.5) * 3.0;\n    float mask = smoothstep(st - 1.0, st, p.x) * smoothstep(st + 1.0, st, p.x);\n    float jiggle = mask * sin((p.x + iTime) * 10.0) * 0.1;\n    \n    // Shapes\n    float planeDist = p.y;\n    float sphereDist = Sphere(p - vec3(-3.0, jiggle + 1.0, 1.0), 1.0);\n    float capsuleDist = Capsule(p - vec3(0.0, jiggle + 0.5, 1.0), vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), 0.5);\n    float cylinderDist = Cylinder(p - vec3(3.0, jiggle + 1.0, 1.0), vec3(0.0, 0.0, 0.4), vec3(0.0, 0.0, -0.4), 0.5);\n    float torusDist = Torus(p - vec3(-1.2, jiggle + 0.5, -1.0), vec2(0.7, 0.2));\n    float boxDist = Box(p - vec3(1.5, jiggle + 1.0, -1.0), vec3(0.5));\n    \n    float d = min(sphereDist, planeDist);\n    d = min(d, capsuleDist);\n    d = min(d, cylinderDist * 0.8);\n    d = min(d, torusDist);\n    d = min(d, boxDist * 0.5);\n    \n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n    float dO = 0.0;\n    \n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd * dO;\n        float dS = GetDist(p);\n        dO += dS;\n        \n        if(dO > MAX_DIST || abs(dS) < SURF_DIST)\n            break;\n    }\n    \n    return dO;\n}\n\n\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDist(p);\n    vec2 e = vec2(0.01, 0.0);\n    \n    vec3 n = d - vec3(\n        GetDist(p - e.xyy),\n        GetDist(p - e.yxy),\n        GetDist(p - e.yyx));\n    \n    return normalize(n);\n}\n\n\nfloat GetLight(vec3 p)\n{\n    const vec3 lightPos = vec3(1.5, 6.0, -3.0);\n    \n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0.0, 1.0);\n    float d = RayMarch(p + n * 0.02, l);\n    \n    if(d < length(lightPos - p))\n        dif *= 0.1;\n    \n    return dif;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Input\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    float mouseEnable = float(iMouse.xy != vec2(0.0));\n    \n    \n    // Camera\n    float camRot = (iTime - 7.0) * CAM_AUTO_SPEED;\n    float camHeight = 3.0;\n    \n    camHeight += mouseEnable * (-camHeight + (mouse.y * MOUSE_SPEED));\n    camRot += mouseEnable * (-camRot + (mouse.x - 0.5) * MOUSE_SPEED);\n    \n    vec3 camPos = vec3(0.0, camHeight, -5.0);\n    camPos.xz *= Rot2D(camRot);\n    \n    vec3 lookAt = vec3(0.0, 0.0, 0.5);\n    float zoom = 0.8;\n    \n    vec3 fwd = normalize(lookAt - camPos);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), fwd));\n    vec3 up = cross(fwd, right);\n    \n    \n    // Ray march\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec3 center = camPos + (fwd * zoom);\n    vec3 i = center + (uv.x * right) + (uv.y * up);\n    vec3 rayDir = normalize(i - camPos);\n    \n    float d = RayMarch(camPos, rayDir);\n    vec3 p = camPos + rayDir * d;\n    \n    float shade = GetLight(p);\n    vec3 col = vec3(shade);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGcRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[155, 155, 180, 180, 269], [272, 272, 303, 303, 331], [334, 334, 382, 382, 560], [563, 563, 612, 612, 908], [911, 911, 940, 940, 1015], [1018, 1018, 1045, 1045, 1088], [1091, 1091, 1114, 1128, 2005], [2008, 2008, 2042, 2042, 2297], [2300, 2300, 2324, 2324, 2525], [2528, 2528, 2552, 2552, 2841], [2844, 2844, 2899, 2912, 3966]], "test": "valid"}
{"id": "wtGfWw", "name": "shader challenge 20210227", "author": "butadiene", "description": "shader challenge ", "tags": ["2d"], "likes": 5, "viewed": 190, "published": "Public API", "date": "1614425950", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time mod(iTime,1000.)\nfloat PI = 3.1415926535;\n#define bpm 120.\nvec2 pmod(vec2 p,float n){\n  float np = 2.0*PI/n;\n  float r = atan(p.x,p.y)-0.5*np;\n  r = mod(r,np)-0.5*np;\n  return length(p.xy)*vec2(cos(r),sin(r));\n  \n  }\n\nfloat func(float x, float y, float z) {\n    z = fract(z), x /= pow(2.,z), x += z*y;\n    float v = 0.;\n    for(int i=0;i<6;i++) {\n        v += asin(sin(x)) * (1.-cos((float(i)+z)*1.0472));\n        v /= 2., x /= 2., x += y;\n    }\n    return v * pow(2.,z);\n}\n\n\nmat2 rot (float r){\n  \n  return mat2(cos(r),sin(r),-sin(r),cos(r));\n  }\n\n vec3 outco(vec2 p){\n  vec3 col = vec3(0);\n   vec2 ssp = p;\n  float iter = 6.;\n  float sit = 1.+floor(mod(time*bpm/60.,iter));\n  for(int i = 0;i<6;i++){\n    if(sit>float(i)){\n       p *= rot(PI*float(i)/iter);\n       p = pmod(p,3.);\n    \n      col += vec3(func(p.x,time*3.,-0.1*time));\n      p = ssp;\n     }\n   \n  }\n  col /= sit;\n  col *= (12.+sit)/12.;\n  return col;\n  }\n  \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p =uv- 0.5;\n\tp /= vec2(iResolution.y / iResolution.x, 1);\n    vec2 sp = p;\n    vec3 col = vec3(0);\n  \n    p *= 100.;\n\n    p = sp;\n    p += 0.1*func(uv.x*100.,uv.y*100.,time)*pow(abs(sin(8.*time*bpm/60.)),16.);\n    float  scale = 800.;\n    p *= scale;\n    vec2 ep = 0.5*scale*vec2(0.01,0.01)*(uv-0.5);\n    col.b += outco(p).r;\n    p += ep;\n    col.g += outco(p).r;\n    p -=2.*ep; \n    col.r += outco(p).r;\n\n  \n  col *= 0.2+pow(abs(sin(4.*time*108./60.)),2.);\n  col = 1.5*pow(col,vec3(1.4,1.4,1.2));\n    fragColor = vec4(col,0.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtGfWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 98, 98, 229], [231, 231, 270, 270, 486], [489, 489, 508, 508, 560], [563, 563, 582, 582, 933], [939, 939, 996, 1046, 1625]], "test": "valid"}
{"id": "WtGfzm", "name": "Sphere Grid Colors", "author": "csgradle", "description": "Looks really scary in full screen.\nStarted out by just trying to make a tile of circles (like the square tile i made in my last shader)\nadded chromatic aberration and distance distortion\ndo ya like it?", "tags": ["grid", "grid", "chromaticaberration", "distortion", "color"], "likes": 3, "viewed": 132, "published": "Public", "date": "1614063929", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);\n}\nfloat circle(vec2 st, vec2 position, float radius) {\n    return 1.-step(radius, length(position-st));\n}\nfloat circleTile(vec2 st, float tileSize, float radius) {\n    vec2 tilePos = vec2(fract(st.x/tileSize), fract(st.y/tileSize));\n    return circle(tilePos, vec2(0.5), radius);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // fix coordinate pixels\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv-0.5;\n    float screenRatio = iResolution.x/iResolution.y;\n    uv.x *= screenRatio;\n    \n    // rotate\n    uv *= rotate2d(iTime*0.3);\n    \n    // distort the space distance scaling\n    vec2 st = uv;\n    st *= scale(vec2(0.3-(.3*length(uv)))); // comment this line to see only the grid of circles\n   \n    // get circle tiles with chromatic aberration  \n    float zoom = .01*sin(iTime*1.)+.015;\n    float r = 0.3;\n    float red = circleTile(st, zoom, r);\n    float green = circleTile(st*scale(vec2(1.02)), zoom, r);\n    float blue = circleTile(st*scale(vec2(0.98)), zoom, r);\n    \n    // final color \n    vec3 col = vec3(red, green, blue);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGfzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 50, 50, 136], [137, 137, 161, 161, 224], [225, 225, 277, 277, 328], [329, 329, 386, 386, 504], [505, 505, 562, 591, 1313]], "test": "valid"}
{"id": "wtKBDR", "name": "Marble Onion Skin", "author": "MacSlow", "description": "Quickly thrown together shader to play around with abs() to get the 'onion skin' effect (see https://iquilezles.org/www/articles/distfunctions/distfunctions.htm). Added a pillar and some domain repetition to not look too boring.", "tags": ["3d", "fbm", "marble", "skin", "onion"], "likes": 3, "viewed": 211, "published": "Public API", "date": "1614201172", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Marble Onion Skin - Trying out the 'onion effect' as stated on iq's website,\n// see https://iquilezles.org/www/articles/distfunctions/distfunctions.htm for\n// details. The code is almost not commented at all, thus not the best example\n// to learn from.\n//\n// Copyright 2021 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nmat2 r2d (float deg) {\n    float r = radians (deg);\n    float c = cos (r);\n    float s = sin (r);\n    return mat2 (c, s, -s, c);\n}\n\nfloat smin (float d1, float d2, float k) {\n    float h = clamp (.5 + .5*(d2 - d1)/k, .0, 1.);\n    return mix (d2, d1, h) - h*k*(1. - h);\n}\n\n// hash(), noise(), fbm() are from an example by iq and/or Shane\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3. - 2.*f);\n\n    float n = p.x + p.y*57. + 113.*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.), hash(n+  1.),f.x),\n                        mix( hash(n+ 57.), hash(n+ 58.),f.x),f.y),\n                    mix(mix( hash(n+113.), hash(n+114.),f.x),\n                        mix( hash(n+170.), hash(n+171.),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p ) {\n    float f;\n    mat2 m = r2d (1.1);\n\n    f  = .5*noise( p ); p.xz *= m*2.02;\n    f += .25*noise( p ); p.xy *= m*2.23;\n    f += .125*noise( p ); p.yz *= m*2.71;\n    f += .0625*noise( p );\n\n    return f;\n}\n\n#define PI 3.14159265\n\nfloat modPolar(inout vec2 p, float repetitions) {\n    float angle = 2.*PI/repetitions;\n    float a = atan(p.y, p.x) + angle/2.;\n    float r = length(p);\n    float c = floor(a/angle);\n    a = mod(a,angle) - angle/2.;\n    p = vec2(cos(a), sin(a))*r;\n    if (abs(c) >= (repetitions/2.)) c = abs(c);\n    return c;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\n\nfloat opSlice (float dist, float thickness) {\n\treturn abs (dist) - thickness;\n}\n\nfloat cylinderd = .0;\n\nfloat map (vec3 p, inout vec3 pout, inout int id) {\n    p.xy *= r2d (12.*cos(iTime));\n    p.xz *= r2d (45.*iTime);\n\n    vec2 cell = vec2(2.5);\n    p.xz = mod (p.xz + .5*cell, cell) - .5*cell;\n\n\tvec3 boxCutterSize = vec3 (.7, .6, .7);\n\tvec3 tmp = abs (p - vec3(.0, 2.25 + .75*(.5+.5*cos(iTime)), .0)) - boxCutterSize;\n\tfloat boxCutter = length (max (vec3 (.0), tmp)) +\n\t\t\t\t\t\t\t  min (max (tmp.x, max (tmp.y, tmp.z)), .0);\n\tfloat ball = opSlice (length (p - vec3(.0, 1.6, .0)) - .5, .1);\n\tball = opSlice (ball, .05);\n\tball = opSlice (ball, .025);\n\tball = opSlice (ball, .0125);\n\tball = max (ball, -boxCutter);\n\n    float ground = p.y + 1.;\n    vec3 size = vec3 (.7, .1, .7);\n\tfloat plate = length (max (vec3 (.0), abs (p - vec3(.0, 1., .0)) - size)) - .025;\n\n    float cyl = sdCappedCylinder (p, vec2 (.5, 1.));\n    modPolar (p.xz, 9.);\n    float cut = sdVerticalCapsule (p - vec3 (.55, -1., .0), 1.6, .1);\n\n    float d = smin (cyl, -cut, -.02);\n\tcylinderd = d;\n    d = min (d, plate);\n    d = min (d, ground);\n    d = min (d, ball);\n\n\tif (d == cyl) id = 1;\n\tif (d == plate) id = 2;\n\tif (d == ground) id = 3;\n\tif (d == ball) id = 4;\n\n    pout = p;\n    return d;\n}\n\nfloat march (vec3 ro, vec3 rd, inout vec3 pout, inout int id) {\n    float t = .0;\n    float d = .0;\n    for (int i = 0; i < 48; ++i) {\n        t = map (ro+d*rd, pout, id);\n        if (abs (t) < .0001*(1. + .126*t)) break;\n        d += t*.95;\n    }\n    return  d;\n}\n\nvec3 norm (vec3 p) {\n    vec3 dummy;\n\tint dummy2;\n    float d = map (p, dummy, dummy2);\n    vec2 e = vec2 (.001, .0);\n    return normalize (vec3 (map (p + e.xyy, dummy, dummy2), map (p + e.yxy, dummy, dummy2), map (p + e.yyx, dummy, dummy2))  - d);\n}\n\n// hard shadows\nfloat sha (vec3 p, vec3 n, vec3 ldir, float ldist) {\n    vec3 dummy;\n    int dummy2;\n    float d2w = march (p  + .01*n, ldir, dummy, dummy2);\n    return ldist < d2w ? 1. : .3;\n}\n\nvec3 shade (vec3 ro, vec3 rd, float d, vec3 p, vec3 n, vec3 lp, vec3 lc, vec3 pout, int id) {\n    float v = fbm (30.*pout);\n    vec3 mat = mix (vec3 (.0), vec3 (1.), v);\n\tif (id == 4) mat = vec3 (1., .0, .0);\n    vec3 am = vec3 (.05);\n    vec3 ldir = normalize (lp - p);\n    vec3 h = normalize (-rd + ldir);\n\tif (id != 4) n = normalize (n + .125*vec3 (fbm (20.*pout), .0, fbm (10.*pout)));\n\tif (id == 3) {\n\t\tfloat m = smoothstep (.9, 1., fract (7.*cylinderd));\n\t\tmat = mix (vec3 (0.), vec3 (1.), m);\n\t}\n    float sp = pow (max (.0, dot (n, h)), 80.*v);\n    float ldist = distance (lp, p);\n    float s = sha (p, n, ldir, ldist);\n    float att = 3. / (ldist*ldist);\n    float li = 2.;\n    float diff = v*max (.0, dot (n, ldir));\n    return att*s*(am + diff*mat*li*lc + sp*vec3 (1.));\n}\n\nvec3 cam (vec2 uv, vec3 ro, vec3 aim, float z) {\n    vec3 f = normalize (aim - ro);\n    vec3 wu = vec3 (.0, 1., .0);\n    vec3 r = normalize (cross (wu, f));\n    vec3 u = normalize (cross (f, r));\n    vec3 c = ro + f*z;\n    return normalize (c + r*uv.x + u*uv.y - ro);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvRaw = uv;\n    uv = uv*2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= 1. + .35*length (uv);\n\n    vec3 ro = vec3 (-.3, 2.75, 1.);\n    vec3 aim = vec3 (.0, 1.25, .0);\n    float z = 1.25;\n    vec3 rd = cam (uv, ro, aim, z);\n    vec3 pout;\n\tint id;\n    float d = march (ro, rd, pout, id);\n    float fog = 1. / (1. + d*d*.1);\n    vec3 p = ro+d*rd;\n    vec3 n = norm (p);\n    vec3 lp1 = vec3 (1.0, 3.0, 2.);\n    vec3 lp2 = vec3 (2.0, 2.5, 5.);\n    vec3 lp3 = vec3 (.1, 4.0, 7.);\n    vec3 lc1 = vec3 (.9, .8, .7);\n    vec3 lc2 = vec3 (.2, .3, .9);\n    vec3 lc3 = vec3 (.9, .3, .2);\n    vec3 col = shade (ro, rd, d, p, n, lp1, lc1, pout, id);\n    col += shade (ro, rd, d, p, n, lp2, lc2, pout, id);\n    col += shade (ro, rd, d, p, n, lp3, lc3, pout, id);\n\n    ro = p +.01*n;\n    rd = normalize (reflect (rd, n));\n    d = march (ro, rd, pout, id);\n    p = ro+d*rd;\n    n = norm (p);\n\n    vec3 rcol = shade (ro, rd, d, p, n, lp1, lc1, pout, id);\n    rcol += shade (ro, rd, d, p, n, lp2, lc2, pout, id);\n    rcol += shade (ro, rd, d, p, n, lp3, lc3, pout, id);\n    col += .25*rcol;\n\n    col *= fog;\n    col = col / (1. + col);\n    col *= 1. - .2*length (uv);\n    col = pow (col, vec3 (1./2.2));\n\n    fragColor = vec4 (col, 1.);\n}\n", "image_inputs": [{"id": "4tlSzM", "previewfilepath": "https://soundcloud.com/michaelschofield/jinny-keep-warm", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/michaelschofield/jinny-keep-warm", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKBDR.jpg", "access": "shaders20k", "license": "gpl-3.0", "functions": [[0, 1136, 1158, 1158, 1266], [1268, 1268, 1310, 1310, 1406], [1408, 1473, 1496, 1496, 1535], [1537, 1537, 1563, 1563, 1958], [1960, 1960, 1981, 1981, 2186], [2211, 2211, 2260, 2260, 2522], [2524, 2524, 2566, 2566, 2665], [2667, 2667, 2720, 2720, 2783], [2785, 2785, 2830, 2830, 2864], [2889, 2889, 2940, 2940, 4049], [4051, 4051, 4114, 4114, 4315], [4317, 4317, 4337, 4337, 4567], [4569, 4585, 4637, 4637, 4762], [4764, 4764, 4857, 4857, 5547], [5549, 5549, 5597, 5597, 5818], [5820, 5820, 5877, 5877, 7159]], "test": "valid"}
{"id": "wtKBWm", "name": "abstract flower", "author": "sukupaper", "description": "Originally made as an animated background for \"paperu.net\".", "tags": ["raymarching", "flower", "abstract"], "likes": 3, "viewed": 61, "published": "Public", "date": "1614508775", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author: paperu\n// Title: abstract flower\n\nprecision lowp float;\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n#define P 3.14159265359\n\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat t;\nfloat df(vec3 p) {\n    p.xz *= rot(t*.2);\n    p.yz *= rot(P*-.2);\n    p.xz *= rot(P*.25);\n    \n    float rad = 0.66*2.5;\n    float d = 10e6;\n    int limI = int(floor((cos(t*2.)*.5+.5)*5.));\n    for(int i = 0; i < 4; i++) {\n        float dt1 = abs(length(abs(p) - vec3(+1.,0.,0.)) - rad) - .0469;\n        float dt2 = abs(length(abs(p) - vec3(0.,+1.,0.)) - rad) - .0469;\n        float dt3 = abs(length(abs(p) - vec3(0.,0.,+1.)) - rad) - .0469;\n        d = min(min(min(d,dt1),dt2),dt3);\n        rad -= .2;\n    }\n    p = abs(p); float dshape = (p.x+p.y+p.z - 10.)*.57735027;\n    return max(-d,dshape);\n}\n\n#define EPSI .0001\nvec3 normal(vec3 p){\n    vec2 u = vec2(0.,EPSI); float d = df(p);\n    return normalize(vec3(df(p + u.yxx),df(p + u.xyx),df(p + u.xxy)) - d);\n}\nvec4 rm(vec3 c, vec3 r) {\n    vec4 color = vec4(vec3(.1),0.);\n    vec3 p = c + r*2.;\n    if(df(p) < EPSI) {\n        color.rgb = 1. - (normal(p)*.5 + .5);\n        color.w = 1.;\n        return color;\n    }\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = (fragCoord.xy - .5*iResolution.xy)/iResolution.x;\n    \n    float mx = length(iMouse.xy/iResolution.xy - .5)*5.;\n\n    st *= 1. + mx;\n\n    t = iTime*.125;\n\n    vec3 c = vec3(0.,0.,-2.);\n    vec3 r = normalize(vec3(st,0.8));\n    vec4 color = rm(c,r);\n\n    vec3 copyColor = color.rgb;\n    color.rgb += vec3(color.r + color.b + color.g)/3.;\n    color.r *= copyColor.b;\n    color.g *= copyColor.g;\n\n    fragColor = vec4(color.grb*color.w,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKBWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 163, 181, 181, 224], [235, 235, 253, 253, 834], [855, 855, 875, 875, 997], [998, 998, 1023, 1023, 1221], [1223, 1223, 1278, 1278, 1731]], "test": "error"}
{"id": "wtKBzR", "name": "Circuit board fractal 4", "author": "jarble", "description": "I found a fractal pattern that looks like a printed circuit board.", "tags": ["fractal", "circuit"], "likes": 1, "viewed": 178, "published": "Public API", "date": "1613787326", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 triangle_wave(vec2 a,float scale){\n    return (abs(fract(a*scale)-.5));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    for(int c=0;c<3;c++){\n        float t1 = 5.0;\n\t    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1;\n        uv += vec2(iTime/2.0,iTime/3.0)/t1/2.0;\n        \n        float offset = .4;\n        float scale = 1.6;\n        for(int i=0;i<3;i++)\n        {\n          \n            uv = triangle_wave(uv.yx+offset,scale)+triangle_wave(uv,scale);\n            uv = triangle_wave(uv+col.xy,scale);\n        }\n     col[c] = fract((uv.x)-(uv.y));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKBzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 78], [80, 80, 137, 137, 674]], "test": "valid"}
{"id": "wtKfDD", "name": "Vorofbm", "author": "mrange", "description": "License CC0: Metallic Voronot Roses\nIf you got a decent height function, apply FBM and see if it makes it more interesting\nBased upon: https://www.shadertoy.com/view/4tXGW4\n", "tags": ["2d", "fbm", "voronot"], "likes": 25, "viewed": 338, "published": "Public API", "date": "1614373123", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License CC0: Metallic Voronot Roses\n//  If you got a decent height function, apply FBM and see if it makes it more interesting\n//  Based upon: https://www.shadertoy.com/view/4tXGW4\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define L2(x)       dot(x, x)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat pabs(float a, float k) {\n  return pmax(a, -a, k);\n}\n\nvec2 hash(vec2 p) {\n  p += 0.5;\n  p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));\n  return -1. + 2.*fract (sin (p)*43758.5453123);\n}\nfloat height_(vec2 p, float tm) {  \n  p *= 0.125*1.5;\n  vec2 n = floor(p + 0.5);\n  vec2 r = hash(n);\n  p = fract(p+0.5)-0.5;\n  float d = length(p);\n//  p.x = pabs(p.x, 0.025);\n//  p.x = abs(p.x);\n//  p *= ROT(-TIME*0.1-1.5*d-(-0.5*p.y+2*p.x)*1) ;\n  float c = 1E6;\n  float x = pow(d, 0.1);\n  float y = atan(p.x, p.y) / TAU;\n  \n  for (float i = 0.; i < 3.; ++i) {\n    float ltm = tm+10.0*(r.x+r.y);\n    float v = length(fract(vec2(x - ltm*i*.005123, fract(y + i*.125)*.5)*20.)*2.-1.);\n    c = pmin(c, v, 0.125);\n  }\n\n  return -0.125*pabs(1.0-tanh_approx(5.5*d-80.*c*c*d*d*(.55-d))-0.25*d, 0.25);\n}\n\n\nfloat height(vec2 p) {\n  float tm = TIME*0.00075;\n  p += 100.0*vec2(cos(tm), sin(tm));\n  const float aa = -0.35;\n  const mat2  pp = 0.9*(1.0/aa)*ROT(1.0);\n  float h = 0.0;\n  float a = 1.0;\n  float d = 0.0;\n  for (int i = 0; i < 6; ++i) {\n    h += a*height_(p, 0.125*TIME+10.0*sqrt(float(i)));\n    h = pmin(h, -h, 0.025);\n    d += a;\n    a *= aa;\n    p *= pp;\n  }  \n  return (h/d);\n}\n\nvec3 normal(vec2 p) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(4.0/RESOLUTION.y, 0);\n  \n  vec3 n;\n  n.x = height(p + e.xy) - height(p - e.xy);\n  n.y = 2.0*e.x;\n  n.z = height(p + e.yx) - height(p - e.yx);\n  \n  return normalize(n);\n}\n\nvec3 color(vec2 p) {\n  const float s = 1.0;\n  const vec3 lp1 = vec3(1.0, 1.25, 1.0)*vec3(s, 1.0, s);\n  const vec3 lp2 = vec3(-1.0, 1.25, 1.0)*vec3(s, 1.0, s);\n\n  float h = height(p);\n  vec3  n = normal(p);\n\n  vec3 ro = vec3(0.0, -10.0, 0.0);\n  vec3 pp = vec3(p.x, 0.0, p.y);\n\n  vec3 po = vec3(p.x, h, p.y);\n  vec3 rd = normalize(ro - po);\n\n  vec3 ld1 = normalize(lp1 - po);\n  vec3 ld2 = normalize(lp2 - po);\n  \n  float diff1 = max(dot(n, ld1), 0.0);\n  float diff2 = max(dot(n, ld2), 0.0);\n\n  vec3  rn    = n;\n  vec3  ref   = reflect(rd, rn);\n  float ref1  = max(dot(ref, ld1), 0.0);\n  float ref2  = max(dot(ref, ld2), 0.0);\n\n  vec3 lcol1 = vec3(1.5, 1.5, 2.0).xzy;\n  vec3 lcol2 = vec3(2.0, 1.5, 0.75).zyx;\n  vec3 lpow1 = 0.15*lcol1/L2(ld1);\n  vec3 lpow2 = 0.5*lcol2/L2(ld2);\n  vec3 dm = vec3(1.0)*tanh(-h*10.0+0.125);\n  vec3 col = vec3(0.0);\n  col += dm*diff1*diff1*lpow1;\n  col += dm*diff2*diff2*lpow2;\n  vec3 rm = vec3(1.0)*mix(0.25, 1.0, tanh_approx(-h*1000.0));\n  col += rm*pow(ref1, 10.0)*lcol1;\n  col += rm*pow(ref2, 10.0)*lcol2;\n\n  return col;\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, 1.0/vec3(2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = color(p);\n\n  col = tanh(0.33*col);\n  col = postProcess(col, q);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKfDD.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[0, 393, 421, 441, 517], [519, 519, 558, 558, 643], [645, 645, 684, 684, 713], [715, 715, 745, 745, 772], [774, 774, 793, 793, 928], [929, 929, 962, 962, 1524], [1527, 1527, 1549, 1549, 1909], [1911, 1911, 1932, 1932, 2138], [2140, 2140, 2160, 2160, 3192], [3194, 3194, 3230, 3230, 3463], [3465, 3465, 3520, 3520, 3729]], "test": "valid"}
{"id": "wtKfDw", "name": "Simple circle __", "author": "Envy24", "description": "Simple circle rendering", "tags": ["simple", "tutorial"], "likes": 0, "viewed": 30, "published": "Public", "date": "1614506037", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n    fragCoord.x = [0.5f; 800.5f].\n    fragCoord.y = [0.5f; 450.5f].\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float radius = (iResolution.y * 0.5f - 1.0f) * 0.5f;     // Circle radius.\n    float modulated =                                        // Sine modulated radius.\n        (radius + 1.0f) + sin(iTime) * radius; \n    \n    float x = fragCoord.x - iResolution.x * 0.5;             // Map x from [0.5f; 800.5f] to [-400.5f; 400.5f].\n    float y = fragCoord.y - iResolution.y * 0.5;             // Map y from [0.5f; 450.5f] to [-225.5f; 225.5f].\n\n    float distance = sqrt(x * x + y * y);                    // Distance from circle center to edge.\n    float sw = clamp((distance - modulated), 0.0f, 1.0f);    // If distance < 0.0f then sw = 1.0f, otherwise sw = 0.0f.\n\n    vec3 background = vec3(0.0f, 0.0f, 0.0f);                // Background rgb-color.\n    vec3 circle = vec3(1.0f, 1.0f, 1.0f);                    // Circle rgb-color.\n    vec3 color = mix(background, circle, sw);                // Pixel rgb-color.\n\n\n    fragColor = vec4(color, 1.0);                            // Pixel rgba-color.\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKfDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 75, 132, 132, 1133]], "test": "valid"}
{"id": "WtKfWR", "name": "two balls shadow version", "author": "gourki", "description": "its rolling", "tags": ["shadowraymarchin"], "likes": 1, "viewed": 152, "published": "Public API", "date": "1614177011", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n//thanks inigo quilez !\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p)-s;\n}\n\n\nvec3 opRep(vec3 p, vec3 c){\n    return mod(p+0.5*c,c) -0.5*c;\n\n}\n\nvec2 uVec2(vec2 s1, vec2 s2)\n{\n    return (s1.x < s2.x) ? s1 : s2;\n}\n\nvec2 opSmoothUnionVec2( vec2 d1, vec2 d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n    }\n    \n    \n\n        \nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n \nvec2 minVec2(vec2 d1, vec2 d2)\n{\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\n// ****** MAP ******\nvec2 map(vec3 pos)\n{\n    vec3 pos2 = pos;\n    \n    //pos = opRep(pos,vec3(30.,0.0,10.0));\n    vec2 s1 = vec2(sdSphere(pos+vec3(2.*sin(iTime),.0,2.*cos(iTime)), 1.0),.0);\n    vec2 s2 = vec2(sdSphere(pos+vec3(-2.*sin(0.5*iTime),.0,-2.*cos(0.5*iTime)), 1.0),1.0);\n    \n    //ground.x += 1. + sin(iTime);  \n    //ground *= rot(0.1*mod(iTime,26.));\n    \n    vec2 world = opSmoothUnionVec2(s1, s2,0.5);\n    vec2 ground = vec2(sin(iTime)+pos2.y+1.0,2.0);\n   \n    world = opSmoothUnionVec2(ground, world,0.5);\n   \n    return world;\n}\n\n\nfloat GetShadow (vec3 pos, vec3 at, float k) {\n    vec3 dir = normalize(at - pos);\n    float maxt = length(at - pos);\n    float f = 01.;\n    float t = 0.001*50.;\n    for (float i = 0.; i <= 10.0; i += .1) {\n        float dist = map(pos + dir * t).x;\n        if (dist < 0.001) return 0.;\n        f = min(f, k * dist / t);\n        t += dist;\n        if (t >= maxt) break;\n    }\n    return f;\n}\n\nvec3 Getnormal(vec3 pos)\n{\n    float v = map(pos).x;\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n        map(pos+e.xyy).x,\n        map(pos+e.yxy).x,\n        map(pos+e.yyx).x) - v);\n}\n\n\nvec2 CastRay(vec3 ro, vec3 rd)\n{\n    float c = 0.0; // si y a contact, \"c\" va stocker sa distance\n    \n    for(int i=0; i<64; i++)\n    {\n        vec2 ray = map(ro + rd * c); // POUR LE MOMENT, on va changer après\n    \n        if(ray.x < (0.0001*c))\n        {\n            return vec2(c,ray.y);\n        }\n        \n        c += ray.x;\n    }\n    \n    // si la marche est trop longue, ca renvoit -1.0\n    return vec2(-1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd) // ray origin & ray direction)\n{\n    // *** RAYMARCHING\n    vec2 contact = CastRay(ro, rd); // ici on ajoutera le raymarching\n    // simulation de raymarching\n    \n    vec3 pos = ro + rd * contact.x;\n    vec3 nor = Getnormal(pos);\n    \n    vec3 lightPos = vec3(sin(iTime), -1.0, cos(iTime))*5.0;\n    vec3 lightTar = vec3(0.,0.,0.);\n    vec3 lightDir = normalize(lightTar -lightPos);\n    \n    float shade = GetShadow(pos, -lightPos,8.);\n    \n    float lambert = dot(nor,lightDir);\n    float blinn = pow(lambert,16.0);\n    float toon = step(lambert, 0.5);\n    // *** Traitement du contact\n    vec3 col = vec3(0.0);\n    \n    if(contact.y == -1.0)\n    {\n        // y a pas de contact\n        col = vec3(mix(vec3(.8, .8, .0), vec3(.5,.0, 0.0), abs(rd.y)));\n    }\n    else\n    {\n        if(contact.y == 0.0)\n        {\n            col = vec3(1.0, 0.0, 0.0);\n        }\n        else if (contact.y == 1.0)\n        {\n            col = vec3(0.0, 1.0, 0.0);\n        }\n        else {\n            col = vec3(0.,0.,1.);\n        }\n        //col *= lambert*(1.-contact.y);\n        //col -= nor;\n         \n        col *= shade*lightDir*(lambert*.8)+.2;\n        //col += blinn*.8;\n        //col*=(1.0-toon)*.5+.5;\n        \n        float fresnel = pow((dot(nor, rd)+.8)*.9,2.)*2.0;\n       \n        col += fresnel;\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Centrer camera\n    vec2 uv = 2.0 * fragCoord/iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // Camera\n    vec3 cameraPos = vec3(.0, 3.0, 10.0);\n    vec3 cameraTar = vec3(0.,0.0,1.0);\n    \n    // view Direction / Ray Direction\n    vec3 forward = normalize(cameraTar - cameraPos);\n    vec3 right = normalize(cross(vec3(0.0, -1.0, 0.0), forward));\n    vec3 up = normalize(cross(right, forward));\n    vec3 viewDir = normalize(uv.x * right + uv.y * up + forward * 2.0);\n    \n    // Time varying pixel color\n    vec3 col = vec3(uv.x, uv.y, 0.0);\n\n    col = render(cameraPos, viewDir);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKfWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 75, 108, 108, 134], [137, 137, 164, 164, 201], [203, 203, 233, 233, 271], [273, 273, 326, 326, 434], [455, 455, 507, 507, 606], [608, 608, 680, 680, 723], [726, 726, 758, 758, 796], [798, 819, 839, 839, 1344], [1347, 1347, 1393, 1393, 1738], [1740, 1740, 1766, 1766, 1936], [1939, 1939, 1971, 1971, 2360], [2362, 2362, 2424, 2447, 3713], [3715, 3715, 3772, 3794, 4445]], "test": "valid"}
{"id": "wtKfWw", "name": "Fork Re Generat anotherpla 166", "author": "anotherplatypus", "description": "Experimenting on clubber.js and some shaders alters by Wizgrav to function with it.\nClubber rewired version of the awesome shader by kali  https://www.shadertoy.com/view/Xtf3Rn This guy is the math sculptor <3\n\nBoom Generators: https://goo.gl/XH88Gf", "tags": ["raymarching", "fractal", "clubber"], "likes": 2, "viewed": 221, "published": "Public API", "date": "1614497298", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// The following block is needed for Clubber integration\n#ifndef CLUBBER\nvec4 iMusic[4];\nconst float iTransition = 1.0;\n#define CLUBBER_R abs(sin(iTime))\n#define CLUBBER_G abs(cos(iTime))\n#define CLUBBER_B abs(sin(iTime*2.))\n#define CLUBBER_A 0.0\n#endif\n// Clubber end\n\n// \"GENERATORS REDUX\" by Kali \n\n// Reworked by eiffie to run faster and under ANGLE:\n//\n// -Made the sphere raytraced \n// -Soft AO shadows\n// -Various great optimizations\n// \n// Thanks eiffie!!!\n\n\n// Original description:\n// Same fractal as \"Ancient Temple\" + rotations, improved shading \n// (better coloring, AO and  shadows), some lighting effects, and a path for the camera  \n// following a liquid metal ball. \n\n\n//#define ENABLE_HARD_SHADOWS // turn off to enable faster AO soft shadows \n//#define ENABLE_VIBRATION\n//#define ENABLE_POSTPROCESS // Works better on window view rather than full screen\n\n\n#define RAY_STEPS 70\n#define SHADOW_STEPS 50\n#define LIGHT_COLOR vec3(.85,.9,1.)\n#define AMBIENT_COLOR vec3(.8,.83,1.)\n#define FLOOR_COLOR vec3(1.,.7,.9)\n#define ENERGY_COLOR vec3(1.,.7,.4)\n#define BRIGHTNESS .9\n#define GAMMA 1.3\n#define SATURATION .85\n\n\n#define detail .00005\n#define t iTime*.25\n\n\n\nvec3 lightdir=normalize(vec3(0.5,-0.3,-1.));\nvec3 ambdir=normalize(vec3(0.,0.,1.));\nconst vec3 origin=vec3(0.,3.11,0.);\nvec3 energy=vec3(0.01);\n#ifdef ENABLE_VIBRATION\nfloat vibration=sin(iTime*60.)*.0013;\n#else\nfloat vibration=0.;\n#endif\nfloat det=0.0;\nvec3 pth1;\n\n\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\n\nvec3 path(float ti) {\nreturn vec3(sin(ti),.4-sin(ti*.632)*.3,cos(ti*.5))*.5;\n}\n\nfloat Sphere(vec3 p, vec3 rd, float r){//A RAY TRACED SPHERE\n\tfloat b = dot( -p, rd );\n\tfloat inner = b * b - dot( p, p ) + r * r;\n\tif( inner < 0.0 ) return -1.0;\n\treturn b - sqrt( inner ) / dot(CLUBBER_R,CLUBBER_G);\n}\n\nvec2 de(vec3 pos) {\n\tfloat hid=0.;\n\tvec3 tpos=pos;\n\ttpos.xz=abs(.5-mod(tpos.xz,1.));\n\tvec4 p=vec4(tpos,1.);\n\tfloat y=max(0.,.35-abs(pos.y-3.35))/.35;\n\tfor (int i=0; i<8; i++) {//LOWERED THE ITERS\n\t\tp.xyz = abs(p.xyz)-vec3(-0.02,1.98,-0.02);\n\t\tp=p*(2.0+vibration*y)/clamp(dot(p.xyz,p.xyz),.4,1.)-vec4(0.5,1.,0.4,0.);\n\t\tp.xz*=mat2(-0.416, -0.91,mix(0.7,.91,CLUBBER_G),mix(-0.8,-.416,CLUBBER_B));\n\t}\n\tfloat fl=pos.y-3.013;\n\tfloat fr=(length(max(abs(p.xyz)-vec3(0.1,5.0,0.1),vec3(0.0)))-0.05)/p.w;//RETURN A RRECT\n\t//float fr=length(p.xyz)/p.w;\n\tfloat d=min(fl,fr);\n\td=min(d,-pos.y+3.95);\n\tif (abs(d-fl)<.001) hid=1.;\n\treturn vec2(d,hid);\n}\n\n\nvec3 normal(vec3 p) {\n\tvec3 e = vec3(0.0,det,0.0);\n\t\n\treturn normalize(vec3(\n\t\t\tde(p+e.yxx).x-de(p-e.yxx).x,\n\t\t\tde(p+e.xyx).x-de(p-e.xyx).x,\n\t\t\tde(p+e.xxy).x-de(p-e.xxy).x\n\t\t\t)\n\t\t);\t\n}\n\nfloat shadow(vec3 pos, vec3 sdir) {//THIS ONLY RUNS WHEN WITH HARD SHADOWS\n\tfloat sh=1.0;\n\tfloat totdist =2.0*det;\n\tfloat dist=10.;\n\tfloat t1=Sphere((pos-.005*sdir)-pth1,-sdir,0.015);\n\tif (t1>0. && t1<.5) {\n\t\tvec3 sphglowNorm=normalize(pos-t1*sdir-pth1);\n\t\tsh=1.-pow(max(.0,dot(sphglowNorm,sdir))*1.2,3.);\n\t} \n\t\tfor (int steps=0; steps<SHADOW_STEPS; steps++) {\n\t\t\tif (totdist<.6 && dist>detail) {\n\t\t\t\tvec3 p = pos - totdist * sdir;\n\t\t\t\tdist = de(p).x;\n\t\t\t\tsh = min( sh, max(50.*dist/totdist,0.0) );\n\t\t\t\ttotdist += max(.01,dist);\n\t\t\t}\n\t\t}\n\t\n    return clamp(sh,0.1,1.0);\n}\n\n\nfloat calcAO( const vec3 pos, const vec3 nor ) {\n\tfloat aodet=detail*40.;\n\tfloat totao = 0.0;\n    float sca = 14.0;\n    for( int aoi=0; aoi<5; aoi++ ) {\n        float hr = aodet*float(aoi*aoi);\n        vec3 aopos =  nor * hr + pos;\n        float dd = de( aopos ).x;\n        totao += -(dd-hr)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - 5.0*totao, 0., 1.0 );\n}\n\nfloat texture2(vec3 p) {\n\tp=abs(.5-fract(p*10.));\n\tvec3 c=vec3(3.);\n\tfloat es, l=es=0.;\n\tfor (int i = 0; i < 10; i++) { \n\t\t\tp = abs(p + c) - abs(p - c) - p; \n\t\t\tp/= clamp(dot(p, p), .0, 1.);\n\t\t\tp = p* -1.5 + c;\n\t\t\tif ( mod(float(i), 2.) < 1. ) { \n\t\t\t\tfloat pl = l;\n\t\t\t\tl = length(p);\n\t\t\t\tes+= exp(-1. / abs(l - pl));\n\t\t\t}\n\t}\n\treturn es;\n}\n\nvec3 light(in vec3 p, in vec3 dir, in vec3 n, in float hid) {//PASSING IN THE NORMAL\n\t#ifdef ENABLE_HARD_SHADOWS\n\t\tfloat sh=shadow(p, lightdir);\n\t#else\n\t\tfloat sh=calcAO(p,-2.5*lightdir);//USING AO TO MAKE VERY SOFT SHADOWS\n\t#endif\n\tfloat ao=calcAO(p,n);\n\tfloat diff=max(0.,dot(lightdir,-n))*sh;\n\tfloat y=3.35-p.y;\n\tvec3 amb=max(.5,dot(dir,-n))*.5*AMBIENT_COLOR;\n\tif (hid<.5) {\n\t\tamb+=max(0.2,dot(vec3(0.,1.,0.),-n))*FLOOR_COLOR*pow(max(0.,.2-abs(3.-p.y))/.2,1.5)*2.;\n\t\tamb+=energy*pow(max(0.,.4-abs(y))/.4,2.)*max(0.2,dot(vec3(0.,-sign(y),0.),-n))*2.;\n\t}\n\tvec3 r = reflect(lightdir,n);\n\tfloat spec=pow(max(0.,dot(dir,-r))*sh,10.);\n\tvec3 col;\n\tfloat energysource=pow(max(0.,.04-abs(y))/.04,4.)*2.;\n\tif (hid>1.5) {col=vec3(1.); spec=spec*spec;}\n\telse{\n\t\tfloat k=texture2(p)*.23+.2; \n\t\tk=min(k,1.5-energysource);\n\t\tcol=mix(vec3(k,k*k,k*k*k),vec3(k),.3);\n\t\tif (abs(hid-1.)<.001) col*=FLOOR_COLOR*1.3;\n\t}\n\tcol=col*(amb+diff*LIGHT_COLOR)+spec*LIGHT_COLOR;\t\n\tif (hid<.5) { \n\t\tcol=max(col,energy*2.*energysource);\n\t}\n\tcol*=min(1.,ao+length(energy)*.5*max(0.,.1-abs(y))/.1);\n\treturn col;\n}\n\nvec3 raymarch(in vec3 from, in vec3 dir) \n\n{\n\tfloat ey=mod(t*.5 + (CLUBBER_A),1.);\n\tfloat glow,eglow,ref,sphdist,totdist=glow=eglow=ref=sphdist=0.;\n\tvec2 d=vec2(1.,0.);\n\tvec3 p, col=vec3(0.);\n\tvec3 origdir=dir,origfrom=from,sphNorm;\n\t\n\t//FAKING THE SQUISHY BALL BY MOVING A RAY TRACED BALL\n\tvec3 wob=cos(dir*500.0*length(from-pth1)+(from-pth1)*250.+iTime*10.)*0.0005;\n\tfloat t1=Sphere(from-pth1+wob,dir,mix(0.,0.02,CLUBBER_R));\n\tfloat tg=Sphere(from-pth1+wob,dir,mix(0.0,0.03,CLUBBER_R));\n\tif(t1>0.){\n\t\tref=1.0;from+=t1*dir;sphdist=t1;\n\t\tsphNorm=normalize(from-pth1+wob);\n\t\tdir=reflect(dir,sphNorm);\n\t} \n\telse if (tg>0.) { \n\t\tvec3 sphglowNorm=normalize(from+tg*dir-pth1+wob);\n\t\tglow+=pow(max(0.,dot(sphglowNorm,-dir)),5.);\n\t};\n\t\n\tfor (int i=0; i<RAY_STEPS; i++) {\n\t\tif (d.x>det && totdist<3.0) {\n\t\t\tp=from+totdist*dir;\n\t\t\td=de(p);\n\t\t\tdet=detail*(1.+totdist*60.)*(1.+ref*5.);\n\t\t\ttotdist+=d.x; \n\t\t\tenergy=ENERGY_COLOR*(1.5+sin(iTime*20.+p.z*10. + 6.*(CLUBBER_R)))*.25;\n\t\t\tif(d.x<0.015)glow+=max(0.,.015-d.x)*exp(-totdist);\n\t\t\tif (d.y<.5 && d.x<0.03){//ONLY DOING THE GLOW WHEN IT IS CLOSE ENOUGH\n\t\t\t\tfloat glw=min(abs(3.35-p.y-ey),abs(3.35-p.y+ey));//2 glows at once\n\t\t\t\teglow+=max(0.,.03-d.x)/.03*\n\t\t\t\t(pow(max(0.,.05-glw)/.05,5.)\n\t\t\t\t+pow(max(0.,.15-abs(3.35-p.y))/.15,8.))*1.5;\n\t\t\t}\n\t\t}\n\t}\n\tfloat l=pow(max(0.,dot(normalize(-dir.xz),normalize(lightdir.xz))),2.);\n\tl*=max(0.2,dot(-dir,lightdir));\n\tvec3 backg=.5*(1.2-l)+LIGHT_COLOR*l*.7;\n\tbackg*=AMBIENT_COLOR;\n\tif (d.x<=det) {\n\t\tvec3 norm=normal(p-abs(d.x-det)*dir);//DO THE NORMAL CALC OUTSIDE OF LIGHTING (since we already have the sphere normal)\n\t\tcol=light(p-abs(d.x-det)*dir, dir, norm, d.y)*exp(-.2*totdist*totdist); \n\t\tcol = mix(col, backg, 1.0-exp(-1.*pow(totdist,1.5)));\n\t} else { \n\t\tcol=backg;\n\t}\n\tvec3 lglow=LIGHT_COLOR*pow(l,30.)*.5;\n\tcol+=glow*(backg+lglow)*1.3;\n\tcol+=pow(eglow,2.)*energy*.015;\n\tcol+=lglow*min(1.,totdist*totdist*.3);\n\tif (ref>0.5) {\n\t\tvec3 sphlight=light(origfrom+sphdist*origdir,origdir,sphNorm,2.);\n\t\tcol=mix(col*.3+sphlight*.7,backg,1.0-exp(-1.*pow(sphdist,1.5)));\n\t}\n\treturn col; \n}\n\nvec3 move(inout mat2 rotview1,inout mat2 rotview2) {\n\tvec3 go=path(t);\n\tvec3 adv=path(t+.7);\n\tvec3 advec=normalize(adv-go);\n\tfloat an=atan(advec.x,advec.z);\n\trotview1=mat2(cos(an),sin(an),-sin(an),cos(an));\n\t\t  an=advec.y*1.7;\n\trotview2=mat2(cos(an),sin(an),-sin(an),cos(an));\n\treturn go;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tpth1 = path(t+.3)+origin+vec3(0.,.01,0.);\n\tvec2 uv = fragCoord.xy / iResolution.xy*2.-1.;\n\tvec2 uv2=uv;\n#ifdef ENABLE_POSTPROCESS\n\tuv*=1.+pow(length(uv2*uv2*uv2*uv2),4.)*.07;\n#endif\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec2 mouse=(iMouse.xy/iResolution.xy-.5)*3.;\n\tif (iMouse.z<1.) mouse=vec2(0.);\n\tmat2 rotview1, rotview2;\n\tvec3 from=origin+move(rotview1,rotview2);\n\tvec3 dir=normalize(vec3(uv*.8,1.));\n\tdir.yz*=rot(mouse.y);\n\tdir.xz*=rot(mouse.x);\n\tdir.yz*=rotview2;\n\tdir.xz*=rotview1;\n\tvec3 color=raymarch(from,dir); \n\tcolor=clamp(color,vec3(.0),vec3(1.));\n\tcolor=pow(color,vec3(GAMMA))*BRIGHTNESS;\n\tcolor=mix(vec3(length(color)),color,SATURATION);\n#ifdef ENABLE_POSTPROCESS\n\tvec3 rain=pow(texture2(iChannel0,uv2+iTime*7.25468).rgb,vec3(1.5));\n\tcolor=mix(rain,color,clamp(iTime*.5-.5,0.,1.));\n\tcolor*=1.-pow(length(uv2*uv2*uv2*uv2)*1.1,6.);\n\tuv2.y *= iResolution.y / 360.0;\n\tcolor.r*=(.5+abs(.5-mod(uv2.y     ,.021)/.021)*.5)*1.5;\n\tcolor.g*=(.5+abs(.5-mod(uv2.y+.007,.021)/.021)*.5)*1.5;\n\tcolor.b*=(.5+abs(.5-mod(uv2.y+.014,.021)/.021)*.5)*1.5;\n\tcolor*=.9+rain*.35;\n#endif\n\tfragColor = vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKfWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[687, 1443, 1462, 1462, 1509], [1512, 1512, 1533, 1533, 1590], [1592, 1592, 1631, 1652, 1810], [1812, 1812, 1831, 1831, 2448], [2451, 2451, 2472, 2472, 2635], [2637, 2637, 2672, 2711, 3208], [3211, 3211, 3259, 3259, 3581], [3583, 3583, 3607, 3607, 3921], [3923, 3923, 3984, 4007, 5004], [5006, 5006, 5050, 5050, 7075], [7077, 7077, 7129, 7129, 7367], [7370, 7370, 7427, 7427, 8535]], "test": "error"}
{"id": "wtKGRz", "name": "24626.0", "author": "jorge2017a1", "description": "24626.0", "tags": ["246260"], "likes": 1, "viewed": 40, "published": "Public", "date": "1612190099", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define hit_background -1\n#define hit_sphere 1\n#define hit_plane 2\n#define hit_light 10\n\n#define pi 3.1415\n#define eps 0.0005\n#define INF 1e5\n\n#define max_bounces 4\n\n\n\n//========================================================================================================\n\n\nstruct Material {\n\tvec3 color;\t\t\n\tfloat refl;\t\t// reflection coefficient (0 - matt, 1 - mirror)\n};\n\n// Information about the intersection point of ray and any scene objects\nstruct Hit \n{\n\tint type;\t\t// object type\n\tvec3 pos;\t\t// point of intersection\n\tvec3 normal;\t\t// normal to object at intersection point\n\tMaterial material;\t// material of this object\n};\n\n\nstruct Sphere \n{\n\tvec3 crd;\t\t// coordinates\n\tfloat r;\t\t// radius\n\tMaterial material;\t// material\n};\n\n\t\n\n//========================================================================================================\n\n// field of view in degrees\nfloat fov = 90.0;\t\t\t\n\n// Objects in the scene\nconst int spheres_count = 2;\nconst int lights_count = 2;\nSphere spheres[spheres_count];\nSphere lights[lights_count];\n\nvoid setScene() \n{\n\tspheres[0] = Sphere(vec3(0.0, 1.0, 6.0 * cos(iTime)), 1.0, Material(vec3(0.8, 0.2, 0.2), 0.4));\n\tspheres[1] = Sphere(vec3(2.0, 1.0, 6.0 * sin(iTime)), 1.0, Material(vec3(0.2, 0.2, 0.8), 0.4));\n\tlights[0] = Sphere(vec3(3.0, 3.0, 3.0), 0.1, Material(vec3(1.0, 1.0, 1.0), 0.0));\n\tlights[1] = Sphere(vec3(-3.0, 3.0, 4.0), 0.1, Material(vec3(1.0, 1.0, 1.0), 0.0));\n\t\n\t// Move the light source\n\tlights[0].crd.xz = vec2(3.0 * cos(iTime), 3.0 * sin(iTime));\n\tlights[1].crd.y = 4.0 * abs(cos(iTime));\n}\n\n//========================================================================================================\n\nfloat intersectSphere(in vec3 ro, in vec3 rd, in Sphere sph) \n{\t\n\tvec3 oc = ro - sph.crd;\n\tfloat b = dot(oc, rd);\n\tfloat c = dot(oc, oc) - sph.r*sph.r;\n\tfloat d = b*b - c;\n\tif (d < 0.0) return INF;\n\tfloat t = -b - sqrt(d);\n\tif (t < 0.0) return INF;\n\treturn t;\n}\n\nfloat iPlane(in vec3 ro, in vec3 rd) \n{\n\t// Plane Equation: y = 0 = ro.y + t*rd.y\n\tfloat t = -ro.y/rd.y;\n\tif (t < 0.0)\n\t\treturn INF;\n\treturn t;\n}\n// Normal to the Plane\nvec3 nPlane(in vec3 pos)\n{\n\treturn vec3(0.0, 1.0, 0.0);\t\n}\n\n\n\nHit intersect(vec3 ro, vec3 rd) \n{\n\t\n\tfloat t = 150.0;\t\n\t\n\t// Info about the intersection\n\tint hit_type = hit_background;\t\t// type of intersection\n\tvec3 pos = vec3(0.0);\t\t\t// intersection point\n\tvec3 normal = vec3(0.0);\t\t// Normal at intersection point\n\tMaterial material = Material(vec3(0.5, 0.6, 0.7), 0.0);\n\t\n\t// Check intersections with spheres\n\tfor (int i = 0; i < spheres_count; i++) \n\t{\n\t\tfloat tmp = intersectSphere(ro, rd, spheres[i]);\n\t\tif (tmp < t) \n\t\t{\n\t\t\tt = tmp;\n\t\t\thit_type = hit_sphere;\n\t\t\tmaterial = spheres[i].material;\n\t\t\tpos = ro + rd*t;\n\t\t\tnormal = normalize(pos - spheres[i].crd);\n\t\t}\n\t}\n\t\n\t// Check intersection with Plane\n\tfloat tpla = iPlane(ro, rd);\n\tif (tpla < t)\n\t{\n\t\tt = tpla;\n\t\thit_type = hit_plane;\n\t\tmaterial.color = vec3(0.4, 0.4, 0.4);\n\t\tmaterial.refl = 0.2;\n\t\tpos = ro + rd*t;\n\t\tnormal = nPlane(pos);\n\t}\n\t\n\t// Check intersection with Light source\n\tfor (int i = 0; i < lights_count; i++)\n\t{\n\t\tfloat tmp = intersectSphere(ro, rd, lights[i]);\n\t\tif (tmp < t) \n\t\t{\n\t\t\tt = tmp;\n\t\t\thit_type = hit_light;\n\t\t\tmaterial = lights[i].material;\n\t\t\tpos = ro + rd*t;\n\t\t\tnormal = normalize(pos - lights[i].crd);\t\t\t\n\t\t}\n\t}\n\n\t// move the intersection point toward the camera a little, so the rays will not be blocked\n\tpos -= rd * eps;\n\t\n\treturn Hit(hit_type, pos, normal, material);\t\t\n}\n\nvec3 determineColor(Hit hit) \n{\n\t// if ray does not intersect scene object, no need to calculate further lighting\n\tif (hit.type == hit_background || hit.type == hit_light)\n\t\treturn hit.material.color;\n\t\n\tvec3 diffuse = vec3(0.0);\n\tvec3 ambient = vec3(0.2);\n\t\n\tfor (int i = 0; i < lights_count; i++) \n\t{\t\n\t\t// emit ray from this light source\n\t\tvec3 ro = hit.pos; \n\t\tvec3 rd = normalize(lights[i].crd - hit.pos);\n\t\t\n\t\tHit lightHit = intersect(ro, rd);\n\t\t\n\t\t// if the point light source is visible, add the diffuse component of this source\t\t\n\t\tif (lightHit.type == hit_light) \n\t\t\tdiffuse += (max(0.0, dot(rd, hit.normal))) * lightHit.material.color;\n\t}\n\t\n\tvec3 color = hit.material.color * clamp((diffuse + ambient), 0.0, 1.0);\n\t\n\treturn color;\n}\n\n\n// Ray tracing formula -> color = mix(color, reflColor, refl);\nvec3 traceRayX(vec3 ro, vec3 rd) \n{\t\t\n\tvec3 colors[max_bounces];\n\tfloat refls[max_bounces];\n\t\n\tfor (int i = 0; i < max_bounces; i++) {\n\t\tHit hit = intersect(ro, rd);\n\t\tcolors[i] = determineColor(hit);\n\t\trefls[i] = hit.material.refl;\n\t\t\n\t\tif (hit.type == hit_background || hit.type == hit_light)\n\t\t\tbreak;\n\t\t\n\t\tro = hit.pos;\n\t\trd = reflect(rd, hit.normal);\n\t}\n\t\n\tvec3 color = colors[max_bounces - 1];\n\t\n\tfor (int j = max_bounces - 2; j >= 0; j--) {\n\t\tcolor = mix(colors[j], color, refls[j]);\n\t}\n\treturn color;\t\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\t// Set the scene objects\n\tsetScene();\n\t\n\t// Calculate the current pixel coordinates with the aspect ratio of the resolution\n\tvec2 uv = (-1.0 + 2.0 * fragCoord.xy / iResolution.xy) / vec2(1.0, iResolution.x / iResolution.y);\n\t\n\t// kFov > 0\n\tfloat kFov = 1.0 / tan(radians(fov / 2.0));\t\t\n\t\t\n\t// generate ray from the origin ro in the direction of rd\n\tvec3 ro = vec3 (0.0, 1.0, 9.0);\n\tvec3 rd = normalize(vec3 (uv, -kFov));\n\t\t\n\t// Ray tracing\n\tvec3 col = traceRayX(ro, rd);\n\t\n\tfragColor = vec4(col, 1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKGRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[900, 1042, 1060, 1060, 1555], [1557, 1665, 1728, 1728, 1926], [1928, 1928, 1967, 2009, 2073], [2074, 2097, 2123, 2123, 2155], [2159, 2159, 2193, 2193, 3461], [3463, 3463, 3494, 3576, 4206], [4209, 4272, 4307, 4307, 4783], [4786, 4786, 4843, 4870, 5349]], "test": "valid"}
{"id": "WttBDN", "name": "Dots universe", "author": "abelu", "description": "Dots universe", "tags": ["noise", "random", "dots"], "likes": 1, "viewed": 188, "published": "Public API", "date": "1613288748", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision highp float;\n#endif\n\nfloat random(vec2 st) {\n  return fract(\n    sin(dot(st.xy, vec2(12.9898,78.233)) * 43758.5453123)\n  );\n}\n\n#define PI 3.1415926538\n#define SCALE 7.\n#define FACTOR .4\n#define SPEED .5\n#define LINE_THICKNESS 0.072\n#define POINT_SIZE 0.03\n#define TIME_SHIFT 100.0\n\nfloat lineSegment(vec2 p, vec2 a, vec2 b) {\n  vec2 pa = p - a;\n  vec2 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\n  return smoothstep(\n    0.0,\n    1.0 / iResolution.x + LINE_THICKNESS,\n    length(pa - ba * h)\n  );\n}\n\nvec2 getOffset(vec2 indecies) {\n  float noiseX = clamp(random(indecies.xy + 0.1), 0.0, 1.0);\n  float noiseY = clamp(random(indecies.yx + 0.1), 0.0, 1.0);\n  float seedX = sin(noiseX * TIME_SHIFT + iTime * noiseX * SPEED);\n  float seedY = cos(noiseY * TIME_SHIFT + iTime * 2.0 * noiseY * SPEED);\n\n  return vec2(\n    noiseX * FACTOR * seedX,\n    noiseY * FACTOR * seedY\n  );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  const vec2 center = vec2(0.5);\n\n  vec2 st = fragCoord / iResolution.y;\n  float scale = SCALE + sin(iTime * 0.1);\n  vec2 position = (st - center) * scale - center * scale;\n\n  st = fract(position);\n\n  vec2 indecies = floor(position);\n  vec2 point = getOffset(indecies) + center;\n  float pointAlpha = random(indecies.yx);\n  float size = POINT_SIZE + random(indecies) * 0.02 + 0.02 * (sin(iTime * random(indecies.yx)) * 0.5 + 0.5);\n  float shapeAlpha = smoothstep(\n    size,\n    size - 0.05,\n    length(st - point)\n  ) * pointAlpha;\n\n  float linesAlpha = 0.0;\n\n  for (float i = 0.0; i < 4.0; i += 1.0) {\n    float angle = PI * 0.5 * i;\n    vec2 shift = vec2(sin(angle), cos(angle));\n    vec2 to = getOffset(indecies + shift) + shift + center;\n\n    linesAlpha += max(\n      0.0,\n      (1.0 - lineSegment(st, point, to)) * (1.0 - distance(point, to)) * 2.0\n    );\n  }\n\n  const vec3 pointColor = vec3(0.99, 0.8, 0.99);\n  const vec3 linesColor = vec3(0.9, 0.5, 0.8);\n\n  vec3 color = pointColor * shapeAlpha + linesColor * linesAlpha;\n\n  // Output to screen\n  fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WttBDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 67, 67, 148], [305, 305, 348, 348, 546], [548, 548, 579, 579, 921], [923, 923, 978, 978, 2062]], "test": "valid"}
{"id": "WttBRl", "name": "A Rose is a Rose is a Rose", "author": "xavierseb", "description": "Here's some roses for Valentine's", "tags": ["recursion", "rose"], "likes": 12, "viewed": 263, "published": "Public API", "date": "1613256109", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// A rose is a rose is a rose -Gertrude Stein\n#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PI2 6.2832\n\nfloat mapLeaf(vec3 p, inout bool isbg) {\t // leaves\n\tp=mod(p+8.,vec3(16.))-8.; p.z-=5.; \n\tp.xy *= rot(PI2/4.);\n\tp.xy =  vec2( length(p.xy)*sin(atan(p.y, p.x)), length(p.xy) ); p.y-=10.;\n\tisbg = true;\n\treturn dot(abs(p), .5*normalize(vec3(1.5,abs(sin(atan(p.x,p.y)*80.)/30.+sin(min(p.y,12.)/8.)),26.))) - .16;  \n}\n\nfloat mapRose(vec3 p, inout bool isbg) { // roses\n\tp=mod(p+vec3(14.,14.,20.),vec3(28.,28.,40.))-vec3(14.,14.,20.); \n\tif(p.z>-11.|| p.z<-33. || length(p.xy)>11.) return mapLeaf(p, isbg);\n\tp.xy *= rot(p.z/.8)/3.5;\n\tp.xy = vec2( length(p.xy)*sin(atan(p.y, p.x)), length(p.xy)-.25 );   \n\tp.xy *= rot(atan(p.y,p.x)); \n\tp.z-=length(p.xy)/16.+2.8;\n\tp.yz = vec2( length(p.yz)*sin(mod(atan(p.z, p.y), PI2/3.) - PI2/3./2.), length(p.yz)-11.6 ); \t\t\t\n\tvec2 p1 = p.xy = vec2( length(p.xy)*sin(mod(atan(p.y, p.x), PI2/90.) - PI2/90./2.), length(p.xy) ); p.y-=8.9;\n\tp.yz *= rot(1.1);\n\tp.xy = vec2( length(p1)*sin(mod(atan(p1.y, p1.x), PI2/2.) - PI2/2./2.), length(p1)-3.5 )*(1.01-p.z)/2.9;\n\tp.z+=length(p.xy)/34.-2.8;\t\t\t\n\tisbg=false;\n\treturn dot(abs(p), normalize(vec3(11,2,4))) - .5;  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy -.5*iResolution.xy) /iResolution.y, m=iMouse.xy/iResolution.xy; \n\tvec3 rd = normalize(vec3(uv, .25+ min(1.,m.y))), p = vec3(0,0,-30);\n\tfragColor = vec4(0);\n\tbool isbg;\n\tp.xz *= rot(m.x*.5-.25);\tp.yz *= rot(sin(iTime)/12.);\n\t\n\tfor (int i=1; i<270; i++) {\n\t\tfloat d = mapRose(p,isbg);\n\t\tif (d < .001) {\n\t\t\tif(isbg) fragColor = vec4(0,400./float(i*i),0,1);\n\t\t\telse \t fragColor = vec4(40./float(i),0,0,1);\n\t\t\tbreak;\n\t\t}\n\t\tp += rd * d;\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WttBRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 119, 159, 170, 431], [433, 433, 473, 482, 1206], [1208, 1208, 1265, 1265, 1726]], "test": "valid"}
{"id": "WttBRN", "name": "Neural Shirt 3D", "author": "iuryBorgesRodrigues", "description": "Neural Shirt 3D", "tags": ["3d", "neural", "shirt"], "likes": 4, "viewed": 143, "published": "Public", "date": "1612360369", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//like the last few shaders I've published, this is a neural network experiment.\n//this time, the neural network reproduces an SDF given the x,y,z coordinates\n//using siren networks with skip connections: https://vsitzmann.github.io/siren/\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat scene(vec3 p) {\n    //sdf is undefined outside the unit sphere, uncomment to witness the abominations\n    if (length(p) > 1.) {\n        return length(p)-.8;\n    }\n    //neural networks can be really compact... when they want to be\n  vec4 f0_0=sin(p.y*vec4(-1.866,4.290,2.601,2.497)+p.z*vec4(.240,-.786,2.007,1.265)+p.x*vec4(3.956,1.460,1.367,.532)+vec4(-2.685,-3.509,.942,-.381));\nvec4 f0_1=sin(p.y*vec4(-3.606,1.369,-1.847,-3.740)+p.z*vec4(-.745,-.741,1.188,-1.510)+p.x*vec4(-.368,3.395,-.833,1.031)+vec4(4.373,6.283,-7.095,-1.042));\nvec4 f0_2=sin(p.y*vec4(3.353,-1.989,3.235,3.104)+p.z*vec4(-.739,-.478,.110,-3.318)+p.x*vec4(3.992,-2.669,-.891,3.172)+vec4(-1.647,-7.413,6.366,1.956));\nvec4 f0_3=sin(p.y*vec4(1.224,-2.609,3.491,-4.317)+p.z*vec4(-.348,3.840,-2.432,2.064)+p.x*vec4(-1.432,-1.402,.431,-2.045)+vec4(-6.209,1.668,7.858,-4.550));\nvec4 f1_0=sin(mat4(.014,-.273,.044,-.186,.368,-.189,.254,.030,-.648,.189,-.332,.323,.337,.339,-.492,-.028)*f0_0+\n    mat4(.407,-.565,-.255,-.003,.336,.225,-.805,-.425,-.014,.289,.488,-.621,-.346,.227,-.107,.202)*f0_1+\n    mat4(-.416,.375,.122,.071,-.178,-.079,.460,.123,-.150,.483,-.397,.356,-.340,.463,.013,-.052)*f0_2+\n    mat4(-.425,.126,.179,-.071,.209,.369,.292,-.178,-.636,-.014,-.016,.287,.360,-.224,.239,.301)*f0_3+\n    vec4(-1.605,-3.116,-1.730,-.855))/1.0+f0_0;\nvec4 f1_1=sin(mat4(.244,-.038,.421,-.013,-.095,.072,.130,.013,-.055,.306,-.783,-.132,.057,-.698,-.067,-.107)*f0_0+\n    mat4(-.699,-.057,.329,-.367,.053,.434,.443,.380,-.357,-.229,.461,.247,-.350,-.280,.467,.188)*f0_1+\n    mat4(.492,-.229,.402,-.282,-.156,-.242,-.537,.002,-.363,-.470,-.110,.251,-.040,.104,-.180,-.013)*f0_2+\n    mat4(-.687,.032,-.765,.017,-.570,-.398,-.276,.067,.085,.559,-.472,.109,.599,.487,-.061,-.528)*f0_3+\n    vec4(1.710,-2.917,1.681,-.757))/1.0+f0_1;\nvec4 f1_2=sin(mat4(.232,-.180,.275,.059,-.347,.318,.116,.307,-.016,-.107,-.056,-.447,-.394,.108,.020,.015)*f0_0+\n    mat4(.546,-.033,-.183,-.914,.251,-.235,-.322,.214,.325,-.162,-.122,.379,.316,.365,-.122,.292)*f0_1+\n    mat4(-.574,-.236,.422,-.388,-.585,.539,.296,-.816,-.263,.127,.147,.079,-.418,.217,-.045,-.008)*f0_2+\n    mat4(-.263,.876,.399,-.647,.235,.477,-.157,.266,-.846,-.373,-.397,-.032,.202,-.390,-.001,.341)*f0_3+\n    vec4(-1.371,-.316,-.784,-.519))/1.0+f0_2;\nvec4 f1_3=sin(mat4(.039,.116,-.504,-.110,-.353,.296,.158,.198,.168,.339,-.217,-.238,-.205,.167,-.078,.496)*f0_0+\n    mat4(-.297,-.465,-.127,.370,-.117,.058,.334,.383,.244,.307,.410,.410,.295,.502,-.302,-.188)*f0_1+\n    mat4(.294,-.281,.378,-.280,-.405,-.026,-.472,.210,-.218,1.199,.073,.531,.267,-.017,-.025,.322)*f0_2+\n    mat4(-.103,-.328,.102,.553,-.143,.098,-.063,-.017,.222,.096,-.083,.279,.080,.033,-.379,-.085)*f0_3+\n    vec4(-1.579,-1.434,.608,2.635))/1.0+f0_3;\nvec4 f2_0=sin(mat4(-.399,-.054,.100,-.464,-.072,.312,-.067,.262,.386,.426,.241,.108,-.137,.070,-.201,.139)*f1_0+\n    mat4(-.021,-.285,-.408,-.293,-.506,-.340,.362,-.341,.182,.491,.128,-.279,.307,.406,-.394,.034)*f1_1+\n    mat4(-.224,-.169,-.045,.403,-.418,.262,.217,-.369,.937,.175,-.006,.118,.159,-.458,-.340,-.195)*f1_2+\n    mat4(.070,.606,-.648,.477,.324,.478,-.206,.175,-.030,.316,-.206,-.128,.313,-.364,-.326,-.256)*f1_3+\n    vec4(1.716,.630,2.222,3.409))/1.4+f1_0;\nvec4 f2_1=sin(mat4(-.144,.197,-.043,-.262,-.041,.185,-.407,-.128,.431,-.075,.159,.073,-.632,-.370,.113,-.123)*f1_0+\n    mat4(-.551,.160,.538,-.000,-.378,-.116,-.304,-.027,-.294,.348,-.417,-.145,-.191,.221,.195,-.064)*f1_1+\n    mat4(.277,.233,-.286,-.034,.439,-.513,.443,-.515,.285,.076,-.097,-.296,-.124,.701,-.092,.186)*f1_2+\n    mat4(.174,.154,-.160,.320,-.048,.025,.046,.320,-.359,.510,.343,.274,.039,-.482,.511,-.406)*f1_3+\n    vec4(.388,-3.117,-1.149,-.658))/1.4+f1_1;\nvec4 f2_2=sin(mat4(.490,-.404,.185,-.223,.508,.023,-.206,.145,.184,.010,-.258,-.352,-.325,.504,.091,-.137)*f1_0+\n    mat4(-.325,.222,.098,.290,.028,.045,.452,-.676,-.130,.394,-.117,-.065,.100,-.041,-.288,-.379)*f1_1+\n    mat4(.047,.097,-.139,.176,-.327,.395,-.147,-.348,-.076,.183,.202,-.279,.023,-.232,.201,-.824)*f1_2+\n    mat4(-.909,.723,.511,-.357,.143,-.418,.156,-.093,-.051,.477,-.332,.080,.069,-.290,.071,.121)*f1_3+\n    vec4(-2.315,-.724,-.967,-2.472))/1.4+f1_2;\nvec4 f2_3=sin(mat4(-.332,-.204,.026,.339,.088,-.636,-.421,-.036,-.584,-.165,.131,-.237,.151,-.065,-.341,-.502)*f1_0+\n    mat4(.070,-.425,-.239,.292,.175,-.141,.027,.598,.554,-.239,-.209,-.283,-.097,.329,-.163,.681)*f1_1+\n    mat4(-.045,.175,-.584,.328,-.141,-.418,.047,.192,-.096,-.489,-.529,.101,.612,.252,.076,-.060)*f1_2+\n    mat4(.406,-.243,-.249,.549,-.350,.145,-.184,-.187,.278,-.337,.353,.916,.075,.523,.285,-.012)*f1_3+\n    vec4(-2.706,1.470,-1.238,1.607))/1.4+f1_3;\nvec4 f3_0=sin(mat4(-.669,-.403,.540,-.195,-.229,-.246,-.082,.213,.537,.235,.166,-.167,-.345,.376,.140,-.468)*f2_0+\n    mat4(.395,-.179,-.080,-.913,-.323,-.744,-.345,-.685,.075,.223,-.317,-.141,-.372,-.223,-.131,.452)*f2_1+\n    mat4(.018,.328,.322,.136,-.143,.090,.279,-.415,.314,-.240,-.267,.184,-.032,.181,-.506,.184)*f2_2+\n    mat4(-.351,.446,.158,-.265,-.079,.053,.352,.218,-.429,-.173,-.708,.250,.226,-.026,.100,.247)*f2_3+\n    vec4(.966,-1.657,3.050,-3.121))/1.7+f2_0;\nvec4 f3_1=sin(mat4(-.305,.293,-.331,.209,-.193,.339,-.480,-.423,-.657,-.276,.112,-.614,.317,-.544,-.320,.055)*f2_0+\n    mat4(-.720,-.238,-.316,.468,-.478,.162,.448,-.591,-.037,.318,-.188,-.500,.308,-.494,.430,.240)*f2_1+\n    mat4(.351,.055,-.189,.382,.100,-.251,.242,-.109,-.024,-.332,.016,-.007,.614,-.395,-.093,-.306)*f2_2+\n    mat4(.079,-.829,-.154,-.445,.183,-.024,-.061,-.053,.293,.607,-.023,-.141,-.098,-.014,.146,-.101)*f2_3+\n    vec4(-.944,-1.746,-1.011,-1.971))/1.7+f2_1;\nvec4 f3_2=sin(mat4(.648,-.186,-.272,-.479,.307,-.062,.420,.425,-.130,-.004,.507,-.141,.033,.415,.284,.403)*f2_0+\n    mat4(.128,.092,.481,.045,-.524,-.232,.497,-.311,-.736,-.516,.222,-.043,-.133,.479,-.342,-.421)*f2_1+\n    mat4(-.123,-.465,-.506,.458,.483,-.155,.530,-.242,-.072,-.052,-.128,-.015,-.134,-.354,-.399,.389)*f2_2+\n    mat4(-.182,-.369,-.282,-.180,.288,-.426,-.092,.408,.273,.268,-.046,.087,.035,-.322,-.297,-.134)*f2_3+\n    vec4(.780,.385,-.277,-1.990))/1.7+f2_2;\nvec4 f3_3=sin(mat4(.059,-.462,-.329,-.495,-.301,.109,.483,.615,.103,-.209,.199,.195,.150,-.430,.304,.313)*f2_0+\n    mat4(-.386,-.197,.181,-.187,.980,-.552,-.058,-.472,-.149,.175,-.306,-.221,-.696,-.962,-.612,.407)*f2_1+\n    mat4(-.250,.263,-.316,-.269,.662,-.201,.029,-.356,-.251,-.282,-.034,-.429,-.302,-.246,.368,.226)*f2_2+\n    mat4(.779,-.228,.025,-.429,-.164,.022,.171,-.472,.024,-.315,.413,-.292,.045,.387,-.295,-.285)*f2_3+\n    vec4(2.070,2.959,-1.704,3.077))/1.7+f2_3;\nvec4 f4_0=sin(mat4(.544,.069,-.513,-.047,-.142,.105,-.163,-.212,.216,.218,-.086,.362,.295,-.565,-.066,.314)*f3_0+\n    mat4(-.414,-.371,.505,.056,-.105,-.348,-.082,-.040,.285,.212,.002,.052,-.138,-.036,.220,-.482)*f3_1+\n    mat4(.243,-.491,-.649,.177,.084,.256,-.473,-.073,-.265,.423,-.223,-.692,.297,.081,-.063,.023)*f3_2+\n    mat4(.554,-.287,.559,-.900,.402,.484,-.315,.307,-.230,.031,.100,-.207,-.281,.326,.463,-.428)*f3_3+\n    vec4(-3.037,.146,-.877,2.857))/2.0+f3_0;\nvec4 f4_1=sin(mat4(-.515,.669,.090,.267,.255,-.076,.067,.246,.378,-.109,-.368,-.020,.344,.517,.485,.708)*f3_0+\n    mat4(.213,-.346,.298,-.252,-.460,-.228,-.620,-.396,-.164,.215,-.416,.520,-.150,.342,.322,.291)*f3_1+\n    mat4(.102,-.174,.185,.488,.211,.498,.078,-.106,-.102,-.460,.035,-.153,.249,-.586,.071,.149)*f3_2+\n    mat4(-.182,.378,-.452,-.311,.054,-.018,-.038,-.031,.090,.117,-.194,.080,.018,.057,.027,-.153)*f3_3+\n    vec4(-2.596,.079,-2.713,-.803))/2.0+f3_1;\nvec4 f4_2=sin(mat4(-.245,.304,-.154,-.302,.077,-.186,-.228,-.035,.419,-.104,-.181,.776,-.236,.299,-.055,-.318)*f3_0+\n    mat4(.124,.390,.517,.008,-.473,-.587,-.149,-.177,.393,.016,.285,.172,.052,-.312,.735,-.120)*f3_1+\n    mat4(-.249,.345,.124,-.182,-.313,-.039,.401,-.417,-.120,-.238,-.472,-.092,.512,-.225,-.596,-.430)*f3_2+\n    mat4(.332,.021,1.003,.163,.534,-.198,-.334,.506,-.385,.505,-.549,-.371,-.509,-.397,.240,-.508)*f3_3+\n    vec4(2.464,-.005,-2.892,.016))/2.0+f3_2;\nvec4 f4_3=sin(mat4(-.804,-.339,-.188,.288,.815,-.568,-.109,.533,.042,-.262,-.473,.048,-.127,.237,-.400,-.404)*f3_0+\n    mat4(-.389,.278,-.183,-.041,-.512,.175,.379,.010,-.585,-.513,.172,-.800,.217,-.276,.482,-.492)*f3_1+\n    mat4(-.311,.054,-.426,-.081,-.667,-.082,-.205,-.443,.608,.425,-.550,-.351,-.305,-.186,.042,-.024)*f3_2+\n    mat4(-.192,.167,-.869,-.217,-.198,-.284,-.225,.905,-.330,-.964,-.291,.272,.305,.364,-.049,-.314)*f3_3+\n    vec4(-.386,.098,2.374,.588))/2.0+f3_3;\nvec4 f5_0=sin(mat4(.550,-.662,.389,.939,-.051,-.473,.175,-.438,.103,-.729,.326,.236,-.220,-.523,.105,.487)*f4_0+\n    mat4(-.441,.281,-.389,-.639,-.537,.110,.020,.357,-.297,-.258,.365,.045,-.534,.461,.073,.314)*f4_1+\n    mat4(.279,-.426,-.367,.040,-.026,.324,.379,.290,.244,.716,-.086,-.667,.057,-.261,-.118,-.025)*f4_2+\n    mat4(-.132,-.362,.442,.417,-.621,.473,-.305,-.576,-.125,-.216,-.568,.191,.527,.329,.547,-.069)*f4_3+\n    vec4(-.563,.215,-1.059,-2.479))/2.2+f4_0;\nvec4 f5_1=sin(mat4(.269,.027,-.484,.846,.318,-.471,-.333,-.550,-.459,-.296,.272,-.040,.356,-.213,-.215,-.250)*f4_0+\n    mat4(.329,.292,.594,.121,.052,.502,.584,-.018,.420,.163,.101,.593,-.140,-.229,.311,-.565)*f4_1+\n    mat4(.436,.160,.018,-.205,-.150,-.444,.549,.406,-.309,-.395,.414,-.323,-.470,.050,-.077,.004)*f4_2+\n    mat4(-.380,.575,.089,.507,-.440,-.183,-.635,.574,.392,-.068,.023,-.493,-.144,.039,.412,-.037)*f4_3+\n    vec4(2.269,2.183,2.855,-1.143))/2.2+f4_1;\nvec4 f5_2=sin(mat4(.968,.461,-.225,-.008,.077,-.010,-.234,-.122,.010,.290,-.306,.432,-.192,-.273,.052,.178)*f4_0+\n    mat4(.054,-1.008,.030,.570,-.164,.466,.719,-.302,-.160,.618,-.487,.383,.427,.064,.141,-.139)*f4_1+\n    mat4(.499,-.171,-.051,-.012,.352,-.266,-.333,.867,.146,.109,.146,.397,.015,-.385,.363,-.038)*f4_2+\n    mat4(.488,.310,-.026,.289,.352,-.068,.470,-.312,-.218,.423,-.807,.050,.041,.315,-.412,-.159)*f4_3+\n    vec4(-1.077,2.860,-1.950,1.573))/2.2+f4_2;\nvec4 f5_3=sin(mat4(.915,.733,-.462,.326,-.081,-.240,-.106,-.034,.645,.015,-.191,-.148,.069,.323,-.153,-.175)*f4_0+\n    mat4(-.645,-.320,.171,.087,-.091,.405,-.187,-1.046,-.363,-.580,-.025,-.109,-.485,-.337,-.045,.599)*f4_1+\n    mat4(-.546,.250,-.135,.080,-.025,.260,-.158,.044,-.780,-.389,.157,-.414,-.188,.210,-.072,.360)*f4_2+\n    mat4(.381,.202,.010,-.178,.022,-.121,-.159,.295,-.429,-.748,-.027,.674,-.193,.121,.294,.394)*f4_3+\n    vec4(2.343,1.753,-1.476,.265))/2.2+f4_3;\nvec4 f6_0=sin(mat4(-.567,.302,.445,-.325,-.368,-.423,-.549,.455,-.298,-.186,-.098,.434,-.404,.057,-.936,.189)*f5_0+\n    mat4(.140,.065,.210,.292,.371,.058,.151,-.042,.376,-.159,-.028,.013,-.034,-.538,-.275,.544)*f5_1+\n    mat4(-.225,.156,-.156,-.348,-.380,.202,.391,.209,.186,-.460,.042,.711,-.587,.050,-.485,-.249)*f5_2+\n    mat4(.184,.098,-.297,-.752,.126,.277,-.776,-.178,-.189,.237,.719,.115,-.280,-.143,.332,.259)*f5_3+\n    vec4(.570,-2.839,.501,-1.388))/2.4+f5_0;\nvec4 f6_1=sin(mat4(.235,.294,-.032,.210,-.613,.503,-.480,-.233,.127,-.530,.078,.186,1.209,.724,.028,.802)*f5_0+\n    mat4(-.450,-.089,.622,-.001,-.742,-.175,-.392,.996,.132,-.018,.511,-.109,.107,.760,-.427,-.007)*f5_1+\n    mat4(-.135,.499,.266,.054,.398,.270,.494,-.394,-.599,.558,.343,-1.122,.136,.673,-.615,.543)*f5_2+\n    mat4(-.034,.825,-.068,-.416,-.354,.309,.195,.304,.529,-.252,.307,.271,-.293,-.041,.655,-.208)*f5_3+\n    vec4(-2.116,-.602,.156,3.043))/2.4+f5_1;\nvec4 f6_2=sin(mat4(-.017,.823,-.624,.268,.134,-.096,.387,-.263,.786,-.317,-.337,-.290,-.613,-.369,.341,-.335)*f5_0+\n    mat4(.047,.136,-.366,-.222,.507,-.311,-.380,-.074,.099,-.543,.321,.288,.014,-.183,.066,-.156)*f5_1+\n    mat4(.533,.914,-.390,.416,.407,.089,-.760,.356,-.650,-.442,-.064,.124,-1.310,.192,.832,-.567)*f5_2+\n    mat4(-.561,.547,.133,-.395,.424,.504,.354,.670,.291,-.080,.139,-.067,-.250,.198,.155,-.265)*f5_3+\n    vec4(-.025,-3.289,-2.495,-.184))/2.4+f5_2;\nvec4 f6_3=sin(mat4(-.259,-.279,.298,-.589,-.149,-.447,-.229,-.171,.555,-.322,.134,-.092,-.690,-.073,.327,.412)*f5_0+\n    mat4(.114,-1.166,-.372,.022,.117,.162,-.636,-.386,.199,.282,-.542,.499,.048,.387,.220,.186)*f5_1+\n    mat4(.153,-.387,-.026,-.563,.288,.008,-.000,-.237,.159,.392,-.132,-.837,.331,-.358,.391,-.030)*f5_2+\n    mat4(.725,-.242,-.334,-.470,-.053,-.301,.855,-.479,.493,-.048,-.232,.488,-.818,-.712,.319,-.365)*f5_3+\n    vec4(.649,2.270,-2.213,-1.682))/2.4+f5_3;\nvec4 f7_0=sin(mat4(.295,.024,.266,.193,-.230,-.254,.327,-.492,.100,.011,.379,-.050,-.493,-.600,.224,-.195)*f6_0+\n    mat4(.424,.114,-.564,.024,.358,.336,.326,.031,-.276,.196,-.474,.917,-.176,-.191,-.357,.808)*f6_1+\n    mat4(.259,.370,.032,.368,.328,.161,-.184,.066,.117,-.287,-.152,-.216,.003,.196,-.216,-.533)*f6_2+\n    mat4(-.224,.153,.302,-.281,-.098,.219,.315,-.244,.227,-.255,-.524,.172,-.096,-.096,.022,.473)*f6_3+\n    vec4(.277,-1.321,-2.988,.327))/2.6+f6_0;\nvec4 f7_1=sin(mat4(-.360,-.456,.254,.338,.071,.524,-.052,-.612,-.119,-.017,-.063,.228,-.355,.852,.047,.226)*f6_0+\n    mat4(.173,.767,.121,-.546,.452,-.107,-.089,-.583,.577,-.353,.628,.064,.284,.590,-.151,.334)*f6_1+\n    mat4(.107,-.792,.196,-.231,-.456,.511,-.377,-.075,-.323,.323,-.046,-.042,-.134,.262,-.229,-.557)*f6_2+\n    mat4(-.187,1.132,.299,-.487,-.098,-.397,-.438,.035,.035,.431,.044,.001,.419,.236,-.169,-.593)*f6_3+\n    vec4(-1.358,-2.203,-.447,-2.868))/2.6+f6_1;\nvec4 f7_2=sin(mat4(-.522,-.747,.001,.189,.269,.125,.423,-.416,-.342,.661,.153,.334,-.000,.721,.035,.620)*f6_0+\n    mat4(.257,.645,.440,-.146,-.719,-.455,-.859,-.357,.162,-.043,.112,.318,.321,-.537,.154,-.115)*f6_1+\n    mat4(-.106,.088,-.282,.794,.243,.277,-.626,.227,-.651,.270,.269,-.724,-.161,.286,.496,-.827)*f6_2+\n    mat4(-.528,-.445,-.670,-.901,-.422,-.102,-.365,.318,.720,.565,-.159,-.505,-.304,.159,.371,.600)*f6_3+\n    vec4(.838,-1.887,2.183,2.824))/2.6+f6_2;\nvec4 f7_3=sin(mat4(-.346,.252,-.124,-.094,-.040,-.990,.036,-.363,.062,.181,.021,-.412,-.013,-.042,.139,-.556)*f6_0+\n    mat4(.367,.367,.457,.650,-.549,-.066,.084,-.395,-.721,.656,.037,-.739,-.055,-.403,-.504,.004)*f6_1+\n    mat4(.534,-.290,.361,-.552,-.190,.013,.292,.145,.443,.154,-.386,.167,-.673,-.759,-.207,1.304)*f6_2+\n    mat4(.369,-.011,-.123,.761,.562,.103,-.283,-.039,.502,.113,.054,-.021,.615,.130,.119,-.175)*f6_3+\n    vec4(-.243,2.676,2.331,-.847))/2.6+f6_3;\nvec4 f8_0=sin(mat4(-.815,.138,1.119,-.066,.322,.368,-.427,-.627,-.490,-.237,.552,.620,-.124,-.203,-.137,.234)*f7_0+\n    mat4(.230,.120,-.098,-.027,.497,-.214,1.009,-.253,.348,-.012,-.203,-.056,.352,.206,-.356,-.295)*f7_1+\n    mat4(.207,-.105,.625,.387,.251,-.396,.342,-.812,-.090,-.371,-.386,-.529,.664,-.063,-.236,-.582)*f7_2+\n    mat4(-.575,.455,.135,.427,.355,-.211,.303,.129,.202,.077,.030,.139,.136,.021,.053,.287)*f7_3+\n    vec4(-1.948,-.654,-2.391,1.007))/2.8+f7_0;\nvec4 f8_1=sin(mat4(-.152,-.477,-.867,.005,.330,.490,.665,-.209,-1.217,-.336,-.161,-.009,-.858,.424,.049,.455)*f7_0+\n    mat4(-.115,-.209,-.524,.649,-.692,-.532,.246,.325,.109,-.311,-.163,.086,.345,.627,.316,.705)*f7_1+\n    mat4(-.299,.029,-.453,.643,.398,-.074,-.408,.371,.456,.416,.023,.123,-.211,.763,.680,-.636)*f7_2+\n    mat4(.335,.694,.380,.388,.100,-.057,.473,.259,-.053,-.209,-.506,.062,-.173,.251,-.564,.086)*f7_3+\n    vec4(1.154,-1.384,1.930,.064))/2.8+f7_1;\nvec4 f8_2=sin(mat4(.260,-.216,.240,-.445,.084,-.730,.590,.003,.048,-.519,-.302,.669,-.728,-.621,.118,.130)*f7_0+\n    mat4(.291,-.203,.622,-.454,-.148,-.389,.163,.596,-.220,-.463,.232,.313,-.164,-.045,.803,-.146)*f7_1+\n    mat4(.254,.773,-.763,.182,-.220,.751,.030,-1.108,-.235,-.575,.616,-.394,-.343,.132,.456,-.090)*f7_2+\n    mat4(.129,.476,-.429,-.650,-.692,-.012,-.084,-.211,.380,-.122,-.057,-.220,-.157,-.008,.012,-.551)*f7_3+\n    vec4(2.211,2.339,.816,2.304))/2.8+f7_2;\nvec4 f8_3=sin(mat4(.202,-.699,-.344,.165,.132,-.269,.180,-.254,-.185,.222,.351,.280,.091,-.177,.575,.031)*f7_0+\n    mat4(-.340,-.319,.753,-.029,.452,-.201,.188,-.082,.265,.673,.678,-.281,-.273,-.551,.374,.143)*f7_1+\n    mat4(.706,-.141,-.891,.058,.360,-.141,-.298,.389,-.060,-.121,.278,-.261,.245,1.102,.059,.166)*f7_2+\n    mat4(.367,.271,-.266,.135,.113,.030,-.201,-.104,.595,-.201,-.179,-.025,-.626,.563,.211,-.329)*f7_3+\n    vec4(-1.765,-1.128,-1.262,-1.918))/2.8+f7_3;\nreturn dot(f8_0,vec4(.044,-.061,-.031,-.035))+\n    dot(f8_1,vec4(-.041,.034,-.053,-.037))+\n    dot(f8_2,vec4(.044,.044,-.049,-.039))+\n    dot(f8_3,vec4(-.021,-.017,-.046,-.022))+\n    -0.082;\n\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 cam = normalize(vec3(1.5,uv));\n    vec3 init = vec3(-3.,0,0);\n    \n    float yrot = 0.5;\n    float zrot = iTime*.2;\n    if (iMouse.z > 0.) {\n        yrot += -4.*mouse.y;\n        zrot = 4.*mouse.x;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n    \n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 150 && !hit; i++) {\n        float dist = scene(p)-0.04;\n        hit = dist*dist < 1e-6;\n        p+=dist*cam;\n        if (distance(p,init)>5.) break;\n    }\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    //don't ask how I stumbled on this texture\n    vec3 nz = p - erot(p, vec3(1), 2.) + erot(p, vec3(1), 4.);\n    float spec = length(sin(r*3.5+sin(nz*120.)*.15)*.4+.6)/sqrt(3.);\n    spec *= smoothstep(-.3,.2,scene(p+r*.2));\n    vec3 col = vec3(1.0,0.0,0.0)*spec + pow(spec,8.);\n    float bgdot = length(sin(cam*8.)*.4+.6)/2.;\n    vec3 bg = vec3(.1,.1,.11) * bgdot + pow(bgdot, 10.);\n    fragColor.xyz = hit ? col : bg;\n    fragColor = smoothstep(-.02,1.05,sqrt(fragColor)) * (1.- dot(uv,uv)*.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WttBRN.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[194, 435, 473, 473, 535], [537, 537, 558, 644, 16709], [16711, 16711, 16730, 16730, 16846], [16848, 16848, 16905, 16905, 18180]], "test": "valid"}
{"id": "wttBzN", "name": "Fork Metallic L rsiqueira 120", "author": "rsiqueira", "description": "dwitter reference: https://www.dwitter.net/d/21550 ", "tags": ["lyapunov"], "likes": 0, "viewed": 64, "published": "Public", "date": "1612378128", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// More info here:  http://www.iquilezles.org/www/articles/lyapunovfractals/lyapunovfractals.htm\n        \n\n//for(i=2e3;i--;x.fillRect(i,t*240,h/=9,4)){I=i/430,Y=t/8-1,h=X=.5\n//for(n=9;n--;\n// X*=Y*I*(1-X)*(1-I*X*(1-X)));\n//h+=Math.log2((Y*I*(1-1.5*X))**2)}\n\n        \nvec3 calc( in vec2 p )\n{\n    float x = 0.4;\n\tfloat h = 0.5;\n\tfor( int i=0; i<11; i++ )\n\t{\n\n  x = p.x+p.y*p.y+2.*p.x*p.y*(1.+sin(iTime+p.x)) *p.x/x\n     +p.x*sin(1.+x+sin(iTime+x*1.1+p.y*1.+p.x));\n      h += log2(abs(p.y*(1.0-4.0*x+sin(iTime))));\n\n\n\t}\n    h /= 35.0;\n\n\n\th = abs(h);\n\tvec3 col = 1.5*( vec3(2.5, 1.0, 0.3) + h );\n\n\treturn col;\n}\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n vec3 col = calc( vec2(-4.4,-2.5) + 9.0*fragCoord/ iResolution.x )/5.;\n fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wttBzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[108, 268, 292, 292, 609], [612, 612, 669, 669, 773]], "test": "valid"}
{"id": "WttfR7", "name": "Segment - gradient 3D", "author": "iq", "description": "Computes the analytic gradient of a segment or capsule's SDF, which is much faster than doing it numerically (useful when the normal is needed inside the SDF evaluation itself or inside the raymarching loop for example).", "tags": ["3d", "sdf", "gradient", "normal", "analytic", "segment", "capsule"], "likes": 13, "viewed": 407, "published": "Public API", "date": "1612442384", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// sdgSegment() returns the segments/capsule SDF and its\n// analytical gradient. This means the normal to the \n// capsule's surface can be used during the raymarch loop\n// rather inexpensivelly (compared to sampling the SDF\n// multiple times to evaluate a normal for it)\n\n// Other SDF analytic gradients:\n//\n// Torus:   https://www.shadertoy.com/view/wtcfzM\n// Capsule: https://www.shadertoy.com/view/WttfR7\n\n\n// .x = f(p)\n// .y = ∂f(p)/∂x\n// .z = ∂f(p)/∂y\n// .w = ∂f(p)/∂z\n// .yzw = ∇f(p) with ‖∇f(p)‖ = 1\nvec4 sdgSegment( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 ba = b-a;\n    vec3 pa = p-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec3  q = pa-h*ba;\n    float d = length(q);\n    return vec4(d-r,q/d);    \n}\n\n\n#define AA 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*(iTime-10.0);\n\tvec3 ro = 1.2*vec3( 1.0*cos(an), 0.65, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n   \n    // animate torus\n    vec3  pa = vec3(-0.5,-0.4,-0.3);\n    vec3  pb = vec3( 0.2, 0.4, 0.1);\n    float ra = 0.25+0.2*sin(iTime);\n    \n    // render    \n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 5.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = sdgSegment(pos,pa,pb,ra).x;\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = sdgSegment(pos,pa,pb,ra).yzw;\n\n            // compute normal numerically, for comparison\n            // http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\n            #if 0\n            const vec2 e = vec2(1,-1);\n            const float eps = 0.0002;\n            nor = normalize( e.xyy*sdgSegment( pos + e.xyy*eps, pa, pb, ra ).x + \n                             e.yyx*sdgSegment( pos + e.yyx*eps, pa, pb, ra ).x + \n                             e.yxy*sdgSegment( pos + e.yxy*eps, pa, pb, ra ).x + \n                             e.xxx*sdgSegment( pos + e.xxx*eps, pa, pb, ra ).x );\n\n            #endif\n\n            float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.85,0.75,0.65)*dif;\n            col *= (0.5+0.5*nor)*(0.5+0.5*nor);\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WttfR7.jpg", "access": "shaders20k", "license": "mit", "functions": [[1488, 1605, 1657, 1657, 1831], [1848, 1848, 1905, 1930, 4266]], "test": "valid"}
{"id": "WttfWs", "name": "Spring Puddles, Sleeping Bugs", "author": "gunthern", "description": "A simple 2d pattern.", "tags": ["2d", "pattern"], "likes": 10, "viewed": 121, "published": "Public", "date": "1613848089", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float plot(in vec2 uv, in float pct) {\n    return smoothstep(pct-.01, pct, uv.y) - smoothstep(pct, pct+.01, uv.y);\n}\n\nfloat circle(in vec2 uv, in float radius, in vec2 center) {\n    vec2 l = uv - center;\n    return 1.0 - smoothstep(radius - (radius * .05),\n                            radius + (radius * .05),\n                            dot(l,l) * 4.0);\n}\n\nfloat box (in vec2 uv, in vec2 size, in vec2 center){\n    size = vec2(0.5) - size*.5;\n    vec2 st = smoothstep (size, size+vec2(0.005), uv - center);\n    st *= smoothstep (size, size+vec2(0.005),vec2(1.0) - (uv - center));\n    float box = st.x * st.y;\n\treturn box;\n}\n\nfloat plus (in vec2 uv, in float size, in vec2 center){\n    float box0 = box(uv, vec2(size,size*0.25), center);\n    float box1 = box(uv, vec2(size*0.25,size), center);\n    return box0 + box1;\n}\n\n//from the book of shaders\nvec2 rotate2D (vec2 uv, float angle) {\n    uv -= 0.5;\n    uv =  mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle)) * uv;\n    uv += 0.5;\n    return uv;\n}\n\n//from the book of shaders, ch.09\nvec2 rotateTilePattern(vec2 uv){\n\n    float PI = 3.14159265;\n\n    //  Scale the coordinate system by 2x2\n    uv *= 2.0;\n\n    //  Give each cell an index number\n    //  according to its position\n    float index = 0.0;\n    index += step(1., mod(uv.x,2.0));\n    index += step(1., mod(uv.y,2.0))*2.0;\n\n    //      |\n    //  2   |   3\n    //      |\n    //--------------\n    //      |\n    //  0   |   1\n    //      |\n\n    // Make each cell between 0.0 - 1.0\n    uv = fract(uv);\n\n    // Rotate each cell according to the index\n    if(index == 1.0){\n        //  Rotate cell 1 by 90 degrees\n        uv = rotate2D(uv,PI*0.5);\n    } else if(index == 2.0){\n        //  Rotate cell 2 by -90 degrees\n        uv = rotate2D(uv,PI*-0.5);\n    } else if(index == 3.0){\n        //  Rotate cell 3 by 180 degrees\n        uv = rotate2D(uv,PI);\n    }\n\n    return uv;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 color = vec3(0.95,0.97,0.93);\n    color = clamp(color,0.0,1.0);\n    \n    //tile\n    vec2 uvUntiled = uv;\n    uv *= 1.5;\n    uv = fract(uv);\n    uv = rotateTilePattern(uv);\n    \n    //grid\n    color -= plus(uv, 0.06, vec2(0.0));\n    color -= plus(uv, 0.06, vec2(0.0,0.5));\n    color -= plus(uv, 0.06, vec2(0.0,-0.5));\n    color -= plus(uv, 0.06, vec2(0.5,-0.5));\n    color -= plus(uv, 0.06, vec2(-0.5,-0.5));\n    color -= plus(uv, 0.06, vec2(-0.5,0.5));\n    color -= plus(uv, 0.06, vec2(-0.5,0.0));\n    color -= plus(uv, 0.06, vec2(0.5,0.0));\n    color -= plus(uv, 0.06, vec2(0.5,0.5));\n    color = clamp(color,0.0,1.0);\n    \n    //magnifying glass\n    color -= vec3(circle(uvUntiled,0.0435,vec2(.5 * sin(iTime*.6)-.2,.5 * cos(iTime*.7))));\n    color += vec3(circle(uvUntiled,0.04,vec2(.5 * sin(iTime*.6)-.2,.5 * cos(iTime*.7)))) * vec3(.7,.9,1.);\n    color = clamp(color,0.0,1.0);\n    \n    //boxes\n    color -= vec3(box(uv, vec2(.0125,.5), vec2(-0.13,0.2)));\n    color -= vec3(box(uv, vec2(.4,.0125), vec2(-0.1,0.1)));\n    color -= vec3(box(uv, vec2(.4,.0125), vec2(-0.25,0.35)));\n    color -= vec3(box(uv, vec2(.32,.0125), vec2(0.3,0.25)));\n    color -= vec3(box(uv, vec2(.0125,.35), vec2(0.14,0.2)));\n    color -= vec3(box(uv, vec2(.0125,.275), vec2(0.4,0.175)));\n    color -= vec3(box(uv, vec2(.125,.0125), vec2(0.42,0.075)));\n    color -= vec3(box(uv, vec2(.0125,.295), vec2(0.35,-0.2)));\n    color -= vec3(box(uv, vec2(.155,.0125), vec2(0.37,-0.41)));\n    color -= vec3(box(uv, vec2(.0125,.16), vec2(0.42,-0.375)));\n    color -= vec3(box(uv, vec2(.1,.0125), vec2(0.125,-0.11)));\n    color -= vec3(box(uv, vec2(.1,.0125), vec2(0.135,-0.14)));\n    color -= vec3(box(uv, vec2(.1,.0125), vec2(0.115,-0.08)));\n    color -= vec3(box(uv, vec2(.0125,.175), vec2(-0.14,-0.32)));\n    color -= vec3(box(uv, vec2(.155,.0125), vec2(-0.11,-0.36)));\n    color -= vec3(box(uv, vec2(.0125,.255), vec2(-0.36,-0.2)));\n    color = clamp(color,0.0,1.0);\n    \n    //circles\n    \n    color -= vec3(circle(uv,0.0475,vec2(0.4 + sin(iTime*.06)*.08,0.6)));\n    color += vec3(circle(uv,0.04,vec2(0.4 + sin(iTime*.06)*.08,0.6))) * vec3(.2,.8,.85);\n    color = clamp(color,0.0,1.0);\n    \n    color -= vec3(circle(uv,0.0275 + sin(iTime*.075)*.01,vec2(0.2 + sin(iTime*.06)*.1,0.85)));\n    color += vec3(circle(uv,0.0225 + sin(iTime*.075)*.01,vec2(0.2 + sin(iTime*.06)*.1,0.85))) * vec3(.85,.8,.35);\n    color = clamp(color,0.0,1.0);\n    \n    color -= vec3(circle(uv,0.0375,vec2(0.72 + sin(iTime*.068)*.01,0.72 + cos(iTime*.068)*.02)));\n    color += vec3(circle(uv,0.0315,vec2(0.72 + sin(iTime*.068)*.01,0.72 + cos(iTime*.068)*.02))) * vec3(.85,.8,.35);\n    color = clamp(color,0.0,1.0);\n    \n    color -= vec3(circle(uv,0.0085,vec2(0.9 + sin(iTime*.58)*.01,0.9 + cos(iTime*.38)*.01)));\n    color += vec3(circle(uv,0.006,vec2(0.9 + sin(iTime*.58)*.01,0.9 + cos(iTime*.38)*.01))) * vec3(.2,.8,.85);\n    color = clamp(color,0.0,1.0);\n    \n    color -= vec3(circle(uv,0.014,vec2(0.9,0.65 + cos(iTime*.48)*.01)));\n    color += vec3(circle(uv,0.0105,vec2(0.9,0.65 + cos(iTime*.48)*.01))) * vec3(.2,.8,.85);\n    color = clamp(color,0.0,1.0);\n    \n    color -= vec3(circle(uv,0.02,vec2(0.85 + sin(iTime*.34)*.01,0.36)));\n    color += vec3(circle(uv,0.016,vec2(0.85 + sin(iTime*.34)*.01,0.36))) * vec3(.85,.8,.35);\n    color = clamp(color,0.0,1.0);\n    \n    color -= vec3(circle(uv,0.0035,vec2(0.86 + sin(iTime*.35)*.026,0.06)));\n    color += vec3(circle(uv,0.002,vec2(0.86 + sin(iTime*.35)*.026,0.06))) * vec3(.2,.8,.85);\n    color = clamp(color,0.0,1.0);\n    \n    color -= vec3(circle(uv,0.01,vec2(0.62 + sin(iTime*.25)*.01,0.1 + cos(iTime*.2)*.015)));\n    color += vec3(circle(uv,0.007,vec2(0.62 + sin(iTime*.25)*.01,0.1 + cos(iTime*.2)*.015))) * vec3(.2,.8,.85);\n    color = clamp(color,0.0,1.0);\n    color -= clamp(vec3(circle(uv,0.03,vec2(0.62,0.1))) - clamp(vec3(circle(uv,0.024,vec2(0.62,0.1))) + (1. - vec3(box(rotate2D(uv,.1 + sin(iTime)*.04 - .1), vec2(.17,.17), vec2(0.2,-0.32)))),0.0,1.0),0.0,1.0);\n    color = clamp(color,0.0,1.0);\n    \n    color -= vec3(circle(uv,0.006,vec2(0.6 + sin(iTime*.24)*.01,0.25)));\n    color += vec3(circle(uv,0.004,vec2(0.6 + sin(iTime*.24)*.01,0.25))) * vec3(.4 * cos(iTime)*.4,.8,.45*sin(iTime) + .1);\n    color = clamp(color,0.0,1.0);\n    \n    color -= vec3(circle(uv,0.016,vec2(0.14,0.27 + sin(iTime*.24)*.02)));\n    color += vec3(circle(uv,0.012,vec2(0.14,0.27 + sin(iTime*.24)*.02))) * vec3(.2,.8,.85);\n    color = clamp(color,0.0,1.0);\n    \n    color -= vec3(circle(uv,0.01,vec2(0.38 + sin(iTime*.44)*.01,0.17 + cos(iTime*.48)*.01)));\n    color += vec3(circle(uv,0.007,vec2(0.38 + sin(iTime*.44)*.01,0.17 + cos(iTime*.48)*.01))) * vec3(.85,.8,.35);\n    color = clamp(color,0.0,1.0);\n    \n    color -= vec3(circle(uv,0.00275,vec2(0.1,0.1)));\n    color += vec3(circle(uv,0.0015,vec2(0.1,0.1))) * vec3(.85,.8,.35);\n    color = clamp(color,0.0,1.0);\n    \n    color -= vec3(circle(uv,0.002,vec2(0.275,0.375)));\n    color += vec3(circle(uv,0.001,vec2(0.275,0.375))) * vec3(.2,.8,.85);\n    color = clamp(color,0.0,1.0);\n    \n    //squiggles\n    float rotationSquiggle1 = 2.5 + sin(iTime*.33)*.275;\n    vec2 uvSquiggle1 = uv + vec2(0.04,-0.2);\n    color -= plot(rotate2D(uvSquiggle1, rotationSquiggle1), (sin(rotate2D(uvSquiggle1, rotationSquiggle1).x*150. + sin(iTime*3.))*.01 + 0.355)) * box(rotate2D(uvSquiggle1, rotationSquiggle1), vec2(0.1,1.0), vec2(.0,-0.1));\n    color = clamp(color,0.0,1.0);\n    \n    float rotationSquiggle2 = 1.575 + sin(iTime*.2)*.2;\n    vec2 uvSquiggle2 = uv + vec2(-0.15,-0.05);\n    color -= plot(rotate2D(uvSquiggle2, rotationSquiggle2), (sin(rotate2D(uvSquiggle2, rotationSquiggle2).x*220. + sin(iTime*4.))*.01 + 0.355)) * box(rotate2D(uvSquiggle2, rotationSquiggle2), vec2(0.075,1.0), vec2(.0,-0.1));\n    color = clamp(color,0.0,1.0);\n    \n    float rotationSquiggle3 = 0. + sin(iTime*.36)*.12;\n    vec2 uvSquiggle3 = uv + vec2(0.42,-0.3);\n    color -= plot(rotate2D(uvSquiggle3, rotationSquiggle3), (sin(rotate2D(uvSquiggle3, rotationSquiggle3).x*120. + sin(iTime*5.))*.01 + 0.355)) * box(rotate2D(uvSquiggle3, rotationSquiggle3), vec2(0.075,1.0), vec2(.0,-0.1));\n    color = clamp(color,0.0,1.0);\n    \n    float rotationSquiggle4 = 1.5 + sin(iTime*.46)*.12;\n    vec2 uvSquiggle4 = uv + vec2(-0.07,0.23);\n    color -= plot(rotate2D(uvSquiggle4, rotationSquiggle4), (sin(rotate2D(uvSquiggle4, rotationSquiggle4).x*120. + sin(iTime*4.))*.01 + 0.355)) * box(rotate2D(uvSquiggle4, rotationSquiggle4), vec2(0.095,1.0), vec2(.0,-0.1));\n    color = clamp(color,0.0,1.0);\n    \n    float rotationSquiggle5 = .8 + sin(iTime*.46)*.12;\n    vec2 uvSquiggle5 = uv + vec2(.2,0.05);\n    color -= plot(rotate2D(uvSquiggle5, rotationSquiggle5), (sin(rotate2D(uvSquiggle5, rotationSquiggle5).x*220. + sin(iTime*3.))*.01 + 0.355)) * box(rotate2D(uvSquiggle5, rotationSquiggle5), vec2(0.095,1.0), vec2(.0,-0.1));\n    color = clamp(color,0.0,1.0);\n\n    //Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WttfWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 116], [118, 118, 177, 177, 356], [358, 358, 411, 411, 624], [626, 626, 681, 681, 819], [821, 848, 886, 886, 1017], [1019, 1053, 1085, 1085, 1897], [1899, 1899, 1954, 2003, 9020]], "test": "valid"}
{"id": "wttfzl", "name": "[RGR] Ray marching 2D", "author": "deeplo", "description": "ray marching", "tags": ["raymarching"], "likes": 2, "viewed": 42, "published": "Public", "date": "1613336474", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S             smoothstep\n\n#define EPSILON 0.0001\n\n#define BG_COLOR      vec3(0.01,0.01,0.01)\n\n#define MAX_DISTANCE  100000.0\n#define MAX_RM_STEPS  512\n#define MIN_DISTANCE  0.00001\n\n#define SPHERE_CENTER1 vec2(0.66,-0.33)\n#define SPHERE_CENTER2 vec2(-0.66,-0.66)\n#define SPHERE_CENTER3 vec2(-0.15,0.5)\n#define SPHERE_RADIUS1 0.050\n#define SPHERE_RADIUS2 0.250\n#define SPHERE_RADIUS3 0.125\n\n#define BOX_CENTER  vec2(0,-0.2)\n#define BOX_SIZE    vec2(0.3,0.1)\n#define BOX_ANGLE   3.14159/4.0\n#define BOX_CENTER2 vec2(0.35,0.33)\n#define BOX_SIZE2   vec2(0.1,0.4)\n#define BOX_ANGLE2  -3.15159/10.0\n\n#define LIGHT_POWER 2.0\n\nmat2 Rot(float a){\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat GetDistSphere(vec2 position, vec2 center, float radius){\n    // Init distance\n    float d = MAX_DISTANCE;\n    // Set origin on the sphere center\n    position -= center;\n    // compute length\n    d = length(position) - radius;\n    // Return distance\n    return d;\n}\n\nfloat GetDistAABB(vec2 position, vec2 center, vec2 size, float angle){\n    // Init distance\n    float d = MAX_DISTANCE;\n    // Set origin on the box center\n    position -= center;\n    // CHange origin according to box angle\n    position *= Rot(angle);\n    // compute length\n    d = length(max(abs(position)-size,vec2(0)));\n    // Return distance\n    return d;\n}\n\nfloat RayMarching(vec2 rayOrigin, vec2 rayDirection){\n    // Init distance\n    float marchDist = 0.0;\n    float dMin = MAX_DISTANCE;\n    // Ray Marching Loop\n    for(int i=0; i<MAX_RM_STEPS && dMin>MIN_DISTANCE && marchDist<MAX_DISTANCE;i++){\n        // Set the next marching point (origin + direction * distance)\n        vec2 p = rayOrigin + rayDirection * marchDist;        \n        // Get minimum distance to spheres, from the computed position\n        float dMin1 = GetDistSphere(p, SPHERE_CENTER1, SPHERE_RADIUS1);\n        float dMin2 = GetDistSphere(p, SPHERE_CENTER2, SPHERE_RADIUS2);\n        float dMin3 = GetDistSphere(p, SPHERE_CENTER3, SPHERE_RADIUS3);\n        // Get minimum distance to box\n        float dMin4 = GetDistAABB(p, BOX_CENTER, BOX_SIZE, BOX_ANGLE);\n        float dMin5 = GetDistAABB(p, BOX_CENTER2, BOX_SIZE2, BOX_ANGLE2);\n        // get minimum from all the minimum\n        dMin = dMin1;\n        dMin = min(dMin,dMin2);\n        dMin = min(dMin,dMin3);\n        dMin = min(dMin,dMin4);\n        dMin = min(dMin,dMin5);\n        // Increase total distance\n        dMin *= 0.5;\n        marchDist += dMin;\n    }\n    // Return distance\n    return marchDist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Get coords normallized according to Y resolution. Screen displays uv between -1/+1  \n    vec2 uv = (2.0*fragCoord/iResolution.xy)-1.0;\n\n    // Background color\n    vec3 bg = BG_COLOR*uv.x;\n    vec4 col = vec4(bg,1.0);\n\n    // Ray origin (mouse position)\n    vec2 M = iMouse.xy;\n    bool autoAnim = (M == vec2(0));\n    // Normalize mouse position\n    M = (2.0*M/iResolution.xy)-1.0;\n    \n    // Auto anim\n    if(autoAnim){\n        M  = vec2(0.55*cos(iTime),0.8*sin(iTime));\n        M += vec2(0.10,0.1);\n    }\n    vec2 rayOrigin = M;\n\n    // Ray direction\n    vec2 rayDirection = uv-rayOrigin;\n    float fading = length(rayDirection);\n    fading  = S(LIGHT_POWER,0.0,fading);\n    fading *= fading;\n\n    // Ray marching mask\n    float marchDist = RayMarching(rayOrigin,rayDirection);\n    float c = S(1.0-EPSILON,1.0,marchDist);\n\n    // distance mask\n    float K = -(c-S(-0.5,0.5,length(rayDirection)*0.5));\n    K = 1.0-S(0.15,1.0,K);\n    c = K;\n\n    // Light color\n    vec3 lightColor = vec3(abs(sin(iTime*0.1287))*0.5+0.5,\n                           abs(sin(iTime*0.5687))*0.5+0.5,\n                           abs(sin(iTime*0.3154))*0.5+0.5);\n    col.rgb += lightColor*c*fading;\n\n    // Draw Sphere obstacles\n    float d0 = length(uv-SPHERE_CENTER1);\n    float cS = S(SPHERE_RADIUS1+EPSILON, SPHERE_RADIUS1, d0);\n    d0 = length(uv-SPHERE_CENTER2);\n    cS += S(SPHERE_RADIUS2+EPSILON, SPHERE_RADIUS2, d0);\n    d0 = length(uv-SPHERE_CENTER3);\n    cS += S(SPHERE_RADIUS3+EPSILON, SPHERE_RADIUS3, d0);    \n    // Draw Box obstacles\n    d0 = length(max(abs((uv-BOX_CENTER)*Rot(BOX_ANGLE))-BOX_SIZE,vec2(0)));\n    cS += S(EPSILON, 0.0, d0);\n    d0 = length(max(abs((uv-BOX_CENTER2)*Rot(BOX_ANGLE2))-BOX_SIZE2,vec2(0)));\n    cS += S(EPSILON, 0.0, d0);\n    \n    cS *= c*fading;\n    col.rgb += vec3(cS);    \n\n    // Draw mouse pointer\n    float lightDist  = length(uv-M);\n    float lightAlpha = S(0.05,-0.001,lightDist); \n    col.rgb += lightColor * vec3(lightAlpha);\n\n    // Output\n    fragColor = col;    \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wttfzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[627, 627, 645, 645, 721], [723, 723, 785, 806, 993], [995, 995, 1065, 1086, 1356], [1358, 1358, 1411, 1432, 2535], [2537, 2537, 2594, 2686, 4600]], "test": "valid"}
{"id": "wttfzn", "name": "Diffeomorphism scale", "author": "bakugod", "description": "Scaled geometry", "tags": ["scale", "diffeomorphism"], "likes": 0, "viewed": 40, "published": "Public", "date": "1612182101", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float grid(vec2 st, float res, float scale)\n{\n  vec2 grid = fract(st*res);\n  return (step(scale,grid.x) * step(scale,grid.y));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy /iResolution.xy;\n\n    float a = uv[0];\n    float b = uv[1];\n    \n    vec2 manifold = vec2(\n        pow(a, 2.0) + \n        pow(b, 3.0), \n        pow(a, 2.0) - \n        pow(b, 3.0));\n    //ceil\n    vec2 manifold2 = vec2(\n        sin(pow(manifold[0], 2.0) + pow(manifold[1], 2.0)), \n        cos(pow(manifold[0], 2.0) + pow(manifold[1], 2.0)) );\n        \n    vec2 sur_def = vec2(\n    clamp(dFdx(manifold[0]/ manifold2[0])* iTime, .001, .002),\n    clamp(dFdy(manifold[0]/ manifold2[1])* iTime, .001, .002) );\n   \n   \n    float r = ceil( iTime + (manifold2[0]) + cos((manifold2[1])) );\n    float x = grid(manifold * manifold2 - r, .1 * r, .1);\n\n    \n    vec3 col = 0.6 + 0.3*cos(iTime+uv.xyx+vec3(0,8,16));\n    \n    fragColor.rgb = vec3( col * x );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wttfzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 45, 45, 128], [131, 131, 188, 188, 960]], "test": "valid"}
{"id": "wtV3zR", "name": "25147.1", "author": "jorge2017a1", "description": "25147.1", "tags": ["251471"], "likes": 1, "viewed": 40, "published": "Public", "date": "1612190459", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n\n// IT's strange, the version http://glslsandbox.com/e#25099.7\n// does not compile on my (cheap) desktop computer (without any error line)\n// but is ok on my old laptop...\n//\n// It looks like using a vec2 ( material , dist ) for the raymarching \n// is failing somewhere...\n//\n// Do you know why ?\n\n\n#define NB_ITER 64\n#define FAR \t100.\n\n\n//#define EDIT\n\nvec3 skyColor( vec2 uv)\n{\n\tvec3 col1 = vec3(.0, .4, .6);\n\tvec3 col2  = vec3(.6, .6,.4);\n\treturn mix (col1, col2, 1.-length(uv+vec2(.2, .3) ) / .5);\n}\nvec4 mapFloor ( vec3 pos )\n{\n\tvec3 col1 = vec3( 1., 0., 0.);\n\tvec3 col2 = vec3( 0., 1., 0.);\n\tfloat val = sign( fract( .25*pos.x) -.5 ) * sign( fract( .25*pos.z) -.5 );\n\tvec3 col =mix( col1, col2, val );\n\tfloat dist = pos.y;\n\treturn vec4( col, dist );\n}\n\nvec4 mapSphere( vec3 pos, float radius )\n{\n//\tfloat DEP_VAL =sin(time) +2.;\n\tfloat dist = length(  pos ) - radius;//+ .2*sin(DEP_VAL *pos.x + sin(5.*time)) * sin(DEP_VAL *pos.y+ cos(6.*time)) * sin(DEP_VAL *pos.z+ sin(time));\n\tvec3 col = vec3( 1.0, .2, .2 );\n\treturn  vec4( col, dist);\n}\n\n\nfloat Mylength( vec3 pos )\n{\n\treturn max(abs(pos.x), max( abs(pos.y), abs( pos.z)) );\n}\n\nfloat Mylength2( vec3 pos )\n{\n\treturn abs(pos.x) + abs(pos.y) + abs( pos.z);\n}\n\nvec4 mapCube( vec3 pos )\n{\n\t//vec4 ret = vec4( abs(atan (pos.x ) ) *abs(atan (pos.y ) ), .0, .0, 1.  );\n\t//vec4 ret = vec4(fract( pos.z ) > .5);\n\tvec3 col = vec3( .0, .9, .1);\n\tfloat dist = Mylength(  pos ) - 5.0;\n\treturn vec4( col, dist );\n}\n\n\nvec4 combine(vec4 val1, vec4 val2 )\n{\n\tif ( val1.w < val2.w ) return val1;\n\treturn val2;\n}\n\n\nvec4 subst( vec4 val1, vec4 val2 )\n{\n\tfloat dist = max(-val2.w, val1.w);\n\treturn vec4(vec3(val1), dist);\n}\n\n\nvec4 mapLotsOfSpheres( vec3 pos)\n{\n\tvec3 col = vec3(.3, .8, .2 );\n\tconst float radius=6.0;\n\tfloat dist = length( mod( pos+15., 30.)-15.) -radius;\n\treturn vec4( col, dist);\n}\nvec4 mapLotsOfCubes( vec3 pos)\n{\n\tvec3 col = vec3(.3, .8, .2 );\n\tconst float radius=6.0;\n\tfloat dist = Mylength( mod( pos+8., 16.)-8.) -radius;\n\treturn vec4( col, dist);\n}\n\nvec4 StrangeSphere( vec3 pos ) \n{\n\t//float move = sin(3.*time ) *.5 - 10.;\n\tfloat move = 10.;\n\tfloat rad = 10.;\n\tvec3 newPos = pos - vec3( .0+move, 5., 50.);\n\tvec4 val2 = mapSphere(newPos, rad );\n\tvec3 p = newPos;\n\tif (val2.w < .1 )\t// Optimization, don't try the strange thing outside the sphere\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tfloat t = float(i)*.11+0.004*iTime;\n\t\tfloat c = cos(t);\n\t\tfloat s = sin(t);\n\t\tmat2 m = mat2(c,-s,s,c);\n\t\tp.xy = m*p.xy;\n\t\t\t      \n\t\trad *= .5;\n\t\tp.x = p.x - rad*2.;\n\t\tvec3 p2 = p;\n\t\tp2.xzy=mod (p.xzy+rad, rad*2.5) -rad;\n\t\t//p2.z=mod (p.z+rad, rad*2.5) -rad;\n\t\t//p2=mod (p+rad, rad*2.5) -rad;\n\n\t\t//vec3 p2 = p;\n\t\tvec4 sph = mapSphere( p2, rad );\n\t\t//val2= combine(val2, sph);\n\t\tval2 = subst(val2, sph);\n\t\t//val2 = sph;\n\t}\n\treturn val2;\n}\n\n\n//#define MOVING_OBJECTS\nvec4 map( vec3 pos)\n{\n\tvec4 ret = mapFloor( pos );\n\n\tvec4 res = combine( ret, StrangeSphere(pos));\n\treturn res;\n}\n\nfloat ambientOcclusion(vec3 pos, vec3 norm)\n{\n    const int steps = 3;\n    const float delta = 0.50;\n\n    float a = 0.0;\n    float weight = 1.0;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta; \n        a += weight*(d - map(pos + norm*d).w);\n        weight *= 0.5;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k) {\n    float sh = 1.0;\n    float t = mint;\n    float h = 0.0;\n    for(int i = 0; i < 15; i++) {\n        if(t > maxt) continue;\n        h = map(ro + rd * t).w;\n        sh = min(sh, k * h / t);\n        t += h;\n    }\n    return sh;\n}\n\n//#define EDIT\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef EDIT\n\tgl_FragColor = vec4( .1);\n#else\n\tvec2 uv = ( fragCoord.xy / iResolution.xy );\n\tuv -= .5;\n\tuv.x *= iResolution.x / iResolution.y;\n\t//uv.x += cos( uv.x)*3.02;\n\t//float fish_eye =  -length(uv)*1.+ sin(time);\n\t//float fish_eye = sin(5.*uv.x) + sin(5.*uv.y) + 1.;\n\tfloat fish_eye =  1.;\n\tvec3 dir = vec3( uv, 1.0 + fish_eye);\n\tdir = normalize(dir);\n\t\n\tvec3 pos = vec3( .0+3.*iMouse.x, 8.1, .0+3.*iMouse.y);\n\t//vec3 pos = vec3( 20.*sin(time), 8.1, 20.*cos(time));\n\t\n\tfloat nbIterF = 0.;\n\tvec4 result;\n\tfor (int i =0; i < NB_ITER; i++)\n\t{\n\t\tresult = map( pos );\n\t\tpos += result.w * dir;\n\t\tif ( (pos.z > FAR) || (abs(result.w) < .001)) break;\n\t\t//if ( (pos.z > FAR)) break;\n\t\tnbIterF += 1.0;\t\n\t}\n\tvec3 col = result.xyz;\n\tif ( pos.z> FAR ) \n\t{\n\t\tcol = skyColor(uv);\n\t}\n\telse\n\t{\n\t\t//vec3 lightPos = vec3(10.* sin(3.*time) + 10., 8.5, 10.*cos(3.*time) + 30. );\n\t\tvec3 lightPos = vec3(1.* sin(3.*iTime) + 10., 8.5, 1.*cos(3.*iTime) + 30. );\n\t\tvec3 light2Pos = normalize( lightPos - pos);\n\t\tvec3 eps = vec3( .1, .0, .0 );\n\t\tvec3 n = vec3( result.w - map( pos - eps.xyy ).w,\n\t\t\t       result.w - map( pos - eps.yxy ).w,\n\t\t\t       result.w - map( pos - eps.yyx ).w );\n\t\tn = normalize(n);\n\t\t//col =abs(n);\n\t\t\t\t\n\t\tfloat lambert = max(.0, dot( n, light2Pos));\n\t\tcol *= vec3(lambert);\n\t\t\n\t\t//vec3 light = vec3( sin( time ), 20 , cos(time) );\n\t\t//col = col* vec3(dot ( -dir, n ));\n\t\t\n\t\t// specular : \n\t\tvec3 h = normalize( -dir + light2Pos);\n\t\tfloat spec = max( 0., dot( n, h ) );\n\t\tcol += vec3(pow( spec, 16.));\n\t\tcol *= ambientOcclusion( pos, n );\n\t\tcol *= softshadow(pos, light2Pos, .02, 5., 14. );\n\t\t//col = vec3(ambientOcclusion( pos, n ));\n\t\t\n\t}\n\t//vec3 col = vec3( nbIterF/64. );\n\tfragColor= vec4( col, 1.0);\n#endif\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtV3zR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[340, 356, 381, 381, 505], [506, 506, 534, 534, 759], [761, 761, 803, 836, 1048], [1051, 1051, 1079, 1079, 1138], [1140, 1140, 1169, 1169, 1218], [1220, 1220, 1246, 1364, 1462], [1465, 1465, 1502, 1502, 1555], [1558, 1558, 1594, 1594, 1664], [1667, 1667, 1701, 1701, 1840], [1841, 1841, 1873, 1873, 2012], [2014, 2014, 2047, 2088, 2781], [2784, 2809, 2830, 2830, 2922], [2924, 2924, 2969, 2969, 3271], [3273, 3273, 3357, 3357, 3585], [3587, 3602, 3659, 3659, 5377]], "test": "valid"}
{"id": "wtVBRw", "name": "Voronot Rose", "author": "mrange", "description": "Voronot Rose", "tags": ["2d", "voronot"], "likes": 37, "viewed": 450, "published": "Public API", "date": "1614104267", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License CC0: Voronot Rose\n//  Based upon: https://www.shadertoy.com/view/4tXGW4\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define L2(x)       dot(x, x)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat pabs(float a, float k) {\n  return pmax(a, -a, k);\n}\n\nfloat height(vec2 p) {\n  p *= 0.45;\n  float d = length(p);\n  p *= ROT(TIME*0.1-1.5*d) ;\n  float c = 1E6;\n  float x = pow(d, 0.1);\n  float y = atan(p.x, p.y) / TAU;\n  \n  for (float i = 0.; i < 3.; ++i) {\n    float v = length(fract(vec2(x - TIME*(i)*.005123, fract(y + i*.125)*.5)*20.)*2.-1.);\n    c = pmin(c, v, 0.125);\n  }\n\n  return -0.0125*pabs(tanh_approx(5.5*d-80.*c*c*d*d*(.55-d))-0.25*d, 0.25);\n}\n\nvec3 normal(vec2 p) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(4.0/RESOLUTION.y, 0);\n  \n  vec3 n;\n  n.x = height(p + e.xy) - height(p - e.xy);\n  n.y = 2.0*e.x;\n  n.z = height(p + e.yx) - height(p - e.yx);\n  \n  return normalize(n);\n}\n\nvec3 color(vec2 p) {\n  const float s = 1.0;\n  const vec3 lp1 = vec3(1.0, 1.25, 1.0)*vec3(s, 1.0, s);\n  const vec3 lp2 = vec3(-1.0, 1.25, 1.0)*vec3(s, 1.0, s);\n\n  float h = height(p);\n  vec3  n = normal(p);\n\n  vec3 ro = vec3(0.0, -10.0, 0.0);\n  vec3 pp = vec3(p.x, 0.0, p.y);\n\n  vec3 po = vec3(p.x, h, p.y);\n  vec3 rd = normalize(ro - po);\n\n  vec3 ld1 = normalize(lp1 - po);\n  vec3 ld2 = normalize(lp2 - po);\n  \n  float diff1 = max(dot(n, ld1), 0.0);\n  float diff2 = max(dot(n, ld2), 0.0);\n\n  vec3  rn    = n;\n  vec3  ref   = reflect(rd, rn);\n  float ref1  = max(dot(ref, ld1), 0.0);\n  float ref2  = max(dot(ref, ld2), 0.0);\n\n  vec3 lcol1 = vec3(1.5, 1.5, 2.0).xzy;\n  vec3 lcol2 = vec3(2.0, 1.5, 0.75).zyx;\n  vec3 lpow1 = 0.15*lcol1/L2(ld1);\n  vec3 lpow2 = 0.5*lcol2/L2(ld2);\n  vec3 dm = vec3(1.0)*tanh(-h*10.0+0.125);\n  vec3 col = vec3(0.0);\n  col += dm*diff1*diff1*lpow1;\n  col += dm*diff2*diff2*lpow2;\n  vec3 rm = vec3(1.0)*mix(0.25, 1.0, tanh_approx(-h*1000.0));\n  col += rm*pow(ref1, 10.0)*lcol1;\n  col += rm*pow(ref2, 10.0)*lcol2;\n\n  return col;\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, 1.0/vec3(2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = color(p);\n\n  col = 4.5*col;\n  // Workaround for some environments that seems to lack a vec3 version of tanh\n  col = vec3(tanh(col.x), tanh(col.y), tanh(col.z));\n  col = 1.0 -col;\n  \n  col = postProcess(col, q);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVBRw.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[0, 291, 319, 339, 415], [417, 417, 456, 456, 541], [543, 543, 582, 582, 611], [613, 613, 643, 643, 670], [672, 672, 694, 694, 1073], [1075, 1075, 1096, 1096, 1302], [1304, 1304, 1324, 1324, 2356], [2358, 2358, 2394, 2394, 2627], [2629, 2629, 2684, 2684, 3040]], "test": "valid"}
{"id": "wtVBWm", "name": "geometry and slices", "author": "sukupaper", "description": "Mainly inspired by an old Charlinu's work: https://www.instagram.com/p/BpG5c1WgAkN/\nI know, my code isn't that much efficient (':", "tags": ["raymarching", "abstract", "shapes", "geometry", "slices", "charlinu"], "likes": 7, "viewed": 104, "published": "Public", "date": "1614510307", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author: paperu\n// Title: geometry and slices\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\nfloat t;\nfloat aa;\n#define P 6.283185307\n\nvec4 mod289(vec4 g){return g-floor(g*(1./289.))*289.;}vec4 permute(vec4 g){return mod289((g*34.+1.)*g);}vec4 taylorInvSqrt(vec4 g){return 1.79284-.853735*g;}vec2 fade(vec2 g){return g*g*g*(g*(g*6.-15.)+10.);}float cnoise(vec2 g){vec4 v=floor(g.rgrg)+vec4(0.,0.,1.,1.),d=fract(g.rgrg)-vec4(0.,0.,1.,1.);v=mod289(v);vec4 r=v.rbrb,a=v.ggaa,p=d.rbrb,e=d.ggaa,c=permute(permute(r)+a),f=fract(c*(1./41.))*2.-1.,t=abs(f)-.5,b=floor(f+.5);f=f-b;vec2 m=vec2(f.r,t.r),o=vec2(f.g,t.g),l=vec2(f.b,t.b),u=vec2(f.a,t.a);vec4 n=taylorInvSqrt(vec4(dot(m,m),dot(l,l),dot(o,o),dot(u,u)));m*=n.r;l*=n.g;o*=n.b;u*=n.a;float i=dot(m,vec2(p.r,e.r)),x=dot(o,vec2(p.g,e.g)),s=dot(l,vec2(p.b,e.b)),S=dot(u,vec2(p.a,e.a));vec2 I=fade(d.rg),y=mix(vec2(i,s),vec2(x,S),I.r);float q=mix(y.r,y.g,I.g);return 2.3*q;}\nfloat rand(in vec2 st){ return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.585); }\nmat2 rot(in float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\nfloat sph(in vec3 p, in float r) { return length(p) - r; }\nfloat box(in vec3 p, in vec3 s) { p = abs(p) - s; return max(max(p.x, p.y), p.z); }\nfloat los(in vec3 p, in float s) { p = abs(p); return (p.x+p.y+p.z-s)*0.57735027; }\nfloat slices(in vec3 p, in float nb, in float f) {\n    float i = 1./nb;\n    return abs(mod(p.y, i) - i*.5) - i*f;\n}\n\nvec3 pgen;\nfloat df(in vec3 p) {\n    vec3 pp[4];\n    p.xz *= rot(t*2.);\n    p.xy *= rot(t*.5);\n    mat2 rotV1 = rot(-t);\n    \n    pp[0] = p + vec3(-0.672,0.562,-0.081);\n    pp[0].xz *= rotV1;\n    pp[0].xy *= rotV1;\n    float d0 = max(box(pp[0].yxz, vec3(.1,.1,.75)),slices(pp[0].yzx + t, 5., .25));\n    \n    pp[1] = p + vec3(0.928,-0.698,-0.081);\n    pp[1].xz *= -rotV1;\n    pp[1].xy *= rotV1;\n    float d1 = max(max(los(pp[1], .5),slices(pp[1], 10., .125)),pp[1].y);\n    \n    pp[2] = p + vec3(0.328,0.622,-0.081);\n    pp[2].xz *= rotV1;\n    pp[2].xy *= -rotV1;\n    float d2 = max(sph(pp[2], .3),slices(pp[2] - t, 5., .25));\n    \n    pp[3] = p + vec3(-0.104,-0.359,0.306);\n    float k = slices(pp[3].zxy, 10., .2);\n    pp[3].xz *= -rotV1;\n    pp[3].xy *= -rotV1;\n    float d3 = max(box(pp[3], vec3(.35)),k);\n    \n    float d = min(d0,min(d1,min(d2,d3)));\n    pgen = d == d0 ? pp[0]\n        : d == d1 ? pp[1]\n        : d == d2 ? pp[2]\n        : d == d3 ? pp[3] : vec3(0.);\n    return d;\n}\n\n#define LIM .001\nvec3 normal(in vec3 p) { float d = df(p); vec2 u = vec2(0.,LIM); return normalize(vec3(df(p + u.yxx),df(p + u.xyx),df(p + u.xxy)) - d); }\n\n#define MAX_D 10.\n#define MAX_IT 30\nstruct rmRes { vec3 pos; int it; bool hit; };\nrmRes rm(in vec3 c, in vec3 r) {\n    rmRes res;\n    res.pos = c;\n    res.hit = false;\n    for(int i = 0; i < MAX_IT; i++) {\n        float d = df(res.pos);\n        if(d < LIM) { res.hit = true; break; }\n        if(distance(c,res.pos) > MAX_D) break;\n        res.pos += d*r;\n        res.it = i;\n    }\n    return res;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = (fragCoord.xy - .5*iResolution.xy)/iResolution.y;\n    t = iTime*.1;\n    \n    vec3 c = vec3(0.,0.,-2.);\n    vec3 r = normalize(vec3(st,.5));\n\n    rmRes res = rm(c,r);\n    \n    vec3 colors[3];\n    colors[0] = mix(vec3(1.000,0.151,0.638),vec3(0.965,0.754,0.044),length(st)*2.5);\n    colors[1] = vec3(0.092,0.089,0.095) - rand(st+fract(t))*.1;\n    colors[2] = vec3(0.062,0.161,0.455) / length(st);\n    \n    float d1 = cnoise(st*5.+t)+cnoise(st*10.)-2.+length(st)*5.864;\n    float d2 = cnoise(st*5.+t+.1245)+cnoise(st*10.+8.5456)-2.+length(st)*5.864;\n    vec3 color = mix(colors[0],colors[1],vec3(step(0.,abs(d1)-.1)));\n    color = mix(color,colors[2],vec3(step(0.,d2)));\n    color = mix(colors[1],color,vec3(step(0.,abs(d2) - .1)));\n    \n    if(res.hit && step(0.,d2) != 1.) {\n        vec3 n = normal(res.pos);\n        vec3 l = normalize(vec3(-1.));\n        \n        float div = .075;\n        vec2 pp = vec2(mod(pgen.x, div) - div*(1. - dot(n,l)),pgen.y);\n        float d = dot(pp,vec2(1.,0.));\n        d = step(0.,d);\n        color = mix(colors[0],colors[1],d);\n    } else  {\n        color += pow(float(res.it)*.02,2.)*colors[2];\n    }\n\n    fragColor = vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVBWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 209, 229, 229, 263], [263, 263, 284, 284, 313], [313, 313, 340, 340, 366], [366, 366, 384, 384, 417], [417, 417, 438, 438, 993], [994, 994, 1017, 1017, 1081], [1082, 1082, 1104, 1104, 1149], [1151, 1151, 1185, 1185, 1209], [1210, 1210, 1243, 1243, 1293], [1294, 1294, 1328, 1328, 1377], [1378, 1378, 1428, 1428, 1493], [1506, 1506, 1527, 1527, 2482], [2501, 2501, 2525, 2525, 2638], [2722, 2722, 2754, 2754, 3038], [3040, 3040, 3095, 3095, 4277]], "test": "error"}
{"id": "wtVBzR", "name": "s t a r t i n g 2 ", "author": "sense", "description": "start\n\nplease hack this / mod this.. so i can learn some things :D ", "tags": ["start"], "likes": 2, "viewed": 36, "published": "Public", "date": "1613788462", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord+iResolution.xy/fragCoord/iResolution.x*0.0003;\n\n    // Time varying pixel color\n  vec3 col = 0.0045 * iResolution/iTime*cos(iTime-uv.x/vec3(20,70,12)) * iResolution*iTime*tan(iTime-uv.y/vec3(10,20,50))*(iTime/iResolution)* 0.00045*tan(iTime-uv.y/vec3(1000,2000,20400))/cos(0.004-iTime*iResolution*iTime*0.000000002);\n // vec3 col1 = 0.15 / 0.05*cos(iTime+uv.xyx/vec3(0,2,8));\n//  vec3 col2 = 0.30 - 0.000005*sin(iTime-uv.xyx/vec3(55,2,8));\n    // Output to screen\n\n \n//fragColor = iTime+fragColor+ 20.03 * iTime/sin(vec4(col,1.10));\n \nfragColor = (vec4(col,5.0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVBzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 697]], "test": "valid"}
{"id": "wtVfDD", "name": "Futuristic Space Travel System", "author": "lmno", "description": "welcome to the s.s. !#*!#*^*#!^#^#!^#^&.", "tags": ["cool", "spacetime", "futuristic"], "likes": 1, "viewed": 70, "published": "Public", "date": "1614436297", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//credits to Danilo Guanabara\n\n#define t iTime\n#define r iResolution.xy\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec3 c;\n\tfloat l,z=t;\n\tfor(int i=-100;i<100;i++) {\n\t\tvec2 uv,p=fragCoord.xy/r;\n\t\tuv=p;\n\t\tp-=.9;\n\t\tp.x*=r.x/r.y;\n\t\tz+=.107;\n\t\tl=length(p);\n\t\tuv+=p/l*(sin(z)+1.)*abs(sin(l*90000.-z*5.));\n\t\tc[i]=.100000/length(abs(mod(uv,10.)-.10));\n\t}\n\tfragColor=vec4(c/l,t);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVfDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 74, 130, 130, 390]], "test": "valid"}
{"id": "WtVfDm", "name": "SpiralExperiment - 2 Polygon ", "author": "Learner_CC", "description": "Learn from aiekick's Penta Spiral : https://www.shadertoy.com/view/WdV3R3", "tags": ["2dspiral"], "likes": 6, "viewed": 57, "published": "Public", "date": "1614488743", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define corner 6.0\nconst vec3 diffColor = vec3(0.5, 0.8, 1.0);\nconst vec3 specColor = vec3(0.7, 0.8, 0.8);\nconst vec3 baseColor = vec3(0.2,0.5,0.8);\n\nfloat spire(vec2 p, float num) {\n    float a = atan(p.y, p.x);\n    float l = log(length(p)) * 16.0 - iTime * 2.0;\n\n    return sin(cos(a * num) * 0.5 + a + l) * 0.5 + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    vec3 rd = normalize(vec3(uv, 1.0));\n    \n    float rotTime = 0.1 * iTime;\n    uv *= mat2(cos(rotTime), sin(rotTime), -sin(rotTime), cos(rotTime));\n\n    float a = atan(uv.y, uv.x) * 4.0 + iTime;\n    vec3 lp = vec3(cos(a), sin(a), -1);\n    float e = 1./ iResolution.y;\n    \n    float f = spire(uv, corner);\n    float fx = (spire(uv - vec2(e, 0.0), corner) - f);\n    float fy = (spire(uv - vec2(0.0, e), corner) - f);\n    \n    vec3 n = normalize(vec3(fx, fy, -1.));\n    vec3 ld = lp - vec3(uv, 0.0);\n    \n    float len = max(length(ld), 0.01);\n    ld /= len;\n    float atten = (f * f) / len;\n\n\tfloat diff = max(dot(n, ld), 0.);  \n    float spec = pow(max(dot( reflect(-ld, n), -rd), 0.), 2.); \n\n\n    vec3 color =  baseColor * vec3(2.0 * f * f- f);\n    color = smoothstep(0.05, 0.75, pow(color * color, specColor));\n    color = (color * 2.0 + diff * diffColor + spec) * atten;\n    \n    fragColor = vec4(sqrt(color), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVfDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[150, 150, 182, 182, 322], [324, 324, 381, 381, 1399]], "test": "valid"}
{"id": "WtVfDw", "name": "Danza de croma", "author": "ChemaSerrano", "description": "Croma", "tags": ["1"], "likes": 1, "viewed": 27, "published": "Public", "date": "1614472288", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circle(in vec2 pos, in float t, in float mult)\n{\n    vec2 center = vec2(0.5,0.5 * iResolution.y / iResolution.y);\n    vec2 v = vec2(center.x + cos(t) + 0.10, center.y + sin(t) * 0.1) - pos;\n    \n    float dist2 = dot(v, v);\n    float circles = 0.2 + cos(dist2 * mult) * 0.2;\n    float darkening = smoothstep(0.0, 0.5, 1.0 - length(v) * 2.0);\n    \n    return circles + darkening;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 pos = fragCoord.xy / iResolution.xy;\n    float t = iTime * 1.25;\n\n    //float r = circle(pos, t + 20.8,  10.0 + sin(t * 0.6 + 1.0) * 1.0);\n    //float g = circle(pos, t + 0.5,  10.0 + sin(t * 0.6 + 2.0) * 1.0);\n    float b = circle(pos, t + 20.3,  10.0 + sin(t * 0.6 + 3.0) * 1.0);\n    //float w = circle(pos, t + 0.1, 10.0 + sin(t + 4.0) * 2.0) * 1.35;\n    float y = circle(pos, t + 2.1, 10.0 + sin(t + 4.0) * 2.0) * 1.35;\n    fragColor = vec4(y*b, y/b, b*y,  1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVfDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 54, 54, 386], [388, 388, 443, 443, 921]], "test": "valid"}
{"id": "WtVfRD", "name": "Animus", "author": "rge15", "description": "Isn't my tutorial.\nYoutube Tutorial : https://www.youtube.com/watch?v=3CycKKJiwis&t=1329s", "tags": ["animus"], "likes": 0, "viewed": 60, "published": "Public API", "date": "1613995069", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(a,b,t) smoothstep(a,b,t)\n\nfloat DistLine(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float t = clamp(dot(pa,ba)/dot(ba,ba),0.,1.);\n    return length(pa-ba*t);\n}\n\nfloat N21(vec2 p)\n{\n    p = fract(p*vec2(233.34, 851.73));\n    p += dot(p,p+23.45);\n    return fract(p.x*p.y);\n}\n\nvec2 N22(vec2 p)\n{\n    float n = N21(p);\n    return vec2(n , N21(p+n));\n}\n\nvec2 GetPos(vec2 id, vec2 offs)\n{\n    vec2 n = N22(id+offs)*iTime;\n    return offs+sin(n)*0.3;\n}\n\nfloat Line(vec2 p , vec2 a, vec2 b)\n{\n    float d = DistLine(p,a,b);\n    float m = S(.03,.01,d);\n    m *= S(1.2,.8,length(a-b));\n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Origin at the middle and aspect ratio correct\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.x;\n\n    float m = 0.;\n    \n    uv *= 10.;\n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    \n    vec2 p[9];\n    int i = 0;\n    for(float y=-1. ; y<=1. ; y++)\n    {\n        for(float x =-1. ; x<=1. ; x++)\n        {\n            p[i++] = GetPos(id,vec2(x,y));         \n        }\n    }   \n    \n    for(int i = 0 ; i<9 ; i++)\n    {\n        m += Line(gv, p[4] , p[i]);\n        \n        vec2 j = (p[i]-gv)*15.;\n        float spk = 1./ dot(j,j);\n        m += spk*(sin(iTime+p[i].x*5.)*.5+.5);\n    }\n    \n    m += Line(gv, p[1] , p[3]);\n    m += Line(gv, p[1] , p[5]);\n    m += Line(gv, p[7] , p[3]);\n    m += Line(gv, p[7] , p[5]);\n    \n    vec3 col = vec3(m);\n    \n    //if(gv.x > .48 || gv.y > .48) col = vec3(1,0,0);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVfRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 76, 76, 194], [196, 196, 215, 215, 308], [310, 310, 328, 328, 383], [385, 385, 418, 418, 481], [483, 483, 520, 520, 627], [629, 629, 686, 738, 1551]], "test": "valid"}
{"id": "WtVfzR", "name": "19/02/2021 - live", "author": "anticore", "description": "Coded live on twitch\nhttps://twitch.tv/antic0re_", "tags": ["raymarch", "clouds", "volumetric"], "likes": 9, "viewed": 295, "published": "Public API", "date": "1613765868", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float ni(float x) {\n    //return texture(texFFTIntegrated, x).x;\n    return texelFetch( iChannel0, ivec2(x * 512.,0), 0 ).x * .0;\n}\n\nfloat hash13(vec3 p) {\n    p  = fract(p * .1031);\n    p += dot(p, p.zyx + 31.32);\n    return fract((p.x + p.y) * p.z);\n}\n\nvec3 hash33(vec3 p3) {\n    vec3 p = fract(p3 * vec3(.1031,.11369,.13787));\n    p += dot(p, p.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p.x + p.y)*p.z, (p.x+p.z)*p.y, (p.y+p.z)*p.x));\n}\n\n\n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n  \n    return mat2(c, s, -s, c);\n}\n\n\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\nfloat snoise(vec3 p) {\n\tvec3 s = floor(p + dot(p, vec3(F3)));\n\tvec3 x = p - s + dot(s, vec3(G3));\n\t \n\tvec3 e = step(vec3(0.0), x - x.yzx);\n\tvec3 i1 = e*(1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\tvec3 x1 = x - i1 + G3;\n\tvec3 x2 = x - i2 + 2.0*G3;\n\tvec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\tvec4 w, d;\n\t \n\tw.x = dot(x, x);\n\tw.y = dot(x1, x1);\n\tw.z = dot(x2, x2);\n\tw.w = dot(x3, x3);\n\t \n\tw = max(0.6 - w, 0.0);\n\t \n\td.x = dot(hash33(s), x);\n\td.y = dot(hash33(s + i1), x1);\n\td.z = dot(hash33(s + i2), x2);\n\td.w = dot(hash33(s + 1.0), x3);\n\t \n\tw *= w;\n\tw *= w;\n\td *= w;\n\t \n\treturn dot(d, vec4(52.0));\n}\n\nfloat snoiseFractal(vec3 m) {\n\treturn   0.5333333* snoise(m)\n\t\t\t\t+0.2666667* snoise(2.0*m)\n\t\t\t\t+0.1333333* snoise(4.0*m)\n\t\t\t\t+0.0666667* snoise(8.0*m);\n}\n\nfloat fbm (in vec3 st, int o) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < o; i++) {\n        value += amplitude * snoise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\n\nfloat worley(vec3 p, float scale){\n\n    vec3 id = floor(p*scale);\n    vec3 fd = fract(p*scale);\n\n    float n = 0.;\n\n    float minimalDist = 1.;\n\n\n    for(float x = -1.; x <=1.; ++x){\n        for(float y = -1.; y <=1.; ++y){\n            for(float z = -1.; z <=1.; ++z){\n\n                vec3 coord = vec3(x,y,z);\n                vec3 rId = hash33(mod(id+coord,scale))*0.5+0.5;\n\n                vec3 r = coord + rId - fd; \n\n                float d = dot(r,r);\n\n                if(d < minimalDist){\n                    minimalDist = d;\n                }\n\n            }//z\n        }//y\n    }//x\n    \n    return 1.0-minimalDist;\n}\n\n\nfloat wfbm (in vec3 st, int o, float s) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < o; i++) {\n        value += amplitude * worley(st, s);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\n\nfloat sdSphere(vec3 p, vec3 pos, float r) {\n    return length(p + pos) - r;\n}\n\nfloat sdBox(vec3 p, vec3 pos, vec3 b) {\n    p += pos;\n    //p.xz *= rot(0.6);\n    //p.xy *= rot(0.5);\n  \n    p.xz *= rot(iTime + ni(0.4));\n    p.xy *= rot(iTime + ni(0.2));\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec2 map(vec3 p) {\n    return vec2(sdBox(p, vec3(0.,0.,5. + sin(ni(0.1) * 100.)), vec3(1., 1., 1.)), 0.);\n}\n\nconst vec3 sundir = normalize( vec3(0.0,-1.0,-0.0) );\n\nvec3 tr(vec3 ro, vec3 rd, vec2 uv) {\n    float td = 1.;\n    vec2 h;\n  \n    vec4 sum = vec4(0);\n  \n    for (int i = 0; i < 100; i++) {\n        h = map(ro + rd * td);\n        td += max(h.x, 0.01);\n        \n            vec3 ip = ro + rd * td;\n        if (h.y == 0. && h.x < 0.01) {\n            ip.yz *= rot(iTime / 10.);\n            ip.xz *= rot(iTime / 10.);\n            float w = smoothstep(0.6, 1., worley(ip, 2.));\n            float s = snoiseFractal(ip*3.);\n            float f = fbm(ip, 8);\n          \n            //return vec3(1);\n            // F = 1/ e ^(t * d).\n            //c += f * 0.01 * exp(-h.x * 2);\n            //return vec3(w);\n            float den = f;\n            \n            if (den > 0.01) {\n               float df = fbm(ip + 0.1 * sundir, 8);\n               // do lighting\n               float dif = clamp((den - df)/0.3, 0.0, 1.0 );\n               vec3  lin = vec3(0.65,0.65,0.75)*1.1 + 0.8*vec3(sin(ip.x + iTime),0.6,cos(ip.y + iTime))*dif;\n               //return vec3(lin);\n               vec4  col = vec4( mix( vec3(cos(ip.y + iTime / 2.) + 0.5,0.95,sin(iTime / 3. + ip.z) + 0.5), vec3(0.25,0.3,0.35), den ), den );\n                \n               col.xyz *= lin;\n               // fog\n               //col.xyz = mix(col.xyz,vec3(0,0,0), 1.0-exp2(-0.075*t));\n              \n              \n                //return col.xyz;\n               // composite front to back\n               //col.w    = min(col.w*8.0*h.x,1.0);\n               //col.rgb *= col.a;\n              \n               sum += col*0.01*(1.0-sum.a);\n            }\n            \n        }\n    }\n    \n    return sum.xyz;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  vec3 ro = vec3(0,0,2);\n  vec3 rd = normalize(vec3(uv, 0) - ro);\n  \n  float w = smoothstep(0.6, 1., worley(vec3(uv * 3., iTime / 20.), 2.));\n  float s = snoise(vec3(uv, iTime));\n  float sf = snoiseFractal(vec3(uv, iTime));\n  float f = fbm(vec3(uv.x, uv.y, iTime), 8);\n  float wf = smoothstep(0.2, 1., wfbm(vec3(uv.x, uv.y, iTime / 10.), 3, 4.));\n  float wff = wf * f;\n  \n  //out_color = vec4(vec3(wff),1);\n  \n  \n  fragColor = vec4(tr(ro, rd, uv), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVfzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 64, 131], [133, 133, 155, 155, 253], [255, 255, 277, 277, 445], [449, 449, 468, 468, 547], [608, 608, 630, 630, 1205], [1207, 1207, 1236, 1236, 1360], [1362, 1362, 1393, 1415, 1664], [1667, 1667, 1701, 1701, 2292], [2295, 2295, 2336, 2358, 2610], [2613, 2613, 2656, 2656, 2690], [2692, 2692, 2731, 2731, 2955], [2957, 2957, 2975, 2975, 3064], [3121, 3121, 3157, 3157, 4730], [4734, 4734, 4791, 4791, 5385]], "test": "error"}
{"id": "wtXXzs", "name": "z^2.5+c", "author": "rossi", "description": "2d-fractal, escape-time, rational exponent\n\nupdate 2021/02/26: added simple animation for param C", "tags": ["fractal", "escapetime", "rationalexponent"], "likes": 8, "viewed": 109, "published": "Public", "date": "1613932853", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// update 2021/02/26: added simple animation for param C\n//\n// thx to https://www.shadertoy.com/user/FabriceNeyret2 for hints and tips\n//\n// TODO: remove ugly pixel trans, get rid of visual artifacts at y=0\n//\n\n#define ANIMATE 1\n#define AA 2\n\n// change param C here (if ANIMATE > 0 then C will be taken from circle centered at C_Center)\n#if ANIMATE > 0\n\n    #define C_Center vec2(0.)\n\n#else\n\n    #define C vec2(-1.05,0.48)\n\n#endif\n\n// change formula here if you like\n#define z_iter(z,c,sgn) ( cmul( csqr(z), sgn*csqrt(z) ) + c )\n\n#define MAX_STEPS 11\n#define BAIL      128.\n#define SAMPLING  32.\n\n// viewport = vec4(center.x, center.y, size.x, size.y)\n#define VIEWPORT vec4(0.,0.,3.,3.)\n#define MAGN 1.\n\n// taken from \n// https://www.ronja-tutorials.com/2018/09/02/white-noise.html\n// get a scalar random value from given 2d-vector\nfloat rand1from2(vec2 val)\n{\n    float random = dot(sin(val), vec2(12.9898, 78.233));\n    return fract(sin(random) * 143758.5453);\n}\n\n#define cs(A) vec2(cos(A), sin(A))\n#define cmul(A,B) mat2(A, -(A).y, (A).x) * (B)\n#define csqr(Z) vec2(Z.x*Z.x-Z.y*Z.y, 2.*Z.x*Z.y)\nvec2 csqrt(vec2 z) { float r = length(z); return vec2(sqrt((r+z.x)*.5), sign(z.y)*sqrt((r-z.x)*.5)); }\n\nfloat iter(vec2 p, float k)\n{\n    vec2 z = p;\n    float sgn = 1.;\n\n    #if ANIMATE > 0\n    vec2 c = C_Center+1.1*cs(iTime);\n    #else\n    vec2 c = C;\n    #endif \n    \n    for(int i = 0; i < MAX_STEPS; ++i)\n    {\n        if (rand1from2(p+vec2(float(i), k)) < 0.5)\n            sgn = -sgn;\n\n        if (dot(z,z) > BAIL) \n            return 0.;\n\n        z = z_iter(z,c,sgn);        \n    }\n    \n    return 1.;\n}\n\nvec3 pixelColor(in vec2 pixel) \n{   \n    vec2 R = iResolution.xy;\n    float ar = R.x/R.y;\n    vec2 vps = 1.0/MAGN*vec2(VIEWPORT.z*ar, VIEWPORT.w);\n    vec2 dxy = vps/R.xy;\n    vec2 p = VIEWPORT.xy-0.5*vps+pixel.xy*dxy;\n      \n    float res = 0.;\n    for (float k = 0.; k < 128.; k+=1.)\n     \tres += iter(p, k);\n    \n    if (res > 0.)\n\t\treturn vec3(exp(-2.*res/SAMPLING)); \n    else\n        return vec3(0.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat d = 1./float(AA);\n\tvec3 col = vec3(0.);\n    \n\tfor(int j = 0; j < AA; ++j)\n\t\tfor(int i = 0; i < AA; ++i)\n\t\t\tcol += pixelColor(fragCoord.xy+vec2(i, j)*d);\n\n    // gamma correction\n    fragColor.rgb = pow(col.rgb*d*d, vec3(.4545));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtXXzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[707, 835, 863, 863, 967], [1101, 1101, 1121, 1121, 1203], [1205, 1205, 1234, 1234, 1611], [1613, 1613, 1646, 1646, 2021], [2023, 2023, 2078, 2078, 2316]], "test": "valid"}
{"id": "WtyBRG", "name": "jellyfish", "author": "kithy", "description": "hemisphere made from sphere and plane.", "tags": ["raymarching", "hemisphere"], "likes": 0, "viewed": 44, "published": "Public", "date": "1614526740", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_DIST 64\n#define EPS 1e-5\n\nfloat sphere(vec3 p){\n\tfloat r=mix(0.3,0.35,sin(iTime+10.0));\n\treturn length(p)-r;\n}\n\nfloat plane(vec3 p){\n\treturn dot(p,vec3(0.0,1.0,0.0));\n}\n\nvec2 pmod(vec2 p,float n){\n\tfloat np=3.141592*2./n;\n\tfloat r=atan(p.x,p.y)-0.5*np;\n\tr=mod(r,np)-0.5*np;\n\treturn length(p)*vec2(cos(r),sin(r));\n}\n\nfloat sd(vec3 p){\n\t\n\t//p.xy=pmod(p.xy,6.0);\n\tp=mod(p,0.8)-0.4;\n\tfloat s1=sphere(p);\n\tfloat p1=plane(p);\n\treturn max(s1,-p1);\n\t//return min(s1,p1);\n\t//return min(s1,-p1);\n\t//return min(-s1,p1);\n\t//return p1;\n\t//return s1;\n}\n\nvec3 genNormal(vec3 p){\n\treturn normalize(vec3(\n\t\tsd(p+vec3(EPS,0.0,0.0))-sd(p+vec3(-EPS,0.0,0.0)),\n\t\tsd(p+vec3(0.0,EPS,0.0))-sd(p+vec3(0.0,-EPS,0.0)),\n\t\tsd(p+vec3(0.0,0.0,EPS))-sd(p+vec3(0.0,0.0,-EPS))\n\t\t));\n}\n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n\tvec2 p=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\n\tvec3 ro=vec3(0.0,1.0-iTime*0.3,2.0);\n\tvec3 rd=normalize(vec3(p,1.0));\n\n\tfloat d,t=0.0;\n\tvec3 n,rp;\n\n\tfor(int i=0;i<MAX_DIST;i++){\n\t\trp=ro+rd*t;\n\t\td=sd(rp);\n\t\tif(d<EPS)break;\n\t\tn=genNormal(rp);\n\t\tt+=d;\n\t}\n\n\t//fragColor=vec4(n,1.0);\n\tvec3 col=vec3(exp(-0.4*t));\n\tfragColor=vec4(col,1.0);\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtyBRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 59, 59, 122], [124, 124, 144, 144, 180], [182, 182, 208, 208, 326], [328, 328, 345, 371, 550], [552, 552, 575, 575, 762], [765, 765, 818, 818, 1167]], "test": "valid"}
{"id": "WtyBWm", "name": "hexagonal tiling decoded", "author": "BigotedSJW", "description": "trying to understand what exactly FabriceNeyret2 was up to in https://www.shadertoy.com/view/ldcXW8\n-- feeling incredibly dumb while doing so", "tags": ["2d", "simple", "hexagon"], "likes": 0, "viewed": 35, "published": "Public", "date": "1614400200", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\"reverse compilation\" of the first draft of https://www.shadertoy.com/view/ldcXW8\n\nconst float PI = float(0xC90FDB) * exp2(-22.);\nconst vec2 SKEW = vec2(1./sqrt(3.), .15);\n\nfloat grid(vec2 uv){\n    uv += SKEW*uv.y;\n    vec2 grid = step(fract(uv + vec2(0.025)), vec2(.05));\n    \n    return max(grid.x, grid.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 5. * (2.*fragCoord - iResolution.xy)/iResolution.y;\n    vec2 skewUV = uv + SKEW*uv.y;\n    \n    vec2 fractUV = fract(skewUV);\n    vec2 floorUV = skewUV - fractUV;\n    \n    float selector = fract((floorUV.x + floorUV.y)/3.);\n    \n    //what even is this!?!?!?\n    vec2 selected;\n    if (selector > .6){\n        selected = floorUV;\n    } else if (selector < .3){\n        selected = floorUV + vec2(1.);\n    } else {\n        selected = floorUV + step(fractUV.yx, fractUV);\n    }\n    \n    //overlay not in original; added just to get things through my skull\n    float angle = PI*sin(iTime)/6.;\n    vec2 sincos = vec2(sin(angle),cos(angle));\n    \n    mat2 rot = mat2(\n        sincos.x, -sincos.y,\n        sincos.y, sincos.x\n    );\n    \n    vec2 gridUV = rot*uv;\n    \n    vec2 halfPix = vec2(-2.5, 2.5)/iResolution.y;\n    \n    float multisampleGrid = 0.25 * (\n        grid(gridUV+halfPix) + grid(gridUV-halfPix)\n        + grid(gridUV+halfPix.yx) + grid(gridUV - halfPix.yx)\n    );\n    \n    vec3 color = mix(\n        mod(selected.xyx, 2.), mod(selected.yxy+7.5, 2.), multisampleGrid);\n    fragColor = vec4(color, 1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtyBWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 175, 195, 195, 313], [315, 315, 372, 372, 1497]], "test": "error"}
{"id": "WtyBWR", "name": "DOFractal", "author": "efairbanks", "description": "MouseX: change depth of field\nMouseY: morph fractal\n\nBeen a while since I wrote a camera with depth-of-field. Felt like playing around with it. Code could be a lot cleaner and more efficient, but oh well.", "tags": ["raymarching", "fractal", "dof", "kifs"], "likes": 4, "viewed": 83, "published": "Public", "date": "1614374551", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 p) {\n    p+=10.;\n    return sin(fract(dot(p.x*1.3242413, p.y*3.346346)*342.23523523)*232.23423);\n}\nfloat cube(vec3 p, float s) {\n    p=abs(p);\n    return max(p.x,max(p.y,p.z))-s;\n}\nvec2 c2p(vec2 p) {return vec2(atan(p.y,p.x),length(p));}\nvec2 p2c(vec2 p) {return vec2(cos(p.x),sin(p.x))*p.y;}\nfloat map(vec3 p) {\n    p=p*1.05;\n    vec3 ac=p;\n    vec3 sc=p;\n    float my=iMouse.y/iResolution.y;\n    for(int i=0;i<7;i++) {\n        ac.xy=p2c(c2p(ac.xy)+vec2(mix(0.3,1.6,my),0.));\n        ac.xz=p2c(c2p(ac.xz)+vec2(mix(2.0,.4,my),0.));\n        ac=abs(ac)-0.1;\n        sc.xy=p2c(c2p(sc.xy)+vec2(mix(2.3,.6,my),0.));\n        sc.xz=p2c(c2p(sc.xz)+vec2(mix(0.1,1.2,my),0.));\n        sc=abs(sc)-0.15;\n    }\n    return max(cube(ac,0.2),-cube(sc,0.14));\n}\nvec3 gradient(vec3 p) {\n    vec2 e=vec2(0.,0.01);\n    return normalize(vec3(\n                map(p+e.yxx)-map(p-e.yxx),\n                map(p+e.xyx)-map(p-e.xyx),\n                map(p+e.xxy)-map(p-e.xxy)\n            ));\n}\nvec3 pixel(vec2 p, vec3 o) {\n    vec3 t=vec3(0.);\n    vec3 fwd=normalize(t-o);\n    vec3 right=cross(fwd,normalize(vec3(0.,-1.,0.)));\n    vec3 up=cross(fwd,right);\n    vec3 r=normalize(fwd+right*p.x+up*p.y);\n    vec3 fp=o+r*mix(1.,3.,iMouse.x/iResolution.x);\n    o=o+(sin(rand(p.xy*1.235313)*3.145)*right+sin(rand(p.yx*0.82352332)*3.145)*up)*0.08;\n    r=normalize(fp-o);\n    // focal stuff\n\n    // ----- //\n    float dt=0.01;\n    for(int i=0;i<60;i++) {\n        float d=map(o+r*dt);\n        if(d<0.001) break;\n        dt+=d*0.8;\n    }\n    if(dt>5.) return vec3(0.);\n    vec3 col=vec3(max(0.05,dot(gradient(o+r*dt),normalize(vec3(-4.,-2.,-10.)))));\n    col+=vec3(max(0.05,dot(gradient(o+r*dt),normalize(-vec3(-4.,-2.,-10.)))));\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*2.-1.;\n    uv.x*=iResolution.x/iResolution.y;\n    if(length(uv)>0.9) {fragColor=vec4(0.5);return;}\n    vec3 col = vec3(0.);\n    int ssaa=2;\n    for(int i=0;i<ssaa;i++) {\n        vec2 offset=vec2(rand(uv)+float(i),rand(uv*vec2(1.234324,0.943534)+vec2(2.,3.)+float(i*2)));\n        col+=pixel(uv+offset*1./iResolution.xy, vec3(cos(iTime),sin(iTime*0.7)*0.8,sin(iTime))*2.)/float(ssaa);\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtyBWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 114], [115, 115, 144, 144, 196], [197, 197, 215, 215, 253], [254, 254, 272, 272, 308], [309, 309, 328, 328, 760], [761, 761, 784, 784, 983], [984, 984, 1012, 1012, 1727], [1728, 1728, 1785, 1785, 2246]], "test": "error"}
{"id": "wtyBzm", "name": "sines experiment", "author": "0xBAMA", "description": "overlapping sines, inspired by https://twitter.com/GunTurtle/status/1363955617224867841", "tags": ["effects", "trig", "sines"], "likes": 5, "viewed": 72, "published": "Public", "date": "1614073688", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float phase_offset = 1.618;\nfloat amplitude_scale = 0.3;\nfloat signal_offset = 0.6;\n\nint accum = 0;\n\nfloat f( float x )\n{\n return amplitude_scale * sin(x + iTime + phase_offset) + signal_offset;\n}\n\nfloat f2( float x )\n{\n return amplitude_scale * 0.618 * sin(x + iTime + phase_offset * 1.618) + signal_offset + 0.75;\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(0.5);\n    uv *= 5.; // -1 to 1, then scaled from there\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    col = vec3(0.2*dot(col,col)); // grayscale bg\n    \n    float result;  // just going by accumulator now\n    \n    for(float c = 0.1; c < 97.5; c += c)\n    {\n        amplitude_scale = 0.1 * sin(c + iTime) + 0.6;\n        signal_offset = cos(c + 0.08 * iTime) * 0.2;\n        phase_offset = sin(c + iTime) + 0.02 * iTime + c;\n        \n        if((result = smoothstep(0., 0.35 + 0.1 * sin(c), abs(uv.x - f(uv.y)))) < 0.01)\n        {\n            accum++;\n        }\n    }\n      \n    for(float c = 0.1; c < 156.5; c += c)\n    {\n        amplitude_scale = 0.1 * sin(c + iTime) + 0.6;\n        signal_offset = cos(c + 0.08 * iTime) * 0.2;\n        phase_offset = sin(c + 0.6 * iTime) + 0.2 * iTime + c;\n        \n        if((result = smoothstep(0., 0.5 + 0.2 * sin(c), abs(uv.x - f2(uv.y)))) < 0.01)\n        {\n            accum++;\n        }\n    }\n    \n    col.g += float(accum) / 9.;\n      \n    col += pal( float(accum) / 8., vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\n    col.r -= float(accum) / 3.;\n      \n\n    // Output to screen\n    fragColor = vec4(vec2(1.75)-col.xy, col.z,1.0) * 0.1 * (uv.x + 5.);\n    fragColor.r *= 1.75;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtyBzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 101, 121, 121, 196], [198, 198, 219, 219, 317], [319, 319, 387, 387, 430], [434, 434, 491, 541, 1894]], "test": "valid"}
{"id": "wtycRt", "name": "Variable fractal tiles", "author": "public_int_i", "description": "Each tile has different fractal parameters.", "tags": ["fractal", "tiles", "variable"], "likes": 4, "viewed": 180, "published": "Public API", "date": "1613166552", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define FIELD_OF_VIEW 7.\n\nmat2 r2(float a) {\n\tfloat s = sin(a), c = cos(a);\n\treturn mat2(c,-s,s,c);\n}\n\nfloat triwave(float x) {\n    return 1.-abs(fract(x)-.5)*2.;\n}\nvec3 triwave(vec3 x) {\n    return vec3(1)-abs(fract(x)-.5)*2.;\n}\n\n//Credit: IQ, integer hash 2 https://www.shadertoy.com/view/XlXcW4\nvec3 hash(uvec3 x) {\n    x = ((x>>8U)^x.yzx)*1103515245U;\n    x = ((x>>8U)^x.yzx)*1103515245U;\n    x = ((x>>8U)^x.yzx)*1103515245U;\n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = ((fragCoord)*2.-iResolution.xy)*FIELD_OF_VIEW/iResolution.y+10.+iTime,\n        ipos = pos;\n\n    //hash from local tile coordinate\n    vec3 h = hash(uvec3(floor(pos/10.),0));\n    pos = mod(pos,10.)-5.;\n    \n    //apply folds based off hash\n    for (int i = 0; i < 6; i++) {\n        float fi = h[i/2], rv = h[i%3+1];\n        if (i%2 == 0) fi = fract(fi*10.);\n        else fi = floor(fi*10.);\n           \n        int id = int(fi)%3;\n        if (id == 0) {//mirror rotate fold\n            pos = (abs(pos)-.5)*r2(rv*6.28);\n        } else if (id == 1) {//plane fold\n            rv *= 6.28;\n            vec2 pnorm = vec2(sin(rv),cos(rv));\n            pos -= pnorm*2.*min(0.,dot(pos,pnorm));\n        } else {//polar fold\n            float sz = .04+rv*1.6,\n                ang = mod(atan(pos.y,pos.x),sz)-sz*.5;\n            pos = vec2(sin(ang),cos(ang))*length(pos);\n        }\n        //apply box fold\n        float ext = h[i%3];\n        pos = clamp(pos,-ext,ext)*2.-pos;\n    }\n\n    //coloring\n    fragColor = vec4(pow(triwave(length(pos)*vec3(4,5,6)),vec3(1.6)),1);\n    \n}", "image_inputs": [{"id": "4dXGR8", "previewfilepath": "/media/previz/buffer00.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/previz/buffer00.png", "ctype": "buffer"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtycRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 45, 45, 102], [104, 104, 128, 128, 165], [166, 166, 188, 188, 230], [232, 299, 319, 319, 477], [479, 479, 536, 536, 1616]], "test": "valid"}
{"id": "WtyfDm", "name": "Circular noise sampling idea", "author": "KalonSall", "description": "An idea I had to generate a 1D noise signal from a texture with dynamic scrolling speed, only needing one texture sampling.\nIdea explained here : https://twitter.com/Kalon_Sall/status/1365621771651661825?s=20", "tags": ["noise", "pattern", "1dnoise"], "likes": 3, "viewed": 69, "published": "Public", "date": "1614420515", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Idea explained here : https://twitter.com/Kalon_Sall/status/1365621771651661825?s=20\n//Top line : wrong way to interpolate between two different speeds\n//Middle line : signal interpolation between two different samplers\n//Bottom line : my idea to interpolate the radius of the trajectory circle to generate a new noise signal\n\n\nvec2 GetRoundSamplerPos(float time, float radius, float period)\n{\n    return mod(radius*vec2(sin(time/period*2.*3.1416),cos(time/period*2.*3.1416))+0.5,1.0);\n}\n\n\nfloat DrawRoundSamplerMask(vec2 samplerPos, vec2 uv,float radius)\n{    \n    float samplerDiscMask =smoothstep(5./iResolution.y, 0., distance(uv, samplerPos)-20./iResolution.y );\n    float samplerOrbitMask = smoothstep(5./iResolution.y, 0., distance(uv, vec2(0.5))-radius )*(1.-smoothstep(5./iResolution.y, 0., distance(uv, vec2(0.5))-(radius-5./iResolution.y) ));\n    return max(samplerDiscMask,samplerOrbitMask);\n}\n\nvec2 GetLinearSamplerPos(float time, float speed)\n{\n    return mod(vec2(time*speed,0.5),1.0);\n}\n\nfloat DrawLinearSamplerMask(vec2 samplerPos, vec2 uv,float speed)\n{\n    \n    float samplerDiscMask =smoothstep(5./iResolution.y, 0., distance(uv, samplerPos)-20./iResolution.y );\n    float samplerOrbitMask = step(uv.y, 0.5)*step(0.5-5./iResolution.y,uv.y);\n    return max(samplerDiscMask,samplerOrbitMask);\n}\n\nfloat GetMidSpeedMixValue(float time){\nreturn clamp(1.*0.5*sin(time/2.)+0.5,0.,1.);\n}\n\nfloat GetMidSpeed(float fast, float slow, float time){\n    return mix(fast,slow,GetMidSpeedMixValue(time));\n}\n\nfloat GetRadiusFromSpeed(float speed, float period){\n    return speed*period/2./3.1416;\n}\n\nvec2 GetRoundSamplerPosInterpol(float time, float fast, float slow, float period)\n{\n    float speed = GetMidSpeed(fast, slow, time);\n    float radius = GetRadiusFromSpeed(speed, period);\n    return mod(radius*vec2(sin(time/period*2.*3.1416),cos(time/period*2.*3.1416))+0.5,1.0);\n}\n\nfloat DrawSignalMask(vec2 samplerPosHisto, vec2 uv){\nfloat signal = texture(iChannel0,samplerPosHisto).r;\n return (1.-smoothstep(uv.y,uv.y+5./iResolution.y, signal))*\n   smoothstep(uv.y-2.*5./iResolution.y,uv.y-5./iResolution.y,signal)    ;\n}\n\nfloat DrawSignalMaskInterpol(vec2 samplerPosHistoFast,vec2 samplerPosHistoSlow, vec2 uv, float time){\nfloat fastSignal = texture(iChannel0,samplerPosHistoFast).r;\nfloat slowSignal = texture(iChannel0,samplerPosHistoSlow).r;\nfloat signal = mix(fastSignal,slowSignal, GetMidSpeedMixValue(time));\n return (1.-smoothstep(uv.y,uv.y+5./iResolution.y, signal))*\n   smoothstep(uv.y-2.*5./iResolution.y,uv.y-5./iResolution.y,signal)    ;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n//CHANGE THIS VALUES TO TEST THE IDEA---------------\n    float period = 10.;\n    float fast = 0.2;\n    float slow = 0.04;\n//--------------------------------------------------    \n    \n    float medium = GetMidSpeed(fast, slow, iTime);\n    \n\n    vec2 xy = fragCoord/iResolution.y*3.;\n    vec2 uv = mod(xy,1.);\n    vec2 signaluv = vec2(2.,1.)*vec2(fragCoord.x/iResolution.y-1./3.,mod(xy.y,1.));\n    \n    float noiseSquareMask = step(xy.x,1.);\n    \n    vec3 red = vec3(1.,0.,0.);\n    vec3 green = vec3(0.,1.,0.);\n    vec3 blue = vec3(0.2,0.6,1.);\n\n    vec3 col = vec3(texture(iChannel0,uv).r);\n    \n    float line1Mask = step(xy.y,1.);\n    float line2Mask = step(xy.y,2.)*step(1.,xy.y);\n    float line3Mask = step(xy.y,3.)*step(2.,xy.y);\n    \n    float fastradius = GetRadiusFromSpeed(fast,period);\n    float slowradius = GetRadiusFromSpeed(slow,period);\n    float mediumradius = GetRadiusFromSpeed(medium,period);\n    \n    vec2 roundSamplerPosFast = GetRoundSamplerPos(iTime,fastradius,period);\n    vec2 roundSamplerPosSlow = GetRoundSamplerPos(iTime,slowradius,period);\n    vec2 roundSamplerPosMid = GetRoundSamplerPos(iTime,mediumradius,period);\n    \n    vec2 linearSamplerPosFast = GetLinearSamplerPos(iTime,fast);\n    vec2 linearSamplerPosSlow = GetLinearSamplerPos(iTime,slow);\n    vec2 linearSamplerPosMid = GetLinearSamplerPos(iTime,medium);\n    \n    \n    //bottom line\n    col = mix(col,red,DrawRoundSamplerMask(roundSamplerPosFast,uv,fastradius)*line1Mask);\n    col = mix(col,blue,DrawRoundSamplerMask(roundSamplerPosSlow,uv,slowradius)*line1Mask);\n    col = mix(col,green,DrawRoundSamplerMask(roundSamplerPosMid,uv,mediumradius)*line1Mask);\n    \n    //middle line\n    col = mix(col,red,DrawLinearSamplerMask(linearSamplerPosFast,uv,fast)*line2Mask);\n    col = mix(col,blue,DrawLinearSamplerMask(linearSamplerPosSlow,uv,slow)*line2Mask);\n    \n    //top line\n    col = mix(col,red,DrawLinearSamplerMask(linearSamplerPosFast,uv,fast)*line3Mask);\n    col = mix(col,blue,DrawLinearSamplerMask(linearSamplerPosSlow,uv,slow)*line3Mask);\n    col = mix(col,green,DrawLinearSamplerMask(linearSamplerPosMid,uv,medium)*line3Mask);\n    \n    \n    vec2 roundSamplerPosFastHisto = GetRoundSamplerPos(iTime-signaluv.x,fastradius,period);\n    vec2 roundSamplerPosSlowHisto = GetRoundSamplerPos(iTime-signaluv.x,slowradius,period);\n    vec2 roundSamplerPosMidHisto = GetRoundSamplerPosInterpol(iTime-signaluv.x,fast, slow, period);\n    \n    vec2 linearSamplerPosFastHisto = GetLinearSamplerPos(iTime-signaluv.x,fast);\n    vec2 linearSamplerPosSlowHisto = GetLinearSamplerPos(iTime-signaluv.x,slow);\n    vec2 linearSamplerPosMidHisto = GetLinearSamplerPos(iTime-signaluv.x,GetMidSpeed(fast, slow, iTime-signaluv.x));\n    \n    float FastRoundSignal = DrawSignalMask(roundSamplerPosFastHisto,signaluv);\n    float SlowRoundSignal =  DrawSignalMask(roundSamplerPosSlowHisto,signaluv);\n    float MidRoundSignal =  DrawSignalMask(roundSamplerPosMidHisto,signaluv);\n    \n    float FastLinSignal = DrawSignalMask(linearSamplerPosFastHisto,signaluv);\n    float SlowLinSignal =  DrawSignalMask(linearSamplerPosSlowHisto,signaluv);\n    float MidLinSignal =  DrawSignalMask(linearSamplerPosMidHisto,signaluv);\n    float MidLinSignalInterpol =  DrawSignalMaskInterpol(linearSamplerPosFastHisto,linearSamplerPosSlowHisto ,signaluv,iTime-signaluv.x);\n    \n    vec3 signal = mix(vec3(1.),red,FastRoundSignal*line1Mask);\n    signal = mix(signal,blue,SlowRoundSignal*line1Mask);\n    signal = mix(signal,green,MidRoundSignal*line1Mask);\n    \n    signal = mix(signal,red,FastLinSignal*line2Mask);\n    signal = mix(signal,blue,SlowLinSignal*line2Mask);\n    signal = mix(signal,green,MidLinSignalInterpol*line2Mask);\n    \n    signal = mix(signal,red,FastLinSignal*line3Mask);\n    signal = mix(signal,blue,SlowLinSignal*line3Mask);\n    signal = mix(signal,green,MidLinSignal*line3Mask);\n    \n    col = mix(signal,col,noiseSquareMask);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtyfDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 330, 395, 395, 489], [492, 492, 559, 559, 907], [909, 909, 960, 960, 1004], [1006, 1006, 1073, 1073, 1314], [1316, 1316, 1354, 1354, 1401], [1403, 1403, 1457, 1457, 1512], [1514, 1514, 1566, 1566, 1603], [1605, 1605, 1688, 1688, 1885], [1887, 1887, 1939, 1939, 2129], [2131, 2131, 2232, 2232, 2561], [2564, 2564, 2621, 2675, 6580]], "test": "error"}
{"id": "WtyfWm", "name": "Random procedural textures", "author": "jarble", "description": "This shader makes procedural textures with many different colors and patterns.", "tags": ["procedural", "texture", "random"], "likes": 1, "viewed": 166, "published": "Public API", "date": "1614404761", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 fract1(vec2 a,vec2 random,float scale1){\n    return (abs(fract(a*scale1+100.0*random)-.5));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;\n    float t;\n    float t2=iTime/20.0;\n    float t3 = 8.0;\n    for(int c=0;c<3;c++){\n\t    vec2 uv = (fragCoord*5.0-iResolution.xy)/iResolution.y/10.0*t3;\n        uv += vec2(iTime/2.0,iTime/3.0)/8.0*t3;\n        float scale = 2.0;\n        float scale1 = 1.7;\n        \n        //vec3 random = vec3(sin(t2/13.0),sin(t2/17.0),sin(t2/19.0))/2.0+.5;\n        vec3 random = hash31(floor((iTime+uv.x)/5.0))*scale1;\n        //vec3 random = hash31(10.0);\n        \n        for(int i=0;i<3;i++)\n        {\n            uv.y *= scale1;\n            uv=fract(uv/(scale1)+(uv.yx/(scale1))/scale);\n            uv = fract1(uv/scale1,random.xy,scale1)*scale1;\n            uv /= scale;\n            uv=uv.yx+col.yx;\n            uv.y *= -1.0;\n            //col = col.yzx;\n        }\n     col[c] = fract((uv.x)-(uv.y));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtyfWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 111, 133, 179, 312], [314, 314, 359, 359, 412], [414, 414, 471, 471, 1355]], "test": "valid"}
{"id": "wtyfWw", "name": "Fractal 28_gaz", "author": "gaz", "description": "3d", "tags": ["fractal"], "likes": 5, "viewed": 169, "published": "Public", "date": "1614429738", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,g=0.,e,s;\n        ++i<99.;\n        O+=sin(vec4(22,15,53,1)/s/e)/e/1e4\n    )\n    {\n        p=g*d;\n        p.z-=3.;\n        p=R(p,normalize(vec3(1,5,0)),iTime*.5);\n        s=3.;\n        for(int i=0;i++<6;)\n            p.xz=.7-abs(p.xz),\n            p.x<p.z?p=p.zyx:p,\n            s*=e=2.6/clamp(dot(p,p),.02,1.2),\n            p=abs(p)*e-vec3(.1,15,2);\n        g+=e=length(p.xy)/s+5e-4;}\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtyfWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 95, 95, 586]], "test": "valid"}
