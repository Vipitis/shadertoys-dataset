{"id": "4dlXzN", "name": "is anyone there?", "author": "mattz", "description": "tried to capture the look as best I could...", "tags": ["portal", "turret", "activated", "thereyouare", "hellooo"], "likes": 36, "viewed": 1862, "published": "Public API", "date": "1397930562", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 L = normalize(vec3(-.3, 1., .2));\nvec3 n1 = normalize(vec3(2., -1., 0));\nvec3 n3 = normalize(vec3(4.,  1., 0));\n\nconst float cz = -.8;\nconst vec3 tgt = vec3(0, cz, 0);\nconst vec3 cpos = vec3(0, cz, 11.5);\n\n#define precis .01\n#define farval 1e5\n#define gap .03\n#define hip .3\n#define dmax 20.0\n#define rayiter 70\n\n#define MAT_SHINYBLACK .0\n#define MAT_DULLGRAY   1.\n#define MAT_MIDGRAY    2.\n#define MAT_WHITE      3.\n#define MAT_EYE        4.\n\n#define OVERLAY\n\nvec2 opU(in vec2 a, in vec2 b) {\n\treturn a.x < b.x ? a : b;\n}\n\nfloat sdBox(in vec3 p, in vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),.0) +\n         length(max(d,.0));\n}\n\nfloat sdCylinder(in vec3 p, in vec2 h) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),.0) + length(max(d,.0));\n}\n\n\nvec2 baseEllipsoid(in vec3 pos) {\n    vec3 abc = vec3(1., 2.5, 1.);\n    abc = pos/(abc*abc);\n\treturn vec2((dot(pos * abc, vec3(.5)) - .5)*inversesqrt(dot(abc,abc)), MAT_WHITE);\n}\n\nfloat sdMidCyl(in vec3 pos) {\n    return .5*baseEllipsoid(2.*pos*vec3(1.,1.,0)).x;\n}\n\n\nmat3 rotX(in float t) {\n    float cx = cos(t), sx = sin(t);\n    return mat3(1., 0, 0, \n                0, cx, sx,\n                0, -sx, cx);\n}\n\nmat3 rotY(in float t) {\n    float cy = cos(t), sy = sin(t);\n\treturn mat3(cy, 0, -sy,\n                0, 1., 0,\n                sy, 0, cy);\n\n}\n\nvec2 ant(inout vec3 pos, in vec3 p1) {\n\tfloat u = clamp(dot(pos, p1)/dot(p1,p1), .0, 1.)-1.0;\n    pos -= p1;\n    return vec2(length(pos-p1*u)-.025, MAT_SHINYBLACK);\n}\n\n\nfloat sdCone( in vec3 p ){\n    p.z -= 0.58;\n\tvec2 q = vec2( length(p.xy), -p.z );\n\treturn max( max( dot(q,vec2(inversesqrt(2.))), -p.z), p.z-1. );\n}\n\nvec2 stick(in vec3 pos, in float l) {\n\t\n    float d;\n\td = dot(abs(pos.xz), normalize(vec2(3., -1.)));\n    pos.z -= l;\n    d = max(d,sdBox(pos, vec3(.15, .05, l)));\n    \n\treturn vec2(d, MAT_SHINYBLACK);\n\t\n}\n\nvec2 torus(in vec3 pos, in vec3 x, in vec3 y) {\n\t\n\tvec3 n = normalize(cross(x, y));\n\t\n\tvec3 pp = length(x)*normalize(pos - n*dot(n, pos));\n    \n\tfloat d = length(pos-pp)-.05;\n\td = max(d, dot(pos, normalize(cross(x, n))));\n\td = max(d, dot(pos, normalize(cross(n, y))));\n\n\treturn vec2(d, MAT_SHINYBLACK);\n\t\n\t\n}\n\n\nvec2 map(in vec3 pos) {\n\n    // antennae\n    vec2 rval = baseEllipsoid(pos);\n\n    vec3 lpos = pos - vec3(-.3, .2, -.2);\n    \n    rval = opU(rval, ant(lpos, vec3(0, 2.7, 0)));\n    \n    lpos = pos - vec3(-.5, 2., -.2);\n    rval = opU(rval, ant(lpos, vec3(0, 1., 0)));\n    rval = opU(rval, ant(lpos, vec3(.2, .2, 0)));\n    rval = opU(rval, ant(lpos, vec3(0, .4, 0)));\n    \t\n\tpos.x = abs(pos.x);\n    \n\t\n\trval.x = max(rval.x, min(dot(pos, n1), sdMidCyl(pos)));\n\trval.x = max(rval.x, -sdCone(pos));\n    rval.x = max(rval.x, -abs(pos.x)+.5*gap);\n\trval.x = max(rval.x, -sdBox(pos - vec3(0, -.15, 0), vec3(.7, .7, .5)));\n\t//rval.x = max(rval.x, -sdCylinder((pos-vec3(0, 0, .5)).xzy, vec2(.23, .5)));\n\n    rval = opU(rval, vec2(length(pos-vec3(0, 0,.56))-.3, MAT_EYE));\n\trval = opU(rval, vec2(sdBox(pos-vec3(0, -.15, 0), vec3(.3, .75, .8)), MAT_DULLGRAY));\n    rval = opU(rval, vec2(sdBox(pos+vec3(0, 13.5, .5), vec3(4., 10.1, 4.)), 2.9));\n\t//rval = opU(rval, vec2(pos.y+3.4, 2.5));\n       \n\t// front leg\n    rval = opU(rval, torus(pos-vec3(.45, -1.2, .3), \n                           vec3(-.45, .1, -1.), \n                           vec3( .45, -.25, .9)));\n\n\tlpos = rotX(1.8)*rotY(-.2)*(pos+vec3(-.5, 2.5, 0));\n\n\tvec2 e = baseEllipsoid(lpos);\n    \n\te.x = max(e.x, -(e.x+hip));\t\n\te.x = max(e.x, -sdMidCyl(lpos));\n\te.x = max(e.x, dot(lpos, n3));\n\te.x = max(e.x, -lpos.x);\n\te.x = max(e.x, -lpos.z);\n    \n    rval = opU(rval, e);\n    rval = opU(rval, stick(lpos-vec3(.22, -2.25, -1.45), 0.775));\n\n    // back leg\n    rval = opU(rval, torus(pos-vec3(0, -.7, -1.15),\n                           vec3(0, .05, -.7),\n                           vec3(0, -.35, .55)));\n\t\n\tlpos = rotX(-1.8)*(pos+vec3(0, 1.5, .4));\n\t\n\te = baseEllipsoid(lpos);\n    \n\te.x = max(e.x, -(e.x+hip));\t\n\te.x = max(e.x, -sdMidCyl(lpos));\n\te.x = max(e.x, dot(lpos, n3));\n\te.x = max(e.x, lpos.z);\n\n    rval = opU(rval, e);\n\n\trval = opU(rval, stick(vec3(0, -2.32, 2.5)-lpos, 1.3));\n\n\t\n    // side\n    pos.x -= .7;\n\n    e = baseEllipsoid(pos);\n\t\t\n\te.x = max(e.x, -sdMidCyl(pos)+gap);\n\te.x = max(e.x, dot(pos, -n3)+gap);\n\te.x = max(e.x, dot(pos, -n1)+gap);\n\t\n\te.x = max(e.x, -sdBox(pos-vec3(1.6, 0, 0), vec3(.75, .1, .5)));\n\t\n    rval = opU(rval, e);\n\n \te = vec2(sdBox(pos-vec3(.35, -.15, 0), vec3(.3, .65, .4)), MAT_DULLGRAY);\n\te = opU(e, vec2(sdBox(vec3(pos.xy, abs(pos.z))-vec3(0, -.2, .3), vec3(.5, .05, .05)), MAT_SHINYBLACK));\n    pos.y = abs(pos.y);\n\te = opU(e, vec2(sdCylinder((pos-vec3(.28, .2, .5)).xzy, vec2(.13, .2)), MAT_MIDGRAY));\n\te.x = max(e.x, -sdCylinder((pos-vec3(.28, .2, .35)).xzy, vec2(.1, .4)));\n    \n    rval = opU(rval, e);\n    \n\treturn rval;\n\t\n}\n\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(precis*2., -1.);\n    float t = .0;\n    for( int i=0; i<rayiter; i++ )\n    {\n        if( abs(res.x)<precis||t>dmax ) continue;//break;\n        t += res.x;\n\t    res = map( ro+rd*t );\n\t    res.y = res.y;\n    }\n\tif (t > dmax || abs(res.x) > precis) { res.y = -1.; }\n    res.x = t;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( .001, 0, 0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat totao = .0;\n    float sca = 1.;\n    for( int aoi=0; aoi<5; aoi++ )\n    {\n        float hr = .01 + .04*float(aoi);\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        totao += -(dd-hr)*sca;\n        sca *= .8;\n    }\n    return clamp( 1. - 3.*totao, .0, 1. );\n}\n\n#ifdef OVERLAY\n\nfloat raycyl(vec3 o, vec3 d) { \n   \t\n    float r = .025;\n\tfloat a = dot(d,d) - d.z*d.z;\n\tfloat b = 2.*(dot(o,d)-o.z*d.z);\n\tfloat c = dot(o,o) - o.z*o.z - r*r;\n\t\t\n    a *= 2.;\n    \n\tfloat qd = b*b - 2.*a*c;\n \tfloat sd = sqrt(qd);\n\tfloat x1 = (-b + sd)/a;\n    float x2 = (-b - sd)/a;\n    \n    float t = qd < .0 ? farval : min(x1 < .0 ? farval : x1,\n\t\t\t \t\t\t             x2 < .0 ? farval : x2);\n    \n\tfloat u = o.z + t*d.z;\n\n    return (t < farval && u >= .0) ? t : farval;\n\t\n}\n\n#endif\n\n\nvec3 shade( in vec3 ro, in vec3 rd ) {\n\t\n\tvec2 tm = castRay(ro, rd);\n\tvec3 rcolor;\n\t\n\tif (tm.y >= .0) {\n\t\tvec3 pos = ro + tm.x * rd;\n\t\tvec3 nor = calcNormal(pos);\n\t\tfloat ao = calcAO( pos, nor );\n\t\t\n\t\t// 0 = shiny black\n\t\t// 1 = dark gray\n\t\t// 2 = mid gray\n\t\t// 3 = shiny white\n\t\t// 4 = eye\n\t\t\n\t\tfloat r = clamp(mix(.2, 1., tm.y/3.), .0, 1.);\n\t\tr*=r;\n\t\tfloat gb = tm.y < 4. ? r : .0;\n\t\t\n\t\tif (tm.y == 4.) {\n\t\t\tfloat k = length(pos.xy);\n\t\t\tr *= (1. - 1.*cos(k*30.0));\n\t\t\tfloat a = atan(pos.y, pos.x);\n\t\t\tr *= (1. - .5*cos(a*16.));\n\t\t}\n\t\t\n\t\tfloat gamma = abs(tm.y - 1.5) < .75 ? .0 : .5;\n\t\t\n\t\tvec3 color = vec3(r, vec2(gb));\n\t\t\n\t\tfloat c1 = dot(nor, L);\n\n\t\tvec3 diffamb = (.5 + .5 * max(c1, -c1*.2))*color;\n\t\t\n\t\tvec3 R = 2.*nor*dot(nor,L)-L;\n\t\tfloat spec = gamma*pow(clamp(-dot(R, rd), .0, 1.), 24.);\n\t\trcolor = (diffamb + spec)*ao;\n\n\t} else {\n\t\tfloat g = max(.3*dot(L,rd)+.6, .0);\n\t\trcolor = vec3(g*g);\n\t}\n    \n#ifdef OVERLAY\n\t\n\tif (raycyl(ro, rd) < tm.x) {\n\t\trcolor = mix(rcolor, vec3(1., .3, .3), .5 + .15*sin(94.*iTime));\n\t}\n    \n#endif\n\n\treturn rcolor;\n\t\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n\tvec2 uv = (fragCoord.xy - .5*iResolution.xy) * 0.8 / (iResolution.y);\n\t\n\tvec3 rz = normalize(tgt - cpos),\n        rx = normalize(cross(rz,vec3(0,1.,0))),\n        ry = cross(rx,rz);\n\t\n\tfloat thetax = -.05, thetay = -.10;\n\t\n\tif (max(iMouse.x, iMouse.y) > 20.0) { \n\t\tthetax = (iMouse.y - .5*iResolution.y) * 3.14/iResolution.y; \n\t\tthetay = (iMouse.x - .5*iResolution.x) * -6.28/iResolution.x; \n\t}\n\t\n    mat3 R = mat3(rx,ry,rz)*rotX(thetax)*rotY(thetay);\n\n\tvec3 rd = R*normalize(vec3(uv, 1.)),\n        ro = tgt + R*vec3(0,0,-length(cpos-tgt));\n\t\n\tfragColor.xyz = pow(shade(ro, rd),vec3(.8));\n\t\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dlXzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[466, 466, 498, 498, 527], [529, 529, 565, 565, 659], [661, 661, 701, 701, 798], [801, 801, 834, 834, 979], [981, 981, 1010, 1010, 1065], [1068, 1068, 1091, 1091, 1212], [1214, 1214, 1237, 1237, 1355], [1357, 1357, 1395, 1395, 1523], [1526, 1526, 1552, 1552, 1674], [1676, 1676, 1713, 1713, 1881], [1883, 1883, 1930, 1930, 2191], [2194, 2194, 2217, 2234, 4811], [4814, 4814, 4854, 4854, 5169], [5171, 5171, 5203, 5203, 5419], [5421, 5421, 5463, 5463, 5758], [6260, 6260, 6298, 6298, 7319], [7322, 7322, 7379, 7379, 7974]], "test": "ok"}
{"id": "4dsSRM", "name": "Whitney Music Box", "author": "jbum", "description": "GLSL implementation of Whitney Music Box.    More info: whitneymusicbox.org", "tags": ["2d", "music", "spiral", "whitney", "whitneymusicbox"], "likes": 30, "viewed": 789, "published": "Public", "date": "1398445900", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Whitney Music Box - Jim Bumgardner\n// whitneymusicbox.org\n\nconst float rad = 0.9;\nconst float dots = 64.0;\nconst float duration = 180.0;\nconst vec3 colorsep = vec3(0,2.09,4.18);\nconst float PI = 3.1415926535897932384626433832795;\nconst float PI2 = 2.0*3.1415926535897932384626433832795;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n  float tm = mod(iTime,duration)/duration;\n  p.y *= iResolution.y/iResolution.x;\n\n  vec3 gradient = vec3(0.0);\n\n  for (float i=1.0; i<=dots; i++)\n  {\n    float i2pi = i*PI2;\n    float ang = mod(tm*i2pi, PI2);\n    float amp = rad*(1.0-(i-1.0)/dots);\n    float cang = i2pi/dots;\n    float fade = 0.7 - pow(smoothstep(0.0,1.0,ang),2.0)*0.5;\n    vec2 star_pos = vec2(cos(ang) * amp, -sin(ang) * amp);\n    gradient += (cos(cang+colorsep) + 1.0/2.0) * ((fade / 384.0) / pow(length(star_pos - p), 1.5)) * fade;\n  }\n  fragColor = vec4( gradient, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dsSRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[291, 291, 348, 348, 949]], "test": "ok"}
{"id": "4dsXzM", "name": "Fovea detector", "author": "nimitz", "description": "Look at any specific point and you should clearly see the extent of your fovea (the stars only seem to be rotating in a small circle at the center of your vision). Move your head back and forth to see it grow/shrink. Works better in full screen mode.", "tags": ["2d", "illusion"], "likes": 200, "viewed": 93554, "published": "Public", "date": "1398494110", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Human fovea detector by nimitz (twitter: @stormoid)\n\n/*\nI was playing with procedural texture generation when I came across this.\nYou might need to tweak the scale value depending on your monitor's ppi.\n\nDifferent shapes might provide better results, haven't tried many.\n*/\n\n//migh need ot tweak this value depending on monitor ppi (tuned for ~100 ppi)\n#define scale 90.\n\n#define thickness 0.0\n#define lengt 0.13\n#define layers 15.\n#define time iTime*3.\n\nvec2 hash12(float p)\n{\n\treturn fract(vec2(sin(p * 591.32), cos(p * 391.32)));\n}\n\nfloat hash21(in vec2 n) \n{ \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nvec2 hash22(in vec2 p)\n{\n    p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn fract(sin(p)*43758.5453);\n}\n\nmat2 makem2(in float theta)\n{\n\tfloat c = cos(theta);\n\tfloat s = sin(theta);\n\treturn mat2(c,-s,s,c);\n}\n\nfloat field1(in vec2 p)\n{\n\tvec2 n = floor(p)-0.5;\n    vec2 f = fract(p)-0.5;\n    vec2 o = hash22(n)*.35;\n\tvec2 r = - f - o;\n\tr *= makem2(time+hash21(n)*3.14);\n\t\n\tfloat d =  1.0-smoothstep(thickness,thickness+0.09,abs(r.x));\n\td *= 1.-smoothstep(lengt,lengt+0.02,abs(r.y));\n\t\n\tfloat d2 =  1.0-smoothstep(thickness,thickness+0.09,abs(r.y));\n\td2 *= 1.-smoothstep(lengt,lengt+0.02,abs(r.x));\n\t\n    return max(d,d2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy-0.5;\n\tp.x *= iResolution.x/iResolution.y;\n\t\n\tfloat mul = (iResolution.x+iResolution.y)/scale;\n\t\n\tvec3 col = vec3(0);\n\tfor (float i=0.;i <layers;i++)\n\t{\n\t\tvec2 ds = hash12(i*2.5)*.20;\n\t\tcol = max(col,field1((p+ds)*mul)*(sin(ds.x*5100. + vec3(1.,2.,3.5))*.4+.6));\n\t}\n\t\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dsXzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[457, 457, 479, 479, 536], [538, 538, 564, 564, 631], [633, 633, 657, 657, 761], [763, 763, 792, 792, 864], [866, 866, 891, 891, 1278], [1280, 1280, 1337, 1337, 1674]], "test": "ok"}
{"id": "4dXSzH", "name": "Julia Set-rose", "author": "thu_yumeng", "description": "Thanks to the editor of the curved trees", "tags": ["fractal", "normalmap", "curvedtrees"], "likes": 1, "viewed": 216, "published": "Public", "date": "1396424387", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime*.5\n#define resolution iResolution.xy\n\nvec3 ldir;\nfloat ot;\n\nfloat julia(vec2 p) {\n\tp=p*2.+vec2(0.,-0.12);\n\tot=1000.;\n\tfloat z = 0.0;\n\tint iter;\n\tfor (int i=0; i<18; i++) {\n\t\tfloat l=dot(p,p);\n\t\tot=min(ot,abs(l-.6));\n\t\titer = i;\n\t\tif(l>4.0)\n\t\t\tbreak;\n\t\tfloat x = p.x*p.x-p.y*p.y;\n\t\tfloat y = 2.*p.x*p.y;\n\t\tp = vec2(x,y)+vec2(0.285,0.01);  \n\t}\n\treturn dot(p,p)*.2;\n}\n\nfloat light(vec2 p) {\n\tvec2 d=vec2(0.,.003);\n\tfloat d1=julia(p-d.xy)-julia(p+d.xy);\n\tfloat d2=julia(p-d.yx)-julia(p+d.yx);\t\n  \tvec3 n1=vec3(0.,d.y,d1);\n  \tvec3 n2=vec3(d.y,0.,d2);\n  \tvec3 n=normalize(cross(n1,n2));\n  \tfloat diff=max(0.,dot(ldir,n))*.6;\n\tvec3 r=reflect(vec3(0.,0.,1.),ldir);\n\tfloat spec=pow(max(0.,dot(r,n)),25.)*.4;\n  \treturn (diff+spec+.15)*max(0.4,1.-julia(p));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy/resolution.xy-.5;\n\tvec2 aspect=vec2(resolution.x/resolution.y,1.);\n  \tp*=aspect;\n\tvec3 lightpos=vec3(sin(time*3.)*.8,cos(time)*.9,-1.);\n\tlightpos.xy*=aspect*.5;\n\tldir=normalize(vec3(p,-julia(p))+lightpos);\n  \tfloat l=light(p);\n  \tot=max(1.-ot*.7,0.);\n\tvec3 col=l*vec3(ot*ot*1.45,ot*.6,ot*ot*.75);\n\tcol+=pow(max(0.,.2-length(p+lightpos.xy))/.2,5.);\n\tcol*=pow(max(0.,1.-length(p+lightpos.xy)*.3),2.5);\n\tfragColor = vec4(col+.03, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dXSzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[79, 79, 100, 100, 383], [385, 385, 406, 406, 767], [769, 769, 826, 826, 1285]], "test": "ok"}
{"id": "4dXXRH", "name": "Getting Serious", "author": "Nihilus", "description": "shadows, light, raymarching test", "tags": ["light", "shadows", "raymarchingtest"], "likes": 3, "viewed": 163, "published": "Public", "date": "1396386504", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PRECISION 0.001\n\n//----------------------------------------------------\n\nvec3 opTwist(vec3 p) {\n\tfloat c = cos(5.0*p.y);\n    float s = sin(5.0*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\nvec2 opU(vec2 d1, vec2 d2) {\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nvec3 opT(vec3 p, vec3 t) {\n\treturn p - t;\n}\n\nvec3 opD(vec3 p, float c) {\n\treturn mod(p, c) - 0.5 * c;\n}\n\nvec2 opS(vec2 d1, vec2 d2) {\n\treturn vec2(max(-d2.x, d1.x), 2.0);\n}\n\n//-----------------------------------------------------\n\nvec2 sdSphere(vec3 p, float r) {\n\treturn vec2(length(p) - r, 1.0);\n}\n\nvec2 sdPlane(vec3 p) {\n\treturn vec2(p.y, 3.0);\n}\n\nvec2 sdBox(vec3 p, vec3 d) {\n\t//p = opTwist(p);\n\treturn vec2(length(max(abs(p)-d,0.0)), 2.0);\n}\n\n//-----------------------------------------------------------------\n\nvec2 scene(vec3 p) {\n\tvec3 v = vec3(0.0, -0.4-abs(sin(iTime)), 0.0);\n\tp.x = mod(p.x, 2.0) - 2.0*0.5;\n\tp.z = mod(p.z, 2.0) - 2.0*0.5;\n\t//beat implementation\n\tfloat beat;\n\tfloat ct = iChannelTime[0];\n\tif ((ct > 8.0 && ct < 33.5)\n\t|| (ct > 38.0 && ct < 88.5)\n\t|| (ct > 93.0 && ct < 194.5))\n\t\tbeat = pow(sin(ct*3.1416*3.78+1.9)*0.5+0.5,15.0)*0.1;\n\t//end beat implementation\n\treturn opU(sdSphere(p+v, 0.18+beat*sin(2.0*(0.3*iTime))) ,opU(sdPlane(p), opS(sdBox(p, vec3(0.4, 1.0, 0.4)), sdSphere(opT(p, vec3(0.0, 1.0, 0.0)), 0.3*abs(sin(iTime))))));\n}\n\nvec2 raymarch(vec3 ro, vec3 rd, float maxd) {\n\tfloat t = 0.0;\n\tfloat h = PRECISION * 2.0;\n\tfloat m = 0.0;\n\t\n\tfor(int i = 0; i < 128; i++) {\n\t\tif(abs(h) < PRECISION || t > maxd) {\n\t\t\tbreak;\n\t\t}\n\t\tt += h;\n\t\tvec2 res = scene(ro + rd * t);\n\t\th = res.x;\n\t\tm = res.y;\n\t}\n\t\n\tif(t > maxd) {\n\t\tm = 0.0;\n\t}\n\t\n\treturn vec2(t, m);\n}\n\nvec3 calcNormal(vec3 pos) {\n\tvec3 eps = vec3(0.001, 0.0, 0.0);\n\tvec3 nor = vec3(\n\t\tscene(pos + eps.xyy).x - scene(pos - eps.xyy).x,\n\t\tscene(pos + eps.yxy).x - scene(pos - eps.yxy).x,\n\t\tscene(pos + eps.yyx).x - scene(pos - eps.yyx).x\n\t);\n\treturn normalize(nor);\n}\n\nfloat calcAO(vec3 pos, vec3 nor) {\n\tfloat totao = 0.0;\n\tfloat sca = 1.0;\n\tfor(int i = 0; i < 5; i++) {\n\t\tfloat hr = 0.01 + 0.05 * float(i);\n\t\tvec3 aopos = nor * hr + pos;\n\t\tfloat dd = scene(aopos).x;\n\t\ttotao += -(dd - hr) * sca;\n\t\tsca *= 0.75;\n\t}\n\treturn clamp(1.0 - 4.0 * totao, 0.0, 1.0);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k) {\n\tfloat res = 1.0;\n    float t = mint;\n    for(int i = 0; i < 30; i++) {\n\t\tif(t < maxt) {\n        \tfloat h = scene( ro + rd*t ).x;\n        \tres = min(res, k*h/t);\n        \tt += 0.02;\n\t\t}\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n\tvec3 col = vec3(0.6, rd.y*(0.5+0.5*abs(sin(iTime))), rd.x*(0.5+0.5*abs(cos(iTime))));\n\t\n\tvec2 res = raymarch(ro, rd, 40.0);\n\tfloat id = res.y;\n\tfloat t = res.x;\n\t\n\tif(id != 0.0) {\n\t\t//point on the shape surface\n\t\tvec3 pos = ro + rd * res.x;\n\t\t//normal vector to the surface\n\t\tvec3 nor = calcNormal(pos);\n\t\t//initial color\n\t\tif(id == 1.0) {\n\t\t\tcol = vec3(1.0, 0.0, 0.3);\n\t\t} else if(id == 2.0) {\n\t\t\tcol = vec3(0.4, 1.0, 0.0);\n\t\t} else if(id == 3.0) {\n\t\t\tcol = vec3(0.0, 0.4, 1.0);\n\t\t}\n\t\tfloat ao = calcAO( pos, nor );\n\n\t\tvec3 lig = normalize(vec3(-0.6, 0.7, -0.5));\n\t\tlig.x *= cos(iTime);\n\t\tlig.y *= sin(iTime);\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n\n\t\tfloat sh = 1.0;\n\t\tif( dif>0.02 ) { sh = softshadow( pos, lig, 0.02, 10.0, 7.0 ); dif *= sh; }\n\n\t\tvec3 brdf = vec3(0.0);\n\t\tbrdf += 0.20*amb*vec3(0.10,0.11,0.13)*ao;\n        brdf += 0.20*bac*vec3(0.15,0.15,0.15)*ao;\n        brdf += 1.20*dif*vec3(1.00,0.90,0.70);\n\n\t\tfloat pp = clamp( dot( reflect(rd,nor), lig ), 0.0, 1.0 );\n\t\tfloat spe = sh*pow(pp,16.0);\n\t\tfloat fre = ao*pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\n\t\tfloat fo = 1.0-exp(-0.0007*t*t);\n\t\tvec3 fco = vec3(0.55,0.65,0.75) + 0.6*vec3(1.0,0.8,0.5);\n\t\t\n\t\tcol = mix(col*brdf + vec3(1.0)*col*spe + 0.2*fre*(0.5+0.5*col), fco, fo);\n\t}\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-1.0 + 2.0 * fragCoord.xy / iResolution.xy) * vec2(iResolution.x/iResolution.y, 1.0);\n\t\t\n\tvec2 mo = iMouse.xy/iResolution.xy; \n\tfloat time = 15.0 + iTime;\n\n\t//camera\n\tvec3 ro = vec3( -0.5+3.2*cos(0.5*time + 6.0*mo.x), 3.0 + 2.0*mo.y, 10.0 + 3.2*sin(0.5*time + 6.0*mo.x) );\n\tvec3 ta = vec3( -0.5, -0.4, 0.5 );\t\n\t\n\t//camera setup\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(0.0, 1.0, 0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = normalize(cross(cu, cw));\n\tvec3 rd = normalize(p.x * cu + p.y * cv + 2.5 * cw);\n\t\n\t//vec3 hp = vec3(0.5/ iResolution.xy, 0.0);\n\tvec3 col = render(ro, rd);\n\t\n\tcol = sqrt(col);\n\t\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dXXRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 103, 103, 217], [219, 219, 247, 247, 282], [284, 284, 310, 310, 327], [329, 329, 356, 356, 387], [389, 389, 417, 417, 456], [515, 515, 547, 547, 583], [585, 585, 607, 607, 633], [635, 635, 663, 682, 730], [801, 801, 821, 821, 1345], [1347, 1347, 1392, 1392, 1667], [1669, 1669, 1696, 1696, 1931], [1933, 1933, 1967, 1967, 2225], [2227, 2227, 2312, 2312, 2541], [2543, 2543, 2574, 2574, 4012], [4014, 4014, 4071, 4071, 4728]], "test": "error"}
{"id": "4dXXzN", "name": "Sine Puke II", "author": "WAHa_06x36", "description": "Was playing around with a physically reasonable rainbow palette function, so I decided to dump it into my classic Sine Puke, famous for being a five-minute test function endlessly copypasted on glsl.heroku.org. Please steal this and make lots of rainbows!", "tags": ["sine", "rainbow", "puke", "copypasterfavourites"], "likes": 23, "viewed": 1471, "published": "Public API", "date": "1397250804", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Sine Puke II, by WAHa.06x36.\n// Same as my original Sine Puke, but with more rainbow, and less \"newp\".\n\n// Based on code by Spektre posted at http://stackoverflow.com/questions/3407942/rgb-values-of-visible-spectrum\nvec3 spectral_colour(float l) // RGB <0,1> <- lambda l <400,700> [nm]\n{\n\tfloat r=0.0,g=0.0,b=0.0;\n         if ((l>=400.0)&&(l<410.0)) { float t=(l-400.0)/(410.0-400.0); r=    +(0.33*t)-(0.20*t*t); }\n    else if ((l>=410.0)&&(l<475.0)) { float t=(l-410.0)/(475.0-410.0); r=0.14         -(0.13*t*t); }\n    else if ((l>=545.0)&&(l<595.0)) { float t=(l-545.0)/(595.0-545.0); r=    +(1.98*t)-(     t*t); }\n    else if ((l>=595.0)&&(l<650.0)) { float t=(l-595.0)/(650.0-595.0); r=0.98+(0.06*t)-(0.40*t*t); }\n    else if ((l>=650.0)&&(l<700.0)) { float t=(l-650.0)/(700.0-650.0); r=0.65-(0.84*t)+(0.20*t*t); }\n         if ((l>=415.0)&&(l<475.0)) { float t=(l-415.0)/(475.0-415.0); g=             +(0.80*t*t); }\n    else if ((l>=475.0)&&(l<590.0)) { float t=(l-475.0)/(590.0-475.0); g=0.8 +(0.76*t)-(0.80*t*t); }\n    else if ((l>=585.0)&&(l<639.0)) { float t=(l-585.0)/(639.0-585.0); g=0.82-(0.80*t)           ; }\n         if ((l>=400.0)&&(l<475.0)) { float t=(l-400.0)/(475.0-400.0); b=    +(2.20*t)-(1.50*t*t); }\n    else if ((l>=475.0)&&(l<560.0)) { float t=(l-475.0)/(560.0-475.0); b=0.7 -(     t)+(0.30*t*t); }\n\n\treturn vec3(r,g,b);\n}\n\nvec3 spectral_palette(float x) { return spectral_colour(x*300.0+400.0); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p=(2.0*fragCoord.xy-iResolution.xy)/max(iResolution.x,iResolution.y);\n\tfor(int i=1;i<50;i++)\n\t{\n\t\tp=p+vec2(\n\t\t\t0.6/float(i)*sin(float(i)*p.y+iTime+0.3*float(i))+1.0,\n\t\t\t0.6/float(i)*sin(float(i)*p.x+iTime+0.3*float(i+10))-1.4\n\t\t);\n\t}\n\tvec3 col=spectral_palette(p.x-48.5);\n\tfragColor=vec4(pow(col,vec3(1.0/2.2)),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dXXzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 219, 290, 290, 1350], [1352, 1352, 1384, 1384, 1425], [1427, 1427, 1484, 1484, 1809]], "test": "ok"}
{"id": "4sfSR7", "name": "Cartoonish WebCam: variant", "author": "FabriceNeyret2", "description": "// variant from okeli4408  https://www.shadertoy.com/view/XdXXzM#\nmouse:   x: threshold y: gamma    Auto-demo if no mouse\nG: gamma amplif before vs after mixing colors\nBG:  B: flip black/white  C: rev of FB\nFG:  F: rev of BG", "tags": ["video", "dfdx"], "likes": 17, "viewed": 4934, "published": "Public API", "date": "1398082033", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant from okeli4408: https://www.shadertoy.com/view/XdXXzM#\n\nbool keyToggle(int ascii) {\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\n}\n\nfloat showFlag(vec2 p, vec2 uv, float v) {\n\tfloat d = length(2.*(uv-p)*iResolution.xy/iResolution.y);\n\treturn \t1.-step(.06*v,d) + smoothstep(0.005,0.,abs(d-.06));\n}\n\nfloat showFlag(vec2 p, vec2 uv, bool flag) {\n\treturn showFlag(p, uv, (flag) ? 1.: 0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\t// --- tunings \n\t\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\t\n\tbool BG_BW, BG_COL, FG_COL,FLIP,GAMMA, VID;\n\t\n\tif (iMouse.z<=0.) { // no mouse: autodemo\n\t\tfloat t = iTime/3.;\n\t\tfloat t0 = mod(t,3.); int i = int(t0);\n\t\t\n\t\t// (!BG_BW) = (i==0)\n\t\tBG_BW  = (i==1);\n\t\tBG_COL = (i==2);\n\t\tFLIP = (mod(t/3.,2.)>1.);\n\t\tGAMMA = (mod(t/6.,2.)>1.);\n\t\tVID = (iResolution.y<200.) || (iChannelResolution[0].y<=0.) || (mod(t/12.,2.)>1.);\n\t\tFG_COL=false; // already there for BG + high gamma\n\t\t\n\t\tmouse = .5*( 1.+ .5*vec2(cos(3.*t)+cos(t), sin(3.3*t)+cos(.7*t) ) );\n\t}\t\n\telse \n\t{\n\t\tBG_BW  = keyToggle(66);\n\t\tBG_COL = keyToggle(67);\n\t\tFG_COL = keyToggle(70);\n\t\tFLIP   = keyToggle(32);\n\t\tGAMMA  = keyToggle(71);\n\t\tVID    = keyToggle(86);\n\t}\n\t\n\tfloat panel = showFlag(vec2(.25,.05),uv, bool(BG_BW))\n\t\t\t\t+ showFlag(vec2(.35,.05),uv, bool(BG_COL))\n\t\t\t\t+ showFlag(vec2(.45,.05),uv, bool(FG_COL))\n\t\t\t\t+ showFlag(vec2(.55,.05),uv, bool(GAMMA))\n\t\t\t\t+ showFlag(vec2(.65,.05),uv, bool(FLIP))\n\t\t\t\t+ showFlag(mouse,uv, true);\n\t\n    // --- display \n\t\n\tvec3 col = (VID) ? texture(iChannel1, vec2(1.-uv.x,uv.y)).rgb \n\t\t\t\t\t : texture(iChannel0, vec2(1.-uv.x,uv.y)).rgb;\n\t\n\t// edge = norm of luminance derivative.\n\tfloat lum = col.x + col.y + col.z;\n\tvec2 deriv = vec2(dFdx(lum), dFdy(lum));\n\tfloat edge = sqrt(dot(deriv,deriv));\n\t// improve:\n\tedge = smoothstep(0.,mouse.x,edge);\n\tif (GAMMA) edge = pow(edge, exp(2.*2.*(mouse.y-.7))); // gamma contrasting\n\t\n\tif (FLIP) edge = 1.-edge;\n\t\n\tvec3 bg = vec3 ( (BG_BW) ? 1.: 0.);  // black vs white background\n\tif (BG_COL) bg = 1.-col; \t\t\t // background = reverse video\n\tif (!FG_COL) col = 1.-bg;\t\t\t // forground = rev of background\n\t\n\t// key transform: ink + paper\n\tcol = mix(col,bg,edge); \n\n\tif (!GAMMA) col = pow(col, vec3(exp(3.*mouse.y))); // gamma contrasting\n\t\n\tcol.b = (col.b+.2*(col.r+col.g) < panel) ? panel:  col.b-panel;\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "Xdf3Rn", "previewfilepath": "/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video"}, {"id": "4sf3zn", "previewfilepath": "/presets/webcam.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/webcam.png", "ctype": "webcam"}, {"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sfSR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 94, 94, 167], [169, 169, 211, 211, 333], [335, 335, 379, 379, 423], [425, 425, 482, 482, 2397]], "test": "error"}
{"id": "4sfSz7", "name": "Old-School Terminal", "author": "Klems", "description": "I tried to emulate the look of an old computer screen. Kinda like a satellite scanning an alien planet, or something like that.", "tags": ["2d", "retro", "crt", "analog"], "likes": 36, "viewed": 2364, "published": "Public", "date": "1398144775", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define DETECT_BLINK 1.5\n#define DETECT_BORDER 4.0\n#define DETECT_CROSS 8.0\n#define DETECT_SEQUENCE 10.0\n\n\n// hash function\nfloat hash(int n) {\n    return fract(sin(float(n))*43758.5453);\n}\n\n// round box distance function\nfloat roundBox(vec2 p, vec2 b, float r) {\n\treturn length(max(abs(p)-b,0.0))-r;\n}\n\n// square signal\nfloat signal(float value) {\n\tvalue -= floor(value);\n\tif (value < 0.5) return 0.0;\n\treturn 1.0;\n}\n\n// pixel coordinate to screen content\nvec3 getPixel(vec2 p) {\n\t\n\t// stretch to get the real ratio\n\tp.y *= iResolution.y / iResolution.x;\n\t\n\t// small border around the whole screen\n\tfloat border = roundBox(p, vec2(0.92, 0.42), 0.0);\n\tif (border > 0.02) return vec3(0.0);\n\tif (border > 0.01) return vec3(1.0);\n\tif (border > 0.00) return vec3(0.0);\n\t\n\t// change the scale\n\tp *= 0.425;\n\t\n\t// translation with time\n\tvec2 trans = vec2(iTime)*vec2(0.0331,0.0051);\n\t\n\t// now do some stuff detection\n\tint detectID = int(iTime / DETECT_SEQUENCE);\n\tfloat detectTime = mod(iTime, DETECT_SEQUENCE);\n\tvec2 center = vec2(hash(detectID), hash(detectID*1500))*2.0-1.0;\n\tcenter.x *= .3; center.y *= .1;\n\tcenter -= vec2(mod(trans.x, 0.8)-.4, mod(trans.y,.4)-.2);\n\t\n\tif (detectTime < DETECT_BLINK) {\n\t\tif (signal(detectTime*5.0) < 0.5) {\n\t\t\tfloat detectBorder = roundBox(p-center, vec2(0.001, 0.001), 0.0);\n\t\t\tif (detectBorder < 0.005) {\n\t\t\t\treturn vec3(1.0);\n\t\t\t}\n\t\t}\n\t} else if (detectTime < DETECT_BORDER) {\n\t\tdetectTime = min(detectTime, DETECT_BORDER);\n\t\tfloat size = (detectTime-DETECT_BLINK)/(DETECT_BORDER-DETECT_BLINK)*0.02;\n\t\tfloat detectBorder = abs(roundBox(p-center, vec2(size, size), 0.01));\n\t\tif (detectBorder < 0.002) {\n\t\t\treturn vec3(1.0);\n\t\t}\n\t} else if (detectTime < DETECT_CROSS) {\n\t\tfloat detectBorder = roundBox(p-center, vec2(0.02, 0.02), 0.01);\n\t\tif (detectBorder > 0.002) {\n\t\t\tdetectBorder = roundBox(p-center, vec2(100.0, 0.002), 0.0);\n\t\t\tif (detectBorder < 0.0001) return vec3(1.0);\n\t\t\tdetectBorder = roundBox(p-center, vec2(0.002, 100.0), 0.0);\n\t\t\tif (detectBorder < 0.0001) return vec3(1.0);\n\t\t}\n\t\tdetectBorder = abs(roundBox(p-center, vec2(0.02, 0.02), 0.01));\n\t\tif (detectBorder < 0.002) {\n\t\t\treturn vec3(1.0);\n\t\t}\n\t}\n\t\n\t// translate the background\n\tp += trans;\n\t// what the fuck am i doing\n    vec3 uv = vec3(texture(iChannel1, p));\n\tuv.x *= cos(uv.y+iTime)*.35124;\n\tuv.y /= cos(uv.x*sqrt(uv.y))*.23312/abs(uv.y);\n    vec3 co = vec3(texture(iChannel1, uv.xy));\n    return co*.8;\n}\n\n// pixel coordinate to screen value, with scanline and glitches etc\nvec3 getScreen(vec2 p) {\n\t\n\t// fade to black on outside\n\tfloat boundValue = roundBox(p, vec2(0.72, 0.6), 0.1)*5.0;\n\tboundValue = 1.0 - clamp(boundValue, 0.0, 1.0);\n\t\n\t// screen scanline\n\tfloat scanline = sin(p.y*3.1415*110.0)*.5+.5;\n\tscanline = sqrt(scanline);\n\t\n\t// glitch the point around\n\tfloat glitch = sin(18.245*iTime)*cos(11.323*iTime)*sin(4.313*iTime);\n\tglitch *= glitch;\n\tp.x += sin(p.y*19.1)*glitch*.01;\n\tp.x += sin(p.y*459.1)*glitch*glitch*.02;\n\t\n\t// get the screen content\n\tvec3 color = getPixel(p);\n\t\n\t// and blend everything together\n\tfloat factor = scanline*boundValue;\n\treturn color*factor*.6+vec3(0, factor*color.g*.8, 0);\n}\n\n// pixel coordinate to physical screen value\nvec3 getScreenBorder(vec2 p) {\n\t// outer border\n\tfloat boundOut = roundBox(p, vec2(1.15, 1.15), 0.0)*8.0;\n\tboundOut = clamp(boundOut, 0.5, 1.0);\n\t\n\t// inner border\n\tvec3 cin = vec3(texture(iChannel0, p*.88));\n\tcin = vec3(cin.r*.02, cin.g*.18, cin.b*.03);\n\t\n\t// add light to simulate screen normal\n\tfloat light = sin((atan(p.x, p.y)+0.2)*2.0);\n\tcin += light*.10+0.13;\n\tfloat boundIn = roundBox(p, vec2(0.99, 0.9), 0.05)*150.0;\n\tboundIn = clamp(boundIn, 0.0, 1.0);\n\t\n\t// add a slight green haze\n\tfloat hazeV = roundBox(p, vec2(0.83, 0.73), 0.03)*3.5;\n\thazeV = 1.0 - clamp(hazeV, 0.8, 1.0);\n\thazeV += (sin(iTime*2.3) + sin(iTime*20.912) * .4)*.06;\n\tvec3 haze = vec3(0.0, hazeV*.14, 0.0);\n\t\n\t// return values\n\treturn mix(cin*boundIn, vec3(0), boundOut) + haze;\n\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n\t// move the point away from the center\n\tvec2 p = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\tp += p*dot(p, p)*0.22;\n\t\n\t// add a small led\n\tvec2 delta = vec2(0.97, 0.04) - (fragCoord.xy / iResolution.xy);\n\tdelta.y *= iResolution.y / iResolution.x;\n\tfloat ledv = clamp(1.5 - length(delta)*150.0, 0.0, 1.0);\n\tledv *= sin(2.0*iTime)*.5+.5;\n\tvec3 led = vec3(ledv*.4, ledv, ledv*.4);\n\t\n\tfragColor = vec4(getScreenBorder(p)+getScreen(p)+led, 1);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sfSz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 124, 143, 143, 189], [191, 222, 263, 263, 302], [304, 321, 348, 348, 417], [419, 457, 480, 516, 2411], [2413, 2481, 2505, 2536, 3122], [3124, 3169, 3199, 3216, 3929], [3931, 3931, 3988, 4030, 4434]], "test": "error"}
{"id": "4sfXzN", "name": "Glowing Metaballs", "author": "2DArray", "description": "My first shader written as code instead of using Strumpy's wonderful Shader Editor.  Starting nice and simple: metaballs with some cheesy bluish glow.  FEEL the innovation (cough)", "tags": ["2d", "metaball"], "likes": 5, "viewed": 266, "published": "Public", "date": "1397268675", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//controls size of each ball\n// (actually represents size with bloom included)\nconst float threshold=50.0;\n\n//higher values mean thinner metaballs\n//1.0 or higher means one ball is not enough to form a solid\nconst float metaballFactor=0.75;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat dist;\n\tvec2 cPoint;\n\tfloat sum=0.0;\n\t//not normalized: circles are not stretched\n\tvec2 uv = fragCoord.xy;\n\t\n\t\n\t//let's make some points...\n\t// hurr durr, counting to a hundred in a shader program\n\t//  what could possibly go wrong\n\tfor (float i=1.0;i<100.0;i++) {\n\t\t//animate each point to wobble around\n\t\tcPoint=vec2(0.5*iResolution);\n\t\tcPoint.x+=sin(cos(i)*iTime*0.273)*iResolution.x*0.5;\n\t\tcPoint.y+=cos((sin(i*1.51))*iTime*0.32)*iResolution.y*0.5;\n\t\t\n\t\t//add current ball weight if within range\n\t\tdist=distance(cPoint,uv);\n\t\tif (dist<threshold) {\n\t\t\tsum+=1.0-sqrt(dist/threshold);\n\t\t}\n\t}\n\t//cutoff based on accumulated total weight\n\tif (sum>metaballFactor) {\n\t\tsum*=0.5;\n\t\tsum=min(sum,.5);\n\t\tsum*=1.8;\n\t\tfragColor = vec4(sum,sum,sum*1.2,1.0);\n\t} else {\n\t\t//not strong enough to be solid\n\t\t//(act as bloom instead)\n\t\tsum*=.3;\n\t\tfragColor = vec4 (sum,sum,sum*1.4,1.0);\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sfXzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[242, 242, 299, 299, 1181]], "test": "ok"}
{"id": "4slSR8", "name": "Shaderforth Cloud", "author": "daeken", "description": "Accidental cloud of awesome.", "tags": ["shaderforth", "points"], "likes": 2, "viewed": 300, "published": "Public", "date": "1396691480", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Compiled with Shaderforth: https://github.com/daeken/Shaderforth\n:globals\n\t@vec3 uniform =iResolution\n\t@float uniform =iTime\n;\n\n:m iter 100 ;\n\n: cart-polar ( p:vec2 -> vec2 ) [ p .y.x / atan p length ]v ;\n: polar-cart ( p:vec2 -> vec2 ) [ p .x cos p .x sin ]v p .y * ;\n\n: move ( pos:vec2 t:float -> vec2 )\n\t[\n\t\tpos .x t + t 1000.0 / sin * pos .x +\n\t\tpos .y t cos *\n\t]v\n;\n\n: run ( p:vec2 t:float -> bool )\n\tt iter float - =t\n\tfalse =hit\n\n\t[ 0.0 0.5 ]v cart-polar =start\n\n\t{\n\t\tt 1.0 + =t\n\t\tstart t move =cp\n\t\tcp polar-cart p - length =dist\n\t\t{\n\t\t\ttrue =hit\n\t\t\t( break )\n\t\t} dist 0.005 < when\n\t} iter times\n\t\n\thit\n;\n\nfragCoord .xy iResolution .xy / 2.0 * 1.0 -\niTime iter float 1000.0 / +\nrun =hit\n\n{\n\t[ 1.0 1.0 1.0 1.0 ]v =fragColor\n} {\n\t[ 0.0 0.0 0.0 1.0 ]v =fragColor\n} hit if\n*/\n\nvec2 cart_polar(vec2);\nbool run(vec2, float);\nvec2 polar_cart(vec2);\nvec2 move(vec2, float);\nvec2 cart_polar(vec2 p) {\n\treturn vec2(atan(((p).y) / ((p).x)), length(p));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tbool hit = run(((fragCoord).xy) / ((iResolution).xy) * 2.0 - 1.0, (iTime) + 100.0 / 1000.0);\n\tif(hit) {\n\t\tfragColor = vec4(1.0, 1.0, 1.0, 1.0);\n\t} else {\n\t\tfragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\t}\n}\nbool run(vec2 p, float t) {\n\tt = (t) - 100.0;\n\tbool hit = false;\n\tvec2 start = cart_polar(vec2(0.0, 0.5));\n\tfor(int temp_1 = 0; temp_1 < 100; ++temp_1) {\n\t\tt = (t) + 1.0;\n\t\tvec2 cp = move(start, t);\n\t\tfloat dist = length((polar_cart(cp)) - (p));\n\t\tif((dist) < 0.005) {\n\t\t\thit = true;\n\t\t}\n\t}\n\treturn hit;\n}\nvec2 polar_cart(vec2 p) {\n\treturn (vec2(cos((p).x), sin((p).x))) * ((p).y);\n}\nvec2 move(vec2 pos, float t) {\n\treturn vec2((((pos).x) + (t)) * (sin((t) / 1000.0)) + ((pos).x), ((pos).y) * (cos(t)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4slSR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[877, 877, 902, 902, 954], [955, 955, 1012, 1012, 1212], [1213, 1213, 1240, 1240, 1518], [1519, 1519, 1544, 1544, 1596], [1597, 1597, 1627, 1627, 1718]], "test": "error"}
{"id": "4ssSRM", "name": "Log Spiral", "author": "jbum", "description": "Logarithmic spiral effect", "tags": ["spiral", "polar", "logarithm"], "likes": 7, "viewed": 753, "published": "Public", "date": "1398447121", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Log Spiral - Jim Bumgardner\n\nconst float PI = 3.1415926535897932384626433832795;\nconst float PId2 = PI/2.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n  vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n  p.y *= iResolution.y/iResolution.x;\n\n  // controls arms for each channel (2 layers)\n  vec3 n1_3 = vec3(-6.0,5.0,3.0);\n  vec3 m1_3 = vec3(3.0,11.0,-12.0);\n\n  // controls zoom effect for each layer\n  vec3 n4_6 = 10.0*iTime*vec3(.1,.11,.111);\n  vec3 m4_6 = 10.0*iTime*vec3(.2,.22,.222);\n\n  // color width for each channel\n  vec3 n7_9 = vec3(0.5);\n  vec3 m7_9 = vec3(0.5);\n\n  // color center for each channel\n  vec3 n10_12 = vec3(0.5);\n  vec3 m10_12 = vec3(0.5);\n\n  // Layer mix\n  float mixv = cos(iTime*.1)*0.5+0.5;\n\n  float a = atan(p.x, p.y);\n  float d = log(length(p));\n  // two layer version...\n  fragColor = vec4(mix(sin(d * n1_3 + vec3(a,-a-PId2,a+PId2) - n4_6) * n7_9 + n10_12, \n                          sin(d * m1_3 + vec3(a,-a-PId2,a+PId2) - m4_6)*sin(a*6.0) * m7_9 + m10_12, \n                          mixv), \n                      1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ssSRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[112, 112, 168, 168, 1074]], "test": "ok"}
{"id": "4sXSRH", "name": "MoirÃ© pattern", "author": "arthursw", "description": "MoirÃ© pattern", "tags": ["moirpattern"], "likes": 3, "viewed": 154, "published": "Public", "date": "1396356212", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat sinm(float t, float vmin, float vmax)\n{\n\treturn (vmax-vmin)*0.5*sin(t)+vmin+(vmax-vmin)*0.5;\n}\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\t   \nvec2 rotate(vec2 v, float alpha)\n{\n\tfloat vx = v.x*cos(alpha)-v.y*sin(alpha);\n\tfloat vy = v.x*sin(alpha)+v.y*cos(alpha);\n\tv.x = vx;\n\tv.y = vy;\n\treturn v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xx;\n\tp -= vec2(0.5,0.5*iResolution.y/iResolution.x);\n\tfloat t = iTime;\n\tp *= sin(0.5*t)*4.0;\n\t\n\t\n\t//vec2 n = floor(p);\n\t//vec2 f = fract(p);\n\t\n\t//float dist = 0.0;\n\t\n\t//vec2 nr = n+hash((n.x+1.0)*(n.y+1.0))-0.5;\n\t\n\tfloat dist = 1.0/length(p-vec2(0.0,0.0));\n\t\n\tdist = sin(500.0*dist);\n\t\n\tvec3 c = vec3(0.85,0.75,0.90);\n\t\n\tfragColor = vec4(c*dist,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sXSRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 46, 46, 101], [103, 103, 126, 126, 165], [171, 171, 205, 205, 326], [328, 328, 385, 385, 775]], "test": "ok"}
{"id": "4sXXR7", "name": "Color illusion in spirals", "author": "FabriceNeyret2", "description": "There is no blue spiral. only green/pink (large spirals).\nWorks with any colors in the 3 defines.", "tags": ["illusion", "perception", "short"], "likes": 11, "viewed": 1719, "published": "Public API", "date": "1398088500", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// inspired from http://www.moillusions.com/color-optical-illusion/\n\n#define LARGE_SPIRAL_COL1 vec3(0.,1.,.5)\n#define LARGE_SPIRAL_COL2 vec3(1.,0.,1.)\n#define SMALL_SPIRAL_COL  vec3(1.,.7,0.)\n\t\n#define PI 3.14159265359\nbool keyToggle(int ascii) \n{ return (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.); }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.* (fragCoord.xy / iResolution.y - vec2(.8,.5));\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\n\tif (iMouse.z<=0.) mouse.x = (1.+sin(.6*iTime))/2.;\n\t\n\tfloat r = length(uv); float a = atan(uv.y,uv.x); // to polar\n\tfloat s1 = a - mouse.x*40.* 2.*PI*r,\n\t\t  s2 = 6.*a + 2.*2.*PI*log(r),\n\t\t  s3 = 6.*a + 2.*2.*PI*log(r);\n\tfloat c1 = smoothstep(-.25,.25,sin(s1)),\n\t\t  c2 = smoothstep(-.01,.01,sin(s2)),\n\t\t  c3 = smoothstep( .67,.666,sin(s3/2.-3.*PI/4.));\n\n\tvec3 col  = mix( SMALL_SPIRAL_COL,  LARGE_SPIRAL_COL2,1.-c3);\n\tvec3 col2 = mix( LARGE_SPIRAL_COL2, LARGE_SPIRAL_COL1, c2 );\n\tc1 = mix(c1,1.-c1,c3);\n\tcol = mix(col,col2,c1);\n\tfragColor = vec4(col,1.);\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sXXR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[219, 219, 247, 247, 319], [322, 322, 379, 379, 1040]], "test": "error"}
{"id": "4sXXRN", "name": "Triangle - distance 3D", "author": "iq", "description": "Distance field to a triangle. Of course, some thickness has to be given to the polygon (or mesh if you had one) in order to make it renderable. [url]http://iquilezles.org/www/articles/triangledistance/triangledistance.htm[/url]", "tags": ["3d", "raymarching", "distancefield", "triangle", "distance"], "likes": 51, "viewed": 8521, "published": "Public API", "date": "1397174619", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// It computes the distance to a triangle.\n//\n// See here: http://iquilezles.org/www/articles/triangledistance/triangledistance.htm\n//\n// In case a mesh was rendered, only one square root would be needed for the\n// whole mesh. In this example the triangle is given a thckness of 0.01 units\n// for display purposes. Like the square root, this thickness should be added\n// only once for the whole mesh too.\n\n\n// List of other 3D SDFs: https://www.shadertoy.com/playlist/43cXRl\n//\n// and http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n\n// Other triangle functions:\n//\n// Occlusion:    https://www.shadertoy.com/view/XdjSDy\n// Distance:     https://www.shadertoy.com/view/4sXXRN\n// Intersection: https://www.shadertoy.com/view/MlGcDz\n// Closest:      https://www.shadertoy.com/view/ttfGWl\n\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat udTriangle( in vec3 v1, in vec3 v2, in vec3 v3, in vec3 p )\n{\n    vec3 v21 = v2 - v1; vec3 p1 = p - v1;\n    vec3 v32 = v3 - v2; vec3 p2 = p - v2;\n    vec3 v13 = v1 - v3; vec3 p3 = p - v3;\n    vec3 nor = cross( v21, v13 );\n\n    return sqrt( (sign(dot(cross(v21,nor),p1)) + \n                  sign(dot(cross(v32,nor),p2)) + \n                  sign(dot(cross(v13,nor),p3))<2.0) \n                  ?\n                  min( min( \n                  dot2(v21*clamp(dot(v21,p1)/dot2(v21),0.0,1.0)-p1), \n                  dot2(v32*clamp(dot(v32,p2)/dot2(v32),0.0,1.0)-p2) ), \n                  dot2(v13*clamp(dot(v13,p3)/dot2(v13),0.0,1.0)-p3) )\n                  :\n                  dot(nor,p1)*dot(nor,p1)/dot2(nor) );\n}\n\n//=====================================================\n\nfloat map( in vec3 p )\n{\n    // triangle\t\n\tvec3 v1 = 1.5*cos( iTime + vec3(0.0,1.0,1.0) + 0.0 );\n\tvec3 v2 = 1.0*cos( iTime + vec3(0.0,2.0,3.0) + 2.0 );\n\tvec3 v3 = 1.0*cos( iTime + vec3(0.0,3.0,5.0) + 4.0 );\n\tfloat d1 = udTriangle( v1, v2, v3, p ) - 0.01;\n\n    // ground plane\n\tfloat d2 = p.y + 1.0;\n\n    return min( d1, d2 );\t\n}\n\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 10.0;\n\tfloat h = 1.0;\n    float t = 0.0;\n    for( int i=0; i<50; i++ )\n    {\n        if( h<0.001 || t>maxd ) break;\n\t    h = map( ro+rd*t );\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n\t\n    return t;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.002,0.0,0.0);\n\n\treturn normalize( vec3(\n           map(pos+eps.xyy) - map(pos-eps.xyy),\n           map(pos+eps.yxy) - map(pos-eps.yxy),\n           map(pos+eps.yyx) - map(pos-eps.yyx) ) );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n    float t = 0.0;\n\tfloat h = 1.0;\n    for( int i=0; i<20; i++ )\n    {\n        h = map(ro + rd*t);\n        res = min( res, k*h/t );\n\t\tt += clamp( h, 0.01, 1.0 );\n\t\tif( h<0.0001 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.02 + 0.025*float(i*i);\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return 1.0 - clamp( occ, 0.0, 1.0 );\n}\n\nvec3 lig = normalize(vec3(1.0,0.9,0.7));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n\tvec3 ro = vec3(0.0, 0.25, 2.0 );\n\tvec3 rd = normalize( vec3(p,-1.0) );\n\t\n\tvec3 col = vec3(0.0);\n\n    float t = intersect(ro,rd);\n    if( t>0.0 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\t\tfloat sha = calcSoftshadow( pos + nor*0.01, lig, 32.0 );\n\t\tfloat occ = calcOcclusion( pos, nor );\n\t\tcol =  vec3(0.9,0.6,0.3)*clamp( dot( nor, lig ), 0.0, 1.0 ) * sha;\n\t\tcol += vec3(0.5,0.6,0.7)*clamp( nor.y, 0.0, 1.0 )*occ;\n        col += 0.03;\n\t\tcol *= exp( -0.2*t );\n        col *= 1.0 - smoothstep( 5.0, 10.0, t );\n\t}\n\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.45) );\n\t   \n    fragColor = vec4( col, 1.0 );\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sXXRN.jpg", "access": "shaders20k", "license": "mit", "functions": [[1888, 1888, 1913, 1913, 1932], [1934, 1934, 2001, 2001, 2653], [2712, 2712, 2736, 2753, 3040], [3042, 3042, 3085, 3085, 3312], [3314, 3314, 3346, 3346, 3558], [3560, 3560, 3617, 3617, 3863], [3865, 3865, 3914, 3914, 4205], [4249, 4249, 4306, 4306, 4998]], "test": "ok"}
{"id": "4sXXz7", "name": "Saturn Take 2", "author": "steverock", "description": "Trying to produce something more like this image: http://nssdc.gsfc.nasa.gov/image/planetary/saturn/saturn_false.jpg", "tags": ["space"], "likes": 5, "viewed": 849, "published": "Public", "date": "1398147685", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2013\n// Edited by Steven An - 2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvec3 lig = normalize( vec3(0.3,0.9,0.7) );\n\nconst float PI = 3.14129;\nconst float TPI = 2. * PI;\n\n//#define STEREO \nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise2d(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nfloat snoise1d(float x) {\n    return snoise2d(vec2(0.0, x));\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\n\treturn texture( iChannel0, (uv+118.4)/256.0, -100.0 ).x;\n}\n\n#ifdef STEREO\n#define lodbias -5.0\n#else\n#define lodbias 0.0\n#endif\n\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec4 x = texture( sam, p.yz, lodbias );\n\tvec4 y = texture( sam, p.zx, lodbias );\n\tvec4 z = texture( sam, p.xy, lodbias );\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\n//=====================================================================\n\nfloat lava( vec2 p )\n{\n\tp += vec2(2.0,4.0);\n    float f;\n    f  = 0.5000*noise( p ); p = p*2.02;\n    f += 0.2500*noise( p ); p = p*2.03;\n    f += 0.1250*noise( p ); p = p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n\n// I think this is just a rotation matrix - haven't analyzed it really.\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nfloat displacement( vec3 p )\n{\n//\tp += vec3(1.0,0.0,0.8);\n\t\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p ); \n\t\n\t// This just adds more high frequency noise to the surface. \n\tfloat n = noise( p*5.5 );\n    f += 0.03*n*n;\n\t\n    return f;\n}\n\nconst float satradius = 5.0;\nconst float satRotSpeed = 3.14*0.1;\n\nvec3 yRot( vec3 p, float rads ) {\n    return vec3(\n        p.x*cos(rads) - p.z*sin(rads),\n        p.y,\n        p.x*sin(rads) + p.z*cos(rads) );\n}\n\nconst float SATBUMP = 1.;\n\nfloat planetSDF( in vec3 p )\n{\n    p = yRot(p, iTime*satRotSpeed);\n\tconst float bandFreq = 8.0;\n\tvec3 spotDir = normalize(vec3(0.0,1.0,0.0));\n\tfloat noisePart = SATBUMP * 0.005 * noise(5.0*p) * sin(3.0*bandFreq*dot(normalize(p),spotDir));\n\treturn length(p) - satradius + noisePart;\n}\n\nfloat unionn( float a, float b ) { return min(a,b); }\nfloat subtract( float a, float b ) { return max(-a, b); }\nfloat intersect( float a, float b ) { return max(a, b); }\n\nfloat sceneSDF( in vec3 pos )\n{\n    return planetSDF(pos);\n}\n\nfloat raymarchTerrain( in vec3 ro, in vec3 rd )\n{\n\tfloat maxd = 30.0;\n\tfloat precis = 0.001;\t\t\t\t\t\t\n    float distToSurf = 1.0;\n    float t = 0.1;\n    for( int i=0; i<160; i++ )\n    {\n        if( abs(distToSurf)<precis||t>maxd ) continue;//break;\n\t    distToSurf = sceneSDF( ro+rd*t );\n        t += distToSurf;\n    }\n\n    if( t>maxd ) t=-1.0;\n    return t;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.02,0.0,0.0);\n\treturn normalize( vec3(\n           sceneSDF(pos+eps.xyy) - sceneSDF(pos-eps.xyy),\n           sceneSDF(pos+eps.yxy) - sceneSDF(pos-eps.yxy),\n           sceneSDF(pos+eps.yyx) - sceneSDF(pos-eps.yyx) ) );\n\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<48; i++ )\n    {\n        float h = sceneSDF(ro + rd*t);\n\t\th = max( h, 0.0 );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.5 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec3 path( float time )\n{\n    //time *= 0.;\n\treturn vec3( 16.0*cos(0.2+0.5*.1*time*1.5), 1.5, 16.0*sin(0.1+0.5*0.11*time*1.5) );\n\t\n}\n\nvec3 blendrings( vec3 col, float t, vec3 ro, vec3 rd )\n{\n    // TODO: lighting/shadows?\n    \n    const float ringrad = satradius*2.1;\n    \n    float tring = -ro.y/rd.y;\n   \tvec3 pring = ro + tring*rd;\n    pring = yRot(pring, iTime*PI/20.);\n    float r = length(pring.xz);\n    \n    if( (tring < t || t <= 0.0) && r <= ringrad )\n    {\n        float noise = snoise1d(r*0.4 + 573.62);\n\n        float normnoise = noise * 0.5 + 0.5;\n        float edgesoft = 0.1;\n        float denstart = 0.4;\n        float density = smoothstep(denstart, denstart+edgesoft, normnoise);\n\n        // more high freq radial noise on top\n        density += snoise1d(r*0.8)*0.3;\n\n        density = clamp(density, 0., 1.);\n\n        // soften outer edge\n        density *= 1.0 - smoothstep(ringrad*0.98, ringrad, r);\n\n        // soften inner edge, against planet\n        density *= smoothstep(satradius, satradius*1.05, r);\n\n        vec3 ringcol = mix( vec3(1.0, 0.3, 0.0), vec3(1.0, 0.2, 0.0), snoise1d(r)*0.5+0.5 );\n        ringcol = mix(vec3(0.0,0.0,0.0), ringcol, pow(r/ringrad,2.0));\n        ringcol *= mix(0.95, 1.0, snoise2d(pring.xz*5.));\n\n        // darken towards the middle\n        ringcol *= smoothstep(ringrad-satradius*1.2, ringrad, r);\n        ringcol *= 0.9;\n\n\n        //col += density*ringcol;\n        col = mix( col, ringcol, density);\n    }\n \treturn col;\n}\n\nvec2 curl2d(in vec2 p)\n{\n    const float E = 0.9;\n    float x = snoise2d(p);\n    float xey = snoise2d(p+vec2(0., E));\n    float xex = snoise2d(p+vec2(E, 0.));\n    \n    return vec2( xex-x, -(xey-x) ) / E;\n}\n\nvec3 saturn_gradient(in vec3 pos, in vec3 rd)\n{\n    // shades of orane\n    vec3 albedo = mix( vec3(0.8,0.6,0.0), vec3(0.7,0.7,1.0), snoise2d( vec2(0.0, pos.y*1.2) ) );\n    \n    // some blue as we go lower\n    albedo += vec3(0,0.5,0.8) * smoothstep(0., -2., pos.y);\n        \n    return albedo;\n}\n\nvec3 shade_saturn( in vec3 pos, in vec3 rd )\n{\n    float t = iTime;\n    vec3 p = pos;\n    \n    // rotate the flow map a bit\n    p = yRot(p, iTime * PI/20.);\n    \n    // to spherical\n    float r = length(p);\n    float phi = atan(p.x, p.z);\n    float theta = acos(p.y/r);\n    \n    // to UV\n    vec2 uv = vec2( phi/PI - 0.5, -(theta/PI - 0.5) );\n    \n    // backwards curl advection\n    for( int i = 0; i < 20; i++ ) {\n        vec2 duv = curl2d(uv*20.)*.0004*.5;\n        uv += duv;\n    }\n    \n    // back to spherical\n    phi = (uv.x+0.5) * PI;\n    theta = (-uv.y+0.5) * PI;\n    \n    // add some ripple in opposite direction so it can flow through the warp\n    theta += sin(TPI*phi/(0.1*PI) + t*(1.3*PI)) * PI*0.005;\n    \n    // back to cartesian\n    p = vec3(\n        r * sin(theta) * cos(phi),\n        r * cos(theta),\n        r * sin(theta) * sin(phi));\n\n    vec3 alb = saturn_gradient( p, rd );\n    \n    // make the center glow a bit\n\tvec3 nor = pos/length(pos);    \n    alb += vec3(1,0.8,0.5) * smoothstep(1.5, 0.0, abs(pos.y)) * pow(dot(nor,-rd),1.0);\n    \n    return alb;\n\n}\n\nvec2 hash( vec2 p )\n{\n\treturn texture( iChannel0, (p+0.5)/200.0, -100.0 ).xy;\n}\n\nvec3 voronoi( in vec2 x, out vec2 cpId )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash( n + g );\n\t\t#ifdef ANIMATE\n        o = animbias + animscale*sin( iTime*0.5 + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash( n + g );\n\t\t#ifdef ANIMATE\n        o = animbias + animscale*sin( iTime*0.5 + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n\n\t\t\n        if( dot(mr-r,mr-r)>0.000001 )\n\t\t{\n        // distance to line\t\t\n        float d = dot( 0.5*(mr+r), normalize(r-mr) );\n\n        md = min( md, d );\n\t\t}\n    }\n\t\n\tcpId = n+mg;\n\n    return vec3( md, mr );\n}\n\nvec4 stars(vec3 rd)\n{\n    float t = iTime;\n    \n    float r = length(rd);\n    float phi = atan(rd.x, rd.z);\n    float theta = acos(rd.y/r);\n    vec2 polar = vec2(phi, theta);\n\n    vec2 cpid;\n    const float zoom = 0.18;\n    vec3 c = voronoi( polar/zoom, cpid );\n\tfloat centerDist = length( c.yz );\n\tfloat borderDist = c.x;\n    \n    const float minsize = 0.005;\n    float size = mix(minsize, 0.05, snoise2d(cpid*20.0)*0.5+0.5);\n    float sharp = mix(0.3, 0.9, snoise2d(cpid*10.0)*0.5+0.5);\n    \n    float flickerFreq = mix(1., 2., snoise2d(cpid*15.0)*0.5+0.5);\n    const float flickerAmt = 0.2;\n    size += minsize * snoise1d(t*flickerFreq);\n       \n    return vec4(1., 1., 0.8, smoothstep(0., 1., pow(centerDist/size, sharp)) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t#ifdef STEREO\n\tfloat eyeID = mod(fragCoord.x + mod(fragCoord.y,2.0),2.0);\n    #endif\n\n    vec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 p = -1.0 + 2.0*q;\n\tp.x *= iResolution.x / iResolution.y;\n\t\t\n    // camera\t\n\tfloat time = 2.7+iTime;\n    \n    // TEMP freeze camera\n    time *= 0.1;\n    \n\tvec3 ro = path( time+0.0 );\n\tvec3 camTarget = path( time+1.6 );\n\t//camTarget.y *= 0.3 + 0.25*cos(0.11*time);\n\tcamTarget.y *= 0.35 + 0.25*sin(0.09*time);\n\tfloat roll = 0.3*sin(1.0+0.001*time);\n\t\n\t// TEMP\n\troll = -200.0;\n\tcamTarget = vec3(0,0,0);\n\t\n\t// stop going into the planet\n\tro = normalize(ro)*max( 10.0, length(ro));\n\t\n\t// camera tx\n\tvec3 cw = normalize(camTarget-ro);\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = normalize(cross(cu,cw));\n\t\n\tfloat r2 = p.x*p.x*0.32 + p.y*p.y;\n    p *= (7.0-sqrt(37.5-11.5*r2))/(r2+1.0);\n\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.1*cw );\n\n\t#ifdef STEREO\n\tvec3 fo = ro + rd*7.0; // put focus plane behind Mike\n\tro -= 0.2*cu*eyeID;    // eye separation\n\trd = normalize(fo-ro);\n    #endif\n\n    // sky\t \n\tvec3 col = vec3(0.1,0.01,0.01) - rd.y*0.1;\n    col *= 0.9;\n    \n\tvec3 bcol = col;\n\n    // terrain\t\n\tfloat t = raymarchTerrain(ro, rd)+0.0;\n\n    if( t>0.0 )\n\t{\n        // we've hit saturn\n        \n\t\tvec3 pos = ro + t*rd;\n\t\tvec3 nor = calcNormal( pos );\n\t\tvec3 ref = reflect( rd, nor );\t// not used?\n\t\t\n\t\t// Perturb the normal by sampling 3D noise\n\t\t// This is largely responsible for the rough, crumbly look of the volcanic rock. Very cool!\n\t\tvec3 bn = -1.0 + 2.0*texcube( iChannel0, 3.0*pos/4.0, nor ).xyz;\n\t\tnor = normalize( nor + 0.2*bn );\n\t\t\n\t\tfloat hh = 1.0 - smoothstep( -2.0, 1.0, pos.y );\n\n        // lighting\n\t\tfloat dif = sqrt(clamp( dot( nor, lig ), 0.0, 1.0 ));\n\t\tfloat sha = 0.0;\n\t\tif( dif>0.01)\n\t\t\tsha=softshadow(pos,lig,0.01,32.0);\n\t\tfloat bac = clamp( dot( nor, normalize(lig*vec3(-1.0,0.0,-1.0)) ), 0.0, 1.0 );\n\t\tfloat sky = 0.5 + 0.5*nor.y;\n        //float lav = smoothstep( 0.5, 0.55, lava(0.1*pos.xz) )*hh*clamp(0.5-0.5*nor.y,0.0,1.0);\n\t\tfloat occ = pow( (1.0-displacement(pos*vec3(0.8,1.0,0.8)))*1.6-0.5, 2.0 );\n\n\t\tfloat amb = 2.5;\n\n\t\tcol = vec3(0.8);\n\t\t\n\t\tfloat cd = length(pos);\n\n        // shade Saturn\n        vec3 albedo = shade_saturn(pos, rd);\n        vec3 brdf =\tdif * albedo;\n        brdf += 0.1 * amb * albedo;\n\n        // anti-rim lighting\n        brdf -= pow(1.0-clamp(dot(nor,-rd),0.,1.),1.9);\n\n        // light/surface interaction\t\t\n        col = brdf * col;\n\t\t\n\t\t// atmospheric\n\t\tcol = mix( col, (1.0-0.7*hh)*bcol, 1.0-exp(-0.00006*t*t*t) );\n\t}\n    else {\n        // hit space - do stars!\n        vec4 colstars = stars(rd);\n        col = mix(colstars.rgb, col, colstars.a);\n    }\n    \n    // rings - ray trace directly on to the y=0 plane\n    // TODO: bind lights here\n    col = blendrings(col, t, ro, rd);\n\n    // film grain over everything\n    col *= mix(0.95, 1.0, snoise2d(p*50.0));\n \n    if(false && fragCoord.x < 200.) {\n        vec2 c = curl2d(fragCoord.xy*.025)*0.5+0.5;\n        fragColor = vec4( c, 0., 1.);\n    }\n    else {\n\t\tfragColor = vec4( col, 1.0 );\n    }\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sXXz7.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[253, 271, 292, 292, 341], [343, 343, 364, 364, 413], [415, 415, 436, 436, 485], [487, 487, 509, 509, 549], [551, 551, 573, 573, 610], [612, 612, 638, 638, 2144], [2146, 2146, 2171, 2171, 2208], [2210, 2210, 2236, 2236, 2447], [2449, 2449, 2475, 2475, 2625], [2696, 2696, 2749, 2749, 2920], [2995, 2995, 3017, 3017, 3215], [3415, 3415, 3445, 3472, 3770], [3838, 3838, 3871, 3871, 3983], [4012, 4012, 4042, 4042, 4295], [4297, 4297, 4331, 4331, 4350], [4351, 4351, 4387, 4387, 4408], [4409, 4409, 4446, 4446, 4466], [4468, 4468, 4499, 4499, 4528], [4530, 4530, 4579, 4579, 4887], [4889, 4889, 4921, 4921, 5162], [5164, 5164, 5229, 5229, 5474], [5476, 5476, 5501, 5519, 5608], [5610, 5610, 5666, 5697, 6954], [6956, 6956, 6980, 6980, 7161], [7163, 7163, 7210, 7233, 7457], [7459, 7459, 7505, 7505, 8536], [8538, 8538, 8559, 8559, 8617], [8619, 8619, 8661, 8661, 9868], [9870, 9870, 9891, 9891, 10600], [10603, 10603, 10660, 10660, 13745]], "test": "error"}
{"id": "ldfSR7", "name": "Simple Blobs", "author": "madpew", "description": "trying to do blobs", "tags": ["noobshaderblobs"], "likes": 16, "viewed": 435, "published": "Public", "date": "1398355461", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define CUTOFF 0.23\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n\tuv.x *= 1000.0;\n\tuv.y *= 550.0;\n\t\n\t// blob setup\t\n\t\n\tvec2 blob1pos = vec2(250.0, 180.0);\n\tfloat blob1size = 350.0;\n\tvec2 blob2pos = vec2(450.0, 200.0);\n\tfloat blob2size = 300.0;\n\tvec2 blob3pos = vec2(600.0, 260.0);\n\tfloat blob3size = 400.0;\n\t\n\t// movement\n\t\n\tblob1pos.x += sin(iTime*3.0) * 70.0;\n\tblob1pos.y += sin(iTime*1.2) * 90.0;\n\tblob2pos.x += sin(iTime*2.0) * 150.0;\n\tblob2pos.y += sin(iTime*3.0) * 20.0;\n\tblob3pos.y += sin(iTime*1.4) * 100.0;\n\tblob3pos.x += sin(iTime*1.7) * 100.0;\n\t\n\t// calc\n\t\n\tfloat blob1dist = clamp(distance(blob1pos, uv),0.0, blob1size);\n\tfloat blob1influence = clamp( 1.0 - blob1dist/blob1size, 0.0, 1.0 );\n\t\n\tfloat blob2dist = clamp(distance(blob2pos, uv),0.0, blob2size);\n\tfloat blob2influence = clamp( 1.0 - blob2dist/blob2size, 0.0, 1.0 );\n\n\tfloat blob3dist = clamp(distance(blob3pos, uv),0.0, blob3size);\n\tfloat blob3influence = clamp( 1.0 - blob3dist/blob3size, 0.0, 1.0 );\n\n\t// finished\n\t\n\tfloat intensity = (pow(blob1influence,6.0) + pow(blob2influence,6.0) + pow(blob3influence,6.0));\n\tintensity = (clamp(intensity,CUTOFF, CUTOFF + 0.0125)-CUTOFF) * 80.0;\n\t\n\tfragColor = vec4(intensity) - vec4(blob1influence,blob2influence,blob3influence,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldfSR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 78, 78, 1305]], "test": "ok"}
{"id": "ldfSzM", "name": "DiscoBritney", "author": "madpew", "description": "Just playing around with shadertoy for the first time.", "tags": ["greenscreentesting"], "likes": 3, "viewed": 237, "published": "Public", "date": "1398285376", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec4 sampled = texture(iChannel0,uv);\n\tvec4 fallback = 0.2 + texture(iChannel0,vec2(0.5, 1.0-uv.y)) * 0.3;\n\n\t// greenscreen remover\n\tfloat dif = (sampled.r + sampled.b + 0.04) - sampled.g;\n\tdif = clamp(dif+0.05, 0.0, 0.33) * 3.0;\n\tsampled = mix(fallback, sampled, dif);\n\n\t//equalize\n\tfloat sum = sampled.r + sampled.g + sampled.b;\n\tsampled *= sum;\n\t\n\t//colorize\n\tvec4 color = vec4(uv*(0.5+0.5*sin(iTime*2.0)),0.5+0.5*sin(iTime*3.0),1.0) * 0.3;\n\t\n\tfragColor = sampled + color;\n}", "image_inputs": [{"id": "Xdf3Rn", "previewfilepath": "/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldfSzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 578]], "test": "error"}
{"id": "ldfSzN", "name": "WhateverThisIsâ„¢", "author": "MarkSkyzoid", "description": "started with popcorn fractals,ended up with this", "tags": ["fractal", "popcorn"], "likes": 3, "viewed": 279, "published": "Public", "date": "1397485540", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NUM_ITER 15\n#define PI 3.14159265359\n\nfloat f(vec2 pixel, int i, float mod)\n{\n\tfloat time = iTime + 0.3 + mod;\n\tfloat v = cos(iTime + pixel.y + cos(2.0 * iTime + PI * pixel.x));\n\treturn v;\n}\n\nfloat g(vec2 pixel, int i, float mod)\n{\n\tfloat time2 = iTime +  2.0 * 0.3 + mod;\n\tfloat v = cos(time2 + pixel.x + cos( 3.0 * (time2 + 0.3) + PI * pixel.y));\n\treturn v;\n}\n\nfloat integrateX(vec2 pixel)\n{\n\tfloat r = 0.0;\n\tfloat dt = 0.3;\n\t\n\tconst int iter = NUM_ITER;\n\t\n\tfor(int i = 0; i < iter; ++i)\n\t{\n\t\tr = r + dt * f(pixel, i, 0.3);\n\t}\n\t\n\treturn r;\n}\n\nfloat integrateY(vec2 pixel)\n{\n\tfloat r = 0.0;\n\tfloat dt = 0.3;\n\t\n\tconst int iter = NUM_ITER;\n\t\n\tfor(int i = 0; i < iter; ++i)\n\t{\n\t\tr = r + dt * g(pixel, i, 0.3);\n\t}\n\t\n\treturn r;\n}\n\nvec2 density(vec2 pixel)\n{\n\tfloat x = integrateX(pixel);\n\tfloat y = integrateY(pixel);\n\treturn vec2(x, y);\n}\n\n\nvec2 random2f( vec2 seed )\n{\n\tfloat rnd1 = mod(fract(sin(dot(seed, vec2(14.9898,78.233))) * 43758.5453), 1.0);\n\tfloat rnd2 = mod(fract(sin(dot(seed+vec2(rnd1), vec2(14.9898,78.233))) * 43758.5453), 1.0);\n\treturn vec2(rnd1, rnd2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 rand = random2f(vec2(25.0, 10.0));\n\t\n\tvec2 uv = (fragCoord.xy + rand) / iResolution.xy;\n\t\n\tvec2 d = density(uv);\n\t\n\tvec4 color = vec4( (1.0 + sin(d.x * d.y)) * 0.5,\n\t\t\t\t\t   (1.0 + cos(d.x + d.y)) * 0.5,\n\t\t\t\t\t   (1.0 + sin(d.x + d.y)) * 0.5, 1.0);\n\t\n\tfragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldfSzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 85, 85, 198], [200, 200, 239, 239, 369], [371, 371, 401, 401, 551], [553, 553, 583, 583, 733], [735, 735, 761, 761, 843], [846, 846, 874, 874, 1077], [1079, 1079, 1136, 1136, 1413]], "test": "ok"}
{"id": "ldfXz7", "name": "Tile Overlay", "author": "TheVaporTrail", "description": "Overlay of two tessellations. ", "tags": ["2d"], "likes": 4, "viewed": 224, "published": "Public", "date": "1398385268", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*--------------------------------------------------------------\n * Shader Tiles: Tesselation of the coordinate space into \n * regular polygons. \n *\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n *\n * https://www.shadertoy.com/user/TheVaporTrail\n * Contact: david (at) TheVaporTrail (dot) com\n * Projects: http://www.TheVaporTrail.com\n *\n * Supported tesselations: Square, Triangle, Hexagon, Octagon\n *\n * These routines work with the idea of a \"tile\", which describes\n * a regular polygon. A tile size is given as the radius of a \n * circle that encloses the polygon. The tile definition has the\n * radius, center, and number of sides. It also has a rotation,\n * direction, inner radius, \"horizontal angle\". (The horizontal\n * angle is the angle between the first vertex and horizontal.)\n *\n * Different tesselation \"styles\" are supported. A style describes\n * the orientations and directions of tiles:\n *   STYLE_MATCHING: All tiles have the same direction and same \n *     starting angle (except alternating triangles are rotated 180)\n *   STYLE_SEAMLESS: Triangles and squares are arranged so that all\n *     vertices 0 are together, vertices 1 are together, etc. The \n *     direction will therefore alternate in adjacent tiles.\n *\n * There are two sets of routines: locate routines and calc routines.\n * Locate routines find a tile given a coordinate and a tile size.\n * Calc routines calculate some piece of information given a tile\n * and a coordinate or other argument.\n *\n * Calc routines:\n *   Vertex \n *   Angle (of point in tile relative to horizontal)\n *   Edge vector\n *   Relative Position\n *   Relative Position UV (0.0<=x<=1.0, 0.0<=y<=1.0)\n *   Contains Point\n *   Distance to Edge\n *   Distance to Closest Edge\n *   Distance to Vertex\n *   Distance to Closest Vertex\n *\n *\n *\n *--------------------------------------------------------------*/\n\n#define DegreeToRad (3.14159/180.0)\n#define Tau (3.14159 * 2.0)\n#define cos30 (0.8660254) /* sqrt(3)/2 */\n\n#define TILE_TRI 0\n#define TILE_SQU 1\n#define TILE_HEX 2\n#define TILE_OCT 3\n\n#define STYLE_MATCHING 0\n#define STYLE_SEAMLESS 1\n\n#define TILE_MAX_SIDES 8\n\n/*--------------------------------------------------------------\n *\n *--------------------------------------------------------------*/\nstruct Tile_t\n{\n\tvec2  center;     // Center of the tile\n\tint   sides;      // Number of sides\n\tfloat len;        // Length of the side\n\tfloat radius;     // Radius to the vertex\n\tfloat inner;      // Radius to closest point on the edge\n\tfloat angle;      // Angle to first vertex\n\tfloat horzangle;  // Angle between canonical first vertex and horizontal \n\tint   direction;  // Rotation direction (+1 or -1)\n};\n\n/*--------------------------------------------------------------\n * Locate (Equilateral) Triangle Tile\n *\n * Canonical tile: vertex zero at 90 degrees, alternating tiles rotated 180 degrees\n *\n * Styles:\n *   MATCHING\n *   SEAMLESS\n *--------------------------------------------------------------*/\nTile_t tile_LocateTriangle(vec2 aCoord, int tileStyle, float radius)\n{\n\tTile_t t;\n\t\n\tfloat sideLen = radius * 2.0 * cos30;\n\t\n\t// Compute the size of a box to contain an equilateral triangle with a side of length=sideLen\n\tvec2 boxSize = vec2(sideLen, sideLen * cos30);\n\n\t// Determine if this is even or odd row. First convert the vertical location to a row number\n\t// Determine if it is an odd or even row\n\t// For odd rows, invert the triangle\n\t// -- This inverts the results when y<0 -- int row = int(aCoord.y/boxSize.y);\n\t// -- This inverts the results when y<0 -- bool evenRow = ((row - 2*(row/2)) == 0);\n\tfloat row = floor(aCoord.y/boxSize.y);\n\tbool evenRow = ((row - 2.0*floor(row/2.0)) < 0.01);\n\t\n\t// Compute the center of the triangle relative to the bottom-left corner of the box\n\t// Note that triangles are inverted for odd rows, so the center is shifted\n\tvec2 ctrAdjA = vec2(boxSize.x * 0.5, boxSize.y * (evenRow?1.0:2.0)/3.0);\n\tvec2 coordA  = aCoord.xy;\n\t// Find the box containing the coord, then compute the triangle center\n\tvec2 boxA    = floor(coordA/boxSize);\n\tvec2 ctrA    = boxA * boxSize + ctrAdjA;\n\t// Triangles are inverted on odd rows\n\tfloat angleA = evenRow ? 90.0 : 270.0;\n\tint   dirA   = 1;\n\t\n    if (tileStyle == STYLE_SEAMLESS)\n    {\n\t\tint idx = int(boxA.x - 3.0 * floor(boxA.x/3.0));\n\t\tdirA = evenRow ? 1 : -1;\n\t\tangleA = 330.0 - float(idx) * 120.0;\n\t\tif (!evenRow)\n\t\t\tangleA = -angleA;\n    }\n    \n    // Same as above, but we shift sideways by half a box\n    // and invert all of the triangles\n\tvec2 shiftB  = vec2(boxSize.x * 0.5, 0.0);\n\tvec2 ctrAdjB = vec2(boxSize.x * 0.5, boxSize.y * (evenRow?2.0:1.0)/3.0);\n\tvec2 coordB  = aCoord.xy + shiftB;\n\tvec2 boxB    = floor((coordB)/boxSize);\n\tvec2 ctrB    = boxB * boxSize - shiftB + ctrAdjB;\n\tfloat angleB = evenRow ? 270.0 : 90.0;\n\tint   dirB   = 1;\n\t\n    if (tileStyle == STYLE_SEAMLESS)\n    {\n\t\tint idx = int(boxB.x - 3.0 * floor((boxB.x)/3.0));\n\t\tdirB = evenRow ? -1 : 1;\n\t\tangleB = 150.0 + float(idx) * 120.0;\n\t\tif (!evenRow)\n\t\t\tangleB = -angleB;\n    }\n\t\n\tbool chooseA = (distance(aCoord, ctrA) < distance(aCoord, ctrB));\n\tvec2 ctr     = (chooseA) ? ctrA : ctrB;\n\tfloat angle  = (chooseA) ? angleA : angleB;\n    int   dir    = (chooseA) ? dirA : dirB;\n\n\tt.center    = ctr;\n\tt.len       = sideLen;\n\tt.sides     = 3;\n\tt.radius    = radius;\n\tt.inner     = sideLen/4.0;\n\tt.angle     = angle;\n\tt.horzangle = -90.0;\n\tt.direction = dir;\n\t\n\t\n\treturn t;\n}\n\n/*--------------------------------------------------------------\n *\n *--------------------------------------------------------------*/\nTile_t tile_LocateHexagon(vec2 aCoord, int tileStyle, float radius)\n{\n\tTile_t t;\n\t\n\tfloat sideLen = radius;\n\t\n\t// Compute the size of a box to contain hexagon with a side of length=sideLen\n\tvec2 boxSize = vec2(sideLen * 3.0, sideLen*cos30*2.0);\n\tfloat hexWidth = sideLen * 2.0;\n\n\t// Convert the vertical location to a row number\n\tfloat row = floor(aCoord.y/boxSize.y);\n\t\n\t// Determine if it is an odd or even row\n\t// For odd rows, invert the triangle\n\tbool evenRow = ((row - 2.0*floor(row/2.0)) < 0.01);\n\t\n\tvec2 ctrAdj = vec2(sideLen, sideLen * cos30);\n\t\n\tvec2 shiftA  = vec2(0.0);\n\tfloat angleA = 0.0;\n\tint   dirA   = evenRow ? 1 : -1;\n\tvec2 coordA  = aCoord.xy + shiftA;\n\tvec2 boxA    = floor(coordA/boxSize);\n\tvec2 ctrA    = boxA * boxSize - shiftA + ctrAdj;\n\tbool hasA    = (coordA.x - boxA.x * boxSize.x < hexWidth);\n\n\tvec2 shiftB  = vec2(sideLen + sideLen * 0.5, sideLen * cos30);\n\tfloat angleB = 0.0;\n\tint   dirB   = evenRow ? 1 : -1;\n\tvec2 coordB  = aCoord.xy + shiftB;\n\tvec2 boxB    = floor((coordB)/boxSize);\n\tvec2 ctrB    = boxB * boxSize - shiftB + ctrAdj;\n\tbool hasB    = (coordB.x - boxB.x * boxSize.x < hexWidth);\n\t\n\tbool chooseA = (!hasB || (hasA && distance(aCoord, ctrA) < distance(aCoord, ctrB)));\n\tvec2 ctr     = (chooseA) ? ctrA : ctrB;\n\tfloat angle  = (chooseA) ? angleA : angleB;\n    int   dir    = (chooseA) ? dirA : dirB;\n\n\tt.center    = ctr;\n\tt.len       = sideLen;\n\tt.sides     = 6;\n\tt.radius    = radius;\n\tt.inner     = sideLen/cos30;\n\tt.angle     = angle;\n\tt.horzangle = -30.0;\n\tt.direction = 1;\n\t\n\treturn t;\n}\n\n/*--------------------------------------------------------------\n *\n *--------------------------------------------------------------*/\nTile_t tile_LocateSquare(vec2 aCoord, int tileStyle, float radius)\n{\n\tTile_t t;\n\t\n\tfloat sideLen = radius*sqrt(2.0);\n\t\n\t// Compute the size of a box \n\tvec2 boxSize = vec2(sideLen, sideLen);\n\n\t// Convert the vertical location to a row number\n\tfloat row = floor(aCoord.y/boxSize.y);\n\t\n\t// Determine if it is an odd or even row\n\tbool evenRow = ((row - 2.0*floor(row/2.0)) < 0.01);\n\t\n\t\n\tfloat angle   = 45.0;\n\tvec2  coord   = aCoord.xy;\n\tvec2  box     = floor(coord/boxSize);\n\tvec2  ctr     = box * boxSize + boxSize/2.0;\n\n\tt.center    = ctr;\n\tt.len       = sideLen;\n\tt.sides     = 4;\n\tt.radius    = radius;\n\tt.inner     = sideLen/2.0;\n\tt.angle     = angle;\n\tt.horzangle = -45.0;\n\tt.direction = 1;\n\t\n\treturn t;\n}\n\n/*--------------------------------------------------------------\n *\n *--------------------------------------------------------------*/\nTile_t tile_LocateOctagon(vec2 aCoord, int tileStyle, float radius)\n{\n\tTile_t t;\n\t\n\tfloat sideLen = radius * 2.0 * sin(Tau/16.0);\n\tfloat inner   = radius * cos(Tau/16.0);\n\t\n\t// Compute the size of a box \n\tvec2 octBoxSize = vec2(inner * 2.0, inner * 2.0);\n\n\tfloat angle   = 360.0/16.0;\n\tvec2  coord   = aCoord.xy;\n\tvec2  box     = floor(coord/octBoxSize);\n\tvec2  ctrOct  = box * octBoxSize + octBoxSize/2.0;\n\n\t// Compute the size of the grid to locate the squares\n\t// The squares are rotated 45 degrees, so the \"width\" is measured across the diagonal..\n\tfloat squRadius   = sideLen / sqrt(2.0);\n\tvec2 squBoxSize   = vec2(squRadius * 2.0 + sideLen);\n\tvec2 shiftB  = vec2(sideLen + squRadius, sideLen + squRadius);\n\tvec2 coordB  = aCoord.xy - shiftB;\n\tvec2 boxB    = floor((coordB)/squBoxSize);\n\tvec2 ctrSqu  = boxB * squBoxSize + shiftB + vec2(squRadius);\n\t// We can use the fact that the sides of the square are diagonal lines with \n\t// slope=+1 or slope=-1 to determine if a point is in the square.\n\tvec2 relPt   = coordB - boxB * squBoxSize - vec2(squRadius);\n\tbool inSqu   = ((abs(relPt.x) + abs(relPt.y)) < squRadius);\n\t//bool hasSqu  = ((coordB.x - boxB.x * squBoxSize.x < squRadius * 2.0) && (coordB.y - boxB.y * squBoxSize.y < squRadius * 2.0));\n\n\tif (inSqu)\n\t{\n\t\tt.center    = ctrSqu;\n\t\tt.len       = sideLen;\n\t\tt.sides     = 4;\n\t\tt.radius    = squRadius;\n\t\tt.inner     = squRadius/sqrt(2.0);\n\t\tt.angle     = 0.0;\n\t\tt.horzangle = 0.0;\n\t\tt.direction = 1;\n\t}\n\telse\n\t{\n\t\tt.center    = ctrOct;\n\t\tt.len       = sideLen;\n\t\tt.sides     = 8;\n\t\tt.radius    = radius;\n\t\tt.inner     = inner;\n\t\tt.angle     = angle;\n\t\tt.horzangle = -360.0/16.0;\n\t\tt.direction = 1;\n\t}\n\t\n\treturn t;\n}\n\n/*--------------------------------------------------------------\n * Locate dispatch routine\n *--------------------------------------------------------------*/\nTile_t tile_Locate(vec2 aCoord, int tileType, int tileStyle, float radius)\n{\n\tTile_t t;\n\t\n\tif (tileType == TILE_TRI)\n\t\tt = tile_LocateTriangle(aCoord, tileStyle, radius);\n\telse if (tileType == TILE_SQU)\n\t\tt = tile_LocateSquare(aCoord, tileStyle, radius);\n\telse if (tileType == TILE_HEX)\n\t\tt = tile_LocateHexagon(aCoord, tileStyle, radius);\n\telse if (tileType == TILE_OCT)\n\t\tt = tile_LocateOctagon(aCoord, tileStyle, radius);\n\t\n\treturn t;\n}\n\n\n/*--------------------------------------------------------------\n *\n *--------------------------------------------------------------*/\nvec2 tile_CalcVertex(Tile_t tile, int vertexIdx)\n{\n\tvec2 pt;\n\tfloat angle;\n\t\n\tangle = DegreeToRad * (tile.angle + float(vertexIdx) * float(tile.direction) * 360.0 / float(tile.sides));\n\t\n\tpt.x = tile.center.x + tile.radius * cos(angle);\n\tpt.y = tile.center.y + tile.radius * sin(angle);\n\t\n\treturn pt;\n}\n\n/*--------------------------------------------------------------\n * Calculate the angle between two vectors, one from the center\n * to the coord and the other between the center and vertex zero\n *--------------------------------------------------------------*/\nfloat tile_CalcAngle(Tile_t tile, vec2 coord)\n{\n\tfloat angle = 0.0;\n\t\n\tangle = atan(coord.y - tile.center.y, coord.x - tile.center.x) / DegreeToRad;\n\t\n\tangle += tile.angle;\n\t\n\tangle *= float(tile.direction);\n\t\n\treturn angle;\n}\n\n/*--------------------------------------------------------------\n *\n *--------------------------------------------------------------*/\nvec2 tile_CalcEdgeVector(Tile_t tile, int vertexIdx)\n{\n\tvec2 vect;\n\t\n\treturn vect;\n}\n\n\n/*--------------------------------------------------------------\n * Calculate the position of a coordinate relative to vertex 0,\n * taking into consideration the direction of the tile.\n * The result is -radius<=x<=radius, -radius<=y<=radius\n *--------------------------------------------------------------*/\nvec2 tile_CalcRelPosition(Tile_t tile, vec2 coord, float twist)\n{\n\tvec2 relPos;\n\t\n\tfloat angle = -(tile.angle + tile.horzangle + twist * float(tile.direction)) *  DegreeToRad;\n\t\n\tfloat cA = cos(angle);\n\tfloat sA = sin(angle);\n\t\n\tmat2 rm = mat2(cA, sA, -sA, cA);\n\t\n\trelPos = coord - tile.center;\n\t\n\trelPos = rm * relPos;\n\t\n\tif (tile.direction == -1)\n\t\trelPos.x = -relPos.x;\n\treturn relPos;\n}\n\n\n/*--------------------------------------------------------------\n * Calculate the relative position, but return values appropriate\n * for a texture lookup.\n *--------------------------------------------------------------*/\nvec2 tile_CalcRelPositionUV(Tile_t tile, vec2 coord, float twist)\n{\n\tvec2 relPos = tile_CalcRelPosition(tile, coord, twist);\n\t\n\tvec2 uv = (relPos + vec2(tile.radius, tile.radius))/(tile.radius * 2.0);\n\t\n\treturn uv;\n}\n\n\n/*--------------------------------------------------------------\n *\n *--------------------------------------------------------------*/\nbool tile_ContainsPoint(Tile_t tile, vec2 coord)\n{\n\tbool contains = true;\n\t\n\treturn contains;\n}\n\n\n/*--------------------------------------------------------------\n * Calculate the distance to a specified edge\n *--------------------------------------------------------------*/\nfloat tile_CalcDistanceToEdge(Tile_t tile, int vertexIdx, vec2 coord)\n{\n\tfloat d;\n\t\n\tvec2 v1 = tile_CalcVertex(tile, vertexIdx);\n\tvec2 v2 = tile_CalcVertex(tile, vertexIdx+1);\n\t//vec2 edgeVec = edgeVector_Tile(tile, vertexIdx);\n\t\n\t// Calc distance to line\n\tvec2 vhat = vec2(v2.y - v1.y, v1.x - v2.x);\n\tvec2 r = v1 - coord;\n\t\n\td = abs(dot(vhat, r))/length(vhat);\n\t\n\treturn d;\n}\n\n/*--------------------------------------------------------------\n * Calculate the distance to the closest edge\n *--------------------------------------------------------------*/\nfloat tile_CalcDistanceToClosestEdge(Tile_t tile, vec2 coord)\n{\n\tfloat closest;\n\tfloat dist;\n\t\n\tclosest = tile_CalcDistanceToEdge(tile, 0, coord);\n\t\n\tfor (int i = 1; i < TILE_MAX_SIDES; i++)\n\t{\n\t\tif (i < tile.sides)\n\t\t{\n\t\t\tdist = tile_CalcDistanceToEdge(tile, i, coord);\n\t\t\tif (dist < closest)\n\t\t\t\tclosest = dist;\n\t\t}\n\t}\n\t\n\treturn closest;\n}\n\n\n/*--------------------------------------------------------------\n *\n *--------------------------------------------------------------*/\nfloat tile_CalcDistanceToVertex(Tile_t tile, int vertexIdx, vec2 coord)\n{\n\tvec2 pt = tile_CalcVertex(tile, vertexIdx);\n\n\treturn distance(coord, pt);\n}\n\n/*--------------------------------------------------------------\n *\n *--------------------------------------------------------------*/\nfloat tile_CalcDistanceToClosestVertex(Tile_t tile, vec2 coord)\n{\n\tfloat closest;\n\tfloat dist;\n\t\n\tclosest = tile_CalcDistanceToVertex(tile, 0, coord);\n\t\n\t\n\tfor (int i = 1; i < TILE_MAX_SIDES; i++)\n\t{\n\t\tif (i < tile.sides)\n\t\t{\n\t\t\tdist = tile_CalcDistanceToVertex(tile, i, coord);\n\t\t\tif (dist < closest)\n\t\t\t\tclosest = dist;\n\t\t\t\t\t\n\t\t}\n\t}\n\t\n\treturn closest;\n}\n\n\n/*--------------------------------------------------------------\n *\n *--------------------------------------------------------------*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tTile_t tile;\n\tvec2 coord = fragCoord.xy;\n\tfloat d;\n\tfloat radius = 60.0;\n\t\n\tvec4 clr;\n\n\t\n\tfloat triRadius = radius + 10.0 * sin(40.0 * iTime * DegreeToRad);\n\tfloat angle = 6.0*iTime * DegreeToRad;\n\tfloat cA = cos(angle);\n\tfloat sA = sin(angle);\n\tmat2 rm = mat2(cA, sA, -sA, cA);\n\tvec2 coord2 = rm * (coord - iResolution.xy/2.0) + iResolution.xy/2.0;\n\t\n\ttile = tile_Locate(coord2, TILE_TRI, 0, triRadius);\t\n\td = tile_CalcDistanceToClosestEdge(tile, coord2);\t\n\tfloat cTri = (d < 5.0) ? (5.0-d)/5.0 : 0.0;\n\t\n\tfloat octRadius = radius - 15.0 * sin(30.0 * iTime * DegreeToRad);\n\tangle = -4.0*iTime * DegreeToRad;\n\tcA = cos(angle);\n\tsA = sin(angle);\n\trm = mat2(cA, sA, -sA, cA);\n\tvec2 coord3 = rm * (coord - iResolution.xy/2.0) + iResolution.xy/2.0;\n\ttile = tile_Locate(coord3, TILE_OCT, 0, octRadius);\t\n\td = tile_CalcDistanceToClosestEdge(tile, coord3);\t\n\tfloat cOct = (d < 5.0) ? (5.0-d)/5.0 : 0.0;\n\t\n\tvec4 clrTri;\n\tvec4 clrOct;\n\n\tif (triRadius < octRadius)\n\t{\n\t\tclrTri =  vec4(cTri, 0., 0.0, cTri);\n\t\tclrOct =  vec4(0., 1.0, 0.0, cOct);\n\t\tfragColor = mix(clrTri, clrOct, clrOct.a);\n\t}\n\telse\n\t{\n\t\tclrTri =  vec4(1.0, 0., 0.0, cTri);\n\t\tclrOct =  vec4(0., cOct, 0.0, cOct);\n\t\tfragColor = mix(clrOct, clrTri, clrTri.a);\n\t}\n\t\t\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldfXz7.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[2713, 3012, 3082, 3082, 5439], [5441, 5576, 5645, 5645, 7115], [7117, 7252, 7320, 7320, 7960], [7962, 8097, 8166, 8166, 9773], [9775, 9934, 10010, 10010, 10373], [10376, 10511, 10561, 10561, 10813], [10815, 11076, 11123, 11123, 11302], [11304, 11439, 11493, 11493, 11523], [11526, 11834, 11899, 11899, 12224], [12227, 12450, 12517, 12517, 12666], [12669, 12804, 12854, 12854, 12899], [12902, 13080, 13151, 13151, 13456], [13458, 13636, 13699, 13699, 13977], [13980, 14115, 14188, 14188, 14265], [14267, 14402, 14467, 14467, 14757], [14760, 14895, 14952, 14952, 16174]], "test": "ok"}
{"id": "ldlSz4", "name": "Raytracer of Spheres in orbit", "author": "GhettoWolf", "description": "a VERY simple raytracer to run in a shader \n\nYou can change the depth at line 203 to decrease/increase secondary rays", "tags": ["raytracing", "texturedspheres"], "likes": 0, "viewed": 180, "published": "Public", "date": "1398048621", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//simple shape struct that supports creation of either planes or spheres\n//hence the variable names - pos for spheres, normals for planes etc\nstruct Shape{\n\tvec3  posOrNormal;\n\tvec4  col;\n\tfloat radiusOrDistance;\n\tbool  isPlane;\n};\n\t\nint numShapes = 6;\n\t\n//rotation matrices\nmat3 RotationMatrixY = mat3( cos( iTime ),  0.0,   sin( iTime ), \n\t\t\t    \t\t\t\t0.0,              0.0,   0.0,\n\t\t\t             \t-sin( iTime ),  0.0,   cos(iTime) );\n\nmat3 RotationMatrixX = mat3( 1.0,        0.0,            0.0,\n\t\t\t    \t\t\t0.0,  cos( iTime ),    -sin(iTime), \n\t\t\t             \t0.0,  sin(iTime),      cos(iTime) );\n\n//camera origin\t\nvec3 camOrigin = vec3(0.0,2.0,-3.0);\nvec3 lookAt    = vec3(0.0,0.0,0.0);\n\n//one light\nvec3 lightPos[2];\n\n\nconst float fov = 30.0 * 3.1415926/180.0;\n\nconst float dist = 0.5/tan(fov * 0.5);\n\nconst float NO_INTERSECTION = 1000.0;\n\n//get the texture co-ordinates for the sphere at the\n//ray interesection point - because these aren't rasterised spheres \n//we are unable to make the spheres \"rotate\" around their own axis , we have to \n//rotate the vectors used for the sampling\nvec2 GetUVForSphere(vec3 centerToIntersection)\n{\n\tvec3 center = RotationMatrixX * centerToIntersection;\n\tvec3 north = RotationMatrixX * vec3(0.0,1.0,0.0); \n\tvec3 equator = RotationMatrixX * vec3(1.0,0.0,0.0);\n\tfloat numerator = acos(dot(-vec3(0.0,1.0,0.0),center));\n\tfloat v = numerator/3.141259;\n\tfloat u;\n\t\n\tfloat possU = (acos(dot( equator,center))/sin(numerator))/(2.0*3.141259);\n\t\n\tif(dot(cross(vec3(0.0,1.0,0.0), equator),center) > 0.0)\n\t{\n\t\tu = possU;\n\t}\n\telse\n\t{\n\t\tu = 1.0 - possU;\n\t}\n\t\t\n\treturn vec2(u,v);\n}\n\t\nfloat IntersectPlane(vec3 dir,vec3 origin,Shape inShape)\n{\n  float val1 = -(dot(origin,inShape.posOrNormal)+ inShape.radiusOrDistance);\n  float val2 = dot(dir,inShape.posOrNormal);\n  float tVal = val1/val2;\n\n  return tVal > 0.0 ? tVal : NO_INTERSECTION;\t\n\t//return NO_INTERSECTION;\n}\n\nfloat IntersectSphere(vec3 dir,vec3 origin,Shape inShape)\n{\n\t//calc all the dot products necessary here\n\tfloat radiusSquared = inShape.radiusOrDistance * inShape.radiusOrDistance;\n\tfloat rayOrigDot    = dot(origin,origin);\n\tfloat rayOriDirDot  = dot(dir,origin);\n\tfloat rayDirDot     = dot(dir,dir);\n\tfloat spherePosDot = dot(inShape.posOrNormal,inShape.posOrNormal);\n\t\n\t//here are the variables for the quadratic equation\n\t//a is the dot prod between the ray direction and itself\n\tfloat b = 2.0 * (rayOriDirDot - dot(dir,inShape.posOrNormal));\n\tfloat c = rayOrigDot + spherePosDot - 2.0 * dot(origin,inShape.posOrNormal) - radiusSquared;\n\n\t\n\t//the value for a is raydirdot\n\tfloat discriminant = (b*b) - 4.0 * rayDirDot * c;\n\n\tif(discriminant < 0.0) return NO_INTERSECTION;\n\n\tdiscriminant = sqrt(discriminant);\n\n\tif(-b+discriminant < 0.0) return NO_INTERSECTION;\n\n\tfloat denom = 1.0/(2.0 * rayDirDot);\n\tfloat t1 = (-b + discriminant) * denom;\n\tfloat t2 = (-b - discriminant) * denom;\n\n\treturn t1 < t2 ? t1 : t2; \n}\n\n\nvec3 CreateRay()\n{\n\tvec3 dir      = normalize(lookAt - camOrigin); \n\tvec3 upVec    = normalize(cross(vec3(1.0,0.0,0.0),dir));\t\n\tvec3 rightVec = normalize(cross(dir,upVec));\n\tvec3 factor1  = (0.5 - (gl_FragCoord.y/iResolution.y)) * upVec;\n\tvec3 factor2  = ((gl_FragCoord.x/iResolution.x)-0.5) * rightVec;\n\tdir = dir * dist + factor1 + factor2;  \n\treturn normalize(dir);\n}\n\n//once we know the instersect/contact point for the ray lets find the colour\nvec4 GenColor(vec3 contactPoint,Shape inShape[6],int index,vec3 dir,vec3 normal)\n{\n\tvec4 col = vec4(0.0,0.0,0.0,1.0);\n\t\n\tfor(int light = 0; light < 2; light++)\n\t{\n\t\tfor(int s = 0; s < 6; s++)\n\t\t{\n\t\t\t//because of the way glsl is compiled we can't use\n\t\t\t//inshape[index] in the code, so we have to iterate through each shape and \n\t\t\t//use a test\n\t\t\tif(s == index)\n\t\t\t{\n\t\t\t\tvec3 lightDir = normalize(lightPos[light]-contactPoint);\n\t\t\t\tvec3 viewVec  =  normalize(contactPoint - camOrigin);\n\t\t\t\tvec3 reflectVec = reflect(-lightDir,normal);\n\t\t\t\tvec4 diff = max(dot(normal,lightDir),0.0) * inShape[s].col;\n\t\t\t\tvec4 spec = pow(max(dot(viewVec,reflectVec),0.0),16.0) * vec4(1.0,1.0,1.0,1.0);\n\t\t\t\t\n\t\t\t\tif(!inShape[s].isPlane)\n\t\t\t\t{\n\t\t\t\t\tvec2 coords = GetUVForSphere(normalize(inShape[s].posOrNormal-contactPoint));\n\t\t\t\t\tdiff *= texture(iChannel0,coords);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcol += clamp(diff + spec,0.0,1.0);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn clamp(col,0.0,1.0);\n}\n\n//create the shapes for this frame, give new positions for the spheres\n//using rotation matrices and the current value of the iTime\n//to create an \"orbit\"\nvoid CreateShapes(out Shape shapes[6])\n{\n\tshapes[0].posOrNormal       = RotationMatrixY * vec3(0.0,0.0,0.0);\n\tshapes[0].radiusOrDistance  = 0.1;\n\tshapes[0].col               = vec4(1.0,0.0,0.0,1.0);\n\tshapes[0].isPlane           = false;\n\t\n\tshapes[1].posOrNormal       = RotationMatrixY * vec3(0.4,0.0,-0.2);\n\tshapes[1].radiusOrDistance  = 0.15;\n\tshapes[1].col               = vec4(0.0,1.0,0.0,1.0);\n\tshapes[1].isPlane           = false;\n\t\n\tshapes[2].posOrNormal       = RotationMatrixY * vec3(-0.2,0.0,0.2);\n\tshapes[2].radiusOrDistance  = 0.05;\n\tshapes[2].col               = vec4(0.5,0.0,1.0,1.0);\n\tshapes[2].isPlane           = false;\n\t\n\tshapes[3].posOrNormal       = RotationMatrixY * vec3(0.1,0.0,-0.5);\n\tshapes[3].radiusOrDistance  = 0.05;\n\tshapes[3].col               = vec4(0.6,0.2,0.0,1.0);\n\tshapes[3].isPlane           = false;\n\t\n\tshapes[4].posOrNormal       = RotationMatrixY * vec3(0.6,0.0,0.5);\n\tshapes[4].radiusOrDistance  = 0.1;\n\tshapes[4].col               = vec4(1.0,0.5,0.5,1.0);\n\tshapes[4].isPlane           = false;\n\t\n\tshapes[5].posOrNormal\t\t= vec3(0.0,1.0,0.0);\n\tshapes[5].radiusOrDistance  = 0.5;\n\tshapes[5].col               = vec4(0.5,0.2,0.5,1.0);\n\tshapes[5].isPlane\t\t\t= true;\n\t\n\tlightPos[0] = vec3(0.0,3.0,0.0);\n\tlightPos[1] = vec3(8.0,0.0,-5.0);\n}\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tShape shapes[6];\n\tCreateShapes(shapes);\n\t\n\tvec3 ray = CreateRay();\n\tvec4 col = vec4(0.0,0.0,0.0,1.0);\n\tvec3 origin = camOrigin;\n\tvec3 contactPoint = vec3(0.0,0.0,0.0);\n\tvec3 normal = vec3(0.0,0.0,0.0);\n\tfloat t = NO_INTERSECTION;\n\tint index = -1;\n\t\n\t\n\tfor(int depth = 0; depth < 2; depth++)\n\t{\n\t\tfloat refCoeff = 1.0;\n\t\t\n\t\tfloat newT;\n\t\tfor(int s = 0; s < 6; s++)\n\t\t{\n\t\t\t\n\t\t\t\n\t\t  if(shapes[s].isPlane)\n\t\t  {\n\t\t\t  newT = IntersectPlane(ray,origin,shapes[s]);\n\t\t  }\n\t\t  else\n\t\t  {\n\t\t\t  newT = IntersectSphere(ray,origin,shapes[s]);\n\t\t  }\n\t\t\t  \n\t\t  if(newT < t && newT > 0.0)\n\t\t  {\n\t\t\t  t = newT;\n\t\t\t  index = s;\n\t\t\t  contactPoint = origin + t * ray;\n\t\t\t  \n\t\t\t  if(shapes[s].isPlane)\n\t\t\t  {  \n\t\t\t    normal = shapes[s].posOrNormal;\n\t\t\t  }\n\t\t\t  else\n\t\t\t  {\n\t\t\t\t  \n\t\t\t\tnormal   = normalize(contactPoint - shapes[s].posOrNormal);\n\t\t\t  }\n\t\t\t  \n\t\t  }\n\t\t}\n\t\t\n\t\tif(index != -1)\n\t\t{\n\t\t\tcol += refCoeff * GenColor(contactPoint,shapes,index,ray,normal);\n\t\t\tray = normalize(reflect(ray,normal));\n\t\t\torigin = contactPoint + ray * 0.1;\n\t\t\trefCoeff * 0.5;\n\t\t\tt = NO_INTERSECTION;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\tfragColor = clamp(col,0.0,1.0);\n}", "image_inputs": [{"id": "XsXGRn", "previewfilepath": "/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldlSz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[846, 1092, 1140, 1140, 1608], [1611, 1611, 1669, 1669, 1894], [1896, 1896, 1955, 1999, 2910], [2913, 2913, 2931, 2931, 3283], [3285, 3362, 3444, 3444, 4301], [4303, 4458, 4498, 4498, 5731], [5734, 5734, 5791, 5791, 6930]], "test": "error"}
{"id": "ldlXzM", "name": "Clouds physically-based II", "author": "jamiep", "description": "Refinement.", "tags": ["clouds"], "likes": 18, "viewed": 900, "published": "Public", "date": "1398630782", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// hash based 3d value noise\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\n\nconst float KAPPA = 0.1;  // extinction coefficient\n\nvec3 sun_direction()\n{\n\tfloat freq = 1.0;\n\tfloat phase = 2.0 + freq*iTime;\n\treturn normalize(vec3(cos(phase), 0.1, sin(phase)));\n}\n\n// returns clouds extinction coeff. as a function of world position\nfloat clouds_extinction( in vec3 p )\n{\t\n\tfloat spatial_period = 40.0;\n\tp /= spatial_period;\n\t\n\tfloat timefreq = 2.0;\n\tvec3 q = p - vec3(1.0,0.1,0.0)*timefreq*iTime;\n\t\n\tfloat cloud_height = 2.5;\n\tfloat m = sin(0.05*timefreq*iTime*2.0*3.14);\n\tfloat layer_y = -0.9*(1.0+0.25*m*m)*cloud_height;\n\n\tfloat N;\n\tfloat g = 1.0;\n\tfloat beta = 0.4;\n    N  = g * noise( q ); q *= 2.0; g *= beta;\n    N += g * noise( q ); q *= 3.0; g *= beta;\n    N += g * noise( q ); q *= 4.0; g *= beta;\n    N += g * noise( q );\n\t\n\tfloat s = 0.16; // edge smoothness (0=hard, 1=smooth)\n\t\n\tfloat cloudtop_y = layer_y + cloud_height*pow(abs(N), 0.7);\n\treturn KAPPA * (smoothstep(p.y-s*cloud_height, p.y+s*cloud_height, cloudtop_y));\n}\n\n\n// return sun+sky radiance\nvec3 sky_color( in vec3 rd )\n{\n\tvec3 skyColor = vec3(0.6,0.71,0.78) - rd.y*0.25*vec3(1.0,0.5,1.0);\n\tfloat sp = dot(sun_direction(), rd) - cos(radians(5.0));\n\tvec3 sun = 2.0e6 * vec3(1.0,0.9,0.7) * pow(sp * step(0.0, sp), 2.3);\n\tskyColor += sun;\n\treturn skyColor;\n}\n\n\n// return radiance reaching the point pos from the sun\nvec3 reduced_sun( in vec3 pos )\n{\n\tconst int num_steps = 2;\n\tconst float max_dist = 8.0;\n\tfloat dl = max_dist/float(num_steps);\n\tfloat Transmittance = 1.0;\n\tfor(int i=0; i<num_steps; i++)\n\t{\n\t\tif(Transmittance < 0.001) break;\n\t\tpos += dl*sun_direction();\n\t\tfloat kappa = clouds_extinction( pos );\n\t\tTransmittance *= exp(-kappa*dl);\n\t}\n\treturn Transmittance * sky_color(sun_direction());\n}\n\n\n// Henyey-Greenstein phase function\nfloat phasefunction(in vec3 a, in vec3 b)\n{\n\tfloat mu = dot(a, b);\n\tfloat g = 0.2;\n\tfloat gSqr = g*g;\n\tfloat oofp = 1.0/(4.0*3.141592);\n\treturn oofp * (1.0 - gSqr) / pow(1.0 - 2.0*g*mu + gSqr, 1.5);\t\n}\n\n\n// raymarch to complete volume rendering integral\nvec3 primary( in vec3 ro, in vec3 rd )\n{\n\tconst float max_dist = 500.0;\n\tconst int num_steps = 128;\n\tfloat dl = max_dist/float(num_steps);\n\t\n\tvec3 pos = ro;\n\tfloat Transmittance = 1.0;\n\t\n\t// Calculate volume rendering integral along primary ray\n\tvec3 InScattered = vec3(0.0);\n\tfor(int i=0; i<num_steps; i++)\n\t{\n\t\tif(Transmittance < 0.01) break;\n\t\tpos += dl*rd;\n\t\tfloat kappa = clouds_extinction( pos );\n\t\tTransmittance *= exp(-kappa*dl);\n\t\t\n\t\t// single scattering given by in-scatter of sunlight\n\t\tconst vec3 albedo = vec3(0.85, 0.82, 0.90);\n\t\tvec3 single_scatt = albedo * kappa * dl * reduced_sun(pos) * phasefunction(sun_direction(), rd);\n\t\t\n\t\t// Fake multiple scattering by a constant emission field (power is an ad-hoc aesthetic tune-\n\t\t// though the power 1.0 possibly has some physical basis, since the diffuse light can be expected\n\t\t// to be roughly proportional to the density of scatterers\n\t\tvec3 fake_multiple_scatt = 0.9*albedo * kappa * dl * pow(kappa/KAPPA, 0.3) * 2.5 * vec3(0.33, 0.35, 0.34);\n\t\t\n\t\t// Accumulate integrand\n\t\tInScattered += Transmittance * (single_scatt + fake_multiple_scatt);\n\t}\n\n\tvec3 AttenuatedBackground = Transmittance*sky_color(rd);\n\treturn InScattered + AttenuatedBackground;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x/ iResolution.y;\n    vec2 mo = -1.0 + 2.0*iMouse.xy / iResolution.xy;\n    \n    // camera\n    vec3 ro = 4.0*normalize(vec3(cos(2.75-3.0*mo.x), 1.5+(2.0*mo.y+1.0), sin(2.75-3.0*mo.x)));\n\tvec3 ta = vec3(0.0, 1.0, 0.0);\n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n\t// raymarch to obtain transmittance along ray through clouds\n    vec3 L = primary( ro, rd );\n\n    fragColor = vec4( L, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldlXzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 30, 53, 53, 92], [93, 93, 119, 119, 485], [541, 541, 563, 563, 671], [673, 741, 779, 779, 1444], [1447, 1474, 1504, 1504, 1738], [1741, 1796, 1829, 1829, 2184], [2187, 2223, 2266, 2266, 2424], [2427, 2477, 2517, 2517, 3693], [3695, 3695, 3752, 3752, 4374]], "test": "ok"}
{"id": "ldsSR4", "name": "randomly generated shaders", "author": "triss", "description": "On the way to Sims", "tags": ["randomlygeneratedshaders"], "likes": 2, "viewed": 167, "published": "Public", "date": "1397754485", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float add(float a, float b) { return a + b;\t}\nfloat sub(float a, float b) { return a - b;\t}\nfloat div(float a, float b) { return a / b;\t}\nfloat mul(float a, float b) { return a * b;\t}\n\nfloat lt(float a, float b) { return a < b ? 1. : 0.; }\nfloat gt(float a, float b) { return a < b ? 1. : 0.; }\nfloat iff(float v, float then, float els) { return v > 0.5 ? then : els; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfloat x = uv.x * 5. - 2.5, y = uv.y * 5. - 2.5;\n\tfloat t = (iTime/3.);\n\t//float v = smoothstep(smoothstep(min(x, fract(sub(x, y))), abs(mix(clamp(exp2(x), step(x, floor(step(mul(x, y), min(y, x)))), abs(y)), div(x, x), y)), clamp(exp(div(mix(asin(pow(exp(x), smoothstep(x, y, y))), mul(clamp(step(x, y), x, mix(x, y, x)), atan(smoothstep(x, x, x))), x), x)), x, sign(exp2(log2(mod(y, clamp(ceil(y), mix(y, x, x), mix(x, y, y)))))))), fract(sqrt(mod(floor(step(clamp(x, mul(abs(y), tan(x)), y), smoothstep(y, y, sub(pow(y, x), sub(y, y))))), y))), x);\n\n\t//float v = sqrt(x);\n\t\n\t//float v = clamp(log2(smoothstep(y, x, smoothstep(clamp(smoothstep(x, min(acos(x), mix(acos(y), mod(x, y), mix(y, y, y))), sub(mul(min(x, y), mix(x, x, y)), sub(y, clamp(x, y, y)))), mix(sub(x, mix(log2(x), atan(x), clamp(x, x, x))), y, add(sign(exp(y)), sub(y, sqrt(y)))), y), clamp(y, step(div(pow(atan(y), mod(y, x)), clamp(exp2(x), clamp(x, x, y), clamp(x, x, x))), clamp(smoothstep(fract(y), log(y), y), mul(mix(y, y, x), mix(x, x, y)), sub(smoothstep(y, y, x), step(x, y)))), clamp(exp(mix(smoothstep(x, y, x), x, log2(y))), y, clamp(mix(mix(y, x, y), pow(x, x), mix(x, y, y)), x, x))), abs(div(mix(sqrt(step(x, y)), sqrt(mod(y, x)), clamp(smoothstep(y, x, y), clamp(y, y, y), mix(y, x, y))), clamp(mix(ceil(y), sub(x, x), clamp(x, x, x)), clamp(sign(x), mod(y, x), div(x, y)), fract(step(x, x)))))))), div(abs(clamp(exp(y), mix(x, mul(y, sign(clamp(x, floor(y), max(x, x)))), add(tan(pow(log(y), x)), y)), atan(add(min(mod(log(x), y), sqrt(smoothstep(x, y, y))), x)))), sub(mix(tan(smoothstep(atan(clamp(mix(y, y, y), ceil(x), add(x, x))), smoothstep(sqrt(clamp(x, y, y)), step(x, add(x, x)), mix(mod(y, y), sin(y), mod(x, y))), exp(mix(smoothstep(x, y, y), acos(x), log(x))))), x, y), step(max(log(sqrt(tan(sign(y)))), smoothstep(smoothstep(mix(x, x, mix(x, x, x)), div(mod(y, y), mix(y, y, x)), mul(smoothstep(y, x, x), x)), y, log(min(fract(x), max(y, x))))), sign(clamp(mix(mul(abs(x), step(x, x)), x, log2(x)), mul(smoothstep(sub(x, x), sqrt(x), mix(y, y, x)), y), mix(add(min(y, y), clamp(y, y, x)), y, floor(atan(x)))))))), y);\n\t//float v = smoothstep(sub(mul(mix(smoothstep(x, sign(x), sub(mul(step(y, atan(t)), x), x)), cos(y), step(log(y), exp(clamp(sign(t), mul(cos(t), x), x)))), t), y), t, mul(acos(smoothstep(y, clamp(asin(t), x, asin(y)), sign(x))), x));\n\t\n\t//float v = mix(fract(smoothstep(mix(div(sub(mix(sub(t, sqrt(x)), sqrt(add(x, x)), y), mix(t, mix(log2(x), smoothstep(t, x, x), mix(y, x, t)), y)), step(mul(sign(clamp(t, t, y)), abs(asin(x))), max(div(max(x, t), t), t))), step(y, mix(exp(mul(y, clamp(y, t, y))), clamp(acos(y), clamp(mod(y, t), clamp(y, y, t), mix(y, x, t)), sub(smoothstep(x, y, x), add(x, x))), pow(x, smoothstep(smoothstep(y, x, y), smoothstep(y, t, t), clamp(t, x, y))))), step(atan(pow(y, x)), pow(sign(tan(sub(x, y))), y))), clamp(clamp(mix(exp(sin(min(t, x))), add(y, x), x), min(min(clamp(mix(y, x, t), fract(y), sub(t, t)), x), clamp(atan(ceil(t)), smoothstep(mod(x, y), atan(t), x), pow(clamp(y, y, y), mix(y, x, x)))), add(sub(tan(min(y, y)), clamp(tan(t), sub(y, y), acos(t))), smoothstep(x, y, log(add(t, t))))), x, mix(tan(t), y, acos(tan(clamp(max(x, x), mix(y, y, x), t))))), mul(y, t))), mix(y, t, smoothstep(ceil(ceil(t)), abs(log2(exp(mix(ceil(step(t, y)), acos(clamp(x, x, x)), sqrt(max(y, x)))))), abs(t))), pow(exp(sin(mix(min(t, mul(tan(clamp(y, y, t)), y)), mix(mix(log2(asin(y)), y, sin(sub(x, x))), y, acos(acos(div(t, y)))), cos(add(pow(mod(t, x), t), cos(x)))))), y));\n\t\n\t//float v = exp(smoothstep(smoothstep(t, smoothstep(y, max(t, x), smoothstep(x, floor(y), exp2(mix(t, y, x)))), x), ceil(x), clamp(tan(clamp(div(clamp(mul(mix(t, t, y), smoothstep(t, t, y)), log2(max(y, y)), atan(t)), smoothstep(asin(add(y, x)), y, smoothstep(clamp(t, t, t), mix(y, x, x), y))), step(log2(sin(mod(y, y))), exp(smoothstep(pow(y, x), mix(y, x, x), mul(t, y)))), log(x))), mod(mix(sub(y, x), max(mix(clamp(step(t, y), smoothstep(x, x, x), x), atan(pow(x, x)), div(smoothstep(y, x, x), sub(y, t))), floor(clamp(x, log2(t), clamp(x, x, x)))), exp2(exp2(clamp(smoothstep(x, x, y), step(y, y), cos(t))))), div(mix(fract(div(ceil(x), log2(y))), y, y), mod(mod(sqrt(acos(x)), mix(mix(y, y, y), smoothstep(x, y, t), x)), sqrt(smoothstep(atan(y), clamp(y, x, x), log2(y)))))), smoothstep(step(t, add(x, smoothstep(acos(smoothstep(y, y, x)), max(exp2(x), fract(x)), mod(t, fract(t))))), t, y))));\n\t\n\t//float v = sqrt(mul(mod(smoothstep(x, cos(max(step(t, cos(tan(x))), clamp(mix(tan(x), step(y, y), t), mix(t, add(t, y), t), asin(asin(t))))), smoothstep(ceil(step(sin(mix(x, y, x)), smoothstep(max(y, y), min(x, y), smoothstep(y, x, y)))), smoothstep(add(mod(max(t, t), mix(x, x, y)), sub(smoothstep(y, x, t), y)), log(smoothstep(mod(x, x), exp(x), smoothstep(x, y, t))), smoothstep(clamp(mix(t, y, x), mix(y, x, y), smoothstep(y, y, t)), sin(smoothstep(x, t, y)), step(y, sin(y)))), log(t))), clamp(clamp(pow(min(clamp(clamp(x, y, t), smoothstep(t, y, t), exp2(y)), add(sub(y, y), y)), x), div(div(acos(log(t)), y), max(add(max(y, x), log2(y)), mix(x, t, div(x, t)))), clamp(exp(tan(smoothstep(x, t, x))), clamp(floor(y), div(fract(t), x), step(t, x)), mix(step(clamp(t, x, t), y), t, smoothstep(t, mix(t, t, y), sqrt(x))))), fract(mod(x, add(y, exp(min(y, y))))), y)), x));\n\n\t//float v= cos(exp(mix(x, y, t)));\n\t//float v = exp(abs(sin(sub(clamp(log2(clamp(clamp(sqrt(t), tan(y), smoothstep(y, y, t)), max(sign(x), add(t, y)), sub(fract(t), max(t, x)))), atan(add(x, sub(clamp(t, y, t), log(y)))), step(t, x)), t))));\n\t\n\t//float v = x;\n\t//float v = mix(exp2(mix(sub(smoothstep(max(sub(mix(floor(y), clamp(x, t, y), mix(x, x, x)), y), fract(mul(asin(x), x))), exp(mod(acos(tan(y)), clamp(log(y), ceil(x), atan(x)))), step(smoothstep(iff(add(y, x), clamp(x, t, y), clamp(t, y, t)), smoothstep(pow(t, t), t, clamp(y, t, y)), iff(tan(x), sub(t, t), sign(y))), iff(sign(clamp(t, t, y)), min(gt(t, t), mod(x, x)), mix(iff(x, y, t), pow(y, t), x)))), exp(step(log2(abs(sub(t, t))), step(t, fract(mix(x, y, t)))))), max(x, exp2(log2(t))), t)), clamp(log2(t), mix(gt(iff(mix(div(clamp(clamp(x, x, t), clamp(y, y, x), mul(t, y)), exp2(log2(x))), max(mix(clamp(y, y, x), iff(x, y, x), x), pow(mod(t, t), mul(x, x))), x), t, sin(min(x, iff(t, sqrt(x), gt(x, y))))), t), log(mul(mix(mix(lt(sub(t, x), sub(t, y)), step(abs(t), y), sqrt(add(y, y))), y, t), div(clamp(mul(exp(y), x), x, fract(y)), y))), iff(t, clamp(t, floor(min(lt(iff(t, y, t), x), pow(y, x))), log2(mix(y, floor(mix(t, x, y)), y))), t)), t), add(fract(sign(x)), log2(gt(sub(atan(sign(x)), y), ceil(mix(min(log(t), ceil(t)), atan(div(sign(y), log(t))), lt(y, asin(mul(t, t)))))))));\n\t\n\t//float v = pow(acos(y), clamp(exp2(y), fract(iff(mod(y, sub(sqrt(x), exp2(lt(exp(y), mix(x, t, y))))), iff(t, t, log(sub(lt(clamp(x, x, y), x), t))), sub(tan(t), y))), mix(t, div(log(atan(sqrt(fract(acos(x))))), div(lt(pow(mix(y, t, iff(y, y, x)), clamp(y, add(y, t), acos(y))), pow(mul(gt(t, x), iff(y, t, y)), t)), mix(mix(lt(y, cos(t)), sign(mix(y, x, x)), exp2(atan(x))), abs(x), mix(x, mod(sub(x, y), clamp(x, t, y)), clamp(log2(t), acos(x), acos(x)))))), x)));\n\t\n\t//float v = mul(step(min(y, iff(sub(iff(cos(step(div(x, t), smoothstep(y, t, x))), y, t), x), x, asin(step(sin(y), sub(t, asin(sqrt(y))))))), x), x);\n\t\n\t//float v = iff(div(x, exp2(mix(mix(add(gt(step(iff(x, x, x), lt(y, t)), lt(y, clamp(x, t, t))), exp2(min(t, step(x, x)))), acos(clamp(step(sub(t, t), gt(y, t)), div(smoothstep(y, t, x), mul(y, x)), clamp(t, asin(t), t))), sub(clamp(step(y, max(x, x)), clamp(smoothstep(t, t, x), y, t), y), y)), pow(smoothstep(ceil(iff(step(x, t), y, mod(y, t))), mod(div(atan(t), clamp(y, y, t)), sqrt(x)), smoothstep(t, y, add(smoothstep(t, x, t), y))), smoothstep(x, sqrt(clamp(y, mul(t, t), ceil(x))), x)), smoothstep(mix(sign(cos(div(x, y))), sub(mod(step(x, t), atan(y)), clamp(add(y, y), iff(x, y, x), step(x, y))), clamp(tan(t), ceil(mod(x, x)), iff(x, floor(t), smoothstep(x, y, y)))), x, smoothstep(sqrt(t), x, sub(sqrt(mod(y, x)), iff(floor(x), atan(t), pow(x, x)))))))), iff(mul(mix(add(iff(add(pow(ceil(x), atan(t)), clamp(add(t, y), t, iff(t, t, y))), mul(clamp(sign(t), mul(t, t), x), mix(clamp(y, t, y), sub(t, t), clamp(x, t, y))), y), min(sign(ceil(log2(x))), floor(smoothstep(t, t, mod(x, x))))), atan(x), step(mod(y, x), pow(log2(sin(sub(y, t))), y))), clamp(clamp(asin(step(x, log2(smoothstep(y, x, y)))), y, log(t)), atan(add(pow(div(mix(t, t, x), t), div(t, sqrt(x))), iff(x, lt(max(t, x), exp2(x)), div(sin(y), y)))), clamp(exp(asin(log(sign(x)))), mod(log2(sign(y)), x), t))), smoothstep(x, atan(mix(gt(t, t), lt(floor(x), x), fract(asin(exp2(clamp(x, x, y)))))), exp(min(clamp(y, step(t, ceil(t)), fract(sqrt(iff(t, x, t)))), x))), y), x);\n\n\t//float v = exp2(y);\n\t\n\t//float v = asin(max(mix(iff(sqrt(gt(acos(y), y)), t, clamp(t, sign(t), fract(atan(x)))), mix(div(tan(smoothstep(step(atan(t), mul(x, x)), sqrt(smoothstep(x, t, x)), min(tan(x), x))), cos(mix(x, sin(max(y, t)), log2(floor(x))))), ceil(y), x), y), cos(x)));\n\n\t//float v = mul(x, y);\n\t//float v = pow(x, pow(add(mul(step(log2(mix(atan(div(y, t)), x, log2(max(y, x)))), x), x), iff(div(y, iff(mul(add(div(y, x), iff(t, x, y)), x), lt(clamp(iff(y, x, t), add(y, y), tan(t)), smoothstep(add(t, t), smoothstep(t, y, y), sqrt(t))), iff(smoothstep(x, y, sign(y)), fract(y), t))), fract(sin(add(mul(t, y), smoothstep(y, pow(t, y), iff(x, x, t))))), smoothstep(ceil(sub(log(mul(t, y)), add(y, abs(t)))), clamp(iff(clamp(x, sin(t), sub(x, x)), iff(x, max(x, t), tan(x)), sign(smoothstep(t, y, t))), add(x, smoothstep(fract(x), floor(x), log2(x))), pow(smoothstep(iff(x, x, t), t, mod(t, t)), ceil(atan(y)))), add(mix(iff(exp(x), min(x, t), max(y, t)), t, fract(y)), mix(max(max(x, y), floor(y)), clamp(mod(x, x), cos(t), exp2(t)), t))))), min(pow(max(y, y), iff(t, y, mul(mod(fract(pow(x, t)), mix(t, exp2(y), ceil(x))), max(mod(t, smoothstep(t, t, x)), max(ceil(y), sin(y)))))), sin(pow(exp2(tan(y)), clamp(fract(smoothstep(iff(x, y, t), clamp(x, x, x), y)), log(lt(pow(x, t), t)), smoothstep(ceil(floor(y)), iff(atan(x), add(t, y), sub(y, x)), smoothstep(sin(y), tan(x), asin(y)))))))));\n\n\t//float v = min(add(iff(sqrt(t), floor(sub(x, iff(asin(mix(mul(x, t), floor(y), y)), fract(log(mix(y, t, y))), clamp(t, mix(clamp(t, y, t), y, clamp(y, y, t)), lt(abs(x), fract(t)))))), smoothstep(gt(asin(sin(t)), y), clamp(t, cos(clamp(t, y, sub(log2(t), iff(y, x, y)))), sub(floor(fract(sin(y))), x)), clamp(clamp(clamp(log(log2(x)), sub(floor(y), div(t, x)), iff(acos(y), y, iff(t, t, x))), min(smoothstep(mix(x, x, y), t, clamp(y, t, t)), y), abs(clamp(t, mod(y, t), sin(y)))), smoothstep(min(clamp(mix(y, t, y), y, clamp(x, t, x)), add(t, x)), atan(mix(step(t, t), mix(x, y, y), div(x, y))), asin(smoothstep(atan(t), mix(x, x, x), lt(x, y)))), floor(t)))), fract(x)), smoothstep(max(add(t, iff(gt(div(mul(smoothstep(y, y, y), y), mix(mul(t, x), div(y, y), exp(y))), mul(clamp(max(x, y), lt(y, x), mix(t, y, x)), mul(iff(x, x, t), add(t, x)))), y, mul(x, y))), sign(x)), step(clamp(pow(x, x), step(y, iff(mix(mix(x, div(t, x), t), atan(div(y, x)), iff(mod(y, y), sub(x, y), iff(x, x, y))), y, y)), t), smoothstep(atan(max(mod(x, min(gt(t, t), t)), smoothstep(lt(x, cos(y)), min(exp2(x), smoothstep(x, y, x)), t))), div(t, y), sqrt(min(clamp(ceil(gt(y, x)), t, t), x)))), t));\n\t//float v = fract(t);\n\t//float v = sin(clamp(mix(iff(atan(pow(smoothstep(iff(mix(t, t, t), log2(t), y), y, iff(exp2(y), add(x, y), acos(t))), x)), t, iff(y, cos(y), sqrt(pow(iff(t, smoothstep(x, x, y), sqrt(y)), smoothstep(floor(x), iff(y, t, t), gt(x, t)))))), mix(atan(sin(atan(x))), min(ceil(floor(y)), atan(step(clamp(ceil(y), x, mix(x, y, x)), x))), clamp(t, step(y, y), log(fract(mod(mod(t, x), div(t, x)))))), pow(pow(t, div(x, smoothstep(fract(mod(t, y)), step(mul(x, y), x), t))), x)), exp(min(t, smoothstep(smoothstep(acos(x), sqrt(gt(clamp(t, y, y), lt(y, x))), t), sin(clamp(sign(y), atan(log2(x)), mix(y, ceil(y), mix(t, x, t)))), t))), iff(smoothstep(x, mod(floor(max(ceil(mix(t, y, y)), x)), iff(sign(iff(y, mix(x, y, x), gt(y, t))), y, y)), ceil(t)), exp(smoothstep(pow(x, atan(cos(x))), x, mix(iff(x, mix(add(t, x), t, mix(x, t, y)), sin(max(x, x))), mix(acos(mul(x, t)), step(y, smoothstep(t, y, x)), clamp(clamp(x, y, t), tan(t), fract(y))), t))), add(mix(clamp(smoothstep(x, mix(step(y, t), y, y), step(ceil(x), t)), clamp(y, asin(mix(y, y, t)), sin(t)), sign(iff(iff(x, x, t), smoothstep(y, t, y), log(t)))), smoothstep(gt(t, smoothstep(t, y, atan(t))), clamp(x, atan(div(x, t)), clamp(max(x, t), floor(y), atan(y))), t), sub(step(gt(exp(t), acos(t)), mix(step(y, x), step(x, t), tan(t))), mix(t, clamp(t, fract(y), clamp(x, y, x)), max(t, y)))), mod(sub(x, sqrt(gt(iff(y, t, t), mul(t, t)))), y)))));\n\n//float v = mix(clamp(gt(pow(add(clamp(clamp(mix(y, ceil(t), gt(x, t)), smoothstep(log(y), exp2(t), x), abs(smoothstep(t, t, x))), x, x), iff(lt(mix(cos(x), atan(y), abs(t)), mod(smoothstep(x, t, t), asin(x))), t, y)), max(y, acos(y))), log(y)), log2(iff(floor(mod(smoothstep(smoothstep(t, smoothstep(y, x, t), max(t, y)), t, sub(abs(x), sqrt(t))), min(min(gt(y, t), x), gt(sub(y, y), t)))), mul(sin(smoothstep(mix(t, mix(x, y, x), smoothstep(t, x, t)), min(iff(y, y, y), atan(y)), max(y, lt(t, t)))), atan(mod(mix(t, x, ceil(x)), asin(sqrt(y))))), lt(pow(smoothstep(mul(cos(x), mix(t, y, y)), fract(lt(t, x)), mix(tan(x), x, mul(x, t))), x), min(gt(min(add(x, y), exp2(t)), x), sub(x, mul(floor(y), fract(t))))))), clamp(add(asin(step(lt(add(iff(x, y, y), min(y, t)), tan(asin(x))), t)), sin(clamp(atan(mul(div(t, y), iff(t, t, t))), x, log(x)))), acos(iff(sign(atan(ceil(x))), lt(atan(max(exp2(y), clamp(t, t, x))), y), step(add(clamp(y, iff(y, x, t), iff(y, y, y)), smoothstep(abs(x), x, lt(x, t))), max(acos(mix(x, t, x)), lt(iff(t, x, y), pow(t, y)))))), y)), log(acos(min(y, lt(pow(clamp(atan(mul(t, y)), mul(pow(y, t), step(x, y)), smoothstep(cos(t), mul(t, x), y)), clamp(min(y, t), iff(y, t, asin(y)), exp(clamp(x, y, t)))), tan(mul(t, pow(asin(t), min(y, x)))))))), gt(smoothstep(y, sign(mix(mod(x, mix(x, exp2(smoothstep(t, y, y)), y)), lt(smoothstep(y, x, sin(t)), smoothstep(clamp(smoothstep(y, t, x), y, min(t, x)), y, smoothstep(smoothstep(t, x, t), mix(x, x, t), atan(t)))), mix(fract(sub(sqrt(x), t)), x, tan(sub(x, iff(x, t, t)))))), y), smoothstep(mul(smoothstep(clamp(add(smoothstep(clamp(t, x, t), log(x), y), exp(smoothstep(y, t, x))), div(iff(mix(t, y, y), cos(y), max(y, t)), add(mix(t, t, y), asin(t))), fract(y)), iff(t, iff(gt(clamp(x, y, t), mod(y, y)), tan(lt(y, y)), fract(step(t, x))), log(y)), add(acos(max(ceil(y), iff(x, y, t))), mix(gt(log(y), sqrt(x)), iff(mix(x, y, y), iff(y, y, y), atan(y)), mix(div(y, x), y, sqrt(x))))), atan(mix(mix(iff(log(x), exp2(x), exp(x)), iff(mix(x, t, t), floor(x), t), ceil(t)), smoothstep(x, x, sin(acos(x))), lt(iff(tan(t), tan(x), pow(t, y)), t)))), lt(abs(y), add(t, t)), mix(mod(step(mul(cos(clamp(x, y, y)), atan(t)), mix(max(x, smoothstep(x, t, y)), clamp(t, floor(y), lt(y, x)), t)), x), fract(clamp(x, smoothstep(iff(mix(x, t, y), clamp(t, x, y), smoothstep(x, y, t)), step(y, mul(y, t)), y), max(sign(t), x))), iff(exp(fract(exp2(sqrt(y)))), x, lt(clamp(t, gt(y, smoothstep(t, t, t)), clamp(iff(t, y, y), t, clamp(t, t, x))), step(clamp(x, clamp(x, y, x), clamp(y, y, x)), t)))))));\n\n//float v = max(gt(log(iff(y, y, fract(mix(t, smoothstep(mod(t, t), smoothstep(add(x, y), y, y), mul(mix(t, y, x), gt(x, y))), smoothstep(log2(smoothstep(t, y, y)), iff(add(t, t), iff(y, y, x), t), add(floor(y), y)))))), pow(ceil(tan(floor(x))), iff(abs(x), exp(asin(pow(x, sqrt(tan(y))))), step(min(min(x, sign(x)), pow(max(iff(x, t, x), cos(t)), atan(fract(t)))), lt(y, x))))), y);\n\n\t//float v = tan(pow(add(max(x, log2(sub(tan(sin(x)), x))), gt(smoothstep(mod(t, x), max(y, x), mix(sign(mix(div(y, x), mix(y, t, y), ceil(t))), y, ceil(x))), smoothstep(iff(iff(sign(floor(y)), log(t), sub(pow(y, t), floor(y))), t, atan(lt(tan(x), y))), pow(exp2(gt(smoothstep(t, y, y), log2(y))), lt(y, lt(clamp(t, y, y), iff(y, x, t)))), log(asin(t))))), div(lt(iff(step(lt(sin(log2(x)), lt(mul(y, x), min(x, x))), mod(sqrt(ceil(y)), y)), gt(atan(asin(iff(y, y, y))), smoothstep(mul(ceil(x), x), atan(t), min(exp2(t), clamp(y, t, t)))), add(sqrt(mul(pow(x, t), x)), mod(smoothstep(sign(t), sub(y, x), iff(y, t, x)), add(x, mix(y, x, y))))), floor(pow(mix(mod(t, y), mul(mix(t, t, y), exp(t)), ceil(lt(y, x))), sign(add(log2(t), iff(t, y, y)))))), min(acos(pow(clamp(cos(mix(y, x, y)), min(mod(x, t), y), fract(y)), lt(x, clamp(clamp(x, t, y), div(y, x), mix(t, x, t))))), acos(iff(clamp(sqrt(y), div(add(y, x), x), clamp(x, asin(x), tan(x))), ceil(mix(iff(t, t, x), clamp(x, x, t), asin(y))), clamp(log2(t), add(acos(x), acos(y)), clamp(ceil(t), mod(y, y), gt(t, x)))))))));\n\n//float v = fract(pow(sign(abs(iff(mix(t, clamp(x, clamp(sqrt(y), x, min(x, x)), atan(sub(t, t))), floor(y)), step(sin(floor(mix(y, y, x))), x), t))), acos(y)));\n//float v = mod(t, x);\n\t//float v = div(mix(x, clamp(mod(max(mix(mix(add(mod(y, x), acos(y)), iff(add(x, t), clamp(y, x, y), x), log(atan(y))), smoothstep(log2(smoothstep(t, t, t)), acos(smoothstep(x, y, x)), asin(cos(y))), mul(mul(sign(x), mul(x, y)), div(mix(x, x, y), log2(x)))), t), t), y, iff(smoothstep(exp2(x), add(floor(y), lt(t, floor(mix(t, x, x)))), t), add(y, mix(pow(smoothstep(exp(y), max(t, y), asin(t)), x), add(sub(y, sub(y, x)), t), log2(t))), t)), smoothstep(lt(min(log(iff(iff(acos(x), sin(x), iff(t, x, y)), iff(sub(y, t), t, clamp(x, y, x)), y)), sub(y, mix(t, pow(x, mix(t, t, y)), t))), step(y, smoothstep(y, max(acos(log2(t)), iff(max(x, t), pow(x, y), iff(y, y, y))), sign(x)))), x, smoothstep(floor(asin(div(clamp(y, x, step(x, y)), iff(mod(x, y), mod(y, t), clamp(y, t, t))))), y, x))), iff(y, clamp(div(acos(lt(x, smoothstep(sub(div(y, t), gt(x, y)), x, log(div(x, y))))), cos(mul(y, sub(mix(x, clamp(t, y, y), t), smoothstep(y, lt(y, t), tan(x)))))), sqrt(pow(iff(exp(clamp(cos(x), pow(t, t), lt(t, y))), lt(iff(t, lt(x, y), y), cos(sub(y, y))), sub(smoothstep(mix(x, t, y), x, t), mix(exp(y), t, clamp(y, t, t)))), iff(iff(atan(gt(y, x)), x, sqrt(mix(y, x, x))), max(log2(t), clamp(sqrt(x), log2(x), exp2(x))), atan(x)))), asin(step(exp(smoothstep(pow(pow(x, t), exp(t)), clamp(iff(t, y, y), floor(x), sin(y)), lt(sign(x), atan(x)))), fract(iff(smoothstep(iff(y, t, x), step(x, x), x), step(lt(y, x), fract(y)), smoothstep(t, t, max(y, y))))))), clamp(x, lt(t, t), atan(x))));\n\n//float v = iff(t, max(mix(ceil(mix(iff(mix(y, fract(x), mul(t, y)), mix(cos(sign(y)), sub(mod(y, x), smoothstep(y, t, x)), asin(log(y))), mix(clamp(sqrt(x), sin(x), sin(x)), acos(y), mod(add(y, x), atan(y)))), mod(mul(mod(add(t, t), log2(x)), fract(mix(y, t, y))), x), x)), x, y), y), x);\n//float v = sqrt(clamp(step(t, ceil(mix(y, step(iff(smoothstep(y, t, mod(x, y)), mix(abs(y), smoothstep(x, y, t), acos(x)), t), mix(smoothstep(acos(y), step(t, y), add(t, t)), t, lt(y, iff(x, x, t)))), t))), y, clamp(mix(iff(mul(floor(clamp(iff(y, x, t), mod(t, y), mix(t, x, t))), mix(step(sin(t), log2(t)), iff(floor(x), sin(x), sqrt(x)), pow(pow(x, t), fract(y)))), min(abs(clamp(y, div(y, t), mix(t, t, x))), y), clamp(x, max(div(min(y, y), sqrt(y)), gt(x, clamp(x, x, x))), sign(atan(x)))), x, clamp(t, clamp(smoothstep(atan(floor(t)), step(y, log(y)), mix(exp2(y), t, x)), clamp(clamp(x, clamp(t, x, y), t), lt(atan(x), exp2(y)), x), clamp(y, smoothstep(y, min(t, x), atan(y)), t)), y)), sin(clamp(mix(exp2(tan(div(t, x))), atan(t), fract(exp(lt(x, x)))), x, clamp(x, add(cos(mod(y, x)), sqrt(y)), add(exp(sub(y, t)), clamp(mix(y, t, t), log2(x), gt(t, x)))))), t)));\n\n//float v = abs(smoothstep(x, asin(min(smoothstep(pow(pow(acos(div(t, x)), smoothstep(max(t, y), iff(y, t, y), acos(x))), t), pow(y, iff(abs(ceil(x)), y, sub(mix(x, y, y), clamp(x, t, y)))), smoothstep(gt(fract(lt(t, t)), y), x, t)), x)), step(div(t, tan(log2(clamp(sub(clamp(x, t, y), step(x, t)), y, clamp(clamp(x, x, x), ceil(x), smoothstep(x, y, y)))))), tan(x))));\n//float v = min(iff(x, add(exp2(mix(mix(log2(min(t, atan(x))), sub(mix(pow(t, x), y, iff(x, y, y)), smoothstep(iff(x, t, y), x, pow(x, y))), x), gt(mix(sqrt(sub(x, y)), log2(div(t, x)), x), exp(pow(exp2(t), t))), asin(t))), step(iff(tan(sqrt(clamp(smoothstep(x, t, y), exp(t), log2(t)))), x, step(t, min(x, mix(y, step(x, x), cos(y))))), t)), abs(x)), mod(y, tan(fract(min(floor(mix(exp(x), smoothstep(smoothstep(t, t, y), sign(y), t), y)), mix(asin(clamp(x, mix(x, x, t), mix(t, y, x))), add(floor(exp(y)), sign(y)), smoothstep(mix(floor(y), clamp(t, t, y), t), div(step(x, x), mix(x, t, x)), acos(t))))))));\n\t//float v = min(mix(clamp(mix(t, t, cos(floor(sub(x, acos(floor(y)))))), gt(sign(t), t), mix(atan(smoothstep(sin(x), t, iff(ceil(asin(y)), div(x, x), log(t)))), y, atan(x))), sin(floor(atan(max(atan(sqrt(asin(y))), y)))), clamp(sqrt(lt(t, add(mod(mix(sqrt(x), cos(t), smoothstep(x, x, t)), t), iff(iff(smoothstep(y, t, x), cos(y), clamp(t, x, t)), lt(asin(x), fract(t)), x)))), y, ceil(smoothstep(cos(sqrt(t)), log2(mix(clamp(t, t, asin(t)), step(iff(x, t, y), x), smoothstep(lt(t, t), ceil(t), cos(x)))), t)))), mix(x, t, mix(log2(add(t, y)), sub(sign(atan(log(tan(clamp(t, t, t))))), step(mul(x, x), y)), mul(floor(sub(log(t), floor(add(sub(x, y), div(t, y))))), sub(mul(y, max(iff(x, t, log2(y)), clamp(abs(x), div(x, x), step(x, t)))), pow(log(smoothstep(mix(t, x, x), pow(x, x), gt(x, t))), iff(step(x, x), lt(mix(t, x, y), log2(x)), mix(sqrt(x), x, acos(y)))))))));\n\n//float v = clamp(log(smoothstep(clamp(clamp(x, x, y), sqrt(t), step(clamp(log(pow(y, mul(x, t))), log2(sub(t, lt(y, t))), log(add(x, exp(y)))), add(mix(floor(mix(t, y, t)), t, exp2(t)), div(clamp(sqrt(t), y, t), lt(iff(t, t, t), add(x, t)))))), atan(t), x)), iff(t, x, max(y, log2(abs(y)))), gt(mix(mix(t, x, y), iff(t, clamp(t, iff(iff(smoothstep(smoothstep(t, t, t), sub(y, x), mix(x, t, y)), t, max(sign(y), log(y))), ceil(gt(mix(t, t, y), mix(t, t, y))), mix(y, sqrt(mod(x, x)), mod(step(y, y), y))), t), pow(step(t, clamp(mul(pow(t, y), t), asin(sub(t, x)), min(lt(y, t), smoothstep(t, t, t)))), t)), acos(clamp(min(x, y), floor(exp(max(smoothstep(x, x, x), log(y)))), pow(smoothstep(exp2(t), gt(min(y, t), step(t, x)), mul(pow(x, t), asin(y))), t)))), y));\n//float v = smoothstep(clamp(ceil(iff(clamp(smoothstep(iff(exp2(pow(x, t)), x, y), pow(y, smoothstep(add(t, t), smoothstep(y, y, y), ceil(x))), sqrt(y)), mix(div(x, mix(lt(x, t), iff(x, y, x), lt(x, y))), pow(iff(t, sub(x, y), abs(x)), y), clamp(t, pow(lt(t, x), lt(y, x)), ceil(smoothstep(t, x, x)))), pow(log(t), cos(clamp(y, y, clamp(t, t, y))))), mul(gt(y, sign(clamp(pow(t, x), lt(x, x), y))), acos(exp(acos(y)))), lt(pow(atan(t), clamp(sin(clamp(y, t, x)), x, tan(t))), floor(sqrt(log2(y)))))), mix(iff(smoothstep(iff(max(t, iff(floor(x), log(y), mul(x, x))), x, log(t)), y, mix(exp(mul(step(t, y), t)), tan(div(sub(x, t), mix(y, x, y))), pow(mix(abs(t), t, step(x, t)), y))), y, sign(iff(fract(mix(smoothstep(t, x, x), clamp(y, y, t), max(x, x))), x, mix(mix(iff(x, x, x), sqrt(y), y), div(abs(x), asin(x)), y)))), smoothstep(cos(max(sub(x, max(log2(x), add(t, t))), add(t, tan(asin(x))))), y, smoothstep(t, lt(mul(t, clamp(abs(x), pow(t, t), t)), mix(add(smoothstep(y, t, t), mix(y, x, y)), iff(fract(y), smoothstep(y, t, t), smoothstep(t, t, t)), mix(gt(t, t), y, mix(x, y, t)))), t)), mod(sin(tan(add(t, exp(t)))), x)), y), iff(t, t, x), log2(mix(asin(step(min(mix(x, x, y), add(asin(smoothstep(y, x, t)), t)), add(smoothstep(x, x, floor(clamp(y, y, t))), div(min(x, gt(y, t)), step(gt(y, y), add(x, x)))))), y, exp2(clamp(pow(smoothstep(mix(ceil(x), y, acos(t)), smoothstep(add(x, x), y, floor(y)), log(max(t, x))), clamp(clamp(y, y, x), log2(smoothstep(x, y, x)), tan(x))), lt(mul(sign(asin(x)), x), mod(y, pow(fract(y), mix(y, x, t)))), max(div(sub(t, ceil(t)), sqrt(mix(t, x, t))), acos(atan(clamp(x, t, x)))))))));\n//float v = smoothstep(pow(iff(mix(cos(log2(cos(cos(iff(y, x, y))))), y, clamp(mul(smoothstep(clamp(mix(y, t, y), x, iff(x, t, t)), sqrt(y), smoothstep(log(t), step(y, y), smoothstep(x, x, y))), x), fract(mod(clamp(smoothstep(x, x, t), iff(t, t, x), y), sub(sqrt(x), y))), mod(y, div(y, mod(gt(y, t), y))))), mix(x, iff(log2(tan(t)), asin(t), lt(gt(y, x), x)), iff(sign(div(x, t)), pow(t, min(clamp(clamp(t, x, t), sqrt(x), t), min(mix(x, y, x), exp2(y)))), clamp(log2(sin(y)), max(div(y, t), t), sin(y)))), lt(step(tan(floor(smoothstep(y, gt(t, x), add(y, y)))), tan(sub(max(atan(y), smoothstep(y, y, x)), mod(smoothstep(y, x, x), t)))), t)), mix(log(y), div(clamp(y, div(x, mul(t, clamp(smoothstep(t, y, t), gt(x, t), y))), t), y), gt(mod(t, sin(iff(t, iff(pow(t, y), y, y), clamp(smoothstep(x, x, y), floor(y), mul(t, x))))), asin(t)))), log(clamp(sign(smoothstep(sub(iff(min(mix(y, t, t), cos(y)), t, mix(y, t, t)), mix(mix(mix(x, y, y), sub(y, x), y), x, x)), iff(ceil(log2(x)), floor(y), exp2(iff(iff(y, y, t), iff(x, t, y), smoothstep(x, x, y)))), mix(smoothstep(t, smoothstep(sin(t), t, clamp(t, x, x)), ceil(acos(t))), atan(gt(asin(y), smoothstep(t, t, t))), ceil(div(y, t))))), y, x)), mix(x, asin(mix(fract(lt(sin(sin(ceil(x))), mod(log(clamp(x, y, y)), y))), t, pow(mix(gt(clamp(sqrt(t), y, x), mix(pow(x, t), mix(x, x, t), t)), gt(sign(sign(x)), step(smoothstep(x, x, y), gt(t, y))), log2(y)), x))), t));\n//float v = clamp(lt(clamp(fract(clamp(y, mix(exp(t), abs(x), lt(step(iff(x, t, y), exp(x)), x)), abs(mix(y, clamp(x, exp2(x), clamp(x, t, x)), step(smoothstep(t, x, y), gt(y, y)))))), mod(gt(tan(mix(iff(sub(t, x), exp2(y), div(y, x)), ceil(sub(x, t)), mul(mix(x, x, t), cos(t)))), t), sign(sqrt(x))), mul(x, clamp(exp2(mod(smoothstep(y, clamp(x, y, t), acos(y)), acos(smoothstep(y, t, y)))), y, t))), min(asin(max(x, div(x, mod(mod(t, x), add(smoothstep(y, y, t), x))))), exp2(asin(t)))), clamp(smoothstep(x, step(sqrt(pow(t, t)), x), mul(abs(log(y)), abs(clamp(sign(t), y, exp(iff(t, mul(y, x), pow(y, t))))))), atan(t), pow(add(mod(lt(lt(floor(step(y, t)), iff(atan(t), mix(t, x, t), x)), sub(exp2(sin(t)), smoothstep(mod(x, t), smoothstep(y, t, x), iff(y, t, t)))), floor(tan(t))), sign(x)), clamp(cos(clamp(exp(clamp(log(t), div(x, t), t)), gt(sign(clamp(t, x, t)), x), step(y, smoothstep(iff(y, t, t), mod(t, x), x)))), t, clamp(x, smoothstep(mod(atan(smoothstep(y, t, x)), mod(div(t, y), smoothstep(t, y, t))), iff(t, t, y), exp2(x)), exp(x))))), y);\n\t//float v = atan(step(iff(sub(mix(div(exp(exp(iff(y, t, t))), gt(gt(x, step(t, t)), smoothstep(gt(t, t), t, x))), mix(sin(floor(mix(x, t, t))), iff(t, x, smoothstep(max(y, t), smoothstep(y, t, x), clamp(y, y, t))), smoothstep(iff(iff(t, x, x), smoothstep(y, t, x), lt(t, y)), min(lt(t, y), y), iff(x, x, sign(x)))), y), clamp(t, x, y)), exp2(mul(x, clamp(t, gt(step(iff(x, x, y), y), smoothstep(mix(y, t, t), acos(x), add(x, y))), y))), step(clamp(y, fract(fract(lt(x, floor(y)))), x), y)), fract(iff(lt(floor(iff(iff(max(y, y), smoothstep(y, x, y), gt(t, y)), smoothstep(add(x, y), pow(x, y), sign(y)), add(t, sin(x)))), iff(log2(gt(y, ceil(y))), x, mix(pow(sub(y, x), mix(x, t, t)), t, sub(x, smoothstep(t, y, y))))), x, t))));\n//float v = mix(clamp(y, asin(fract(cos(smoothstep(min(cos(mix(y, y, x)), lt(exp2(x), mix(y, x, y))), mix(smoothstep(gt(t, y), atan(x), clamp(t, t, x)), floor(t), atan(step(t, t))), asin(y))))), clamp(step(mod(div(exp(lt(y, sub(y, y))), sub(clamp(smoothstep(x, y, t), iff(y, y, y), y), iff(min(y, t), t, div(y, y)))), min(sign(mix(pow(t, y), y, abs(x))), clamp(pow(iff(y, t, t), step(y, t)), x, asin(t)))), clamp(gt(x, pow(lt(y, x), ceil(div(t, t)))), iff(y, mod(mod(max(x, y), iff(y, x, x)), atan(x)), iff(gt(smoothstep(x, y, y), step(t, x)), mod(clamp(t, y, y), sign(t)), iff(log2(y), pow(x, t), y))), mix(y, y, mix(y, smoothstep(y, clamp(t, t, x), x), sin(iff(y, x, y)))))), mod(y, gt(max(fract(t), atan(iff(atan(t), max(x, x), t))), clamp(y, atan(sign(sign(t))), x))), smoothstep(smoothstep(sign(mix(iff(smoothstep(t, t, t), t, exp2(x)), atan(lt(x, y)), mix(exp2(y), iff(y, y, x), div(t, t)))), y, atan(acos(fract(clamp(y, y, x))))), iff(tan(div(smoothstep(log(x), step(x, t), log(x)), smoothstep(fract(x), x, t))), y, acos(t)), abs(clamp(y, acos(floor(x)), smoothstep(lt(mix(t, x, y), x), div(abs(y), log2(y)), mix(lt(x, y), log2(t), iff(y, x, x)))))))), clamp(smoothstep(iff(x, max(div(div(t, sqrt(mix(t, y, x))), x), step(ceil(sign(cos(x))), x)), t), mix(max(iff(iff(abs(mul(y, y)), pow(t, y), mod(step(x, t), floor(y))), exp(cos(gt(y, x))), tan(div(asin(t), iff(y, y, x)))), sqrt(y)), smoothstep(mul(abs(mod(x, x)), iff(x, x, smoothstep(x, iff(x, x, y), t))), iff(sub(y, x), div(add(pow(y, x), lt(t, t)), iff(exp(t), mod(y, x), t)), t), log(iff(iff(sub(x, t), step(t, t), exp2(t)), clamp(x, sqrt(x), x), iff(y, mix(x, y, x), cos(y))))), x), sin(iff(log(clamp(mul(t, log2(x)), div(x, y), add(y, clamp(x, y, y)))), lt(y, clamp(y, t, x)), y))), log2(atan(t)), t), mix(iff(sqrt(smoothstep(floor(acos(y)), abs(y), cos(x))), y, asin(log(max(lt(t, min(iff(t, y, x), t)), clamp(t, smoothstep(clamp(x, t, y), t, y), iff(iff(x, t, t), iff(t, t, y), gt(y, t))))))), pow(sub(mod(sub(fract(ceil(mod(t, x))), min(fract(iff(y, x, t)), x)), floor(step(abs(sub(y, t)), y))), iff(x, t, fract(clamp(gt(t, step(x, x)), smoothstep(clamp(x, y, y), y, x), exp(div(t, y)))))), t), smoothstep(fract(mod(mix(add(sin(y), tan(gt(x, y))), pow(y, t), x), y)), clamp(mix(t, exp2(sin(clamp(y, max(t, t), t))), pow(y, clamp(exp(mod(x, y)), x, t))), clamp(iff(step(y, mix(y, iff(t, t, t), mix(y, y, y))), tan(clamp(gt(y, y), y, step(y, t))), div(x, x)), log2(log(iff(pow(x, y), iff(y, x, y), cos(t)))), t), iff(log(max(sin(sub(x, x)), exp2(mix(t, y, y)))), y, floor(tan(exp(x))))), pow(t, max(t, sqrt(mix(sub(x, y), max(t, mix(t, t, t)), mix(iff(x, t, t), div(y, t), floor(x)))))))));\n\n//float v = clamp(ceil(div(t, t)), clamp(y, add(y, t), ceil(t)), clamp(max(t, y), mix(y, x, x), step(t, y)));\n\n\t//float v = asin(gt(mul(x, t), sub(x, t)));\n//float v = asin(max(smoothstep(t, y, y), gt(x, x)));\n//float v = clamp(t, iff(mix(t, x, y), sin(t), y), mix(x, iff(x, t, y), fract(x)));\n\n//float v = min(y, abs(clamp(x, x, t)));\n//float v = iff(clamp(step(y, x), sub(t, y), sub(y, y)), mix(y, t, log2(x)), atan(smoothstep(y, t, y)));\n//float v = pow(fract(t), iff(gt(x, y), div(y, t), iff(t, x, y)));\n//\tfloat v = clamp(log2(gt(x, y)), clamp(exp2(x), acos(x), div(x, y)), min(abs(y), t));\n//float v = smoothstep(acos(acos(y)), min(iff(y, t, y), add(x, y)), x);\n//float v = iff(min(min(y, y), asin(t)), clamp(clamp(t, t, t), sub(x, t), sin(x)), sin(y));\n\n//float v = add(sin(mul(y, x)), sqrt(pow(x, t)));\n\t\n//float v = mix(mix(exp2(t), log(x), clamp(y, t, t)), y, smoothstep(cos(y), sub(x, t), t));\n\n//float v = mul(atan(y), div(iff(x, t, t), sqrt(y)));\n\t//float v = step(iff(lt(abs(asin(t)), sin(x)), exp(y), tan(exp(tan(y)))), lt(iff(x, cos(cos(x)), abs(smoothstep(t, t, y))), y));\n\n//float v = add(fract(exp2(y)), fract(ceil(lt(x, mix(y, y, y)))));\n//float v = clamp(log2(t), clamp(smoothstep(mix(ceil(x), fract(t), lt(x, x)), x, floor(log(t))), smoothstep(mul(tan(y), smoothstep(x, x, x)), tan(sign(x)), step(clamp(x, x, x), div(x, t))), sub(y, x)), abs(fract(sqrt(mix(t, y, t)))));\n//float v = lt(log(t), sub(sign(iff(sin(y), mix(x, t, t), acos(t))), y));\n//float v = clamp(fract(gt(atan(x), clamp(t, sqrt(t), y))), pow(mul(max(t, lt(x, x)), floor(y)), exp(atan(mix(t, x, x)))), t);\n\n//float v = smoothstep(x, max(smoothstep(acos(x), t, asin(clamp(iff(smoothstep(y, x, x), iff(x, x, t), y), clamp(smoothstep(y, y, x), t, atan(t)), lt(tan(x), add(y, x))))), min(clamp(mix(clamp(sqrt(x), y, y), ceil(abs(t)), smoothstep(add(t, y), x, sign(t))), tan(asin(y)), smoothstep(smoothstep(cos(x), iff(x, y, y), x), iff(sign(y), min(t, y), pow(x, x)), t)), min(x, div(smoothstep(cos(t), min(t, x), max(x, x)), mod(mod(x, y), y))))), min(y, add(y, exp(sin(gt(clamp(x, x, t), max(x, y)))))));\n\t//float v = pow(smoothstep(min(clamp(clamp(mod(x, gt(y, x)), mix(y, t, log(x)), min(mod(t, t), y)), mod(sub(step(y, t), sin(t)), y), x), mix(clamp(mod(pow(x, t), atan(x)), iff(sin(y), smoothstep(y, t, y), smoothstep(t, t, y)), exp(y)), step(clamp(sqrt(y), iff(x, x, t), smoothstep(x, y, t)), clamp(clamp(t, x, x), x, x)), clamp(smoothstep(clamp(t, y, t), add(t, x), clamp(y, y, t)), clamp(min(x, x), clamp(y, y, t), sub(t, t)), sign(x)))), y, y), floor(pow(mix(t, y, div(t, clamp(mix(t, y, x), max(y, y), lt(t, y)))), smoothstep(smoothstep(log(tan(t)), max(lt(y, x), sign(y)), mix(y, sqrt(y), clamp(t, x, x))), floor(gt(mix(t, y, y), mix(x, y, x))), x))));\nfloat v = iff(mix(exp(t), atan(fract(t)), exp2(log(exp2(sin(div(y, t)))))), mix(lt(cos(sub(sin(clamp(x, t, y)), mix(max(t, y), iff(y, x, y), cos(x)))), exp(x)), gt(min(pow(x, min(asin(y), t)), tan(asin(sub(x, y)))), atan(exp2(ceil(clamp(t, y, y))))), x), smoothstep(sqrt(atan(log(step(gt(y, t), div(t, x))))), exp2(x), x));\n\n\n\tfragColor = vec4(v, v, v,1.0);\n}", "image_inputs": [{"id": "Xdf3Rn", "previewfilepath": "/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldsSR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 45], [46, 46, 75, 75, 91], [92, 92, 121, 121, 137], [138, 138, 167, 167, 183], [185, 185, 213, 213, 239], [240, 240, 268, 268, 294], [295, 295, 338, 338, 369], [371, 371, 428, 428, 33314]], "test": "ok"}
{"id": "ldsSRN", "name": "Candy Squish", "author": "Patapom", "description": "Direct live from Revision 2014 ! ^_^", "tags": ["revision", "live"], "likes": 6, "viewed": 261, "published": "Public", "date": "1397935974", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float smin( float a, float b, float k )\n{\n    a = pow( a, k ); b = pow( b, k );\n    return pow( (a*b)/(a+b), 1.0/k );\n}\nfloat smin2( float a, float b, float k )\n{\n\treturn log( max( 0.001, exp( k*a ) ) + exp( k*b ) ) / k;\n}\nfloat cos3( vec3 a )\n{\n\treturn cos( a.x ) * cos( a.y ) * cos( a.z );\n}\n\nvec3 repeat( vec3 p, float s )\n{\n\treturn mod( p+0.5*s, s ) - 0.5*s;\n}\n\nvec3 repeatXZ( vec3 p, float s )\n{\n\tfloat\th = 0.5*s;\n\treturn vec3( mod( p.x+h, s ) - h, p.y, mod( p.z+h, s ) - h );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel1, (uv+0.5)/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat fbm( vec3 p )\n{\n\tvec3\tf = vec3( 0.5, 2.0, 0.4 );\n\tvec3\tmulF = vec3( 6.0, 8.0, 6.0 );\n\tconst float\tmulA = 0.45;\n\tfloat\ta = 1.0;\n\tfloat\tv  = a * noise( f*p ); f *= mulF; a *= mulA;\n\t\t\tv += a * noise( f*p ); f *= mulF; a *= mulA;\n\t\t\tv += a * noise( f*p ); f *= mulF; a *= mulA;\n\t\t\tv += a * noise( f*p ); f *= mulF; a *= mulA;\n\treturn v * (1.0 / (1.0+0.5+0.25+0.125));\n}\n\nfloat randCell( vec2 cell, vec2 bisou )\n{\n\treturn fract( 10.0 + sin( 32151.16 * (cell.x+bisou.x) + 0.12191 )\n\t\t\t\t + sin( -2558.5189 * (cell.y + bisou.y) + 0.59168 ) );\n}\n\nfloat map( vec3 p )\n{\n\tconst float\tRepeatRate = 8.0;\n\tvec2\tcellXZ = floor( (p.xz - 0.5 * RepeatRate) / RepeatRate );\n\tfloat\tradius = 1.5 + 0.5 * sin( cellXZ.x + 0.564 * iTime )*sin( 1.4651 * cellXZ.y + 1.2169216* iTime );\n\n\tfloat\tcellRandom = randCell( cellXZ, vec2( 0, 0 ) );\n\tvec3\theight = vec3( 0.0,\n\t\t\t\t\t\t  -4.0\n\t\t\t\t\t\t  * abs( sin( 37861.32 * cellXZ.x + 2.863 * iTime )\n\t\t\t\t\t\t  *sin( 031651.0 * cellXZ.y + 1.894 * iTime ) )\n\t\t\t\t\t\t  , 0.0 );\n\tfloat\tvscale = mix( 0.125, 0.8, cellRandom );\n\tvec3\tscale = vec3( 1, vscale, 1 );\n\tfloat \tdsphere = length( repeatXZ( scale *( p + height), RepeatRate ) ) - radius;\n\tfloat \tdplane = p.y + 2.0;\n\n\treturn smin2( dsphere, dplane, -1.8 );//, cos(p.x)+cos(p.y)+cos(p.z));\n}\n\nvec3 normal( vec3 p )\n{\n\tconst vec2 e = vec2( 0.001, 0.0 );\n\tfloat c = map( p );\n\treturn normalize( vec3(\n\t\tmap( p + e.xyy ) - map( p - e.xyy ),\n\t\tmap( p + e.yxy ) - map( p - e.yxy ),\n\t\tmap( p + e.yyx ) - map( p - e.yyx )\n\t\t) );\n}\n\nfloat AO( vec3 p, vec3 n )\n{\n\tconst float step = 0.01;\n\tp += 0.1 * n;\n\tfloat AO = 1.0;\n\tfor ( int i=0; i < 16; i++ )\n\t{\n\t\tfloat\td = max( 0.0, map( p ) );\n\t\tp += step * n;\n\t\t\n\t\tAO *= 1.0 - exp( -20.0 * d * (2.0+float(i)) );\n\t}\n\treturn AO;\n}\n\nfloat\tShadow( vec3 p, vec3 l )\n{\n\tconst float step = 0.5;\n\tp += 0.5 * l;\n\tfloat S = 1.0;\n\tfor ( int i=0; i < 16; i++ )\n\t{\n\t\tfloat\td = max( 0.0, map( p ) );\n\t\tp += step * l;\n\t\t\n\t\tS *= 1.0 - exp( -20.0 * d * (3.0+float(i)) );\n\t}\n\treturn S;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2\tuv = fragCoord.xy / iResolution.xy;\n\tvec3\tp = vec3( 5.0 * sin( 1.0 * iTime )\n\t\t\t\t\t , 6.0 + 4.0 * sin( 0.5 * iTime )\n\t\t\t\t\t , 4.0 * iTime );\n\tvec3\ttarget = p + vec3(\n\t\tsin( 1.2 * iTime ),\n\t\tsin( 1.0 + 0.7891 * iTime ),\n\t\t5.0 + 2.0 * sin( 1.2 * iTime )\n\t\t);\n\t\n\tvec3\tat = normalize( target - p );\n\tvec3\tright = normalize( cross( at, vec3( 0, 1, 0 ) ) );\n\tvec3\tup = cross( right, at );\n\n\tfloat\tTan = 0.6;\n\tvec3\tv = normalize( vec3( iResolution.x / iResolution.y * Tan * (2.0 * uv.x - 1.0), Tan * (2.0 * uv.y - 1.0), 1.0 ) );\n\t\t\tv = v.x * right + v.y * up + v.z * at;\n\n\tfloat\tt = 0.0;\n\tfor ( int i=0; i < 64; i++ )\n\t{\n\t\tfloat\td = map( p );\n\t\tt += d;\n\t\tp += d * v;\n\t}\n\t\n\tif ( t <= 0.0 )\n\t\tt = 1e4;\n\t\n\t\n\tvec3\tcolor = vec3( 0.0 );\n\t\n\tvec3\tn = normal( p );\n\n\tvec3\tLight = normalize( vec3( 1 ) );\n\t\n\tfloat\tstrip = fract( 1.0 * p.y + p.z - 1.0 * p.x );\n\t\t\tstrip = step( strip, 0.4 ); \n\t\n\tvec3\tsurfColor = mix( vec3( 1 ), vec3( 1, 0.1, 0.1 ), strip );\n\t\n\tvec3\tdiff = Shadow( p, Light ) * clamp( 0.0, 1.0, 0.5 + 0.5 * dot( n, Light )) * vec3( 1 );\n\t\t\tdiff += AO( p, n ) * mix( vec3( 0.5 ), 0.2 * vec3( 0.2, 0.8, 1.0 ), (0.5 + 0.5 * n.y) );\n\t\n\tcolor = surfColor * diff;\n\t\n\tfloat fogExt = 0.025 * mix( 1.0, 1.5, 0.5 * (1.0 + noise( 0.625*vec3(1.5, 1.0, 1.5) * p + 1.0 * iTime * vec3( 0, 0, 2 ) )) );\n\tfloat fog = exp( -fogExt * t );\n\tcolor = mix( vec3( 1.0, 0.8, 0.4 ), color, fog );\n\t\n\tfragColor = vec4( color, 1.0 );\n}\n", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldsSRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 119], [120, 120, 162, 162, 222], [223, 223, 245, 245, 293], [295, 295, 327, 327, 364], [366, 366, 400, 400, 483], [485, 485, 511, 511, 721], [723, 723, 744, 744, 1095], [1097, 1097, 1138, 1138, 1266], [1268, 1268, 1289, 1289, 1981], [1983, 1983, 2006, 2006, 2213], [2215, 2215, 2243, 2243, 2454], [2456, 2456, 2488, 2488, 2695], [2697, 2697, 2754, 2754, 4165]], "test": "error"}
{"id": "ldXXz4", "name": "super-simple raytracer", "author": "2DArray", "description": "A really primitive raytracer", "tags": ["3d", "raytracing"], "likes": 5, "viewed": 406, "published": "Public", "date": "1397384318", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//xyz is position, w is radius\nconst vec4 theSphere = vec4(0.0,0.0,0.0,2.0);\n\n//variables for raytrace output\nvec3 hitPos;\nvec3 hitNormal;\nfloat hitT;\nfloat light;\nvec3 frustum;\n\n\n//ray vs. sphere collision test\n//(taken directly from Inigo Quilez's website)\nbool intSphere (in vec4 sphere,in vec3 rayOrigin,in vec3 rayDir) {\n\tvec3 diff = rayOrigin-sphere.xyz;\n\tfloat b = dot(rayDir,diff);\n\tfloat c = dot(diff,diff) - sphere.w*sphere.w;\n\tfloat t = b*b - c;\n\tif (t>0.0) {\n\t\tt = -b - sqrt(t);\n\t\tif (t>0.0) {\n\t\t\thitPos = rayOrigin + rayDir*t;\n\t\t\thitNormal = normalize(hitPos - sphere.xyz);\n\t\t\thitT=t;\n\t\t\treturn(true);\n\t\t}\n\t}\n\t\n\treturn(false);\n}\n\nbool intGround (in float height,in vec3 rayOrigin,in vec3 rayDir) {\n\tfloat diff = -height-rayOrigin.y;\n\tif (rayDir.y==0.0) {\n\t\treturn(false);\n\t}\n\tfloat t = diff / dot(rayDir,vec3(0.0,-1.0,0.0));\n\tif (t>0.0) {\n\t\thitPos=rayOrigin+rayDir*t;\n\t\thitNormal=vec3(0.0,1.0,0.0);\n\t\thitT=t;\n\t\treturn(true);\n\t}\n\treturn(false);\n}\n\n//Turbo simple lighting calculation\n//nDotL and distance falloff\nfloat pointLight(vec3 samplePos,vec4 light,vec3 normal) {\n\tvec3 l = light.xyz - samplePos;\n\tif (dot(l,l)>light.w*light.w) {\n\t\treturn(0.0);\n\t}\n\tfloat nDotL = dot(normal,normalize(l));\n\treturn(nDotL*(1.0-length(l)/light.w));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//where's the camera?\n\tvec3 camPos = vec3(sin(iTime*1.0),cos(iTime*.387),-8.0);\n\t\n\t//camera projection settings\n\t//points along the +X/+Y corner of the view frustum\n\tfrustum = vec3(1.0,iResolution.y/iResolution.x,1.0);\n\n\t\n\t//where's the pixel?\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\t//what's the view ray of the current pixel?\n\tvec3 t2=vec3(uv,1.0);\n\tt2=t2 * 2.0 - 1.0;\n\tvec3 viewDir = normalize(frustum * t2);\n\t\n\t//where's the light?\n\t//xyz is position, w is size\n\tvec4 theLight = vec4(5.0+cos(iTime*1.23),\n\t\t\t\t\t\t 6.0,\n\t\t\t\t\t\t sin(iTime*1.23),\n\t\t\t\t\t\t 25.0+cos(iTime*.037));\n\t\n\t//is the view ray hitting the sphere or ground?\n\tbool hit=false;\n\tvec3 finalPos;\n\tvec3 finalNormal;\n\tfloat finalT;\n\t//collide against sphere and ground plane\n\tif (intSphere(theSphere,camPos,viewDir)) {\n\t\thit=true;\n\t\t\n\t\tfinalT=hitT;\n\t\tfinalPos=hitPos;\n\t\tfinalNormal=hitNormal;\n\t}\n\tif (intGround(-2.5,camPos,viewDir)) {\n\t\t\n\t\tif (hit==false||hitT<finalT) {\n\t\t\thit=true;\n\t\t\tfinalT=hitT;\n\t\t\tfinalPos=hitPos;\n\t\t\tfinalNormal=hitNormal;\n\t\t}\n\t}\n\tif (hit) {\n\t\t//hitPos and hitNormal are set inside collision functions\n\t\tlight = pointLight(finalPos,theLight,finalNormal);\n\t\t\n\t\t//check lit pixels for shadows\n\t\tif (light>.05) {\n\t\t\tif (intSphere(theSphere,finalPos,normalize(theLight.xyz-finalPos))) {\n\t\t\t\tlight*=0.3;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//apply ambient light\n\t\tlight=max(0.05,light);\n\t\t\n\t\tvec3 finalColor=vec3(light,light,light);\n\t\t\n\t\t//post processing: slight fog\n\t\tfinalColor+=normalize(vec3(0.75,0.75,0.95)-finalColor)*min(finalT,20.0)/60.0;\n\t\t\n\t\t//all done: fire away!\n\t\tfragColor = vec4(finalColor,1.0);\n\t} else {\n\t\t//pixel not hitting anything\n\t\t\n\t\tfragColor = vec4(.5,.5,.7,1.0)*(1.0-.25*t2.y);\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldXXz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[180, 259, 325, 325, 641], [643, 643, 710, 710, 958], [960, 1025, 1082, 1082, 1249], [1251, 1251, 1308, 1331, 2981]], "test": "ok"}
{"id": "lsB3zW", "name": "fall stars", "author": "zugamifk", "description": "star", "tags": ["star"], "likes": 1, "viewed": 386, "published": "Public", "date": "1398135910", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float time = 0.;\nfloat pi = 3.14159;\nfloat cycle = 0.;\n\nfloat usin(float x) {return 0.5+0.5*sin(x);}\nfloat osin(float x) {return 0.75+0.25*sin(x);}\nfloat ucos(float x) {return 0.5+0.5*cos(x);}\nfloat ocos(float x) {return 0.75+0.25*cos(x);}\n\nconst vec4 nullcol = vec4(0.);\nconst vec3 nulldir = vec3(0.);\n\nstruct shapevals {vec2 pos; float ang; float scale; float line;};\nstruct rayblob {vec3 pos; float ang; float scale; vec3 col;};\n\t\nvec3 sphere(vec3 p, vec3 r, rayblob s) {\n\tvec3 inc = p+r;\n\tif (length(inc-s.pos) < s.scale) {\n\t\tfloat b = 2.*dot(r, p-s.pos);\n\t\tfloat c = dot(p-s.pos, p-s.pos) - s.scale*s.scale;\n\t\tfloat d = b*b-4.*c;\n\t\tif (d < 0.) return nulldir;\n\t\tfloat t1 = (-b + sqrt(d))/2.;\n\t\tfloat t2 = (-b - sqrt(d))/2.;\n\t\tfloat t = min(t1,t2);\n\t\treturn inc-t*r;\n\t} \n\treturn nulldir;\n}\n\nfloat surf(vec2 p) {\n\tfloat z = usin(p.x*7.+2.*time) + ucos(p.y*4.+osin(time*4.)*2.);\t\n\n\treturn z*.3;\n}\n\t\nconst vec3 eye = vec3(0.,0.,4.);\nconst vec3 at = vec3(0.,0.,0.);\nconst vec3 up = vec3(0.,1.,0.);\nconst float frustrum = 2.0;\nvec4 raysurf(vec2 p, rayblob s) {\n\tvec3 ray = normalize(at-eye);\n\tvec3 right = cross(up, ray);\n\n\tvec3 pt = normalize(ray*frustrum + p.x*right + p.y*up);\n\tray = eye;\n\t\n\tvec3 collide;\n\tvec3 col = vec3(0.);\n\t\n\tfloat dt = .2;\n\tfloat z = eye.z;\n\tfor (int i = 0; i < 32; i++) {\n\t\tcollide = sphere(ray, pt*dt, s);\n\t\tif (collide != nulldir) {\n\t\t\tvec3 n = normalize(collide - s.pos);\n\t\t\tpt = -n;\n\t\t\tz = dot(ray, n);\n\t\t\tcol += s.col;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tz = surf(ray.xy);\n\t\tif (z > ray.z) break;\n\t\tray += pt*dt;\n\t}\n\t\n\tfloat stripe = ceil(sin(z*(30.*osin(time*4.))));\n\tvec3 scol = vec3(stripe*.8, stripe*.5, 0.);\n\t\n\tcol += scol*(z+.3);\n\treturn vec4(col,1.);\t\n}\n\n\nfloat pattern(vec3 ray) {\n\tfloat res = 0.;\n\tfloat r = length(ray.xy);\n\t\n\treturn usin(r*cycle*2.-time*10.)+ucos(12.*atan(ray.y/ray.x)+2.*time+r*cycle*10.);\n}\n\nvec4 circle(vec2 p, shapevals s, float j) { \n\tvec2 pos = s.pos;\n\t\n\tvec2 os = p-pos;\n\tfloat a = atan(os.y,os.x)+s.ang;\n\tfloat d = length(os)-usin(a*j)*s.scale;\n\t\n\tif (d<s.scale) {\n\t\treturn vec4(usin(pos.x), usin(pos.y),pattern(os.xyx),1.0);\n\t} else if (d-s.line < s.scale) {\n\t\treturn vec4(nullcol.xyz,1.);\n\t}return nullcol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = 2.*uv-1.;\n\tuv.x *= iResolution.x/iResolution.y;\n\t\n    time = iTime;\n    cycle = 2.*pi;\n    \n\tvec4 col;\n\t\n\tshapevals f1 = shapevals(vec2(sin(time),cos(time*4.)), time*4.+sin(time)*2., 0.2,0.05);\n\tshapevals f2 = shapevals(vec2(cos(time*4.+pi/2.),sin(time)), time*2.-sin(time*2.)*3., 0.25,.05);\n\tshapevals rain;\n\t\n\trayblob s1 = rayblob(vec3(sin(time), cos(time*2.), .5), 0., 1., vec3(0.,.4,0.));\n\t\n\tconst int num = 10;\n\tfor (int i = 0; i < num; i++) {\n\t\tfloat j = float(i);\n\t\tfloat fall = usin(sin(j));\n\t\tfall = fall*-time*2.;\n\t\train = shapevals(vec2(mod(j, pi)-pi/2.,mod(j+fall, pi)-pi/2.), time*(0.5+0.5*usin(j))+sin(time+j)*2., 0.1+0.02*usin(cycle*time*4.+j), .05);\t\n\t\tcol = circle(uv, rain, 5.);\n\t\tif (col != nullcol) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tif (col == nullcol) {\n\t\tcol = circle(uv, f1, 2.);\n\t}\t\n\tif (col == nullcol) {\n\t\tcol = circle(uv, f2, 3.);\n\t}\n\tif (col == nullcol) {\n\t\tcol = raysurf(uv, s1);\n\t}\n\t\n\tfragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsB3zW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[56, 56, 77, 77, 100], [101, 101, 122, 122, 147], [148, 148, 169, 169, 192], [193, 193, 214, 214, 239], [434, 434, 474, 474, 793], [795, 795, 815, 815, 898], [1026, 1026, 1059, 1059, 1674], [1677, 1677, 1702, 1702, 1833], [1835, 1835, 1878, 1878, 2159], [2161, 2161, 2218, 2218, 3188]], "test": "ok"}
{"id": "lsfXz4", "name": "Rolling ball", "author": "Dave_Hoskins", "description": "I wanted to see if I could trace the grass back from a ball in my 'Rolling Hills' grass shader. Mouse to move through time.\nThe grass goes back into place after being flattened by ball.", "tags": ["grass", "rollingball"], "likes": 97, "viewed": 7302, "published": "Public API", "date": "1397417147", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Rolling ball. By David Hoskins, April 2014.\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://www.shadertoy.com/view/lsfXz4\n\n// Uses https://www.shadertoy.com/view/Xsf3zX as base.\n\n\nfloat PI  = 4.0*atan(1.0);\nvec3 sunLight  = normalize( vec3(  0.35, 0.2,  0.3 ) );\nvec3 cameraPos;\nvec3 camTar;\nvec3 sunColour = vec3(1.0, .6, .4);\nconst mat2 rotate2D = mat2(1.932, 1.623, -1.623, 1.952);\nfloat gTime = 0.0;\nvec2 ballRoll;\nfloat bounce;\n//#define MOD2 vec2(3.07965, 7.4235)\n#define MOD2 vec2(.16632,.17369)\n#define f(p) length(fract(p/70.) - .5)\n\n//--------------------------------------------------------------------------\n// Noise functions...\nfloat Hash( float p )\n{\n\tvec2 p2 = fract(vec2(p) / MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);\n}\n\n//--------------------------------------------------------------------------\nfloat Hash(vec2 p)\n{\n\tp  = fract(p / MOD2);\n    p += dot(p.xy, p.yx+19.19);\n    return fract(p.x * p.y);\n}\n\n//--------------------------------------------------------------------------\nfloat Noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    float res = mix(mix( Hash(p), Hash(p+ vec2(1.0, 0.0)),f.x),\n                    mix( Hash(p+ vec2(.0, 1.0)), Hash(p+ vec2(1.0, 1.0)),f.x),f.y);\n    return res;\n}\n\n//--------------------------------------------------------------------------\nvec2 Rotate2(vec2 p, float a)\n{\n\tfloat si = sin(a);\n\tfloat co = cos(a);\n\treturn mat2(co, si, -si, co) * p;\n}\n\n\n//  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//--------------------------------------------------------------------------\nvec2 Voronoi( in vec2 x )\n{\n\tvec2 p = floor( x );\n\tvec2 f = fract( x );\n\tfloat res=100.0;\n    vec2 id;\n\tfor( int j=-1; j<=1; j++ )\n\tfor( int i=-1; i<=1; i++ )\n\t{\n\t\tvec2 b = vec2( float(i), float(j) );\n\t\tvec2 r = b - f  + hash22( p + b );\n\t\tfloat d = dot(r,r);\n\t\tif( d < res )\n\t\t{\n\t\t\tres = d;\n\t\t\tid.x  = Hash(p+b);\n\t\t}\t\t\t\n    }\n\treturn vec2(max(.4-sqrt(res), 0.0),id.x);\n}\n\n\n//--------------------------------------------------------------------------\nvec3 BallTexture( in vec3 n)\n{\n\tvec3 col = vec3(.5, 0.0, 0.0);\n\tcol= mix(col, vec3(.0, .6, 0.9), smoothstep(-0.05, -.04, n.y) * smoothstep(0.05, .04, n.y));\n\tfloat at = cos(atan(n.x, n.z) * 5.0)*(n.y*n.y);\n\tcol =mix(col, vec3(.7, .7, 0.0), smoothstep(0.3, .32, at));\n\treturn col * .8;\n}\n\n//--------------------------------------------------------------------------\nvec2 Terrain( in vec2 p)\n{\n\tfloat type = 0.0;\n\tvec2 pos = p*0.003;\n\tfloat w = 50.0;\n\tfloat f = .0;\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tf += Noise(pos) * w;\n\t\tw = w * 0.62;\n\t\tpos *= 2.6;\n\t}\n\n\treturn vec2(f, type);\n}\n\n//--------------------------------------------------------------------------\nvec2 Map(in vec3 p)\n{\n\tvec2 h = Terrain(p.xz);\n    return vec2(p.y - h.x, h.y);\n}\n\n//--------------------------------------------------------------------------\nfloat FractalNoise(in vec2 xy)\n{\n\tfloat w = .7;\n\tfloat f = 0.0;\n\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tf += Noise(xy) * w;\n\t\tw = w*0.6;\n\t\txy = 2.0 * xy;\n\t}\n\treturn f;\n}\n\n//--------------------------------------------------------------------------\n// Grab all sky information for a given ray from camera\nvec3 GetSky(in vec3 rd, bool doClouds)\n{\n\tfloat sunAmount = max( dot( rd, sunLight), 0.0 );\n\tfloat v = pow(1.0-max(rd.y,0.0),6.);\n\tvec3  sky = mix(vec3(.1, .2, .3), vec3(.32, .32, .32), v);\n\tsky = sky + sunColour * sunAmount * sunAmount * .25;\n\tsky = sky + sunColour * min(pow(sunAmount, 800.0)*1.5, .4);\n\t\n\tif (doClouds)\n\t{\n\t\tvec2 cl = rd.xz * (1.0/rd.y);\n\t\tv = FractalNoise(cl) * .3;\n\t\tsky = mix(sky, sunColour, v*v);\n\t}\n\n\treturn clamp(sky, 0.0, 1.0);\n}\n\n//--------------------------------------------------------------------------\n// Merge grass into the sky background for correct fog colouring...\nvec3 ApplyFog( in vec3  rgb, in float dis, in vec3 dir)\n{\n\tfloat fogAmount = clamp(dis*dis* 0.0000011, 0.0, 1.0);\n\treturn mix( rgb, GetSky(dir, false), fogAmount );\n}\n\n//--------------------------------------------------------------------------\nvec3 DE(vec3 p)\n{\n\tfloat base = Terrain(p.xz).x - 1.9;\n\tfloat height = Noise(p.xz*2.0)*.75 + Noise(p.xz)*.35 + Noise(p.xz*.5)*.2;\n\t//p.y += height;\n\n\tfloat y = p.y - base-height;\n\ty = y*y;\n\t\n\t// Move grass out of way of target (ball)...\n\tvec2 move = (p.xz-camTar.xz);\n\tfloat l = length(move);\n\tmove = (move * y) * smoothstep(15.0, -6.0, l)/ (bounce+1.0);\n\tp.xz -= move;\n\n\tvec2 ret = Voronoi((p.xz*2.5+sin(y*4.0+p.zx*3.23)*0.12+vec2(sin(iTime*2.3+0.5*p.z),sin(iTime*3.6+.5*p.x))*y*.5));\n\tfloat f = ret.x * .6 + y * .58;\n\treturn vec3( y - f*1.4, clamp(f * 1.5, 0.0, 1.0), ret.y);\n}\n\n//--------------------------------------------------------------------------\n// eiffie's code for calculating the aperture size for a given distance...\nfloat CircleOfConfusion(float t)\n{\n\treturn max(t * .04, (2.0 / iResolution.y) * (1.0+t));\n}\n\n//--------------------------------------------------------------------------\nfloat Linstep(float a, float b, float t)\n{\n\treturn clamp((t-a)/(b-a),0.,1.);\n}\n\n//--------------------------------------------------------------------------\nfloat Sphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\n//--------------------------------------------------------------------------\n// Calculate sun light...\nvoid DoLighting(inout vec3 mat, in vec3 normal, in float dis)\n{\n\tfloat h = dot(sunLight,normal);\n\tmat = mat * sunColour*(max(h, 0.0)+max((normal.y+.3) * .2, 0.0)+.1);\n}\n\n//--------------------------------------------------------------------------\nvec3 GrassOut(in vec3 rO, in vec3 rD, in vec3 mat, in vec3 normal, in float dist)\n{\n\tfloat d = -2.0;\n\t\n\t// Only calculate cCoC once is enough here...\n\tfloat rCoC = CircleOfConfusion(dist*.3);\n\tfloat alpha = 0.0;\n\t\n\tvec4 col = vec4(mat, 0.0);\n\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tif (col.w > .99 || d > dist) break;\n\t\tvec3 p = rO + rD * d;\n\t\t\n\t\tvec3 ret = DE(p);\n\t\tret.x += .5 * rCoC;\n\n\t\tif (ret.x < rCoC)\n\t\t{\n\t\t\talpha = (1.0 - col.w) * Linstep(-rCoC, rCoC, -ret.x);//calculate the mix like cloud density\n\t\t\t\n\t\t\t// Mix material with white tips for grass...\n\t\t\tvec3 gra = mix(vec3(.0, .2, 0.0), vec3(.1, .4, min(pow(ret.z, 4.0)*35.0, .35)),\n\t\t\t\t\t\t   pow(ret.y, 9.0)*.7) * ret.y * .7;\n\t\t\tcol += vec4(gra * alpha, alpha);\n\t\t}\n\t\td += .02;\n\t}\n\t\n\tDoLighting(col.xyz, normal, dist);\n\t\n\tcol.xyz = mix(mat, col.xyz, col.w);\n\n\treturn col.xyz;\n}\n\n\n//--------------------------------------------------------------------------\nvec3 GrassBlades(in vec3 rO, in vec3 rD, in vec3 mat, in float dist)\n{\n\tfloat d = 0.0;\n\tfloat f;\n\t// Only calculate cCoC once is enough here...\n\tfloat rCoC = CircleOfConfusion(dist*.3);\n\tfloat alpha = 0.0;\n\t\n\tvec4 col = vec4(mat*0.15, 0.0);\n\n\tfor (int i = 0; i < 15; i++)\n\t{\n\t\tif (col.w > .99) break;\n\t\tvec3 p = rO + rD * d;\n\t\t\n\t\tvec3 ret = DE(p);\n\t\tret.x += .5 * rCoC;\n\n\t\tif (ret.x < rCoC)\n\t\t{\n\t\t\talpha = (1.0 - col.y) * Linstep(-rCoC, rCoC, -ret.x) * 2.0;//calculate the mix like cloud density\n\t\t\tf = clamp(ret.y, 0.0, 1.0);\n\t\t\t// Mix material with white tips for grass...\n\t\t\tvec3 gra = mix(mat, vec3(.2, .3, min(pow(ret.z, 14.0)*3.0, .3)), pow(ret.y,100.0)*.6 ) * ret.y;\n\t\t\tcol += vec4(gra * alpha, alpha);\n\t\t}\n\t\td += max(ret.x * .7, .02);\n\t}\n\tif(col.w < .2)col.xyz = vec3(0.1, .15, 0.05);\n\treturn col.xyz;\n}\n\n//--------------------------------------------------------------------------\nvec3 TerrainColour(vec3 pos, vec3 dir,  vec3 normal, float dis, float type)\n{\n\tvec3 mat;\n\tif (type == 0.0)\n\t{\n\t\t// Random colour...\n\t\tmat = mix(vec3(.0,.2,.0), vec3(.1,.3,.0), Noise(pos.xz*.025));\n\t\t// Random shadows...\n\t\tfloat t = FractalNoise(pos.xz * .1)+.5;\n\t\t// Do grass blade tracing...\n\t\tmat = GrassBlades(pos, dir, mat, dis) * t;\n\t\tDoLighting(mat, normal, dis);\n\t\tfloat f = Sphere( pos, sunLight, vec4(camTar, 10.0));\n\t\tif (f > 0.0)\n\t\t{\n\t\t\tmat *= clamp(f*.05, 0.4, 1.0);\n\t\t}\n\t}else\n\t{\n\t\t// Ball...\n\t\tvec3 nor = normalize(pos-camTar);\n\t\tvec3 spin = nor;\n\t\t\n\t\tspin.xz = Rotate2(spin.xz, ballRoll.y);\n\t\tspin.zy = Rotate2(spin.zy, ballRoll.x);\n\t\tspin.xy = Rotate2(spin.xy, .4);\n\t\t\n\t\tmat = BallTexture(spin);\n\t\tDoLighting(mat, nor, dis);\n\t\tvec3 ref = reflect(dir, nor);\n\t\tmat += sunColour * pow(max(dot(ref, sunLight), 0.0), 6.0) * .3;\n\t\t\n\t\tif (pos.y < Terrain(pos.xz).x+1.5)\n\t\t{\n\t\t\tmat = GrassOut(pos, dir, mat, normal, dis);\n\t\t}\n\t}\n\tmat = ApplyFog(mat, dis, dir);\n\treturn mat;\n}\n\n//--------------------------------------------------------------------------\n// Home in on the surface by dividing by two and split...\nfloat BinarySubdivision(in vec3 rO, in vec3 rD, float t, float oldT)\n{\n\tfloat halfwayT = 0.0;\n\tfor (int n = 0; n < 5; n++)\n\t{\n\t\thalfwayT = (oldT + t ) * .5;\n\t\tif (Map(rO + halfwayT*rD).x < .05)\n\t\t{\n\t\t\tt = halfwayT;\n\t\t}else\n\t\t{\n\t\t\toldT = halfwayT;\n\t\t}\n\t}\n\treturn t;\n}\n\n\n//--------------------------------------------------------------------------\nvec3 CameraPath( float t )\n{\n\t//t = time + t;\n    vec2 p = vec2(200.0 * sin(3.54*t), 200.0 * cos(3.54*t) );\n\treturn vec3(p.x+5.0,  0.0, -94.0+p.y);\n} \n\n//--------------------------------------------------------------------------\nbool Scene(in vec3 rO, in vec3 rD, inout float resT, inout float type )\n{\n    float t = 5.;\n\tfloat oldT = 0.0;\n\tfloat delta = 0.;\n\tvec2 h = vec2(1.0, 1.0);\n\tbool hit = false;\n\tfor( int j=0; j < 70; j++ )\n\t{\n\t    vec3 p = rO + t*rD;\n        if (p.y > 90.0) break;\n\n\t\th = Map(p); // ...Get this position's height mapping.\n\n\t\t// Are we inside, and close enough to fudge a hit?...\n\t\tif( h.x < 0.05)\n\t\t{\n\t\t\thit = true;\n            break;\n\t\t}\n\t        \n\t\tdelta = h.x + (t*0.03);\n\t\toldT = t;\n\t\tt += delta;\n\t}\n    type = h.y;\n    resT = BinarySubdivision(rO, rD, t, oldT);\n\tfloat f = Sphere( rO, rD, vec4(camTar, 10.0));\n\t\n\tif (f > 0.0 && f < resT+4.5)\n\t{\n\t\thit = true;\n\t\ttype = 1.0;\n\t\tresT = f;\n\t\t\n\t\t\n\t}\n\treturn hit;\n}\n\n//--------------------------------------------------------------------------\nvec3 PostEffects(vec3 rgb, vec2 xy)\n{\n\t// Gamma first...\n\trgb = pow(rgb, vec3(0.45));\n\t\n\t// Then...\n\t#define CONTRAST 1.1\n\t#define SATURATION 1.3\n\t#define BRIGHTNESS 1.3\n\trgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);\n\t// Vignette...\n\trgb *= .4+0.6*pow(40.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.2 );\t\n\treturn rgb;\n}\n\n//--------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat m = (iMouse.x/iResolution.x)*300.0;\n\tfloat gTime = (iTime*5.0+m+468.0)*.006;\n    vec2 xy = fragCoord.xy / iResolution.xy;\n\tvec2 uv = (-1.0 + 2.0 * xy) * vec2(iResolution.x/iResolution.y,1.0);\n\t\n\tif (xy.y < .13 || xy.y >= .87)\n\t{\n\t\t// Top and bottom cine-crop - what a waste! :)\n\t\tfragColor=vec4(vec4(0.0));\n\t\treturn;\n\t}\n\n\tcameraPos = CameraPath(gTime + 0.0);\n    cameraPos.x-= 20.0;\n\tcamTar\t  = CameraPath(gTime + .06);\n\t\n\tvec2 diff = (camTar.xz - CameraPath(gTime + .13).xz);\n\tballRoll.x = -gTime * 72.0;\n\tballRoll.y = atan(diff.x, diff.y);\n\t\n\tcameraPos.y = Terrain(cameraPos.xz).x + 7.0;\n\tcamTar.y    = Terrain(camTar.xz).x+7.0;\n\tbounce = abs(sin(gTime*130.0))* 40.0 * max(abs(sin(gTime*15.0))-.85, 0.0);\n\tcamTar.y += bounce;\n\t\n\tfloat roll = .3*sin(gTime*3.0+.5);\n\tvec3 cw = normalize(vec3(camTar.x, cameraPos.y, camTar.z)-cameraPos);\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = cross(cw,cp);\n\tvec3 cv = cross(cu,cw);\n\tvec3 dir = normalize(uv.x*cu + uv.y*cv + 1.3*cw);\n\tmat3 camMat = mat3(cu, cv, cw);\n\n\tvec3 col;\n\tfloat distance = 1e20;\n\tfloat type = 0.0;\n\tif( !Scene(cameraPos, dir, distance, type) )\n\t{\n\t\t// Missed scene, now just get the sky...\n\t\tcol = GetSky(dir, true);\n\t}\n\telse\n\t{\n\t\t// Get world coordinate of landscape...\n\t\tvec3 pos = cameraPos + distance * dir;\n\t\t// Get normal from sampling the high definition height map\n\t\tvec2 p = vec2(0.1, 0.0);\n\t\tvec3 nor  \t= vec3(0.0,\t\tTerrain(pos.xz).x, 0.0);\n\t\tvec3 v2\t\t= nor-vec3(p.x,\tTerrain(pos.xz+p).x, 0.0);\n\t\tvec3 v3\t\t= nor-vec3(0.0,\tTerrain(pos.xz-p.yx).x, -p.x);\n\t\tnor = cross(v2, v3);\n\t\tnor = normalize(nor);\n\n\t\t// Get the colour using all available data...\n\t\tcol = TerrainColour(pos, dir, nor, distance, type);\n\t}\n\t\n\t// bri is the brightness of sun at the centre of the camera direction.\n\tfloat bri = dot(cw, sunLight)*.75;\n\tif (bri > 0.0)\n\t{\n\t\tvec2 sunPos = vec2( dot( sunLight, cu ), dot( sunLight, cv ) );\n\t\tvec2 uvT = uv-sunPos;\n\t\tuvT = uvT*(length(uvT));\n\t\tbri = pow(bri, 6.0)*.8;\n\n\t\t// glare = the red shifted blob...\n\t\tfloat glare1 = max(dot(normalize(vec3(dir.x, dir.y+.3, dir.z)),sunLight),0.0)*1.4;\n\t\t// glare2 is the yellow ring...\n\t\tfloat glare2 = max(1.0-length(uvT+sunPos*.5)*4.0, 0.0);\n\t\tuvT = mix (uvT, uv, -2.3);\n\t\t// glare3 is a purple splodge...\n\t\tfloat glare3 = max(1.0-length(uvT+sunPos*5.0)*1.2, 0.0);\n\n\t\tcol += bri * vec3(1.0, .0, .0)  * pow(glare1, 12.5)*.05;\n\t\tcol += bri * vec3(1.0, 1.0, 0.2) * pow(glare2, 2.0)*2.5;\n\t\tcol += bri * sunColour * pow(glare3, 2.0)*3.0;\n\t}\n\tcol = PostEffects(col, xy);\t\n\t\n\tfragColor=vec4(col,1.0);\n}\n\n//--------------------------------------------------------------------------", "image_inputs": [{"id": "4dlGRr", "previewfilepath": "https://soundcloud.com/wadsman/in-fields-of-grass", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/wadsman/in-fields-of-grass", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsfXz4.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[596, 695, 718, 718, 817], [819, 896, 916, 916, 1002], [1004, 1081, 1107, 1107, 1349], [1351, 1428, 1459, 1459, 1536], [1539, 1558, 1579, 1579, 1713], [1715, 1792, 1819, 1819, 2163], [2166, 2243, 2273, 2273, 2529], [2531, 2608, 2634, 2634, 2820], [2822, 2899, 2920, 2920, 2980], [2982, 3059, 3091, 3091, 3223], [3225, 3358, 3398, 3398, 3813], [3815, 3960, 4017, 4017, 4126], [4128, 4205, 4222, 4222, 4784], [4786, 4938, 4972, 4972, 5029], [5031, 5108, 5150, 5150, 5186], [5188, 5265, 5318, 5318, 5481], [5483, 5586, 5649, 5649, 5754], [5756, 5833, 5916, 5916, 6665], [6668, 6745, 6815, 6815, 7556], [7558, 7635, 7712, 7712, 8618], [8620, 8755, 8825, 8825, 9021], [9024, 9101, 9129, 9146, 9250], [9253, 9330, 9403, 9403, 10041], [10043, 10120, 10157, 10176, 10504], [10506, 10583, 10640, 10640, 13175]], "test": "ok"}
{"id": "lslSR7", "name": "The Pulse", "author": "gleurop", "description": "A recreation of this gif: http://i.imgur.com/a6Sknp8.jpg. Cross your eyes until adjacent circles line up for a neat effect.", "tags": ["procedural", "2d", "sacedgeometry"], "likes": 67, "viewed": 2293, "published": "Public", "date": "1398643091", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hsv(float h,float s,float v) {\n\treturn mix(vec3(1.),clamp((abs(fract(h+vec3(3.,2.,1.)/3.)*6.-3.)-1.),0.,1.),s)*v;\n}\nfloat circle(vec2 p, float r) {\n\treturn smoothstep(0.1, 0.0, abs(length(p)-r)); // try changing the 0.1 to 0.3\n}\nfloat r3 = sqrt(3.0);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n\tuv *= 10.0;\n\tfloat r = smoothstep(-0.7, 0.7, sin(iTime*1.57-length(uv)*0.1))+1.0;\n\tvec2 rep = vec2(4.0,r3*4.0);\n\tvec2 p1 = mod(uv, rep)-rep*0.5;\n\tvec2 p2 = mod(uv+vec2(2.0,0.0), rep)-rep*0.5;\n\tvec2 p3 = mod(uv+vec2(1.0,r3), rep)-rep*0.5;\n\tvec2 p4 = mod(uv+vec2(3.0,r3), rep)-rep*0.5;\n\tvec2 p5 = mod(uv+vec2(0.0,r3*2.0), rep)-rep*0.5;\n\tvec2 p6 = mod(uv+vec2(2.0,r3*2.0), rep)-rep*0.5;\n\tvec2 p7 = mod(uv+vec2(1.0,r3*3.0), rep)-rep*0.5;\n\tvec2 p8 = mod(uv+vec2(3.0,r3*3.0), rep)-rep*0.5;\n\t\n\tfloat c = 0.0;\n\tc += circle(p1, r);\n\tc += circle(p2, r);\n\tc += circle(p3, r);\n\tc += circle(p4, r);\n\tc += circle(p5, r);\n\tc += circle(p6, r);\n\tc += circle(p7, r);\n\tc += circle(p8 , r);\n\tfragColor = vec4(hsv(r+0.7, 1.0, c), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lslSR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 120], [121, 121, 152, 152, 233], [256, 256, 313, 313, 1122]], "test": "ok"}
{"id": "lslSRN", "name": "floop", "author": "triss", "description": "randomly generated function", "tags": ["generated"], "likes": 0, "viewed": 114, "published": "Public", "date": "1397925183", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n// some extra operators for our GA\n//\n// - all defined here instead of a header to allow dumping of code straight in\n// to Processing, http://www.shadertoy.com, http://glsl.heroku.com etc.\n////////////////////////////////////////////////////////////////////////////////\n\n// basic operands for addition, subtraction,\n// multiplication and division\nfloat add(float a, float b) { return a + b; }\nfloat sub(float a, float b) { return a - b; }\nfloat div(float a, float b) { return a / b; }\nfloat mul(float a, float b) { return a * b; }\n\n// the following are operators that perform boolean operations\n// > 0.5 is true < 0.5 is false\n\n// converts a boolean to a float - 1. for True 0. for false\nfloat btof(bool b) { return b ? 1. : 0.; }\n\n// converts a float to a boolean\nbool ftob(float f) { return fract(abs(f)) > 0.5; }\n\n// not for floats\nfloat fnot(float f) { return 1.0 - f; }\n\n// less than and greater than\nfloat lt(float a, float b) { return btof(a < b); }\nfloat gt(float a, float b) { return btof(a > b); }\n\n// if, then, else\nfloat iff(float f, float then, float els) { return f > 0.5 ? then : els; }\n\n// and, or, xor\nfloat and(float a, float b) { return btof(ftob(a) && ftob(b)); }\nfloat or (float a, float b) { return btof(ftob(a) || ftob(b)); }\nfloat xor(float a, float b) { return btof(ftob(a) ^^ ftob(b)); }\n\n// ors, ands, xors, less than and greater than's  that return one of\n// there incoming values instead of just on or off\nfloat anda(float a, float b) { return ftob(a) && ftob(b) ? a : 0.; }\nfloat andb(float a, float b) { return ftob(a) && ftob(b) ? b : 0.; }\nfloat ora (float a, float b) { return ftob(a) || ftob(b) ? a : 0.; }\nfloat orb (float a, float b) { return ftob(a) || ftob(b) ? b : 0.; }\nfloat xora(float a, float b) { return ftob(a) ^^ ftob(b) ? a : 0.; }\nfloat xorb(float a, float b) { return ftob(a) ^^ ftob(b) ? b : 0.; }\nfloat lta (float a, float b) { return a < b ? a : 0.; }\nfloat ltb (float a, float b) { return a < b ? b : 0.; }\nfloat gta (float a, float b) { return a > b ? a : 0.; }\nfloat gtb (float a, float b) { return a > b ? b : 0.; }\n\n// unipolar versions of bipolar functions\nfloat unisin(float f) { return sin(f) * 0.5 + 0.5; }\nfloat unicos(float f) { return cos(f) * 0.5 + 0.5; }\nfloat unitan(float f) { return tan(f) * 0.5 + 0.5; }\nfloat uniasin(float f) { return asin(f) * 0.5 + 0.5; }\nfloat uniacos(float f) { return acos(f) * 0.5 + 0.5; }\nfloat uniatan(float f) { return atan(f) * 0.5 + 0.5; }\n\n////////////////////////////////////////////////////////////////////////////////\n// the actual shader code starts here\n////////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalize x and y values\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // get how long shader has been running\n    float t = iTime * 3.;\n\n    // move and scale viewport\n    float x = uv.x * 50. - 25.5;\n    float y = uv.y * 5. - 2.5;\n\n\t\n    ////////////////////////////////////////////////////////////////////////////\n    // function generated by GA\n    ////////////////////////////////////////////////////////////////////////////\n \tfloat v= smoothstep(xorb(clamp(abs(x), smoothstep(xora(t, y), t, mul(t, t)), gt(sub(t, y), clamp(t, t, t))), xor(gta(y, log(x)), clamp(t, sqrt(x), mod(y, y)))), iff(pow(mix(sqrt(t), gtb(x, x), unisin(t)), y), x, log2(min(clamp(x, t, t), uniacos(x)))), mix(y, unicos(x), iff(gtb(lt(x, y), clamp(x, t, y)), mul(lta(x, y), iff(t, x, t)), mix(gtb(y, y), orb(x, y), mix(t, x, y)))));\n    // output our function\n    fragColor = vec4(v, v, v, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lslSRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[352, 428, 457, 457, 473], [474, 474, 503, 503, 519], [520, 520, 549, 549, 565], [566, 566, 595, 595, 611], [709, 769, 789, 789, 811], [813, 846, 866, 866, 896], [898, 916, 937, 937, 955], [957, 987, 1015, 1015, 1037], [1038, 1038, 1066, 1066, 1088], [1090, 1108, 1151, 1151, 1182], [1184, 1200, 1229, 1229, 1264], [1265, 1265, 1294, 1294, 1329], [1396, 1516, 1546, 1546, 1584], [1585, 1585, 1615, 1615, 1653], [1654, 1654, 1684, 1684, 1722], [1723, 1723, 1753, 1753, 1791], [1930, 1930, 1960, 1960, 1985], [1986, 1986, 2016, 2016, 2041], [2042, 2042, 2072, 2072, 2097], [2098, 2098, 2128, 2128, 2153], [2155, 2197, 2220, 2220, 2249], [2250, 2250, 2273, 2273, 2302], [2303, 2303, 2326, 2326, 2355], [2356, 2356, 2380, 2380, 2410], [2411, 2411, 2435, 2435, 2465], [2466, 2466, 2490, 2490, 2520], [2723, 2723, 2780, 2812, 3667]], "test": "ok"}
{"id": "lslXR8", "name": "branchless distance field", "author": "Panoptics", "description": "Building on earlier work. Eliminated branches in inner loop.\nPoint is marched until it hits a surface. Once a surface is hit loop continues, but does nothing more till expired.", "tags": ["distancefield", "voxel", "cubes"], "likes": 4, "viewed": 412, "published": "Public", "date": "1396842816", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#define NO_BAIL\nconst vec3 grid = vec3(4.0);\nconst vec3 griddiv = vec3(2.0);\nconst vec3 aabb  = vec3(0.75, 0.25, 0.25);\nconst vec3 aabb2 = vec3(0.25, 0.85, 0.25);\nconst vec3 aabb3 = vec3(0.25, 0.25, 0.85);\n\nfloat pyramid( vec3 p, float h) {\n\tvec3 q=abs(p);\n\treturn max(-p.y, (q.x+q.y+q.z-h)/3.0 );\n}\n\nfloat box(vec3 p) {\n\treturn min(  pyramid( vec3(p.x,-p.y,p.z)-vec3(0.0,0.0,0.0),1.0),\n\t\tmin( pyramid(p-vec3(0.0, 0.0, 0.0), 0.90),\n\t\tmin(min(length(max(abs(p)-aabb, 0.0)),\n\t\t\tlength(max(abs(p)-aabb2, 0.0))),\n\t\t\tlength(max(abs(p)-aabb3, 0.0)))));\n}\n\nvec3 rot(vec3 p, float f) {\n\tfloat s = sin(f);\n\tfloat c = cos(f);\n\tp.xy *= mat2(c, -s, s, c);\n\tp.yz *= mat2(c, -s, s, c);\n\treturn p;\n}\n\nvec3 trans(vec3 p, out float rotout) {\n\tvec3 rep = floor(p/grid);\n\tp = mod(p,grid)-griddiv;\n\trotout = iTime*0.28 + (rep.x+rep.z+rep.y)*0.3;\n\tp = rot(p, rotout);\n\treturn p;\t\n}\nvec3 normal(vec3 p) {\n\tvec3 e = vec3(0.02,0.0,0.0);\n\treturn normalize(vec3(\n\t\tbox(p+e.xyy)-box(p-e.xyy),\n\t\tbox(p+e.yxy)-box(p-e.yxy),\n\t\tbox(p+e.yyx)-box(p-e.yyx)));\n}\n\nfloat scene(vec3 p) {\n\tfloat dummy;\n\treturn box(trans(p,dummy));\n}\n\nvec3 normal(vec3 p, float d) {\n\tvec3 e = vec3(0.04,0.0,0.0);\n\treturn normalize(vec3(\n\t\tscene(p+e.xyy)-d,\n\t\tscene(p+e.yxy)-d,\n\t\tscene(p+e.yyx)-d));\n}\n\nbool raystep(inout float d, inout vec3 p,vec3 ray){\n\tconst float eps=0.016;\n\td=scene(p);\n\tp+=max(eps,d*0.99)*ray;\n\treturn (d < eps);\n}\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 xy = fragCoord.xy / iResolution.xy - vec2(0.5,0.5);\n\txy.y *= -iResolution.y / iResolution.x;\n\n\tvec3 ro = 2.0*normalize(vec3(cos(iTime/4.0),cos(iTime/4.0),sin(iTime/4.0)));\n    vec3 eyed = normalize(vec3(0.0) - ro);\n    vec3 ud = normalize(cross(vec3(0.0,1.0,0.0), eyed));\n    vec3 vd = normalize(cross(eyed,ud));\n\n\tconst float fov = 3.14 * 0.7;\n\tfloat f = fov * length(xy);\n\tvec3 rd = normalize(normalize(xy.x*ud + xy.y*vd) + (1.0/tan(f))*eyed);\n\n\tvec3 p = ro;\n\tfloat d=0.017;\n\tfloat dummy;\n\tbool hit=false;\n\t\n\tfor(int i = 0; i < 64; i++) \n\t{\n\t\t#ifdef NO_BAIL\n\t\thit = ( hit == false ) ? raystep(d,p,rd):true;\n\t\t#else\n\t\thit = ( hit == false ) ? raystep(d,p,rd):true;\n\t\tif (hit) continue;\n\t\t#endif\n\t}\n\t\n\tvec3 bg = normalize(p).zzz + 0.21;\n\t\n\tif(d < 0.016) {\n\t\tvec3 n = normal(p,d); \n\t\tvec3 col = vec3(dot(vec3(0.0,0.0,1.0), n));\n\t\tfloat objrot;\n\t\tvec3 objp = trans(p,objrot);\n\t\tvec3 objn = abs(rot(n,objrot));\n\t\t\n\t\tvec2 uv = \n\t\t\t(objn.y > 0.707) ? vec2(objp.zx) : \n\t\t\t(objn.x > 0.707) ? vec2(objp.zy) :\n\t\t\t\t\t\t\t   vec2(objp.xy) ;\n\t\tvec3 tex = texture(iChannel0, uv).rgb;\n\t\tvec3 hl = smoothstep(0.6, 1.0, col);\n\t\tcol *= clamp(tex.xyz+0.13, 0.0, 1.0);\n\n\t\tcol = col + hl*.4;\n\t\tfloat dall = length(p-ro)*1.20;\n\t\tfloat fog = clamp(dall/mix(90.0,40.0,((rd.z+1.0)*0.5)), 0.0, 1.0);\n\n\t\tfragColor = vec4(mix(col, bg, fog),1.0);\n\t}\n\telse {\n\t\tfragColor = vec4(bg, 1.0);\n\t}\n\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lslXR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[209, 209, 242, 242, 301], [303, 303, 322, 322, 550], [552, 552, 579, 579, 686], [688, 688, 726, 726, 862], [863, 863, 884, 884, 1029], [1031, 1031, 1052, 1052, 1097], [1099, 1099, 1129, 1129, 1247], [1249, 1249, 1300, 1300, 1383], [1386, 1386, 1443, 1443, 2811]], "test": "error"}
{"id": "lslXz8", "name": "raytracer - test #1", "author": "remonvv", "description": "First test with GLSL real-time raytracer", "tags": ["raytracing"], "likes": 2, "viewed": 170, "published": "Public", "date": "1396944434", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision highp float;\nprecision lowp int;\n#endif\n\nfloat intersectPlane(in vec3 origin, in vec3 direction, out vec3 normal) {\n\n\tnormal = vec3(0.0, 1.0, 0.0);\n\treturn -origin.y / direction.y;\n}\n\nfloat intersectSphere(in vec3 origin, in vec3 direction, in vec4 sphere, out vec3 position, out vec3 normal) {\n\n\tvec3 center = origin - sphere.xyz;\n\t\n\tfloat b = 2.0 * dot(center, direction);\n\tfloat c = dot(center, center) - sphere.w * sphere.w;\n\tfloat h = b * b- 4.0 * c;\n\t\n\tif(h < 0.0)\n\t\treturn -1.0;\n\t\t\n\tfloat t = (-b - sqrt(h)) / 2.0;\n\t\n\tposition = origin + direction * t;\n\t\n\tnormal = normalize(position - sphere.xyz);\n\t\n\treturn t;\n}\n\nvec3 light = vec3(4.0, 5.0, 0.0);\nvec4 sphere1 = vec4(0.0, 1.0, 1.0, 1.0);\nvec4 sphere2 = vec4(0.0, 1.0, 1.0, 0.5);\n\nfloat intersect(in vec3 origin, in vec3 direction, out float t, out vec3 position, out vec3 normal) {\n\n\tt = 100000.0;\n\tfloat id = -1.0; \n\tvec3 normals1;\n\tvec3 normals2;\n\tvec3 normalp;\n\t\n\tfloat ts1 = intersectSphere(origin, direction, sphere1, position, normals1);\n\tfloat ts2 = intersectSphere(origin, direction, sphere2, position, normals2);\n\tfloat tp = intersectPlane(origin, direction, normalp);\n\t\n\tif(ts1 > 0.0) {\n\t\n\t\tid = 1.0;\n\t\tt = ts1;\n\t\tnormal = normals1;\n\t}\n\t\t\n\tif(ts2 > 0.0 && ts2 < t) {\n\t\n\t\tid = 1.5;\n\t\tt = ts2;\n\t\tnormal = normals2;\n\t}\n\t\t\n\tif(tp > 0.0 && tp < t) {\n\t\tid = 2.0;\n\t\tt = tp;\n\t\tnormal = normalp;\n\t}\n\t\t\n\tposition = origin + (t - 0.0001) * direction;\n\t\t\n\treturn id;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tsphere1.x = sin(iTime / 1.0);\n\tsphere1.z = cos(iTime / 1.0);\n\n\tsphere2.x = sphere1.x + sin(iTime / 0.5) * 1.5;\n\tsphere2.z = sphere1.z + cos(iTime / 0.5) * 1.5;\n\n\tfloat aspect = iResolution.y / iResolution.x;\n\tvec2 uv = fragCoord.xy / iResolution.xy * vec2(1, aspect);\n\tvec3 origin = vec3(0.0, 2.0, 4.0);\n\tvec3 direction = normalize(vec3(-1.0 + 2.0 * uv, -1.0));\n\t\n\tfloat distance;\n\tvec3 normal;\n\tvec3 position;\n\tfloat id = intersect(origin, direction, distance, position, normal);\n\n\tvec3 col = vec3(0.0);\n\t\n\tvec3 lightDir = normalize(light - position);\n\t\t\n\tfloat diffuse = clamp(dot(normal, lightDir), 0.0, 1.0) * 0.9;\n\tvec3 ambient = vec3(0.4, 0.4, 0.4);\n\t\n\tif(id > 0.9 && id < 1.1) {\n\t\t\n\t\tcol = vec3(1.0, 0.8, 0.9);\n\t\tcol *= 0.7 + 0.3 * normal.y; // hacked AO\n\t}\n\t\t\n\telse if(id > 1.4 && id < 1.6) {\n\t\t\n\t\tcol = vec3(0.8, 1.0, 0.7);\n\t\tcol *= 0.7 + 0.3 * normal.y; // hacked AO\n\t}\n\t\t\n\telse if(id > 1.9 && id < 2.1) {\n\t\n\t\tcol = vec3(0.7, 0.7, 0.9);\n\t\t\n\t\tif(fract(position.x / 10.0) > 0.5 ^^ fract(position.z / 10.0) > 0.5)\n\t\t\tcol *= 0.9;\n\t\t\n\t}\n\t\n\tvec3 shadowRay = normalize(light - position);\n\t\n\tfloat shadowT;\n\tvec3 shadowP;\n\tvec3 shadowN;\n\t\n\tfloat shadow = 1.0;\n\t\n\tif(intersect(position, shadowRay, shadowT,  shadowP, shadowN) > 0.0)\n\t\tshadow = 0.5;\n\t\t\n\tcol = col * ambient + col * diffuse * shadow;\n\t\n\tfragColor = vec4(col, min(1.0, iTime));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lslXz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[64, 64, 138, 138, 205], [207, 207, 317, 317, 643], [762, 762, 863, 863, 1448]], "test": "ok"}
{"id": "lsXSzH", "name": "Elevation", "author": "arthursw", "description": "Elevation lines", "tags": ["2d", "elevation"], "likes": 12, "viewed": 305, "published": "Public", "date": "1396625157", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// I've not seen anybody out there computing correct cell interior distances for Voronoi\n// patterns yet. That's why they cannot shade the cell interior correctly, and why you've\n// never seen cell boundaries rendered correctly. \n//\n// However, here's how you do mathematically correct distances (note the equidistant and non\n// degenerated grey isolines inside the cells) and hence edges (in yellow):\n//\n// http://www.iquilezles.org/www/articles/voronoilines/voronoilines.htm\n\n\n#define ANIMATE\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nvec2 hash( vec2 p )\n{\n    p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn fract(sin(p)*43758.5453);\n}\n\n\nvec2 rotate(vec2 v, float alpha)\n{\n\tfloat vx = v.x*cos(alpha)-v.y*sin(alpha);\n\tfloat vy = v.x*sin(alpha)+v.y*cos(alpha);\n\tv.x = vx;\n\tv.y = vy;\n\treturn v;\n}\n\nfloat particles( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    float d = 0.0;\n    for( int i=0; i<=150; i++ )\n\t{\n\t\tvec2 particle = hash(float(i)*vec2(0.323,0.156));\n\t\t\n        particle += 0.05*sin(1.0*iTime + 6.2831*particle );\n\t\t\n\t\tfloat w = 3.0*hash(float(i)*0.254);\n\t\td += w/length(particle-x);\n    }\n\n    return d;\n}\n\nfloat sinm(float t, float vmin, float vmax)\n{\n\treturn (vmax-vmin)*0.5*sin(t)+vmin+(vmax-vmin)*0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy/iResolution.xx;\n\n    float c = particles( p );\n\tfloat s = 0.005*c + 1.0*sin(100.0*log(c)) - 3.0*1.5;\n\t\n    vec3 col = (0.5 + 0.5*s)*vec3(s*0.95321,s*0.35,0.25);\n\t\n\tfragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsXSzH.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[621, 621, 644, 644, 683], [685, 685, 706, 706, 810], [813, 813, 847, 847, 968], [970, 970, 1000, 1000, 1309], [1311, 1311, 1356, 1356, 1411], [1413, 1413, 1470, 1470, 1689]], "test": "ok"}
{"id": "lsXSzM", "name": "well, that's cool.", "author": "gr4yscale", "description": "I have no idea what I'm doing. Well, kind of, but mostly not really.", "tags": ["2d"], "likes": 3, "viewed": 135, "published": "Public", "date": "1398276316", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 position = fragCoord.xy/iResolution.xy;\n    float aspect = iResolution.x/iResolution.y;\n\tposition.x *= aspect;\n\tfloat dist = distance(position, vec2(aspect*0.5, 0.5));\n\tfloat offset=sin(iTime*8.0/dist);\n\tfragColor = vec4(offset*sin(dist), offset*1.0-sin(dist), offset, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsXSzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 340]], "test": "ok"}
{"id": "lsXXz8", "name": "Little test", "author": "Nrx", "description": "Just a little test...", "tags": ["raymarching"], "likes": 5, "viewed": 369, "published": "Public API", "date": "1396527232", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define DELTA\t\t\t\t0.01\n#define RAY_LENGTH_MAX\t\t50.0\n#define RAY_STEP_MAX\t\t50\n#define LIGHT\t\t\t\tvec3 (0.5, 0.75, 1.0)\n#define BACK_COLOR\t\t\tvec3 (0.25, 0.5, 1.0)\n#define AMBIENT\t\t\t\t0.2\n#define SPECULAR_POWER\t\t4.0\n#define SPECULAR_INTENSITY\t0.5\n#define REFLECT_COUNT\t\t2\n#define FADE_POWER\t\t\t2.0\n#define GAMMA\t\t\t\t(1.0 / 2.2)\n#define M_PI\t\t\t\t3.1415926535897932384626433832795\n\n#define SHADOW\n\nmat3 mRotate (in vec3 angle) {\n\tfloat c = cos (angle.x);\n\tfloat s = sin (angle.x);\n\tmat3 rx = mat3 (1.0, 0.0, 0.0, 0.0, c, s, 0.0, -s, c);\n\n\tc = cos (angle.y);\n\ts = sin (angle.y);\n\tmat3 ry = mat3 (c, 0.0, -s, 0.0, 1.0, 0.0, s, 0.0, c);\n\n\tc = cos (angle.z);\n\ts = sin (angle.z);\n\tmat3 rz = mat3 (c, s, 0.0, -s, c, 0.0, 0.0, 0.0, 1.0);\n\n\treturn rz * ry * rx;\n}\n\nvec3 vRotateY (in vec3 p, in float angle) {\n\tfloat c = cos (angle);\n\tfloat s = sin (angle);\n\treturn vec3 (c * p.x - s * p.z, p.y, c * p.z + s * p.x);\n}\n\nfloat sphere (in vec3 p, in float r) {\n\treturn length (p) - r;\n}\n\nfloat box (in vec3 p, in vec3 b, in float r) {\n\treturn length (max (abs (p) - b + r, 0.0)) - r;\n}\n\nfloat plane (in vec3 p, in vec3 n, in float d) {\n\treturn dot (p, normalize (n)) + d;\n}\n\nfloat torusZ (in vec3 p, in float r1, in float r2) {\n\tvec2 q = vec2 (length (p.xy) - r1, p.z);\n\treturn length (q) - r2;\n}\n\nfloat cylinderX (in vec3 p, in float r) {\n \treturn length (p.yz) - r;\n}\n\nfloat cylinderY (in vec3 p, in float r) {\n \treturn length (p.xz) - r;\n}\n\nvec3 twistY (in vec3 p, in float k, in float angle) {\n\treturn vRotateY (p, angle + k * p.y);\n}\n\nfloat fixDistance (in float d, in float correction, in float k) {\n\tcorrection = max (correction, 0.0);\n\tk = clamp (k, 0.0, 1.0);\n\treturn min (d, max ((d - DELTA) * k + DELTA, d - correction));\n}\n\nfloat getDistance (in vec3 p, out vec4 q) {\n\n\t// Ground\n\tvec3 q_ = p;\n\tq_.z += 0.8 * (sin (iTime + p.x * 0.5) + sin (p.y * 0.5));\n\tfloat dist = fixDistance (plane (q_, vec3 (-0.2, 0.0, 1.0), 5.0), 0.6, 0.8); // need to fix the distance because of the sine deformation\n\tq = vec4 (q_, 0.0);\n\n\t// Twisted box\n\tq_ = p;\n\tq_.x -= 5.0;\n\tq_ = twistY (q_, cos (iTime), iTime);\n\tfloat dist_ = fixDistance (box (q_, vec3 (1.0, 1.0, 1.0), 0.1), 0.2, 0.8); // need to fix the distance because of the twist\n\tif (dist_ < dist) {\n\t\tq = vec4 (q_, 1.0);\n\t\tdist = dist_;\n\t}\n\n\t// Simple box\n\tq_ = p;\n\tq_.y -= 3.0;\n\tq_ = mRotate (vec3 (0.7, 0.0, -0.2)) * q_;\n\tdist_ = box (q_, vec3 (1.0, 0.5, 1.0), 0.3);\n\tif (dist_ < dist) {\n\t\tq = vec4 (q_, 2.0);\n\t\tdist = dist_;\n\t}\n\n\t// Sphere\n\tq_ = p + vec3 (3.0, -1.0, sin (iTime * 2.0) - 1.0);\n\tdist_ = sphere (q_, 1.0);\n\tif (dist_ < dist) {\n\t\tq = vec4 (q_, 3.0);\n\t\tdist = dist_;\n\t}\n\n\t// Twisted torus\n\tq_ = p;\n\tq_.y += 4.0;\n\tq_ = twistY (q_, 2.0, 0.0);\n\tdist_ = fixDistance (torusZ (q_, 1.0, 0.3), 0.8, 0.5); // need to fix the distance because of the twist\n\tif (dist_ < dist) {\n\t\tq = vec4 (q_, 4.0);\n\t\tdist = dist_;\n\t}\n\n\t// Cylinders\n\tq_ = p;\n\tq_.z += 2.0;\n\tq_.y = mod (q_.y, 5.0) - 0.5 * 5.0;\n\tdist_ = cylinderX (q_, 0.2);\n\tif (dist_ < dist) {\n\t\tq = vec4 (q_, 5.0);\n\t\tdist = dist_;\n\t}\n\tq_ = p;\n\tq_.z += 2.0;\n\tq_.x = mod (q_.x, 5.0) - 0.5 * 5.0;\n\tdist_ = cylinderY (q_, 0.2);\n\tif (dist_ < dist) {\n\t\tq = vec4 (q_, 6.0);\n\t\tdist = dist_;\n\t}\n\n\t// Smallest distance\n\treturn dist;\n}\n\nvec3 getObjectColor (in vec4 q, out float reflection) {\n\tfloat tint = 0.6 + 0.4 * sin (q.x * 10.0) * sin (q.y * 10.0) * sin (q.z * 10.0);\n\tif (q.w < 0.5) {\n\t\treflection = 0.0;\n\t\treturn (0.6 + 0.4 * tint) * vec3 (0.2, 1.0, 1.0);\n\t}\n\tif (q.w < 1.5) {\n\t\treflection = 0.2;\n\t\treturn tint * vec3 (1.0, 0.0, 0.0);\n\t}\n\tif (q.w < 2.5) {\n\t\treflection = 0.0;\n\t\treturn tint * vec3 (0.0, 0.0, 1.0);\n\t}\n\tif (q.w < 3.5) {\n\t\treflection = 0.5;\n\t\treturn tint * vec3 (1.0, 1.0, 0.0);\n\t}\n\tif (q.w < 4.5) {\n\t\treflection = 0.0;\n\t\treturn tint * vec3 (1.0, 0.2, 0.5);\n\t}\n\treflection = 0.0;\n\treturn tint * vec3 (0.5, 0.5, 0.6);\n}\n\nvec3 getNormal (in vec3 p) {\n\tvec4 q;\n\tvec2 h = vec2 (DELTA, 0.0);\n\treturn normalize (vec3 (\n\t\tgetDistance (p + h.xyy, q) - getDistance (p - h.xyy, q),\n\t\tgetDistance (p + h.yxy, q) - getDistance (p - h.yxy, q),\n\t\tgetDistance (p + h.yyx, q) - getDistance (p - h.yyx, q)\n\t));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Old monitor effect\n\tvec2 frag = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n\tfloat round = pow (length (frag * frag), 6.0);\n\tfrag.y *= 1.0 + round * 0.2;\n\tvec3 colorMonitor = vec3 (1.0 - round);\n\tcolorMonitor *= vec3 (0.8, 1.0 + abs (mod (frag.y, 0.04) / 0.04 - 0.5), 0.8);\n\n\t// Define the ray corresponding to this fragment\n\tfrag.x *= iResolution.x / iResolution.y;\n\tvec3 direction = normalize (vec3 (frag, 2.0));\n\n\t// Set the camera\n\tfloat angle = M_PI * sin (0.1 * iTime);\n\tvec3 origin = vec3 (10.0 * cos (angle), 10.0 * sin (angle), 2.5);\n\tdirection = mRotate (vec3 (M_PI / 2.0 + 0.45, 0.0, angle - M_PI / 2.0)) * direction;\n\n\t// Compute the fragment color\n\tvec3 lightDirection = normalize (LIGHT);\n\tfloat moveAway = DELTA * 10.0;\n\n\tvec3 color = vec3 (0.0, 0.0, 0.0);\n\tfloat absorb = 1.0;\n\tfloat fade = 0.0;\n\tfor (int reflectionIndex = 0; reflectionIndex < REFLECT_COUNT; ++reflectionIndex) {\n\n\t\t// Ray marching\n\t\tvec4 objectInfo;\n\t\tfloat rayLength = 0.0;\n\t\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\t\t\tfloat dist = getDistance (origin, objectInfo);\n\t\t\trayLength += dist;\n\t\t\tif (dist < DELTA || rayLength > RAY_LENGTH_MAX) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\torigin += dist * direction;\n\t\t}\n\n\t\t// Combine colors\n\t\tif (reflectionIndex == 0) {\n\t\t\tfade = pow (max (0.0, 1.0 - rayLength / RAY_LENGTH_MAX), FADE_POWER);\n\t\t} else {\n\t\t\tcolor *= 1.0 - absorb;\n\t\t}\n\t\tif (rayLength > RAY_LENGTH_MAX) {\n\t\t\tcolor += BACK_COLOR * absorb;\n\t\t\tbreak;\n\t\t}\n\n\t\t// Get the object color\n\t\tfloat reflection;\n\t\tvec3 objectColor = getObjectColor (objectInfo, reflection);\n\n\t\t// Lighting\n\t\tvec3 normal = getNormal (origin);\n\t\tdirection = reflect (direction, normal);\n\n\t\t#ifdef SHADOW\n\t\tvec3 p = origin + moveAway * lightDirection;\n\t\trayLength = 0.0;\n\t\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\t\t\tfloat dist = getDistance (p, objectInfo);\n\t\t\trayLength += dist;\n\t\t\tif (dist < DELTA || rayLength > RAY_LENGTH_MAX) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp += dist * lightDirection;\n\t\t}\t\t\n\t\tif (rayLength < RAY_LENGTH_MAX) {\n\t\t\tobjectColor *= AMBIENT;\n\t\t}\n\t\telse\n\t\t#endif\n\t\t{\n\t\t\tfloat diffuse = max (0.0, dot (normal, lightDirection));\n\t\t\tfloat specular = pow (max (0.0, dot (direction, lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n\t\t\tobjectColor = (AMBIENT + diffuse) * objectColor + specular;\n\t\t}\n\t\tcolor += objectColor * absorb;\n\n\t\t// Next ray...\n\t\tif (reflection < DELTA) {\n\t\t\tbreak;\n\t\t}\n\t\tabsorb *= reflection;\n\t\torigin += moveAway * direction;\n\t}\n\n\t// Fading\n\tcolor = mix (BACK_COLOR, color, fade);\n\n\t// Gamma correction\n\tcolor = pow (color, vec3 (GAMMA));\n\n\t// Set the fragment color\n\tfragColor = vec4 (color * colorMonitor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsXXz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[386, 386, 416, 416, 743], [745, 745, 788, 788, 896], [898, 898, 936, 936, 962], [964, 964, 1010, 1010, 1061], [1063, 1063, 1111, 1111, 1149], [1151, 1151, 1203, 1203, 1272], [1274, 1274, 1315, 1315, 1345], [1347, 1347, 1388, 1388, 1418], [1420, 1420, 1473, 1473, 1514], [1516, 1516, 1581, 1581, 1710], [1712, 1712, 1755, 1767, 3207], [3209, 3209, 3264, 3264, 3813], [3815, 3815, 3843, 3843, 4090]], "test": "ok"}
{"id": "lsXXzN", "name": "digits/sliders/kbd widgets", "author": "FabriceNeyret2", "description": "Utils\n\nnew version here: https://www.shadertoy.com/view/MdKGRw\n", "tags": ["font", "keyboard", "digits", "sliders", "widgets"], "likes": 18, "viewed": 2059, "published": "Public API", "date": "1397566249", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// cf new version here: https://www.shadertoy.com/view/MdKGRw\n\nvec2 FragCoord;\nvec4 FragColor;\n\n// --- key toggles -----------------------------------------------------\n\n// FYI: LEFT:37  UP:38  RIGHT:39  DOWN:40   PAGEUP:33  PAGEDOWN:34  END : 35  HOME: 36 F1:112\n\nbool keyToggle(int ascii) {\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\n}\nbool keyClick(int ascii) {\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.25)).x > 0.);\n}\n\n\n// --- Digit display ----------------------------------------------------\n\n// all functions return true or seg number if something was drawn -> caller can then exit the shader.\n\n//     ... adapted from Andre in https://www.shadertoy.com/view/MdfGzf\n\nfloat segment(vec2 uv, bool On) {\n\treturn (On) ?  (1.-smoothstep(0.08,0.09+float(On)*0.02,abs(uv.x)))*\n\t\t\t       (1.-smoothstep(0.46,0.47+float(On)*0.02,abs(uv.y)+abs(uv.x)))\n\t\t        : 0.;\n}\n\nfloat digit(vec2 uv,int num) {\n\tfloat seg= 0.;\n    seg += segment(uv.yx+vec2(-1., 0.),num!=-1 && num!=1 && num!=4                    );\n\tseg += segment(uv.xy+vec2(-.5,-.5),num!=-1 && num!=1 && num!=2 && num!=3 && num!=7);\n\tseg += segment(uv.xy+vec2( .5,-.5),num!=-1 && num!=5 && num!=6                    );\n   \tseg += segment(uv.yx+vec2( 0., 0.),num!=-1 && num!=0 && num!=1 && num!=7          );\n\tseg += segment(uv.xy+vec2(-.5, .5),num==0 || num==2 || num==6 || num==8           );\n\tseg += segment(uv.xy+vec2( .5, .5),num!=-1 && num!=2                              );\n    seg += segment(uv.yx+vec2( 1., 0.),num!=-1 && num!=1 && num!=4 && num!=7          );\t\n\treturn seg;\n}\n\nfloat showNum(vec2 uv,int nr, bool zeroTrim) { // nr: 2 digits + sgn . zeroTrim: trim leading \"0\"\n\tif (abs(uv.x)>2.*1.5 || abs(uv.y)>1.2) return 0.;\n\n\tif (nr<0) {\n\t\tnr = -nr;\n\t\tif (uv.x>1.5) {\n\t\t\tuv.x -= 2.;\n\t\t\treturn segment(uv.yx,true); // minus sign.\n\t\t}\n\t}\n\t\n\tif (uv.x>0.) {\n\t\tnr /= 10; if (nr==0 && zeroTrim) nr = -1;\n\t\tuv -= vec2(.75,0.);\n\t} else {\n\t\tuv += vec2(.75,0.); \n\t\tnr = int(mod(float(nr),10.));\n\t}\n\n\treturn digit(uv,nr);\n}\n\nfloat dots(vec2 uv, int dot) { // dot: bit 0 = bottom dot; bit 1 = top dot\n\tfloat point0 = float(dot/2),\n\t\t  point1 = float(dot)-2.*point0; \n\tuv.y -= .5;\tfloat l0 = 1.-point0+length(uv); if (l0<.13) return (1.-smoothstep(.11,.13,l0));\n\tuv.y += 1.;\tfloat l1 = 1.-point1+length(uv); if (l1<.13) return (1.-smoothstep(.11,.13,l1));\n\treturn 0.;\n}\n//    ... end of digits adapted from Andre\n\n#define STEPX .875\n#define STEPY 1.5\nfloat _offset=0.; // auto-increment useful for successive \"display\" call\n\n// 2digit int + sign\nbool display(vec2 pos, float scale, float offset, int number, int dot) { // dot: draw separator\n\tvec2 uv = FragCoord.xy/iResolution.y;\n\tuv = (uv-pos)/scale*2.; \n    uv.x = .5-uv.x + STEPX*offset;\n\tuv.y -= 1.;\n\t\n\tfloat seg = showNum(uv,number,false);\n\toffset += 2.;\n\t\n\tif (dot>0) {\n\t\tuv.x += STEPX*offset; \n\t\tseg += dots(uv,dot);\n\t\toffset += 2.;\n\t}\n\n\tFragColor += vec4(seg);  // change color here\n\t_offset = offset;\n\treturn (seg>0.);\n}\n\n// 2.2 float + sign\nbool display(vec2 pos, float scale, float offset, float val) { // dot: draw separator\n\tif (display( pos, scale, 0., int(val), 1)) return true;\n    if (display( pos, scale, _offset, int(fract(abs(val))*100.), 0)) return true;\n\treturn false;\n}\n\n\n// --- sliders and mouse widgets ---------------------------\n\nbool affMouse() \n{\n\tfloat R=5.;\n\tvec2 pix = FragCoord.xy/iResolution.y;\n\tfloat pt = max(1e-2,1./iResolution.y); R*=pt;\n\n\tvec2 ptr = iMouse.xy/iResolution.y; \n\tvec2 val = iMouse.zw/iResolution.y; \n\tfloat s=sign(val.x); val = val*s;\n\t\n\t// current mouse pos\n    float k = dot(ptr-pix,ptr-pix)/(R*R*.4*.4);\n\t\tif (k<1.) \n\t    { if (k>.8*.8) FragColor = vec4(0.);\n\t\t     else      FragColor = vec4(s,.4,0.,1.); \n\t\t  return true;\n\t\t}\n\t\n\t// prev mouse pos \n    k = dot(val-pix,val-pix)/(R*R*.4*.4);\n\t\tif (k<1.) \n\t    { if (k>.8*.8) FragColor = vec4(0.);\n\t\t     else      FragColor = vec4(0.,.2,s,1.); \n\t\t  return true;\n\t\t}\n\t\n\treturn false;\n}\nbool affSlider(vec2 p0, vec2 dp, float v)\n{\n\tfloat R=5.;\n\tvec2 pix = FragCoord.xy/iResolution.y;\n\tfloat pt = max(1e-2,1./iResolution.y); R*=pt;\n\tpix -= p0;\n\n\tfloat dp2 = dot(dp,dp);\n\tfloat x = dot(pix,dp)/dp2; if ((x<0.)||(x>1.)) return false;\n\tfloat x2=x*x;\n\tfloat y = dot(pix,pix)/dp2-x2; if (y>R*R) return false;\n\n\ty = sqrt(y);\n\tif (y<pt) { FragColor = vec4(1.,.2,0.,1.); return true; }      // rule\n\tvec2 p = vec2(x-v,y);\n\tif (dot(p,p)<R*R) { FragColor = vec4(1.,.2,0.,1.); return true; }  // button\n\t\n\treturn false;\n}\n\n// --- flag and values buton display ---\n\nfloat showFlag(vec2 p, vec2 uv, float v) {\n\tfloat d = length(2.*(uv-p));\n\treturn \t1.-step(.06*v,d) + smoothstep(0.005,0.,abs(d-.06));\n}\n\nfloat showFlag(vec2 p, vec2 uv, bool flag) {\n\treturn showFlag(p, uv, (flag) ? 1.: 0.);\n}\n\n// --------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    FragCoord=fragCoord;\n\tvec2 uv = fragCoord.xy/iResolution.y;\n\tvec4 mouse = iMouse/iResolution.y;\n\tFragColor = vec4(0.);\t\n\n    if (affMouse()) { fragColor=FragColor; return;} // display mouse and state\n\t\n\tif (iMouse.z<=0.) // auto-tuning if no user tuning\n\t{   float t = iTime;\n\t\tmouse.xy = .05+.3*vec2(1.+cos(t),1.+sin(t))/2.;\n\t}\n\t\n\t{   // display sliders\n\t\tvec2 pos = vec2(.05,.02), len = vec2(.4,0);\n        if (affSlider(pos.xy, len.xy,(mouse.x-pos.x)/length(len))) { fragColor=FragColor; return;}\n\t\tif (affSlider(pos.yx, len.yx,(mouse.y-pos.x)/length(len))) { fragColor=FragColor; return;}\n\t}\n\t\n\t// display counters\n\tvec2 pos ; \n\tfloat scale = 0.1;\n\t\n\tpos = vec2(.2,.8);    if (display( pos, scale, 0., mouse.x*100.)) { fragColor=FragColor; return;}\n\tpos.y -= STEPY*scale; if (display( pos, scale, 0., mouse.y*100.)) { fragColor=FragColor; return;} \n\tpos.y -= STEPY*scale; if (display( pos, scale, 0., mouse.z*100.)) { fragColor=FragColor; return;}\n\tpos.y -= STEPY*scale; if (display( pos, scale, 0., mouse.a*100.)) { fragColor=FragColor; return;} \n\tpos.y -= STEPY*scale; if (display( pos, scale, 0., mod(iTime,60.))) { fragColor=FragColor; return;} \n\n\t// button panel\n\tfloat panel = showFlag(vec2(.70,.05),uv, (mouse.z<0.))\n\t\t\t\t+ showFlag(vec2(.70,.15),uv, (mouse.z>0.))\n\t\t\t\t+ showFlag(vec2(.80,.05),uv, (mouse.a<0.))\n\t\t\t\t+ showFlag(vec2(.80,.15),uv, (mouse.a>0.))\n\t\t\t\t+ showFlag(vec2(.90,.10),uv, mouse.x)\n\t\t\t\t+ showFlag(vec2(1.0,.10),uv, mouse.y);\n\tFragColor.b += panel;\n    fragColor=FragColor;\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsXXzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[265, 265, 292, 292, 365], [366, 366, 392, 392, 465], [718, 718, 751, 751, 910], [912, 912, 942, 942, 1585], [1587, 1587, 1633, 1684, 2024], [2026, 2026, 2056, 2100, 2368], [2524, 2545, 2617, 2640, 2979], [2981, 3001, 3063, 3086, 3242], [3307, 3307, 3325, 3325, 3940], [3941, 3941, 3984, 3984, 4463], [4507, 4507, 4549, 4549, 4642], [4644, 4644, 4688, 4688, 4732], [4789, 4789, 4846, 4846, 6375]], "test": "error"}
{"id": "MdlSRM", "name": "KIFS", "author": "EvilRyu", "description": "A menger spone..", "tags": ["3d", "raymarching", "fractal", "kifs"], "likes": 52, "viewed": 6272, "published": "Public API", "date": "1398595351", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Try KIFS...\n\n void ry(inout vec3 p, float a){  \n \tfloat c,s;vec3 q=p;  \n  \tc = cos(a); s = sin(a);  \n  \tp.x = c * q.x + s * q.z;  \n  \tp.z = -s * q.x + c * q.z; \n }  \n void rx(inout vec3 p, float a){  \n \tfloat c,s;vec3 q=p;  \n  \tc = cos(a); s = sin(a);  \n  \tp.y = c * q.y - s * q.z;  \n  \tp.z = s * q.y + c * q.z; \n }  \n\n void rz(inout vec3 p, float a){  \n \tfloat c,s;vec3 q=p;  \n  \tc = cos(a); s = sin(a);  \n  \tp.x = c * q.x - s * q.y;  \n  \tp.y = s * q.x + c * q.y; \n }  \nfloat plane(vec3 p, float y) {\n    return length(vec3(p.x, y, p.z) - p);\n}\n\n// folding hex from nimitz: https://www.shadertoy.com/view/XtdGDB\nvec2 fold(vec2 p)\n{\n    p.xy = abs(p.xy);\n    const vec2 pl1 = vec2(-0.5, 0.8657);\n    const vec2 pl2 = vec2(-0.8657, 0.4);\n    p -= pl1*2.*min(0., dot(p, pl1));\n    p -= pl2*2.*min(0., dot(p, pl2));\n    return p;\n}\n\nvec3 mat=vec3(0.0);\nbool bcolor = false;\n\nfloat menger_spone(in vec3 z0){\n\tvec4 z=vec4(z0,1.0);\n    vec3 offset = vec3(0.785,1.1,0.46);\n    float scale = 2.46;\n\tfor (int n = 0; n < 4; n++) {\n\t\tz = abs(z);\n\t\tif (z.x<z.y)z.xy = z.yx;\n\t\tif (z.x<z.z)z.xz = z.zx;\n\t\tif (z.y<z.z)z.yz = z.zy;\n\t\tz = z*scale;\n\t\tz.xyz -= offset*(scale-1.0);\n       \tif(bcolor && n==2)\n            mat+=vec3(0.5)+sin(z.xyz)*vec3(1.0, 0.24, 0.245);\n\t\tif(z.z<-0.5*offset.z*(scale-1.0))\n            z.z+=offset.z*(scale-1.0);\n\t}\n\treturn (length(max(abs(z.xyz)-vec3(1.0),0.0))-0.05)/z.w;\n}\n\n vec3 f(vec3 p){ \n     ry(p,iTime*0.4);\n     float d1 = plane(p, -0.8);\n     p.xz = fold(p.xz);\n\n     float d2 = menger_spone(p);\n     if(d1 < d2)\n     {\n         return vec3(d1, 0.0, 0.0);\n     }\n     else\n     {\n         return vec3(d2, 1.0, 0.0);\n     } \n } \n\n float ao(vec3 p, vec3 n){ \n \tfloat ao=0.0,sca=1.0; \n \tfor(float i=0.0;i<20.0;++i){ \n \t\tfloat hr=0.05+0.015*i*i; \n \t\tao+=(hr-f(n*hr+p).x)*sca; \n \t\tsca*=0.75; \n \t} \n \treturn 1.0-clamp(ao,0.0,1.0); \n } \n\n\nfloat rand(vec2 t){\n\treturn fract(sin(dot(t*0.123,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat softshadow(vec3 ro, vec3 rd, float k ){ \n     float s=1.0,h=0.0; \n     float t = 0.01;\n     for(int i=0; i < 50; ++i){ \n         h=f(ro+rd*t).x; \n         if(h<0.001){s=0.0;break;} \n         s=min(s, k*h/t); \n         t+=abs(h);\n     } \n     return clamp(s*0.9+0.1, 0.0, 1.0); \n} \n vec3 nor(vec3 p){ \n \tvec3 e=vec3(0.0001,0.0,0.0); \n \treturn normalize(vec3(f(p+e.xyy).x-f(p-e.xyy).x, \n \t\t\t\t\t\t  f(p+e.yxy).x-f(p-e.yxy).x, \n \t\t\t\t\t\t  f(p+e.yyx).x-f(p-e.yyx).x)); \n } \n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n    float t = 0.0;\n    vec3 res = vec3(-1.0);\n\tvec3 h = vec3(1.0);\n    for( int i=0; i<64; i++ )\n    {\n\t\tif( h.x<0.003 || t>30.0 ){\n\t\t}else {\n        \th = f(ro + rd*t);\n        \tres = vec3(t,h.yz);\n        \tt += abs(h.x);\n\t\t}\n    }\n\tif( t>30.0 ) res=vec3(-1.0);\n    return res;\n}\n\n void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n { \n    vec2 q=fragCoord.xy/iResolution.xy; \n \tvec2 uv = -1.0 + 2.0*q; \n \tuv.x*=iResolution.x/iResolution.y; \n\n    vec3 ta = vec3(0,0.08,0.);\n    vec3 ro = vec3(1., 1.4, -3.);\n \tvec3 cf = normalize(ta-ro); \n    vec3 cs = normalize(cross(cf,vec3(0.0,1.0,0.0))); \n    vec3 cu = normalize(cross(cs,cf)); \n \tvec3 rd = normalize(uv.x*cs + uv.y*cu + 2.8*cf);  // transform from view to world\n\n    vec3 sundir = normalize(vec3(3., 5.,-2.8)); \n    vec3 sun = vec3(1.64, 1.27, 0.99); \n    vec3 skycolor = vec3(0.6, 1.5, 1.0); \n\n\tvec3 bg = exp(uv.y-1.0)*vec3(0.5, 0.9, 1.5);\n\n    float sc=clamp(dot(sundir, rd), 0.0, 1.0); \n    vec3 col=bg+vec3(1.0,0.8,0.4)*pow(sc,50.0); \n\n\n    float t=0.0;\n    vec3 p=ro; \n\t \n\tvec3 res = intersect(ro, rd);\n\t if(res.x > 0.0){\n\t\t   p = ro + res.x * rd;\n           bcolor = true;\n           mat=vec3(0.0);\n           vec3 n=nor(p);\n           mat/=6.0;\n           bcolor = false;\n           float occ = ao(p, n); \n           float shadow = softshadow(p, sundir, 50.0);\n\n           float dif = max(0.0, dot(n, sundir)); \n           float sky = 0.6 + 0.4 * max(0.0, dot(n, vec3(0.0, 1.0, 0.0))); \n \t\t   float bac = max(0.3 + 0.7 * dot(vec3(-sundir.x, -1.0, -sundir.z), n), 0.0); \n           float spe = max(0.0, pow(clamp(dot(sundir, reflect(rd, n)), 0.0, 1.0), 20.0)); \n\n           vec3 lin = 5.5 * sun * dif; \n           lin += 0.8 * bac * sun * occ; \n           lin += 0.6 * sky * skycolor * occ; \n           lin += 2.0 * spe * occ; \n\n           col = shadow * lin *(vec3(0.6, 0.8, 0.9)*(1.0-res.y)+mat*res.y) *  0.2; \n \t\t   col = mix(col,bg, 1.0-exp(-0.003*res.x*res.x)); \n    } \t\n    // post\n    col=pow(clamp(col,0.0,1.0),vec3(0.45)); \n    col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n    col=mix(col, vec3(dot(col, vec3(0.33))), -1.);  // satuation\n    col*=0.5+0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.8);  // vigneting\n \tfragColor.xyz = col; \n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdlSRM.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[127, 127, 158, 158, 276], [280, 280, 311, 311, 428], [433, 433, 464, 464, 581], [584, 584, 614, 614, 658], [660, 726, 745, 745, 941], [985, 985, 1016, 1016, 1501], [1504, 1504, 1519, 1519, 1763], [1767, 1767, 1792, 1792, 1965], [1969, 1969, 1988, 1988, 2058], [2059, 2059, 2104, 2104, 2344], [2347, 2347, 2364, 2364, 2528], [2531, 2531, 2573, 2573, 2853], [2856, 2856, 2915, 2915, 4797]], "test": "ok"}
{"id": "MdlXzM", "name": "Persian Carpet", "author": "gleurop", "description": "I really like the color quantization in this one.", "tags": ["procedural", "2d", "fractal"], "likes": 11, "viewed": 934, "published": "Public", "date": "1398631560", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 fold = vec2(0.5, -0.5);\nvec2 translate = vec2(1.5);\nfloat scale = 1.3;\n\nvec3 hsv(float h,float s,float v) {\n\treturn mix(vec3(1.),clamp((abs(fract(h+vec3(3.,2.,1.)/3.)*6.-3.)-1.),0.,1.),s)*v;\n}\n\nvec2 rotate(vec2 p, float a){\n\treturn vec2(p.x*cos(a)-p.y*sin(a), p.x*sin(a)+p.y*cos(a));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = -1.0 + 2.0*fragCoord.xy/iResolution.xy;\n\tp.x *= iResolution.x/iResolution.y;\n\tp *= 0.003;\n\tfloat x = p.y;\n\tp = abs(mod(p, 8.0) - 4.0);\n\tfor(int i = 0; i < 36; i++){\n\t\tp = abs(p - fold) + fold;\n\t\tp = p*scale - translate;\n\t\tp = rotate(p, 3.14159/(8.0+sin(iTime*0.001+float(i)*0.1)*0.5+0.5));\n\t}\n\tfloat i = x*10.0 + atan(p.y, p.x) + iTime*0.5;\n\tfloat h = floor(i*6.0)/5.0 + 0.07;\n\th += smoothstep(0.0, 0.4, mod(i*6.0/5.0, 1.0/5.0)*5.0)/5.0 - 0.5;\n\tfragColor=vec4(hsv(h, 1.0, smoothstep(-1.0, 3.0, length(p))), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdlXzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 77, 112, 112, 197], [199, 199, 228, 228, 290], [292, 292, 349, 349, 874]], "test": "ok"}
{"id": "MdlXzN", "name": "Toune Aile", "author": "Patapom", "description": "\"Bisou tunnel with bars\" a.k.a. \"what it feels like when you're a turd rushing to the sewers\"...", "tags": ["tunnel"], "likes": 20, "viewed": 615, "published": "Public", "date": "1398525246", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// If you want to puke, just uncomment these lines... ^^\n#define ANIMATE_TUNNEL\n#define ROTATE_BARS\n#define TRANSLATE_BARS\n\n// Define this to feel the power of the turd\n//#define TURD_MODE\n\n// Change this for more or less reflection\n#define FRESNEL 0.05\n\n\nconst float PI = 8.0;//3.14159265358979;\n\nfloat repeat( float a, float s )\n{\n\treturn mod( a - 0.5*s, s ) + 0.5*s;\n}\n\nfloat smin( float a, float b, float k )\n{\n\treturn log( max( 0.001, exp( a*k ) + exp( b*k ) ) ) / k;\n\treturn log( max( 0.001, exp( (-10.0+a)*k ) + exp( (-10.0+b)*k ) ) ) / k + 10.0;\n}\n\nfloat smin2( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat hash( float n ) { return fract(sin(n)*43758.5453123); }\n\nfloat noise( in vec3 x )\n{\n   vec3 p = floor(x);\n   vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel0, (uv+0.5)/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n// Assuming n1=1 (air) we get:\n//\tF0 = ((n2 - n1) / (n2 + n1))Â²\n//\t=> n2 = (1 + sqrt(F0)) / (1 - sqrt(F0))\n//\nvec3\tFresnel_IORFromF0( vec3 _F0 )\n{\n\tvec3\tSqrtF0 = sqrt( _F0 );\n\treturn (1.0 + SqrtF0) / (1.00001 - SqrtF0);\n}\n\n// Full accurate Fresnel computation (from Walter's paper Â§5.1 => http://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf)\n// For dielectrics only but who cares!?\nvec3\tFresnel( vec3 _IOR, float _CosTheta, float _FresnelStrength )\n{\n\tfloat\tc = mix( 1.0, _CosTheta, _FresnelStrength );\n\tvec3\tg_squared = max( vec3(0.0), _IOR*_IOR - 1.0 + c*c );\n// \tif ( g_squared < 0.0 )\n// \t\treturn 1.0;\t// Total internal reflection\n\n\tvec3\tg = sqrt( g_squared );\n\n\tvec3\ta = (g - c) / (g + c);\n\t\t\ta *= a;\n\tvec3\tb = (c * (g+c) - 1.0) / (c * (g-c) + 1.0);\n\t\t\tb = 1.0 + b*b;\n\n\treturn 0.5 * a * b;\n}\n\nfloat smoothinterp( float x0, float x1, float t )\n{\n\treturn mix( x0, x1, smoothstep( 0.0, 1.0, t ) );\n}\n\nvec2 tunnelCenter( float z )\n{\n#ifdef ANIMATE_TUNNEL\n\treturn vec2(\t0.2 * (sin( 0.5919 * z + 4.0 * iTime ) + sin( 1.2591 * z )*cos( 0.915 * z )),\n\t\t\t\t\t0.2 * (sin( 1.8 * z + 4.0 * iTime ) + sin( 0.1378 * z )) );\n#else\n\treturn vec2( 0.0, 0.0 );\n#endif\n}\n\nconst float barGap = 1.0;\n\nvoid barCenterAxis( float z, out vec3 barCenter, out vec3 barAxis, out float barOffset )\n{\t\n\tvec2\tc = tunnelCenter( z ); \t// Tunnel center\n\t\n\t// Retrieve bar index & compute rotation/offset\n\tfloat\tbarIndex = floor( z / barGap );\n\tfloat\tzcenter = (0.5+barIndex) * barGap;\n\tfloat\tangle = 2.0 * PI * 0.156 * (0.2+barIndex);// + iTime;\n\t\n\tangle = 0.798 * barIndex;\t// Fixed bars\n#ifdef ROTATE_BARS\n\tangle += iTime * (0.5 + 1.0 * sin( 1234.567 * barIndex ));\n#endif\n\n\tbarAxis = vec3( cos( angle ), sin( angle ), 0.2 * sin( zcenter ) );\n\n#ifdef TRANSLATE_BARS\n\tbarOffset = 0.0 + 0.5 * sin( 17.21191 * barIndex + iTime * (0.5 + 1.0 * sin( 8976.5431 * barIndex )) );\n#else\n\tbarOffset = 0.0 + 0.5 * sin( 17.21191 * barIndex );\n#endif\n\n\tbarCenter = vec3( c + barOffset * vec2( -barAxis.y, barAxis.x ), zcenter );\n}\n\nvec3 safePosition( float z, float rand )\n{\n\tvec3\tbarCenter0, barAxis0; float barOffset0;\n\tbarCenterAxis( z - 0.5 * barGap, barCenter0, barAxis0, barOffset0 );\n\tvec2\ttunnelCenter0 = tunnelCenter( barCenter0.z );\n\n\tvec3\tbarCenter1, barAxis1; float barOffset1;\n\tbarCenterAxis( z + 0.5 * barGap, barCenter1, barAxis1, barOffset1 );\n\tvec2\ttunnelCenter1 = tunnelCenter( barCenter1.z );\n\t\n\tfloat\tz0 = barCenter0.z;\n\tfloat\tz1 = barCenter1.z;\n\tfloat\tt = (z - z0) / (z1 - z0); // Interpolant\n\t\n\t// Compute the 2 valid positions for each bar\n\tfloat\toff0 = mix( 0.5*(1.0+barOffset0), 0.5*(-1.0+barOffset0),\n\t\t\t\t\t\tstep( 0.0, sign( sin( 37.85961 * (z0 + rand) ) ) ) );\t// Choose between left or right of the bar...\n\tvec2\tsafePos0 = tunnelCenter0 + off0 * vec2( -barAxis0.y, barAxis0.x );\n\n\tfloat\toff1 = mix( 0.5*(1.0+barOffset1), 0.5*(-1.0+barOffset1),\n\t\t\t\t\t\tstep( 0.0, sign( sin( 37.85961 * (z1 + rand) ) ) ) );\n\tvec2\tsafePos1 = tunnelCenter1 + off1 * vec2( -barAxis1.y, barAxis1.x );\n\t\n\treturn vec3(\tsmoothinterp( safePos0.x, safePos1.x, t ),\n\t\t\t\t\tsmoothinterp( safePos0.y, safePos1.y, t ),\n\t\t\t\t\tz );\n}\n\nfloat bisou( vec3 p )\n{\n\tvec3\tc, axis; float offset;\n\tbarCenterAxis( p.z, c, axis, offset );\n\t\n\tvec3\ttoP = p-c;\n\tvec3\tplaneP = toP - dot( toP, axis ) * axis;\n\t\n\treturn length( planeP ) - 0.1\n//\t\t- 0.05 * noise(37.0569 * p )\n\t\t;\n}\n\nfloat map( vec3 p )\n{\n\tvec2\tc = tunnelCenter( p.z );\n\tfloat\td_tunnel = 1.0 - length( p.xy - c );\n\tfloat\td_bar = bisou( p );\n\n\treturn smin2( d_tunnel, d_bar, 0.7 )\n#ifdef TURD_MODE\n\t\t- 0.025 * noise( 67.0569 * p )\n#endif\n\t;\n\t\n\treturn min( d_tunnel, d_bar );\n\treturn smin( d_tunnel, d_bar, -4.0 );\n}\n\nvec3 normal( vec3 p, const float eps, out float cheapAO )\n{\n\tvec2 e = vec2( eps, 0.0 );\n\tfloat c = map( p );\n\tvec3\tn = vec3(\n\t\tmap( p + e.xyy ) - map( p - e.xyy ),\n\t\tmap( p + e.yxy ) - map( p - e.yxy ),\n\t\tmap( p + e.yyx ) - map( p - e.yyx )\n\t\t);\n\tcheapAO = length( n );\n\treturn n / cheapAO;\n}\n\nvec3 reflection( vec3 p, vec3 v, vec3 n )\n{\n\tv = reflect( v, n );\n//\tp += (0.01 / dot( v, n )) * v;\n\tp += 0.01 * n;\n\n\tfloat\tt = 0.0;\n\tfor ( int i=0; i < 64; i++ )\n\t{\n\t\tfloat\td = map( p );\n\t\tif ( d < 0.005 ) break;\n\n\t\tt += d;\n\t\tp += d * v;\n\t}\n\n\treturn p;\n}\n\nfloat AO( vec3 p, vec3 n )\n{\n\tconst float step = 0.01;\n\tp += 0.1 * n;\n\tfloat AO = 1.0;\n\tfor ( int i=0; i < 16; i++ )\n\t{\n\t\tfloat\td = max( 0.0, map( p ) );\n\t\tp += step * n;\n\t\t\n\t\tAO *= 1.0 - exp( -20.0 * d * (2.0+float(i)) );\n\t}\n\treturn AO;\n}\n\nfloat\tShadow( vec3 p, vec3 l, float distance2Light )\n{\n\tconst float\tk = 10.0;\n\n\tfloat S = 1.0;\n\tfloat t = 0.05;\n\tfor ( int i=0; i < 64; i++ )\n\t{\n\t\tfloat\th = map( p + t * l );\n\t\tif ( h < 0.0001 )\n\t\t\treturn 0.0;\n\n\t\tS = min( S, k*h / t );\n\t\tt += h;\n\t\tif ( t > distance2Light )\n\t\t\tbreak;\n\t}\n\treturn S;\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2\tuv = fragCoord.xy / iResolution.xy;\n\t\n\tfloat\tz = 1.0 * iTime;\n\n\tvec3\tp = safePosition( z, 0.0 );\n\n\tvec3\ttarget = p + vec3(\n\t\tsin( 1.2 * iTime ),\n\t\tsin( 1.0 + 0.7891 * iTime ),\n\t\t5.0 + 2.0 * sin( 1.2 * iTime )\n\t\t);\n\t\n\tvec3\tat = normalize( target - p );\n\tvec3\tright = normalize( cross( at, vec3( 0, 1, 0 ) ) );\n\tvec3\tup = cross( right, at );\n\n\tfloat\tTan = 0.6;\n\tvec3\tv = normalize( vec3( iResolution.x / iResolution.y * Tan * (2.0 * uv.x - 1.0), Tan * (2.0 * uv.y - 1.0), 1.0 ) );\n\t\t\tv = v.x * right + v.y * up + v.z * at;\n\n\t// Compute light position\n\tfloat\tlightTime = 0.25 * iTime;\n\tfloat\tz_light = z + 4.0 + 3.0 * sin( 3.156 * lightTime ) * sin( 0.15891 * lightTime );\n\tvec3\tl = safePosition( z_light, 187.65 );\n\n\t// March!\n\tvec3\tprevPos2Light = l - p;\n\tfloat\tprevDist2Light = length( prevPos2Light );\n\t\t\tprevPos2Light /= max( 1e-4, prevDist2Light );\n\n\tfloat\tscatt = 0.0;\n\tvec3\tp_orig = p;\n\tfor ( int i=0; i < 64; i++ )\n\t{\n\t\tfloat\td = map( p );\n\t\tif ( d < 0.005 ) break;\n\t\tp += d * v;\n\n\t\tvec3\tpos2Light = l - p;\n\t\tfloat\tdist2Light = length( pos2Light );\n\t\t\t\tpos2Light /= max( 1e-4, dist2Light );\n\t\tscatt += d / pow( 0.5 * (prevDist2Light + dist2Light), 2.0 );\n\t\tprevPos2Light = pos2Light;\n\t\tprevDist2Light = dist2Light;\n\t}\n\n\tconst float\t\tLightIntensity = 0.5;\n\tconst vec3\tC0 = 1.0 * vec3( 0.2, 0.2, 0.2 );\n\tconst vec3\tC1 = vec3( 1.0, 1.0, 1.0 );\n\n\tscatt = pow( max( 0.0, 0.2 * (scatt - 0.25) ), 2.0 );\n\n\t// Compute normal and Fresnel\n\tfloat\tAO;\n\tvec3\tn = normal( p, 0.0001, AO );\n\tvec3\tF0 = FRESNEL * vec3( 0.5, 0.8, 1.0 );\n\tvec3\tFr = clamp( vec3( 0.0 ), vec3( 1.0 ), Fresnel( Fresnel_IORFromF0( F0 ), dot( -v, n ), 1.0 ) );\n\n\t// Compute direct lighting\n\tvec3\tLight = l - p;\n\tfloat\tdLight = length( Light );\n\t\t\tLight *= 1.0 / max( 0.001, dLight );\n\tfloat\tshadow = Shadow( p, Light, dLight );\n\tvec3\tcolorT = (LightIntensity / (dLight*dLight)) * mix( C0, shadow * C1, 0.5 + 0.5 * dot( n, Light ));\n\n\t// Compute reflection\n\tvec3\tp_refl = reflection( p, v, n );\n\tvec3\tn_refl = normal( p_refl, 0.0001, AO );\n\n\t\t\tLight = l - p_refl;\n\t\t\tdLight = max( 0.05, length( Light ) );\n\t\t\tLight *= 1.0 / dLight;\n\tvec3\tcolorR = (LightIntensity / (dLight*dLight)) * mix( AO*C0, C1, 0.5 + 0.5 * dot( n_refl, Light ));\n\t\n\tvec3\tcolor = mix( colorT, colorR, Fr );\n\n\tcolor += scatt * vec3( 1.0, 0.5, 0.3 );\n\n\t// Apply fog\n\tfloat\tt = length( p - p_orig );\n\tfloat\tfog = exp( -0.05 * t );\n\tcolor = mix( vec3( 1.0, 0.9, 0.8 ), color, fog );\n\n\tcolor = pow( color, vec3(1.0/2.2) );\n\t\n\tfragColor = vec4( color, 1.0 );\n}\n", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdlXzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[299, 299, 333, 333, 372], [374, 374, 415, 415, 556], [558, 558, 600, 600, 693], [695, 695, 718, 718, 756], [758, 758, 784, 784, 991], [993, 1106, 1142, 1142, 1217], [1219, 1389, 1457, 1457, 1803], [1805, 1805, 1856, 1856, 1908], [1910, 1910, 1940, 1940, 2160], [2189, 2189, 2279, 2279, 2993], [2995, 2995, 3037, 3037, 4085], [4087, 4087, 4110, 4110, 4316], [4617, 4617, 4676, 4676, 4909], [4911, 4911, 4954, 4954, 5166], [5168, 5168, 5196, 5196, 5407], [5409, 5409, 5463, 5463, 5709], [5711, 5711, 5768, 5768, 8264]], "test": "error"}
{"id": "MdsSRM", "name": "Moiré", "author": "FabriceNeyret2", "description": "A: anti aliasing       C: toggles colors                  M: draw mode = max vs sum\nmouse: translate.   Z: mouse.y zoom instead.     S: mouse.x tunes wires step instead.", "tags": ["moire"], "likes": 4, "viewed": 1416, "published": "Public API", "date": "1398602818", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define PI 3.14159265359\n\nbool COMB;\nbool ANTI_A;\nfloat STEP;\n\nfloat zoom;\n\nbool keyToggle(int ascii) {\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\n}\n\nfloat fwidth2(float k) { vec2 dk = vec2(dFdx(k),dFdy(k)); return length(dk); }\n\nfloat Icos(float k, float S) { // cos with or without antialiasing\n\tfloat dk = 1.;\n\tif (ANTI_A) { // antialiasing: return 1/dk . int( cos(k), k= -dk/2..dk/2 )\n\t\tdk = fwidth(k);\n\t\tif (dk>0.) dk = 2.*sin(dk/2.)/dk ;\n\t\tdk *= 1./S; // *zoom; // scaling should not change intensity\n\t}\n\treturn cos(k)*dk;\n\t\n}\nfloat rosace(float s, float z, float L, float S, float T, bool clip) { \n\ts = S*(s-T); z = S*(z-T); // translation and scaling\n\tif (clip && ( (z<=0.) || (z>L) || (s-z<0.) || (s-z>L) )) return 0.;\n\t// canonical:  s = x+y,  z = x\n\t// <x,y> - <0,k> = <k,L> - <0,k> \n\t// => x.(L-k)=k.(y-k) => k2 -k.s + zL = 0 => D = s2-4zL\n\tfloat d = 1.-4.*z*L/(s*s); if (d<0.) return 0.;\n\n\td = sqrt(d);\n\tfloat k1 = s*(1.+d)/2., k2 = s*(1.-d)/2.;\n\t\n#if 1\n\tfloat s1 = Icos(PI*k1/STEP,S) , s2 = Icos(PI*k2/STEP,S);\n#else\n\tfloat s1 = (clip && ( (k1<0.)||(k1>L) )) ? 0. : Icos(PI*k1/STEP,S),\n\t\t  s2 = (clip && ( (k2<0.)||(k2>L) )) ? 0. : Icos(PI*k2/STEP,S);\t\n#endif\n\n\treturn .5+.5* ( (COMB) ? max(s1,s2) : (s1+s2) );\n}\n\nvec2 tile1(vec2 uv, float L, float S) {\n\tS=1.;\n\tfloat r,g, s = uv.x+uv.y, S2=S*2.,T=L/2.;\n\tr   = rosace(s, uv.x,  L,S,0., true)   + rosace(s, uv.y,  L,S,0., true);\n\tr  += rosace(s, uv.x,  L,S2,T, true) + rosace(s, uv.y,  L,S2,T, true);\n\t\n\tuv.x = L-uv.x; s = uv.x+uv.y;\n\tg  = rosace(s, uv.x,  L,S,0., true)   + rosace(s, uv.y,  L,S,0., true);\n\tg += rosace(s, uv.x,  L,S2,T, true) + rosace(s, uv.y,  L,S2,T, true);\n\n\treturn vec2(r,g);\n}\n\nvec2 tile2(vec2 uv, float L, float S) {\n\tS=1.;\n\tfloat r,g, s = uv.x+uv.y, S2=S*2.,T=L/2.;\n\tr  = rosace(s, uv.x,  L,S2,T, true) + rosace(s, uv.y,  L,S2,T, true);\n\tr += rosace(s, mod(uv.x+L/2.,L),  L,S2,T, true) + rosace(s, mod(uv.y+L/2.,L),  L,S2,T, true);\n\n\tuv.x = L-uv.x; s = uv.x+uv.y;\n\tg  = rosace(s, uv.x,  L,S2,T, true) + rosace(s, uv.y,  L,S2,T, true);\n\tg += rosace(s, mod(uv.x+L/2.,L),  L,S2,T, true) + rosace(s, mod(uv.y+L/2.,L),  L,S2,T, true);\n\n\treturn vec2(r,g);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t = 10.*iTime;\n    float L = iResolution.y;\n\tvec2 uv = fragCoord.xy-.5-iResolution.xy/2.;\n\tvec2 trans = vec2(0.);\n\t\n\t// --- tuning\n\t\n\tvec4 mouse = abs((iMouse-.5)/iResolution.y);\n\tif (iMouse.z<=0.) {\n\t\tzoom = 1.+10.*(1.-cos(.02*t))/2.;\n\t\tSTEP = 1.+50.*(1.-cos(.1*t))/2.;\n\t\tANTI_A = true;\n\t\tCOMB = ( mod(.02*t/(2.*PI),1.) > .5 );  \n\t\ttrans = .5+iResolution.xy/2.*(1.+vec2(cos(.02*t),sin(.03*t))/(1.+zoom));\n\t}\n\telse\n\t{\n\t\tANTI_A = !keyToggle(65);\n\t\tCOMB   = (! keyToggle(64+13)); // 'M'\n\t\n\t\ttrans = iMouse.xy;\n\t\tif (!keyToggle(64+26)) { zoom=mouse.y*10.; trans.y=iMouse.w; } \n\t\telse \t\t\t\t\t zoom = mouse.w*10.;\n\t\tif (keyToggle(64+19)) { STEP = mouse.x*100.; trans.x=abs(iMouse.z); }\n\t\telse\t\t\t\t    STEP = 4.; // mouse.z*100.;\n\t}\n\t\n\tuv -= 10.*(trans-.5-iResolution.xy/2.);\n\tuv *= zoom;\n\t\n\t// --- display \n\t\n\tvec3 col = vec3(0.); \n\tcol.rg = tile1(mod(uv,L),L,zoom);\n\n\tfragColor = (!keyToggle(67)) ? vec4(col.r+col.g) : vec4(col.r,col.g,0.,1.);\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdsSRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 77, 104, 104, 177], [179, 179, 203, 203, 257], [259, 259, 289, 325, 561], [562, 562, 632, 632, 1255], [1257, 1257, 1296, 1296, 1691], [1693, 1693, 1732, 1732, 2168], [2170, 2170, 2227, 2227, 3173]], "test": "error"}
{"id": "MdXXz4", "name": "Morphing light blobs", "author": "matrefeytontias", "description": "Simple morphing light blobs shader, based on distance calculation.", "tags": ["2d", "blobs", "distance"], "likes": 1, "viewed": 206, "published": "Public", "date": "1397385329", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 blob1 = vec3(cos(iTime) * 0.5 + 0.5, sin(iTime) * 0.5 +0.5, 2.),\n\t\tblob2 = vec3(sin(iTime) * 0.3 + 0.5, cos(iTime) * 0.2 + 0.2, 2.5),\n\t\tblob3 = vec3(cos(iTime) * 0.4 + 0.5, cos(iTime) * 0.3 + 0.6, 3.0);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\t// multiplies the distances to the blobs together\n\tfloat shade = distance(uv, blob1.xy) * blob1.z;\n\t\n\tfloat shade1 = distance(uv, blob2.xy) * blob2.z;\n\tshade *= shade1;\n\t\n\tfloat shade2 = distance(uv, blob3.xy) * blob3.z;\n\tshade *= shade2;\n\t\n\tshade = 1.0 - abs(shade);\n\t\n\t// make it shine\n\tfragColor = vec4(shade * (cos(iTime) * 0.25 + 0.75),\n\t\t\t\t\t\tshade * (sin(iTime) * 0.25 + 0.75),\n\t\t\t\t\t\tshade * (cos(iTime) * 0.5 + 0.5), 1.0);\n}\n", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdXXz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 743]], "test": "ok"}
{"id": "MsB3Wt", "name": "streaming video", "author": "ryk", "description": "Watch to the end! Hilarious!\n", "tags": ["2d", "video", "throbber", "streaming"], "likes": 14, "viewed": 473, "published": "Public", "date": "1396442057", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ANGLE 360./8.\n#define R_THROB 20.\n#define R_DOT 6.\n#define PI 3.14159265359\n#define PLAY_H 8.\n#define PAUSE_DIV 2.\n#define BAR_H 30.\n#define STRIP_L BAR_H/2. - 3.\n#define STRIP_H BAR_H/2. + 3.\n#define STRIP_R_M 35.\n#define STRIP_L_M 60.\n#define CIRCLE_RAD 7.\n#define VOLUME -15.\n#define UI_SHADE 0.7\n\nvoid volume(vec2 pos, inout vec3 col)\n{\n\tpos -= vec2(iResolution.x-5., BAR_H/2.-PLAY_H);\n\tvec3 col_vol = pos.x < VOLUME ? vec3(UI_SHADE) : vec3(0.4);\n\tfloat l = step(0.,pos.y)\n\t\t*(1.-step(0.,pos.x))\n\t\t*(1.-smoothstep(0.,1.,pos.y-pos.x/2.5-PLAY_H*2.));\n\tcol = mix(col, col_vol, l);\n}\n\nvoid circle(vec2 pos, inout vec3 col)\n{\n\tfloat l = length(pos-vec2(clamp(iMouse.x, STRIP_R_M, iResolution.x-STRIP_L_M), BAR_H/2.));\n\tcol = mix(vec3(UI_SHADE), col, smoothstep(CIRCLE_RAD, CIRCLE_RAD+1., l));\n}\n\nvoid strip(vec2 pos, inout vec3 col)\n{\n\tfloat l = smoothstep(STRIP_L-2., STRIP_L+2., pos.y)\n\t\t* (1.-smoothstep(STRIP_H-.2,STRIP_H+2., pos.y))\n\t\t* step(STRIP_R_M ,pos.x)\n\t\t* (1.-step(iResolution.x-STRIP_L_M, pos.x));\n\tvec3 col_strip = pos.x < iMouse.x ? vec3(1.,0.,0.) : vec3(0.);\n\tcol = mix(col,col_strip,l);\n}\n\nvoid bar(vec2 pos, inout vec3 col)\n{\n\tif (pos.y < BAR_H)\n\t{\n\t\tcol = vec3(.3);\n\t}\n}\n\nvoid gradient(vec2 pos, inout vec3 col)\n{\n\tif (pos.y < BAR_H)\n\t{\n\t\tcol *= 1. - pos.y/150.;\n\t}\n}\n\nvoid play(vec2 pos, inout vec3 col)\n{\n\tpos -= vec2(10.,BAR_H/2.);\n\tfloat l = smoothstep(0., 1., pos.x)*smoothstep(0.,1.5,PLAY_H-abs(pos.y)-pos.x/1.5);\n\t\n\tcol = mix(col,vec3(UI_SHADE),l);\n}\n\nvoid pause(vec2 pos, inout vec3 col)\n{\n\tpos -= vec2(BAR_H/2.,BAR_H/2.);\n\tfloat l = step(-PLAY_H, pos.x)\n\t\t*(1.-step(PLAY_H, pos.x))\n\t\t*step(-PLAY_H, pos.y)\n\t\t*(1.-step(PLAY_H, pos.y));\n\tl*=(1.-step(-PAUSE_DIV, pos.x)\n\t\t*(1.-step(PAUSE_DIV, pos.x)));\n\tcol = mix(col,vec3(UI_SHADE),l);\n}\n\nvec3 throbber(vec2 pos)\n{\n\tvec3 col = vec3(.0);\n\tvec2 pol = vec2(length(pos), -atan(pos.y, pos.x)*180./PI);\n\tfloat ang = (mod(pol.y+ANGLE/2., ANGLE)-ANGLE/2.)*PI/180.;\n\tfloat index = pol.y*PI/180. - ang;\n\tindex -= iTime*10.;\n\tindex = mod(index,2.*PI);\n\tpos = pol.x*vec2(cos(ang), sin(ang));\n\tcol = vec3(index)/2./PI * (1.-smoothstep(R_DOT-1.,R_DOT,length(pos - vec2(R_THROB,0.))));\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pos = fragCoord.xy;\n\tvec2 mid = iResolution.xy/2.;\n\tvec3 col = throbber(pos-mid-vec2(0.,BAR_H/2.));\n\tbar(pos, col);\n\t//play(pos, col);\n\tpause(pos, col);\n\tstrip(pos, col);\n\tcircle(pos, col);\n\tvolume(pos, col);\n\tgradient(pos, col);\n\tfragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsB3Wt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[309, 309, 348, 348, 591], [593, 593, 632, 632, 801], [803, 803, 841, 841, 1113], [1115, 1115, 1151, 1151, 1197], [1199, 1199, 1240, 1240, 1294], [1296, 1296, 1333, 1333, 1484], [1486, 1486, 1524, 1524, 1771], [1773, 1773, 1798, 1798, 2169], [2171, 2171, 2228, 2228, 2494]], "test": "ok"}
{"id": "MsfXzM", "name": "Gabor3", "author": "FabriceNeyret2", "description": "mouse: freq and dir of Gabor.\nA: mouse.y tunes angular spread instead.\nT: mouse.x tunes gaussian thickness instead.\nRed: Fourier representation of the Gabor function.\nCyan: Signal representation of the Gabor function.", "tags": ["gabor"], "likes": 15, "viewed": 2014, "published": "Public API", "date": "1398340227", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// inspired from https://www.shadertoy.com/view/MdjGWy#\n\n\n// for faster eval, you can decrease proportionnaly NB and GAUSS_F to keep coverage\nfloat GAUSS_F = .1;    // size of gabor blobs\n#define NB 100.        // number or gabor blobs\n\n#define SCALE 30.      // SCALING FACTOR for superimposing signal and fourier spaces\n\n#define PI 3.14159265358979\n\n// --- key toggles -----------------------------------------------------\n\nbool keyToggle(int ascii) {\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\n}\n\n\n// --- util math func  -----------------------------------------------------\n\n#if 0  // 1: texture-based noise  0: function-based noise\nfloat rnd(vec2 uv, int z) \n{\n\tif      (z==0) return texture(iChannel1,uv).r;\n\telse if (z==1) return texture(iChannel1,uv).g;\n\telse if (z==2) return texture(iChannel1,uv).b;\n\telse           return texture(iChannel1,uv).a;\n}\nfloat rndi(float i, float j)\n{\n\tvec2 uv = vec2(.5+i,.5+j)/ iChannelResolution[1].x;\n\treturn texture(iChannel1,uv).r;\n}\n#else\nfloat rndi(float i, float j)\n{\n\treturn fract(sin(i+9876.*j)*12345.678);\n}\n#endif\n\nfloat gauss(float x, float s) {\n    return exp(-.5*(x*x)/(s*s)); \n}\nfloat gauss(float x) {\n    return exp(-.5*x*x); \n}\nfloat gauss(float s,vec2 D) {\n\tfloat d = dot(D,D)/(s*s);\n\treturn exp(-.5*d); \n}\n\n#define SQR(x) ((x)*(x))\n\nfloat gabor(vec2 pos, vec2 k, float gaussF, float phi) {\n\tfloat g = gauss(length(pos), 1./gaussF);\n    float s = .5*sin(2.*PI*dot(pos,k) - phi);\n\treturn g*s;\n}\n\n// -----------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.*(fragCoord.xy / iResolution.y - vec2(.85,.5));\n\n\t// --- tuning \n\t\n\tvec4 mouse; \n\tmouse.xy = 2.*(iMouse.xy/  iResolution.y - vec2(.85,.5));\n\tmouse.zw = 2.*(abs(iMouse.zw)/  iResolution.y - vec2(.85,.5));\n\tif (iMouse.x+iMouse.y==0.) mouse = vec4(.5);\n\tvec3 col;\n\tfloat vS=0.,vF=0.,A=0.;\n\t\n\tvec2 k = mouse.xy; // wave number\n\t\n\tif (!keyToggle(65)) { // tune angular spread\n\t\tA = PI/2.* .5*(1.+mouse.y);\n\t\tk.y = mouse.w;\n\t}\n\tif (keyToggle(84)) { // tune angular spread\n\t\tGAUSS_F *= 4.*iMouse.x/iResolution.x;\n\t\tk.x = abs(mouse.z);\n\t}\n\t\n\t\n\t// --- display\n\t\n\tvec2 k_ortho = vec2(-k.y,k.x);\n\t\n\t// in Fourier space, Gabor = Gauss(s)*F(sin) = 2 Gaussians at k and -k\n\t// in signal space, Gabor = Gauss(1/s).sin(kx)  * white\n\n\tfor (float i=0.; i<NB; i++) { \n\t\t\n\t\t// random sample within angular spread\n\t\tfloat a = A*(2.*i/NB-1.);\n\t\tvec2 Rk = cos(a)*k + sin(a)*k_ortho;\n\n\t\t// signal space:  white := Poisson point distrib -> sum random pos\n\t\tvec2 pos =2.*vec2(1.5*rndi(i,0.),rndi(i,1.))-1.;\t\t\n\t\tvS += gabor(SCALE*(uv-pos), Rk, GAUSS_F, 10.*iTime +float(i));\n\t\t// Fourier: (dirac+ + dirac-)*gauss\n\t\tvF += \t\t gauss(    GAUSS_F,uv-Rk) + gauss(    GAUSS_F,uv+Rk)\n\t\t\t - 10.*( gauss(.02*GAUSS_F,uv-Rk) + gauss(.02*GAUSS_F,uv+Rk) );\n\t}\n\t\n\tvF *= max(1., length(k)*2.*A/(PI*GAUSS_F)) /float(NB); // normalization\n\tvS = (1.-vF)*(vS*sqrt(3.*GAUSS_F)+1.)/2.;\n\n\tfragColor = vec4(vF,vS,vS,1.);\n}\n                  \n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsfXzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[426, 426, 453, 453, 526], [1095, 1095, 1126, 1126, 1162], [1163, 1163, 1185, 1185, 1213], [1214, 1214, 1243, 1243, 1293], [1321, 1321, 1377, 1377, 1480], [1540, 1540, 1597, 1597, 2985]], "test": "error"}
{"id": "MslXz8", "name": "Iterations - shiny", "author": "iq", "description": "The sixth variation of the \"Iterations\" shader. Orbit trapping for non linear operator applied repeatedly", "tags": ["procedural", "2d"], "likes": 65, "viewed": 5583, "published": "Public API", "date": "1396923387", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\t\t\t\t\t\t    \n\n\n// Other \"Iterations\" shaders:\n//\n// \"trigonometric\"   : https://www.shadertoy.com/view/Mdl3RH\n// \"trigonometric 2\" : https://www.shadertoy.com/view/Wss3zB\n// \"circles\"         : https://www.shadertoy.com/view/MdVGWR\n// \"coral\"           : https://www.shadertoy.com/view/4sXGDN\n// \"guts\"            : https://www.shadertoy.com/view/MssGW4\n// \"inversion\"       : https://www.shadertoy.com/view/XdXGDS\n// \"inversion 2\"     : https://www.shadertoy.com/view/4t3SzN\n// \"shiny\"           : https://www.shadertoy.com/view/MslXz8\n// \"worms\"           : https://www.shadertoy.com/view/ldl3W4\n// \"stripes\"         : https://www.shadertoy.com/view/wlsfRn\n\n\nvec3 shape( in vec2 p )\n{\n\tp *= 2.0;\n\t\n\tvec3 s = vec3( 0.0 );\n\tvec2 z = p;\n\tfor( int i=0; i<8; i++ ) \n\t{\n        // transform\t\t\n\t\tz += cos(z.yx + cos(z.yx + cos(z.yx+0.5*iTime) ) );\n\n        // orbit traps\t\t\n\t\tfloat d = dot( z-p, z-p ); \n\t\ts.x += 1.0/(1.0+d);\n\t\ts.y += d;\n\t\ts.z += sin(atan(z.y-p.y,z.x-p.x));\n\t\t\n\t}\n\t\n\treturn s / 8.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 pc = (2.0*fragCoord.xy-iResolution.xy)/min(iResolution.y,iResolution.x);\n\n\tvec2 pa = pc + vec2(0.04,0.0);\n\tvec2 pb = pc + vec2(0.0,0.04);\n\t\n    // shape (3 times for diferentials)\t\n\tvec3 sc = shape( pc );\n\tvec3 sa = shape( pa );\n\tvec3 sb = shape( pb );\n\n    // color\t\n\tvec3 col = mix( vec3(0.08,0.02,0.15), vec3(0.6,1.1,1.6), sc.x );\n\tcol = mix( col, col.zxy, smoothstep(-0.5,0.5,cos(0.5*iTime)) );\n\tcol *= 0.15*sc.y;\n\tcol += 0.4*abs(sc.z) - 0.1;\n\n    // light\t\n\tvec3 nor = normalize( vec3( sa.x-sc.x, 0.01, sb.x-sc.x ) );\n\tfloat dif = clamp(0.5 + 0.5*dot( nor,vec3(0.5773) ),0.0,1.0);\n\tcol *= 1.0 + 0.7*dif*col;\n\tcol += 0.3 * pow(nor.y,128.0);\n\n    // vignetting\t\n\tcol *= 1.0 - 0.1*length(pc);\n\t\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MslXz8.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[782, 782, 807, 807, 1117], [1119, 1119, 1177, 1177, 1913]], "test": "ok"}
{"id": "MssXz4", "name": "Spiky", "author": "u2Bleank", "description": "Old school spiky ball effect.\ndevelopped on my lapop at 0.5fps at the Revision 2014.\nThe live battle coding session has rised my motivation to start something with shader toy\nUsed a lot of template/code from other shaders.", "tags": ["balls", "rotation", "spikes"], "likes": 34, "viewed": 1972, "published": "Public", "date": "1397944572", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// u2 : developped on my lapop at 2fps at the Revision 2014.\n//\t\tthe live coding session has rised my motivation to start something with shader toy\n//\t\tUsed a lot of template/code from other shaders.\n//\t\tOld school spiky ball effect.\n\n\n// Set up a camera looking at the scene.\n// origin - camera is positioned relative to, and looking at, this point\n// distance - how far camera is from origin\n// rotation - about x & y axes, by left-hand screw rule, relative to camera looking along +z\n// zoom - the relative length of the lens\nvoid CamPolar( out vec3 pos, out vec3 ray, in vec3 origin, in vec2 rotation, in float distance, in float zoom, vec2 fragCoord)\n{\n\t// get rotation coefficients\n\tvec2 c = vec2(cos(rotation.x),cos(rotation.y));\n\tvec4 s;\n\ts.xy = vec2(sin(rotation.x),sin(rotation.y)); // worth testing if this is faster as sin or sqrt(1.0-cos);\n\ts.zw = -s.xy;\n\n\t// ray in view space\n\tray.xy = fragCoord.xy - iResolution.xy*.5;\n\tray.z = iResolution.y*zoom;\n\tray = normalize(ray);\n//\tlocalRay = ray;\n\t\n\t// rotate ray\n\tray.yz = ray.yz*c.xx + ray.zy*s.zx;\n\tray.xz = ray.xz*c.yy + ray.zx*s.yw;\n\t\n\t// position camera\n\tpos = origin - distance*vec3(c.x*s.y,s.z,c.x*c.y);\n}\n\n// return the distance to a sphere\nfloat Psphere( vec3 p, vec3 c, float r )\n{\n\treturn length(p-c)-r;\n}\n\nfloat Pcapsule( vec3 p, vec3 a, vec3 b, float rmin, float rmax )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\tvec3 norm = normalize( b - a );\n\tfloat d = -dot( norm, a );\n\tfloat dist = dot( norm, p ) + d ;\n\t\n\tfloat rf = dist / length( b-a );\n\t\n\tfloat r = mix( rmin, rmax, rf*rf*rf );\n\t\t\n    return length( pa - ba*h ) - r;\n}\n\n// polynomial smooth min (k = 0.1);\nfloat blendPrim( float a, float b  )\n{\n\tfloat k=0.32 ;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n//\treturn min( a, b );\n}\n\n// Convert a vector into 2 Auler angle\nvec2 ToEuler( vec3 p )\n{\n\treturn vec2( atan( p.z, p.x  ),\n\t\t\t     atan( sqrt(p.x*p.x+p.z*p.z), p.y)) ;\n//\treturn vec2( atan( p.x, p.z ),\n//\t\t\t     atan( p.y, sqrt(p.x*p.x+p.z*p.z) )) ;\n}\n\nvec3 FromEuler( vec2 e )\n{\n\tfloat c = sin(e.y);\n\treturn vec3( c * cos(e.x),\n\t\t\t \t cos(e.y),\n\t\t\t \t c * sin(e.x)\t\t);\n}\n\nfloat nbSpikes = 16. ;\nfloat PI = 3.141592653 ;\nvec3 ClassifyDir( vec3 p, out float id )\n{\n\tvec2 angle = ToEuler( p )  ;\t\n\t\n\tfloat div = 2.*PI / nbSpikes\t;\n\t\n\tangle /= div ;\n\tangle = floor(angle);\n\tid = angle.x+angle.y ;\n\tangle = angle*div;\n\tangle += div*0.5 ;\n\t\n\treturn FromEuler(angle);\n//\treturn normalize(p) ;\n//\tif( p.y > 0. )\n//\t\treturn vec3(0.,1.,0.);\n//\telse\n//\t\treturn vec3(0.,-1.,0.);\n}\n\nfloat Pcapsule1( vec3 p, vec3 dir, float dist, float thickmin, float thickmax )\n{\n\treturn \tPcapsule( p, dir*1., dir*(dist-3.), thickmin, thickmax );\n}\n\nvec4 QuatFromAxisAngle( vec3 axis, float angle )\n{\n\tfloat theta = 0.5 * angle\t;\n\tfloat sine = sin(theta)\t\t\t;\n\treturn vec4( cos(theta),\n\t\t\t\t axis.x * sine,\n\t\t\t\t axis.y * sine,\n\t\t\t\t axis.z * sine );\n}\n\nvec3 TransformVecQuat( vec3 v, vec4 q )\n{\n\tvec3 t = 2. * cross(q.xyz, v);\n\treturn v + q.w * t + cross(q.xyz, t);\n}\n\nvec4 PlaneFromNormPos( vec3 n, vec3 p )\n{\n\treturn vec4( n.x, n.y, n.z, \n\t\t\t\t - dot( n, p ) );\n}\n\nfloat Pplane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n// Compute the Spiky object\nfloat Spiky( vec3 p )\n{\n\t// transform input position*\n\tvec4 q = QuatFromAxisAngle( normalize( vec3(cos(iTime*0.7),1,0) ), iTime*1.5 - 0.35*length(p) );\n\tp = TransformVecQuat( p, q );\n\t\t\n\t\n\t// Spiky !\t\n\tfloat id ;\n//\tfloat p0 = Pcapsule( p, vec3(0,1,0), vec3(0,5,0), 0.05 );\n\tvec3 d = ClassifyDir(p,id);\n\tvec3 infos = vec3( 10., 0.3, 0.02 );\n/*\tfloat modc = mod(id,4. ) ;\n\tif( modc < 1. )\n\t\tinfos = vec3( 11., 0.2, 0.04 );\n\telse if( modc < 2. )\n\t\tinfos = vec3( 9., 0.4, 0.035 );\n\telse if( modc < 3. )\n\t\tinfos = vec3( 8., 0.1, 0.055 );*/\n\tfloat p0 = Pcapsule1( p, d, infos.x, infos.y, infos.z );\n\tfloat p1 = Psphere( p, vec3(0,0,0), 2.5 );\n\t\n\treturn blendPrim( p0, p1 );\t// blend primitives\t\n//\treturn p1;\t// blend primitives\t\n}\n\nfloat PlaneY = -7. ;\n\n// return the distance to the scene\nfloat Scene( vec3 p )\n{\n\tfloat s  = Spiky( p ) ;\n\t\n\t// Floor and background\n\tvec4 floorp = PlaneFromNormPos( vec3(0.,1.,0.), vec3(0.,PlaneY,0.) );\n\tfloat f = Pplane( p, floorp );\n\t\n\treturn min( s, f );\n//\treturn f ;\n//\treturn p1 ;\t// blend primitives\n}\n\n\nvec3 calcNormal( in vec3 p, out float valid )\n{\n\n\tvec3 e = vec3(0.001,0.0,0.0);\n\tvec3 norm = vec3(Scene(p+e.xyy) - Scene(p-e.xyy),\n\t\t\t\t\t\t   Scene(p+e.yxy) - Scene(p-e.yxy),\n\t\t\t\t\t\t   Scene(p+e.yyx) - Scene(p-e.yyx) );\n\tfloat l = length( norm );\n//\tif( l > 0.0015 && l < 1000. )\n//\t{\n\t\tvalid = 1. ;\n\t\tnorm /= l ;\n//\t}\n//\telse\n//\t{\n//\t\tvalid = 0. ;\n//\t}\n\treturn norm ;\t\t   \n}\n\nfloat calcAOSpiky( in vec3 pos, in vec3 nor )\n{\n    float ao = 1.0;\n    float totao = 0.0;\n    float sca = 15.0;\n    for( int aoi=0; aoi<5; aoi++ )\n    {\n        float hr = 0.002 + 0.04*float(aoi*aoi);\n        vec3 aopos =  nor * hr + pos;\n        float dd = Spiky( aopos );\n        totao += -(dd-hr)*sca;\n        sca *= 0.5;\n    }\n    return 1.0 - clamp( totao, 0.0, 1.0 );\n}\n\n// compute soft shadow from Spiky object\nfloat softShadowSpiky( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k )\n{\n\tfloat res = 1.0;\n    float dt = 0.02;\n    float t = mint;\n    for( int i=0; i<32; i++ )\n    {\n\t\tif( t<maxt )\n\t\t{\n        float h = Spiky( ro + rd*t );\n        res = min( res, k*h/t );\n        t += max( 0.05, dt );\n\t\t}\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat TraceSpiky( vec3 vpos, vec3 vdir )\n{\t\n\tfloat tmax = 80.0;\n\tfloat dist = 1.0;\n\tfloat t = 0.0;\n\tfor( int i=0; i < 30; i++ )\n\t{\n\t\tif( dist<0.01 || dist>tmax ) \n\t\t\tbreak;\n\t\t\n\t\tvec3 p = vpos + t*vdir;\n\t\tdist = Spiky( p );\t\n\t\t\n\t\tt += dist ;\n\t}\n\t\n\treturn t ;\n}\n\nfloat TraceFloor( vec3 vpos, vec3 vdir, vec3 viewDir )\n{\n\tfloat tmax = 80.0;\n\tfloat dist = 1.0;\n\tfloat t = 0.0;\n\tfor( int i=0; i < 30; i++ )\n\t{\n\t\tif( dist<0.01 || dist>tmax ) \n\t\t\tbreak;\n\t\t\n\t\tvec3 p = vpos + t*vdir;\n\t\t\n\t\tvec4 floorp = PlaneFromNormPos( vec3(0.,1.,0.), vec3(0.,PlaneY,0.) );\n\t\tdist = Pplane( p, floorp );\t\n\t\n//\t\tdist = min( dist, dot( p, -viewDir )-60. );\n\t\t\n\t\tt += dist ;\n\t}\t\n\t\n\treturn t ;\n}\n\n// main light\nvec3 lightDir = vec3( 1, -0.8, 0.5 );\nvec3 lightCol = vec3( 0.9, 0.9, 0.9 );\n\n// pseudo sss color\nvec3 sssCol = 2.*vec3( 0.12, 0.1, 0.07 );\n\n\n// fog\nvec3 fogCol = vec3(1.,1.,1.);\nfloat fogCutIn = 20. ;\nfloat fogPower = 0.04 ;\n\n\nfloat ComputeFog( vec3 pos, vec3 vpos )\n{\n\t// fog\n\tfloat lfog = length(pos-vpos) - fogCutIn ; // start the fog a much further from the camera\n\treturn exp( -fogPower*lfog );\t\n}\n\nvec3 ShadeSpiky( vec3 pos, vec3 vpos, vec3 vdir, vec3 viewDir )\n{\n\tfloat validNorm = 0.;\n\tvec3 nor = calcNormal( pos, validNorm );\n//\t\tvec3 nor = ClassifyDir( pos );\n\t\t\n\tlightDir = normalize( lightDir );\n\tfloat l0i = clamp( -dot( nor, lightDir ), 0., 1. );\n\tfloat l0Sh = 1. ;\n\tif( l0i >0.02 )\n\t\tl0Sh = softShadowSpiky( pos, -lightDir, 5., 40., 3. );\n\tvec3 l0 = l0i * l0Sh * lightCol; \n\t\t\n\t\t\n\tvec3 lightDir1 = vec3( -1, 1, 0 );\n\tvec3 lightCol1 = 0.5*vec3( 0.22, 0.2, -0.17 );\n\t\t\n\tvec3 lightDir2 = normalize( viewDir + vec3(0.5,0.1,0.) );\n\tvec3 lightCol2 = 0.5*vec3( 0.12, 0.12, 0.2 );\n\t\t\t\t\n\tfloat sshCoef = 1.-clamp( -dot( nor, viewDir ), 0., 1. );\n\tsshCoef = pow( sshCoef, 1. );\n\t\t\t\n\t// va calculer l'ambient occlusion\n\tfloat ao = 1.-calcAOSpiky( pos, nor );\n\t\t\n\tvec3 l1 = clamp( -dot( nor, lightDir1 ) * lightCol1, 0., 1. );\n\tvec3 l2 = clamp( -dot( nor, lightDir2 ) * lightCol2, 0., 1. );\n\t\t\n\n\tvec3 col = mix( l0+l1, l2, ao ) ;\t\n\tcol += sshCoef * sssCol * validNorm ;\n\n\t// apply fog\n\tfloat fi =  ComputeFog( pos, vpos );\n\tcol = mix( fogCol, col, fi );\t\n\t\n\treturn col;\n}\n\nvec3 ShadeFloor( vec3 pos, vec3 vpos, vec3 vdir )\n{\n\tfloat aoSh = calcAOSpiky( pos, vec3(0.,1.,0.) );\n\tfloat l0Sh = softShadowSpiky( pos, -lightDir, 4., 10., 3.5 );\n\tl0Sh *= aoSh;\n\n\tvec3 col = mix( vec3(0.85), 0.5*sssCol, 0.4*(1.-l0Sh) ) ;\n\t\n\t// compute reflection :\n\tvec3 rdir = reflect( vdir, vec3(0,1,0) );\n\tfloat ts = TraceSpiky( pos, rdir );\n\tif( ts < 20. )\n\t{\n\t\tvec3 hpos = pos+rdir*ts ;\n\t\tfloat attY = exp( -0.2*max(hpos.y+8.,0.) );\n\t\tcol = mix( col, ShadeSpiky( hpos, vpos, rdir, vdir ), attY );\n\t}\n\t\t\n\t\n\t// apply fog\n\tfloat fi =  ComputeFog( pos, vpos );\n\tcol = mix( fogCol, col, fi );\t\t\n\t\n\treturn col ;\n//\treturn vec3(length( vpos-pos)/120.1);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 camRot = vec2(0.4,2.6)+vec2(-2.5,8.5)*(iMouse.yx/iResolution.yx) ;\n\tcamRot.x = max( camRot.x, 0. );\n\tvec3 vpos, vdir;\n\tvec3 targetPos = vec3(0.,0.,0.);\n\tCamPolar( vpos, vdir, targetPos, camRot, 25.0 + 5.*cos(iTime*0.1), 1.5, fragCoord);\n\tvec3 viewDir = normalize( targetPos - vpos );\n\t\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\tvec2 p = -1.0 + 2.0*uv;\n\tp.x *= iResolution.x/iResolution.y;\n\n\t\n\tfloat ts = TraceSpiky( vpos, vdir );\n\tfloat tf = TraceFloor( vpos, vdir, viewDir );\n\t\n\tvec3 col ; \n\tif( ts < tf )\n\t\tcol = ShadeSpiky( vpos+vdir*ts, vpos, vdir, viewDir );\n\telse\n\t\tcol = ShadeFloor( vpos+vdir*tf, vpos, vdir );\n\t\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MssXz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[236, 529, 657, 687, 1172], [1174, 1209, 1251, 1251, 1276], [1278, 1278, 1344, 1344, 1648], [1650, 1686, 1724, 1724, 1856], [1858, 1897, 1921, 1921, 2083], [2085, 2085, 2111, 2111, 2201], [2251, 2251, 2293, 2293, 2599], [2601, 2601, 2682, 2682, 2751], [2753, 2753, 2803, 2803, 2951], [2953, 2953, 2994, 2994, 3067], [3069, 3069, 3110, 3110, 3164], [3166, 3166, 3198, 3224, 3255], [3257, 3285, 3308, 3338, 4011], [4035, 4071, 4094, 4094, 4323], [4326, 4326, 4373, 4373, 4698], [4700, 4700, 4747, 4747, 5076], [5078, 5119, 5210, 5210, 5472], [5474, 5474, 5516, 5516, 5733], [5735, 5735, 5791, 5791, 6142], [6386, 6386, 6427, 6435, 6561], [6563, 6563, 6628, 6628, 7633], [7635, 7635, 7686, 7686, 8290], [8294, 8294, 8351, 8351, 9011]], "test": "ok"}
{"id": "MsXSzH", "name": "A bad day", "author": "avix", "description": "Everything is fake...", "tags": ["procedural", "3d", "raymarch"], "likes": 27, "viewed": 2360, "published": "Public", "date": "1396633680", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define FARCLIP    55.0\n\n#define MARCHSTEPS 60\n#define SHSTEPS    30\n#define SHPOWER    1.5\n\n#define MAT1       1.0\n\n#define CLD1 iTime*0.35\n#define CLD2 iTime*0.15\n\n/***********************************************/\n\nfloat hash(float n) { \n\treturn fract(sin(n)*43758.5453123); \n}\n\nfloat noise3(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + p.z*113.0;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\n/***********************************************/\nvec2 DE(vec3 p) {\n    vec2 t=vec2( (p.y+4.0-texture(iChannel0,p.xz*0.002).x*5.0- texture(iChannel0,p.xz*0.03).x*0.2 )*0.5, 1.0);\n    \n    float g=p.y+2.4;\n    if (t.x>g) t.x=g;\n    \n    return t;\n}\n\n/***********************************************/\n\nvoid DEcloudsPWR(vec3 p, float t, inout float cpwr) {\n    float c= -p.y-1.0-noise3(p*1.9+CLD1)*0.4;\n    if (c>t) cpwr=c-t;\n}\n\nvec4 DEclouds(vec3 p, vec3 lig) {\n    float c=-p.y-1.0-noise3(p*1.3+CLD1)*0.6;\n        vec4 clr =vec4( mix( vec3(0.1,0.1,0.1), vec3(0.8,0.9,1.0), c*0.5 ), clamp(c,0.0,1.0));\n        float ww=-p.y-1.0-noise3(p*1.5+0.6*lig+CLD2)*0.8;\n\t    float dif =  clamp((clr.w - ww)/0.6, 0.0, 1.0 );\n        vec3 brdf = 0.9+ vec3(0.6, 0.5, 0.4)*dif;  \n\tclr.xyz *= brdf;\n    clr.w*=0.35;\n    clr.xyz*=clr.w;\n    return clr;\n}\n\n/***********************************************/\nvec3 normal(vec3 p) {\n\tvec3 e=vec3(0.01,-0.01,0.0);\n\treturn normalize( vec3(\te.xyy*DE(p+e.xyy).x +\te.yyx*DE(p+e.yyx).x +\te.yxy*DE(p+e.yxy).x +\te.xxx*DE(p+e.xxx).x));\n}\n/***********************************************/\nfloat calcSh( vec3 ro, vec3 rd, float s, float e, float k ) {\n\tfloat res = 1.0;\n    for( int i=0; i<SHSTEPS; i++ ) {\n    \tif( s>e ) break;\n        float h = DE( ro + rd*s ).x;\n        res = min( res, k*h/s );\n    \ts += 0.02*SHPOWER;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n/***********************************************\nvoid rot( inout vec3 p, vec3 r) {\n\tfloat sa=sin(r.y); float sb=sin(r.x); float sc=sin(r.z);\n\tfloat ca=cos(r.y); float cb=cos(r.x); float cc=cos(r.z);\n\tp*=mat3( cb*cc, cc*sa*sb-ca*sc, ca*cc*sb+sa*sc,\tcb*sc, ca*cc+sa*sb*sc, -cc*sa+ca*sb*sc,\t-sb, cb*sa, ca*cb );\n}\n\n/***********************************************/\n#define sun normalize(vec3(-0.4,0.15,1.0))\n\nvec3 sky(vec3 rd){\n    float sa=max(dot(rd,sun),0.0);\n    float v=pow(0.9-max(rd.y+0.1,0.0),12.0);\n    vec3 s=mix(vec3(0.8,0.6,0.3),vec3(0.1,0.1,0.1),v);\n        s=s+vec3(0.7,0.2,0.0)*sa*sa*0.5;\n        s=s+vec3(1.0,2.0,1.0)*min(pow(sa,650.0)*1.5,0.3);\n    return clamp(s,0.0,1.0);\n}\n/***********************************************/\nvec3 fog(vec3 color, vec3 fcolor, float depth, float density){\n\tconst float e = 2.71828182845904523536028747135266249;\n\tfloat f = pow(e, -pow(depth*density, 2.0));\n\treturn mix(fcolor, color, f);\n}\n\n/***********************************************/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\t\n\tvec3 ta = vec3(0.0, 0.0, 0.0);\n\tvec3 ro =vec3(0.0, 1.3, -5.0);\n    vec3 lig=vec3(0.0,1.0,1.0);\n\nta.z+=iTime*2.5;\nro.z+=iTime*2.5;\n\t\n/*\tvec2 mp=iMouse.xy/iResolution.xy;\n\trot(ro,vec3(mp.x,mp.y,0.0));\n\trot(lig,vec3(mp.x,mp.y,0.0));\t*/\n\n\tvec3 cf = normalize( ta - ro );\n    vec3 cr = normalize( cross(cf,vec3(0.0,1.0,0.0) ) );\n    vec3 cu = normalize( cross(cr,cf));\n\tvec3 rd = normalize( p.x*cr + p.y*cu + 2.5*cf );\n\n\tvec4 clds=vec4(0.0);\n\tfloat cpwr=0.0;\n\t\n\t//march terrain ...\n\tvec2 r=vec2(0.0);\t\n\tfloat d=0.0;\n\tvec3 ww;\n\tfor(int i=0; i<MARCHSTEPS; i++) {\n\t\tww=ro+rd*d;\n\t\tr=DE(ww);\n    \tDEcloudsPWR(ww,r.x,cpwr);\n        if( abs(r.x)<0.0 || r.x>FARCLIP ) break;\n        d+=r.x;\n\t}\n    r.x=d;\n    \n    //march clouds ...\n    float t=0.0;\n    for(int i=0; i<MARCHSTEPS; i++) {\n\t\tvec3 p=ro+rd*t;\n\t\tclds+=DEclouds(p,lig)*(1.0 - clds.w);\n\t\tt+=0.6;\n\t}\n\n\t//colors ... \n\t\n    vec3 col=sky(rd);\n\n\tif( r.x<FARCLIP ) {\n            vec3 nor=normal(ww);\n        \tfloat amb= 1.0;\t\t\n        \tfloat dif= clamp(dot(nor, lig), 0.0,1.0);\n        \tfloat bac= clamp(dot(nor,-lig), 0.0,1.0);\n        \tfloat sh= calcSh(ww, lig, 0.01, 2.0, 4.0);\n\n    \t\tif (r.y==MAT1) ww=vec3(1.3)* texture(iChannel1, ww.xz*0.2).xyz;\n    \t    ww *= 0.5*amb + 0.4*dif*sh + 0.05*bac;\n    \t    \n\t\t   //faking sunlight like a big boy here\n    \t   vec3 colf=mix(col*0.8,ww, clamp(abs(nor.z*1.8), 0.0,1.0));     \n    \t   \n           colf = mix( colf, clds.xyz, clamp(cpwr,0.0,1.0) );\n\n           col=fog(colf, col, r.x, 0.03);\n\t} else {\n\t    //clouds top\n\t    ro.z-=iTime*100.0;\n\t    float sd=dot(rd,sun);\n\t    float t = clamp( pow(1.0-0.5*rd.y, 8.0), 0.0,1.0);\n\t    clds=vec4(0.0);\n\t        for (int i=0; i<MARCHSTEPS; i++) {\n                float c = (float(i-MARCHSTEPS)*2.0+3.0-ro.y) / rd.y;\n                vec3 cpos = ro + rd*c;\n                     cpos*=vec3(0.007,0.025,0.0062);\n                float a = smoothstep(0.0, 1.0, noise3( cpos ))*0.8; \n                vec3 lc = mix(vec3( 0.8, 0.8, 0.9 ), vec3( 0.1,0.1,0.1 ), a); \n                a=(1.0-clds.w)*a; \n                clds += vec4(lc*a, a); \n                if (clds.w>0.9) break;\n            }\n            \n            clds.rgb /= clds.w+0.001;\n            col=mix( col, clds.rgb , clds.w*(1.0-t) );            \n\t} \n\n\tfragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsXSzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[217, 217, 238, 238, 279], [281, 281, 303, 303, 705], [707, 757, 774, 774, 954], [1007, 1007, 1060, 1060, 1131], [1133, 1133, 1166, 1166, 1543], [1545, 1595, 1616, 1616, 1762], [1763, 1813, 1874, 1874, 2088], [2496, 2496, 2514, 2514, 2779], [2780, 2830, 2892, 2892, 3026]], "test": "error"}
{"id": "XdfSz8", "name": "Boring Mandelbrot Zoom", "author": "rogerdahl", "description": "Simple zooms into 3 areas of the Mandelbrot set.", "tags": ["mandelbrot", "zoom"], "likes": 0, "viewed": 200, "published": "Public", "date": "1396330638", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tconst float zoom_rate = 1.5;\n\tconst float max_zoom = 25.0; // also time spent in each zoom\n\tconst int bailout = 400;\n\t\n\tint zoom_idx = int(mod(iTime, max_zoom * 3.0) / max_zoom);\n\t\n\t// select zoom target\n\tfloat center_r;\n\tfloat center_i;\n\tif (zoom_idx == 0) {\n\t\tcenter_r = 0.28595756563098457;\n\t\tcenter_i = 0.011516107407704111;\n\t}\n\telse if (zoom_idx == 1) {\n\t\tcenter_r = -0.70024170070240843;\n\t\tcenter_i = -0.26508919693469957;\n\t}\n\telse {\n\t\tcenter_r = -1.1617553883109397;\n\t\tcenter_i = -0.19740616627583873;\n\t}\n\n\tfloat zoom = pow(zoom_rate, mod(iTime, max_zoom));\n\n\tfloat w = float(iResolution.x);\n\tfloat h = float(iResolution.y);\n\n\tfloat pos_x = float(fragCoord.x) / w;\n\tfloat pos_y = float(fragCoord.y) / h;\n\t\n\tfloat cx = center_r + (pos_x - 0.5) / zoom;\n\tfloat cy = center_i + ((pos_y - 0.5) * (h / w)) / zoom;\n\n\tfloat x = 0.0;\n\tfloat y = 0.0;\n\t\n\tint j;\n\tfor (int i = 0; i < bailout; i++)\t{\n\t\tfloat xx = x * x - y * y + cx;\n\t\ty = 2.0 * x * y + cy;\n\t\tx = xx;\n\t\tif (x*x + y*y >= 4.0) {\n  \t\t\tj = i;\n\t\t\tbreak;\n\t\t}\n\t\tj = 0;\n\t}\n\n  \tvec3 col;\n\tfloat c;\n\tif (j == 0) {\n\t\tc = 0.0;\n\t}\n\telse {\n\t\tc = float(j) / float(bailout);\n\t}\n\t\n\tif (zoom_idx == 0) {\n\t\tcol = vec3(3.0 * c, 2.0 * c, 0.0 * c);\n\t}\n\telse if (zoom_idx == 1) {\n\t\tcol = vec3(0.5 * c , 1.5 * c, 1.1 * c);\n\t}\n\telse {\n\t\tcol = vec3(0.0 * c , 2.5 * c, 3.0 * c);\n\t}\n\tfragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdfSz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1405]], "test": "ok"}
{"id": "XdfSzN", "name": "grid spiral", "author": "zugamifk", "description": "woohoo", "tags": ["linearalgebrastuff"], "likes": 2, "viewed": 151, "published": "Public", "date": "1397262344", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = 3.141593;\nconst float cycle = 2.0*pi;\n\nfloat usin(float x) {return 0.5+0.5*sin(x);}\nfloat ucos(float x) {return 0.5+0.5*cos(x);}\nvec3 icol(float r, float g, float b) { return vec3(r/255., g/255., b/255.);}\n\nvec3 spiral(vec2 uv) {\n\tfloat ang = atan(uv.x, uv.y);\t\n\tfloat len = length(uv);\n\tfloat s = iTime;\n\t\n\tvec3 c1 = icol(170.,59.,91.);\n\tvec3 c2 = icol(249.,249.,79.);\n\tvec3 c3 = icol(249.,167.,24.);\n\tvec3 c4 = icol(167.,232.,62.);\n\t\n\tfloat rw = len - len*0.5*usin(s)*ucos(ang*8.0 + s);\n\tfloat r = usin(rw*cycle - s*2.0);\n\t\n\t\n\tfloat g = ucos(len*24.0 - usin(s)*8.0 - s*4.0 + ang);\n\t\n\tfloat b = usin(sin(s)/len*len*8.+ang*8.0 - (ucos(len-pi*s*2.))*8.0);\n\n\tfloat si = mod(s, 4.0);\n\t\n\n\treturn r*c1 + g*c2 + b*c3;\n}\n\nvec3 bg(vec2 uv) {\n\tuv.y = 0.5*(uv.y + 1.0);\n\tvec3 c1\t= icol(230.,181.,52.);\n\tvec3 c2\t= icol(40.,72.,140.);\n\tvec3 c3 = icol(238.,238.,91.);\n\t\n\tfloat i = exp(-2.0*uv.y);\n\t\n\treturn i*c2 + (1.0-i)*c1;\n\t\n}\n\nfloat grid(vec2 uv) {\n\tfloat lin =0.001;\n\tfloat blur = 2.0;\n\tfloat ph = blur/iResolution.y;\n\t\n\tfloat square = 1.0/10.0;\n\t\n\tfloat x = mod(uv.x, square);\n\tif (abs(uv.x) < lin*4.) return 0.;\n\tif ( x < lin) return 0.;\n\tif (x < lin + ph) return x/(ph+lin);\n\t\n\tfloat y = mod(uv.y, square);\n\tif (abs(uv.y) < lin*4.) return 0.;\n\tif ( y < lin) return 0.;\n\tif (y < lin + ph) return y/(ph+lin);\n\t\n\treturn 1.0;\n}\n\nfloat line(vec2 uv, float f) {\n\tfloat wide = 0.02;\n\t\n\tvec3 col = vec3(1.,0.,0.);\n\t\n\tif (abs(f-uv.y) < wide) return 1.;\n\treturn 0.;\n}\n\nfloat vector(vec2 uv, vec2 v, vec2 p) {\n\tuv = uv - p;\n\tfloat d = length(uv - v * dot(uv, v)/dot(v,v));\t\n\tif (d > 0.02 ||\n\t   \tuv.y * v.y < 0. ||\n\t\tuv.x * v.x < 0. ||\n\t   length(uv) > length(v)) return 0.;\n\treturn 1.;\n}\n\nvec2 matrix2(vec2 uv, mat2 m, vec2 p) {\n\treturn vec2(vector(uv, m[0], p), vector(uv, m[1], p));\t\n}\nmat2 rot(float t) {\n\tmat2 r;\n\tr[0] = vec2(sin(t), cos(t));\n\tr[1] = vec2(cos(t), -sin(t));\n\treturn r;\n}\n\nvec2 distort(vec2 uv) {\n\tfloat t = iTime;\n\tvec2 polar = vec2(length(uv), atan(uv.x, uv.y));\n\tfloat th = t;;\n\t\n\tmat2 scale;\n\tfloat s = 4.0;\n\tscale[0] = vec2(s, 0.);\n\tscale[1] = vec2(0., s);\n\treturn scale * uv;\n}\n\nmat2 diag() {\n\tmat2 q, l, qt;\n\tq[0] = vec2(0.96, .28);\n\tq[1] = vec2(.28, .96);\n\n\tl[0] = vec2(5., 2.);\n\tl[1] = vec2(2., 3.);\n\n\tqt[0] = vec2(0.96, .28);\n\tqt[1] = vec2(.28, .96);\n\t\n\treturn q * l * qt;\n}\n\nconst int ev_n = 32;\nvec3 ev(vec2 uv) {\n\tfloat t = iTime;\n\tvec3 cx = vec3(1.,0.,0.);\n\tvec3 ce = vec3(0., 1., 0.);\n\tvec3 cr = vec3(0.);\n\tfloat s = 1./float(ev_n);;\n\tvec2 v;\n\tmat2 e;\n\t\n\t// this vector is used fo eigenvalues\n\te[0] = vec2(sin(t)*5., cos(0.3*t)*2.);\n\te[1] = vec2(sin(t*0.5)*2.,-cos(t*1.2)*3.);\n\t\n\tfor (int i = 0; i < ev_n; i++) {\n\t\tv = rot(float(i)*s*cycle+t)*vec2(1.,0.);\n\t\tcr += cx * vector(uv, v, vec2(0.));\n\t\tcr += ce * vector(uv, e*v, v);\n\t}\n\treturn cr;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t = iTime;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = uv*2.0 - 1.0;\n\tuv.x *= iResolution.x/iResolution.y;\n\t\n\tvec3 b = vec3(bg(uv));\n\tvec3 c1 = vec3(1.,0.,0.);\n\tvec3 c2 = vec3(0.,1.,0.);\n\t\n\tvec2 uvt = distort(uv);\n\n\tfloat g = grid(uv);\n\n\tfloat l1 = line(uvt, sin(uvt.x));\n\tfloat l2 = line(uvt, cos(uvt.x));\n\t\n\tfloat v = vector(uvt, vec2(3., 2.), vec2(0.));\n\t\n\tfragColor = vec4(b*g + ev(uvt), 1.);\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdfSzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[56, 56, 77, 77, 100], [101, 101, 122, 122, 145], [146, 146, 184, 184, 222], [224, 224, 246, 246, 730], [732, 732, 750, 750, 933], [935, 935, 956, 956, 1335], [1337, 1337, 1367, 1367, 1469], [1471, 1471, 1510, 1510, 1689], [1691, 1691, 1730, 1730, 1789], [1790, 1790, 1809, 1809, 1892], [1894, 1894, 1917, 1917, 2104], [2106, 2106, 2119, 2119, 2305], [2328, 2328, 2346, 2346, 2779], [2783, 2783, 2840, 2840, 3250]], "test": "ok"}
{"id": "XdfXR4", "name": "ray marching - test #1", "author": "remonvv", "description": "Simple ray marching test. Upper right shows steps (light = less steps, dark = more steps), lower right shows normals", "tags": ["raymarching", "distancefields", "roundedcubes"], "likes": 3, "viewed": 178, "published": "Public", "date": "1397141393", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ray marching\nconst int max_iterations = 260;\nconst float eps = 0.001;\nconst float clip_far = 10000.0;\n\n// math\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\nconst vec3 fog = vec3(0.4, 0.5, 1.0);\n\n\n\nfloat dist_box( vec3 pos, vec3 size, float radius ) {\n\t\n\tfloat radFac = 1.1 + sin(iTime) * 0.9;\n\tradius = radFac;\n\tsize-=radFac;\n\t\n\tpos = mod(pos,vec3(8.0)) - vec3(4.0);\n\t\n\treturn length( max( abs( pos ) - size, 0.0 ) ) - radius;\n}\n\n// get distance in the world\nfloat dist_field( vec3 pos ) {\n\treturn  dist_box( pos, vec3( 2.0 ), 0.4 );\n}\n\n// phong shading\nvec3 shading( vec3 v, vec3 n, vec3 eye, float distance, vec2 uv, float steps ) {\n\t// ...add lights here...\n\t\n\tfloat shininess = 122.0;\n\t\n\tvec3 final = vec3( 0.0 );\n\t\n\tvec3 ev = normalize( v - eye );\n\tvec3 ref_ev = reflect( ev, n );\n\t\n\t{\n\t\tvec3 light_pos   = vec3( 20.0, 20.0, 20.0 );\n\t\tvec3 light_color = vec3( 0.3, 0.7, 0.7 );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n\t\t\n\t\tfinal += light_color * ( diffuse + specular ); \n\t}\n\t\n\t{\n\t\tvec3 light_pos   = vec3( -20.0, -2.0, -20.0 );\n\t\tvec3 light_color = vec3( 0.3, 0.4, 0.7 );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n\t\t\n\t\tfinal += light_color * ( diffuse + specular ); \n\t}\n\n\tfloat fogFactor = min(1.0, 1.0 - 10.0 / distance);\n\t\n\tif(uv.x < 0.5)\n\t\treturn final + (fog - final) * fogFactor;\n\telse if(uv.y < 0.5)\n\t\treturn vec3(n);\n\t\telse\n\t\treturn vec3(1.0 - steps);\n}\n\n// get gradient in the world\nvec3 gradient( vec3 pos ) {\n\tconst vec3 dx = vec3( eps, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, eps, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, eps );\n\treturn normalize (\n\t\tvec3(\n\t\t\tdist_field( pos + dx ) - dist_field( pos - dx ),\n\t\t\tdist_field( pos + dy ) - dist_field( pos - dy ),\n\t\t\tdist_field( pos + dz ) - dist_field( pos - dz )\t\t\t\n\t\t)\n\t);\n}\n\n// ray marching\nfloat ray_marching( vec3 origin, vec3 dir, float start, float end, out float steps ) {\n\tfloat depth = start;\n\tsteps = 0.0;\n\tfor ( int i = 0; i < max_iterations; i++ ) {\n\t\tfloat dist = dist_field( origin + dir * depth );\n\t\tsteps += 1.0 / float(max_iterations);\n\t\tif ( dist < eps ) {\n\t\t\treturn depth;\n\t\t}\n\t\tdepth += dist;\n\t\tif ( depth >= end) {\n\t\t\treturn end;\n\t\t}\n\t\t\n\t}\n\treturn end;\n}\n\n// get ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\n// camera rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 col = vec3(0.0);\n\t\n\t// default ray dir\n\tvec3 dir = ray_dir( 45.0, iResolution.xy, fragCoord.xy );\n\t\n\t// default ray origin\n\tvec3 eye = vec3( 0.0, 0.0, iTime );\n\t\n\t// rotate camera\n\tmat3 rot = rotationXY(-iMouse.yx / 100.0);\n\tdir = rot * dir;\n\t//eye = rot * eye;\n\t\n\t// ray marching\n\tfloat steps;\n\tfloat depth = ray_marching( eye, dir, 0.0, clip_far, steps );\n\t\n\tvec3 pos = eye + dir * depth;\n\tvec3 n = gradient( pos );\n\t\n\tcol = shading( pos, n, eye, depth, fragCoord.xy / iResolution.xy, steps );\n\t\n\t\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdfXR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[225, 225, 278, 278, 456], [458, 487, 517, 517, 563], [565, 582, 662, 688, 1670], [1672, 1701, 1728, 1728, 2044], [2046, 2062, 2148, 2148, 2444], [2446, 2467, 2515, 2515, 2691], [2693, 2725, 2756, 2756, 2912], [2914, 2914, 2971, 2971, 3510]], "test": "ok"}
{"id": "Xdj3zh", "name": "raytrace madness", "author": "zugamifk", "description": "test", "tags": ["test"], "likes": 2, "viewed": 140, "published": "Public", "date": "1398135942", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct camera {\n  vec3 pos;\n  vec3 facing;\n};\n\nstruct hitInfo {\n    vec3 lv;\n    vec3 cv;\n    vec3 normal;\n    vec3 pos;\n};\n\nstruct lightInfo {\n   vec3 pos;\n   vec3 dColor;\n   vec3 sColor;\n};\n\nlightInfo light1, light2;\ncamera cam;\n\nvec3 bg(vec2 p) {\n //p.x += floor(mod(time, .2)*10.);\n if (floor(mod(floor(p.x)+floor(p.y), 2.0)) <1.)\n    return vec3(0.);\n   return vec3(1.);\n}\n\nvec3 getBG(vec2 p) {\n  p.x += cos(.5*iTime); \n  p.y += sin(.5*iTime);\n  p += vec2(0.5*sin(p.y)*sin(iTime),\n          -0.5*sin(p.x)*sin(iTime));\n  p*=4.;\n//  p.x = p.x + p.x*cos(time);\n // p.y = p.y + p.y*sin(time);\n  return bg(p);\n}\n\nvec3 getColor(hitInfo hit, lightInfo lite) {\n    vec3 col;\n    \n    if (dot( vec3(0.,0., -1.), hit.normal)==0.) {col=vec3(0.);}\n    else {\n       col = 0.7*getBG(\n               vec2( hit.pos.xy +\n                 hit.normal.xy*dot(vec3(0.,0., 1.)-hit.pos, vec3(0.,0.,1.))/dot(hit.normal, vec3(0.,0.,1.))\n               )\n             ).xxx;\n    }\n\n    float i = clamp(dot(hit.lv, hit.normal), 0., 1.);\n    col += i*lite.dColor;\n\n    i = pow(clamp(dot(hit.cv, reflect(hit.lv, hit.normal)), 0., 1.), 4.0);\n    col += i *lite.sColor;\n    return col;\n}\n\nconst int MAX_STEPS = 100;\n\nfloat raymarch(camera o, vec3 j, float d) {\n\n   vec3 r = o.pos;\n   vec3 s = o.facing*0.1;\n   float n, dist = n = distance(o.pos, j);\n   for (int i = 0; i < MAX_STEPS; i++) {\n     if (n <= d) {\n        return length(r);\n     }\n     r += s;\n     dist = n;\n     n = distance(r, j);\n   }\n   return 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -2.0 + 4.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    cam.pos  = vec3(p, 0.);\n    cam.facing = vec3(0.,0.,1.);\n\n    vec3 r = cam.pos;\n    vec4 col = vec4(getBG(cam.pos.xy), 0.5);\n    \n    vec3 cc = vec3(cos(iTime), sin(iTime), 0.);\n\n    lightInfo light1 = lightInfo(vec3(0.,0., 1.+cos(iTime)*0.8), vec3(1.,1.,1.), vec3(1.,1., 1.)\n    );\n    lightInfo light2 = lightInfo(vec3(cos(iTime*8.),0.5,2.), vec3(0.,0., 1.), vec3(0.,1., 1.)\n    );\n\n    float a = acos(sign(cam.pos.y-cc.y)*dot(normalize(cam.pos.xy-cc.xy), vec2(1., 0.)));\n    float sa = 0.5+0.25*cos(10.*a+iTime)*cos(20.*a);\n\n    float d = raymarch(cam, cc, 0.5);\n\n    if (d > 0.) {\n\n        d =length(cam.pos- cc)/0.5;\n        r = vec3(cam.pos.xy, sqrt(1.-d*d));\n\n       col = vec4(getColor(\n          hitInfo(normalize(light1.pos-r), normalize(cam.pos-r), normalize(r-cc), r), light1\n       ), 1.);\n     //  col += vec4(getColor(\n     //     hitInfo(normalize(light2.pos-r), normalize(cam.pos-r), normalize(r-cc), r)\n      // ), 1.);\n    }\n\n    fragColor = col;\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xdj3zh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[232, 232, 249, 285, 377], [379, 379, 399, 399, 611], [613, 613, 657, 657, 1162], [1192, 1192, 1235, 1235, 1491], [1493, 1493, 1550, 1550, 2621]], "test": "ok"}
{"id": "XdsSzN", "name": "starline", "author": "cafe", "description": "starline", "tags": ["starline"], "likes": 3, "viewed": 171, "published": "Public", "date": "1397656529", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI=3.14159;\nconst float linenum=7.;\nconst float starmod=3.;\n\nvec3 dcol = vec3(-1.);\n\nfloat sine(float x){\n\treturn (sin((x-0.5)*PI)+1.)/2.;\n}\n\nvec2 rotate(vec2 uv, float ang){\n\t\n\tfloat l=length(uv);\n\t\n\tl=mix(l,exp(l),sine(iTime*0.2-0.2)/2.);\n\t\n\tang += atan(uv.x,uv.y);\n\t\n\treturn vec2(sin(ang),cos(ang))*l;\n}\n\nvec2 cirflect(vec2 uv){\n\t\n\tfloat md=1.-abs(mod(length(uv),2.)-1.);\n\t\n\treturn normalize(uv)*md;\t\n}\n\nfloat line(vec2 p1, vec2 p2){\n\tvec2 ld = p2-p1;\n\tfloat md = clamp(dot(-p1,normalize(ld))/length(ld),0.,1.);\n\treturn abs(length(mix(p1,p2,md)));\n}\n\nfloat convex(vec2 u){\n\t\n\tfloat dist;\n\tfloat anginc = (PI/linenum)*2.;\n\t\n\tfor(float i=0. ; i<linenum ; i++){\n\t\tfloat ang1 = anginc*i*starmod;\n\t\tfloat ang2 = anginc*(i+1.)*starmod;\n\t\tvec2 p1 = vec2(cos(ang1),sin(ang1));\n\t\tvec2 p2 = vec2(cos(ang2),sin(ang2));\n\t\t\n\t\tfloat ndist = line(p1+u,p2+u);\n\t\tif(i==0.) dist=ndist;\n\t\telse dist=min(dist,ndist);\n\t}\n\treturn dist;\t\n}\n\nvec3 shade(vec2 uv){\n\t\n\t/* PARAMS */\n\t\n\tconst float width=0.02;\n\tconst float linenum=20.;\n\t\n\n\t/* ------ */\n\t\n\tfloat dist=0.;\n\t\n\tvec2 ruv = rotate(uv,mod(iTime*0.4,PI*2.));\n\truv = cirflect(ruv);\n\t\n\tfloat warp=0.3;\n\t\n\tdist = convex(vec2(0.)-ruv*(sin(iTime*0.2*PI)*(warp*2.)+1.-warp));\n\t\n\tdist = max(0.,dist-width);\n\t\n\tvec3 color;\n\t\n\tcolor = vec3(dist);\n\tcolor.r = smoothstep(color.r,0.,0.01);\n\tcolor.g = smoothstep(color.g,0.,0.02);\n\tcolor.b = smoothstep(color.b,0.,0.04);\n\t\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.*fragCoord.xy - iResolution.xy) / iResolution.y;\n\t\n\tuv*=2.;\n\t\n\tvec3 color=shade(uv);\n\t\n\tif(max(dcol.r,max(dcol.g,dcol.b)) > -1.)\n\t\tcolor=dcol;\n\t\n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdsSzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 97, 117, 117, 152], [154, 154, 186, 186, 318], [320, 320, 343, 343, 417], [419, 419, 448, 448, 564], [566, 566, 587, 587, 931], [933, 933, 953, 969, 1422], [1424, 1424, 1481, 1481, 1672]], "test": "ok"}
{"id": "XdsXR4", "name": "distance field renderer", "author": "2DArray", "description": "A distance-field renderer with directional lights and ambient occlusion", "tags": ["3d", "distancefield"], "likes": 1, "viewed": 335, "published": "Public", "date": "1397546976", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 frustum;\nfloat drawDistance = 250.0;\nfloat epsilon = 0.05;\nfloat aoStep = 0.2;\nfloat aoFactor = 0.04;\nfloat tileSize = 5.0;\n\nconst float PI = 3.14159;\n\nvec3 rotVec3(vec3 vector,vec3 eulerAngles) {\n\tfloat sinT;\n\tfloat cosT;\n\tmat3 matrix;\n\teulerAngles = -eulerAngles;\n\tif (eulerAngles.x!=0.0) {\n\t\tsinT = sin(eulerAngles.x);\n\t\tcosT = cos(eulerAngles.x);\n\t\tmatrix = mat3(1.0,0.0,0.0,0.0,cosT,-sinT,0.0,sinT,cosT);\n\t\tvector = matrix * vector;\n\t}\n\tif (eulerAngles.y!=0.0) {\n\t\tsinT = sin(eulerAngles.y);\n\t\tcosT = cos(eulerAngles.y);\n\t\tmatrix = mat3(cosT,0.0,sinT,0.0,1.0,0.0,-sinT,0.0,cosT);\n\t\tvector = matrix * vector;\n\t}\n\tif (eulerAngles.z!=0.0) {\n\t\tsinT = sin(eulerAngles.z);\n\t\tcosT = cos(eulerAngles.z);\n\t\tmatrix = mat3(cosT,-sinT,0.0,sinT,cosT,0.0,0.0,0.0,1.0);\n\t\tvector = matrix * vector;\n\t}\n\treturn(vector);\n}\n\nfloat distanceToSphere(vec4 sphere,vec3 point) {\n\treturn(length(point-sphere.xyz)-sphere.w);\n}\n\nfloat distanceToRect(vec3 rectExtents,vec3 rectCenter,vec3 point) {\n\tvec3 tPoint = point-rectCenter;\n\treturn(length(max(abs(tPoint)-rectExtents,0.0)));\n}\nfloat distanceToRoundRect(vec4 rectExtents,vec3 rectCenter,vec3 point) {\n\tvec3 tPoint = point-rectCenter;\n\treturn(length(max(abs(tPoint)-rectExtents.xyz,0.0)) - rectExtents.w);\n}\nfloat distanceToFloor(float floorHeight,vec3 point) {\n\treturn(point.y-floorHeight);\n}\n\nfloat distanceField(vec3 point) {\n\tfloat dist = 10000.0;\n\t\n\t//point.x+=sin(point.y+iTime) * 0.5;\n\t\n\tpoint=vec3(mod(point.x+tileSize*1.5,tileSize*3.0)-tileSize*1.5,point.y,mod(point.z+tileSize,tileSize*2.0)-tileSize);\n\t\n\tvec4 theSphere = vec4(0.0,0.0,0.0,1.0);\n\tdist = min(dist, distanceToSphere(theSphere,point));\n\t\n\tvec3 rectCenter = vec3(3.0,0.0,0.0);\n\tvec3 rectExtents = vec3(1.0,2.0,1.0);\n\tdist = min(dist, distanceToRect(rectExtents,rectCenter,point));\n\t\n\trectCenter = vec3(-3.0,0.0,0.0);\n\tvec4 rectExtents2 = vec4(1.0,1.0,1.0,0.7);\n\tdist = min(dist,distanceToRoundRect(rectExtents2,rectCenter,point));\n\t\n\tdist=min(dist,distanceToFloor(-2.0,point));\n\t\n\treturn(dist);\n}\n\nvec3 findNormal(vec3 point) {\n\tvec3 normal;\n\t\n\tfloat ep = epsilon * .25;\n\t\n\tnormal.x=distanceField(point+vec3(ep,0.0,0.0))-\n\t\t\t distanceField(point-vec3(ep,0.0,0.0));\n\tnormal.y=distanceField(point+vec3(0.0,ep,0.0))-\n\t\t\t distanceField(point-vec3(0.0,ep,0.0));\n\tnormal.z=distanceField(point+vec3(0.0,0.0,ep))-\n\t\t\t distanceField(point-vec3(0.0,0.0,ep));\n\t\n\treturn(normalize(normal));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat camRot = iTime*0.3;\n\tvec3 camPos = vec3(cos(camRot)+.1,1.0,sin(camRot))*8.0;\n\t\n\tfrustum = vec3 (1.0,iResolution.y/iResolution.x,1.0);\n\t\n\t//tileSize = 7.0 + cos(iTime*0.2)*2.0;\n\t\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec3 uv2 = vec3(uv,1.0);\n\tuv2 = uv2 * 2.0 - 1.0;\n\tvec3 viewDir = normalize(frustum * uv2);\n\t\n\tviewDir = rotVec3(viewDir, vec3(.3,-camRot-PI*0.5,0.0));\n\t\n\tfloat dist;\n\tvec3 rayPos = camPos+viewDir*0.001;\n\tvec3 travelVector;\n\t\n\tfloat light=0.0;\n\t\n\tbool stop = false;\n\t\n\tvec3 normal;\n\t\n\tfor (int i=0;i<64;i++) {\n\t\tif (stop == false) {\n\t\t\ttravelVector=rayPos-camPos;\n\t\t\t\n\t\t\tdist=distanceField(rayPos);\n\t\t\t\n\t\t\tif (dist<epsilon) {\n\t\t\t\tlight=1.0;\n\t\t\t\tnormal=findNormal(rayPos);\n\t\t\t\tstop=true;\n\t\t\t} else if (dot(travelVector,travelVector)>drawDistance*drawDistance) {\n\t\t\t\tlight=0.0;\n\t\t\t\tstop=true;\n\t\t\t} else {\n\t\t\t\trayPos+=viewDir*dist;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tvec3 finalColor;\n\tif (light<.5) {\n\t\tlight=uv2.y*.5+.5;\n\t\tfinalColor = vec3(light,light,light);\n\t} else {\n\t\tvec3 sun = normalize(vec3(1.0,1.0,1.0));\n\t\tlight = clamp(dot(normal,sun),0.0,1.0);\n\t\t\n\t\tsun = normalize(vec3(-1.0,-1.0,-1.0));\n\t\tlight+=clamp(dot(normal,sun)*.5,0.0,1.0);\n\t\t\n\t\tlight=max(light,0.1);\n\t\t\n\t\tfloat oDist = dist;\n\t\tfor (float j=0.0;j<8.0;j++) {\n\t\t\trayPos+=normal*aoStep;\n\t\t\tdist=distanceField(rayPos);\n\t\t\tlight-=(aoStep*(j+1.0)-(dist-oDist))*aoFactor;\n\t\t}\n\t\tlight=clamp(light,0.0,1.0);\n\t\t\n\t\tfinalColor=vec3(light,light,light);\n\t}\n\t//light=length(travelVector)/drawDistance;\n\t//finalColor = vec3(light,light,light);\n\t\n\t\n\tfragColor = vec4(finalColor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdsXR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[157, 157, 201, 201, 814], [816, 816, 864, 864, 910], [912, 912, 979, 979, 1065], [1066, 1066, 1138, 1138, 1244], [1245, 1245, 1298, 1298, 1330], [1332, 1332, 1365, 1365, 2005], [2007, 2007, 2036, 2036, 2389], [2391, 2391, 2448, 2448, 3994]], "test": "ok"}
{"id": "XdsXz4", "name": "Primes structure", "author": "FabriceNeyret2", "description": "SPACE= no zoom\n3 way to display the distribution of primes.\nafter \"discovering numbers structures through images\" by Jean-Paul Delahaye\nin \"Pour la Science\", French edition of Scientific American, Feb 2014\nhttp://www.lifl.fr/~delahaye/pls/2014/243.pdf", "tags": ["primes"], "likes": 7, "viewed": 1783, "published": "Public API", "date": "1397584630", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 3 way to display the distribution of primes\n\n// after \"discovering numbers structures through images\" by Jean-Paul Delahaye\n// in \"Pour la Science\", French edition of Scientific American, Feb 2014\n// http://www.lifl.fr/~delahaye/pls/2014/243.pdf\n\n#define PI 3.14159265359\n\nbool keyToggle(int ascii) {\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\n}\n\nint DISPLAY  = 3; // display method :\n\t\t\t\t\t// 1: i = length along a squared spiral \n\t\t\t\t\t// 2: i = length along a squared spiral \n\t\t\t\t\t// 3: i = length along an Archimedial spiral \n\t\n\nfloat isPrime( float x );\nfloat prime (int n) {\n\n#define MODE 3\n\n#if MODE == 0 // the simpler the better... but unrolling kills on windows\n\tint imax = int(sqrt(float(n)));\n\tfor (int i=2; i<1400; i++ ) {\n\t\tif (i>imax) return 1.;\n\t\tif ( n-i*(n/i) == 0) return 0.;\n\t}\n\n#elif MODE == 1  // i^2-i+41  gives primes with 50% probability\n\tfloat d = sqrt(1.-4.*(41.-float(n)));\n\tif (d<0.) return 0.;\n\tif (fract((1.+sqrt(d))/2.)> 1e-5) return 0.;\n\treturn 1.;\n\t\n#elif MODE == 2 // stochastic test, but needs long longs.\n\tfloat err = mod(pow(2.,float(n)-1.),float(n)) - 1.; \n\tif (abs(err)> 1e-5) return 0.;\n\treturn 1.;\n\t\n#elif MODE == 3 // IQ compact loop\n\treturn isPrime(float(n));\n#endif\t\n}\n\nfloat truemod(float x,float y) { float v = mod(x,y); return (v==y)? 0. : v; }\n\n// isPrime:  Created by inigo quilez - iq/2013 https://www.shadertoy.com/view/4slGRH\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Info on prime hunting: http://www.iquilezles.org/blog/?p=1558\nfloat isPrime( float x )\n{\n\tif( x==1. ) return 0.;\n\tif( x==2. ) return 1.;\n\tif( x==3. ) return 1.;\n\tif( x==5. ) return 1.;\n\tif( x==7. ) return 1.;\n\t\n\tif( mod(x,2.)==0. ) return 0.;\n\tif( mod(x,3.)==0. ) return 0.;\n\tif( mod(x,5.)==0. ) return 0.;\n\n\tfloat y = 7.;\n\tbool flip =   true; // (mod(iTime*4.,1.)>.5);\n\tfloat xmax = (flip) ? sqrt(x)+1. : x;\n\t//int max =  (flip) ? 2000:200;\n\n\tfor( int i=0; i<200; i++ ) // count up to 6000\n\t{ \n\t    // if (i>max) {  return 1.; }\n\t\tif( truemod(x,y)==0. )  return 0.;\n\t\ty += 4.; if( y>=xmax ) return 1.;\n\t\tif( truemod(x,y)==0. )  return 0.;\n\t\ty += 2.; if( y>=xmax ) return 1.;\n\t\tif( truemod(x,y)==0. )  return 0.;\n\t\ty += 4.; if( y>=xmax ) return 1.;\n\t\tif( truemod(x,y)==0. )  return 0.;\n\t\ty += 2.; if( y>=xmax ) return 1.;\n\t\tif( truemod(x,y)==0. )  return 0.;\n\t\ty += 4.; if( y>=xmax ) return 1.;\n\t\tif( truemod(x,y)==0. )  return 0.;\n\t\ty += 6.; if( y>=xmax ) return 1.;\n\t\tif( truemod(x,y)==0. )  return 0.;\n\t\ty += 2.; if( y>=xmax ) return 1.;\n\t\tif( truemod(x,y)==0. )  return 0.;\n\t\ty += 6.; if( y>=xmax ) return 1.;\n\t}\n\t\n\treturn 1.;\n}\n\n// ---------------------------------------------------------\n\n#define myInt(x)  (int(x)+(((x)<0.)?0:1) )\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat zoom = (keyToggle(32)) ? 1. : clamp(.5*(1.-cos(iTime)),0.,1.);\n\tDISPLAY = 1;//+int(mod(iTime/(2.*PI),3.));\n\t\n\tvec2 uv;\n\tuv.x = float(int(fragCoord.x)-int(iResolution.x/2.))*zoom;\n\tuv.y = float(int(fragCoord.y)-int(iResolution.y/2.))*zoom;\n\tint i;\t\n\t\n\tif (DISPLAY == 1) \n\t{ \t\t\t\t\t\t// i = col + line*WIDTH\n\t\tuv += iResolution.xy/2.;\n\t\ti = int(uv.x)+int(iResolution.x)*int(uv.y);\n\t}\n\telse if (DISPLAY == 2) \n\t{ \t\t\t\t\t\t // i = length along a squared spiral \n\t\tint   x = myInt(uv.x),\n\t\t\t  y = myInt(uv.y);\n\t\tfloat ax = abs(float(x)),\n\t\t\t  ay = abs(float(y));\n\t\tint   r = int (max(ax,ay));\n\t\tint quadran = ( ax > ay ) ? ( (x>0) ? 1 : 3 ) : ( (y>0) ? 2 : 4 );\n\t\t\n\t\ti = (r-1)*r; \n\t\tif      (quadran==1) i +=                 r+y;     // right\n\t\telse if (quadran==2) i += 2*r           + r-x;     // top\n\t\telse if (quadran==3) i += 4*(r-1)       + r-y;     // left\n\t\telse                 i += 4*(r-1) + 2*r + r+x;     // bottom\n\t\t//fragColor = vec4(mod(float(i),2.)); return;\t\n\t\t//fragColor = vec4(float(i)/40000.); return;\t\n\t}\t\n\telse \n\t{ \t\t\t\t\t\t//  i = length along an Archimedial spiral \n#       define RAD 1. // 4. // zoom\n    \tfloat r = length(uv)/RAD, a = atan(uv.y, uv.x),\n\t  \t\t  s = r - a/(2.*PI),\n\t    \t  t = floor(s)+a/(2.*PI), // turns\n\t\t\t  l = t*t;// int (a/2PI da)\n\t\t//fragColor = vec4(sin(2.*PI*s)); return;\n\t\t//fragColor = vec4(sin(l/4.))+vec4(max(0.,sin(s)),0.,0.,0.);return;\n \t\ti = int(l);\n\t}\n\n\t\tfragColor = vec4(prime(i));\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdsXz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[276, 276, 303, 303, 376], [588, 588, 609, 609, 1242], [1244, 1244, 1276, 1276, 1321], [1323, 1560, 1586, 1586, 2630], [2737, 2737, 2794, 2794, 4230]], "test": "error"}
{"id": "XdsXzM", "name": "Infini-chess", "author": "squeakyneb", "description": "Just a quickie I whipped up, as inspired by Mudlord's \"they took mah hyperspace\".", "tags": ["2d", "chess", "mudlord"], "likes": 6, "viewed": 172, "published": "Public", "date": "1398490879", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\tuv -= 0.5;//center it\n\tuv *= 2.0;//screen domain is now -1 to 1\n\tuv.x *= iResolution.x/iResolution.y; //correct for aspect ratio by varying length of horizontal axis\n\t\n\tvec2 pA = vec2(1.0*sin(iTime),\t\t1.0*cos(iTime));\n\tvec2 pB = vec2(1.0*sin(iTime*1.7),\t\t0.8*cos(iTime*1.3));\n\t/* my original code\n\tfloat cA = length(uv-pA);\n\tcA = mod(cA*3.0,1.0);\n\tif(cA<0.5){cA=0.;}else{cA=1.;}\n\t\n\tfloat cB = length(uv-pB);\n\tcB = mod(cB*3.0,1.0);\n\tif(cB<0.5){cB=0.;}else{cB=1.;}\n\t\n\tfloat c = mod((cA + cB),2.); //GLSL has no XOR so I improvised this stupid thing\n\t*/\n\t\n\t// mmalex's version\n\tfloat cA = length(uv-pA);\n\tfloat cB = length(uv-pB);\n\t\n\tfloat c = sign(sin(cA*15.))*sign(sin(cB*15.));\n\t\n\tfragColor = vec4(vec3(c),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdsXzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 818]], "test": "ok"}
{"id": "XdXXWn", "name": "rice on checker illusion", "author": "FabriceNeyret2", "description": "mouse.x: zoom\nmouse.y: grey level of dots", "tags": ["illusion"], "likes": 7, "viewed": 1646, "published": "Public API", "date": "1398721903", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat rnd(vec2 uv) { return fract(sin(5423.1*uv.x-65.543*uv.y)*1e5); }\nfloat rnd0(vec2 uv) { return (rnd(uv)>.5) ? 1. : 0. ; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t = iTime;\n    vec2 uv = (fragCoord.xy -.5*iResolution.xy)/ ( floor(iResolution.y/64.)*64.);\n\n\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\tif (iMouse.z<=0.) {\n\t\tmouse.x = .5*(1.+cos(.1*t));\n\t\tmouse.y = .5*(1.+cos(t));\n\t}\n\t\n\tuv *= pow(2.,2.-6.*mouse.x);\n#define REPEAT (7./8.)\n\tvec2 vrep = uv/REPEAT +.4;\n\tuv = mod(vrep,1.)*REPEAT -.4 ;  \t\t // repeat the macro pattern\n\tfloat irep = mod( floor(vrep.x)+floor(vrep.y) ,2.);\n\t\n\tvec2 v = floor(uv*16.);\t\n\tfloat fv = mod(v.x+v.y,2.);\t\t\t\t\t \t\t// large checker\t\n\tvec2 sv = mod(floor(uv*16.*4.-.5),2.);\t\t \t\t// for small squares\n\tfloat fsv = sv.x+sv.y + 1.-sv.x*sv.y;  \t\t \t\t// eliminates odd rows and cols\n\tvec2 m = floor(uv*16.*2.);\t\t\t\t\t \t\t// for mask\n\tfloat fm = m.x+m.y;\t\t\t\t\t\t\t \t\t// half checker\n\tfm += ((uv.x-1./32.)*(uv.y-1./32.)<0.) ? 1. : 0.;   // translates by 1 row\n\tfm += irep;\n\n\tt = mod(floor(iTime),2.);\n\tfm += t;\n\t// fm += rnd0(m+t);\n\t\t\n\tif (length(v)>6.25) fm = 0.;\n  \n\tfsv = mod(fsv,2.)*mod(fm,2.)*mouse.y;\n\t\n#if 0\n\tfv = mod(fv+fsv,2.); \n#else\n\tfv =  (fv > .5) ? 1.-fsv : fsv;\n#endif\n\n\tfragColor = vec4(fv);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdXXWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 21, 21, 71], [72, 72, 93, 93, 127], [129, 129, 186, 186, 1256]], "test": "ok"}
{"id": "XdXXz4", "name": "Motion Blur Visualization", "author": "HLorenzi", "description": "Importance of motion blur under three different frame rates (60, 30 and 15 FPS -- Shadertoy must be running at full 60 FPS for correct blurring). You can click on the shader to hide the jittering or the blurred circles.", "tags": ["2d", "blur", "fast", "sphere", "circle", "ball", "motion", "sample"], "likes": 145, "viewed": 8766, "published": "Public API", "date": "1397136691", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 circle(vec2 p, vec2 center, float radius)\n{\n\treturn mix(vec4(1,1,1,0), vec4(1,0,0,1), smoothstep(radius + 0.005, radius - 0.005, length(p - center)));\n}\n\nvec4 scene(vec2 uv, float t)\n{\n\treturn circle(uv, vec2(0, sin(t * 16.0) * (sin(t) * 0.5 + 0.5) * 0.5), 0.2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 resol = iResolution.xy / vec2(6,1);\n\tvec2 coord = mod(fragCoord.xy, resol);\n\tfloat view = floor(fragCoord.x / resol.x);\n\t\n\tvec2 uv = coord / resol;\n\tuv = uv * 2.0 - vec2(1);\n\tuv.x *= resol.x / resol.y;\n\t\n\tfragColor = vec4(1,1,1,1);\n\t\n\tfloat frametime = (60. / (floor(view / 2.) + 1.));\n\tfloat time = floor((iTime + 3.) * frametime) / frametime;\n\tvec4 mainCol = scene(uv, time);\n\t\n\tvec4 blurCol = vec4(0,0,0,0);\n\tfor(int i = 0; i < 32; i++)\n\t{\n\t\tif ((i < 8 || view >= 2.0) && (i < 16 || view >= 4.0))\n\t\t{\n\t\t\tblurCol += scene(uv, time - float(i) * (1. / 15. / 32.));\n\t\t}\n\t}\n\tblurCol /= pow(2., floor(view / 2.) + 3.);\n\t\n\tif (mod(view, 2.) == 0.)\n\t\tfragColor = mainCol;\n\telse\n\t\tfragColor = blurCol;\n\t\n\tif (iMouse.z > 0. && mod(view, 2.) == mod(floor(iMouse.z / resol.x), 2.))\n\t\tfragColor = vec4(0,0,0,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdXXz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 48, 48, 157], [159, 159, 189, 189, 269], [271, 271, 328, 328, 1138]], "test": "ok"}
{"id": "XsfSz7", "name": "original thought", "author": "destroyboy", "description": "the logistic equation is supposed to be one of the simplest equations that produces chaos.", "tags": ["chaos"], "likes": 4, "viewed": 132, "published": "Public", "date": "1398117225", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// logistic map\n// http://en.wikipedia.org/wiki/Logistic_map\n// r varies with time\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat r=4.0*sin(0.5*iTime);\n\tvec2 p1 = 2.0*fragCoord.xy/iResolution.xy-0.5;\n\tvec2 p2 = p1;\n\t\n\tfloat hit = 3.0;\n\tfor(int i=0;i<25;i++)\n\t{\n\t\tp1=r*p1*(1.0-p1);\n\t\t\n\t\tfloat d=distance(p1,p2);\n\t\tif (d<hit)\n\t\t    hit=d;\n\t}\n\thit=5.0*clamp(hit,0.0,0.2);\n\tfragColor = vec4(hit,hit,hit,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsfSz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 83, 140, 140, 424]], "test": "ok"}
{"id": "XsfXz7", "name": "bifurcate", "author": "destroyboy", "description": "x is x and y is r", "tags": ["bifurcation"], "likes": 4, "viewed": 166, "published": "Public", "date": "1398158692", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// logistic map\n// http://en.wikipedia.org/wiki/Logistic_map\n// zoom varies with time\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p1 = (fragCoord.xy/iResolution.xy-vec2(0.5,0.5))*8.0*(0.0+sin(0.1*iTime));\n\tvec2 p2 = p1;\n\tfloat hit = 3.0;\n\tfor(int i=0;i<50;i++)\n\t{\n\t\tp1.x=p1.y*p1.x*(1.0-p1.x);\n\t\tfloat d=distance(p1.x,p2.x);\n\t\tif (d<hit)\n\t\t    hit=d;\n\t}\n\thit=20.0*clamp(hit,0.0,0.05);\n\thit = 1.0-hit;\n\thit=hit*hit;\n\tfragColor = vec4(hit,hit,hit,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsfXz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 86, 143, 143, 471]], "test": "ok"}
{"id": "XslSR7", "name": "subliminal", "author": "FabriceNeyret2", "description": "mouse.x moves stripes (do it fast)\nmouse.y tunes stripes width\nYou can also look at your screen from far away.", "tags": ["illusion", "short"], "likes": 8, "viewed": 1672, "published": "Public API", "date": "1398527929", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float DX = 1.;\nfloat V = 0.;\n#define A .05\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t = iTime;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\tvec3 col = vec3(0);\n\tif (iMouse.z<=0.) {\n\t\tmouse.x = sin(t);\n\t\tmouse.y = (1.+sin(.3*t))/2.;\n\t}\n\t\n\tDX += floor(exp(5.*mouse.y));\n\tt = 30.*mouse.x;\n\t\n\tif (mod((fragCoord.x+.5)/DX-t,2.)>=1.)\n\t\tcol = 1.-A + A*texture(iChannel0,vec2(uv.x,1.-uv.y)).rgb;\n\t\n\tfragColor = vec4(col,1.0);\n\t\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XslSR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 45, 102, 102, 490]], "test": "error"}
{"id": "XssSzN", "name": "Metaballs - Cubic", "author": "iq", "description": "Bounded metaballs with cubic falloff. It's usually recommended to use quintic falloffs though. See . And PLEASE don't use 1/dÂ² potentials!", "tags": ["2d", "metaballs", "cubic"], "likes": 32, "viewed": 3116, "published": "Public API", "date": "1397670043", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (-iResolution.xy+2.0*fragCoord.xy)/iResolution.y;\n\n    // anim\n\tvec2 c1 = 0.8*sin( iTime*1.0 + vec2(4.0,0.5) + 1.0);\n\tvec2 c2 = 0.8*sin( iTime*1.3 + vec2(1.0,2.0) + 2.0);\n\tvec2 c3 = 0.8*sin( iTime*1.5 + vec2(0.0,2.0) + 4.0);\n\t\n    // potential (3 metaballs)\n    float v = 0.0;\t\n\tv += 1.0-smoothstep(0.0,0.7,length(uv-c1));\n\tv += 1.0-smoothstep(0.0,0.7,length(uv-c2));\n\tv += 1.0-smoothstep(0.0,0.7,length(uv-c3));\n\n    // color\t\n\tvec3 col = mix( vec3(v), vec3(1.0,0.6,0.0), smoothstep(0.9,0.91,v) );\n\t\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XssSzN.jpg", "access": "shaders20k", "license": "mit", "functions": [[1079, 1079, 1136, 1136, 1678]], "test": "ok"}
{"id": "XssXRH", "name": "dez", "author": "Branch", "description": "Effect from the Demokerho Invitation. ", "tags": ["dezz"], "likes": 41, "viewed": 2746, "published": "Public", "date": "1396797902", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct polygon{\n\tvec2 A, B, C;\n};\nfloat roundBox(vec2 coord, vec2 pos, vec2 b ){\n  return length(max(abs(coord-pos)-b,0.0));\n}\nfloat box(vec2 coord, vec2 pos, vec2 size){\n\tif((coord.x<(pos.x+size.x)) &&\n\t   (coord.x>(pos.x-size.x)) &&\n\t   (coord.y<(pos.y+size.y)) && \n\t   (coord.y>(pos.y-size.y)) ) \n\t\treturn 1.0;\n\treturn 0.0;\n}\nfloat sun(vec2 coord, vec2 pos, float size){\n\tif(length(coord-pos)<size)\n\t\treturn 1.0;\n\treturn 0.0;\n}\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat _sign(vec2 p1, vec2 p2, vec2 p3){\n  return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);\n}\nint PIT(vec2 pt, vec2 v1, vec2 v2, vec2 v3){\n\tint b1, b2, b3;\n\n\tif(_sign(pt, v1, v2) < 0.0) b1=1;\n\tif(_sign(pt, v2, v3) < 0.0) b2=1;\n\tif(_sign(pt, v3, v1) < 0.0) b3=1;\n\tif((b1 == b2) && (b2 == b3))\n\t\treturn 1;\n\treturn 0;\n}\n\nint PIT(vec2 pt, polygon X){\n\tint b1, b2, b3;\n\n\tif(_sign(pt, X.A, X.B) < 0.0) b1=1;\n\tif(_sign(pt, X.B, X.C) < 0.0) b2=1;\n\tif(_sign(pt, X.C, X.A) < 0.0) b3=1;\n\tif((b1 == b2) && (b2 == b3))\n\t\treturn 1;\n\treturn 0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat vasenKulmakarva=floor(mod(iTime*0.8,2.0))*0.1;\n\tfloat oikeaKulmakarva=floor(mod(iTime*0.3,2.0))*0.1;\n\tfloat vasenSilma=min(max(0.24*sin(iTime),0.006),0.06);\n\tfloat oikeaSilma=min(max(0.24*sin(iTime),0.006),0.06);\n\tfloat suu=iTime*10.0;\n\tvec4 tulos;\n\tvec4 lopullinentulos=vec4(1.0);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfloat aspectCorrection = (iResolution.x/iResolution.y);\n\tvec2 coordinate_entered = 2.0 * uv - 1.0;\n\tfor(float rgbare=0.0; rgbare<2.0; rgbare++){\n\tvec2 coord = vec2(aspectCorrection,1.0) *coordinate_entered;\n\tcoord.x*=1.0+rgbare*0.009;\n\tcoord*=1.0+rand(coord+iTime)/(pow(iTime,7.0)*3.0)-length(coord)*10.0/(pow(iTime*1.1,24.0));\n\tcoord*=1.0+0.1*sin(iTime*0.1);\n\ttulos=vec4(vec3(200.0/255.0, 10.0/255.0, 65.0/255.0),1.0);\n\tif(mod(coord.x+coord.y,0.2)>0.1){\n\t\tif(sun(coord,vec2(0.0),0.7)==1.0)\n\t\t   tulos.xyz=vec3(1.0,262.0/512.0, 74.0/255.0);\n\t}\n\tif(mod(coord.x+coord.y+iTime*0.1,0.2)<0.1){\n\t\tfor(float j=-6.0; j<6.0; j++)\n\t\tfor(float i=-5.0; i<5.0; i++){\n\t\t\tvec2 posi=vec2(i/2.0,j/2.0);\n\t\t\tvec2 size=vec2(0.22);\n\t\t\tif(box(coord,posi,size)==1.0 && mod(i+j,2.0)==0.0)\n\t\t   \t\ttulos.xyz-=vec3(0.4,0.5,0.3);\n\t\t}\n\t}\n\t\n\tfor(float i=0.0; i<3.141*2.0; i+=3.141*0.2){\n\t\tfloat aikakerroin=iTime*0.6;\n\t\tvec2 A=vec2(0.0,0.0);\n\t\tvec2 B=vec2(cos(aikakerroin+i), sin(aikakerroin+i));\n\t\tvec2 C=vec2(cos(aikakerroin+i-3.141*0.1), sin(aikakerroin+i-3.141*0.1));\n\t\tif(mod(coord.x+coord.y,0.2)>0.1)\n\t\tif(PIT(coord, A, B, C)==1)\n\t\t\ttulos.xyz=vec3(1.0,222.0/512.0, 64.0/255.0);\n\t}\n\t\n\tif(roundBox(coord, vec2(0.0,0.0), vec2(0.37, 0.37) )<0.1)\n\t\ttulos.xyz=vec3(0.0, 0.0, 0.0);\n\t\n\tif(roundBox(coord, vec2(0.0,0.0), vec2(0.33, 0.33) )<0.1 &&\n\t   roundBox(coord, vec2(0.0,-0.3), vec2(0.11, 0.11) )>0.1)\n\t\ttulos.xyz=vec3(0.97, 0.97, 0.97);\n\t\n\tif(mod(coord.x+coord.y,0.04)<0.02)\n\tif(roundBox(coord, vec2(0.3,-0.12), vec2(0.06, oikeaSilma) )<0.01)\n\t\ttulos.xyz=vec3(0.0, 0.0, 0.0);\n\t\n\tif(mod(coord.x+coord.y,0.04)<0.02)\n\tif(roundBox(coord, vec2(-0.3,-0.12), vec2(0.06, vasenSilma) )<0.01)\n\t\ttulos.xyz=vec3(0.0, 0.0, 0.0);\n\t\n\tif(roundBox(coord, vec2(0.0,-0.3), vec2(0.07, 0.07) )<0.1)\n\t\ttulos.xyz=vec3(0.97, 0.97, 0.97);\n\t\n\tfor(float i=-0.1; i<0.1; i+=0.04)\n\tif(roundBox(coord, vec2(i,-0.35), vec2(0.001, 0.13+sin(suu+i)*0.01) )<0.01)\n\t\ttulos.xyz=vec3(0.0, 0.0, 0.0);\n\t\t\n\tif(roundBox(coord, vec2(0.3,0.0+oikeaKulmakarva), vec2(0.08, 0.001) )<0.008)\n\t\ttulos.xyz-=vec3(0.7, 0.7, 0.7);\n\t\n\tif(roundBox(coord, vec2(-0.3,0.0+vasenKulmakarva), vec2(0.08, 0.001) )<0.008)\n\t\ttulos.xyz-=vec3(0.7, 0.7, 0.7);\n\ttulos.xyz=tulos.xyz-vec3(min(max(-0.44+length(coord)*0.41,0.0),1.0))+vec3(0.06*rand(vec2(coord.x+coord.y,iTime*coord.y*coord.x)));\n\t\n\tif(rgbare==0.0)\n\t\tlopullinentulos.r=tulos.r;\n\tif(rgbare==1.0)\n\t\tlopullinentulos.gb=tulos.gb;\n\t}\n\tif(mod(fragCoord.y,2.0)<1.0)   /////////////////////////\n\tlopullinentulos.xyz=lopullinentulos.xyz/1.3;\n\tfragColor = lopullinentulos;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XssXRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 34, 80, 80, 126], [127, 127, 170, 170, 328], [329, 329, 373, 373, 430], [431, 431, 451, 451, 523], [524, 524, 563, 563, 637], [638, 638, 682, 682, 860], [862, 862, 890, 890, 1074], [1077, 1077, 1134, 1134, 3997]], "test": "ok"}
{"id": "XssXz4", "name": "Neon parallax", "author": "nimitz", "description": "Manhattan distance metric and parallax scrolling.", "tags": ["2d", "parallax"], "likes": 100, "viewed": 3485, "published": "Public", "date": "1397586251", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Neon parallax by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/XssXz4\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n#define t iTime\n\nfloat pulse(float cn, float wi, float x)\n{\n\treturn 1.-smoothstep(0., wi, abs(x-cn));\n}\n\nfloat hash11(float n)\n{\n    return fract(sin(n)*43758.5453);\n}\n\nvec2 hash22(vec2 p)\n{\n    p = vec2( dot(p,vec2(127.1, 311.7)), dot(p,vec2(269.5, 183.3)));\n\treturn fract(sin(p)*43758.5453);\n}\n\nvec2 field(in vec2 p)\n{\n\tvec2 n = floor(p);\n\tvec2 f = fract(p);\n\tvec2 m = vec2(1.);\n\tvec2 o = hash22(n)*0.17;\n\tvec2 r = f+o-0.5;\n\tfloat d = abs(r.x) + abs(r.y);\n\tif(d<m.x)\n    {\n\t\tm.x = d;\n\t\tm.y = hash11(dot(n,vec2(1., 2.)));\n\t}\n\treturn vec2(m.x,m.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy-0.5;\n\tuv.x *= iResolution.x/iResolution.y*0.9;\n\tuv *= 4.;\n\t\n\tvec2 p = uv*.01;\n\tp *= 1./(p-1.);\n\t\n\t//global movement\n\tuv.y += t*1.2;\n\tuv.x += sin(t*0.3)*0.8;\n\tvec2 buv = uv;\n\t\n\tfloat rz = 0.;\n\tvec3 col = vec3(0.);\n\tfor(float i=1.; i<=26.; i++)\n\t{\n\t\tvec2 rn = field(uv);\n\t\tuv -= p*(i-25.)*0.2;\n\t\trn.x = pulse(0.35,.02, rn.x+rn.y*.15);\n\t\tcol += rn.x*vec3(sin(rn.y*10.), cos(rn.y)*0.2,sin(rn.y)*0.5);\n\t}\n\t\n\t//animated grid\n\tbuv*= mat2(0.707,-0.707,0.707,0.707);\n\tfloat rz2 = .4*(sin(buv*10.+1.).x*40.-39.5)*(sin(uv.x*10.)*0.5+0.5);\n\tvec3 col2 = vec3(0.2,0.4,2.)*rz2*(sin(2.+t*2.1+(uv.y*2.+uv.x*10.))*0.5+0.5);\n\tfloat rz3 = .3*(sin(buv*10.+4.).y*40.-39.5)*(sin(uv.x*10.)*0.5+0.5);\n\tvec3 col3 = vec3(1.9,0.4,2.)*rz3*(sin(t*4.-(uv.y*10.+uv.x*2.))*0.5+0.5);\n\t\n\tcol = max(max(col,col2),col3);\n\t\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XssXz4.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[243, 243, 285, 285, 329], [331, 331, 354, 354, 393], [395, 395, 416, 416, 521], [523, 523, 546, 546, 776], [778, 778, 835, 835, 1692]], "test": "ok"}
{"id": "XsXSz7", "name": "Clouds, physically-based version", "author": "jamiep", "description": "Refactoring iq clouds, to figure out how it works in terms of volume rendering. Also adding HG phase function.", "tags": ["clouds"], "likes": 11, "viewed": 620, "published": "Public", "date": "1398097702", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// hash based 3d value noise\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\n\nconst float KAPPA = 0.08;  // extinction coefficient\n\nvec3 sun_direction()\n{\n\tfloat freq = 1.0;\n\tfloat phase = 2.0 + freq*iTime;\n\treturn normalize(vec3(cos(phase), 0.1, sin(phase)));\n}\n\n// returns clouds extinction coeff. as a function of world position\nfloat clouds_extinction( in vec3 p )\n{\t\n\tfloat spatial_period = 32.0;\n\tp /= spatial_period;\n\t\n\tfloat timefreq = 0.5;\n\tvec3 q = p - vec3(1.0,0.1,0.0)*timefreq*iTime;\n\t\n\tfloat cloud_height = 2.5;\n\tfloat layer_y = -1.3*cloud_height;\n\n\tfloat N;\n\tfloat g = 1.0;\n\tfloat beta = 0.4;\n    N  = g * noise( q ); q *= 2.0; g *= beta;\n    N += g * noise( q ); q *= 2.0; g *= beta;\n    N += g * noise( q ); q *= 2.0; g *= beta;\n    N += g * noise( q );\n\t\n\tfloat s = 0.16; // edge smoothness (0=hard, 1=smooth)\n\t\n\tfloat cloudtop_y = layer_y + cloud_height*pow(abs(N), 0.7);\n\treturn KAPPA * (smoothstep(p.y-s*cloud_height, p.y+s*cloud_height, cloudtop_y));\n}\n\n\n// return sun+sky radiance\nvec3 sky_color( in vec3 rd )\n{\n\tvec3 skyColor = vec3(0.6,0.71,0.78) - rd.y*0.25*vec3(1.0,0.5,1.0);\n\tfloat sp = dot(sun_direction(), rd) - cos(radians(5.0));\n\tvec3 sun = 2.0e6 * vec3(1.0,0.9,0.7) * pow(sp * step(0.0, sp), 2.3);\n\tskyColor += sun;\n\treturn skyColor;\n}\n\n\n// return radiance reaching the point pos from the sun\nvec3 reduced_sun( in vec3 pos )\n{\n\tconst int num_steps = 2;\n\tconst float max_dist = 10.0;\n\tfloat dl = max_dist/float(num_steps);\n\tfloat Transmittance = 1.0;\n\tfor(int i=0; i<num_steps; i++)\n\t{\n\t\tif(Transmittance < 0.001) break;\n\t\tpos += dl*sun_direction();\n\t\tfloat kappa = clouds_extinction( pos );\n\t\tTransmittance *= exp(-kappa*dl);\n\t}\n\treturn Transmittance * sky_color(sun_direction());\n}\n\n\n// Henyey-Greenstein phase function\nfloat phasefunction(in vec3 a, in vec3 b)\n{\n\tfloat mu = dot(a, b);\n\tfloat g = 0.25;\n\tfloat gSqr = g*g;\n\tfloat oofp = 1.0/(4.0*3.141592);\n\treturn oofp * (1.0 - gSqr) / pow(1.0 - 2.0*g*mu + gSqr, 1.5);\t\n}\n\n\n// raymarch to complete volume rendering integral\nvec3 primary( in vec3 ro, in vec3 rd )\n{\n\tconst float max_dist = 250.0;\n\tconst int num_steps = 64;\n\tfloat dl = max_dist/float(num_steps);\n\t\n\tvec3 pos = ro;\n\tfloat Transmittance = 1.0;\n\t\n\t// Calculate volume rendering integral along primary ray\n\tvec3 InScattered = vec3(0.0);\n\tfor(int i=0; i<num_steps; i++)\n\t{\n\t\tif(Transmittance < 0.01) break;\n\t\tpos += dl*rd;\n\t\tfloat kappa = clouds_extinction( pos );\n\t\tTransmittance *= exp(-kappa*dl);\n\t\t\n\t\t// single scattering given by in-scatter of sunlight\n\t\tconst vec3 albedo = vec3(0.85, 0.82, 0.79);\n\t\tvec3 single_scatt = albedo * kappa * dl * reduced_sun(pos) * phasefunction(sun_direction(), rd);\n\t\t\n\t\t// Fake multiple scattering by a constant emission field (power is an ad-hoc aesthetic tune-\n\t\t// though the power 1.0 possibly has some physical basis, since the diffuse light can be expected\n\t\t// to be roughly proportional to the density of scatterers\n\t\tvec3 fake_multiple_scatt = albedo * kappa * dl * pow(kappa/KAPPA, 1.0) * 2.5 * vec3(0.33, 0.35, 0.34);\n\t\t\n\t\t// Accumulate integrand\n\t\tInScattered += Transmittance * (single_scatt + fake_multiple_scatt);\n\t}\n\n\tvec3 AttenuatedBackground = Transmittance*sky_color(rd);\n\treturn InScattered + AttenuatedBackground;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x/ iResolution.y;\n    vec2 mo = -1.0 + 2.0*iMouse.xy / iResolution.xy;\n    \n    // camera\n    vec3 ro = 4.0*normalize(vec3(cos(2.75-3.0*mo.x), 1.5+(2.0*mo.y+1.0), sin(2.75-3.0*mo.x)));\n\tvec3 ta = vec3(0.0, 1.0, 0.0);\n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n\t// raymarch to obtain transmittance along ray through clouds\n    vec3 L = primary( ro, rd );\n\n    fragColor = vec4( L, 1.0 );\n}\n", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsXSz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 30, 53, 53, 92], [93, 93, 119, 119, 485], [542, 542, 564, 564, 672], [674, 742, 780, 780, 1384], [1387, 1414, 1444, 1444, 1678], [1681, 1736, 1769, 1769, 2125], [2128, 2164, 2207, 2207, 2366], [2369, 2419, 2459, 2459, 3630], [3632, 3632, 3689, 3689, 4311]], "test": "ok"}
{"id": "XsXXRN", "name": "Fire Shader", "author": "codevinsky", "description": "It's fire. Taken from the Phaser shader library", "tags": ["fire"], "likes": 41, "viewed": 2053, "published": "Public", "date": "1397169160", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n        float rand(vec2 n) {\n            return fract(cos(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n        }\n\n        float noise(vec2 n) {\n            const vec2 d = vec2(0.0, 1.0);\n            vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n            return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n        }\n\n        float fbm(vec2 n) {\n            float total = 0.0, amplitude = 1.0;\n            for (int i = 0; i < 4; i++) {\n                total += noise(n) * amplitude;\n                n += n;\n                amplitude *= 0.5;\n            }\n            return total;\n        }\n\n        void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n            const vec3 c1 = vec3(0.5, 0.0, 0.1);\n            const vec3 c2 = vec3(0.9, 0.0, 0.0);\n            const vec3 c3 = vec3(0.2, 0.0, 0.0);\n            const vec3 c4 = vec3(1.0, 0.9, 0.0);\n            const vec3 c5 = vec3(0.1);\n            const vec3 c6 = vec3(0.9);\n\t\t\t\n\t\t\tvec2 speed = vec2(0.7, 0.4);\n\t\t\tfloat shift = 1.6;\n\t\t\tfloat alpha = 1.0;\n\n            vec2 p = fragCoord.xy * 8.0 / iResolution.xx;\n            float q = fbm(p - iTime * 0.1);\n            vec2 r = vec2(fbm(p + q + iTime * speed.x - p.x - p.y), fbm(p + q - iTime * speed.y));\n            vec3 c = mix(c1, c2, fbm(p + r)) + mix(c3, c4, r.x) - mix(c5, c6, r.y);\n            fragColor = vec4(c * cos(shift * fragCoord.y / iResolution.y), alpha);\n        }", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsXXRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[10, 10, 30, 30, 115], [125, 125, 146, 146, 384], [394, 394, 413, 413, 658], [668, 668, 725, 725, 1459]], "test": "ok"}
