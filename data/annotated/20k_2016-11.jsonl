{"id": "4l3SR4", "name": "Vasarely - 4", "author": "FabriceNeyret2", "description": "From Vasarely kinetics period.\nsee [url]http://www.fondationvasarely.fr/fr/centre-architectonique/victor-vasarely/[/url]", "tags": ["pattern", "2tweets", "short", "vasarely", "copies", "reproductions"], "likes": 21, "viewed": 643, "date": "1478266028", "time_retrieved": "2024-06-20T18:43:49.963173", "image_code": "// NB: you can uncomment variants in the long version\n\n\n/** // -------------------  short version: 222 chars\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    float  x = abs(U= (U+U-(O.xy=iResolution.xy))/O.y * 8.).x, \n           l = ceil(max(x,abs(U.y))); //, e = 35./R.y;\n\n    U = abs( (2.*fract(U)-1.) * mat2( sin(iTime*exp(-l/2.7) + 1.57*vec4(1,2,0,1)) ) );\n\tO -= x<6. ? O- 1./(max(U.x,U.y)-.7)  :O;\n  //O -= x<6. ? O- smoothstep(-e,e, max(U.x,U.y)-.7)  :O; // antialiased\n}\n/**/\n\n\n/**/ // ---------------------------------------------- 271 chars\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n\tvec2 R = iResolution.xy, V;\n         U = (U+U-R)/R.y * 8.; V=ceil(abs(U));\n    O -= O; if (abs(U.x)>6.) return;\n    \n    float // l = length(U)/8.,                // L2 continuous warp\n          // l = length(ceil(U))/8.,          // L2 distance, odd center\n          // l = length(V)/8.,                // L2 distance, even center\n             l = max(V.x,V.y)/8.,             // L1 distance\n          // t = iTime*max(0.,1.-l/.8);\n             t = iTime*exp(-l*3.),\n             e = 35./R.y;\n \n    //         tiles              rotating\n    U = abs( (2.*fract(U)-1.) * mat2( sin(t+1.57*vec4(1,2,0,1)) ) );\n    \n\tO += smoothstep(-e,e, max(U.x,U.y)-.7) -O;\n    //O += .1/(max(U.x,U.y)-.8);\n}\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4l3SR4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4l3SRB", "name": "Nyan party! ~=[,,_,,]:3", "author": "Makio64", "description": "Lets party ! Shader made one year ago finally fixed to avoid the insane branching...", "tags": ["raymarching", "nyan", "cat", "party"], "likes": 15, "viewed": 323, "date": "1480126977", "time_retrieved": "2024-06-20T18:43:52.454314", "image_code": "// Rave Party\n// By David Ronai / @Makio64\n// write long time ago & just fixed it, not fully rewrite, sorry for the uglyness of it\n\n//------------------------------------------------------------------ VISUAL QUALITY\n\nprecision lowp float;\n#define POSTPROCESS\n#define RENDER_DEPTH\n#define RAYMARCHING_STEP 32\n#define RAYMARCHING_JUMP .85\n\n//------------------------------------------------------------------ MATRIX/OPERATIONS/PRIMARY Functions\n\nmat2 Rot2(float a ) {\n\tfloat c = cos( a );\n\tfloat s = sin( a );\n\treturn mat2( c, -s, s, c );\n}\n\nmat4 Rot4X(float a ) {\n\tfloat c = cos( a );\n\tfloat s = sin( a );\n\treturn mat4( 1, 0, 0, 0,\n\t\t\t\t 0, c,-s, 0,\n\t\t\t\t 0, s, c, 0,\n\t\t\t\t 0, 0, 0, 1 );\n}\n\nmat4 Rot4Y(float a ) {\n\tfloat c = cos( a );\n\tfloat s = sin( a );\n\treturn mat4( c, 0, s, 0,\n\t\t\t\t 0, 1, 0, 0,\n\t\t\t\t-s, 0, c, 0,\n\t\t\t\t 0, 0, 0, 1 );\n}\n\nmat4 Rot4Z(float a ) {\n\tfloat c = cos( a );\n\tfloat s = sin( a );\n\treturn mat4(\n\t\tc,-s, 0, 0,\n\t\ts, c, 0, 0,\n\t\t0, 0, 1, 0,\n\t\t0, 0, 0, 1\n\t);\n}\n\nmat4 matRotate( in vec3 xyz )\n{\n\tvec3 si = sin(xyz);\n\tvec3 co = cos(xyz);\n\treturn mat4( co.y*co.z,                co.y*si.z,               -si.y,       0.0,\n\t\t\t\t si.x*si.y*co.z-co.x*si.z, si.x*si.y*si.z+co.x*co.z, si.x*co.y,  0.0,\n\t\t\t\t co.x*si.y*co.z+si.x*si.z, co.x*si.y*si.z-si.x*co.z, co.x*co.y,  0.0,\n\t\t\t\t 0.0,                      0.0,                      0.0,        1.0 );\n}\n\nmat4 Loc4( vec3 p ) {\n\treturn mat4(\n\t\t1,  0,  0,  -p.x,\n\t\t0,  1,  0,  -p.y,\n\t\t0,  0,  1,  -p.z,\n\t\t0,  0,  0,  1\n\t);\n}\n\nmat4 _transpose(in mat4 m ) {\n\treturn mat4(\n\t\t vec4( m[0].x, m[1].x, m[2].x, m[3].x ),\n\t\t vec4( m[0].y, m[1].y, m[2].y, m[3].y ),\n\t\t vec4( m[0].z, m[1].z, m[2].z, m[3].z ),\n\t\t vec4( m[0].w, m[1].w, m[2].w, m[3].w )\n\t);\n}\n\nfloat sdCappedCylinder( in vec3 p, in vec2 h ) {\n\tvec2 d = abs(vec2(length(p.xz),p.y)) - h;\n\treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba) / dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n\tvec2 q = vec2( length(p.xz), p.y );\n\tfloat d1 = -p.y-c.z;\n\tfloat d2 = max( dot(q,c.xy), p.y);\n\treturn length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdSphere( vec3 p, float r ) {\n\treturn length(p) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdBoxRounded(vec3 p, vec3 b, float r) {\n\treturn length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sMinP( float a, float b, float k ) {\n\tfloat h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat opS( float a, float b ) {\n\treturn max( a, -b );\n}\n\nvec3 opTx( vec3 p, mat4 m ) {\n\treturn (transpose(m)*vec4(p,1.0)).xyz;\n}\n\nvec3 opRep( vec3 p, in vec3 spacing ) {\n    p.x = mod(p.x, spacing.x) - 0.5*spacing.x;\n    p.z = mod(p.z, spacing.z) - 0.5*spacing.z;\n\treturn p;\n}\n\nvec3 opRepY( vec3 p, in float spacingY ) {\n    p.y = mod(p.y, spacingY) - 0.5*spacingY;\n\treturn p;\n}\n\nvec3 opRepX( vec3 p, in float spacingX ) {\n    p.x = mod(p.x, spacingX) - 0.5*spacingX;\n\treturn p;\n}\n\nvec3 opRepZ( vec3 p, in float spacingZ ) {\n    p.z = mod(p.z, spacingZ) - 0.5*spacingZ;\n\treturn p;\n}\n\nvec2 opU( in vec2 v1, in vec2 v2){\n\t//Alternative wihout if.\n\treturn mix(v1,v2,clamp(sign(v1.x - v2.x),0.,1.));\n\t//return (v1.x<v2.x)?v1:v2;\n}\n\n//Mercury\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\n//------------------------------------------------------------------ MATERIALS\n\n#define BLACK 1.\n#define WHITE 2.\n#define BLUE 3.\n#define PINK 4.\n#define NYAN 5.\n#define NEON 6.\n\n\n//------------------------------------------------------------------ MAP\n\nvec3 posFromAngle(in float phi, in float theta, in float radius){\n\treturn vec3(\n\t\tradius * sin( phi ) * cos( theta ),\n\t\tradius * cos( phi ),\n\t\tradius * sin( phi ) * sin( theta )\n\t);\n}\n\nfloat freqs[4];\n\nfloat sdSimpleCat(in vec3 pos){\n    vec3 headPos = pos+vec3(0.,freqs[2]*.5,0.);\n    vec3 q = headPos - vec3(0.,6.,-3.);\n    pR(q.xz,.3);\n    pModInterval1(q.z,5.,0.,1.);\n    q.z -= .2;\n\tfloat hears = sdCone( q, vec3( 0.5, .3, 3.0 ));\n\tq = headPos;\n\tfloat head = min(hears,sdSphere(q,5.));\n    float body = sdCapsule(q, vec3( 0., -12., 0. ), vec3( 0., -12., 0.), 8.2 );\n\treturn sMinP(body, head, 5.);\n}\n\n// Return distance + material ID\nvec2 map( in vec3 pos )\n{\n    pos -= vec3(0.,freqs[3]*15.,0.);\n\tvec3 q = pos;\n\n    float screen;\n    if(freqs[3]<.6){\n\t\tscreen = sdBoxRounded(pos-vec3(-65.,16.,0.),vec3(1.,42.,100.),0.);\n  \t} else {\n        screen = sdSimpleCat((pos-vec3(-85.,56.,0.))/5.5)*6.;\n    }\n    vec2 nyan = vec2(screen, NYAN);\n    vec3 headPos = pos+vec3(0.,freqs[2]*.5,0.);\n    q = opTx( headPos - vec3(.5,5.2,-3.), Rot4X(.3) );\n\tfloat pinkHearL = sdCone( q, vec3( 0.5, .3, 3.0 ));\n\tq = opTx( headPos - vec3(.5,5.2,3.), Rot4X(-.3) );\n\tfloat pinkHearR = sdCone( q, vec3( 0.5, .3, 3.0 ));\n\tfloat pinkHears = min(pinkHearL,pinkHearR);\n\n\tq = opTx( headPos - vec3(0.,6.,-3.), Rot4X(.3) );\n\tfloat hearL = sdCone( q, vec3( 0.5, .3, 3.0 ));\n\tq = opTx( headPos - vec3(0.,6.,3.), Rot4X(-.3) );\n\tfloat hearR = sdCone( q, vec3( 0.5, .3, 3.0 ));\n\tfloat hears = min(hearR,hearL);\n\tpinkHears = max(pinkHears,hears);\n\thears = opS(hears,pinkHears);\n\n\tq = headPos;\n\tfloat head = min(hears,sdSphere(q,5.));\n\tfloat head2 = sdSphere(q,5.2);\n\tq = headPos;\n\tpinkHears = opS(pinkHears,head2);\n\tq = pos;\n\tfloat body = sdCapsule(q, vec3( 0., -12., 0. ), vec3( 0., -12., 0.), 8.2 );\n\tbody = sMinP(body, head, 5.);\n    \n    vec2 white = vec2(body,WHITE);\n\n\tfloat phi = freqs[3]*2.-1.;\n\n\tq = headPos - posFromAngle(phi+1.35,.3,5.);\n\tfloat eyeL = sdSphere(q,.3);\n\n\tq = headPos - posFromAngle(phi+1.35,-.3,5.);\n\tfloat eyeR = sdSphere(q,.3);\n\n    q = headPos - posFromAngle(1.54,1.54,5.3);\n\tfloat headphoneL = sdSphere(q,1.3);\n\n\tq = headPos - posFromAngle(1.54,-1.54,5.3);\n\tfloat headphoneR = sdSphere(q,1.3);\n    float headphones = min(headphoneL, headphoneR);\n    q = opTx( pos, Rot4Z(1.3) );\n    float bassin = sdTorus(q, vec2(5.7,.3));\n\t//headphones = min(bassin,headphones);\n    vec2 neon = vec2(headphones,NEON);\n\n\tfloat eyes = min(eyeL,eyeR);\n\tvec2 blue = vec2(eyes, BLUE);\n\tvec2 pink = vec2(min(bassin,pinkHears),PINK);\n\n\tq = pos - posFromAngle(phi+1.5,0.,5.1);\n\tfloat noze = sdSphere(q,.1);\n\n\tq = pos - posFromAngle(phi+1.5,.4,5.);\n\tq = opTx( q, Rot4X(-1.3) );\n\tfloat mustache = sdCappedCylinder(q, vec2(.05,2.5));\n\n\tq = pos - posFromAngle(phi+1.55,.4,5.);\n\tq = opTx( q, Rot4X(-1.4) );\n\tmustache = min(mustache,sdCappedCylinder(q, vec2(.05,2.5)));\n\n\tq = pos - posFromAngle(phi+1.6,.4,5.);\n\tq = opTx( q, Rot4X(-1.5) );\n\tmustache = min(mustache,sdCappedCylinder(q, vec2(.05,2.5)));\n\n\tq = pos - posFromAngle(phi+1.5,-.4,5.);\n\tq = opTx( q, Rot4X(1.3) );\n\tmustache = min(mustache,sdCappedCylinder(q, vec2(.05,2.5)));\n\n\tq = pos - posFromAngle(phi+1.55,-.4,5.);\n\tq = opTx( q, Rot4X(1.4) );\n\tmustache = min(mustache,sdCappedCylinder(q, vec2(.05,2.5)));\n\n\tq = pos - posFromAngle(phi+1.6,-.4,5.);\n\tq = opTx( q, Rot4X(1.5) );\n\tmustache = min(mustache,sdCappedCylinder(q, vec2(.05,2.5)));\n\n    \n    q = opTx( pos-vec3(-25.,17.,120.), Rot4Y(.2) );\n    float speakerL = sdBoxRounded(q,vec3(20.,50.,20.),0.1);\n    q = opRepY(pos-vec3(-20.,33.,120.),30.);\n    float speakerSphere = sdSphere(q,8.+(1.-freqs[1])*21.);\n    speakerL = opS(speakerL,speakerSphere);\n    white.x = min(speakerL,white.x);\n\n    q = opTx( pos-vec3(-25.,17.,-120.), Rot4Y(-.2) );\n    float speakerR = sdBoxRounded(q,vec3(20.,50.,20.),0.1);\n    q = opRepY(pos-vec3(-20.,33.,-120.),30.);\n    speakerSphere = sdSphere(q,8.+(1.-freqs[1])*21.);\n    speakerR = opS(speakerR,speakerSphere);\n\n    white.x = min(speakerR,white.x);\n\n    q = opRepZ(pos-vec3(-50.,120.-smoothstep(50.,130.,abs(pos.z))*30.,-70.),20.);\n\tfloat projectors = sdBoxRounded(q,vec3(freqs[1]*11.),3.);\n    neon.x = min(projectors,neon.x);\n\n    q = opRepZ(pos-vec3(-100.,20.,-50.),100.);\n   \tif(freqs[3]<.62){\n   \t\tq = opTx( q, Rot4X(freqs[2]*10.)*Rot4Y(freqs[3]*10.) );\n\t\tprojectors = sdBoxRounded(q,vec3(freqs[1]*30.),0.);\n  \t} else {\n    \tprojectors = sdSimpleCat(q/2.5)*6.;\n    }\n    neon.x = min(projectors,neon.x);\n\n    q = pos-vec3(19.,-15.,0.);\n    float table = sdBoxRounded(q,vec3(8.,5.5,20.),0.);\n\twhite.x = min(white.x,table);\n\n    q = pos-vec3(29.,-13.,0.);\n    float tableCat = sdSimpleCat(q/.25)*.25;\n\tneon.x = min(neon.x,tableCat);\n\n    q = pos-vec3(-25.,-50.,0.);\n    float stage = sdBoxRounded(q,vec3(30.,20.,200.),0.);\n\twhite.x = min(white.x,stage);\n\n    q = pos-vec3(17.,-14.,11.);\n    float dj = sdCappedCylinder(q,vec2(6.,5.3));\n    neon.x = min(dj,neon.x);\n    //white.x = min(dj,white.x);\n    q = pos-vec3(17.,-14.,-11.);\n    dj = sdCappedCylinder(q,vec2(6.,5.3));\n    neon.x = min(dj,neon.x);\n    //white.x = min(dj,white.x);\n\n\tvec2 black = vec2(min(noze,mustache),BLACK);\n    pos += vec3(0.,40.,0.);\n\n    if(pos.x>30.){\n    \tq = opRep(pos+vec3(0.,10.+cos(iTime*10.)*3.5,0.),vec3(60.,30.,60.));\n        float cats = sdSimpleCat(q);\n\n        q = opRep(pos+vec3(25.,10.+cos(iTime*10.+.5)*3.5,25.),vec3(30.,50.,60.));\n        cats = min(cats,sdSimpleCat(q));\n\n        q = opRep(pos+vec3(50.,10.+cos(iTime*10.+1.)*3.5,50.),vec3(30.,50.,20.));\n        cats = min(cats,sdSimpleCat(q));\n\n        white.x = min(white.x,cats);\n    }\n\n    vec2 infos = opU(white,blue);\n\tinfos = opU(infos,pink);\n\tinfos = opU(infos,black);\n    infos = opU(infos,nyan);\n    infos = opU(infos,neon);\n\treturn infos;\n}\n\n\n//------------------------------------------------------------------ RAYMARCHING / NORMAL / SHADOW ( call map )\n\n#ifdef RENDER_DEPTH\nvec2 castRay( in vec3 ro, in vec3 rd, inout float depth )\n#else\nvec2 castRay( in vec3 ro, in vec3 rd )\n#endif\n{\n\tfloat tmax = 800.;\n\tfloat precis = .01;\n\tfloat t = 0.0;\n\tvec2 res;\n\n\tfor( int i=0; i<RAYMARCHING_STEP; i++ )\n\t{\n\t\tvec3 pos = ro+rd*t;\n\t\tres = map( pos );\n\t\tif( res.x<precis || t>tmax ) break;\n\t\tt += res.x*RAYMARCHING_JUMP;\n\n\t\t#ifdef RENDER_DEPTH\n\t\tdepth += 1./float(RAYMARCHING_STEP);\n\t\t#endif\n\t}\n\treturn vec2( t, res.y );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tconst vec2 e = vec2(0.001,-0.001);\n\treturn normalize( e.xyy*map( pos + e.xyy ).x +\n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x +\n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x +\n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\n//------------------------------------------------------------------ RENDER\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 uv )\n{\n\tvec3 col;\n\n\t#ifdef RENDER_DEPTH\n\tfloat depth = 0.;\n\tvec2 res = castRay(ro,rd,depth);\n\t#else\n\tvec2 res = castRay(ro,rd);\n\t#endif\n\n\tfloat t = res.x;\n\tfloat m = res.y;\n\n\tvec3 pos = ro + t * rd;\n\tvec3 nor = calcNormal(pos);\n\t\tvec3 lig = vec3(0.6, 0.5, -0.5);\n\n    col = vec3(1.);\n\tcol *= clamp( dot( nor, lig ), 0.0, 1.0 )*vec3(1.);\n\tvec3 ambient = vec3(.3,.3,.4);\n\tcol += ambient*(1.-col);\n    \t\n    if( m == NYAN )\n\t{\n \t\tvec2 uv = vec2( .5+pos.z/100.-mod(iTime,1.0), 1.5*(pos.y+10.)/100. );\n        uv = mod(uv,vec2(1.));\n       \tfloat ww = 40.0/256.0;\n    \tfloat ofx = floor( mod( iTime*12.0, 6.0 ) );\n\t\tuv.x = uv.x*ww + ofx*ww;\n\t\tcol = texture( iChannel1, uv ).rgb * vec3(1.,.4,.4);\n   }\n    \n    if( m == NEON ){\n        col *= 1.3;\n    \tdepth *= 3.;\n    }\n    \n\tif(t>600.){\n\t\tcol = vec3(.1,.1,.1);\n\t}\n    else{\n\t#ifdef RENDER_DEPTH\n    \tvec3 depthColor = vec3(depth)*vec3(.8,.2,.1);\n    \tcol = mix(col,depthColor,freqs[0]);\n    #endif\n    }\n    col=mix(col,vec3(.1),smoothstep(1.1,1.6,depth));\n\treturn col;\n}\n\n\n//------------------------------------------------------------------ POSTEFFECTS\n\n#ifdef POSTPROCESS\n\nvec3 bw( in vec3 col )\n{\n\treturn vec3(0.299*col.r + 0.587*col.g + 0.114*col.b);\n}\n\nvec3 postEffects( in vec3 col, in vec2 uv, in float time )\n{\n    if(freqs[3]>.65){\n\t\tcol = bw( col*1.5 );\n    }\n\n\t// vigneting\n\tcol *= 0.25+0.75*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.15 );\n\n\treturn col;\n}\n\n#endif\n\n\n//------------------------------------------------------------------ CAMERA\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\treturn mat3( cu, cv, cw );\n}\n\n\n//------------------------------------------------------------------ MAIN\n\nvoid mainImage( out vec4 fragColor, in vec2 coords )\n{\n    freqs[0] = texture( iChannel0, vec2( 0.01, 0.25 ) ).x;\n\tfreqs[1] = texture( iChannel0, vec2( 0.1, 0.3 ) ).x;\n\tfreqs[2] = texture( iChannel0, vec2( 0.15, 0.25 ) ).x;\n\tfreqs[3] = texture( iChannel0, vec2( 0.2, 0.05 ) ).x;\n\n\tfloat time = mod(iTime,100.);\n\tvec2 uv = coords.xy / iResolution.xy;\n\tvec2 mouse = iMouse.xy/iResolution.xy;\n\n\tvec2 q = coords.xy/iResolution.xy;\n\tvec2 p = (-iResolution.xy+2.0*coords.xy)/iResolution.y;\n\n    //Close camera\n\tfloat angle = 0.;\n\tfloat radius = 1.+freqs[2]*freqs[2]*250.;\n    vec3 ro = vec3(cos(angle)*radius,cos(time/3.)*4.+9.,sin(angle)*radius);\n    vec3 ta = vec3(0.);\n\n    //Far camera\n    angle = sin(iTime)*.3;\n    radius += 70.+freqs[2]*freqs[2]*380.;\n    vec3 ro2 = vec3(cos(angle)*radius,cos(time/3.)*4.+50.,sin(angle)*radius);\n\n    //Select the camera\n    float s = sign(freqs[3] - .5);\n    ro = mix(ro,ro2,clamp(s,0.,1.));\n\n\tmat3 ca = setCamera( ro, ta, 0. );\n\tvec3 rd = ca * normalize( vec3(p.xy,1.5) );\n\n\tvec3 color = render( ro, rd, uv );\n\n\t#ifdef POSTPROCESS\n\tcolor = postEffects( color, uv, time );\n\t#endif\n\tfragColor = vec4(color,1.0);\n}\n", "image_inputs": [{"id": "Xsf3Rn", "previewfilepath": "/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture"}, {"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4l3SRB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4l3SRM", "name": "Billows-0", "author": "lukexi", "description": "billowing colors", "tags": ["noise"], "likes": 7, "viewed": 170, "date": "1478558468", "time_retrieved": "2024-06-20T18:43:53.375531", "image_code": "\n// Author: \n// Title: \n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v) { \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\n// Smooth HSV to RGB conversion \nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat fbm(vec3 domain) {\n    vec2 st = domain.xy;\n    float time = domain.z;\n    \n    const float octaves = 5.;\n    float f = 0.;\n    for (float i = 0.; i < octaves; i++) {\n        float scale = pow(2.,i);\n        f += snoise(vec3(st*scale, time)) * 1./scale;\n    }\n    return f;\n}\n\nfloat circle(vec2 st) {\n    return length(st) - abs(sin(iTime*0.1))*2.;\n}\n\nfloat smoothedge(float v) {\n    return smoothstep(0.0, 1.0 / iResolution.x, v);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float phase = mod(iTime, 1.0);\n    \n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n\t\n    // Domain warping\n    float angle = fbm(vec3(st*3.,iTime*0.1))*2.*3.1415;\n    float angleScale = 0.02;\n    vec2 offset = vec2(sin(angle), cos(angle)) * angleScale;\n    st+=offset;\n    \n    // st = vec2(snoise(vec3(st*5.,u_time*0.1)), snoise(vec3(st*5., u_time*0.1)));\n    \n    vec3 tex = vec3(smoothedge(circle(st-0.5)));\n    \n    float f = fbm(vec3(st*3., iTime*0.05));\n    float f2 = fbm(vec3(st*4., iTime*0.05));\n    vec3 color = hsv2rgb_smooth(vec3(f, f2, 0.5));\n    // color = vec3(st.x,st.y,abs(sin(u_time)));\n    \n    color = mix(color, vec3(0.), tex.x);\n\n    fragColor = vec4(color,1.0);\n    \n    // fragColor = vec4(tex,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4l3SRM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4l3SzH", "name": "Tunnel Beauty 6", "author": "aiekick", "description": "i have the limit of the float after a certain time, and some noise appears :)\nyou can increase the iteration at line 86 to have better shape but more slow too :) ", "tags": ["tunnelbeauty6"], "likes": 49, "viewed": 2854, "date": "1478916114", "time_retrieved": "2024-06-20T18:43:54.054294", "image_code": "// Created by Stephane Cuillerdier - @Aiekick/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nmat3 RotZ(float a)\n{\n    return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);\n}\n\nfloat df(vec3 p)\n{\n\tvec3 q = p;\n    //q += sin(iTime*0.2)*40.;\n    //q.xy += cos(iTime * 0.2);\n\tq *= RotZ(q.z * 0.1);\n    q += sin(q.zxy * 0.5) * 0.5;\n\tq *= RotZ(q.z * 0.2);\n    q = sin(q.zxy * 0.2) * 1.5;\n    p += q;\n\tp *= RotZ(p.z * 0.045);\n    return 10. - abs(p.y*0.5);\n}\n\nvec3 nor( vec3 pos, float prec )\n{\n\tvec3 eps = vec3( prec, 0., 0. );\n\tvec3 nor = vec3(\n\t    df(pos+eps.xyy) - df(pos-eps.xyy),\n\t    df(pos+eps.yxy) - df(pos-eps.yxy),\n\t    df(pos+eps.yyx) - df(pos-eps.yyx) );\n\treturn normalize(nor);\n}\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// get density of the df at surfPoint\n// ratio between constant step and df value\nfloat SubDensity(vec3 surfPoint, float prec, float ms) \n{\n\tvec3 n;\n\tfloat s = 0.;\n    const int iter = 10;\n\tfor (int i=0;i<iter;i++)\n\t{\n\t\tn = nor(surfPoint,prec); \n\t\tsurfPoint = surfPoint - n * ms; \n\t\ts += df(surfPoint);\n\t}\n\t\n\treturn 1.-s/(ms*float(iter)); // s < 0. => inside df\n}\n\nfloat SubDensity(vec3 p, float s) \n{\n\tvec3 n = nor(p,s); \t\t\t\t\t\t\t// precise normale at surf point\n\treturn df(p - n * s);\t\t\t\t\t\t// ratio between df step and constant step\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 g = fragCoord;\n\tvec2 si = iResolution.xy;\n\tvec2 uv = (g+g-si)/si.y;\n\tvec3 ro = vec3(0,0, iTime * 15.); \n    vec3 cv = ro + vec3(0,0,1); \n\tvec3 cu = normalize(vec3(0,1,0));\n  \tvec3 z = normalize(cv-ro);\n    vec3 x = normalize(cross(cu,z));\n  \tvec3 y = cross(z,x);\n    float fov = .9;\n  \tvec3 rd = normalize(fov * (uv.x * x + uv.y * y) + z);\n\t\n\tfloat s = 1., d = 0.;\n\tfor (int i=0; i<90; i++) \n\t{\n\t\tif (log(d*d/s/1e5)>0.) break;\n\t\td += (s=df(ro+rd*d))*.2;\n\t}\n\t\n\tvec3 p = ro + rd * d;\t\t\t\t\t\t\t\t\t\t\t// surface point\n\tvec3 lid = normalize(ro-p); \t\t\t\t\t\t\t\t\t// light dir\n\tvec3 n = nor(p, 0.1);\t\t\t\t\t\t\t\t\t\t\t// normal at surface point\n\tvec3 refl = reflect(rd,n);\t\t\t\t\t\t\t\t\t\t// reflected ray dir at surf point \n\tfloat diff = clamp( dot( n, lid ), 0.0, 1.0 ); \t\t\t\t\t// diffuse\n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 4. ); \t\t\t// fresnel\n\tfloat spe = pow(clamp( dot( refl, lid ), 0.0, 1.0 ),16.);\t\t// specular\n\tvec3 col = vec3(.8,.5,.2);\n    \n    // here the magic happen\n\tfloat sss = df(p - n*0.001)/0.1;\t\t\t\t\t\t\t\t// quick sss 0.001 of subsurface\n\t\n\tfloat sb = SubDensity(p, 0.01, 0.1);\t\t\t\t\t\t\t// deep subdensity from 0.01 to 0.1 (10 iterations)\n\tvec3 bb = clamp(blackbody(200. * sb),0.,1.);\t\t\t\t\t// blackbody color\n\tfloat sss2 = 0.8 - SubDensity(p, 3.); \t\t\t\t\t\t\t// one step sub density of df of 3 of subsurface\n\t\n    fragColor.rgb = (diff + fre + bb * sss2 * .8 + col * sss * .2) * 0.25 + spe * 1.2;\n\n\t// vigneting from iq Shader Mike : https://www.shadertoy.com/view/MsXGWr\n    vec2 q = g/si;\n    fragColor.rgb *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.55 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4l3SzH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4l3Xz2", "name": "Sin and Polar Study", "author": "Homaniac", "description": "Result of practicing shaping and phasing functions with sin and using mod space of polar coordinates.\nTry changing some of the #define variables. Higher values for SIN_AMP_MAX produce interesting results.", "tags": ["waves", "sin", "animated", "polar"], "likes": 5, "viewed": 142, "date": "1480483874", "time_retrieved": "2024-06-20T18:43:54.054294", "image_code": "#define PI 3.14159265359\n#define NUM_PI_DIVS 8.0\n\n#define PI_DIV PI/NUM_PI_DIVS\n#define HALF_PI_DIV PI_DIV*0.5\n#define THIRD_PI_DIV PI_DIV/3.0\n\n#define SMOOTH_HALF_INTERVAL HALF_PI_DIV*0.5\n\n#define SIN_AMP_MAX HALF_PI_DIV*0.5\n#define SIN_AMP_TIME_AMP 5.0\n#define SIN_FREQ_MAX 100.0\n#define SIN_FREQ_TIME_AMP 0.5\n\n#define SIN_TIME_AMP 10.0\n#define MOD_TIME_AMP 0.5\n\nfloat plot(float pct, vec2 st){\n  return smoothstep(pct - SMOOTH_HALF_INTERVAL, pct, st.y)\n      - smoothstep(pct, pct + SMOOTH_HALF_INTERVAL, st.y);\n}\n\nfloat computeAmp(float time_factor) {\n  return SIN_AMP_MAX*(sin(iTime*time_factor*SIN_AMP_TIME_AMP)/2.0 + 0.5);\n}\n\nfloat posSin(float x) {\n  return (sin(x)/2.0 + 0.5);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 st = vec2(fragCoord.x /iResolution.x, fragCoord.y/iResolution.y);\n  st = (st - 0.5) * 2.0;\n\n  // Determine the polar coordinate\n  float oTheta = atan(st.y, st.x);\n  float r = length(st);\n\n  float theta = mod(oTheta + iTime*MOD_TIME_AMP, PI_DIV) - HALF_PI_DIV;\n  float theta2 = mod(oTheta - THIRD_PI_DIV + iTime*MOD_TIME_AMP*2.0/3.0, PI_DIV) - HALF_PI_DIV;\n  float theta3 = mod(oTheta - 2.0*THIRD_PI_DIV + iTime*MOD_TIME_AMP/3.0, PI_DIV) - HALF_PI_DIV;\n\n  float freq = SIN_FREQ_MAX*posSin(iTime*SIN_FREQ_TIME_AMP);\n\n  float ampR = computeAmp(1.0/3.0);\n  float ampG = computeAmp(2.0/3.0);\n  float ampB = computeAmp(1.0);\n\n  float polarPct = plot(ampR*sin(r*freq - iTime*SIN_TIME_AMP), vec2(theta));\n  float polarPct2 = plot(ampG*sin(r*freq - iTime*SIN_TIME_AMP/3.0), vec2(theta2));\n  float polarPct3 = plot(ampB*sin(r*freq - iTime*SIN_TIME_AMP*2.0/3.0), vec2(theta3));\n\n  vec3 color = vec3(polarPct, polarPct2, polarPct3);\n  // vec3 color = vec3(polarPct*posSin(iTime*2.0/3.0), polarPct2*posSin(iTime), polarPct3*posSin(iTime/3.0));\n\n  fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4l3Xz2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4l3Xz4", "name": "IQ's solids with SSAA and DoF", "author": "pyrite", "description": "*YOU WILL NEED TO EDIT THE CODE*\nThe number of points on the lens of the render camera has been reduced to 2.\nBefore modifying the code, pause the renderer. Increase N until the blur looks smooth, enjoy!\nLine 327 \"const int lensRes = N;\" ", "tags": ["example", "dof", "camera", "iq", "ssaa"], "likes": 4, "viewed": 464, "date": "1479885507", "time_retrieved": "2024-06-20T18:43:55.969747", "image_code": "// Created by inigo quilez - iq/2013\n// Modified by pyrite \n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// A list of usefull distance function to simple primitives, and an example on how to \n// do some interesting boolean operations, repetition and displacement.\n//\n// More info here: http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2 )\n{\n    float d1 = -p.y - h;\n    float q = p.y - h;\n    float si = 0.5*(r1-r2)/h;\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length2(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length8(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n  return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//----------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n//----------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = opU( vec2( sdPlane(     pos), 1.0 ),\n\t                vec2( sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ), 46.9 ) );\n    res = opU( res, vec2( sdBox(       pos-vec3( 1.0,0.25, 0.0), vec3(0.25) ), 3.0 ) );\n    res = opU( res, vec2( udRoundBox(  pos-vec3( 1.0,0.25, 1.0), vec3(0.15), 0.1 ), 41.0 ) );\n\tres = opU( res, vec2( sdTorus(     pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), 25.0 ) );\n    res = opU( res, vec2( sdCapsule(   pos,vec3(-1.3,0.10,-0.1), vec3(-0.8,0.50,0.2), 0.1  ), 31.9 ) );\n\tres = opU( res, vec2( sdTriPrism(  pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ),43.5 ) );\n\tres = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.30,-1.0), vec2(0.1,0.2) ), 8.0 ) );\n\tres = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), 55.0 ) );\n\tres = opU( res, vec2( sdTorus82(   pos-vec3( 0.0,0.25, 2.0), vec2(0.20,0.05) ),50.0 ) );\n\tres = opU( res, vec2( sdTorus88(   pos-vec3(-1.0,0.25, 2.0), vec2(0.20,0.05) ),43.0 ) );\n\tres = opU( res, vec2( sdCylinder6( pos-vec3( 1.0,0.30, 2.0), vec2(0.1,0.2) ), 12.0 ) );\n\tres = opU( res, vec2( sdHexPrism(  pos-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ),17.0 ) );\n\n    res = opU( res, vec2( opS(\n\t\t             udRoundBox(  pos-vec3(-2.0,0.2, 1.0), vec3(0.15),0.05),\n\t                 sdSphere(    pos-vec3(-2.0,0.2, 1.0), 0.25)), 13.0 ) );\n    res = opU( res, vec2( opS(\n\t\t             sdTorus82(  pos-vec3(-2.0,0.2, 0.0), vec2(0.20,0.1)),\n\t                 sdCylinder(  opRep( vec3(atan(pos.x+2.0,pos.z)/6.2831,\n\t\t\t\t\t\t\t\t\t\t\t  pos.y,\n\t\t\t\t\t\t\t\t\t\t\t  0.02+0.5*length(pos-vec3(-2.0,0.2, 0.0))),\n\t\t\t\t\t\t\t\t\t     vec3(0.05,1.0,0.05)), vec2(0.02,0.6))), 51.0 ) );\n\tres = opU( res, vec2( 0.7*sdSphere(    pos-vec3(-2.0,0.25,-1.0), 0.2 ) + \n\t\t\t\t\t                   0.03*sin(50.0*pos.x)*sin(50.0*pos.y)*sin(50.0*pos.z), \n                                       65.0 ) );\n\tres = opU( res, vec2( 0.5*sdTorus( opTwist(pos-vec3(-2.0,0.25, 2.0)),vec2(0.20,0.05)), 46.7 ) );\n\n    res = opU( res, vec2(sdConeSection( pos-vec3( 0.0,0.35,-2.0), 0.15, 0.2, 0.1 ), 13.67 ) );\n\n    res = opU( res, vec2(sdEllipsoid( pos-vec3( 1.0,0.35,-2.0), vec3(0.15, 0.2, 0.05) ), 43.17 ) );\n        \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n#if 0\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n\tfloat precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n\t\t\n        if( m<1.5 )\n        {\n            \n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.4 + 0.1*f*vec3(1.0);\n        }\n\n        // lighitng        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.20*dif*vec3(1.00,0.85,0.55);\n\t\tlin += 1.20*spe*vec3(1.00,0.85,0.55)*dif;\n        lin += 0.20*amb*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*dom*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.002*t*t ) );\n\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//THIS v\n    const int lensRes = 2; //THIS < changes the smoothness of the DoF blur\n    const int ssaa = 1; // THIS < changes the quality of the rendered pixels (keep low for this demo)\n    float lensDis = 1.0; //THIS < ajusts the \"zoom\" of the virtual camera\n    float lensSiz = 0.2; //THIS < ajusts the size of the DoF blur\n    float focalDis = 5.0; //THIS < controls the location of the focal plane\n    //THIS ^\n    \n\tvec2 sensorLoc = fragCoord.xy / iResolution.x; //sets x limits from 0-1 y at same scale, center at (0.5,~0.5)\n    sensorLoc = vec2(0.5, 0.5*(iResolution.y/iResolution.x)) - sensorLoc; //reverse sensor and center on (0,0)\n    \n    vec3 Y = vec3(0.0,1.0,0.0); //useful later could be hardcoded later instead\n    float an = 0.5*iTime + 2.0*iMouse.x/iResolution.x; //movement of camera\n    \n    vec3 cameraPos = 5.0*vec3(1.0*cos(an),0.4,1.0*sin(an)); //this is not normalized\n    vec3 cameraTar = vec3(-0.5,0.0,0.5); //camera target\n    vec3 cameraDir = cameraTar-cameraPos; //this will and should be normalized\n    cameraDir = normalize(cameraDir); //normalize\n    \n    vec3 cameraX = cross(cameraDir,Y); //x dir for camera\n    cameraX = normalize(cameraX); //normalize\n    \n    vec3 cameraZ = cross(cameraX,cameraDir); //z dir for camera\n    cameraZ = normalize(cameraZ); //normlize\n\t\n    vec3 colorTotal = vec3(0.0,0.0,0.0);\n    const float lensResF = float(lensRes); //for comparing to float later\n    float focal = 1.0+lensDis/focalDis; //brings the image to focus at focalDis from the cameraPos\n    float ssaaF = float(ssaa); // for using later to save a cast.\n    float sscale = 1.0/(iResolution.x*2.0*ssaaF); // size of a pixel ssaa step\n    \n    for (int sx = 0; sx < ssaa; sx++){ //SSAA x direction\n    \tfor (int sy = 0; sy < ssaa; sy++){ //SSAA y direction\n            \n        \tfloat ssx = float(2*sx+1-ssaa)*sscale; //sub pixel offset for SSAA\n            float ssy = float(2*sy+1-ssaa)*sscale; //sub pixel offset for SSAA\n            vec3 sensorRel = cameraX*(sensorLoc.x+ssx) + cameraZ*(sensorLoc.y+ssy); //position on sensor relative to center of sensor. Used once\n            vec3 sensorPos = cameraPos - lensDis*cameraDir + sensorRel; //3d position of ray1 origin on sensor\n            \t\n            for (float xcount = 0.5; xcount <= lensResF; xcount++){\n        \t\tfor (float ycount = 0.5; ycount <= lensResF; ycount++){\n                    \n            \t\tvec2 lensCoord = vec2(xcount/lensResF,ycount/lensResF); //fragCoord analog for lens array. lens is square\n        \t\t\tvec2 lensLoc = (lensCoord-vec2(0.5,0.5))*lensSiz; //location on 2d lens plane\n            \t\t\n                    if (length(lensLoc)<(lensSiz/2.0)){\n                        \n                \t\tvec3 lensRel = cameraX*(lensLoc.x) + cameraZ*(lensLoc.y); //position on lens relative to lens center. Used twice\n            \t\t\tvec3 lensPos = cameraPos + lensRel; // 3d position of ray1 end and ray2 origin on lens\n            \t\t\tvec3 rayDir1 = lensPos - sensorPos; //direction of ray from sensor to lens\n            \t\t\tvec3 rayDir2 = rayDir1 - focal*(lensRel); //direction of ray afer being focused by lens\n            \t\t\trayDir2 = normalize(rayDir2); //normalize after focus \n            \t\t\tvec3 color = render(lensPos,rayDir2); //scene returns a color\n            \t\t\tcolorTotal = colorTotal+color; //sum colors over all  points from lens\n                    }\n                }\n            }\n        }\n    }\n    \n    fragColor = vec4(colorTotal/(lensResF*lensResF)/(ssaaF*ssaaF)+0.1,0.0); //slight post-processing\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4l3Xz4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lcSWM", "name": "2d distance field", "author": "polyrhythm", "description": "playing distance field animation", "tags": ["2d", "distancefields"], "likes": 2, "viewed": 108, "date": "1479784052", "time_retrieved": "2024-06-20T18:43:55.975748", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 p = -1.0 + 2.0 * uv;\n\tp.x *= iResolution.x / iResolution.y;\n\n\tvec3 colour = vec3(0.0);\n\tfloat d;\n\n\td = length(p);\n\n\tcolour = vec3(fract(d * abs(cos(iTime))),\n\t   \t\t\t  1.0 - fract(d * 10.0) + abs(sin(iTime)),\n\t\t\t\t  fract(d * abs(sin(iTime)) + 0.5));\n\n\tfragColor = vec4(colour, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lcSWM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lcXW7", "name": "Simple Trap", "author": "docwhite", "description": "Trying to get a very simple example showing traps for learning purposes.", "tags": ["simple", "learning", "trap"], "likes": 4, "viewed": 455, "date": "1479834610", "time_retrieved": "2024-06-20T18:43:55.975748", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.0);\n    \n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n\tfloat zoo = 0.01;\n    \n\tvec2 cc = vec2(-0.533516,0.526141) + p*zoo;\n\n\tvec2 t2c = vec2(cos(iTime), sin(iTime));\n\t\t\n    vec2 z  = vec2(0.0);\n\tfloat trap = 1000.0;\n    \n    for( int i=0; i<200; i++ )\n    {\n        if( dot(z,z)>1024.0 ) break;\n        z = cc + vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ); // Z -> ZÂ² + c\t\n\t\ttrap = min( trap, dot(z-t2c,z-t2c) );\n    }\n\n\tcol += trap;\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lcXW7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4ldSRN", "name": "Shadertoy4Android app", "author": "flockaroo", "description": "I accidentally wrote a Shadertoy App for Android...\nYou can download it here: [url]http://www.flockaroo.at/shadertoy4android.php[/url]\nStill very rudimentary, so some bugs might crawl out here and there, but many shaders should work.\n", "tags": ["shadertoy", "app", "android"], "likes": 4, "viewed": 768, "date": "1478473220", "time_retrieved": "2024-06-20T18:43:57.242570", "image_code": "// I accidentally wrote a Shadertoy App for Android.\n// So this is just an announcement.\n// download Shadertoy for Android here:\n// http://flockaroo.at/downloads/shadertoy4android-debug.apk\n\nint getDigitMask(int d)\n{\n    if(d==0x0) return 0x00EAAAE;\n    if(d==0x1) return 0x004C444;\n    if(d==0x2) return 0x00E2E8E;\n    if(d==0x3) return 0x00E2E2E;\n    if(d==0x4) return 0x00AAE22;\n    if(d==0x5) return 0x00E8E2E;\n    if(d==0x6) return 0x00E8EAE;\n    if(d==0x7) return 0x00E2222;\n    if(d==0x8) return 0x00EAEAE;\n    if(d==0x9) return 0x00EAE2E;\n    if(d==0xa) return 0x004AAEA;\n    if(d==0xb) return 0x00CACAC;\n    if(d==0xc) return 0x0068886;\n    if(d==0xd) return 0x00CAAAC;\n    if(d==0xe) return 0x00E8C8E;\n    if(d==0xf) return 0x00E8C88;\n    return -1;\n}\n\n\n#define O_ 0x10\n#define I_ 0x11\n#define Z_ 0x12\n#define M_ 0x13\n#define H_ 0x14\n#define S_ 0x15\n#define G_ 0x16\n#define L_ 0x17\n#define X_ 0x18\n#define Q_ 0x19\n#define A_ 0x1A\n#define B_ 0x1B\n#define C_ 0x1C\n#define D_ 0x1D\n#define E_ 0x1E\n#define F_ 0x1F\n#define J_ 0x21\n#define N_ 0x22\n#define W_ 0x23\n#define K_ 0x24\n#define U_ 0x25\n#define P_ 0x26\n#define V_ 0x27\n#define T_ 0x28\n#define Y_ 0x29\n#define R_ 0x2A\n#define dot_ 0x30\n#define dot2_ 0x31\n#define space_ 0x32\n#define minus_ 0x33\n\nint getLetterMask(int d)\n{\n    if(d==O_) return 0x004AAA4; // O\n    if(d==I_) return 0x00E444E; // I\n    if(d==Z_) return 0x00E248E; // Z\n    if(d==M_) return 0x00AEEAA; // M\n    if(d==H_) return 0x00AAEAA; // H\n    if(d==S_) return 0x00E8E2E; // S\n    if(d==G_) return 0x00E8AAE; // G\n    if(d==L_) return 0x008888E; // L\n    if(d==X_) return 0x00EAEAE; // X\n    if(d==Q_) return 0x004AAA6; // q\n    if(d==A_) return 0x004AAEA; // A\n    if(d==B_) return 0x00CACAC; // B\n    if(d==C_) return 0x0068886; // C\n    if(d==D_) return 0x00CAAAC; // D\n    if(d==E_) return 0x00E8C8E; // E\n    if(d==F_) return 0x00E8C88; // F\n    if(d==J_) return 0x00E222C; // J\n    if(d==N_) return 0x00CAAAA; // N\n    if(d==W_) return 0x00AAEEA; // W\n    if(d==K_) return 0x00AAEAA; // K\n    if(d==U_) return 0x00AAAAE; // U\n    if(d==P_) return 0x00CAAC8; // P\n    if(d==V_) return 0x00AAAA4; // V\n    if(d==T_) return 0x00E4444; // T\n    if(d==Y_) return 0x00AAE44; // Y\n    if(d==R_) return 0x00CAACA; // R\n    if(d==dot_) return 0x0000004; // .\n    if(d==dot2_) return 0x0004004; // :\n    if(d==space_) return 0x0000000; // _\n    if(d==minus_) return 0x0000E00; // _\n    return getDigitMask(d);\n}\n\n\nvoid drawLetter(int n, vec2 pos, float size, inout vec4 fragColor, vec2 fragCoord)\n{\n    int m = getLetterMask(n);\n    int j=int((fragCoord-pos).y/size);\n    int i=int((fragCoord-pos).x/size);\n    if(i>=0 && i<4 && j>=0 && j<6)\n        //if(((m>>(4*j-i))&1)==1) fragColor=vec4(1);\n        if(int(mod(float(m)/pow(2.0,float(4*j-i)),2.0))==1) fragColor=vec4(1);\n}\n\nvoid drawText(mat4 str, vec2 pos, float size, inout vec4 fragColor, vec2 fragCoord)\n{\n    for(int i=0;i<4;i++)\n    {\n        bool breakIt=false;\n        for(int j=0;j<4;j++)\n        {\n            if(int(str[i][j])<0) { breakIt=true; break; }\n            drawLetter(int(str[i][j]),pos+size*vec2(4.0*float(i*4+j),0),size,fragColor,fragCoord);\n        }\n        if(breakIt) break;\n    }\n}\n\nvoid drawDigit(int n, vec2 pos, float size, inout vec4 fragColor, vec2 fragCoord)\n{\n    int m = getDigitMask(n);\n    int j=int((fragCoord-pos).y/size);\n    int i=int((fragCoord-pos).x/size);\n    if(i>=0 && i<4 && j>=0 && j<6)\n        //if(((m>>(4*j-i))&1)==1) fragColor=vec4(1);\n        if(int(mod(float(m)/pow(2.0,float(4*j-i)),2.0))==1) fragColor=vec4(1);\n}\n\nint getDigit(int n, int d)\n{\n    return int(mod(float(n)/pow(10.0,float(d)),10.0));\n}\n\nint getDigitF(float f, int d)\n{\n    if(d<0) return int(mod(f/pow(0.1,float(-d)),10.0));\n    return int(mod(f/pow(10.0,float(d)),10.0));\n}\n\nvoid drawInt(int n, vec2 pos, float size, inout vec4 fragColor, vec2 fragCoord )\n{\n    int n2 = 10;\n    int dn=0;\n    for(int i=0;i<100;i++) { if(n2-1>=n) {dn=i+1; break;} n2*=10; }\n    for(int i=0;i<100;i++)\n    {\n        if(i==dn) break;\n        drawDigit(getDigit(n,dn-1-i), pos, size, fragColor, fragCoord );\n        pos+=vec2(4.0*size,0);\n    }\n}\n\n\nvoid drawFloat(float f, int dotnum, vec2 pos, float size, inout vec4 fragColor, vec2 fragCoord )\n{\n    int n2 = 10;\n    int dn=0;\n    if(f<0.0) { f=-f; drawLetter(minus_, pos, size, fragColor, fragCoord); pos+=vec2(4.0*size,0); }\n    for(int i=0;i<100;i++) { if(float(n2-1)>=f) {dn=i+1; break;} n2*=10; }\n    for(int i=0;i<100;i++)\n    {\n        int d;\n        if      (i<dn)  d=getDigitF(f,dn-1-i);\n        else if (i==dn) d=dot_;\n        else if (i>dn)  d=getDigitF(f,dn-1-i+1);\n        if(i==dn+dotnum+1) break;\n        drawLetter(d, pos, size, fragColor, fragCoord );\n        pos+=vec2(4.0*size,0);\n    }\n}\n\nvoid drawBox(float x, float y, float sx, float sy, inout vec4 col, vec2 coord)\n{\n    coord-=vec2(x,y);\n    vec4 dcol = vec4(1);\n    dcol *= 1.-smoothstep( sx-.01, sx+.01,coord.x);\n    dcol *=    smoothstep(-sx-.01,-sx+.01,coord.x);\n    dcol *= 1.-smoothstep( sy-.01, sy+.01,coord.y);\n    dcol *=    smoothstep(-sy-.01,-sy+.01,coord.y);\n    col+=dcol;\n}\n\nvoid drawHalfCircle(float x, float y, float r, inout vec4 col, vec2 coord)\n{\n    coord-=vec2(x,y);\n    vec4 dcol = vec4(1);\n    float l=length(coord);\n    dcol *= 1.0-smoothstep(r-.01,r+.01,l);\n    dcol *= smoothstep(-.01,+.01,coord.y);\n    col+=dcol;\n}\n\nvoid drawAndroid(float x, float y, float sx, float sy, inout vec4 col, vec2 coord)\n{    \n    coord = (coord-vec2(x,y))/vec2(sx,sy);\n    float ang = .3*cos(iTime*5.);\n    coord = vec2(coord.x*cos(ang)+coord.y*sin(ang),-coord.x*sin(ang)+coord.y*cos(ang));\n    \n    drawHalfCircle(0.,1.,.9,col,coord);\n    drawBox(0.,0.,.9,.9,col,coord);\n    drawBox( 1.25,0.,.2,.8,col,coord);\n    drawBox(-1.25,0.,.2,.8,col,coord);\n    drawBox(-.5,-1.3,.2,.3,col,coord);\n    drawBox( .5,-1.3,.2,.3,col,coord);\n}\n\n#define Res vec2(iResolution.xy)\n\nvec3 maskRGBGrid(vec3 col, vec2 coord,vec2 scrRes)\n{\t\n    if(fract(coord.x/Res.x*scrRes.x)<0.33) return col*vec3(1,0,0);\n    if(fract(coord.x/Res.x*scrRes.x)<0.66) return col*vec3(0,1,0);\n    return col*vec3(0,0,1);\n}\n\nfloat fermi(float x)\n{\n    return 1./(1.+exp(x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float offTime=1200000.;\n    float offdt=iTime-offTime;\n    float s=iResolution.x*0.013;\n    s*=fermi(offdt/0.07)+0.7*exp(-offdt*offdt/0.1/0.1);\n    vec2 c=iResolution.xy*0.5;\n    float l1=9.0;\n    float l2=3.0;\n    float l3=7.0;\n    vec4 col=vec4(0.0);\n    vec2 coord = (fragCoord-c);\n    coord+=dot(coord,coord)*coord/iResolution.x/iResolution.x*0.9;\n    coord+=c;\n    float coordOffX=0.0;\n    vec2 scrRes=vec2(150,120)*3.0;\n    if(Res.y/1.7<scrRes.y) scrRes*=Res.y/1.7/scrRes.y;\n    coordOffX+=.7*sin(iTime*40.0+70.0*coord.y/Res.x)*Res.x*0.002;\n    coordOffX-=1.*sin(iTime*60.0+800.0*coord.y/Res.x)*Res.x*0.002;\n    //coord+=vec2(coordOffX,0);\n    vec2 coordQ = floor(coord/Res*scrRes)*Res/scrRes;\n    coordQ+=vec2(coordOffX,0);\n    float andrSize = iResolution.y*.3*(.8+.15*sin(iTime*3.));\n    drawText(mat4(S_,H_,A_,D_, E_,R_,T_,O_, Y_,-1,0,0, 0,0,0,0), c+vec2(-s*4.*0.5*l1, s*4.0), s, col,coordQ);\n    drawText(mat4(F_,O_,R_,-1, 0,0,0,0, 0,0,0,0, 0,0,0,0),       c+vec2(-s*4.*0.5*l2,-s*3.0), s, col,coordQ);\n    drawText(mat4(A_,N_,D_,R_, O_,I_,D_,-1,0,0,0,0, 0,0,0,0),    c+vec2(-s*4.*0.5*l3,-s*10.0), s, col,coordQ);\n    col*=2.;\n    drawAndroid(c.x,c.y,andrSize,andrSize,col,coordQ);\n    col*=.35;\n    //coord-=vec2(coordOffX,0);\n\tcol*=vec4(1.,0.0,0.0,1);\n    col+=vec4(0.15);\n    // pixel mask\n    //col.xyz=maskRGBGrid(col.xyz,coord,scrRes);\n    // cathod ray mask\n    col*=clamp(1.0*(0.5+0.5*sin(3.3*scrRes.y*coord.y/iResolution.y)),0.0,1.0);\n    // time-mask\n    float ferm=fermi(offdt/0.07);\n    float d=length(coord-c);\n    col+=0.015*exp(-d*d/4.0/Res.x/Res.x/ferm/ferm)/(ferm)*mix(sin(iTime*300.0),1.0,(1.0-ferm));\n    if(coord.x<Res.x*0.05) col=vec4(0);\n    if(coord.y<Res.y*0.05) col=vec4(0);\n    if(coord.x>Res.x*0.95) col=vec4(0);\n    if(coord.y>Res.y*0.95) col=vec4(0);\n    fragColor=col.yxzw;\n}\n", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ldSRN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4ldXD7", "name": "sunset meh-drive", "author": "kernalphage", "description": "ughhh this is harder than i thought it would be", "tags": ["sunset", "paint", "procgen"], "likes": 0, "viewed": 95, "date": "1480044070", "time_retrieved": "2024-06-20T18:43:57.242570", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        vec2 uv = fragCoord.xy / iResolution.xy;\n    float uvt = uv.x + iTime * .6;\n    float uvy = uv.y + .1 + sin(iTime*1.) * .1;\n    float height = 1.- smoothstep(.15, .49, uvy) * .55* (cos(uvy*2.2 * (1.0 + .07 *cos(uvt*6.0 + 1.4)))  + .22 \n                                                  + .017 *cos(uvt*89.38) \n                                                  + .03  *cos(uvt*46.38) \n                                                  + .012 *cos(uvt*19.7 + .12) \n                                                  + .03  *sin(uvt*5.7+7.5));\n    \n    height = smoothstep(.6,.75, height);\n    \n    vec2 suncenter = vec2(((uv.y-.8) * .4) * (uv.x - .5) +uv.x - .5, uvy + (sin(uv.x *85.*(uv.y+.8) + iTime *.8)*.01*(uv.y - 1.)) - .9);\n    \n    vec2 sun_repeat = vec2(0,tan(suncenter.y*4.) );\n    float sun = 1. + 1.5 * smoothstep(.1, .2, length(mod(suncenter,sun_repeat) - sun_repeat  * .5));\n    \n    vec3 red = vec3(.99, .14, .34);\n    vec3 blue = vec3(.26, .29, 1);\n    vec3 col = mix(red,blue, height - abs(.26 - uvy + .1 * sin(uvt)));\n    \n    fragColor = vec4(col * height * (sun),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ldXD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4ldXDn", "name": "bp Shapes", "author": "blackpolygon", "description": "Drawing polygons", "tags": ["distancefield", "shapingfunctions"], "likes": 3, "viewed": 133, "date": "1479018960", "time_retrieved": "2024-06-20T18:43:57.569744", "image_code": "// Author: blackpolygon\n// Title:  Shapes\n\n// Based on the code by @patriciogv from \n// https://thebookofshaders.com/07/\n\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat shape(in vec2 st, int N){\n    \n  // Remap the space to -1. to 1.\n  st = st *2.-1.;\n  \n  // Angle and radius from the current pixel\n  float a = atan(st.x,st.y)+PI;\n  float r = TWO_PI/float(N);\n  \n  // Shaping function that modulate the distance\n  return cos(floor(.5+a/r)*r-a)*length(st);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/min(iResolution.x,iResolution.y);\n    st.x -= 0.35;\n    \n    // rotate the space\n    st -= vec2(0.5);\n    st = rotate2d( sin(iTime/3.)*PI) * st;\n    st += vec2(0.5);\n\n    vec3 bgColor = vec3(st.x,0.568,0.651);\n    \n    int sides = 2 + int(abs(sin(iTime/10.)*6.));\n\tfloat d = shape(st, sides);\n    \n    float w = 1.-smoothstep(.4,0.401,d);\n    \n    // Add the shape on the foreground\n    vec3 color = vec3(w);\n    vec3 color2 = vec3(1.0-smoothstep(-0.024,0.634,d));\n    \n    bgColor -= color;\n    bgColor += color2;\n\t \n\tfragColor = vec4(bgColor,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ldXDn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4ldXR4", "name": "Pipes", "author": "xorxor", "description": "Shadertoy remix of davidope's excellent work for codevember 2016\nhttp://dvdp.tumblr.com/post/97344550933/140913\n\nLearning about repetition and anti-aliasing.", "tags": ["raymarching", "tunnel", "codevember", "dvdp"], "likes": 54, "viewed": 1997, "date": "1478453499", "time_retrieved": "2024-06-20T18:43:57.575835", "image_code": "// Created by XORXOR, 2016\n// Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0)\n//\n// Shadertoy remix of davidope's work\n// http://dvdp.tumblr.com/post/97344550933/140913\n\n#define ANTIALIAS\n\nfloat cylinder( vec3 p )\n{\n    return length( p.xy ) - 0.9;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float a = -0.1 * iTime - 0.02 * p.z;\n    float c = cos( a );\n    float s = sin( a );\n    mat2 m = mat2( c, -s, s, c );\n    return vec3( m * p.xy, p.z );\n}\n\nvec2 opRep( vec2 p, float size, float start, float stop )\n{\n    float halfSize = size * 0.5;\n    vec2 c = floor( p / size );\n    p = mod( p, size ) - halfSize;\n    if ( ( c.x > stop ) || ( c.y > stop ) )\n    {\n        p += size * ( c - stop );\n    }\n    if ( ( c.x < start ) || ( c.y < start ) )\n    {\n        p += size * ( c - start );\n    }\n    return p;\n}\n\nfloat map( vec3 p )\n{\n    p = opTwist( p );\n    p.xy = opRep( p.xy, 10.0, -7.0, 7.0 );\n    float d = cylinder( p );\n    return d;\n}\n\nfloat scene( vec3 ro, vec3 rd )\n{\n    float t = 0.01;\n    for ( int i = 0; i < 200; i++ )\n    {\n        vec3 p = ro + t * rd;\n        float d = map( p );\n        if ( d < 0.001 )\n        {\n            return t;\n        }\n        t += d;\n    }\n    return -1.0;\n}\n\nvec3 calcNormal( vec3 pos )\n{\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    float pd = map( pos );\n    vec3 n = vec3(\n            pd - map( pos - eps.xyy ),\n            pd - map( pos - eps.yxy ),\n            pd - map( pos - eps.yyx ) );\n    return normalize( n );\n}\n\nfloat calcAo( vec3 pos, vec3 n )\n{\n    float occ = 0.0;\n    for ( int i = 0; i < 5; i++ )\n    {\n        float hp = 0.1 + 2.0 * float( i );\n        float dp = map( pos + n * hp );\n        occ += ( hp - dp );\n    }\n    return clamp( 1.0 - 0.04 * occ, 0.0, 1.0 );\n}\n\nvec3 render( vec3 ro, vec3 rd )\n{\n    float d = scene( ro, rd );\n    vec3 col = vec3( 0 );\n    if ( d > 0.0 )\n    {\n        vec3 pos = ro + d * rd;\n        vec3 twistPos = opTwist( pos );\n        float t = -15.0 * iTime;\n        col = vec3( floor( 0.3 * mod( twistPos.z + t, 6.0 ) ) );\n        vec3 nor = calcNormal( pos );\n        float ao = calcAo( pos, nor );\n        col *= vec3( ao );\n        float fog = ( 400.0 + pos.z ) / 300.0;\n        col *= fog;\n    }\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 eye = vec3( 0.0, 0.0, 20.0 );\n    vec3 target = vec3( 0.0 );\n    vec3 cw = normalize( target - eye );\n    vec3 cu = cross( cw, vec3( 0, 1, 0 ) );\n    vec3 cv = cross( cu, cw );\n    mat3 cm = mat3( cu, cv, cw );\n\n    vec3 col = vec3( 0.0 );\n#ifdef ANTIALIAS\n    for ( int i = 0; i < 4; i++ )\n    {\n        vec2 off = vec2( mod( float( i ), 2.0 ), mod( float( i / 2 ), 2.0 ) ) / 2.0;\n#else\n        vec2 off = vec2( 0.0 );\n#endif\n        vec2 uv = ( fragCoord.xy + off - 0.5 * iResolution.xy ) / iResolution.y;\n        vec3 rd = cm * normalize( vec3( uv, 2.5 ) );\n\n        col += render( eye, rd );\n#ifdef ANTIALIAS\n    }\n    col *= 0.25;\n#endif\n\n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-4.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ldXR4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4ldXRS", "name": "Preetham Sky projected", "author": "xchip", "description": "based on https://www.shadertoy.com/view/llSSDR", "tags": ["preethamskyprojected"], "likes": 2, "viewed": 360, "date": "1480290492", "time_retrieved": "2024-06-20T18:43:58.315356", "image_code": "\n#define PI 3.14159265359\n\n#define PI 3.14159265359\n\nfloat saturatedDot( in vec3 a, in vec3 b )\n{\n\treturn max( dot( a, b ), 0.0 );   \n}\n\nvec3 YxyToXYZ( in vec3 Yxy )\n{\n\tfloat Y = Yxy.r;\n\tfloat x = Yxy.g;\n\tfloat y = Yxy.b;\n\n\tfloat X = x * ( Y / y );\n\tfloat Z = ( 1.0 - x - y ) * ( Y / y );\n\n\treturn vec3(X,Y,Z);\n}\n\nvec3 XYZToRGB( in vec3 XYZ )\n{\n\t// CIE/E\n\tmat3 M = mat3\n\t(\n\t\t 2.3706743, -0.9000405, -0.4706338,\n\t\t-0.5138850,  1.4253036,  0.0885814,\n \t\t 0.0052982, -0.0146949,  1.0093968\n\t);\n\n\treturn XYZ * M;\n}\n\n\nvec3 YxyToRGB( in vec3 Yxy )\n{\n\tvec3 XYZ = YxyToXYZ( Yxy );\n\tvec3 RGB = XYZToRGB( XYZ );\n\treturn RGB;\n}\n\nvoid calculatePerezDistribution( in float t, out vec3 A, out vec3 B, out vec3 C, out vec3 D, out vec3 E )\n{\n\tA = vec3(  0.1787 * t - 1.4630, -0.0193 * t - 0.2592, -0.0167 * t - 0.2608 );\n\tB = vec3( -0.3554 * t + 0.4275, -0.0665 * t + 0.0008, -0.0950 * t + 0.0092 );\n\tC = vec3( -0.0227 * t + 5.3251, -0.0004 * t + 0.2125, -0.0079 * t + 0.2102 );\n\tD = vec3(  0.1206 * t - 2.5771, -0.0641 * t - 0.8989, -0.0441 * t - 1.6537 );\n\tE = vec3( -0.0670 * t + 0.3703, -0.0033 * t + 0.0452, -0.0109 * t + 0.0529 );\n}\n\nvec3 calculateZenithLuminanceYxy( in float t, in float thetaS )\n{\n\tfloat chi  \t \t= ( 4.0 / 9.0 - t / 120.0 ) * ( PI - 2.0 * thetaS );\n\tfloat Yz   \t \t= ( 4.0453 * t - 4.9710 ) * tan( chi ) - 0.2155 * t + 2.4192;\n\n\tfloat theta2 \t= thetaS * thetaS;\n    float theta3 \t= theta2 * thetaS;\n    float T \t \t= t;\n    float T2 \t \t= t * t;\n\n\tfloat xz =\n      ( 0.00165 * theta3 - 0.00375 * theta2 + 0.00209 * thetaS + 0.0)     * T2 +\n      (-0.02903 * theta3 + 0.06377 * theta2 - 0.03202 * thetaS + 0.00394) * T +\n      ( 0.11693 * theta3 - 0.21196 * theta2 + 0.06052 * thetaS + 0.25886);\n\n    float yz =\n      ( 0.00275 * theta3 - 0.00610 * theta2 + 0.00317 * thetaS + 0.0)     * T2 +\n      (-0.04214 * theta3 + 0.08970 * theta2 - 0.04153 * thetaS + 0.00516) * T +\n      ( 0.15346 * theta3 - 0.26756 * theta2 + 0.06670 * thetaS + 0.26688);\n\n\treturn vec3( Yz, xz, yz );\n}\n\nvec3 calculatePerezLuminanceYxy( in float theta, in float gamma, in vec3 A, in vec3 B, in vec3 C, in vec3 D, in vec3 E )\n{\n\treturn ( 1.0 + A * exp( B / cos( theta ) ) ) * ( 1.0 + C * exp( D * gamma ) + E * cos( gamma ) * cos( gamma ) );\n}\n\nvec3 calculateSkyLuminanceRGB( in vec3 s, in vec3 e, in float t )\n{\n\tvec3 A, B, C, D, E;\n\tcalculatePerezDistribution( t, A, B, C, D, E );\n\n\tfloat thetaS = acos( saturatedDot( s, vec3(0,1,0) ) );\n\tfloat thetaE = acos( saturatedDot( e, vec3(0,1,0) ) );\n\tfloat gammaE = acos( saturatedDot( s, e )\t\t   );\n\n\tvec3 Yz = calculateZenithLuminanceYxy( t, thetaS );\n\n\tvec3 fThetaGamma = calculatePerezLuminanceYxy( thetaE, gammaE, A, B, C, D, E );\n\tvec3 fZeroThetaS = calculatePerezLuminanceYxy( 0.0,    thetaS, A, B, C, D, E );\n\n\tvec3 Yp = Yz * ( fThetaGamma / fZeroThetaS );\n\n\treturn YxyToRGB( Yp );\n}\n\n// Shadertoy specific uniforms\n#define u_res iResolution\n#define u_time iTime\n#define u_mouse iMouse\n\nmat3 rotate_around_x(in float angle_degrees)\n{\n\tfloat angle = radians(angle_degrees);\n\tfloat _sin = sin(angle);\n\tfloat _cos = cos(angle);\n\treturn mat3(1, 0, 0, 0, _cos, -_sin, 0, _sin, _cos);\n}\n\nvec3 sun_dir = vec3(0, 1, 0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{           \n\tvec3 col = vec3(0);\n\n\t// sun\n\tmat3 rot = rotate_around_x(-abs(sin(u_time / 2.)) * 90.);\n\tsun_dir *= rot;\n\n\tvec2 aspect_ratio = vec2(u_res.x / u_res.y, 1);\n\tfloat fov = tan(radians(45.0));\n\tvec2 point_ndc = fragCoord.xy / u_res.xy;\n\tvec3 point_cam = vec3((2.0 * point_ndc - 1.0) * aspect_ratio * fov, -1.0);\n\n    \n    // sky dome angles\n\tvec3 p = point_cam;\n\tfloat z2 = p.x * p.x + p.y * p.y;\n    \n    if (z2>1.0)\n    {\n        fragColor = vec4(0.,0.,0.,1.);\n        return;\n    }\n    \n\tfloat phi = atan(p.y, p.x);\n\tfloat theta = acos(1.0 - z2);\n\n    vec3 dir = vec3(\n\t\tsin(theta) * cos(phi),\n\t\tcos(theta),\n\t\tsin(theta) * sin(phi));\n\n\t\n    col = calculateSkyLuminanceRGB( sun_dir, dir, 2.0 ) * .05;\n    col = clamp( col, 0.0, 1.0 );\n    \n    //gamma\n    col = pow( col, vec3(0.45) );\n    \n\tfragColor = vec4(col, 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ldXRS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4ltSDr", "name": "mandeltribrotship", "author": "balkhan", "description": "Transition from mandelbrot to burning ship, with some tribrots (I'm bad at names)\nexponential color smoothing, still got some banding, if anyone can tell how to remove it please do :)\nuncomment line 2 if you wish", "tags": ["2d", "fractal", "mandelbrot", "burningship"], "likes": 8, "viewed": 285, "date": "1480063093", "time_retrieved": "2024-06-20T18:43:58.630377", "image_code": "#define I_MAX 50\n//#define ROTATION\n\nvec2 \tcmult(vec2 a, vec2 b);\nvec2\tcadd(vec2 a, vec2 b);\n\nvoid\tmainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2\tuv = fragCoord.xy / iResolution.xy;\n    vec4\tz = vec4(0.0, 0.0, 0.0, 0.0);\n    vec2\tof = vec2((uv.x -0.5)/0.125, (uv.y -0.5)/0.125);\n    vec3\tcol = vec3(0.0);\n    vec2\tdist = vec2(0.0);\n    z.xy = of;\n#ifdef ROTATION\n    vec2\tit;\n    it = cmult(vec2(1.0, 1.0), vec2(of/(of.x*of.x+of.y*of.y)));\n    it /= 3.0;\n#endif\n    int ii = -1;\n    for (int i = -1; i < I_MAX; ++i)\n    {\n        ++ii;\n        z.xy = cadd((cmult(abs(z.xy)-of, abs(z.xy)-of)), vec2(cos(iTime/5.0),sin(iTime/3.0)));\n        z.z = 2.0 * (z.x*z.z - z.y*z.w);\n        z.w = 2.0 * (z.y*z.z - z.x*z.w);\n        dist.x = dot(z.xy,z.xy);\n\t\tdist.y = dot(z.zw,z.zw);\n\n#ifdef ROTATION\n     z.xy = cmult(z.xy, vec2(cos(it.x+sin(it.y+iTime/2.0)), \n                             sin(it.y+sin(it.x+iTime/2.0))));\n#endif\n     \tcol.x += exp(-abs(float(ii)/z.x)); // expensive but pretty\n    \tcol.y += exp(-abs(float(ii)/z.y));\n    \tcol.z += exp(-abs(float(ii)/(z.x+z.y)));\n        if (dist.x > 100000000000.0 || dist.y > 100000000000.0)\n            break;\n    }\n    col /= vec3(float(ii));\n    fragColor = vec4(col, 1.0);\n}\n\nvec2 \tcmult(vec2 a, vec2 b)\n{\n    return (vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x));\n}\n\nvec2\tcadd(vec2 a, vec2 b)\n{\n\treturn (vec2(a.x + b.x, a.y + b.y));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ltSDr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4ltSRN", "name": "Color Glow", "author": "tabman", "description": "Simple glow. Looks nice with gradients.", "tags": ["texture", "rgb", "image"], "likes": 6, "viewed": 367, "date": "1478462822", "time_retrieved": "2024-06-20T18:43:58.630377", "image_code": "void mainImage( out vec4 o, in vec2 q )\n{\n    o = texture(iChannel0,q/iResolution.xy);\n    vec4 f = vec4(1.,1.,1.,1.);//rgb frequencies\n\n    //sine glow\n    o = .5*(1.0+sin(6.28318*o+iTime*f));\n\n    //ping pong glow\n    //o = abs(mod(o+iTime*f,2.)-1.);\n}", "image_inputs": [{"id": "4sX3Rn", "previewfilepath": "/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ltSRN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4ltSRS", "name": "nebula smoke", "author": "mahalis", "description": "pentagons all hashed up", "tags": ["smoke", "purple"], "likes": 51, "viewed": 4439, "date": "1480282799", "time_retrieved": "2024-06-20T18:43:58.891020", "image_code": "float polygonDistance(vec2 p, float radius, float angleOffset, int sideCount) {\n\tfloat a = atan(p.x, p.y)+ angleOffset;\n\tfloat b = 6.28319 / float(sideCount);\n\treturn cos(floor(.5 + a / b) * b - a) * length(p) - radius;\n}\n\n// from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE1 443.8975\nfloat hash11(float p) // assumes p in ~0-1 range\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\nvec2 hash21(float p) // assumes p in larger integer range\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = vec2(0.5) - (fragCoord.xy / iResolution.xy);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float accum = 0.;\n    for(int i = 0; i < 83; i++) {\n        float fi = float(i);\n        float thisYOffset = mod(hash11(fi * 0.017) * (iTime + 19.) * 0.2, 4.0) - 2.0;\n        vec2 center = (hash21(fi) * 2. - 1.) * vec2(1.1, 1.0) - vec2(0.0, thisYOffset);\n        float radius = 0.5;\n        vec2 offset = uv - center;\n        float twistFactor = (hash11(fi * 0.0347) * 2. - 1.) * 1.9;\n        float rotation = 0.1 + iTime * 0.2 + sin(iTime * 0.1) * 0.9 + (length(offset) / radius) * twistFactor;\n        accum += pow(smoothstep(radius, 0.0, polygonDistance(uv - center, 0.1 + hash11(fi * 2.3) * 0.2, rotation, 5) + 0.1), 3.0);\n    }\n    \n    vec3 subColor = vec3(0.4, 0.8, 0.2); //vec3(0.4, 0.2, 0.8);\n    vec3 addColor = vec3(0.3, 0.2, 0.1);//vec3(0.3, 0.1, 0.2);\n    \n\tfragColor = vec4(vec3(1.0) - accum * subColor + addColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ltSRS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4ltXDn", "name": "bp Color theory", "author": "blackpolygon", "description": "Experimenting with color and masks", "tags": ["colors", "circle", "rotation"], "likes": 5, "viewed": 177, "date": "1479017766", "time_retrieved": "2024-06-20T18:43:59.145793", "image_code": "// Author: blackpolygon\n// Title:  Color Theory\n\n// Experimenting with color and masks\n\n#define PI 3.14159265359\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat circle(in vec2 st, in float radius){\n    vec2 l = st-vec2(0.5);\n    return 1.-smoothstep(radius, radius+0.002, dot(l,l));\n}\n\t\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/min(iResolution.x,iResolution.y);\n    st.x -= 0.35;\n    \n    //Calculate the color for the circle before the rotation\n    vec3 color = vec3(st.y,st.x,0.484);\n    \n    st -= vec2(0.5);\n    st = rotate2d( sin(iTime/2.)*PI) * st;\n    st+= 0.5;\n    \n    //Background color after rotation\n    vec3 bgColor = vec3(st.x,st.y,0.392);\n    \n    float mask1 = circle(st,0.1);\n    float mask2 = 1.0-mask1;  //Inverse of the circle\n    \n    \n    color *= vec3(mask1);\n    color += bgColor*vec3(mask2);\n\t \n\tfragColor = vec4(color,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ltXDn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4ltXW4", "name": "imperfect voxels", "author": "SudoNhim", "description": "Combining voxels and distance functions to make rough shaped voxels.\n\n1st pass: voxel march a fixed number of steps storing the first four voxels hit\n2nd pass: distance march each of the hit voxels to intersect", "tags": ["voxels"], "likes": 3, "viewed": 182, "date": "1479607566", "time_retrieved": "2024-06-20T18:44:00.230601", "image_code": "// utility functions\nvec3 rot_axis_angle(vec3 v, vec3 axis, float angle);\nfloat snoise(const in vec3 x);\nfloat hash(float x);\n\n// current ray\nvec3 ro;\nvec3 rd;\n\n// voxel marcher\n#define MAX_VOXEL_HITS 4\n#define VOXEL_MARCH_STEPS 36\nivec3 hitVoxels[MAX_VOXEL_HITS];\nint hitIndex = 0;\nvoid voxelMarch();\n\n// terrain type of hit voxel\nint terrainType;\n\n// map\n#define NONE 0\n#define WATER 1\n#define STONE 2\nint getTerrain(ivec3 mapPos) {\n  float l = length(vec3(mapPos));\n  float rand = ( \n    0.367 * hash(float(mapPos.x) + 127.71) + \n    0.367 * hash(float(mapPos.y) + 432.22) + \n    0.367 * hash(float(mapPos.z) + 322.11)\n    );\n  if (l*rand > 4.0) return STONE;\n  \n  if (mapPos.y < 0) return WATER;\n  \n  return NONE;\n}\n\n\nfloat dfVoxel(vec3 p, vec3 globalP) {\n  if (terrainType == WATER) {\n    float surfDist = p.y - 0.5;\n    return surfDist;\n  } \n  else if (terrainType == STONE) {\n    float radius = 0.01;\n    vec3 sides = vec3(0.475, 0.475, 0.475);\n    float cubeDist = length(max(abs(p)-(sides-radius), 0.0))-radius;\n    float distortion = -0.03 + 0.03*snoise(p*3.0+floor(globalP));\n    float detail = min(0.0, 0.004*snoise(p*15.0+floor(-globalP)));\n    return cubeDist + distortion + detail;\n  }\n  return 0.0;\n}\n\nvec3 nrmVoxel(vec3 p, vec3 globalP) {\n  vec2 dd = vec2(0.001,0.0);\n  float base = dfVoxel(p, globalP);\n  return normalize(vec3(\n    dfVoxel(p+dd.xyy, globalP) - base,\n    dfVoxel(p+dd.yxy, globalP) - base,\n    dfVoxel(p+dd.yyx, globalP) - base\n    ));\n}\n\nvec3 hitPos;\nvec3 hitVoxelCenter;\nvec3 hitNormal;\n#define SDMARCH_STEPS 8\nvoid resolveHitVoxels() { \n  for (int i=0; i<MAX_VOXEL_HITS; i++) {\n    if (i == hitIndex) break;\n    \n    terrainType = getTerrain(hitVoxels[i]);\n    hitVoxelCenter = vec3(hitVoxels[i]) + 0.5;\n    \n    // intersect with voxel cube\n    vec3 cubeIntersect = (hitVoxelCenter - ro - 0.5*sign(rd))/rd;\n    float d = max(cubeIntersect.x, max(cubeIntersect.y, cubeIntersect.z));\n    hitPos = ro + rd * d;\n    \n    // attempt better intersect with distance marching\n    float diff;\n    vec3 p =hitPos;\n    for (int j=0; j<SDMARCH_STEPS; j++) {\n      diff = dfVoxel(p - hitVoxelCenter, hitVoxelCenter);\n      d += diff;\n      p = ro + rd * d;\n    }\n    if (diff < 0.03) { // good enough distance marched intersection\n      hitPos = p;\n      break;\n    }\n  }\n  \n  hitNormal = nrmVoxel(hitPos - hitVoxelCenter, hitVoxelCenter);\n}\n\nvec3 GetColor()\n{\n  vec3 color = vec3(0.0);\n  if (terrainType == WATER)\n    color = vec3(0.1, 0.1, 0.2) + 0.1*snoise(hitVoxelCenter);\n  if (terrainType == STONE)\n    color = vec3(0.1) + vec3(0.5, 0.3, 0.1) * abs(snoise(hitVoxelCenter));\n  vec3 ldir = normalize(hitPos);\n  float diffuse = dot(-ldir, hitNormal);\n  float ambient = 1.0 - length(hitPos) / 16.0;\n  color *= diffuse + ambient;\n  return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord.xy/iResolution.xy;\n  ro = vec3(0.0, 2.0, 0.0);\n  rd = vec3(((uv-0.5)*vec2(iResolution.x/iResolution.y, 1.0)), 1.0);\n  rd = rot_axis_angle(rd, vec3(1.0, 0.0, 0.0), sin(iTime/9.0)/4.0+0.3+(-iMouse.y/iResolution.y)*3.0);\n  rd = rot_axis_angle(rd, vec3(0.0, 1.0, 0.0), sin(iTime/7.0)/2.0+(iMouse.x/iResolution.x-0.5)*5.0);\n  \n  voxelMarch();\n  resolveHitVoxels();\n  \n  vec3 color = vec3(0.0);\n  if (hitIndex > 0)\n    color = GetColor();\n    \n  fragColor = vec4(color, 1.0);\n}\n\n\n//###################################################################\n// Voxel marcher\n\nvoid voxelMarch() {\n  ivec3 mapPos = ivec3(floor(ro));\n  vec3 deltaDist = abs(vec3(length(rd)) / rd);\n  ivec3 rayStep = ivec3(sign(rd));\n  vec3 sideDist = (sign(rd) * (vec3(mapPos) - ro) + (sign(rd) * 0.5) + 0.5) * deltaDist; \n  bvec3 mask;\n\t\n  for (int i = 0; i < VOXEL_MARCH_STEPS; i++) {\n    if (getTerrain(mapPos) != NONE) {\n      if (hitIndex == 0) // no non-const indexing? :<\n          hitVoxels[0] = mapPos;\n      else if (hitIndex == 1)\n          hitVoxels[1] = mapPos;\n      else if (hitIndex == 2)\n          hitVoxels[2] = mapPos;\n      else if (hitIndex == 3)\n          hitVoxels[3] = mapPos;\n      hitIndex++;\n      if (hitIndex == MAX_VOXEL_HITS) return;\n    }\n\n    // Branchless DDA not working in webgl? :L\n    //mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));\n    //sideDist += vec3(mask) * deltaDist;\n    //mapPos += ivec3(mask) * rayStep;\n      \n    if (sideDist.x < sideDist.y) {\n        if (sideDist.x < sideDist.z) {\n            sideDist.x += deltaDist.x;\n              mapPos.x += rayStep.x;\n            mask = bvec3(true, false, false);\n        }\n        else {\n            sideDist.z += deltaDist.z;\n            mapPos.z += rayStep.z;\n            mask = bvec3(false, false, true);\n        }\n    }\n    else {\n        if (sideDist.y < sideDist.z) {\n            sideDist.y += deltaDist.y;\n            mapPos.y += rayStep.y;\n            mask = bvec3(false, true, false);\n        }\n        else {\n            sideDist.z += deltaDist.z;\n            mapPos.z += rayStep.z;\n            mask = bvec3(false, false, true);\n          }\n      }\n  }\n}\n\n\n//###################################################################\n// Utils\n\nvec3 rot_axis_angle(vec3 v, vec3 axis, float angle) {\n  return v*cos(angle) +\n         cross(axis, v)*sin(angle) +\n         axis*dot(axis, v)*(1.0-cos(angle));\n}\n\nfloat hash(float x) {\n  return fract(423.623*sin(773.67*x + 1.93));\n}\n\n// Description : Array and textureless GLSL 3D simplex noise function\n// http://www.gamedev.net/topic/502913-fast-computed-noise/\n\nvec4 randomizer4(const vec4 x)\n{\n    vec4 z = mod(x, vec4(5612.0));\n    z = mod(z, vec4(3.1415927 * 2.0));\n    return(fract(cos(z) * vec4(56812.5453)));\n}\n\nconst float A = 1.0;\nconst float B = 57.0;\nconst float C = 113.0;\nconst vec3 ABC = vec3(A, B, C);\nconst vec4 A3 = vec4(0, B, C, C+B);\nconst vec4 A4 = vec4(A, A+B, C+A, C+A+B);\n\nfloat snoise(const in vec3 xx)\n{\n    vec3 x = mod(xx + 32768.0, 65536.0);\n    vec3 ix = floor(x);\n    vec3 fx = fract(x);\n    vec3 wx = fx*fx*(3.0-2.0*fx);\n    float nn = dot(ix, ABC);\n\n    vec4 N1 = nn + A3;\n    vec4 N2 = nn + A4;\n    vec4 R1 = randomizer4(N1);\n    vec4 R2 = randomizer4(N2);\n    vec4 R = mix(R1, R2, wx.x);\n    float re = mix(mix(R.x, R.y, wx.y), mix(R.z, R.w, wx.y), wx.z);\n\n    return 1.0 - 2.0 * re;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ltXW4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4t3SD4", "name": "Stepped Twist", "author": "flaffol", "description": "Stepped twisting effect applied to some radial stripes.", "tags": ["2d", "simple", "spiral", "radial", "twist"], "likes": 16, "viewed": 258, "date": "1479789147", "time_retrieved": "2024-06-20T18:44:00.230601", "image_code": "#define COLOR_A vec4(0.400, 0.466, 0.533, 1.0)\n#define COLOR_B vec4(0.800, 0.800, 0.800, 1.0)\n\n#define STRIPES 5.0\n#define STEP_SIZE 0.02\n\n#define SPEED 0.80\n\nfloat getValue (in vec2 position)\n{\n    // Calculate vector from center, then correct for aspect ratio\n    vec2 radial_vector = (position.xy / iResolution.xy) - vec2(0.5, 0.5);\n    radial_vector.x *= iResolution.x / iResolution.y;\n    \n    // Calculate and adjust angle of this vector\n    float angle = atan(radial_vector.y, radial_vector.x);\n    angle += (1.0 - STEP_SIZE * floor(length(radial_vector) / STEP_SIZE)) * (iTime * SPEED);\n    \n    // Return the color of the stripe at the adjusted angle\n    return step(0.0, sin(angle * STRIPES));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Average 4 values for some lazy antialiasing\n    float value = getValue(fragCoord + vec2(-0.25, -0.25));\n    value += getValue(fragCoord + vec2(-0.25, 0.25));\n    value += getValue(fragCoord + vec2(0.25, 0.25));\n    value += getValue(fragCoord + vec2(0.25, -0.25));\n    value /= 4.0;\n    \n    // Apply averaged value to color gradient\n    fragColor = mix(COLOR_A, COLOR_B, value);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4t3SD4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4t3SWN", "name": "fingerprint generator", "author": "diviaki", "description": "symbolic fingerprints", "tags": ["forensics"], "likes": 46, "viewed": 2733, "date": "1479473705", "time_retrieved": "2024-06-20T18:44:00.448787", "image_code": "vec2 hash2( vec2 p )\n{\n\tp = vec2( dot(p,vec2(63.31,127.63)), dot(p,vec2(395.467,213.799)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43141.59265);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float invzoom = 100.;\n    vec2 uv = invzoom*((fragCoord-0.5*iResolution.xy)/iResolution.x);\n    float bounds = smoothstep(9.,10.,length(uv*vec2(0.7,0.5)));\n\n    //cumulate information\n    float a=0.;\n    vec2 h = vec2(floor(7.*iTime), 0.);\n    for(int i=0; i<50; i++){\n        float s=sign(h.x);\n        h = hash2(h)*vec2(15.,20.);\n    \ta += s*atan(uv.x-h.x, uv.y-h.y);\n    }\n    \n    //comment this out for static center\n    uv += 20.*abs(hash2(h));\n    \n    a+=atan(uv.y, uv.x); //spirallic center more likely\n\n    float w = 0.8; //row width\n    float p=(1.-bounds)*w; //pressure\n    float s = min(0.3,p); //smooth\n    float l = length(uv)+0.319*a; //base rings plus information\n    \n    //dist -> alternate pattern\n    float m = mod(l,2.);\n    float v = (1.-smoothstep(2.-s,2.,m))*smoothstep(p,p+s,m);\n    \n\tfragColor = vec4(v,v,v,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4t3SWN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4t3XR4", "name": "Mandelbox Sphere Fractal Combo", "author": "henry", "description": "This is the same as kig's mandelbox sphere code, except that i tried to max(mandelboxISO,SphereISO) and failed so then i multiplied the length(x,y,z) at the end of mandeblox formula by 5+sin(time) and i am happy with the result, even if i failed totally. ", "tags": ["fractal", "trippy", "mandelbox", "isosurface"], "likes": 6, "viewed": 246, "date": "1478275447", "time_retrieved": "2024-06-20T18:44:01.024551", "image_code": "#define AA_SIZE 2.0\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);  \n}\n\nvec3 shadeBg(vec3 nml, vec2 fragCoord)\n{\n\tvec2 aspect = vec2(iResolution.x/iResolution.y, 1.0);\n\tvec2 uv = (2.0 * fragCoord.xy / iResolution.xy - 1.0) * aspect;\n    float t = 16.0;\n\tvec3 bgLight = normalize(vec3(\n\t\tcos(t*0.2/0.954929658551372)*4.0, \n\t\tsin(t/1.1936620731892151)*3.0 - 4.0, \n\t\tsin(t*0.2/0.954929658551372)*8.0\n\t));\n\tvec3 sun = vec3(2.0, 1.5, 1.0)*0.75;\n\tfloat bgDiff = dot(nml, vec3(0.0, -1.0, 0.0));\n\tfloat sunPow = dot(nml, bgLight);\n\tfloat sp = max(sunPow, 0.0);\n\tvec3 bgCol = max(0.0, bgDiff)*2.0*vec3(0.4, 0.7, 0.65);\n\tbgCol += max(0.0, -bgDiff)*vec3(0.4, 0.55, 0.9);\n\tbgCol += vec3(0.2, 0.5, 0.7)*((0.5*pow(1.0-abs(bgDiff), 5.0)*(5.0-dot(uv,uv))));\n\tbgCol += sun*(0.5*pow( sp, 3.0)+pow( sp, 256.0));\n\tbgCol += vec3(0.5, 0.2, 0.15)*(pow( sp, 8.0) + pow( sp, abs(bgLight.y)*128.0));\n    //bgCol += vec3(1.9,0.,0.9) * ((1.0-pow(abs(bgDiff), 0.6)) * 0.5);\n\treturn pow(max(vec3(0.0), bgCol), vec3(1.9));\n}\n\nfloat mandelbox_dist(vec3 pos) {\n    vec4 p = vec4(pos, 1.0), p0 = p;\n    float minRad2 = 0.25;\n    vec4 scale = vec4(2.0) / minRad2;\n    float absScalem1 = abs(2.0 - 1.0);\n    float AbsScaleRaisedTo1mIters = pow(abs(2.0), (1.0 - 20.0));\n    for (int i=0; i<20; i++) {\n        p.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;\n        float r2 = dot(p.xyz, p.xyz);\n        p *= clamp(max(minRad2/r2, minRad2), 0.0, 1.0);\n        p = p * scale + p0;\n    }\n    return ((length(p.xyz)*(5.0*sin(iTime/4.0)) - absScalem1) / p.w - AbsScaleRaisedTo1mIters);\n}\n\nfloat scene(vec3 p) {\n    return max(length(p)-7.5, mandelbox_dist(p));\n}\n\nvec3 normal(vec3 p, float d)\n{\n\tfloat e = 0.005;\n\tfloat dx = scene(vec3(e, 0.0, 0.0) + p) - d;\n\tfloat dy = scene(vec3(0.0, e, 0.0) + p) - d;\n\tfloat dz = scene(vec3(0.0, 0.0, e) + p) - d;\n\treturn normalize(vec3(dx, dy, dz));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    for (float x = 0.0; x < AA_SIZE; x++) {\n    for (float y = 0.0; y < AA_SIZE; y++) {\n\n        vec2 uv = (vec2(x/AA_SIZE, y/AA_SIZE) + fragCoord.xy) / iResolution.xy;\n        uv = (0.5 - uv) * 2.0;\n        uv.x *= iResolution.x / iResolution.y;\n\n        float time = iTime; //406.9;\n        float a = cos(time/3.53423*0.5);\n        float ca = cos(a), sa = sin(a);\n        uv *= mat2(ca, sa, -sa, ca);\n        mat3 rot = rotationMatrix(normalize(vec3(1.0, -0.5, 0.5)),time*0.05);\n        vec3 ro = rot*vec3(0,0,-15.0);\n        vec3 rd = rot*normalize(vec3(uv, 5.5));\n        ro += rd * 4.0;\n        vec3 transmit = vec3(1.0);\n        float bounce = 0.0;\n\n        for (int i=0; i<70; i++) {\n            float t = scene(ro);\n            if (t < 0.0025) {\n                vec3 nml = normal(ro, t);\n                rd = normalize(reflect(rd, nml));\n                ro += rd * 0.005;\n                transmit *= vec3(0.75, 0.8, 0.9)*0.7 - float(i)/70.0;\n                bounce++;\n                break;\n            } else {\n                ro += rd * t;\n            }\n            if (t > 17.0) {\n                break;\n            }\n        }\n        if (bounce == 0.0) {\n            transmit *= 0.0;\n        }\n        fragColor += vec4(1.0-exp(-1.6*transmit*shadeBg(-rd, fragCoord)), 1.0);\n    }\n    }\n    fragColor /= AA_SIZE*AA_SIZE;\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4t3XR4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4t3XRN", "name": "Deformed object", "author": "Swax97", "description": "I'm going to start doing more interesting things on this site.\nFor now, I've got a blob.", "tags": ["fractal", "raymarch", "fog", "sinusoidal"], "likes": 7, "viewed": 197, "date": "1478305747", "time_retrieved": "2024-06-20T18:44:01.394400", "image_code": "#define MARCH_EPS 0.007\n#define MARCH_STEP 0.25\n#define FAR 8.0\n\n#define time iTime\n\nconst vec2 res = vec2(1024, 768);\n\nfloat map (vec3 p) {\n\tp += sin(p.yzx * 5.0  - time * 0.41) * 0.15;\n\tp += sin(p.zxy * 9.0  - time * 0.47) * 0.065;\n\tp += sin(p.xyz * 17.0 - time * 1.43) * 0.0275;\n\tp += sin(p.yzx * 33.0 - time * 0.11) * 0.01475;\n\tp += sin(p.zyx * 65.0 - time * 0.17) * 0.01075;\n\tp += sin(p.xzy * 129. - time * 0.13) * 0.00700;\n\tp += sin(p.yzx * 257. - time * 0.05) * 0.00400;\n\treturn length(p) - 1.0;\n}\n\nfloat trace(vec3 ro, vec3 rd, inout float close){\n\tfloat d, t = 1.2;\n\t\n\tfor (int i = 0; i < 100; i++){\n\t\td = map(ro + rd * t);\n\t\tif (abs(d) < MARCH_EPS || t > FAR) break;\n\t\tclose = min(close, d);\n\t\tt += d * MARCH_STEP;\n\t}\n\t\n\treturn (t+1.0) * step(d, MARCH_EPS) - 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\t\n\tfloat cost = cos(time * 0.7);\n\tfloat sint = sin(time * 0.7);\n\n\tvec3 ro = 3.0 * vec3(sint, 0.0, cost);\n\tvec3 rd = normalize(vec3(uv, -1.5));\n\t\n\trd.xz *= mat2(cost, sint, -sint, cost);\n\t\n\tfloat close = 4.0;\n\tfloat t = trace(ro, rd, close);\n\tif (t > 0.0){\n\t\tvec3 end = ro + rd * t;\n\t\t\n\t\tconst vec2 eps = 0.01 * vec2(-1.0, 1.0);\n\t\tvec3 nml = normalize(eps.xxx * map(vec3(end + eps.xxx)) + \n\t\t\t\t     \t\t eps.yyx * map(vec3(end + eps.yyx)) + \n\t\t\t\t\t\t\t eps.xyy * map(vec3(end + eps.xyy)) + \n\t\t\t\t\t\t\t eps.yxy * map(vec3(end + eps.yxy)));\n\t\t\t\t\n\t\tfloat dp, ao = (map(end + nml * 0.05) - map(end)) * 20.0;\n\n\t\tvec3 lig = vec3(ao * 0.3);\n\t\tdp = max(0.0, dot(nml, vec3(0.57735, 0.57735, -0.57735)));\n\t\tlig += vec3(0.6, 0.4, 0.2) * (dp*0.7 + dp*dp*dp*0.3);\n\t\t\n\t\tdp = max(0.0, dot(nml, vec3(-0.57735, -0.57735, -0.57735)));\n\t\tlig += vec3(0.2, 0.4, 0.6) * (dp*0.7 + dp*dp*dp*0.3);\n\n\t\tdp = max(0.0, nml.z);\n\t\tlig += vec3(0.1, 0.4, 0.1) * (dp*0.7 + dp*dp*dp*0.3);\n\t\t\n\n\t\t//float l = 0.3 + 0.7 * dot(ro + rd * t, vec3(-0.57735));\n\t\t//l = max(0.0, l);\n\t\tfragColor = vec4(lig, 1.0);\n\t} else { \n\t\tvec3 aur = vec3(0.4, 0.5, 0.4) / (close + 1.0);\n\t\taur += vec3(0.5, 0.3, 0.4);\t\n\t\tfragColor = vec4(aur, 1.0);\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4t3XRN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4t3XWn", "name": "Tunnel Beauty 5", "author": "aiekick", "description": "Tunnel Beauty 5", "tags": ["tunnel", "5", "beauty"], "likes": 16, "viewed": 608, "date": "1478889471", "time_retrieved": "2024-06-20T18:44:02.158111", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2016 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\nmat3 RotZ(float a){return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\t// get rotation matrix near z\n\nvec3 last_p;\n\nvec3 path(vec3 p)\n{\n\tp *= RotZ(cos(p.z * 0.1) * 0.1);\n    p += sin(p.zxy * 0.5) * 0.5;\n\tp *= RotZ(sin(p.z * 0.2) * 0.1);\n   \treturn sin(p * 0.1) * 5.;\n}\nfloat angle(vec2 p, float d)\n{\n    return abs(fract(atan(p.x, p.y)/3.14159*10.*sin(d*0.1))-.5);\n}\n\nfloat df(vec3 p)\n{\n\tp += path(p);\n    p *= RotZ(cos(p.z * 0.5)*0.3);\n    \n    float ca = angle(p.xy, p.z);\n    float la = angle(last_p.xy, last_p.z);\n    last_p = p;\n    return mix(3.,6.,mix(la,ca,sin(p.z*0.1)*0.55+0.45)) - length(p.xy);\n}\n\nvec3 nor( vec3 pos, float prec )\n{\n\tvec3 eps = vec3( prec, 0., 0. );\n\tvec3 nor = vec3(\n\t    df(pos+eps.xyy) - df(pos-eps.xyy),\n\t    df(pos+eps.yxy) - df(pos-eps.yxy),\n\t    df(pos+eps.yyx) - df(pos-eps.yyx) );\n\treturn normalize(nor);\n}\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// get density of the df at surfPoint\n// ratio between constant step and df value\nfloat SubDensity(vec3 surfPoint, float prec, float ms) \n{\n\tvec3 n;\n\tfloat s = 0.;\n    const int iter = 10;\n\tfor (int i=0;i<iter;i++)\n\t{\n\t\tn = nor(surfPoint,prec); \n\t\tsurfPoint = surfPoint - n * ms; \n\t\ts += df(surfPoint);\n\t}\n\t\n\treturn 1.-s/(ms*float(iter)); // s < 0. => inside df\n}\n\nfloat SubDensity(vec3 p, float s) \n{\n\tvec3 n = nor(p,s); \t\t\t\t\t\t\t// precise normale at surf point\n\treturn df(p - n * s);\t\t\t\t\t\t// ratio between df step and constant step\n}\n\nvoid mainImage( out vec4 f, in vec2 g )\n{\n\tvec2 si = iResolution.xy;\n\t\n\tvec2 uv = (g+g-si)/si.y;\n\n\tfloat time = iTime*1.2;\n\t\n\tvec3 ro = vec3(0,0, time*5.);\n\tro -= path(ro);\n\t\n\tvec3 cv = ro + vec3(0,0,10); // cam view\n\tcv -= path(cv);\n\t\n\tvec3 lp = ro;\t// light pos\n\t\n\tvec3 cu = normalize(vec3(0,1,0));\n  \tvec3 z = normalize(cv-ro);\n    vec3 x = normalize(cross(cu,z));\n  \tvec3 y = cross(z,x);\n  \tvec3 rd = normalize(z + uv.x*x + uv.y*y);\n\t\n    last_p = ro;\n    \n\tfloat s = 1., d = 0.;\n\tfor (int i=0; i<60; i++) // 30 iterations yeah :)\n\t{\n\t\tif (log(d/1e6)>0.) break; // due to this special break condition\n\t\td += df(ro+rd*d)*.2;\n\t}\n\t\n    f.rgb = vec3(0);\n    \n\t{\n\t\tvec3 p = ro + rd * d;\t\t\t\t\t\t\t\t\t\t\t// surface point\n\t\tvec3 ld = normalize(lp-p); \t\t\t\t\t\t\t\t\t\t// light dir\n\t\tvec3 n = nor(p, 0.1);\t\t\t\t\t\t\t\t\t\t\t// normal at surface point\n\t\tvec3 refl = reflect(rd,n);\t\t\t\t\t\t\t\t\t\t// reflected ray dir at surf point \n\t\tfloat diff = clamp( dot( n, ld ), 0.0, 1.0 ); \t\t\t\t\t// diffuse\n\t\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 4. ); \t\t\t// fresnel\n\t\tfloat spe = pow(clamp( dot( refl, ld ), 0.0, 1.0 ),16.);\t\t// specular\n\t\tvec3 col = vec3(0.2,0.5,0.8);\n\t\tfloat sss = df(p - n*0.001)/1.;\t\t\t\t\t\t\t\t// quick sss 0.001 of subsurface\n\t\t\n\t\tfloat sb = SubDensity(p, 0.01, 0.1);\t\t\t\t\t\t\t// deep subdensity from 0.01 to 0.1 (10 iterations)\n\t\tvec3 bb = blackbody(200. * sb).bgr;\t\t\t\t\t\t\t\t\t// blackbody color\n\t\tfloat sss2 = 0.5 - SubDensity(p, 3.); \t\t\t\t\t\t\t// one step sub density of df of 3 of subsurface\n\t\tfloat ao = df(p + n * 1.2);\t\n\t\tvec3 a = ((diff + fre + spe)*ao + bb * sss2 * .5 + col * sss * .5) * 0.35;\n\t\tvec3 b = col * sss;\n\t\t\n\t\tf.rgb = mix(a, b, .8-exp(-0.03*d*d));\n    }\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4t3XWn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4t3Xz2", "name": "Starfield_Anim", "author": "listenheart", "description": "stars", "tags": ["star"], "likes": 8, "viewed": 269, "date": "1480476879", "time_retrieved": "2024-06-20T18:44:02.158111", "image_code": "// Thanks  https://www.shadertoy.com/view/ltXXDN\n#define r(o) fract(sin(vec4(6,9,1,o)*i) * 9e2)\nvoid mainImage(out vec4 f, vec2 v )  {\n    float t = iTime;\n    vec2 uv=v/iResolution.y;\n  \tfor (float i=0.; i < 10.; i+=.1) \n        f +=  r(0)/8e2\n             / pow(\n                  length( uv - 3.*fract(sin(t)*0.05+r(5.).zw))\n               , 0.6*abs(sin(t*2.+i))+0.8 );  \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4t3Xz2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4t3XzS", "name": "Simplistic Sea", "author": "VoidChicken", "description": "The simplistic sea with clouds. Basically that's it. Relatively laggy for average gpus.", "tags": ["3d", "raymarch", "clouds", "volumetric", "vignette", "hdr", "reinhard", "chicken", "tonemap", "simplistic"], "likes": 3, "viewed": 202, "date": "1480120675", "time_retrieved": "2024-06-20T18:44:02.158111", "image_code": "#define R vec3(iResolution.xy,1)\n#define MIN1(a,b) (a.x<b.x?a:b)\nvec3 vignette( vec2 uv, vec3 color )\n{\n\tvec2 offset = (uv - 0.5) * sqrt(2.0);\n\t\n\tfloat dst = dot(offset,offset);\n\t\n\tconst float str = 0.95;\n\tconst float powr = 1.5;\n\n\treturn color * ((1.0 - str) +  str * pow(1.0 - dst, powr));\n}\nvec2 map ( vec3 p ) {\n    float t = 1.,t2=5.;\n    float h = sin(p.x+iTime*t)+sin(p.z+iTime*t);\n       h*=sin(iTime*t2+p.x+p.y);\n    h/=10.;\n    vec2 f = \n        vec2(\n            p.y+h,\n            0);\n    return f;\n}\nvec3 normal( in vec3 x)\n{\n    vec2 e = vec2( .01, 0.0 );\n    return normalize( vec3( map(x+e.xyy).x - map(x-e.xyy).x,\n                            map(x+e.yxy).x - map(x-e.yxy).x,\n                            map(x+e.yyx).x - map(x-e.yyx).x ) );\n}\nfloat noise1( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel0, (uv+0.5)/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\nfloat noise (vec3 pos) {\n    float f = 0.;\n    vec3 q = pos;\n            f  = 0.5000*noise1( q ); q = q*2.01;\n            f += 0.2500*noise1( q ); q = q*2.02;\n            f += 0.1250*noise1( q ); q = q*2.03;\n            f += 0.0625*noise1( q ); q = q*2.01;\n    return f;\n}\n\nvec3 camera = vec3(0,2,-6.);\nvec3 sky (vec3 u) {\n\tvec3 skyC = mix( vec3(0.01, 0.1, 0.4), vec3(0.2, 0.5, 0.6) * 5.0, u.y/2.+.5);    \n    vec3 skyC2 = skyC;\n    \n    float d = 8./u.y;\n    if (u.y>.0){\n        for (int i = 0; i < 32; i++) {\n            float diff = .25/u.y;\n            d+=diff;\n            vec3 v = u;\n            v.y*=2.;\n            float f = noise(camera+v/5.*d+iTime/5.);\n            f+=noise(camera+v/5.*d-iTime/5.);\n            f=pow(f,5./diff);\n            skyC2+=(sqrt(float(i))*f*(1./d));\n        }\n    }\n    return mix(skyC, skyC2, 1.1-clamp(d/75.,.1,1.));\n}\nfloat trace (vec3 o, vec3 d) {\n    float t = 0.;\n    for (int i = 0; i < 100; ++i) {\n        if(t>30.)break;\n   \t\tt+=map(o+d*t).x; \n    }\n    return t;\n}\nconst float pi = acos(-1.);\nvec3 shade(vec3 i, vec3 dr) {\n    vec2 d = map(i);\n    vec3 c = vec3(1);\n    vec3 n = normal(i);\n    if (d.y==0.) {\n        vec3 r = reflect(dr,n);\n        float fres = dot(n,-dr);\n        c=mix((sky(r)/7.+1.)*vec3(1,1.2,4),vec3(0,.5,8),fres/2.);\n    }\n   \n    return c;\n}\nvec3 render (vec2 u)     \n{\n    camera.z+=iTime;\n    vec3 o = camera;\n    vec3 d = normalize(vec3((u*2.-1.)*(R.xz/R.yz),1));\n    vec3 c = sky(d);\n    \n    \n    float t = trace(o,d);\n    \n    vec3 i = o+d*t;\n    if (map(i).x<.02) {\n     \tc = mix(shade(i,d),c,t/30.);   \n       \t\n    }\n    \n    //vignetting\n    c=vignette( u, c );\n    \n    \n    //Reinhard Exposure & gamma correction\n   \tc/=c+1.;\n    c=pow(c,vec3(1./2.2));\n    return c;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/R.xy;\n\tfragColor = vec4(render(uv),1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4t3XzS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tc3DX", "name": "Glorious Line Algorithm", "author": "otaviogood", "description": "This is an attempt to solve everything anyone could want from a line in one function. See comments.", "tags": ["line", "circle", "antialiasing", "antialias", "rectangle", "algorithm", "rounded"], "likes": 52, "viewed": 1796, "date": "1477983763", "time_retrieved": "2024-06-20T18:44:03.261255", "image_code": "/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n-Otavio Good\n\n**************** Glorious Line Algorithm ****************\nThis is an attempt to solve everything anyone could want from a line in one function.\nGlorious features:\n- antialiasing\n- rectangles, squares, lines, circles, rounded rectangles\n- square or rounded endpoints\n- outline shapes (might have some bugs still)\n- dashed, animated lines\n- resolution dependent or independent - some functions work in pixel units, some in UV coordinates.\n- efficient\n*/\n\n// Clamp [0..1] range\n#define saturate(a) clamp(a, 0.0, 1.0)\n\n// Basically a triangle wave\nfloat repeat(float x) { return abs(fract(x*0.5+0.5)-0.5)*2.0; }\n\n// This is it... what you have been waiting for... _The_ Glorious Line Algorithm.\n// This function will make a signed distance field that says how far you are from the edge\n// of the line at any point U,V.\n// Pass it UVs, line end points, line thickness (x is along the line and y is perpendicular),\n// How rounded the end points should be (0.0 is rectangular, setting rounded to thick.y will be circular),\n// dashOn is just 1.0 or 0.0 to turn on the dashed lines.\nfloat LineDistField(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded, float dashOn) {\n    // Don't let it get more round than circular.\n    rounded = min(thick.y, rounded);\n    // midpoint\n    vec2 mid = (pB + pA) * 0.5;\n    // vector from point A to B\n    vec2 delta = pB - pA;\n    // Distance between endpoints\n    float lenD = length(delta);\n    // unit vector pointing in the line's direction\n    vec2 unit = delta / lenD;\n    // Check for when line endpoints are the same\n    if (lenD < 0.0001) unit = vec2(1.0, 0.0);\t// if pA and pB are same\n    // Perpendicular vector to unit - also length 1.0\n    vec2 perp = unit.yx * vec2(-1.0, 1.0);\n    // position along line from midpoint\n    float dpx = dot(unit, uv - mid);\n    // distance away from line at a right angle\n    float dpy = dot(perp, uv - mid);\n    // Make a distance function that is 0 at the transition from black to white\n    float disty = abs(dpy) - thick.y + rounded;\n    float distx = abs(dpx) - lenD * 0.5 - thick.x + rounded;\n\n    // Too tired to remember what this does. Something like rounded endpoints for distance function.\n    float dist = length(vec2(max(0.0, distx), max(0.0,disty))) - rounded;\n    dist = min(dist, max(distx, disty));\n\n    // This is for animated dashed lines. Delete if you don't like dashes.\n    float dashScale = 2.0*thick.y;\n    // Make a distance function for the dashes\n    float dash = (repeat(dpx/dashScale + iTime)-0.5)*dashScale;\n    // Combine this distance function with the line's.\n    dist = max(dist, dash-(1.0-dashOn*1.0)*10000.0);\n\n    return dist;\n}\n\n// This makes a filled line in pixel units. A 1.0 thick line will be 1 pixel thick.\nfloat FillLinePix(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded) {\n    float scale = abs(dFdy(uv).y);\n    thick = (thick * 0.5 - 0.5) * scale;\n    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 0.0);\n    return saturate(df / scale);\n}\n\n// This makes an outlined line in pixel units. A 1.0 thick outline will be 1 pixel thick.\nfloat DrawOutlinePix(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded, float outlineThick) {\n    float scale = abs(dFdy(uv).y);\n    thick = (thick * 0.5 - 0.5) * scale;\n    rounded = (rounded * 0.5 - 0.5) * scale;\n    outlineThick = (outlineThick * 0.5 - 0.5) * scale;\n    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 0.0);\n    return saturate((abs(df + outlineThick) - outlineThick) / scale);\n}\n\n// This makes a line in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat FillLine(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded) {\n    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 0.0);\n    return saturate(df / abs(dFdy(uv).y));\n}\n\n// This makes a dashed line in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat FillLineDash(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded) {\n    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 1.0);\n    return saturate(df / abs(dFdy(uv).y));\n}\n\n// This makes an outlined line in UV units. A 1.0 thick outline will span 0..1 in UV space.\nfloat DrawOutline(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded, float outlineThick) {\n    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 0.0);\n    return saturate((abs(df + outlineThick) - outlineThick) / abs(dFdy(uv).y));\n}\n\n// This just draws a point for debugging using a different technique that is less glorious.\nvoid DrawPoint(vec2 uv, vec2 p, inout vec3 col) {\n    col = mix(col, vec3(1.0, 0.25, 0.25), saturate(abs(dFdy(uv).y)*8.0/distance(uv, p)-4.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Adjust UV space so it's a nice size and square.\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 16.0;\n\n    // Make things that rotate with time.\n    vec2 rotA = vec2(cos(iTime*0.82), sin(iTime*0.82));\n    vec2 rotB = vec2(sin(iTime*0.82), -cos(iTime*0.82));\n    // Make a bunch of line endpoints to use.\n    vec2 pA = vec2(-4.0, 0.0) - rotA;\n    vec2 pB = vec2(4.0, 0.0) + rotA;\n    vec2 pC = pA + vec2(0.0, 4.0);\n    vec2 pD = pB + vec2(0.0, 4.0);\n    // Debugging code\n    //float df = LineDistField(uv, pA, pB, vec2(28.0 * dFdy(uv).y), 0.1, 0.0);\n    //float df = DistField(uv, pA, pB, 25.000625 * dFdx(uv).x, 0.5);\n    //vec3 finalColor = vec3(df*1.0, -df*1.0, 0.0);\n    //finalColor = vec3(1.0) * saturate(df / dFdy(uv).y);\n    //finalColor = vec3(1.0) * saturate((abs(df+0.009)-0.009) / dFdy(uv).y);\n\n    // Clear to white.\n    vec3 finalColor = vec3(1.0);\n\n    // Lots of sample lines\n    // 1 pixel thick regardless of screen scale.\n    finalColor *= FillLinePix(uv, pA, pB, vec2(1.0, 1.0), 0.0);\n    // Rounded rectangle outline, 1 pixel thick\n    finalColor *= DrawOutlinePix(uv, pA, pB, vec2(32.0), 16.0, 1.0);\n    // square-cornered rectangle outline, 1 pixel thick\n    finalColor *= DrawOutlinePix(uv, pA, pB, vec2(64.0), 0.0, 1.0);\n    // Fully rounded endpoint with outline 8 pixels thick\n    finalColor *= DrawOutlinePix(uv, pA, pB, vec2(128.0), 128.0, 8.0);\n    // Dashed line with rectangular endpoints that touch pC and pD, 0.5 radius thickness in UV units\n    finalColor *= FillLineDash(uv, pC, pD, vec2(0.0, 0.5), 0.0);\n    // Rounded endpoint dashed line with radius 0.125 in UV units\n    finalColor *= FillLineDash(uv, pC + vec2(0.0, 2.0), pD + vec2(0.0, 2.0), vec2(0.125), 1.0);\n    \n    finalColor *= DrawOutline(uv, (pA + pB) * 0.5 + vec2(0.0, -4.5), (pA + pB) * 0.5 + vec2(0.0, -4.5), vec2(2.0, 2.0), 2.0, 0.8);\n    finalColor *= FillLine(uv, pA - vec2(4.0, 0.0), pC - vec2(4.0, 0.0)+rotA, vec2(0.125), 1.0);\n    finalColor *= FillLine(uv, pB + vec2(4.0, 0.0), pD + vec2(4.0, 0.0)-rotA, vec2(0.125), 1.0);\n\n    DrawPoint(uv, pA, finalColor);\n    DrawPoint(uv, pB, finalColor);\n    DrawPoint(uv, pC, finalColor);\n    DrawPoint(uv, pD, finalColor);\n\n    // Blue grid lines\n    finalColor -= vec3(1.0, 1.0, 0.2) * saturate(repeat(uv.x*2.0) - 0.92)*4.0;\n    finalColor -= vec3(1.0, 1.0, 0.2) * saturate(repeat(uv.y*2.0) - 0.92)*4.0;\n    //finalColor *= saturate(mod(fragCoord.y + 0.5, 2.0) + mod(fragCoord.x + 0.5, 2.0));\n    fragColor = vec4(sqrt(saturate(finalColor)), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc0-1.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tc3DX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tcSR4", "name": "#codevember - 03", "author": "jcksmssng", "description": "Day 3 - Trying out the smooth minimum on 2 shapes\nFollowing super tutorial from hughsk\nhttps://hughsk.io/fragment-foundry/chapters/09b-blending-shapes.html", "tags": ["noob", "smoothmin", "codevember"], "likes": 7, "viewed": 688, "date": "1478268625", "time_retrieved": "2024-06-20T18:44:03.509775", "image_code": "float map(float value, float oldMin, float oldMax, float newMin, float newMax) {\n    return newMin + (newMax - newMin) * (value - oldMin) / (oldMax - oldMin);\n}\n\n// Smooth minimum by the great iquilezles.org\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat circle ( vec2 point, vec2 orig, float radius ) {\n   \treturn length(point - orig) - radius;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Fixes the aspect ratio to match a square frame\n\t// get values between -1 and +1 for the current pixel\n    vec2 res = iResolution.xy;\n\tvec2 uv = (2.0 * fragCoord - res) / res.y;\n    float radius = 0.5;\n    \n    // Create the circles and apply smooth min to them\n    float circle1 = circle(uv, vec2(sin(iTime) * .9, 0.0), radius);\n    float circle2 = circle(uv, -1.0 * vec2(sin(iTime) * .9, 0.0), radius);\n    float dist = smin(circle1, circle2, .3);\n    \n    // Put back the pos.x in a (0.0, 1.0) coordinates\n    // Then if dir is < 0.0 return the pos otherwise 1.0 - pos\n    float m = map(uv.x, -1.0, 1.0, 0.0, 1.0);\n    float c = dist < 0.0 ? m : 1.0 - m;\n\tvec3 color = vec3(.5 * c, .18, .2 * c);\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tcSR4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tcXWH", "name": "Soleil tout noir", "author": "Matnard", "description": "function drawing", "tags": ["2d"], "likes": 1, "viewed": 119, "date": "1479210029", "time_retrieved": "2024-06-20T18:44:03.509775", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    vec2 p = fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n    \n    vec2 q = p - vec2(0.5,0.5);\n    vec3 color = vec3(1.0,1.0,1.0);\n    \n    float amplitude = abs(sin(iTime * 3.1416)) * 0.05;\n    \n\tfloat r = 0.2 + amplitude * cos( atan(q.y,q.x) * 20.0 );\n    \n    \n    color *= smoothstep(r, r+0.01,length(q));\n    \n    fragColor = vec4(color, 1.0);\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tcXWH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tcXWn", "name": "Dim", "author": "VoidChicken", "description": "A dim glow.", "tags": ["2d", "glow", "dim"], "likes": 1, "viewed": 94, "date": "1478890499", "time_retrieved": "2024-06-20T18:44:03.509775", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv-=.5;\n    uv.x*=iResolution.x/iResolution.y;\n    uv+=.5;\n    float rand = texture(iChannel0, iTime*vec2(.01)).r;\n    vec3 col = vec3(0);\n    float h = sin(uv.y*30.-iTime-rand*5.)/5.;\n    float kl = length((uv)-.5);\n    float v = .4+h/10.+rand/5.;\n    if (kl<v) {\n        float u = abs(kl-v-.002);\n        float c = 1.-u;\n        c=pow(c,100.);\n    \tcol = vec3(.9*u+atan(c-cos(u)), .75*u, u+sin(c*64.)*u);    \n    }\n    col*=min(1., iTime);\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tcXWn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tdSDN", "name": "nanoscale", "author": "SudoNhim", "description": "The world is made of atoms, which are basically like billiard balls, apparently :)", "tags": ["terrain", "voxels", "pseudoscience"], "likes": 35, "viewed": 577, "date": "1479690181", "time_retrieved": "2024-06-20T18:44:04.448994", "image_code": "#define PI 3.14159\n\n#define VOXEL_NONE  0\n#define VOXEL_WATER 1\n#define VOXEL_SAND  2\n#define VOXEL_EARTH 3\n#define VOXEL_STONE 4\n#define VOXEL_GRASS 5\n\n// from https://www.shadertoy.com/view/4sfGzS\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n    vec2 uv = p.xy + f.xy;\n\tvec2 rg = vec2(texture( iChannel0, (uv+vec2(37.0,17.0)*p.z+0.5)/256.0, -100.0 ).x,\n                   texture( iChannel0, (uv+vec2(37.0,17.0)*(p.z+1.0)+0.5)/256.0, -100.0 ).x );\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nint getVoxelAt(ivec3 ip)\n{ \n    if (ip.y <= 0) return VOXEL_WATER;\n    \n    // so this is like, grabbing the texture as a heightmap and\n    // then like twisting it in random directions as it goes up\n    // umm...\n    vec3 p = vec3(vec3(ip) + 0.5);\n    float theta = noise(p / 16.0) * PI * 2.0;\n    vec2 disp = vec2(cos(theta), sin(theta)) * p.y;\n    vec3 terr = texture(iChannel1, (p.xz + disp) / 128.0).rgb;\n\n    bvec3 contains = lessThanEqual(vec3(0.0), (terr - p.y/16.0));\n    if (contains.x && contains.y && !contains.z) return VOXEL_SAND;\n    if (contains.x && contains.z) return VOXEL_GRASS;\n    if (contains.y && contains.z && !contains.x) return VOXEL_STONE;\n    if (contains.x || contains.y || contains.z) return VOXEL_EARTH;\n\n    return VOXEL_NONE;\n}\n\nfloat dfVoxel(vec3 p, int voxelType)\n{\n    return length(p) - 0.5;\n}\n\nvec3 nrmVoxel(vec3 p, int voxelType) \n{\n    vec2 dd = vec2(0.001,0.0);\n    float base = dfVoxel(p, voxelType);\n    return normalize(vec3(\n        dfVoxel(p+dd.xyy, voxelType) - base,\n        dfVoxel(p+dd.yxy, voxelType) - base,\n        dfVoxel(p+dd.yyx, voxelType) - base\n    ));\n}\n\nvoid voxelMarch(vec3 ro, vec3 rd, out ivec3 hitVoxels[4], out int hitCount) \n{\n    hitCount = 0;\n\n    ivec3 mapPos = ivec3(floor(ro));\n    vec3 deltaDist = abs(vec3(length(rd)) / rd);\n    ivec3 rayStep = ivec3(sign(rd));\n    vec3 sideDist = (sign(rd) * (vec3(mapPos) - ro) + (sign(rd) * 0.5) + 0.5) * deltaDist; \n    bvec3 mask;\n\t\n    for (int i = 0; i < 128; i++) {\n\n        // check current position for voxel\n        if (getVoxelAt(mapPos) != VOXEL_NONE) {\n            // no non-const indexing? :<\n            if (hitCount == 0) hitVoxels[0] = mapPos;\n            else if (hitCount == 1) hitVoxels[1] = mapPos;\n            else if (hitCount == 2) hitVoxels[2] = mapPos;\n            else if (hitCount == 3) hitVoxels[3] = mapPos;\n            hitCount++;\n            if (hitCount == 4) return;\n        }\n\n        // march forward to next position by discrete digital analyzer\n        if (sideDist.x < sideDist.y) {\n            if (sideDist.x < sideDist.z) {\n                sideDist.x += deltaDist.x;\n                mapPos.x += rayStep.x;\n                mask = bvec3(true, false, false);\n            } else {\n                sideDist.z += deltaDist.z;\n                mapPos.z += rayStep.z;\n                mask = bvec3(false, false, true);\n            }\n        } else {\n            if (sideDist.y < sideDist.z) {\n                sideDist.y += deltaDist.y;\n                mapPos.y += rayStep.y;\n                mask = bvec3(false, true, false);\n            } else {\n                sideDist.z += deltaDist.z;\n                mapPos.z += rayStep.z;\n                mask = bvec3(false, false, true);\n            }\n        }\n    }\n}\n\nvoid resolveHitVoxels(\n    vec3 ro, vec3 rd, ivec3 hitVoxels[4], int hitCount, \n    out ivec3 hitVoxel, out vec3 hit, out int terrainType) \n{ \n  for (int i=0; i<4; i++) {\n    if (i == hitCount) return;\n    \n    hitVoxel = hitVoxels[i];\n    terrainType = getVoxelAt(hitVoxel);\n    vec3 hitVoxelCenter = vec3(hitVoxel) + 0.5;\n    \n    // intersect with voxel cube\n    vec3 cubeIntersect = (hitVoxelCenter - ro - 0.5*sign(rd))/rd;\n    float d = max(cubeIntersect.x, max(cubeIntersect.y, cubeIntersect.z));\n\n    // fallback in case of no distance intersection\n    hit = ro + rd * (d - 0.01) - hitVoxelCenter;\n      \n    // attempt better intersect with distance marching\n    float diff;\n    vec3 p = ro + rd * d;\n    for (int j=0; j<4; j++) {\n      diff = dfVoxel(p - hitVoxelCenter, terrainType);\n      d += diff;\n      p = ro + rd * d;\n    }\n    if (diff < 0.05) { // good enough distance marched intersection\n      hit = p - hitVoxelCenter;\n      return;\n    }\n  }\n}\n\nvec3 doColoring(vec3 hit, int terrainType, vec3 ldir)\n{\n    vec3 n = nrmVoxel(hit, terrainType);\n    float diffuse = max(dot(-ldir, n), 0.1);\n    \n    // render\n    vec3 color = vec3(0.0);\n    if (terrainType == VOXEL_WATER) color.b = 1.0;\n    if (terrainType == VOXEL_EARTH) color.r = 1.0;\n    if (terrainType == VOXEL_SAND) color.rg = vec2(1.0);\n    if (terrainType == VOXEL_STONE) color.rgb = vec3(0.5);\n    if (terrainType == VOXEL_GRASS) color.g = 1.0;\n    \n    color *= diffuse;\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera stolen from Shane :) https://www.shadertoy.com/view/ll2SRy\n\tvec2 uv = (fragCoord - iResolution.xy*.5 )/iResolution.y;\n    vec3 rd = normalize(vec3(uv, (1.-dot(uv, uv)*.5)*.5));\n    vec3 ro = vec3(0., 20., iTime*10.0);\n    float t = sin(iTime * 0.2) + noise(ro/32.0);\n    ro.y += 4.0*t;\n\tfloat cs = cos( t ), si = sin( t );\n    rd.yz = mat2(cs, si,-si, cs)*rd.yz;\n    rd.xz = mat2(cs, si,-si, cs)*rd.xz;\n    \n    // voxel march into the scene storing up to four intersections\n    int hitCount;\n    ivec3 hitVoxels[4];\n    voxelMarch(ro, rd, hitVoxels, hitCount);\n\n    // resolve to one accurate intersection by distance marching\n    int terrainType = VOXEL_NONE;\n    ivec3 hitVoxel;\n    vec3 hit;\n    resolveHitVoxels(ro, rd, hitVoxels, hitCount, hitVoxel, hit, terrainType);\n\n    vec3 hitGlobal = vec3(hitVoxel) + hit;\n    \n    // color\n    vec3 ldir = normalize(hitGlobal - ro);\n    vec3 color = doColoring(hit, terrainType, ldir);\n    \n    // fog\n    float fog = smoothstep(1.0, 0.0, length(hitGlobal - ro)/96.0);\n    color *= fog;\n    \n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tdSDN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tdSW8", "name": "Ice Cream", "author": "lara", "description": "Yummy.", "tags": ["ice", "cream"], "likes": 4, "viewed": 387, "date": "1479314491", "time_retrieved": "2024-06-20T18:44:04.455140", "image_code": "#define S 256   // Steps\n#define P 0.001 // Precision\n#define R 2.    // Marching substeps\n#define D 20.   // Max distance\n#define K 8.    // Shadow softness\n\n#define T iTime\n#define PI 3.1415926\n#define TAU (PI*2.0)\n\nstruct Ray { vec3 o, d; };\nstruct Camera { vec3 p, t; };\nstruct Hit { vec3 p; float t, d; };\n\nvec2 _uv;\nbool _normalMarch = false;\nCamera _cam = Camera(vec3(0,1,-2.5), vec3(0,0.2,0));\nfloat _d, _chocolateBar, _dcone, _dcream;\n\nmat3 rotX(float a){float c=cos(a),s=sin(a);return mat3(1,0,0,0,c,-s,0,s,c);}\nmat3 rotY(float a){float c=cos(a),s=sin(a);return mat3(c,0,-s,0,1,0,s,0,c);}\nmat3 rotZ(float a){float c=cos(a),s=sin(a);return mat3(c,-s,0,s,c,0,0,0,1);}\n\n// http://www.iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat mylength(vec3 v,float e)\n{\n    v = pow(abs(v),vec3(e));\n    return pow(v.x+v.y+v.z,1./e);\n}\n                                        \nfloat sdLine(vec3 p, vec3 a, vec3 b, float r, float e)\n{\n    vec3 ab = b-a, ap = p-a;\n    return mylength(ap-ab*clamp(dot(ap,ab)/dot(ab,ab),0.,1.),e)-r;\n}\n\nfloat scene(vec3 p)\n{\n    p *= rotY(-T);\n    \n    vec3 q = p;\n    \n    _d = 1e10;\n\n\t_dcone = max(\n        sdLine(p,vec3(0),vec3(0,-2,0),0.3*(2.-abs(p.y))+0.05,2.0),\n       -sdLine(p,vec3(0),vec3(0,-2,0),0.33*(2.-abs(p.y-0.3))+0.05,2.0)\n    );\n\n    if (_normalMarch == true) { q -= textureLod(iChannel0,p.xz,0.).x*0.0001; }\n    _chocolateBar = sdLine(q,vec3(0,0,0),vec3(0,1.5,0.5),0.1,8.0);\n    \n    q = p; q.y -= 0.9;\n    q *= rotX(max(q.y*0.5,0.0));\n    \n    if (_normalMarch == true) { q.y -= textureLod(iChannel0,p.xz,0.).x*0.01; }\n    \n    _dcream = sdLine(q*rotY(q.y*TAU),vec3(0,0,0),vec3(0,1,0),0.45*(1.-q.y)+(1.-q.y*10.)*0.01,3.0);\n\t_dcream = smin(_dcream,_chocolateBar,0.05);\n    \n    _d = min(_d,_dcream);\n    _d = min(_d,_dcone);\n    _d = min(_d,_chocolateBar);\n    \n    return _d;\n}\n\nvec3 getNormal(vec3 p)\n{\n    _normalMarch = true;\n\n\tvec2 e = vec2(P,0);\n    \n\treturn normalize(vec3(\n\t\tscene(p+e.xyy)-scene(p-e.xyy),\n\t\tscene(p+e.yxy)-scene(p-e.yxy),\n\t\tscene(p+e.yyx)-scene(p-e.yyx)\n\t));\n}\n\nHit march(Ray r)\n{\n    float t = 0.0, d;\n    \n    for(int i = 0; i < S; i++)\n    {\n        d = scene(r.o+r.d*t);\n        t += d/R;\n        \n        if (d < P || t > D) { break; }\n    }\n    \n    return Hit(r.o+r.d*t, t, d);\n}\n\nRay lookAt(Camera cam, vec2 uv)\n{\n    vec3 dir = normalize(cam.t-cam.p);\n    vec3 right = normalize(cross(dir, vec3(0,1,0)));\n    vec3 up = cross(right, dir);\n\n    return Ray(cam.p, normalize(right*uv.x + up*uv.y + dir));\n}\n\nfloat getSSAO(Hit h) \n{    \n\tvec2 e = vec2(1./iResolution.x,0);\t\n\t\n\tfloat d = pow(abs(\n\t\t(h.t-march(lookAt(_cam,_uv+e.xy)).t)+\n\t\t(h.t-march(lookAt(_cam,_uv-e.xy)).t)+\n\t\t(h.t-march(lookAt(_cam,_uv+e.yx)).t)+\n\t\t(h.t-march(lookAt(_cam,_uv-e.yx)).t)\n\t),2.);\n\n\treturn clamp(1.-d*100.,0.,1.);\n}\n\nvec3 getColor(Hit h)\n{\n    if (h.d > P) { return vec3(0.2); }\n    \n    vec3 n = getNormal(h.p);\n    vec3 col = vec3(0);\n    vec3 light = _cam.p;\n\n    if(_d == _dcream)\n    {\n        float diff = max(dot(normalize(light-h.p),n),0.0);\n        float spec = pow(max(dot(normalize(reflect(h.p-_cam.p,n)),n),0.0),50.);\n        col = vec3(0.5+getSSAO(h)*0.5);\n    }\n    \n    if (_d == _dcone)\n    {\n        h.p *= rotY(-T);\n        \n        float a = atan(h.p.x,h.p.z);\n        float f = pow(abs(sin((a+h.p.y*2.)*9.)*sin((a-h.p.y*2.)*9.)),0.5)*max(ceil(dot(n,vec3(0,-1,0))),0.0);\n        \n        h.p -= n*f;\n        \n        float diff = max(dot(normalize(light-h.p),n),0.0);\n        float spec = pow(max(dot(normalize(reflect(h.p-_cam.p,n)),n),0.0),10.)*0.2;\n        \n        col = mix(vec3(190,128,57),vec3(252,199,106),f)/256.*diff+spec;\n    }\n    \n    if (_d == _chocolateBar)\n    {      \n        float diff = max(dot(normalize(light-h.p),n),0.0);\n        float spec = pow(max(dot(normalize(reflect(h.p-_cam.p,n)),n),0.0),100.);\n        \n        col = vec3(0.4,0.2,0)*diff+spec;\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    _uv = (2.0*fragCoord.xy-iResolution.xy)/iResolution.yy;\n    vec2 uvm = (2.0*iMouse.xy-iResolution.xy)/iResolution.yy;\n    \n    if (iMouse.y < 10.) { uvm.y =  0.1; }\n    if (iMouse.x < 10.) { uvm.x = -0.45; }\n    \n    _cam.p *= rotX(-uvm.y)*rotY(uvm.x*PI);\n    \n    float f = 1.-length((2.0*fragCoord.xy-iResolution.xy)/iResolution.xy)*0.5;\n    fragColor = vec4(getColor(march(lookAt(_cam,_uv))), 1.0)*f;\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tdSW8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tdSWN", "name": "Moving Julia set", "author": "sheepmaster", "description": "Julia set for a parameter moving in a Bezier interpolation between random control points. Click to use mouse position for the parameter.", "tags": ["2d", "fractal", "julia", "bezier"], "likes": 3, "viewed": 583, "date": "1480284719", "time_retrieved": "2024-06-20T18:44:04.455140", "image_code": "#define SCALE 3.0\n\n#define TIME_INTERVAL 3.0\n\n#define SHOW_INDICATOR false\n#define INDICATOR_RADIUS 2.0\n\n#define NUM_ITERATIONS 1024\n#define ESCAPE_RADIUS 10.0\n\n#define PI 3.14159265359\n\n// https://www.shadertoy.com/view/4dS3Wd\nfloat hash(int n) {\n    return fract(sin(float(n)) * 1e4);\n}\n\nfloat bezierInterpolate(vec4 p, float t) {\n    float oneMinusT = 1.0 - t;\n    vec4 weights = vec4(\n        oneMinusT * oneMinusT * oneMinusT,\n        3.0 * t * oneMinusT * oneMinusT,\n        3.0 * t * t * oneMinusT,\n        t * t * t);\n    return dot(weights, p);\n}\n\nvec2 boxMuller(vec2 u) {\n    float r = sqrt(-2.0 * log(u.x));\n    float theta = 2.0 * PI * u.y;\n    return r * vec2(cos(theta), sin(theta));\n}\n\n// Smooth HSV to RGB conversion \n// https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2RgbSmooth(float hue, float saturation, float value) {\n    vec3 rgb = clamp(abs(mod(hue*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0);\n\n\trgb = rgb*rgb*(3.0-2.0*rgb);  // Cubic smoothing\t\n\n\treturn value * mix(vec3(1.0), rgb, saturation);\n}\n\nfloat arg(vec2 z) {\n    return atan(z.y, z.x) / (2.0 * PI);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float scalingFactor = min(iResolution.x, iResolution.y) / SCALE;\n\tvec2 scaledCoord = (fragCoord.xy - iResolution.xy / 2.0) / scalingFactor;\n    \n    vec2 pos;\n    if (iMouse.z + iMouse.w > 0.0) {\n        pos = (iMouse.xy - iResolution.xy / 2.0) / scalingFactor;\n    } else {\n        int timeStep = int(iTime / TIME_INTERVAL);\n        float timeRel = fract(iTime / TIME_INTERVAL);\n\n        vec2 pos1 = vec2(hash(4 * timeStep), hash(4 * timeStep + 1)) * 2.0 - vec2(1.0);\n        vec2 dir1 = boxMuller(vec2(hash(4 * timeStep + 2), hash(4 * timeStep + 3)));\n        vec2 pos2 = vec2(hash(4 * timeStep + 4), hash(4 * timeStep + 5)) * 2.0 - vec2(1.0);\n        vec2 dir2 = boxMuller(vec2(hash(4 * timeStep + 6), hash(4 * timeStep + 7)));\n\n        pos = vec2(\n            bezierInterpolate(vec4(pos1.x, pos1.x + dir1.x, pos2.x - dir2.x, pos2.x), timeRel),\n            bezierInterpolate(vec4(pos1.y, pos1.y + dir1.y, pos2.y - dir2.y, pos2.y), timeRel));\n\n        vec2 dist = scaledCoord - pos;\n        if (SHOW_INDICATOR && (distance(scaledCoord, pos) < INDICATOR_RADIUS / scalingFactor)) {\n            fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n            return;\n        }\n    }\n    \n    // Iterate\n    vec2 z = scaledCoord;\n    vec2 dz = vec2(0.0);\n\tfloat d = 0.0;\n    for(int i = 0; i < NUM_ITERATIONS; i++) {\n        if(length(z) > ESCAPE_RADIUS) {\n        \t// distance\t\n\t\t\t// d(c) = |Z|Â·log|Z|/|Z'|\n            d = 0.5 * sqrt(dot(z,z)/dot(dz,dz)) * log(dot(z,z));\n\n            // do some soft coloring based on distance\n            d = clamp(8.0 * d, 0.0, 1.0);\n            d = 1.0 - pow(d, 0.5);\n            break;\n        }\n        \n\t\t// Z' -> 2Â·ZÂ·Z' + 1\n        dz = 2.0 * vec2(z.x * dz.x - z.y * dz.y, z.x * dz.y + z.y * dz.x) + vec2(1.0, 0.0);\n\t\t\t\n        // Z -> ZÂ² + c\t\t\t\n        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + pos;\t\n    }\n\n    float hue = arg(scaledCoord) - arg(pos); \n    float sat = min(length(scaledCoord) * 5.0, 1.0);\n    vec3 col = hsv2RgbSmooth(hue, sat, d);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tdSWN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tdXWn", "name": "bp Triangles", "author": "blackpolygon", "description": "Experimenting with color", "tags": ["triangle", "color", "shape"], "likes": 1, "viewed": 154, "date": "1478993823", "time_retrieved": "2024-06-20T18:44:04.879403", "image_code": "// Author: blackpolygon\n// Title: Triangles\n\n//Experimenting with color\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 u_resolution;\nuniform float u_time;\n\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat shape(in vec2 st, int N, float radius){\n  // Remap the space to -1. to 1.\n  st = st *2.-1.;\n  // Angle and radius from the current pixel\n  float a = atan(st.x,st.y)+PI;\n  float r = TWO_PI/float(N);\n  // Shaping function that modulate the distance\n  return cos(floor(.5+a/r)*r-a)*length(st)*radius;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 st=(fragCoord.xy-.5*iResolution.xy)/min(iResolution.x,iResolution.y) + vec2(0.5);\n    float b1a0 = (0.5+(sin(iTime)*0.5));\n    \n    vec3 color = vec3(0.,b1a0*st.y+0.2,0.658);\n    vec2 stTriangle = st;\n    stTriangle.y += 0.1;\n    float t1 = shape(stTriangle, 3, 1.);\n    stTriangle.y -= 0.0;\n    float t2 = shape(stTriangle, 3, 1.2);\n    float t3 = shape(stTriangle, 3, 1.5);\n    float t4 = shape(stTriangle, 3, 2.060);\n    \n    st -= vec2(0.5);\n    st = rotate2d( sin(iTime/2.)*PI) * st;\n    st+= 0.5;\n    \n    vec3 bgColor = vec3((0.5 + sin(st.y)*0.5)*0.920,(0.5 + sin(st.x)*0.5)*0.836,0.716);\n    \n    float triangleMask = 1.-smoothstep(.4, 0.405,t1);\n    float triangleMask2 = 1.-smoothstep(.4, 0.405,t2);\n    float triangleMask3 = 1.-smoothstep(.4, 0.405,t3);\n    float triangleMask4 = 1.-smoothstep(.4, 0.405,t4);\n    \n    vec3 triangleColor = color*vec3(triangleMask);\n    vec3 triangleColor2 = color*vec3(triangleMask2)*0.4;\n    vec3 triangleColor3 = color*vec3(triangleMask3)*0.2;\n    vec3 triangleColor4 = color*vec3(triangleMask4)*0.1;\n    \n    float mask3 = 1.0-triangleMask;\n    \n    vec3 finalColor = vec3(0.);\n    \n    finalColor += triangleColor;\n    finalColor *= 1.0-triangleMask2;\n    finalColor += triangleColor2;\n    finalColor *= 1.0-triangleMask3;\n    finalColor += triangleColor3;\n    finalColor *= 1.0-triangleMask4;\n    finalColor += triangleColor4;\n    \n    finalColor += bgColor*vec3(mask3);\n    \n\tfragColor = vec4(finalColor,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tdXWn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4ttSDM", "name": "Overwatch Spinner", "author": "antonOTI", "description": "I really like the overwatch spinner when searching for a game. the combination of motions is so smooth yet complex.\nSurely the code can be simplified and optimized but I'm too tired for this :)", "tags": ["2d", "spinner", "fanart", "overwatch"], "likes": 38, "viewed": 1703, "date": "1479978388", "time_retrieved": "2024-06-20T18:44:04.879403", "image_code": "#define _Smooth(p,r,s) smoothstep(-s, s, p-(r))\n#define PI 3.141592\n#define TPI 6.2831\n#define HPI 1.570796\n\nfloat GetBias(float x,float bias)\n{\n  return (x / ((((1.0/bias) - 2.0)*(1.0 - x))+1.0));\n}\nfloat GetGain(float x,float gain)\n{\n  if(x < 0.5)\n    return GetBias(x * 2.0,gain)/2.0;\n  else\n    return GetBias(x * 2.0 - 1.0,1.0 - gain)/2.0 + 0.5;\n}\n\n// from http://iquilezles.org/www/articles/smin/smin.htm\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k)\n{\n    return (-smin(-a,-b,k));\n}\n\nfloat sclamp(float f,float k)\n{\n    return smin(1.,smax(0.,f,k),k);\n}\n\n\n\nfloat hex(vec2 pos)\n{\n    const float corner = .015;\n    vec2 q = abs(pos);\n\treturn smax(\n        smax((q.x * 0.866025 +pos.y*0.5),q.y,corner),\n        smax((q.x * 0.866025 -pos.y*0.5),q.y,corner),corner);\n}\n\nfloat hexRadiusFactor(float time)\n{\n    time *= 2.;\n    float s = sclamp(sin(time )+.65,.25);\n\t\n    return s;\n}\n\nvoid hexFest(inout vec3 col,in vec2 uv, in float time)\n{\n    vec3 hexColor = vec3(0.294,0.360,0.478);\n    \n    float a =- PI / 3.;\n    float sa = sin(a);\n    float ca = cos(a);\n    uv = mat2(sa,ca,ca,-sa) * uv;\n    \n     //hexagones\n    float deltaTime = 1./8. * 1.2;\n    float baseHexRadius = .1;\n    vec2 hexDelta = vec2(.195,.21);\n    \n    float timeAccu = 1.;\n    \n    float rf,radius,f = 0.;\n    \n    \n    \n    //hex1\n    timeAccu += 1.;\n    rf = hexRadiusFactor(time + deltaTime * timeAccu);\n    radius = baseHexRadius * rf;\n    \n    f = hex(uv);\n    f = _Smooth(radius,f,.0025);\n\n    col = mix(col,hexColor,f * rf);\n    \n    //hex2\n    timeAccu += 1.;\n    rf = hexRadiusFactor(time + deltaTime * timeAccu);\n    radius = baseHexRadius * rf;\n    \n    f = hex(uv - hexDelta * vec2(1.,.5));\n    f = _Smooth(radius,f,.0025);\n\n    col = mix(col,hexColor,f * rf);\n    \n    //hex3\n    timeAccu += 1.;\n    rf = hexRadiusFactor(time + deltaTime * timeAccu);\n    radius = baseHexRadius * rf;\n    \n    f = hex(uv - hexDelta * vec2(1.,-.5));\n    f = _Smooth(radius,f,.0025);\n\n    col = mix(col,hexColor,f * rf);\n    \n    //hex4\n    timeAccu += 1.;\n    rf = hexRadiusFactor(time + deltaTime * timeAccu);\n    radius = baseHexRadius * rf;\n    \n    f = hex(uv - hexDelta * vec2(.0,-1.));\n    f = _Smooth(radius,f,.0025);\n\n    col = mix(col,hexColor,f * rf);\n    \n    //hex5\n    timeAccu += 1.;\n    rf = hexRadiusFactor(time + deltaTime * timeAccu);\n    radius = baseHexRadius * rf;\n    \n    f = hex(uv - hexDelta * vec2(-1.,-.5));\n    f = _Smooth(radius,f,.0025);\n\n    col = mix(col,hexColor,f * rf);\n    \n    //hex6\n    timeAccu += 1.;\n    rf = hexRadiusFactor(time + deltaTime * timeAccu);\n    radius = baseHexRadius * rf;\n    \n    f = hex(uv - hexDelta * vec2(-1.,.5));\n    f = _Smooth(radius,f,.0025);\n\n    col = mix(col,hexColor,f * rf);\n    \n    \n    //hex7\n    timeAccu += 1.;\n    rf = hexRadiusFactor(time + deltaTime * timeAccu);\n    radius = baseHexRadius * rf;\n    \n    f = hex(uv - hexDelta * vec2(0.,1.));\n    f = _Smooth(radius,f,.0025);\n\n    col = mix(col,hexColor,f * rf);\n}\n\n\n#define _Circle(l,r,ht,s) _Smooth(len,r-ht,s) - _Smooth(len,r+ht,s) \n\nvoid circleFest(inout vec3 col,in vec2 uv, in float time)\n{\n\tfloat len = length(uv);\n    float ang = atan(uv.y,uv.x);\n    \n    vec3 circleCol = vec3(0.);\n    \n    float f = (_Circle(len,.45,.003,.013)) * .15;\n    col = mix(col,circleCol,f);\n    \n    time = -1.485 + time*2.;// * 2. + 1.4;\n    \n    float a = (ang + time) / TPI;\n    a = (a - floor(a));\n    \n    f = (_Circle(len,.45,.006,.013)) *.05;\n    \n    float startTime = max(mod(time + HPI,TPI),PI) + HPI;\n    \n    float start = sin(startTime) * .5 + .5;\n    \n    float endTime = min(mod(time + HPI,TPI),PI) + HPI;\n    \n    float end = sin(endTime)*.5+.5;\n    \n    f *= step(a,1.-start) - step(a,end);\n    col = mix(col,circleCol,f*3.5);\n    \n    f = (_Circle(len,.45,.003,.013)) ;\n    f *= step(a,.04 + sin(time) * .01) - step(a,0.);\n   \n    col = mix(col,circleCol,f);\n   \n    f = (_Circle(len,.62,.003,.013)) ;\n    col = mix(col,circleCol,f*.25);\n    \n    f = (_Circle(len,.62,.003,.013)) ;\n    \n    time += 1.;\n    time = GetGain(fract(time/TPI),.25) * TPI;\n    a = (ang - time - 1.5) / TPI;\n    a += sin(time) * .15;\n    a = (a - floor(a)) ;\n    //a = GetBias(a,.65);\n    f *= step(a,.03 ) - step(a,0.);\n    col = mix(col,circleCol,f);\n    \n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.y) - vec2(iResolution.x / iResolution.y * .5,.5);\n    uv *= 1.6;\n    vec3 col = vec3(.1,.0,.4) + vec3(pow(1.-length(uv*.25),.4));\n    \n    float time = iTime + 1.1;\n    \n    hexFest(col,uv,time);\n    circleFest(col,uv,time);\n   \n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ttSDM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4ttSRH", "name": "#codevember - 02", "author": "jcksmssng", "description": "Day 2 - Moving square", "tags": ["codevember"], "likes": 0, "viewed": 482, "date": "1478265929", "time_retrieved": "2024-06-20T18:44:04.879403", "image_code": "float map(float value, float oldMin, float oldMax, float newMin, float newMax) {\n    return newMin + (newMax - newMin) * (value - oldMin) / (oldMax - oldMin);\n}\n\nfloat square(vec2 point, vec2 dimensions) {\n  vec2 origin = vec2(sin(iTime * 2.0)/3.0, 0.0);\n  vec2 d = abs(point - origin) - dimensions;\n  float dist = min(max(d.x, d.y),0.0) + length(max(d,0.0));\n  float m = map(point.x, -1.0, 1.0, 0.0, 1.0);\n  return dist < 0.0 ? m : 1.0 - m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Fixes the aspect ratio to match a square frame\n\t// get values between -1 and +1 for the current pixel\n    vec2 res = iResolution.xy;\n\tvec2 uv = (2.0 * fragCoord - res) / res.y;\n    float blue = square(uv, vec2(.5, .5));\n\tvec3 color = vec3(.3 * blue, .3 * blue, blue);\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ttSRH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4ttSRN", "name": "#codevember - 07", "author": "jcksmssng", "description": "Today we try ray tracing + some displacement functions\nRay tracing tutorial by the awesome Cabbibo\nhttps://www.shadertoy.com/view/Xl2XWt", "tags": ["3d", "raytracing", "noob", "codevember"], "likes": 3, "viewed": 899, "date": "1478555868", "time_retrieved": "2024-06-20T18:44:05.849180", "image_code": "const float SURFACE_HIT_PRECISION = .001;\nconst float MAX_DIST = 10.;\nconst int MAX_STEPS = 100;\n\n// EyeRay Transformation Matrix from the great @cabbibo\n// https://www.shadertoy.com/view/Xl2XWt\nmat3 calculateEyeRayTransformationMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nfloat map( float value, float oldMin, float oldMax, float newMin, float newMax ) \n{\n    return newMin + (newMax - newMin) * (value - oldMin) / (oldMax - oldMin);\n}\n\n\n// iquilezles.org\nfloat displacement( vec3 ray )\n{\n    float r = sin(iTime);\n    return sin( -1. * r + 10. * ray.x ) * sin( r + 11. * ray.y ) * sin( r + 9. * ray.z );\n}\n\n// SDF now returns a distance from object & an ID\nvec2 sphere ( vec3 ray ) \n{\n    vec3 orig = vec3( 0. , 0. , -3.0 );\n    float radius = 1.1;\n   \tfloat dist1 = length( ray - orig ) - radius;\n    float dist2 = displacement( ray );\n    float dist = dist1 + dist2;\n    float id = 1.;\n    \n\treturn vec2( dist, id );\n}\n\n// Inspired by @cabbibo\n// https://www.shadertoy.com/view/Xl2XWt\nvec2 checkRayHit( vec3 eyePos, vec3 rayDir )\n{\n  \tfloat distToSurface = SURFACE_HIT_PRECISION * 2.;\n    \n  \t// The total distance traveled by the ray obviously should start at 0\n  \tfloat totalDist = 0.;\n  \tfloat finalDist = 0.;\n    \n  \t// if our id is less that 0. , it means we haven't hit anything\n  \tfloat id = -1.;\n\n  \tfor( int i = 0; i < MAX_STEPS; i++ ) {\n    \t// Break if we hit the surface\n    \tif( distToSurface < SURFACE_HIT_PRECISION ) break;\n    \n    \t// Break if we reach end of the scene\n    \tif( totalDist > MAX_DIST ) break;\n    \n    \t// Current pos starts at eyePos then follows rayDir along the total distance traveled by the ray\n    \tvec3 currentPos = eyePos + rayDir * totalDist;\n    \tvec2 distToSphere = sphere( currentPos );\n \t\n\t\tid = distToSphere.y;\n        totalDist += distToSphere.x;\n\t}\n\n  \tif( totalDist < MAX_DIST ) {\n  \t\tfinalDist = totalDist;\n  \t}\n\n  \tif( totalDist > MAX_DIST ){ \n  \t\tfinalDist = MAX_DIST;\n    \tid = -1.;\n  \t}\n\n  \treturn vec2( finalDist , id );\n}\n\n// Original function from @cabbibo\n// https://www.shadertoy.com/view/Xl2XWt\nvec3 getSurfaceNormal( vec3 hitPos )\n{    \n\tvec3 tinyChangeX = vec3( 0.001, 0.0, 0.0 );\n    vec3 tinyChangeY = vec3( 0.0 , 0.001 , 0.0 );\n    vec3 tinyChangeZ = vec3( 0.0 , 0.0 , 0.001 );\n    \n   \tfloat upTinyChangeInX = sphere( hitPos + tinyChangeX ).x; \n    float downTinyChangeInX = sphere( hitPos - tinyChangeX ).x; \n    \n    float tinyChangeInX = upTinyChangeInX - downTinyChangeInX;\n    \n    \n    float upTinyChangeInY   = sphere( hitPos + tinyChangeY ).x; \n    float downTinyChangeInY = sphere( hitPos - tinyChangeY ).x; \n    \n    float tinyChangeInY = upTinyChangeInY - downTinyChangeInY;\n    \n    \n    float upTinyChangeInZ   = sphere( hitPos + tinyChangeZ ).x; \n    float downTinyChangeInZ = sphere( hitPos - tinyChangeZ ).x; \n    \n    float tinyChangeInZ = upTinyChangeInZ - downTinyChangeInZ;\n    \n    \n\tvec3 normal = vec3( tinyChangeInX, tinyChangeInY, tinyChangeInZ );\n    \n\treturn normalize(normal);\n}\n\n\nvec3 bgColor(vec3 rayDir)\n{\n    float b = map(rayDir.x, -1., 1., 0., 1.);\n\treturn vec3( .18, .18, b );\n}\n\n// Inspired by @cabbibo\n// https://www.shadertoy.com/view/Xl2XWt\nvec3 sphereColor( vec3 hitPos, vec3 surfaceNormal )\n{\n    vec3 lightPos = vec3( 1. , 4. , 3. );\n\n    // Get direction of light relative to the hit\n    vec3 lightDir = lightPos - hitPos;\n    lightDir = normalize( lightDir );\n    \n    // The dot product of the lightDir to the surfaceNormal of the hit\n    // Gives us how much that hit is facing the light source\n    // -1: faces opposite\n    // 1: faces completely the light\n    float faceValue = dot( lightDir , surfaceNormal );\n    faceValue = max( 0. , faceValue );\n    \n    float b = map( hitPos.x, -1., 1., 0., .8 );\n    vec3 color = vec3( .18 , .18 , b );\n   \t\n    // here's how we do some shadowing !\n    color *= faceValue;\n\treturn color;\n}\n\n// Inspired by @cabbibo\n// https://www.shadertoy.com/view/Xl2XWt\nvec3 color( vec2 rayHitInfo, vec3 eyePos, vec3 rayDir )\n{\n    vec3 color;\n    \n  \tif( rayHitInfo.y < 0.0 ) {\n  \t\tcolor = bgColor(rayDir);  \n  \t} else {\n      \tvec3 hitPos = eyePos + rayHitInfo.x * rayDir;\n\n      \tvec3 surfaceNormal = getSurfaceNormal( hitPos );\n      \n      \tif( rayHitInfo.y == 1. ){\n        \tcolor = sphereColor( hitPos , surfaceNormal ); \n      \t}\n  \t}\n    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Fixes the aspect ratio to match a square frame\n\t// get values between -1 and +1 for the current pixel\n\tvec2 uv = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n    vec3 eyePos = vec3( 0., 0., 2.);\n    vec3 lookAt = vec3( 0. , 0. , 0. );\n  \n    mat3 eyeTransformationMatrix = calculateEyeRayTransformationMatrix( eyePos, lookAt, 0. ); \n   \n    // For every pixel we throw a ray from the eye\n    vec3 ray = normalize( eyeTransformationMatrix * vec3( uv.xy , 2. ) ); \n    vec2 rayHitInfo = checkRayHit( eyePos , ray );\n    \n\tvec3 c = color( rayHitInfo, eyePos, ray );\n    \n\tfragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ttSRN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4ttSWr", "name": "bp Metaball", "author": "blackpolygon", "description": "Moving meatballs with sauce", "tags": ["noise", "blur", "metaball"], "likes": 10, "viewed": 232, "date": "1479019858", "time_retrieved": "2024-06-20T18:44:06.309877", "image_code": "// Author: blackpolygon\n// Title: Metaball and noise\n\n//Basen on the example by patriciogv\n\n\nfloat random (in vec2 st) { \n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))* \n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (1.0 - u.x) + \n            (d - b) * u.x * u.y;\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\n\nfloat smoothen(float d1, float d2) {\n    float k = 0.836;\n    return -log(exp(-k * d1) + exp(-k * d2)) / k;\n}\n\n\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitud = 0.524;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitud * noise(st);\n        st *= 2.;\n        amplitud *= .5;\n    }\n    return value;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/min(iResolution.x,iResolution.y);\n    st.x -= 0.35;\n    \n    float x = st.x;\n    float y = st.y;\n    vec3 color = vec3(st.y*0.492,-0.079,0.760);\n    \n    st -= 0.5;\n    color += fbm(st*(0.5+sin(iTime)*0.2)*5.964);\n    st = rotate2d( sin(iTime/2.)*3.14 ) * st;\n    st += vec2(0.5);\n    \n    vec2 p0 = vec2(cos(iTime) * 0.3 + 0.5, 0.5);\n    vec2 p1 = vec2(-cos(iTime) * 0.3 + 0.5, 0.5);\n    float d = smoothen(distance(st, p0) * 5.0, distance(st, p1) * 5.0);\n\tfloat ae = 5.0 / iResolution.y;\n    vec3 mask = 1.0-vec3(smoothstep(0.9, (0.5+sin(iTime)*0.5)*0.776+ae, d));\n    \n    vec3 bgColor = vec3(1.100,0.2+y,0.5+abs(sin(iTime)*0.5));\n    \n\tvec3 finalcolor = (bgColor*1.0-mask) + color*0.2;\n    \n    \n    fragColor = vec4(finalcolor,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ttSWr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4ttXDr", "name": "raymarch_bulb_plasma", "author": "balkhan", "description": "mandelbulb distance estimator taken from syntopia (tweaked a bit) : http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\n", "tags": ["3d", "fractal", "mandelbulb"], "likes": 2, "viewed": 225, "date": "1479458519", "time_retrieved": "2024-06-20T18:44:07.000566", "image_code": "#define I_MAX\t250\n#define E_BULB\t0.001\n#define E_SPHI\t0.01\n\n/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n*/\n\nfloat\tbulb(vec3 pos);\nfloat\tde(vec3 pos);\nmat4\tlookat(vec3 eye, vec3 target, vec3 up);\nvec2 \tcmult(vec2 a, vec2 b);\nvec4\tmarch(vec3 pos, vec3 dir);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4\tcol = vec4(0.0);\n\tvec3\tdir = normalize(vec3(fragCoord.xy - iResolution.xy/2.0, -iResolution.y));\n    vec3\tpos = vec3(-2.0, 0.0, 2.0);\n    mat4\tlook = lookat(pos, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n\n    dir = vec3(dot(dir, look[0].xyz), dot(dir, look[1].xyz), dot(dir, look[2].xyz));\n   \tvec4 inter = (march(pos, dir));\n    if (inter.w >= float(I_MAX))\n\t    col.xyz = inter.xyz;\n    else\n        col.xyz = vec3(1.0-inter.w/float(I_MAX));\n   \tfragColor = col;\n}\n\nvec4\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0);\n    vec3\tp = vec3(0.0);\n    vec4\tstep = vec4(0.0);\n\n    for (int i = -1; i < I_MAX; ++i)\n    {\n    \tp = pos + dir * dist.y;\n        dist.x = bulb(p);\n        //dist.x = de(p);\n        dist.y += dist.x;\n        if (dist.x < E_BULB)\n           break;\n        step.x += exp(-abs(dist.y + 30.0 * (dist.x-(p.x*p.z/1.0)) ));\n        step.y += exp(-abs(dist.y + 30.0 * (dist.x-(p.x*p.z/2.0)) ));\n        step.z += exp(-abs(dist.y + 30.0 * (dist.x-(p.x*p.z/1.5)) ));\n        step.w++;\n    }\n    return (step);\n}\n\nfloat\tbulb(vec3 pos) // brot3D de\n{\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 10 ; i++)\n    {\n\t\tr = length(z);\n\t\tif (r > 15.0)\n            break;\n\t\tfloat theta = atan(sin(z.z + iTime/5.0) * z.z/r, z.z*r);\n\t\tfloat phi = atan(z.y, z.x);\n\t\tdr =  pow(r, 8.0 - 1.0) * 8.0 * dr + 1.50;\n\t\tfloat zr = pow(r, 8.0);\n\t\ttheta = theta * 8.0;\n\t\tphi = phi * 8.0 + 30.0 * cos(iTime/3.0);\n        //theta = cmult(vec2(theta), vec2(r,1.0/r)).y;\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz += pos + r/dr;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\nfloat de(vec3 pos) // sphere de\n{\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 10 ; i++)\n    {\n\t\tr = length(z);\n\t\tif (r > 15.0)\n            break;\n\t\tfloat theta = atan(z.z/r, z.z*r);\n\t\tfloat phi = atan(z.x - z.z, z.y - z.z);\n\t\tdr =  pow(r, 5.0-1.0)*7.0*dr + 1.0;\n\t\tfloat zr = pow(r, 5.0);\n\t\ttheta = theta*5.0;\n\t\tphi = phi*5.0+5.0*cos(iTime/3.0);\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n        z.xy = cmult(vec2(z.xy),vec2(z.y/dr, z.y/dr)); // inversion try\n\t\tz += pos;\n\t}\n\treturn 0.4*log(r)*r/dr;\n}\n\nmat4\tlookat(vec3 e, vec3 ta, vec3 up)\n{\n    vec3 z = normalize(e - ta);    \n    vec3 x = normalize(cross(up, z));\n    vec3 y = cross(z, x);     \n\n    mat4 orientation = mat4(\n       \t\t\t\t\t\tx.x, y.x, z.x, 0.0,\n       \t\t\t\t\t\tx.y, y.y, z.y, 0.0,\n       \t\t\t\t\t\tx.z, y.z, z.z, 0.0,\n       \t\t\t\t\t\t0.0, 0.0, 0.0, 1.0);\n\n    mat4 translation = mat4(\n         \t\t\t\t\t1.0, 0.0, 0.0, 0.0,\n         \t\t\t\t\t0.0, 1.0, 0.0, 0.0, \n         \t\t\t\t\t0.0, 0.0, 1.0, 0.0,\n\t\t\t\t\t\t\t-e.x,-e.y,-e.z, 1.0);\n\n    return (orientation * translation);\n}\n\nvec2 \tcmult(vec2 a, vec2 b)\n{\n    return (vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ttXDr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4ttXRN", "name": "CloudScapeDan", "author": "anprogrammer", "description": "Not a very good shader", "tags": ["bad"], "likes": 4, "viewed": 156, "date": "1478466172", "time_retrieved": "2024-06-20T18:44:07.000813", "image_code": "#define EPSILON 0.0001\n\nstruct Intersection\n{\n    float MinDist;\n    float Material;\n};\n\nstruct IntersectionResult\n{\n    float TotalDist;\n    float Material;\n    vec3 HitPos;\n};\n    \nfloat yPlaneDist(vec3 pos, float yAlt)\n{\n    return abs(yAlt - pos.y);\n}\n\nIntersection intersectYPlane(vec3 pos, float yAlt)\n{\n    Intersection ii;\n    float dist = yPlaneDist(pos, yAlt);\n    if (dist < EPSILON)\n    {\n        ii.Material = mod(pos.x, 2.0) < 1.0 != mod(pos.z, 2.0) < 1.0 ? 1.0 : 2.0;\n    }\n    \n    ii.MinDist = dist;\n    return ii;\n}\n\nfloat sphereDist(vec3 pos, vec3 spherePos, float sphereRadius)\n{\n    vec3 diff = spherePos - pos;\n    float dist = length(diff);\n    vec3 dir = diff / dist;\n    return max(dist - sphereRadius, 0.0);\n}\n\nIntersection drawSphere(vec3 pos, vec3 spherePos, float sphereRadius, float material)\n{\n    Intersection ii;\n    float dist = sphereDist(pos, spherePos, sphereRadius);\n    if (dist < EPSILON)\n    {\n        ii.Material = material;\n    }\n    \n    ii.MinDist = dist;\n    return ii;\n}\n\nIntersection mixI(Intersection a, Intersection b)\n{\n    if (a.MinDist < b.MinDist)\n    {\n        return a;\n    }\n    else\n    {\n        return b;\n    }\n}\n\nvec3 getLightPos()\n{\n    float angle = iTime;\n    float radius = 4.0;\n    return vec3(cos(angle)*radius, 3.0 * sin(angle * 3.7) + 2.0, sin(angle)*radius);\n}\n\nIntersection intersectScene(vec3 rayPos)\n{\n\tIntersection ii = drawSphere(rayPos,\n                          vec3(0.0, 0.0, 0.0),\n                          2.0, 4.0);\n    ii = mixI(ii, drawSphere(rayPos,\n                          getLightPos(),\n                          1.0, 3.0));\n    ii = mixI(ii, drawSphere(rayPos,\n                          vec3(5.0, -1.0, 2.0),\n                          1.0, 5.0));\n    ii = mixI(ii, intersectYPlane(rayPos, -2.0));\n    \n    return ii;\n}\n\nIntersectionResult rayMarch(vec3 startPos, vec3 dir, float maxDist)\n{   \n    vec3 rayPos = startPos;\n    \n    IntersectionResult ir;\n    ir.Material = 0.0;\n    ir.TotalDist = maxDist;\n    float totalDist = 0.0;\n    \n    for (int step = 0; step < 150; step++)\n    {\n        Intersection ii = intersectScene(rayPos);\n        if (ii.MinDist < EPSILON || totalDist > maxDist)\n        {\n            ir.TotalDist = min(totalDist, maxDist);\n            ir.HitPos = startPos + dir * totalDist;\n            if (ii.MinDist < EPSILON)\n            {\n                ir.Material = ii.Material;\n            }\n            break;\n        }\n        \n        rayPos += dir * ii.MinDist;\n        totalDist += ii.MinDist;\n    }\n    \n    return ir;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float size = max(iResolution.x, iResolution.y);\n\tvec2 xy = (fragCoord.xy - iResolution.xy * 0.5)  / size * 2.0;\n    vec3 rayDir = normalize(vec3(xy, 1.0));\n    \n    float cameraRadius = 20.0;\n    float cameraAngle = iTime * 0.1;\n    \n    vec3 camPos = vec3(cos(cameraAngle) * cameraRadius, 5.0 + cos(cameraAngle * 4.0), sin(cameraAngle) * cameraRadius);\n    vec3 fwd = normalize(-camPos); //Look at origin\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 left = cross(up, fwd);\n    \n    float fogDist = 40.0;\n    IntersectionResult ir = rayMarch(camPos, left * rayDir.x + up * rayDir.y + fwd * rayDir.z, fogDist);\n    \n    float angle = iTime;\n    float radius = 4.0;\n    vec3 lightPos = getLightPos();\n    vec3 shadowDir = normalize(lightPos - ir.HitPos);\n    \n    IntersectionResult shadow = rayMarch(ir.HitPos + shadowDir * 0.1, shadowDir, 10.0);\n    float shadowStrength = shadow.TotalDist / 10.0;\n    if (shadow.Material == 3.0)\n    {\n        shadowStrength = 1.0;\n    }\n    \n    shadowStrength *= pow(4.0 / length(lightPos - ir.HitPos), 2.0);\n    \n    vec3 color;\n    if (ir.Material == 1.0)\n    {\n        color = vec3(0.5, 0.5, 0.5);\n    }\n    if (ir.Material == 2.0)\n    {\n        color = vec3(0.9, 0.9, 0.9);\n    }\n    if (ir.Material == 3.0)\n    {\n        color = vec3(1.0, 1.0, 1.0);\n    }\n    if (ir.Material == 4.0)\n    {\n        color = vec3(0.0, 0.0, 1.0);\n    }\n    if (ir.Material == 5.0)\n    {\n        color = vec3(0.0, 1.0, 0.0);\n    }\n    \n    vec3 fogColor = vec3(0.0, 0.0, 0.0);\n    float fogStrength = ir.TotalDist / fogDist;\n    vec3 finalColor = (shadowStrength * 0.7 + 0.3) * color * (1.0 - fogStrength) + fogColor * fogStrength;\n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ttXRN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4ttXW7", "name": "cravo-SnowmanArmy", "author": "cravo", "description": "An army of snowmen.  Used iq's raymarching primitives example to provide most of the code - I just designed the snowman and the ground.", "tags": ["raymarch", "snowman"], "likes": 3, "viewed": 131, "date": "1480004068", "time_retrieved": "2024-06-20T18:44:08.740321", "image_code": "// Uses IQ's raymarching primitives as a starting point, I just designed the snowman and the ground :)\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y - texture(iChannel0,vec2(p.x*0.02,p.z*0.02)).x*0.19 - texture(iChannel0,vec2(p.x*0.5,p.z*0.5)).x*0.02;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2 )\n{\n    float d1 = -p.y - h;\n    float q = p.y - h;\n    float si = 0.5*(r1-r2)/h;\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length2(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length8(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n  return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//----------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n//----------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    // ground \n    vec2 ground = vec2(sdPlane(pos),2.0);\n\n    pos = opRep(pos, vec3(1,0.0,0.9));\n    \n    // body\n    vec2 res = vec2( sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ), 2.0);\n    \n    // head\n    res = opU( res, vec2( sdSphere(    pos-vec3( 0.0,0.6, 0.0), 0.15), 2.0));\n    \n    // hat\n\tres = opU( res, vec2( sdCylinder(  pos-vec3( 0.0,0.76,0.0), vec2(0.1,0.08) ), 8.0 ) );\n\tres = opU( res, vec2( sdCylinder(  pos-vec3( 0.0,0.72,0.0), vec2(0.15,0.005) ), 8.0 ) );\n    \n    // eyes\n    res = opU( res, vec2( sdSphere(    pos-vec3( -0.05,0.65, 0.14), 0.015), 8.0));\n    res = opU( res, vec2( sdSphere(    pos-vec3(  0.05,0.65, 0.14), 0.015), 8.0));\n    \n    // mouth\n    res = opU( res, vec2( sdSphere(    pos-vec3(  0.07,0.575, 0.14), 0.015), 8.0));\n    res = opU( res, vec2( sdSphere(    pos-vec3( -0.07,0.575, 0.14), 0.015), 8.0));\n    res = opU( res, vec2( sdSphere(    pos-vec3( -0.03,0.55, 0.14), 0.015), 8.0));\n    res = opU( res, vec2( sdSphere(    pos-vec3(  0.03,0.55, 0.14), 0.015), 8.0));\n    \n    // nose\n    res = opU( res, vec2( sdSphere(    pos-vec3(  0.0,0.615, 0.16), 0.03), 4.0));\n    \n    // buttons\n    res = opU( res, vec2( sdSphere(    pos-vec3(  0.0,0.45, 0.16), 0.031), 8.0));\n    res = opU( res, vec2( sdSphere(    pos-vec3(  0.0,0.35, 0.22), 0.031), 8.0));\n    res = opU( res, vec2( sdSphere(    pos-vec3(  0.0,0.25, 0.25), 0.031), 8.0));\n    \n    res = opU(res, ground);\n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n#if 0\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n\tfloat precis = 0.001;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n \n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += h;//clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    //return clamp( res, 0.0, 1.0 );\n\n    if(t>tmax)\n    {\n        return 1.0;\n    }\n    else\n    {\n        return clamp(length(t*rd)*0.5,0.0,1.0);\n    }\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = vec3(1.0);\n\t\t\n        if( m == 8.0 )\n        {\n            col = vec3(0.0);\n        }\n\t\telse if (m == 4.0 )\n        {\n            col = vec3(0.8,0.4,0.2);\n        }\n        \n        // lighitng        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = 0.0;//smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos + nor*0.0001, lig, 0.02, 2.5 );\n        dom *= softshadow( pos + nor*0.0001, ref, 0.02, 2.5 );\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.20*dif*vec3(1.00,0.85,0.55);\n\t\tlin += 1.20*spe*vec3(1.00,0.85,0.55)*dif;\n        lin += 0.20*amb*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*dom*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.002*t*t ) );\n\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n\n\t// camera\t\n    \n    //front view\n\t//vec3 ro = vec3( 0.0, 1.0, 2.0 );\n    //side view\n\t//vec3 ro = vec3( 2.0, 1.0, 0.0 );\n\t// spinny view\n    vec3 ro = vec3(40.0 * cos(iTime * 0.0015), 1.75 + 0.5*cos(iTime * 0.05), -40.0 * sin(iTime * 0.0045));\n        \n    // fixed target\n    //vec3 ta = vec3( 0.0, 0.5, 0.0 );\n\t\n    // spinny target\n    vec3 ta = vec3(ro.x, 0.5, ro.z - 10.0);\n    \n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n\tcol = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ttXW7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ll3Sz8", "name": "dark ball", "author": "mahalis", "description": "messing with CSG and fake reflections", "tags": ["raymarch", "metal", "holes"], "likes": 3, "viewed": 123, "date": "1478049045", "time_retrieved": "2024-06-20T18:44:08.740321", "image_code": "float smoothMin(float a, float b, float k) {\n \tfloat h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);   \n}\n\nfloat sdCylinder( vec3 p, float r, float h ) {\n\tvec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r, h);\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCube(vec3 p, float b) {\n\tvec3 d = abs(p) - b;\n    float adj = min(d.z,min(d.x, d.y));\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0)) - 0.01 - 0.8 * adj * adj;\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nvec3 repeatSpace(vec3 p, vec3 spacing) {\n    return mod(p, spacing) - 0.5 * spacing;\n}\n\nfloat opSub(float d1, float d2) {\n    return max(d1, -d2);\n}\n\nfloat opAdd(float d1, float d2) {\n    return min(d1, d2);\n}\n\nfloat opInt(float d1, float d2) {\n    return max(d1, d2);\n}\n\nvec3 rX(vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    q.y = c * p.y - s * p.z;\n    q.z = s * p.y + c * p.z;\n    \n    return q;\n}\n\nvec3 rY(vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    q.x = c * p.x + s * p.z;\n    q.z = -s * p.x + c * p.z;\n    \n    return q;\n}\n\nvec3 rZ(vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    q.x = c * p.x - s * p.y;\n    q.y = s * p.x + c * p.y;\n    \n    return q;\n}\n\nfloat d(vec3 p) {\n    vec3 gridSpace = repeatSpace(rY(rZ(p, iTime * 0.1) + vec3(sin(p.z * 2.3 - iTime * 0.19) * 0.2, 0.0, sin(p.x * 1.9 - iTime * 0.23) * 0.2), 0.4) - vec3(0.0, iTime * 0.1, 0.0), vec3(0.27));\n    float cutoutDistance = sdSphere(gridSpace, 0.12);\n    return opAdd(opSub(sdSphere(p, 0.6), cutoutDistance), sdSphere(gridSpace, pow(smoothstep(1.2, 0.5, length(p)), 3.6) * 0.06));\n}\n\nvec3 gradient(vec3 p, float v) {\n    const vec3 eps = vec3(0.0001, 0.0, 0.0);\n    return (vec3(d(p + eps.xyy), d(p + eps.yxy), d(p + eps.yyx)) - v) / eps.x;\n}\n\nvec4 march(vec3 from, vec3 towards, float prec) {\n    vec3 lastSamplePosition = from;\n    float lastDistance = 0.0;\n    for(int i = 0; i < 70; i++) {\n        vec3 samplePosition = lastSamplePosition + max(lastDistance * 0.6, prec) * towards;\n        float cDist = d(samplePosition);\n        \n        lastSamplePosition = samplePosition;\n        lastDistance = cDist;\n        \n        if (cDist < 0.0) {\n            return vec4(samplePosition, cDist);\n        }\n    }\n    return vec4(1.0);\n}\n\nvec3 lightSurface(vec3 position, vec3 normal, vec3 toEye) {\n    vec3 toLight = normalize(vec3(-0.3, 1.0, 0.5) - position);\n    float ndotL = max(0.0, dot(normal, toLight));\n    float ndotV = max(0.0, dot(normal, toEye));\n    float ndotH = max(0.0, dot(normal, normalize(toEye + toLight)));\n    float fres = pow(1.0 - ndotV, 5.0);\n    float spec = smoothstep(0.4, 0.45, ndotL) * pow(ndotH, 0.5);\n    float occlusion = smoothstep(0.0, 0.1, march(position + toLight * 0.1, toLight, 0.005).w);\n    vec3 color = vec3(0.2 * pow(ndotL, 4.0) + 0.3 * fres + 0.9 * spec) * occlusion;\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = 2.0 * (fragCoord.xy / iResolution.xy - 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    const vec3 cameraLookAt = vec3(0.0, 0.0, 0.0);\n    vec3 cameraPosition = rY(vec3(0.0, 0.7, 1.0) * 1.5, iTime * 0.2);\n    vec3 cameraForward = normalize(cameraLookAt - cameraPosition);\n    vec3 cameraRight = cross(cameraForward, vec3(0.0, 1.0, 0.0));\n    vec3 cameraUp = cross(cameraRight, cameraForward);\n\tvec3 rayDirection = normalize(uv.x * cameraRight + uv.y * cameraUp + 3.0 * cameraForward);\n    \n    vec4 marchResult = march(cameraPosition, rayDirection, 0.001);\n    if (marchResult.w > 0.0) {\n        fragColor = vec4(vec3(0.3 - uv.y * 0.05 - pow(dot(uv, uv) * 0.5, 0.3) * 0.3), 1.0); // âskyâ color\n    } else {\n        vec3 position = marchResult.xyz;\n        fragColor = vec4(lightSurface(position, gradient(position, marchResult.w), -rayDirection), 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ll3Sz8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ll3XR4", "name": "2D Metacircles", "author": "jonathansty", "description": "2d", "tags": ["2d"], "likes": 1, "viewed": 454, "date": "1478358231", "time_retrieved": "2024-06-20T18:44:08.740321", "image_code": "const float force = 4000.0;\n\nconst bool bDebug = false;\n\nfloat length2(vec2 d){ return dot(d,d);}\nfloat saturate(float i){ return clamp(i,0.0,1.0);}\nfloat metaball(vec2 fragcoord, vec2 pos,float f)\n{\n    return f/length2((fragcoord - pos));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n    vec2 middle = iResolution.xy/2.0;\n    float r = 90.0 + sin(iTime)*25.0;\n    float b = metaball(fragCoord, vec2(middle.x + cos(iTime)*r,middle.y + sin(iTime)*r),force);\n\t\n    b += metaball(fragCoord, vec2(middle.x, middle.y),force);\n    \n    b -= metaball(fragCoord,vec2(100,0),4.0*force);\n    b -= metaball(fragCoord,middle + vec2(100,0),force*2.0);\n\tvec4 c = vec4(0);\n    if( b < 0.8)\n        c = vec4(1.0*abs(b*b*b),1.0*abs(b*b*b),abs(b)*0.2,1);\n    else\n        c = vec4(0.2*b,0.2*b,b,1.0);    \n\n    fragColor = c;\n    if(bDebug)\n    \tfragColor = vec4(abs(b),b,b,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ll3XR4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ll3XRN", "name": "PatternSins", "author": "Dain", "description": "Take some iq noise, turn it into sin patterns.", "tags": ["noise", "pattern"], "likes": 0, "viewed": 114, "date": "1478407112", "time_retrieved": "2024-06-20T18:44:08.740321", "image_code": "#define PI 3.14159265359\n#define twoPI PI*2.0\n#define HashMe(a) fract(sin(a)*13.0) \n \nfloat iqNoiseM(vec3 x) {\n    vec3 p = floor(x );\n    vec3 f = fract(x);\n    \n    \n    f = f*f*(3.0-2.0*f);\n   //  f = f*f*f*(f*(f*6.0-15.0)+10.0);\n    float c1 = 883.0;\n    float c2 = 971.0;\n    float c3 = 127.0;\n    float n = p.x*c3 + p.y*c2+ c1*p.z;\n    return mix(\n        mix(\n            mix(HashMe(n+0.0),HashMe(n+ c3),f.x),\n            mix(HashMe(n+c2),HashMe(n+c2+ c3),f.x),\n            f.y),\n        mix(\n            mix(HashMe(n+c1),HashMe(n+c1+ c3),f.x),\n            mix(HashMe(n+c1+c2),HashMe(n+c1+c2+ c3),f.x),\n            f.y),\n        f.z);\n}\n\nfloat PatternSins(vec3 x){\n    \n    vec3 x2 = (x)+ sin(x)*twoPI;\n    return iqNoiseM(x2);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    float n = PatternSins(vec3(0.0, uv*20.0) * cos(iTime*0.41/3.0)*3.0 + \n                           iTime*0.41);\n    vec3 color = mix(vec3(0.4,0.18,0.2), vec3(0.23,.9,.7), n)*n;\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ll3XRN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ll3Xz7", "name": "#codevember - 11", "author": "jcksmssng", "description": "For today's #codevember, trying out some blob effect with a 3D Noise algo by Patricio Gonzalez Vivo https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83", "tags": ["noise", "blob", "rotation"], "likes": 4, "viewed": 675, "date": "1478884148", "time_retrieved": "2024-06-20T18:44:09.989081", "image_code": "const float SURFACE_HIT_PRECISION = .001;\nconst float MAX_DIST = 10.;\nconst int MAX_STEPS = 100;\n\n// EyeRay Transformation Matrix from the great @cabbibo\n// https://www.shadertoy.com/view/Xl2XWt\nmat3 calculateEyeRayTransformationMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n\nmat3 rotateX( float angle )\n{\n    return mat3(1, 0, 0,\n                0, cos(angle), -sin(angle),\n                0, sin(angle), cos(angle));\n}\n\nmat3 rotateY( float angle )\n{\n    return mat3(cos(angle), 0, sin(angle),\n                0, 1, 0,\n                -sin(angle), 0, cos(angle));\n}\n\nmat3 rotateZ( float angle )\n{\n    return mat3(cos(angle), -sin(angle), 0,\n                sin(angle), cos(angle), 0,\n                0, 0, 1);\n}\n\nfloat map( float value, float oldMin, float oldMax, float newMin, float newMax ) \n{\n    return newMin + (newMax - newMin) * (value - oldMin) / (oldMax - oldMin);\n}\n\n\nfloat mod289( float x )\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289( vec4 x )\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 perm(vec4 x) \n{\n    return mod289(((x * 34.0) + 1.0) * x);\n}\n\nfloat noise3(vec3 p)\n{\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\nvec2 sphere ( vec3 ray ) \n{\n    vec3 orig = vec3( 0. , 0. , -3.0 );\n    vec3 dist = ray - orig;\n    dist *= rotateY( iTime );\n    float noise = noise3( ray ) * sin( iTime ) + sin( iTime / 2.0 );\n    dist += noise;\n    float radius = 1.1;\n   \tfloat le = length( dist ) - radius;\n    \n    float id = 1.;\n    \n\treturn vec2( le, id );\n}\n\n\nvec2 useShape( vec3 ray )\n{\n    return sphere( ray );\n}\n\n\n// Inspired by @cabbibo\n// https://www.shadertoy.com/view/Xl2XWt\nvec2 checkRayHit( vec3 eyePos, vec3 rayDir )\n{\n  \tfloat distToSurface = SURFACE_HIT_PRECISION * 2.;\n    \n  \t// The total distance traveled by the ray obviously should start at 0\n  \tfloat totalDist = 0.;\n  \tfloat finalDist = 0.;\n    \n  \t// if our id is less that 0. , it means we haven't hit anything\n  \tfloat id = -1.;\n\n  \tfor( int i = 0; i < MAX_STEPS; i++ ) {\n    \t// Break if we hit the surface\n    \tif( distToSurface < SURFACE_HIT_PRECISION ) break;\n    \n    \t// Break if we reach end of the scene\n    \tif( totalDist > MAX_DIST ) break;\n    \n    \t// Current pos starts at eyePos then follows rayDir along the total distance traveled by the ray\n    \tvec3 currentPos = eyePos + rayDir * totalDist;\n    \tvec2 distToObj = useShape( currentPos );\n \t\n\t\tid = distToObj.y;\n        totalDist += distToObj.x;\n\t}\n\n  \tif( totalDist < MAX_DIST ) {\n  \t\tfinalDist = totalDist;\n  \t}\n\n  \tif( totalDist > MAX_DIST ){ \n  \t\tfinalDist = MAX_DIST;\n    \tid = -1.;\n  \t}\n\n  \treturn vec2( finalDist , id );\n}\n\n// Original function from @cabbibo\n// https://www.shadertoy.com/view/Xl2XWt\nvec3 getSurfaceNormal( vec3 hitPos )\n{    \n\tvec3 x = vec3( 0.001, 0.0, 0.0 );\n    vec3 y = vec3( 0.0 , 0.001 , 0.0 );\n    vec3 z = vec3( 0.0 , 0.0 , 0.001 );\n    \n   \tfloat upTinyChangeInX = useShape( hitPos + x ).x; \n    float downTinyChangeInX = useShape( hitPos - x ).x; \n    \n    float tinyChangeInX = upTinyChangeInX - downTinyChangeInX;\n    \n    \n    float upTinyChangeInY   = useShape( hitPos + y ).x; \n    float downTinyChangeInY = useShape( hitPos - y ).x; \n    \n    float tinyChangeInY = upTinyChangeInY - downTinyChangeInY;\n    \n    \n    float upTinyChangeInZ   = useShape( hitPos + z ).x; \n    float downTinyChangeInZ = useShape( hitPos - z ).x; \n    \n    float tinyChangeInZ = upTinyChangeInZ - downTinyChangeInZ;\n    \n    \n\tvec3 normal = vec3( tinyChangeInX, tinyChangeInY, tinyChangeInZ );\n    \n\treturn normalize(normal);\n}\n\nvec3 bgColor(vec3 rayDir)\n{\n    float b = map(rayDir.x, -1., 1., 0., 1.);\n\treturn vec3( .18, .18, b );\n}\n\n// Inspired by @cabbibo\n// https://www.shadertoy.com/view/Xl2XWt\nvec3 objColor( vec3 hitPos, vec3 surfaceNormal )\n{\n    vec3 lightPos = vec3( 1. , 1. , 1. );\n\n    // Get direction of light relative to the hit\n    vec3 lightDir = lightPos - hitPos;\n    lightDir = normalize( lightDir );\n    \n    // The dot product of the lightDir to the surfaceNormal of the hit\n    // Gives us how much that hit is facing the light source\n    // -1: faces opposite\n    // 1: faces completely the light\n    float faceValue = dot( lightDir , surfaceNormal );\n    faceValue = max( 0.3 , faceValue );\n    \n    float b = map( hitPos.x, -1., 1., 0., .8 );\n    vec3 color = vec3( .18 , .18 , b );\n   \t\n    // here's how we do some shadowing !\n    color *= faceValue;\n\treturn color;\n}\n\n// Inspired by @cabbibo\n// https://www.shadertoy.com/view/Xl2XWt\nvec3 colorize( vec2 rayHitInfo, vec3 eyePos, vec3 rayDir )\n{\n    vec3 color;\n    \n  \tif( rayHitInfo.y < 0.0 ) {\n  \t\tcolor = bgColor(rayDir);  \n  \t} else {\n      \tvec3 hitPos = eyePos + rayHitInfo.x * rayDir;\n\n      \tvec3 surfaceNormal = getSurfaceNormal( hitPos );\n      \n      \tif( rayHitInfo.y >= 1. ){\n        \tcolor = objColor( hitPos , surfaceNormal ); \n      \t}\n  \t}\n    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Fixes the aspect ratio to match a square frame\n\t// get values between -1 and +1 for the current pixel\n\tvec2 uv = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n    fract(uv);\n    vec3 eyePos = vec3( 0., 0., 2.);\n    vec3 lookAt = vec3( 0. , 0. , 0. );\n  \n    mat3 eyeTransformationMatrix = calculateEyeRayTransformationMatrix( eyePos, lookAt, 0. ); \n   \n    // For every pixel we throw a ray from the eye\n    vec3 ray = normalize( eyeTransformationMatrix * vec3( uv.xy , 2. ) ); \n    vec2 rayHitInfo = checkRayHit( eyePos , ray );\n    \n\tvec3 color = colorize( rayHitInfo, eyePos, ray );\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ll3Xz7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llcSz8", "name": "Kelp Forest", "author": "BigWIngs", "description": "Use the mouse to look around. \nIf you want to see just the fish you can set the FISH_ONLY define to true. \nThe full effect brings my titan card to it's knees on fullscreen. To get a decent framerate you can turn the bubbles and the kelp off.", "tags": ["raymarching", "sss", "distanceestimation", "ocean", "underwater", "bubbles", "fish"], "likes": 148, "viewed": 8658, "date": "1478568236", "time_retrieved": "2024-06-20T18:44:13.492252", "image_code": "// \"Kelp Forest\" by Martijn Steinrucken aka BigWings - 2016\n// Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// SONG : Hollywood Principle - Breathing Underwater (Ether Remix)\n\n// Use these to change the effect\n\n#define FISH_ONLY false\n#define FISH true\n#define KELP true\n#define BUBBLES true\n\n#define INVERTMOUSE 1.\n\n#define MAX_STEPS 200\n#define CAM_DEPTH 30.\n\n#define S(x,y,z) smoothstep(x,y,z)\n#define B(x,y,z,w) S(x-z, x+z, w)*S(y+z, y-z, w)\n#define sat(x) clamp(x,0.,1.)\n#define SIN(x) sin(x)*.5+.5\n\n\nconst vec3 lf=vec3(1., 0., 0.);\nconst vec3 up=vec3(0., 1., 0.);\nconst vec3 fw=vec3(0., 0., 1.);\n\nconst float pi = 3.141592653589793238;\nconst float twopi = 6.283185307179586;\n\n\nvec3 bg; // global background color\n\nfloat dist2(vec3 a, vec3 b) { vec3 D=a-b; return dot(D, D); } \nfloat L2(vec3 p) {return dot(p, p);}\nfloat L2(vec2 p) {return dot(p, p);}\n\nfloat N1( float x ) { return fract(sin(x)*5346.1764); }\nfloat N2(float x, float y) { return N1(x + y*134.324); }\n\nvec3 hash31(float p) {\n    //  3 out, 1 in... DAVE HOSKINS\n   vec3 p3 = fract(vec3(p) * vec3(.1031,.11369,.13787));\n   p3 += dot(p3, p3.yzx + 19.19);\n   return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n\nstruct ray {\n    vec3 o;\n    vec3 d;\n};\nray e;\t\t\t\t// the eye ray\n\nstruct camera {\n    vec3 p;\t\t\t// the position of the camera\n    vec3 forward;\t// the camera forward vector\n    vec3 left;\t\t// the camera left vector\n    vec3 up;\t\t// the camera up vector\n\t\n    vec3 center;\t// the center of the screen, in world coords\n    vec3 i;\t\t\t// where the current ray intersects the screen, in world coords\n    ray ray;\t\t// the current ray: from cam pos, through current uv projected on screen\n    vec3 lookAt;\t// the lookat point\n    float zoom;\t\t// the zoom factor\n};\ncamera cam;\n\n\nvoid CameraSetup(vec2 uv, vec3 position, vec3 lookAt, float zoom) {\n\t\n    cam.p = position;\n    cam.lookAt = lookAt;\n    cam.forward = normalize(cam.lookAt-cam.p);\n    cam.left = cross(up, cam.forward);\n    cam.up = cross(cam.forward, cam.left);\n    cam.zoom = zoom;\n    \n    cam.center = cam.p+cam.forward*cam.zoom;\n    cam.i = cam.center+cam.left*uv.x+cam.up*uv.y;\n    \n    cam.ray.o = cam.p;\t\t\t\t\t\t// ray origin = camera position\n    cam.ray.d = normalize(cam.i-cam.p);\t// ray direction is the vector from the cam pos through the point on the imaginary screen\n}\n\nfloat remap01(float a, float b, float t) { return (t-a)/(b-a); }\n\n\n// DE functions from IQ\n// https://www.shadertoy.com/view/Xds3zN\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\nfloat fmin( float a, float b, float k, float f, float amp) {\n\t// 'fancy' smoothmin min.\n    // inserts a cos wave at intersections so you can add ridges between two unioned objects\n    \n    float h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n    float scale = h*(1.0-h);\n\treturn mix( b, a, h ) - (k+cos(h*pi*f)*amp*k)*scale;\n}\n\nfloat sdSphere( vec3 p, vec3 pos, float s ) { return length(p-pos)-s; }\n\nfloat scaleSphere( vec3 p, vec3 scale, float s )\n{\n    return (length(p/scale)-s)*min(scale.x, min(scale.y, scale.z));\n}\n\nvec3 opTwist( vec3 p, float a )\n{\n    float  c = cos(a*p.y*pi);\n    float  s = sin(a*p.y*pi);\n    mat2   m = mat2(c,-s,s,c);\n    \n    p.xz = m*p.xz;\n    return vec3(p);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nmat3 RotMat(vec3 axis, float angle)\n{\n    // http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c          );\n}\n\nstruct de {\n    // data type used to pass the various bits of information used to shade a de object\n\tfloat d;\t// distance to the object\n    float b;\t// bump\n    float m; \t// material\n    float a;\t// angle\n    float a2;\n    \n    float d1, d2, d3, d4, d5;\t// extra distance params you can use to color your object\n    \n    vec3 p;\t\t// the offset from the object center\n    \n    vec3 s1;\t// more data storage\n};\n    \nstruct rc {\n    // data type used to handle a repeated coordinate\n\tvec3 id;\t// holds the floor'ed coordinate of each cell. Used to identify the cell.\n    vec3 h;\t\t// half of the size of the cell\n    vec3 p;\t\t// the repeated coordinate\n};\n    \nrc Repeat(vec3 pos, vec3 size) {\n\trc o;\n    o.h = size*.5;\t\t\t\t\t\n    o.id = floor(pos/size);\t\t\t// used to give a unique id to each cell\n    o.p = mod(pos, size)-o.h;\n    return o;\n}\n\nfloat SkipCell(rc q, vec3 rd) {\n\t// returns a distance so that we skip the current cell and end up in the next cell\n    \n    vec3 r;\t// ray that will bring us to the next cell\n    if(rd.x<0.) r.x = -(q.p.x+q.h.x); else r.x = (q.h.x-q.p.x);\n    if(rd.y<0.) r.y = -(q.p.y+q.h.y); else r.y = (q.h.y-q.p.y);\n    if(rd.z<0.) r.z = -(q.p.z+q.h.z); else r.z = (q.h.z-q.p.z);\n    vec3 steps = r/rd;\n    \n    return length(min(min(steps.x, steps.y), steps.z)*rd)+.01;// add a little bit so we for sure end up in the next cell\n}\n\nvec3 background(vec3 r) {\n\tfloat x = atan(r.x, r.z);\t\t// from -pi to pi\t\n\tfloat y = pi*0.5-acos(r.y);  \t\t// from -1/2pi to 1/2pi\t\t\n    \n    vec3 upCol = vec3(.15, .25, .6)*7.;\n    \n    float u = dot(r, up)*.5+.5;\n    \n    vec3 col = mix(upCol*.05, upCol, u*u);\n    \n    float t = iTime*4.;\t\t\t\t// add god rays\n    float a = sin(r.x);\n    \n    float beam = sat(sin(10.*x+a*y*5.+t));\n    beam *= sat(sin(7.*x+a*y*3.5-t));\n    \n    float beam2 = sat(sin(42.*x+a*y*21.-t));\n    beam2 *= sat(sin(34.*x+a*y*17.+t));\n    \n    beam += beam2;\n    col *= 1.+beam*.03;\n    \n    return col;\n}\n\nfloat WaterSurface(vec3 r) {\n    \n    float u = dot(r, up);\n    \n    vec2 p = r.xz*(CAM_DEPTH/r.y)*3.; \n    \n    float t = iTime*5.;\n    \n    float bump = sin(p.x*2.+t+sin(p.y*.73+t));\n    bump += sin(p.x*1.43+t)*.5;\n    \n    bump += sin(p.x*1.21-t+sin(p.y*.3-t*.34));\n    bump += sin(p.x*.43-t)*.5;\n    \n    bump += sin(p.y*.81-t+sin(p.x*.334-t*.34));\n    bump += sin(p.y*.63-t)*.5;\n    \n    bump *= u*S(9., 1., u);\n    bump *= S(.5, 1., u)*.05;\n\n    return bump;\n}\n\nvec3 Caustics(vec3 p) {\n    float t = iTime*2.;\n    \n    float s1 = sin(p.x*5.+t)*.5+.5;\n    float s2 = sin(p.z*5.+t)*.5+.5;\n    float s3 = sin(p.x*s1+p.z*s2*.1+t*.32)*.5+.5;\n    \n    float c = pow(s1*s2, 2.);\n    \n\treturn c*vec3(1., 1., .9);\n}\n    \nvec3 Scales(vec2 uv, float seed) {\n    // returns a scale info texture: x = brightness y=noise z=distance to center of scale\n    vec2 uv2 = fract(uv);\n    vec2 uv3 = floor(uv);\n    \n    float rDist = length(uv2-vec2(1., .5));\n    float rMask = S(.5, .45, rDist);\n    float rN = N2(uv3.x, uv3.y+seed);\n    vec3 rCol = vec3(uv2.x-.5, rN, rDist);\n     \n    float tDist = length(uv2-vec2(.5, 1.));    \n    float tMask = S(.5, .45, tDist);\n    float tN = N2(uv3.x, uv3.y+seed);\n    vec3 tCol = vec3(1.*uv2.x, tN, tDist);\n    \n    float bDist = length(uv2-vec2(.5, 0.));\n    float bMask = S(.5, .45, bDist);\n    float bN = N2(uv3.x, uv3.y-1.+seed);\n    vec3 bCol = vec3(uv2.x, bN, bDist);\n    \n    float lDist = length(uv2-vec2(.0, .5));\n    float lMask = S(.5, .45, lDist);\n    float lN = N2(uv3.x-1., uv3.y+seed);\n    vec3 lCol = vec3(uv2.x+.5, lN, lDist);\n    \n    vec3 col = rMask*rCol;\n    col = mix(col, tCol, tMask);\n    col = mix(col, bCol, bMask);\n    col = mix(col, lCol, lMask);\n    \n    return col;\n}\n\nde Fish(vec3 p, vec3 n, float camDist) {\n    // p = position of the point to be sampled\n    // n = per-fish random values\n    // camDist = the distance of the fish, used to scale bump effects\n    \n    p.z += sin(p.x-iTime*2.+n.x*100.)*mix(.15, .25, n.y);\n    p.z = abs(p.z);\n   \n    float fadeDetail = S(25., 5., camDist);\n    \n    vec3 P;\n    \n    float dist;\t\t// used to keep track of the distance to a certain point\n    float mask;\t\t// used to mask effects\n    float r;\n    vec2 dR;\n    \n    float bump=0.; // keeps track of bump offsets\n    \n    float lobe = scaleSphere(p-vec3(-1., 0., 0.25), vec3(1., 1., .5), .4);\n    float lobe2 = scaleSphere(p-vec3(-1., 0., -0.25), vec3(1., 1., .5), .4);\n    \n    vec3 eyePos = p-vec3(-1., 0., 0.4);\n    float eye = scaleSphere(eyePos, vec3(1., 1., .35), .25);\n    float eyeAngle = atan(eyePos.x, eyePos.y);\n    \n    float snout = scaleSphere(p-vec3(-1.2, -0.2, 0.), vec3(1.5, 1., .5), .4);\n    P = p-vec3(-1.2, -0.6, 0.);\n    P = P*RotMat(vec3(0., 0., 1.), .35);\n    float jawDn = scaleSphere(P, vec3(1., .2, .4), .6);\n    float jawUp = scaleSphere(P-vec3(-0.3, 0.15, 0.), vec3(.6, .2, .3), .6);\n    float mouth = fmin(jawUp, jawDn, 0.03, 5., .1);\n    snout = smin(snout, mouth, 0.1);\n    \n    float body1 = scaleSphere(p-vec3(.6, -0., 0.), vec3(2., 1., .5), 1.);\n    float body2 = scaleSphere(p-vec3(2.4, 0.1, 0.), vec3(3., 1., .4), .6); \n\n    P = p-vec3(-1., 0., 0.);\n    \n    float angle = atan(P.y, P.z);\n    vec2 uv = vec2(remap01(-2., 3., p.x), (angle/pi)+.5); // 0-1\n    vec2 uv2 = uv * vec2(2., 1.)*20.;\n    \n    vec3 sInfo = Scales(uv2, n.z);\n    float scales = -(sInfo.x-sInfo.z*2.)*.01;\n    scales *= S(.33, .45, eye)*S(1.8, 1.2, eye)*S(-.3, .0, p.x);\n    \n    // gill plates\n    P = p-vec3(-.7, -.25, 0.2);\n    P = P * RotMat(vec3(0., 1., 0.), .4);\n    float gill = scaleSphere(P, vec3(1., .9, .15), .8);\n    \n    // fins\n    float tail = scaleSphere(p-vec3(4.5, 0.1, 0.), vec3(1., 2., .2), .5);\n    dR = (p-vec3(3.8, 0.1, 0.)).xy;\n    r = atan(dR.x, dR.y);\n    \n    mask = B(0.45, 2.9, .2, r) * S(.2*.2, 1., L2(dR));\n    \n    bump += sin(r*70.)*.005*mask;\n    tail += (sin(r*5.)*.03 + bump)*mask;\n    tail += sin(r*280.)*.001*mask*fadeDetail;\n    \n    float dorsal1 = scaleSphere(p-vec3(1.5, 1., 0.), vec3(3., 1., .2), .5);\n    float dorsal2 = scaleSphere(p-vec3(0.5, 1.5, 0.), vec3(1., 1., .1), .5);\n    dR = (p-vec3(0.)).xy;\n    r = atan(dR.x, dR.y);\n    dorsal1 = smin(dorsal1, dorsal2, .1);\n    \n    mask = B(-.2, 3., .2, p.x);\n    bump += sin(r*100.)*.003*mask;\n    bump += (1.-pow(sin(r*50.)*.5+.5, 15.))*.015*mask;\n    bump += sin(r*400.)*.001*mask*fadeDetail;\n    dorsal1 += bump;\n    \n    float anal = scaleSphere(p-vec3(2.6, -.7, 0.), vec3(2., .7, .1), .5);\n    anal += sin(r*300.)*.001;\n    anal += sin(r*40.)*.01;\n    \n    \n    // Arm fins\n    P = p-vec3(0.7, -.6, 0.55);\n    dR = (p-vec3(0.3, -.4, 0.6)).xy;\n    r = atan(dR.x, dR.y);\n    P = P*RotMat(lf, .2);\n    P = P*RotMat(up, .2);\n    mask = B(1.5, 2.9, .1, r); \t\t\t// radial mask\n    mask *= S(.1*.1, .6*.6, L2(dR));\t\t\t// distance mask\n \tfloat arm = scaleSphere(P, vec3(2., 1., .2), .2);\n    arm += (sin(r*10.)*.01 + sin(r*100.)*.002) * mask;\n   \n    // Breast fins\n    P = p-vec3(0.9, -1.1, 0.2);\n    P = P*RotMat(fw, .4);\n    P = P*RotMat(lf, .4);\n    dR = (p-vec3(0.5, -.9, 0.6)).xy;\n    r = atan(dR.x, dR.y);\n    mask = B(1.5, 2.9, .1, r); \t\t\t// radial mask\n    mask *= S(.1*.1, .4*.4, L2(dR));\n    float breast = scaleSphere(P, vec3(2., 1., .2), .2);\n    breast += (sin(r*10.)*.01 + sin(r*60.)*.002)*mask;\n    \n    \n    de f;\n    f.p = p;\n    f.a = angle;\n    f.a2 = eyeAngle;\n    f.d4 = length(eyePos);\n    f.m = 1.;\n    \n    f.d1 = smin(lobe, lobe2, .2);\t\t\t\t\t\t\t\t\t\t\t\t// d1 = BODY\n    f.d1 = smin(f.d1, snout, .3);\n    f.d1 += 0.005*(sin(f.a2*20.+f.d4)*sin(f.a2*3.+f.d4*-4.)*SIN(f.d4*10.));\n    f.d1 = smin(f.d1, body1, .15);\n    f.d1 = smin(f.d1, body2, .3);\n    f.d1 += scales*fadeDetail;\n    f.d1 = fmin(f.d1, gill, .1, 5., 0.1);\n    \n    float fins = min(arm, breast);\n    fins = min(fins, tail);\n    fins = min(fins, dorsal1);\n    fins = min(fins, anal);    \n        \n    f.d = smin(f.d1, fins, .05);\n    f.d = fmin(f.d, eye, .01, 2., 1.);\n    f.d *= .8;\n    \n    f.d2 = dorsal1;\n    f.d3 = tail;\n    f.d5 = mouth;\n    f.b = bump;\n    \n    f.s1 = sInfo;\n    \n    return f;\n}\n\nde Kelp(vec3 p, vec3 n) {\n\tde o;\n    \n    p = opTwist(p, floor(n.y*10.)/40.);\n    o.d = udRoundBox(p, vec3(mix(.1, .7, n.x), 40., .01), .005);\n    \n    o.d *=.6;\n    o.m=3.;\n    \n    return o;\n}\n\nde SmallBubbles(rc q, vec3 p, vec3 n) {\n\t// q = repeated coord\n    // p = world pos\n    // n = per-bubble random values\n    \n    de o;\n    o.m=2.;\n   \n    float t = iTime*2.;\n    \n    n -= 0.5;\n    \n    float s = fract((n.x+n.y+n.z)*100.);\n    s = pow(s, 4.);\n    float size = mix(.05, .7, s)*.5;\n    \n    vec3 pos;\n    \n    pos.x = sin((t+n.y)*twopi*(1.-s)*3.)*n.x*s;\n    \n    o.d = sdSphere(q.p, pos, size);\n    \n    p.y += t;\n    p *= 7.;\n    \n    n *= twopi;\n    o.d += (sin(p.x+n.x+t)+sin(p.y+n.y)+sin(p.z+n.z+t))*s*.05;\n    \n    o.d*=.8;\n    return o;\n}\n\nde map( vec3 p, vec3 rd) {\n    // returns a vec3 with x = distance, y = bump, z = mat transition w = mat id\n    de o;\n    o.d = 1000.;\n    \n    float t = iTime;\n    \n    if(FISH_ONLY) {\n       p.x += 1.5;\n       o = Fish(p, vec3(0.), 0.); \n    } else {\n        rc q;\n        vec3 n;\n        \n        if(FISH) {\n            q = Repeat(vec3(p.x+t, p.y, p.z), vec3(11.5, 4.5, 2.5)); // make fishies move forward\n            n = hash31(q.id.x+q.id.y*123.231+q.id.z*87.342);\n\n            float camDist = length(p);\n            if(n.x>.95) \n                o = Fish(q.p, n, camDist);\n            else\n                o.d = SkipCell(q, rd);\n        }\n        \n        if(KELP) {\t\t\t\t\t\t\t\t\t\t\n            q = Repeat(vec3(p.x+sin(t+p.y*.2)*.5, p.y, p.z), vec3(2., 40., 2.)); // make kelp sway\n            n = hash31(q.id.x+q.id.z*765.);\n\n            de kelp;\n            if(n.z*S(7., 10., length(q.id)) > .9)\n                kelp = Kelp(q.p, n);\n            else \n                kelp.d = SkipCell(q, rd);\n\n            if(kelp.d<o.d) o=kelp;\n        }\n        \n        if(BUBBLES) {\t\t\t\t\t\t\t\t\t\t// Map kelp\n            p.y -= t*4.;\t\t\t// sway with the water\n\t\t\t\n            p.y += 40.;\n            q = Repeat(p, vec3(4., 4., 4.));\n            n = hash31(q.id.x+q.id.y*1234.5234+q.id.z*765.);\n\t\t\t\n            de bubbles;\n            if(n.z*S(2., 5., length(q.id)) > .95)\n                bubbles = SmallBubbles(q, p, n);\n            else \n                bubbles.d = SkipCell(q, rd);\n\n            if(bubbles.d<o.d) o=bubbles;\n        }\n        \n    }\n    \n    return o;\n    \n}\n\nde map( in vec3 p){return map(p, vec3(1.));}\n\nde castRay( in vec3 ro, in vec3 rd ) {\n    // returns a distance and a material id\n    \n    float dmin = 1.0;\n    float dmax = 100.0;\n    \n\tfloat precis = 0.002;\n    \n    de o;\n    o.d = dmin;\n    o.m = -1.0;\n    \n    for( int i=0; i<MAX_STEPS; i++ )\n    {\n\t    de res = map( ro+rd*o.d, rd );\n        if( res.d<precis || o.d>dmax ) break;\n        \n        float d = o.d;\n        o = res;\n        o.d += d;\n    }\n\n    if( o.d>dmax ) o.m=-1.0;\n    \n    return o;\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor ) {\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<4; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos, nor ).d;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).d - map(pos-eps.xyy).d,\n\t    map(pos+eps.yxy).d - map(pos-eps.yxy).d,\n\t    map(pos+eps.yyx).d - map(pos-eps.yyx).d );\n\treturn normalize(nor);\n}\n\n\nvec3 FishMaterial(de o, vec3 nor, float fresnel, float spec, float occ, vec3 amb, vec3 ref, float u, vec3 pos) {\n   vec3 finCol = vec3(1., .5, .25);\n        \n        float dorsalMask = (1.-sat(o.d2*15.))*B(-.3, 3., .1, o.p.x);\n        float finMask = o.d1*2.;\n        float spikeMask = pow(o.b*50., 2.);\n        float dorsalTrans = sat(finMask*spikeMask*dorsalMask*3.);\n        float tailMask = S(3.8, 5.2, o.p.x);\n        float tailTrans = tailMask*(1.-pow(max(1.-(o.b*100.+0.5), 0.), 3.));\n        float translucency = (dorsalTrans+tailTrans+o.d1*3.);\n        translucency *= u+.2;\n        \n        float bodyMask = sat(1.-(o.d1-.01)*50.);\n        vec3 topCol = vec3(.5, .5, .5);\n        vec3 bottomCol = vec3(1.3);\n        float w = sin(o.p.x*5.)*.1;\n \t\tvec3 bodyCol = mix(topCol, bottomCol, S(.4, -.2, o.p.y)+(o.s1.y-.5)*.5);\n        \n        float camo = SIN(o.d4*5.);\n        camo *= SIN(o.d2*10.);\n        \n        float headMask = S(.8, 1., o.d3);\n        vec3 headCol = mix(vec3(1.2), topCol,  S(0., .5, o.d4)*S(1.1, .5, o.d4));\n        headCol += 0.1*(sin(o.a2*20.+o.d4)*sin(o.a2*3.+o.d4*-4.)*SIN(o.d4*10.));\n        \n        headCol += (1.-fresnel)*ref.b*.2;\n        vec3 mouthCol = vec3(1.3);\n        headCol = mix(headCol, mouthCol, (1.-S(.0, .2, o.d5)));\n        \n    \tvec3 col = vec3(1.);\n        col = mix(col, col*mix(bodyCol, headCol, headMask), bodyMask);\n        col *= camo*.5+.5;\n        \n       \tvec3 eyeColor = vec3(.8, .6, .2);\n        eyeColor += sin(o.a2*2.*pi+.345)*sin(o.a2*pi)*.1;\n       \n        float eyeMask = S(.27, .25, o.d4);\n        eyeColor *= S(.13, .15, o.d4);\n        eyeColor *= S(.25, .19, o.d4)+.25;\n        eyeColor += spec;\n        \n        col = mix(col, eyeColor, eyeMask);\n        \n        vec3 ambient = mix(amb, vec3(occ), .5);   \n        col *= ambient;\n        \n        col = mix(col, bg*finCol, translucency);\t// add light through fins\n        \n        float dif = clamp( dot( nor, up ), 0., 1.0 );\n        col += Caustics(pos)*dif*S(-20., 1., pos.y);\n    \n    return col;\n}\n\nvec3 BubbleMaterial(de o, float fresnel, float spec, vec3 ref) {\n    vec3 col = ref;\n    \n    return col;\n}\n\nvec3 KelpMaterial(de o, float fresnel, vec3 amb, vec3 ref, float u, vec3 pos) {\n\tvec3 kelpColor = vec3(1., .5, .2);\n    vec3 col = amb;\n    vec3 transColor = kelpColor*bg*1.3;\n    col = mix(col, transColor, fresnel);\n    col += Caustics(pos)*.2;\n    col *= sat(u*2.);\n    \n    return col;\n}\n\n\nvec4 render( in vec3 ro, in vec3 rd, float depth ) {\n    // outputs a color\n    \n    vec3 col = vec3(0.);\n    de o = castRay(ro,rd);\n\n    vec3 pos = ro + o.d*rd;\n    vec3 nor = calcNormal( pos );\n    vec3 r = reflect( rd, nor );\n    vec3 amb = background(nor);\t\t// the background in the direction of the normal\n    vec3 ref = background(r);\t\t// the background in the direction of the reflection vector\n\n    float fresnel = sat(dot(rd, -nor));\n\n    float occ = calcAO( pos, nor );\n    float lookUp = dot(rd, up)*.5+.5;\t\t// 1 when looking straight up, 0 when looking straight down\n\n    float spec = pow(sat(dot(r, up)), 20.);\n   \n    \n    if( o.m==1. )\n        col = FishMaterial(o, nor, fresnel, spec, occ, amb, ref, lookUp, pos);\n    else if(o.m==2.)\n    \tcol = BubbleMaterial(o, fresnel, spec, ref);\n    else if(o.m==3.)\n       col = KelpMaterial(o, fresnel, amb, ref, lookUp, pos);\n    \n    \n    float backContrast = max(S(.9, .70, lookUp), S(30., 25., o.d)); \n    col *= backContrast;\n    \n    float fog = S(0., 60., o.d);\n    col = mix(col, bg, fog);\n\n    return vec4( col, o.m );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy) - 0.5;\n   \tuv.y *= iResolution.y/iResolution.x;\n    vec2 m = iMouse.xy/iResolution.xy;\n    if(m.x==0. &&m.y==0.) m = vec2(.96, .6);\n\tfloat t = iTime;\n    \n    float turn = (.1-m.x)*twopi;\n    float s = sin(turn);\n    float c = cos(turn);\n    mat3 rotX = mat3(\t  c,  0., s,\n                   \t\t  0., 1., 0.,\n                   \t\t  s,  0., -c);\n    \n    vec3 camPos = vec3(0., 0., 0.);\n    vec3 pos = vec3(0., INVERTMOUSE*10.*cos((m.y)*pi), -10.)*rotX;\n   \t\n    CameraSetup(uv, camPos+pos, camPos, 1.);\n    \n    bg = background(cam.ray.d);\n\n    vec4 info = render(cam.ray.o, cam.ray.d, 0.);\n  \n    vec3 col;\n    if(info.w==-1.) \n        col = bg+WaterSurface(cam.ray.d); \n    else \n        col = info.rgb;\n    \n    fragColor = vec4(col, .1);\n}", "image_inputs": [{"id": "MdjGDR", "previewfilepath": "https://soundcloud.com/etheredm/hollywood-principle-breathing-underwater-ether-remix", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/etheredm/hollywood-principle-breathing-underwater-ether-remix", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llcSz8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llcXR4", "name": "Zigzag iterations", "author": "kellyegan", "description": "triangle pattern", "tags": ["triangles"], "likes": 1, "viewed": 161, "date": "1478401796", "time_retrieved": "2024-06-20T18:44:13.492252", "image_code": "#define TAU 6.28318530718\n\n\nfloat diagonal( vec2 uv, float w, float i ) {\n  return i < 0.0 ? uv.y - uv.x : (uv.x + uv.y) - w;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    float c = 40.0;\n    \n    vec2 pos_f = fract(uv * c);\n    vec2 pos_i = floor(uv * c);\n\n    float a = sin(3.0 + (pos_i.y + pos_i.x * c) * (iTime * 0.001) );   \n        \n    float l = smoothstep( -0.1, 0.0, diagonal( pos_f, 1.0, a))\n            - smoothstep( 0.0, 0.1, diagonal( pos_f, 1.0, a ));\n    \n    vec3 h = l * vec3( 0.5 + pos_i.x / (c* 2.0), pos_i.y / c, (a + 1.0) / 2.0 );\n    \n    fragColor = vec4( h ,1.0);\n    \n}\n\n\n\t\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llcXR4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llcXRN", "name": "Green Hayduke", "author": "Dain", "description": "Shane's desert passage shader, with a patternSin instead of cellTile used on walls and some different colors/path etc\n\nShane's Desert passage: https://www.shadertoy.com/view/XtyGzc#\npatternsin: https://www.shadertoy.com/view/ll3XRN", "tags": ["noise", "cave", "path", "rock", "passage"], "likes": 30, "viewed": 907, "date": "1478419648", "time_retrieved": "2024-06-20T18:44:16.704633", "image_code": "/*Shane's in's dessert passage, but using PatternSin instead of cellTile on cavern walls.\n\n\n*/\n//uncomment to show original(with celltile)\n//#define SHOW_ORIGINAL\n\n/*\n\tDesert Passage\n\t--------------\n\n\tThis is a rendering of an ancient, sandstone passageway, carved out over time on a planet... that \n\tslightly resembles a hastily-constructed, man-made set on the original Star Trek series, and where \n\tthe occasional rock hangs in mid air. Thankfully, I made up for it with some three-layer dust to \n\tgive it a bit more authenticity. :)\n\n\tI tend to favor abstract scenes, simply for the reason that so-called natural looking ones are harder \n\tto produce at decent frame rates... for me, anyway. With abstract scenes, I can use fake physics - or\n\tincorrect physics - then claim that I meant for it to be that way. :)\n\n\tAiekick's \"Weird Canyon\" was the inspiration for this. I liked his idea to carve out a solid object \n\twith Voronoi to create an \"Antelope Canyon\" like setting. The rendering style was influenced by \n\tDave Hoskins's \"Skin Peeler,\" which is based off of Nimitz's \"Xyptonjtroz\" example. Originally, I'd\n\thoped to emulate the look of IQ's \"Fractal Cave\" with cool streaming light shafts, but I thought I'd \n\tsave that for another time.\n\n\tThe scene is created by constructing a sinusoidal cave like mass, then carving out the surface with a\n\tcustom cellular algorithm that emulates Voronoi. It's pretty self explanatory and is contained in the\n\tdistance function. By the way, if you tried rendering the same scene using regular 3D Voronoi, your \n\tcircuits would fry.\n\n\tIn fact, this particular example makes usage of layering in order of aesthetic importance. Basically, \n\tthe larger, undulating base layers are raymarched - preferably with cheap algorithms - and the finer \n\tdetails - which tend to be more expensive - are bump mapped.\n\t\n\n\tRelated examples:\n\n\t// Gorgeous rendering.\n\tFractal Cave - IQ\n\thttps://www.shadertoy.com/view/Xtt3Wn\n\n\t// A more abstract version.\n\tWeird Canyon - Aiekick\n\thttps://www.shadertoy.com/view/XtjSRm\n\n\t// One of my favorite simple coloring jobs.\n    Skin Peeler - Dave Hoskins\n    https://www.shadertoy.com/view/XtfSWX\n    Based on one of my all time favorites:\n    Xyptonjtroz - Nimitz\n\thttps://www.shadertoy.com/view/4ts3z2\n\n*/\n\n// The far plane. I'd like this to be larger, but the extra iterations required to render the \n// additional scenery starts to slow things down on my slower machine.\n#define FAR 80.\n\n\n// 2x2 matrix rotation. Angle vector, courtesy of Fabrice.\nmat2 rot2( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n// 1x1 and 3x1 hash functions.\nfloat hash( float n ){ return fract(cos(n)*45758.5453); }\nfloat hash( vec3 p ){ return fract(sin(dot(p, vec3(7, 157, 113)))*45758.5453); }\n\n\n// Draw the object on the repeat tile. In this case, a sphere. The result it squared, but that can\n// be taken into account after obtaining the minimum. See below.\nfloat drawObject(in vec3 p){ p = fract(p)-.5; return dot(p, p); }\n\n\n// Repeat cellular tile routine. The operation count is extremely low when compared to conventional\n// methods. No loops, no flooring, no hash calls, etc. Conceptually speaking, this is the fastest way \n// to produce a reasonable 3D cellular pattern... Although, there's one with three objects and no \n// rotation, but quality really suffers at that point. \nfloat cellTile(in vec3 p){\n    \n    // Draw four overlapping objects (spheres, in this case) at various positions throughout the tile.\n    vec4 d; \n    d.x = drawObject(p - vec3(.81, .62, .53));\n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.y = drawObject(p - vec3(.39, .2, .11));\n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = drawObject(p - vec3(.62, .24, .06));\n    p.xz = vec2(p.z-p.x, p.z + p.x)*.7071;\n    d.w = drawObject(p - vec3(.2, .82, .64));\n\n    // Obtain the minimum, and you're done.\n    d.xy = min(d.xz, d.yw);\n        \n    return min(d.x, d.y)*2.66; // Scale between zero and one... roughly//.\n}\n\n\n //that varies over time, which depends upon the frequencies and amplitudes.\nvec2 path(in float z){ return -vec2(20.*sin(z * .02), 4.*cos(z * .09) + 1.*(sin(z*.025)  - 1.)); }\n\n\n// The triangle function that Sha\n// The path is a 2D sinusoid that varies over time, which depends upon the frequencies and amplitudes.\nvec2 path3(in float z){ \n    float height =  4.*cos(z * .09) + 3.*(sin(z*.025));\n    return vec2(20.*sin(z * .04),height - 1.0);\n        }\n#define PI 3.14159265359\n#define twoPI PI*2.0\n#define HashMe(a) fract(sin(a)*13.0) \n \nfloat iqNoise(vec3 x) {\n    vec3 p = floor(x );\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n   // f = f*f*f*(f*(f*6.0-15.0)+10.0);\n    float c1 = 883.0;\n    float c2 = 971.0;\n    float c3 = 1.0;//127.0;\n    float n = p.x*c3 + p.y*c2+ c1*p.z;\n    return mix(\n        mix(\n            mix(HashMe(n+0.0),HashMe(n+ c3),f.x),\n            mix(HashMe(n+c2),HashMe(n+c2+ c3),f.x),\n            f.y),\n        mix(\n            mix(HashMe(n+c1),HashMe(n+c1+ c3),f.x),\n            mix(HashMe(n+c1+c2),HashMe(n+c1+c2+ c3),f.x),\n            f.y),\n        f.z);\n}\n\nfloat PatternSins(vec3 x){\n     //x = (x)+ sin(x)*twoPI*1.0 + cos(x.yzx*0.5)*twoPI*0.25  + cos(x.zxy*0.1)*twoPI*.10;\n     x = (x)+ sin(x)*twoPI;\n    return iqNoise(x);\n}\n\n// The triangle function that Shadertoy user Nimitz has used in various triangle noise demonstrations.\n// See Xyptonjtroz - Very cool.\n//vec3 tri(in vec3 x){return abs(fract(x)-.5);} // Triangle function.\n\n// The function used to perturb the walls of the passage structure: I came up with the tiled cellular\n// routine in order to raymarch something that resembled Voronoi. Regular 3D Voronoi is so intensive\n// that it's hard enough to bump map, let alone raymarch. Conceptually speaking, this algorithm is as\n// fast as you're going to get, yet it's still only good for one raymarching layer. The other cellular\n// layers (two more) have been bump mapped.\nfloat surfFunc(in vec3 p){\n   #ifndef SHOW_ORIGINAL\n    return PatternSins(p/6.0) ;//+ PatternSins(p/2.0)*0.2 ; // + PatternSins(p/12.0)*0.5;///6.0);//*2.0;\n    \n   #else\n    float c = cellTile(p/6.); // Resembles a standard 3D Voronoi layer.\n    return mix(c, cos(c*6.283*2.)*.5 + .5, .125); // Mixing in a touch of sinusoidal variation.\n    \n   #endif\n    // Cheaper wall layering (although, not much), for comparison. \n    //p /= 2.;\n    //float c = dot(tri(p*.5 + tri(p*0.25).yzx), vec3(0.666));\n    //return mix(c, cos(c*6.283*1.5)*.5 + .5, .25);\n    \n    //p /= 5.;\n    //return dot(tri(p + tri(p.zxy)), vec3(0.666));\n\n}\n\n\n// IQ's smooth minium function. \nfloat smin(float a, float b , float s){\n    \n    float h = clamp( 0.5 + 0.5*(b-a)/s, 0. , 1.);\n    return mix(b, a, h) - h*(1.0-h)*s;\n}\n\n// Smooth maximum, based on IQ's smooth minimum.\nfloat smax(float a, float b, float s){\n    \n    float h = clamp( 0.5 + 0.5*(a-b)/s, 0., 1.);\n    return mix(b, a, h) + h*(1.0-h)*s;\n}\n\n// The desert passage scene. Use a gyroid object as the passage-system base layer, carve it out\n// with the cellular function, put in a floor, then cap the whole thing off at roof height.\nfloat map(vec3 p){\n    \n\t// Surface function to perturb the walls.\n    float sf = surfFunc(p);\n\n    // A gyroid object to form the main passage base layer.\n    float cav = dot(cos(p*3.14159265/8.), sin(p.yzx*3.14159265/8.)) + 2.;\n    \n    // Mold everything around the path.\n    p.xy -= path(p.z);\n    \n    // The oval tunnel. Basically, a circle stretched along Y.\n    float tun = 1.5 - length(p.xy*vec2(1, .4));\n   \n    // Smoothly combining the tunnel with the passage base layer,\n    // then perturbing the walls.\n    tun = smax(tun, 1.-cav, 2.) + .75 + (.5-sf);\n    \n    float gr = p.y + 7. - cav*.5 + (.5-sf)*.5; // The ground.\n    float rf = p.y - 15.; // The roof cutoff point.\n    \n    // Smoothly combining the passage with the ground, and capping\n    // it off at roof height.\n    return smax(smin(tun, gr, .1), rf, 1.);\n \n \n}\n\n\n\n// Basic raymarcher. I haven't tweaked this yet. I think it needs it.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    float t = 0., h;\n    \n    for(int i=0; i<128; i++){\n    \n        h = map(ro+rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(h)<0.002*(t*.25 + 1.) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.)\n        \n        t += h*.8;\n    }\n\n    return min(t, FAR);\n}\n\n\n// Tetrahedral normal - courtesy of IQ. I'm in saving mode, so the two \"map\" calls saved make\n// a difference. Also because of the random nature of the scene, the tetrahedral normal has the \n// same aesthetic effect as the regular - but more expensive - one, so it's an easy decision.\nvec3 normal(in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.001;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\n/*\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 normal(in vec3 p) {\n\tconst vec2 e = vec2(0.002, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n*/\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D t, in vec3 p, in vec3 n ){\n   \n    n = max(abs(n) - .2, .001); // The original is multiplied by \"7,\" but it feels slightly redundant.\n    n /= (n.x + n.y + n.z );  // Normalize.\n    // Three planes, weighted by their normals. Hence, tri-planar, I guess. :)\n\tp = (texture(t, p.yz)*n.x + texture(t, p.zx)*n.y + texture(t, p.xy)*n.z).xyz;\n    return p*p; // Rough sRGB to linear.\n}\n\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n// Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n// example that explains it, if you require it.\nfloat n3D(in vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// Surface bump function: Cheap, but with decent visual impact. Of couse, \"cheap\" is a relative\n// term. This contains two 3D cellular functions and a 3D noise function. Thankfully, they're all\n// custom written and pretty quick.\nfloat bumpSurf3D( in vec3 p){\n\n    float bmp = cellTile(p/3.)*.8 + cellTile(p)*.2;\n    float ns = n3D(p*6. - bmp*6.);\n    \n    return mix(bmp, 1. - abs(ns-.333)/.667, .05);\n\n}\n\n// Standard function-based bump mapping function.\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    const vec2 e = vec2(0.001, 0);\n    float ref = bumpSurf3D(p);                 \n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy),\n                      bumpSurf3D(p - e.yxy),\n                      bumpSurf3D(p - e.yyx) )-ref)/e.x;                     \n          \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\n// The iterations should be higher for proper accuracy, but in this case, I wanted less accuracy, just to leave\n// behind some subtle trails of light in the caves. They're fake, but they look a little like light streaming \n// through some openings... kind of.\nfloat softShadow(in vec3 ro, in vec3 rd, in float start, in float end, in float k){\n\n    float shade = 1.0;\n    // Increase this and the shadows will be more accurate, but the wispy light trails in the caves will disappear.\n    // Plus more iterations slow things down, so it works out, in this case.\n    const int maxIterationsShad = 10; \n\n    // The \"start\" value, or minimum, should be set to something more than the stop-threshold, so as to avoid a collision with \n    // the surface the ray is setting out from. It doesn't matter how many times I write shadow code, I always seem to forget this.\n    // If adding shadows seems to make everything look dark, that tends to be the problem.\n    float dist = start;\n    float stepDist = end/float(maxIterationsShad);\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n        // End, or maximum, should be set to the distance from the light to surface point. If you go beyond that\n        // you may hit a surface not between the surface and the light.\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0., 1., k*h/dist));\n        \n        // What h combination you add to the distance depends on speed, accuracy, etc. To be honest, I find it impossible to find \n        // the perfect balance. Faster GPUs give you more options, because more shadow iterations always produce better results.\n        // Anyway, here's some posibilities. Which one you use, depends on the situation:\n        // +=max(h, 0.001), +=clamp( h, 0.01, 0.25 ), +=min( h, 0.1 ), +=stepDist, +=min(h, stepDist*2.), etc.\n        \n        // In this particular instance the light source is a long way away. However, we're only taking a few small steps\n        // toward the light and checking whether anything \"locally\" gets in the way. If a part of the scene a long distance away\n        // is between our hit point and the light source, it won't be accounted for. Technically that's not correct, but the local\n        // shadows give that illusion... kind of.\n        dist += clamp(h, .2, stepDist); // For this example only. Not to be trusted. :)\n        \n        // There's some accuracy loss involved, but early exits from accumulative distance function can help.\n        if (abs(h)<0.001 || dist > end) break; \n    }\n\n    // I usually add a bit to the final shade value, which lightens the shadow a bit. It's a preference thing. Really dark shadows \n    // look too brutal to me.\n    return min(max(shade, 0.) + .1, 1.); \n}\n\n\n\n\n\n// Ambient occlusion, for that self shadowed look. Based on the original by XT95. I love this \n// function. For a better version, and usage, refer to XT95's examples below:\n//\n// Hemispherical SDF AO - https://www.shadertoy.com/view/4sdGWN\n// Alien Cocoons - https://www.shadertoy.com/view/MsdGz2\nfloat calculateAO( in vec3 p, in vec3 n)\n{\n\tfloat ao = 0.0, l;\n\tconst float nbIte = 6.0;\n    const float maxDist = 3.;\n\t//const float falloff = 0.9;\n    for(float i=1.; i< nbIte+.5; i++ ){\n    \n        l = (i*.66 + hash(i)*.34)/nbIte*maxDist;\n        \n        ao += (l - map( p + n*l ))/(1.+ l);// / pow(1.+l, falloff);\n    }\n\t\n    return clamp( 1.-ao/nbIte, 0., 1.);\n}\n\n\n// Just a single color. I debated over whether to include the sun, but the dust is there and I'm saving cycles.\nvec3 getSky(){ return vec3(1., 1.4, 1.7); }\n\n\n/////\n// Code block to produce three layers of fine dust. Not sophisticated at all.\n// If you'd like to see a much more sophisticated version, refer to Nitmitz's\n// Xyptonjtroz example. Incidently, I wrote this off the top of my head, but\n// I did have that example in mind when writing this.\nfloat trig3(in vec3 p){\n    p = cos(p*2. + (cos(p.yzx) + 1.)*1.57);// + iTime*1.\n    return dot(p, vec3(0.1666)) + 0.5;\n}\n\n// Basic low quality noise consisting of three layers of rotated, mutated \n// trigonometric functions. Needs work, but it's OK for this example.\nfloat trigNoise3D(in vec3 p){\n\n    // 3D transformation matrix.\n    const mat3 m3RotTheta = mat3(0.25, -0.866, 0.433, 0.9665, 0.25, -0.2455127, -0.058, 0.433, 0.899519 )*1.5;\n  \n\tfloat res = 0.;\n\n    float t = trig3(p*3.14159265);\n\tp += (t);\n    p = m3RotTheta*p;\n    //p = (p+0.7071)*1.5;\n    res += t;\n    \n    t = trig3(p*3.14159265); \n\tp += (t)*0.7071;\n    p = m3RotTheta*p;\n     //p = (p+0.7071)*1.5;\n    res += t*0.7071;\n\n    t = trig3(p*3.14159265);\n\tres += t*0.5;\n\t \n\treturn res/2.2071;\n}\n\n// Hash to return a scalar value from a 3D vector.\nfloat hash31(vec3 p){ return fract(sin(dot(p, vec3(127.1, 311.7, 74.7)))*43758.5453); }\n\n// Very few layers of cheap trigonometric noise to produce some subtle mist.\n// Start at the ray origin, then take four samples of noise between it\n// and the surface point. Apply some very simplistic lighting along the \n// way. It's not particularly well thought out, but it doesn't have to be.\nfloat getMist(in vec3 ro, in vec3 rd, in vec3 lp, in float t){\n\n    float mist = 0.;\n    ro += rd*t/3.; // Edge the ray a little forward to begin.\n\n    ;; float moveMist = iTime*13.40;\n    //ro.z += sin(iTime*0.01)*0111.1;\n    //ro.z += iTime;\n    for (int i = 0; i<3; i++){\n        // Lighting. Technically, a lot of these points would be\n        // shadowed, but we're ignoring that.\n        float sDi = length(lp-ro)/FAR; \n\t    float sAtt = 1./(1. + sDi*0.1 + sDi*sDi*0.01);\n\t    // Noise layer.\n        mist += trigNoise3D(ro/2.)*sAtt;//trigNoise3D\n        // Advance the starting point towards the hit point.\n        ro += rd*t/3.;\n    }\n    \n    // Add a little noise, then clamp, and we're done.\n    return clamp(mist/1.5 + hash31(ro)*0.1-0.05, 0., 1.);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\t\n\n\n\t\n\t// Screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 ro = vec3(0, 0, iTime*8.); // Camera position, doubling as the ray origin.\n\tvec3 lookAt = ro + vec3(0, 0, .5);  // \"Look At\" position.\n \n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera and \"look at\" vectors down the tunnel. The \"path\" function is \n\t// synchronized with the distance function.\n\tro.xy += path(ro.z);\n\tlookAt.xy += path(lookAt.z);\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159265/2.5; // FOV - Field of view.\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(vec3(forward.z, 0, -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(forward + FOV*u.x*right + FOV*u.y*up);\n    \n    // Swiveling the camera about the XY-plane (from left to right) when turning corners.\n    // Naturally, it's synchronized with the path in some kind of way.\n\trd.xy = rot2( path(lookAt.z).x/64. )*rd.xy;\n    \n\t\n    // Usually, you'd just make this a unit directional light, and be done with it, but I\n    // like some of the angular subtleties of point lights, so this is a point light a\n    // long distance away. Fake, and probably not advisable, but no one will notice.\n    vec3 lp = vec3(FAR*.5, FAR, FAR) + vec3(0, 0, ro.z);\n \n\n\t// Raymarching.\n    float t = trace(ro, rd);\n    \n   \n    // Sky. Only retrieving a single color this time.\n    vec3 sky = getSky();\n    \n    // The passage color. Can't remember why I set it to sky. I'm sure I had my reasons.\n    vec3 col = sky;\n    \n    // Surface point. \"t\" is clamped to the maximum distance, and I'm reusing it to render\n    // the mist, so that's why it's declared in an untidy postion outside the block below...\n    // It seemed like a good idea at the time. :)\n    vec3 sp = ro+t*rd; \n    \n    float pathHeight = sp.y-path(sp.z).y; // Path height line, of sorts.\n    \n    // If we've hit the ground, color it up.\n    if (t < FAR){\n    \n        \n        vec3 sn = normal( sp ); // Surface normal.\n        \n        // Light direction vector. From the sun to the surface point. We're not performing\n        // light distance attenuation, since it'll probably have minimal effect.\n        vec3 ld = lp-sp;\n        ld /= max(length(ld), 0.001); // Normalize the light direct vector.\n\n        \n        // Texture scale factor.        \n        const float tSize = 1./4.;\n        \n        // Function based bump mapping.\n        sn = doBumpMap(sp, sn, .75/(1. + t/FAR*.25));\n        \n        // Bump mapping with the pink sandstone texture to provide a bit of gritty detailing.\n        float bf = (pathHeight + 5. < 0.)?  .05: .025;\n        sn = doBumpMap(iChannel0, sp*tSize, sn, bf/(1. + t/FAR));\n        \n        \n        float shd = softShadow(sp, ld, 0.05, FAR, 8.); // Shadows.\n        float ao = calculateAO(sp, sn); // Ambient occlusion.\n        \n        float dif = max( dot( ld, sn ), 0.0); // Diffuse term.\n        float spe = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 5.); // Specular term.\n        float fre = clamp(1.0 + dot(rd, sn), 0.0, 1.0); // Fresnel reflection term.\n \n        // Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a sandstone consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.0);\n\t\tfloat fre2 = mix(.2, 1., Schlick);  //F0 = .2 - Hard clay... or close enough.\n       \n        // Overal global ambience. Without it, the cave sections would be pretty dark. It's made up,\n        // but I figured a little reflectance would be in amongst it... Sounds good, anyway. :)\n        float amb = fre*fre2*.7 + .05;\n        \n        // Coloring the soil - based on depth. Based on a line from Dave Hoskins's \"Skin Peeler.\"\n        col = clamp(mix(vec3(.152, 0.4275,.153), vec3(.225, 0.05985, 0.0153), -sn.y*.5 + pathHeight*.5 + 1.75), vec3(.9, 0.534375, 0.239), vec3(.9, .855, .765));\n        \n              \n        // Give the soil a bit of a sandstone texture.\n        col = smoothstep(-.5, 1., tex3D(iChannel1, sp*tSize, sn)*2.)*(col + vec3(.225, .21375, .19125));\n        \n        // Making the ground reflect just a little more to give the appearance of fine dust or sand...\n        // It's a work in progress. :)\n        col += smoothstep(0., 1., -pathHeight - 5.5)*fre*.25;\n \n        // A bit of sky reflection. Not really accurate, but I've been using fake physics since the 90s. :)\n        col += getSky()*fre*fre2; \n        \n        \n        \n        // Combining all the terms from above. Some diffuse, some specular - both of which are\n        // shadowed and occluded - plus some global ambience. Not entirely correct, but it's\n        // good enough for the purposes of this demonstation.        \n        col = (col*(dif + .1) + vec3(1)*fre2*spe)*shd*ao + amb*pow(col, vec3(2.));\n\n        \n    }\n    \n   \n    // Combine the scene with the sky using some cheap volumetric substance.\n\tfloat dust = getMist(ro , rd, lp, t)*(1.-clamp((pathHeight - 5.)*.125, 0., 1.));//(-rd.y + 1.);\n    sky = getSky()*mix(01.2, .75, dust);\n    col = mix(col, sky, min(t*t*1.5/FAR/FAR, 1.)); // Quadratic fade off. More subtle.\n    //col = mix(col, sky, min(t*.75/FAR, 1.)); // Linear fade. Much dustier. I kind of like it.\n\n    \n    // Standard way to do a square vignette. Note that the maxium value value occurs at \"pow(0.5, 4.) = 1./16,\" \n    // so you multiply by 16 to give it a zero to one range. This one has been toned down with a power\n    // term to give it more subtlety.\n    u = fragCoord/iResolution.xy;\n    col = min(col, 1.)*pow( 16.0*u.x*u.y*(1.0-u.x)*(1.0-u.y) , .125);\n \n    // Done.\n\tfragColor = vec4(sqrt(clamp(col, 0., 1.)), 1);\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llcXRN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llcXW7", "name": "Foamy water", "author": "k_mouse", "description": "Some 2d water with foam. Try increasing MAX_ITER for a smoke-like look to it.", "tags": ["water", "foam"], "likes": 102, "viewed": 6667, "date": "1479912389", "time_retrieved": "2024-06-20T18:44:16.704633", "image_code": "// Made by k-mouse (2016-11-23)\n// Modified from David Hoskins (2013-07-07) and joltz0r (2013-07-04)\n\n#define TAU 6.28318530718\n\n#define TILING_FACTOR 1.0\n#define MAX_ITER 8\n\n\nfloat waterHighlight(vec2 p, float time, float foaminess)\n{\n    vec2 i = vec2(p);\n\tfloat c = 0.0;\n    float foaminess_factor = mix(1.0, 6.0, foaminess);\n\tfloat inten = .005 * foaminess_factor;\n\n\tfor (int n = 0; n < MAX_ITER; n++) \n\t{\n\t\tfloat t = time * (1.0 - (3.5 / float(n+1)));\n\t\ti = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));\n\t\tc += 1.0/length(vec2(p.x / (sin(i.x+t)),p.y / (cos(i.y+t))));\n\t}\n\tc = 0.2 + c / (inten * float(MAX_ITER));\n\tc = 1.17-pow(c, 1.4);\n    c = pow(abs(c), 8.0);\n\treturn c / sqrt(foaminess_factor);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tfloat time = iTime * 0.1+23.0;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 uv_square = vec2(uv.x * iResolution.x / iResolution.y, uv.y);\n    float dist_center = pow(2.0*length(uv - 0.5), 2.0);\n    \n    float foaminess = smoothstep(0.4, 1.8, dist_center);\n    float clearness = 0.1 + 0.9*smoothstep(0.1, 0.5, dist_center);\n    \n\tvec2 p = mod(uv_square*TAU*TILING_FACTOR, TAU)-250.0;\n    \n    float c = waterHighlight(p, time, foaminess);\n    \n    vec3 water_color = vec3(0.0, 0.35, 0.5);\n\tvec3 color = vec3(c);\n    color = clamp(color + water_color, 0.0, 1.0);\n    \n    color = mix(water_color, color, clearness);\n\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llcXW7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llcXWM", "name": "Iridescent crystals", "author": "tdhooper", "description": "I originally planed to add a radiolaria model in the middle, and experiment with refraction, but this looks pretty nice so those plans can wait until next time.\n\nI've had to limit the step distance as the chamfers are causing a lot of overshoots :(", "tags": ["dodecahedron", "iridescence", "facet"], "likes": 59, "viewed": 2034, "date": "1480256166", "time_retrieved": "2024-06-20T18:44:18.989862", "image_code": "#define MODEL_ROTATION vec2(.122, .5)\n\n// 0: Defaults\n// 1: Model\n#define MOUSE_CONTROL 1\n\n// Comment out for faster rendering\n#define ENABLE_CHAMFER\n\n\n// --------------------------------------------------------\n// HG_SDF\n// https://www.shadertoy.com/view/Xs3GRB\n// --------------------------------------------------------\n\n#define PI 3.14159265359\n#define PHI (1.618033988749895)\n#define TAU 6.283185307179586\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n\n// Intersection has to deal with what is normally the inside of the resulting object\n// when using union, which we normally don't care about too much. Thus, intersection\n// implementations sometimes differ from union implementations.\nfloat fOpIntersectionChamfer(float a, float b, float r) {\n\tfloat m = max(a, b);\n\tif (r <= 0.) return m;\n\tif (((-a < r) && (-b < r)) || (m < 0.)) {\n\t\treturn max(m, (a + r + b)*sqrt(0.5));\n\t} else {\n\t\treturn m;\n\t}\n}\n\n\n// --------------------------------------------------------\n// http://math.stackexchange.com/a/897677\n// --------------------------------------------------------\n\nmat3 orientMatrix(vec3 A, vec3 B) {\n    mat3 Fi = mat3(\n        A,\n        (B - dot(A, B) * A) / length(B - dot(A, B) * A),\n        cross(B, A)\n    );\n    mat3 G = mat3(\n        dot(A, B),              -length(cross(A, B)),   0,\n        length(cross(A, B)),    dot(A, B),              0,\n        0,                      0,                      1\n    );\n    return Fi * G * inverse(Fi);\n}\n\n\n// --------------------------------------------------------\n// IQ\n// https://www.shadertoy.com/view/ll2GD3\n// --------------------------------------------------------\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n\n// --------------------------------------------------------\n// MAIN\n// --------------------------------------------------------\n\nfloat time;\n\nstruct Model {\n    float dist;\n    vec3 colour;\n    float id;\n};\n\n    \nfloat quadrant(float a, float b) {\n\treturn ((sign(a) + sign(b) * 2.) + 3.) / 2.;\n}\n\n// Nearest icosahedron vertex and id\nvec4 icosahedronVertex(vec3 p) {\n    vec3 v1, v2, v3, result, plane;\n    float id;\n    float idMod = 0.;\n\tv1 = vec3(\n    \tsign(p.x) * PHI,\n        sign(p.y) * 1.,\n        0\n    );\n\tv2 = vec3(\n    \tsign(p.x) * 1.,\n        0,\n        sign(p.z) * PHI\n    );\n\tv3 = vec3(\n    \t0,\n        sign(p.y) * PHI,\n        sign(p.z) * 1.\n    );\n    plane = normalize(cross(\n        mix(v1, v2, .5),\n        cross(v1, v2)\n    ));\n    if (dot(p, plane) > 0.) {\n    \tresult = v1;\n        id = quadrant(p.y, p.x);\n    } else {\n    \tresult = v2;\n        id = quadrant(p.x, p.z) + 4.;\n    }\n    plane = normalize(cross(\n        mix(v3, result, .5),\n        cross(v3, result)\n    ));\n    if (dot(p, plane) > 0.) {\n    \tresult = v3;\n        id = quadrant(p.z, p.y) + 8.;\n    }\n    return vec4(normalize(result), id);\n}\n\nvec3 rand(vec3 seed){\n    return fract(mod(seed, 1.) * 43758.5453);\n}\n\nvec3 jitterOffset(float seed) {\n\treturn normalize(rand(vec3(seed, seed + .2, seed + .8)) - .5);\n}\n\nvec3 jitterVec(vec3 v, float seed, float magnitude) {\n\treturn normalize(v + jitterOffset(seed) * magnitude);\n}\n\nfloat alias(float t, float resolution) {\n\treturn floor(t * resolution) / resolution;\n}\n\n#ifdef ENABLE_CHAMFER\n\tconst float chamfer = .003;\n#else\n\tconst float chamfer = .0;\n#endif\n\nfloat fCrystalShard(vec3 p, float size) {\n    float d;\n    float width = size * .04 + .07;\n    vec3 o = normalize(vec3(1,0,-.04));\n\n    pModPolar(p.xy, 5.);\n    float part1, part2;\n    \n    p.y = abs(p.y);\n\n    part1 = fPlane(p, vec3(1,0,-.04), -width);\n\n    pR(p.xy, TAU/5.);\n    part2 = fPlane(p, vec3(1,0,-.04), -width);\n    \n    d = max(part1, part2);\n\td = fOpIntersectionChamfer(part1, part2, chamfer);\n\n    return d;\n}\n\nfloat fCrystalCap(vec3 p, float id, float side) {\n    float jitter = id + side * .1;\n    vec3 o = normalize(vec3(1,0,.55));\n\tfloat angle = TAU / 3.;\n    float d, part;\n\n    d = fPlane(p, jitterVec(o, jitter + .3, .1), 0.);\n    \n    pR(p.xy, angle);\n    part = fPlane(p, jitterVec(o, jitter + .5, .1), 0.);\n    d = fOpIntersectionChamfer(d, part, chamfer);\n\n    pR(p.xy, angle);\n    part = fPlane(p, jitterVec(o, jitter + .9, .1), 0.);\n    d = fOpIntersectionChamfer(d, part, chamfer);\n    \n    return d;\n}\n\nfloat fCrystal(vec3 p, float id, float focus) {\n    \n    float size = sin(time * TAU * 4. + focus * 5. + id) * .5 + .5;\n    float size2 = cos(time * TAU * 2. + focus * 5. + id) * .5 + .5;\n    \n    size = alias(size, 2.);\n    size2 = alias(size2, 2.);\n    \n    float height = size2 * .1 + .35;\n    float offset = .9;\n    float d;\n\n    float shard = fCrystalShard(p, size);\n    \n    p.z -= offset;\n    float side = sign(p.z) * .5 + .5;\n    p.z = abs(p.z);\n    p.z -= height;\n\n    float cap = fCrystalCap(p, id, side);\n    d = fOpIntersectionChamfer(shard, cap, chamfer);\n\n\treturn d;\n}\n\nModel model(vec3 p) {    \n\tfloat d = 1000.;\n   \tvec3 col = vec3(0);\n\tvec3 dir = normalize(vec3(\n    \t0,\n        -PHI,\n        -1\n    ));\n    \n    vec4 iv = icosahedronVertex(p);\n    vec3 v = iv.xyz;\n    float id = iv[3] / 12.;\n    \n    p *= orientMatrix(v, vec3(0,0,1));\n    pR(p.xy, id);\n    \n    pR(p.xy, time * TAU);\n    \n    float focus = dot(v, dir) * .5 + .5;\n\n    d = fCrystal(p, id, focus);\n        \n    return Model(d, col, 1.);\n}\n\n\n\n// The MINIMIZED version of https://www.shadertoy.com/view/Xl2XWt\n\nconst float MAX_TRACE_DISTANCE = 30.0;           // max trace distance\nconst float INTERSECTION_PRECISION = 0.001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 100;\n\n// Default is 1, reduce to fix overshoots\n#ifdef ENABLE_CHAMFER\n\tconst float FUDGE_FACTOR = .5;\n#else\n\tconst float FUDGE_FACTOR = 1.;\n#endif\n\nmat3 sphericalMatrix(float theta, float phi) {\n    float cx = cos(theta);\n    float cy = cos(phi);\n    float sx = sin(theta);\n    float sy = sin(phi);\n    return mat3(\n\t\tcy, -sy * -sx, -sy * cx,\n\t\t0, cx, sx,\n\t\tsy, cy * -sx, cy * cx\n    );\n}\n\nmat3 mouseRotation(bool enable, vec2 xy) {\n    if (enable) {\n    \tvec2 mouse = iMouse.xy / iResolution.xy;\n\n        if (mouse.x != 0. && mouse.y != 0.) {\n\t    \txy.x = mouse.x;\n    \t\txy.y = mouse.y;\n        }\n    }\n    float rx, ry;\n    \n    rx = (xy.y + .5) * PI;\n    ry = (-xy.x) * 2. * PI;\n    \n    return sphericalMatrix(rx, ry);\n}\n\nmat3 modelRotation() {\n    mat3 m = mouseRotation(MOUSE_CONTROL==1, MODEL_ROTATION);\n    return m;\n}\n\n\n// checks to see which intersection is closer\nModel opU( Model m1, Model m2 ){\n    if (m1.dist < m2.dist) {\n    \treturn m1;\n    } else {\n    \treturn m2;\n    }\n}\n\n\n//--------------------------------\n// Modelling \n//--------------------------------\n\n\nModel map( vec3 p ){\n    Model res = Model(1000000., vec3(0), 0.);\n    p *= modelRotation();\n    res = opU(res, model(p));\n   \treturn res;\n}\n\n\nconst float GAMMA = 2.2;\n\nvec3 gamma(vec3 color, float g)\n{\n    return pow(color, vec3(g));\n}\n\nvec3 linearToScreen(vec3 linearRGB)\n{\n    return gamma(linearRGB, 1.0 / GAMMA);\n}\n\n\nstruct Hit {\n    float len;\n    vec3 colour;\n    float id;\n};\n\nHit calcIntersection( in vec3 ro, in vec3 rd ){\n\n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n    float res = -1.0;\n    float id = -1.;\n    vec3 colour;\n\n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n\n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n        Model m = map( ro+rd*t );\n        h = m.dist;\n        t += h * FUDGE_FACTOR;\n        id = m.id;\n        colour = m.colour;\n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n\n    return Hit( res , colour , id );\n}\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera(out vec3 camPos, out vec3 camTar, out float camRoll, in float time, in vec2 mouse) {\n    float dist = 3.;\n    camRoll = 0.;\n    camTar = vec3(0);\n    camPos = vec3(0,.1,-dist);\n    pR(camPos.yx, time*TAU*1.);\n    camPos += camTar;\n}\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).dist - map(pos-eps.xyy).dist,\n        map(pos+eps.yxy).dist - map(pos-eps.yxy).dist,\n        map(pos+eps.yyx).dist - map(pos-eps.yyx).dist );\n    return normalize(nor);\n}\n\n\nvec3 render( Hit hit , vec3 ro , vec3 rd ){\n\n    vec3 bg = vec3(0.);\n    vec3 color = bg;\n\n    if (hit.id == 1.) {\n    \tvec3 pos = ro + rd * hit.len;\n        vec3 norm = calcNormal( pos );\n        vec3 ref = reflect(rd, norm);\n        vec3 lig = normalize(vec3(.5,1,-.5));\n        vec3 dome = vec3(0,1,0);\n        vec3 eye = vec3(0,0,-1);\n\n        vec3 perturb = sin(pos * 10.);\n        color = spectrum( dot(norm + perturb * .05, eye) * 2.);\n\n        float specular = clamp(dot(ref, lig), 0., 1.);\n        specular = pow((sin(specular * 20. - 3.) * .5 + .5) + .1, 32.) * specular;\n        specular *= .1;\n        specular += pow(clamp(dot(ref, lig), 0., 1.) + .3, 8.) * .1;\n\n        float shadow = pow(clamp(dot(norm, dome) * .5 + 1.2, 0., 1.), 3.);\n        color = color * shadow + specular;\n\n        float near = 2.8;\n        float far = 4.;\n        float fog = (hit.len - near) / (far - near);\n        fog = clamp(fog, 0., 1.);\n        color = mix(color, bg, fog);\n    }\n\n\treturn color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime;\n    time /= 3.;\n    time = mod(time, 1.);   \n    \n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    vec3 camPos = vec3( 0., 0., 2.);\n    vec3 camTar = vec3( 0. , 0. , 0. );\n    float camRoll = 0.;\n    \n    // camera movement\n    doCamera(camPos, camTar, camRoll, iTime, m);\n    \n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( camPos, camTar, camRoll );  // 0.0 is the camera roll\n    \n    // create view ray\n    vec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    Hit hit = calcIntersection( camPos , rd  );\n\n    vec3 color = render( hit , camPos , rd );    \n    color = linearToScreen(color);\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llcXWM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llcXWr", "name": "TheGrid", "author": "dila", "description": "Kali's circuit inspired flythrough. Feels a bit like Tron or something: https://www.youtube.com/watch?v=UTHCGcFH6jk", "tags": ["raymarch"], "likes": 62, "viewed": 967, "date": "1478974950", "time_retrieved": "2024-06-20T18:44:18.995637", "image_code": "vec3 col1 = vec3(0.118, 0.365, 0.467);\nvec3 col2 = vec3(0.514, 0.851, 0.933);\nvec3 col3 = vec3(0.957, 0.875, 0.29);\nvec3 col4 = vec3(0.973, 0.663, 0.106);\nvec3 col5 = vec3(0.843, 0.431, 0.176);\nvec3 col6 = vec3(0.361, 0.251, 0.145);\n\nmat2 rot(float x)\n{\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec3 tex(vec3 p, float pz)\n{\n    vec2 q = p.xy;\n    float fp = 10.0;\n    q = (fract(q / fp) - 0.5) * fp;\n    float d = 1000.0;\n    float mid = 0.0;\n    vec2 mpos = vec2(0.0);\n    const int n = 3;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < 2; ++j) {\n        \tq = abs(q) - 0.5;\n        \tq *= rot(3.141592 * 0.25);\n        }\n        q = abs(q) - 0.25;\n        q *= rot(pz * 0.5);\n        q.x += sin(pz);\n        float k = sdBox(vec3(q, 0.0), vec3(1.0, 0.5, 1.0));\n        if (k < d) {\n\t\t\td = k;\n            mpos = q;\n            mid = float(i);\n        }\n    }\n    d = max(d, -sdBox(p, vec3(1.0, 2.0, 1.0)));\n    float f = 1.0 / (1.0 + d * d * 1000.0);\n    float dl = pz * 0.7 + mid * 0.6 + mpos.x * 0.5;\n    dl = sin(dl + iTime) * 0.5 + 0.5;\n\tvec3 col = mix(vec3(0.0), col2, dl);\n    vec3 tex = texture(iChannel0, mpos.xy).xyz;\n    tex *= tex;\n    float tf = sin(mid + iTime) * 0.5 + 0.5;\n    tex = mix(vec3(0.0), tex, tf);\n    float lt = max(sign(-d), 0.0);\n    return mix(tex * lt * col1, col * 4.0, f);\n}\n\nvec3 _texture(vec3 p, float pz)\n{\n    vec3 ta = tex(p.xyz, pz).xyz;\n    vec3 tb = tex(p.xzy, pz).xyz;\n    vec3 tc = tex(p.yzx, pz).xyz;\n    return (ta + tb + tc) / 3.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 o = vec3(0.0, 0.0, iTime * 4.0);\n    vec3 r = normalize(vec3(uv, 1.3 - dot(uv, uv) * 0.33));\n    \n\tfloat t = fract(iTime * 0.1) * 4.0;\n    vec4 ct = vec4(t, t - 1.0, t - 2.0, t - 3.0);\n    ct = clamp(ct, 0.0, 1.0);\n    ct = pow(ct, vec4(8.0));\n\tct = 1.0 - pow(1.0 - ct, vec4(64.0));\n    ct *= 3.14159 * 0.5;\n    r.xy *= rot(ct.x + ct.y + ct.z + ct.w);\n    \n    vec3 fc = vec3(0.0);\n    \n    const int n = 8;\n    for (int i = 0; i < n; ++i) {\n        float fi = float(i) / float(n);\n        float sr = 1.5;\n        vec3 sp = o;\n        sp.z = floor(sp.z / sr + 1.0 + float(i)) * sr;\n        float t = 0.0;\n        for (int i = 0; i < 15; ++i) {\n            vec3 p = o + r * t - sp;\n            float ws = sin(p.z * 0.125) * 0.5 + 0.5;\n            float c = mix(2.0, 6.0, ws) - abs(p.x);\n            t += min(-p.z, c);\n        }\n        vec3 w = o + r * t - sp;\n        float back = sr * float(n);\n        float f = clamp(t, 0.0, back) / back;\n\t\tf = pow(f, 2.0);\n        vec3 tex = _texture(w, sp.z);\n        fc += tex / float(n);\n    }\n    \n\tfragColor = vec4(sqrt(fc), 1.0);\n}", "image_inputs": [{"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llcXWr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llcXzj", "name": "Daily Shade 27: Crystal prison", "author": "psonice", "description": "A reinforced crystal prison, but what was it built to contain? Whatever it was, it's escaped. ", "tags": ["raymarch", "refraction", "glass"], "likes": 5, "viewed": 673, "date": "1480546147", "time_retrieved": "2024-06-20T18:44:22.099069", "image_code": "/* \nDay 27\n*/\n\n//#define DEBUG\n#ifdef DEBUG\nint debugStep = 0;\nfloat debugValue = 0.0;\n#endif\n\n// Rotation\n#define R(p,a) p=cos(a)*p+sin(a)*vec2(-p.y,p.x);\n\n\n#define kINFINITY 10000.0 // An unimaginably large number\n#define kSQRT2 1.414213\n#define kISQRT2 0.707107\n#define kPI 3.141592\n\n// maximum iteration count\n#define kMAXITERS 150\n#define kEPSILON 0.001\n#define kMAXINTERSECTIONS 1\n\n// refractive index\n#define kREFRACT 1.0/1.5\n\n// materials\n#define kFLOORMATERIAL 0\n#define kGLASSMATERIAL 1\n#define kMIRRORMATERIAL 2\n#define kGLOWMATERIAL 3\n#define kMATTEMATERIAL 4\n\n#define kFLOORCOLOUR vec3(0.7, 0.65, 0.6)\n#define kGLASSCOLOUR vec3(0.9, 0.7, 0.5)\n#define kMIRRORCOLOUR vec3(0.9)\n#define kMIRRORCOLOUR2 vec3(0.5)\n#define kGLOWCOLOUR vec3(0.5)\n\n#define kZENITHCOLOUR vec3(0.3, 0.7, 1.0)\n#define kNADIRCOLOUR vec3(0.7, 0.6, 0.4)\n#define kHORIZONCOLOUR vec3(0.95)\n#define kSUNCOLOUR vec3(100, 90, 70)\n\n// A ray. Has origin + direction.\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n    \n// Distance to nearest surface\nstruct SDResult {\n    float d; // Distance\n    int material; // Nearest material\n};\n\n// A camera. Has a position and a direction. \nstruct Camera {\n    vec3 pos;\n    Ray ray;\n};\n    \n// A disk. Has position, size, colour.\nstruct Disk {\n    vec3 pos;\n    float radius;\n    vec3 col;\n};\n    \nstruct Sphere {\n    vec3 pos;\n    float radius;\n};\n    \nstruct Box {\n\tvec3 pos;\n\tvec3 size;\n    float radius;\n};\n    \nfloat eps = kEPSILON;\nfloat divergence;\n\nvec3 smoothBlend(in vec3 point, in vec3 about, in float radius) {\n    point -= about;\n    point = mix(-point, point, smoothstep(-radius, radius, point));\n    return point + about;\n}\n    \n// Distance to sphere (signed)\nfloat sphereDist(in Ray ray, in Sphere sphere) {\n    return length(ray.origin - sphere.pos) - sphere.radius;\n}\n\n// Distance to sphere surface\nfloat uSphereDist(in Ray ray, in Sphere sphere) {\n    return abs(length(ray.origin - sphere.pos) - sphere.radius);\n}\n\n// Distance to box surface (signed)\nfloat boxDist(in Ray ray, in Box box) {\n    vec3 dist = abs(ray.origin - box.pos) - (box.size * 0.5);\n    vec3 cDist = max(dist, 0.0);\n    return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(cDist) - box.radius;\n}\n\n// Distance to box surface\nfloat uBoxDist(in Ray ray, in Box box) {\n    return abs(length(max(abs(ray.origin - box.pos) - (box.size * 0.5), 0.0)) - box.radius);\n}\n\n// distance to floor\nfloat floorDist(in Ray ray) {\n    float dist = ray.origin.y;\n    return dist;\n}\n\n// traced coords of floor intersection, floor at height y\nvec2 floorPos(in Ray ray, in float y) {\n    float dist = (ray.origin.y - y) / ray.dir.y;\n \treturn ray.origin.xz + ray.dir.xz * dist; \n}\n\n/*\n---- Random/hash stuff ----\n*/\n\n// Normalised random number, borrowed from Hornet's noise distributions: https://www.shadertoy.com/view/4ssXRX\nfloat nrand(in vec2 n) {\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\n// random value based on texture channel 2\nvec3 texrand(in vec2 n, in float mipLevel) {\n    return texture(iChannel2, n, mipLevel).xyz;\n}\n\n// returns a hash value for a fixed size cell\nfloat hashForCell(in vec3 pos, in float cellSize) {\n    float hash = nrand(floor(pos.xz / cellSize) + 68.0);\n    return hash;\n}\n\n// returns a random colour based on the cell hash\nvec3 randomColourForCell(in vec3 pos, in float cellSize) {\n\tfloat hash = hashForCell(pos, cellSize); \n    return vec3(\n        nrand(vec2(hash * 2.0, hash * 4.0)),\n        nrand(vec2(hash * 4.0, hash * 8.0)),\n        nrand(vec2(hash * 8.0, hash * 16.0))\n\t);\n\tvec3 c = vec3(hash, mod(hash + 0.15, 1.0), mod(hash + 0.3, 1.0)) * 0.75;\n}\n\n/*\n---- INTERSECTION OPS ----\n*/\n\n// Union of two signed distances\nfloat unionOp(float d0, float d1) {\n    return min(d0, d1);\n}\n\n// Intersection of two signed distances\nfloat intersectOp(float d0, float d1) {\n    return max(d0, d1);\n}\n\n// Difference of two signed distances\nfloat differenceOp(float d0, float d1) {\n    return max(d0, -d1);\n}\n\t\n// from http://www.iquilezles.org/www/articles/smin/smin.htm\n// polynomial smooth min (k = 0.1); \nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n/*\n---- Scene rendering ----\n*/\n\nfloat meshDist(in Ray ray) {\n    vec3 p = ray.origin;\n\n\tvec3 mp = p;\n    mp.xz = mod(p.xz, 1.)-0.5;\n    \n    Box b = Box(vec3(0, 2.5, 0), vec3(0.2), 0.02);\n    \n\tray.origin = vec3(mp.x, mp.y + (sin(p.z * kPI) * sin(p.x * kPI)) *0.5, 0.0);\n    ray.origin.y = abs(ray.origin.y);\n    \n\tfloat s1 = boxDist(ray, b);\n    \n    ray.origin = vec3(0.0, mp.y + (sin(p.x * kPI) * -sin(p.z * kPI)) * 0.5, mp.z);\n    ray.origin.y = abs(ray.origin.y);\n\tfloat s2 = boxDist(ray, b);\n\t\n    return unionOp(s1, s2);\n}\n\n// Get the distance to the scene (returns a struct containing distance and nearest material)\nSDResult sceneDist(in Ray ray) {\n    SDResult result;\n    float t = iTime ;\n    float floorDist = ray.origin.y+3.0;\n    \n    float glass = abs(differenceOp(\n        boxDist(ray, Box(vec3(0), vec3(4.5), 1.0)),\n        boxDist(ray, Box(vec3(0), vec3(2.5), 0.5))\n        ));\n    \n    float boundingBox = boxDist(ray, Box(vec3(0), vec3(4.5), 1.0));\n                                \n\tresult.d = meshDist(ray);\n    R(ray.origin.xy, kPI * 0.5);\n    result.d = smin(result.d, meshDist(ray), 0.2);\n    R(ray.origin.yz, kPI * 0.5);\n    result.d = smin(result.d, meshDist(ray), 0.2);\n    \n    result.d = intersectOp(result.d, boundingBox);\n    result.d = result.d + max(0.0, 0.2 - max(0.0, -boundingBox));\n    result.d = unionOp(result.d, (glass));\n    result.material = result.d == glass ? kGLASSMATERIAL : kMATTEMATERIAL;\n    result.d = unionOp(result.d, floorDist);\n    result.material = result.d == floorDist ? kMATTEMATERIAL : result.material;\n    return result;\n}\n\n// Gets the normal\nvec3 normal(in Ray ray) {\n    vec2 eps = vec2(0.0001, 0);\n    float baseDist = sceneDist(ray).d;\n \treturn normalize(vec3(\n        sceneDist(Ray(ray.origin + eps.xyy, ray.dir)).d - \n        sceneDist(Ray(ray.origin - eps.xyy, ray.dir)).d,\n        sceneDist(Ray(ray.origin + eps.yxy, ray.dir)).d -\n        sceneDist(Ray(ray.origin - eps.yxy, ray.dir)).d,\n        sceneDist(Ray(ray.origin + eps.yyx, ray.dir)).d -\n        sceneDist(Ray(ray.origin - eps.yyx, ray.dir)).d\n        ));\n}\n\n// Moves the ray to the surface. Helps avoid artefacts due to ray intersection imprecision.\nvoid clampToSurface(in Ray ray, in float d, inout vec3 n) {\n    for (int i=0; i<5; i++) {\n \t\tray.origin += n * d*0.5;\n \t\td = sceneDist(ray).d;\n \t\tn = normal(ray);\n    }\n}\n\n// Calulcate a fresnel term for reflections\nfloat fresnelTerm(in Ray ray, in vec3 n, in float power) {\n\tfloat fresnel = min(1., dot(ray.dir, n) + 1.0);\n\tfresnel = pow(fresnel, power);\n    return fresnel;\n}\n\n/*\n---- LIGHTING ----\n*/\n\n// Pretty background colour of some sort...\nvec3 backgroundColour (in Ray ray, in float divergence) {\n   // return vec3(1);\n    // Declare a horizon and extremity (either zenith or nadir)\n    vec3 base, extremity, texture;\n    float x = smoothstep(0.0,1.0,abs(ray.dir.y));\n   // base = mix(vec3(0.05, 0.1, 0.2), vec3(0.0), x);\n    \n    if (ray.dir.y >= 0.0) {\n        // sky: fake as hell clouds\n    \tbase = mix(kHORIZONCOLOUR, kZENITHCOLOUR, x);\n        texture = vec3(1);\n        float cloudFactor = 0.0;\n        \n        vec2 coord = ray.dir.xz / 8.0;\n        float scale = 1.0;\n        for (int i=0; i<4; i++) {\n            float offset = iTime * 0.03 / scale;\n            cloudFactor += texrand(coord + vec2(0, -offset), 3.0).r * scale;\n            coord *= 2.0;\n            scale *= 0.5;\n        }\n        cloudFactor /= 1.5;\n        vec3 cloud = mix(vec3(0.4), vec3(1), cloudFactor);\n        base = mix(base, cloud, cloudFactor * ray.dir.y * ray.dir.y);\n        \n    } else {\n        // ground: fake as hell desert\n        texture = kNADIRCOLOUR * 0.5;\n        vec2 floorCoord = floorPos(ray, -30.0) + vec2(0, iTime * 100.0);\n        texture *= (sin(floorCoord.x * .183 + floorCoord.y * 0.183 + sin(floorCoord.y * 0.3) * 0.5) \n                    + sin(floorCoord.x * .15 + floorCoord.y * 0.22 + sin(floorCoord.x * 0.26) * 0.5))\n            * 0.25 + 0.5;\n\t\tbase = mix(kHORIZONCOLOUR, kNADIRCOLOUR + texture, x);\n        \n    }\n    \n    \n    \n    return base;\n}\n\n// Technically broken, but seems to make soft shadows? *shrug*\nfloat occlusion(in Ray ray, in vec3 n) {\n    vec3 origin = ray.origin;\n    float o = 0.0;\n    ray.dir = n;\n    float x = eps*2.0;\n    origin += ray.dir * x;\n    for (float i=1.0; i<7.0; i++) {\n    \tray.origin = origin + ray.dir * x;\n        float d = sceneDist(ray).d;\n        o += max(x - d, 0.0) / x / i;\n        \n        x *= 4.0;\n    }\n \treturn 1.0 - o;\n}\n\nvec3 highlight(in Ray ray, in vec3 n) {\n    // sun\n\tvec3 sunDir = normalize(vec3(1,0.3,1));\n\tfloat sunDist = distance(sunDir, ray.dir)-0.00;\n\treturn mix(vec3(10,10,8), vec3(0), smoothstep(0.0, 0.2, sunDist));\n}\n\n/*\n---- RAY MARCHING ----\n*/\n\n// The main marching loop\nvoid marchRay(inout Ray ray, inout vec3 colour) {\n    bool inside = false; // are we inside or outside the glass object\n    vec3 impact = vec3(1); // This decreases each time the ray passes through glass, darkening colours\n\n    vec3 startpoint = ray.origin;\n    \n#ifdef DEBUG   \nvec3 debugColour = vec3(1, 0, 0);\n#endif\n    \n    SDResult result;\n    vec3 n;\n    vec3 glassStartPos;\n    \n    //float glow = 0.0;\n    \n    for (int i=0; i<kMAXITERS; i++) {\n        // Get distance to nearest surface\n        result = sceneDist(ray);\n        \n        //glow += result.material == kGLOWMATERIAL ? \n        //    pow(max(0.0, (80.0 - result.d) * 0.0125), 4.0) * result.d * 0.01\n        //    : 0.0;\n        \n        // Step half that distance along ray (helps reduce artefacts)\n        float stepDistance = (inside ? abs(result.d) * 0.5 : result.d*0.8);\n        ray.origin += ray.dir * stepDistance;\n        //if (length(ray.origin) > 40.0) { break; }\n        \n        if (stepDistance < eps) {\n            // colision\n            // normal\n            // Get the normal, then clamp the intersection to the surface\n    \t\tn = normal(ray);\n            //clampToSurface(ray, stepDistance, n);\n#ifdef DEBUG\n//debugColour = n;\n//break;\n#endif\n            \n            if ( result.material == kFLOORMATERIAL ) {\n                // ray hit floor\n                \n                // Add some noise to the normal, since this is pretending to be grit...\n                vec3 randomNoise = texrand(ray.origin.xz * 0.4, 0.0);\n                randomNoise.xz = randomNoise.xz * 2. - 1.;\n                n = mix(n, normalize(vec3(randomNoise.x, 1, randomNoise.y)), randomNoise.z * 0.3);\n                \n                // Colour is just grey with crappy fake lighting...\n                float o = occlusion(ray, n);\n                colour += vec3(1) * o * impact;\n                impact *= 0.;\n                break;\n            }\n            \n            if ( result.material == kMATTEMATERIAL ) {\n                // ray hit floor\n                \n#ifdef DEBUG\ndebugColour = vec3(0,1,0);\nbreak;\n#endif\n                // handle interior glass / other intersecion\n                if (inside) {\n                     float glassTravelDist =  min(distance(glassStartPos, ray.origin) / 16.0, 1.);\n    \t\t\t\tglassStartPos = ray.origin;\n                    // mix in the colour\n                \timpact *= mix(kGLASSCOLOUR, kGLASSCOLOUR * 0.1, glassTravelDist);\n                    impact *= 0.0;\n                    \n                }\n                \n                // Add some noise to the normal, since this is pretending to be grit...\n                vec3 randomNoise = texrand(n.xz * 0.5 + 0.5, 0.0);\n                randomNoise.xz = randomNoise.xz * 2. - 1.;\n               // n = mix(n, normalize(vec3(randomNoise.x, 1, randomNoise.y)), randomNoise.z * 0.1);\n                \n                // Colour is just grey with crappy fake lighting...\n                float o = occlusion(ray, n);\n                colour += vec3(1) * o * impact;\n                impact *= 0.;\n                break;\n            }\n            \n            if (result.material == kGLOWMATERIAL) {\n             \tcolour = mix(colour, kGLOWCOLOUR, impact);\n                impact *= 0.;\n                break;\n            }\n            \n            // check what material it is...\n            \n            if (result.material == kMIRRORMATERIAL) {\n                \n                // handle interior glass / other intersecion\n                if (inside) {\n                     float glassTravelDist =  min(distance(glassStartPos, ray.origin) / 16.0, 1.);\n    \t\t\t\tglassStartPos = ray.origin;\n                    // mix in the colour\n                \timpact *= mix(kGLASSCOLOUR, kGLASSCOLOUR * 0.1, glassTravelDist);\n                    \n                }\n                \n                // it's a mirror, reflect the ray\n                ray.dir = reflect(ray.dir, n);\n                    \n                // Step 2x epsilon into object along normal to ensure we're beyond the surface\n                // (prevents multiple intersections with same surface)\n                ray.origin += n * eps * 4.0;\n                \n                // Mix in the mirror colour\n                colour += highlight(ray, n);\n                impact *= kMIRRORCOLOUR;\n                float o = occlusion(ray, n);\n                impact *= o;\n#ifdef DEBUG\ndebugColour = vec3(o);\nbreak;\n#endif\n                \n            } else {\n                // glass material\n            \n                if (inside) {\n                \t// refract glass -> air\n                \tray.dir = refract(ray.dir, -n, 1.0/kREFRACT);\n                    \n                    // Find out how much to tint (how far through the glass did we go?)\n                    float glassTravelDist =  min(distance(glassStartPos, ray.origin) / 16.0, 1.);\n    \n                    // mix in the colour\n                \timpact *= mix(kGLASSCOLOUR, kGLASSCOLOUR * 0.1, glassTravelDist);\n                    \n#ifdef DEBUG\ndebugValue += glassTravelDist / 2.0;\n#endif\n      \n                \n              \t} else {\n                \n#ifdef DEBUG\ndebugColour = vec3(0,0,1);\n//break;\n#endif\n               \t\t// refract air -> glass\n                \tglassStartPos = ray.origin;\n                    \n              \t  \t// Mix the reflection in, according to the fresnel term\n                \tfloat fresnel = fresnelTerm(ray, n, 1.0);\n                    fresnel = fresnel;\n    \t\t\t\t/*\n                    colour = mix(\n                    \tcolour, \n                    \ttexture(iChannel1, reflect(ray.dir, n)), \n                    \tvec4(fresnel) * impact);\n*/\n                    colour = mix(\n                        colour,\n                        backgroundColour(ray, 0.0),\n                        vec3(fresnel) * impact);\n                \tcolour += n.x * 0.1;//highlight(ray, n);\n                    impact *= 1.0 - fresnel;\n    \t\t\t\n                \t// refract the ray\n            \t\tray.dir = refract(ray.dir, n, kREFRACT);\n                    \n#ifdef DEBUG\n//debugValue += 0.5;\n#endif\n                }\n            \n            \t// Step 2x epsilon into object along normal to ensure we're beyond the surface\n                ray.origin += (inside ? n : -n) * eps * 2.0;\n                \n                // Flip in/out status\n                inside = !inside;\n            }\n        }\n        \n        // increase epsilon\n        eps += divergence * stepDistance;\n    }\n    \n    // So far we've traced the ray and accumulated reflections, now we need to add the background.\n   // colour += texture(iChannel0, ray.dir) * impact;\n    ray.origin = startpoint;\n    colour.rgb += backgroundColour(ray, 0.0) * impact; // + glow * kGLOWCOLOUR;\n    \n#ifdef DEBUG\n//debugColour.rgb = ray.dir;\n//debugColour = vec3(float(debugStep)/2.0);\ncolour = debugColour;\n#endif\n}\n\n// Sets up a camera at a position, pointing at a target.\n// uv = fragment position (-1..1) and fov is >0 (<1 is telephoto, 1 is standard, 2 is fisheye-like)\nCamera setupCam(in vec3 pos, in vec3 target, in float fov, in vec2 uv) {\n\t\t// cam setup\n    // Create camera at pos\n\tCamera cam;\n    cam.pos = pos;\n    \n    // A ray too\n    Ray ray;\n    ray.origin = pos;\n    \n    // FOV is a simple affair...\n    uv *= fov;\n    \n    // Now we determine hte ray direction\n\tvec3 cw = normalize (target - pos );\n\tvec3 cp = vec3 (0.0, 1.0, 0.0);\n\tvec3 cu = normalize ( cross(cw,cp) );\n\tvec3 cv = normalize ( cross (cu,cw) );\n    \n\tray.dir = normalize ( uv.x*cu + uv.y*cv + 0.5 *cw);\n    \n    // Add the ray to the camera and our work here is done.\n\tcam.ray = ray;\n    \n    // Ray divergence\n    divergence = fov / iResolution.x;\n    \n\treturn cam;\n}\n\nvec3 camPath(in float time) {\n    \n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = mouse * kPI * 2.0 + kPI;\n    \n    vec3 camPos = vec3(0,-2.5,10);//vec3(sin(time * 0.3) * 2.0, sin(time * 0.1) * 2.0 + 4.0, time);\n\t\n    R(camPos.xz, time + mouse.x);\n    //R(camPos.zy, sin(time) * kPI * 0.1 + 0.2);\n    \n    return camPos;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // We'll need a camera. And some perspective.\n    \n\t// Get some coords for the camera angle from the frag coords. Convert to -1..1 range.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2. - 1.;\n    \n    // Aspect correction so we don't get oval bokeh\n    uv.y *= iResolution.y/iResolution.x;\n    \n    // Make a camera with ALL NEW AND IMPROVED! camera code :)\n    float camTime = iTime*.25;\n    vec3 camPos = camPath(camTime);\n    vec3 camTarget = vec3(0);//camPath(camTime + 1.0);\n    camTarget.y = 0.0;\n    //camTarget.y -= 3.0;\n    Camera cam = setupCam(camPos, camTarget, 0.4, uv);\n    \n    // Let's raymarch some stuff and inject that into the scene...\n    \n    // Create an empty colour\n    vec3 col = vec3(0);\n    \n    // Trace that ray!\n    marchRay(cam.ray, col);\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llcXzj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lldSRM", "name": "FlamingThing", "author": "dila", "description": "Kali-inspired twisted sculpture. Oh, and the flames? Just some glow taken from the last map() evaluation.", "tags": ["raymarch"], "likes": 16, "viewed": 381, "date": "1478797469", "time_retrieved": "2024-06-20T18:44:22.099069", "image_code": "mat2 rot(float x)\n{\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec3 mpos = vec3(0.0);\nfloat mid = 0.0;\n\nfloat map(vec3 p)\n{\n    vec3 q = p;\n    \n    q.y += sin(q.z * 0.125) * 3.0;\n    \n    q.x -= (sin(q.z * 0.25) * 0.5 + 0.5) * 3.0;\n    \n    q.xy *= rot(iTime);\n    \n    float u = 0.125;\n    q.z = (fract(q.z / u) - 0.5) * u;\n    \n    vec3 s = vec3(1.0, 0.125, 0.25);\n    \n    const int n = 4;\n    for (int i = 0; i < n; ++i) {\n        q.y = abs(q.y) - 0.5;\n        q.xy *= rot(3.14159 * 0.125);\n        q = abs(q) - 0.125;\n        q.xy *= rot(p.z * 0.5);\n    }\n    \n    mpos = p;\n    mid = 0.0;\n    float d = 8.0 - p.x;\n    \n    float k = sdBox(q, s);\n    \n    if (k < d) {\n    \td = k;\n        mpos = q * 10.0;\n        mid = 1.0;\n    }\n    \n    return d;\n}\n\nvec3 normal(vec3 p)\n{\n\tvec3 o = vec3(0.01, 0.0, 0.0);\n    return normalize(vec3(map(p+o.xyy) - map(p-o.xyy),\n                          map(p+o.yxy) - map(p-o.yxy),\n                          map(p+o.yyx) - map(p-o.yyx)));\n}\n\nfloat trace(vec3 o, vec3 r)\n{\n\tfloat t = 0.0;\n    for (int i = 0; i < 40; ++i) {\n\t\tt += map(o + r * t) * 0.7;\n    }\n    return t;\n}\n\nvec3 texturef(sampler2D channel, vec3 p)\n{\n    vec3 ta = texture(channel, p.xy).xyz;\n    vec3 tb = texture(channel, p.xz).xyz;\n    vec3 tc = texture(channel, p.zy).xyz;\n    return (ta * ta + tb * tb + tc * tc) / 3.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 o = vec3(-9.0, 0.0, iTime * 10.0);\n    vec3 r = normalize(vec3(uv, 1.0));\n    \n    r.xy *= rot(sin(iTime * 0.25) * 0.5);\n    r.xz *= rot(3.14159 * 0.5);\n    \n    float t = trace(o, r);\n    vec3 w = o + r * t;\n    vec3 sn = normal(w);\n    float fd = map(w);\n    float ao = map(w + sn * 1.2);\n    \n    vec3 lcol1 = vec3(1.0, 0.5, 0.25) * 2.0;\n    vec3 lcol2 = vec3(0.5, 1.0, 1.0);\n    \n    vec3 tex = vec3(0.0);\n    if (mid == 0.0) {\n    \ttex = texture(iChannel0, mpos.yz * 0.03).xyz;\n        tex *= tex;\n    } else {\n        tex = texturef(iChannel1, mpos * 0.05);\n        tex *= vec3(1.0, 0.5, 0.25);\n    }\n\n    vec3 lpos = o += vec3(-1.0, 8.0, -2.0);\n    vec3 ldel = w - lpos;\n    float ldist = length(ldel);\n    ldel /= ldist;\n    float lt = trace(lpos + sn * 0.5, ldel);\n    float lm = max(dot(ldel, -sn), 0.0);\n    lm /= (1.0 + ldist * ldist * 0.001);\n    if (lt < ldist) {\n        lm *= 0.25;\n    }\n    \n    if (mid == 1.0) {\n        vec3 ref = reflect(ldel, sn);\n    \tfloat spec = max(dot(r, -ref), 0.0);\n    \tspec = pow(spec, 2.0);\n        lcol1 *= 1.0 + spec;\n    \tlcol2 *= 1.0 + spec;\n    }\n    \n    vec3 lit = vec3(lm) * lcol2 + lcol1 * (sn.y * 0.5 + 0.5);\n    \n    float edge = 1.0 - 1.0 / (1.0 + fd * 100.0);\n    \n    vec3 fc = mix(lit * tex, lcol1, edge) * ao;\n    \n\tfragColor = vec4(sqrt(fc), 1.0);\n}", "image_inputs": [{"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}, {"id": "XdXGzr", "previewfilepath": "/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lldSRM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lldSWN", "name": "K-Tower", "author": "woronoi", "description": "Scherk towers. DE stuff by DarkBeam (fractalforums.com)", "tags": ["scherk", "minimalsurfaces"], "likes": 14, "viewed": 624, "date": "1479759723", "time_retrieved": "2024-06-20T18:44:23.038497", "image_code": "float kTower(vec3 p)\n{\n    float z = p.z;\n    float t=1.5*atan(p.y,p.x);\n    float u=sqrt(p.x*p.x+p.y*p.y);\n    float x=sin(t)*u;\n    float y=cos(t)*u;\n    float ex=exp(x);\n    float ey=exp(y);\n    float zz=ex*ey;\n    float n=ex*ex+ey*ey;\n    float d=1.0+zz*zz;\n    zz=4.0*sin(p.z)*zz;\n    if (zz>0.0) n=n+zz; else d=d-zz;\n    return abs(log(n/d))-0.05;\n}\n\nvec2 map( in vec3 p )\n{\n    float s = 0.4;\n    float d2= cos(s*p.x)*sin(0.5*s*p.y)*cos(s*p.z);\n    float d1 = kTower(p);\n    return vec2(d1+d2,length(p));\n}\n\n\nvec2 castRay(in vec3 ro, in vec3 rd)\n{\n\tconst float MAX_DIST = 60.0;\n\tconst float MIN_DIST = 0.0002;\n\tconst float NONE = -1.0;\n\n\tfloat t = 0.0;\n\tvec2 res = vec2(-1.0);\n\tvec2 h = vec2(1.0);\n\tfloat overstep = 0.0;\n\tfloat phx = MAX_DIST;\n\n\tfor (int i = 0; i < 100; i++)\n\t{\n\t\tif (h.x < MIN_DIST || t > MAX_DIST)\n\t\t\tbreak;\n\n\t\th = map(ro + rd * t);\n\n\t\tif (h.x > overstep)\n\t\t{\n\t\t\toverstep = h.x * min(1.0, 0.5 * h.x / phx);\n\t\t\tt += h.x * 0.3 + overstep;\n\t\t\tphx = h.x;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tt -= overstep;\n\t\t\tphx = MAX_DIST;\n\t\t\th.x = 1.0;\n\t\t\toverstep = 0.0;\n\t\t}\n\n\t\tres = vec2(t, h.y);\n\t}\n\n\tif (t > MAX_DIST)\n\t\tres = vec2(NONE);\n\n\treturn res;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) + rd.y * 0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n\t\t\n        if( m<1.5 )\n        {\n            \n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.4 + 0.1*f*vec3(1.0);\n        }\n\n        // lighitng        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.20*dif*vec3(1.00,0.85,0.55);\n\t\tlin += 1.20*spe*vec3(1.00,0.85,0.55)*dif;\n        lin += 0.20*amb*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*dom*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.002*t*t ) );\n\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\t\t \n\tfloat time = 15.0 + iTime;\n\n\t// camera\t\n\tvec3 ro = vec3(4.0*cos(time), -1.0, 8.0*time + 8.0 );\n    vec3 ta = vec3( 0.0, 0.0, 0.5 * ro.z ) + ro;\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, time*0.2 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n\tcol = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lldSWN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lldSzn", "name": "Stellated octahedron", "author": "decrooks", "description": "Stellated octahedron as the sum of dual tetrahedra.", "tags": ["raymarching", "sdf", "tetrahedron", "octahedron", "stellated"], "likes": 16, "viewed": 505, "date": "1478018566", "time_retrieved": "2024-06-20T18:44:25.741750", "image_code": "// Created by David Crooks\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define TWO_PI 6.283185\n#define PI 3.14159265359\n\nstruct Ray {\n   vec3 origin;\n   vec3 direction;\n};\n\nstruct LightColor {\n\tvec3 diffuse;\n\tvec3 specular;\n};\n    \n    \nstruct Material {\n    LightColor  color;\n    float shininess;\n    float mirror;\n    float refractiveIndex;\n    float opacity;  \n};\n    \n    \nstruct MapValue {\n    float \t  signedDistance;\n    Material  material;\n};\n\nstruct Trace {\n    float    dist;\n    vec3     p;\n    vec3 normal;\n    Ray \t ray;\n    Ray reflection;\n\n    Material material;\n    bool hit;\n};\n    \n\nstruct PointLight {\n    vec3 position;\n    LightColor color;\n};\n    \nstruct DirectionalLight {\n    vec3 direction;\n    LightColor color;\n};\n    \nPointLight  light1,light2,light3;\nDirectionalLight dirLight;\n\nMaterial blackMat,whiteMat,bluishMat,yellowMat,oscMat,tableMat,tableDarkMat;\n\nvec3 rayPoint(Ray r,float t) {\n \treturn r.origin +  t*r.direction;\n}\n\nMapValue intersectObjects( MapValue d1, MapValue d2 )\n{\n    if (d1.signedDistance>d2.signedDistance){\n    \treturn    d1 ;\n    }\n    else {\n        d2.material = d1.material;\n    \treturn d2;\n    }\n}\n\nMapValue addObjects(MapValue d1, MapValue d2 )\n{\n    if (d1.signedDistance<d2.signedDistance) {\n    \treturn    d1 ;\n    }\n    else {\n    \treturn d2;\n    }\n}\n\n\nMapValue subtractObjects( MapValue A, MapValue B )\n{\n    //A-B\n    if (-B.signedDistance>A.signedDistance){\n        B.signedDistance *= -1.0;\n        B.material = A.material;\n    \treturn    B ;\n    }\n    else {\n       \n    \treturn A;\n    }\n}\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  \n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n\n//sdCapsule by iq\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nMapValue plane(vec3 p, vec3 origin, vec3 normal , Material m ){\n    vec3 a = p - origin;\n    MapValue mv;\n    mv.material = m;\n\n    mv.signedDistance = dot(a,normal);\n    return mv;\n}\n\nfloat  plane(vec3 p, vec3 origin, vec3 normal){ \n\treturn dot(p - origin,normal);   \n}\n\n\nfloat tetrahedron(vec3 p, float d) {\n    \n    float dn =1.0/sqrt(3.0);\n\n\n    float mv1 = plane(p,vec3(d,d,d) ,vec3(-dn,dn,dn)) ; \n    float mv2 = plane(p,vec3(d,-d,-d) ,vec3(dn,-dn,dn)) ;\n    float mv3 = plane(p,vec3(-d,d,-d) ,vec3(dn,dn,-dn)) ;\n    float mv4 = plane(p,vec3(-d,-d,d) ,vec3(-dn,-dn,-dn)) ;\n\n\n    //max intersects shapes\n    //So this is the intersection of four planes.\n    return max(max(mv1,mv2),max(mv3,mv4));\n}\n\n\n\n\nfloat octahedron(vec3 p,  float d) {\n  \n    float mv = tetrahedron(p,d);\n    float mv2 = tetrahedron(-p,d);\n\n    return  max(mv,mv2); \n}   \n\nfloat stellatedOctahedron(vec3 p,  float d) {\n  \n    float mv = tetrahedron(p,d);\n    float mv2 = tetrahedron(-p,d);\n\t\n    //The stellated Octahedron is \n    return  min(mv,mv2); \n}   \n\n\nbool tileing(vec2 point)\n{\n    float t = iTime;\n    float h = sqrt(3.0)/2.0;\n   \tvec3 u = vec3(1.0,-0.5,-0.5);\n   \tvec3 v = vec3(0,h,-h);\n    \n    vec3 n = vec3(0.5);\n    \n    float scaleFactor = 5.0;\n    vec2 q = point*scaleFactor + 0.3*iTime;\n    vec3 p = n + q.x*u +q.y*v;\n    \n    p = floor(p);\n    \n    float i = p.x + p.y + p.z;\n    float j = p.x  + p.y;\n    float k = p.x  + p.z;\n    \n    float a = mod(i,2.0);\n    float b = mod(j,2.0);\n    float c = mod(k,2.0);\n        \n    if (a>0.1)\n    {\n        return false;\n    }\n    else {\n        if(b>0.1){\n           if(c>0.1){\n            \treturn false;\n        \t}\n        \telse {\n            \treturn true;\n        \t} \n        }\n        else {\n        \treturn true;\n        }\n    }\n}\n\n\n\nbool octTileing3d(vec2 point)\n{\n    //This pattern takes a slice through a grid of stellated octahedron.\n    //I'm fairly sure there are much more effiecient ways to draw this tiling - e.g. with alternating cubes.\n    //But I think its interesting to use the geomtry of the stellated octahedron.\n    \n    float t = iTime;\n    float h = sqrt(3.0)/2.0;\n   \tvec3 u = vec3(1.0,-0.5,-0.5);\n   \tvec3 v = vec3(0,h,-h);\n    \n    vec3 n = vec3(0.5);\n    float scaleFactor = 2.5;\n    vec2 q = point*scaleFactor;\n    vec3 p = n + q.x*u +q.y*v;\n    \n    vec3 w = mod(p,1.0);\n    w = 2.0*w - vec3(1.0);\n    \n    float o1 = octahedron(w,1.0);\n    float o2 = octahedron(w,0.8);\n    float so1 = stellatedOctahedron(v,1.0);\n    \n    if(o1>0.0){\n        //outside octahedron o1\n        if(so1>0.0){\n            //outside stellatedOctahedron\n            return true;\n        }\n        else{\n            //inside stellatedOctahedron\n           return false; \n        }  \n    }else{\n        //inside octahedron o1\n        if(o2>0.0){\n            //outside octahedron o2\n            return true;\n        }\n        else{\n            //inside octahedron o2\n            return false;\n        }\n    }\n}\n\nMapValue xzPlane( vec3 p ,float y, Material m)\n{\n    MapValue mv;\n    mv.material = m;\n    mv.signedDistance = p.y - y;\n    return mv;\n}\n\n#define USE_OCTAHEDRAL_PATTERN false\n\nMapValue tableTop( vec3 p ,float y, Material m1,Material m2)\n{\n \tMaterial  m;\n    //Draw a pattern on the table top by taking a 2d slice through a 3d checkerboard.\n   \n    bool patternValue;\n    \n    if(USE_OCTAHEDRAL_PATTERN){\n        //This is slow, but its nice that the pattern is based on the geometry of the stellated octahedron. \n        patternValue = octTileing3d(p.xz);\n    }\n    else {\n        //Similar pattern, but faster.\n        patternValue = tileing(p.xz);\n    }\n    \n    if(patternValue){\n        m = m1;\n    }\n    else {\n       m = m2 ;\n    }\n    \n  return xzPlane( p ,y, m);\n}\n\n\n\nMapValue cubeFrame(vec3 p, float d,float thickness, Material m){\n    \n    MapValue mv;\n    mv.material = m;\n\n    float r = d*thickness;\n    float dt = sdCapsule(  p, vec3(d,d,d),vec3(-d,d,d), r );\n    \n    //min adds shapes\n    dt = min(dt,  sdCapsule(  p, vec3(-d,d,d),vec3(-d,-d,d), r ));\n    dt = min(dt,  sdCapsule(  p, vec3(-d,-d,d),vec3(d,-d,d), r ));\n    dt = min(dt,  sdCapsule(  p, vec3(d,-d,d),vec3(d,d,d), r ));\n\n    dt = min(dt,  sdCapsule(  p, vec3(d,d,-d),vec3(-d,d,-d), r ));\n    dt = min(dt,  sdCapsule(  p, vec3(-d,d,-d),vec3(-d,-d,-d), r ));\n    dt = min(dt,  sdCapsule(  p, vec3(-d,-d,-d),vec3(d,-d,-d), r ));\n    dt = min(dt,  sdCapsule(  p, vec3(d,-d,-d),vec3(d,d,-d), r ));\n\n    dt = min(dt,  sdCapsule(  p, vec3(d,d,-d),vec3(d,d,d), r ));\n    dt = min(dt,  sdCapsule(  p, vec3(-d,d,-d),vec3(-d,d,d), r ));\n    dt = min(dt,  sdCapsule(  p, vec3(-d,-d,-d),vec3(-d,-d,d), r ));\n    dt = min(dt,  sdCapsule(  p, vec3(d,-d,-d),vec3(d,-d,d), r ));\n\n    mv.signedDistance = dt;\n\n    return mv;\n}\n\n\nMapValue stellatedOctahedron(vec3 p,float d, Material m) {\n  return MapValue(stellatedOctahedron(p,d),m); \n}\n\nvec3 orbit(float t){\n    return vec3(sin(t),0.0,cos(t));\n}\n\nvoid setMaterials() {\n    vec3 specular = vec3(1.0); \n    float shininess = 16.0;\n    whiteMat = Material(LightColor(0.95*vec3(1.0,1.0,1.0),0.3*vec3(1.0,1.0,1.0)) ,shininess ,0.75,1.0,1.0);\n    tableDarkMat = Material(LightColor(vec3(0.2,0.2,0.35),vec3(0.33,0.33,0.31)) ,shininess ,0.75,1.0,1.0);   \n}\n\n///////////////////////////////////////////////////////////////\n//------------------- Map the scene -------------------------//\n\n\nMapValue map(vec3 p){\n    \n   float t  = iTime;\n   mat3 rotate = rotationMatrix(orbit(0.2*t),0.67*t);\n   vec3 q = rotate*p;\n    \n   MapValue objects = stellatedOctahedron(q,0.5,whiteMat);\n   //Add a frame to show how the stellated octahedron is embedded in a cube\n   objects = addObjects(objects,cubeFrame(q,0.5,0.04,whiteMat));\n   //patterned tabletop\n   objects = addObjects(objects,tableTop(p,-1.0,whiteMat,tableDarkMat));\n   //add a  roof to reflect off\n   objects = addObjects(objects,xzPlane(-p,-2.0,whiteMat));\n    \n   return objects;\n}\n\n////////////////////////////////////////////////////////////\n//------------------- Raytracing -------------------------//\n\n\nvec3 calculateNormal(vec3 p) {\n    float epsilon = 0.001;\n    \n    vec3 normal = vec3(\n                       map(p +vec3(epsilon,0,0)).signedDistance - map(p - vec3(epsilon,0,0)).signedDistance,\n                       map(p +vec3(0,epsilon,0)).signedDistance - map(p - vec3(0,epsilon,0)).signedDistance,\n                       map(p +vec3(0,0,epsilon)).signedDistance - map(p - vec3(0,0,epsilon)).signedDistance\n                       );\n    \n    return normalize(normal);\n}\n\n\nTrace castRay(in Ray ray, float maxDistance){\n    float dist = 0.01;\n    float presicion = 0.001;\n\tvec3 p;\n    MapValue mv;\n    bool hit = false;\n    for(int i=0; i<64; i++){\n    \tp = rayPoint(ray,dist);\n       \tmv = map(p);\n         dist += 0.5*mv.signedDistance;\n        if(mv.signedDistance < presicion)\n        {\n          hit = true; \n            break;\n        } \n         if(dist>maxDistance) break;\n       \n    }\n    return Trace(dist,p,p,ray,ray,mv.material,hit);\n}\n\nTrace traceRay(in Ray ray, float maxDistance) {\n    Trace trace = castRay(ray,maxDistance);\n    trace.normal = calculateNormal(trace.p);\n    trace.reflection = Ray(trace.p,reflect(ray.direction, trace.normal));\n\n    return trace;\n}\n\nfloat castShadow(in Ray ray, float dist){\n    Trace trace = castRay(ray,dist);\n    float maxDist = min(1.0,dist);\n    float result = trace.dist/maxDist;\n   \n    return clamp(result,0.0,1.0);\n}\n\nRay cameraRay(vec3 viewPoint, vec3 lookAtCenter, vec2 p , float d){ \n\tvec3 v = normalize(lookAtCenter -viewPoint);\n    \n    vec3 n1 = cross(v,vec3(0.0,1.0,0.0));\n    vec3 n2 = cross(n1,v);  \n        \n    vec3 lookAtPoint = lookAtCenter + d*(p.y*n2 + p.x*n1);\n                                    \n    Ray ray;\n                    \n    ray.origin = viewPoint;\n   \tray.direction =  normalize(lookAtPoint - viewPoint);\n    \n    return ray;\n}\n\nvec3 diffuseLighting(in Trace trace, vec3 lightColor,vec3 lightDir){\n    float lambertian = max(dot(lightDir,trace.normal), 0.0);\n  \treturn  lambertian * trace.material.color.diffuse * lightColor; \n}\n\n\n\nvec3 cookTorranceSpecularLighting(in Trace trace, vec3 lightColor,vec3 L){\n    //https://en.wikipedia.org/wiki/Specular_highlight#Cook.E2.80.93Torrance_model\n    //https://renderman.pixar.com/view/cook-torrance-shader\n    \n    vec3 V = -trace.ray.direction;\n\n    vec3 H = normalize(L + V);\n    \n    float NdotH = dot(trace.normal, H);\n    float NdotV = dot(trace.normal, V);\n    float VdotH = dot(V ,H );\n    float NdotL = dot(trace.normal , L);\n    \n    float lambda  = 0.25;\n    float F = pow(1.0 + NdotV, lambda);\n    \n    float G = min(1.0,min((2.0*NdotH*NdotV/VdotH), (2.0*NdotH*NdotL/VdotH)));\n    \n    \n   // Beckmann distribution D\n    float alpha = 5.0*acos(NdotH);\n    float gaussConstant = 1.0;\n\tfloat D = gaussConstant*exp(-(alpha*alpha));\n    \n    \n    float c = 1.0;\n    float specular = c *(F*D*G)/(PI*NdotL*NdotV);\n    \n    \n    return specular * trace.material.color.specular * lightColor;\n}\n\n\n\n\nvec3 pointLighting(in Trace trace, PointLight light){\n    vec3 lightDir = light.position - trace.p;\n\tfloat d = length(lightDir);\n  \tlightDir = normalize(lightDir);\n   \n  \tvec3 color =  diffuseLighting(trace, light.color.diffuse, lightDir);\n\n    color += cookTorranceSpecularLighting(trace, light.color.specular, lightDir);\n\n    float  attenuation = 1.0 / (1.0 +  0.1 * d * d);\n    float shadow = castShadow(Ray(trace.p,lightDir),d);\n    color *= attenuation*shadow;\n    return  color;\n}\n\nvec3 directionalLighting(Trace trace, DirectionalLight light){\n\n    vec3 color =  diffuseLighting(trace, light.color.diffuse, light.direction);\n    \n    color += cookTorranceSpecularLighting(trace, light.color.specular, light.direction);\n    \n    float shadow = castShadow(Ray(trace.p,light.direction),3.0);\n    color *= shadow;\n    return  color;\n}\n\n\nvoid setLights(){\n  \tfloat  time = iTime;\n    vec3 specular = vec3(1.0);\n  \tlight1 = PointLight(vec3(cos(1.3*time),1.0,sin(1.3*time)),LightColor( vec3(1.0),specular));\n  \tlight2 = PointLight(vec3(0.7*cos(1.6*time),1.1+ 0.35*sin(0.8*time),0.7*sin(1.6*time)),LightColor(vec3(1.0),specular)); \n  //  light3 = PointLight(vec3(1.5*cos(1.6*time),0.15+ 0.15*sin(2.9*time),1.5*sin(1.6*time)),LightColor(vec3(0.6),specular));\n    //dirLight = DirectionalLight(normalize(vec3(0.0,1.0,0.0)),LightColor(vec3(0.1),vec3(0.5)));\n} \n\n\nvec3 lighting(in Trace trace){\n    vec3 color = vec3(0.01,0.01,0.1);//ambient color\n        \n\tcolor += pointLighting(trace, light1);\n\tcolor += pointLighting(trace, light2) ;\n   // color += pointLighting(trace, light3) ;\n\t//color += directionalLighting(trace, dirLight);\n    \n    return color;\n}\n\n\n\n\n\nvec3 render(vec2 p){\n    vec3 viewpoint = vec3(-1.0,1.7,-2.3);\n    \n    vec3 lookAt = vec3(0.0,-0.1,0.0);\n    \n  \tRay ray = cameraRay(viewpoint,lookAt,p,2.4);\n    vec3 color = vec3(0.0);\n    float frac = 1.0;\n   \n    float d = 0.0;\n    float maxDistance = 10.0;\n    for(int i = 0; i<3; i++) {\n        Trace trace = traceRay(ray,maxDistance);\n        \n \t\tif(i==0) d = trace.dist;\n        maxDistance -= trace.dist;\n    \tcolor += lighting(trace)*(1.0 - trace.material.mirror)*frac;\n        if(!trace.hit) break;\n        \n        frac *= trace.material.mirror;\n        if(frac < 0.1 || maxDistance<0.0) break;\n        ray = trace.reflection;\n    }\n\n   \treturn color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n    \n  \tsetLights();\n    setMaterials();\n    \n   \tvec3 colorLinear =  render(p);\n    float screenGamma = 2.2;\n    vec3 colorGammaCorrected = pow(colorLinear, vec3(1.0/screenGamma));\n\tfragColor = vec4(colorGammaCorrected,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lldSzn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lldXRB", "name": "Relax : Night Shader Edition", "author": "Canilho", "description": "Self Learning study, based on Inigo Quilez work. \nBig thanks to him. \nOriginal music track created by me. \nMore Sounds at https://soundcloud.com/canilho", "tags": ["shader3d"], "likes": 17, "viewed": 587, "date": "1480389866", "time_retrieved": "2024-06-20T18:44:25.747981", "image_code": "// This was a self learning study of an animation of\n\t// inigo quilez \n\t// Big thanks for the inspiration\n\t// https://www.shadertoy.com/view/ldXXDj\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat fbm( vec2 p )\n{\n    return 0.5000*texture( iChannel0, p*1.00 ).x + \n           0.2500*texture( iChannel0, p*2.02 ).x + \n           0.1250*texture( iChannel0, p*4.02 ).x + \n           0.0675*texture( iChannel0, p*8.02 ).x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = mod( iTime, 458.0 );\n\tvec2 p = (-iResolution.xy+2.0*fragCoord.xy) / iResolution.y;\n    vec2 i = p;\n\n    // camera\n    p += vec2(1.0,3.0)*0.002*2.0*cos( iTime*2.0 + vec2(0.0,1.5) );    \n    p += vec2(1.0,3.0)*0.001*1.0*cos( iTime*5.0 + vec2(1.0,4.5) );    \n    p *= 0.95 + 0.05*length(p);\n    float an = 0.03*sin( 0.1*time );\n    float co = cos(an);\n    float si = sin(an);\n    p = mat2( co, -si, si, co )*p;\n    \n    // water\n    vec2 q = vec2(p.x,1.0)/p.y;\n    q.y -= 0.3*time;    \n    vec2 off = texture( iChannel0, 0.5*(mod(time*0.0001,2.0))*q*vec2(1.0,2.0) - vec2(0.0,0.007*time) ).xy;\n    q += 0.4*(-1.0 + 5.0*off);\n    vec3 col = texture( iChannel0, 0.8*q*(mod(time*0.001,2.0)) *vec2(.5,8.0) + vec2(0.0,0.01*time) ).zyx;\n    col *= 0.4;\n    float re = 1.0-smoothstep( 0.0, 0.7, abs(p.x-0.6) - abs(p.y)*0.3+0.2 );\n    col += 1.0*vec3(1.0,0.9,0.73)*re*0.2*off.y*5.0*(1.0-col.x);\n    float re2 = 1.0-smoothstep( 0.0, 2.0, abs(p.x-0.6) - abs(p.y)*0.85 );\n\n    \n    // sky\n    vec3 sky = vec3(0.01,0.03,0.1);\n    // stars    \n    sky += 0.8*smoothstep( 0.90,1.0,texture( iChannel3, 2.5*p+time*0.03 ).x);\n    sky += 0.4*smoothstep( 0.50,1.0,texture( iChannel3, 2.5*p+time*0.1 ).y);\n    sky += 0.3*pow(abs(0.5-max(0.0,p.y)),5.0);\n    \n    // clouds    \n    float f = fbm( 0.002*vec2(p.x,1.0)/p.y );\n    vec3 cloud = vec3(0.3,0.4,0.5)*0.7*(1.0-0.85*sqrt(smoothstep(0.4,1.0,f)));\n    sky = mix( sky, cloud, 0.95*smoothstep( 0.4, 0.6, f ) );\n    sky = mix( sky, vec3(0.33,0.34,0.35), pow(1.0-max(0.0,p.y),2.0) );\n    col = mix( col, sky, smoothstep(0.0,0.1,p.y) );\n\n    // moon\n    \t// position\n        float d = length(p-vec2(0.58,0.5));\n    \n        float g = .8 - smoothstep( 0.2, 0.21 , d-0.010*time*0.05 );\n        float moontex = 0.8+0.2*smoothstep(0.25,0.7,fbm(0.06*p));\n        vec3 moon = vec3(1.0,0.97,0.9);\n    \n        col += moon*exp(-2.*d);\n      \n        col = mix( col, moon*moontex, g );\n    \n    // horizon\n    col += 0.2*cos(time/120.0)*pow(clamp(1.0-abs(p.y),0.0,1.0),9.0);\n    \n    // postprocess\n    col *= 1.4;\n    col = pow( col, vec3(1.5,1.2,1.0) );    \n    col *= clamp(1.0-0.3*length(i), 0.0, 1.0 );\n\n    // fade \n    \t// Initial fade from  0 to 4 seconds\n    \tcol *=       smoothstep(  0.0,  4.0, time );\n    \t// End song 443 seconds + 4 seconds of fade\n\t    col *= 1.0 - smoothstep( 443.0, 447.0, time );\n\n    fragColor = vec4( col, 2.0 );\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "MsS3D1", "previewfilepath": "https://soundcloud.com/canilho/relax", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/canilho/relax", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lldXRB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lltSDN", "name": "Mighty Morphin Somethin Somethin", "author": "GeekyMcGeekface", "description": "Just learning and messing with SDFs.", "tags": ["procedural", "sdf"], "likes": 3, "viewed": 104, "date": "1479765006", "time_retrieved": "2024-06-20T18:44:27.226858", "image_code": "/**\n * Part 2 Challenges\n * - Change the diffuse color of the sphere to be blue\n * - Change the specual color of the sphere to be green\n * - Make one of the lights pulse by having its intensity vary over time\n * - Add a third light to the scene\n */\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\n/**\n * Signed distance function for a sphere centered at the origin with radius 1.0;\n */\nfloat sphereSDF(vec3 samplePoint) {\n    return length(samplePoint) - 1.0;\n}\n\nfloat sphereSDF(vec3 samplePoint, float r) {\n    return length(samplePoint) - r;\n}\n\nfloat sphereSDF(vec3 samplePoint, vec3 posSphere, float r) {\n    return length(samplePoint - posSphere) - r;\n}\n\nfloat udRoundBox( vec3 p, vec3 size, float r )\n{\n  return length(max(abs(p) - size, 0.0)) - r;\n}\n\nfloat udRoundBox( vec3 p, vec3 size, vec3 pos, float r )\n{\n  return length(max(abs(p - pos) - size, 0.0)) - r;\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\n/**\n * Constructive solid geometry intersection operation on SDF-calculated distances.\n */\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\n\n/**\n * Constructive solid geometry difference operation on SDF-calculated distances.\n */\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n\n/**\n * Constructive solid geometry difference operation on SDF-calculated distances.\n */\nfloat weirdSDF(float distA, float distB) {\n    return mix(distA, distB, sin(iTime) + 1.0);\n}\n\n// polynomial smooth min (k = 0.1);\nfloat sdfBlend( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n    \n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {\n\n\n//    float box = udRoundBox( samplePoint, vec3(1.2, 0.2, 0.5), 0.1 );\n    float box = udRoundBox( samplePoint,\n                           \tvec3(1.2, 0.2, 0.5),\n                           vec3(sin(iTime*1.8 + 0.2) * 0.3, cos(iTime + 0.2) * 0.45, 0.0),\n                           0.2 );\n\n    float sphere = sphereSDF(samplePoint,\n                             vec3(sin(iTime + 0.7) * 0.6, cos(iTime*2.2 + 0.17) * 0.2, 0.0),\n                             0.6 + (sin(iTime*3.0)*0.3));\n\n    float sphere2 = sphereSDF(samplePoint,\n                             vec3(cos(iTime*1.4 + 1.7) * 0.55, sin(iTime*2.8 + 3.17) * 0.3, 0.4),\n                             0.5 + (sin(iTime*3.0)*0.2));\n\n//    float blend1 = sdfBlend(box, sphere, 0.2);\n//    float blend2 = sdfBlend(blend1, sphere2, 0.2);\n\n//    float blend1 = unionSDF(box, sphere );\n//    float blend2 = unionSDF(blend1, sphere2 );\n//    float blend1 = intersectSDF(box, sphere );\n//    float blend2 = intersectSDF(blend1, sphere2 );\n//    float blend1 = differenceSDF(box, sphere );\n//    float blend2 = differenceSDF(blend1, sphere2 );\n    float blend1 = weirdSDF(box, sphere );\n    float blend2 = sdfBlend(blend1, sphere2, 0.2 );\n\n    \n    return( blend2 );\n    \n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n//    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n//    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n//    vec3 color = ambientLight * k_a;\n\n    vec3 color = k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n//    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    vec3 light1Intensity = vec3(0.5, 0.5, 0.5);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n//    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    vec3 light2Intensity = vec3(0.5, 0.5, 0.5);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.0, 5.0);\n    float dist = shortestDistanceToSurface(eye, dir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * dir;\n    \n    // =================================================================================================\n    // =================================================================================================\n#define WITH_A_DASH_OF_PLASMA\n\n#ifdef WITH_A_DASH_OF_PLASMA\n    vec2 fragPos = fragCoord;\n    \n    float t = iTime / 2.;\n//    U = 8.* U / iResolution.xy - 4.;\n    fragPos = 2.* fragPos / iResolution.xy - 1.;\n    vec3 U = vec3(fragPos, fragPos.x * fragPos.y );\n\n    \n    for (int i=0; i<8; i++)\n    \tU += cos( U.yxz * 3. + vec3(t,1.6,t*0.3)) / 3.,\n    \tU += sin( U.zxy + t  + vec3(1.6,0.,t*0.7)) / 2.,\n    \tU *= 1.2;\n    \n\n//\to.xyz += abs(mod(U,16.) / 16.);\n#endif\n\n    // =================================================================================================\n    // =================================================================================================\n    \n    vec3 K_a = vec3(0.15, 0.15, 0.15);\t\t// Material Ambient color\n    vec3 K_d = vec3(1.0, 0.9, 0.8);\t\t// Material Diffuse color\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\t\t// Material Specular color (components > 1 are ok!)\n    float shininess = 25.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n\n#ifdef WITH_A_DASH_OF_PLASMA\n\tcolor *= abs(mod(U, 16.) / 16.);\n#endif    \n\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lltSDN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lltXD4", "name": "Ripple noise", "author": "Mr_F", "description": "Wavy noise experiments", "tags": ["noise", "wave", "water", "normalmap", "heightmap", "bump", "ripple"], "likes": 39, "viewed": 1748, "date": "1479739901", "time_retrieved": "2024-06-20T18:44:27.814788", "image_code": "const float hardness = 0.1;\nconst int iterations = 4;\nconst float speed = 1.5;\nconst float intensity = 1.0;\n\n// Slow, but more octaves\n#define COMPLEX\n\n//#define TILED\n\n\n// Hash function from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\nvec4 hash43(vec3 p)\n{\n    vec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nfloat drip(vec2 uv, vec2 pos, float age, float scale, float cells) {\n    vec2 vD = vec2 (uv - pos);\n    float fD = sqrt(dot (vD, vD)) * 2.0 * (cells/16.0);\n    float fDa = 10.0 * fD;\n    float freq = 300.0 * scale;\n    return    max (0.0, 1.0 - fDa*fDa)\n            * sin ((fD*freq - age*40.0*(scale*2.0-1.0))*hardness);\n}\n\n// Based on texture bombing: http://http.developer.nvidia.com/GPUGems/gpugems_ch20.html\nfloat drops(vec2 uv, float cells) {\n    float height = 0.0;\n    vec2 cell = floor(uv * cells);\n    for(int iter=0; iter<iterations; iter++) {\n        for(int i = -1; i <= 1; i++) {\n          for(int j = -1; j <= 1; j++) {\n            vec2 cell_t = cell + vec2(i, j);\n            vec2 uv_t = uv;\n #ifdef TILED\n              // could be simplified...\n              if (cell_t.x<0.0) {\n                  cell_t.x += cells;\n                  uv_t.x += 1.0;\n              } else if (cell_t.x>cells-1.0) {\n                  cell_t.x -= cells;\n                  uv_t.x -= 1.0;\n              }\n              \n              if (cell_t.y<0.0) {\n                  cell_t.y += cells;\n                  uv_t.y += 1.0;\n              } else if (cell_t.y>cells-1.0) {\n                  cell_t.y -= cells;\n                  uv_t.y -= 1.0;\n              }\n #endif\n            vec4 rnd_t = hash43(vec3(cell_t, float(iter)));\n            vec2 pos_t = (cell_t+rnd_t.xy)/cells;\n            float age_t = (iTime*speed + rnd_t.z);\n            float scale_t = rnd_t.w;\n            height += drip(uv_t, pos_t, age_t, scale_t, cells);\n          }\n        }\n    }\n    return height;\n}\n\nfloat heightmap(vec2 uv) {\n    float height = 0.0;\n #ifdef COMPLEX\n    height += drops(uv, 32.0);\n    height += drops(uv, 16.0);\n    height += drops(uv, 8.0);\n    height += drops(uv, 4.0);\n    height += drops(uv, 2.0);\n    height /= 8.0;\n #else\n    height += drops(uv, 8.0);\n    height += drops(uv, 4.0);\n    height /= 5.0;\n #endif\n    return height * intensity;\n}\n\nvec2 dudvmap(vec2 uv) {\n    const float eps = 0.01;\n    vec2 offset = vec2(eps, 0.0);\n    return vec2(\n        heightmap(uv+offset.xy) - heightmap(uv-offset.xy),\n        heightmap(uv+offset.yx) - heightmap(uv-offset.yx)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n #ifdef TILED\n    // Tile UVs 2x2 for demonstration\n    uv *= 2.0;\n    uv = fract(uv);\n #endif\n    \n    float height = heightmap(uv);\n\tvec2 dudv = dudvmap(uv);\n    vec3 normal = normalize( vec3(dudv, sqrt(max(1.0-dot(dudv,dudv),0.0))) );\n    \n    if (fragCoord.x < iResolution.x*0.33) {\n    \tfragColor = vec4(height*0.5+0.5);\n    } else if (fragCoord.x < iResolution.x*0.66) {\n        fragColor = vec4(normal*0.5+0.5, 1);\n    } else {    \n    \tfragColor = texture(iChannel0, uv + dudv*0.125);\n    }\n}\n", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lltXD4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lltXW7", "name": "strange zone 01", "author": "macbooktall", "description": "some code used from Mercury's hg_sdf http://mercury.sexy/hg_sdf/\niq's base raymarch code + 2d and 3d noise \nterrain from https://www.shadertoy.com/view/MsB3WR", "tags": ["zone"], "likes": 1, "viewed": 2863, "date": "1480094449", "time_retrieved": "2024-06-20T18:44:29.323920", "image_code": "#define PI 3.14159265\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\nreturn dot(p, n) + distanceFromOrigin;\n}\n\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\nfloat halfsize = size*0.5;\nfloat c = floor((p + halfsize)/size);\np = mod(p+halfsize, size) - halfsize;\nif (c > stop) { //yes, this might not be the best thing numerically.\np += size*(c - stop);\nc = stop;\n}\nif (c <start) {\np += size*(c - start);\nc = start;\n}\nreturn c;\n}\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\nfloat angle = 2.*PI/repetitions;\nfloat a = atan(p.y, p.x) + angle/2.;\nfloat r = length(p);\nfloat c = floor(a/angle);\na = mod(a,angle) - angle/2.;\np = vec2(cos(a), sin(a))*r;\n// For an odd number of repetitions, fix cell index of the cell in -x direction\n// (cell index would be e.g. -5 and 5 in the two halves of the cell):\nif (abs(c) >= (repetitions/2.)) c = abs(c);\nreturn c;\n}\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*157.0;\n\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+157.0), hash(n+158.0),f.x),f.y);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nconst mat2 rotate2D = mat2(1.3623, 1.7531, -1.7131, 1.4623);\n\nfloat sdPlane(vec3 p){ \n return p.y;   \n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdTerrain( vec3 p )\n{\n    if (p.z < 1.) return p.y;\n \tfloat pz = min(1.,p.z*.8);\n    vec2 pos = p.xz;\n\tfloat w = noise(pos*.2)*(mix(2.,3.,pz*.6));\n\tfloat f = .0;\n\tfor (int i = 0; i < 2; i++)\n\t{\n\t\tf += w * noise(pos);\n       \tw = -w * .2;\n\t\tpos = rotate2D * pos;\n\t}\n\treturn p.y - mix(0., f, pz);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nfloat sdCylinderTube( vec3 p, vec2 h )\n{    \n    float rep = 32.;\n    float n = h.y*1.01/10.;\n    float ri = pModPolar(p.xy, rep);\n    float zi = pModInterval1(p.z, n*2., -5., 5.);\n    p.x -= h.x*0.3;\n    float s = h.x/rep;\n    float box = sdBox(p, vec3(s*(hash(ri*30. + zi*20.)+.1)*1.8, s, n));\n\t \n    return box;\n}\n\n//----------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\nreturn (d1.x<d2.x) ? d1 : d2;\n}\n\nfloat opU( float d1, float d2 )\n{\n    return min(d2,d1);\n}\n\n\nvec2 rotate(vec2 v, float a){\n\tfloat t = atan(v.y,v.x)+a;\n    float d = length(v);\n    v.x = cos(t)*d;\n    v.y = sin(t)*d;\n    return v;\n}\n\nfloat roomWidth = .5;\n\nfloat map(vec3 pos, inout float id) {\n\n    vec3 p = pos;\n    p.y += roomWidth*.8;\n    vec2 ground = vec2(sdTerrain(p), 1.0);\n    p.y -= roomWidth*.3;\n    vec2 water = vec2(sdPlane(p), 2.0);\n    \n    float box = 100.;\n\tvec2 moon = vec2(sdSphere(p-vec3(0.75,0.,18.), roomWidth*19.), 4.0);    \n    p += vec3(-0.,-0.0,-1.9);\n\n    box = opU(box,sdCylinderTube(p, vec2(roomWidth*2., roomWidth*3.1)));   \n    \n    p.x += .25;\n    p.z -= .25;\n    for (int i = 0; i <3; i++) // i <3 gemma\n    {\n        float h = hash(float(i*4+10))*roomWidth*1.+roomWidth*.9;\n        p.xz = rotate(p.xz, h*5.);\n\n        box = opU(box,sdBox(p, vec3(roomWidth*.12 + h*0.4*roomWidth, roomWidth +h*1.5, roomWidth*.3+ (1.-h)*0.4*roomWidth)));   \n    }\n   \n    vec2 shape = vec2(box, 3.0);\n    \n    vec2 dist = opU(ground, water);\n\tdist = opU(dist, moon);\n    \n    dist = opU(dist, shape);\n\tid = dist.y;\n    return dist.x;\n}\n\nfloat castRay( in vec3 ro, in vec3 rd, inout float id, inout vec3 pos )\n{\n    float tmin = 0.0;\n    float tmax = 40.;\n    \n    float t = tmin;\n    vec3 intersection = ro;\n    for( int i=0; i<40; i++ )\n    {\n        intersection = ro+rd*t;\n    \tfloat res = map( intersection, id );\n        if(  t>tmax ) break;\n        t += res;\n    }\n\n    if( t>tmax ) id=-1.0;\n    pos = intersection;\n    return t;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    float id = 0.;\n\tvec3 eps = vec3( 0.01, 0.0, 0.0 );\n\tvec3 nor = vec3(\n   (map(pos+eps.xyy,id)) - (map(pos-eps.xyy,id)),\n   (map(pos+eps.yxy,id)) - (map(pos-eps.yxy,id)),\n   (map(pos+eps.yyx,id)) - (map(pos-eps.yyx, id)) );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<4; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float id = 0.;\n        float dd = map( aopos, id );\n        occ += -(dd-hr)*sca;\n        sca *= .95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nfloat fog(vec3 ro, vec3 rd, float off) {\n    float tmin = 0.0;\n    float tmax = 30.;\n   \t\n    float t = tmin;\n    float sum = 0.;\n \n    for( int i=0; i<30; i++ )\n    {\n    \tvec3 pos = ro+rd*t;\n        pos.x += off;\n        float v = smoothstep(0.,1.,noise(pos*.8));\n        if (t>tmax) break;\n        sum += v * .045;\n        t += .05 + v;\n   \t}\n    \n    return sum;\n}\n\nvec3 ripple(vec3 nor, float off, float d, vec3 rd) {\n \t\n    nor.x += noise(vec2(d*40.+20., rd.x*10.)+off)*0.025;\n    nor.x -= noise(vec2(d+100., rd.x*2.+20.)+off)*0.015;    \n\n    nor.z += noise(vec2(d*0.1+20., rd.x*10.)+off)*0.01;\n\n    return nor;\n}\n    \nvec3 render( in vec3 ro, in vec3 rd )\n{\n    float t = 0.;\n    float refIntensity = 0.;\n    float tt = mod(iTime, 3.14159);\n \tfloat id = 0.;\n    vec3 intersection = vec3(0.);\n    float res = castRay(ro,rd, id, intersection);\n\n    if( id == 2.0 ) {\n        refIntensity = res*0.35;\n        vec3 nor = vec3(0., 1., 0.);\n    \tnor = mix(ripple(nor, tt, 0.1, rd), ripple(nor, tt-3.14159, 0.1, rd), tt/3.14159);\n        rd = reflect(rd, nor);\n        ro = intersection;\n        ro.y += 0.01;\n        res = castRay(ro,rd, id, intersection);\n    }\n \n    t = res;\n\n    vec3 pos = intersection;\n    vec3 nor = calcNormal( pos );\n    float occ = calcAO( pos, nor );\n    vec3 col = cos(0.1 + vec3(0.,0.25,0.2) + t*0.2)*occ*1.1;\n    col = mix(col, vec3(1.), refIntensity);\n   \n    col = mix( col, mix(vec3(0.,0.5,0.5), vec3(1.), refIntensity), max(1.0-exp( -0.1*t ),clamp(t*0.01,0.,1.)) );\n    col = pow(col,vec3(.6));\n    \n    col.r -= mix(fog(ro, rd, tt), fog(ro, rd, tt-3.14159), tt/3.14159);\n  \n    return col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\nvec3 cw = normalize(ta-ro);\nvec3 cp = vec3(sin(cr), cos(cr),0.0);\nvec3 cu = normalize( cross(cw,cp) );\nvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n    \n\tp.x *= iResolution.x/iResolution.y;\n\n\tvec3 ro = vec3(-1., 0.1, -1.);\n  \tvec3 ta = ro+vec3(0.35,-0.0,1.);\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\tvec3 rd = ca * normalize(vec3(p.xy,2. + sin(iTime*2.)*0.025));\n    vec3 col = 1.-render( ro, rd );\n\tfragColor=vec4( col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lltXW7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsXXzH", "name": "Mistake Google", "author": "maqflp", "description": "Made by mistake a year or two ago, now when I ran it.. it's funny to watch :-)\n", "tags": ["2d"], "likes": 0, "viewed": 134, "date": "1480109954", "time_retrieved": "2024-06-20T18:44:29.330028", "image_code": "float dist(vec2 r, vec2 c)\n{\t\n\treturn length(r-c);\n}\n\nfloat triangle(float t, float a)\n{\t\n\treturn abs(2.0*(t/a-floor(t/a+0.5)));\n}\n\nfloat poiseuille(float r, float R)\n{\t\n\treturn (1.0 - (r/R)*(r/R));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv.x*=16.0/9.0;\n\t\n\tfloat d, tt, tt2;\n\tfloat Radius = 0.0125;\n\tfloat c = 1.0;\n\tfloat s = 0.05*sin(uv.x+iTime);\n\t\n\tc*=smoothstep(0.25,0.256,uv.y+s);\n\tc*=(1.0-smoothstep(0.75,0.756,uv.y+s));\n\n\n\tfor(float kulka=0.0; kulka<1.0; kulka+=0.01)\n\t{\n\t\ttt = texture( iChannel0, vec2(kulka,0.02) ).r;\t\n\t\ttt2 = texture( iChannel0, vec2(kulka,0.2) ).r;\t\n\t\t\n\t\td=dist(uv, vec2(2.0*tt, 0.25+0.5*tt2-s));\n\t\tif(d < Radius)\n\t\t\t\tc*=smoothstep(Radius*0.8,Radius,d);\n\t}\n\t\n\n\tfragColor = vec4(vec3(c,c,c),1.0);\n}", "image_inputs": [{"id": "4sX3Rn", "previewfilepath": "/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsXXzH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lt3SWN", "name": "\"Universal\" Style Intro", "author": "VoidChicken", "description": "A sloppy Universal style intro.", "tags": ["3d", "intro", "universal", "sloppy"], "likes": 0, "viewed": 118, "date": "1479538846", "time_retrieved": "2024-06-20T18:44:29.330028", "image_code": "#define R(x) (fract(x)<.6?floor(x):ceil(x))\nfloat M ( vec3 x ) {\n    return length(x)-2.;\n}\nfloat N(vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.-2.*f);\n\t\n\tvec2 u = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 g = texture( iChannel0, (u+.5)/256., -100. ).yx;\n\treturn mix( g.x, g.y, f.z );\n}\nfloat p=atan(1.)*4.;\nvoid mainImage( out vec4 u,  vec2 f )\n{\n\tvec2 R=iResolution.xy,k=f/R;\n    float j = sin(min(.5,iTime/24.)*p);\n    vec3 c,o=vec3(mix(2.8, 0., j), 0, -5.*j),d=normalize(vec3(vec2(1,R.y/R.x)*(k*2.-1.+(k-.5)/40.),1)),i;\n \n    float t = 0.;\n    for (int i = 0; i < 64; ++i)\n        t+=M(o+d*t);\n    i=o+d*t;\n    if (M(i)<.2){\n        vec3 g=vec3(.96,.66,.29),z=vec3(0,.35, .035),n = normalize(i);\n    \tfloat t,q,l=.5+max(0., dot(n, vec3(1,1,-3))), o=min(1.,iTime/8.);\n        \n        t=N(i+o);\n        t=max(t,0.);\n       \tq=N(i*200.+o)+.2;\n        q=(max(.9,q)-.9)/.2;\n        c=R(t)*g*q*.7+.3*mix(z,vec3(0,.2,1),1.-t);\n    }\n\tu = c.xyzx*min(iTime*.25, 1.)*max(min(15.-iTime,1.),0.)*(1.62-length(k-.5));\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lt3SWN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lt3SzB", "name": "202", "author": "mhorga", "description": "testing shadow", "tags": ["2d"], "likes": 5, "viewed": 2291, "date": "1480263744", "time_retrieved": "2024-06-20T18:44:29.330028", "image_code": "\nfloat differenceOp(float d0, float d1) {\n    return max(d0, -d1);\n}\n\nfloat distanceToRect( vec2 point, vec2 center, vec2 size ) {\n\tpoint -= center;\n    point = abs(point);\n    point -= size / 2.;\n    return max(point.x, point.y);\n}\n\nfloat distanceToScene( vec2 point ) {\n    float d2r1 = distanceToRect( point, vec2( 0. ), vec2(0.45, 0.85) );\n    float d2r2 = distanceToRect( mod(point, 0.1), vec2( 0.05 ), vec2(0.02, 0.04) );\n    float diff = differenceOp(d2r1, d2r2);\n    return diff;\n}\n\nfloat getShadow(vec2 point, vec2 lightPos)  {\n    vec2 lightDir = normalize(lightPos - point);\n    float dist2light = length(lightDir);\n    float distAlongRay = 0.0;\n\tfor (float i=0.0; i < 80.; i++) {\n        vec2 currentPoint = point + lightDir * distAlongRay;\n        float d2scene = distanceToScene(currentPoint);\n        if (d2scene <= 0.001) { return 0.0; }\n        distAlongRay += d2scene;\n        if (distAlongRay > dist2light) { break; }\n    }\n    return 1.;\n}\n \nvoid mainImage( out vec4 color, in vec2 coord ) {\n    vec2 uv = coord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.y *= iResolution.y / iResolution.x;\n    float d2scene = distanceToScene(uv);\n    bool i = d2scene < 0.0; \n    color = i ? vec4( .1, .5, .5, 1. ) : vec4( .7, .8, .8, 1. );\n\tvec2 lightPos = vec2(1.3 * sin(iTime), 1.3 * cos(iTime));\n    float dist2light = length(lightPos - uv);\n    color *= max(0.0, 2. - dist2light );\n    float shadow = getShadow(uv, lightPos);\n    shadow = shadow * 0.5 + 0.5;\n    color *= shadow;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lt3SzB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lt3SzH", "name": "Rounded Voronoi Blocks", "author": "Shane", "description": "Applying some bump mapping and lighting to a variation on IQ's 9-tap Voronoi algorithm to produce some animated, pseudo-lit rounded blocks. 2D made to look like 3D would be another way to put it. :)", "tags": ["3d", "voronoi", "illusion", "bump", "blocks"], "likes": 65, "viewed": 3540, "date": "1478334011", "time_retrieved": "2024-06-20T18:44:30.766444", "image_code": "/*\n\tRounded Voronoi Blocks\n\t----------------------\n\n    Applying some bump mapping and lighting to a Voronoi variation to produce an \n\tanimated, pseudo-lit, rounded block effect.\n\n\tI had originally intended to do a standard square block version using a first order\n    triangular distance metric, but noticed that IQ, Aeikick and others had already done \n\tit, so I switched to a second order distance setup and experimented with a few different \n\tmetrics. The end result was the oddly distributed round-looking blocks with defined \n\tedges you see.\n\n\tTo add a little more to the illusion, I bump mapped it, put in some fake occlusion,\n\tand some subtle edging. As you can see, there's not a lot of code.\n\n\n\tRelated examples:\n\n\t// Uses the more standard, triangle metric. So stylish.\n\tIQ - Blocks \n\thttps://www.shadertoy.com/view/lsSGRc\n\n\t// Aiekick's tunnelized take on the above. \n\tVoro Tri Tunnel - aiekick\n\thttps://www.shadertoy.com/view/XtGGWy\n\n*/\n\n\n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(41, 289)));\n    //return fract(vec2(262144, 32768)*n); \n    \n    // Animated.\n    p = fract(vec2(262144, 32768)*n); \n    // Note the \".25,\" insted of \".5\".\n    return sin( p*6.2831853 + iTime )*.25 + .5; \n    \n}\n\n\n//float tri(float x){ return abs(fract(x) - .5)*2.; }\n\n// 2D 2nd-order Voronoi: Obviously, this is just a rehash of IQ's original. I've tidied\n// up those if-statements. Since there's less writing, it should go faster. That's how \n// it works, right? :)\n//\nfloat Voronoi(in vec2 p){\n    \n\tvec2 g = floor(p), o; p -= g; // Cell ID, offset variable, and relative cell postion.\n\t\n\tvec3 d = vec3(1); // 1.4, etc. \"d.z\" holds the distance comparison value.\n    \n\tfor(int y=-1; y<=1; y++){\n\t\tfor(int x=-1; x<=1; x++){\n            \n\t\t\to = vec2(x, y); // Grid cell ID offset.\n            o += hash22(g + o) - p; // Random offset.\n\t\t\t\n            // Regular squared Euclidean distance.\n            d.z = dot(o, o); \n            // Adding some radial variance as we sweep around the circle. It's an old\n            // trick to draw flowers and so forth. Three petals is reminiscent of a\n            // triangle, which translates roughly to a blocky appearance.\n            d.z *= cos(atan(o.y, o.x)*3. - 3.14159/2.)*.333 + .667;\n            //d.z *= (1. -  tri(atan(o.y, o.x)*3./6.283 + .25)*.5); // More linear looking.\n            \n            d.y = max(d.x, min(d.y, d.z)); // Second order distance.\n            d.x = min(d.x, d.z); // First order distance.\n                      \n\t\t}\n\t}\n\n    // A bit of science and experimentation.\n    return d.y*.5 + (d.y-d.x)*.5; // Range: [0, 1]... Although, I'd check. :)\n    \n    //return d.y; // d.x, d.y - d.x, etc.\n    \n    \n}\n\n\n// Bump mapping function. Put whatever you want here. If you wish to do some\n// fake shadowing, it's usually helpful to keep the range between zero and one.\nfloat bumpFunc(vec2 p){ \n    \n    return Voronoi(p*4.); // Range: [0, 1] \n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    \n    // PLANE ROTATION\n    //\n    // Rotating the canvas back and forth. I don't feel it adds value, in this case,\n    // but feel free to uncomment it.\n    //vec2 a = sin(vec2(1.57, 0) + sin(iTime*0.1)*sin(iTime*0.12)*2.);\n    //uv *= mat2(a, -a.y, a.x);\n  \n    // Position offset.\n    vec3 offs = vec3(-iTime/16., -iTime/8., 0);\n\n    // VECTOR SETUP - surface postion, ray origin, unit direction vector, and light postion.\n    //\n    // Setup: I find 2D bump mapping more intuitive to pretend I'm raytracing, then lighting a bump mapped plane \n    // situated at the origin. Others may disagree. :)  \n    vec3 sp = vec3(uv, 0) + offs; // Surface posion. Hit point, if you prefer. Essentially, a screen at the origin.\n    vec3 rd = normalize(vec3(uv, 1.)); // Unit direction vector. From the origin to the screen plane.\n    vec3 lp = vec3(cos(iTime)*0.5, sin(iTime)*0.2, -2.) + offs; // Light position - Back from the screen.\n\tvec3 sn = vec3(0., 0., -1); // Plane normal. Z pointing toward the viewer.\n \n     \n\n    \n    // BUMP MAPPING - PERTURBING THE NORMAL\n    //\n    // Setting up the bump mapping variables and edge calcultion. Normally, you'd amalgamate a lot \n    // of the following, and roll it into a single function, but I wanted to show the workings.\n    //\n    // f - Function value\n    // fx - Change in \"f\" in in the X-direction.\n    // fy - Change in \"f\" in in the Y-direction.\n    vec2 eps = vec2(3./iResolution.y, 0.);\n    \n    float f = bumpFunc(sp.xy); // Function value.\n    float fx = bumpFunc(sp.xy+eps.xy); // Nearby sample in the X-direction.\n    float fy = bumpFunc(sp.xy+eps.yx); // Nearby sample in the Y-direction.\n  \n    float fx2 = bumpFunc(sp.xy-eps.xy); // Sample on the other side in the X-direction.\n    float fy2 = bumpFunc(sp.xy-eps.yx); // Same on the other side in the Y-direction.\n    \n    // Using the samples to provide an edge measurement. How you do it depends on the\n    // look you're going for.\n    //float edge = abs(fx + fy + fx2 + fy2 - 4.*f); //abs(fx - f) + abs(fy - f);\n    float edge = abs(fx + fy + fx2 + fy2) - 4.*f; //abs(fx - f) + abs(fy - f);\n    //float edge = abs(fx + fx2) + abs(fy + fy2) - 4.*f; //abs(fx - f) + abs(fy - f);\n\n    edge = smoothstep(0., 8., edge/eps.x*4.);\n   \n \t// Controls how much the bump is accentuated.\n\tconst float bumpFactor = 0.35;\n    \n    // Using the above to determine the dx and dy function gradients.\n    fx = (fx-fx2)/eps.x/2.; // Change in X\n    fy = (fy-fy2)/eps.x/2.; // Change in Y.\n    // Using the gradient vector, \"vec3(fx, fy, 0),\" to perturb the XY plane normal \",vec3(0, 0, -1).\"\n    // By the way, there's a redundant step I'm skipping in this particular case, on account of the \n    // normal only having a Z-component. Normally, though, you'd need the commented stuff below.\n    //vec3 grad = vec3(fx, fy, 0);\n    //grad -= sn*dot(sn, grad);\n    //sn = normalize( sn + grad*bumpFactor ); \n    sn = normalize( sn + vec3(fx, fy, 0)*bumpFactor );           \n     \n    \n    // LIGHTING\n    //\n\t// Determine the light direction vector, calculate its distance, then normalize it.\n\tvec3 ld = lp - sp;\n\tfloat lDist = max(length(ld), 0.001);\n\tld /= lDist;\n\n    // Light attenuation.    \n    float atten = 1./(1.0 + lDist*lDist*0.15);\n    \n    // Using the bump function, \"f,\" to darken the crevices. Completely optional, but I\n    // find it gives extra shadowy depth.\n    //atten *= smoothstep(0.1, 1., f)*.9 + .1; // Or... f*f*.7 + .3; //  pow(f, .75); // etc.\n    atten *= ((1.-f)*.9 + .1); // Or... f*f*.7 + .3; //  pow(f, .75); // etc.\n    \n\n\t\n    // TEXTURE COLOR\n    //\n\t// Some fake tri-plannar mapping. I wouldn't take it too seroiusly.    \n    const float ts = 2.;\n    vec3 nsn = max(abs(sn)-.2, .001);\n    nsn /= dot(nsn, vec3(1));\n    vec3 texCol = vec3(0);\n    sp.z += -f*1.; // Pretending that the Z-value is not sitting flat on the plane.\n    // Tri-planar.\n    texCol += texture(iChannel0, sp.xy*ts).xyz*nsn.z;\n    texCol += texture(iChannel0, sp.xz*ts).xyz*nsn.y;\n    texCol += texture(iChannel0, sp.yz*ts).xyz*nsn.x;\n    // sRGB to linar with processing. Basically, minipulating the color a bit.\n    texCol = smoothstep(0.075, .5, texCol*texCol)*1.5;\n    \n    \n    // Diffuse value.\n\tfloat diff = max(dot(sn, ld), 0.);  \n    // Enhancing the diffuse value a bit. Made up.\n    diff = pow(diff, 4.)*0.66 + pow(diff, 8.)*0.34; \n    // Specular highlighting.\n    float spec = pow(max(dot( reflect(-ld, sn), -rd), 0.), 8.); \n    // Fresnel reflection. It's one line, so why not.\n    float fres = pow(clamp(dot(rd, sn) + 1., 0., 1.), 16.);\n    \n    \n    // Apply the edging here. You could do it later, but I wanted the specular lighting to \n    // supercede it. Not for a scientific reason. I just thought it looked nicer this way. :)\n    texCol *= 1.-edge*.5;\n    \n    // I did this by accident, but found it added to the depth, so I kept it.\n    texCol *= smoothstep(0.1, .6, atten);\n\t\n    \n    // FINAL COLOR\n    // Using the values above to produce the final color.   \n    vec3 col = (texCol*(diff*2. + 0.2 + vec3(1, 1.4, 2)*fres) + vec3(1., .7, .3)*spec*2.)*atten;\n\n    // Doing the edging here is fine, but it overrides the specular, which wasn't the look I was going for.\n    //col *= 1. - edge*.5;\n    \n    // Postprocesing - A subtle vignette, contrast and coloring.\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1.-uv.x)*(1.-uv.y), 0.125); // Vignette.\n  \n    col = vec3(1.4, 1.2, .9)*pow(max(col, 0.), vec3(1, 1.2, 1.5))*1.5; // Contrast, coloring.\n    \n\n    // Perform some statistically unlikely (but close enough) 2.0 gamma correction. :) \n\tfragColor = vec4(sqrt(clamp(col, 0., 1.)), 1.);\n}\n", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lt3SzH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lt3XRM", "name": "Overlapping Triangles", "author": "Wumpf", "description": "Playing around with a simple triangle animation. A remake this gif https://twitter.com/bigblueboo/status/792742608904785921", "tags": ["fractal", "triangles"], "likes": 14, "viewed": 649, "date": "1478729112", "time_retrieved": "2024-06-20T18:44:31.136106", "image_code": "#define ENABLE_ANTIALIAS\n\n#define PI2 6.28318530718\n#define NUMTRI 21\n\nfloat triangle(in vec2 uv, float size, float rotation)\n{\n    float crot = cos(rotation);\n    float srot = sin(rotation);\n    uv = vec2(dot(uv, vec2(crot, -srot)), dot(uv, vec2(srot, crot)));\n   \n    float dist = max(max(-2.0 * uv.y, uv.y - uv.x * sqrt(3.0)), uv.y + uv.x * sqrt(3.0)); // Equilateral Tri.\n    \n    if(dist > size)\n        return 0.0;\n    else\n        return 1.0;\n}\n\nfloat evaluate(in vec2 uv, float scaledTime)\n{\n    float value = 0.0;\n    for(int i=0; i<NUMTRI; ++i)\n    {\n        float fi = float(i);\n        float rotDir = mod(fi, 2.0) * 2.0 - 1.0;\n        float tridelay = fi * 0.05;\n        float time = smoothstep(tridelay, tridelay + 1.0, scaledTime) * PI2 / 3.0;\n    \tvalue += triangle(uv, fi * 0.025, time * rotDir);\n    }\n\n    return mod(value, 2.0);\n}\n\nfloat sampleImage(in vec2 uv, float scaledTime, float pixSize)\n{\n    float sampleValue;\n#ifdef ENABLE_ANTIALIAS\n    // Simple multisampling (rotated grid multisampling)\n    sampleValue  = evaluate(uv + vec2(-0.375, 0.125) * pixSize, scaledTime);\n    sampleValue += evaluate(uv + vec2(0.125, 0.375) * pixSize, scaledTime);\n    sampleValue += evaluate(uv + vec2(0.375, -0.125) * pixSize, scaledTime);\n    sampleValue += evaluate(uv + vec2(-0.125, -0.375) * pixSize, scaledTime);\n   \tsampleValue /= 4.0;\n#else\n   \tsampleValue = evaluate(uv, scaledTime);\n#endif\n    \n    return sampleValue;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pixSize = 1.0 / iResolution.y;// assume wider than tall\n\tvec2 uv = vec2(0.5) - fragCoord.xy * pixSize; \n    uv.x -= (iResolution.y - iResolution.x) / iResolution.y * 0.5;\n\tuv.y += 0.08;// move stuff up a bit\n    \n    float scaledTime = mod(iTime, 16.0) * 0.2;\n    \n    float value = sampleImage(uv, scaledTime, pixSize);\n    \n    fragColor = vec4(value,value,value, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lt3XRM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltcSDr", "name": "Classic Spiral", "author": "aiekick", "description": "Classic, Spiral", "tags": ["spiral", "classic"], "likes": 6, "viewed": 612, "date": "1478970826", "time_retrieved": "2024-06-20T18:44:31.136106", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy * 2. - iResolution.xy)/iResolution.y * 5.;\n\t\n\tfloat a = length(uv) - iTime;\n\t\n\tuv *= mat2(cos(a), -sin(a), sin(a), cos(a));\n\t\n\tuv = abs(uv);\n\t\n\tuv = vec2(atan(uv.x, uv.y)/3.14159, length(uv));\n\t\n\tfloat b = sqrt(uv.x) + sqrt(uv.y);\n\tfloat c = sqrt(uv.x + uv.y);\n\t\n\tfloat s = b-c;\n\n\tfragColor = vec4(s);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltcSDr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltcSRM", "name": "Perlin Landscape", "author": "aszecsei", "description": "Attempting to make a procedural desert landscape with sand effects.", "tags": ["procedural", "landscape"], "likes": 3, "viewed": 194, "date": "1478652086", "time_retrieved": "2024-06-20T18:44:31.663796", "image_code": "const int firstOctave = 3;\nconst int octaves = 8;\nconst float persistence = 0.6;\n\n//Not able to use bit operator like <<, so use alternative noise function from YoYo\n//\n//https://www.shadertoy.com/view/Mls3RS\n//\n//And it is a better realization I think\nfloat noise(int x,int y)\n{   \n    float fx = float(x);\n    float fy = float(y);\n    \n    return 2.0 * fract(sin(dot(vec2(fx, fy) ,vec2(12.9898,78.233))) * 43758.5453) - 1.0;\n}\n\nfloat smoothNoise(int x,int y)\n{\n    return noise(x,y)/4.0+(noise(x+1,y)+noise(x-1,y)+noise(x,y+1)+noise(x,y-1))/8.0+(noise(x+1,y+1)+noise(x+1,y-1)+noise(x-1,y+1)+noise(x-1,y-1))/16.0;\n}\n\nfloat COSInterpolation(float x,float y,float n)\n{\n    float r = n*3.1415926;\n    float f = (1.0-cos(r))*0.5;\n    return x*(1.0-f)+y*f;\n    \n}\n\nfloat InterpolationNoise(float x, float y)\n{\n    int ix = int(x);\n    int iy = int(y);\n    float fracx = x-float(int(x));\n    float fracy = y-float(int(y));\n    \n    float v1 = smoothNoise(ix,iy);\n    float v2 = smoothNoise(ix+1,iy);\n    float v3 = smoothNoise(ix,iy+1);\n    float v4 = smoothNoise(ix+1,iy+1);\n    \n   \tfloat i1 = COSInterpolation(v1,v2,fracx);\n    float i2 = COSInterpolation(v3,v4,fracx);\n    \n    return COSInterpolation(i1,i2,fracy);\n    \n}\n\nfloat PerlinNoise2D(float x,float y)\n{\n    float sum = 0.0;\n    float frequency =0.0;\n    float amplitude = 0.0;\n    for(int i=firstOctave;i<octaves + firstOctave;i++)\n    {\n        frequency = pow(2.0,float(i));\n        amplitude = pow(persistence,float(i));\n        sum = sum + InterpolationNoise(x*frequency,y*frequency)*amplitude;\n    }\n    \n    return sum;\n}\n\nfloat map(vec3 p) {\n    vec3 q = fract(p) * 2.0 - 1.0;\n    q.y = p.y + texture(iChannel0, p.xz * 0.125).x * 0.25 + PerlinNoise2D(p.x * 0.05, p.z * 0.01) * 3.0;\n    \n    return q.y - 0.25;\n}\n\nfloat trace(vec3 o, vec3 r) {\n    float t = 0.0;\n    \n    for(int i=0; i<32; ++i) {\n        vec3 p = o + r * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    \n    return t;\n}\n\nfloat lerp(float a, float b, float t) {\n    return (1.0 - t) * a + (t * b);\n}\n\nvec3 lerp3(vec3 a, vec3 b, float t) {\n    return vec3(lerp(a.x, b.x, t), lerp(a.y, b.y, t), lerp(a.z, b.z, t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 r = normalize(vec3(uv, 1.0));\n    \n    float the = iTime * 0.2;\n    r.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    \n    vec3 o = vec3(0, 1.0, iTime);\n    \n    float t = trace(o, r);\n    \n    float fog = 1.0 / (1.0 + t * t * 0.1);\n    \n    vec3 sandColor = vec3(0.761, 0.698, 0.502);\n    vec3 skyColor = vec3(0.529, 0.808, 0.98);\n    fragColor = vec4(lerp3(vec3(0), sandColor, fog),1.0);\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltcSRM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltcSz7", "name": "Acid geometry", "author": "xorxor", "description": "Animgif remake of davidope's work\nhttp://dvdp.tumblr.com/post/96924050968/testing-toon-shaders-for-an-illustration-project\n\nStill learning distance field modelling and animation.\n", "tags": ["raymarching", "cartoon", "npr", "codevember", "dvdp"], "likes": 70, "viewed": 2149, "date": "1478704374", "time_retrieved": "2024-06-20T18:44:33.136340", "image_code": "// Created by XORXOR, 2016\n// Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0)\n// https://www.shadertoy.com/view/4ldXR4\n//\n// Remake of davidope's animgif\n// http://dvdp.tumblr.com/post/96924050968/testing-toon-shaders-for-an-illustration-project\n\n#define PI 3.141592653589793\n#define TWO_PI 6.283185307179586\n#define SQRT_2 1.4142135623730951\n\nvec3 hash3( float n )\n{\n    return fract( sin( vec3( n, n + 1.0, n + 2.0 ) ) *\n            vec3( 13.5453123, 31.1459123, 37.3490423 ) );\n}\n\n// from iq\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs( p ) - b;\n    return min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs( p );\n    return max( q.y - h.y, max( ( q.x * 0.866025 + q.z * 0.5 ), q.z ) - h.x );\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    return ( length( p / r ) - 1.0 ) * min( min( r.x, r.y ), r.z );\n}\n\nvec2 opU( vec2 d2, vec2 d1 )\n{\n    return ( d2.x < d1.x ) ? d2 : d1;\n}\n\nvec2 opS( vec2 d2, vec2 d1 )\n{\n    return( -d1.x > d2.x ) ? vec2( -d1.x, d1.y ) : d2;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5 + 0.5 *( b - a ) / k, 0.0, 1.0 );\n    return mix( b, a, h ) - k * h * ( 1.0 - h );\n}\n\n// from hg_sdf\nfloat sdCapsule( vec3 p, float r, float c )\n{\n    return mix( length( p.yz ) - r,\n                length( vec3( p.y, abs( p.x ) - c, p.z ) ) - r,   step( c, abs( p.x ) ) );\n}\n\nvec2 opRep( vec2 p, vec2 size, vec2 start, vec2 stop )\n{\n    vec2 halfSize = size * 0.5;\n    vec2 c = floor( p / size );\n    p = mod( p , size ) - halfSize;\n    if ( c.y > stop.y )\n    {\n        p.y += size.y * ( c.y - stop.y );\n    }\n    if ( c.y < start.y )\n    {\n        p.y += size.y * ( c.y - start.y );\n    }\n    return p;\n}\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR( inout vec2 p, float a )\n{\n    p = cos( a ) * p + sin( a ) * vec2( p.y, -p.x );\n}\n\n// Shortcut for 45-degrees rotation\nvoid pR45( inout vec2 p )\n{\n    p = ( p + vec2( p.y, -p.x ) ) * sqrt( 0.5 );\n}\n\nvec2 sdSmokingCube( vec3 p, float t, float minDistance )\n{\n    vec2 cube = opS( vec2( sdBox( p, vec3( 1.0 ) ), 1.0 ),\n                      vec2( sdBox( p - vec3( 0.0, 0.0, 0.1 ), vec3( 0.72, 0.72, 1.0 ) ), 2.0 ) );\n    vec2 smoke = vec2( 9999.0, 7.0 );\n    vec3 smokeDir = vec3( 1.0 );\n\n    // rendering the smoke from spheres is really slow\n    // trying a quick speedup by checking the distance from the smoke bounding sphere first\n    float smokeBounds = length( p - vec3( 0.5, 0.5, 1.3 ) ) - 1.0;\n    if ( smokeBounds < min( cube.x, minDistance ) )\n    {\n#define NUM_PARTICLES 15\n\n        for ( int i = 0; i < NUM_PARTICLES; i++ )\n        {\n            float pt = fract( t + float( i ) / float( NUM_PARTICLES ) );\n            float d = length( p + vec3( 0.0, 0.0, -0.8 ) +\n                         0.15 - hash3( float( i ) ) * 0.3\n                         - pt * ( smokeDir + 0.5 * hash3( float( i ) ) - vec3( 0.25 ) ) ) - 0.25 * ( 1.0 - pt );\n            smoke.x = min( smoke.x, d );\n        }\n    }\n\n    return opU( cube, smoke );\n}\n\nvec2 sdPyramid( vec3 p, vec2 h )\n{\n    const float a = 0.866025;\n    vec3 q = abs( p );\n    float dx = max( q.x - h.y, max( q.z * a + p.y * 0.5, -p.y ) - h.x * 0.5 );\n    float dz = max( q.z - h.y, max( q.x * a + p.y * 0.5, -p.y ) - h.x * 0.5 );\n    return vec2( max( dx, dz ), 3.0 );\n}\n\nvec2 sdWorm( vec3 p, vec2 t )\n{\n    vec2 q = vec2( length( p.xy ) - t.x, p.z );\n    float dt = length( q ) - t.y;\n\n    vec3 d = abs( p + vec3( 0.0, 1.0, 0.0 ) ) - vec3( t.x * 2.0, t.x, t.x );\n    float dc = min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) );\n\n    return vec2( max( dt, -dc ), 4.0 );\n}\n\nvec2 sdPearl( vec3 p )\n{\n    return opU( vec2( length( p ) - 0.7, 6.0 ),\n                opS( vec2( length( p ) - 1.0, 5.0 ),\n                     vec2( sdHexPrism( p + vec3( 1.0, 0.0, 0.0 ) , vec2( 1.0, 1.1 ) ), 5.0 ) ) );\n}\n\nvec2 sdCloud( vec3 p )\n{\n    float d = sdCapsule( p, 0.5, 1.0 );\n    d = smin( d, length( p + vec3( 0.0, -0.3, 0.0 ) ) - 0.6, 0.7 );\n    d = smin( d, length( p + vec3( 0.3, 0.4, 0.0 ) ) - 0.2, 0.7 );\n    d = smin( d, length( p + vec3( -0.4, 0.35, -0.1 ) ) - 0.3, 0.2 );\n\n    return vec2( d, 6.0 );\n}\n\nvec2 map( vec3 pos )\n{\n    float t = iTime * 0.4;\n    float tMod = fract( t );\n\n    vec2 plane = vec2( abs( pos.y + 1.0 ), 0.0 );\n\n    float pyramidSize = tMod * 1.16;\n    vec2 pyramidBottom = sdPyramid( pos + vec3( 3.0, 1.0 - pyramidSize * 0.5, -2.0 ),\n                              vec2( pyramidSize ) );\n    vec2 pyramidTop = sdPyramid( pos + vec3( 3.0, 0.4 - pyramidSize * 1.7, -2.0 ),\n                              vec2( 1.16 - pyramidSize ) );\n\n    float wormOffset = tMod * -2.0;\n    wormOffset += ( wormOffset <= -1.0 ) ? 2.0 : 0.0;\n    wormOffset /= SQRT_2;\n    vec3 wormPos = pos + vec3( 0.0 + wormOffset, 1.0, -4.0 + wormOffset );\n    pR45( wormPos.xz );\n    pR( wormPos.xy, tMod * TWO_PI );\n    vec2 worm = sdWorm( wormPos, vec2( 1.0, 0.5 ) );\n\n    vec3 pearlPos = pos - vec3( 3.0, 0.0, 2.0 );\n    pR( pearlPos.xz, tMod * TWO_PI );\n    vec2 pearl = sdPearl( pearlPos );\n\n    float cloudSpeed = ( tMod * -8.0 ) * SQRT_2;\n    vec3 cloudPos = pos - vec3( 4.0 + cloudSpeed, 3.0, 0.0 + cloudSpeed );\n    pR45( cloudPos.xz );\n    cloudPos.xz = opRep( cloudPos.xz, vec2( 8.0 ) , vec2( 0.0 ), vec2( 0.0 ) );\n    vec2 cloud = sdCloud( cloudPos );\n\n    vec2 res = opU( pyramidBottom,\n               opU( pyramidTop,\n               opU( worm,\n               opU( pearl,\n               opU( cloud, plane ) ) ) ) );\n\n    vec2 cube = sdSmokingCube( pos, tMod, res.x );\n\n    return opU( cube, res );\n}\n\nvec2 scene( vec3 ro, vec3 rd )\n{\n    float t = 0.01;\n    for ( int i = 0; i < 100; i++ )\n    {\n        vec3 pos = ro + t * rd;\n        vec2 res = map( pos );\n        if ( res.x < 0.01 )\n        {\n            return vec2( t, res.y );\n        }\n        t += res.x;\n    }\n    return vec2( -1.0 );\n}\n\n// from eiffie\n// https://www.shadertoy.com/view/4ss3WB\nfloat calcEdge( vec3 pos )\n{\n    vec3 eps = vec3( 0.05, 0.0, 0.0 );\n    float d000 = map( pos ).x;\n    float d_100 = map( pos - eps.xyy ).x;\n    float d100 = map( pos + eps.xyy ).x;\n    float d0_10 = map( pos - eps.yxy ).x;\n    float d010 = map( pos + eps.yxy ).x;\n    float d00_1 = map( pos - eps.yyx ).x;\n    float d001 = map( pos + eps.yyx ).x;\n    float edge = abs( d000 - 0.5 * ( d_100 + d100 ) ) +\n                 abs( d000 - 0.5 * ( d0_10 + d010 ) ) +\n                 abs( d000 - 0.5 * ( d00_1 + d001 ) );\n\n    return clamp( 1.0 - edge * 200.0, 0.0, 1.0 );\n}\n\nfloat calcShadow( vec3 ro, vec3 rd, float mint, float maxt )\n{\n    float t = mint;\n    float res = 1.0;\n    for ( int i = 0; i < 20; i++ )\n    {\n        float h = map( ro + rd * t ).x;\n        res = min( res, 22.0 * h / t );\n        t += h;\n        if ( ( h < 0.001 ) || ( t > maxt ) )\n        {\n            break;\n        }\n    }\n    return clamp( res + 0.7, 0.0, 1.0 );\n}\n\nvec3 generateRay( vec2 fragCoord, vec3 eye, vec3 target )\n{\n    vec2 uv = ( fragCoord.xy - 0.5 * iResolution.xy ) / iResolution.y;\n    vec3 cw = normalize( target - eye );\n    vec3 cu = cross( cw, vec3( 0, 1, 0 ) );\n    vec3 cv = cross( cu, cw );\n    mat3 cm = mat3( cu, cv, cw );\n    vec3 rd = cm * normalize( vec3( uv, 2.5 ) );\n    return rd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float mo = 2.0 + 0.5 * iMouse.x / iResolution.x;\n    vec3 target = vec3( 1.0, 0.0, 0.0 );\n    vec3 eye = vec3( 20.0 * cos( mo ), 6.0, 20.0 * sin( mo ) );\n    vec3 rd = generateRay( fragCoord.xy, eye, target );\n    vec3 rdLeft = generateRay( fragCoord.xy + vec2( 2.0, 0.0 ), eye, target );\n    vec3 rdBottom = generateRay( fragCoord.xy + vec2( 0.0, 2.0 ), eye, target );\n\n    vec3 col = vec3( 1.0, 0.0, 1.0 );\n    vec2 res = scene( eye, rd );\n    float edge = 1.0;\n    if ( res.x > 0.0 )\n    {\n        vec3 pos = eye + res.x * rd;\n        col = res.y < 0.5 ? vec3( 0.29, 0.00, 0.47 ) :\n              res.y < 1.5 ? vec3( 0.20, 0.64, 0.38 ) :\n              res.y < 2.5 ? vec3( 0.93, 0.20, 0.0 ) :\n              res.y < 3.5 ? vec3( 0.90, 0.81, 0.14 ) :\n              res.y < 4.5 ? vec3( 0.81, 0.00, 0.28 ) :\n              res.y < 5.5 ? vec3( 0.07, 0.31, 0.82 ) :\n              res.y < 6.5 ? vec3( 1.0 ) :\n              res.y < 7.5 ? vec3( 0.13 ) : vec3( 0.0 );\n\n        edge = calcEdge( pos );\n\n        vec3 ldir = normalize( vec3( -7.0, 13.0, 7.0 ) );\n        float sh = calcShadow( pos, ldir, 0.1, 8.0 );\n        col *= sh;\n    }\n\n    if ( res.y < 0.5 || res.y > 3.5 )\n    {\n        // edge detection by iq\n        // https://www.shadertoy.com/view/4slSWf\n        vec2 resLeft = scene( eye, rdLeft );\n        vec2 resBottom = scene( eye, rdBottom );\n        edge = clamp( 1.0 - 1.0 * max( abs( res.x - resLeft.x ), abs( res.y - resBottom.y ) ), 0.0, 1.0 );\n    }\n\n    col *= edge;\n\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-4.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltcSz7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltcSzH", "name": "Beginner blob study", "author": "xorxor", "description": "Beginner raymarching blob study during codevember 2016", "tags": ["raymarching", "beginner", "blob", "codevember"], "likes": 6, "viewed": 677, "date": "1478093421", "time_retrieved": "2024-06-20T18:44:33.142385", "image_code": "// Created by XORXOR, 2016\n// Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0)\n// \n// Thanks to iq's articles\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// and the Raymarching - Primitives sample\n// https://www.shadertoy.com/view/Xds3zN\n\nconst int kNumSpheres = 20;\n\nfloat hash1( float n )\n{\n\treturn fract( sin( n ) * 4121.15393 );\n}\n\nvec3 hash3( float n )\n{\n\treturn fract( sin( vec3( n, n + 1.0, n + 2.0 ) ) *\n\t\t\tvec3( 13.5453123, 31.1459123, 37.3490423 ) );\n}\n\nfloat sphere( vec3 p, float r )\n{\n\treturn length( p ) - r;\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5 *( b - a ) / k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k * h * ( 1.0 - h );\n}\n\nfloat sdf( vec3 p )\n{\n\tfloat d = 99999.0;\n\tvec3 t = vec3( 12923.73 + iTime );\n\tfor ( int i = 0; i < kNumSpheres; i++ )\n\t{\n\t\tvec3 ps = vec3( 3.0 ) * cos( t * hash3( float( i ) ) );\n\t\tfloat ds = sphere( p - ps, mix( 0.7, 1.1, hash1( float( i ) ) ) );\n\t\td = smin( d, ds, 0.85 );\n\t}\n\treturn d;\n}\n\nfloat castRay( vec3 ro, vec3 rd )\n{\n\tfloat t = 0.0;\n\tvec3 p;\n\n\tfor ( int i = 0; i < 50; i++ )\n\t{\n\t\tp = ro + rd * t;\n\t\tfloat d = sdf( p );\n\t\tif ( d < 0.01 )\n\t\t{\n\t\t\treturn t;\n\t\t}\n\t\tt += d;\n\t}\n\n\treturn -1.0;\n}\n\nvec3 calcNormal( vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 n = vec3(\n\t\t\tsdf( pos + eps.xyy ) - sdf( pos - eps.xyy ),\n\t\t\tsdf( pos + eps.yxy ) - sdf( pos - eps.yxy ),\n\t\t\tsdf( pos + eps.yyx ) - sdf( pos - eps.yyx ) );\n\treturn normalize( n );\n}\n\nfloat calcShadow( vec3 ro, vec3 rd, float mint, float maxt )\n{\n\tfloat t = mint;\n\tfloat res = 1.0;\n\tfor ( int i = 0; i < 32; i++ )\n\t{\n\t\tfloat h = sdf( ro + rd * t );\n\t\tres = min( res, 7.0 * h / t );\n\t\tt += h;\n\t\tif ( ( h < 0.01 ) || ( t > maxt ) )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\nmat3 setCamera( vec3 ro, vec3 ta )\n{\n\tvec3 cw = normalize( ta - ro );\n\tvec3 cu = normalize( cross( cw, vec3( 0, 1, 0 ) ) );\n\tvec3 cv = normalize( cross( cu, cw ) );\n\treturn mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ( fragCoord.xy - iResolution.xy * 0.5 ) / iResolution.y;\n\tvec3 ro = vec3( 19.80, 0.0, -2.82 );\n\tvec3 ta = vec3( 0.0 );\n\tmat3 cm = setCamera( ro, ta );\n\tvec3 rd = cm * normalize( vec3( uv, 3.0 ) );\n\n\tvec3 col = vec3( 0.0 );\n\tfloat t = castRay( ro, rd );\n\tif ( t > 0.0 )\n\t{\n\t\tvec3 pos = ro + rd * t;\n\t\tvec3 n = calcNormal( pos );\n\t\tvec3 ref = reflect( rd, n );\n\n\t\tvec3 ldir = normalize( vec3( -0.5, 2.8, -5.0 ) );\n\t\tfloat dif = max( dot( n, ldir ), 0.0 );\n\t\tfloat spe = pow( clamp( dot( ref, ldir ), 0.0, 1.0 ), 32.0 );\n\t\tfloat sh = calcShadow( pos, ldir, 0.1, 8.0 );\n\n\t\tcol += dif * sh * vec3( 0.7 );\n\t\tcol += dif * sh * spe * vec3( 1.0 );\n\t}\n\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-4.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltcSzH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltcSzn", "name": "Marble paper", "author": "kellyegan", "description": "Marble paper pattern", "tags": ["pattern"], "likes": 4, "viewed": 168, "date": "1477967577", "time_retrieved": "2024-06-20T18:44:33.142385", "image_code": "#define TAU 2.*acos(-1.)\n\nfloat contain( float v ) {    \n\treturn (v + 1.) / 2.; \n}\n\nfloat verticalBars( vec2 uv, float num ) {\n    float v = sin(num * TAU * uv.x);\n    return smoothstep(0.45, 0.55, (v + 1.) / 2.);\n    \n}\n\nfloat horizontalBars( vec2 uv, float num ) {\n    float v = sin(num * TAU * uv.y);\n    return smoothstep(0.45, 0.55, (v + 1.) / 2.);\n    \n}\n\nfloat rand(float i) {\n return fract(sin(i)*1000000.0);   \n}\n\nfloat noise( float x ) {\n    float i = floor(x);\n\tfloat f = fract(x);\n\treturn mix(rand(i), rand(i + 1.0), smoothstep(0.,1.,f));   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float bars = 10.;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float t = sin(iTime* 0.1);\n    uv += vec2( 0.0, 0.02 * abs(sin(30. * TAU * uv.x)) + 0.1 * sin( t +  2. * TAU * uv.x) + noise(uv.x * 200.0)* 0.01);\n    \n    float a = horizontalBars( uv, 7. );\n    float b = horizontalBars( uv, 11. );\n    float c = horizontalBars( uv, 17. );\n    \n    \n    vec3 col = vec3( a-c, (b-c) * 0.8, c * 0.7 );\n    \n\tfragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltcSzn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltcXDn", "name": "GlowPipe", "author": "Unix", "description": "Glowing pipe", "tags": ["glow", "pipe", "unix"], "likes": 8, "viewed": 137, "date": "1478943792", "time_retrieved": "2024-06-20T18:44:33.150048", "image_code": "// Created by Unix 2016\n// Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0)\n\nfloat marchCount;\n\nfloat cylinder( vec3 p )\n{\n    return length( p.xy ) - 0.9;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float a = -0.1 * sin(iTime) - 0.03 * p.z * sin(p.x+iTime/100.);\n    float b = -0.1 * iTime - 0.02 * p.z;\n    float c = cos( a );\n    float s = sin( a );\n    mat2 m = mat2( c, -s, s, c );\n    return vec3( m * p.xy, p.z );\n}\n\nvec2 opRep( vec2 p, float size, float start, float stop )\n{\n    float halfSize = size * 0.5;\n    vec2 c = floor( p / size );\n    p = mod( p, size ) - halfSize;    \n    return p;\n}\n\nfloat map( vec3 p )\n{\n    p = opTwist( p );\n    //p.xy = opRep( p.xy, 10.0, -7.0, 7.0 );\n    p.xy = opRep( p.xy, 3.0, -7.0, 7.0 );\n    float d = cylinder( p );\n    return d;\n}\n\nfloat scene( vec3 ro, vec3 rd )\n{\n    float t = 0.01;\n    marchCount = 0.0;\n    for ( int i = 0; i < 150; i++ )\n    {\n        vec3 p = ro + t * rd;\n        float d = map( p );\n        if ( d < 0.001 )\n        {\n            return t;\n        }\n        t += d;\n        marchCount+= 1.0/d*0.1;\n    }\n    return -1.0;\n}\n\nvec3 calcNormal( vec3 pos )\n{\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    float pd = map( pos );\n    vec3 n = vec3(\n            pd - map( pos - eps.xyy ),\n            pd - map( pos - eps.yxy ),\n            pd - map( pos - eps.yyx ) );\n    return normalize( n );\n}\n\nfloat calcAo( vec3 pos, vec3 n )\n{\n    float occ = 0.0;\n    for ( int i = 0; i < 5; i++ )\n    {\n        float hp = 0.1 + 2.0 * float( i );\n        float dp = map( pos + n * hp );\n        occ += ( hp - dp );\n    }\n    return clamp( 1.0 - 0.04 * occ, 0.0, 1.0 );\n}\n\nvec3 render( vec3 ro, vec3 rd )\n{\n    float d = scene( ro, rd );\n    vec3 col = vec3( 0 );\n    if ( d > 0.0 )\n    {\n        vec3 pos = ro + d * rd;\n        vec3 twistPos = opTwist( pos );\n        float t = -5.0 * iTime;\n        col = vec3( floor( 0.2 * mod( twistPos.z + t, 6.0 ) ) );\n        vec3 nor = calcNormal( pos );\n        float ao = calcAo( pos, nor );\n        col *= vec3( ao );\n        float fog = ( 400.0 + pos.z ) / 300.0;\n        col *= fog;\n    }\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 eye = vec3( 0.0, 0.0, 20.0 );\n    vec3 target = vec3( 0.0 );\n    vec3 cw = normalize( target - eye );\n    vec3 cu = cross( cw, vec3( 0, 1, 0 ) );\n    vec3 cv = cross( cu, cw );\n    mat3 cm = mat3( cu, cv, cw );\n\n    vec3 col = vec3( 0.0 );\n    \n    for ( int i = 0; i < 10; i++ )\n    {\n        vec2 off = vec2( mod( float( i ), 2.0 ), mod( float( i / 2 ), 2.0 ) ) / 2.0;\n        vec2 uv = ( fragCoord.xy + off - 0.5 * iResolution.xy ) / iResolution.y;\n        vec3 rd = cm * normalize( vec3( uv, 2.5 ) );\n        col += render( eye, rd );\n    }\n    col *= 0.15;\n\t// This is the glow\n    col += marchCount * vec3(0.2, 1.0, 0.41) * 0.0005;\n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-4.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltcXDn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltdSz8", "name": "matrix dance", "author": "komietty", "description": "raymarching", "tags": ["raymarching"], "likes": 0, "viewed": 117, "date": "1478188688", "time_retrieved": "2024-06-20T18:44:33.151045", "image_code": "const vec3 cPos = vec3(0.,  0.,  3.0);\nconst vec3 cDir = vec3(0., 0., -1.);\nconst vec3 cUp  = vec3(0., 1., 0.);\n\nconst vec3 lightDir = vec3(-0.577, 0.577, 0.577);\n\n// smoothing min\nfloat smoothMin(float d1, float d2, float k){\n    float h = exp(-k * d1) + exp(-k * d2);\n    return -log(h) / k;\n}\n\n// box distance function\nfloat distFuncBox(vec3 p){\n    return length(max(abs(p) - vec3(2.0, 0.1, 0.5), 0.0)) - 0.1;\n}\n\n// torus distance function\nfloat distFuncTorus(vec3 p){\n    vec2 t = vec2(1.5, 0.25);\n    vec2 r = vec2(length(p.xy) - t.x, p.z);\n    return length(r) - t.y;\n}\n\n// twist x axis\nvec3 twistX(vec3 p, float power){\n    float s = sin(power * p.x);\n    float c = cos(power * p.x);\n    mat3 m = mat3(\n        1.0, 0.0, 0.0,\n        0.0,   c,   s,\n        0.0,  -s,   c\n    );\n    return m * p;\n}\n\n// twist y axis\nvec3 twistY(vec3 p, float power){\n    float s = sin(power * p.y);\n    float c = cos(power * p.y);\n    mat3 m = mat3(\n          c, 0.0,  -s,\n        0.0, 1.0, 0.0,\n          s, 0.0,   c\n    );\n    return m * p;\n}\n\n// twist z axis\nvec3 twistZ(vec3 p, float power){\n    float s = sin(power * p.z);\n    float c = cos(power * p.z);\n    mat3 m = mat3(\n          c,  s,  0.0,\n         -s,  c,  0.0,\n        0.0, 0.0, 1.0\n    );\n    return m * p;\n}\n\n\n\n\n// distance function\nfloat distFunc(vec3 p){\n    vec3 x = twistX(p, 0.0);\n    vec3 y = twistY(x, cos(iTime));\n    vec3 z = twistZ(y, sin(iTime));\n    float d1 = distFuncTorus(z);\n    float d2 = distFuncBox(z);\n    return smoothMin(d1, d2, 8.0);\n}\n\nvec3 genNormal(vec3 p){\n    float d = 0.001;\n    return normalize(vec3(\n        distFunc(p + vec3(  d, 0.0, 0.0)) - distFunc(p + vec3( -d, 0.0, 0.0)),\n        distFunc(p + vec3(0.0,   d, 0.0)) - distFunc(p + vec3(0.0,  -d, 0.0)),\n        distFunc(p + vec3(0.0, 0.0,   d)) - distFunc(p + vec3(0.0, 0.0,  -d))\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// fragment position\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    \n    // camera and ray\n    vec3 cSide = cross(cDir, cUp);\n    float targetDepth = 1.0;\n    vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir * targetDepth);\n    \n    // marching loop\n    float tmp, dist;\n    tmp = 0.0;\n    vec3 dPos = cPos;\n    for(int i = 0; i < 256; i++){\n        dist = distFunc(dPos);\n        tmp += dist;\n        dPos = cPos + tmp * ray*0.1;\n    }\n    \n    // hit check\n    vec3 color;\n    if(abs(dist) < 0.001){\n        vec3 normal = genNormal(dPos);\n        float diff = clamp(dot(lightDir, normal), 0.1, 1.0);\n        color = vec3(1.0, 1.0, 1.0) * diff;\n    }else{\n        color = vec3(0.0);\n    }\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltdSz8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltdXRS", "name": "CloudyNoise", "author": "kuvkar", "description": "tinkering some noise that might work for clouds etc.", "tags": ["noise", "clouds"], "likes": 58, "viewed": 2554, "date": "1480370870", "time_retrieved": "2024-06-20T18:44:33.152042", "image_code": "/**\n Trying to whip up some noise that might work on clouds and such. \n Well I guess almost any noise works with clouds. But still :)\n*/\n\nfloat cloudyNoise(vec2 uv)\n{\n    float sx = cos(500. * uv.x);\n    float sy = sin(500. * uv.y);\n    sx = mix(sx, cos(uv.y * 1000.), .5);\n    sy = mix(sy, sin(uv.x * 1000.), .5);\n    \n    vec2 b = (vec2(sx, sy));\n    vec2 bn = normalize(b);\n\n    vec2 _b = b;\n\tb.x = _b.x * bn.x - _b.y * bn.y;\n    b.y = _b.x * bn.y + _b.y * bn.x; \n    vec2 l = uv - vec2(sin(b.x), cos(b.y));\n    return length(l - b) - 0.5;\n}\n\nfloat cloudyFbm(vec2 uv)\n{\n    float f = 0.0;\n    vec2 _uv = uv;\n    vec2 rotator = (vec2(.91, 1.5));\n    \n    for (int i = 0; i < 5; ++i)\n    {\n        vec2 tmp = uv;\n        uv.x = tmp.x * rotator.x - tmp.y * rotator.y; \n        uv.y = tmp.x * rotator.y + tmp.y * rotator.x; \n        f += .5 * cloudyNoise(uv) * pow(0.5, float(i + 1));\n    }\n    return f;\n}\n\nfloat clouds (vec2 uv)\n{\n    float T = iTime * .001;\n\n\tfloat x = 0.0;\n    x += cloudyFbm( 0.5 * uv + vec2(.1,  -.01) * T) * 0.5;\n    x += cloudyFbm( 1.0 * uv + vec2(.12,  .03) * T) * 0.5 * 0.5;\n \tx += cloudyFbm( 2.0 * uv + vec2(.15, -.02) * T) * 0.5 * 0.5 * 0.5;\n \tx += cloudyFbm( 4.0 * uv + vec2(.2,   .01) * T) * 0.5 * 0.5 * 0.5 * 0.5;\n \tx += cloudyFbm( 8.0 * uv + vec2(.15, -.01) * T) * 0.5 * 0.5 * 0.5 * 0.5 * 0.5;\n\t\n    x = smoothstep(0.0, .6, x);\n    float f = 0.6;\n\tx = (x - f) / (1.0 - f);\n    float _x = x;    \n    x = smoothstep(0.4, 0.55, x);\n\treturn x * _x;    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 ouv = uv;\n    uv -= vec2(0.5);\n    uv.y /= iResolution.x / iResolution.y;\n    vec2 _uv = uv * 0.007;\n    \n    // clouds \n\tfloat x = clouds(_uv);\n    // sky colors\n    vec4 top = vec4(0.1, 0.45, 0.9, 0.0) * .6;\n    vec4 bottom = vec4(0., 0.45, .7, 0.0) * 1.2;\n    fragColor = mix(bottom, top, smoothstep(0., .7, ouv.y));\n    \n    // clouds color\n    fragColor += x;\n    fragColor = mix(vec4(x), fragColor, 1. - x);\n\t\n    // some fake lighting\n    vec2 ld = .005 * normalize(vec2(1.0, 1.)) * fwidth(uv);\n    float f = .0;\n    const int steps = 4;\n    for (int i = 1; i <= steps; ++i)\n    {\n    \tfloat c = clouds(_uv - float(i * i) * ld) * pow(0.55, float(i));\n        f += max(c, 0.0);\n    }\n    f = clamp(f, 0.0, 1.0);\n    f = 1.0 - f;\n    f = pow(f, 1.2);\n    fragColor += vec4(f) * x * .5;   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltdXRS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltKGzR", "name": "CoolRedPlotLine", "author": "evadsnibor", "description": "Plot of red line", "tags": ["plot"], "likes": 4, "viewed": 158, "date": "1479331231", "time_retrieved": "2024-06-20T18:44:33.152042", "image_code": "#define PI 3.14159265359\n#define T (iTime * 6.)\n\nfloat square(float x) {\n\treturn sign(sin(x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 position = ( gl_FragCoord.xy / iResolution.xy ) - 0.5;\n\tposition.x *= iResolution.x / iResolution.y;\n    \n\tfloat a = 0.;\n\tfor (float i = 1.; i <= 6.; i++) {\n\t\tfloat p = pow(2., i);\n\t\ta += sin(p * 2. * PI * (position.x) - T) / p;\n\t}\n\ta =0.1;// (0.1 + 0.1*a) * ( 0.3 / abs(position.y - 0.025*a));\n\t//*/\n\t\n\tfloat b = 0.;\n\t\n\tfor (float i = 1.; i <= 6.; i++) {\n\t\tfloat p = pow(4., i);\n\t\tb += cos(p * 2. * PI * (position.x) - 2.0*T) / p;\n\t}\n\tb = (0.15 + 0.2*b) * ( 0.1 / abs(position.y - 0.045*b));\n\t\n\tvec3 result = a * vec3(0.405, 0.05, 0.3) + b * vec3(1., 0.05, 0.05);\n\n\tfragColor = vec4( result, 1.0 );\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltKGzR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lttXDn", "name": "Ray Marching Experiment 60", "author": "aiekick", "description": "Ray Marching Experiment 60", "tags": ["ray", "experiment", "marching", "60"], "likes": 44, "viewed": 1107, "date": "1479125151", "time_retrieved": "2024-06-20T18:44:33.833571", "image_code": "// Created by Stephane Cuillerdier - @Aiekick/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\nmat3 rotx(float a){return mat3(1.,0.,0.,0.,cos(a),-sin(a),0.,sin(a),cos(a));}\nmat3 roty(float a){return mat3(cos(a),0.,sin(a),0.,1.,0.,-sin(a),0.,cos(a));}\nmat3 rotz(float a){return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\n\nvec4 df(vec3 p) // from https://www.shadertoy.com/view/ltcSDr\n{\n\tp *= rotz(p.z * 0.07);\n\tvec2 uv = p.xz;\n\tfloat a = length(uv) - iTime*2.;\n\tuv *= mat2(cos(a), -sin(a), sin(a), cos(a));\n\tuv = abs(uv);\n\tuv = vec2(atan(uv.x, uv.y)/3.14159, length(uv));\n\tfloat b = sqrt(uv.x) + sqrt(uv.y);\n\tfloat c = sqrt(uv.x + uv.y);\n\tfloat s = b-c;\n\tfloat d = 6. - abs(p.y)  - smoothstep(0.128,1.-0.128, s*1.32);\n\treturn vec4(d);\n}\n\nvec3 nor( in vec3 p, float prec )\n{\n\tvec3 e = vec3( prec, 0., 0. );\n\tvec3 n = vec3(\n\t    df(p+e.xyy).x - df(p-e.xyy).x,\n\t    df(p+e.yxy).x - df(p-e.yxy).x,\n\t    df(p+e.yyx).x - df(p-e.yyx).x );\n\treturn normalize(n);\n}\n\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// get density of the df at surfPoint\n// ratio between constant step and df value\nfloat SubDensity(vec3 surfPoint, float prec, float ms) \n{\n\tvec3 n;\n\tfloat s = 0.;\n    const int iter = 10;\n\tfor (int i=0;i<iter;i++)\n\t{\n\t\tn = nor(surfPoint,prec); \n\t\tsurfPoint = surfPoint - n * ms; \n\t\ts += df(surfPoint).x;\n\t}\n\t\n\treturn 1.-s/(ms*float(iter)); // s < 0. => inside df\n}\n\nfloat SubDensity(vec3 p, float s) \n{\n\tvec3 n = nor(p,s); \t\t\t\t\t\t\t\n\treturn df(p - n * s).x;\t\t\t\t\t\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 g = fragCoord.xy;\n\tvec2 si = iResolution.xy;\n\tvec2 uv = (g+g-si)/si.y;\n\tfloat t = -iTime * 0.2;\n\tvec3 ro = vec3(cos(t),0., sin(t)) * 12.; \n    vec3 cv = vec3(0); \n\tvec3 cu = normalize(vec3(0,1,0));\n  \tvec3 z = normalize(cv-ro);\n    vec3 x = normalize(cross(cu,z));\n  \tvec3 y = cross(z,x);\n    float fov = .9;\n  \tvec3 rd = normalize(fov * (uv.x * x + uv.y * y) + z);\n    \n    float s = 1., d = 0.;\n\tfor (int i=0; i<200; i++) \n\t{\n\t\tif (log(d*d/s/1e5)>0.) break;\n\t\td += (s=df(ro+rd*d).x)*.5;\n\t}\n\t\n\tvec3 p = ro + rd * d;\t\t\t\t\t\t\t\t\t\t\t// surface point\n\tvec3 lid = normalize(ro-p); \t\t\t\t\t\t\t\t\t// light dir\n\tvec3 n = nor(p, 0.1);\t\t\t\t\t\t\t\t\t\t\t// normal at surface point\n\tvec3 refl = reflect(rd,n);\t\t\t\t\t\t\t\t\t\t// reflected ray dir at surf point \n\tfloat diff = clamp( dot( n, lid ), 0.0, 1.0 ); \t\t\t\t\t// diffuse\n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 4. ); \t\t\t// fresnel\n\tfloat spe = pow(clamp( dot( refl, lid ), 0.0, 1.0 ),16.);\t\t// specular\n\tvec3 col = vec3(.8,.5,.2);\n    float sss = df(p - n*0.001).x/0.1;\t\t\t\t\t\t\t\t// quick sss 0.001 of subsurface\n\tfloat sb = SubDensity(p, 1., 0.1);\t\t\t\t\t\t\t\t// deep subdensity from 0.01 to 0.1 (10 iterations)\n\tvec3 bb = clamp(blackbody(100. * sb),0.,1.);\t\t\t\t\t// blackbody color\n\tfloat sss2 = 1. - SubDensity(p, 3.); \t\t\t\t\t\t\t// one step sub density of df of 3 of subsurface\n\t\n    fragColor.rgb = (diff + fre + bb * sss2 * .8 + col * sss * .2) * 0.25 + spe * 1.2;\n\n\t// vigneting from iq Shader Mike : https://www.shadertoy.com/view/MsXGWr\n    vec2 q = g/si;\n    fragColor.rgb *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.55 );\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lttXDn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ml3XWH", "name": "Fast Fish", "author": "dr2", "description": "Faster version of \"Kelp Forest\" by Martijn Steinrucken aka BigWings", "tags": ["raymarching", "fish", "cells"], "likes": 14, "viewed": 843, "date": "1479290484", "time_retrieved": "2024-06-20T18:44:36.251830", "image_code": "// \"Fast Fish\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Scene based on \"Kelp Forest\" by Martijn Steinrucken aka BigWings - 2016\n  (https://www.shadertoy.com/view/llcSz8)\n\n  Runs several times (4-5X) faster, mainly due to altered cell marching.\n\n  Coloring/lighting changed to avoid confusion; mouse enabled.\n*/\n\nfloat Hashfv2 (vec2 p);\nvec3 Hashv3f (float p);\nvec2 Rot2D (vec2 q, float a);\nfloat PrSphDf (vec3 p, float s);\nfloat PrEllipsDf (vec3 p, vec3 r);\nfloat PrRndBoxDf (vec3 p, vec3 b, float r);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\n\nstruct {\n  vec3 vSc;\n  float dBody, dDors, dTail, dMouth, dBump;\n} fh;\n\nvec3 qHit, ltDir;\nfloat tCur, dstFar;\nconst float dEps = 0.0005;\nconst vec3 fRep = vec3 (11.5, 4.5, 2.5), kRep = vec3 (2., 40., 2.),\n   bRep = vec3 (4., 4., 4.),\n   fVr = vec3 (1., 123.231, 87.342), bVr = vec3 (1., 1234.5234, 765.);\nconst vec2 kVr = vec2 (1.1, 764.);\nconst float pi = 3.14159;\n\nfloat ScalesHt (vec2 uv)\n{\n  vec4 ds, scl, g;\n  float s;\n  uv -= floor (uv);\n  ds = vec4 (length (uv - vec2 (1., 0.5)), length (uv - vec2 (0.5, 1.)),\n     length (uv - vec2 (0.5, 0.)), length (uv - vec2 (0., 0.5)));\n  scl = uv.x + vec4 (-0.5, 0., 0., 0.5) - 2. * ds;\n  g = smoothstep (0.45, 0.5, ds);\n  s = (1. - g.x) * scl.x;\n  s = (s - scl.y) * g.y + scl.y;\n  s = (s - scl.z) * g.z + scl.z;\n  s = (s - scl.w) * g.w + scl.w;\n  return -0.01 * s;\n}\n\nfloat ScalesSh (vec2 uv, float rnd)\n{\n  vec4 ds, scl, g;\n  vec2 uvi;\n  float s;\n  uvi = floor (uv);\n  uv -= uvi;\n  ds = vec4 (length (uv - vec2 (1., 0.5)), length (uv - vec2 (0.5, 1.)),\n     length (uv - vec2 (0.5, 0.)), length (uv - vec2 (0., 0.5)));\n  scl.x = Hashfv2 (uvi + vec2 (0., rnd));\n  scl.y = scl.x;\n  scl.z = Hashfv2 (uvi + vec2 (0., rnd - 1.));\n  scl.w = Hashfv2 (uvi + vec2 (-1., rnd));\n  g = smoothstep (0.45, 0.5, ds);\n  s = (1. - g.x) * scl.x;\n  s = (s - scl.y) * g.y + scl.y;\n  s = (s - scl.z) * g.z + scl.z;\n  s = (s - scl.w) * g.w + scl.w;\n  return s;\n}\n\nfloat WSmoothMin (float a, float b, float r, float f, float amp)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  r *= 1. + cos (h * f) * amp;\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat FishDf (vec3 p, vec3 vr)\n{\n  vec3 q;\n  vec2 r;\n  float dCheek, dEye, dSnout, dGill, dAnal, dPect, dPelv, dScales, mask, a, d;\n  p.z += sin (p.x - tCur * 2. + vr.x * 100.) * (0.15 + 0.1 * vr.y);\n  p.z = abs (p.z);\n  qHit = p;\n  fh.dBump = 0.;\n  dCheek = SmoothMin (PrEllipsDf (p - vec3 (-1., 0., 0.25), vec3 (0.4, 0.4, 0.2)),\n     PrEllipsDf (p - vec3 (-1., 0., -0.25), vec3 (0.4, 0.4, 0.2)), 0.2);\n  dEye = PrEllipsDf (p - vec3 (-1., 0., 0.4), vec3 (0.25, 0.25, 0.09));\n  dSnout = PrEllipsDf (p - vec3 (-1.2, -0.2, 0.), vec3 (0.6, 0.4, 0.2));\n  q = p - vec3 (-1.2, -0.6, 0.);\n  q.xy = Rot2D (q.xy, 0.35);\n  fh.dMouth = WSmoothMin (PrEllipsDf (q - vec3 (-0.3, 0.15, 0.),\n     vec3 (0.36, 0.12, 0.18)),\n     PrEllipsDf (q, vec3 (0.6, 0.12, 0.24)), 0.03, 15., 0.1);\n  dSnout = SmoothMin (dSnout, fh.dMouth, 0.1);\n  q = p - vec3 (-1., 0., 0.);\n  fh.vSc = vec3 (8. * p.x + 16., 20. * atan (q.y, q.z) / pi + 0.5, vr.z);\n  dScales = ScalesHt (fh.vSc.xy) * smoothstep (0.33, 0.45, dEye) *\n     (1. - smoothstep (1.2, 1.8, dEye)) * smoothstep (-0.3, 0., p.x);\n  q = p - vec3 (-0.7, -0.25, 0.2);\n  q.xz = Rot2D (q.xz, -0.4);\n  dGill = PrEllipsDf (q, vec3 (0.8, 0.72, 0.12));\n  fh.dTail = PrEllipsDf (p - vec3 (4.5, 0.1, 0.), vec3 (0.5, 1., 0.1));\n  r = p.xy - vec2 (3.8, 0.1);\n  a = atan (r.x, r.y);\n  mask = SmoothBump (0.45, 2.9, 0.2, a) * smoothstep (0.04, 1., dot (r, r));\n  fh.dBump += sin (a * 70.) * 0.005 * mask;\n  fh.dTail += mask * (sin (a * 5.) * 0.03 + sin (a * 280.) * 0.001) + fh.dBump;\n  a = atan (p.x, p.y);\n  fh.dBump += SmoothBump (-0.2, 3., 0.2, p.x) * (sin (a * 100.) * 0.003 +\n     (1. - pow (sin (a * 50.) * 0.5 + 0.5, 15.)) * 0.015 + sin (a * 400.) * 0.001);\n  fh.dDors = SmoothMin (PrEllipsDf (p - vec3 (1.5, 1., 0.), vec3 (1.5, 0.5, 0.1)),\n     PrEllipsDf (p - vec3 (0.5, 1.5, 0.), vec3 (0.5, 0.5, 0.05)), 0.1) + fh.dBump;\n  dAnal = PrEllipsDf (p - vec3 (2.6, -0.7, 0.), vec3 (1., 0.35, 0.05)) +\n     sin (a * 300.) * 0.001 + sin (a * 40.) * 0.01;\n  q = p - vec3 (0.7, -0.6, 0.52);\n  r = p.xy - vec2 (0.3, -0.4);\n  a = atan (r.x, r.y);\n  q.yz = Rot2D (q.yz, -0.2);\n  q.xz = Rot2D (q.xz, -0.2);\n  dPect = PrEllipsDf (q, vec3 (0.4, 0.2, 0.04)) +\n     (sin (a * 10.) * 0.01 + sin (a * 100.) * 0.002) *\n     SmoothBump (1.5, 2.9, 0.1, a) * smoothstep (0.01, 0.36, dot (r, r));\n  q = p - vec3 (0.9, -1.1, 0.2);\n  q.xy = Rot2D (q.xy, 0.4);\n  q.yz = Rot2D (q.yz, 0.4);\n  r = p.xy - vec2 (0.5, -0.9);\n  a = atan (r.x, r.y);\n  dPelv = PrEllipsDf (q, vec3 (2., 1., 0.2) * 0.2) +\n     (sin (a * 10.) * 0.01 + sin (a * 60.) * 0.002) *\n     SmoothBump (1.5, 2.9, 0.1, a) * smoothstep (0.01, 0.16, dot (r, r));\n  fh.dBody = SmoothMin (dCheek, dSnout, 0.3);\n  fh.dBody = SmoothMin (SmoothMin (fh.dBody,\n     PrEllipsDf (p - vec3 (0.6, -0., 0.), vec3 (2., 1., 0.5)), 0.15),\n     PrEllipsDf (p - vec3 (2.4, 0.1, 0.), vec3 (1.8, 0.6, 0.24)), 0.3) + dScales;\n  fh.dBody = WSmoothMin (fh.dBody, dGill, 0.1, 15., 0.1);\n  d = SmoothMin (fh.dBody, min (min (min (min (dPect, dPelv), fh.dTail), fh.dDors),\n     dAnal), 0.05);\n  d = WSmoothMin (d, dEye, 0.01, 6., 1.);\n  return 0.9 * d;\n}\n\nfloat KelpDf (vec3 p, vec3 vr)\n{\n  p.xz = Rot2D (p.xz, p.y * pi * floor (vr.y * 10.) / 40.);\n  return 0.9 * PrRndBoxDf (p, vec3 ((0.1 + 0.5 * vr.x) *\n    (0.8 + 0.2 * sin (0.2 * pi * p.y)), 30., 0.02 + 0.01 * vr.y), 0.005);\n}\n\nfloat BubDf (vec3 p, vec3 pw, vec3 vr)\n{\n  vec3 b;\n  float s, t, r, d, a;\n  t = tCur;\n  vr -= 0.5;\n  s = pow (fract (dot (vr, vec3 (1.)) * 100.), 4.);\n  pw.y += t;\n  pw = 7. * pw + 2. * pi * vr + vec3 (t, 0., t);\n  d = sin ((t + vr.y) * 3. * pi * (1. - s)) *\n     0.3 * vr.x * (1. - s);\n  a = vr.z * t;\n  b = d * vec3 (cos (a), 0., sin (a));\n  r = 0.1 - 0.05 * s + dot (sin (pw), vec3 (1.)) * s * 0.02;\n  return 0.9 * PrSphDf (p - b, r);\n}\n\nfloat FObjDf (vec3 p)\n{\n  vec3 cId, vr;\n  float d;\n  cId = floor (p / fRep);\n  vr = Hashv3f (dot (cId, fVr));\n  d = (vr.x > 0.95) ? FishDf (p - fRep * (cId + 0.5), vr) : dstFar;\n  return d;\n}\n\nfloat FObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p, cId, vr, s;\n  float dHit, d;\n  dHit = 0.1;\n  for (int j = 0; j < 120; j ++) {\n    p = ro + rd * dHit;\n    p.x += tCur;\n    cId = floor (p / fRep);\n    vr = Hashv3f (dot (cId, fVr));\n    d = (vr.x > 0.95) ? FishDf (p - fRep * (cId + 0.5), vr) : dstFar;\n    s = (fRep * (cId + step (0., rd)) - p) / rd;\n    d = min (d, abs (min (min (s.x, s.y), s.z)) + 0.01);\n    if (d < dEps || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nfloat KObjDf (vec3 p)\n{\n  vec3 cId, vr;\n  float d;\n  cId = floor (p / kRep);\n  vr = Hashv3f (dot (cId.xz, kVr));\n  d = (vr.x * smoothstep (7., 10., length (cId)) > 0.9) ?\n     KelpDf (p - kRep * (cId + 0.5), vr) : dstFar;\n  return d;\n}\n\nfloat KObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p, cId, vr, s;\n  float dHit, d;\n  dHit = 0.1;\n  for (int j = 0; j < 120; j ++) {\n    p = ro + rd * dHit;\n    p.x += sin (tCur + p.y * 0.2) * 0.5;\n    cId = floor (p / kRep);\n    vr = Hashv3f (dot (cId.xz, kVr));\n    d = (vr.x * smoothstep (7., 10., length (cId)) > 0.9) ?\n       KelpDf (p - kRep * (cId + 0.5), vr) : dstFar;\n    s = (kRep * (cId + step (0., rd)) - p) / rd;\n    d = min (d, abs (min (min (s.x, s.y), s.z)) + 0.01);\n    if (d < dEps || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nfloat BObjDf (vec3 p)\n{\n  vec3 cId, vr;\n  float d;\n  cId = floor (p / bRep);\n  vr = Hashv3f (dot (cId, bVr));\n  d = (vr.x * smoothstep (2., 5., length (cId)) > 0.95) ?\n     BubDf (p - bRep * (cId + 0.5), p, vr) : dstFar;\n  return d;\n}\n\nfloat BObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p, cId, vr, s;\n  float dHit, d;\n  dHit = 0.1;\n  for (int j = 0; j < 120; j ++) {\n    p = ro + rd * dHit;\n    p.y -= tCur * 4. + 40.;\n    cId = floor (p / bRep);\n    vr = Hashv3f (dot (cId, bVr));\n    d = (vr.x * smoothstep (2., 5., length (cId)) > 0.95) ?\n       BubDf (p - bRep * (cId + 0.5), p, vr) : dstFar;\n    s = (bRep * (cId + step (0., rd)) - p) / rd;\n    d = min (d, abs (min (min (s.x, s.y), s.z)) + 0.01);\n    if (d < dEps || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nfloat ObjDfN (vec3 p)\n{\n  vec3 q;\n  float dHit;\n  q = p;\n  q.x += tCur;\n  dHit = FObjDf (q);\n  q = p;\n  q.x += sin (tCur + p.y * 0.2) * 0.5;\n  dHit = min (dHit, KObjDf (q));\n  q = p;\n  q.y -= tCur * 4. + 40.;\n  dHit = min (dHit, BObjDf (q));\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDfN (p + e.xxx), ObjDfN (p + e.xyy),\n     ObjDfN (p + e.yxy), ObjDfN (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat TurbLt (vec3 p, vec3 n, float t)\n{\n  vec2 q, qq, a1, a2;\n  float c, tt;\n  q = vec2 (dot (p.yzx, n), dot (p.zxy, n));\n  q = 2. * pi * mod (q, 1.) - 256.;\n  t += 11.;\n  c = 0.;\n  qq = q;\n  for (int k = 1; k <= 7; k ++) {\n    tt = t * (1. + 1. / float (k));\n    a1 = tt - qq;\n    a2 = tt + qq;\n    qq = q + tt + vec2 (cos (a1.x) + sin (a2.y), sin (a1.y) + cos (a2.x));\n    c += 1. / length (q / vec2 (sin (qq.x), cos (qq.y)));\n  }\n  return clamp (pow (abs (1.25 - abs (0.167 + 40. * c)), 8.), 0., 1.);\n}\n\nfloat FinSh (vec3 rd)\n{\n  float u;\n  u = clamp (fh.dBody * 2. * pow (fh.dBump * 50., 2.) *\n     (1. - clamp (fh.dDors * 15., 0., 1.)) *\n     SmoothBump (-0.3, 3., 0.1, qHit.x) * 3., 0., 1.) +\n     smoothstep (3.8, 5.2, qHit.x) *\n     (1. - pow (max (1. - (fh.dBump * 100. + 0.5), 0.), 3.)) + fh.dBody * 3.;\n  return u * (rd.y * 0.5 + 0.7);\n}\n\nvec4 FishCol ()\n{\n  vec3 col, colTop, colBot, colBody, colHead, colMouth, colFin, colEye, pEye;\n  float spec, aEye, sEye;\n  pEye = qHit - vec3 (-1., 0., 0.4);\n  aEye = atan (pEye.x, pEye.y);\n  sEye = length (pEye);\n  if (sEye > 0.26) {\n    colBot = vec3 (1., 0.8, 0.6);\n    colTop = 0.8 * colBot;\n    colFin = vec3 (1., 1., 0.5);\n    colMouth = 1.5 * colBot;\n    colBody = mix (colTop, colBot, 1. - smoothstep (-0.2, 0.4, qHit.y) +\n       ScalesSh (fh.vSc.xy, fh.vSc.z));\n    colHead = mix (colTop, colBot, smoothstep (0., 0.5, sEye) *\n       smoothstep (0.5, 1.1, sEye));\n    colHead += 0.05 * (sin (aEye * 20. + sEye) *\n       sin (aEye * 3. - sEye * 4.) * (sin (sEye * 10.) + 1.));\n    colHead = mix (colMouth, colHead, smoothstep (0., 0.2, fh.dMouth));\n    col = mix (colFin, mix (colBody, colHead, smoothstep (0.8, 1., fh.dTail)),\n       clamp (1. - (fh.dBody - 0.01) * 50., 0., 1.)) *\n       (0.125 * (sin (sEye * 5.) + 1.) * (sin (fh.dDors * 10.) + 1.) + 0.5);\n    spec = 0.3;\n  } else {\n    colEye = vec3 (0.8, 0.6, 0.2);\n    col = colEye + sin (aEye * 2. * pi + 0.3) * sin (aEye * pi) * 0.1;\n    col *= smoothstep (0.13, 0.15, sEye) *\n       (1.25 - smoothstep (0.19, 0.25, sEye));\n    spec = 0.6;\n  }\n  return vec4 (col, spec);\n}\n\nfloat WatShd (vec3 rd)\n{\n  vec2 p;\n  float t, h;\n  p = 20. * rd.xz / rd.y;\n  t = tCur * 2.;\n  h = sin (p.x * 2. + t * 0.77 + sin (p.y * 0.73 - t)) +\n     sin (p.y * 0.81 - t * 0.89 + sin (p.x * 0.33 + t * 0.34)) +\n     (sin (p.x * 1.43 - t) + sin (p.y * 0.63 + t)) * 0.5;\n  h *= smoothstep (0.5, 1., rd.y) * 0.04;\n  return h;\n}\n\nvec3 BgCol (vec3 rd)\n{\n  float u, t, gd, b;\n  u = rd.y + 1.;\n  t = tCur * 4.;\n  b = dot (vec2 (atan (rd.x, rd.z), 0.5 * pi - acos (rd.y)), vec2 (2., sin (rd.x)));\n  gd = clamp (sin (5. * b + t), 0., 1.) * clamp (sin (3.5 * b - t), 0., 1.) +\n     clamp (sin (21. * b - t), 0., 1.) * clamp (sin (17. * b + t), 0., 1.);\n  return vec3 (0.25, 0.4, 1.) * (0.24 + 0.44 * u * u) * (1. + gd * 0.05);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, bgCol, vn;\n  float dstObj, d, spec;\n  int idObj;\n  col = vec3 (0.);\n  bgCol = BgCol (rd);\n  dstObj = dstFar;\n  d = FObjRay (ro, rd);\n  if (d < dstObj) {\n    dstObj = d;\n    idObj = 1;\n  }\n  d = KObjRay (ro, rd);\n  if (d < dstObj) {\n    dstObj = d;\n    idObj = 2;\n  }\n  d = BObjRay (ro, rd);\n  if (d < dstObj) {\n    dstObj = d;\n    idObj = 3;\n  }\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1) {\n      col4 = FishCol ();\n      col = col4.rgb;\n      col = mix (col, bgCol * vec3 (1., 0.8, 0.7), FinSh (rd));\n      spec = col4.a;\n    } else if (idObj == 2) {\n      col = vec3 (0.2, 0.7, 0.3);\n      spec = 0.;\n    } else if (idObj == 3) {\n      col = 0.7 * mix (vec3 (1.), BgCol (reflect (rd, vn)), 0.7);\n      spec = 0.5;\n    }\n    col = col * (0.2 * bgCol +\n       0.2 * max (dot (vn, normalize (vec3 (- ltDir.x, ltDir.y, - ltDir.z))), 0.) +\n       0.2 * max (vn.y, 0.) + 0.6 * max (dot (vn, ltDir), 0.)) +\n       spec * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.);\n    col *= 0.5 + 0.5 * clamp (rd.y + 1., 0., 1.5);\n    col += 0.2 * TurbLt (0.03 * ro, abs (vn), 0.5 * tCur) *\n       smoothstep (-0.3, -0.1, vn.y);\n    col = mix (col, bgCol, smoothstep (0.3 * dstFar, dstFar, dstObj));\n  } else col = bgCol + WatShd (rd);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.8 * pi + 0.02 * pi * tCur;\n  el = -0.22 * pi * sin (0.017 * pi * tCur);\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.6 * pi * mPtr.y;\n  }\n  el = clamp (el, -0.2 * pi, 0.2 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n     mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 9., -10.);\n  rd = vuMat * normalize (vec3 (uv, 2.5));\n  ltDir = normalize (vec3 (0.2, 1., -0.2));\n  dstFar = 50.;\n  fragColor = vec4 (pow (ShowScene (ro, rd), vec3 (0.7)), 1.);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, cHashA3.xy)) * cHashM);\n}\n\nvec3 Hashv3f (float p)\n{\n  return fract (sin (vec3 (p, p + 1., p + 2.)) *\n     vec3 (cHashM, cHashM * 0.43, cHashM * 0.37));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nfloat PrRndBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ml3XWH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ml3XzB", "name": "rainbow rock", "author": "jasonaugur", "description": "test", "tags": ["raymarch", "lighting", "highlights"], "likes": 6, "viewed": 257, "date": "1480275139", "time_retrieved": "2024-06-20T18:44:36.251830", "image_code": "float box( vec3 p, vec3 d ) {\n\treturn max( max( abs(p.x)-d.x, abs(p.y)-d.y ), abs(p.z)-d.z );\n}\n\nfloat sphere( vec3 p, float r ) {\n\treturn length(p) - r;\n}\n\nfloat sdf_smin(float a, float b, float k)\n{\n\tfloat res = exp(-k*a) + exp(-k*b);\n\treturn -log(max(0.0001,res)) / k;\n}\n\nvec2 rotate( vec2 v, float a ) {\n\treturn vec2( v.x * sin(a) + v.y * cos(a), v.y * sin(a) - v.x * cos(a) );\n}\n\nvec3 rotate( vec3 v, float a ) {\n\treturn vec3( rotate( v.xz, a ), v.y ).xzy;\n}\n\nfloat scene( vec3 p ) {\n\tvec3 b1 = p + vec3( 0., -.5, 0.);\n\tb1 = rotate(b1.yxz,3.14*.2).yxz;\n\tb1 = rotate(b1.xyz,3.14*.25).xyz;\n\treturn sdf_smin(\n        \tsdf_smin( sphere(p - vec3(0.,1.5,0.), .5), box(b1, vec3(.5)), 5.), \n        \tsphere(p,1.),5.-.5*sin(p.x*20.)-.5*sin(p.z*20.));\n}\n\nvec3 grad( vec3 p ) {\n\tvec2 eps = vec2( .01, 0. );\n\treturn normalize(\n\t   vec3( scene( p + eps.xyy),\n\t\t     scene( p + eps.yxy),\n\t\t     scene( p + eps.yyx) ) -\n\t   vec3( scene( p - eps.xyy),\n\t\t     scene( p - eps.yxy),\n\t\t     scene( p - eps.yyx) )\n\t\t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 sp = (fragCoord.xy / iResolution.xy) - .5;\n    sp.x *= iResolution.x/iResolution.y;\n\tvec3 o = vec3(0.,.5,-2.);\n\tvec3 v = normalize(vec3(sp, .5));\n\tvec3 l = normalize(vec3(.25,.25,-1.));\n\tfloat t = 3.1415926 * .5*sin(iTime);\n\to.xz = rotate( o.xz, t );\n\tv.xz = rotate( v.xz, t );\n\tl.xz = rotate( l.xz, t );\n    \n    vec3 n = vec3(0.);\n\tfor( int i = 0; i < 32; i++ ) {\n\t\tfloat dt = scene( o );\n\t\to += v * dt;\n\t\tif( dt < .01 )\n\t\t\tn = grad( o );\n\t}\n\t\n\tvec3 c = rotate(rotate(rotate(n.zxy, o.x*2.).zxy,o.y*2.).zxy,o.z*2.);\n    c = mix( c, n, clamp(abs(mod(iTime,20.)-10.)-5.,0.,1.));\n\tfragColor = vec4( (c *.5+.5) * (1.-dot(-n,v)) * dot(n,l) + pow(dot(n,l),64.), 1. );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ml3XzB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MlcSD8", "name": "Cymatic Spirals", "author": "metabog", "description": "Messing around with circles. Let it run for a bit, cool stuff happens after about 40-50secs. ", "tags": ["2d", "distancefields", "spiral", "moving"], "likes": 2, "viewed": 115, "date": "1479252797", "time_retrieved": "2024-06-20T18:44:36.251830", "image_code": "float circled(vec2 uv, vec2 pos, float rad) {\n\tfloat d = length(pos - uv) - rad;\n\treturn d;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\n#define nCircles 128\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy;\n\tvec2 center = iResolution.xy * 0.5;\n\tfloat radius = 0.025* iResolution.y;\n    \n    float anginc = (3.143*2.0)/float(nCircles);\n\tfloat ang = 0.0;\n   \tfragColor = vec4(0.1,0.8,0.25,1.0);\n\tvec4 col = vec4(0.4, 0.7,1.0,1.0);\n\n    float func = 1000.0;\n    \n    for(int i=0; i<nCircles;i++)\n    {\n        float move = cos(iTime+ang*iTime*0.1);\n        vec2 ps = center + vec2(cos(ang),sin(ang))*iResolution.x*0.26*move; \n        func = smin(func,circled(uv, ps, radius*abs(move)),70.0/iResolution.x);\n        ang+=anginc;\n    }\n    \n    fragColor = mix(fragColor,col*sign(-func),0.225);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlcSD8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MlcXD4", "name": "domain repetition", "author": "balkhan", "description": "experimenting with de's\ncomment line 8 for another shape", "tags": ["3d", "raymarching", "domainrepetition", "mandelbulb", "de"], "likes": 4, "viewed": 280, "date": "1479811087", "time_retrieved": "2024-06-20T18:44:36.258202", "image_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n*/\n\n#define PI\t\t3.14\n#define I_MAX\t50\n#define E_BULB\t0.001\n#define BULB // comment this line to see something else\n\nfloat\tbulb(vec3 pos);\nfloat\tde(vec3 pos);\nmat4\tlookat(vec3 eye, vec3 target, vec3 up);\nvec2 \tcmult(vec2 a, vec2 b);\nvec4\tmarch(vec3 pos, vec3 dir);\n\n/*\n* Taken from an iq's shader\n*/\n\nvec3 calcNormal( in vec3 pos, float e, vec3 dir)\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\n\treturn normalize(vec3(\n           march(pos+eps.xyy, dir).w - march(pos-eps.xyy, dir).w,\n           march(pos+eps.yxy, dir).w - march(pos-eps.yxy, dir).w,\n           march(pos+eps.yyx, dir).w - march(pos-eps.yyx, dir).w ));\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float   fov = 1.;\n\tvec3    forw  = vec3(0.0, 0.0, -1.0);\n\tvec3    right = vec3(1.0, 0.0, 0.0);\n\tvec3    up    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x-0.5) * right + (uv.y-0.5) * up + fov * forw));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4\tcol = vec4(0.0);\n    vec3\tpos = vec3(0.0, 0.0, 0.0);\n    vec3\tlight = vec3(-30.0, 30.0, -20.0);\n\tvec2\tuv = fragCoord.xy / iResolution.xy;\n    vec3\tdir = camera(uv);\n\n    vec4\tinter = (march(pos, dir));\n    vec3\tn = calcNormal(pos, E_BULB, dir);\n    // phong shading\n    if (inter.x < float(I_MAX))\n    {\n        vec3 vd = normalize(light - (pos+inter.w*dir));\n        float vdn = dot(vd, n);\n\t    col.xyz = vec3(1.0, 0.50, .25) * vd + dot(dir, n) * vdn;\n\t    col.xyz += vec3(dot(-dir, 2.0 * vdn * n - vd));\n    }\n   \tfragColor = col;\n}\n\nvec4\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0);\n    vec3\tp = vec3(0.0);\n    vec4\tstep = vec4(0.0);\n\n    for (int i = -1; i < I_MAX; ++i)\n    {\n    \tp = pos + dir * dist.y;\n        dist.x = de(p);\n        dist.y += dist.x;\n        if (dist.x < E_BULB)\n           break;\n        step.x++;\n    }\n    step.w = dist.y;\n    return (step);\n}\n\n/*\n*\tMandelbulb DE taken from Syntopia\n*/\n\nfloat\tde(vec3 pos)\n{\n#ifdef\tBULB\n    pos.x = 2.0*sin(pos.x+iTime/2.0);\n    pos.z = 2.0*sin(pos.z+iTime/2.0);\n    pos.y = sin(pos.y+iTime/2.0)+cos(pos.y+iTime/2.0);\n\n    vec3 z = pos;\n    float theta;\n    float phi;\n    float zr;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 10 ; i++)\n    {\n\t\tr = length(z);\n\t\tif (r > 2.0)\n            break;\n\t\ttheta = acos(z.z/r);\n\t\tphi = atan(z.y, z.x);\n        zr = r * r;\n        zr *= zr;\n        zr *= zr;\n\t\tdr =  zr * 8.0 * dr + .50;\n\t\tzr *= r;\n\t\ttheta = theta * 8.0;\n\t\tphi = phi * 8.0 + 30.0 * cos(iTime/3.0);\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz += pos;\n\t}\n\treturn (0.5*log(r)*r/dr);\n#endif\n#ifndef\tBULB\n    pos.x = cos(pos.x-pos.y+iTime/4.0)*cos(pos.x+pos.y-iTime/4.0);\n    pos.z = cos(pos.z+iTime/4.0)*cos(pos.z-iTime/4.0);\n    pos.y = cos(pos.y-pos.x+iTime/4.0)*cos(pos.y+pos.x-iTime/4.0);\n    return (length(pos)-0.125);\n#endif\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlcXD4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MlcXW7", "name": "Daily Shade day 21: Xmas tree", "author": "psonice", "description": "Not much time, so a quick hack. Tree-like, glass and shiny balls... it's an abstract xmas tree. Or something.", "tags": ["raymarch", "glass", "tree", "mirror", "xmas", "daily"], "likes": 4, "viewed": 675, "date": "1479912710", "time_retrieved": "2024-06-20T18:44:39.276164", "image_code": "/* \nDay 21: Some quick fun with ray mirroring for fractal-like shapes.\n*/\n\n//#define DEBUG\n#ifdef DEBUG\nint debugStep = 0;\nfloat debugValue = 0.0;\n#endif\n\n// Rotation\n#define R(p,a) p=cos(a)*p+sin(a)*vec2(-p.y,p.x);\n\n\n#define kINFINITY 10000.0 // An unimaginably large number\n#define kSQRT2 1.414213\n#define kISQRT2 0.707107\n#define kPI 3.141592\n\n// maximum iteration count\n#define kMAXITERS 200\n#define kEPSILON 0.001\n#define kMAXINTERSECTIONS 1\n\n// refractive index\n#define kREFRACT 1.0/1.5\n\n// materials\n#define kFLOORMATERIAL 0\n#define kGLASSMATERIAL 1\n#define kMIRRORMATERIAL 2\n#define kMATTEMATERIAL 3\n\n#define kFLOORCOLOUR vec3(0.7, 0.65, 0.6)\n#define kGLASSCOLOUR vec3(1.0, 0.1, 0.1)\n#define kMIRRORCOLOUR vec3(1, 1, 0.5)\n#define kMATTECOLOUR vec3(0.9, 0.85, 0.8)\n\n#define kZENITHCOLOUR vec3(0.3, 0.7, 1.0)\n#define kNADIRCOLOUR vec3(0.7, 0.6, 0.4)\n#define kHORIZONCOLOUR vec3(0.95)\n#define kSUNCOLOUR vec3(100, 90, 70)\n\n// A ray. Has origin + direction.\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n    \n// Distance to nearest surface\nstruct SDResult {\n    float d; // Distance\n    int material; // Nearest material\n};\n\n// A camera. Has a position and a direction. \nstruct Camera {\n    vec3 pos;\n    Ray ray;\n};\n    \n// A disk. Has position, size, colour.\nstruct Disk {\n    vec3 pos;\n    float radius;\n    vec3 col;\n};\n    \nstruct Sphere {\n    vec3 pos;\n    float radius;\n};\n    \nstruct Box {\n\tvec3 pos;\n\tvec3 size;\n    float radius;\n};\n    \nfloat eps = kEPSILON;\nfloat divergence;\n\nvec3 smoothBlend(in vec3 point, in vec3 about, in float radius) {\n    point -= about;\n    point = mix(-point, point, smoothstep(-radius, radius, point));\n    return point + about;\n}\n    \n// Distance to sphere (signed)\nfloat sphereDist(in Ray ray, in Sphere sphere) {\n    return length(ray.origin - sphere.pos) - sphere.radius;\n}\n\n// Distance to sphere surface\nfloat uSphereDist(in Ray ray, in Sphere sphere) {\n    return abs(length(ray.origin - sphere.pos) - sphere.radius);\n}\n\n// Distance to box surface (signed)\nfloat boxDist(in Ray ray, in Box box) {\n    vec3 dist = abs(ray.origin - box.pos) - (box.size * 0.5);\n    vec3 cDist = max(dist, 0.0);\n    return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(cDist) - box.radius;\n}\n\n// Distance to box surface\nfloat uBoxDist(in Ray ray, in Box box) {\n    return abs(length(max(abs(ray.origin - box.pos) - (box.size * 0.5), 0.0)) - box.radius);\n}\n\n// distance to floor\nfloat floorDist(in Ray ray) {\n    float dist = ray.origin.y;\n    return dist;\n}\n\n// traced coords of floor intersection, floor at height y\nvec2 floorPos(in Ray ray, in float y) {\n    float dist = (ray.origin.y - y) / ray.dir.y;\n \treturn ray.origin.xz + ray.dir.xz * dist; \n}\n\n/*\n---- Random/hash stuff ----\n*/\n\n// Normalised random number, borrowed from Hornet's noise distributions: https://www.shadertoy.com/view/4ssXRX\nfloat nrand(in vec2 n) {\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\n// random value based on texture channel 2\nvec3 texrand(in vec2 n, in float mipLevel) {\n    return texture(iChannel2, n, mipLevel).xyz;\n}\n\n// returns a hash value for a fixed size cell\nfloat hashForCell(in vec3 pos, in float cellSize) {\n    float hash = nrand(floor(pos.xz / cellSize) + 68.0);\n    return hash;\n}\n\n// returns a random colour based on the cell hash\nvec3 randomColourForCell(in vec3 pos, in float cellSize) {\n\tfloat hash = hashForCell(pos, cellSize); \n    return vec3(\n        nrand(vec2(hash * 2.0, hash * 4.0)),\n        nrand(vec2(hash * 4.0, hash * 8.0)),\n        nrand(vec2(hash * 8.0, hash * 16.0))\n\t);\n\tvec3 c = vec3(hash, mod(hash + 0.15, 1.0), mod(hash + 0.3, 1.0)) * 0.75;\n}\n\n/*\n---- INTERSECTION OPS ----\n*/\n\n// Union of two signed distances\nfloat unionOp(float d0, float d1) {\n    return min(d0, d1);\n}\n\n// Union of two unsigned distances\nfloat unionOpU(float d0, float d1) {\n    return min(d0, d1);\n}\n\nfloat smoothUnionOp(float d0, float d1, float r) {\n    float minD = min(d0, d1);\n    float maxD = max(d0, d1);\n    return mix(minD, maxD, 1. - smoothstep(0.0, r, maxD - minD));\n \treturn min(d0, d1);   \n}\n\n// Intersection of two signed distances\nfloat intersectOp(float d0, float d1) {\n    return max(d0, d1);\n}\n\n// Intersection of two unsigned distances\nfloat intersectOpU(float d0, float d1) {\n    return max(d0, d1);\n}\n\n// Difference of two signed distances\nfloat differenceOp(float d0, float d1) {\n    return max(d0, -d1);\n}\n\n// Difference of two unsigned distances\nfloat differenceOpU(float d0, float d1) {\n    return max(d0, -d1);\n}\n\n/*\n---- Scene rendering ----\n*/\n\n// Get the distance to the scene (returns a struct containing distance and nearest material)\nSDResult sceneDist(in Ray ray) {\n    SDResult result;\n    result.d = kINFINITY;\n    \n   \tSphere s0 = Sphere(vec3(0,0,0), 5.0);\n    float dist = sphereDist(ray, s0);\n    \n    ray.origin = abs(ray.origin);\n    \n    bool boolFlip = false;\n    float offset = 9.0;\n    float size = 4.0;\n    for (int i=0; i<4; i++) {\n        float newDist = min(\n            sphereDist(ray,  Sphere(vec3(offset,0,0), size)),\n            min(\n                sphereDist(ray,  Sphere(vec3(0,offset,0), size)),\n                sphereDist(ray,  Sphere(vec3(0,0,offset), size))\n            )\n        );\n        dist = min(dist, newDist);\n        if (dist == newDist) { boolFlip = !boolFlip; }\n        \n        offset += size * 1.8;\n        ray.origin.xy = R(ray.origin.xy, sin(iTime) * 0.2);\n        ray.origin.xz = R(ray.origin.xz, sin(iTime * 0.88) * 0.2);\n        ray.origin.yz = R(ray.origin.yz, sin(iTime * 1.11) * 0.2);\n        //ray.origin = abs(ray.origin);\n        ray.origin = smoothBlend(ray.origin, vec3(0), size);\n        size *= 0.8;\n    }\n    \n    \n    result.d = dist;\n   \n    result.material = boolFlip ? kGLASSMATERIAL : kMIRRORMATERIAL;\n    return result;\n}\n\n// Gets the normal\nvec3 normal(in Ray ray) {\n    vec2 eps = vec2(0.0001, 0);\n    float baseDist = sceneDist(ray).d;\n \treturn normalize(vec3(\n        sceneDist(Ray(ray.origin + eps.xyy, ray.dir)).d - baseDist,\n        sceneDist(Ray(ray.origin + eps.yxy, ray.dir)).d - baseDist,\n        sceneDist(Ray(ray.origin + eps.yyx, ray.dir)).d - baseDist\n        ));\n}\n\n// Moves the ray to the surface. Helps avoid artefacts due to ray intersection imprecision.\nvoid clampToSurface(in Ray ray, in float d, inout vec3 n) {\n \tray.origin += n * d;\n \td = sceneDist(ray).d;\n \tn = normal(ray);\n}\n\n// Calulcate a fresnel term for reflections\nfloat fresnelTerm(in Ray ray, in vec3 n, in float power) {\n\tfloat fresnel = min(1., dot(ray.dir, n) + 1.0);\n\tfresnel = pow(fresnel, power);\n    return fresnel;\n}\n\n// gets a reasonable texture coordinate from the normal\nvec2 texCoordFromNormal(in vec3 n) {\n\tvec2 c = n.xy * abs(n.z) + n.xz * abs(n.y) + n.yz * abs(n.x);\n    return c * 0.5 + 0.5;\n//    c.x = mix(n.x, n.y, abs(n.y) - abs(n.x));\n //   c.y = mix(n.y, n.z, abs(n.z) - abs(n.y));\n //   return c * 0.5 + 0.5;\n}\n\n/*\n---- LIGHTING ----\n*/\n\n// Pretty background colour of some sort...\nvec3 backgroundColour (in Ray ray, in float divergence) {\n    \n    // Declare a horizon and extremity (either zenith or nadir)\n    vec3 base, extremity, texture;\n    float x = smoothstep(0.0,1.0,abs(ray.dir.y));\n    \n    if (ray.dir.y >= 0.0) {\n        // sky: fake as hell clouds\n    \tbase = mix(kHORIZONCOLOUR, kZENITHCOLOUR, x);\n        texture = vec3(1);\n        float cloudFactor = 0.0;\n        \n        vec2 coord = ray.dir.xz / 8.0;\n        float scale = 1.0;\n        for (int i=0; i<4; i++) {\n            float offset = iTime * 0.03 / scale;\n            cloudFactor += texrand(coord + vec2(0, -offset), 3.0).r * scale;\n            coord *= 2.0;\n            scale *= 0.5;\n        }\n        cloudFactor /= 1.5;\n        vec3 cloud = mix(vec3(0.4), vec3(1), cloudFactor);\n        base = mix(base, cloud, cloudFactor * ray.dir.y * ray.dir.y);\n        \n    } else {\n        // ground: fake as hell desert\n        texture = kNADIRCOLOUR * 0.5;\n        vec2 floorCoord = floorPos(ray, -30.0);// + vec2(0, iTime * 100.0);\n        texture *= (sin(floorCoord.x * .183 + floorCoord.y * 0.183 + sin(floorCoord.y * 0.3) * 0.5) \n                    + sin(floorCoord.x * .15 + floorCoord.y * 0.22 + sin(floorCoord.x * 0.26) * 0.5))\n            * 0.25 + 0.5;\n\t\tbase = mix(kHORIZONCOLOUR, kNADIRCOLOUR + texture, x);\n        \n    }\n    \n    \n    return base;\n}\n\n// Technically broken, but seems to make soft shadows? *shrug*\nfloat occlusion(in Ray ray, in vec3 n) {\n    vec3 origin = ray.origin;\n    float o = 0.0;\n    ray.dir = n;\n    float x = eps;\n    origin += ray.dir * x;\n    for (float i=1.0; i<8.0; i++) {\n    \tray.origin = origin + ray.dir * x;\n        float d = sceneDist(ray).d;\n        o += max(x - d, 0.0) / x / i * 0.5;\n        \n        x *= 2.0;\n    }\n \treturn 1.0 - o;\n}\n\nvec3 light(in Ray ray, in vec3 n) {\n    // get the half-angle\n    ray.dir = (ray.dir, n) * 0.5;\n    return backgroundColour(ray, 0.0);\n}\n\n/*\n---- RAY MARCHING ----\n*/\n\n// The main marching loop\nvoid marchRay(inout Ray ray, inout vec3 colour) {\n    bool inside = false; // are we inside or outside the glass object\n    vec3 impact = vec3(1); // This decreases each time the ray passes through glass, darkening colours\n\n    vec3 startpoint = ray.origin;\n    \n#ifdef DEBUG   \nvec4 debugColour = vec4(1, 0, 0, 1);\n#endif\n    \n    SDResult result;\n    vec3 n;\n    vec3 glassStartPos;\n    \n    for (int i=0; i<kMAXITERS; i++) {\n        // Get distance to nearest surface\n        result = sceneDist(ray);\n        \n        // Step half that distance along ray (helps reduce artefacts)\n        float stepDistance = inside ? abs(result.d) : result.d;\n        ray.origin += ray.dir * stepDistance * 0.5;\n        if (length(ray.origin) > 40.0) { break; }\n        \n        if (stepDistance < eps) {\n            // colision\n            // normal\n            // Get the normal, then clamp the intersection to the surface\n    \t\tn = normal(ray);\n            //clampToSurface(ray, stepDistance, n);\n#ifdef DEBUG\n#endif\n            \n            if ( result.material == kMATTEMATERIAL ) {\n                // ray hit thing\n                \n                // tex coord from normal\n                vec2 coord = texCoordFromNormal(n);\n                \t\n                float fresnel = fresnelTerm(ray, n, 2.0);\n                \n                // Add some noise to the normal, since this is pretending to be grit...\n                vec3 randomNoise = texture(iChannel2, n.xy * .50, fresnel * 4.0).rgb;\n                randomNoise += texture(iChannel2, n.xz * .50, fresnel * 4.0).rgb;\n                randomNoise += texture(iChannel2, n.yz * .50, fresnel * 4.0).rgb;\n                randomNoise /= 3.0;\n                n = mix(n, randomNoise, 0.3);\n                colour = kMATTECOLOUR * light(ray, n) * vec3(occlusion(ray, n));\n                /*\n\t\t\t\tn = mix(n, normalize(vec3(randomNoise.x, 1, randomNoise.y)), randomNoise.z);\n                \n                // Colour is just grey with crappy fake lighting...\n                colour += mix(\n                    kFLOORCOLOUR, \n                    vec3(0), \n                    pow(max((-n.x+n.y) * 0.5, 0.0), 2.0)\n                ) * impact;\n\t\t\t\t*/\n                impact *= 0.;\n                break;\n            } else if (result.material == kFLOORMATERIAL) {\n               \t// Some textured floor...\n                vec2 coords = floorPos(ray, 0.0) * 0.2;\n                coords = mod(floor(coords),2.0);\n                \n                float occ = occlusion(ray, vec3(0,1,0));\n                colour = mix(colour, vec3(mod(coords.x + coords.y, 2.0)) * occ, 0.5);\n                impact *= 0.5;\n                ray.dir = reflect(ray.dir, vec3(0,1,0));\n                ray.origin += ray.dir * eps;\n                \n            }else if (result.material == kMIRRORMATERIAL) {\n                \n                // handle interior glass / other intersecion\n                if (inside) {\n                     float glassTravelDist =  min(distance(glassStartPos, ray.origin) / 16.0, 1.);\n    \t\t\t\tglassStartPos = ray.origin;\n                    // mix in the colour\n                \timpact *= mix(kGLASSCOLOUR, kGLASSCOLOUR * 0.1, glassTravelDist);\n                    \n                }\n                \n                float occ = occlusion(ray, n);\n                \n                // it's a mirror, reflect the ray\n                ray.dir = reflect(ray.dir, n);\n                    \n                // Step 2x epsilon into object along normal to ensure we're beyond the surface\n                // (prevents multiple intersections with same surface)\n                ray.origin += n * eps * 2.0;\n                \n                // Mix in the mirror colour\n                impact *= kMIRRORCOLOUR * occ;\n                \n            } else {\n                // glass material\n            \n                if (inside) {\n                \t// refract glass -> air\n                \tray.dir = refract(ray.dir, -n, 1.0/kREFRACT);\n                    \n                    // Find out how much to tint (how far through the glass did we go?)\n                    float glassTravelDist =  min(distance(glassStartPos, ray.origin) / 16.0, 1.);\n    \n                    // mix in the colour\n                \timpact *= mix(kGLASSCOLOUR, kGLASSCOLOUR * 0.1, glassTravelDist);\n                    \n#ifdef DEBUG\ndebugValue += glassTravelDist / 2.0;\n#endif\n      \n                \n              \t} else {\n               \t\t// refract air -> glass\n                \tglassStartPos = ray.origin;\n                    \n              \t  \t// Mix the reflection in, according to the fresnel term\n                \tfloat fresnel = fresnelTerm(ray, n, 1.0);\n                    fresnel = fresnel;\n    \t\t\t\t/*\n                    colour = mix(\n                    \tcolour, \n                    \ttexture(iChannel1, reflect(ray.dir, n)), \n                    \tvec4(fresnel) * impact);\n*/\n                    colour = mix(\n                        colour,\n                        backgroundColour(ray, 0.0),\n                        vec3(fresnel) * impact);\n                    impact *= 1.0 - fresnel;\n    \t\t\t\n                \t// refract the ray\n            \t\tray.dir = refract(ray.dir, n, kREFRACT);\n                    \n#ifdef DEBUG\n//debugValue += 0.5;\n#endif\n                }\n            \n            \t// Step 2x epsilon into object along normal to ensure we're beyond the surface\n                ray.origin += (inside ? n : -n) * eps * 2.0;\n                \n                // Flip in/out status\n                inside = !inside;\n            }\n        }\n        \n        // increase epsilon\n        eps += divergence * stepDistance;\n    }\n    \n    // So far we've traced the ray and accumulated reflections, now we need to add the background.\n   // colour += texture(iChannel0, ray.dir) * impact;\n    ray.origin = startpoint;\n    colour.rgb += backgroundColour(ray, 0.0) * impact;\n    \n#ifdef DEBUG\n//debugColour.rgb = ray.dir;\ndebugColour.rgb = vec3(float(debugStep)/2.0);\ncolour = debugColour;\n#endif\n}\n\n// Sets up a camera at a position, pointing at a target.\n// uv = fragment position (-1..1) and fov is >0 (<1 is telephoto, 1 is standard, 2 is fisheye-like)\nCamera setupCam(in vec3 pos, in vec3 target, in float fov, in vec2 uv) {\n\t\t// cam setup\n    // Create camera at pos\n\tCamera cam;\n    cam.pos = pos;\n    \n    // A ray too\n    Ray ray;\n    ray.origin = pos;\n    \n    // FOV is a simple affair...\n    uv *= fov;\n    \n    // Now we determine hte ray direction\n\tvec3 cw = normalize (target - pos );\n\tvec3 cp = vec3 (0.0, 1.0, 0.0);\n\tvec3 cu = normalize ( cross(cw,cp) );\n\tvec3 cv = normalize ( cross (cu,cw) );\n    \n\tray.dir = normalize ( uv.x*cu + uv.y*cv + 0.5 *cw);\n    \n    // Add the ray to the camera and our work here is done.\n\tcam.ray = ray;\n    \n    // Ray divergence\n    divergence = fov / iResolution.x;\n    \n\treturn cam;\n}\n\nvec3 camPath(in float time) {\n    float r = 40.0;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = mouse * kPI * 2.0 + kPI;\n    vec3 camPos = vec3(r, 8, 0);\n\t\n    R(camPos.xz, time + mouse.x);\n    R(camPos.zy, sin(time) * kPI + mouse.y);\n    \n    return camPos;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // We'll need a camera. And some perspective.\n    \n\t// Get some coords for the camera angle from the frag coords. Convert to -1..1 range.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2. - 1.;\n    \n    // Aspect correction so we don't get oval bokeh\n    uv.y *= iResolution.y/iResolution.x;\n    \n    // Make a camera with ALL NEW AND IMPROVED! camera code :)\n    float camTime = iTime / 4.0;\n    vec3 camPos = camPath(camTime);\n    vec3 camTarget = vec3(0, 6, 0);\n    //camTarget.y -= 3.0;\n    Camera cam = setupCam(camPos, camTarget, 0.500, uv);\n    \n    // Let's raymarch some stuff and inject that into the scene...\n    \n    // Create an empty colour\n    vec3 col = vec3(0);\n    \n    // Trace that ray!\n    marchRay(cam.ray, col);\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlcXW7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MldSWr", "name": "Weird Spiral", "author": "aiekick", "description": "Weird, Spiral", "tags": ["spiral", "weird"], "likes": 1, "viewed": 358, "date": "1479144254", "time_retrieved": "2024-06-20T18:44:39.276164", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy * 2. - iResolution.xy)/iResolution.y * 5.;\n\t\n\tfloat a = length(uv*0.5) * sin(iTime * 0.2);\n\t\n\tuv *= mat2(cos(a), -sin(a), sin(a), cos(a));\n\t\n\tuv = abs(uv)-5.*cos(iTime * 0.2);\n\t\n\tuv = vec2(atan(uv.x, uv.y)/3.14159*3., length(uv));\n\tuv = abs(fract(uv)-.5);\n    \n\tfloat b = sqrt(uv.x) + sqrt(uv.y);\n\tfloat c = sqrt(uv.x + uv.y);\n\t\n\tfloat s = b-c;\n\n\tfragColor = vec4(s);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MldSWr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MldXRN", "name": "Flower Df", "author": "aiekick", "description": "Flower Df", "tags": ["flower", "df"], "likes": 6, "viewed": 620, "date": "1478729244", "time_retrieved": "2024-06-20T18:44:39.276164", "image_code": "// Based on the shader Ellipse - Distance of iq : https://www.shadertoy.com/view/4sS3zz\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\n    float t = sin(iTime*0.2);\n\tfloat a = atan(uv.x, uv.y)/3.14159*3.;\n    \n    float d = length( uv) - mix(.5,0.5+1.*t,abs(fract(a)-.5));\n    \n    \n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*abs(d)+iTime*10.);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n\n\tfragColor = vec4( col, 1.0 );;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MldXRN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MldXRS", "name": "uncertain rings", "author": "mahalis", "description": "I was going for something sort of calm and psychedelic here; the codeâs a bit of a mess but I think it looks interesting.", "tags": ["stripes", "lensing"], "likes": 6, "viewed": 686, "date": "1480487099", "time_retrieved": "2024-06-20T18:44:39.700656", "image_code": "// hash functions from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE1 443.8975\nfloat hash11(float p) // assumes p in ~0-1 range\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\nvec2 hash21(float p) // assumes p in larger integer range\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n\n\nvec4 scaledAndLocalUVs(vec2 uv) {\n\tconst float cellResolution = 3.0;\n    vec2 scaledUV = uv * cellResolution;\n    scaledUV.x += floor(mod(scaledUV.y, 2.)) * 0.5;\n    vec2 localUV = (fract(scaledUV) - vec2(0.5)) * 2.;\n    localUV.y += sin(iTime * 1.3 + (hash12(floor(scaledUV) * 0.123) * 2. - 1.) * 3.14) * 0.1;\n    \n    vec4 result;\n    result.xy = scaledUV;\n    result.zw = localUV;\n    return result;\n}\n\nfloat gridMask(vec4 uvs, float thresholdOffset) {\n    return smoothstep(0.8, 0.9, length(uvs.zw) - thresholdOffset) + smoothstep(0.05, 0., length(uvs.zw) - 0.4 + thresholdOffset);\n}\n\nvec2 gridDistortion(vec4 uvs) {\n    vec2 scaledUV = uvs.xy;\n    vec2 localUV = uvs.zw;\n    \n    float localAngle = atan(localUV.y, localUV.x);\n    vec2 cellIndices = floor(scaledUV);\n    float layer1Speed = 2.9 * (hash12(cellIndices * 0.211) * 2. - 1.);\n    float layer2Speed = 2.3 * (hash12(cellIndices * 0.43 + 0.03) * 2. - 1.);\n    \n    float distortAmount = 1. + 0.3 * pow(sin(2.*localAngle - iTime * layer1Speed + hash12(cellIndices + vec2(5.3, 1.7))), 2.) + 0.25 * cos(5. * localAngle + iTime * layer2Speed + 3. * hash12(floor(scaledUV) * 100.) );\n    return normalize(localUV) * 0.2 * distortAmount * (1. - pow(1. - length(localUV), 3.));\n    \n}\n\nfloat stripes(float t) {\n    return smoothstep(-0.1, 0.1, abs(mod(t, 2.) - 1.) - 0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float overallShiftAngle = iTime * -0.19;\n\tvec2 uv = (fragCoord.xy / iResolution.y) + 0.3 * vec2(cos(overallShiftAngle), sin(overallShiftAngle));\n    \n    vec4 uvs = scaledAndLocalUVs(uv);\n    float mask = gridMask(uvs, -.05);\n    float stripeAngle = 2. + iTime * 0.1;\n    vec2 stripeDirection = vec2(cos(stripeAngle), sin(stripeAngle));\n    float stripeOffset = iTime * 0.1;\n    const float stripeMultiplier = 7.;\n    float backgroundStripeValue = stripes((dot(uv + .3*sin(uv.y*2.13), stripeDirection)) * stripeMultiplier  + stripeOffset);\n    float lensedStripeValue = stripes((dot(uv + gridDistortion(uvs), stripeDirection)) * stripeMultiplier + stripeOffset);\n    float lensColorMultiplier = (.6+1.4*pow(smoothstep(.5, 1., length(uvs.zw)), 0.6));\n    vec3 lensedColor = mix(vec3(0.4, 1.0, 0.05), vec3(0.1, 0.6, 1.), lensedStripeValue) * lensColorMultiplier;\n    vec3 backgroundColor = .4 * mix(vec3(0.1, 0.6, 1.0), vec3(0.0,0.2, 0.7), backgroundStripeValue);//mix(vec3(0.4, 1., 0.6), vec3(0.4, 0.8, 1.), backgroundStripeValue);//mix(vec3(1.0, 0.6, 0.1), vec3(1.0, 0.9, 0.1), backgroundStripeValue);\n    float shadowAmount = .1 * (mask - gridMask(uvs + vec4(0., 0., 0., .04), 0.02));\n\tfragColor = vec4(mix(lensedColor, backgroundColor, mask) - shadowAmount,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MldXRS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MldXW7", "name": "Rotating Tesseract", "author": "Vortex_", "description": "A 4D Cube rendered as a  \"3D shadow\". \n\nUsing 4D matrices to rotate the Tesseract in the 4th dimension.\n\nPlease come with suggestions if I have done something utterly wrong. :)", "tags": ["raymarching", "cube", "4d", "rotating", "tesseract", "hypercube"], "likes": 5, "viewed": 393, "date": "1480099688", "time_retrieved": "2024-06-20T18:44:39.700656", "image_code": "/*//////////////////////////\nCreator: Andreas Sorman \naka. \"Vortex\"\n\n\n\n*///////////////////////////\n\nfloat PI = 3.14159265359;\nfloat eps = .0001;\n\n\n//Models\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat udBox4D( vec4 p, vec4 b)\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdBox4D( vec4 p, vec4 b )\n{\n  vec4 d = abs(p) - b;\n  return min(max(d.x ,max(d.y,max(d.z,d.w))),0.0) + length(max(d,0.0));\n}\n\nmat4 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(1, 0, 0, 0),\n        vec4(0, 1, 0, 0),\n        vec4(0, 0, c, -s),\n        vec4(0, 0, s, c)\n    );\n}\n\nmat4 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(1, 0, 0, 0),\n        vec4(0, c, 0, -s),\n        vec4(0, 0, 1, 0),\n        vec4(0, s, 0, c)\n    );\n}\n\nmat4 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, 0, 0, s),\n        vec4(0, 1, 0, 0),\n        vec4(0, 0, 1, 0),\n        vec4(-s, 0, 0, c)\n    );\n}\n\n\nmat3 rotateX3D(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    \n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY3D(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    \n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ3D(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    \n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1, d2);\n}\n\n//Scene Where You Can Place Objects\nfloat scene(vec3 pos) { \n    \n    float time = iTime;\n    \n    float d = sdBox4D(vec4(pos*rotateZ3D(time)*rotateY3D(time)*rotateX3D(time),0)*rotateZ(time)*rotateY(time)*rotateX(time), vec4(.6));\n    \n    //d = opS(sdBox4D(vec4(pos*rotateZ3D(time)*rotateY3D(time)*rotateX3D(time),0)*rotateZ(time)*rotateY(time)*rotateX(time), vec4(1., .5, .5, .5)), d);\n    //d = opS(sdBox4D(vec4(pos*rotateZ3D(time)*rotateY3D(time)*rotateX3D(time),0)*rotateZ(time)*rotateY(time)*rotateX(time), vec4(.5, 1., .5, .5)), d);\n    //d = opS(sdBox4D(vec4(pos*rotateZ3D(time)*rotateY3D(time)*rotateX3D(time),0)*rotateZ(time)*rotateY(time)*rotateX(time), vec4(.5, .5, 1., .5)), d);\n    //d = opS(sdBox4D(vec4(pos*rotateZ3D(time)*rotateY3D(time)*rotateX3D(time),0)*rotateZ(time)*rotateY(time)*rotateX(time), vec4(.5, .5, .5, 1.)), d);         \n    \n    \n    return d;//opS(sdSphere(pos, 0.4), udBox(pos, vec3(0.3)));\n}\n\n//Get Normal\nvec3 normal(vec3 pos) {\n    float eps = 0.001;\n    \n    return normalize(vec3(\n    scene(pos + vec3(eps,0.,0.)) - scene(pos - vec3(eps,0.,0.)),\n    scene(pos + vec3(0.,eps,0.)) - scene(pos - vec3(0.,eps,0.)),\n    scene(pos + vec3(0.,0.,eps)) - scene(pos - vec3(0.,0.,eps))));\n}\n\n//Marching Until It Hits Something\nvec3 march(vec3 pos, vec3 dir) {    \n    vec3 rayPos = pos;    \n    float dis = eps;\n    \n    vec3 c = vec3(rayPos);  \n    \n    for(int i = 0; i < 50; i++) {                         \n       \tc = rayPos;\n      \n        if(dis < eps) {\n            c = normal(rayPos);\n            \n            break;\n        }\n                    \n        dis = scene(rayPos); \n        rayPos += dir*dis;                                                         \n    }\n    \n    return c;\n}\n\n//Renders The Final Image\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    //UV Setup\n    vec2 uv = -1.0 + 2.0 * (fragCoord.xy / iResolution.xy);\n    uv.y *= -1.;\n    uv.x *= 1.7777;\n   \n    vec3 pos = vec3(0., 1., -2.);\n    vec3 target = vec3(0.);\n    \n    //Setting Up Camera Vector\n    vec3 ww = normalize(target - pos);\n    vec3 uu = normalize(cross(vec3(0, 1, 0), ww));\n    vec3 vv = normalize(cross(ww, uu));\n    vec3 dir = normalize(uv.x*uu + uv.y*vv + ww);         \n    \n    vec3 c = normalize(abs(march(pos, dir)));       \n    \n    fragColor = vec4(c, 1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MldXW7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MldXWn", "name": "Electric Hydraulics", "author": "zackpudil", "description": "Future of dams. Dam electricity.\nUpdate: Made the flashing lights from electricity more subtle.\nUpdate: Added iapafoto suggestion. Thanks.\n\nThanks to FabriceNeyret2 as well for testing issues.", "tags": ["fractal"], "likes": 22, "viewed": 1408, "date": "1479148929", "time_retrieved": "2024-06-20T18:44:39.706696", "image_code": "//===== Common gpu randomness functions =====\n\nfloat hash(float n) {\n    return fract(sin(n)*4357.5453);\n}\n\nfloat noise(float g) {\n    float p = floor(g);\n    float f = fract(g);\n    \n    f = f*f*(3.0 - 2.0*f);\n    \n    return mix(hash(p), hash(p + 1.0), f);\n}\n\nfloat noise(vec3 g) {\n    vec3 p = floor(g);\n    vec3 f = fract(g);\n    \n    f = f*f*(3.0 - 2.0*f);\n    float n = p.x + 57.0*p.y + 113.0*p.z;\n    \n    float x = mix(hash(n), hash(n + 1.0), f.x);\n    float y = mix(hash(n + 57.0), hash(n + 58.0), f.x);\n    float z = mix(hash(n + 113.0), hash(n + 114.0), f.x);\n    float w = mix(hash(n + 170.0), hash(n + 171.0), f.x);\n    \n    return mix(mix(x, y, f.y), mix(z, w, f.y), f.z);\n}\n\nconst mat3 m3 = mat3(\n\t 0.00,  0.80,  0.60,\n\t-0.80,  0.36, -0.48,\n\t-0.60, -0.48,  0.64\n);\n\n\nfloat fbm(vec3 p) {\n\tfloat f = 0.0;\n\n\tf += 0.5000*noise(p); p *= m3*2.01;\n\tf += 0.2500*noise(p); p *= m3*2.02;\n\tf += 0.1250*noise(p); p *= m3*2.04;\n\tf += 0.0625*noise(p);\n\tf /= 0.9375;\n\n\treturn f;\n}\n    \n// ===============================\n\nvoid rotate(inout vec2 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    \n    p = mat2(c, s, -s, c)*p;\n}\n\nvec2 opU(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\nvec2 de(vec3 p) {\n    vec3 op = p;\n    p.x = abs(p.x) - 3.3;\n    p.z = mod(p.z + 2.0, 4.0) -  2.0;\n    vec4 q = vec4(p, 1);\n    q.xyz -= 1.0;\n\n    // simple kali fractal\n    q.xyz = q.zxy;\n    for(int i = 0; i < 6; i++) {\n        q.xyz = abs(q.xyz + 1.0) - 1.0;\n        q /= clamp(dot(q.xyz, q.xyz), 0.25, 1.0);\n        q *= 1.1;\n        \n        rotate(q.xy, -0.35);\n    }\n    \n    vec2 f = vec2((length(q.xyz) - 1.5)/q.w, 1.0);\n    \n    // floor, ceiling and walls.\n    f = opU(f, vec2(min(min(p.y + 1.7, -p.y + 2.0), min(op.x + 4.0, -op.x + 4.0)), 0.0));\n\n    // fake electricity.\n    vec3 sp = p;\n    sp.xz = abs(sp.xz) - 0.07;\n\trotate(sp.xz, 20.0*sp.y + 20.0*iTime + 5.0*noise(10.0*(op.z + p.y + 5.0*iTime)));\n    sp.xz += 0.02;\n    float g = smoothstep(-1.1, -1.0, -sp.y)*smoothstep(-1.0, -0.8, sp.y);\n    f = opU(f, vec2(length(sp.xz) - 0.03*hash(iTime)*g, 2.0));\n    \n    // pipes coming out of the fractal.\n    vec3 gp = p;\n    gp.y += 1.6 - smoothstep(-1.0, 1.0, p.x);\n    gp.x += 1.0;\n    gp.z += 0.1 - 0.4*(gp.x*gp.x)*smoothstep(0.0, 3.5, -p.x);\n    gp.z = abs(gp.z)- 0.2;\n    gp = abs(abs(gp) - 0.02) - 0.05;\n    f = opU(f, vec2(length(gp.zy) - 0.04, 3.0));\n    \n    // pipe running down the middle.\n    op.y += 1.6;\n    op.x = abs(op.x) - 0.1;\n    op = abs(abs(op) - 0.06) - 0.06;\n    f = opU(f, vec2(length(op.xy) - 0.05, 3.0));\n    \n    return f;\n}\n\nvec2 trace(vec3 ro, vec3 rd, float mx) {\n    float t = 0.0;\n    float m = 0.0;\n    for(int i = 0; i < 100; i++) {\n        vec2 s = de(ro + rd*t);\n        if(s.x < 0.0001 || t >= mx) break;\n        t += s.x*0.75;\n        m = s.y;\n    }\n    \n    return t < mx ? vec2(t, m) : vec2(-1.0);\n}\n\nvec3 normal(vec3 p) {\n    vec2 h = vec2(0.001, 0.0);\n    float m = de(p).y;\n    vec3 n = vec3(\n        de(p + h.xyy).x - de(p - h.xyy).x,\n        de(p + h.yxy).x - de(p - h.yxy).x,\n        de(p + h.yyx).x - de(p - h.yyx).x\n\t);\n    vec3 b = vec3(0);\n    if(m == 0.0) {\n        float f = 1.0;\n        b = vec3(\n            fbm(f*p + h.xyy) - fbm(f*p - h.xyy),\n            fbm(f*p + h.yxy) - fbm(f*p - h.yxy),\n            fbm(f*p + h.yyx) - fbm(f*p - h.yyx)\n\t\t);\n        b = normalize(b);\n    }\n    return normalize(n) + 0.3*b;\n}\n\nfloat ao(vec3 p, vec3 n) {\n    float o = 0.0, s = 0.005;\n    \n    for(int i = 0; i < 15; i++) {\n        float d = de(p + n*s).x;\n        o += (s - d);\n        s += s/(float(i) + 1.0);\n    }\n    \n    return 1.0 - clamp(o, 0.0, 1.0);\n}\n\nvec4 texcube(sampler2D s, vec3 p, vec3 n) {\n    vec3 m = pow(abs(n), vec3(10.0));\n    \n    vec4 x = texture(s, p.zy);\n    vec4 y = texture(s, p.xz);\n    vec4 z = texture(s, p.xy);\n    \n    return (m.x*x + m.y*y + m.z*z)/(m.x + m.y + m.z);\n}\n\nvec3 render(vec3 ro, vec3 rd, vec2 uv) {\n    vec3 col = vec3(0);\n    \n    vec2 t = trace(ro, rd, 20.0);\n    if(t.x < 0.0) return col;\n\n    vec3 pos = ro + rd*t.x;\n    vec3 nor = normal(pos);\n    vec3 ref = reflect(rd, nor);\n\n    vec3 key = pos;\n    key.z = mod(key.z + 2.0, 4.0) - 2.0;\n    vec3 lig = normalize(-key);\n    float dis = length(key) - 0.5;\n    float att = 1.0/(1.0 + 1.5*dis + 0.5*dis*dis);\n\n    float occ = ao(pos, nor); // ambient occlusion.\n    float dom = step(0.0, -trace(pos + nor*0.0001, ref, 2.0).x); // reflectance shadow.\n    float sha = step(0.0, -trace(pos + nor*0.001, lig, dis).x); // electic light shadow.\n\n    col = vec3(0.4);\n    \n    if(pos.y > -1.5) col *= occ*occ;\n    \n    if(t.y != 2.0) {\n        // shinny metal like material. Fresnel term with reflectance shadow.\n\t\tcol += 0.5*clamp(1.0 + dot(rd, nor), 0.0, 1.0)*dom;\n        \n        // light coming from the electricity.\n        col += att*hash(iTime)*clamp(dot(lig, nor), 0.0, 1.0)\n            *vec3(0.4, 0.4, 2.0)\n            *sha;\n    }\n\n    if(t.y == 1.0)\n        col *= texcube(iChannel0, 0.5*pos, nor).xyz; // kali fractal.\n    else if(t.y == 3.0)\n        col *= texcube(iChannel1, pos + iTime, nor).xyz*vec3(1.0, 5.0, 10.0); // pipes.\n\telse if(t.y == 2.0)\n        col *= vec3(0.5, 3.0, 50.0)*hash(iTime); // electricity.\n    \n\tcol = mix(col, vec3(0), 1.0 - exp(-0.2*t.x));\n   \treturn mix(col, vec3(1,5,10),exp(-abs(100.*cos(pos.z*.1+1.*iTime)))*(1.-occ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coords.\n\tvec2 uv = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    float time = iTime;\n    \n    // ray origi and direction.\n    float r = 3.5 + 1.0*cos(2.0*time);\n    vec3 ro = vec3(0, 0.0, time);\n    \n    vec3 ww = normalize(vec3(5.0*sin(time*0.3), 0.0, time + 1.0)-ro);\n    vec3 uu = normalize(cross(vec3(0, 1, 0), ww));\n    vec3 vv = normalize(cross(ww, uu));\n    \n    vec3 rd = normalize(uv.x*uu + uv.y*vv + 1.97*ww);\n    \n    vec3 col = render(ro, rd, uv);\n    \n    col = 1.0 - exp(-0.5*col); // tone mapping\n    col = pow(abs(col), vec3(1.0/2.2)); // gamma correction.\n\tfragColor = vec4(col, 1);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MldXWn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MldXz4", "name": "Menger2D", "author": "EvilRyu", "description": "...", "tags": ["2d", "fractal", "mengerspone"], "likes": 10, "viewed": 589, "date": "1478617435", "time_retrieved": "2024-06-20T18:44:39.706696", "image_code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat s=0.95,a=0.006,scale=3.;\nfloat d_box(vec2 q){float d=max(abs(q.x),abs(q.y));return smoothstep(s,s+a,d)+smoothstep(s-a,s-a-a,d);}\nfloat d_sph(vec2 q,float s){float d=pow(pow(abs(q.x),3.0)+pow(abs(q.y),3.0),1./3.);return smoothstep(s,s+a,d)+smoothstep(s-a,s-a-a,d);}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    vec3 col=vec3(1.0)*d_box(q);\n    float iter = mod(floor(iTime),7.0);\n    for(int i=0;i<4;++i)\n    {\n        if(i<int(iter+0.5))\n        {\n            q=abs(q);\n            if(q.x>q.y)q.xy=q.yx;\n            s*=1.0/scale;\n            col*=d_sph(q,s);\n            q-=s*(scale-1.);\n            if(q.x<-0.5*s*(scale-1.0))q.x+=s*(scale-1.0);\n        }\n        else\n        {\n            col*=d_sph(q,fract(iTime)*s/scale);\n        }\n    }\n    fragColor.xyz=col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MldXz4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MltSD4", "name": "polyhedron playground", "author": "russ", "description": "Just a bunch of Platonic and Archimedean solids.", "tags": ["raymarching", "polyhedra"], "likes": 22, "viewed": 750, "date": "1479876681", "time_retrieved": "2024-06-20T18:44:40.476295", "image_code": "//marching parameters\n#define FAR 30.\n#define EPS 0.005\n#define STEPS 128\n\n//precomputed folding planes\nconst vec2 tetra = vec2(.5, 0.707106781);\t\t\t\t\t\t\nconst vec2 octa = vec2(0.707106781, .5);\nconst vec2 dodeca = vec2(0.80901699, .30901699);\n\nfloat length2(vec3 p){\n\treturn dot(p,p);    \n}\n\n//knighty's fold-n-cut polyhedra\nfloat poly(vec3 p, int type, vec3 uvw){\n\tvec2 m = type==0 ? tetra : type==1 ? octa : dodeca;\n    vec3 nc = vec3(-.5,-m.x, m.y);\n    for(int i=0;i<5;i++){\n        p.xy = abs(p.xy);\n        p-=2.*min(0.,dot(p,nc))*nc;\n    }\n \tvec3 pab = vec3(0.,0.,1.);\n    vec3 pbc = vec3(m.y, 0., .5);\n    vec3 pca = vec3(0., m.y, m.x);\n    p -= normalize(uvw.x*pab+uvw.y*pbc+uvw.z*pca);\n    pbc = normalize(pbc); pca = normalize(pca);\n    float dp = max(dot(p,pab),max(dot(p,pbc),dot(p,pca)));\n    float dla=length2(p-min(0.,p.x)*vec3(1.,0.,0.));\n\tfloat dlb=length2(p-min(0.,p.y)*vec3(0.,1.,0.));\n\tfloat dlc=length2(p-min(0.,dot(p,nc))*nc);\n\treturn min(dp-0.043,sqrt(min(min(dla,dlb),dlc))-0.05);\n}\n    \nfloat DE(vec3 p){\n    vec3 modp = floor(p*0.25);\n\tp -=  2.+ 4. * modp;\n    //made up hash of position to an integer 0-15 to yield 16 different polyhedra\n    float index= mod(5.*modp.x+7.*modp.y+13.*modp.z,16.);\n    float modindex = mod(index, 7.);\n    //choosing the 'active mirrors' in the coxeter diagram, can be 1, 2 or all 3\n    vec3 uvw = vec3( (mod(modindex,2.) == 1. || modindex ==6.) ? 1. : 0.,\n                     (modindex < 4.) ? 1. : 0.,\n                     (modindex >= 2. && modindex < 6.) ? 1. : 0. );\n    //there are 7 unique shapes with octahedral symmetry, 7 with dodecahedral, 2 remaining with tetrahedral \n    int type =  index<7. ? 1 : index < 14. ? 2 : 0;\t\t\t\t\t\t\t\n    return poly(p, type, uvw);\n}\n\n//bog standard raymarcher, nothing to see here\nfloat trace(vec3 ro, vec3 rd){   \n    float t = 0.0, iter= 0.0, d;    \n    for (int i = 0; i < STEPS; i++){\n        d = DE(ro + rd*t);        \n        if(abs(d)<EPS*t || t>FAR) break;        \n        t += d*.75;  \n    }\n    if (d>=EPS*t) t = FAR;\n    else t+= d;\n    return t;\n}\n\n//quicker dirtier march for reflections\nfloat traceRef(vec3 ro, vec3 rd){    \n    float t = 0.001, d; \n    for (int i = 0; i < STEPS/2; i++){\n        d = DE(ro + rd*t);       \n        if(abs(d)<EPS || t>FAR) break;        \n        t += d;\n    }   \n    if (d>=EPS*t) t = FAR;\n    else t+= d;\n    return t;\n}\n\n//classic soft shadows\nfloat softShadow(vec3 ro, vec3 lp, float k){\n    const int maxIterationsShad = 20;     \n    vec3 rd = (lp-ro); \n    float shade = 1.0;\n    float dist = 0.005;    \n    float end = max(length(rd), 0.001);\n    float stepDist = end/float(maxIterationsShad);   \n    rd *= 1./end;\n    for (int i=0; i<maxIterationsShad; i++){\n        float h = DE(ro + rd*dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); \n        dist += clamp( h, .02, stepDist*2. ); \n        if (h<0.005 || dist > end) break; \n    }\n    return min(max(shade, 0.) + 0.25, 1.0); \n}\n\n//6-tap gradient\nvec3 getNormal( in vec3 p ){\n    vec2 e = vec2(0.005, 0.); \n    return normalize(vec3(DE(p+e.xyy)-DE(p-e.xyy),DE(p+e.yxy)-DE(p-e.yxy),DE(p+e.yyx)-DE(p-e.yyx)));\n}\n\n//Another made-up hashfunction for color   \nvec3 getColor(vec3 p){    \n    vec3 col = vec3(1);\n    vec3 fl = floor(p*.25);    \n    return fract(fl*153.745 + fl.zxy*652.2356+ fl.yzx * 98.346); \t\t\t\n}\n\n//standard phong lighting but taking R instead of V to save a reflect \nvec3 light(vec3 sp, vec3 ref, vec3 sn, vec3 lp){  \n    vec3 ld = lp-sp; \n    float lDist = max(length(ld), 0.001); \n    ld /= lDist;    \n    float atten = 1. / (1.0 + lDist*0.2 + lDist*lDist*0.1);\n    float diff = max(dot(sn, ld), 0.);\n    float spec = pow(max( dot( ref , ld ), 0.0 ), 200.0);\n    vec3 col = getColor(sp);\n    return (col*((diff-spec) + 0.15) + spec*1.5) * atten;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    //wide-angle camera ray\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.y;\n    vec3 rd = normalize(vec3(uv, 0.4));\n    //trig identities for double angles, then yaw and pitch ray at different speeds\n    float c = cos(iTime * 0.15), s = sin(iTime * 0.15), c2 = 2.*c*c-1., s2 = 2.*s*c ;\n    rd.xy = mat2(c2, s2, -s2, c2)*rd.xy;\n    rd.xz = mat2(c, s, -s, c)*rd.xz;\n    vec3 ro = vec3(0., 0., iTime*1.5);\n    vec3 lp = ro + vec3(0., 1., -.5);    \n    float t = trace(ro, rd);\n    vec3 col = vec3(0.);\n    float fog = smoothstep(0., .95, t/FAR);\n    //do lights only if hit found\n    if(t<FAR){\n    \tro += rd*t;\n    \tvec3 sn = getNormal(ro);\n        rd = reflect(rd, sn);\n    \tcol += light(ro, rd, sn, lp);\n    \tfloat sh = softShadow(ro+EPS*sn, lp, 16.); \t\n    \tt = traceRef(ro +  rd, rd);\n        if(t<FAR){\n        \tro += rd*t;\n    \t\tsn = getNormal(ro);\n            rd = reflect(rd, sn);\n    \t\tcol += light(ro, rd, sn, lp)*.15;\n        }   \n    \tcol *= sh;\n    }\n    col = mix(col, vec3(0), fog); \n    fragColor = vec4(pow(col,vec3(0.45)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MltSD4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MltSWN", "name": "Daily Shade day 20: mmmetaballs", "author": "psonice", "description": "Intended to make metaballs, ready to use the technique for something else. Got it wrong ;) Also added some light + AO.", "tags": ["raymarch", "daily"], "likes": 7, "viewed": 557, "date": "1479751821", "time_retrieved": "2024-06-20T18:44:43.664491", "image_code": "/* \nDay 20: With backgrounds part-done, itâs time to get distractedâ¦\nFixed the occlusion, added some lighting, made a blobby thing.\nThe blobby thing should be more blobby than this, but I canât\nremember how to do the smooth-junction operation and no internet.\nClose, but no banana.\n*/\n\n//#define DEBUG\n#ifdef DEBUG\nint debugStep = 0;\nfloat debugValue = 0.0;\n#endif\n\n// Rotation\n#define R(p,a) p=cos(a)*p+sin(a)*vec2(-p.y,p.x);\n\n\n#define kINFINITY 10000.0 // An unimaginably large number\n#define kSQRT2 1.414213\n#define kISQRT2 0.707107\n#define kPI 3.141592\n\n// maximum iteration count\n#define kMAXITERS 200\n#define kEPSILON 0.001\n#define kMAXINTERSECTIONS 1\n\n// refractive index\n#define kREFRACT 1.0/1.5\n\n// materials\n#define kFLOORMATERIAL 0\n#define kGLASSMATERIAL 1\n#define kMIRRORMATERIAL 2\n#define kMATTEMATERIAL 3\n\n#define kFLOORCOLOUR vec3(0.7, 0.65, 0.6)\n#define kGLASSCOLOUR vec3(1.0, 0.5, 0.1)\n#define kMIRRORCOLOUR vec3(0.8)\n#define kMATTECOLOUR vec3(0.9, 0.85, 0.8)\n\n#define kZENITHCOLOUR vec3(0.3, 0.7, 1.0)\n#define kNADIRCOLOUR vec3(0.7, 0.6, 0.4)\n#define kHORIZONCOLOUR vec3(0.95)\n#define kSUNCOLOUR vec3(100, 90, 70)\n\n// A ray. Has origin + direction.\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n    \n// Distance to nearest surface\nstruct SDResult {\n    float d; // Distance\n    int material; // Nearest material\n};\n\n// A camera. Has a position and a direction. \nstruct Camera {\n    vec3 pos;\n    Ray ray;\n};\n    \n// A disk. Has position, size, colour.\nstruct Disk {\n    vec3 pos;\n    float radius;\n    vec3 col;\n};\n    \nstruct Sphere {\n    vec3 pos;\n    float radius;\n};\n    \nstruct Box {\n\tvec3 pos;\n\tvec3 size;\n    float radius;\n};\n    \nfloat eps = kEPSILON;\nfloat divergence;\n\nvec3 smoothBlend(in vec3 point, in vec3 about, in float radius) {\n    point -= about;\n    point = mix(-point, point, smoothstep(-radius, radius, point));\n    return point + about;\n}\n    \n// Distance to sphere (signed)\nfloat sphereDist(in Ray ray, in Sphere sphere) {\n    return length(ray.origin - sphere.pos) - sphere.radius;\n}\n\n// Distance to sphere surface\nfloat uSphereDist(in Ray ray, in Sphere sphere) {\n    return abs(length(ray.origin - sphere.pos) - sphere.radius);\n}\n\n// Distance to box surface (signed)\nfloat boxDist(in Ray ray, in Box box) {\n    vec3 dist = abs(ray.origin - box.pos) - (box.size * 0.5);\n    vec3 cDist = max(dist, 0.0);\n    return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(cDist) - box.radius;\n}\n\n// Distance to box surface\nfloat uBoxDist(in Ray ray, in Box box) {\n    return abs(length(max(abs(ray.origin - box.pos) - (box.size * 0.5), 0.0)) - box.radius);\n}\n\n// distance to floor\nfloat floorDist(in Ray ray) {\n    float dist = ray.origin.y;\n    return dist;\n}\n\n// traced coords of floor intersection, floor at height y\nvec2 floorPos(in Ray ray, in float y) {\n    float dist = (ray.origin.y - y) / ray.dir.y;\n \treturn ray.origin.xz + ray.dir.xz * dist; \n}\n\n/*\n---- Random/hash stuff ----\n*/\n\n// Normalised random number, borrowed from Hornet's noise distributions: https://www.shadertoy.com/view/4ssXRX\nfloat nrand(in vec2 n) {\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\n// random value based on texture channel 2\nvec3 texrand(in vec2 n, in float mipLevel) {\n    return texture(iChannel2, n, mipLevel).xyz;\n}\n\n// returns a hash value for a fixed size cell\nfloat hashForCell(in vec3 pos, in float cellSize) {\n    float hash = nrand(floor(pos.xz / cellSize) + 68.0);\n    return hash;\n}\n\n// returns a random colour based on the cell hash\nvec3 randomColourForCell(in vec3 pos, in float cellSize) {\n\tfloat hash = hashForCell(pos, cellSize); \n    return vec3(\n        nrand(vec2(hash * 2.0, hash * 4.0)),\n        nrand(vec2(hash * 4.0, hash * 8.0)),\n        nrand(vec2(hash * 8.0, hash * 16.0))\n\t);\n\tvec3 c = vec3(hash, mod(hash + 0.15, 1.0), mod(hash + 0.3, 1.0)) * 0.75;\n}\n\n/*\n---- INTERSECTION OPS ----\n*/\n\n// Union of two signed distances\nfloat unionOp(float d0, float d1) {\n    return min(d0, d1);\n}\n\n// Union of two unsigned distances\nfloat unionOpU(float d0, float d1) {\n    return min(d0, d1);\n}\n\nfloat smoothUnionOp(float d0, float d1, float r) {\n    float minD = min(d0, d1);\n    float maxD = max(d0, d1);\n    return mix(minD, maxD, 1. - smoothstep(0.0, r, maxD - minD));\n \treturn min(d0, d1);   \n}\n\n// Intersection of two signed distances\nfloat intersectOp(float d0, float d1) {\n    return max(d0, d1);\n}\n\n// Intersection of two unsigned distances\nfloat intersectOpU(float d0, float d1) {\n    return max(d0, d1);\n}\n\n// Difference of two signed distances\nfloat differenceOp(float d0, float d1) {\n    return max(d0, -d1);\n}\n\n// Difference of two unsigned distances\nfloat differenceOpU(float d0, float d1) {\n    return max(d0, -d1);\n}\n\n/*\n---- Scene rendering ----\n*/\n\n// Get the distance to the scene (returns a struct containing distance and nearest material)\nSDResult sceneDist(in Ray ray) {\n    SDResult result;\n    result.d = kINFINITY;\n    \n    float t = iTime * 1.;\n    \n    for (float i=0.0; i<8.0; i++) {\n       \t// random spheres...\n        Sphere s = Sphere(\n            vec3(\n                sin(i*0.8 + t), \n                sin(i*0.825 + i + t), \n                sin(i*0.8 + i*1.2 + t)) * 7.0,\n            3.0);\n        result.d = smoothUnionOp(result.d, sphereDist(ray, s), 1.0);\n    }\n   \n    result.material = kMATTEMATERIAL;\n    return result;\n}\n\n// Gets the normal\nvec3 normal(in Ray ray) {\n    vec2 eps = vec2(0.0001, 0);\n    float baseDist = sceneDist(ray).d;\n \treturn normalize(vec3(\n        sceneDist(Ray(ray.origin + eps.xyy, ray.dir)).d - baseDist,\n        sceneDist(Ray(ray.origin + eps.yxy, ray.dir)).d - baseDist,\n        sceneDist(Ray(ray.origin + eps.yyx, ray.dir)).d - baseDist\n        ));\n}\n\n// Moves the ray to the surface. Helps avoid artefacts due to ray intersection imprecision.\nvoid clampToSurface(in Ray ray, in float d, inout vec3 n) {\n \tray.origin += n * d;\n \td = sceneDist(ray).d;\n \tn = normal(ray);\n}\n\n// Calulcate a fresnel term for reflections\nfloat fresnelTerm(in Ray ray, in vec3 n, in float power) {\n\tfloat fresnel = min(1., dot(ray.dir, n) + 1.0);\n\tfresnel = pow(fresnel, power);\n    return fresnel;\n}\n\n// gets a reasonable texture coordinate from the normal\nvec2 texCoordFromNormal(in vec3 n) {\n\tvec2 c = n.xy * abs(n.z) + n.xz * abs(n.y) + n.yz * abs(n.x);\n    return c * 0.5 + 0.5;\n//    c.x = mix(n.x, n.y, abs(n.y) - abs(n.x));\n //   c.y = mix(n.y, n.z, abs(n.z) - abs(n.y));\n //   return c * 0.5 + 0.5;\n}\n\n/*\n---- LIGHTING ----\n*/\n\n// Pretty background colour of some sort...\nvec3 backgroundColour (in Ray ray, in float divergence) {\n    \n    // Declare a horizon and extremity (either zenith or nadir)\n    vec3 base, extremity, texture;\n    float x = smoothstep(0.0,1.0,abs(ray.dir.y));\n    \n    if (ray.dir.y >= 0.0) {\n        // sky: fake as hell clouds\n    \tbase = mix(kHORIZONCOLOUR, kZENITHCOLOUR, x);\n        texture = vec3(1);\n        float cloudFactor = 0.0;\n        \n        vec2 coord = ray.dir.xz / 8.0;\n        float scale = 1.0;\n        for (int i=0; i<4; i++) {\n            float offset = iTime * 0.03 / scale;\n            cloudFactor += texrand(coord + vec2(0, -offset), 3.0).r * scale;\n            coord *= 2.0;\n            scale *= 0.5;\n        }\n        cloudFactor /= 1.5;\n        vec3 cloud = mix(vec3(0.4), vec3(1), cloudFactor);\n        base = mix(base, cloud, cloudFactor * ray.dir.y * ray.dir.y);\n        \n    } else {\n        // ground: fake as hell desert\n        texture = kNADIRCOLOUR * 0.5;\n        vec2 floorCoord = floorPos(ray, -30.0);// + vec2(0, iTime * 100.0);\n        texture *= (sin(floorCoord.x * .183 + floorCoord.y * 0.183 + sin(floorCoord.y * 0.3) * 0.5) \n                    + sin(floorCoord.x * .15 + floorCoord.y * 0.22 + sin(floorCoord.x * 0.26) * 0.5))\n            * 0.25 + 0.5;\n\t\tbase = mix(kHORIZONCOLOUR, kNADIRCOLOUR + texture, x);\n        \n    }\n    \n    \n    return base;\n}\n\n// Technically broken, but seems to make soft shadows? *shrug*\nfloat occlusion(in Ray ray, in vec3 n) {\n    vec3 origin = ray.origin;\n    float o = 0.0;\n    ray.dir = n;\n    float x = eps;\n    origin += ray.dir * x;\n    for (float i=1.0; i<8.0; i++) {\n    \tray.origin = origin + ray.dir * x;\n        float d = sceneDist(ray).d;\n        o += max(x - d, 0.0) / x / i * 0.5;\n        \n        x *= 2.0;\n    }\n \treturn 1.0 - o;\n}\n\nvec3 light(in Ray ray, in vec3 n) {\n    // get the half-angle\n    ray.dir = (ray.dir, n) * 0.5;\n    return backgroundColour(ray, 0.0);\n}\n\n/*\n---- RAY MARCHING ----\n*/\n\n// The main marching loop\nvoid marchRay(inout Ray ray, inout vec3 colour) {\n    bool inside = false; // are we inside or outside the glass object\n    vec3 impact = vec3(1); // This decreases each time the ray passes through glass, darkening colours\n\n    vec3 startpoint = ray.origin;\n    \n#ifdef DEBUG   \nvec4 debugColour = vec4(1, 0, 0, 1);\n#endif\n    \n    SDResult result;\n    vec3 n;\n    vec3 glassStartPos;\n    \n    for (int i=0; i<kMAXITERS; i++) {\n        // Get distance to nearest surface\n        result = sceneDist(ray);\n        \n        // Step half that distance along ray (helps reduce artefacts)\n        float stepDistance = inside ? abs(result.d) : result.d;\n        ray.origin += ray.dir * stepDistance * 0.3;\n        if (length(ray.origin) > 40.0) { break; }\n        \n        if (stepDistance < eps) {\n            // colision\n            // normal\n            // Get the normal, then clamp the intersection to the surface\n    \t\tn = normal(ray);\n            //clampToSurface(ray, stepDistance, n);\n#ifdef DEBUG\n#endif\n            \n            if ( result.material == kMATTEMATERIAL ) {\n                // ray hit thing\n                \n                // tex coord from normal\n                vec2 coord = texCoordFromNormal(n);\n                \t\n                float fresnel = fresnelTerm(ray, n, 2.0);\n                \n                // Add some noise to the normal, since this is pretending to be grit...\n                vec3 randomNoise = texture(iChannel2, n.xy * .50, fresnel * 4.0).rgb;\n                randomNoise += texture(iChannel2, n.xz * .50, fresnel * 4.0).rgb;\n                randomNoise += texture(iChannel2, n.yz * .50, fresnel * 4.0).rgb;\n                randomNoise /= 3.0;\n                n = mix(n, randomNoise, 0.3);\n                colour = kMATTECOLOUR * light(ray, n) * vec3(occlusion(ray, n));\n                /*\n\t\t\t\tn = mix(n, normalize(vec3(randomNoise.x, 1, randomNoise.y)), randomNoise.z);\n                \n                // Colour is just grey with crappy fake lighting...\n                colour += mix(\n                    kFLOORCOLOUR, \n                    vec3(0), \n                    pow(max((-n.x+n.y) * 0.5, 0.0), 2.0)\n                ) * impact;\n\t\t\t\t*/\n                impact *= 0.;\n                break;\n            }\n            \n            // check what material it is...\n            \n            if (result.material == kMIRRORMATERIAL) {\n                \n                // handle interior glass / other intersecion\n                if (inside) {\n                     float glassTravelDist =  min(distance(glassStartPos, ray.origin) / 16.0, 1.);\n    \t\t\t\tglassStartPos = ray.origin;\n                    // mix in the colour\n                \timpact *= mix(kGLASSCOLOUR, kGLASSCOLOUR * 0.1, glassTravelDist);\n                    \n                }\n                \n                // it's a mirror, reflect the ray\n                ray.dir = reflect(ray.dir, n);\n                    \n                // Step 2x epsilon into object along normal to ensure we're beyond the surface\n                // (prevents multiple intersections with same surface)\n                ray.origin += n * eps * 2.0;\n                \n                // Mix in the mirror colour\n                impact *= kMIRRORCOLOUR;\n                \n            } else {\n                // glass material\n            \n                if (inside) {\n                \t// refract glass -> air\n                \tray.dir = refract(ray.dir, -n, 1.0/kREFRACT);\n                    \n                    // Find out how much to tint (how far through the glass did we go?)\n                    float glassTravelDist =  min(distance(glassStartPos, ray.origin) / 16.0, 1.);\n    \n                    // mix in the colour\n                \timpact *= mix(kGLASSCOLOUR, kGLASSCOLOUR * 0.1, glassTravelDist);\n                    \n#ifdef DEBUG\ndebugValue += glassTravelDist / 2.0;\n#endif\n      \n                \n              \t} else {\n               \t\t// refract air -> glass\n                \tglassStartPos = ray.origin;\n                    \n              \t  \t// Mix the reflection in, according to the fresnel term\n                \tfloat fresnel = fresnelTerm(ray, n, 1.0);\n                    fresnel = fresnel;\n    \t\t\t\t/*\n                    colour = mix(\n                    \tcolour, \n                    \ttexture(iChannel1, reflect(ray.dir, n)), \n                    \tvec4(fresnel) * impact);\n*/\n                    colour = mix(\n                        colour,\n                        backgroundColour(ray, 0.0),\n                        vec3(fresnel) * impact);\n                    impact *= 1.0 - fresnel;\n    \t\t\t\n                \t// refract the ray\n            \t\tray.dir = refract(ray.dir, n, kREFRACT);\n                    \n#ifdef DEBUG\n//debugValue += 0.5;\n#endif\n                }\n            \n            \t// Step 2x epsilon into object along normal to ensure we're beyond the surface\n                ray.origin += (inside ? n : -n) * eps * 2.0;\n                \n                // Flip in/out status\n                inside = !inside;\n            }\n        }\n        \n        // increase epsilon\n        eps += divergence * stepDistance;\n    }\n    \n    // So far we've traced the ray and accumulated reflections, now we need to add the background.\n   // colour += texture(iChannel0, ray.dir) * impact;\n    ray.origin = startpoint;\n    colour.rgb += backgroundColour(ray, 0.0) * impact;\n    \n#ifdef DEBUG\n//debugColour.rgb = ray.dir;\ndebugColour.rgb = vec3(float(debugStep)/2.0);\ncolour = debugColour;\n#endif\n}\n\n// Sets up a camera at a position, pointing at a target.\n// uv = fragment position (-1..1) and fov is >0 (<1 is telephoto, 1 is standard, 2 is fisheye-like)\nCamera setupCam(in vec3 pos, in vec3 target, in float fov, in vec2 uv) {\n\t\t// cam setup\n    // Create camera at pos\n\tCamera cam;\n    cam.pos = pos;\n    \n    // A ray too\n    Ray ray;\n    ray.origin = pos;\n    \n    // FOV is a simple affair...\n    uv *= fov;\n    \n    // Now we determine hte ray direction\n\tvec3 cw = normalize (target - pos );\n\tvec3 cp = vec3 (0.0, 1.0, 0.0);\n\tvec3 cu = normalize ( cross(cw,cp) );\n\tvec3 cv = normalize ( cross (cu,cw) );\n    \n\tray.dir = normalize ( uv.x*cu + uv.y*cv + 0.5 *cw);\n    \n    // Add the ray to the camera and our work here is done.\n\tcam.ray = ray;\n    \n    // Ray divergence\n    divergence = fov / iResolution.x;\n    \n\treturn cam;\n}\n\nvec3 camPath(in float time) {\n    float r = 20.0;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = mouse * kPI * 2.0 + kPI;\n    vec3 camPos = vec3(r, 0, 0);\n\t\n    R(camPos.xz, time + mouse.x);\n    R(camPos.zy, sin(time) * kPI + mouse.y);\n    \n    return camPos;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // We'll need a camera. And some perspective.\n    \n\t// Get some coords for the camera angle from the frag coords. Convert to -1..1 range.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2. - 1.;\n    \n    // Aspect correction so we don't get oval bokeh\n    uv.y *= iResolution.y/iResolution.x;\n    \n    // Make a camera with ALL NEW AND IMPROVED! camera code :)\n    float camTime = iTime / 4.0;\n    vec3 camPos = camPath(camTime);\n    vec3 camTarget = vec3(0);\n    //camTarget.y -= 3.0;\n    Camera cam = setupCam(camPos, camTarget, 0.500, uv);\n    \n    // Let's raymarch some stuff and inject that into the scene...\n    \n    // Create an empty colour\n    vec3 col = vec3(0);\n    \n    // Trace that ray!\n    marchRay(cam.ray, col);\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MltSWN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MltSzN", "name": "spider w", "author": "gigatron", "description": " by eiffie... played by gigatron", "tags": ["spider", "web"], "likes": 1, "viewed": 105, "date": "1478546956", "time_retrieved": "2024-06-20T18:44:43.670659", "image_code": "// Spiderweb by eiffie based on knighty's spirals - https://www.shadertoy.com/view/ls2GRz\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n#define time iTime*0.75\n#define size iResolution\n#define tex iChannel0\n\n#define PI 3.14159265358979323846264338327950288419716939937510\nconst vec2 c=vec2(32.0,1.0);\nconst float tpdlc=0.2137673;//precalculated 2*PI/length(c)\n//Draws two perpendicular spirals (from knighty and then I messed it up with gravity)\nfloat dspiral(vec3 p){//original https://www.shadertoy.com/view/ls2GRz\n\tfloat r=length(p.xy);\n\tvec2 f=vec2(log(r),atan(p.y,p.x))*0.5/PI;\n\tvec2 d=f.y*vec2(c.x,-c.y)-f.x*c.yx;\n\td=(0.5-abs(fract(d)-0.5))*r*tpdlc;\n\tfloat g=sqrt(abs(d.x-d.y));\n\tp.y+=g*0.1;//now add gravity\n\tp.xy*=1.0+g*0.00;//straighten a bit\n\tr=length(p.xy);//and recalculate the second spiral\n\tf=vec2(log(r),atan(p.y,p.x))*0.5/PI;\n\tfloat d1=-f.y*c.y-f.x*c.x;\n\td1=(0.5-abs(fract(d1)-0.5))*r*tpdlc;\n\treturn min(sqrt(d.x*d.x+p.z*p.z),max(sqrt(d1*d1+p.z*p.z),-r+2.0-sin(time/1.4)*8.));\n}\n\nmat3 lookat(vec3 fw,vec3 up){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,normalize(up)));return mat3(rt,cross(rt,fw),fw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec3 ro=vec3(-0.0-sin(time),-1.0+sin(time),-4.0);\n\t\n\tvec3 rd=lookat(-ro,vec3(1.0,1.,0.0))*normalize(vec3((1.0*fragCoord.xy-size.xy*0.5)/size.y,1.0));\n\t\n    vec3 col=vec3(2.);\n    vec3 bg=vec3(texture(iChannel0,fragCoord/iResolution.xy)).xyz/3.0;\n\tvec2 trap=vec2(100.0);\n\tfloat t=-(ro.z+0.5)/rd.z,d=1.0;\n\tfor(int i=0;i<24;i++){\n\t\tt+=d=dspiral(ro+rd*t)*0.8;\n\t\tif(d<trap.x)trap=vec2(d,t);\n\t}\n\tfloat mind=2.0*trap.y/size.y;\n\tif(trap.x>mind){\n         \n          col=mix(col,bg,min(1.0,smoothstep(1.0,mind,max(0.0,trap.x))))  ;\n         \n        }\n\tfragColor = vec4(clamp(col,0.0,1.0),1.0);\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MltSzN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MltXWn", "name": "bp Double Galaxy", "author": "blackpolygon", "description": ":D", "tags": ["colors", "pointcloud", "galaxy"], "likes": 27, "viewed": 642, "date": "1479076646", "time_retrieved": "2024-06-20T18:44:44.052401", "image_code": "// Author: blackpolygon\n// Title:  Double Galaxy\n\n// Based on 'Audio Eclipse' by airtight\n// https://www.shadertoy.com/view/MdsXWM\n\n\nconst float dots = 500.; \nfloat radius = 0.0025; \nconst float brightness = 0.0003;\n\n//convert HSV to RGB\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\t\t\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st=(fragCoord.xy-.5*iResolution.xy)/min(iResolution.x,iResolution.y);\n    vec3 c=vec3(0.0);\n    \n    st = rotate2d( sin(iTime/5.)*3.14 ) * st;\n\tfloat b1a0 = 0.5+sin(iTime)*0.5;\n    float b1a02 = 0.5+cos(iTime)*0.5;\n    float ra =  (0.5+sin(iTime/3.)*0.3)*0.002;\n    \n    //inner\n    for(float i=0.;i<dots/2.; i++){\n\t\t\t\n        radius +=ra;\n        \n\t\t//get location of dot\n        float x = radius*cos(2.*3.14*float(i)/(dots/(15.+b1a0)));\n        float y = radius*sin(2.*3.14*float(i)/(dots/(14. +b1a02)));\n        vec2 o = vec2(x,y);\n\t    \n\t\t//get color of dot based on its index in the \n\t\t//circle + time to rotate colors\n\t\tvec3 dotCol = hsv2rgb(vec3((i + iTime*5.)/ (dots/14.),1.,1.0));\n\t    \n        //get brightness of this pixel based on distance to dot\n\t\tc += brightness/(length(st-o))*dotCol;\n    }\n    \n    //outer\n    for(float i=0.;i<dots; i++){\n        radius += ra;\n        float y = radius*cos(2.*3.14*float(i)/(dots/(10.+b1a0)));\n        float x = radius*sin(2.*3.14*float(i)/(dots/(10. +b1a02)));\n        vec2 o = vec2(x,y);\n\t\tvec3 dotCol = hsv2rgb(vec3((i + iTime*5.)/ (dots/10.),1.,1.0));\n\t\tc += brightness/(length(st-o))*dotCol;\n    }\n\t \n\tfragColor = vec4(c,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MltXWn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MltXz7", "name": "Star layers", "author": "gigatron", "description": "Another Starfield based on HeGu snowy shader, converted to starfield 8 layers like amiga playfield ", "tags": ["starfield", "layer"], "likes": 7, "viewed": 580, "date": "1478871125", "time_retrieved": "2024-06-20T18:44:44.834336", "image_code": "#define dir 2    // define direction 0,1,2,3  up/down/left/right\n#define time iTime\n#define speed 0.4\n\nvec2 mod289(vec2 x) {\n\t\t  return x - floor(x * (1.0 / 289.0)) * 289.0;\n\t\t}\n\n\t\tvec3 mod289(vec3 x) {\n\t\t  \treturn x - floor(x * (1.0 / 289.0)) * 289.0;\n\t\t}\n\t\t\n\t\tvec4 mod289(vec4 x) {\n\t\t  \treturn x - floor(x * (1.0 / 289.0)) * 289.0;\n\t\t}\n\t\t\n\t\tvec3 permute(vec3 x) {\n\t\t  return mod289(((x*34.0)+1.0)*x);\n\t\t}\n\n\t\tvec4 permute(vec4 x) {\n\t\t  return mod((34.0 * x + 1.0) * x, 289.0);\n\t\t}\n\n\t\tvec4 taylorInvSqrt(vec4 r)\n\t\t{\n\t\t  \treturn 1.79284291400159 - 0.85373472095314 * r;\n\t\t}\n\t\t\n\t\tfloat snoise(vec2 v)\n\t\t{\n\t\t\t\tconst vec4 C = vec4(0.211324865405187,0.366025403784439,-0.577350269189626,0.024390243902439);\n\t\t\t\tvec2 i  = floor(v + dot(v, C.yy) );\n\t\t\t\tvec2 x0 = v -   i + dot(i, C.xx);\n\t\t\t\t\n\t\t\t\tvec2 i1;\n\t\t\t\ti1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\t\t\t\tvec4 x12 = x0.xyxy + C.xxzz;\n\t\t\t\tx12.xy -= i1;\n\t\t\t\t\n\t\t\t\ti = mod289(i); // Avoid truncation effects in permutation\n\t\t\t\tvec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t\t\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\t\t\t\t\n\t\t\t\tvec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n\t\t\t\tm = m*m ;\n\t\t\t\tm = m*m ;\n\t\t\t\t\n\t\t\t\tvec3 x = 2.0 * fract(p * C.www) - 1.0;\n\t\t\t\tvec3 h = abs(x) - 0.5;\n\t\t\t\tvec3 ox = floor(x + 0.5);\n\t\t\t\tvec3 a0 = x - ox;\n\t\t\t\t\n\t\t\t\tm *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\t\t\t\t\n\t\t\t\tvec3 g;\n\t\t\t\tg.x  = a0.x  * x0.x  + h.x  * x0.y;\n\t\t\t\tg.yz = a0.yz * x12.xz + h.yz * x12.yw;\n\n\t\t\t\treturn 130.0 * dot(m, g);\t\t\n\t\t}\n\t\t\n\t\tfloat cellular2x2(vec2 P)\n\t\t{\n\t\t\t\t#define K 0.142857142857 // 1/7\n\t\t\t\t#define K2 0.0714285714285 // K/2\n\t\t\t\t#define jitter 0.8 // jitter 1.0 makes F1 wrong more often\n\t\t\t\t\n\t\t\t\tvec2 Pi = mod(floor(P), 289.0);\n\t\t\t\tvec2 Pf = fract(P);\n\t\t\t\tvec4 Pfx = Pf.x + vec4(-0.5, -1.5, -0.5, -1.5);\n\t\t\t\tvec4 Pfy = Pf.y + vec4(-0.5, -0.5, -1.5, -1.5);\n\t\t\t\tvec4 p = permute(Pi.x + vec4(0.0, 1.0, 0.0, 1.0));\n\t\t\t\tp = permute(p + Pi.y + vec4(0.0, 0.0, 1.0, 1.0));\n\t\t\t\tvec4 ox = mod(p, 7.0)*K+K2;\n\t\t\t\tvec4 oy = mod(floor(p*K),7.0)*K+K2;\n\t\t\t\tvec4 dx = Pfx + jitter*ox;\n\t\t\t\tvec4 dy = Pfy + jitter*oy;\n\t\t\t\tvec4 d = dx * dx + dy * dy; // d11, d12, d21 and d22, squared\n\t\t\t\t// Sort out the two smallest distances\n\t\t\t\t\n\t\t\t\t// Cheat and pick only F1\n\t\t\t\td.xy = min(d.xy, d.zw);\n\t\t\t\td.x = min(d.x, d.y);\n\t\t\t\treturn d.x; // F1 duplicated, F2 not computed\n\t\t}\n\t\t\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\t\t\t\t\t\t\n\t\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\t\t\n\t\tuv.x*=(iResolution.x/iResolution.y);\n\t\t\t\t\t\n\t\tvec2 GA=vec2(0);\n\t\t\t\t\n        #if dir==0 \n        GA.y +=time*speed;\n        #elif dir==1\n        GA.y -=time*speed;\n        #elif dir==2\n        GA.x +=time*speed;\n        #elif dir==3\n        GA.x -=time*speed;\n        #endif\n\t\t\n    \t// multi declaration \n        float   F1,F2,F3,F4,F5,F6,F7,F8=0.0;\n\t\tfloat   N1,N2,N3,N4,N5,N6,N7,N8=0.0;\n\t\tfloat A,A1,A2,A3,A4,A5,A6,A7,A8=0.0;\n\t\n\n\n\t// Snow layers, somewhat like an fbm with worley layers.\n\tF1 = 1.0-cellular2x2((uv+(GA*0.1))*8.0);\t\n\tA1 = 1.0-(A*0.8);\n\tN1 = smoothstep(0.9998,1.0,F1)*0.2*A1;\t\n\n\tF2 = 1.0-cellular2x2((uv+(GA*0.2))*7.0);\t\n\tA2 = 1.0-(A*0.8);\n\tN2 = smoothstep(0.9998,1.0,F2)*0.3*A2;\t\t\t\t\n\n\tF3 = 1.0-cellular2x2((uv+(GA*0.3))*6.0);\t\n\tA3 = 1.0-(A*0.8);\n\tN3 = smoothstep(0.9998,1.0,F3)*0.4*A3;\t\t\t\n            \n    F4 = 1.0-cellular2x2((uv+(GA*0.4))*5.0);\t\n\tA4 = 1.0-(A*0.8);\n\tN4 = smoothstep(0.9998,1.0,F4)*0.5*A4;\t\n            \n    F5 = 1.0-cellular2x2((uv+(GA*0.5))*4.0);\t\n\tA5 = 1.0-(A*0.8);\n\tN5 = smoothstep(0.9998,1.0,F5)*0.6*A5;\t\n\t\t\t\t\t\t\t\t\n    F6 = 1.0-cellular2x2((uv+(GA*0.8))*3.0);\t\n\tA6 = 1.0-(A*0.8);\n\tN6 = smoothstep(0.9999,1.0,F6)*0.59*A6;\n    \n    F7 = 1.0-cellular2x2((uv+(GA*1.2))*2.9);\t\n\tA7 = 1.0-(A*0.8);\n\tN7 = smoothstep(0.9999,1.0,F7)*0.58*A7;\n    \n    F8 = 1.0-cellular2x2((uv+(GA*1.8))*2.8);\t\n\tA8 = 1.0-(A*0.8);\n\tN8 = smoothstep(0.9999,1.0,F8)*0.57*A8;\n    \n     \n    \n    \n    \n    \n    \n    \n    \n    \n\tfloat cl= N8+N7+N6+N5+N4+N3+N2+N1;\n\t\t\t\t\t\t\n\t//cl = N1+N2+N3+N4+N5;\n\tfragColor = vec4(cl, cl, cl, 1.0)*2.;\n}\n//okeyy for mac ?", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MltXz7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MltXzM", "name": "#codevember - 10", "author": "jcksmssng", "description": "Going back to 2d to try some rotation matrices + pattern\nFollowing the awesome book of shaders lesson by Patricio Gonzalez Vivo\nhttps://thebookofshaders.com/09/", "tags": ["matrix", "fract"], "likes": 0, "viewed": 526, "date": "1478817015", "time_retrieved": "2024-06-20T18:44:44.834336", "image_code": "mat2 rotate2d( float angle )\n{\n    return mat2(cos(angle), -sin(angle),\n                sin(angle), cos(angle));\n}\n\nfloat map(float value, float oldMin, float oldMax, float newMin, float newMax) \n{\n    return newMin + (newMax - newMin) * (value - oldMin) / (oldMax - oldMin);\n}\n\nfloat circle ( vec2 point, float radius ) \n{\n    //vec2 origin = vec2( sin( iTime ), .0 );\n   \tvec2 origin = vec2( .0, .0 );\n    return length(point - origin) - radius;\n}\n\nfloat colorize( float dist, vec2 point )\n{\n    float m = map(point.x, -1., 1., 0., .7);\n    return dist < 0.0 ? 1.0 - m : m;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy;\n\tvec2 uv = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n    uv.x += sin( iTime );\n    uv *= sin( iTime ) * 3. + sin( 2. * iTime ) / 4.;\n    uv *= rotate2d( sin ( iTime ));\n    uv = 2. * sin( iTime ) * fract( uv );\n    uv *= rotate2d( iTime );\n    \n    float radius = 0.5 * cos( iTime );\n    float c = circle( uv, radius ); \n    \n    float b = colorize( c, uv );\n\tvec3 color = vec3( .18, .18, b );\n\n    fragColor = vec4( color, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MltXzM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Mt3Sz7", "name": "non-euclidean mirror ", "author": "zproxy", "description": "non-euclidean mirror.\n\nlets find out how does this work for  360 3D video", "tags": ["noneuclidean"], "likes": 4, "viewed": 227, "date": "1478698933", "time_retrieved": "2024-06-20T18:44:46.246427", "image_code": "// https://www.shadertoy.com/view/4llSWf\n\n#define MIN_DIST 0.0003\n#define MAX_DIST 64.0\n#define MAX_STEPS 1024\n#define STEP_MULT 0.1\n#define NORMAL_OFFS 0.02\n\n#define DISABLE_WARP\n//#define HIDE_BOX\n\nfloat pi = atan(1.0)*4.0;\nfloat tau = atan(1.0)*8.0;\n\n//Returns a rotation matrix for the given angles around the X,Y,Z axes.\nmat3 Rotate(vec3 angles)\n{\n    vec3 c = cos(angles);\n    vec3 s = sin(angles);\n    \n    mat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0,c.x,s.x, 0.0,-s.x, c.x);\n    mat3 rotY = mat3( c.y, 0.0,-s.y, 0.0,1.0,0.0, s.y, 0.0, c.y);\n    mat3 rotZ = mat3( c.z, s.z, 0.0,-s.z,c.z,0.0, 0.0, 0.0, 1.0);\n\n    return rotX*rotY*rotZ;\n}\n\n//==== Distance field operators/functions by iq. ====\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opI( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdPlane( vec3 p, vec3 n )\n{\n  return dot(p, normalize(n));\n}\n\nfloat sdBox(vec3 p, vec3 s)\n{\n    p = abs(p) - s / 2.0;\n    return max(max(p.x,p.y),p.z);\n}\n//===================================================\n\nvec3 scale = vec3(1,1,1);\n\n//Defines the volume in which rays will speed up/slow down.\nfloat Warp(vec3 p)\n{\n    return sdBox(p + vec3(0,0,0.5), vec3(3.0,2.5,0.75));\n}\n\nfloat Scene(vec3 p)\n{\n    float d = 1000.0;\n    \n    p *= scale;\n    \n    // how to move floor?\n    d = opU(d, -sdPlane(p, vec3(0,0,2)));\n    \n    #ifndef HIDE_BOX\n    d = opU(d, sdBox(p,vec3(3,2.6,1.8)));\n    \n    // border?\n    //d = opU(d, sdBox(p,vec3(3,4,2)));\n    \n    // how to make warp area bigger?\n    d = opS(sdBox(p + vec3(0,0,0.5), vec3(4,2.5,0.75)), d);\n    #endif\n    \n    d = opU(d, sdSphere(p + vec3(2,0,0.5),0.25));\n    \n    \n    // right pillar\n    d = opU(d, sdBox(p + vec3(1.5,1.4,0.5), vec3(0.125,0.125,0.9)));\n    d = opU(d, sdSphere(p + vec3(1.5,1.4,1.0), 0.125));\n\n    // left pillar\n    d = opU(d, sdBox(p + vec3(1.5,-1.4,0.4), vec3(0.125,0.125,0.9)));\n    d = opU(d, sdSphere(p + vec3(1.5,-1.4,1.0), 0.125));\n\n    \n   \n    \n    //d = opU(d, -sdSphere(p,32.0));\n    \n\treturn d;\n}\n\nfloat MarchWarp(vec3 origin,vec3 dir)\n{\n    float dist = 0.0;\n    \n    for(int i = 0;i < MAX_STEPS;i++)\n    {\n        float sceneDist = Warp(origin + dir * dist);\n        \n        dist += sceneDist * STEP_MULT;\n        \n        if(abs(sceneDist) < MIN_DIST || sceneDist > MAX_DIST)\n        {\n            break;\n        }\n    } \n    return dist;\n}\n\nvec3 MarchRay(vec3 origin,vec3 dir)\n{\n    bool inWarp = false;\n    \n    float dist = 0.0;\n    \n    //Distance to the \"warp zone\".\n    float warpDist = MarchWarp(origin,dir);\n    \n    for(int i = 0;i < MAX_STEPS;i++)\n    {\n        float sceneDist = Scene(origin + dir * dist);\n        \n        //Reset the march distance, set the ray origin to the surface of the \"warp zone\", scale the map and ray origin.\n        #ifndef DISABLE_WARP\n        if(warpDist < dist && !inWarp)\n    \t{\n            scale.x = 4.0;\n            \n            dist = 0.0;\n            origin = origin + dir * warpDist;\n            origin /= scale;\n            \n            inWarp = true;\n    \t}\n        #endif\n        \n        if(warpDist < dist && !inWarp)\n    \t{\n            // just a mirror\n            //scale.x = -1.0;\n            \n            // mirror longated\n            //scale.x = -1.0/4.0;\n            \n            //scale.x = -8.0;\n            \n            // dolly zoom basically?\n            float zzmax = 15.0;\n            float zz =  zzmax * (1.0 + cos(iTime * 0.5)) / 2.0;\n            \n            if (zz < 0.0)\n                zz = 0.0;\n            \n            scale.x = -1.0 * (1.0 + zz);\n\n            \n            dist = 0.0;\n            origin = origin + dir * warpDist;\n            origin /= scale;\n            \n            inWarp = true;\n    \t}\n        \n        dist += sceneDist * STEP_MULT;\n        \n        if(abs(sceneDist) < MIN_DIST || sceneDist > MAX_DIST)\n        {\n            if(sceneDist < 0.0)\n            {\n                dist += MIN_DIST;\n            }\n            \n            break;\n        }\n    }\n    \n    return origin + dir * dist;\n}\n\nvec3 Normal(vec3 p)\n{\n    vec3 off = vec3(NORMAL_OFFS,0,0);\n    return normalize\n    ( \n        vec3\n        (\n            Scene(p+off.xyz) - Scene(p-off.xyz),\n            Scene(p+off.zxy) - Scene(p-off.zxy),\n            Scene(p+off.yzx) - Scene(p-off.yzx)\n        )\n    );\n}\n\nvec3 Shade(vec3 position, vec3 normal, vec3 direction, vec3 camera)\n{\n    position *= scale;\n   // vec3 color = vec3(1.0);\n    vec3 color = vec3(1.1, 0.9, 0.3);\n    \n    color = color * 0.75 + 0.25;\n    \n    color *= normal * .55 + .75;\n    \n    // can we make the floor checker larger?\n    float checker = \n        \n        // keep bmv pattern in mirror\n        sin(position.x * pi *2.0) \n        * sin(position.y * pi * 2.0) \n        * sin(position.z * pi * 2.0);\n    \n    color *= step(0.0,checker) * 0.25 + 0.75;\n    \n    float ambient = 0.1;\n    float diffuse = 0.5 * -dot(normal,direction);\n    float specular = 0.7 * max(0.0, -dot(direction, reflect(direction,normal)));\n    \n    color *= vec3(ambient + diffuse + pow(specular,5.0));\n\n    color *= smoothstep(12.0,6.0,length(position));\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n    vec3 angles = vec3(0);\n    \n    \n    if(iMouse.xy == vec2(0))\n    {\n    \tangles = vec3(iTime * 0.2, 1.3, 0.0);\n    }\n    else\n    {\n    \tangles = vec3((iMouse.xy/iResolution.xy)*pi,0);\n    }\n    \n    angles.xy *= vec2(2.0,1.0);\n    angles.y = clamp(angles.y,-tau/4.0, 1.5);\n    \n    mat3 rotate = Rotate(angles.yzx);\n    \n    //vec3 orig = vec3(0,0,-2) * rotate;\n    \n    // altitude\n    //vec3 orig = vec3(0,0,-3) * rotate + vec3(0,0,-3);\n    // could we orbit around the ball only?\n\n    // side\n    //    vec3 orig = vec3(0,0,-3) * rotate + vec3(0,3,0);\n\n    //vec3 orig = vec3(0,0,-3) * rotate + vec3(-2,0,0);\n//\tvec3 orig = vec3(0,0,-1) * rotate + vec3(-2,0,0);\n//\tvec3 orig = vec3(0,0,-0.5) * rotate + vec3(-2,0,-0.5);\n\n    //vec3 orig = vec3(0,0,-0.5) * rotate + vec3(-2.125,0,-0.5);\n    vec3 orig = vec3(0,0,-0.5) * rotate + vec3(-2.125,0.125,-0.5);\n\n    \n    vec3 dir = normalize(vec3(uv - res/2.0,0.5)) * rotate;\n    \n    vec3 hit = MarchRay(orig,dir);\n    vec3 norm = Normal(hit);\n    \n    vec3 color = Shade(hit,norm,dir,orig);\n    \n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mt3Sz7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Mt3SzB", "name": "Daily Shade day 24: Mesh", "author": "psonice", "description": "Day 24. Decided to do something with an old shader: https://www.shadertoy.com/view/MdS3R3\nSo, first step was to bring that distance function into the new rendering code. Tomorrow, I'll try to make something with it.", "tags": ["waves", "raymarch", "reflections", "mesh"], "likes": 16, "viewed": 716, "date": "1480292717", "time_retrieved": "2024-06-20T18:44:49.125462", "image_code": "/* \nDay 24\n*/\n\n//#define DEBUG\n#ifdef DEBUG\nint debugStep = 0;\nfloat debugValue = 0.0;\n#endif\n\n// Rotation\n#define R(p,a) p=cos(a)*p+sin(a)*vec2(-p.y,p.x);\n\n\n#define kINFINITY 10000.0 // An unimaginably large number\n#define kSQRT2 1.414213\n#define kISQRT2 0.707107\n#define kPI 3.141592\n\n// maximum iteration count\n#define kMAXITERS 150\n#define kEPSILON 0.001\n#define kMAXINTERSECTIONS 1\n\n// refractive index\n#define kREFRACT 1.0/1.5\n\n// materials\n#define kFLOORMATERIAL 0\n#define kGLASSMATERIAL 1\n#define kMIRRORMATERIAL 2\n#define kGLOWMATERIAL 3\n#define kMIRRORMATERIAL2 4\n\n#define kFLOORCOLOUR vec3(0.7, 0.65, 0.6)\n#define kGLASSCOLOUR vec3(0.9)\n#define kMIRRORCOLOUR vec3(0.9)\n#define kMIRRORCOLOUR2 vec3(0.5)\n#define kGLOWCOLOUR vec3(0.5)\n\n#define kZENITHCOLOUR vec3(0.3, 0.7, 1.0)\n#define kNADIRCOLOUR vec3(0.7, 0.6, 0.4)\n#define kHORIZONCOLOUR vec3(0.95)\n#define kSUNCOLOUR vec3(100, 90, 70)\n\n// A ray. Has origin + direction.\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n    \n// Distance to nearest surface\nstruct SDResult {\n    float d; // Distance\n    int material; // Nearest material\n};\n\n// A camera. Has a position and a direction. \nstruct Camera {\n    vec3 pos;\n    Ray ray;\n};\n    \n// A disk. Has position, size, colour.\nstruct Disk {\n    vec3 pos;\n    float radius;\n    vec3 col;\n};\n    \nstruct Sphere {\n    vec3 pos;\n    float radius;\n};\n    \nstruct Box {\n\tvec3 pos;\n\tvec3 size;\n    float radius;\n};\n    \nfloat eps = kEPSILON;\nfloat divergence;\n\nvec3 smoothBlend(in vec3 point, in vec3 about, in float radius) {\n    point -= about;\n    point = mix(-point, point, smoothstep(-radius, radius, point));\n    return point + about;\n}\n    \n// Distance to sphere (signed)\nfloat sphereDist(in Ray ray, in Sphere sphere) {\n    return length(ray.origin - sphere.pos) - sphere.radius;\n}\n\n// Distance to sphere surface\nfloat uSphereDist(in Ray ray, in Sphere sphere) {\n    return abs(length(ray.origin - sphere.pos) - sphere.radius);\n}\n\n// Distance to box surface (signed)\nfloat boxDist(in Ray ray, in Box box) {\n    vec3 dist = abs(ray.origin - box.pos) - (box.size * 0.5);\n    vec3 cDist = max(dist, 0.0);\n    return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(cDist) - box.radius;\n}\n\n// Distance to box surface\nfloat uBoxDist(in Ray ray, in Box box) {\n    return abs(length(max(abs(ray.origin - box.pos) - (box.size * 0.5), 0.0)) - box.radius);\n}\n\n// distance to floor\nfloat floorDist(in Ray ray) {\n    float dist = ray.origin.y;\n    return dist;\n}\n\n// traced coords of floor intersection, floor at height y\nvec2 floorPos(in Ray ray, in float y) {\n    float dist = (ray.origin.y - y) / ray.dir.y;\n \treturn ray.origin.xz + ray.dir.xz * dist; \n}\n\n/*\n---- Random/hash stuff ----\n*/\n\n// Normalised random number, borrowed from Hornet's noise distributions: https://www.shadertoy.com/view/4ssXRX\nfloat nrand(in vec2 n) {\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\n// random value based on texture channel 2\nvec3 texrand(in vec2 n, in float mipLevel) {\n    return texture(iChannel2, n, mipLevel).xyz;\n}\n\n// returns a hash value for a fixed size cell\nfloat hashForCell(in vec3 pos, in float cellSize) {\n    float hash = nrand(floor(pos.xz / cellSize) + 68.0);\n    return hash;\n}\n\n// returns a random colour based on the cell hash\nvec3 randomColourForCell(in vec3 pos, in float cellSize) {\n\tfloat hash = hashForCell(pos, cellSize); \n    return vec3(\n        nrand(vec2(hash * 2.0, hash * 4.0)),\n        nrand(vec2(hash * 4.0, hash * 8.0)),\n        nrand(vec2(hash * 8.0, hash * 16.0))\n\t);\n\tvec3 c = vec3(hash, mod(hash + 0.15, 1.0), mod(hash + 0.3, 1.0)) * 0.75;\n}\n\n/*\n---- INTERSECTION OPS ----\n*/\n\n// Union of two signed distances\nfloat unionOp(float d0, float d1) {\n    return min(d0, d1);\n}\n\n// Intersection of two signed distances\nfloat intersectOp(float d0, float d1) {\n    return max(d0, d1);\n}\n\n// Difference of two signed distances\nfloat differenceOp(float d0, float d1) {\n    return max(d0, -d1);\n}\n\n/*\n---- Scene rendering ----\n*/\n\n// Get the distance to the scene (returns a struct containing distance and nearest material)\nSDResult sceneDist(in Ray ray) {\n    SDResult result;\n    \n    float floorDist = ray.origin.y;\n    \n    vec3 p = ray.origin;\n    float t = iTime;//mod(iTime, kPI);\n    \n\tp += vec3(\n\t\tsin(p.z * 1.55 + t) + sin(p.z * 1.34 + t),\n\t\t0.,\n\t\tsin(p.x * 1.34 + t) + sin(p.x * 1.55 + t)\n\t) * .5;\n\n\tvec3 mp = p;\n    mp.xz = mod(p.xz, 1.);\n    \n        \n\tray.origin = vec3(mp.x, mp.y + (sin(p.z * kPI) * sin(p.x * kPI)) * 0.25, 0.5);\n\tfloat s1 = boxDist(\n        ray, \n        Box(\n            vec3(0.5), \n            vec3(0.2), \n            0.02\n        ));\n    \n    ray.origin = vec3(0.5, mp.y + (sin(p.x * kPI) * -sin(p.z * kPI)) * 0.25, mp.z);\n\tfloat s2 = boxDist(\n        ray, \n        Box(\n            vec3(0.5),\n            vec3(0.0),\n            0.15\n            ));\n\t\n    result.d = unionOp(s1, s2);\n    \n    result.d = unionOp(result.d, floorDist);\n    \n    result.material = result.d == floorDist ? kFLOORMATERIAL : kMIRRORMATERIAL;\n    \n    return result;\n}\n\n// Gets the normal\nvec3 normal(in Ray ray) {\n    vec2 eps = vec2(0.0001, 0);\n    float baseDist = sceneDist(ray).d;\n \treturn normalize(vec3(\n        sceneDist(Ray(ray.origin + eps.xyy, ray.dir)).d - \n        sceneDist(Ray(ray.origin - eps.xyy, ray.dir)).d,\n        sceneDist(Ray(ray.origin + eps.yxy, ray.dir)).d -\n        sceneDist(Ray(ray.origin - eps.yxy, ray.dir)).d,\n        sceneDist(Ray(ray.origin + eps.yyx, ray.dir)).d -\n        sceneDist(Ray(ray.origin - eps.yyx, ray.dir)).d\n        ));\n}\n\n// Moves the ray to the surface. Helps avoid artefacts due to ray intersection imprecision.\nvoid clampToSurface(in Ray ray, in float d, inout vec3 n) {\n    for (int i=0; i<5; i++) {\n \t\tray.origin += n * d*0.5;\n \t\td = sceneDist(ray).d;\n \t\tn = normal(ray);\n    }\n}\n\n// Calulcate a fresnel term for reflections\nfloat fresnelTerm(in Ray ray, in vec3 n, in float power) {\n\tfloat fresnel = min(1., dot(ray.dir, n) + 1.0);\n\tfresnel = pow(fresnel, power);\n    return fresnel;\n}\n\n/*\n---- LIGHTING ----\n*/\n\n// Pretty background colour of some sort...\nvec3 backgroundColour (in Ray ray, in float divergence) {\n    \n    // Declare a horizon and extremity (either zenith or nadir)\n    vec3 base, extremity, texture;\n    float x = smoothstep(0.0,1.0,abs(ray.dir.y));\n   // base = mix(vec3(0.05, 0.1, 0.2), vec3(0.0), x);\n    \n    if (ray.dir.y >= 0.0) {\n        // sky: fake as hell clouds\n    \tbase = mix(kHORIZONCOLOUR, kZENITHCOLOUR, x);\n        texture = vec3(1);\n        float cloudFactor = 0.0;\n        \n        vec2 coord = ray.dir.xz / 8.0;\n        float scale = 1.0;\n        for (int i=0; i<4; i++) {\n            float offset = iTime * 0.03 / scale;\n            cloudFactor += texrand(coord + vec2(0, -offset), 3.0).r * scale;\n            coord *= 2.0;\n            scale *= 0.5;\n        }\n        cloudFactor /= 1.5;\n        vec3 cloud = mix(vec3(0.4), vec3(1), cloudFactor);\n        base = mix(base, cloud, cloudFactor * ray.dir.y * ray.dir.y);\n        \n    } else {\n        // ground: fake as hell desert\n        texture = kNADIRCOLOUR * 0.5;\n        vec2 floorCoord = floorPos(ray, -30.0) + vec2(0, iTime * 100.0);\n        texture *= (sin(floorCoord.x * .183 + floorCoord.y * 0.183 + sin(floorCoord.y * 0.3) * 0.5) \n                    + sin(floorCoord.x * .15 + floorCoord.y * 0.22 + sin(floorCoord.x * 0.26) * 0.5))\n            * 0.25 + 0.5;\n\t\tbase = mix(kHORIZONCOLOUR, kNADIRCOLOUR + texture, x);\n        \n    }\n    \n    \n    \n    return base;\n}\n\n// Technically broken, but seems to make soft shadows? *shrug*\nfloat occlusion(in Ray ray, in vec3 n) {\n    vec3 origin = ray.origin;\n    float o = 0.0;\n    ray.dir = n;\n    float x = eps*2.0;\n    origin += ray.dir * x;\n    for (float i=1.0; i<7.0; i++) {\n    \tray.origin = origin + ray.dir * x;\n        float d = sceneDist(ray).d;\n        o += max(x - d, 0.0) / x / i;\n        \n        x *= 4.0;\n    }\n \treturn 1.0 - o;\n}\n\nvec3 highlight(in Ray ray, in vec3 n) {\n    // sun\n\tvec3 sunDir = normalize(vec3(1,0.3,1));\n\tfloat sunDist = distance(sunDir, ray.dir)-0.00;\n\treturn mix(vec3(10,10,8), vec3(0), smoothstep(0.0, 0.2, sunDist));\n}\n\n/*\n---- RAY MARCHING ----\n*/\n\n// The main marching loop\nvoid marchRay(inout Ray ray, inout vec3 colour) {\n    bool inside = false; // are we inside or outside the glass object\n    vec3 impact = vec3(1); // This decreases each time the ray passes through glass, darkening colours\n\n    vec3 startpoint = ray.origin;\n    \n#ifdef DEBUG   \nvec3 debugColour = vec3(1, 0, 0);\n#endif\n    \n    SDResult result;\n    vec3 n;\n    vec3 glassStartPos;\n    \n    //float glow = 0.0;\n    \n    for (int i=0; i<kMAXITERS; i++) {\n        // Get distance to nearest surface\n        result = sceneDist(ray);\n        \n        //glow += result.material == kGLOWMATERIAL ? \n        //    pow(max(0.0, (80.0 - result.d) * 0.0125), 4.0) * result.d * 0.01\n        //    : 0.0;\n        \n        // Step half that distance along ray (helps reduce artefacts)\n        float stepDistance = (inside ? abs(result.d) : result.d) * 0.65;\n        ray.origin += ray.dir * stepDistance;\n        //if (length(ray.origin) > 40.0) { break; }\n        \n        if (stepDistance < eps) {\n            // colision\n            // normal\n            // Get the normal, then clamp the intersection to the surface\n    \t\tn = normal(ray);\n            //clampToSurface(ray, stepDistance, n);\n#ifdef DEBUG\n//debugColour = n;\n//break;\n#endif\n            \n            if ( result.material == kFLOORMATERIAL ) {\n                // ray hit floor\n                \n                // Add some noise to the normal, since this is pretending to be grit...\n                vec3 randomNoise = texrand(ray.origin.xz * 0.4, 0.0);\n                n = mix(n, normalize(vec3(randomNoise.x, 1, randomNoise.y)), randomNoise.z);\n                \n                // Colour is just grey with crappy fake lighting...\n                colour += mix(\n                    kFLOORCOLOUR, \n                    vec3(0), \n                    pow(max((-n.x+n.y) * 0.5, 0.0), 2.0)\n                ) * impact;\n                float o = occlusion(ray, n);\n#ifdef DEBUG\ndebugColour = vec3(o);\nbreak;\n#endif\n                colour *= o;\n                impact *= 0.;\n                break;\n            }\n            \n            if (result.material == kGLOWMATERIAL) {\n             \tcolour = mix(colour, kGLOWCOLOUR, impact);\n                impact *= 0.;\n                break;\n            }\n            \n            // check what material it is...\n            \n            if (result.material == kMIRRORMATERIAL) {\n                \n                // handle interior glass / other intersecion\n                if (inside) {\n                     float glassTravelDist =  min(distance(glassStartPos, ray.origin) / 16.0, 1.);\n    \t\t\t\tglassStartPos = ray.origin;\n                    // mix in the colour\n                \timpact *= mix(kGLASSCOLOUR, kGLASSCOLOUR * 0.1, glassTravelDist);\n                    \n                }\n                \n                // it's a mirror, reflect the ray\n                ray.dir = reflect(ray.dir, n);\n                    \n                // Step 2x epsilon into object along normal to ensure we're beyond the surface\n                // (prevents multiple intersections with same surface)\n                ray.origin += n * eps * 4.0;\n                \n                // Mix in the mirror colour\n                colour += highlight(ray, n);\n                impact *= kMIRRORCOLOUR;\n                float o = occlusion(ray, n);\n                impact *= o;\n#ifdef DEBUG\ndebugColour = vec3(o);\nbreak;\n#endif\n                \n            } else {\n                // glass material\n            \n                if (inside) {\n                \t// refract glass -> air\n                \tray.dir = refract(ray.dir, -n, 1.0/kREFRACT);\n                    \n                    // Find out how much to tint (how far through the glass did we go?)\n                    float glassTravelDist =  min(distance(glassStartPos, ray.origin) / 16.0, 1.);\n    \n                    // mix in the colour\n                \timpact *= mix(kGLASSCOLOUR, kGLASSCOLOUR * 0.1, glassTravelDist);\n                    \n#ifdef DEBUG\ndebugValue += glassTravelDist / 2.0;\n#endif\n      \n                \n              \t} else {\n               \t\t// refract air -> glass\n                \tglassStartPos = ray.origin;\n                    \n              \t  \t// Mix the reflection in, according to the fresnel term\n                \tfloat fresnel = fresnelTerm(ray, n, 1.0);\n                    fresnel = fresnel;\n    \t\t\t\t/*\n                    colour = mix(\n                    \tcolour, \n                    \ttexture(iChannel1, reflect(ray.dir, n)), \n                    \tvec4(fresnel) * impact);\n*/\n                    colour = mix(\n                        colour,\n                        backgroundColour(ray, 0.0),\n                        vec3(fresnel) * impact);\n                \tcolour += n.x * 0.1;//highlight(ray, n);\n                    impact *= 1.0 - fresnel;\n    \t\t\t\n                \t// refract the ray\n            \t\tray.dir = refract(ray.dir, n, kREFRACT);\n                    \n#ifdef DEBUG\n//debugValue += 0.5;\n#endif\n                }\n            \n            \t// Step 2x epsilon into object along normal to ensure we're beyond the surface\n                ray.origin += (inside ? n : -n) * eps * 2.0;\n                \n                // Flip in/out status\n                inside = !inside;\n            }\n        }\n        \n        // increase epsilon\n        eps += divergence * stepDistance;\n    }\n    \n    // So far we've traced the ray and accumulated reflections, now we need to add the background.\n   // colour += texture(iChannel0, ray.dir) * impact;\n    ray.origin = startpoint;\n    colour.rgb += backgroundColour(ray, 0.0) * impact; // + glow * kGLOWCOLOUR;\n    \n#ifdef DEBUG\n//debugColour.rgb = ray.dir;\n//debugColour = vec3(float(debugStep)/2.0);\ncolour = debugColour;\n#endif\n}\n\n// Sets up a camera at a position, pointing at a target.\n// uv = fragment position (-1..1) and fov is >0 (<1 is telephoto, 1 is standard, 2 is fisheye-like)\nCamera setupCam(in vec3 pos, in vec3 target, in float fov, in vec2 uv) {\n\t\t// cam setup\n    // Create camera at pos\n\tCamera cam;\n    cam.pos = pos;\n    \n    // A ray too\n    Ray ray;\n    ray.origin = pos;\n    \n    // FOV is a simple affair...\n    uv *= fov;\n    \n    // Now we determine hte ray direction\n\tvec3 cw = normalize (target - pos );\n\tvec3 cp = vec3 (0.0, 1.0, 0.0);\n\tvec3 cu = normalize ( cross(cw,cp) );\n\tvec3 cv = normalize ( cross (cu,cw) );\n    \n\tray.dir = normalize ( uv.x*cu + uv.y*cv + 0.5 *cw);\n    \n    // Add the ray to the camera and our work here is done.\n\tcam.ray = ray;\n    \n    // Ray divergence\n    divergence = fov / iResolution.x;\n    \n\treturn cam;\n}\n\nvec3 camPath(in float time) {\n    float r = sin(time*0.5) * 2.0 + 4.0;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = mouse * kPI * 2.0 + kPI;\n    vec3 camPos = vec3(r, r, 0);\n\t\n    R(camPos.xz, time + mouse.x);\n    R(camPos.zy, sin(time) * kPI * 0.1 + 0.2);\n    \n    return camPos;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // We'll need a camera. And some perspective.\n    \n\t// Get some coords for the camera angle from the frag coords. Convert to -1..1 range.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2. - 1.;\n    \n    // Aspect correction so we don't get oval bokeh\n    uv.y *= iResolution.y/iResolution.x;\n    \n    // Make a camera with ALL NEW AND IMPROVED! camera code :)\n    float camTime = iTime / 4.0;\n    vec3 camPos = camPath(camTime);\n    vec3 camTarget = vec3(0,0,0);\n    //camTarget.y -= 3.0;\n    Camera cam = setupCam(camPos, camTarget, 0.500, uv);\n    \n    // Let's raymarch some stuff and inject that into the scene...\n    \n    // Create an empty colour\n    vec3 col = vec3(0);\n    \n    // Trace that ray!\n    marchRay(cam.ray, col);\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mt3SzB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Mt3XRS", "name": "Chinese Box", "author": "xbe", "description": "Just a box with nice drawings... :) Nearly everything is generated by code.", "tags": ["procedural", "2d", "3d", "raymarching"], "likes": 20, "viewed": 701, "date": "1480419509", "time_retrieved": "2024-06-20T18:44:52.980476", "image_code": "// Created by Xavier Benech - xbe/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Chinese box\n// Use \"chinese style\" 2D patterns to texture a box\n\n#define PI 3.141592654\n#define FAR 1000.\n#define DEG2RAD 3.141592654/180.\n\n#define CART2POLAR(x,y) vec2( sqrt(x*x + y*y), atan(y, x) )\n\n#define SHADE_NONE -1.\n#define SHADE_MAT 1.\n#define SHADE_GLOSSY_BOX 2.\n#define SHADE_GLOSSY_FLOOR 3.\n\n#define BOXCOLOR vec3(1.,0.1,0.02)\n\nconst vec3 LIGHTPOS0 = vec3(5.65, 4.5, 0.);\nconst vec3 LIGHTPOS1 = vec3(5.65*cos(2.*PI/3.), 4.5, 5.65*sin(2.*PI/3.));\nconst vec3 LIGHTPOS2 = vec3(5.65*cos(4.*PI/3.), 4.5, 5.65*sin(4.*PI/3.));\n\n////////////////////////////////////////////////////////////////////////////\n// Utils\n\nvec2 rotate(vec2 p, float a)\n{\n\treturn vec2(p.x * cos(a) + p.y * sin(a),\n\t\t\t\tp.y * cos(a) - p.x * sin(a));\n}\n\nvec3 rotateXZ(vec3 p, float a)\n{\n\treturn vec3(p.x * cos(a) + p.z * sin(a),\n                p.y,\n\t\t\t\tp.z * cos(a) - p.x * sin(a));\n}\n\nvec3 rotateXY(vec3 p, float a)\n{\n\treturn vec3(p.x * cos(a) + p.y * sin(a),\n                p.y * cos(a) - p.x * sin(a),\n                p.z);\n}\n\nvec3 rotateYZ(vec3 p, float a)\n{\n\treturn vec3(p.x,\n        \t\tp.y * cos(a) + p.z * sin(a),\n                p.z * cos(a) - p.y * sin(a));\n}\n\nmat4 rotationXYZ( float x, float y, float z )\n{\n    mat4 rotx = mat4(  1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, cos(x), -sin(x), 0.0,\n\t\t\t\t 0.0, sin(x), cos(x), 0.0,\n\t\t\t\t 0.0,   0.0,   0.0,   1.0 );\n    mat4 roty = mat4(  cos(y), 0.0, sin(y), 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t -sin(y), 0.0, cos(y), 0.0,\n\t\t\t\t 0.0,   0.0,   0.0,   1.0 );\n    mat4 rotz = mat4(  cos(z), -sin(z), 0.0, 0.0,\n\t\t\t\t sin(z), cos(z), 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t 0.0,   0.0,   0.0,   1.0 );\n\treturn rotz*roty*rotx;\n}\n\n////////////////////////////////////////////////////////////////////////////\n// DECORATIONS\n\nfloat circle(vec2 p, float r, float width)\n{\n    float d = 0.;\n    d += smoothstep(1., 0., width*abs(p.x - r));\n    return d;\n}\n\nfloat stripes(vec2 p, float a, float width)\n{\n    float d = 0.;\n    d += smoothstep(1., 0., width*abs(abs(p.y) - a));\n    return d;\n}\n\nfloat zebra(vec2 p, float width)\n{\n    float d = 0.;\n    d += smoothstep(1., 0., width*abs(p.x - p.y));\n    d += smoothstep(1., 0., width*abs(p.x + p.y));\n    return d;\n}\n\nfloat arc(vec2 p, float r, float a, float width)\n{\n    float d = 0.;\n    if (abs(p.y) < a) {\n\t    d += smoothstep(1., 0., width*abs(p.x - r));\n    }\n    return d;\n}\n\nfloat mirror(float x, float v, float width)\n{\n    float d = 0.;\n    d += smoothstep(1., 0., width*abs(x - v));\n    d += smoothstep(1., 0., width*abs(x - abs(v)));\n    d += smoothstep(1., 0., width*abs(abs(x) - v));\n    d += smoothstep(1., 0., width*abs(abs(x) - abs(v)));\n    return d;\n}\n\nfloat rose(vec2 p, float t, float width)\n{\n    const float a = 6.;\n    p.x *= 7. + 8. * t;\n    return mirror(p.x, sin(a * p.y), width);\n}\n\nfloat rose2(vec2 p, float t, float width)\n{\n    const float a = 6.;\n    p.x *= 7. + 8. * t;\n    return mirror(p.x, cos(a * p.y), width);\n}\n\nfloat fun(vec2 p, float t, float width)\n{\n    const float a = 6.;\n    p.x *= 7. + 8. * t;\n    return mirror(sin(a * p.x / PI), cos(a * p.y / PI), width);\n}\n\nfloat fun2(vec2 p, float t, float width)\n{\n    const float a = 6.;\n    p.x *= 7. + 8. * t;\n    return mirror(p.x, sin(a * p.y)+cos(a * p.y), width);\n}\n\nfloat spiral(vec2 p, float width)\n{\n    return mirror(p.x, 0.5 * p.y / PI, width);\n}\n\nfloat BoxLotus1(vec2 p)\n{\n    float res = 0.;\n    if (p.x < 0.7325) {\n\t    vec2 c;\n\t    vec2 f;\n        if (p.x < 0.25) {\n\t        c = vec2(0.25, PI / 4.);\n            f = mod(p, c) - 0.5 * c;\n            res += spiral(vec2(f.x, f.y), 192.);\n            res += spiral(vec2(0.9*f.x, f.y + 0.05), 192.);\n            res += spiral(vec2(0.8*f.x, f.y + 0.075), 192.);\n            res += spiral(vec2(0.7*f.x, f.y + 0.1), 192.);\n    \t}\n        if (p.x > 0.125 && p.x < 0.4) {\n            p.x *= 0.8;\n\t        c = vec2(0.25, PI / 4.);\n            f = mod(p, c) - 0.5 * c;\n            f.x *= 1.;\n            f.y *= 1.;\n            float d = 0.75;\n            res += fun2(vec2(f.x, f.y*f.y), d, 16.);\n            res += fun2(vec2(f.x + 0.01, f.y*f.y + 0.05), d, 16.);\n            res += fun2(vec2(f.x - 0.01, f.y*f.y + 0.05), d, 16.);\n            res += fun2(vec2(f.x + 0.02, f.y*f.y + 0.075), d, 16.);\n            res += fun2(vec2(f.x - 0.02, f.y*f.y + 0.075), d, 16.);\n    \t}\n    }\n    return res;\n}\n\nfloat BoxLotus2(vec2 p)\n{\n    float res = 0.;\n    vec2 c;\n    vec2 f;\n    if (p.x < 0.25) {\n        c = vec2(0.25, PI / 4.5);\n        f = mod(p, c) - 0.5 * c;\n        res += rose(vec2(f.x, f.y), 1., 12.);\n        res += rose(vec2(0.9*f.x, f.y + 0.05), 1., 12.);\n        res += rose(vec2(0.8*f.x, f.y + 0.075), 1., 12.);\n        res += rose(vec2(0.7*f.x, f.y + 0.1), 1., 12.);\n    }\n    if (p.x > 0.125 && p.x < 0.3) {\n        p.y += 1.247*PI;\n        c = vec2(0.25, PI / 4.5);\n        f = mod(p, c) - 0.5 * c;\n        f.x *= 1.0;\n        f.y *= 2.;\n        res += fun(vec2(f.x, f.y*f.y), -0.4, 32.);\n        res += fun(vec2(f.x + 0.01, f.y*f.y + 0.05), -0.4, 32.);\n        res += fun(vec2(f.x + 0.01, f.y*f.y - 0.05), -0.4, 32.);\n        res += fun(vec2(f.x + 0.02, f.y*f.y + 0.075), -0.4, 32.);\n        res += fun(vec2(f.x + 0.02, f.y*f.y - 0.075), -0.4, 32.);\n    }\n\tres += circle(p, 0.30, 192.);\n\tres += circle(p, 0.31, 192.);\n\tres += circle(p, 0.32, 192.);\n    return res;\n}\n\nfloat BoxLotus3(vec2 p)\n{\n    float res = 0.;\n    vec2 c;\n    vec2 f;\n    if (p.x < 0.25) {\n        c = vec2(0.25, PI / 5.);\n        f = mod(p, c) - 0.5 * c;\n        res += spiral(vec2(f.x, f.y), 192.);\n        res += spiral(vec2(0.9*f.x, f.y + 0.05), 192.);\n        res += spiral(vec2(0.8*f.x, f.y + 0.075), 192.);\n        res += spiral(vec2(0.7*f.x, f.y + 0.1), 192.);\n    }\n    if (p.x > 0.125 && p.x < 0.3) {\n        p.y += 1.01;\n        c = vec2(0.25, PI / 5.);\n        f = mod(p, c) - 0.5 * c;\n        f.x *= 1.25;\n        f.y *= 2.1;\n        res += fun(vec2(f.x, f.y*f.y), -0.4, 32.);\n        res += fun(vec2(f.x + 0.01, f.y*f.y + 0.05), -0.4, 32.);\n        res += fun(vec2(f.x + 0.01, f.y*f.y - 0.05), -0.4, 32.);\n        res += fun(vec2(f.x + 0.02, f.y*f.y + 0.075), -0.4, 32.);\n        res += fun(vec2(f.x + 0.02, f.y*f.y - 0.075), -0.4, 32.);\n    }\n\tres += circle(p, 0.30, 192.);\n\tres += circle(p, 0.31, 192.);\n    return res;\n}\n\nfloat BoxLotus4(vec2 p)\n{\n    float res = 0.;\n    vec2 c;\n    vec2 f;\n    if (p.x < 0.25) {\n        c = vec2(0.25, PI / 4.);\n        f = mod(p, c) - 0.5 * c;\n        res += rose(vec2(f.x, f.y), 0., 12.);\n        res += rose(vec2(f.x, f.y + 0.05), 0.1, 12.);\n        res += rose(vec2(f.x, f.y + 0.075), 0.2, 12.);\n        res += rose(vec2(f.x, f.y + 0.1), 0.3, 12.);\n    }\n\tres += circle(p, 0.26, 192.);\n\tres += circle(p, 0.27, 192.);\n\tres += circle(p, 0.28, 192.);\n    return res;\n}\n\nfloat BoxSideFB(vec2 c)\n{\n    vec2 cc = 1.5*c;\n    float res = BoxLotus1(CART2POLAR(cc.x, cc.y));\n    cc = 2.*c + vec2(1.1, 0.);\n    res += BoxLotus4(CART2POLAR(cc.x, cc.y));\n    cc = 2.*c + vec2(-1.1, 0.);\n    res += BoxLotus4(CART2POLAR(cc.x, cc.y));\n    return clamp(res, 0., 1.);\n}\n\nfloat BoxSideLR(vec2 c)\n{\n    vec2 cc = 1.5*c;\n    float res = BoxLotus1(CART2POLAR(cc.x, cc.y));\n    return clamp(res, 0., 1.);\n}\n\nfloat BoxCover(vec2 c)\n{\n    vec2 cc = 0.7*c;\n    float res = BoxLotus2(CART2POLAR(cc.x, cc.y));\n    cc = 1.66*c + vec2(1.15, 0.5);\n    res += BoxLotus3(CART2POLAR(cc.x, cc.y));\n    cc = 1.66*c + vec2(1.15, -0.5);\n    res += BoxLotus3(CART2POLAR(cc.x, cc.y));\n    cc = 1.66*c + vec2(-1.15, -0.5);\n    res += BoxLotus3(CART2POLAR(cc.x, cc.y));\n    cc = 1.66*c + vec2(-1.15, 0.5);\n    res += BoxLotus3(CART2POLAR(cc.x, cc.y));\n    return res;\n}\n\nfloat Table(vec2 c)\n{\n    float res = 0.;\n    vec2 p = CART2POLAR(c.x, c.y);\n    vec2 m;\n    vec2 f;\n\tp.x *= 1.01;\n\tres += circle(p, 0.125, 512.);\n    if (p.x > 0.125 && p.x < 0.25) {\n        m = vec2(0.25, PI / 10.);\n        f = mod(p, m) - 0.5 * m;\n        res += stripes(f, 0.125, 512.*p.x);\n    }\n\tres += circle(p, 0.25, 512.);\n    if (p.x > 0.125 && p.x < 0.5) {\n        m = vec2(0.25, PI / 5.);\n        f = mod(p, m) - 0.5 * m;\n        f.x *= 1.25;\n        f.y *= 2.;\n        res += fun(vec2(f.x, f.y*f.y), -0.4, 64.);\n        res += fun(vec2(f.x + 0.01, f.y*f.y + 0.05), -0.4, 64.);\n        res += fun(vec2(f.x + 0.01, f.y*f.y - 0.05), -0.4, 64.);\n        res += fun(vec2(f.x + 0.02, f.y*f.y + 0.075), -0.4, 64.);\n        res += fun(vec2(f.x + 0.02, f.y*f.y - 0.075), -0.4, 64.);\n    }\n    if (p.x > 0.25 && p.x < 0.5) {\n        vec2 pp = vec2(p.x*1.05, p.y);\n        m = vec2(0.25, PI / 10.);\n        f = mod(pp, m) - 0.5 * m;\n        f.x *= 3.4;\n        res += zebra(vec2(f.x, f.y), 96.);\n        res += zebra(vec2(f.x, f.y - 0.05), 96.);\n        res += zebra(vec2(f.x, f.y + 0.05), 96.);\n        res += zebra(vec2(f.x, f.y - 0.1), 96.);\n        res += zebra(vec2(f.x, f.y + 0.1), 96.);\n    }\n\tres += circle(p, 0.5, 128.);\n    return clamp(res, 0., 1.);\n}\n\n////////////////////////////////////////////////////////////////////////////\n// PRIMITIVES\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n////////////////////////////////////////////////////////////////////////////\n// OPERATORS\n\nvec2 opS( vec2 d1, vec2 d2 )\n{\n    return d1.x > -d2.x ? d1 : vec2(-d2.x, d2.y);\n}\n\nvec2 opI( vec2 d1, vec2 d2 )\n{\n     return d1.x > d2.x ? d1 : d2;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n    return d1.x < d2.x ? d1 : d2;\n}\n\n////////////////////////////////////////////////////////////////////////////\n// MODELS\n\nvec2 box(in vec3 pos)\n{\n    // cover\n    vec2 dc = vec2(FAR, 0.);\n    vec3 cpos = pos;\n    cpos.y -= 1.475;\n    cpos.z += 0.55;\n    cpos = rotateYZ(cpos, -DEG2RAD*60.);\n    dc = opU( dc, vec2( udRoundBox(cpos, vec3(1.5,0.1,1.0), 0.05), 4.));\n    dc = opI( dc, vec2( sdBox(cpos - vec3(0.,0.075,0.), vec3(1.6,0.1,1.1)), 1.));\n    dc = opS( dc, vec2( sdBox(cpos, vec3(1.475,0.1,.95)), 1.));\n\n    // base\n    vec2 db = vec2(FAR, 0.);\n    vec3 bpos = pos;\n    db = opU( db, vec2( udRoundBox(bpos, vec3(1.5,0.55,1.0), 0.05), 3.));\n    db = opI( db, vec2( sdBox(bpos + vec3(0.,0.05,0.), vec3(1.6,0.6,1.1)), 1.));\n    db = opU( db, vec2( sdBox(bpos - vec3(0.,0.1,0.), vec3(1.47,0.5,.95)), 1.));\n    db = opS( db, vec2( sdBox(bpos - vec3(0.,0.12,0.), vec3(1.45,0.6,.92)), 1.));\n\t\n    // joint\n    vec2 dj = vec2(FAR, 0.);\n    vec3 jpos = pos;\n    jpos.y -= 0.555;\n    jpos.z += 1.045;\n    jpos = rotateXY(jpos, -DEG2RAD*90.);\n    dj = opU(dj, vec2( sdCylinder( jpos, vec2(0.015,1.525)), 2.));\n    \n    return opU(dc, opU(db, dj));\n}\n\nvec2 lamp(in vec3 pos)\n{\n    vec2 d = vec2(FAR, 0.);\n    vec3 cpos = pos;\n    cpos = rotateXZ(cpos, DEG2RAD*45.);\n    float sd = sdCapsule(pos, vec3(0.,0.,0.), vec3(0.,1.,0.), 0.6);\n    d = opU(d, vec2( sd \n                    - 0.075*abs(sin(2.*PI*pos.x*pos.z))\n                    - 0.075*abs(sin(2.*PI*cpos.x*cpos.z)), 120.));\n    d = opU(d, vec2( sdCylinder( pos - vec3(0.,0.5,0.), vec2(0.45,1.1)), 121.));\n    d = opS(d, vec2( sdCylinder( pos - vec3(0.,0.5,0.), vec2(0.425,1.15)), 121.));\n    return d;\n}\n\nvec2 ground(in vec3 pos)\n{\n    vec2 d = vec2(FAR, 0.);\n\td = opU(d, vec2(sdCylinder(pos, vec2(5.5, 0.1)), 50.));\n    return d;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(FAR, 0.);\n \tvec3 cpos;\n    // Box\n    cpos = pos;\n    cpos.y -= 0.05;\n    cpos = rotateXZ(cpos, -DEG2RAD*90.);\n    res = opU(res, box(cpos));\n    \n    // Lamps\n    cpos = pos - LIGHTPOS0;\n    cpos.y += 0.5;\n    res = opU(res, lamp(cpos));\n    cpos = pos - LIGHTPOS1;\n    cpos.y += 0.5;\n    res = opU(res, lamp(cpos));\n    cpos = pos - LIGHTPOS2;\n    cpos.y += 0.5;\n    res = opU(res, lamp(cpos));\n\n    // Ground\n    cpos = pos + vec3(0., 0.68, 0.);\n    res = opU(res, ground(cpos));\n    \n    return res;\n}\n\n////////////////////////////////////////////////////////////////////////////\n// RENDER\n\nvec3 gray(vec3 c)\n{\n    return 0.333 * vec3(c.x+c.y+c.z);\n}\n\nfloat texBoxSides(vec3 pos, vec3 nor)\n{\n    if (abs(nor.x) > 0.) {\n        return BoxSideFB(0.5*pos.zy + vec2(0.,-0.02));\n    } else {\n        return BoxSideLR(0.5*pos.xy - vec2(0.,0.02));\n    }\n    return 0.;\n}\n\nfloat texBoxCover(vec3 pos, vec3 nor)\n{\n    if (nor.x < 0.) {\n        vec2 blending = abs( nor.xy );\n        blending = normalize(max(blending, 0.00001));\n        float b = (blending.x + blending.y);\n        blending /= vec2(b, b);\n        vec3 ppos = 0.6*pos + vec3(0.,-0.97,0.);\n        float xaxis = BoxCover( ppos.zy );\n        float yaxis = BoxCover( ppos.zx );\n        return xaxis * blending.x + xaxis * blending.y;\n    }\n    return 0.;\n}\n\nvec3 triPlanarTex(sampler2D sam, vec3 pos, vec3 nor)\n{\n    vec3 blending = abs( nor );\n    blending = normalize(max(blending, 0.00001));\n    float b = (blending.x + blending.y + blending.z);\n    blending /= vec3(b, b, b);\n    vec3 xaxis = texture( sam, pos.yz).xyz;\n    vec3 yaxis = texture( sam, pos.xz).xyz;\n    vec3 zaxis = texture( sam, pos.xy).xyz;\n    // blend the results of the 3 planar projections.\n    return xaxis * blending.x + xaxis * blending.y + zaxis * blending.z;\n}\n\nvec4 colorize(in vec3 pos, in vec3 nor, in float id)\n{\n    vec3 col;\n    float shader = SHADE_NONE;\n    if (id < 1.1) { \t\t// Box Inside\n        col = BOXCOLOR;\n        shader = SHADE_GLOSSY_BOX;\n    } else if (id < 2.1) { \t// Box Joint\n        col = vec3(0.95, 0.9, 0.1);\n        shader = SHADE_GLOSSY_BOX;\n    } else if (id < 3.1) {\t// Box Sides Decoration\n        col = BOXCOLOR * (1. - texBoxSides(pos, nor));\n        shader = SHADE_GLOSSY_BOX;\n    } else if (id < 4.1) {\t// Box Decoration\n        col = BOXCOLOR * (1. - texBoxCover(pos, nor));\n        shader = SHADE_GLOSSY_BOX;\n    } else if (id < 50.1) {\t// Floor\n        col = (1.-Table(0.0905*pos.xz)) * vec3(0.5) * texture(iChannel0, 0.1*pos.xz).rgb;\n        shader = SHADE_GLOSSY_FLOOR;\n    } else if (id < 120.1) {// Lamp paper\n        col = vec3(0.8, 0.4, 0.) - 0.5 * gray(triPlanarTex(iChannel1, pos, nor));\n        shader = SHADE_MAT;\n    } else if (id < 121.1) {// Lamp inside\n        if (pos.y > 3.575 && pos.y < 5.) {\n            col = vec3(1.);\n            shader = SHADE_MAT;\n        } else {\n            col = vec3(0.);\n            shader = SHADE_GLOSSY_BOX;\n        }\n    }\n    return vec4(col, shader);\n}\n\nvec4 castRay( in vec3 ro, in vec3 rd )\n{\n\tconst float tmin = 0.01;\n    const float tmax = 15.0;    \n\tconst float precis = 0.001;\n    float t = tmin;\n    float id = -1.0;\n    vec3 pos;\n    for( int i=0; i<60; i++ )\n    {\n        pos = ro+rd*t;\n\t    vec2 res = map( pos );\n        if( abs(res.x)<precis || t>tmax ) break;\n        t += res.x;\n\t    id = res.y;\n    }\n\n    if( t>tmax ) id=-1.0;\n    return vec4( pos, id );\n}\n\nfloat minDist( in vec3 ro, in vec3 rd, in vec3 refPos )\n{\n\tconst float tmin = 0.1;\n    const float tmax = 30.0;\n    float t = tmin;\n    float min = FAR;\n    float lastmin = FAR;\n    vec3 pos;\n    for( int i=0; i<20; i++ )\n    {\n        pos = ro+rd*t;\n        float d = distance(pos, refPos);\n        if( min > lastmin || t>tmax ) break;\n        t += d;\n        lastmin = min;\n        min = d;\n    }\n    return lastmin;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec2 eps = vec2( 0.001, 0.0 );\n    vec2 vx0 = map(pos+eps.xyy);\n    vec2 vx1 = map(pos-eps.xyy);\n    vec2 vy0 = map(pos+eps.yxy);\n    vec2 vy1 = map(pos-eps.yxy);\n    vec2 vz0 = map(pos+eps.yyx);\n    vec2 vz1 = map(pos-eps.yyx);\n    \n\tvec3 nor = vec3(\n\t    vx0.y == vx1.y ? vx0.x - vx1.x : 0.,\n\t    vy0.y == vy1.y ? vy0.x - vy1.x : 0.,\n\t    vz0.y == vz1.y ? vz0.x - vx1.x : 0.);\n\n    return normalize(nor);\n}\n\nvec3 shade(vec3 pos, vec3 nor, vec3 col, vec3 lightPos, vec3 lightColor)\n{\n\tfloat dist = distance(lightPos, vec3(pos));\n\tfloat att = 1.;//exp(-0.325*dist);\n    float cosine = dot(nor, normalize(lightPos-pos));\n    float ambient = clamp( 0.01+0.005*nor.y, 0.0, 1.0 );\n    float diffuse = 0.;\n    float specular = 0.;\n    if (cosine > 0.){\n        diffuse = att*cosine;\n    }\t\n    specular = att*pow(abs(cosine), 10.);\n\treturn col*ambient+col*diffuse*lightColor+col*specular*lightColor;\n}\n\nstruct Material {\n\tvec3  color;\t\t// diffuse color\n\tfloat n;\t\t\t// refraction index\n\tfloat roughness;\t// Cook-Torrance roughness\n\tfloat fresnel;\t\t// Cook-Torrance fresnel reflectance\n\tfloat density;\t\t// Cook-Torrance color density i.e. fraction of diffuse reflection\n};\n\nstruct Light {\n\tvec3 pos;\n\tvec3 color;\n};\n\n/// References:\n/// http://content.gpwiki.org/index.php/D3DBook:%28Lighting%29_Cook-Torrance\n/// http://ruh.li/GraphicsCookTorrance.html\nvec3 shadeCookTorrance( vec3 pos, vec3 nor, vec3 vd, Material mat, Light lig )\n{\n\tfloat roughness = mat.roughness;\n\tfloat F0 = mat.fresnel;\n\tfloat K = mat.density;\n\t//\n\tvec3 ld = normalize(lig.pos-pos);\n\tvec3 h = normalize(vd+ld);\n\tfloat NdotL = clamp( dot( nor, ld ),0.,1. );\n\tfloat NdotH = clamp( dot( nor, h ),0.,1. );\n\tfloat NdotV = clamp( dot( nor, vd ),0.,1. );\n\tfloat VdotH = clamp( dot( h, vd ),0.,1. );\n\tfloat rsq = roughness * roughness;\n\t\n\t// Geometric Attenuation\n\tfloat NH2   = 2. * NdotH / VdotH;\n\tfloat geo_b = (NH2 * NdotV );\n\tfloat geo_c = (NH2 * NdotL );\n\tfloat geo   = min( 1., min( geo_b, geo_c ) );\n\t\n\t// Roughness\n\t// Beckmann distribution function\n\tfloat r1 = 1. / ( 4. * rsq * pow(NdotH, 4.));\n\tfloat r2 = (NdotH * NdotH - 1.) / (rsq * NdotH * NdotH);\n\tfloat rough = r1 * exp(r2);\n\t\n\t// Fresnel\t\t\t\n\tfloat fres = pow( 1.0 - VdotH, 5. );\n\tfres *= ( 1.0 - F0 );\n\tfres += F0;\n\t\n\tvec3 spec = (NdotV * NdotL==0.) ? vec3(0.) : vec3 ( fres * geo * rough ) / ( NdotV * NdotL );\n\tvec3 res = NdotL * ( (1.-K)*spec + K*mat.color ) * lig.color;// * exp(-0.001*length(lig.pos-i.p));\n\treturn clamp(res, 0., 1.);\n}\n\nfloat occlusion( in vec3 pos, in Light lig )\n{\n    vec3 rd = normalize(lig.pos - pos);\n    vec4 res = castRay(pos+0.01*rd,rd);\n    return (res.w > 0.) && (res.w < 100.) ? 0. : 1.;\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    const vec3 lightColor = vec3(0.6, 0.2, 0.05);\n    Light lig0;\n    lig0.color = lightColor;\n    lig0.pos = LIGHTPOS0; //vec3(4., 4.5, 4.);\n    Light lig1;\n    lig1.color = lightColor;\n    lig1.pos = LIGHTPOS1; //vec3(-4., 4.5, 4.);\n    Light lig2;\n    lig2.color = lightColor;\n    lig2.pos = LIGHTPOS2; //vec3(-4., 4.5, -4.);\n    Light lig3;\n    lig3.color = lightColor;\n    lig3.pos = vec3(4., 4.5, -4.);\n    //\n    vec3 col = mix(vec3(0.01),vec3(0.025, 0.05, 0.1),abs(4.*rd.y));\n    vec4 res = castRay(ro,rd);\n    vec3 pos = res.xyz;\n\tfloat id = res.w;\n    if( id > 0. )\n    {\n        vec3 nor = calcNormal( pos );\n        vec4 material = colorize(pos, nor, id);\n        vec3 objCol = material.xyz;\n        float shader = material.w;\n        \n        col = vec3(0.);\n        \n       float occ0 = occlusion(pos, lig0);\n       float occ1 = occlusion(pos, lig1);\n       float occ2 = occlusion(pos, lig2);\n\n\t\t if (shader == SHADE_MAT) {\n            Material mat;\n            mat.color = objCol;\n            mat.n = 1.;\n            mat.fresnel = 0.95;\n            mat.roughness = 0.95;\n            mat.density = 0.9;\n            col += occ0 * shadeCookTorrance(pos, nor, -rd, mat, lig0);\n            col += occ1 * shadeCookTorrance(pos, nor, -rd, mat, lig1);\n            col += occ2 * shadeCookTorrance(pos, nor, -rd, mat, lig2);\n   \t\t} else if (shader == SHADE_GLOSSY_BOX) {\n            Material mat;\n            mat.color = objCol;\n            mat.n = 1.;\n            mat.fresnel = 0.95;\n            mat.roughness = 0.05;\n            mat.density = 0.95;\n            col += occ0 * shadeCookTorrance(pos, nor, -rd, mat, lig0);\n            col += occ1 * shadeCookTorrance(pos, nor, -rd, mat, lig1);\n            col += occ2 * shadeCookTorrance(pos, nor, -rd, mat, lig2);\n         \tcol += 0.2*lig0.color*clamp( dot( nor, normalize(vec3(-lig0.pos.x,0.0,-lig0.pos.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n         \tcol += 0.2*lig1.color*clamp( dot( nor, normalize(vec3(-lig1.pos.x,0.0,-lig1.pos.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n         \tcol += 0.2*lig2.color*clamp( dot( nor, normalize(vec3(-lig2.pos.x,0.0,-lig2.pos.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        } else if (shader == SHADE_GLOSSY_FLOOR) {\n            Material mat;\n            mat.color = objCol;\n            mat.n = 1.;\n            mat.fresnel = 0.95;\n            mat.roughness = 0.05;\n            mat.density = 0.95;\n            float pe = Table(0.0905*pos.xz) - Table(0.0905*(pos.xz+vec2(0.01,0.01)));\n            nor.xz -= 0.15*vec2(1.,1.)*pe;\n            nor = normalize(nor);\n            col += occ0 * shadeCookTorrance(pos, nor, -rd, mat, lig0);\n            col += occ1 * shadeCookTorrance(pos, nor, -rd, mat, lig1);\n            col += occ2 * shadeCookTorrance(pos, nor, -rd, mat, lig2);\n        }\n        col = clamp( col, 0., 1.);\n\t\tfloat amb = 0.1 * clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        col += 0.33*(occ0+occ1+occ2) * amb * objCol;\t\t\n    }\n    if ((id < 1.) || (id > 5.))\n    {\n        float d = min( distance(ro, LIGHTPOS0) > 4. ? minDist(ro, rd, LIGHTPOS0) : FAR,\n                      min( distance(ro, LIGHTPOS1) > 4. ? minDist(ro, rd, LIGHTPOS1) : FAR,\n                           distance(ro, LIGHTPOS2) > 4. ? minDist(ro, rd, LIGHTPOS2) : FAR));\n        if (d < 6.)\n        {\n            col += vec3(0.6, 0.4, 0.1) * exp(-0.75*d);\n        }\n    }\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    //\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 0.05*iTime;\n\n\t// camera\n    float a = sin(PI*time);\n    float b = cos(0.66*PI*time);\n    float d = 3.25 + b;\n    float h = 0.05;\n\tvec3 ro = vec3(d, h, d);\n    mat4 rot = rotationXYZ(0.5*PI*(a*a + mo.y), -2.*PI*time - 0.25*PI - 2.*PI*mo.x, 0.);\n    vec4 ro4 = rot * vec4(ro, 1.);\n    ro = ro4.xyz;\n\tvec3 ta = vec3( 0., 0.5, 0. );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = normalize(ca * normalize( vec3(p.xy,2.0) ));\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n    // gamma correction\n    col = pow( col, vec3(0.8) );\n\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}, {"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mt3XRS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Mt3XWH", "name": "The Walking Raymarcher", "author": "xorxor", "description": "Replaying mocap data with hand-tuned shape animation for Codevember 2016.\n\nInspired by Universal Everything's Walking City and makio64's sketches.\n\nSoundtrack by Simon Pyke", "tags": ["raymarching", "codevember", "mocap"], "likes": 48, "viewed": 1554, "date": "1479282225", "time_retrieved": "2024-06-20T18:44:54.732489", "image_code": "// Created by XORXOR, 2016\n// Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0)\n// https://www.shadertoy.com/view/Mt3XWH\n//\n// Replaying mocap data with hand-tuned shape animation for Codevember 2016.\n// Inspired by Universal Everything's Walking City\n// https://vimeo.com/85596568\n// and makio64's Codevember sketches\n// http://makiopolis.com/codevember/\n//\n// Soundtrack by Simon Pyke\n// https://soundcloud.com/freefarm/walking-city\n\n\n// I don't believe there's no better way to read an array with a non-constant index. Is there?\n#define returnPos() vec3 p0, p1; for(int i=0; i<NUM_FRAMES-1; i++){ if(i==n) { p0=p[i]; p1=p[i+1]; break;}} return mix( p0, p1, f );\n\n#define NUM_FRAMES 21\n\nvec3 getSpine2( int n, float f )\n{\n\tvec3 p[ NUM_FRAMES ];\n\tp[0] = vec3(0.0368,9.18,-0.389); p[1] = vec3(0.036,9.19,-0.386); p[2] = vec3(0.0326,9.19,-0.367); p[3] = vec3(0.0294,9.2,-0.347); p[4] = vec3(0.0272,9.2,-0.33); p[5] = vec3(0.0276,9.2,-0.334); p[6] = vec3(0.029,9.2,-0.345); p[7] = vec3(0.0307,9.19,-0.358); p[8] = vec3(0.0327,9.19,-0.371); p[9] = vec3(0.0346,9.19,-0.383); p[10] = vec3(0.0363,9.18,-0.389); p[11] = vec3(0.0377,9.19,-0.378); p[12] = vec3(0.0388,9.19,-0.357); p[13] = vec3(0.0395,9.2,-0.337); p[14] = vec3(0.0397,9.2,-0.33); p[15] = vec3(0.0396,9.2,-0.336); p[16] = vec3(0.0394,9.2,-0.347); p[17] = vec3(0.0391,9.19,-0.359); p[18] = vec3(0.0387,9.19,-0.371); p[19] = vec3(0.0381,9.19,-0.381); p[20] = vec3(0.0373,9.19,-0.388);\n\treturnPos();\n}\n\nvec3 getLWrist( int n, float f )\n{\n\tvec3 p[ NUM_FRAMES ];\n\tp[0] = vec3(0.829,9.28,2.77); p[1] = vec3(0.817,9.29,2.74); p[2] = vec3(0.809,9.32,2.55); p[3] = vec3(0.972,9.31,2.36); p[4] = vec3(1.27,9.22,2.12); p[5] = vec3(1.62,9.05,1.83); p[6] = vec3(2,8.84,1.38); p[7] = vec3(2.32,8.63,0.77); p[8] = vec3(2.5,8.45,0.0625); p[9] = vec3(2.52,8.33,-0.505); p[10] = vec3(2.54,8.27,-0.816); p[11] = vec3(2.8,8.25,-0.958); p[12] = vec3(3.29,8.36,-0.936); p[13] = vec3(3.8,8.61,-0.774); p[14] = vec3(4.12,8.92,-0.361); p[15] = vec3(4.16,9.19,0.259); p[16] = vec3(3.88,9.24,1.01); p[17] = vec3(3.35,9.25,1.72); p[18] = vec3(2.67,9.28,2.27); p[19] = vec3(1.93,9.33,2.62); p[20] = vec3(1.21,9.33,2.77);\n\treturnPos();\n}\n\nvec3 getHead( int n, float f )\n{\n\tvec3 p[ NUM_FRAMES ];\n\tp[0] = vec3(-0.181,12.1,-0.778); p[1] = vec3(-0.163,12.1,-0.763); p[2] = vec3(-0.0746,12.2,-0.687); p[3] = vec3(0.0121,12.2,-0.6); p[4] = vec3(0.0886,12.2,-0.514); p[5] = vec3(0.138,12.2,-0.444); p[6] = vec3(0.193,12.2,-0.425); p[7] = vec3(0.252,12.2,-0.467); p[8] = vec3(0.303,12.2,-0.564); p[9] = vec3(0.337,12.1,-0.667); p[10] = vec3(0.354,12.1,-0.727); p[11] = vec3(0.349,12.1,-0.647); p[12] = vec3(0.311,12.2,-0.484); p[13] = vec3(0.234,12.2,-0.361); p[14] = vec3(0.141,12.2,-0.317); p[15] = vec3(0.0452,12.2,-0.353); p[16] = vec3(-0.0365,12.2,-0.417); p[17] = vec3(-0.102,12.2,-0.504); p[18] = vec3(-0.149,12.2,-0.603); p[19] = vec3(-0.175,12.2,-0.696); p[20] = vec3(-0.183,12.1,-0.762);\n\treturnPos();\n}\n\nvec3 getSpine1( int n, float f )\n{\n\tvec3 p[ NUM_FRAMES ];\n\tp[0] = vec3(1.75e-08,8.01,-0.0366); p[1] = vec3(1.75e-08,8.01,-0.0366); p[2] = vec3(1.75e-08,8.01,-0.0366); p[3] = vec3(1.75e-08,8.01,-0.0366); p[4] = vec3(1.75e-08,8.01,-0.0366); p[5] = vec3(1.75e-08,8.01,-0.0366); p[6] = vec3(1.75e-08,8.01,-0.0366); p[7] = vec3(1.75e-08,8.01,-0.0366); p[8] = vec3(1.75e-08,8.01,-0.0366); p[9] = vec3(1.75e-08,8.01,-0.0366); p[10] = vec3(1.75e-08,8.01,-0.0366); p[11] = vec3(1.75e-08,8.01,-0.0366); p[12] = vec3(1.75e-08,8.01,-0.0366); p[13] = vec3(1.75e-08,8.01,-0.0366); p[14] = vec3(1.75e-08,8.01,-0.0366); p[15] = vec3(1.75e-08,8.01,-0.0366); p[16] = vec3(1.75e-08,8.01,-0.0366); p[17] = vec3(1.75e-08,8.01,-0.0366); p[18] = vec3(1.75e-08,8.01,-0.0366); p[19] = vec3(1.75e-08,8.01,-0.0366); p[20] = vec3(1.75e-08,8.01,-0.0366);\n\treturnPos();\n}\n\nvec3 getRElbow( int n, float f )\n{\n\tvec3 p[ NUM_FRAMES ];\n\tp[0] = vec3(-1.13,9.51,-3.53); p[1] = vec3(-1.18,9.53,-3.52); p[2] = vec3(-1.46,9.69,-3.48); p[3] = vec3(-1.93,9.89,-3.3); p[4] = vec3(-2.52,10.1,-2.89); p[5] = vec3(-3.04,10.3,-2.25); p[6] = vec3(-3.35,10.3,-1.48); p[7] = vec3(-3.4,10.1,-0.669); p[8] = vec3(-3.14,9.84,0.164); p[9] = vec3(-2.68,9.58,0.756); p[10] = vec3(-2.26,9.38,1.03); p[11] = vec3(-2.09,9.17,1.04); p[12] = vec3(-2.13,8.94,0.857); p[13] = vec3(-2.22,8.71,0.521); p[14] = vec3(-2.31,8.53,0.0537); p[15] = vec3(-2.38,8.43,-0.531); p[16] = vec3(-2.43,8.47,-1.25); p[17] = vec3(-2.35,8.65,-2); p[18] = vec3(-2.12,8.93,-2.67); p[19] = vec3(-1.77,9.21,-3.16); p[20] = vec3(-1.36,9.43,-3.45);\n\treturnPos();\n}\n\nvec3 getLShoulder( int n, float f )\n{\n\tvec3 p[ NUM_FRAMES ];\n\tp[0] = vec3(0.905,10.8,-0.53); p[1] = vec3(0.918,10.8,-0.517); p[2] = vec3(0.977,10.8,-0.456); p[3] = vec3(1.03,10.7,-0.407); p[4] = vec3(1.09,10.7,-0.385); p[5] = vec3(1.12,10.6,-0.407); p[6] = vec3(1.16,10.6,-0.472); p[7] = vec3(1.19,10.6,-0.574); p[8] = vec3(1.21,10.6,-0.698); p[9] = vec3(1.22,10.5,-0.807); p[10] = vec3(1.22,10.5,-0.869); p[11] = vec3(1.21,10.5,-0.83); p[12] = vec3(1.2,10.6,-0.723); p[13] = vec3(1.16,10.6,-0.623); p[14] = vec3(1.12,10.7,-0.557); p[15] = vec3(1.07,10.7,-0.529); p[16] = vec3(1.02,10.8,-0.513); p[17] = vec3(0.983,10.8,-0.508); p[18] = vec3(0.95,10.8,-0.514); p[19] = vec3(0.926,10.8,-0.525); p[20] = vec3(0.91,10.8,-0.532);\n\treturnPos();\n}\n\nvec3 getLKnee( int n, float f )\n{\n\tvec3 p[ NUM_FRAMES ];\n\tp[0] = vec3(0.785,3.85,-0.624); p[1] = vec3(0.943,3.84,-0.57); p[2] = vec3(1.27,3.83,0.0486); p[3] = vec3(1.71,4.02,0.562); p[4] = vec3(2.12,4.33,0.882); p[5] = vec3(2.29,4.51,1.01); p[6] = vec3(2.37,4.79,1.31); p[7] = vec3(2.36,5.21,1.7); p[8] = vec3(2.09,5.31,1.97); p[9] = vec3(1.51,5.01,2.09); p[10] = vec3(0.769,4.38,1.67); p[11] = vec3(0.454,4.24,1.45); p[12] = vec3(0.446,4.23,1.41); p[13] = vec3(0.504,3.96,0.814); p[14] = vec3(0.562,3.87,0.356); p[15] = vec3(0.598,3.87,0.156); p[16] = vec3(0.623,3.87,-0.0922); p[17] = vec3(0.654,3.89,-0.36); p[18] = vec3(0.702,3.91,-0.605); p[19] = vec3(0.767,3.9,-0.661); p[20] = vec3(0.819,3.86,-0.619);\n\treturnPos();\n}\n\nvec3 getLElbow( int n, float f )\n{\n\tvec3 p[ NUM_FRAMES ];\n\tp[0] = vec3(2.32,9.16,1.03); p[1] = vec3(2.32,9.11,1.01); p[2] = vec3(2.33,8.88,0.885); p[3] = vec3(2.36,8.66,0.652); p[4] = vec3(2.42,8.46,0.287); p[5] = vec3(2.5,8.37,-0.181); p[6] = vec3(2.53,8.35,-0.795); p[7] = vec3(2.43,8.41,-1.51); p[8] = vec3(2.13,8.54,-2.2); p[9] = vec3(1.78,8.67,-2.65); p[10] = vec3(1.64,8.78,-2.87); p[11] = vec3(1.87,9,-2.92); p[12] = vec3(2.34,9.33,-2.79); p[13] = vec3(2.73,9.63,-2.53); p[14] = vec3(3.05,9.82,-2.18); p[15] = vec3(3.27,9.84,-1.75); p[16] = vec3(3.38,9.68,-1.18); p[17] = vec3(3.33,9.49,-0.559); p[18] = vec3(3.14,9.35,0.0245); p[19] = vec3(2.85,9.27,0.518); p[20] = vec3(2.52,9.21,0.885);\n\treturnPos();\n}\n\nvec3 getRHip( int n, float f )\n{\n\tvec3 p[ NUM_FRAMES ];\n\tp[0] = vec3(-0.847,6.35,-0.0933); p[1] = vec3(-0.847,6.35,-0.0938); p[2] = vec3(-0.85,6.35,-0.0979); p[3] = vec3(-0.856,6.36,-0.109); p[4] = vec3(-0.863,6.37,-0.127); p[5] = vec3(-0.87,6.38,-0.149); p[6] = vec3(-0.877,6.38,-0.173); p[7] = vec3(-0.882,6.38,-0.198); p[8] = vec3(-0.886,6.38,-0.222); p[9] = vec3(-0.889,6.37,-0.246); p[10] = vec3(-0.89,6.36,-0.266); p[11] = vec3(-0.89,6.35,-0.277); p[12] = vec3(-0.887,6.34,-0.277); p[13] = vec3(-0.882,6.33,-0.262); p[14] = vec3(-0.875,6.31,-0.24); p[15] = vec3(-0.867,6.3,-0.214); p[16] = vec3(-0.858,6.29,-0.185); p[17] = vec3(-0.851,6.29,-0.157); p[18] = vec3(-0.847,6.3,-0.131); p[19] = vec3(-0.845,6.31,-0.11); p[20] = vec3(-0.846,6.33,-0.0968);\n\treturnPos();\n}\n\nvec3 getRShoulder( int n, float f )\n{\n\tvec3 p[ NUM_FRAMES ];\n\tp[0] = vec3(-1.03,10.5,-1.06); p[1] = vec3(-1.02,10.5,-1.05); p[2] = vec3(-0.963,10.6,-1.02); p[3] = vec3(-0.912,10.7,-0.96); p[4] = vec3(-0.873,10.7,-0.88); p[5] = vec3(-0.856,10.8,-0.789); p[6] = vec3(-0.839,10.8,-0.714); p[7] = vec3(-0.818,10.8,-0.668); p[8] = vec3(-0.798,10.8,-0.656); p[9] = vec3(-0.783,10.8,-0.662); p[10] = vec3(-0.775,10.8,-0.666); p[11] = vec3(-0.781,10.8,-0.612); p[12] = vec3(-0.806,10.8,-0.531); p[13] = vec3(-0.852,10.8,-0.485); p[14] = vec3(-0.902,10.7,-0.501); p[15] = vec3(-0.95,10.7,-0.573); p[16] = vec3(-0.988,10.6,-0.664); p[17] = vec3(-1.01,10.6,-0.767); p[18] = vec3(-1.03,10.6,-0.873); p[19] = vec3(-1.04,10.5,-0.967); p[20] = vec3(-1.03,10.5,-1.04);\n\treturnPos();\n}\n\nvec3 getRWrist( int n, float f )\n{\n\tvec3 p[ NUM_FRAMES ];\n\tp[0] = vec3(-1.6,8.04,-1.82); p[1] = vec3(-1.65,8.05,-1.84); p[2] = vec3(-1.99,8.08,-1.94); p[3] = vec3(-2.54,8.13,-1.96); p[4] = vec3(-3.3,8.3,-1.75); p[5] = vec3(-3.96,8.55,-1.12); p[6] = vec3(-4.18,8.71,-0.0801); p[7] = vec3(-3.77,8.73,1.11); p[8] = vec3(-2.76,8.78,2.16); p[9] = vec3(-1.57,8.95,2.67); p[10] = vec3(-0.714,9.18,2.71); p[11] = vec3(-0.359,9.3,2.55); p[12] = vec3(-0.396,9.31,2.32); p[13] = vec3(-0.576,9.29,2.02); p[14] = vec3(-0.845,9.19,1.69); p[15] = vec3(-1.15,9,1.32); p[16] = vec3(-1.47,8.65,0.829); p[17] = vec3(-1.72,8.32,0.182); p[18] = vec3(-1.82,8.12,-0.545); p[19] = vec3(-1.78,8.03,-1.19); p[20] = vec3(-1.66,8.03,-1.65);\n\treturnPos();\n}\n\nvec3 getRAnkle( int n, float f )\n{\n\tvec3 p[ NUM_FRAMES ];\n\tp[0] = vec3(-0.994,1.24,2.41); p[1] = vec3(-0.587,1.02,2.41); p[2] = vec3(-0.478,0.89,1.7); p[3] = vec3(-0.466,0.664,0.998); p[4] = vec3(-0.4,0.473,0.322); p[5] = vec3(-0.354,0.463,-0.229); p[6] = vec3(-0.338,0.502,-0.778); p[7] = vec3(-0.343,0.586,-1.36); p[8] = vec3(-0.374,0.715,-1.93); p[9] = vec3(-0.412,0.938,-2.51); p[10] = vec3(-0.464,1.33,-3.08); p[11] = vec3(-0.46,1.96,-3.65); p[12] = vec3(-0.48,2.61,-3.87); p[13] = vec3(-0.531,2.99,-3.45); p[14] = vec3(-0.503,2.98,-2.8); p[15] = vec3(-0.587,2.74,-2.06); p[16] = vec3(-0.745,2.89,-1.29); p[17] = vec3(-0.861,2.99,-0.664); p[18] = vec3(-0.918,2.69,-0.0864); p[19] = vec3(-0.881,1.83,0.69); p[20] = vec3(-0.72,1.2,1.79);\n\treturnPos();\n}\n\nvec3 getLHip( int n, float f )\n{\n\tvec3 p[ NUM_FRAMES ];\n\tp[0] = vec3(0.892,6.35,-0.129); p[1] = vec3(0.892,6.35,-0.129); p[2] = vec3(0.889,6.34,-0.125); p[3] = vec3(0.883,6.33,-0.114); p[4] = vec3(0.876,6.32,-0.0966); p[5] = vec3(0.867,6.31,-0.0752); p[6] = vec3(0.857,6.31,-0.0521); p[7] = vec3(0.848,6.31,-0.0284); p[8] = vec3(0.839,6.32,-0.00525); p[9] = vec3(0.83,6.32,0.0163); p[10] = vec3(0.823,6.33,0.0347); p[11] = vec3(0.819,6.34,0.0452); p[12] = vec3(0.822,6.35,0.0448); p[13] = vec3(0.832,6.37,0.0323); p[14] = vec3(0.845,6.38,0.0128); p[15] = vec3(0.858,6.39,-0.0113); p[16] = vec3(0.871,6.4,-0.0381); p[17] = vec3(0.882,6.41,-0.0654); p[18] = vec3(0.89,6.4,-0.0911); p[19] = vec3(0.893,6.38,-0.112); p[20] = vec3(0.893,6.36,-0.126);\n\treturnPos();\n}\n\nvec3 getRKnee( int n, float f )\n{\n\tvec3 p[ NUM_FRAMES ];\n\tp[0] = vec3(-1.22,4.58,1.71); p[1] = vec3(-0.858,4.26,1.37); p[2] = vec3(-0.798,4.27,1.37); p[3] = vec3(-0.742,4.07,0.989); p[4] = vec3(-0.691,3.88,0.358); p[5] = vec3(-0.675,3.85,0.0894); p[6] = vec3(-0.676,3.84,-0.139); p[7] = vec3(-0.683,3.85,-0.405); p[8] = vec3(-0.702,3.88,-0.674); p[9] = vec3(-0.736,3.9,-0.837); p[10] = vec3(-0.799,3.89,-0.849); p[11] = vec3(-0.891,3.88,-0.876); p[12] = vec3(-1.11,3.86,-0.778); p[13] = vec3(-1.54,3.87,-0.371); p[14] = vec3(-1.86,3.98,0.0739); p[15] = vec3(-2.03,4.17,0.562); p[16] = vec3(-2.14,4.56,1.18); p[17] = vec3(-2.13,4.98,1.61); p[18] = vec3(-1.97,5.14,1.84); p[19] = vec3(-1.58,4.88,1.86); p[20] = vec3(-1.2,4.57,1.7);\n\treturnPos();\n}\n\nvec3 getLAnkle( int n, float f )\n{\n\tvec3 p[ NUM_FRAMES ];\n\tp[0] = vec3(0.645,1.27,-2.85); p[1] = vec3(0.941,1.62,-3.15); p[2] = vec3(1.01,2.52,-3.04); p[3] = vec3(1.03,3.06,-2.54); p[4] = vec3(1.13,3.11,-2.02); p[5] = vec3(1.25,2.87,-1.66); p[6] = vec3(1.35,2.77,-1.08); p[7] = vec3(1.32,2.86,-0.344); p[8] = vec3(1.02,2.5,0.608); p[9] = vec3(0.784,1.73,1.76); p[10] = vec3(0.342,1.1,2.54); p[11] = vec3(-0.128,0.972,2.24); p[12] = vec3(0.0519,0.846,1.48); p[13] = vec3(0.129,0.568,0.847); p[14] = vec3(0.204,0.475,0.281); p[15] = vec3(0.266,0.485,-0.211); p[16] = vec3(0.301,0.534,-0.758); p[17] = vec3(0.355,0.618,-1.31); p[18] = vec3(0.454,0.738,-1.85); p[19] = vec3(0.602,0.952,-2.39); p[20] = vec3(0.721,1.22,-2.78);\n\treturnPos();\n}\n\nvec3 head, spine1, spine2;\nvec3 lHip, lKnee, lAnkle, lShoulder, lElbow, lWrist;\nvec3 rHip, rKnee, rAnkle, rShoulder, rElbow, rWrist;\n\nfloat smin( float a, float b )\n{\n    const float k = 2.9;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat tRidgeStrength = 0.2;\nfloat tRidgeFreq = 10.0;\nvec3 tLatticeRadii = vec3( 0.0 );\nfloat tR = 1.2;\n\nvec2 map( vec3 p )\n{\n    float plane = abs( p.y + 0.9 );\n\n    vec3 q = mod( p, 1.0 ) - 0.5;\n    float lattice = min( length( q.xy ) - tLatticeRadii.x,\n                    min( length( q.yz ) - tLatticeRadii.y,\n                         length( q.xz ) - tLatticeRadii.z ) );\n    \n    p.y -= tRidgeStrength * ( 2.0 - p.y * 0.1 ) * ( 1.0 +  sin( p.y * tRidgeFreq ) );\n\n    float d = length( p - head ) - tR;\n    d = smin( d, length( p - spine1 ) - tR );\n    d = smin( d, length( p - spine2 ) - tR );\n    d = smin( d, length( p - lHip ) - tR );\n    d = smin( d, length( p - lKnee ) - tR );\n    d = smin( d, length( p - lAnkle ) - 1.5 * tR );\n    d = smin( d, length( p - lShoulder ) - tR );\n    d = smin( d, length( p - lElbow ) - 0.8 * tR );\n    d = smin( d, length( p - lWrist ) - 0.7 * tR );\n    \n    d = smin( d, length( p - rHip ) - tR );\n    d = smin( d, length( p - rKnee ) - tR );\n    d = smin( d, length( p - rAnkle ) - 1.5 * tR );\n    d = smin( d, length( p - rShoulder ) - tR );\n    d = smin( d, length( p - rElbow ) - 0.8 * tR );\n    d = smin( d, length( p - rWrist ) - 0.7 * tR );\n    \n    d = max( d, -lattice );\n    return ( d < plane ) ? vec2( d, 1.0 ) : vec2( plane, 2.0 );\n}\n\nfloat calcShadow( vec3 ro, vec3 rd, float mint, float maxt )\n{\n    float t = mint;\n    float res = 1.0;\n    for ( int i = 0; i < 10; i++ )\n    {\n        float h = map( ro + rd * t ).x;\n        res = min( res, 1.1 * h / t );\n        t += h;\n        if ( ( h < 0.001 ) || ( t > maxt ) )\n        {\n            break;\n        }\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec2 trace( vec3 ro, vec3 rd )\n{\n    const float kTMin = 0.01;\n    const float kTMax = 200.0;\n    const float kEps = 0.001;\n\n    float t = kTMin;\n    vec2 res;\n    for ( int i = 0; i < 70; i++ )\n    {\n        vec3 pos = ro + rd * t;\n        res = map( pos );\n        if ( ( res.x < kEps ) || ( t > kTMax ) )\n        {\n            break;\n        }\n        t += res.x * 0.5;\n    }\n\n    if ( t < kTMax )\n    {\n        return vec2( t, res.y );\n    }\n    else\n    {\n        return vec2( -1.0 );\n    }\n}\n\nvec3 calcNormal( vec3 p )\n{\n    const vec2 e = vec2( 0.005, 0 );\n    float dp = map( p ).x;\n    return normalize( vec3( dp - map( p - e.xyy ).x,\n                            dp - map( p - e.yxy ).x,\n                            dp - map( p - e.yyx ).x ) );\n}\n\nmat3 calcCamera( vec3 eye, vec3 target )\n{\n    vec3 cw = normalize( target - eye );\n    vec3 cu = cross( cw, vec3( 0, 1, 0 ) );\n    vec3 cv = cross( cu, cw );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float walkTime = mod( 10.0 * iTime, float( NUM_FRAMES - 1 ) );\n    int inTime = int( floor( walkTime ) );\n    float fTime = fract( walkTime );\n    head = getHead( inTime, fTime );\n    spine1 = getSpine1( inTime, fTime );\n    spine2 = getSpine2( inTime, fTime );\n    lHip = getLHip( inTime, fTime );\n    lKnee = getLKnee( inTime, fTime );\n    lAnkle = getLAnkle( inTime, fTime );\n    lShoulder = getLShoulder( inTime, fTime );\n\tlElbow = getLElbow( inTime, fTime );\n\tlWrist = getLWrist( inTime, fTime );\n    rHip = getRHip( inTime, fTime );\n\trKnee = getRKnee( inTime, fTime );\n    rAnkle = getRAnkle( inTime, fTime );\n\trShoulder = getRShoulder( inTime, fTime );\n\trElbow = getRElbow( inTime, fTime );\n\trWrist = getRWrist( inTime, fTime );\n    \n    float trTime = mod( iTime, 140.0 );\n    \n    tRidgeStrength = 0.2;\n\ttRidgeFreq = 0.0;\n    tLatticeRadii = vec3( 0.0 );\n    tR = 1.2;\n    \n    if ( trTime < 5.0 )\n    {\n        tRidgeStrength = 0.2;\n\t\ttRidgeFreq = 0.0;\n\t\ttLatticeRadii = vec3( 0.0 ); \n    }\n    else\n    if ( trTime < 10.0 )\n    {\n        tRidgeFreq = 10.0 * smoothstep( 5.0, 10.0, trTime );  \n    }\n    else\n    if ( trTime < 20.0 )\n    {\n        tRidgeFreq = 10.0;\n    }\n    else\n    if ( trTime < 40.0 )\n    {\n        tRidgeFreq = 10.0;\n        tLatticeRadii = mix( vec3( 0.0 ), vec3( 0.3, 0.0, 0.0 ),\n                       \t\t smoothstep( 20.0, 40.0, trTime ) );\n    }\n    else\n    if ( trTime < 60.0 )\n    {\n        tRidgeFreq = 10.0;\n        tLatticeRadii  = mix( vec3( 0.3, 0.0, 0.0 ), vec3( 0.0, 0.0, 0.6 ),\n                              smoothstep( 40.0, 60.0, trTime ) );\n    }\n    else\n    if ( trTime < 70.0 )\n    {\n        float t = smoothstep( 60.0, 70.0, trTime );\n        tRidgeFreq = 10.0 - 10.0 * t;\n        tLatticeRadii = mix( vec3( 0.0, 0.0, 0.6 ), vec3( 0.0 ), t );\n        tR = mix( 1.2, 2.25, t ); \n    }\n    else\n    if ( trTime < 90.0 )\n    {\n        float t = smoothstep( 70.0, 90.0, trTime );\n        tRidgeFreq = 10.0;\n        tLatticeRadii = vec3( 0.0 );\n        tR = 2.25;\n        tRidgeStrength = 0.2 * t;\n    }\n    else\n    if ( trTime < 100.0 )\n    {\n        float t = smoothstep( 90.0, 100.0, trTime );\n        tRidgeFreq = 10.0;\n        tLatticeRadii = mix( vec3( 0.0 ), vec3( 0.5 ), t );\n        tR = 2.25;\n    }\n    else\n    if ( trTime < 120.0 )\n    {\n        float t = smoothstep( 100.0, 120.0, trTime );\n        tRidgeFreq = 10.0;\n        tLatticeRadii = vec3( 0.5 );\n        tR = mix( 2.25, 1.2, t );\n    }\n    else\n    if ( trTime < 140.0 )\n    {\n        float t = smoothstep( 120.0, 140.0, trTime );\n        tRidgeFreq = 10.0 - 10.0 * t;\n        tLatticeRadii = mix( vec3( 0.5 ), vec3( 0.0 ), t );\n    }\n\n    vec2 mo = vec2( 0.95, -0.2 );\n    if ( iMouse.z > 0.5 )\n    {\n        mo = 2.0 * iMouse.xy / iResolution.xy - 1.0;\n        mo *= 3.14159 * vec2( 0.4, 0.1 );\n    }\n    mo += 3.14159 * 0.5;\n\n    vec3 eye = vec3( 40.0 * cos( mo.x ), 30.0 + 20.0 * cos( mo.y ), 40.0 * sin( mo.x ) );\n    vec3 target = vec3( 0.0, 6.0, 0.0 );\n    \n    mat3 cam = calcCamera( eye, target );\n\n \tvec2 uv = ( fragCoord.xy - 0.5 * iResolution.xy ) / iResolution.y;\n    vec3 rd = cam * normalize( vec3( uv, 2.0 ) );\n\n    vec3 col = vec3( 1.0 );\n    \n    vec2 res = trace( eye, rd );\n    if ( res.x > 0.0 )\n    {\n        vec3 pos = eye + rd * res.x;\n        vec3 nor = calcNormal( pos );\n        vec3 ldir = normalize( vec3( -10.5, 20.8, 24.0 ) );\n        \n        if ( res.y < 1.5 )\n        {\n        \tcol = 0.5 + 0.5 * nor;\n            float dif = max( dot( nor, ldir ), 0.0 );\n            vec3 ref = reflect( rd, nor );\n            float spe = pow( clamp( dot( ref, ldir ), 0.0, 1.0 ), 15.0 );\n\n            col *= ( 0.3 + 0.7 * dif );\n            float edge = pow( 1.0 - dot( -rd, nor ), 1.1 );\n        \tcol += 0.8 * edge + spe;\n        }\n      \n        float sh = calcShadow( pos, ldir, 0.1, 30.0 );\n        col *= ( 0.5 + sh );\n    }\n    \n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "XsBGWh", "previewfilepath": "https://soundcloud.com/freefarm/walking-city", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/freefarm/walking-city", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-4.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mt3XWH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Mt3XzH", "name": "The Daily Shade, day 1: Fokeh", "author": "psonice", "description": "I've planned to do a \"write a shader a day\" thing for a while, ideally a whole month. But every month seems to have something in the way :D\n\nSo, let's just do it. I'll miss days. So what.", "tags": ["bokeh", "raytrace", "daily"], "likes": 13, "viewed": 1212, "date": "1478103796", "time_retrieved": "2024-06-20T18:44:55.404968", "image_code": "// Day 1: Get some basic raymarcher working. \n// Or... no, let's do some kind of fake bokeh thing, I've not done that before.\n\n// A camera. Has a position and a direction. \nstruct Camera {\n    vec3 pos;\n    vec3 dir;\n};\n    \n// A ray. Has origin + direction.\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n    \n// A disk. Has position, size, colour.\nstruct Disk {\n    vec3 pos;\n    float radius;\n    vec3 col;\n};\n        \n    vec4 intersectDisk(in Ray ray, in Disk disk, in float focalPoint) {\n        // Move ray to Z plane of disk\n        ray.origin += ray.dir * disk.pos.z;\n        \n        // Find distance from ray to disk (only xy needs considering since they have equal Z)\n        float dist = length(ray.origin.xy - disk.pos.xy);\n        \n        // blur depends on distance from focal point\n        float blurRadius = abs(focalPoint - disk.pos.z) * 0.1;\n        \n        // Calculate alpha component, using blur radius and disk radius\n        float alpha = 1. - smoothstep(max(0., disk.radius - blurRadius), disk.radius + blurRadius, dist);\n       \n        // Limit to 50% opacity\n        alpha *= 0.3;\n       \t\n        // Pre-multiply by alpha and return\n        return vec4(disk.col * alpha, alpha);\n    }\n\n// Normalised random number, borrowed from Hornet's noise distributions: https://www.shadertoy.com/view/4ssXRX\nfloat nrand( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // We'll need a camera. And some perspective.\n    \n\t// Get some coords for the camera angle from the frag coords. Convert to -1..1 range.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2. - 1.;\n    \n    // Aspect correction so we don't get oval bokeh\n    uv.y *= iResolution.y/iResolution.x;\n    \n    // Make a camera at 0,0,0 pointing forwards\n    Camera cam = Camera(vec3(0, 0, 0.), vec3(0, 0, 1));\n                        \n    // Find the ray direction. Simple in this case.\n    Ray ray = Ray(cam.pos, normalize(cam.dir + vec3(uv, 0)));\n    \n    // Cast the ray into the scene, intersect it with bokeh disks.\n    // I'm using a float since the loop is simple and it avoids a cast (costly on some platforms)\n    const float diskCount = 100.;\n    \n    // Set the focal point\n    float focalPoint = 2.0;\n    \n    // Create an empty colour\n    vec4 col = vec4(0.);\n    \n    float time = iTime * 0.1;\n    \n    for (float i=0.0; i<diskCount; i++) {\n        // random disk position\n        vec3 diskPos = vec3(\n            sin(i*(nrand(vec2(i-3., i + 1.)) + 1.) + time),\n            sin(i*(nrand(vec2(i-2., i + 2.)) + 2.) + time * 0.9), \n            sin(i*(nrand(vec2(i-1., i + 3.)) + 2.) + time * 0.9) * 5. + 5.5\n            );\n        \n        // Scale x+y by z so it fills the space a bit more nicely\n        diskPos.xy *= diskPos.z*0.7;\n        \n        // random disk colour\n        vec3 diskCol = vec3(\n            sin(i) * 0.25 + 0.75,\n            sin(i + 4.) * 0.25 + 0.55,\n            sin(i + 8.) * 0.25 + 0.65\n        );\n        \n        // random disk size\n        float diskSize = nrand(vec2(i)) * 0.2 + 0.1;\n        \n        // create the disk\n        Disk disk = Disk(diskPos, diskSize, diskCol);\n        \n        // Intersect the disk\n        vec4 result = intersectDisk(ray, disk, focalPoint);\n        \n        // Add the colour in\n       col += result;\n    }\n    \n\tfragColor = vec4(col.rgb,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mt3XzH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Mt3XzN", "name": "Balloon Dance", "author": "dr2", "description": "Balloons at dawn", "tags": ["fire", "balloon"], "likes": 13, "viewed": 655, "date": "1478430569", "time_retrieved": "2024-06-20T18:44:55.416856", "image_code": "// \"Balloon Dance\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat Noisefv3 (vec3 p);\nfloat Fbm2 (vec2 p);\nfloat PrSphDf (vec3 p, float s);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\n\nconst float pi = 3.14159;\n\n#define N_BAL 5\n\nvec3 balPos[N_BAL], sunDir, qHit, qHitFlm;\nfloat dstFar, tCur, balRad, flmCylRad, flmCylLen;\nint idObj, idGrp;\nbool balFlm[N_BAL], balFlmCur;\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, skyCol, sunCol, p;\n  float ds, fd, att, attSum, d, sd;\n  if (rd.y >= 0.) {\n    p = rd * (200. - ro.y) / max (rd.y, 0.0001);\n    ds = 0.1 * sqrt (length (p));\n    p += ro;\n    fd = 0.002 / (smoothstep (0., 10., ds) + 0.1);\n    p.xz *= fd;\n    p.xz += 0.1 * tCur;\n    att = Fbm2 (p.xz);\n    attSum = att;\n    d = fd;\n    ds *= fd;\n    for (int j = 0; j < 4; j ++) {\n      attSum += Fbm2 (p.xz + d * sunDir.xz);\n      d += ds;\n    }\n    attSum *= 0.3;\n    att *= 0.3;\n    sd = clamp (dot (sunDir, rd), 0., 1.);\n    skyCol = mix (vec3 (0.7, 1., 1.), vec3 (1., 0.4, 0.1), 0.25 + 0.75 * sd);\n    sunCol = vec3 (1., 0.8, 0.7) * pow (sd, 1024.) +\n       vec3 (1., 0.4, 0.2) * pow (sd, 256.);\n    col = mix (vec3 (0.5, 0.75, 1.), skyCol, exp (-2. * (3. - sd) *\n       max (rd.y - 0.1, 0.))) + 0.3 * sunCol;\n    attSum = 1. - smoothstep (1., 9., attSum);\n    col = mix (vec3 (0.4, 0., 0.2), mix (col, vec3 (0.3, 0.3, 0.3), att), attSum) +\n       vec3 (1., 0.4, 0.) * pow (attSum * att, 3.) * (pow (sd, 10.) + 0.5);\n  } else col = vec3 (0.1, 0.2, 0.1);\n  return col;\n}\n\nfloat FlmDf (vec3 p)\n{\n  vec3 q;\n  float d, dMin;\n  dMin = dstFar;\n  for (int k = 0; k < N_BAL; k ++) {\n    if (balFlm[k]) {\n      q = p - (balPos[k] - vec3 (0., 0.8 * balRad, 0.));\n      d = PrCylDf (q.xzy, flmCylRad + 0.3 * q.y / flmCylLen, flmCylLen);\n      d = max (d, - q.y - 0.5 * flmCylLen);\n      if (d < dMin) { dMin = d;  qHitFlm = q; }\n    }\n  }\n  return dMin;\n}\n\nfloat FlmRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = FlmDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  if (d >= 0.001) dHit = dstFar;\n  return dHit;\n}\n\nfloat BalDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  q = p;\n  d = max (PrSphDf (q, balRad), - PrSphDf (q, 0.98 * balRad));\n  q.y -= - balRad;\n  d = max (d, - PrCylDf (q.xzy, 0.3 * balRad, 0.1 * balRad));\n  if (d < dMin) { dMin = d;  idObj = 1;  qHit = p;}\n  q = p;\n  q.y -= -1.42 * balRad;\n  d = PrCylDf (q.xzy, 0.05 * balRad, 0.13 * balRad);\n  q.y -= 0.02 * balRad;\n  d = max (d, - PrCylDf (q.xzy, 0.03 * balRad, 0.13 * balRad));\n  if (d < dMin) { dMin = d;  idObj = 2;  qHit = p;}\n  q = p;\n  q.y -= -1.5 * balRad;\n  d = PrCylDf (q.xzy, 0.2 * balRad, 0.07 * balRad);\n  q.y -= 0.02 * balRad;\n  d = max (d, - PrCylDf (q.xzy, 0.18 * balRad, 0.07 * balRad));\n  if (d < dMin) { dMin = d;  idObj = 3;  qHit = p;}\n  q = p;\n  q.xz = abs (q.xz) - 0.25 * balRad;\n  q.y -= -1.15 * balRad;\n  q.yz = Rot2D (q.yz, -0.35);\n  q.xy = Rot2D (q.xy, 0.35);\n  d = PrCylDf (q.xzy, 0.005 * balRad, 0.35 * balRad);\n  if (d < dMin) { dMin = d;  idObj = 4;  qHit = p;}\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin, d;\n  dMin = dstFar;\n  for (int k = 0; k < N_BAL; k ++) {\n    d = BalDf (p - balPos[k], dMin);\n    if (d < dMin) { dMin = d;  idGrp = k;  balFlmCur = balFlm[k]; }\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * vec3 (v.y, v.z, v.w));\n}\n\nvec3 FlmCol (vec3 p, vec3 rd)\n{\n  vec3 q, qq;\n  float a, f, dr;\n  a = 0.;\n  p.y -= - flmCylLen;\n  dr = 0.05 / flmCylRad;\n  for (int j = 0; j < 20; j ++) {\n    p += dr * rd;\n    q = 15. * p / flmCylLen;\n    q.y -= 40. * tCur;\n    qq.y = Noisefv3 (q + 0.1 * vec3 (sin (tCur)));\n    qq.x = Noisefv3 (q + vec3 (qq.y));\n    qq.z = Noisefv3 (q + vec3 (qq.x));\n    q = p + 0.25 * (1. - 3. * p.y / flmCylLen) * (qq - 0.5);\n    f = 0.45 * q.y - 2.5 * length (q.xz);\n    f = clamp (sign (f) * f * f, 0., 1.) * (3. - 0.9 * q.y);\n    a += f;\n  }\n  return clamp (a * vec3 (1., 0.5, 0.3), 0., 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, col, colFlm;\n  float dstObj, dstFlm, a, s;\n  bool inSun, inFlm;\n  for (int k = 0; k < N_BAL; k ++) {\n    s = float (k - 1) / float (N_BAL);\n    a = 2. * pi * fract (0.02 * tCur + s);\n    balPos[k].xz = 2.5 * balRad * vec2 (cos (a), sin (a));\n    a = 2. * pi * fract (0.07 * tCur + s);\n    balPos[k].y = 3. * balRad + 0.5 * balRad * sin (a);\n    balFlm[k] = (a > pi);\n  }\n  flmCylRad = 0.4;\n  flmCylLen = 2.;\n  dstFlm = FlmRay (ro, rd);\n  dstObj = ObjRay (ro, rd);\n  inSun = true;\n  inFlm = false;\n  if (dstObj < dstFar) {\n    ro += rd * dstObj;\n    vn = ObjNf (ro);\n    if (idObj == 1) {\n      col = HsvToRgb (vec3 (float (idGrp) / float (N_BAL), 0.9, 0.8));\n      col *= 1. + 0.2 * SmoothBump (0.17, 0.25, 0.02,\n         min (length (qHit.xy), length (qHit.zy)) / balRad);\n      inFlm = balFlmCur;\n      if (length (qHit) < 0.99 * balRad) {\n        col *= 0.2;\n        if (inFlm) col += 0.1 * vec3 (1., 0.5, 0.);\n        inSun = false;\n      } else {\n        if (length (qHit) > 0.99 * balRad) {\n          a = atan (qHit.x, qHit.z) / (2. * pi) + 0.5;\n          vn.xz = Rot2D (vn.xz, 0.1 * pi * sin (pi * (0.5 - mod (24. * a, 1.))));\n        }\n      }\n    } else if (idObj == 2) {\n       a = atan (qHit.x, qHit.z) / (2. * pi) + 0.5;\n       vn.xz = Rot2D (vn.xz, 0.1 * pi * sin (pi * (0.5 - mod (12. * a, 1.))));\n      col = vec3 (0.6);\n    } else if (idObj == 3) {\n      a = atan (qHit.x, qHit.z) / (2. * pi) + 0.5;\n      vn.xz = Rot2D (vn.xz, 0.1 * pi * sin (pi * (0.5 - mod (32. * a, 1.))));\n      col = vec3 (0.6, 0.3, 0.);\n    } else if (idObj == 4) {\n      col = vec3 (0.3);\n    }\n    if (inSun) col = col * (0.2 +\n       0.2 * max (dot (vn, - normalize (vec3 (sunDir.x, 0., sunDir.z))), 0.) +\n       0.6 * max (dot (vn, sunDir), 0.)) +\n       0.1 * pow (max (0., dot (sunDir, reflect (rd, vn))), 64.);\n  } else col = BgCol (ro, rd);\n  if (dstFlm < min (dstFar, dstObj)) {\n    colFlm = FlmCol (qHitFlm, rd);\n    col = mix (col, colFlm, 0.6 * length (colFlm));\n  }\n  if (inFlm) col = mix (col, vec3 (1., 0.5, 0.),\n     0.3 * pow (clamp (dot (normalize (qHit), - rd), 0., 1.), 4.));\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec3 ro, rd, vd, u;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, f;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dstFar = 50.;\n  balRad = 2.;\n  az = 2. * pi * fract (0.01 * tCur);\n  el = 0.1 * pi + 0.08 * pi * sin (2. * pi * fract (0.022 * tCur));\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  ro = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n       mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n      vec3 (0., 2., -30.);\n  vd = normalize (vec3 (0., 3. * balRad, 0.) - ro);\n  u = - vd.y * vd;\n  f = 1. / sqrt (1. - vd.y * vd.y);\n  rd = mat3 (f * vec3 (vd.z, 0., - vd.x), f * vec3 (u.x, 1. + u.y, u.z), vd) *\n     normalize (vec3 (uv, 5.5));\n  sunDir = normalize (vec3 (1., 0.2, -1.));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t1, t2;\n  vec3 ip, fp;\n  float q;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  q = dot (ip, cHashA3);\n  t1 = Hashv4f (q);\n  t2 = Hashv4f (q + cHashA3.z);\n  return mix (mix (mix (t1.x, t1.y, fp.x), mix (t1.z, t1.w, fp.x), fp.y),\n              mix (mix (t2.x, t2.y, fp.x), mix (t2.z, t2.w, fp.x), fp.y), fp.z);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mt3XzN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtcSRM", "name": "Gradient sine", "author": "Fred", "description": "Click and drag to edit sine settings", "tags": ["mouse", "gradient", "sine"], "likes": 1, "viewed": 361, "date": "1478649845", "time_retrieved": "2024-06-20T18:44:55.422763", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 m = iMouse;\n\t\n    vec2 cur = vec2(8.0 / iResolution.x, 200.0 / iResolution.y); \n    \n    vec2 pos = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y); \n\t\n    float value = (sin(pos.x * 3.1415 * 2.0 * 20.0 * cur.x + iTime * 10.0) * cur.y + 1.0) * 0.5;\n\t\n\tfloat lum = value < pos.y ? uv.x : uv.y;\n\t\n\tfragColor = vec4(lum, 0.0, 0.4, lum);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Gradient Sine\",\n\t\"description\": \"Simple sine wave\",\n\t\"model\": \"car\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtcSRM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtcSz4", "name": "Mandala", "author": "xbe", "description": "First attempt to draw mandala like shapes.", "tags": ["procedural", "2d"], "likes": 30, "viewed": 1092, "date": "1479767179", "time_retrieved": "2024-06-20T18:44:55.427769", "image_code": "// Xavier Benech\n// Mandala 2D\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define PI 3.14159265\n\n#define aspect (iResolution.x/iResolution.y)\n\nfloat circle(vec2 p, float r, float width)\n{\n    float d = 0.;\n    d += smoothstep(1., 0., width*abs(p.x - r));\n    return d;\n}\n\nfloat arc(vec2 p, float r, float a, float width)\n{\n    float d = 0.;\n    if (abs(p.y) < a) {\n\t    d += smoothstep(1., 0., width*abs(p.x - r));\n    }\n    return d;\n}\n\n\nfloat rose(vec2 p, float t, float width)\n{\n    const float a0 = 6.;\n    float d = 0.;\n    p.x *= 7. + 8. * t;\n    d += smoothstep(1., 0., width*abs(p.x - sin(a0*p.y)));\n    d += smoothstep(1., 0., width*abs(p.x - abs(sin(a0*p.y))));\n    d += smoothstep(1., 0., width*abs(abs(p.x) - sin(a0*p.y)));\n    d += smoothstep(1., 0., width*abs(abs(p.x) - abs(sin(a0*p.y))));\n    return d;\n}\n\nfloat rose2(vec2 p, float t, float width)\n{\n    const float a0 = 6.;\n    float d = 0.;\n    p.x *= 7. + 8. * t;\n    d += smoothstep(1., 0., width*abs(p.x - cos(a0*p.y)));\n    d += smoothstep(1., 0., width*abs(p.x - abs(cos(a0*p.y))));\n    d += smoothstep(1., 0., width*abs(abs(p.x) - cos(a0*p.y)));\n    d += smoothstep(1., 0., width*abs(abs(p.x) - abs(cos(a0*p.y))));\n    return d;\n}\n\nfloat spiral(vec2 p, float width)\n{\n    float d = 0.;\n    d += smoothstep(1., 0., width*abs(p.x - 0.5 * p.y / PI));\n    d += smoothstep(1., 0., width*abs(p.x - 0.5 * abs(p.y) / PI));\n    d += smoothstep(1., 0., width*abs(abs(p.x) - 0.5 * p.y / PI));\n    d += smoothstep(1., 0., width*abs(abs(p.x) - 0.5 * abs(p.y) / PI));\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = uv - 0.5;\n\tp.x *= aspect;\n\n    vec2 f = vec2 ( sqrt(p.x*p.x + p.y*p.y), atan(p.y, p.x) );\n\n    float T0 = cos(0.3*iTime);\n    float T1 = 0.5 + 0.5 * cos(0.3*iTime);\n    float T2 = sin(0.15*iTime);\n    \n    float m0 = 0.;\n    float m1 = 0.;\n    float m2 = 0.;\n    float m3 = 0.;\n    float m4 = 0.;\n    if (f.x < 0.7325) {\n        f.y += 0.1 * iTime;\n\t    vec2 c;\n\t    vec2 f2;\n        c = vec2(0.225 - 0.1*T0, PI / 4.);\n        if (f.x < 0.25) {\n            for (float i=0.; i < 2.; ++i) {\n                f2 = mod(f, c) - 0.5 * c;\n                m0 += spiral(vec2(f2.x, f2.y), 192.);\n            }\n    \t}\n        c = vec2(0.225 + 0.1*T0, PI / 4.);\n        if (f.x > 0.43) {\n            for (float i=0.; i < 2.; ++i) {\n                f.y += PI / 8.;\n            \tf2 = mod(f, c) - 0.5 * c;\n                m1 += rose((0.75-0.5*T0)*f2, 0.4*T1, 24.);\n                m1 += rose2((0.5+0.5*T1)*f2, 0.2 + 0.2*T0, 36.);\n            }\n\t    }\n        c = vec2(0.6 - 0.2*T0, PI / 4.);\n        if (f.x > 0.265) {\n            for (float i=0.; i < 2.; ++i) {\n                f.y += PI / 8.;\n                f2 = mod(f, c) - 0.5 * c;\n                m2 += spiral(vec2((0.25 + 0.5*T1)*f2.x, f2.y), 392.);\n                m2 += rose2((1.+0.25*T0)*f2, 0.5, 24.);\n            }\n        }\n        c = vec2(0.4 + 0.23*T0, PI / 4.);\n        if (f.x < 0.265) {\n            for (float i=0.; i < 2.; ++i) {\n                f.y += PI / 8.;\n                f2 = mod(f, c) - 0.5 * c;\n                m3 += spiral(vec2(f2.x, f2.y), 256.);\n                m3 += rose(f2, 1.5 * T1, 16.);\n            }\n        }\n        m4 += circle(f, 0.040, 192.);\n        m4 += circle(f, 0.265, 192.);\n        m4 += circle(f, 0.430, 192.);\n    }\n    m4 += circle(f, 0.7325, 192.);\n\n    // color\n    float z = m0 + m1 + m2 + m3 + m4;\n    z *= z;\n    z = clamp(z, 0., 1.);\n    vec3 col = vec3(z) * vec3(0.33*T2);\n    \n    // Background\n\tvec3 bkg = vec3(0.32,0.36,0.4) + p.y*0.1;\n\tcol += bkg;\n    \n\t// Vignetting\n\tvec2 r = -1.0 + 2.0*(uv);\n\tfloat vb = max(abs(r.x), abs(r.y));\n\tcol *= (0.15 + 0.85*(1.0-exp(-(1.0-vb)*30.0)));\n\n    fragColor = vec4( col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtcSz4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtcXD7", "name": "Complex Form with Spirals", "author": "xorxor", "description": "After Sol Lewitt's Complex Form with Black and White Bands.\n\nfor Codevember 2016, day 22.", "tags": ["voronoi", "spiral", "codevember"], "likes": 24, "viewed": 868, "date": "1479934744", "time_retrieved": "2024-06-20T18:44:55.895778", "image_code": "// Complex Form with Black and White Spirals\n// Created by XORXOR, 2016\n// Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0)\n//\n// Thanks to iq for voronoi\n// https://www.shadertoy.com/view/ldl3W8\n\n#define ANIMATE\n\nvec2 hash( vec2 p )\n{\n    return fract( sin( vec2( p.x * p.y, p.x + p.y ) ) * vec2( 234342.1459123, 373445.3490423 ) );\n}\n\n// iq's voronoi\n// https://www.shadertoy.com/view/ldl3W8\nvec4 voronoi( in vec2 x )\n{\n    vec2 n = floor( x );\n    vec2 f = fract( x );\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n    vec2 mg, mr, mo;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n        vec2 o = hash( n + g );\n        #ifdef ANIMATE\n        o = 0.5 + 0.3*sin( iTime + 6.2831*o );\n        #endif\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n            mo = o;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n        vec2 o = hash( n + g );\n        #ifdef ANIMATE\n        o = 0.5 + 0.3*sin( iTime + 6.2831*o );\n        #endif\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec4( md, mr, mo.x + mo.y );\n}\n\nvoid mainImage( out vec4 O, vec2 p )\n{\n    vec2 b = 6.0 * p / iResolution.x;\n    vec4 v = voronoi( b );\n    vec2 q = v.yz;\n\n    float a = iTime + atan( sign( v.w - 1.0 ) * q.y, q.x );\n    float l = length( q * 5.0 / ( sqrt( v.x ) ) ) + 0.319 * a;\n    float m = mod( l, 2.0 );\n#if 1 // sharpening by s23b\n    float w = min( fwidth( mod( l + 1.5, 2.0 ) ), fwidth( mod( l + 0.5, 2.0 ) ) ) / 2.0;\n\tfloat o = ( 1.0 - smoothstep( 1.85 - w, 1.85 + w, m ) ) * smoothstep( 1.15 - w, 1.15 + w, m );\n#else\n    float o = ( 1.0 - smoothstep( 1.7, 2.0, m ) ) * smoothstep( 1.0, 1.3, m );\n#endif\n    o = mix( 0.0, o, smoothstep( 0.04, 0.07, v.x ) );\n\n    O = vec4( vec3( o ), 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-4.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtcXD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtcXDr", "name": "Pretty Colors", "author": "anprogrammer", "description": "Pretty colors, inspired by IQ's fbm warp article", "tags": ["colorsfbm"], "likes": 39, "viewed": 2152, "date": "1479139108", "time_retrieved": "2024-06-20T18:44:55.895778", "image_code": "#define N_DELTA 0.015625\nfloat rand(vec3 n) { \n    return fract(sin(dot(n, vec3(95.43583, 93.323197, 94.993431))) * 65536.32);\n}\n\nfloat perlin2(vec3 n)\n{\n    vec3 base = floor(n / N_DELTA) * N_DELTA;\n    vec3 dd = vec3(N_DELTA, 0.0, 0.0);\n    float\n        tl = rand(base + dd.yyy),\n        tr = rand(base + dd.xyy),\n        bl = rand(base + dd.yxy),\n        br = rand(base + dd.xxy);\n    vec3 p = (n - base) / dd.xxx;\n    float t = mix(tl, tr, p.x);\n    float b = mix(bl, br, p.x);\n    return mix(t, b, p.y);\n}\n\nfloat perlin3(vec3 n)\n{\n    vec3 base = vec3(n.x, n.y, floor(n.z / N_DELTA) * N_DELTA);\n    vec3 dd = vec3(N_DELTA, 0.0, 0.0);\n    vec3 p = (n - base) / dd.xxx;\n    float front = perlin2(base + dd.yyy);\n    float back = perlin2(base + dd.yyx);\n    return mix(front, back, p.z);\n}\n\nfloat fbm(vec3 n)\n{\n    float total = 0.0;\n    float m1 = 1.0;\n    float m2 = 0.1;\n    for (int i = 0; i < 5; i++)\n    {\n        total += perlin3(n * m1) * m2;\n        m2 *= 2.0;\n        m1 *= 0.5;\n    }\n    return total;\n}\n\nfloat nebula1(vec3 uv)\n{\n    float n1 = fbm(uv * 2.9 - 1000.0);\n    float n2 = fbm(uv + n1 * 0.05);   \n    return n2;\n}\n\nfloat nebula2(vec3 uv)\n{\n    float n1 = fbm(uv * 1.3 + 115.0);\n    float n2 = fbm(uv + n1 * 0.35);   \n    return fbm(uv + n2 * 0.17);\n}\n\nfloat nebula3(vec3 uv)\n{\n    float n1 = fbm(uv * 3.0);\n    float n2 = fbm(uv + n1 * 0.15);   \n    return n2;\n}\n\nvec3 nebula(vec3 uv)\n{\n    uv *= 10.0;\n\treturn nebula1(uv * 0.5) * vec3(1.0, 0.0, 0.0) +\n        \tnebula2(uv * 0.4) * vec3(0.0, 1.0, 0.0) +\n        \tnebula3(uv * 0.6) * vec3(0.0, 0.0, 1.0);\n        \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float size = max(iResolution.x, iResolution.y);\n\tvec2 xy = (fragCoord.xy - iResolution.xy * 0.5)  / size * 2.0;\n    vec3 rayDir = normalize(vec3(xy, 1.0));\n    vec2 uv = xy * 0.5 + 0.5;\n    \n    fragColor = vec4(vec3((nebula(vec3(uv * 5.1, iTime * 0.1) * 0.1) - 1.0)), 1.0);\n\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtcXDr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtcXWr", "name": "Ray tracing a cone", "author": "Zavie", "description": "Highschool maths galore.\n(FIXME: do the bottom part)", "tags": ["raytracing", "cone", "analytic", "conics"], "likes": 33, "viewed": 21198, "date": "1479122137", "time_retrieved": "2024-06-20T18:44:57.241428", "image_code": "/*\n\nThis shader demonstrates solving the intersection of\na ray and a cone for ray tracing.\n\nThe math is detailed on this page:\nhttp://lousodrome.net/blog/light/2017/01/03/intersection-of-a-ray-and-a-cone/\n\n--\nZavie\n\n*/\n\n#define MAX_BOUNCES 2\nfloat gamma = 2.2;\n\n// ---8<----------------------------------------------------------------------\n// Material\n\nstruct Material\n{\n    vec3 c;\t\t// diffuse color\n    float f0;\t// specular color (monochrome)\n};\n\n// ---8<----------------------------------------------------------------------\n// Geometry\n\n#define PI acos(-1.)\nfloat hash(float x) { return fract(sin(x) * 43758.5453); }\n\nstruct Ray\n{\n    vec3 o;\t\t// origin\n    vec3 d;\t\t// direction\n};\n\nstruct Hit\n{\n    float t;\t// solution to p=o+t*d\n    vec3 n;\t\t// normal\n    Material m;\t// material\n};\nconst Hit noHit = Hit(1e10, vec3(0.), Material(vec3(-1.), -1.));\n\nstruct Plane\n{\n    float d;\t// solution to dot(n,p)+d=0\n    vec3 n;\t\t// normal\n    Material m;\t// material\n};\n\nstruct Sphere\n{\n\tfloat r;\t// radius\n    vec3 p;\t\t// center position\n    Material m;\t// material\n};\n\nstruct Cone\n{\n    float cosa;\t// half cone angle\n    float h;\t// height\n    vec3 c;\t\t// tip position\n    vec3 v;\t\t// axis\n    Material m;\t// material\n};\n\nHit intersectPlane(Plane p, Ray r)\n{\n    float dotnd = dot(p.n, r.d);\n    if (dotnd > 0.) return noHit;\n\n    float t = -(dot(r.o, p.n) + p.d) / dotnd;\n    return Hit(t, p.n, p.m);\n}\n\nHit intersectSphere(Sphere s, Ray r)\n{\n\tvec3 op = s.p - r.o;\n    float b = dot(op, r.d);\n    float det = b * b - dot(op, op) + s.r * s.r;\n    if (det < 0.) return noHit;\n\n    det = sqrt(det);\n    float t = b - det;\n    if (t < 0.) t = b + det;\n    if (t < 0.) return noHit;\n\n    return Hit(t, (r.o + t*r.d - s.p) / s.r, s.m);\n}\n\nHit intersectCone(Cone s, Ray r)\n{\n    vec3 co = r.o - s.c;\n\n    float a = dot(r.d,s.v)*dot(r.d,s.v) - s.cosa*s.cosa;\n    float b = 2. * (dot(r.d,s.v)*dot(co,s.v) - dot(r.d,co)*s.cosa*s.cosa);\n    float c = dot(co,s.v)*dot(co,s.v) - dot(co,co)*s.cosa*s.cosa;\n\n    float det = b*b - 4.*a*c;\n    if (det < 0.) return noHit;\n\n    det = sqrt(det);\n    float t1 = (-b - det) / (2. * a);\n    float t2 = (-b + det) / (2. * a);\n\n    // This is a bit messy; there ought to be a more elegant solution.\n    float t = t1;\n    if (t < 0. || t2 > 0. && t2 < t) t = t2;\n    if (t < 0.) return noHit;\n\n    vec3 cp = r.o + t*r.d - s.c;\n    float h = dot(cp, s.v);\n    if (h < 0. || h > s.h) return noHit;\n\n    vec3 n = normalize(cp * dot(s.v, cp) / dot(cp, cp) - s.v);\n\n    return Hit(t, n, s.m);\n}\n\nvec3 randomVector(float seed)\n{\n    float r2 = hash(seed);\n    float phi = 2. * PI * hash(seed + r2);\n    float sina = sqrt(r2);\n    float cosa = sqrt(1. - r2);\n\n\treturn vec3(cos(phi) * sina, cosa, sin(phi) * sina);\n}\n\nbool compare(inout Hit a, Hit b)\n{\n    if (b.m.f0 >= 0. && b.t < a.t)\n    {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nHit intersectScene(Ray r)\n{\n    vec3 axis1 = randomVector(floor(iTime));\n    vec3 axis2 = randomVector(floor(iTime+1.));\n    vec3 axis = normalize(mix(axis1, axis2, fract(iTime)));\n    float translation = 4.*abs(2.*fract(iTime/8.)-1.) - 2.;\n\n    Sphere s = Sphere(1., vec3(1., 1., 0.), Material(vec3(0.5), 0.04));\n    Plane p  = Plane(0., vec3(0., 1., 0.), Material(vec3(0.5, 0.4, 0.3), 0.04));\n    Cone c = Cone(0.95, 2., vec3(translation, 2., 1.), -axis, Material(vec3(1., 0., 0.), 0.02));\n\n    Hit hit = noHit;\n    compare(hit, intersectPlane(p, r));\n    compare(hit, intersectSphere(s, r));\n    compare(hit, intersectCone(c, r));\n    return hit;\n}\n\n// ---8<----------------------------------------------------------------------\n// Light\n\nstruct DirectionalLight\n{\n    vec3 d;\t\t// Direction\n    vec3 c;\t\t// Color\n};\n\nDirectionalLight sunLight = DirectionalLight(normalize(vec3(1., .5, .5)), vec3(1e3));\nvec3 skyColor(vec3 d)\n{\n    float transition = pow(smoothstep(0.02, .5, d.y), 0.4);\n\n    vec3 sky = 2e2*mix(vec3(0.52, 0.77, 1), vec3(0.12, 0.43, 1), transition);\n    vec3 sun = sunLight.c * pow(abs(dot(d, sunLight.d)), 5000.);\n    return sky + sun;\n}\n\nfloat pow5(float x) { return x * x * x * x * x; }\n\n// Schlick approximation\nfloat fresnel(vec3 h, vec3 v, float f0)\n{\n    return pow5(1. - clamp(dot(h, v), 0., 1.)) * (1. - f0) + f0;\n}\n\nfloat epsilon = 4e-4;\n\nvec3 accountForDirectionalLight(vec3 p, vec3 n, DirectionalLight l)\n{\n    if (intersectScene(Ray(p + epsilon * l.d, l.d)).m.f0 < 0.)\n    {\n        return clamp(dot(n, l.d), 0., 1.) * l.c;\n    }\n\treturn vec3(0.);\n}\n\nvec3 radiance(Ray r)\n{\n    vec3 accum = vec3(0.);\n    vec3 attenuation = vec3(1.);\n\n    for (int i = 0; i <= MAX_BOUNCES; ++i)\n    {\n        Hit hit = intersectScene(r);\n\n        if (hit.m.f0 >= 0.)\n        {\n            float f = fresnel(hit.n, -r.d, hit.m.f0);\n\n            vec3 hitPos = r.o + hit.t * r.d;\n\n            // Diffuse\n            vec3 incoming = vec3(0.);\n            incoming += accountForDirectionalLight(hitPos, hit.n, sunLight);\n\n            accum += (1. - f) * attenuation * hit.m.c * incoming;\n\n            // Specular: next bounce\n            attenuation *= f;\n            vec3 d = reflect(r.d, hit.n);\n            r = Ray(r.o + hit.t * r.d + epsilon * d, d);\n        }\n        else\n        {\n            accum += attenuation * skyColor(r.d);\n            break;\n        }\n    }\n    return accum;\n}\n\n// ---8<----------------------------------------------------------------------\n// Tone mapping\n\n// See: http://filmicgames.com/archives/75\nvec3 Uncharted2ToneMapping(vec3 color)\n{\n\tfloat A = 0.15;\n\tfloat B = 0.50;\n\tfloat C = 0.10;\n\tfloat D = 0.20;\n\tfloat E = 0.02;\n\tfloat F = 0.30;\n\tfloat W = 11.2;\n\tfloat exposure = 0.012;\n\tcolor *= exposure;\n\tcolor = ((color * (A * color + C * B) + D * E) / (color * (A * color + B) + D * F)) - E / F;\n\tfloat white = ((W * (A * W + C * B) + D * E) / (W * (A * W + B) + D * F)) - E / F;\n\tcolor /= white;\n\tcolor = pow(color, vec3(1. / gamma));\n\treturn color;\n}\n\n// ---8<----------------------------------------------------------------------\n// Scene\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n\n    float o1 = 0.25;\n    float o2 = 0.75;\n    vec2 msaa[4];\n    msaa[0] = vec2( o1,  o2);\n    msaa[1] = vec2( o2, -o1);\n    msaa[2] = vec2(-o1, -o2);\n    msaa[3] = vec2(-o2,  o1);\n\n    vec3 color = vec3(0.);\n    for (int i = 0; i < 4; ++i)\n    {\n        vec3 p0 = vec3(0., 1.1, 4.);\n        vec3 p = p0;\n        vec3 offset = vec3(msaa[i] / iResolution.y, 0.);\n        vec3 d = normalize(vec3(iResolution.x/iResolution.y * uv.x, uv.y, -1.5) + offset);\n        Ray r = Ray(p, d);\n        color += radiance(r) / 4.;\n    }\n\n\tfragColor = vec4(Uncharted2ToneMapping(color),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtcXWr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtdSRM", "name": "Zebra Drops", "author": "s23b", "description": "Inspired by [url=https://www.shadertoy.com/user/xorxor]xorxor[/url]'s work I recreated a [url=http://dvdp.tumblr.com/post/130583230673/150505]davidope[/url] gif in a shader.", "tags": ["raymarch", "metaballs", "drop", "split", "dvdp"], "likes": 14, "viewed": 705, "date": "1478864810", "time_retrieved": "2024-06-20T18:44:57.241428", "image_code": "#define AA 2.\n#define FAKE_AA 1\n#define MAX_STEPS 50\n\n#define NEAR .001\n#define FAR 10.\n\n#define FALL_SPEED 2.5\n#define BALL_SIZE .6\n#define FALL_FREQ 9.\n#define TEXTURE_SPEED 2.\n#define SMOOTH 1.\n\n#define PI 3.14159265359\n#define SQ2 1.41421356237\n\n#define saturate(x) clamp(x, 0., 1.)\n\nvoid tRotate(inout vec2 p, float angle) {\n    float s = sin(angle), c = cos(angle);\n\tp *= mat2(c, -s, s, c);\n}\n\nfloat tRepeat1(inout float p, float r) {\n    float id = floor((p + r * .5) / r);\n    p = mod(p + r * .5, r) - r * .5;\n    return id;\n}\n\nvec3 tFallRepeat(vec3 p, float angle) {\n    tRotate(p.xy, angle);\n    p.y += iTime * FALL_SPEED;\n    tRepeat1(p.y, FALL_FREQ);\n    return p;\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat opSmoothUnion(float a, float b) {\n    float h = saturate(.5 + .5 * (b - a) / SMOOTH);\n    return mix(b, a, h) - SMOOTH * h * (1. - h);\n}\n\nfloat opSmoothIntersect(float a, float b) {\n    return -opSmoothUnion(-a, -b);\n}\n\nfloat map(vec3 p) {\n    float falling = opSmoothIntersect(sdSphere(tFallRepeat(p, 0.), BALL_SIZE), -p.y);\n    tRotate(p.yz, PI / 3.);\n    float split1 = opSmoothIntersect(sdSphere(tFallRepeat(p, -PI / 4.), BALL_SIZE), (p.y - p.x) * SQ2);\n    float split2 = opSmoothIntersect(sdSphere(tFallRepeat(p, PI / 4.), BALL_SIZE), (p.y + p.x) * SQ2);\n    float split = opSmoothUnion(split1, split2);\n    return opSmoothUnion(split, opSmoothUnion(sdSphere(p, 1.), falling));\n}\n\nfloat trace(vec3 o, vec3 r, out float steps) {\n\n    float t = 0.;\n    steps = 0.;\n    for (int i = 0; i < MAX_STEPS; ++i) {\n        float d = map(o + r * t);\n        t += d * 1.;\n        ++steps;\n        if (d < NEAR || t > FAR) break;\n    }\n    \n    return t;\n}\n\nvec3 render(vec2 fragCoord) {\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 r = normalize(vec3(uv, 3.));\n    vec3 o = vec3(0, 0, -6.5);\n    \n    vec2 mouse = iMouse.z > 0. ? iMouse.xy / iResolution.xy * 2. : vec2(1., -.3);\n    mouse *= PI;\n    tRotate(r.yz, -mouse.y);\n    tRotate(r.xz, -mouse.x);\n    tRotate(o.yz, -mouse.y);\n    tRotate(o.xz, -mouse.x);\n    \n    float steps = 0.;\n    float f = trace(o, r, steps);\n    steps /= float(MAX_STEPS);\n    steps *= steps;\n    \n    vec3 p = o + f * r;\n    \n    float scroll = p.y * 5. - TEXTURE_SPEED * iTime;\n    \n    #if FAKE_AA\n    vec3 c = vec3(saturate(sin(scroll * PI * 2.) * 8. + .5));\n    #else\n    vec3 c = vec3(fract(scroll) < .5);\n    #endif\n    \n    c -= steps;\n\treturn f < FAR ? c : vec3(0);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    \n    fragColor = vec4(0);\n    \n    for (float x = 0.; x < AA; ++x) {\n    \tfor (float y = 0.; y < AA; ++y) {\n            fragColor.rgb += render(fragCoord + vec2(x, y) / AA);\n        }\n    }\n        \n\tfragColor /= AA * AA;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtdSRM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtdSWr", "name": "Cubic Tunnel", "author": "xorxor", "description": "Tried to recreate mr. div's cubic_tunnel animgif for Codevember 2016\n[url]http://mrdiv.tumblr.com/post/90669206322/cubictunnel[/url]\n\nDidn't have enough experience and time to properly mimic the materials, though.\n", "tags": ["raymarching", "tunnel", "codevember", "mrdiv"], "likes": 31, "viewed": 1096, "date": "1479139821", "time_retrieved": "2024-06-20T18:44:58.611101", "image_code": "// Created by XORXOR, 2016\n// Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0)\n// https://www.shadertoy.com/view/4ldXR4\n//\n// Tried to recreate mr. div's cubic_tunnel animgif\n// http://mrdiv.tumblr.com/post/90669206322/cubictunnel\n//\n// Related:\n// Plasma cube by patu (cube edges)\n// https://www.shadertoy.com/view/4d3SRN\n//\n// Cave Entrance by Shane (bump mapping)\n// https://www.shadertoy.com/view/ltjXzd\n\n//#define ANTIALIAS\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs( p ) - b;\n    return min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\nfloat map( vec3 p )\n{\n    p.z = mod( p.z, 8.0 );\n\n    float d = sdBox( p - vec3( 0.0, 1.0, 1.0 ), vec3( 1.5, 0.5, 0.5 ) );\n    d = min( d, sdBox( p - vec3( 1.0, 0.0, 1.0 ), vec3( 0.5 ) ) );\n    d = min( d, sdBox( p - vec3( -1.0, 1.0, 3.0 ), vec3( 0.5, 0.5, 1.5 ) ) );\n    d = min( d, sdBox( p - vec3( -1.0, 0.0, 5.0 ), vec3( 0.5, 1.5, 0.5 ) ) );\n    d = min( d, sdBox( p - vec3( 0.0, -1.0, 5.0 ), vec3( 0.5 ) ) );\n    d = min( d, sdBox( p - vec3( 1.0, -1.0, 6.5 ), vec3( 0.5, 0.5, 2.0 ) ) );\n    d = min( d, sdBox( p - vec3( 1.0, -1.0, 0.5 ), vec3( 0.5, 0.5, 1.0 ) ) );\n    return d;\n}\n\nfloat trace( vec3 ro, vec3 rd, float kTMax )\n{\n    const float kTMin = 0.01;\n    const float kEps = 0.001;\n\n    float t = kTMin;\n    float res;\n    for ( int i = 0; i < 64; i++ )\n    {\n        vec3 pos = ro + rd * t;\n        res = map( pos );\n        if ( ( res < kEps ) || ( t > kTMax ) )\n        {\n            break;\n        }\n        t += res;\n    }\n\n    if ( t < kTMax )\n    {\n        return t;\n    }\n    else\n    {\n        return -1.0;\n    }\n}\n\nfloat traceRefl( vec3 ro, vec3 rd, float kTMax )\n{\n    const float kTMin = 0.01;\n    const float kEps = 0.001;\n\n    float t = kTMin;\n    float res;\n    for ( int i = 0; i < 100; i++ )\n    {\n        vec3 pos = ro + rd * t;\n        res = map( pos );\n        if ( ( res < kEps ) || ( t > kTMax ) )\n        {\n            break;\n        }\n        t += res * clamp( 0.1 * float( i + 1 ) * 0.1, 0.0, 1.0 );\n    }\n\n    if ( t < kTMax )\n    {\n        return t;\n    }\n    else\n    {\n        return -1.0;\n    }\n}\n\nmat3 calcCamera( vec3 eye, vec3 target )\n{\n    vec3 cw = normalize( target - eye );\n    vec3 cu = cross( cw, vec3( 0, 1, 0 ) );\n    vec3 cv = cross( cu, cw );\n    return mat3( cu, cv, cw );\n}\n\nfloat edge2d( vec2 coord )\n{\n    const float edge = 0.95;\n    vec2 ec = smoothstep( edge, 1.0, coord );\n    ec += 1.0 - smoothstep( -1.0, -edge, coord );\n    return dot( ec, vec2( 1.0 ) );\n}\n\nfloat edge( vec3 coord )\n{\n    vec3 c = 1.0 - 2.0 * fract( ( coord + 0.5 ) );\n    float x = edge2d( c.xy );\n    float y = edge2d( c.yz );\n    float z = edge2d( c.xz );\n    return 1.0 - x * y * z;\n}\n\nvec3 calcNormal( vec3 p )\n{\n    const vec2 e = vec2( 0.005, 0 );\n    float dp = map( p );\n    return normalize( vec3( dp - map( p - e.xyy ),\n                            dp - map( p - e.yxy ),\n                            dp - map( p - e.yyx ) ) );\n}\n\nfloat calcShadow( vec3 ro, vec3 rd, float mint, float maxt )\n{\n    float t = mint;\n    float res = 1.0;\n    for ( int i = 0; i < 10; i++ )\n    {\n        float h = map( ro + rd * t );\n        res = min( res, 1.5 * h / t );\n        t += h;\n        if ( ( h < 0.001 ) || ( t > maxt ) )\n        {\n            break;\n        }\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcAo( vec3 pos, vec3 n )\n{\n    float sca = 2.0;\n    float occ = 0.0;\n    for( int i = 0; i < 5; i++ )\n    {\n\n        float hr = 0.01 + float( i ) * 0.5 / 4.0;\n        float dd = map( n * hr + pos );\n        occ += ( hr - dd ) * sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );\n}\n\n// Bump mapping from Shane:\n// https://www.shadertoy.com/view/ltjXzd\n\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n )\n{\n    n = max( ( abs( n ) - 0.2 ) * 7.0 , 0.001 );\n    n /= ( n.x + n.y + n.z );\n\n    return 1.0 - ( texture( tex, p.yz ) * n.x +\n                   texture( tex, p.zx ) * n.y +\n                   texture( tex, p.xy ) * n.z ).xyz;\n}\n\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 nor, float bumpfactor)\n{\n    const float eps = 0.01;\n    vec3 grad = vec3( tex3D( tex, vec3( p.x - eps, p.y, p.z ), nor ).x,\n                      tex3D( tex, vec3( p.x, p.y - eps, p.z ), nor ).x,\n                      tex3D( tex, vec3( p.x, p.y, p.z - eps ), nor ).x );\n\n    grad = ( grad - tex3D( tex,  p , nor ).x ) / eps;\n\n    grad -= nor * dot( nor, grad );\n\n    return normalize( nor + grad * bumpfactor );\n}\n\nvec3 color( vec3 pos, vec3 nor, vec3 ro, vec3 rd )\n{\n    vec3 col = vec3( 0.36, 0.15, 0.06 );\n\n    if ( dot( rd, rd ) > 0.001 )\n    {\n        nor = doBumpMap( iChannel0, pos, nor, 0.003 );\n\n        vec3 ref = reflect( rd, nor );\n        vec3 ldir = normalize( vec3( -2.0, 2.5, 4.0 ) );\n        float dif = max( dot( nor, ldir ), 0.0 );\n        float spe = pow( clamp( dot( ref, ldir ), 0.0, 1.0 ), 6.0 );\n\n        col += 0.2 * dif;\n        col += spe;\n    }\n\n    float ao = calcAo( pos, nor );\n    col *= ( 0.3 +  ao );\n\n    col *= edge( pos );\n    float d = abs( pos.z - ro.z );\n    col = mix( 1.0 - col, col, clamp( d / 10.0, 0.0, 1.0 ) );\n\n    col += pow( 0.3 * max( abs( pos.x ), abs( pos.y ) ), 2.0 );;\n    return col;\n}\n\nvec3 render( vec3 ro, vec3 rd )\n{\n    float t = trace( ro, rd, 40.0 );\n    vec3 col = vec3( 1.0 );\n    if ( t > 0.0 )\n    {\n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal( pos );\n\n        vec3 ref = reflect( rd, nor );\n        col = color( pos, nor, ro, rd );\n\n        float tRef = traceRefl( pos, ref, 10.0 );\n\n        if ( tRef > 0.0 )\n        {\n            vec3 refPos = pos + tRef * ref;\n            vec3 refNor = calcNormal( refPos );\n\n            col += 0.1 * color( refPos, refNor, vec3( 0.0 ), vec3( 0.0 ) );\n        }\n        col = mix( col, vec3( 1.0 ), smoothstep( 0.0, 30.0, t ) );\n    }\n    return col;\n}\n\nmat2 rot2( float a )\n{\n    float c = cos( a );\n    float s = sin( a );\n    return mat2( c, -s, s, c );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = vec2( 0.0 );\n    if ( iMouse.z > 0.5 )\n    {\n        mo = 2.0 * iMouse.xy / iResolution.xy - 1.0;\n        mo *= 3.14159 * 0.1;\n    }\n\n    float time = iTime * 6.0;\n    vec3 eye = vec3( 0.0, 0.0, 0.0 - time );\n    vec3 target = vec3( 0.0, 0.0, -20.0 );\n    target.xz *= rot2( mo.x );\n    target.yz *= rot2( mo.y );\n    target.z -= time;\n    mat3 cam = calcCamera( eye, target );\n\n    vec3 col = vec3( 0.0 ) ;\n#ifdef ANTIALIAS\n    for ( int i = 0; i < 4; i++ )\n    {\n        vec2 off = vec2( mod( float( i ), 2.0 ), mod( float( i / 2 ), 2.0 ) ) / 2.0;\n#else\n        vec2 off = vec2( 0.0 );\n#endif\n        vec2 uv = ( fragCoord.xy + off - 0.5 * iResolution.xy ) / iResolution.y;\n        vec3 rd = cam * normalize( vec3( uv, 2.0 ) );\n\n        col += render( eye, rd );\n#ifdef ANTIALIAS\n    }\n    col *= 1.0 / 4.0;\n#endif\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-4.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtdSWr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtdSzB", "name": "EndlessGradientsMk1", "author": "lukexi", "description": "Cosine gradient + line-art testing", "tags": ["2d"], "likes": 2, "viewed": 449, "date": "1480404186", "time_retrieved": "2024-06-20T18:44:58.611101", "image_code": "\n\n\nfloat smoothedge(float v) {\n    return smoothstep(0.0, 1.0 / iResolution.x, v);\n}\n\nfloat ring(vec2 p, float radius, float width) {\n  return abs(length(p) - radius * 0.5) - width;\n}\n\n\nfloat plot(vec2 st, float pct){\n  return  smoothstep( pct-0.02, pct, st.y) - \n          smoothstep( pct, pct+0.02, st.y);\n}\n\nvec3 replace(vec3 color, float mask, vec3 maskColor) {\n    return (1.0-mask)*color+mask*maskColor;\n}\n\nfloat cos01(float phase) {\n    return cos(phase) * 0.5 + 0.5;\n}\nfloat rescale01(float low, float high, float value) {\n    return low + value*(high - low);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.x*=iResolution.x/iResolution.y;\n    st.x-=0.4;\n    \n    float speed = 4.;\n\tfloat phase = st.x * 6.28*2. + iTime*speed;\n    \n    // Phase-shifted cosine gradients\n    float r = rescale01(0., 1., cos01(phase*0.9 + 0.5));\n    float g = rescale01(0., 1., cos01(phase*0.8 + 0.2));\n    float b = rescale01(0., 1., cos01(phase*0.7 + 4.0));\n    vec3 gradient = vec3(r,g,b);\n    \n    // Background color\n    vec3 outcol = vec3(0.050,0.038,0.055);\n    // Plot rgb values\n    outcol = replace(outcol, plot(st, r), vec3(1.0,0.0,0.0));\n    outcol = replace(outcol, plot(st, g), vec3(0.0,1.0,0.0));\n    outcol = replace(outcol, plot(st, b), vec3(0.0,0.0,1.0));\n\t\n    // Mask with distance field ring\n    float d = 1.0;\n    d = min(d, ring(st - vec2(0.5,0.5), 0.500, 0.036));\n    float shapemask = 1.-smoothedge(d);\n    \n    outcol = replace(outcol, shapemask, gradient);\n    \n    fragColor = vec4(outcol,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtdSzB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtdSzN", "name": "HelloWorldShaderSpiral", "author": "gadgetgnome", "description": "My hello world spiral âÂ my first shader created. \n\n// Day #1 shader programming.", "tags": ["2d"], "likes": 6, "viewed": 136, "date": "1478554503", "time_retrieved": "2024-06-20T18:44:58.617080", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ar = iResolution.x / iResolution.y;\n    vec4 temp = vec4(0.0,0.0,0.0,1.0);\n    vec2 center = vec2(0.5,0.5);\n    vec2 fromCenter = uv - center;\n    float angle = atan( fromCenter.y, fromCenter.x);\n    fromCenter.x *= ar;\n    float fromCenterLength = length(fromCenter);\n    \n    temp.r = 0.5 + sin(angle*1.0 + fromCenterLength * 6.28 * 15.0 - iTime * 15.0)* 0.5;\n\ttemp.r -= fromCenterLength * 2.0;\n    fragColor = temp;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtdSzN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtdXRS", "name": "Daily Shade day 25: Alien Wave", "author": "psonice", "description": "Initial plans didn't work out, ended up making this instead. Apologies if the wave motion causes nausea ;)", "tags": ["raymarch", "wave", "ao"], "likes": 22, "viewed": 933, "date": "1480373684", "time_retrieved": "2024-06-20T18:45:01.605437", "image_code": "/* \nDay 25\n*/\n\n//#define DEBUG\n#ifdef DEBUG\nint debugStep = 0;\nfloat debugValue = 0.0;\n#endif\n\n// Rotation\n#define R(p,a) p=cos(a)*p+sin(a)*vec2(-p.y,p.x);\n\n\n#define kINFINITY 10000.0 // An unimaginably large number\n#define kSQRT2 1.414213\n#define kISQRT2 0.707107\n#define kPI 3.141592\n\n// maximum iteration count\n#define kMAXITERS 150\n#define kEPSILON 0.001\n#define kMAXINTERSECTIONS 1\n\n// refractive index\n#define kREFRACT 1.0/1.5\n\n// materials\n#define kFLOORMATERIAL 0\n#define kGLASSMATERIAL 1\n#define kMIRRORMATERIAL 2\n#define kGLOWMATERIAL 3\n#define kMATTEMATERIAL 4\n\n#define kFLOORCOLOUR vec3(0.7, 0.65, 0.6)\n#define kGLASSCOLOUR vec3(0.9)\n#define kMIRRORCOLOUR vec3(0.9)\n#define kMIRRORCOLOUR2 vec3(0.5)\n#define kGLOWCOLOUR vec3(0.5)\n\n#define kZENITHCOLOUR vec3(0.3, 0.7, 1.0)\n#define kNADIRCOLOUR vec3(0.7, 0.6, 0.4)\n#define kHORIZONCOLOUR vec3(0.95)\n#define kSUNCOLOUR vec3(100, 90, 70)\n\n// A ray. Has origin + direction.\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n    \n// Distance to nearest surface\nstruct SDResult {\n    float d; // Distance\n    int material; // Nearest material\n};\n\n// A camera. Has a position and a direction. \nstruct Camera {\n    vec3 pos;\n    Ray ray;\n};\n    \n// A disk. Has position, size, colour.\nstruct Disk {\n    vec3 pos;\n    float radius;\n    vec3 col;\n};\n    \nstruct Sphere {\n    vec3 pos;\n    float radius;\n};\n    \nstruct Box {\n\tvec3 pos;\n\tvec3 size;\n    float radius;\n};\n    \nfloat eps = kEPSILON;\nfloat divergence;\n\nvec3 smoothBlend(in vec3 point, in vec3 about, in float radius) {\n    point -= about;\n    point = mix(-point, point, smoothstep(-radius, radius, point));\n    return point + about;\n}\n    \n// Distance to sphere (signed)\nfloat sphereDist(in Ray ray, in Sphere sphere) {\n    return length(ray.origin - sphere.pos) - sphere.radius;\n}\n\n// Distance to sphere surface\nfloat uSphereDist(in Ray ray, in Sphere sphere) {\n    return abs(length(ray.origin - sphere.pos) - sphere.radius);\n}\n\n// Distance to box surface (signed)\nfloat boxDist(in Ray ray, in Box box) {\n    vec3 dist = abs(ray.origin - box.pos) - (box.size * 0.5);\n    vec3 cDist = max(dist, 0.0);\n    return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(cDist) - box.radius;\n}\n\n// Distance to box surface\nfloat uBoxDist(in Ray ray, in Box box) {\n    return abs(length(max(abs(ray.origin - box.pos) - (box.size * 0.5), 0.0)) - box.radius);\n}\n\n// distance to floor\nfloat floorDist(in Ray ray) {\n    float dist = ray.origin.y;\n    return dist;\n}\n\n// traced coords of floor intersection, floor at height y\nvec2 floorPos(in Ray ray, in float y) {\n    float dist = (ray.origin.y - y) / ray.dir.y;\n \treturn ray.origin.xz + ray.dir.xz * dist; \n}\n\n/*\n---- Random/hash stuff ----\n*/\n\n// Normalised random number, borrowed from Hornet's noise distributions: https://www.shadertoy.com/view/4ssXRX\nfloat nrand(in vec2 n) {\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\n// random value based on texture channel 2\nvec3 texrand(in vec2 n, in float mipLevel) {\n    return texture(iChannel2, n, mipLevel).xyz;\n}\n\n// returns a hash value for a fixed size cell\nfloat hashForCell(in vec3 pos, in float cellSize) {\n    float hash = nrand(floor(pos.xz / cellSize) + 68.0);\n    return hash;\n}\n\n// returns a random colour based on the cell hash\nvec3 randomColourForCell(in vec3 pos, in float cellSize) {\n\tfloat hash = hashForCell(pos, cellSize); \n    return vec3(\n        nrand(vec2(hash * 2.0, hash * 4.0)),\n        nrand(vec2(hash * 4.0, hash * 8.0)),\n        nrand(vec2(hash * 8.0, hash * 16.0))\n\t);\n\tvec3 c = vec3(hash, mod(hash + 0.15, 1.0), mod(hash + 0.3, 1.0)) * 0.75;\n}\n\n/*\n---- INTERSECTION OPS ----\n*/\n\n// Union of two signed distances\nfloat unionOp(float d0, float d1) {\n    return min(d0, d1);\n}\n\n// Intersection of two signed distances\nfloat intersectOp(float d0, float d1) {\n    return max(d0, d1);\n}\n\n// Difference of two signed distances\nfloat differenceOp(float d0, float d1) {\n    return max(d0, -d1);\n}\n\t\n// from http://www.iquilezles.org/www/articles/smin/smin.htm\n// polynomial smooth min (k = 0.1); \nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n/*\n---- Scene rendering ----\n*/\n\n// Get the distance to the scene (returns a struct containing distance and nearest material)\nSDResult sceneDist(in Ray ray) {\n    SDResult result;\n    float t = iTime + 10.0;\n    R(ray.origin.yz, cos(ray.origin.z - t) / t);\n    //ray.origin.y += sin(ray.origin.x * 0.5 + t);\n    float floorDist = ray.origin.y-0.3;\n    \n    vec3 p = ray.origin;\n    p.y *= 0.75;\n    \n\tp += vec3(\n\t\tsin(p.z * 1.55) + sin(p.z * 1.34),\n\t\t0.,\n\t\tsin(p.x * 1.34) + sin(p.x * 1.55)\n\t) * .5;\n\n\tvec3 mp = p;\n    mp.xz = mod(p.xz, 1.);\n    \n        \n\tray.origin = vec3(mp.x, mp.y + (sin(p.z * kPI) * sin(p.x * kPI)) * 0.25, 0.5);\n\tfloat s1 = boxDist(\n        ray, \n        Box(\n            vec3(0.5), \n            vec3(0.2), \n            0.02\n        ));\n    \n    ray.origin = vec3(0.5, mp.y + (sin(p.x * kPI) * -sin(p.z * kPI)) * 0.25, mp.z);\n\tfloat s2 = boxDist(\n        ray, \n        Box(\n            vec3(0.5),\n            vec3(0.0),\n            0.15\n            ));\n\t\n    result.d = unionOp(s1, s2);\n    \n    //result.d = unionOp(result.d, floorDist);\n    result.d = smin(result.d, floorDist, 0.5);\n    result.material = kMATTEMATERIAL;\n    \n    return result;\n}\n\n// Gets the normal\nvec3 normal(in Ray ray) {\n    vec2 eps = vec2(0.0001, 0);\n    float baseDist = sceneDist(ray).d;\n \treturn normalize(vec3(\n        sceneDist(Ray(ray.origin + eps.xyy, ray.dir)).d - \n        sceneDist(Ray(ray.origin - eps.xyy, ray.dir)).d,\n        sceneDist(Ray(ray.origin + eps.yxy, ray.dir)).d -\n        sceneDist(Ray(ray.origin - eps.yxy, ray.dir)).d,\n        sceneDist(Ray(ray.origin + eps.yyx, ray.dir)).d -\n        sceneDist(Ray(ray.origin - eps.yyx, ray.dir)).d\n        ));\n}\n\n// Moves the ray to the surface. Helps avoid artefacts due to ray intersection imprecision.\nvoid clampToSurface(in Ray ray, in float d, inout vec3 n) {\n    for (int i=0; i<5; i++) {\n \t\tray.origin += n * d*0.5;\n \t\td = sceneDist(ray).d;\n \t\tn = normal(ray);\n    }\n}\n\n// Calulcate a fresnel term for reflections\nfloat fresnelTerm(in Ray ray, in vec3 n, in float power) {\n\tfloat fresnel = min(1., dot(ray.dir, n) + 1.0);\n\tfresnel = pow(fresnel, power);\n    return fresnel;\n}\n\n/*\n---- LIGHTING ----\n*/\n\n// Pretty background colour of some sort...\nvec3 backgroundColour (in Ray ray, in float divergence) {\n    return vec3(1);\n    // Declare a horizon and extremity (either zenith or nadir)\n    vec3 base, extremity, texture;\n    float x = smoothstep(0.0,1.0,abs(ray.dir.y));\n   // base = mix(vec3(0.05, 0.1, 0.2), vec3(0.0), x);\n    \n    if (ray.dir.y >= 0.0) {\n        // sky: fake as hell clouds\n    \tbase = mix(kHORIZONCOLOUR, kZENITHCOLOUR, x);\n        texture = vec3(1);\n        float cloudFactor = 0.0;\n        \n        vec2 coord = ray.dir.xz / 8.0;\n        float scale = 1.0;\n        for (int i=0; i<4; i++) {\n            float offset = iTime * 0.03 / scale;\n            cloudFactor += texrand(coord + vec2(0, -offset), 3.0).r * scale;\n            coord *= 2.0;\n            scale *= 0.5;\n        }\n        cloudFactor /= 1.5;\n        vec3 cloud = mix(vec3(0.4), vec3(1), cloudFactor);\n        base = mix(base, cloud, cloudFactor * ray.dir.y * ray.dir.y);\n        \n    } else {\n        // ground: fake as hell desert\n        texture = kNADIRCOLOUR * 0.5;\n        vec2 floorCoord = floorPos(ray, -30.0) + vec2(0, iTime * 100.0);\n        texture *= (sin(floorCoord.x * .183 + floorCoord.y * 0.183 + sin(floorCoord.y * 0.3) * 0.5) \n                    + sin(floorCoord.x * .15 + floorCoord.y * 0.22 + sin(floorCoord.x * 0.26) * 0.5))\n            * 0.25 + 0.5;\n\t\tbase = mix(kHORIZONCOLOUR, kNADIRCOLOUR + texture, x);\n        \n    }\n    \n    \n    \n    return base;\n}\n\n// Technically broken, but seems to make soft shadows? *shrug*\nfloat occlusion(in Ray ray, in vec3 n) {\n    vec3 origin = ray.origin;\n    float o = 0.0;\n    ray.dir = n;\n    float x = eps*2.0;\n    origin += ray.dir * x;\n    for (float i=1.0; i<7.0; i++) {\n    \tray.origin = origin + ray.dir * x;\n        float d = sceneDist(ray).d;\n        o += max(x - d, 0.0) / x / i;\n        \n        x *= 4.0;\n    }\n \treturn 1.0 - o;\n}\n\nvec3 highlight(in Ray ray, in vec3 n) {\n    // sun\n\tvec3 sunDir = normalize(vec3(1,0.3,1));\n\tfloat sunDist = distance(sunDir, ray.dir)-0.00;\n\treturn mix(vec3(10,10,8), vec3(0), smoothstep(0.0, 0.2, sunDist));\n}\n\n/*\n---- RAY MARCHING ----\n*/\n\n// The main marching loop\nvoid marchRay(inout Ray ray, inout vec3 colour) {\n    bool inside = false; // are we inside or outside the glass object\n    vec3 impact = vec3(1); // This decreases each time the ray passes through glass, darkening colours\n\n    vec3 startpoint = ray.origin;\n    \n#ifdef DEBUG   \nvec3 debugColour = vec3(1, 0, 0);\n#endif\n    \n    SDResult result;\n    vec3 n;\n    vec3 glassStartPos;\n    \n    //float glow = 0.0;\n    \n    for (int i=0; i<kMAXITERS; i++) {\n        // Get distance to nearest surface\n        result = sceneDist(ray);\n        \n        //glow += result.material == kGLOWMATERIAL ? \n        //    pow(max(0.0, (80.0 - result.d) * 0.0125), 4.0) * result.d * 0.01\n        //    : 0.0;\n        \n        // Step half that distance along ray (helps reduce artefacts)\n        float stepDistance = (inside ? abs(result.d) : result.d) * 0.5;\n        ray.origin += ray.dir * stepDistance;\n        //if (length(ray.origin) > 40.0) { break; }\n        \n        if (stepDistance < eps) {\n            // colision\n            // normal\n            // Get the normal, then clamp the intersection to the surface\n    \t\tn = normal(ray);\n            //clampToSurface(ray, stepDistance, n);\n#ifdef DEBUG\n//debugColour = n;\n//break;\n#endif\n            \n            if ( result.material == kFLOORMATERIAL ) {\n                // ray hit floor\n                \n                // Add some noise to the normal, since this is pretending to be grit...\n                vec3 randomNoise = texrand(ray.origin.xz * 0.4, 0.0);\n                randomNoise.xz = randomNoise.xz * 2. - 1.;\n                n = mix(n, normalize(vec3(randomNoise.x, 1, randomNoise.y)), randomNoise.z * 0.3);\n                \n                // Colour is just grey with crappy fake lighting...\n                float o = occlusion(ray, n);\n                colour += vec3(1) * o * impact;\n                impact *= 0.;\n                break;\n            }\n            \n            if ( result.material == kMATTEMATERIAL ) {\n                // ray hit floor\n                \n                // Add some noise to the normal, since this is pretending to be grit...\n                vec3 randomNoise = texrand(n.xz * 0.5 + 0.5, 0.0);\n                randomNoise.xz = randomNoise.xz * 2. - 1.;\n               // n = mix(n, normalize(vec3(randomNoise.x, 1, randomNoise.y)), randomNoise.z * 0.1);\n                \n                // Colour is just grey with crappy fake lighting...\n                float o = occlusion(ray, n);\n                colour += vec3(1) * o * impact;\n                impact *= 0.;\n                break;\n            }\n            \n            if (result.material == kGLOWMATERIAL) {\n             \tcolour = mix(colour, kGLOWCOLOUR, impact);\n                impact *= 0.;\n                break;\n            }\n            \n            // check what material it is...\n            \n            if (result.material == kMIRRORMATERIAL) {\n                \n                // handle interior glass / other intersecion\n                if (inside) {\n                     float glassTravelDist =  min(distance(glassStartPos, ray.origin) / 16.0, 1.);\n    \t\t\t\tglassStartPos = ray.origin;\n                    // mix in the colour\n                \timpact *= mix(kGLASSCOLOUR, kGLASSCOLOUR * 0.1, glassTravelDist);\n                    \n                }\n                \n                // it's a mirror, reflect the ray\n                ray.dir = reflect(ray.dir, n);\n                    \n                // Step 2x epsilon into object along normal to ensure we're beyond the surface\n                // (prevents multiple intersections with same surface)\n                ray.origin += n * eps * 4.0;\n                \n                // Mix in the mirror colour\n                colour += highlight(ray, n);\n                impact *= kMIRRORCOLOUR;\n                float o = occlusion(ray, n);\n                impact *= o;\n#ifdef DEBUG\ndebugColour = vec3(o);\nbreak;\n#endif\n                \n            } else {\n                // glass material\n            \n                if (inside) {\n                \t// refract glass -> air\n                \tray.dir = refract(ray.dir, -n, 1.0/kREFRACT);\n                    \n                    // Find out how much to tint (how far through the glass did we go?)\n                    float glassTravelDist =  min(distance(glassStartPos, ray.origin) / 16.0, 1.);\n    \n                    // mix in the colour\n                \timpact *= mix(kGLASSCOLOUR, kGLASSCOLOUR * 0.1, glassTravelDist);\n                    \n#ifdef DEBUG\ndebugValue += glassTravelDist / 2.0;\n#endif\n      \n                \n              \t} else {\n               \t\t// refract air -> glass\n                \tglassStartPos = ray.origin;\n                    \n              \t  \t// Mix the reflection in, according to the fresnel term\n                \tfloat fresnel = fresnelTerm(ray, n, 1.0);\n                    fresnel = fresnel;\n    \t\t\t\t/*\n                    colour = mix(\n                    \tcolour, \n                    \ttexture(iChannel1, reflect(ray.dir, n)), \n                    \tvec4(fresnel) * impact);\n*/\n                    colour = mix(\n                        colour,\n                        backgroundColour(ray, 0.0),\n                        vec3(fresnel) * impact);\n                \tcolour += n.x * 0.1;//highlight(ray, n);\n                    impact *= 1.0 - fresnel;\n    \t\t\t\n                \t// refract the ray\n            \t\tray.dir = refract(ray.dir, n, kREFRACT);\n                    \n#ifdef DEBUG\n//debugValue += 0.5;\n#endif\n                }\n            \n            \t// Step 2x epsilon into object along normal to ensure we're beyond the surface\n                ray.origin += (inside ? n : -n) * eps * 2.0;\n                \n                // Flip in/out status\n                inside = !inside;\n            }\n        }\n        \n        // increase epsilon\n        eps += divergence * stepDistance;\n    }\n    \n    // So far we've traced the ray and accumulated reflections, now we need to add the background.\n   // colour += texture(iChannel0, ray.dir) * impact;\n    ray.origin = startpoint;\n    colour.rgb += backgroundColour(ray, 0.0) * impact; // + glow * kGLOWCOLOUR;\n    \n#ifdef DEBUG\n//debugColour.rgb = ray.dir;\n//debugColour = vec3(float(debugStep)/2.0);\ncolour = debugColour;\n#endif\n}\n\n// Sets up a camera at a position, pointing at a target.\n// uv = fragment position (-1..1) and fov is >0 (<1 is telephoto, 1 is standard, 2 is fisheye-like)\nCamera setupCam(in vec3 pos, in vec3 target, in float fov, in vec2 uv) {\n\t\t// cam setup\n    // Create camera at pos\n\tCamera cam;\n    cam.pos = pos;\n    \n    // A ray too\n    Ray ray;\n    ray.origin = pos;\n    \n    // FOV is a simple affair...\n    uv *= fov;\n    \n    // Now we determine hte ray direction\n\tvec3 cw = normalize (target - pos );\n\tvec3 cp = vec3 (0.0, 1.0, 0.0);\n\tvec3 cu = normalize ( cross(cw,cp) );\n\tvec3 cv = normalize ( cross (cu,cw) );\n    \n\tray.dir = normalize ( uv.x*cu + uv.y*cv + 0.5 *cw);\n    \n    // Add the ray to the camera and our work here is done.\n\tcam.ray = ray;\n    \n    // Ray divergence\n    divergence = fov / iResolution.x;\n    \n\treturn cam;\n}\n\nvec3 camPath(in float time) {\n    \n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = mouse * kPI * 2.0 + kPI;\n    \n    vec3 camPos = vec3(sin(time * 0.3) * 2.0, sin(time * 0.13) * 2.0 + 4.5, time);\n\t\n    //R(camPos.xz, time + mouse.x);\n    //R(camPos.zy, sin(time) * kPI * 0.1 + 0.2);\n    \n    return camPos;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // We'll need a camera. And some perspective.\n    \n\t// Get some coords for the camera angle from the frag coords. Convert to -1..1 range.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2. - 1.;\n    \n    // Aspect correction so we don't get oval bokeh\n    uv.y *= iResolution.y/iResolution.x;\n    \n    // Make a camera with ALL NEW AND IMPROVED! camera code :)\n    float camTime = iTime;\n    vec3 camPos = camPath(camTime);\n    vec3 camTarget = camPath(camTime + 1.0);\n    camTarget.y = 0.0;\n    //camTarget.y -= 3.0;\n    Camera cam = setupCam(camPos, camTarget, 0.75, uv);\n    \n    // Let's raymarch some stuff and inject that into the scene...\n    \n    // Create an empty colour\n    vec3 col = vec3(0);\n    \n    // Trace that ray!\n    marchRay(cam.ray, col);\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtdXRS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtdXz7", "name": "Sphere to Plane Transition", "author": "Ark", "description": "A transition by a homeomorphism between the sphere in R^3 with a single point removed and the set of all points in R^2.\nãçé¢ä¸ããä¸ç¹ãåãé¤ããéåãã¨ãå¹³é¢ä¸ã®ç¹å¨ä½ãã®éã®åç¸ååã«ããé·ç§»", "tags": ["transition"], "likes": 7, "viewed": 240, "date": "1478880345", "time_retrieved": "2024-06-20T18:45:02.375109", "image_code": "#define INF 1e10\n#define EPS 1e-2\n#define PI 3.14159265359\n\nstruct Camera{\n    vec3 pos;\n    vec3 dir;\n    vec3 up;\n    vec3 side;\n    float focus;\n} camera;\n\nstruct Ray {\n    vec3 dir;\n} ray;\n\nstruct Light{\n    vec3 pos;\n} light;\n\nstruct Intersection{\n    vec3 pos;\n    vec3 diffuseColor;\n    vec3 specularColor;\n    vec3 ambientColor;\n    float specularPower;\n} intersection;\n\nvoid setPhong() {\n    intersection.diffuseColor = vec3(0.2, 0.4, 0.7);\n    intersection.specularColor = vec3(1.0, 1.0, 1.0) * 0.9;\n    intersection.ambientColor = vec3(0.0, 0.02, 0.10);\n    intersection.specularPower = 20.0;\n}\n\nvec3 convert(float r, float theta, float phi, float a) {\n    float x = r*sin(theta)*cos(phi);\n    float y = r*sin(theta)*sin(phi);\n    float z = r*cos(theta);\n    \n    float h = -1.0;\n    float t = (z-r)/(h-r);\n    float _x = x/t;\n    float _y = y/t;\n    \n    vec3 v1 = vec3(x, y, z);\n    vec3 v2 = vec3(_x, _y, h);\n    \n    //return mix(v1, v2, a);\n    return clamp(mix(v1, v2, a), -vec3(INF), vec3(INF));\n}\n\nvoid init(vec2 pos) {\n    float phi = PI*iTime/6.0;\n    float theta = mix(EPS, PI-EPS, sin(PI*iTime/13.0)*0.5+0.5);\n    camera.pos = convert(3.0, theta, phi, 0.0);\n    //camera.pos = vec3(3.0, 0.0, 2.0);\n    camera.dir = normalize(-camera.pos);\n    camera.side = normalize(cross(camera.dir, vec3(0.0, 0.0, 1.0)));\n    camera.up = normalize(cross(camera.side, camera.dir));\n    camera.focus = 1.8;\n    light.pos = vec3(15.0, 20.0, 5.0);\n    ray.dir = normalize(camera.side*pos.x + camera.up*pos.y + camera.dir*camera.focus);\n    setPhong();\n}\n\nfloat capsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p-a;\n    vec3 ba = b-a;\n    float h = clamp(dot(pa, ba)/dot(ba, ba), 0.0, 1.0);\n    return max(0.0, length(pa - ba*h) - r);\n}\n\nfloat torus(vec3 p, float r1, float r2) {\n    vec2 q = vec2(length(p.xy)-r1, p.z);\n    return abs(length(q)-r2);\n}\n\nfloat getT() {\n    return pow(sin(iTime/3.0), 4.0);\n}\n\nfloat dist(vec3 pos) {\n    float res = INF;\n    \n    const float r = 1.0;\n    \n///*\n    const int N = 36;\n    const float weight = 0.02;\n    \n    for(int i=0; i<N; i++) {\n        float theta = mix(0.1, PI, float(i)/float(N));\n        vec3 v = convert(r, theta, 0.0, getT());\n        float d = torus(pos-vec3(0.0, 0.0, v.z), length(v.xy), weight);\n        res = min(res, d);\n    }\n//*/    \n/*\n    const int num1 = 8;\n    const int num2 = 12;\n    const float weight = 0.05;\n    for (int i=0; i<num1; i++) {\n        for (int j=0; j<num2; j++) {\n            float phi1 = mix(0.0, 2.0*PI, float(i)/float(num1));\n            float phi2 = mix(0.0, 2.0*PI, float(i+1)/float(num1));\n            float theta1 = mix(0.1, PI, float(j)/float(num2));\n            float theta2 = mix(0.1, PI, float(j+1)/float(num2));\n            vec3 v1 = convert(r, theta1, phi1, getT());\n            vec3 v2 = convert(r, theta1, phi2, getT());\n            vec3 v3 = convert(r, theta2, phi1, getT());\n            float d1 = capsule(pos, v1, v2, weight);\n            float d2 = capsule(pos, v1, v3, weight);\n            res = min(res, min(d1, d2));\n        }\n    }\n*/\n    \n    return res;\n}\n\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        dist(p+vec3(EPS,0,0)) - dist(p),\n        dist(p+vec3(0,EPS,0)) - dist(p),\n        dist(p+vec3(0,0,EPS)) - dist(p)\n    ));\n}\n\nvec3 calc() {\n    \n    float t = 0.0, d;\n    intersection.pos = camera.pos;\n    const int N = 24;\n    for(int i=0; i<N; i++) {\n        d = dist(intersection.pos);\n        if (abs(d) < EPS) break;\n        t += d*0.9+EPS;\n        intersection.pos = camera.pos + t*ray.dir;   \n    }\n    \n    vec3 n = getNormal(intersection.pos);\n    vec3 lightDir = - normalize(intersection.pos - light.pos);\n    vec3 eyeDir = - normalize(intersection.pos - camera.pos);\n    float diffuse = clamp(dot(n, lightDir), 0.0, 1.0);\n    float specular = pow(clamp(dot(n, normalize(lightDir+eyeDir)), 0.0, 1.0), intersection.specularPower);\n    float ambient = 1.0;\n\n    if (abs(d) < EPS) {\n        return vec3(diffuse * intersection.diffuseColor + specular * intersection.specularColor + ambient * intersection.ambientColor);\n    } else {\n        return vec3(0.1);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = (2.0*fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n    init(uv);\n    \n    vec3 col = calc();\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtdXz7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtKGDD", "name": "Tunnel Beauty 4", "author": "aiekick", "description": "Tunnel Beauty 4", "tags": ["tunnel", "4", "beauty"], "likes": 13, "viewed": 593, "date": "1478888682", "time_retrieved": "2024-06-20T18:45:03.066159", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2016 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\nmat3 RotZ(float a){return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\n\nvec3 path(vec3 p)\n{\n\tp *= RotZ(p.z * 0.1);\n    p += sin(p.zxy * 0.5) * 0.5;\n\tp *= RotZ(p.z * 0.2);\n   \treturn sin(p.zxy * 0.2) * 2.;\n}\n\nfloat df(vec3 p)\n{\n\tp += path(p);\n\tp *= RotZ(p.z * 0.01);\n\treturn mix(3.,2.5+3.5*sin(p.z*.5),abs(fract(atan(p.x, p.y)/3.14159*3.)-.5)) - length(p.xy);\n}\n\nvec3 nor( vec3 pos, float prec )\n{\n\tvec3 eps = vec3( prec, 0., 0. );\n\tvec3 nor = vec3(\n\t    df(pos+eps.xyy) - df(pos-eps.xyy),\n\t    df(pos+eps.yxy) - df(pos-eps.yxy),\n\t    df(pos+eps.yyx) - df(pos-eps.yyx) );\n\treturn normalize(nor);\n}\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// get density of the df at surfPoint\n// ratio between constant step and df value\nfloat SubDensity(vec3 surfPoint, float prec, float ms) \n{\n\tvec3 n;\n\tfloat s = 0.;\n    const int iter = 3;\n\tfor (int i=0;i<iter;i++)\n\t{\n\t\tn = nor(surfPoint,prec); \n\t\tsurfPoint = surfPoint - n * ms; \n\t\ts += df(surfPoint);\n\t}\n\t\n\treturn 1.-s/(ms*float(iter)); // s < 0. => inside df\n}\n\nfloat SubDensity(vec3 p, float s) \n{\n\tvec3 n = nor(p,s); \t\t\t\t\t\t\t// precise normale at surf point\n\treturn df(p - n * s)/s;\t\t\t\t\t\t// ratio between df step and constant step\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 g = fragCoord;\n\tvec2 si = iResolution.xy;\n\t\n\tvec2 uv = (g+g-si)/si.y;\n\n\tfloat time = iTime*0.5;\n\t\n\tvec3 ro = vec3(0,0, time*5.);\n\tro -= path(ro);\n\t\n\tvec3 cv = ro + vec3(0,0,4); // cam view\n\tcv -= path(cv);\n\t\n\tvec3 lp = ro;\t// light pos\n\t\n\tvec3 cu = normalize(vec3(0,1,0));\n  \tvec3 z = normalize(cv-ro);\n    vec3 x = normalize(cross(cu,z));\n  \tvec3 y = cross(z,x);\n  \tvec3 rd = normalize(z + uv.x*x + uv.y*y);\n\n\tfloat s = 1., d = 0.;\n\tfor (int i=0; i<150; i++) \n\t{\n\t\tif (log(d*d/s/1e6)>0.) break; \n\t\td += (s = df(ro+rd*d))*0.2;\n\t}\n\t\n\tvec3 p = ro + rd * d;\t\t\t\t\t\t\t\t\t\t\t// surface point\n\tvec3 ld = normalize(lp-p); \t\t\t\t\t\t\t\t\t\t// light dir\n\tvec3 n = nor(p, 0.1);\t\t\t\t\t\t\t\t\t\t\t// normal at surface point\n\tvec3 refl = reflect(rd,n);\t\t\t\t\t\t\t\t\t\t// reflected ray dir at surf point \n\tfloat diff = clamp( dot( n, ld ), 0.0, 1.0 ); \t\t\t\t\t// diffuse\n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 4. ); \t\t\t// fresnel\n\tfloat spe = pow(clamp( dot( refl, ld ), 0.0, 1.0 ),16.);\t\t// specular\n\tvec3 col = vec3(0.8,0.5,0.2);\n\tfloat sss = df(p - n*0.001)/0.01;\t\t\t\t\t\t\t\t// quick sss 0.001 of subsurface\n\t\n\tfloat sb = SubDensity(p, 0.01, 0.01);\t\t\t\t\t\t\t// deep subdensity \n\tvec3 bb = clamp(blackbody(100. * sb),0.,1.);\t\t\t\t\t// blackbody color\n\tfloat sss2 = 1.0 - SubDensity(p, 1.5); \t\t\t\t\t\t\t// one step sub density of df of 1.5 of subsurface\n\t\n\tvec3 a = (diff + fre + bb * sss * .8 + col * sss * .2) * 0.35 + spe;\n    vec3 b = col * sss2;\n    \n\tfragColor.rgb = mix(a, b, .8-exp(-0.005*d*d));\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtKGDD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MttSzM", "name": "TheDream", "author": "dila", "description": "Had a go at producing some more interesting textures instead of using the raw stock images.", "tags": ["raymarch"], "likes": 27, "viewed": 396, "date": "1478867567", "time_retrieved": "2024-06-20T18:45:03.072252", "image_code": "vec3 col1 = vec3(0.659, 0.435, 0.18);\nvec3 col2 = vec3(0.455, 0.349, 0.059);\nvec3 col3 = vec3(0.667, 0.569, 0.514);\n\nfloat hash( float n ) { return fract(sin(n)*13.5453123); }\nvec2 hash2(vec2 p) { return vec2(hash(p.x), hash(p.y)); }\n\nmat2 rot(float x)\n{\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdBoxZ( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,d.y),0.0) + length(max(d.xy,0.0));\n}\n\nfloat cylinder(vec3 p, vec2 b)\n{\n    float d = length(p.yz) - b.x;\n    float k = b.y - abs(p.x);\n    return max(d, -k);\n}\n\nfloat mid = 0.0;\nvec3 mpos = vec3(0.0);\n\nfloat rs = 11.0;\nfloat hs = 6.0;\n\nfloat picpos(vec3 p)\n{\n    return floor(p.z / hs + 0.5) + floor(p.x / rs * 7.0 + 0.5);\n}\n\nfloat cam = 0.25;\n\nfloat map(vec3 p)\n{\n    p.y += sin(p.z * cam);\n    \n    mid = 0.0;\n    mpos = p;\n    \n    float rw = 4.2;\n    float rh = 4.0;\n    float fx = (fract(p.x / rs - 0.5) - 0.5) * rs;\n    vec3 rp = vec3(p.x, p.y, p.z);\n\tfloat rd = -sdBoxZ(rp, vec3(rw, rh, 1.0));\n\n    vec3 kp = vec3(abs(p.x) - rw * 1.75 - 1.0, p.y, p.z);\n    float kd = -sdBoxZ(kp, vec3(rw * 0.75, rh, 1.0));\n    if (kd > rd) {\n        rd = kd;\n        mid = 3.0;\n    }\n    \n    float ct = 0.1;\n    float ax = abs(p.x) - rw + ct;\n    float cx = (fract(ax / rs - 0.5) - 0.5) * rs;\n    vec3 hp = vec3(ax, p.y, (fract(p.z / hs) - 0.5) * hs);\n    float hd = -sdBox(hp, vec3(2.0, 2.0, 1.5));\n    \n    float d = rd;\n    if (hd > rd) {\n        d = hd;\n        mid = 1.0;\n    }\n\n    vec3 cp = vec3(ax, p.y, (fract(p.z / hs + 0.5) - 0.5) * hs);\n    cp.yz *= rot(iTime * 1.25 + picpos(p));\n    float cd = cylinder(cp, vec2(2.0, ct));\n    \n    if (cd < d) {\n        d = cd;\n        mid = 2.0;\n        mpos = cp;\n    }\n    \n    return d;\n}\n\nvec3 normal(vec3 p)\n{\n\tvec3 o = vec3(0.01, 0.0, 0.0);\n    return normalize(vec3(map(p+o.xyy) - map(p-o.xyy),\n                          map(p+o.yxy) - map(p-o.yxy),\n                          map(p+o.yyx) - map(p-o.yyx)));\n}\n\nfloat trace(vec3 o, vec3 r)\n{\n    float t = 0.0;\n    for (int i = 0; i < 40; ++i) {\n        t += map(o + r * t);\n    }\n    return t;\n}\n\nvec3 strips(vec2 p)\n{\n    float gap = 0.25;\n    float fy = fract(p.y);\n    float kx = max(fy - gap, 0.0) / (1.0 - gap);\n    float ky = min(fy, gap) / gap;\n    float ku = 4.0 * kx * (1.0 - kx);\n    ku = 1.0 - pow(1.0 - ku, 5.0);\n    vec3 tex = texture(iChannel0, p * 0.1).xyz;\n    tex *= tex;\n    float dark = 1.0 - ky;\n    dark = dark * dark;\n    vec3 gs = mix(col3 * 0.125, col3, dark);\n    return tex * (col3 * ku + gs);\n}\n\nvec3 tiles(vec2 p)\n{\n    p *= 0.5;\n    vec2 f = fract(p);\n    float gap = 0.01;\n    vec2 kx = max(f - gap, 0.0) / (1.0 - gap);\n    vec2 ky = min(f, gap) / gap;\n    vec2 ku = 4.0 * kx * (1.0 - kx);\n    ku = pow(1.0 - ku, vec2(5.0));\n    vec2 fp = floor(p);\n    vec2 tu = hash2(fp) * 1000.0 + fract(p);\n    vec3 tex = texture(iChannel1, tu * 0.1).xyz;\n    tex *= tex;\n    float bwt = dot(tex, vec3(0.299, 0.587, 0.114));\n    float alt = mod(fp.x + fp.y, 2.0);\n    float gc = max(ku.x, ku.y);\n    vec3 gl = mix(col3 * bwt * 0.5, col3 * (1.0 - bwt), alt);\n    vec3 gs = mix(col1, col1 * 0.125, max(ku.x, ku.y));\n    return mix(gl, gs, gc);\n}\n\nvec3 picture(vec3 p, vec3 w)\n{\n    vec2 q = p.yz;\n    q *= 0.5;\n    float d = 1000.0;\n    vec2 tuv = vec2(0.0);\n    float fid = 0.0;\n    float pp = picpos(w) * 3.14159 * 0.125;\n    const int n = 5;\n    for (int i = 0; i < n; ++i) {\n        float fi = float(i) / float(n);\n        q = abs(q) - 0.25;\n        q *= rot(3.14159 * 0.25 + pp * 3.345);\n        q.y = abs(q.y) - 0.25;\n        q *= rot(pp);\n        float b = sdBoxZ(vec3(q, 0.0), vec3(0.5, 0.125, 1.0));\n        if (b < d) {\n            d = b;\n            tuv = q;\n            fid = fi;\n        }\n    }\n    vec3 tex = texture(iChannel1, tuv * 0.1).xyz;\n    tex *= tex;\n    tex = mix(col3, tex * col3, 1.0-fid);\n    return tex;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 o = vec3(0.0, 0.0, iTime * 2.0);\n    vec3 r = normalize(vec3(uv, 0.7 - dot(uv, uv) * 0.5));\n    \n    o.y -= sin(o.z * cam);\n    r.xy *= rot(sin(iTime * 0.125) * 3.14159 * 0.125);\n    \n    float t = trace(o, r);\n    vec3 w = o + r * t;\n    vec3 sn = normal(w);\n    \n    vec3 tex = vec3(1.0);\n\n    if (mid == 1.0) {\n        if (abs(sn.y) < 0.1) {\n            tex = strips(mpos.xy);\n        } else {\n            tex = strips(mpos.xy);\n        }\n    } else if (mid == 2.0) {\n        if (abs(sn.x) < 0.1) {\n            tex = col1 * 0.25;\n        } else {\n            tex = picture(mpos, w);\n        }\n    } else if (mid == 3.0) {\n        vec2 st = mpos.yz - 2.0 * vec2(0.0, o.z);\n        tex = tiles(st);\n    } else if (abs(sn.y) < 0.1) {\n        tex = strips(mpos.zy);\n    } else {\n        vec2 st = mpos.xz + vec2(0.0, o.z);\n        tex = tiles(st);\n    }\n    \n    vec3 lit = vec3(0.3);\n    \n    vec3 lpos = o + vec3(0.0, 0.0, 0.0);\n    lpos += vec3(0.0, 0.0, 0.0);\n    vec3 ldel = w - lpos;\n    float ldist = length(ldel);\n    ldel /= ldist;\n    float lm = max(dot(ldel, -sn), 0.0);\n    lm /= 1.0 + ldist * ldist * 0.1;\n    lit += vec3(lm) * col3 * 2.0;\n    \n\tfloat aoc = map(w + sn * 1.2);\n    float fog = 1.0 / (1.0 + t * t * 0.001);\n    vec3 fc = lit * tex * aoc * fog;\n\tfragColor = vec4(sqrt(fc), 1.0);\n}", "image_inputs": [{"id": "XsXGRn", "previewfilepath": "/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MttSzM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MttXD4", "name": "Daily Shade day 19: Alien Zardoz", "author": "psonice", "description": "Wanted to work on backgrounds today. Added cheap clouds, desert, gradients, then made a spaceship that looks more like a weird alien zardoz. Now with some mouse control.", "tags": ["raymarch", "glass", "mirror", "daily", "zardoz"], "likes": 7, "viewed": 792, "date": "1479734808", "time_retrieved": "2024-06-20T18:45:05.926860", "image_code": "/* \nDay 19: Background time.\nMade a weird alien glass + mirror space ship, because glass and mirror.\n*/\n\n//#define DEBUG\n#ifdef DEBUG\nint debugStep = 0;\nfloat debugValue = 0.0;\n#endif\n\n// Rotation\n#define R(p,a) p=cos(a)*p+sin(a)*vec2(-p.y,p.x);\n\n\n#define kINFINITY 10000.0 // An unimaginably large number\n#define kSQRT2 1.414213\n#define kISQRT2 0.707107\n#define kPI 3.141592\n\n// maximum iteration count\n#define kMAXITERS 200\n#define kEPSILON 0.001\n#define kMAXINTERSECTIONS 1\n\n// refractive index\n#define kREFRACT 1.0/1.5\n\n// materials\n#define kFLOORMATERIAL 0\n#define kGLASSMATERIAL 1\n#define kMIRRORMATERIAL 2\n\n#define kFLOORCOLOUR vec3(0.7, 0.65, 0.6)\n#define kGLASSCOLOUR vec3(1.0, 0.5, 0.1)\n#define kMIRRORCOLOUR vec3(0.8)\n\n#define kZENITHCOLOUR vec3(0.3, 0.7, 1.0)\n#define kNADIRCOLOUR vec3(0.7, 0.6, 0.4)\n#define kHORIZONCOLOUR vec3(0.95)\n#define kSUNCOLOUR vec3(100, 90, 70)\n\n// A ray. Has origin + direction.\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n    \n// Distance to nearest surface\nstruct SDResult {\n    float d; // Distance\n    int material; // Nearest material\n};\n\n// A camera. Has a position and a direction. \nstruct Camera {\n    vec3 pos;\n    Ray ray;\n};\n    \n// A disk. Has position, size, colour.\nstruct Disk {\n    vec3 pos;\n    float radius;\n    vec3 col;\n};\n    \nstruct Sphere {\n    vec3 pos;\n    float radius;\n};\n    \nstruct Box {\n\tvec3 pos;\n\tvec3 size;\n    float radius;\n};\n    \nfloat eps = kEPSILON;\nfloat divergence;\n\nvec3 smoothBlend(in vec3 point, in vec3 about, in float radius) {\n    point -= about;\n    point = mix(-point, point, smoothstep(-radius, radius, point));\n    return point + about;\n}\n    \n// Distance to sphere (signed)\nfloat sphereDist(in Ray ray, in Sphere sphere) {\n    return length(ray.origin - sphere.pos) - sphere.radius;\n}\n\n// Distance to sphere surface\nfloat uSphereDist(in Ray ray, in Sphere sphere) {\n    return abs(length(ray.origin - sphere.pos) - sphere.radius);\n}\n\n// Distance to box surface (signed)\nfloat boxDist(in Ray ray, in Box box) {\n    vec3 dist = abs(ray.origin - box.pos) - (box.size * 0.5);\n    vec3 cDist = max(dist, 0.0);\n    return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(cDist) - box.radius;\n}\n\n// Distance to box surface\nfloat uBoxDist(in Ray ray, in Box box) {\n    return abs(length(max(abs(ray.origin - box.pos) - (box.size * 0.5), 0.0)) - box.radius);\n}\n\n// distance to floor\nfloat floorDist(in Ray ray) {\n    float dist = ray.origin.y;\n    return dist;\n}\n\n// traced coords of floor intersection, floor at height y\nvec2 floorPos(in Ray ray, in float y) {\n    float dist = (ray.origin.y - y) / ray.dir.y;\n \treturn ray.origin.xz + ray.dir.xz * dist; \n}\n\n/*\n---- Random/hash stuff ----\n*/\n\n// Normalised random number, borrowed from Hornet's noise distributions: https://www.shadertoy.com/view/4ssXRX\nfloat nrand(in vec2 n) {\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\n// random value based on texture channel 2\nvec3 texrand(in vec2 n, in float mipLevel) {\n    return texture(iChannel2, n, mipLevel).xyz;\n}\n\n// returns a hash value for a fixed size cell\nfloat hashForCell(in vec3 pos, in float cellSize) {\n    float hash = nrand(floor(pos.xz / cellSize) + 68.0);\n    return hash;\n}\n\n// returns a random colour based on the cell hash\nvec3 randomColourForCell(in vec3 pos, in float cellSize) {\n\tfloat hash = hashForCell(pos, cellSize); \n    return vec3(\n        nrand(vec2(hash * 2.0, hash * 4.0)),\n        nrand(vec2(hash * 4.0, hash * 8.0)),\n        nrand(vec2(hash * 8.0, hash * 16.0))\n\t);\n\tvec3 c = vec3(hash, mod(hash + 0.15, 1.0), mod(hash + 0.3, 1.0)) * 0.75;\n}\n\n/*\n---- INTERSECTION OPS ----\n*/\n\n// Union of two signed distances\nfloat unionOp(float d0, float d1) {\n    return min(d0, d1);\n}\n\n// Union of two unsigned distances\nfloat unionOpU(float d0, float d1) {\n    return min(d0, d1);\n}\n\n// Intersection of two signed distances\nfloat intersectOp(float d0, float d1) {\n    return max(d0, d1);\n}\n\n// Intersection of two unsigned distances\nfloat intersectOpU(float d0, float d1) {\n    return max(d0, d1);\n}\n\n// Difference of two signed distances\nfloat differenceOp(float d0, float d1) {\n    return max(d0, -d1);\n}\n\n// Difference of two unsigned distances\nfloat differenceOpU(float d0, float d1) {\n    return max(d0, -d1);\n}\n\n/*\n---- Scene rendering ----\n*/\n\n// Get the distance to the scene (returns a struct containing distance and nearest material)\nSDResult sceneDist(in Ray ray) {\n    SDResult result;\n    \n    vec3 origin = ray.origin;\n    \n    // Mess with the ray\n    vec2 offset = vec2(\n        sin(iTime * 0.34), \n        cos(iTime * 0.55)\n    );\n    float r = 2.0;\n    \n    ray.origin.xz -= 4.0;\n    ray.origin = smoothBlend(ray.origin, vec3(-4.0, -2, -4.0), r);\n    ray.origin = smoothBlend(ray.origin, vec3(-1.0, -2, -3.0), r);\n    R(ray.origin.xy, 0.3);\n    R(ray.origin.zy, 0.3);\n\n    //ray.origin.xz += 2.0;\n    \n    Box wing = Box(vec3(0), vec3(4.0 * origin.z * 0.50, 0.5, 8.0), 1.0);\n    \n    float distToWing = boxDist(ray, wing);\n    \n    // add a body\n    \n    ray.origin = origin;\n    ray.origin = smoothBlend(ray.origin, vec3(0), r);\n    ray.origin.x -= 5.0;\n    R(ray.origin.xz, 0.3);\n    Box body = Box(vec3(0,0,2), vec3(0, 0, 10), (origin.z + 5.0) * 0.1 );\n    float distToBody = boxDist(ray, body);\n    \n    // add a body\n    \n    ray.origin = origin;\n    ray.origin = smoothBlend(ray.origin, vec3(0), r);\n    ray.origin.x -= 2.0;\n    R(ray.origin.xz, -0.4);\n    ray.origin.z = -ray.origin.z;\n    Box body2 = Box(vec3(0,0,2), vec3(0, 0, 10), (origin.z + 5.0) * 0.15 );\n    \n    distToBody = unionOp(distToBody, boxDist(ray, body2));\n    \n    //Find the neares of the floor and box0\n    result.d = unionOp(distToWing, distToBody);\n    //result.d = distToWing;\n    //result.material = result.d == distToBox ? kGLASSMATERIAL : kMIRRORMATERIAL;\n    result.material = result.d == distToWing ? kGLASSMATERIAL : kMIRRORMATERIAL;\n    return result;\n}\n\n// Gets the normal\nvec3 normal(in Ray ray) {\n    vec2 eps = vec2(0.0001, 0);\n    float baseDist = sceneDist(ray).d;\n \treturn normalize(vec3(\n        sceneDist(Ray(ray.origin + eps.xyy, ray.dir)).d - baseDist,\n        sceneDist(Ray(ray.origin + eps.yxy, ray.dir)).d - baseDist,\n        sceneDist(Ray(ray.origin + eps.yyx, ray.dir)).d - baseDist\n        ));\n}\n\n// Moves the ray to the surface. Helps avoid artefacts due to ray intersection imprecision.\nvoid clampToSurface(in Ray ray, in float d, inout vec3 n) {\n \tray.origin += n * d;\n \td = sceneDist(ray).d;\n \tn = normal(ray);\n}\n\n// Calulcate a fresnel term for reflections\nfloat fresnelTerm(in Ray ray, in vec3 n, in float power) {\n\tfloat fresnel = min(1., dot(ray.dir, n) + 1.0);\n\tfresnel = pow(fresnel, power);\n    return fresnel;\n}\n\n/*\n---- LIGHTING ----\n*/\n\n// Pretty background colour of some sort...\nvec3 backgroundColour (in Ray ray, in float divergence) {\n    \n    // Declare a horizon and extremity (either zenith or nadir)\n    vec3 base, extremity, texture;\n    float x = smoothstep(0.0,1.0,abs(ray.dir.y));\n    \n    if (ray.dir.y >= 0.0) {\n        // sky: fake as hell clouds\n    \tbase = mix(kHORIZONCOLOUR, kZENITHCOLOUR, x);\n        texture = vec3(1);\n        float cloudFactor = 0.0;\n        \n        vec2 coord = ray.dir.xz / 8.0;\n        float scale = 1.0;\n        for (int i=0; i<4; i++) {\n            float offset = iTime * 0.03 / scale;\n            cloudFactor += texrand(coord + vec2(0, -offset), 3.0).r * scale;\n            coord *= 2.0;\n            scale *= 0.5;\n        }\n        cloudFactor /= 1.5;\n        vec3 cloud = mix(vec3(0.4), vec3(1), cloudFactor);\n        base = mix(base, cloud, cloudFactor * ray.dir.y * ray.dir.y);\n        \n    } else {\n        // ground: fake as hell desert\n        texture = kNADIRCOLOUR * 0.5;\n        vec2 floorCoord = floorPos(ray, -30.0) + vec2(0, iTime * 100.0);\n        texture *= (sin(floorCoord.x * .183 + floorCoord.y * 0.183 + sin(floorCoord.y * 0.3) * 0.5) \n                    + sin(floorCoord.x * .15 + floorCoord.y * 0.22 + sin(floorCoord.x * 0.26) * 0.5))\n            * 0.25 + 0.5;\n\t\tbase = mix(kHORIZONCOLOUR, kNADIRCOLOUR + texture, x);\n        \n    }\n    \n    \n    return base;\n}\n\n// Technically broken, but seems to make soft shadows? *shrug*\nfloat occlusion(in Ray ray, in vec3 n) {\n    float o = 0.0;\n    ray.dir = n;\n    float x = 0.1;\n    for (int i=0; i<5; i++) {\n    \tray.origin += x;\n        float d = sceneDist(ray).d;\n        o += max(x - d, 0.0);\n        \n        x *= 2.0;\n    }\n \treturn 1.0 - o * 0.5;;\n}\n\n/*\n---- RAY MARCHING ----\n*/\n\n// The main marching loop\nvoid marchRay(inout Ray ray, inout vec3 colour) {\n    bool inside = false; // are we inside or outside the glass object\n    vec3 impact = vec3(1); // This decreases each time the ray passes through glass, darkening colours\n\n    vec3 startpoint = ray.origin;\n    \n#ifdef DEBUG   \nvec4 debugColour = vec4(1, 0, 0, 1);\n#endif\n    \n    SDResult result;\n    vec3 n;\n    vec3 glassStartPos;\n    \n    for (int i=0; i<kMAXITERS; i++) {\n        // Get distance to nearest surface\n        result = sceneDist(ray);\n        \n        // Step half that distance along ray (helps reduce artefacts)\n        float stepDistance = inside ? abs(result.d) : result.d;\n        ray.origin += ray.dir * stepDistance * 0.3;\n        if (length(ray.origin) > 40.0) { break; }\n        \n        if (stepDistance < eps) {\n            // colision\n            // normal\n            // Get the normal, then clamp the intersection to the surface\n    \t\tn = normal(ray);\n            //clampToSurface(ray, stepDistance, n);\n#ifdef DEBUG\n#endif\n            \n            if ( result.material == kFLOORMATERIAL ) {\n                // ray hit floor\n                \n                // Add some noise to the normal, since this is pretending to be grit...\n                vec3 randomNoise = texrand(ray.origin.xz * 0.4, 0.0);\n                n = mix(n, normalize(vec3(randomNoise.x, 1, randomNoise.y)), randomNoise.z);\n                \n                // Colour is just grey with crappy fake lighting...\n                colour += mix(\n                    kFLOORCOLOUR, \n                    vec3(0), \n                    pow(max((-n.x+n.y) * 0.5, 0.0), 2.0)\n                ) * impact;\n                impact *= 0.;\n                break;\n            }\n            \n            // check what material it is...\n            \n            if (result.material == kMIRRORMATERIAL) {\n                \n                // handle interior glass / other intersecion\n                if (inside) {\n                     float glassTravelDist =  min(distance(glassStartPos, ray.origin) / 16.0, 1.);\n    \t\t\t\tglassStartPos = ray.origin;\n                    // mix in the colour\n                \timpact *= mix(kGLASSCOLOUR, kGLASSCOLOUR * 0.1, glassTravelDist);\n                    \n                }\n                \n                // it's a mirror, reflect the ray\n                ray.dir = reflect(ray.dir, n);\n                    \n                // Step 2x epsilon into object along normal to ensure we're beyond the surface\n                // (prevents multiple intersections with same surface)\n                ray.origin += n * eps * 2.0;\n                \n                // Mix in the mirror colour\n                impact *= kMIRRORCOLOUR;\n                \n            } else {\n                // glass material\n            \n                if (inside) {\n                \t// refract glass -> air\n                \tray.dir = refract(ray.dir, -n, 1.0/kREFRACT);\n                    \n                    // Find out how much to tint (how far through the glass did we go?)\n                    float glassTravelDist =  min(distance(glassStartPos, ray.origin) / 16.0, 1.);\n    \n                    // mix in the colour\n                \timpact *= mix(kGLASSCOLOUR, kGLASSCOLOUR * 0.1, glassTravelDist);\n                    \n#ifdef DEBUG\ndebugValue += glassTravelDist / 2.0;\n#endif\n      \n                \n              \t} else {\n               \t\t// refract air -> glass\n                \tglassStartPos = ray.origin;\n                    \n              \t  \t// Mix the reflection in, according to the fresnel term\n                \tfloat fresnel = fresnelTerm(ray, n, 1.0);\n                    fresnel = fresnel;\n    \t\t\t\t/*\n                    colour = mix(\n                    \tcolour, \n                    \ttexture(iChannel1, reflect(ray.dir, n)), \n                    \tvec4(fresnel) * impact);\n*/\n                    colour = mix(\n                        colour,\n                        backgroundColour(ray, 0.0),\n                        vec3(fresnel) * impact);\n                    impact *= 1.0 - fresnel;\n    \t\t\t\n                \t// refract the ray\n            \t\tray.dir = refract(ray.dir, n, kREFRACT);\n                    \n#ifdef DEBUG\n//debugValue += 0.5;\n#endif\n                }\n            \n            \t// Step 2x epsilon into object along normal to ensure we're beyond the surface\n                ray.origin += (inside ? n : -n) * eps * 2.0;\n                \n                // Flip in/out status\n                inside = !inside;\n            }\n        }\n        \n        // increase epsilon\n        eps += divergence * stepDistance;\n    }\n    \n    // So far we've traced the ray and accumulated reflections, now we need to add the background.\n   // colour += texture(iChannel0, ray.dir) * impact;\n    ray.origin = startpoint;\n    colour.rgb += backgroundColour(ray, 0.0) * impact;\n    \n#ifdef DEBUG\n//debugColour.rgb = ray.dir;\ndebugColour.rgb = vec3(float(debugStep)/2.0);\ncolour = debugColour;\n#endif\n}\n\n// Sets up a camera at a position, pointing at a target.\n// uv = fragment position (-1..1) and fov is >0 (<1 is telephoto, 1 is standard, 2 is fisheye-like)\nCamera setupCam(in vec3 pos, in vec3 target, in float fov, in vec2 uv) {\n\t\t// cam setup\n    // Create camera at pos\n\tCamera cam;\n    cam.pos = pos;\n    \n    // A ray too\n    Ray ray;\n    ray.origin = pos;\n    \n    // FOV is a simple affair...\n    uv *= fov;\n    \n    // Now we determine hte ray direction\n\tvec3 cw = normalize (target - pos );\n\tvec3 cp = vec3 (0.0, 1.0, 0.0);\n\tvec3 cu = normalize ( cross(cw,cp) );\n\tvec3 cv = normalize ( cross (cu,cw) );\n    \n\tray.dir = normalize ( uv.x*cu + uv.y*cv + 0.5 *cw);\n    \n    // Add the ray to the camera and our work here is done.\n\tcam.ray = ray;\n    \n    // Ray divergence\n    divergence = fov / iResolution.x;\n    \n\treturn cam;\n}\n\nvec3 camPath(in float time) {\n    float r = 20.0;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = mouse * kPI * 2.0 + kPI;\n    vec3 camPos = vec3(r, 0, 0);\n\t\n    R(camPos.xz, time + mouse.x);\n    R(camPos.zy, sin(time) * kPI + mouse.y);\n    \n    return camPos;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // We'll need a camera. And some perspective.\n    \n\t// Get some coords for the camera angle from the frag coords. Convert to -1..1 range.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2. - 1.;\n    \n    // Aspect correction so we don't get oval bokeh\n    uv.y *= iResolution.y/iResolution.x;\n    \n    // Make a camera with ALL NEW AND IMPROVED! camera code :)\n    float camTime = iTime / 4.0;\n    vec3 camPos = camPath(camTime);\n    vec3 camTarget = vec3(0);\n    //camTarget.y -= 3.0;\n    Camera cam = setupCam(camPos, camTarget, 0.500, uv);\n    \n    // Let's raymarch some stuff and inject that into the scene...\n    \n    // Create an empty colour\n    vec3 col = vec3(0);\n    \n    // Trace that ray!\n    marchRay(cam.ray, col);\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MttXD4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MttXWN", "name": "WorkShop - 1", "author": "thisisraize", "description": "Workshop experiment", "tags": ["workshop"], "likes": 0, "viewed": 83, "date": "1479756510", "time_retrieved": "2024-06-20T18:45:06.242240", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // RGBA\n    vec4 color = vec4(1.0 ,0.5, 1.0, 0.5);\n    color.r = 0.0;\n    color.bg = vec2(0.0, 0.5);\n    // pixel position\n\tvec2 pixel = fragCoord.xy / iResolution.xy;\n    \n    // center origin point \n    pixel = (pixel - 0.5) * 2.0;\n    \n    // aspect ratio\n    pixel.x *= iResolution.x / iResolution.y;\n    \n    \n    \n    color.gr = pixel.xy;\n    color.b = 1.0;\n    \n    // time elapsed\n    float time = iTime;\n    \n    // oscillation\n    float anim = sin(time) * 0.5 + 0.5;\n    \n    // circle\n    float radius = 0.5 * anim * 0.5 +0.5;\n    float circle = step(length(pixel), radius);\n    //color.rgb *= circle;\n    \n    // smooth circle\n    float smoothCircle = 1.0 - smoothstep(radius, radius + 0.2, length(pixel));\n    //color.rgb *= smoothCircle;\n    \n    // rotation\n    float angle = atan(pixel.y, pixel.x);\n    float dist = length(pixel);\n    angle += time;\n\tangle *= dist;\n    pixel = vec2(cos(angle), sin(angle)) * dist;\n    \n    // square\n    float square = step(abs(pixel.x), radius) * step(abs(pixel.y), radius);\n    color.rgb *= square;\n    \n    // grid\n    float lineSize = 0.02;\n    float cellWidth = 0.2;\n    float grid = step(cellWidth - lineSize, mod(pixel.x, cellWidth));\n    grid += step(cellWidth - lineSize, mod(pixel.y, cellWidth));\n    color.rgb *= grid;\n        \n\tfragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MttXWN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtV3Dy", "name": "Platonic Solids", "author": "decrooks", "description": "The five Platonic solids orbiting a sphere.", "tags": ["3d", "sdf", "cube", "sphere", "tetrahedron", "icosahedron", "dodecahedron", "octahedron", "platonic"], "likes": 27, "viewed": 655, "date": "1478087022", "time_retrieved": "2024-06-20T18:45:08.763465", "image_code": "// Created by David Crooks\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// An exercise in platonic geometry with signed distance funcions.\n// https://en.wikipedia.org/wiki/Platonic_solid\n// SDF\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// http://www.alanzucconi.com/2016/07/01/signed-distance-functions/\n\n#define TWO_PI 6.283185\n#define PI 3.14159265359\n//Golden mean and inverse -  for the icosohedron and dodecadron\n#define PHI 1.6180339887\n#define INV_PHI 0.6180339887\n\nstruct Ray {\n   vec3 origin;\n   vec3 direction;\n};\n\nstruct LightColor {\n\tvec3 diffuse;\n\tvec3 specular;\n};\n    \n    \nstruct Material {\n    LightColor  color;\n    float shininess;\n    float mirror;\n    float refractiveIndex;\n    float opacity;  \n};\n    \n    \nstruct MapValue {\n    float \t  signedDistance;\n    Material  material;\n};\n\nstruct Trace {\n    float    dist;\n    vec3     p;\n    vec3 normal;\n    Ray \t ray;\n    Ray reflection;\n    Material material;\n    bool hit;\n};\n    \n\nstruct PointLight {\n    vec3 position;\n    LightColor color;\n};\n    \nstruct DirectionalLight {\n    vec3 direction;\n    LightColor color;\n};\n    \nPointLight  light1,light2;\n\n\nMaterial blackMat,whiteMat,blueMat,yellowMat;\n\nvec3 rayPoint(Ray r,float t) {\n \treturn r.origin +  t*r.direction;\n}\n\nMapValue intersectObjects( MapValue d1, MapValue d2 )\n{\n    if (d1.signedDistance>d2.signedDistance){\n    \treturn    d1 ;\n    }\n    else {\n        d2.material = d1.material;\n    \treturn d2;\n    }\n}\n\nMapValue addObjects(MapValue d1, MapValue d2 )\n{\n    if (d1.signedDistance<d2.signedDistance) {\n    \treturn    d1 ;\n    }\n    else {\n    \treturn d2;\n    }\n}\n\n\nMapValue subtractObjects( MapValue A, MapValue B )\n{\n    //A-B\n    if (-B.signedDistance>A.signedDistance){\n        B.signedDistance *= -1.0;\n        B.material = A.material;\n    \treturn    B ;\n    }\n    else {\n       \n    \treturn A;\n    }\n}\n\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    //http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  \n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nfloat  plane(vec3 p, vec3 origin, vec3 normal){ \n   return dot(p - origin,normal);   \n}\n\nfloat  doubleplane(vec3 p, vec3 origin, vec3 normal){ \n   return max(dot(p - origin,normal),dot(-p - origin,normal));   \n}\n\nMapValue plane(vec3 p, vec3 origin, vec3 normal , Material m ){\n \n  MapValue mv;\n  mv.material = m;\n   \n  mv.signedDistance = plane(p,origin,normal);\n  return mv;\n}\n\nMapValue sphere(vec3 p, float radius, Material m) {\n  MapValue mv;\n  mv.material = m;\n  mv.signedDistance =length(p) - radius;\n  return mv;\n}\n\nMapValue xzPlane( vec3 p ,float y, Material m)\n{\n  MapValue mv;\n  mv.material = m;\n  mv.signedDistance = p.y - y;\n  return mv;\n}\n\n//////////////////////////////////////////////////////////\n//---------------Platonic solids -----------------------//\n//////////////////////////////////////////////////////////\n\n//cube by iq\nMapValue cube( vec3 p, float d , Material m)\n{\n  MapValue mv;\n  mv.material = m;\n \n  mv.signedDistance = length(max(abs(p) -d,0.0));\n  return mv; \n}\n\n\n\nMapValue tetrahedron(vec3 p, float d, Material m) {\n    \n  MapValue mv;\n  mv.material = m;\n \n  float dn =1.0/sqrt(3.0);\n  \n   //The tetrahedran is the intersection of four planes:\n    float sd1 = plane(p,vec3(d,d,d) ,vec3(-dn,dn,dn)) ; \n    float sd2 = plane(p,vec3(d,-d,-d) ,vec3(dn,-dn,dn)) ;\n \tfloat sd3 = plane(p,vec3(-d,d,-d) ,vec3(dn,dn,-dn)) ;\n \tfloat sd4 = plane(p,vec3(-d,-d,d) ,vec3(-dn,-dn,-dn)) ;\n  \n    //max intersects shapes\n    mv.signedDistance = max(max(sd1,sd2),max(sd3,sd4));\n  return mv; \n}\n\n\nMapValue octahedron(vec3 p,  float d, Material m) {\n \n  //The octahedron is the intersection of two dual tetrahedra.  \n  MapValue mv = tetrahedron(p,d,m);\n  MapValue mv2 = tetrahedron(-p,d,m);\n  \n  mv = intersectObjects(mv,mv2);\n    \n  return mv; \n}   \n\nMapValue alternativeOctahedron(vec3 p,  float d, Material m) {\n   //Alternative construction of octahedran.\n   //The same as for a terahedron, except intersecting double planes (the volume between two paralell planes). \n    \n    MapValue mv;\n    mv.material = m;\n \n    float dn =1.0/sqrt(3.0);\n    float sd1 = doubleplane(p,vec3(d,d,d) ,vec3(-dn,dn,dn)) ; \n    float sd2 = doubleplane(p,vec3(d,-d,-d) ,vec3(dn,-dn,dn)) ;\n \tfloat sd3 = doubleplane(p,vec3(-d,d,-d) ,vec3(dn,dn,-dn)) ;\n \tfloat sd4 = doubleplane(p,vec3(-d,-d,d) ,vec3(-dn,-dn,-dn)) ;\n    \n    mv.signedDistance = max(max(sd1,sd2),max(sd3,sd4));\n  return mv; \n}   \n\n\n\nMapValue dodecahedron(vec3 p,  float d, Material m) {\n  \n    MapValue mv;\n    mv.material = m;\n\n    //Some vertices of the icosahedron.\n    //The other vertices are cyclic permutations of these, plus the opposite signs.\n    //We don't need the opposite sign because we are using double planes - two faces for the price of one. \n    vec3 v = normalize(vec3(0.0,1.0,PHI));\n    vec3 w = normalize(vec3(0.0,1.0,-PHI));\n       \n    //The dodecahedron is dual to the icosahedron. The faces of one corespond to the vertices of the oyther.\n    //So we can construct the dodecahedron by intersecting planes passing through the vertices of the icosohedran.\n    float ds = doubleplane(p,d*v,v);\n    //max == intesect objects\n    ds = max(doubleplane(p,d*w,w),ds); \n\n    ds = max(doubleplane(p,d*v.zxy,v.zxy),ds);\n    ds = max(doubleplane(p,d*v.yzx,v.yzx),ds);\n\n\n    ds = max(doubleplane(p,d*w.zxy,w.zxy),ds);\n    ds = max(doubleplane(p,d*w.yzx,w.yzx),ds);\n    \n    mv.signedDistance = ds;\n  \n       \n    return mv; \n}   \n\n\nMapValue icosahedron(vec3 p,  float d, Material m) {\n  \n  \tMapValue mv;\n  \tmv.material = m;\n  \tfloat h=1.0/sqrt(3.0);\n    \n    \n    //Same idea as above, using the vertices of the dodecahedron\n    vec3 v1 = h* vec3(1.0,1.0,1.0);\n    vec3 v2 = h* vec3(-1.0,1.0,1.0);\n    vec3 v3 = h* vec3(-1.0,1.0,-1.0);\n    vec3 v4 = h* vec3(1.0,1.0,-1.0);\n   \n    vec3 v5 = h* vec3(0.0,INV_PHI,PHI);\n    vec3 v6 = h* vec3(0.0,INV_PHI,-PHI);\n    \n    float ds = doubleplane(p,d*v1,v1);\n    //max == intesect objects\n \tds = max(doubleplane(p,d*v2,v2),ds);\n    ds = max(doubleplane(p,d*v3,v3),ds); \n    ds = max(doubleplane(p,d*v4,v4),ds);\n    ds = max(doubleplane(p,d*v5,v5),ds); \n    ds = max(doubleplane(p,d*v6,v6),ds);\n    \n    //plus cyclic permutaions of v5 and v6:\n    ds = max(doubleplane(p,d*v5.zxy,v5.zxy),ds); \n    ds = max(doubleplane(p,d*v5.yzx,v5.yzx),ds);\n    ds = max(doubleplane(p,d*v6.zxy,v6.zxy),ds);\n    ds = max(doubleplane(p,d*v6.yzx,v6.yzx),ds);\n    \n    mv.signedDistance = ds;\n    \n  \treturn mv;\n}   \n\n//////////////////////////////////////////////////////////////\n\n\nvoid setMaterials() {\n    float t  = iTime;\n    float s = 0.4*(1.0+sin(t));\n    vec3 specular = vec3(0.3); \n    float shininess = 16.0;\n    blackMat = Material(LightColor(vec3(0.0,0.0,0.01),vec3(0.1,0.1,0.1)) ,35.0,0.75,1.0,1.0);\n    whiteMat = Material(LightColor(vec3(1.0),vec3(1.0)) ,shininess ,0.75,1.0,1.0);\n    blueMat = Material(LightColor(vec3(0.3,0.3,0.75),vec3(0.3,0.3,1.0)) ,shininess ,0.75,1.0,1.0);\n    yellowMat = Material(LightColor(vec3(0.8,0.8,0.4),vec3(0.9,0.9,0.2)) ,shininess ,0.75,1.0,1.0);\n}\n\n\nvec3 orbit(float t){\n    return vec3(sin(t),0.0,cos(t));\n}\n\n/////////////////////Map the sceane/////////////////////////////////////////////\n\n\nMapValue map(vec3 p){\n   float t  = iTime;\n   mat3 R = rotationMatrix(orbit(0.2*t),0.67*t);\n   float r = 0.8; \n    \n   MapValue objects = sphere(p,0.3,blackMat);\n   \n   // Add the five platonic solids\n   objects = addObjects(objects,cube( R*(p + r*orbit(t)),0.25,whiteMat));\n   objects = addObjects(objects,tetrahedron(R*(p + r*orbit(t+ TWO_PI*0.2)),0.25,whiteMat));\n   objects = addObjects(objects,octahedron(R*(p + r*orbit(t+ TWO_PI*0.4)),0.35,whiteMat));\n   objects = addObjects(objects,dodecahedron(R*(p + r*orbit(t+ TWO_PI*0.6)),0.25,whiteMat));\n   objects = addObjects(objects,icosahedron(R*(p + r*orbit(t+ TWO_PI*0.8)),0.25,whiteMat));\n   \n   //add a floor and a cieling\n   objects = addObjects(objects,xzPlane(p,-0.75,blueMat));\n   objects = addObjects(objects,xzPlane(-p,-2.0,yellowMat));\n    \n   return objects;\n}\n\n\n///////////////////////////Raytracing////////////////////////////////////////\n\n\nvec3 calculateNormal(vec3 p) {\n    float epsilon = 0.001;\n    \n    vec3 normal = vec3(\n                       map(p +vec3(epsilon,0,0)).signedDistance - map(p - vec3(epsilon,0,0)).signedDistance,\n                       map(p +vec3(0,epsilon,0)).signedDistance - map(p - vec3(0,epsilon,0)).signedDistance,\n                       map(p +vec3(0,0,epsilon)).signedDistance - map(p - vec3(0,0,epsilon)).signedDistance\n                       );\n    \n    return normalize(normal);\n}\n\nTrace castRay(in Ray ray, float maxDistance){\n    float dist = 0.01;\n    float presicion = 0.001;\n\tvec3 p;\n    MapValue mv;\n    bool hit = false;\n    for(int i=0; i<64; i++){\n    \tp = rayPoint(ray,dist);\n       \tmv = map(p);\n         dist += 0.5*mv.signedDistance;\n        if(mv.signedDistance < presicion)\n        {\n          hit = true; \n            break;\n        } \n         if(dist>maxDistance) break;\n       \n    }\n    return Trace(dist,p,p,ray,ray,mv.material,hit);\n}\n\nTrace traceRay(in Ray ray, float maxDistance) {\n    Trace trace = castRay(ray,maxDistance);\n    trace.normal = calculateNormal(trace.p);\n    trace.reflection = Ray(trace.p,reflect(ray.direction, trace.normal));\n\n    return trace;\n}\n\nfloat castShadow(in Ray ray, float dist){\n    Trace trace = castRay(ray,dist);\n    float maxDist = min(1.0,dist);\n    float result = trace.dist/maxDist;\n   \n    return clamp(result,0.0,1.0);\n}\n\nRay cameraRay(vec3 viewPoint, vec3 lookAtCenter, vec2 p , float d){ \n\tvec3 v = normalize(lookAtCenter -viewPoint);\n    \n    vec3 n1 = cross(v,vec3(0.0,1.0,0.0));\n    vec3 n2 = cross(n1,v);  \n        \n    vec3 lookAtPoint = lookAtCenter + d*(p.y*n2 + p.x*n1);\n                                    \n    Ray ray;\n                    \n    ray.origin = viewPoint;\n   \tray.direction =  normalize(lookAtPoint - viewPoint);\n    \n    return ray;\n}\n\nvec3 diffuseLighting(in Trace trace, vec3 lightColor,vec3 lightDir){\n    float lambertian = max(dot(lightDir,trace.normal), 0.0);\n  \treturn  lambertian * trace.material.color.diffuse * lightColor; \n}\n\n\n\nvec3 cookTorranceSpecularLighting(in Trace trace, vec3 lightColor,vec3 L){\n    //https://en.wikipedia.org/wiki/Specular_highlight#Cook.E2.80.93Torrance_model\n    //https://renderman.pixar.com/view/cook-torrance-shader\n    \n    \n    vec3 V = -trace.ray.direction;\n\n    vec3 H = normalize(L + V);\n    \n    float NdotH = dot(trace.normal, H);\n    float NdotV = dot(trace.normal, V);\n    float VdotH = dot(V ,H );\n    float NdotL = dot(trace.normal , L);\n    \n    float lambda  = 0.25;\n    float F = pow(1.0 + NdotV, lambda);\n    \n    float G = min(1.0,min((2.0*NdotH*NdotV/VdotH), (2.0*NdotH*NdotL/VdotH)));\n    \n    \n   // Beckmann distribution D\n    float alpha = 5.0*acos(NdotH);\n    float gaussConstant = 1.0;\n\tfloat D = gaussConstant*exp(-(alpha*alpha));\n    \n    \n    float c = 1.0;\n    float specular = c *(F*D*G)/(PI*NdotL*NdotV);\n    \n    \n    return specular * trace.material.color.specular * lightColor;\n}\n\n\n\n\nvec3 pointLighting(in Trace trace, PointLight light){\n    vec3 lightDir = light.position - trace.p;\n\tfloat d = length(lightDir);\n  \tlightDir = normalize(lightDir);\n   \n  \tvec3 color =  diffuseLighting(trace, light.color.diffuse, lightDir);\n\n    color += cookTorranceSpecularLighting(trace, light.color.specular, lightDir);\n\n    float  attenuation = 1.0 / (1.0 +  0.1 * d * d);\n    float shadow = castShadow(Ray(trace.p,lightDir),d);\n    color *= attenuation*shadow;\n    return  color;\n}\n\nvec3 directionalLighting(Trace trace, DirectionalLight light){\n\n    vec3 color =  diffuseLighting(trace, light.color.diffuse, light.direction);\n    \n    color += cookTorranceSpecularLighting(trace, light.color.specular, light.direction);\n    \n    float shadow = castShadow(Ray(trace.p,light.direction),3.0);\n    color *= shadow;\n    return  color;\n}\n\n\nvoid setLights(){\n  \tfloat  time = iTime;\n    vec3 specular = vec3(1.0);\n  \tlight1 = PointLight(vec3(cos(1.3*time),1.0,sin(1.3*time)),LightColor( vec3(1.0),specular));\n  \tlight2 = PointLight(vec3(0.7*cos(1.6*time),1.1+ 0.35*sin(0.8*time),0.7*sin(1.6*time)),LightColor(vec3(1.0),specular)); \n} \n\n\nvec3 lighting(in Trace trace){\n    vec3 color = vec3(0.01,0.01,0.2);//ambient color     \n\tcolor += pointLighting(trace, light1);\n\tcolor += pointLighting(trace, light2) ;\n\n    return color;\n}\n\nfloat rayDistance(Ray r,vec3 p){\n    vec3 v = r.origin - p;\n    return length(v - dot(v,r.direction)*r.direction);\n}\n\nvec3 render(vec2 p){\n    vec3 viewpoint = vec3(-1.0,1.9,-2.3);\n    \n    vec3 lookAt = vec3(0.0,-0.15,0.0);\n    \n  \tRay ray = cameraRay(viewpoint,lookAt,p,2.4);\n    vec3 color = vec3(0.0);\n    float frac = 1.0;\n   \n    float d = 0.0;\n    float maxDistance = 7.0;\n    for(int i = 0; i<2; i++) {\n        Trace trace = traceRay(ray,maxDistance);\n        \n \t\tif(i==0) d = trace.dist;\n        maxDistance -= trace.dist;\n    \tcolor += lighting(trace)*(1.0 - trace.material.mirror)*frac;\n        if(!trace.hit) break;\n        \n        frac *= trace.material.mirror;\n        if(frac < 0.1 || maxDistance<0.0) break;\n        ray = trace.reflection;\n    }\n   \t\n    \n   \n   \treturn color;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n    \n  \tsetLights();\n    setMaterials();\n    \n   \tvec3 colorLinear =  render(p);\n    float screenGamma = 2.2;\n    vec3 colorGammaCorrected = pow(colorLinear, vec3(1.0/screenGamma));\n\tfragColor = vec4(colorGammaCorrected,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtV3Dy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XddXDM", "name": "wave chessboard 8bit effect", "author": "patu", "description": "Playing with code size reducion. \nIs Fabrice here to reduce ascii count?", "tags": ["demosceneeffect2d"], "likes": 5, "viewed": 610, "date": "1478132967", "time_retrieved": "2024-06-20T18:45:08.763465", "image_code": "/**\n *\n * Chrome extension for Shadertoy:\n * \n * http://bit.ly/shadertoy-plugin \n * \n */\n\nvoid mainImage( out vec4 C, in vec2 R )\n{\n\tR = ceil((R.xy / iResolution.xy - .5) * 99.) / 99. + cos(iTime) * .2;\n    R.x *= 1. + pow(sin(iTime + R.y * 2.), 4.);\n    //C -= C; // mac fix - clear color;\n    R *= sin(R * 30.);\n    C += -C + ceil(R.x * R.y) * .2;\n}\n\n//190\n//178\n//176\n//173", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XddXDM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xl3SR7", "name": "SphereRayMarch", "author": "mmostajab", "description": "ray marching of a simple sphere\n\nIt also supports virtual reality.", "tags": ["raycasting", "vr"], "likes": 1, "viewed": 214, "date": "1478614859", "time_retrieved": "2024-06-20T18:45:09.254399", "image_code": "vec4 back_color(in vec2 fragCoord2d){\n    int n = int(fragCoord2d.x / 10.0 + fragCoord2d.y / 10.0);\n    if(n - 2 * (n / 2) == 0)\n        return vec4(1.0);\n    return vec4(0.0);\n}\n\nbool intersect_sphere(in vec3 worldSphereCenter, in float radius, in vec3 rayOrigin, in vec3 rayDir, inout vec3 normal){\n    \n    vec3 sphereCenter = worldSphereCenter - rayOrigin;\n    \n    float a = length(rayDir) * length(rayDir);\n\tfloat bPrime = -dot(sphereCenter, rayDir);\n\tfloat c = length(sphereCenter) * length(sphereCenter) - radius * radius;\n\tfloat deltaPrime  = bPrime * bPrime - a * c;\n\n\tif(deltaPrime >= 0.0){\n\t\tfloat t = -bPrime - sqrt(deltaPrime);\n\t\tvec3 intersect_point = t * rayDir;\n\t\tnormal = normalize(intersect_point - sphereCenter);\n\n        return true;\n\t} \n    \n    return false;\n    \n}\n\nbool intersect_backgroundPlane(in vec3 worldPlaneCenter, in vec3 worldPlaneNormal, in vec3 rayOrigin, in vec3 rayDir, inout vec3 normal, inout vec3 checker_color) {\n   float t = dot(worldPlaneNormal, worldPlaneCenter - rayOrigin) / dot(worldPlaneNormal, rayDir);\n    if(t >= 0.0){\n        normal = worldPlaneNormal;\n        float distToPlaneCenter = length(worldPlaneCenter - rayOrigin + t * rayDir);\n        int randColorBand = int(distToPlaneCenter);\n        if(randColorBand - 2 * (randColorBand / 2) == 0){\n            checker_color = vec3(1, 1, 1);\n        } else {\n            checker_color = vec3(0, 0, 0);\n        }\n        return true;\n    } else {\n        return false;\n    }\n}\n\nvoid createScene(in vec3 rayOrigin, in vec3 rayDir, out vec4 fragColor){\n    const vec3 objColor = vec3(0.5, 0.2, 0.4);\n    const vec3 lightDir = normalize(vec3(1, 1, 1));\n    \n    float animLength = 6.14;\n    float t = iTime - float(int(iTime / animLength)) * animLength;\n    \n    const float radius = 100.0;\n    vec3 sphereCenter = vec3(iResolution.xy / 2.0 + vec2(0.0, 100.0 * sin(t)), -50.0);\n    \n    \n    vec3 normal = vec3(1.0);\n    \n    vec3 output_color;\n    \n    if(intersect_sphere(sphereCenter, radius, rayOrigin, rayDir, normal)){\n        fragColor = vec4(objColor * dot(normal, lightDir), 1.0);\n    }\n    else if(intersect_backgroundPlane(vec3(iResolution.xy / 2.0, -50.0), vec3(0, 0, 1), rayOrigin, rayDir, normal, output_color)){\n        fragColor = vec4(output_color, 1.0);\n    }\n\t//else fragColor = back_color(fragCoord2d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord2d )\n{\n    // Playing around with the mouse button.\n    if(length(fragCoord2d - iMouse.xy) < 10.0){\n        fragColor = vec4(1, 0, 0, 1);\n        return;\n    }\n    \n    const float viewPlaneDistance = 200.0;\n    vec3 rayOrigin = vec3(iResolution.xy / 2.0, 200.0);\n    vec3 fragCoord = vec3(fragCoord2d, rayOrigin.z - viewPlaneDistance);\n    vec3 rayDir = normalize(fragCoord - rayOrigin);\n    \n    \n    createScene(rayOrigin, rayDir, fragColor);\n\n    \n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord2d, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    float animLength = 6.14;\n    float t = iTime - float(int(iTime / animLength)) * animLength;\n    \n    const vec3 objColor = vec3(0.5, 0.2, 0.4);\n    const vec3 lightDir = normalize(vec3(4, 2, 2));\n    const float viewPlaneDistance = 40.0;\n    \n    createScene(fragRayOri, fragRayDir, fragColor);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xl3SR7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xl3SWN", "name": "Dornia Straight v0.5 (WIP)", "author": "ttoinou", "description": "Done optimizing ! Working on pretty text effects like in Photoshop, Transfer/step & color mixing functions avalaible with macros (click to see bump transfer func).\nTry to turn shadow on line31 !\n\nBased on https://www.shadertoy.com/view/ll3SD8 ", "tags": ["text", "shadow", "effect", "stroke", "glow", "edge", "font"], "likes": 7, "viewed": 538, "date": "1479512727", "time_retrieved": "2024-06-20T18:45:13.721199", "image_code": "/*\n * Dornia Straight\n *\n *      - Shader porportional font with\n *               accents, ponctuations,\n *               maths and others symbols\n *      - Segment based characters\n *      - All char fit in at a most a vec3,\n *          currently ~80 chars in 56 vec4\n *      - => Chars can be \"written\" from a texture fetch !\n *         Otherwise, chars are computed & optimized\n *         at compilation...\n *      - Using 23 bits of float precision (mantissa)\n *      - Easy creation of new characters\n *      - Easy geometry & text effects\n *         (stroke, edge, glow, shadow, bevel...)\n * \n *              sodorny\n *\n *   v0.5     18-11-2016\n */\n\n// Previous version\n// https://www.shadertoy.com/view/ll3SD8\n\n// Original from\n// https://www.shadertoy.com/view/XdXGRB\n\n// issue with box corners on complicated chars\n#define CORNERS_ROUND\n//#define ENABLE_SHADOW\n\n\n#define SUBX  5.\n#define SUBY  9.\n#define SUBGRID  SUBX * SUBY\n\n#define SUBPLUS  3.\n#define SUBM   49.\n#define SUBM2  2401.\n#define SUBM3  117649.\n\n// could be const\n// but doesn't change\n// compilation time\nvec4 c_ab =vec4(4932900,1746,4932900,2010);\nvec4 c_ic =vec4(-7859403,2706577,43,5393700);\nvec4 c_de =vec4(5393700,5,2993700,1554);\nvec3 c_q =vec3(-15624999,591700,45);\nvec4 c_fg =vec4(103395,1246,-15562557,2054);\nvec4 c_hk =vec4(109291,90,62035,2238);\nvec3 c_jn =vec3(-15578057,100571,5355300);\nvec4 c_ls =vec4(-7874894,90,4193200,2054);\nvec4 c_mo =vec4(5355300,57330,5355300,41);\nvec4 c_pz =vec4(-15624999,130900,41,5393892);\nvec4 c_tr =vec4(-7874951,105253,1148,61095);\nvec4 c_Bu =vec4(2377187,5274090,2874087,3051300);\nvec4 c_yv =vec4(-15624999,61055,100651,62153);\nvec4 c_wx =vec4(3051300,57330,2943451,41);\nvec4 c_AD =vec4(5306300,61054,4730167,4454);\nvec4 c_EF =vec4(5392700,51646,98495,1148);\nvec4 c_GH =vec4(5392700,1152,2472639,5306235);\nvec4 c_IJ =vec4(353193,5392689,353193,5157391);\nvec4 c_KCL =vec4(109079,2010,5392700,110055);\nvec4 c_MO =vec4(643558,45,698300,1);\nvec4 c_PQ =vec4(130900,41,698300,5373439);\nvec4 c_RS =vec4(2953320,5347048,1308648,4931248);\nvec4 c_Tic =vec4(353193,43,36173,2130);\nvec4 c_WX =vec4(5351438,5,4825815,5);\nvec4 c_YZ =vec4(104371,268,5392892,58702);\nvec4 c_01 =vec4(4931900,2761151,103401,2246);\nvec4 c_34 =vec4(4931900,61054,61055,2215);\nvec4 c_78 =vec4(98687,1246,4931900,2991647);\nvec4 c_25 =vec4(2530900,2246,2991700,2054);\nvec4 c_69 =vec4(5392700,1054,591700,2054);\nvec4 c_exclV =vec4(-7874894,4825129,41,14113);\nvec4 c_codo =vec4(-11731134,1846,-11731134,1650);\nvec4 c_qubk =vec4(475703,3938385,105350,2206);\nvec4 c_ddap =vec4(-7856144,3295072,28,590);\nvec4 c_dcosl =vec4(-7856144,3295072,32,2014);\nvec4 c_bos8 =vec4(3648845,3913645,61054,5397600);\nvec4 c_asst6 =vec4(1883370,2713140,2354466,3913656);\nvec4 c_udor =vec4(-9801169,2246,472656,44);\nvec4 c_htbc =vec4(3059870,4254602,91728,4927000);\nvec4 c_aoeN =vec4(-7849922,2993700,1554,696380);\nvec4 c_ccdU =vec4(-11749999,4192700,4928469,698300);\nvec4 c_andm =vec4(850783,3693432,3634807,1246);\nvec4 c_frq =vec4(85177,80275,75569,80471);\nvec4 c_qu =vec4(31558,36460,26756,31658);\nvec4 c_par =vec4(3217737,2243,3457833,2047);\nvec4 c_cur =vec4(2631893,109935,2867187,100331);\nvec4 c_equ =vec4(590,690,3059870,30);\nvec4 c_dipl =vec4(3059870,4374652,2472259,25);\nvec4 c_dicr =vec4(3648845,15,1295913,4201761);\nvec4 c_prgt =vec4(119663,144700,85652,75667);\nvec4 c_ceci =vec4(-7832557,3987700,-7812557,36173);\nvec4 c_thlt =vec4(-7832621,3987700,105483,85079);\nvec4 c_gtlt =vec4(75667,2044,85079,2236);\nvec3 ch_dia =vec3(-7812557,1647686,14);\nvec3 ch_idia =vec3(-7859403,2706527,1680743);\nvec4 c_acc =vec4(-7812557,688,-7812557,592);\n\n\n/*\n * Dornia Straight Font Properties \n */\n\n#define PI 3.14159265359\n\n//#define UNPACK1(A) floor(mod(A,SUBM))\n#define UNPACK1(A) (mod(A,SUBM))\n#define UNPACK2(A) floor(mod(A/SUBM,SUBM))\n#define UNPACK3(A) floor(mod(A/SUBM2,SUBM))\n#define UNPACK4(A) floor(A/SUBM3)\n\n#define FONT_SIZE 0.05\n#define FONT_SPACING 1.\n#define FONT_LENGTH 0. // iTime > 2. ? (cos(iTime/2.*PI)*.5+.5)*1. : 0.\n\n#define STROKEW_REGULAR 0.7 // (vec2(.5,0.).xy).x\n#define STROKEW_BOLD (STROKEW_REGULAR+1.)\n\nfloat font_size = FONT_SIZE;\nfloat font_spacing = FONT_SPACING;\nfloat font_weight = STROKEW_REGULAR;\nfloat font_length = FONT_LENGTH;\nfloat font_aspect = 1.;//(cos(iTime/2.*PI)*.5+.5)*2.;\nfloat font_line_height = 1.;\n\nvec4  font_coord; // current pixel coord in relative space, zw for shadow coord\nvec3  font_cursor;\n// cursor for current char, includes super & sub script\n// cursor.z is current font_size\nvec3  font_cursorChar;\nvec3  font_cursorOrigin; // beginning of a new line\nvec4  font_draw;\n\n\n\n/*\n * DorniFont23 Drawing FSM \n */\n\n#define PROPMAX         250.\n#define UNPACKPROP(x,n,m)  (mod(floor(x),PROPMAX)/PROPMAX*(m - n)+n)\n#define UNPACKCHARSPACE(x)  UNPACKPROP(-x,-.3,1.)\n#define UNPACKCURSORZ(x)    UNPACKPROP(-x/PROPMAX,-1.,0.)\n#define UNPACKVSHIFT(x)     UNPACKPROP(-x/(PROPMAX*PROPMAX),-2.,2.)\n\nfloat char_space = 1.;\nfloat vertical_shift = 0.;\n\nfloat space_width(){\n    return font_aspect*font_cursorChar.z*3./7.*font_spacing*mix(1.,font_weight,0.2);\n    //return font_aspect*font_cursorChar.z*3./5.*font_spacing;\n}\n\nvoid setScript(int i){\n    if( i == 0 ){\n        // real font space taking into account baseline\n        // and a margin\n        font_cursorChar.z = font_size*9./7. * 6.5/7.;//  *5./7.*1.6  * 6.5/7.;\n    }\n}\n\nfloat count = 0.;\nvoid setCursorChar(){\n\t//font_cursorChar.xy = font_coord.xy;\n\t//font_cursorChar.y -= font_cursor.y;\n    //font_cursorChar.xy = font_coord - vec2( (count++)/3.,0.3) - font_cursor.xy;\n    \n    \n\tfont_cursorChar.xy = font_cursor.xy;\n    \n    // add baseline\n    font_cursorChar.y += font_cursorChar.z*2./5.;\n    \n    // add margin space\n    font_cursorChar.x += font_cursorChar.z/9.;// /28. + font_weight*font_size/8.;\n    //\n    font_cursorChar.x += space_width()*font_cursor.z;\n    \n    //font_cursorChar.xy = font_coord - font_cursorChar.xy;\n    \n    //font_cursorChar.z  = font_size*5./7.;\n\t//pos.x = pos.x - font_cursor.x + font_spacing*font_aspect*font_cursor.z;\n\t//pos.x -= max(font_spacing*font_aspect*font_cursor.x - font_cursor.z,0.5);\n\n}\n\nvoid resetFont(vec2 line_beginning){\n\tfont_cursor.xy = line_beginning;\n    font_cursor.z = 0.;\n    font_cursorOrigin = font_cursor;\n    font_draw = vec4(0.);\n    setScript(0);\n    setCursorChar();\n}\n\nvec2 nearestVec(vec2 v,vec2 w,vec2 p){\n    w -= v;\n    //w *= 0.666; // for animation\n    v -= p;\n    return v + clamp( -dot(v, w) / (dot(w,w) + font_length*font_size*.06) , 0. , 1. ) * w;\n}\n\nfloat segmentDistance(vec2 v)\n{\n    #ifdef CORNERS_ROUND\n   \t\treturn length(v);\n    #else\n   \t\treturn max(abs(v.x),abs(v.y));\n    #endif\n    \n\t//float power = mix(0.1,5.,iMouse.x/iResolution.x);\n    \n   \t//return pow(pow(abs(v.x),power)+pow(abs(v.y),power),1./power);\n    \n    //float angle = 0.2*PI;\n    //v *= mat2(cos(angle),sin(angle),-sin(angle),cos(angle));\n    /*\n    float q = length(w);\n    if( q > 0. ){\n        float k = dot(v,w);\n        v.y = dot(v,vec2(-w.y,w.x))/q;\n        v.x = k/q;\n    }\n    */\n   \t//return abs(v.x)+abs(v.y);\n    //v = abs(v);\n   \t//return v.x+v.y + 2.*sqrt( v.x*v.y );\n    \n   \t//return length(v) + font_length*font_size*0.06;\n}\n\n\nfloat distance2ToSegment(vec2 v, vec2 w, vec2 p)\n{\n    w -= v;\n    v -= p;\n    v += clamp( -dot(v, w) / (dot(w,w) + font_length*font_size*.06) , 0. , 1. ) * w;\n    #ifdef CORNERS_ROUND\n   \t\treturn dot(v,v);\n    #else\n   \t\treturn max(abs(v.x),abs(v.y));\n    #endif\n    \n}\n\nfloat vertexCount; // 0, 1 or 2\nvec4 vertexAB;\nvec2 vertexC;\n\nfloat currentDist = -1.;\nfloat currentDistTmp = -1.;\nfloat currentDist2 = -1.;\nfloat currentDistTmp2 = -1.;\nfloat nearestThickness;\nfloat nearestThickness2;\nfloat distSum;\nvec4 nearestAB;\nvec4 nearestCD;\n\n\nvoid resetSegments(){\n    currentDist = -1.;\n    currentDist2 = -1.;\n    distSum = 0.;\n    font_cursor.z = 0.;\n    char_space = 1.;\n    vertical_shift = 0.;\n}\n\nvoid pushSegment(){\n    // everything here is slowing compilation\n    \n    currentDistTmp = distance2ToSegment(\n        vertexAB.xy,\n        vertexAB.zw,\n        font_coord.xy\n   \t);\n    if( currentDistTmp < currentDist || currentDist == -1. ){\n        currentDist = currentDistTmp;\n        nearestAB = vertexAB;\n        nearestThickness = font_cursorChar.z;\n    }\n    \n    #ifdef ENABLE_SHADOW\n        currentDistTmp2 = distance2ToSegment(\n            vertexAB.xy,\n            vertexAB.zw,\n            font_coord.zw\n        );\n        if( currentDistTmp2 < currentDist2 || currentDist2 == -1. ){\n            currentDist2 = currentDistTmp2;\n            nearestCD = vertexAB;\n            nearestThickness2 = font_cursorChar.z;\n        }\n    #endif\n    \n    distSum += exp(-80.*currentDistTmp/(font_size*font_size));\n}\n\nvoid resetVertex(){\n    vertexCount = 0.;\n}\n\nvoid pushVertex(float v){\n    if( v == 0. ){\n        // restart\n        vertexCount = 0.;\n    } else {\n        // old grid function\n        vertexC = vec2(\n            mod(v-1.,SUBX)/4. * .228 * font_aspect ,\n            0.350877 - (floor((v-1.)/SUBX)+2.*vertical_shift)/12.\n        ) * font_cursorChar.z + font_cursorChar.xy;\n        \n        if( mod(vertexCount,2.) < 1. ){\n            vertexAB.xy = vertexC;\n        } else {\n            vertexAB.zw = vertexC;\n        }\n        \n        // draw segment if available\n        if( vertexCount > 0. ){\n            pushSegment();\n        }\n        \n        vertexCount++;\n    }\n}\n\nvoid _o4(in float A) \n{\n    pushVertex(UNPACK1(A));\n    pushVertex(UNPACK2(A));\n    pushVertex(UNPACK3(A));\n    pushVertex(UNPACK4(A));\n}\n\nvoid space()\n{\n\tfont_cursor.x += space_width();\n}\n\nvoid newline()\n{\n\tfont_cursor.x = font_cursorOrigin.x;\n\tfont_cursor.y -= font_size*font_line_height*8./5.*.9;\n}\n\nvec2 polar(float radius,float angle){\n    return radius*vec2(cos(angle),sin(angle));\n}\n\n// xy is for char segment\n// zw for char's shadow segment\nvec4 nearest;\nvec2 nearestDist;\n\nvoid textOutput()\n{\n    nearest.xy = nearestVec(nearestAB.xy,\n                        nearestAB.zw,\n                        font_coord.xy)/nearestThickness;\n    nearestDist.x = segmentDistance(nearest.xy);\n    \n    nearest.zw = nearestVec(nearestCD.xy,nearestCD.zw,font_coord.zw)/nearestThickness2;\n    nearestDist.y = segmentDistance(nearest.zw);\n    \n}\n\nfloat firstChar;\n\nvoid _ch_begin(in float c){\n    firstChar = c;\n    \n    if( c < 0. ){\n        char_space = UNPACKCHARSPACE(c);\n        font_cursor.z = UNPACKCURSORZ(c);\n    \tvertical_shift = UNPACKVSHIFT(c);\n    }\n    \n    // compute here font_coord.zw\n    // if the shadow direction\n    // depends on the coord\n    \n    setCursorChar();\n    resetVertex();\n    \n    if( c >= 0. ){\n    \t_o4(c);\n    }\n}\n\nvoid _ch_end(){\n\tfont_cursor.x += char_space*space_width();\n    \n    if( firstChar < 0. ){\n        font_cursor.z = 0.;\n        char_space = 1.;\n        vertical_shift = 0.;\n    }\n}\n\nvoid _ch4(in float c){\n    _ch_begin(c);\n    _ch_end();\n}\n\nvoid _ch8(in vec2 a){\n    _ch_begin(a.x);\n    _o4(a.y);\n    _ch_end();\n}\n\nvoid _ch16(in vec3 a){\n    _ch_begin(a.x);\n    _o4(a.y);\n    _o4(a.z);\n    _ch_end();\n}\n\n#define _bold     font_weight = STROKEW_BOLD;\n#define _reg      font_weight = STROKEW_REGULAR;\n#define textBegin resetSegments();\n#define textEnd   textOutput();\n\n#define _sp space();\n#define _nl newline();\n\n/*\n * Color mix functions\n */\n\n// built in\n// vec4 mix(vec4 a,vec4 b,float t)\n\nvec4 add(vec4 a,vec4 b,float t){\n    return a + b*t;\n}\n\n/*\n * Prebuilt style functions\n */\n\nfloat Stroke(float width, float border){\n    return clamp( 1. -\n      max( nearestDist.x-font_weight/24.*width , 0. )\n         / (1e-8+border) * nearestThickness\n    , 0. , 1. );\n}\n\nvec3 StrokeAndEdge(float width, float edge, float border){\n    float x = Stroke(width,border);\n    float y = (1.-x)*clamp( 1. -\n      max( nearestDist.x - font_weight/24.*width - edge*font_weight , 0. )\n          / (1e-8+border) * nearestThickness\n     ,0. ,1. );\n    \n    return vec3( x,\n      y,\n      x+y\n    );\n}\n\nfloat Glow(float spread){\n    //return pow(mix(distSum,exp(-20.*nearestDist.x),.3)/2.,.3) *(1. - font_length);\n    \n    //return pow( smoothstep( 0. , 1. , 1. - nearestDist.x*6. ) , .5 );\n    return 1. / ( .5 + nearestDist.x/spread );\n    //return exp( -64.*nearestDist.x*nearestDist.x*nearestDist.x );\n}\n\nfloat Shadow(float spread,float size){\n    float k = max(nearestDist.y-size,0.);\n    return exp(-10.*k*k/(1e-8 + spread));\n}\n\n/*\n * Transfer functions [0,1]->[0,1]\n */\n\n#define linear(x) (x)\n#define smooth(x) (smoothstep(0.,1., (x) ))\n#define fast(x)   (sqrt(x))\nfloat slow(float x){\n    return x*x;\n}\nfloat bump(float x){\n    return 4.*x*(1. - x);\n}\n#define fast_bump(x) fast(bump(x))\n#define slow_bump(x) slow(bump(x))\n\n\n#define textStyle(thing,func,transfer,color) font_draw = func(font_draw,color,transfer(thing)*color.a);\n// mix with 2 colors for stroke & edge for example\n#define textStyle2(thing,func,transfer,colorA,colorB) { vec3 _mix_ = thing; vec4 _col_ = mix(colorA,colorB,_mix_.y+(1. - _mix_.z)); font_draw = func(font_draw,_col_,transfer(_mix_.z)*_col_.a*_mix_.z); }\n\n\n    //r.y = pow((distSum+4.*exp(-40.*nearestDist.x*nearestDist.x))/4.,1.5) *(1. - font_length);\n    \n    //r.y = exp(-40.*dot(a,a) );\n    \n    //r.y = (distSum*exp(-80.*r.z*r.z))*(1. - font_length);\n    \n    //r.y = exp(-80.*(currentDist)/(thickness*thickness));\n    //r.y = 1. - abs(r.x);\n    //r.y = exp(-1000000.*r.x);\n    \n    //vec4 col = mix(font_glow_color*r.y,font_stroke_color,clamp(r.x,0.,1.));\n    \n        \n    //previous += font_glow_color*font_glow_color.a*r.y;\n    \n    //float shadow = clamp( 1. - distance(a,vec2(.08))*8. , 0. , 1.);\n    //float shadow = clamp( 1. - abs( dot( a ,  ) )*4. , 0. , 1.);\n    //vec2 w = nearestA - nearestB;\n    //w = vec2(-w.y,w.x);\n    \n    //vec2 w = a - nearestCursorChar.xy;\n    //float shadow = clamp( 1. - abs( dot(w,w)/dot(w,font_shadow_dir) - .1 )*8. , 0. , 1. );\n   \n\n//-----------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 coord )\n{\n    vec2 uv = coord.xy/iResolution.xy;\n    fragColor = vec4(.8 - uv.x*.5,.7 - uv.y*.6,0.75 - sqrt(uv.x*uv.y)*.6,1.);\n\n\n    font_line_height = 0.9;\n    font_size = .1;\n    resetFont(vec2(.05, .8));\n    font_draw = fragColor;\n    \n    font_coord.xy = coord.xy/iResolution.y;\n    //font_coord.zw = font_coord.xy + polar( .2 , -.4 )*font_size;\n    font_coord.zw = font_coord.xy - (iMouse.xy/iResolution.xy-vec2(.5,.5))*font_size;\n\n    textBegin\n\n\t_ch8( c_AD.zw ); _ch8( c_de.zw ); _ch8( c_acc.xy ); _ch8( c_ls.zw );  _sp _ch4( c_aoeN.w ); _ch8( c_mo.zw ); _ch8( c_de.zw ); _ch16( ch_dia ); _ch8( c_ls.xy );  _sp _ch8( c_mo.zw ); _ch4( c_Bu.w ); _ch8( c_acc.xy );  _sp _ch4( c_Bu.w ); _ch4( c_jn.z );\n    _sp _ch4( c_pz.w ); _ch8( c_de.zw ); _ch8( c_acc.zw ); _ch16( c_pz.xyz ); _ch8( c_hk.xy ); _ch16( c_yv.xyz ); _ch4( c_tr.w );  _sp _ch8( c_hk.xy ); _ch8( c_ab.xy ); _ch16( ch_idia );  _nl _ch8( c_mo.xy ); _ch8( c_de.zw );  _sp _ch4( c_yv.w );\n    _ch8( c_de.zw ); _ch8( c_ceci.zw ); _ch16( c_tr.xyz );  _sp _ch8( c_de.xy ); _ch8( c_de.zw );  _sp _ch16( c_q.xyz ); _ch8( c_fg.zw ); _ch8( c_ls.xy ); _ch8( c_ab.xy ); _ch16( c_ccdU.xyz ); _ch8( c_mo.zw ); _ch4( c_jn.z ); _ch8( c_ls.zw ); \n    _sp _ch8( c_wx.xy ); _ch4( c_Bu.w ); _ch16( ch_dia ); _ch4( c_tr.w ); _ch8( c_mo.xy ); _ch16( c_ic.xyz ); _ch8( c_de.zw ); _ch4( c_jn.z ); _ch8( c_ls.zw );  _nl  _ch16( c_ic.xyz ); _ch8( c_jn.xy ); _ch8( c_de.zw );  _sp _ch8( c_de.xy );\n    _ch8( c_Tic.zw ); _ch4( c_jn.z ); _ch8( c_de.zw );  _sp _ch8( c_de.xy ); _ch4( c_ddap.w ); _ch8( c_de.zw ); _ch8( c_wx.zw ); _ch16( c_q.xyz );  _ch4( c_Bu.w ); _ch16( c_ic.xyz ); _ch8( c_ls.zw );  _sp _ch4( c_tr.w ); _ch8( c_mo.zw ); _ch8( c_ceci.zw );\n    _ch16( c_tr.xyz ); _ch16( c_ic.xyz ); _ch8( c_ls.zw );  _sp _ch8( c_de.xy ); _ch8( c_de.zw );  _sp _ch8( c_ab.zw ); _ch8( c_mo.zw ); _ch16( c_aoeN.xyz ); _ch4( c_Bu.w ); _ch8( c_fg.xy );  _nl _ch8( c_ab.xy ); _ch4( c_Bu.w );  _sp _ch8( c_hk.zw );\n    _ch16( c_ic.xyz ); _ch4( c_tr.w );  _sp _ch8( c_ab.xy ); _ch8( c_acc.xy );  _sp _ch8( c_ls.xy ); _ch4( c_ddap.w ); _ch8( c_ab.xy ); _ch16( c_yv.xyz ); _ch16( ch_dia );  _sp _ch8( c_de.xy ); _ch4( c_ddap.w ); _ch8( c_ab.xy ); _ch8( c_ceci.zw ); _ch16( c_q.xyz );\n    _ch8( c_fg.zw ); _ch8( c_de.zw );  _sp _ch8( c_mo.xy ); _ch4( c_Bu.w ); _ch8( c_ceci.zw ); _ch4( c_tr.w );  _sp _ch8( c_de.zw ); _ch16( c_tr.xyz );  _sp _ch4( c_ic.w ); _ch8( c_ab.xy ); _ch16( c_aoeN.xyz ); _ch16( c_tr.xyz ); _ch8( c_de.zw ); _ch4( c_tr.w ); _ch8( c_ab.xy );\n    _sp _ch16( c_qubk.xyz ); _ch16( c_exclV.xyz ); \n    _nl _nl _sp _sp _sp _ch8( c_AD.zw ); _ch8( c_mo.zw ); _ch4( c_tr.w ); _ch4( c_jn.z ); _ch16( c_ic.xyz ); _ch8( c_ab.xy );  _sp _ch8( c_RS.zw ); _ch16( c_tr.xyz ); _ch4( c_tr.w ); _ch8( c_ab.xy ); _ch16( c_ic.xyz ); _ch16( c_q.xyz ); _ch8( c_fg.zw );\n    _ch8( c_hk.xy ); _ch16( c_tr.xyz ); \n \n    textEnd\n        \n    float glowCoeff = mix(.1,1.5,cos(iTime/2.)*.5+.5);\n    textStyle(Glow(glowCoeff),mix,smooth,vec4(.9,.6-(1.-uv.y)*.4,.0,.7))\n        \n    if( iMouse.z > .5 ){\n    \ttextStyle(Shadow(.5,.05),mix,bump,vec4(0.,0.,0.,.8))\n    } else {\n    \ttextStyle(Shadow(.5,.05),mix,smooth,vec4(0.,0.,0.,.8))\n    }\n        \n    textStyle2(StrokeAndEdge( 1. , .1 , .05*font_size ),mix,slow,vec4(1.-uv.x,0.,uv.x*.6,1.),vec4(0.,0.,0.,1.))\n    textStyle(Stroke( .3 , .05*font_size ),mix,slow,vec4(1.))\n        \n    \n    // limiter\n    fragColor = font_draw*4.;\n    fragColor = (1.-exp(-fragColor))/(1. + exp(-fragColor));\n\n    // no limiter\n    //fragColor = font_draw;\n}\n\n\n\n/*\n * Character design\n */\n\n/*\n\n#define SUBX  5.\n#define SUBY  9.\n#define SUBGRID  SUBX * SUBY\n#define SUBPLUS  3.\n#define SUBM   49.\n#define SUBM2  2401.\n#define SUBM3  117649.\n\n#define SUB2(x,y) (1. + 2.*x + 2.*y*SUBX)\n\n#define PACK4(A,B,C,D) (A+SUBM*(B+SUBM*(C+SUBM*D)))\n#define p1(a,b,c,d)  PACK4(a,b,c,d)\n#define p2(a,b,c,d,e,f,g,h)  vec2(PACK4(a,b,c,d),PACK4(e,f,g,h))\n#define p3(a,b,c,d,e,f,g,h,i,j,k,l)  vec3(PACK4(a,b,c,d),PACK4(e,f,g,h),PACK4(i,j,k,l))\n#define p4(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p)  vec4(PACK4(a,b,c,d),PACK4(e,f,g,h),PACK4(i,j,k,l),PACK4(m,n,o,p))\n\n// Main points\n\n#define A_   SUB2(0.,0.)\n#define B_   SUB2(1.,0.)\n#define C_   SUB2(2.,0.)\n#define D_   SUB2(0.,1.)\n#define E_   SUB2(1.,1.)\n#define F_   SUB2(2.,1.)\n#define G_   SUB2(0.,2.)\n#define H_   SUB2(1.,2.)\n#define I_   SUB2(2.,2.)\n#define J_   SUB2(0.,3.)\n#define K_   SUB2(1.,3.)\n#define L_   SUB2(2.,3.)\n#define M_   SUB2(0.,4.)\n#define N_   SUB2(1.,4.)\n#define O_   SUB2(2.,4.)\n\n// Middle points for complicated characters\n\n#define AB_  SUB2(0.5,0.) // for S\n#define AD_  SUB2(0.,0.5) // for S\n#define DH_  SUB2(0.5,1.5) // for (\n#define HJ_  SUB2(0.5,2.5) // for (\n#define FH_  SUB2(1.5,1.5) // for (\n#define HL_  SUB2(1.5,2.5) // for (\n#define BE_  SUB2(1.,0.5) // for ()\n#define KN_  SUB2(1.,3.5) // for ()\n#define EH_  SUB2(1.,1.5) // for {}\n#define EI_  SUB2(1.5,1.5) // for &\n#define HK_  SUB2(1.,2.5) // for {}\n#define KM_  SUB2(.5,3.5) // for comma\n#define GH_  SUB2(0.5,2.) // for Z and {\n#define HI_  SUB2(1.5,2.) // for Z and B and }\n#define BC_  SUB2(1.5,0.) // for B and D\n#define NO_  SUB2(1.5,4.) // for B and D\n#define CF_  SUB2(2.,0.5) // for 4, D\n#define FI_  SUB2(2.,1.5) // for B\n#define DG_  SUB2(0.,1.5) // for S\n#define IL_  SUB2(2.,2.5) // for S, B\n#define LO_  SUB2(2.,3.5) // for S, B, D\n#define JK_  SUB2(0.5,3.)// for ;\n#define GJ_  SUB2(0.,2.5) // for =\n#define HI_  SUB2(1.5,2.) // for *\n#define DE_  SUB2(0.5,1.) // for *\n#define EF_  SUB2(1.5,1.) // for *\n#define MN_  SUB2(0.5,4.) // for !=\n#define BF_  SUB2(1.5,0.5) // for !=\n#define AE_  SUB2(.5,.5) // for %\n#define KO_  SUB2(1.5,3.5) // for %\n#define JM_  SUB2(0.,3.5) // for #\n\n// Char special Properties\n#define PROPMAX         250.\n#define PROPPACK(a,n,m) (floor( (a - n)/(m - n)*(PROPMAX - 1.) ) )\n#define PROPPACK3(x,y,z) (-(x+PROPMAX*y+PROPMAX*PROPMAX*z))\n#define CHARSPACE(x)     (PROPPACK(x,-.3,1.))\n#define CURSORZ(x)       (PROPPACK(x,-1.,0.))\n#define VSHIFT(x)        (PROPPACK(x,-2.,2.))\n//#define SPECIALPROP(a,b,c)  PROPPACK3(CHARSPACE(a),CURSORZ(b),VSHIFT(c))\n#define SPECIALPROP(a,b,c)  (-(CHARSPACE(a)+PROPMAX*CURSORZ(b)+PROPMAX*PROPMAX*VSHIFT(c)))\n\n\n\n// Small letters\n\n//const vec2 ch_a =vec2(4932900,1746);\n//const vec2 ch_b =vec2(4932900,2010);\nconst vec4 c_ab = p4( G_,I_,O_,M_, J_,L_,0.,0.,G_,I_,O_,M_, A_,M_,0.,0. );\n#define _a _ch8(c_ab.xy);\n#define _b _ch8(c_ab.zw);\n\n//const vec3 ch_i = vec3( -1. , p2( D_,D_,0.,M_, G_,0.,0.,0. ) );\n//const vec4 c_ic = vec4( -1. , p2( E_,E_,0.,H_, N_,0.,0.,0. ) , p1( I_,G_,M_,O_ ) );\nconst vec4 c_ic = vec4( SPECIALPROP(.5,-.25,.0) , p3( E_,E_,0.,H_, N_,0.,0.,0. , I_,G_,M_,O_ ) );\n#define _c _ch4(c_ic.w);\n#define _i _ch16(c_ic.xyz);\n\nconst vec4 c_de = p4( I_,G_,M_,O_, C_,0.,0.,0., O_,M_,G_,I_, L_,J_,0.,0.  );\n#define _d _ch8(c_de.xy);\n#define _e _ch8(c_de.zw);\n\n// a recaser // O_,M_,G_,I_, U_,0.,0.,0\nconst vec3 c_q = vec3(  SPECIALPROP(1.,0.,2.) , p2(I_,G_,A_,C_, O_,0.,0.,0.) );\n#define _q _ch16(c_q.xyz); \n\n//const vec4 c_fg = p4( C_,B_,N_,0., G_,I_,0.,0.,O_,M_,G_,I_, U_,S_,0.,0. );\n//#define _f _ch8(c_fg.xy);\n//#define _g _ch8(c_fg.zw);\n\nconst vec4 c_fg = vec4( p2( C_,B_,N_,0., G_,I_,0.,0. ) , SPECIALPROP(0.,-1.,2.) , p1(O_,M_,0.,0.) );\n#define _f _ch8(c_fg.xy);\n#define _g _ch16(c_q.xyz); _ch8(c_fg.zw);\n\nconst vec4 c_hk = p4( G_,I_,O_,0., M_,A_,0.,0.,A_,M_,I_,0., K_,O_,0.,0. );\n#define _h _ch8(c_hk.xy);\n#define _k _ch8(c_hk.zw);\n\n//const vec4 c_jn = vec4( SPECIALPROP(.45,-.3,1.) , p3( E_,E_,0.,H_, T_,S_,0.,0., M_,G_,I_,O_ ) );\n//const vec4 c_jn = vec4( SPECIALPROP(.45,-.3,1.) , p3( B_,B_,0.,E_, N_,M_,0.,0., M_,G_,I_,O_ ) );\nconst vec3 c_jn = vec3( SPECIALPROP(.0,-.75,2.) , p2( H_,N_,M_,0., M_,G_,I_,O_ ) );\n//#define _j _ch16(c_jn.xyz);\n#define _j  _ch16(c_ic.xyz); _ch8(c_jn.xy);\n#define _n _ch4(c_jn.z);\n// 1 float avalaible\n\nconst vec4 c_ls = vec4( SPECIALPROP(.45,0.,.0) , p3( M_,A_,0.,0., I_,G_,J_,L_, O_,M_,0.,0. ) );\n#define _l _ch8(c_ls.xy);\n#define _s _ch8(c_ls.zw);\n\nconst vec4 c_mo = p4( M_,G_,I_,O_, 0.,N_,H_,0.,M_,G_,I_,O_, M_,0.,0.,0. );\n#define _m _ch8(c_mo.xy);\n#define _o _ch8(c_mo.zw);\n\n//const vec4 c_pq = p4( M_,O_,I_,G_, S_,0.,0.,0.,O_,M_,G_,I_, U_,0.,0.,0. );\n//#define _p _ch8(c_pq.xy);\n//#define _q _ch8(c_pq.zw);\n\nconst vec4 c_pz = vec4( SPECIALPROP(1.,0.,2.), p3( G_,I_,C_,A_, M_,0.,0.,0., G_,I_,M_,O_) );\n#define _p _ch16(c_pz.xyz);\n#define _z _ch4(c_pz.w);\n\n\nconst vec4 c_tr = vec4( SPECIALPROP(.75,0.,.0) , p3( A_,M_,N_,0., G_,H_,0.,0. , M_,G_,I_,0. ) );\n#define _t _ch16(c_tr.xyz);\n#define _r _ch4(c_tr.w);\n\nconst vec4 c_Bu = p4( A_,BC_,CF_,FI_, HI_,IL_,LO_,NO_,  M_,A_,G_,HI_ , G_,M_,O_,I_ );\n#define _B _ch16(c_Bu.xyz);\n#define _u _ch4(c_Bu.w);\n\n//const vec2 ch_v = p2( G_,J_,N_,L_, I_,0.,0.,0. );\n//#define _v _ch8(ch_v);\n//const vec4 c_yvz = p4( G_,M_,O_,0., I_,U_,S_,0.,G_,N_,I_,0.,G_,I_,M_,O_ );\n//#define _z _ch4(c_yvz.w);\n\nconst vec4 c_yv = vec4( SPECIALPROP(1.,0.,2.), p3( A_,G_,I_,0., C_,O_,M_,0.,G_,N_,I_,0.) );\n#define _y _ch16(c_yv.xyz);\n#define _v _ch4(c_yv.w);\n\n\nconst vec4 c_wx = p4( G_,M_,O_,I_, 0.,N_,H_,0.,G_,O_,0.,I_, M_,0.,0.,0. );\n#define _w _ch8(c_wx.xy);\n#define _x _ch8(c_wx.zw);\n\n// Capitals letters\n\n//const vec2 ch_D = p2( A_,B_,F_,L_,  N_,M_,A_,0. );\nconst vec4 c_AD = p4( M_,A_,C_,O_, 0.,G_,I_,0.,A_,BC_,CF_,LO_,  NO_,M_,A_,0. );\n#define _A _ch8(c_AD.xy);\n#define _D _ch8(c_AD.zw);\n\n\n\nconst vec4 c_EF = p4( C_,A_,M_,O_ , 0.,I_,G_,0. , C_,A_,M_,0. , G_,H_,0.,0. );\n#define _E _ch8(c_EF.xy);\n#define _F _ch8(c_EF.zw);\n\nconst vec4 c_GH = p4( C_,A_,M_,O_ , I_,H_,0.,0.,A_,M_,0.,G_ , I_,0.,C_,O_  );\n#define _G _ch8(c_GH.xy);\n#define _H _ch8(c_GH.zw);\n\nconst vec4 c_IJ = p4( A_,C_,0.,B_ , N_,0.,M_,O_,A_,C_,0.,B_ , N_,0.,M_,N_  );\n#define _I _ch8(c_IJ.xy);\n#define _J _ch8(c_IJ.zw);\n\nconst vec4 c_KCL = p4( C_,G_,O_,0. , A_,M_,0.,0. , C_,A_,M_,O_ , A_,M_,O_,0. );\n#define _K _ch8(c_KCL.xy);\n#define _C _ch4(c_KCL.z);\n#define _L _ch4(c_KCL.w);\n\nconst vec4 c_MO = p4( M_,A_,H_,C_ , O_,0.,0.,0.,A_,M_,O_,C_, A_,0.,0.,0. );\n#define _M _ch8(c_MO.xy);\n#define _O _ch8(c_MO.zw);\n\n//const vec2 ch_Q = p2( A_,M_,O_,C_, A_,0.,O_,U_ );\n//const vec2 ch_Q = p2( A_,M_,O_,C_, A_,0.,U_,N_ );\nconst vec4 c_PQ = p4( G_,I_,C_,A_, M_,0.,0.,0.,A_,M_,O_,C_, A_,0.,K_,O_ );\n#define _P _ch8(c_PQ.xy);\n#define _Q _ch8(c_PQ.zw);\n\n//const vec2 ch_R = p2( M_,A_,C_,I_, G_,O_,0.,0. );\n//const vec2 ch_S = p2( C_,A_,DG_,IL_, IL_,O_,M_,0. );\n//const vec2 ch_S = p2( C_,AB_,AD_,DG_, IL_,LO_,NO_,M_ );\nconst vec4 c_RS = p4( M_,A_,C_,I_, G_,0.,GH_,O_,C_,AB_,AD_,D_, L_,LO_,NO_,M_ );\n#define _R _ch8(c_RS.xy);\n#define _S _ch8(c_RS.zw);\n\nconst vec4 c_Tic = p4( A_,C_,0.,B_, N_,0.,0.,0.,D_,B_,F_,0., H_,N_,0.,0. );\n#define _T _ch8(c_Tic.xy);\n#define _icirc _ch8(c_Tic.zw);\n\nconst vec4 c_WX = p4( A_,M_,H_,O_, C_,0.,0.,0. , A_,O_,0.,M_, C_,0.,0.,0. );\n#define _W _ch8(c_WX.xy);\n#define _X _ch8(c_WX.zw);\n\nconst vec4 c_YZ = p4( A_,H_,N_,0., H_,C_,0.,0.,A_,C_,M_,O_, 0.,GH_,HI_,0. );\n#define _Y _ch8(c_YZ.xy);\n#define _Z _ch8(c_YZ.zw);\n\n// Digits\n\nconst vec4 c_01 = p4( A_,C_,O_,M_ , A_, 0. , H_ , H_,D_,B_,N_,0.,M_,O_,0.,0. );\n#define _0 _ch8(c_01.xy);\n#define _1 _ch8(c_01.zw);\n\nconst vec4 c_34 = p4( A_,C_,O_,M_,0.,G_,I_,0.,A_,G_,I_,0.,CF_,O_,0.,0. );\n#define _3 _ch8(c_34.xy);\n#define _4 _ch8(c_34.zw);\n\nconst vec4 c_78 = p4( A_,C_,M_,0.,G_,I_,0.,0.,A_,C_,O_,M_,A_,0.,G_,I_ );\n#define _7 _ch8(c_78.xy);\n#define _8 _ch8(c_78.zw);\n\nconst vec4 c_25 = p4( A_,C_,I_,G_,M_,O_,0.,0.,C_,A_,G_,I_,O_,M_,0.,0. );\n#define _2 _ch8(c_25.xy);\n#define _5 _ch8(c_25.zw);\n\nconst vec4 c_69 = p4( C_,A_,M_,O_,I_,G_,0.,0.,I_,G_,A_,C_,O_,M_,0.,0. );\n#define _6 _ch8(c_69.xy);\n#define _9 _ch8(c_69.zw);\n\n// Misc & Ponctuations & Letter V\n\nconst vec4 c_exclV = vec4( SPECIALPROP(.45,0.,.0) , p3( A_,J_,0.,M_, M_,0.,0.,0.,A_,N_,C_,0.) );\n#define _excl _ch16(c_exclV.xyz);\n#define _V _ch4(c_exclV.w);\n// {{ ! }}{{excl}}\n\nconst vec4 c_codo = vec4( SPECIALPROP(.4,-.3,1.) , p1(K_,KM_,0.,0.), SPECIALPROP(.4,-.3,1.) , p1(K_,K_,0.,0.));\n#define _com _ch8(c_codo.xy);\n#define _dot _ch8(c_codo.zw);\n\nconst vec4 c_qubk = p4( D_,AD_,AB_,BC_, CF_,F_,H_,K_, 0.,N_,N_,0.,A_, O_,0.,0. );\n#define _quest _ch16(c_qubk.xyz);\n#define _back _ch4(c_qubk.w);\n// {{ ? }}{{quest}}\n\n//const vec3 ch_ddot = vec3(-2. , p2(KN_,KN_,0.,HK_, HK_,0.,0.,0.));\n//const float ch_apo = p1(AB_, AE_,D_,0.);\nconst vec4 c_ddap = vec4( SPECIALPROP(.45,-.3,.0) , p3(EH_,EH_,0.,HK_, HK_,0.,0.,0., AB_, DE_,0.,0.));\n#define _ddot _ch16(c_ddap.xyz);\n#define _apo _ch4(c_ddap.w);\n// {{ ' }}{{apo}}\n\nconst vec4 c_dcosl = vec4( SPECIALPROP(.45,-.3,.0) , p3(EH_,EH_,0.,HK_, JK_,0.,0.,0.,C_, M_,0.,0.));\n#define _dcom _ch16(c_dcosl.xyz);\n#define _sla _ch4(c_dcosl.w);\n\nconst vec4 c_bos8 = p4(D_,L_,0.,J_, F_,0.,E_,K_, 0.,G_,I_,0.,C_,B_,N_,O_);\n#define _star8 _ch16(c_bos8.xyz);\n#define _brao _ch4(c_bos8.w);\n\n//const vec3 ch_aster = p3(B_,E_,HI_,0., A_,E_,C_,0., GH_,E_,0.,0.);\n//const vec3 ch_aster = p3(AB_,HI_,0.,BC_, GH_,0.,DE_,EF_, 0.,0.,0.,0.);\nconst vec4 c_asst6 = p4(AD_,FI_,0.,DG_, CF_,0.,B_,H_,DG_,IL_,0.,FI_, GJ_,0.,E_,K_);\n#define _star6 _ch8(c_asst6.xy);\n#define _aster _ch8(c_asst6.zw);\n\nconst vec4 c_udor = vec4( SPECIALPROP(.58,-.18,.5) , p3(M_,O_,0.,0.,AB_,MN_,0.,BC_, NO_,0.,0.,0.));\n#define _und _ch8(c_udor.xy);\n#define _or _ch8(c_udor.zw);\n\n\n\nconst vec4 c_htbc = p4(DG_,FI_,0.,GJ_, IL_,0.,BE_,JM_, 0.,CF_,KN_,0.,A_,B_,N_,M_);\n#define _hash _ch16(c_htbc.xyz);\n#define _brac _ch4(c_htbc.w);\n\n\nconst vec4 c_aoeN = vec4( SPECIALPROP(.6,-.4,.0) , p3( O_,M_,G_,I_, L_,J_,0.,0., M_,A_,O_,C_)  );\n#define _aoe _ch16(c_aoeN.xyz);\n#define _N _ch4(c_aoeN.w);\n// {{ Å }}{{o}}{{aoe}}\n// {{ Ã¦ }}{{a}}{{aoe}}\n\nconst vec4 c_ccdU = vec4( SPECIALPROP(1.,.0,1.) , p3( F_,D_,J_,L_, 0.,K_,N_,M_,A_,M_,O_,C_) );\n#define _ccd _ch16(c_ccdU.xyz);\n#define _U _ch4(c_ccdU.w);\n// {{ Ã§ }}{{ccd}}\n\n\n//const vec3 ch_and = p3(O_,D_,AD_,AB_, BC_,CF_,F_,J_, JM_,MN_,N_,IL_);\n//const vec3 ch_and = p3(O_,DG_,D_,AE_, BF_,F_,FI_,J_, JM_,MN_,N_,IL_);\nconst vec4 c_andm = p4(O_,DG_,D_,AE_, BE_,EF_,EI_,J_, JM_,MN_,N_,IL_,G_, I_,0.,0.);\n#define _and _ch16(c_andm.xyz);\n#define _minus _ch4(c_andm.w);\n\n// Quotes & Brackets\n\nconst vec4 c_frq = p4(F_, H_,L_,0., E_,G_,K_,0.,D_, H_,J_,0., E_,I_,K_,0.);\n#define _frqo _ch8(c_frq.xy);\n#define _frqc _ch8(c_frq.zw);\n\nconst vec4 c_qu = p4(AB_, AE_,E_,0., BC_,BF_,F_,0.,AB_, AE_,D_,0., BC_,BF_,E_,0.);\n#define _qo _ch8(c_qu.xy);\n#define _qc _ch8(c_qu.zw);\n\nconst vec4 c_par = p4(C_,BE_,DH_,HJ_, KN_,O_,0.,0.,A_,BE_,FH_,HL_, KN_,M_,0.,0.);\n#define _paro _ch8(c_par.xy);\n#define _parc _ch8(c_par.zw);\n\nconst vec4 c_cur = p4(C_,BE_,EH_,GH_, HK_,KN_,O_,0.,A_,BE_,EH_,HI_, HK_,KN_,M_,0.);\n#define _curo _ch8(c_cur.xy);\n#define _curc _ch8(c_cur.zw);\n\n// Maths\n\nconst vec4 c_equ = p4(AB_, DE_,0.,0., BC_,EF_,0.,0.,DG_,FI_,0.,GJ_, IL_,0.,0.,0.);\n#define _quo _ch8(c_equ.xy);\n#define _eq _ch8(c_equ.zw);\n\n//const vec2 ch_diff = p2(DG_,FI_,0.,GJ_, IL_,0.,F_,J_);\n//const vec2 ch_diff = p2(DG_,FI_,0.,GJ_, IL_,0.,EF_,JK_);\n//const vec2 ch_diff = p2(DG_,FI_,0.,GJ_, IL_,0.,BC_,MN_);\n//const vec2 ch_plus = p2(EH_,HK_,0.,G_, I_,0.,0.,0.);\nconst vec4 c_dipl = p4(DG_,FI_,0.,GJ_, IL_,0.,BF_,KM_,E_,K_,0.,G_, I_,0.,0.,0.);\n#define _diff _ch8(c_dipl.xy);\n#define _plus _ch8(c_dipl.zw);\n\n//const vec2 ch_div = p2(C_,M_,0.,AE_, AE_,0.,KO_,KO_);\n//const vec2 ch_div = p2(CF_,JM_,0.,AD_, AD_,0.,LO_,LO_);\nconst vec4 c_dicr = p4(D_,L_,0.,J_, F_,0.,0.,0.,CF_,JM_,0.,D_, D_,0.,L_,L_);\n#define _cross _ch8(c_dicr.xy);\n#define _div _ch8(c_dicr.zw);\n\nconst vec4 c_prgt = p4(C_,M_,0.,A_, B_,E_,D_,A_, 0.,K_,L_,0.,D_,I_,J_,0.);\n#define _gt _ch4(c_prgt.w);\n\nconst vec4 c_ceci = vec4( SPECIALPROP(0.,-.68,.0) , p1(J_,M_,N_,K_) , SPECIALPROP(0.,-1.,.0) , p1(D_,B_,F_,0.) );\n#define _pcent _ch16(c_prgt.xyz);_ch8(c_ceci.xy);\n#define _circ _ch8(c_ceci.zw);\n// {{ Ã¢ }}{{a}}{{circ}}\n// {{ Ã´ }}{{o}}{{circ}}\n// {{ Ã» }}{{u}}{{circ}}\n// {{ Ãª }}{{e}}{{circ}}\n// {{ Ã® }}{{icirc}}\n\nconst vec4 c_thlt = vec4( SPECIALPROP(.333333,-.68,.0) , p3(J_,M_,N_,K_, L_,O_,N_,0.,F_,G_,L_,0.) );\n#define _pthou _ch16(c_prgt.xyz);_ch16(c_thlt.xyz);\n#define _lt _ch4(c_thlt.w);\n\nconst vec4 c_gtlt = p4( D_,I_,J_,0., L_,M_,0.,0. , F_,G_,L_,0., J_,O_,0.,0. );\n#define _gte _ch8(c_gtlt.xy);\n#define _lte _ch8(c_gtlt.zw);\n\n// Accents\n\nconst vec3 ch_dia = vec3( SPECIALPROP(.0,-1.,.0), p2(DE_,DE_,0.,EF_, EF_,0.,0.,0.));\n#define _dia _ch16(ch_dia);\n\nconst vec3 ch_idia = vec3( SPECIALPROP(.5,-.25,.0) , p2( DE_,DE_,0.,H_, N_,0.,EF_,EF_ ) );\n#define _idia _ch16(ch_idia);\n// {{ Ã¤ }}{{a}}{{dia}}\n// {{ Ã¼ }}{{u}}{{dia}}\n// {{ Ã« }}{{e}}{{dia}}\n// {{ Ã¿ }}{{y}}{{dia}}\n// {{ Ã¯ }}{{idia}}\n\n\nconst vec4 c_acc = vec4( SPECIALPROP(0.,-1.,.0) , p1( AB_,EF_,0.,0. ) , SPECIALPROP(0.,-1.,.0) , p1( BC_,DE_,0.,0. ) );\n#define _agr _ch8(c_acc.xy);\n// {{ Ã  }}{{a}}{{agr}}\n// {{ Ã¨ }}{{e}}{{agr}}\n// {{ Ã¹ }}{{u}}{{agr}}\n#define _acu _ch8(c_acc.zw);\n// {{ Ã© }}{{e}}{{acu}}\n\n// {{   }}{{sp}}\n// {{ \\n }}{{nl}}\n\n\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xl3SWN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xl3SzB", "name": "lights pattern generator", "author": "lomateron", "description": "click to change pattern", "tags": ["2d"], "likes": 37, "viewed": 998, "date": "1480155243", "time_retrieved": "2024-06-20T18:45:13.721425", "image_code": "//iq color palette\nvec3 pal(float t, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv*2.-1.;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    float e = iTime*.125;\n    float d = 128.*iMouse.x/iResolution.x+8.5;\n    \n    float zoom = 4.+16.*iMouse.y/iResolution.y;\n    vec2 g = uv*zoom;\n    uv = d*(floor(g)+.5)/zoom;\n    g = fract(g)*2.-1.;\n    \n    float f = dot(uv,uv)-e;\n    \n    vec4 c = vec4(\n        pal( f*.5 + e,\n            vec3(0.5,0.5,0.5),\n            vec3(0.5,0.5,0.5),\n            vec3(1.0,1.0,1.0),\n            vec3(0.0,0.10,0.20)),1.);\n    \n\tfragColor = c*(1.-dot(g,g))*.2/abs((fract(f)-.5)*8.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xl3SzB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xl3SzH", "name": "MegaWave 5", "author": "aiekick", "description": "MegaWave 5", "tags": ["megawave"], "likes": 17, "viewed": 765, "date": "1478010998", "time_retrieved": "2024-06-20T18:45:14.745865", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nmat3 RotX(float a){return mat3(1.,0.,0.,0.,cos(a),-sin(a),0.,sin(a),cos(a));}\nmat3 RotY(float a){return mat3(cos(a),0.,sin(a),0.,1.,0.,-sin(a),0.,cos(a));}\nmat3 RotZ(float a){return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\n\nconst float mPi = 3.14159;\nconst float m2Pi = 6.28318;\nfloat time = 0.;\nfloat time2 = 0.;\n\nfloat shape(vec3 p)\n{\n    return length(p);\n}\n\nvec2 df(vec3 p) // from MegaWave 2 (https://www.shadertoy.com/view/ltjXWR)\n{\n\tvec2 res = vec2(1000.);\n\t\n    p *= RotY(-3.14159/4.);\n    p *= RotZ(p.z * 0.05);\n    \n\tvec3 q;\n\t\n\t// mat 2\n\tq.x = cos(p.x);\n\tq.y = p.y * 5. - 25. + 10. * cos(p.x / 7. + time2) + 10. * sin(p.z / 7. + time2);\n\tq.z = cos(p.z);\n    float sphere = shape(q) - 1.;\n\tif (sphere < res.x)\n\t\tres = vec2(sphere, 2.);\n\t\n\t// mat 3\n\tq.x = cos(p.x);\n\tq.y = p.y * 5. + 25. + 10. * cos(p.x / 7. + time2 + mPi) + 10. * sin(p.z / 7. + time2 + mPi);\n\tq.z = cos(p.z);\n\tsphere = shape(q) - 1.;\n\tif (sphere < res.x)\n\t\tres = vec2(sphere, 3.);\n\n    return res;\n}\n\nvec3 nor( vec3 p, float prec )\n{\n    vec2 e = vec2( prec, 0. );\n    vec3 n = vec3(\n\t\tdf(p+e.xyy).x - df(p-e.xyy).x,\n\t\tdf(p+e.yxy).x - df(p-e.yxy).x,\n\t\tdf(p+e.yyx).x - df(p-e.yyx).x );\n    return normalize(n);\n}\n\n// from iq code\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<30; i++ )\n    {\n\t\tfloat h = df( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n//--------------------------------------------------------------------------\n// Grab all sky information for a given ray from camera\n// from Dave Hoskins // https://www.shadertoy.com/view/Xsf3zX\nvec3 GetSky(in vec3 rd, in vec3 sunDir, in vec3 sunCol)\n{\n\tfloat sunAmount = max( dot( rd, sunDir), 0.0 );\n\tfloat v = pow(1.0-max(rd.y,0.0),6.);\n\tvec3  sky = mix(vec3(.1, .2, .3), vec3(.32, .32, .32), v);\n\tsky = sky + sunCol * sunAmount * sunAmount * .25;\n\tsky = sky + sunCol * min(pow(sunAmount, 800.0)*1.5, .3);\n\treturn clamp(sky, 0.0, 1.0);\n}\n\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// get density of the df at surfPoint\n// ratio between constant step and df value\nfloat SubDensity(vec3 surfPoint, float prec, float ms) \n{\n\tvec3 n;\n\tfloat s = 0.;\n    const int iter = 8;\n\tfor (int i=0;i<iter;i++)\n\t{\n\t\tn = nor(surfPoint,prec); \n\t\tsurfPoint = surfPoint - n * ms; \n\t\ts += df(surfPoint).x;\n\t}\n\treturn 1.-s/(ms*float(iter)); // s < 0. => inside df\n}\n\nfloat SubDensity(vec3 p, float s) \n{\n\tvec3 n = nor(p,s); \t\t\t\t\t\t\t// precise normale at surf point\n\treturn df(p - n * s).x;\t\t\t\t\t\t// ratio between df step and constant step\n}\n\nvec4 shade(vec3 ro, vec3 rd, float d, vec3 lp)\n{\n\tvec3 p = ro + rd * d;\t\t\t\t\t\t\t\t\t\t\t// surface point\n\tfloat sb = SubDensity(p, 0.001, 0.1);\t\t\t\t\t\t\t// deep subdensity (10 iterations)\n\tvec3 bb = blackbody(100.*sb+100.);\t\t\t\t\t\t\t\t// blackbody color according to the subdensity value\n\tvec3 ld = normalize(lp-p); \t\t\t\t\t\t\t\t\t\t// light dir\n\tvec3 n = nor(p, .01);\t\t\t\t\t\t\t\t\t\t\t// normal at surface point\n\tvec3 refl = reflect(rd,n);\t\t\t\t\t\t\t\t\t\t// reflected ray dir at surf point \n\tfloat amb = 0.08; \t\t\t\t\t\t\t\t\t\t\t\t// ambiance factor\n\tfloat diff = clamp( dot( n, ld ), 0.0, 1.0 ); \t\t\t\t\t// diffuse\n    diff *= softshadow( p, ld, 0.02, 50.);\t\t\t\t\t\t\t// soft shadow\n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 16. ); \t\t// fresnel\n\tfloat spe = pow(clamp( dot( refl, ld ), 0.0, 1.0 ),25.);\t\t// specular\n\tfloat sss = 1. - SubDensity(p*0.1, 5.) * 0.5; \t\t\t\t\t// one step sub density of df\n\treturn vec4(\t\t\t\t\t\t\t\t\t\t\t\t\t// some mix of WTF :) i tried many different things and this i choose :) but maybe there is other things to do\n        (diff + fre + bb.x * sss) * amb + diff * 0.5, \n        (diff + fre + bb * sb + sss * 0.3) * amb + spe * 0.6 - diff * sss * 0.05\t\n    );\n}\n\n// get cam\nvec3 cam(vec2 g, vec2 si, vec3 ro, vec3 cv)\n{\n\tvec2 uv = (g+g-si)/si.y;\n\tvec3 cu = normalize(vec3(0,1,0));\n  \tvec3 z = normalize(cv-ro);\n    vec3 x = normalize(cross(cu,z));\n  \tvec3 y= cross(z,x);\n  \treturn normalize(z + uv.x*x + uv.y*y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 f = vec4(0);\n    \n    vec2 g = fragCoord.xy;\n    vec2 si = iResolution.xy;\n    \n    time = iTime * 2.;\n    time2 = iTime * 1.;\n    \n    vec3 cu = vec3(0,1,0);\n  \tvec3 cv = vec3(time + .1,0,time + .1);\n    vec3 ro = vec3(time,0,time);\n\t\n\tvec3 lp = ro + vec3(101,10,-5);\n   \tvec3 rd = cam(g, si, ro, cv);\n\n    float s = 1.;\n    float d = 0.;\n    for(int i=0;i<250;i++)\n    {      \n        if (log(d*d/s/1e5)>0.||d>100.)break;\n        d += s = df(ro+rd*d).x * .1;\n    }\n\t\n    vec3 sky = GetSky(rd, normalize(lp-ro), vec3(2.));\n\n    if (d < 100.)\n    {\n        f = shade(ro, rd, d, lp);\n        f = f.zyzw;\n        f = f + f.x*0.3;\n        f = mix( f, sky.rbgg, 1.0-exp( -0.001*d*d ) );\n    }\n    else\n    {\n        f = sky.rbgg;\n    }\n        \n   \tfragColor = sqrt(f*f*f*5.); // gamma correction\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xl3SzH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xl3XR4", "name": "Walking cubes", "author": "xorxor", "description": "Learning a bit about movement, ao and reflections during Codevember 2016", "tags": ["raymarching", "cubes", "codevember"], "likes": 10, "viewed": 637, "date": "1478275633", "time_retrieved": "2024-06-20T18:45:14.757802", "image_code": "// Created by XORXOR, 2016\n// Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0)\n//\n// Thanks to iq's articles\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// and the Raymarching - Primitives sample\n// https://www.shadertoy.com/view/Xds3zN\n\n#define SQRT_2 1.4142135623730951\n#define HALF_PI 1.5707963267948966\n#define QUARTER_PI 0.7853981633974483\n\n#define CUBE_SIZE 0.5\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n    return ( d1.x < d2.x ) ? d1 : d2;\n}\n\nmat3 transform( float a, out vec2 offset )\n{\n    float c = cos( a );\n    float s = sin( a );\n    vec2 v = CUBE_SIZE * SQRT_2 * abs( vec2( cos( a + QUARTER_PI ), sin( a + QUARTER_PI ) ) );\n    offset.x = - min( abs( v.x ), abs( v.y ) );\n    offset.y = max( v.x, v.y );\n    if ( mod( a, HALF_PI ) > QUARTER_PI )\n    {\n        offset.x = - offset.x;\n    }\n    float n = floor( a / QUARTER_PI ) + 2.0;\n    offset.x += CUBE_SIZE * 2.0 * floor( n / 2.0 );\n    offset.x = mod( offset.x, 12.0 ) - 5.0;\n\n    // rotation matrix inverse\n    return mat3( c, 0, s,\n                -s, 0, c,\n                 0, 1, 0 );\n}\n\nfloat udRoundBoxT( vec3 p )\n{\n    float r = 0.1;\n    return length( max( abs( p ) - vec3( CUBE_SIZE - r ), 0.0 ) ) - r;\n}\n\nfloat hash( float n )\n{\n    return fract( sin( n ) * 4121.15393 );\n}\n\nvec2 map( vec3 p )\n{\n    vec2 plane = vec2( abs( p.y ), 1.0 );\n\n    vec2 offset = vec2( 0 );\n    mat3 t = transform( iTime * 2.0, offset );\n    vec3 q = t * ( p  - vec3( offset.x - 0.3, offset.y, -3.0 ) );\n    vec2 box = vec2( udRoundBoxT( q ), 2.0 );\n\n    mat3 t2 = transform( 4.0 + iTime * 2.5, offset );\n    vec3 q2 = t2 * ( p  - vec3( offset.x + 0.1, offset.y, 1.0 ) );\n    vec2 box2 = vec2( udRoundBoxT( q2 ), 3.0 );\n\n    mat3 t3 = transform( 2.0 + iTime * 1.2, offset );\n    vec3 q3 = t3 * ( p  - vec3( offset.x + 0.4, offset.y, -1.2 ) );\n    vec2 box3 = vec2( udRoundBoxT( q3 ), 4.0 );\n\n    mat3 t4 = transform( -1.3 + iTime * 1.75, offset );\n    vec3 q4 = t4 * ( p  - vec3( offset.x + 0.3, offset.y, 2.3 ) );\n    vec2 box4 = vec2( udRoundBoxT( q4 ), 5.0 );\n\n    return opU( opU( box, opU( box2, opU( box3, box4 ) ) ),\n                plane );\n}\n\nvec2 scene( vec3 ro, vec3 rd )\n{\n    float t = 0.1;\n    for ( int i = 0; i < 64; i++ )\n    {\n        vec3 pos = ro + rd * t;\n        vec2 res = map( pos );\n        if ( res.x < 0.0005 )\n        {\n            return vec2( t, res.y );\n        }\n        t += res.x;\n    }\n    return vec2( -1.0 );\n}\n\nfloat calcShadow( vec3 ro, vec3 rd, float mint, float maxt )\n{\n    float t = mint;\n    float res = 1.0;\n    for ( int i = 0; i < 32; i++ )\n    {\n        vec2 h = map( ro + rd * t );\n        res = min( res, 2.0 * h.x / t );\n        t += h.x;\n        if ( ( h.x < 0.001 ) || ( t > maxt ) )\n        {\n            break;\n        }\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcAo( vec3 pos, vec3 n )\n{\n    float occ = 0.0;\n    for ( int i = 0; i < 5; i++ )\n    {\n        float hp = 0.01 + 0.1 * float(i) / 4.0;\n        float dp = map( pos + n * hp ).x;\n        occ += ( hp - dp );\n    }\n    return clamp( 1.0 - 1.5 * occ, 0.0, 1.0 );\n}\n\nvec3 calcNormal( vec3 pos )\n{\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 n = vec3(\n            map( pos + eps.xyy ).x - map( pos - eps.xyy ).x,\n            map( pos + eps.yxy ).x - map( pos - eps.yxy ).x,\n            map( pos + eps.yyx ).x - map( pos - eps.yyx ).x );\n    return normalize( n );\n}\n\n// http://www.iquilezles.org/www/articles/palettes/palettes.htm\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b * cos( 6.28318 * ( c * t + d ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord.xy - 0.5 * iResolution.xy )/ iResolution.y;\n    vec3 eye = vec3( 0.0, 7.0, 20.0 );\n    vec3 target = vec3( 0.0 );\n    vec3 cw = normalize( target - eye );\n    vec3 cu = cross( cw, vec3( 0.0, 1.0, 0.0 ) );\n    vec3 cv = cross( cu, cw );\n    mat3 cm = mat3( cu, cv, cw );\n    vec3 rd = cm * normalize( vec3( uv, 6.0 ) );\n\n    vec2 res = scene( eye, rd );\n\n    vec3 col = vec3( 0.0 );\n    if ( res.x >= 0.0 )\n    {\n        vec3 pos = eye + rd * res.x;\n        vec3 n = calcNormal( pos );\n        if ( res.y == 1.0 )\n        {\n        \tcol = vec3( 0.2 + mod( floor( pos.x ) + floor( pos.z ), 2.0 ) );\n        }\n        else\n        {\n            col = palette( ( res.y - 1.0 ) / 4.0,\n                     vec3( 0.5, 0.5, 0.5 ), vec3( 0.5, 0.5, 0.5\t),\n                     vec3( 1.0, 1.0, 1.0 ), vec3( 0.0, 0.33, 0.67 ) );\n        }\n\n        vec3 ldir = normalize( vec3( 0.5, 2.8, 4.0 ) );\n        float sh = calcShadow( pos, ldir, 0.01, 4.0 );\n        float ao = calcAo( pos, n );\n        col *= ( 0.2 + ao ) * ( 0.3 + sh );\n\n        vec3 ref = reflect( rd, n );\n        float refSh = calcShadow( pos, ref, 0.01, 4.0 );\n\n        float dif = max( dot( n, ldir ), 0.0 );\n        float spe = pow( clamp( dot( ref, ldir ), 0.0, 1.0 ), 15.0 );\n\n        col *= ( 0.3 + dif ) * ( 0.5 + refSh );\n        col += dif * sh *  spe * vec3( 1.0 );\n    }\n\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-4.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xl3XR4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xl3XzS", "name": "cloudy voxel world 2.0", "author": "SudoNhim", "description": "A voxel world with rounded edges, anti-aliasing, volumetric clouds, semitransparent water, reflections, shadows, ambient occlusion and SUNSHINE", "tags": ["voxels", "volumetricfog"], "likes": 20, "viewed": 736, "date": "1480124858", "time_retrieved": "2024-06-20T18:45:16.461006", "image_code": "#define PI 3.14159\n\n#define VOXEL_NONE  0\n#define VOXEL_WATER 1\n#define VOXEL_SAND  2\n#define VOXEL_EARTH 3\n#define VOXEL_STONE 4\n#define VOXEL_GRASS 5\n\n#define SUN_DIRECTION normalize(vec3(0.4, 0.6, 0.7))\n\nstruct VoxelHit\n{\n    ivec3 mapPos;    // world coords\n    int terrainType; // terrain type\n    vec2 volAccum;   // sum of (fog, water) along the ray path\n    vec3 hitRel;     // position of intersect relative to center of voxel\n    vec3 hitNormal;  // surface normal at intersect\n    float weight;    // contribution to the ray (fractional values come from anti-aliasing)\n};\n\nstruct VoxelMarchResult\n{\n    // we store the first two intersects for two purposes:\n    // 1) it allows the first voxel hit to be non-cube shaped (e.g. rounded edges)\n    // 2) it allows cheap anti-aliasing\n    VoxelHit first;\n    VoxelHit second;\n};\n\n// from https://www.shadertoy.com/view/4sfGzS\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n    vec2 uv = p.xy + f.xy;\n\tvec2 rg = vec2(texture( iChannel0, (uv+vec2(37.0,17.0)*p.z+0.5)/256.0, -100.0 ).x,\n                   texture( iChannel0, (uv+vec2(37.0,17.0)*(p.z+1.0)+0.5)/256.0, -100.0 ).x );\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nvoid getVoxelAndOcclusionsAt(ivec3 ip, out int terrainType, out vec2 occlusions)\n{ \n    terrainType = VOXEL_NONE;\n    \n    float cloudiness = noise(vec3(ip)/8.0);\n    occlusions = vec2(smoothstep(0.6, 0.7, cloudiness)*0.3 + 0.1, 0.0);\n    \n    if (ip.y <= 1) {terrainType = VOXEL_WATER; occlusions = vec2(0.0, 1.0);}\n    \n    // so this is like, grabbing the texture as a heightmap and\n    // then like twisting it in random directions as it goes up\n    // umm...\n    vec3 p = vec3(vec3(ip) + 0.5);\n    float theta = noise(p / 16.0) * PI * 2.0;\n    vec2 disp = vec2(cos(theta), sin(theta)) * p.y;\n    vec3 terr = texture(iChannel1, (p.xz + disp) / 128.0).rgb;\n\n    bvec3 contains = lessThanEqual(vec3(0.0), (terr - p.y/16.0));\n    if (contains.x && contains.y && !contains.z) terrainType = VOXEL_SAND;\n    else if (contains.x && contains.z) terrainType = VOXEL_GRASS;\n    else if (contains.y && contains.z && !contains.x) terrainType = VOXEL_STONE;\n    else if (contains.x || contains.y || contains.z) terrainType = VOXEL_EARTH;\n}\n\nfloat dfVoxel(vec3 p, int terrainType)\n{\n    float r = 0.1;\n    if (terrainType == VOXEL_WATER) r = 0.0;\n    return length(max(abs(p)-vec3(0.5-r),0.0))-r;\n}\n\nvec3 nrmVoxel(vec3 p, int terrainType) \n{\n    vec2 dd = vec2(0.001,0.0);\n    float base = dfVoxel(p, terrainType);\n    return normalize(vec3(\n        dfVoxel(p+dd.xyy, terrainType) - base,\n        dfVoxel(p+dd.yxy, terrainType) - base,\n        dfVoxel(p+dd.yyx, terrainType) - base\n    ));\n}\n\nVoxelMarchResult voxelMarch(vec3 ro, vec3 rd) \n{\n    ivec3 mapPos = ivec3(floor(ro));\n    vec3 deltaDist = abs(vec3(length(rd)) / rd);\n    ivec3 rayStep = ivec3(sign(rd));\n    vec3 sideDist = (sign(rd) * (vec3(mapPos) - ro) + (sign(rd) * 0.5) + 0.5) * deltaDist; \n    vec2 volAccum = vec2(0.0);\n    float prevDist = 0.0;\n    \n    VoxelMarchResult result;\n\t\n    for (int i = 0; i < 96; i++) {\n\n        // check current position for voxel\n        vec2 occlusions;  int terrainType;\n        getVoxelAndOcclusionsAt(mapPos, terrainType, occlusions);\n        \n        // if intersected, save\n        if (terrainType != VOXEL_NONE) {\n            VoxelHit newVoxelHit = VoxelHit(mapPos, terrainType, volAccum, vec3(0.0), vec3(0.0), 0.0);\n            if (result.first.terrainType == VOXEL_NONE) {\n                result.first = newVoxelHit;\n            } else if (result.first.terrainType != VOXEL_WATER || terrainType != VOXEL_WATER) {\n                result.second = newVoxelHit;\n                break; // two intersections, stop stepping!\n            }\n        }\n\n        // march forward to next position\n        float newDist = min( sideDist.x, min(sideDist.y, sideDist.z ));\n        vec3 mi = step( sideDist.xyz, sideDist.yzx ); \n        vec3 mm = mi*(1.0-mi.zxy);\n        sideDist += mm * vec3(rayStep) / rd;\n        mapPos += ivec3(mm)*rayStep;\n        \n        // accumulate occlusions\n        volAccum += occlusions * (newDist - prevDist);\n        prevDist = newDist;\n    }\n    \n    // last result should always have max fog\n    result.second.volAccum = volAccum;\n    \n    // if there was no intersection, set accumulated fog on first hit and return\n    if (result.first.terrainType == VOXEL_NONE) {\n        result.first.volAccum = volAccum;\n        result.first.weight = 1.0;\n        return result;\n    }\n    \n    // distance march to intersect first voxel\n    vec3 hitVoxelCenter = vec3(result.first.mapPos) + 0.5;\n    vec3 cubeIntersect = (hitVoxelCenter - ro - 0.5*sign(rd))/rd;\n    float dist = max(cubeIntersect.x, max(cubeIntersect.y, cubeIntersect.z));\n    float diff; float mindiff = 1.0; float finaldist = 0.0;\n    for (int i=0; i<8; i++) {\n        vec3 p = ro + rd * dist;\n        diff = dfVoxel(p - hitVoxelCenter, result.first.terrainType);\n        if (diff < mindiff) {\n            mindiff = diff;\n            finaldist = dist;\n        }\n        dist += diff; \n    }\n    \n    float pixSizeApprox = 2.0/iResolution.x * finaldist; // the FOV is actually about 1 radian :)\n    result.first.weight = smoothstep(pixSizeApprox, 0.0, mindiff - 0.01); // anti-alias blend\n    result.first.hitRel = ro + rd * finaldist - hitVoxelCenter;\n    result.first.hitNormal = nrmVoxel(result.first.hitRel, result.first.terrainType);\n    \n    // if it was water, adjust weight for surface reflection\n    if (result.first.terrainType == VOXEL_WATER) result.first.weight = 0.5;\n    \n    // do a cube intersection for the second voxel\n    hitVoxelCenter = vec3(result.second.mapPos) + 0.5;\n    cubeIntersect = (hitVoxelCenter - ro - 0.5*sign(rd))/rd;\n    dist = max(cubeIntersect.x, max(cubeIntersect.y, cubeIntersect.z));\n    result.second.hitRel = ro + rd * dist - hitVoxelCenter;\n    \n    // attempt to improve a little with distance marching\n    for (int i=0; i<4; i++) {\n        vec3 p = ro + rd * dist;\n        diff = dfVoxel(p - hitVoxelCenter, result.first.terrainType);\n        dist += diff; \n    }\n    if (diff < 0.05) result.second.hitRel = ro + rd * dist - hitVoxelCenter;\n    \n    result.second.weight = 1.0 - result.first.weight;\n    result.second.hitNormal = nrmVoxel(result.second.hitRel, result.second.terrainType);\n    \n    return result;\n}\n\nfloat marchShadowCheck(VoxelHit hit)\n{\n    vec3 ro = hit.hitRel + vec3(hit.mapPos) + 0.5;\n    vec3 rd = SUN_DIRECTION;\n    ro += rd*0.11;\n    \n    ivec3 mapPos = ivec3(floor(ro));\n    vec3 deltaDist = abs(vec3(length(rd)) / rd);\n    ivec3 rayStep = ivec3(sign(rd));\n    vec3 sideDist = (sign(rd) * (vec3(mapPos) - ro) + (sign(rd) * 0.5) + 0.5) * deltaDist; \n\tfloat fogAccum = 0.0;\n    float prevDist = 0.0;\n    \n    for (int i = 0; i < 16; i++) {\n\n        // check current position for voxel\n        vec2 occlusions;  int terrainType;\n        getVoxelAndOcclusionsAt(mapPos, terrainType, occlusions);\n        \n        // if intersected, finish\n        if (terrainType != VOXEL_NONE) {\n            return 1.0;\n        }\n\n        // march forward to next position\n        float newDist = min( sideDist.x, min(sideDist.y, sideDist.z ));\n        vec3 mi = step( sideDist.xyz, sideDist.yzx ); \n        vec3 mm = mi*(1.0-mi.zxy);\n        sideDist += mm * vec3(rayStep) / rd;\n        mapPos += ivec3(mm)*rayStep;\n        \n        // accumulate fog\n        fogAccum += occlusions.x * (newDist - prevDist);\n        prevDist = newDist;\n    }\n    \n    // no intersection\n    return fogAccum / 5.0;\n}\n\nfloat calcAmbientOcclusion(VoxelHit hit)\n{\n    float ambientOcc = 0.0;\n    \n    // for each of the 28 voxels surrounding the hit voxel\n    for (int i=-1; i<=1; i++) for (int j=-1; j<=1; j++) for (int k=-1; k<=1; k++) {\n        if (i == 0 && j == 0 && k == 0) continue; // skip the hit voxel\n        ivec3 offset = ivec3(i, j, k);\n        // TODO: find some way to skip these voxels\n        // if (dot(hit.hitRel, vec3(offset)) < 0.0) continue; \n        \n        int terrainType; vec2 occlusions;\n        getVoxelAndOcclusionsAt(hit.mapPos + offset, terrainType, occlusions);\n        if (terrainType != VOXEL_NONE && terrainType != VOXEL_WATER) {\n            \n            // use the distance from just above the intersection to estimate occlusion\n            float dist = dfVoxel(hit.hitRel + hit.hitNormal*0.5 - vec3(offset), terrainType);\n            ambientOcc += smoothstep(1.0, 0.0, dist);\n        }\n    }\n    \n    return ambientOcc / 8.0;\n}\n\nvec3 doColoring(VoxelHit hit, vec3 rd)\n{   \n    // global position for non-repeating noise\n    vec3 hitGlobal = vec3(hit.mapPos) + hit.hitRel + 0.5;\n    float f1 = noise(hitGlobal*19.0);\n    float f2 = noise(hitGlobal*33.0);\n    float f3 = noise(hitGlobal*71.0);\n    \n    vec3 color = vec3(0.0);\n    if (hit.terrainType == VOXEL_WATER) {\n        color = vec3(0.4, 0.4, 0.8) * (0.8 + f1*0.1 + f2*0.05 + f3*0.05);\n    } else if (hit.terrainType == VOXEL_EARTH) {\n        color = vec3(1.0, 0.7, 0.3) * (f1*0.13 + f2*0.13 + f3*0.1 + 0.3);\n    } else if (hit.terrainType == VOXEL_SAND) {\n        color = vec3(1.0, 1.0, 0.6) * (f1*0.07 + f2*0.07 + f3*0.2 + 0.5);\n    } else if (hit.terrainType == VOXEL_STONE) {\n        color = vec3(0.5) * (f1*0.3 + f2*0.1 + 0.6);\n    } else if (hit.terrainType == VOXEL_GRASS) {\n        color = vec3(0.3, 0.7, 0.4) * (f1*0.1 + f3*0.1 + 0.6);\n    }  else if (hit.terrainType == VOXEL_NONE) {\n        color = vec3(0.0, 1.0, 1.0);\n        color += vec3(5.0, 3.0, 0.0)*pow(max(dot(rd, SUN_DIRECTION), 0.0), 128.0);\n    }\n    \n    float shadow = min(marchShadowCheck(hit), 1.0);\n    float ambient = 1.0 - calcAmbientOcclusion(hit);\n    float diffuse = max(dot(SUN_DIRECTION, hit.hitNormal), 0.0);\n    diffuse = diffuse*(1.0-shadow);\n    \n    color *= diffuse * 0.6 + ambient * 0.4;\n    \n    vec2 occlusions = smoothstep(vec2(0.0), vec2(10.0, 3.0), hit.volAccum);\n    color = mix(color, vec3(0.3, 0.3, 0.5), occlusions.y); // water\n    color = mix(color, vec3(0.6), occlusions.x);           // cloud\n    \n    // blend with other intersection. will be fractional when anti-aliasing or underwater\n    color *= hit.weight;\n    \n    return color;\n}\n\n\nVoxelHit marchReflection(VoxelHit hit, vec3 prevrd)\n{\n    vec3 ro = hit.hitRel + vec3(hit.mapPos) + 0.5;\n    vec3 rd = reflect(prevrd, hit.hitNormal);\n    ro += 0.01*rd;\n    \n    ivec3 mapPos = ivec3(floor(ro));\n    vec3 deltaDist = abs(vec3(length(rd)) / rd);\n    ivec3 rayStep = ivec3(sign(rd));\n    vec3 sideDist = (sign(rd) * (vec3(mapPos) - ro) + (sign(rd) * 0.5) + 0.5) * deltaDist; \n    vec2 volAccum = hit.volAccum;\n    float prevDist = 0.0;\n\t\n    for (int i = 0; i < 16; i++) {\n\n        // check current position for voxel\n        vec2 occlusions;  int terrainType;\n        getVoxelAndOcclusionsAt(mapPos, terrainType, occlusions);\n        \n        // if intersected, finish\n        if (terrainType != VOXEL_NONE) {\n            vec3 hitVoxelCenter = vec3(mapPos) + 0.5;\n    \t\tvec3 cubeIntersect = (hitVoxelCenter - ro - 0.5*sign(rd))/rd;\n    \t\tfloat dist = max(cubeIntersect.x, max(cubeIntersect.y, cubeIntersect.z));\n            vec3 hitRel = ro + rd * dist - hitVoxelCenter;\n            return VoxelHit(mapPos, terrainType, volAccum, hitRel, nrmVoxel(hitRel, terrainType), 1.0);\n        }\n\n        // march forward to next position\n        float newDist = min( sideDist.x, min(sideDist.y, sideDist.z ));\n        vec3 mi = step( sideDist.xyz, sideDist.yzx ); \n        vec3 mm = mi*(1.0-mi.zxy);\n        sideDist += mm * vec3(rayStep) / rd;\n        mapPos += ivec3(mm)*rayStep;\n        \n        // accumulate occlusions\n        volAccum += occlusions * (newDist - prevDist);\n        prevDist = newDist;\n    }\n    \n    // no intersection\n    return VoxelHit(mapPos, VOXEL_NONE, volAccum, vec3(0.0), vec3(0.0), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera stolen from Shane :) https://www.shadertoy.com/view/ll2SRy\n\tvec2 uv = (fragCoord - iResolution.xy*.5 )/iResolution.y;\n    vec3 rd = normalize(vec3(uv, (1.-dot(uv, uv)*.5)*.5));\n    vec3 ro = vec3(0., 10., iTime*10.0);\n    float t = sin(iTime * 0.2) + noise(ro/32.0);\n    ro.y += 4.0*t;\n\tfloat cs = cos( t ), si = sin( t );\n    rd.yz = mat2(cs, si,-si, cs)*rd.yz;\n    rd.xz = mat2(cs, si,-si, cs)*rd.xz;\n    \n    // voxel march into the scene storing up to four intersections\n    VoxelMarchResult result = voxelMarch(ro, rd);\n    \n    // if first intersection is with water surface, march reflection\n    if (result.first.terrainType == VOXEL_WATER) {\n        result.first = marchReflection(result.first, rd);\n        result.first.weight = 0.5;\n        result.second.weight = 0.5;\n    }\n    \n    // color\n    vec3 color1 = doColoring(result.first, rd);\n    vec3 color2 = doColoring(result.second, rd);\n    vec3 color = color1 + color2;\n    \n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xl3XzS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlcSR2", "name": "Daily Shader 26: rolling shutter", "author": "psonice", "description": "Having failed on day 25, here's a simple rolling shutter effect illustration. ", "tags": ["raymarch", "rollingshutter"], "likes": 2, "viewed": 538, "date": "1480521126", "time_retrieved": "2024-06-20T18:45:19.424998", "image_code": "/* \nDay 25: mission failed.\nDay 26:\n*/\n\n//#define DEBUG\n#ifdef DEBUG\nint debugStep = 0;\nfloat debugValue = 0.0;\n#endif\n\n// Rotation\n#define R(p,a) p=cos(a)*p+sin(a)*vec2(-p.y,p.x);\n\n\n#define kINFINITY 10000.0 // An unimaginably large number\n#define kSQRT2 1.414213\n#define kISQRT2 0.707107\n#define kPI 3.141592\n\n// maximum iteration count\n#define kMAXITERS 250\n#define kEPSILON 0.001\n#define kMAXINTERSECTIONS 1\n\n// refractive index\n#define kREFRACT 1.0/1.5\n\n// materials\n#define kFLOORMATERIAL 0\n#define kGLASSMATERIAL 1\n#define kMIRRORMATERIAL 2\n#define kGLOWMATERIAL 3\n#define kMATTEMATERIAL 4\n\n#define kFLOORCOLOUR vec3(0.7, 0.65, 0.6)\n#define kGLASSCOLOUR vec3(0.9)\n#define kMIRRORCOLOUR vec3(0.9)\n#define kMIRRORCOLOUR2 vec3(0.5)\n#define kGLOWCOLOUR vec3(0.5)\n\n#define kZENITHCOLOUR vec3(0.3, 0.7, 1.0)\n#define kNADIRCOLOUR vec3(0.7, 0.6, 0.4)\n#define kHORIZONCOLOUR vec3(0.95)\n#define kSUNCOLOUR vec3(100, 90, 70)\n\n// A ray. Has origin + direction.\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n    \n// Distance to nearest surface\nstruct SDResult {\n    float d; // Distance\n    int material; // Nearest material\n};\n\n// A camera. Has a position and a direction. \nstruct Camera {\n    vec3 pos;\n    Ray ray;\n};\n    \n// A disk. Has position, size, colour.\nstruct Disk {\n    vec3 pos;\n    float radius;\n    vec3 col;\n};\n    \nstruct Sphere {\n    vec3 pos;\n    float radius;\n};\n    \nstruct Box {\n\tvec3 pos;\n\tvec3 size;\n    float radius;\n};\n    \nfloat time;\nfloat eps = kEPSILON;\nfloat divergence;\n\nvec3 smoothBlend(in vec3 point, in vec3 about, in float radius) {\n    point -= about;\n    point = mix(-point, point, smoothstep(-radius, radius, point));\n    return point + about;\n}\n    \n// Distance to sphere (signed)\nfloat sphereDist(in Ray ray, in Sphere sphere) {\n    return length(ray.origin - sphere.pos) - sphere.radius;\n}\n\n// Distance to sphere surface\nfloat uSphereDist(in Ray ray, in Sphere sphere) {\n    return abs(length(ray.origin - sphere.pos) - sphere.radius);\n}\n\n// Distance to box surface (signed)\nfloat boxDist(in Ray ray, in Box box) {\n    vec3 dist = abs(ray.origin - box.pos) - (box.size * 0.5);\n    vec3 cDist = max(dist, 0.0);\n    return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(cDist) - box.radius;\n}\n\n// Distance to box surface\nfloat uBoxDist(in Ray ray, in Box box) {\n    return abs(length(max(abs(ray.origin - box.pos) - (box.size * 0.5), 0.0)) - box.radius);\n}\n\n// distance to floor\nfloat floorDist(in Ray ray) {\n    float dist = ray.origin.y;\n    return dist;\n}\n\n// traced coords of floor intersection, floor at height y\nvec2 floorPos(in Ray ray, in float y) {\n    float dist = (ray.origin.y - y) / ray.dir.y;\n \treturn ray.origin.xz + ray.dir.xz * dist; \n}\n\n/*\n---- Random/hash stuff ----\n*/\n\n// Normalised random number, borrowed from Hornet's noise distributions: https://www.shadertoy.com/view/4ssXRX\nfloat nrand(in vec2 n) {\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\n// random value based on texture channel 2\nvec3 texrand(in vec2 n, in float mipLevel) {\n    return texture(iChannel2, n, mipLevel).xyz;\n}\n\n// returns a hash value for a fixed size cell\nfloat hashForCell(in vec3 pos, in float cellSize) {\n    float hash = nrand(floor(pos.xz / cellSize) + 68.0);\n    return hash;\n}\n\n// returns a random colour based on the cell hash\nvec3 randomColourForCell(in vec3 pos, in float cellSize) {\n\tfloat hash = hashForCell(pos, cellSize); \n    return vec3(\n        nrand(vec2(hash * 2.0, hash * 4.0)),\n        nrand(vec2(hash * 4.0, hash * 8.0)),\n        nrand(vec2(hash * 8.0, hash * 16.0))\n\t);\n\tvec3 c = vec3(hash, mod(hash + 0.15, 1.0), mod(hash + 0.3, 1.0)) * 0.75;\n}\n\n/*\n---- INTERSECTION OPS ----\n*/\n\n// Union of two signed distances\nfloat unionOp(float d0, float d1) {\n    return min(d0, d1);\n}\n\n// Intersection of two signed distances\nfloat intersectOp(float d0, float d1) {\n    return max(d0, d1);\n}\n\n// Difference of two signed distances\nfloat differenceOp(float d0, float d1) {\n    return max(d0, -d1);\n}\n\t\n// from http://www.iquilezles.org/www/articles/smin/smin.htm\n// polynomial smooth min (k = 0.1); \nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n/*\n---- Scene rendering ----\n*/\n\n// Get the distance to the scene (returns a struct containing distance and nearest material)\nSDResult sceneDist(in Ray ray) {\n    SDResult result;\n    \n    //float floorDist = ray.origin.z+0.5;\n    \n    Box b0 = Box(vec3(0,5,0), vec3(0.3, 8, 0.1), 0.1);\n   // Box b1 = Box(vec3(0,5,0), vec3(8, 0.3, 0.1), 0.1);\n    \n    ray.origin.y -= 5.0;\n    R(ray.origin.xy, time*time);\n    ray.origin.y += 5.0;\n    result.d = boxDist(ray, b0);\n    ray.origin.y -= 5.0;\n    R(ray.origin.xy, kPI / 3.0);\n    ray.origin.y += 5.0;\n    result.d = unionOp(result.d, boxDist(ray, b0));\n    ray.origin.y -= 5.0;\n    R(ray.origin.xy, kPI / 3.0);\n    ray.origin.y += 5.0;\n    result.d = unionOp(result.d, boxDist(ray, b0));\n    \n    //result.d = unionOp(result.d, floorDist);\n    \n    result.material = kMIRRORMATERIAL;\n    \n    return result;\n}\n\n// Gets the normal\nvec3 normal(in Ray ray) {\n    vec2 eps = vec2(0.0001, 0);\n    float baseDist = sceneDist(ray).d;\n \treturn normalize(vec3(\n        sceneDist(Ray(ray.origin + eps.xyy, ray.dir)).d - \n        sceneDist(Ray(ray.origin - eps.xyy, ray.dir)).d,\n        sceneDist(Ray(ray.origin + eps.yxy, ray.dir)).d -\n        sceneDist(Ray(ray.origin - eps.yxy, ray.dir)).d,\n        sceneDist(Ray(ray.origin + eps.yyx, ray.dir)).d -\n        sceneDist(Ray(ray.origin - eps.yyx, ray.dir)).d\n        ));\n}\n\n// Moves the ray to the surface. Helps avoid artefacts due to ray intersection imprecision.\nvoid clampToSurface(in Ray ray, in float d, inout vec3 n) {\n    for (int i=0; i<5; i++) {\n \t\tray.origin += n * d*0.5;\n \t\td = sceneDist(ray).d;\n \t\tn = normal(ray);\n    }\n}\n\n// Calulcate a fresnel term for reflections\nfloat fresnelTerm(in Ray ray, in vec3 n, in float power) {\n\tfloat fresnel = min(1., dot(ray.dir, n) + 1.0);\n\tfresnel = pow(fresnel, power);\n    return fresnel;\n}\n\n/*\n---- LIGHTING ----\n*/\n\n// Pretty background colour of some sort...\nvec3 backgroundColour (in Ray ray, in float divergence) {\n    return vec3(1);\n    // Declare a horizon and extremity (either zenith or nadir)\n    vec3 base, extremity, texture;\n    float x = smoothstep(0.0,1.0,abs(ray.dir.y));\n   // base = mix(vec3(0.05, 0.1, 0.2), vec3(0.0), x);\n    \n    if (ray.dir.y >= 0.0) {\n        // sky: fake as hell clouds\n    \tbase = mix(kHORIZONCOLOUR, kZENITHCOLOUR, x);\n        texture = vec3(1);\n        float cloudFactor = 0.0;\n        \n        vec2 coord = ray.dir.xz / 8.0;\n        float scale = 1.0;\n        for (int i=0; i<4; i++) {\n            float offset = iTime * 0.03 / scale;\n            cloudFactor += texrand(coord + vec2(0, -offset), 3.0).r * scale;\n            coord *= 2.0;\n            scale *= 0.5;\n        }\n        cloudFactor /= 1.5;\n        vec3 cloud = mix(vec3(0.4), vec3(1), cloudFactor);\n        base = mix(base, cloud, cloudFactor * ray.dir.y * ray.dir.y);\n        \n    } else {\n        // ground: fake as hell desert\n        texture = kNADIRCOLOUR * 0.5;\n        vec2 floorCoord = floorPos(ray, -30.0) + vec2(0, iTime * 100.0);\n        texture *= (sin(floorCoord.x * .183 + floorCoord.y * 0.183 + sin(floorCoord.y * 0.3) * 0.5) \n                    + sin(floorCoord.x * .15 + floorCoord.y * 0.22 + sin(floorCoord.x * 0.26) * 0.5))\n            * 0.25 + 0.5;\n\t\tbase = mix(kHORIZONCOLOUR, kNADIRCOLOUR + texture, x);\n        \n    }\n    \n    \n    \n    return base;\n}\n\n// Technically broken, but seems to make soft shadows? *shrug*\nfloat occlusion(in Ray ray, in vec3 n) {\n    vec3 origin = ray.origin;\n    float o = 0.0;\n    \n    ray.dir = n;\n    float x = eps*2.0;\n    origin += ray.dir * x;\n    for (float i=1.0; i<7.0; i++) {\n    \tray.origin = origin + ray.dir * x;\n        float d = sceneDist(ray).d;\n        o += max(x - d, 0.0) / x / (i);\n        \n        x *= 2.0;\n    }\n \treturn 1.0 - o;\n}\n\nvec3 highlight(in Ray ray, in vec3 n) {\n    // sun\n\tvec3 sunDir = normalize(vec3(1,0.3,1));\n\tfloat sunDist = distance(sunDir, ray.dir)-0.00;\n\treturn mix(vec3(10,10,8), vec3(0), smoothstep(0.0, 0.2, sunDist));\n}\n\n/*\n---- RAY MARCHING ----\n*/\n\n// The main marching loop\nvoid marchRay(inout Ray ray, inout vec3 colour) {\n    bool inside = false; // are we inside or outside the glass object\n    vec3 impact = vec3(1); // This decreases each time the ray passes through glass, darkening colours\n\n    vec3 startpoint = ray.origin;\n    \n#ifdef DEBUG   \nvec3 debugColour = vec3(1, 0, 0);\n#endif\n    \n    SDResult result;\n    vec3 n;\n    vec3 glassStartPos;\n    \n    //float glow = 0.0;\n    \n    for (int i=0; i<kMAXITERS; i++) {\n        // Get distance to nearest surface\n        result = sceneDist(ray);\n        \n        //glow += result.material == kGLOWMATERIAL ? \n        //    pow(max(0.0, (80.0 - result.d) * 0.0125), 4.0) * result.d * 0.01\n        //    : 0.0;\n        \n        // Step half that distance along ray (helps reduce artefacts)\n        float stepDistance = (inside ? abs(result.d) : result.d) * 0.5;\n        ray.origin += ray.dir * stepDistance;\n        \n    //R(ray.origin.yz, stepDistance * cos(x) * 0.003);\n   // R(ray.origin.yz, stepDistance * sin(ray.origin.z*0.1) * 0.01);\n    //R(ray.origin.zx, stepDistance * sin(ray.origin.z*0.1) * 0.001);\n   //R(ray.origin.xy, ray.origin.x * stepDistance * -0.01);\n        //if (length(ray.origin) > 40.0) { break; }\n        \n        if (stepDistance < eps) {\n            // colision\n            // normal\n            // Get the normal, then clamp the intersection to the surface\n    \t\tn = normal(ray);\n            //clampToSurface(ray, stepDistance, n);\n#ifdef DEBUG\n//debugColour = n;\n//break;\n#endif\n            \n            if ( result.material == kFLOORMATERIAL ) {\n                // ray hit floor\n                \n                // Add some noise to the normal, since this is pretending to be grit...\n                vec3 randomNoise = texrand(ray.origin.xz * 0.4, 0.0);\n                randomNoise.xz = randomNoise.xz * 2. - 1.;\n                n = mix(n, normalize(vec3(randomNoise.x, 1, randomNoise.y)), randomNoise.z * 0.3);\n                \n                // Colour is just grey with crappy fake lighting...\n                float o = occlusion(ray, n);\n                colour += vec3(1) * o * impact;\n                impact *= 0.;\n                break;\n            }\n            \n            if ( result.material == kMATTEMATERIAL ) {\n                // ray hit floor\n                \n                // Add some noise to the normal, since this is pretending to be grit...\n                vec3 randomNoise = texrand(n.xz * 0.5 + 0.5, 0.0);\n                randomNoise.xz = randomNoise.xz * 2. - 1.;\n               // n = mix(n, normalize(vec3(randomNoise.x, 1, randomNoise.y)), randomNoise.z * 0.1);\n                \n                // Colour is just grey with crappy fake lighting...\n                float o = occlusion(ray, n);\n                colour += vec3(1) * o * impact;\n                impact *= 0.0;\n                \n                //ray.dir = reflect(ray.dir, n);\n                //ray.origin += ray.dir * eps;\n                break;\n            }\n            \n            if (result.material == kGLOWMATERIAL) {\n             \tcolour = mix(colour, kGLOWCOLOUR, impact);\n                impact *= 0.;\n                break;\n            }\n            \n            // check what material it is...\n            \n            if (result.material == kMIRRORMATERIAL) {\n                \n                // handle interior glass / other intersecion\n                if (inside) {\n                     float glassTravelDist =  min(distance(glassStartPos, ray.origin) / 16.0, 1.);\n    \t\t\t\tglassStartPos = ray.origin;\n                    // mix in the colour\n                \timpact *= mix(kGLASSCOLOUR, kGLASSCOLOUR * 0.1, glassTravelDist);\n                    \n                }\n                \n                // it's a mirror, reflect the ray\n                ray.dir = reflect(ray.dir, n);\n                    \n                // Step 2x epsilon into object along normal to ensure we're beyond the surface\n                // (prevents multiple intersections with same surface)\n                ray.origin += n * eps * 4.0;\n                \n                // Mix in the mirror colour\n                colour += highlight(ray, n);\n                impact *= kMIRRORCOLOUR;\n                float o = occlusion(ray, n);\n                impact *= o;\n#ifdef DEBUG\ndebugColour = vec3(o);\nbreak;\n#endif\n                \n            } else {\n                // glass material\n            \n                if (inside) {\n                \t// refract glass -> air\n                \tray.dir = refract(ray.dir, -n, 1.0/kREFRACT);\n                    \n                    // Find out how much to tint (how far through the glass did we go?)\n                    float glassTravelDist =  min(distance(glassStartPos, ray.origin) / 16.0, 1.);\n    \n                    // mix in the colour\n                \timpact *= mix(kGLASSCOLOUR, kGLASSCOLOUR * 0.1, glassTravelDist);\n                    \n#ifdef DEBUG\ndebugValue += glassTravelDist / 2.0;\n#endif\n      \n                \n              \t} else {\n               \t\t// refract air -> glass\n                \tglassStartPos = ray.origin;\n                    \n              \t  \t// Mix the reflection in, according to the fresnel term\n                \tfloat fresnel = fresnelTerm(ray, n, 1.0);\n                    fresnel = fresnel;\n    \t\t\t\t/*\n                    colour = mix(\n                    \tcolour, \n                    \ttexture(iChannel1, reflect(ray.dir, n)), \n                    \tvec4(fresnel) * impact);\n*/\n                    colour = mix(\n                        colour,\n                        backgroundColour(ray, 0.0),\n                        vec3(fresnel) * impact);\n                \tcolour += n.x * 0.1;//highlight(ray, n);\n                    impact *= 1.0 - fresnel;\n    \t\t\t\n                \t// refract the ray\n            \t\tray.dir = refract(ray.dir, n, kREFRACT);\n                    \n#ifdef DEBUG\n//debugValue += 0.5;\n#endif\n                }\n            \n            \t// Step 2x epsilon into object along normal to ensure we're beyond the surface\n                ray.origin += (inside ? n : -n) * eps * 2.0;\n                \n                // Flip in/out status\n                inside = !inside;\n            }\n        }\n        \n        // increase epsilon\n        eps += divergence * stepDistance;\n    }\n    \n    // So far we've traced the ray and accumulated reflections, now we need to add the background.\n   // colour += texture(iChannel0, ray.dir) * impact;\n    ray.origin = startpoint;\n    colour.rgb += backgroundColour(ray, 0.0) * impact; // + glow * kGLOWCOLOUR;\n    \n#ifdef DEBUG\n//debugColour.rgb = ray.dir;\n//debugColour = vec3(float(debugStep)/2.0);\ncolour = debugColour;\n#endif\n}\n\n// Sets up a camera at a position, pointing at a target.\n// uv = fragment position (-1..1) and fov is >0 (<1 is telephoto, 1 is standard, 2 is fisheye-like)\nCamera setupCam(in vec3 pos, in vec3 target, in float fov, in vec2 uv) {\n\t\t// cam setup\n    // Create camera at pos\n\tCamera cam;\n    cam.pos = pos;\n    \n    // A ray too\n    Ray ray;\n    ray.origin = pos;\n    \n    // FOV is a simple affair...\n    uv *= fov;\n    \n    // Now we determine hte ray direction\n\tvec3 cw = normalize (target - pos );\n\tvec3 cp = vec3 (0.0, 1.0, 0.0);\n\tvec3 cu = normalize ( cross(cw,cp) );\n\tvec3 cv = normalize ( cross (cu,cw) );\n    \n\tray.dir = normalize ( uv.x*cu + uv.y*cv + 0.5 *cw);\n    \n    // Add the ray to the camera and our work here is done.\n\tcam.ray = ray;\n    \n    // Ray divergence\n    divergence = fov / iResolution.x;\n    \n\treturn cam;\n}\n\nvec3 camPath(in float time) {\n    \n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = mouse * kPI * 2.0 + kPI;\n    \n    vec3 camPos = vec3(0, 5, 5);\n\t\n    R(camPos.xz, -time*0.1 + mouse.x);\n   //camPos.z += time;\n    //R(camPos.xy, mouse.y);\n    \n    return camPos;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime;\n    \n    // We'll need a camera. And some perspective.\n    \n\t// Get some coords for the camera angle from the frag coords. Convert to -1..1 range.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2. - 1.;\n    \n    // Aspect correction so we don't get oval bokeh\n    uv.y *= iResolution.y/iResolution.x;\n    \n    // Make a camera with ALL NEW AND IMPROVED! camera code :)\n    float camTime = iTime;\n    vec3 camPos = camPath(camTime);\n    vec3 camTarget = vec3(0);\n    camTarget.y = 5.0;\n    //camTarget.y -= 3.0;\n    Camera cam = setupCam(camPos, camTarget, 1.0, uv);\n    \n    time += uv.y*0.1;\n    \n    // Let's raymarch some stuff and inject that into the scene...\n    \n    // Create an empty colour\n    vec3 col = vec3(0);\n    \n    // Trace that ray!\n    marchRay(cam.ray, col);\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlcSR2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlcSz2", "name": "filtered checker (box, 2D)", "author": "iq", "description": "A cheap analytical approximation to a filtered checkerboard pattern. Mostly copy and pasted from [url]http://http.developer.nvidia.com/GPUGems/gpugems_ch25.html[/url]. See also [url]https://www.shadertoy.com/view/MdjGR1[/url]. Move mouse.", "tags": ["procedural", "2d", "filter", "checker"], "likes": 77, "viewed": 4823, "date": "1480474906", "time_retrieved": "2024-06-20T18:45:21.055388", "image_code": "// The MIT License\n// Copyright Â© 2017 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Similar to https://www.shadertoy.com/view/XlXBWs, but with a triangular filter kernel,\n// which produces less flickering animations that a box filter. Luckily, it's still easily\n// integrable analytically! Full description in this article:\n//\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\n//\n// Inspired by http://http.developer.nvidia.com/GPUGems/gpugems_ch25.html and improved\n//\n// Info: http://iquilezles.org/www/articles/filterableprocedurals/filterableprocedurals.htm\n//  \n// More filtered patterns:  https://www.shadertoy.com/playlist/l3KXR1\n\n\n\n// --- analytically box-filtered checkerboard ---\n\nfloat checkersTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n    // filter kernel\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;  \n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)/2.0)-0.5)-abs(fract((p+0.5*w)/2.0)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\n// --- unfiltered checkerboard ---\n\nfloat checkersTexture( in vec2 p )\n{\n    vec2 q = floor(p);\n    return mod( q.x+q.y, 2.0 );            // xor pattern\n}\n\n\n//===============================================================================================\n//===============================================================================================\n// sphere implementation\n//===============================================================================================\n//===============================================================================================\n\nfloat softShadowSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    vec3 oc = sph.xyz - ro;\n    float b = dot( oc, rd );\n\t\n    float res = 1.0;\n    if( b>0.0 )\n    {\n        float h = dot(oc,oc) - b*b - sph.w*sph.w;\n        res = smoothstep( 0.0, 1.0, 2.0*h/b );\n    }\n    return res;\n}\n\nfloat occSphere( in vec4 sph, in vec3 pos, in vec3 nor )\n{\n    vec3 di = sph.xyz - pos;\n    float l = length(di);\n    return 1.0 - dot(nor,di/l)*sph.w*sph.w/(l*l); \n}\n\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    float t = -1.0;\n\tvec3  ce = ro - sph.xyz;\n\tfloat b = dot( rd, ce );\n\tfloat c = dot( ce, ce ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h>0.0 )\n\t{\n\t\tt = -b - sqrt(h);\n\t}\n\t\n\treturn t;\n}\n\n//===============================================================================================\n//===============================================================================================\n// scene\n//===============================================================================================\n//===============================================================================================\n\n\n// spheres\nconst vec4 sc0 = vec4(  3.0, 0.5, 0.0, 0.5 );\nconst vec4 sc1 = vec4( -4.0, 2.0,-5.0, 2.0 );\nconst vec4 sc2 = vec4( -4.0, 2.0, 5.0, 2.0 );\nconst vec4 sc3 = vec4(-30.0, 8.0, 0.0, 8.0 );\n\nfloat intersect( vec3 ro, vec3 rd, out vec3 pos, out vec3 nor, out float occ, out int matid )\n{\n    // raytrace\n\tfloat tmin = 10000.0;\n\tnor = vec3(0.0);\n\tocc = 1.0;\n\tpos = vec3(0.0);\n    matid = -1;\n\t\n\t// raytrace-plane\n\tfloat h = (0.01-ro.y)/rd.y;\n\tif( h>0.0 ) \n\t{ \n\t\ttmin = h; \n\t\tnor = vec3(0.0,1.0,0.0); \n\t\tpos = ro + h*rd;\n\t\tmatid = 0;\n\t\tocc = occSphere( sc0, pos, nor ) * \n\t\t\t  occSphere( sc1, pos, nor ) *\n\t\t\t  occSphere( sc2, pos, nor ) *\n\t\t\t  occSphere( sc3, pos, nor );\n\t}\n\n\n\t// raytrace-sphere\n\th = iSphere( ro, rd, sc0 );\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n        pos = ro + h*rd;\n\t\tnor = normalize(pos-sc0.xyz); \n\t\tmatid = 1;\n\t\tocc = 0.5 + 0.5*nor.y;\n\t}\n\n\th = iSphere( ro, rd, sc1 );\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n        pos = ro + tmin*rd;\n\t\tnor = normalize(pos-sc1.xyz); \n\t\tmatid = 2;\n\t\tocc = 0.5 + 0.5*nor.y;\n\t}\n\n\th = iSphere( ro, rd, sc2 );\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n        pos = ro + tmin*rd;\n\t\tnor = normalize(pos-sc2.xyz); \n\t\tmatid = 3;\n\t\tocc = 0.5 + 0.5*nor.y;\n\t}\n\n\th = iSphere( ro, rd, sc3 );\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n        pos = ro + tmin*rd;\n\t\tnor = normalize(pos-sc3.xyz); \n\t\tmatid = 4;\n\t\tocc = 0.5 + 0.5*nor.y;\n\t}\n\n\treturn tmin;\t\n}\n\nvec2 texCoords( in vec3 pos, int mid )\n{\n    vec2 matuv;\n    \n    if( mid==0 )\n    {\n        matuv = pos.xz;\n    }\n    else if( mid==1 )\n    {\n        vec3 q = normalize( pos - sc0.xyz );\n        matuv = vec2( atan(q.x,q.z), acos(q.y ) )*sc0.w;\n    }\n    else if( mid==2 )\n    {\n        vec3 q = normalize( pos - sc1.xyz );\n        matuv = vec2( atan(q.x,q.z), acos(q.y ) )*sc1.w;\n    }\n    else if( mid==3 )\n    {\n        vec3 q = normalize( pos - sc2.xyz );\n        matuv = vec2( atan(q.x,q.z), acos(q.y ) )*sc2.w;\n    }\n    else if( mid==4 )\n    {\n        vec3 q = normalize( pos - sc3.xyz );\n        matuv = vec2( atan(q.x,q.z), acos(q.y ) )*sc3.w;\n    }\n\n\treturn 12.0*matuv;\n}\n\n\nvoid calcCamera( out vec3 ro, out vec3 ta )\n{\n\tfloat an = 0.1*sin(0.1*iTime);\n\tro = vec3( 5.0*cos(an), 0.5, 5.0*sin(an) );\n    ta = vec3( 0.0, 1.0, 0.0 );\n}\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in float occ, in vec3 rd )\n{\n    float sh = min( min( min( softShadowSphere( pos, vec3(0.57703), sc0 ),\n\t\t\t\t              softShadowSphere( pos, vec3(0.57703), sc1 )),\n\t\t\t\t              softShadowSphere( pos, vec3(0.57703), sc2 )),\n                              softShadowSphere( pos, vec3(0.57703), sc3 ));\n\tfloat dif = clamp(dot(nor,vec3(0.57703)),0.0,1.0);\n\tfloat bac = clamp(0.5+0.5*dot(nor,vec3(-0.707,0.0,-0.707)),0.0,1.0);\n    vec3 lin  = dif*vec3(1.50,1.40,1.30)*sh;\n\t     lin += occ*vec3(0.15,0.20,0.30);\n\t     lin += bac*vec3(0.10,0.10,0.10)*(0.2+0.8*occ);\n\n    return lin;\n}\n//===============================================================================================\n//===============================================================================================\n// render\n//===============================================================================================\n//===============================================================================================\n\nvoid calcRayForPixel( in vec2 pix, out vec3 resRo, out vec3 resRd )\n{\n\tvec2 p = (-iResolution.xy + 2.0*pix) / iResolution.y;\n\t\n     // camera movement\t\n\tvec3 ro, ta;\n\tcalcCamera( ro, ta );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\t\n\tresRo = ro;\n\tresRd = rd;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord) / iResolution.y;\n\n    float th = (iMouse.z>0.001) ? (2.0*iMouse.x-iResolution.x)/iResolution.y : 0.0;\n\n\tvec3 ro, rd, ddx_ro, ddx_rd, ddy_ro, ddy_rd;\n\tcalcRayForPixel( fragCoord + vec2(0.0,0.0), ro, rd );\n\tcalcRayForPixel( fragCoord + vec2(1.0,0.0), ddx_ro, ddx_rd );\n\tcalcRayForPixel( fragCoord + vec2(0.0,1.0), ddy_ro, ddy_rd );\n\t\t\n    // trace\n\tvec3 pos, nor;\n\tfloat occ;\n    int mid;\n    float t = intersect( ro, rd, pos, nor, occ, mid );\n\n\tvec3 col = vec3(0.9);\n\tif( mid!=-1 )\n\t{\n#if 1\n\t\t// -----------------------------------------------------------------------\n        // compute ray differentials by intersecting the tangent plane to the  \n        // surface.\t\t\n\t\t// -----------------------------------------------------------------------\n\n\t\t// computer ray differentials\n\t\tvec3 ddx_pos = ddx_ro - ddx_rd*dot(ddx_ro-pos,nor)/dot(ddx_rd,nor);\n\t\tvec3 ddy_pos = ddy_ro - ddy_rd*dot(ddy_ro-pos,nor)/dot(ddy_rd,nor);\n\n\t\t// calc texture sampling footprint\t\t\n\t\tvec2     uv = texCoords(     pos, mid );\n\t\tvec2 ddx_uv = texCoords( ddx_pos, mid ) - uv;\n\t\tvec2 ddy_uv = texCoords( ddy_pos, mid ) - uv;\n#else\n\t\t// -----------------------------------------------------------------------\n        // Because we are in the GPU, we do have access to differentials directly\n        // This wouldn't be the case in a regular raytrace.\n\t\t// It wouldn't work as well in shaders doing interleaved calculations in\n\t\t// pixels (such as some of the 3D/stereo shaders here in Shadertoy)\n\t\t// -----------------------------------------------------------------------\n\t\tvec2 uvw = texCoords( pos, mid );\n\n\t\t// calc texture sampling footprint\t\t\n\t\tvec2 ddx_uvw = dFdx( uvw ); \n        vec2 ddy_uvw = dFdy( uvw ); \n#endif\n\n        \n\t\t// shading\t\t\n\t\tvec3 mate = vec3(0.0);\n\n        if( p.x<th ) mate = vec3(1.0)*checkersTexture( uv );\n        else          mate = vec3(1.0)*checkersTextureGradBox( uv, ddx_uv, ddy_uv );\n            \n        // lighting\t\n\t\tvec3 lin = doLighting( pos, nor, occ, rd );\n\n        // combine lighting with material\t\t\n\t\tcol = mate * lin;\n\t\t\n        // fog\t\t\n        col = mix( col, vec3(0.9), 1.0-exp( -0.00001*t*t ) );\n\t}\n\t\n    // gamma correction\t\n\tcol = pow( col, vec3(0.4545) );\n\n\tcol *= smoothstep( 1.0, 2.0, abs(p.x-th)/(2.0/iResolution.y) );\n\t\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/XlcSz2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlcXD8", "name": "Sine on the normal of Sine", "author": "cubby208", "description": "I realize that this is a REALLY bad way to do this as far as efficiency goes. My problem is that the second line is basically a point on the normal of sin(x). I can not find an equation for the 2nd line.", "tags": ["increaseitrforabettergraph"], "likes": 1, "viewed": 184, "date": "1479177068", "time_retrieved": "2024-06-20T18:45:21.055388", "image_code": "#define ITR 900 //INCREASE this number for a better graph, decrease for a faster one\nfloat col = 0.0;\nvec2 uv = vec2(0.0);\nfloat hue = 0.0;\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nvoid colorPt(in vec2 pt, in float colo)\n{\n    if (length(uv-pt) < 0.001)\n    {\n\t\tcol = 1.0;\n        hue = colo;\n    }\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tuv = fragCoord.xy / iResolution.xy;\n    \n    float tx1 = iTime;\n    float tx2 = iTime * 9.0;\n    for (int i = 0; i < ITR; i++)\n    {\n\t\tfloat x = (float(i) / float(ITR));\n        float dom = x * 4.0 * 3.141592 + tx1;\n        float by = sin(dom) * 0.4  + 0.5;\n        float d = (cos(dom) * 0.4 * 4.0 * 3.141592);\n        float a = atan(d) + (3.141592 / 2.0);\n        float dx = cos(a);\n        float dy = sin(a);\n        float disp = sin(x * 100.0) * sin(iTime * 1.0) * 0.02;\n        colorPt(vec2(x + (dx * disp), by + (dy * disp)), x);\n        colorPt(vec2(x, by), x);\n    }\n    \n    if (hue == 0.0)\n    {\n\t\tfragColor = vec4(vec3(col),1.0);\n    }\n    else\n    {\n        vec3 get = vec3(hue, 1.0, 1.0);\n\t\tfragColor = vec4(hsv2rgb(get), 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlcXD8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlcXWr", "name": "Hillz", "author": "VoidChicken", "description": "A basic hill raymarcher with a raycasted distance field for the plane.", "tags": ["procedural", "3d", "simple", "raymarch", "raycast", "distance", "field"], "likes": 7, "viewed": 151, "date": "1478904179", "time_retrieved": "2024-06-20T18:45:21.055388", "image_code": "#define R(x) (fract(x)<.5?floor(x):ceil(x))\nvec3 tex( vec2 u ) {\n    float k = 0.;\n    k=(sign(sin(u.x*3.14))+sign(sin(u.y*3.14)));\n    float jt =  ((sin(u.x*3.14))+(sin(u.y*3.14)));\n    vec3 i = vec3(.2,.1,0)*pow(abs(1.-clamp(jt, 0., 1.)), 10.);\n    i+=abs(jt)/2.;\n    return i;\n}\nfloat pRTd( vec3 o, vec3 d ) {\n    if (d.y>=0.) return 10.; \n    return ((o.y-2.)/(-d.y));\n}\nfloat smin( float a, float b )\n{\n    float k = 2.;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat map ( vec3 o, vec3 d ) {\n    vec2 sph = (mod(o.xz, 10.)-5.);\n\treturn smin(pRTd(o, d), length(vec3(sph.x, o.y, sph.y))-(4.));    \n}\nfloat trace( vec3 o, vec3 d ) {\n\tfloat t = 0.;\n    for (int i = 0; i < 64; ++i) {\n        float f = map(o+d*t, d);\n        if (t>30.||f<.02) break;\n        t+=f*.7;\n    }\n    return t;\n}\nvoid render ( vec2 u, out vec4 c ) {\n    vec3 col = vec3(1);\n    vec3 o = vec3 (0, 6, iTime*3.),\n        d = normalize(vec3(vec2(iResolution.x/iResolution.y, 1)*(u*2.-1.), 1));\n\t\n    float t = 0.;\n    float hit = 0.;\n    t=trace(o, d);\n    \n    vec3 r = o+t*d;\n    hit=-(map(r, d)-.2);\n    \n    if (hit>=0.) {\n   \t\t col=mix(col, tex(r.xz).rgb, (1.-t/30.));   \n    }\n    col=col*col;\n    col+=texture(iChannel0, u.xy+1000.*(iTime)).r/20.;\n\tcol*=min(1.,iTime*.25);\n    c=1.-exp(-col.xyzx*(1.-pow(length(u-.5), 2.))*2.13);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    render ( uv, fragColor );\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlcXWr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XldSD7", "name": "Daily Shade day 22: Graveyard", "author": "psonice", "description": "Decided to make some fog. Added a suitable scene...", "tags": ["raymarch", "fog", "daily"], "likes": 8, "viewed": 607, "date": "1480032613", "time_retrieved": "2024-06-20T18:45:24.146516", "image_code": "/* \nDay 22: A bit late for halowe'en.\n*/\n\n//#define DEBUG\n#ifdef DEBUG\nint debugStep = 0;\nfloat debugValue = 0.0;\n#endif\n\n// Rotation\n#define R(p,a) p=cos(a)*p+sin(a)*vec2(-p.y,p.x);\n\n\n#define kINFINITY 10000.0 // An unimaginably large number\n#define kSQRT2 1.414213\n#define kISQRT2 0.707107\n#define kPI 3.141592\n\n// maximum iteration count\n#define kMAXITERS 300\n#define kEPSILON 0.001\n#define kMAXINTERSECTIONS 1\n\n// refractive index\n#define kREFRACT 1.0/1.5\n\n// materials\n#define kFLOORMATERIAL 0\n#define kGLASSMATERIAL 1\n#define kMIRRORMATERIAL 2\n#define kMATTEMATERIAL 3\n\n#define kFLOORCOLOUR vec3(0.7, 0.65, 0.6)\n#define kGLASSCOLOUR vec3(1.0, 0.5, 0.1)\n#define kMIRRORCOLOUR vec3(0.8)\n#define kMATTECOLOUR vec3(0.9, 0.85, 0.8)\n\n#define kZENITHCOLOUR vec3(0.3, 0.7, 1.0)\n#define kNADIRCOLOUR vec3(0.7, 0.6, 0.4)\n#define kHORIZONCOLOUR vec3(0.95)\n#define kSUNCOLOUR vec3(100, 90, 70)\n\n// A ray. Has origin + direction.\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n    \n// Distance to nearest surface\nstruct SDResult {\n    float d; // Distance\n    int material; // Nearest material\n};\n\n// A camera. Has a position and a direction. \nstruct Camera {\n    vec3 pos;\n    Ray ray;\n};\n    \n// A disk. Has position, size, colour.\nstruct Disk {\n    vec3 pos;\n    float radius;\n    vec3 col;\n};\n    \nstruct Sphere {\n    vec3 pos;\n    float radius;\n};\n    \nstruct Box {\n\tvec3 pos;\n\tvec3 size;\n    float radius;\n};\n    \nfloat eps = kEPSILON;\nfloat divergence;\n\nvec3 smoothBlend(in vec3 point, in vec3 about, in float radius) {\n    point -= about;\n    point = mix(-point, point, smoothstep(-radius, radius, point));\n    return point + about;\n}\n    \n// Distance to sphere (signed)\nfloat sphereDist(in Ray ray, in Sphere sphere) {\n    return length(ray.origin - sphere.pos) - sphere.radius;\n}\n\n// Distance to sphere surface\nfloat uSphereDist(in Ray ray, in Sphere sphere) {\n    return abs(length(ray.origin - sphere.pos) - sphere.radius);\n}\n\n// Distance to box surface (signed)\nfloat boxDist(in Ray ray, in Box box) {\n    vec3 dist = abs(ray.origin - box.pos) - (box.size * 0.5);\n    vec3 cDist = max(dist, 0.0);\n    return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(cDist) - box.radius;\n}\n\n// Distance to box surface\nfloat uBoxDist(in Ray ray, in Box box) {\n    return abs(length(max(abs(ray.origin - box.pos) - (box.size * 0.5), 0.0)) - box.radius);\n}\n\n// distance to floor\nfloat floorDist(in Ray ray) {\n    float dist = ray.origin.y;\n    return dist;\n}\n\n// traced coords of floor intersection, floor at height y\nvec2 floorPos(in Ray ray, in float y) {\n    float dist = (ray.origin.y - y) / ray.dir.y;\n \treturn ray.origin.xz + ray.dir.xz * dist; \n}\n\n/*\n---- Random/hash stuff ----\n*/\n\n// Normalised random number, borrowed from Hornet's noise distributions: https://www.shadertoy.com/view/4ssXRX\nfloat nrand2(in vec2 n) {\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\n// random value based on texture channel 2\nvec3 texrand(in vec2 n, in float mipLevel) {\n    return texture(iChannel2, n, mipLevel).xyz;\n}\n\n// returns a hash value for a fixed size cell\nfloat hashForCell(in vec3 pos, in float cellSize) {\n    float hash = nrand2(floor(pos.xz / cellSize) + 68.0);\n    return hash;\n}\n\n// returns a random colour based on the cell hash\nvec3 randomColourForCell(in vec3 pos, in float cellSize) {\n\tfloat hash = hashForCell(pos, cellSize); \n    return vec3(\n        nrand2(vec2(hash * 2.0, hash * 4.0)),\n        nrand2(vec2(hash * 4.0, hash * 8.0)),\n        nrand2(vec2(hash * 8.0, hash * 16.0))\n\t);\n\tvec3 c = vec3(hash, mod(hash + 0.15, 1.0), mod(hash + 0.3, 1.0)) * 0.75;\n}\n\n/*\n---- INTERSECTION OPS ----\n*/\n\n// Union of two signed distances\nfloat unionOp(float d0, float d1) {\n    return min(d0, d1);\n}\n\n// Union of two unsigned distances\nfloat unionOpU(float d0, float d1) {\n    return min(d0, d1);\n}\n\nfloat smoothUnionOp(float d0, float d1, float r) {\n    float minD = min(d0, d1);\n    float maxD = max(d0, d1);\n    return mix(minD, maxD, 1. - smoothstep(0.0, r, maxD - minD));\n \treturn min(d0, d1);   \n}\n\n// Intersection of two signed distances\nfloat intersectOp(float d0, float d1) {\n    return max(d0, d1);\n}\n\n// Intersection of two unsigned distances\nfloat intersectOpU(float d0, float d1) {\n    return max(d0, d1);\n}\n\n// Difference of two signed distances\nfloat differenceOp(float d0, float d1) {\n    return max(d0, -d1);\n}\n\n// Difference of two unsigned distances\nfloat differenceOpU(float d0, float d1) {\n    return max(d0, -d1);\n}\n\n/*\n---- Scene rendering ----\n*/\n\n// Get the distance to the scene (returns a struct containing distance and nearest material)\nSDResult sceneDist(in Ray ray) {\n    SDResult result;\n    result.d = ray.origin.y;\n    \n    float hash = hashForCell(ray.origin, 20.0);\n    ray.origin.xz = mod(ray.origin.xz, 20.0)-10.0;\n    \n   \t//R(ray.origin.yz, sin(hash) * 0.2);\n    float bDist1 = boxDist(ray, Box(vec3(0,8,0), vec3(0.5,16,0.5), 0.5));\n    float bDist2 = boxDist(ray, Box(vec3(0,11,0), vec3(8,0.5,0.5), 0.5));\n    float x = unionOp(bDist1, bDist2);\n    result.d = unionOp(result.d, x);\n   \n    result.material = result.d == ray.origin.y ? kFLOORMATERIAL : kMATTEMATERIAL;\n    return result;\n}\n\n// Gets the normal\nvec3 normal(in Ray ray) {\n    vec2 eps = vec2(0.0001, 0);\n    float baseDist = sceneDist(ray).d;\n \treturn normalize(vec3(\n        sceneDist(Ray(ray.origin + eps.xyy, ray.dir)).d - baseDist,\n        sceneDist(Ray(ray.origin + eps.yxy, ray.dir)).d - baseDist,\n        sceneDist(Ray(ray.origin + eps.yyx, ray.dir)).d - baseDist\n        ));\n}\n\n// Moves the ray to the surface. Helps avoid artefacts due to ray intersection imprecision.\nvoid clampToSurface(in Ray ray, in float d, inout vec3 n) {\n \tray.origin += n * d;\n \td = sceneDist(ray).d;\n \tn = normal(ray);\n}\n\n// Calulcate a fresnel term for reflections\nfloat fresnelTerm(in Ray ray, in vec3 n, in float power) {\n\tfloat fresnel = min(1., dot(ray.dir, n) + 1.0);\n\tfresnel = pow(fresnel, power);\n    return fresnel;\n}\n\n// gets a reasonable texture coordinate from the normal\nvec2 texCoordFromNormal(in vec3 n) {\n\tvec2 c = n.xy * abs(n.z) + n.xz * abs(n.y) + n.yz * abs(n.x);\n    return c * 0.5 + 0.5;\n//    c.x = mix(n.x, n.y, abs(n.y) - abs(n.x));\n //   c.y = mix(n.y, n.z, abs(n.z) - abs(n.y));\n //   return c * 0.5 + 0.5;\n}\n\n/*\n---- LIGHTING ----\n*/\n\n// Pretty background colour of some sort...\nvec3 backgroundColour (in Ray ray, in float divergence) {\n    \n    // Declare a horizon and extremity (either zenith or nadir)\n    vec3 base, extremity, texture;\n    float x = smoothstep(0.0,1.0,abs(ray.dir.y));\n    \n    if (ray.dir.y >= 0.0) {\n        // sky: fake as hell clouds\n    \tbase = mix(kHORIZONCOLOUR, kZENITHCOLOUR, x);\n        texture = vec3(1);\n        float cloudFactor = 0.0;\n        \n        vec2 coord = ray.dir.xz / 8.0;\n        float scale = 1.0;\n        for (int i=0; i<4; i++) {\n            float offset = iTime * 0.03 / scale;\n            cloudFactor += texrand(coord + vec2(0, -offset), 3.0).r * scale;\n            coord *= 2.0;\n            scale *= 0.5;\n        }\n        cloudFactor /= 1.5;\n        vec3 cloud = mix(vec3(0.4), vec3(1), cloudFactor);\n        base = mix(base, cloud, cloudFactor * ray.dir.y * ray.dir.y);\n        \n    } else {\n        // ground: fake as hell desert\n        texture = kNADIRCOLOUR * 0.5;\n        vec2 floorCoord = floorPos(ray, -30.0);// + vec2(0, iTime * 100.0);\n        texture *= (sin(floorCoord.x * .183 + floorCoord.y * 0.183 + sin(floorCoord.y * 0.3) * 0.5) \n                    + sin(floorCoord.x * .15 + floorCoord.y * 0.22 + sin(floorCoord.x * 0.26) * 0.5))\n            * 0.25 + 0.5;\n\t\tbase = mix(kHORIZONCOLOUR, kNADIRCOLOUR + texture, x);\n        \n    }\n    \n    \n    return base;\n}\n\n// Technically broken, but seems to make soft shadows? *shrug*\nfloat occlusion(in Ray ray, in vec3 n) {\n    vec3 origin = ray.origin;\n    float o = 0.0;\n    ray.dir = n;\n    float x = eps;\n    origin += ray.dir * x;\n    for (float i=1.0; i<8.0; i++) {\n    \tray.origin = origin + ray.dir * x;\n        float d = sceneDist(ray).d;\n        o += max(x - d, 0.0) / x / i;\n        \n        x *= 2.0;\n    }\n \treturn 1.0 - o;\n}\n\nvec3 light(in Ray ray, in vec3 n) {\n    // get the half-angle\n    ray.dir = (ray.dir, n) * 0.5;\n    return backgroundColour(ray, 0.0) * (n.y + n.z) * 0.5;\n}\n\nfloat fog(in Ray ray, float stepDistance) {\n    float fogNoise = 0.0;\n    float s = 0.05;\n    for (int i=0; i<2; i++) {\n        float t = iTime;\n        fogNoise += sin(ray.origin.x*s + t) + sin(ray.origin.x*s + ray.origin.z*s+t);\n        s *= 2.85;\n    }\n    \n    fogNoise /= 2.0 * 2.0;\n    fogNoise = fogNoise * 0.25 + 0.5;\n    float yScale = (50.0 - ray.origin.y) / 50.0;\n    float fog = stepDistance * 0.2 * fogNoise * yScale;\n    fog += max(0.0, 10.0 - ray.origin.y) / 10.0;\n    return clamp(fog, 0., 1.);\n}\n\n/*\n---- RAY MARCHING ----\n*/\n\n// The main marching loop\nvoid marchRay(inout Ray ray, inout vec3 colour) {\n    bool inside = false; // are we inside or outside the glass object\n    vec3 impact = vec3(1); // This decreases each time the ray passes through glass, darkening colours\n\n    vec3 startpoint = ray.origin;\n    \n#ifdef DEBUG   \nvec4 debugColour = vec4(1, 0, 0, 1);\n#endif\n    \n    SDResult result;\n    vec3 n;\n    vec3 glassStartPos;\n    \n    for (int i=0; i<kMAXITERS; i++) {\n        // Get distance to nearest surface\n        result = sceneDist(ray);\n        \n        // Step half that distance along ray (helps reduce artefacts)\n        float stepDistance = inside ? abs(result.d) : result.d;\n        ray.origin += ray.dir * stepDistance;\n        \n        float f = fog(ray, stepDistance);\n        \n        colour = mix(colour, vec3(0.7), clamp(f, 0., 1.));\n        impact *= 1. - f;\n        \n       // if (length(ray.origin) > 40.0) { break; }\n        \n        if (stepDistance < eps) {\n            // colision\n            // normal\n            // Get the normal, then clamp the intersection to the surface\n    \t\tn = normal(ray);\n            //clampToSurface(ray, stepDistance, n);\n#ifdef DEBUG\n#endif\n            \n            if (result.material == kFLOORMATERIAL) {\n            \t// ray hit floor\n              \n                // Add some noise to the normal, since this is pretending to be grit...\n                vec3 randomNoise = texture(iChannel2, ray.origin.xz * .050, 0.0).rgb;\n                randomNoise += texture(iChannel2, ray.origin.xz * .10, 0.0).rgb;\n                n = mix(vec3(0,1,0), randomNoise-1.0, 0.25);\n                colour = mix(colour, kMATTECOLOUR * light(ray, n) * vec3(occlusion(ray, n)), impact);\n                /*\n\t\t\t\tn = mix(n, normalize(vec3(randomNoise.x, 1, randomNoise.y)), randomNoise.z);\n                \n                // Colour is just grey with crappy fake lighting...\n                colour += mix(\n                    kFLOORCOLOUR, \n                    vec3(0), \n                    pow(max((-n.x+n.y) * 0.5, 0.0), 2.0)\n                ) * impact;\n\t\t\t\t*/\n                impact *= 0.;\n                break;\n            }\n            \n            if ( result.material == kMATTEMATERIAL ) {\n                // ray hit thing\n                \n                // tex coord from normal\n                vec2 coord = texCoordFromNormal(n);\n                \t\n                float fresnel = fresnelTerm(ray, n, 2.0);\n                \n                // Add some noise to the normal, since this is pretending to be grit...\n                vec3 randomNoise = texture(iChannel2, n.xy * .50, fresnel * 4.0).rgb;\n                randomNoise += texture(iChannel2, n.xz * .50, fresnel * 4.0).rgb;\n                randomNoise += texture(iChannel2, n.yz * .50, fresnel * 4.0).rgb;\n                randomNoise /= 3.0;\n                n = mix(n, randomNoise-0.5, 0.3);\n                colour = mix(colour, kMATTECOLOUR * light(ray, n) * vec3(occlusion(ray, n)), impact);\n                /*\n\t\t\t\tn = mix(n, normalize(vec3(randomNoise.x, 1, randomNoise.y)), randomNoise.z);\n                \n                // Colour is just grey with crappy fake lighting...\n                colour += mix(\n                    kFLOORCOLOUR, \n                    vec3(0), \n                    pow(max((-n.x+n.y) * 0.5, 0.0), 2.0)\n                ) * impact;\n\t\t\t\t*/\n                impact *= 0.;\n                break;\n            }\n            \n            // check what material it is...\n            \n            if (result.material == kMIRRORMATERIAL) {\n                \n                // handle interior glass / other intersecion\n                if (inside) {\n                     float glassTravelDist =  min(distance(glassStartPos, ray.origin) / 16.0, 1.);\n    \t\t\t\tglassStartPos = ray.origin;\n                    // mix in the colour\n                \timpact *= mix(kGLASSCOLOUR, kGLASSCOLOUR * 0.1, glassTravelDist);\n                    \n                }\n                \n                // it's a mirror, reflect the ray\n                ray.dir = reflect(ray.dir, n);\n                    \n                // Step 2x epsilon into object along normal to ensure we're beyond the surface\n                // (prevents multiple intersections with same surface)\n                ray.origin += n * eps * 2.0;\n                \n                // Mix in the mirror colour\n                impact *= kMIRRORCOLOUR;\n                \n            } else {\n                // glass material\n            \n                if (inside) {\n                \t// refract glass -> air\n                \tray.dir = refract(ray.dir, -n, 1.0/kREFRACT);\n                    \n                    // Find out how much to tint (how far through the glass did we go?)\n                    float glassTravelDist =  min(distance(glassStartPos, ray.origin) / 16.0, 1.);\n    \n                    // mix in the colour\n                \timpact *= mix(kGLASSCOLOUR, kGLASSCOLOUR * 0.1, glassTravelDist);\n                    \n#ifdef DEBUG\ndebugValue += glassTravelDist / 2.0;\n#endif\n      \n                \n              \t} else {\n               \t\t// refract air -> glass\n                \tglassStartPos = ray.origin;\n                    \n              \t  \t// Mix the reflection in, according to the fresnel term\n                \tfloat fresnel = fresnelTerm(ray, n, 1.0);\n                    fresnel = fresnel;\n    \t\t\t\t/*\n                    colour = mix(\n                    \tcolour, \n                    \ttexture(iChannel1, reflect(ray.dir, n)), \n                    \tvec4(fresnel) * impact);\n*/\n                    colour = mix(\n                        colour,\n                        backgroundColour(ray, 0.0),\n                        vec3(fresnel) * impact);\n                    impact *= 1.0 - fresnel;\n    \t\t\t\n                \t// refract the ray\n            \t\tray.dir = refract(ray.dir, n, kREFRACT);\n                    \n#ifdef DEBUG\n//debugValue += 0.5;\n#endif\n                }\n            \n            \t// Step 2x epsilon into object along normal to ensure we're beyond the surface\n                ray.origin += (inside ? n : -n) * eps * 2.0;\n                \n                // Flip in/out status\n                inside = !inside;\n            }\n        }\n        \n        // increase epsilon\n        eps += divergence * stepDistance;\n    }\n    \n    // So far we've traced the ray and accumulated reflections, now we need to add the background.\n   // colour += texture(iChannel0, ray.dir) * impact;\n    ray.origin = startpoint;\n    colour.rgb += backgroundColour(ray, 0.0) * impact;\n    \n#ifdef DEBUG\n//debugColour.rgb = ray.dir;\ndebugColour.rgb = vec3(float(debugStep)/2.0);\ncolour = debugColour;\n#endif\n}\n\n// Sets up a camera at a position, pointing at a target.\n// uv = fragment position (-1..1) and fov is >0 (<1 is telephoto, 1 is standard, 2 is fisheye-like)\nCamera setupCam(in vec3 pos, in vec3 target, in float fov, in vec2 uv) {\n\t\t// cam setup\n    // Create camera at pos\n\tCamera cam;\n    cam.pos = pos;\n    \n    // A ray too\n    Ray ray;\n    ray.origin = pos;\n    \n    // FOV is a simple affair...\n    uv *= fov;\n    \n    // Now we determine hte ray direction\n\tvec3 cw = normalize (target - pos );\n\tvec3 cp = vec3 (0.0, 1.0, 0.0);\n\tvec3 cu = normalize ( cross(cw,cp) );\n\tvec3 cv = normalize ( cross (cu,cw) );\n    \n\tray.dir = normalize ( uv.x*cu + uv.y*cv + 0.5 *cw);\n    \n    // Add the ray to the camera and our work here is done.\n\tcam.ray = ray;\n    \n    vec2 mouse = (iMouse.xy / iResolution.xy)*2.-1.;\n    if (mouse.x+mouse.y == -2.0) { mouse *= 0.0; }\n    R(cam.ray.dir.yz, (-mouse.y * kPI) * 0.5);\n    R(cam.ray.dir.xz, (mouse.x * kPI) * 0.5);\n    \n    // Ray divergence\n    divergence = fov / iResolution.x;\n    \n\treturn cam;\n}\n\nvec3 camPath(in float time) {\n    vec3 camPos = vec3(sin(time * 0.5) * 0.2, cos(time) * 0.3 + 15.0, (sin(time) * 0.2) + (time*2.0));\n    \n    return camPos;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // We'll need a camera. And some perspective.\n    \n\t// Get some coords for the camera angle from the frag coords. Convert to -1..1 range.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2. - 1.;\n    \n    // Aspect correction so we don't get oval bokeh\n    uv.y *= iResolution.y/iResolution.x;\n    \n    // Make a camera with ALL NEW AND IMPROVED! camera code :)\n    float camTime = iTime;\n    vec3 camPos = camPath(camTime);\n    vec3 camTarget = camPath(camTime + 1.0) + vec3(sin(camTime * 0.5), sin(camTime * 0.3) *0.5 - 0.5, 0);\n    //camTarget.y -= 3.0;\n    \n    Camera cam = setupCam(camPos, camTarget, 0.500, uv);\n    \n    \n    // Let's raymarch some stuff and inject that into the scene...\n    \n    // Create an empty colour\n    vec3 col = vec3(0);\n    \n    // Trace that ray!\n    marchRay(cam.ray, col);\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XldSD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XldXD7", "name": "cloudy voxel world", "author": "SudoNhim", "description": "A minecraft like world with rounded edges and fog. I have a lot more to do to this one :)", "tags": ["voxels", "minecraft"], "likes": 13, "viewed": 587, "date": "1480046046", "time_retrieved": "2024-06-20T18:45:25.213278", "image_code": "#define PI 3.14159\n\n#define VOXEL_NONE  0\n#define VOXEL_WATER 1\n#define VOXEL_SAND  2\n#define VOXEL_EARTH 3\n#define VOXEL_STONE 4\n#define VOXEL_GRASS 5\n\n// from https://www.shadertoy.com/view/4sfGzS\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n    vec2 uv = p.xy + f.xy;\n\tvec2 rg = vec2(texture( iChannel0, (uv+vec2(37.0,17.0)*p.z+0.5)/256.0, -100.0 ).x,\n                   texture( iChannel0, (uv+vec2(37.0,17.0)*(p.z+1.0)+0.5)/256.0, -100.0 ).x );\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nint getVoxelAndFogAt(ivec3 ip, out float fogStrength)\n{ \n    float cloudiness = noise(vec3(ip)/8.0);\n    fogStrength = smoothstep(0.6, 0.7, cloudiness)*0.3 + 0.1;\n    \n    if (ip.y <= 0) return VOXEL_WATER;\n    \n    // so this is like, grabbing the texture as a heightmap and\n    // then like twisting it in random directions as it goes up\n    // umm...\n    vec3 p = vec3(vec3(ip) + 0.5);\n    float theta = noise(p / 16.0) * PI * 2.0;\n    vec2 disp = vec2(cos(theta), sin(theta)) * p.y;\n    vec3 terr = texture(iChannel1, (p.xz + disp) / 128.0).rgb;\n\n    bvec3 contains = lessThanEqual(vec3(0.0), (terr - p.y/16.0));\n    if (contains.x && contains.y && !contains.z) return VOXEL_SAND;\n    if (contains.x && contains.z) return VOXEL_GRASS;\n    if (contains.y && contains.z && !contains.x) return VOXEL_STONE;\n    if (contains.x || contains.y || contains.z) return VOXEL_EARTH;\n\n    return VOXEL_NONE;\n}\n\nfloat dfVoxel(vec3 p, int voxelType)\n{\n    float r = 0.1;\n    if (voxelType == VOXEL_WATER) r = 0.0;\n    return length(max(abs(p)-vec3(0.5-r),0.0))-r;\n}\n\nvec3 nrmVoxel(vec3 p, int voxelType) \n{\n    vec2 dd = vec2(0.001,0.0);\n    float base = dfVoxel(p, voxelType);\n    return normalize(vec3(\n        dfVoxel(p+dd.xyy, voxelType) - base,\n        dfVoxel(p+dd.yxy, voxelType) - base,\n        dfVoxel(p+dd.yyx, voxelType) - base\n    ));\n}\n\nvoid voxelMarch(vec3 ro, vec3 rd, out ivec3 hitVoxels[4], out float fogAccums[5], out int hitCount) \n{\n    hitCount = 0;\n\n    ivec3 mapPos = ivec3(floor(ro));\n    vec3 deltaDist = abs(vec3(length(rd)) / rd);\n    ivec3 rayStep = ivec3(sign(rd));\n    vec3 sideDist = (sign(rd) * (vec3(mapPos) - ro) + (sign(rd) * 0.5) + 0.5) * deltaDist; \n    bvec3 mask;\n    float fogAccum = 0.0;\n    float prevDist = 0.0;\n\t\n    for (int i = 0; i < 96; i++) {\n\n        // check current position for voxel\n        float fogStrength;\n        if (getVoxelAndFogAt(mapPos, fogStrength) != VOXEL_NONE) {\n            // no non-const indexing? :<\n            if (hitCount == 0)      { hitVoxels[0] = mapPos; fogAccums[0] = fogAccum; }\n            else if (hitCount == 1) { hitVoxels[1] = mapPos; fogAccums[1] = fogAccum; }\n            else if (hitCount == 2) { hitVoxels[2] = mapPos; fogAccums[2] = fogAccum; }\n            else if (hitCount == 3) { hitVoxels[3] = mapPos; fogAccums[3] = fogAccum; }\n            hitCount++;\n            if (hitCount == 4) return;\n        }\n\n        // march forward to next position by discrete digital analyzer\n        float newDist = min( sideDist.x, min(sideDist.y, sideDist.z ));\n        vec3 mi = step( sideDist.xyz, sideDist.yzx ); \n        vec3 mm = mi*(1.0-mi.zxy);\n        sideDist += mm * vec3(rayStep) / rd;\n        mapPos += ivec3(mm)*rayStep;\n        \n        fogAccum += fogStrength * (newDist - prevDist);\n        prevDist = newDist;\n    }\n    \n    // did not intersect.\n    fogAccums[4] = fogAccum;\n}\n\nvoid resolveHitVoxels(\n    vec3 ro, vec3 rd, ivec3 hitVoxels[4], float fogAccums[5], int hitCount, \n    out ivec3 hitVoxel, out vec3 hit, out int terrainType, out float fogAccum) \n{ \n  for (int i=0; i<4; i++) {\n    if (i == hitCount) { \n      terrainType = VOXEL_NONE;\n      fogAccum = fogAccums[4];\n      return; // less than four hits, none intersected\n    }\n    \n    hitVoxel = hitVoxels[i]; float tmp;\n    terrainType = getVoxelAndFogAt(hitVoxel, tmp);\n    fogAccum = fogAccums[i];\n    vec3 hitVoxelCenter = vec3(hitVoxel) + 0.5;\n    \n    // intersect with voxel cube\n    vec3 cubeIntersect = (hitVoxelCenter - ro - 0.5*sign(rd))/rd;\n    float d = max(cubeIntersect.x, max(cubeIntersect.y, cubeIntersect.z));\n\n    // fallback in case of four no distance intersection\n    hit = ro + rd * (d - 0.01) - hitVoxelCenter;\n      \n    // attempt better intersect with distance marching\n    float diff;\n    vec3 p = ro + rd * d;\n    for (int j=0; j<4; j++) {\n      diff = dfVoxel(p - hitVoxelCenter, terrainType);\n      d += diff;\n      p = ro + rd * d;\n    }\n    if (diff < 0.05) { // good enough distance marched intersection\n      hit = p - hitVoxelCenter;\n      return;\n    }\n  }\n  // four hits, none intersected. Use the intersection with the cube to pretend we hit the last one.\n}\n\nvec3 doColoring(vec3 hit, int terrainType, vec3 hitGlobal, vec3 ldir)\n{\n    vec3 n = nrmVoxel(hit, terrainType);\n    float diffuse = max(dot(-ldir, n), 0.1);\n    \n    float f1 = noise(hitGlobal*19.0);\n    float f2 = noise(hitGlobal*33.0);\n    float f3 = noise(hitGlobal*71.0);\n    \n    // render\n    vec3 color = vec3(0.0);\n    if (terrainType == VOXEL_WATER) {\n        color = vec3(0.4, 0.4, 0.8) * (0.8 + f1*0.1 + f2*0.05 + f3*0.05);\n    } else if (terrainType == VOXEL_EARTH) {\n        color = vec3(1.0, 0.7, 0.3) * (f1*0.33 + f2*0.33 + f3*0.33);\n    } else if (terrainType == VOXEL_SAND) {\n        color = vec3(1.0, 1.0, 0.6) * (f1*0.1 + f2*0.1 + f3*0.5 + 0.3);\n    } else if (terrainType == VOXEL_STONE) {\n        color = vec3(0.5) * (f1*0.3 + f2*0.1 + 0.6);\n    } else if (terrainType == VOXEL_GRASS) {\n        color = vec3(0.3, 0.7, 0.4) * (f1*0.2 + f3*0.5 + 0.3);\n    }\n    \n    color *= diffuse;\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera stolen from Shane :) https://www.shadertoy.com/view/ll2SRy\n\tvec2 uv = (fragCoord - iResolution.xy*.5 )/iResolution.y;\n    vec3 rd = normalize(vec3(uv, (1.-dot(uv, uv)*.5)*.5));\n    vec3 ro = vec3(0., 10., iTime*10.0);\n    float t = sin(iTime * 0.2) + noise(ro/32.0);\n    ro.y += 4.0*t;\n\tfloat cs = cos( t ), si = sin( t );\n    rd.yz = mat2(cs, si,-si, cs)*rd.yz;\n    rd.xz = mat2(cs, si,-si, cs)*rd.xz;\n    \n    // voxel march into the scene storing up to four intersections\n    int hitCount;\n    ivec3 hitVoxels[4];\n    float fogAccums[5];\n    voxelMarch(ro, rd, hitVoxels, fogAccums, hitCount);\n\n    // resolve to one accurate intersection by distance marching\n    int terrainType = VOXEL_NONE;\n    ivec3 hitVoxel;\n    vec3 hit;\n    float fogAccum;\n    resolveHitVoxels(ro, rd, hitVoxels, fogAccums, hitCount, hitVoxel, hit, terrainType, fogAccum);\n\n    vec3 hitGlobal = vec3(hitVoxel) + hit;\n    float dist = length(hitGlobal - ro);\n    \n    // color\n    vec3 color;\n    if (terrainType == VOXEL_NONE) // sky\n    {\n        color = vec3 (0.5, 0.5, 0.6);\n        dist = 1000.0;\n    } else {\n        vec3 ldir = normalize(hitGlobal - ro);\n        color = doColoring(hit, terrainType, hitGlobal, ldir);\n    }\n    \n    // fog\n    float fog = smoothstep(0.0, 10.0, fogAccum);\n    color = mix(color, vec3(0.6), fog);\n    \n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XldXD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XldXDn", "name": "bp Stars", "author": "blackpolygon", "description": "Positioning particles with sin and cos while applying some transformations.", "tags": ["cloud", "color", "hsv", "points"], "likes": 16, "viewed": 453, "date": "1479018395", "time_retrieved": "2024-06-20T18:45:25.576964", "image_code": "// Author: blackpolygon\n// Title:  Stars\n\n// Based on 'Audio Eclipse' by airtight\n// https://www.shadertoy.com/view/MdsXWM\n\n\nconst float dots = 250.; //number of lights\nfloat radius = 0.050; //radius of light ring\nconst float brightness = 0.001;\n\n//convert HSV to RGB\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/min(iResolution.x,iResolution.y);\n    st.x -= 0.35;\n    \n    st -= 0.5;\n    vec3 color=vec3(0.0); //background color\n\t\t\n    for(float i=0.;i<dots; i++){\n\t\t\n        radius += (0.5+sin(iTime/3.)*0.3)*0.002;\n        float b1a0 = 0.5+sin(iTime/5.)*0.5;\n        float b1a02 = 0.5+cos(iTime/5.)*0.5;\n\n        float x = radius*cos(2.*3.14*float(i)/(dots/(50.+b1a0*5.)));\n        float y = radius*sin(2.*3.14*float(i)/(dots/(5. +b1a02*5.)));\n        vec2 position = vec2(x,y);\n\n\t\tvec3 dotCol = vec3(0.5+sin(iTime)*0.2,0.20,0.734);\n\t    \n\t\tcolor += (brightness/(length(st-position))*dotCol) * 0.8;\n    }\n\t \n\tfragColor = vec4(color,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XldXDn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XldXRN", "name": "polka dots    (319 chars)", "author": "FabriceNeyret2", "description": "ref: [url]https://www.facebook.com/TheScienceScoop/posts/1343039352396001[/url]\n\nWill you guess what is the trajectory of a given dot ? :-)", "tags": ["2d", "pattern", "polka", "short"], "likes": 45, "viewed": 1996, "date": "1478473888", "time_retrieved": "2024-06-20T18:45:25.734753", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n\tU = ( U+U - R ) /R.y * 8.;  \n\n    float Pi = 3.14159265359,\n           t = 16.*iTime,  // iDate.w cause streching bug on some machines (AMD+windows?)\n           e = 35./R.y, v;\n  //       a = Pi/3.*floor(t/2./Pi);\n  //U *= mat2(cos(a),-sin(a), sin(a), cos(a));              \n    U *= mat2(sin(Pi/3.*ceil(t/2./Pi) + Pi*vec4(.5,1,0,.5)));      // animation ( switch dir )\n    \n  \tU.y /= .866; \n    U -= .5;   \n    v = ceil(U.y);\n    U.x += .5*v;                                                   // hexagonal tiling\n  //U.x += sin(t) > 0. ? (.5-.5*cos(t)) * (2.*mod(v,2.)-1.) : 0.;  \n    U.x += sin(t) > 0. ? (1.-cos(t)) * (mod(v,2.)-.5) : 0.;        // animation ( scissor )\n  //U.x += (1.-cos(t/2.)) * (mod(v,2.)-.5);                        // variant\n    \n    U = 2.*fract(U)-1.;                                            // dots\n    U.y *= .866;\n\tO += smoothstep(e,-e, length(U)-.6) -O;\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XldXRN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XltSDn", "name": "Tunnel Beauty 7", "author": "aiekick", "description": "Tunnel Beauty 7", "tags": ["tunnel", "7", "beauty"], "likes": 7, "viewed": 519, "date": "1479001240", "time_retrieved": "2024-06-20T18:45:26.413419", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nmat3 RotZ(float a)\n{\n    return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);\n}\n\nfloat df(vec3 p)\n{\n\tvec3 q = p;\n    q *= RotZ(q.z * 0.1);\n\tq += sin(q.zxy * 0.2);\n\tq *= RotZ(q.z * 0.1);\n    q = sin(q.zxy * 0.15)*1.5;\n    p += q;\n\tp *= RotZ(p.z * 0.015);\n    p *= 0.5;\n\treturn mix(25.,0.,abs(fract(atan(p.x, p.y)/3.14159*3.)-.5)) - max(abs(p.x),abs(p.y));\n}\n\nvec3 nor( vec3 pos, float prec )\n{\n\tvec3 eps = vec3( prec, 0., 0. );\n\tvec3 nor = vec3(\n\t    df(pos+eps.xyy) - df(pos-eps.xyy),\n\t    df(pos+eps.yxy) - df(pos-eps.yxy),\n\t    df(pos+eps.yyx) - df(pos-eps.yyx) );\n\treturn normalize(nor);\n}\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// get density of the df at surfPoint\n// ratio between constant step and df value\nfloat SubDensity(vec3 surfPoint, float prec, float ms) \n{\n\tvec3 n;\n\tfloat s = 0.;\n    const int iter = 10;\n\tfor (int i=0;i<iter;i++)\n\t{\n\t\tn = nor(surfPoint,prec); \n\t\tsurfPoint = surfPoint - n * ms; \n\t\ts += df(surfPoint);\n\t}\n\t\n\treturn 1.-s/(ms*float(iter)); // s < 0. => inside df\n}\n\nfloat SubDensity(vec3 p, float s) \n{\n\tvec3 n = nor(p,s); \t\t\t\t\t\t\t// precise normale at surf point\n\treturn df(p - n * s);\t\t\t\t\t\t// ratio between df step and constant step\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 g = fragCoord.xy;\n\tvec2 si = iResolution.xy;\n\tvec2 uv = (g+g-si)/si.y;\n\tvec3 ro = vec3(26.5,26.5, iTime * 80.); \n\tro.xy *= sin(-ro.z * 0.005);\n\tro *= RotZ(-ro.z * 0.015);\n    vec3 cv = ro + vec3(0,0,0.2); \n\tvec3 cu = normalize(vec3(0,1,0));\n  \tvec3 z = normalize(cv-ro);\n    vec3 x = normalize(cross(cu,z));\n  \tvec3 y = cross(z,x);\n    float fov = .9;\n  \tvec3 rd = normalize(fov * (uv.x * x + uv.y * y) + z);\n\t\n\tfloat s = 1., d = 0.;\n\tfor (int i=0; i<200; i++) \n\t{\n\t\tif (log(d*d/s/1e5)>0.) break;\n\t\td += (s=df(ro+rd*d))*.2;\n\t}\n\t\n\tvec3 p = ro + rd * d;\t\t\t\t\t\t\t\t\t\t\t// surface point\n\tvec3 lid = normalize(ro-p); \t\t\t\t\t\t\t\t\t// light dir\n\tvec3 n = nor(p, 0.1);\t\t\t\t\t\t\t\t\t\t\t// normal at surface point\n\tvec3 refl = reflect(rd,n);\t\t\t\t\t\t\t\t\t\t// reflected ray dir at surf point \n\tfloat diff = clamp( dot( n, lid ), 0.0, 1.0 ); \t\t\t\t\t// diffuse\n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 4. ); \t\t\t// fresnel\n\tfloat spe = pow(clamp( dot( refl, lid ), 0.0, 1.0 ),16.);\t\t// specular\n\tvec3 col = vec3(.8,.5,.2);\n    \n    // here the magic happen\n\tfloat sss = df(p - n*0.001)/0.06;\t\t\t\t\t\t\t\t// quick sss 0.001 of subsurface\n\t\n\tfloat sb = SubDensity(p, 0.01, 0.1);\t\t\t\t\t\t\t// deep subdensity from 0.01 to 0.1 (10 iterations)\n\tvec3 bb = clamp(blackbody(200. * sb),0.,1.);\t\t\t\t\t// blackbody color\n\tfloat sss2 = 0.8 - SubDensity(p, 3.); \t\t\t\t\t\t\t// one step sub density of df of 3 of subsurface\n\t\n    fragColor.rgb = (diff + fre + bb * sss2 * .8 + col * sss * .2) * 0.25 + spe * 1.2;\n\n\tfragColor.rgb = mix(fragColor.rgb, col * sss, 1.-exp(-0.0001*d*sss));\n\t\n\t// vigneting from iq Shader Mike : https://www.shadertoy.com/view/MsXGWr\n    vec2 q = g/si;\n    fragColor.rgb *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.55 );\n}\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XltSDn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XltSWH", "name": "Modified elevated", "author": "piluve", "description": "This is just a copy of the shader made by iq: https://www.shadertoy.com/view/MdX3Rr . I do not take any credit on that, I just edited how the noise is generated so it has a diferent look.", "tags": ["noise", "elevated"], "likes": 5, "viewed": 955, "date": "1479322766", "time_retrieved": "2024-06-20T18:45:27.922748", "image_code": "// Original shader created by inigo quilez - iq/2013 (https://www.shadertoy.com/view/MdX3Rr)\n// Modified by Ignacio CP (nachocpol@gmail.com)\n\n/*\n\tIÂ´m using the noised() function by IÃ±igo in my DX renderer but I wanted to improve how \n\tit looks.\n\n\tIÂ´ve been looking at some real pictures of terrains and also some hi-quality terrain\n\trenders and most of the detail is on the high parts of the mountain. The lower parts\n\thave less detail (I guess erosion has something to do with that).\n\n\tTo recreate that I added a new parameter: intensity.\n\tWith it, I add more intensity to the parts of the terrain that initially are taler.\n\n    float intensity = 1.0;\n\tfloat modi = 0.05;\n    for( int i=0; i<15; i++ )\n    {\n        vec3 n = noised(p);\n        n *= intensity;\n        if(i==0)intensity = n.x + modi;\n    }\n\n\tYou can also change the initial intensity value to get sharper results.\n*/\n\n\n\n#define SC (250.0)\n\n// value noise, and its analytical derivatives\nvec3 noised( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    vec2 u = f*f*(3.0-2.0*f);\n\tfloat a = texture(iChannel0,(p+vec2(0.5,0.5))/256.0,-100.0).x;\n\tfloat b = texture(iChannel0,(p+vec2(1.5,0.5))/256.0,-100.0).x;\n\tfloat c = texture(iChannel0,(p+vec2(0.5,1.5))/256.0,-100.0).x;\n\tfloat d = texture(iChannel0,(p+vec2(1.5,1.5))/256.0,-100.0).x;\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\t6.0*f*(1.0-f)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\nconst mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\n\nfloat detailH( in vec2 x )\n{\n    float d = 0.0;//50.0*texture( iChannel2, x*0.03/SC, 0.0 ).x;\n    return d + 0.5*texture( iChannel2, x*2.0/SC, 0.0 ).x;\n}\n\nfloat detailM( in vec2 x )\n{\n    float d = 0.0;//50.0*texture( iChannel2, x*0.03/SC, 0.0 ).x;\n    return d;\n}\n\nfloat freq = 0.0032;\nfloat modi = 0.05;\n\nfloat terrainH( in vec2 x )\n{\n\tvec2  p = x*freq/SC;\n    float a = 0.0;\n    float b = 1.0;\n\tvec2  d = vec2(0.0);\n    float intensity = 1.2;\n    for( int i=0; i<15; i++ )\n    {\n        vec3 n = noised(p);\n        n *= intensity;\n        if(i==0)intensity = n.x + modi;\n        d += n.yz;\n        a += b*n.x/(1.0+dot(d,d));\n\t\tb *= 0.5;\n        p = m2*p*2.0;\n    }\n\n    float de = detailH(x);\n\treturn SC*100.0*a - de;\n}\n\nfloat terrainM( in vec2 x )\n{\n\tvec2  p = x*freq/SC;\n    float a = 0.0;\n    float b = 1.0;\n\tvec2  d = vec2(0.0);\n    float intensity = 1.2;\n    for( int i=0; i<9; i++ )\n    {\n        vec3 n = noised(p);\n        n*= intensity;\n        if(i==0)intensity = n.x + modi;\n        d += n.yz;\n        a += b*n.x/(1.0+dot(d,d));\n\t\tb *= 0.5;\n        p = m2*p*2.0;\n    }\n\treturn SC*100.0*a - detailH(x);\n}\n\nfloat terrainL( in vec2 x )\n{\n\tvec2  p = x*freq/SC;\n    float a = 0.0;\n    float b = 1.0;\n\tvec2  d = vec2(0.0);\n    float intensity = 1.2;\n    for( int i=0; i<7; i++ )\n    {\n        vec3 n = noised(p);\n        n*= intensity;\n        if(i==0)intensity = n.x + modi;\n        d += n.yz;\n        a += b*n.x/(1.0+dot(d,d));\n\t\tb *= 0.5;\n        p = m2*p*2.0;\n    }\n\n\treturn SC*100.0*a;\n}\n\nfloat interesct( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\n{\n    float t = tmin;\n\tfor( int i=0; i<256; i++ )\n\t{\n        vec3 pos = ro + t*rd;\n\t\tfloat h = pos.y - terrainM( pos.xz );\n\t\tif( h<(0.002*t) || t>tmax ) break;\n\t\tt += 0.5*h;\n\t}\n\n\treturn t;\n}\n\nfloat softShadow(in vec3 ro, in vec3 rd )\n{\n    // real shadows\t\n    float res = 1.0;\n    float t = 0.001;\n\tfor( int i=0; i<80; i++ )\n\t{\n\t    vec3  p = ro + t*rd;\n        float h = p.y - terrainM( p.xz );\n\t\tres = min( res, 16.0*h/t );\n\t\tt += h;\n\t\tif( res<0.001 ||p.y>(SC*200.0) ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos, float t )\n{\n    vec2  eps = vec2( 0.002*t, 0.0 );\n    return normalize( vec3( terrainH(pos.xz-eps.xy) - terrainH(pos.xz+eps.xy),\n                            2.0*eps.x,\n                            terrainH(pos.xz-eps.yx) - terrainH(pos.xz+eps.yx) ) );\n}\n\nvec3 camPath( float time )\n{\n\treturn SC*1100.0*vec3( cos(0.0+0.23*time), 0.0, cos(1.5+0.21*time) );\n}\n\t\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*texture( iChannel0, p/256.0 ).x; p = m2*p*2.02;\n    f += 0.2500*texture( iChannel0, p/256.0 ).x; p = m2*p*2.03;\n    f += 0.1250*texture( iChannel0, p/256.0 ).x; p = m2*p*2.01;\n    f += 0.0625*texture( iChannel0, p/256.0 ).x;\n    return f/0.9375;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, in float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    vec3 light1 = normalize( vec3(-0.8,0.4,-0.3) );\n    // bounding plane\n    float tmin = 1.0;\n    float tmax = 1000.0*SC;\n#if 1\n    float maxh = 300.0*SC;\n    float tp = (maxh-ro.y)/rd.y;\n    if( tp>0.0 )\n    {\n        if( ro.y>maxh ) tmin = max( tmin, tp );\n        else            tmax = min( tmax, tp );\n    }\n#endif\n\tfloat sundot = clamp(dot(rd,light1),0.0,1.0);\n\tvec3 col;\n    float t = interesct( ro, rd, tmin, tmax );\n    if( t>tmax)\n    {\n        // sky\t\t\n\t\tcol = vec3(0.3,.55,0.8)*(1.0-0.8*rd.y)*0.9;\n        // sun\n\t\tcol += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n\t\tcol += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n\t\tcol += 0.2*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );\n        // clouds\n\t\tvec2 sc = ro.xz + rd.xz*(SC*1000.0-ro.y)/rd.y;\n\t\tcol = mix( col, vec3(1.0,0.95,1.0), 0.5*smoothstep(0.5,0.8,fbm(0.0005*sc/SC)) );\n        // horizon\n        col = mix( col, vec3(0.7,0.75,0.8), pow( 1.0-max(rd.y,0.0), 8.0 ) );\n\t}\n\telse\n\t{\n        // mountains\t\t\n\t\tvec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, t );\n        //nor = normalize( nor + 0.5*( vec3(-1.0,0.0,-1.0) + vec3(2.0,1.0,2.0)*texture(iChannel1,0.01*pos.xz).xyz) );\n        vec3 ref = reflect( rd, nor );\n        float fre = clamp( 1.0+dot(rd,nor), 0.0, 1.0 );\n        \n        // rock\n\t\tfloat r = texture( iChannel0, (7.0/SC)*pos.xz/256.0 ).x;\n        col = (r*0.25+0.75)*0.9*mix( vec3(0.08,0.05,0.03), vec3(0.10,0.09,0.08), \n                                     texture(iChannel0,0.00007*vec2(pos.x,pos.y*48.0)/SC).x );\n\t\tcol = mix( col, 0.20*vec3(0.45,.30,0.15)*(0.50+0.50*r),smoothstep(0.70,0.9,nor.y) );\n        col = mix( col, 0.15*vec3(0.30,.30,0.10)*(0.25+0.75*r),smoothstep(0.95,1.0,nor.y) );\n\n\t\t// snow\n\t\tfloat h = smoothstep(55.0,80.0,pos.y/SC + 25.0*fbm(0.01*pos.xz/SC) );\n        float e = smoothstep(1.0-0.5*h,1.0-0.1*h,nor.y);\n        float o = 0.3 + 0.7*smoothstep(0.0,0.1,nor.x+h*h);\n        float s = h*e*o;\n        col = mix( col, 0.29*vec3(0.62,0.65,0.7), smoothstep( 0.1, 0.9, s ) );\n\t\t\n         // lighting\t\t\n        float amb = clamp(0.5+0.5*nor.y,0.0,1.0);\n\t\tfloat dif = clamp( dot( light1, nor ), 0.0, 1.0 );\n\t\tfloat bac = clamp( 0.2 + 0.8*dot( normalize( vec3(-light1.x, 0.0, light1.z ) ), nor ), 0.0, 1.0 );\n\t\tfloat sh = 1.0; if( dif>=0.0001 ) sh = softShadow(pos+light1*20.0,light1);\n\t\t\n\t\tvec3 lin  = vec3(0.0);\n\t\tlin += dif*vec3(7.00,5.00,3.00)*vec3( sh, sh*sh*0.5+0.5*sh, sh*sh*0.8+0.2*sh );\n\t\tlin += amb*vec3(0.40,0.60,0.80)*1.2;\n        lin += bac*vec3(0.40,0.50,0.60);\n\t\tcol *= lin;\n        \n        col += s*0.1*pow(fre,4.0)*vec3(7.0,5.0,3.0)*sh * pow( clamp(dot(light1,ref), 0.0, 1.0),16.0);\n        col += s*0.1*pow(fre,4.0)*vec3(0.4,0.5,0.6)*smoothstep(0.0,0.6,ref.y);\n\n\t\t// fog\n        //float fo = 1.0-exp(-0.000004*t*t/(SC*SC) );\n        float fo = 1.0-exp(-0.001*t/SC );\n        vec3 fco = 0.7*vec3(0.5,0.7,0.9) + 0.1*vec3(1.0,0.8,0.5)*pow( sundot, 4.0 );\n\t\tcol = mix( col, fco, fo );\n\n        // sun scatter\n\t\tcol += 0.3*vec3(1.0,0.8,0.4)*pow( sundot, 8.0 )*(1.0-exp(-0.002*t/SC));\n\t}\n\n    // gamma\n\tcol = pow(col,vec3(0.4545));\n\t\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = -1.0 + 2.0*fragCoord.xy/iResolution.xy;\n\tvec2 s = xy*vec2(iResolution.x/iResolution.y,1.0);\n\n    float time = iTime*0.15 + 0.3 + 4.0*iMouse.x/iResolution.x;\n\n    // camera position\n\tvec3 ro = camPath( time );\n\tvec3 ta = camPath( time + 3.0 );\n\tro.y = terrainL( ro.xz ) + 11.0*SC;\n\tta.y = ro.y - 20.0*SC;\n\tfloat cr = 0.2*cos(0.1*time);\n    \n//ro = vec3(0.0,0.0,0.0); ro += camPath(20.0 ); ro.y += terrainM( ro.xz ) + 4.0; cr = 0.0; ta = ro + vec3(0.0,0.0,-1.0);    \n    \n    // camera2world transform    \n    mat3 cam = setCamera( ro, ta, cr );\n\n    // camera ray    \n\tvec3 rd = cam * normalize(vec3(s.xy,2.0));\n\n    vec3 col = render( ro, rd );\n    \n    // vignetting\t\n\tcol *= 0.5 + 0.5*pow( (xy.x+1.0)*(xy.y+1.0)*(xy.x-1.0)*(xy.y-1.0), 0.1 );\n\n    fragColor = vec4( col, 1.0 );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    vec3 ro = fragRayOri;\n    ro = camPath( 20.0 );\n    ro.y += terrainM( ro.xz ) + 2.0;\n    \n    fragColor = vec4( render( ro, fragRayDir ), 1.0 );\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XltSWH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XltSWn", "name": "bp Galaxy", "author": "blackpolygon", "description": "Rotating matrix", "tags": ["pointcloud", "rotation"], "likes": 21, "viewed": 342, "date": "1478986161", "time_retrieved": "2024-06-20T18:45:28.177232", "image_code": "// Author: blackpolygon\n// Title:  Galaxy\n\n// Based on 'Audio Eclipse' by airtight\n// https://www.shadertoy.com/view/MdsXWM\n\n\nconst float dots = 300.; \nfloat radius = 0.0050;\nconst float brightness = 0.00025;\nconst float TWOPI = 6.28318;\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\t\t\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st=(fragCoord.xy-.5*iResolution.xy)/min(iResolution.x,iResolution.y);\n    vec3 bgColor = vec3(0.0); \n    \n    st = rotate2d( sin(iTime/5.)*3.14 ) * st;\n\t\t\n    for(float i=0.;i<dots; i++){\n\t\t\n        radius += (0.5+sin(iTime/3.)*0.3)*0.002;\n        \n        //Values going between 1 and 0\n        float b1a0 = 0.5+sin(iTime)*0.5;\n        float b1a02 = 0.5+cos(iTime)*0.5;\n\n\t\t//get location of dot\n        float x = radius*cos(TWOPI*float(i)/(dots/(15.+b1a0)));\n        float y = radius*sin(TWOPI*float(i)/(dots/(14. +b1a02)));\n        vec2 position = vec2(x,y);\n\t    \n        //get brightness of this pixel based on distance to dot\n\t\tbgColor += brightness/(length(st-position));\n    }\n\t \n\tfragColor = vec4(bgColor,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XltSWn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XltSWr", "name": "bp Melting lines", "author": "blackpolygon", "description": "Just don't stare at it too much", "tags": ["noise", "distortion", "lines"], "likes": 2, "viewed": 171, "date": "1479074966", "time_retrieved": "2024-06-20T18:45:28.528707", "image_code": "// Author: blackpolygon\n// Title: Melting lines\n\n//Based on 'Wood' by patriciogv\n\n\nfloat random (in vec2 st) { \n    float cs = iTime*0.0005;\n    return fract(sin(dot(st.xy,\n                         vec2(0.1+cs,0.820))) \n                * 88.049);\n}\n\n// Value noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/lsf3WH\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( random( i + vec2(0,0) ), \n                     random( i + vec2(1.0,0.0) ), u.x),\n                mix( random( i + vec2(0.0,1.0) ), \n                     random( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nmat2 rotate2d(float angle){\n    return mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle));\n}\n\nfloat lines(in vec2 pos, float b){\n    float b1a0 = 0.5 + sin(iTime)*0.5;\n    float b1a1 = sin(iTime);\n    float scale = 3.;\n    pos *= scale;\n    return smoothstep(0.0,\n                    0.500+b*.5,\n                    abs((sin(pos.x*4.189)+b*b1a1))*0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/min(iResolution.x,iResolution.y);\n    st.x -= 0.35;\n    \n    st *= iResolution.y/iResolution.x;\n    st -= 0.5;\n    st = rotate2d( sin(iTime*0.15)*3. ) * st;\n\tfloat cs = 5.+ sin(iTime)*0.2*(iTime*0.05);\n    vec2 pos = st.yx*vec2(2.360+cs, 1.208+cs);\n\n    float pattern = pos.x;\n\n    pos = rotate2d( noise(pos) ) * pos;\n    \n    pattern = lines(pos,0.5);\n    vec3 color = vec3(0.985, 0.3+(0.5+cos(iTime)*0.5),0.521) * vec3(pattern);\n    \n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XltSWr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XltSzS", "name": "Preetham Sky irradiance", "author": "xchip", "description": " based on https://www.shadertoy.com/view/llSSDR", "tags": ["preethamskyirradiance"], "likes": 2, "viewed": 325, "date": "1480291445", "time_retrieved": "2024-06-20T18:45:29.371365", "image_code": "#define PI 3.14159265359\n\nfloat saturatedDot( in vec3 a, in vec3 b )\n{\n\treturn max( dot( a, b ), 0.0 );   \n}\n\nvec3 YxyToXYZ( in vec3 Yxy )\n{\n\tfloat Y = Yxy.r;\n\tfloat x = Yxy.g;\n\tfloat y = Yxy.b;\n\n\tfloat X = x * ( Y / y );\n\tfloat Z = ( 1.0 - x - y ) * ( Y / y );\n\n\treturn vec3(X,Y,Z);\n}\n\nvec3 XYZToRGB( in vec3 XYZ )\n{\n\t// CIE/E\n\tmat3 M = mat3\n\t(\n\t\t 2.3706743, -0.9000405, -0.4706338,\n\t\t-0.5138850,  1.4253036,  0.0885814,\n \t\t 0.0052982, -0.0146949,  1.0093968\n\t);\n\n\treturn XYZ * M;\n}\n\n\nvec3 YxyToRGB( in vec3 Yxy )\n{\n\tvec3 XYZ = YxyToXYZ( Yxy );\n\tvec3 RGB = XYZToRGB( XYZ );\n\treturn RGB;\n}\n\nvoid calculatePerezDistribution( in float t, out vec3 A, out vec3 B, out vec3 C, out vec3 D, out vec3 E )\n{\n\tA = vec3(  0.1787 * t - 1.4630, -0.0193 * t - 0.2592, -0.0167 * t - 0.2608 );\n\tB = vec3( -0.3554 * t + 0.4275, -0.0665 * t + 0.0008, -0.0950 * t + 0.0092 );\n\tC = vec3( -0.0227 * t + 5.3251, -0.0004 * t + 0.2125, -0.0079 * t + 0.2102 );\n\tD = vec3(  0.1206 * t - 2.5771, -0.0641 * t - 0.8989, -0.0441 * t - 1.6537 );\n\tE = vec3( -0.0670 * t + 0.3703, -0.0033 * t + 0.0452, -0.0109 * t + 0.0529 );\n}\n\nvec3 calculateZenithLuminanceYxy( in float t, in float thetaS )\n{\n\tfloat chi  \t \t= ( 4.0 / 9.0 - t / 120.0 ) * ( PI - 2.0 * thetaS );\n\tfloat Yz   \t \t= ( 4.0453 * t - 4.9710 ) * tan( chi ) - 0.2155 * t + 2.4192;\n\n\tfloat theta2 \t= thetaS * thetaS;\n    float theta3 \t= theta2 * thetaS;\n    float T \t \t= t;\n    float T2 \t \t= t * t;\n\n\tfloat xz =\n      ( 0.00165 * theta3 - 0.00375 * theta2 + 0.00209 * thetaS + 0.0)     * T2 +\n      (-0.02903 * theta3 + 0.06377 * theta2 - 0.03202 * thetaS + 0.00394) * T +\n      ( 0.11693 * theta3 - 0.21196 * theta2 + 0.06052 * thetaS + 0.25886);\n\n    float yz =\n      ( 0.00275 * theta3 - 0.00610 * theta2 + 0.00317 * thetaS + 0.0)     * T2 +\n      (-0.04214 * theta3 + 0.08970 * theta2 - 0.04153 * thetaS + 0.00516) * T +\n      ( 0.15346 * theta3 - 0.26756 * theta2 + 0.06670 * thetaS + 0.26688);\n\n\treturn vec3( Yz, xz, yz );\n}\n\nvec3 calculatePerezLuminanceYxy( in float theta, in float gamma, in vec3 A, in vec3 B, in vec3 C, in vec3 D, in vec3 E )\n{\n\treturn ( 1.0 + A * exp( B / cos( theta ) ) ) * ( 1.0 + C * exp( D * gamma ) + E * cos( gamma ) * cos( gamma ) );\n}\n\nvec3 calculateSkyLuminanceRGB( in vec3 s, in vec3 e, in float t )\n{\n\tvec3 A, B, C, D, E;\n\tcalculatePerezDistribution( t, A, B, C, D, E );\n\n\tfloat thetaS = acos( saturatedDot( s, vec3(0,1,0) ) );\n\tfloat thetaE = acos( saturatedDot( e, vec3(0,1,0) ) );\n\tfloat gammaE = acos( saturatedDot( s, e )\t\t   );\n\n\tvec3 Yz = calculateZenithLuminanceYxy( t, thetaS );\n\n\tvec3 fThetaGamma = calculatePerezLuminanceYxy( thetaE, gammaE, A, B, C, D, E );\n\tvec3 fZeroThetaS = calculatePerezLuminanceYxy( 0.0,    thetaS, A, B, C, D, E );\n\n\tvec3 Yp = Yz * ( fThetaGamma / fZeroThetaS );\n\n\treturn YxyToRGB( Yp );\n}\n\n// Shadertoy specific uniforms\n#define u_res iResolution\n#define u_time iTime\n#define u_mouse iMouse\n\n#define SAMPLECOUNT 1024\n\nvec2 hash2( float n ) { return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123)); }\n\n\nvec3 SampleHemisphere(in vec3 sun_dir, in vec3 dir)\n{  \n    vec3  ru  = normalize( cross( dir, vec3(0.0,1.0,1.0) ) );\n    vec3  rv  = normalize( cross( ru, dir ) );\n\n    vec3 col = vec3(0.,0.,0.);\n    \n    for( int i=0; i<SAMPLECOUNT; i++ )\n    {\n        vec2  aa = hash2( float(i)*203.1 );\n        float ra = sqrt(aa.y);\n        float rx = ra*cos(6.2831*aa.x); \n        float ry = ra*sin(6.2831*aa.x);\n        float rz = sqrt( 1.0-aa.y );\n        vec3  rdir = vec3( rx*ru + ry*rv + rz*dir );\n    \n        col += calculateSkyLuminanceRGB( sun_dir, rdir, 2.0 ) * rz;\n        \n    }\n    \n    return col/ float(SAMPLECOUNT);   \n}\n\nmat3 rotate_around_x(in float angle_degrees)\n{\n\tfloat angle = radians(angle_degrees);\n\tfloat _sin = sin(angle);\n\tfloat _cos = cos(angle);\n\treturn mat3(1, 0, 0, 0, _cos, -_sin, 0, _sin, _cos);\n}\n\nvec3 sun_dir = vec3(0, 1, 0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{           \n\tvec3 col = vec3(0);\n\n\t// sun\n\tmat3 rot = rotate_around_x(-abs(sin(u_time / 2.)) * 90.);\n\tsun_dir *= rot;\n\n\tvec2 aspect_ratio = vec2(u_res.x / u_res.y, 1);\n\tfloat fov = tan(radians(45.0));\n\tvec2 point_ndc = fragCoord.xy / u_res.xy;\n\tvec3 point_cam = vec3((2.0 * point_ndc - 1.0) * aspect_ratio * fov, -1.0);\n\n    \n    // sky dome angles\n\tvec3 p = point_cam;\n\tfloat z2 = p.x * p.x + p.y * p.y;\n    \n    if (z2>1.0)\n    {\n        fragColor = vec4(0.,0.,0.,1.);\n        return;\n    }\n    \n\tfloat phi = atan(p.y, p.x);\n\tfloat theta = acos(1.0 - z2);\n\n    vec3 dir = vec3(sin(theta) * cos(phi),cos(theta),sin(theta) * sin(phi));\n\n    col = SampleHemisphere( sun_dir, dir ) * .05;\n    //col = calculateSkyLuminanceRGB( sun_dir, dir, 2.0 ) * .05;\n    col = clamp( col, 0.0, 1.0 );\n    \n    //gamma\n    col = pow( col, vec3(0.45) );\n    \n\tfragColor = vec4(col, 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XltSzS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XltXRH", "name": "Simplex made of value noise", "author": "afl_ext", "description": "This is created by merging 2 3d noises calculated with different offset numbers, cool", "tags": ["noise", "simplex", "iq", "perin"], "likes": 11, "viewed": 406, "date": "1478137608", "time_retrieved": "2024-06-20T18:45:29.722745", "image_code": "// I want to mark that this is created by accident\n// afl_ext 2016\nfloat oct(vec3 p){\n    return fract(4768.1232345456 * sin((p.x+p.y*43.0+p.z*137.0)));\n}\nfloat achnoise(vec3 x){\n    vec3 p = floor(x);\n    vec3 fr = smoothstep(0.0, 1.0, fract(x));\n    vec3 LBZ = p + vec3(0.0, 0.0, 0.0);\n    vec3 LTZ = p + vec3(0.0, 1.0, 0.0);\n    vec3 RBZ = p + vec3(1.0, 0.0, 0.0);\n    vec3 RTZ = p + vec3(1.0, 1.0, 0.0);\n\n    vec3 LBF = p + vec3(0.0, 0.0, 1.0);\n    vec3 LTF = p + vec3(0.0, 1.0, 1.0);\n    vec3 RBF = p + vec3(1.0, 0.0, 1.0);\n    vec3 RTF = p + vec3(1.0, 1.0, 1.0);\n\n    float l0candidate1 = oct(LBZ);\n    float l0candidate2 = oct(RBZ);\n    float l0candidate3 = oct(LTZ);\n    float l0candidate4 = oct(RTZ);\n\n    float l0candidate5 = oct(LBF);\n    float l0candidate6 = oct(RBF);\n    float l0candidate7 = oct(LTF);\n    float l0candidate8 = oct(RTF);\n\n    float l1candidate1 = mix(l0candidate1, l0candidate2, fr[0]);\n    float l1candidate2 = mix(l0candidate3, l0candidate4, fr[0]);\n    float l1candidate3 = mix(l0candidate5, l0candidate6, fr[0]);\n    float l1candidate4 = mix(l0candidate7, l0candidate8, fr[0]);\n\n\n    float l2candidate1 = mix(l1candidate1, l1candidate2, fr[1]);\n    float l2candidate2 = mix(l1candidate3, l1candidate4, fr[1]);\n\n\n    float l3candidate1 = mix(l2candidate1, l2candidate2, fr[2]);\n\n    return l3candidate1;\n}\n\nfloat supernoise3d(vec3 p){\n\n\tfloat a =  achnoise(p);\n\tfloat b =  achnoise(p + 120.5);\n\treturn (a + b) * 0.5;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n\tfragColor = vec4(supernoise3d(vec3(iTime, uv.x * 20.0, uv.y * 20.0)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XltXRH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XltXzH", "name": "Stereo Projection", "author": "soma_arc", "description": "stereographic projection", "tags": ["3d", "mobius"], "likes": 10, "viewed": 243, "date": "1478517429", "time_retrieved": "2024-06-20T18:45:31.122780", "image_code": "\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n\tvec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n\t// implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n\treturn vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                 fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nconst float PI = 3.14159265359;\nconst float PI_2 = PI/2.;\nconst float PI_4 = PI/4.;\n\nconst float fourPI = 12.566368;\nconst float EPSILON = 0.001;\n\nconst vec3 BLACK = vec3(0);\nconst vec3 WHITE = vec3(1);\nconst vec3 LIGHT_GRAY = vec3(0.78);\nconst vec3 RED = vec3(1, 0, 0);\nconst vec3 GREEN = vec3(0, .78, 0);\nconst vec3 BLUE = vec3(0, 0, 1);\nconst vec3 YELLOW = vec3(1, 1, 0);\nconst vec3 PINK = vec3(.78, 0, .78);\nconst vec3 LIGHT_BLUE = vec3(0, 1, 1);\n\nconst float NO_HIT = 9999999.;\n\nconst int MTL_PLANE = 0;\nconst int MTL_SPHERE = 1;\nconst int MTL_CYLINDER = 2;\nint g_mtl = -1;\n\nvec4 intersectPlane(vec3 p, vec3 n, \n                    vec3 rayOrigin, vec3 rayDir, vec4 isect){\n    float d = -dot(p, n);\n    float v = dot(n, rayDir);\n    float t = -(dot(n, rayOrigin) + d) / v;\n    if(EPSILON < t && t < isect.x){\n        g_mtl = MTL_PLANE;\n    \treturn vec4(t, n);\n    }\n    return isect;\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat triangle( vec2 p2, vec3 a, vec3 b, vec3 c ){\n    vec3 p = vec3(p2, 0);\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat hexagram(vec2 pos, float radius){\n    float hexR = radius;\n    float rad = radians(60.);\n    float offset = radians(30.);\n    vec3 hexTP1 = vec3(hexR * cos(rad * 6. + offset), hexR * sin(rad * 6. + offset), 0);\n    vec3 hexTP2 = vec3(hexR * cos(rad + offset), hexR * sin(rad + offset), 0);\n    vec3 hexTP3 = vec3(hexR * cos(rad * 2. + offset), hexR * sin(rad * 2. + offset), 0);\n    vec3 hexTP4 = vec3(hexR * cos(rad * 3. + offset), hexR * sin(rad * 3. + offset), 0);\n    vec3 hexTP5 = vec3(hexR * cos(rad * 4. + offset), hexR * sin(rad * 4. + offset), 0);\n    vec3 hexTP6 = vec3(hexR * cos(rad * 5. + offset), hexR * sin(rad * 5. + offset), 0);\n \n    float dd = triangle(pos, hexTP1, hexTP3, hexTP5);\n    dd = min(dd, triangle(pos, hexTP2, hexTP4, hexTP6));\n\treturn dd;\n}\n\nvec4 intersectSphere(vec3 sphereCenter, float radius, \n                      vec3 rayOrigin, vec3 rayDir, vec4 isect){\n  vec3 v = rayOrigin - sphereCenter;\n  float b = dot(rayDir, v);\n  float c = dot(v, v) - radius * radius;\n  float d = b * b - c;\n  if(d >= 0.){\n    float s = sqrt(d);\n    float t = -b - s;\n    if(t <= EPSILON) t = -b + s;\n    if(EPSILON < t && t < isect.x){\n      g_mtl = MTL_SPHERE;\n      vec3 p = (rayOrigin + t * rayDir);\n      return vec4(t, normalize(p - sphereCenter));\n    }\n  }\n  return isect;\n}\n\nvec4 intersectXZCylinder(float r, vec3 center, mat3 invRotationMat,\n                         vec3 rayOrigin, vec3 rayDir, vec4 isect){\n    rayOrigin = (rayOrigin - center) * invRotationMat;\n    rayDir = rayDir * invRotationMat;\n    float a = rayDir.x * rayDir.x + rayDir.z * rayDir.z;\n    float b = 2. * ( rayOrigin.x * rayDir.x + rayOrigin.z * rayDir.z);\n    float c = rayOrigin.x * rayOrigin.x + rayOrigin.z * rayOrigin.z - r * r;\n    float d = b * b - 4. * a * c;\n    if(d >= 0.){\n        float s = sqrt(d);\n        float t = (-b - s) / (2. * a);\n        if(t <= EPSILON) t = (-b + s) / (2. * a);\n        if(EPSILON < t && t < isect.x){\n            vec3 p = (rayOrigin + t * rayDir);\n            g_mtl = MTL_CYLINDER;\n            return vec4(t, normalize(vec3(p.x, 0, p.z)));\n        }\n    }\n    return isect;\n}\n\n// catPos is upper left position of texture\nvec4 getNyanCatColor(float scale, vec2 catPos,vec2 p){\n    p /= scale;\n    p -= catPos;\n\tp = clamp(p,0.0,1.0);\n\tp.x = p.x*40.0/256.0;\n    float fr = floor( mod( 20.0*iTime, 6.0 ) );\n\tp.x += fr*40.0/256.0;\n\treturn texture( iChannel0, p);\n}\n\nvec4 getVideo(float scale, vec2 videoPos, vec2 p){\n    p -= videoPos;\n    p /= scale;\n\tp /= iResolution.xy; \n    if(p.x < 0. || 1. < p.x ||\n       p.y < 0. || 1. < p.y){\n    \treturn vec4(0);\n    }\n\treturn texture(iChannel1, vec2(1)-p);\n}\n\nconst vec3 LIGHT_DIR = normalize(vec3(0.0, -0.5, 0.5));\nconst vec3 ambientFactor = vec3(0.1);\n\nvec2 stereoProject(vec3 p){\n\treturn vec2(p.x / (1. - p.y), p.z / (1. - p.y));\n}\n\nconst vec3 SPHERE_CENTER = vec3(0, 0.5, 0);\nconst float SPHERE_RADIUS = 0.5;\nconst float CYLINDER_RADIUS = 0.01;\nvec4 getIntersection(vec3 eye, vec3 ray){\n\tvec4 isect = vec4(NO_HIT);\n    isect = intersectPlane(vec3(0, 0., 0.), vec3(0, 1, 0),\n                            eye, ray, isect);\n    isect = intersectSphere(SPHERE_CENTER, SPHERE_RADIUS,\n                            eye, ray, isect);\n    \n    mat3 m = mat3(cos(-PI_4), -sin(-PI_4), 0,\n                  sin(-PI_4), cos(-PI_4), 0,\n                  0, 0, 1);\n    isect = intersectXZCylinder(CYLINDER_RADIUS, vec3(0,1,0), m,\n                         \t\teye, ray, isect);\n    m = mat3(cos(PI_4), -sin(PI_4), 0,\n             sin(PI_4), cos(PI_4), 0,\n             0, 0, 1);\n    isect = intersectXZCylinder(CYLINDER_RADIUS, vec3(0,1,0), m,\n                           \t\teye, ray, isect);\n    return isect;\n}\n\nbool visible(vec3 eye, vec3 target){\n    vec3 v = normalize(target - eye);\n\treturn getIntersection(eye, v).x == NO_HIT;\n}\n\nvec3 diffuseLighting(const vec3 p, const vec3 n, const vec3 diffuseColor,\n                     const vec3 lightPos, const vec3 lightPower){\n  \tvec3 v = lightPos - p;\n  \tfloat d = dot(n, normalize(v));\n  \tfloat r = length(v);\n  \treturn (d > 0. && visible(p + EPSILON * n, lightPos)) ?\n    \t(lightPower * (d / (fourPI * r * r))) * diffuseColor\n    \t: BLACK;\n}\n\n\nconst vec3 CIRCLE_COLOR = RED;\nconst vec3 LINE_COLOR = BLUE;\nconst float LINE_THICKNESS = 0.05;\nvec2 gCatPos;\nvec3 getFloorColor(vec2 p, vec3 floorColor){\n    float catScale = 1.;\n    \n    float len = length(p);\n    if(1. - LINE_THICKNESS <= len &&\n       len <= 1. + LINE_THICKNESS) floorColor = CIRCLE_COLOR;\n    \n    if(- LINE_THICKNESS <= p.y &&\n       p.y <= LINE_THICKNESS) floorColor = LINE_COLOR;\n    \n\tvec4 nc = getNyanCatColor(catScale, gCatPos, p);\n    if(nc.w == 1.) floorColor = nc.xyz;\n    \n    //float d = hexagram(p - vec2(1.4, .7), 0.5);\n    //if(d < 0.01) floorColor = vec3(1, 0, 0.7);\n    \n    float videoScale = 0.005;\n    vec2 videoPos = vec2(-1.5, -2.5);\n    vec4 vc = getVideo(videoScale, videoPos, p);\n    if(vc.w == 1.) floorColor = vc.xyz;\n\n    return floorColor;\n}\n\nconst vec3 LIGHT_POS = vec3(0, 5, 1);\nconst vec3 LIGHT_POWER = vec3(300.);\n\nvec3 calcColor(vec3 eye, vec3 ray){\n    vec3 l = BLACK;\n\tvec4 isect = getIntersection(eye, ray);\n    if(isect.x != NO_HIT){\n        vec3 matColor = WHITE;\n\t\tvec3 intersection = eye + ray * isect.x;\n\t    vec3 normal = isect.yzw;\n        if(g_mtl == MTL_PLANE){\n            matColor = vec3(0.7);\n\t\t\tmatColor = getFloorColor(intersection.xz, matColor);\n        }else if(g_mtl == MTL_SPHERE){\n            matColor = vec3(0.7, 0.4, 0.4);\n            matColor = getFloorColor(stereoProject(intersection), matColor);\n        }else if(g_mtl == MTL_CYLINDER){\n            matColor = GREEN;\n        }\n      \t// diffuse lighting by directionalLight\n\t\t//vec3 diffuse =  clamp(dot(normal, LIGHT_DIR), 0., 1.) * matColor;\n       \tvec3 diffuse = diffuseLighting(intersection, normal, matColor,\n                                        LIGHT_POS, LIGHT_POWER);\n\t\tvec3 ambient = matColor * ambientFactor;\n\t\tl += (diffuse + ambient);\n    }\n\treturn l;\n}\n\nvec3 hsv2rgb(vec3 c){\n\tconst vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  \tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  \treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nconst float DISPLAY_GAMMA_COEFF = 1. / 2.2;\nvec3 gammaCorrect(vec3 rgb) {\n\treturn vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n      \t        (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n                (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n}\n\nvec3 calcRay (const vec3 eye, const vec3 target,\n              const vec3 up, const float fov,\n              const float width, const float height, const vec2 coord){\n  float imagePlane = (height * .5) / tan(radians(fov) * .5);\n  vec3 v = normalize(target - eye);\n  vec3 focalXAxis = normalize(cross(v, up));\n  vec3 focalYAxis =  normalize(cross(v, focalXAxis ));\n  vec3 center = v * imagePlane;\n  vec3 origin = center - (focalXAxis * (width  * .5)) - (focalYAxis * (height * .5));\n  return normalize(origin + (focalXAxis * coord.x) + (focalYAxis * (height - coord.y)));\n}\n\nconst float SAMPLE_NUM = 20.;\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ){\n    float dist = 2.8;\n\t//vec3 eye = vec3(0, .5, 2);\n    vec3 eye = vec3(dist * sin(iTime), 1.5, dist * cos(iTime));\n    gCatPos = 2. * vec2(sin(iTime) - 0.5, 0);\n\n    vec3 target = vec3(0);\n    vec3 up = vec3(0, 1, 0);\n    float fov = 60.;\n    \n  \tvec3 sum = vec3(0);\n  \tfor(float i = 0. ; i < SAMPLE_NUM ; i++){\n    \tvec2 coordOffset = rand2n(gl_FragCoord.xy, i);\n          \n    \tvec3 ray = calcRay(eye, target, up, fov,\n        \t               iResolution.x, iResolution.y,\n            \t           gl_FragCoord.xy + coordOffset);\n          \n    \tsum += calcColor(eye, ray);\n  \t}\n \t vec3 col = (sum/SAMPLE_NUM);\n          \n  \tfragColor = vec4(gammaCorrect(col), 1.);\n}\n", "image_inputs": [{"id": "Xsf3Rn", "previewfilepath": "/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture"}, {"id": "XdfGRr", "previewfilepath": "/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XltXzH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xt3SRM", "name": "RadarChaos", "author": "gadgetgnome", "description": "Started programming shaders this afternoon, heaps of fun!\nPlaying with angles, and exploring arbitrary numbers.\n\n// Day #1 shader programming.", "tags": ["2d"], "likes": 3, "viewed": 94, "date": "1478556586", "time_retrieved": "2024-06-20T18:45:31.122780", "image_code": "\nconst float PI = 3.141592653589793238462643383;\nconst float PI2 = PI * 2.0;\nconst float pixelation = 20.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float ar = iResolution.x / iResolution.y;\n    vec4 temp = vec4(0.0,0.0,0.0,1.0);\n    vec2 center = vec2(0.5,0.5);\n    vec2 fromCenter = uv - center;\n    fromCenter.x *= ar;\n    \n    fromCenter *= pixelation;\n    fromCenter = floor ( fromCenter );\n    fromCenter /= pixelation;\n    \n    float angle = mod( atan( fromCenter.y, fromCenter.x) - iTime * 1.0 , PI2)  ;\n    float fromCenterLength = length(fromCenter);\n    \n    temp.g = angle / PI2;\n    temp.g -= sin(iTime * 1000.0 + fragCoord.x + fragCoord.y);\n    \n    fragColor = temp;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xt3SRM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xt3XD7", "name": "Victorian Cheese Mandelbrot", "author": "docwhite", "description": "Little piece that I will be using in a VJ host application.", "tags": ["fractal"], "likes": 4, "viewed": 587, "date": "1479840577", "time_retrieved": "2024-06-20T18:45:31.122780", "image_code": "    float tetex = 0.5;\n\tfloat tetey = 0.5;\n\tfloat bpm = 120.0;\n\tfloat leftx = 0.5;\n\tfloat lefty = 0.5;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    lefty = 1.0 + 0.5 * sin(iTime);\n    vec3 col = vec3(0.0);\n    \n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\n    p.x *= iResolution.x/iResolution.y;\n\n    if (p.x > 0.0) p.x = -p.x;\n    if (p.y > 0.0) p.y = -p.y;\n\n    float enno = tetex;\n    float ramon = tetey;\n\n    p += enno * smoothstep(enno - ramon, enno + ramon, p.x*p.x + p.y*p.y);\n\n\tfloat zoo = 0.001 + 0.0008 * sin(0.00001 * pow(bpm, 2.0) * iTime);\n    \n\tvec2 cc = vec2(-0.52941,0.526141) + p*zoo;\n\n\tvec2 t2c = vec2(cos(iTime), sin(iTime));\n\t\t\n    vec2 z  = vec2(0.0);\n\tfloat trap = 1000.0;\n\n\tconst int iterations = int(100 + int(0.1) * 100 );\n    \n    for( int i=0; i < iterations; i++ )\n    {\n        if( dot(z,z)>1024.0 ) break;\n        z = cc + vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ); // Z -> ZÂ² + c\t\n\t\ttrap = min( trap, dot(z-t2c,z-t2c) );\n    }\n    float etFactor = dot(z,z);\n    float trapFactor = trap;\n\n    col += mix(clamp(1.0 - etFactor, 0.0, 1.0), clamp(trapFactor, 0.0, 1.0), lefty);\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xt3XD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xt3XWN", "name": "Mandelbrot test 1", "author": "n1kk", "description": "tetsting fractal drawing with shaders", "tags": ["fractal", "mandelbrot"], "likes": 2, "viewed": 139, "date": "1479648858", "time_retrieved": "2024-06-20T18:45:31.122780", "image_code": "// better one https://www.shadertoy.com/view/lsX3W4\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // screen rect convertion to local coordinate system \n    vec2 start = vec2(-4.5, -2.5);\n    vec2 size = vec2(5.0, 5.0);\n    // zooming data\n    //vec2 zoom_point = vec2(0.59089, 0.599975);\n    vec2 zoom_point = vec2(0.59089+.2, 0.599975);\n    float zoom = 1.0;\n    bool show_zoom_point = true;\n    float anim_speed = 0.2;\n    float zoom_factor = 15.0;\n    float pizelSize = size.x / iResolution.x;\n    \n    vec3 col = vec3(0.0, 0.0, 0.0);\n    \n    // iMouse.zw present mouse has been pressed, use pointer data for zoom\n    // otherwize use Time to animate zooming in and out\n    if (iMouse.z > 0.0 || iMouse.w > 0.0) {\n        zoom_point = iMouse.zw / iResolution.xy;\n        zoom_point.x *= iResolution.x / iResolution.y;\n        zoom = pow(2.0, distance(iMouse.xy, iMouse.zw)) / 1.0;\n    } else {\n        zoom = 0.5 - 0.5 * cos(anim_speed * iTime);\n    \tzoom = pow(2.0, zoom_factor * zoom);\n    }\n    \n    if (zoom != 0.0) {\n        //float multitude_zoom = pow(2.0, zoom_factor * zoom);\n        vec2 scaled_size = size / zoom;\n        vec2 scale_shift = (size - scaled_size) * zoom_point;\n\n        size = scaled_size;\n        start += scale_shift;\n    }\n    \n    vec2 p = uv * size + start;\n    vec2 c = p;\n    \n    // draw grid x\n    if ( mod(abs(p.x), floor(abs(p.x))) < pizelSize ) {\n        col.r += 0.1;\n    }\n    // draw grid y\n    if ( mod(abs(p.y), floor(abs(p.y))) < pizelSize ) {\n        col.g += 0.1;\n    }\n     \n    // mandelbrot\n    float res = 0.0;\n    const int nn = 300;\n    //for (int n = 0; n <= nn; n++) {\n    for (float n = 0.0; n < 1.0; n += 0.005) {\n        float aa = p.x * p.x - p.y * p.y;\n        float bb = 2.0 * p.x * p.y;\n        p.x = aa + c.x;\n        p.y = bb + c.y;\n        //res = (1.0 + float(n)) / float(nn);\n      \tres = n; \n        if ((p.x + p.y) > 10000.0) {\n           break;\n        }\n    }\n    // animate coloring\n    /*\n\tcol.r += res * (0.6+0.4*cos(3.0*iTime));\n    col.g += res * (0.6+0.4*(cos(iTime) + sin(2.0*iTime)));\n    col.b += res * (0.6+0.4*sin(iTime));\n    */\n    col += vec3(float(res));\n    \n    // show zooming point\n    if (show_zoom_point && distance(uv, zoom_point) < 1.0 * pizelSize) {\n        col = vec3(0.0, 1.0, 0.0);\n    }\n    \n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xt3XWN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xt3XzH", "name": "Sine wave superposition", "author": "drivenbynostalgia", "description": "Sine wave superposition for simple water wave synthesis with a predefined velocity (e.g. wind direction and speed).", "tags": ["water", "sinewaves"], "likes": 17, "viewed": 1168, "date": "1478017513", "time_retrieved": "2024-06-20T18:45:31.122780", "image_code": "// A simple implementation of sine waves along a given, unnormalized velocity\n\nconst float TAU = 6.2831852;\nconst float PI = 0.5 * TAU; // This is a political statement\n\nconst float octaves = 8.0;\nconst vec2 globalVelocity = vec2(6.0, 8.0);\n\n// Hash without Sine by Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    const float HASHSCALE1 = .1031;\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat getAmplitude(float octave)\n{\n    return 1.0 / pow(2.0, octave);\n}\n\nfloat getWavelength(float octave)\n{\n\tconst float maximumWavelength = 50.0;\n    \n    float wavelength = TAU * maximumWavelength / pow(2.0, octave);\n\n    // Make it aperiodic with a random factor\n    wavelength *= 0.75 + 0.5 * hash11(1.337 * octave);\n    \n    return wavelength;\n}\n\nfloat getSpeed(float octave)\n{\n    const float speedScaleFactor = 2.0;\n    \n    // Smallest waves travel twice as fast as given velocity,\n    // largest waves travel half as fast\n    const vec2 speedRange = vec2(2.0, 0.5);\n    \n    // Map octave to speed range\n    float speed = speedScaleFactor * mix(speedRange.x, speedRange.y, octave / (max(1.0, octaves - 1.0)));\n    \n    // Add some randomness\n    speed *= 0.5 + hash11(1.337 * octave);\n    \n    return speed;\n}\n\nfloat getHeight(vec2 position, vec2 velocity)\n{\n    float magnitude = length(velocity);\n    vec2 direction = (magnitude > 1e-5) ? velocity / magnitude : vec2(0.0);\n\n    float height = 0.0;\n    \n    for (float octave = 0.0; octave < octaves; octave += 1.0)\n    {\n        float amplitude = getAmplitude(octave);\n        float wavelength = getWavelength(octave);\n        float speed = magnitude * getSpeed(octave);\n        float frequency = TAU / wavelength;\n        float randomPhaseOffset = hash11(1.337 * octave) * TAU;\n        float phase = speed * frequency + randomPhaseOffset;\n        float theta = dot(-direction, position);\n    \n        height += amplitude * sin(theta * frequency + iTime * phase);\n    }\n    \n    return height;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    if (uv.x < 0.5)\n    {    \n\t\tfragColor = vec4(vec3(0.25 * getHeight(fragCoord, globalVelocity) + 0.5), 1.0);\n    }\n    else\n    {\n        vec2 velocity = vec2(length(globalVelocity), 0.0);\n        float height = getHeight(vec2(fragCoord.x, 0.0), velocity);\n        float scaledHeight = (0.25 * height + 3.0) / 6.0;\n\n        float plot = 1.0 - pow(1.0 - distance(uv.y, scaledHeight), 500.0);\n        \n        fragColor = vec4(vec3(plot), 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xt3XzH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtcSR4", "name": "Vignetting", "author": "Jin02", "description": "Simple Vignetting", "tags": ["vignetting"], "likes": 0, "viewed": 99, "date": "1478266721", "time_retrieved": "2024-06-20T18:45:31.122780", "image_code": "vec4 Vignetting_Hermit(vec2 uv, vec2 vignetUV, float start, float end, vec4 srcColor, vec4 fadeColor)\n{\n    float dist = smoothstep(start, end, distance( uv, vignetUV ) );\n    float fade = clamp(dist, 0.0, 1.0);\n    \n    return mix(srcColor, fadeColor, fade);\n}\n\nvec4 Vignetting_Linear(vec2 uv, vec2 vignetUV, float start, float end, vec4 srcColor, vec4 fadeColor)\n{\n    float dist = mix(start, end, distance( uv, vignetUV ) );\n    float fade = clamp(dist, 0.0, 1.0);\n    \n    return mix(srcColor, fadeColor, fade);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv\t\t\t= fragCoord.xy / iResolution.xy;\n    \n    float end\t\t= clamp(1.0 + 0.5 * sin(iTime), 0.0, 1.0);\n    vec4 srcColor\t= vec4(uv, 0.5 + 0.5 * sin(iTime), 1.0);\n    vec4 fadeColor\t= vec4(1.0, 1.0, 1.0, 1.0);\n    \n  \tvec4 res = Vignetting_Hermit(uv, vec2(0.5, 0.5), 0.0, end, srcColor, fadeColor);\n//  vec4 res = Vignetting_Linear(uv, vec2(0.5, 0.5), 0.0, end, srcColor, fadeColor);\n        \n\tfragColor = vec4(res.rgb, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtcSR4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtcSW7", "name": "Mirror ball 3D", "author": "tabacnik", "description": "Learning shaders, this one is a reflection test using pong illumination method", "tags": ["3draytracepong"], "likes": 6, "viewed": 235, "date": "1479827684", "time_retrieved": "2024-06-20T18:45:31.122780", "image_code": "#define GT iTime \n\n\n// Material tem cor ambiente, difusa e specular. Tem um fator especular. Se reflete.\nstruct Material {\n    vec3 dif, amb, spc;\n    float spf;\n    bool rfl;\n};\n\n// Esfera tem um centro, um raio e um material primario e secundario\nstruct Sphere {\n\tvec3 cen;\n    float rai;\n    Material mat, sec;\n    int padrao;\n};\n\n// Plano tem uma origem e uma normal\nstruct Plane {\n    vec3 ori, nor;\n    Material mat, sec;\n};\n\n// Luz possue uma posiÃ§Ã£o e uma cor\nstruct Ligth {\n    vec3 pos, cor;\n};\n\n// Hit information possue ponto, normal do ponto, material do ponto,\n// flag se acertou algo, flag de sombra e distancia;\nstruct HitInf {\n    vec3 pos, nor;\n    Material mat;\n    bool hit, ins;\n    float dis;\n};\n\n// Ray possue origem \nstruct Ray {\n    vec3 ori, dir;\n};\n\nconst Material air = Material(vec3(0.),vec3(0.),vec3(0.),1.,false);\nconst HitInf nulo = HitInf(vec3(0.),vec3(0.),air,false,false,0.);\n    \n// Objetos em cena\n//============================================================================================\nSphere bola[3];\n\nMaterial metal = Material(vec3(0.9,0.9,0.9),vec3(0.9,0.9,0.9),vec3(0.99),120.,true);\nMaterial blu = Material(vec3(0.1,0.2,0.6),vec3(0.1,0.1,0.3),vec3(0.99),80.,false);\nMaterial gre = Material(vec3(0.1,0.6,0.2),vec3(0.1,0.4,0.1),vec3(0.99),80.,false);\nMaterial red = Material(vec3(0.7,0.1,0.1),vec3(0.2,0.1,0.1),vec3(0.99),80.,false);\n\nconst Plane plano = Plane(vec3(0.,-2.,0.),vec3(0.,1.,0.),\n       Material(vec3(0.1,0.3,0.3),vec3(0.1,0.2,0.2),vec3(0.0),1.,false),\n       Material(vec3(0.5,0.4,0.1),vec3(0.3,0.2,0.1),vec3(0.0),1.,false) );\n    \n// Encontra Esfera\nHitInf findSphere(Sphere s, Ray ray) {\n    HitInf hit = nulo;\n    vec3 or = ray.ori - s.cen;\n    vec3 dir = ray.dir;\n    \n    float A = dot (dir,dir);\n    float B = 2.*dot(or,dir);\n    float C = dot(or,or) - s.rai*s.rai;\n    \n    float delt = B*B - 4.*A*C;\n    if(delt<0.) return hit;\n    \n    float t1 = (-B-sqrt(delt))/(2.*A);\n    float t2 = (-B-sqrt(delt))/(2.*A);\n    float t = min( max(0.,t1),max(0.,t2) );\n    \n    if(t>0.001) {\n    \thit.hit = true;\n        hit.pos = ray.ori + t*ray.dir;\n        hit.nor = (hit.pos - s.cen)/s.rai;\n        hit.mat = s.mat;\n        hit.dis = t;\n        \n        if(s.padrao>0) {\n            float X = hit.pos.x - s.cen.x;\n            float Y = hit.pos.y - s.cen.y;\n            float Z = hit.pos.z - s.cen.z;\n            \n            float sig = degrees(acos( Y/s.rai ));\n            float tet = degrees(atan( Z/X ));\n            tet += mod(180.*step(0.,-X),360.);\n            \n            if(s.padrao == 1){\n                float ang = sin((tet+sig)/2.);\n                if(ang<0.) hit.mat=s.sec;\n            }\n            if(s.padrao==2){\n                float ang = sin(tet/3.)*sin(sig/3.);\n                if(ang<0.) hit.mat=s.sec;\n            }\n            if(s.padrao==3){\n                float ang = pow(sin(tet/10.),4.) + pow(cos(sig/10.),4.);\n                if(ang>0.9) hit.mat=s.sec;\n            }\n        }\n    }\n    \n    return hit;\n}\n\n// Encontra Plano\nHitInf findPlane(Plane p, Ray ray) {\n    HitInf hit = nulo;\n    float t = dot(p.nor,ray.dir);\n    if(t!=0.){\n        t = dot(p.ori - ray.ori,p.nor)/t;\n        if(t>0.001){\n            hit.hit=true;\n            hit.nor=p.nor;\n            hit.pos=ray.ori+t*ray.dir;\n            hit.mat=p.mat;\n            hit.dis=t;\n            \n            float a = sin(hit.pos.x)*sin(hit.pos.z);\n            if(a>0.) hit.mat = p.sec;\n        }\n    }\n    \n    return hit;\n}\n\n\n//Luz minha gente\nconst Ligth luz = Ligth(vec3(50.,50.,50.),vec3(0.99));\nvec3 iluminate(HitInf hit, Ray ray, vec3 camera) {\n    if(!hit.hit) return vec3(0.);\n    vec3 cor = vec3(0.);\n    \n    vec3 L = normalize(luz.pos - hit.pos);\n    vec3 view = normalize(camera - hit.pos);\n    vec3 refl = reflect (-L, hit.nor);\n    float spcFac = max(0.,dot(refl,view));\n    \n    if(!hit.ins) cor += max(0.,dot(L,hit.nor))*hit.mat.dif*luz.cor;\n    cor += hit.mat.amb*luz.cor;\n    if(!hit.ins) cor += hit.mat.spc*luz.cor*pow(spcFac,hit.mat.spf);\n    \n    return cor;\n}\n\nbool sombra(Ray ray, Sphere b){\n    HitInf hit = findSphere(b,ray);\n    if(hit.hit) return true;\n    return false;\n}\n\nHitInf traceScene(Ray ray){\n    \n    HitInf hit = nulo;\n    float t;\n    \n    HitInf aux;\n    \n    for(int i=0;i<3;i++) {\n        aux = findSphere(bola[i],ray);\n        if(!hit.hit || (aux.hit && aux.dis<hit.dis)) {\n        \thit=aux;\n        }\n    }\n    aux = findPlane(plano,ray);\n    if(!hit.hit || (aux.hit && aux.dis<hit.dis)){\n        hit=aux;\n    }\n    for(int i=0;i<3;i++) {\n        bool test = sombra( Ray(hit.pos,normalize(luz.pos - hit.pos)), bola[i] );\n       \tif(test) hit.ins = test;\n    }\n    \n    return hit;\n}\n    \nvec3 rayTrace(Ray ray){\n    \n    HitInf hit = nulo;\n    const int N = 2;\n    float t;\n    vec3 cor = vec3(0.);\n    vec3 camera = ray.ori;\n    \n\tbola[0] = Sphere(vec3(0.,5.,0.),3., metal, blu, 0 );\n\tbola[1] = Sphere(vec3(5.*sin(GT),0.,5.*cos(GT)),2., gre, blu, 2 );\n\tbola[2] = Sphere(vec3(5.*sin(-GT),0.,5.*-cos(GT)),2., red, gre, 1 );\n    \n    hit = traceScene(ray);    \n    if(!hit.hit) return cor;\n    cor += iluminate(hit,ray,ray.ori);\n    cor*=exp(-0.01*hit.dis);\n    if(!hit.mat.rfl) return cor;\n    //return cor;\n    \n    for(int i=1; i<N; i++){\n        ray = Ray(hit.pos,normalize(reflect(ray.dir,hit.nor)));\n        hit = traceScene(ray);   \n    \t//if(!hit.hit) return cor;\n    \tcor *= iluminate(hit,ray,camera);\n        cor*=exp(-0.01*hit.dis);\n    \tif(!hit.mat.rfl) return cor;\n    }\n    //cor += rayReflec( Ray(hit.pos,normalize(reflect(ray.dir,hit.nor)) ));\n    //cor*=exp(-2.*hit.dis);\n    return clamp(cor,0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv/2.;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 up = vec3(0.,1.,0.);\n    \n    vec3 eye = vec3(-15.*sin(iTime/3.),8.,15.*cos(iTime/3.));\n    vec3 tar = vec3(0.,2.,0.);\n    \n    vec3 ww = normalize(tar-eye);\n    vec3 uu = normalize( cross(ww,up) );\n    vec3 vv = normalize( cross(uu,ww) );\n\t\n    vec3 ux = uu*tan(radians(30.));\n    vec3 vy = vv*tan(radians(30.));\n    \n    mat3 camera = mat3(ux,vy,-ww);\n    \n    const float N = 3.;\n    float zoom = 1.;\n    vec3 color = vec3(0.);\n    \n    for(float i = 0.; i<N; i++)\n        for(float j = 0.; j<float(N); j++) {\n    \t\tvec2 o = (1.0+abs(uv.x-0.5)*3.0)*(vec2(float(i),float(j))/float(N)-0.5);\n    \t\tvec2 p = (-iResolution.xy + 2.0*(gl_FragCoord.xy + o))/iResolution.y;\n            vec3 rt = normalize( camera*vec3(p,-zoom) );\n            color += rayTrace( Ray(eye,rt) );\n        \n    }\n    color /= N*N;\n    //color = pow(color,vec3(1./2.2));\n        \n\tfragColor = vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtcSW7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtcXDM", "name": "Mandelbrot set s1511411", "author": "RyoMorimoto", "description": "ç­æ³¢å¤§å­¦æå ±ç§å­¦é¡ã®è¬ç¾©ãè¤ç´ é¢æ°è«ãã®èª²é¡ã¨ãã¦å¶ä½ãã¾ããã", "tags": ["mandelbrot"], "likes": 2, "viewed": 81, "date": "1479813953", "time_retrieved": "2024-06-20T18:45:31.128967", "image_code": "#define xshift 43.0\n#define yshift 34.134\n#define scale .01\n\n\n// è¤ç´ æ°ãï¼ä¹ããé¢æ°\nvec2 dc_square(in vec2 z)\n{\t\n    float re = (z.x*z.x) - (z.y*z.y);\n    float im = 2.0 * z.x * z.y;\n    return vec2(re,im);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    //colã¯å¾ã«ååº§æ¨ã®è²ã«ãªã\n    vec3 col = vec3(0.0, 0.0 ,0.0 );\n    vec2 p = vec2(\n       ((fragCoord.x - iResolution.x/2.0) / iResolution.x)*(iResolution.x/iResolution.y),\n       ((fragCoord.y - iResolution.y/2.0) / iResolution.y)\n       );\n    \n    //vec2 p = -1.0 + 2.5 * fragCoord.xy / iResolution.xy;\n    //p.x *= iResolution.x/iResolution.y;\n    float tz =   -0.7*cos(0.225*iTime)+0.1;\n    float zo = pow( 0.5, 13.0*tz );\n    \n    vec2 z = vec2(0,0);\n    \n    vec2 c = p*zo;\n    \n    c.x += xshift;\n   \tc.y += yshift;\n    c *= scale;\n    \n    \n    for (int i = 0; i < 500; i++) {\n        if(length(z) >= 3.5){\n           col = vec3(1.0-1.0/mod(float(i),8.0),1.0-1.0/mod(float(i),3.0),1.0-1.0/mod(float(i),7.0));\n        }\n        \n        z = dc_square(z) + c;\n    }\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtcXDM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtcXWM", "name": "Kaleido Tunnel", "author": "zackpudil", "description": "Kaleidoscope fractal tunnel. Use mouse to look around.", "tags": ["fractal"], "likes": 57, "viewed": 3186, "date": "1480017817", "time_retrieved": "2024-06-20T18:45:31.650364", "image_code": "float time() { return iTime; }\nvec2 resolution() { return iResolution.xy; }\n\nfloat hash(float n) {\n    return fract(sin(n)*43578.5453);\n}\n\nmat2 rotate(float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\t\n\treturn mat2(c, s, -s, c);\n}\n\nfloat de(vec3 p) {\n\tvec3 op = p;\n\tp = fract(p + 0.5) - 0.5;\n\tp.xz *= rotate(3.14159);\n\tconst int it = 7;\n\tfor(int i = 0; i < it; i++) {\n\t\tp = abs(p);\n\t\tp.xz *= rotate(-0.1 + 0.1*sin(time()));\n\t\tp.xy *= rotate(0.3);\n\t\tp.yz *= rotate(0.0 + 0.2*cos(0.45*time()));\n\t\tp = 2.0*p - 1.0;\n\t}\n    \n    float c = length(op.xz - vec2(0, 0.1*time())) - 0.08;\n\t\n\treturn max(-c, (length(max(abs(p) - 1.3 + texture(iChannel0, vec2(0)).r, 0.0)))*exp2(-float(it)));\n}\n\nfloat trace(vec3 ro, vec3 rd, float mx) {\n\tfloat t = 0.0;\n\tfor(int i = 0; i < 100; i++) {\n\t\tfloat d = de(ro + rd*t);\n\t\tif(d < 0.001*t || t >= mx) break;\n\t\tt += d;\n\t}\n\treturn t;\n}\n\nvec3 normal(vec3 p) {\n\tvec2 h = vec2(0.001, 0.0);\n\tvec3 n = vec3(\n\t\tde(p + h.xyy) - de(p - h.xyy),\n\t\tde(p + h.yxy) - de(p - h.yxy),\n\t\tde(p + h.yyx) - de(p - h.yyx)\n\t);\n\treturn normalize(n);\n}\n\nfloat ao(vec3 p, vec3 n) {\n\tfloat o = 0.0, s = 0.005;\n\tfor(int i= 0; i < 15; i++) {\n\t\tfloat d = de(p + n*s);\n\t\to += (s - d);\n\t\ts += s/(float(i) + 1.0);\n\t}\n\treturn 1.0 - clamp(o, 0.0, 1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n\tvec3 col = vec3(1);\n\t\n\tfloat t = trace(ro, rd, 10.0);\n    if(t < 10.0) {\n        vec3 pos = ro + rd*t;\n        vec3 nor = normal(pos);\n        vec3 ref = normalize(reflect(rd, nor));\n\n        float occ = ao(pos, nor);\n        float dom = smoothstep(0.0, 0.3, trace(pos + nor*0.001, ref, 0.3));\n\n        col = 0.1*vec3(occ);\n        col += clamp(1.0 + dot(rd, nor), 0.0, 1.0)*mix(vec3(1), vec3(1.0, 0.3, 0.3), 1.0 - dom);\n\t\tcol *= vec3(2.0*abs(cos(20.0*pos.x)), 3.3*abs(sin(10.0*pos.z)), 10.0 + t);\t\n    }\n    \n    col = mix(col, vec3(10), 1.0 - exp(-0.16*t));\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = (-resolution() + 2.0*fragCoord.xy)/resolution().y;\n\tvec2 mo = iMouse.z > 0.0 ? (-resolution() + 2.0*iMouse.xy)/resolution().y : vec2(0);\n  \n\tfloat atime = 0.1*time();\n\tvec3 ro = vec3(0.0, 0.0, atime);    \n    vec3 la = vec3(2.0*mo, atime + 1.0);\n    \n\tvec3 ww = normalize(la-ro);\n\tvec3 uu = normalize(cross(vec3(0, 1, 0), ww));\n\tvec3 vv = normalize(cross(ww, uu));\n    mat3 ca = mat3(uu, vv, ww);\n\tvec3 rd = normalize(ca*vec3(uv, 1.97));\n\t\n\tvec3 col = render(ro, rd);\n\t\n\tcol = 1.0 - exp(-0.5*col);\n\tcol = pow(abs(col), vec3(1.0/2.2));\n\tfragColor = vec4(col, 1);\n}", "image_inputs": [{"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtcXWM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtdSWr", "name": "bp Light", "author": "blackpolygon", "description": "Looks kinds like a pulsar or a neutron star", "tags": ["blur", "light"], "likes": 5, "viewed": 225, "date": "1479021037", "time_retrieved": "2024-06-20T18:45:31.935205", "image_code": "// Author: blackpolygon\n\n#define PI 3.14159265359\n\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/min(iResolution.x,iResolution.y);\n    st.x -= 0.35;\n    \n    st -= vec2(0.5);\n    st = rotate2d( sin(iTime/(PI*2.))*PI ) * st;    \n\n    float sint = sin(iTime);\n    \n    float y = pow(st.y, (0.5 - sint *0.4)*5.);\n    vec3 grad = vec3(y);\n    \n    vec3 basecolor = vec3(0.080,0.003,0.020);\n    vec3 color = grad* vec3(0.149,0.369,0.980);\n    vec3 final = basecolor+color;\n    \n    \n    float w = 0.5 + sint*0.2    - pow(abs(st.x),0.324);\n    vec3 grad2 = vec3(w);\n       \n    final = final + grad2;\n    \n    float b1a0 = 0.5 + sint*0.5;\n    vec2 pos = st;\n\n    float r = length(pos)*2.0;\n    float a = atan(pos.y,pos.x);\n    float f = abs(cos(a*1.))*0.01;\n\n    color = vec3( 1.-smoothstep(f,f+ 0.02+ b1a0*0.10,r) );\n\tcolor = color * vec3(0.860,0.759,0.410);\n    final = final + color;\n    \n     fragColor = vec4(final,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtdSWr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtdXDM", "name": "Circle rotation", "author": "gigatron", "description": "Watching iq youtube shadertoy tutorial... and played quickly with circle distance length !", "tags": ["circle", "iq", "rotation"], "likes": 2, "viewed": 155, "date": "1479983275", "time_retrieved": "2024-06-20T18:45:32.371457", "image_code": "// (c) Gigat(ronAN) France  24/11/2016 ;\n#define time iTime\n\n#define tex   // textured ?\n\n\n  \t\n\n\n\nvec2 rotation(in float angle,in vec2 position,in vec2 center)\n{\n    //Function seen from https://www.shadertoy.com/view/XlsGWf\n    float rot = radians(angle);\n    mat2 rotation = mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n    return vec2((position-center)*rotation);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n    \n    fragColor = vec4(0.,.0,0.,0.);// ios !\n    \n    \n    float a_xz =  0.002+time*0.02;\n  \t float a_yz = 0.002+time*1.08;\n \t float a_xy = 0.002*time*0.28;\n\t// stolen rotation formula \n \t mat2 rot_xz = mat2(cos(a_xz),sin(a_xz),-sin(a_xz),cos(a_xz));\t\n \t mat2 rot_yz = mat2(cos(a_yz),sin(a_yz),-sin(a_yz),cos(a_yz));\t\t\n \t mat2 rot_xy = mat2(cos(a_xy),sin(a_xy),-sin(a_xy),cos(a_xy));\n    \n    \n    \n       \n \tvec2 q = p*2.-1.  ; // center draw inside this vector ;\n    q.x *=iResolution.x/iResolution.y*.95;\t\n           \n\t q *=-rot_xz;\n    \n    q  *=-0.1+rot_yz+0.2*sin(time*0.02 )*0.002 ;\n\t \n      vec2  tuv = vec2(fract((p*2.-1.)*0.2));\n      tuv =rotation(time*20.,p*2.-1.,vec2(0.,0.));\n      vec3 tx = texture(iChannel1,  tuv).rgb;\n      vec3 col =vec3(0.5,0.5,1.00); // IQ colors\n \t   #ifdef tex\n       col /=tx ;   // enable texture \n       #endif \n    \n\tfloat r = 0.008;\n    for(float i= 0.0;i<46.0;i++){   //0-46 xx\n\t   for(float j= 0.0;j<36.0;j++){ // 0-36 yy \n\t   \n    col *= smoothstep( r, r+j/600., length( q-vec2(-0.9+i/60.0, 0.90-j/20.))/j*36. );\n    \n    q *=rot_xy;\n  \t  \n        \n   \t }\n\t}   \n    \n    col -=vec3(p.x,p.x,p.y*0.8);\n    col.zx *=rot_xz*sin(time)-p.y;\n\n\tfragColor = 0.2-vec4(col,1.0);\n\t\n// vector calculation is now much faster ... paranoimia amiga intro\n// End of Transmission;    \n  \n}\n\n/* Britney iChannel0 \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 tex = texture(iChannel0, uv * vec2(1, 1)).rgba;\n    \n    float l = tex.r * 0.22 + tex.g * 0.11 + tex.b * 0.11;\n   \n    \n    float d = tex.t*8. ;\n  \n    if(tex.g<0.299) l = step(1.0 - l, mod(d, 1.2));\n   \n    \n     fragColor = vec4(tex+l);\n}\n*/", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "MdBGDh", "previewfilepath": "https://soundcloud.com/arcade-music-tribute/hybris", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/arcade-music-tribute/hybris", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtdXDM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtdXR4", "name": "IFS experimenting", "author": "deadmanswitch", "description": "Experimenting", "tags": ["fractal", "experiment", "ifs"], "likes": 11, "viewed": 181, "date": "1478451403", "time_retrieved": "2024-06-20T18:45:33.129149", "image_code": "// tetrahedron: https://www.shadertoy.com/view/ltVGzy\n\n#define FOV 60.0\n\n#define MAX_STEP   48\n#define MAX_STEP_F 48.0\n\n// constants\nconst float infinity = 1.0/0.000000001;\nconst float PI = asin(1.0)*2.0;\n\n\n// min/max vec\nfloat max4(in vec4 v4) {\n    return max( max(v4.x, v4.y), max(v4.z, v4.w) );\n}\n\nfloat min4(in vec4 v4) {\n    return min( min(v4.x, v4.y), min(v4.z, v4.w) );\n}\n\n// rotations\nvec3 rotateX(in vec3 vec, in float rad) {\n    \n    return vec3(\n        vec[0],\n        vec[1]*cos(rad) - vec[2]*sin(rad),\n        vec[1]*sin(rad) + vec[2]*cos(rad)\n    );\n        \n}\n\nvec3 rotateY(in vec3 vec, in float rad) {\n    \n    return vec3(\n        vec[2]*sin(rad) + vec[0]*cos(rad),\n        vec[1],\n        vec[2]*cos(rad) - vec[0]*sin(rad)\n    );\n}\n\nvec3 rotateZ(in vec3 vec, in float rad) {\n    \n    return vec3(\n        vec[0]*cos(rad) - vec[1]*sin(rad),\n        vec[0]*sin(rad) + vec[1]*cos(rad),\n        vec[2]\n    );\n}\n\n// return the vector closest to `p`\nvec3 closestTo(in vec3 p, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    \n    vec4 ll = vec4(\n    \tdistance(a,p),\n        distance(b,p),\n        distance(c,p),\n        distance(d,p)\n    );\n    \n    float sh = min4(ll);\n    \n    vec4 eq = vec4(notEqual(ll, vec4(sh)));\n    \n    return mix(a, mix( b, mix(c, d, eq.z ), eq.y ), eq.x );\n    \n}\n\n// points\nconst vec3 point0 = vec3( 0.0,                 1.0,                 0.0);\nconst vec3 point1 = vec3( 0.9428090453147888, -0.3333333432674408,  0.0);\nconst vec3 point2 = vec3(-0.4714045226573944, -0.3333333432674408, -0.8164966106414795);\nconst vec3 point3 = vec3(-0.4714045226573944, -0.3333333432674408,  0.8164966106414795);\n\nconst mat2 foldb = mat2(0.7071067690849304, -0.7071067690849304, 0.7071067690849304, 0.7071067690849304);\nconst mat2 foldi = mat2(0.7071067690849304, 0.7071067690849304, -0.7071067690849304, 0.7071067690849304);\n\nvoid fold(inout vec2 vec) {\n    vec = (abs(vec*foldb))*foldi;\n}\n\n// the distance estimator function\nconst int STEPS = 16;\nfloat DE(in vec3 pos) {\n    \n    // rotation\n    float rot = (iTime*0.25*0.25)*PI*2.0;\n    pos = rotateY(pos, rot);\n    \n    // steps\n    vec3 p = pos;\n    for(int i=0; i<STEPS; i++) {\n        \n        fold(p.xy);\n        p = rotateY(p,  0.2+cos(iTime)*0.1);\n        fold(pos.xz);\n        p = rotateZ(p, -0.6-cos(iTime)*0.1);\n        \n        // scale the current point, and find the closest point vertex\n        p *= 2.0;\n        p = p-closestTo(p, point0, point1, point2, point3);\n        \n    }\n    \n    // calculate the distance to the last found tetrahedron ( for STEPS=0 -> tet(pos, 1.0) )\n    return length(p)/exp2(float(STEPS));\n    \n}\n\nconst vec3 shadowColor = vec3(0.05, 0.0, 0.05);\nconst vec3 backColor = vec3(0.2, 0.2, 0.5);\nconst vec3 tetColor = vec3(0.2, 0.75, 0.25);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // camera\n\tvec2 view = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    \n    float aspect = iResolution.x/iResolution.y;\n    float a = tan(FOV * (PI/180.0) / 2.0);\n    vec2 ab = vec2(a * aspect, a);\n    \n    // the start point, and the direction of the ray\n    vec3 dir = normalize(vec3(ab*view, -1.0));\n    vec3 point = vec3(0.0, 0.0, 1.2+sin(iTime*0.25)*0.5);\n    \n    // ray-march\n    float closest = infinity;\n\n    for(int i = 0; i<MAX_STEP; i++) {\n\n        vec3 pos = point;\n\n        float dist = DE(pos);\n\n        if(dist < 0.001) {\n            fragColor = vec4(mix(\n                tetColor,\n                shadowColor,\n                sqrt(float(i)/MAX_STEP_F)\n            ), 1.0);\n            return;\n        }\n\n        closest = min(closest, dist);\n\t\t\n        // cannot take a full step :( ( *0.75 )\n        point += dir*dist*0.75;\n\n    }\n\n    fragColor = vec4(mix(\n        shadowColor,\n        backColor,\n        sqrt(clamp(closest/0.5, 0.0, 1.0))\n    ), 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtdXR4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtdXzB", "name": "zizou", "author": "faof", "description": "shader oui", "tags": ["tags"], "likes": 1, "viewed": 380, "date": "1480336105", "time_retrieved": "2024-06-20T18:45:34.329394", "image_code": "// Blobs\n// Eric Galin\n\nconst int Steps = 1000;\nconst float Epsilon = 0.05; // Marching epsilon\nconst float T=0.5;\n\nconst float rA=10.0; // Maximum ray marching or sphere tracing distance from origin\nconst float rB=40.0; // Minimum\n\n// Transforms\nvec3 rotateX(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n\nvec3 rotateZ(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.y, -sa*p.x + ca*p.y, p.z);\n}\n\n\n// Smooth falloff function\n// r : small radius\n// R : Large radius\nfloat falloff( float r, float R )\n{\n  float x = clamp(r/R,0.0,1.0);\n  float y = (1.0-x*x);\n  return y*y*y;\n}\n\n// Primitive functions\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : large radius\nfloat point(vec3 p, vec3 c, float e,float R)\n{\n  return e*falloff(length(p-c),R);\n}\n\n\nfloat segment(vec3 p, vec3 a, vec3 b, float e, float r){\n\tvec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return e*falloff(length( pa - ba*h ),r);\n}\n\n\n// Blending\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Blend(float a,float b)\n{\n    return a+b;\n}\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Union(float a,float b)\n{\n    return max(a,b);\n}\n\n// Potential field of the object\n// p : point\nfloat object(vec3 p)\n{\n  p.z=-p.z;\n  float v = Blend(point(p,vec3( 0.0, 1.0, 1.0),1.0,4.5),\n                  segment(p,vec3( 2.0, 0.0,-3.0),vec3( 12.0, 0.0,-3.0),1.0,2.0));\n  return v-T;\n}\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n  float eps = 0.0001;\n  vec3 n;\n  float v = object(p);\n  n.x = object( vec3(p.x+eps, p.y, p.z) ) - v;\n  n.y = object( vec3(p.x, p.y+eps, p.z) ) - v;\n  n.z = object( vec3(p.x, p.y, p.z+eps) ) - v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat Trace(vec3 o, vec3 u, out bool h,out int s)\n{\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p);\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += Epsilon;\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, out bool h,out int s)\n{\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p);\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += max(Epsilon,abs(v)/4.0);\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n\n// Background color\nvec3 background(vec3 rd)\n{\n  return mix(vec3(0.4, 0.3, 0.0), vec3(0.7, 0.8, 1.0), rd.y*0.5+0.5);\n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\nvec3 Shade(vec3 p, vec3 n)\n{\n  // point light\n  const vec3 lightPos = vec3(5.0, 5.0, 5.0);\n  const vec3 lightColor = vec3(0.5, 0.5, 0.5);\n\n  vec3 c = 0.25*background(n);\n  vec3 l = normalize(lightPos - p);\n\n  // Not even Phong shading, use weighted cosine instead for smooth transitions\n  float diff = 0.5*(1.0+dot(n, l));\n\n  c += diff*lightColor;\n\n  return c;\n}\n\n// Shading with number of steps\nvec3 ShadeSteps(int n)\n{\n   float t=float(n)/(float(Steps-1));\n   return vec3(t,0.25+0.75*t,0.5-0.5*t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 pixel = (gl_FragCoord.xy / iResolution.xy)*2.0-1.0;\n\n  // compute ray origin and direction\n  float asp = iResolution.x / iResolution.y;\n  vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -4.0));\n  vec3 ro = vec3(0.0, 0.0, 20.0);\n\n  // vec2 mouse = iMouse.xy / iResolution.xy;\n  float a=iTime*0.25;\n  ro = rotateY(ro, a);\n  rd = rotateY(rd, a);\n\n  // Trace ray\n  bool hit;\n\n  // Number of steps\n  int s;\n\n  float t = SphereTrace(ro, rd, hit,s);\n  vec3 pos=ro+t*rd;\n  // Shade background\n  vec3 rgb = background(rd);\n\n  if (hit)\n  {\n    // Compute normal\n    vec3 n = ObjectNormal(pos);\n\n    // Shade object with light\n    rgb = Shade(pos, n);\n  }\n\n  // Uncomment this line to shade image with false colors representing the number of steps\n  //rgb = ShadeSteps(s);\n\n  fragColor=vec4(rgb, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtdXzB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XttSW8", "name": "Parametric Surface Plotter", "author": "lara", "description": "Couldn't find one through the search so I thought I'd give it a go.\nYou can input your own equation and tweak some parameters.", "tags": ["surface", "plotter", "parametric"], "likes": 19, "viewed": 790, "date": "1479312724", "time_retrieved": "2024-06-20T18:45:34.329394", "image_code": "//#define CROSSEYE 0.2\n\n#define STEPS 10.\n#define ORTHOGONAL\n#define SURFACE\n#define MESH vec4(vec3(0),0.01)\n\n#define PI  3.14159\n#define TAU 6.28318\n#define T   iTime\n\nconst float U_MIN = 0.0;\nconst float U_MAX = TAU;\nconst float V_MIN = 0.0;\nconst float V_MAX = TAU;\n\n// Your equation here\n\nvec3 fn(float u, float v)\n{\n    // Torus:  return vec3(cos(u)*(1.-cos(v)*0.5),sin(v)*0.5,sin(u)*(1.-cos(v)*0.5));\n    // Sphere: return vec3(sin(u)*cos(v),sin(v),cos(u)*cos(v) );\n    // Cone:   return vec3(sin(u),1,cos(u))*sin(v);\n\t// Plane:  return vec3(u-PI,1,v-PI)*0.5;\n    // Vase:   return vec3(cos(u),(v-PI)/TAU*3.,sin(u))*vec2((1.-cos(v-PI*1.5)*0.5)*step(0.01,v),1).xyx*0.7;\n    \n    // Klein Bottle:\n    // (from https://de.wikipedia.org/wiki/Kleinsche_Flasche#Beschreibung_im_3-dimensionalen_Raum)\n    \n    float r = 2.0-cos(u);\n\n    return vec3(\n        2.0*(1.0-sin(u))*cos(u)+r*cos(v)*(2.0*exp(-pow(u/2.0-PI,2.0))-1.0),\n        r*sin(v),\n        6.0*sin(u) + 0.5*r*sin(u)*cos(v)*exp(-pow(u-3.0*PI/2.0,2.0))\n    ).xzy*0.2;\n}\n\n/* -------------------------------------------------------------------------------------------------------- */\n\n\nconst float U_STP = (U_MAX-U_MIN)/STEPS;\nconst float V_STP = (V_MAX-V_MIN)/STEPS;\n\nstruct Ray    { vec3 o, d; };\nstruct Camera { vec3 p, t; };\nstruct Hit    { vec3 p, n; float t; int id; };\n    \nCamera _cam = Camera(vec3(0,0,-2.5), vec3(0));\nHit _miss   = Hit(vec3(0),vec3(0),-1e10, 0);\n\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nbool isNan(float val){return(val<=0.||0.<=val)?false:true;}\n\nHit triangle(Ray r, vec3 a, vec3 b, vec3 c, int id)\n{\n\tvec3 ab = b-a, bc = c-b, ac = c-a;\n\tvec3 n = cross(ab,ac);\n\n\tfloat nrd = dot(n,r.d);\n    if (abs(nrd) < 0.001 || isNan(nrd) == true) { return _miss; }\n\n\tfloat t = -dot(n,r.o-a)/nrd;\n    if (t < 0.0) { return _miss; }\n\n\tvec3 p = r.o+r.d*t;\n\n    if(dot(n,cross( ab,p-a)) < 0.0\n    || dot(n,cross( bc,p-b)) < 0.0\n    || dot(n,cross(-ac,p-c)) < 0.0) { return _miss; }\n    \n\treturn Hit(b+bc/2.,vec3(sign(nrd)),t,id);\n}\n\n// Can probably be simpilfied a lot\nHit line(Ray r, vec3 pa, vec3 pb, float sr, int id)\n{\n    vec3 ab = pb-pa;\n    vec3 oa = pa-r.o;\n    \n    float dabrd = dot(ab,r.d);\n    float drdrd = dot(r.d,r.d);\n    \n    float det = dot(ab,ab)*drdrd-dot(ab,r.d)*dabrd;\n    if (det == 0.) { return _miss; }\n\n\tvec3 sp = pa+ab*clamp((dot(oa,r.d)*dabrd-dot(oa,ab)*drdrd)/det,0.,1.);\n\n    r.o -= sp;\n\n    float a = drdrd;\n    float b = 2.0*dot(r.o,r.d);\n    float c = dot(r.o,r.o)-sr*sr;\n    float d = pow(b,2.0)-4.0*a*c;\n\n    if (d < 0.0) { return _miss; }\n    \n    float s = sqrt(d);\n    float t = min(-b+s,-b-s)/(2.*a);\n    \n    return Hit(vec3(0), vec3(0), t, id);\n\n    // vec3 p = r.o+sp+r.d*t;\n\t// vec3 n = normalize(p-sp);\n    \n    // return Hit(p, n, t, id);\n}\n\nfloat compare(inout Hit a, Hit b)\n{\n    if (a.t < 0.0 || b.t > 0.0 && b.t < a.t)\n    {\n        a = b;\n        return 1.0;\n    }\n    \n\treturn 0.0;\n}\n\nHit trace(Ray r)\n{\n    Hit h = _miss;\n    \n    for(float u = U_MIN; u < U_MAX; u += U_STP)\n    {          \n        for(float v = V_MIN; v < V_MAX; v += V_STP)\n        {        \n            vec3 a = fn(u,v);\n            vec3 b = fn(u,v+V_STP);\n            vec3 c = fn(u+U_STP,v);\n\n            #ifdef MESH\n            \n            \tcompare(h,line(r,a,b,MESH.w,0));\n            \tcompare(h,line(r,a,c,MESH.w,0));\n            \n            #endif\n\n            #ifdef SURFACE\n                \n                vec3 d = fn(u+U_STP,v+V_STP);\n            \n                float comp = max(\n                    compare(h,triangle(r,a,b,c,1)),\n                    compare(h,triangle(r,d,c,b,1))\n                );\n\n                if (comp > 0.0)\n                {\n                    h.n = normalize(cross(a-b,d-b))*h.n.x;\n                }\n\n            #endif\n        }\n    }\n\n    return h;\n}\n\nRay lookAt(Camera cam, vec2 uv)\n{\n    vec3 d = normalize(cam.t-cam.p);\n    vec3 r = normalize(cross(d,vec3(0,1,0)));\n    vec3 u = cross(r,d);\n\t\n    #ifndef ORTHOGONAL\n    return Ray(cam.p,normalize(r*uv.x + u*uv.y + d));\n    #else\n    return Ray(cam.p+(r*uv.x + u*uv.y)*2.0, d);\n    #endif\n}\n\nvec3 getColor(Hit h)\n{\n    if(h.t <= 0.0) { return vec3(0.2); }\n    \n    #ifdef MESH\n    if(h.id == 0) { return MESH.rgb; }\n    #endif\n    \n    // float diff = max(dot(normalize(_cam.p-h.p),h.n),0.5);\n    // float spec = pow(max(dot(reflect(normalize(h.p-_cam.p),h.n),normalize(_cam.p-h.p)),0.0),100.);\n    \n    return normalize(h.n+1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // normalized screen and mouse coordinates\n    vec2 uv  = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.yy;\n    vec2 uvm = (2.0 * iMouse.xy    - iResolution.xy) / iResolution.xy;\n    \n    if (iMouse.y < 10. && iMouse.x < 10.) { uvm = vec2(T*0.1+PI/2.1, 0.4); }\n    \n\t#ifdef CROSSEYE\n    _cam.p.x += sign(uv.x)*CROSSEYE;\n    uv.x = mod(uv.x,1.5)-1.5/2.;\n    #endif\n    \n    // cam rotation\n    _cam.p.yz *= rot(uvm.y*PI/2.);\n    _cam.p.xz *= rot(uvm.x*TAU);\n    \n    // vignette\n    float f = 1.-length((2.0*fragCoord.xy-iResolution.xy)/iResolution.xy)*0.25;\n    \n    fragColor = vec4(getColor(trace(lookAt(_cam,uv))),1)*f;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XttSW8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XttSWN", "name": "Shinto Shrine Archway", "author": "gam0022", "description": "Inspired by \"Fushimi Inari Shrine\" and \"Itsukushima Shrine\".", "tags": ["raymarching", "glow"], "likes": 20, "viewed": 406, "date": "1479693702", "time_retrieved": "2024-06-20T18:45:34.335391", "image_code": "// consts\nconst float EPS = 1e-4;\nconst float OFFSET = EPS * 10.0;\nconst float PI = 3.14159;\nconst float INF = 1e+10;\n\nconst vec3 lightDir = vec3( -0.48666426339228763, 0.8111071056538127, -0.3244428422615251 );\nconst vec3 backgroundColor = vec3( 0.0 );\nconst vec3 gateColor = vec3( 1.0, 0.1, 0.1 );\n\nconst float totalTime = 75.0;\n\n// globals\nvec3 cPos, cDir;\nfloat normalizedGlobalTime = 0.0;\n//vec3 illuminationColor;\n\nstruct Intersect {\n    bool isHit;\n\n    vec3 position;\n    float distance;\n    vec3 normal;\n\n    int material;\n    vec3 color;\n};\n    \nconst int BASIC_MATERIAL = 0;\nconst int MIRROR_MATERIAL = 1;\n\n\n// distance functions\nvec3 opRep( vec3 p, float interval ) {\n    return mod( p, interval ) - 0.5 * interval;\n}\n\nvec2 opRep( vec2 p, float interval ) {\n    return mod( p, interval ) - 0.5 * interval;\n}\n\nfloat opRep( float x, float interval ) {\n    return mod( x, interval ) - 0.5 * interval;\n}\n\nfloat sphereDist( vec3 p, vec3 c, float r ) {\n    return length( p - c ) - r;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h ) {\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n    return length(max(abs(p)-b,0.0));\n}\n\nfloat udFloor( vec3 p ){\n    float t1 = 1.0;\n    float t2 = 3.0;\n    float d = -0.5;\n    for( float i = 0.0; i < 3.0; i++ ) {\n        float f = pow( 2.0, i );\n    \td += 0.1 / f * ( sin( f * t1 * p.x + t2 * iTime ) + sin( f * t1 * p.z + t2 * iTime ) );\n    }\n\treturn dot(p,vec3(0.0,1.0,0.0)) - d;\n}\n\nfloat dGate( vec3 p ) {\n    p.y -= 1.3 * 0.5;\n    \n    float r = 0.05;\n    float left  = sdCappedCylinder( p - vec3( -1.0, 0.0, 0.0 ),  vec2(r, 1.3));\n    float right = sdCappedCylinder( p - vec3( 1.0,  0.0, 0.0 ),  vec2(r, 1.3));\n\n    float ty = 0.02 * p.x * p.x;\n    float tx = 0.5 * ( p.y - 1.3 );\n    float katsura  = udBox( p - vec3( 0.0, 1.3 + ty, 0.0 ), vec3( 1.7 + tx, r * 2.0 + ty, r ) );\n\n    float kan = udBox( p - vec3( 0.0, 0.7, 0.0 ), vec3( 1.3, r, r ) );\n    float gakuduka = udBox( p - vec3( 0.0, 1.0, 0.0), vec3( r, 0.3, r ) );\n\n    return min( min( left, right ), min( gakuduka, min( katsura, kan ) ) );\n}\n\nfloat dRepGate( vec3 p ) {\n    if ( normalizedGlobalTime <= 0.5 ) {\n        p.z = opRep( p.z, 1.0 + 20.0 * cos( PI * normalizedGlobalTime ) );\n    } else {\n        p.xz = opRep( p.xz, 10.0  );\n    }\n    return dGate( p );\n}\n\nfloat sceneDistance( vec3 p ) {\n    return udFloor( p );\n}\n\n\n// color functions\nvec3 hsv2rgb( vec3 c ) {\n\n    vec4 K = vec4( 1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0 );\n    vec3 p = abs( fract( c.xxx + K.xyz ) * 6.0 - K.www );\n    return c.z * mix( K.xxx, clamp( p - K.xxx, 0.0, 1.0 ), c.y );\n\n}\n\nIntersect minIntersect( Intersect a, Intersect b ) {\n    if ( a.distance < b.distance ) {\n        return a;\n    } else {\n        return b;\n    }\n}\n\nIntersect sceneIntersect( vec3 p ) {\n\n    Intersect a;\n    a.distance = udFloor( p );\n    a.material = MIRROR_MATERIAL;\n    // return minIntersect( a, b );\n    return a;\n}\n\nvec3 getNormal( vec3 p ) {\n\tvec2 e = vec2( 1.0, -1.0 ) * 0.001;\n\treturn normalize(\n\t\te.xyy * sceneDistance( p + e.xyy ) + e.yyx * sceneDistance( p + e.yyx ) + \n\t\te.yxy * sceneDistance( p + e.yxy ) + e.xxx * sceneDistance( p + e.xxx ) );\n}\n\nfloat getShadow( vec3 ro, vec3 rd ) {\n\n    float h = 0.0;\n    float c = 0.0;\n    float r = 1.0;\n    float shadowCoef = 0.5;\n\n    for ( float t = 0.0; t < 50.0; t++ ) {\n\n        h = sceneDistance( ro + rd * c );\n\n        if ( h < EPS ) return shadowCoef;\n\n        r = min( r, h * 16.0 / c );\n        c += h;\n\n    }\n\n    return 1.0 - shadowCoef + r * shadowCoef;\n\n}\n\nIntersect getRayColor( vec3 origin, vec3 ray ) {\n\n    // marching loop\n    float dist, minDist, trueDepth;\n    float depth = 0.0;\n    vec3 p = origin;\n    int count = 0;\n    Intersect nearest;\n\n    // first pass (water)\n    for ( int i = 0; i < 120; i++ ){\n\n        dist = sceneDistance( p );\n        depth += dist;\n        p = origin + depth * ray;\n\n        count = i;\n        if ( abs(dist) < EPS ) break;\n\n    }\n\n    if ( abs(dist) < EPS ) {\n\n        nearest = sceneIntersect( p );\n        nearest.position = p;\n        nearest.normal = getNormal(p);\n        nearest.distance = depth;\n        float diffuse = clamp( dot( lightDir, nearest.normal ), 0.1, 1.0 );\n        float specular = pow( clamp( dot( reflect( lightDir, nearest.normal ), ray ), 0.0, 1.0 ), 6.0 );\n        //float shadow = getShadow( p + nearest.normal * OFFSET, lightDir );\n\n        if ( nearest.material == BASIC_MATERIAL ) {\n        } else if ( nearest.material == MIRROR_MATERIAL ) {\n            nearest.color = vec3( 0.5, 0.7, 0.8 ) * diffuse + vec3( 1.0 ) * specular;\n        }\n\n        nearest.isHit = true;\n\n    } else {\n\n        nearest.color = backgroundColor;\n        nearest.isHit = false;\n\n    }\n    nearest.color = clamp( nearest.color - 0.1 * nearest.distance, 0.0, 1.0 );\n\n    // second pass (gates)\n    p = origin;\n    depth = 0.0;\n    minDist = INF;\n    for ( int i = 0; i < 20; i++ ){\n        dist = dRepGate( p );\n        minDist = min(dist, minDist);\n        /*if ( dist < minDist ) {\n            minDist = dist;\n            trueDepth = depth;\n        }*/\n        depth += dist;\n        p = origin + depth * ray;\n        if ( i == 9 && normalizedGlobalTime <= 0.5 ) {\n            break;\n        }\n    }\n\n    if ( abs(dist) < EPS ) {\n        nearest.color += gateColor;\n    } else {\n        nearest.color += gateColor * clamp( 0.05 / minDist, 0.0, 1.0 );\n    }\n\n    return nearest;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    normalizedGlobalTime = mod( iTime / totalTime, 1.0 );\n\n    // fragment position\n    vec2 p = ( fragCoord.xy * 2.0 - iResolution.xy ) / min(  iResolution.x,  iResolution.y );\n\n    // camera and ray\n    if ( normalizedGlobalTime < 0.7 ) {\n        cPos = vec3( 0.0, 0.6 + 0.4 * cos( iTime ), 3.0 * iTime );\n        cDir = normalize( vec3( 0.0, -0.1, 1.0 ) );\n    } else {\n        cPos = vec3( 0.0, 0.6 + 0.4 * cos( iTime ) + 50.0 * ( normalizedGlobalTime - 0.7 ), 3.0 * iTime );\n        cDir = normalize( vec3( 0.0, -0.1 - ( normalizedGlobalTime - 0.7 ), 1.0 ) );\n    }\n    vec3 cSide = normalize( cross( cDir, vec3( 0.0, 1.0 ,0.0 ) ) );\n    vec3 cUp   = normalize( cross( cSide, cDir ) );\n    float targetDepth = 1.3;\n    vec3 ray = normalize( cSide * p.x + cUp * p.y + cDir * targetDepth );\n\n    // Illumination Color\n    // illuminationColor = hsv2rgb( vec3( iTime * 0.02 + 0.6, 1.0, 1.0 ) );\n\n    vec3 color = vec3( 0.0 );\n    float alpha = 1.0;\n    Intersect nearest;\n\n    for ( int i = 0; i < 3; i++ ) {\n\n        nearest = getRayColor( cPos, ray );\n\n        color += alpha * nearest.color;\n        alpha *= 0.5;\n        ray = normalize( reflect( ray, nearest.normal ) );\n        cPos = nearest.position + nearest.normal * OFFSET;\n\n        if ( !nearest.isHit || nearest.material != MIRROR_MATERIAL ) break;\n\n    }\n\n    fragColor = vec4(color, 1.0);\n\n}", "image_inputs": [{"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XttSWN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XttXD4", "name": "My Rasterizer", "author": "VoidChicken", "description": "I made a rasterizer for fun. ", "tags": ["2d", "3d", "distancefield", "rasterizer", "projection", "distance", "field", "raster"], "likes": 5, "viewed": 245, "date": "1479635002", "time_retrieved": "2024-06-20T18:45:34.335391", "image_code": "#define PI acos(-1.)\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c\n               );\n}\n//iq's distance fields\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\nfloat trid( vec2 p, vec2 a, vec2 b, vec2 c) {\n\treturn udTriangle(vec3(p,0), vec3(a,0), vec3(b,0), vec3(c,0));    \n}\nfloat line( vec2 p, vec2 a, vec2 b, float r) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 c = vec3(0);\n    float df = 1.;\n    float S = 5.;\n    vec3 A = vec3 (0, .5, 0)*S;\n    vec3 B = vec3 (-.5, 0., 0.)*S;\n    vec3 C = vec3 (.5, 0,0)*S;\n    mat3 RMX = rotationMatrix(vec3(sin(iTime),1,cos(iTime)),iTime*3.1415);\n    A*=RMX;\n    B*=RMX;\n    C*=RMX;\n    A+=vec3(0,0,15);\n    B+=vec3(0,0,15);\n    C+=vec3(0,0,15);\n    vec2 PA,PB,PC;\n    float TANHFOV = tan(PI/4.);\n    float DVA = A.z*TANHFOV;\n    float DVB = B.z*TANHFOV;\n    float DVC = C.z*TANHFOV;\n    PA=(A/DVA).xy;\n    PB=(B/DVB).xy;\n    PC=(C/DVB).xy;\n    PA+=.5;\n    PB+=.5;\n    PC+=.5;\n    float r = .0002;\n    bool OLIN=fract(iTime/5.)>.5;\n    if (OLIN) {\n        df=line(uv,PA,PB,r);\n        df=min(df,line(uv,PB,PC,r));\n        df=min(df,line(uv,PC,PA,r));\n    } else {\n    \tdf = trid(uv, PA, PB, PC);    \n    }\n    if (df<.02) c=pow(vec3(1.-df/.02), vec3(5.));\n\tfragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XttXD4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XttXDN", "name": "lcd glitter field", "author": "lebek", "description": "lcd glitter field", "tags": ["glitter"], "likes": 10, "viewed": 585, "date": "1479693743", "time_retrieved": "2024-06-20T18:45:34.602075", "image_code": "\n\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 R =  iResolution.xy,\n         p = (2.*fragCoord - R) / R.y;\n    float speed = .2;\n    vec3 ro = .7*vec3(cos(iTime*speed), 1.0, sin(iTime*speed));\n\t\tvec3 ta = vec3(0);\n\n\t// camera-to-world transformation\n    mat3 ca = setCamera(ro, ta, 0.0);\n\n    // ray direction\n    vec3 rd = ca*normalize(vec3(p,2.0));\n\n\tfloat n = sin(iTime*0.6)*10.+50.;\n    vec3 column = normalize(floor(rd*n));\n    vec2 polar = vec2(acos(column.z), atan(column.y/column.x));\n\tvec2 h = hash(polar);\n    float dist = length(h);\n    fragColor =    dist\n     * step( length(fract(rd*n)-.5) / clamp(dist, 0., 1.), .5 )\n\t * vec4(h, .5,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XttXDN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XttXR4", "name": "fish eye", "author": "lomateron", "description": "just another simple ray marching example", "tags": ["raymarching"], "likes": 3, "viewed": 703, "date": "1478444574", "time_retrieved": "2024-06-20T18:45:34.953547", "image_code": "#define D .0001\nvec3 skyColor(float x)\n{\n\tvec3 v1 = vec3(-.376,-1.798,-2.76);\n\tvec3 v2 = vec3(1.024,2.865,3.722);\n\tvec3 v3 = vec3(.117,-.577,-.894);\n\tvec3 v4 = vec3(.116,.307,.535);\n\tvec3 v5 = vec3(.094,.121,.168);\n\tfloat x2 = x*x;\n\tfloat x3 = x2*x;\n\tfloat x4 = x3*x;\n\treturn v1*x4+v2*x3+v3*x2+v4*x+v5;\n}\nfloat sphrs(vec3 p)\n{\n    return max((length(fract(p)*2.-1.) - 1.), p.y);\n}\nvoid march(vec3 eye, vec3 cam, inout vec3 p, inout float d)\n{\n    float dep = 0.;\n    for (int i = 0; i < 16; ++i)\n    {\n        p = eye + dep*cam;\n        d = sphrs(p);\n        dep += d;\n    }\n}\nvec3 normal(vec3 p, float d){\n    return normalize(vec3(\n        d - sphrs(vec3(p.x - D, p.y, p.z)),\n        d - sphrs(vec3(p.x, p.y - D, p.z)),\n        d - sphrs(vec3(p.x, p.y, p.z - D))\n    ));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //make uv to go form -1 to 1 accros the screen\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv*2.-1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    //calculate fish eye camera\n    vec3 cam = normalize(vec3(uv,sqrt(1.-dot(uv,uv))));\n    \n    //rotate cam vector in x axis by t radians\n    float t = (sin(iTime)-1.)*-.5;\n    cam = vec3(cam.x,\n               cos(t)*cam.y-sin(t)*cam.z,\n               sin(t)*cam.y+cos(t)*cam.z);\n    \n    //calculate camera position\n    vec3 eye = vec3(iMouse.x*.01,1.,iMouse.y*.01+iTime-40.);\n    \n    //calculate final color shown in every pixel\n    vec3 p;\n    float d;\n    march(eye, cam, p, d);\n    vec3 n = cam;\n    if(d<D){ n = normal(p, d); }\n\tfragColor = vec4(skyColor(n.y),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XttXR4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XttXW8", "name": "Hypercube", "author": "lara", "description": "A very cheap method. :P", "tags": ["3d", "raymarching", "4d", "tesseract", "hypercube"], "likes": 6, "viewed": 438, "date": "1479314762", "time_retrieved": "2024-06-20T18:45:35.832713", "image_code": "#define S 128  // Steps\n#define P 0.01 // Precision\n#define D 5.   // Max distance\n\n#define T iTime+1.0\n//#define CROSSEYE 0.2\n\nstruct Ray { vec3 o, d; };\nstruct Camera { vec3 p, t; };\nstruct Hit { vec3 p; float t, d; };\n\nCamera _cam = Camera(vec3(0,0,-2.3),vec3(0));\n\nfloat sdLine(vec3 p, vec3 a, vec3 b)\n{\n\tvec3 ab = b-a, ap = p-a;\n\treturn length(ap-ab*clamp(dot(ap,ab)/dot(ab,ab),0.,1.))-0.025;\n}\n\nmat2 rot(float a)\n{\n    float c=cos(a),s=sin(a);\n    return mat2(c,-s,s,c);\n}\n\n// Vertices\nconst vec3 lbf = vec3(-0.5,-0.5,-0.5);\nconst vec3 rbf = vec3( 0.5,-0.5,-0.5);\nconst vec3 lbb = vec3(-0.5,-0.5, 0.5);\nconst vec3 rbb = vec3( 0.5,-0.5, 0.5);\n\nconst vec3 ltf = vec3(-0.5, 0.5,-0.5);\nconst vec3 rtf = vec3( 0.5, 0.5,-0.5);\nconst vec3 ltb = vec3(-0.5, 0.5, 0.5);\nconst vec3 rtb = vec3( 0.5, 0.5, 0.5);\n\nvec3 lbfi,rbfi,lbbi,rbbi,ltfi,rtfi,ltbi,rtbi,lbf_lbfi,ltf_ltfi,lbb_lbbi,ltb_ltbi,rbb_lbb,rbf_lbf,rtf_ltf,rtb_ltb,lbfi_rbfi,lbbi_rbbi,ltfi_rtfi,ltbi_rtbi,rbbi_rbb,rbfi_rbf,rtfi_rtf,rtbi_rtb;\n\nfloat scene(vec3 p)\n{\n    float d = 1e10;\n\n\t// outside\n\td = min(d,sdLine(p,lbf_lbfi,rbf_lbf));\n\td = min(d,sdLine(p,lbb_lbbi,rbb_lbb));\n\td = min(d,sdLine(p,ltf_ltfi,rtf_ltf));\n\td = min(d,sdLine(p,ltb_ltbi,rtb_ltb));\n\n\td = min(d,sdLine(p,lbf_lbfi,lbb_lbbi));\n\td = min(d,sdLine(p,ltf_ltfi,ltb_ltbi));\n\td = min(d,sdLine(p,lbf_lbfi,ltf_ltfi));\n\td = min(d,sdLine(p,lbb_lbbi,ltb_ltbi));\n\n\td = min(d,sdLine(p,rbf_lbf,rbb_lbb));\n\td = min(d,sdLine(p,rtf_ltf,rtb_ltb));\n\td = min(d,sdLine(p,rbf_lbf,rtf_ltf));\n\td = min(d,sdLine(p,rbb_lbb,rtb_ltb));\n\n    // inside\n\td = min(d,sdLine(p,lbfi_rbfi,lbbi_rbbi));\n\td = min(d,sdLine(p,ltfi_rtfi,ltbi_rtbi));\n\td = min(d,sdLine(p,lbfi_rbfi,ltfi_rtfi));\n\td = min(d,sdLine(p,lbbi_rbbi,ltbi_rtbi));\n\n\td = min(d,sdLine(p,lbbi_rbbi,rbbi_rbb));\n\td = min(d,sdLine(p,lbfi_rbfi,rbfi_rbf));\n\td = min(d,sdLine(p,ltfi_rtfi,rtfi_rtf));\n\td = min(d,sdLine(p,ltbi_rtbi,rtbi_rtb));\n\n\td = min(d,sdLine(p,rbfi_rbf,rtfi_rtf));\n\td = min(d,sdLine(p,rbbi_rbb,rtbi_rtb));\n\td = min(d,sdLine(p,rbfi_rbf,rbbi_rbb));\n\td = min(d,sdLine(p,rtfi_rtf,rtbi_rtb));\n\n    // connections\n\td = min(d,sdLine(p,rtbi_rtb,rtb_ltb));\n\td = min(d,sdLine(p,rbfi_rbf,rbf_lbf));\n\td = min(d,sdLine(p,rbbi_rbb,rbb_lbb));\n\td = min(d,sdLine(p,rtfi_rtf,rtf_ltf));\n\t\n\td = min(d,sdLine(p,ltfi_rtfi,ltf_ltfi));\n\td = min(d,sdLine(p,ltbi_rtbi,ltb_ltbi));\n\td = min(d,sdLine(p,lbfi_rbfi,lbf_lbfi));\n\td = min(d,sdLine(p,lbbi_rbbi,lbb_lbbi));\n\t\n\treturn d;\n}\n\nvec3 getNormal(vec3 p)\n{\n\tvec2 e = vec2(P,0);\n\t\n\treturn normalize(vec3(\n\t\tscene(p+e.xyy)-scene(p-e.xyy),\n\t\tscene(p+e.yxy)-scene(p-e.yxy),\n\t\tscene(p+e.yyx)-scene(p-e.yyx)\n\t));\n}\n\nRay lookAt(Camera cam, vec2 c)\n{\n\tvec3 dir = normalize(cam.t-cam.p);\n\tvec3 right = normalize(cross(dir,vec3(0,1,0)));\n\tvec3 up = cross(right,dir);\n\n\treturn Ray(cam.p,normalize(right*c.x+up*c.y+dir));\n}\n\nHit march(Ray r)\n{\n\tfloat t = 0.0, d;\n\t\n\tfor(int i = 0; i < S; i++)\n\t{\n\t\td = scene(r.o+r.d*t);\n\t\tt += d;\n\t\t\n\t\tif (d < P || t > D) { break; }\n\t}\n\t\n\treturn Hit(r.o+r.d*t, t, d);\n}\n\n\nvec3 getColor(Hit h)\n{\t\n\tif (h.d > P) { return vec3(1); }\n\n\tvec3 n = getNormal(h.p);\n\tvec3 light = _cam.p+vec3(0,0.1,0);\n\t\n\tfloat d = 1e10;\n    float diff = 1.-max(dot(normalize(light-h.p),n),0.0);\n    float spec = pow(max(dot(normalize(reflect(h.p-_cam.p,n)),-normalize(h.p-light)),0.0),100.);\n\n\treturn (vec3(2,0,1)*diff+spec);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.xx;\n    \n\t#ifdef CROSSEYE\n    _cam.p.x += sign(uv.x)*CROSSEYE;\n    uv.x = mod(uv.x,1.)-0.5;\n    #endif\n    \n    _cam.p.zy *= rot(T);\n    _cam.p.xy *= rot(T);\n\n\tfloat t = mod(T,1.0);\n\tfloat s = (sin(T*0.5)+1.0)/2.0*0.15+0.15;\n\n\tlbfi = vec3(-0.5+s,-0.5+s,-0.5+s);\n\trbfi = vec3( 0.5-s,-0.5+s,-0.5+s);\n\tlbbi = vec3(-0.5+s,-0.5+s, 0.5-s);\n\trbbi = vec3( 0.5-s,-0.5+s, 0.5-s);\n\tltfi = vec3(-0.5+s, 0.5-s,-0.5+s);\n\trtfi = vec3( 0.5-s, 0.5-s,-0.5+s);\n\tltbi = vec3(-0.5+s, 0.5-s, 0.5-s);\n\trtbi = vec3( 0.5-s, 0.5-s, 0.5-s);\n    \n\tlbf_lbfi = mix(lbf,lbfi,t);\n\tltf_ltfi = mix(ltf,ltfi,t);\n\tlbb_lbbi = mix(lbb,lbbi,t);\n\tltb_ltbi = mix(ltb,ltbi,t);\n    \n\trbb_lbb = mix(rbb,lbb,t);\n\trbf_lbf = mix(rbf,lbf,t);\n\trtf_ltf = mix(rtf,ltf,t);\n\trtb_ltb = mix(rtb,ltb,t);\n    \n\tlbfi_rbfi = mix(lbfi,rbfi,t);\n\tlbbi_rbbi = mix(lbbi,rbbi,t);\n\tltfi_rtfi = mix(ltfi,rtfi,t);\n\tltbi_rtbi = mix(ltbi,rtbi,t);\n    \n\trbbi_rbb = mix(rbbi,rbb,t);\n\trbfi_rbf = mix(rbfi,rbf,t);\n\trtfi_rtf = mix(rtfi,rtf,t);\n\trtbi_rtb = mix(rtbi,rtb,t);\n\n\tvec3 f = 1.0-length(uv)*vec3(1.2,1.2,1)*0.5;\n\tfragColor = vec4(getColor(march(lookAt(_cam,uv)))*f,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XttXW8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XttXzM", "name": "Volumestone", "author": "VoidChicken", "description": "A stone that has transparent layers. Raycasting the ground. (Earlier: Pretty laggy on weak GPUs.)", "tags": ["3d", "volume", "raymarch", "raycast", "ao", "wood"], "likes": 0, "viewed": 151, "date": "1478745462", "time_retrieved": "2024-06-20T18:45:35.832713", "image_code": "#define NORM(R) R=normalize(R);\n#define MAP(V) df = map(V);\n#define FPLANE(V) (V.x+V.y)\n#define LOP(X) for (int unsd = 0; unsd < X; ++unsd)\n#define TRACE(R,O) t=trace(R, O); v = ro+rd*t;\n#define FLR FPLANE(vec2(v.y,2.))\nvec2 uvx (vec3 p) {\n\tfloat x = p.x;\n    float y = p.y;\n    float z = p.z;\n    float u = atan(x, z) / (2. * 3.14159265358979) + .5;\n    float v = asin(y) / (3.14159265358979) + .5;\n    return vec2(u,v);\n}\nmat3 rmx(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c        \n                );\n}\n\nfloat map ( vec3 v ) {\n    float stn = length(v-vec3(0,1,0))-(2.+length(atan(v*sin(v))));\n    \n    return stn;\n}\nfloat map2 ( vec3 v ) {\n\treturn min(map(v),FLR);    \n}\nfloat trace( vec3 ro, vec3 rd ) {\n    \n\tfloat t = 0.;\n    LOP (32) {\n        float df;\n        MAP( (ro + t * rd))\n        if ( t > 30. ) break;\n        t += df * .8;\n    }\n    return t;\n}\nvec3 normal( in vec3 x )\n{\n    vec2 e = vec2( .01, 0.0 );\n    return normalize( vec3( map2(x+e.xyy) - map2(x-e.xyy),\n                            map2(x+e.yxy) - map2(x-e.yxy),\n                            map2(x+e.yyx) - map2(x-e.yyx) ) );\n}\n\nvec3 denstex ( vec3 v , vec3 rd ) {\n    vec3 u = v;\n    mat3 rot = rmx(vec3(0,1,0), iTime/2.5);\n    u*=rot;\n    vec3 col = vec3(0);\n    for (int i = 0; i < 5; ++i ) {\n     \n        float trans = texture(iChannel2, uvx(u*vec3(1,.1,1))*float(i)+float(i)*2.31).r;\n        u+=rd*rot/4.1252;\n        col=mix(col, vec3(.4, .8, .5)*trans, trans);\n    }\n    return col;\n}\nvoid render  ( vec2 s, out vec4 c ) {\n\tvec3 col = vec3(1);\n    vec3 ro = vec3 ( 0, 6.-(1.-iMouse.y/iResolution.y)*7., -8. );\n    ro*=rmx(vec3(0,1,0),iTime/6.+iMouse.x/iResolution.x*3.-1.5) ;\n    vec3 rd = vec3 ( s*2.-1., .8);\n    \n    rd.x*=iResolution.x/iResolution.y;\n    NORM(rd);\n    rd*=rmx(vec3(1, 0, 0),3.14/6.);\n    rd*=rmx(vec3(0,1,0),iTime/6.+iMouse.x/iResolution.x*3.-1.5) ;\n    float t = 0.;\n    vec3 v;\n    \n    \n    TRACE( ro, rd );\n    \n    bool ht = map(v)<.5;\n    bool fl;// = map(v)==FLR;\n    vec3 nrm = normal(v);\n    vec3 dor = vec3(1);\n    float ptd = 100.;\n    \n    //Plane intersect\n    vec3 plt;\n    if (rd.y<0.) {\n\n        ptd = ((ro.y+2.)/(-rd.y));\n        plt = ro+rd*ptd;\n     \n      //  col=plt.xzx;\n        dor = texture(iChannel0, plt.xz/10.).rgb;\n    }  \n    if (ht) {\n        col = denstex(v,rd);\n        float ao = pow(abs(map2(v)-map2(v+nrm)), .9);\n        col*=clamp((1.-dot(nrm,v-vec3(0, 5, 0)))/distance(v,vec3(0,5,0)), .5, 1.); \n        col=mix(col, vec3(1), t/30.);\n        col*=min(1.,ao);\n    }\n    if (ptd<t||t>30.) {\n   \t\tcol = dor;\n        float ao = pow(abs(map2(v)-map2(v+nrm)),.9);\n          col*=clamp((1.-dot(normal(plt),plt-vec3(0, 5, 0)))/distance(plt,vec3(0,5,0)), 0., 1.); \n        TRACE(plt, normalize(vec3(0,8,0)-plt));\n        if (t<=30.)\n            col *= t/30.;\n        col=mix(col, vec3(1), min(ptd,50.)/50.);\n        col*=min(1.,ao);\n      \t\n    }\n    \n   \n    col*=pow(1.-length(s-.5), 1./4.);\n    col*=min(iTime,1.);\n    c=col.xyzz;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\trender(uv, fragColor);\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XttXzM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
