{"id": "4dlfDj", "name": "Kaleido_Complex_0", "author": "balkhan", "description": "I thought I released this into the wild a long time ago, turns out I did not;\nShould be a fun golfing exercise, I guess, feel free;", "tags": ["complex"], "likes": 5, "viewed": 136, "date": "1542523622", "time_retrieved": "2024-06-20T19:23:41.299224", "image_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\n// Fabrice reduce to 578c\n\nvec2 cmult(vec2 a, vec2 b) { return mat2(a,-a.y,a.x)  * b; }\n\nvoid\tmainImage( out vec4 O, vec2 U ) {\n    vec2  R = iResolution.xy, dist,\n         uv = ( U - R/2. ) / R.y;\n    vec4  z = vec4(16.*abs(uv),0,0);\n\n    float t = iTime*.25,\n    \t  r = 1.,\n          i;\n    \n    for (i = 0.; i < 12.; ++i)  {\n        r = -r;\n        z.xy = cmult(z.xy, vec2(1));\n        z.xy = abs(z.xy) -10.5+r;\n\t\tz.xy = cmult(z.xy, vec2(sin(t),cos(t)) );\t\n        z.zw = 2. * (z.xy*z.z - z.yx*z.w);\n        if ( i > 0. && min(abs(z.x),abs(z.y)) < .51 ) {\n            O.xy = exp(-abs(z.xy*z.x*z.y)); \n    \t    O.z  = exp(-abs(min(z.x,z.y)));\n            break;\n        }\n     \tO.xy += .2*exp(-abs(-z.xy/i+i/z.xy));\n    \tO.z  += .2*exp(-abs((z.x+z.y)/i-i/(z.x+z.y)));\n        \n        dist.x = dot(z.xy,z.xy);\n\t\tdist.y = dot(z.zw,z.zw);\n        if (max(dist.x,dist.y) > 1e7 )\n            break;\n    }\n}\n\n\n\n/*\n#define I_MAX 12\nfloat\tt;\nvec2 \tcmult(vec2 a, vec2 b);\nvec2\tcadd(vec2 a, vec2 b);\nvec2\tg(vec2 n);\nvec2\tdg(vec2 n);\nvec2\tcdiv(vec2 a, vec2 b);\n\nvoid\tmainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    t = iTime*.25;\n    vec2 R = iResolution.xy,\n          uv  = vec2(fragCoord-R/2.) / R.y;\n    vec4\tz = vec4(0.0, 0.0, 0.0, 0.0);\n    vec2\tof = 2.*vec2( abs(uv.x )/0.125, abs(uv.y )/0.125);\n    vec3\tcol = vec3(0.0);\n    vec2\tdist = vec2(0.0);\n    z.xy = of;\n    int ii = -1;\n    float\tparam_i = .0;\n    float\tr = 1.;\n    for (int i = -1; i < I_MAX; ++i)\n    {\n        r*=-1.;\n        ++ii;\n        z.xy = float(ii)*.1251*0.+cmult(z.xy, vec2(1.,1.)).xy;\n        z.xy = abs(z.xy)-10.5+r;\n\t\tz.xy = cmult(z.xy, vec2(sin(t*1.), cos(t*1.) )-0.*vec2(1., -1.) );\t\n        z.z = 2.0 * (z.x*z.z - z.y*z.w);\n        z.w = 2.0 * (z.y*z.z - z.x*z.w);\n        dist.x = dot(z.xy,z.xy);\n\t\tdist.y = dot(z.zw,z.zw);\n        if ( float(ii) > 0.\n            &&\n            (\n             sqrt(z.x*z.x -float(ii)*.0) < .51\n            ||\n             sqrt(z.y*z.y -float(ii)*.0) < .51\n                )\n           )\n        {\n        col.x = exp(-abs(z.x*z.x*z.y)-0.*abs(cos(float(ii)*.06125+t*8.)) )*1.; // expensive but pretty\n    \tcol.y = exp(-abs(z.y*z.x*z.y)-0.*abs(cos(float(ii)*.06125+t*8.)) )*1.;\n    \tcol.z = exp(-abs(min(z.x,z.y)-0.*abs(cos(float(ii)*.06125+t*8.)) ))*1.;\n            break;\n        }\n\n     \tcol.x += .1*exp(-abs(-z.x/float(ii)+float(ii)/z.x))*2.; // expensive but pretty\n    \tcol.y += .1*exp(-abs(-z.y/float(ii)+float(ii)/z.y))*2.;\n    \tcol.z += .1*exp(-abs((-z.x-z.y)/float(ii)+float(ii)/(z.x+z.y)))*2.;\n        if (dist.x > 10000000.0 || dist.y > 100000000000.0)\n            break;\n    }\n    fragColor = 1.*vec4(col, 1.0);\n}\n\nvec2 \tcmult(vec2 a, vec2 b)\n{\n    return (vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x));\n}\n\nvec2\tcadd(vec2 a, vec2 b)\n{\n\treturn (vec2(a.x + b.x, a.y + b.y));\n}\n\nvec2 g(vec2 n) {\n    return vec2(\n        n.x*n.x*n.x - 3.*n.x*n.y*n.y - 100.,\n        -n.y*n.y*n.y + 3.*n.x*n.x*n.y\n    );\n}\n\nvec2 dg(vec2 n) {\n    return 2. * vec2(\n        n.x*n.x - n.y*n.y,\n        2. * n.x * n.y\n    );\n}\n\nvec2 cdiv(vec2 a, vec2 b) {\n    float d = dot(b, b);\n    if(d == 0.) return a;\n    else return vec2(\n        (a.x*b.x + a.y*b.y),\n        (a.y*b.x - a.x*b.y)) / d;;\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dlfDj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4l3BDr", "name": "TPblob_Peuriere_Romain", "author": "p1707721", "description": "Mod√©lisation d'un pneu en surfaces implicites", "tags": ["blob"], "likes": 2, "viewed": 77, "date": "1541859266", "time_retrieved": "2024-06-20T19:23:43.687158", "image_code": "// Peuriere Romain\n\nconst int Steps = 1000;\nconst float Epsilon = 0.05; // Marching epsilon\nconst float T=0.5;\n\nconst float rA=10.0; // Maximum ray marching or sphere tracing distance from origin\nconst float rB=40.0; // Minimum\n\n// Transforms\nvec3 rotateX(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n\nvec3 rotateZ(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.y, -sa*p.x + ca*p.y, p.z);\n}\n\n\n// Smooth falloff function\n// r : small radius\n// R : Large radius\nfloat falloff( float r, float R )\n{\n  float x = clamp(r/R,0.0,1.0);\n  float y = (1.0-x*x);\n  return y*y*y;\n}\n\n// Primitive functions\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : large radius\nfloat point(vec3 p, vec3 c, float e,float R)\n{\n    return e*falloff(length(p-c),R);\n}\n\n// Segment skeleton\n// p : point\n// c1 : 1st extremity of skeleton\n// c2 : 2nd extremity of skeleton\n// e : energy associated to skeleton\n// R : large radius\nfloat segment(vec3 p, vec3 c1, vec3 c2, float e, float R)\n{\n    vec3 unitVec = normalize(c2-c1);\n    \n    float val;\n    \n    float projectedDistance = dot((p-c1),unitVec);\n    if (projectedDistance<0.0){\n    \tval = length(p-c1); \n    }else if (projectedDistance>length(c1-c2)){\n     \tval = length(p-c2);   \n    }else{\n    \tval = sqrt(length(p-c1) * length(p-c1) - projectedDistance * projectedDistance);   \n    }\n    return e*falloff(val,R);\n}\n\n// Disc skeleton\n// p : point\n// center : center of the disc\n// n : normal to the disc\n// discRadius : disc radius\n// e : energy associated to skeleton\n// R : large radius\nfloat disc(vec3 p, vec3 center, vec3 n, float discRadius, float e, float R)\n{\n    float distanceToCenter = length(center-p);\n    \n    n = normalize(n); // disc normal\n    float verticalDistance = dot((p-center),n);\n    float horizontalDistance = sqrt(distanceToCenter*distanceToCenter - verticalDistance*verticalDistance);\n    \n    float val;\n    if (horizontalDistance<discRadius){\n        val = abs(verticalDistance);\n    }else{\n     \tval = sqrt( (horizontalDistance-discRadius)*(horizontalDistance-discRadius) + verticalDistance*verticalDistance);    \n    }\n    \n    return e*falloff(val,R);\n}\n\n// Torus skeleton\n// p : point\n// center : center of the Torus\n// n : normal to the Torus\n// discRadius : Torus radius\n// e : energy associated to skeleton\n// R : large radius\nfloat torus(vec3 p, vec3 center, vec3 n, float discRadius, float e, float R)\n{\n    float distanceToCenter = length(center-p);\n    \n    n = normalize(n); // disc normal\n    float verticalDistance = dot((p-center),n);\n    float horizontalDistance = sqrt(distanceToCenter*distanceToCenter - verticalDistance*verticalDistance);\n    \n    float val = sqrt( (horizontalDistance-discRadius)*(horizontalDistance-discRadius) + verticalDistance*verticalDistance);    \n    \n    \n    return e*falloff(val,R);\n}\n\n// Cube skeleton\n// p : point\n// pmin : lower point of the cube\n// pmax : upper point of the cube\n// e : energy associated to skeleton\n// R : large radius\nfloat cube(vec3 p, vec3 pmin,vec3 pmax, float e, float R) \n{\n  float dx = max(0.0 , max(pmin.x - p.x, p.x - pmax.x));\n  float dy = max(0.0 , max(pmin.y - p.y, p.y - pmax.y));\n  float dz = max(0.0 , max(pmin.z - p.z, p.z - pmax.z));\n  \n  float val = sqrt(dx*dx + dy*dy + dz*dz);    \n  return e*falloff(val,R);\n}\n\n// Plan skeleton\n// p : point\n// c1 : 1st extremity of the plan diagonal\n// c2 : 2nd extremity of the plan diagonal\n// n : normal to the plan\n// e : energy associated to skeleton\n// R : large radius\nfloat plan(vec3 p, vec3 c1, vec3 c2, vec3 n, float e, float R)\n{\n    //float v = plan(p, vec3(-2,-2,0), vec3(2,2,0), vec3(0,0,1),1.0, 2.0);\n    vec3 c3,c4;\n    \n    vec3 diag = normalize(c2-c1);\n\n    c3 = c1 + 0.5 * (c2-c1) + 0.5 * length(c2-c1) * normalize(cross(diag,n)); // corner right\n    c4 = c1 + 0.5 * (c2-c1) - 0.5 * length(c2-c1) * normalize(cross(diag,n)); // corner left\n    \n    \n    vec3 unitVec1 = normalize(c3-c1);\n    vec3 unitVec2 = normalize(c4-c1);\n    \n    n = normalize(n);\n    \n    float val;\n    \n    float projectedDistance1 = dot((p-c1),unitVec1);\n    float projectedDistance2 = dot((p-c1),unitVec2);\n    \n    if (projectedDistance1<0.0){\n         if (projectedDistance2<0.0){\n    \t\tval = length(p-c1); \n         }else if (projectedDistance2>length(c1-c4)){\n            val = length(p-c4);\n         }else{\n            val = sqrt(length(p-c1) * length(p-c1) - projectedDistance2 * projectedDistance2);\n         }\n    }else if (projectedDistance1>length(c1-c3)){\n         if (projectedDistance2<0.0){\n    \t\tval = length(p-c3); \n         }else if (projectedDistance2>length(c3-c2)){\n            val = length(p-c2);\n         }else{\n            val = sqrt(length(p-c3) * length(p-c3) - projectedDistance2 * projectedDistance2);\n         }\n    }else{\n         if (projectedDistance2<0.0){\n    \t\tval = sqrt(length(p-c1) * length(p-c1) - projectedDistance1 * projectedDistance1);\n         }else if (projectedDistance2>length(c1-c4)){\n            val = sqrt(length(p-c4) * length(p-c4) - projectedDistance1 * projectedDistance1);\n         }else{\n            float projectedDistance3 = dot((p-c1),n);\n            val = abs(projectedDistance3);\n         }\n    \t   \n    }\n    return e*falloff(val,R);\n}\n\n// Triangle skeleton\n// p : point\n// c1 : 1st extremity of the triangle\n// c2 : 2nd extremity of the triangle\n// c3 : 3rd extremity of the triangle\n// n : normal to the plan\n// e : energy associated to skeleton\n// R : large radius\nfloat triangle(vec3 p, vec3 c1, vec3 c2, vec3 c3, float e, float R)\n{\n    vec3 n = normalize(cross((c2-c1),(c3-c1)));\n                       \n    vec3 unitVec1 = normalize(c2-c1);\n    vec3 unitVec2 = normalize(c3-c1);\n    vec3 unitVec3 = normalize(c3-c2);\n\n    float val;\n    \n    float sign1 = (p.x - c2.x) * (c1.y - c2.y) - (c1.x - c2.x) * (p.y - c2.y);\n    float sign2 = (p.x - c3.x) * (c2.y - c3.y) - (c2.x - c3.x) * (p.y - c3.y);\n    float sign3 = (p.x - c1.x) * (c3.y - c1.y) - (c3.x - c1.x) * (p.y - c1.y);\n    \n    \n    if(sign1>=0.0 && sign2>=0.0 && sign3>=0.0){\n        val = abs(dot((p-c1),n));\n    }else{\n        val = 10000.0;\n    }\n    return e*falloff(val,R);\n                       \n}\n                       \n                       \n    \n// Blending\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Blend(float a,float b)\n{\n    return a+b;\n}\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Union(float a,float b)\n{\n    return max(a,b);\n}\n\n// Intersection\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Intersection(float a,float b)\n{\n    return min(a,b);\n}\n\n// Without\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Without(float a,float b)\n{\n    return min(a,2.0*T - b);\n}\n\n// Potential field of the object\n// p : point\nfloat object(vec3 p)\n{\n  \tp.z=-p.z;\n    // Point non tournant pour le plan\n    vec3 pold = p;\n    // Rotation du pneu\n    p = rotateZ(p,iTime*4.0);\n    \n    //PNEU\n    \n    //torus principal\n    float v = torus(p, vec3(0,0,-0.5), vec3(0,0,1), 3.5, 1.0, 2.0);\n    v = Blend(v,torus(p, vec3(0,0,+0.5), vec3(0,0,1), 3.5, 1.0, 2.0));\n    \n    //bandes rainures\n    v = Blend(v,torus(p, vec3(0,0,0), vec3(0,0,1), 4.6, -0.1, 0.1));\n    v = Blend(v,torus(p, vec3(0,0,-0.7), vec3(0,0,1), 4.4, -0.1, 0.1));\n    v = Blend(v,torus(p, vec3(0,0,+0.7), vec3(0,0,1), 4.4, -0.1, 0.1));\n    v = Blend(v,torus(p, vec3(0,0,-0.9), vec3(0,0,1), 4.3, -0.1, 0.1));\n    v = Blend(v,torus(p, vec3(0,0,+0.9), vec3(0,0,1), 4.3, -0.1, 0.1));\n    \n    // cot√©s (aplatissement)\n    v = Blend(v,disc(p, vec3(0,0,+1.5), vec3(0,0,1), 3.5, -1.0, 0.5));\n    v = Blend(v,disc(p, vec3(0,0,-1.5), vec3(0,0,1), 3.5, -1.0, 0.5));\n    \n    // chevrons\n    /*\n  \tfor(float i = 0.0; i < 2.0*3.14;i=i+0.1){\n    \tv = Blend(v,segment(p, rotateZ(vec3(-4.5,1.0,0.0),i), rotateZ(vec3(-4.5,0,-0.7),i), -0.1, 0.05));\n    \tv = Blend(v,segment(p, rotateZ(vec3(-4.5,1.0,0.0),i), rotateZ(vec3(-4.5,0,0.7),i), -0.1, 0.05));\n     \tv = Blend(v,segment(p, rotateZ(vec3(-4.3,0.0,-1.0),i), rotateZ(vec3(-4.0,0,-1.2),i), -0.1, 0.05));\n\t}\n\t*/\n    \n    // JANTE\n    v = Union(v,disc(p, vec3(0,0,-1.2), vec3(0,0,1), 3.3, 1.0, 0.1));\n    \n    // Triangles de la jante\n  \tfor(float i = 0.0; i < 2.0*3.14;i=i+1.04){\n    \tv = Without(v,triangle( p,  rotateZ(vec3(-1,-3,-1.3),i),  rotateZ(vec3(1,-3,-1.3),i),  rotateZ(vec3(0,-0.5,-1.3),i),1.0,0.5));\n\n  \t}\n    // Centre de la jante\n  \tv = Union(v,disc(p, vec3(0,0,-1.1), vec3(0,0,1), 1.0, 1.0, 0.3));\n    \n    \n  \tfor(float i = 0.0; i < 2.0*3.14;i=i+1.04){\n    \t//trou √©crou\n      \tv = Without(v,point(p,  rotateZ(vec3(-0.5,-0.8,-1.3),i), 1.0, 0.3));\n\t\t// segment associ√©\n      \tv= Without(v,segment(p,rotateZ(vec3(-1.5,-2.6,-1.2),i), rotateZ(vec3(-0.7,-1.2,-1.2),i), 1.0 ,0.3));\n \t }\n    \n   \t// Centre enfonc√©\n  \tv = Blend(v,disc(p, vec3(0,0,-1.2), vec3(0,0,1), 0.5, -1.0, 0.2));\n   \n    // plan final\n    v = Union(v,plan(pold,vec3(-4,-4.5,-4),vec3(4,-4.5,4),vec3(0,1,0),1.0,0.2));\n\n  \treturn v-T;\n}\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n  float eps = 0.0001;\n  vec3 n;\n  float v = object(p);\n  n.x = object( vec3(p.x+eps, p.y, p.z) ) - v;\n  n.y = object( vec3(p.x, p.y+eps, p.z) ) - v;\n  n.z = object( vec3(p.x, p.y, p.z+eps) ) - v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat Trace(vec3 o, vec3 u, out bool h,out int s)\n{\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p);\n    // Hit object\n      if (v > 0.0)\n      {\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += Epsilon;\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, out bool h,out int s)\n{\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p);\n    // Hit object\n      if (v > 0.0)\n      {\n      \th = true;\n      \tbreak;\n      }\n      // Move along ray\n      t += max(Epsilon,abs(v)/4.0);\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n\n// Background color\nvec3 background(vec3 rd)\n{\n  return mix(vec3(0.4, 0.3, 0.0), vec3(0.7, 0.8, 1.0), rd.y*0.5+0.5);\n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\nvec3 Shade(vec3 p, vec3 n)\n{\n  // point light\n  const vec3 lightPos = vec3(5.0, 5.0, 5.0);\n  const vec3 lightColor = vec3(0.5, 0.5, 0.5);\n\n  vec3 c = 0.25*background(n);\n  vec3 l = normalize(lightPos - p);\n\n  // Not even Phong shading, use weighted cosine instead for smooth transitions\n  float diff = 0.5*(1.0+dot(n, l));\n\n  c += diff*lightColor;\n\n  return c;\n}\n\n// Shading with number of steps\nvec3 ShadeSteps(int n)\n{\n   float t=float(n)/(float(Steps-1));\n   return vec3(t,0.25+0.75*t,0.5-0.5*t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 pixel = (gl_FragCoord.xy / iResolution.xy)*2.0-1.0;\n\n  // compute ray origin and direction\n  float asp = iResolution.x / iResolution.y;\n  vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -4.0));\n  vec3 ro = vec3(0.0, 0.0, 20.0);\n\n  // vec2 mouse = iMouse.xy / iResolution.xy;\n  float a=iTime*2.0;\n  ro = rotateY(ro,- 0.90);\n  rd = rotateY(rd, -0.90);\n // ro = rotateY(ro, a);\n // rd = rotateY(rd, a);\n\n  // Trace ray\n  bool hit;\n\n  // Number of steps\n  int s;\n\n  float t = SphereTrace(ro, rd, hit,s);\n  vec3 pos=ro+t*rd;\n  // Shade background\n  vec3 rgb = background(rd);\n\n  if (hit)\n  {\n    // Compute normal\n    vec3 n = ObjectNormal(pos);\n\n    // Shade object with light\n    rgb = Shade(pos, n);\n  }\n\n  // Uncomment this line to shade image with false colors representing the number of steps\n  //rgb = ShadeSteps(s);\n\n  fragColor=vec4(rgb, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4l3BDr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lcBDf", "name": "tunnel optimized 2", "author": "ruko", "description": "use a distance field instead of a boolean function\n\ncode is now simpler and achieves a good result in far fewer iterations", "tags": ["tunnel"], "likes": 1, "viewed": 57, "date": "1541223372", "time_retrieved": "2024-06-20T19:23:44.178145", "image_code": "// Set to true to see where the image is likely to be distorted\n#define debug false\n\nfloat tunnel(vec3 p) {\n    float d = sqrt(p.x * p.x + p.y * p.y);\n    return 10.0 - d;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec2 rotate(vec2 p, float th) {\n    return vec2(\n        p.x * cos(th) - p.y * sin(th),\n        p.x * sin(th) + p.y * cos(th)\n    );\n}\n\nfloat disc(vec3 p) { \n    //p.x += cos(iTime) * 10.0;\n    //p.y += sin(iTime) * 10.0;\n    \n    //p.yz = rotate(p.yz, iTime);\n    \n    p.xy = rotate(p.xy, iTime);\n    \n    return sdCappedCylinder(p, vec2(2.0, 0.1));\n}\n\nfloat scene(vec3 p) {\n    //return tunnel(p);\n    float d = tunnel(p);\n    //d = min(d, disc(p + vec3(0.0, 0.0, -40.0)));\n    d = min(d, disc(p + vec3(0.0, 0.0, -20.0)));\n    //d = min(d, disc(p + vec3(0.0, 0.0, -80.0)));\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.yy;\n    \n    fragCoord.x -= iResolution.x / 2.;\n    fragCoord.y -= iResolution.y / 2.;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec3 p = vec3(0.);   \n    p.x += cos(iTime) * 5.0;\n    p.y += sin(iTime*1.1) * 3.0;\n\n    vec3 direction = normalize(vec3(fragCoord, iResolution.x));\n    direction.x += cos(iTime) * .01;\n    direction.y += sin(iTime) * .01;\n    \n    \n    int maxSteps = min(500, int(floor(iTime)) * int(floor(iTime)));\n    float dist = 1.;\n    vec3 ray_t = p + dist * direction;\n    while (maxSteps-- > 0) {\n        float minDist = scene(ray_t);\n        if (abs(minDist) < 0.001) {\n            break;\n        }\n        dist += minDist;\n        ray_t = p + dist * direction;\n    }\n\n    float d = dist;\n    \n    float fogginess = 1./exp(d*.02);\n\n    col = vec3(fogginess*(0.5+0.5*sin(d+iTime*10.0)));\n    \n    if (debug)\n        col.x -= float(maxSteps);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lcBDf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4ldfDj", "name": "Cornericity 2", "author": "pidulgi", "description": "very simple shader", "tags": ["outlands"], "likes": 2, "viewed": 59, "date": "1541093478", "time_retrieved": "2024-06-20T19:23:44.287215", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy*20.0;\n\n    // Time varying pixel color\n    vec3 col =  0.5*tan(iTime+vec3(uv.x * uv.y/100.0, uv.x * uv.y/10.0, uv.x * uv.y)+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col, 1) * uv.x;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ldfDj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lGBD1", "name": "Gear tower", "author": "Flopine", "description": "Shader made in 20 minutes during GROW Shader Showdown in Paris. The colours and the pixellate effect were supposed to represent an old gameboy style, as the music was generated on gameboys by https://twitter.com/cyanidedansen  <3", "tags": ["raymarching", "modeling", "gameboy"], "likes": 16, "viewed": 350, "date": "1542307089", "time_retrieved": "2024-06-20T19:23:44.875097", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui and Coyhot for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Cookie Collective rulz\n\n\n#define time iTime\n#define ITER 64.\n#define PI 3.141592\n#define beat (50./60.)\n\nmat2 rot(float a)\n{ return mat2 (cos(a),sin(a),-sin(a),cos(a));}\n\n\nvec2 moda(vec2 p, float per)\n{\n    float a = atan(p.x,p.y);\n    float l = length(p);\n    a = mod(a-per/2., per) -per/2.;\n    return vec2 (cos(a),sin(a))*l;\n}\n\nfloat cylY(vec3 p, float r, float h)\n{\n    return max(length(p.xz)-r, abs(p.y)-h);\n}\n\nfloat cyl (vec2 p, float r)\n{return length(p)-r;}\n\n\nfloat box (vec3 p, vec3 c)\n{return length(max(abs(p)-c,0.));}\n\nfloat gears(vec3 p, float c_size)\n{\n    float c = max(-cylY(p,0.4, 10.),cylY(p,1.,0.2));\n    p.xz = moda(p.xz, 2.*PI/7.);\n    p.x -= 1.;\n    float b = box(p, vec3(0.2));\n    return min(b,c);\n}\n\nfloat prim1 (vec3 p)\n{\n  \tfloat c= cyl(p.xz, 0.3);\n  \n  \tfloat p_mod = fract(p.y - 0.5);\n  \tfloat p_index = floor(p.y - 0.5);\n  \n\tfloat t0 = floor(time*beat);\n    float t1 = fract(time*beat);\n    t1 = pow(t1, 6.);\n    float anim = (PI/2.)*(t0+t1);\n    \n    p.y = p_mod - 0.5;\n    if (mod(p_index, 2.)==0.) p.xz *= rot(anim);\n    else p.xz *= rot(-anim);\n    float g = gears(p, 0.);\n    return min(c,g);\n}\n\n\nfloat SDF(vec3 p)\n{\n    vec3 pp = p;\n    float per = 5.;\n    p.xz = mod(p.xz - per/2., per) - per/2.;\n    float pr1 = prim1(p);\n\n    p = pp;\n    float per2 = 10.;\n    p.xy = mod(p.xy, per) - per/2.;\n    p.yz *= rot(PI/2.);\n    float pr2 = prim1(p);\n\n    return min(pr1,pr2);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.*(fragCoord/iResolution.xy) -1.;\n    uv.x *= iResolution.x/iResolution.y;\n\n    \n  \tfloat detail = 80.;\n  \tuv = floor(uv*detail) / detail;\n\n  \tvec3 ro = vec3(-1.,0.001 + time,-2.); vec3 p = ro;\n\tvec3 rd = normalize(vec3(uv,1.));\n\n    float shad = 0.;\n        for (float i = 0.; i<ITER; i++)\n        {\n            float d = SDF(p);\n            if (d<0.001)\n            {\n              shad = i/ITER;\n            \tbreak;\n            }\n       \t\tp+=d*rd;\n        }\n\n    float t = length(ro-p);\n\n\n\tvec3 col = vec3(shad) * 0.3;\n\tcol = mix(col, vec3(131.0,145.0,0.)/255.0, 1.-exp(-0.002*t*t));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lGBD1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lGBDR", "name": "Test Cylinder Intersector", "author": "iq", "description": "Testing [url]https://www.shadertoy.com/view/4lcSRn[/url] As it turns, it fails miserably when the the cones start degenerating to cylinders...", "tags": ["3d", "raytracing", "cylinder"], "likes": 9, "viewed": 586, "date": "1542180391", "time_retrieved": "2024-06-20T19:23:44.881179", "image_code": "// Created by inigo quilez - iq/2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Testing https://www.shadertoy.com/view/4lcSRn.\n\nvec4 iSphere( in vec3 ro, in vec3 rd, in vec3 ce, in float ra )\n{\n\tvec3 oc = ro - ce;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - ra*ra;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec4(-1.0);\n    float t = -b - sqrt( h );\n\treturn vec4( t, (oc + t*rd)/ra );\n}\n\nvec4 iCylinder( in vec3 ro, in vec3 rd, \n                in vec3 pa, in vec3 pb, float ra, \n                out float v ) // extreme a, extreme b, radius\n{\n\tv = 0.0;\n    vec3 ba = pb-pa;\n\n    vec3  oc = ro - pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoc = dot(ba,oc);\n    \n    float a = baba - bard*bard;\n    float b = baba*dot( oc, rd) - baoc*bard;\n    float c = baba*dot( oc, oc) - baoc*baoc - ra*ra*baba;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec4(-1.0);\n    h = sqrt(h);\n    float t = (-b-h)/a;\n\n    // body\n    float y = baoc + t*bard;\n    if( y>0.0 && y<baba )\n    {\n        v = y/baba;\n        return vec4( t, (oc+t*rd - ba*v)/ra );\n    }\n    \n    return vec4(-1.0);\n}\n\n\n#define AA 2\n\nvec3 path( in float h )\n{\n    return 0.5*sin(6.2831*h*vec3(3.0,2.0,5.0)+vec3(0.0,1.0,3.0)+0.5*iTime*vec3(1.1,1.3,1.7));\n}\n\nvec4 intersect( in vec3 ro, in vec3 rd, out float h )\n{\n    vec3  oce = path(0.0);\n    vec4 tnor = vec4(1e20);\n    const int num = 80; // make this bigger for more precision curve\n    float hm = 0.0;\n    for( int i=1; i<=num; i++ )\n    {\n        float h = float(i)/float(num);\n        vec3 ce = path(h);\n        float ra = 0.04;\n\n        vec4 tmp; float tmpv;\n\n        // links\n        tmp = iCylinder( ro, rd, oce, ce, ra, tmpv );\n        if( tmp.x>0.0 && tmp.x<tnor.x ) { tnor = tmp; hm=h+tmpv/float(num); }\n\n        // points\n        tmp = iSphere( ro, rd, oce, ra );\n        if( tmp.x>0.0 && tmp.x<tnor.x ) { tnor = tmp; hm=h; }\n\n\n        oce = ce;\n    }\n    \n    // enable to render floor\n    //float t = (-0.6-ro.y)/rd.y; if( t>0.0 && t<tnor.x ) { hm=0.4; tnor=vec4(t,0.0,1.0,0.0); }\n\n    h = hm;\n    return tnor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.01*iTime;\n\tvec3 ro = vec3( 1.0*sin(an), 0.4, 1.0*cos(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n\n        // raytrace\n        float hm;\n        vec4 tnor = intersect( ro, rd, hm );\n        float t = tnor.x;\n    \n        // shading/lighting\t\n        vec3 col = vec3(0.015)*(1.0-0.15*dot(p,p));\n        if( t<1e19 )\n        {\n            vec3 mate = 0.5 + 0.5*cos(2.0*hm*6.2831+vec3(0.0,2.0,3.0));\n\n            vec3 pos = ro + t*rd;\n            vec3 nor = tnor.yzw;\n            const vec3 lig = vec3(0.8,0.6,0.0);\n            vec3 hal = normalize(lig-rd);\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n            float spe = clamp(dot(nor,hal),0.0,1.0);\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            float kk; float sha = (intersect( pos+nor*0.001, lig, kk ).x<1e19) ? 0.0 : 1.0;\n            float fre = clamp(1.0+dot(rd,nor),0.0,1.0);\n            \n            col = vec3(0.05,0.1,0.15)*amb + vec3(1.0,0.8,0.5)*dif*sha;\n            col *= mate;\n            col += 0.5*pow(spe,32.0)*dif*sha;\n            col += fre*fre*0.2*mate*(0.5+0.5*dif*sha);\n        }\n\t\n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lGBDR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lGfDD", "name": "Concentric Rainbow Circles, club", "author": "alvarobyrne", "description": "clubberized, https://codepen.io/alvarobyrne/pen/rQzoOz. The point here is to show online use of iMusic uniform, so useless within shadertoy and usable in codepen. https://github.com/wizgrav/clubber", "tags": ["circles", "color", "rainbow", "clubber"], "likes": 5, "viewed": 784, "date": "1542496950", "time_retrieved": "2024-06-20T19:23:44.881179", "image_code": "// Fork of \"Concentric Rainbow Circles\" by jangxx. https://shadertoy.com/view/XtKBDz\n// 2018-11-17 23:16:55\n#ifndef CLUBBER\nvec4 iMusic[4];\nconst float iTransition = 1.0;\n#endif\n#define PI 3.14159265359\n\nfloat gradientFn(in float x, in float low, in float high, in float target) {\n    float b = ((low * target) - high) / (low - high);\n    float m = (1.0 - b) / low;\n    return m*x + b;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/(iResolution.xy-iMusic[0].x);\n   \n    float aspect = iResolution.x / iResolution.y;\n    \n//    vec2 pos = (uv * 2.0) - vec2(1, 1);\n    vec2 pos = (uv * 2.0) - vec2(0.5+iMusic[0].y, 0.5+iMusic[0].z);\n    pos.x *= aspect+iMusic[1].z;\n    \n    float radius = length(pos)+iMusic[1].y;\n\n    float x = radius*1.0 - iTime/(4.0+iMusic[0].y);\n    float ringColor = mod(x, 1.0) * 10.0;\n\n    vec3 finalColor;\n    if (ringColor < 1.0) {\n        finalColor = vec3(230,0,63)*(1.-iMusic[3].w)  / 255.0;\n    } else if (ringColor < 2.0) {\n        finalColor = vec3(255,0,0)*iMusic[3].z  / 255.0;\n    } else if (ringColor < 3.0) {\n        finalColor = vec3(255,81,0)*iMusic[3].y  / 255.0;\n    } else if (ringColor < 4.0) {\n        finalColor = vec3(255,138,0)*iMusic[3].x / 255.0;\n    } else if (ringColor < 5.0) {\n        finalColor = vec3(255,189,0)*iMusic[1].x / 255.0;\n    } else if (ringColor < 6.0) {\n        finalColor = vec3(241,236,0)*iMusic[0].x / 255.0;\n    } else if (ringColor < 7.0) {\n        finalColor = vec3(0,245,138)*iMusic[2].x / 255.0;\n    } else if (ringColor < 8.0) {\n        finalColor = vec3(0,206,190)*iMusic[2].y / 255.0;\n    } else if (ringColor < 9.0) {\n        finalColor = vec3(0,118,252)*iMusic[2].z / 255.0;\n    } else if (ringColor < 10.0) {\n        finalColor = vec3(140,24,195)*iMusic[2].w / 255.0;\n    }\n\n    float gradient = mod(ringColor, 1.0+0.5*iMusic[1].w);\n    if (gradient > 0.6) {\n        finalColor *= gradientFn(gradient, 0.6, 1.0, 0.3);\n    }\n\n    fragColor = vec4(finalColor, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lGfDD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lGfWh", "name": "Simplex noise fire", "author": "Imic", "description": "the fire based of simplex noise.", "tags": ["2dnoise"], "likes": 2, "viewed": 262, "date": "1542290354", "time_retrieved": "2024-06-20T19:23:44.881179", "image_code": "vec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise(vec2 p)\n{\n    const float K1=0.366025404;//(sqrt(3)-1)/2)\n    const float K2=0.211324865;//(3-sqrt(3))/6;\n    \n    vec2 i=floor(p+(p.x+p.y)*K1);\n    \n    vec2 a=p-(i-(i.x+i.y)*K2);\n    vec2 o=(a.x<a.y)?vec2(0.0,1.0):vec2(1.0,0.0);\n    vec2 b=a-o+K2;\n    vec2 c=a-1.0+2.0*K2;\n    \n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\t\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\t\n\treturn dot( n, vec3(70.0) );\n    \n}\n\nfloat fbm(vec2 uv)\n{\n    float f=0.0;\n    uv=uv*2.0;\n\tf  = 0.5000*noise( uv ); uv = 2.0*uv;\n\tf += 0.2500*noise( uv ); uv = 2.0*uv;\n\tf += 0.1250*noise( uv ); uv = 2.0*uv;\n\tf += 0.0625*noise( uv ); uv = 2.0*uv;\n\tf = f+0.5;\n\treturn f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates (from 0 to 1)\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 q = uv;\n    q.x*=5.;\n\tfloat strength =1.5;\n\tfloat T = 1.5*iTime;\n\tq.x-=2.5;//Ox=2.5\n\tq.y-=0.25;//Oy=0.25\n    \n    //the first layer of noise\n\tfloat n = fbm(strength*q - vec2(0,T));\n\n    //the second layer of noise\n    float c=1.-16.*(pow(length(q)-n*q.y,2.));\n    \n    //using the noise to generate pixel color;\n    float c1=n*c*(1.-pow(uv.y,4.));\n\tc1=clamp(c1,0.,1.);\n\n    //color\n\tvec3 col = vec3(1.5*c1, 1.5*c1*c1*c1, c1*c1*c1*c1*c1*c1);\n    \n    //the mix paramterÔºåc1/n\n\tfloat c2 = c * (1.-pow(uv.y,4.));\n    \n    //liner mix to complement the pixel,which should be black.\n\tfragColor = vec4( mix(vec3(0.),col,c2), 1.0);\n    //fragColor = vec4(col,1.0);\n    //fragColor=vec4(1.0*c,1.0*c,1.0*c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lGfWh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lGfWW", "name": "Cube & Plane", "author": "paulo69", "description": "  ", "tags": ["procedural", "3d", "visualization", "mathematics", "geometry", "points", "vectors", "learn", "crossproduct", "orthographicprojection"], "likes": 2, "viewed": 129, "date": "1542500562", "time_retrieved": "2024-06-20T19:23:44.881179", "image_code": "void mainImage(out vec4 P, in vec2 C) {\n    vec3 V = vec3(C/iResolution.x-vec2(.5,.25),1.)*mat3(1.,     0.,      0.,\n             \t\t\t\t\t\t\t\t\t\t\t0.,cos(.3),-sin(.4),\n             \t\t\t\t\t\t\t\t\t\t\t0.,sin(.4),cos(.4));\n    \n    vec3[] d = vec3[] (\n    \tvec3(-.08,-.08,-.08),vec3(.08,-.08,-.08),vec3(.08,-.08,.08),vec3(-.08,-.08,.08),\n        vec3(.08,.08,.08),vec3(-.08,.08,.08),vec3(-.08,.08,-.08),vec3(.08,.08,-.08),\n        vec3(-.22,-.12,-.22),vec3(.22,-.12,-.22),vec3(-.22,-.12,.22),vec3(.22,-.12,.22)); \n    \n    for (int i = 0; i<12;i++) {\n    \td[i]=d[i]*mat3(cos(iTime),0.,sin(iTime),0.,1.,0.,-sin(iTime),0.,cos(iTime));\n        P += vec4((1.-smoothstep(.003,.006,length(cross(d[i]-vec3(.0,.3,-1.),V))/length(V))));\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lGfWW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lKBWm", "name": "GearDescrates", "author": "zhimo", "description": "Gear On Descrates", "tags": ["2d", "circle", "gear", "descrates"], "likes": 1, "viewed": 336, "date": "1542791479", "time_retrieved": "2024-06-20T19:23:46.590528", "image_code": "// Author: 185202204@qq.com\n\n//base on:https://www.shadertoy.com/view/XtKBDD\n//coding by unity shader,github:\n//https://github.com/zhimo1997/ShaderToy\n//more details on my blog :\n//https://blog.csdn.net/qq_36383623/article/details/84237042\n\n\n\n//if uv is in Circle or not\nfloat IsInCircle(vec2 uv,vec2 center,float radius) {\n\tfloat r = distance(uv,center);\n\tif (r < radius) {\n\t\treturn r / radius;\n\t}\n\treturn -1.0;\n}\n\nfloat CaculateAngle(vec2 v1, vec2 v2) {\n\tfloat magnitude1 = sqrt(v1.x*v1.x + v1.y*v1.y);\n\tfloat magnitude2 = sqrt(v2.x*v2.x + v2.y*v2.y);\n\tfloat cosValue = dot(v1, v2) / (magnitude1*magnitude2);\n\tfloat finalAngle = acos(cosValue);\n\tfinalAngle = degrees(finalAngle);\n\n\tvec3 dir = cross(vec3(v1, 0), vec3(v2, 0));\n\tif (dir.z >= 0.0) {\n\t\treturn finalAngle;\n\t}\n\telse{\n\t\treturn 360.0 - finalAngle;\n\t}\n}\n\n//ËÆ°ÁÆóÁÇπÂà∞Áõ¥Á∫øÁöÑË∑ùÁ¶ªÔºåoffsetÁî®‰∫éÂπ≥Ë°åÁ∫ø\nfloat CaculatePointToAxis(vec2 uv, vec2 center, float slope, float offset) {\n\tfloat val = abs(slope*(uv.x - center.x) + offset - (uv.y - center.y)) / sqrt(1.0 + slope * slope);\n\treturn val;\n}\n\nfloat IsInRect(vec2 uv, vec2 center, float angle, float width, float height) {\n\n\t\tif (angle == 90.0 || angle == 270.0) {\n\t\t\tfloat val1 = abs(uv.x + width * 0.5 - center.x);\n\t\t\tfloat val2 = abs(uv.x - width * 0.5 - center.x);\n\t\t\tfloat val3 = abs(uv.y + height * 0.5 - center.x);\n\t\t\tfloat val4 = abs(uv.y - height * 0.5 - center.x);\n\n\t\t\tif (val1 + val2 <= width + 0.001 && val3 + val4 <= height + 0.001) {\n\t\t\t\treturn 1.0;\n\t\t\t}\n\t\t\treturn 0.0;\n\t\t}\n\t\tif (angle == 0.0 || angle == 180.0) {\n\t\t\tfloat val1 = abs(uv.x + height * 0.5 - center.x);\n\t\t\tfloat val2 = abs(uv.x - height * 0.5 - center.x);\n\t\t\tfloat val3 = abs(uv.y + width * 0.5 - center.x);\n\t\t\tfloat val4 = abs(uv.y - width * 0.5 - center.x);\n\n\t\t\tif (val1 + val2 <= height + 0.001 && val3 + val4 <= width + 0.001) {\n\t\t\t\treturn 1.0;\n\t\t\t}\n\t\t\treturn 0.0;\n\t\t}\n\t\tangle = radians(angle);\n\t\tfloat slope = tan(angle);\n\t\tfloat offset1 = width * 0.5 * sqrt(1.0 + slope * slope);\n\t\tfloat val1 = CaculatePointToAxis(uv, center, slope, offset1);\n\t\tfloat val2 = CaculatePointToAxis(uv, center, slope, -offset1);\n\n\t\tslope = -1.0 / slope;\n\t\tfloat offset2 = height * 0.5 * sqrt(1.0 + slope * slope);\n\t\tfloat val3 = CaculatePointToAxis(uv, center, slope, offset2);\n\t\tfloat val4 = CaculatePointToAxis(uv, center, slope, -offset2);\n\n\t\tif (val1 + val2 <= width + 0.001 && val3 + val4 <= height + 0.001) {\n\t\t\treturn 1.0;\n\t\t}\n\t\treturn 0.0;\n\t}\n\nfloat CalculateRadius(float r1,float r2,float r4) {\n\tfloat k1 = 1.0/ r1;\n\tfloat k2 = 1.0/ r2;\n\tfloat k4 = 1.0/ r4;\n\n\tfloat t1 = k1 + k2 - k4;\n\tfloat t2 = k1 * k1 + k2 * k2 + k4 * k4;\n\t\t\n\tfloat a = 1.0;\n\tfloat b = -2.0*t1;\n\tfloat c = 2.0 * t2 - t1 * t1;\n\tfloat delta = b * b - 4.0 * a*c;\n\tif (delta < 0.0) {\n\t\treturn -1.0;\n\t}\n\tfloat d1 =( -b + sqrt(delta))/(2.0*a);\n\t//float d2 =Ôºà -b - sqrt(delta)Ôºâ/(2.0*a);\n\treturn 1.0/d1;\n}\n\nvec4 CaculateFourthCircleCenter(vec2 center1,vec2 center2,float r1,float r2) {\n\tfloat m = -(center2.x-center1.x)/(center2.y-center1.y);\n\tfloat n = 0.5*((r2*r2-r1*r1)/(center1.y-center2.y)+center2.y+center1.y+(center1.x*center1.x-center2.x*center2.x)/(center1.y-center2.y));\n\tfloat a = 1.0 + m * m;\n\tfloat b = 2.0 * m*(n - center1.y) - 2.0*center1.x;\n\tfloat c = center1.x*center1.x + (n-center1.y)*(n-center1.y) - r1 * r1;\n\tfloat x1 = (-b + sqrt(b*b-4.0*a*c))/(2.0*a);\n\tfloat y1 = m * x1 + n;\n\tfloat x2 = (-b - sqrt(b*b - 4.0 * a*c)) / (2.0 * a);\n\tfloat y2 = m * x2 + n;\n\n\tvec3 v0 = vec3(center1.x-center2.x,center1.y-center2.y,0.0);\n\tvec3 v1 = vec3(center1.x-x1,center1.y-y1,0.0);\n\tvec3 t = cross(v0, v1);\n\tif ( t.z>= 0.0) {\n\t\treturn vec4(x1,y1,x2,y2);\n\t}\n\treturn vec4(x2,y2,x1,y1);\n\t\t\n}\n\nvec4 DrawCircle(vec2 uv,vec2 center,float radius,vec4 centerColor,vec4 contourCol) {\n    float aspect = distance(uv,center)/radius;\n    float alpha = aspect;\n\tfloat angle = CaculateAngle(vec2(1,0),uv-center);\n    float ColorRotateSpeed=10.0;\n\tangle = mod(angle+ColorRotateSpeed*iTime,360.0);\n\tfloat index =floor(angle/20.0);\n\t//alpha = index * alpha;\n\talpha *= abs(0.5-index / 18.0);\n\treturn mix(centerColor,contourCol,alpha);\n}\n\n//return the background color\nvec4 DrawBg(vec2 uv){\n    \n    float aspect1=iResolution.x/iResolution.y;\n    vec2 center=vec2(0.5*aspect1,0.5);\n   \n    float angle = CaculateAngle(vec2(1,0),uv-center);\n    float ColorRotateSpeed=-80.0;\n\tangle = mod(angle+ColorRotateSpeed*iTime,360.0);\n\tfloat index =floor(angle/15.0);\n\t//alpha = index * alpha;\n\t//float alpha *= abs(0.5-index / 18.0);\n\t\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)*index);\n    return vec4(col,1);\n}\n\nfloat IsInGear(vec2 uv, vec2 center, float radius, vec4 centerColor, vec4 contourColor, float toothWidth, float toothDepth, float rearSpeed) {\n\tfloat aspect1=iResolution.x/iResolution.y;\n    float centerOffsetScale =0.07;\n\tcenter = center + centerOffsetScale * (vec2(0.5*aspect1,0.5)-center);\n\tfloat offsetDepth = 0.05;\n    offsetDepth=offsetDepth*radius;\n\tradius -= offsetDepth;\n\tif (IsInCircle(uv, center, radius) < 0.0) {\n\t\t//return DrawBg();\n\t\treturn 0.0;\n\t}\n\tfloat rectWidth = toothWidth * radius;\n\tfloat rectHeight = (radius) * 2.0;\n\tradius = radius - toothDepth * radius;\n\t\t\n    float aspect = IsInCircle(uv, center, radius);\n\n\tif (aspect >= 0.0) {\n\t\t//return DrawCircle(uv, center, aspect, centerColor, contourColor);\n\t\treturn 1.0;\n\t}\n\t\t\n\trearSpeed *= (1.0 / radius);\n\t//float angle = _RotateSpeed * _Time.y;\n\tfor (int j = 0; j < 12; j++) {\n\t\tfloat angle = float(j) * 15.0;\n\t\t\t\n\t\tangle += rearSpeed;\n\t\tif (IsInRect(uv, center, angle, rectWidth, rectHeight) > 0.5) {\n\t\t\treturn 1.0;\n\t\t}\n\t}\n\n\t\treturn 0.0;\n\t}\n\n\tfloat IsInGearContour(vec2 uv, vec2 center, float radius, vec4 centerColor, vec4 contourColor, float toothWidth, float toothDepth, float contourDepth, float rearSpeed) {\n\t\tfloat rectHeight = (radius - contourDepth) * 2.0;\n\t\tfloat rectWidth = toothWidth * radius;\n\t\tif (IsInCircle(uv, center, radius) < 0.0) {\n\t\t\t//return DrawBg();\n\t\t\treturn 0.0;\n\t\t}\n\t\tradius = (radius - (toothDepth + contourDepth) * radius);\n\t\tfloat aspect = IsInCircle(uv, center, radius);\n\t\tif (aspect >= 0.0) {\n\t\t\t//return DrawCircle(uv, center, aspect, centerColor, contourColor);\n\t\t\treturn 0.0;\n\t\t}\n\n\n\n\t\t//float angle = _RotateSpeed * _Time.y;\n\t\trearSpeed *= (1.0 / radius);\n\t\tfor (int j = 0; j < 18; j++) {\n\t\t\tfloat angle = float(j) * 10.0;\n\n\t\t\tangle += rearSpeed;\n\t\t\tif (IsInRect(uv, center, angle, rectWidth, rectHeight) > 0.5) {\n\t\t\t\treturn 0.0;\n\t\t\t}\n\t\t}\n\n\t\treturn 1.0;\n\t}\n\n//draw the shape of Descrates\nvec4 DrawDescrates(vec2 uv){\n    float aspect=iResolution.x/iResolution.y;\n    \n    float rearSpeed =15.0;\n    rearSpeed*= iTime;\n    float ToothWidth=0.1;\n    float ToothDepth=0.05;\n    \n    float ContourDepth=0.02;\n    float ContourToothWidth=0.07;\n    float ContourToothDepth=0.06;\n    \n    float RotateSpeed=0.001;\n    float angle = RotateSpeed * iTime;\n    float ScaleChangeSpeed=0.0;\n\tfloat scale = 0.1*(sin(ScaleChangeSpeed*iTime));\n    float CenterX=0.5;\n    float CenterY=0.5;\n\tvec2 center = vec2(CenterX,CenterY);\n    center.x*=aspect;\n\tfloat radius = 0.5;\n\tfloat R[5];\n\tvec2 CircleCenter[5];\n\t//ËÆ°ÁÆóÂêÑ‰∏™ÂúÜÁöÑÂçäÂæÑÂèäÂúÜÂøÉ\n\tint Amount = 5;\n\tR[0] = radius;\n\tCircleCenter[0] = vec2(CenterX, CenterY);\n    CircleCenter[0].x*=aspect;\n\n    float radius2=0.35;\n\tR[1] = radius2+scale;\n\t//CircleCenter[1].x = CircleCenter[0].x - (R[0] - R[1]);\n\t//CircleCenter[1].y = CircleCenter[0].y;\n\tCircleCenter[1].x = CircleCenter[0].x - (R[0] - R[1])*cos(angle);\n\tCircleCenter[1].y = CircleCenter[0].y + (R[0] - R[1])*sin(angle);\n\t\t\n\tR[2] = R[0] - R[1]-0.0001;\n\tfloat l = (R[0]-R[1]) / (R[1]+R[2]);\n\tCircleCenter[2] = CircleCenter[1]-(1.0/l)*(CircleCenter[1]-CircleCenter[0]);\n\n\tvec4 CenterColor = vec4(0.7,0.9,0.9,1.0);\n\tvec4 ContourColor = vec4(0.8,0,0.4,1.0);\n\n\tvec4 centerColor;\n    vec4 contourColor;\n    \n   \n    \n    \n\t//Á¨¨‰∏Ä‰∏™ÂÜÖÂúÜ\n\t//float flag = IsInCircle(uv, CircleCenter[1], R[1]);\n\tif (IsInGear(uv, CircleCenter[1], R[1], centerColor, contourColor, ToothWidth, ToothDepth,  -rearSpeed) >= 0.5) {\n\t\tcenterColor = mix(CenterColor, ContourColor, 0.7);\n\t\tcontourColor = mix(ContourColor, CenterColor, 0.7);\n\t\treturn DrawCircle(uv, CircleCenter[1],R[1], centerColor, contourColor);\n\t}\n    \n\t//Á¨¨‰∫å‰∏™ÂÜÖÂúÜ\n\t//flag = IsInCircle(uv, CircleCenter[2], R[2]);\n\tif (IsInGear(uv, CircleCenter[2], R[2], centerColor, contourColor, ToothWidth, ToothDepth,  -rearSpeed) >= 0.5) {\n\t\tcenterColor = mix(CenterColor, ContourColor, 0.3);\n\t\tcontourColor = mix(ContourColor, CenterColor, 0.3);\n\t\treturn DrawCircle(uv, CircleCenter[2],R[2], centerColor, contourColor);\n\t}\n\t\n\t//Á¨¨‰∏â‰∏™ÂÜÖÂúÜ\n\tfloat r = CalculateRadius(R[1], R[2], R[0]);\n\n\tif (r < 0.0) {\n\t\treturn vec4(0, 0, 0, 1);\n\t}\n\n\tvec4 center4 = CaculateFourthCircleCenter(CircleCenter[1], CircleCenter[2], R[1] + r, R[2] + r);\n\t//center4.x*=aspect;\n    //center4.z*=aspect;\n    //float2 center4 = CaculateFourthCircleCenter(CircleCenter[0],float2(0.35,0.5), float2(0.85, 0.5), R[0], R[1] + r, R[2] + r);\n\t//flag = IsInCircle(uv, center4.xy, r);\n\tif (IsInGear(uv, center4.xy, r, centerColor, contourColor, ToothWidth, ToothDepth, -rearSpeed) >= 0.5) {\n\t\t//return fixed4(0,0,0,1);\n\t\tcenterColor = mix(CenterColor, ContourColor, 0.4);\n\t\tcontourColor = mix(ContourColor, CenterColor, 0.4);\n\t\treturn DrawCircle(uv, center4.xy,r, centerColor, contourColor);\n\t}\n    //return vec4(1,0,0.5,1);\n\t\t//flag = IsInCircle(uv, center4.zw, r);\n\t\tif (IsInGear(uv, center4.zw, r, centerColor, contourColor, ToothWidth, ToothDepth, -rearSpeed) >= 0.5) {\n\t\t\t//return fixed4(0,0,0,1);\n\t\t\tcenterColor = mix(CenterColor, ContourColor, 0.4);\n\t\t\tcontourColor = mix(ContourColor, CenterColor, 0.4);\n\t\t\treturn DrawCircle(uv, center4.zw,r, centerColor, contourColor);\n\t\t}\n\n\t\tCircleCenter[3] = center4.xy;\n\t\tR[3] = r;\n\n\t\tCircleCenter[4] = center4.zw;\n\t\tR[4] = r;\n\n\t\tint amount = 6;\n\t\tfor (int j = 0; j < amount; j++) {\n\t\t\tr = CalculateRadius(R[1],R[3],R[0]);\n\t\t\tcenter4 = CaculateFourthCircleCenter(CircleCenter[1], CircleCenter[3], R[1] + r, R[3] + r);\n\t\t\t//flag = IsInCircle(uv, center4.xy, r);\n\t\t\tif (IsInGear(uv, center4.xy, r, centerColor, contourColor, ToothWidth, ToothDepth, -rearSpeed) >= 0.5) {\n\t\t\t\t//return fixed4(1,1,1,1);\n\t\t\t\tcenterColor = mix(CenterColor, ContourColor, 0.5+float(j)*0.1);\n\t\t\t\tcontourColor = mix(ContourColor, CenterColor, 0.5+float(j)*0.1);\n\t\t\t\treturn DrawCircle(uv, center4.xy,r, centerColor, contourColor);\n\t\t\t}\n\t\t\tCircleCenter[3] = center4.xy;\n\t\t\tR[3] = r;\n\t\t}\n\n\t\tfor (int j = 0; j < amount; j++) {\n\t\t\tr = CalculateRadius(R[1], R[4], R[0]);\n\t\t\tcenter4 = CaculateFourthCircleCenter(CircleCenter[1], CircleCenter[4], R[1] + r, R[4] + r);\n\t\t\t//flag = IsInCircle(uv, center4.zw, r);\n\t\t\tif (IsInGear(uv, center4.zw, r, centerColor, contourColor, ToothWidth, ToothDepth, -rearSpeed) >= 0.5) {\n\t\t\t\t//return fixed4(0,0,0,1);\n\t\t\t\tcenterColor = mix(CenterColor, ContourColor, 0.5 + float(j) * 0.1);\n\t\t\t\tcontourColor = mix(ContourColor, CenterColor, 0.5 + float(j) * 0.1);\n\t\t\t\treturn DrawCircle(uv, center4.zw,r, centerColor, contourColor);\n\t\t\t}\n\t\t\tCircleCenter[4] = center4.zw;\n\t\t\tR[4] = r;\n\t\t}\n\t\t\n\t\t//contourColor=vec4(0.7,0.9,0.9,1);\n\t\t//flag = IsInCircle(uv, CircleCenter[0], R[0]);\n\t\tif (IsInGearContour(uv, CircleCenter[0], R[0], centerColor, contourColor, ContourToothWidth, ContourToothDepth,ContourDepth, -rearSpeed) >= 0.5) {\n\t\t\tcenterColor = mix(CenterColor, ContourColor, 0.0);\n\t\t\tcontourColor = mix(ContourColor, CenterColor, 0.0);\n\t\t\treturn DrawCircle(uv, CircleCenter[0],R[0], centerColor, contourColor);\n\t\t}\n\n\t\treturn DrawBg(uv);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect=iResolution.x/iResolution.y;\n    uv.x=uv.x*aspect;\n\n   fragColor=DrawDescrates(uv);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lKBWm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lKBzK", "name": "Polar waves", "author": "Polytope", "description": "Just playing around with polar coord. and colors", "tags": ["2d", "colors", "noob", "polarcoordinates"], "likes": 5, "viewed": 93, "date": "1543182077", "time_retrieved": "2024-06-20T19:23:46.590528", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy*2.-1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float r = length(vec2(.0)-uv);\n    float a = atan(uv.x,uv.y);\n    \n    a += smoothstep(r*.1,r+.9,sin((r-a)*6.+iTime))*sin((r+a)*3.+iTime);\n\n    vec3 col = vec3(0.0);\n\n    col.r += smoothstep(.1,.9,abs(sin(a+iTime)));\n    col.g += smoothstep(r,r+.1,abs(sin((a+r)*3.+iTime)));\n    col.b += smoothstep(.1,r-.1,sin((a+r)*12.+iTime))+smoothstep(.1,r-.1,sin((a-r)*12.+iTime));\n\tcol.rgb += sin((a-r)*12.-iTime-mix(col.r, col.g, (sin(r*10.-iTime))));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lKBzK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lKBzV", "name": "CSG - Etape 10", "author": "dacruzquen", "description": "csg", "tags": ["csg"], "likes": 2, "viewed": 107, "date": "1543247981", "time_retrieved": "2024-06-20T19:23:49.584711", "image_code": "//link : \n\n//Material\nstruct Material\n{\n    float Ka;\n    float Kd;\n    float Ks;\n    float Kn;\n};\n    \nstruct ShadeInfo\n{\n    vec3 shadedCol;\n    float Ks;\n};\n    \nstruct LightInfo\n{\n    vec3 pos;\n    vec3 col;\n    float power;\n};\n    \nconst int MAX_NB_BOUNCES = 5;\n\n//camera parameters\nvec3 cameraPos = vec3(6,4,-5);\nconst vec3 cameraTarget = vec3(3,1,-8);\nconst float cameraFovY = 80.0; // Note: angle is degree\n\n//Sphere parameters\nvec3 spherePos = cameraTarget + vec3(0,1,2);\nconst float sphereRadius = 1.0;\nconst vec3 sphereCol = vec3(1,0,0);\nconst Material sphereMat = Material(0.2,0.7,1.0,50.0);\nconst int sphereId = 1;\n\n//Light parameters\nconst vec3 ambiantCol = vec3(0,0,1);\n\nconst vec3 light1Col = vec3(1,1,1);\nvec3 light1Pos = vec3(8,10,-12);\nconst float light1Pow = 0.8;\n\nconst vec3 light2Col = vec3(1,1,0.5);\nvec3 light2Pos = vec3(3,10,1);\nconst float light2Pow = 0.5;\n\nconst int NB_LIGHTS = 2;\n\nLightInfo lights[NB_LIGHTS];\n\n//Sky parameters\nconst vec3 skyCol = vec3(0);\nconst int skyId = 0;\n\n//Plane parameters\nconst vec3 planePos = vec3(0, 0.1, 0);\nconst vec3 planeNormal = vec3(0,1.0,0);\nconst vec3 planeCol1 = vec3(1.0);\nconst vec3 planeCol2 = vec3(0.4);\nconst Material planeMat = Material(0.2,1.0,0.2,5.0);\nconst int planeId = 2;\n\n//Antialiasing parameters\nconst int PIXEL_SAMPLING_GRID_SIZE = 5;\nconst int PIXEL_SAMPLING_SIZE = 5;\n\n//CSG parameters\nconst vec3 csgSphere1Pos = cameraTarget + vec3(-1.125,2,0);\nconst float csgSphere1Radius = 1.4;\n\nconst vec3 csgSphere2Pos = cameraTarget + vec3(1.125,2,0);\nconst float csgSphere2Radius = 1.4;\n\nconst vec3 csgSphere3Pos = cameraTarget + vec3(0,2.5,0);\nconst float csgSphere3Radius = 0.5;\n\nconst vec3 csgSphere4Pos = cameraTarget + vec3(0,2.4,-0.5);\nconst float csgSphere4Radius = 0.5;\n\nconst vec3 csgCol1 = vec3(1.0,0.5,0.0); //orange\nconst vec3 csgCol2 = vec3(0.4,1.0,1.0); //light cyan\nconst vec3 csgCol3 = vec3(1.0,0.0,1.0); //magenta\nconst vec3 csgCol4 = vec3(5.0,5.0,0.0); //hyper yellow\n\nconst Material csgMat = Material(0.2,1.0,0.1,90.0);\nconst int csgId = 3;\n\nint subObjectIdC = 0;\n\nvec2 transform_to_apply(vec2 xy){\n    xy = (2.*xy.xy - iResolution.xy)/iResolution.y;\n    return vec2(xy.x,xy.y);\n}\n\nfloat raySphere(vec3 rayPos, vec3 rayDir, vec3 spherePos, float sphereRadius, out vec3 intersecS, out vec3 normalS)\n{    \n    vec3 diff = rayPos - spherePos;\n    \n    float a = dot(rayDir,rayDir);\n    float b = 2.0 * dot(diff,rayDir);\n    float c = dot(diff,diff) - sphereRadius * sphereRadius;\n    \n    float di = b*b - 4.0*a*c;\n    \n    if(di >= 0.0)\n    {\n        float sdi = sqrt(di);\n        float den = 1.0 / (2.0 * a);\n        float t1 = (-b - sdi) * den;\n        float t2 = (-b + sdi) * den;\n        \n        intersecS = rayPos + t1 * rayDir;\n        normalS = normalize(intersecS - spherePos);\n        \n        return t1;\n    }\n    \n    return -1.;\n}\n\nfloat rayPlane(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal, out vec3 intersecPt, out vec3 normal)\n{\n    if(dot(rayDir,planeNormal)!=0.0)\n    {\n        float t = dot(planePos - rayPos,planeNormal)/dot(rayDir,planeNormal);\n        \n        intersecPt = rayPos + t * rayDir;\n        normal = planeNormal;\n        \n        return t;\n    }\n    return -1.0;\n}\n\nfloat rayCSG(vec3 rayPos, vec3 rayDir, out vec3 intersecPt, out vec3 normal, out int subObjectId)\n{\n    //Our example CSG object is define like this : ((sphere1 AND sphere2) OR sphere3) - sphere4)\n\t\n    float distIn, distOut;\n    distIn = -1.0;\n    distOut = -1.0;\n    \n    //Intersection sphere 1\n    vec3 diff1 = rayPos - csgSphere1Pos;\n    \n    float a1 = dot(rayDir,rayDir);\n    float b1 = 2.0 * dot(diff1,rayDir);\n    float c1 = dot(diff1,diff1) - csgSphere1Radius * csgSphere1Radius;\n    \n    float di1 = b1*b1 - 4.0*a1*c1;\n    \n    float dist1IN, dist1OUT;\n    \n    if(di1 >= 0.0)\n    {\n        float sdi1 = sqrt(di1);\n        float den1 = 1.0 / (2.0 * a1);\n        float t11 = (-b1 - sdi1) * den1;\n        float t21 = (-b1 + sdi1) * den1;\n        \n        //sphere1IN = rayPos + t11 * rayDir;\n        //sphere1OUT = rayPos + t21 * rayDir;\n        dist1IN = t11;\n        dist1OUT = t21;\n        //normalS1 = normalize(intersecS1 - csgSphere1Pos);\n    }\n    else\n    {\n        dist1IN = -1.0;\n        dist1OUT = -1.0;\n    }\n    \n    \n    //Intersection Sphere 2\n    vec3 diff2 = rayPos - csgSphere2Pos;\n    \n    float a2 = dot(rayDir,rayDir);\n    float b2 = 2.0 * dot(diff2,rayDir);\n    float c2 = dot(diff2,diff2) - csgSphere2Radius * csgSphere2Radius;\n    \n    float di2 = b2*b2 - 4.0*a2*c2;\n    \n    float dist2IN, dist2OUT;\n    \n    if(di2 >= 0.0)\n    {\n        float sdi2 = sqrt(di2);\n        float den2 = 1.0 / (2.0 * a2);\n        float t12 = (-b2 - sdi2) * den2;\n        float t22 = (-b2 + sdi2) * den2;\n        \n        //sphere1IN = rayPos + t12 * rayDir;\n        //sphere1OUT = rayPos + t22 * rayDir;\n        dist2IN = t12;\n        dist2OUT = t22;\n        //normalS2 = normalize(intersecS2 - csgSphere2Pos);\n    }\n    else\n    {\n        dist2IN = -1.0;\n        dist2OUT = -1.0;\n    }\n    \n    //Intersection Sphere 3\n    vec3 diff3 = rayPos - csgSphere3Pos;\n    \n    float a3 = dot(rayDir,rayDir);\n    float b3 = 2.0 * dot(diff3,rayDir);\n    float c3 = dot(diff3,diff3) - csgSphere3Radius * csgSphere3Radius;\n    \n    float di3 = b3*b3 - 4.0*a3*c3;\n    \n    float dist3IN, dist3OUT;\n    \n    if(di3 >= 0.0)\n    {\n        float sdi3 = sqrt(di3);\n        float den3 = 1.0 / (2.0 * a3);\n        float t13 = (-b3 - sdi3) * den3;\n        float t23 = (-b3 + sdi3) * den3;\n        \n        //sphere3IN = rayPos + t13 * rayDir;\n        //sphere3OUT = rayPos + t23 * rayDir;\n        dist3IN = t13;\n        dist3OUT = t23;\n        //normalS3 = normalize(intersecS3 - csgSphere3Pos);\n    }\n    else\n    {\n        dist3IN = -1.0;\n        dist3OUT = -1.0;\n    }\n    \n    //Intersection Sphere 4\n    vec3 diff4 = rayPos - csgSphere4Pos;\n    \n    float a4 = dot(rayDir,rayDir);\n    float b4 = 2.0 * dot(diff4,rayDir);\n    float c4 = dot(diff4,diff4) - csgSphere4Radius * csgSphere4Radius;\n    \n    float di4 = b4*b4 - 4.0*a4*c4;\n    \n    float dist4IN, dist4OUT;\n    \n    if(di4 >= 0.0)\n    {\n        float sdi4 = sqrt(di4);\n        float den4 = 1.0 / (2.0 * a4);\n        float t14 = (-b4 - sdi4) * den4;\n        float t24 = (-b4 + sdi4) * den4;\n        \n        //sphere4IN = rayPos + t14 * rayDir;\n        //sphere4OUT = rayPos + t24 * rayDir;\n        dist4IN = t14;\n        dist4OUT = t24;\n        //normalS4 = normalize(intersecS4 - csgSphere4Pos);\n    }\n    else\n    {\n        dist4IN = -1.0;\n        dist4OUT = -1.0;\n    }\n    \n    //Sphere1 AND Sphere2\n    \n    if((dist1OUT < dist2IN) || (dist2OUT < dist1IN))\n    {\n        distIn = -1.0;\n    \tdistOut = -1.0;\n    }\n    else\n    {\n        distIn = max(dist1IN,dist2IN);\n        distOut = min(dist1OUT,dist2OUT);\n        if(distIn == dist1IN)\n        {\n        \tsubObjectId = 1;\n            intersecPt = rayPos + distIn * rayDir;\n        \tnormal = normalize(intersecPt - csgSphere1Pos);\n        }\n        else\n        {\n            subObjectId = 2;\n            intersecPt = rayPos + distIn * rayDir;\n        \tnormal = normalize(intersecPt - csgSphere2Pos);\n        }\n    }\n    \n    //(Sphere1 AND Sphere2) OR Sphere3\n    if(distIn > 0.0 && dist3IN > 0.0)\n    {\n        distIn = min(distIn,dist3IN);\n        distOut = max(distOut, dist3OUT);\n        if(distIn == dist3IN)\n        {\n        \tsubObjectId = 3;\n            intersecPt = rayPos + distIn * rayDir;\n        \tnormal = normalize(intersecPt - csgSphere3Pos);\n        }\n    }\n    else\n    {\n        distIn = max(distIn,dist3IN);\n        distOut = max(distOut, dist3OUT);\n        if(distIn > 0.0)\n        {\n        \tif(distIn == dist3IN)\n        \t{\n        \t\tsubObjectId = 3;\n        \t    intersecPt = rayPos + distIn * rayDir;\n        \t\tnormal = normalize(intersecPt - csgSphere3Pos);\n       \t\t}\n        }\n        else\n        {\n            distIn = -1.0;\n    \t\tdistOut = -1.0;\n            subObjectId = 0;\n        }\n    }\n    \n    //((Sphere1 AND Sphere2) OR Sphere3) - Sphere4\n    if(distIn > 0.0 && dist4IN > 0.0)\n    {\n        if(distIn < dist4IN)\n        {\n            distOut = dist4IN;\n        }\n        else\n        {\n            if(distOut > dist4OUT)\n            {\n            \tdistIn = dist4OUT;\n            \tsubObjectId = 4;\n            \tintersecPt = rayPos + distIn * rayDir;\n        \t\tnormal = normalize(intersecPt - csgSphere4Pos);\n            }\n            else\n            {\n                distIn = -1.0;\n            }\n        }\n    }\n    else\n    {\n        if(distIn < 0.0)\n        {\n            distIn = -1.0;\n    \t\tdistOut = -1.0;\n            subObjectId = 0;\n        }\n        else\n        {\n            distOut = dist4IN;\n        }\n    }\n    \n    if(distIn >= 0.0)\n        return distIn;\n    \n    subObjectId = 0;\n    \n    return -1.0;\n}\n\nvoid computeCameraRayFromPixel(in vec2 pixCoord, out vec3 rayPos, out vec3 rayDir)\n{\n    rayPos = cameraPos;\n    \n    float f = 1./tan(radians(cameraFovY)/2.);\n    \n    vec3 PT = cameraTarget - cameraPos;\n    vec3 cz = normalize(PT);\n    \n    vec3 PO = f*cz;\n    \n    vec3 cyT = vec3(0,-1.,0);\n    vec3 cxT = cross(cyT,cz);\n    \n    vec3 cx = normalize(cxT);\n    \n    vec3 cy = cross(cz,cx);\n    \n    vec3 OS = pixCoord.x * cx - pixCoord.y * cy;\n    \n    rayDir = normalize(PO+OS);\n}\n\nvec3 computePhongShading(vec3 sphereCol, Material sphereMat,float shadowFactor, vec3 normal, vec3 L, vec3 R, vec3 V, LightInfo light)\n{\n    vec3 A = sphereMat.Ka * ambiantCol / float(NB_LIGHTS);\n    vec3 D = sphereMat.Kd * sphereCol * light.col * light.power * max(dot(L,normal),0.0);\n    vec3 S = sphereMat.Ks * light.col * light.power  * pow(max(dot(R,V),0.0),sphereMat.Kn);\n    return A+shadowFactor*D+shadowFactor*S;\n}\n\n\n\n//The aim of this routine is to find the nearest intersection the ray has with all objects\nfloat computeNearestIntersection(vec3 rayPos, vec3 rayDir, out int objectId, out vec3 intersecI, out vec3 normalI)\n{\n    // M√©thode pas adapt√©e pour l'ajout d'objets, \n    // pour le CSG je m'inspire de la m√©thode ComputeNearestIntersection de https://www.shadertoy.com/view/XslcDM\n    \n    /*vec3 intersecS, normalS;\n    float distSphere = raySphere(rayPos, rayDir, spherePos, sphereRadius, intersecS, normalS);\n    vec3 intersecP, normalP;\n    float distPlane = rayPlane(rayPos, rayDir, planePos, planeNormal, intersecP, normalP);\n    if(distSphere > 0.0 && distPlane > 0.0)\n    {\n        float distMin = min(distSphere,distPlane);\n        objectId = (distSphere == distMin) ? sphereId : planeId; \n        intersecI = (distSphere == distMin) ? intersecS : intersecP; ;\n        normalI = (distSphere == distMin) ? normalS : normalP; ;\n        return distMin;\n    }\n    else\n    {\n        if(distSphere > 0.0)\n        {\n            objectId = sphereId;\n            intersecI = intersecS;\n            normalI = normalS;\n            return distSphere;\n        }\n        else if (distPlane > 0.0)\n        {\n            objectId = planeId;\n            intersecI = intersecP;\n            normalI = normalP;\n            return distPlane;\n        }\n        else\n        {\n           \tobjectId = skyId;\n            return -1.0;\n        }\n    }*/\n    \n    // Set the default value when no intersection is found: we hit the 'sky'\n    float minDist  = 1000000.0;\n          objectId = skyId;\n    \n    // Test the sphere\n    vec3 intersecS, normalS;\n    float distS = raySphere(rayPos, rayDir, spherePos, sphereRadius, intersecS, normalS);\n    if ((distS > 0.0) && (distS < minDist))\n    {\n        objectId  =  sphereId;\n        minDist   =     distS;\n        intersecI = intersecS;\n          normalI =   normalS;\n    }\n    \n    // Test the plane\n    vec3 intersecP, normalP;\n    float distP =  rayPlane(rayPos, rayDir,  planePos,  planeNormal, intersecP, normalP);\n    if ((distP > 0.0) && (distP < minDist))\n    {\n        objectId  =   planeId;\n        minDist   =     distP;\n\t    intersecI = intersecP;\n    \t  normalI =   normalP;\n    }\n    \n    // Test the CSG object\n    vec3 intersecC, normalC;\n    float distC =  rayCSG(rayPos, rayDir,  intersecC,  normalC, subObjectIdC);\n    if ((distC > 0.0) && (distC < minDist))\n    {\n        objectId  =   csgId;\n        minDist   =     distC;\n\t    intersecI = intersecC;\n    \t  normalI =   normalC;\n    }\n    \n    // To remain coherent with the raySphere & rayPlane function that returns -1 when no\n    // intersetion is found, we add the following two lines:\n    if (objectId == skyId)\n        minDist = -1.0;\n    \n    return minDist;\n}\n\nvec3 getSphereColorAtPoint(vec3 pt)\n{\n    return sphereCol;\n}\n\n//pt is assumed to be on the place surface\nvec3 getPlaneColorAtPoint(vec3 pt)\n{\n    return mod(floor(pt.x*0.5) + floor(pt.z*0.5),2.0) < 1.0 ? planeCol1 : planeCol2;\n}\n\nvec3 getCSGColorAtPoint(vec3 pt)\n{\n    switch(subObjectIdC)\n    {\n        case 1:\n        \treturn csgCol1;\n        case 2:\n        \treturn csgCol2;\n        case 3:\n        \treturn csgCol3;\n        case 4:\n        \treturn csgCol4;\n        default:\n        \treturn vec3(3);\n    }\n}\n\nvec3 getObjectColorAtPoint(int objectId, vec3 pt, out Material objectMat)\n{\n    switch(objectId)\n    {\n        case 0:\n        \treturn skyCol;\n        case 1:\n        \tobjectMat = sphereMat;\n        \treturn getSphereColorAtPoint(pt);\n        case 2:\n        \tobjectMat = planeMat;\n        \treturn getPlaneColorAtPoint(pt);\n        case 3:\n        \tobjectMat = csgMat;\n        \treturn getCSGColorAtPoint(pt);\n    }\n}\n\nfloat getShadowFactorAtPoint(vec3 I, vec3 N, Material objectMat, vec3 L, float Ldist)\n{\n    I += 0.001*N;\n    int objId;\n    vec3 intersecS, normalS;\n    float d = computeNearestIntersection(I,L,objId,intersecS,normalS);\n    return (d<=0.0 || d>=Ldist)?1.0:objectMat.Ka;\n}\n\nvec3 RaytraceAtPixelCoord(vec2 pixCoord)\n{\n    vec3 rayPos, rayDir;\n    computeCameraRayFromPixel(pixCoord, rayPos, rayDir);\n    \n    ShadeInfo infos[MAX_NB_BOUNCES];\n    int nbBounces = 0;\n    do\n    {\n        int objectId;\n        vec3 intersecI, normalI;\n        float distI = computeNearestIntersection(rayPos,rayDir,objectId,intersecI,normalI);\n        \n        if(distI <= 0.0)\n        {\n            infos[nbBounces].shadedCol = skyCol;\n            infos[nbBounces].Ks = 0.0;\n            break;\n        }\n        \n        \n    \tvec3 V = -rayDir;\n        Material objMat;\n    \tvec3 col = getObjectColorAtPoint(objectId, intersecI, objMat);\n        \n        vec3 c = vec3(0.);\n        \n        for(int i=0;i<NB_LIGHTS;i++)\n        {\n    \t\tvec3 L = normalize(lights[i].pos - intersecI);\n    \t\tvec3 R = normalize(2.0*dot(normalI,L)*normalI - L);\n        \n        \tfloat Ldist = distance(intersecI,lights[i].pos);\n        \n        \tfloat shadowFactor = getShadowFactorAtPoint(intersecI, normalI, objMat, L, Ldist);\n        \n    \t\t//Phong shading to get the color of the surface point\n    \t\tc += computePhongShading(col, objMat, shadowFactor, normalI, L, R, V, lights[i]);\n        }\n        \n        \n        infos[nbBounces].shadedCol = c;\n        infos[nbBounces].Ks = objMat.Ks;\n        \n        rayPos = intersecI + 0.001*normalI;\n        rayDir = normalize(2.0*dot(normalI,V)*normalI - V);\n        //objId = objectId;\n        \n        nbBounces++;\n        \n    }while(nbBounces < MAX_NB_BOUNCES);\n    \n    vec3 resCol = vec3(0);\n    \n   \tdo\n    {\n        resCol = infos[nbBounces].shadedCol + infos[nbBounces].Ks * resCol;\n        nbBounces--;\n    }while(nbBounces >= 0);\n    \n    return resCol;\n}\n\n//De facto \"noise\" function, modified to supply two values\n//Taken from: https://www.shadertoy.com/view/4dGXW1\nvec2 noise2(vec2 location, vec2 delta)\n{\n    const vec2 c = vec2(12.9898,78.233);\n    const float m = 43758.5453;\n    return vec2(\n        fract(sin(dot(location + delta, c)) * m),\n        fract(sin(dot(location + vec2(delta.y,delta.x),c)) * m)\n        );\n}\n\nvoid animateScene(float time)\n{\n    const float pi = 3.1415926535;\n    const float rs = 2.0;\n    const float spr = 5.0;\n    float as = 2.0 * pi * time / spr;\n    \n    spherePos = cameraTarget + rs * vec3(-sin(as),0.0,cos(as)) + vec3(0,1,0);\n    \n    light1Pos += vec3(0,10.5 + 9.5 * cos(time) - 10.,0);\n    \n    float targetDist = length(cameraTarget - cameraPos);\n    cameraPos -= vec3(0,0,targetDist);\n    cameraPos += targetDist * vec3(sin(time),max(sin(time*0.5),0.),cos(time));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    \n    animateScene(time*1.0);\n    \n    lights[0].pos = light1Pos;\n    lights[0].col = light1Col;\n    lights[0].power = light1Pow;\n    lights[1].pos = light2Pos;\n    lights[1].col = light2Col;\n    lights[1].power = light2Pow;    \n    \n    \n    \n    //Apply change of coordinates from pixel\n    fragCoord = transform_to_apply(fragCoord.xy);\n    \n    vec3 resCol = vec3(0);\n    \n    for (int i=0; i<PIXEL_SAMPLING_GRID_SIZE; i++) \n    {\n        for (int j=0; j<PIXEL_SAMPLING_SIZE; j++) \n        {\n            vec2 offset = vec2(float(i)/(float(PIXEL_SAMPLING_GRID_SIZE)*iResolution.x),float(j)/(float(PIXEL_SAMPLING_SIZE)*iResolution.y));\n            //vec2 q =  vec2(float(i), float(j));\n            //vec2 n = noise2( fragCoord , q );\n            //vec2 offset = vec2(n.x/800., n.y/600.);\n\t\t\tresCol += RaytraceAtPixelCoord(fragCoord + offset);\n      \t}\n    }\n    resCol /= float(PIXEL_SAMPLING_GRID_SIZE * PIXEL_SAMPLING_SIZE);\n    \n    fragColor = vec4(resCol,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lKBzV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lKfRc", "name": "Bubbling displacement", "author": "anneka", "description": "Raymarching displacement and morphing.", "tags": ["raymarching"], "likes": 4, "viewed": 447, "date": "1543443621", "time_retrieved": "2024-06-20T19:23:49.590721", "image_code": "const float phi = (1.+sqrt(5.))*.5;\n\nfloat rand(vec2 c){\n\treturn fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 eye() {\n    return vec3(.2, .5, 2.);\n}\n\nvec3 lookAt (vec3 from, vec3 target, vec2 uv) {\n    vec3 forward = normalize(target - from);\n    vec3 right = normalize(cross(forward, vec3(0,1,0)));\n    vec3 up = normalize(cross(forward, right));\n    return normalize(forward * .5 + uv.x * right + uv.y * up);\n}\n\nmat2 rotation(float angle) {\n    float c = cos(angle), s = sin(angle);\n    return mat2(c, s, -s, c);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdDodecahedron(vec3 p, float r)\n{\n    const vec3 n = normalize(vec3(phi,1,0));\n\n    p = abs(p/r);\n    float a = dot(p,n.xyz);\n    float b = dot(p,n.zxy);\n    float c = dot(p,n.yzx);\n    return (max(max(a,b),c)-n.x)*r;\n}\n\nfloat sdIcosahedron(vec3 p, float r)\n{\n    const float q = (sqrt(5.)+3.)/2.;\n\n    const vec3 n1 = normalize(vec3(q,1,0));\n    const vec3 n2 = vec3(sqrt(3.)/3.);\n\n    p = abs(p/r);\n    float a = dot(p, n1.xyz);\n    float b = dot(p, n1.zxy);\n    float c = dot(p, n1.yzx);\n    float d = dot(p, n2.xyz)-n1.x;\n    return max(max(max(a,b),c)-n1.x,d)*r; // turn into (...)/r  for weird refractive effects when you subtract this shape\n}\n\nfloat displace(float shape, vec3 p, float freq, float scale) {\n    float d = sin(freq*p.x)*sin(freq*p.y)*sin(freq*p.z);\n    return shape + scale*d;\n}\n\nfloat sdf(vec3 eye) {\n    mat2 rot = rotation(iTime*.1);\n    vec3 p = eye;\n    p.xy *= rot;\n    p.xz *= rot;\n    p.yz *= rot;\n        \n    float shape = min(\n            sdDodecahedron(p,.75),\n            sdIcosahedron(p.zyx,.75)\n        );\n    vec3 pos = eye;\n    float displacedShape = displace(shape, p, mix(20., 1., (sin(iTime)*.5 + .5)), .1);\n    \n    return mix(displacedShape, shape, (sin(iTime)*.5 + .5));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv = (uv-.5) / 2.;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec4 color = vec4(0.);\n\n    float shade = 0.;\n    float distTotal = 0.;\n\n    vec3 eye = eye();\n    vec3 target = vec3(0);\n    vec3 ray = lookAt(eye, target, uv);\n    const float count = 50.;\n\n    for (float i = count; i > 0.; --i) {\n\n        float dist = sdf(eye);\n\n        if (dist < .0001) {\n            shade = i/count;\n            break;\n        }\n\n        eye += ray * dist;\n        distTotal += dist;\n    }\n    \n    vec3 shadeColor = mix(vec3(0., 1., 0.), vec3(0., 0., 1.), (sin(iTime)*.5 + .5));\n\n\tcolor = vec4(vec3(pow(shade, 2.)) * shadeColor, 1.);\n    \n    color.rgb += rand(uv+vec2(iTime*.00001))*.15;\n   \n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lKfRc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lKfzw", "name": "normal-raymarching", "author": "ukonpower", "description": "haa\n", "tags": ["raymarching"], "likes": 4, "viewed": 101, "date": "1543327734", "time_retrieved": "2024-06-20T19:23:49.590721", "image_code": "const float PI = 3.14159265;\nconst float angle = 60.0;\nconst float fov = angle * 0.5 * PI / 180.0;\n\nvec3 cPos = vec3(0,0,3);\n\nconst float sSize = 0.5;\n\nfloat sphereDF(vec3 p){\n    //„É¨„Ç§Â∫ßÊ®ô„ÅÆ‰πóÈô§„ÇíÂèñ„Çã„Åì„Å®„Åß„É¨„Ç§„Çí„É´„Éº„Éó\n    vec3 loopP = mod(p,4.0) - 2.0;\n\treturn length(loopP) - sSize;\n}\n\nvec3 getNormal(vec3 p){\n    float delta = 0.001;\n\tvec3 dx = vec3(delta,0.0,0.0);\n\tvec3 dy = vec3(0.0,delta,0.0);\n\tvec3 dz = vec3(0.0,0.0,delta);\n    vec3 result;\n    result.x = sphereDF(p + dx) - sphereDF(p - dx);\n    result.y = sphereDF(p + dy) - sphereDF(p - dy);\n    result.z = sphereDF(p + dz) - sphereDF(p - dz);\n    \n    return normalize(result);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //uv„ÇíÂèñÂæó\n    vec2 pos = (fragCoord * 2.0  - iResolution.xy ) / min(iResolution.x,iResolution.y);\n    \n    //„É¨„Ç§„Çí‰ΩúÊàê\n\tvec3 ray = normalize(vec3(sin(fov) * pos.x,sin(fov) * pos.y,-1.0));\n    \n    //„É¨„Ç§„Åã„Çâ„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆË∑ùÈõ¢\n    float rDistance = 0.0;\n    //„É¨„Ç§„ÅÆÈÄ≤„Çì„Å†Ë∑ùÈõ¢\n    float rLen = 0.0;\n    \n    //„Ç´„É°„É©„ÅÆ‰ΩçÁΩÆ„ÇíÁßªÂãï\n    cPos.z -= iTime * 10.0;\n    cPos.y = sin(iTime) * 5.0;\n    cPos.x = cos(iTime * 0.5) * 2.0;\n    vec3 rPos = cPos;\n    \n    //„É¨„Ç§„Éû„Éº„ÉÅ„É≥„Ç∞\n    for(int i = 0; i < 64; i++){\n    \trDistance = sphereDF(rPos);\n        rLen += rDistance;\n        rPos = cPos + ray * rLen;\n    }\n    \n    vec3 col = vec3(0,0,0);\n    //ÊúÄÁü≠Ë∑ùÈõ¢„ÅåÂçÅÂàÜÁü≠„Åë„Çå„Å∞\n    if(abs(rDistance) <= 0.01){\n        //„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆÁ†≤Êà¶„ÇíÂèñÂæó\n        vec3 normal = getNormal(rPos);\n        float diff = clamp(dot(vec3(0.5,0.5,0.5), normal), 0.1, 1.0);\n        //„Éî„ÇØ„Çª„É´„ÅÆÊèèÁîª\n        col = vec3(diff);\n    }else{\n        //„É¨„Ç§„Åå„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Å´Âà∞ÈÅî„Åó„Å¶„ÅÑ„Å™„Åë„Çå„Å∞ÊèèÁîª„Åó„Å™„ÅÑ\n        col = vec3(0,0,0);\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lKfzw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lKfzy", "name": "Mandelbulb Variant", "author": "coler706", "description": "I switched out some formulas in https://www.shadertoy.com/view/MsfGRr to create my own fractal.", "tags": ["procedural", "3d", "raymarching", "distancefield", "mandelbulb", "kindernoiser"], "likes": 4, "viewed": 205, "date": "1542989718", "time_retrieved": "2024-06-20T19:23:50.900364", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// A port of my 2007 demo Kindernoiser: https://www.youtube.com/watch?v=9AX8gNyrSWc (http://www.pouet.net/prod.php?which=32549)\n//\n// More (oudated, half broken) info here:  http://iquilezles.org/www/articles/juliasets3d/juliasets3d.htm\n\n\n// antialais level (1, 2, 3...)\n#define AA 2\n\n// undefine this to use numerical normals (central differences)\n//#define ANALYTIC\n\nvec4 qsqr( in vec4 a ) // square a quaterion\n{\n    return vec4( a.x*a.x - a.y*a.y - a.z*a.z - a.w*a.w,\n                 2.0*a.x*a.y,\n                 2.0*a.x*a.z,\n                 2.0*a.x*a.w );\n}\n\nconst int numIterations = 10;\nvoid powN(float p, inout vec3 z, float zr0, inout float dr)\n{\n    float zx0 = asin(z.x / zr0);\n    float zy0 = asin(z.y / zr0);\n    float zz0 = asin(z.z / zr0);\n    float zr = pow(zr0, p - 1.0);\n    float zx = zx0 * p;\n    float zy = zy0 * p;\n    float zz = zz0 * p;\n\n    dr = zr * dr * p + 1.0;\n    zr *= zr0;\n\n    z = zr * normalize(vec3(sin(zx),sin(zy), sin(zz)));\n}\n\nfloat map( in vec3 p, out vec4 oTrap, in vec4 c )\n{\n    vec3 zz=p;\n    vec3 cc=p;\n    vec4 z = normalize(vec4(p.x+p.y+p.z,p.x-p.y-p.z,-p.x-p.y+p.z,-p.x+p.y-p.z))*length(p);\n    vec4 c0 =vec4(p,0.0);// normalize(vec4(p.x+p.y+p.z,p.x-p.y-p.z,-p.x-p.y+p.z,-p.x+p.y-p.z))*length(p);//vec4(p,0.0);\n    float md2 = 1.0;\n    float mz2 = dot(z,z);\n\n    vec4 trap = vec4(abs(z.xyz),dot(z,z));\n\n    for( int i=0; i<numIterations; i++ )\n    {\n        //md2 *= 16.0*pow(length(z),15.0);   // dz -> 2¬∑z¬∑dz, meaning |dz| -> 2¬∑|z|¬∑|dz| (can take the 4 out of the loop and do an exp2() afterwards)\n        //z = qsqr(qsqr(qsqr(qsqr(z)))) + c0;  // z  -> z^2 + c\n        powN(5.0,zz,length(zz),md2);\n\t\tzz=zz+cc;\n        trap = min( trap, vec4(abs(zz.xyz),dot(zz,zz)) );\n\n        mz2 = dot(zz,zz);\n        if(mz2>4.0) break;\n    }\n    \n    oTrap = trap;\n\n    return 0.5*length(zz)/md2*log(length(zz));  // d = 0.5¬∑|z|¬∑log|z| / |dz|\n}\n\n#ifdef ANALYTIC\n// analytic normal\nvec3 calcNormal( in vec3 p, in vec4 c )\n{\n    vec4 z = vec4(p,0.0);\n\n    mat4x4 J = mat4x4(1,0,0,0,  // identity\n                      0,1,0,0,  \n                      0,0,1,0,  \n                      0,0,0,1 );\n\n  \tfor(int i=0; i<numIterations; i++)\n    {\n        J = J*mat4x4(z.x, -z.y, -z.z, -z.w, // chain rule of jacobians (removed the 2 factor)\n                     z.y,  z.x,  0.0,  0.0,\n                     z.z,  0.0,  z.x,  0.0, \n                     z.w,  0.0,  0.0,  z.x);\n\n        z = qsqr(z) + c; // z -> z2 + c\n        \n        if(dot(z,z)>4.0) break;\n    }\n\n    return normalize( (J*z).xyz );\n}\n#else\n// numerical method\nvec3 calcNormal( in vec3 pos, in vec4 c )\n{\n    vec4 kk;\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.001;\n    return normalize( e.xyy*map( pos + e.xyy, kk, c ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, kk, c ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, kk, c ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, kk, c ) );\n}\n#endif\n\nfloat intersect( in vec3 ro, in vec3 rd, out vec4 res, in vec4 c )\n{\n    vec4 tmp;\n    float resT = -1.0;\n\tfloat maxd = 20.0;\n    float h = 1.0;\n    float t = 0.0;\n    for( int i=0; i<300; i++ )\n    {\n        if( h<0.0001||t>maxd ) break;\n\t    h = map( ro+rd*t, tmp, c );\n        t += h;\n    }\n    if( t<maxd ) { resT=t; res = tmp; }\n\n\treturn resT;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k, in vec4 c )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<64; i++ )\n    {\n        vec4 kk;\n        float h = map(ro + rd*t, kk, c);\n        res = min( res, k*h/t );\n        if( res<0.001 ) break;\n        t += clamp( h, 0.01, 0.5 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec4 c )\n{\n\tconst vec3 sun = vec3(  0.577, 0.577,  0.577 );\n    \n\tvec4 tra;\n\tvec3 col;\n    float t = intersect( ro, rd, tra, c );\n    if( t < 0.0 )\n    {\n     \tcol = vec3(0.7,0.9,1.0)*(0.7+0.3*rd.y);\n\t\tcol += vec3(0.8,0.7,0.5)*pow( clamp(dot(rd,sun),0.0,1.0), 48.0 );\n\t}\n\telse\n\t{\n        vec3 mate = vec3(1.0,0.8,0.7)*0.3;\n\t\t//mate.x = 1.0-10.0*tra.x;\n        \n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, c );\n        \n\t\tfloat occ = clamp(2.5*tra.w-0.15,0.0,1.0);\n\t\t\n\n        col = vec3(0.0);\n\n        // sky\n        {\n        float co = clamp( dot(-rd,nor), 0.0, 1.0 );\n        vec3 ref = reflect( rd, nor );\n        //float sha = softshadow( pos+0.0005*nor, ref, 0.001, 4.0, c );\n        float sha = occ;\n        sha *= smoothstep( -0.1, 0.1, ref.y );\n        float fre = 0.1 + 0.9*pow(1.0-co,5.0);\n            \n\t\tcol  = mate*0.3*vec3(0.8,0.9,1.0)*(0.6+0.4*nor.y)*occ;\n\t\tcol +=  2.0*0.3*vec3(0.8,0.9,1.0)*(0.6+0.4*nor.y)*sha*fre;\n        }\n\n        // sun\n        {\n        const vec3 lig = sun;\n        float dif = clamp( dot( lig, nor ), 0.0, 1.0 );\n        float sha = softshadow( pos, lig, 0.001, 64.0, c );\n        vec3 hal = normalize( -rd+lig );\n        float co = clamp( dot(hal,lig), 0.0, 1.0 );\n        float fre = 0.04 + 0.96*pow(1.0-co,5.0);\n        float spe = pow(clamp(dot(hal,nor), 0.0, 1.0 ), 32.0 );\n        col += mate*3.5*vec3(1.00,0.90,0.70)*dif*sha;\n        col +=  7.0*3.5*vec3(1.00,0.90,0.70)*spe*dif*sha*fre;\n        }\n\n        // extra fill\n        {\n        const vec3 lig = vec3( -0.707, 0.000, -0.707 );\n\t\tfloat dif = clamp(0.5+0.5*dot(lig,nor), 0.0, 1.0 );\n        col += mate* 1.5*vec3(0.14,0.14,0.14)*dif*occ;\n        }\n        \n        // fake SSS\n        {\n        float fre = clamp( 1.+dot(rd,nor), 0.0, 1.0 );\n        col += mate* mate*0.6*fre*fre*(0.2+0.8*occ);\n        }\n    }\n\n\treturn pow( col, vec3(0.4545) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // anim\n    float time = iTime*.15;\n    vec4 c = 0.45*cos( vec4(0.5,3.9,1.4,1.1) + time*vec4(1.2,1.7,1.3,2.5) ) - vec4(0.3,0.0,0.0,0.0);\n\n    // camera\n\tfloat r = 2.5+0.15*cos(0.0+0.29*time);\n\tvec3 ro = vec3(           r*cos(0.3+0.37*time), \n\t\t\t\t\tr*cos(1.0+0.33*time), \n\t\t\t\t\t          r*cos(2.2+0.31*time) );\n\tvec3 ta = vec3(0.0,0.0,0.0);\n    float cr = 0.1*cos(0.1*time);\n    \n    \n    // render\n    vec3 col = vec3(0.0);\n    for( int j=0; j<AA; j++ )\n    for( int i=0; i<AA; i++ )\n    {\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord + vec2(float(i),float(j))/float(AA))) / iResolution.y;\n\n        vec3 cw = normalize(ta-ro);\n        vec3 cp = vec3(sin(cr), cos(cr),0.0);\n        vec3 cu = normalize(cross(cw,cp));\n        vec3 cv = normalize(cross(cu,cw));\n        vec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n\n        col += render( ro, rd, c );\n    }\n    col /= float(AA*AA);\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tcol *= 0.7 + 0.3*pow(16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y),0.25);\n    \n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lKfzy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4ltBD2", "name": "my  House", "author": "rdcorning", "description": "house", "tags": ["epg200"], "likes": 0, "viewed": 72, "date": "1541532125", "time_retrieved": "2024-06-20T19:23:51.427231", "image_code": "//house data\nvec2 housePos = vec2(0.2, 0.1);\nfloat houseLengthX = 0.6;\nfloat houseLengthY = 0.4;\nvec3 houseColor = vec3(0.9, 0.9, 0.0);\nfloat houseAlpha;\n//window1 data\nvec2 windowPos = vec2(0.3, 0.25);\nvec3 windowColor = vec3(0.2, 0.5, 1.0);\nfloat windowLength = 0.13;\nfloat windowAlpha;\n//window2 data\nvec2 window2Pos = vec2(0.6, 0.25);\nvec3 window2Color = vec3(0.2, 0.5, 1.0);\nfloat window2Length = 0.13;\nfloat window2Alpha;\n//chimny data\nvec2 chimneyPos = vec2(.3, 0.8);\nvec3 chimneyColor = vec3(0.8, 0.4, 0.0);\nfloat chimneyLengthX = 0.05;\nfloat chimneyLengthY = 0.075;\nfloat chinmeyAlpha;\n//sunset\nfloat brightness = 1.0;\n\n//switches\nfloat houseSwitch = 1.0;\nfloat windowSwitch = 1.0;\nfloat window2Switch = 1.0;\nfloat chimneySwitch = 1.0;\n\nvec4 BG = vec4(0.0);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //list to do\n    \n    //1. make rectange for house\n    //2. make 2 square for windows\n    //3. make square for chimny\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aRatio = iResolution.y / iResolution.x;\n    uv.y *= aRatio;\n    \n    //----------------------------------------------------------------------------------------------------------------------\n    //create house\n    vec4 houseLayer = vec4(0.0);\n    housePos.y *= aRatio;\n    \n    float houseInterpX = step(housePos.x, uv.x) - step(housePos.x + houseLengthX, uv.x);\n\tfloat houseInterpY = step(housePos.y, uv.y) - step(housePos.y + houseLengthY, uv.y);\n    houseAlpha = (houseInterpX * houseInterpY) * houseSwitch;\n\n    houseLayer = vec4(houseColor, houseAlpha);\n    //----------------------------------------------------------------------------------------------------------------------\n    //create window1\n    vec4 windowLayer = vec4(0.0);\n    windowPos.y *= aRatio;\n    \n    float window1InterpX = step(windowPos.x, uv.x) - step(windowPos.x + windowLength, uv.x);\n\tfloat window1InterpY = step(windowPos.y, uv.y) - step(windowPos.y + windowLength, uv.y);\n    windowAlpha = (window1InterpX * window1InterpY) * windowSwitch;\n    \n    windowLayer = vec4(windowColor, windowAlpha);\n    //----------------------------------------------------------------------------------------------------------------------\n    //create window2\n    vec4 window2Layer = vec4(0.0);\n    window2Pos.y *= aRatio;\n    \n    float window2InterpX = step(window2Pos.x, uv.x) - step(window2Pos.x + window2Length, uv.x);\n\tfloat window2InterpY = step(window2Pos.y, uv.y) - step(window2Pos.y + window2Length, uv.y);\n    window2Alpha = (window2InterpX * window2InterpY) * window2Switch;\n    \n    window2Layer = vec4(window2Color, window2Alpha);\n    //----------------------------------------------------------------------------------------------------------------------\n    //create chinmey\n    chimneyPos.y *= aRatio;\n    vec4 chinmeyLayer = vec4(0.0);\n\n    float chimneyInterpX = step(chimneyPos.x, uv.x) - step(chimneyPos.x + chimneyLengthX, uv.x);\n\tfloat chimneyInterpY = step(chimneyPos.y, uv.y) - step(chimneyPos.y + chimneyLengthY, uv.y);\n    chinmeyAlpha= (chimneyInterpX * chimneyInterpY) * chimneySwitch;\n    \n\tchinmeyLayer = vec4(chimneyColor, chinmeyAlpha);\n    //-------------------------------------------------------------------------------------------------------------------\n    //create sunset\n    vec4 sunSet = vec4(1.0, uv.y, 0.3, 1.0);\n   \tsunSet.rg *= abs(cos(iTime) * brightness);\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec4 Comp = mix(BG, sunSet, sunSet.a);\n    Comp = mix (Comp, houseLayer, houseLayer.a);\n    Comp = mix (Comp, windowLayer, windowLayer.a);\n    Comp = mix (Comp, window2Layer, window2Layer.a);\n    Comp = mix (Comp, chinmeyLayer, chinmeyLayer.a);\n\n   \tfragColor = Comp;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ltBD2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lVfDh", "name": "cycle rand histogram", "author": "FabriceNeyret2", "description": "top: show effect of fract( rand + time )\nleft: bluenoise   right: whitenoise\nextreme sides: binarized final value.\n\nwhitenoise shows more disturbing propagating fronts.\nbluenoise does not, but structure disturbingly persistent.", "tags": ["cycle", "bluenoise", "rand"], "likes": 8, "viewed": 470, "date": "1542388281", "time_retrieved": "2024-06-20T19:23:51.427231", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy; \n // U *= .5; R*= .5;  // uncomment for zoomed version\n    \n    O = U.x<R.x/2. ? texelFetch(iChannel0, ivec2(mod(U,iChannelResolution[0].xy)),0)\n                   : texelFetch(iChannel1, ivec2(mod(U,iChannelResolution[1].xy)),0);\n\n    O = O.xxxx;       // comment if you want colors\n\n    if (U.y>R.y/2.) O = fract( O + iTime ); \n \n    if (abs(U.x-R.x/2.)>R.x/4.) O = step(.5,O);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lVfDh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lVfDw", "name": "sphere field", "author": "khlorghaal", "description": " ", "tags": ["volume", "raymarch", "vr"], "likes": 8, "viewed": 223, "date": "1542773082", "time_retrieved": "2024-06-20T19:23:51.427231", "image_code": "#define ETA 1e-5\n\n#define PI 3.14159265359\n#define TAU (PI*2.)\n\n#define time float(iTime)\n\n#define ITERS 1024\n\nprecision highp float;\n\nvec3 sumv(vec2 v){ return vec3(dot(v,vec2(1))); }\nvec3 sumv(vec3 v){ return vec3(dot(v,vec3(1))); }\nvec3 sumv(vec4 v){ return vec3(dot(v,vec4(1))); }\nfloat sums(vec2 v){ return dot(v,vec2(1)); }\nfloat sums(vec3 v){ return dot(v,vec3(1)); }\nfloat sums(vec4 v){ return dot(v,vec4(1)); }\n\n#define CA vec4(\\\n    3411.23,\\\n    3415.23,\\\n    3421.34,\\\n    3401.34)\n#define CB vec4(\\\n    5061.11,\\\n    5021.43,\\\n    5043.13,\\\n    5051.13)\nfloat rand4_1(vec4 x){\n    return fract(\n        sin(sin(dot(x,CB))*CA.x)\n    );\n}\n\nvec4 psmooth(vec4 x){\n\treturn x*x*(3.-2.*x);\n    //return x;\n}\n\nfloat f(vec3 p){\n\n    p.z+= time*-2.7;\n    p.x+= time* 2.3;\n\n    /*\n    vec3 wind= vec3(\n    noise( vec4(p,time   ),vec4(.2,.1,.1,1.)),\n    noise( vec4(p,time+4.),vec4(.2,.1,.1,1.)),\n    noise( vec4(p,time+8.),vec4(.2,.1,.1,1.))\n    );\n    p+= wind*.2;\n    */\n\n    p= mod(p,2.)-1.;\n\treturn dot(p,p)>.2? 0.:1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv= fragCoord/iResolution.xy;\n    vec2 uvn= uv*2.-1.;\n    uvn.x*= iResolution.x/iResolution.y;\n    \n    vec2 xy= uvn;\n    vec3 c= vec3(0.);\n    \n\tfloat t= 0.;\n    for(int i=0; i!=ITERS; i++){\n        t+= .006*(t+1.);\n        vec3 p= vec3(xy,1.)*t;\n        #define COLORA vec3(0.,.9,.0)\n        #define COLORB vec3(0.,.1,1.)\n        float ab= clamp(t*.01,0.,1.);\n        c+= log(t)*f(p)*mix(COLORA,COLORB,ab);\n    }\n    c/=float(ITERS)*.2;\n    c= pow(c,vec3(1./2.2));\n        \n    fragColor= vec4(c,1.0);\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{    \n    vec3 c= vec3(0.);\n    \n\tfloat t= 0.;\n    for(int i=0; i!=ITERS; i++){\n        t+= .006*(t+1.);\n        vec3 p= fragRayOri+fragRayDir*t;\n        #define COLORA vec3(0.,.9,.0)\n        #define COLORB vec3(0.,.1,1.)\n        float ab= clamp(t*.01,0.,1.);\n        c+= log(t)*f(p)*mix(COLORA,COLORB,ab);\n    }\n    c/=float(ITERS)*.2;\n    c= pow(c,vec3(1./2.2));\n        \n    fragColor= vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lVfDw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lVfR1", "name": "Peace Within", "author": "voz", "description": "To forever inscribe peace.", "tags": ["peace", "treaty"], "likes": 0, "viewed": 287, "date": "1541832014", "time_retrieved": "2024-06-20T19:23:52.027204", "image_code": "//Do not redistribute.\n\n//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((.125-.25*saw(float(__LINE__)*PI*GR*E)/PI/GR/E)*iTime+1000.0)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.25, .75, x))\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan(uv.y, uv.x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define circle(x) (vec2(cos((x)*2.0*PI),sin(2.0*PI*(x))))\n\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n\n\nfloat saw(float x)\n{\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\nvec2 saw(vec2 x)\n{\n    return vec2(saw(x.x), saw(x.y));\n}\n\nvec3 saw(vec3 x)\n{\n    return vec3(saw(x.x), saw(x.y), saw(x.z));\n}\n\nvec4 saw(vec4 x)\n{\n    return vec4(saw(x.x), saw(x.y), saw(x.z), saw(x.w));\n}\n\n\n//-----------------ITERATED FUNCTION SYSTEM-----------------\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float gradient = uv.y;\n    \n        float scale = E;\n    uv = uv*scale-scale/2.0;\n    \n    float aspect = iResolution.x/iResolution.y;\n    \n    uv.x *= aspect;\n    \n    vec2 uv0 = uv;\n    \n    int max_iterations = 4;//-int(saw(spounge)*float(max_iterations)/2.0);\n    \n    float antispeckle = 1.0; \n    float magnification = 1.0;\n  \n\tvec4 color = vec4(0.0);\n    float map = 0.0;\n    float border = 1.0;\n    vec4 final = vec4(0.0);\n    float c1 = 0.0;\n    \n    for(int i = 0; i < max_iterations; i++)\n    {\n        float iteration = float(i)/float(max_iterations);\n    \n        float d = -cos(float(i)*PI);\n        \n        vec2 o = circle(time*d)*(1.0-iteration)/2.0;\n        \n        \n        float c = smoothstep(0.0, 1.0/E/E, 1.0-length(uv));\n        if(i == 0) c1 = c;\n        \n        \n        \n        vec2 uv2 = (uv+o)*(E+iteration);\n        float c2 = smoothstep(1.0/E, 1.0/GR, 1.0-length(uv2)*2.0/PI)*c;\n        vec2 uv3 = (uv-o)*(E+iteration);\n        float c3 = smoothstep(1.0/E, 1.0/GR, 1.0-length(uv3)*2.0/PI)*c;\n        \n        uv = ((uv)*(1.0-c2)*(1.0-c3)+\n            (uv2)*(c2)*(1.0-c3)+\n            (uv3)*(1.0-c2)*(c3))*(antispeckle)+uv*(1.0-antispeckle)*c;\n        \n        \n        border *= saw(1.0+c2*2.0)*saw(1.0+c3*2.0);\n\n        float b = pow(border, iteration);\n        float a = atan(uv.y, uv.x)/PI*.5+.5;\n        float l = d*length(uv)*.5;\n        map += smoothstep( 0.0, border*GR, GR*saw(c+c2+c3)*saw(border*saw(saw(2.0*(a+l))*saw(b*(d-c2)*(d-c3))*antispeckle)*(iteration+1.0)));\n        \n        antispeckle *= (clamp((c2+c3), 0.0, 1.0))*(1.0-saw(c2*2.0-c3)*saw(c3*2.0-c2));\n        final += vec4(flux(map*PI+time*GR*E), 1.0);\n    }\n     \n    float w = smoothstep(.8, 1.0, saw(map));\n    \n    map = smoothstep(0.0, 1.0, map);\n    fragColor = ((w+final*(1.0-w)))*map*c1+(1.0-c1)*gradient;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "proprietary-license", "thumbnail": "https://www.shadertoy.com/media/shaders/4lVfR1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lVfWz", "name": "Simple Spiral Test", "author": "jangxx", "description": "Basic spiral (port from another project)", "tags": ["test"], "likes": 4, "viewed": 58, "date": "1542232381", "time_retrieved": "2024-06-20T19:23:52.027204", "image_code": "#define PI2 6.28318530718\n\nbool equals(float val, float check, float tolerance) {\n    if (val + tolerance > check && val - tolerance < check) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nbool equalsMod(float val, float check, float tolerance, float modulo) {\n    if (mod(mod(val, modulo) - check, modulo) < tolerance) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float aspect = iResolution.x / iResolution.y;\n    \n    const vec2 centerOffset = vec2(0,0);\n    const float speed = 5.0;\n    const float lineThickness = 0.5 * PI2;\n\n    vec2 pos = (uv * 2.0) - vec2(1, 1);\n    pos -= centerOffset;\n\t\n    pos.x *= aspect;\n    \n    float radius = length(pos);\n    float angle = acos(pos.y / radius);\n    if (pos.x <= 0.0) {\n        angle = (PI2) - angle;\n    }\n\n    angle = mod(angle + iTime * speed, PI2);\n\n    float r = radius * 10.0 * PI2;\n\n    if (equalsMod(r, angle, lineThickness, PI2)) {\n        fragColor = vec4(1,1,1,1);\n    } else {\n        fragColor = vec4(0,0,0,1);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lVfWz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lVfzW", "name": "TestColor RayTracing Sphere", "author": "defaultUser0", "description": "Testing spheres and color", "tags": ["raytracingspherecolor"], "likes": 2, "viewed": 88, "date": "1542026378", "time_retrieved": "2024-06-20T19:23:52.033282", "image_code": "#define STEP_SIZE .1\n#define NUMBER_OF_STEPS 32\n#define MINIMUM_HIT_DISTANCE .001\n#define MAXIMUM_TRACE_DISTANCE 1000.\n#define SMALL_STEP vec3(.001, 0., 0.)\n#define SQRT2 1.41421356237\n#define SQRT13 3.60555127546\n#define NB_THRESHOLDS 100.\n#define PI 3.14159265359\n#define AA_SAMPLES_X 4.\n\n#define sph(p, c, r) length(p-c)-r\n\n\n// params:\n// p: arbitrary point in 3D space\n// c: the center of our sphere\n// r: the radius of our sphere\n\n// polynomial smooth min (k = 0.1);\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 );\n    return min( a, b ) - h*h*h/(6.0*k*k);\n}\n\nfloat SDF(in vec3 p){\n    //float displacement = 0.;//sin(5. * p.x) * sin(5. * p.y) * sin(5. * p.z) * 0.25;\n        \n \tfloat sphere_0 = sph(p, vec3(0.), 1.);\n    \n    float sphere_1 = sph(p, vec3(1.5*sin(iTime),1.5*sin(iTime),-1.), 0.5);\n    \n    //Later we might have sphere_1, sphere_2, cube_3, etc...\n    \n    return sminCubic(sphere_0, sphere_1, 1.5);\n}\n\nvec3 calculate_normal(in vec3 p){\n    return normalize(vec3(\n    SDF(p + SMALL_STEP.xyy) - SDF(p - SMALL_STEP.xyy),\n    SDF(p + SMALL_STEP.yxy) - SDF(p - SMALL_STEP.yxy),\n    SDF(p + SMALL_STEP.yyx) - SDF(p - SMALL_STEP.yyx)));\n}\n    \nvec3 ray_march(in vec3 ro, in vec3 rd){\n\tfloat total_distance_traveled = 0.;\n    // Ray Marching\n    for (int i = 0; i < NUMBER_OF_STEPS ; ++i){\n        // Calculate our current posiiton along the ray\n        vec3 current_position = ro + total_distance_traveled * rd;\n        \n        // Sphere centered at the origin and has unit radius\n        float distance_to_closest = SDF(current_position);\n        \n        if (distance_to_closest < MINIMUM_HIT_DISTANCE)\n        {\n            vec3 normal = calculate_normal(current_position);\n            \n            // for now hard-code the ligth's position in our scene\n            vec3 light_position = vec3(SQRT13*cos(2.*iTime), -5.0, SQRT13*sin(2.*iTime));\n            vec3 light_color = vec3(1., 0., 0.);\n            \n            //Calculate the unit direction vector that point from\n            // the point of intersection to the light source\n            vec3 direction_to_light = normalize(current_position - light_position);\n            \n            float diffuse_intensity = max(0., floor(dot(normal, direction_to_light)*NB_THRESHOLDS)/NB_THRESHOLDS);\n            \n            // for now hard-code the ligth's position in our scene\n            vec3 light_position2 = vec3(SQRT13*cos(2.*iTime + 2.*PI/3.), -5.0, SQRT13*sin(2.*iTime + 2.*PI/3.));\n            vec3 light_color2 = vec3(0., 0., 1.);\n            \n            //Calculate the unit direction vector that point from\n            // the point of intersection to the light source\n            vec3 direction_to_light2 = normalize(current_position - light_position2);\n            \n            float diffuse_intensity2 = max(0., floor(dot(normal, direction_to_light2)*NB_THRESHOLDS)/NB_THRESHOLDS);\n            \n            // for now hard-code the ligth's position in our scene\n            vec3 light_position3 = vec3(SQRT13*cos(2.*iTime + 4.*PI/3.), -5.0, SQRT13*sin(2.*iTime+ 4.*PI/3.));\n            vec3 light_color3 = vec3(0., 1., 0.);\n            \n            //Calculate the unit direction vector that point from\n            // the point of intersection to the light source\n            vec3 direction_to_light3 = normalize(current_position - light_position3);\n            \n            float diffuse_intensity3 = max(0., floor(dot(normal, direction_to_light3)*NB_THRESHOLDS)/NB_THRESHOLDS);\n            \n         \t// we hit something ! Return red for now\n            return clamp(vec3(1.,1.,1.)*(diffuse_intensity * light_color + diffuse_intensity2 * light_color2 + diffuse_intensity3 * light_color3), vec3(0.), vec3(1.));\n        }\n        \n        if (total_distance_traveled > MAXIMUM_TRACE_DISTANCE) //miss\n        {\n         \tbreak;   \n        }\n        \n        // accumulate the distance traveled thus far\n        total_distance_traveled += distance_to_closest;\n    }\n    \n    // If we get here, we didn't hit anything so just\n    // rerturn a background color (black)\n    return vec3(0.2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    \n    // Normalized pixel coordinates (from -1 to 1) and normalize\n    vec2 uv = 2.*fragCoord.xy/iResolution.x - vec2(1., iResolution.y/iResolution.x);\n    float delta = 2./iResolution.x;\n    \n    vec3 camera_position  = vec3(0., 0., -5. - 0.*sin(iTime));\n    vec3 ro = camera_position;\n    vec3 rd;\n    \n\n\t// ANTI ALIASING ALGORITHM\n    vec3 shaded_color = vec3(0);\n    for (float i=0. ; i < AA_SAMPLES_X * AA_SAMPLES_X ; i++){\n        //rd = vec3(uv, 1.0);\n        rd = vec3(uv.x + delta/2. * (floor(i/AA_SAMPLES_X) - 0.5), uv.y + delta/2. * (mod(i,AA_SAMPLES_X) - 0.5),1.0);\n        shaded_color += ray_march(ro, rd);\n    }\n    shaded_color /= AA_SAMPLES_X * AA_SAMPLES_X;\n    \n\n    // Output to screen\n    fragColor = vec4(shaded_color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lVfzW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lyBD1", "name": "smooth purple", "author": "Del", "description": "purple", "tags": ["raymarch"], "likes": 7, "viewed": 376, "date": "1542308919", "time_retrieved": "2024-06-20T19:23:52.033282", "image_code": "// simple plane march\nmat2 rotate(float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n#define\tTAU 6.28318\n\nfloat map(vec3 p)\n{\n    float d =  length(p.xz);\n\n    float t2 = fract(iTime*0.5) * TAU;\n    \n\tfloat y = 0.5+sin(t2 + d)*0.5;\n\ty = y*=abs(p.x*p.z)*0.125;\n\ty = smoothstep(0.0,4.0,y);\n\t\n\treturn p.y - y*y;\n}\n\nvec3 normal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\nvec3 render(vec3 ro, vec3 rd)\n{\n\t// march\t\n\tfloat tmin = 0.1;\n\tfloat tmax = 120.;\n\tvec3 p;\n\tfloat t = tmin;\n\tfor (int i = 0; i < 80; i++)\n\t{\n\t\tp = ro + t * rd;\n\t\tfloat d = map(p);\n\t\tt += d*0.5;\n\t\tif (t > tmax)\n\t\t\tbreak;\t\t\n\t}\n\t\n    // light\n\tif (t < tmax)\n\t{\n\t   \tvec3 lightDir = normalize(vec3(1.5, 1.0, 0.5));\n\t\tvec3 nor = normal(p);\n\t\tvec3 c = vec3(0.3, 0.1, 0.5);\n\t\t\n\t\tfloat dif = max(dot(nor, lightDir), 0.0);\n\t\tc += vec3(0.2) * dif;\n\t\t\n\t\tvec3 ref = reflect(rd, nor);\n\t\tfloat spe = max(dot(ref, lightDir), 0.0);\n\t\tc += vec3(3.0) * pow(spe, 16.);\n\t\t\n\t\treturn c;\n\t}\n\t\n\treturn vec3(0.2,0.2,0.6);\n}\n\nmat3 camera(vec3 ro, vec3 ta, vec3 up)\n{\n\tvec3 nz = normalize(ta - ro);\n\tvec3 nx = cross(nz, normalize(up));\n\tvec3 ny = cross(nx, nz);\n\treturn mat3(nx, ny, nz);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.xy;\n\tp.x *= iResolution.x / iResolution.y;\n    \n\n\tvec3 ro = vec3(0.0, 10.0, 0.0);\n    \n    float ang = radians(-90.0);\n    ro.z = sin(ang)*14.0;\n    ro.x = cos(ang)*14.0;\n    \n\tvec3 ta = vec3(0.0, -2.0, 0.0);\n\t\n\tvec3 rd = camera(ro, ta, vec3(0.0, 1.0, 0.0)) * normalize(vec3(p.xy, 1.0));\n\t\n\tvec3 c = render(ro, rd);\n\n    // vignette\n    c *= 0.4 + 0.6*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\n\tfragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lyBD1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lyBR3", "name": "FFT Strings", "author": "RaduBT", "description": "https://www.shadertoy.com/view/ldsBRn", "tags": ["fftstrings"], "likes": 10, "viewed": 775, "date": "1543287548", "time_retrieved": "2024-06-20T19:23:52.033282", "image_code": "// lots of inspiration from IQ and hg_sdf\n\nconst float PI = 3.14159265359;\nconst int MAX_MARCHING_STEPS = 50;\nconst float EPSILON = 0.0001;\n\nvec2 rotate2d(vec2 v, float a) {\n\treturn vec2(v.x * cos(a) - v.y * sin(a), v.y * cos(a) + v.x * sin(a)); \n}\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat sdTorus( vec3 p, vec2 t ) {\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}\n\nfloat opTwist( vec3 p, float fftValue, float time ) {\n    float c = cos((fftValue*1.5) *p.y);\n    float s = sin((fftValue+0.5)*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m * p.xz, p.y);\n    \n    return sdTorus(q, vec2(abs(sin(iTime*0.1))+0.5*(fftValue*0.2), fftValue*0.0001));\n\n}\n\nfloat opRep( vec3 p, vec3 c ) {\n            \n    float idx = mod((floor((p.x)/c.x)), 32.0);\n    float idy = mod((floor((p.y)/c.y)), 32.0);\n    float idz = mod((floor((p.z)/c.z)), 32.0);\n    \n\tfloat id = length(vec3(idx, idy, idz));\n       \n    float fftValue = (((texture( iChannel0, vec2(id+1.0, 0.0) ).x)) * 10.0);\n    \n    vec3 q = mod(p, c) - 0.5 * c;\n\n    vec3 r = q;  \n    \n    float rotationAmount = (id * 5.0) + (iTime * 2.0);\n   \n    bool xmod2 = mod(idx, 2.0) == 0.0;\n    \n    // offset even rows\n    if (xmod2) {\n    \tq.y += 1.5;\n        r.y -= 1.5;\n    }\n    \n\tpR(q.xy, rotationAmount);\n    pR(q.xz, rotationAmount * 0.1);\n    \n    float shape1 = opTwist(q, fftValue, iTime);\n    \n    if (xmod2) {\n    \n        pR(r.xy, rotationAmount);\n        pR(r.xz, rotationAmount * 0.1);\n        \n        float shape2 = opTwist(r, fftValue, iTime);\n        \n    \treturn min(shape1, shape2);\n        \n    } else {\n        \n        return shape1;\n        \n    }\n}\n\n\nfloat sceneSDF(vec3 samplePoint) {\n\treturn opRep(samplePoint, vec3(3.0, 3.0, 3.0));\n}\n\nvec3 castRay(vec3 pos, vec3 dir) {\n\tfor (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n\t\tfloat dist = sceneSDF(pos);\n        if (dist < EPSILON) {\n\t\t\treturn pos;\n        }\n\t\tpos += dist * dir;\n\t}    \n\treturn pos;\n}\n\n\nfloat lightPointDiffuse(vec3 pos, vec3 lightPos) {\n\tfloat lightDist = length(lightPos - pos);\n\tfloat color = 3.0 / (lightDist * lightDist);\n\treturn max(0.0, color);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    float fft = ( iChannel0, vec2(fragCoord.x,fragCoord.y) ).x; \n\tfft = 0.9*fft;\n    \n\tvec4 mousePos = (iMouse / iResolution.xyxy) * 2.0 - 1.0;\n    \n\tmousePos *= vec2(PI / 2.0, PI / 2.0).xyxy;\n    \n    if (iMouse.zw == vec2(0.0)) {\n        mousePos.xy = vec2(0.5, -0.2); \n    }\n\t\n\tvec2 screenPos = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\t\n\tvec3 cameraPos = vec3(0.0, 0.0, -8.0);\n\t\n\tvec3 cameraDir = vec3(0.0, 0.0, 1.0);\n\tvec3 planeU = vec3(2.0, 0.0, 0.0);\n\tvec3 planeV = vec3(0.0, iResolution.y / iResolution.x * 2.0, 0.0);\n\tvec3 rayDir = normalize(cameraDir + screenPos.x * planeU + screenPos.y * planeV);\n\t\n\tcameraPos.yz = rotate2d(cameraPos.yz, mousePos.y);\n\trayDir.yz = rotate2d(rayDir.yz, mousePos.y);\n\t\n\tcameraPos.xz = rotate2d(cameraPos.xz, mousePos.x);\n\trayDir.xz = rotate2d(rayDir.xz, mousePos.x);\n    \n    cameraPos.zy += iTime;\n\t\n\tvec3 rayPos = castRay(cameraPos, rayDir);\n\t\n    // base color\n\tvec3 color = vec3(0.01, 0.23, 0.43);\n    \n    color += (rayDir*0.02);\n    \n    vec3 lightPos = cameraPos;\n\n    color *= 10.0 * lightPointDiffuse(rayPos, lightPos) * 10.0;\n    \n\tcolor = pow(color, vec3(0.4));\t\n\t\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "MlX3R8", "previewfilepath": "https://soundcloud.com/robotaki/tron-legacy-daft-punk-derezzed", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/robotaki/tron-legacy-daft-punk-derezzed", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lyBR3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lyBzK", "name": "House: shape over shape ", "author": "TLC123", "description": "House UPDATED: more fidelity  \nSorry for the messy code, Just a plaything so far.\nMore than just a lathe in my opinion.\nuse one 2d SDF to find a 2D dist of  say ( X , Y )  then use that  with remaining axis Z to look up another 2d SDF  (dist , Z) \n", "tags": ["2d", "sdf", "shape"], "likes": 36, "viewed": 397, "date": "1543068571", "time_retrieved": "2024-06-20T19:23:53.803199", "image_code": "\n\n// Fork of \"2 * 2d -> 3d  \" by TLC123. https://shadertoy.com/view/MlyfRW\n// 2018-11-21 16:26:28\n\n// Fork of \"The Walking Raymarcher\" by xorxor. https://shadertoy.com/view/Mt3XWH\n// 2018-11-11 15:37:21\n\n\n// tracer from  https://shadertoy.com/view/Mt3XWH\n// sdPentagon from https://www.shadertoy.com/view/llVyWW\n// roundrect forked fromm https://www.shadertoy.com/view/4sjyRz\n// http://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n// https://www.shadertoy.com/view/XdfXDB\n// http://mercury.sexy/hg_sdf/\n// sexy union functions work just as great in 2D\n\n// grass https://www.shadertoy.com/view/ls33W7\nfloat  tile=24.0;\n\nfloat hash1( vec2 n )\n{\n    return fract(sin(dot(n,vec2(1.0,113.0)))*43758.5453123);\n}\nfloat fOpPipe(float a, float b, float r) {\n    return length(vec2(a, b)) - r;\n}\nvec2 pR45(  vec2 p) {\n    p = (p + vec2(p.y, -p.x)) * sqrt(0.5);\n    return (p);\n}\nvec2 pR90(  vec2 p) {\n    p = (vec2(p.y, -p.x)) ;\n    return (p);\n}\nfloat pMod1(inout float p, float size) {\n    float halfsize = size * 0.5;\n    float c = floor((p + halfsize) / size);\n    p = mod(p + halfsize, size) - halfsize;\n    return c;\n}\n// The \"Columns\" flavour makes n-1 circular columns at a 45 degree angle:\nfloat fOpUnionColumns(float a, float b, float r, float n) {\n    if ((a < r) && (b < r)) {\n        vec2 p = vec2(a, b);\n        float columnradius = r * sqrt(2.0) / ((n - 1.) * 2. + sqrt(2.));\n        pR45(p);\n        p.x -= sqrt(2.) / 2. * r;\n        p.x += columnradius * sqrt(2.);\n        if (mod(n, 2.) == 1.) {\n            p.y += columnradius;\n        }\n        // At this point, we have turned 45 degrees and moved at a point on the\n        // diagonal that we want to place the columns on.\n        // Now, repeat the domain along this direction and place a circle.\n        pMod1(p.y, columnradius * 2.);\n        float result = length(p) - columnradius;\n        result = min(result, p.x);\n        result = min(result, a);\n        return min(result, b);\n    } else {\n        return min(a, b);\n    }\n}\n// first object gets a capenter-style groove cut out\nfloat fOpGroove(float a, float b, float ra, float rb) {\n    return max(a, min(a + ra, rb - abs(b)));\n}\n\n// first object gets a capenter-style tongue attached\nfloat fOpTongue(float a, float b, float ra, float rb) {\n    return min(a, max(a - ra, abs(b) - rb));\n}\n\nfloat fOpEngrave(float a, float b, float r) {\n    return max(a, (a + r - abs(b)) * sqrt(0.5));\n}\n\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n    float s = r / n;\n    float u = b - r;\n    return min(min(a, b), 0.5 * (u + a + abs((mod(u - a + s, 2. * s)) - s)));\n}\n\nfloat sdBox( in vec2 p, in vec2 b) {\n    vec2 d = abs(p) - b;\n    return (max(d.x, d.y));\n}\n\n\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2) {\n    vec2 e0 = p1 - p0, e1 = p2 - p1, e2 = p0 - p2;\n    vec2 v0 = p - p0, v1 = p - p1, v2 = p - p2;\n\n    vec2 pq0 = v0 - e0 * clamp(dot(v0, e0) / dot(e0, e0), 0.0, 1.0);\n    vec2 pq1 = v1 - e1 * clamp(dot(v1, e1) / dot(e1, e1), 0.0, 1.0);\n    vec2 pq2 = v2 - e2 * clamp(dot(v2, e2) / dot(e2, e2), 0.0, 1.0);\n\n    float s = sign(e0.x * e2.y - e0.y * e2.x);\n    vec2 d = min(min(vec2(dot(pq0, pq0), s * (v0.x * e0.y - v0.y * e0.x)),\n            vec2(dot(pq1, pq1), s * (v1.x * e1.y - v1.y * e1.x))),\n        vec2(dot(pq2, pq2), s * (v2.x * e2.y - v2.y * e2.x)));\n\n    return -sqrt(d.x) * sign(d.y);\n}\n\n\n\nfloat smin(float a, float b) {\n    const float k = .26;\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n\n}\n\nfloat smax(float d1, float d2, float k) {\n\n    float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n    return mix(d2, -d1, h) + k * h * (1.0 - h);\n}\n\n\nfloat roundrect(vec2 p, vec2 c, vec2 r) {\n\n    p = abs(p) - c + r;\n    if (p.x >= 0.0 && p.y >= 0.0)\n        return length(p) - r.x;\n    else\n        return max(p.x, p.y) - r.x;\n}\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\n\nfloat shape1(vec2 p ,float seed) {\n   \n    \n p=fract(p/tile)*tile;\n  p = vec2(abs(p.x)-(tile*0.5)  ,p.y-(tile*0.5+3.)  ); \n    \nif (fract(seed*7.1)<=0.5){p=pR90(p);           }\nif (fract(seed*9.1)<=0.5){p=pR90(p);           }\n   if (seed<=0.5){p=p.yx;           }\nif (fract(seed*3.1)<=0.5){p=pR90(p);           }\n\n    float d = roundrect(p - vec2(0, -3), vec2(6, 3),vec2(0.));\n\n    if (fract(seed*13.1)<=0.5){p=pR90(p);           }\n    \n      p = vec2(  (p.x)  +cos(seed*17.)*1.25 ,p.y +sin(seed*27.)*1.25); \n\n\n\n    d = fOpUnionStairs(d, roundrect(p - vec2(0, -4.4), vec2(2.2, 3),vec2(0.)), .6, 2.);\n    //d=min(d,   sdBox(p-vec2(0,-2),vec2(2,2) ) );\n    // d=fOpUnionStairs(d, sdLine(p,vec2(0,0),vec2(0,-3))-2. ,.8,2.);\n\n    d = fOpUnionStairs(d, sdLine(p, vec2(0, 0), vec2(0, -3)) - 1.9, .5, 2.);\n    d = fOpUnionStairs(d, sdLine(p, vec2(0, 2), vec2(0, -3)), .5, 2.);\n    d = fOpUnionStairs(d, sdLine(p, vec2(1.4, 1.4), vec2(0, 0)), .5, 2.);\n    d = fOpUnionStairs(d, sdLine(p, vec2(-1.4, 1.4), vec2(0, 0)), .5, 2.);\n\n      p= vec2(abs(p.x),p.y); // mirror p\n    \n    float g = sdBox(p - vec2(0, -3), vec2(4.45, 11));\n    g = smin(g, sdBox(p - vec2(0, -3), vec2(12, 1.42)));\n    //d=min(d,fOpGroove(d,g,0.2,0.51));\n    // d=fOpGroove(d,g,0.2,0.51);\n    d = (fOpTongue(d, g, 0.2, 0.7*seed*seed));\n\n    float g1 = (sdBox(p - vec2(0, -6), vec2(1.3, 4)));\n    d = smin(d, fOpPipe(d - .6, g1, 0.4*seed));\n\n    return (d);\n}\n\n\nfloat shape2(vec2 p,float seed) {\n    \n    \n\n    float d = sdTriangle(p, vec2(0.5, 3), vec2(-4.+sin(seed*10.)*2., 5.+seed*3.), vec2(-10., 5.+seed*3.)); //roof\n    d = min(d, sdTriangle(p, vec2(0.5, 3), vec2(-10., 3), vec2(-10.,5.+seed*3.)));\n\n    d = fOpUnionColumns(d, roundrect(p - vec2(-.4, 3), vec2(1.04, .1), vec2(0.1)), .19, 2.);\n\n\n    d = min(d, roundrect(p - vec2(0, -.5), vec2(0.6, .4), vec2(0.03))); //base\n\n    d = fOpUnionStairs(d, roundrect(p - vec2(-5, 0.4), vec2(5., 2.5), vec2(0.)), 0.3, 2.);\n\n    d = fOpUnionStairs(d, roundrect(p - vec2(0, -1.34), vec2(2.6, .4), vec2(0.)), 0.6, 3.); //base\n\n    d = min(d, roundrect(p - vec2(0, 0.9), vec2(.06, .06), vec2(0.)));\n    d = min(d, roundrect(p - vec2(0, 1.9), vec2(.06, .06), vec2(0.)));\n    d=min(d, p.y + 0.9  );\n \n\n\n    return   d ;\n}\n\nfloat noise(vec2 p){\n    return texture(iChannel0,fract(p)).r;\n}\nvec3 grass(vec2 p){\n    \n    return vec3(mix(\n        vec3(0.12,0.71,0.),\n        vec3(0.07,0.47,0.),\n        noise(p)\n    ));\n}\n\n\nvec4 map(vec3 p) {\n    float plane = abs(p.y + 0.9);\n\nfloat r= hash1(floor(p.xz/tile))*0.5+0.5;    \nfloat g= hash1(vec2(floor(p.xz/tile)+2.));    \nfloat b= hash1(vec2(floor(p.z/tile)))*0.25;    \n\n\n\n    float w = shape1(p.xz,r);\n    float d = shape2(vec2(w, p.y),g);\n\n\n    return (p.y<-0.8 ?vec4(d,grass(  p.xz*0.04)):vec4(d, vec3(r,g,b)/ max(1.,4.*(p.y-2.2)) ));\n}\n\nfloat calcShadow(vec3 ro, vec3 rd, float mint, float maxt) {\n    float t = mint;\n    float res = 1.0;\n    for (int i = 0; i < 100; i++) {\n        float h = map(ro + rd * t).x;\n        res = min(res, 1.1 * h / t);\n        t += h;\n        if ((h < 0.001) || (t > maxt)) {\n            break;\n        }\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nvec4 trace(vec3 ro, vec3 rd) {\n    const float kTMin = 0.001;\n    const float kTMax =300.0;\n    const float kEps = 0.0001;\n\n    float t = kTMin;\n    vec4 res;\n    for (int i = 0; i < 370; i++) {\n        vec3 pos = ro + rd * t;\n        res = map(pos);\n        if ((res.x < kEps) || (t > kTMax)) {\n            break;\n        }\n        t += res.x * 0.25;\n    }\n\n    if (t < kTMax) {\n        return vec4(t, res.yzw);\n    } else {\n        return vec4(-1.0,0,0,0);\n    }\n}\n\nvec3 calcNormal(vec3 p) {\n    const vec2 e = vec2(0.005, 0);\n    float dp = map(p).x;\n    return normalize(vec3(dp - map(p - e.xyy).x,\n        dp - map(p - e.yxy).x,\n        dp - map(p - e.yyx).x));\n}\n\nmat3 calcCamera(vec3 eye, vec3 target) {\n    vec3 cw = normalize(target - eye);\n    vec3 cu = cross(cw, vec3(0, 1, 0));\n    vec3 cv = cross(cu, cw);\n    return mat3(cu, cv, cw);\n}\n\nvec3 cameraPath( float t )\n    \n{\n    t=t*4.;\n    vec2 p  = vec2(400.0*sin(t/102.),400.*cos(t/103.));\n \tp  += vec2(40.0*sin(t/12.),60.*cos(t/13.));\n    float z = 18.0+1.*sin(t/02.) ;\n\n\treturn vec3( p.x,z , p.y );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n\n    vec2 mo = vec2(0.95, -0.2);\n    if (iMouse.z > 0.5) {\n        mo = 10.0 * iMouse.xy / iResolution.xy - 1.0;\n        mo *= 3.14159 * vec2(0.4, 0.1);\n    }\n    mo += 3.14159 * 0.15 * iTime;\n\n    vec3 eye = cameraPath(iTime);\n    vec3 target = cameraPath(iTime+23.+sin(iTime)*6.)-vec3(0,30,0);\n\n    mat3 cam = calcCamera(eye, target);\n\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 rd = cam * normalize(vec3(uv, 2.0));\n\n    vec3 col = vec3(0.60);\n\n    vec4 res = trace(eye, rd);\n    if (res.x > 0.0) {\n        vec3 pos = eye + rd * res.x;\n        vec3 nor = calcNormal(pos);\n        vec3 ldir = normalize(vec3(-10.5, 20.8, 24.0));\n\n        if (res.y < 1.5) {\n                        col = col* 0.4 + 0.6 * (vec3(1) - nor.zxy);\n            col = col*0.2 + 0.8 * (vec3(res.yzw) );\n\n            float dif = abs(dot(nor, ldir));\n            vec3 ref = reflect(rd, nor);\n            float spe = pow(clamp(dot(ref, ldir), 0.0, 1.0), 2.0);\n\n            col *= (0.2 + 0.8 * dif);\n            float edge = pow(1.0 - dot(-rd, nor), 1.011);\n            col += 0.1 * edge + spe;\n        }\n\n        float sh = calcShadow(pos, ldir, 0.1, 30.0);\n        col *= (0.5 + sh);\n    }\n\n\n \n    if (fract((iTime + 1.) / 10.) < 0.165) {\n        // col=vec3( shape1(uv*20.-vec2(0,4))>0. )\n\n        float len = shape1(eye.xz+uv * 50. - vec2(0, 4), hash1(floor((eye.xz+uv * 50. - vec2(0, 4))/tile))) / 10.;\n\n        //distance field coloring by iq https://www.shadertoy.com/view/4lcBWn\n        col = vec3(1.0) - sign(len) * vec3(0.1, 0.4, 0.7);\n        col *= 1.0 - exp(-iResolution.y * 0.008 * abs(len));\n        col *= 0.8 + 0.2 * cos(iResolution.y * 0.3 * abs(len));\n        col = mix(col, vec3(1.0), max(1.0 - abs(len) * iResolution.y * 0.2, 0.0));\n        fragColor = vec4(col * col, 1.0);\n    }\n    if (fract((iTime + 1.) / 10.) < 0.08) {\n        // col=vec3( shape2(uv*20.-vec2(0,-8))>0. );\n\n        float len = shape2(uv * 20. - vec2(0, -2), hash1(floor((uv * 20. - vec2(0, -2))/tile))) / 10.;\n\n        //distance field coloring by iq https://www.shadertoy.com/view/4lcBWn\n        col = vec3(1.0) - sign(len) * vec3(0.1, 0.4, 0.7);\n        col *= 1.0 - exp(-iResolution.y * 0.008 * abs(len));\n        col *= 0.8 + 0.2 * cos(iResolution.y * 0.3 * abs(len));\n        col = mix(col, vec3(1.0), max(1.0 - abs(len) * iResolution.y * 0.2, 0.0));\n        if (abs(uv.x) < 0.005) col = vec3(1.);\n\n        fragColor = vec4(col * col, 1.0);\n    }\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lyBzK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4slBW2", "name": "Kaleido_Complex_1", "author": "balkhan", "description": "I thought I released this into the wild a long time ago, turns out I did not;\nShould be a fun golfing exercise, I guess, feel free;", "tags": ["complex"], "likes": 6, "viewed": 107, "date": "1542523828", "time_retrieved": "2024-06-20T19:23:54.391331", "image_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\n#define I_MAX 12\nfloat\tt;\nvec2 \tcmult(vec2 a, vec2 b);\nvec2\tcadd(vec2 a, vec2 b);\nvec2\tg(vec2 n);\nvec2\tdg(vec2 n);\nvec2\tcdiv(vec2 a, vec2 b);\n\nvoid\tmainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    t = iTime*.125;\n    vec2 R = iResolution.xy,\n          uv  = vec2(fragCoord-R/2.) / R.y;\n    vec4\tz = vec4(0.0, 0.0, 0.0, 0.0);\n    vec2\tof = 2.*vec2( (uv.x )/0.125, (uv.y )/0.125);\n    vec3\tcol = vec3(0.0);\n    vec2\tdist = vec2(0.0);\n    z.xy = of;\n    int ii = -1;\n    float\tparam_i = .0;\n    float\tr = 1.;\n    for (int i = -1; i < I_MAX; ++i)\n    {\n        r*=-1.;\n        ++ii;\n        z.xy = float(ii)*.1251*0.+cmult(z.xy, vec2(1.,1.)).xy;\n        z.xy = abs(z.xy)-5.5+r;\n\t\tz.xy = cmult(z.xy, vec2(sin(t*1.*float(ii)*sin(t*.1+float(ii) ) ), cos(t*1.*float(ii)*sin(t*.1+float(ii) ) ) )-0.*vec2(1., -1.) );\t\n        z.z = 2.0 * (z.x*z.z - z.y*z.w);\n        z.w = 2.0 * (z.y*z.z - z.x*z.w);\n        dist.x = dot(z.xy,z.xy);\n\t\tdist.y = dot(z.zw,z.zw);\n        if ( float(ii) > 0.\n            &&\n            (\n             sqrt(z.x*z.x -float(ii)*.0) < .51\n            ||\n             sqrt(z.y*z.y -float(ii)*.0) < .51\n                )\n           )\n        {\n        col.x = exp(-abs(z.x*z.x*z.y)-0.*abs(cos(float(ii)*.06125+t*8.)) )*1.; // expensive but pretty\n    \tcol.y = exp(-abs(z.y*z.x*z.y)-0.*abs(cos(float(ii)*.06125+t*8.)) )*1.;\n    \tcol.z = exp(-abs(min(z.x,z.y)-0.*abs(cos(float(ii)*.06125+t*8.)) ))*1.;\n            break;\n        }\n\n     \tcol.x += .0*exp(-abs(-z.x/float(ii)+float(ii)/z.x))*2.; // expensive but pretty\n    \tcol.y += .0*exp(-abs(-z.y/float(ii)+float(ii)/z.y))*2.;\n    \tcol.z += .0*exp(-abs((-z.x-z.y)/float(ii)+float(ii)/(z.x+z.y)))*2.;\n        if (dist.x > 10000000.0 || dist.y > 100000000000.0)\n            break;\n    }\n    fragColor = 1.*vec4(col, 1.0);\n}\n\nvec2 \tcmult(vec2 a, vec2 b)\n{\n    return (vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x));\n}\n\nvec2\tcadd(vec2 a, vec2 b)\n{\n\treturn (vec2(a.x + b.x, a.y + b.y));\n}\n\nvec2 g(vec2 n) {\n    return vec2(\n        n.x*n.x*n.x - 3.*n.x*n.y*n.y - 100.,\n        -n.y*n.y*n.y + 3.*n.x*n.x*n.y\n    );\n}\n\nvec2 dg(vec2 n) {\n    return 2. * vec2(\n        n.x*n.x - n.y*n.y,\n        2. * n.x * n.y\n    );\n}\n\nvec2 cdiv(vec2 a, vec2 b) {\n    float d = dot(b, b);\n    if(d == 0.) return a;\n    else return vec2(\n        (a.x*b.x + a.y*b.y),\n        (a.y*b.x - a.x*b.y)) / d;;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4slBW2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tcfDl", "name": "Sponge Test", "author": "Sobaya", "description": "test", "tags": ["raytrace"], "likes": 4, "viewed": 113, "date": "1542807827", "time_retrieved": "2024-06-20T19:23:54.397220", "image_code": "\nconst vec3 light = vec3(5,2.6,3.2) * 5.;\n\nconst float epsilon = 0.001;\nconst float screen_width = 2.;\nconst float screen_height = 2.;\nconst float screen_depth= 2.;\n\nfloat sdBox3( vec3 p, vec3 b ) {\n    p = abs(p) - b;\n    return min(max(p.x, max(p.y, p.z)), length(max(vec3(0), p)));\n}\n \nfloat distSponge(vec3 p) {\n    p = abs(p);\n    float d = sdBox3(p, vec3(1));\n    float s = 1.;\n    for (int i = 0; i < 3; i++) {\n        vec3 a = mod( p*s, 2.0 )-1.0;\n        s *= 3.0;\n        vec3 r = abs(1.0 - 3.0*abs(a));\n        float da = max(r.x,r.y);\n        float db = max(r.y,r.z);\n        float dc = max(r.z,r.x);\n        float c = (min(da,min(db,dc))-1.0)/s;\n\n        if( c>d ) {\n          d = c;\n        }\n    }\n    return d;\n}\n \nfloat dist(vec3 p) {\n    vec3 xvec = normalize(vec3(1,2,4));\n    vec3 yvec = vec3(0,1,0);\n    vec3 zvec = normalize(cross(xvec, yvec));\n    yvec = normalize(cross(zvec, xvec));\n    mat3 r = mat3(xvec, yvec, zvec);\n    float d = distSponge(r * p);\n    d = min(d, distSponge(r * r * (p - vec3(3,1,0))));\n    d = min(d, p.y + 1.5);\n    return d;\n}\n \nvec3 getNormal(vec3 p) {\n\tvec3 result;\n\tresult.x = dist(p + vec3(epsilon, 0, 0)) - dist(p - vec3(epsilon, 0, 0));\n\tresult.y = dist(p + vec3(0, epsilon, 0)) - dist(p - vec3(0, epsilon, 0));\n\tresult.z = dist(p + vec3(0, 0, epsilon)) - dist(p - vec3(0, 0, epsilon));\n\treturn normalize(result);\n}\n\nvec3 rayMarch(vec3 cv, vec3 p) {\n\tfor (int j = 0; j < 64; j++) {\n\t\tfloat d = dist(p);\n\t\tif (abs(d) < epsilon)\n\t\t\tbreak;\n\t\tp += d * cv;\n\t}\n    return p;\n}\n\nfloat shadow(vec3 p) {\n    const float k = 20.;\n    float res = 1.;\n    vec3 v = normalize(light-p);\n    float t = 0.01;\n    float ph = 1e20;\n    for (int i = 0; i < 32; i++) {\n\t\tfloat h = dist(p + t * v);\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n        \n        if (res < epsilon) break;\n        if (t > 100.) break;\n\t}\n    return res;\n}\n \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 tc = fragCoord - iResolution.xy * .5;\n    tc /= iResolution.y;\n    vec3 eye = vec3(1, 3, 5.);\n    vec3 yvec = vec3(0, 1, 0);\n    vec3 n = normalize(vec3(0, 1., 0));\n    float angle = 1. * iTime;\n    float c = cos(angle);\n    float s = sin(angle);\n    mat4 matrix;\n\tmatrix[0][0] = n[0]*n[0]*(1.-c)+c;\n\tmatrix[0][1] = n[0]*n[1]*(1.-c)-n[2]*s;\n\tmatrix[0][2] = n[2]*n[0]*(1.-c)+n[1]*s;\n\tmatrix[1][0] = n[0]*n[1]*(1.-c)+n[2]*s;\n\tmatrix[1][1] = n[1]*n[1]*(1.-c)+c;\n\tmatrix[1][2] = n[1]*n[2]*(1.-c)-n[0]*s;\n\tmatrix[2][0] = n[2]*n[0]*(1.-c)-n[1]*s;\n\tmatrix[2][1] = n[1]*n[2]*(1.-c)+n[0]*s;\n\tmatrix[2][2] = n[2]*n[2]*(1.-c)+c;\n    eye = (matrix * vec4(eye, 1.)).xyz;\n    yvec = (matrix * vec4(yvec, 1.)).xyz;\n    vec3 zvec = normalize(eye);\n    vec3 xvec = normalize(cross(yvec, zvec));\n    yvec = normalize(cross(zvec, xvec));\n\tvec3 cv = normalize(screen_width * tc.x * xvec + screen_height * tc.y * yvec - zvec * screen_depth);\n    vec3 p = rayMarch(cv, eye);\n\tfloat d = dist(p);\n\tif (d < epsilon) {\n        float intensity = texture(iChannel0, p.xz * 0.1).r;\n        vec3 color = vec3(intensity);\n        \n        \n\t\tvec3 normal = getNormal(p);\n        float dif = max(0., dot(normal, normalize(light - p)));\n        dif *= shadow(p);\n         \n        \n        float len = length(p - eye);\n        float fog = len * 0.02;\n        \n        color = color * dif + fog;\n        \n        fragColor = vec4(color, 1.);\n\t} else {\n\t\tfragColor = vec4(1);\n\t}\n   // fragColor += sin(iTime);\n}", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tcfDl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tcfDs", "name": "crowded pillars 3 - 378 chars", "author": "FabriceNeyret2", "description": "golfing [url]https://shadertoy.com/view/4lsSRB[/url]\ncompact simplified version of [url]https://www.shadertoy.com/view/4lfSDn[/url]\n\ndoes it work on Windows ?", "tags": ["3d", "raymarching", "short", "golf"], "likes": 17, "viewed": 911, "date": "1541450392", "time_retrieved": "2024-06-20T19:23:54.397220", "image_code": "// golfing of https://shadertoy.com/view/4lsSRB (458 chars)\n// compact simplified version of https://www.shadertoy.com/view/4lfSDn (990 chars)\n\n#define R        *= mat2( cos( vec4(0,11,33,0) + iTime*\n//#define M(a,b) 1. / ( 1./a + 1./(b) )\n#define M(a,b)   a * b / ( a + b )\n#define L        length\n#define D(s)     min( ( t = abs( s.2 +fract(p) ) ).x , min(t.y,t.z) )\n\nvoid mainImage(out vec4 O, vec2 U) {\n    vec4 p = vec4(U,0,1)/iResolution.yyxy-.5, d,t; p.x -= .4;\n    p.xz R.13)), p.yz R.2)),\n    d = p;  p.z += 5.*iTime;\n    for ( float x,i = 1e2; i-- > 0.; p -= d*x )\n        t = mod(p,8.) - 4.,\n     \tx = L( vec2( M( L(t.xy), M( L(t.yz), L(t.xz) ) ) -.7 , \n                     min( D(-), D() ) ) ),\n        x < .01 ? O += i/83., i = -i:  i; }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tcfDs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tcfWf", "name": "slowgltch", "author": "ljmatkins", "description": "slower glitch", "tags": ["clone"], "likes": 9, "viewed": 148, "date": "1541209565", "time_retrieved": "2024-06-20T19:23:57.803580", "image_code": "#define MODEL_ROTATION vec2(.5, .5)\n#define LIGHT_ROTATION vec2(.3, .8)\n#define CAMERA_ROTATION vec2(.5, .67)\n\n// Mouse control\n// 0: Defaults\n// 1: Model\n// 2: Lighting\n// 3: Camera\n#define MOUSE_CONTROL 1\n\n// Debugging\n//#define NORMALS\n//#define NO_GLITCH\n//#define GLITCH_MASK\n\n\nfloat time;\n\nfloat _round(float n) {\n    return floor(n + .5);\n}\n\nvec2 _round(vec2 n) {\n    return floor(n + .5);\n}\n\n// --------------------------------------------------------\n// HG_SDF\n// https://www.shadertoy.com/view/Xs3GRB\n// --------------------------------------------------------\n\n#define PI 3.14159265359\n#define PHI (1.618033988749895)\n#define TAU 6.283185307179586\n\nfloat vmax(vec3 v) {\n    return max(max(v.x, v.y), v.z);\n}\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n    return dot(p, n) + distanceFromOrigin;\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n\n#define GDFVector3 normalize(vec3(1, 1, 1 ))\n#define GDFVector4 normalize(vec3(-1, 1, 1))\n#define GDFVector5 normalize(vec3(1, -1, 1))\n#define GDFVector6 normalize(vec3(1, 1, -1))\n\n#define GDFVector7 normalize(vec3(0, 1, PHI+1.))\n#define GDFVector8 normalize(vec3(0, -1, PHI+1.))\n#define GDFVector9 normalize(vec3(PHI+1., 0, 1))\n#define GDFVector10 normalize(vec3(-PHI-1., 0, 1))\n#define GDFVector11 normalize(vec3(1, PHI+1., 0))\n#define GDFVector12 normalize(vec3(-1, PHI+1., 0))\n\n#define GDFVector13 normalize(vec3(0, PHI, 1))\n#define GDFVector14 normalize(vec3(0, -PHI, 1))\n#define GDFVector15 normalize(vec3(1, 0, PHI))\n#define GDFVector16 normalize(vec3(-1, 0, PHI))\n#define GDFVector17 normalize(vec3(PHI, 1, 0))\n#define GDFVector18 normalize(vec3(-PHI, 1, 0))\n\n#define fGDFBegin float d = 0.;\n#define fGDF(v) d = max(d, abs(dot(p, v)));\n#define fGDFEnd return d - r;\n\nfloat fDodecahedron(vec3 p, float r) {\n    fGDFBegin\n    fGDF(GDFVector13) fGDF(GDFVector14) fGDF(GDFVector15) fGDF(GDFVector16)\n    fGDF(GDFVector17) fGDF(GDFVector18)\n    fGDFEnd\n}\n\nfloat fIcosahedron(vec3 p, float r) {\n    fGDFBegin\n    fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n    fGDF(GDFVector11) fGDF(GDFVector12)\n    fGDFEnd\n}\n\n\n// --------------------------------------------------------\n// Rotation\n// --------------------------------------------------------\n\nmat3 sphericalMatrix(float theta, float phi) {\n    float cx = cos(theta);\n    float cy = cos(phi);\n    float sx = sin(theta);\n    float sy = sin(phi);\n    return mat3(\n        cy, -sy * -sx, -sy * cx,\n        0, cx, sx,\n        sy, cy * -sx, cy * cx\n    );\n}\n\nmat3 mouseRotation(bool enable, vec2 xy) {\n    if (enable) {\n        vec2 mouse = iMouse.xy / iResolution.xy;\n\n        if (mouse.x != 0. && mouse.y != 0.) {\n            xy.x = mouse.x;\n            xy.y = mouse.y;\n        }\n    }\n    float rx, ry;\n    \n    rx = (xy.y + .5) * PI;\n    ry = (-xy.x) * 2. * PI;\n    \n    return sphericalMatrix(rx, ry);\n}\n\nmat3 modelRotation() {\n    mat3 m = mouseRotation(MOUSE_CONTROL==1, MODEL_ROTATION);\n    return m;\n}\n\nmat3 lightRotation() {\n    mat3 m = mouseRotation(MOUSE_CONTROL==2, LIGHT_ROTATION);\n    return m;\n}\n\nmat3 cameraRotation() {\n    mat3 m = mouseRotation(MOUSE_CONTROL==3, CAMERA_ROTATION);\n    return m;\n}\n\n\n// --------------------------------------------------------\n// Modelling \n// --------------------------------------------------------\n\nstruct Material {\n    vec3 albedo;\n};\n\nstruct Model {\n    float dist;\n    Material material;\n};\n\nMaterial defaultMaterial = Material(\n    vec3(.5)\n);  \n\nModel newModel() {\n    return Model(\n        10000.,\n        defaultMaterial\n    );\n}\n\nconst float modelSize = 1.2;\n\nfloat blend(float y, float blend, float progress) {\n    float a = (y / modelSize) + .5;\n    a -= progress * (1. + blend) - blend * .5;\n    a += blend / 2.;\n    a /= blend;\n    a = clamp(a, 0., 1.);\n    a = smoothstep(0., 1., a);\n    a = smoothstep(0., 1., a);\n    return a;\n}\n\nfloat ShapeBlend(float y, float progress) {\n    float shapeProgress = clamp(progress * 2. - .5, 0., 1.);\n    float shapeBlend = blend(y, .8, shapeProgress);\n    return shapeBlend;\n}\n\nfloat SpinBlend(float y, float progress) {\n    return blend(y, 1.5, progress);\n}\n\nfloat Flip() {\n\treturn round(mod(time, 1.));\n}\n\nfloat Progress() {\n    float progress = mod(time*2., 1.);\n    //progress = smoothstep(0., 1., progress);\n    //progress = sin(progress * PI - PI/2.) * .5 + .5;\n    return progress;\n}\n\nModel mainModel(vec3 p) {\n    Model model = newModel();\n    \n\tfloat progress = Progress();\n    float flip = Flip();\n    \n    float spinBlend = SpinBlend(p.y, progress);\n    pR(p.xz, spinBlend * PI / 2.);\n    pR(p.xz, PI * -.5 * flip);\n    \n    float part1 = fDodecahedron(p, modelSize * .5);\n    pR(p.xz, PI/2.);\n    float part2 = fIcosahedron(p, modelSize * .5);\n    \n\tfloat shapeBlend = ShapeBlend(p.y, progress);\n    shapeBlend = mix(shapeBlend, 1. - shapeBlend, flip);    \n    float d = mix(part1, part2, shapeBlend);\n\n    model.dist = d;\n    model.material.albedo = mix(vec3(.03), vec3(.8), 1. - shapeBlend);\n\n    return model;\n}\n\nModel glitchModel(vec3 p) {\n    Model model = newModel();\n    float progress = Progress();\n\tfloat band = ShapeBlend(p.y, progress);\n    band = sin(band * PI);    \n\n   \tfloat fadeBottom = clamp(1. - dot(p, vec3(0,1,0)), 0., 1.);\n    band *= fadeBottom;\n\n    float radius = modelSize / 2. + band * .2;\n    model.dist = length(p) - radius;\n    model.material.albedo = vec3(band);\n    \n    return model;\n}\n\nModel map( vec3 p , bool glitchMask){\n    mat3 m = modelRotation();\n    p *= m;\n    pR(p.xz, -time*PI);\n    if (glitchMask) {\n    \treturn glitchModel(p);\n    }\n    Model model = mainModel(p);\n    return model;\n}\n\n\n// --------------------------------------------------------\n// LIGHTING\n// https://www.shadertoy.com/view/Xds3zN\n// --------------------------------------------------------\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t, false ).dist;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.00001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos, false ).dist;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 doLighting(Material material, vec3 pos, vec3 nor, vec3 ref, vec3 rd) {\n    vec3 lightPos = vec3(0,0,-1);\n    vec3 backLightPos = normalize(vec3(0,-.3,1));\n    vec3 ambientPos = vec3(0,1,0);\n\n    mat3 m = lightRotation();\n    lightPos *= m;\n    backLightPos *= m;\n        \n    float occ = calcAO( pos, nor );\n    vec3  lig = lightPos;\n    float amb = clamp((dot(nor, ambientPos) + 1.) / 2., 0., 1.);\n    float dif = clamp((dot(nor, lig) + 1.) / 3., 0.0, 1.0 );\n    float bac = pow(clamp(dot(nor, backLightPos), 0., 1.), 1.5);\n    float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n    \n    dif *= softshadow( pos, lig, 0.01, 2.5 ) * .5 + .5;\n\n    vec3 lin = vec3(0.0);\n    lin += 1.20*dif*vec3(.95,0.80,0.60);\n    lin += 0.80*amb*vec3(0.50,0.70,.80)*occ;\n    lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n    lin += 0.20*fre*vec3(1.00,1.00,1.00)*occ;\n    vec3 col = material.albedo*lin;\n    \n\tfloat spe = clamp(dot(ref, lightPos), 0., 1.);\n    spe = pow(spe, 2.) * .1;\n    col += spe;\n\n    return col;\n}   \n\n\n// --------------------------------------------------------\n// Ray Marching\n// Adapted from: https://www.shadertoy.com/view/Xl2XWt\n// --------------------------------------------------------\n\nconst float MAX_TRACE_DISTANCE = 30.; // max trace distance\nconst float INTERSECTION_PRECISION = .001; // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 100;\nconst float FUDGE_FACTOR = .9; // Default is 1, reduce to fix overshoots\n\nstruct CastRay {\n    vec3 origin;\n    vec3 direction;\n    bool glitchMask;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n    float len;\n};\n\nstruct Hit {\n    Ray ray;\n    Model model;\n    vec3 pos;\n    bool isBackground;\n    vec3 normal;\n    vec3 color;\n};\n\nvec3 calcNormal( in vec3 pos ){\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy, false).dist - map(pos-eps.xyy, false).dist,\n        map(pos+eps.yxy, false).dist - map(pos-eps.yxy, false).dist,\n        map(pos+eps.yyx, false).dist - map(pos-eps.yyx, false).dist );\n    return normalize(nor);\n}\n    \nHit raymarch(CastRay castRay){\n\n    float currentDist = INTERSECTION_PRECISION * 2.0;\n    Model model;\n    \n    Ray ray = Ray(castRay.origin, castRay.direction, 0.);\n\n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        if (currentDist < INTERSECTION_PRECISION || ray.len > MAX_TRACE_DISTANCE) {\n            break;\n        }\n        model = map(ray.origin + ray.direction * ray.len, castRay.glitchMask);\n        currentDist = model.dist;\n        ray.len += currentDist * FUDGE_FACTOR;\n    }\n    \n    bool isBackground = false;\n    vec3 pos = vec3(0);\n    vec3 normal = vec3(0);\n    vec3 color = vec3(0);\n    \n    if (ray.len > MAX_TRACE_DISTANCE) {\n        isBackground = true;\n    } else {\n        pos = ray.origin + ray.direction * ray.len;\n        normal = calcNormal(pos);\n    }\n\n    return Hit(ray, model, pos, isBackground, normal, color);\n}\n\n\n// --------------------------------------------------------\n// Rendering\n// Refraction from https://www.shadertoy.com/view/lsXGzH\n// --------------------------------------------------------\n\nvoid shadeSurface(inout Hit hit){\n\n    vec3 color = vec3(.25);\n    \n    if (hit.isBackground) {\n        hit.color = color;\n        return;\n    }\n\n    #ifdef NORMALS\n        color = hit.normal * 0.5 + 0.5;\n    #else\n    \tvec3 ref = reflect(hit.ray.direction, hit.normal);\n        color = doLighting(\n            hit.model.material,\n            hit.pos,\n            hit.normal,\n            ref,\n            hit.ray.direction\n        );\n    #endif\n\n    hit.color = color;\n}\n\n\nvec3 render(Hit hit){\n    \n    shadeSurface(hit);\n    \n    if (hit.isBackground) {\n        return hit.color;\n    }\n    \n    return hit.color;\n}\n\n\n// --------------------------------------------------------\n// Camera\n// https://www.shadertoy.com/view/Xl2XWt\n// --------------------------------------------------------\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera(out vec3 camPos, out vec3 camTar, out float camRoll, in float time, in vec2 mouse) {\n    float dist = 3.;\n    camRoll = 0.;\n    camTar = vec3(0,0,0);\n    camPos = vec3(0,0,-dist);\n    camPos *= cameraRotation();\n    camPos += camTar;\n}\n\nHit raymarchPixel(vec2 p, bool glitchPass) {\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    vec3 camPos = vec3( 0., 0., 2.);\n    vec3 camTar = vec3( 0. , 0. , 0. );\n    float camRoll = 0.;\n    \n    // camera movement\n    doCamera(camPos, camTar, camRoll, iTime, m);\n    \n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( camPos, camTar, camRoll );  // 0.0 is the camera roll\n    \n    // create view ray\n    float focalLength = 3.;\n    vec3 rd = normalize( camMat * vec3(p.xy, focalLength) );\n    \n    Hit hit = raymarch(CastRay(camPos, rd, glitchPass));\n    \n    return hit;\n}\n\n\n// --------------------------------------------------------\n// Gamma\n// https://www.shadertoy.com/view/Xds3zN\n// --------------------------------------------------------\n\nconst float GAMMA = 2.2;\n\nvec3 gamma(vec3 color, float g) {\n    return pow(color, vec3(g));\n}\n\nvec3 linearToScreen(vec3 linearRGB) {\n    return gamma(linearRGB, 1.0 / GAMMA);\n}\n\n\n// --------------------------------------------------------\n// Glitch core\n// --------------------------------------------------------\n\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nconst float glitchScale = .5;\n\nvec2 glitchCoord(vec2 p, vec2 gridSize) {\n\tvec2 coord = floor(p / gridSize) * gridSize;;\n    coord += (gridSize / 2.);\n    return coord;\n}\n\n\nstruct GlitchSeed {\n    vec2 seed;\n    float prob;\n};\n    \nfloat fBox2d(vec2 p, vec2 b) {\n  vec2 d = abs(p) - b;\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nGlitchSeed glitchSeed(vec2 p, float speed) {\n    float seedTime = floor(time * speed);\n    vec2 seed = vec2(\n        1. + mod(seedTime / 100., 100.),\n        1. + mod(seedTime, 100.)\n    ) / 100.;\n    seed += p;\n    \n    float prob = 0.;\n    Hit hit = raymarchPixel(p, true);\n    if ( ! hit.isBackground) {\n    \tprob = hit.model.material.albedo.x;\n    }\n    \n    return GlitchSeed(seed, prob);\n}\n\nfloat shouldApply(GlitchSeed seed) {\n    return round(\n        mix(\n            mix(rand(seed.seed), 1., seed.prob - .5),\n            0.,\n            (1. - seed.prob) * .5\n        )\n    );\n}\n\n\n// --------------------------------------------------------\n// Glitch effects\n// --------------------------------------------------------\n\n// Swap\n\nvec4 swapCoords(vec2 seed, vec2 groupSize, vec2 subGrid, vec2 blockSize) {\n    vec2 rand2 = vec2(rand(seed), rand(seed+.1));\n    vec2 range = subGrid - (blockSize - 1.);\n    vec2 coord = floor(rand2 * range) / subGrid;\n    vec2 bottomLeft = coord * groupSize;\n    vec2 realBlockSize = (groupSize / subGrid) * blockSize;\n    vec2 topRight = bottomLeft + realBlockSize;\n    topRight -= groupSize / 2.;\n    bottomLeft -= groupSize / 2.;\n    return vec4(bottomLeft, topRight);\n}\n\nfloat isInBlock(vec2 pos, vec4 block) {\n    vec2 a = sign(pos - block.xy);\n    vec2 b = sign(block.zw - pos);\n    return min(sign(a.x + a.y + b.x + b.y - 3.), 0.);\n}\n\nvec2 moveDiff(vec2 pos, vec4 swapA, vec4 swapB) {\n    vec2 diff = swapB.xy - swapA.xy;\n    return diff * isInBlock(pos, swapA);\n}\n\nvoid swapBlocks(inout vec2 xy, vec2 groupSize, vec2 subGrid, vec2 blockSize, vec2 seed, float apply) {\n    \n    vec2 groupOffset = glitchCoord(xy, groupSize);\n    vec2 pos = xy - groupOffset;\n    \n    vec2 seedA = seed * groupOffset;\n    vec2 seedB = seed * (groupOffset + .1);\n    \n    vec4 swapA = swapCoords(seedA, groupSize, subGrid, blockSize);\n    vec4 swapB = swapCoords(seedB, groupSize, subGrid, blockSize);\n    \n    vec2 newPos = pos;\n    newPos += moveDiff(pos, swapA, swapB) * apply;\n    newPos += moveDiff(pos, swapB, swapA) * apply;\n    pos = newPos;\n    \n    xy = pos + groupOffset;\n}\n\n\n// Static\n\nvoid staticNoise(inout vec2 p, vec2 groupSize, float grainSize, float contrast) {\n    GlitchSeed seedA = glitchSeed(glitchCoord(p, groupSize), 5.);\n    seedA.prob *= .5;\n    if (shouldApply(seedA) == 1.) {\n        GlitchSeed seedB = glitchSeed(glitchCoord(p, vec2(grainSize)), 5.);\n        vec2 offset = vec2(rand(seedB.seed), rand(seedB.seed + .1));\n        offset = round(offset * 2. - 1.);\n        offset *= contrast;\n        p += offset;\n    }\n}\n\n\n// Freeze time\n\nvoid freezeTime(vec2 p, inout float time, vec2 groupSize, float speed) {\n    GlitchSeed seed = glitchSeed(glitchCoord(p, groupSize), speed);\n    //seed.prob *= .5;\n    if (shouldApply(seed) == 1.) {\n        float frozenTime = floor(time * speed) / speed;\n        time = frozenTime;\n    }\n}\n\n\n// --------------------------------------------------------\n// Glitch compositions\n// --------------------------------------------------------\n\nvoid glitchSwap(inout vec2 p) {\n\n    vec2 pp = p;\n    \n    float scale = glitchScale;\n    float speed = 5.;\n    \n    vec2 groupSize;\n    vec2 subGrid;\n    vec2 blockSize;    \n    GlitchSeed seed;\n    float apply;\n    \n    groupSize = vec2(.6) * scale;\n    subGrid = vec2(2);\n    blockSize = vec2(1);\n\n    seed = glitchSeed(glitchCoord(p, groupSize), speed);\n    apply = shouldApply(seed);\n    swapBlocks(p, groupSize, subGrid, blockSize, seed.seed, apply);\n    \n    groupSize = vec2(.8) * scale;\n    subGrid = vec2(3);\n    blockSize = vec2(1);\n    \n    seed = glitchSeed(glitchCoord(p, groupSize), speed);\n    apply = shouldApply(seed);\n    swapBlocks(p, groupSize, subGrid, blockSize, seed.seed, apply);\n\n    groupSize = vec2(.2) * scale;\n    subGrid = vec2(6);\n    blockSize = vec2(1);\n    \n    seed = glitchSeed(glitchCoord(p, groupSize), speed);\n    float apply2 = shouldApply(seed);\n    swapBlocks(p, groupSize, subGrid, blockSize, (seed.seed + 1.), apply * apply2);\n    swapBlocks(p, groupSize, subGrid, blockSize, (seed.seed + 2.), apply * apply2);\n    swapBlocks(p, groupSize, subGrid, blockSize, (seed.seed + 3.), apply * apply2);\n    swapBlocks(p, groupSize, subGrid, blockSize, (seed.seed + 4.), apply * apply2);\n    swapBlocks(p, groupSize, subGrid, blockSize, (seed.seed + 5.), apply * apply2);\n    \n    groupSize = vec2(1.2, .2) * scale;\n    subGrid = vec2(9,2);\n    blockSize = vec2(3,1);\n    \n    seed = glitchSeed(glitchCoord(p, groupSize), speed);\n    apply = shouldApply(seed);\n    swapBlocks(p, groupSize, subGrid, blockSize, seed.seed, apply);\n}\n\n\n\nvoid glitchStatic(inout vec2 p) {\n\n    // Static\n    //staticNoise(p, vec2(.25, .25/2.) * glitchScale, .005, 5.);\n    \n    // 8-bit\n    staticNoise(p, vec2(.5, .25/2.) * glitchScale, .2 * glitchScale, 2.);\n}\n\nvoid glitchTime(vec2 p, inout float time) {\n   freezeTime(p, time, vec2(.5) * glitchScale, 2.);\n}\n\nvoid glitchColor(vec2 p, inout vec3 color) {\n    vec2 groupSize = vec2(.75,.125) * glitchScale;\n    vec2 subGrid = vec2(0,6);\n    float speed = 5.;\n    GlitchSeed seed = glitchSeed(glitchCoord(p, groupSize), speed);\n    seed.prob *= .3;\n    if (shouldApply(seed) == 1.) {\n        vec2 co = mod(p, groupSize) / groupSize;\n        co *= subGrid;\n        float a = max(co.x, co.y);\n        //color.rgb *= vec3(\n        //  min(floor(mod(a - 0., 3.)), 1.),\n        //    min(floor(mod(a - 1., 3.)), 1.),\n        //    min(floor(mod(a - 2., 3.)), 1.)\n        //);\n        \n        color *= min(floor(mod(a, 2.)), 1.) * 10.;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime;\n    time /= 8.;\n    time = mod(time, 1.);\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    \n    vec3 color;\n    \n    #ifdef GLITCH_MASK\n    \tfloat prob = glitchSeed(p, 10.).prob;\n    \tcolor = vec3(prob);\n   \t#else\n\n        #ifndef NO_GLITCH\n            glitchSwap(p);\n            glitchTime(p, time);\n            glitchStatic(p);\n        #endif\n\n        Hit hit = raymarchPixel(p, false);\n        color = render(hit);\n\n        #ifndef NO_GLITCH\n            glitchColor(p, color);\n        #endif\n    \n        #ifndef NORMALS\n           color = linearToScreen(color);\n        #endif\n\n    #endif\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tcfWf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tdBWf", "name": "Androids Love Penguins", "author": "dr2", "description": "Why do androids love penguins?", "tags": ["projection", "linux", "snow", "android", "penguin"], "likes": 12, "viewed": 468, "date": "1541360492", "time_retrieved": "2024-06-20T19:23:57.827942", "image_code": "// \"Androids Love Penguins\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Why do androids love penguins? (mouseable)\n\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat PrEllipsDf (vec3 p, vec3 r);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv2 (vec2 p);\nvec3 Noisev3v2 (vec2 p);\nfloat Fbm2s (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define N_PENG 3\n\nmat3 pngMat[N_PENG], pMat;\nvec3 pngPos[N_PENG], pPos, qHit, sunDir, trkA, trkF, rmSize;\nvec2 scrnSize;\nfloat dstFar, tCur, fAng, rAngA, scrnUp;\nint idObj;\nbool doSh;\nconst float pi = 3.14159;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nvec3 TrackPath (float t)\n{\n  return vec3 (dot (trkA, sin (trkF * t)), 0.5 * cos (0.007 * t) * cos (0.01 * t), t);\n}\n\nvec3 TrackDir (float t)\n{\n  return vec3 (dot (trkF * trkA, cos (trkF * t)), 0., 1.);\n}\n\nvec3 TrackAcc (float t)\n{\n  return vec3 (dot (trkF * trkF * trkA, - sin (trkF * t)), 0., 0.);\n}\n\nfloat GrndHt (vec2 p)\n{\n  float w;\n  w = p.x - TrackPath (p.y).x;\n  return SmoothMin (8. * Fbm2s (0.05 * p), 0.1 * w * w - 0.5, 0.5) + Fbm2s (0.1 * p);\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = 0; j < 220; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz);\n    if (h < 0. || s > dstFar) break;\n    sLo = s;\n    s += max (0.01 * s, 0.4 * h);\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = 0; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (p.y > GrndHt (p.xz)) sLo = s;\n      else sHi = s;\n    }\n    dHit = 0.5 * (sLo + sHi);\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec2 e = vec2 (0.01, 0.);\n  return normalize (vec3 (GrndHt (p.xz) - vec2 (GrndHt (p.xz + e.xy),\n     GrndHt (p.xz + e.yx)), e.x).xzy);\n}\n\nfloat PengDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, dh;\n  p.xz *= -1.;\n  q = p;\n  d = PrEllipsDf (q.xzy, vec3 (1.3, 1.2, 1.4));\n  q.y -= 1.5;\n  dh = PrEllipsDf (q.xzy, vec3 (0.8, 0.6, 1.3));\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.3, 2., -0.4);\n  d = SmoothMin (d, max (dh, - PrCylDf (q, 0.15, 0.3)), 0.2);\n  DMINQ (1);\n  q = p;\n  q.yz -= vec2 (1.6, -0.6);\n  d = max (PrEllipsDf (q, vec3 (0.4, 0.2, 0.6)), 0.01 - abs (q.y));\n  DMINQ (2);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.3, 2., -0.4);\n  d = PrSphDf (q, 0.15);\n  DMINQ (3);\n  q = p;\n  q.x = abs (q.x);\n  q.xy -= vec2 (0.6, -1.05);\n  q.yz = Rot2D (q.yz, -0.5 * pi);\n  q.y -= -0.6;\n  d = PrCylDf (q.xzy, 0.12, 0.7);\n  DMINQ (4);\n  q -= vec3 (0.1, -0.67, -0.4);\n  q.xz = Rot2D (q.xz, -0.07 * pi);\n  d = PrEllipsDf (q.xzy, vec3 (0.15, 0.5, 0.05));\n  q.z -= 0.5;\n  q.xz = Rot2D (q.xz, 0.15 * pi);\n  q.z -= -0.5;\n  d = SmoothMin (d, PrEllipsDf (q.xzy, vec3 (0.15, 0.5, 0.05)), 0.05);\n  q.z -= 0.5;\n  q.xz = Rot2D (q.xz, -0.3 * pi);\n  q.z -= -0.5;\n  d = SmoothMin (d, PrEllipsDf (q.xzy, vec3 (0.15, 0.5, 0.05)), 0.05);\n  DMINQ (5);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (1.1, 0.3, -0.2);\n  q.yz = Rot2D (q.yz, -0.25 * pi);\n  q.xy = Rot2D (q.xy, fAng) - vec2 (0.1, -0.4);\n  d = PrEllipsDf (q.xzy, vec3 (0.05, 0.25, 0.9));\n  DMINQ (6);\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float d, dMin;\n  dMin = dstFar;\n  for (int j = 0; j < N_PENG; j ++) {\n    q = p - pngPos[j];\n    d = PrSphDf (q, 3.);\n    if (doSh || d < 0.1) dMin = PengDf (pngMat[j] * q, dMin);\n    else dMin = min (dMin, d);\n  }\n  q = p;\n  q.x -= TrackPath (p.z).x;\n  q.y -= 2.;\n  q.z = mod (q.z + 20., 40.) - 20.;\n  d = 0.8 * PrTorusDf (q, 0.3, 7.);\n  DMINQ (7);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 160; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0005, -0.0005);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat GrndSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float sh, d, h;\n  doSh = true;\n  sh = 1.;\n  d = 0.05;\n  for (int j = 0; j < 30; j ++) {\n    p = ro + d * rd;\n    h = p.y - GrndHt (p.xz);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  for (int j = 0; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float f;\n  rd.y = abs (rd.y) + 0.0001;\n  ro.xz += 0.5 * tCur;\n  f = Fbm2s (0.02 * (rd.xz * (100. - ro.y) / rd.y + ro.xz));\n  col = vec3 (0.1, 0.2, 0.4);\n  col = mix (col, vec3 (0.8), clamp (3. * (f - 0.5) * rd.y + 0.1, 0., 1.));\n  return col;\n}\n\nvoid PengPM (float s, float dir)\n{\n  vec3 vel, va, acc, ort, cr, sr;\n  pPos = TrackPath (s);\n  vel = TrackDir (s);\n  acc = TrackAcc (s);\n  pPos.x -= 50. * acc.x;\n  va = cross (acc, vel) / length (vel);\n  ort = vec3 (-0.1 * dir, atan (vel.z, vel.x) - 0.5 * dir * pi,\n     12. * dir * length (va) * sign (va.y));\n  cr = cos (ort);\n  sr = sin (ort);\n  pMat = mat3 (cr.z, - sr.z, 0., sr.z, cr.z, 0., 0., 0., 1.) *\n         mat3 (1., 0., 0., 0., cr.x, - sr.x, 0., sr.x, cr.x) *\n         mat3 (cr.y, 0., - sr.y, 0., 1., 0., sr.y, 0., cr.y);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, vns;\n  float dstGrnd, dstObj, gg, dx, sh;\n  doSh = false;\n  dstGrnd = GrndRay (ro, rd);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstGrnd) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj != 3) {\n      if (idObj == 1) col4 = (qHit.z < -0.2 || qHit.z > 0.4 && abs (qHit.x) < 0.04 ||\n         qHit.z < 0.4 && length (qHit.xy) < 0.2) ? vec4 (0.9, 0.9, 0.9, 0.1) :\n         vec4 (0.15, 0.15, 0.2, 0.1);\n      else if (idObj == 2) col4 = vec4 (1., 0.8, 0.2, 0.2);\n      else if (idObj == 4) col4 = vec4 (0.8, 0.8, 0., 0.2);\n      else if (idObj == 5) col4 = vec4 (0.9, 0.9, 0., 0.2);\n      else if (idObj == 6) col4 = vec4 (0.2, 0.2, 0.25, 0.1);\n      else if (idObj == 7) col4 = vec4 (0.3, 0.4, 0.7, 0.2);\n      sh = ObjSShadow (ro, sunDir);\n      col = col4.rgb * (0.2 + 0.1 * max (- dot (vn.xz, normalize (sunDir.xz)), 0.) +\n         0.7 * sh * max (dot (vn, sunDir), 0.)) +\n         sh * col4.a * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n    } else col = SkyCol (ro, reflect (rd, vn));\n  } else if (dstGrnd < dstFar) {\n    ro += dstGrnd * rd;\n    vn = GrndNf (ro);\n    gg = smoothstep (0.6, 0.9, vn.y);\n    vn = VaryNf (4. * ro, vn, 0.5);\n    vns = normalize (Noisev3v2 (128. * ro.xz) - 0.5);\n    vns.y = abs (vns.y);\n    dx = abs (ro.x - TrackPath (ro.z).x);\n    col = vec3 (1.) * mix (1.1, 1., gg) * (0.7 +\n       0.3 * mix (Noisefv2 (vec2 (16. * dx, 0.5 * ro.z)), 1., smoothstep (0., 2., dx)));\n    sh = min (GrndSShadow (ro, sunDir), ObjSShadow (ro, sunDir));\n    col = col * (0.2 + 0.1 * max (- dot (vn.xz, normalize (sunDir.xz)), 0.) +\n       0.7 * sh * max (dot (vn, sunDir), 0.)) +\n       0.3 * sh * gg * smoothstep (0.3, 0.5, dot (vn, sunDir)) *\n       pow (max (dot (normalize (sunDir - rd), vns), 0.), 8.);\n  } else col = SkyCol (ro, rd);\n  return pow (clamp (col, 0., 1.), vec3 (0.9));\n}\n\nfloat RobDf (vec3 p)\n{\n  vec3 q;\n  float d, szFac;\n  szFac = 0.8;\n  p /= szFac;\n  p.y -= -1.2;\n  q = p;\n  q.y -= 2.3;\n  d = max (PrSphDf (q, 0.85), - q.y - 0.2);\n  q = p;\n  q.y -= 1.5;\n  d = min (d, PrRoundCylDf (q.xzy, 0.9, 0.28, 0.75));\n  q = p;\n  q.x = abs (q.x) - 1.05;\n  q.y -= 2.;\n  q.yz = Rot2D (q.yz, rAngA);\n  q.y -= -0.5;\n  d = min (d, PrRoundCylDf (q.xzy, 0.2, 0.15, 0.6));\n  q = p;\n  q.x = abs (q.x) - 0.3;\n  q.y -= 3.1;\n  q.xy = Rot2D (q.xy, 0.2 * pi);\n  q.y -= 0.25;\n  d = min (d, PrRoundCylDf (q.xzy, 0.06, 0.04, 0.3));\n  q = p;\n  q.x = abs (q.x) - 0.4;\n  q.y -= 0.3;\n  d = min (d, PrRoundCylDf (q.xzy, 0.25, 0.15, 0.65));\n  q = p;\n  q.x = abs (q.x) - 0.4;\n  q.yz -= vec2 (2.7, 0.7);\n  d = min (d, PrSphDf (q, 0.15));\n  return szFac * d;\n}\n\nfloat ObjDfTh (vec3 p)\n{\n  vec3 q;\n  float d, dMin, bf;\n  dMin = dstFar;\n  d = p.y;\n  DMIN (10);\n  d = 2. * rmSize.y - p.y;\n  DMIN (11);\n  d = rmSize.x - abs (p.x);\n  DMIN (12);\n  d = p.z + rmSize.z;\n  DMIN (13);\n  d = - p.z + rmSize.z;\n  DMIN (14);\n  bf = PrBox2Df (p.xz - vec2 (0., -1.), vec2 (7.5, 6.));\n  q = p;\n  q.xz = mod (q.xz + 1.5, 3.) - 1.5;\n  q.y -= 0.25 * rmSize.y;\n  d = max (bf, RobDf (q));\n  DMIN (15);\n  return dMin;\n}\n\nfloat ObjRayTh (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = ObjDfTh (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNfTh (vec3 p)\n{\n  const vec2 e = vec2 (0.0005, -0.0005);\n  vec4 v = vec4 (ObjDfTh (p + e.xxx), ObjDfTh (p + e.xyy),\n     ObjDfTh (p + e.yxy), ObjDfTh (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec3 BrickCol (vec2 p)\n{\n  vec2 q, iq;\n  q = p * vec2 (1./62., 1./31.);\n  iq = floor (q);\n  if (2. * floor (iq.y / 2.) != iq.y) q.x += 0.5;\n  q = smoothstep (0.02, 0.05, abs (fract (q + 0.5) - 0.5));\n  return (0.7 + 0.3 * q.x * q.y) * vec3 (0.6, 0.55, 0.5);\n}\n\nvec3 ObjColTh (vec3 p)\n{\n  vec3 col;\n  if (idObj == 10) col = vec3 (0.2, 0.15, 0.1);\n  else if (idObj == 11) col = vec3 (0.8, 0.8, 0.9);\n  else if (idObj == 12) col = BrickCol (40. * p.zy);\n  else if (idObj == 13) col = BrickCol (40. * p.xy);\n  else if (idObj == 15) col = vec3 (0.8, 1., 0.8);\n  return col;\n}\n\nvec3 ScrnCol (vec2 w)\n{\n  vec3 ro, rd;\n  float spd;\n  trkA = 5. * vec3 (1.9, 2.9, 4.3);\n  trkF = 0.18 * vec3 (0.23, 0.17, 0.13);\n  spd = 10.;\n  for (int j = 0; j < N_PENG; j ++) {\n    PengPM (spd * tCur + 15. * float (j + 1), 1.);\n    pPos.y = GrndHt (pPos.xz) + 1.35;\n    pPos.y += max (0., 0.5 * cos (0.13 * pPos.z) * cos (0.2 * pPos.z));\n    pngPos[j] = pPos;\n    pngMat[j] = pMat;\n  }\n  if (mod (0.1 * tCur, 2.) > 1.2) PengPM (spd * tCur, 1.);\n  else PengPM (spd * tCur + 15. * float (N_PENG + 1), -1.);\n  ro = pPos;\n  ro.y += 3.;\n  rd = normalize (vec3 (w / scrnSize.y, 2.2)) * pMat;\n  fAng = -0.2 * pi + 0.1 * pi * SmoothBump (0.25, 0.75, 0.1, mod (0.125 * tCur, 1.)) *\n     sin (16. * pi * tCur);\n  sunDir = normalize (vec3 (0., 1.5, 1.));\n  sunDir.xz = Rot2D (sunDir.xz, 0.3 * pi * sin (0.1 * tCur));\n  dstFar = 250.;\n  return ShowScene (ro, rd);\n}\n\nvec3 ShowSceneTh (vec3 ro, vec3 rd)\n{\n  vec3 col, vn, vd, ltDir, scrCol, refFac;\n  vec2 w;\n  float dHit, tCyc;\n  int idObjT;\n  bool isScrn;\n  tCyc = mod (0.25 * tCur, 2.);\n  rAngA = (abs (tCyc - 1.) < 0.5) ? 0.: 2. * pi * (0.5 - abs (mod (2. * (tCyc - 0.5), 1.) - 0.5)); \n  dHit = ObjRayTh (ro, rd);\n  ro += dHit * rd;\n  vn = ObjNfTh (ro);\n  col = vec3 (0.);\n  refFac = vec3 (1.);\n  if (idObj == 15) {\n    refFac = 0.8 * vec3 (0.8, 0.9, 0.8);\n    for (int j = 0; j < 2; j ++) {\n      rd = reflect (rd, vn);\n      ro += 0.01 * rd;\n      dHit = ObjRayTh (ro, rd);\n      ro += dHit * rd;\n      if (idObj != 15) break;\n      refFac *= 0.8 * vec3 (0.8, 0.9, 0.8);\n    }\n  }\n  vn = ObjNfTh (ro);\n  isScrn = false;\n  col = vec3 (0.);\n  scrCol = vec3 (0.);\n  idObjT = idObj;\n  if (idObjT == 14) {\n    w = ro.xy;\n    w.y -= rmSize.y + scrnUp;\n  } else {\n    col = ObjColTh (ro);\n    if (idObjT != 10) {\n      vd = normalize (vec3 (0., 1., 3.5) * rmSize - ro);\n      if (vd.z != 0.) ro += vd * (rmSize.z - ro.z) / vd.z;\n      ro.y -= rmSize.y + scrnUp;\n      w = ro.xy;\n    }\n  }\n  if (idObjT != 10) isScrn = (abs (w.x) < scrnSize.x && abs (w.y) < scrnSize.y);\n  if (isScrn) scrCol = ScrnCol (w);\n  col = (idObjT == 14) ? scrCol: 0.2 * col * (1. + 0.4 * scrCol * (1. + max (dot (vn,\n     normalize (vec3 (0., scrnUp, rmSize.z))), 0.)));\n  return clamp (refFac * col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float az, el;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 2. * pi * max (0.9 - abs (mod (0.011 * tCur, 2.) - 1.), 0.) / 0.9;\n  el = 0.1 * (cos (2. * az) - 1.);\n  if (mPtr.z > 0.) {\n    el -= 0.3 * pi * mPtr.y;\n    az -= 2. * pi * mPtr.x;\n  }\n  el = clamp (el, -0.07 * pi, 0.07 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  tCur = mod (tCur, 600.) - 300.;\n  rmSize = vec3 (12., 5., 12.);\n  scrnUp = 0.15 * rmSize.y;\n  scrnSize = vec2 (0.95, 0.8) * rmSize.xy;\n  ro = vuMat * vec3 (0., rmSize.y, -0.99 * rmSize.z);\n  ro.xz = clamp (ro.xz, - 0.98 * rmSize.xz, 0.98 * rmSize.xz);\n  ro.y = clamp (ro.y - 0.2 * rmSize.y, 0.02 * rmSize.y, 1.98 * rmSize.y);\n  rd = vuMat * normalize (vec3 (uv, 3.));\n  dstFar = 150.;\n  fragColor = vec4 (ShowSceneTh (ro, rd), 1.);\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  float dxy, dz;\n  dxy = length (p.xy) - r;\n  dz = abs (p.z) - h;\n  return min (min (max (dxy + rt, dz), max (dxy, dz + rt)), length (vec2 (dxy, dz) + rt) - rt);\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + vec4 (0., 1., 57., 58.)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nvec3 Noisev3v2 (vec2 p)\n{\n  vec4 h;\n  vec3 g;\n  vec2 ip, fp, ffp;\n  ip = floor (p);\n  fp = fract (p);\n  ffp = fp * fp * (3. - 2. * fp);\n  h = Hashv4f (dot (ip, vec2 (1., 57.)));\n  g = vec3 (h.y - h.x, h.z - h.x, h.x - h.y - h.z + h.w);\n  return vec3 (h.x + dot (g.xy, ffp) + g.z * ffp.x * ffp.y,\n     30. * fp * fp * (fp * fp - 2. * fp + 1.) * (g.xy + g.z * ffp.yx));\n}\n\nfloat Fbm2s (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.75);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tdBWf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tdfDX", "name": "Arcade Racetrack Thing", "author": "scratch13764", "description": "I'm not sure what I'm doing here. It actually didn't turn out that bad...?\nNever mind it did.\nIt's a really cheap way to draw a fake 3D environment, I guess.\n", "tags": ["2d", "race"], "likes": 5, "viewed": 227, "date": "1541356594", "time_retrieved": "2024-06-20T19:23:58.058145", "image_code": "#define SPEED .5 + (iTime/10.)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord - .5*iResolution.xy ) / iResolution.y;\n    uv.y += .65; //Thanks @FabriceNeyret2\n    \n    \n    float LIGHT_STRIP = 0.; //Calculates the stripes of light and dark that show depth in some early racing games\n    \n    float TURN = sin(iTime/2.);\n    uv.x -= uv.y*uv.y/5.0*TURN;\n    \n    if (abs(round((uv.y*uv.y*uv.y+(iTime*SPEED))*10.)/10. - (uv.y*uv.y*uv.y+(iTime*SPEED))) < 0.025)\n    {\n        LIGHT_STRIP = 0.1;\n    }\n    \n    vec3 COL;\n    if (abs(uv.x)-0.6 > .5-(uv.y/1.2))\n    {\n        COL = vec3(0.1,0.9,0.1);\n    }\n    else if (abs(uv.x)-0.5 > .5-(uv.y/1.3))\n    {\n        if (LIGHT_STRIP == 0.) COL = vec3 (0.9);\n        else COL = vec3 (0.9,0.1,0.1);\n        LIGHT_STRIP = 0.0; //We don't need the stripes if we're drawing the checker things\n    }\n    \n    COL += LIGHT_STRIP;\n    COL += (uv.y-.5)/5.; //Distance fog\n    COL = smoothstep(1.05,1.04,uv.y)*COL + (smoothstep(1.04,1.05,uv.y)*vec3(.6,.6,1.));\n\n    fragColor = vec4(COL,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tdfDX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tGBR1", "name": "Trippy Cosmic Force of Mu 2 ", "author": "pelleman", "description": "Tweaked Cosmic Force of Mu 2 into something more up-tempo.", "tags": ["trippy", "hypnotizing", "psy", "energy"], "likes": 6, "viewed": 164, "date": "1541709202", "time_retrieved": "2024-06-20T19:23:58.603427", "image_code": "// A Trippy/Psytrance version of https://www.shadertoy.com/view/MtKfzz by beervgeer.\n// Best viewed in fullscreen with loudspeakers on high volume :-).\n\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n#define time iTime\n#define resolution iResolution.xy\n#define size 0.0240525\n#define lineSize 0.24540144\n#define blur 0.227794\n#define grid 9.510933\n#define morph 5.2208757\n#define delayAmount 3.223359\n#define delay2 6.429779\n#define speed 0.39144516\n\n\nfloat impulse( float k, float x )\n{\n    float h = k*x;\n    return h*exp(1.0-h);\n}\n\nfloat plot(float dis){\n   float pct = smoothstep(dis,dis+blur,0.5)-smoothstep(lineSize+dis,lineSize+dis+blur,0.5);     \n  return   pct ;\n}\n\n\nvec3 rgb2hsb( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                d / (q.x + e),\n                q.x);\n}\n\n//  Function from I√±igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     vec2 res = vec2(0);\n    res.x = resolution.x*0.5625;\n    res.y = resolution.y;\n    \n   vec2 st = gl_FragCoord.xy/res;\n st.x -= 0.35;\n  float d = 0.0;\n\n  // Remap the space to -1. to 1.\n  st = st *2.-1.;\n  \n  // Number of sides of your shape\n  int N = 4;\n\n  // Angle and radius from the current pixel\n  vec3 colorNew = vec3(0);\n  \n  for(int i=0;i<5;i++) {\n      \n      float m = (float(i)/5.);\n      st.y += size*m*sin(time/3.);\n      float a = atan(st.x,st.y)+PI+(morph*m) + (0.03*m * sin(time));\n      float r = TWO_PI/float(N);\n      \n      d = cos(floor(.5+a/r)*r-a )*length(st)*abs(cos(time/r-a)*sin(time*0.1));\n      d = impulse(d,delayAmount);\n      vec3 color = vec3(0.0);\n      float check = delay2 * (1.-length(st));\n      color.r = plot(fract(d*grid - check + time*speed));\n      color.g = plot(fract(d*grid - check + time*speed*0.8));\n      color.b = plot(fract(d*grid - check + time*speed*0.6));\n      colorNew+= ( color*m );\n    }\n    \n    \n \n   vec3 hue = rgb2hsb(colorNew);\n    hue.x = 0.6;\n    hue.y = 0.5;\n    hue.y = 0.5;\n    fragColor = vec4( hsb2rgb(hue)-colorNew*0.2 ,1.);\n\n  \n}", "image_inputs": [{"id": "XdfGzn", "previewfilepath": "/media/ap/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tGBR1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tGfRy", "name": "ÂÖâÁ∫øËøΩË∏™RayTrace", "author": "lingel", "description": "ÂÆûÊó∂ÂèçÂ∞ÑÂÖâÁ∫øËøΩË∏™", "tags": ["raytrace"], "likes": 2, "viewed": 150, "date": "1542877212", "time_retrieved": "2024-06-20T19:23:59.931036", "image_code": "//Author:3977270@qq.com\n//‰ΩøÁî®Â∑¶ÊâãÂùêÊ†áÁ≥ªÔºåÂè≥Ëæπx,‰∏äËæπyÔºåÂâçÊñπz\n\n/////////////////////////////////////////////////////////////////////\n//////////// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\n//ÈöèÊú∫\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n// Compound versions of the hashing algorithm I whipped together.\nuint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\nuint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\nuint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\n// Pseudo-random value in half-open range [0:1].\nfloat random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }\nfloat random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n\n/////////////////////////////////////////////////////////////////////////////\n////////////////////////////////Áü©Èòµ\n//Áü©Èòµ\nmat4 identMat=mat4(\n    1.0,0.0,0.0,0.0,\n    0.0,1.0,0.0,0.0,\n    0.0,0.0,1.0,0.0,\n    0.0,0.0,0.0,1.0\n);\n//XËΩ¥ÊóãËΩ¨\nmat4 rotatX(float Angle)\n{\n    float rs=radians(Angle);\n    mat4 temp=mat4(\n    1.0,    0.0,        0.0,        0.0,\n    0.0,    cos(rs),    -sin(rs),   0.0,\n    0.0,    sin(rs),    cos(rs),    0.0,\n    0.0,    0.0,        0.0,        1.0\n);\nreturn transpose(temp);\n}\n//YËΩ¥ÊóãËΩ¨\nmat4 rotatY(float Angle)\n{\n    float rs=radians(Angle);\n    mat4 temp=mat4(\n    cos(rs),    0.0,    sin(rs),   0.0, \n    0.0,        1.0,    0.0,       0.0, \n    -sin(rs),   0.0,   cos(rs),    0.0, \n    0.0,        0.0,    0.0,       1.0  \n);\nreturn transpose(temp);\n}\n\n//ZËΩ¥ÊóãËΩ¨\nmat4 rotatZ(float Angle)\n{\n    float rs=radians(Angle);\n    mat4 temp=mat4(\n    cos(rs),    -sin(rs),   0.0,    0.0,\n    sin(rs),    cos(rs),    0.0,    0.0,\n    0.0,        0.0,        1.0,    0.0,\n    0.0,        0.0,        0.0,    1.0\n);\nreturn transpose(temp);\n}\n//‰∏âËΩ¥ÊóãËΩ¨\nmat4 rotat(vec3 r)\n{\nreturn rotatX(r.x)*rotatY(r.y)*rotatZ(r.z);\n//return rotatZ(r.z)*rotatY(r.y)*rotatX(r.x);\n}\n//‰ΩçÁßªÁü©Èòµ\nmat4 translate(vec3 v)\n{\n    mat4 temp=identMat;\n    temp[3][0]=v.x;\n    temp[3][1]=v.y;\n    temp[3][2]=v.z;\n    return temp;\n}\n\n\n\n///////////////////////////////////////////////////////////////////////////\n//Â∞ÑÁ∫ø\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n//ÊùêË¥®\nstruct Material\n{\n    vec4 BaseColor;\n};\n//Ê£ÄÊµãÁªìÊûú\nstruct HitResult\n{\n    float t;\n    vec3 worldNormal;\n    Material material;\n};\n\n//ÁêÉ‰ΩìÊ£ÄÊµãÂáΩÊï∞\nstruct Sphere\n{\n    float radius;\n    vec3 center;\n    Material material;\n};\n//Áõ∏Êú∫\nstruct Camera\n{\nfloat FOV;\nfloat focusDistance;\n};\n//ÁêÉ‰ΩìÂ∞ÑÁ∫øÊ£ÄÊµã\nbool trace(in Ray r,in Sphere sp,out HitResult res){\n    //Â∞ÑÁ∫øÂéüÁÇπÂà∞ÁêÉÂøÉÂêëÈáè\n    vec3 oc=sp.center-r.origin;\n    //Â∞ÜÂéüÁÇπÂà∞ÁêÉÂøÉÂêëÈáèÊäïÂΩ±Âà∞Â∞ÑÁ∫øÊñπÂêëÊ±ÇÈïøÂ∫¶\n    float l=dot(r.direction,oc);\n    //Â∞ÑÁ∫øÂéüÁÇπÂà∞ÁêÉÂøÉÁöÑÂπ≥ÊñπË∑ùÁ¶ª\n    float d=dot(oc,oc);\n    //‰∏§‰∏™Áõ¥Ëßí‰∏âËßíÂΩ¢Âπ≥ÊñπÂ∑Æ„ÄÇÂÖ∂ÂÄº‰∏∫‰∏ÄÊù°Áõ¥ËßíËæπÁöÑÂπ≥Êñπ\n    float det=pow(sp.radius,2.0)-(d-pow(l,2.0));//Âπ≥ÊñπÂ∑Æ\n    if(det<0.0) return false;//Êó†Ëß£\n    res.t=l-sqrt(det);//ÊúÄËøëÁÇπÈïøÂ∫¶\n    if (res.t<0.0) res.t=l+sqrt(det);//ÊúÄËøëÁÇπÂú®Áõ∏ÂèçÊñπÂêë\n    if(res.t<0.0) return false;\n    //Êª°Ë∂≥Êù°‰ª∂ÔºåÂ°´ÂÖÖÊ£ÄÊµãÁªìÊûú\n    res.worldNormal=normalize(r.origin+r.direction*res.t-sp.center);\n    res.material=sp.material;\n    return true;\n}\n//Âª∫Á´ãÂú∫ÊôØ\nconst int count=5;\nSphere sps[5];\nCamera ca=Camera(60.0,1.0);\nvec3 cameraLocation;\nvec3 cameraRotation;\nvoid createSence(){\n    //4‰∏™ÁêÉ‰Ωì\n    sps[0]=Sphere(3.f,vec3(0.0-sin(iTime)*20.0,3.0,-5.0),Material(vec4(1.0,0.1,0.1,1.0)));//Á∫¢ÁêÉ\n    sps[1]=Sphere(3.f,vec3(5.0,3.0+sin(iTime)*10.0+10.0,0.0),Material(vec4(0.1,1.0,0.1,1.0)));//ÁªøÁêÉ\n    sps[2]=Sphere(3.f,vec3(-5.0+sin(iTime)*10.0+10.0,3.0,0.0),Material(vec4(0.1,0.1,1.0,1.0)));//ËìùÁêÉ\n    sps[3]=Sphere(10.f,vec3(0.0,10.0,10.0),Material(vec4(1.0,1.0,1.0,1.0)));//ÈªÑÁêÉ\n    sps[4]=Sphere(5000.f,vec3(0.0,-5000.0,10.0),Material(vec4(1.0,1.0,1.0,1.0)*0.8));\n    cameraLocation=vec3(0.0,20.0,-30.0);//Áõ∏Êú∫‰ΩçÁΩÆ\n    cameraRotation=vec3(20.0,0.0,0.0);//Áõ∏Êú∫ÊóãËΩ¨\n}\n/////ËøΩË∏™Âú∫ÊôØÂÜÖÁöÑÁâ©‰Ωì\nbool traceSence(in Ray r,out HitResult res)\n{   \n    bool re=false;\n    float maxDistance=9e10;//ÊúÄÂ§ßÂÖâÁ∫øËøΩË∏™Ê∑±Â∫¶\n    for(int i=0;i<count;i++)\n    {\n        HitResult tempRes;\n        if(trace(r,sps[i],tempRes))\n        {\n            if(tempRes.t<maxDistance)\n            {\n                re=true;\n                res=tempRes;\n                maxDistance=tempRes.t;\n            }\n        }\n    }\n    return re;\n}\n//////ÂèñÂæó‰∏ñÁïåÁ©∫Èó¥Â∞ÑÁ∫ø\nRay getRay(in vec2 fragCoord,in Camera ca,in mat4 caT)\n{\n    fragCoord+=random(vec2(fragCoord.x,iTime));\n    //ÂØπÁÑ¶Âπ≥Èù¢ÂçäÈ´òÂ∫¶\n    float halfH=tan(radians(ca.FOV/2.0))*ca.focusDistance;\n    //Â∞ÑÁ∫øÂú®ÂØπÁÑ¶Âπ≥Èù¢‰∏äÁöÑ‰ΩçÁΩÆ\n    vec2 uv=fragCoord-iResolution.xy/2.0;//Âπ≥Áßª\n    float rate=halfH/(iResolution.y/2.0);//ÁªΩÊîæÊØî‰æã\n    uv*=rate;\n    vec3 rayTarget=vec3(uv,ca.focusDistance);\n    //Â±ÄÈÉ®Â∞ÑÁ∫øÊñπÂêë\n    vec3 dir=normalize(rayTarget);//Â±ÄÈÉ®ÊñπÂêë\n    vec3 camerOrigin=vec3(0.0,0.0,0.0);//Â±ÄÈÉ®‰ΩçÁΩÆ\n    //ËΩ¨Êç¢Âà∞‰∏ñÁïåÁ©∫Èó¥Â∞ÑÁ∫ø\n    camerOrigin=vec3(caT*vec4(camerOrigin,1.0));//‰∏ñÁïå‰ΩçÁΩÆ\n    dir=mat3(caT)*dir;//‰∏ñÁïåÊñπÂêë\n    //ÊûÑÂª∫Â∞ÑÁ∫øÂØπË±°\n    Ray r=Ray(camerOrigin,dir);\n    return r;\n}\n\n/////////////////////////////////////////////////////////Ê∏≤ÊüìÂáΩÊï∞\n/////Ê∏≤ÊüìËÉåÊôØ\nvec4 getBackground(vec3 dir)\n{\n    dir=normalize(dir);\n    vec3 lightDir=mat3(rotatY(iTime*50.0))*normalize(vec3(1.0,1.0,-1.0));\n    float alpha=pow(dot(dir,lightDir)*0.5+0.5,16.0);\n    vec4 sunColor=vec4(1.0,0.6,0.2,1.0)*2.0;\n    vec4 up=vec4(0.2,0.2,1.0,1.0)*1.0;\n    vec4 down=vec4(1.0,0.9,0.8,1.0)*0.5;\n    return mix(mix(down,up,dir.y),sunColor,alpha);\n}\n/////Ê∏≤Êüì\nvec4 render(in Ray r)\n{   \n    const int maxDepth=32;\n    vec4 finalColor=vec4(1.0);\n    HitResult tempRes;\n    for(int i=0;i<maxDepth;i++)\n    {   r.origin+=r.direction*0.01;\n        if(traceSence(r,tempRes))\n        {\n            //ËæêÂ∞ÑË¥°ÁåÆ\n            finalColor*=tempRes.material.BaseColor;\n            //Áî®‰∫é‰∏ã‰∏ÄÊ¨°ËøΩË∏™ÁöÑÂ∞ÑÁ∫ø\n            r=Ray(r.origin+r.direction*tempRes.t,reflect(r.direction,tempRes.worldNormal));\n            \n            /*\n            vec3 normal=(dot(r.direction,tempRes.worldNormal)<0.0)? tempRes.worldNormal:-tempRes.worldNormal;\n            float rr=(dot(r.direction,tempRes.worldNormal)<0.0)? 1.3:1.0/1.3;\n            r=Ray(r.origin+r.direction*tempRes.t,refract(r.direction,normal,rr));\n\t\t\t*/\n            \n            //ËøΩË∏™Ê¨°Êï∞ÁªìÊùü\n            if(i+1==count){\n                finalColor*=getBackground(r.direction);\n                //finalColor*=vec4(1.0);//ËøΩË∏™Â∞ΩÂ§¥È¢úËâ≤\n            }\n        }\n        else\n        {\n            finalColor*=getBackground(r.direction);\n            break;\n        }\n    }\n    return finalColor;\n}\n//‰∏ªÂáΩÊï∞\nvec3 s=refract(vec3(1.0,2.0,10.0),vec3(1.0,0.0,0.0),1.5);\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    createSence();//ÂàõÂª∫Âú∫ÊôØ\n    //Áõ∏Êú∫Áü©Èòµ\n    mat4 cameraMat=translate(cameraLocation)*rotat(cameraRotation);\n    fragColor+=render(getRay(fragCoord+vec2(0.5,0.5),ca,cameraMat));//ÁùÄËâ≤\n    fragColor+=render(getRay(fragCoord+vec2(0.7,0.5),ca,cameraMat));\n    fragColor+=render(getRay(fragCoord+vec2(0.75,0.5),ca,cameraMat));\n    fragColor+=render(getRay(fragCoord+vec2(0.25,0.75),ca,cameraMat));\n    fragColor+=render(getRay(fragCoord+vec2(0.5,0.25),ca,cameraMat));\n    fragColor/=5.0;\n    vec2 uv=fragCoord/iResolution.xy;\n    //fragColor=texture(iChannel1,vec3(1.0,0.0,0.5));\n    //Gamma\n    const float inverseGamma=1.0/2.2;\n    fragColor=vec4(pow(fragColor.x,inverseGamma),pow(fragColor.y,inverseGamma),pow(fragColor.z,inverseGamma),1.0);\n    \n\n}\n", "image_inputs": [{"id": "XsfGzn", "previewfilepath": "/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tGfRy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tGfWR", "name": "Moon gleam", "author": "jsen", "description": "A test to see how wave deformation affects the light column formed by the moon's reflection on water.\nImproved waves using code from https://www.shadertoy.com/view/Ms2SD1", "tags": ["moon", "lightcolumn"], "likes": 10, "viewed": 245, "date": "1543104053", "time_retrieved": "2024-06-20T19:23:59.931036", "image_code": "const vec3 LIGHT_POS = vec3(0.0, 10.0, -100.0);\nconst vec3 LIGHT_COL = vec3(0.7, 0.7, 0.9);\nconst vec3 WATER_COL = vec3(0.4, 0.7, 1.0);\n\nconst float WAVE_FREQ = 1.0;\nconst float WAVE_AMP = 0.03;\nconst float WAVE_SPEED = 0.3;\nconst float SPEC_EXP = 64.0;\n\n\nfloat rand( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( rand( i + vec2(0.0,0.0) ), \n                     rand( i + vec2(1.0,0.0) ), u.x),\n                mix( rand( i + vec2(0.0,1.0) ), \n                     rand( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat sphereDF(vec3 p, float rad) {\n    return length(p) - rad;\n}\n\nfloat oct(vec2 uv) {\n    uv += noise(uv);\n    uv = 1.0 - abs(sin(uv));\n    return pow(1.0 - uv.x * uv.y, 8.0);\n}\n\nfloat waveDist(vec3 p) {\n    vec2 uv = p.xz;\n    \n    float d = 0.0;\n    float freq = WAVE_FREQ;\n    float amp = WAVE_AMP;\n    for (int i = 0; i < 3; ++i) {\n        d += amp * oct((uv + (2.0 + iTime) * WAVE_SPEED) * freq);\n        d += amp * oct((uv - (2.0 + iTime) * WAVE_SPEED) * freq);\n        amp *= 0.5;\n        freq *= 1.5;\n    }\n    \n    return d;\n}\n\nfloat planeDF(vec3 p, float y) {\n    return p.y - y;\n}\n\nfloat boxDF(vec3 p, vec3 b) {\n    return length(max(abs(p) - b, 0.0)) - 0.1;\n}\n\nfloat capDF(vec3 p, float h, float r) {\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\n\nfloat subDF(float a, float b) {\n    return max(a, -b);\n}\n\nvec4 mapU(vec4 a, vec4 b) {\n    return a.w < b.w ? a : b;\n}\n\nfloat waves(vec3 p, float y) {\n    return planeDF(p, y) - waveDist(p);\n}\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c         );\n}\n\nfloat moon(vec3 p, float r) {\n    return sphereDF(p, r);\n}\n\nvec4 map(vec3 p) {\n    vec4 ret =      vec4(vec3(0.0), waves(p, -1.0));\n    ret = mapU(ret, vec4(LIGHT_COL, moon(p - LIGHT_POS, 2.0)));\n    \n    return ret;\n}\n\nvec3 normal(vec3 p) {\n    float eps = 0.01;\n    vec3 norm = vec3(\n        map(vec3(p.x + eps, p.y, p.z)).w - map(vec3(p.x - eps, p.y, p.z)).w,\n        map(vec3(p.x, p.y + eps, p.z)).w - map(vec3(p.x, p.y - eps, p.z)).w,\n        map(vec3(p.x, p.y, p.z + eps)).w - map(vec3(p.x, p.y, p.z - eps)).w\n    );\n    return normalize(norm);\n}\n\nfloat shadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {\n    float res = 1.0;\n    for (float t = mint; t < maxt;) {\n        float h = map(ro + rd * t).w;\n        if (h < 0.001)\n            return res;\n        t += h;\n        res = min(res, k * h / t);\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n    float mint = 0.0;\n    float maxt = 150.0;\n    \n    bool found = false;\n    vec3 surfPos = ro;\n    vec3 mapCol = vec3(0.0);\n    for (float t = mint; t < maxt;) {\n        surfPos = ro + t * rd;\n        vec4 mapVal = map(surfPos);\n        float h = mapVal.w;\n        if (h < 0.001) {\n            found = true;\n            mapCol = mapVal.xyz;\n            break;\n        }\n        t += h;\n    }\n    \n    vec3 col = vec3(1.0);\n    if (found && mapCol != LIGHT_COL) {\n        vec3 norm = normal(surfPos);\n        vec3 ref = reflect(rd, norm);\n        float ndl = dot(ref, normalize(LIGHT_POS - surfPos));\n\n        vec3 amb = 0.1 * normalize(LIGHT_COL);\n        vec3 dif = normalize(WATER_COL);\n        dif *= 0.1 * ndl;\n        \n        vec3 spe = normalize(LIGHT_COL);\n        spe *= pow(ndl, SPEC_EXP);\n\n        col = amb + dif + spe;\n    } else if (mapCol == LIGHT_COL) {\n        vec3 p = normalize(surfPos - LIGHT_POS);\n        vec2 sph = vec2(acos(p.z), atan(p.y / p.x));\n        \n        col = normalize(LIGHT_COL);\n        col *= vec3(0.5 + sin(p.x) + sin(p.z));\n        col -= 0.1 * (1.0 + noise(4.0 * sph));;\n    } else {\n        col = vec3(0.05, 0.07, 0.1);\n    }\n    \n    return clamp(col, 0.0, 1.0);\n}\n\nmat3 setCamera( vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouseCurr = iMouse.xy / iResolution.xy;\n    \n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 camPos = vec3(0.0, 15.0 * (1.0 - mouseCurr.y), 50.0);\n    vec3 ro = camPos;\n    mat3 ca = setCamera(ro, vec3(0.0), 0.0);\n    vec3 rd = ca * normalize(vec3(p, 3.2));\n\n    vec3 col = render(ro, rd);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tGfWR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tGfzG", "name": "x(x+a) in the complex plane", "author": "BanditCat", "description": "step 1", "tags": ["fractal"], "likes": 1, "viewed": 82, "date": "1542857947", "time_retrieved": "2024-06-20T19:23:59.931036", "image_code": "// First\n\nconst float bailout = 10.0;\nconst int iter = 16;\n\nvec2 imul( in vec2 x, in vec2 y ){\n    return vec2(x.x*y.x - x.y*y.y,x.x*y.y+x.y*y.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy + vec2(-0.5,-0.5))*vec2(4,4);\n    vec2 c = uv;\n    int count = iter;\n      \n    vec2 pet = vec2(cos(iTime*4.0),sin(iTime));\n    uv += pet;\n    \n    for( int i = 0; i < iter; i++ ){\n        vec2 nuv = uv + c;\n\t\tuv = imul( uv, nuv);\n        if( length(uv) > bailout ){\n            count = i;\n            break;\n        }\n    }\n   uv -= pet;\n    \n    \n    vec3 col = vec3( 0.0,  1.0/length(uv), 0 );\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tGfzG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tGfzm", "name": "Raymarched Lava Lamp", "author": "_polymath", "description": "A raymarched lavalamp", "tags": ["raymarching"], "likes": 8, "viewed": 598, "date": "1542969166", "time_retrieved": "2024-06-20T19:23:59.931036", "image_code": "#define MAXITERS 30\n#define LENFACTOR .95\n#define MINDIST 0.04\n#define NDELTA 0.001\n\n// metaballs ref:\n// http://jamie-wong.com/2014/08/19/metaballs-and-marching-squares/\n\n#define NDELTAX vec3(NDELTA, 0., 0.)\n#define NDELTAY vec3(0., NDELTA, 0.)\n#define NDELTAZ vec3(0., 0., NDELTA)\n\nfloat rand(float n) {\n    //return texture(iChannel0, fract(vec2(n, n))).r;\n\treturn fract(2634.2745 * (n + 3.263));\n}\nvec3 rand3(float n) {\n    return vec3(rand(n * 363.34), rand(n * 73.25), rand(n * 3734.423));\n}\n\n// Hardcoded randomness for speed:\nconst vec3[6] speeds = vec3[6] (\n\tvec3(0.764, 1.175, 1.035),\n    vec3(1.32, 1.227, 0.9745),\n    vec3(0.834, 0.734, 1.263),\n    vec3(1.1623, 0.933, 0.7373),\n    vec3(0.9347, 1.3734, 0.834),\n    vec3(0.853, 1.2745, 0.972)\n);\nconst vec3[6] ranges = vec3[6] (\n\tvec3(0.5273, 1.8347, 1.0734),\n\tvec3(0.846, 2.384, 0.7346),\n\tvec3(0.7234, 1.377, 0.982),\n\tvec3(0.62485, 1.927, 0.5273),\n\tvec3(0.982, 1.73435, 0.8245),\n\tvec3(0.5834, 2.572, 0.6725)\n);\n\nfloat scene(vec3 p) {\n    //float d = 10000.;\n    float den = 0.;\n    for (float i = .0; i < 5.; ++i) {\n        vec3 c = sin(iTime * speeds[int(i)]) * ranges[int(i)]\n            + vec3(0., 0., 10.);\n        vec3 dis = c - p;\n        float x = dot(dis, dis);\n        den += .8 / x;\n    }\n    //return     pow(den, .25) - 2.;\n    if (den < 0.333) return 2.;\n    else return 1. / den - 1.;\n}\n    \nvec3 sceneNormal(vec3 p) {\n    return normalize(vec3(\n        scene(p + NDELTAX) - scene(p - NDELTAX),\n        scene(p + NDELTAY) - scene(p - NDELTAY),\n        scene(p + NDELTAZ) - scene(p - NDELTAZ)\n\t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.yy;\n    vec3 ray = normalize(vec3(uv, 1.));\n    vec3 cam = vec3(0., 1., -1.);\n    \n    vec3 pos = cam;\n    float dist;\n    for (int i = 0; i < MAXITERS; ++i) {\n        dist = scene(pos);\n        if (dist < MINDIST) break;\n        pos += ray * dist * LENFACTOR;\n    }\n    \n    float b;\n    if (dist < MINDIST) {\n\t    vec3 n = sceneNormal(pos);\n    \tb = -0.5 * n.y + 0.5;\n    } else\n        b = (-0.5 * uv.y + 0.5) * cos(uv.x);\n    b = clamp(b, 0., 1.);\n    \n    float t = iTime * 0.4;\n    float smallTime = smoothstep(0., 1., fract(t)),\n        bigTime = mod(t, 6.);\n    \n    vec3 col = vec3(0, 0, 0);\n    if (bigTime < 1.) {\n        col.r = b; col.g = b * smallTime;\n    } else if (bigTime < 2.) {\n        col.g = b; col.r = (1. - smallTime) * b;\n    } else if (bigTime < 3.) {\n        col.g = b; col.b = b * smallTime;\n    } else if (bigTime < 4.) {\n        col.b = b; col.g = (1. - smallTime) * b;\n    } else if (bigTime < 5.) {\n        col.b = b; col.r = b * smallTime;\n    } else {\n        col.r = b; col.b = (1. - smallTime) * b;\n    }\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tGfzm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tGfzz", "name": "Antelope Canyon", "author": "Ubiquitous", "description": "Modified a few values from [https://www.shadertoy.com/view/MlG3zh], adding ground plane, adjusting light to simulate  dusting of snow on the path and rocks, + misc fog color tweaks.", "tags": ["rocks", "flythrough", "canyon", "antelope", "arizona"], "likes": 17, "viewed": 517, "date": "1541578478", "time_retrieved": "2024-06-20T19:24:02.926255", "image_code": "/*\n\tAntelope Canyon\n    -----------\n    Modified From: https://www.shadertoy.com/view/MlG3zh\n\n\tCombining some cheap distance field functions with some functional and texture-based bump \n\tmapping to carve out a rocky canyon-like passageway.\n\n\tThere's nothing overly exciting about this example. I was trying to create a reasonably\n    convincing looking rocky setting using cheap methods.\n\n\tI added in some light frosting, mainly to break the monotony of the single colored rock.\n\tThere's a mossy option below, for anyone interested. Visually speaking, I find the moss more\n\tinteresting, but I thought the frost showed the rock formations a little better. Besides,\n\tI'd like to put together a more dedicated greenery example later.\n\n*/\n\n#define PI 3.14159265\n#define FAR 60.\n\n// Extra settings. Use one or the other. The MOSS setting overrides the HOT setting.\n// Mossy setting. Better, if you want more color to liven things up. For this example, I wanted subtlety.\n//#define MOSS \n// Hot setting. It represents 2 minutes of post processing work, so it's definitely nothing to excited about. :)\n//#define HOT\n\n// Coyote's snippet to provide a virtual reality element. Really freaky. It gives the scene \n// physical depth, but you have to do that magic picture focus adjusting thing with your eyes.\n//#define THREE_D \n\n\n// Rotation matrix.\nconst mat2 rM = mat2(.7071, .7071, -.7071, .7071); \n\n// 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n// of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) + a);\treturn mat2(v, -v.y, v.x); }\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D channel, vec3 p, vec3 n){\n    \n    //vec3 col = mix(vec3(.7, 1, 1.3), vec3(1), n.y*.5 + .5);\n    \n    n = max(abs(n) - .2, 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(channel, p.zy).xyz;\n    vec3 ty = texture(channel, p.xz).xyz;\n    vec3 tz = texture(channel, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);//*col;\n}\n\n\n// Cellular tile setup. Draw four overlapping objects (spheres, in this case) \n// at various positions throughout the tile.\n \nfloat drawObject(in vec3 p){\n  \n    p = fract(p)-.5;\n    return dot(p, p);\n    \n}\n\n\n// 3D cellular tile function.\nfloat cellTile(in vec3 p){\n   \n    vec4 d; \n    \n    // Plot four objects.\n    d.x = drawObject(p - vec3(.81, .62, .53));\n    p.xy *= rM;\n    d.y = drawObject(p - vec3(.6, .82, .64));\n    p.yz *= rM;\n    d.z = drawObject(p - vec3(.51, .06, .70));\n    p.zx *= rM;\n    d.w = drawObject(p - vec3(.12, .62, .64));\n\n\t// Obtaining the minimum distance.\n    d.xy = min(d.xz, d.yw);\n    \n    // Normalize... roughly. Trying to avoid another min call (min(d.x*A, 1.)).\n    return  min(d.x, d.y)*2.5;\n    \n}\n\n\n// The triangle function that Shadertoy user Nimitz has used in various triangle noise demonstrations.\n// See Xyptonjtroz - Very cool. Anyway, it's not really being used to its full potential here.\n// https://www.shadertoy.com/view/4ts3z2\nvec3 tri(in vec3 x){return abs(fract(x)-.5);} // Triangle function.\n\n\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){\n   \n    //return vec2(0); // Straight.\n    float a = sin(z * 0.11);\n    float b = cos(z * 0.14);\n    return vec2(a*4. -b*1.5, b*1.7 + a*1.5); \n    //return vec2(a*4. -b*1.5, 0.); // Just X.\n    //return vec2(0, b*1.7 + a*1.5); // Just Y.\n}\n\n\n\n// A fake noise looking sinusoial field - flanked by a ground plane and some walls with\n// some triangular-based perturbation mixed in. Cheap, but reasonably effective.\nfloat map(vec3 p){\n    \n \n    p.xy -= path(p.z); // Wrap the passage around\n    \n    vec3 w = p; // Saving the position prior to mutation.\n    \n    vec3 op = tri(p*.4*3. + tri(p.zxy*.4*3.)); // Triangle perturbation.\n   \n    \n    float ground = p.y + 0.05 + dot(op, vec3(.222))*.13; // Ground plane, slightly perturbed.\n \n    p += (op - .15)*.3; // Adding some triangular perturbation.\n   \n\tp = cos(p*.315*1.41 + sin(p.zxy*.875*1.27)); // Applying the sinusoidal field (the rocky bit).\n    \n    float canyon = (length(p) - 1.05)*.95 - (w.x*w.x)*.51; // Spherize and add the canyon walls.\n    \n    return min(ground, canyon);\n\n    \n}\n\n\n\n// Surface bump function. I'm reusing the \"cellTile\" function, but absoulte sinusoidals\n// would do a decent job too.\nfloat bumpSurf3D( in vec3 p, in vec3 n){\n    \n    //return (cellTile(p/1.5))*.66 + (cellTile(p*2./1.5))*.34;\n    \n    return cellTile(p/1.5);\n    \n}\n\n// Standard function-based bump mapping function.\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    const vec2 e = vec2(2.201, 0);\n    float ref = bumpSurf3D(p, nor);                 \n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy, nor),\n                      bumpSurf3D(p - e.yxy, nor),\n                      bumpSurf3D(p - e.yyx, nor) )-ref)/e.x;                     \n          \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n    \n}\n\n\nfloat accum;\n\n\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n    \n    accum = 0.;\n\n    float t = 0.0, h;\n    for(int i = 0; i < 160; i++){\n    \n        h = map(ro+rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(h)<0.001*(t*.15 + 1.) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.)\n        t += h;//*.7;\n        \n        if(abs(h)<0.15) accum += (.15-abs(h))/24.;///(1.+t);//.0005/abs(h);\n        //if(abs(h)<0.25)accum += (.25-abs(h))*vec3(3, 2, 1)/4.*n3D((ro+rd*t)*16. - vec3(0, 0, 1)*iTime*1.);\n        \n    }\n\n    return min(t, FAR);\n    \n}\n\n/*\n// Ambient occlusion, for that self shadowed look. Based on the original by XT95. I love this \n// function, and in many cases, it gives really, really nice results. For a better version, and \n// usage, refer to XT95's examples below:\n//\n// Hemispherical SDF AO - https://www.shadertoy.com/view/4sdGWN\n// Alien Cocoons - https://www.shadertoy.com/view/MsdGz2\nfloat calculateAO2( in vec3 p, in vec3 n )\n{\n\tfloat ao = 0.0, l;\n    const float maxDist = 2.;\n\tconst float nbIte = 6.0;\n\t//const float falloff = 0.9;\n    for( float i=1.; i< nbIte+.5; i++ ){\n    \n        l = (i*.75 + fract(cos(i)*45758.5453)*.25)/nbIte*maxDist;\n        \n        ao += (l - map( p + n*l ))/(1.+ l);// / pow(1.+l, falloff);\n    }\n\t\n    return clamp(1.- ao/nbIte, 0., 1.);\n}\n*/\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calculateAO(in vec3 p, in vec3 n){\n\t\n    float sca = 1., occ = 0.;\n    for(float i=0.; i<5.; i++){\n    \n        float hr = .01 + i*.5/4.;        \n        float dd = map(n * hr + p);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp(2.0 - occ, 0., 1.);    \n}\n\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ. In instances where there's no descernible \n// aesthetic difference between it and the six tap version, it's worth using.\nvec3 calcNormal(in vec3 p){\n\n    // Note the slightly increased sampling distance, to alleviate artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.001, -0.001); \n    return normalize(e.xyy*map(p + e.xyy) + e.yyx*map(p + e.yyx) + e.yxy*map(p + e.yxy) + e.xxx*map(p + e.xxx));\n}\n\n/*\n// Standard normal function. 6 taps.\nvec3 calcNormal(in vec3 p) {\n\tconst vec2 e = vec2(0.002, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n*/\n\n// Shadows.\nfloat shadows(in vec3 ro, in vec3 rd, in float start, in float end, in float k){\n\n    float shade = 1.0;\n    const int shadIter = 14; \n\n    float dist = start;\n    //float stepDist = end/float(shadIter);\n\n    for (int i=0; i<shadIter; i++){\n        float h = map(ro + rd*dist);\n        shade = min(shade, k*h/dist);\n        //shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n\n        dist += clamp(h, 0.32, 0.2);\n        \n        // There's some accuracy loss involved, but early exits from accumulative distance function can help.\n        if ((h)<0.001 || dist > end) break; \n    }\n    \n    return min(max(shade, 0.) + 0.0, 1.0); \n}\n\n//////\n// Very basic pseudo environment mapping... and by that, I mean it's fake. :) However, it \n// does give the impression that the surface is reflecting the surrounds in some way.\n//\n// Anyway, the idea is very simple. Obtain the reflected (or refracted) ray at the surface \n// hit point, then index into a repeat texture in some way. It can be pretty convincing \n// (in an abstract way) and facilitates environment mapping without the need for a cube map, \n// or a reflective pass.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\n\nvec3 envMap(vec3 rd, vec3 n){\n    \n    return tex3D(iChannel0, rd, n);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t\n\t// Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n    \n    #ifdef THREE_D\n    float sg = sign(fragCoord.x - .5*iResolution.x);\n    uv.x -= sg*.25*iResolution.x/iResolution.y;\n    #endif\n\t\n\t// Camera Setup.\n    vec3 camPos = vec3(0.0, 0.0, iTime*4.); // Camera position, doubling as the ray origin.\n\n\tvec3 lookAt = camPos + vec3(-0.05, 0.05, 0.25);  // \"Look At\" position.\n\n \n    // Light positioning. The positioning is fake. Obviously, the light source would be much \n    // further away, so illumination would be relatively constant and the shadows more static.\n    // That's what direct lights are for, but sometimes it's nice to get a bit of a point light \n    // effect... but don't move it too close, or your mind will start getting suspicious. :)\n \tvec3 lightPos = camPos + vec3(-30, 40, -20);\n\n\n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and two light vectors down the tunnel. The \"path\" function is \n\t// synchronized with the distance function. Change to \"path2\" to traverse the other tunnel.\n\tlookAt.xy += path(lookAt.z);\n\tcamPos.xy += path(camPos.z);\n\t//lightPos.xy += path(lightPos.z);\n    \n    \n    #ifdef THREE_D\n    camPos.x -= sg*.15; lookAt.x -= sg*.15; lightPos.x -= sg*.15;\n    #endif\n    \n    \n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.333;//PI/3.; // FOV - Field of view.\n    vec3 forward = normalize(lookAt-camPos);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    \n    // Lens distortion.\n    //vec3 rd = (forward + FOV*uv.x*right + FOV*uv.y*up);\n    //rd = normalize(vec3(rd.xy, rd.z - length(rd.xy)*.25));    \n    \n    // Swiveling the camera about the XY-plane (from left to right) when turning corners.\n    // Naturally, it's synchronized with the path in some kind of way.\n\trd.xy = rot2( path(lookAt.z).x/16. )*rd.xy;\n\n    /*    \n    // Mouse controls. I use them as a debugging device, but they can be used to look around. \n\tvec2 ms = vec2(0);\n    if (iMouse.z > 1.0) ms = (2.*iMouse.xy - iResolution.xy)/iResolution.xy;\n    vec2 a = sin(vec2(1.5707963, 0) - ms.x); \n    mat2 rM = mat2(a, -a.y, a.x);\n    rd.xz = rd.xz*rM; \n    a = sin(vec2(1.5707963, 0) - ms.y); \n    rM = mat2(a, -a.y, a.x);\n    rd.yz = rd.yz*rM;\n\t*/\n    \n    // Standard ray marching routine. I find that some system setups don't like anything other than\n    // a \"break\" statement (by itself) to exit. \n\tfloat t = trace(camPos, rd);   \n    \n\t\n    // Initialize the scene color.\n    vec3 sceneCol = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t<FAR){\n\t\n   \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = camPos + rd*t;\n        \n        // Voxel normal.\n        //vec3 sn = -(mask * sign( rd ));\n        vec3 sn = calcNormal(sp);\n        \n        // Sometimes, it's necessary to save a copy of the unbumped normal.\n        vec3 snNoBump = sn;\n        \n        // I try to avoid it, but it's possible to do a texture bump and a function-based\n        // bump in succession. It's also possible to roll them into one, but I wanted\n        // the separation... Can't remember why, but it's more readable anyway.\n        //\n        // Texture scale factor.\n        const float tSize0 = 1./2.;\n        \n        \n        // Function based bump mapping. Comment it out to see the under layer. It's pretty\n        // comparable to regular beveled Voronoi... Close enough, anyway.\n        sn = doBumpMap(sp, sn, .5);\n        \n        // Texture-based bump mapping.\n\t    sn = doBumpMap(iChannel0, sp*tSize0, sn, .1);//(-sign(sn.y)*.15+.85)*\n\n        \n    \t// Light direction vectors.\n\t    vec3 ld = lightPos - sp;\n\n        // Distance from respective lights to the surface point.\n\t    float lDist = max(length(ld), 0.001);\n    \t\n    \t// Normalize the light direction vectors.\n\t    ld /= lDist;\n        \n        // Shadows.\n        float shading = shadows(sp + sn*.005, ld, .05, lDist, 8.);\n        \n\t    // Ambient occlusion.\n\t    float ao = calculateAO(sp, sn);//*.75 + .25;\n\n\t    \n        \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.007);\n    \t\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.0);\n   \t\n    \t// Specular lighting.\n\t    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 32.);\n\n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow( clamp(dot(sn, rd) + 1., .0, 1.), 1.);\n        \n        // Ambient light, due to light bouncing around the the canyon.\n\t    float ambience = 0.35*ao + fre*fre*.25;\n\n        // Object texturing, coloring and shading.\n\t    vec3 texCol = tex3D(iChannel0, sp*tSize0, sn);\n\n        // Tones down the pinkish limestone\\granite color.\n        //texCol *= mix(vec3(.7, 1, 1.3), vec3(1), snNoBump.y*.5 + .5);\n        \n        #ifdef MOSS\n        // Some quickly improvised moss.\n        texCol = texCol*mix(vec3(1), vec3(.5, 1.5, 1.5), abs(snNoBump));\n        texCol = texCol*mix(vec3(1), vec3(.6, 1, .5), pow(abs(sn.y), 4.));\n        #else\n        // Adding in the white frost. A bit on the cheap side, but it's a subtle effect.\n        // As you can see, it's improvised, but from a physical perspective, you want the frost to accumulate\n        // on the flatter surfaces, hence the \"sn.y\" factor. There's some Fresnel thrown in as well to give\n        // it a tiny bit of sparkle.\n        texCol = mix(texCol, vec3(.35, .55, 1)*(texCol*.5+.5)*vec3(2), ((snNoBump.y*.5 + sn.y*.5)*.5+.5)*pow(abs(sn.y), 4.)*texCol.r*fre*4.);\n        #endif      \n\n        \n        // Final color. Pretty simple.\n        sceneCol = texCol*(diff + spec + ambience);// + vec3(.2, .5, 1)*spec;\n        \n        // A bit of accumulated glow.\n        sceneCol += texCol*((sn.y)*.5+.5)*min(vec3(1, 1.15, 1.5)*accum, 1.);  \n     \n        \n        // Adding a touch of Fresnel for a bit of glow.\n        sceneCol += texCol*vec3(.8, .95, 1)*pow(fre, 4.)*.5;\n        \n        \n        // Faux environmental mapping. Adds a bit more ambience.        \n        vec3 sn2 = snNoBump*.5 + sn*.5;\n        vec3 ref = reflect(rd, sn2);//\n        vec3 em = envMap(ref/2., sn2);\n        ref = refract(rd, sn2, 1./1.31);\n        vec3 em2 = envMap(ref/8., sn2);\n        //sceneCol += ((sn.y)*.25+.75)*sceneCol*(em + em2);\n        sceneCol += sceneCol*2.*(sn.y*.25+.75)*mix(em2, em, pow(fre, 4.));\n\n\n\t    // Shading. Adding some ambient occlusion to the shadow for some fake global lighting.\n        sceneCol *= atten*min(shading + ao*.35, 1.)*ao;\n\t   \n\t\n\t}\n    \n       \n    // Blend in a bit of light fog for atmospheric effect. I really wanted to put a colorful, \n    // gradient blend here, but my mind wasn't buying it, so dull, blueish grey it is. :)\n    vec3 fog = vec3(1.6, 0.8, 1.2)*(rd.y*1.5 + 2.5);\n    #ifdef MOSS\n    fog *= vec3(14, 0.25, 1.5);\n    #else\n    #ifdef HOT\n    fog *= 4.;\n    #endif\n    #endif\n    sceneCol = mix(sceneCol, fog, smoothstep(0., .95, t/FAR)); // exp(-.002*t*t), etc. fog.zxy\n    \n    \n    //sceneCol *= vec3(.5, .75, 1.5); // Nighttime vibe.\n    #ifndef MOSS\n    #ifdef HOT\n    float gr = dot(sceneCol, vec3(.299, .587, .114)); // Grayscale.\n    // A tiny portion of the original color blended with a very basic fire palette.\n    sceneCol = sceneCol*.1 + pow(min(vec3(1.5, 1, 1)*gr*1.2, 1.), vec3(1, 3, 16));\n    // Alternative artsy look. Comment out the line above first.\n    //sceneCol = mix(sceneCol, pow(min(vec3(1.5, 1, 1)*gr*1.2, 1.), vec3(1, 3, 16)), -uv.y + .5);\n    #endif\n    #endif\n    \n    // Subtle, bluish vignette.\n    uv = fragCoord/iResolution.xy;\n    sceneCol = mix(vec3(0, .1, 1), sceneCol, pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y) , .125)*.15 + .85);\n    \n\n    // Clamp and present the badly gamma corrected pixel to the screen.\n\tfragColor = vec4(sqrt(clamp(sceneCol, 0., 1.)), 1.0);\n\t\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tGfzz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tKBDW", "name": "fake lighting", "author": "Del", "description": "raymarch / lighting / patched sphere testing", "tags": ["raymarch", "reflect", "spec"], "likes": 13, "viewed": 609, "date": "1542572363", "time_retrieved": "2024-06-20T19:24:03.859678", "image_code": "// simple sphere march (+ fake light / ref)\nmat2 rotate(float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n#define\tTAU 6.28318\n\nfloat textureFunc( vec2 uv )\n{\n    uv *= 3.;\n    vec2 f_uv = fract(uv);\n    float v = smoothstep(.0,.5,length(vec2(.5)-f_uv));\n    return v;\n}\n\n// IQ's patched sphere parametrization to squash texture on to a sphere.\n// Reference: http://iquilezles.org/www/articles/patchedsphere/patchedsphere.htm\n\nvec2 sphereToCube(in vec3 pointOnSphere)\n{\n   return vec2(pointOnSphere.x/pointOnSphere.z,pointOnSphere.y/pointOnSphere.z);\n}\n/* Check if x and y are between 0 and 1. If so, return v,\n * otherwise return zeros. This allows us to use a sum of\n * vectors to test what face of the cube we are on */ \nvec2 insideBounds(vec2 v)\n{\n    vec2 s = step(vec2(-1.,-1.), v) - step(vec2(1.,1.), v);\n    return s.x * s.y * v;\n}\n\nfloat getSphereMappedTexture(in vec3 pointOnSphere)\n{\n    /* Test to determine which face we are drawing on.\n     * Opposing faces are taken care of by the absolute\n     * value, leaving us only three tests to perform.\n     */\n    vec2 st = abs(\n        insideBounds(sphereToCube(pointOnSphere.xyz)) +\n        insideBounds(sphereToCube(pointOnSphere.zyx)) +\n        insideBounds(sphereToCube(pointOnSphere.xzy)));\n    return textureFunc(st);\n}\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBumpedSphere(vec3 p)\n{\n\tfloat k = getSphereMappedTexture(p) * 0.25;\t\t// \n\tfloat d = sdSphere(p, 4.0);\n    return d+k;\n}\n\n\nfloat map(vec3 p)\n{\n    float ox = p.x;\n    vec4 tt = vec4(iTime*0.05,iTime*0.1,iTime*0.5,iTime*0.75) * TAU;\n\tp.xz *= rotate(tt.x);\n    p.zy *= rotate(tt.y);\n\n    float d2 = sdBumpedSphere(p);\n    float d1 =  length(p.xyz);\n    float ii = 6.0;\n    float k = sin(p.x*ii);\n    k*= sin(p.z*ii);\n    k*= sin(p.y+p.z*d1);\n    d1 = d1 - 4.0 + k*0.25;\n    \n    // blend between bumped texture sphere and the random displacement... :)\n    float bv = 0.5+sin(ox*0.1+iTime*0.7)*0.5;\n    bv = (bv*3.0)-1.5;\n    bv = smoothstep(0.0,1.0,bv);\n    return mix(d1,d2,bv);\n}\n\nvec3 normal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\nvec3 render(vec3 ro, vec3 rd)\n{\n\t// march\t\n\tfloat tmin = 0.1;\n\tfloat tmax = 20.;\n\tvec3 p;\n\tfloat t = tmin;\n\tfor (int i = 0; i < 180; i++)\n\t{\n\t\tp = ro + t * rd;\n\t\tfloat d = map(p);\n\t\tt += d*0.75;\n\t\tif (t > tmax)\n\t\t\tbreak;\t\t\n\t}\n\t\n    // light\n\tif (t < tmax)\n\t{\n\t   \tvec3 lightDir = normalize(vec3(0.0, 1.0, -1.0));\n\t\tvec3 nor = normal(p);\n\t\t\n\t\tfloat dif = max(dot(nor, lightDir), 0.0);\n\t\tvec3 c = vec3(0.5) * dif;\n        \n        float tf = 0.05;\n\t\tc += vec3(0.3,0.3,0.3) + reflect(vec3(p.x*tf, p.y*tf, 0.05), nor);\n\n\t\tvec3 ref = reflect(rd, nor);\n\t\tfloat spe = max(dot(ref, lightDir), 0.0);\n\t\tc += vec3(2.0) * pow(spe, 32.);\n\t\treturn c;\n\t}\n\t\n\treturn vec3(0.24,0.24,0.35);\n}\n\nmat3 camera(vec3 ro, vec3 ta, vec3 up)\n{\n\tvec3 nz = normalize(ta - ro);\n\tvec3 nx = cross(nz, normalize(up));\n\tvec3 ny = cross(nx, nz);\n\treturn mat3(nx, ny, nz);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 q = (2.0*fragCoord.xy / iResolution.xy)-1.0;\n\tvec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.xy;\n\tp.x *= iResolution.x / iResolution.y;\n\n\tvec3 ro = vec3(0.0, 0.0, 0.0);\n    float ang = radians(-90.0);\n    float d = 6.0;\n    ro.z = sin(ang)*d;\n    ro.x = cos(ang)*d;\n\tvec3 ta = vec3(0.0, 0.0, 0.0);\n\t\n\tvec3 rd = camera(ro, ta, vec3(0.0, 1.0, 0.0)) * normalize(vec3(p.xy, 1.0));\n\n    // render\n\tvec3 c = render(ro, rd);\n\n    // vignette\n    float rf = sqrt(dot(q, q)) * 0.35;\n    float rf2_1 = rf * rf + 1.0;\n    float e = 1.0 / (rf2_1 * rf2_1);    \n    c*=e;    \n\n\tfragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tKBDW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tKBRy", "name": "Rounded cylinder", "author": "gilenei", "description": "Rounded cylinder, ray cast", "tags": ["raycast"], "likes": 3, "viewed": 86, "date": "1542971081", "time_retrieved": "2024-06-20T19:24:06.258944", "image_code": "// The MIT License\n// Copyright ¬© 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n    \n\n// A list of useful distance function to simple primitives, and an example on how to \n// do some interesting boolean operations, repetition and displacement.\n//\n// More info here: http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n#define AA 1   // make this 1 is your machine is too slow\n\n\n//------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    \n}\n\nfloat sdRoundBox( in vec3 p, in vec3 b, in float r ) \n{\n    vec3 q = abs(p) - b;\n    return min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0)) - r;\n}\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 1\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n#endif    \n#if 0    \n    float d1 = q.z-h.y;\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n#if 0\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n#endif\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\n\nfloat sdEquilateralTriangle(  in vec2 p )\n{\n    const float k = 1.73205;//sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n    h.x *= 0.866025;\n    float d2 = sdEquilateralTriangle(p.xy/h.x)*h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  float ra = 0.2;\n  float rb = 0.1;\n  h.x = 0.4;\n  h.y = 0.4;\n  vec2 d = abs(vec2(length(p.xz),p.y)-2.0*ra+rb) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdPryamid4(vec3 p, vec3 h ) // h = { cos a, sin a, height }\n{\n    // Tetrahedron = Octahedron - Cube\n    float box = sdBox( p - vec3(0,-2.0*h.z,0), vec3(2.0*h.z) );\n \n    float d = 0.0;\n    d = max( d, abs( dot(p, vec3( -h.x, h.y, 0 )) ));\n    d = max( d, abs( dot(p, vec3(  h.x, h.y, 0 )) ));\n    d = max( d, abs( dot(p, vec3(  0, h.y, h.x )) ));\n    d = max( d, abs( dot(p, vec3(  0, h.y,-h.x )) ));\n    float octa = d - h.z;\n    return max(-box,octa); // Subtraction\n }\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n    return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = opU( vec2( sdPlane(     pos), 1.0 ),\n\t                vec2( sdSphere(    pos-vec3( 1.0,0.25, 0.0), 0.01 ), 46.9 ) );\n    //res = opU( res, vec2( sdBox(       pos-vec3( 1.0,0.25, 0.0), vec3(0.25) ), 3.0 ) );\n    //res = opU( res, vec2( sdRoundBox(  pos-vec3( 1.0,0.25, 1.0), vec3(0.15), 0.1 ), 41.0 ) );\n\t//res = opU( res, vec2( sdTorus(     pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), 25.0 ) );\n    //res = opU( res, vec2( sdCapsule(   pos,vec3(-1.3,0.10,-0.1), vec3(-0.8,0.50,0.2), 0.1  ), 31.9 ) );\n\t//res = opU( res, vec2( sdTriPrism(  pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ),43.5 ) );\n\tres = opU( res, vec2( sdCylinder(  pos-vec3( 0,0.30,0), vec2(0.1,0.08) ), 8.0 ) );\n\t//res = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), 55.0 ) );\n\t//res = opU( res, vec2( sdTorus82(   pos-vec3( 0.0,0.25, 2.0), vec2(0.20,0.05) ),50.0 ) );\n\t//res = opU( res, vec2( sdTorus88(   pos-vec3(-1.0,0.25, 2.0), vec2(0.20,0.05) ),43.0 ) );\n\t//res = opU( res, vec2( sdCylinder6( pos-vec3( 1.0,0.30, 2.0), vec2(0.1,0.2) ), 12.0 ) );\n\t//res = opU( res, vec2( sdHexPrism(  pos-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ),17.0 ) );\n\t//res = opU( res, vec2( sdPryamid4(  pos-vec3(-1.0,0.15,-2.0), vec3(0.8,0.6,0.25) ),37.0 ) );\n    //res = opU( res, vec2( opS( sdRoundBox(  pos-vec3(-2.0,0.2, 1.0), vec3(0.15),0.05),\n\t                           //sdSphere(    pos-vec3(-2.0,0.2, 1.0), 0.25)), 13.0 ) );\n    //res = opU( res, vec2( opS( sdTorus82(  pos-vec3(-2.0,0.2, 0.0), vec2(0.20,0.1)),\n\t//                           sdCylinder(  opRep( vec3(atan(pos.x+2.0,pos.z)/6.2831, pos.y, 0.02+0.5*length(pos-vec3(-2.0,0.2, 0.0))), vec3(0.05,1.0,0.05)), vec2(0.02,0.6))), 51.0 ) );\n\t//res = opU( res, vec2( 0.5*sdSphere(    pos-vec3(-2.0,0.25,-1.0), 0.2 ) + 0.03*sin(50.0*pos.x)*sin(50.0*pos.y)*sin(50.0*pos.z), 65.0 ) );\n\t//res = opU( res, vec2( 0.5*sdTorus( opTwist(pos-vec3(-2.0,0.25, 2.0)),vec2(0.20,0.05)), 46.7 ) );\n    //res = opU( res, vec2( sdCappedCone( pos-vec3( 0.0,0.35,-2.0), 0.15, 0.2, 0.1 ), 13.67 ) );\n    //res = opU( res, vec2( sdEllipsoid( pos-vec3( 1.0,0.35,-2.0), vec3(0.15, 0.2, 0.05) ), 43.17 ) );\n    //res = opU( res, vec2( sdRoundCone( pos-vec3(-2.0,0.2,-2.0), 0.2, 0.1, 0.3 ), 23.56 ) );\n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n   \n#if 1\n    // bounding volume\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<64; i++ )\n    {\n\t    float precis = 0.0004*t;\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        if( m<1.5 )\n        {\n            \n            float f = checkersGradBox( 5.0*pos.xz );\n            col = 0.3 + f*vec3(0.1);\n        }\n\n        // lighitng        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n        vec3  hal = normalize( lig-rd );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.2, 0.2, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        \n        dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n        dom *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.30*dif*vec3(1.00,0.80,0.55);\n        lin += 0.40*amb*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.40*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\t\tcol += 10.00*spe*vec3(1.00,0.90,0.70);\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime;\n\n    \n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n\t\t// camera\t\n        vec3 ro = vec3( 4.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.5*sin(0.1*time + 6.0*mo.x) );\n        vec3 ta = vec3( -0.5, -0.4, 0.5 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta, 0.0 );\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.2) );\n\n        // render\t\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/4tKBRy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tKBzz", "name": "Caleidoscope", "author": "alexahdp", "description": "Simple color caleidoscope", "tags": ["color"], "likes": 2, "viewed": 497, "date": "1541632128", "time_retrieved": "2024-06-20T19:24:06.259906", "image_code": "#define TWO_PI 6.28318530718\n\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n\t\n    // –≤–µ–∫—Ç–æ—Ä –æ—Ç —Ü–µ–Ω—Ç—Ä–∞ –∫ —Ç–µ–∫—É—â–µ–º—É –ø–∏–∫—Å—É–ª—é\n    vec2 toCenter = vec2(0.5) - uv;\n    \n    // —É–≥–æ–ª –≤–µ–∫—Ç–æ—Ä–∞\n    float ca = atan(toCenter.x, toCenter.y);\n    \n    // —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –æ—Ç —Ü–µ–Ω—Ç—Ä–∞ –¥–æ —Ç–µ–∫—É—â–µ–≥–æ –ø–∏–∫—Å–µ–ª—è\n    float r = length(toCenter) * 2.0;\n    \n    // –ø—Å–∏—Ö–æ–¥–µ–ª–∏—á–µ—Å–∫–∞—è –∫–∞—Ä—É—Å–µ–ª—å\n    vec3 color = hsb2rgb(vec3(((ca + iTime) / TWO_PI) + 0.5, r, 1.0));\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tKBzz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tKfRc", "name": "Basic Weather Noise Pattern", "author": "gigaherz", "description": "Testing using noise algorithm with time as a component to make a flowing noise to simulate weather patterns.", "tags": ["noise", "time", "pattern"], "likes": 3, "viewed": 185, "date": "1543442629", "time_retrieved": "2024-06-20T19:24:06.713803", "image_code": "//\t<https://www.shadertoy.com/view/4dS3Wd>\n//\tBy Morgan McGuire @morgan3d, http://graphicscodex.com\n//\nfloat hash(float n) { return fract(sin(n) * 1e4); }\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\nfloat noise(float x) {\n\tfloat i = floor(x);\n\tfloat f = fract(x);\n\tfloat u = f * f * (3.0 - 2.0 * f);\n\treturn mix(hash(i), hash(i + 1.0), u);\n}\n\nfloat noise(vec2 x) {\n\tvec2 i = floor(x);\n\tvec2 f = fract(x);\n\n\t// Four corners in 2D of a tile\n\tfloat a = hash(i);\n\tfloat b = hash(i + vec2(1.0, 0.0));\n\tfloat c = hash(i + vec2(0.0, 1.0));\n\tfloat d = hash(i + vec2(1.0, 1.0));\n\n\t// Simple 2D lerp using smoothstep envelope between the values.\n\t// return vec3(mix(mix(a, b, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tmix(c, d, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tsmoothstep(0.0, 1.0, f.y)));\n\n\t// Same code, with the clamps in smoothstep and common subexpressions\n\t// optimized away.\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n// This one has non-ideal tiling properties that I'm still tuning\nfloat noise(vec3 x) {\n\tconst vec3 step = vec3(110, 241, 171);\n\n\tvec3 i = floor(x);\n\tvec3 f = fract(x);\n \n\t// For performance, compute the base input to a 1D hash from the integer part of the argument and the \n\t// incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(i, step);\n\n\tvec3 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nfloat noiseOctaves(vec3 x) {\n    return\n        noise(x) + \n        noise(x*2.0+x)*0.5 + \n        noise(x*4.0+x*2.0)*0.25 + \n        noise(x*8.0+x*4.0)*0.125;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    float col = noiseOctaves(vec3(uv*3.0+vec2(-iTime*0.05,iTime*0.01),iTime*0.1))-1.0;\n    float isRain = clamp(col*1000.0,0.0,1.0);\n    float isStorm = clamp((col-0.5)*1000.0,0.0,1.0);\n\n    // Output to screen\n    fragColor = vec4(isStorm,0.0,isRain,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tKfRc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tKfRw", "name": "Approx. Cubic Spline Distance", "author": "nr4", "description": "Approximate cubic bezier spline distance for rendering SVGs.\nTechnique is interval approximation. Also tried power series approximation (glitches). I expect that the discontinuities in the more far away regions can be removed with polynomial division.", "tags": ["sdf", "bezier", "approximation", "spline", "distance", "cubic", "quadratic"], "likes": 4, "viewed": 226, "date": "1543584690", "time_retrieved": "2024-06-20T19:24:06.722034", "image_code": "/*\n * Approx. Cubic Spline Distance\n * \n * Copyright (C) 2018  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n// Update 1: Optimizations\n\n// Switch between cubic and quadratic splines here.\n//#define QUADRATIC\n#define CUBIC\n\nconst vec2 k = vec2(1.,0.);\nconst float pi = acos(-1.);\n\nvec2 B2(float t, vec2 P0, vec2 P1, vec2 P2)\n{\n    float m1 = 1.-t;\n    return m1*m1*P0 + 2.*m1*t*P1 + t*t*P2;\n}\n\nvec2 B2Prime(float t, vec2 P0, vec2 P1, vec2 P2)\n{\n    return 2.*((1.-t)*(P1-P0)+t*(P2-P1));\n}\n\nfloat D2(vec2 x, float t, vec2 P0, vec2 P1, vec2 P2)\n{\n    return length(x-B2(t, P0, P1, P2));\n}\n\nfloat D2Prime(vec2 x, float  t, vec2 P0, vec2 P1, vec2 P2)\n{\n    return dot(x-B2(t,P0,P1,P2), B2Prime(t, P0,P1,P2));\n}\n\nvec2 B3(float t, vec2 P0, vec2 P1, vec2 P2, vec2 P3)\n{\n    float m1 = 1.-t;\n    return m1*m1*m1*P0 + 3.*m1*t*(m1*P1+t*P2) + t*t*t*P3;\n}\n\nvec2 B3Prime(float t, vec2 P0, vec2 P1, vec2 P2, vec2 P3)\n{\n    float m1 = 1.-t;\n    return 3.*(m1*m1*(P1-P0)+2.*m1*t*(P2-P1)+t*t*(P3-P2));\n}\n\nfloat D3(vec2 x, float t, vec2 P0, vec2 P1, vec2 P2, vec2 P3)\n{\n    return length(x-B3(t, P0, P1, P2, P3));\n}\n\nfloat D3Prime(vec2 x, float  t, vec2 P0, vec2 P1, vec2 P2, vec2 P3)\n{\n    return dot(x-B3(t,P0,P1,P2,P3), B3Prime(t,P0,P1,P2,P3));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 1.*(fragCoord/iResolution.yy-.5);\n    \n    // Control points.\n    vec2 p_0 = vec2(-.25,-.25)+.15*vec2(sin(iTime), cos(3.*iTime)), \n        p_1 = vec2(.25,-.25)+.5*vec2(sin(iTime), .5-sin(iTime)),\n        p_2 = vec2(.25,.25)+.15*vec2(cos(iTime), sin(iTime)),\n    \tp_3 = vec2(.65,.35)+.15*vec2(sin(iTime), cos(iTime));\n\n    float tmin = 0., tmax = 1., tnew, \n#ifdef QUADRATIC\n        dmin = D2Prime(uv,tmin,p_0,p_1,p_2), \n        dmax = D2Prime(uv,tmax,p_0,p_1,p_2),\n#else\n        dmin = D3Prime(uv,tmin,p_0,p_1,p_2,p_3),\n        dmax = D3Prime(uv,tmax,p_0,p_1,p_2,p_3),\n#endif\n        dnew;\n    \n    // Solve for polynomial roots with interval approximation.\n    for(int i=0; i<10; ++i)\n    {\n        // Compute t and distance for the new test parameter tnew\n        tnew = mix(tmin, tmax, .5);\n#ifdef QUADRATIC\n        dnew = D2Prime(uv,tnew,p_0,p_1,p_2);\n#else\n        dnew = D3Prime(uv,tnew,p_0,p_1,p_2,p_3);\n#endif\n        \n        if(dnew>0.)\n        {\n            tmin = tnew;\n            dmin = dnew;\n        }\n        else \n        {\n            tmax = tnew;\n            dmax = dnew;\n        }\n    }\n        \n    // Cap at the ends of the spline\n    tmin = clamp(tmin, 0., 1.);\n    \n    // Compute distance\n#ifdef QUADRATIC\n    dmin = D2(uv, tmin, p_0, p_1, p_2);\n#else\n    dmin = D3(uv, tmin, p_0, p_1, p_2, p_3);\n#endif\n    \n    vec3 col = k.yyy;\n    \n    // Draw distance isolines\n    col += (0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)))*mod(dmin,0.1)*10.+vec3(1.,0.,0.)*step(dmin,.05);\n    // Draw control points\n    col += k.yxx*step(length(uv-p_0), .05)+k.xyx*step(length(uv-p_1), .05)+k.yxx*step(length(uv-p_2), .05);\n    \n#ifdef CUBIC\n    col += k.yxy*step(length(uv-p_3), .05);\n#endif\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tKfRw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tKfzW", "name": "Object/Light/Camera animation", "author": "dacruzquen", "description": "animation", "tags": ["animation"], "likes": 0, "viewed": 79, "date": "1542014371", "time_retrieved": "2024-06-20T19:24:07.907423", "image_code": "//link : https://www.shadertoy.com/view/4slcDM\n\n//Material\nstruct Material\n{\n    float Ka;\n    float Kd;\n    float Ks;\n    float Kn;\n};\n\n//camera parameters\nvec3 cameraPos = vec3(6,4,-5);\nconst vec3 cameraTarget = vec3(3,1,-8);\nconst float cameraFovY = 80.0; // Note: angle is degree\n\n//Sphere parameters\nvec3 spherePos = cameraTarget + vec3(0,1,2);\nconst float sphereRadius = 1.0;\nconst vec3 sphereCol = vec3(1,0,0);\nconst Material sphereMat = Material(0.2,0.7,1.0,50.0);\nconst int sphereId = 1;\n\n//Light parameters\nconst vec3 ambiantCol = vec3(0,0,1);\nconst vec3 lightCol = vec3(1,1,1);\nvec3 lightPos = vec3(8,10,-12);\n\n//Sky parameters\nconst vec3 skyCol = vec3(0);\nconst int skyId = 0;\n\n//Plane parameters\nconst vec3 planePos = vec3(0, 0.1, 0);\nconst vec3 planeNormal = vec3(0,1.0,0);\nconst vec3 planeCol1 = vec3(1.0);\nconst vec3 planeCol2 = vec3(0.4);\nconst Material planeMat = Material(0.2,1.0,0.2,5.0);\nconst int planeId = 2;\n\nvec2 transform_to_apply(vec2 xy){\n    xy = (2.*xy.xy - iResolution.xy)/iResolution.y;\n    return vec2(xy.x,xy.y);\n}\n\nfloat raySphere(vec3 rayPos, vec3 rayDir, vec3 spherePos, float sphereRadius, out vec3 intersecS, out vec3 normalS)\n{    \n    vec3 diff = rayPos - spherePos;\n    \n    float a = dot(rayDir,rayDir);\n    float b = 2.0 * dot(diff,rayDir);\n    float c = dot(diff,diff) - sphereRadius * sphereRadius;\n    \n    float di = b*b - 4.0*a*c;\n    \n    if(di >= 0.0)\n    {\n        float sdi = sqrt(di);\n        float den = 1.0 / (2.0 * a);\n        float t1 = (-b - sdi) * den;\n        float t2 = (-b + sdi) * den;\n        \n        intersecS = rayPos + t1 * rayDir;\n        normalS = normalize(intersecS - spherePos);\n        \n        return t1;\n    }\n    \n    return -1.;\n}\n\nfloat rayPlane(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal, out vec3 intersecPt, out vec3 normal)\n{\n    if(dot(rayDir,planeNormal)!=0.0)\n    {\n        float t = dot(planePos - rayPos,planeNormal)/dot(rayDir,planeNormal);\n        \n        intersecPt = rayPos + t * rayDir;\n        normal = planeNormal;\n        \n        return t;\n    }\n    return -1.0;\n}\n\nvoid computeCameraRayFromPixel(in vec2 pixCoord, out vec3 rayPos, out vec3 rayDir)\n{\n    rayPos = cameraPos;\n    \n    float f = 1./tan(radians(cameraFovY)/2.);\n    \n    vec3 PT = cameraTarget - cameraPos;\n    vec3 cz = normalize(PT);\n    \n    vec3 PO = f*cz;\n    \n    vec3 cyT = vec3(0,-1.,0);\n    vec3 cxT = cross(cyT,cz);\n    \n    vec3 cx = normalize(cxT);\n    \n    vec3 cy = cross(cz,cx);\n    \n    vec3 OS = pixCoord.x * cx - pixCoord.y * cy;\n    \n    rayDir = normalize(PO+OS);\n}\n\nvec3 computePhongShading(vec3 sphereCol, Material sphereMat,float shadowFactor, vec3 normal, vec3 L, vec3 R, vec3 V)\n{\n    vec3 A = sphereMat.Ka * ambiantCol;\n    vec3 D = sphereMat.Kd * sphereCol * lightCol * max(dot(L,normal),0.0);\n    vec3 S = sphereMat.Ks * lightCol * pow(max(dot(R,V),0.0),sphereMat.Kn);\n    return A+shadowFactor*D+shadowFactor*S;\n}\n\n//The aim of this routine is to find the nearest intersection the ray has with all objects\nfloat computeNearestIntersection(vec3 rayPos, vec3 rayDir, out int objectId, out vec3 intersecI, out vec3 normalI)\n{\n    vec3 intersecS, normalS;\n    float distSphere = raySphere(rayPos, rayDir, spherePos, sphereRadius, intersecS, normalS);\n    vec3 intersecP, normalP;\n    float distPlane = rayPlane(rayPos, rayDir, planePos, planeNormal, intersecP, normalP);\n    if(distSphere > 0.0 && distPlane > 0.0)\n    {\n        float distMin = min(distSphere,distPlane);\n        objectId = (distSphere == distMin) ? sphereId : planeId; \n        intersecI = (distSphere == distMin) ? intersecS : intersecP; ;\n        normalI = (distSphere == distMin) ? normalS : normalP; ;\n        return distMin;\n    }\n    else\n    {\n        if(distSphere > 0.0)\n        {\n            objectId = sphereId;\n            intersecI = intersecS;\n            normalI = normalS;\n            return distSphere;\n        }\n        else if (distPlane > 0.0)\n        {\n            objectId = planeId;\n            intersecI = intersecP;\n            normalI = normalP;\n            return distPlane;\n        }\n        else\n        {\n           \tobjectId = skyId;\n            return -1.0;\n        }\n    }\n}\n\nvec3 getSphereColorAtPoint(vec3 pt)\n{\n    return sphereCol;\n}\n\n//pt is assumed to be on the place surface\nvec3 getPlaneColorAtPoint(vec3 pt)\n{\n    return mod(floor(pt.x*0.5) + floor(pt.z*0.5),2.0) < 1.0 ? planeCol1 : planeCol2;\n}\n\nvec3 getObjectColorAtPoint(int objectId, vec3 pt, out Material objectMat)\n{\n    switch(objectId)\n    {\n        case 0:\n        \treturn skyCol;\n        case 1:\n        \tobjectMat = sphereMat;\n        \treturn getSphereColorAtPoint(pt);\n        case 2:\n        \tobjectMat = planeMat;\n        \treturn getPlaneColorAtPoint(pt);\n    }\n}\n\nfloat getShadowFactorAtPoint(vec3 I, vec3 N, Material objectMat, vec3 L, float Ldist)\n{\n    I += 0.001*N;\n    int objId;\n    vec3 intersecS, normalS;\n    float d = computeNearestIntersection(I,L,objId,intersecS,normalS);\n    return (d<=0.0 || d>=Ldist)?1.0:objectMat.Ka;\n}\n\nvoid animateScene(float time)\n{\n    const float pi = 3.1415926535;\n    const float rs = 2.0;\n    const float spr = 5.0;\n    float as = 2.0 * pi * time / spr;\n    \n    spherePos = cameraTarget + rs * vec3(-sin(as),0.0,cos(as)) + vec3(0,1,0);\n    \n    lightPos += vec3(0,10.5 + 9.5 * cos(time) - 10.,0);\n    \n    float targetDist = length(cameraTarget - cameraPos);\n    cameraPos -= vec3(0,0,targetDist);\n    cameraPos += targetDist * vec3(sin(time),max(sin(time*0.5),0.),cos(time));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    \n    animateScene(time*1.0);\n    \n    //Apply change of coordinates from pixel\n    fragCoord = transform_to_apply(fragCoord.xy);\n    \n    // Compute the ray to be casted through the pixel towards the 3D scene\n    vec3 rayPos, rayDir;\n    computeCameraRayFromPixel(fragCoord, rayPos, rayDir);\n    \n    int objId;\n    vec3 intersec, normal;\n   \tfloat dist = computeNearestIntersection(rayPos, rayDir, objId, intersec, normal);\n    Material objMat;\n    vec3 col = getObjectColorAtPoint(objId, intersec, objMat);\n    \n    if(dist > 0.0)\n    {        \n    \t//Unit vector from the surface point towards the light\n    \tvec3 L = normalize(lightPos - intersec);\n        \n    \t//Unit vector of the reflection direction\n    \tvec3 R = normalize(2.0*dot(normal,L)*normal - L);\n        \n    \t//Unit vector going from the surface point towards the camera\n    \t//vec3 V = normalize(cameraPos - intersecS);\n    \tvec3 V = -rayDir;\n        \n        float Ldist = distance(intersec,lightPos);\n        \n        float shadowFactor = getShadowFactorAtPoint(intersec, normal, objMat, L, Ldist);\n        \n    \t//Phong shading to get the color of the surface point\n    \tfragColor = vec4(computePhongShading(col, objMat, shadowFactor, normal, L, R, V), 1);\n    }\n    \n    else //We didn't hit the sphere so background\n        fragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tKfzW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4ttyRB", "name": "Wobbly grid", "author": "toocanzs", "description": "One of the first raymarching shaders I've made that actually looks pretty cool. The idea came from watching this video https://youtu.be/QDfqgG8HJDQ?t=748 I wanted to test myself and see if I could create something similar ", "tags": ["simple", "raymarch", "sdf"], "likes": 6, "viewed": 264, "date": "1543172977", "time_retrieved": "2024-06-20T19:24:07.907423", "image_code": "#define PI 3.1415926535\n#define EPSILON 0.001\n#define FAR 1000.\nmat2 rot( in float a ) {\n    float c = cos(a);\n    float s = sin(a);\n\treturn mat2(c,s,-s,c);\t\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdBox( vec2 p, vec2 b )\n{\n  vec2 d = abs(p) - b;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCross( in vec3 p, float size)\n{\n  float da = sdBox(p.xy,vec2(size));\n  float db = sdBox(p.yz,vec2(size));\n  float dc = sdBox(p.zx,vec2(size));\n  return min(da,min(db,dc));\n}\n\n#define PILLAR_SEP 160.\n#define PILLAR_WIDTH 10.\n#define FAME_SIZE 1.\n\nfloat frame(vec3 p)\n{\n    float d;\n    d = sdBox(p, vec3(FAME_SIZE));\n    d = max(d, -sdCross(p, FAME_SIZE*0.5));\n    return d;\n}\n\nfloat grid(vec3 q)\n{\n    q = mod(q,2.)-0.5*2.;\n    return frame(q);\n}\n\nfloat gridCross(vec3 q)\n{\n    float d;\n    q = mod(q, PILLAR_SEP)- 0.5*PILLAR_SEP;\n    d = grid(q);\n    d = max(sdCross(q, PILLAR_WIDTH), d);\n    return d;\n}\n\n\nfloat map(vec3 p)\n{\n    float d;\n   \tp.y += sin(p.x*0.0141231 + iTime*1.03123)*4.;\n    p.x += sin(p.z*0.0323124 + iTime*0.8345)*7.;\n    p.z += sin(p.x*0.022345 + iTime*0.73245)*6.;\n    vec3 q = p;\n    \n    \n    d = gridCross(q);\n    q += vec3(-PILLAR_WIDTH,-PILLAR_WIDTH*3.,-PILLAR_WIDTH);\n    q = mod(q , PILLAR_WIDTH*2.) - 0.5 * PILLAR_WIDTH*2.;\n    d = max(-sdCross(q, 6.), d);\n    return d;\n}\n#define steps 128\nfloat march(vec3 o, vec3 r, out float m)\n{\n    float t = 0.;\n    int i = 0;\n    for(i; i < steps; i++)\n    {\n        vec3 p = o + r * t;\n        float d = map(p);\n        if(d < EPSILON || t > FAR)\n        {\n            break;\n        }\n        t += d * 0.4;\n    }\n    m = float(i);\n    return min(FAR, t);\n}\n\nvec3 getNormal(vec3 pos)\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( 2.*fragCoord - iResolution.xy )/ iResolution.y;\n    vec3 o = vec3(0,0,iTime*20.);\n    vec3 r = normalize(vec3(uv,1.));\n    \n    float m;\n    float d = march(o,r,m);\n    \n    vec3 fogCol = vec3(0.5,0.7,0.9)*0.7;\n    \n    vec3 col = vec3(fogCol);\n    float l = 1.-smoothstep(0., .95, d/FAR);\n    if(d < FAR)\n    {\n        m = (m / float(steps)) + 0.01;\n        float fog = (1.0 / (1.0 + m*m * 10.));\n        \n        col = vec3(fog);\n    }\n\tcol = mix(vec3(fogCol), col, l);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ttyRB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tVBDm", "name": "Infinity Birthday Crystal", "author": "khlorghaal", "description": "For my friend\nLambert flavored", "tags": ["volume", "raymarch", "cube"], "likes": 4, "viewed": 160, "date": "1542795337", "time_retrieved": "2024-06-20T19:24:07.907423", "image_code": "#define ETA 1e-5\n\n#define PI 3.14159265359\n#define TAU (PI*2.)\n\n#define time float(iTime)\n\n#define ITERS 512\n\nprecision highp float;\n\nvec3 sumv(vec2 v){ return vec3(dot(v,vec2(1))); }\nvec3 sumv(vec3 v){ return vec3(dot(v,vec3(1))); }\nvec3 sumv(vec4 v){ return vec3(dot(v,vec4(1))); }\nfloat sums(vec2 v){ return dot(v,vec2(1)); }\nfloat sums(vec3 v){ return dot(v,vec3(1)); }\nfloat sums(vec4 v){ return dot(v,vec4(1)); }\n\n#define CA vec4(\\\n    3411.23,\\\n    3415.23,\\\n    3421.34,\\\n    3401.34)\n#define CB vec4(\\\n    5061.11,\\\n    5021.43,\\\n    5043.13,\\\n    5051.13)\nfloat rand41(vec4 x){\n    return fract(\n        sin(sin(dot(x,CB))*CA.x)\n    );\n}\nfloat rand31(vec3 x){\n    return fract(\n        sin(sin(dot(x,CB.xyz))*CA.x)\n    );\n}\n\nvec3 f(vec3 p){\n    p= mod(p,1.);\n        \n    vec3 n= p-.5;\n    n= normalize(n);\n        \n    vec3 sn= .25-p;\n    vec3 sp= p-.75;\n\tif(sn.x>0.||sp.x>0.||\n       sn.y>0.||sp.y>0.||\n       sn.z>0.||sp.z>0.)\n        return vec3(0.);\n    //todo planar cut\n    return n;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv= fragCoord/iResolution.xy;\n    vec2 uvn= uv*2.-1.;\n    uvn.x*= iResolution.x/iResolution.y;\n    \n    vec2 xy= uvn;\n    #define FOG vec3(.1,.5,.95)\n    vec3 c= FOG;\n    \n\tfloat t= .5;\n    for(int i=0; i!=ITERS; i++){\n        t+= .008*(t+1.);\n        vec3 p= vec3(xy*.5,1.)*t;\n        \n    \tp+= time*vec3(.0,.0, 1.0);\n        \n        /* wind is bad for cake\n        vec3 wind= vec3(\n        noise( vec4(p,time   ),vec4(.2,.1,.1,1.)),\n        noise( vec4(p,time+4.),vec4(.2,.1,.1,1.)),\n        noise( vec4(p,time+8.),vec4(.2,.1,.1,1.))\n        );\n        p+= wind*.2;\n        */\n        \n        #define ICING vec3(.95)\n        #define CAKE vec3(0.91,.9,.35)\n        #define SPRINKLE_RED vec3(0.9,.15,.15)\n        #define SPRINKLE_GREN vec3(0.25,.87,.25)\n        #define SPRINKLE_CYAN vec3(0.3,.6,1.)\n        #define SPRINKLE_PURP vec3(0.4,.1,.8)\n        \n        vec3 norm= f(p);\n        \n        if(norm!=vec3(0.)){\n            float lum= dot(norm,normalize(vec3(1.,1.,-1.)));//lambert flavored\n            //how to analyticly calculate a bounce map for infinite cubes?\n            lum= lum*.5+.6;\n            \n            vec3 color;\n            vec3 colors[]= vec3[]( ICING,ICING,ICING,ICING,ICING,ICING,\n                                  SPRINKLE_RED,SPRINKLE_GREN,SPRINKLE_CYAN,SPRINKLE_PURP );\n            float ci= rand31(floor(p*32.));\n            color= colors[int((float(colors.length())-.5)*ci)];\n            \n            float foga= clamp(t/10., 0.,1.);\n            color= foga<.3? color:ICING;\n            \n            color= pow(color, vec3(2.2));\n            \n            c= color*lum;\n            \n            float fogb= clamp(t/90.-.125, 0.,1.);\n            c= mix(c,FOG, fogb);\n            \n            break;\n        }\n    }\n    c= pow(c,vec3(1./2.2));\n    fragColor= vec4(c,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tVBDm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tVBDz", "name": "[twitch] Desert Bus", "author": "yx", "description": "Coded live on twitch stream in Bonzomatic, and tidied/ported to shadertoy.\nUnedited Bonzomatic shader here: [url]https://gist.github.com/willkirkby/a29771548a7d7ca931b83c5c15bff83b[/url]\nMade in recognition of Desert Bus For Hope.", "tags": ["twitch", "desertbus"], "likes": 21, "viewed": 4364, "date": "1542235672", "time_retrieved": "2024-06-20T19:24:09.089347", "image_code": "const float pi = acos(-1.);\nconst float SPEED = 3.;\nconst float BUSSTOP_WAVELENGTH = 1000.;\n\nvec2 rotate(vec2 a, float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x * c - a.y * s,\n        a.x * s + a.y * c\n    );\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n    vec3 d = abs(p) - b;\n    return length(max(d,0.0)) - r\n        + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdCylinder(vec3 p, float r)\n{\n    return length(p.xy) - r;\n}\n\nfloat sdCappedCylinder(vec3 p, float r, float h, float steer)\n{\n    p.xz = rotate(p.xz, steer);\n    return max(sdCylinder(p, r), abs(p.z)-h);\n}\n\nfloat bettersin(float a)\n{\n    return sin(a*pi*2.-.5*pi)*.5+.5;\n}\n\nvec2 steering(float time)\n{\n    time = mod(time, 8.);\n    float t;\n    if (time < 7.)\n        t = (time / 7.);\n    else\n        t = 1.-(time-7.);\n    return vec2(\n        smoothstep(0.,1.,t)*2.-1.,\n        time>7.?bettersin(t)*.5:0.\n    );\n}\n\nfloat shadowscene(vec3 p)\n{\n    vec2 steer = steering(iTime);\n\n    vec3 bp = p;\n    bp.y += sin(iTime*10.)*.03;\n    bp.z += steer.x;\n    float bus = sdRoundBox(bp-vec3(0,-.1,0), vec3(4.,.8,1)-.1, .3);\n\n    float ground = p.y + 1.5;\n    ground = max(ground, length(p+vec3(0,1.5,0))-7.);\n\n    return min(bus, ground);\n}\n\nvec2 scene(vec3 p)\n{\n    vec2 steer = steering(iTime);\n\n    vec3 bp = p;\n    bp.y += sin(iTime*10.)*.03;\n    bp.z += steer.x;\n    float bus = sdRoundBox(bp-vec3(0,-.1,0), vec3(4.,.8,1)-.1, .3);\n    bus = max(bus, -sdCylinder(bp - vec3(3,-1,0), .5));\n    bus = max(bus, -sdCylinder(bp - vec3(-3,-1,0), .5));\n    bus = max(bus, -sdCylinder(bp - vec3(-2,-1,0), .5));\n\n    vec3 wp = p;\n    wp.z += steer.x;\n    wp.z = abs(wp.z);\n    wp.z -= 1.;\n    float wheels = 1000.;\n    wheels = min(wheels, sdCappedCylinder(wp - vec3( 3,-1,0), .4, .2, steer.y));\n    wheels = min(wheels, sdCappedCylinder(wp - vec3(-3,-1,0), .4, .2, 0.));\n    wheels = min(wheels, sdCappedCylinder(wp - vec3(-2,-1,0), .4, .2, 0.));\n\n    float hubcaps = 1000.;\n    hubcaps = min(hubcaps, sdCappedCylinder(wp - vec3( 3,-1,0), .17, .3, steer.y));\n    hubcaps = min(hubcaps, sdCappedCylinder(wp - vec3(-3,-1,0), .17, .3, 0.));\n    hubcaps = min(hubcaps, sdCappedCylinder(wp - vec3(-2,-1,0), .17, .3, 0.));\n\n    float windows = sdRoundBox(bp - vec3(4,.1,0), vec3(.8,.3,.8), .1);\n    windows = min(windows, sdRoundBox(bp - vec3(2.8 +bp.y*.7,.1,0), vec3(.5,.3,2), .1));\n    windows = min(windows, sdRoundBox(bp - vec3(1.4 +bp.y*.7,.1,0), vec3(.5,.3,2), .1));\n    windows = min(windows, sdRoundBox(bp - vec3(     bp.y*.7,.1,0), vec3(.5,.3,2), .1));\n    windows = min(windows, sdRoundBox(bp - vec3(-1.4+bp.y*.7,.1,0), vec3(.5,.3,2), .1));\n    windows = min(windows, sdRoundBox(bp - vec3(-2.8+bp.y*.7,.1,0), vec3(.5,.3,2), .1));\n\n    float ground = p.y + 1.5;\n    ground = max(ground, length(p+vec3(0,1.5,0))-7.);\n\n    vec3 bsp = p;\n    float bst = mod(iTime*SPEED*5., BUSSTOP_WAVELENGTH)-BUSSTOP_WAVELENGTH*.5;\n    float busstop = sdCappedCylinder(bsp.xzy+vec3(bst,4.2,.5), .05, 1., 0.);\n    busstop = min(busstop, sdCappedCylinder(bsp.yzx+vec3(-.9,4.2,bst), .4, .05, 0.));\n    busstop = max(busstop, sdCylinder(bsp.xzy, 7.));\n\n    float mat = 0.;\n    float best = 1000.;\n    if (ground < best) { mat = 1.; best = ground; }\n    if (bus < best) { mat = 2.; best = bus; }\n    if (wheels < best) { mat = 3.; best = wheels; }\n    if (busstop < best) { mat = 5.; best = busstop; }\n\n    if (mat == 2. && windows < bus)\n        mat = 4.;\n\n    if (mat == 3. && hubcaps < wheels)\n        mat = 2.;\n\n    return vec2(\n        best,\n        mat\n    );\n}\n\nfloat sdCircle(vec2 uv, float r)\n{\n    return length(uv)-r;\n}\n\nfloat sceneLRR(vec2 uv)\n{\n    uv.y -= .3;\n    float circles = min(\n        min(\n            sdCircle(uv+vec2(.14,0), .033),\n            sdCircle(uv+vec2(.24,0), .033)\n        ),\n        min(\n            sdCircle(uv+vec2(.34,0), .033),\n            sdCircle(uv+vec2(-.03,0), .1)\n        )\n    );\n    uv.y = abs(uv.y);\n    float chevron = dot(vec3(uv,1),vec3(1,2.3,-.4));\n    chevron = max(.1-uv.x, chevron);\n    chevron = max(-sdCircle(uv+vec2(-.05,0), .15), chevron);\n\n    return min(chevron, circles);\n}\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 cam = vec3(0,0,-15);\n    vec3 dir = normalize(vec3(uv,1));\n\n    cam.yz = rotate(cam.yz, .3);\n    dir.yz = rotate(dir.yz, .3);\n\n    cam.xz = rotate(cam.xz, pi/3.);\n    dir.xz = rotate(dir.xz, pi/3.);\n\n    float t=0.;\n    vec2 k=vec2(0);\n    for(int i=0;i<100;++i)\n    {\n        k=scene(cam+dir*t);\n        t+=k.x;\n        if (k.x<.001)\n            break;\n    }\n    vec3 h = cam+dir*t;\n    vec2 o = vec2(.01, 0);\n    vec3 n = normalize(vec3(\n        scene(h+o.xyy).x-scene(h-o.xyy).x,\n        scene(h+o.yxy).x-scene(h-o.yxy).x,\n        scene(h+o.yyx).x-scene(h-o.yyx).x\n    ));\n    out_color.rgb = n*.5+.5;\n    //out_color.rgb = fract(h);\n\n    if (k.x > 1.)\n        k.y = 0.;\n\n    float fakeAO = shadowscene(h+n*.8)/.8;\n    fakeAO = clamp(fakeAO, 0., 1.) * .4 + .6;\n\n\n    vec3 albedo = vec3(1);\n    float mat = k.y;\n    if (mat == 0.)\n    { // sky\n        float d = sceneLRR(uv);\n        vec3 light = vec3(.4,.6,1);\n        vec3 dark  = vec3(.1,0,.6);\n        out_color.rgb = mix(light, dark, smoothstep(-.001, .001, d));\n        return;\n    }\n    else if (mat == 1.)\n    { // ground\n        h.z = abs(h.z);\n\n        albedo = vec3(.9, .6, 0);\n\n        if (h.z < 3.2 && h.y > -1.6)\n            albedo = vec3(.4);\n        else if (h.z < 4. && h.y > -1.6)\n            albedo = vec3(.6,.4,0);\n\n            if (h.z < .3 && fract(h.x*.2+iTime*SPEED) < .5 && h.y > -1.6)\n                albedo = vec3(1,.9,.2);\n            }\n    else if (mat == 2.)\n    { // bus\n        albedo = vec3(.7,.8,.9);\n    }\n    else if (mat == 3.)\n    { // wheels\n        albedo = vec3(.1);\n    }\n    else if (mat == 4.)\n    { // windows\n        albedo = vec3(.1);\n    }\n    else if (mat == 5.)\n    { // busstop\n        albedo = h.y > .5 ? vec3(1,0,0) : vec3(.8);\n    }\n\n    float light = dot(n, normalize(vec3(2,3,1)))*.5+.5;\n\n    out_color.rgb = albedo * light * fakeAO;\n\n    //out_color = vec4(step(screenUV.y, steering(screenUV.x * 8)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tVBDz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tVBR1", "name": "Triforce", "author": "surma", "description": "Much shader, very animation, wow.", "tags": ["zelda", "trifoce"], "likes": 5, "viewed": 624, "date": "1541822307", "time_retrieved": "2024-06-20T19:24:10.065082", "image_code": "#define PI 3.14159\n\nfloat fsin(float f, float t) {\n  return sin(t/f * 2.0 * PI);\n}\n\n\nfloat psin(float f, float t) {\n  return fsin(f, t) * 0.5 + 0.5;\n}\n\nfloat minmaxsin(float min, float max, float f, float t) {\n  return psin(f, t) * (max - min) + min;\n}\n\nfloat spike(float steepness, float at, float x) {\n  return exp(-pow(x-at, 2.0) * steepness);\n}\n\nfloat bezier1(float p1, float p2, float t) {\n  return 0.0 + 3.0*pow(1.0-t, 2.0)*t*p1 + 3.0*(1.0-t)*pow(t, 2.0)*p2 + pow(t, 3.0);\n}\n\nvec2 bezier2(vec2 p1, vec2 p2, float t) {\n  return vec2(\n    bezier1(p1.x, p2.x, t),\n    bezier1(p1.y, p2.y, t)\n  );\n}\n\nfloat bezier(vec2 p1, vec2 p2, float x0) {\n  float t = 0.5;\n  vec2 p;\n  for(int i = 1; i < 10; i++) {\n    p = bezier2(p1, p2, t);\n    if(p.x < x0) {\n      t += pow(2.0, float(-i));\n    } else {\n      t -= pow(2.0, float(-i));\n    }\n  }\n  return bezier2(p1, p2, t).y;\n}\n\nmat3 translate(vec2 d) {\n  return mat3(\n    1.0, 0.0, 0.0,\n    0.0, 1.0, 1.0,\n    -d.x, -d.y, 1.0\n  );\n}\n\nmat3 rotate(float alpha) {\n  return mat3(\n    cos(alpha), sin(alpha), 0.0,\n    -sin(alpha), cos(alpha), 0.0,\n    0.0, 0.0, 1.0\n  );\n}\n\nmat3 scale(vec2 s) {\n  return mat3(\n    s.x, 0.0, 0.0,\n    0.0, s.y, 1.0,\n    0.0, 0.0, 1.0\n  );\n}\n\nfloat sdHalfplane(vec2 normal, vec2 o, vec2 p) {\n  return dot(normal, -o-p);\n}\n\nvec2 sdTranslate(vec2 delta, vec2 p) {\n  return p + delta;\n}\n\nfloat sdUnion3(float f1, float f2, float f3) {\n  return min(min(f1, f2), f3);\n}\n\n\nfloat sdIntersection3(float f1, float f2, float f3) {\n  return max(max(f1, f2), f3);\n}\n\nfloat deg2rad(float deg) {\n  return deg/360.0 * 2.0 * PI;\n}\n\nfloat sdTriangle(float size, vec2 p) {\n  return sdIntersection3(\n\tsdHalfplane(\n      vec2(\n        cos(deg2rad(0.0)), \n        sin(deg2rad(0.0))\n      ), \n      vec2(\n        cos(deg2rad(0.0))*size, \n        sin(deg2rad(0.0))*size\n      ), \n      p\n    ),\n    sdHalfplane(\n      vec2(\n        cos(deg2rad(120.0)), \n        sin(deg2rad(120.0))\n      ), \n      vec2(\n        cos(deg2rad(120.0))*size,\n        sin(deg2rad(120.0))*size\n      ), \n      p\n    ),\n    sdHalfplane(\n      vec2(\n        cos(deg2rad(240.0)), \n        sin(deg2rad(240.0))\n      ), \n      vec2(\n        cos(deg2rad(240.0))*size,\n        sin(deg2rad(240.0))*size\n      ), \n      p\n    )\n  );\n}\n\nvec2 rotatePoint(vec2 o, float angle, vec2 p) {\n  return sdTranslate(-o, (rotate(angle) * vec3(sdTranslate(o, p), 1.0)).xy);\n}\n\nfloat maxTime = 5.0;\n\nfloat time() {\n  return mod(iTime, maxTime);\n}\n\nfloat subTimeline(float start, float end) {\n  return (clamp(\n    time(),\n    start,\n    end\n  ) - start) / (end - start);\n}\n\nfloat triangleRotateTimeline() {\n  float t = subTimeline(2.0, 3.0);\n  \n  return bezier(vec2(0.7, 0.0), vec2(0.3, 1.0), t) * (360.0 + 120.0);\n}\n\nfloat step2(float e1, float e2, float t) {\n  return step(e1, t) * (1.0 - step(e2, t));\n}\n\nvec2 triangleTranslateTimeline(vec2 start, vec2 end) {\n  float t1 = subTimeline(1.3, 2.0);\n  float t2 = 1.0 - subTimeline(3.0, 3.7);\n  \n  float t = step2(1.3, 2.0, time())*t1 + step2(3.0, 3.7, time())*t2 + step2(2.0, 3.0, time());\n\n  return mix(\n    start,\n    end,\n    bezier(vec2(0.7, 0.0), vec2(0.3, 1.0), t)\n  );\n}\n\nfloat sdWorld(vec2 p) {\n  float outset = 1.5;\n  float size = 50.0;\n  float side = 2.0 * size * sqrt(3.0);\n  p = rotatePoint(vec2(0.0), deg2rad(90.0), p);\n  \n  vec2 t1 = rotatePoint(vec2(0.0), deg2rad(0.0), vec2(2.0*size, 0.0));\n  vec2 t2 = rotatePoint(vec2(0.0), deg2rad(120.0), vec2(2.0*size, 0.0));\n  vec2 t3 = rotatePoint(vec2(0.0), deg2rad(240.0), vec2(2.0*size, 0.0));\n\n  float r = deg2rad(triangleRotateTimeline() + 60.0);\n  return sdUnion3(\n    sdTriangle(size, rotatePoint(vec2(0.0), r, sdTranslate(triangleTranslateTimeline(t1, outset*t1),  p))),\n    sdTriangle(size, rotatePoint(vec2(0.0), r, sdTranslate(triangleTranslateTimeline(t2, outset*t2), p))),\n    sdTriangle(size, rotatePoint(vec2(0.0), r, sdTranslate(triangleTranslateTimeline(t3, outset*t3), p)))\n  );\n}\n\nmat3 camera(vec2 pos, float s, float alpha) {\n  return rotate(alpha) * scale(vec2(s)) * translate(pos);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 pixel) {\n  float radiance = 50.0;\n  float ripples = 10.0;\n  vec2 center = iResolution.xy/2.0;\n  mat3 cameraT = camera(center, 1.0, 0.0);\n  pixel = (cameraT * vec3(pixel, 1.0)).xy;\n\n  float d = sdWorld(pixel);\n  fragColor = mix(\n    vec4(vec3(0.2), 1.0),\n    mix(\n      vec4(vec3(0.8), 1.0),\n      vec4(vec3(0.6), 1.0),\n      spike(3.0, 3.0, mod(d - iTime*10.0, ripples))* clamp(0.0, radiance, radiance-d)/radiance\n    ),\n    clamp(0.0, 1.0, d)\n  );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tVBR1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tVBzD", "name": "a new era (126 bytes)", "author": "HellMood", "description": "This is a port of [url=https://www.pouet.net/prod.php?which=78044]into a new era 64b[/url]  to shadertoy, using the binary operations available in WebGL 2.0. If chrome doesn't compile,  enable WebGL2. You're invited to help me shrink the size of this =)", "tags": ["raycaster", "onetweet", "golf", "sizecoding", "x86port"], "likes": 10, "viewed": 1139, "date": "1542909641", "time_retrieved": "2024-06-20T19:24:10.065082", "image_code": "void mainImage(out vec4 d, vec2 f) {    /* thx2FabriceNeyret2 */\\\n    int a = 0,i = 0;\n    for( ; (a&64) < 1 ;\n        a = --i-int(iTime*79.) & ( int(d++)+19 ^ int(d.y)+9 )  )\n        d.xy -= f/3e2; /* replace 3e2 with 9e2 for fullscreen */\n    d = vec4( (a&63)- i ) / 5e2;}   /* -2 (a&63) -> a%64 */", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tVBzD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tVfDR", "name": "Raymarch anything 3 (nipple mix)", "author": "Del", "description": "Nipples remix", "tags": ["raymarch"], "likes": 5, "viewed": 394, "date": "1542225790", "time_retrieved": "2024-06-20T19:24:10.743890", "image_code": "// raymarch anything #3 (nipple mix) - Del 14/11/2018\n\n#define\tTAU 6.28318\nfloat objID = 0.0;\nfloat svobjID = 0.0;\n\nfloat pMod1(inout float p, float size)\n{\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nfloat hash(vec2 p)  // replace this by something better\n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nmat2 rotate(float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat map(vec3 p)\n{\n    float time = iTime;\n    float modz = mod(time*6.75, 44.0);\n    float t2 = fract(time*1.1) * TAU;\n    float t3 = fract(time*0.7) * TAU;\n    float t4 = fract(time*0.14)* TAU;\n\n    p.xy *= rotate(p.z * 0.08 + t4);\n    \n    float m = 0.5+sin(t2+p.z*0.4)*0.5;\n    m += 0.5+cos(p.z*0.4+t3+p.x*0.4)*0.5;\n    \n\tp.z += modz;\n    pMod1(p.z,44.0);\n    \n\tfloat dist = 4.5 -abs(p.y)+m;\n    \n    vec3 p2 = p;\n\tfloat cz = pMod1(p2.z,4.0);\n\tfloat cx = pMod1(p2.x,4.0);\n\n    float r = hash(vec2(cz+(cz*0.31),cx+(cx*0.61)));\n    \n    if (r>0.875)\n    {\n\t\tfloat d2 = sdSphere(p2+vec3(0.0,4.0+m,0.0),0.4);\n\t\tfloat d3 = sdSphere(p2-vec3(0.0,4.0+m,0.0),0.4);\n        dist = smin(dist,d2,1.1);\n        dist = smin(dist,d3,1.1);\n    }\n\n    objID = abs(p.z)/44.0;\n    return dist;\n}\n\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\nvec3 normal( in vec3 p )\n{\n    // Note the slightly increased sampling distance, to alleviate\n    // artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.0025, -0.0025); \n    return normalize(\n        e.xyy * map(p + e.xyy) + \n        e.yyx * map(p + e.yyx) + \n        e.yxy * map(p + e.yxy) + \n        e.xxx * map(p + e.xxx));\n}\nvec3 render(vec2 uv)\n{\n    float time = iTime;\n\tvec3 ro = vec3(0.0, 0.0, 0.0);\n\tvec3 rd = normalize(vec3(uv, 1.95));\n\tvec3 p = vec3(0.0);\n\tfloat t = 0.;\n\tfor (int i = 0; i < 80; i++)\n    {\n\t\tp = ro + rd * t;\n\t\tfloat d = map(p);\n\t\tif (d < .001 || t > 100.) break;\n\t\tt += .5 * d;\n\t}\n    \n    svobjID = objID;\n\tvec3 l = ro+vec3(0.0,0.0,15.0);\n\tvec3 n = normal(p);\n\tvec3 lp = normalize(l - p);\n\tfloat diff = 1.2 * max(dot(lp, n), 0.);\n    \n    vec3 c1 = vec3(2.84,2.0,1.45);\n    vec3 c2 = vec3(2.54,1.6,1.85);\n\treturn vec3(0.1)+mix(c1,c2,svobjID) * diff / (1. + t * t * .01);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 col = render(uv);\n\t// vignette\n    col *= 0.4 + 0.6*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\tfragColor = vec4(col, 1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tVfDR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tyBWh", "name": "Crap Mandelbrot", "author": "milolouis", "description": "Rubbish", "tags": ["mandlebrotcrap"], "likes": 2, "viewed": 452, "date": "1542725762", "time_retrieved": "2024-06-20T19:24:10.998451", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    int bitdepth = 4;\n    int res = int(pow(2.0, float(bitdepth)));\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float zoom = 0.5 + (pow(iTime, 3.0) / 8.0);\n    //zoom = 0.5;\n    float xoffset = -(zoom / 1.0) * (iResolution.x / 2.85);\n    float yoffset = -(zoom / 4.0) * (iResolution.x / 18.0);\n    yoffset = 1.0;\n    \n    float c_re = ((fragCoord.x + xoffset) - iResolution.x/2.0)*4.0/(iResolution.x * zoom);\n    float c_im = ((fragCoord.y + yoffset) - iResolution.y/2.0)*4.0/(iResolution.x * zoom);\n    float x = 0.0;\n    float y = 0.0;\n    \n    int max = int(pow(2.0, float(bitdepth * 3))) - 1;\n    \n    int iteration = 0;\n    while (((x*x+y*y) <= 4.0) && (iteration < max)) {\n        float x_new = x*x - y*y + c_re;\n        y = 2.0*x*y + c_im;\n        x = x_new;\n        iteration++;\n    }\n    \n    float b = float(iteration % int(res)) / float(res);\n    float g = float((iteration >> bitdepth) % int(res)) / float(res);\n    float r = float((iteration >> (bitdepth * 2)) % int(res)) / float(res);\n    \n    vec3 col = vec3(r,g,b);\n        \n    //col = vec3(1.0,1.0,1.0) - col;\n\n    fragColor = vec4(col,1.0);    \n    \n    // Output to screen\n    \n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tyBWh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tyfDm", "name": "marble test texture v2", "author": "dalerank", "description": "based on https://www.shadertoy.com/view/XdByD1", "tags": ["texture", "marble"], "likes": 12, "viewed": 796, "date": "1542714257", "time_retrieved": "2024-06-20T19:24:10.998451", "image_code": "// based on https://www.shadertoy.com/view/XdByD1\n\nvec2 csqr( vec2 a )  { return vec2( a.x*a.x - a.y*a.y, 2.*a.x*a.y  ); }\n\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )//from iq\n{\n\tvec3 oc = ro;// - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = 1.0; //b*b - c;\n\treturn vec2(-b-h, -b+h );\n}\n\nfloat map(in vec3 p, vec2 sctime) {\n\t\n\tfloat res = 0.;\n\t\n    vec3 c = p;\n    c.xy = c.xy * sctime.x + vec2(c.y, c.x) * sctime.y;\n\tfor (int i = 0; i < 10; ++i) \n    {\n        p =.7*abs(p)/dot(p,p) -.7;\n        p.yz= csqr(p.yz);\n        p=p.zxy;\n        res += exp(-19. * abs(dot(p,c)));        \n\t}\n\treturn res/2.;\n}\n\nvec3 raymarch( in vec3 ro, vec3 rd, vec2 tminmax , vec2 sctime)\n{\n    //tminmax += vec2(1.,1.) * sin( iTime * 1.3)*3.0;\n   \tvec3 one3 = vec3(1.,1.,1.);\n    vec3 t = one3 * tminmax.x;\n    \n    vec3 dt = vec3(.07, 0.02, 0.05);\n    vec3 col= vec3(0.);\n    vec3 c = one3 * 0.;\n    for( int i=0; i<64; i++ )\n\t{\n     \tvec3 s = vec3(2.0, 3.0, 4.0);   \n        t+=dt*exp(-s*c);\n        vec3 a = step(t,one3*tminmax.y);\n        vec3 pos = ro+t*rd;\n        \n        c.x = map(ro+t.x*rd, sctime);\n        c.y = map(ro+t.y*rd, sctime);\n        c.z = map(ro+t.z*rd, sctime);               \n        \n        col = mix(col, .99*col+ .08*c*c*c, a);\n    }\n    \n    vec3 c0 = vec3(0.4,0.3,0.99);\n    vec3 c1 = vec3(0.9,0.7,0.0);\n    vec3 c2 = vec3(0.9,0.1,0.2);\n    return c0 * col.x + c1 * col.y + c2 * col.z;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime;\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.);\n\n    vec3 ro = vec3(6.);\n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\n\n    \n    vec2 tmm = iSphere( ro, rd, vec4(0.,0.,0.,2.) );\n\n\t// raymarch\n    vec3 col = raymarch(ro,rd,tmm, vec2(sin(iTime), cos(iTime)));\n    \t\n\t// shade    \n    col =  .5 *(log(1.+col));\n    col = clamp(col,0.,1.);\n    fragColor = vec4( col, 1.0 );\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tyfDm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ll3fWl", "name": "no audio port for vdj", "author": "iondd", "description": "fractal", "tags": ["fractal"], "likes": 6, "viewed": 637, "date": "1541452316", "time_retrieved": "2024-06-20T19:24:11.004559", "image_code": "// Remnant X\n// by David Hoskins.\n// Thanks to boxplorer and the folks at 'Fractalforums.com'\n// HD Video:- https://www.youtube.com/watch?v=BjkK9fLXXo0\n\n// #define STEREO\n\nvec3 sunDir  = normalize( vec3(  0.35, 0.1,  0.3 ) );\nconst vec3 sunColour = vec3(1.0, .95, .8);\n\n\n#define SCALE 2.8\n#define MINRAD2 .25\nfloat minRad2 = clamp(MINRAD2, 1.0e-9, 1.0);\n#define scale (vec4(SCALE, SCALE, SCALE, abs(SCALE)) / minRad2)\nfloat absScalem1 = abs(SCALE - 1.0);\nfloat AbsScaleRaisedTo1mIters = pow(abs(SCALE), float(1-10));\nvec3 surfaceColour1 = vec3(.8, .0, 0.);\nvec3 surfaceColour2 = vec3(.4, .4, 0.5);\nvec3 surfaceColour3 = vec3(.5, 0.3, 0.00);\nvec3 fogCol = vec3(0.4, 0.4, 0.4);\nfloat gTime;\n\n\n//----------------------------------------------------------------------------------------\nfloat Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel0, (uv+ 0.5)/256.0, -99.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n//----------------------------------------------------------------------------------------\nfloat Map(vec3 pos) \n{\n\t//return (length(pos)-4.0);\n\n\tvec4 p = vec4(pos,1);\n\tvec4 p0 = p;  // p.w is the distance estimate\n\n\tfor (int i = 0; i < 9; i++)\n\t{\n\t\tp.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;\n\n\t\t// sphere folding: if (r2 < minRad2) p /= minRad2; else if (r2 < 1.0) p /= r2;\n\t\tfloat r2 = dot(p.xyz, p.xyz);\n\t\tp *= clamp(max(minRad2/r2, minRad2), 0.0, 1.0);\n\n\t\t// scale, translate\n\t\tp = p*scale + p0;\n\t}\n\treturn ((length(p.xyz) - absScalem1) / p.w - AbsScaleRaisedTo1mIters);\n}\n\n//----------------------------------------------------------------------------------------\nvec3 Colour(vec3 pos, float sphereR) \n{\n\t//scale.z = 0.0;\n\tvec3 p = pos;\n\tvec3 p0 = p;\n\tfloat trap = 1.0;\n    \n\tfor (int i = 0; i < 6; i++)\n\t{\n        \n\t\tp.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;\n\t\tfloat r2 = dot(p.xyz, p.xyz);\n\t\tp *= clamp(max(minRad2/r2, minRad2), 0.0, 1.0);\n\n\t\tp = p*scale.xyz + p0.xyz;\n\t\ttrap = min(trap, r2);\n\t}\n\t// |c.x|: log final distance (fractional iteration count)\n\t// |c.y|: spherical orbit trap at (0,0,0)\n\tvec2 c = clamp(vec2( 0.3333*log(dot(p,p))-1.0, sqrt(trap) ), 0.0, 1.0);\n\n    float t = mod(length(pos) - gTime*150., 16.0);\n    surfaceColour1 = mix( surfaceColour1, vec3(.4, 3.0, 5.), pow(smoothstep(0.0, .3, t) * smoothstep(0.6, .3, t), 10.0));\n\treturn mix(mix(surfaceColour1, surfaceColour2, c.y), surfaceColour3, c.x);\n}\n\n\n//----------------------------------------------------------------------------------------\nvec3 GetNormal(vec3 pos, float distance)\n{\n    distance *= 0.001+.0001;\n\tvec2 eps = vec2(distance, 0.0);\n\tvec3 nor = vec3(\n\t    Map(pos+eps.xyy) - Map(pos-eps.xyy),\n\t    Map(pos+eps.yxy) - Map(pos-eps.yxy),\n\t    Map(pos+eps.yyx) - Map(pos-eps.yyx));\n\treturn normalize(nor);\n}\n\n//----------------------------------------------------------------------------------------\nfloat GetSky(vec3 pos)\n{\n    pos *= 2.3;\n\tfloat t = Noise(pos);\n    t += Noise(pos * 2.1) * .5;\n    t += Noise(pos * 4.3) * .25;\n    t += Noise(pos * 7.9) * .125;\n\treturn t;\n}\n\n//----------------------------------------------------------------------------------------\nfloat BinarySubdivision(in vec3 rO, in vec3 rD, vec2 t)\n{\n    float halfwayT;\n  \n    for (int i = 0; i < 6; i++)\n    {\n\n        halfwayT = dot(t, vec2(.5));\n        float d = Map(rO + halfwayT*rD); \n        //if (abs(d) < 0.001) break;\n        t = mix(vec2(t.x, halfwayT), vec2(halfwayT, t.y), step(0.0005, d));\n\n    }\n\n\treturn halfwayT;\n}\n\n//----------------------------------------------------------------------------------------\nvec2 Scene(in vec3 rO, in vec3 rD, in vec2 fragCoord)\n{\n\tfloat t = .05 + 0.05 * texture(iChannel0, fragCoord.xy / iChannelResolution[0].xy).y;\n\tvec3 p = vec3(0.0);\n    float oldT = 0.0;\n    bool hit = false;\n    float glow = 0.0;\n    vec2 dist;\n\tfor( int j=0; j < 100; j++ )\n\t{\n\t\tif (t > 12.0) break;\n        p = rO + t*rD;\n       \n\t\tfloat h = Map(p);\n        \n\t\tif(h  <0.0005)\n\t\t{\n            dist = vec2(oldT, t);\n            hit = true;\n            break;\n        }\n       \tglow += clamp(.05-h, 0.0, .4);\n        oldT = t;\n      \tt +=  h + t*0.001;\n \t}\n    if (!hit)\n        t = 1000.0;\n    else       t = BinarySubdivision(rO, rD, dist);\n    return vec2(t, clamp(glow*.25, 0.0, 1.0));\n\n}\n\n//----------------------------------------------------------------------------------------\nfloat Hash(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 33758.5453)-.5;\n} \n\n//----------------------------------------------------------------------------------------\nvec3 PostEffects(vec3 rgb, vec2 xy)\n{\n\t// Gamma first...\n\t\n\n\t// Then...\n\t#define CONTRAST 1.08\n\t#define SATURATION 1.5\n\t#define BRIGHTNESS 1.5\n\trgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);\n\t// Noise...\n\t//rgb = clamp(rgb+Hash(xy*iTime)*.1, 0.0, 1.0);\n\t// Vignette...\n\trgb *= .5 + 0.5*pow(20.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.2);\t\n\n    rgb = pow(rgb, vec3(0.47 ));\n\treturn rgb;\n}\n\n//----------------------------------------------------------------------------------------\nfloat Shadow( in vec3 ro, in vec3 rd)\n{\n\tfloat res = 1.0;\n    float t = 0.05;\n\tfloat h;\n\t\n    for (int i = 0; i < 8; i++)\n\t{\n\t\th = Map( ro + rd*t );\n\t\tres = min(6.0*h / t, res);\n\t\tt += h;\n\t}\n    return max(res, 0.0);\n}\n\n//----------------------------------------------------------------------------------------\nmat3 RotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n//----------------------------------------------------------------------------------------\nvec3 LightSource(vec3 spotLight, vec3 dir, float dis)\n{\n    float g = 0.0;\n    if (length(spotLight) < dis)\n    {\n\t\tg = pow(max(dot(normalize(spotLight), dir), 0.0), 500.0);\n    }\n   \n    return vec3(.6) * g;\n}\n\n//----------------------------------------------------------------------------------------\nvec3 CameraPath( float t )\n{\n    vec3 p = vec3(-.78 + 3. * sin(2.14*t),.05+2.5 * sin(.942*t+1.3),.05 + 3.5 * cos(3.594*t) );\n\treturn p;\n} \n    \n//----------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat m = (iMouse.x/iResolution.x)*300.0;\n\tgTime = (iTime+m)*.01 + 15.00;\n    vec2 xy = fragCoord.xy / iResolution.xy;\n\tvec2 uv = (-1.0 + 2.0 * xy) * vec2(iResolution.x/iResolution.y, 1.0);\n\t\n\t\n\t#ifdef STEREO\n\tfloat isRed = mod(fragCoord.x + mod(fragCoord.y, 2.0),2.0);\n\t#endif\n\n\tvec3 cameraPos\t= CameraPath(gTime);\n    vec3 camTar\t\t= CameraPath(gTime + .01);\n\n\tfloat roll = 13.0*sin(gTime*.5+.4);\n\tvec3 cw = normalize(camTar-cameraPos);\n\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\n\tvec3 cv = normalize(cross(cu,cw));\n    cw = RotationMatrix(cv, sin(-gTime*20.0)*.7) * cw;\n\tvec3 dir = normalize(uv.x*cu + uv.y*cv + 1.3*cw);\n\n\t#ifdef STEREO\n\tcameraPos += .008*cu*isRed; // move camera to the right\n\t#endif\n\n    vec3 spotLight = CameraPath(gTime + .03) + vec3(sin(gTime*18.4), cos(gTime*17.98), sin(gTime * 22.53))*.2;\n\tvec3 col = vec3(0.0);\n    vec3 sky = vec3(0.03, .04, .05) * GetSky(dir);\n\tvec2 ret = Scene(cameraPos, dir,fragCoord);\n    \n    if (ret.x < 900.0)\n    {\n\t\tvec3 p = cameraPos + ret.x*dir; \n\t\tvec3 nor = GetNormal(p, ret.x);\n        \n       \tvec3 spot = spotLight - p;\n\t\tfloat atten = length(spot);\n\n        spot /= atten;\n        \n        float shaSpot = Shadow(p, spot);\n        float shaSun = Shadow(p, sunDir);\n        \n       \tfloat bri = max(dot(spot, nor), 0.0) / pow(atten, 1.5) * .15;\n        float briSun = max(dot(sunDir, nor), 0.0) * .3;\n        \n       col = Colour(p, ret.x);\n       col = (col * bri * shaSpot) + (col * briSun* shaSun);\n        \n       vec3 ref = reflect(dir, nor);\n       col += pow(max(dot(spot,  ref), 0.0), 10.0) * 2.0 * shaSpot * bri;\n       col += pow(max(dot(sunDir, ref), 0.0), 10.0) * 2.0 * shaSun  * bri;\n    }\n    \n    col = mix(sky, col, min(exp(-ret.x+1.5), 1.0));\n    col += vec3(pow(abs(ret.y), 2.)) * vec3(.02, .04, .1);\n\n    col += LightSource(spotLight-cameraPos, dir, ret.x);\n\tcol = PostEffects(col, xy);\t\n\n\t\n\t#ifdef STEREO\t\n\tcol *= vec3( isRed, 1.0-isRed, 1.0-isRed );\t\n\t#endif\n\t\n\tfragColor=vec4(col,1.0);\n}\n\n//--------------------------------------------------------------------------", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ll3fWl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ll3fWX", "name": "Nadieh's sphere", "author": "nicoptere", "description": "rendition of the sphere discussed here : https://twitter.com/mattdesl/status/1058331809958760448", "tags": ["2d", "gradient", "hsl", "bulge"], "likes": 0, "viewed": 157, "date": "1541252675", "time_retrieved": "2024-06-20T19:24:11.350230", "image_code": "mat2 getMat( float angle ){\n    return mat2( cos( angle ), -sin( angle ), sin( angle ), cos( angle ) );\n}\n\n//YI-Wen Lin:\n//https://gist.github.com/yiwenl/745bfea7f04c456e0101\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6. - 3.);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n\tvec2 uv = ( fragCoord.xy / iResolution.xy ) * 2.0 - 1.0;\n\t\n    //preserve aspect ratio\n\tuv.x *= iResolution.x / iResolution.y;\n\n    //radius\n      float r = length(uv) * 1.618033988749894848; //1.618... = Golden ration\n\n      //grid pattern\n      vec2 chk = floor( uv * 8. );\n      vec3 col = vec3( 0.65 ) + mod( chk.x + chk.y, 2. ) * vec3(.25);\n\n      //sway\n      uv *= getMat( sin( iTime ) * .2 );\n\n      //bulge\n      uv *= ( ( 1. - sqrt( 1. - r ) ) / r );\n\n      //vertical shift\n      uv.y += iTime * .1;\n\n      //stripe\n      float stripes = 7.;\n      float hue = fract( floor( uv.y * stripes ) / stripes  );\n\n      \t//smooth-ish blend S > 1. / bloom-ish with S = 0.5\n    \t///*\n        float S = 0.5;\n        float prev = fract(  floor( uv.y * stripes ) / stripes ) - 1. / stripes;\n        float hueMix = clamp( fract( uv.y * stripes ) * S, 0.,1.);\n        hue = mix( prev, hue, hueMix );\n\t\t//*/\n\n      //convert Hue to RGB\n      vec3 hsv = hsv2rgb( vec3( hue, .75, 1. ) );\n\n      //blend\n      float alpha = smoothstep(  0.99, 1.,r );\n      fragColor.rgb = mix( hsv, col, alpha );\n      fragColor.a = 1.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ll3fWX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llcBDB", "name": "Ray March 1st", "author": "jpechevarria", "description": "Learning \"ray marching\", \"volumetric rendering\" + \"signed distance function\".\nPracticing diffuse + specular lighting.\nAntialiasing (subsampling or miltusample, don't remember de name ;) ).\nOclussion.", "tags": ["raymarching", "sdf", "shadow", "volumetric"], "likes": 3, "viewed": 92, "date": "1541175668", "time_retrieved": "2024-06-20T19:24:13.095527", "image_code": "#define MAX_MARCHING_STEPS 200\n#define EPSILON 0.001\n//#define AXIS_RADIUS 0.01;\n#define AMBIENT_LIGHT 0.01\n\n#define ROTATE_EYE 0\n#define ANIMATE_FIGURE 0\n#define ROTATE_LIGHT 1\n#define VIEW_AXIS 0\n\n#define EYE_DIST 18.0\n#define WALL_DIST 20.0\n\nfloat AXIS_RADIUS = (2.0) * EYE_DIST / 1000.0;\n\nmat2 cubeRot;\nvec3 cubeTra;\n\nvec3 light1Pos_base = vec3(0.0,2.0,3.0);\nvec3 light1Pos;\n\nint lightInScene = 1;\n\nmat2 rot2d( float angle ) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2( \n        \t\tc, -s,\n                s,  c\n               );\n}\n\nfloat unionSDF(float sdf1, float sdf2) {\n    return min(sdf1,sdf2);\n}\n\nfloat intersectSDF(float sdf1, float sdf2) {\n    return max(sdf1,sdf2);\n}\n\nfloat excludeSDF(float sdf1, float sdf2) {\n    return intersectSDF(sdf1, -sdf2);\n}\n\nfloat sphereSDF(vec3 p, float radio) {\n    // SPHERE\n    return length(p) - radio;\n}\nfloat leftHSpaceSDF(float coord, float limit) {\n    return coord - limit;\n}\nfloat rightHSpaceSDF(float coord, float limit) {\n    return limit - coord;\n}\nfloat cubeSDF(vec3 p, float lado)\n{\n    lado *= 0.5;\n    // CUBE\n    float dx = max( leftHSpaceSDF(p.x,lado) , rightHSpaceSDF(p.x,-lado) );\n    float dy = max( leftHSpaceSDF(p.y,lado) , rightHSpaceSDF(p.y,-lado) );\n    float dz = max( leftHSpaceSDF(p.z,lado) , rightHSpaceSDF(p.z,-lado) );\n\n    float ret;\n    ret = max(max(dx,dy),dz);\n    \n    return ret;\n}\n\nfloat ejeXSDF(vec3 p) { return length(p.yz) - AXIS_RADIUS; }\nfloat ejeYSDF(vec3 p) { return length(p.xz) - AXIS_RADIUS; }\nfloat ejeZSDF(vec3 p) { return length(p.xy) - AXIS_RADIUS; }\n\nfloat sceneSDF(vec3 p, out int mat) {\n    \n    mat = 1;\n    \n    float ret;\n    float sphere1, sphere2, sphere3, sphere4;\n    float cube;\n    \n    float commonRadius = 1.3;\n    \n    vec3 sphereCentre1 = vec3(0.0,0.0,0.0);\n    float sphereRadius1 = commonRadius; //(1.0 + sin(iTime)) * 0.5;\n\n\tvec3 sphereCentre2 = vec3(0.0,0.0,0.0);\n    float sphereRadius2 = 0.5; // (1.0 + sin(iTime)) * 0.5;\n\t/*\n    vec3 sphereCentre3 = vec3(0.0,1.0,0.0);\n    float sphereRadius3 = commonRadius; // (1.0 + sin(iTime)) * 0.5;\n\t\n    vec3 sphereCentre4 = vec3(0.0,-1.0,0.0);\n    float sphereRadius4 = commonRadius; // (1.0 + sin(iTime)) * 0.5;\n\t*/\n    \n    // CUBE TRANSFORMATIONS\n    vec3 pp = p;\n    pp.xyz += cubeTra;\n    //pp.yz = cubeRot * pp.yz;\n    //pp.xz = cubeRot * pp.xz;\n    pp.xy = cubeRot * pp.xy;\n    \n    sphere1 = sphereSDF(pp - sphereCentre1, sphereRadius1);\n    sphere2 = sphereSDF(p - sphereCentre2, sphereRadius2);\n    //sphere3 = sphereSDF(pp - sphereCentre3, sphereRadius3);\n    //sphere4 = sphereSDF(pp - sphereCentre4, sphereRadius4);\n    \n    cube = cubeSDF(pp , 2.0);\n\n    ret = 999.0;\n    \n    ret = unionSDF(ret,cube);\n\n    // INTERSECTION\n    //ret = intersectSDF(ret,sphere);\n\n    /* UNION \n    ret = unionSDF(ret, sphere1);\n    ret = unionSDF(ret, sphere2);\n    ret = unionSDF(ret, sphere3);\n    ret = unionSDF(ret, sphere4);\n    //*/\n\n    ///* EXCLUSION\n\tret = excludeSDF(ret,sphere1);\n    //ret = excludeSDF(ret,sphere2);\n    //ret = excludeSDF(ret,sphere3);\n    //ret = excludeSDF(ret,sphere4);\n\t//*/\n\n\tret = unionSDF(ret, sphere2);\n\n    /* INTERSECTION\n\tfloat fig2;\n    fig2 = 999.0;\n\tfig2 = unionSDF(fig2,sphere1);\n    fig2 = unionSDF(fig2,sphere2);\n    fig2 = unionSDF(fig2,sphere3);\n    fig2 = unionSDF(fig2,sphere4);\n    \n    ret = intersectSDF(ret,fig2);\n\t//*/\n\n    \n    // UNION CON LOS EJES\n    if ( ret > 0.0 \n        \t&& lightInScene > 0 \n        \t&& VIEW_AXIS > 0\n       ) {\n        float eje;\n        \n        eje = ejeXSDF(p);\n        ret = unionSDF(ret, eje);\n        if ( eje < EPSILON ) mat = 2;\n        \n        eje = ejeYSDF(p);\n        ret = unionSDF(ret, eje);\n        if ( eje < EPSILON ) mat = 3;\n        \n        eje = ejeZSDF(p);\n        ret = unionSDF(ret, eje);\n        if ( eje < EPSILON ) mat = 4;\n    }\n    \n    if ( lightInScene > 0 )\n    {\n        float lightDist = sphereSDF(p - light1Pos, 0.15);\n        if ( lightDist < EPSILON ) mat = 5;\n\n        ret = unionSDF(ret, lightDist);\n    }\n    \n    ret = unionSDF(ret,leftHSpaceSDF(p.y, -3.0));\n    ret = unionSDF(ret,leftHSpaceSDF(p.z, -WALL_DIST));\n    ret = unionSDF(ret,leftHSpaceSDF(p.x, -WALL_DIST));\n    ret = unionSDF(ret,rightHSpaceSDF(p.z, WALL_DIST));\n    ret = unionSDF(ret,rightHSpaceSDF(p.x, WALL_DIST));\n    \n    return ret;\n}\n\nfloat lightSDF(vec3 p, vec3 l, out vec3 col) \n{\n    float ret = sphereSDF(l, 0.1);\n    if ( ret < EPSILON )\n    {\n        col = vec3(1.0,1.0,0.0);\n    }\n    return ret;\n}\n\nfloat rayMarch(vec3 eye, vec3 viewRayDirection, out int mat) {\n    float start = 0.0;\n    float end = 100.0;\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        //vec3 col;\n        float dist = sceneSDF(eye + depth * viewRayDirection, mat);\n        if (dist < EPSILON) {\n            // We're inside the scene surface!\n            return depth;\n        }\n        // Move along the view ray\n        depth += dist;\n\n        if (depth >= end) {\n            // Gone too far; give up\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 estimateNormal(vec3 p) {\n    int col;\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z),col) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z),col),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z),col) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z),col),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON),col) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON),col)\n    ));\n}\n\nvec4 image( in vec2 fragCoord, in vec2 resolution )\n{\n    vec4 fragColor = vec4(0, 0, 0, 1);\n    \n    // MOELO TRANFORMATIONS\n    if ( ANIMATE_FIGURE > 0 )\n    {\n\t\tcubeRot = rot2d(0.5*iTime);\n\t\t//cubeTra = vec3(0.0, 0.0, 5.0*sin(1.7*iTime));\n        //cubeTra.x = 1.5 * sin(3.0*iTime);\n    }\n    else\n    {\n        cubeRot = rot2d(0.0);\n        cubeTra = vec3(3.0,0.0,0.0);\n    }\n    //cubeTra = vec3(-2.0,0.0,0.0);\n    \n    // LIGHT ROTATION\n\tlight1Pos = light1Pos_base;\n    if ( ROTATE_LIGHT > 0 )\n    {\n        mat2 rot = rot2d(iTime);\n        light1Pos.xz *= rot;  \n    }\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / resolution.xy - 0.5;\n    uv.y *= resolution.y / resolution.x;\n\n\tvec3 eye;\n    if ( ROTATE_EYE == 0 )\n    {\n        eye = vec3(EYE_DIST*cos(1.1),3.0,EYE_DIST * sin(1.1));\n    }\n    else\n    {\n    \tfloat eyeAngle = 0.5 * iTime;\n        eye.xz = EYE_DIST * vec2 ( sin(eyeAngle), cos(eyeAngle) );\n        eye.y = 3.0;\n    }\n    \n    vec3 lookAt = vec3 ( 0.0, 0.0, 0.0 );\n    vec3 eyeDir = normalize(lookAt - eye);\n    vec3 up = vec3 ( 0.0, 1.0, 0.0 );\n    vec3 right = normalize(cross(eyeDir,up));\n    up = cross(right,eyeDir);\n    \n    vec3 screen = eye + eyeDir + uv.x * right + uv.y * up;\n    vec3 rayDir = normalize(screen - eye);\n    \n    int material;\n    float dist = rayMarch(eye, rayDir, material);\n    \n\tvec3 col;\n\n\tif ( material == 1 ) col = vec3(1.0,1.0,1.0);\n    \n    if ( material >= 2 && material <= 5 ) {\n        if ( material == 2 ) col = vec3(1.0,0.0,0.0);\n        if ( material == 3 ) col = vec3(0.0,1.0,0.0);\n        if ( material == 4 ) col = vec3(0.0,0.0,1.0);\n        if ( material == 5 ) col = vec3(1.0,1.0,0.0);\n        fragColor = vec4(col,1.0);\n    }\n    else \n    {\n\n        vec3 p = eye + dist * rayDir;\n\n        if ( dist < 100.0 ) {\n            \n            vec3 viewDir = - rayDir;\n\n            vec3 normal = estimateNormal(p);\n\n            // DIRECTIONAL LIGHT\n            //vec3 light = -light1Dir;\n            //float ligthPower = 1.0;\n\n            // POINT LIGHT\n            vec3 light = light1Pos - p;\n            float lightDist = length(light);\n            float ligthPower = pow(3.0 / lightDist,1.0);\n\n            light = normalize(light);\n\n            // DIFFUSE LIGHT\n            float light1Dif = max(dot(light, normal),0.0);\n\n            // SPECULAR LIGHT\n            vec3 reflectDir = reflect(-light, normal);\n            float angle = max(dot(reflectDir, viewDir),0.0);\n            float light1Spe = pow(angle,64.0);\n\n            // VIEW NORMALS\n            //fragColor = vec4(normal,1.0);\n\n            //\n            fragColor = vec4(AMBIENT_LIGHT);\n\n            // VIEW DIFF LIGHT\n            fragColor += 1.0 * ligthPower * vec4(light1Dif);\n\n            // VIEW SPEC LIGHT\n            fragColor += 1.0 * ligthPower * vec4(light1Spe);\n\n            //fragColor = vec4(abs(normal),1.0);\n            //fragColor = vec4(light,1.0);\n            //fragColor = vec4(pow(4.0/lightDist,10.0));\n\n            fragColor.rgb *= col;\n            \n            // VERIFY LIGHT OCCLUSION\n            ///*\n            lightInScene = 0;\n            rayDir = normalize(p-light1Pos);\n            float distFromLight = rayMarch(light1Pos, rayDir, material);\n            float diff = length(p-light1Pos) -distFromLight ;\n            if ( diff > 10.0 * EPSILON )\n            {\n                fragColor = vec4(AMBIENT_LIGHT);\n            }\n\t\t\t//*/\n        }\n    }\n    \n    return fragColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float subSample = 3.0;\n    \n    \n    if ( subSample < 2.0 )\n    {\n    \tfragColor += image(fragCoord, iResolution.xy);\n    }\n    else\n    {\n        vec2 subResolution = iResolution.xy * subSample;\n\n        float samples = subSample * subSample;\n        float sampleWeight = 1.0 / samples;\n\n        for ( float i = 0.0; i < subSample ; i ++ )\n        {\n            for ( float j = 0.0; j < subSample ; j ++ )\n            {\n                vec2 newCoord = fragCoord * subSample + vec2(i,j);\n                fragColor += image(newCoord, subResolution) * sampleWeight;\n            }\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llcBDB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lldBD2", "name": "Simple Shrink", "author": "xiaogeformax", "description": " a sample shader shrink to center", "tags": ["kaleidoscope", "shrink"], "likes": 3, "viewed": 247, "date": "1541160748", "time_retrieved": "2024-06-20T19:24:13.101440", "image_code": "precision highp float;\nfloat PI = 3.14159265359;\n\nvec2 kaleidoscope(vec2 uv, vec2 offset, float splits)\n{\n    // XY coord to angle\n    float angle = atan(uv.y, uv.x);\n    // Normalize angle (0 - 1)\n    angle = ((angle / PI) + 1.0) * 0.5;\n    // Rotate by 90¬∞\n    angle = angle + 0.25 * iTime * 0.05;\n    // Split angle \n    angle = mod(angle, 1.0 / splits) * splits;\n    \n    // Warp angle\n    angle = -abs(2.0*angle - 1.0) + 1.0;\n    \n    angle = angle*0.1;\n    \n    // y is just dist from center\n    float y = length(uv);\n    \n    angle = angle * (y*3.0);\n    \n    return vec2(angle, y) + offset;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n    vec2 offset = vec2(iTime   *0.05,  iTime   *0.5);\n    vec2 uv  = kaleidoscope(p, offset, 10.);\n    // pattern: cosines\n    float f = cos(8.*uv.x)*cos(6.0*uv.y);\n    \n    // color fetch: palette\n    vec3 col =0.+  sin( 3.1416*f + vec3(1.,0.5,1.0) );\n    \n    // output:\n    fragColor = vec4( col, 1.0 );\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lldBD2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llGBRy", "name": "Ray Trace Test", "author": "foodini", "description": "A simple raytracer, with diffuse, specular, reflection, shadows. Still needs visible light sources.", "tags": ["raytracer", "raytracer", "raytrace", "raytrace"], "likes": 1, "viewed": 120, "date": "1542915861", "time_retrieved": "2024-06-20T19:24:13.101695", "image_code": "struct ray {\n\tvec3 o;\n\tvec3 d;\n};\n\nstruct light {\n\tvec3 pos;\n\tvec3 col;\n\tfloat exp;\n};\n\nstruct shape {\n\tint type; //0:sphere, 1:plane\n\t\n\tvec3 pos;\n\tvec3 offset;  //radius or normal\n\t\n\tfloat diffuse_fract;\n\tfloat specular_fract;\n\tint diffuse_texture;\n\t\n\tfloat reflective_fract;\n};\n\n    \nconst int obj_count = 10;\nconst int light_count = 3;\nshape shapes[obj_count];\nlight lights[light_count];\n    \n\n//ray must be normalized!\nfloat ray_sphere_isect(ray r, const int id) {\n\tshape s = shapes[id];\n\t\n\tfloat a = dot(r.d, r.d);\n\tvec3 s0_r0 = r.o - s.pos;\n\tfloat b = 2.0*dot(r.d, s0_r0);\n\tfloat c = dot(s0_r0, s0_r0) - s.offset.x*s.offset.x;\n\tfloat b2 = b*b;\n\tif (b2 - 4.0*a*c < 0.0) {\n\t\treturn -1.0;\n\t}\n\treturn (-b - sqrt(b2 - 4.0*a*c)) / (2.0*a); \n}\n\nvec3 diffuse_texture(vec3 p, int t) {\n\tif(t==0)\n\t\treturn vec3(1.0,0.,0.0);\n\tif(t==1)\n\t\treturn vec3(1.0 - (\n\t\t\tsmoothstep(0.3, 0.5, fract(p.z)) -\n\t\t\tsmoothstep(0.5, 0.7, fract(p.z)) +\n\t\t\tsmoothstep(0.3, 0.5, fract(p.y)) -\n\t\t\tsmoothstep(0.5, 0.7, fract(p.y))\n\t\t\t));\n\tif(t==2)\n\t\treturn vec3(1.0 - (\n\t\t\tsmoothstep(0.3, 0.5, fract(p.x)) -\n\t\t\tsmoothstep(0.5, 0.7, fract(p.x)) +\n\t\t\tsmoothstep(0.3, 0.5, fract(p.z)) -\n\t\t\tsmoothstep(0.5, 0.7, fract(p.z))\n\t\t\t));\n\tif(t==3)\n\t\treturn vec3(1.0 - (\n\t\t\tsmoothstep(0.3, 0.5, fract(p.x)) -\n\t\t\tsmoothstep(0.5, 0.7, fract(p.x)) +\n\t\t\tsmoothstep(0.3, 0.5, fract(p.y)) -\n\t\t\tsmoothstep(0.5, 0.7, fract(p.y))\n\t\t\t));\n\tif(t==4)\n\t\treturn vec3(0.0,1.0,0.0);\n\tif(t==5)\n\t\treturn vec3(0.0,0.0,1.0);\n\treturn vec3(0.2,0.2,0.2);\n\n}\n\nfloat ray_plane_isect(ray r, const int id) {\n\tshape s = shapes[id];\n\n\tfloat denom = dot(s.offset, r.d);\n\tif(denom > 1.0e-6) {\n\t\tfloat t = dot((s.pos - r.o), s.offset) / denom;\n\t\tif(t > 1.0e-6) {\n\t\t\treturn t;\n\t\t}\n\t}\n\treturn -1.0;\n}\n\n//Should isect_dist return dist*dist?\nfloat isect_dist(ray r, int id) {\n\tif (shapes[id].type == 0) {\n\t\treturn ray_sphere_isect(r, id);\n\t} else {\n\t\treturn ray_plane_isect(r, id);\n\t}\n\treturn -1.;\n}\n\nvec3 isect_normal(vec3 position, int id) {\n\tif (shapes[id].type == 0) {\n\t\treturn(normalize(position - shapes[id].pos));\n\t} else {\n\t\treturn(-shapes[id].offset);\n\t}\n}\n\n//TODO: \n// * Light attenuation is broken. Gets brighter with distance.\n// * visible light sources.\nvec3 get_color_for_ray(ray r) {\n\tint ignore = -1;\n\tvec3 retval = vec3(0.0);\n\t/* visible light sources...\n\tfor(lid=0; lid<light_count; lid++) {\n\t\tvec3\n\t}\n\t*/\n\tfloat attenuation = 1.0;\n\tint depth = 0;\n\tvec3 position, normal, reflection, to_v;\n\twhile(depth < 4 && attenuation > 0.05) {\n\t\tdepth += 1;\n\t\tfloat min_dist = 100000.;\n\t\tint nearest_obj = -1;\n\t\tfor (int obj_id=0; obj_id<obj_count; obj_id++) {\n\t\t\tif (obj_id == ignore) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfloat t = isect_dist(r, obj_id);\n\t\t\tif (t > 0.0 && t < min_dist) {\n\t\t\t\tnearest_obj = obj_id;\n\t\t\t\tmin_dist = t;\n\t\t\t}\n\t\t}\n\t\tif (nearest_obj < 0) {\n\t\t\treturn retval;\n\t\t}\n\t\tposition = r.o + r.d*min_dist;\n\t\tnormal = isect_normal(position, nearest_obj);\n\t\tif (shapes[nearest_obj].diffuse_fract > 0.0 || shapes[nearest_obj].reflective_fract > 0.0) {\n\t\t\tto_v = normalize(r.o - position);\n\t\t\treflection = reflect(to_v, normal);\n\t\t}\n\t\tif (shapes[nearest_obj].diffuse_fract > 0.0) {\n\t\t\tfor (int lid=0; lid<light_count; lid++) {\n\t\t\t\tvec3 to_l = lights[lid].pos - position;\n\t\t\t\tray shadow_test = ray(position, to_l);  //NOT NORMALIZED\n\t\t\t\tbool shadowed = false;\n\t\t\t\tif (dot(normal, to_l) < 0.0) {\n\t\t\t\t\tshadowed = true;\n\t\t\t\t} else {\n\t\t\t\t\tfor (int obj_id=0; obj_id<obj_count; obj_id++) {\n\t\t\t\t\t\tfloat dist = isect_dist(shadow_test, obj_id);\n\t\t\t\t\t\tif (dist > 0.0 && dist < 1.0) { //1.0 because shadow_test isn't normalized\n\t\t\t\t\t\t\tshadowed = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!shadowed) {\n\t\t\t\t\tto_l = normalize(to_l);\n\t\t\t\t\tretval += \n\t\t\t\t\t\tattenuation * (\n\t\t\t\t\t\t\tdiffuse_texture(position, shapes[nearest_obj].diffuse_texture)\n\t\t\t\t\t\t\t* dot(to_l, normal) \n\t\t\t\t\t\t\t* shapes[nearest_obj].diffuse_fract\n\t\t\t\t\t\t\t/ sqrt(dot(to_l, to_l))\n\t\t\t\t\t\t\t//SPECULAR:\n\t\t\t\t\t\t\t+ lights[lid].col\n\t\t\t\t\t\t\t\t* pow(dot(to_l, reflection), 50.0)\n\t\t\t\t\t\t\t\t* shapes[nearest_obj].specular_fract\n\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (shapes[nearest_obj].reflective_fract <= 0.0) {\n\t\t\treturn retval;\n\t\t}\n\t\tretval *= (1.0 - shapes[nearest_obj].reflective_fract);\n\t\tattenuation *= shapes[nearest_obj].reflective_fract;\n\t\tr.o = position;\n\t\tr.d = -reflection;\n\n\t\tignore = nearest_obj;\n\t}\n\treturn retval;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float st = sin(iTime);\n    float ct = cos(iTime);\n    float nst = -sin(iTime);\n    float nct = -cos(iTime);\n    shapes[0] = shape(0, vec3(st,ct,nst),    vec3(0.9),        0.7, 0.9, 0, 0.1);\n    shapes[1] = shape(0, vec3(ct,nst,nct),    vec3(1.2),        0.7, 0.9, 4, 0.1);\n    shapes[2] = shape(0, vec3(nst,nct,st),  vec3(1.1),        0.7, 0.9, 5, 0.1);\n    shapes[3] = shape(0, vec3(nct,st,ct),    vec3(1.0),       0.4, 0.9, 6, 0.2);\n    shapes[4] = shape(1, vec3( 6.,0.,0.),    vec3(1.,0.,0.),  1.0, 1.0, 1, 0.0);\n    shapes[5] = shape(1, vec3(-6.,0.,0.),   vec3(-1.,0.,0.),  1.0, 1.0, 1, 0.0);\n    shapes[6] = shape(1, vec3( 0.,6.,0.),    vec3(0.,1.,0.),  1.0, 1.0, 2, 0.0);\n    shapes[7] = shape(1, vec3( 0.,-6.,0.),   vec3(0.,-1.,0.), 1.0, 1.0, 2, 0.0);\n    shapes[8] = shape(1, vec3( 0.,0.,6.),    vec3(0.,0.,1.),  1.0, 1.0, 3, 0.0);\n    shapes[9] = shape(1, vec3( 0.,0.,-6.),   vec3(0.,0.,-1.), 1.0, 1.0, 3, 0.0);\n    lights[0] = light(vec3(sin(iTime)*2.0,   cos(iTime)*2.0, 2.0), vec3(1.0, 0.0, 0.0), 5.0);\n    lights[1] = light(vec3(cos(iTime)*2.0,   sin(iTime)*2.0, 2.0), vec3(0.0, 1.0, 0.0), 5.0);\n    lights[2] = light(vec3(-sin(iTime)*2.0,  cos(iTime)*2.0, 2.0), vec3(0.0, 0.0, 1.0), 5.0);\n    vec3 viewpoint = vec3(6.0*sin(iTime/3.0), 6.0*cos(iTime/3.0), 2.0*sin(iTime/2.0));\n    vec3 lookat = vec3(0.0, 0.0, 0.0);\n    vec3 lookdir = viewpoint - lookat;\n    vec3 right = vec3(-lookdir.y, lookdir.x, 0.0);\n\t\t\n\tvec2 screen_coords = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\tright *= 3.0/length(right);\n\tvec3 up = cross(lookdir, right);\n\tup *= 3.0/(length(up))*iResolution.y/iResolution.x;\n\n\tvec3 screen_vect = normalize((lookat + up * screen_coords.y + right * screen_coords.x) - viewpoint);\n\tray r = ray(viewpoint, screen_vect);\n\n\tfragColor = vec4(get_color_for_ray(r), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llGBRy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llGBz1", "name": "octree truchet slice", "author": "abje", "description": "a 2d slice of a 3d octree truchet", "tags": ["2d", "truchet", "3dslice"], "likes": 10, "viewed": 464, "date": "1541779910", "time_retrieved": "2024-06-20T19:24:13.829052", "image_code": "//5 is maybe a little too much, 3 is fine\n#define limit 3.0\n\n#define HASHSCALE3 vec3(.6531, .5563, .7498)\n\n#define dot2(p) dot(p,p)\n\n//hash function in hash without sine by Dave_Hoskins\n//https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z*15.3023+0.434);\n}\n\n#define checktree(k)                        \\\nfor (j = 0.0; j < k; j++) {             \\\n    vec3 h = floor(r*exp2(j))*exp2(-j); \\\n    float rand = hash13(h+exp2(-j-1.0));\\\n    if (rand >= 0.5) {                 \\\n        break;                          \\\n    }                                   \\\n}\n\nfloat squarering(vec3 p, float size) {\n    vec2 q = vec2(abs(length(p.xy)-0.5),abs(p.z));\n    float len = length(max(q-size,0.0))+min(max(q.x,q.y)-size,0.0);\n    return len;\n}\n\nfloat truchet(vec3 p, int type) {\n    vec3 q = abs(p-0.5);\n\t\n    vec3 q2 = vec3(min(min(q.x,q.y),q.z),0,max(max(q.x,q.y),q.z));\n    q = min(q,q.yzx);\n    q2.y = max(max(q.x,q.y),q.z);\n\n    float inside = length(abs(q2.yz-vec2(0.0,0.5)))-0.1667;\n    float inside2 = length(abs(max(q2.yz-vec2(0.0,0.5),0.0)))-0.1667;\n    float outside = length(abs(q2.yz-vec2(0.5,0.5)))-0.3333;\n    \n    float len;\n    //len = min(len, squarering(p.xyz-vec3(0,0,0.5)));\n    //len = min(len, squarering(p.yzx-vec3(1,0,0.5)));\n    //len = min(len, squarering(p.zxy-vec3(1,1,0.5)));\n    if (type == 0) {\n        len = -outside;\n    } else if (type == 1) {\n        len = inside;\n    } else if (type == 2) {\n        len = inside2;\n    } else if (type == 3) {\n        float size = 0.1667-0.1+q2.z*0.2;\n        len = squarering(p.xyz-vec3(0,0,0.5),size)*0.9;\n        len = min(len, squarering(p.yzx-vec3(1,0,0.5),size)*0.9);\n        len = min(len, squarering(p.zxy-vec3(1,1,0.5),size)*0.9);\n    }\n    \n    \n    return len;\n}\n\nfloat map(vec3 p) {\n    \n    vec3 fp;\n    vec3 lp;\n    float len;\n    float i;\n    \n    //r is the truchet cell you want the random \n    vec3 r = p;\n    float j;\n    checktree(limit);\n    i = j;\n    float size = exp2(-i);\n    //the position in the bottom left corner of the truchet cell\n    fp = floor(p/size)*size;\n\n    //the local position on the truchet cell (always 0-1)\n    lp = fract(p/size);\n    \n    int type = int(hash13((fp+size*0.5)*vec3(0.93,0.89,1.23))*4.0);\n    len = truchet(lp,type)*size;\n    \n    while (i <= limit) {\n        //the position in the bottom left corner of the truchet cell\n        fp = floor(p/size)*size;\n        //the local position on the truchet cell (always 0-1)\n        lp = fract(p/size);\n        //check for the overlapping black dots\n        vec3 p2 = p/size;\n        vec3 fp2 = floor(p2-0.5);\n        for(int x = -0; x <= 1; x++) {\n            for(int y = -0; y <= 1; y++) {\n                for(int z = -0; z <= 1; z++) {\n                    r = (fp2+vec3(x,y,z))*size;\n                    //this branch doesn't do anything, but it skips the random() once\n                    if (r != fp)\n                    {\n                        checktree(i);\n\n                        if (i==j) {\n                            vec3 q = abs(p2-fp2-vec3(x,y,z)-0.5);\n                            \n                            vec3 q2 = vec3(min(min(q.x,q.y),q.z),0,max(max(q.x,q.y),q.z));\n                            q = min(q,q.yzx);\n                            q2.y = max(max(q.x,q.y),q.z);\n                            \n                            float outside = length(abs(q2.yz-vec2(0.5,0.5)))-0.3333;\n                            \n                            len = max(-outside*size,len);\n                        }\n                    }\n                }\n            }\n        }\n        size *= 0.5;\n        len *= -1.0;\n        i++;\n    }\n    return len;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord.xy*2.0-iResolution.xy)/iResolution.y;\n    \n    \n    fragColor = vec4(map(vec3(uv,iTime*0.1))*iResolution.y*0.5);\n    \n    fragColor = sqrt(fragColor);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llGBz1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llGfRV", "name": "CBM 3D", "author": "Del", "description": "cbm logo", "tags": ["raymarch", "logo", "extrude", "cbm"], "likes": 8, "viewed": 417, "date": "1543163064", "time_retrieved": "2024-06-20T19:24:14.447232", "image_code": "// yx's commodore shape from here - https://www.shadertoy.com/view/4lGfzK\n//\n// Raymarched by Del 25/11/2018\n\nfloat cbm(vec2 p)\n{\n    const float A = 10.;\n    const float B = 0.034 * A;\n    const float C = 0.166 * A;\n    const float E = 0.364 * A;\n    const float F = 0.52 * A;\n    const float G = 0.53 * A;\n    const float H = 0.636 * A;\n    const float I = 0.97 * A;\n    \n    p.y = abs(p.y);\n    \n    float outerCircle = length(p)-I*.5;\n    float innerCircle = length(p*vec2(F/G,1))-F*.5;\n    float verticalMask = p.x-(H-I*.5);\n    \n    float topMask = p.y-C-B*.5;\n    float bottomMask = p.y-B*.5;\n    float angleMask = ((p.x-p.y)-A+I*.5+E*.5)/sqrt(2.);\n    \n    float vents = max(max(angleMask,max(topMask,-bottomMask)), -verticalMask);\n    \n    float ring = max(max(outerCircle,-innerCircle),verticalMask);\n    \n    return min(vents, ring);\n}\n\n\nmat2 rotate(float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n#define\tTAU 6.28318\n\n\nfloat map(vec3 p)\n{\n    float time = iTime+0.2;\n    p.z -= 13.0+sin(fract(time*0.15)*TAU)*2.0;\n    \n    float twist = 0.5+sin(fract(time*0.25)*TAU)*0.5;\n    twist *= p.y * 0.1;\n    p.xz *= rotate(twist+fract(time*0.26)*TAU);\n    \n    float dist = cbm(p.xy);\n    \n    float dep = 0.5;\n    vec2 e = vec2( dist, abs(p.z) - dep );\n    dist = min(max(e.x,e.y),0.0) + length(max(e,0.0));\n    dist -= 0.07;\n    return dist;\n}\n\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\nvec3 normal( in vec3 p )\n{\n    // Note the slightly increased sampling distance, to alleviate\n    // artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.0025, -0.0025); \n    return normalize(\n        e.xyy * map(p + e.xyy) + \n        e.yyx * map(p + e.yyx) + \n        e.yxy * map(p + e.yxy) + \n        e.xxx * map(p + e.xxx));\n}\nvec3 render(vec2 uv)\n{\n\tvec3 ro = vec3(0.0, 0.0, 0.0);\n\tvec3 rd = normalize(vec3(uv, 1.95));\n\tvec3 p = vec3(0.0);\n\tfloat t = 0.;\n\tfor (int i = 0; i < 100; i++)\n    {\n\t\tp = ro + rd * t;\n\t\tfloat d = map(p);\n\t\tif (d < .001 || t > 100.) break;\n\t\tt += d *0.75;\n\t}\n    \n    vec3 c = vec3(0.35,0.35,0.45);\n    c*= 1.2-abs(uv.y);\n    \n    if (t<100.0)\n    {\n\t   \tvec3 lightDir = normalize(vec3(1.0, 1.0, 0.5));\n        vec3 nor = normal(p);\n\n        float dif = max(dot(nor, lightDir), 0.0);\n        c = vec3(0.5) * dif;\n\n        float tf = 0.02;\n        c += vec3(0.65,0.6,0.25) + reflect(vec3(p.x*tf, p.y*tf,tf), nor);\n\n        vec3 ref = reflect(rd, nor);\n        float spe = max(dot(ref, lightDir), 0.0);\n        c += vec3(2.0) * pow(spe, 32.);\n    }\n\n    c *= 1.0 - 0.3*length(uv);\n\treturn c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 col = render(uv);\n\tfragColor = vec4(col, 1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llGfRV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llKBz3", "name": "Voronoi Wooble", "author": "beervgeer", "description": "Exercising wooble and voronoi with book of shaders.", "tags": ["voronoi", "shiny", "wooble"], "likes": 19, "viewed": 1239, "date": "1543487373", "time_retrieved": "2024-06-20T19:24:15.077740", "image_code": "\n\nuniform float rot;\nuniform float huecolor;\nuniform float brightness;\n#define time iTime\n#define resolution iResolution.xy\nuniform vec2 mouse;\nuniform vec3 spectrum;\n\nuniform sampler2D texture0;\nuniform sampler2D texture1;\nuniform sampler2D texture2;\nuniform sampler2D texture3;\nuniform sampler2D prevFrame;\nuniform sampler2D prevPass;\n#define PI 3.14159265359\n\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);\n}\n\nvec3 rgb2hsb( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                d / (q.x + e),\n                q.x);\n}\n\n//  Function from I√±igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nfloat voronoiClassic(in vec2 st){\n    // Tile the space\n    vec2 i_st = floor(st);\n    vec2 f_st = fract(st);\n\n    float m_dist = 1.0;  // minimun distance\n    vec2 m_point ;\n    \n    for (int j=-1; j<=1; j++ ) {\n        for (int i=-1; i<=1; i++ ) {\n            vec2 neighbor = vec2(float(i),float(j));\n            vec2 point = random2(i_st + neighbor);\n            \n             point = 0.5 + 0.5*sin(time + 0.4 *sin(time*0.1) * point);\n             \n          \n            vec2 diff = neighbor + point - f_st;\n            float dist = length(diff);\n            \n           \n             m_dist = (min(m_dist, dist) + min(m_dist, m_dist*dist)) /2.;\n            \n        }\n    }\n    \n    \n\n    return m_dist ;\n   \n}   \n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 res = vec2(0);\n    res.x = resolution.x*0.5625;\n    res.y = resolution.y;\n    \n    vec2 st = fragCoord.xy/res.y;\n    \n    st.x -= 0.35;\n   \n    st.x +=  0.1 * sin(time *0.2) + 0.05 * sin(time *0.6);\n   \n    st.y +=  0.1 * sin(time*0.4) + 0.05 * sin(time*0.1);\n   \n    vec2 toCenter = vec2(0.5)-st;\n    float angle = atan(toCenter.y,toCenter.x);\n    \n  \n  \n    float radius = 1.- length(toCenter)*1.1;\n    \n    float deg = (1.+cos(time*0.1+ (radius*(11.299721*(sin(time*.1))))*radius))/2.;\n    \n    st -= vec2(0.5);\n  \n    st = rotate2d( deg )* st;\n    st += vec2(0.5);\n   \n    st *= 4.+ 2.*sin(time*.22);\n \n    \n    vec3 color = vec3(.0);\n    vec3 color2 = vec3(.0);\n   \t\n    float voronoi = voronoiClassic(st);\n    color.r += pow(voronoi ,2.)*3.5;\n    color.r = 1.-color.r;\n    color2.r += pow(voronoi ,radius*1.1)*2.2;\n    color2.r = 1.-color2.r;\n    color2.g += pow(voronoi ,radius*1.1)*2.2;\n    color2.g = 1.-color2.g;\n  \n\n    \n   vec3 hue = rgb2hsb(color);\n\n   hue.y = 0.709906*radius ;\n   vec3 hue2 = rgb2hsb(color2);\n   hue2.y = 0.709906*radius;\n   fragColor = vec4((hsb2rgb(hue) +color + hsb2rgb(hue2) + color2 )/1.9,radius);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llKBz3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llKfR1", "name": "Frequency on Frequencies", "author": "Jangalomph", "description": "frequency circle filled with frequency noise", "tags": ["circle"], "likes": 2, "viewed": 320, "date": "1541880206", "time_retrieved": "2024-06-20T19:24:15.077740", "image_code": "//I'm just learning how shaders work - Nick S.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord.xy/iResolution.xy; // 0 <> 1\n    \n    uv -=.5; // -0.5 <> 0.5\n    \n    uv.x *= iResolution.x/iResolution.y; // Fixes aspect ratio\n        \n    float d = length(uv);\n    float n = fract (iTime+sin(uv.x * 100. + uv.y * 1.)*1.55 );\n    float r = 0.04* sin(iTime*10.)+0.2;\n    r += 0.05 * sin(iTime);\n    \n    //float r = 0.5;\n    \n    float c = smoothstep(r, r-n, d);\n    \n    //c *= vec3(.6, .4, .2);\n\n    fragColor = vec4(vec3(c * vec3(.2, 0.8, 1.1)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llKfR1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lltBDB", "name": "Crazy Complex Map", "author": "Ebanflo", "description": "Rational functions are wild.\n\nNote that you can make the image much more tame by lowering the degrees of the numerator and denominator.", "tags": ["2d", "complex", "meromorphic"], "likes": 5, "viewed": 266, "date": "1541384364", "time_retrieved": "2024-06-20T19:24:15.077740", "image_code": "#define numeratorDegree 20\n#define denominatorDegree 20\n\n//thanks Fabrice\n#define shove(x) x + .2*sign(x)*step(abs(x), vec4(.2))\n\nvec4 pi = vec4(0,2,4,8)*atan(1.0);\n\nvec2 cmul (vec2 a, vec2 b){return mat2(a, -a.y, a.x)*b;}\nvec2 cinv(vec2 z){return vec2(z.x, -z.y)/dot(z, z);}\nvec2 cdiv (vec2 a, vec2 b){return cmul(a, cinv(b));}\n\n//bad random function that does what i want\nvec4 rand(int n){\n    vec4 r = sin(fract(vec4(762.314, 257.831, 856.374, 983.219)*float(n))\n               + vec4(345.6, 508.3, 448.9, 633.5)*float(n));\n    return shove(r);\n    \n}\n\nvec3 color(vec2 p){\n    return sqrt(sqrt(length(p)))*(0.5 + 0.5*sin(atan(p.y, p.x) + vec3(0, 0.333, 0.666)*pi.w));\n}\n\nvec2 f(vec2 z){\n    vec2 result = vec2(1, 0);\n    \n    for(int i = 1; i <= numeratorDegree; i++){\n        vec4 r = rand(i);\n        vec2 p = r.xy + r.z*sin(r.w*iTime + pi.xy);\n        result = cmul(result, z - p);\n    }\n    for(int i = 1; i <= denominatorDegree; i++){\n        vec4 r = rand(-i);\n        vec2 p = r.xy + r.z*sin(r.w*iTime + pi.xy);\n        result = cdiv(result, z - p);\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n    fragColor.rgb = color(f(p));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lltBDB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llVBDz", "name": "Cube Wall", "author": "_polymath", "description": "Is it raytracing? It is raycasting? Who even knows. It's as much a mystery as which ones are cubes and which ones are holes.", "tags": ["3d"], "likes": 5, "viewed": 395, "date": "1542818166", "time_retrieved": "2024-06-20T19:24:15.768609", "image_code": "\n// #define COLOURS\n\nvec2 rotate(vec2 p, float theta) {\n\tfloat s = sin(theta), c = cos(theta);\n\treturn vec2(\n\t\tp.x * c + p.y * s,\n\t\tp.y * c - p.x * s);\n}\n\nstruct camera {\n\tvec3 cam;\n    vec3 ray;\n};\n\nconst float ffd = 3.1415927 * .25;\ncamera makeIsometric(camera cam) {\n    cam.cam.yz = rotate(cam.cam.yz, ffd);\n    cam.cam.xz = rotate(cam.cam.xz, ffd);\n    cam.ray.yz = rotate(cam.ray.yz, ffd);\n    cam.ray.xz = rotate(cam.ray.xz, ffd);\n    return cam;\n}\n\ncamera mixCameras(camera a, camera b, float x) {\n    x = smoothstep(0., 1., x);\n\treturn camera(\n        mix(a.cam, b.cam, x),\n        mix(a.ray, b.ray, x));\n}\n\ncamera getCamera(int n, vec2 uv) {\n    switch(n) {\n        // case 1: // a perspective camera\n        case 2: // an isometric orthographic camera\n            return makeIsometric(camera(\n                vec3(uv * 6., 0.),\n                vec3(0., 0., 1.)));\n        case 3: // a balls-tripping reverse perspective camera\n            return makeIsometric(camera(\n                vec3(uv * 12., 0.),\n                normalize(vec3(-uv, 3.))));\n    }\n    // fall back to camera 1:\n    // an isometric perspective camera\n    return makeIsometric(camera(\n    \tvec3(0.),\n    \tnormalize(vec3(uv, 3.))));\n}\n\ncamera mixedCamera(int a, int b, float x, vec2 uv) {\n    return mixCameras(getCamera(a, uv), getCamera(b, uv), x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -(fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    \n \tfloat bigTime = mod(iTime / 10., 3.),\n        smallTime = fract(bigTime);\n    \n    camera cam;\n    \n    if (bigTime < 1.)\n        cam = mixedCamera(2, 1, smallTime, uv);\n    else if (bigTime < 2.)\n        cam = mixedCamera(1, 3, smallTime, uv);\n    else\n        cam = mixedCamera(3, 2, smallTime, uv);\n    //cam = getCamera(3, uv);\n    //cam = getCamera(3, uv);\n        \n    cam.cam.x += sin(iTime * 0.1);\n    cam.cam.y += cos(iTime * 0.682);\n    \n\t// so we have to march the ray through the cubes\n    // nothing interesting happens within 16 units of the camera\n    vec3 p = cam.cam + cam.ray * 16., ray = cam.ray;\n    float face;\n    vec3 cube;\n    \n    for (int i = 0; i < 70; ++i) {\n        vec3 distToNextPixel = 1. - fract(p * sign(ray));\n        vec3 timeToNextPixel = abs(distToNextPixel / ray);\n\n        if (timeToNextPixel.x < timeToNextPixel.y\n            && timeToNextPixel.x < timeToNextPixel.z)\n        {\n            face = .3;\n            p += ray * timeToNextPixel.x;\n        }\n        else if (timeToNextPixel.y < timeToNextPixel.x\n                 && timeToNextPixel.y < timeToNextPixel.z)\n        {\n            face = .6;\n            p += ray * timeToNextPixel.y;\n        }\n        else {\n            face = .9;\n            p += ray * timeToNextPixel.z;\n        }\n        cube = floor(p);\n        if (abs(cube.x) + abs(cube.y) + abs(cube.z) >= 30.)\n            break;\n    }\n    \n    vec3 col;\n    \n    #ifdef COLOURS\n    switch (int(mod(cube.x + cube.y - cube.z, 3.))) {\n        case 0: switch(int(mod(cube.x, 3.))) {\n            case 1: col = vec3(.5, .9, .2); break;\n            case 2: col = vec3(.9, .4, .2); break;\n            case 0: col = vec3(.2, .3, .9); break;\n        } break;\n    \tcase 1: switch(int(mod(cube.x, 3.))) {\n            case 2: col = vec3(.5, .9, .2); break;\n            case 0: col = vec3(.9, .4, .2); break;\n            case 1: col = vec3(.2, .3, .9); break;\n        } break;\n    \tcase 2: switch(int(mod(cube.x, 3.))) {\n            case 0: col = vec3(.5, .9, .2); break;\n            case 1: col = vec3(.9, .4, .2); break;\n            case 2: col = vec3(.2, .3, .9); break;\n        } break;\n    }\n    #else\n    col = vec3(.9);\n    #endif\n\n    fragColor = vec4(col * face, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llVBDz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llVBWw", "name": "Crap Julia", "author": "milolouis", "description": "crap juila", "tags": ["juliacrap"], "likes": 1, "viewed": 85, "date": "1542805064", "time_retrieved": "2024-06-20T19:24:15.768609", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float res = 4.0;\n    int max = int(pow(2.0, res * 3.0));\n    \n    float div = pow(2.0, res);\n    \n    vec2 c = vec2(-0.7, 0.27015);\n    vec2 move = vec2(- 0.8,0.0);\n    float zoom = 0.5 + (pow(iTime, 3.0) / 8.0);\n    \n    int iteration = max;\n    \n    vec2 z;\n    z.x = 1.5*(fragCoord.x - iResolution.x/2.0)/(0.5*zoom*iResolution.x) + move.x;\n    z.y = 1.0*(fragCoord.y - iResolution.y/2.0)/(0.5*zoom*iResolution.y) + move.y;\n    \n    while (((z.x*z.x+z.y*z.y) < 4.0) && (iteration > 1)) {\n        float tmp = (z.x*z.x - z.y*z.y) + c.x;\n        z.y = 2.0*z.x*z.y + c.y;\n        z.x = tmp;\n        iteration--;\n    }\n    \n    float r = float(iteration % int(div)) / div;\n    float g = float((iteration >> int(res)) % int(div)) / div;\n    float b = float((iteration >> (int(res) * 2)) % int(div)) / div;\n\n    fragColor = vec4(r,g,b,1.0);        \n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llVBWw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llyBDD", "name": "WarpingBall", "author": "Falko", "description": "use mouse to rotate camera", "tags": ["procedural"], "likes": 2, "viewed": 66, "date": "1542566209", "time_retrieved": "2024-06-20T19:24:17.211138", "image_code": "vec3 v;\nvec3 lightSource = vec3(20.0, 0.0, 6.0);\nfloat bLightSource = 0.6;\nfloat ba = 0.4;\n\nvec2 random2(vec2 st, float n){\n    //computed values have to be n-periodic in y-direction\n    //on both poles of the sphere gradients are identically\n    //set to zero to avoid discontinuity\n    vec2 stPeriodic = vec2(st.x, mod(st.y, n));\n    if(abs(st.x)<=1.01 || abs(st.x-n)<=1.01){\n        return vec2(0.0);\n    }\n    else{\n    //hash function to generate noise\n    stPeriodic = vec2( dot(stPeriodic,vec2(127.1,311.7)),\n              dot(stPeriodic,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(stPeriodic)*43758.177);\n    }\n    \n    }\n\n\n\n\n\nfloat gNoise(vec2 st, float n) {\n    //gradient noise\n\tvec2 i = floor(st);\n\tvec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0), n), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0), n), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0), n), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0), n), f - vec2(1.0,1.0) ), u.x), u.y);\n    }\n\nfloat pi(){\n \treturn radians(180.0);   \n}\n\n\nvec2 intersectCircle(vec2 cp, vec2 rView){\n    //compute p and q from pq-formula\n            float cp_projected = dot(rView, cp);\n            return vec2(cp_projected, pow(cp_projected, 2.0)-dot(cp, cp));\n    }\n\nvec2 intersectBall(vec3 cp, vec3 rView){\n    //compute p and q from pq-formula\n            float cp_projected = dot(rView, cp);\n            return vec2(cp_projected, pow(cp_projected, 2.0)-dot(cp, cp));\n    }\n\nfloat diffuse(vec3 p, vec3 normal){\n            vec3 dirLight = normalize(lightSource-p);\n            return bLightSource*max(0.0, dot(normal, dirLight));\n    }\n\n\nfloat specular(vec3 normal, vec3 p, vec3 rCamera){\n            vec3 dir_light = normalize(p-lightSource);\n            vec3 dir_reflect = reflect(dir_light, normal);\n            float spec = pow(max(0.0, dot(rCamera, dir_reflect)), 200.0);\n            return spec;\n            \n    }\n\nvec3 chess(vec3 p, vec3 pFrag){\n    //computes the chess pattern with diffuse lightning\n    vec3 cSand = vec3(0.76, 0.7, 0.5);\n    vec3 cSandStone = vec3(0.76, 0.57, 0.5);\n    vec3 cRock = vec3(0.71, 0.7, 0.65);\n \t\n    float tileSize = 4.0;\n    float pixSize = 3.0*2.0*length(v-p)\n        \t\t\t\t\t\t\t/(min(iResolution.x, iResolution.y)\n                                    *length(v-pFrag)\n                                    *tileSize);\n    \n    vec2 ij = floor(p.xy/tileSize);\n   \tvec3 cChess;\n    if(mod(ij.x, 2.0)==mod(ij.y, 2.0)){\n        cChess = cSand;\n    }\n    else{\n     \tcChess = cSandStone;   \n    }\n    \n    vec2 pLocal = abs(fract(p.xy/tileSize)-0.5);\n    float maxLocal = max(pLocal.x, pLocal.y);\n    \n    float bd = diffuse(p, vec3(0.0, 0.0, 1.0));\n    return (ba+bd)*mix(cRock, cChess, smoothstep(0.0, pixSize, 0.49-maxLocal));  \n}\n\nvec3 rostrum(vec3 p, vec3 rView, float radius){\n    //essentially intersect ray with cylinder\n    vec3 cRock = vec3(0.71, 0.7, 0.65);\n    float h = 2.0;\n \t\n    vec2 sol = intersectCircle(-p.xy, normalize(rView.xy));\n    \n    vec3 pCylinder = p + rView*\n        \t\t\t\t(sol.x+sqrt(sol.y+pow(radius, 2.0)))\n                         /length(rView.xy);\n    \n    vec3 nCylinder = normalize(vec3(-pCylinder.xy, 0.0));\n    vec3 pPlane = p - (p.z-h) * rView / rView.z;\n    \n    float bd = mix(diffuse(pCylinder, nCylinder),\n             diffuse(pPlane, vec3(0.0, 0.0, 1.0)),\n             smoothstep(h-0.1, h, pCylinder.z));\n    return (ba+bd)*cRock;\n}\n\nvec3 computeBackground(vec3 p, vec3 rView){\n \tvec3 cSand = vec3(0.76, 0.7, 0.5);\n    vec3 cSandStone = vec3(0.76, 0.57, 0.5);\n    vec3 cSky = vec3(0.5, 0.76, 0.7);\n    \n    //check if XY-plane is visible\n    if(dot(rView, vec3(0.0, 0.0, 1.0))>-0.01*3.14){\n     \treturn cSky;   \n    }\n    \n    //calculate intersection with XY-plane\n    vec3 pXY = p - p.z * rView / rView.z;\n    float l0 = length(pXY);\n    float l1 = length(p - (p.z-2.0) * rView / rView.z);\n    \n    \n    if(l1>30.0){\n        \n     \treturn cSky;  \n    }\n    else if(l0>25.0){\n        vec3 cRostrum = rostrum(p, rView, 25.0);\n        vec3 mix0 = mix(chess(pXY, p), cRostrum,\n                   smoothstep(25.0, 25.4, l0));  \n     \treturn mix(mix0, cSky,\n                   smoothstep(29.3, 30.0, l1));   \n    }\n    else{\n        return chess(pXY, p); \n     \t\n    }\n}\n\n\n    \n\nmat3 rotationMatrix(const float angle, const vec3 axis){\n \tfloat alpha = radians(angle);\n    float c = cos(alpha);\n    float s = sin(alpha);\n    mat3 R;\n    R[0] = axis * axis.x * (1.0-c) + vec3(c, axis.z*s, -axis.y*s);\n    R[1] = axis * axis.y * (1.0-c) + vec3(-axis.z*s, c, axis.x*s);\n    R[2] = axis * axis.z * (1.0-c) + vec3(axis.y*s, -axis.x*s, c);\n    return R;\n}\n\nvec3 getCameraPosition(vec4 mouse){\n    //computes position of camera from difference between\n    //clicked and current pixel-coordinates\n    vec3 v0 = 20.0*vec3(1.0, 0.0, 1.0);\n    \n    if(iMouse.w<0.){\n        return v0;\n    }\n    else{\n        vec3 v;\n    \tvec2 angle = 200.0*(mouse.xy-mouse.zw);\n        angle.y = min(abs(angle.y), 40.0)*sign(angle.y);\n        \n        vec3 axVert = vec3(0.0, 0.0, 1.0);\n        mat3 rVert = rotationMatrix(angle.x, axVert);\n        v = rVert*v0;\n        \n        vec3 axFlat = normalize(cross(-v, axVert));\n\t\tmat3 rFlat = rotationMatrix(angle.y, axFlat);\n        return rFlat*v;\n    }\n}\n\nfloat f(vec2 polar, float n){\n \t//deviation from radius\n    \n    \n    return 0.5*(1.0+sin(iTime+5.0*gNoise(polar, n)));\n}\n\nvec3 polarToSpace(vec2 polar, float n){\n    //convert polar coordinates to euclidean\n    polar = vec2(polar.x*pi()/n, 2.0*pi()*polar.y/n); \n \treturn vec3(cos(polar.x), \n               \tsin(polar.x)*-sin(polar.y),\n               \tsin(polar.x)*-cos(polar.y));\n    \n}\n\nvec3 reflectionBall(vec3 pSurface, vec3 normal, vec3 pFrag, vec3 rView){\n    //compute the reflection in the balls surface\n    vec3 rReflected = reflect(rView, normal);\n    vec3 pFragReflected = pSurface - rReflected * length(pSurface-pFrag);\n    return computeBackground(pFragReflected, rReflected);\n               \n}\n\nvec3 warpedSurface(vec3 p, vec3 center, vec3 rView, float radius){\n    //compute the perturbed normals of the \n    //warped surface (bump map, no true normals or positions)\n    \n    vec3 cLemon = vec3(1.0, 0.88, 0.0);\n    vec3 pNormalized = normalize(p-center);\n   \tfloat n = 13.0;\n    \n   \tvec2 pz = normalize(pNormalized.zy);\n           \n   \tvec2 polar = vec2(n*acos(pNormalized.x)/pi(),\n                      0.5*n*(acos(pz.x)*sign(pz.y)/pi()+1.0));\n    \n    float h = 0.05;\t   \n   \n    float factor = 0.01;\n    float fVal = factor*f(polar, n);\n    \n  \tvec3 dx = ((1.0-factor*f(vec2(polar.x+h, polar.y), n))*\n               polarToSpace(vec2(polar.x+h, polar.y), n)-\n               (1.0-fVal)*\n               pNormalized)/h;\n    vec3 dy = ((1.0-factor*f(vec2(polar.x, polar.y+h), n))*\n               polarToSpace(vec2(polar.x, polar.y+h), n)-\n               (1.0-fVal)*\n               pNormalized)/h;\n                      \n    vec3 normal = -normalize(cross(dx, dy));\n    \n    //add lightning and reflection\n    float bd = diffuse(p, normal); \n    float spec = specular(normal, p, -rView);\n    \n    vec3 reflection = reflectionBall(p+pNormalized*fVal,\n                                     normal,\n                                     v,\n                                     rView);\n   \treturn mix(mix((ba+bd)*cLemon, reflection, 0.3),\n              vec3(1.0), spec);\n           \n           \n   \n   }\n\n\nvec4 computeObject(vec3 p, vec3 rView){\n    //compute intersection of viewing ray with sphere\n    //calculate color\n    vec3 center = vec3(0.0, 0.0, 6.0);\n    float radius =  5.0;\n    \n    vec2 sol = intersectBall(center-p, rView);\n    \n    if(pow(radius, 2.0)+sol.y>0.0){\n           float temp = sol.x+sqrt(sol.y+pow(radius, 2.0));\n           vec3 p1 = p+(-sol.y-pow(radius, 2.0)+pow(sol.x, 2.0))*rView/temp;\n           \n           vec3 color = warpedSurface(p1, center, rView, radius);\n           return vec4(color , smoothstep(0.0, 0.3, pow(radius, 2.0)+sol.y));\n           }\n           else{\n           return vec4(0.0);\n            }        \n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.0*(fragCoord-0.5*iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec4 mouse = iMouse/min(iResolution.x, iResolution.y);\n    \n    // set up camera\n   \n    v = getCameraPosition(mouse);\n    vec3 vDir = normalize(-v);\n    vec3 vLeft = normalize(cross(vDir, vec3(0.0, 0.0, 1.0)));\n    vec3 vUp = cross(vLeft, vDir);\n    float dScreen = 2.5;\n    \n    //calculate fragment position in space\n    vec3 pFrag = v + dScreen * vDir + uv.x*vLeft + uv.y * vUp;\n    \n    vec3 rView = normalize(pFrag-v);\n    \n    vec4 colorBall = computeObject(pFrag, rView);\n    \n    vec3 color = computeBackground(pFrag, rView);\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(mix(color, colorBall.xyz, colorBall.w),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llyBDD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llyBRG", "name": "4.6.12 Truchet", "author": "fizzer", "description": "Truchet tiling using the semi-regular tiling made of squares, hexagons, and dodecagons. This is based on the idea that any regular polygon with an even number of sides can be used as a Truchet tile. The big arrays seem to cause big slowdown on WebGL...", "tags": ["hexagon", "truchet", "tiling", "dodecagon"], "likes": 20, "viewed": 379, "date": "1542916626", "time_retrieved": "2024-06-20T19:24:18.568700", "image_code": "// Truchet tiling using the semi-regular tiling made of squares, hexagons, and dodecagons.\n// This is based on the idea that any regular polygon with an even number of sides can be used\n// as a Truchet tile.\n//\n// Inspired by this JavaScript canvas version here: http://somethingorotherwhatever.com/truchet-polygons/\n//\n// The side connection tables were pre-generated using my own rather brute-force program.\n//\n// 4.8^2 version is here: https://www.shadertoy.com/view/MlyBRG\n//\n// Weaved version is here: https://www.shadertoy.com/view/WsyXWR\n//\n\nfloat pi = 3.141592653589;\n\nfloat hash(vec2 p)\n{\n    return texelFetch(iChannel0, ivec2(p) & 255, 0).r;\n}\n\n/*\n// Returns the origin and radius of a circle intersecting a and b, with tangents\n// at a and b pointing towards vec2(0). This is for drawing the circular arcs.\nvoid solveCircle(vec2 a, vec2 b, out vec2 o, out float r)\n{\n    float th = acos(dot(normalize(a), normalize(b))) / 2.;\n    float adj = length(a);\n    r = tan(th) *adj;\n    o = normalize((a + b) / 2.) * sqrt(r * r + adj * adj);\n}\n*/\n\n// (via comments on https://www.shadertoy.com/view/wdBSRm):\n// adx's considerably more concise version of the method above.\n// On a side note, if you haven't seen it before, his \"Quake / Introduction\" \n// shader is well worth the look: https://www.shadertoy.com/view/lsKfWd\nvoid solveCircle(vec2 a, vec2 b, out vec2 o, out float r){\n    \n    vec2 m = a + b;\n    o = dot(a, a)/dot(m, a)*m;\n    r = length(o - a);\n    \n}\n\n// Pixel width for anti-aliasing.\nfloat w;\n\n// Draws a line or arc connecting a and b inside a polygon.\nfloat l(vec2 p, vec2 a, vec2 b)\n{\n    if(dot(normalize(a), normalize(b)) < -.99999)\n    {\n        float d = distance(p, mix(a, b, clamp(dot(p - a, b - a) / dot(b - a,b - a), 0., 1.)));\n        return smoothstep(0.03, 0.03 - w * 2., d - .02);\n    }\n\n    vec2 o;\n    float r;\n    solveCircle(a, b, o, r);\n    return smoothstep(0.03, 0.03 - w * 2., abs(distance(p, o) - r) - .02);\n}\n\n// Array of unique hexagon side connections without overlaps.\nconst float arr6[2*3*2] = float[2*3*2](\n    1., 2., 3., 4., 5., 6.,\n    1., 2., 3., 6., 4., 5.\n);\n\n// Array of unique dodecagon side connections without overlaps.\nconst float arr12[29*6*2] = float[29*6*2](\n    1. , 2. ,  3. , 4. ,  5. , 6. ,  7. , 8. ,  9. , 10. ,  11. , 12. ,\n    1. , 2. ,  3. , 4. ,  5. , 6. ,  7. , 8. ,  9. , 12. ,  10. , 11. ,\n    1. , 2. ,  3. , 4. ,  5. , 6. ,  7. , 12. ,  8. , 9. ,  10. , 11. ,\n    1. , 2. ,  3. , 4. ,  5. , 6. ,  7. , 12. ,  8. , 11. ,  9. , 10. ,\n    1. , 2. ,  3. , 4. ,  5. , 8. ,  6. , 7. ,  9. , 12. ,  10. , 11. ,\n    1. , 2. ,  3. , 4. ,  5. , 12. ,  6. , 7. ,  8. , 9. ,  10. , 11. ,\n    1. , 2. ,  3. , 4. ,  5. , 12. ,  6. , 7. ,  8. , 11. ,  9. , 10. ,\n    1. , 2. ,  3. , 4. ,  5. , 12. ,  6. , 9. ,  7. , 8. ,  10. , 11. ,\n    1. , 2. ,  3. , 4. ,  5. , 12. ,  6. , 11. ,  7. , 8. ,  9. , 10. ,\n    1. , 2. ,  3. , 4. ,  5. , 12. ,  6. , 11. ,  7. , 10. ,  8. , 9. ,\n    1. , 2. ,  3. , 6. ,  4. , 5. ,  7. , 8. ,  9. , 12. ,  10. , 11. ,\n    1. , 2. ,  3. , 6. ,  4. , 5. ,  7. , 12. ,  8. , 9. ,  10. , 11. ,\n    1. , 2. ,  3. , 6. ,  4. , 5. ,  7. , 12. ,  8. , 11. ,  9. , 10. ,\n    1. , 2. ,  3. , 8. ,  4. , 5. ,  6. , 7. ,  9. , 12. ,  10. , 11. ,\n    1. , 2. ,  3. , 8. ,  4. , 7. ,  5. , 6. ,  9. , 12. ,  10. , 11. ,\n    1. , 2. ,  3. , 12. ,  4. , 5. ,  6. , 7. ,  8. , 9. ,  10. , 11. ,\n    1. , 2. ,  3. , 12. ,  4. , 5. ,  6. , 7. ,  8. , 11. ,  9. , 10. ,\n    1. , 2. ,  3. , 12. ,  4. , 5. ,  6. , 9. ,  7. , 8. ,  10. , 11. ,\n    1. , 2. ,  3. , 12. ,  4. , 5. ,  6. , 11. ,  7. , 8. ,  9. , 10. ,\n    1. , 2. ,  3. , 12. ,  4. , 5. ,  6. , 11. ,  7. , 10. ,  8. , 9. ,\n    1. , 2. ,  3. , 12. ,  4. , 7. ,  5. , 6. ,  8. , 9. ,  10. , 11. ,\n    1. , 2. ,  3. , 12. ,  4. , 7. ,  5. , 6. ,  8. , 11. ,  9. , 10. ,\n    1. , 2. ,  3. , 12. ,  4. , 9. ,  5. , 6. ,  7. , 8. ,  10. , 11. ,\n    1. , 2. ,  3. , 12. ,  4. , 9. ,  5. , 8. ,  6. , 7. ,  10. , 11. ,\n    1. , 2. ,  3. , 12. ,  4. , 11. ,  5. , 6. ,  7. , 8. ,  9. , 10. ,\n    1. , 2. ,  3. , 12. ,  4. , 11. ,  5. , 6. ,  7. , 10. ,  8. , 9. ,\n    1. , 2. ,  3. , 12. ,  4. , 11. ,  5. , 8. ,  6. , 7. ,  9. , 10. ,\n    1. , 2. ,  3. , 12. ,  4. , 11. ,  5. , 10. ,  6. , 7. ,  8. , 9. ,\n    1. , 2. ,  3. , 12. ,  4. , 11. ,  5. , 10. ,  6. , 9. ,  7. , 8.\n);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.y;\n\n    fragColor = vec4(1);\n\n    vec2 p = uv.xy * 5.;\n\n    w = max(length(dFdx(p)), length(dFdy(p)));\n\n    p.x += iTime / 3.;\n\n    // The plane is first divided in to equilaterial triangles.\n    \n    float s = 1. / sqrt(3.);\n\n    vec2 op = p;\n\n    p.x /= s;\n    p.x += mod(floor(p.y), 2.);\n\n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n\n    if(fp.x > mix(fp.y, 1. - fp.y, mod(ip.x, 2.)))\n        ip.x += 1.;\n\n    fp = p - ip;\n\n    fp.x *= s;\n    fp.y -= 1. / 3. + mod(ip.x + 1., 2.) / 3.;\n\n    if(mod(ip.x, 2.) > .5)\n        fp.y =- fp.y;\n\n    float a = 0.;\n\n    vec3 col = vec3(1, 1, 0);\n\n    fp.x = abs(fp.x);\n\n    float th = pi * 2. / 3.;\n\n    // Use the symmetry of the figure within the triangular tile.\n    \n    if(dot(fp, vec2(cos(th), sin(th))) < 0.)\n        fp = fp - vec2(cos(th), sin(th)) * dot(fp, vec2(cos(th), sin(th))) * 2.;\n\n    fp.x = abs(fp.x);\n\n    float dd = fp.y;\n    dd = max(dd, dot(fp, vec2(sin(th), -cos(th))));\n\n\t// Get the precise distances of the tile edges.\n    \n    float c = tan(pi * 2. / 6.) / (3. * tan(pi * 2. / 6.) + 3.);\n    float e = 1. / 3. - c;\n    float f = 1. / (3. * cos(pi * 2. / 6.)) - c;\n\tfloat g = 0.;\n    \n    if(dd - c < 0.)\n    {\n        // Hexagon.\n        op = op * vec2(1. / s, 1) + vec2(.5, 0);\n        ip = floor(op);\n\n        vec2 fp = op - ip - .5;\n\n        fp.x *= s;\n        fp.y -= 1. / 6. * (1. - 2. * mod(ip.x + ip.y, 2.));\n\n        float th = pi * 2. / 6.;\n\n        float tha = th*(floor(6. * hash(ip * 3. + 2.)) + .5);\n        fp *= mat2(cos(tha), sin(tha), -sin(tha), cos(tha));\n\n        int i = int(floor(hash(ip * 13. + 99.) * 1.999));\n\n        for(int j = 0; j < 3; j += 1)\n        {\n            float ia = arr6[i * 6 + j * 2 + 0] - 1.;\n            float ib = arr6[i * 6 + j * 2 + 1] - 1.;\n            a += l(fp, c * vec2(cos(th * float(ia)), sin(th * float(ia))), c * vec2(cos(th * float(ib)), sin(th * float(ib))));\n        }\n\n        g = max(g, smoothstep(-w * 2., 0., dd - c));\n\n        col = vec3(1, 0, 0);\n    }\n    else if((abs(fp.x)-e)<0.)\n    {\n        // Square.\n        op = op * vec2(1. / s, 2) + vec2(.5 + .5 * mod(floor(op.y * 2. + .5), 2.), .5);\n        ip = floor(op);\n\n        vec2 fp = op - ip - .5;\n\n        fp.x *= s;\n        fp.y /= 2.;\n\n        float th = pi * 2. / 4.;\n\n        float tha = th * floor(3.999 * hash(ip * 3. + 2.));\n\n        if(mod(ip.y, 2.) > .5)\n            tha += pi * 2. / 3. * .5 * (2. - mod(ip.x + floor(ip.y / 2.), 2.));\n\n        fp *= mat2(cos(tha), sin(tha), -sin(tha), cos(tha));\n\n        a += l(fp, +e * vec2(0., 1.), +e * vec2(sin(th), cos(th)));\n        a += l(fp, -e * vec2(0., 1.), -e * vec2(sin(th), cos(th)));\n\n        g = max(g, smoothstep(e - w * 2., e, max(abs(fp.x), abs(fp.y))));\n\n        col = vec3(0, 0, 1);\n    }\n    else\n    {\n        // Dodecagon.\n        op = op * vec2(1. / s / 2., 1.) + vec2(.5 + .5 * mod(floor(op.y + .5), 2.), .5);\n        ip = floor(op);\n\n        vec2 fp = op - ip - .5;\n\n        fp.x *= s * 2.;\n\n        float th = pi * 2. / 12.;\n\n        float tha = th * floor(12. * hash(ip * 3.));\n        fp *= mat2(cos(tha), sin(tha), -sin(tha), cos(tha));\n\n        int i = int(floor(hash(ip * 13. + 99.) * 28.999));\n\n        float d = -1.;\n\n        for(int j = 0; j < 6; j+=1)\n        {\n            float ia = arr12[i * 12 + j * 2 + 0] - 1.;\n            float ib = arr12[i * 12 + j * 2 + 1] - 1.;\n            a += l(fp, f * vec2(cos(th * float(ia)), sin(th * float(ia))), f * vec2(cos(th * float(ib)), sin(th * float(ib))));\n            d = max(d, abs(dot(fp, vec2(cos(th * float(j)), sin(th * float(j))))) - f);\n        }\n\n        g = max(g, smoothstep(-w * 2., 0., d));\n    }\n\n    // Shade.\n    col = mix(col, vec3(1), .3) + .2;    \n    col = mix(col, vec3(0), g);\n\n    float l = 1. - (min(fract(iTime / 4.) * 2., 2. - 2. * fract(iTime / 4.)) - .5) * 16.;\n\n    fragColor.rgb = mix(vec3(.8), col, smoothstep(0., 1., l));\n\n    fragColor.rgb = mix(fragColor.rgb, vec3(0), a);\n\n    // Gamma etc.\n    fragColor.rgb = pow(fragColor.rgb, vec3(1. / 2.2));\n}\n\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "4dXGR8", "previewfilepath": "/media/previz/buffer00.png", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/previz/buffer00.png", "ctype": "buffer"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llyBRG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llyBWR", "name": "randomgrid", "author": "Del", "description": "grid", "tags": ["grid"], "likes": 7, "viewed": 401, "date": "1542200968", "time_retrieved": "2024-06-20T19:24:18.574826", "image_code": "// simple random grid...\n\n#define rand(p)  fract(sin(dot(p ,vec2(12.9898,78.233))) * 43758.5453)\n\nfloat grid(vec2 uv, float scale, float thickness)\n{\n    //vec2 g2 = step(thickness,fract(uv));\n    vec2 g2 = smoothstep(0.,1.5*scale/iResolution.y,abs(fract(uv+.5)-.5)-thickness/2.);\n    return min(g2.x,g2.y);\n}\n\n\nfloat RandomGrid(vec2 uv,float scale)\n{\n    uv *= scale;\n    float g = grid(uv,scale,0.25);\n\treturn rand(floor(uv)/scale)*g;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = ( fragCoord -.5*iResolution.xy ) / iResolution.y;\n    uv.xy += iTime*0.25;\n    float scale = 20.0;\n    float v = RandomGrid(uv,scale);\n    vec3 c1 = vec3(0.2,0.2,0.2);\n    vec3 c2 = vec3(0.0,0.9,0.9);\n    fragColor = vec4(mix(c1,c2,v),1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llyBWR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llyBz1", "name": "Raymarch anything", "author": "Del", "description": "something I doodled in GLSL sandbox :)", "tags": ["raymarch", "anything"], "likes": 3, "viewed": 379, "date": "1541781516", "time_retrieved": "2024-06-20T19:24:18.574826", "image_code": "// you can literally raymarch anything :)\nfloat Turb(vec2 p)\n{\n\tp*=0.25;\n\tp.x *= 0.7;\n\tfloat ti = iTime*0.125;\n\tp.y += ti;\n\tvec2 i = p;\n\t\n\tfloat c = -0.1;\n\tfloat inten = 0.15;\n\tfloat r = length(p+vec2(sin(ti),sin(ti*0.433))*2.);\n\t\n\tfor (float n = 0.0; n < 4.0; n+=1.0)\n\t{\n\t\tfloat t = r-ti * (1.0 - (1.9 / (n+1.)));\n\t\t      t = r-ti/(n+0.6);\n\t\ti -= p.yx + vec2(\n\t\t\tcos(t*0.1 - i.x-r) + sin(t*0.1 + i.y), \n\t\t\tsin(t*0.7 - i.y) + cos(t*0.4 + i.x)+r\n\t\t);\n\t\tc += 1.0/length(vec2(\n\t\t\t(sin(i.x+t)/inten),\n\t\t\t(cos(i.y+t)/inten)\n\t\t\t)\n\t\t);\n\t}\n\tc = smoothstep(0.0,1.0,c*0.75);\n\treturn c * 0.3;\n}\n\n\nfloat map(vec3 p)\n{\n\tp.x + sin(p.z+iTime)*0.5;\n\tp.x *= sign(p.y);\t// mirror top->bottom\n\tfloat k = Turb(p.xz);\n\treturn 3.5 -abs(p.y) - k;\n}\n\nvec3 normal(vec3 p) {\n\tvec2 e = vec2(.001, 0.);\n\tvec3 n;\n\tn.x = map(p + e.xyy) - map(p - e.xyy);\n\tn.y = map(p + e.yxy) - map(p - e.yxy);\n\tn.z = map(p + e.yyx) - map(p - e.yyx);\n\treturn normalize(n);\n}\n\nvec3 render(vec2 uv)\n{\n\tvec3 ro = vec3(sin(iTime)*0.25, cos(iTime)*0.25, iTime*0.75);\n\tvec3 rd = normalize(vec3(uv, .5));\n\tvec3 p = vec3(0.);\n\tfloat t = 0.;\n\tfor (int i = 0; i < 80; i++)\n    {\n\t\tp = ro + rd * t;\n\t\tfloat d = map(p);\n\t\tif (d < .001 || t > 100.) break;\n\t\tt += .5 * d;\n\t}\n\tvec3 l = ro;\n\tvec3 n = normal(p);\n\tvec3 lp = normalize(l - p);\n\tfloat diff = .5 * max(dot(lp, n), 0.);\n\treturn vec3(diff*0.54,diff*2.8,diff*1.85) / (1. + t * t * .01);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 col = render(uv);\n\tfragColor = vec4(col, 1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llyBz1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llyBzm", "name": "Growing Bumpy Polyhedron", "author": "dr2", "description": " Bumpy Fibonacci polyhedron with increasing face count (shown); use mouse to  focus on active region.\n", "tags": ["fibonacci", "polyhedron"], "likes": 12, "viewed": 531, "date": "1542110243", "time_retrieved": "2024-06-20T19:24:19.569022", "image_code": "// \"Growing Bumpy Polyhedron\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val);\nvec3 RotToDir (vec3 v1, vec3 v2, vec3 p);\n\nvec3 ltDir;\nfloat dstFar, tCur, tFrac, nFace, nFaceN;\nconst float pi = 3.14159, phi = 1.618034;\n\nvec4 SphFib (vec3 v, float n)\n{   // Keinert et al's inverse spherical Fibonacci mapping\n  vec4 b;\n  vec3 vf, vfMin;\n  vec2 ff, c;\n  float fk, ddMin, dd, a, z, ni;\n  ni = 1. / n;\n  fk = pow (phi, max (2., floor (log (n * pi * sqrt (5.) * dot (v.xy, v.xy)) /\n     log (phi + 1.)))) / sqrt (5.);\n  ff = vec2 (floor (fk + 0.5), floor (fk * phi + 0.5));\n  b = vec4 (ff * ni, pi * (fract ((ff + 1.) * phi) - (phi - 1.)));\n  c = floor ((0.5 * mat2 (b.y, - b.x, b.w, - b.z) / (b.y * b.z - b.x * b.w)) *\n     vec2 (atan (v.y, v.x), v.z - (1. - ni)));\n  ddMin = 4.1;\n  for (int j = 0; j < 4; j ++) {\n    a = dot (ff, vec2 (j - 2 * (j / 2), j / 2) + c);\n    z = 1. - (2. * a + 1.) * ni;\n    vf = vec3 (sin (2. * pi * fract (phi * a) + vec2 (0.5 * pi, 0.)) * sqrt (1. - z * z), z);\n    dd = dot (vf - v, vf - v);\n    if (dd < ddMin) {\n      ddMin = dd;\n      vfMin = vf;\n    }\n  }\n  return vec4 (sqrt (ddMin), vfMin);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec4 f4;\n  float d, dn, s;\n  f4 = SphFib (normalize (p), nFace);\n  s = sqrt (nFace) / 10.;\n  d = RotToDir (f4.yzw, vec3 (0., 0., 1.), p - f4.yzw).z - 1. +\n     0.1 * smoothstep (0.07, 0.17, f4.x * s) / s;\n  if (tFrac > 0.) {\n    f4 = SphFib (normalize (p), nFaceN);\n    dn = RotToDir (f4.yzw, vec3 (0., 0., 1.), p - f4.yzw).z - 1. +\n       0.1 * smoothstep (0.07, 0.17, f4.x * s) / s;\n    d = mix (d, dn, smoothstep (0., 1., tFrac));\n  }\n  return 0.8 * d;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0002 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float dstObj;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col = vec3 (0., 0.9, 0.) * (0.2 + 0.2 * max (dot (vn, - ltDir), 0.) +\n       0.7 * pow (max (dot (vn, ltDir), 0.), 2.)) +\n       0.3 * vec3 (1., 0., 0.) * pow (max (dot (normalize (ltDir - rd), vn), 0.), 16.);\n  } else col = vec3 (0., 0., 0.3 * (0.7 - 0.2 * rd.y));\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvv, ori, ca, sa;\n  float el, az, tStep, nfMax;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tStep = 0.1;\n  nfMax = 4000.;\n  nFace = 6. + mod (floor (tCur / tStep), nfMax - 5.);\n  nFaceN = min (nFace + 1., nfMax);\n  tFrac = (fract (tCur / tStep) - 0.7) / 0.3;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az += 0.05 * pi * tCur;\n    el += 0.4 * pi * sin (0.01 * pi * tCur);\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 0., -12.);\n  rd = vuMat * normalize (vec3 (uv, 5.));\n  dstFar = 20.;\n  ltDir = vuMat * normalize (vec3 (-0.3, 0.5, -1.));\n  col = ShowScene (ro, rd);\n  uv += vec2 (-1.4, 0.9);\n  uvv = abs (uv + vec2 (0.2, -0.05)) - vec2 (0.23, 0.08);\n  if (max (uvv.x, uvv.y) < 0.) col = mix (col, vec3 (0.5, 1., 0.5),\n     ShowInt (uv, vec2 (0.4, 0.1), 4., nFace));\n  fragColor = vec4 (col, 1.);\n}\n\nfloat DigSeg (vec2 q)\n{\n  return (1. - smoothstep (0.12, 0.15, abs (q.x))) *\n     (1. - smoothstep (0.55, 0.65, abs (q.y)));\n}\n\n#define DSG(q) k = kk;  kk = k / 2;  if (kk * 2 != k) d = max (d, DigSeg (q));\n\nfloat ShowDig (vec2 q, int iv)\n{\n  float d;\n  int k, kk;\n  const vec2 vp = vec2 (0.5, 0.5), vm = vec2 (-0.5, 0.5), vo = vec2 (1., 0.);\n  if (iv == -1) k = 8;\n  else if (iv <= 1) k = (iv == 0) ? 119 : 36;\n  else if (iv <= 3) k = (iv == 2) ? 93 : 109;\n  else if (iv <= 5) k = (iv == 4) ? 46 : 107;\n  else if (iv <= 7) k = (iv == 6) ? 122 : 37;\n  else              k = (iv == 8) ? 127 : 47;\n  q = (q - 0.5) * vec2 (1.8, 2.3);\n  d = 0.;\n  kk = k;\n  DSG (q.yx - vo)  DSG (q.xy - vp)  DSG (q.xy - vm)  DSG (q.yx)\n  DSG (q.xy + vm)  DSG (q.xy + vp)  DSG (q.yx + vo)\n  return d;\n}\n\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, sgn, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (min (q.x, q.y) >= 0. && max (q.x, q.y) < 1.) {\n    q.x *= mxChar;\n    sgn = sign (val);\n    val = abs (val);\n    nDig = (val > 0.) ? floor (max (log (val) / log (10.), 0.)) + 1. : 1.;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = val / pow (10., mxChar - idChar - 1.);\n    if (sgn < 0.) {\n      if (idChar == mxChar - nDig - 1.) s = ShowDig (q, -1);\n      else ++ v;\n    }\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n\nvec3 RotToDir (vec3 v1, vec3 v2, vec3 p)\n{\n  vec3 n;\n  float c;\n  n = normalize (cross (v1, v2));\n  c = dot (v1, v2);\n  return c * p + sqrt (1. - c * c) * cross (n, p) + (1. - c) * dot (n, p) * n;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llyBzm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llyfRh", "name": "Fibonacci Polyhedra", "author": "dr2", "description": "Faberge meets Fibonacci (no. 5 in the \"egg\" series)", "tags": ["reflection", "fibonacci", "egg", "polyhedron", "faberge"], "likes": 9, "viewed": 399, "date": "1541756474", "time_retrieved": "2024-06-20T19:24:20.987169", "image_code": "// \"Fibonacci Polyhedra\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Faberge meets Fibonacci (no. 5 in the \"egg\" series)\n  The Fibonacci scheme for near-uniform covering a sphere with disks is used to\n  construct polyhedra.\n*/\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrEllips2Df (vec3 p, vec2 r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nvec3 RotToDir (vec3 v1, vec3 v2, vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltDir, qHit, vdFib;\nvec2 opCs, rotCs, rShell;\nfloat tCur, dstFar, opPhs, nFace;\nint idObj;\nconst int idShell = 1, idHing = 2, idArm = 3, idPolyh = 4;\nconst float pi = 3.14159, phi = 1.618034;\n\nvec3 SphFib (vec3 v, float n)\n{   // based on Keinert et al's inverse spherical Fibonacci mapping\n  vec4 b;\n  vec3 vf, vfMin;\n  vec2 ff, c;\n  float fk, ddMin, dd, a, z, ni;\n  ni = 1. / n;\n  fk = pow (phi, max (2., floor (log (n * pi * sqrt (5.) * dot (v.xy, v.xy)) /\n     log (phi + 1.)))) / sqrt (5.);\n  ff = vec2 (floor (fk + 0.5), floor (fk * phi + 0.5));\n  b = vec4 (ff * ni, pi * (fract ((ff + 1.) * phi) - (phi - 1.)));\n  c = floor ((0.5 * mat2 (b.y, - b.x, b.w, - b.z) / (b.y * b.z - b.x * b.w)) *\n     vec2 (atan (v.y, v.x), v.z - (1. - ni)));\n  ddMin = 4.1;\n  for (int j = 0; j < 4; j ++) {\n    a = dot (ff, vec2 (j - 2 * (j / 2), j / 2) + c);\n    z = 1. - (2. * a + 1.) * ni;\n    vf = vec3 (sin (2. * pi * fract (phi * a) + vec2 (0.5 * pi, 0.)) * sqrt (1. - z * z), z);\n    dd = dot (vf - v, vf - v);\n    if (dd < ddMin) {\n      ddMin = dd;\n      vfMin = vf;\n    }\n  }\n  return vfMin;\n}\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, r, hWid, shUp;\n  dMin = dstFar;\n  hWid = 0.3;\n  q = p;\n  q.z += rShell.x + 0.9 * hWid;\n  d = PrCapsDf (q.yzx, 0.25, 0.95);\n  DMINQ (idHing);\n  q.yz = Rot2Cs (q.yz, opCs);\n  q.y = abs (q.y);\n  q.yz = Rot2Cs (q.yz, opCs);\n  q.z -= hWid;\n  d = max (PrBoxDf (q, vec3 (0.95, 0.25, hWid)), - q.y);\n  DMINQ (idArm);\n  q.z -= rShell.x + 0.9 * hWid;\n  r = rShell.x + 0.1 * (1. - q.y / length (q)) * cos (32. * atan (q.x, q.z));\n  d = max (max (PrEllips2Df (q.xzy, vec2 (r, rShell.y) + 0.1),\n     - PrEllips2Df (q.xzy, vec2 (r, rShell.y) - 0.1)), - q.y);\n  DMINQ (idShell);\n  shUp = 1.2 + 1.6 * opPhs;\n  q = p;\n  q.y -= - rShell.y + shUp;\n  d = PrCylDf (q.xzy, 0.1, shUp);\n  q = p;\n  q.y -= - rShell.y + 0.1;\n  d = min (d, PrCylDf (q.xzy, 0.5, 0.05));\n  DMINQ (idArm);\n  q = p;\n  q.y -= - rShell.y + 2. * shUp;\n  q.xz = Rot2Cs (q.xz, rotCs);\n  vdFib = SphFib (normalize (q), nFace);\n  d = RotToDir (vdFib, vec3 (0., 0., 1.), q - vdFib).z - 1.2;\n  DMINQ (idPolyh);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 160; j ++) {\n    d = ObjDf (ro + rd * dHit);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0002, -0.0002);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstObj, s;\n  bool isRefl;\n  rShell = vec2 (4., 3.5);\n  isRefl = false;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar && idObj == idPolyh) {\n    ro += dstObj * rd;\n    vdFib.xz = Rot2Cs (vdFib.xz, rotCs * vec2 (1., -1.));\n    rd = reflect (rd, vdFib);\n    ro += 0.01 * rd;\n    dstObj = ObjRay (ro, rd);\n    isRefl = true;\n  }\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col4 = vec4 (0.8, 0.85, 0.8, 0.2);\n    if (idObj == idShell) {\n      s = length (qHit / rShell.xyx);\n      col4 = (s > 1. || qHit.y < 0.05) ? col4 : mix (vec4 (0.4, 0.9, 0.4, 0.1),\n         vec4 (0.9, 0.7, 0.7, 0.1), smoothstep (0.3, 0.5, rShell.y - qHit.y) *\n         smoothstep (0.97, 0.98, s));\n      if (s > 1.) vn = VaryNf (64. * qHit, vn, 0.5);\n    } else if (idObj == idHing) col4 *= 1. - 0.5 * SmoothBump (0.05, 0.1, 0.02,\n       mod (4. * qHit.x, 1.));\n    col = col4.rgb * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +\n       col4.a * pow (max (dot (normalize (ltDir - rd), vn), 0.), 128.);\n    if (! isRefl || idObj == idShell && s > 1.)\n       col += 256. * pow (clamp (0.5 + 0.5 * dot (ltDir, reflect (rd, vn)), 0., 1.), 16.) *\n       pow (1. - 0.6 * abs (dot (normalize (ltDir - rd), VaryNf (1024. * qHit, vn, 2.))), 8.);\n    if (idObj == idShell && s < 1.) col *= 0.4 + 0.6 * smoothstep (0.1, 0.2, opPhs);\n    if (isRefl) col *= 0.9;\n  } else {\n    col = (mix (vec3 (1., 0.9, 0.8) * (0.4 + 0.2 * rd.y), vec3 (0.1, 0.1, 0.5),\n       max (SmoothBump (0.45, 0.55, 0.05, mod (64. * atan (rd.z, - rd.x) / pi, 1.)),\n       SmoothBump (0.45, 0.55, 0.05, mod (64. * asin (rd.y) / pi, 1.)))) +\n       vec3 (0.5, 0.5, 1.) * (((rd.y > max (abs (rd.x), abs (rd.z * 0.25))) ?\n       min (2. * rd.y, 1.) : 0.05 * (1. + dot (rd, ltDir))) + 0.5 * step (0., rd.y) *\n       pow (clamp (1.05 - 0.5 * length (max (abs (rd.xz / rd.y) - vec2 (1., 4.), 0.)), 0., 1.),\n       8.))) * (isRefl ? 0.5 : 0.4);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  opPhs = SmoothBump (0.25, 0.85, 0.15, mod (0.1 * tCur, 1.));\n  nFace = 32. * pow (2., mod (floor (0.1 * tCur), 6.));\n  opCs = sin (0.2 * pi * opPhs + vec2 (0.5 * pi, 0.));\n  rotCs = sin (0.01 * pi * tCur + vec2 (0.5 * pi, 0.));\n  az = pi;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 3. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az += 0.5 * pi * (2. * mod (floor (0.04 * tCur), 2.) - 1.) *\n       SmoothBump (0.25, 0.65, 0.1, mod (0.04 * tCur, 1.));\n    el -= 0.05 * pi * sin (0.05 * pi * tCur);\n  }\n  el = clamp (el, -0.45 * pi, 0.45 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 2.7, -30.);\n  zmFac = 4.2 + 2. * opPhs;\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  dstFar = 60.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nfloat PrEllips2Df (vec3 p, vec2 r)\n{\n  return (length (p / r.xxy) - 1.) * min (r.x, r.y);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 RotToDir (vec3 v1, vec3 v2, vec3 p)\n{\n  vec3 n;\n  float c;\n  n = normalize (cross (v1, v2));\n  c = dot (v1, v2);\n  return c * p + sqrt (1. - c * c) * cross (n, p) + (1. - c) * dot (n, p) * n;\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec3 e = vec3 (0.1, 0., 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llyfRh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llyfzD", "name": "Poison bubbles", "author": "kernalphage", "description": "cellular  noise!  it started as trying to imitate waves but uhh... here we are. the normals look pointy, and im not quite sure how to fix it. ", "tags": ["codevember", "poison"], "likes": 7, "viewed": 127, "date": "1541988640", "time_retrieved": "2024-06-20T19:24:20.987169", "image_code": "\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\nfloat cellular(vec2 pos, int i, int j){\n    pos = pos-.5;\n    float pp =  3. * sin(4.*atan(pos.y, pos.x)*iTime);\n    return length(pos * pp);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat bubble( vec2 uv) {\n   // return length(.5 - uv);\n    // Scale\n    vec2 st = 5.4 * uv;\n\n    // Tile the space\n    vec2 i_st = floor(st);\n    vec2 f_st = fract(st);\n\n    float m_dist = 1.;  // minimun distance\n\t\n    for (int y= -1; y <= 1; y++) {\n        for (int x= -1; x <= 1; x++) {\n            // Neighbor place in the grid\n            vec2 neighbor = vec2(float(x),float(y));\n\n            // Random position from current + neighbor place in the grid\n            vec2 point = random2(i_st + neighbor);\n\n\t\t\t// Animate the point\n            point = 0.5 + 0.5*sin(iTime + 6.2831*point) * vec2(.5, 1);\n\n\t\t\t// Vector between the pixel and the point\n            vec2 diff = neighbor + point - f_st;\n            // Distance to the point\n            float dist = length(diff);\n\t\t\t//dist = pow(dist, .7 + .5 * random2(i_st + neighbor + 114.215).x);\n            // Keep the closer distance\n            m_dist = opSmoothUnion(m_dist, dist, 0.5);\n        }\n    }  \n    //return 1./(1.13+m_dist);\n    return m_dist;\n}\n\nfloat lighting(vec3 light, vec3 normal){\n \n    return .5 * max(dot( normal, light), .24);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv.x *= 1.64;\n    \n    //calculate normal\n    float m_dist = bubble(uv);\n    vec3 pos = vec3(uv, m_dist); \n    \n    vec3 dx = vec3(.05,0.,0.);\n    dx = pos - vec3(uv+ dx.xy, bubble(uv + dx.xy));\n    \n    vec3 dy = vec3(0.,.05,0.);\n    dy = pos - vec3(uv+ dy.xy, bubble(uv + dy.xy));    \n\t\n    vec3 normal =  normalize(cross(1./dx, 1./dy));\n\n    // calculate color \n    float col = smoothstep(1.-uv.y*2.,1.-uv.y*1., m_dist * sin(iTime * .2));\n    vec3 background = vec3(.60 , .14, .20)*uv.y;\n    vec3 foreground = vec3(.0, .82306, .320);\n    \n    // lighting\n    float light = lighting(normalize(vec3(1.2,sin(iTime)*-.72,3.14)), normal);\n    light += lighting(normalize(vec3(4.2,-3.35,6.7)), normal);\n  \tlight = max(light, col);\n    vec3 color = light *  mix(foreground,background, col);\n    \n    // Output to screen\n    fragColor =  vec4(.5 + .5 * normal, 1.0);\n    //fragColor = vec4(m_dist);\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llyfzD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lt2BD3", "name": "Eleven point conic", "author": "mla", "description": "Another nice construction from plane projective geometry: the eleven point conic.", "tags": ["conic", "projective", "elevenpoint"], "likes": 4, "viewed": 419, "date": "1543070008", "time_retrieved": "2024-06-20T19:24:22.881748", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Projective geometry: the eleven point conic.\n//\n// Take 4 points (red) and the 6 lines (yellow) through pairs of points,\n// forming a complete quadrangle.\n//\n// There are 3 diagonal points where the line through two points meets\n// the line through the other two points (cyan).\n//\n// Given a line l (red), the 6 quadrangle lines meet l in 6 points and each\n// point has a harmonic conjugate with the two points of the quadrangle\n// on the same line (green).\n//\n// Additionally, the 4 points of the quadrangle and the line l\n// define a pair of conics (blue and grey), passing through the 4 points\n// and tangent to the line (these conics may be imaginary though).\n//\n// The three diagonal points, the six harmonic points and the two points\n// of tangency of the pair of conics all lie on a third conic, the\n// eleven point conic (white).\n//\n// Copyright (c) Matthew Arcus, 2018\n// MIT License: https://opensource.org/licenses/MIT\n//\n// Controls:\n// Drag mouse to change line\n// '1' and '2': change initial configuration\n// 'f': change line & point drawing style\n// 'z': zoom in\n//\n////////////////////////////////////////////////////////////////////////////////\n\nint configuration = 2;\n\nconst float lwidth = 0.015;\nconst float pwidth = 0.045;\nfloat ledge0 = 0.0, ledge1 = lwidth;\nfloat pedge0 = lwidth, pedge1 = pwidth;\nconst float scale = 1.5;\nfloat zoom = 1.0;\n\nconst float PI =  3.141592654;\n\nconst vec3 pcolor0 = vec3(1,0,0);\nconst vec3 pcolor1 = vec3(0,1,0);\nconst vec3 pcolor2 = vec3(1,1,0);\nconst vec3 pcolor3 = vec3(0,1,1);\nconst vec3 pcolor4 = pcolor1;\nconst vec3 lcolor0 = pcolor0;\nconst vec3 lcolor1 = pcolor1;\nconst vec3 lcolor2 = vec3(1,1,0.2);\nconst vec3 ccolor0 = vec3(1,1,1);\nconst vec3 ccolor1 = vec3(0,0,1);\nconst vec3 ccolor2 = vec3(0.5,0.5,1);\n\n// Solve Ax^2 + 2Bx + C = 0\nbool quadratic(float A, float B, float C,\n               out float x1, out float x2) {\n   float D = B*B - A*C;\n   if (D < 0.0) return false;\n   D = sqrt(D);\n   if (B < 0.0) D = -D;\n   x1 = (-B-D)/A;\n   x2 = C/(A*x1);\n   return true;\n}\n\n// Return either intersection of lines p and q\n// or line through points p and q, r = kp + jq\nvec3 join(vec3 p, vec3 q) {\n  return cross(p,q);\n}\n\n// Find a projective mapping taking p0,p1,p2,p4 to\n// triangle of reference and unit point, ie:\n// p0 -> (1,0,0), p1 -> (0,1,0), p2 -> (0,0,1), p3 -> (1,1,1)\n// No three points collinear.\nmat3 rproject(vec3 p0, vec3 p1, vec3 p2, vec3 p3) {\n  // Just an inverse for the first three points\n  // (the triangle of reference). No inverse if collinear.\n  mat3 m = inverse(mat3(p0,p1,p2)); // column major!\n  p3 = m*p3; \n  // Then scale each row so the unit point (1,1,1) is correct\n  m = transpose(m);\n  // zero components here only if not collinear\n  m[0] /= p3[0];\n  m[1] /= p3[1];\n  m[2] /= p3[2];\n  return transpose(m);\n}\n\n// Represent a projective conic as a 3x3 matrix:\n//\n// M = (a,d,e,\n//      d,b,f,\n//      e,f,c)\n//\n// is: axx + byy + czz + 2(dxy + exz + fyz) = 0\n// calculated as pMp for p = (x,y,z).\n//\n// We can treat this as a distance field, scaled by the\n// (x,y) derivative in order to get correct line widths.\n\n// With this representation, the dual conic is just the inverse;\n// if the determinant is zero then there is no dual and the\n// conic is degenerate.\n\n// Conic through 4 points and a line - there are 2 solutions, so\n// need to solve quadratic. I'm sure I didn't invent this but\n// can't remember the source.\n// l.p = l'p == l'(MinvM)p = (Minv'l)'Mp\nbool conic4points(vec3 p0, vec3 p1, vec3 p2, vec3 p3, vec3 l4, out mat3 M0, out mat3 M1) {\n  // p takes p0,p1,p2,p3 to triangle of reference and unit point\n  mat3 p = rproject(p0,p1,p2,p3);\n  // and then to the square (1,1),(1,-1),(-1,1),(-1,-1)\n  mat3 q = rproject(vec3(1,-1,1), vec3(-1,1,1),vec3(-1,-1,1),vec3(1,1,1));\n  p = inverse(q)*p; // q is constant\n  // Now construct a conic through the images of p0-p3 and l4\n  l4 = transpose(inverse(p))*l4;\n  float i = l4.x, j = l4.y, k = l4.z;\n  float A = -j*j, B = 0.5*(i*i+j*j-k*k), C = -i*i;\n  float t0,t1;\n  if (!quadratic(A,B,C,t0,t1)) return false;\n  M0 = mat3(t0, 0, 0,\n            0, -1, 0,\n            0,  0, 1.0-t0);\n  M0 = transpose(p)*M0*p;\n  if (isnan(determinant(M0))) return false;\n  M1 = mat3(t1, 0, 0,\n            0, -1, 0,\n            0,  0, 1.0-t1);\n  M1 = transpose(p)*M1*p;\n  if (isnan(determinant(M1))) return false;\n  return true;\n}\n\n// Find the two points of intersection of a line through p0 and\n// p1 with the conic defined by M.\nbool lineconic(vec3 p0, vec3 p1, mat3 M, out vec3 q0, out vec3 q1) {\n  // (tp0 + p1)M(tp0 + p1) == 0\n  float A = dot(p0,M*p0);\n  float B = dot(p0,M*p1);\n  float C = dot(p1,M*p1);\n  float t0,t1;\n  if (!quadratic(A,B,C,t0,t1)) return false;\n  q0 = t0*p0+p1;\n  q1 = t1*p0+p1;\n  return true;\n}\n\n// Find the two points of intersection of the line l\n// with the conic defined by c.\nbool lineconic(vec3 l, mat3 M, out vec3 i0, out vec3 i1) {\n  // Intersect l with two of the axes. This might of course\n  // be the same point (1,0,0) here, so should use the third\n  // axis.\n  vec3 p0 = join(l,vec3(0,0,1));\n  vec3 p1 = join(l,vec3(0,1,0));\n  return lineconic(p0,p1,M,i0,i1);\n}\n\n// Construct the conic defined by 5 points.\n// Method taken from \"Geometry\", Brannan, Esplan & Gray, CUP, 2012\nmat3 conic5points(vec3 p0, vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n  // p takes p0,p1,p2,p3 to triangle of reference and unit point\n  mat3 p = rproject(p0,p1,p2,p3);\n  // Now construct a conic through the images of p0-p4,\n  p4 = p*p4;\n  float a = p4.x, b = p4.y, c = p4.z;\n  float d = c*(a-b);\n  float e = b*(c-a);\n  float f = a*(b-c);\n  mat3 m = mat3(0,d,e,\n                d,0,f,\n                e,f,0);\n  // And combine the two.\n  return transpose(p)*m*p;\n}\n\n// Harmonic conjugate of p,q and intersection of p,q with l.\nvec3 harmonic(vec3 p, vec3 q, vec3 l) {\n  // kp + jq is conjugate of kp - lq:\n  // l.(kp - jq) = 0\n  // k(l.p) = j(l.q)\n  float k = dot(l,q);\n  float j = dot(l,p);\n  return k*p+j*q;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Drawing functions\n////////////////////////////////////////////////////////////////////////////////\n\nfloat point(vec3 pos, vec3 p) {\n  if (p.z == 0.0) return 0.0;\n  pos /= pos.z; p /= p.z; // Normalize\n  float dist = distance(pos,p);\n  if (isnan(dist)) return 0.0;\n  return 1.0-smoothstep(pedge0,pedge1,dist);\n}\n\nfloat line(vec3 pos, vec3 l) {\n  float dist = dot(pos,l)/(pos.z*length(l.xy));\n  if (isnan(dist)) return 0.0;\n  return 1.0-smoothstep(ledge0,ledge1,abs(dist));\n}\n\nfloat conic(vec3 pos, mat3 m) {\n  float dist = dot(pos,m*pos);   // Distance from the conic\n  vec3 grad = m*pos*2.0;         // The gradient uses the same matrix.\n  dist /= pos.z*length(grad.xy); // Normalize for Euclidean distance\n  if (isnan(dist)) return 0.0;\n  return 1.0-smoothstep(ledge0,ledge1,abs(dist));\n}\n\n// Screen coords to P2 coords\nvec3 map(vec2 p) {\n  return vec3(scale*zoom*(2.0*p - iResolution.xy) / iResolution.y, 1);\n}\n\n//-------------------------------------------------\n//From https://www.shadertoy.com/view/XtXGRS#\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec3 transform(vec3 p) {\n  float t = 0.5*iTime;\n  p.x *= 1.0+0.5*sin(t);\n  p.y *= 1.0+0.3*sin(0.618*t);\n  p.xy = rotate(p.xy,0.2*t);\n  //p.yz = rotate(p.yz,0.1*t);\n  return p;\n}\n\nvec3 cmix(vec3 color0, vec3 color1, float level) {\n  return mix(color0,color1,level);\n}\n\nconst int CHAR_0 = 48;\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_F = 70;\nconst int CHAR_I = 73;\nconst int CHAR_Z = 90;\nbool keypress(int code) {\n#if defined LOCAL || __VERSION__ < 300\n  return false;\n#else\n  return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  if (keypress(CHAR_Z)) zoom = 0.25;\n  if (!keypress(CHAR_F)) {\n      float pixelwidth = 2.0*scale/iResolution.y;\n      pedge0 = pwidth-pixelwidth;\n      pedge1 = pwidth+pixelwidth;\n      ledge0 = lwidth-pixelwidth;\n      ledge1 = lwidth+pixelwidth;\n  }    \n  configuration = int(keypress(CHAR_0+1)) + 2*int(!keypress(CHAR_0+2));\n  vec3 pos = map(fragCoord.xy);\n  vec3 p0,p1,p2,p3,l4; // p4 is the movable line\n  if (configuration == 0) {\n    p0 = vec3(1,0,0); p1 = vec3(0,1,0);\n    p2 = vec3(0,0,1); p3 = vec3(1,1,1);\n    l4 = vec3(0.5,-1,1);\n  } else if (configuration == 1) {\n    p0 = vec3(0,0,1); p1 = vec3(1,0,1);\n    p2 = vec3(0,1,1); p3 = vec3(1,1,1);\n    l4 = vec3(0.5,-1,1);\n  } else if (configuration == 2) {\n    p0 = vec3(0,0,1); p1 = vec3(0,1,1);\n    p2 = vec3(0.866,-0.5,1); p3 = vec3(-0.866,-0.5,1);\n    l4 = vec3(-1,0.5,1);\n  } else {\n    p0 = vec3(1,0,1);  p1 = vec3(0,1,1);\n    p2 = vec3(-1,0,1); p3 = vec3(0,-1,1);\n    l4 = vec3(0.5,-1,1);\n  }\n  p0 = transform(p0); p1 = transform(p1);\n  p2 = transform(p2); p3 = transform(p3);\n  if (iMouse.x != 0.0) {\n    l4 = map(iMouse.xy);\n  }\n  vec3 l01 = join(p0,p1);\n  vec3 l02 = join(p0,p2);\n  vec3 l03 = join(p0,p3);\n  vec3 l12 = join(p1,p2);\n  vec3 l13 = join(p1,p3);\n  vec3 l23 = join(p2,p3);\n\n  // diagonal points\n  vec3 d0 = join(l01,l23);\n  vec3 d1 = join(l02,l13);\n  vec3 d2 = join(l03,l12);\n\n  // harmonic points\n  vec3 h01 = harmonic(p0,p1,l4);\n  vec3 h02 = harmonic(p0,p2,l4);\n  vec3 h03 = harmonic(p0,p3,l4);\n  vec3 h12 = harmonic(p1,p2,l4);\n  vec3 h13 = harmonic(p1,p3,l4);\n  vec3 h23 = harmonic(p2,p3,l4);\n\n  // conics\n  mat3 elevenpoint = conic5points(d0,d1,d2,h01,h23);\n  mat3 M1,M2;\n  bool doM1M2 = conic4points(p0,p1,p2,p3,l4,M1,M2);\n  vec3 i0,i1;\n  bool doN = lineconic(l4,elevenpoint,i0,i1);\n\n  vec3 color = vec3(0);\n\n  // The diagonal lines of the quadrangle\n  color = cmix(color,lcolor2,line(pos,l01));\n  color = cmix(color,lcolor2,line(pos,l02));\n  color = cmix(color,lcolor2,line(pos,l03));\n  color = cmix(color,lcolor2,line(pos,l12));\n  color = cmix(color,lcolor2,line(pos,l13));\n  color = cmix(color,lcolor2,line(pos,l23));\n\n  // The moving line\n  color = cmix(color,lcolor0,line(pos,l4));\n  \n  // The conics\n  color = cmix(color,ccolor0,conic(pos,elevenpoint));\n  if (doM1M2) {\n    color = cmix(color,ccolor1,conic(pos,M1));\n    color = cmix(color,ccolor2,conic(pos,M2));\n  }\n\n  // The points of the quadrangle\n  color = cmix(color,pcolor0,point(pos,p0));\n  color = cmix(color,pcolor0,point(pos,p1));\n  color = cmix(color,pcolor0,point(pos,p2));\n  color = cmix(color,pcolor0,point(pos,p3));\n\n  // The midpoints of the sides of the quadrangle\n  color = cmix(color,pcolor1,point(pos,h01));\n  color = cmix(color,pcolor1,point(pos,h02));\n  color = cmix(color,pcolor1,point(pos,h03));\n  color = cmix(color,pcolor1,point(pos,h12));\n  color = cmix(color,pcolor1,point(pos,h13));\n  color = cmix(color,pcolor1,point(pos,h23));\n\n  // The magic triangle\n  color = cmix(color,pcolor3,point(pos,d0));\n  color = cmix(color,pcolor3,point(pos,d1));\n  color = cmix(color,pcolor3,point(pos,d2));\n\n  color = cmix(color,pcolor4,point(pos,join(l01,l4)));\n  color = cmix(color,pcolor4,point(pos,join(l02,l4)));\n  color = cmix(color,pcolor4,point(pos,join(l03,l4)));\n  color = cmix(color,pcolor4,point(pos,join(l12,l4)));\n  color = cmix(color,pcolor4,point(pos,join(l13,l4)));\n  color = cmix(color,pcolor4,point(pos,join(l23,l4)));\n  \n  if (doN) {\n    color = cmix(color, pcolor2, point(pos,i0));\n    color = cmix(color, pcolor2, point(pos,i1));\n  }\n  fragColor = vec4(pow(1.0*color,vec3(0.4545)),1);\n}\n", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lt2BD3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lt3BW2", "name": "Combination SDF", "author": "iq", "description": "The three basic boolean operations that help combine shape, in discrete and smooth form. BEWARE these operators produce a bound to the real SDF of the final shape, so they will slow down your raymarcher.", "tags": ["3d", "raymarching", "distancefield", "sdf"], "likes": 55, "viewed": 7456, "date": "1541047763", "time_retrieved": "2024-06-20T19:24:24.036050", "image_code": "// The MIT License\n// Copyright ¬© 2018 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Smooth vs sharp boolean operations for combining shapes\n\n// Related techniques:\n//\n// Elongation  : https://www.shadertoy.com/view/Ml3fWj\n// Rounding    : https://www.shadertoy.com/view/Mt3BDj\n// Onion       : https://www.shadertoy.com/view/MlcBDj\n// Metric      : https://www.shadertoy.com/view/ltcfDj\n// Combination : https://www.shadertoy.com/view/lt3BW2\n// Repetition  : https://www.shadertoy.com/view/3syGzz\n// Extrusion2D : https://www.shadertoy.com/view/4lyfzw\n// Revolution2D: https://www.shadertoy.com/view/4lyfzw\n//\n// More information here: http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n\nfloat opUnion( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opSubtraction( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opIntersection( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n\t//float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n\t//return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    float h = max(k-abs(-d1-d2),0.0);\n    return max(-d1, d2) + h*h*0.25/k;\n\t//float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n\t//return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat opSmoothIntersection( float d1, float d2, float k )\n{\n    float h = max(k-abs(d1-d2),0.0);\n    return max(d1, d2) + h*h*0.25/k;\n\t//float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n\t//return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\n//-------------------------------------------------\n\nfloat sdSphere( in vec3 p, in float r )\n{\n    return length(p)-r;\n}\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)) - r;\n}\n\n//---------------------------------\n\nfloat map(in vec3 pos)\n{\n    float d = 1e10;\n    \n    \n    float an = sin(iTime);\n\n    // opUnion\n    {\n    vec3 q = pos - vec3(-2.0,0.0,-1.3);\n    float d1 = sdSphere( q-vec3(0.0,0.5+0.3*an,0.0), 0.55 );\n    float d2 = sdRoundBox(q, vec3(0.6,0.2,0.7), 0.1 ); \n    float dt = opUnion(d1,d2);\n    d = min( d, dt );\n  \t}\n    \n    // opSmoothUnion\n    {\n    vec3 q = pos - vec3(-2.0,0.0,1.0);\n    float d1 = sdSphere( q-vec3(0.0,0.5+0.3*an,0.0), 0.55 );\n    float d2 = sdRoundBox(q, vec3(0.6,0.2,0.7), 0.1 ); \n    float dt = opSmoothUnion(d1,d2, 0.25);\n    d = min( d, dt );\n    }\n\n\n    // opSubtraction\n    {\n    vec3 q = pos - vec3(0.0,0.0,-1.3);\n    float d1 = sdSphere( q-vec3(0.0,0.5+0.3*an,0.0), 0.55 );\n    float d2 = sdRoundBox(q, vec3(0.6,0.2,0.7), 0.1 ); \n    float dt = opSubtraction(d1,d2);\n    d = min( d, dt );\n    }\n\n    // opSmoothSubtraction\n    {\n    vec3 q = pos - vec3(0.0,0.0,1.0);\n    float d1 = sdSphere( q-vec3(0.0,0.5+0.3*an,0.0), 0.55 );\n    float d2 = sdRoundBox(q, vec3(0.6,0.2,0.7), 0.1 ); \n    float dt = opSmoothSubtraction(d1,d2, 0.25);\n    d = min( d, dt );\n    }\n\n    // opIntersection\n    {\n    vec3 q = pos - vec3(2.0,0.0,-1.3);\n    float d1 = sdSphere( q-vec3(0.0,0.5+0.3*an,0.0), 0.55 );\n    float d2 = sdRoundBox(q, vec3(0.6,0.2,0.7), 0.1 ); \n    float dt = opIntersection(d1,d2);\n    d = min( d, dt );\n    }\n    \n    // opSmoothIntersection\n    {\n    vec3 q = pos - vec3(2.0,0.0,1.0);\n    float d1 = sdSphere( q-vec3(0.0,0.5+0.3*an,0.0), 0.55 );\n    float d2 = sdRoundBox(q-vec3(0.0,0.5,0.0), vec3(0.6,0.2,0.7), 0.1 ); \n    float dt = opSmoothIntersection(d1,d2, 0.25);\n    d = min( d, dt );\n    }\n\n    return d;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n    const float ep = 0.0001;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*ep ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep ) );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )\n{\n\tfloat res = 1.0;\n    float t = tmin;\n    for( int i=0; i<50; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.20 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n \n        vec3 ro = vec3(0.0,4.0,8.0);\n        vec3 rd = normalize(vec3(p-vec2(0.0,1.8),-3.5));\n\n        float t = 7.0;\n        for( int i=0; i<64; i++ )\n        {\n            vec3 p = ro + t*rd;\n            float h = map(p);\n            if( abs(h)<0.001 || t>11.0 ) break;\n            t += h;\n        }\n\n        vec3 col = vec3(0.0);\n\n        if( t<11.0 )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            vec3  lig = normalize(vec3(1.0,0.8,-0.2));\n            float dif = clamp(dot(nor,lig),0.0,1.0);\n            float sha = calcSoftshadow( pos, lig, 0.001, 1.0, 16.0 );\n            float amb = 0.5 + 0.5*nor.y;\n            col = vec3(0.05,0.1,0.15)*amb + \n                  vec3(1.00,0.9,0.80)*dif*sha;\n        }\n\n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/lt3BW2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lt3fWf", "name": "vertg", "author": "dariopasotti21", "description": "g", "tags": ["tt"], "likes": 1, "viewed": 61, "date": "1541286526", "time_retrieved": "2024-06-20T19:24:24.150843", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lt3fWf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lt3fWj", "name": "[twitch] Pumpkin", "author": "yx", "description": "Coded live on twitch stream in Bonzomatic, and tidied/ported to shadertoy.\nUnedited Bonzomatic shader here: [url]https://gist.github.com/willkirkby/7afe42a8c8efb74ac33bb449e6941069[/url]", "tags": ["halloween", "pumpkin", "twitch"], "likes": 5, "viewed": 868, "date": "1541028532", "time_retrieved": "2024-06-20T19:24:25.102647", "image_code": "#define PI (acos(-1.))\n\nvec2 rotate(vec2 a, float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x * c - a.y * s,\n        a.x * s + a.y * c\n    );\n}\n\n// http://mercury.sexy/hg_sdf/\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n    float angle = 2.*PI/repetitions;\n    float a = atan(p.y, p.x) + angle/2.;\n    float r = length(p);\n    float c = floor(a/angle);\n    a = mod(a,angle) - angle/2.;\n    p = vec2(cos(a), sin(a))*r;\n    // For an odd number of repetitions, fix cell index of the cell in -x direction\n    // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n    if (abs(c) >= (repetitions/2.)) c = abs(c);\n    return c;\n}\n\nfloat sdSphere(vec3 p, vec3 c, float r)\n{\n    return length(p-c)-r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nvec2 scene(vec3 p)\n{\n    float floorPlane = p.y + 1.;\n\n    vec3 rp = p;\n    pModPolar(rp.xz, 12.);\n    float sphere = length(rp*vec3(.9,1,1)-vec3(.3,0,0))-1.;\n\n    sphere = abs(sphere+.05)-.05;\n\n    vec3 mirrorP = p;\n    mirrorP.z = -abs(mirrorP.z);\n\n    // round eyes\n    vec3 mp = p;\n    mp.x = abs(mp.x);\n    float eye = sdSphere(mp, vec3(.3,.4,-1.2), .17);\n    sphere = max(sphere, -eye);\n\n    // curved mouth\n    float mouth1 = sdSphere(p, vec3(0,.6,-1), 1.);\n    float mouth2 = sdSphere(p, vec3(0,1.3,-1), 1.35);\n    sphere = max(sphere, -max(mouth1, -mouth2));\n\n    // angular eyes\n    sphere = max(sphere, -sdTriPrism(mp*vec3(1,-1,1)+vec3(-.25,.35,-1.), vec2(.2,1.1)));\n\n    // both noses\n    sphere = max(sphere, -sdTriPrism(mirrorP-vec3(0,.22,-1.), vec2(.1,1.1)));\n\n    // angular mouth\n    sphere = max(sphere, -sdTriPrism(mp*vec3(1,-1,1)+vec3(-.37,-.03,-1.), vec2(.16,1.1)));\n    sphere = max(sphere, -sdTriPrism(mp*vec3(1,-1,1)+vec3(-.2,-.04,-1.), vec2(.18,1.1)));\n    sphere = max(sphere, -sdTriPrism(mp*vec3(1,-1,1)+vec3(0,-.05,-1.), vec2(.2,1.1)));\n\n\n    floorPlane = -sdBox(p-vec3(0,1,0), vec3(6,2.5,6));\n\n    float stem = dot(vec4(rp,1),vec4(1,.1,0,-.2));\n    stem = max(stem, p.y-1.3);\n    stem = max(stem, -p.y+.95);\n\n    return vec2(\n        min(floorPlane,min(sphere,stem)),\n        floorPlane < sphere \n        ? 0\n        : sphere < stem\n        ? 1\n        : 2\n    );\n}\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 cam = vec3(0,0,-5);\n    vec3 dir = normalize(vec3(uv,1));\n\n    cam.yz = rotate(cam.yz, .3+sin(iTime*.1)*.1);\n    dir.yz = rotate(dir.yz, .3+sin(iTime*.1)*.1);\n\n    cam.xz = rotate(cam.xz, iTime*.4);\n    dir.xz = rotate(dir.xz, iTime*.4);\n\n    float t = 0.;\n    for(int i=0;i<100;++i)\n    {\n        float k = scene(cam+dir*t).x;\n        t += k;\n        if (k<.001) break;\n    }\n    vec3 h = cam+dir*t;\n    vec2 o = vec2(0.001,0);\n    vec3 n = normalize(vec3(\n        scene(h+o.xyy).x-scene(h-o.xyy).x,\n        scene(h+o.yxy).x-scene(h-o.yxy).x,\n        scene(h+o.yyx).x-scene(h-o.yyx).x\n    ));\n    vec2 mat = scene(h);\n\n    vec3 candlePos = sin(iTime*vec3(\n        18.1,\n        15.6,\n        14.7\n    ))*.01;\n\n    if (mat.x > 1.)\n    {\n        // sky\n        out_color = vec4(0,0,0,1);\n    }\n    else if (mat.y == 0.)\n    {\n        // floor\n        float fakeLight = clamp(1.-length(h)*.12,0.,1.);\n        vec4 color = vec4(.2,0,.3,0);\n        vec3 fh = fract(h*.5+.501)-.5;\n        float checker = fh.x*fh.y*fh.z;\n        out_color = color*float(checker>0.) * fakeLight;\n    }\n    else if (mat.y == 1. || mat.y == 2.)\n    {\n        vec3 fakeN = n;\n        fakeN.xz = rotate(fakeN.xz, -iTime*.4);\n        // pumpkin\n        vec4 albedo = mat.y == 1. ? vec4(1,.5,0,0) : vec4(.1,.3,.1,1);\n        out_color = albedo * (fakeN.x*.5+.5);\n        out_color += pow(dot(fakeN,normalize(vec3(1,1,-1)))*.5+.5,20.)*.2;\n    }\n\n    out_color = clamp(out_color, 0.,1.);\n\n    bool occluded = false;\n    vec3 lightCheckDir = normalize(candlePos-h);\n    t=0.;\n    h += n *.01;\n    h *= .995;\n    float lowestK = 1e9;\n    for(int i=0;i<32&&!occluded;++i)\n    {\n        float k = scene(h+lightCheckDir*t).x;\n        t += k;\n        lowestK = min(k,lowestK);\n        if (k<0.001)\n            occluded=true;\n        else if (t > distance(candlePos, h))\n            break;\n            }\n\n    if(!occluded)\n        out_color += vec4(1,.9,.1,1) * .3 * smoothstep(0.,.02,lowestK);\n\n    //out_color = vec4(n*.5+.5,0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lt3fWj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lt3Szn", "name": "Now Loading", "author": "Sobaya", "description": "po", "tags": ["po"], "likes": 12, "viewed": 216, "date": "1542859837", "time_retrieved": "2024-06-20T19:24:25.102647", "image_code": "float sq(float t) {\n    return t * t;\n}\n\nfloat seg(vec2 s, vec2 e, vec2 p) {\n    float len = length(e - s);\n    vec2 v = (e - s) / len;\n    float t = dot(v, p - s) / len;\n    if (t > 1.) return length(p - e);\n    else if (t < 0.) return length(p - s);\n    else return sqrt(sq(length(p-s)) - sq(dot(p-s, v)));\n}\n\nvec2 rot(vec2 p, float a) {\n    float rad = a * 3.141592 / 180.;\n    float c = cos(rad);\n    float s = sin(rad);\n    return vec2(p.x * c - p.y * s,\n                p.x * s + p.y * c);\n}\n\n#define ADD(x) dist = min(dist, x)\n#define TIME iTime\n\nvec2 trans(vec2 p) {\n    return p * 0.2;\n}\n\nstruct Po {\n    float d;\n    int idx;\n};\n    \nconst int N = 55;\n\nPo dist(vec2 p) {\n    \n\tvec2 starts[N];\n\tvec2 ends[N];\n\tstarts[0] = vec2(-3.1097560975609757, -0.7073170731707317);\n\tends[0] = vec2(-3.1097560975609757, -0.0);\n\tstarts[1] = vec2(-3.1097560975609757, -0.0);\n\tends[1] = vec2(-2.6341463414634148, -0.7317073170731707);\n\tstarts[2] = vec2(-2.6341463414634148, -0.7317073170731707);\n\tends[2] = vec2(-2.6219512195121952, -0.0);\n\tstarts[3] = vec2(-2.1463414634146343, -0.24390243902439024);\n\tends[3] = vec2(-2.2804878048780486, -0.2804878048780488);\n\tstarts[4] = vec2(-2.2804878048780486, -0.2804878048780488);\n\tends[4] = vec2(-2.3536585365853657, -0.4024390243902439);\n\tstarts[5] = vec2(-2.3536585365853657, -0.4024390243902439);\n\tends[5] = vec2(-2.3536585365853657, -0.5487804878048781);\n\tstarts[6] = vec2(-2.3536585365853657, -0.5487804878048781);\n\tends[6] = vec2(-2.2804878048780486, -0.6829268292682926);\n\tstarts[7] = vec2(-2.2804878048780486, -0.6829268292682926);\n\tends[7] = vec2(-2.1707317073170733, -0.7439024390243902);\n\tstarts[8] = vec2(-2.1707317073170733, -0.7439024390243902);\n\tends[8] = vec2(-2.0121951219512195, -0.7073170731707317);\n\tstarts[9] = vec2(-2.0121951219512195, -0.7073170731707317);\n\tends[9] = vec2(-1.9024390243902438, -0.5487804878048781);\n\tstarts[10] = vec2(-1.9024390243902438, -0.5365853658536586);\n\tends[10] = vec2(-1.9268292682926829, -0.4024390243902439);\n\tstarts[11] = vec2(-1.9268292682926829, -0.4024390243902439);\n\tends[11] = vec2(-1.98780487804878, -0.29268292682926833);\n\tstarts[12] = vec2(-1.98780487804878, -0.29268292682926833);\n\tends[12] = vec2(-2.1341463414634148, -0.23170731707317072);\n\tstarts[13] = vec2(-1.7195121951219512, -0.25609756097560976);\n\tends[13] = vec2(-1.5853658536585367, -0.7195121951219512);\n\tstarts[14] = vec2(-1.5853658536585367, -0.7195121951219512);\n\tends[14] = vec2(-1.402439024390244, -0.2682926829268293);\n\tstarts[15] = vec2(-1.402439024390244, -0.2682926829268293);\n\tends[15] = vec2(-1.2195121951219512, -0.7073170731707317);\n\tstarts[16] = vec2(-1.2195121951219512, -0.7073170731707317);\n\tends[16] = vec2(-1.0609756097560976, -0.25609756097560976);\n\tstarts[17] = vec2(-0.46341463414634154, -0.07317073170731703);\n\tends[17] = vec2(-0.46341463414634154, -0.7195121951219512);\n\tstarts[18] = vec2(-0.46341463414634154, -0.7195121951219512);\n\tends[18] = vec2(-0.07317073170731725, -0.7195121951219512);\n\tstarts[19] = vec2(0.2682926829268292, -0.23170731707317072);\n\tends[19] = vec2(0.10975609756097587, -0.30487804878048785);\n\tstarts[20] = vec2(0.10975609756097587, -0.30487804878048785);\n\tends[20] = vec2(0.06097560975609771, -0.4878048780487805);\n\tstarts[21] = vec2(0.06097560975609771, -0.4878048780487805);\n\tends[21] = vec2(0.13414634146341495, -0.6585365853658536);\n\tstarts[22] = vec2(0.13414634146341495, -0.7073170731707317);\n\tends[22] = vec2(0.3170731707317074, -0.7439024390243902);\n\tstarts[23] = vec2(0.3414634146341465, -0.7195121951219512);\n\tends[23] = vec2(0.48780487804878025, -0.6219512195121952);\n\tstarts[24] = vec2(0.48780487804878025, -0.6219512195121952);\n\tends[24] = vec2(0.4999999999999997, -0.426829268292683);\n\tstarts[25] = vec2(0.4999999999999997, -0.426829268292683);\n\tends[25] = vec2(0.4390243902439028, -0.31707317073170727);\n\tstarts[26] = vec2(0.4390243902439028, -0.31707317073170727);\n\tends[26] = vec2(0.28048780487804875, -0.2195121951219512);\n\tstarts[27] = vec2(0.731707317073171, -0.24390243902439024);\n\tends[27] = vec2(0.9024390243902439, -0.23170731707317072);\n\tstarts[28] = vec2(0.9024390243902439, -0.23170731707317072);\n\tends[28] = vec2(1.0731707317073167, -0.29268292682926833);\n\tstarts[29] = vec2(1.0731707317073167, -0.29268292682926833);\n\tends[29] = vec2(1.097560975609756, -0.7317073170731707);\n\tstarts[30] = vec2(1.0853658536585364, -0.4512195121951219);\n\tends[30] = vec2(0.7926829268292681, -0.46341463414634143);\n\tstarts[31] = vec2(0.7926829268292681, -0.46341463414634143);\n\tends[31] = vec2(0.6951219512195125, -0.6097560975609757);\n\tstarts[32] = vec2(0.682926829268293, -0.6097560975609757);\n\tends[32] = vec2(0.8048780487804876, -0.7560975609756098);\n\tstarts[33] = vec2(0.8048780487804876, -0.7560975609756098);\n\tends[33] = vec2(1.0853658536585364, -0.6829268292682926);\n\tstarts[34] = vec2(1.7073170731707317, -0.012195121951219523);\n\tends[34] = vec2(1.7317073170731707, -0.7195121951219512);\n\tstarts[35] = vec2(1.695121951219512, -0.6341463414634145);\n\tends[35] = vec2(1.4878048780487805, -0.7804878048780488);\n\tstarts[36] = vec2(1.4878048780487805, -0.7804878048780488);\n\tends[36] = vec2(1.341463414634146, -0.5975609756097562);\n\tstarts[37] = vec2(1.3292682926829271, -0.5853658536585367);\n\tends[37] = vec2(1.3170731707317076, -0.3780487804878049);\n\tstarts[38] = vec2(1.3170731707317076, -0.3780487804878049);\n\tends[38] = vec2(1.4634146341463414, -0.24390243902439024);\n\tstarts[39] = vec2(1.4634146341463414, -0.24390243902439024);\n\tends[39] = vec2(1.695121951219512, -0.2682926829268293);\n\tstarts[40] = vec2(1.98780487804878, -0.04878048780487809);\n\tends[40] = vec2(2.024390243902439, -0.04878048780487809);\n\tstarts[41] = vec2(2.0121951219512195, -0.24390243902439024);\n\tends[41] = vec2(2.0121951219512195, -0.7073170731707317);\n\tstarts[42] = vec2(2.3048780487804876, -0.24390243902439024);\n\tends[42] = vec2(2.3048780487804876, -0.7317073170731707);\n\tstarts[43] = vec2(2.3048780487804876, -0.3414634146341463);\n\tends[43] = vec2(2.5243902439024386, -0.2195121951219512);\n\tstarts[44] = vec2(2.5243902439024386, -0.2195121951219512);\n\tends[44] = vec2(2.682926829268293, -0.31707317073170727);\n\tstarts[45] = vec2(2.682926829268293, -0.31707317073170727);\n\tends[45] = vec2(2.682926829268293, -0.7439024390243902);\n\tstarts[46] = vec2(3.3292682926829267, -0.2682926829268293);\n\tends[46] = vec2(3.3292682926829267, -0.8170731707317074);\n\tstarts[47] = vec2(3.3292682926829267, -0.8170731707317074);\n\tends[47] = vec2(3.182926829268293, -0.9634146341463414);\n\tstarts[48] = vec2(3.182926829268293, -0.9634146341463414);\n\tends[48] = vec2(2.9878048780487805, -0.9268292682926829);\n\tstarts[49] = vec2(3.3170731707317067, -0.30487804878048785);\n\tends[49] = vec2(3.1341463414634148, -0.24390243902439024);\n\tstarts[50] = vec2(3.1341463414634148, -0.24390243902439024);\n\tends[50] = vec2(2.951219512195122, -0.31707317073170727);\n\tstarts[51] = vec2(2.951219512195122, -0.31707317073170727);\n\tends[51] = vec2(2.8902439024390243, -0.524390243902439);\n\tstarts[52] = vec2(2.8902439024390243, -0.524390243902439);\n\tends[52] = vec2(3.036585365853659, -0.7073170731707317);\n\tstarts[53] = vec2(3.036585365853659, -0.7073170731707317);\n\tends[53] = vec2(3.1707317073170733, -0.7073170731707317);\n\tstarts[54] = vec2(3.158536585365854, -0.7073170731707317);\n\tends[54] = vec2(3.2926829268292677, -0.646341463414634);\n    Po res;\n    int idx = -1;\n    float dist = 114514.;\n    float t = TIME * 80.;\n    float po = (1. - cos(TIME)) / 2.;\n    for (int i = 0; i < N; i++) {\n        vec2 origin =  rot(vec2(1,0), float(i+0) * 360. / float(N) + t) * 0.5;\n        vec2 origin2 = rot(vec2(1,0), (float(i+0) + (i == 0 ? 0.2 : 1.)) * 360. / float(N) + t) * 0.5;\n        starts[i] = origin * (1. - po) + po * trans(starts[i]);\n        ends[i] = origin2 * (1. - po) + po * trans(ends[i]);\n        float d = seg(starts[i], ends[i], p);\n        if (d < dist) {\n            dist = d;\n            idx = i;\n        }\n    }\n    res.d = dist;\n    res.idx = idx;\n    return res;\n}\n\nconst float PI = 3.141592;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    Po po = dist(uv);\n    float t = 1. / po.d * 0.01;\n    float theta = float(po.idx) / float(N) * 360.;\n    fragColor.rgb = vec3(t) * 1.;\n    fragColor.a = 1.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lt3Szn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltdBWX", "name": "sinusoid test", "author": "lalalaring", "description": "sinusoid", "tags": ["sinusoid"], "likes": 0, "viewed": 67, "date": "1541394649", "time_retrieved": "2024-06-20T19:24:25.102647", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tfloat sino = 0.5 * (1.0 + sin( 0.0001f * dot(fragCoord, fragCoord) + iTime * 5.0 ));\n    // Output to screen\n    fragColor = vec4(sino,sino,sino,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltdBWX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltGBRm", "name": "Raytracer Reflexion ", "author": "dacruzquen", "description": "raytracer", "tags": ["raytracer"], "likes": 1, "viewed": 136, "date": "1542106033", "time_retrieved": "2024-06-20T19:24:26.563432", "image_code": "//link : \n\n//Material\nstruct Material\n{\n    float Ka;\n    float Kd;\n    float Ks;\n    float Kn;\n};\n    \nstruct ShadeInfo\n{\n    vec3 shadedCol;\n    float Ks;\n};\n    \nconst int MAX_NB_BOUNCES = 5;\n\n//camera parameters\nvec3 cameraPos = vec3(6,4,-5);\nconst vec3 cameraTarget = vec3(3,1,-8);\nconst float cameraFovY = 80.0; // Note: angle is degree\n\n//Sphere parameters\nvec3 spherePos = cameraTarget + vec3(0,1,2);\nconst float sphereRadius = 1.0;\nconst vec3 sphereCol = vec3(1,0,0);\nconst Material sphereMat = Material(0.2,0.7,1.0,50.0);\nconst int sphereId = 1;\n\n//Light parameters\nconst vec3 ambiantCol = vec3(0,0,1);\nconst vec3 lightCol = vec3(1,1,1);\nvec3 lightPos = vec3(8,10,-12);\n\n//Sky parameters\nconst vec3 skyCol = vec3(0);\nconst int skyId = 0;\n\n//Plane parameters\nconst vec3 planePos = vec3(0, 0.1, 0);\nconst vec3 planeNormal = vec3(0,1.0,0);\nconst vec3 planeCol1 = vec3(1.0);\nconst vec3 planeCol2 = vec3(0.4);\nconst Material planeMat = Material(0.2,1.0,0.2,5.0);\nconst int planeId = 2;\n\nconst int PIXEL_SAMPLING_GRID_SIZE = 5;\nconst int PIXEL_SAMPLING_SIZE = 5;\n\nvec2 transform_to_apply(vec2 xy){\n    xy = (2.*xy.xy - iResolution.xy)/iResolution.y;\n    return vec2(xy.x,xy.y);\n}\n\nfloat raySphere(vec3 rayPos, vec3 rayDir, vec3 spherePos, float sphereRadius, out vec3 intersecS, out vec3 normalS)\n{    \n    vec3 diff = rayPos - spherePos;\n    \n    float a = dot(rayDir,rayDir);\n    float b = 2.0 * dot(diff,rayDir);\n    float c = dot(diff,diff) - sphereRadius * sphereRadius;\n    \n    float di = b*b - 4.0*a*c;\n    \n    if(di >= 0.0)\n    {\n        float sdi = sqrt(di);\n        float den = 1.0 / (2.0 * a);\n        float t1 = (-b - sdi) * den;\n        float t2 = (-b + sdi) * den;\n        \n        intersecS = rayPos + t1 * rayDir;\n        normalS = normalize(intersecS - spherePos);\n        \n        return t1;\n    }\n    \n    return -1.;\n}\n\nfloat rayPlane(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal, out vec3 intersecPt, out vec3 normal)\n{\n    if(dot(rayDir,planeNormal)!=0.0)\n    {\n        float t = dot(planePos - rayPos,planeNormal)/dot(rayDir,planeNormal);\n        \n        intersecPt = rayPos + t * rayDir;\n        normal = planeNormal;\n        \n        return t;\n    }\n    return -1.0;\n}\n\nvoid computeCameraRayFromPixel(in vec2 pixCoord, out vec3 rayPos, out vec3 rayDir)\n{\n    rayPos = cameraPos;\n    \n    float f = 1./tan(radians(cameraFovY)/2.);\n    \n    vec3 PT = cameraTarget - cameraPos;\n    vec3 cz = normalize(PT);\n    \n    vec3 PO = f*cz;\n    \n    vec3 cyT = vec3(0,-1.,0);\n    vec3 cxT = cross(cyT,cz);\n    \n    vec3 cx = normalize(cxT);\n    \n    vec3 cy = cross(cz,cx);\n    \n    vec3 OS = pixCoord.x * cx - pixCoord.y * cy;\n    \n    rayDir = normalize(PO+OS);\n}\n\nvec3 computePhongShading(vec3 sphereCol, Material sphereMat,float shadowFactor, vec3 normal, vec3 L, vec3 R, vec3 V)\n{\n    vec3 A = sphereMat.Ka * ambiantCol;\n    vec3 D = sphereMat.Kd * sphereCol * lightCol * max(dot(L,normal),0.0);\n    vec3 S = sphereMat.Ks * lightCol * pow(max(dot(R,V),0.0),sphereMat.Kn);\n    return A+shadowFactor*D+shadowFactor*S;\n}\n\n//The aim of this routine is to find the nearest intersection the ray has with all objects\nfloat computeNearestIntersection(vec3 rayPos, vec3 rayDir, out int objectId, out vec3 intersecI, out vec3 normalI)\n{\n    vec3 intersecS, normalS;\n    float distSphere = raySphere(rayPos, rayDir, spherePos, sphereRadius, intersecS, normalS);\n    vec3 intersecP, normalP;\n    float distPlane = rayPlane(rayPos, rayDir, planePos, planeNormal, intersecP, normalP);\n    if(distSphere > 0.0 && distPlane > 0.0)\n    {\n        float distMin = min(distSphere,distPlane);\n        objectId = (distSphere == distMin) ? sphereId : planeId; \n        intersecI = (distSphere == distMin) ? intersecS : intersecP; ;\n        normalI = (distSphere == distMin) ? normalS : normalP; ;\n        return distMin;\n    }\n    else\n    {\n        if(distSphere > 0.0)\n        {\n            objectId = sphereId;\n            intersecI = intersecS;\n            normalI = normalS;\n            return distSphere;\n        }\n        else if (distPlane > 0.0)\n        {\n            objectId = planeId;\n            intersecI = intersecP;\n            normalI = normalP;\n            return distPlane;\n        }\n        else\n        {\n           \tobjectId = skyId;\n            return -1.0;\n        }\n    }\n}\n\nvec3 getSphereColorAtPoint(vec3 pt)\n{\n    return sphereCol;\n}\n\n//pt is assumed to be on the place surface\nvec3 getPlaneColorAtPoint(vec3 pt)\n{\n    return mod(floor(pt.x*0.5) + floor(pt.z*0.5),2.0) < 1.0 ? planeCol1 : planeCol2;\n}\n\nvec3 getObjectColorAtPoint(int objectId, vec3 pt, out Material objectMat)\n{\n    switch(objectId)\n    {\n        case 0:\n        \treturn skyCol;\n        case 1:\n        \tobjectMat = sphereMat;\n        \treturn getSphereColorAtPoint(pt);\n        case 2:\n        \tobjectMat = planeMat;\n        \treturn getPlaneColorAtPoint(pt);\n    }\n}\n\nfloat getShadowFactorAtPoint(vec3 I, vec3 N, Material objectMat, vec3 L, float Ldist)\n{\n    I += 0.001*N;\n    int objId;\n    vec3 intersecS, normalS;\n    float d = computeNearestIntersection(I,L,objId,intersecS,normalS);\n    return (d<=0.0 || d>=Ldist)?1.0:objectMat.Ka;\n}\n\nvec3 RaytraceAtPixelCoord(vec2 pixCoord)\n{\n    vec3 rayPos, rayDir;\n    computeCameraRayFromPixel(pixCoord, rayPos, rayDir);\n    \n    ShadeInfo infos[MAX_NB_BOUNCES];\n    int nbBounces = 0;\n    do\n    {\n        int objectId;\n        vec3 intersecI, normalI;\n        float distI = computeNearestIntersection(rayPos,rayDir,objectId,intersecI,normalI);\n        \n        if(distI <= 0.0)\n        {\n            infos[nbBounces].shadedCol = skyCol;\n            infos[nbBounces].Ks = 0.0;\n            break;\n        }\n        \n        Material objMat;\n    \tvec3 col = getObjectColorAtPoint(objectId, intersecI, objMat);\n    \tvec3 L = normalize(lightPos - intersecI);\n    \tvec3 R = normalize(2.0*dot(normalI,L)*normalI - L);\n    \tvec3 V = -rayDir;\n        \n        float Ldist = distance(intersecI,lightPos);\n        \n        float shadowFactor = getShadowFactorAtPoint(intersecI, normalI, objMat, L, Ldist);\n        \n    \t//Phong shading to get the color of the surface point\n    \tvec3 c = computePhongShading(col, objMat, shadowFactor, normalI, L, R, V);\n        \n        infos[nbBounces].shadedCol = c;\n        infos[nbBounces].Ks = objMat.Ks;\n        \n        rayPos = intersecI + 0.001*normalI;\n        rayDir = normalize(2.0*dot(normalI,V)*normalI - V);\n        //objId = objectId;\n        \n        nbBounces++;\n        \n    }while(nbBounces < MAX_NB_BOUNCES);\n    \n    vec3 resCol = vec3(0);\n    \n   \tdo\n    {\n        resCol = infos[nbBounces].shadedCol + infos[nbBounces].Ks * resCol;\n        nbBounces--;\n    }while(nbBounces >= 0);\n    \n    return resCol;\n}\n\n//De facto \"noise\" function, modified to supply two values\n//Taken from: https://www.shadertoy.com/view/4dGXW1\nvec2 noise2(vec2 location, vec2 delta)\n{\n    const vec2 c = vec2(12.9898,78.233);\n    const float m = 43758.5453;\n    return vec2(\n        fract(sin(dot(location + delta, c)) * m),\n        fract(sin(dot(location + vec2(delta.y,delta.x),c)) * m)\n        );\n}\n\nvoid animateScene(float time)\n{\n    const float pi = 3.1415926535;\n    const float rs = 2.0;\n    const float spr = 5.0;\n    float as = 2.0 * pi * time / spr;\n    \n    spherePos = cameraTarget + rs * vec3(-sin(as),0.0,cos(as)) + vec3(0,1,0);\n    \n    lightPos += vec3(0,10.5 + 9.5 * cos(time) - 10.,0);\n    \n    float targetDist = length(cameraTarget - cameraPos);\n    cameraPos -= vec3(0,0,targetDist);\n    cameraPos += targetDist * vec3(sin(time),max(sin(time*0.5),0.),cos(time));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float time = iTime;\n    \n    animateScene(time*1.0);\n    \n    //Apply change of coordinates from pixel\n    fragCoord = transform_to_apply(fragCoord.xy);\n    \n    vec3 resCol = vec3(0);\n    \n    for (int i=0; i<PIXEL_SAMPLING_GRID_SIZE; i++) \n    {\n        for (int j=0; j<PIXEL_SAMPLING_SIZE; j++) \n        {\n            vec2 offset = vec2(float(i)/(float(PIXEL_SAMPLING_GRID_SIZE)*iResolution.x),float(j)/(float(PIXEL_SAMPLING_SIZE)*iResolution.y));\n            /*vec2 q =  vec2(float(i), float(j));\n            vec2 n = noise2( fragCoord , q );\n            vec2 offset = vec2(n.x/800., n.y/600.);*/\n\t\t\tresCol += RaytraceAtPixelCoord(fragCoord + offset);\n      \t}\n    }\n    resCol /= float(PIXEL_SAMPLING_GRID_SIZE * PIXEL_SAMPLING_SIZE);\n    \n    fragColor = vec4(resCol,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltGBRm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltGBRR", "name": "Antelope Canyon II", "author": "Ubiquitous", "description": "Originally from [https://www.shadertoy.com/view/MlG3zh], I had created [https://www.shadertoy.com/view/4tGfzz]. adding ground plane, adjusting light to simulate dusting of snow on the path/rocks, and fog tweaks; this is a more realistic version.", "tags": ["rocks", "flythrough", "canyon", "antelope", "arizona"], "likes": 11, "viewed": 387, "date": "1541581890", "time_retrieved": "2024-06-20T19:24:29.442485", "image_code": "/*\n\tAntelope Canyon\n    -----------\n    Modified From: https://www.shadertoy.com/view/MlG3zh\n\n\tCombining some cheap distance field functions with some functional and texture-based bump \n\tmapping to carve out a rocky canyon-like passageway.\n\n\tThere's nothing overly exciting about this example. I was trying to create a reasonably\n    convincing looking rocky setting using cheap methods.\n\n\tI added in some light frosting, mainly to break the monotony of the single colored rock.\n\tThere's a mossy option below, for anyone interested. Visually speaking, I find the moss more\n\tinteresting, but I thought the frost showed the rock formations a little better. Besides,\n\tI'd like to put together a more dedicated greenery example later.\n\n*/\n\n#define PI 3.14159265\n#define FAR 60.\n\n// Extra settings. Use one or the other. The MOSS setting overrides the HOT setting.\n// Mossy setting. Better, if you want more color to liven things up. For this example, I wanted subtlety.\n//#define MOSS \n// Hot setting. It represents 2 minutes of post processing work, so it's definitely nothing to excited about. :)\n//#define HOT\n\n// Coyote's snippet to provide a virtual reality element. Really freaky. It gives the scene \n// physical depth, but you have to do that magic picture focus adjusting thing with your eyes.\n//#define THREE_D \n\n\n// Rotation matrix.\nconst mat2 rM = mat2(.7071, .7071, -.7071, .7071); \n\n// 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n// of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) + a);\treturn mat2(v, -v.y, v.x); }\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D channel, vec3 p, vec3 n){\n    \n    //vec3 col = mix(vec3(.7, 1, 1.3), vec3(1), n.y*.5 + .5);\n    \n    n = max(abs(n) - 1.5, 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(channel, p.zy).xyz;\n    vec3 ty = texture(channel, p.xz).xyz;\n    vec3 tz = texture(channel, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);//*col;\n}\n\n\n// Cellular tile setup. Draw four overlapping objects (spheres, in this case) \n// at various positions throughout the tile.\n \nfloat drawObject(in vec3 p){\n  \n    p = fract(p)-.2;\n    return dot(p, p);\n    \n}\n\n\n// 3D cellular tile function.\nfloat cellTile(in vec3 p){\n   \n    vec4 d; \n    \n    // Plot four objects.\n    d.x = drawObject(p - vec3(.81, .62, .53));\n    p.xy *= rM;\n    d.y = drawObject(p - vec3(.6, .82, .64));\n    p.yz *= rM;\n    d.z = drawObject(p - vec3(.51, .06, .70));\n    p.zx *= rM;\n    d.w = drawObject(p - vec3(.12, .62, .64));\n\n\t// Obtaining the minimum distance.\n    d.xy = min(d.xz, d.yw);\n    \n    // Normalize... roughly. Trying to avoid another min call (min(d.x*A, 1.)).\n    return  min(d.x, d.y)*0.7;\n    \n}\n\n\n// The triangle function that Shadertoy user Nimitz has used in various triangle noise demonstrations.\n// See Xyptonjtroz - Very cool. Anyway, it's not really being used to its full potential here.\n// https://www.shadertoy.com/view/4ts3z2\nvec3 tri(in vec3 x){return abs(fract(x)-.51);} // Triangle function.\n\n\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){\n   \n    //return vec2(0); // Straight.\n    float a = sin(z * 0.43);\n    float b = cos(z * 0.22);\n    return vec2(a*1.5 -b*0.5, b*0.6 + a*0.5); \n    //return vec2(a*4. -b*1.5, 0.); // Just X.\n    //return vec2(0, b*1.7 + a*1.5); // Just Y.\n}\n\n\n\n// A fake noise looking sinusoial field - flanked by a ground plane and some walls with\n// some triangular-based perturbation mixed in. Cheap, but reasonably effective.\nfloat map(vec3 p){\n    \n \n    p.xy -= path(p.z); // Wrap the passage around\n    \n    vec3 w = p; // Saving the position prior to mutation.\n    \n    vec3 op = tri(p*.4*3. + tri(p.zxy*.4*2.)); // Triangle perturbation.\n   \n    \n    float ground = p.y + 0.02 + dot(op, vec3(.111))*.02; // Ground plane, slightly perturbed.\n \n    p += (op - 0.05)*.33; // Adding some triangular perturbation.\n   \n\tp = cos(p*.51*0.51 + sin(p.zxy*1.19*1.12)); // Applying the sinusoidal field (the rocky bit).\n    \n    float canyon = (length(p) - 0.72)*.45 - (w.x*w.x)*0.45; // Spherize and add the canyon walls.\n    \n    return min(ground, canyon);\n\n    \n}\n\n\n\n// Surface bump function. I'm reusing the \"cellTile\" function, but absoulte sinusoidals\n// would do a decent job too.\nfloat bumpSurf3D( in vec3 p, in vec3 n){\n    \n    //return (cellTile(p/1.5))*.66 + (cellTile(p*2./1.5))*.34;\n    \n    return cellTile(p/1.5);\n    \n}\n\n// Standard function-based bump mapping function.\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    const vec2 e = vec2(6.201, 0);\n    float ref = bumpSurf3D(p, nor);                 \n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy, nor),\n                      bumpSurf3D(p - e.yxy, nor),\n                      bumpSurf3D(p - e.yyx, nor) )-ref)/e.x;                     \n          \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n    \n}\n\n\nfloat accum;\n\n\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n    \n    accum = 0.;\n\n    float t = 0.2, h;\n    for(int i = 0; i < 160; i++){\n    \n        h = map(ro+rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(h)<0.001*(t*.15 + 1.) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.)\n        t += h;//*.7;\n        \n        if(abs(h)<0.15) accum += (.15-abs(h))/16.;///(1.+t);//.0005/abs(h);\n        //if(abs(h)<0.25)accum += (.25-abs(h))*vec3(3, 2, 1)/4.*n3D((ro+rd*t)*16. - vec3(0, 0, 1)*iTime*1.);\n        \n    }\n\n    return min(t, FAR);\n    \n}\n\n/*\n// Ambient occlusion, for that self shadowed look. Based on the original by XT95. I love this \n// function, and in many cases, it gives really, really nice results. For a better version, and \n// usage, refer to XT95's examples below:\n//\n// Hemispherical SDF AO - https://www.shadertoy.com/view/4sdGWN\n// Alien Cocoons - https://www.shadertoy.com/view/MsdGz2\nfloat calculateAO2( in vec3 p, in vec3 n )\n{\n\tfloat ao = 0.0, l;\n    const float maxDist = 2.;\n\tconst float nbIte = 6.0;\n\t//const float falloff = 0.9;\n    for( float i=1.; i< nbIte+.5; i++ ){\n    \n        l = (i*.75 + fract(cos(i)*45758.5453)*.25)/nbIte*maxDist;\n        \n        ao += (l - map( p + n*l ))/(1.+ l);// / pow(1.+l, falloff);\n    }\n\t\n    return clamp(1.- ao/nbIte, 0., 1.);\n}\n*/\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calculateAO(in vec3 p, in vec3 n){\n\t\n    float sca = 1., occ = 0.5;\n    for(float i=0.; i<5.; i++){\n    \n        float hr = .01 + i*.5/4.;        \n        float dd = map(n * hr + p);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp(1.61 - occ, 0., 1.); // lower base shadow   \n}\n\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ. In instances where there's no descernible \n// aesthetic difference between it and the six tap version, it's worth using.\nvec3 calcNormal(in vec3 p){\n\n    // Note the slightly increased sampling distance, to alleviate artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.001, -0.001); \n    return normalize(e.xyy*map(p + e.xyy) + e.yyx*map(p + e.yyx) + e.yxy*map(p + e.yxy) + e.xxx*map(p + e.xxx));\n}\n\n/*\n// Standard normal function. 6 taps.\nvec3 calcNormal(in vec3 p) {\n\tconst vec2 e = vec2(0.002, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n*/\n\n// Shadows.\nfloat shadows(in vec3 ro, in vec3 rd, in float start, in float end, in float k){\n\n    float shade = 1.0;\n    const int shadIter = 14; \n\n    float dist = start;\n    //float stepDist = end/float(shadIter);\n\n    for (int i=0; i<shadIter; i++){\n        float h = map(ro + rd*dist);\n        shade = min(shade, k*h/dist);\n        //shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n\n        dist += clamp(h, 2.32, 1.2);\n        \n        // There's some accuracy loss involved, but early exits from accumulative distance function can help.\n        if ((h)<0.001 || dist > end) break; \n    }\n    \n    return min(max(shade, 0.) + 0.1, 1.0); \n}\n\n//////\n// Very basic pseudo environment mapping... and by that, I mean it's fake. :) However, it \n// does give the impression that the surface is reflecting the surrounds in some way.\n//\n// Anyway, the idea is very simple. Obtain the reflected (or refracted) ray at the surface \n// hit point, then index into a repeat texture in some way. It can be pretty convincing \n// (in an abstract way) and facilitates environment mapping without the need for a cube map, \n// or a reflective pass.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\n\nvec3 envMap(vec3 rd, vec3 n){\n    \n    return tex3D(iChannel0, rd, n);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t\n\t// Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n    \n    #ifdef THREE_D\n    float sg = sign(fragCoord.x - .5*iResolution.x);\n    uv.x -= sg*.25*iResolution.x/iResolution.y;\n    #endif\n\t\n\t// Camera Setup.\n    vec3 camPos = vec3(0.0, 0.5, iTime*4.); // Camera position, doubling as the ray origin.\n\n\tvec3 lookAt = camPos + vec3(0.1, 0.1, 0.65);  // \"Look At\" position.\n\n \n    // Light positioning. The positioning is fake. Obviously, the light source would be much \n    // further away, so illumination would be relatively constant and the shadows more static.\n    // That's what direct lights are for, but sometimes it's nice to get a bit of a point light \n    // effect... but don't move it too close, or your mind will start getting suspicious. :)\n \tvec3 lightPos = camPos + vec3(-30, 20, -20);\n\n\n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and two light vectors down the tunnel. The \"path\" function is \n\t// synchronized with the distance function. Change to \"path2\" to traverse the other tunnel.\n\tlookAt.xy += path(lookAt.z);\n\tcamPos.xy += path(camPos.z);\n\t//lightPos.xy += path(lightPos.z);\n    \n    \n    #ifdef THREE_D\n    camPos.x -= sg*.15; lookAt.x -= sg*.15; lightPos.x -= sg*.15;\n    #endif\n    \n    \n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.333;//PI/3.; // FOV - Field of view.\n    vec3 forward = normalize(lookAt-camPos);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    \n    // Lens distortion.\n    //vec3 rd = (forward + FOV*uv.x*right + FOV*uv.y*up);\n    //rd = normalize(vec3(rd.xy, rd.z - length(rd.xy)*.25));    \n    \n    // Swiveling the camera about the XY-plane (from left to right) when turning corners.\n    // Naturally, it's synchronized with the path in some kind of way.\n\trd.xy = rot2( path(lookAt.z).x/16. )*rd.xy;\n\n    /*    \n    // Mouse controls. I use them as a debugging device, but they can be used to look around. \n\tvec2 ms = vec2(0);\n    if (iMouse.z > 1.0) ms = (2.*iMouse.xy - iResolution.xy)/iResolution.xy;\n    vec2 a = sin(vec2(1.5707963, 0) - ms.x); \n    mat2 rM = mat2(a, -a.y, a.x);\n    rd.xz = rd.xz*rM; \n    a = sin(vec2(1.5707963, 0) - ms.y); \n    rM = mat2(a, -a.y, a.x);\n    rd.yz = rd.yz*rM;\n\t*/\n    \n    // Standard ray marching routine. I find that some system setups don't like anything other than\n    // a \"break\" statement (by itself) to exit. \n\tfloat t = trace(camPos, rd);   \n    \n\t\n    // Initialize the scene color.\n    vec3 sceneCol = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t<FAR){\n\t\n   \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = camPos + rd*t;\n        \n        // Voxel normal.\n        //vec3 sn = -(mask * sign( rd ));\n        vec3 sn = calcNormal(sp);\n        \n        // Sometimes, it's necessary to save a copy of the unbumped normal.\n        vec3 snNoBump = sn;\n        \n        // I try to avoid it, but it's possible to do a texture bump and a function-based\n        // bump in succession. It's also possible to roll them into one, but I wanted\n        // the separation... Can't remember why, but it's more readable anyway.\n        //\n        // Texture scale factor.\n        const float tSize0 = .9/1.;\n        \n        \n        // Function based bump mapping. Comment it out to see the under layer. It's pretty\n        // comparable to regular beveled Voronoi... Close enough, anyway.\n        sn = doBumpMap(sp, sn, .5);\n        \n        // Texture-based bump mapping.\n\t    sn = doBumpMap(iChannel0, sp*tSize0, sn, .1);//(-sign(sn.y)*.15+.85)*\n\n        \n    \t// Light direction vectors.\n\t    vec3 ld = lightPos - sp;\n\n        // Distance from respective lights to the surface point.\n\t    float lDist = max(length(ld), 0.001);\n    \t\n    \t// Normalize the light direction vectors.\n\t    ld /= lDist;\n        \n        // Shadows.\n        float shading = shadows(sp + sn*.005, ld, .45, lDist, 38.);\n        \n\t    // Ambient occlusion.\n\t    float ao = calculateAO(sp, sn);//*.75 + .25;\n\n\t    \n        \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.037);\n    \t\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 1.0);\n   \t\n    \t// Specular lighting.\n\t    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.1 ), 12.);\n\n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow( clamp(dot(sn, rd) + 1., .0, 1.), 1.);\n        \n        // Ambient light, due to light bouncing around the the canyon.\n\t    float ambience = 0.35*ao + fre*fre*.25;\n\n        // Object texturing, coloring and shading.\n\t    vec3 texCol = tex3D(iChannel0, sp*tSize0, sn);\n\n        // Tones down the pinkish limestone\\granite color.\n        //texCol *= mix(vec3(.7, 1, 1.3), vec3(1), snNoBump.y*.5 + .5);\n        \n        #ifdef MOSS\n        // Some quickly improvised moss.\n        texCol = texCol*mix(vec3(1), vec3(.5, 1.5, 1.5), abs(snNoBump));\n        texCol = texCol*mix(vec3(1), vec3(.6, 1, 1.5), pow(abs(sn.y), 4.));\n        #else\n        // Adding in the white frost. A bit on the cheap side, but it's a subtle effect.\n        // As you can see, it's improvised, but from a physical perspective, you want the frost to accumulate\n        // on the flatter surfaces, hence the \"sn.y\" factor. There's some Fresnel thrown in as well to give\n        // it a tiny bit of sparkle.\n        texCol = mix(texCol, vec3(.35, .55, 1)*(texCol*.5+.5)*vec3(2), ((snNoBump.y*.5 + sn.y*.5)*.5+.5)*pow(abs(sn.y), 44.)*texCol.r*fre*2.);\n        #endif      \n\n        \n        // Final color. Pretty simple.\n        sceneCol = texCol*(diff + spec + ambience);// + vec3(.2, .5, 1)*spec;\n        \n        // A bit of accumulated glow.\n        sceneCol += texCol*((sn.y)*1.5+.5)*min(vec3(1, 1.35, 1.5)*accum, 41.);  \n     \n        \n        // Adding a touch of Fresnel for a bit of glow.\n        sceneCol += texCol*vec3(.8, .95, 1)*pow(fre, 24.)*.5;\n        \n        \n        // Faux environmental mapping. Adds a bit more ambience.        \n        vec3 sn2 = snNoBump*.5 + sn*.5;\n        vec3 ref = reflect(rd, sn2);//\n        vec3 em = envMap(ref/2., sn2);\n        ref = refract(rd, sn2, 1./1.31);\n        vec3 em2 = envMap(ref/8., sn2);\n        //sceneCol += ((sn.y)*.25+.75)*sceneCol*(em + em2);\n        sceneCol += sceneCol*2.*(sn.y*.25+.75)*mix(em2, em, pow(fre, 4.));\n\n\n\t    // Shading. Adding some ambient occlusion to the shadow for some fake global lighting.\n        sceneCol *= atten*min(shading + ao*.35, 1.)*ao;\n\t   \n\t\n\t}\n    \n       \n    // Blend in a bit of light fog for atmospheric effect. I really wanted to put a colorful, \n    // gradient blend here, but my mind wasn't buying it, so dull, blueish grey it is. :)\n    vec3 fog = vec3(0.6, 0.8, 1.3)*(rd.y*2.5 + 2.5);\n    #ifdef MOSS\n    fog *= vec3(14, 0.4, 1.5);\n    #else\n    #ifdef HOT\n    fog *= 4.;\n    #endif\n    #endif\n    sceneCol = mix(sceneCol, fog, smoothstep(0., .95, t/FAR)); // exp(-.002*t*t), etc. fog.zxy\n    \n    \n    //sceneCol *= vec3(.5, .75, 1.5); // Nighttime vibe.\n    #ifndef MOSS\n    #ifdef HOT\n    float gr = dot(sceneCol, vec3(.299, .287, .114)); // Grayscale.\n    // A tiny portion of the original color blended with a very basic fire palette.\n    sceneCol = sceneCol*.1 + pow(min(vec3(1.5, 1, 1)*gr*1.2, 1.), vec3(1, 3, 16));\n    // Alternative artsy look. Comment out the line above first.\n    //sceneCol = mix(sceneCol, pow(min(vec3(1.5, 1, 1)*gr*1.2, 1.), vec3(1, 3, 16)), -uv.y + .5);\n    #endif\n    #endif\n    \n    // Subtle, bluish vignette.\n    uv = fragCoord/iResolution.xy;\n    sceneCol = mix(vec3(0, .1, 1), sceneCol, pow( 24.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y) , .125)*.15 + .85);\n    \n\n    // Clamp and present the badly gamma corrected pixel to the screen.\n\tfragColor = vec4(sqrt(clamp(sceneCol, 0.01, 0.5)), 1.4);\n\t\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltGBRR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltGfDD", "name": "Wa ,myfirstshader", "author": "wanli", "description": "low low 1", "tags": ["low"], "likes": 2, "viewed": 72, "date": "1542556600", "time_retrieved": "2024-06-20T19:24:29.442485", "image_code": "float minZero(float ix){\n    if(ix<0.){\n    \tix=0.;\n    }\n    return ix;\n}\n\nfloat MyCirle_mask(vec2 uv, vec2 p,float r,float blur){\n    \n    uv.x-=p.x;\t\t\t\t\t\t\t// ÂÖàÂπ≥ÁßªÂÜçÁº©Êîæ\n    uv.y-=p.y;\n    uv.x*=iResolution.x/iResolution.y;\t//ËÆ©‰πãÂâçÁöÑÔºà1Ôºå1ÔºâÁöÑ xÂèòÂ§ßÂà∞x/yÂÄçÔºõ\n    float d=length(uv);\n    float s=smoothstep(r,r-blur,d);\n    return s;\n}\n\n\nfloat MySmile(vec2 uv,vec2 position,float size){\n    uv-=position;\n    uv/=size;\n    \n\tfloat face=MyCirle_mask(uv,vec2(0.0,0.0),.3,0.01);\n    float eye1=MyCirle_mask(uv,vec2(-0.06,0.1),.05,0.01);\n    float eye2=MyCirle_mask(uv,vec2(0.06,0.1),.05,0.01);\n    \n    float mouse1=MyCirle_mask(uv,vec2(0.0,0.1),.24,0.01);\n    float mouse2=MyCirle_mask(uv,vec2(0.0,-0.05),.2,0.01);\n    float mouse=mouse2-mouse1;\n    mouse=minZero(mouse);\n    return face-eye1-eye2-mouse;\n}\n\nfloat Band(float UV,float start,float end,float blur){\n\tfloat step1=smoothstep(start-blur,start+blur,UV);\n    float step2=smoothstep(end-blur,end+blur,UV);\n    return step1-step2;\n}\n\nfloat Rect(vec2 uv,float left,float right,float botton,float top,float blur){\n    uv.x*=iResolution.x/iResolution.y;\t//ËÆ©‰πãÂâçÁöÑÔºà1Ôºå1ÔºâÁöÑ xÂèòÂ§ßÂà∞x/yÂÄçÔºõ\n \tfloat step1=Band(uv.x,left,right,blur);\n    float step2=Band(uv.y,botton,top,blur);\n    return step1*step2;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float iGlobalTime=iTime;\n    vec2 uv = fragCoord/iResolution.xy; //0Âà∞1\n   \tuv.x-=0.5;\n    uv.y-=0.5;\n    \n    //move and smile\n    float size=sin(iTime);\n    if(size<0.){\n        size=-size;\n    }\n    float Color=MySmile(uv*size,vec2(0.,0.),0.7);\n    \n    \n    //Move\n    //float m=-(uv.x+0.3)*(uv.x-0.3);\n    //m*=13.0*m;\n    float m=sin(uv.x*20.+iTime*2.)/8.;\n   \tfloat x=uv.x;\n    float y=uv.y-m;\n    y=y*4.0/(12.0*x+6.);\n    \n    //blur\n    float blur=(9.0*x+3.)*0.01;\n    float RectMask=Rect(vec2(x,y),-1.,1.,-0.1,0.1,blur);\n    \n   \t//add smailface\n    vec3 AddColor=RectMask*vec3(1.)+Color*vec3(0.8,0.8,0.0);\n    \n    fragColor = vec4(vec3(AddColor),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltGfDD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltGfDR", "name": "Test Line 1", "author": "jangxx", "description": "First test", "tags": ["test"], "likes": 0, "viewed": 54, "date": "1542231227", "time_retrieved": "2024-06-20T19:24:29.442485", "image_code": "#define PI 3.14159265359\n\nbool modCompare(float a, float b, float modulus, float epsilon) {\n\tfloat mod_a = mod(a, modulus);\n    float mod_b = mod(b, modulus);\n    return (abs(mod_a - mod_b) <= epsilon || abs(mod_a - mod_b) + epsilon >= modulus);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x / iResolution.y;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv = vec2(-1.0 + uv.x*2.0, -1.0 + uv.y*2.0);\n    uv.x *= aspect;\n    \n    vec2 xaxis = vec2(1,0);\n    \n    float angle;\n    if (uv.y >= 0.0) {\n        angle = acos(dot(xaxis, uv) / length(uv));\n    } else {\n    \tangle = PI + acos(dot(-xaxis, uv) / length(uv));\n    }\n    \n    float lineAngle = iTime;\n    vec3 line = vec3(cos(lineAngle), sin(lineAngle), 0);\n    \n    float dist = length(cross(vec3(uv, 0), line)) / length(line);\n    \n    if (dist <= 0.1) {\n        fragColor = vec4(0,0,0,1);\n    } else if (mod(mod(angle - lineAngle, PI*2.0) + PI*2.0,PI*2.0) >= PI) {\n    \tfragColor = vec4(0,1,0,1);\n    } else {\n    \tfragColor = vec4(0,0,1,1);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltGfDR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltGfRK", "name": "Another Cubic Crystallograph", "author": "khlorghaal", "description": "I math only a little and suddenly the void awakens", "tags": ["raytrace", "crystal"], "likes": 2, "viewed": 130, "date": "1543122106", "time_retrieved": "2024-06-20T19:24:29.442485", "image_code": "#define ETA 1e-5\n\n#define PI 3.14159265359\n#define TAU (PI*2.)\n\n#define time float(iTime)\n\nprecision highp float;\n\n\nmat3 rotx(float t){\n    float c= cos(t);\n    float s= sin(t);\n    \n    return mat3(\n        1, 0, 0,\n        0, c,-s,\n        0, s, c\n    );\n}\nmat3 roty(float t){\n    float c= cos(t);\n    float s= sin(t);\n    \n    return mat3(\n         c,0,s,\n         0,1,0,\n    \t-s,0,c\n    );\n}\nmat3 rotz(float t){\n    float c= cos(t);\n    float s= sin(t);\n    \n    return mat3(\n        c,-s,0,\n        s, c,0,\n    \t0, 0,1\n    );\n}\n\nfloat f(vec3 p){\n    p= mod(p,1.)*2.-1.;\n\treturn dot(p,p)-.99;\n}\n\n#define MARCHES 128\nfloat raytrace(vec3 orig, vec3 dir){\n    float a= 0.;\n    vec3 ray= orig;\n    for(int i=0; i!=MARCHES; i++){\n        vec3 osc= sin(vec3(time)*vec3(.25,.5,1.));\n\t\tfloat t= osc.x*osc.y*osc.z*8.;\n        ray+= dir*t;\n        a+= f(ray);\n    }\n    return a;\n}\n\nvec3 subsample(vec2 fc){\n    vec2 res= iResolution.xy;\n    vec2 uv = fc/res;\n    vec2 uvn= uv*2.-1.;\n    uvn.y*= res.y/res.x;\n    \n    vec2 r= (iMouse.xy/iResolution.xy)*PI;\n    \n    r= vec2(-.125,.25)*PI;\n    \n    vec3 d= vec3(uvn*2., 1);\n    d= rotx(-(r.y-PI/2.))*d;\n    d= roty(r.x*2.-PI/2.)*d;\n    d= normalize(d);//its boring without this\n    \n    vec3 ca= vec3(0.);\n    vec3 cb= vec3(1.);\n    \n    float a= raytrace(vec3(0.),d);\n    \n    return mix(ca,cb, a);\n}\n#define SS 3\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 fc = fragCoord;\n    \n    vec3 c= vec3(0);\n    for(int y=0; y!=SS; y++){\n    \tfor(int x=0; x!=SS; x++){\n            c+= subsample(fc + (vec2(x,y)/float(SS)) );\n        }\n    }\n    c/=float(SS*SS);\n    //c= pow(c,vec3(1./2.2));\n    fragColor= vec4(c,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltGfRK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltGfRW", "name": "Yet another Disco 2", "author": "denosya", "description": "Trying randoms things...", "tags": ["disco"], "likes": 0, "viewed": 443, "date": "1542037480", "time_retrieved": "2024-06-20T19:24:29.442485", "image_code": "const float MARBLE_RADIUS  = 0.1075;\nconst float MARBLE_SPACING = 0.5;\n\n\n\nfloat map(in vec3 m, out vec3 normal) {\n    \n    float angle = iTime*0.15;\n    float c = cos(angle);\n    float s = sin(angle);        \n    \n    mat3 sphereMat = mat3(vec3(c, 0.0, s),\n                          vec3(0.0, 1.0, 0.0),\n                          vec3(-s, 0.0, c));\n    \n    vec3 center = vec3(0, 0, -2.5 + cos(iTime*0.5)*1.5 );\n    float radius = 4.0;\n    \n    vec3 v = m - center;\n    \n    v = sphereMat * v;\n    \n    float distToCenter = length(v) - radius;\n    \n    vec3 marbleCenter = floor((v + MARBLE_SPACING*0.5) / MARBLE_SPACING) * MARBLE_SPACING;\n\n    if(length(marbleCenter) > radius - MARBLE_RADIUS*0.5) {\n        return max(distToCenter, MARBLE_SPACING * 0.5);\n    }\n    else {\n        float d = length(v - marbleCenter);\n        normal = normalize(v - marbleCenter);\n        \n        if(d<0.0) return MARBLE_SPACING * 0.75;\n        return d - MARBLE_RADIUS;\n    }\n}\n\n\n\nvec2 getUV(in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    uv -= vec2(0.5, 0.5);    \n    uv.x *= ratio;\n    return uv;\n}\n\n\nfloat raymarch(in vec3 dir, out vec3 m, out vec3 normal) {\n    \n    float mattercrossed = 0.0;\n    \n    for(int i=0; i<100; i++) {\n\t\tfloat d = map(m, normal);        \n \n        if(d > -0.05 && d < 0.05) {\n            mattercrossed += 1.0;\n        }        \n        \n        d = max(d, 0.01);\n        \n        m += dir * d * 0.5;\n    }\n    \n    return mattercrossed;\n}\n\nvec4 lighting(float matter, vec3 m, in vec3 normal) {\n    \n    vec4 color = vec4(cos(m.x), cos(m.y), cos(m.z), 1.0);\n    \n    \n    return color * matter * 0.02;\n}\n\nbool isdot(vec3 m) {\n \t\n    vec3 closest = mod(m, vec3(0.1, 0.1, 0.1));\n\n    float d = length(closest);\n    \n    return d < 0.05;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = getUV(fragCoord);\n\tvec3 dir = normalize(vec3(uv.x, uv.y, -1));\n\n    vec3  m = vec3(0);//cos(iTime*1.0)*1.0, cos(iTime*0.5)*2.5, 0.0);\n    vec3  normal;\n\n    float matter = raymarch(dir, m, normal);\n    \n    if(matter>0.0000000) {\n        \tfragColor = lighting(matter, m, normal);\n    }\n    else {\n\t    fragColor = vec4(0);    \n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltGfRW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltGfz1", "name": "Dreamscape", "author": "WB", "description": "Volumetric clouds with anisotropic single scattering.", "tags": ["raymarching", "clouds"], "likes": 2, "viewed": 126, "date": "1541957276", "time_retrieved": "2024-06-20T19:24:30.393983", "image_code": "#define _FoV 45.0\n#define MAX_STEPS 128\n#define STEP_SIZE 75.0\n#define MAX_OCTAVES 12\n#define MAX_LOOP 256\n\n#define JITTER\n\nconst vec3 _SunPos= vec3(-100.0, 50.0, 1000.0);\nconst vec3 _SunColor = vec3(0.12, 0.10, 0.08);\nconst float _Density = 0.082;\nconst float _Abs = 0.001;\nconst float _Mie = 0.2;\nconst float _G = 0.9;\n\n//Improved Heyney-Greenstein phase function\nfloat cornetteShanksPhase(float mu, float g)\n{\n\tfloat g2 = g * g;\n\treturn (3.0 * (1.0 - g2) * (1.0 + mu * mu)) / (2.0 * (2.0 + g2) * pow(1.0 + g2 - 2.0 * g * mu, 1.5));\n}\n\n//4x4 Bayer matrix for ordered dithering\nconst mat4 _Bayer4x4 = mat4(vec4(0,0.5,0.125,0.625),\n                      \t\tvec4(0.75,0.25,0.875,.375), \n                  \t\t    vec4(0.1875,0.6875,0.0625,0.5625), \n                  \t    \tvec4(0.9375,0.4375,0.8125,0.3125));\n\n//iq's gradient noise\nvec2 hash( vec2 x )\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nvec3 hash( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\n//Fractal (pink) noise function S(f) ‚àù 1/f^Œ±, {0 <= Œ± <=2}\nfloat fbm(vec3 seed, int octaves, float freq, float lac)\n{\n    float val;\n    for (int i = 1; i < MAX_OCTAVES; i++)\n    {\n        if (i > octaves)\n            break;\n        \n        val += noise(seed * freq * float(i)) / (pow(float(i), lac));\n    }\n\n    return val;\n}\n\nfloat sampleVolume(vec3 pos)\n{\n    float n = (fbm(pos, 4, 0.007, 1.5));\n    n = abs(n);\n    float h = (pos.y * pos.y)/256.0;\n    n = max(0.0, n - abs(noise(pos * 0.025) * 1.0/h * 2.0));\n    n = smoothstep(0.2, 1.0, n);\n    return n * _Density * h;\n}\n\n//Radiative transfer approximation\nvec4 bsdf(vec3 pos, vec3 dir, vec3 col, float phase, float ds, int s)\n{    \n    //int steps = int(min(float(s), float(MAX_STEPS)));\n    vec4 result = vec4(col, 1.0);\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        if (i >= s)\n            break;\n        \n        float depth = sampleVolume(pos);\n        \n        //Beer-Lambert Law: T = e^-œÑ, œÑ = Œº‚Ñì\n        float ext = (_Abs + _Mie) * depth;\n        ext = max(ext, 0.0000001);\n        float trans = exp(-ext * ds);\n        trans *= (1.0 - depth * trans);\n        \n        float falloff = -pos.y/1500.0;\n        \n        vec3 lum = _SunColor * falloff * phase * _Mie * depth;\n        vec3 intScatt = (lum - (lum*trans))/ext;\n        \n        result.rgb += intScatt * result.a;\n        result.a *= trans;\n        \n        if (result.a <= 0.02)\n            return result;\n        \n        pos += dir * ds;\n    }\n    \n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Calculate eye vector\n    vec3 rayOrigin = vec3(0.0, 0.0 + sin(iTime) * 10.0, iTime * 1500.0);\n    vec2 uv = fragCoord/iResolution.xy;\n    float ar = iResolution.x/iResolution.y;\n    float d = ar/tan(radians(_FoV/2.0));    \n    vec3 rayDir = normalize(vec3((-1.0 + 2.0 * uv) * vec2(ar, 1.0), d));\n    \n    //Sky color\n    vec4 col = mix(vec4(0.2, 0.1, 0.1, 1.0), vec4(0.5, 0.5, 1.0, 1.0), uv.y -0.2);\n\n    //Assume light rays are parallel for distant source\n    vec3 sunDir = normalize(_SunPos);\n    \n    //Light\n    float sun = dot(sunDir, rayDir);\n    col += smoothstep(0.999,1.0,sun) * vec4(1.0,0.7,0.4,1.0) * 1.25;\n    col += smoothstep(0.975,1.02,sun) * vec4(0.4,0.25,0.2, 1.0);\n       \n    if (uv.y < 0.5)\n    {       \n        //Mie phase approx\n        float mu = dot(sunDir, rayDir);\n        float phase = cornetteShanksPhase(mu, _G);\n            \n        #ifdef JITTER\n        //Bayer matrix ordered depth jittering\n        float width = (uv.x * iResolution.x);\n        float height = (uv.y * iResolution.y);\n        width = mod(width, 4.0);\n        height = mod(height, 4.0);\n        float offset = _Bayer4x4[int(width)][int(height)];\n        rayOrigin += rayDir * offset * STEP_SIZE;\n        #endif\n        \n        //Clouds\n    \tcol = bsdf(rayOrigin, rayDir, col.rgb, phase, STEP_SIZE, 96);\n    }\n    else\n    {\n        //Stars\n        float t = abs(noise(vec2(50.0*uv.x + iTime, uv.y*50.0)));\n        col += t * min(1.0,smoothstep(0.4, 1.0, noise(rayDir * 250.0)) * 8.0);\n    }\n    \n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltGfz1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltGfzV", "name": "Kuiper", "author": "PianiGiani", "description": "Coloured orbs", "tags": ["dots"], "likes": 3, "viewed": 111, "date": "1543175276", "time_retrieved": "2024-06-20T19:24:30.393983", "image_code": "#define S(a,b,t) smoothstep(a,b,t)\n#define nTime (iTime+9000.)/12.\n\nfloat DDot(vec2 p1,vec2 p2, float blr) {\n    return 1.-(distance(p1,p2)*blr);\n}\n    \n\nfloat N21(vec2 p)\n{\t// Dave Hoskins - https://www.shadertoy.com/view/4djSRW\n\tvec3 p3  = fract(vec3(p.xyx) * vec3(443.897, 441.423, 437.195));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n\tvec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col=vec3(0.,0.,0.);\n    vec3 colmask;\n    vec2 pos;\n    \n    //rotate screen (from Martijn Steinrucken aka BigWings)\n    float s = sin(nTime);\n    float c = cos(nTime);\n    uv*=mat2(c, -s, s, c);             \n    \n    for(float i=1.0;i<=350.;i++)\n    {\n    \tfloat t=N21(vec2(i,i));\n        float tt=N21(vec2(i+i,i+9.));\n    \tpos = vec2(sin(nTime+i*t)+tt, cos(nTime+i)+tt);\n        float blur=300.-(180.*(sin(nTime*tt)+0.5));\n             \n    \t// blob colour\n        float cc=N21(vec2(i+2.,i+3.));\n    \tcolmask=vec3(1.+sin(iTime*t)/2.,1.+sin(iTime*cc)/2.,1.+cos(iTime)/2.);\n        col=max(colmask*vec3(DDot(uv,pos,blur)),col);\n        col=max(colmask*vec3(DDot(uv,pos*vec2(-1.,1.),blur)),col);\n        col=max(colmask*vec3(DDot(uv,pos*vec2(-1.,-1.),blur)),col);\n        col=max(colmask*vec3(DDot(uv,pos*vec2(1.,-1.),blur)),col);\n    }\n    \n    fragColor = vec4(col,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltGfzV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltKBDD", "name": "Cool shader", "author": "paulo69", "description": "Because I didn't have anything else to do :D\nPS : it is inspired by a tutorial from The Art of Code !\n", "tags": ["procedural", "flower", "shader", "polarcoordinates", "equation", "maths"], "likes": 4, "viewed": 122, "date": "1542650675", "time_retrieved": "2024-06-20T19:24:30.393983", "image_code": "#define PI 3.1415\nvoid mainImage( out vec4 col, in vec2 p )\n{\n    vec2 uv = (p.xy-0.5*iResolution.xy)/iResolution.y;\n    vec2 coord = uv;\n    vec2 cp = vec2 (atan(uv.x,uv.y),length(uv));\n    uv = vec2(cp.x/(2.0*PI)+0.5+iTime*0.1+cp.y*cos(iTime)*0.15,cp.y);\n    col = vec4(abs(vec4(smoothstep(0.45,0.45+sin(iTime),length(coord)))*vec4(1.0,2.0,0.9,1.0))+smoothstep(0.0,max(-iTime+5.0,0.21),min(fract(uv.x*8.0),fract(1.0-uv.x*8.0))*0.5+0.2-uv.y)*vec4(5.0,normalize(length(cp*PI))*.8,normalize(length(cp*5.0*PI))*0.4,1.0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltKBDD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lttfW2", "name": "Fibonacci's Fractal Flower", "author": "dr2", "description": "Fractal-like extension of \"Fibonacci's Cones\" following idea in iq's \"Planet Fall\" (mouseable)", "tags": ["fractal", "raymarch", "flower", "fibonacci"], "likes": 1, "viewed": 554, "date": "1541152520", "time_retrieved": "2024-06-20T19:24:31.486481", "image_code": "// \"Fibonacci's Fractal Flower\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCapsDf (vec3 p, float r, float h);\nvec3 HueToRgb (float c);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec3 RotToDir (vec3 v1, vec3 v2, vec3 p);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Hashff (float p);\n\nvec3 ltDir;\nfloat dstFar, tCur, sclVar, qHue;\nvec2 sRot;\nint qLev;\nconst int nLev = 3;\nconst float pi = 3.14159, phi = 1.618034;\n\nvec4 SphFib (vec3 v, float n)\n{   // Keinert et al's inverse spherical Fibonacci mapping\n  vec4 b;\n  vec3 vf, vfMin;\n  vec2 ff, c;\n  float fk, ddMin, dd, a, aMin, z, ni;\n  ni = 1. / n;\n  fk = pow (phi, max (2., floor (log (n * pi * sqrt (5.) * dot (v.xy, v.xy)) /\n     log (phi + 1.)))) / sqrt (5.);\n  ff = vec2 (floor (fk + 0.5), floor (fk * phi + 0.5));\n  b = vec4 (ff * ni, pi * (fract ((ff + 1.) * phi) - (phi - 1.)));\n  c = floor ((0.5 * mat2 (b.y, - b.x, b.w, - b.z) / (b.y * b.z - b.x * b.w)) *\n     vec2 (atan (v.y, v.x), v.z - (1. - ni)));\n  ddMin = 4.1;\n  for (int j = 0; j < 4; j ++) {\n    a = dot (ff, vec2 (j - 2 * (j / 2), j / 2) + c);\n    z = 1. - (2. * a + 1.) * ni;\n    vf = vec3 (sin (2. * pi * fract (phi * a) + vec2 (0.5 * pi, 0.)) * sqrt (1. - z * z), z);\n    dd = dot (vf - v, vf - v);\n    if (dd < ddMin) {\n      ddMin = dd;\n      vfMin = vf;\n      aMin = a;\n    }\n  }\n  return vec4 (aMin, vfMin);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec4 f4;\n  vec3 pn;\n  float dMin, d, sTot, s, t;\n  dMin = PrSphDf (p, 2.1);\n  if (dMin < 0.05) {\n    p.xz = Rot2Cs (p.xz, sRot);\n    t = length (p);\n    pn = p / t;\n    f4 = SphFib (pn, 512.);\n    dMin = t - 1.1 + 0.1 * smoothstep (0.05, 0.15, length (pn - f4.yzw));\n    qLev = 0;\n    qHue = 0.1;\n    sTot = 1.;\n    for (int j = 0; j < nLev; j ++) {\n      if (j > 0) {\n        p.z -= 3.;\n        f4 = SphFib (normalize (p), 128.);\n      }\n      s = sclVar + 2. * Hashff (31. * f4.x);\n      p = s * vec3 (1.3, 1.3, 1.) * RotToDir (f4.yzw, vec3 (0., 0., 1.), p - f4.yzw);\n      sTot /= s;\n      d = sTot * PrCapsDf (p, 0.3, 3.);\n      if (d < dMin) {\n        dMin = d;\n        qLev = j + 1;\n        t = 0.5 * Hashff (41. * f4.x);\n        if (j == 0) qHue = 0.1 + t;\n        else qHue += (1. - (float (j) / float (nLev))) * t;\n      }\n    }\n    dMin *= 0.3;\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 250; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstObj, s;\n  sRot = sin (0.1 * pi * (floor (0.2 * tCur) + smoothstep (0., 0.2, mod (0.2 * tCur, 1.))) +\n     vec2 (0.5 * pi, 0.));\n  sclVar = 38. - 29. * SmoothBump (0.18, 0.75, 0.15, mod (0.05 * tCur, 1.));\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    s = float (qLev) / float (nLev);\n    col = HueToRgb (mod (qHue, 1.)) * (0.2 + 0.8 * s) * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +\n      0.5 * s * pow (max (dot (normalize (ltDir - rd), vn), 0.), 64.);\n  } else col = mix (vec3 (1., 1., 0.5), vec3 (0., 0., 0.3 * (0.7 + 0.3 * rd.y)),\n     smoothstep (0.0035, 0.004, length (SphFib (rd, 8192.).yzw - rd)));\n  return col;\n}\n\n#define AA  0\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.;\n  zmFac = 5.;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n    zmFac += 15. * abs (mPtr.x);\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 0., -8.);\n  dstFar = 15.;\n  ltDir = vuMat * normalize (vec3 (0.5, 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 4.;\n#endif  \n  col = vec3 (0.);\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.71 / canvas.y, 0.),\n       0.5 * pi * (a + 0.5)), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (pow (col, vec3 (0.7)), 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nvec3 HueToRgb (float c)\n{\n  return clamp (abs (fract (c + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec3 RotToDir (vec3 v1, vec3 v2, vec3 p)\n{\n  vec3 n;\n  float c;\n  n = normalize (cross (v1, v2));\n  c = dot (v1, v2);\n  return c * p + sqrt (1. - c * c) * cross (n, p) + (1. - c) * dot (n, p) * n;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lttfW2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltVBRc", "name": "rotation of mandelbrot", "author": "CynicRus", "description": "Just experiment", "tags": ["fractal", "mandelbrot", "rotate"], "likes": 18, "viewed": 487, "date": "1543498766", "time_retrieved": "2024-06-20T19:24:31.751694", "image_code": "#define maxiter 250\n#define m1 1.0\n#define m2 0.9\n#define r1 0.5\n#define r2 0.5\n#define v1 0.5\n#define v2 0.95\n\nvoid rotate (inout vec2 vertex, float rads)\n{\n  mat2 tmat = mat2(cos(rads), -sin(rads),\n                   sin(rads), cos(rads));\n \n  vertex.xy = vertex.xy * tmat;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord - .5*iResolution.xy ) / iResolution.y;\n    rotate(uv,0.35 * iTime);\n    vec2 z = vec2(0.0, 0.0);\n\tfloat p = 0.0;\n\tfloat dist = 0.0;\n\tfloat x1 = tan(iTime*v1)*r1;\n\tfloat y1 = sin(iTime*v1)*r1;\n\tfloat x2 = tan(iTime*v2)*r2;\n\tfloat y2 = sin(iTime*v2)*r2;\n\tfor (int i=0; i<maxiter; ++i)\n\t{\n\t\tz *= 2.0;\n\t\tz = mat2(z,-z.y,z.x) * z + uv;\n\t\tp = m1/sqrt((z.x-x1)*(z.x-x1)+(z.y-y1)*(z.y-y1))+m2/sqrt((z.x-x2)*(z.x-x2)+(z.y-y2)*(z.y-y2));\n\t\tdist = max(dist,p);\n\n\t}\n\tdist *= 0.0099;\n\tfragColor = vec4(dist/0.3, dist*dist/0.03, dist/0.112, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltVBRc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltyBRz", "name": "fractal experiment", "author": "conan777", "description": "A first experiment with 3d fractals bases on iq's wonderful work 'Apollonian', as well as many others here on shadertoy =)", "tags": ["fractals"], "likes": 9, "viewed": 595, "date": "1542315674", "time_retrieved": "2024-06-20T19:24:31.751694", "image_code": "//#version 400 core\n\nvec4 orb;\n\nfloat map(vec3 p, float s)\n{\n\tfloat scale = 1.0;\n\torb = vec4(100.0);\n\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tp = -1.0 + 2.0 * fract(0.5 * p + 0.5);\n\t\tfloat r2 = dot(p, p);\n        orb = min(orb, vec4(abs(p), r2));\n\n\t\tfloat k = s / r2;\n\t\tp *= k;\n\t\tscale *= k;\n\t}\n\treturn 0.25 * (abs(p.x) + abs(p.y)) / scale;\n}\n\nfloat trace( in vec3 ro, in vec3 rd, float s )\n{\n\tfloat maxd = 30.0;\n    float t = 0.01;\n    for (int i = 0; i < 150; i++)\n    {\n\t    float precis = 0.001 * t;\n\n\t    float h = map(ro + rd * t, s);\n        if (h < precis || t > maxd)\n            break;\n        t += h;\n    }\n    if (t > maxd)\n        t = -1.0;\n    return t;\n}\n\nvec3 calcNormal( in vec3 pos, in float t, in float s )\n{\n    float precis = 0.001 * t;\n\n    vec2 e = vec2(1.0,-1.0) * precis;\n    return normalize(e.xyy * map(pos + e.xyy, s) +\n\t\t\t\t\t e.yyx * map(pos + e.yyx, s) +\n\t\t\t\t\t e.yxy * map(pos + e.yxy, s) +\n                     e.xxx * map(pos + e.xxx, s));\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in float anim )\n{\n    vec3 col = vec3(0.0);\n    float t = trace(ro, rd, anim);\n    if (t > 0.0)\n    {\n        vec4 tra = orb;\n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal(pos, t, anim);\n        vec3  light = vec3(0.5, 0.5, 0.5);\n        float key = clamp(dot(light, nor), 0.0, 1.0);\n        vec3 brdf = vec3(0.30, 0.20, 0.10) + vec3(1.00, 0.40, 0.00) * key;\n        vec3 rgb = vec3(1.0);\n        rgb = mix(rgb, vec3(0.90, 0.20, 0.20), clamp(10.0 * tra.y, 0.0, 1.0));\n        col = rgb * brdf * exp(-0.2 * t);\n    }\n    return sqrt(col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    \n    vec2 uv = (fragCoord.xy - iResolution.xy/2.0) / max(iResolution.xy.x, iResolution.xy.y);\n \n    float anim = (sin(iTime * 0.2) + 1.0) * 0.6;\n    vec3 tot = vec3(0.0);\n    vec3 ro;\n    ro = vec3(1.0, 5.0, 5.0);\n    vec3 tmp = vec3(uv, 1.0);\n    vec3 rd = -normalize(tmp);\n    tot += render(ro, rd, anim);\n\tfragColor = vec4(tot, 1.0);\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    float time = iTime*0.25;\n    float anim = (sin(iTime * 0.2) + 1.0) * 0.6;\n\n    vec3 col = render( fragRayOri + vec3(0.0,1.0,2.5), fragRayDir, anim);\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltyBRz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltyBWw", "name": "ShaderSupo1", "author": "Jacko1222", "description": "effect1", "tags": ["effect"], "likes": 2, "viewed": 65, "date": "1542718667", "time_retrieved": "2024-06-20T19:24:31.897213", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(min(1.0, sin(iTime-0.5)*uv.y*3.0), min(1.0, -sin(iTime)*uv.y*3.0), min(1.0, (cos(iTime)+sin(iTime))*uv.x*uv.y)); \n\n    // Time varying pixel color\n    if ((1.0-sin(uv.x*40000.0+iTime) < uv.y)){\n    \tcol = vec3(0);\n    }\n    //vec3 col = uv.xyx * vec3(pow(1.5, 3.0 + 2.5*cos(iTime)));\n        \n        //0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltyBWw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltyBzK", "name": "noise mountain", "author": "ukeyshima", "description": "noiseMountain", "tags": ["noise"], "likes": 8, "viewed": 201, "date": "1543146564", "time_retrieved": "2024-06-20T19:24:31.897213", "image_code": "float random(vec3 p){\n    return fract(sin(dot(p.xyz,vec3(12.9898,0.0,78.233)))*36.253);\n}\nfloat valueNoise(vec3 p){\n    vec3 i=vec3(floor(p.x),p.y,floor(p.z));\n    vec3 f=vec3(fract(p.x),p.y,fract(p.z));\n    float f1=random(i);\n    float f2=random(i+vec3(1.0,0.0,0.0));\n    float f3=random(i+vec3(0.0,0.0,1.0));\n    float f4=random(i+vec3(1.0,0.0,1.0));\n    // f=smoothstep(0.0,1.0,f);\n    f=f*f*(3.0-2.0*f);\n    return (f1*(1.0-f.x)+f2*f.x)*(1.0-f.z)+(f3*(1.0-f.x)+f4*f.x)*f.z;\n}\nfloat octaveValueNoise(vec3 p){\nfloat value=0.0;\nfloat maxValue=0.0;\nfor(float i=0.0;i<9.0;i++){\n    value+=pow(0.5,i)*valueNoise(vec3(p.x*pow(2.0,i),p.y,p.z*pow(2.0,i)));\n    maxValue+=pow(0.5,i);\n}\nreturn value/maxValue;\n}\n\nfloat mountainDistFunc(vec3 p){\n    vec3 pos=vec3(0.0,1.0,0.0);\n    vec3 n=normalize(pos);\n   return dot(p,n)/5.0+octaveValueNoise(p)/3.0;\n}\n\nfloat distFunc(vec3 p){\n    float obj1;\n    obj1=mountainDistFunc(p);\n    return obj1;\n}\n\nvec3 genNormal(vec3 p){\n    float d=0.001;\n    return normalize(vec3(\n        distFunc(p+vec3(d,0.0,0.0))-distFunc(p+vec3(-d,0.0,0.0)),\n        distFunc(p+vec3(0.0,d,0.0))-distFunc(p+vec3(0.0,-d,0.0)),\n        distFunc(p+vec3(0.0,0.0,d))-distFunc(p+vec3(0.0,0.0,-d))\n        ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 p = (fragCoord.xy*2.0 - iResolution.xy) / min(iResolution.x,iResolution.y);   \n    p*=5.0; \n    vec3 lightPos=vec3(30.0,30.0,0.0);\n    vec3 ambientColor=vec3(0.1);\n    vec3 cPos=vec3(0.0,0.0,10.0-iTime/3.0);\n    vec3 cDir=vec3(0.0,-0.5,-1.0);\n    vec3 cUp=vec3(0.0,1.0,0.0);\n    vec3 cSide=cross(cDir,cUp);    \n    float targetDepth=1.0;\n    vec3 ray=normalize(cSide*p.x+cUp*p.y+cDir*targetDepth);\n    float distance=0.0;\n    float rLen=0.0;\n    vec3 rPos=cPos;\n    vec3 color=vec3(242.0/255.0,242.0/255.0,232.0/255.0);\n    float maxDist=100.0;\n    for(int i=0;i<70;i++){\n        distance=distFunc(rPos);\n        if(abs(distance)<0.09){\n            color=vec3(octaveValueNoise(vec3(rPos.x,0.0,0.0)),octaveValueNoise(vec3(rPos.x,0.0,rPos.z)),octaveValueNoise(vec3(0.0,0.0,rPos.z)));\n            vec3 normal=genNormal(rPos);\n            color=color*vec3(clamp(dot(lightPos,normal),0.0,1.0))+ambientColor+rLen/30.0;\n            break;\n        }\n        rLen+=distance;\n        rPos=cPos+ray*rLen;\n        if(rLen>maxDist){\n            break;\n        }\n    }    \n    fragColor=vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltyBzK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltyfDm", "name": "Shadowland", "author": "Plento", "description": "Finally started learning ray marched shadows and AO. I learned most of it from Iq's website and a handful of Shane's shaders. I learned how to use it from https://www.shadertoy.com/view/4dt3zn His comments are really useful.", "tags": ["3d", "raymarch", "sdf", "shadows", "occlusion", "ambient"], "likes": 20, "viewed": 739, "date": "1542848855", "time_retrieved": "2024-06-20T19:24:33.279321", "image_code": "\n// LOOKS BEST IN FULLSCREEN\n\n// raymarching defines\n#define FAR 100.0\n#define DISTANCE_BIAS 0.75\n#define EPSILON 0.0001\n\n\n\n// part of the edge detection which I learned here by nimitz: https://www.shadertoy.com/view/4s2XRd\n// I had a similar approach before, but this method looks better.\n#define EDGE_SIZE 0.022\n#define SMOOTH 0.02\n#define SIZE 0.9\n\n// sdf subtraction from Iq's website\nfloat opSub( float d1, float d2 ) { return max(-d1,d2); }\n\n// normalized mouse coords\nvec2 m(){\n    vec2 m = iMouse.xy / iResolution.xy-.5; \n    m.x *= iResolution.x/iResolution.y;\n\treturn m;\n}\n\n// Noise and rand found everywhere on shadertoy\nfloat rand(vec2 n){ \n\treturn fract(sin(dot(n, vec2(17.12037, 5.71713))) * 12345.6789);\n}\n\nfloat noise(vec2 n){\n\tvec2 d = vec2(0.0, 1.0);\n\tvec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b + d.xx), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nfloat map(vec3 rp)\n{\n    // sphere pos\n    vec3 pos = rp - vec3(1.0, -1.0, 0.0); \n    \n    pos.z -= 0.035;\n    \n    // movements\n    pos.x += iTime * 0.5;\n    pos.y -= m().y*8.0;\n    pos.x -= m().x*8.0;\n    \n    // repeat coordinates\n    pos = mod(pos, vec3(2))-0.5 * vec3(2);\n    \n    // Endless filled space that starts in front of the camera \n    float res = 2.00001 - rp.z;\n    \n    // subtract from the space using spheres\n    res = opSub(length(pos) - 1.33, res);\n   \n    return res;\n}\n\n// Got this from one of Shane's shaders. So fun to play with\nfloat softShadow(vec3 ro, vec3 lp, float k)\n{\n    const int maxIterationsShad = 32; \n    \n    vec3 rd = (lp-ro); \n\n    float shade = 1.;\n    float dist = .005;    \n    float end = max(length(rd), 0.001);\n\n    \n    rd /= end;\n\n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n       \n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); \n       \n        dist += clamp(h, .02, .2);\n        \n       \n        if (h<0.0 || dist > end) break; \n       \n    }\n\n   \n    return min(max(shade, 0.) + 0.03, 1.0); \n}\n\n\nvec3 getNormal(in vec3 p) {\n\tconst vec2 e = vec2(0.002, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n// Directly from Iq's site: http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1. );    \n}\n\n\n\n\n    \n \n// A mixture of techniques here that Iv'e seen used by Iq and Shane\nvec3 color(vec3 ro, vec3 rd, vec3 norm, vec3 lp, float t, float md)\n{\n    \n    \n    vec3 p = ro + rd * t; // hit location\n    \n    // Lighting\n    vec3 ld = lp-ro;\n    float lDist = max(length(ld), 0.001); // Light to surface distance.\n    float atten = 2.0 / (1.0 + lDist*0.2 + lDist*lDist*0.1); // light attenuation \n    ld /= lDist;\n    \n    \n    float diff = max(dot(norm, ld), 0.0); // diffuse\n    float spec = pow(max( dot( reflect(-ld, norm), -rd ), 0.0 ), 12.0); // specular\n    \n    float occ = calcAO( ro + rd, norm )*1.0; // get AO \n    \n    float amb = clamp( 0.5 + 0.5 * norm.y, 0.0, 1.0 ); // ambient\n    float fre = pow( clamp(1.0 + dot(norm,rd),0.0,1.0), 2.0 ); // fresnel\n    // \n    \n    \n    \n    vec3 lf = vec3(0.0); // light color\n    \n    // adding all the light terms\n    lf += 1.0 * amb * vec3(0.5,0.5,0.5) * occ;\n    lf += 2.0 * fre * vec3(0.7,0.5,0.0) * occ;\n    lf += diff + 0.5;\n    \n    // moving the hit location with the geometry. Im sure I'll figure out a better way\n    p.x += iTime;  \n    p.y -= m().y*16.0;\n    p.x -= m().x*16.0;\n        \n    float nn = noise(p.xy*5.0); // some noise\n    \n    // pink blue pattern\n    vec3 col = vec3(sin(nn*10.0), cos(nn * 10.0), 1.0) * 0.9;\n    \n    // simply colors the scene yellow if the z normal if below a threshold. quick and easy\n    // but probably not sustainable \n    if(norm.x != 0.0 && p.z < 4.1)\n        col = vec3(1.0, 1.0, 0.0);\n           \n    // apply lighting to main color \n    col *= lf;\n    \n    // some additional lighting / coloring \n    col  = (col*(diff + 0.7) + vec3(1.0, 0.6, 0.5)*spec*0.2);\n    \n    // apply attenuation\n    col *= atten;\n    \n    // adds a little more detail to texture\n    col *= clamp(noise(p.xy*52.0), 0.3, 1.0) * 1.4;\n    col *= 0.8;\n    return col;\n    \n}\n\n\n\nvec2 trace(vec3 ro, vec3 rd)\n{\n    float t = 0.0; // total distance\n    float d = 0.0; // distance to nearest object\n    \n    float md = 999.0; \n    \n    float h = EPSILON; \n  \n    vec2 dd = vec2(0.,10000.);\n    \n    bool stp = false;\n    \n    for (int i = 0; i < 64; i++) \n    {\n        d = map(ro + rd*t); // get distance to nearest object\n        \n        if(abs(d)<EPSILON || t > FAR) {break;} // hit object or went too far\n        \n        \n        // Part of the edge detection. Basically checks if we are within the set edge bounds \n        // of the object the ray is passing\n        if (stp == false) \n        {\n            md = min(md,d); // get current minimum distance\n            \n            if (h < EDGE_SIZE && h < d && i > 0)\n            {\n                stp = true;\n                dd.y = dd.x;\n            }\n        }\n        \n         h = d;\n        \n        t += d * DISTANCE_BIAS;\n        \n    }\n    \n    if (stp) md = smoothstep(EDGE_SIZE-SMOOTH, EDGE_SIZE+SIZE, md);\n    else md = 1.0;\n    \n    return vec2(t, md );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y; \n \n    vec3 ro = vec3(0.0, 0.0, 0.0); \n \n    // fish eyed ray direction vector because this thing isnt a sphere haha fooled you\n     vec3 rd = normalize(vec3(uv, 1.0 - dot(uv, uv) * 0.35));\n    \n   \n    // light position. Fun to play with. bottom one looks pretty cool because the light goes\n    // in the ball\n    vec3 lp = ro + vec3(0.8, 0.7, 0.0);\n    //vec3 lp = ro + vec3(1.0, 0.7, sin(iTime) * 3.0);\n    \n    // Distance to scene object and minimum distance \n    //to an object if nothing was hit\n    vec2 t = trace(ro, rd); \n    \t\t\t\t\t\t\n    // set the ray origin location to the hit location\n    ro += rd * t.x; \n    \n    // normals of hit object\n    vec3 norm = getNormal(ro); \n    \n    // shadows\n    float sh = softShadow(ro, lp, 120.); \n    \n    // color the scene...except for fog and\n    // edge outline which happens below\n    vec3 col = color(ro, rd, norm, lp, t.x, t.y); \n    \t\t\t\t\t\t\t\t\t\t\t\t\n    \n    vec3 fogCol = vec3(0.0, 0.0, 0.0);\n    \n    col *= sh; // apply shadows to scene\n        \n   \n    col *= mix(t.y,1.0, smoothstep(44.0,45.0,t.x)); // apply the edge outline\n    \n    col = mix( col, vec3(0), 1.0 - exp( -0.0036*t.x*t.x*t.x )); // some fog\n    \n   \n    fragColor = vec4(sqrt(clamp(col, 0.0, 1.0)), 1.0);\n \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltyfDm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltyfz1", "name": "Raymarch anything (twist)", "author": "Del", "description": "twisted :)", "tags": ["raymarch", "anything"], "likes": 9, "viewed": 491, "date": "1541785387", "time_retrieved": "2024-06-20T19:24:33.285119", "image_code": "// you can literally raymarch anything :)\nfloat Turb(vec2 p)\n{\n\tp*=0.25;\n\tp.x *= 0.7;\n\tfloat ti = iTime*0.125;\n\tp.y += ti;\n\tvec2 i = p;\n\t\n\tfloat c = -0.1;\n\tfloat inten = 0.15;\n\tfloat r = length(p+vec2(sin(ti),sin(ti*0.433))*2.);\n\t\n\tfor (float n = 0.0; n < 4.0; n+=1.0)\n\t{\n\t\tfloat t = r-ti * (1.0 - (1.9 / (n+1.)));\n\t\t      t = r-ti/(n+0.6);\n\t\ti -= p.yx + vec2(\n\t\t\tcos(t*0.1 - i.x-r) + sin(t*0.1 + i.y), \n\t\t\tsin(t*0.7 - i.y) + cos(t*0.4 + i.x)+r\n\t\t);\n\t\tc += 1.0/length(vec2(\n\t\t\t(sin(i.x+t)/inten),\n\t\t\t(cos(i.y+t)/inten)\n\t\t\t)\n\t\t);\n\t}\n\tc = smoothstep(0.0,1.0,c*0.75);\n\treturn c * 0.3;\n}\n\nmat2 rotate(float a)\n{\n\tfloat c = cos(a),\n\t\ts = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\n\n\nfloat map(vec3 p)\n{\n\tp.xy *= rotate(p.z * .07 + iTime * .2);\n    \n\tp.x + sin(p.z+iTime)*0.5;\n\tp.x *= sign(p.y);\t// mirror top->bottom\n\tfloat k = Turb(p.xz);\n\treturn sin((iTime*3.0)+p.z*0.25)+8.5 -abs(p.y) - k;\n}\n\nvec3 normal(vec3 p) {\n\tvec2 e = vec2(.001, 0.);\n\tvec3 n;\n\tn.x = map(p + e.xyy) - map(p - e.xyy);\n\tn.y = map(p + e.yxy) - map(p - e.yxy);\n\tn.z = map(p + e.yyx) - map(p - e.yyx);\n\treturn normalize(n);\n}\n\nvec3 render(vec2 uv)\n{\n\tvec3 ro = vec3(sin(iTime)*0.25, cos(iTime)*0.25, iTime*0.75);\n\tvec3 rd = normalize(vec3(uv, .5));\n\tvec3 p = vec3(0.);\n\tfloat t = 0.;\n\tfor (int i = 0; i < 80; i++)\n    {\n\t\tp = ro + rd * t;\n\t\tfloat d = map(p);\n\t\tif (d < .001 || t > 100.) break;\n\t\tt += .5 * d;\n\t}\n\tvec3 l = ro;\n\tvec3 n = normal(p);\n\tvec3 lp = normalize(l - p);\n\tfloat diff = .7 * max(dot(lp, n), 0.);\n\treturn vec3(diff*0.54,diff*2.8,diff*1.85) / (1. + t * t * .01);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 col = render(uv);\n\tfragColor = vec4(col, 1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltyfz1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdtBDn", "name": "Progress from bot to top", "author": "vitsky", "description": "Progress from bot to top", "tags": ["progress"], "likes": 2, "viewed": 333, "date": "1543417052", "time_retrieved": "2024-06-20T19:24:33.285119", "image_code": "#define HALF_PI 1.57079632679\n#define PI      3.14159265359\n\nfloat hash(float x)\n{\n    return fract(sin(x) * 43758.5453) * 2.0 - 1.0;\n}\n\nfloat sineInOut(float t)\n{\n  return -0.5 * (cos(PI * t) - 1.0);\n}\n\nconst float speed = 1.00;\nconst float duration = 2.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2  uv = 2.0 * vec2(fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;   \n    \n    float sequence = floor(iTime / duration);\n    float current_time = mod(iTime, duration);\n    float start = -1.0;\n    float end   = 1.0;\n    float pos = 0.0;      \n    float dist = speed * current_time;\n    float goal = abs(end - start);\n    \n    if (dist <= goal) \n    {\n        pos = mix(start, end, sineInOut(dist / goal));\n    } \n    else \n    {\n        pos = end;\n    }\n    \n    float f = step(uv.y, pos);\n        \n    fragColor = vec4(f);\n}\n\n\n    \n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdtBDn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MlcBWl", "name": "Solidtux Rainbow Tunnel", "author": "SolidTux", "description": "Rainbow Tunnel", "tags": ["tunnel"], "likes": 4, "viewed": 624, "date": "1541453811", "time_retrieved": "2024-06-20T19:24:34.200366", "image_code": "\n\n#define TIME mod(iTime, float(20.425))\n\nprecision highp float;\n\nconst float MIN_DEPTH = float(1);\nconst float MAX_DEPTH = float(40);\nconst int MAX_ITER = 600;\nconst float EPS = float(0.01);\nconst float SHADOW = float(0);\nconst float SHADOW_EPS = float(0.01);\nconst float SHADOW_DEPTH = float(2);\nconst float SHADOW_SMOOTH = float(15);\nconst float PI = 3.14159265359;\nconst float KEYFRAME_0 = float(0);\nconst float KEYFRAME_1 = float(5);\nconst float KEYFRAME_2 = float(6);\nconst float KEYFRAME_3 = float(15);\nconst float KEYFRAME_4 = float(20);\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\nstruct RayResult {\n    float depth;\n    int object;\n    vec3 norm;\n};\nstruct SdfResult {\n    float distance;\n    vec3 pos;\n    vec2 uv;\n    int object;\n};\nstruct Camera {\n    vec3 position;\n    vec3 target;\n    vec3 up;\n    float zoom;\n};\nfloat rand(float n){\n    return fract(sin(n) * 43758.5453123);\n}\nvec2 norm_coord(in vec2 coord, in vec2 res) {\n    vec2 uv = coord.xy/res.xy;\n    uv = 2.*uv - 1.;\n    if (res.x > res.y) {\n        uv.x *= res.x/res.y;\n    } else {\n        uv.y *= res.y/res.x;\n    }\n    return uv;\n}\nvec3 ray_direction(in Camera cam, in vec2 coord, in vec2 res) {\n    vec2 uv = norm_coord(coord, res);\n    vec3 dir = normalize(cam.target - cam.position);\n    vec3 right = normalize(cross(dir, cam.up));\n    vec3 u = normalize(cross(right, dir));\n    vec3 target = cam.position + normalize(dir)/cam.zoom + uv.x*right + uv.y*u;\n    return normalize(target - cam.position);\n}\nRay get_ray(in Camera cam, in vec2 coord, in vec2 res) {\n    return Ray(cam.position, ray_direction(cam, coord, res));\n}\nvec2 sphere_map(in vec3 pos) {\n    // TODO\n    return vec2(0.);\n}\nfloat box(vec3 p, vec3 b) {\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\nSdfResult sdf_union(in SdfResult a, in SdfResult b) {\n    if (a.distance < b.distance) {\n        return a;\n    } else {\n        return b;\n    }\n}\nmat3 rotx(in float a) {\n    return mat3(\n            1., 0., 0.,\n            0., cos(a), -sin(a),\n            0., sin(a), cos(a)\n            );\n}\nmat3 roty(in float a) {\n    return mat3(\n            cos(a), 0., -sin(a),\n            0., 1., 0.,\n            sin(a), 0., cos(a)\n            );\n}\nmat3 rotz(in float a) {\n    return mat3(\n            cos(a), -sin(a), 0.,\n            sin(a), cos(a), 0.,\n            0., 0., 1.\n            );\n}\nSdfResult sdf(in vec3 pos) {\n    SdfResult res = SdfResult(MAX_DEPTH, vec3(0.), vec2(0.), -1);\n    vec3 p = pos;\n    \n    p.xz = vec2(atan(p.x, p.z), length(p.xz) - 2.7 + 0.5*(exp(-TIME*0.1) + exp((TIME - 20.425)*0.1))*sin(0.5*p.y));\n    p.y -= 5.*(TIME - 11.);\n    p.xy = mod(p.xy, vec2(0.3, 3.));\n    p.y += p.x;\n    res = SdfResult(box(p, vec3(float(0.35), float(0.2), float(2))), p, vec2(0., 0.), 0);\n    return res;\n}\nvec3 norm(in vec3 p) {\n    return normalize(vec3(\n        sdf(vec3(p.x + EPS, p.y, p.z)).distance - sdf(vec3(p.x - EPS, p.y, p.z)).distance,\n        sdf(vec3(p.x, p.y + EPS, p.z)).distance - sdf(vec3(p.x, p.y - EPS, p.z)).distance,\n        sdf(vec3(p.x, p.y, p.z + EPS)).distance - sdf(vec3(p.x, p.y, p.z - EPS)).distance\n    ));\n}\nRayResult raymarcher(in Ray ray) {\n    float depth = MIN_DEPTH;\n    for (int i=0; i<MAX_ITER; i++) {\n        vec3 pos = ray.origin + depth*ray.direction;\n        SdfResult res = sdf(pos);\n        if (res.distance < EPS) {\n            return RayResult(depth, res.object, norm(pos));\n        }\n        depth += res.distance;\n        if (depth > MAX_DEPTH) {\n            return RayResult(MAX_DEPTH, -1, vec3(0.));\n        }\n    }\n    return RayResult(MAX_DEPTH, -1, vec3(0.));\n}\nfloat lightmarch(in Ray ray, in float maxd, in float k) {\n    float depth = 0.;\n    float r = 1.;\n    for (int i=0; i<MAX_ITER; i++) {\n        vec3 pos = ray.origin + depth*ray.direction;\n        SdfResult res = sdf(pos);\n        if (res.distance < SHADOW_EPS) {\n            return 0.;\n        }\n        r = min(r, k*res.distance/depth);\n        depth += res.distance;\n        if (depth >= (maxd - SHADOW_DEPTH)) {\n            return r;\n        }\n    }\n    return r;\n}\nvec4 color(in vec2 coord, in vec2 resolution) {\n    Camera cam = Camera(mix(mix(mix(mix(vec3(float(0), float(0), float(40)), vec3(float(0), float(5), float(0)), smoothstep(KEYFRAME_0, KEYFRAME_1, TIME)), vec3(float(0), float(5), float(0)), smoothstep(KEYFRAME_1, KEYFRAME_2, TIME)), vec3(float(0), float(5), float(0)), smoothstep(KEYFRAME_2, KEYFRAME_3, TIME)), vec3(float(0), float(0), float(40)), smoothstep(KEYFRAME_3, KEYFRAME_4, TIME)), vec3(float(0.1), float(0), float(0)), mix(mix(mix(mix(vec3(float(0), float(1), float(0)), vec3(float(1), float(5), float(0)), smoothstep(KEYFRAME_0, KEYFRAME_1, TIME)), vec3(cos(0.75*sin(TIME - 11.)), 0., sin(0.75*sin(TIME - 11.))), smoothstep(KEYFRAME_1, KEYFRAME_2, TIME)), vec3(cos(0.75*sin(TIME - 11.)), 0., sin(0.75*sin(TIME - 11.))), smoothstep(KEYFRAME_2, KEYFRAME_3, TIME)), vec3(float(0), float(1), float(0)), smoothstep(KEYFRAME_3, KEYFRAME_4, TIME)), float(0.4));\n    Ray ray = get_ray(cam, coord, resolution);\n    RayResult res = raymarcher(ray);\n    vec3 pos = ray.origin + res.depth*ray.direction;\n    vec3 col;\n    if (res.object == 0) {\n        vec3 amb = vec3((sin(pos) + 1.)/2.);\n        vec3 spec = vec3(0.);\n        vec3 diff = vec3(0.);\n        vec3 h;\n        vec3 l;\n        vec3 lpos;\n        vec3 ldir;\n        float bright = 1.;\n        lpos = vec3(float(0), float(5), float(0));\n        l = normalize(lpos - pos);\n        h = normalize(-ray.direction + l);\n        spec += vec3(float(1), float(1), float(1))*pow(dot(res.norm, h), float(1));\n        diff += amb*dot(l, res.norm);\n        if (SHADOW > 0.) {\n            Ray light_ray = Ray(lpos, -l);\n            float s = SHADOW*lightmarch(light_ray, length(lpos - pos), SHADOW_SMOOTH) + 1. - SHADOW;\n            spec *= s;\n            diff *= s;\n        }\n        col = float(0)*amb + float(1)*diff + float(0)*spec;\n    }\n    if (res.object == -1) {\n        col = vec3(float(0.1), float(0.1), float(0.2));\n    }vec2 nc = abs(2.*coord/resolution - 1.); col = mix(vec3(0.), col, smoothstep(1.1, 1.05, max(nc.x, nc.y) + 0.1*length(nc)));\n    col = clamp(col, 0., 1.);\n    return vec4(col, 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = color(fragCoord, iResolution.xy);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlcBWl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MlcBWX", "name": "bubblebutt3", "author": "shi", "description": "color mixing example", "tags": ["outlands"], "likes": 2, "viewed": 75, "date": "1541249594", "time_retrieved": "2024-06-20T19:24:34.357863", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.y*16.0;\n    \n    // Change time, keep rgb phase constant\n    vec3 mytime = vec3(-iTime, iTime*2.0, iTime) + vec3(1,2,4);\n\n    // Time varying pixel color\n    vec3 butt = 0.5 + sin(mytime+uv.y)\n              + 0.5 + sin(mytime+uv.x)\n              + 0.5 + cos(mytime+uv.y)\n              + 0.5 + cos(mytime+uv.x);\n\n    // Output to screen\n    fragColor = vec4(butt,1.0);\n    fragColor = vec4(1.0) - fragColor; \n    fragColor = fragColor*8.0-1.0;\n    \n    // Add this before and after line 18 for different effects\n    fragColor = fragColor + 1.5;\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlcBWX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MlGBWW", "name": "Square SDF w/ interior", "author": "scratch13764", "description": "Turned out ok, I need interior for the lighting model on my raymarcher.", "tags": ["sdf", "square", "interior"], "likes": 0, "viewed": 120, "date": "1542676789", "time_retrieved": "2024-06-20T19:24:34.357863", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy-.5;\n    uv.x *= iResolution.x/iResolution.y;\n    float RayDir = sin(iTime)/3.-.8;\n    float SquareSDF =\n                          min(max(abs(uv.x),abs(uv.y))-.1,.0)\n                          +\n                          length(max(abs(uv)-.1,0.))\n                          ;\n\n    \n    vec3 col = vec3(sin(SquareSDF*100.+(iTime*10.)));\n    vec2 ray = vec2(.5,-.5);\n    for (int i = 0; i < 7; i++){\n        SquareSDF =\n                          min(max(abs(ray.x),abs(ray.y))-.1,.0)\n                          +\n                          length(max(abs(ray)-.1,0.))\n                          ;\n        if (length(uv-ray) < SquareSDF && length(uv-ray) > SquareSDF - .005) col = vec3(1.,0.,0.);\n        ray += vec2(sin(RayDir),cos(RayDir))*SquareSDF;\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlGBWW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MlGfRK", "name": "Star Nest Cross Section", "author": "khlorghaal", "description": "trying to understand this fractal", "tags": ["fractal"], "likes": 4, "viewed": 206, "date": "1543125557", "time_retrieved": "2024-06-20T19:24:34.364061", "image_code": "// Forked by Khlorghaal from Star Nest by Pablo Roman Andrioli https://www.shadertoy.com/view/XlfGRj\n// MIT License\n\n#define iterations 64\n#define formuparam .5\n\nvec3 subsample(vec2 fc)\n{\n\tvec2 uv= (fc-.5*iResolution.xy)/iResolution.x;\n\tfloat time=iTime;\n    \t\n    //uv.x+= time*.1;\n    \n    vec3 p= vec3(uv, time*.01);\n    float pa,a=pa=0.;\n    for (int i=0; i<iterations; i++) { \n        p=abs(p)/dot(p,p)-formuparam; // the magic formula\n        a+=abs(length(p)-pa); // absolute sum of average change\n        pa=length(p);\n    }\n    a/= float(iterations);\n    a= abs(a);\n    a= min(1., a);//despeckle\n    float lum= pow(a, 8.);\n        \n\treturn vec3(lum);\t\n}\n#define SS 6\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 fc = fragCoord;\n    \n    vec3 c= vec3(0);\n    for(int y=0; y!=SS; y++){\n    \tfor(int x=0; x!=SS; x++){\n            c+= subsample(fc + vec2(x,y)/float(SS) );\n        }\n    }\n    c/=float(SS*SS);        \n    fragColor= vec4(c,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/MlGfRK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MlGfzy", "name": "RGBligthBeams", "author": "skandix", "description": "ligthbeams", "tags": ["ligthbeams"], "likes": 2, "viewed": 85, "date": "1542936947", "time_retrieved": "2024-06-20T19:24:34.527865", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 q = uv - vec2(.7, .5);\n    float beats = 128.0;\n    float bpm = beats/60.;\n    q += q.x*(pow(3.,0.5)/4.);\n    \n\tif (mod(iTime, 2.0/.5 ) >= 1.0) {\n        uv.y /= (.1*q.x+.03)*cos(iTime/bpm);\n        q.x *= pow(1000., .6)/iTime;\n    } else {\n\t\tuv.y /= (.1*q.y)*cos(iTime/bpm);\n    \tq.x *= pow(1000., .6)/iTime;\n    }\n\n    // Time varying pixel color\n    vec3 col = .5 + .5 *cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,tan(iTime));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlGfzy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MlKBzm", "name": "Infinite Spheres (Bare-bones)", "author": "hackerpoet", "description": "Bare-bones ray marcher for drawing infinite spheres.", "tags": ["spheres", "raymarcher"], "likes": 1, "viewed": 184, "date": "1542151418", "time_retrieved": "2024-06-20T19:24:35.061398", "image_code": "int max_iters = 500;\nfloat max_dist = 1000.0;\nvec3 bg_col = vec3(0.8, 0.8, 1.0);\nvec3 fg_col = vec3(1.0, 1.0, 0.6);\n\n/**\n * Rotation matrix from angles\n */\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, s),\n        vec3(0, -s, c)\n    );\n}\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n//the signed distance field function\n//used in the ray march loop\nfloat sdf(vec3 p) {\n    //a sphere of radius 1.\n    return length( p ) - 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n//1 : retrieve the fragment's coordinates\n\tvec2 uv = ( fragCoord.xy / iResolution.xy ) * 2.0 - 1.0;\n\t//preserve aspect ratio\n\tuv.x *= iResolution.x / iResolution.y;\n\n\n//2 : camera position and ray direction\n\tvec3 pos = vec3( 2.0, 2.0,-20.);\n\tvec3 dir = normalize( vec3( uv, 3.0 ) );\n\n    vec2 mos = (iMouse.xy / iResolution.xy) - vec2(0.5);\n    pos = rotateY(iTime / 6.0) * pos;\n    dir = rotateY(mos.x * 3.0) * rotateX(mos.y * 3.0) * dir;\n    \n//3 : ray march loop\n    //ip will store final color\n\tvec3 col = bg_col;\n\n\t//variable step size\n\tfloat t = 0.0;\n    int i = 0;\n\tfor(; i < max_iters; i++) {\n        //update position along path\n        vec3 ip = pos + dir * t;\n\n        //gets the shortest distance to the scene\n        float m = 4.0;\n        ip = abs(mod(ip - m*0.5, m) - m*0.5);\n\t\tfloat d = sdf( ip );\n\n        //break the loop if the distance was too small\n        //this means that we are close enough to the surface\n        if (d < 0.01) {\n            float a = float(i) / float(max_iters);\n            float diffuse = dot(ip, vec3(0.6, 0.8, 0.0))*0.5 + 0.5;\n            col = fg_col * diffuse * (1.0 - a) + bg_col * a;\n            break;\n        }\n\n\t\t//increment the step along the ray path\n\t\tt += d;\n\n        //break if too far\n        if (t > max_dist) {\n            break;\n        }\n\t}\n        \n\n//4 : apply color to this fragment\n\tfragColor = vec4(col, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlKBzm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MlKfzm", "name": "Rounded Cone - intersection", "author": "iq", "description": "Intersection of a ray and a generic (oriented in any direction) capped cone. I got it down to a single square root and one division. Many rejections are actually sqrt/div free! Computes normals too, but naturally code simplifies even further if you don't.", "tags": ["3d", "raycast"], "likes": 9, "viewed": 1167, "date": "1542155623", "time_retrieved": "2024-06-20T19:24:35.073860", "image_code": "// The MIT License\n// Copyright ¬© 2018 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Intersection of a ray and a rounded cone oriented in an arbitrary direction\n// with a single square root and division (both delayed) for the body\n\n// List of ray-surface intersectors at https://www.shadertoy.com/playlist/l3dXRf\n//\n// and http://iquilezles.org/www/articles/intersectors/intersectors.htm\n\n\nvec4 iRoundedCone( in vec3  ro, in vec3  rd, \n                   in vec3  pa, in vec3  pb, \n                   in float ra, in float rb )\n{\n    vec3  ba = pb - pa;\n\tvec3  oa = ro - pa;\n\tvec3  ob = ro - pb;\n    float rr = ra - rb;\n    float m0 = dot(ba,ba);\n    float m1 = dot(ba,oa);\n    float m2 = dot(ba,rd);\n    float m3 = dot(rd,oa);\n    float m5 = dot(oa,oa);\n\tfloat m6 = dot(ob,rd);\n    float m7 = dot(ob,ob);\n    \n    float d2 = m0-rr*rr;\n    \n\tfloat k2 = d2    - m2*m2;\n    float k1 = d2*m3 - m1*m2 + m2*rr*ra;\n    float k0 = d2*m5 - m1*m1 + m1*rr*ra*2.0 - m0*ra*ra;\n    \n\tfloat h = k1*k1 - k0*k2;\n\tif(h < 0.0) return vec4(-1.0);\n    float t = (-sqrt(h)-k1)/k2;\n  //if( t<0.0 ) return vec4(-1.0);\n\n    float y = m1 - ra*rr + t*m2;\n    if( y>0.0 && y<d2 ) \n    {\n        return vec4(t, normalize( d2*(oa + t*rd)-ba*y) );\n    }\n\n    // Caps. I feel this can be done with a single square root instead of two\n    float h1 = m3*m3 - m5 + ra*ra;\n    float h2 = m6*m6 - m7 + rb*rb;\n    if( max(h1,h2)<0.0 ) return vec4(-1.0);\n    \n    vec4 r = vec4(1e20);\n    if( h1>0.0 )\n    {        \n    \tt = -m3 - sqrt( h1 );\n        r = vec4( t, (oa+t*rd)/ra );\n    }\n\tif( h2>0.0 )\n    {\n    \tt = -m6 - sqrt( h2 );\n        if( t<r.x )\n        r = vec4( t, (ob+t*rd)/rb );\n    }\n    \n    return r;\n}\n\nvec3 pattern( in vec2 uv )\n{\n    vec3 col = vec3(0.6);\n    col += 0.4*smoothstep(-0.01,0.01,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\n#define AA 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*iTime;\n\tvec3 ro = vec3( 1.0*cos(an), 0.4, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // aniamte cone\n        #if 1\n        vec3  pa = vec3(-0.1,-0.1,0.1);\n        vec3  pb = vec3( 0.4, 0.3,0.3);\n        float ra = 0.3;\n        float rb = 0.1;\n        #else\n        vec3  pa = 0.4*cos(iTime*vec3(1.0,1.3,0.8)+vec3(0.0,2.0,4.0));\n        vec3  pb = 0.4*cos(iTime*vec3(0.9,1.1,0.7)+vec3(1.0,3.0,6.0));\n        float ra = 0.2 + 0.1*sin(iTime*1.7+0.0);\n        float rb = 0.2 + 0.1*sin(iTime*1.8+2.0);\n        #endif\n    \n        // raytrace\n        vec4 tnor = iRoundedCone( ro, rd, pa, pb, ra, rb );\n\n        float t = tnor.x;\n    \n        // shading/lighting\t\n        vec3 col = vec3(0.08)*(1.0-0.3*length(p)) + 0.02*rd.y;\n        if( t>0.0 )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = tnor.yzw;\n\n            vec3 w = normalize(pb-pa);\n            vec3 u = normalize(cross(w,vec3(0,0,1)));\n            vec3 v = normalize(cross(u,w) );\n            vec3 q = (pos-pa)*mat3(u,v,w);\n            col = pattern( vec2(16.0,64.0)*vec2(atan(q.y,q.x),q.z) );\n\n            vec3 lig = normalize(vec3(0.7,0.6,0.3));\n            vec3 hal = normalize(-rd+lig);\n\t\t    float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n\t\t    float amb = clamp( 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n            \n\t\t    col *= vec3(0.2,0.3,0.4)*amb + vec3(1.0,0.9,0.7)*dif;\n            col += 0.4*pow(clamp(dot(hal,nor),0.0,1.0),12.0)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // dither to remove banding in the background\n    tot += fract(sin(fragCoord.x*vec3(13,1,11)+fragCoord.y*vec3(1,7,5))*158.391832)/255.0;\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/MlKfzm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MltfWj", "name": "Dashed Circle", "author": "mrsaturn", "description": "An optimized dashed circle :D", "tags": ["circle", "dashed"], "likes": 1, "viewed": 515, "date": "1541120033", "time_retrieved": "2024-06-20T19:24:35.624647", "image_code": "#define AA 1\n#define AA_SAMPLES 4\n#define AA_WIDTH 0.004\n\n#define BG_COLOR vec3(0.2, 0.6, 0.6)\n\n// Circle parameters\n#define CIRCLE_INNER_RADIUS_SQUARED 0.58\n#define CIRCLE_OUTER_RADIUS_SQUARED 0.6\n#define CIRCLE_COLOR vec3(1.0)\n#define CIRCLE_CENTER vec2(0)\n#define SEGMENTS 0\n\n// Effects parameters\n#define ROTATE_CLOCKWISE 1\n#define ROTATION_SPEED 1.0\n\n#define SCALE_CIRCLE 1\n#define SCALE_SPEED 1.5\n#define SCALE_LIMIT 1.8\n\n#define CLOCKWISE_HIDING 1\n#if CLOCKWISE_HIDING\n\t#define CIRCLE_DIR 0.0\n#else\n\t#define CIRCLE_DIR 1.0\n#endif\n\n// Mathematical constants\n#define PI_2 6.283185\n\n// Shader constants\nconst float SEGMENT_ANGLE = PI_2 / float(1 << SEGMENTS);\nconst float SAMPLE_INCREMENT = AA_WIDTH / max(float(AA_SAMPLES - 1), 1.0);\nconst float INIT_OFFSET = -AA_WIDTH / 2.0;\n\n// Returns angle of point relative to circle\nfloat theta(vec2 point)\n{\n    float angle = atan(point.y, point.x);\n    angle += PI_2 * float(angle < 0.0);\n    return angle;\n}\n\n// Returns whether or not a pixel should get drawn\nbool hide_pixel(vec2 dir)\n{\n    // use square distance to avoid taking the square root\n    float square_dist = dot(dir, dir);\n    // use 'or' operation to increase chances of avoiding the last check\n    return square_dist > CIRCLE_OUTER_RADIUS_SQUARED || \n           square_dist < CIRCLE_INNER_RADIUS_SQUARED ||\n           mod(floor(theta(dir) / SEGMENT_ANGLE), 2.0) != CIRCLE_DIR;\n}\n\n// Applies 2D rotation matrix to point\nvec2 rotate_2d(vec2 point, float angle)\n{\n    float s_theta = sin(angle);\n    float c_theta = cos(angle);\n    return vec2(point.x * c_theta - point.y * s_theta, \n                point.x * s_theta + point.y * c_theta);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // clamp coordinates from -1 to 1, and account for aspect-ratio\n    vec2 coord = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n#if SCALE_CIRCLE\n    // make the circle shrink and grow\n    coord *= sin(iTime * SCALE_SPEED) + SCALE_LIMIT;\n#endif\n    \n#if ROTATE_CLOCKWISE\n    coord = rotate_2d(coord - CIRCLE_CENTER, iTime * ROTATION_SPEED);\n#else\n    coord = rotate_2d(coord - CIRCLE_CENTER, -iTime * ROTATION_SPEED);\n#endif\n    \n    float color_val\n#if AA\n \t= 0.0;\n\tfloat offset_y = INIT_OFFSET;\n    for (int i = 0; i < AA_SAMPLES; ++i)\n    {\n        float offset_x = INIT_OFFSET;\n        for (int j = 0; j < AA_SAMPLES; ++j)\n        {\n            color_val += float(hide_pixel(coord + vec2(offset_x, offset_y)));\n            offset_x += SAMPLE_INCREMENT;\n        }\n        \n        offset_y += SAMPLE_INCREMENT;\n    }\n    \n    color_val /= float(AA_SAMPLES * AA_SAMPLES);\n#else\n    = float(hide_pixel(coord));\n#endif\n    \n    fragColor = vec4(mix(CIRCLE_COLOR, BG_COLOR, color_val), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MltfWj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MlVBzG", "name": "Inscribed Circles", "author": "koi", "description": "Infinite circles inscribed within an angle.\nMove fixed point (x=1) with mouse.", "tags": ["circle", "animated", "angle", "inscribed"], "likes": 2, "viewed": 80, "date": "1543368126", "time_retrieved": "2024-06-20T19:24:35.624647", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = fragCoord;\n    coord.y -= iResolution.y / 2.0;\n    coord /= iMouse.x > 0.0 ? iMouse.x : iResolution.x / 2.0;\n    \n    fragColor = vec4(0.0);\n    \n    float angle = (sin(iTime / 2.0) * 0.375 + 0.42);\n    \n    if(abs(coord.y) < coord.x * tan(angle)) {\n        float s = sin(angle);\n        float k = log((2.0 / (1.0 - s)) - 1.0);\n        float d = exp(ceil(log(coord.x / (1.0 + s)) / k) * k);\n        \n        float a = coord.x - d;\n        float b = coord.y;\n        float r = d * s;\n        \n        if(a*a + b*b > r*r) {\n        \tfragColor = vec4(1.0);\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlVBzG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MlVfzG", "name": "Spherical indexing", "author": "mla", "description": "My take on spherical indexing, inspired by [url]http://donw.io/post/sphere-indexing/[/url], but using a different method.", "tags": ["barycentric", "spherical", "indexing"], "likes": 21, "viewed": 672, "date": "1543018515", "time_retrieved": "2024-06-20T19:24:36.503508", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Spherical indexing.\n//\n// Inspired by http://donw.io/post/sphere-indexing/ but using a different method\n//\n// Map sphere normal to octahedron face by i) taking absolute values of x,y,z\n// to map into primary quadrant, ii) intersect with surface x+y+z = 1.\n// On the octahedron face, the triangle (1,0,0),(0,1,0),(0.0,1), Euclidean\n// coordinates are the same as barycentric coordinates, which we can\n// reinterpret as positions in the right angled triangle\n// (0,0),(1,0),(0,1) just by dropping the z coordinate. Now the rows and\n// columns are horizontal and vertical and we can find the indices\n// just with some floors and mods.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// Smooth HSV to RGB conversion \n// Function by iq, from https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( vec3 c ) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n// Return square of the perp distance from p to line from A to B.\nfloat linedistance2(vec3 p, vec3 A, vec3 B) {\n  vec3 d = B-A;\n  vec3 q = A+dot(p-A,d)/dot(d,d)*d;\n  return dot(p-q,p-q);\n}\n\n// Normalize a vec2 to a vec3 bary coord with sum 1.\nvec3 mkbary(vec2 p) {\n  return vec3(p,1.0-dot(p,vec2(1)));\n}\n\nfloat N = 8.0;\nfloat linewidth2 = 0.005*0.005;\nvec3 getColor(vec3 p) {\n  p = abs(p);            // Map to primary quadrant\n  p /= dot(p,vec3(1));   // To x+y+z = 1 plane\n  vec2 frac = N * p.xy;  // To (0,0),(N,0),(0,N) triangle\n  vec2 xy = clamp(floor(frac),0.0,N-1.0);\n  frac -= xy;\n  // xy now has the integer row/column coordinates\n  // frac has the coordinates within a row/column square\n  // so work our which triangle in the square it is in.\n  float parity = float(dot(frac,vec2(1)) > 1.0);\n  // Compute the index. Adding quadrant left as exercise.\n  // Bottom bit is upper/lower triangle\n  float index = 2.0*xy.y + parity;\n  // Clamp to avoid rounding problems at end.\n  // row n goes from 0 up to 2(N-n-1)\n  index = clamp(index,0.0,2.0*(N-xy.x-1.0));\n  index += 2.0 * N*xy.x;\n\n  // Now find distance to lines in triangle.\n  // A,B,C are vertices of region triangle, in bary coordinates\n  // If p has bary coords (a,b,c), then (a,b',c') is line\n  // parallel to side opposite first vertex.\n  vec3 A = mkbary((xy+vec2(1,0))/N);\n  vec3 B = mkbary((xy+vec2(0,1))/N);\n  vec3 C = mkbary((parity==0.0?xy:xy+vec2(1))/N);\n  if (linedistance2(p,A,B) < linewidth2 ||\n      linedistance2(p,B,C) < linewidth2 ||\n      linedistance2(p,C,A) < linewidth2 ||\n      false) {\n    return vec3(1);\n  }\n  return hsv2rgb(vec3(index/(2.0*N),0.8,0.8));\n}\n\nfloat PI = 3.14159;\n\nstruct Ray {\n  vec3 q;               // origin\n  vec3 d;               // direction\n};\n\nstruct Hit {\n  float t;      // solution to p=q+t*d\n  vec3 n;       // normal\n};\n\nstruct Sphere {\n  float r;      // radius\n  vec3 p;       // centre\n};\n\nbool intersectSphere(Sphere s, Ray ray, out Hit hit) {\n  vec3 p = s.p;\n  float r = s.r;\n  float c = length(p);\n  vec3 q = ray.q, d = ray.d;\n  // |q + t*d - p|^2 = r^2\n  float B = dot(q-p,d);\n  float C = dot(q,q)-2.0*dot(q,p)+(c+r)*(c-r);\n  float D = B*B - C;\n  if (D < 0.0) return false;\n  D = sqrt(D);\n  float t,t1;\n  if (B >= 0.0) {\n    t = -B-D; t1 = C/t;\n  } else {\n    t1 = -B+D; t = C/t1;\n  }\n  if (t < 0.0) t = t1;\n  if (t < 0.0) return false;\n  // Normal is the radial vector of sphere\n  hit = Hit(t, (q+t*d-p)/r);\n  return true;\n}\n\nbool intersectScene(Ray r, out Hit hit) {\n  Sphere s = Sphere(1.0, vec3(0));\n  if (intersectSphere(s,r,hit)) {\n    return true;\n  }\n  return false;\n}\n\nvec3 light;\nfloat ambient;\nfloat diffuse;\n\nvec4 solve(Ray r) {\n  Hit hit;\n  if (!intersectScene(r,hit)) {\n    return vec4(0,0,0,1);\n  } else {\n    vec3 n = hit.n;\n    if (dot(r.d,n) > 0.0) n *= -1.0;\n    vec3 baseColor = getColor(hit.n);\n    vec3 color = baseColor.xyz*(ambient+diffuse*max(0.0,dot(light,n)));\n    float specular = pow(max(0.0,dot(reflect(light,n),r.d)),5.0);\n    color += 0.5*specular*vec3(1.0,1.0,1.0);\n    color *= clamp(1.0 - (hit.t-3.0)/5.0,0.0,1.0);\n    return vec4(sqrt(color),1.0);\n  }\n}\n\nvec2 rotate(vec2 p, float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = -(2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = -(2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  p.yz = rotate(p.yz,iTime * 0.125);\n  p.zx = rotate(p.zx,iTime * 0.2);\n  return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  light = normalize(vec3(0.5,1.0,-1.0));\n  ambient = 0.5;\n  diffuse = 1.0-ambient;\n  vec2 uv = 2.0*fragCoord.xy/iResolution.xy - 1.0;\n  vec3 p = vec3(0,0,-6.0);\n  // \"screen\" coordinate\n  vec3 s = vec3(iResolution.x/iResolution.y * uv.x, uv.y, 0);\n  vec3 d = s-p; // Direction from camera to screen point\n  p = transform(p);\n  d = transform(d);\n  d = normalize(d);\n  light = transform(light);\n  fragColor = solve(Ray(p,d));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlVfzG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MlVfzy", "name": "Another Apollonian Gasket", "author": "mla", "description": "An Apollonian Gasket. Mouse drags central circle. 'h' maps to half plane, 'd' inverts in unit disk.\n\nNew feature: press 'j' for Joukovsky!", "tags": ["inversion", "apollonian", "gasket"], "likes": 13, "viewed": 569, "date": "1543051891", "time_retrieved": "2024-06-20T19:24:37.237009", "image_code": "/////////////////////////////////////////////////////////////////////\n//\n// Apollonian Gasket: iterated inversion in a set of tangent circles\n//\n// Originally derived from https://www.shadertoy.com/view/4dsBDn\n// by ebanflo but changed fairly substantially.\n//\n// Mouse drags central circle around.\n// 'd' inverts in unit disk\n// 'h' maps to half plane\n// 'j' applies Joukovsky transform\n//\n/////////////////////////////////////////////////////////////////////\n\n// N = 3 gives 4 mutually tangent circles.\n\nconst float N = 3.0;\nconst int max_iterations = 100;\nconst float pi = 3.14159265;\n\n// Circles are represented as vec3(x,y,r2) where\n// (x,y) is the centre and r2 is the squared radius.\n\n// Invert pos in circle c\nvec2 invert(vec2 pos, vec3 c) {\n  vec2 p = pos-c.xy;\n  float p2 = dot(p,p);\n  return p*c.z/p2 + c.xy;\n}\n  \n// Invert pos in circle if it is inside \nbool checkinverse(inout vec2 pos, vec3 c) {\n  vec2 p = pos-c.xy;\n  float p2 = dot(p,p);\n  if (p2 > c.z) return false;\n  pos = p*c.z/p2 + c.xy;\n  return true;\n}\n\n// N circles in a ring, with tangency points on unit circle,\n// plus a central circle, tangent to the others.\nvec3 gasket(vec2 pos){\n  float theta = pi/N;\n  float r = 1.0/cos(theta);\n  float s = tan(theta);\n  for(int n = 0; n < max_iterations; n++){\n    vec3 c = vec3(0,0,pow(r-s,2.0));\n    // Try inverting in central circle\n    if (!checkinverse(pos,c)) {\n      bool found = false;\n      // else try in the circles of the ring.\n      for (float i = 0.0; i < N; i++) {\n        float t = 0.2*iTime;\n        vec3 c = vec3(r*sin(2.0*i*theta+t), r*cos(2.0*i*theta+t), s*s);\n        if (checkinverse(pos,c)) {\n          found = true;\n          break;\n        }\n      }\n      if (!found) return vec3(pos,n);\n    }\n  }\n  return vec3(pos,max_iterations);\n}\n\n// Smooth HSV to RGB conversion \n// Function by iq, from https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c ) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 getCol(vec3 n){\n  return hsv2rgb(vec3(mod(n.z/50.0,1.0),0.8,0.8));\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n  return vec2(z.x*w.x - z.y*w.y,\n              z.x*w.y + z.y*w.x);\n}\n\nvec2 cinv(vec2 z) {\n  return z/dot(z,z)*vec2(1,-1);\n}\n\nvec2 csqrt(vec2 z) {\n  float r = length(z);\n  return vec2(sqrt(0.5*(r+z.x)),sign(z.y)*sqrt(0.5*(r-z.x)));\n}\n\nbool keypress(int code) {\n  //return false;\n  return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n}\n\nconst int CHAR_D = 68;\nconst int CHAR_H = 72;\nconst int CHAR_J = 74;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  vec2 z = 2.0 * fragCoord.xy / iResolution.y - vec2(iResolution.x / iResolution.y, 1.0);\n  if (keypress(CHAR_H)) {\n    z.y += 1.0;\n    z = invert(z,vec3(0,-1,2)); // Map half plane to unit disk.\n  }\n  if (keypress(CHAR_D)) {\n    z *= 20.0;\n    z = invert(z,vec3(0,0,1)); // Invert in unit disk\n  }\n  if (keypress(CHAR_J)) {\n    // Inverse Joukovsky transform\n    // Solve w^2 - 2wz + 1 = 0\n    // a = 1, b = -z, c = 1\n    // (z +- sqrt(z^2 - 1))\n    vec2 t = csqrt(cmul(z,z)-vec2(1,0));\n    if (dot(z+t,z+t) < 1.0) z += t;\n    else z -= t;\n    //z = 0.5*(z+cinv(z)); // sanity check\n  }\n  vec2 m = vec2(0.1,-0.2);\n  if (iMouse.x != 0.0) {\n    m = 2.0 * iMouse.xy / iResolution.y - vec2(iResolution.x / iResolution.y, 1.0);\n  }\n    // If mouse outside unit circle, inversion is imaginary!\n  if (true/*length(m) < 0.999*/) {\n    vec2 c = m*(1.0/dot(m,m));\n    z = invert(z,vec3(c,dot(c,c)-1.0));\n  }\n\n  vec3 data = gasket(z);\n  vec3 baseColor = getCol(data);\n  fragColor = vec4(pow(baseColor, vec3(1.2)),1);\n}\n", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlVfzy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MlyBRd", "name": "narrow sky", "author": "lise", "description": "sky", "tags": ["sky", "cineshader"], "likes": 7, "viewed": 16055, "date": "1543596414", "time_retrieved": "2024-06-20T19:24:39.091621", "image_code": "const float MATH_PI = float( 3.14159265359 );\nconst vec3 SKY_COLOR = vec3(0.05, 0.2, 0.5);\nconst vec3 LIGHT = normalize( vec3(  0.1, 0.8,  0.9 ) );\nconst vec3 LIGHT_BACK = LIGHT * - 1.0;\nconst float AIRPLANE_SIZE = 20.0; // AIRPLANEÊèèÁîªÁØÑÂõ≤Áõ¥ÂæÑ\nconst float AIRPLANE_SCALE = 1.0; // AIRPLANE„Çπ„Ç±„Éº„É´\nconst float TIME_SCALE = 1.0;\nconst float EP = 0.0001;\nconst int AIRPLANE_COUNT = 5;\nconst float PI = 3.141592;\nconst float PI2 = PI * 2.0;\n\n\nconst vec2 cloudrange = vec2(0.0, 10000.0);\nconst vec3 cloudmove = vec3(0.0 , 0.0, 600.0);\n\nmat3 airplanes[AIRPLANE_COUNT];\n\nfloat dot2(in vec2 v ) { return dot(v,v); }\nfloat dot2(in vec3 v ) { return dot(v,v); }\n\n// random/hash function              \nfloat hash( float n )\n{\n  return fract(cos(n)*41415.92653);\n}\n\n// 3d noise function\nfloat noise( in vec3 x )\n{\n  vec3 p  = floor(x);\n  vec3 f  = smoothstep(0.0, 1.0, fract(x));\n  float n = p.x + p.y*57.0 + 113.0*p.z;\n\n  return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n    mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\nmat3 m = mat3( 0.00,  1.60,  1.20, -1.60,  0.72, -0.96, -1.20, -0.96,  1.28 );\n\n// Fractional Brownian motion\nfloat fbm( vec3 p )\n{\n  float f = 0.5000*noise( p ); p = m*p*1.1;\n  f += 0.2500*noise( p ); p = m*p*1.2;\n  f += 0.1666*noise( p ); p = m*p;\n  f += 0.0834*noise( p );\n  return f;\n}\n\nvec3 foldXZ(vec3 p)\n{\n    p.x = abs(p.x);\n    p.z = abs(p.z);\n    return p;\n}\n\nmat2 rotate(float a)\n{\n    float s = sin(a),c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nvec4 dElongate( in vec3 p, in vec3 h )\n{\n    vec3 q = abs(p)-h;\n    return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n\nfloat dSphere(vec3 pos, float size)\n{\n    return length(pos) - size;\n}\n\nfloat dEllipsoid(vec3 pos, vec3 size)\n{\n    return dSphere(pos / size, 1.0);\n}\n\nfloat dRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat dTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat dBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat dTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat dTree(vec3 po, inout vec4 hitColor)\n{\n    vec3 p = po;\n    // p = vec3(floor(p.x),floor(p.y),floor(p.z));\n    p.x = mod(p.x, 20.) - 10.0;\n    p.z = mod(p.z, 20.) - 10.0;\n\n    vec3 size = vec3(0.4, 4.0, 0.4);\n    float branch = dBox(p, size);\n    for (int i = 0; i < 2; i++)\n    {\n        vec3 q = foldXZ(p);\n        q.y -= size.y;\n        q.xy *= rotate(-0.4);\n        q.zy *= rotate(-0.4);\n        branch = min(branch, dBox(q, size));\n        p = q;\n    }\n\n    p.y -= size.y;\n    float leaf = dEllipsoid(p, vec3(3,2,3));\n\n    if (branch < leaf)\n    {\n        hitColor = vec4(0.44, 0.29, 0.22, 1.0);\n    }\n    else\n    {\n        float hoge = step(fract(po.x) + fract(po.y) + fract(po.z), 0.9) * 0.5;\n        hitColor = vec4(0.44 - hoge, 0.99 - hoge, 0.22 - hoge, 1.0);\n    }\n\n    return min(branch, leaf);\n}\n\nvec3 rotateX(vec3 position, float rotate)\n{\n    return vec3(position.x, position.z * -sin(rotate) + position.y * cos(rotate), position.z * cos(rotate) + position.y * sin(rotate));\n}\n\nfloat dAircraft(vec3 ray, inout vec4 hitColor)\n{\n    vec3 body1 = vec3(0.5, 0.6, 2.0) * AIRPLANE_SCALE;\n    vec3 body1Pos = vec3(0, 0.2, -1.) * AIRPLANE_SCALE;\n    float body1Rot = 3.14 * -0.03;\n    vec3 body2 = vec3(1, 1, 5) * AIRPLANE_SCALE;\n    vec3 body2Pos = vec3(0, 1, 0) * AIRPLANE_SCALE;\n    float body2Rot = 3.14 * 0.0;\n    vec3 body3 = vec3(0.5, 0.9, 7) * AIRPLANE_SCALE;\n    vec3 body3Pos = vec3(1, -1, 1.1) * AIRPLANE_SCALE;\n    float body3Rot = 3.14 * 0.5;\n    vec2 body4 = vec2(0.3, 0.1) * AIRPLANE_SCALE;\n    vec3 body4Pos = vec3(-1.5, 1.5, 1) * AIRPLANE_SCALE;\n    float body4Distortion = 3.14 * 0.0;\n    vec2 body5 = vec2(8.0, -6.0) * AIRPLANE_SCALE;\n    vec3 body5Pos = vec3(0, -1, 0) * AIRPLANE_SCALE;\n    vec2 body6 = vec2(4.0, -3.0) * AIRPLANE_SCALE;\n    vec3 body6Pos = vec3(0, -1.1, -5) * AIRPLANE_SCALE;\n    vec3 body7 = vec3(2.4, 0.5, 2.0) * AIRPLANE_SCALE;\n    vec3 body7Pos = vec3(0, 1.5, 5) * AIRPLANE_SCALE;\n    vec3 body8_1 = vec3(1.2, 0, -4.0) * AIRPLANE_SCALE;\n    vec3 body8_2 = vec3(2.4, 2.5, -7.5) * AIRPLANE_SCALE;\n    vec3 body8_3 = vec3(1.4, -1., -7.5) * AIRPLANE_SCALE;\n    vec3 body8Pos = vec3(0, -1, 0) * AIRPLANE_SCALE;\n\n    float body1Depth = dEllipsoid(rotateX(ray, body1Rot) + body1Pos, body1);\n    float body2Depth = dEllipsoid(rotateX(ray, body2Rot) + body2Pos, body2);\n    float body3Depth = dRoundCone(rotateX(vec3(ray.x, ray.y, ray.z), body3Rot) + body3Pos, body3.x, body3.y, body3.z);\n    // abs„Åó„Åü„ÅÑ\n    float body3_1Depth = dRoundCone(rotateX(vec3(-ray.x, ray.y, ray.z), body3Rot) + body3Pos, body3.x, body3.y, body3.z);\n    vec4 body4_ = dElongate(vec3(abs(ray.x), ray.y, ray.z) + body4Pos + vec3(0, 0, ray.y * -0.5), vec3(0.6, 0.1, 2.0));\n    float body4Depth = body4_.w + dTorus(rotateX(body4_.xzy + vec3(0, 0, 0), body4Distortion), body4);\n    float body5Depth = dTriangle(ray, vec3(body5.x, 0.0, body5.y) + body5Pos, vec3(-body5.x, 0.0, body5.y) + body5Pos, body5Pos) - 0.3;\n    float body6Depth = dTriangle(ray, vec3(body6.x, 0.0, body6.y) + body6Pos, vec3(-body6.x, 0.0, body6.y) + body6Pos, body6Pos) - 0.2;\n    float body7Depth = dBox(ray + body7Pos + vec3(0, 0, ray.y * -0.5), body7);\n    float body8Depth = dTriangle(vec3(abs(ray.x), ray.y, ray.z), body8_1 + body8Pos, body8_2 + body8Pos, body8_3 + body8Pos) - 0.1;\n\n    hitColor = vec4(1.0, 1.0, 1.0, 1.0);\n    float depth = min(min(min(min(min(min(min(min(body1Depth, body2Depth), body3Depth), body3_1Depth), body4Depth), body5Depth), body6Depth), body7Depth), body8Depth);\n\n    if (EP > abs(depth - body1Depth))\n    {\n        hitColor = vec4(0.2, 0.2, 0.2, 1.0);\n    }\n\n    return depth;\n}\n\nvec3 dAircraftNormal(vec3 pos)\n{\n    vec4 _tmp;\n    return normalize(vec3(\n            dAircraft(pos, _tmp) - dAircraft(vec3(pos.x - EP, pos.y, pos.z), _tmp),\n            dAircraft(pos, _tmp) - dAircraft(vec3(pos.x, pos.y - EP, pos.z), _tmp),\n            dAircraft(pos, _tmp) - dAircraft(vec3(pos.x, pos.y, pos.z - EP), _tmp)\n        ));\n}\n\nmat4 getWorldMat(mat3 transform)\n{\n    // trans world\n    vec3 axisX = cross(transform[1], transform[2]) * -1.0;\n\n    return mat4(\n        axisX.x, axisX.y, axisX.z, 0,\n        transform[1].x, transform[1].y, transform[1].z, 0,\n        transform[2].x, transform[2].y, transform[2].z, 0,\n        0, 0, 0, 1 \n        );\n}\n\nvoid airplaneRender(inout vec4 color, inout float depth, float time, vec3 cameraPos, vec3 rayDirection)\n{\n    for (int i = 0; i < AIRPLANE_COUNT; i++)\n    {\n        mat4 worldMat = getWorldMat(airplanes[i]);\n\n        vec3 localCameraPosition = (worldMat * vec4(cameraPos - airplanes[i][0], 1.0)).xyz;\n        vec3 localRayDirection = (worldMat * vec4(rayDirection, 1.0)).xyz;\n\n        float airplaneDepth = length(localCameraPosition) - AIRPLANE_SIZE * 0.5;\n        vec4 hitColor = color;\n\n\n        float marchDepth = 0.0;\n        for (int i = 0; i < 1000; i++)\n        {\n            if (marchDepth > airplaneDepth + AIRPLANE_SIZE || depth < marchDepth)\n            {\n                break;\n            }\n\n            vec3 ray = localCameraPosition + localRayDirection * marchDepth;\n            float diff = dAircraft(ray, hitColor);\n\n            if (diff < EP)\n            {\n                depth = marchDepth + diff;\n                vec3 normal = dAircraftNormal(ray);\n                color = vec4(vec3(clamp(dot(normal, LIGHT) * hitColor, 0.0, 1.0)) + 0.2, 1.0);\n            }\n            else\n            {\n                // Á¥∞„Åã„ÅÑÊâÄ„Å´Á≤æÂ∫¶„Çí„Çà„Åõ„Çã\n                marchDepth += diff;\n            }\n\n            marchDepth += AIRPLANE_SIZE * 0.001;\n        }\n    }\n}\n\nvoid skyRender(inout vec4 color, inout float depth, float time, vec3 cameraPos, vec3 rayDirection)\n{\n    float sundot = clamp(dot(rayDirection, LIGHT),0.0,1.0);\n        \n    // render sky\n    float t = pow(1.0-0.7*rayDirection.y, 15.0);\n    vec3 col = 0.8 * SKY_COLOR;\n    // sun\n    col += 0.47*vec3(1.6,1.4,1.0)*pow( sundot, 350.0 );\n    // sun haze\n    col += 0.4*vec3(0.8,0.9,1.0)*pow( sundot, 2.0 );\n        \n    // CLOUDS\n    vec4 sum = vec4(0,0,0,0);\n    float c = 0.;\n    for(int i=0;i<1000;i++) // or while\n    { \n        c +=100.; // cloud depth\n        vec3 cpos = cameraPos + c*rayDirection + cloudmove * iTime; // cloud position\n        if(cloudrange.x < cpos.y && cpos.y < cloudrange.y){\n            float alpha = smoothstep(0.5, 1.0, fbm( cpos*0.00025 ))*.9; // fractal cloud density\n            vec3 localcolor = mix(vec3( 1.1, 1.05, 1.0 ), 0.7*vec3( 0.4,0.4,0.3 ), alpha); // density color white->gray\n            alpha = (1.0-sum.w)*alpha; // alpha/density saturation (the more a cloud layer's density, the more the higher layers will be hidden)\n            sum += vec4(localcolor*alpha, alpha); // sum up weightened color\n        }\n        \n        if (0. < rayDirection.y && cloudrange.y < cpos.y)\n        break;\n        if (rayDirection.y < 0. && cpos.y < cloudrange.x)\n        break;\n        if (0.98 < sum.w)\n        break;\n        if (depth < c)\n        break;\n    }\n        \n\n\n    float alpha = smoothstep(0.7, 1.0, sum.w);\n    sum.rgb /= sum.w+0.0001;\n\n    sum.rgb -= 0.6*vec3(0.8, 0.75, 0.7)*pow(sundot,13.0)*alpha;\n    sum.rgb += 0.2*vec3(1.3, 1.2, 1.0)* pow(sundot,5.0)*(1.0-alpha);\n\n    col = mix( col, sum.rgb , sum.w );\n\n    color = color + vec4(col, 1.0);\n}\n\nvoid objectRender(inout vec4 color, inout float depth, float time, vec3 cameraPos, vec3 rayDirection)\n{\n    airplaneRender(color, depth, time, cameraPos, rayDirection);\n}\n\nvec3 getAirplanePosition(float time, int index)\n{\n    vec3 line = vec3(0, 5000., 500);\n    vec3 line2 = vec3(cos(time * 0.2) * 1000.0 - 250., 20, sin(time * 0.2 - 10.0) * 1000.0);\n    vec3 member = vec3(float(index) * 20., 10.0, float(index) * 100.);\n    return line + line2 + member;\n}\n\nvoid objectUpdate(float time)\n{\n    mat4 leaderWorld = inverse(getWorldMat(airplanes[0]));\n\n    for(int index = 0; index < AIRPLANE_COUNT; index++)\n    {\n        vec3 position = getAirplanePosition(time, index);\n        vec3 prevPosition = getAirplanePosition(time - EP, index);\n        vec3 nextPosition = getAirplanePosition(time + EP, index);\n        vec3 dir = normalize(nextPosition - position);\n        vec3 top = vec3(0, 1, 0);\n        airplanes[index] = mat3(position, top, dir);\n    }\n}\n\nvoid cameraUpdate(vec2 fragCoord, float time, out vec3 cameraPosition, out vec3 rayDirection)\n{\n    vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    cameraPosition = vec3(sin(1.0*time -10.0) * 100., 5000., 0.0);\n\n    vec3 cameraDirection = normalize(airplanes[0][0] - cameraPosition);\n    vec3 cameraTop = normalize(cameraDirection + vec3(0, 1, 0));\n    vec3 right = normalize(cross(cameraDirection, cameraTop));\n    cameraTop = cross(cameraDirection, right) * -1.0;\n\n    rayDirection = normalize(uv.x * right + uv.y * cameraTop + cameraDirection);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float time = iTime * TIME_SCALE;\n    vec3 cameraPos;\n    vec3 rayDirection;\n    vec4 color;\n    float depth = 100000.0;\n\n    objectUpdate(time);\n    cameraUpdate(fragCoord, time, cameraPos, rayDirection);\n\n    objectRender(color, depth, time, cameraPos, rayDirection);\n    skyRender(color, depth, time, cameraPos, rayDirection);\n\n\tfragColor = color;\n\n    float debugcolor = depth * 0.01;\n    //fragColor = vec4(debugcolor, debugcolor, debugcolor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlyBRd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MlyBRG", "name": "4.8^2 Truchet", "author": "fizzer", "description": "Truchet tiling using the semi-regular tiling made of octagons and squares. This is based on the idea that any regular polygon with an even number of sides can be used as a Truchet tile.", "tags": ["truchet", "tiling", "octagon"], "likes": 21, "viewed": 393, "date": "1542916610", "time_retrieved": "2024-06-20T19:24:39.916174", "image_code": "// Truchet tiling using the semi-regular tiling made of octagons and squares.\n// This is based on the idea that any regular polygon with an even number of sides can be used\n// as a Truchet tile.\n//\n// Inspired by this JavaScript canvas version here: http://somethingorotherwhatever.com/truchet-polygons/\n//\n// The side connection tables were pre-generated using my own rather brute-force program.\n//\n// 4.6.12 version is here: https://www.shadertoy.com/view/llyBRG\n//\n// Weaved version is here: https://www.shadertoy.com/view/3dVSRm\n//\n\nfloat pi = 3.141592653589;\n\nfloat hash(vec2 p)\n{\n    return texelFetch(iChannel0, ivec2(p) & 255, 0).r;\n}\n\n/*\n// Returns the origin and radius of a circle intersecting a and b, with tangents\n// at a and b pointing towards vec2(0). This is for drawing the circular arcs.\nvoid solveCircle(vec2 a, vec2 b, out vec2 o, out float r)\n{\n    float th = acos(dot(normalize(a), normalize(b))) / 2.;\n    float adj = length(a);\n    r = tan(th) *adj;\n    o = normalize((a + b) / 2.) * sqrt(r * r + adj * adj);\n}\n*/\n\n// (via comments on https://www.shadertoy.com/view/wdBSRm):\n// adx's considerably more concise version of the method above.\n// On a side note, if you haven't seen it before, his \"Quake / Introduction\" \n// shader is well worth the look: https://www.shadertoy.com/view/lsKfWd\nvoid solveCircle(vec2 a, vec2 b, out vec2 o, out float r){\n    \n    vec2 m = a + b;\n    o = dot(a, a)/dot(m, a)*m;\n    r = length(o - a);\n    \n}\n\n// Pixel width for anti-aliasing.\nfloat w;\n\n// Draws a line or arc connecting a and b inside a polygon.\nfloat l(vec2 p, vec2 a, vec2 b)\n{\n    if(dot(normalize(a), normalize(b)) < -.99999)\n    {\n        float d = distance(p, mix(a, b, clamp(dot(p - a, b - a) / dot(b - a,b - a), 0., 1.)));\n        return smoothstep(0.03, 0.03 - w * 2., d - .04);\n    }\n\n    vec2 o;\n    float r;\n    solveCircle(a, b, o, r);\n    return smoothstep(0.03, 0.03 - w * 2., abs(distance(p, o) - r) - .04);\n}\n\n\n// Array of unique octagon side connections without overlaps.\nconst int arr8[4 * 8] = int[4 * 8](\n    1, 2 ,  3, 4 ,  5, 6 ,  7, 8, \n    1, 2 ,  3, 4 ,  5, 8 ,  6, 7, \n    1, 2 ,  3, 8 ,  4, 5 ,  6, 7, \n    1, 2 ,  3, 8 ,  4, 7 ,  5, 6\n);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.y;\n\n    fragColor = vec4(1);\n\n    vec2 p = uv.xy * 8.;\n\n    w = max(length(dFdx(p)), length(dFdy(p)));\n\n    p.x += iTime / 3.;\n\n    float th = 2. * pi / 8.;\n\n    float el = tan(2. * pi / 16.);\n    float hyp = sqrt(1. - el * el);\n    float d = cos(2. * pi / 16.) * hyp;\n\n    vec2 ip = floor(p - .5) * 2.;\n    vec2 fpa = abs(fract(p) - .5);\n    vec2 fp = fract(p - .5) - .5;\n\n    float a = 0.;\n    float b = hash(ip);\n    float c = 0.;\n\n    vec3 col = vec3(1, 1, 0);\n\n    if(fpa.x + fpa.y < (1. - sqrt(2.) / 2.))\n    {\n        // Square.\n        ip = floor(p) * 2. +1.;\n        b = hash(ip);\n        fp = fract(p) - .5;\n        if(b > .5)\n            fp = fp.yx * vec2(1, -1);\n\n        a += l(fp, normalize(vec2(-1, 1)) * .5 * d / 2., normalize(vec2(1, 1)) * .5 * d / 2.);\n        a += l(fp, normalize(vec2(1, -1)) * .5 * d / 2., normalize(vec2(-1, -1)) * .5 * d / 2.);\n        c = max(c, smoothstep((1. - sqrt(2.) / 2.) - w * sqrt(2.) * 2., (1. - sqrt(2.) / 2.), max(abs(fp.x + fp.y), abs(fp.y - fp.x))));\n    }\n    else\n    {\n        // Octagon.\n        float th = floor(mod(b,.25)/.25*8.) * pi * 2. / 8.;\n        fp *= mat2(cos(th), sin(th), -sin(th), cos(th));\n        col = mix(vec3(0, .5, 0), vec3(.25, .25, 1), mod(ip.x / 2. + ip.y / 2., 2.));\n\n        th = pi * 2. / 8.;\n\n        int i = int(floor(b * 3.999));\n\n        for(int j = 0; j < 8; j += 2)\n        {\n            int ia = arr8[i * 8 + j + 0] - 1;\n            int ib = arr8[i * 8 + j + 1] - 1;\n            a += l(fp, vec2(cos(th * float(ia)), sin(th * float(ia))) / 2., vec2(cos(th * float(ib)), sin(th * float(ib))) / 2.);\n        }\n\n        float d = max(abs(fp.x + fp.y) / sqrt(2.), abs(fp.y - fp.x) / sqrt(2.));\n        c = max(c, smoothstep(.5 - w * 2., .5, max(d, max(abs(fp.x), abs(fp.y)))));\n    }\n\n    // Shade.\n    col = mix(col, vec3(1), .3) + .1;    \n    col = mix(col, vec3(0), c);\n\n    float l = 1. - (min(fract(iTime / 4.) * 2., 2. - 2. * fract(iTime / 4.)) - .5) * 16.;\n\n    fragColor.rgb = mix(vec3(.8), col, smoothstep(0., 1., l));\n\n    fragColor.rgb = mix(fragColor.rgb, vec3(0), a);\n\n    // Gamma etc.\n    fragColor.rgb = pow(fragColor.rgb, vec3(1. / 2.2));\n}\n\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlyBRG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MlyBRK", "name": "fire-api", "author": "leet", "description": "fire", "tags": ["fire"], "likes": 7, "viewed": 519, "date": "1543121221", "time_retrieved": "2024-06-20T19:24:39.916174", "image_code": "\nfloat snoise(vec3 uv, float res)\n{\n\tconst vec3 s = vec3(1e0, 1e2, 1e3);\n\t\n\tuv *= res;\n\t\n\tvec3 uv0 = floor(mod(uv, res))*s;\n\tvec3 uv1 = floor(mod(uv+vec3(1.), res))*s;\n\t\n\tvec3 f = fract(uv); f = f*f*(3.0-2.0*f);\n\n\tvec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,\n\t\t      \t  uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);\n\n\tvec4 r = fract(sin(v*1e-1)*1e3);\n\tfloat r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\tr = fract(sin((v + uv1.z - uv0.z)*1e-1)*1e3);\n\tfloat r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\treturn mix(r0, r1, f.z)*2.-1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 p = -.5 + fragCoord.xy / iResolution.xy;\n\tp.x *= iResolution.x/iResolution.y;\n\t\n\tfloat color = 3.0 - (3.*length(2.*p));\n\t\n\tvec3 coord = vec3(atan(p.x,p.y)/6.2832+.5, length(p)*.4, .5);\n\t\n\tfor(int i = 1; i <= 7; i++)\n\t{\n\t\tfloat power = pow(2.0, float(i));\n\t\tcolor += (1.5 / power) * snoise(coord + vec3(0.,-iTime*.05, iTime*.01), power*16.);\n\t}\n\tfragColor = vec4( color, pow(max(color,0.),2.)*0.4, pow(max(color,0.),3.)*0.15 , 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlyBRK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MlyBRW", "name": "Color Cubes", "author": "Tenderz", "description": "Just cubes and colors", "tags": ["raymarching", "glow"], "likes": 7, "viewed": 462, "date": "1541945792", "time_retrieved": "2024-06-20T19:24:40.861730", "image_code": "#define STEPS 128\n#define PREC_MULT 0.0001\n#define TMAX 150.0\n#define TMIN 1.0\n#define PI 3.14159265359\n\nvec3 mainLightDir;\nvec3 mainLightColor;\nvec3 ambientColor;\n\nvec3 FastHSL(vec3 hsl);\n\n// Unsigned cos [0,1]\nfloat ucos(float t) {\n    return cos(t) * 0.5 + 0.5;\n}\n\nvec2 rotate(vec2 axis, float angle) {\n    return vec2(\n        cos(angle) * axis.x + sin(angle) * axis.y,\n        -sin(angle) * axis.x + cos(angle) * axis.y\n    );\n}\n\nfloat roundBox( vec3 p, vec3 b, float r) {\n    vec3 d = abs(p) - b;\n    return length(max(d,0.0)) - r + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat plane(vec3 p, vec3 n, float d) {\n    return dot(p, n)-d;\n}\n\nvec2 mat(float f, float m) {\n    return vec2(f, m);\n}\n\nvec2 un(vec2 a, vec2 b) {\n    if(a.x < b.x) {\n        return a;\n    } else {\n        return b;\n    }\n}\n\nvec3 matGlow(vec3 p) {\n    return FastHSL(vec3(mod(iTime*0.2+p.x*0.02+p.z*0.01, 1.0), 1,1));\n}\n\nvec3 matChecker(vec3 p) {\n    vec2 uv = p.xz;\n    vec2 grid = floor(mod(uv, 2.0));\n    vec3 baseColor;\n    if(grid.x == grid.y) {\n        baseColor = vec3(1,1,1);\n    } else {\n        baseColor = vec3(0,0,0);\n    }\n    baseColor = baseColor * 0.1 + vec3(1,1,1) * 0.1;\n    return baseColor;\n}\n\nvoid mapAll(vec3 p, inout vec2 base, inout float occ, inout vec3 light) {\n    light = vec3(0,0,0);\n    \n    vec3 boxp = p;\n    // boxp.xz *= 1+mod(mod(Time,1)+boxp.y, 1);\n    boxp = p-vec3(0.0,2.0+ucos(iTime)*2.0,0);\n    boxp.z = mod(boxp.z+4.0, 8.0)-4.0;\n    boxp.xz = rotate(boxp.xz, iTime+p.y);\n    float roundBoxd = roundBox(boxp, vec3(1.0 + mod(p.y*1.0+iTime*3.0,2.0) ,2.0+ucos(iTime),1.0) * 0.5, 0.3);\n    \n    float planei = abs(mod(p.x,2.0)-1.0);\n    float planes = floor(mod(p.x*0.5-0.5,2.0)) * 2.0 -1.0;\n    planei = pow(planei,0.2);\n    vec3 planep = p;\n    planep.y -= (planei*planes) * 0.2;\n    float planed = plane(planep, vec3(0,1,0), 0.0);\n    \n    light += pow(max(0.0, 1.0-roundBoxd / 5.0),4.0) * matGlow(p);\n    base = un(mat(planed, 0.0), mat(roundBoxd, 1.0));\n    occ = planed;\n}\n\nvec2 map(vec3 p) {\n    vec2 base;\n    float occ;\n    vec3 light;\n    mapAll(p, base, occ, light);\n    return base;\n}\n\n#define EPSILON 0.0001\nvec3 mapNormal(vec3 p) {\n    return normalize(vec3(\n        map(vec3(p.x + EPSILON, p.y, p.z)).x - map(vec3(p.x - EPSILON, p.y, p.z)).x,\n        map(vec3(p.x, p.y + EPSILON, p.z)).x - map(vec3(p.x, p.y - EPSILON, p.z)).x,\n        map(vec3(p.x, p.y, p.z  + EPSILON)).x - map(vec3(p.x, p.y, p.z - EPSILON)).x\n    ));\n}\n\nvec4 computeAO(vec3 pos, vec3 n) {\n    float occ = 0.0;\n\tvec3 light = vec3(0,0,0);\n    \n\tfor( int i=0; i<3; i++ )\n\t{\n\t\tvec3 aopos = pos + n*0.3*float(i);\n        \n        vec2 baseStep;\n        float occStep;\n        vec3 lightStep;\n        mapAll(aopos, baseStep, occStep, lightStep);\n\t\tocc += occStep;\n        light += lightStep;\n\t}\n    \n    float ao = clamp(occ, 0.0, 1.0);\n    \n\treturn vec4(light, ao);\n}\n\nvec3 shade(vec3 rayOrigin, vec3 rayDir, float t, float m) {\n    vec3 p = rayOrigin + rayDir * t;\n    vec3 n = mapNormal(p);\n    float nDotL = max(0.0, dot(n, -mainLightDir));\n    vec3 lightColor = ambientColor + nDotL * mainLightColor;\n    vec3 baseColor = vec3(1,1,1);\n    if(m == 0.) {\n        baseColor = matChecker(p);\n        vec4 ao = computeAO(p, n);\n        baseColor += ao.xyz;\n    } else if(m == 1.) {\n        baseColor = matGlow(p)*5.;\n    }\n    vec3 objColor = baseColor * lightColor;\n    return objColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    mainLightDir = normalize(vec3(-0.5,-1,-2));\n    mainLightColor = normalize(vec3(1.1,1.2,1)) * 0.5;\n    ambientColor = vec3(1,1,1) * 0.2;\n        \n    float ratio = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 xy = (uv-.5) * vec2(ratio, 1);\n    \n    float yaw = iTime;\n    float pitch = -PI * 0.2;\n    vec3 lookAt = vec3(0,2,0);\n    vec3 lookDir = -normalize(vec3(0,0,1));\n    lookDir.zy = rotate(lookDir.zy, pitch);\n    lookDir.xz = rotate(lookDir.xz, yaw);\n    float lookDist = 8.0 + ucos(iTime) * 50.0;\n    vec3 camPos = lookAt - lookDir * lookDist;\n    vec3 o = camPos;\n    vec3 d = normalize(vec3(xy.x, xy.y,-1.5));\n    d.zy = rotate(d.zy, pitch);\n    d.xz = rotate(d.xz, yaw);\n    \n    float tmin = TMIN;\n    float tmax = TMAX;\n    float t = tmin;\n    vec2 trace;\n    float thres = 0.;\n    for(int i = 0; i < STEPS; i++) {\n\t    thres = PREC_MULT*t;\n        vec3 pos = o + d * t;\n        trace = map(pos);\n        float dist = trace.x;\n        if(dist < thres || t > tmax) {\n            break;\n        }\n        t += dist*0.6;\n    }\n    \n    vec3 c = vec3(0,0,0);\n    if(t < tmax) {\n        c = shade(o, d, t, trace.y);\n    }\n    \n    fragColor.xyz = c;\n    fragColor.a = 1.;\n}\n\n// https://github.com/hughsk/glsl-hsv2rgb\nvec3 FastHSL(vec3 hsl) {\n\tvec3 c = hsl;\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0., 1.), c.y);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlyBRW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MlyBzG", "name": "low-step raymarching", "author": "abje", "description": "raymarching using intersections instead of distance fields. finding the normal is quite tricky.", "tags": ["3d", "raymarching"], "likes": 13, "viewed": 512, "date": "1542912037", "time_retrieved": "2024-06-20T19:24:41.528238", "image_code": "#define maxdist 20.0\n#define steps 5\n#define antialiasing 1\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\n//random function by romasm\n//https://www.shadertoy.com/view/4scfz4\nfloat seed = 0.0;\nvec2 fragUV = vec2(0.0);\nfloat rand() \n{\n\tfloat r = fract(sin(dot(fragUV, vec2(12.9898, 78.233)) + seed) * 43758.5453);\n\tseed++;\n    return r;    \n}\n\n//a sphere intersection function from iq\n//https://www.shadertoy.com/view/4djSDy\nvec2 sphIntersect( in vec3 ro, in vec3 rd, float size)\n{\n\tfloat b = dot( ro, rd );\n\tfloat c = dot( ro, ro )-size*size;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(99999);\n\treturn vec2(-b-sqrt(h),-b+sqrt(h));\n}\n\n//same function but i changed vec3 with vec2\nvec2 sphIntersect( in vec2 ro, in vec2 rd, float size)\n{\n\tfloat b = dot( ro, rd );\n\tfloat c = dot( ro, ro )-size*size;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(99999);\n\treturn vec2(-b-sqrt(h),-b+sqrt(h));\n}\n\nvec3 texture2(vec3 p, vec3 n) {\n    vec3 c = cos(p*3.0-n);\n    vec3 s = sin(p*3.0+n*3.0);\n    \n    vec3 col = s*c.yzx*0.5+0.5;\n    col *= dot(n,normalize(vec3(-1)))*0.5+0.5;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragUV = fragCoord / iResolution.xy;\n    seed = iTime;\n    \n    vec3 acc = vec3(0);\n    for (int aa = 0; aa < antialiasing; aa++) {\n#if antialiasing==1\n        vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n#else\n        vec2 uv = ((fragCoord+vec2(rand(),rand()))*2.0-iResolution.xy)/iResolution.y;\n#endif\n\n        vec3 rd = normalize(vec3(uv,1));\n        vec3 ro = vec3(0.5,0.5,iTime);\n        \n        if (length(iMouse.xy) > 40.0) {\n            rd.yz *= rot(iMouse.y/iResolution.y*3.14-3.14*0.5);\n            rd.xz *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n        }\n        \n        vec3 ird = 1.0/vec3(length(rd.yz),length(rd.xz),length(rd.xy));\n\n        float dist = 0.0;\n        vec3 n = vec3(0,0,-1);\n        for (int i = 0; i < steps; i++) {\n            vec3 p = fract(ro+rd*dist)-0.5;\n\n            vec2 a = vec2(-1,1);\n            float l = 0.0;\n\n            //for cylinder normals\n            vec3 mask = vec3(1);\n\n            vec2 d = sphIntersect(p,rd,0.58);\n            if (d.x < 0.0) {\n                l = d.y;\n            }\n\n            d = sphIntersect(p.yz,rd.yz*ird.x,0.4)*ird.x;\n            if (d.x < 0.0 && d.y > l) {\n                mask = vec3(0,1,1);\n                l = d.y;\n            }\n\n            d = sphIntersect(p.xz,rd.xz*ird.y,0.4)*ird.y;\n            if (d.x < 0.0 && d.y > l) {\n                mask = vec3(1,0,1);\n                l = d.y;\n            }\n\n            d = sphIntersect(p.xy,rd.xy*ird.z,0.4)*ird.z;\n            if (d.x < 0.0 && d.y > l) {\n                mask = vec3(1,1,0);\n                l = d.y;\n            }\n\n            if (l > 0.0) {\n                dist += l;\n                p += rd*l;\n                n = -p*mask;\n            } else {\n                break;\n            }\n        }\n\n        vec3 background = vec3(0.2);\n        vec3 col = background;\n\n        if (dist < maxdist) {\n            vec3 p = ro+rd*dist;\n\n            n = normalize(n);\n\t\t\t\n            col = texture2(p, n);\n\n            col = mix(col,background,sqrt(dist/maxdist));\n        }\n        acc += col;\n    }\n    \n    \n    \n    fragColor = vec4(sqrt(acc/float(antialiasing)),1);\n}", "image_inputs": [{"id": "XdX3Rr", "previewfilepath": "/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlyBzG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MlyBzK", "name": "Android O System Update", "author": "_polymath", "description": "Based on the pattern displayed by my old Nexus 5X when it applied a system update (with some changes)", "tags": ["2d"], "likes": 9, "viewed": 461, "date": "1543151123", "time_retrieved": "2024-06-20T19:24:41.528238", "image_code": "const float scale = .35,\n    width = .07,\n    loops = 4.,\n    tau = acos(-1.) * 2.,\n    totalAngle = loops * tau;\n\nvec3 hue(float theta) {\n\ttheta = fract(theta / tau + 10.) * 6.;\n    /*if (theta > 0.) {*/\n        if (theta < 1.) return vec3(1., theta, 0.); // r -> y\n        if (theta < 2.) return vec3(2. - theta, 1., 0.); // y -> g\n        if (theta < 3.) return vec3(0., 1., theta - 2.); // g -> c\n        if (theta < 4.) return vec3(0., 4. - theta, 1.); // c -> b\n        if (theta < 5.) return vec3(theta - 4., 0., 1.); // b -> m\n        /*if (theta < 6.)*/ return vec3(1., 0., 6. - theta); // m -> r\n    //}\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy * .5)\n        / min(iResolution.y, iResolution.x) / scale;\n    float r = length(uv),\n        theta = atan(uv.y, uv.x);\n    \n    fragColor = vec4(0.,0.,0.,1.);\n    \n    for (float i = 0.; i < totalAngle; i += tau) {\n        float l = 1., phi = theta + i;\n        \n        l += sin(phi * .5 + iTime * .72) * .03;\n        l += sin(phi * .25 + iTime * .82) * .027;\n        l += sin(phi * .75 + iTime * .91) * .023;\n        \n        fragColor.rgb += hue(phi / loops)\n            * smoothstep(0., 2. / loops,\n                        1. - abs(r - l) * 15.);\n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlyBzK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MlyfRW", "name": "2 * 2d -> 3d  ", "author": "TLC123", "description": "\nsweep one 2d shape on one other\nfor a combined  3d object ( X , Y , Z )\nuse one 2d SDF to find a 2D dist of  say ( X , Y )  then use that  with remaining axis Z to look up another 2d SDF  (dist , Z) \n", "tags": ["2d", "sdf", "shape"], "likes": 24, "viewed": 324, "date": "1541954609", "time_retrieved": "2024-06-20T19:24:41.534081", "image_code": "// Fork of \"The Walking Raymarcher\" by xorxor. https://shadertoy.com/view/Mt3XWH\n// 2018-11-11 15:37:21\n\n\n// tracer from  https://shadertoy.com/view/Mt3XWH\n// sdPentagon from https://www.shadertoy.com/view/llVyWW\n// roundrect forked fromm https://www.shadertoy.com/view/4sjyRz\n \nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return  (max(d.x,d.y) );\n}\n\n float sdPentagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(0.809016994,0.587785252,0.726542528); // pi/5: cos, sin, tan\n\n    // reflections\n    p.y = -p.y;\n    p.x = abs(p.x);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    \n\t// side of polygon\n    return length(p-vec2(clamp(p.x,-r*k.z,r*k.z),r))*sign(p.y-r);\n}\n\nfloat smin( float a, float b )\n{\n    const float k = .21;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n    \n}\n\nfloat smax( float d1, float d2 ,float k ) {\n \n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n\nfloat roundrect(vec2 p, vec2 c, vec2 r) {\n    \n    p = abs(p) - c +r ;\n\tif (p.x >= 0.0 && p.y >= 0.0)\n        return length(p)-r.x;\n    else\n        return max(p.x, p.y)-r.x;\n}\n\nfloat shape1(vec2 p){\n\nfloat d= sdPentagon(p-vec2(-2.+-2.*sin(iTime*4.),0),1.3);\n      d=smin(d, sdPentagon(p-vec2(2,0.+2.*sin(iTime*2.) ),1.3) );\n\n    d=smin(d,sdBox(p-vec2(0,-6),vec2(3) ) );\n\n    return (d );\n    }\nfloat shape2(vec2 p){\np=p+vec2(0.2+sin(iTime*3.)*2.,0);\n\nfloat d= roundrect(p-vec2(1.75,0),vec2(2.7,1.),vec2(.2));\n    \n    \n    d=min(d,roundrect(p-vec2(2.2,0),vec2(3.3,0.5),vec2(.2))  );\n    \n    \n    d=min(d,roundrect(p-vec2(-0.0,14),vec2(0.8,1),vec2(.3)));\n    d=min(d,roundrect(p-vec2(-0,7), vec2(1,7.),vec2(.6)));\n    d=min(d, length(p-vec2(1,1))-1.1);\n    d=smax(  (length(p-vec2(1.2,8))-.7),d,0.23);\n    d=smin(d, (length(p-vec2(1.0,5))-.6));\n      d=smax((length(p-vec2(3.1,11))-2.7),d,0.24);\n\n    \n    \n    return(d );\n        }\n\n\nvec2 map( vec3 p )\n{\n    float plane = abs( p.y + 0.9 );\n\n \n\n     \n   float w =  shape1(    p.xz);\n   float d =  shape2(vec2(w,p.y));\n    \n \n    return ( d < plane ) ? vec2( d, 1.0 ) : vec2( plane, 2.0 );\n}\n\nfloat calcShadow( vec3 ro, vec3 rd, float mint, float maxt )\n{\n    float t = mint;\n    float res = 1.0;\n    for ( int i = 0; i < 10; i++ )\n    {\n        float h = map( ro + rd * t ).x;\n        res = min( res, 1.1 * h / t );\n        t += h;\n        if ( ( h < 0.001 ) || ( t > maxt ) )\n        {\n            break;\n        }\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec2 trace( vec3 ro, vec3 rd )\n{\n    const float kTMin = 0.01;\n    const float kTMax = 200.0;\n    const float kEps = 0.001;\n\n    float t = kTMin;\n    vec2 res;\n    for ( int i = 0; i < 70; i++ )\n    {\n        vec3 pos = ro + rd * t;\n        res = map( pos );\n        if ( ( res.x < kEps ) || ( t > kTMax ) )\n        {\n            break;\n        }\n        t += res.x * 0.5;\n    }\n\n    if ( t < kTMax )\n    {\n        return vec2( t, res.y );\n    }\n    else\n    {\n        return vec2( -1.0 );\n    }\n}\n\nvec3 calcNormal( vec3 p )\n{\n    const vec2 e = vec2( 0.005, 0 );\n    float dp = map( p ).x;\n    return normalize( vec3( dp - map( p - e.xyy ).x,\n                            dp - map( p - e.yxy ).x,\n                            dp - map( p - e.yyx ).x ) );\n}\n\nmat3 calcCamera( vec3 eye, vec3 target )\n{\n    vec3 cw = normalize( target - eye );\n    vec3 cu = cross( cw, vec3( 0, 1, 0 ) );\n    vec3 cv = cross( cu, cw );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\n    vec2 mo = vec2( 0.95, -0.2 );\n    if ( iMouse.z > 0.5 )\n    {\n        mo = 10.0 * iMouse.xy / iResolution.xy - 1.0;\n        mo *= 3.14159 * vec2( 0.4, 0.1 );\n    }\n    mo += 3.14159 * 2.5;\n\n    vec3 eye = vec3( 40.0 * cos( mo.x ), 30.0 + 20.0 * cos( mo.y ), 40.0 * sin( mo.x ) );\n    vec3 target = vec3( 0.0, 6.0, 0.0 );\n    \n    mat3 cam = calcCamera( eye, target );\n\n \tvec2 uv = ( fragCoord.xy - 0.5 * iResolution.xy ) / iResolution.y;\n    vec3 rd = cam * normalize( vec3( uv, 2.0 ) );\n\n    vec3 col = vec3( 1.0 );\n    \n    vec2 res = trace( eye, rd );\n    if ( res.x > 0.0 )\n    {\n        vec3 pos = eye + rd * res.x;\n        vec3 nor = calcNormal( pos );\n        vec3 ldir = normalize( vec3( -10.5, 20.8, 24.0 ) );\n        \n        if ( res.y < 1.5 )\n        {\n        \tcol = 0.5 + 0.5 * nor;\n            float dif = max( dot( nor, ldir ), 0.0 );\n            vec3 ref = reflect( rd, nor );\n            float spe = pow( clamp( dot( ref, ldir ), 0.0, 1.0 ), 15.0 );\n\n            col *= ( 0.3 + 0.7 * dif );\n            float edge = pow( 1.0 - dot( -rd, nor ), 1.1 );\n        \tcol += 0.8 * edge + spe;\n        }\n      \n        float sh = calcShadow( pos, ldir, 0.1, 30.0 );\n        col *= ( 0.5 + sh );\n    }\n    \n    \n    \n    \n    if (fract(iTime/10.)<0.33) {\n       // col=vec3( shape1(uv*20.-vec2(0,4))>0. )\n            \n                float len = shape1(uv*20.-vec2(0,4))/10.;\n    \n    //distance field coloring by iq https://www.shadertoy.com/view/4lcBWn\n       col = vec3(1.0) - sign(len)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-iResolution.y*0.008*abs(len));\n\tcol *= 0.8 + 0.2*cos(iResolution.y*0.3*abs(len));\n\tcol = mix( col, vec3(1.0), max(1.0-abs(len)*iResolution.y*0.2,0.0));\n\tfragColor = vec4(col*col, 1.0);\n            }\n    if (fract(iTime/10.)<0.165) {\n          // col=vec3( shape2(uv*20.-vec2(0,-8))>0. );\n\n            float len = shape2(uv*20.-vec2(0,-7))/10.;\n    \n    //distance field coloring by iq https://www.shadertoy.com/view/4lcBWn\n       col = vec3(1.0) - sign(len)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-iResolution.y*0.008*abs(len));\n\tcol *= 0.8 + 0.2*cos(iResolution.y*0.3*abs(len));\n\tcol = mix( col, vec3(1.0), max(1.0-abs(len)*iResolution.y*0.2,0.0));\n\t\tif (abs(uv.x)<0.005)col=vec3(1.);\n\n\tfragColor = vec4(col*col, 1.0);   \n    }\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlyfRW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Mt2fR1", "name": "Perlin Displacement Fire", "author": "nr4", "description": "Perlin displacement fire.\n", "tags": ["fire", "perlin"], "likes": 4, "viewed": 188, "date": "1541447360", "time_retrieved": "2024-06-20T19:24:41.534345", "image_code": "/*\n * Perlin Displacement Fire\n * \n * Copyright (C) 2018  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nconst vec2 c=vec2(1.,0.);\n#define blend(a) ((6.*a-15.)*a+10.)*a*a*a\n#define rand(a0) fract(sin(dot(a0.xy ,vec2(12.9898,78.233)))*43758.5453)\n#define g(a,a0) (2.*rand(vec2(a,a0))-1.)\n#define interpolate(d,w00,w10,w01,w11) mix(mix(w00,w10,blend(d.x)),mix(w01,w11,blend(d.x)),blend(d.y))\n#define perlin1d(a,seed) mix(g(floor(a),seed)*fract(a),dot(vec2(g(floor(a)+1.,seed)),vec2(fract(a),-1.)),blend(fract(a)))\n\nfloat mfperlin1d(float x, float seed, float fmin, float fmax, float phi)\n{\n    float sum = 0.;\n    float a = 1.;\n    \n    for(float f = fmin; f<fmax; f = f*2.)\n    {\n        sum = a*perlin1d(f*x, seed) + sum;\n        a = a*phi;\n    }\n    \n    return sum;\n}\n\nvec2 g2d(vec2 x, float seed)\n{\n    return vec2(-1.)+2.*vec2(rand(x+vec2(seed+2., seed+1.)), rand(x+vec2(seed+3.,seed+4.)));\n}\n\nfloat perlin2d(vec2 x, float seed)\n{\n    return interpolate(fract(x),\n                       dot(g2d(floor(x), seed), fract(x)), \n                       dot(g2d(floor(x).xy+c.xy, seed), fract(x).xy-c.xy), \n                       dot(g2d(floor(x).xy+c.yx, seed), fract(x).xy-c.yx), \n                       dot(g2d(floor(x).xy+c.xx, seed), fract(x).xy-c.xx));\n}\n\nfloat mfperlin2d(vec2 x, float seed, float fmin, float fmax, float phi)\n{\n    float sum = 0.;\n    float a = 1.;\n    \n    for(float f = fmin; f<fmax; f = f*2.)\n    {\n        sum = a*perlin2d(f*x, seed) + sum;\n        a = a*phi;\n    }\n    \n    return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 1.5*(fragCoord.xy/iResolution.xy-iTime*vec2(0.,2.));\n    \n\tfragColor = mix(\n        c.yyyx, \n        vec4(1.,81./255.,0./255.,1.), \n        abs(mfperlin2d(vec2(1.5,.44)*uv-vec2(.4*perlin2d(2.*uv-7.2*iTime*c.xy,1.), perlin2d(1.*uv-4.4*iTime+1.,5.)),10.,1.,3.e1,.3))\n    );\n    fragColor += mix(\n        fragColor, \n        vec4(1.,173./255.,57./255.,1.), \n        mfperlin2d(vec2(1.6,.3)*uv-vec2(.4*perlin2d(1.4*uv-9.3*iTime*c.xy,1.), perlin2d(1.3*uv-5.7*iTime+1.,5.)),10.,1.,4.e1,.7)\n    );\n    fragColor += mix(\n        fragColor,\n        -vec4(1.,173./255.,57./255.,1.), \n        mfperlin2d(vec2(1.4,.1)*uv-vec2(.2*perlin2d(2.1*uv-6.1*iTime*c.xy,1.), perlin2d(1.7*uv-3.4*iTime+1.,5.)),10.,1.,3.e1,.9)\n    );\n    \n    fragColor = clamp(2.*tanh(fragColor),0.,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mt2fR1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Mt3BWf", "name": "Phasing Circles", "author": "stellartux", "description": "Phasing colour patterns of overlapping circles.", "tags": ["circles", "colourful"], "likes": 1, "viewed": 338, "date": "1541279253", "time_retrieved": "2024-06-20T19:24:41.837423", "image_code": "/*  \nLoosely based off of this video \nhttps://www.youtube.com/watch?v=hkCakDslpXM\n\nSPACE to toggle between colour/black&white\nM to toggle mirroring the circles\n#define as MAGICNUM as any nonzero float for specific images\n*/\n\n//#define MAGICNUM 360./32.\n#ifndef MAGICNUM\n#define MAGICNUM 4000./(iTime + 45.)\n#endif\n\nfloat circle(in vec2 _st, in vec2 _pos, in float _radius){\n  vec2 _c = _st - _pos;\n\treturn step(dot(_c,_c), _radius);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \tvec2 st = 2. * fragCoord.xy / iResolution.xy - 1.;\n  \tst.x *= iResolution.x/iResolution.y;\n\t\n    float color = 0.;\n    \n    for (float i = 0.; i < 360.; i += MAGICNUM) {\n   \t\tcolor += circle(st, 0.5 * vec2(sin(i), cos(i)), 0.25);\n        if (texelFetch( iChannel0, ivec2(77,2),0 ).x == 0.) {\n          color += circle(st, 0.5 * vec2(sin(-i), cos(-i)), 0.25);\n        }\n    }\n    if (texelFetch( iChannel0, ivec2(32,2),0 ).x == 0.) {\n    \tcolor /= MAGICNUM / 4.;\n    \tfragColor = vec4(hsv2rgb(vec3(color, 1., .8)),1.0);\n    } else {\n     \tcolor = mod(color, 2.);\n        fragColor = vec4(vec3(color), 1.);\n    }\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mt3BWf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Mt3fD2", "name": "Finally !", "author": "wazoowazoo", "description": "I finally managed to make a simple but beautiful water shader, i've added perlin noise, reflection, a fresnel-like effect and depth (which is not very visible). Only thing left to do is optimization.", "tags": ["refraction", "water", "depth", "fresnel", "distorsion"], "likes": 3, "viewed": 195, "date": "1541068508", "time_retrieved": "2024-06-20T19:24:42.467708", "image_code": "#define PI 3.141592654\n#define PREC 0.001 // derivative precision, to small (< 0.00001) deteriors quality & performance\n#define SIZE vec2(40,30) // function size/precision\n#define WATER vec4(0.21, 0.4, 0.81, 1) // water color, no use yet ...\n#define CAMERA vec3(0.5, 0.5, 1) // camera position, direction is always [0, 0, -1]\n\nstruct Light\n{\n  vec3 pos;\n  vec4 color;\n};\n\n//\tClassic Perlin 2D Noise\n//\tby Stefan Gustavson\n//\nvec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nvec4 permute(vec4 x) {return mod(((x*34.0)+1.0)*x, 289.0);}\n\nfloat cnoise(vec2 P) {\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod(Pi, 289.0); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n  vec4 i = permute(permute(ix) + iy);\n  vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; // 1/41 = 0.024...\n  vec4 gy = abs(gx) - 0.5;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n  vec4 norm = 1.79284291400159 - 0.85373472095314 * vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n// End of Stefan Gustavson's code\n\nfloat func(vec2 coords, float offset, float mult) {\n  //return (cnoise(coords + vec2(offset)) + 1) / 3 * mult;\n  return ((cnoise(coords + vec2(offset)) + 1.0) / 2.0 + (cnoise(coords * vec2(8.0) + vec2(offset) * vec2(8.0))) / 80.0) * mult +\n  (cos(0.1 * PI * coords.x) * sin(0.3 * PI * coords.y)) * sin(offset) / 5.0;\n}\n\nfloat xDerivative(vec2 coords, float offset, float mult) {\n  return (func(coords + vec2(PREC, 0), offset, mult) - func(coords - vec2(PREC, 0), offset, mult))/((coords.x + PREC) - (coords.x - PREC));\n}\n\nfloat yDerivative(vec2 coords, float offset, float mult) {\n  return (func(coords + vec2(0, PREC), offset, mult) - func(coords - vec2(0, PREC), offset, mult))/((coords.y + PREC) - (coords.y - PREC));\n}\n\nfloat mult = 0.3;\nLight LIGHT = Light(vec3(1, 0.5, 1), vec4(1, 1, 1, 1)); // light position & color\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {  \n  vec2 texCoords = fragCoord / iResolution.xy;\n    \n  mult = (sin(iTime) * 0.7 + 1.0) / 2.0;\n  LIGHT.pos.x = (cos(iTime * 0.5 * 1.21) + 1.0) / 2.0;\n    \n  float waveHeight = func(texCoords * SIZE, iTime, mult);\n\n  // calculating derivatives\n  float xDerivative = xDerivative(texCoords * SIZE, iTime, mult);\n  float yDerivative = yDerivative(texCoords * SIZE, iTime, mult);\n\n  // surface normal, light incidence angle and camera angle\n  vec3 surfaceNormal = normalize(vec3(\n    -xDerivative,\n    -yDerivative,\n    3\n  ));\n  vec3 lightVect = normalize(vec3(\n    LIGHT.pos.x - texCoords.x,\n    LIGHT.pos.y - texCoords.y,\n    LIGHT.pos.z - waveHeight\n  ));\n  vec3 cameraVect = normalize(vec3(\n    CAMERA.x - texCoords.x,\n    CAMERA.y - texCoords.y,\n    CAMERA.z - waveHeight\n  ));\n\n  // depth calculation\n  vec3 cameraToWater = vec3(\n    texCoords.x - CAMERA.x,\n    texCoords.y - CAMERA.y,\n    waveHeight - CAMERA.z\n  );\n\n  float depth = pow(length(cameraToWater / (waveHeight - CAMERA.z) * waveHeight), 1.0);\n\n  // refraction offset\n  vec3 refraction = normalize(refract(cameraVect, surfaceNormal, 1.3));\n\n  vec2 off;\n  off.x = refraction.x * waveHeight / SIZE.x;\n  off.y = refraction.y * waveHeight / SIZE.y;\n\n  // computing reflection/refraction ratio\n  float reflectionAmount = pow(dot(surfaceNormal, lightVect), 75.0);\n\n  // output color\n  vec4 finalColor = (texture(iChannel0, texCoords + off) * WATER * (1.0 - reflectionAmount)) + (LIGHT.color * reflectionAmount * 0.9);\n  finalColor.a = depth;\n\n  //finalColor *= vec4(2, 2, 2, 1); //uncomment line for brightter water\n  fragColor = finalColor;\n}\n", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mt3fD2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Mt3fRj", "name": "Alien Squid (With Color)", "author": "rlarp", "description": "squid with color", "tags": ["color", "alien", "squid"], "likes": 1, "viewed": 51, "date": "1541437803", "time_retrieved": "2024-06-20T19:24:43.904326", "image_code": "#define PI 3.1415926535897932384626433832795\n\nstruct Shape{ // Basic Shape Constructor\n  float dist;\n  vec4 color;\n};\n    \n// Utility Functions\n   \nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nvec2 getPolarUV(in vec2 uv)\n{\n    float angle = atan(uv.y, uv.x);\n    angle += PI;\n    angle /= (2.*PI);\n    \n    float dist = distance(vec2(0.), uv);\n    \n    return vec2(angle, dist);\n}\n\nfloat mixColors(float r, float v, float z){\n    return clamp(0.5 + 0.5 * (v-r) / z, 0., 1.); \n}\n\n\nfloat fOpUnionColumns(float a, float b, float r, float n) {\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\t\tpR45(p);\n\t\tp.x -= sqrt(2.)/2.*r;\n\t\tp.x += columnradius*sqrt(2.);\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\t// At this point, we have turned 45 degrees and moved at a point on the\n\t\t// diagonal that we want to place the columns on.\n\t\t// Now, repeat the domain along this direction and place a circle.\n\t\tpMod1(p.y, columnradius*2.);\n\t\tfloat result = length(p) - columnradius;\n\t\tresult = min(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn min(result, b);\n\t} else {\n\t\treturn min(a, b);\n\t}\n}\n\nfloat pModPolar(inout vec2 v, float r){\n  float f = 6.28318/r;\n  float z = atan(v.y, v.x)+f*0.5;\n  float m = floor(z/f);\n  z = mod(z, f)-f*0.5;\n  v = vec2(cos(z), sin(z))*length(v);\n  return m;\n}\n\nmat2 rot(float a){\n  float r = cos(a);\n  float f = sin(a);\n  return mat2(r, f, -f, r);\n}\n\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat fCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t\n\t// distance to tip\n\tif ((q.y > height) && (projected < 0.)) {\n\t\td = max(d, length(tip));\n\t}\n\t\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0)));\n\t}\n\treturn d;\n}\n\n// Main Character (The Squid) \n\nShape character(vec3 c){\n  Shape shape;\n  shape.dist = 1000.; // Draw Distance\n  shape.color = vec4(1.); // Initial Color\n //  vec4 color = vec4(0.5, cos(iTime), cos(iTime), 0.); \n    \n  vec3 p = c; // Base\n  vec3 b = c; // Body\n  vec3 a1 = c; // Arm 1 Sect 1\n  vec3 a12 = c; // Arm 1 Sect 2 \n  vec3 a2 = c; // Arm 2 Sect 1 \n  vec3 a22 = c; // Arm 2 Sect 2 \n  vec3 a3 = c; // Arm 3 Sect 1\n  vec3 a32 = c; // Arm 3 Sect 2 \n  vec3 a4 = c; // Arm 4 Sect 1\n  vec3 a42 = c; // Arm 4 Sect 2 \n  vec3 e1 = c; // Eye 1 \n  vec3 e2 = c; // Pupil\n  vec3 w1 = c; // Wheel inside \n  vec3 w2 = c; // Wheel outside \n  vec3 h = c; // Hat \n  vec3 t = c; // Tentacles\n    \n    \n  // Body\n  vec4 bColor = vec4(1.0, 0.0, 0.3, 0.);  // \n  float body = fBox(b+vec3(0.0, -1.5, 0.0), vec3(0.8, 1.2, 0.75)); // Makes a box (called body) at point p of size = 1.\n    \n  // Base\n  vec4 baColor = vec4(1.0, 0.0, 0.0, 1.0); // \n  float base = fBox(p+vec3(0.0, 0.3, 0.0), vec3(0.55, 0.65, 0.75)); // Makes a box for the base\n    \n  // Eye Outside \n  vec4 e1Color = vec4(0.,0.,0., 0.); // BLACK\n  float eye1 = sdEllipsoid(e1+vec3(0.0,-1.0, 0.4), vec3(.5, abs(sin(iTime))*.5, .6));\n   \n  // Eye Inside\n  vec4 e2Color = vec4(1., 1., 1., 1.); \n  float eye2 = fSphere(e2+vec3((sin(iTime)*0.2), -1.0, 0.5), 0.15); \n   \n  // Note: I intiially had wheels hence the wheels here; I might still implement them later.   \n    \n  // Wheel Outside\n  //float wheel1 = fSphere(w1+vec3(0.0,2.,0.0), 1.0); \n \n  // Wheel Inside\n  //float wheel2 = fSphere(w2+vec3(0.0,sin(iTime)+2.,sin(iTime*0.1)+0.5), 0.4);  \n  \n  // Arm 1\n  vec4 a1Color = vec4(0.,0.,1.,1.);\n  float arm1 = fBox(a1+vec3(1.2,-0.3,0.0), vec3(1.,0.3,0.0)); \n  a12.xy *= rot(radians(45.)); \n  vec4 a12Color = vec4(0.,0.,1.,1.); \n  float arm12 = fBox(a12+vec3(1.8,-1.7,0.0), vec3(.7,0.3,0.0));\n    \n  // Arm 2\n  vec4 a2Color = vec4(0., 0., 1., 1.);\n  float arm2 = fBox(a2+vec3(1.2,-1.5,0.0), vec3(1.,0.3,0.0)); \n  a22.xy *= rot(radians(45.)); \n  vec4 a22Color = vec4(0.,0., 1., 1.); \n  float arm22 = fBox(a22+vec3(1.0,-2.5,0.0), vec3(.7,0.3,0.0)); \n    \n  // Arm 3\n  vec4 a3Color = vec4(0., 0., 1., 1.);\n  float arm3 = fBox(a3+vec3(-1.2,-0.3,0.0), vec3(1.,0.3,0.0)); \n  a32.xy *= rot(radians(-45.)); \n  vec4 a32Color = vec4(0., 0., 1., 1.);\n  float arm32 = fBox(a32+vec3(-1.8,-1.7,0.0), vec3(.7,0.3,0.0));\n    \n  // Arm 4\n  vec4 a4Color = vec4(0., 0., 1., 1.);\n  float arm4 = fBox(a4+vec3(-1.2,-1.5,0.0), vec3(1.,0.3,0.0)); \n  a42.xy *= rot(radians(-45.)); \n  vec4 a42Color = vec4(0., 0., 1., 1.);\n  float arm42 = fBox(a42+vec3(-1.0,-2.5,0.0), vec3(.7,0.3,0.0)); \n    \n  // Hat\n  vec4 hColor = vec4(1.,1.,1.,1.); \n  float hat = fSphere(h-vec3(0.,2.7,0.0), 0.55); \n    \n  // Tentacles\n  vec4 tColor = vec4(sin(iTime), 0.2, sin(iTime)-0.5, 1.); \n  t.x = abs(t.x)-.15; // Mirror\n  t.x = abs(t.x)-0.15; // Mirror again\n  t.xy *= rot(radians(180.)); // Rotates it to face the other way\n  t.x += sin(t.y * 10. - iTime * 4.) * (1. - t.y) * .03; // Animates the tentacles\n  // float tentacles = fCone(t+vec3(0., 0.5, 0.), 0.4, 3.); // Animates the tentacles\n  float tentacles = fCone(t+vec3(0., -0.55, 0.), 0.4, 2.); \n      \n    \n  shape.dist = max(body, -eye1); // Adds the box and eye (difference)\n  shape.dist = min(shape.dist, eye2); // Use shape.dist after two shapes \n  shape.dist = min(shape.dist, base); \n  //shape.dist = min(shape.dist, wheel1); \n  //shape.dist = max(shape.dist, -wheel2); \n  shape.dist = min(shape.dist, arm1); \n  shape.dist = min(shape.dist, arm12); \n  shape.dist = min(shape.dist, arm2); \n  shape.dist = min(shape.dist, arm22); \n  shape.dist = min(shape.dist, arm3);\n  shape.dist = min(shape.dist, arm32);\n  shape.dist = min(shape.dist, arm4);\n  shape.dist = min(shape.dist, arm42);\n  shape.dist = min(shape.dist, tentacles); \n  shape.dist = fOpUnionColumns(shape.dist,hat, 1., 5.); // Creates the hat ilke effect\n  \n  shape.color = mix(bColor, baColor, mixColors(base, body, 0.0));\n  shape.color = mix(shape.color, baColor, mixColors(body, shape.dist, 0.0));\n  shape.color = mix(shape.color, e1Color, mixColors(eye1, shape.dist, 0.0));\n  shape.color = mix(shape.color, e2Color, mixColors(eye2, shape.dist, 1.0));\n  shape.color = mix(shape.color, a1Color, mixColors(arm1, shape.dist, 0.0));\n  shape.color = mix(shape.color, a12Color, mixColors(arm12, shape.dist, 1.0));\n  shape.color = mix(shape.color, a2Color, mixColors(arm2, shape.dist, 0.0)); \n  shape.color = mix(shape.color, a22Color, mixColors(arm22, shape.dist, 1.0));\n  shape.color = mix(shape.color, a3Color, mixColors(arm3, shape.dist, 0.0));\n  shape.color = mix(shape.color, a32Color, mixColors(arm32, shape.dist, 1.0));\n  shape.color = mix(shape.color, a4Color, mixColors(arm4, shape.dist, 0.0));\n  shape.color = mix(shape.color, a42Color, mixColors(arm42, shape.dist, 1.0));\n  shape.color = mix(shape.color, tColor, mixColors(tentacles, shape.dist, 1.0));\n  shape.color = mix(shape.color, hColor, mixColors(hat, shape.dist, 0.5)); \n    \n    \n  return shape;\n}\n\nShape background(vec3 b){ // Creates the background (circle and box) \n   Shape shape;\n   shape.dist = 1000.;\n   shape.color = vec4(1.0); \n  //  vec4 color = vec4(0.5, cos(iTime), cos(iTime), 0.);  \n   vec3 g = b; // Ground\n   vec3 g1 = b; // Ground 1\n    \n   g.xz *= rot(b.y*0.2+iTime);\n   vec4 gColor = vec4(5., 8., 1., 1.);\n   float ground = fSphere(g-vec3(0.,-12.75, 0.0), 10.); \n   vec4 hColor = vec4(1., 1., 1., 1.); \n   float holder = fBox(g1-vec3(.0, -5., .0), vec3(100., .5, 0.));\n    \n   shape.dist = min(ground, holder);\n   shape.color = mix(gColor, hColor, mixColors(holder, ground, 0.0));\n    \n    return shape; \n  \n}\n\n\nShape map(vec3 c){ // Maps everything together (the Background and Character) \n  Shape face = character(c);\n  Shape ground = background(c);\n  face.dist = min(face.dist, ground.dist); \n  face.color = mix(face.color*2., ground.color, mixColors(ground.dist, face.dist, 0.5)); \n  return face;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { // Camera, dimensions, etc \n  vec2 v = (fragCoord.xy-0.5 * iResolution.xy) / iResolution.y;\n\n  \n  vec3 cam = vec3(0., 0., -10.5);\n   // vec3 cam = vec3(-sin(iTime)*0.3-0.5, sin(iTime)+2., sin(iTime)-10.); \n  vec3 f = normalize(vec3(v, 1.));\n  vec3 scene = cam;\n    scene.yx *= rot(iTime);\n  fragColor = vec4(0.);\n\n  // Ray Marcher\n  for(float z = 0.1 ; z <= 1.; z += 0.03){\n    Shape c = map(scene); // Calc SDF\n    if(c.dist < 0.0001){\n      fragColor = c.color*(1.-z); // Hit  - invert pixels\n      break;\n    }\n    scene += f * c.dist;\n\n\n  }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mt3fRj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtcfDj", "name": "Color Blindness LMS Curves", "author": "Tynach", "description": "Draws curves representing the LMS cone fundamentals atop the resulting spectrum. Blends between Gaussian parameters to simulate color blindness (some issues with tritanopia, however).\n\nPause as the curve you want to edit is animated to adjust via mouse.", "tags": ["simulation", "srgb", "protanopia", "deuteranopia", "tritanopia", "lms", "spectral", "protanomaly", "deuteranomaly", "tritanomaly", "simulated"], "likes": 28, "viewed": 1865, "date": "1541715999", "time_retrieved": "2024-06-20T19:24:47.589389", "image_code": "/************************************************************************\n * Scroll to line 376 to change the parameters used to draw the diagram *\n ************************************************************************/\n\nprecision highp float;\n\n#define PI 3.1415926535897932384626433832795\n#define EULER 2.7182818284590452353602874713527\n#define EV_CONV 1239.842\n\n\n/*\n * Structures\n */\n\n// Parameters for transfer characteristics (gamma curves)\nstruct transfer {\n\t// Exponent used to linearize the signal\n\tfloat power;\n\n\t// Offset from 0.0 for the exponential curve\n\tfloat off;\n\n\t// Slope of linear segment near 0\n\tfloat slope;\n\n\t// Values below this are divided by slope during linearization\n\tfloat cutoffToLinear;\n\n\t// Values below this are multiplied by slope during gamma correction\n\tfloat cutoffToGamma;\n};\n\n// Parameters for a colorspace\nstruct rgb_space {\n\t// Chromaticity coordinates (xyz) for Red, Green, and Blue primaries\n\tmat3 primaries;\n\n\t// Chromaticity coordinates (xyz) for white point\n\tvec3 white;\n\n\t// Linearization and gamma correction parameters\n\ttransfer trc;\n};\n\n\n/*\n * Preprocessor 'functions' that help build colorspaces as constants\n */\n\n// Turns 6 chromaticity coordinates into a 3x3 matrix\n#define Primaries(r1, r2, g1, g2, b1, b2)\\\n\tmat3(\\\n\t\t(r1), (r2), 1.0 - (r1) - (r2),\\\n\t\t(g1), (g2), 1.0 - (g1) - (g2),\\\n\t\t(b1), (b2), 1.0 - (b1) - (b2))\n\n// Creates a whitepoint's xyz chromaticity coordinates from the given xy coordinates\n#define White(x, y)\\\n\tvec3((x), (y), 1.0 - (x) - (y))/(y)\n\n// Creates a scaling matrix using a vec3 to set the xyz scalars\n#define diag(v)\\\n\tmat3(\\\n\t\t(v).x, 0.0, 0.0,\\\n\t\t0.0, (v).y, 0.0,\\\n\t\t0.0, 0.0, (v).z)\n\n// Creates a conversion matrix that turns RGB colors into XYZ colors\n#define rgbToXyz(space)\\\n\tspace.primaries*diag(inverse((space).primaries)*(space).white)\n\n// Creates a conversion matrix that turns XYZ colors into RGB colors\n#define xyzToRgb(space)\\\n\tinverse(rgbToXyz(space))\n\n// Creates a conversion matrix converts linear RGB colors from one colorspace to another\n#define conversionMatrix(f, t)\\\n\txyzToRgb(t)*rgbToXyz(f)\n\n\n/*\n * Standard XYZ -> LMS transformation matrices\n */\n\nconst mat3 CIECAM02 = mat3(\n\t0.7328, -0.7036, 0.003,\n\t0.4296, 1.6975, 0.0136,\n\t-0.1624, 0.0061, 0.9834\n);\n\nconst mat3 HUNT = mat3(\n\t0.38971, -0.22981, 0,\n\t0.68898, 1.1834, 0,\n\t-0.07868, 0.04641, 1\n);\n\nconst mat3 CIECAM97_1 = mat3(\n\t0.8951, -0.7502, 0.0389,\n\t0.2664, 1.7135, -0.0685,\n\t-0.1614, 0.0367, 1.0296\n);\n\nconst mat3 CIECAM97_2 = mat3(\n\t0.8562, -0.836, 0.0357,\n\t0.3372, 1.8327, -0.0469,\n\t-0.1934, 0.0033, 1.0112\n);\n\n\n/*\n * Chromaticities for RGB primaries\n */\n\n// CIE 1931 RGB\nconst mat3 primariesCie = Primaries(\n\t0.72329, 0.27671,\n\t0.28557, 0.71045,\n\t0.15235, 0.02\n);\n\n// Identity RGB\nconst mat3 primariesIdentity = mat3(1.0);\n\n// Original 1953 NTSC primaries\nconst mat3 primariesNtsc = Primaries(\n\t0.67, 0.33,\n\t0.21, 0.71,\n\t0.14, 0.08\n);\n\n// European Broadcasting Union primaries for SDTV and Rec. 601 (625 lines)\nconst mat3 primariesEbu = Primaries(\n\t0.64, 0.33,\n\t0.29, 0.6,\n\t0.15, 0.06\n);\n\n// P22 Phosphor primaries (allegedly; only found one source)\n// Used by older versions of SMPTE-C, before specific chromaticities were given\nconst mat3 primariesP22 = Primaries(\n\t0.61, 0.342,\n\t0.298, 0.588,\n\t0.151, 0.064\n);\n\n// Modern day SMPTE-C primaries, used in modern NTSC (Rec. 601) and SMPTE-240M\nconst mat3 primariesSmpteC = Primaries(\n\t0.63, 0.34,\n\t0.31, 0.595,\n\t0.155, 0.07\n);\n\n// Never-popular, antiquated, and idealized 'HDTV' primaries based mostly on the\n// 1953 NTSC colorspace. SMPTE-240M officially used the SMPTE-C primaries\nconst mat3 primaries240m = Primaries(\n\t0.67, 0.33,\n\t0.21, 0.71,\n\t0.15, 0.06\n);\n\n// Alleged primaries for old Sony TVs with a very blue whitepoint\nconst mat3 primariesSony = Primaries(\n\t0.625, 0.34,\n\t0.28, 0.595,\n\t0.155, 0.07\n);\n\n// Rec. 709 (HDTV) and sRGB primaries\nconst mat3 primaries709 = Primaries(\n\t0.64, 0.33,\n\t0.3, 0.6,\n\t0.15, 0.06\n);\n\n// DCI-P3 primaries\nconst mat3 primariesDciP3 = Primaries(\n\t0.68, 0.32,\n\t0.265, 0.69,\n\t0.15, 0.06\n);\n\n// Rec. 2020 UHDTV primaries\nconst mat3 primaries2020 = Primaries(\n\t0.708, 0.292,\n\t0.17, 0.797,\n\t0.131, 0.046\n);\n\n// If the HUNT XYZ->LMS matrix were expressed instead as\n// chromaticity coordinates, these would be them\nconst mat3 primariesHunt = Primaries(\n\t0.8374, 0.1626,\n\t2.3, -1.3,\n\t0.168, 0.0\n);\n\n// If the CIECAM97_1 XYZ->LMS matrix were expressed instead as\n// chromaticity coordinates, these would be them\nconst mat3 primariesCiecam971 = Primaries(\n\t0.7, 0.306,\n\t-0.357, 1.26,\n\t0.136, 0.042\n);\n\n// If the CIECAM97_2 XYZ->LMS matrix were expressed instead as\n// chromaticity coordinates, these would be them\nconst mat3 primariesCiecam972 = Primaries(\n\t0.693, 0.316,\n\t-0.56, 1.472,\n\t0.15, 0.067\n);\n\n// If the CIECAM02 XYZ->LMS matrix were expressed instead as\n// chromaticity coordinates, these would be them\nconst mat3 primariesCiecam02 = Primaries(\n\t0.711, 0.295,\n\t-1.476, 2.506,\n\t0.144, 0.057\n);\n\n// LMS primaries as chromaticity coordinates, computed from\n// http://www.cvrl.org/ciepr8dp.htm, and\n// http://www.cvrl.org/database/text/cienewxyz/cie2012xyz2.htm\n/*const mat3 primariesLms = Primaries(\n\t0.73840145, 0.26159855,\n\t1.32671635, -0.32671635,\n\t0.15861916, 0.0\n);*/\n\n// Same as above, but in fractional form\nconst mat3 primariesLms = Primaries(\n\t194735469.0/263725741.0, 68990272.0/263725741.0,\n\t141445123.0/106612934.0, -34832189.0/106612934.0,\n\t36476327.0/229961670.0, 0.0\n);\n\n// Original LMS matrix used to derive above primaries\nconst mat3 xyzFromLms = mat3(\n\t1.94735469, 0.68990272, 0,\n\t-1.41445123, 0.34832189, 0,\n\t0.36476327, 0, 1.93485343\n);\n\n\n/*\n * Chromaticities for white points\n */\n\n// Standard Illuminant C. White point for the original 1953 NTSC color system\nconst vec3 whiteC = White(0.310063, 0.316158);\n\n// Standard illuminant E (also known as the 'equal energy' white point)\nconst vec3 whiteE = White(1.0/3.0, 1.0/3.0);\n\n// Alleged whitepoint to use with the P22 phosphors (D65 might be more proper)\nconst vec3 whiteP22 = White(0.313, 0.329);\n\n// Standard illuminant D65. Note that there are more digits here than specified\n// in either sRGB or Rec 709, so in some cases results may differ from other\n// software. Color temperature is roughly 6504 K (originally 6500K, but complex\n// science stuff made them realize that was innaccurate)\nconst vec3 whiteD65 = White(0.312713, 0.329016);\n\n// Standard illuminant D50. Just included for the sake of including it. Content\n// for Rec. 709 and sRGB is recommended to be produced using a D50 whitepoint.\n// For the same reason as D65, the color temperature is 5003 K instead of 5000 K\nconst vec3 whiteD50 = White(0.34567, 0.35850);\n\n// White point for DCI-P3 Theater\nconst vec3 whiteTheater = White(0.314, 0.351);\n\n// Very blue white point for old Sony televisions. Color temperature of 9300 K.\n// Use with the 'primariesSony' RGB primaries defined above\nconst vec3 whiteSony = White(0.283, 0.298);\n\n// White balance for LMS so that each channel's spectral sensitivities peak at\n// exactly 1.0, at least according to the 2006 cone fundamentals\n//const vec3 whiteLmsUnity = White(89766673.0/387074477.0, 103822461.0/387074477.0);\nconst vec3 whiteLmsUnity = vec3(0.89766673, 1.03822461, 1.93485343);\n\n\n/*\n * Gamma curve parameters\n */\n\n// Linear gamma\nconst transfer gam10 = transfer(1.0, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 1.8; used by older Macintosh systems\nconst transfer gam18 = transfer(1.8, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.2; not linear near 0. Was defined abstractly to be used by early\n// NTSC systems, and is what Adobe RGB uses\nconst transfer gam22 = transfer(2.2, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.4; not linear near 0. Seems a popular choice among some people\n// online, so I included it. I don't think any standard uses this\nconst transfer gam24 = transfer(2.4, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.5; not linear near 0. Approximately what old Sony TVs used\nconst transfer gam25 = transfer(2.5, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.8; not linear near 0. Loosely defined gamma for European SDTV\nconst transfer gam28 = transfer(2.8, 0.0, 1.0, 0.0, 0.0);\n\n// Modern SMPTE 170M, as well as Rec. 601, Rec. 709, and a rough approximation\n// for Rec. 2020 content as well. Do not use with Rec. 2020 if you work with\n// high bit depths!\nconst transfer gam170m = transfer(1.0/0.45, 0.099, 4.5, 0.0812, 0.018);\n\n// Gamma for sRGB. Besides being full-range (0-255 values), this is the only\n// difference between sRGB and Rec. 709.\nconst transfer gamSrgb = transfer(2.4, 0.055, 12.92, 0.04045, 0.0031308);\n\n\n/*\n * RGB Colorspaces\n */\n\n// CIE 1931 RGB\nconst rgb_space Cie1931 = rgb_space(primariesCie, whiteE, gam10);\n\n// Identity RGB\nconst rgb_space Identity = rgb_space(primariesIdentity, whiteE, gam10);\n\n// Original 1953 NTSC\nconst rgb_space Ntsc = rgb_space(primariesNtsc, whiteC, gam22);\n\n// Mostly unused and early HDTV standard (SMPTE 240M)\nconst rgb_space Smpte240m = rgb_space(primaries240m, whiteD65, gam22);\n\n// European Broadcasting Union SDTV\nconst rgb_space Ebu = rgb_space(primariesEbu, whiteD65, gam28);\n\n// Original, imprecise colorspace for NTSC after 1987 (probably incorrect)\nconst rgb_space SmpteC = rgb_space(primariesP22, whiteD65, gam22);\n\n// Modern SMPTE \"C\" colorimetry\nconst rgb_space Smpte170m = rgb_space(primariesSmpteC, whiteD65, gam170m);\n\n// Old Sony displays using high temperature white point\nconst rgb_space Sony = rgb_space(primariesSony, whiteSony, gam25);\n\n// Rec. 709 (HDTV)\nconst rgb_space Rec709 = rgb_space(primaries709, whiteD65, gam170m);\n\n// sRGB (mostly the same as Rec. 709, but different gamma and full range values)\nconst rgb_space Srgb = rgb_space(primaries709, whiteD65, gamSrgb);\n\n// DCI-P3 D65\nconst rgb_space DciP3D65 = rgb_space(primariesDciP3, whiteD65, gam170m);\n\n// DCI-P3 D65\nconst rgb_space DciP3Theater = rgb_space(primariesDciP3, whiteTheater, gam170m);\n\n// Rec. 2020\nconst rgb_space Rec2020 = rgb_space(primaries2020, whiteD65, gam170m);\n\n// Hunt primaries, balanced against equal energy white point\nconst rgb_space HuntRgb = rgb_space(primariesHunt, whiteE, gam10);\n\n// CIE CAM 1997 primaries, balanced against equal energy white point\nconst rgb_space Ciecam971Rgb = rgb_space(primariesCiecam971, whiteE, gam10);\n\n// CIE CAM 1997 primaries, balanced against equal energy white point and linearized\nconst rgb_space Ciecam972Rgb = rgb_space(primariesCiecam972, whiteE, gam10);\n\n// CIE CAM 2002 primaries, balanced against equal energy white point\nconst rgb_space Ciecam02Rgb = rgb_space(primariesCiecam02, whiteE, gam10);\n\n// Lms primaries, balanced against equal energy white point\nconst rgb_space LmsRgb = rgb_space(primariesLms, whiteE, gam10);\n\n\n/**************\n *            *\n *  Settings  *\n *            *\n **************/\n\n// Convert to this colorspace\nconst rgb_space space = rgb_space(primaries709, whiteD65, gamSrgb);\n\n// Use LMS primaries instead of a pre-created matrix\nconst mat3 toRgb = xyzToRgb(space);\nconst mat3 toXyz = rgbToXyz(space);\nconst mat3 toLms = xyzToRgb(LmsRgb);\nconst mat3 whiteBalance = diag((toLms*space.white)/(toLms*whiteE));\n\n\n// Converts RGB colors to a linear light scale\nvec3 toLinear(vec3 color, transfer trc)\n{\n\tbvec3 cutoff = lessThan(color, vec3(trc.cutoffToLinear));\n\tbvec3 negCutoff = lessThanEqual(color, vec3(-1.0*trc.cutoffToLinear));\n\tvec3 higher = pow((color + trc.off)/(1.0 + trc.off), vec3(trc.power));\n\tvec3 lower = color/trc.slope;\n\tvec3 neg = -1.0*pow((color - trc.off)/(-1.0 - trc.off), vec3(trc.power));\n\n\tcolor = mix(higher, lower, cutoff);\n\tcolor = mix(color, neg, negCutoff);\n\n\treturn color;\n}\n\n// Gamma-corrects RGB colors to be sent to a display\nvec3 toGamma(vec3 color, transfer trc)\n{\n\tbvec3 cutoff = lessThan(color, vec3(trc.cutoffToGamma));\n\tbvec3 negCutoff = lessThanEqual(color, vec3(-1.0*trc.cutoffToGamma));\n\tvec3 higher = (1.0 + trc.off)*pow(color, vec3(1.0/trc.power)) - trc.off;\n\tvec3 lower = color*trc.slope;\n\tvec3 neg = (-1.0 - trc.off)*pow(-1.0*color, vec3(1.0/trc.power)) + trc.off;\n\n\tcolor = mix(higher, lower, cutoff);\n\tcolor = mix(color, neg, negCutoff);\n\n\treturn color;\n}\n\n// x = current wavelength\n// u = control point wavelength\n#define gauss(x, u, o, A)\\\n\tA/o*exp(-0.5*pow((x - u)/o, 2.0))\n\n// Converts from a wavelength to LMS.\n// Constructed using multi-peak Gaussian functions generated using Labplot\n// and closely fitted to the CIE 2006 2¬∞ cone fundamentals created by\n// Stockman & Sharp 2000).\n// Takes an 'amount' vector which determines how strong each type of\n// color blindness will be\nvec3 waveToLms(float wave, vec3 amount)\n{\n\t// LMS Gaussian function parameters for each cone type\n\tconst vec3[5] lParams = vec3[](\n\t\tvec3(449.682, 21.6622, 2.36612),\n\t\tvec3(477.589, 11.0682, 1.39883),\n\t\tvec3(532.488, 25.7494, 34.0478),\n\t\tvec3(570.2, 5.91487, 0.243387),\n\t\tvec3(585.858, 34.98, 77.8669)\n\t);\n\n\tconst vec3[5] mParams = vec3[](\n\t\tvec3(450.237, 19.5222, 3.33537),\n\t\tvec3(479.559, 13.3211, 3.68813),\n\t\tvec3(519.924, 17.1502, 9.68484),\n\t\tvec3(542.8, 3.27696, 0.105766),\n\t\tvec3(552.158, 33.3895, 77.9298)\n\t);\n\n\tconst vec3[5] sParams = vec3[](\n\t\tvec3(467.661, 8.84562, 5.32073),\n\t\tvec3(422.211, 10.2028, 8.58498),\n\t\tvec3(443.084, 11.9848, 19.6347),\n\t\tvec3(444.863, 1.30608, -0.0330768),\n\t\tvec3(460.886, 25.7907, 24.9128)\n\t);\n\n\t// Color blindness simulation constants\n\tconst vec3 white = inverse(xyzFromLms)*whiteE;\n\tconst vec3 blue = inverse(xyzFromLms)*LmsRgb.primaries[2];\n\tconst vec3 red = inverse(xyzFromLms)*LmsRgb.primaries[0];\n\n\tconst vec2 prota = inverse(mat2(\n\t\twhite.g, blue.g,\n\t\twhite.b, blue.b\n\t))*vec2(white.r, blue.r);\n\n\tconst vec2 deuta = inverse(mat2(\n\t\twhite.r, blue.r,\n\t\twhite.b, blue.b\n\t))*vec2(white.g, blue.g);\n\n\tconst vec2 trita = inverse(mat2(\n\t\twhite.r, red.r,\n\t\twhite.g, red.g\n\t))*vec2(white.b, red.b);\n\n\t// Color blindness adjusted parameters for each cone type\n\tvec3[5] lParamsMod = vec3[](\n\t\tmix(lParams[0], mParams[0], amount.x),\n\t\tmix(lParams[1], mParams[1], amount.x),\n\t\tmix(lParams[2], mParams[2], amount.x),\n\t\tmix(lParams[3], mParams[3], amount.x),\n\t\tmix(lParams[4], mParams[4], amount.x)\n\t);\n\n\tvec3[5] mParamsMod = vec3[](\n\t\tmix(mParams[0], lParams[0], amount.y),\n\t\tmix(mParams[1], lParams[1], amount.y),\n\t\tmix(mParams[2], lParams[2], amount.y),\n\t\tmix(mParams[3], lParams[3], amount.y),\n\t\tmix(mParams[4], lParams[4], amount.y)\n\t);\n\n\tvec3[5] sParamsMod = vec3[](\n\t\tmix(sParams[0], mParams[0], amount.z),\n\t\tmix(sParams[1], mParams[1], amount.z),\n\t\tmix(sParams[2], mParams[2], amount.z),\n\t\tmix(sParams[3], mParams[3], amount.z),\n\t\tmix(sParams[4], mParams[4], amount.z)\n\t);\n\n\t// Color blindness adaptation matrices\n\t/*mat3 adaptProta = mat3(\n\t\t1.0 - amount.x, 0.0, 0.0,\n\t\tprota.x*amount.x, 1.0, 0.0,\n\t\tprota.y*amount.x, 0.0, 1.0\n\t);\n\n\tmat3 adaptDeuta = mat3(\n\t\t1.0, deuta.x*amount.y, 0.0,\n\t\t0.0, 1.0 - amount.y, 0.0,\n\t\t0.0, deuta.y*amount.y, 1.0\n\t);\n\n\tmat3 adaptTrita = mat3(\n\t\t1.0, 0.0, trita.x*amount.z,\n\t\t0.0, 1.0, trita.y*amount.z,\n\t\t0.0, 0.0, 1.0 - amount.z\n\t);\n\n\tmat3 adapt = adaptTrita*adaptDeuta*adaptProta;*/\n\n\tmat3 adapt = mat3(\n\t\t1.0 - amount.x, deuta.x*amount.y, trita.x*amount.z,\n\t\tprota.x*amount.x, 1.0 - amount.y, trita.y*amount.z,\n\t\tprota.y*amount.x, deuta.y*amount.y, 1.0 - amount.z\n\t);\n\n\t// Return the LMS values for the given wavelength\n\treturn (adapt*vec3(1))*vec3(\n\t\t// L cone response curve\n\t\tgauss(wave, lParamsMod[0].x, lParamsMod[0].y, lParamsMod[0].z) +\n\t\tgauss(wave, lParamsMod[1].x, lParamsMod[1].y, lParamsMod[1].z) +\n\t\tgauss(wave, lParamsMod[2].x, lParamsMod[2].y, lParamsMod[2].z) +\n\t\tgauss(wave, lParamsMod[3].x, lParamsMod[3].y, lParamsMod[3].z) +\n\t\tgauss(wave, lParamsMod[4].x, lParamsMod[4].y, lParamsMod[4].z),\n\n\t\t// M cone response curve\n\t\tgauss(wave, mParamsMod[0].x, mParamsMod[0].y, mParamsMod[0].z) +\n\t\tgauss(wave, mParamsMod[1].x, mParamsMod[1].y, mParamsMod[1].z) +\n\t\tgauss(wave, mParamsMod[2].x, mParamsMod[2].y, mParamsMod[2].z) +\n\t\tgauss(wave, mParamsMod[3].x, mParamsMod[3].y, mParamsMod[3].z) +\n\t\tgauss(wave, mParamsMod[4].x, mParamsMod[4].y, mParamsMod[4].z),\n\n\t\t// S cone response curve\n\t\tgauss(wave, sParamsMod[0].x, sParamsMod[0].y, sParamsMod[0].z) +\n\t\tgauss(wave, sParamsMod[1].x, sParamsMod[1].y, sParamsMod[1].z) +\n\t\tgauss(wave, sParamsMod[2].x, sParamsMod[2].y, sParamsMod[2].z) +\n\t\tgauss(wave, sParamsMod[3].x, sParamsMod[3].y, sParamsMod[3].z) +\n\t\tgauss(wave, sParamsMod[4].x, sParamsMod[4].y, sParamsMod[4].z)\n\t)/sqrt(2.0*PI);\n}\n\n// Scales a color to the closest in-gamut representation of that color\n// Preserves both hue and luminosity, but at the cost of saturation\nvec3 gamutScale(vec3 color)\n{\n\tfloat luma = (toXyz*color).y;\n\n\tfloat low = min(color.r, min(color.g, min(color.b, 0.0)));\n\tfloat high = max(color.r, max(color.g, max(color.b, 1.0)));\n\n\tfloat lowScale = low/(low - luma);\n\tfloat highScale = max((high - 1.0)/(high - luma), 0.0);\n\tfloat scale = max(lowScale, highScale);\n\tcolor += scale*(luma - color);\n\n\treturn color;\n}\n\n\nconst float minWave = 390.0;\nconst float maxWave = 730.0;\nconst float waveRange = maxWave - minWave;\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\t// Number of pixels to the left and right of the current pixel to sample\n\t// the LMS spectral values\n\tconst float offset = 0.5;\n\n\t// Which period of 5-second intervals is currently active\n\t// Synchronizes with the default animation's timing\n\tfloat timeSegment = mod(iTime/5.0, 3.0);\n\n\t// How strong the color blindness is for each channel\n\tvec3 amount;\n\n\t// By default (or if the leftmost column of pixels was clicked last)\n\tif (iMouse.x == 0.0) {\n\t\t// Have the amount of each channel move on a sine wave that is\n\t\t// different for each channel, clamped so that only one changes\n\t\t// at a time, each taking 5 seconds. iTime values of note:\n\n\t\t// amount.x ('L') starts:  0.0; peaks:  2.5; ends:  5.0\n\t\t// amount.y ('M') starts:  5.0; peaks:  7.5; ends: 10.0\n\t\t// amount.z ('S') starts: 10.0; peaks: 12.5; ends: 15.0\n\t\tamount = vec3(iTime*2.0/15.0);\n\t\tamount += vec3(1.0/6.0, -0.5, -7.0/6.0);\n\t\tamount = clamp(sin(amount*PI)*2.0 - 1.0, 0.0, 1.0);\n\t} else {\n\t\t// Depending on which 'time segment' is currently observed, change\n\t\t// which curve the user can edit with their mouse\n\n\t\t// These are meant to be synchronized with the animation detailed\n\t\t// above, that way a user can pause the shader to manipulate the\n\t\t// curve that was being animated at the time they paused it\n\t\tamount = vec3(\n\t\t\tiMouse.x/iResolution.x*float(floor(timeSegment) == 0.0),\n\t\t\tiMouse.x/iResolution.x*float(floor(timeSegment) - 1.0 == 0.0),\n\t\t\tiMouse.x/iResolution.x*float(floor(timeSegment) - 2.0 == 0.0)\n\t\t);\n\t}\n\n\t// Obtain the LMS values to eventually become the color for each pixel\n\tvec2 uv = gl_FragCoord.xy/iResolution.xy;\n\tvec3 color = waveToLms(waveRange*uv.x + minWave, amount);\n\n\t// Only show the spectrum in the center slice\n\tbvec3 showSpectrum = bvec3(int(uv.y*3.0) % 3 - 1);\n\tcolor = mix(color, vec3(0), showSpectrum);\n\n\t// Uniformly brighten the image to fit it within sRGB while\n\t// retaining full accuracy\n\tcolor += inverse(xyzFromLms)*vec3(1.076);\n\tcolor /= 3.71;\n\n\t// Perform white balance and convert to RGB\n\tcolor = toRgb*xyzFromLms*whiteBalance*color;\n\n\t// Scale out-of-gamut colors just in case\n\tcolor = gamutScale(color);\n\n\t// Sample of the line 'offset' pixels to the left and right of the\n\t// current column of pixels\n\tvec3 bef = waveToLms(waveRange*(fragCoord.x + offset)/iResolution.x + minWave, amount)/2.5;\n\tvec3 aft = waveToLms(waveRange*(fragCoord.x - offset)/iResolution.x + minWave, amount)/2.5;\n\n\t// Apply white balance to LMS curve samples\n\tbef = toLms*xyzFromLms*whiteBalance*bef;\n\taft = toLms*xyzFromLms*whiteBalance*aft;\n\n\n\t// Calculate distance from the L line\n\tvec2 p1L = vec2(fragCoord.x - offset, bef.x*iResolution.y);\n\tvec2 p2L = vec2(fragCoord.x + offset, aft.x*iResolution.y);\n\tvec2 toUvL = p2L - fragCoord;\n\tvec2 unitL = normalize(p2L - p1L);\n\tfloat distL = length(toUvL - dot(toUvL, unitL)*unitL);\n\n\t// Calculate distance from the M line\n\tvec2 p1M = vec2(fragCoord.x - offset, bef.y*iResolution.y);\n\tvec2 p2M = vec2(fragCoord.x + offset, aft.y*iResolution.y);\n\tvec2 toUvM = p2M - fragCoord;\n\tvec2 unitM = normalize(p2M - p1M);\n\tfloat distM = length(toUvM - dot(toUvM, unitM)*unitM);\n\n\t// Calculate distance from the S line\n\tvec2 p1S = vec2(fragCoord.x - offset, bef.z*iResolution.y);\n\tvec2 p2S = vec2(fragCoord.x + offset, aft.z*iResolution.y);\n\tvec2 toUvS = p2S - fragCoord;\n\tvec2 unitS = normalize(p2S - p1S);\n\tfloat distS = length(toUvS - dot(toUvS, unitS)*unitS);\n\n\n\t// Calculate line colors\n\tvec3 lineL = inverse(toLms)*whiteBalance*vec3(1, 0.1, 0.1);\n\tvec3 lineM = inverse(toLms)*whiteBalance*vec3(0.1, 1, 0.1);\n\tvec3 lineS = inverse(toLms)*whiteBalance*vec3(0.1, 0.1, 1);\n\n\t// Set all colored lines to the same luminosity\n\tlineL = lineL/lineL.y*0.25;\n\tlineM = lineM/lineM.y*0.25;\n\tlineS = lineS/lineS.y*0.25;\n\n\t// Convert line colors to RGB and scale them to be in-gamut so they blend smoothly\n\tlineL = gamutScale(toRgb*lineL);\n\tlineM = gamutScale(toRgb*lineM);\n\tlineS = gamutScale(toRgb*lineS);\n\n\n\t// Draw the black lines\n\tcolor = mix(vec3(0), color, clamp(distL - 2.5*iResolution.y/1024.0, 0.0, 1.0));\n\tcolor = mix(vec3(0), color, clamp(distM - 2.5*iResolution.y/1024.0, 0.0, 1.0));\n\tcolor = mix(vec3(0), color, clamp(distS - 2.5*iResolution.y/1024.0, 0.0, 1.0));\n\n\t// Draw the colored lines\n\tcolor = mix(lineL, color, clamp(distL - 1.0*iResolution.y/1024.0, 0.0, 1.0));\n\tcolor = mix(lineM, color, clamp(distM - 1.0*iResolution.y/1024.0, 0.0, 1.0));\n\tcolor = mix(lineS, color, clamp(distS - 1.0*iResolution.y/1024.0, 0.0, 1.0));\n\n\n\t// Apply display transfer characteristics (or 'gamma')\n\tcolor = toGamma(color, space.trc);\n\n\t// Set the pixel's color\n\tfragColor = vec4(color, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtcfDj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtcfRl", "name": "torus_thingy_19", "author": "balkhan", "description": "another torus thingy", "tags": ["3d", "raymarching"], "likes": 4, "viewed": 146, "date": "1542178296", "time_retrieved": "2024-06-20T19:24:47.595414", "image_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\nvec2\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvoid\trotate(inout vec2 v, float angle);\nvec3\tcalcNormal( in vec3 pos, float e, vec3 dir);\nfloat\tloop_circle(vec3 p);\nfloat\tcircle(vec3 p, float phase);\nfloat\tsdTorus( vec3 p, vec2 t, float phase );\nfloat\tmylength(vec2 p);\nfloat\tmylength(vec3 p);\nfloat\tnrand( vec2 n );\n\nfloat \tt;\t\t\t// time\nvec3\tret_col;\t// bgd color\nvec3\th; \t\t\t// volumetric light\nvec3\trc;\t\t\t// very subtle\n\n#define I_MAX\t\t200.\n#define E\t\t\t0.0001\n#define FAR\t\t\t40.\n#define PI\t\t\t3.14159\n#define TAU\t\t\tPI*2.\n\nvoid mainImage(out vec4 c_out, in vec2 f)\n{\n    t  = iTime*.125;\n    vec3\tcol = vec3(0., 0., 0.);\n\tvec2 R = iResolution.xy,\n          uv  = vec2(f-R/2.) / R.y;\n\tvec3\tdir = camera(uv);\n    vec3\tpos = vec3(.0, .0, 60.0);\n\n    h*=0.;\n    rc = vec3(\n        1.0,\n        .05,\n        .05\n    );\n    vec2\tinter = (march(pos, dir));\n    ret_col = vec3(.90, .82, .70);\n    col.xyz = ret_col*(1.-inter.x*.005);\n    col += h*.005;\n    c_out =  vec4(col,1.0);\n}\n\n/*\n* Leon's mod polar from : https://www.shadertoy.com/view/XsByWd\n*/\n\nvec2 modA (vec2 p, float count) {\n    float an = TAU/count;\n    float a = atan(p.y,p.x)+an*.5;\n    a = mod(a, an)-an*.5;\n    return vec2(cos(a),sin(a))*length(p);\n}\n\n/*\n* end mod polar\n*/\n\nfloat\tscene(vec3 p)\n{  \n    float\tmind = 1e5;\n    float\ttoris = 1e5;\n    p.z += -37.;\n    rotate(p.xz, 1.57-.035*iTime );\n    rotate(p.yz, 1.57-.05*iTime );\n    vec2 q;\n\n    q = vec2( length(p.xz)-5., p.y );\n\trotate(q, iTime);\n    \n    q = abs(q)-3.;\n\n    toris = length(q)-2.5;\n    \n    mind = mylength(p.xyz)-20.;\n    p.xyz = fract(p.xyz*2.)-.5;\n    mind = max(mind, (length(p.xyz)+.0+toris*1.0+-5.50+20.0*.1250025*(1./max(toris*toris + .25, .05)) ) );\n    mind = abs(mind)+.005;\n\n    h += (1.5-rc)*1./max(.01, toris*toris+ 2.25);\n    h += vec3(.5, .1, .1)*1./max(.01, toris*toris*10.+.25);\n    h += vec3(.92, .27,.1)*1./max(.01, mind*mind*40. + .2505101);\n    \n    return (mind);\n}\n\nvec2\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0, 0.0);\n    vec3\tp = vec3(0.0, 0.0, 0.0);\n    vec2\ts = vec2(0.0, 0.0);\n\n\t    for (float i = -1.; i < I_MAX; ++i)\n\t    {\n\t    \tp = pos + dir * dist.y;\n\t        dist.x = scene(p);\n\t        dist.y += dist.x*.2;\n\t        if (dist.x < E || dist.y > FAR)\n            {\n                break;\n            }\n\t        s.x++;\n    }\n    s.y = dist.y;\n    return (s);\n}\n\n// Utilities\n\nfloat\tmylength(vec2 p)\n{\n\tfloat\tret;\n\n    ret = max(abs(p.x), abs(p.y));\n    \n    return ret;\n}\n\nfloat\tmylength(vec3 p)\n{\n\tfloat\tret;\n\n    ret = max(max(abs(p.x), abs(p.y)), abs(p.z));\n\n    return ret;\n}\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec2\trot(vec2 p, vec2 ang)\n{\n\tfloat\tc = cos(ang.x);\n    float\ts = sin(ang.y);\n    mat2\tm = mat2(c, -s, s, c);\n    \n    return (p * m);\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float\t\tfov = 1.;\n\tvec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n\nvec3 calcNormal( in vec3 pos, float e, vec3 dir)\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\n    return normalize(vec3(\n           march(pos+eps.xyy, dir).y - march(pos-eps.xyy, dir).y,\n           march(pos+eps.yxy, dir).y - march(pos-eps.yxy, dir).y,\n           march(pos+eps.yyx, dir).y - march(pos-eps.yyx, dir).y ));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtcfRl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtcfWf", "name": "Mandelbrot Zoom (512 Iterations)", "author": "Nihilistic_Furry", "description": "This version of the Mandelbrot zoom uses a higher iteration count than my previous version. It produces nicer results, but takes more processing power. For my laptop, this one can frame drop whereas the other one didn't. Position tuned at time 319.18.", "tags": ["mandelbrot", "zoom", "fractals"], "likes": 1, "viewed": 168, "date": "1541294351", "time_retrieved": "2024-06-20T19:24:47.595414", "image_code": "// Default zoom point of (-1.2501902, 0.00612967 i), but previosly (-1.2501046 + 0.00611021 i)\n// Zooms in on point that is good at showing rounding errors as it zooms in more and more \n#define cx -1.2501902\n#define cy 0.00612967\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Variables\n\tfloat scale = 1.0 / (iTime * iTime * iTime + 1.0);\n    float ax, ay;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Change perspectives w/ zoom\n    ax = cx + ((uv.x * 3.5) - 2.5) * scale;\n    ay = cy + ((uv.y * 2.0) - 1.0) * scale;\n    vec2 c = vec2 (ax, ay);\n    \n    // Set up calculation (x = real, y = imaginary)\n    vec2 z;\n    int i;\n    \n    // Actual math of mandelbrot set\n    for (i = 0; !(i > 512 || dot (z, z) > 16.0); i++) \n    {\n        // Find \"z = z^2 + c\"\n        z = vec2 ((z.x * z.x) - (z.y * z.y), 2.0 * z.x * z.y) + c;\n    }\n    \n    float color;\n    \n    // If part of set, make it black, if not, divide by 512 for colored version\n    if (i > 512)\n    {\n        color = 0.0;\n    } \n    else\n    {\n\t\tcolor = float (i) * 0.0625;\n    }\n    \n    fragColor = vec4 (color, color, color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtcfWf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtcfWj", "name": "RayMarchingBlob", "author": "HUYNH", "description": "Operator: blending + intersect + union + difference\nObject: Sphere + cube + Torus\nFunction: Twist + Displacement", "tags": ["ray"], "likes": 1, "viewed": 88, "date": "1541800733", "time_retrieved": "2024-06-20T19:24:47.602090", "image_code": "\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\n// Operator\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n\n//Smooth 2 function\nfloat blendingSDF( float a, float b)\n{\n    float k = 1.5;\n    float h = max( k-abs(a-b), 0.0 );\n    return min( a, b ) - h*h*h/(6.0*k*k);\n}\n\n\n\nfloat cubeSDF(vec3 p) {\n\n    vec3 d = abs(p) - vec3(1.0, 1.0, 1.0);\n    \n   \n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n   \n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\nfloat sphereSDF(vec3 p) {\n    return length(p) - 1.0;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// Twist\nfloat opTwist( vec3 p )\n{\n    float c = cos(4.0*p.y + iTime);\n    float s = sin(4.0*p.y + iTime);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return sdTorus(q, vec2(0.7,0.2));\n}\n\n// Displacement\n \tfloat opDisplace( vec3 p )\n{\n    float d1 =  sphereSDF(p);\n    float d2 = sin(2.0*p.x+ iTime)*sin(2.0*p.y+ iTime)*sin(2.0*p.z+ iTime);\n    return d1+d2;\n}\n\n\nfloat sceneSDF(vec3 samplePoint) {\n    float sphereDist = sphereSDF((samplePoint + vec3(3.0,0.0,0))/1.2) * 1.2;\n    float cubeDist = cubeSDF(samplePoint+  + vec3(3.0,sin(iTime),0));\n    float Diff = differenceSDF(cubeDist, sphereDist);\n  \n    \n    float sphereDist1 = sphereSDF(samplePoint/1.2) * 1.2;\n    float cubeDist1 = cubeSDF(samplePoint + vec3(0.0,-sin(iTime),0));\n    float Uni =  unionSDF(sphereDist1,cubeDist1);\n    \n    float sphereDist2 = sphereSDF((samplePoint + vec3(-3.0,0.0,0))/1.2) * 1.2;\n    float cubeDist2 = cubeSDF(samplePoint + vec3(-3.0,sin(iTime),0));\n    float Inter =  intersectSDF(sphereDist2,cubeDist2);\n    \n    float sphereDist3 = sphereSDF((samplePoint + vec3(-8.0,0.0,0))/1.2) * 1.2;\n    float sphereDist13 = sphereSDF((samplePoint + vec3(-8.0,2.5*-sin(iTime),0))/1.2) * 1.2;\n    float sphereDist14 = sphereSDF((samplePoint + vec3(-8.0+ 2.5*-sin(iTime),0.0,0))/1.2) * 1.2;\n    \n    float Blend1 =  blendingSDF(sphereDist3,sphereDist13);\n    float Blend2 =  blendingSDF(sphereDist13,sphereDist14);\n    float Blend = blendingSDF(Blend1, Blend2);\n    \n    \n    float Twist = opTwist(samplePoint + vec3(6.0,0.0,0));\n    \n    float Displace = opDisplace(samplePoint + vec3(9.0,0.0,0));\n    \n    float sum = unionSDF(unionSDF(unionSDF(unionSDF(unionSDF(Diff,Uni),Inter),Blend),Twist),Displace);\n    \n    \n    \n    \n    return sum;\n}\n\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n  \n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 ,\n                          40.0,\n                          -40.0 );\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n \n    return color;\n}\n\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.0, -30.0);\n    \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = vec3(0.2, 0.2, 0.2);\n    vec3 K_d = vec3(0.7, 0.2, 0.2);\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtcfWj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtdBDs", "name": "Day 1: Uniforms", "author": "sdesai", "description": "I'm participating in a 100 day shader challenge. Where I create a shader a day for 100 days. I'm doing this challenge so I can learn how to write shaders. Hopefully by day 100 i'll have a great portfolio built up. ", "tags": ["day1"], "likes": 0, "viewed": 67, "date": "1541523726", "time_retrieved": "2024-06-20T19:24:47.602090", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(abs(sin(iTime)),0.9,0.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtdBDs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtGBRm", "name": "Supervision 1 work Julian", "author": "J2G8W", "description": "Julian Graphics Part 1A work", "tags": ["cambridge"], "likes": 0, "viewed": 68, "date": "1542106140", "time_retrieved": "2024-06-20T19:24:48.935039", "image_code": "// Settings\nconst float FOV_DEG = 80.0f;\nconst int MAX_STEPS = 300;\nconst vec3 LIGHT_DIR = vec3(1.0,1.0,-1.0);\n\n// Consts / Enumerations \nconst float EPS = 0.0001f;\nconst float DEG_TO_RAD = 0.0174533f;\nconst float M_PI = 3.14159265358979323846;\nconst int FLOOR_PLANE = 1;\nconst int OBJECT = 2;\nconst int OBJECT2 = 3;\nconst int NO_HIT = 0;\n\n///////////////////////////////////////////////////////////\n\nstruct Ray\n{\n    vec3 Orgin;\n    vec3 Direction;\n};\n\n//Utils\nmat3 CreateRotationX(float rotation)\n{\n    mat3 rotateX =\n     mat3(\n        1.0, 0.0, 0.0,\n\t\t0.0, cos(rotation), -sin(rotation),\n\t\t0.0, sin(rotation), cos(rotation)\n    );\n\n    return rotateX;\n}\n\nmat3 CreateRotationY(float rotation)\n{\n    mat3 rotateY = \n     mat3(\n        cos(rotation), 0.0, sin(rotation),\n\t\t0.0, 1.0, 0.0, \n\t\t-sin(rotation), 0.0, cos(rotation)\n    );\n\n    return rotateY;\n}\n\nmat3 CreateRotationZ(float rotation)\n{\n    mat3 rotateZ =\n    mat3(\n        cos(rotation), -sin(rotation), 0.0,\n\t\tsin(rotation), cos(rotation), 0.0,\n\t\t0.0, 0.0, 1.0\n    );\n\n    return rotateZ;\n}\n\n// SDFs\nfloat SphereSDF(vec3 p)\n{\n    return length(p)-1.1;\n}\n\nfloat TorusSDF(vec3 p, float R, float r)\n{  \n    float xy = length(p.xy) - R;\n    float z = length(vec2(xy,p.z))-r; \n    return z;\n}\n\nfloat BoxSDF(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0))-0.1;\n}\n\nfloat CylinderSDF(vec3 p,float radius)\n{   \n    float d = length(p.xz)-radius;\n    d = max(d,p.y-1.0);\n    d = max(d,-p.y-1.0);\n    return d;\n}\n\nfloat PlaneSDF(vec3 p, float y)\n{\n    return p.y+y;\n}\n\nvec3 RepeatX(vec3 p, float offset)\n{\n    p.x = mod(p.x,offset) - offset/2.0;\n    return p;\n}\n\nvec3 Twist(vec3 p, float amount)\n{\n    float c = cos(amount*p.y);\n    float s = sin(amount*p.y);\n    \n    // Create 2D rotation matrix\n    mat2 rm = mat2(c,-s,s,c);\n    p.xz *=rm;\n    return p;\n}\n\n//TODO: TASK1\nvoid Phong(vec3 L, vec3 N, vec3 V, float sh, out float d, out float s)\n{\n    // IMPLEMENT PHONG MODEL HERE\n    \n     \n    vec3 R = normalize(reflect(normalize(L),N));\n    \n    float ks = 1.0;\n    float kd = 1.0;\n    \n    d = kd * max(0.0,dot(normalize(L),N));    //Arbitarily set kd, ks  \n    s = ks * pow(max(0.0,dot(-R,normalize(V))),sh); //Assumed illumination is multiplied in later on\n}\n\n//Main scene distance field function\nfloat CombineSDF(vec3 p, inout int closest)\n{\n      vec3 pn = p*vec3(1.0,0.6,1.0);;\n      pn =  Twist(pn+vec3(0,0,-0.3),sin(iTime)*0.5);//CreateRotationY(iTime)* vec4(p,0);\n      float sd = SphereSDF(pn.xyz);  \n  \n      sd = max(BoxSDF(pn.xyz,vec3(0.95)),-sd); \n      float  torus = TorusSDF(CreateRotationY(iTime)*(p + CreateRotationY(iTime*0.3)*vec3(0.0,0.0,2.5)) ,0.9f,0.4f);\n      sd = min(torus,sd);      \n      float pd =  PlaneSDF(p,23.0); \n      float fin = min(sd,pd);\n      closest = OBJECT;\n      if(fin == pd)\n      { closest = FLOOR_PLANE;}\n      else if(fin == torus) \n      {closest = OBJECT2;}\n      return fin;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    int dummy = 0;\n    return \n    normalize(vec3(\n\t\tCombineSDF(vec3(p.x + EPS, p.y, p.z), dummy) - CombineSDF(vec3(p.x - EPS, p.y, p.z), dummy),\n\t\tCombineSDF(vec3(p.x, p.y + EPS, p.z), dummy) - CombineSDF(vec3(p.x, p.y - EPS, p.z), dummy),\n\t\tCombineSDF(vec3(p.x, p.y, p.z + EPS), dummy) - CombineSDF(vec3(p.x, p.y, p.z - EPS), dummy)\n\t\t));\n}\n\nfloat Trace(Ray r,inout int hit)\n{\n    hit = 0;\n    float t = 0.0f;\n    \n    for(int i =0; i < MAX_STEPS; ++i)\n    {\n       vec3 p = r.Orgin + r.Direction * t;\n       int closest = 0;     \n       float sd = CombineSDF(p, closest);\n           \n       if(sd < EPS)\n       {\n          hit = closest;\n          return t;\n       }\n       t += sd;\n    }\n    return 0.0f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Frag coord normalization \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    // Make center of the screen be (0,0)\n    uv = uv * 2.0 - 1.0; \n    // Aspect ratio\n    uv.x *= iResolution.x/iResolution.y;\n    \n    //FOV\n    float fovDist = tan(FOV_DEG  *0.5 * M_PI / 180.0); \n    uv *= fovDist;\n    \n    //TODO: TASK2\n    //CHANGE CAMERA POSITION AND ORIENTATION HERE:\n    Ray r;\n    \n    vec3 uv2 = vec3(uv,1.0);\t\t//Camera angle stuff tick\n    uv2 *= CreateRotationX(radians(35.0));\n    r.Direction = normalize(uv2);\n    r.Orgin = vec3(0,4,-5.0);\n    \n    \n    int hit = NO_HIT;   // indicates type of the object hit\n    float t = Trace(r,hit);  \n    vec3 hitAt = r.Orgin + r.Direction * t;\n    vec3 N = GetNormal(hitAt);\n    \n    float diff,spec = 0.0;\n    vec3 col = vec3(0); \n    \n    if(hit == OBJECT) // Block\n    {        \n        Phong(LIGHT_DIR,N,-r.Direction,50.0,diff,spec);\n        col =  vec3(0.2,0.04,0.2)+ vec3(0.5,0.0,0.5) * diff + vec3(1.0) * spec;\n    }\n    else if(hit == OBJECT2) // Torus\n    {\n        Phong(LIGHT_DIR,N,-r.Direction,50.0,diff,spec);\n        vec3 baseCol = vec3(clamp(cos(hitAt.y),0.0,1.0), clamp(sin(hitAt.y),0.0,1.0),0.0);\n        col =  0.3 * baseCol + 0.7 * baseCol * diff + vec3(1.0)*spec; \n    } \n    else if(hit == FLOOR_PLANE) // Floor\n    {\n        float ar = iResolution.x/iResolution.y;\n        vec2 planeUV = vec2(80.0+hitAt.x,hitAt.z)/200.0;\n        col = texture(iChannel0, planeUV).xyz; \n       \n        \n        //TODO: TASK3\n        // ADD FLOOR PATTERNS\n        \n        col *= abs(sin(hitAt.x*0.2));\t//Black pattern tick - Consant is arbitray relating to spacing\n        \n        vec3 purple = vec3(0.5,0,0.5);\n        col += 0.5 * abs(sin(hitAt.z*0.2)) * purple; //Purple pattern tick - Front constant does brightness\n\t\t\n        // Stationary Spotlight tick - uses min to avoid over brightness with close objects\n        //col = min(col*(20.0/length(hitAt)),col);\t\n        \n        //Moving Spotlight - again uses lots of arbitary constants\n        float move = abs(sin(iTime)*100.0);\n        vec3 spotPos =vec3(0,0,move); \n        col = min(col*(20.0/length(spotPos-hitAt)),col);\n    \t\n    }\n    \n    else // NO HIT - BACKGROUND COLOR\n    {\n      col = 0.5 + 0.5 * cos(uv.xyx + vec3(0,2.3,3.5));\n    }\n    \n    //TODO: TASK4\n    //SCREEN SPACE EFFECTS\n    \n    //Constant greyscale\n    //float grey = 0.21*col.x + 0.72*col.y + 0.07*col.z;\n    //col = vec3(grey);\n    \n    \n    //Left to Right transistion\n    float screenX = fragCoord.x/iResolution.x;\n    \n    float level = pow(screenX,2.8);\n    float grey = 0.21*col.x + 0.72*col.y + 0.07*col.z;\n    col = vec3(grey*(1.0-level)+col.x*level,grey*(1.0-level)+col.y*level,grey*(1.0-level)+col.z*level);\n    \n        \n    \n   // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtGBRm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtKBRz", "name": "Cosmic Force of Mu", "author": "beervgeer", "description": "My first shader! All learned from book of shaders, now at chapter https://thebookofshaders.com/07/.\nComments welcome.\n\nHomemade soundtrack: https://soundcloud.com/connect-3-1/loopje\n", "tags": ["gradients", "energy", "lightdance"], "likes": 17, "viewed": 2011, "date": "1541677228", "time_retrieved": "2024-06-20T19:24:49.553133", "image_code": "#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n#define time iTime\n#define resolution iResolution.xy\n#define size 0.544726\n#define lineSize 0.174972\n#define blur 0.227794\n#define grid 4.3651814\n#define grid2 4.1270218\n#define morph 2.30923\n#define delayAmount 0.044175148\n#define speed 0.466905\n\nfloat impulse( float k, float x )\n{\n    float h = k*x;\n    return h*exp(1.0-h);\n}\n\nfloat plot(float dis){\n   float pct = smoothstep(dis,dis+blur,0.5)-smoothstep(lineSize+dis,lineSize+dis+blur,0.5);     \n  return   pct ;\n}\n\nvec3 wooper(vec2 st, float timeCheck){\n    \n    vec3 color = vec3(0.0);\n    vec2 pos = vec2(0.5)-abs(st);\n\n    float r = length(pos)*2.0;\n    float a = atan(pos.y,pos.x);\n    \n    float gridSine = 5.+ (grid2*sin(timeCheck/5. * PI));\n    \n    r = fract(impulse(r,gridSine)*grid);\n    \n    float morphSine = 0.2 + ( 1.+sin(timeCheck/3. * PI) /2.)*morph;\n    float morphSine2 = 0.2 + ( 1.+sin(timeCheck/5. * PI) /2.)*morph;\n    float morphSine3 = 0.2 + ( 1.+sin(timeCheck/9. * PI) /2.)*morph;\n    \n    float f = ( size*cos(a*6. + timeCheck/3.) + size*cos(a*2. + timeCheck/2.))/2.;\n    float p = plot(1.-smoothstep(f,f+0.9,r*morphSine));\n    float f2 = ( size*cos(a*4. + timeCheck/3.) + size*cos(a*3. + timeCheck*7.))/2.;\n    float p2 = plot(1.-smoothstep(f2,f2+0.9,r*morphSine2));\n    float f3 = ( size*cos(a*7. + timeCheck/30.) + size*cos(a*3. + timeCheck*7.))/2.;\n    float p3 = plot(1.-smoothstep(f3,f3+0.9,r*morphSine3));\n    \n    color.r = p;\n    color.g = p2 *st.x;\n    color.b = p3;\n \n   return(color);\n}\n\nvec3 powerParticle(vec2 st){\n  \n    st.y += ((st.x*0.05)*sin(time/10.*PI)+(st.x*0.1)*sin(time/12.*PI))/2.;\n    st.x += ((st.y*0.05)*sin(time/10.*PI) + (st.y*0.1)*sin(time/12.*PI))/2.;\n    \n    vec2 pos = vec2(0.25+0.25*sin(time))-abs(st);\n\n    float r = length(pos);\n    float d = distance(st,vec2(0.5))* (sin(time/8.));\n    d = distance(vec2(.5),st);\n   vec3 colorNew = vec3(0);\n   \n   float delay = delayAmount;\n   float timerChecker = time * speed ;\n    for(int i=0;i<10;i++) {\n     \n      vec3 colorCheck = wooper(st, timerChecker+ float(i)*delay)* (1.-(float(i)/10.0));\n      colorNew+= colorCheck ;\n    }\n    \n    return(colorNew);\n}\n\nvec3 rgb2hsb( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                d / (q.x + e),\n                q.x);\n}\n\n//  Function from I√±igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 res = vec2(0);\n    res.x = resolution.x*0.5625;\n    res.y = resolution.y;\n    vec2 st = gl_FragCoord.xy/res;\n    st.x -= 0.35;\n    vec3 powerColor = powerParticle(st);\n    vec3 hue = rgb2hsb(powerColor);\n    hue.x = mod(time/10.,1.);\n    hue.y = 0.5;\n    float d = 1.-distance(vec2(.5),st)*2.;\n   \t\n    fragColor = vec4( (hsb2rgb(hue)*d )+(powerColor*d*0.5),1.0);\n \t\n}", "image_inputs": [{"id": "4lsGzr", "previewfilepath": "https://soundcloud.com/connect-3-1/loopje", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/connect-3-1/loopje", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtKBRz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtKfRD", "name": "boxcircle shape distance", "author": "abje", "description": "made another one, this time everything is centered but there is a circle and a box instead of just circles, also a 3d and 2d comparison.\n", "tags": ["3d", "raymarching", "distance", "union"], "likes": 4, "viewed": 373, "date": "1542063503", "time_retrieved": "2024-06-20T19:24:50.316986", "image_code": "#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nfloat box(vec2 p, vec2 s) {\n    vec2 q = abs(p)-s;\n    return length(max(q,0.0))+min(max(q.x,q.y),0.0);\n}\n\nfloat box(vec3 p, vec3 s) {\n    vec3 q = abs(p)-s;\n    return length(max(q,0.0))+min(max(max(q.x,q.y),q.z),0.0);\n}\n\nfloat boxcircle(vec2 p, float r0, float r1, float sign0, float sign1) {\n    \n    if (r1 < r0) {\n        vec2 q = abs(p);\n        q = vec2(min(q.x,q.y),max(q.x,q.y));\n        vec2 corner = vec2(sqrt(r0*r0-r1*r1),1);\n        vec2 q2 = q-corner;\n        vec2 n = vec2(-corner.y,corner.x);\n        if (min(sign1*dot(q2,n),-sign0*q2.x)>0.0) return length(q2);\n    }\n    \n    float len = -sign0*(length(p)-r0);\n    len = max(len,sign1*box(p,vec2(r1)));\n    return len;\n}\n\nfloat map(vec3 p, float r0, float r1, float sign0, float sign1) {\n    \n    if (r1 < r0) {\n        vec3 p2 = abs(p);\n        vec3 q = vec3(min(min(p2.x,p2.y),p2.z),0,max(max(p2.x,p2.y),p2.z));\n        q.y = dot(p2-q,vec3(1));\n        vec2 q2 = vec2(length(q.xy),q.z);\n\n        vec2 corner = vec2(sqrt(r0*r0-r1*r1),1);\n        q2 = q2-corner;\n        vec2 n = vec2(-corner.y,corner.x);\n        if (min(sign1*dot(q2,n),-sign0*q2.x)>0.0) return length(q2);\n    }\n    \n    float len = -sign0*(length(p)-r0);\n    len = max(len,sign1*box(p,vec3(r1)));\n    return len;\n}\n\nvec3 findnormal(vec3 p, float eps, float r0, float r1, float sign0, float sign1) {\n    vec2 e = vec2(0,eps);\n    \n    return normalize(vec3(\n        map(p+e.yxx,r0,r1,sign0,sign1),\n        map(p+e.xyx,r0,r1,sign0,sign1),\n        map(p+e.xxy,r0,r1,sign0,sign1))\n       -map(p      ,r0,r1,sign0,sign1));\n}\n\nfloat line( vec2 pa, vec2 ba) \n{\n    float h = max( dot(pa,ba)/dot(ba,ba), 0.0 );\n    return length( pa - ba*h );\n}\n\nfloat visualize(vec2 p, float r0, float r1, float sign0, float sign1) {\n    \n    float len = abs(length(p)-r0);\n    //len = min(len,abs(box(p,vec2(r1))));\n    //float len = 1000.0;\n    \n    if (r1 < r0) {\n        p = abs(p);\n        p = vec2(min(p.x,p.y),max(p.x,p.y));\n        vec2 corner = vec2(sqrt(r0*r0-r1*r1),1);\n        vec2 q = p-corner;\n        vec2 n = vec2(-corner.y,corner.x);\n\n        len = min(len,min(abs(line(q,-corner*sign0)),abs(line(q,vec2(0,1)*sign1))));\n    }\n    //if (min(sign0*dot(q,n),sign1*dot(q,vec2(-1,0)))>0.0)len = length(q);\n    \n    return max(0.25-abs(len)*iResolution.y/32.0,0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float r0 = mix(1.0,sqrt(2.0),sin(iTime)*0.5+0.5);\n    float r1 = 1.0;\n    float sign0 = 1.0;\n    float sign1 = 1.0;\n    \n    if (fragCoord.x > iResolution.x*0.5) {\n        // Normalized pixel coordinates (from 0 to 1)\n        vec2 uv = 2.0*(fragCoord*2.0-iResolution.xy)/iResolution.x*2.0;\n\t\tuv.x -= 2.0;\n\n        float len = boxcircle(uv,r0,r1,sign0,sign1);\n\n        //distance field coloring by iq https://www.shadertoy.com/view/4lcBWn\n        //this is a bit different, i wanted the border to be resolution independent\n        vec3 col = vec3(1.0) - sign(len)*vec3(0.1,0.4,0.7);\n        col *= 1.0 - exp(-iResolution.y*0.008*abs(len));\n        col *= 0.8 + 0.2*cos(iResolution.y*0.3*abs(len));\n        col = mix( col, vec3(1.0), max(1.0-abs(len)*iResolution.y*0.2,0.0));\n\n        fragColor = vec4(col*col, 1.0);\n\n        fragColor += visualize(uv,r0,r1,sign0,sign1);\n    } else {\n        vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.x*2.0;\n\t\tuv.x += 1.0;\n        \n        \n        vec3 ro = vec3(0,0,-3.0);\n        vec3 rd = normalize(vec3(uv,1));\n        \n        if (length(iMouse.xy) > 40.0) {\n            rd.yz *= rot(iMouse.y/iResolution.y*3.15-3.15*0.5);\n            rd.xz *= rot(iMouse.x/iResolution.x*3.15*2.0-3.15);\n            ro.yz *= rot(iMouse.y/iResolution.y*3.15-3.15*0.5);\n            ro.xz *= rot(iMouse.x/iResolution.x*3.15*2.0-3.15);\n        }\n        \n        \n        float d = 0.0;\n        \n        for( int i = 0; i < 200; i++) {\n            vec3 p = ro+rd*d;\n            float l = map(p,r0,r1,sign0,sign1)-0.2;\n            d += l;\n            if (d > 10.0 || l < d/iResolution.y) {\n                break;\n            }\n        }\n        if (d < 10.0) {\n            vec3 p = ro+rd*d;\n            \n            vec3 normal = findnormal(p,0.001,r0,r1,sign0,sign1);\n            vec3 light = vec3(-1.0/sqrt(3.0));\n            \n            \n            fragColor = vec4(normal*0.2+0.8,1);\n            fragColor *= max(dot(normal,-light),0.1);\n        } else {\n            fragColor = vec4(vec3(0.6,0.5,0.8)*(rd.y*0.5+0.5)\n                            +vec3(0.8,0.7,0.4)*(dot(rd,vec3(-1.0/sqrt(3.0)))*0.5+0.5),1);\n        }\n    }\n    // squareroot for 2.0 gamma\n    fragColor = sqrt(fragColor);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtKfRD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtKfRK", "name": "Data stream", "author": "Danielhu", "description": "command line magics", "tags": ["matrix"], "likes": 11, "viewed": 980, "date": "1543254415", "time_retrieved": "2024-06-20T19:24:50.323071", "image_code": "\n#define Hash(x) fract(sin(x) * 34214.0)\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float sp = Hash(floor(uv.x * 64.));\n    uv.y += sp * iTime;\n    float x_s = fract(uv.x * 64.);\n    float y_s = fract(uv.y * 18.);\n \n    float g = Hash(floor(uv.x * 410.) + Hash(floor(uv.y * 140.)));\n    \n    g = smoothstep(abs(g - 0.5), 0.2, 0.5);\n    g *= step(x_s, 0.6) * step(y_s, 0.8) * step(Hash(floor(uv.y * 18.)) + Hash(floor(uv.x * 64.)), 1.0);\n    \n    g *= (1. - sp * 0.5);\n    \n    fragColor = vec4(0. ,g , 0. , 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtKfRK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtKfWz", "name": "Mikki ", "author": "MikkiRich", "description": "Mikki  Rich ¬†", "tags": ["rich"], "likes": 0, "viewed": 271, "date": "1542273564", "time_retrieved": "2024-06-20T19:24:50.456343", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n     fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtKfWz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtKfzR", "name": "Sineless Noise", "author": "Jamie_Pendergast", "description": "Using dot products instead of sines can produce similar results.\n", "tags": ["noise"], "likes": 0, "viewed": 421, "date": "1541673618", "time_retrieved": "2024-06-20T19:24:50.456343", "image_code": "\nfloat dotnoise(float n)\n{\n    n = fract(n * 11.1);\n    float na = n-1.;\n    float nb = n + na;\n    float nc = n - na;\n    vec2 a = vec2(na,nb);\n    vec2 b = vec2(a.x + nb,a.y + nc);\n    vec2 c = vec2(a.y + n,a.y + n);\n    float d = dot(a,a);\n    d += dot(a,a);\n\td += dot(a,-b + 2142.); d *= 4.2;\n    d += dot(a + 142.,c); d *= 3.4;\n    d += dot(-b,c - 891.); d *= 4.3;\n    d += dot(b + 901.3,b); d *= 1.1;\n    d += dot(c,-c * 3.1); d *= 4.3;\n    return fract(d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv.x += iTime;\n    fragColor = vec4(dotnoise(dot(uv,uv)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtKfzR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtKfzz", "name": "Cosmic Force of Mu 2", "author": "beervgeer", "description": "Another experiment based on book of shaders code. Best in fullscreen.", "tags": ["triangles", "lines", "blue", "silver", "geometry", "energy"], "likes": 12, "viewed": 752, "date": "1541688695", "time_retrieved": "2024-06-20T19:24:50.965393", "image_code": "#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n#define time iTime\n#define resolution iResolution.xy\n#define size 0.0240525\n#define lineSize 0.24540144\n#define blur 0.227794\n#define grid 9.510933\n#define morph 5.2208757\n#define delayAmount 3.223359\n#define delay2 6.429779\n#define speed 0.39144516\n\n\nfloat impulse( float k, float x )\n{\n    float h = k*x;\n    return h*exp(1.0-h);\n}\n\nfloat plot(float dis){\n   float pct = smoothstep(dis,dis+blur,0.5)-smoothstep(lineSize+dis,lineSize+dis+blur,0.5);     \n  return   pct ;\n}\n\n\nvec3 rgb2hsb( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                d / (q.x + e),\n                q.x);\n}\n\n//  Function from I√±igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     vec2 res = vec2(0);\n    res.x = resolution.x*0.5625;\n    res.y = resolution.y;\n    \n   vec2 st = gl_FragCoord.xy/res;\n st.x -= 0.35;\n  float d = 0.0;\n\n  // Remap the space to -1. to 1.\n  st = st *2.-1.;\n  \n  // Number of sides of your shape\n  int N = 3;\n\n  // Angle and radius from the current pixel\n  vec3 colorNew = vec3(0);\n  \n  for(int i=0;i<5;i++) {\n      \n      float m = (float(i)/5.);\n      st.y += size*m*sin(time/3.);\n      float a = atan(st.x,st.y)+PI+(morph*m) + (0.03*m * sin(time));\n      float r = TWO_PI/float(N);\n      \n      d = cos(floor(.5+a/r)*r-a )*length(st);\n      d = impulse(d,delayAmount);\n      vec3 color = vec3(0.0);\n      float check = delay2 * (1.-length(st));\n      color.r = plot(fract(d*grid - check + time*speed));\n      color.g = plot(fract(d*grid - check + time*speed*0.8));\n      color.b = plot(fract(d*grid - check + time*speed*0.6));\n      colorNew+= ( color*m );\n    }\n    \n    \n \n   vec3 hue = rgb2hsb(colorNew);\n    hue.x = 0.6;\n    hue.y = 0.5;\n    hue.y = 0.5;\n    fragColor = vec4( hsb2rgb(hue)-colorNew*0.2 ,1.);\n\n  \n}", "image_inputs": [{"id": "4ts3zr", "previewfilepath": "https://soundcloud.com/connect-3-1/twinkles", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/connect-3-1/twinkles", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtKfzz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MttBW2", "name": "Stretching Squares", "author": "Turtle1331", "description": "I originally posted this on glslsandbox (http://glslsandbox.com/e#43300).  The pattern is easy to describe with line drawing, but I found it quite tricky to implement as a shader.  ", "tags": ["grid", "illusion", "squares"], "likes": 15, "viewed": 164, "date": "1541142106", "time_retrieved": "2024-06-20T19:24:50.965393", "image_code": "/*\n\nCopyright ¬© 2017 Turtle1331 (Turtle1331.github.io)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software\nand associated documentation files (the ‚ÄúSoftware‚Äù), to deal in the Software without\nrestriction, including without limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or\nsubstantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED ‚ÄúAS IS‚Äù, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\nBUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\nDAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = (fragCoord - iResolution.xy / 2.) / iResolution.x;\n\tp *= 10.;\n\t\n\tfloat c = 0.;\n\tfloat t = fract(iTime);\n\tt *= t;\n\tt *= 2. - t;\n\t\n\tp *= mat2(1., -t, t, 1.) / (t * t + 1.);\n\tvec2 q = floor(p + .5);\n\tp -= q;\n\tp *= mat2(1., t, -t, 1.);\n\t\n\tfloat d = 10.;\n\tfor (int i = 0; i < 4; i++) {\n\t\td = min(d, max(abs(p.x - .5 - t * .5), abs(p.y - .5 + t * .5)) - t * .5);\n\t\tp *= mat2(0., 1., -1., 0.);\n\t}\n\t\n\tc = (.5 - t * .5) * mod(floor(q.x) + floor(q.y) + ceil(sign(max(abs(p.x), abs(p.y)) - .5) * .5), 2.);\n\tc += (c - 1. + t * .5) * floor(sign(d) * .5);\n\tfragColor = vec4(c);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MttBW2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtVBDD", "name": "Caf√© wall illusion", "author": "Polytope", "description": "A famous optical illusion", "tags": ["illusion", "tiles"], "likes": 4, "viewed": 92, "date": "1542656620", "time_retrieved": "2024-06-20T19:24:50.965393", "image_code": "vec3 g = vec3(.5);\nvec3 w = vec3(1.);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n\n    uv *= 20.;\n    \n    float m = mod(uv.y,2.);\n    uv.x += step(1.,m)*iTime*.5;\n    \n    vec2 f_uv = fract(uv);\n    vec2 i_uv = floor(uv);\n    \n    f_uv.y += step( 1.5/iResolution.x*20., f_uv.y);\n    \n    float c = mod(i_uv.x,2.);\n    float d = mix(g,w,f_uv.y).x;\n    \n    vec3 col = vec3(c*d);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtVBDD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtVBRc", "name": "rose curve", "author": "WingStone", "description": "rose curve paint~\njust for fun~hhh\nyou can use x-coordinate to control size~", "tags": ["2d", "curve", "rose"], "likes": 6, "viewed": 390, "date": "1543564048", "time_retrieved": "2024-06-20T19:24:50.965393", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n\n    float theta = atan(uv.y, uv.x);\n    \n    float i = 5.0, j = 6.0;\n\n    float n = cos(0.003*i*iTime)*4.0+4.0;\n    float d = sin(0.003*j*iTime)*4.0+4.0;\n    \n    float c = abs(iMouse.x/iResolution.x*2.0 - 1.0);\t\t//using mouse to control \"c\"\n    \n    float r = 0.0;\n    \n    float factor = 0.0;\n    for(int i=0; i < 16; i++)\n    {\n        r = (sin(n/d*theta))*0.5 + c;\t\t\t//rose curve function\n        float tmp = abs(length(uv) - r);\n        factor += 1.0 - smoothstep(-1.5,1.5, tmp / fwidth(length(uv) - r));;\n        theta += 3.1415926*2.0;\n    }\n    \n    fragColor = vec4( 1. - factor );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtVBRc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtVBRG", "name": "Orbit Trapped", "author": "belfry", "description": "Playing with orbit traps for colouring.", "tags": ["orbittraps"], "likes": 8, "viewed": 196, "date": "1543019082", "time_retrieved": "2024-06-20T19:24:50.972217", "image_code": "#define reflections 2.\n#define optimized 0\n\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat box(vec3 p, vec3 b) {\n    vec3 a = abs(p) - b;\n    return max(a.x, max(a.y, a.z));\n}\n\nvec4 sdf(vec3 p) {\n    vec3 o = vec3(1000000.);\n    for (float i = 0.; i < 8.; i++) {\n        p -= vec3(1.83, 2.21, 1.916);\n        float a = 0.8 + sin(cos(p.x + p.y) + p.z) * .23;\n        p.xy *= mat2(cos(a), sin(a), -sin(a), cos(a));\n        p = abs(p);\n        a = 0.214;\n        p.yz *= mat2(cos(a), sin(a), -sin(a), cos(a));\n        p -= vec3(-.52, .6, -.23);\n        a = -0.21;\n        p.xz *= mat2(cos(a), sin(a), -sin(a), cos(a));\n        \n        vec3 d = p - vec3(cos(iTime * .07), sin(iTime * .15), 1.) * 2.;\n        vec2 d1 = p.xz;\n        o = min(o, vec3(dot(d, d), dot(d1, d1), p.z));\n    }\n    p -= vec3(1., 2., 3.);\n    return vec4(max(sphere(p, 2.3085), -box(p, vec3(.5, 1.15, 3.9))), o*vec3(.1, .1, .5));\n}\n\nvec3 normal(vec3 p) {\n    vec2 eps = vec2(.05, 0.);\n    float dx = sdf(p + eps.xyy).x - sdf(p - eps.xyy).x;\n    float dy = sdf(p + eps.yxy).x - sdf(p - eps.yxy).x;\n    float dz = sdf(p + eps.yyx).x - sdf(p - eps.yyx).x;\n    return normalize(vec3(dx, dy, dz));\n}\n\nfloat ambientOcclusion(vec3 p, vec3 n, float dist, float steps) {\n    float ao = 0.;\n    for (float i = 1.; i <= steps; i++) {\n        ao += sdf(p + n * (i / steps * dist)).x;\n    }\n    return clamp(ao / steps, 0., 1.);\n}\n\nfloat translucency(vec3 p, vec3 n, float dist, float steps) {\n    float ao = 0.;\n    for (float i = 1.; i <= steps; i++) {\n        ao += sdf(p - n * (i / steps * dist)).x;\n    }\n    return clamp(ao / steps, 0., 1.);\n}\n\nvec3 draw(vec3 pos, vec3 n, float i, float t, vec3 dir, vec3 o) {\n    vec3 lightDir = normalize(vec3(1.));\n    float diffuse = max(0., dot(lightDir, n)) * .4;\n    float specular = pow(max(0., dot(normalize(lightDir + dir), n)), 16.) * .25;\n    float rim = pow(1. - abs(dot(n, dir)), 5.) * .3;\n    vec3 lightColor = vec3(.9, .85, .7);\n    float ao = ambientOcclusion(pos, n, 0.25, 5.);\n    float trans = translucency(pos, n, .4, 3.)*0.25;\n    vec3 lighting = (ao + diffuse) * lightColor \n        + (rim + specular) * vec3(0.3, 0.4,.7)\n        + trans * vec3(0.9, .4, .4);\n    return o * lighting + vec3(i / 500., t / 50., i / 500.);\n}\n\n#if optimized\nbool trace(vec3 camPos, vec3 dir, out vec3 pos, out float i, out float t, out vec3 o) {\n    pos = vec3(0.);\n    float eps = .005;\n    i = 0.;\n    t = 0.;\n    bool hit = false;\n    vec4 d;\n    for (; i < 300.; i++) {\n        pos = camPos + t * dir;\n\t\td = sdf(pos);\n        if (abs(d.x) < eps * t) {\n            hit = true;\n            break;\n        }\n        t += d.x * .09;\n        if (t > 300.)\n            break;\n    }\n    o = d.yzw;\n    return true;\n}\n#else\nbool trace(vec3 camPos, vec3 dir, out vec3 pos, out float i, out float t, out vec3 o) {\n    pos = vec3(0.);\n    float eps = .005;\n    i = 0.;\n    t = 0.;\n    bool hit = false;\n    vec4 d;\n    for (; i < 1000.; i++) {\n        pos = camPos + t * dir;\n\t\td = sdf(pos);\n        if (abs(d.x) < eps * t) {\n            hit = true;\n            break;\n        }\n        t += d.x * .09;\n        if (t > 300.)\n            break;\n    }\n    o = d.yzw;\n    return hit;\n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixelPos = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\n    float fov = radians(60.);\n    vec3 dir = normalize(vec3(pixelPos, 1. / tan(.5 * fov)));\n    \n    float a = iTime * .1;\n    dir.xz *= mat2(cos(a), sin(a), -sin(a), cos(a));\n    vec3 camPos = vec3(3., -4., -11.);\n    \n    \n    float i, t;\n    vec3 pos, o;\n    bool hit = trace(camPos, dir, pos, i, t, o);\n    vec3 n = normal(pos);\n    \n    vec3 col = vec3(0.);\n    if (hit) {\n        col = draw(pos, n, i, t, -dir, o);\n        \n        for (float j = 1.; j <= reflections; j++) {\n            dir = reflect(dir, n);\n            hit = trace(camPos, dir, pos, i, t, o);\n            n = normal(pos);\n            vec3 reflCol = draw(pos, n, i, t, -dir, o);\n\n            col = mix(col, reflCol, .1 / j);\n        }\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtVBRG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtVBRz", "name": "Unreal mountain (fork)", "author": "Del", "description": "just a fork of ldm0's fractal shader with some scale animations", "tags": ["fractal", "fork", "anim"], "likes": 3, "viewed": 394, "date": "1541677928", "time_retrieved": "2024-06-20T19:24:50.973214", "image_code": "//Created by ldm0\n//personal website: ldm0.xyz\n//\n// original shader here: https://www.shadertoy.com/view/MtVfzR\n//\n// I just added a scale to see what it would do (click mouse for X and Y scale)\nvoid mainImage(out vec4 color, in vec2 coord)\n{\n    float m;\n    vec2 uv = coord.xy / iResolution.xy;\n    uv.x *= 2.;\n    uv.x -= 1.;\n    uv.y += .382;\n    \n    float sy = 1.0+sin(iTime);\n    float sx = (iMouse.z<0.5) ? 1.0 : sy;\n    \n    for (int i = 0; i < 35; ++i)\n    {\n        uv= abs(uv);\n        m = uv.x * uv.x  + uv.y * uv.y;\n        uv.x = uv.x/m - .217 * sx;\n        uv.y = uv.y/m - .105 * sy;\n    }\n\n    //m = smoothstep(0.0,1.0,m);\n    \n    \n    float m1 = m+.17;\n    float m2 = m1*1.65;\n    \n    color= vec4(vec3(m1,m2,m1), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtVBRz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtVBWR", "name": "ray-tracing demo", "author": "Arthas_me", "description": "it works now!\n", "tags": ["raytracing"], "likes": 4, "viewed": 556, "date": "1542246932", "time_retrieved": "2024-06-20T19:24:51.856387", "image_code": "const float PI = 3.141592653589793;\n\nconst vec3 ambient = vec3(0.01);\nconst vec3 lightColor = vec3(1.);\nvec3 lightOrigin = vec3(4.,4.,4.);\nconst float lightRadius = 3.;\nconst float lightIntensity = 10.;\n\nuint seed;\n\nuint pcg_hash(uint seed) {\n    uint state = seed * 747796405u + 2891336453u;\n    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n    return (word >> 22u) ^ word;\n}\nfloat rand_float() {\n    seed = pcg_hash(seed);\n    return float(seed) * (1.0 / 4294967296.0);\n}\nvec2 rand_vec2() {\n    float r = rand_float() * 2.0 * PI;\n    return vec2(cos(r), sin(r));\n}\nvec3 rand_vec3() {\n    float r = rand_float() * 2. * PI;\n    float z = rand_float() * 2. - 1.;\n    float z_scale = sqrt(1.0-z*z);\n    return vec3(cos(r)*z_scale, sin(r)*z_scale, z);\n}\nuint initSeed() {\n    uint seed = pcg_hash(uint(gl_FragCoord.x));\n    seed = pcg_hash(seed + uint(gl_FragCoord.y));\n    seed = pcg_hash(seed + uint(iTime*1000.));\n    return seed;\n}\n\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra) {\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h < 0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\nfloat plaIntersect(in vec3 ro, in vec3 rd, in vec4 p) {\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta, in float cr) {\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nbool intersect(in vec3 ro, in vec3 rd,\n    out vec3 pos, out vec3 normal, out vec3 color,\n    out float roughness, out bool light) {\n\n        vec3 sphPostions[4];\n        sphPostions[0] = vec3(-0.5, 0.25, -0.5);\n        sphPostions[1] = vec3(-0.5, 0.25, 0.5);\n        sphPostions[2] = vec3(0.5, 0.25, -0.5);\n        sphPostions[3] = vec3(0.5, 0.25, 0.5);\n\n        vec3 sphColors[4];\n        sphColors[0] = vec3(0.0, 0.5, 1.0);\n        sphColors[1] = vec3(1.0, 0.0, 0.5);\n        sphColors[2] = vec3(0.5, 1.0, 0.0);\n        sphColors[3] = vec3(1.0, 0.5, 0.5);\n\n        vec3 sphCenter;\n        float sphRadius = 0.25;\n\n        float tmin = 1e38, t;\n        bool hit = false;\n\n        vec4 plane = vec4(0.,1.,0.,0.);\n\n        t = plaIntersect(ro, rd, plane);\n        // t = (0.0 - ro.y) / rd.y;\n        if (t > 0.0 && t<tmin) {\n            tmin = t;\n            pos = ro + rd * t;\n            normal = vec3(0,1,0);\n            // coffee color\n            color = vec3(.8, .2, .2) * 0.25;\n            // coffee roughness\n            roughness = 0.;\n            light = false;\n            hit = true;\n        }\n        for (int i = 0; i < 4; i++) {\n            sphCenter = sphPostions[i];\n            t = sphIntersect(ro, rd, sphCenter, sphRadius).x;\n            if (t>0.0 && t<tmin) {\n                tmin = t;\n                pos = ro + t*rd;\n                normal = normalize(pos - sphCenter);\n\n                roughness = 0.1;\n                color = sphColors[i];\n\n                light = false;\n                hit = true;\n            }\n        }\n\n\n        t = sphIntersect(ro, rd, lightOrigin, lightRadius).x;\n        if (t>0.0 && t<tmin) {\n            tmin = t;\n            pos = ro + t*rd;\n            normal = normalize(pos - lightOrigin);\n            roughness = 0.;\n            color = lightColor;\n            light = true;\n            hit = true;\n        }\n\n        return hit;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    seed = initSeed();\n    vec2 jitter = vec2(rand_float(), rand_float()) ;\n\n    vec2 uv = (gl_FragCoord.xy + jitter) / iResolution.xy; // 0 <> 1\n    vec2 p = (-iResolution.xy + 2. * (gl_FragCoord.xy + jitter)) / iResolution.y; // -1 <> 1 by height\n\n    vec3 ro = vec3(2.*sin(iTime), 2., -2.*cos(iTime));\n    vec3 ta = vec3(0., 0., 0.);\n\n    lightOrigin = vec3(4.* cos(iTime/.7), 4., 4.* sin(iTime/.7));\n    \n    mat3 camera = setCamera(ro, ta, 0.);\n\n    vec3 rd = camera * normalize(vec3(p.xy, 2.2));\n\n\n    // rt\n    vec3 accum = vec3(0.);\n    vec3 mask = vec3(1.);\n    for (int i = 0; i < 10; i++) {\n        vec3 pos, normal, color;\n        float roughness;\n        bool light;\n\n        if (!intersect(ro, rd, pos, normal, color, roughness, light)) {\n            // hit nothing\n            accum += ambient * mask;\n            break;\n        }\n\n        // hit light\n        if (light) {\n            accum += lightColor * mask;\n            break;\n        }\n\n        // hit obj\n        mask *= color;\n\n\n        // pos to light origin ray test\n        vec3 _v3;\n        float _f;\n        vec3 lo = lightOrigin + rand_vec3() * lightRadius;\n        vec3 ld = normalize(lo - pos);\n        if (intersect(pos + ld * 0.0001, ld, _v3, _v3, _v3, _f, light) && light) {\n            float d = clamp(dot(normal, ld), 0.0, 1.0);\n            d *= pow(asin(lightRadius/distance(pos, lightOrigin)), 2.0);\n            accum += d * lightIntensity * lightColor * mask;\n        }\n\n        rd = normalize(mix(reflect(rd, normal), normal + rand_vec3(), roughness));\n        ro = pos + 0.0001 * rd;\n\n    }\n    accum = pow( accum, vec3(0.4545) );\n    fragColor = vec4(accum, 1.);\n\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtVBWR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtVcW1", "name": "GerstnerHeightmap", "author": "felipunkerito", "description": "2d Gerstner waves applied as a heightmap.", "tags": ["2d", "waves", "gerstner"], "likes": 6, "viewed": 866, "date": "1543447374", "time_retrieved": "2024-06-20T19:24:51.856387", "image_code": "//#define TWOD\n#define NOISE \n#define ITER    10\n#define EPS   1e-3\n#define STEPS  256\n#define FAR    20.\n\nmat2 rot( float a )\n{\n\n    return mat2( cos( a ), -sin( a ),\n                 sin( a ),  cos( a )\n               );\n\n}\n\nfloat hash( float a )\n{\n\n    return fract( sin( a * 42165.15 ) * 54513.51 );\n\n}\n\nfloat hash( vec2 uv )\n{\n\n    return fract( sin( uv.x * 452.153 + uv.y * 542.515 ) * 215.15 );\n\n}\n\nfloat noise( vec2 uv )\n{\n    \n    vec2 id = floor( uv );\n    vec2 lv = fract( uv );\n    lv *= lv * lv * ( 3.0 - 2.0 * lv );\n    \n    float bl = hash( id );\n    float br = hash( id + vec2( 1, 0 ) );\n    float b = mix( bl, br, lv.x );\n    \n    float tl = hash( id + vec2( 0, 1 ) );\n    float tr = hash( id + vec2( 1 ) );\n    float t = mix( tl, tr, lv.x );\n    \n    return mix( b, t, lv.y ); \n\n}\n\nfloat ger( vec2 uv )\n{\n    \n    float ste = 1.5;\n    float amp = 0.7;\n    float wav = 1.9;\n    float spe = 1.5;\n    uv.x *= 0.1;\n    uv.y *= 0.3;\n    #ifdef NOISE\n    uv.x += 1.0 * amp * cos( uv.x - iTime * spe + ( uv.x + uv.y ) + noise( uv + iTime ) );\n    uv.y += ste * amp * sin( uv.y - iTime * spe * 0.5 + ( uv.x + uv.y ) + noise( uv + 5.0 + iTime ) );\n    #else\n    uv.x += 1.0 * amp * cos( uv.x - iTime * spe + ( uv.x + uv.y ) );\n    uv.y += ste * amp * sin( uv.y - iTime * spe * 0.5 + ( uv.x + uv.y ) );\n    #endif\n    float c = 0.3 * sin( wav * ( amp ) * ( uv.x + uv.y ) + iTime );\n    \n    return c;\n\n}\n\nfloat fbm( vec2 uv )\n{\n\n    float res = 0.0, amp = 1.0, fre = 1.0, div = 0.0, tim = iTime;\n    \n    for( int i = 0; i < ITER; ++i )\n    {\n    \n        res += amp * ger( ( uv + tim ) * fre );\n        div += amp;\n        tim *= 0.7;\n        amp *= 0.5;\n        fre *= 2.0;\n    \n    }\n    \n    res /= div;\n    \n    return res;\n\n}\n\nfloat wav( vec2 uv )\n{\n\n    return 5.0 * fbm( uv );\n\n}\n\nfloat wavO( vec2 uv )\n{\n\n    return 5.0 * ger( uv );\n\n}\n\nfloat map( vec3 p )\n{\n\n    return p.y + wav( p.xz );\n\n}\n\nvec3 nor( vec3 p )\n{\n\n    vec2 e = vec2( EPS, 0.0 );\n    \n    return normalize( vec3( map( p + e.xyy ) - map( p - e.xyy ),\n                            map( p + e.yxy ) - map( p - e.yxy ),\n                            map( p + e.yyx ) - map( p - e.yyx )\n                          )\n                    );\n\n}\n\nfloat ray( vec3 ro, vec3 rd, out float d )\n{\n\n    float t = 0.0; d = 0.0;\n    \n    for( int i = 0; i < STEPS; ++i )\n    {\n    \n        vec3 p = ro + rd * t;\n        d = 0.3 * map( p );\n        \n        if( d < EPS || t > FAR ) break;\n        \n        t += d;\n    \n    }\n    \n    return t;\n\n}\n\nvec3 ren( vec3 ro, vec3 rd )\n{\n\n    float d = 0.0, t = ray( ro, rd, d );\n    vec3 col = vec3( 0 );\n    vec3 p =  ro + rd * t;\n    vec3 n = nor( p );\n    vec3 lig = normalize( vec3( 0.0, 0.5, 1.0 ) );\n    \n    float amb = 0.5 + 0.5 * n.y;\n    float ambO = 0.5 + 0.5 * -n.y;\n    float dif = max( 0.0, dot( lig, n ) );\n    float spe = pow( clamp( dot( lig, reflect( rd, n ) ), 0.0, 1.0 ), 16.0 ); \n    \n    float tex = wav( p.xz );\n    \n    col += 0.5 * vec3( 24, 49, 89 ) / 256.0;\n    \n    vec3 fint = mix( vec3( 0.2 ), vec3( 0 ), tex );\n    vec3 foa = mix( vec3( 0.5 ), vec3( 0 ), wav( p.xz * 7.0 ) );\n    \n    col += 0.3 * dif;\n    col += 0.3 * amb;\n    col += 0.1 * spe;\n    \n    col += -0.05 + fint;\n    col += -0.05 + foa;\n    \n    //col = mix( vec3( 0 ), vec3( 1 ), col );\n    //col -= 1.0;\n\n    //if( col.r >= 0.1 ) col += 0.2;\n    \n    col *= 0.5 / ( 1.0 + t * t * 0.1 );\n    \n    col *= sqrt( col );\n    \n    return col;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = ( -iResolution.xy + 2.0 * fragCoord ) / iResolution.y;\n    \n    vec3 ro = vec3( 0, 3.0, -iTime );\n    vec3 rd = normalize( vec3( uv, -1 ) );\n    ro.y -= wavO( ro.xz );\n    \n    ro.x += noise( ro.xz ) * 0.5;\n    rd.x += noise( ro.xz ) * 0.5;\n    \n    vec3 col = vec3( 0 );\n    \n    #ifdef TWOD\n    \n    col = mix( vec3( 0, 0.5, 0.6 ), vec3( 0 ), fbm( uv * 50.0 ) );\n    \n    #else\n    \n    float d = 0.0, t = ray( ro, rd, d );\n    \n    col = d < EPS ? ren( ro, rd ) : vec3( 0 );\n    \n    #endif\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtVcW1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtVfR3", "name": "dots and lights", "author": "CynicRus", "description": "Just experiments with this-))", "tags": ["lighting", "dots", "lights", "rotation"], "likes": 6, "viewed": 143, "date": "1543484207", "time_retrieved": "2024-06-20T19:24:51.862461", "image_code": "\nfloat hash (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvec2 hash2(vec2 uv) {\n\tfloat  k = hash(uv);\n\treturn vec2(k, hash(uv + k));\n}\n\n\nvec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d)\n{\n    return b + a*tan( iTime * 0.02*(c*t+d) );\n}\n//\n\nmat2 rotate(float a) {\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nvec3 layer(vec2 uv, float time) {\n\tvec3 col = vec3(0.);\n\tfor (int i = 0; i < 15; i++) {\n\t\tvec2 p = 2. * hash2(float(i) + vec2(2.)) - 1.;\n\t\tp -= vec2(sin(.1 * hash(float(i) + vec2(20., 50.)) * time + hash(float(i) + vec2(10.))), \n\t\t\t  cos(.1 * hash(float(i) + vec2(20., 40.)) * time + hash(float(i) + vec2(10.))));\n\t\tfloat k = (.5 * hash(float(i) + vec2(25., 75.)) + .01);\n\t\tcol += palette(k * 3., vec3(.5), vec3(.5), vec3(1.), vec3(.0, .33, .67)) / length(uv - p);\n\t}\n\tcol /= 120.;\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec2 st = fragCoord.xy / iResolution.xy;\n\tvec3 col = vec3(0.);\n\tfor (float i = 0.; i < 1.; i += .1) {\n\t\tuv *= rotate(iTime * 0.2 + i);\n\t\tfloat t = fract(iTime * .1 + i);\n\t\tfloat s = smoothstep(2., 0., t);\n\t\tfloat f = smoothstep(.8, 0., t)\n\t\t * smoothstep(.0, .2, t);\n\t\tcol += layer(uv * s, iTime) * f;\n\t}\n\tvec3 bb = texture(iChannel0, st - 0.5).rgb;\n\tfragColor = vec4(col * .2 + bb * .9, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtVfR3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtVfRR", "name": "Low-res default effect", "author": "slack", "description": "Low-res version of the default effect", "tags": ["test"], "likes": 2, "viewed": 135, "date": "1541661696", "time_retrieved": "2024-06-20T19:24:52.056371", "image_code": "float random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float scale = max(iResolution.x, iResolution.y);\n    vec2 uv = fragCoord/scale;\n    \n    float dot_size = 0.9;\n    \n    // Output to screen\n    float row = trunc(uv.y * 30.0);\n    float col = trunc(uv.x * 30.0);\n\n    // Time varying pixel color\n    vec3 color = 0.5 + 0.5*cos(iTime+0.15*vec3(col, row, col)+vec3(0,2,4));\n\n    \n    float px = fract(uv.x * 30.0);\n    float py = fract(uv.y * 30.0);\n    if (px < dot_size && py < dot_size) {\n      float distance = distance(vec2(px, py), vec2(dot_size/2.0));\n      float noise = 0.15*(random(uv)-0.5);\n      fragColor = vec4(color, 1.0) * vec4(1.0 - distance*distance + noise);\n    }\n    else\n      fragColor = vec4(0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtVfRR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtVfRw", "name": "Intro to gfx - supo work - ted", "author": "ejaw2", "description": "supo1", "tags": ["cam"], "likes": 0, "viewed": 44, "date": "1542132379", "time_retrieved": "2024-06-20T19:24:53.220242", "image_code": "\n// Settings\nconst float FOV_DEG = 80.0f;\nconst int MAX_STEPS = 300;\nconst vec3 LIGHT_DIR = vec3(1.0,1.0,-1.0);\n\n// Consts / Enumerations \nconst float EPS = 0.0001f;\nconst float DEG_TO_RAD = 0.0174533f;\nconst float M_PI = 3.14159265358979323846;\nconst int FLOOR_PLANE = 1;\nconst int OBJECT = 2;\nconst int OBJECT2 = 3;\nconst int NO_HIT = 0;\n\n///////////////////////////////////////////////////////////\n\nstruct Ray\n{\n    vec3 Orgin;\n    vec3 Direction;\n};\n\n//Utils\nmat3 CreateRotationX(float rotation)\n{\n    mat3 rotateX =\n     mat3(\n        1.0, 0.0, 0.0,\n\t\t0.0, cos(rotation), -sin(rotation),\n\t\t0.0, sin(rotation), cos(rotation)\n    );\n\n    return rotateX;\n}\n\nmat3 CreateRotationY(float rotation)\n{\n    mat3 rotateY = \n     mat3(\n        cos(rotation), 0.0, sin(rotation),\n\t\t0.0, 1.0, 0.0, \n\t\t-sin(rotation), 0.0, cos(rotation)\n    );\n\n    return rotateY;\n}\n\nmat3 CreateRotationZ(float rotation)\n{\n    mat3 rotateZ =\n    mat3(\n        cos(rotation), -sin(rotation), 0.0,\n\t\tsin(rotation), cos(rotation), 0.0,\n\t\t0.0, 0.0, 1.0\n    );\n\n    return rotateZ;\n}\n\n// SDFs\nfloat SphereSDF(vec3 p)\n{\n    return length(p)-1.1;\n}\n\nfloat TorusSDF(vec3 p, float R, float r)\n{  \n    float xy = length(p.xy) - R;\n    float z = length(vec2(xy,p.z))-r; \n    return z;\n}\n\nfloat BoxSDF(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0))-0.1;\n}\n\nfloat CylinderSDF(vec3 p,float radius)\n{   \n    float d = length(p.xz)-radius;\n    d = max(d,p.y-1.0);\n    d = max(d,-p.y-1.0);\n    return d;\n}\n\nfloat PlaneSDF(vec3 p, float y)\n{\n    return p.y+y;\n}\n\nvec3 RepeatX(vec3 p, float offset)\n{\n    p.x = mod(p.x,offset) - offset/2.0;\n    return p;\n}\n\nvec3 Twist(vec3 p, float amount)\n{\n    float c = cos(amount*p.y);\n    float s = sin(amount*p.y);\n    \n    // Create 2D rotation matrix\n    mat2 rm = mat2(c,-s,s,c);\n    p.xz *=rm;\n    return p;\n}\n\n//TODO: TASK1\nvoid Phong(vec3 L, vec3 N, vec3 V, float sh, out float d, out float s)\n{\n    // IMPLEMENT PHONG MODEL HERE\n    vec3 R = normalize(reflect(normalize(L),N));\n    d = max(0.0, dot(N, L));\n    s = pow(max(0.0, dot(R, V)), sh);\n}\n\n//Main scene distance field function\nfloat CombineSDF(vec3 p, inout int closest)\n{\n      vec3 pn = p*vec3(1.0,0.6,1.0);;\n      pn =  Twist(pn+vec3(0,0,-0.3),sin(iTime)*0.5);//CreateRotationY(iTime)* vec4(p,0);\n      float sd = SphereSDF(pn.xyz);  \n  \n      sd = max(BoxSDF(pn.xyz,vec3(0.95)),-sd); \n      float  torus = TorusSDF(CreateRotationY(iTime)*(p + CreateRotationY(iTime*0.3)*vec3(0.0,0.0,2.5)) ,0.9f,0.4f);\n      sd = min(torus,sd);      \n      float pd =  PlaneSDF(p,23.0); \n      float fin = min(sd,pd);\n      closest = OBJECT;\n      if(fin == pd)\n      { closest = FLOOR_PLANE;}\n      else if(fin == torus) \n      {closest = OBJECT2;}\n      return fin;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    int dummy = 0;\n    return \n    normalize(vec3(\n\t\tCombineSDF(vec3(p.x + EPS, p.y, p.z), dummy) - CombineSDF(vec3(p.x - EPS, p.y, p.z), dummy),\n\t\tCombineSDF(vec3(p.x, p.y + EPS, p.z), dummy) - CombineSDF(vec3(p.x, p.y - EPS, p.z), dummy),\n\t\tCombineSDF(vec3(p.x, p.y, p.z + EPS), dummy) - CombineSDF(vec3(p.x, p.y, p.z - EPS), dummy)\n\t\t));\n}\n\nfloat Trace(Ray r,inout int hit)\n{\n    hit = 0;\n    float t = 0.0f;\n    \n    for(int i =0; i < MAX_STEPS; ++i)\n    {\n       vec3 p = r.Orgin + r.Direction * t;\n       int closest = 0;     \n       float sd = CombineSDF(p, closest);\n           \n       if(sd < EPS)\n       {\n          hit = closest;\n          return t;\n       }\n       t += sd;\n    }\n    return 0.0f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Frag coord normalization \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    // Make center of the screen be (0,0)\n    uv = uv * 2.0 - 1.0; \n    // Aspect ratio\n    uv.x *= iResolution.x/iResolution.y;\n    \n    //FOV\n    float fovDist = tan(FOV_DEG  *0.5 * M_PI / 180.0); \n    uv *= fovDist;\n    \n    //TODO: TASK2\n    //CHANGE CAMERA POSITION AND ORIENTATION HERE:\n    Ray r;\n    r.Direction = normalize(vec3(uv,1.0)) * CreateRotationX(35.0 * DEG_TO_RAD);\n    r.Orgin = vec3(0,4.0,-5.0);\n    \n    int hit = NO_HIT;   // indicates type of the object hit\n    float t = Trace(r,hit);  \n    vec3 hitAt = r.Orgin + r.Direction * t;\n    vec3 N = GetNormal(hitAt);\n    \n    float diff,spec = 0.0;\n    vec3 col = vec3(0); \n    \n    if(hit == OBJECT) // Block\n    {        \n        Phong(LIGHT_DIR,N,-r.Direction,50.0,diff,spec);\n        col =  vec3(0.2,0.04,0.2)+ vec3(0.5,0.0,0.5) * diff + vec3(1.0) * spec;\n    }\n    else if(hit == OBJECT2) // Torus\n    {\n        Phong(LIGHT_DIR,N,-r.Direction,50.0,diff,spec);\n        vec3 baseCol = vec3(clamp(cos(hitAt.y),0.0,1.0), clamp(sin(hitAt.y),0.0,1.0),0.0);\n        col =  0.3 * baseCol + 0.7 * baseCol * diff + vec3(1.0)*spec; \n    } \n    else if(hit == FLOOR_PLANE) // Floor\n    {\n        float ar = iResolution.x/iResolution.y;\n        vec2 planeUV = vec2(80.0+hitAt.x,hitAt.z)/200.0;\n        col = (texture(iChannel0, planeUV).xyz); \n        //TODO: TASK3\n        // ADD FLOOR PATTERNS\n        col = col * abs(sin(hitAt.x * 0.4));\n        col = col + vec3(0.5,0.0,0.5)*abs(sin(hitAt.z*0.1)*0.4);\n        col = col * vec3(1,1,1) * (18.0/(distance(vec2(hitAt.x + 10.0 * sin(iTime), hitAt.z + 10.0 * sin(iTime)), uv)));\n        \n\n    }\n    \n    else // NO HIT - BACKGROUND COLOR\n    {\n      col = 0.5 + 0.5 * cos(uv.xyx + vec3(0,2.3,3.5));\n    }\n    //TODO: TASK3\n    //SCREEN SPACE EFFECTS\n    \n    float ltor = fragCoord.x/iResolution.x;\n    \n    float xcol = ((col.x * (1.0 + 2.0 * pow(ltor,2.8))) + (col.y * (1.0 - pow(ltor,2.8))) + (col.z * (1.0-pow(ltor,2.8))))/3.0;\n\tfloat ycol = ((col.x * (1.0 - pow(ltor,2.8))) + (col.y * (1.0 + 2.0 * pow(ltor,2.8))) + (col.z * (1.0-pow(ltor,2.8))))/3.0;\n    float zcol = ((col.x * (1.0 - pow(ltor,2.8))) + (col.y * (1.0-pow(ltor,2.8))) + (col.z * (1.0 + 2.0 * pow(ltor,2.8))))/3.0;\n    col = vec3(xcol, ycol, zcol);\n    \n   // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtVfRw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtVfWR", "name": "Box Tunnel (or Pyramid)", "author": "spelman7", "description": "An attempt at a uniform rectangular distance field with a moving center. My first shadertoy attempt. Fun to trick your brain into thinking the center point is at a higher or lower altitude than the rest of the field. ", "tags": ["distancefield", "tunnel", "palette", "stripes", "neon"], "likes": 5, "viewed": 201, "date": "1542253188", "time_retrieved": "2024-06-20T19:24:53.474688", "image_code": "\n\n// palette generator from iq: https://www.shadertoy.com/view/ll2GD3\nvec3 palette (float t) {\n\tvec3 a = vec3(0.5,0.5,0.5);\n\tvec3 b = vec3(0.5,0.5,0.5);\n\tvec3 c = vec3(2.0,1.0,0.0);\n\tvec3 d = vec3(0.5,0.20,0.25);\n\treturn a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // set up uv coordinate system\n    vec2 center = vec2(sin(iTime*0.25)/2., cos(iTime*0.31)/2.);\n\tvec2 p = ((2. * fragCoord.xy) - iResolution.xy) / iResolution.xy;\n    \n    // create uniform rectangular distance field\n\tfloat left = step(p.x, center.x);\n\tfloat bot = step(p.y, center.y);\n\tfloat pNewX1 = (p.x - center.x)/(1.0 - center.x);\n\tfloat pNewY1 = (p.y - center.y)/(1.0 - center.y);\n\tfloat pNewX2 = (p.x - center.x)/(-1.0 - center.x);\n\tfloat pNewY2 = (p.y - center.y)/(-1.0 - center.y);\n\tvec2 pNew = vec2(pNewX2*left+pNewX1*(1.0-left), pNewY2*bot+pNewY1*(1.0-bot));\n\tfloat dist = max(abs(pNew.x), abs(pNew.y));\n    \n    // generate your palette color based on the distance field\n\tvec3 palette = palette(fract(iTime*0.1+dist));\n    \n    // transform the distance field to create boxes with highlights\n\tfloat boxes = pow(dist, .3);\n\tboxes = sin(boxes * 300.) * 0.5 + 0.5;\n    boxes = smoothstep(-0.15, 0.95, boxes);\n\tfloat highlight = pow((boxes), 9.0)/2.;\n    \n    // final color\n\tvec3 color = (palette * boxes) + (palette * highlight);\n    color *= sqrt(dist);\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtVfWR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtyBzD", "name": "There has to be more to this.", "author": "Jamie_Pendergast", "description": "I really think I am catching onto discovering something great. ", "tags": ["fractal", "mandlebrot"], "likes": 4, "viewed": 378, "date": "1541979317", "time_retrieved": "2024-06-20T19:24:53.474688", "image_code": "//Jamie Pendergast\nvec2 c_mul(vec2 l, vec2 r)\n{\n    vec2 z;\n    z.x = (l.x * r.x) - (l.y * l.y);\n    z.y = (l.x * l.y) + (r.x * r.y);\n    return z;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 c = -1. + 2. * fragCoord/iResolution.xy;\n    c.x *= iResolution.x / iResolution.y;\n\tc *= exp(-iTime); // zooming    \n    c += vec2(-0.25,0.);  //panning\n\n    vec2 a = c; // first complex number\n    vec2 z = c; // second complex number\n   \t\n    vec2 offset = vec2(2.,0.); //definately play with this\n    int i = 0;\n    \n    for(i; i < 2000; ++i)\n    {\n        if(dot(z,z) > 512.) break;\n        a = c_mul(z - c,z - c) + c; //play with this\n        z = c_mul(a - offset,a) - c; //play with this\n    }\n    \n   \t\n    if(i == 2000)\n    {\n    \tfragColor = vec4(0.3,0.,0.,1.);\n        return;\n    }\n    \n    float rat = (float(i) - log2(log2(dot(z,z))));\n    rat /= 100.;\n    \n    \n    fragColor = vec4(rat,rat *= 2.,rat *= 2.,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtyBzD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtyfRW", "name": "Fugu Watching", "author": "dr2", "description": "Lots of fugu looking at you (mouseable)", "tags": ["lighting", "water", "repetition", "fish", "fibonacci"], "likes": 13, "viewed": 564, "date": "1541949105", "time_retrieved": "2024-06-20T19:24:56.287211", "image_code": "// \"Fugu Watching\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Lots of fugu looking at you (mouseable)\n\n#define AA  1   // optional antialiasing\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrRndBoxDf (vec3 p, vec3 b, float r);\nvec3 HsvToRgb (vec3 c);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec3 RotToDirLim (vec3 v1, vec3 v2, vec3 p, float aMax);\nvec2 Rot2D (vec2 q, float a);\nfloat Minv3 (vec3 p);\nvec3 Hashv3f (float p);\n\nvec3 fRep, kRep, bRep, pFish, ltDir, vuPos, fMove, fCell, fShift, eyeOff, vRan;\nfloat dstFar, tCur, szFac, bodyEx, spkEx, mthShp, eyeBlnk, fHue;\nint idObj;\nbool fOcc, kOcc, bOcc;\nconst int idBody = 1, idFinV = 2, idFinL = 3, idTail = 4, idMouth = 5, idEye = 6,\n   idKelp = 7, idBub = 8;\nconst float pi = 3.14159, phi = 1.618034;\n\nvec3 RdNonz (vec3 rd)\n{\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.y == 0.) rd.y = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  return rd;\n}\n\nvoid FSetConf (vec3 cId)\n{\n  vRan = Hashv3f (dot (cId, vec3 (31., 41., 51.)) + 99.);\n  bodyEx = SmoothBump (0.25, 0.75, 0.15, mod (0.4 * tCur + 2. * pi * vRan.y, 1.));\n  spkEx = SmoothBump (0.65, 0.85, 0.05, mod (0.2 * tCur + 2. * pi * vRan.y, 1.));\n  mthShp = sin (6. * tCur + 2. * pi * vRan.x);\n  szFac = 4. - 0.5 * vRan.x;\n  fShift = vec3 (0., 0., 4. * vRan.y - 2.);\n  fOcc = (vRan.z > 0.6);\n  eyeBlnk = vRan.y;\n  fHue = vRan.x;\n}\n\nfloat DstTail ()\n{\n  vec3 p;\n  float d, r, a;\n  p = pFish;\n  p.yz -= vec2 (0.11, -0.45);\n  p.xz = Rot2D (p.xz, 0.5 * cos (2. * tCur + 2. * pi * vRan.z - 3. * p.y + 5. * p.z));\n  a = 0.003 * sin (32. * atan (p.y, p.z));\n  r = length (p.yz);\n  d = min (0.01 - 0.008 * smoothstep (0.15, 0.25, r) - abs (p.x -\n     a * smoothstep (0.04, 0.08, r)), 0.35 - 0.05 * p.y - 0.01 * cos (a * 1024.) - r);\n  d = - SmoothMin (abs (p.y) + 0.3 * p.z, SmoothMin (-0.3 * abs (p.y) - p.z, d, 0.02), 0.02);\n  return d;\n}\n\nfloat DstFinL ()\n{\n  vec3 p;\n  float d, r, a, t, w;\n  p = pFish;\n  t = 5. * tCur + 2. * pi * vRan.z + 0.2 * sign (p.x);\n  p.x = abs (p.x) - 0.26 - 0.02 * bodyEx;\n  p.xz = Rot2D (p.xz, 0.4 * pi);\n  w = 0.15 * (1. - 0.15 * bodyEx) * (1. + 5. * length (p));\n  p.yz = Rot2D (p.yz, 0.2 + 0.5 * w * cos (t + 2. * atan (p.x, - p.y)) - 0.5 * pi);\n  p.xz = Rot2D (p.xz, 1.2 + 0.75 * bodyEx + w * sin (t - w) - 0.5 * pi);\n  a = atan (p.x, - p.y);\n  r = length (p.xy);\n  d = min (0.01 - 0.008 * smoothstep (0.2, 0.3, r) -\n     abs (p.z + 0.002 * sin (32. * a) * smoothstep (0.05, 0.08, r)),\n     0.4 - 0.15 * smoothstep (1., 3., abs (a)) - 0.01 * cos (32. * a) - r);\n  d = - SmoothMin (-0.2 * p.x + p.y, SmoothMin (p.x - 0.7 * p.y, d, 0.02), 0.02);\n  return d;\n}\n\nfloat DstFinV ()\n{\n  vec3 p;\n  float d, r, a, y;\n  p = pFish;\n  p.y = abs (p.y + 0.035 * bodyEx) - 0.035 * bodyEx - 0.26 - 0.02 * sign (p.y);\n  p.z -= -0.1;\n  y = smoothstep (0., 0.2, p.y);\n  p.z *= 1. - 0.3 * y * y;\n  a = - cos (4. * tCur + 2. * pi * vRan.z + 5. * (- p.y + p.z)) * (0.1 - 0.3 * p.z);\n  p.xz = Rot2D (p.xz, a);\n  p.xy = Rot2D (p.xy, a);\n  a = 0.0025 * sin (32. * atan (p.y, p.z));\n  r = length (p.yz);\n  d = min (0.01 - 0.009 * smoothstep (0.1, 0.2, r) -\n     abs (p.x + a * smoothstep (0.04, 0.1, r)), 0.22 - 0.015 * cos (512. * a) - r);\n  d = - SmoothMin (p.y + 0.4 * p.z, SmoothMin (-0.4 * p.y - p.z, d, 0.02), 0.02);\n  return d;\n}\n\nfloat DstMth ()\n{\n  vec3 p;\n  p = pFish;\n  p.yz -= vec2 (0.1, 0.34 + 0.02 * bodyEx - 2. * p.x * p.x);\n  p.xy *= vec2 (0.5 + 0.1 * mthShp, 1. - 0.5 * mthShp);\n  return PrCylAnDf (p, 0.015, 0.0015, 0.03);\n}\n\nvec4 SphFib (vec3 v, float n)\n{   // Keinert et al's inverse spherical Fibonacci mapping\n  vec4 b;\n  vec3 vf, vfMin;\n  vec2 ff, c;\n  float fk, ddMin, dd, a, z, ni;\n  ni = 1. / n;\n  fk = pow (phi, max (2., floor (log (n * pi * sqrt (5.) * dot (v.xy, v.xy)) /\n     log (phi + 1.)))) / sqrt (5.);\n  ff = vec2 (floor (fk + 0.5), floor (fk * phi + 0.5));\n  b = vec4 (ff * ni, pi * (fract ((ff + 1.) * phi) - (phi - 1.)));\n  c = floor ((0.5 * mat2 (b.y, - b.x, b.w, - b.z) / (b.y * b.z - b.x * b.w)) *\n     vec2 (atan (v.y, v.x), v.z - (1. - ni)));\n  ddMin = 4.1;\n  for (int j = 0; j < 4; j ++) {\n    a = dot (ff, vec2 (j - 2 * (j / 2), j / 2) + c);\n    z = 1. - (2. * a + 1.) * ni;\n    vf = vec3 (sin (2. * pi * fract (phi * a) + vec2 (0.5 * pi, 0.)) * sqrt (1. - z * z), z);\n    dd = dot (vf - v, vf - v);\n    if (dd < ddMin) {\n      ddMin = dd;\n      vfMin = vf;\n    }\n  }\n  return vec4 (sqrt (ddMin), vfMin);\n}\n\nvec2 SpkShp ()\n{\n  vec4 f4;\n  vec3 uf;\n  float s;\n  f4 = SphFib (normalize (pFish + vec3 (0., 0., 0.1)), 2048.);\n  uf = f4.yzw;\n  s = smoothstep (0.95, 0.99, dot (uf, normalize (vec3 (0., 0.24, 1.))));\n  if (s == 0.) s = smoothstep (0.92, 0.99, dot (uf, normalize (vec3 (0., 0.35, -1.))));\n  if (s == 0.) s = smoothstep (0.9, 0.94, dot (uf, normalize ((eyeOff - vec3 (0., 0., -0.03)) *\n     vec3 (sign (uf.x), 1., 1.))));\n  if (s == 0.) s = smoothstep (0.97, 0.99, dot (uf, normalize (vec3 (sign (uf.x), 0., 0.25))));\n  if (s == 0.) s = smoothstep (0.97, 0.99, dot (uf, normalize (vec3 (0., sign (uf.y), -0.1))));\n  return vec2 (1. - s, f4.x);\n}\n\nfloat DstBody ()\n{\n  vec3 p, q;\n  vec2 spk;\n  float spkLen, db, dt;\n  spk = SpkShp ();\n  spkLen = spk.x * (1. - smoothstep (0.001, 0.02, spk.y)) * (0.001 + 0.04 * spkEx);\n  p = pFish;\n  p.y -= -0.03 * bodyEx;\n  p.x *= 1. + 1.5 * (p.y + 0.2) * (p.y + 0.2);\n  p.xy *= 1. + 0.5 * smoothstep (0., 0.5, - p.z);\n  q = (p - vec3 (0., 0.2 + 0.025 * bodyEx, 0.5 * (p.y - 0.2) - 0.14)) * vec3 (1.4, 1.7, 0.6);\n  dt = PrSphDf (q, 0.4 - 0.2 * smoothstep (0., 1.5, 1.3 - p.z) + spkLen);\n  q = p * vec3 (1.2, 1.2, 1. + 0.5 * smoothstep (0., 0.5, - p.y - p.z));\n  db = PrSphDf (q, 0.37 + smoothstep (0., 1.7, - p.z) + 0.03 * bodyEx + spkLen);\n  q = pFish;\n  q.yz -= vec2 (0.1, 0.1);\n  q.xy *= vec2 (0.5, 1.) + vec2 (0.1, -0.4) * mthShp;\n  return SmoothMin (max (db, - PrCylDf (q, 0.02, 0.3)), dt, 0.05);\n}\n\nfloat FishDf (vec3 p)\n{\n  float dMin, d, a, c;\n  p += fShift;\n  p /= szFac;\n  d = PrSphDf (p, 0.8);\n  if (d < 0.1) {\n    c = cos (2. * tCur + 2. * pi * vRan.x);\n    a = -0.5 * smoothstep (-0.2, 1.1, - p.z) * c;\n    p.xz = Rot2D (p.xz, 0.1 * c + a);\n    p.xy = Rot2D (p.xy, 0.5 * a);\n    pFish = p;\n    dMin = 0.3 * DstBody ();\n    idObj = idBody;\n    d = DstMth ();\n    if (abs (d) < dMin) idObj = idMouth;\n    dMin = SmoothMin (dMin, d, 0.01);\n    d = 0.6 * DstTail ();\n    if (d < dMin) idObj = idTail;\n    dMin = SmoothMin (dMin, d, 0.01);\n    d = 0.6 * DstFinL ();\n    if (d < dMin) idObj = idFinL;\n    dMin = SmoothMin (dMin, d, 0.01);\n    d = 0.7 * DstFinV ();\n    if (d < dMin) idObj = idFinV;\n    dMin = SmoothMin (dMin, d, 0.01);\n    p.x = abs (p.x);\n    d = PrSphDf (p - eyeOff, 0.13);\n    if (d < dMin) idObj = idEye;\n    dMin = SmoothMin (dMin, d, 0.02);\n  } else dMin = d;\n  return szFac * dMin;\n}\n\nfloat FObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p, cId, cIdP, s;\n  float dHit, d;\n  rd = RdNonz (rd);\n  dHit = 0.1;\n  cIdP = vec3 (-99.);\n  for (int j = 0; j < 120; j ++) {\n    p = ro + rd * dHit + fMove;\n    cId = floor (p / fRep);\n    if (cId != cIdP) {\n      cIdP = cId;\n      FSetConf (cId);\n    }\n    d = fOcc ? FishDf (p - fRep * (cId + 0.5)) : dstFar;\n    s = (fRep * (cId + step (0., rd)) - p) / rd;\n    d = min (d, abs (Minv3 (s)) + 0.01);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 FObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.001, -0.001);\n  v = vec4 (- FishDf (p + e.xxx), FishDf (p + e.xyy), FishDf (p + e.yxy), FishDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvoid KSetConf (vec3 cId)\n{\n  vRan = Hashv3f (dot (cId.xz, vec2 (37., 47.)));\n  kOcc = (vRan.x * smoothstep (7., 10., length (cId)) > 0.9);\n}\n\nfloat KelpDf (vec3 p)\n{\n  p.xz -= 1.;\n  p.xz = Rot2D (p.xz, p.y * pi * floor (vRan.y * 10.) / 40.);\n  return 0.9 * PrRndBoxDf (p, vec3 ((0.1 + 0.5 * vRan.x) *\n    (0.8 + 0.2 * sin (0.2 * pi * p.y)), 30., 0.02 + 0.01 * vRan.y), 0.005);\n}\n\nfloat KObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p, cId, cIdP, s;\n  float dHit, d;\n  rd = RdNonz (rd);\n  dHit = 0.1;\n  cIdP = vec3 (-99.);\n  for (int j = 0; j < 80; j ++) {\n    p = ro + rd * dHit;\n    p.x += sin (tCur + p.y * 0.2) * 0.5;\n    cId = floor (p / kRep);\n    if (cId != cIdP) {\n      cIdP = cId;\n      KSetConf (cId);\n    }\n    d = kOcc ? KelpDf (p - kRep * (cId + 0.5)) : dstFar;\n    s = (kRep * (cId + step (0., rd)) - p) / rd;\n    d = min (d, abs (Minv3 (s)) + 0.01);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 KObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.001, -0.001);\n  v = vec4 (- KelpDf (p + e.xxx), KelpDf (p + e.xyy), KelpDf (p + e.yxy), KelpDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvoid BSetConf (vec3 cId)\n{\n  vRan = Hashv3f (dot (cId, vec3 (33., 43., 53.)));\n  bOcc = (vRan.x * smoothstep (2., 5., length (cId)) > 0.95);\n}\n\nfloat BubDf (vec3 p, vec3 pw)\n{\n  vec3 b, vr;\n  float s, t, r, d, a;\n  t = tCur;\n  vr = vRan - 0.5;\n  s = pow (fract (dot (vr, vec3 (1.)) * 100.), 4.);\n  pw.y += t;\n  pw = 7. * pw + 2. * pi * vr + vec3 (t, 0., t);\n  d = sin ((t + vr.y) * 3. * pi * (1. - s)) * 0.3 * vr.x * (1. - s);\n  a = vr.z * t;\n  b = d * vec3 (cos (a), 0., sin (a));\n  r = 0.1 - 0.05 * s + dot (sin (pw), vec3 (1.)) * s * 0.02;\n  return 0.9 * PrSphDf (p - b, r);\n}\n\nfloat BObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p, cId, cIdP, s;\n  float dHit, d;\n  rd = RdNonz (rd);\n  dHit = 0.1;\n  cIdP = vec3 (-99.);\n  for (int j = 0; j < 80; j ++) {\n    p = ro + rd * dHit;\n    p.y -= tCur * 4. + 40.;\n    cId = floor (p / bRep);\n    if (cId != cIdP) {\n      cIdP = cId;\n      BSetConf (cId);\n    }\n    d = bOcc ? BubDf (p - bRep * (cId + 0.5), p) : dstFar;\n    s = (bRep * (cId + step (0., rd)) - p) / rd;\n    d = min (d, abs (Minv3 (s)) + 0.01);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 BObjNf (vec3 p, vec3 pw)\n{\n  vec4 v;\n  vec2 e = vec2 (0.001, -0.001);\n  v = vec4 (- BubDf (p + e.xxx, pw), BubDf (p + e.xyy, pw), BubDf (p + e.yxy, pw),\n     BubDf (p + e.yyx, pw));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec4 FishCol (vec3 p)\n{\n  vec4 col4;\n  vec3 ve;\n  vec2 spk;\n  float s, t;\n  col4 = vec4 (HsvToRgb (vec3 (0.15 + 0.8 * fHue, 0.8, 1.)), 0.2);\n  if (idObj == idBody) {\n    col4.rgb *= 0.7 + 0.3 * smoothstep (-0.1, 0.1, pFish.y);\n    spk = SpkShp ();\n    col4.rgb = mix (col4.rgb, vec3 (0.9, 0.7, 0.7), 0.5 * smoothstep (0., 0.01, spk.x) *\n       SmoothBump (0.25, 0.75, 0.1, mod (128. * atan (0.7 * pFish.x, pFish.y - 0.1) / pi, 1.)));\n    col4 = mix (col4, vec4 (0.9, 0.9, 0.95, 0.5), 0.5 * step (0.02, spk.x) * step (spk.y, 0.02));\n  } else if (idObj == idMouth) {\n    col4.rgb = mix (col4.rgb, vec3 (0.9, 0.7, 0.7), 0.5);\n  } else if (idObj == idFinV || idObj == idFinL) {\n    col4.rgb = mix (col4.rgb, vec3 (1.), 0.3 * smoothstep (0.4, 0.5, length (pFish)));\n  } else if (idObj == idTail) {\n    col4.rgb = mix (col4.rgb, vec3 (1.), 0.3 * smoothstep (0.6, 0.7, length (pFish)));\n  } else if (idObj == idEye) {\n    if (abs (pFish.y - eyeOff.y - 0.04) < 0.001 + 0.1 * SmoothBump (0.13, 0.87, 0.07,\n       mod (0.5 * tCur + 2. * pi * eyeBlnk, 1.))) {\n      ve = eyeOff * vec3 (sign (pFish.x), 1., 1.) * szFac + fCell - (fShift + fMove);\n      ve = RotToDirLim (normalize (vuPos - ve), vec3 (sign (pFish.x), 0., 0.), p - ve, 0.35 * pi);\n      s = length (ve.yz) / szFac;\n      t = (1. - step (s, 0.06 + 0.02 * SmoothBump (0.25, 0.75, 0.25,\n         mod (12. * atan (ve.y, ve.z) / pi, 1.))));\n      col4.rgb = vec3 (1.) * t * (0.5 + 0.5 * smoothstep (0.07, 0.1, s));\n      col4.a = (t == 0.) ? -1. : 0.3;\n    } else idObj = idBody;\n  }\n  return col4;\n}\n\nfloat WatShd (vec3 rd)\n{\n  vec2 p;\n  float t, h;\n  rd = RdNonz (rd);\n  p = 20. * rd.xz / rd.y;\n  t = tCur * 2.;\n  h = sin (2. * p.x + 0.77 * t + sin (0.73 * p.y - t)) + sin (0.81 * p.y - 0.89 * t +\n     sin (0.33 * p.x + 0.34 * t)) + 0.5 * (sin (1.43 * p.x - t) + sin (0.63 * p.y + t));\n  h *= 0.04 * smoothstep (0.5, 1., rd.y);\n  return h;\n}\n\nfloat TurbLt (vec3 p, vec3 vn, float t)\n{\n  vec4 b;\n  vec2 q, qq;\n  float c, tt;\n  q = 2. * pi * mod (vec2 (dot (p.yzx, vn), dot (p.zxy, vn)), 1.) - 256.;\n  t += 11.;\n  c = 0.;\n  qq = q;\n  for (float j = 1.; j <= 7.; j ++) {\n    tt = t * (1. + 1. / j);\n    b = sin (tt + vec4 (- qq + vec2 (0.5 * pi, 0.), qq + vec2 (0., 0.5 * pi)));\n    qq = q + tt + b.xy + b.zw;\n    c += 1. / length (q / sin (qq));\n  }\n  return clamp (pow (abs (1.25 - abs (0.167 + 40. * c)), 8.), 0., 1.);\n}\n\nvec3 BgCol (vec3 rd)\n{\n  float t, gd, b;\n  t = tCur * 4.;\n  b = dot (vec2 (atan (rd.x, rd.z), 0.5 * pi - acos (rd.y)), vec2 (2., sin (rd.x)));\n  gd = clamp (sin (5. * b + t), 0., 1.) * clamp (sin (3.5 * b - t), 0., 1.) +\n     clamp (sin (21. * b - t), 0., 1.) * clamp (sin (17. * b + t), 0., 1.);\n  return mix (vec3 (0., 0.5, 0.8), vec3 (0.25, 0.4, 1.), 0.5 + 0.5 * rd.y) *\n     (0.24 + 0.44 * (rd.y + 1.) * (rd.y + 1.)) * (1. + gd * 0.05);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, bgCol, vn, cId, p;\n  float dstObj, d;\n  fRep = vec3 (6., 6.5, 11.5);\n  kRep = vec3 (4., 40., 4.);\n  bRep = vec3 (4., 4., 4.);\n  eyeOff = vec3 (0.13);\n  fMove = vec3 (0., 0., -1.5 * tCur);\n  bgCol = BgCol (rd);\n  dstObj = dstFar;\n  d = FObjRay (ro, rd);\n  if (d < dstObj) {\n    dstObj = d;\n  }\n  d = KObjRay (ro, rd);\n  if (d < dstObj) {\n    dstObj = d;\n    idObj = idKelp;\n  }\n  d = BObjRay (ro, rd);\n  if (d < dstObj) {\n    dstObj = d;\n    idObj = idBub;\n  }\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    if (idObj <= idEye) {\n      p = ro + fMove;\n      cId = floor (p / fRep);\n      FSetConf (cId);\n      fCell = fRep * (cId + 0.5);\n      vn = FObjNf (p - fCell);\n      col4 = FishCol (ro);\n    } else if (idObj == idKelp) {\n      p = ro;\n      p.x += sin (tCur + p.y * 0.2) * 0.5;\n      cId = floor (p / kRep);\n      KSetConf (cId);\n      vn = KObjNf (p - kRep * (cId + 0.5));\n      col4 = vec4 (0.2, 0.7, 0.3, 0.);\n    } else if (idObj == idBub) {\n      p = ro;\n      p.y -= tCur * 4. + 40.;\n      cId = floor (p / bRep);\n      BSetConf (cId);\n      vn = BObjNf (p - bRep * (cId + 0.5), p);\n      col4 = vec4 (0.7 * mix (vec3 (1.), BgCol (reflect (rd, vn)), 0.7), 0.5);\n    }\n    if (col4.a >= 0.) {\n      col = col4.rgb * (0.1 + 0.2 * bgCol + 0.7 * max (dot (vn, ltDir), 0.)) +\n         col4.a * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n      if (idObj != idEye) col += 0.1 * TurbLt (0.5 * ro, abs (vn), 0.5 * tCur) *\n         smoothstep (-0.3, -0.1, vn.y);\n      else col = mix (col, vec3 (1., 0., 0.), 0.1 * dot (vn, - rd));\n      if (idObj == idBub) col *= 0.5 + 0.5 * clamp (rd.y + 1., 0., 1.5);\n    } else {\n      rd = reflect (rd, vn);\n      col = 0.5 * (BgCol (rd) + WatShd (rd));\n    }\n    col = mix (col, bgCol, smoothstep (0.3, 0.95, dstObj / dstFar));\n  } else col = bgCol + WatShd (rd);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = pi + 2. * pi * SmoothBump (0.25, 0.75, 0.25, mod (0.01 * tCur, 1.));\n  el = -0.22 * pi * sin (0.017 * pi * tCur);\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.6 * pi * mPtr.y;\n  }\n  el = clamp (el, -0.3 * pi, 0.3 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n     mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0.01);\n  vuPos = ro;\n  ltDir = normalize (vec3 (0.2, 1., -0.2));\n  dstFar = 50.;\n  col = vec3 (0.);\n  if (abs (uv.y) < 0.85) {\n#if ! AA\n    const float naa = 1.;\n#else\n    const float naa = 3.;\n#endif  \n    sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n    for (float a = 0.; a < naa; a ++) {\n      rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n         sr * (0.667 * a + 0.5) * pi), 2.));\n      col += (1. / naa) * ShowScene (ro, rd);\n    }\n    col = pow (col, vec3 (0.8));\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrRndBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec3 RotToDirLim (vec3 v1, vec3 v2, vec3 p, float aMax)\n{\n  vec3 n;\n  float c;\n  n = normalize (cross (v1, v2));\n  c = max (dot (v1, v2), cos (aMax));\n  return c * p + sqrt (1. - c * c) * cross (n, p) + (1. - c) * dot (n, p) * n;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nconst float cHashM = 43758.54;\n\nvec3 Hashv3f (float p)\n{\n  return fract (sin (p + vec3 (37., 39., 41.)) * cHashM);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtyfRW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Mtyfzt", "name": "Plasma Sphere", "author": "dr2", "description": "Swirling colors; mouse overrides sphere motion", "tags": ["plasma"], "likes": 9, "viewed": 544, "date": "1543595184", "time_retrieved": "2024-06-20T19:24:56.303694", "image_code": "// \"Plasma Sphere\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Swirling colors; mouse overrides sphere motion.\n// Started from plasma idea in \"Magnetismic\" by nimitz.\n\n#define AA  0\n\nfloat PrSphAnDf (vec3 p, float r, float w);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nvec2 Rot2D (vec2 q, float a);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec3 HueToRgb (float c);\nfloat Fbm3s (vec3 p, float t);\n\nvec3 ltDir, qnHit;\nfloat dstFar, tCur, aRot, redFac;\nint idObj;\nbool doRot;\nconst float pi = 3.14159, phi = 1.618034;\n\nfloat SphFib (vec3 v, float n)\n{   // Keinert et al's inverse spherical Fibonacci mapping\n  vec4 b;\n  vec3 vf;\n  vec2 ff, c;\n  float fk, ddMin, a, z, ni;\n  ni = 1. / n;\n  fk = pow (phi, max (2., floor (log (n * pi * sqrt (5.) * dot (v.xy, v.xy)) /\n     log (phi + 1.)))) / sqrt (5.);\n  ff = vec2 (floor (fk + 0.5), floor (fk * phi + 0.5));\n  b = vec4 (ff * ni, pi * (fract ((ff + 1.) * phi) - (phi - 1.)));\n  c = floor ((0.5 * mat2 (b.y, - b.x, b.w, - b.z) / (b.y * b.z - b.x * b.w)) *\n     vec2 (atan (v.y, v.x), v.z - (1. - ni)));\n  ddMin = 4.1;\n  for (int j = 0; j < 4; j ++) {\n    a = dot (ff, vec2 (j - 2 * (j / 2), j / 2) + c);\n    z = 1. - (2. * a + 1.) * ni;\n    vf = vec3 (sin (2. * pi * fract (phi * a) + vec2 (0.5 * pi, 0.)) * sqrt (1. - z * z), z);\n    ddMin = min (ddMin, dot (vf - v, vf - v));\n  }\n  return sqrt (ddMin);\n}\n\nfloat FibHole (vec3 p)\n{\n  return smoothstep (0.032, 0.036, SphFib (p, 2048.));\n}\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float rad, dMin, d;\n  dMin = dstFar;\n  rad = 1.;\n  for (int j = 0; j < 2; j ++) {\n    q = p.yzx;\n    if (doRot) {\n      if (j == 0) q.xz = Rot2D (q.xz, aRot);\n      else q.yz = Rot2D (q.yz, aRot);\n    }\n    d = 0.7 * PrSphAnDf (q, rad, -0.005 + 0.01 * FibHole (normalize (q)));\n    DMIN (1);\n    rad *= redFac;\n  }\n  rad = 1.;\n  p.xz = Rot2D (p.xz, 0.25 * pi);\n  for (int j = 0; j < 3; j ++) {\n    q = p;\n    if (j == 1) q.xy = Rot2D (q.xy, 0.5 * pi);\n    else if (j == 2) q.yz = Rot2D (q.yz, -0.5 * pi);\n    d = PrTorusDf (q.xzy, 0.01 * rad, 1.02 * rad);\n    DMIN (2);\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float d, h;\n  d = 0.;\n  for (int j = 0; j < 120; j ++) {\n    h = ObjDf (ro + d * rd);\n    d += h;\n    if (h < 0.0005 || d > dstFar) break;\n  }\n  return d;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.00012, -0.0001);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat BallHit (vec3 ro, vec3 rd, float bRad)\n{\n  float h, b, d;\n  b = dot (rd, ro);\n  d = b * b + bRad * bRad - dot (ro, ro);\n  h = dstFar;\n  if (d > 0.) {\n    h = - b - sqrt (d);\n    qnHit = (ro + h * rd) / bRad;\n  }\n  return h;\n}\n\nvec4 PlasCol (vec3 p, vec3 rd, float d, float bRad)\n{\n  vec4 col4, c4;\n  vec3 q;\n  float w, h;\n  h = mod (0.1 * tCur, 1.);\n  d += 0.01;\n  col4 = vec4 (0.);\n  for (int j = 0; j < 64; j ++) {\n    q = p + d * rd;\n    if (length (q) > bRad || col4.a >= 1.) break;\n    q.xz = Rot2D (q.xz, -2. * pi * h);\n    w = dot (q, q);\n    q /= w + 0.05;\n    q.xz = Rot2D (q.xz, q.y);\n    q.xy = Rot2D (q.xy, -1.1 * q.z);\n    q /= dot (q, q) + 100. * (1.05 + sin (0.17 * tCur));\n    c4 = vec4 (HueToRgb (h), 1.) * clamp (4. * Fbm3s (30. * q, 0.5 * tCur) - 2. - w, 0., 1.) +\n       vec4 (HueToRgb (mod (h + 0.4, 1.)), 1.) * clamp (4. * Fbm3s (33. * q.yzx, 0.5 * tCur) -\n       2. - w, 0., 1.);\n    d += (bRad / 64.) * (1. - 0.25 * c4.a);\n    col4 += 0.02 * (1. - col4.a) * c4.a * c4;\n  }\n  return col4;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, bgCol, vn;\n  float dstObj, dstBall, c, bRad;\n  aRot = doRot ? (2. * pi / 5.) * (floor (0.2 * tCur) + smoothstep (0.7, 1.,\n     mod (0.2 * tCur, 1.))) : 0.;\n  redFac = 0.98;\n  bRad = 0.95;\n  dstBall = BallHit (ro, rd, bRad);\n  dstObj = ObjRay (ro, rd);\n  if (dstBall < min (dstObj, dstFar)) col4 = PlasCol (ro, rd, dstBall, bRad);\n  if (dstObj < dstFar) {\n    ro += rd * dstObj;\n    vn = ObjNf (ro);\n    if (idObj == 1) col = vec3 (0.7, 0.7, 0.5);\n    else if (idObj == 2) col = vec3 (0.6, 0.8, 0.85);\n    if (dot (normalize (ro), vn) < 0.) col *= 0.5;\n    col = col * (0.3 + 0.7 * max (dot (vn, ltDir), 0.)) +\n       0.1 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n    rd = reflect (rd, vn);\n  }\n  c = max (SmoothBump (0.4, 0.6, 0.05, mod (64. * atan (rd.z, - rd.x) / pi, 1.)),\n     SmoothBump (0.4, 0.6, 0.05, mod (64. * asin (rd.y) / pi, 1.)));\n  bgCol = mix (vec3 (1., 0.9, 0.8) * (0.4 + 0.2 * rd.y), vec3 (0.1, 0.1, 0.5), c);\n  c = (rd.y > max (abs (rd.x), abs (rd.z * 0.25))) ? min (2. * rd.y, 1.) :\n     0.05 * (1. + dot (rd, ltDir));\n  if (rd.y > 0.) c += 0.5 * pow (clamp (1.05 - 0.5 *\n     length (max (abs (rd.xz / rd.y) - vec2 (1., 4.), 0.)), 0., 1.), 8.);\n  bgCol += vec3 (0.5, 0.5, 1.) * c + 2. * vec3 (1., 0.9, 0.8) *\n     (pow (abs (rd.x), 2048.) + pow (abs (rd.z), 2048.));\n  bgCol *= 0.4;\n  if (dstBall < min (dstObj, dstFar)) col = mix (((dstObj < dstFar) ? col : bgCol),\n     col4.rgb, col4.a);\n  else if (dstObj < dstFar) col += 0.2 * bgCol;\n  else col = bgCol;\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  doRot = true;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += 3. * pi * mPtr.x;\n    el += 1.5 * pi * mPtr.y;\n    doRot = false;\n  } else {\n    az = 0.25 * pi - 0.03 * pi * tCur;\n    el = 0.2 * pi * sin (0.3 * az);\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  zmFac = 3.3;\n  ro = vuMat * vec3 (0., 0., -4.);\n  ltDir = normalize (vec3 (0., 1., 0.));\n  dstFar = 10.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 4.;\n#endif  \n  col = vec3 (0.);\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.71 / canvas.y, 0.),\n       0.5 * pi * (a + 0.5)), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrSphAnDf (vec3 p, float r, float w)\n{\n  return abs (length (p) - r) - w;\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec3 HueToRgb (float c)\n{\n  return clamp (abs (fract (c + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.);\n}\n\nconst float cHashM = 43758.54;\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm3s (vec3 p, float t)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 4; j ++) {\n    f += a * abs (sin (2. * pi * Noisefv3 (p - t)));\n    a *= 0.5;\n    p *= 3.;\n  }\n  return f * (1. / 1.875);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mtyfzt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xl3BWf", "name": "Still learning, in progress...", "author": "FlashyTheCreeper", "description": "im still learning\n\n\n\n\n\nbtw, shadertoy pls fix pick input window asap", "tags": ["sinus"], "likes": 6, "viewed": 133, "date": "1541193581", "time_retrieved": "2024-06-20T19:24:56.438609", "image_code": "// Some codes taken from:\n// https://www.shadertoy.com/view/Xsl3WH\n// Special thx to Xor!\n\n#define pie 3.1415926\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\nvec3 col = abs(.1 / (10. * uv.y + sin(uv.x * vec3(10,10.1,10.2) + iTime)));\nfragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xl3BWf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlcfWf", "name": "slowglitch4", "author": "ljmatkins", "description": "slower glitch moved down", "tags": ["clone"], "likes": 7, "viewed": 101, "date": "1541210081", "time_retrieved": "2024-06-20T19:25:00.172192", "image_code": "#define MODEL_ROTATION vec2(.5, .5)\n#define LIGHT_ROTATION vec2(.3, .8)\n#define CAMERA_ROTATION vec2(.5, .67)\n\n// Mouse control\n// 0: Defaults\n// 1: Model\n// 2: Lighting\n// 3: Camera\n#define MOUSE_CONTROL 1\n\n// Debugging\n//#define NORMALS\n//#define NO_GLITCH\n//#define GLITCH_MASK\n\n\nfloat time;\n\nfloat _round(float n) {\n    return floor(n + .5);\n}\n\nvec2 _round(vec2 n) {\n    return floor(n + .5);\n}\n\n// --------------------------------------------------------\n// HG_SDF\n// https://www.shadertoy.com/view/Xs3GRB\n// --------------------------------------------------------\n\n#define PI 3.14159265359\n#define PHI (1.618033988749895)\n#define TAU 6.283185307179586\n\nfloat vmax(vec3 v) {\n    return max(max(v.x, v.y), v.z);\n}\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n    return dot(p, n) + distanceFromOrigin;\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n\n#define GDFVector3 normalize(vec3(1, 1, 1 ))\n#define GDFVector4 normalize(vec3(-1, 1, 1))\n#define GDFVector5 normalize(vec3(1, -1, 1))\n#define GDFVector6 normalize(vec3(1, 1, -1))\n\n#define GDFVector7 normalize(vec3(0, 1, PHI+1.))\n#define GDFVector8 normalize(vec3(0, -1, PHI+1.))\n#define GDFVector9 normalize(vec3(PHI+1., 0, 1))\n#define GDFVector10 normalize(vec3(-PHI-1., 0, 1))\n#define GDFVector11 normalize(vec3(1, PHI+1., 0))\n#define GDFVector12 normalize(vec3(-1, PHI+1., 0))\n\n#define GDFVector13 normalize(vec3(0, PHI, 1))\n#define GDFVector14 normalize(vec3(0, -PHI, 1))\n#define GDFVector15 normalize(vec3(1, 0, PHI))\n#define GDFVector16 normalize(vec3(-1, 0, PHI))\n#define GDFVector17 normalize(vec3(PHI, 1, 0))\n#define GDFVector18 normalize(vec3(-PHI, 1, 0))\n\n#define fGDFBegin float d = 0.;\n#define fGDF(v) d = max(d, abs(dot(p, v)));\n#define fGDFEnd return d - r;\n\nfloat fDodecahedron(vec3 p, float r) {\n    fGDFBegin\n    fGDF(GDFVector13) fGDF(GDFVector14) fGDF(GDFVector15) fGDF(GDFVector16)\n    fGDF(GDFVector17) fGDF(GDFVector18)\n    fGDFEnd\n}\n\nfloat fIcosahedron(vec3 p, float r) {\n    fGDFBegin\n    fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n    fGDF(GDFVector11) fGDF(GDFVector12)\n    fGDFEnd\n}\n\n\n// --------------------------------------------------------\n// Rotation\n// --------------------------------------------------------\n\nmat3 sphericalMatrix(float theta, float phi) {\n    float cx = cos(theta);\n    float cy = cos(phi);\n    float sx = sin(theta);\n    float sy = sin(phi);\n    return mat3(\n        cy, -sy * -sx, -sy * cx,\n        0, cx, sx,\n        sy, cy * -sx, cy * cx\n    );\n}\n\nmat3 mouseRotation(bool enable, vec2 xy) {\n    if (enable) {\n        vec2 mouse = iMouse.xy / iResolution.xy;\n\n        if (mouse.x != 0. && mouse.y != 0.) {\n            xy.x = mouse.x;\n            xy.y = mouse.y;\n        }\n    }\n    float rx, ry;\n    \n    rx = (xy.y + .5) * PI;\n    ry = (-xy.x) * 2. * PI;\n    \n    return sphericalMatrix(rx, ry);\n}\n\nmat3 modelRotation() {\n    mat3 m = mouseRotation(MOUSE_CONTROL==1, MODEL_ROTATION);\n    return m;\n}\n\nmat3 lightRotation() {\n    mat3 m = mouseRotation(MOUSE_CONTROL==2, LIGHT_ROTATION);\n    return m;\n}\n\nmat3 cameraRotation() {\n    mat3 m = mouseRotation(MOUSE_CONTROL==3, CAMERA_ROTATION);\n    return m;\n}\n\n\n// --------------------------------------------------------\n// Modelling \n// --------------------------------------------------------\n\nstruct Material {\n    vec3 albedo;\n};\n\nstruct Model {\n    float dist;\n    Material material;\n};\n\nMaterial defaultMaterial = Material(\n    vec3(.5)\n);  \n\nModel newModel() {\n    return Model(\n        10000.,\n        defaultMaterial\n    );\n}\n\nconst float modelSize = 1.2;\n\nfloat blend(float y, float blend, float progress) {\n    float a = (y / modelSize) + .5;\n    a -= progress * (1. + blend) - blend * .5;\n    a += blend / 2.;\n    a /= blend;\n    a = clamp(a, 0., 1.);\n    a = smoothstep(0., 1., a);\n    a = smoothstep(0., 1., a);\n    return a;\n}\n\nfloat ShapeBlend(float y, float progress) {\n    float shapeProgress = clamp(progress * 2. - .5, 0., 1.);\n    float shapeBlend = blend(y, .8, shapeProgress);\n    return shapeBlend;\n}\n\nfloat SpinBlend(float y, float progress) {\n    return blend(y, 1.5, progress);\n}\n\nfloat Flip() {\n\treturn round(mod(time, 1.));\n}\n\nfloat Progress() {\n    float progress = mod(time*2., 1.);\n    //progress = smoothstep(0., 1., progress);\n    //progress = sin(progress * PI - PI/2.) * .5 + .5;\n    return progress;\n}\n\nModel mainModel(vec3 p) {\n    Model model = newModel();\n    \n\tfloat progress = Progress();\n    float flip = Flip();\n    \n    float spinBlend = SpinBlend(p.y, progress);\n    pR(p.xz, spinBlend * PI / 2.);\n    pR(p.xz, PI * -.5 * flip);\n    \n    float part1 = fDodecahedron(p, modelSize * .5);\n    pR(p.xz, PI/2.);\n    float part2 = fIcosahedron(p, modelSize * .5);\n    \n\tfloat shapeBlend = ShapeBlend(p.y, progress);\n    shapeBlend = mix(shapeBlend, 1. - shapeBlend, flip);    \n    float d = mix(part1, part2, shapeBlend);\n\n    model.dist = d;\n    model.material.albedo = mix(vec3(.03), vec3(.8), 1. - shapeBlend);\n\n    return model;\n}\n\nModel glitchModel(vec3 p) {\n    Model model = newModel();\n    float progress = Progress();\n\tfloat band = ShapeBlend(p.y, progress);\n    band = sin(band * PI);    \n\n   \tfloat fadeBottom = clamp(1. - dot(p, vec3(0,1,0)), 0., 1.);\n    band *= fadeBottom;\n\n    float radius = modelSize / 2. + band * .2;\n    model.dist = length(p) - radius;\n    model.material.albedo = vec3(band);\n    \n    return model;\n}\n\nModel map( vec3 p , bool glitchMask){\n    mat3 m = modelRotation();\n    p *= m;\n    pR(p.xz, -time*PI);\n    if (glitchMask) {\n    \treturn glitchModel(p);\n    }\n    Model model = mainModel(p);\n    return model;\n}\n\n\n// --------------------------------------------------------\n// LIGHTING\n// https://www.shadertoy.com/view/Xds3zN\n// --------------------------------------------------------\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t, false ).dist;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.00001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos, false ).dist;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 doLighting(Material material, vec3 pos, vec3 nor, vec3 ref, vec3 rd) {\n    vec3 lightPos = vec3(0,0,-1);\n    vec3 backLightPos = normalize(vec3(0,-.3,1));\n    vec3 ambientPos = vec3(0,1,0);\n\n    mat3 m = lightRotation();\n    lightPos *= m;\n    backLightPos *= m;\n        \n    float occ = calcAO( pos, nor );\n    vec3  lig = lightPos;\n    float amb = clamp((dot(nor, ambientPos) + 1.) / 2., 0., 1.);\n    float dif = clamp((dot(nor, lig) + 1.) / 3., 0.0, 1.0 );\n    float bac = pow(clamp(dot(nor, backLightPos), 0., 1.), 1.5);\n    float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n    \n    dif *= softshadow( pos, lig, 0.01, 2.5 ) * .5 + .5;\n\n    vec3 lin = vec3(0.0);\n    lin += 1.20*dif*vec3(.95,0.80,0.60);\n    lin += 0.80*amb*vec3(0.50,0.70,.80)*occ;\n    lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n    lin += 0.20*fre*vec3(1.00,1.00,1.00)*occ;\n    vec3 col = material.albedo*lin;\n    \n\tfloat spe = clamp(dot(ref, lightPos), 0., 1.);\n    spe = pow(spe, 2.) * .1;\n    col += spe;\n\n    return col;\n}   \n\n\n// --------------------------------------------------------\n// Ray Marching\n// Adapted from: https://www.shadertoy.com/view/Xl2XWt\n// --------------------------------------------------------\n\nconst float MAX_TRACE_DISTANCE = 30.; // max trace distance\nconst float INTERSECTION_PRECISION = .001; // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 100;\nconst float FUDGE_FACTOR = .9; // Default is 1, reduce to fix overshoots\n\nstruct CastRay {\n    vec3 origin;\n    vec3 direction;\n    bool glitchMask;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n    float len;\n};\n\nstruct Hit {\n    Ray ray;\n    Model model;\n    vec3 pos;\n    bool isBackground;\n    vec3 normal;\n    vec3 color;\n};\n\nvec3 calcNormal( in vec3 pos ){\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy, false).dist - map(pos-eps.xyy, false).dist,\n        map(pos+eps.yxy, false).dist - map(pos-eps.yxy, false).dist,\n        map(pos+eps.yyx, false).dist - map(pos-eps.yyx, false).dist );\n    return normalize(nor);\n}\n    \nHit raymarch(CastRay castRay){\n\n    float currentDist = INTERSECTION_PRECISION * 2.0;\n    Model model;\n    \n    Ray ray = Ray(castRay.origin, castRay.direction, 0.);\n\n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        if (currentDist < INTERSECTION_PRECISION || ray.len > MAX_TRACE_DISTANCE) {\n            break;\n        }\n        model = map(ray.origin + ray.direction * ray.len, castRay.glitchMask);\n        currentDist = model.dist;\n        ray.len += currentDist * FUDGE_FACTOR;\n    }\n    \n    bool isBackground = false;\n    vec3 pos = vec3(0);\n    vec3 normal = vec3(0);\n    vec3 color = vec3(0);\n    \n    if (ray.len > MAX_TRACE_DISTANCE) {\n        isBackground = true;\n    } else {\n        pos = ray.origin + ray.direction * ray.len;\n        normal = calcNormal(pos);\n    }\n\n    return Hit(ray, model, pos, isBackground, normal, color);\n}\n\n\n// --------------------------------------------------------\n// Rendering\n// Refraction from https://www.shadertoy.com/view/lsXGzH\n// --------------------------------------------------------\n\nvoid shadeSurface(inout Hit hit){\n\n    vec3 color = vec3(.25);\n    \n    if (hit.isBackground) {\n        hit.color = color;\n        return;\n    }\n\n    #ifdef NORMALS\n        color = hit.normal * 0.5 + 0.5;\n    #else\n    \tvec3 ref = reflect(hit.ray.direction, hit.normal);\n        color = doLighting(\n            hit.model.material,\n            hit.pos,\n            hit.normal,\n            ref,\n            hit.ray.direction\n        );\n    #endif\n\n    hit.color = color;\n}\n\n\nvec3 render(Hit hit){\n    \n    shadeSurface(hit);\n    \n    if (hit.isBackground) {\n        return hit.color;\n    }\n    \n    return hit.color;\n}\n\n\n// --------------------------------------------------------\n// Camera\n// https://www.shadertoy.com/view/Xl2XWt\n// --------------------------------------------------------\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera(out vec3 camPos, out vec3 camTar, out float camRoll, in float time, in vec2 mouse) {\n    float dist = 3.;\n    camRoll = 0.;\n    camTar = vec3(0,0,0);\n    camPos = vec3(0,0,-dist);\n    camPos *= cameraRotation();\n    camPos += camTar;\n}\n\nHit raymarchPixel(vec2 p, bool glitchPass) {\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    vec3 camPos = vec3( 0., 0., 2.);\n    vec3 camTar = vec3( 0. , 0. , 0. );\n    float camRoll = 0.;\n    \n    // camera movement\n    doCamera(camPos, camTar, camRoll, iTime, m);\n    \n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( camPos, camTar, camRoll );  // 0.0 is the camera roll\n    \n    // create view ray\n    float focalLength = 3.;\n    vec3 rd = normalize( camMat * vec3(p.xy, focalLength) );\n    \n    Hit hit = raymarch(CastRay(camPos, rd, glitchPass));\n    \n    return hit;\n}\n\n\n// --------------------------------------------------------\n// Gamma\n// https://www.shadertoy.com/view/Xds3zN\n// --------------------------------------------------------\n\nconst float GAMMA = 2.2;\n\nvec3 gamma(vec3 color, float g) {\n    return pow(color, vec3(g));\n}\n\nvec3 linearToScreen(vec3 linearRGB) {\n    return gamma(linearRGB, 1.0 / GAMMA);\n}\n\n\n// --------------------------------------------------------\n// Glitch core\n// --------------------------------------------------------\n\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nconst float glitchScale = .5;\n\nvec2 glitchCoord(vec2 p, vec2 gridSize) {\n\tvec2 coord = floor(p / gridSize) * gridSize;;\n    coord += (gridSize / 2.);\n    return coord;\n}\n\n\nstruct GlitchSeed {\n    vec2 seed;\n    float prob;\n};\n    \nfloat fBox2d(vec2 p, vec2 b) {\n  vec2 d = abs(p) - b;\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nGlitchSeed glitchSeed(vec2 p, float speed) {\n    float seedTime = floor(time * speed);\n    vec2 seed = vec2(\n        1. + mod(seedTime / 100., 100.),\n        1. + mod(seedTime, 100.)\n    ) / 100.;\n    seed += p;\n    \n    float prob = 0.;\n    Hit hit = raymarchPixel(p, true);\n    if ( ! hit.isBackground) {\n    \tprob = hit.model.material.albedo.x;\n    }\n    \n    return GlitchSeed(seed, prob);\n}\n\nfloat shouldApply(GlitchSeed seed) {\n    return round(\n        mix(\n            mix(rand(seed.seed), 1., seed.prob - .5),\n            0.,\n            (1. - seed.prob) * .5\n        )\n    );\n}\n\n\n// --------------------------------------------------------\n// Glitch effects\n// --------------------------------------------------------\n\n// Swap\n\nvec4 swapCoords(vec2 seed, vec2 groupSize, vec2 subGrid, vec2 blockSize) {\n    vec2 rand2 = vec2(rand(seed), rand(seed+.1));\n    vec2 range = subGrid - (blockSize - 1.);\n    vec2 coord = floor(rand2 * range) / subGrid;\n    vec2 bottomLeft = coord * groupSize;\n    vec2 realBlockSize = (groupSize / subGrid) * blockSize;\n    vec2 topRight = bottomLeft + realBlockSize;\n    topRight -= groupSize / 2.;\n    bottomLeft -= groupSize / 2.;\n    return vec4(bottomLeft, topRight);\n}\n\nfloat isInBlock(vec2 pos, vec4 block) {\n    vec2 a = sign(pos - block.xy);\n    vec2 b = sign(block.zw - pos);\n    return min(sign(a.x + a.y + b.x + b.y - 3.), 0.);\n}\n\nvec2 moveDiff(vec2 pos, vec4 swapA, vec4 swapB) {\n    vec2 diff = swapB.xy - swapA.xy;\n    return diff * isInBlock(pos, swapA);\n}\n\nvoid swapBlocks(inout vec2 xy, vec2 groupSize, vec2 subGrid, vec2 blockSize, vec2 seed, float apply) {\n    \n    vec2 groupOffset = glitchCoord(xy, groupSize);\n    vec2 pos = xy - groupOffset;\n    \n    vec2 seedA = seed * groupOffset;\n    vec2 seedB = seed * (groupOffset + .1);\n    \n    vec4 swapA = swapCoords(seedA, groupSize, subGrid, blockSize);\n    vec4 swapB = swapCoords(seedB, groupSize, subGrid, blockSize);\n    \n    vec2 newPos = pos;\n    newPos += moveDiff(pos, swapA, swapB) * apply;\n    newPos += moveDiff(pos, swapB, swapA) * apply;\n    pos = newPos;\n    \n    xy = pos + groupOffset;\n}\n\n\n// Static\n\nvoid staticNoise(inout vec2 p, vec2 groupSize, float grainSize, float contrast) {\n    GlitchSeed seedA = glitchSeed(glitchCoord(p, groupSize), 5.);\n    seedA.prob *= .5;\n    if (shouldApply(seedA) == 1.) {\n        GlitchSeed seedB = glitchSeed(glitchCoord(p, vec2(grainSize)), 5.);\n        vec2 offset = vec2(rand(seedB.seed), rand(seedB.seed + .1));\n        offset = round(offset * 2. - 1.);\n        offset *= contrast;\n        p += offset;\n    }\n}\n\n\n// Freeze time\n\nvoid freezeTime(vec2 p, inout float time, vec2 groupSize, float speed) {\n    GlitchSeed seed = glitchSeed(glitchCoord(p, groupSize), speed);\n    //seed.prob *= .5;\n    if (shouldApply(seed) == 1.) {\n        float frozenTime = floor(time * speed) / speed;\n        time = frozenTime;\n    }\n}\n\n\n// --------------------------------------------------------\n// Glitch compositions\n// --------------------------------------------------------\n\nvoid glitchSwap(inout vec2 p) {\n\n    vec2 pp = p;\n    \n    float scale = glitchScale;\n    float speed = 5.;\n    \n    vec2 groupSize;\n    vec2 subGrid;\n    vec2 blockSize;    \n    GlitchSeed seed;\n    float apply;\n    \n    groupSize = vec2(.6) * scale;\n    subGrid = vec2(2);\n    blockSize = vec2(1);\n\n    seed = glitchSeed(glitchCoord(p, groupSize), speed);\n    apply = shouldApply(seed);\n    swapBlocks(p, groupSize, subGrid, blockSize, seed.seed, apply);\n    \n    groupSize = vec2(.8) * scale;\n    subGrid = vec2(3);\n    blockSize = vec2(1);\n    \n    seed = glitchSeed(glitchCoord(p, groupSize), speed);\n    apply = shouldApply(seed);\n    swapBlocks(p, groupSize, subGrid, blockSize, seed.seed, apply);\n\n    groupSize = vec2(.2) * scale;\n    subGrid = vec2(6);\n    blockSize = vec2(1);\n    \n    seed = glitchSeed(glitchCoord(p, groupSize), speed);\n    float apply2 = shouldApply(seed);\n    swapBlocks(p, groupSize, subGrid, blockSize, (seed.seed + 1.), apply * apply2);\n    swapBlocks(p, groupSize, subGrid, blockSize, (seed.seed + 2.), apply * apply2);\n    swapBlocks(p, groupSize, subGrid, blockSize, (seed.seed + 3.), apply * apply2);\n    swapBlocks(p, groupSize, subGrid, blockSize, (seed.seed + 4.), apply * apply2);\n    swapBlocks(p, groupSize, subGrid, blockSize, (seed.seed + 5.), apply * apply2);\n    \n    groupSize = vec2(1.2, .2) * scale;\n    subGrid = vec2(9,2);\n    blockSize = vec2(3,1);\n    \n    seed = glitchSeed(glitchCoord(p, groupSize), speed);\n    apply = shouldApply(seed);\n    swapBlocks(p, groupSize, subGrid, blockSize, seed.seed, apply);\n}\n\n\n\nvoid glitchStatic(inout vec2 p) {\n\n    // Static\n    //staticNoise(p, vec2(.25, .25/2.) * glitchScale, .005, 5.);\n    \n    // 8-bit\n    staticNoise(p, vec2(.5, .25/2.) * glitchScale, .2 * glitchScale, 2.);\n}\n\nvoid glitchTime(vec2 p, inout float time) {\n   freezeTime(p, time, vec2(.5) * glitchScale, 2.);\n}\n\nvoid glitchColor(vec2 p, inout vec3 color) {\n    vec2 groupSize = vec2(.75,.125) * glitchScale;\n    vec2 subGrid = vec2(0,6);\n    float speed = 5.;\n    GlitchSeed seed = glitchSeed(glitchCoord(p, groupSize), speed);\n    seed.prob *= .3;\n    if (shouldApply(seed) == 1.) {\n        vec2 co = mod(p, groupSize) / groupSize;\n        co *= subGrid;\n        float a = max(co.x, co.y);\n        //color.rgb *= vec3(\n        //  min(floor(mod(a - 0., 3.)), 1.),\n        //    min(floor(mod(a - 1., 3.)), 1.),\n        //    min(floor(mod(a - 2., 3.)), 1.)\n        //);\n        \n        color *= min(floor(mod(a, 2.)), 1.) * 10.;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime;\n    time /= 9.;\n    time = mod(time, 1.);\n    fragCoord.y += 20.0;\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    \n    vec3 color;\n    \n    #ifdef GLITCH_MASK\n    \tfloat prob = glitchSeed(p, 10.).prob;\n    \tcolor = vec3(prob);\n   \t#else\n\n        #ifndef NO_GLITCH\n            glitchSwap(p);\n            glitchTime(p, time);\n            glitchStatic(p);\n        #endif\n\n        Hit hit = raymarchPixel(p, false);\n        color = render(hit);\n\n        #ifndef NO_GLITCH\n            glitchColor(p, color);\n        #endif\n    \n        #ifndef NORMALS\n           color = linearToScreen(color);\n        #endif\n\n    #endif\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlcfWf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlcfWX", "name": "Mandelbrot Set Test Zoom", "author": "Nihilistic_Furry", "description": "Mandelbrot zoom at point (-1.2501046 + 0.00611021 i), which shows the mandelbrot, but as it gets closer and closer shows the limits of floating point numbers at very small numbers (in particular the boxes and lines at 1+ minutes), tuned to time 318.84.", "tags": ["fractal", "mandelbrot", "zoom"], "likes": 0, "viewed": 248, "date": "1541182777", "time_retrieved": "2024-06-20T19:25:00.178398", "image_code": "// Default zoom point of (-1.2501046 + 0.00611021 i) \n// Zooms in on point that is good at showing rounding errors as it zooms in more and more \n#define cx -1.2501046\n#define cy 0.00611021\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Variables\n\tfloat scale = 1.0 / (iTime * iTime * iTime + 1.0);\n    float ax, ay;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Change perspectives w/ zoom\n    ax = cx + ((uv.x * 3.5) - 2.5) * scale;\n    ay = cy + ((uv.y * 2.0) - 1.0) * scale;\n    \n    // Set up calculation (a = real, b = imaginary)\n    float a1 = ax, a2, b1 = ay, b2;\n    int i;\n    \n    // Actual math of mandelbrot set\n    for (i = 0; !(i > 255 || (a1 * a1) + (b1 * b1) > 16.0); i++) \n    {\n        // Find \"z = z^2 + c\"\n        a2 = (a1 * a1) - (b1 * b1) + ax;\n        b2 = 2.0 * (a1 * b1) + ay;\n        \n        // Set values to new values\n        a1 = a2;\n        b1 = b2;\n    }\n    \n    float color;\n    \n    // If part of set, make it black, if not, divide by 255 for colored version\n    if (i > 255)\n    {\n        color = 0.0;\n    } \n    else\n    {\n\t\tcolor = float (i) * 0.0625;\n    }\n    \n    fragColor = vec4 (color, color, color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlcfWX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XldBD8", "name": "Two-dimensional Spirals", "author": "nr4", "description": "Distance to a spiral.", "tags": ["2d", "sdf", "spiral", "antialiasing"], "likes": 4, "viewed": 488, "date": "1542719464", "time_retrieved": "2024-06-20T19:25:00.178398", "image_code": "/*\n * Two-dimensional Spirals\n * \n * Copyright (C) 2018  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nconst float pi = acos(-1.);\nconst vec3 c = vec3(1.,0.,-1.);\n\n// hash function\nfloat r(vec2 a0)\n{\n    return fract(sin(dot(a0.xy ,vec2(12.9898,78.233)))*43758.5453);\n}\n\n// distance to spiral\nfloat dspiral(vec2 x, float a, float d)\n{\n    float p = atan(x.y, x.x),\n        n = floor((abs(length(x)-a*p)+d*p)/(2.*pi*a));\n    p += (n*2.+1.)*pi;\n    return -abs(length(x)-a*p)+d*p;\n}\n\n#define A iResolution.y\n#define B 3./Y\n#define S(v) smoothstep(-1.5/A,1.5/A,v)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float a = .125, aa = .5*a; // tile size\n    vec2 uv = fragCoord/A+.5,\n        x = mod(uv, a)-aa, y = uv-x; // we want many spirals\n\n    //random number of edges and random rotation\n    float p = (-7.5+15.*r(y))*iTime,\n        k = cos(p), s = sin(p), k2 = cos(p-pi), s2 = sin(p-pi),\n    \td = dspiral(mat2(k,s,-s,k)*x, 5.e-3*(.75+.5*r(y+1.)), 4.e-4*(.75+.5*r(y+2.)));\n    \n    //set random colors\n    vec3 col = .5 + .5*cos(p+uv.xyx+vec3(0.,2.,4.));\n    fragColor = vec4(col*mix(S(d),1.,.5)+S(-abs(d)),1.);\n    \n    //add borders\n    vec2 v = smoothstep(-aa,-aa+1.5/A,x)*smoothstep(aa,aa-1.5/A,x);\n    fragColor *= v.x*v.y;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XldBD8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XldBWf", "name": "Thing_12", "author": "balkhan", "description": "Triangles thing", "tags": ["raymarching"], "likes": 9, "viewed": 154, "date": "1542180338", "time_retrieved": "2024-06-20T19:25:00.188113", "image_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\nvec2\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvoid\trotate(inout vec2 v, float angle);\nfloat\tmylength(vec3 p);\nfloat\tmylength(vec2 p);\nvec3 \tcameraLookAt(vec3 target, vec3 camPos, vec3 up, vec2 uv, float camNear);\n\nfloat \tt;\t\t\t// time\nvec3\tret_col;\t// torus color\nvec3\th; \t\t\t// light amount\n\n#define I_MAX\t\t200.\n#define E\t\t\t0.0001\n#define FAR\t\t\t100.\n#define PI\t\t\t3.14\n\nvoid mainImage(out vec4 c_out, in vec2 f)\n{\n    t  = iTime*.125;\n    vec3\tcol = vec3(0., 0., 0.);\n\tvec2 R = iResolution.xy,\n          uv  = vec2(f-R/2.) / R.y;\n    vec3\tpos = vec3(.250+0.*clamp((1.-1.*exp((-iTime+20.))), .0, 1.), .250+0.*clamp((1.-1.*exp((-iTime+20.))), .0, 1.), 20.0);\n\n\tvec3\tdir = camera(uv);\n    //cameraLookAt(vec3(.0, .0, .0), pos, vec3(.0,  1., .0), uv, .3);\n\n    h*=0.;\n    vec2\tinter = (march(pos, dir));\n    col += h*.00625125;\n    c_out =  vec4(col,1.0);\n}\n\n// iq's Capsule sdf modified\nfloat sdThing( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec3 pbh = pa - ba*h;\n    return max(1.5,mylength(pbh)) - r*length( pbh )*.25;\n}\n\nfloat\tscene(vec3 p)\n{  \n    float\tvar;\n    float\tmind = 1e5;\n    p.z -=-30.;\n    rotate(p.xz, 1.57*1.0-1.05*iTime*1.0+.5*sin(iTime*2.));\n    \n    vec3 pp = p;\n    ret_col = 1.-vec3(.5, .5, .3);\n    \n    rotate(p.zy, -iTime*.125+p.x*(.125+.105*sin(-iTime*.25) ));\n    \n    mind = sdThing(p, vec3(-10., -5.0*cos(iTime*1.+p.x*.5), -5.0*sin(iTime*1.+p.x*.5) ), vec3(10.,.0,.0), 2.5);\n    mind = abs(mind)-.25;\n    mind = mix(mind, max(mind, sin(p.x*3.+iTime*50.)+.998), .5 + .5*sin(iTime*.25));    \n    mind = mix(abs(mind)+.01, mind, .5 + .5*sin(iTime*.25));\n\n    h += vec3(2.75,.8,.5)*vec3(1.)*.0125/max(.01, (mind)*(mind) );\n\n    return (mind)*.25;\n}\n\nvec2\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0, 0.0);\n    vec3\tp = vec3(0.0, 0.0, 0.0);\n    vec2\ts = vec2(0.0, 0.0);\n    for (float i = -1.; i < I_MAX; ++i)\n    {\n\t   \tp = pos + dir * dist.y;\n\t    dist.x = scene(p)*1.;\n        dist.y += dist.x; // makes artefacts disappear\n        if (dist.x < E || dist.y > FAR)\n        {\n            break;\n        }\n        s.x++;\n    }\n    s.y = dist.y;\n    return (s);\n}\n\n// Utilities\n\nfloat\tmylength(vec3 p) {return max(max(abs(p.x), abs(p.y)), abs(p.z));}\nfloat\tmylength(vec2 p) {return (max(abs(p.x), abs(p.y)));}\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec2\trot(vec2 p, vec2 ang)\n{\n\tfloat\tc = cos(ang.x);\n    float\ts = sin(ang.y);\n    mat2\tm = mat2(c, -s, s, c);\n    \n    return (p * m);\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float\t\tfov = 1.;\n\tvec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n\nvec3 cameraLookAt(vec3 target, vec3 camPos, vec3 up, vec2 uv, float camNear)\n{\n    vec3 axisZ = normalize(target - camPos);\n    vec3 axisX = cross(axisZ, up);\n    vec3 axisY = cross(axisX, axisZ);\n    return normalize(axisX * uv.x + axisY * uv.y + camNear * axisZ); \n}\n\nvec3 calcNormal( in vec3 pos, float e, vec3 dir)\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\n    return normalize(vec3(\n           march(pos+eps.xyy, dir).y - march(pos-eps.xyy, dir).y,\n           march(pos+eps.yxy, dir).y - march(pos-eps.yxy, dir).y,\n           march(pos+eps.yyx, dir).y - march(pos-eps.yyx, dir).y ));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XldBWf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XldfDX", "name": "Boby Sponger", "author": "dijame", "description": "Bobick est une fusion potara (cf Dragon Ball Z), il s'agit de bob l'√©ponge et de patrick qui se m√™lent pour ne former qu'un.", "tags": ["bobick"], "likes": 3, "viewed": 93, "date": "1541855011", "time_retrieved": "2024-06-20T19:25:02.881693", "image_code": "const int Steps = 1000;\nconst float Epsilon = 0.01; // Marching epsilon\nconst float T=0.5;\n\nconst float rA=10.0; // Maximum ray marching or sphere tracing distance from origin\nconst float rB=40.0; // Minimum\n\n// Transforms\nvec3 rotateX(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n\nvec3 rotateZ(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.y, -sa*p.x + ca*p.y, p.z);\n}\n\nvec3 scale(vec3 p, float s)\n{\n    return p * s;\n}\n\n\n// Smooth falloff function\n// r : small radius\n// R : Large radius\nfloat falloff( float r, float R )\n{\n  float x = clamp(r/R,0.0,1.0);\n  float y = (1.0-x*x);\n  return y*y*y;\n}\n\n// Primitive functions\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : large radius\nfloat blob(vec3 p, vec3 c, float e,float R)\n{\n  return e*falloff(length(p-c),R);\n}\n\n// Cone skeleton\n// p : point \n// o : origin of skeleton\n// h : size of cone\n// a : angle of adjacent/opposite\n// e : energy associated to skeleton\n// r : radius\nfloat cone(vec3 p, vec3 o, float e, float R)\n{\n\tvec2 q    = vec2( length( p.xz ), p.y );\n    float d1  = -p.y - o.z;\n    float d2  = max( dot(q,o.xy), p.y );\n    float res = length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.0);\n    return e * falloff(res,R);\n}\n\n// Line skeleton\n// p : point\n// l1 : first point of the line\n// l2 : second point of the line\n// e : energy associated to skeleton\n// R : large radius\nfloat line(vec3 p, vec3 l1, vec3 l2, float e, float R) \n{\n\tvec3 direction = normalize(l2 - l1);\n    vec3 l1p = p - l1;\n    \n    float dotProduct = dot(direction, l1p);\n    \n    if (dotProduct < 0.0) {\n\t\treturn e*falloff(length(p-l1),R);\n    } else if (dotProduct > length(l2 - l1)) {\n        return e*falloff(length(p-l2),R);\n    }\n    \n    // projection of p on the line\n    vec3 l1H = dotProduct * direction;\n    vec3 h = l1 + l1H;\n    \n\treturn e*falloff(length(p-h), R);\n}\n\n// Line skeleton with decrease\n// p : point\n// l1 : first point of the line\n// l2 : second point of the line\n// e : energy associated to skeleton\n// R : large radius\nfloat lineDecreasing(vec3 p, vec3 l1, vec3 l2, float e, float R, float minDecreasingRatio) {\n    \n\tvec3 direction = normalize(l2 - l1);\n    vec3 l1p = p - l1;\n    \n    float dotProduct = dot(direction, l1p);\n    \n    if (dotProduct <= 0.0) {\n\t\treturn e*falloff(length(p-l1),R);\n    } else if (dotProduct >= length(l2 - l1)) {\n        return e*falloff(length(p-l2),minDecreasingRatio * R);\n    }\n    \n    // projection of p on the line\n    vec3 l1H = dotProduct * direction;\n    vec3 h = l1 + l1H;\n    \n    float decreasingRatio = 1.0 - (dotProduct / length(l2-l1)) * (1.0 - minDecreasingRatio);\n    \n\treturn e*falloff(length(p-h), decreasingRatio * R);\n}\n\n// Circle skeleton\n// p : point\n// c : center\n// r : radius\n// n : circle normal\n// e : energy associated to skeleton\n// R : large radius\nfloat circle(vec3 p, vec3 c, float r, vec3 n, float e, float R) {\n    \n    vec3 delta = p - c;\n\tvec3 CQ = delta - (dot(delta, n) * n);\n    \n    vec3 K = c + r * normalize(CQ);\n    \n\treturn e*falloff(length(p-K), R);\n}\n\n// Half Circle skeleton\n// p : point\n// c : center\n// r : radius\n// n : circle normal\n// d : filled half direction\n// e : energy associated to skeleton\n// R : large radius\nfloat halfCircle(vec3 p, vec3 c, float r, vec3 n, vec3 d, float e, float R) {\n\n    float distance = 0.0;\n    \n    vec3 delta = p - c;\n    \n    if (dot(delta, d) < 0.0) {\n        vec3 orthoVec = cross(d, n);\n        \n  \t\treturn line(p, c -  orthoVec * r, c + orthoVec * r, e, R);   \n    } else {\n        vec3 CQ = delta - (dot(delta, n) * n);\n\n        vec3 K = c + r * normalize(CQ);\n\n        distance = length(p-K);\n    }\n    \n    return e*falloff(distance, R);\n}\n\n// Cuboid\n// p : point\n// c : center of cuboid\n// X : size of x edge\n// Y : size of Y edge\n// Z : size of z edge\n// e : energy asociated to skeleton\n// R : large radius\nfloat cuboid(vec3 p, vec3 c, float X, float Y, float Z, float e, float R)\n{\t\n    float x = abs(p.x- c.x);\n    float y = abs(p.y- c.y);\n    float z = abs(p.z- c.z);\n    \n    float distX = 0., distY = 0., distZ = 0.;\n    if (x > X/2.)\n        distX = x - X/2.;\n    if (y > Y/2.)\n        distY = y - Y/2.;\n    if (z > Z/2.)\n        distZ = z - Z/2.;\n    \n    float dist = sqrt(distX*distX + distY*distY + distZ*distZ);\n    \n    \n    //return e * falloff(max(max(x,y),z),R);       \n    return e * falloff(dist,R);     \n}\n\n// Cube\n// p : point \n// s : size of cube\n// e : energy associated to skeleton\n// s : size of cube\n// R : large radius\nfloat cube(vec3 p, vec3 s, float e, float R) {\n\treturn e * falloff(length(max(abs(p) - s, 0.0)), R);\n}\n\n// Tore\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// r : small radius\n// R : large radius\nfloat tore(vec3 p, vec3 c, float e, float r, float R)\n{\n    p.x = p.x - c.x;\n    p.y = p.y - c.y;\n    p.z = p.z - c.z;\n    float xz  = (sqrt((p.x*p.x) + (p.z*p.z)) - R);\n\tfloat yr  = (p.y*p.y)-(r*r);\n    float res = ((xz * xz) + yr);\n    return e * falloff(res,R);\n}           \n\n// Blending\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Blend(float a,float b)\n{\n    return a+b;\n}\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Union(float a,float b)\n{\n    return max(a,b);\n}\n\n//Intersection\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Intersection(float a, float  b)\n{\n    return min(a,b);\n}\n\n// Private\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Deprived(float a, float b)\n{\n    return a-b;\n}\n\nfloat Interpolation(float a, float b, float c)\n{\n    return mix(a,b,c);\n}\n\n// Potential field of the object\n// p : point\nfloat object(vec3 p)\n{\n    p.z=-p.z;\n    float tmp = p.x;\n    if(iTime < 10.) {\n        p.x = tmp - 10. + iTime;\n        p = scale(p,1.5);\n    }\n    else\n        p = scale(p,1.5);\n        \n    // Boby\n\tvec3 pabs = vec3(abs(p.x),p.y,p.z);\n    // Corps\n    float v = cuboid(p, vec3(0.0,0.0,0.0), 2.0,4.5,1.0,1.0, 4.0); \n    // Les yeux\n    //Les globes\n    float gb = blob(pabs,vec3(1.0,1.6,2.5),2.5,1.3);\n    // L'oeuil\n    float y = blob(pabs,vec3(1.0,1.6,2.5),2.5,1.3);\n\ty = Union(v,blob(pabs,vec3(1.05,1.65,3.0),3.5,0.55));\n    \n    v = Blend(v,gb);\n    v = Union(v,y);\n    // Les sourcils\n    v = Blend(v,cuboid(rotateZ(pabs,-0.55),vec3(0.0,3.0,2.15),0.12,0.3,0.1,1.0,.2));\n\tv = Blend(v,cuboid(pabs,vec3(1.0,2.75,2.15),0.12,0.3,0.1,1.0,.2));\n    v = Blend(v,cuboid(rotateZ(pabs,0.55),vec3(1.75,2.0 ,2.15),0.12,0.3,0.1,1.0,.2));\n    \n    // Le nez\n    v = Blend(v,line(p,vec3(0.0,.8,1.5),vec3(0.0,1.0,2.5),1.0,0.5));\n    \n    // Bouche\n    v = Deprived(v,Intersection(blob(p,vec3(0.0,-.8,1.5),50.0,1.),blob(p,vec3(0.0,-.3,1.5),50.0,1.)));\n    \n    // Les dents\n    //v = Union(v,cuboid(p,vec3(0.25,.1,1.15),0.3,0.4,0.15,1.0,1.0));\n    //v = Union(v,cuboid(p,vec3(-0.25,.1,1.15),0.3,0.4,0.15,1.0,1.0));\n\n    // Les manches\n    if( iTime < 25.){\n    \tv = Blend(v,cone(rotateZ(vec3(pabs.x - 2.5,pabs.y - 1.2,pabs.z),1.5), vec3(0.5,0.5,0.7), 0.6, .2));\n    \t// Les bras\n    \tv = Blend(v,line(pabs, vec3(3.5, 1.35, 0.0),vec3(6.1,1.5,0.0), .8, 0.8));  \n    } \n\n    // Les jambes\n    v = Blend(v,cone(rotateY(vec3(pabs.x - 0.5,pabs.y + 3.4,pabs.z),1.5), vec3(0.5,0.5,0.6), 0.6, .2));\n    v = Blend(v,line(pabs, vec3(1.0, -3.0, 0.0),vec3(1.0,-6,0.0), .8, 0.8));  \n    \n    v = Deprived(v,blob(pabs, vec3(1.9,-1.3,2.),1.0, 0.45));\n    v = Deprived(v,blob(pabs, vec3(1.4,-2.3,2.),1.0, 0.5));\n  \n  // PatPat  \n    if(iTime < 10.) {\n      p.x = tmp + 10. - iTime; \n      p = scale(p,0.9);\n    }  \n  if(iTime > 25.)  \n  \tp = scale(p,0.7);\n  // pieds\n  float g = lineDecreasing(vec3(abs(p.x) - 0.75,p.y,p.z) ,vec3( 0.0, -2.0, 0.0), vec3(1.0, -4.0, 0.0 + sin(4.0*iTime)),1.0,1.75, 0.3);\n\n  // buste\n  g = Blend(g,blob(p,vec3(0.0, -0.75 ,0.0),2.5,2.5));\n  // bras\n  g = Blend(g,lineDecreasing(vec3(-abs(p.x), p.y, p.z),vec3(-1.0, -0.25, 0.0), vec3(-3.0, 0.5, 0.0 + sin(4.0*iTime)), 1.0,1.25, 0.5));\n  // tete\n  g = Blend(g,lineDecreasing(p,vec3(0.0, 1.0, 0.0), vec3(0.0, 3.0, 0.0), 1.5, 1.5, 0.5));\n  // yeux\n  g = Blend(g, blob(vec3(abs(p.x) - 1.25, p.y, p.z), vec3(-0.9, 2.0, 0.5), 1.0, 0.5));\n  g = Blend(g, blob(vec3(abs(p.x) - 1.25, p.y, p.z), vec3(-0.9, 2.0, 0.7), 1.0, 0.1));\n    \n  // nombril\n  g = Deprived(g, blob(p, vec3(0.0, -1.5, 1.8), 1.0, 0.9));\n    \n  // sourcils\n  g = Union(g, line(vec3(abs(p.x) - 0.1, p.y, p.z), vec3(0.6, 2.7, 0.5), vec3(0.0, 2.75, 0.5), 0.7, 0.2));\n    \n  // bouche\n  g = Blend(g, halfCircle(p, vec3(0.0, 1.3, 0.8), 0.4, vec3(0.0, 0.0, -1.0), vec3(0.0, -1.0, 0.0), 1.0, 0.2));\n  \n if (iTime > 25.)\n    return Interpolation(g,v,0.6)-T;   \n else if(iTime > 20.)\n    return blob(p,vec3(0.0),1.0,exp(0.07*iTime)) - T;\n else if(iTime > 12.)\n   return (Interpolation(g,v,0.1 + sin(0.5*iTime))-T) * (0.25*iTime); \n else\n    return Blend(g,v) - T;\n}\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n  float eps = 0.0001;\n  vec3 n;\n  float v = object(p);\n  n.x = object( vec3(p.x+eps, p.y, p.z) ) - v;\n  n.y = object( vec3(p.x, p.y+eps, p.z) ) - v;\n  n.z = object( vec3(p.x, p.y, p.z+eps) ) - v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat Trace(vec3 o, vec3 u, out bool h,out int s)\n{\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p  = o + (t*u);\n    float v = object(p);\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += Epsilon;\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n// Trace ray using ray marching\n// o  : ray origin\n// u  : ray direction\n// h  : hit\n// s  : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, out bool h,out int s)\n{\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float omega      = 1.2;\n    float t          = rA;\n    float c_t\t\t = rA;\n    float previous_v = 0.;\n    float stepL      = 0.;\n    float c_error    = 999.;\n\tfloat signe      = object(o) < 0. ? -1. : 1.;\n        \n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3  p   = o+(t*u);\n    float s_v = signe * object(p);   \n    float v   = object(p);\n    bool test = (omega > 1. && (v + previous_v) < stepL);  \n      \n    if(test) {\n        stepL  -= omega * stepL;\n        omega  =  1.0;\n    }\n    else {\n        stepL = s_v * omega; \n    }          \n      \n    previous_v  = v;\n    float error = s_v/t;\n    \n    if(!test && error < c_error){\n    \tc_t     = t;\n        c_error = error;\n    }\n\t\n      if (v > 0.) {\n\t\ts=i;\n        h = true;\n        break;\n      }\n    // Move along ray\n    t += max(stepL,0.15);        \n    // Escape marched far away\n      if (!test && t>rB)\n        break;\n  }\n  return t;\n}\n\n\n// Background color\nvec3 background(vec3 rd)\n{\n  return mix(vec3(0.4, 0.3, 0.0), vec3(0.7, 0.8, 1.0), rd.y*0.5+0.5);\n}\n\nvec3 objectColor() {\n  return mix(vec3(1.0, 0.3, 0.3), vec3(1.0, 1.0, 0.0), 0.25 * sin(0.5*iTime));\n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\nvec3 Shade(vec3 p, vec3 n)\n{\n  // point light\n  const vec3 lightPos   = vec3(5.0, 5.0, 5.0);\n  const vec3 lightColor = vec3(0.5, 0.5, 0.5);\n  vec3 c = vec3(0.0);\n  if(p.x < 0. && iTime < 12.)\t\n  \tc = vec3(1.0, 0.3, 0.3);\n  else if(p.x > 0. && iTime < 12.)  \n \tc = vec3(1.0, .5, 0.0);\n  else\n    c = objectColor();\n  \n  vec3 l = normalize(lightPos - p);\n\n  // Not even Phong shading, use weighted cosine instead for smooth transitions\n  float diff = 0.5*(1.0+dot(n, l));\n\n  c += diff*lightColor;\n\n  return c;\n}\n\n// Shading with number of steps\nvec3 ShadeSteps(int n)\n{\n   float t=float(n)/(float(Steps-1));\n   return vec3(t,0.25+0.75*t,0.5-0.5*t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 pixel = (gl_FragCoord.xy / iResolution.xy)*2.0-1.0;\n\n  // compute ray origin and direction\n  float asp = iResolution.x / iResolution.y;\n  vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -4.0));\n  vec3 ro = vec3(0.0, 0.0, 20.0);\n\n  // vec2 mouse = iMouse.xy / iResolution.xy;\n  float ax=3.2;\n  float ay=0.0;  \n  if (iMouse.z > 0.0) {\n   \tax = iMouse.x / iResolution.x * 6.0 + 0.5;\n    ay = iMouse.y / iResolution.y * 6.0 + 0.5;  \n  }\n  ro = rotateY(ro, ax);\n  rd = rotateY(rd, ax);\n  //ro = rotateX(ro, ay);\n  //rd = rotateX(rd, ay);  \n\n  // Trace ray\n  bool hit;\n\n  // Number of steps\n  int s;\n\t\n  //float t = Trace(ro,rd,hit,s);\n  float t = SphereTrace(ro, rd, hit,s);\n  vec3 pos=ro+t*rd;\n  // Shade background\n  vec3 rgb = vec3(1.0);\n\n  if (hit)\n  {\n    // Compute normal\n    vec3 n = ObjectNormal(pos);\n\n    // Shade object with light\n    rgb = Shade(pos, n);\n    //rgb = vec3(0.5);  \n  }\n\n  // Uncomment this line to shade image with false colors representing the number of steps\n  //rgb = ShadeSteps(s);\n\n  fragColor=vec4(rgb, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XldfDX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlGBD1", "name": "ÂºÇÂΩ¢Áä∂-‰∫îËä±Áì£", "author": "Arikes", "description": "ÂºÇÂΩ¢Áä∂-‰∫îËä±Áì£", "tags": [], "likes": 0, "viewed": 49, "date": "1542306027", "time_retrieved": "2024-06-20T19:25:03.014849", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    vec2 temp = uv * 2.0 - vec2(1.0);\n    if(dot(temp,temp) > sin(atan(temp.y,temp.x)*5.0+iTime))\n        discard;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlGBD1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlGBzV", "name": "Matrix rain ", "author": "RaduBT", "description": "// Created by Reinder Nijhoff 2015\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/XdcGzr\n//\n// Based on matrix - 255 char by FabriceNeyret2: https://www.shadertoy.com/view/4tlXR4\n// compacting to 2-tweets pa\n\nhttps://www.shadertoy.com/view/XdcGzr", "tags": ["fork", "matrix"], "likes": 14, "viewed": 784, "date": "1543102989", "time_retrieved": "2024-06-20T19:25:03.172509", "image_code": "// Created by Reinder Nijhoff 2015\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/XdcGzr\n//\n// Based on matrix - 255 char by FabriceNeyret2: https://www.shadertoy.com/view/4tlXR4\n// compacting to 2-tweets patriciogv's Matrix shader https://www.shadertoy.com/view/MlfXzN ( 819 -> 255 chars ) \n// But first go see patriciogv's comments and readable sources :-D\n//\n// All credits go to FabriceNeyret2\n//\n\n\n#define R fract(23.*sin(p.x*7.+p.y*8.))\n\nvoid mainImage( out vec4 o, vec2 i) {\n    vec2 j = fract(i*=.21), \n         p = vec2(92,int(iTime*(7.+8.*sin(i-=j).x)))+i;\n    o-=o; o.g=R; p*=j; o*=R>.5&&j.x<.6&&j.y<.8?1.:0.;\n}\n\n", "image_inputs": [{"id": "ltX3R8", "previewfilepath": "https://soundcloud.com/the-phys-1/dps-tron-legacy-end-of-line-rmx", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/the-phys-1/dps-tron-legacy-end-of-line-rmx", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlGBzV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlGfDw", "name": "fake lighting (purple mix)", "author": "Del", "description": "fake lighting shader mixed with smooth purple wave mapping :)", "tags": ["waves", "displacement", "fake", "light", "sphere", "march", "reflect", "parametrization"], "likes": 7, "viewed": 564, "date": "1542675787", "time_retrieved": "2024-06-20T19:25:04.081616", "image_code": "// simple sphere march (+ fake light / ref)\nmat2 rotate(float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n#define\tTAU 6.28318\n\n// IQ's patched sphere parametrization to squash texture on to a sphere.\n// Reference: http://iquilezles.org/www/articles/patchedsphere/patchedsphere.htm\n\nvec2 sphereToCube(in vec3 pointOnSphere)\n{\n   return vec2(pointOnSphere.x/pointOnSphere.z,pointOnSphere.y/pointOnSphere.z);\n}\n/* Check if x and y are between 0 and 1. If so, return v,\n * otherwise return zeros. This allows us to use a sum of\n * vectors to test what face of the cube we are on */ \nvec2 insideBounds(vec2 v)\n{\n    vec2 s = step(vec2(-1.,-1.), v) - step(vec2(1.,1.), v);\n    return s.x * s.y * v;\n}\n\nfloat GetWaveDisplacement(vec3 p)\n{\n    float time = iTime;\n\tfloat waveStrength = 0.1;\n\tfloat frequency = 4.0;\n\tfloat waveSpeed = 0.15;\n\tfloat rotSpeed = 0.1;\n\tfloat twist = 0.24;\n\tfloat falloffRange = 2.0;\t// the other values have been tweaked around this...\n\t\n\tfloat d = length(p);\n\tp.xz *= rotate(d*twist+(time*rotSpeed)*TAU);\n\tvec2 dv = p.xz*0.15;\n\td = length(dv);\n\td = clamp(d,0.0,falloffRange);\n\tfloat d2 = d-falloffRange;\n\tfloat t = fract(time*waveSpeed)*TAU;\n\tfloat s = sin(frequency*d*d+t);\n\tfloat k = s * waveStrength * d2*d2;\n\tk *= p.x*p.z*0.5;\n\t//k-= 0.4;\t\t\t\t\t// mix it up a little...\n\tk -= sin(fract(time*0.1)*TAU)*0.4*d2;\t\t\t// really mix it up... :)\n\tk = smoothstep(0.0,0.45,k*k);\n\treturn k;\n}\n\nfloat getSphereMappedTexture(in vec3 pointOnSphere)\n{\n    /* Test to determine which face we are drawing on.\n     * Opposing faces are taken care of by the absolute\n     * value, leaving us only three tests to perform.\n     */\n    vec2 st = (\n        insideBounds(sphereToCube(pointOnSphere)) +\n        insideBounds(sphereToCube(pointOnSphere.zyx)) +\n        insideBounds(sphereToCube(pointOnSphere.xzy)));\n    \n    st *= 12.0;\n    float k = GetWaveDisplacement(vec3(st.x,0.0,st.y))*0.5;\n    k = clamp(k,0.0,1.0);\n\treturn 1.0-k;\n    //return textureFunc(st);\n}\n\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBumpedSphere(vec3 p)\n{\n\tfloat k = getSphereMappedTexture(p) * 0.25;\t\t// \n\tfloat d = sdSphere(p, 4.0);\n    return d+k;\n}\n\n\nfloat map(vec3 p)\n{\n    vec4 tt = vec4(iTime*0.03,iTime*0.07,iTime*0.5,iTime*0.75) * TAU;\n\tp.xz *= rotate(tt.x);\n    p.zy *= rotate(tt.y);\n    return sdBumpedSphere(p);\n}\n\nvec3 normal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\nvec3 render(vec3 ro, vec3 rd)\n{\n\t// march\t\n\tfloat tmin = 0.1;\n\tfloat tmax = 10.;\n\tvec3 p;\n\tfloat t = tmin;\n\tfor (int i = 0; i < 180; i++)\n\t{\n\t\tp = ro + t * rd;\n\t\tfloat d = map(p);\n\t\tt += d*0.5;\n\t\tif (t > tmax)\n\t\t\tbreak;\t\t\n\t}\n\t\n    // light\n\tif (t < tmax)\n\t{\n\t   \tvec3 lightDir = normalize(vec3(0.0, 1.0, -1.0));\n\t\tvec3 nor = normal(p);\n\t\t\n\t\tfloat dif = max(dot(nor, lightDir), 0.0);\n\t\tvec3 c = vec3(0.5) * dif;\n        \n        float tf = 0.02;\n\t\tc += vec3(0.35,0.02,0.58)*0.5 + reflect(vec3(p.x*tf, p.y*tf, 0.05), nor);\n\n\t\tvec3 ref = reflect(rd, nor);\n\t\tfloat spe = max(dot(ref, lightDir), 0.0);\n\t\tc += vec3(2.0) * pow(spe, 32.);\n\t\treturn c;\n\t}\n\t\n\treturn vec3(0.24,0.24,0.35);\n}\n\nmat3 camera(vec3 ro, vec3 ta, vec3 up)\n{\n\tvec3 nz = normalize(ta - ro);\n\tvec3 nx = cross(nz, normalize(up));\n\tvec3 ny = cross(nx, nz);\n\treturn mat3(nx, ny, nz);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 q = (2.0*fragCoord.xy / iResolution.xy)-1.0;\n\tvec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.xy;\n\tp.x *= iResolution.x / iResolution.y;\n\n\tvec3 ro = vec3(0.0, 0.0, 0.0);\n    float ang = radians(-90.0);\n    float d = 6.0;\n    ro.z = sin(ang)*d;\n    ro.x = cos(ang)*d;\n\tvec3 ta = vec3(0.0, 0.0, 0.0);\n\t\n\tvec3 rd = camera(ro, ta, vec3(0.0, 1.0, 0.0)) * normalize(vec3(p.xy, 1.0));\n\n    // render\n\tvec3 c = render(ro, rd);\n\n    // vignette\n    float rf = sqrt(dot(q, q)) * 0.35;\n    float rf2_1 = rf * rf + 1.0;\n    float e = 1.0 / (rf2_1 * rf2_1);    \n    c*=e;    \n\n\tfragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlGfDw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlGfWW", "name": "WarpingFloor", "author": "Falko", "description": "move mouse to rotate camera", "tags": ["procedural", "raymarching"], "likes": 3, "viewed": 105, "date": "1542477155", "time_retrieved": "2024-06-20T19:25:05.572720", "image_code": "vec3 v;\nvec3 lightSource = vec3(20.0, 0.0, 6.0);\nfloat bLightSource = 0.6;\nfloat ba = 0.4;\n\nvec2 random2(vec2 st){\n    //hash function to generate noise\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.177);\n    }\n    \nfloat gNoise(vec2 st) {\n    //gradient noise\n\tvec2 i = floor(st);\n\tvec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n    }\n\nfloat pi(){\n \treturn radians(180.0);   \n}\n\nvec2 intersectCircle(vec2 cp, vec2 rView){\n    \t\t//compute p and q from pq-formula\n            float cp_projected = dot(rView, cp);\n            return vec2(cp_projected, pow(cp_projected, 2.0)-dot(cp, cp));\n    }\n\n\n\nfloat diffuse(vec3 p, vec3 normal){\n            vec3 dirLight = normalize(lightSource-p);\n            return bLightSource*max(0.0, dot(normal, dirLight));\n    }\n\nvec3 chess(vec3 p, vec3 pFrag, vec3 normal){\n    //computes the chess pattern with diffuse lightning\n    vec3 cSand = vec3(0.76, 0.7, 0.5);\n    vec3 cSandStone = vec3(0.76, 0.57, 0.5);\n    vec3 cRock = vec3(0.71, 0.7, 0.65);\n \t\n    float tileSize = 4.0;\n    float pixSize = 3.0*2.0*length(v-p)\n        \t\t\t\t\t\t\t/(min(iResolution.x, iResolution.y)\n                                    *length(v-pFrag)\n                                    *tileSize);\n    \n    vec2 ij = floor(p.xy/tileSize);\n   \tvec3 cChess;\n    if(mod(ij.x, 2.0)==mod(ij.y, 2.0)){\n        cChess = cSand;\n    }\n    else{\n     \tcChess = cSandStone;   \n    }\n    \n    vec2 pLocal = abs(fract(p.xy/tileSize)-0.5);\n    float maxLocal = max(pLocal.x, pLocal.y);\n    \n    float bd = diffuse(p, normal);\n    return (ba+bd)*mix(cRock, cChess, smoothstep(0.0, pixSize, 0.49-maxLocal));  \n}\n\nvec3 rostrum(vec3 p, vec3 rView, float radius){\n    //essentially intersect ray with cylinder\n    vec3 cRock = vec3(0.71, 0.7, 0.65);\n    float h = 2.0;\n \t\n    vec2 sol = intersectCircle(-p.xy, normalize(rView.xy));\n    \n    vec3 pCylinder = p + rView*\n        \t\t\t\t(sol.x+sqrt(sol.y+pow(radius, 2.0)))\n                         /length(rView.xy);\n    \n    vec3 nCylinder = normalize(vec3(-pCylinder.xy, 0.0));\n    vec3 pPlane = p - (p.z-h) * rView / rView.z;\n    \n    float bd = mix(diffuse(pCylinder, nCylinder),\n             diffuse(pPlane, vec3(0.0, 0.0, 1.0)),\n             smoothstep(h-0.1, h, pCylinder.z));\n    return (ba+bd)*cRock;\n}\n\nvec3 computeBackground(vec3 p, vec3 rView){\n \tvec3 cSand = vec3(0.76, 0.7, 0.5);\n    vec3 cSandStone = vec3(0.76, 0.57, 0.5);\n    vec3 cSky = vec3(0.5, 0.76, 0.7);\n    \n    //check if XY-plane is visible\n    if(dot(rView, vec3(0.0, 0.0, 1.0))>-0.01*3.14){\n     \treturn cSky;   \n    }\n    \n    //calculate intersection with XY-plane\n    vec3 pXY = p - p.z * rView / rView.z;\n    float l0 = length(pXY);\n    float l1 = length(p - (p.z-2.0) * rView / rView.z);\n    vec2 polar = vec2(acos(pXY.x/l0)*sign(pXY.y)+pi(), l0);\n    \n    if(l1>30.0){\n        \n     \treturn cSky;  \n    }\n    else if(l0>25.0){\n        //compute rostrum\n        vec3 cRostrum = rostrum(p, rView, 25.0);\n        vec3 mix0 = mix(chess(pXY, p, vec3(0.0, 0.0, 1.0)),\n                        cRostrum,\n                   \t\tsmoothstep(25.0, 25.4, l0));  \n     \treturn mix(mix0, cSky,\n                   smoothstep(29.3, 30.0, l1));   \n    }\n    else{\n        //compute chess pattern\n        return chess(pXY, p, vec3(0.0, 0.0, 1.0));   \n    }\n}\n\n\n    \n\nmat3 rotationMatrix(const float angle, const vec3 axis){\n \tfloat alpha = radians(angle);\n    float c = cos(alpha);\n    float s = sin(alpha);\n    mat3 R;\n    R[0] = axis * axis.x * (1.0-c) + vec3(c, axis.z*s, -axis.y*s);\n    R[1] = axis * axis.y * (1.0-c) + vec3(-axis.z*s, c, axis.x*s);\n    R[2] = axis * axis.z * (1.0-c) + vec3(axis.y*s, -axis.x*s, c);\n    return R;\n}\n\nvec3 getCameraPosition(vec4 mouse){\n    //computes position of camera from difference between\n    //clicked and current pixel-coordinates\n    vec3 v0 = 20.0*vec3(1.0, 0.0, 1.0);\n    \n    if(iMouse.w<0.){\n        return v0;\n    }\n    else{\n        vec3 v;\n    \tvec2 angle = 200.0*(mouse.xy-mouse.zw);\n        angle.y = min(abs(angle.y), 40.0)*sign(angle.y);\n        \n        vec3 axVert = vec3(0.0, 0.0, 1.0);\n        mat3 rVert = rotationMatrix(angle.x, axVert);\n        v = rVert*v0;\n        \n        vec3 axFlat = normalize(cross(-v, axVert));\n\t\tmat3 rFlat = rotationMatrix(angle.y, axFlat);\n        return rFlat*v;\n    }\n}\n\nbool overlap(vec2 i0, vec2 i1){\n    //true if intervall 0 overlaps with intervall 1\n    if(i0.x>i0.y){\n      float temp = i0.x;\n      i0.x = i0.y;\n      i0.y = temp;  \n    }\n    return (clamp(i0.x, i1.x, i1.y)!=clamp(i0.y, i1.x, i1.y));\n}\n\nfloat f(vec2 pxy, float radius){\n \t//height of floor\n    float smoother = smoothstep(-radius, -0.3*radius, -length(pxy));\n    return 0.5*smoother*(1.0+sin(iTime+10.0*gNoise(0.2*pxy)));\n}\n\nvec3 raymarch(vec3 p, vec3 r, float radius, vec2 center){\n            float tol = 0.01;\n    \t\tvec3 pHat = p;\n            float fValue=1000.0;\n            float tolMarch = 30.0*tol;\n            \n    \t\tint iMax = 1000;\n            int i = 0;\n    \n    \t\t//first perform simple raymarch\n            while(fValue>0.0 && i<iMax){\n            pHat = pHat+tolMarch*r;\n            fValue = min(pHat.z-f(pHat.xy, radius),\n                         radius-length(center-pHat.xy));\n            }\n    \t\t\n    if(pHat.z-f(pHat.xy, radius)>0.0){\n        //terminate if ray hit boundary of cylinder\n        return vec3(1000.0);\n    }\n    else{\n        //perform local bisection for better quality\n        float b1 = (pHat.z-p.z)/r.z;\n        float b0 = b1-tolMarch;\n    \n    \n        float eta = 10000.0;\n            \n        i = 0;\n        float b;\n        while(abs(eta)>tol && i<iMax){\n                    b = 0.5*(b0+b1);\n                    pHat = p+b*r;\n                    eta = pHat.z-f(pHat.xy, radius);\n                    if(eta<0.0){\n                            b1 = b;\n                    }\n                    else{\n                            b0 = b;\n                    }\n                    i = i+1;\n            }\t\t\n    \treturn pHat;\n    }\n}\n\nvec4 warpedFloor(vec3 pFrag, vec3 p0, vec3 rView, float radius, vec2 center){\n       \n \tvec3 pSurface = raymarch(p0, rView, radius, center);\n    if (length(center-pSurface.xy)>radius){\n        \t//if ray hit cylinder return vector with alpha = 0\n        \treturn vec4(0.0);\n    \t}\n    else{\n        \tvec3 pProjected = vec3(pSurface.xy, 0.0);\n        \tfloat h = 0.001;\n            \n            float fValue = f(pProjected.xy, radius);\n            float dx = (f(pProjected.xy+vec2(h, 0.0), radius)-fValue)/h;\n            float dy = (f(pProjected.xy+vec2(0.0, h), radius)-fValue)/h;\n    \t\t\n        \tvec3 normal = normalize(cross(vec3(1.0, 0.0, dx), vec3(0.0, 1.0, dy)));\n        \t\n        \n        \treturn vec4(chess(pProjected, pFrag, normal), 1.0);\n    }\n        \n            \n}\n\nvec4 computeObject(vec3 p, vec3 rView){\n    vec3 cBrick = vec3(0.8, 0.25, 0.33);\n    vec2 center = vec2(0.0);\n    float radius =  10.0;\n    float h =1.0;\n    \n    //check if ray intersects a covering cylinder\n    //if yes, perform raymarch to compute the pixels color\n    vec2 sol = intersectCircle(center-p.xy, normalize(rView.xy));\n    float lxy = length(rView.xy);\n    \n    if(pow(radius, 2.0)+sol.y<=0.0){\n        return vec4(cBrick, 0.0);\n    }\n    \n    float temp = sol.x+sqrt(sol.y+pow(radius, 2.0));\n    vec3 p0 = p+(-sol.y-pow(radius, 2.0)+pow(sol.x, 2.0))*rView/(temp*lxy);\n    vec3 p1 = p+temp*rView/lxy;\n     \n    \n    if(overlap(vec2(p1.z, p0.z), vec2(0, h))){\n        return warpedFloor(p, p0, rView, radius, center);\n        \n    }\n       else{\n           \n           return vec4(cBrick, 0.0);\n       }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.0*(fragCoord-0.5*iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec4 mouse = iMouse/min(iResolution.x, iResolution.y);\n    \n    // set up camera\n    //vec3 v = 10.0*vec3(1.0, 0.0, 1.0);\n    v = getCameraPosition(mouse);\n    vec3 vDir = normalize(-v);\n    vec3 vLeft = normalize(cross(vDir, vec3(0.0, 0.0, 1.0)));\n    vec3 vUp = cross(vLeft, vDir);\n    float dScreen = 2.5;\n    \n    //calculate fragment position in space\n    vec3 pFrag = v + dScreen * vDir + uv.x*vLeft + uv.y * vUp;\n    \n    vec3 rView = normalize(pFrag-v);\n    \n    //compute the warped segment and if visible\n    //the background\n    vec4 color = computeObject(pFrag, rView);\n    if(color.w<0.5){\n       color = vec4(computeBackground(pFrag, rView), 1.0);\n    }\n\n\n    // Output to screen\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlGfWW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlKBDR", "name": "Doodling #8: Penumbra", "author": "lsdlive", "description": "Quick doodling yesterday, train session for the GROW's shader showdown.", "tags": ["tunnel", "raymarch", "doodling"], "likes": 11, "viewed": 611, "date": "1542217286", "time_retrieved": "2024-06-20T19:25:06.154653", "image_code": "// @lsdlive\n// CC-BY-NC-SA\n\n\nmat2 r2d(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\n// Tunnel pattern studied from shane & shau\n// i.e. https://www.shadertoy.com/view/4tKXzV\nvec2 path(float t) {\n\tfloat a = sin(t*.2 + 1.5), b = sin(t*.2);\n\treturn vec2(a*2., a*b);\n}\n\n// http://mercury.sexy/hg_sdf/\n// hglib mirrorOctant\nvoid mo(inout vec2 p, vec2 d) {\n\tp = abs(p) - d;\n\tif (p.y > p.x)p = p.yx;\n}\n\n// hglib pMod1\nfloat re(float p, float d) {\n\treturn mod(p - d * .5, d) - d * .5;\n}\n\n// hglib pModPolar\nvoid amod(inout vec2 p, float d) {\n\tfloat a = re(atan(p.x, p.y), d);\n\tp = vec2(cos(a), sin(a)) * length(p);\n}\n\n// iq's signed cross sc() - http://iquilezles.org/www/articles/menger/menger.htm\nfloat sc(vec3 p, float d) {\n\tp = abs(p);\n\tp = max(p, p.yzx);\n\treturn min(p.x, min(p.y, p.z)) - d;\n}\n\nfloat g = 0.;\nfloat de(vec3 p) {\n\n\tp.xy -= path(p.z);\n\n\tp.xy *= r2d(p.z*.05);\n\n\tvec3 q = p;\n\n    // cylinder section\n\tamod(q.xy, 6.28 / 7.);\n\tmo(q.xy, vec2(1, .6));\n\tq.xy *= r2d(q.z*.5);\n\tmo(q.xy, vec2(.1, .2));\n\tamod(q.xy, 6.28 / 3.);\n\tfloat cyl2 = length(q.xy) - .05;\n\n    p.z = re(p.z, .4);\n    \n    // cross structure section\n\tamod(p.xy, .785*2.);\n\tmo(p.xz, vec2(3, .01));\n\tamod(p.xy, .785*.5);\n\tp.x = abs(p.x) - 2.1;\n\tmo(p.xy, vec2(.4, 2));\n\tfloat d = sc(p, .02);\n    \n\tg += .008 / (.01 + d * d);// glow trick from balkhan https://www.shadertoy.com/view/4t2yW1\n\td = min(d, cyl2); // outside of the glow computation for cool effect & better contrast\n    \n\treturn d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = (fragCoord - .5*iResolution.xy) / iResolution.y;\n\n\tfloat dt = iTime * 3.;\n\tvec3 ro = vec3(0, 0, -3. + dt);\n\tvec3 ta = vec3(0, 0, dt);\n\n\tro.xy += path(ro.z);\n\tta.xy += path(ta.z);\n\n\tvec3 fwd = normalize(ta - ro);\n\tvec3 right = normalize(cross(fwd, vec3(0, 1, 0)));\n\tvec3 up = normalize(cross(right, fwd));\n\tvec3 rd = normalize(fwd + right * uv.x + up * uv.y);\n\n\tvec3 p;\n\tfloat t = 0., ri;\n\tfor (float i = 0.; i < 1.; i += .02) {\n\t\tri = i;\n\t\tp = ro + rd * t;\n\t\tfloat d = de(p);\n\t\td = max(abs(d), .002);// phantom mode trick from aiekick https://www.shadertoy.com/view/MtScWW\n\t\tt += d * .8;\n\t}\n\n\tvec3 c = mix(vec3(.5, .4, .3), vec3(.2, .1, .2), uv.x + ri);\n\tc += g * .034;// glow trick from balkhan https://www.shadertoy.com/view/4t2yW1\n\n\tfragColor = vec4(c, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-4.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlKBDR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlKBRV", "name": "SimpleVisualizer", "author": "Bricktronic", "description": "Yes.", "tags": ["visualizer"], "likes": 2, "viewed": 366, "date": "1543204064", "time_retrieved": "2024-06-20T19:25:06.154653", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float fft = texture(iChannel0,vec2(uv.x,uv.y)).x;\n    vec3 col;\n    col.x = uv.y*sin(iTime);\n    col.y = uv.x*cos(iTime);\n    col.z = (uv.x+fft)*sin(cos(uv.y)*iTime);\n    \n    if(fragCoord.y>iResolution.y/2.5 && fragCoord.y<iResolution.y/1.5){\n        col.y+=fft*uv.y;\n        col.x+=fft*uv.x;\n        col.z+=fft*uv.y;\n    }\n\n    // Output to screen\n    fragColor = vec4(col*(1.+(fft*0.1)),1.0);\n}", "image_inputs": [{"id": "XdfGzn", "previewfilepath": "/media/ap/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlKBRV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlKBRw", "name": "ShinyLightingTest", "author": "Del", "description": "Shiny Test", "tags": ["raymarch", "sdf", "twist", "symbol", "env", "handcrafted"], "likes": 3, "viewed": 320, "date": "1542112643", "time_retrieved": "2024-06-20T19:25:07.815238", "image_code": "// Symbol lighting test - Del 13/11/2018\n// removed SVG symbol, replaced with Symbol distance function...\n//------------------------------------------------------------------------\n// Camera\n//------------------------------------------------------------------------\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in vec2 mouse )\n{\n    mouse = vec2(0.0,0.0);\n    \n\n    mouse.y = sin(iTime*0.8)*0.2;\n    \n    float an = 10.0*mouse.x;\n\tcamPos = vec3(1.1*sin(an),0.3+mouse.y*2.0,1.1*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n//------------------------------------------------------------------------\n// Modelling \n//------------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\n#define PI 3.141592\n#define\tTAU 6.28318\n\nmat2 rotate(float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// simple bend(Y) mod\nvec2 opBendTest( vec2 p, float angle, float xmod )\n{\n    p.x += xmod;\n    p = rotate( angle * p.x ) * p.xy;\n    p.x -= xmod;\n    return p;\n}\n// simple spriral(x) mod\nfloat spiral(vec2 p, float sa, float b)\n{\n  float a = atan(p.y, p.x);\n  float l = length(p);\n  float n = (log(l/sa)/b - a) / (2.*PI);\n  float upper_ray = sa * exp(b *(a + 2.*PI*ceil(n)));\n  float lower_ray = sa * exp(b *(a + 2.*PI*floor(n)));\n  return min(abs(upper_ray - l), abs(l-lower_ray));\n}\n\n// 2D-shapes (Trapezoid, Ring, Box, Triangle)\nfloat dot2(in vec2 v ) { return dot(v,v); }\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n\n\tp.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y < 0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    \n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat ring(vec2 uv, float rad, float thickness)\n{\n    return abs(rad - length(uv)) - thickness;\n}\n\nfloat sdBox( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p) - b;\n\treturn min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}    \n\n// signed distance to a 2D triangle\nfloat sdTriangle( in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\nfloat NewSymbol(vec2 uv)\n{\n    vec2 p = uv+vec2(0.27,0.09);\n\tfloat s1 = length(p)-0.2;\t\t\t\t\t\t// circle1\n  \tfloat s2 = length(p+vec2(-0.22,-0.01))-0.18;\t// circle2\n\tp.x = spiral(p.xy, PI*0.5, -0.33);\t\t\t\t// Spiral distort\n    float d = sdTrapezoid(p,0.015,0.015,0.08);\t\t// could just be a box...\n\td = max(d, s1);\t\t\t\t\t\t\t\t\t// subtract circle\n\td = max(d,-s2);\t\t\t\t\t\t\t\t\t// subtract circle\n\n    p = vec2(abs(uv.x),uv.y);\n    //d = min(d,sdTriangle(vec2(-0.155,0.1),vec2(-0.055,0.1),vec2(-0.105,0.05),p.yx)); // mid-cross tri\n    d = min(d, sdTrapezoid(p.yx+vec2(0.105,-0.075),0.0,0.05,0.025));   \t\t\t// mid-cross trapeziod!\n    d = min(d,sdBox(p+vec2(-0.05,0.105),vec2(0.025,0.025)));\t\t\t\t\t\t// mid-cross bar\n    d = min(d,sdTriangle(vec2(0.0, -0.425),vec2(0.1, -0.25),vec2(-0.025, -0.35),p.xy)); // bottom triangle\n    \n\tp = opBendTest(uv+vec2(0.16, -0.088),radians(77.0),-0.103);\n    d = smin(d, sdTrapezoid(p.yx,0.018,0.025,0.19), 0.012); // bent arm (attempted to smooth the join, needs work)\n\n    d = min(d,sdBox(uv+vec2(0.0,0.13),vec2(0.032,0.2)));\t// main body\n    d = min(d,sdBox(uv+vec2(-0.08,-0.085),vec2(0.09,0.025))); // horn1 (bar)\n\n    float cuts = length( uv+vec2(-0.17,-0.32))-0.21;\n    cuts = min(cuts,length( uv+vec2(-0.17,0.15))-0.21);\n    cuts = min(cuts,length( uv+vec2(-0.73,-0.085))-0.4);\n    p = uv+vec2(-0.26,-0.085);\n    d = min(max(sdTrapezoid(p.yx,0.025,0.13,0.09),-cuts),d); // horn2 (cutout)\n    \n    d = smin(d,ring(uv+vec2(0.0,-0.26),0.13,0.028),0.01);\t\t\t// top-ring\n    \n    \n    return d;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opTwist( vec3 p )\n{\n    p.y += 0.5;\n    float scale = sin(iTime*1.25)*0.15;\n    \n    float  c = cos(scale*p.y+scale);\n    float  s = sin(scale*p.y+scale);\n    mat2   m = mat2(c,-s,s,c);\n    p = vec3(m*p.zy,p.x);\n    p.y -= 0.5;\n    return p;\n}\n\nvec3 rotateX(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(p.x, ca * p.y - sa * p.z, sa * p.y + ca * p.z);\n}\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n}\nvec3 rotateZ(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca * p.x - sa * p.y, sa * p.x + ca * p.y, p.z);\n}\n\n\nvec2 doModel( vec3 p )\n{\n    vec2 res = vec2( sdPlane(p+vec3(0.0,0.45,0.0)), 1.0);\t// floor...\n    \n    float t1 = fract(iTime*0.42)*TAU;\n    float t2 = fract(-iTime*0.2)*TAU;\n    \n    vec3 r1 = rotateY(p,t1);\n    r1 = rotateY(r1, sin(t2-p.y*1.95));\n    r1 = opTwist(r1);\n    \n    float symbolDist = NewSymbol(r1.xy);\n    float dep = 0.02;\n    vec2 e = vec2( symbolDist, abs(r1.z) - dep );\n    symbolDist = min(max(e.x,e.y),0.0) + length(max(e,0.0));\n    symbolDist -= 0.01;    \n    \n    res = opU(res,vec2(symbolDist,3.0));\n    return res;\n}\n\n//------------------------------------------------------------------------\n// Lighting\n//------------------------------------------------------------------------\nfloat calcSoftshadow( in vec3 ro, in vec3 rd );\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in float mat )\n{\n    vec3 mal = vec3(0.0);\n    if (mat<=1.0)\n    {\n        float f = mod( floor(1.5*pos.z) + floor(1.5*pos.x), 2.0);\n        mal = 0.2 + 0.2*f+0.2*vec3(0.45,0.85,1.0)*2.0;\n    }\n    else\n\t\tmal = vec3(0.65,0.35,0.35)+reflect(pos*0.1, nor);     \n    vec3  lig = normalize(vec3(0.7,0.35,1.0));\t\t// dir\n\tvec3 color = mal * (dot(nor, lig) + pow(dot(nor, lig), 10.0)*4.0);\n    \n    // shadow\n    float dif = max(dot(nor,lig),0.0);\n    float sha = 0.0;\n    if( dif>0.01 )\n        sha=calcSoftshadow( pos+0.01*nor, lig );\n    color *= sha;\n    \n    // fog    \n    //-----------------------------\n\tcolor *= exp(-0.0085*dis*dis);\n    \n    return color;\n}\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 10.0;           // max trace distance\n\tconst float precis = 0.001;        // precission of the intersection\n    float h = precis*2.0;\n    float t = 0.0;\n\t//float res = -1.0;\n    vec2 res = vec2(-1.0,0.0);\n    float c = 0.0;\n    \n    for( int i=0; i<100; i++ )          // max number of raymarching iterations is 90\n    {\n        if( h<precis||t>maxd ) break;\n        vec2 res2 = doModel( ro+rd*t );\n\t    h = res2.x;\n        c = res2.y;\n        \n        t += h*0.75;\n    }\n\n    if( t<maxd )\n    {\n        res.x = t;\n        res.y = c;\n    }\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.001;             // precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps ).x + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ).x + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ).x + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ).x );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.0005;                 // selfintersection avoidance distance\n\tfloat h = 1.0;\n    for( int i=0; i<40; i++ )         // 40 is the max numnber of raymarching steps\n    {\n        h = doModel(ro + rd*t).x;\n        res = min( res, 64.0*h/t );   // 64 is the hardness of the shadows\n\t\tt += clamp( h, 0.02, 2.0 );   // limit the max and min stepping distances\n    }\n    return clamp(res,0.25,1.0);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n  \tvec3 col = vec3(0.1);\n\n\t// raymarch\n    vec2 res = calcIntersection( ro, rd ); \n    float t = res.x;\n    if( t>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n        col = doLighting( pos, nor, rd, t, res.y );\n\t}\n\n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n    // gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlKBRw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlKBWD", "name": "Intro to gfx - homework mb2271", "author": "mihaiberechet", "description": "This is my homework for Introduction to Graphics", "tags": ["work"], "likes": 1, "viewed": 67, "date": "1542588655", "time_retrieved": "2024-06-20T19:25:08.948661", "image_code": "\n// Settings\nconst float FOV_DEG = 80.0f;\nconst int MAX_STEPS = 300;\nconst vec3 LIGHT_DIR = vec3(1.0,1.0,-1.0);\n\n// Consts / Enumerations \nconst float EPS = 0.0001f;\nconst float DEG_TO_RAD = 0.0174533f;\nconst float M_PI = 3.14159265358979323846;\nconst int FLOOR_PLANE = 1;\nconst int OBJECT = 2;\nconst int OBJECT2 = 3;\nconst int NO_HIT = 0;\n\n///////////////////////////////////////////////////////////\n\nstruct Ray\n{\n    vec3 Orgin;\n    vec3 Direction;\n};\n\n//Utils\nmat3 CreateRotationX(float rotation)\n{\n    mat3 rotateX =\n     mat3(\n        1.0, 0.0, 0.0,\n\t\t0.0, cos(rotation), -sin(rotation),\n\t\t0.0, sin(rotation), cos(rotation)\n    );\n\n    return rotateX;\n}\n\nmat3 CreateRotationY(float rotation)\n{\n    mat3 rotateY = \n     mat3(\n        cos(rotation), 0.0, sin(rotation),\n\t\t0.0, 1.0, 0.0, \n\t\t-sin(rotation), 0.0, cos(rotation)\n    );\n\n    return rotateY;\n}\n\nmat3 CreateRotationZ(float rotation)\n{\n    mat3 rotateZ =\n    mat3(\n        cos(rotation), -sin(rotation), 0.0,\n\t\tsin(rotation), cos(rotation), 0.0,\n\t\t0.0, 0.0, 1.0\n    );\n\n    return rotateZ;\n}\n\n// SDFs\nfloat SphereSDF(vec3 p)\n{\n    return length(p)-1.1;\n}\n\nfloat TorusSDF(vec3 p, float R, float r)\n{  \n    float xy = length(p.xy) - R;\n    float z = length(vec2(xy,p.z))-r; \n    return z;\n}\n\nfloat BoxSDF(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0))-0.1;\n}\n\nfloat CylinderSDF(vec3 p,float radius)\n{   \n    float d = length(p.xz)-radius;\n    d = max(d,p.y-1.0);\n    d = max(d,-p.y-1.0);\n    return d;\n}\n\nfloat PlaneSDF(vec3 p, float y)\n{\n    return p.y+y;\n}\n\nvec3 RepeatX(vec3 p, float offset)\n{\n    p.x = mod(p.x,offset) - offset/2.0;\n    return p;\n}\n\nvec3 Twist(vec3 p, float amount)\n{\n    float c = cos(amount*p.y);\n    float s = sin(amount*p.y);\n    \n    // Create 2D rotation matrix\n    mat2 rm = mat2(c,-s,s,c);\n    p.xz *=rm;\n    return p;\n}\n\nvoid Phong(vec3 L, vec3 N, vec3 V, float sh, out float d, out float s)\n{\n    // IMPLEMENT PHONG MODEL HERE\n    d = dot(N, L);\n    s = pow(dot(V, normalize(reflect(V, N))), sh);\n}\n\n//Main scene distance field function\nfloat CombineSDF(vec3 p, inout int closest)\n{\n      vec3 pn = p*vec3(1.0,0.6,1.0);;\n      pn =  Twist(pn+vec3(0,0,-0.3),sin(iTime)*0.5);//CreateRotationY(iTime)* vec4(p,0);\n      float sd = SphereSDF(pn.xyz);  \n  \n      sd = max(BoxSDF(pn.xyz,vec3(0.95)),-sd); \n      float  torus = TorusSDF(CreateRotationY(iTime)*(p + CreateRotationY(iTime*0.3)*vec3(0.0,0.0,2.5)) ,0.9f,0.4f);\n      sd = min(torus,sd);      \n      float pd =  PlaneSDF(p,23.0); \n      float fin = min(sd,pd);\n      closest = OBJECT;\n      if(fin == pd)\n      { closest = FLOOR_PLANE;}\n      else if(fin == torus) \n      {closest = OBJECT2;}\n      return fin;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    int dummy = 0;\n    return \n    normalize(vec3(\n\t\tCombineSDF(vec3(p.x + EPS, p.y, p.z), dummy) - CombineSDF(vec3(p.x - EPS, p.y, p.z), dummy),\n\t\tCombineSDF(vec3(p.x, p.y + EPS, p.z), dummy) - CombineSDF(vec3(p.x, p.y - EPS, p.z), dummy),\n\t\tCombineSDF(vec3(p.x, p.y, p.z + EPS), dummy) - CombineSDF(vec3(p.x, p.y, p.z - EPS), dummy)\n\t\t));\n}\n\nfloat Trace(Ray r,inout int hit)\n{\n    hit = 0;\n    float t = 0.0f;\n    \n    for(int i =0; i < MAX_STEPS; ++i)\n    {\n       vec3 p = r.Orgin + r.Direction * t;\n       int closest = 0;     \n       float sd = CombineSDF(p, closest);\n           \n       if(sd < EPS)\n       {\n          hit = closest;\n          return t;\n       }\n       t += sd;\n    }\n    return 0.0f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Frag coord normalization \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    // Make center of the screen be (0,0)\n    uv = uv * 2.0 - 1.0; \n    // Aspect ratio\n    uv.x *= iResolution.x/iResolution.y;\n    \n    //FOV\n    float fovDist = tan(FOV_DEG  *0.5 * M_PI / 180.0); \n    uv *= fovDist;\n    \n    //TODO: TASK2\n    //CHANGE CAMERA POSITION AND ORIENTATION HERE:\n    Ray r;\n    r.Direction = normalize(vec3(uv,1.0) * CreateRotationX(35.0 * DEG_TO_RAD));\n    r.Orgin = vec3(0,0,-4.0) + vec3(0,4.0,-1.0);\n    \n    int hit = NO_HIT;   // indicates type of the object hit\n    float t = Trace(r,hit);  \n    vec3 hitAt = r.Orgin + r.Direction * t;\n    vec3 N = GetNormal(hitAt);\n    \n    float diff,spec = 0.0;\n    vec3 col = vec3(0); \n    \n    if(hit == OBJECT) // Block\n    {        \n        Phong(LIGHT_DIR,N,-r.Direction,50.0,diff,spec);\n        col =  vec3(0.2,0.04,0.2)+ vec3(0.5,0.0,0.5) * diff + vec3(1.0) * spec;\n    }\n    else if(hit == OBJECT2) // Torus\n    {\n        Phong(LIGHT_DIR,N,-r.Direction,50.0,diff,spec);\n        vec3 baseCol = vec3(clamp(cos(hitAt.y),0.0,1.0), clamp(sin(hitAt.y),0.0,1.0),0.0);\n        col =  0.3 * baseCol + 0.7 * baseCol * diff + vec3(1.0)*spec; \n    } \n    else if(hit == FLOOR_PLANE) // Floor\n    {\n        float ar = iResolution.x/iResolution.y;\n        vec2 planeUV = vec2(80.0+hitAt.x,hitAt.z)/200.0;\n        col = texture(iChannel0, planeUV).xyz; \n        //TODO: TASK3\n        // ADD FLOOR PATTERNS\n        col *= ((cos(hitAt.x / 2.0) + 1.0) / 2.0);\n\n        vec3 secondColor = vec3(0.2, 0.7, 0.3);\n        vec3 thirdColor = vec3(0.4, 0.1, 0.6); \n        vec3 hColor = secondColor + (thirdColor - secondColor) * ((sin(hitAt.x / 18.0) + 1.0) / 2.0);\n\t\tcol = hColor + (col - hColor) * ((cos(hitAt.z / 2.0) + 1.0) / 2.0);\n        \n        float maxLength = 40.0;\n        vec3 origin = vec3(cos(iTime) * 50.0, sin(iTime) * 50.0, 0.0);\n        col = col * (min(maxLength/ length(hitAt - origin), 1.0));\n    }\n    \n    else // NO HIT - BACKGROUND COLOR\n    {\n      col = 0.5 + 0.5 * cos(uv.xyx + vec3(0,2.3,3.5));\n    }\n    //TODO: TASK3\n    //SCREEN SPACE EFFECTS\n    vec3 grayCol = vec3((col.x + col.y + col.z) / 3.0);\n    float sat = pow((fragCoord.x/iResolution.x), 2.8);\n    col = grayCol + (col - grayCol) * sat;\n    \n   // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlKBWD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlKfDh", "name": "Fractal Seizure 2.0", "author": "hhhzzzsss", "description": "The shading is really different so I made it it's own thing.", "tags": ["2d", "fractal", "juliaset", "flashingcolors"], "likes": 3, "viewed": 159, "date": "1542387060", "time_retrieved": "2024-06-20T19:25:08.954692", "image_code": "vec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec2 randDisplacement() {\n    return vec2(fract(sin(iTime*14237.14238)*23403.24234),\n                fract(sin(iTime*35034.24809)*23473.42303));\n}\n\nvec2 gradient(float c) {\n    float w1 = 1.0-mod(c, 0.02)*50.0;\n    float bri;\n    float sat = 1.0;\n    if (w1<0.9) {\n        bri = 1.0 - w1/0.9 + 0.2;\n    }\n    else {\n        bri = (w1-0.9) / 0.1 + 0.2;\n    }\n    if (bri>1.0) {\n        sat = 1.0 - (bri-1.0)/0.5;\n    }\n    return vec2(min(1.0, bri), sat);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\t\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv*2.0 - 1.0;\n    uv *= 0.7+0.3*sin(iTime*14.2354);\n    uv.x *= iResolution.x / iResolution.y;\n    float theta = iTime*10.0;\n    mat2 rot = mat2 (cos(theta), sin(theta), -sin(theta), cos(theta));\n    uv *= rot;\n    uv += 0.4*randDisplacement();\n    \n    vec2 z = uv;\n    vec2 c = vec2(-0.73+0.05*cos(30.5142*iTime+0.3),0.3+0.1*sin(10.0*iTime+0.9));\n    \n    float minDist = 100.0;\n    float iterations = -1.0;\n    for (float i = 0.0; i < 200.0; i++) {\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;\n        if (abs(z.y)<minDist) {\n            minDist = abs(z.y);\n        }\n        if (dot(z,z) > 256.0) {\n            iterations = i;\n            break;\n        }\n    }\n    \n    iterations = iterations + 2.0 - log(log(length(z)))/log(2.0);\n    \n    float hue = pow(iterations/50.0,0.4+0.2*sin(4.534243*iTime));\n    hue += iTime*10.0;\n    \n    if (iterations >= 0.0) {\n        vec2 brisat = gradient(hue);\n\t\tfragColor = vec4(hsv2rgb(vec3(hue,brisat.y,brisat.x)) ,1.0);\n    }\n    else {\n        fragColor = vec4(min( vec3(1.0), (1.0-minDist*200.0)*vec3(1.0,1.2,2.0) ), 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlKfDh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlKfDz", "name": "Dripping down", "author": "cras", "description": "Couldn't come up with a more interesting way to color it...any suggestions?", "tags": ["2d", "noise"], "likes": 5, "viewed": 129, "date": "1542238479", "time_retrieved": "2024-06-20T19:25:08.954692", "image_code": "float rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.y *= iResolution.y/iResolution.x;\n    st *= 20.;\n\n\tfloat steps = step(0.1, noise(st + iTime) * fract(st.y - 0.45));\n    vec3 color;\n    if (steps == 0.0) {\n        color = vec3(0.297,0.725,0.539);\n    } else {\n        color = vec3(0.751,0.980,0.755);\n    }\n    \n    fragColor = vec4(vec3(color),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlKfDz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlKfWR", "name": "raymarch anything 3", "author": "Del", "description": "march", "tags": ["march"], "likes": 5, "viewed": 350, "date": "1542215519", "time_retrieved": "2024-06-20T19:25:08.954692", "image_code": "// raymarch anything #3 - Del 14/11/2018\n\nfloat pMod1(inout float p, float size)\n{\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nfloat hash(vec2 p)  // replace this by something better\n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nmat2 rotate(float a)\n{\n\tfloat c = cos(a),\n\t\ts = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat objID = 0.0;\nfloat svobjID = 0.0;\n\n#define\tTAU 6.28318\n\nfloat map(vec3 p)\n{\n    float time=iTime;\n    float zo = time*6.75;\n    float modz = mod(zo,44.0);\n    \n    float t2 = fract(time*1.1) * TAU;\n    float t3 = fract(time*0.7) * TAU;\n    float t4 = fract(time*0.14)* TAU;\n    \n    float m = 0.5+sin(t2+p.z*0.4)*0.5;\n    m += 0.5+cos(p.z*0.4+t3+p.x*0.4)*0.5;\n    \n    p.xy *= rotate(p.z * .08 + t4);\n    \n\tp.z += modz;\n    float c1 = pMod1(p.z,44.0);\n    \n\tfloat dist = 3.5 -abs(p.y)+m;\n    \n    vec3 p2 = p;\n\tfloat cz = pMod1(p2.z,4.0);\n\tfloat cx = pMod1(p2.x,4.0);\n\n    float r = hash(vec2(cz+(cz*0.31),cx+(cx*0.61)));\n\n    if (abs(cx)<1.0)\n        r=0.0;\n\n    if (r>0.75)\n    {\n\t\tfloat d2 = sdCylinder(p2,vec2(0.7,5.5));         \n        dist = smin(dist,d2,1.1);\n    }\n\n    objID = abs(p.z)/44.0;\n    return dist;\n}\n\nvec3 normal(vec3 p)\n{\n\tvec2 e = vec2(.001, 0.);\n\tvec3 n;\n\tn.x = map(p + e.xyy) - map(p - e.xyy);\n\tn.y = map(p + e.yxy) - map(p - e.yxy);\n\tn.z = map(p + e.yyx) - map(p - e.yyx);\n\treturn normalize(n);\n}\n\nvec3 render(vec2 uv)\n{\n    float time = iTime;\n\tvec3 ro = vec3(0.0, 0.0, 0.0);\n\tvec3 rd = normalize(vec3(uv, 1.95));\n\tvec3 p = vec3(0.0);\n\tfloat t = 0.;\n\tfor (int i = 0; i < 180; i++)\n    {\n\t\tp = ro + rd * t;\n\t\tfloat d = map(p);\n\t\tif (d < .001 || t > 100.) break;\n\t\tt += .25 * d;\n\t}\n    \n    svobjID = objID;\n\tvec3 l = ro+vec3(0.0,0.0,12.0);\n\tvec3 n = normal(p);\n\tvec3 lp = normalize(l - p);\n\tfloat diff = 1.2 * max(dot(lp, n), 0.);\n    \n    vec3 c1 = vec3(2.54,2.2,1.25);\n    vec3 c2 = vec3(2.54,1.1,1.85);\n    \n    float m = svobjID;\n    vec3 col = mix(c1,c2,m);\n    \n\treturn col*diff / (1. + t * t * .01);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 col = render(uv);\n\t// vignette\n    col *= 0.4 + 0.6*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\tfragColor = vec4(col, 1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlKfWR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlKfzy", "name": "noise ripoff", "author": "milolouis", "description": "noise", "tags": ["noiseripoff"], "likes": 2, "viewed": 77, "date": "1543175442", "time_retrieved": "2024-06-20T19:25:09.288221", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\n// 2D Random\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(iTime / 100000.00,78.233)))\n                 * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n\n    // Scale the coordinate system to see\n    // some noise in action\n    vec2 pos = vec2(uv*1024.0);\n\n    // Use the noise function\n    float n = noise(pos);\n\n\n    // Output to screen\n    fragColor = vec4(vec3(n), 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlKfzy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XltBWj", "name": "Simple terrain", "author": "HUYNH", "description": "Simple terrain with noise and smooth function", "tags": ["terrain"], "likes": 1, "viewed": 163, "date": "1541800884", "time_retrieved": "2024-06-20T19:25:09.288221", "image_code": "\nconst float EPSILON = 0.0001;\n\n\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n\n// Reference:  https://thebookofshaders.com/11/?lan=fr\n// noise\n// Not so good, but ok \nfloat noise (float px, float pz) {\n    vec2 st = vec2(px,pz);\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth\n\n    vec2 u = f*f*(3.0-2.0*f);\n    \n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nvec3 getNormal( const vec3  p )\n{\n    return normalize( vec3( noise(p.x-EPSILON,p.z) - noise(p.x+EPSILON,p.z),\n                            2.0*EPSILON,\n                            noise(p.x,p.z-EPSILON) - noise(p.x,p.z+EPSILON) ) );\n}\n\n\n// Phong shading\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    \n    vec3 N = getNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        \n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n       \n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(50.0 * sin(iTime/2.0),\n                          80.0,\n                          50.0 * cos(iTime/2.0));\n    \n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n   \n    return color;\n}\n\n\nbool castRay(vec3  ro,  vec3 rd, inout float resT)\n{\n    \n    const float delt = 0.1;\n    const float mint = 0.00;\n    const float maxt = 20.0;\n    for( float t = mint; t < maxt; t += delt )\n    {\n         vec3 p = ro + rd*t;\n        if( p.y < 0.5*noise( p.x, p.z ) )\n        {\n            resT = t - 0.5*delt;\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0, 2, 0);\n    float dist ;\n    \n    if (!castRay(eye, dir,dist)) {\n        // Sky \n        vec3 col = 0.9*vec3(0.4,0.65,1.0) - dir.y*vec3(0.4,0.36,0.4);\n        \n        fragColor = vec4(col, 0.0);\n\t\treturn;\n    }\n    \n    // Terrain Color\n    vec3 p = eye + dist * dir;\n    vec3 K_a = vec3(0.2, 0.2, 0.2);\n    vec3 K_d = vec3(0.7, 0.2, 0.2);\n    vec3 K_s = vec3(0.0, 0.0, 0.0);\n    float shininess = 0.0;   \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XltBWj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XltBzB", "name": "another 2d house", "author": "lovelyH", "description": "Recently there is a lot of 2d houses on shadertoy. So I decide to also make one.", "tags": ["2d", "house"], "likes": 12, "viewed": 126, "date": "1543264078", "time_retrieved": "2024-06-20T19:25:10.542513", "image_code": "\nvec2 rot(vec2 p, float l){\n\tfloat s= sin(l), c= cos(l);\n\treturn vec2(\n\t\tc*p.x - s*p.y,\n\t\ts*p.x + c*p.y\n\t\t);\n}\n\n\n\n/// hold color result of helper drawing function\nvec3 rc;\n\n\n/// draw window\nbool getWindow(vec2 uv){\n\tuv= abs(uv);\n\tif( max( uv.x, uv.y ) < 0.1 ){\n\t\tif( min( uv.x,uv.y) < 0.01 || 0.08 < max(uv.x,uv.y) )\n\t\t\trc= vec3(.4,.3,.3);\n\t\telse\n\t\t\trc= vec3(.3,.5,.9);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n\n\nvec3 getFaceColor(vec2 uv){\n\tuv.x= abs(uv.x);\n\t// /// eyes\n\t// if( length(uv - vec2(0.015,0.015)) < 0.007 )\n\t// \treturn vec3(.1);\n\t// /// lips\n\t// if( abs(length(uv)-0.02) < 0.005 && uv.y < -0.01 )\n\t// \treturn vec3(.1);\n\n\t/// eyes\n\tif( length(uv - vec2(0.011,0.005)) < 0.005 )\n\t\treturn vec3(.1);\n\t/// lips\n\tif( abs(length(uv-vec2(0,-.01))-0.02) < 0.003 && uv.y < -0.02 )\n\t\treturn vec3(.1);\n\treturn vec3(.9,.9,.8);\n}\n\n\n\nbool getWhite(vec2 uv, bool female, float generationAndAge){\n\tint generation= int(floor(generationAndAge));\n\tfloat age= fract( generationAndAge );\n\tif( age < 0.05 ){\n\t\t// uv.x += 0.15;\n\t\t// uv.y += 0.13;\n\t\t// uv= rot(uv,0.5);\n\t\t// if( length(uv) < 0.05 || length(uv-vec2(0.0,0.04)) < 0.05 ){\n\t\t// \trc= vec3(1);\n\t\t// \treturn true;\n\t\t// }\n\t\treturn false;\n\t}\n\tif( age < 0.25 ){\n\t\tuv =  (uv-vec2(0.0,-0.5)) / (clamp(age,0.2,0.25)/0.25) + vec2(0.0,-0.5);\n\t}\n\t\n\tvec3 hairColor= vec3(.1);\n\tif( female ){\n\t\tswitch(int(mod(float(generation),3.))){\n\t\t\tcase 0: hairColor= vec3(.9,.9,.1); break;\n\t\t\tcase 1: hairColor= vec3(.9,.2,.1); break;\n\t\t}\n\t}\n\thairColor= mix( hairColor, vec3(.7), 2.5*(age-0.6) );\n\n\tfalse;///@todo something is probably wrong with compiler. that line need to be here\n\tif( female ){\n\t\t/// config\n\t\tfloat dressLenght= clamp( -0.3+0.01*float(generation), -0.3, -0.2 );\n\t\tfloat hairLenght= clamp( mod( float(generation)*0.07, 0.1 )  , 0.0, 0.1);\n\t\tvec3 dressColor= vec3(.9);\n\t\tswitch(int(mod(float(generation),5.))){\n\t\t\tcase 0: dressColor= vec3(.7,.7,.7); break;\n\t\t\tcase 1: dressColor= vec3(.9,.5,.9); break;\n\t\t\tcase 2: dressColor= vec3(.1,.5,.9); break;\n\t\t\tcase 3: dressColor= vec3(.4,.8,.5); break;\n\t\t}\n\n\t\tuv.x= abs(uv.x);\n\t\t/// hair\n\t\tif( \n\t\t\t(0.03 < uv.x || 0.02 < uv.y  )\n\t\t\t&&\n\t\t\t(\n\t\t\t\tlength(uv) < 0.05 && 0.0 < uv.y\n\t\t\t\t||\n\t\t\t\tuv.x < 0.05 && uv.y <= 0.0 && -hairLenght < uv.y\n\t\t\t)\n\t\t ){\n\t\t\trc= hairColor;\n\t\t\treturn true;\n\t\t}\n\t\t/// head\n\t\tif( length(uv) < 0.04 ){\n\t\t\trc= getFaceColor(uv);\n\t\t\treturn true;\n\t\t}\n\t\t/// dress bottom\n\t\tif( dressLenght < uv.y && 3.0*uv.x + uv.y < -0.05 )\n\t\t{\n\t\t\trc= dressColor;\n\t\t\treturn true;\n\t\t}\n\t\t/// dress top\n\t\tif( -0.2 < uv.y && uv.x - 0.1 * uv.y < 0.05 && uv.y < -0.04 && -0.29 < uv.y )\n\t\t{\n\t\t\trc= dressColor;\n\t\t\treturn true;\n\t\t}\n\t\t/// hands\n\t\tvec2 u= rot(uv-vec2(0.0,-0.00),-0.5);\n\t\tu.x= abs(u.x);\n\t\tif( u.x < 0.01 && -0.2 < u.y ){\n\t\t\tif( u.y < -0.17 ){\n\t\t\t\trc= vec3(1);\n\t\t\t}else{\n\t\t\t\trc= dressColor;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\t/// legs\n\t\tu= uv;\n\t\tu.x= abs(u.x-0.025);\n\t\tif( u.x < 0.012 && u.y < -0.18 && -0.34 < u.y ){\n\t\t\trc= -0.31 < u.y ? vec3(.9,.9,.8) : vec3(.3,.0,.0);\n\t\t\treturn true;\n\t\t}\n\t}else{\n\t\tvec3 clothColor= vec3(.1,.2,.1);\n\t\tswitch(int(mod(float(generation),7.))){\n\t\t\tcase 0:clothColor= vec3(.5,.1,.1); break;\n\t\t\tcase 1:clothColor= vec3(.2,.1,.6); break;\n\t\t\tcase 2:clothColor= vec3(.4,.1,.8); break;\n\t\t\tcase 3:clothColor= vec3(.6,.6,.99); break;\n\t\t\tcase 4:clothColor= vec3(.85); break;\n\t\t\tcase 5:clothColor= vec3(.7); break;\n\t\t}\n\t\t\n\t\tvec3 clothColor2= vec3(.12,.15,.5);\n\t\tswitch(int(mod(float(generation),3.))){\n\t\t\tcase 0: clothColor2= vec3(.3,.2,.2); break;\n\t\t\tcase 1: clothColor2= vec3(.5,.4,.4); break;\n\t\t}\n\t\t\n\t\tvec2 u;\n\t\tuv.x= abs(uv.x);\n\t\t/// hair\n\t\tif( \n\t\t\t(0.03 < uv.x || 0.02 < uv.y  )\n\t\t\t&&\n\t\t\t(\n\t\t\t\tlength(uv) < 0.05 && 0.0 < uv.y\n\t\t\t\t||\n\t\t\t\tuv.x < 0.05 && uv.y <= 0.0 && 0.0 < uv.y\n\t\t\t)\n\t\t ){\n\t\t\trc= hairColor;\n\t\t\treturn true;\n\t\t}\n\t\t/// head\n\t\tif( length(uv) < 0.04 ){\n\t\t\trc= getFaceColor(uv);\n\t\t\treturn true;\n\t\t}\n\t\t/// legs\n\t\tu= uv;\n\t\tif( u.y < -0.16 )\n\t\tif( -0.34 < u.y && u.x < 0.012+0.025 && (  0.01 < u.x || -0.2 < u.y )  )\n\t\t{\n\t\t\trc= -0.31 < u.y ? clothColor2 : vec3(.1,.0,.0);\n\t\t\treturn true;\n\t\t}\n\t\t/// t-shirt top\n\t\tif( -0.2 < uv.y && uv.x - 0.1 * uv.y < 0.05 && uv.y < -0.04 && -0.29 < uv.y )\n\t\t{\n\t\t\trc= uv.y < -0.15 ? vec3(0) : clothColor;\n\t\t\treturn true;\n\t\t}\n\t\t/// hands\n\t\tu= rot(uv-vec2(0.0,-0.00),-0.5);\n\t\tu.x= abs(u.x);\n\t\tif( u.x < 0.01 && -0.2 < u.y ){\n\t\t\tif( u.y < -0.17 ){\n\t\t\t\trc= vec3(1);\n\t\t\t}else{\n\t\t\t\trc= clothColor;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\t/// not us\n\treturn false;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv= 2.0 * fragCoord / iResolution.xy - vec2(1.0,1.0);\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tvec3 r;\n\tfloat generation= 0.2 * iTime;\n\tgeneration= floor(generation) + 0.5 * fract(generation);\n\tbool isChildFemale= mod(generation,2.0) < 1.0;\n\tfloat parentMove1= clamp( 20.0 * (mod(generation,1.0) - 0.26 ) , 0.0, 1.0 );\n\tfloat pairMove=    clamp( 15.0 * (mod(generation,1.0) - 0.30 ) , 0.0, 100.0 );\n\tfloat parentMove2= clamp( 15.0 * (mod(generation,1.0) - 0.35 ) , 0.0, 100.0 );\n\n\tif( false ){\n\t}else if(mod(generation,1.0) < 0.05 && ( length(rot(uv+vec2(0.15+0.6,0.13+0.2),0.5)) < 0.05 || length(rot(uv+vec2(0.15+0.6,0.13+0.2),0.5)-vec2(0,0.04)) < 0.05 ) ){\n\t\t/// infrant\n\t\tr= vec3(1);\n\t}else if( getWhite(uv-vec2(-0.8-parentMove2,-0.2) + parentMove1 * vec2(0.2,0.2), true, generation - 0.5 ) ){\n\t\t/// mum\n\t\tr= rc;\n\t}else if( getWhite(uv-vec2(-0.4-parentMove2,-0.2) + parentMove1 * vec2(-0.2,0.2), false, generation - 0.5 ) ){\n\t\t/// dad\n\t\tr= rc;\n\t}else if( getWhite(uv-vec2(-0.6 + clamp( 15.0 * (mod(generation,1.0) - 0.42 ) , 0.0, 1.0 )*(isChildFemale?-0.2:0.2),-0.2), isChildFemale, generation ) ){\n\t\t/// child\n\t\tr= rc;\n\t}else if( getWhite(uv-vec2(-0.6 + (isChildFemale?0.2:-0.2) - 10.0*clamp(0.4-mod(generation,1.0), 0.0, 1.0) , -0.2), !isChildFemale, generation ) ){\n\t\t/// pair\n\t\tr= rc;\n\t}else if( true && uv.x + uv.y < 1.8 && - uv.x + uv.y < 0.4 && 0.4 < uv.y && uv.y < 0.7  ){\n\t\t/// house roof\n\t\tr = vec3(.9,.1,.1);\n\t}else if( getWindow(uv-vec2(0.4,0.2)) ){\n\t\t/// window 1\n\t\tr = rc;\n\t}else if( getWindow(uv-vec2(1.0,0.2)) ){\n\t\t/// window 2\n\t\tr = rc;\n\t}else if( getWindow(uv-vec2(0.4,-0.25)) ){\n\t\t/// window 3\n\t\tr = rc;\n\t}else if( abs(uv.x-0.9) < 0.1 && abs(uv.y+0.3) < 0.2 ){\n\t\t/// door\n\t\tr = vec3(.5,.3,.1);\n\t}else if( abs(uv.x-0.7) < 0.6 && abs(uv.y) <= 0.5 ){\n\t\t/// house wall\n\t\tr = vec3(.7);\n\t}else if( + uv.x * uv.x * 0.04 +uv.y < -0.3 ){\n\t\t/// grass\n\t\tr = vec3(.3,.7,.2);\n\t}else{\n\t\t/// sky\n\t\tr = vec3(.5,.5,.9);\n\t}\n\n\tfragColor = vec4(r,0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XltBzB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlVBDR", "name": "Intro to gfx ‚Äì  homework    ", "author": "Jacko1222", "description": "Throwing shade.\nJack Parkinson's supervision work", "tags": ["phonghomework"], "likes": 0, "viewed": 54, "date": "1542219069", "time_retrieved": "2024-06-20T19:25:10.542753", "image_code": "\n// Settings\nconst float FOV_DEG = 80.0f;\nconst int MAX_STEPS = 300;\nconst vec3 LIGHT_DIR = vec3(1.0,1.0,-1.0);\n\n// Consts / Enumerations \nconst float EPS = 0.0001f;\nconst float DEG_TO_RAD = 0.0174533f;\nconst float M_PI = 3.14159265358979323846;\nconst int FLOOR_PLANE = 1;\nconst int OBJECT = 2;\nconst int OBJECT2 = 3;\nconst int NO_HIT = 0;\n\n///////////////////////////////////////////////////////////\n\nstruct Ray\n{\n    vec3 Origin;\n    vec3 Direction;\n};\n\n//Utils\nmat3 CreateRotationX(float rotation)\n{\n    mat3 rotateX =\n     mat3(\n        1.0, 0.0, 0.0,\n\t\t0.0, cos(rotation), -sin(rotation),\n\t\t0.0, sin(rotation), cos(rotation)\n    );\n\n    return rotateX;\n}\n\nmat3 CreateRotationY(float rotation)\n{\n    mat3 rotateY = \n     mat3(\n        cos(rotation), 0.0, sin(rotation),\n\t\t0.0, 1.0, 0.0, \n\t\t-sin(rotation), 0.0, cos(rotation)\n    );\n\n    return rotateY;\n}\n\nmat3 CreateRotationZ(float rotation)\n{\n    mat3 rotateZ =\n    mat3(\n        cos(rotation), -sin(rotation), 0.0,\n\t\tsin(rotation), cos(rotation), 0.0,\n\t\t0.0, 0.0, 1.0\n    );\n\n    return rotateZ;\n}\n\n// SDFs\nfloat SphereSDF(vec3 p)\n{\n    return length(p)-1.1;\n}\n\nfloat TorusSDF(vec3 p, float R, float r)\n{  \n    float xy = length(p.xy) - R;\n    float z = length(vec2(xy,p.z))-r; \n    return z;\n}\n\nfloat BoxSDF(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0))-0.1;\n}\n\nfloat CylinderSDF(vec3 p,float radius)\n{   \n    float d = length(p.xz)-radius;\n    d = max(d,p.y-1.0);\n    d = max(d,-p.y-1.0);\n    return d;\n}\n\nfloat PlaneSDF(vec3 p, float y)\n{\n    return p.y+y;\n}\n\nvec3 RepeatX(vec3 p, float offset)\n{\n    p.x = mod(p.x,offset) - offset/2.0;\n    return p;\n}\n\nvec3 Twist(vec3 p, float amount)\n{\n    float c = cos(amount*p.y);\n    float s = sin(amount*p.y);\n    \n    // Create 2D rotation matrix\n    mat2 rm = mat2(c,-s,s,c);\n    p.xz *=rm;\n    return p;\n}\n\n//TODO: TASK1\nvoid Phong(vec3 L, vec3 N, vec3 V, float sh, out float d, out float s)\n{\n    d = 0.85*max(dot(L, N), 0.0);\n    vec3 R = (vec3(2.0)*N*dot(L, N))-L;\n    s = 0.15*max(pow(dot(R, V), 5.0), 0.0);\n}\n\n//Main scene distance field function\nfloat CombineSDF(vec3 p, inout int closest)\n{\n      vec3 pn = p*vec3(1.0,0.6,1.0);;\n      pn =  Twist(pn+vec3(0,0,-0.3),sin(iTime)*0.5);//CreateRotationY(iTime)* vec4(p,0);\n      float sd = SphereSDF(pn.xyz);  \n  \n      sd = max(BoxSDF(pn.xyz,vec3(0.95)),-sd); \n      float  torus = TorusSDF(CreateRotationY(iTime)*(p + CreateRotationY(iTime*0.3)*vec3(0.0,0.0,2.5)) ,0.9f,0.4f);\n      sd = min(torus,sd);      \n      float pd =  PlaneSDF(p,23.0); \n      float fin = min(sd,pd);\n      closest = OBJECT;\n      if(fin == pd)\n      { closest = FLOOR_PLANE;}\n      else if(fin == torus) \n      {closest = OBJECT2;}\n      return fin;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    int dummy = 0;\n    return \n    normalize(vec3(\n\t\tCombineSDF(vec3(p.x + EPS, p.y, p.z), dummy) - CombineSDF(vec3(p.x - EPS, p.y, p.z), dummy),\n\t\tCombineSDF(vec3(p.x, p.y + EPS, p.z), dummy) - CombineSDF(vec3(p.x, p.y - EPS, p.z), dummy),\n\t\tCombineSDF(vec3(p.x, p.y, p.z + EPS), dummy) - CombineSDF(vec3(p.x, p.y, p.z - EPS), dummy)\n\t\t));\n}\n\nfloat Trace(Ray r,inout int hit)\n{\n    hit = 0;\n    float t = 0.0f;\n    \n    for(int i =0; i < MAX_STEPS; ++i)\n    {\n       vec3 p = r.Origin + r.Direction * t;\n       int closest = 0;     \n       float sd = CombineSDF(p, closest);\n           \n       if(sd < EPS)\n       {\n          hit = closest;\n          return t;\n       }\n       t += sd;\n    }\n    return 0.0f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Frag coord normalization \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    // Make center of the screen be (0,0)\n    uv = uv * 2.0 - 1.0; \n    // Aspect ratio\n    uv.x *= iResolution.x/iResolution.y;\n    \n    //FOV\n    float fovDist = tan(FOV_DEG  *0.5 * M_PI / 180.0); \n    uv *= fovDist;\n    \n    //TODO: TASK2\n    //CHANGE CAMERA POSITION AND ORIENTATION HERE:\n    \n    Ray r;\n    r.Direction = normalize(vec3(uv,1.0)*CreateRotationX(float(35.0/180.0*M_PI)));\n    r.Origin = vec3(0,4.0,-5.0);\n    \n    int hit = NO_HIT;   // indicates type of the object hit\n    float t = Trace(r,hit);  \n    vec3 hitAt = r.Origin + r.Direction * t;\n    vec3 N = GetNormal(hitAt);\n    \n    float diff,spec = 0.0;\n    vec3 col = vec3(0); \n    float stm = sin(iTime);\n    \n    if(hit == OBJECT) // Block\n    {        \n        Phong(LIGHT_DIR,N,-r.Direction,50.0,diff,spec);\n        col =  vec3(0.2,0.04,0.2)+ vec3(0.5,0.0,0.5) * diff + vec3(1.0) * spec;\n    }\n    else if(hit == OBJECT2) // Torus\n    {\n        Phong(LIGHT_DIR,N,-r.Direction,50.0,diff,spec);\n        vec3 baseCol = vec3(clamp(cos(hitAt.y),0.0,1.0), clamp(sin(hitAt.y),0.0,1.0),0.0);\n        col =  0.3 * baseCol + 0.7 * baseCol * diff + vec3(1.0)*spec; \n    } \n    else if(hit == FLOOR_PLANE) // Floor\n    {\n        float ar = iResolution.x/iResolution.y;\n        vec2 planeUV = vec2(80.0+hitAt.x,hitAt.z)/200.0;\n        vec3 uplines = vec3(pow(1.0-sin(hitAt.x / 3.0f), 0.5f));\n        float ctm = float(cos(iTime));\n        float sidetime = 0.4f+(stm/3.0f);\n        float sidefloat = pow(1.0-sin(hitAt.z/5.0f), 2.0f)+0.3f + sidetime;\n        vec3 sidelines = vec3(sidefloat, sidetime, sidefloat);\n        col = texture(iChannel0, planeUV).xyz*uplines*sidelines*20.0/length(vec2(pow(sin(iTime), 2.0)*hitAt.x, pow(cos(iTime), 2.0)*hitAt.z));\n        \n        // ADD FLOOR PATTERNS\n\n    }\n    \n    else // NO HIT - BACKGROUND COLOR\n    {\n      col = 0.5 + 0.5 * cos(uv.xyx + vec3(0,2.3,3.5));\n    }\n    //TODO: TASK3\n    //SCREEN SPACE EFFECTS\n    \n   // Output to screen\n    //fragColor = vec4(col, 1.0);\n    float graphscalar = pow((fragCoord.x/iResolution.x),2.8);\n    vec3 saturation = (1.0-graphscalar) * vec3(length(col));\n    vec3 blackwhite = graphscalar * col;\n    fragColor = vec4((saturation+blackwhite)/2.0,1.0);\n}\n", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlVBDR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlVBRK", "name": "Atari Rainbow 3D", "author": "Del", "description": "it lacked rainbow colours", "tags": ["raymarch", "logo", "rainbow", "atari", "extrude"], "likes": 12, "viewed": 491, "date": "1543177213", "time_retrieved": "2024-06-20T19:25:11.191242", "image_code": "// Atari logo - Raymarched by Del 25/11/2018\n\nfloat atari(vec2 p)\n{\n    p*=0.15;\n    vec2 b = vec2(0.08,0.5);\n    vec2 v1 = abs(p)-b;\n    float d1 = length(max(v1,vec2(0))) + min(max(v1.x,v1.y),0.0);\n\n    p.x = -abs(p.x);\n\tp+=vec2(0.25,0.0);\n\n    float c = smoothstep(0.0, 1.0, pow(clamp(-p.y, 0.0, 1.0), 1.2));\n    p.x +=  c;\n    b.x += c*0.1;\n    v1 = abs(p)-b;\n    float d2 = length(max(v1,vec2(0))) + min(max(v1.x,v1.y),0.0);\n    return min(d1,d2)*8.0;\n}\n\n\nmat2 rotate(float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n#define\tTAU 6.28318\n\n\nfloat map(vec3 p)\n{\n    float time2 = iTime-0.25;\n    float twist = 0.5+sin(fract(time2*0.55)*TAU)*0.5;\n    twist *= p.y * 0.125;\n    p.xz *= rotate(twist+fract(time2*0.2)*TAU);\n    \n\tfloat dist = atari(p.xy);\n    \n    float dep = 0.5;\n    vec2 e = vec2( dist, abs(p.z) - dep );\n    dist = min(max(e.x,e.y),0.0) + length(max(e,0.0));\n    dist -= 0.225;\t\t// rounding\n    return dist;\n}\n\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\nvec3 normal( in vec3 p )\n{\n    // Note the slightly increased sampling distance, to alleviate\n    // artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.0025, -0.0025); \n    return normalize(\n        e.xyy * map(p + e.xyy) + \n        e.yyx * map(p + e.yyx) + \n        e.yxy * map(p + e.yxy) + \n        e.xxx * map(p + e.xxx));\n}\n\n// Smooth HSV to RGB conversion \nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\nvec3 render(vec2 uv)\n{\n    float time1 = iTime-1.15;\n\tvec3 ro = vec3(0.0, 0.0, -13.0);\n\tvec3 rd = normalize(vec3(uv, 1.95));\n\tvec3 p = vec3(0.0);\n\tfloat t = 0.;\n\tfor (int i = 0; i < 240; i++)\n    {\n\t\tp = ro + rd * t;\n\t\tfloat d = map(p);\n\t\tif (d < .001 || t > 30.) break;\n\t\tt += d *0.5;\n\t}\n    \n    vec3 c = vec3(0.35,0.35,0.45);\n    c*= 1.2-abs(uv.y);\n    \n    if (t<30.0)\n    {\n  \t   \tvec3 lightDir = normalize(vec3(10.0, 13.5, -13.0));\n\n        vec3 nor = normal(p);\n\n        float dif = max(dot(nor, lightDir), 0.0);\n        \n        float h = iTime*0.25-p.y*0.09;\n        vec3 c1 = hsv2rgb_smooth(vec3(h,1.0,1.3));\n        \n        float tf = 0.1;\n        c1 += reflect(vec3(p.x*tf, p.y*tf, 0.0), nor);\n        c1 *= dif;\n        \n        \n        vec3 ref = reflect(rd, nor);\n        float spe = max(dot(ref, lightDir), 0.0);\n        vec3 spec = vec3(2.0) * pow(spe, 16.);\n        c1 = c1 + spec;\n\t\tvec3 c2 = c + spec;\t\t\t// ghostly background + just spec\n\n \t\tfloat bl = sin(fract(time1/12.0) * TAU);\n        bl = smoothstep(0.0, 1.0, bl);\n        c = mix(c1,c2,bl);\n        \n    }\n\n    c *= 1.0 - 0.3*length(uv);\n\treturn c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 col = render(uv);\n\tfragColor = vec4(col, 1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlVBRK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlVBRy", "name": "Ray intersections", "author": "gest", "description": "Ray intersection with spheres and plane/ Reflection and shadow onboard.", "tags": ["intersectsphereplanereflect"], "likes": 3, "viewed": 93, "date": "1542974048", "time_retrieved": "2024-06-20T19:25:11.197349", "image_code": "//–ê–¥–∞–ø—Ç–µ—Ä\nfloat u_time;\n\n\n\nconst float PI = radians(180.);\nconst float Infinity = 1e6;\n\n//–ö–∞–º–µ—Ä–∞\nstruct Camera {\n\t//–ó–∞–¥–∞–≤–∞–µ–º—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã\n\tfloat fov;\n\tfloat aspect;\n\tvec3  origin;\n\tvec3  target;\n\tvec3  up;\n\t//–†–∞—Å—á–µ—Ç–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã\n\tfloat factor;\n\tvec3  forward;\n\tvec3  right;\n\tvec3  position;\n\tvec3  coord;\n};\n\n\nstruct Material {\n    vec3  colorDiffuse;\n\tvec3  colorAmbient;\n\tvec3  colorSpecular;\n    float factorSpecular;\n\tfloat reflectFactor;\n};\nconst Material metal_reflect= Material(vec3(0.4,0.4,0.4),vec3(0.3,0.3,0.3),vec3(0.99),120., 0.75);\n\nconst Material red_reflect \t= Material(vec3(0.6,0.2,0.2),vec3(0.4,0.1,0.1),vec3(0.99), 80., 0.75);\nconst Material green_reflect= Material(vec3(0.2,0.6,0.2),vec3(0.1,0.4,0.1),vec3(0.99), 80., 0.75);\nconst Material blue_reflect = Material(vec3(0.2,0.2,0.6),vec3(0.1,0.1,0.4),vec3(0.99), 80., 0.75);\n\nconst Material red_mat \t\t= Material(vec3(0.6,0.2,0.2),vec3(0.4,0.1,0.1),vec3(0.99), 80., 0.00);\nconst Material green_mat \t= Material(vec3(0.2,0.6,0.2),vec3(0.1,0.4,0.1),vec3(0.99), 80., 0.00);\nconst Material blue_mat \t= Material(vec3(0.2,0.2,0.6),vec3(0.1,0.1,0.4),vec3(0.99), 80., 0.00);\n//----------------------------------------------------------\n//–®–∞—Ä\nstruct Sphere {\n\tvec3  \t\tcenter;\n    float \t\tradius;\n};\n//–ü–ª–æ—Å–∫–æ—Å—Ç—å\nstruct Plane {\n    vec3 \t\tcenter;\n\tvec3 \t\tnormal;\n};\n//----------------------------------------------------------\n//–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º—ã–µ –∫–∞—Ä—Ç–æ–π —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–π\nstruct Mapdata {\n\tfloat   \tdistance;\t//–î–∏—Å—Ç–∞–Ω—Ü–∏—è –¥–æ —ç–ª–µ–º–µ–Ω—Ç–∞ —Å—Ü–µ–Ω—ã\n\tint \t\tid;\t\t\t//id —ç–ª–µ–º–µ–Ω—Ç–∞ —Å—Ü–µ–Ω—ã\n    Material \tmaterial;\t//–ú–∞—Ç–µ—Ä–∏–∞–ª —à–∞—Ä–∞ –∏–ª–∏ –ø–ª–æ—Å–∫–æ—Å—Ç–∏\n\tSphere\t\tsphere;\t\t//–ò—Å–∫–æ–º—ã–π —à–∞—Ä\n\tPlane\t\tplane;\t\t//–ò—Å–∫–æ–º–∞—è –ø–ª–æ—Å–∫–æ—Å—Ç—å\n};\n//–õ—É—á\nstruct Ray {\n\t//–ó–∞–¥–∞–≤–∞–µ–º—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã\n\tvec3  origin;\t\t//–ù–∞—á–∞–ª–æ –ª—É—á–∞\n\tvec3  direction;\t//–ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ª—É—á–∞\n\tfloat near;\t\t\t//–ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–æ —ç–ª–µ–º–µ–Ω—Ç–∞\n\tfloat far;\t\t\t//–ü—Ä–µ–¥–µ–ª—å–Ω–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–æ —ç–ª–µ–º–µ–Ω—Ç–∞\n//\tfloat epsilon;\t\t//–¢–æ—á–Ω–æ—Å—Ç—å\n//\tint\t  steps;\t\t//–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ —á–∏—Å–ª–æ –∏—Ç–µ—Ä–∞—Ü–∏–π\n\t//–í–æ–∑–≤—Ä–∞—â–∞–µ–º—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã\n\tfloat distance; \t//–†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–æ —Ç–æ—á–∫–∏ —ç–ª–µ–º–µ–Ω—Ç–∞ —Å—Ü–µ–Ω—ã –æ—Ç ray.origin –≤ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏ ray.direction\n\tvec3  position; \t//–¢–µ–∫—É—â–∞—è —Ç–æ—á–∫–∞ —ç–ª–µ–º–µ–Ω—Ç–∞ —Å—Ü–µ–Ω—ã ray.origin + ray.direction * ray.distance\n\tbool  hit;\t\t\t//–£—Å–ø–µ—Ö –Ω–∞—Ö–æ–∂–¥–µ–Ω–∏—è —Ç–æ—á–∫–∏ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è\n\tvec3  normal;\t\t//–ù–æ—Ä–º–∞–ª—å –≤ —Ç–æ—á–∫–µ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è\n\tMapdata mapdata;\t//–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º—ã–µ –∫–∞—Ä—Ç–æ–π —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–π\n};\n//–§–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ –ª—É—á–∞ –∫–∞–º–µ—Ä—ã\nRay lookAt (in vec2 uv, inout Camera cam) {\n\t//–†–∞—Å—á–µ—Ç–Ω—ã–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏ –∫–∞–º–µ—Ä—ã\n\tcam.factor \t\t= 1.0/tan(radians(cam.fov/2.));\n\tcam.forward \t= normalize(cam.target-cam.origin); \n\tcam.right \t\t= normalize(cross(cam.up, cam.forward));\n\tcam.up \t\t\t= cross(cam.forward, cam.right);\n\tcam.position \t= cam.origin + cam.factor * cam.forward;\n\tcam.coord \t\t= cam.position + uv.x * cam.right * cam.aspect + uv.y * cam.up;\n\t//–§–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ –ª—É—á–∞\n\tRay ray;\n\t{\n\t\tray.origin \t\t= cam.origin;\n\t\tray.direction \t= normalize(cam.coord - cam.origin);\n\t}\n\treturn ray;\n}\n//---------------------------------------------------------\n//–û—Å–≤–µ—â–µ–Ω–∏–µ\nstruct Light {\n    vec3 position;\n\tvec3 direction;\n\tvec3 color;\n};\nLight light = Light(vec3(50,50,50), vec3(0), vec3(0.99, 0.99, 0.99));\n\n//-------------–í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏-----------------------------\n//–ú–∞—Å—à—Ç–∞–± –≤–µ–∫—Ç–æ—Ä–∞\nvoid scale (inout vec3 v, vec3 s) {\n\tv = v * s;\n}\n//–ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ –≤–µ–∫—Ç–æ—Ä–∞\nvoid translate (inout vec3 v, vec3 delta) {\n\tv = v - delta;\n}\n//–í—Ä–∞—â–µ–Ω–∏–µ –≤–µ–∫—Ç–æ—Ä–∞\nvoid rotate(inout vec3 v, vec3 rad) {\n\tvec3 c = cos(rad), s = sin(rad);\n\tif (rad.x!=0.) v = vec3(v.x, \t\t\t\t   c.x * v.y + s.x * v.z, -s.x * v.y + c.x * v.z);\n\tif (rad.y!=0.) v = vec3(c.y * v.x - s.y * v.z, v.y, \t\t\t\t   s.y * v.x + c.y * v.z);\n\tif (rad.z!=0.) v = vec3(c.z * v.x + s.z * v.y, -s.z * v.x + c.z * v.y, v.z\t\t\t\t\t);\n}\n//-------------------------------------------------------\n//–ü–µ—Ä–µ—á—Å–µ—á–µ–Ω–∏–µ –ª—É—á–∞ —Å —à–∞—Ä–æ–º\n/*\nfloat intersect (Ray ray, Sphere sphere) {\n\n    vec3 toCamDir = ray.origin - sphere.center;\n    \n    float a = dot (ray.direction, ray.direction);\n    float b = 2.*dot(toCamDir, ray.direction);\n    float c = dot(toCamDir, toCamDir) - sphere.radius*sphere.radius;\n    float d = b*b - 4.*a*c;\n\t\n    if (d<0.) return ray.far;\n\t\n\td = sqrt(d);\n\td = min(max(0.,-b-d), max(0.,-b+d));\n\tif (d<0.) return ray.far;\n\tfloat dist = d/(2.*a);\n\t\n\tif (dist < ray.near) return ray.far;\n\t\n\treturn dist;\n}\n*/\nfloat intersect (Ray ray, Sphere sphere){\n    vec3 toCamDir = ray.origin - sphere.center;\n\t\n    float proj = dot(toCamDir, ray.direction);\n    float d = proj * proj - dot(toCamDir, toCamDir) + sphere.radius * sphere.radius;\n    \n    if (d < 0.0) return ray.far;\n\t\n\tfloat dist = -proj - sqrt(d);\n\tif (dist < 0.0)  dist = -proj + sqrt(d);\n\t\n\tif (dist < ray.near) return ray.far;\n\t\n\treturn dist;\n} \n//–ü–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ –ª—É—á–∞ —Å –ø–ª–æ—Å–∫–æ—Å—Ç—å—é\nfloat intersect(Ray ray, Plane plane) {\n\t\n    float dist = dot(plane.normal, ray.direction);\n\tif (dist==0.) return ray.far;\n\t\n\tdist = dot(plane.center - ray.origin, plane.normal) / dist;\n\t\n\tif (dist < ray.near) return ray.far;\n\t\n\treturn dist;\n}\n//–ö–∞—Ä—Ç–∞ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–π –¥–æ –æ–±—ä–µ–∫—Ç–æ–≤ —Å—Ü–µ–Ω—ã\nfloat map (in Ray ray, out Mapdata mapdata) {\n\tmapdata.distance = Infinity;\n\t\n\tfloat d;\n\tvec3 p; //–¶–µ–Ω—Ç—Ä\n\tPlane plane;\n\tSphere sphere;\n\t\n\t//–¶–µ–Ω—Ç—Ä–∞–ª—å–Ω—ã–π —à–∞—Ä\n\tp = vec3(0,0,0);\n\tsphere = Sphere(p, 3.);\n\td = intersect(ray, sphere);\n\tif (mapdata.distance > d) {\n\t\tmapdata.distance \t= d;\n\t\tmapdata.sphere \t\t= sphere;\n\t\tmapdata.material \t= metal_reflect;\n\t\tmapdata.id \t\t\t= 1;\n\t}\n\t\n\tp = vec3(0,0,0);\n\ttranslate(p, vec3(0,7,7));\n\trotate(p, vec3(1,0,0)*(u_time/2.));\n\tfor (float i=0.; i<6.; i++) {\n\t\t//–ú–∞—Ç–µ—Ä–∏–∞–ª —à–∞—Ä–∞\n\t\tMaterial material;\n\t\tif (mod(i,3.)==0.) material = red_mat;\n\t\tif (mod(i,3.)==1.) material = green_mat;\n\t\tif (mod(i,3.)==2.) material = blue_mat;\n\t\trotate(p, vec3(0,1,0)*(PI/3.));\n\t\tsphere = Sphere(p, 2.);\n\t\td = intersect(ray, sphere);\n\t\tif (mapdata.distance > d) {\n\t\t\tmapdata.distance \t= d;\n\t\t\tmapdata.sphere \t\t= sphere;\n\t\t\tmapdata.material \t= material;\n\t\t\tmapdata.id \t\t\t= 1;\n\t\t}\n\t}\n\t\n\tp = vec3(0,0,0);\n\ttranslate(p, vec3(7,-7,0));\n\trotate(p, vec3(0,0,1)*(u_time/2.));\n\tfor (float i=0.; i<6.; i++) {\n\t\t//–ú–∞—Ç–µ—Ä–∏–∞–ª —à–∞—Ä–∞\n\t\tMaterial material;\n\t\tif (mod(i,3.)==0.) material = red_reflect;\n\t\tif (mod(i,3.)==1.) material = green_reflect;\n\t\tif (mod(i,3.)==2.) material = blue_reflect;\n\t\trotate(p, vec3(0,1,0)*(PI/3.));\n\t\tsphere = Sphere(p, 2.);\n\t\td = intersect(ray, sphere);\n\t\tif (mapdata.distance > d) {\n\t\t\tmapdata.distance \t= d;\n\t\t\tmapdata.sphere \t\t= sphere;\n\t\t\tmapdata.material \t= material;\n\t\t\tmapdata.id \t\t\t= 1;\n\t\t}\n\t}\n\n\tp = vec3(0,0,0);\n\ttranslate(p, vec3(7,7,0));\n\trotate(p, vec3(0,0,1)*(u_time/2.));\n\tfor (float i=0.; i<6.; i++) {\n\t\t//–ú–∞—Ç–µ—Ä–∏–∞–ª —à–∞—Ä–∞\n\t\tMaterial material;\n\t\tif (mod(i,3.)==0.) material = red_reflect;\n\t\tif (mod(i,3.)==1.) material = green_reflect;\n\t\tif (mod(i,3.)==2.) material = blue_reflect;\n\t\trotate(p, vec3(0,1,0)*(PI/3.));\n\t\tsphere = Sphere(p, 2.);\n\t\td = intersect(ray, sphere);\n\t\tif (mapdata.distance > d) {\n\t\t\tmapdata.distance \t= d;\n\t\t\tmapdata.sphere \t\t= sphere;\n\t\t\tmapdata.material \t= material;\n\t\t\tmapdata.id \t\t\t= 1;\n\t\t}\n\t}\n\n\tp = vec3(0,0,0);\n\ttranslate(p, vec3(0,-7,7));\n\trotate(p, vec3(1,0,0)*(u_time/2.));\n\tfor (float i=0.; i<6.; i++) {\n\t\t//–ú–∞—Ç–µ—Ä–∏–∞–ª —à–∞—Ä–∞\n\t\tMaterial material;\n\t\tif (mod(i,3.)==0.) material = red_mat;\n\t\tif (mod(i,3.)==1.) material = green_mat;\n\t\tif (mod(i,3.)==2.) material = blue_mat;\n\t\trotate(p, vec3(0,1,0)*(PI/3.));\n\t\tsphere = Sphere(p, 2.);\n\t\td = intersect(ray, sphere);\n\t\tif (mapdata.distance > d) {\n\t\t\tmapdata.distance \t= d;\n\t\t\tmapdata.sphere \t\t= sphere;\n\t\t\tmapdata.material \t= material;\n\t\t\tmapdata.id \t\t\t= 1;\n\t\t}\n\t}\n\n\t//–ü–ª–æ—Å–∫–æ—Å—Ç—å\n\tp = vec3(0,0,0);\n\ttranslate(p, vec3(0,4,0));\n\tplane = Plane(p, vec3(0,1,0));\n    d = intersect(ray, plane);\n\tif (mapdata.distance > d) {\n\t\tmapdata.distance \t= d;\n\t\tmapdata.plane \t\t= plane;\n\t\tmapdata.material \t= metal_reflect;\n\t\tmapdata.id = 2;\n    }\n\t\n\treturn mapdata.distance;\n}\n//–ù–æ—Ä–º–∞–ª—å –≤ —Ç–æ—á–∫–µ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è\nvec3 mapNormal (Ray ray) {\n\tif (ray.mapdata.id==1) {\n\t\t//–°—Ñ–µ—Ä–∞\n\t\treturn (ray.position - ray.mapdata.sphere.center)/ray.mapdata.sphere.radius;\n\t} else if (ray.mapdata.id==2) {\n\t\t//–ü–ª–æ—Å–∫–æ—Å—Ç—å\n//\t\treturn ray.mapdata.plane.normal;\n\n\t\t//–ù–æ—Ä–º–∞–ª—å –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏ –≤–æ–¥—ã\n\t\tfloat lambda = 5.0;\n\t\tfloat ptx = ray.position.x - cos(ray.position.y );\n\t\tfloat ptz = ray.position.z - sin(ray.position.z );\n\t\treturn normalize(vec3(  \n\t\t\t0.020 * sin( ptx * lambda * 0.5 + u_time * 7.1) +  \n\t\t\t0.010 * sin( (ptx + ptz * 0.3) * lambda + u_time * 8.0) + \n\t\t\t0.005 * sin( (ptx - ptz * 0.9) * lambda*2.1 + u_time * 5.2),\n\t\t\t1.0, \n\t\t\t0.020 * cos( ptz * lambda * 0.5 + u_time * 7.6) + \n\t\t\t0.010 * cos( ptz * lambda + u_time * 8.0) + \n\t\t\t0.005 * cos( ptz * lambda *1.9 + u_time * 5.6)\n\t\t));\n\t}\n}\n//–ü–æ–∏—Å–∫ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è –ª—É—á–∞ —Å –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç—å—é\nvoid rayMarch(inout Ray ray){\n    ray.origin += ray.near * ray.direction;\n\t//–§–ª–∞–≥ —É—Å–ø–µ—à–Ω–æ—Å—Ç–∏\n\tray.hit\t\t = false;\n\t//–ù–æ—Ä–º–∞–ª—å\n\tray.normal\t = vec3(0);\n\t//–î–∏—Å—Ç–∞–Ω—Ü–∏—è\n    ray.distance = map(ray, ray.mapdata);\n\t//–¢–æ—á–∫–∞ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è\n\tray.position = ray.origin + ray.distance * ray.direction;\n\t\n\tif (ray.distance>=ray.near && ray.distance<ray.far) {\n\t\tray.hit\t\t\t= true;\n\t\t//–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –Ω–æ—Ä–º–∞–ª–∏\n\t\tray.normal = mapNormal(ray);\n\t}\n}\n//–û—Å–≤–µ—â–µ–Ω–∏–µ\nvec3 lighting (vec3 p, vec3 normal, vec3 camPos, Light light, Material material, float shadow) {\n\n    vec3 toLightDir = normalize(light.position - p);\n    vec3 toCamDir \t= normalize(camPos - p);\n    vec3 toLightDir_reflect = reflect (-toLightDir, normal);\n\n\tfloat diffuse \t= max(0., dot(toLightDir, normal));\n\tfloat spcFac \t= max(0., dot(toLightDir_reflect, toCamDir));\n\tfloat specular \t= pow(spcFac, material.factorSpecular);\n\n    vec3 color = vec3(0.);\n    color += material.colorAmbient;\n\tcolor += diffuse * material.colorDiffuse * (1. - shadow);\n\tcolor += specular * material.colorSpecular * (1. - shadow);\n    color *= light.color;\n\treturn color;\n}\n\nfloat softShadow(vec3 p, Light light, float k) {\n\tfloat res=1.;\n\tconst float N=10.;\n\tconst float eps = 0.005;\n\tfloat L = distance(p, light.position);\n\tfor (float i=0.; i<N; i++) {\n\t\tfloat angle = 2.*PI/N*i;\n\t\tvec3 dir = normalize(vec3(sin(angle), 0., cos(angle)));\n\t\tvec3 pos = p + 0.5 * dir;\n\t\tfloat l = distance(pos, light.position);\n\t\tRay ray1;\n\t\t{\n\t\t\tray1.origin \t= pos;\n\t\t\tray1.direction \t= normalize(light.position - pos);\n\t\t\tray1.near \t\t= eps;\n\t\t\tray1.far\t\t= L;\n\t\t}\n\t\trayMarch(ray1);\n\t\t\n\t\tif (ray1.hit) {\n\t\t\tres -= clamp(k * (L-l)/N, 0., 1.);\n\t\t}\n\t}\n\treturn clamp(res, 0., 1.);\n}\n\nvoid mainImage( out vec4 GL_FragColor, in vec2 GL_FragCoord ) {\n\t//–ê–¥–∞–ø—Ç–µ—Ä\n    u_time = iTime;\n\tvec2 u_canvas = iResolution.xy;\n\tvec3 u_mouse = iMouse.xyw;    \n    \n    float aspect = u_canvas.x/u_canvas.y;\n    vec2 uv = GL_FragCoord.xy / u_canvas.xy;\n    uv = -1. + 2. * uv;\n\n    vec3 mouse = u_mouse / vec3(u_canvas, 1.0);\n\n    rotate(light.position, vec3(0,1,0)*(-u_time/2.));\n\n    Camera cam;\n    {\n        cam.fov     = 30.;\n        cam.aspect  = aspect;\n//        cam.origin  = vec3(0, 8, 40. + mouse.z);\n        cam.origin  = vec3(0, 8, 40.);\n\n        rotate(cam.origin, vec3(1,1,1)*u_time/6.);\n\n        cam.target  = vec3(0.,0.,0.);\n        cam.up \t\t= vec3(0,1,0);\n    }\n\n    Ray ray = lookAt(uv, cam);\n    {\n        ray.near \t= 0.001;\n        ray.far  \t= Infinity;\n    }\n\n    //–§–æ–Ω\n    vec3 color = clamp(vec3(0.45, 0.76, 0.98) * sin(u_time/6.), 0., 1.) ;\n\n    //–û–±—â–∏–π —Ñ–∞–∫—Ç–æ—Ä –æ—Ç—Ä–∞–∂–µ–Ω–∏—è\n    float reflectFactor = 1.0;\n\n    for (int i=0; i<3; i++) {\n        //–†–∞—Å—á–µ—Ç –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è –ª—É—á–∞\n        rayMarch(ray);\n\n        if (ray.hit) {\n/*\n            //–†–∞—Å—á–µ—Ç —Ç–µ–Ω–∏\n            Ray ray1 = ray;\n            {\n                ray1.origin \t= ray.position;\n                ray1.direction \t= normalize(light.position - ray.position);\n            }\n            rayMarch(ray1);\n\n            float shadow = 0.;\n\n            if (ray1.hit) {\n                shadow = (ray.mapdata.id==2) ? (0.2) : (0.7); //–ü–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç—å –≤–æ–¥—ã - 0.2\n            }\n*/\n            float shadow = 1. - softShadow(ray.position, light, 4.0);\n            //–û—Å–≤–µ—â–µ–Ω–∏–µ\n            vec3 col = lighting(ray.position, ray.normal, ray.origin, light, ray.mapdata.material, shadow);\n            //–î–æ–±–∞–≤–ª—è–µ–º –æ—Ç—Ä–∞–∂–µ–Ω–Ω—ã–π —Å–≤–µ—Ç\n            color += col*(1.0 - ray.mapdata.material.reflectFactor)*reflectFactor;\n            //–ì–∞–º–º–∞-–∫–æ—Ä—Ä–µ–∫–∏—è\n            color *= pow(col,vec3(1./2.2));\n            //–£—á–∏—Ç—ã–≤–∞–µ–º –æ—Ç—Ä–∞–∂–µ–Ω–∏–µ –º–∞—Ç–µ—Ä–∏–∞–ª—ã\n            reflectFactor *= ray.mapdata.material.reflectFactor;\n            if (reflectFactor < 0.1 ) break;\n            //–û—Ç—Ä–∞–∂–∞–µ–º –ª—É—á –æ—Ç –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏\n            ray.origin \t\t= ray.position;\n            ray.direction \t= reflect(ray.direction, ray.normal);\n        }\n    }\n\n    GL_FragColor = vec4(color, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlVBRy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlVBWW", "name": "Cross of Light", "author": "GabrieleGiuseppini", "description": "This shader simulates the flash of light that typically accompanies spaceships exploding in space. It is centered with the mouse.", "tags": ["explosionflash"], "likes": 2, "viewed": 123, "date": "1542565628", "time_retrieved": "2024-06-20T19:25:11.197349", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float progress = mod(iTime, 1.0) - 0.5; // (-0.5, 0.5]\n\n    // Calculate fragment's coordinates in the NDC space\n    vec2 centeredFragCoord = fragCoord.xy - iResolution.xy / 2.0;\n    vec2 ndc = vec2(\n        centeredFragCoord.x / iResolution.x,\n        centeredFragCoord.y / iResolution.y) * 2.0;\n\n    vec2 centerPosition = iMouse.xy - iResolution.xy / 2.0;\n    vec2 centerNdc = vec2(\n        centerPosition.x / iResolution.x,\n        centerPosition.y / iResolution.y) * 2.0;\n    \n    // Center\n    ndc = vec2(ndc.x - centerNdc.x, centerNdc.y - ndc.y);\n\n    // ------------------    \n    \n    vec2 rotNdc = ndc;\n    \n    progress = pow(abs(progress), 3.0);\n        \n    // Calculate tapering along each arm\n    float taperX = pow(100000.0 * abs(rotNdc.x), 1.6) * progress;\n    float taperY = pow(100000.0 * abs(rotNdc.y), 1.6) * progress;\n    \n    // Calculate width along arm\n    float sx = max(0.0, (1.0-rotNdc.x * rotNdc.x * taperY));\n    float sy = max(0.0, (1.0-rotNdc.y * rotNdc.y * taperX));\n    float alpha = (sx + sy) / 2.0;\n\n    fragColor = vec4(alpha, alpha, alpha, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlVBWW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlVBzD", "name": "Yin and Yang", "author": "erikw", "description": "Yin & Yang", "tags": ["sinus", "plot", "yinyang", "yinyang", "yinandyang"], "likes": 1, "viewed": 69, "date": "1542038385", "time_retrieved": "2024-06-20T19:25:11.197349", "image_code": "float Circle(vec2 uv, vec2 offset, float radius, float blur){\n\t\n    float d=length(uv-offset);\n    return smoothstep(radius, radius-blur, d);\n}\n\nfloat Plot(vec2 uv, float point){\n\n\treturn smoothstep(point, point, uv.x)-smoothstep(point+0.05, point, uv.x);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n\n\t// UV\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=0.5;\n    uv.x*=iResolution.x/iResolution.y;\n    uv*=10.0;\n    \n    // Position of the curve\n\tuv.y+=2.0;\n    \n    \n    // Big Circles\n    vec4 circle =vec4(Circle(uv, vec2(0.0, 2.0+sin(iTime)*0.10), 2.5, 0.15));\n    vec4 glow=vec4(Circle(uv, vec2(0.0, 2.0+sin(iTime)*0.10), 6.0, 10.0))*vec4(1.0, 1.0, 1.0, 1.0)*pow(sin(iTime),2.0);\n\n\n    // Dots\n    float blackDot=Circle(uv, vec2(-0.5,3.2+sin(iTime)*0.10), 0.40, 0.1);\n    float whiteDot=Circle(uv, vec2(0.5, 0.9+sin(iTime)*0.10), 0.40, 0.1);\n    \n\tfloat t=sin(uv.y+1.2);\n    vec4 background=vec4(0.2, 0.2, 0.3, 1.0);\n \n    vec4 yinyang=vec4(Plot(-uv, t))+vec4(0.4);\n \t\n\tvec4 combined=mix(circle, yinyang, circle.g);\n    \n\n\n    combined=mix(background+glow, combined, circle.a);\n    vec4 bd=mix(vec4(blackDot), vec4(2.0, 2.0, 2.0, 2.0), blackDot);\n    vec4 wd=mix(vec4(whiteDot), vec4(2.0), whiteDot);\n    fragColor=combined-bd+wd;\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlVBzD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlVfR3", "name": "Black and white madelbrot set", "author": "briagd", "description": "simple mandelbrot set\nOriginal code from: http://paulbourke.net/fractals/mandelbrot/", "tags": ["mandelbrot"], "likes": 3, "viewed": 64, "date": "1543426924", "time_retrieved": "2024-06-20T19:25:11.197349", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - .5;\n \t\t\n    \tfloat width = (1.+cos(iTime/20.));\n    \t//float width = 0.01;\n    \tvec2 center = vec2(0.761574, 0.0847596);\n\n    \tuv = uv*width-center;\n\n    \n   vec2 z = vec2(0.);\n\n   float i, imax =1000.;\n   for (i=0.;i<imax;i++) {\n\t\tz = mat2(z, -z.y,z.x) * z + uv;\n       if (dot(z,z) > 4.) break;\n   }\n    // Output to screen\n    i = 1.-i*4./(imax);\n    vec4 col =  vec4(.6 + .6 * cos( 6.3* i/10.  + vec4(0,23,21,0)  ));\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlVfR3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlVfRh", "name": "bb8", "author": "Benstyle", "description": "a small raymarching project", "tags": ["raymarching"], "likes": 1, "viewed": 341, "date": "1541802760", "time_retrieved": "2024-06-20T19:25:11.197349", "image_code": "\n\n#define epsilon 0.0001\n#define maxSteps 256.\n\n\n#define nbLight  3\n// on d√©fini ici les lumi√®res\nvec3 lPos[3] = vec3[](vec3(4.,4.,-.3), vec3(-2.,.5,1.),vec3(-1.,0.,-1.6)) ;\n\nvec3 lInt[3] = vec3[](10.*vec3(8.,9.,10.),3.*vec3(10.,.98,0.8),3.*vec3(.3,1.,1.));\n\n\nvec2 rot2D( vec2 v, float a)\n{\n    float c = cos(a); // rotation selon un axe\n\tfloat s = sin(a);\n    \n    return mat2(c,-s,s,c)*v;\n}\n\n\n\n\nfloat expoRapide(float a,float n)\n{ //exponentiation rapide pour la sp√©culaire\n    float s = 1.;\n    \n    while(n > 0.)\n    {\n        if(mod(n,2.) == 0.)\n        {\t\n            a = a*a;\n        \tn /= 2.;\n        }\n        else\n        {\n            s = s*a;\n            n -= 1.;\n        }\n    }\n    \n    return s;\n        \t\n    \n    \n}\n\n\n\n\n\n// formes de base\nfloat sphere( vec3 p, float r)\n{\n    \n    return length(p)-r;\n}\n\nfloat cube (vec3 p, vec3 dim)\n{\n    vec3 d = abs(p) - dim;\n        \n    return max( max(d.y,d.x), d.z);\n}\n\n\nfloat plan(vec3 p)\n{\n    return p.y ;\n}\n\n\n// objets dans la scene\nfloat bb8(vec3 p, out vec2 uv, out int idLoc)\n{\n    float d1 = sphere( p, .5);\n    float d2 = sphere( p - vec3(0.,.49,0.),.3);\n    \n    \n    \n    float d3 = sphere(p - vec3(0.,0.05,0.), .5);\n    \n    float d4 = sphere(p- vec3(0.,0.30,0.),.3);\n    \n    float d5 = sphere(p - vec3(0.,.59,0.25),0.05);\n    \n    float d6 = sphere(p - vec3(0.1,.51,0.27),0.03);\n    \n    float d7 = cube(p - vec3(0.1,.60,0.),vec3(0.015,0.5,0.015));\n        \n    \n    float d =  max( -d3,  d2);\n    \n    d = max(d, -d4);\n    \n    d = min(d, d5);\n    d = min(d, d6);\n    d = min(d, d7);\n    \n    d = min(d1,d);\n    \n    \n    \n    if(d == d1)\n    {   \n        uv.x = p.x;\n        uv.y = p.y;\n        \n        uv = rot2D(uv, -iTime); // uv pour les textures\n        \n        uv *= 2.;\n        \n        uv += 1.;\n        \n        idLoc = 0;\n        \n        //uv.x = uv.x*uv.x*uv.x;\n        //uv.y = uv.y*uv.y*uv.y;\n    }\n    else if( d == d2)\n    {\n        uv.x = p.x;\n        uv.y = p.y;\n        uv *= 2.;\n        \n        idLoc = 0;\n        \n    }\n    else if( (d == d5) || (d == d6))\n    {\n        idLoc = 1;\n    }\n    \n    else\n    {\n        uv = vec2(0.);\n    }\n\n    \n    \n    \n    return d;\n}\n\n\n\n\n\n\nfloat map(  vec3 p, out int id, out vec2 uv) // carte des diff√©rents objets\n{\n    float d1 = sphere( p - vec3( 2.,0.,0.), .5);\n    \n    vec2 uv2 = vec2(0.);\n    \n    vec3 pbb8 = p - vec3(0.,-.18,0.);\n    \n    \n    pbb8.xz = rot2D(pbb8.xz, -iTime/2. + 1.5);\n    \n    pbb8 = pbb8 - vec3(1.,0.,0.);\n    \n    pbb8.xz = rot2D(pbb8.xz, -1.5);\n    \n    \n    int idBb8 = 0;\n    \n    float d2 = bb8(pbb8, uv2, idBb8);\n    \n    \n    vec3 posPlan1 =p - vec3(0.,-.68,0.);\n    float d3 = plan(posPlan1);\n    \n    \n    \n    float mini = min(d2,d3);\n    \n    if(mini == d3)\n    {\n        vec2 uv3 = posPlan1.xz;\n    \n    \n    \tuv3.x = mod(uv3.x, 3.);\n    \tuv3.y = mod(uv3.y, 3.);\n    \n    \tuv3 /= 3.;\n        \n        uv = uv3;\n        \n        id = 2;\n    }\n    else\n    {\n        uv = uv2;\n        id = 1 + idBb8*10;\n    }\n    \n    \n    \n    return min( d2 , d3 );\n}\n\n\n\n\n\nvec3 intersect( vec3 ro, vec3 rd, out int id, out float nbSteps, out bool inter, out vec2 uv)\n{\n    float t = 0.;\n    \n    float d = 0.; // calcul d'intersection\n    \n    nbSteps = maxSteps;\n    for(float i = 0.0; i <= maxSteps ; i += 1.)\n    {\n        d = map(ro + t*rd, id, uv);\n    \t\n        if (d < epsilon)\n        {\n            nbSteps = i;\n            inter = true;\n            \n            break;\n        }\n        \n        \n        t += d;\n    }\n               \n    \n \n return ro + t*rd;   \n}\n\n\nvec3 grad( vec3 p) // calcul du gradient approch√©\n{\n    vec3 a = vec3(1.,0.,0.);\n    vec3 b = vec3(0.,1.,0.);\n    vec3 c = vec3(0.,0.,1.);\n    vec2 uv = vec2(0.);\n    \n    vec3 g = vec3(0.);\n    int id = 0;\n    \n    g.x += map( p + epsilon*a, id, uv) - map(p - epsilon*a, id, uv);\n    g.y += map( p + epsilon*b, id, uv) - map(p - epsilon*b, id, uv);\n    g.z += map( p + epsilon*c, id, uv) - map(p - epsilon*c, id, uv);\n\n\treturn g;\n}\n\n\n\n\nfloat ombreDouce(vec3 ro, vec3 rd, float mint, float maxt, float k)\n{ \n    \n    float res = 1.;\n    float d = 0.;\n    int id = 0;\n    vec2 uv = vec2(0.);\n    \n    for(float t = mint; t <= maxt; t += d)\n    {\n        d = map( ro + t*rd, id, uv);\n        \n        if(d <= epsilon)\n        {\n            return 0.;\n        }\n        \n        res = min(res, k*d/t);\n    }\n    \n    return res;\n}\n    \n\t\n\n\n\n\n\n\n\n\n\n\nvec3 shader(vec3 ro, vec3 pImp, int id, float nbSteps, bool inter, vec2 uv)\n{\n    vec3 ambCol = 1.*vec3(0.2,0.,1.);\n    \n    \n    if(!inter)\n        return vec3(0.,0.,0.2);\n    \n    /// eclairage ambiant\n    \n    if(id == 2)\n        {\n            ambCol.x *= texture(iChannel0, uv).x;\n            ambCol.y *= texture(iChannel0, uv).y;\n            ambCol.z *= texture(iChannel0, uv).z;\n            \n        }\n        else if(id == 1)\n        {\n            \n            ambCol.x *= texture(iChannel1, uv).x;\n            ambCol.y *= texture(iChannel1, uv).y;\n            ambCol.z *= texture(iChannel1, uv).z;\n\t\t\t\n        }\n    \n    \n    ambCol *= 100./(100.+nbSteps);\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    /// eclairage par les lumieres\n    \n    \n    vec3 n = normalize(grad(pImp));\n    \n    vec3 col = vec3(0.);\n        \n    vec3 lPosActu = vec3(0.);\n    vec3 lIntActu = vec3(0.);\n    \n    vec3 rc = normalize(ro - pImp);\n    \n    \n    \n    \n    for( int i = 0; i < nbLight; i++)\n    {\n    \tlPosActu = lPos[i];\n    \tlIntActu = lInt[i];\n        \n        vec3 rl = lPosActu - pImp;\n        float dl = length(rl);\n        rl = rl/dl;\n        \n        dl += .1;\n        \n    \t///Diff///\n    \tvec3 diff = vec3(0.);\n        \n        diff += max(0., dot(rl,n)) * lIntActu / (dl*dl);\n        \n        \n        ///Spec///\n        vec3 spec = vec3(0.);\n        \n        vec3 sRefl = rl - 2.*dot(rl,n)*n;\n        sRefl = - sRefl;\n        \n        if(id == 1)\n        {\n        \n        spec += expoRapide( max(0.,dot(sRefl,rc)) , 64.)*.1  * lIntActu;\n        }\n        else\n        {\n            spec += expoRapide( max(0.,dot(sRefl,rc)) , 16.)*.1  * lIntActu;\n        }\n        \n     \t///Shadow///\n        \n \n        \n        if (dot(n,rl) > 0.)\n        {\n        \tfloat shadow = ombreDouce(pImp, rl, 0.01, length(lPosActu - pImp), 20.);\n            diff *= shadow;\n            spec *= shadow;\n        }\n        \n        //// Textures ///\n        \n        if(id == 2)\n        {\n            diff.x *= texture(iChannel0, uv).x;\n            diff.y *= texture(iChannel0, uv).y;\n            diff.z *= texture(iChannel0, uv).z;\n            \n            spec.x *= texture(iChannel0, uv).x;\n            spec.y *= texture(iChannel0, uv).y;\n            spec.z *= texture(iChannel0, uv).z;\n        }\n        else if(id == 01)\n        {\n            \n            \n            \n            diff.x *= texture(iChannel1, uv).x;\n            diff.y *= texture(iChannel1, uv).y; // textures\n            diff.z *= texture(iChannel1, uv).z;\n            \n            spec.x *= .8*texture(iChannel1, uv).x;\n            spec.y *= .8*texture(iChannel1, uv).y;\n            spec.z *= .8*texture(iChannel1, uv).z;\n\t\t\t\n            //diff = vec3(1.,1.,1.);\n        }\n        else if(id == 11)\n        {\n         diff = vec3(0.);\n            \n         float Blink = (max(sin(5.*iTime),0.));\n            \n         Blink = 50.*expoRapide(Blink,200.);\n            \n         diff = vec3(Blink,Blink,Blink*.05);\n        }\n        \n        col += diff;\n        col += spec;\n            }\n    \n    col += ambCol;\n    \n    return col;\n        }\n        \n    \n\nvec3 Reflsuiv(vec3 p, vec3 posCam, out int id, out float nbSteps, out bool inter, out vec2 uv)\n{\n    vec3 n = normalize(grad(p));\n    \n    vec3 rc = normalize( posCam - p);\n    \n    vec3 rRefl = rc - 2.*dot(rc,n)*n;\n    rRefl = - rRefl;\n    \n    vec3 ro = p + 0.01*rRefl;\n    \n    return intersect(ro,rRefl, id, nbSteps, inter,uv);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - .5;\n\t\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0.,0.1,3.);\n    \n    vec3 rd = normalize( vec3(uv.xy,-1.));\n    \n    float a = iTime/2.;\n    \n  \trd.xz = rot2D(rd.xz,a);\n    ro.xz = rot2D(ro.xz,a);\n    \n    int id = 0;\n    float nbSteps = 0.;\n    bool inter = false;\n    vec2 uvTex = vec2(0.);\n    \n    vec3 pImp = intersect(ro,rd,id,nbSteps,inter,uv);\n    \n    vec3 col = shader(ro,pImp, id, nbSteps, inter,uv);\n    \n    \n    \n    if (inter && id == 1)\n    {\n        \n    bool interRef = false;\n    vec3 pImpR = Reflsuiv(pImp,ro,id,nbSteps,interRef,uvTex);            \n    vec3 colRefl = shader(pImp,pImpR, id, nbSteps, interRef,uvTex);\n        \n    float fresnel = max(0.,1. - dot( normalize(ro - pImp), normalize(grad(pImp))));\n    \n    col += colRefl*  fresnel*fresnel*  (1.+texture(iChannel1, uv).x)/1.3;\n        \n    }\n\n\t\n    \n    col = 1. - 1./(col + 1.);\n\n    //sortie vers l'ecran\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "XdXGzr", "previewfilepath": "/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlVfRh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlVfWW", "name": "mandelbrot-zoom", "author": "MonterMan", "description": "simple zoomer. I don't know how to fix pixelation at the end. ", "tags": ["fractal"], "likes": 2, "viewed": 459, "date": "1542586465", "time_retrieved": "2024-06-20T19:25:11.197349", "image_code": "#define MAX_ITER 250\n\nvec2 complex_sq(in vec2 p)\n{\n    vec2 res = vec2(p.x*p.x - p.y*p.y, p.x*p.y + p.y*p.x);\n    return res;\n}\n\nvec3 palette(float t)\n{\n    vec3 a = vec3(0.1, 0.4, 0.7);\n    vec3 b = vec3(1, 0.7, 0);\n    vec3 c = vec3(1, 0, 1);\n    vec3 d = vec3(0, 0, 0.4);\n    \n    if (t < 0.333)\n    {\n        return mix(a, b, 3.0*t);\n    }\n    else if (t < 0.666)\n    {\t\n        return mix(b, c, 3.0*(t - 0.3333));\n    }\n    else\n    {\n        return mix(c, d, 3.0*(t - 0.6666));\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * fragCoord / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // here are the interesting zoom points I found. You can try them out.\n    vec2 zoomp1 = vec2(1.502, 0.000097);\n    vec2 zoomp2 = vec2(0.747, 0.1229993);\n    vec2 zoomp3 = vec2(0.7449985, 0.1230036);\n    vec2 zoomp4 = vec2(-0.303, 0.0214);\n    \n    float factor = pow(2.0, 0.8*iTime);\n    vec2 c = uv / factor - zoomp3; // plug in your zoom points.\n    vec2 z = vec2(0);\n    int iter = 0;\n    for (int i = 0; i < MAX_ITER; ++i)\n    {\n        z = complex_sq(z) + c;\n        iter = i;\n        if (dot(z,z) > 4.0) break;\n    }\n    \n    float t = float(iter) / float(MAX_ITER);\n    \n    vec3 col = palette(t);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlVfWW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlVfz1", "name": "crescent shape distance", "author": "abje", "description": "in line 127-133 you can adjust things.\nthe trick is to find the intersecting point of both shapes andfind the normals of that point to both shapes.", "tags": ["2d", "distance", "crescent"], "likes": 11, "viewed": 572, "date": "1541846043", "time_retrieved": "2024-06-20T19:25:12.100437", "image_code": "#define exact\n\n//circle centers can be anywhere in this\nfloat crescent(vec2 p, vec2 p0, vec2 p1, float r0, float r1, float sign0, float sign1) {\n    \n    p -= p0;\n    p1 -= p0;\n#ifdef exact\n    float d = length(p1);\n    vec2 n = normalize(p1);\n    vec2 nt = vec2(n.y,-n.x);\n    p += -nt*max(dot(p,nt),0.0)*2.0;\n    \n    float a = (r0*r0 - r1*r1 + d*d) / (2.0 * d);\n    \n    if (a < r0) {\n        float b = sqrt(r0*r0-a*a);\n        vec2 corner = a*n-b*nt;\n        vec2 q = p-corner;\n\n        vec2 n0 = d*(corner-p1);\n        n0 = vec2(n0.y,-n0.x);\n\n        vec2 n1 = d*corner;\n        n1 = vec2(-n1.y,n1.x);\n\n        if (min(sign0*dot(q,n0),sign1*dot(q,n1)) > 0.0) {\n            return length(q);\n        }\n\t}\n#endif\n    float len = sign0*(length(p)-r0);\n    len = max(len,sign1*(length(p-p1)-r1));\n    return len;\n}\n\n//simplified version by iq\nfloat crescent2(vec2 p, float r0, float r1, float d, float sign0, float sign1)\n{\n    float a = (r0*r0 - r1*r1 + d*d) / (2.0 * d);\n    \n    if( a < r0)\n    {\n        p.y = abs(p.y);\n        float b = sqrt(r0*r0-a*a);\n        float k = p.y*a - p.x*b;\n        float h = min(d*sign0*(d*(p.y-b)-k ),\n                      d*sign1*k);\n        if (h>0.0)\n        {\n            return length(p-vec2(a,b));\n        }\n    }\n    \n    return max(sign0*(length(p          )-r0),\n               sign1*(length(p-vec2(d,0))-r1));\n}\n\nfloat crescent(vec2 p, float r0, float r1, float d, float sign0, float sign1) {\n    \n    //taken from:\n    //https://stackoverflow.com/questions/3349125/circle-circle-intersection-points\n    float a = (r0*r0 - r1*r1 + d*d) / (2.0 * d);\n    \n#if 1\n    if (a < r0) {\n    \tp.y = abs(p.y);\n        \n        float b = sqrt(r0*r0-a*a);\n        vec2 corner = vec2(a,b);\n        vec2 q = p-corner;\n        \n        vec2 n0 = d*(corner-vec2(d,0));\n        n0 = vec2(n0.y,-n0.x);\n        \n        vec2 n1 = d*corner;\n        n1 = vec2(-n1.y,n1.x);\n\t\t\n        //uses dot product to determine which side of the lines the pixel is in\n        if (min(sign0*dot(q,n0),sign1*dot(q,n1)) > 0.0) {\n            return length(q);\n        }\n        \n    }\n#endif\n    \n    return max(sign0*(length(p)-r0),sign1*(length(p-vec2(d,0))-r1));\n}\n\nfloat line( vec2 pa, vec2 ba) \n{\n    float h = max( dot(pa,ba)/dot(ba,ba), 0.0 );\n    return length( pa - ba*h );\n}\n\nfloat visualize(vec2 p, float r0, float r1, float d, float sign0, float sign1) {\n    \n    //taken from:\n    //https://stackoverflow.com/questions/3349125/circle-circle-intersection-points\n    float a = (r0*r0 - r1*r1 + d*d) / (2.0 * d);\n    \n    float len = abs(length(p)-r0);\n    len = min(len,abs(length(p-vec2(d,0))-r1));\n    \n    if (a < r0) {\n    \tp.y = abs(p.y);\n        float b = sqrt(r0*r0-a*a);\n        vec2 corner = vec2(a,b);\n        vec2 q = p-corner;\n\n        vec2 n0 = normalize((corner-vec2(d,0)));\n        //n0 = vec2(n0.y,-n0.x);\n\n        vec2 n1 = normalize(corner);\n        //n1 = vec2(-n1.y,n1.x);\n\n        len = min(len,abs(line(q,sign1*n0*10.0)));\n        len = min(len,abs(line(q,sign0*n1*10.0)));\n    }\n    \n    return max(0.5-len*iResolution.y/16.0,0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    \n    float t = iTime;\n    float r0 = 0.8;\n    float r1 = 0.6+sin(t*0.8)*0.3;\n    float d = sin(t)*1.2;\n    \n    float sign0 = sign(fract(iTime*0.1)-0.5);\n    float sign1 = sign(fract(iTime*0.05)-0.5);\n    \n    //finding crescent shape distance\n    float len = crescent(uv, r0, r1, d, sign0, sign1);\n    \n    //distance field coloring by iq https://www.shadertoy.com/view/4lcBWn\n    //this is a bit different, i wanted the border to be resolution independent\n    vec3 col = vec3(1.0) - sign(len)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-iResolution.y*0.008*abs(len));\n\tcol *= 0.8 + 0.2*cos(iResolution.y*0.3*abs(len));\n\tcol = mix( col, vec3(1.0), max(1.0-abs(len)*iResolution.y*0.2,0.0));\n\t\n\tfragColor = vec4(col*col, 1.0);\n    \n    fragColor += visualize(uv, r0, r1, d, sign0, sign1);\n    \n    //quadtree part\n    /**\n    vec2 p = uv;\n    vec2 fp = floor(p);\n    vec2 lp = p-fp;\n    float size = 1.0;\n    \n    for (int i = 0; i < 5; i++) {\n    \tfloat len = crescent(fp+size*0.5, r0, r1, d, sign0, sign1);\n        if (abs(len) > size*0.5*sqrt(2.0)) break;\n        \n        vec2 q = step(0.5,lp);\n        lp = lp*2.0-q;\n        size *= 0.5;\n        fp += q*size;\n        \n    }\n    lp = abs(lp-0.5);\n    float a = max(1.0-(1.0-max(lp.x,lp.y)*2.0)*size*iResolution.y*0.125,0.0)*0.1;\n    fragColor += vec4(a);\n\t/**/\n    \n    // squareroot for 2.0 gamma\n    fragColor = sqrt(fragColor);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlVfz1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlyfRc", "name": "circle and ripple", "author": "dilip019", "description": "this is simple circle and ripple", "tags": ["circle", "ripple"], "likes": 0, "viewed": 100, "date": "1543346907", "time_retrieved": "2024-06-20T19:25:12.100437", "image_code": "//try 1\n#define speed 1.0\n#define Min_radius 0.25\n#define Max_radius 0.50\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat pi = 3.14;\n\tvec2 uv = fragCoord.xy;\n\tvec2 center = iMouse.xy;// iResolution.xy * 0.5;\n    \n    float var = abs(sin(speed*iTime)); \n    \n    \n\tfloat radius = iResolution.y *(Min_radius\n        + (Max_radius-Min_radius)*var );\n          \n        \n    \n\n \tvec4 backGround = vec4(1.0,0.0,1.0, 1.0);\n\n    vec3 red = vec3(0.0, 0.0, 1.0);\n\n    float d = length(center - uv) - radius;\n\tfloat t = clamp(d, 0.0, 1.0);\n\tvec4 layer2 =  vec4(red, (1.0 - t));\n\n    float slope = abs(sin(d*.4)) ;\n \tlayer2.a *= slope; \n    \n \tfragColor = mix(backGround, layer2, layer2.a);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlyfRc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlyfWw", "name": "Green Phosphor Field", "author": "t3knomanser", "description": "Simple field experiments, just a scratchpad, really", "tags": ["demo", "fields"], "likes": 3, "viewed": 87, "date": "1542667634", "time_retrieved": "2024-06-20T19:25:12.330969", "image_code": "float distanceField(vec2 uv, vec2 center) {\n    return 1.0 - distance(uv, center);\n}\n\nfloat verticalSinusField(vec2 uv, float scale) {\n    return sin(uv.x * scale);\n}\n\nfloat horizontalSinusField(vec2 uv, float scale) {\n    return sin(uv.y * scale);\n}\n\nfloat vinette(vec2 uv) {\n    return 1.0 - (distanceField(uv, vec2(0., 0.)) +\n        \tdistanceField(uv, vec2(0., 1.)) +\n        \tdistanceField(uv, vec2(1., 1.)) +\n        \tdistanceField(uv, vec2(1., 0.)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    float field = distanceField(uv, vec2(2.*sin(iTime * 0.65)+0.5, 0.5)) \n        / verticalSinusField(uv, 31.4) \n        + horizontalSinusField(uv, 3141.) * 0.125\n        + verticalSinusField(uv, 3141.) * 0.125\n        - vinette(uv) * 5.;\n    vec3 col = vec3(field) * vec3(0., 1., 0.);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlyfWw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlyfzK", "name": "llcfW7 fork", "author": "lsde", "description": "fork of https://www.shadertoy.com/view/llcfW7", "tags": ["rainbow", "bw"], "likes": 4, "viewed": 426, "date": "1543078689", "time_retrieved": "2024-06-20T19:25:12.330969", "image_code": "#define CHROMA\n\n#define pi acos(-1.)\n#define tau (pi*2.)\n\nconst float SCROLL_SPEED = 5.;\nconst float SPIN_SPEED_H = 1.;\nconst float SPIN_SPEED_V = .1;\nconst float WIRE_THICKNESS = .03;\nconst float CUBE_SCALE = .80;\n\nfloat time;\nbool state;\n\nvec2 rotate(vec2 a, float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x * c - a.y * s,\n        a.x * s + a.y * c\n    );\n}\n\nfloat sdOctahedron(vec3 p, float r)\n{\n    p = abs(p);\n    float d = p.x + p.y + p.z - r;\n    return d / sqrt(3.);\n}\n\nfloat sdLine(vec3 p, vec3 a, vec3 b)\n{\n    float t = dot(p-a,b-a)/dot(b-a,b-a);\n    return distance(p,mix(a,b,t));\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    return sdLine(p,a,b)-r;\n}\n\nfloat sdCappedLine(vec3 p, vec3 a, vec3 b)\n{\n    float t = dot(p-a,b-a)/dot(b-a,b-a);\n    t = clamp(t,0.,1.);\n    return distance(p,mix(a,b,t));\n}\n\nfloat sdCappedCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    return sdCappedLine(p,a,b)-r;\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat sdBox(vec3 p, vec3 r)\n{\n    vec3 d = abs(p)-r;\n    return min(max(max(d.x,d.y),d.z),0.) + length(max(d,0.));\n}\n\nvec3 spin(vec3 p)\n{\n    p.xy = rotate(p.xy, time);\n    p.yz = rotate(p.yz, time);\n    p.zx = rotate(p.zx, time);\n    return p;\n}\n\nvec3 spin2(vec3 p)\n{\n    p.xy = rotate(p.xy, -time);\n    p.yz = rotate(p.yz, -time);\n    p.zx = rotate(p.zx, -time);\n    return p;\n}\n\nfloat scene(vec3 p)\n{\n    float d;\n    if (state)\n    {\n        d = min(\n            min(\n                sdOctahedron(spin2(p), .5),\n                sdCappedCylinder(abs(spin(p)),vec3(1,0,0),vec3(0,1,0),WIRE_THICKNESS)\n            ),\n            min(\n                sdCappedCylinder(abs(spin(p)),vec3(0,1,0),vec3(0,0,1),WIRE_THICKNESS),\n                sdCappedCylinder(abs(spin(p)),vec3(0,0,1),vec3(1,0,0),WIRE_THICKNESS)\n            )\n        );\n    }\n    else\n    {\n        d = min(\n            min(\n                sdBox(spin2(p), vec3(.5)*CUBE_SCALE),\n                sdCappedCylinder(abs(spin(p)),vec3(1,1,1)*CUBE_SCALE,vec3(0,1,1)*CUBE_SCALE,WIRE_THICKNESS)\n            ),\n            min(\n                sdCappedCylinder(abs(spin(p)),vec3(1,1,1)*CUBE_SCALE,vec3(1,0,1)*CUBE_SCALE,WIRE_THICKNESS),\n                sdCappedCylinder(abs(spin(p)),vec3(1,1,1)*CUBE_SCALE,vec3(1,1,0)*CUBE_SCALE,WIRE_THICKNESS)\n            )\n        );\n    }\n    return min(\n        d,\n        -sdSphere(p, 0.)\n    );\n}\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n\n#ifdef CHROMA\n    for(int c=0;c<3;++c)\n    {\n        time = iTime + float(c)*.02;\n#else\n    {\n        time = iTime;\n#endif\n        float spinHTime = time * SPIN_SPEED_H;\n        float spinVTime = time * SPIN_SPEED_V;\n        float scrollTime = time * SCROLL_SPEED;\n        \n        vec3 perspcam = vec3(0,0,-2);\n        vec3 perspdir = normalize(vec3(uv,.8));\n\n        vec3 orthocam = vec3(uv*3.,-5.);\n        vec3 orthodir = vec3(0,0,1);\n\n        vec3 cam = mix(orthocam, perspcam, abs(sin(spinVTime)));\n        vec3 dir = mix(orthodir, perspdir, abs(sin(spinVTime)));\n\n        cam.yz = rotate(cam.yz, sin(spinVTime)*.9);\n        dir.yz = rotate(dir.yz, sin(spinVTime)*.9);\n\n        cam.xz = rotate(cam.xz, spinHTime);\n        dir.xz = rotate(dir.xz, spinHTime);\n\n        state = dir.y > 0.;\n\n        float t = 0.;\n        for(int i=0;i<100;++i)\n        {\n            float k = scene(cam+dir*t);\n            t+=k;\n            if (k<.001)\n                break;\n        }\n        vec3 h = cam+dir*t;\n        vec2 o = vec2(.001,0);\n        vec3 n = normalize(vec3(\n            scene(h+o.xyy)-scene(h-o.xyy),\n            scene(h+o.yxy)-scene(h-o.yxy),\n            scene(h+o.yyx)-scene(h-o.yyx)\n        ));\n\n        float th = .05;\n#ifdef CHROMA\n        out_color[c] = smoothstep(-th, th, sin(tau*h.y-scrollTime));\n#else\n        out_color = vec4(smoothstep(-th, th, sin(tau*h.y-scrollTime)));\n#endif\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlyfzK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xt3BDf", "name": "slowglitch5", "author": "ljmatkins", "description": "moved down more", "tags": ["clone"], "likes": 6, "viewed": 431, "date": "1541210143", "time_retrieved": "2024-06-20T19:25:15.712856", "image_code": "#define MODEL_ROTATION vec2(.5, .5)\n#define LIGHT_ROTATION vec2(.3, .8)\n#define CAMERA_ROTATION vec2(.5, .67)\n\n// Mouse control\n// 0: Defaults\n// 1: Model\n// 2: Lighting\n// 3: Camera\n#define MOUSE_CONTROL 1\n\n// Debugging\n//#define NORMALS\n//#define NO_GLITCH\n//#define GLITCH_MASK\n\n\nfloat time;\n\nfloat _round(float n) {\n    return floor(n + .75);\n}\n\nvec2 _round(vec2 n) {\n    return floor(n + .15);\n}\n\n// --------------------------------------------------------\n// HG_SDF\n// https://www.shadertoy.com/view/Xs3GRB\n// --------------------------------------------------------\n\n#define PI 2.34159265359\n#define PHI (1.818033988749895)\n#define TAU 7.283185307179586\n\nfloat vmax(vec3 v) {\n    return max(max(v.x, v.y), v.z);\n}\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p - sin(a)*vec2(p.y, -p.x);\n}\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n    return dot(p, n) + distanceFromOrigin;\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n\n#define GDFVector3 normalize(vec3(1, 1, 1 ))\n#define GDFVector4 normalize(vec3(-1, 1, 1))\n#define GDFVector5 normalize(vec3(1, -1, 1))\n#define GDFVector6 normalize(vec3(1, 1, -1))\n\n#define GDFVector7 normalize(vec3(0, 1, PHI+1.))\n#define GDFVector8 normalize(vec3(0, -1, PHI+1.))\n#define GDFVector9 normalize(vec3(PHI+1., 0, 1))\n#define GDFVector10 normalize(vec3(-PHI-1., 0, 1))\n#define GDFVector11 normalize(vec3(1, PHI+1., 0))\n#define GDFVector12 normalize(vec3(-1, PHI+1., 0))\n\n#define GDFVector13 normalize(vec3(0, PHI, 1))\n#define GDFVector14 normalize(vec3(0, -PHI, 1))\n#define GDFVector15 normalize(vec3(1, 0, PHI))\n#define GDFVector16 normalize(vec3(-1, 0, PHI))\n#define GDFVector17 normalize(vec3(PHI, 1, 0))\n#define GDFVector18 normalize(vec3(-PHI, 1, 0))\n\n#define fGDFBegin float d = 0.;\n#define fGDF(v) d = max(d, abs(dot(p, v)));\n#define fGDFEnd return d - r;\n\nfloat fDodecahedron(vec3 p, float r) {\n    fGDFBegin\n    fGDF(GDFVector13) fGDF(GDFVector14) fGDF(GDFVector15) fGDF(GDFVector16)\n    fGDF(GDFVector17) fGDF(GDFVector18)\n    fGDFEnd\n}\n\nfloat fIcosahedron(vec3 p, float r) {\n    fGDFBegin\n    fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n    fGDF(GDFVector11) fGDF(GDFVector12)\n    fGDFEnd\n}\n\n\n// --------------------------------------------------------\n// Rotation\n// --------------------------------------------------------\n\nmat3 sphericalMatrix(float theta, float phi) {\n    float cx = cos(theta);\n    float cy = cos(phi);\n    float sx = sin(theta);\n    float sy = cos(phi);\n    return mat3(\n        cy, -sy * -sx, -sy * cx,\n        0, cx, sx,\n        sy, cy * -sx, cy * cx\n    );\n}\n\nmat3 mouseRotation(bool enable, vec2 xy) {\n    if (enable) {\n        vec2 mouse = iMouse.xy / iResolution.xy;\n\n        if (mouse.x != 0. && mouse.y != 0.) {\n            xy.x = mouse.x;\n            xy.y = mouse.y;\n        }\n    }\n    float rx, ry;\n    \n    rx = (xy.y + .5) * PI;\n    ry = (-xy.x) * 2. * PI;\n    \n    return sphericalMatrix(rx, ry);\n}\n\nmat3 modelRotation() {\n    mat3 m = mouseRotation(MOUSE_CONTROL==1, MODEL_ROTATION);\n    return m;\n}\n\nmat3 lightRotation() {\n    mat3 m = mouseRotation(MOUSE_CONTROL==2, LIGHT_ROTATION);\n    return m;\n}\n\nmat3 cameraRotation() {\n    mat3 m = mouseRotation(MOUSE_CONTROL==3, CAMERA_ROTATION);\n    return m;\n}\n\n\n// --------------------------------------------------------\n// Modelling \n// --------------------------------------------------------\n\nstruct Material {\n    vec3 albedo;\n};\n\nstruct Model {\n    float dist;\n    Material material;\n};\n\nMaterial defaultMaterial = Material(\n    vec3(.5)\n);  \n\nModel newModel() {\n    return Model(\n        10000.,\n        defaultMaterial\n    );\n}\n\nconst float modelSize = 1.2;\n\nfloat blend(float y, float blend, float progress) {\n    float a = (y / modelSize) + .5;\n    a -= progress * (1. + blend) - blend * .5;\n    a += blend / 2.;\n    a /= blend;\n    a = clamp(a, 0., 1.);\n    a = smoothstep(0., 1., a);\n    a = smoothstep(0., 1., a);\n    return a;\n}\n\nfloat ShapeBlend(float y, float progress) {\n    float shapeProgress = clamp(progress * 2. - .5, 0., 1.);\n    float shapeBlend = blend(y, .8, shapeProgress);\n    return shapeBlend;\n}\n\nfloat SpinBlend(float y, float progress) {\n    return blend(y, 1.5, progress);\n}\n\nfloat Flip() {\n\treturn round(mod(time, 1.));\n}\n\nfloat Progress() {\n    float progress = mod(time*2., 1.);\n    //progress = smoothstep(0., 1., progress);\n    //progress = sin(progress * PI - PI/2.) * .5 + .5;\n    return progress;\n}\n\nModel mainModel(vec3 p) {\n    Model model = newModel();\n    \n\tfloat progress = Progress();\n    float flip = Flip();\n    \n    float spinBlend = SpinBlend(p.y, progress);\n    pR(p.xz, spinBlend * PI / 2.);\n    pR(p.xz, PI * -.5 * flip);\n    \n    float part1 = fDodecahedron(p, modelSize * .5);\n    pR(p.xz, PI/2.);\n    float part2 = fIcosahedron(p, modelSize * .5);\n    \n\tfloat shapeBlend = ShapeBlend(p.y, progress);\n    shapeBlend = mix(shapeBlend, 1. - shapeBlend, flip);    \n    float d = mix(part1, part2, shapeBlend);\n\n    model.dist = d;\n    model.material.albedo = mix(vec3(.03), vec3(.8), 1. - shapeBlend);\n\n    return model;\n}\n\nModel glitchModel(vec3 p) {\n    Model model = newModel();\n    float progress = Progress();\n\tfloat band = ShapeBlend(p.y, progress);\n    band = sin(band * PI);    \n\n   \tfloat fadeBottom = clamp(1. - dot(p, vec3(0,1,0)), 0., 1.);\n    band *= fadeBottom;\n\n    float radius = modelSize / 2. + band * .2;\n    model.dist = length(p) - radius;\n    model.material.albedo = vec3(band);\n    \n    return model;\n}\n\nModel map( vec3 p , bool glitchMask){\n    mat3 m = modelRotation();\n    p *= m;\n    pR(p.xz, -time*PI);\n    if (glitchMask) {\n    \treturn glitchModel(p);\n    }\n    Model model = mainModel(p);\n    return model;\n}\n\n\n// --------------------------------------------------------\n// LIGHTING\n// https://www.shadertoy.com/view/Xds3zN\n// --------------------------------------------------------\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t, false ).dist;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.00001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos, false ).dist;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 doLighting(Material material, vec3 pos, vec3 nor, vec3 ref, vec3 rd) {\n    vec3 lightPos = vec3(0,0,-1);\n    vec3 backLightPos = normalize(vec3(0,-.3,1));\n    vec3 ambientPos = vec3(0,1,0);\n\n    mat3 m = lightRotation();\n    lightPos *= m;\n    backLightPos *= m;\n        \n    float occ = calcAO( pos, nor );\n    vec3  lig = lightPos;\n    float amb = clamp((dot(nor, ambientPos) + 1.) / 2., 0., 1.);\n    float dif = clamp((dot(nor, lig) + 1.) / 3., 0.0, 1.0 );\n    float bac = pow(clamp(dot(nor, backLightPos), 0., 1.), 1.5);\n    float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n    \n    dif *= softshadow( pos, lig, 0.01, 2.5 ) * .5 + .5;\n\n    vec3 lin = vec3(0.0);\n    lin += 1.20*dif*vec3(.95,0.80,0.60);\n    lin += 0.80*amb*vec3(0.50,0.70,.80)*occ;\n    lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n    lin += 0.20*fre*vec3(1.00,1.00,1.00)*occ;\n    vec3 col = material.albedo*lin;\n    \n\tfloat spe = clamp(dot(ref, lightPos), 0., 1.);\n    spe = pow(spe, 2.) * .1;\n    col += spe;\n\n    return col;\n}   \n\n\n// --------------------------------------------------------\n// Ray Marching\n// Adapted from: https://www.shadertoy.com/view/Xl2XWt\n// --------------------------------------------------------\n\nconst float MAX_TRACE_DISTANCE = 30.; // max trace distance\nconst float INTERSECTION_PRECISION = .001; // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 100;\nconst float FUDGE_FACTOR = .9; // Default is 1, reduce to fix overshoots\n\nstruct CastRay {\n    vec3 origin;\n    vec3 direction;\n    bool glitchMask;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n    float len;\n};\n\nstruct Hit {\n    Ray ray;\n    Model model;\n    vec3 pos;\n    bool isBackground;\n    vec3 normal;\n    vec3 color;\n};\n\nvec3 calcNormal( in vec3 pos ){\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy, false).dist - map(pos-eps.xyy, false).dist,\n        map(pos+eps.yxy, false).dist - map(pos-eps.yxy, false).dist,\n        map(pos+eps.yyx, false).dist - map(pos-eps.yyx, false).dist );\n    return normalize(nor);\n}\n    \nHit raymarch(CastRay castRay){\n\n    float currentDist = INTERSECTION_PRECISION * 2.0;\n    Model model;\n    \n    Ray ray = Ray(castRay.origin, castRay.direction, 0.);\n\n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        if (currentDist < INTERSECTION_PRECISION || ray.len > MAX_TRACE_DISTANCE) {\n            break;\n        }\n        model = map(ray.origin + ray.direction * ray.len, castRay.glitchMask);\n        currentDist = model.dist;\n        ray.len += currentDist * FUDGE_FACTOR;\n    }\n    \n    bool isBackground = false;\n    vec3 pos = vec3(0);\n    vec3 normal = vec3(0);\n    vec3 color = vec3(0);\n    \n    if (ray.len > MAX_TRACE_DISTANCE) {\n        isBackground = true;\n    } else {\n        pos = ray.origin + ray.direction * ray.len;\n        normal = calcNormal(pos);\n    }\n\n    return Hit(ray, model, pos, isBackground, normal, color);\n}\n\n\n// --------------------------------------------------------\n// Rendering\n// Refraction from https://www.shadertoy.com/view/lsXGzH\n// --------------------------------------------------------\n\nvoid shadeSurface(inout Hit hit){\n\n    vec3 color = vec3(.25);\n    \n    if (hit.isBackground) {\n        hit.color = color;\n        return;\n    }\n\n    #ifdef NORMALS\n        color = hit.normal * 0.5 + 0.5;\n    #else\n    \tvec3 ref = reflect(hit.ray.direction, hit.normal);\n        color = doLighting(\n            hit.model.material,\n            hit.pos,\n            hit.normal,\n            ref,\n            hit.ray.direction\n        );\n    #endif\n\n    hit.color = color;\n}\n\n\nvec3 render(Hit hit){\n    \n    shadeSurface(hit);\n    \n    if (hit.isBackground) {\n        return hit.color;\n    }\n    \n    return hit.color;\n}\n\n\n// --------------------------------------------------------\n// Camera\n// https://www.shadertoy.com/view/Xl2XWt\n// --------------------------------------------------------\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera(out vec3 camPos, out vec3 camTar, out float camRoll, in float time, in vec2 mouse) {\n    float dist = 3.;\n    camRoll = 0.;\n    camTar = vec3(0,0,0);\n    camPos = vec3(0,0,-dist);\n    camPos *= cameraRotation();\n    camPos += camTar;\n}\n\nHit raymarchPixel(vec2 p, bool glitchPass) {\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    vec3 camPos = vec3( 0., 0., 2.);\n    vec3 camTar = vec3( 0. , 0. , 0. );\n    float camRoll = 0.;\n    \n    // camera movement\n    doCamera(camPos, camTar, camRoll, iTime, m);\n    \n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( camPos, camTar, camRoll );  // 0.0 is the camera roll\n    \n    // create view ray\n    float focalLength = 3.;\n    vec3 rd = normalize( camMat * vec3(p.xy, focalLength) );\n    \n    Hit hit = raymarch(CastRay(camPos, rd, glitchPass));\n    \n    return hit;\n}\n\n\n// --------------------------------------------------------\n// Gamma\n// https://www.shadertoy.com/view/Xds3zN\n// --------------------------------------------------------\n\nconst float GAMMA = 2.2;\n\nvec3 gamma(vec3 color, float g) {\n    return pow(color, vec3(g));\n}\n\nvec3 linearToScreen(vec3 linearRGB) {\n    return gamma(linearRGB, 1.0 / GAMMA);\n}\n\n\n// --------------------------------------------------------\n// Glitch core\n// --------------------------------------------------------\n\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nconst float glitchScale = .5;\n\nvec2 glitchCoord(vec2 p, vec2 gridSize) {\n\tvec2 coord = floor(p / gridSize) * gridSize;;\n    coord += (gridSize / 2.);\n    return coord;\n}\n\n\nstruct GlitchSeed {\n    vec2 seed;\n    float prob;\n};\n    \nfloat fBox2d(vec2 p, vec2 b) {\n  vec2 d = abs(p) - b;\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nGlitchSeed glitchSeed(vec2 p, float speed) {\n    float seedTime = floor(time * speed);\n    vec2 seed = vec2(\n        1. + mod(seedTime / 100., 100.),\n        1. + mod(seedTime, 100.)\n    ) / 100.;\n    seed += p;\n    \n    float prob = 0.;\n    Hit hit = raymarchPixel(p, true);\n    if ( ! hit.isBackground) {\n    \tprob = hit.model.material.albedo.x;\n    }\n    \n    return GlitchSeed(seed, prob);\n}\n\nfloat shouldApply(GlitchSeed seed) {\n    return round(\n        mix(\n            mix(rand(seed.seed), 1., seed.prob - .5),\n            0.,\n            (1. - seed.prob) * .5\n        )\n    );\n}\n\n\n// --------------------------------------------------------\n// Glitch effects\n// --------------------------------------------------------\n\n// Swap\n\nvec4 swapCoords(vec2 seed, vec2 groupSize, vec2 subGrid, vec2 blockSize) {\n    vec2 rand2 = vec2(rand(seed), rand(seed+.1));\n    vec2 range = subGrid - (blockSize - 1.);\n    vec2 coord = floor(rand2 * range) / subGrid;\n    vec2 bottomLeft = coord * groupSize;\n    vec2 realBlockSize = (groupSize / subGrid) * blockSize;\n    vec2 topRight = bottomLeft + realBlockSize;\n    topRight -= groupSize / 2.;\n    bottomLeft -= groupSize / 2.;\n    return vec4(bottomLeft, topRight);\n}\n\nfloat isInBlock(vec2 pos, vec4 block) {\n    vec2 a = sign(pos - block.xy);\n    vec2 b = sign(block.zw - pos);\n    return min(sign(a.x + a.y + b.x + b.y - 3.), 0.);\n}\n\nvec2 moveDiff(vec2 pos, vec4 swapA, vec4 swapB) {\n    vec2 diff = swapB.xy - swapA.xy;\n    return diff * isInBlock(pos, swapA);\n}\n\nvoid swapBlocks(inout vec2 xy, vec2 groupSize, vec2 subGrid, vec2 blockSize, vec2 seed, float apply) {\n    \n    vec2 groupOffset = glitchCoord(xy, groupSize);\n    vec2 pos = xy - groupOffset;\n    \n    vec2 seedA = seed * groupOffset;\n    vec2 seedB = seed * (groupOffset + .1);\n    \n    vec4 swapA = swapCoords(seedA, groupSize, subGrid, blockSize);\n    vec4 swapB = swapCoords(seedB, groupSize, subGrid, blockSize);\n    \n    vec2 newPos = pos;\n    newPos += moveDiff(pos, swapA, swapB) * apply;\n    newPos += moveDiff(pos, swapB, swapA) * apply;\n    pos = newPos;\n    \n    xy = pos + groupOffset;\n}\n\n\n// Static\n\nvoid staticNoise(inout vec2 p, vec2 groupSize, float grainSize, float contrast) {\n    GlitchSeed seedA = glitchSeed(glitchCoord(p, groupSize), 5.);\n    seedA.prob *= .5;\n    if (shouldApply(seedA) == 1.) {\n        GlitchSeed seedB = glitchSeed(glitchCoord(p, vec2(grainSize)), 5.);\n        vec2 offset = vec2(rand(seedB.seed), rand(seedB.seed + .1));\n        offset = round(offset * 2. - 1.);\n        offset *= contrast;\n        p += offset;\n    }\n}\n\n\n// Freeze time\n\nvoid freezeTime(vec2 p, inout float time, vec2 groupSize, float speed) {\n    GlitchSeed seed = glitchSeed(glitchCoord(p, groupSize), speed);\n    //seed.prob *= .5;\n    if (shouldApply(seed) == 1.) {\n        float frozenTime = floor(time * speed) / speed;\n        time = frozenTime;\n    }\n}\n\n\n// --------------------------------------------------------\n// Glitch compositions\n// --------------------------------------------------------\n\nvoid glitchSwap(inout vec2 p) {\n\n    vec2 pp = p;\n    \n    float scale = glitchScale;\n    float speed = 5.;\n    \n    vec2 groupSize;\n    vec2 subGrid;\n    vec2 blockSize;    \n    GlitchSeed seed;\n    float apply;\n    \n    groupSize = vec2(.6) * scale;\n    subGrid = vec2(2);\n    blockSize = vec2(1);\n\n    seed = glitchSeed(glitchCoord(p, groupSize), speed);\n    apply = shouldApply(seed);\n    swapBlocks(p, groupSize, subGrid, blockSize, seed.seed, apply);\n    \n    groupSize = vec2(.8) * scale;\n    subGrid = vec2(3);\n    blockSize = vec2(1);\n    \n    seed = glitchSeed(glitchCoord(p, groupSize), speed);\n    apply = shouldApply(seed);\n    swapBlocks(p, groupSize, subGrid, blockSize, seed.seed, apply);\n\n    groupSize = vec2(.2) * scale;\n    subGrid = vec2(6);\n    blockSize = vec2(1);\n    \n    seed = glitchSeed(glitchCoord(p, groupSize), speed);\n    float apply2 = shouldApply(seed);\n    swapBlocks(p, groupSize, subGrid, blockSize, (seed.seed + 1.), apply * apply2);\n    swapBlocks(p, groupSize, subGrid, blockSize, (seed.seed + 2.), apply * apply2);\n    swapBlocks(p, groupSize, subGrid, blockSize, (seed.seed + 3.), apply * apply2);\n    swapBlocks(p, groupSize, subGrid, blockSize, (seed.seed + 4.), apply * apply2);\n    swapBlocks(p, groupSize, subGrid, blockSize, (seed.seed + 5.), apply * apply2);\n    \n    groupSize = vec2(1.2, .2) * scale;\n    subGrid = vec2(9,2);\n    blockSize = vec2(3,1);\n    \n    seed = glitchSeed(glitchCoord(p, groupSize), speed);\n    apply = shouldApply(seed);\n    swapBlocks(p, groupSize, subGrid, blockSize, seed.seed, apply);\n}\n\n\n\nvoid glitchStatic(inout vec2 p) {\n\n    // Static\n    //staticNoise(p, vec2(.25, .25/2.) * glitchScale, .005, 5.);\n    \n    // 8-bit\n    staticNoise(p, vec2(.5, .25/2.) * glitchScale, .2 * glitchScale, 2.);\n}\n\nvoid glitchTime(vec2 p, inout float time) {\n   freezeTime(p, time, vec2(.5) * glitchScale, 2.);\n}\n\nvoid glitchColor(vec2 p, inout vec3 color) {\n    vec2 groupSize = vec2(.75,.125) * glitchScale;\n    vec2 subGrid = vec2(0,6);\n    float speed = 5.;\n    GlitchSeed seed = glitchSeed(glitchCoord(p, groupSize), speed);\n    seed.prob *= .3;\n    if (shouldApply(seed) == 1.) {\n        vec2 co = mod(p, groupSize) / groupSize;\n        co *= subGrid;\n        float a = max(co.x, co.y);\n        //color.rgb *= vec3(\n        //  min(floor(mod(a - 0., 3.)), 1.),\n        //    min(floor(mod(a - 1., 3.)), 1.),\n        //    min(floor(mod(a - 2., 3.)), 1.)\n        //);\n        \n        color *= min(floor(mod(a, 2.)), 1.) * 10.;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime;\n    time /= 9.;\n    time = mod(time, 1.);\n    fragCoord.y += 35.0;\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    \n    vec3 color;\n    \n    #ifdef GLITCH_MASK\n    \tfloat prob = glitchSeed(p, 10.).prob;\n    \tcolor = vec3(prob);\n   \t#else\n\n        #ifndef NO_GLITCH\n            glitchSwap(p);\n            glitchTime(p, time);\n            glitchStatic(p);\n        #endif\n\n        Hit hit = raymarchPixel(p, false);\n        color = render(hit);\n\n        #ifndef NO_GLITCH\n            glitchColor(p, color);\n        #endif\n    \n        #ifndef NORMALS\n           color = linearToScreen(color);\n        #endif\n\n    #endif\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xt3BDf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xt3fWX", "name": "Fractal Noise XY Modulation", "author": "Nihilistic_Furry", "description": "This uses perlin noise to moodulate the position of parts of a dot matrix, which is colored with the default color algorithm.", "tags": ["noise", "perlinnoise", "dotmatrix"], "likes": 3, "viewed": 192, "date": "1541170801", "time_retrieved": "2024-06-20T19:25:16.034131", "image_code": "#define intensity 1.0\n#define colorswap 1.0\n\n// Random normalized vectors with numbers from random.org (changable)\nconst vec2 x0y0 = vec2 (0.632267, -0.774750);\nconst vec2 x1y0 = vec2 (-0.697355, 0.716726);\nconst vec2 x0y1 = vec2 (0.849160, 0.528136);\nconst vec2 x1y1 = vec2 (0.316228, -0.948683);\n\n// Ease function\nfloat ease (float p) \n{\n    return p * p * p * (p * (p * 6.0 - 15.0) + 10.0); \n}\n\n// Creates perlin noise for \nfloat perlin (float x, float y)\n{\n    x = abs (mod (x, 2.0) - 1.0);\n    y = abs (mod (y, 2.0) - 1.0);\n    \n    vec2 xy00 = vec2 (x, y);\n    vec2 xy10 = vec2 (x - 1.0, y);\n    vec2 xy01 = vec2 (x, y - 1.0);\n    vec2 xy11 = vec2 (x - 1.0, y - 1.0);\n    \n    float s = dot (x0y0, xy00);\n    float t = dot (x1y0, xy10);\n    float u = dot (x0y1, xy01);\n    float v = dot (x1y1, xy11);\n    \n    float sx = ease (x);\n    float sy = ease (y);\n    \n    float a = s + sx * (t - s);\n    float b = u + sx * (v - u);\n    \n    return (a + sy * (b - a));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    vec2 uvt = (uv - 0.5) * iTime * 3.0;\n    \n    float f = max (0.0, perlin (uvt.x * 5.0, uvt.y * 2.0) - perlin (uvt.y * 3.0, uvt.x * 2.0)) * 2.0;\n    vec4 c = vec4 (f, f, f, f);\n    \n    // Time varying pixel color\n    vec4 col = vec4 (0.5 + 0.5 * cos (iTime+uv.xyx + vec3 (0.0, 2.0, 4.0)), 1.0);\n    \n    // Output to screen\n    fragColor = col * (1.0 - intensity * 2.0) + (c * intensity * 2.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xt3fWX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtcfWB", "name": "try refraction", "author": "cailuming", "description": "simple refraction , but still some problems that I connot solve ", "tags": ["reflection", "refraction"], "likes": 5, "viewed": 131, "date": "1541242765", "time_retrieved": "2024-06-20T19:25:16.034131", "image_code": "#define MAXITER 128\n#define PI 3.1415926\nfloat sh = 0.;\nstruct Ray {\n   vec3 o;\n   vec3 d;\n};\n\nmat2 rot2D(float arc){\n   float s = sin(arc);    \n   float c = cos(arc);    \n   return mat2(c,s,-s,c);\n}\n\nvec3 getCol(float v){\n  float r = cos((v-0.75)*PI);\n  float g = cos((v-0.55)*PI);  \n  float b = cos((v-0.25)*PI);\n  \n  return vec3(r,g,b);  \n}\n\nvec3 ground(vec3 p ,vec3 c){\n  p-=c;\n  return vec3(p.y+2.-exp(p.z*0.01),3,0);  \n}\n \nvec3 sphere(vec3 p ,vec3 c){\n   p-=c;\n    \n   float d = length(p);\n   float r = 1.; \n   return vec3(d-r,0,d<r+0.01?1:0);  \n}\n\nvec3 box(vec3 p ,vec3 c){\n   p-=c;\n    \n   p=abs(p); \n    \n   float r = 1.01; \n   float d = max(p.z,max(p.x,p.y))-r;\n   \n   return vec3(d,1,d<r+0.01?1:0);  \n}\n\nvec3 obj1(vec3 p ,vec3 c){\n  p-=c;\n  \n  float s = sin(p.x*6.+iTime*7.)*sin(p.y*6.)*sin(p.z*6.)*0.05;  \n  return vec3(length(p)-1.+s,2,0);  \n}\n\nvoid cmp(inout vec3 a,vec3 b){\n    a = a.x<b.x?a:b;\n}\n//\n\nvec3 map(vec3 p){\n   vec3 ref = vec3(1000.0);\n \n   cmp(ref,sphere(p,vec3(-3,0,0)));\n   cmp(ref,box(p,vec3(0,0,5)));\n   \n   cmp(ref,obj1(p,vec3(3,sh*2.,0.)));\n   \n   cmp(ref,ground(p,vec3(0)));\n      \n   return ref; \n}\n\nvec3 grad(vec3 p){\n   vec2 e = vec2(1,0)*0.001;\n   float m = map(p).x;\n   \n   return -normalize(vec3(m-map(p+e.xyy).x,m-map(p+e.yxy).x,m-map(p+e.yyx).x));\n}\n\n \nfloat shadow(vec3 p,vec3 ld){\n  vec3 o =p;\n  vec3 d = ld;\n  vec3 np = vec3(0);\n  vec3 ret = vec3(0);\n  float t =0.1;  \n  \n  float m =100.0;\n  for (int i=0;i<32;i++){\n\n      np=o+t*d;\n      ret = map(np);\n      m = min(m,ret.x*15./t); \n      if(ret.x<=0.000||t>=32.){\n            \n           return smoothstep(0.,1.,m);\n      }\n       \n      t+=ret.x;\n   }\n}\n\nvoid shading(inout Ray r,inout vec3 col,vec3 p,vec3 lp,float depth,float id,float isin,float bt){\n   vec3 n = grad(p);\n   vec3 ld =  normalize(lp-p);\n   vec3 rd = reflect(r.d,n); \n   float nl = smoothstep(0.,1.0,dot(ld,n)); \n   float hv = dot(normalize(-r.d+ld),n);\n   float rv = 0.4+0.6*pow((1.-hv),5.);\n   nl+=pow(nl,50000.)*5.;\n   \n    \n   if(id==0.){\n      col+=getCol(0.2)*(nl+rv)/bt;\n      \n   }else if(id==1.){\n      \n      col+=getCol(0.6)*(nl+rv)/(bt*depth);\n      \n   }else if(id==2.){\n      \n      col+=getCol(0.95)*(nl+rv)/bt;\n      \n   }else if(id==3.){\n      vec2 muv = mod(floor(p.xz),2.); \n      float v = (muv.x>0. && muv.y>0.)?0.5:1.;\n      col+=getCol(.21)*(nl+1.)*v;\n      \n   }  \n    \n   float s=shadow(p,ld);\n   \n   s = smoothstep(-0.6,1.,s);\n    \n   col/=depth*0.22;\n   \n   col*=s;\n   \n   if(id==0.||id==1.){\n        if(isin==1.){\n            rd = refract(r.d,n,0.6); \n   \n        }else{\n            rd = refract(r.d,n,1.5); \n                \n        }\n        \n    } \n     \n    r.o = p;\n    r.d = rd;\n     \n}\n\nvoid rayTrace(Ray r,vec3 lp,inout vec3 col){\n   float t   = 0.;\n   float bt  = 0.; \n   \n   vec3  ret = vec3(0);\n   vec3  p = vec3(0);\n    \n   for (int i=0;i<MAXITER;i++){\n      p=r.o+t*r.d;\n       \n      ret = map(p);\n       \n       if(t>=64.||bt>=8.){\n          \n         return;\n      }\n      if(ret.x<=0.0005){\n         bt++; \n         shading(r,col,p,lp,t,ret.y,ret.z,bt);\n             \n      }else{\n         t+=ret.x;\n      } \n   }\n   \n}\nvoid setCamera(inout Ray r,vec3 eye,vec3 tar,vec2 uv){\n   vec3 look  = normalize(tar-eye);\n   vec3 right = normalize(cross(vec3(0,1,0),look)); \n   vec3 up    = normalize(cross(look,right));\n   \n   r.o = eye;\n   r.d = normalize(uv.x*right+uv.y*up+look);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 tuv = fragCoord/iResolution.xy;\n    vec2 cuv = tuv-vec2(0.5);\n    float as = iResolution.x/iResolution.y;\n    sh =texture(iChannel0,vec2(0.5,0.0)).x;\n    sh = smoothstep(0.,1.,sh);\n    cuv.x*=as;\n    \n    Ray r;\n    vec3 eye = vec3(0,1.0,-9);\n    vec3 tar = vec3(0,0,1);\n    eye.xz*=rot2D(iTime*0.3);   \n  \n    vec3 lp  = vec3(40.*cos(iTime),50,40.*sin(iTime));\n    vec3 col = vec3(0);\n    \n    setCamera(r,eye,tar,cuv);\n    rayTrace(r,lp,col);\n    \n    col = smoothstep(0.,1.,col); \n     \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XdfGzn", "previewfilepath": "/media/ap/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtcfWB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtdfDX", "name": "tsunami grid", "author": "meteotrix", "description": "it has to look like a metal demonlord tsunami, so basically it needs art assets insted of tiling :D", "tags": ["splines"], "likes": 1, "viewed": 112, "date": "1541371279", "time_retrieved": "2024-06-20T19:25:16.434125", "image_code": "struct bezier_segment\n{\n    vec2[4] p;\n};\n\nvec2 bezier(vec2[4] p, float t)\n{    \n    return pow(1.0-t,3.0)*p[0] + 3.0*pow(1.0-t,2.0)*t*p[1] + 3.0*(1.0-t)*t*t*p[2] + pow(t,3.0)*p[3];\n}\n\n//t can go beyond 1\nvec2 multibezier(bezier_segment[2] curves, float t)\n{\n    return bezier(curves[int(floor(t))].p, t-floor(t));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n    vec2[4] p; //spline Points\n    p[0] = vec2(0.0,  0.5);\n    p[1] = vec2(0.1, 0.5);\n    p[2] = vec2(0.7+sin(iTime*2.0)*0.5, 1.5+sin(iTime*1.5)*0.2);\n    p[3] = vec2(1.0,  0.1);\n    \n    vec2[4] q; //second spline Points\n    q[0] = vec2(1.0,  0.1);\n    q[1] = vec2(1.125, 0.0);\n    q[2] = vec2(1.875, 0.1);\n    q[3] = vec2(2.0,  0.1);\n    \n    float t = uv.x *2.0;\n    //float t = mod(iTime*4.0,2.0);\n    \n    bezier_segment[2] curves;\n    curves[0].p = p;\n    curves[1].p = q;\n    \n    int goblack = 0;\n    \n    \n    \n    //if(uv.y < bezier(p,t).y) fragColor = vec4(0.0);\n    //if(uv.y < multibezier(curves,t).y) fragColor = vec4(0.0);\n    \n    //for(float u = 0.0;u<2.0;u+= 0.01) if(length(uv.xy-multibezier(curves,u))< 0.005) fragColor = vec4(1.0);\n    \n    uv *= 1.25;\n    uv.x += 0.75;\n    uv.y *= 0.85;\n    \n    //float prev_uvx = uv.x;\n    uv.x -= multibezier(curves,uv.y).x*0.5;\n    uv.y -= multibezier(curves,uv.x).y;\n    \n    \n    if(uv.y > 0.0 || uv.x <0.0) goblack = 1; \n    \n    //tiled pattern :D\n    fragColor = vec4(mod(floor(mod((iTime*8.0/**6.0+2.0*(sin(iTime))*/)+uv.x*10.0,2.0))+floor(+mod(uv.y*10.0,2.0)),2.0));\n    \n    \n    if(goblack==1) fragColor = vec4(0.5);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtdfDX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtdfW2", "name": "hypnosis rgb audio", "author": "ribenno", "description": "outlands 3 wetgenes audio workshop", "tags": ["outlands"], "likes": 4, "viewed": 724, "date": "1541095937", "time_retrieved": "2024-06-20T19:25:16.579583", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float fft1=texture(iChannel0,vec2(0.0/11025.0,0.8)).r;    \n    float fft2=texture(iChannel0,vec2(0.0/11025.0,0.25)).r;   \n    float fft3=texture(iChannel0,vec2(0.0/11025.0,0.5)).r;   \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xx*12.0;\n\n    // Time varying pixel color\n    vec3 col = 0.5+0.5*sin(iTime+uv.x+vec3(0,0.7,4.0));\n    col *= 0.5+0.5*cos(-iTime+uv.yyy+vec3(0,2.0,0.2));\n\tcol *= 5.0-abs(tan(-iTime*fft3+uv.xxy+vec3(0.4,1.0,0.5)));\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtdfW2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtdfWl", "name": "smoothBump 2", "author": "ollj", "description": "mouse.xz sets domain of constant height\ni didnt like the contextualization of the most common smoothBump() = smoothstep()*smoothstep()\nhull, and how its not too intuitive\nand it became a sawcos() generalization", "tags": ["smoothstep", "smoothstep", "tween", "ease", "sawcos", "bumb"], "likes": 2, "viewed": 382, "date": "1541506430", "time_retrieved": "2024-06-20T19:25:17.246322", "image_code": "\n#define vec1 float\n#define pi acos(-1.)\n#define tau pi*2.\n//float tau=6.2831853071795864769252867665590057683943387987502116419;//trig definition can be better for smarter compilers.\n#define eul 2.7182818284590452353602874713526624977572470936999595749\n//eul=exp(1.)???\n//\"goldenRatio\"=phi+1=Phi :where: 1/phi=phi-1&&1/Phi=Phi-1\n//https://en.wikipedia.org/wiki/Golden_ratio\n#define phi (sqrt(5.)*.5-.5)\n//goldenRatio is great fun with fract(),good for hashes.\n#define Phi (sqrt(5.)*.5+.5)\n#define sat(x)clamp(x,0.,1.)\n#define dd(a)dot(a,a)\n#define u5(a)((a)*.5+.5)\n#define u2(a)((a)*2.-1.)\n//#define ss(a,u)smoothstep(a,-a,u)//bad namespace for this,more trouble than its worth\nvec1 suv(vec4 a){return dot(vec4(1),a);}vec1 suv(vec3 a){return dot(vec3(1),a);}vec1 suv(vec2 a){return a.x+a.y;}//sum of vector\n#define minx(a,b)mix(b,a,step(a.x,b.x))\n#define manx(a,b)mix(a,-b,step(a.x,-b.x))\n#define maxx(a,b)-minx(-a,-b)\n\n\n//2d zoom\n#define ViewZoom 4.\n//divide by/aa for hairline drawing and sharp smoothstep()\n#define Aa(r) (min(r.x,r.y)/ViewZoom)\n#define fra(t,u,r,m)(u-.5*r.xy)*ViewZoom/r.y\n\n//https://www.shadertoy.com/view/4l2BRD\n//x sets start point of 50% \n//y sets easin and easeout time (from 0 to 1 and from 1 to 0)\n//z sets end   point of 50%\n#define smoothBump(x,y,z,w) smoothstep(x-z,x+z,w)*smoothstep(y+z,y-z,w)\n//i am not a fan of the smootzhbump above, it is not parallel, it is boun badly\n//it sure has its use cases, but for me it needs a context with more utility\n//by being vound to domain[0..1] and range[0..1]\nfloat smoothbump2(vec2 u,vec4 m//https://www.shadertoy.com/view/XtdfWl\n){//u/=4.//based on smothbump(), it ended as generalization of a sawCos()-like\n ;//m/=4.\n ;//domain [ 0. <= m.x < m.z < 1. ] is well defined \n ;//the m.z==1 case is shit, open intervals are harer to catch\n ;//the m.x==1 case is shit, open intervals are harer to catch\n ;if(abs(u.x-.5)>.5)return u.y/32.//optional outOfBounds shortcut\n ;//vec2 c=vec2(0)\n ;m.xz=sat(m.xz)\n ;m.xz=vec2(min(m.x,m.z),max(m.x,m.z))//sorting simplifies things? not here!\n //;m.xz=fract(m.xz)\n ;//if(m.x>m.z)m.xz=vec2(m.x+m.z)/2.//compromise sorting\n ;// i really dislike this open interval asymptote evading epsilon stuff, this is where math fails!\n ;if(m.z>.9999)m.z=.9999 //enforce bounds or else this else{} part is needed, and its not well done!\n ;if(m.x>.9999)m.x=.9999 //enforce bounds or else this else{} part is needed, and its not well done!\n ;if(m.x<.0001)m.x=.0001 //enforce bounds or else this else{} part is needed, and its not well done!\n ;m.z=max(m.x,m.z)//m.x dominates //faster and makes sense for decaying things\n ;//if(m.z<1.&&m.x>0.){\n     m.xy=vec2(u.x/m.x,(u.x-1.)/(-1.+m.z))//catch non-asymptotic case.\n //;}//else m.xy=vec2(mix(u.x,0.,step(1.,u.x)),1.)//asymptotic special case is not good for outOfBounds\n #if 1\n ;m.xy=smoothstep(vec2(0),vec2(1),m.xy)//2 smoothsteps in 1\n #else\n ;m.xy=sat(m.xy) //optionally to the above, just to linearEaseTween\n #endif     \n ;m.xy=-m.xy \n ;return max(m.x,m.y);}\n\n\nvec4 demoSmoothBump(vec2 u,vec4 m){\n ;vec4 c=vec4( smoothbump2(vec2(u.x   ,u.y),m   )+u.y)\n ;  // c=vec4((smoothbump2(vec2(u.x/2.,u.y),m/2.)+u.y)*2.)//scaling example\n ;c.x=smoothstep(.1,-.1,c.x)\n ;c.y=smoothstep(.1,-.1,c.y)\n ;c.z=smoothstep(.1,-.1,c.z)\n ;c.w=smoothstep(.1,-.1,c.w)\n ;c.xy+=c.w\n ;c.w=1.\n ;return c;\n ;//return vec4(smoothBump(0.,m.x-m.z*.5,m.z,u.x)-u.y)//meh this is rather dumb\n ;//return vec4(smoothBump(0.,m.x,m.z,u.x)-u.y)\n ;}\n\n\nvoid mainImage( out vec4 o, in vec2 u\n){vec4 c=vec4(0)\n ;//t=0.//override time for vis\n ;float t=iTime\n ;vec3 r=iResolution.xyz\n ;vec4 m=iMouse.xyzw\n ;u   =fra(t,u   ,r,m)\n ;if(m.z>0.){\n  ;m.xy=fra(t,m.xy,r,m)\n  ;m.zw=fra(t,m.zw,r,m)\n ;}else{//iMouse is cos(hash41Aperiodic())\n   ;m=sqrt(vec4(5,2,3,1))-vec4(21,17,13,11) //QuadraticField: see: https://www.shadertoy.com/view/Xt3BDB\n   ;m=sin(m*t*.1)//time as seed for hash m.\n   ;m=(m/ViewZoom+1./ViewZoom)*1.5\n       \n   ;//m.xyzw=m.xyzw*.5+.5//mirror symmetry on y=0\n   ;//m.yw=m.yw*.3+.3//minimum key width\n   ;m*=ViewZoom*.4//view scale\n ;}\n ;c=demoSmoothBump(u,m)\n ;c.x=length(u-m.xy)-.1\n ;c.y=length(u-m.zw)-.1\n      ;c.x=smoothstep(.1,-.1,c.x)\n ;c.y=smoothstep(.1,-.1,c.y)\n ;o=c\n  ;}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtdfWl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtGBDh", "name": "Raymarch anything (iq mix)", "author": "Del", "description": "same map function, using IQs marching code / shadows etc. (press mouse for bonus nipple mix)", "tags": ["3d", "raymarching"], "likes": 4, "viewed": 379, "date": "1542290776", "time_retrieved": "2024-06-20T19:25:18.513013", "image_code": "// Raymarch anything #3 - using one of IQs raymarchers :)\n//\n// RayMarch + Shadow base code from here: https://www.shadertoy.com/view/lsKcDD\n//------------------------------------------------------------------\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat pMod1(inout float p, float size)\n{\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nfloat hash(vec2 p)  // replace this by something better\n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nmat2 rotate(float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat objID = 0.0;\nfloat svobjID = 0.0;\n\n#define\tTAU 6.28318\n\n//------------------------------------------------------------------\n\n\n\nfloat map(vec3 p)\n{\n    float time=iTime;\n    float zo = time*6.75;\n    float modz = mod(zo,44.0);\n    \n    float t2 = fract(time*1.1) * TAU;\n    float t3 = fract(time*0.7) * TAU;\n    float t4 = fract(time*0.14)* TAU;\n    \n    float m = 0.5+sin(t2+p.z*0.4)*0.5;\n    m += 0.5+cos(p.z*0.4+t3+p.x*0.4)*0.5;\n    \n    p.xy *= rotate(p.z * .08 + t4);\n    \n\tp.z += modz;\n    float c1 = pMod1(p.z,44.0);\n    \n\tfloat dist = 3.5 -abs(p.y)+m;\n    \n    vec3 p2 = p;\n\tfloat cz = pMod1(p2.z,4.0);\n\tfloat cx = pMod1(p2.x,4.0);\n\n    float r = hash(vec2(cz+(cz*0.31),cx+(cx*0.61)));\n\n    if (abs(cx)<1.0)\n        r=0.0;\n\n    if (iMouse.z < 0.5)\n    {\n        if (r>0.75)\n        {\n            float d2 = sdCylinder(p2,vec2(0.7,5.5));         \n            dist = smin(dist,d2,1.1);\n        }\n    }\n    else\n    {\n        // nipple mix\n        if (r>0.875)\n        {\n            float d2 = sdSphere(p2+vec3(0.0,3.2+m,0.0),0.8);\n            float d3 = sdSphere(p2-vec3(0.0,3.2+m,0.0),0.8);\n            dist = smin(dist,d2,1.1);\n            dist = smin(dist,d3,1.1);\n        }\n    }\n    \n    \n    objID = abs(p.z)/44.0;\n    return dist;\n}\n\n\n//------------------------------------------------------------------\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<50; i++ )\t//32\n    {\n\t\tfloat h = map( ro + rd*t );\n\n        // traditional technique\n        //\tres = min( res, 10.0*h/t );\n        // improved technique\n            // use this if you are getting artifact on the first iteration, or unroll the\n            // first iteration out of the loop\n            //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, 10.0*d/max(0.0,t-y) );\n        ph = h;\n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\nfloat castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 100.0;\n   \n    \n    float t = tmin;\n    for( int i=0; i<180; i++ )\n    {\n\t    float precis = 0.0005*t;\n\t    float res = map( ro+rd*t );\n        if( res<precis || t>tmax ) break;\n        t += res*0.25;\n    }\n\n    if( t>tmax ) t=-1.0;\n    return t;\n    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.001 + 0.15*float(i)/4.0;\n        float d = map( pos + h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );    \n}\n\nvec3 render( in vec3 ro, in vec3 rd)\n{ \n    vec3  col = vec3(0.0);\n    float t = castRay(ro,rd);\n\n    svobjID = objID;\n    if( t>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        \n        // material        \n\t\tvec3 mate1 = vec3(1.7,0.6,0.7)*0.2;\n\t\tvec3 mate2 = vec3(1.5,1.2,0.7)*0.2;\n        \n        float m = svobjID;\n        vec3 mate = mix(mate1,mate2,m);\n        \n\n        // key light\n        //vec3  lig = normalize( vec3(-0.1, 0.3, 0.6) );\n        \n\t\tvec3 lig = ro+vec3(-0.1,0.0,12.0);\n        lig = normalize(lig);\n        \n        vec3  hal = normalize( lig-rd );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float sha = calcSoftshadow( pos, lig, 0.01, 3.0 );\n        dif *= sha*0.85;\n\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n\t\tcol = mate * 4.0*dif*vec3(1.00,0.70,0.5);\n        col +=      12.0*spe*vec3(1.00,0.70,0.5);\n        \n        // ambient light\n        //float occ = calcAO( pos, nor );\n        float occ=1.0;\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        col += mate*amb*occ*vec3(0.0,0.08,0.1);\n        \n        // fog\n        col *= exp( -0.0005*t*t );\n    }\n\n\treturn col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera\t\n    vec3 ro = vec3( 0.0, 0.0, -111.0 );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    //int technique = (fract(iTime/2.0)>0.5) ? 1 : 0;\n\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n    // ray direction\n    vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n    // gamma\n    col = pow( col, vec3(0.4545) );\n    \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtGBDh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtGBDR", "name": "Test Rounded Cone Intersector", "author": "iq", "description": "Testing [url]https://www.shadertoy.com/view/MlKfzm[/url]", "tags": ["3d", "raytracing", "cone"], "likes": 9, "viewed": 625, "date": "1542177823", "time_retrieved": "2024-06-20T19:25:18.518942", "image_code": "// Created by inigo quilez - iq/2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Testing https://www.shadertoy.com/view/MlKfzm.\n\n\nvec4 iRoundedCone( in vec3  ro, in vec3  rd, \n                   in vec3  pa, in vec3  pb, \n                   in float ra, in float rb,\n                   out float v )\n{\n    vec3  ba = pb - pa;\n\tvec3  oa = ro - pa;\n    float rr = ra - rb;\n    \n    float m0 = dot(ba,ba);\n    float m1 = dot(ba,oa);\n    float m2 = dot(ba,rd);\n    float m3 = dot(rd,oa);\n    float m5 = dot(oa,oa);\n\n    float d2 = m0 - rr*rr;\n\n    float k2 = d2    - m2*m2;\n    float k1 = d2*m3 - m1*m2 + m2*rr*ra;\n    float k0 = d2*m5 - m1*m1 + m1*rr*ra*2.0 - m0*ra*ra;\n    \n\tfloat h = k1*k1 - k0*k2;\n\tif(h < 0.0) return vec4(-1.0);\n    float t = (-sqrt(h)-k1)/k2;\n\n    // body\n    float y = m1 - ra*rr + t*m2;\n    if( y>0.0 && y<d2 ) \n    {\n        v = y/d2;\n        return vec4(t, normalize(oa+t*rd-ba*v) );\n    }\n\n\t// base cap\n\th = m3*m3 - m5 + ra*ra;\n\tif( h>0.0 )\n    {\n        v = 0.0;\n        t = -m3 - sqrt( h );\n\t    return vec4( t, (oa+t*rd)/ra );\n    }\n    return vec4(-1.0);\n}\n\n//---------------------------------\n\n#define AA 2\n\nconst int num = 80; // make this bigger for more precision curve\n\n\nvec3 path( in float h )\n{\n    return 0.5*sin(6.2831*h*vec3(3.0,2.0,5.0)+vec3(0.0,1.0,3.0)+0.5*iTime*vec3(1.1,1.3,1.7));\n}\n\nfloat size( in float h )\n{\n    return 0.04 + 0.03*sin(6.2831*h*8.0+1.3);\n}\n\nvec4 intersect( in vec3 ro, in vec3 rd, out float h )\n{\n    vec3  oce = path(0.0);\n    float ora = size(0.0);\n    vec4 tnor = vec4(1e20);\n    float hm = 0.0;\n    for( int i=1; i<=num; i++ )\n    {\n        float h = float(i)/float(num);\n        vec3  ce = path(h);\n        float ra = size(h);\n\n        vec4 tmp; float tmpv;\n        tmp = iRoundedCone( ro, rd, oce, ce, ora, ra, tmpv );\n        if( tmp.x>0.0 && tmp.x<tnor.x ) { tnor = tmp; hm=h+tmpv/float(num); }\n\n        oce = ce;\n        ora = ra;\n    }\n\n    h = hm;\n    return tnor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.01*iTime;\n\tvec3 ro = vec3( 1.0*sin(an), 0.4, 1.0*cos(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n\n        // raytrace\n        float hm;\n        vec4 tnor = intersect( ro, rd, hm );\n        float t = tnor.x;\n\n        // backround        \n        vec3 col = vec3(0.015)*(1.0-0.15*dot(p,p));\n        \n        // tubes\n        if( t<1e19 )\n        {\n            // material\n            vec3 mate = 0.5 + 0.5*cos(2.0*hm*6.2831+vec3(0.0,2.0,3.0));\n            \n            // lighting\n            vec3 pos = ro + t*rd;\n            vec3 nor = tnor.yzw;\n            const vec3 lig = vec3(0.8,0.6,0.0);\n            vec3 hal = normalize(lig-rd);\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n            float spe = clamp(dot(nor,hal),0.0,1.0);\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            float kk; float sha = (intersect( pos+nor*0.001, lig, kk ).x<1e19) ? 0.0 : 1.0;\n            float fre = clamp(1.0+dot(rd,nor),0.0,1.0);\n            \n            col = vec3(0.05,0.1,0.15)*amb + vec3(1.0,0.8,0.5)*dif*sha;\n            col *= mate;\n            col += 0.5*pow(spe,16.0)*dif*sha;\n            col += fre*fre*0.2*mate*(0.5+0.5*dif*sha);\n        }\n\t\n        // gamma\n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // dither to remove banding in the background\n    tot += fract(sin(fragCoord.x*vec3(13,1,11)+fragCoord.y*vec3(1,7,5))*158.391832)/255.0;\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtGBDR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtGBDW", "name": "Inverse Hilbert Curve", "author": "Wunkolo", "description": "Projection of a 2D point onto a Hilbert Curve", "tags": ["projection", "curve"], "likes": 24, "viewed": 1173, "date": "1542468823", "time_retrieved": "2024-06-20T19:25:18.519739", "image_code": "#define LEVEL 15U\n#define WIDTH ( (1U << LEVEL) )\n#define AREA ( WIDTH * WIDTH )\n\nfloat HilbertIndex( uvec2 Position )\n{   \n    uvec2 Regions;\n    uint Index = 0U;\n    for( uint CurLevel = WIDTH/2U; CurLevel > 0U; CurLevel /= 2U )\n    {\n        uvec2 Region = uvec2(greaterThan((Position & uvec2(CurLevel)), uvec2(0U)));\n        Index += CurLevel * CurLevel * ( (3U * Region.x) ^ Region.y);\n        if( Region.y == 0U )\n        {\n            if( Region.x == 1U )\n            {\n                Position = uvec2(WIDTH - 1U) - Position;\n            }\n            Position.xy = Position.yx;\n        }\n    }\n    \n    return float(Index) / float(AREA);\n}\n\nvec4 mirrored(vec4 v)\n{\n    vec4 Mod = mod(v, 2.0);\n    return mix(Mod, 2.0 - Mod, step(1.0, Mod));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 UV = fragCoord/iResolution.xy;\n    UV.x *= iResolution.x / iResolution.y;\n    UV.x -= fract((iResolution.x ) / iResolution.y) / 2.0;\n   \n    uvec2 FragCoord = uvec2( UV * float(WIDTH) );\n    float Index = HilbertIndex( FragCoord );\n    \n    Index += iTime / 12.0;\n\tvec2 Border = smoothstep(vec2(0.0), vec2(0.0) + vec2(0.01), UV) -\n        smoothstep(vec2(1.0) - vec2(0.01), vec2(1.0), UV);\n    fragColor = mirrored(\n        vec4(\n            Index * 7.0,\n            Index * 11.0,\n            Index * 13.0,\n            1.0\n        )\n\t) * (Border.x * Border.y);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtGBDW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtGBWw", "name": "Looney toons", "author": "Polytope", "description": "Just playing around with polar coord", "tags": ["2d", "polarcoords"], "likes": 6, "viewed": 153, "date": "1542660045", "time_retrieved": "2024-06-20T19:25:18.519739", "image_code": "#define PI 3.1415926\n\nvec4 color1 = vec4(1.0, 0.1, 0.0, 1.0);\nvec4 color2 = vec4(1.0, 0.4, 0.0, 1.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    \n    float r = length(abs(uv));\n   \tfloat a = atan(uv.y, uv.x);\n\n   \tfloat y = fract(r*18./(r+.6)-iTime);\n\t\n    y = smoothstep(0.0, 1.0, y);\n   \n   \tfloat x = length(uv);\n   \tx = smoothstep(.11,.21, x);\n\n    fragColor = mix(color2,color1,y)*x;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtGBWw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtGBzD", "name": "Mandelbrot iteration", "author": "nking", "description": "Visualisation of the compex plane as it goes through the mandelbrot sequence linearly interpolated between values.", "tags": ["mandelbrot"], "likes": 3, "viewed": 99, "date": "1541931945", "time_retrieved": "2024-06-20T19:25:18.834251", "image_code": "const float scale = 3.0;\nconst float timeScale = 0.5;\nconst float PI = 3.1415926535;\n\n//  Function from I√±igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\n\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nfloat arctan(vec2 v) {\n\treturn atan(v.y, v.x);\n}\n\nvec3 col(vec2 complex) {\n\tfloat normAng = arctan(-complex) / PI / 2.0 + 0.5;\n\tfloat len = length(complex) + 1.0;\n\tlen = 1.0 / len;\n\n\treturn hsb2rgb(vec3(normAng, 1.0, len));\n}\n\nvec2 sq(vec2 c) {\n\treturn vec2(c.x*c.x - c.y*c.y, 2.0*c.x*c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 screenPos = fragCoord.xy - vec2(0.5, 0.5) * iResolution.xy;\n\tscreenPos /= min(iResolution.x, iResolution.y);\n\tscreenPos *= scale;\n    screenPos += vec2(-0.6,0.0);\n\n    vec2 z = vec2(0.0);\n\tvec2 pz = z;\n\tfloat ntime = mod(iTime * timeScale, 30.0);\n\tfloat dtime = ntime - floor(ntime);\n    \n\tfor (float i = 0.0; i < ntime + 1.0; i++) {\n        pz = z;\n        z = sq(pz) + screenPos;\n    }\n\n    z = mix(pz, z, dtime);\n\n    fragColor = vec4(col(z), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtGBzD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtGBzK", "name": "Noisy transition", "author": "Simplyfire", "description": "fun transition between two colors - click with mouse to interact", "tags": ["noise", "color", "lava"], "likes": 7, "viewed": 173, "date": "1543063668", "time_retrieved": "2024-06-20T19:25:18.840410", "image_code": "#define outer vec3(.1 , 1.0, 1.)\n#define inner vec3(.15,0.5, 1.)\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n#define s smoothstep\n\nfloat map(float x, float a1, float a2, float b1, float b2){\n  return b1 + (b2-b1) * (x-a1) / (a2-a1);\n}\n\nvec3 rgb( in vec3 c){\n vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0), 6.0)-3.0)-1.0, 0.0, 1.0 );\n rgb = rgb*rgb*(3.0-2.0*rgb);\n return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nfloat maxrect(vec2 uv, vec2 c){\n\treturn max(abs(c.x-uv.x), abs(c.y-uv.y));\n}\n\n// book of shaders mathemagic\n// https://thebookofshaders.com/11/\n// https://thebookofshaders.com/edit.php#11/iching-03.frag\n\nvec3 random3(vec3 c) {\n    float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n    vec3 r;\n    r.z = fract(512.0*j);\n    j *= .125;\n    r.x = fract(512.0*j);\n    j *= .125;\n    r.y = fract(512.0*j);\n    return r-0.5;\n}\n\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\nfloat snoise(vec3 p) {\n\n    vec3 s = floor(p + dot(p, vec3(F3)));\n    vec3 x = p - s + dot(s, vec3(G3));\n\n    vec3 e = step(vec3(0.0), x - x.yzx);\n    vec3 i1 = e*(1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\n    vec3 x1 = x - i1 + G3;\n    vec3 x2 = x - i2 + 2.0*G3;\n    vec3 x3 = x - 1.0 + 3.0*G3;\n\n    vec4 w, d;\n\n    w.x = dot(x, x);\n    w.y = dot(x1, x1);\n    w.z = dot(x2, x2);\n    w.w = dot(x3, x3);\n\n    w = max(0.6 - w, 0.0);\n\n    d.x = dot(random3(s), x);\n    d.y = dot(random3(s + i1), x1);\n    d.z = dot(random3(s + i2), x2);\n    d.w = dot(random3(s + 1.0), x3);\n\n    w *= w;\n    w *= w;\n    d *= w;\n\n    return dot(d, vec4(52.0));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n    if(m.x == 0. && m.y == 0.){\n        m.x = .5;\n        m.y = .25;\n    }\n    vec2 c = vec2(.5, .5);\n    float transitionSize = m.y;\n    float granularity = m.x*5.;\n    float t = iTime*m.y;\n    vec3 colorA = vec3(.0, 1., 1.);\n    vec3 colorB = vec3(.6, 1.6, 0.2);\n    float noiseInX = uv.x*granularity;\n    float noiseInY = uv.y*granularity-t;\n    float n = snoise(vec3(noiseInX, noiseInY, 0));\n    float pct = s(0., 1., uv.y+transitionSize*n);\n    vec3 hsb = mix(colorA, colorB, pct);\n    \n    fragColor = vec4(rgb(hsb), 1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtGBzK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtGfRG", "name": "[twitch] Geometric Descent", "author": "yx", "description": "I stream shader creation every Wednesday at 9pm UK time, over at [url]https://twitch.tv/lunasorcery[/url]\nCome and watch a show!\n\nOr watch the VOD for this shader here: [url]https://www.twitch.tv/videos/339397877[/url]", "tags": ["raymarching", "shapes", "twitch"], "likes": 64, "viewed": 1963, "date": "1542842330", "time_retrieved": "2024-06-20T19:25:18.840410", "image_code": "/*\n\tThis shader was created live on stream!\n\tYou can watch the VOD here: https://www.twitch.tv/videos/339397877\n\t\n\tI use the Bonzomatic tool by Gargaj/Conspiracy:\n\thttps://github.com/Gargaj/Bonzomatic\n\n\tWednesdays around 9pm UK time I stream at https://twitch.tv/lunasorcery\n\tCome and watch a show!\n\n\t~yx\n*/\n\nconst float phi = (1.+sqrt(5.))*.5;\n\nfloat noise(vec3 p)\n{\n    return fract(\n        sin(\n            dot(p, vec3(12.4536728,432.45673828,32.473682))\n        )*43762.342);\n}\n\nvec2 rotate(vec2 a, float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x * c - a.y * s,\n        a.x * s + a.y * c\n    );\n}\n\nfloat sdIcosahedron(vec3 p, float r)\n{\n    const float q = (sqrt(5.)+3.)/2.;\n\n    const vec3 n1 = normalize(vec3(q,1,0));\n    const vec3 n2 = vec3(sqrt(3.)/3.);\n\n    p = abs(p/r);\n    float a = dot(p, n1.xyz);\n    float b = dot(p, n1.zxy);\n    float c = dot(p, n1.yzx);\n    float d = dot(p, n2.xyz)-n1.x;\n    return max(max(max(a,b),c)-n1.x,d)*r; // turn into (...)/r  for weird refractive effects when you subtract this shape\n}\n\nfloat sdDodecahedron(vec3 p, float r)\n{\n    const vec3 n = normalize(vec3(phi,1,0));\n\n    p = abs(p/r);\n    float a = dot(p,n.xyz);\n    float b = dot(p,n.zxy);\n    float c = dot(p,n.yzx);\n    return (max(max(a,b),c)-n.x)*r;\n}\n\nfloat scene(vec3 p)\n{\n    p.xy = rotate(p.xy, p.z*.05);\n\n    float n = noise(floor((p)/4.));\n    float shape = fract((floor(p.x/4.)+floor(p.y/4.)*2.)/4.);\n    float spinOffset1 = floor(p.z/4.);\n    float spinOffset2 = floor(p.z/4.+2.);\n    float spinOffset3 = floor(p.z/4.+4.);\n\n\n    p = mod(p,4.)-2.;\n    p.xy = rotate(p.xy, iTime+spinOffset1);\n    p.yz = rotate(p.yz, iTime+spinOffset2);\n    p.zx = rotate(p.zx, iTime+spinOffset3);\n\n    if (shape < .25) {\n        return min(\n            sdDodecahedron(p,1.),\n            sdIcosahedron(p.zyx,1.)\n        );\n    } else if (shape < .5) {\n        return max(\n            sdDodecahedron(p,1.),\n            -sdIcosahedron(p.zyx,.9)\n        );\n    } else if (shape < .75) {\n        return max(\n            -sdDodecahedron(p,.95),\n            sdIcosahedron(p.zyx,1.)\n        );\n    } else {\n        return max(\n            sdDodecahedron(p,.95),\n            sdIcosahedron(p.zyx,1.)\n        );\n    }\n}\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    uv *= 1.+length(uv)*.5;\n\n    vec3 cam = vec3(0,0,0);\n    vec3 dir = normalize(vec3(uv,1));\n\n    //cam.yz = rotate(cam.yz, .3);\n    //dir.yz = rotate(dir.yz, .3);\n\n    cam.z = iTime * 4.;\n    dir.xy = rotate(dir.xy, iTime*.1);\n    //dir.yz = rotate(dir.yz, iTime*.3);\n    //dir.zx = rotate(dir.zx, iTime*.3);\n\n    float t = 0.;\n    float k = 0.;\n    int i;\n    for(i=0;i<100;++i)\n    {\n        k = scene(cam+dir*t)*.55;\n        t += k;\n        if (k < .001) break;\n    }\n\n    vec3 h = cam+dir*t;\n    vec2 o = vec2(.001, 0);\n    vec3 n = normalize(vec3(\n        scene(h+o.xyy)-scene(h-o.xyy),\n        scene(h+o.yxy)-scene(h-o.yxy),\n        scene(h+o.yyx)-scene(h-o.yyx)\n    ));\n\n    float iterFog = pow(1.-(float(i)/100.), 2.);\n    float light = pow(max(0.,n.x*.5+.5),2.);\n    float vignette = smoothstep(2.,0.,length(uv));\n    vec3 a = mix(vec3(.01,.01,.1),vec3(0,1,1),iterFog);\n    vec3 b = mix(vec3(0,0,0),vec3(1,sin(iTime*.4)*.5+.5,cos(iTime*.4)*.5+.5),light*iterFog*4.);\n    out_color.rgb = a + b;\n    out_color *= vignette;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtGfRG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtGfRV", "name": "Eleven point conic, dual", "author": "mla", "description": "Dual of [url]https://www.shadertoy.com/view/lt2BD3[/url]. More lines! And note that there are points where 3 green lines come together, but no point is marked - these are unrecognized collinearities in the original configuration.", "tags": ["dual", "point", "conic", "projective", "eleven"], "likes": 1, "viewed": 200, "date": "1543090630", "time_retrieved": "2024-06-20T19:25:20.737593", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Projective geometry: the eleven point conic, dual.\n//\n// Take 4 lines (red) and the 6 points (yellow) on intersections of pairs of lines,\n// forming a complete quadrilateral.\n//\n// There are 3 diagonal lines joining each point where two lines meet\n// to the point where the other two lines meet (cyan).\n//\n// Given a point l (red), the 6 quadrilateral points form 6 lines with l (purple)\n// and each line has a harmonic conjugate with the two lines of the quadrangle\n// going through the same point (green).\n//\n// Additionally, the 4 lines of the quadrilateral and the point l\n// define a pair of conics (blue and grey), tangent to the 4 lines\n// and passing through the point (these conics may be imaginary though).\n//\n// The three diagonal liness, the six harmonic lines and the two lines\n// of tangency of the pair of conics at l are all tangent to a third conic,\n// the eleven point conic (white).\n//\n// Copyright (c) Matthew Arcus, 2018\n// MIT License: https://opensource.org/licenses/MIT\n//\n// Controls:\n// Drag mouse to change line\n// '1' and '2': change initial configuration\n// 'f': change line & point drawing style\n// 'z': zoom in\n//\n////////////////////////////////////////////////////////////////////////////////\n\nint configuration = 2;\n\nconst float lwidth = 0.015;\nconst float pwidth = 0.045;\nfloat ledge0 = 0.0, ledge1 = lwidth;\nfloat pedge0 = lwidth, pedge1 = pwidth;\nconst float scale = 2.5;\nfloat zoom = 1.0;\n\nconst float PI =  3.141592654;\n\nconst vec3 pcolor0 = vec3(1,0,0);\nconst vec3 pcolor1 = vec3(0,1,0);\nconst vec3 pcolor2 = vec3(1,1,0);\nconst vec3 pcolor3 = vec3(0,1,1);\nconst vec3 pcolor4 = vec3(0.5,0,0.5);\nconst vec3 lcolor0 = pcolor0;\nconst vec3 lcolor1 = pcolor1;\nconst vec3 lcolor2 = vec3(1,1,0.2);\nconst vec3 ccolor0 = vec3(1,1,1);\nconst vec3 ccolor1 = vec3(0,0,1);\nconst vec3 ccolor2 = vec3(0.5,0.5,1);\n\n// Solve Ax^2 + 2Bx + C = 0\nbool quadratic(float A, float B, float C,\n               out float x1, out float x2) {\n   float D = B*B - A*C;\n   if (D < 0.0) return false;\n   D = sqrt(D);\n   if (B < 0.0) D = -D;\n   x1 = (-B-D)/A;\n   x2 = C/(A*x1);\n   return true;\n}\n\n// Return either intersection of lines p and q\n// or line through points p and q, r = kp + jq\nvec3 join(vec3 p, vec3 q) {\n  return cross(p,q);\n}\n\n// Find a projective mapping taking p0,p1,p2,p4 to\n// triangle of reference and unit point, ie:\n// p0 -> (1,0,0), p1 -> (0,1,0), p2 -> (0,0,1), p3 -> (1,1,1)\n// No three points collinear.\nmat3 rproject(vec3 p0, vec3 p1, vec3 p2, vec3 p3) {\n  // Just an inverse for the first three points\n  // (the triangle of reference). No inverse if collinear.\n  mat3 m = inverse(mat3(p0,p1,p2)); // column major!\n  p3 = m*p3; \n  // Then scale each row so the unit point (1,1,1) is correct\n  m = transpose(m);\n  // zero components here only if not collinear\n  m[0] /= p3[0];\n  m[1] /= p3[1];\n  m[2] /= p3[2];\n  return transpose(m);\n}\n\n// Represent a projective conic as a 3x3 matrix:\n//\n// M = (a,d,e,\n//      d,b,f,\n//      e,f,c)\n//\n// is: axx + byy + czz + 2(dxy + exz + fyz) = 0\n// calculated as pMp for p = (x,y,z).\n//\n// We can treat this as a distance field, scaled by the\n// (x,y) derivative in order to get correct line widths.\n\n// With this representation, the dual conic is just the inverse;\n// if the determinant is zero then there is no dual and the\n// conic is degenerate.\n\n// Conic through 4 points and a line - there are 2 solutions, so\n// need to solve quadratic. I'm sure I didn't invent this but\n// can't remember the source.\n// l.p = l'p == l'(MinvM)p = (Minv'l)'Mp\nbool conic4points(vec3 p0, vec3 p1, vec3 p2, vec3 p3, vec3 l4, out mat3 M0, out mat3 M1) {\n  // p takes p0,p1,p2,p3 to triangle of reference and unit point\n  mat3 p = rproject(p0,p1,p2,p3);\n  // and then to the square (1,1),(1,-1),(-1,1),(-1,-1)\n  mat3 q = rproject(vec3(1,-1,1), vec3(-1,1,1),vec3(-1,-1,1),vec3(1,1,1));\n  p = inverse(q)*p; // q is constant\n  // Now construct a conic through the images of p0-p3 and l4\n  l4 = transpose(inverse(p))*l4;\n  float i = l4.x, j = l4.y, k = l4.z;\n  float A = -j*j, B = 0.5*(i*i+j*j-k*k), C = -i*i;\n  float t0,t1;\n  if (!quadratic(A,B,C,t0,t1)) return false;\n  M0 = mat3(t0, 0, 0,\n            0, -1, 0,\n            0,  0, 1.0-t0);\n  M0 = transpose(p)*M0*p;\n  if (isnan(determinant(M0))) return false;\n  M1 = mat3(t1, 0, 0,\n            0, -1, 0,\n            0,  0, 1.0-t1);\n  M1 = transpose(p)*M1*p;\n  if (isnan(determinant(M1))) return false;\n  return true;\n}\n\n// Find the two points of intersection of a line through p0 and\n// p1 with the conic defined by M.\nbool lineconic(vec3 p0, vec3 p1, mat3 M, out vec3 q0, out vec3 q1) {\n  // (tp0 + p1)M(tp0 + p1) == 0\n  float A = dot(p0,M*p0);\n  float B = dot(p0,M*p1);\n  float C = dot(p1,M*p1);\n  float t0,t1;\n  if (!quadratic(A,B,C,t0,t1)) return false;\n  q0 = t0*p0+p1;\n  q1 = t1*p0+p1;\n  return true;\n}\n\n// Find the two points of intersection of the line l\n// with the conic defined by c.\nbool lineconic(vec3 l, mat3 M, out vec3 i0, out vec3 i1) {\n  // Intersect l with two of the axes. This might of course\n  // be the same point (1,0,0) here, so should use the third\n  // axis.\n  vec3 p0 = join(l,vec3(0,0,1));\n  vec3 p1 = join(l,vec3(0,1,0));\n  return lineconic(p0,p1,M,i0,i1);\n}\n\n// Construct the conic defined by 5 points.\n// Method taken from \"Geometry\", Brannan, Esplan & Gray, CUP, 2012\nmat3 conic5points(vec3 p0, vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n  // p takes p0,p1,p2,p3 to triangle of reference and unit point\n  mat3 p = rproject(p0,p1,p2,p3);\n  // Now construct a conic through the images of p0-p4,\n  p4 = p*p4;\n  float a = p4.x, b = p4.y, c = p4.z;\n  float d = c*(a-b);\n  float e = b*(c-a);\n  float f = a*(b-c);\n  mat3 m = mat3(0,d,e,\n                d,0,f,\n                e,f,0);\n  // And combine the two.\n  return transpose(p)*m*p;\n}\n\n// Harmonic conjugate of p,q and intersection of p,q with l.\nvec3 harmonic(vec3 p, vec3 q, vec3 l) {\n  // kp + jq is conjugate of kp - lq:\n  // l.(kp - jq) = 0\n  // k(l.p) = j(l.q)\n  float k = dot(l,q);\n  float j = dot(l,p);\n  return k*p+j*q;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Drawing functions\n////////////////////////////////////////////////////////////////////////////////\n\nfloat line(vec3 pos, vec3 p) {\n  if (p.z == 0.0) return 0.0;\n  pos /= pos.z; p /= p.z; // Normalize\n  float dist = distance(pos,p);\n  if (isnan(dist)) return 0.0;\n  return 1.0-smoothstep(pedge0,pedge1,dist);\n}\n\nfloat point(vec3 pos, vec3 l) {\n  float dist = dot(pos,l)/(pos.z*length(l.xy));\n  if (isnan(dist)) return 0.0;\n  return 1.0-smoothstep(ledge0,ledge1,abs(dist));\n}\n\nfloat conic(vec3 pos, mat3 m) {\n  m = inverse(m);\n  float dist = dot(pos,m*pos);   // Distance from the conic\n  vec3 grad = m*pos*2.0;         // The gradient uses the same matrix.\n  dist /= pos.z*length(grad.xy); // Normalize for Euclidean distance\n  if (isnan(dist)) return 0.0;\n  return 1.0-smoothstep(ledge0,ledge1,abs(dist));\n}\n\n// Screen coords to P2 coords\nvec3 map(vec2 p) {\n  return vec3(scale*zoom*(2.0*p - iResolution.xy) / iResolution.y, 1);\n}\n\n//-------------------------------------------------\n//From https://www.shadertoy.com/view/XtXGRS#\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec3 transform(vec3 p) {\n  float t = 0.5*iTime;\n  p.x *= 1.0-0.5*sin(t);\n  p.y *= 1.0+0.3*sin(0.618*t);\n  p.xy = rotate(p.xy,0.2*t);\n  //p.yz = rotate(p.yz,0.1*t);\n  return p;\n}\n\nvec3 cmix(vec3 color0, vec3 color1, float level) {\n  return mix(color0,color1,level);\n}\n\nconst int CHAR_0 = 48;\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_F = 70;\nconst int CHAR_I = 73;\nconst int CHAR_Z = 90;\nbool keypress(int code) {\n#if defined LOCAL || __VERSION__ < 300\n  return false;\n#else\n  return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  float pixelwidth = 2.0*scale/iResolution.y;\n  if (keypress(CHAR_Z)) zoom = 0.25;\n  if (!keypress(CHAR_F)) {\n      pedge0 = pwidth-pixelwidth;\n      pedge1 = pwidth+pixelwidth;\n      ledge0 = lwidth-pixelwidth;\n      ledge1 = lwidth+pixelwidth;\n  }\n  ledge1 = max(ledge1,1.5*pixelwidth);\n  configuration = int(keypress(CHAR_0+1)) + 2*int(keypress(CHAR_0+2));\n  vec3 pos = map(fragCoord.xy);\n  vec3 p0,p1,p2,p3,l4; // p4 is the movable line\n  if (configuration == 3) {\n    p0 = vec3(1,0,0); p1 = vec3(0,1,0);\n    p2 = vec3(0,0,1); p3 = vec3(1,1,1);\n    l4 = vec3(0.5,-1,1);\n  } else if (configuration == 1) {\n    p0 = vec3(0,0,1); p1 = vec3(1,0,1);\n    p2 = vec3(0,1,1); p3 = vec3(1,1,1);\n    l4 = vec3(0.5,-1,1);\n  } else if (configuration == 2) {\n    p0 = vec3(1,1,1); p1 = vec3(0,1,1);\n    p2 = vec3(0.866,-0.5,1); p3 = vec3(-0.866,-0.5,1);\n    l4 = vec3(0.5,-1,1);\n  } else {\n    p0 = vec3(1,-2,1);  p1 = vec3(-1,-2,1);\n    p2 = vec3(2,1,1); p3 = vec3(-2,1,1);\n    l4 = vec3(-1,-1,1);\n  }\n  p0 = transform(p0); p1 = transform(p1);\n  p2 = transform(p2); p3 = transform(p3);\n  if (iMouse.x != 0.0) {\n    l4 = map(iMouse.xy);\n  }\n  vec3 l01 = join(p0,p1);\n  vec3 l02 = join(p0,p2);\n  vec3 l03 = join(p0,p3);\n  vec3 l12 = join(p1,p2);\n  vec3 l13 = join(p1,p3);\n  vec3 l23 = join(p2,p3);\n\n  // diagonal points\n  vec3 d0 = join(l01,l23);\n  vec3 d1 = join(l02,l13);\n  vec3 d2 = join(l03,l12);\n\n  // harmonic points\n  vec3 h01 = harmonic(p0,p1,l4);\n  vec3 h02 = harmonic(p0,p2,l4);\n  vec3 h03 = harmonic(p0,p3,l4);\n  vec3 h12 = harmonic(p1,p2,l4);\n  vec3 h13 = harmonic(p1,p3,l4);\n  vec3 h23 = harmonic(p2,p3,l4);\n\n  // conics\n  mat3 elevenpoint = conic5points(d0,d1,d2,h01,h23);\n  mat3 M1,M2;\n  bool doM1M2 = conic4points(p0,p1,p2,p3,l4,M1,M2);\n  vec3 i0,i1;\n  bool doN = lineconic(l4,elevenpoint,i0,i1);\n\n  vec3 color = vec3(0);\n\n  // The points of the quadrangle\n  color = cmix(color,pcolor0,point(pos,p0));\n  color = cmix(color,pcolor0,point(pos,p1));\n  color = cmix(color,pcolor0,point(pos,p2));\n  color = cmix(color,pcolor0,point(pos,p3));\n\n#if 1\n  // The midpoints of the sides of the quadrangle\n  color = cmix(color,pcolor1,point(pos,h01));\n  color = cmix(color,pcolor1,point(pos,h02));\n  color = cmix(color,pcolor1,point(pos,h03));\n  color = cmix(color,pcolor1,point(pos,h12));\n  color = cmix(color,pcolor1,point(pos,h13));\n  color = cmix(color,pcolor1,point(pos,h23));\n\n  // The magic triangle\n  color = cmix(color,pcolor3,point(pos,d0));\n  color = cmix(color,pcolor3,point(pos,d1));\n  color = cmix(color,pcolor3,point(pos,d2));\n\n  color = cmix(color,pcolor4,point(pos,join(l01,l4)));\n  color = cmix(color,pcolor4,point(pos,join(l02,l4)));\n  color = cmix(color,pcolor4,point(pos,join(l03,l4)));\n  color = cmix(color,pcolor4,point(pos,join(l12,l4)));\n  color = cmix(color,pcolor4,point(pos,join(l13,l4)));\n  color = cmix(color,pcolor4,point(pos,join(l23,l4)));\n  \n  if (doN) {\n    color = cmix(color, pcolor2, point(pos,i0));\n    color = cmix(color, pcolor2, point(pos,i1));\n  }\n\n  // The conics\n  color = cmix(color,ccolor0,conic(pos,elevenpoint));\n  if (doM1M2) {\n    color = cmix(color,ccolor1,conic(pos,M1));\n    color = cmix(color,ccolor2,conic(pos,M2));\n  }\n\n  // The diagonal lines of the quadrangle\n  color = cmix(color,lcolor2,line(pos,l01));\n  color = cmix(color,lcolor2,line(pos,l02));\n  color = cmix(color,lcolor2,line(pos,l03));\n  color = cmix(color,lcolor2,line(pos,l12));\n  color = cmix(color,lcolor2,line(pos,l13));\n  color = cmix(color,lcolor2,line(pos,l23));\n\n  // The moving line\n  color = cmix(color,lcolor0,line(pos,l4));\n#endif  \n  fragColor = vec4(pow(1.0*color,vec3(0.4545)),1);\n}\n", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtGfRV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtGfRW", "name": "Color rotation", "author": "klk", "description": "Rotating color as if it was a point in 3D space", "tags": ["rotation", "colorspace"], "likes": 6, "viewed": 996, "date": "1541888352", "time_retrieved": "2024-06-20T19:25:20.737593", "image_code": "// Created by Alex Kluchikov\n\nvec2 rot(vec2 p,float a)\n{\n    float c=cos(a);\n    float s=sin(a);\n    return p*mat2(s,c,c,-s);\n}\n\nvoid mainImage(out vec4 o, in vec2 uv)\n{\n    uv/=iResolution.xy;\n\n    vec3 col = clamp(1.-.7*vec3(\n        length(uv-vec2(.1,0)),\n        length(uv-vec2(.9,0)),\n        length(uv-vec2(.5,1))\n        ),0.,1.)*2.-1.;\n    col.zx=rot(col.zx,iTime*0.65+.2*sin(uv.y*4.+iTime));\n\n    for(int i=0;i<4;i++)\n    {\n        col.zx=rot(col.zx,iTime*0.65*col.y*0.01);\n        col.xy=rot(col.xy,.7+iTime*col.z*0.01);\n        col.yz=rot(col.yz,.4-iTime*0.79*col.x*0.01);\n    }\n    o=vec4(col*.5+.5,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtGfRW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtGfzw", "name": "Cross - distance 2D", "author": "iq", "description": "Distance to a cross. Produces exact exterior and bound interior distance.", "tags": ["2d", "distancefield", "sdf", "distance", "cross", "vesica"], "likes": 33, "viewed": 3819, "date": "1542069786", "time_retrieved": "2024-06-20T19:25:21.240596", "image_code": "// The MIT License\n// Copyright ¬© 2015 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance to a 2D cross. Produces exact exterior and\n// bound interior distance. I need to fix the interior distance.\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\n\nfloat sdCross( in vec2 p, in vec2 b, float r ) \n{\n    p = abs(p); p = (p.y>p.x) ? p.yx : p.xy;\n    \n\tvec2  q = p - b;\n    float k = max(q.y,q.x);\n    vec2  w = (k>0.0) ? q : vec2(b.y-p.x,-k);\n    float d = length(max(w,0.0));\n    return ((k>0.0)?d:-d) + r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    // animate size\n\tvec2 si = 0.5 + 0.3*cos( iTime + vec2(0.0,1.57) ); if( si.x<si.y ) si=si.yx;\n\n    // animate corner radious\n    float ra = 0.1*sin(iTime*1.2);\n\n    // some failure cases (interior distance is broken)\n    // si = vec2(0.5,0.4); ra=0.0;\n    // si = vec2(0.5,0.2); ra=-0.1;\n\n    // distance\n\tfloat d = sdCross( p, si, ra );\n\n    // color\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-3.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n    // mouse SDF\n    if( iMouse.x>0.001 )\n    {\n    d = sdCross(m, si, ra );\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0015));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/XtGfzw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtKBDD", "name": "Descrates Circle", "author": "zhimo", "description": "Descrates Circle", "tags": ["2d", "circle", "descrates"], "likes": 3, "viewed": 318, "date": "1542616678", "time_retrieved": "2024-06-20T19:25:22.301203", "image_code": "// Author: 185202204@qq.com\n\n//coding by unity shader,github:\n//https://github.com/zhimo1997/ShaderToy\n//more details on my blog :\n//https://blog.csdn.net/qq_36383623/article/details/84237042\n\n\n\n//if uv is in Circle or not\nfloat IsInCircle(vec2 uv,vec2 center,float radius) {\n\tfloat r = distance(uv,center);\n\tif (r < radius) {\n\t\treturn r / radius;\n\t}\n\treturn -1.0;\n}\n\nfloat CaculateAngle(vec2 v1, vec2 v2) {\n\tfloat magnitude1 = sqrt(v1.x*v1.x + v1.y*v1.y);\n\tfloat magnitude2 = sqrt(v2.x*v2.x + v2.y*v2.y);\n\tfloat cosValue = dot(v1, v2) / (magnitude1*magnitude2);\n\tfloat finalAngle = acos(cosValue);\n\tfinalAngle = degrees(finalAngle);\n\n\tvec3 dir = cross(vec3(v1, 0), vec3(v2, 0));\n\tif (dir.z >= 0.0) {\n\t\treturn finalAngle;\n\t}\n\telse{\n\t\treturn 360.0 - finalAngle;\n\t}\n}\n\nfloat CalculateRadius(float r1,float r2,float r4) {\n\tfloat k1 = 1.0/ r1;\n\tfloat k2 = 1.0/ r2;\n\tfloat k4 = 1.0/ r4;\n\n\tfloat t1 = k1 + k2 - k4;\n\tfloat t2 = k1 * k1 + k2 * k2 + k4 * k4;\n\t\t\n\tfloat a = 1.0;\n\tfloat b = -2.0*t1;\n\tfloat c = 2.0 * t2 - t1 * t1;\n\tfloat delta = b * b - 4.0 * a*c;\n\tif (delta < 0.0) {\n\t\treturn -1.0;\n\t}\n\tfloat d1 =( -b + sqrt(delta))/(2.0*a);\n\t//float d2 =Ôºà -b - sqrt(delta)Ôºâ/(2.0*a);\n\treturn 1.0/d1;\n}\n\nvec4 CaculateFourthCircleCenter(vec2 center1,vec2 center2,float r1,float r2) {\n\tfloat m = -(center2.x-center1.x)/(center2.y-center1.y);\n\tfloat n = 0.5*((r2*r2-r1*r1)/(center1.y-center2.y)+center2.y+center1.y+(center1.x*center1.x-center2.x*center2.x)/(center1.y-center2.y));\n\tfloat a = 1.0 + m * m;\n\tfloat b = 2.0 * m*(n - center1.y) - 2.0*center1.x;\n\tfloat c = center1.x*center1.x + (n-center1.y)*(n-center1.y) - r1 * r1;\n\tfloat x1 = (-b + sqrt(b*b-4.0*a*c))/(2.0*a);\n\tfloat y1 = m * x1 + n;\n\tfloat x2 = (-b - sqrt(b*b - 4.0 * a*c)) / (2.0 * a);\n\tfloat y2 = m * x2 + n;\n\n\tvec3 v0 = vec3(center1.x-center2.x,center1.y-center2.y,0.0);\n\tvec3 v1 = vec3(center1.x-x1,center1.y-y1,0.0);\n\tvec3 t = cross(v0, v1);\n\tif ( t.z>= 0.0) {\n\t\treturn vec4(x1,y1,x2,y2);\n\t}\n\treturn vec4(x2,y2,x1,y1);\n\t\t\n}\n\nvec4 DrawCircle(vec2 uv,vec2 center,float aspect,vec4 centerColor,vec4 contourCol) {\n    float alpha = aspect;\n\tfloat angle = CaculateAngle(vec2(1,0),uv-center);\n    float ColorRotateSpeed=10.0;\n\tangle = mod(angle+ColorRotateSpeed*iTime,360.0);\n\tfloat index =floor(angle/20.0);\n\t//alpha = index * alpha;\n\talpha *= abs(0.5-index / 18.0);\n\treturn mix(centerColor,contourCol,alpha);\n}\n\n//return the background color\nvec4 DrawBg(vec2 uv){\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    return vec4(col,1.0);\n}\n\n//draw the shape of Descrates\nvec4 DrawDescrates(vec2 uv){\n    float aspect=iResolution.x/iResolution.y;\n    \n    float RotateSpeed=4.0;\n    float angle = RotateSpeed * iTime;\n    float ScaleChangeSpeed=1.5;\n\tfloat scale = 0.1*(sin(ScaleChangeSpeed*iTime));\n    float CenterX=0.5;\n    float CenterY=0.5;\n\tvec2 center = vec2(CenterX,CenterY);\n    center.x*=aspect;\n\tfloat radius = 0.5;\n\tfloat R[5];\n\tvec2 CircleCenter[5];\n\t//ËÆ°ÁÆóÂêÑ‰∏™ÂúÜÁöÑÂçäÂæÑÂèäÂúÜÂøÉ\n\tint Amount = 5;\n\tR[0] = radius;\n\tCircleCenter[0] = vec2(CenterX, CenterY);\n    CircleCenter[0].x*=aspect;\n\n    float radius2=0.35;\n\tR[1] = radius2+scale;\n\t//CircleCenter[1].x = CircleCenter[0].x - (R[0] - R[1]);\n\t//CircleCenter[1].y = CircleCenter[0].y;\n\tCircleCenter[1].x = CircleCenter[0].x - (R[0] - R[1])*cos(angle);\n\tCircleCenter[1].y = CircleCenter[0].y + (R[0] - R[1])*sin(angle);\n\t\t\n\tR[2] = R[0] - R[1]-0.0001;\n\tfloat l = (R[0]-R[1]) / (R[1]+R[2]);\n\tCircleCenter[2] = CircleCenter[1]-(1.0/l)*(CircleCenter[1]-CircleCenter[0]);\n\n\tvec4 CenterColor = vec4(0.7,0.9,0.9,1.0);\n\tvec4 ContourColor = vec4(0.8,0,0.4,1.0);\n\n\tvec4 centerColor;\n    vec4 contourColor;\n\t//Á¨¨‰∏Ä‰∏™ÂÜÖÂúÜ\n\tfloat flag = IsInCircle(uv, CircleCenter[1], R[1]);\n\tif (flag >= 0.0) {\n\t\tcenterColor = mix(CenterColor, ContourColor, 0.7);\n\t\tcontourColor = mix(ContourColor, CenterColor, 0.7);\n\t\treturn DrawCircle(uv, CircleCenter[1],flag, centerColor, contourColor);\n\t}\n\t//Á¨¨‰∫å‰∏™ÂÜÖÂúÜ\n\tflag = IsInCircle(uv, CircleCenter[2], R[2]);\n\tif (flag >= 0.0) {\n\t\tcenterColor = mix(CenterColor, ContourColor, 0.3);\n\t\tcontourColor = mix(ContourColor, CenterColor, 0.3);\n\t\treturn DrawCircle(uv, CircleCenter[2],flag, centerColor, contourColor);\n\t}\n\n\t//Á¨¨‰∏â‰∏™ÂÜÖÂúÜ\n\tfloat r = CalculateRadius(R[1], R[2], R[0]);\n\n\tif (r < 0.0) {\n\t\treturn vec4(0, 0, 0, 1);\n\t}\n\n\tvec4 center4 = CaculateFourthCircleCenter(CircleCenter[1], CircleCenter[2], R[1] + r, R[2] + r);\n\t//center4.x*=aspect;\n    //center4.z*=aspect;\n    //float2 center4 = CaculateFourthCircleCenter(CircleCenter[0],float2(0.35,0.5), float2(0.85, 0.5), R[0], R[1] + r, R[2] + r);\n\tflag = IsInCircle(uv, center4.xy, r);\n\tif (flag >= 0.0) {\n\t\t//return fixed4(0,0,0,1);\n\t\tcenterColor = mix(CenterColor, ContourColor, 0.4);\n\t\tcontourColor = mix(ContourColor, CenterColor, 0.4);\n\t\treturn DrawCircle(uv, center4.xy,flag, centerColor, contourColor);\n\t}\n\t\tflag = IsInCircle(uv, center4.zw, r);\n\t\tif (flag >= 0.0) {\n\t\t\t//return fixed4(0,0,0,1);\n\t\t\tcenterColor = mix(CenterColor, ContourColor, 0.4);\n\t\t\tcontourColor = mix(ContourColor, CenterColor, 0.4);\n\t\t\treturn DrawCircle(uv, center4.zw,flag, centerColor, contourColor);\n\t\t}\n\n\t\tCircleCenter[3] = center4.xy;\n\t\tR[3] = r;\n\n\t\tCircleCenter[4] = center4.zw;\n\t\tR[4] = r;\n\n\t\tint amount = 6;\n\t\tfor (int j = 0; j < amount; j++) {\n\t\t\tr = CalculateRadius(R[1],R[3],R[0]);\n\t\t\tcenter4 = CaculateFourthCircleCenter(CircleCenter[1], CircleCenter[3], R[1] + r, R[3] + r);\n\t\t\tflag = IsInCircle(uv, center4.xy, r);\n\t\t\tif (flag >= 0.0) {\n\t\t\t\t//return fixed4(1,1,1,1);\n\t\t\t\tcenterColor = mix(CenterColor, ContourColor, 0.5+float(j)*0.1);\n\t\t\t\tcontourColor = mix(ContourColor, CenterColor, 0.5+float(j)*0.1);\n\t\t\t\treturn DrawCircle(uv, center4.xy,flag, centerColor, contourColor);\n\t\t\t}\n\t\t\tCircleCenter[3] = center4.xy;\n\t\t\tR[3] = r;\n\t\t}\n\n\t\tfor (int j = 0; j < amount; j++) {\n\t\t\tr = CalculateRadius(R[1], R[4], R[0]);\n\t\t\tcenter4 = CaculateFourthCircleCenter(CircleCenter[1], CircleCenter[4], R[1] + r, R[4] + r);\n\t\t\tflag = IsInCircle(uv, center4.zw, r);\n\t\t\tif (flag >= 0.0) {\n\t\t\t\t//return fixed4(0,0,0,1);\n\t\t\t\tcenterColor = mix(CenterColor, ContourColor, 0.5 + float(j) * 0.1);\n\t\t\t\tcontourColor = mix(ContourColor, CenterColor, 0.5 + float(j) * 0.1);\n\t\t\t\treturn DrawCircle(uv, center4.zw,flag, centerColor, contourColor);\n\t\t\t}\n\t\t\tCircleCenter[4] = center4.zw;\n\t\t\tR[4] = r;\n\t\t}\n\t\t\n\t\t//contourColor=vec4(0.7,0.9,0.9,1);\n\t\tflag = IsInCircle(uv, CircleCenter[0], R[0]);\n\t\tif (flag >= 0.0) {\n\t\t\tcenterColor = mix(CenterColor, ContourColor, 0.0);\n\t\t\tcontourColor = mix(ContourColor, CenterColor, 0.0);\n\t\t\treturn DrawCircle(uv, CircleCenter[0],flag, centerColor, contourColor);\n\t\t}\n\n\t\treturn DrawBg(uv);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect=iResolution.x/iResolution.y;\n    uv.x=uv.x*aspect;\n\n   fragColor=DrawDescrates(uv);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtKBDD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtKBDz", "name": "Concentric Rainbow Circles", "author": "jangxx", "description": "Concentric rainbow colored circles. Port from another project. Based on a gif I can't find anymore.", "tags": ["circles", "color", "rainbow"], "likes": 9, "viewed": 198, "date": "1542233636", "time_retrieved": "2024-06-20T19:25:22.307357", "image_code": "#define PI 3.14159265359\n\nfloat gradientFn(in float x, in float low, in float high, in float target) {\n    float b = ((low * target) - high) / (low - high);\n    float m = (1.0 - b) / low;\n    return m*x + b;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n   \n    float aspect = iResolution.x / iResolution.y;\n    \n    vec2 pos = (uv * 2.0) - vec2(1, 1);\n    pos.x *= aspect;\n    \n    float radius = length(pos);\n\n    float x = radius*1.0 - iTime/4.0;\n    float ringColor = mod(x, 1.0) * 10.0;\n\n    vec3 finalColor;\n    if (ringColor < 1.0) {\n        finalColor = vec3(230,0,63) / 255.0;\n    } else if (ringColor < 2.0) {\n        finalColor = vec3(255,0,0) / 255.0;\n    } else if (ringColor < 3.0) {\n        finalColor = vec3(255,81,0) / 255.0;\n    } else if (ringColor < 4.0) {\n        finalColor = vec3(255,138,0) / 255.0;\n    } else if (ringColor < 5.0) {\n        finalColor = vec3(255,189,0) / 255.0;\n    } else if (ringColor < 6.0) {\n        finalColor = vec3(241,236,0) / 255.0;\n    } else if (ringColor < 7.0) {\n        finalColor = vec3(0,245,138) / 255.0;\n    } else if (ringColor < 8.0) {\n        finalColor = vec3(0,206,190) / 255.0;\n    } else if (ringColor < 9.0) {\n        finalColor = vec3(0,118,252) / 255.0;\n    } else if (ringColor < 10.0) {\n        finalColor = vec3(140,24,195) / 255.0;\n    }\n\n    float gradient = mod(ringColor, 1.0);\n    if (gradient > 0.6) {\n        finalColor *= gradientFn(gradient, 0.6, 1.0, 0.3);\n    }\n\n    fragColor = vec4(finalColor, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtKBDz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtKBzG", "name": "3d Glass with caustic modified", "author": "tholzer", "description": "Slightly modified version of [url]https://www.shadertoy.com/view/4lB3D1[/url] originally created by andregc.", "tags": ["raytracing", "raymarching", "reflection", "refraction", "glass", "caustic"], "likes": 13, "viewed": 381, "date": "1542971470", "time_retrieved": "2024-06-20T19:25:24.228736", "image_code": "\n//---------------------------------------------------------\n// Shader:   3dGlassWithCaustic.glsl   2018-11-23\n//\n// original: https://www.shadertoy.com/view/XljGWR by andregc\n//\n// Distance function, camera setup and base for raymarching\n//           https://www.shadertoy.com/view/Xds3zN by IQ\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//---------------------------------------------------------\n\n#define calcRecursion rec3  // use n rays levels (rays1 to rays6): total  RAY_COUNT = 2^n-1\n\n#define DIST_EPSILON 0.005\n\n#define ID_SKY 2.001\n#define ID_FLOOR 1.\n#define ID_LIGHT 1.001\n#define ID_GLASS_WALL 2.000\n#define ETA 0.85\n#define PI 3.14159265359\n\n#define DENSITY_MIN 0.1\n#define DENSITY_MAX 0.1\n#define MATERIAL_COLOR vec3(0.05, 0.08, 0.1)\n#define AIR_COLOR vec3(0.2, 0.3, 0.5)\n\n//#define GLASS_1_COLOR vec3(0.8,0.2,0.6)\n#define GLASS_1_COLOR vec3(1.2, 1., 0.8)*(1.-0.2* mod( floor(5.0*p.z) + floor(5.1*p.x) + floor(5.1*p.y), 2.0))\n//#define GLASS_1_COLOR vec3(0.8,1.,0.8)*(0.6+0.4*noise(p.xz*30. + p.yz*23.))\n\nvec3 LIGHT_DIR = normalize(vec3(-0.6,0.7,-0.3));\n//-------------------------------------------------------------------------------\n\nfloat rand(vec2 n) { return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453); }\n\nfloat noise(vec2 n) {\n\tconst vec2 d = vec2(0.0, 1.0);\n\tvec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nstruct HitData {\n    float dist;\n    vec3 normal;\n    float mat;\n    vec3 p;\n};\n\nstruct Ray {\n    vec3 rd;\n    HitData hit;\n    vec3 col;\n    float share;\n    float eta;\n};\n\n//-------------------------------------------------------------------------------\n// primitives:  https://www.shadertoy.com/view/Xds3zN\n// info: http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n//-------------------------------------------------------------------------------\nfloat sdPlane( vec3 p ) {return p.y;}\n\nfloat sdSphere( vec3 p, float radius) {return (length(p)-radius);}\n\n// Rounded Cylinder: ra=radius, rb=roundingRadius, h=height\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n// Box - exact: b=dimension\nfloat sdBox (vec3 p, vec3 b)\n{\n  vec3 d = abs(p) - b;\n  return (min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)));\n}\n\n// Rounded Box: b=dimension, r=roundingRadius\nfloat sdRoundedBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) - r + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\n// rounded box: b=size, r=roundingRadius\nfloat roundedBox (vec3 p, vec3 b, float r) { return abs(length(max(abs(p)-b,0.0))-r); }\n\nfloat sdTorus (vec3 p, vec2 t) {return length(vec2(length(p.xz)-t.x,p.y))-t.y;}\n\nfloat sdCone (vec3 p, vec2 c) {return dot(c, vec2(length(p.xz),p.y));}   // c must be normalized\n\n//---------\nvec3 opU (vec3 d1, vec3 d2) { return (d1.x < d2.x) ? d1 : d2; }  // union\n\nvec3 opS (vec3 d1, vec3 d2) { return -d1.x > d2.x  ? d2 : d1; }  // subtraction\n\n//---------\nmat2 rotation(float angle) \n{\n    float c = cos(angle), s = sin(angle);\n    return mat2(c, s, -s, c);\n}\n\n//-------------------------------------------------------------------------------\nvec3 map(in vec3 pos)\n{\n  vec3 res = vec3(sdPlane(pos), ID_FLOOR, -1. );\n\n  res = opU(res, vec3((sdRoundedCylinder (pos-vec3(0.5,0.5,-0.2), 0.15, 0.05, 0.4)), ID_GLASS_WALL, ETA));\n\n  res = opU(res, vec3(sdSphere (pos-vec3(-0.2,0.31,0.4),0.2+0.1*sin(iTime)),ID_GLASS_WALL, ETA));\n\n  res = opU(res, vec3((sdCone  (pos-vec3(-0.7,0.49,-0.2), vec2(0.4,0.3))), ID_GLASS_WALL, ETA));\n\n  mat2 rot1 = rotation(iTime*1.2);  vec3 pr = pos.yxz - vec3(0.4,-0.1,-0.7);\n  pr.yz *= rot1;\n  pr.xy *= rot1;\n  pr.xz *= rot1;\n  res = opU(res, vec3(sdTorus      (pr, vec2(0.3,0.1)),ID_GLASS_WALL, ETA));\n\n  res = opU(res, vec3(sdRoundedBox (pos-vec3(0.8,0.4,0.5), vec3(0.14), 0.06+0.02*sin(iTime)),ID_GLASS_WALL, ETA));\n\n  res.x = abs(res.x);\n  return res;\n}\n//-------------------------------------------------------------------------------\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.0001, 0.0, 0.0 );\n    float d = map(pos).x;\n    return normalize( vec3(\n\t    map(pos+eps.xyy).x - d,\n\t    map(pos+eps.yxy).x - d,\n\t    map(pos+eps.yyx).x - d));\n}\n\nHitData findIntersection(vec3 p, vec3 rd)\n{\n    float tmin = 0.000;\n    float tmax = 50.0;\n\n    float precis = DIST_EPSILON;\n    float t = tmin;\n    float eta = -1.;\n    vec3 res;\n    for( int i=0; i<50; i++ )\n    {\n\t  \tres = map(p+rd*t);\n        eta = res.z;\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n    }\n\n    p += rd*t;\n    // calculate normal in the father point to avoid artifacts\n    vec3 n = calcNormal(p-rd*(precis-res.x));\n    return HitData(t, n, res.y, p);\n}\n\n//-------------------------------------------------------------------------------\nvec3 refractCaustic(vec3 p, vec3 rd, vec3 ld, float eta)\n{\n    vec3 cl = vec3(1);\n    for(int j = 0; j < 2; ++j)\n    {\n        HitData cp = findIntersection(p, rd);\n        if (length(cp.p) > 2.) {\n            break;\n        }\n        cl *= GLASS_1_COLOR;//*(abs(dot(rd, cp.normal)));\n        vec3 normal = sign(dot(rd, cp.normal))*cp.normal;\n        rd = refract(rd, -normal, eta);\n\n        p = cp.p;\n        eta = 1./eta;\n        p += normal*DIST_EPSILON*2.;\n    }\n    float d = clamp( dot( rd, ld ), 0.0, 1.0 );\n    return smoothstep(0.99, 1., d)*cl;\n}\n\nvec3 caustic(vec3 p,vec3 ld, Ray ray)\n{\n    vec3 VX = normalize(cross(ld, vec3(0,1,0)));\n    vec3 VY = normalize(cross(ld, VX));\n    vec3 c = vec3(0);\n\n    const int N = 3;\n    p += ray.hit.normal*DIST_EPSILON;\n\n    for(int i = 0; i < N;++i) {\n\n        float n1 = rand(p.xz*10. + vec2(iTime*2. +float(i)*123.));\n        float n2 = rand(p.xz*15. +vec2(iTime*3. +float(i)*111.));\n\n        vec3 rd = ld + (VX*(n1-0.5)+VY*(n2-0.5))*0.1;\n     // rd = ld;\n        rd = normalize(rd);\n\n        vec3 cl = refractCaustic(p, rd, ld, ray.eta);\n\n      \tc += cl* dot(rd,ray.hit.normal);\n    }\n    return c*3./float(N);\n}\n\n// lightning is based on https://www.shadertoy.com/view/Xds3zN\nvec3 getFloorColor(in Ray ray)\n{\n    vec3 col = vec3(0);\n    vec3 pos = ray.hit.p;\n    vec3 ref = reflect( ray.rd, ray.hit.normal );\n\n    float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n    col = 0.4 + 0.1*f*vec3(1.0);\n\n    float dif = clamp( dot( ray.hit.normal, LIGHT_DIR ), 0.0, 1.0 );\n    vec3 brdf = vec3(0.0);\n    brdf += caustic(pos, LIGHT_DIR, ray);\n    brdf += 1.20*dif*vec3(1.00,0.90,0.60);\n    col = col*brdf;\n    // exclude branching\n    col *= (ID_GLASS_WALL-ray.hit.mat);\n\n    return col;\n}\n\nvec3 getColor(in Ray ray)\n{\n    vec3 p = ray.hit.p ;// can be used by SURFACE_COLOR define\n    vec3 c1 = ray.col * GLASS_1_COLOR;\n    vec3 c2 = getFloorColor(ray);\n    // exclude branching\n    return mix(c2, c1, ray.hit.mat - ID_FLOOR);\n}\n\n//-------------------------------------------------------------------------------\nvec3 getRayColor(Ray ray)\n{\n    float d = mix(DENSITY_MIN, DENSITY_MAX, (ray.eta - ETA)/(1./ETA-ETA));\n    vec3 matColor = mix(AIR_COLOR, MATERIAL_COLOR, (ray.eta - ETA)/(1./ETA-ETA));\n    vec3 col = getColor(ray);\n\n    float q = exp(-d*ray.hit.dist);\n    col = col*q+matColor*(1.-q);\n    return col*ray.share;\n}\n\nvoid getRays(inout Ray ray, out Ray r1, out Ray r2) {\n     vec3 p = ray.hit.p;\n    float cs = dot(ray.hit.normal, ray.rd);\n    // simple approximation\n    float fresnel = 1.0-abs(cs);\n//\tfresnel = mix(0.1, 1., 1.0-abs(cs));\n    float r = ray.hit.mat - ID_FLOOR;\n     vec3 normal = sign(cs)*ray.hit.normal;\n    vec3 refr = refract(ray.rd, -normal, ray.eta);\n    vec3 refl = reflect(ray.rd, ray.hit.normal);\n    vec3 z = normal*DIST_EPSILON*2.;\n    p += z;\n    r1 = Ray(refr, findIntersection(p, refr),  vec3(0),(1.-fresnel)*r, 1./ray.eta);\n    p -= 2.*z;\n    r2 = Ray( refl, findIntersection(p, refl), vec3(0),r*fresnel, ray.eta);\n}\n\n// set of \"recursion\" functions\n\nvoid rec1(inout Ray ray)\n{\n    ray.col += getRayColor(ray);\n}\n\n\nvoid rec2(inout Ray ray)\n{\n    Ray r1,r2;\n    getRays(ray, r1, r2);\n    ray.col += getRayColor(r1);\n    ray.col += getRayColor(r2);\n}\n\nvoid rec3(inout Ray ray)\n{\n    Ray r1,r2;\n    getRays(ray, r1, r2);\n    rec2(r1);\n    ray.col += getRayColor(r1);\n    // use first level of reflection rays only to improve performance\n    rec1(r2);\n    ray.col += getRayColor(r2);\n}\n\nvoid rec4(inout Ray ray)\n{\n    Ray r1,r2;\n    getRays(ray, r1, r2);\n    rec3(r1);\n    ray.col += getRayColor(r1);\n    // use first level of reflection rays only to improve performance\n    rec1(r2);\n    ray.col += getRayColor(r2);\n}\n\nvoid rec5(inout Ray ray)\n{\n    Ray r1,r2;\n    getRays(ray, r1, r2);\n    rec4(r1);\n    ray.col += getRayColor(r1);\n    // use first level of reflection rays only to improve performance\n    rec1(r2);\n    ray.col += getRayColor(r2);\n}\n\nvoid rec6(inout Ray ray)\n{\n    Ray r1,r2;\n    getRays(ray, r1, r2);\n    rec5(r1);\n    ray.col += getRayColor(r1);\n    // use only first level of reflection to improve performance\n    rec1(r2);\n    ray.col += getRayColor(r2);\n}\n\nvec3 render(vec3 p, vec3 rd)\n{\n    HitData hit = findIntersection(p, rd);\n    Ray ray = Ray( rd, hit, vec3(0), 1., ETA);\n    calcRecursion(ray);\n    ray.col = getRayColor(ray);\n    return ray.col;\n}\n\n// https://www.shadertoy.com/view/Xds3zN\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr),0.0);\n  vec3 cu = normalize( cross(cw,cp) );\n  vec3 cv = normalize( cross(cu,cw) );\n  return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord.xy / iResolution.xy-0.5;\n    uv.x *= iResolution.x/iResolution.y;\n  vec2 mo = iMouse.xy/iResolution.xy;\n  // this strange construction is used to define initial view angle\n  mo = mix(vec2(0.6,0.3),mo, sign(mo.x+mo.y));\n  mo.y += 0.02;\n  mo.y *= 1.5;\n  float rotTime = sin(iTime*0.04);\n  mo.x *= 10.;\n  float R = 4.3;   // view distance\n  float Y = sin(mo.y);\n  float X = cos(mo.y);  // ro = ray origin\n  vec3 ro = vec3(cos(rotTime + mo.x)*X, Y, X*sin(rotTime + mo.x) )*R;\n  vec3 ta = vec3( 0,0.4,0);\n\n  // camera-to-world transformation\n  mat3 ca = setCamera( ro, ta, 0. );\n  vec3 rd = ca * normalize( vec3(uv.xy,2.5) ); // ray direction\n\n  // get raymarching color\n  vec3 c = render(ro, rd);\n\n  fragColor = vec4(c, 1);\n}\n", "image_inputs": [{"id": "MlB3zD", "previewfilepath": "https://soundcloud.com/bestmusicingames/plains-the-chinese-orchestra-mix-shadow-of-the-beast-2015-remix-album", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/bestmusicingames/plains-the-chinese-orchestra-mix-shadow-of-the-beast-2015-remix-album", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtKBzG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtKBzz", "name": "[twitch] Refractive Block", "author": "yx", "description": "Coded live on twitch stream in Bonzomatic, and tidied/ported to shadertoy.\nUnedited Bonzomatic shader here: [url]https://gist.github.com/willkirkby/3136d71da8a9315748cf2e8359b7b722[/url]", "tags": ["refraction", "twitch"], "likes": 9, "viewed": 475, "date": "1541631803", "time_retrieved": "2024-06-20T19:25:24.234950", "image_code": "vec2 rotate(vec2 a, float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x * c - a.y * s,\n        a.x * s + a.y * c\n    );\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sdBeveledBox(vec3 p, vec3 r, float R)\n{\n    float a = sdBox(p,r);\n    p=abs(p);\n    float b = (p.x + p.y - r.x - r.y + R) / sqrt(2.);\n    float c = (p.y + p.z - r.y - r.z + R) / sqrt(2.);\n    float d = (p.z + p.x - r.z - r.x + R) / sqrt(2.);\n    float e = (p.x + p.y + p.z - r.x - r.y - r.z + R + R) / sqrt(3.);\n    return max(max(max(a,b),max(c,d)),e);\n}\n\nfloat sdCylinder(vec3 p, float r)\n{\n    return length(p.zy)-r;\n}\n\nfloat sdCappedCylinder(vec3 p, float r, float h)\n{\n    return max(sdCylinder(p,r),abs(p.x)-h);\n}\n\nfloat scene(vec3 p)\n{\n    float box = sdBeveledBox(p, vec3(1.), .1);\n    p.xz=abs(p.xz);\n    p.xz=vec2(max(p.x,p.z),min(p.x,p.z));\n    float a = sdBeveledBox(p-vec3(0,.25,0), vec3(1.1,.5,.2), .1);\n    float b = sdBeveledBox(p+vec3(0,.6,0), vec3(1.1,.15,.2), .1);\n    p.y=abs(p.y);\n    float indent = sdBeveledBox(p-vec3(1.06,.7,.7),vec3(.1),.05);\n    indent = sdCappedCylinder(p-vec3(1.06,.7,.7),.07,.1);\n    return max(min(box,max(min(a,b),p.x-1.05)),-indent);\n}\n\nfloat scene2(vec3 p)\n{\n    return -(length(p)-7.);\n    return -sdBox(p, vec3(7.));\n}\n\nfloat CAMERA_ELEVATION = 0.4;\nfloat SPIN_RATE = .3;\n#define REFRACTIVITY (sin(iTime*.5)*.5+.5)\n\nvoid cameraSpin(inout vec3 p)\n{\n    p.yz = rotate(p.yz, CAMERA_ELEVATION);\n    p.xz = rotate(p.xz, iTime*SPIN_RATE);\n}\n\nvoid cameraSpinBackwards(inout vec3 p)\n{\n    p.xz = rotate(p.xz, -iTime*SPIN_RATE);\n    p.yz = rotate(p.yz, -CAMERA_ELEVATION);\n}\n\nvec3 background(vec2 uv)\n{\n    vec3 cam = vec3(0,0,-5);\n    vec3 dir = normalize(vec3(uv,1));\n\n    float t=0.;\n    float k=0.;\n    for(int i=0;i<10;++i)\n    {\n        k = scene2(cam+dir*t);\n        t+=k;\n        if (k<.001)\n            break;\n    }\n    vec3 h = cam+dir*t;\n\n    float T = length(sin(h*2.))/sqrt(3.);\n    T=fract(T+iTime*.05);\n    T=step(.5,T);\n    vec3 color = vec3(.9)+T*.1-.2;\n    color -= smoothstep(0.,1.,length(uv))*.5;\n    return color;\n}\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 cam = vec3(0,0,-10);\n    vec3 dir = normalize(vec3(uv,2.5));\n    vec3 fwd = vec3(0,0,1);\n\n    cameraSpin(cam);\n    cameraSpin(dir);\n    cameraSpin(fwd);\n\n    float t=0.;\n    float k=0.;\n    for(int i=0;i<100;++i)\n    {\n        k = scene(cam+dir*t);\n        t+=k;\n        if (k<.001)\n            break;\n    }\n    vec3 h = cam+dir*t;\n    vec2 o = vec2(.001, 0);\n    vec3 worldNormal = normalize(vec3(\n        scene(h+o.xyy)-scene(h-o.xyy),\n        scene(h+o.yxy)-scene(h-o.yxy),\n        scene(h+o.yyx)-scene(h-o.yyx)\n    ));\n    vec3 eyeNormal = worldNormal;\n    cameraSpinBackwards(eyeNormal);\n\n    vec3 specular = vec3(0);\n\n    if (k < .001)\n    {\n        uv += reflect(vec3(0,0,1),eyeNormal).xy * REFRACTIVITY * .3;\n        specular += pow(1.-max(0.,dot(-dir,worldNormal)),5.) * REFRACTIVITY * .5;\n    }\n\n    out_color.rgb = background(uv) + specular;\n    out_color.rgb = pow(out_color.rgb, vec3(1.2,1.1,1.0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtKBzz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtKfRG", "name": "2Tweet Caustics, #define-less", "author": "jeremyabel", "description": "Wanted to try this in Unreal Engine, so I formatted it in a way that was suitable for use in UE's material editor.\nOriginal is David Hoskins's: https://www.shadertoy.com/view/MdKXDm", "tags": ["2d", "water", "caustics"], "likes": 23, "viewed": 552, "date": "1542956933", "time_retrieved": "2024-06-20T19:25:24.562067", "image_code": "// #define-less version of David Hoskins' two-tweet caustics effect,\n// suitable for use as a custom HLSL expression within Unreal Engine's\n// material editor.\n//\n// cleaner golf'd version by FabriceNeyret2\n//\n// ORIGINAL: https://www.shadertoy.com/view/MdKXDm\n//\n// A simple, if a little square, water caustic effect.\n// David Hoskins.\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Inspired by akohdr's \"Fluid Fields\"\n// https://www.shadertoy.com/view/XsVSDm\n\nvoid mainImage(out vec4 k, vec2 p)\n{\n    mat3 m = mat3(-2,-1,2, 3,-2,1, 1,2,2);\n    vec3 a = vec3( p / 4e2, iTime / 4. ) * m,\n         b = a * m * .4,\n         c = b * m * .3;\n    k = vec4(pow(\n          min(min(   length(.5 - fract(a)), \n                     length(.5 - fract(b))\n                  ), length(.5 - fract(c)\n             )), 7.) * 25.);\n}\n\n\n/* UE4 Custom HLSL Material Expression: \n\nInput: k, where k.xy is texcoord, k.z is time\n\nfloat3x3 m = float3x3(-2,-1,2, 3,-2,1, 1,2,2);\nfloat3 a = mul(k, m) * 0.5;\nfloat3 b = mul(a, m) * 0.4;\nfloat3 c = mul(b, m) * 0.3;\nreturn pow(min(min(length(0.5 - frac(a)), length(0.5 - frac(b))), length(0.5 - frac(c))), 7) * 25.;\n\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtKfRG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtKfWD", "name": "Tiles dots", "author": "Polytope", "description": "Playing around with tile effect, from https://thebookofshaders.com/09/", "tags": ["test", "tile"], "likes": 6, "viewed": 116, "date": "1542601932", "time_retrieved": "2024-06-20T19:25:24.562067", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xx;\n    uv *= 18.;\n    \n    uv.y += (1.-step(1.,mod(iTime,2.)))*iTime*step(1.,mod(uv.x,2.));\n    uv.y -= (1.-step(1.,mod(iTime,2.)))*iTime*(1.-step(1.,mod(uv.x,2.)));\n    \n    uv.x += (step(1.,mod(iTime,2.)))*iTime*step(1.,mod(uv.y,2.));\n    uv.x -= (step(1.,mod(iTime,2.)))*iTime*(1.-step(1.,mod(uv.y,2.)));\n    \n    vec2 f_uv = fract(uv);\n    \n    float c = smoothstep(.24,.25,length(vec2(.5)-f_uv));\n    \n    vec3 col = vec3(c);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtKfWD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtKfWW", "name": "Dodecahedron From Three Planes", "author": "yx", "description": "Playing with cheap distance functions.", "tags": ["sdf"], "likes": 8, "viewed": 611, "date": "1542567554", "time_retrieved": "2024-06-20T19:25:24.562067", "image_code": "const float pi = acos(-1.);\nconst float phi = (1.+sqrt(5.))*.5;\n\nvec2 rotate(vec2 a, float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x * c - a.y * s,\n        a.x * s + a.y * c\n    );\n}\n\nfloat scene(vec3 p)\n{\n    const vec3 n = normalize(vec3(phi,1,0));\n\n    p = abs(p);\n\tfloat a = dot(p,n.xyz);\n    float b = dot(p,n.zxy);\n    float c = dot(p,n.yzx);\n    return max(max(a,b),c)-phi*n.y;\n}\n\nvec3 trace(vec3 cam, vec3 dir)\n{\n    vec3 accum = vec3(1);\n    for(int bounce=0;bounce<3;++bounce)\n    {\n        float t;\n        float k;\n        for(int i=0;i<100;++i)\n        {\n            k = scene(cam+dir*t);\n            t += k;\n            if (k < .001 || k > 10.)\n                break;\n        }\n\n        vec3 h = cam+dir*t;\n        vec2 o = vec2(.001, 0);\n        vec3 n = normalize(vec3(\n            scene(h+o.xyy)-scene(h-o.xyy),\n            scene(h+o.yxy)-scene(h-o.yxy),\n            scene(h+o.yyx)-scene(h-o.yyx)\n        ));\n\n        if (k > 10.)\n        {\n            return vec3(1);\n        }\n        else if (iMouse.z > 0.)\n        {\n            return n*.5+.5;\n        }\n        else\n        {\n            float A = .1;\n            float B = scene(h+n*A);\n            float fakeAO = clamp(B/A,0.,1.);\n            fakeAO = pow(fakeAO,.6)*.2+.8;\n\n            float light = dot(n,normalize(vec3(1,4,2)))*.5+.5;\n\n            vec3 color = vec3(.9);\n\n            return pow(light * fakeAO * accum * color, vec3(.4545));\n        }\n    }\n    return vec3(0);\n}\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy-.5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 cam = vec3(uv*3.,-5.);\n    vec3 dir = vec3(0,0,1);\n\n    cam.yz = rotate(cam.yz, .5);\n    dir.yz = rotate(dir.yz, .5);\n\n    cam.xz = rotate(cam.xz, iTime*.2);\n    dir.xz = rotate(dir.xz, iTime*.2);\n\n    out_color.rgb = trace(cam,dir);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtKfWW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XttBDX", "name": "try sphere volumetric pro", "author": "cailuming", "description": "I want to make some bloom eft but failed, anyway, I love this try ", "tags": ["skyvolumetric"], "likes": 6, "viewed": 567, "date": "1541952023", "time_retrieved": "2024-06-20T19:25:24.562067", "image_code": "#define PI 3.1415926\n#define MAXIT  256.\n\nstruct Ray {\n   vec3  o;\n   vec3  d;\n};\n    \nmat2 rot2D(float a){\n    float c = cos(a);\n    float s = sin(a);\n    \n    return mat2(c,-s,s,c);\n}\n\n\nvec3 getCol(float v){\n    float r = cos((v-0.75)*PI*1.5);\n    float g = cos((v-0.55)*PI*1.5);\n    float b = cos((v-0.25)*PI*1.5);\n    \n    return vec3(r,g,b);\n}    \n\n\nvoid drawStars(inout vec3 col,vec2 uv,vec2 c){\n   uv-=c;\n    \n   uv*=2.8;\n   \n   float l =length(uv);\n   float arc = atan(uv.y,uv.x); \n     \n   float d = abs(dot(vec2(0,1),uv));\n   float d1 = abs(dot(vec2(1,0),uv));\n   float ctv = c.x*10.0;\n   // clip the star\n   d+=pow(l,1.1+0.6*cos(iTime*2.0+ctv));\n   d1+=pow(l,1.1+0.6*cos(iTime*2.0+ctv));\n   \n   float v =0.0005/l;  \n   // blend the star\n   v+=0.01/(d);\n   v+=0.01/(d1);\n   v=pow(v,1.6);\n    \n   col+=vec3(cos(iTime+ctv)*0.1+0.5,sin(iTime+ctv)*0.4+0.5,sin(iTime)*0.3+0.7)*v;\n}\n\nvoid drawStarGroup(inout vec3 col,vec2 uv,float starNum){\n    for (float i=0.0;i<starNum;i++){\n        drawStars(col,uv,vec2(i*0.1*sin(i),cos(i)*0.3));\n    }\n}\n\nvoid drawMeteor(inout vec3 col, in vec2 uv,vec2 startP,vec2 endP,float linWidth){\n \n   uv*=3.0;\n   vec2 lineDir=endP-startP;\n   vec2 fragDir=uv-startP;\n   \n   // keep the line coefficient bewteen [0,1] so that the projective dir on the \n   // lineDir will not exceed or we couldn't get a line segment but a line.\n   float lineCoe=clamp(dot(lineDir,fragDir)/dot(lineDir,lineDir),0.,1.0);\n                       \n   vec2 projDir=lineCoe*lineDir;\n    \n   vec2 fragToLineDir= fragDir- projDir;\n    \n   float dis=length(fragToLineDir);\n   float disToTail = length(projDir);\n   dis=linWidth/dis;\n     \n   col += vec3(dis*0.2,dis*0.6,0.8*dis)*pow(disToTail,3.0);\n    \n}\n \nvoid drawMeteors(inout vec3 col,vec2 uv){\n    vec2 starPosBegin = vec2(0.5,0.4);\n    vec2 starPosEnd = vec2(-0.5,-0.1);\n    vec2 starDir = normalize(starPosEnd-starPosBegin);\n    float trackC = 16.*cos(mod(-iTime*0.5,PI));\n    vec2 starCoe = starDir*trackC*2.0;\n    \n    drawMeteor(col,uv,starPosBegin+starCoe,starPosEnd+starCoe,0.03);\n\n}\n \nvec3 grad2D(vec3 p){\n   float arch = atan(p.z,p.x); \n   float lnc = length(texture(iChannel0,vec2(arch,p.y)));\n   float offx = length(texture(iChannel0,vec2(atan(p.z,p.x+0.0001),p.y)));\n   float offy = length(texture(iChannel0,vec2(arch,p.y+0.0001)));\n    \n   return normalize(vec3(offx-lnc,offy-lnc,0.1)); \n}\nvoid setCamera(inout Ray r,vec3 eye,vec3 tar,vec2 uv){\n   vec3 look = normalize(tar-eye);\n   vec3 right = normalize(cross(vec3(0,1,0),look));\n   vec3 up = normalize(cross(look,right)); \n   \n   r.o = eye;\n   r.d = normalize(uv.x*right+uv.y*up+look);\n}\n \nvoid sphereVolume(inout vec3 col,inout Ray r,vec3 lp,vec3 lp1,vec2 uv){\n   \n   \n   vec3 p   = r.o+r.d;\n   vec3 p1  = p;\n   \n   vec3 c   = vec3(0);\n   vec3 n   = vec3(0);\n   vec3 ld  = vec3(0);\n   vec3 ld1  = vec3(0);\n   \n   float ra   = 2.0; \n   \n   float t =(length(p-c)-ra);\n   float plen = 0.;\n    \n   float atmosv  = 0.;\n   float planetv = 0.;\n   \n   float steps = .01;\n   float nl = 0.;\n   float nl1 = 0.;\n   float li = 0.; \n   vec3 start = r.o+r.d*t;\n    \n   for(float i=0.;i<MAXIT;i++){\n       p= start+r.d*i*0.01;\n       p1=start+r.d*i*0.01;\n       plen = length(p);\n       // draw the planet\n       if(plen<=ra){\n           \n           if(abs(n.x)<=0.){\n              ld  =  normalize(lp-p);\n              ld1  =  normalize(lp1-p);\n               \n              n = normalize(p); \n              nl = smoothstep(0.,1.,dot(ld,n));\n              nl1 =  smoothstep(0.,1.,dot(ld1,n))/(length(lp1)*0.2);\n           }\n           p.xz*=rot2D(iTime*0.2);  \n           \n           if(plen>ra-0.35){\n              atmosv+=steps*(nl+nl1)*0.6;\n              li += smoothstep(-1.,1.,pow(dot(ld,r.d),2.)+1.)*steps;   \n           }else{ \n              planetv=1.;\n              break; \n           }\n               \n       }else if(dot(p,r.o)<0.){\n           break;\n       }  \n        \n   }\n    \n   if(planetv<=0.){\n        drawMeteors(col,uv);\n        drawStarGroup(col,uv,16.); \n   }\n    \n   vec3 ocolor = getCol(1.1-(atmosv+li)*0.3)*atmosv;\n   vec3 pcolor = planetv*texture(iChannel0,vec2(atan(p.z,p.x),p.y)*0.8).xyz;\n   nl+=nl1; \n   col+=smoothstep(0.,1.,(ocolor*(li+nl)+pcolor*nl));\n       \n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 tuv = fragCoord/iResolution.xy;\n    vec2 uv = tuv-vec2(0.5);\n    uv.x*=iResolution.x/iResolution.y;\n   \n    vec3 eye = vec3(0,0,-6);\n    vec3 tar = vec3(0,0,1);\n    vec3 lp  = vec3(20.*cos(iTime*0.4),1,20.*sin(iTime*0.4));\n    vec2  vd = normalize(vec2(-1,-0.5));\n    float trac  = 96.*cos(mod(-iTime*0.5,PI));\n    vec3 lp1  = vec3(1.+vd.x*trac,1.4+vd.y*trac,-20.);\n    \n    vec3 col = vec3(0);\n    \n    Ray r;\n    \n    setCamera(r,eye,tar,uv);\n    \n    sphereVolume(col,r,lp,lp1,uv);\n  \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "4df3Rn", "previewfilepath": "/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XttBDX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XttBW2", "name": "GLSL compiler bug in Safari", "author": "elenzil", "description": "In Safari on MacOS and all browsers on iOS this gets a compile error.\nIt's fine on MacOS Chrome and Firefox, and also in the iOS 'shadertoy' app.\n", "tags": ["glslbug", "safari"], "likes": 2, "viewed": 439, "date": "1541093591", "time_retrieved": "2024-06-20T19:25:24.731913", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int count = 5;\n        \n    // the following line compiles and executes fine\n    // on my Mac in firefox and chrome but in safari results in:\n    // \"Loop-index cannot be compared with non-constant expression\".\n    // the error also occurs on iOS in all browsers,\n    // but not in the 'shadertoy' app.\n    //\n    // presumably this is a bug in Apple's WebView component.\n    for (int n = 0; n < count; ++n) {\n    }\n    \n    // this has nothing to do with the apparent bug,\n    // just something to look at.\n    vec2 uv = 150.0 * (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    float a = 0.0;\n\ta += sin(length(uv) * 0.12 + iTime * 1.0);\n    a += sin(length(uv) * 0.21 - iTime * 1.1);\n    a = a * 0.25 + 0.5;\n    \n    fragColor = vec4(vec3(a), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XttBW2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XttBWf", "name": "CJ vers. - Industrial Complex", "author": "chrisjj", "description": "Shane's https://www.shadertoy.com/view/MtdSWS , simplified.", "tags": ["test"], "likes": 4, "viewed": 198, "date": "1541357736", "time_retrieved": "2024-06-20T19:25:28.083593", "image_code": "// Shane's https://www.shadertoy.com/view/MtdSWS , simplified by CJ.\n\n#define time (iTime/3.)\n\n// Maximum ray distance.\n#define FAR 50. \n\n// Wrap the scene itself around the camera path.\n//#define OBJECT_CAMERA_WRAP \n\n// Warm setting. Commenting it out gives it more of a twilight feel, which I prefer, but\n// fiery stuff tends to stand out more, so that's the default. :)\n#define WARM\n \n\n// Comment this out to omit the detailing. Basically, the function-based bump mapping \n// won't be included. The texture-based bump mapping will remain though.\n//#define SHOW_DETAILS\n\n// 2D rotation. Always handy. Angle vector, courtesy of Fabrice.\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\nfloat objID; // Structure object ID.\nfloat bObjID; // Bump map detail ID.\n\n// Regular Menger Sponge formula. Very simple, but if you're not sure, look it\n// up on Wikipedia, and look up a Void Cube image.\nfloat Menger(vec3 q){\n    \n    objID = 0.;\n    bObjID = 0.;\n    \n    vec3 p;\n\t// Scale factor, and distance.\n    float s = 16., d = 0., d1;\n \n    // Repeat space.\n    p = abs(fract(q/s)*s - s/2.); // Equivalent to: p = abs(mod(q, s) - s/2.);\n    // Repeat Void Cubes. Cubes with a cross taken out.\n    d1 = min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - s/3. + 1.;\n    d = max(d, d1);\n    s /= 4.; // Divide space (each dimension) by 4.\n\n    p = abs(fract(q/s)*s - s/2.); // Equivalent to: p = abs(mod(q, s) - s/2.);\n    // Repeat Void Cubes. Cubes with a cross taken out.\n\n    d1 = min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - s/3.;\n    d = max(d, d1);\n    s /= 3.; // Divide space (each dimension) by 3.\n\n    p = abs(fract(q/s)*s - s/2.); // Equivalent to: p = abs(mod(q, s) - s/2.);\n    // Repeat Void Cubes. Cubes with a cross taken out.\n    d1 = min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - s/3.;\n    bObjID = step(d, d1);\n    d = max(d, d1);\n\n \treturn d;    \n}\n\n// The distance field is a little messier than usual - mainly because it includes more objects, \n// but at it's core, it's just a simple amalgation of repetive objects placed in the scene with \n// repeat space tricks.\n//\n// In essence, it's a lattice with a floor and railings thrown in, and a bit of space taken out.\n// I put it together in a hurry, so could have planned it a bit better. I wanted it to be at least \n// a little readable, so didn't group as much stuff together as I could have. Either way, I'll \n// take a look at it later and tidy things up a bit.\nfloat lattice(vec3 p){\n \n    // Repeat space.\n    vec3 q = abs(mod(p, vec3(32, 16, 32)) - vec3(16, 8, 16));\n    vec3 q2 = abs(mod(p - vec3(4, 0, 0), vec3(32, 2, 16)) - vec3(16, 1, 8));\n    \n    // Holes. I've called them holes, but they're more like square columns used to negate objects.\n    float hole1 = max(q2.x - 7.65, q.z - 8.); // Used to carve a hole beside the railings.\n    float hole2 = max(-p.y - .75, q.z - 4.85); // Used to chop the top off of the bridge railings.\n    float hole3 = abs(mod(p.z + 16., 32.) - 16.) - 2.85; // Used to form the floor to ceiling partitions.\n    \n    \n    // Floor minus hole (repeat square columns) equals bridge. :) \n    float fl = max(p.y + 3.5, -hole1);  \n    \n    // The wall panels with rectangular windows.\n    float wall = max(q2.x - 8., q2.z - 2.15);\n    wall = max(wall, -max(abs(abs(q2.x - 8.) - 4.) - 1.75, abs(q.y - 8.) - .5)); // Wall with window.\n    \n    // This is a neat trick to subdivide space up further without the need for another\n    // modulo call... in a manner of speaking.\n    q2.x = abs(q2.x - 8.);\n    float rail = max(q2.x - .15, q2.y - .15);\n    float rail2 = max(q2.x - .15/6., abs(mod(q2.y + 1./6., 1./3.) - 1./6.) - .15/6.);\n    rail = min(rail, max(rail2, -p.y - 3.));\n    // Optional bottom rail with no gap. Comment out the line above though.\n    //rail = min(min(rail, rail2), max(q2.x - .15, abs(p.y + 3.75) - .6));\n    \n    // Posts.\n    float posts = max(q2.x - .15, abs(mod(q2.z, 2.) - 1.) - .15);\n    \n    // Forming the railings. Comment out the 2nd and 3rd lines if you want to see what they're there for.\n    rail = min(rail, posts);\n    rail = max(rail, -hole2);    \n    rail = max(rail, -hole3);\n    \n    // Subdividing space down again without using the modulo call. For all I know, I've made things\n    // slower. :)\n    q.xz = abs(q.xz - vec2(8));\n    q.x = abs(q.x - 4.);\n\n\n    // Pylons and round pylons.\n    float pylon = min( max(max(q.x, q.y) - 3., -p.y) , min(max(q.y, q.z)*.55 + length(q.yz)*.45 - 3.1, max(q.x, q.z)) - 2.);\n    float rndPylon = length(vec2(q.xz)*vec2(.7, .4)) - 1.;\n    \n    // Breaking space right down to 2x2x2 cubic segments.\n    q = abs(mod(q,  2.) - 1.);\n    float pylonHole = min(q.x, min(q.y, q.z)); // Used to take cubic chunks out of the pylons.\n\n    \n    //objID = step(pylonHole - .15, pylon);\n    \n\n    // Forming the structure.\n    float structure = min(max(pylon, pylonHole) - .15, min(rndPylon, wall)); \n    \n    // Adding the floor and the railings to the structure.\n    return min(structure, min(fl, rail));\n \n    \n}\n\n\n\n// For all intents and purposes, this is a twisty lattice smoothly bounded by a square \n// tube on the outside. I have a million different shaders based on this concept alone, \n// but I won't bore you with them. Instead, Dila and Aiekick have some pretty good examples \n// on Shadertoy making use of it that are worth looking at.\nfloat map(vec3 p){\n    \n    objID = 0.;\n    \n    #ifdef OBJECT_CAMERA_WRAP\n    // Wrap the scene around the path. Optional. See the bump mapping function also.    \n    p.xy -= camPath(p.z).xy;\n    #else   \n    p.x += 4.;\n    #endif\n    \n    float d = lattice(p);\n\n     \n    return d*.95;//*.7;\n}\n\n\n\n// Raymarching.\nfloat trace(vec3 ro, vec3 rd){\n\n    float t = 0., d;\n    for (int i=0; i<80; i++){\n\n        d = map(ro + rd*t);\n        if(abs(d)<.001*(t*.125 + 1.) || t>FAR) break;\n        t += d;\n    }\n    return min(t, FAR);\n}\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D channel, vec3 p, vec3 n){\n    \n\n    \n    n = max(abs(n) - .2, 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(channel, p.zy).xyz;\n    vec3 ty = texture(channel, p.xz).xyz;\n    vec3 tz = texture(channel, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n}\n\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n// Smooth tiles. There are better ways, but it works.\nfloat tiles(vec2 p){\n     \n    p = abs(fract(p*4.) - .5)*2.;\n    float s = max(p.x, p.y);\n    return smoothstep(0., .6, s);//smoothstep(0.1, 1., s*2. - .35);//\n\n\n    /*\n    // Fancier grid pattern, but I decided to implement the \"less is more\" principle. :)\n    vec2 q = abs(fract(p*1.) - .5)*2.;\n    float s = max(q.x, q.y);\n    s = smoothstep(0.5, .85, s);\n    \n    q = abs(fract(p*4. + .5) - .5)*2.;\n    float s2 = max(q.x, q.y);\n    s2 = smoothstep(0., 1., s2);\n    \n    return max(s, s2);\n    */\n\n}\n\n\n// The bump mapping function.\nfloat bumpFunction(in vec3 p){\n    \n    // If wrapping the scene around the the camera path, the bump has to match.\n    #ifdef OBJECT_CAMERA_WRAP\n    p.xy -= camPath(p.z).xy;\n    #endif\n    \n    // A reproduction of the lattice at higher frequency. Obviously, you could put\n    // anything here. Noise, Voronoi, other geometrical formulas, etc.\n    float c;\n    if(p.y>-3.49 || p.y<-3.51) c = min(abs(Menger(p*4.))*1.6, 1.);\n    else { \n        \n        // Another floor pattern. It didn't really work here.\n        //c = 1.-(Menger(p*8. + vec3(0, 0., 0))*1.6) + .7;      \n        //c = smoothstep(.1, 1., c);\n        \n        // Simple grid setup for the floor.\n        c = tiles(p.xz + vec2(0));\n        \n        bObjID = 0.;\n    }\n    \n    return c;   \n   \n}\n\n// Standard function-based bump mapping function with some edging thrown into the mix.\nvec3 doBumpMap(in vec3 p, in vec3 n, float bumpfactor, inout float edge){\n    \n    // Resolution independent sample distance... Basically, I want the lines to be about\n    // the same pixel with, regardless of resolution... Coding is annoying sometimes. :)\n    vec2 e = vec2(2./iResolution.y, 0); \n    \n    float f = bumpFunction(p); // Hit point function sample.\n    \n    float fx = bumpFunction(p - e.xyy); // Nearby sample in the X-direction.\n    float fy = bumpFunction(p - e.yxy); // Nearby sample in the Y-direction.\n    float fz = bumpFunction(p - e.yyx); // Nearby sample in the Y-direction.\n    \n    float fx2 = bumpFunction(p + e.xyy); // Sample in the opposite X-direction.\n    float fy2 = bumpFunction(p + e.yxy); // Sample in the opposite Y-direction.\n    float fz2 = bumpFunction(p+ e.yyx);  // Sample in the opposite Z-direction.\n    \n     \n    // The gradient vector. Making use of the extra samples to obtain a more locally\n    // accurate value. It has a bit of a smoothing effect, which is a bonus.\n    vec3 grad = vec3(fx - fx2, fy - fy2, fz - fz2)/(e.x*2.);  \n    //vec3 grad = (vec3(fx, fy, fz ) - f)/e.x;  // Without the extra samples.\n\n\n    // Using the above samples to obtain an edge value. In essence, you're taking some\n    // surrounding samples and determining how much they differ from the hit point\n    // sample. It's really no different in concept to 2D edging.\n    edge = abs(fx + fy + fz + fx2 + fy2 + fz2 - 6.*f);\n    edge = smoothstep(0., 1., edge/e.x);\n    \n    // Some kind of gradient correction. I'm getting so old that I've forgotten why you\n    // do this. It's a simple reason, and a necessary one. I remember that much. :D\n    grad -= n*dot(n, grad);          \n                      \n    return normalize(n + grad*bumpfactor); // Bump the normal with the gradient vector.\n\t\n}\n\n// The normal function with some edge detection rolled into it. Sometimes, it's possible to get away\n// with six taps, but we need a bit of epsilon value variance here, so there's an extra six.\nvec3 nr(vec3 p, inout float edge, float t){ \n\t\n    vec2 e = vec2(2./iResolution.y, 0); // Larger epsilon for greater sample spread, thus thicker edges.\n\n    // Take some distance function measurements from either side of the hit point on all three axes.\n\tfloat d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\tfloat d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\tfloat d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\tfloat d = map(p)*2.;\t// The hit point itself - Doubled to cut down on calculations. See below.\n     \n    // Edges - Take a geometry measurement from either side of the hit point. Average them, then see how\n    // much the value differs from the hit point itself. Do this for X, Y and Z directions. Here, the sum\n    // is used for the overall difference, but there are other ways. Note that it's mainly sharp surface \n    // curves that register a discernible difference.\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    //edge = max(max(abs(d1 + d2 - d), abs(d3 + d4 - d)), abs(d5 + d6 - d)); // Etc.\n    \n    // Once you have an edge value, it needs to normalized, and smoothed if possible. How you \n    // do that is up to you. This is what I came up with for now, but I might tweak it later.\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n\t\n    // Redoing the calculations for the normal with a more precise epsilon value.\n    e = vec2(.005*min(1. + t, 5.), 0);\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx); \n    \n    // Return the normal.\n    // Standard, normalized gradient mearsurement.\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat cao(in vec3 p, in vec3 n){\n\t\n    float sca = 1., occ = 0.;\n    for(float i=0.; i<5.; i++){\n    \n        float hr = .01 + i*.5/4.;        \n        float dd = map(n * hr + p);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp(1.0 - occ, 0., 1.);    \n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 20; \n    \n    vec3 rd = (lp-ro); // Unnormalized direction ray.\n\n    float shade = 1.0;\n    float dist = 0.05;    \n    float end = max(length(rd), 0.001);\n    //float stepDist = end/float(maxIterationsShad);\n    \n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        //dist += min( h, stepDist ); // So many options here: dist += clamp( h, 0.0005, 0.2 ), etc.\n        dist += clamp(h, 0.01, 0.2);\n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0.001 || dist > end) break; \n    }\n\n    // I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing.\n    return min(max(shade, 0.) + 0.2, 1.0); \n}\n\n// Blackbody color palette. Handy for all kinds of things.\nvec3 blackbodyPalette(float t){\n\n    // t = tLow + (tHigh - tLow)*t;\n    t *= 4000.; // Temperature range. Hardcoded from 0K to 4000K, in this case.    \n    \n    // Planckian locus or black body locus approximated in CIE color space.\n    float cx = (0.860117757 + 1.54118254e-4*t + 1.28641212e-7*t*t)/(1.0 + 8.42420235e-4*t + 7.08145163e-7*t*t);\n    float cy = (0.317398726 + 4.22806245e-5*t + 4.20481691e-8*t*t)/(1.0 - 2.89741816e-5*t + 1.61456053e-7*t*t);\n    \n    // Converting the chromacity coordinates to XYZ tristimulus color space.\n    float d = (2.*cx - 8.*cy + 4.);\n    vec3 XYZ = vec3(3.*cx/d, 2.*cy/d, 1. - (3.*cx + 2.*cy)/d);\n    \n    // Converting XYZ color space to RGB: http://www.cs.rit.edu/~ncs/color/t_spectr.html\n    vec3 RGB = mat3(3.240479, -0.969256, 0.055648, -1.537150, 1.875992, -0.204043, \n                    -0.498535, 0.041556, 1.057311) * vec3(1./XYZ.y*XYZ.x, 1., 1./XYZ.y*XYZ.z);\n\n    // Apply Stefan‚ÄìBoltzmann's law to the RGB color\n    return max(RGB, 0.)*pow(t*0.0004, 4.); \n}\n\n// Pseudo environment mapping. Simlilar to above, but using tri-planar texturing for a more \n// even spread.\nvec3 envMap(vec3 rd, vec3 n){\n    \n    vec3 col = tex3D(iChannel0, rd, n);\n    col = smoothstep(.15, .5, col);\n    #ifdef WARM\n    col *= vec3(1.35, 1, .65);\n    #endif\n    //col = col*.5 + vec3(1)*pow(min(vec3(1.5, 1, 1)*dot(col, vec3(.299, .587, .114)), 1.), vec3(1, 3, 10))*.5; // Contrast, coloring. \n    \n    return col;\n\n}\n\n// Compact, self-contained version of IQ's 3D value noise function.\nfloat n3D(vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// Layered noise.\nfloat fBm(vec3 p){ return n3D(p)*.57 + n3D(p*2.)*.28 + n3D(p*4.)*.15; }\n\n// Camera path. Arranged to coincide with the frequency of the lattice.\nvec3 camPath(float t){\n\n    //return vec3(4, 0, t); // Straight path.\n\n    // Curvy path. Weaving around the columns.\n    float a = sin(t * 3.14159265/32. + 1.5707963*1.);\n    float b = cos(t * 3.14159265/32.);\n\n    return vec3(a*5., b*a, t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n\n    // Screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\t\n\t// Camera Setup.\n    float speed = 3.;\n    vec3 ro = camPath(time*speed); // Camera position, doubling as the ray origin.\n    vec3 lk = camPath(time*speed + .5);  // \"Look At\" position.\n    \n  //  vec3 lp = camPath(time*speed + 5.5); // Light position, somewhere near the moving camera.\n    // Moving the light in the opposite X-direction to the camera path. No science is involved. I\n    // just preferred the lighting a better from this perpective.\n//    lp.x = -lp.x;\n    // Moving the light along the Z-axis only, if your prefer.\n\tvec3 lp = ro;//vec3(0, 0, time*speed) + vec3(0, 0, 0);\n    \n    #ifdef OBJECT_CAMERA_WRAP\n    lp.x += 8.;\n    #endif\n\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159/3.; ///3. FOV - Field of view.\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    vec3 up = cross(fwd, rgt);\n\n    // Unit direction ray.\n    //vec3 rd = normalize(fwd + FOV*(u.x*rgt + u.y*up));\n    \n    // Mild lens distortion to fit more of the scene in, and to mix things up a little.\n    vec3 rd = fwd + FOV*(u.x*rgt + u.y*up);\n//    rd = normalize(vec3(rd.xy, (rd.z - length(rd.xy)*.3)*.7));\n    \n    // Swiveling the camera from left to right when turning corners.\n//    float swivel = camPath(lk.z).x;\n//    rd.xy = rot(swivel/24. )*rd.xy;\n//    rd.xz = rot(swivel/8. )*rd.xz;\n    \n\n    \n    // Raymarch.\n    float t = trace(ro, rd);\n    float svObjID = objID;\n    \n    // Surface hit point.\n    vec3 sp = ro + rd*t;\n    \n    // Normal with edge component.\n    float edge;\n    vec3 sn = nr(sp, edge, t);\n    \n    // Shadows and ambient self shadowing.\n    float sh = softShadow(sp, lp, 16.); // Soft shadows.\n    float ao = cao(sp, sn); // Ambient occlusion.\n    \n    // Light direction vector setup and light to surface distance.\n    vec3 ld = lp - sp;\n    float lDist = max(length(ld), .0001);\n    ld /= lDist;\n    \n    // Attenuation.\n    float atten = 1./(1. + lDist*.125 + lDist*lDist*.025);\n    \n \n    \n    // Heavy function-based bump mapping with bumped edges.\n    float edge2 = 0.;\n    #ifdef SHOW_DETAILS\n    sn = doBumpMap(sp, sn, .15/(1. + t/FAR), edge2);\n    #endif\n    \n\n    // Warping the texture cordinates by the camera path just slightly to break up the\n    // texture repetion a bit, especially on the floor.\n    vec3 tsp = sp;\n    tsp.xy += camPath(tsp.z).xy*.35;\n\n    \n    // Texture-based bump mapping.\n    const float tSize = 1./5.;\n    sn = doBumpMap(iChannel0, tsp*tSize, sn, .01/(1. + t/FAR));\n\n    \n    // Diffuse, specular and Fresnel.\n    float dif = max(dot(ld, sn), 0.);\n    float spe = pow(max(dot(reflect(rd, sn), ld), 0.), 8.);\n    float fre = pow(clamp(dot(rd, sn) + 1., 0., 1.), 4.);\n    dif = pow(dif, 4.)*0.66 + pow(dif, 8.)*0.34; // Ramping up the diffuse to make it shinier.\n    \n    \n    // Texturing the object.\n    vec3 tx = tex3D(iChannel0, tsp*tSize, sn);\n    tx = smoothstep(0.05, .5, tx)*1.5; // Giving it a bit more brightness and contrast.\n    #ifdef WARM\n    tx *= vec3(1.35, 1, .65);\n    #endif\n \n \n    \n    #ifdef SHOW_DETAILS\n    if(bObjID > .5 && bObjID < 1.5) tx *= vec3(1.3, .65, .35);//vec3(1.5, .85, .25);\n    #endif\n    \n    // Lazy way to identify the mesh floor area. It saves an object identification in the\n    // distance function.\n    if(sp.y<-3.49 && sp.y>-3.51) {\n        \n        //dif = (sqrt(dif));\n        #ifdef SHOW_DETAILS\n        tx *= tiles(sp.xz);\n        #endif\n        tx *= vec3(1.3, 1, .7);\n    }\n    \n    \n    // Applying the normal-based and bump mapped edges.\n    tx *= (1.-edge*.7)*(1.-edge2*.7);\n    \n    \n    // Combining the terms above to produce the final color.\n    vec3 fc = tx*(dif*1.5 + .2);\n    #ifdef WARM\n    fc += tx*vec3(1, .7, .4)*fre*4. + vec3(1.35, 1, .65)*vec3(1, .7, .3)*spe*3.;\n    #else\n    fc += tx*vec3(.5, .7, 1)*fre*4. + vec3(1, .7, .3)*spe*3.;\n    #endif\n    \n    // Adding in some reflective looking color. It's completely fake, but subtle enough so\n    // that you don't notice.\n    vec3 env = envMap(tsp*tSize + reflect(rd, sn), sn);//svSn*.75 + sn*.25\n    fc += env*.5;\n  \n    \n    // Shading.\n    fc *= atten*sh*ao;\n\n    \n    // Extra processing. A little too heavy going for my liking.\n    //fc = fc*.5 + vec3(1)*pow(max(fc, 0.), vec3(1, 1.5, 2.5))*.5; // Contrast, coloring.\n\n    \n    // Mixing in some fiery background haze, otherwise known as a lazy, two dollar, noise effect. :)\n    #ifdef WARM\n    float noise = (fBm(sp - time*2.)*.08 + .94)*(rd.y*.25 + .75);\n    vec3 bg = blackbodyPalette(noise);\n    #else\n    float noise = (fBm(sp - time*2.)*.15 + .9)*(rd.y*.5 + .5);\n    vec3 bg = mix(vec3(.3, .4, .7), vec3(.7, .9, 1), noise);\n    #endif\n    fc = mix(bg, fc, 1. - smoothstep(0., 1., t*t/FAR/FAR) ); //1./(1. + t*t*.003)\n    \n\n    // Approximate gamma correction.\n\tfragColor = vec4(sqrt(clamp(fc, 0., 1.)), 1.0);\n}\n", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XttBWf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtVBDz", "name": "Intro to gfx - homework1", "author": "HaskarP", "description": "A Shader by me", "tags": ["work"], "likes": 0, "viewed": 42, "date": "1542651988", "time_retrieved": "2024-06-20T19:25:29.295793", "image_code": "// Settings\nconst float FOV_DEG = 80.0f;\nconst int MAX_STEPS = 300;\nconst vec3 LIGHT_DIR = vec3(1.0,1.0,-1.0);\n\n// Consts / Enumerations \nconst float EPS = 0.0001f;\nconst float DEG_TO_RAD = 0.0174533f;\nconst float M_PI = 3.14159265358979323846;\nconst int FLOOR_PLANE = 1;\nconst int OBJECT = 2;\nconst int OBJECT2 = 3;\nconst int NO_HIT = 0;\n\n///////////////////////////////////////////////////////////\n\nstruct Ray\n{\n    vec3 Orgin;\n    vec3 Direction;\n};\n\n//Utils\nmat3 CreateRotationX(float rotation)\n{\n    mat3 rotateX =\n     mat3(\n        1.0, 0.0, 0.0,\n\t\t0.0, cos(rotation), -sin(rotation),\n\t\t0.0, sin(rotation), cos(rotation)\n    );\n\n    return rotateX;\n}\n\nmat3 CreateRotationY(float rotation)\n{\n    mat3 rotateY = \n     mat3(\n        cos(rotation), 0.0, sin(rotation),\n\t\t0.0, 1.0, 0.0, \n\t\t-sin(rotation), 0.0, cos(rotation)\n    );\n\n    return rotateY;\n}\n\nmat3 CreateRotationZ(float rotation)\n{\n    mat3 rotateZ =\n    mat3(\n        cos(rotation), -sin(rotation), 0.0,\n\t\tsin(rotation), cos(rotation), 0.0,\n\t\t0.0, 0.0, 1.0\n    );\n\n    return rotateZ;\n}\n\n// SDFs\nfloat SphereSDF(vec3 p)\n{\n    return length(p)-1.1;\n}\n\nfloat TorusSDF(vec3 p, float R, float r)\n{  \n    float xy = length(p.xy) - R;\n    float z = length(vec2(xy,p.z))-r; \n    return z;\n}\n\nfloat BoxSDF(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0))-0.1;\n}\n\nfloat CylinderSDF(vec3 p,float radius)\n{   \n    float d = length(p.xz)-radius;\n    d = max(d,p.y-1.0);\n    d = max(d,-p.y-1.0);\n    return d;\n}\n\nfloat PlaneSDF(vec3 p, float y)\n{\n    return p.y+y;\n}\n\nvec3 RepeatX(vec3 p, float offset)\n{\n    p.x = mod(p.x,offset) - offset/2.0;\n    return p;\n}\n\nvec3 Twist(vec3 p, float amount)\n{\n    float c = cos(amount*p.y);\n    float s = sin(amount*p.y);\n    \n    // Create 2D rotation matrix\n    mat2 rm = mat2(c,-s,s,c);\n    p.xz *=rm;\n    return p;\n}\n\nfloat maximum(float a, float b) {\n    if (a>b) {\n        return a;\n    }\n    return b;\n}\n\n//TODO: TASK1\nvoid Phong(vec3 L, vec3 N, vec3 V, float sh, out float d, out float s)\n{\n    // IMPLEMENT PHONG MODEL HERE\n    N = normalize(N);\n    L = normalize(L);\n    V = normalize(V);\n    d = maximum(0.0,dot(N,L));\n    s = pow(maximum(0.0,dot(normalize(reflect(L,N)),V)),sh);  \n    \n}\n\n//Main scene distance field function\nfloat CombineSDF(vec3 p, inout int closest)\n{\n      vec3 pn = p*vec3(1.0,0.6,1.0);;\n      pn =  Twist(pn+vec3(0,0,-0.3),sin(iTime)*0.5);//CreateRotationY(iTime)* vec4(p,0);\n      float sd = SphereSDF(pn.xyz);  \n  \n      sd = max(BoxSDF(pn.xyz,vec3(0.95)),-sd); \n      float  torus = TorusSDF(CreateRotationY(iTime)*(p + CreateRotationY(iTime*0.3)*vec3(0.0,0.0,2.5)) ,0.9f,0.4f);\n      sd = min(torus,sd);      \n      float pd =  PlaneSDF(p,23.0); \n      float fin = min(sd,pd);\n      closest = OBJECT;\n      if(fin == pd)\n      { closest = FLOOR_PLANE;}\n      else if(fin == torus) \n      {closest = OBJECT2;}\n      return fin;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    int dummy = 0;\n    return \n    normalize(vec3(\n\t\tCombineSDF(vec3(p.x + EPS, p.y, p.z), dummy) - CombineSDF(vec3(p.x - EPS, p.y, p.z), dummy),\n\t\tCombineSDF(vec3(p.x, p.y + EPS, p.z), dummy) - CombineSDF(vec3(p.x, p.y - EPS, p.z), dummy),\n\t\tCombineSDF(vec3(p.x, p.y, p.z + EPS), dummy) - CombineSDF(vec3(p.x, p.y, p.z - EPS), dummy)\n\t\t));\n}\n\nfloat Trace(Ray r,inout int hit)\n{\n    hit = 0;\n    float t = 0.0f;\n    \n    for(int i =0; i < MAX_STEPS; ++i)\n    {\n       vec3 p = r.Orgin + r.Direction * t;\n       int closest = 0;     \n       float sd = CombineSDF(p, closest);\n           \n       if(sd < EPS)\n       {\n          hit = closest;\n          return t;\n       }\n       t += sd;\n    }\n    return 0.0f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Frag coord normalization \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    // Make center of the screen be (0,0)\n    uv = uv * 2.0 - 1.0; \n    // Aspect ratio\n    uv.x *= iResolution.x/iResolution.y;\n    \n    //FOV\n    float fovDist = tan(FOV_DEG  *0.5 * M_PI / 180.0); \n    uv *= fovDist;\n    \n    //TODO: TASK2\n    //CHANGE CAMERA POSITION AND ORIENTATION HERE:\n    Ray r;\n    r.Direction = normalize(vec3(uv,1.0));\n    r.Orgin = vec3(0,4,-5.0);\n    mat3 rotate = CreateRotationX(35.0*M_PI/180.0);\n    r.Direction.xyz *= rotate;\n    \n    int hit = NO_HIT;   // indicates type of the object hit\n    float t = Trace(r,hit);  \n    vec3 hitAt = r.Orgin + r.Direction * t;\n    vec3 N = GetNormal(hitAt);\n    \n    float diff,spec = 0.0;\n    vec3 col = vec3(0); \n    \n    if(hit == OBJECT) // Block\n    {        \n        Phong(LIGHT_DIR,N,-r.Direction,50.0,diff,spec);\n        col =  vec3(0.2,0.04,0.2)+ vec3(0.5,0.0,0.5) * diff + vec3(1.0) * spec;\n    }\n    else if(hit == OBJECT2) // Torus\n    {\n        Phong(LIGHT_DIR,N,-r.Direction,50.0,diff,spec);\n        vec3 baseCol = vec3(clamp(cos(hitAt.y),0.0,1.0), clamp(sin(hitAt.y),0.0,1.0),0.0);\n        col =  0.3 * baseCol + 0.7 * baseCol * diff + vec3(1.0)*spec; \n    } \n    else if(hit == FLOOR_PLANE) // Floor\n    {\n        float ar = iResolution.x/iResolution.y;\n        vec2 planeUV = vec2(80.0+hitAt.x,hitAt.z)/200.0;\n        col = texture(iChannel0, planeUV).xyz; \n        //TODO: TASK3\n        // ADD FLOOR PATTERNS\n        col = vec3(col.x,col.y,col.z);\n        \n        // AM i supposed to add a texture from channel 1 onto this:?\n        // or create my own texture and superimpose?\n        // where do i get the implementation details for the individual components?\n\n    }\n    \n    else // NO HIT - BACKGROUND COLOR\n    {\n      col = 0.5 + 0.5 * cos(uv.xyx + vec3(0,2.3,3.5));\n    }\n    //TODO: TASK3\n    //SCREEN SPACE EFFECTS\n    \n    \n   // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtVBDz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtVBRc", "name": "First Attempt at a RayMarcher", "author": "foodini", "description": "Just trying to build a ray marching demo that will be easily modiiable by someone trying to learn the concepts. \n\nVery much a work in progress.", "tags": ["raymarch", "raymarch"], "likes": 2, "viewed": 115, "date": "1543440810", "time_retrieved": "2024-06-20T19:25:30.162593", "image_code": "float dist1(vec3 p) {\n    p = mod(p+0.5,1.0)-vec3(0.5);\n    return length(p) - 0.3;\n}\n\nfloat dist2(vec3 p) {\n    float single = length(p) - sin(iTime)*sin(iTime);\n  \n    //p = mod(p,1.0)-vec3(0.5); // instance on xy-plane\n    vec3 folded = fract(p+0.5)-vec3(0.5); // instance on xy-plane\n    float infinite = length(folded)-abs(sin(length(p))/4.0);\n  \n    return min(infinite, single);\n}\n\n\nint iterations = 15;\nfloat scale = 2.0;\nfloat dist3(vec3 z) {\n\tvec3 a1 = vec3(1,1,1);\n\tvec3 a2 = vec3(-1,-1,1);\n\tvec3 a3 = vec3(1,-1,-1);\n\tvec3 a4 = vec3(-1,1,-1);\n\tvec3 c;\n\tint n = 0;\n\tfloat dist, d;\n\twhile (n < iterations) {\n\t\t c = a1; dist = length(z-a1);\n\t        d = length(z-a2); if (d < dist) { c = a2; dist=d; }\n\t\t d = length(z-a3); if (d < dist) { c = a3; dist=d; }\n\t\t d = length(z-a4); if (d < dist) { c = a4; dist=d; }\n\t\tz = scale*z-c*(scale-1.0);\n\t\tn++;\n\t}\n\n\treturn length(z) * pow(scale, float(-n))-0.001;\n}\n\nfloat dist4(vec3 z) {\n    float r;\n    int n = 0;\n    while (n < iterations) {\n       if(z.x+z.y<0.) z.xy = -z.yx; // fold 1\n       if(z.x+z.z<0.) z.xz = -z.zx; // fold 2\n       if(z.y+z.z<0.) z.zy = -z.yz; // fold 3\t\n       z = z*scale - vec3(1.,1.,1.)*(scale-1.0);\n       n++;\n    }\n    return (length(z) ) * pow(scale, -float(n));\n}\n\nfloat dist(vec3 p) {\n    return dist4(p);\n}\n\nvec3 dx = vec3(0.0001, 0.0, 0.0);\nvec3 dy = vec3(0.0, 0.0001, 0.0);\nvec3 dz = vec3(0.0, 0.0, 0.0001);\n\nvec3 norm(vec3 p) {\n    return normalize(\n        vec3(dist(p+dx)-dist(p-dx),\n\t\t     dist(p+dy)-dist(p-dy),\n\t\t     dist(p+dz)-dist(p-dz))\n    );   \n}\n\nfloat rand(float seed) {\n    float s = sin(seed*iTime + 3872983.9);\n    return s*s;\n}\n\n//rd MUST BE NORMALIZED, or distance estimation will march the ray in incorrect step sizes.\nbool march(out int iterations, out vec3 point, out float smallest_dist, in vec3 r0, in vec3 rd) {\n    float total_dist = 0.0;\n    float cur_dist;\n    smallest_dist = 10000000.0;\n    \n    point = r0 + rd * total_dist;\n    for (iterations=0; iterations<120; iterations++) {\n        cur_dist = dist(point);\n        if(cur_dist < smallest_dist) {\n            smallest_dist = cur_dist;\n        }\n        if(cur_dist < 0.001) {\n            return true;\n        }\n        total_dist += cur_dist;\n    \tpoint = r0 + rd * total_dist;\n    }\n    return false;\n}\n\nvec3 ortho_light_dir = vec3(0.57735, -0.57735, 0.57735);\nvec3 ortho_light_color = vec3(0.8, 0.5, 1.0);\n\nvec4 lighting(vec3 p, vec3 n) {\n    //AMBIENT (currently 0) Should be multiplied by diffuse color.\n    vec3 retval = vec3(0., 0., 0.); \n    float dprod = dot(n, ortho_light_dir);\n    if(dprod >= 0.0) {\n        retval += ortho_light_color * (\n            //DIFFUSE\n            vec3(0.7, 0.8, 1.0) * dprod +\n            //SPECULAR\n            //pow(dprod, 40.0)\n            0.0\n        );\n    }\n    return vec4(retval, 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //Screen x goes from -1.0 to 1.0\n\tvec2 screen_coord = -1.0 + 2.0 * (fragCoord.xy / iResolution.xy);\n    float aspect_ratio = iResolution.x/iResolution.y;\n    //Screen y goes from (-1.0/aspect_ratio to 1.0/aspect_ratio)\n    screen_coord.y /= aspect_ratio;\n\n    //Given a viewpoit (location of the eye) and a point to look at,\n    //compute the vector out the top of the viewer's head (up) and out\n    //his right ear (right);\n\tvec3 viewpoint = vec3(2.5*sin(iTime/8.), 2.5*cos(iTime/8.), sin(iTime/16.));\n    vec3 lookat = vec3(0., 0.0, 0.0);\n    vec3 lookdir = lookat - viewpoint;\n    vec3 right = normalize(cross(lookdir, vec3(0., 0., 1.)));\n    vec3 up = normalize(cross(right, lookdir));\n    \n    //Scale right and up to fix the 'focal length' of the camera. By\n    //doing this, I can make the distance between viewpoint and lookat\n    //arbitrarily large or small and the camera doesn't jump from zoom\n    //to fisheye. Change the 1.0s to something larger for fisheye, smaller\n    //for zoom.\n    float looklen = length(lookdir);\n    right *= looklen * 0.5;\n    up *= looklen * 0.5;\n    \n    //From the viewpoint, the ray we'll travel along to pass through the\n    //appropriate pixel:\n    vec3 ray_d = \n        normalize(\n        \tlookat\n            + screen_coord.x * right\n            + screen_coord.y * up\n            - viewpoint\n        );\n    \n    int iterations;\n    vec3 intersection;\n    float smallest_dist;\n    bool hit = march(iterations, intersection, smallest_dist, viewpoint, ray_d);\n    if(hit) {\n        //\n        fragColor = lighting(intersection, norm(intersection));\n    } else {\n        float sky_brightness = max(dot(ray_d, ortho_light_dir), 0.0);\n        vec3 sky_color = sky_brightness * ortho_light_color;\n    \tfragColor = vec4(sky_color, 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtVBRc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtVfDz", "name": "Fractal Diamond Combination", "author": "_polymath", "description": "Some diamonds that merge as the camera pans out", "tags": ["2d"], "likes": 3, "viewed": 364, "date": "1542818207", "time_retrieved": "2024-06-20T19:25:30.168715", "image_code": "vec2 rotate(vec2 p, float theta) {\n\tfloat s = sin(theta), c = cos(theta);\n    return vec2(\n    \tp.x * c + p.y * s,\n    \tp.y * c - p.x * s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float bigTime = mod(iTime / 10., 1.);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord / iResolution.xy - .5) * pow(2., bigTime);\n    uv = rotate(uv, 3.1415927 / 4.) * 5.;\n    vec2 bigUv = fract(uv * .5) * 2.;\n\tuv = fract(uv);\n    \n    vec4 back = vec4(0., 0., .4, 1.);\n    vec4 fore = vec4(0., 0., .8, 1.);\n    \n    if (bigTime > 0.5) {\n        if (bigUv.x > 1. != bigUv.y > 1.) {\n        \t// the top square that slides right\n            if (uv.y < 0.5)\n    \t    \tfragColor = (1. - uv.x > bigTime) ? fore : back;\n            else\n            // the bottom square that slides left\n    \t    \tfragColor = (uv.x > bigTime) ? fore : back;\n        } else {\n            // the constant squares\n            if (uv.x > 0.5 == uv.y > 0.5)\n                fragColor = fore;\n            // the square sliding in from the left\n            else if (uv.y < 0.5)\n                fragColor = (1.5 - uv.x < bigTime) ? fore : back;\n            // the square sliding in from the right\n            else\n                fragColor = (0.5 + uv.x < bigTime) ? fore : back;\n        }    \n    }\n    else {\n    \tif (uv.x > 0.5 != uv.y > 0.5)\n    \t    fragColor = back;\n\t    else\n    \t    fragColor = fore;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtVfDz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtVfRc", "name": "Uncoiling Too", "author": "PianiGiani", "description": "Variation on https://www.shadertoy.com/view/ltKyWG", "tags": ["spirograph", "coils"], "likes": 6, "viewed": 179, "date": "1543443874", "time_retrieved": "2024-06-20T19:25:30.168715", "image_code": "#define S(a,b,t) smoothstep(a,b,t)\n#define DST 0.001\n#define WD 1.5\n#define STP 5.\n#define RES 400.\n#define RES2 600.\n#define RES3 900.\n#define nTime iTime/2.\n\nfloat Dline(vec2 p, vec2 a, vec2 b) {\n\t// line drawing function from BigWings\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float t = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.1);\n    return length(pa-ba*t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    float s = sin(nTime/5.);\n    float c = cos(nTime/5.);\n    uv*=mat2(c, -s, s, c); \n    \n    float va = (cos(iTime/6.)+.5)*20.;\n    float shape = 3.+(cos(iTime/35.)*2.);\n    \n    float col=0.0;\n    float i=-100.0;\n    for(int i2=0;i2<1000;i2++)\n    {\n        i+=shape;\n        if (i >= 100.) {break;}\n        float r=va;\n        float rr=120.;\n        float p=va;\n        float ii=i+shape;\n    \tvec2 myA = vec2((r+rr)*cos(i)+p*cos(r+rr)*i/r,(r+rr)*sin(i)+p*sin(r+rr)*i/r);\n    \tvec2 myB = vec2((r+rr)*cos(ii)+p*cos(r+rr)*ii/r,(r+rr)*sin(ii)+p*sin(r+rr)*ii/r);\n    \n    \tfloat d = Dline(uv, myA/RES, myB/RES);\n   \t \tfloat m = S(WD/200., (WD/200.)-(0.02-(i/9000.)), d)*WD;\n    \tcol = max(m,col);\t\n\n        d = Dline(uv-vec2(0.0,0.0), myA/RES3, myB/RES3);\n   \t \tm = S(WD/200., (WD/200.)-(0.02-(i/9000.)), d)*WD;\n    \tcol = max(m,col);\n\n    }\n    fragColor = vec4(vec3(col*(cos(iTime/15.)/2.+1.2),col*(sin(iTime/23.)/2.+1.2), col*(sin(iTime/10.)/2.+1.2)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtVfRc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtVfRm", "name": "Multiple Light", "author": "dacruzquen", "description": "multiple light", "tags": ["multiplelight"], "likes": 1, "viewed": 123, "date": "1542125117", "time_retrieved": "2024-06-20T19:25:31.768734", "image_code": "//link : \n\n//Material\nstruct Material\n{\n    float Ka;\n    float Kd;\n    float Ks;\n    float Kn;\n};\n    \nstruct ShadeInfo\n{\n    vec3 shadedCol;\n    float Ks;\n};\n    \nstruct LightInfo\n{\n    vec3 pos;\n    vec3 col;\n    float power;\n};\n    \nconst int MAX_NB_BOUNCES = 5;\n\n//camera parameters\nvec3 cameraPos = vec3(6,4,-5);\nconst vec3 cameraTarget = vec3(3,1,-8);\nconst float cameraFovY = 80.0; // Note: angle is degree\n\n//Sphere parameters\nvec3 spherePos = cameraTarget + vec3(0,1,2);\nconst float sphereRadius = 1.0;\nconst vec3 sphereCol = vec3(1,0,0);\nconst Material sphereMat = Material(0.2,0.7,1.0,50.0);\nconst int sphereId = 1;\n\n//Light parameters\nconst vec3 ambiantCol = vec3(0,0,1);\n\nconst vec3 light1Col = vec3(1,1,1);\nvec3 light1Pos = vec3(8,10,-12);\nconst float light1Pow = 0.8;\n\nconst vec3 light2Col = vec3(1,1,0.5);\nvec3 light2Pos = vec3(3,10,1);\nconst float light2Pow = 0.5;\n\nconst int NB_LIGHTS = 2;\n\nLightInfo lights[NB_LIGHTS];\n\n//Sky parameters\nconst vec3 skyCol = vec3(0);\nconst int skyId = 0;\n\n//Plane parameters\nconst vec3 planePos = vec3(0, 0.1, 0);\nconst vec3 planeNormal = vec3(0,1.0,0);\nconst vec3 planeCol1 = vec3(1.0);\nconst vec3 planeCol2 = vec3(0.4);\nconst Material planeMat = Material(0.2,1.0,0.2,5.0);\nconst int planeId = 2;\n\nconst int PIXEL_SAMPLING_GRID_SIZE = 5;\nconst int PIXEL_SAMPLING_SIZE = 20;\n\nvec2 transform_to_apply(vec2 xy){\n    xy = (2.*xy.xy - iResolution.xy)/iResolution.y;\n    return vec2(xy.x,xy.y);\n}\n\nfloat raySphere(vec3 rayPos, vec3 rayDir, vec3 spherePos, float sphereRadius, out vec3 intersecS, out vec3 normalS)\n{    \n    vec3 diff = rayPos - spherePos;\n    \n    float a = dot(rayDir,rayDir);\n    float b = 2.0 * dot(diff,rayDir);\n    float c = dot(diff,diff) - sphereRadius * sphereRadius;\n    \n    float di = b*b - 4.0*a*c;\n    \n    if(di >= 0.0)\n    {\n        float sdi = sqrt(di);\n        float den = 1.0 / (2.0 * a);\n        float t1 = (-b - sdi) * den;\n        float t2 = (-b + sdi) * den;\n        \n        intersecS = rayPos + t1 * rayDir;\n        normalS = normalize(intersecS - spherePos);\n        \n        return t1;\n    }\n    \n    return -1.;\n}\n\nfloat rayPlane(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal, out vec3 intersecPt, out vec3 normal)\n{\n    if(dot(rayDir,planeNormal)!=0.0)\n    {\n        float t = dot(planePos - rayPos,planeNormal)/dot(rayDir,planeNormal);\n        \n        intersecPt = rayPos + t * rayDir;\n        normal = planeNormal;\n        \n        return t;\n    }\n    return -1.0;\n}\n\nvoid computeCameraRayFromPixel(in vec2 pixCoord, out vec3 rayPos, out vec3 rayDir)\n{\n    rayPos = cameraPos;\n    \n    float f = 1./tan(radians(cameraFovY)/2.);\n    \n    vec3 PT = cameraTarget - cameraPos;\n    vec3 cz = normalize(PT);\n    \n    vec3 PO = f*cz;\n    \n    vec3 cyT = vec3(0,-1.,0);\n    vec3 cxT = cross(cyT,cz);\n    \n    vec3 cx = normalize(cxT);\n    \n    vec3 cy = cross(cz,cx);\n    \n    vec3 OS = pixCoord.x * cx - pixCoord.y * cy;\n    \n    rayDir = normalize(PO+OS);\n}\n\nvec3 computePhongShading(vec3 sphereCol, Material sphereMat,float shadowFactor, vec3 normal, vec3 L, vec3 R, vec3 V, LightInfo light)\n{\n    vec3 A = sphereMat.Ka * ambiantCol / float(NB_LIGHTS);\n    vec3 D = sphereMat.Kd * sphereCol * light.col * light.power * max(dot(L,normal),0.0);\n    vec3 S = sphereMat.Ks * light.col * light.power  * pow(max(dot(R,V),0.0),sphereMat.Kn);\n    return A+shadowFactor*D+shadowFactor*S;\n}\n\n//The aim of this routine is to find the nearest intersection the ray has with all objects\nfloat computeNearestIntersection(vec3 rayPos, vec3 rayDir, out int objectId, out vec3 intersecI, out vec3 normalI)\n{\n    vec3 intersecS, normalS;\n    float distSphere = raySphere(rayPos, rayDir, spherePos, sphereRadius, intersecS, normalS);\n    vec3 intersecP, normalP;\n    float distPlane = rayPlane(rayPos, rayDir, planePos, planeNormal, intersecP, normalP);\n    if(distSphere > 0.0 && distPlane > 0.0)\n    {\n        float distMin = min(distSphere,distPlane);\n        objectId = (distSphere == distMin) ? sphereId : planeId; \n        intersecI = (distSphere == distMin) ? intersecS : intersecP; ;\n        normalI = (distSphere == distMin) ? normalS : normalP; ;\n        return distMin;\n    }\n    else\n    {\n        if(distSphere > 0.0)\n        {\n            objectId = sphereId;\n            intersecI = intersecS;\n            normalI = normalS;\n            return distSphere;\n        }\n        else if (distPlane > 0.0)\n        {\n            objectId = planeId;\n            intersecI = intersecP;\n            normalI = normalP;\n            return distPlane;\n        }\n        else\n        {\n           \tobjectId = skyId;\n            return -1.0;\n        }\n    }\n}\n\nvec3 getSphereColorAtPoint(vec3 pt)\n{\n    return sphereCol;\n}\n\n//pt is assumed to be on the place surface\nvec3 getPlaneColorAtPoint(vec3 pt)\n{\n    return mod(floor(pt.x*0.5) + floor(pt.z*0.5),2.0) < 1.0 ? planeCol1 : planeCol2;\n}\n\nvec3 getObjectColorAtPoint(int objectId, vec3 pt, out Material objectMat)\n{\n    switch(objectId)\n    {\n        case 0:\n        \treturn skyCol;\n        case 1:\n        \tobjectMat = sphereMat;\n        \treturn getSphereColorAtPoint(pt);\n        case 2:\n        \tobjectMat = planeMat;\n        \treturn getPlaneColorAtPoint(pt);\n    }\n}\n\nfloat getShadowFactorAtPoint(vec3 I, vec3 N, Material objectMat, vec3 L, float Ldist)\n{\n    I += 0.001*N;\n    int objId;\n    vec3 intersecS, normalS;\n    float d = computeNearestIntersection(I,L,objId,intersecS,normalS);\n    return (d<=0.0 || d>=Ldist)?1.0:objectMat.Ka;\n}\n\nvec3 RaytraceAtPixelCoord(vec2 pixCoord)\n{\n    vec3 rayPos, rayDir;\n    computeCameraRayFromPixel(pixCoord, rayPos, rayDir);\n    \n    ShadeInfo infos[MAX_NB_BOUNCES];\n    int nbBounces = 0;\n    do\n    {\n        int objectId;\n        vec3 intersecI, normalI;\n        float distI = computeNearestIntersection(rayPos,rayDir,objectId,intersecI,normalI);\n        \n        if(distI <= 0.0)\n        {\n            infos[nbBounces].shadedCol = skyCol;\n            infos[nbBounces].Ks = 0.0;\n            break;\n        }\n        \n        \n    \tvec3 V = -rayDir;\n        Material objMat;\n    \tvec3 col = getObjectColorAtPoint(objectId, intersecI, objMat);\n        \n        vec3 c = vec3(0.);\n        \n        for(int i=0;i<NB_LIGHTS;i++)\n        {\n    \t\tvec3 L = normalize(lights[i].pos - intersecI);\n    \t\tvec3 R = normalize(2.0*dot(normalI,L)*normalI - L);\n        \n        \tfloat Ldist = distance(intersecI,lights[i].pos);\n        \n        \tfloat shadowFactor = getShadowFactorAtPoint(intersecI, normalI, objMat, L, Ldist);\n        \n    \t\t//Phong shading to get the color of the surface point\n    \t\tc += computePhongShading(col, objMat, shadowFactor, normalI, L, R, V, lights[i]);\n        }\n        \n        \n        infos[nbBounces].shadedCol = c;\n        infos[nbBounces].Ks = objMat.Ks;\n        \n        rayPos = intersecI + 0.001*normalI;\n        rayDir = normalize(2.0*dot(normalI,V)*normalI - V);\n        //objId = objectId;\n        \n        nbBounces++;\n        \n    }while(nbBounces < MAX_NB_BOUNCES);\n    \n    vec3 resCol = vec3(0);\n    \n   \tdo\n    {\n        resCol = infos[nbBounces].shadedCol + infos[nbBounces].Ks * resCol;\n        nbBounces--;\n    }while(nbBounces >= 0);\n    \n    return resCol;\n}\n\n//De facto \"noise\" function, modified to supply two values\n//Taken from: https://www.shadertoy.com/view/4dGXW1\nvec2 noise2(vec2 location, vec2 delta)\n{\n    const vec2 c = vec2(12.9898,78.233);\n    const float m = 43758.5453;\n    return vec2(\n        fract(sin(dot(location + delta, c)) * m),\n        fract(sin(dot(location + vec2(delta.y,delta.x),c)) * m)\n        );\n}\n\nvoid animateScene(float time)\n{\n    const float pi = 3.1415926535;\n    const float rs = 2.0;\n    const float spr = 5.0;\n    float as = 2.0 * pi * time / spr;\n    \n    spherePos = cameraTarget + rs * vec3(-sin(as),0.0,cos(as)) + vec3(0,1,0);\n    \n    light1Pos += vec3(0,10.5 + 9.5 * cos(time) - 10.,0);\n    \n    float targetDist = length(cameraTarget - cameraPos);\n    cameraPos -= vec3(0,0,targetDist);\n    cameraPos += targetDist * vec3(sin(time),max(sin(time*0.5),0.),cos(time));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    \n    animateScene(time*1.0);\n    \n    lights[0].pos = light1Pos;\n    lights[0].col = light1Col;\n    lights[0].power = light1Pow;\n    lights[1].pos = light2Pos;\n    lights[1].col = light2Col;\n    lights[1].power = light2Pow;    \n    \n    \n    \n    //Apply change of coordinates from pixel\n    fragCoord = transform_to_apply(fragCoord.xy);\n    \n    vec3 resCol = vec3(0);\n    \n    for (int i=0; i<PIXEL_SAMPLING_GRID_SIZE; i++) \n    {\n        for (int j=0; j<PIXEL_SAMPLING_SIZE; j++) \n        {\n            vec2 offset = vec2(float(i)/(float(PIXEL_SAMPLING_GRID_SIZE)*iResolution.x),float(j)/(float(PIXEL_SAMPLING_SIZE)*iResolution.y));\n            //vec2 q =  vec2(float(i), float(j));\n            //vec2 n = noise2( fragCoord , q );\n            //vec2 offset = vec2(n.x/800., n.y/600.);\n\t\t\tresCol += RaytraceAtPixelCoord(fragCoord + offset);\n      \t}\n    }\n    resCol /= float(PIXEL_SAMPLING_GRID_SIZE * PIXEL_SAMPLING_SIZE);\n    \n    fragColor = vec4(resCol,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtVfRm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtVfRW", "name": "Vesica - distance 2D", "author": "iq", "description": "Distance to a vesica shape (intersection of two disks). Can be seen as a special case of abje's crescent shape (https://www.shadertoy.com/view/XlVfz1)", "tags": ["2d", "distancefield", "sdf", "distance", "vesica", "vesica"], "likes": 14, "viewed": 1675, "date": "1542006212", "time_retrieved": "2024-06-20T19:25:31.774812", "image_code": "// The MIT License\n// Copyright ¬© 2018 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to an vesica (intersection of two disks). Can be seen as a\n// special case of abje's crescent shape (https://www.shadertoy.com/view/XlVfz1)\n\n// Note, interor distance is ont correct\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htmistfunctions2d.htm\n\n\nfloat sdVesica(vec2 p, float r, float d)\n{\n    p = abs(p);\n\n    float b = sqrt(r*r-d*d);  // can delay this sqrt by rewriting the comparison\n    return ((p.y-b)*d > p.x*b) ? length(p-vec2(0.0,b))*sign(d)\n                               : length(p-vec2(-d,0.0))-r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    float ra1 =       0.5*cos(iTime*1.1*0.5+0.5);\n    float ra2 = 0.1 + 0.1*sin(iTime*2.7*0.5+6.0);\n    float wid = max(0.5,ra1);\n    \n\tfloat d = sdVesica( p, wid, ra1 ) - ra2;\n\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-4.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(140.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.005,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = sdVesica(m, wid, ra1 ) - ra2;\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n   \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/XtVfRW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtVfRy", "name": "BARCODE", "author": "milolouis", "description": "barcode", "tags": ["barcode"], "likes": 4, "viewed": 101, "date": "1543175435", "time_retrieved": "2024-06-20T19:25:31.884067", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float ymod = cos(float(int(fragCoord.y) >> 3)) * 8.0;\n\n    // Time varying pixel color\n    float val = floor(1.0 + sin(iTime + (fragCoord.x / ymod)));\n    \n    // Output to screen\n    fragColor = vec4(vec3(val),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtVfRy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtVfRz", "name": "floating bubbles mask", "author": "perebalsach", "description": "random circles / bubbles floating", "tags": ["circles", "random"], "likes": 3, "viewed": 163, "date": "1541797679", "time_retrieved": "2024-06-20T19:25:32.174880", "image_code": "float noise1(vec2 p)\n{\n    p = fract(p * vec2(233.42, 865.32));\n    p += dot(p, p+32.33);\n    return fract(p.x * p.y);\n}\n\nvec2 noise2(vec2 p)\n{\n    float n = noise1(p);\n    return vec2(n, noise1(p+n));\n}\n\nvec2 getPos(vec2 id)\n{\n    vec2 noise = noise2(id);\n    \n    float x = sin(iTime * noise.x);\n    float y = cos(iTime * noise.y);\n    \n    return vec2(x, y) * 0.4;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - .5 * iResolution.xy) /iResolution.y;\n\n    // Time varying pixel color\n   \n    vec3 col = vec3(.0);\n    uv *= 5.0;\n    float m = .0;\n    \n    vec2 gridUv = fract(uv) -.5;\n    vec2 cellId = floor(uv);\n    \n    vec2 p = getPos(cellId);\n    float d = length(gridUv - p);\n    m = smoothstep(.1, .05, d);\n        \n    col = vec3(m);\n    \n    // Grid debug\n    // col.rg = gridUv;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtVfRz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtVfzW", "name": "Grid & Stochastic Antialiasing", "author": "dacruzquen", "description": "antialiasing", "tags": ["antialiasing"], "likes": 0, "viewed": 124, "date": "1542016691", "time_retrieved": "2024-06-20T19:25:33.520454", "image_code": "//link : \n\n//Material\nstruct Material\n{\n    float Ka;\n    float Kd;\n    float Ks;\n    float Kn;\n};\n\n//camera parameters\nvec3 cameraPos = vec3(6,4,-5);\nconst vec3 cameraTarget = vec3(3,1,-8);\nconst float cameraFovY = 80.0; // Note: angle is degree\n\n//Sphere parameters\nvec3 spherePos = cameraTarget + vec3(0,1,2);\nconst float sphereRadius = 1.0;\nconst vec3 sphereCol = vec3(1,0,0);\nconst Material sphereMat = Material(0.2,0.7,1.0,50.0);\nconst int sphereId = 1;\n\n//Light parameters\nconst vec3 ambiantCol = vec3(0,0,1);\nconst vec3 lightCol = vec3(1,1,1);\nvec3 lightPos = vec3(8,10,-12);\n\n//Sky parameters\nconst vec3 skyCol = vec3(0);\nconst int skyId = 0;\n\n//Plane parameters\nconst vec3 planePos = vec3(0, 0.1, 0);\nconst vec3 planeNormal = vec3(0,1.0,0);\nconst vec3 planeCol1 = vec3(1.0);\nconst vec3 planeCol2 = vec3(0.4);\nconst Material planeMat = Material(0.2,1.0,0.2,5.0);\nconst int planeId = 2;\n\nconst int PIXEL_SAMPLING_GRID_SIZE = 5;\nconst int PIXEL_SAMPLING_SIZE = 25;\n\nvec2 transform_to_apply(vec2 xy){\n    xy = (2.*xy.xy - iResolution.xy)/iResolution.y;\n    return vec2(xy.x,xy.y);\n}\n\nfloat raySphere(vec3 rayPos, vec3 rayDir, vec3 spherePos, float sphereRadius, out vec3 intersecS, out vec3 normalS)\n{    \n    vec3 diff = rayPos - spherePos;\n    \n    float a = dot(rayDir,rayDir);\n    float b = 2.0 * dot(diff,rayDir);\n    float c = dot(diff,diff) - sphereRadius * sphereRadius;\n    \n    float di = b*b - 4.0*a*c;\n    \n    if(di >= 0.0)\n    {\n        float sdi = sqrt(di);\n        float den = 1.0 / (2.0 * a);\n        float t1 = (-b - sdi) * den;\n        float t2 = (-b + sdi) * den;\n        \n        intersecS = rayPos + t1 * rayDir;\n        normalS = normalize(intersecS - spherePos);\n        \n        return t1;\n    }\n    \n    return -1.;\n}\n\nfloat rayPlane(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal, out vec3 intersecPt, out vec3 normal)\n{\n    if(dot(rayDir,planeNormal)!=0.0)\n    {\n        float t = dot(planePos - rayPos,planeNormal)/dot(rayDir,planeNormal);\n        \n        intersecPt = rayPos + t * rayDir;\n        normal = planeNormal;\n        \n        return t;\n    }\n    return -1.0;\n}\n\nvoid computeCameraRayFromPixel(in vec2 pixCoord, out vec3 rayPos, out vec3 rayDir)\n{\n    rayPos = cameraPos;\n    \n    float f = 1./tan(radians(cameraFovY)/2.);\n    \n    vec3 PT = cameraTarget - cameraPos;\n    vec3 cz = normalize(PT);\n    \n    vec3 PO = f*cz;\n    \n    vec3 cyT = vec3(0,-1.,0);\n    vec3 cxT = cross(cyT,cz);\n    \n    vec3 cx = normalize(cxT);\n    \n    vec3 cy = cross(cz,cx);\n    \n    vec3 OS = pixCoord.x * cx - pixCoord.y * cy;\n    \n    rayDir = normalize(PO+OS);\n}\n\nvec3 computePhongShading(vec3 sphereCol, Material sphereMat,float shadowFactor, vec3 normal, vec3 L, vec3 R, vec3 V)\n{\n    vec3 A = sphereMat.Ka * ambiantCol;\n    vec3 D = sphereMat.Kd * sphereCol * lightCol * max(dot(L,normal),0.0);\n    vec3 S = sphereMat.Ks * lightCol * pow(max(dot(R,V),0.0),sphereMat.Kn);\n    return A+shadowFactor*D+shadowFactor*S;\n}\n\n//The aim of this routine is to find the nearest intersection the ray has with all objects\nfloat computeNearestIntersection(vec3 rayPos, vec3 rayDir, out int objectId, out vec3 intersecI, out vec3 normalI)\n{\n    vec3 intersecS, normalS;\n    float distSphere = raySphere(rayPos, rayDir, spherePos, sphereRadius, intersecS, normalS);\n    vec3 intersecP, normalP;\n    float distPlane = rayPlane(rayPos, rayDir, planePos, planeNormal, intersecP, normalP);\n    if(distSphere > 0.0 && distPlane > 0.0)\n    {\n        float distMin = min(distSphere,distPlane);\n        objectId = (distSphere == distMin) ? sphereId : planeId; \n        intersecI = (distSphere == distMin) ? intersecS : intersecP; ;\n        normalI = (distSphere == distMin) ? normalS : normalP; ;\n        return distMin;\n    }\n    else\n    {\n        if(distSphere > 0.0)\n        {\n            objectId = sphereId;\n            intersecI = intersecS;\n            normalI = normalS;\n            return distSphere;\n        }\n        else if (distPlane > 0.0)\n        {\n            objectId = planeId;\n            intersecI = intersecP;\n            normalI = normalP;\n            return distPlane;\n        }\n        else\n        {\n           \tobjectId = skyId;\n            return -1.0;\n        }\n    }\n}\n\nvec3 getSphereColorAtPoint(vec3 pt)\n{\n    return sphereCol;\n}\n\n//pt is assumed to be on the place surface\nvec3 getPlaneColorAtPoint(vec3 pt)\n{\n    return mod(floor(pt.x*0.5) + floor(pt.z*0.5),2.0) < 1.0 ? planeCol1 : planeCol2;\n}\n\nvec3 getObjectColorAtPoint(int objectId, vec3 pt, out Material objectMat)\n{\n    switch(objectId)\n    {\n        case 0:\n        \treturn skyCol;\n        case 1:\n        \tobjectMat = sphereMat;\n        \treturn getSphereColorAtPoint(pt);\n        case 2:\n        \tobjectMat = planeMat;\n        \treturn getPlaneColorAtPoint(pt);\n    }\n}\nfloat getShadowFactorAtPoint(vec3 I, vec3 N, Material objectMat, vec3 L, float Ldist)\n{\n    I += 0.001*N;\n    int objId;\n    vec3 intersecS, normalS;\n    float d = computeNearestIntersection(I,L,objId,intersecS,normalS);\n    return (d<=0.0 || d>=Ldist)?1.0:objectMat.Ka;\n}\n\nvoid animateScene(float time)\n{\n    const float pi = 3.1415926535;\n    const float rs = 2.0;\n    const float spr = 5.0;\n    float as = 2.0 * pi * time / spr;\n    \n    spherePos = cameraTarget + rs * vec3(-sin(as),0.0,cos(as)) + vec3(0,1,0);\n    \n    lightPos += vec3(0,10.5 + 9.5 * cos(time) - 10.,0);\n    \n    float targetDist = length(cameraTarget - cameraPos);\n    cameraPos -= vec3(0,0,targetDist);\n    cameraPos += targetDist * vec3(sin(time),max(sin(time*0.5),0.),cos(time));\n}\n\nvec3 raycastAtPixelCoord(vec2 pixCoord)\n{\n    vec3 rayPos, rayDir;\n    computeCameraRayFromPixel(pixCoord, rayPos, rayDir);\n    \n    int objectId;\n    vec3 intersecI, normalI;\n    float distI = computeNearestIntersection(rayPos, rayDir, objectId, intersecI, normalI);\n    \n    if(distI <= 0.0)\n        return skyCol;\n    \n    vec3 L = lightPos - intersecI;\n    float Ldist = length(L);\n    L = L / Ldist;\n    \n    vec3 R = 2.0 * dot(normalI,L) * normalI - L;\n    \n    vec3 V = -rayDir;\n    \n    Material objectMat;\n    vec3 objectCol = getObjectColorAtPoint(objectId, intersecI, objectMat);\n    \n    float shadowFactor = getShadowFactorAtPoint(intersecI, normalI, objectMat, L, Ldist);\n    \n    vec3 resCol = computePhongShading(objectCol, objectMat, shadowFactor, normalI, L, R, V);\n    \n    return resCol;\n}\n\n//De facto \"noise\" function, modified to supply two values\n//Taken from: https://www.shadertoy.com/view/4dGXW1\nvec2 noise2(vec2 location, vec2 delta)\n{\n    const vec2 c = vec2(12.9898,78.233);\n    const float m = 43758.5453;\n    return vec2(\n        fract(sin(dot(location + delta, c)) * m),\n        fract(sin(dot(location + vec2(delta.y,delta.x),c)) * m)\n        );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    \n    animateScene(time*1.0);\n    \n    //Apply change of coordinates from pixel\n    fragCoord = transform_to_apply(fragCoord.xy);\n    \n    vec3 resCol = vec3(0);\n    \n    //Grid antialiasing\n    \n    /*for (int i=0; i<PIXEL_SAMPLING_GRID_SIZE; i++) \n    {\n        for (int j=0; j<PIXEL_SAMPLING_GRID_SIZE; j++) \n        {\n            vec2 offset = vec2(float(i)/(float(PIXEL_SAMPLING_GRID_SIZE)*800.),float(j)/(float(PIXEL_SAMPLING_SIZE)*600.));\n\t\t\tresCol += raycastAtPixelCoord(fragCoord + offset);\n      \t}\n    }\n    \n    resCol /= float(PIXEL_SAMPLING_GRID_SIZE * PIXEL_SAMPLING_GRID_SIZE);*/\n    \n    //Stochastic antialiasing\n    \n    for (int i=0; i<PIXEL_SAMPLING_SIZE; i++) \n    {\n        vec2 q =  vec2(float(i), float(i));\n        vec2 n = noise2( fragCoord , q );\n        vec2 offset = vec2(n.x/800., n.y/600.);\n\t\tresCol += raycastAtPixelCoord(fragCoord + offset);\n    }\n    resCol /= float(PIXEL_SAMPLING_SIZE);\n    \n    fragColor = vec4(resCol,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtVfzW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtyBR1", "name": "helpsquare", "author": "johnnyblame", "description": "wtf is this", "tags": ["shit"], "likes": 0, "viewed": 58, "date": "1541711012", "time_retrieved": "2024-06-20T19:25:33.526390", "image_code": "vec3 white = vec3(1,1,1);\nvec3 black = vec3(0,0,0);\nvec3 red = vec3(1, 0, 0);\n\nfloat sinp(float x) {\n    return abs(sin(x));\n}\n\nvec3 sp(vec2 c, float r, vec2 p) {\n    float d = length(p - c);\n    if (d < r)\n    {\n        if (sin(d) > 0.0) {\n            return sin((iTime*vec3(0, 0.5, 1)));    \n        }\n        else {\n      float d_norm = r / d;\n            return vec3(sinp(iTime)*d_norm);\n        }\n    }\n    else\n        return white;\n}\n\nvec3 sq(vec2 c, float bedro, vec2 p, float a) {\n  float r = bedro / 2.0;\n    mat2 rot_mat =mat2(\n        sin(a), cos(a),\n        sin(a), -sin(a)\n        );\n    vec2 p2 = p * rot_mat;\n    if (abs(p2.x - c.x) < r && abs(p2.y - c.y) < r)\n        return black;\n    else\n        return vec3(-1);\n    \n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 ccenter = iResolution.xy / 2.0;  \n    float cradius = (sinp(iTime* 2.0  ) * (iResolution.y / 2.0 ));\n   \n   vec3 col = sp(ccenter, cradius, fragCoord);\n    \n    float angle = abs(sin(iTime) * 2.0);\n    \n     vec3 sq_col = sq(vec2(sin(iTime) + 0.2) * iResolution.xy / 2.0,\n                     25.0, fragCoord, angle);\n    if (sq_col.x != -1.0)\n        col = sq_col;\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtyBR1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtyBRW", "name": "interactive shader test", "author": "cwervo", "description": "Drag your mouse ", "tags": ["interactive"], "likes": 1, "viewed": 70, "date": "1541886031", "time_retrieved": "2024-06-20T19:25:33.526546", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    // Shift downward a bit\n    uv.y -= 0.5;\n    // Normalize & flip across y-axis\n    uv += iMouse.xy/iResolution.xy * vec2(1.0, 1.0);\n    vec3 col = 0.5 + 0.5*tan(0.6*iTime+uv.xyx+vec3(0,2,4));\n    col = 0.5 + 0.5*cos(iTime*0.6+uv.xyx+vec3(0,2,4));\n    fragColor = vec4(col * (0.3 + uv.y),0.6);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtyBRW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtyBWW", "name": "voronoi gyroid", "author": "abje", "description": "It is a gyroid mixed with voronoi. It is fast because it doesn't have shadows/reflection.", "tags": ["3d", "raymarching", "voronoi", "gyroid"], "likes": 27, "viewed": 735, "date": "1542456606", "time_retrieved": "2024-06-20T19:25:33.526546", "image_code": "#define FAR 40.0\n#define EPS 0.001\n#define STEPS 1000\n\n#define voronoiscale 0.4\n#define voronoiscalefloor 1.0\n#define voronoiborder 0.1\n#define gyroidborder 0.03\n#define roundness 0.05\n#define edge 0.3\n\n#define ambient 0.3\n\n#define dot2(a) dot(a,a)\n#define rot(A) mat2(cos(A),-sin(A),sin(A),cos(A))\n\n#define PI acos(-1.0)\n\n#define HASHSCALE4 vec4(.1031, .1030, .0973, .01099)\n\nfloat torus(vec3 p, float r) {\n    vec2 q = vec2(length(p.xz)-r,p.y);\n    \n    return length(q);\n}\n\nfloat map(vec3 p) {\n    \n    vec3 s = sin(p);\n    vec3 c = cos(p.yzx);\n    float len = abs(dot(s,c)*0.7)-gyroidborder;\n    \n    //float t1 = torus(p+vec3(1,0,0),2.0);\n    //float t2 = torus(p.yzx-vec3(1,0,0).yzx,2.0);\n    //float len = abs(t1-t2)*max(t1,t2)*0.3-0.1;\n    \n    vec4 q = vec4(abs(p)-2.0*PI+roundness,len);\n    return length(max(q,0.0))*0.8+min(0.0,max(max(max(q.x,q.y),q.z),q.w))-roundness;\n}\n\n\n//if this is under 0, ignore voronoi\nfloat map2(vec3 p) {\n    \n    vec3 q = abs(p);\n    \n    float a = max(max(q.x,q.y),q.z);\n    \n    \n    return 2.0*PI-a-edge;\n}\n\nfloat planetrace(vec3 p, vec3 d,vec3 plane) {\n    float len = -min(dot(p,plane)+voronoiborder,0.0)/max(dot(d,plane),EPS);\n    return len;\n}\n\nvec3 hash34(vec4 p4)\n{\n\tp4 = fract(p4  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.zzyw)*p4.zywx).xyz;\n}\n\nvec3 noise(vec3 p3)\n{\n    //animated whitenoise, moving linearly to different random points\n    //float floortime = floor(iTime);\n    //return mix(hash34(vec4(p3,floortime)),hash34(vec4(p3,floortime+1.0)),iTime-floortime);\n    \n    //moving around in circles\n    return sin(vec3(iTime+p3.xzz*p3.yxy+p3))*0.5+0.5;\n    \n    //static procedual whitenoise\n    //return hash34(vec4(p3,0.75));\n    \n    //volume texture noise (fastest, for me at least)\n    //return (texelFetch(iChannel0,ivec3(mod(p3,32.0)),0).rgb-0.5)*0.5;\n}\n\nvec4 holes(vec3 ro, vec3 rd, float scale) {\n    /*\n    vec3 p = abs(mod(ro,0.2)-0.1);\n    \n    return -p.z+0.05;\n    */\n    \n    \n    ro /= scale;\n    \n    float len = 10000.0;\n    vec3 cell;\n    vec3 center = floor(ro);\n    vec3 center2;\n    \n    //finding closest voronoi cell\n    for(float x = -1.0; x <= 1.0; x++) {\n    \tfor(float y = -1.0; y <= 1.0; y++) {\n    \t\tfor(float z = -1.0; z <= 1.0; z++) {\n                vec3 orig = vec3(x,y,z)+center;\n                orig += noise(orig);\n                if (len > dot2(ro-orig)) {\n                    cell = orig;\n                    center2 = vec3(x,y,z)+center;\n                    len = dot2(ro-orig);\n                }\n            }\n    \t}\n    }\n    \n    \n    //raytracing\n    vec3 normal;\n    \n    len = 10000.0;\n    center = center2;\n    \n    for(float x = -1.0; x <= 1.0; x++) {\n        for(float y = -1.0; y <= 1.0; y++) {\n            for(float z = -1.0; z <= 1.0; z++) {\n                if (!(x==0.0&&y==0.0&&z==0.0)) {\n                    vec3 orig = vec3(x,y,z)+center;\n                    orig += noise(orig);\n                    vec3 mid = mix(orig,cell,0.5);\n                    vec3 plane = vec3((orig-cell));\n                    float num = planetrace(ro-vec3(mid),rd,plane);\n\n                    if (num < len) {\n                        len = num;\n                        normal = -plane;\n                    }\n                }\n            }\n        }\n    }\n    \n    return vec4(len*scale,normal);\n}\n\nvec3 normal(vec3 p) {\n    vec2 e = vec2(EPS,0);\n    \n    return normalize(vec3(\n        map(p+e.xyy),\n        map(p+e.yxy),\n        map(p+e.yyx))\n       -map(p));\n}\n\nvec3 normal2(vec3 p) {\n    vec2 e = vec2(EPS,0);\n    \n    return normalize(vec3(\n        map2(p+e.xyy),\n        map2(p+e.yxy),\n        map2(p+e.yyx))\n       -map2(p));\n}\n\nvec4 ray(vec3 ro, vec3 rd, float maxdist) {\n    float d = 0.0;\n    \n    vec3 n = vec3(-1);\n    for(int i = 0; i < STEPS; i++) {\n        vec3 p = ro+rd*d;\n        float l = map(p);\n        float l2 = map2(p);\n        \n        if (l < EPS && l2 > EPS) {\n            vec4 h = holes(p, rd, voronoiscale);\n            if (h.x > l) {\n                if (l2 < h.x) {\n                    n = vec3(-2);\n                    l = l2;\n                } else {\n                    n = h.yzw;\n                    l = h.x;\n                }\n            } else {\n                n = vec3(-1);\n            }\n        }\n        \n        d += l;\n        if (d > maxdist||l < EPS) {\n            break;\n        }\n    }\n    if (n == vec3(-1)) n = normal(ro+rd*d);\n    if (n == vec3(-2)) n = normal2(ro+rd*d);\n    return vec4(d,n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(0,0,-12.0);\n    vec3 rd = normalize(vec3(uv,1));\n    \n    if (length(iMouse.xy/iResolution.y) > 0.1) {\n        rd.yz *= rot(-iMouse.y/iResolution.y*3.14+3.14*0.5);\n        ro.yz *= rot(-iMouse.y/iResolution.y*3.14+3.14*0.5);\n        rd.xz *= rot(-iMouse.x/iResolution.x*6.28);\n        ro.xz *= rot(-iMouse.x/iResolution.x*6.28);\n    } else {\n        rd.xz *= rot(iTime*0.2);\n        ro.xz *= rot(iTime*0.2);\n    }\n    ro.y = max(ro.y-1.5,-2.0*PI+0.1);\n    \n    float plane;\n    if (rd.y >= 0.0) {\n        plane = FAR;\n    } else {\n        plane = min(-(ro.y+6.28)/rd.y,FAR);\n    }\n    \n    \n    vec4 r = ray(ro,rd, plane);\n    \n    vec3 background = vec3(0.2,0.4,0.3)*(rd.y*0.5+0.5)\n                     +vec3(0.4,0.2,0.5)*(dot(rd,vec3(-1.0/sqrt(3.0)))*0.5+0.5);\n    \n    background *= 0.2;\n    \n    if (r.x < plane) {\n        vec3 p = ro+rd*r.x;\n        vec3 n = r.yzw;\n        \n        fragColor = vec4(1);\n        \n        vec3 lightn = normalize(vec3(1));\n        float light = max(ambient, dot(n,lightn));\n        \n        fragColor *= light;\n        \n        fragColor = mix(fragColor,vec4(background,1), r.x/FAR);\n        \n    } else if (plane < FAR) {\n        r.x = plane;\n        vec3 p = ro+rd*plane;\n        vec3 n = vec3(0,1,0);\n        \n        //rd = refract(rd,n,0.9);\n        \n        vec4 vor = holes(p, rd, voronoiscalefloor);\n        \n        vec3 col;\n        \n        if (vor.x > 0.0) {\n            col = vec3(0.2,0.1,0.8);\n        } else {\n            col = vec3(0.5,0.5,0.0);\n        }\n            \n        vec3 lightn = normalize(vec3(1));\n        float light = max(ambient, dot(n,lightn));\n\n        col *= light;\n        \n        vec3 rd2 = reflect(rd,n);\n        \n        if (vor.x > 0.0) {\n            p += rd*vor.x;\n            r.x += vor.x;\n            n = vor.yzw;\n            fragColor = vec4(0.6,0.2,0.3,1);\n            \n            float light = max(ambient, dot(n,lightn));\n\t\t\t\n            fragColor *= light;\n            \n            fragColor.xyz = mix(fragColor.xyz,col,0.3);\n            \n        } else {\n            fragColor.xyz = col;\n        }\n        \n        fragColor += clamp(dot(rd2,lightn)*200.0-199.0,0.0,1.0);\n    }\n    fragColor = mix(fragColor,vec4(background,1), min(r.x/FAR,1.0));\n    \n    fragColor = sqrt(fragColor);\n}", "image_inputs": [{"id": "XdX3Rr", "previewfilepath": "/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtyBWW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtyfRz", "name": "Hex Fill", "author": "HyPeRbLaH", "description": "Fills from left to right with hexagons", "tags": ["hex"], "likes": 10, "viewed": 332, "date": "1541607417", "time_retrieved": "2024-06-20T19:25:34.144708", "image_code": "// Created by inigo quilez - iq/2014 -- Modified by Chad Allen\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat scale = 16.0;\n\n// sqrt(3.0) / 3.0\nfloat sqrt3d3 = 0.57735026918962576450914878050196;\nfloat twoSqrt3d3 = 1.1547005383792515290182975610039;\n\n// { 2d cell id, distance to border, distnace to center )\nvec4 hexagon( vec2 p ) \n{\n\tvec2 q = vec2( p.x*2.0*sqrt3d3, p.y + p.x*sqrt3d3 );\n\t\n\tvec2 pi = floor(q);\n\tvec2 pf = fract(q);\n\n\tfloat v = mod(pi.x + pi.y, 3.0);\n\n\tfloat ca = step(1.0,v);\n\tfloat cb = step(2.0,v);\n\tvec2  ma = step(pf.xy,pf.yx);\n\t\n    // distance to borders\n\tfloat e = dot( ma, 1.0-pf.yx + ca*(pf.x+pf.y-1.0) + cb*(pf.yx-2.0*pf.xy) );\n\n\t// distance to center\t\n\tp = vec2( q.x + floor(0.5+p.y/1.5), 4.0*p.y/3.0 )*0.5 + 0.5;\n\tfloat f = length( (fract(p) - 0.5)*vec2(1.0,0.85) );\t\t\n\t\n\treturn vec4( pi + ca - cb*ma, e, f );\n}\n\nfloat hash1( vec2  p ) { float n = dot(p,vec2(127.1,311.7) ); return fract(sin(n)*43758.5453); }\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\t//vec2 pos = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 pos = fragCoord.xy / iResolution.y;\n    float ratio = iResolution.x / iResolution.y;\n\t\n    // distort\n\t//pos *= 1.0 + 0.3*length(pos);\n\t\n    // gray\n\tvec4 h = hexagon(scale * pos);\n\t//float n = noise( vec3(0.3*h.xy+iTime*0.1,iTime) );\n    float t = iTime * 0.05;\n    float hash = hash1(h.xy);\n    //float sweepLine = (1.0 - fract(t)) * 1.2 - 0.1;\n    //float sweep = smoothstep(sweepLine - 0.05, sweepLine + 0.05, 1.0 - uv.x);// * scale + fract(t) * ratio * scale;\n    float hxToWidth = scale * ratio * twoSqrt3d3;\n    float front = -h.x + (fract(t) * 1.4 - 0.2 + hash * 0.15) * hxToWidth;\n\tfloat hx = h.x / hxToWidth + front;\n    \n    // h.x / scale * ratio * twoSqrt3d3 + (-h.x + (frace(t) * 1.4 - 0.2 + hash * 0.15) * scale * ratio * twoSqrt3d3;\n    \n    //vec4 col = textureLod(iChannel0, (h.xy + vec2(-iTime * 0.2, 0.0)) / 300.0, 0.0) * smoothstep(0.8, 1.0, hx * (h.z + 0.1));\n    vec4 cola = textureLod(iChannel0, (h.xy + floor(t) * 0.1) / 50.0, 0.0) * 0.2 + 0.1;\n    vec4 colb = textureLod(iChannel0, (h.xy + floor(t) * 0.2) / 40.0, 0.0) * 0.7 + 0.3;\n    vec4 bg = vec4(0.05, 0.35, 0.45, 1.0);\n    float growth = mix(smoothstep(0.75, 1.0, hx * (h.z + 0.025)), clamp(hx, 0.0, 1.0), mod(floor(t), 2.0));\n    vec4 col = mix(bg, mix(cola, colb, growth), smoothstep(0.05, 0.1, h.z));\n\t//col *= smoothstep( 0.10, 0.11, h.z );\n\t//col *= smoothstep( 0.10, 0.11, h.w );\n\t//col *= 1.0 + 0.15*sin(40.0*h.z);\n\t//col *= 0.75 + 0.5*h.z*n;\n\t\n\n\t// red\n\t//h = hexagon(6.0*pos + 0.6*iTime);\n\t//n = noise( vec3(0.3*h.xy+iTime*0.1,iTime) );\n\t//vec3 colb = 0.9 + 0.8*sin( hash1(h.xy)*1.5 + 2.0 + vec3(0.0,1.0,1.0) );\n\t//colb *= smoothstep( 0.10, 0.11, h.z );\n\t//colb *= 1.0 + 0.15*sin(40.0*h.z);\n\t//colb *= 0.75 + 0.5*h.z*n;\n\n\t//h = hexagon(6.0*(pos+0.1*vec2(-1.3,1.0)) + 0.6*iTime);\n    //col *= 1.0-0.8*smoothstep(0.45,0.451,noise( vec3(0.3*h.xy+iTime*0.1,iTime) ));\n\n\t//col = mix( col, colb, smoothstep(0.45,0.451,n) );\n\n\t// vignette\n\t//col *= pow( 16.0*uv.x*(1.0-uv.x)*uv.y*(1.0-uv.y), 0.1 );\n    //col *= step(0.0, uv.x - fract(iTime * 0.1));\n\t\n\tfragColor = col;\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtyfRz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xtyfz3", "name": "Stripe shader", "author": "nicolasrannou", "description": "Smoothed stripes", "tags": ["stripes", "smooth"], "likes": 4, "viewed": 83, "date": "1543322200", "time_retrieved": "2024-06-20T19:25:34.144708", "image_code": "// https://andreashackel.de/tech-art/stripes-shader-1/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float stripeWidth = 30.; //in pixels\n    float colorWidth = .6; // 20 %\n    float offset = 0.5 * (1. - colorWidth); //\n    float direction = -0.7; // 0: vertical, 1. horizontal\n    vec3 labelColor = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n \n    \n    float normalizedWidth = iResolution.x / stripeWidth;\n    float pos = mix(uv.x, uv.y, direction) * normalizedWidth;\n    float fracPos = fract(pos);\n    float smoothed = smoothstep(offset, offset + 2. / stripeWidth, fracPos) * (1. - smoothstep(1. - offset - 2. / stripeWidth, 1. - offset, fracPos));\n\n    fragColor = vec4(labelColor * smoothed, smoothed);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xtyfz3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
