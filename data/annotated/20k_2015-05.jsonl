{"id": "4l23RV", "name": "Ethereal onion", "author": "Aj_", "description": "An onion I came up with while learning stuff", "tags": ["happy", "onion"], "likes": 2, "viewed": 1082, "published": "Public API", "date": "1430470516", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    \n    vec2 res = iResolution.xy/abs(2./sin(iTime/4.));\n\tvec2 position = ( (fragCoord.xy - vec2(iResolution.x/2., iResolution.y/2.)) / max(res.y, res.x)  ) ;\n\tmat2 rot;\n\tfloat ang = -45. * 0.0174532925;\n\trot[0] = vec2(cos(ang), -sin(ang));\n\trot[1] = vec2(sin(ang), cos(ang));\t\n\tposition*=rot;\n\tfloat x = position.x;\n\tfloat y = position.y;\n\tfloat u,t;\n\t\n\tfor(int i=0;i<60;i++) {\n\t\tu = x*y*y  - y*y+x +.008 ;\n\t\tt = y*x*x  - x*x+y +.008 ;\n\t\t\n\t\t\n\t\tx = u;\n\t\ty = t;\n\t\tif(dot(vec2(u,t), vec2(u,t))>.08) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t}\n\t\n\tvec3 color =  vec3((x*y))*100.;\n\n\tfragColor = vec4(vec3(color.x/8., color.y/4., color.z/4.), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l23RV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 682]], "test": "valid"}
{"id": "4l23WV", "name": "Intro effect", "author": "Branch", "description": "Made for a small 1.7kb intro\nhttp://www.pouet.net/prod.php?which=65666", "tags": ["dunno"], "likes": 6, "viewed": 205, "published": "Public", "date": "1432566739", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float roundBox(vec2 coord, vec2 pos, vec2 b ){\n  return 1.-floor(length(max(abs(coord-pos)-b,0.0)));\n}\nmat2 rotate(float Angle)\n{\n    mat2 rotation = mat2(\n        vec2( cos(Angle),  sin(Angle)),\n        vec2(-sin(Angle),  cos(Angle))\n    );\n\treturn rotation;\n}\nfloat box(vec2 coord, vec2 pos, vec2 size){\n\tif((coord.x<(pos.x+size.x)) &&\n\t   (coord.x>(pos.x-size.x)) &&\n\t   (coord.y<(pos.y+size.y)) && \n\t   (coord.y>(pos.y-size.y)) ) \n\t\treturn 1.0;\n\treturn 0.0;\n}\nfloat sun(vec2 coord, vec2 pos, float size){\n\tif(length(coord-pos)<size)\n\t\treturn 1.0;\n\treturn 0.0;\n}\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat arrow(vec2 coord, vec2 pos){\n\treturn box(coord, pos, vec2(.4,.1))+box(coord, pos+vec2(.3,-.3), vec2(.1,.4));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tfloat t=iTime;\n\tvec4 tulos;\n\tvec4 lopullinentulos=vec4(1.0);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfloat aspectCorrection = (iResolution.x/iResolution.y);\n\tvec2 coordinate_entered = 2.0 * uv - 1.0;\n\tvec2 c = vec2(aspectCorrection,1.0) *coordinate_entered;\n\tfor(float rgbare=0.0; rgbare<2.0; rgbare++){\n\tvec2 coord = vec2(aspectCorrection,1.0) *coordinate_entered;\n\tcoord.x*=1.0+rgbare*0.009;\n\ttulos=vec4(vec3(255.0/255.0, 70.0/255.0, 65.0/255.0),1.0);\n\tfor(float i=0.; i<12.; i++){\n\t\ttulos+=4.*sun(coord, vec2(.5+sin(t*.1+i)*.4+rand(vec2(i,2.)*.1),mod(t*.2+i+t*i*.00123+rand(vec2(i,2.)),5.0)-2.5), .4*rand(vec2(i,4.3)))*15.;\n\t\ttulos-=sun(coord, vec2(.5+sin(t*.1+i)*.4+rand(vec2(i,2.)*.1),mod(t*.2+i+t*i*.00123+rand(vec2(i,2.)),5.0)-2.5), .4*rand(vec2(i,4.3))+0.04)*5.;\n\t}\n\ttulos+=arrow(vec2(mod(c.x-t*.5,1.2),mod(c.y-t*.3,1.)),vec2(.7))/3.;\n    vec2 pos=vec2(-.6,-.2+.1*sin(t*4.));\n\tfloat k1=floor(mod(iTime,2.))*.1;\n\tfloat k2=floor(mod(iTime+1.,2.))*.1;\n\tcoord*=rotate(floor(mod(iTime*.3,2.0))*.2-.1);\n\ttulos-=\t(box(coord*vec2(1.), vec2(.2,-.34-k1)+pos, vec2(.1,.2))+\n\t\t\tbox(coord*vec2(1.), vec2(-.2,-.34-k2)+pos, vec2(.1,.2))+\n\t\t\tbox(coord*vec2(1.), vec2(0.,.2)+pos, vec2(.4,.3))+\n\t\t\tbox(coord*vec2(1.), vec2(.55,.3-k2)+pos, vec2(.1,.2))+\n\t\t\tbox(coord*vec2(1.), vec2(-.55,.3-k1)+pos, vec2(.1,.2))+\n\t\t\tbox(coord*vec2(1.), vec2(0.,.75)+pos, vec2(.3,.2))-\n\t\t\tbox(coord*vec2(1.), vec2(0.,.75)+pos, vec2(.2,.1))*4. ) * 4.;\t\n\tif(rgbare==0.0)\n\t\tlopullinentulos.r=tulos.r;\n\tif(rgbare==1.0)\n\t\tlopullinentulos.gb=tulos.gb;\n\t}\n\tif(mod(fragCoord.y,2.0)<1.0)\n\tlopullinentulos.xyz=lopullinentulos.xyz/1.3;\n\tfloat vignette = min(max(1.4 / (1.25 + 0.28*dot(c, c)),0.),1.);\n\tfragColor = lopullinentulos*vignette-0.01+rand(c*t)*0.02;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l23WV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 46, 46, 102], [103, 103, 129, 129, 261], [262, 262, 305, 305, 463], [464, 464, 508, 508, 565], [566, 566, 586, 586, 658], [659, 659, 693, 693, 775], [776, 776, 832, 832, 2558]], "test": "valid"}
{"id": "4l23zc", "name": "Heartwing Angel", "author": "ChristinaCoffin", "description": "hacking fractals with warpy math and came across a heart/bird/flower -like shape and decided to animate it.", "tags": ["procedural", "fractal"], "likes": 88, "viewed": 3011, "published": "Public", "date": "1431022521", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// @christinacoffin\n// 2015-05-07: 1st version, need to optim and do some proper AA\n\nvec3 JuliaFractal(vec2 c, vec2 c2, float animparam, float anim2 ) {\t\n\tvec2 z = c;\n    \n\tfloat ci = 0.0;\n\tfloat mean = 0.0;\n    \n\tfor(int i = 0;i < 64; i++)\n    {\n\t\tvec2 a = vec2(z.x,abs(z.y));\n\t\t\n        float b = atan(a.y*(0.99+animparam*9.0), a.x+.110765432+animparam);\n\t\t\n        if(b > 0.0) b -= 6.303431307+(animparam*3.1513);\n\t\t\n        z = vec2(log(length(a*(0.98899-(animparam*2.70*anim2)))),b) + c2;\n\n        if (i>0) mean+=length(z/a*b);\n\n        mean+=a.x-(b*77.0/length(a*b));\n\n        mean = clamp(mean, 111.0, 99999.0);\n\t}\n    \n\tmean/=131.21;\n\tci =  1.0 - fract(log2(.5*log2(mean/(0.57891895-abs(animparam*141.0)))));\n\n\treturn vec3( .5+.5*cos(6.*ci+0.0),.5+.75*cos(6.*ci + 0.14),.5+.5*cos(6.*ci +0.7) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float animWings = 0.004 * cos(iTime*0.5);\n    float animFlap = 0.011 * sin(iTime*1.0);    \n    float timeVal = 56.48-20.1601;\n\tvec2 uv = fragCoord.xy - iResolution.xy*.5;\n\tuv /= iResolution.x*1.5113*abs(sin(timeVal));\n    uv.y -= animWings*5.0; \n\tvec2 tuv = uv*125.0;\n\tfloat rot=3.141592654*0.5;\n  \n\tuv.x = tuv.x*cos(rot)-tuv.y*sin(rot);\n\tuv.y =1.05* tuv.x*sin(rot)+tuv.y*cos(rot);\n\tfloat juliax = tan(timeVal) * 0.011 + 0.02/(fragCoord.y*0.19531*(1.0-animFlap));\n\tfloat juliay = cos(timeVal * 0.213) * (0.022+animFlap) + 5.66752-(juliax*1.5101);//+(fragCoord.y*0.0001);// or 5.7\n    \n \n    float tapU = (1.0/ float(iResolution.x))*25.5;//*cos(animFlap);\n    float tapV = (1.0/ float(iResolution.y))*25.5;//*cos(animFlap);\n    \n  \n\tfragColor = vec4( JuliaFractal(uv+vec2(0.0,0.0), vec2(juliax, juliay), animWings, animFlap ) ,1.0);\n    \n    fragColor += vec4( JuliaFractal(uv+vec2(tapU,tapV), vec2(juliax, juliay), animWings, animFlap ) ,1.0);\n//    fragColor += vec4( JuliaFractal(uv+vec2(tapU,-tapV), vec2(juliax, juliay), animWings, animFlap ) ,1.0);\n//    fragColor += vec4( JuliaFractal(uv+vec2(-tapU,tapV), vec2(juliax, juliay), animWings, animFlap ) ,1.0);\n    fragColor += vec4( JuliaFractal(uv+vec2(-tapU,-tapV), vec2(juliax, juliay), animWings, animFlap ) ,1.0);  \n    fragColor *= 0.3333;\n    \n    fragColor.xyz = fragColor.zyx;\n\tfragColor.xyz = vec3(1)-fragColor.xyz;\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l23zc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 85, 152, 152, 804], [807, 807, 864, 864, 2251]], "test": "valid"}
{"id": "4l2GWK", "name": "Interference2", "author": "alan2here", "description": "Odd effect, may be hardware dependent.", "tags": ["interference"], "likes": 1, "viewed": 107, "published": "Public", "date": "1432480329", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat zoom = iTime * 0.05 + 1.0;\n    zoom = pow(2.0, pow(zoom, zoom) - 1.0) - 1.0;\n    vec2 uv = (fragCoord.xy / iResolution.xy) / vec2(zoom, zoom);\n    fragColor = vec4(\n        mod(1.0 / uv.y, uv.x) / uv.x,\n        mod(4.0 / uv.y, uv.x) / uv.x,\n        mod(16.0 / uv.y, uv.x) / uv.x,\n        1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l2GWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 358]], "test": "valid"}
{"id": "4lB3DG", "name": "Glowing thing", "author": "denzen", "description": "My first nice-looking (or at least not-too-bad-looking) fragment shader. \\o/", "tags": ["2d", "2tweets", "2tc"], "likes": 6, "viewed": 1281, "published": "Public", "date": "1431685459", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 f, vec2 u )\n{\n\tu /= iResolution.xy;\n    f.xy = .5 - u;\n\n    float t = iTime,\n          z = atan(f.y,f.x) * 3.,\n          v = cos(z + sin(t * .1)) + .5 + sin(u.x * 10. + t * 1.3) * .4;\n\n    f.x = 1.2 + cos(z - t*.2) + sin(u.y*10.+t*1.5)*.5;\n\tf.yz = vec2( sin(v*4.)*.25, sin(v*2.)*.3 ) + f.x*.5;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lB3DG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 319]], "test": "valid"}
{"id": "4lB3WK", "name": "raymarching is so awesome", "author": "public_int_i", "description": "there's just so much stuff you can do with ray marching", "tags": ["3d", "raymarch"], "likes": 6, "viewed": 696, "published": "Public API", "date": "1432993658", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define FOV_SCALE 1.\n#define EPSILON .008\nconst vec3 ne = vec3(.0004435,0.,0.);\nconst vec3 repeat = vec3(20.,0.,20.);\nconst vec3 repeat2 = repeat/2.;\n\nfloat df(in vec3 p) {\n    vec3 ap = abs(p);\n    vec3 r = mod(ap,repeat)-repeat2;\n    float d = min(1.+p.y,\n                  length(max(abs(r)-vec3(2.,40.,2.),0.)));\n    \n    float dp = cos(ap.x+ap.z)*.5+.5;\n    ap.y += dp;\n    d = max(-(length(mod(ap,vec3(5.))-vec3(2.5))-2.), d);\n\n    return d;\n}\nvec3 nrm(in vec3 p) {\n    return normalize(vec3(df(p+ne)-df(p-ne),\n                     df(p+ne.yxz)-df(p-ne.yxz),\n                     df(p+ne.yzx)-df(p-ne.yzx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - vec2(.5);\n    uv.y *= iResolution.y/iResolution.x;\n\t\n    vec3 ld = normalize(vec3(500.,100.,200.));\n    float ct = iTime*10.;\n    vec3 rp = vec3(0.,20.,ct);\n    vec3 rd = normalize(vec3(0.,-2.,10.));\n    vec3 srd = rd;\n    vec3 rr = cross(vec3(0.,1.,0.),rd);\n    rd = normalize(rd*FOV_SCALE + uv.x*rr + uv.y*cross(rd,rr));\n    //rr = vec3(0.,0.,0.)*.001;\n    \n    float d,s = 0.;\n    for (int i = 0; i < 256; i++) {\n        d = df(rp);\n        if (d < EPSILON) break;\n        \n        rp += d*rd;\n        s += d*.02;\n        //rd = normalize(rd+d*rr);\n        rr = cross(normalize(vec3(sin(s),cos(s),sin(s))),rd);\n    \trd = normalize(srd*FOV_SCALE + uv.x*rr + uv.y*cross(rd,rr));\n    }\n    \n    vec3 c;\n    if (d < EPSILON) {\n        vec3 n = nrm(rp);\n        c = texture(iChannel0,(rp.xy+rp.zx*.5)*.1).xyz;\n        \n        rd = n;\n        rp -= rd*d;\n        for (int i = 0; i < 4; i++) {\n            d = df(rp);\n            if (d < EPSILON) break;\n        }\n        \n        c = .14*c +\n            max(0.,dot(ld,n))*c;\n    } else {\n        c = vec3(.9);\n    }\n    \n    fragColor = vec4(pow(c*2.0,vec3(1.2,1.2,1.3)),1.);\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lB3WK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[151, 151, 172, 172, 449], [450, 450, 471, 471, 616], [618, 618, 675, 675, 1844]], "test": "error"}
{"id": "4lBGWK", "name": "Simple Shadow Scene", "author": "Yevano", "description": "Playing with shadows.", "tags": ["raymarch", "shadows"], "likes": 2, "viewed": 189, "published": "Public", "date": "1432234631", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define EPSILON 0.001\n#define MAX_DIST 30.\n\nvec3 lightPos = vec3(0, 0., 0.);\n\nstruct HitInfo {\n    float d;\n    vec3 c;\n    vec3 p;\n};\n\nfloat sphere(vec3 pos, float r) {\n    return length(pos) - r;\n}\n\nfloat box(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n  \treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nHitInfo map(vec3 pos, vec3 rd) {\n    HitInfo hit = HitInfo(9999., vec3(0., 0., 0.), pos);\n    float nd;\n    \n    nd = sphere(vec3(pos.xz, pos.y/(sin(iTime)+1.5)).xzy, 1.);\n    if(nd < hit.d) hit = HitInfo(nd, vec3(1., 0., 0.), pos);\n    nd = box(pos - vec3(0., -3, 0.), vec3(1000., 0.5, 1000.));\n    if(nd < hit.d) hit = HitInfo(nd, texture(iChannel0, pos.xz/10.).rgb, pos);\n    \n    return hit;\n}\n#define AAA 0.1\nmat2 getRotMat(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nHitInfo march(in vec3 ro, in vec3 rd, bool right) {\n    if(right) {\n        ro.xz *= getRotMat(AAA);\n    } else {\n        ro.xz *= getRotMat(-AAA);\n    }\n    HitInfo ret = HitInfo(1000., vec3(0.), ro);\n    bool didHit = false;\n    float l = 0.;\n    for(int i = 0; i < 100; i++) {\n        vec3 r = ro + rd * l;\n        HitInfo hit = map(r, rd);\n        if(hit.d <= EPSILON) {\n            ret = HitInfo(l, hit.c, r);\n            didHit = true;\n            break;\n        }\n        if(hit.d > MAX_DIST) {\n            break;\n        }\n        l += hit.d;\n    }\n    \n    if(!didHit) return ret;\n    \n    ro = ro + rd * l;\n    rd = normalize(lightPos - ro);\n    l = 0.1;\n    for(int i = 0; i < 50; i++) {\n        vec3 r = ro + rd * l;\n        HitInfo hit = map(r, rd);\n        if(hit.d <= EPSILON) {\n            ret.c*=0.5;\n            return ret;\n        }\n        if(distance(r, lightPos) < hit.d) {\n            return ret;\n        }\n        l += min(hit.d, distance(r, lightPos));\n    }\n    \n    return ret;\n}\n\nvec3 pixel(vec2 uv) {\n    vec3 ro = vec3(0., 0., -6.);\n    vec3 rd = normalize(vec3(uv, 1.));\n    HitInfo hit = march(ro, rd, uv.x > 0.);\n    float i = smoothstep(20., 0., distance(hit.p, lightPos));\n    return hit.c * i;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    uv.x -= iResolution.x/iResolution.y/2.;\n    uv.y -= .5;\n    lightPos = vec3(sin(iTime)*4., 2., cos(iTime)*4.);\n\tfragColor = vec4(pixel(uv), 1.);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lBGWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[136, 136, 169, 169, 199], [201, 201, 228, 228, 318], [320, 320, 352, 352, 717], [734, 734, 759, 759, 811], [813, 813, 864, 864, 1819], [1821, 1821, 1842, 1842, 2044], [2046, 2046, 2103, 2103, 2337]], "test": "error"}
{"id": "4lBGzt", "name": "Geyser (Fast Water)", "author": "bbcollinsworth", "description": "A mod of xbe's \"fires\" to create a fast, smooth falling water effect.", "tags": ["procedural", "2d", "noise", "water", "fluid", "waterfall", "waterspout"], "likes": 66, "viewed": 2510, "published": "Public", "date": "1431209036", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//////////////////////\n// GEYSER based on Fire Flame shader by xbe\n\n// procedural noise from IQ\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t dot(p,vec2(269.5,183.3)) );\n    //setting p mult to 0.0001 seems to get slightly smoother results\n\treturn -1.0 + 2.0*fract(sin(p*0.0001)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n\tconst float K1 = 0.366025404; // (sqrt(3)-1)/2;\n\tconst float K2 = 0.211324865; // (3-sqrt(3))/6;\n\t\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n\tvec2 a = p - i + (i.x+i.y)*K2;\n\tvec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);\n\tvec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\t\n\tvec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\t\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\t\n\treturn dot( n, vec3(70.0) );\n}\n\nfloat fbm(vec2 uv)\n{\n\tfloat f;\n\tmat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tf  = 0.5000*noise( uv ); uv = m*uv;\n\tf += 0.2500*noise( uv ); uv = m*uv;\n\tf += 0.1250*noise( uv ); uv = m*uv;\n\tf += 0.0625*noise( uv ); uv = m*uv;\n    //increasing first float here widens flow\n\tf = 0.6 + 0.5*f;\n\treturn f;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n\t//vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uv = (fragCoord.xy/iResolution.x)*2.0-vec2(1.0,iResolution.y/iResolution.x);\n\tvec2 q = -uv;\n    \n    //These functions scale the fire... higher# = smaller:\n\t//q.x *= 2.;//q.x +=sin(iTime);\n\t//q.y *= 2.;//+cos(iTime);\n\tfloat strength = floor(6.);//floor(q.x+1.); +sin(iTime*0.1)\n    \n    //float strength = abs(sin(iTime*0.01))*15.;\n    \n    //THIS CONTROLS SPEED OF FALL:\n    //Pow & Q.Y controls downward accell\n    //could use time mult to change with LIFT?\n\tfloat T3 = max(3.,1.25*strength)*iTime*0.6+pow(abs(q.y),1.25)*2.; // +q.y*q.y*2.//2.*sin(q.y*2.) DO THIS FOR SHIMMERY SURFACE EFFECT: *uv.y;\n    \n\tfloat n = fbm(vec2(strength*q.x,strength*q.y) - vec2(0,T3));\n    strength=26.;\n    float T3B = max(3.,1.25*strength)*iTime*0.6+pow(abs(q.y),1.25)*2.;\n    n = n*0.5 + (n*0.5)/(0.001+1.5*fbm(vec2(strength*q.x,strength*q.y) - vec2(0,T3B)));\n    \n    //this controls width:\n    float intensity = abs(sin(iTime*0.2));\n    n*=1.+pow(intensity,8.)*0.5;\n    \n    //adjusting the 16 divisor makes water fuzzier as it drops...increasing 16 makes top sharper, lower makes fuzzier\n\t//Second part of this adjusts shape\n    float c = 1. - (16./abs(pow(q.y,1.)*4.+1.)) * pow( max( 0., length(q*vec2(1.8+q.y*1.5,.75) ) - n * max( 0., q.y+.25 ) ),1.2 );\n//\tfloat c1 = n * c * (1.5-pow(1.25*uv.y,4.));\n    \n    //adjusting float before power changes intensity; lower number inside power is higher flame height\n    float c1 = n * c * ((0.7+pow(intensity,0.8)*0.9-pow(intensity,4.)*0.4)-pow((1.0)*uv.y,2.));//-abs(sin(iTime*0.2))*uv.y\n    \n    c1= c1*1.05+sin(c1*3.4)*0.4;\n    c1*=0.95-pow(q.y,2.0);\n    c1=clamp(c1,0.4,1.0);\n    \n\t//mix the color:\n\tvec3 col = vec3(1.5*c1*c1*c1, 1.5*c1*c1*c1*c1, 1.25*c1*c1*c1*c1);\n\n\t\n\tcol = col.zyx;\n\n\tfloat a = c * (1.-pow(abs(uv.y),10.));\n\tvec4 waterColor = vec4( mix(vec3(0.),col,a), 1.0);\n    \n    fragColor = waterColor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lBGzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 96, 117, 117, 313], [315, 315, 341, 341, 799], [801, 801, 821, 821, 1097], [1101, 1101, 1158, 1212, 3072]], "test": "valid"}
{"id": "4ljGDy", "name": "The Fuzz!", "author": "CloneDeath", "description": "The fuzz are here to catch him!", "tags": ["fuzzpolicesirens"], "likes": 1, "viewed": 1127, "published": "Public API", "date": "1432074456", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixelCoords =  fragCoord.xy / iResolution.xy;\n    \n    pixelCoords.y += (sin((iTime * 3.0) + (pixelCoords.x * 3.0)) + 1.0) / 4.0;\n    pixelCoords.y -= 0.25;\n    \n    vec4 manFighting = texture(iChannel0, pixelCoords);\n    \n    vec4 color = manFighting;\n    float redAmount = sin(iTime * 9.0) / 2.0;\n    color.r += redAmount;\n    color.gba -= redAmount;\n    \n    \n    vec2 backgroundSample = fragCoord.xy / iResolution.xy;\n    backgroundSample.y *= -1.0;\n    vec4 starrySky = texture(iChannel1, backgroundSample);\n    \n    if (manFighting.g > manFighting.r + manFighting.b){\n     \tfragColor = starrySky;   \n    } else {\n     \tfragColor = color;   \n    }\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}, {"id": "XdfGRr", "previewfilepath": "/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ljGDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 721]], "test": "error"}
{"id": "4ljGRd", "name": "Annotated Ray Tracing", "author": "Polytonic", "description": "See https://www.tinycranes.com/blog/2015/05/annotated-realtime-raytracing/", "tags": ["raytracing", "spheres"], "likes": 115, "viewed": 17686, "published": "Public", "date": "1431467551", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Ray tracing is a topic I have always wanted to explore, but never really had\n// the opportunity to do so until now. What exactly is ray tracing? Consider a\n// lamp hanging from the ceiling. Light is constantly being emitted from the\n// lamp in the form of light rays, which bounce around the room until they hit\n// your eye. Ray tracing follows a similar concept by simulating the path of\n// light through a scene, except in reverse. There is no point in doing the math\n// for light rays you cannot see!\n\n// Algorithmically, ray tracing is very elegant. For each pixel, shoot a light\n// ray from the camera through each pixel on screen. If the ray collides with\n// geometry in the scene, create new rays that perform the same process for both\n// reflection, as in a mirror, and refraction, as in through water. Repeat\n// to your satisfaction.\n\n// Having worked extensively with OpenCL in the past, this seemed like a good\n// candidate to port to a parallel runtime on a GPU. Inspired by the [smallpt](http://www.kevinbeason.com/smallpt/#moreinfo)\n// line-by-line explanation, I decided to write a parallel ray tracer with\n// extensive annotations. The results are below ...\n\n// ![screenshot](/uploads/raytracer.png)\n\n// I start with a simple ray definition, consisting of an origin point and a\n// direction vector. I also define a directional light to illuminate my scene.\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Light {\n    vec3 color;\n    vec3 direction;\n};\n\n// In real life, objects have many different material properties. Some objects\n// respond very differently to light than others. For instance, a sheet of paper\n// and a polished mirror. The former exhibits a strong *diffuse* response;\n// incoming light is reflected at many angles. The latter is an example of a\n// *specular* response, where incoming light is reflected in a single direction.\n// To model this, I create a basic material definition. Objects in my scene\n// share a single (RGB) color with diffuse and specular weights.\nstruct Material {\n    vec3 color;\n    float diffuse;\n    float specular;\n};\n\n// To render the scene, I need to know where a ray intersects with an object.\n// Since rays have infinite length from an origin, I can model the point of\n// intersection by storing the distance along the ray. I also need to store the\n// surface normal so I know which way to bounce! Once I create a ray, it loses\n// the concept of scene geometry, so one more thing I do is forward the surface\n// material properties.\nstruct Intersect {\n    float len;\n    vec3 normal;\n    Material material;\n};\n\n// The last data structures I create are for objects used to fill my scene. The\n// most basic object I can model is a sphere, which is defined as a radius at\n// some center position, with some material properties. To draw the floor, I\n// also define a simple horizontal plane centered at the origin, with a normal\n// vector pointing upwards.\nstruct Sphere {\n    float radius;\n    vec3 position;\n    Material material;\n};\n\nstruct Plane {\n    vec3 normal;\n    Material material;\n};\n\n// At this point, I define some global variables. A more advanced program might\n// pass these values in as uniforms, but for now, this is easier to tinker with.\n// Due to floating point precision errors, when a ray intersects geometry at a\n// surface, the point of intersection could possibly be just below the surface.\n// The subsequent reflection ray would then bounce off the *inside* wall of the\n// surface. This is known as self-intersection. When creating new rays, I\n// initialize them at a slightly offset origin to help mitigate this problem.\nconst float epsilon = 1e-3;\n\n// The classical ray tracing algorithm is recursive. However, GLSL does not\n// support recursion, so I instead use an iterative approach to control the\n// number of light bounces.\nconst int iterations = 16;\n\n// Next, I define an exposure time and gamma value. At this point, I also create\n// a basic directional light and define the ambient light color; the color here\n// is mostly a matter of taste. Basically ... lighting controls.\nconst float exposure = 1e-2;\nconst float gamma = 2.2;\nconst float intensity = 100.0;\nconst vec3 ambient = vec3(0.6, 0.8, 1.0) * intensity / gamma;\n\n// For a Static Light\nLight light = Light(vec3(1.0) * intensity, normalize(vec3(-1.0, 0.75, 1.0)));\n\n// For a Rotating Light\n// Light light = Light(vec3(1.0) * intensity, normalize(\n//                vec3(-1.0 + 4.0 * cos(iTime), 4.75,\n//                      1.0 + 4.0 * sin(iTime))));\n\n// I strongly dislike this line. I needed to know when a ray hits or misses a\n// surface. If it hits geometry, I returned the point at the surface. Otherwise,\n// the ray misses all geometry and instead hits the sky box. In a language that\n// supports dynamic return values, I could `return false`, but that is not an\n// option in GLSL. In the interests of making progress, I created an intersect\n// of distance zero to represent a miss and moved on.\nconst Intersect miss = Intersect(0.0, vec3(0.0), Material(vec3(0.0), 0.0, 0.0));\n\n// As indicated earlier, I implement ray tracing for spheres. I need to compute\n// the point at which a ray intersects with a sphere. [Line-Sphere](http://en.wikipedia.org/wiki/Line-sphere_intersection)\n// intersection is relatively straightforward. For reflection purposes, a ray\n// either hits or misses, so I need to check for no solutions, or two solutions.\n// In the latter case, I need to determine which solution is \"in front\" so I can\n// return an intersection of appropriate distance from the ray origin.\nIntersect intersect(Ray ray, Sphere sphere) {\n    // Check for a Negative Square Root\n    vec3 oc = sphere.position - ray.origin;\n    float l = dot(ray.direction, oc);\n    float det = pow(l, 2.0) - dot(oc, oc) + pow(sphere.radius, 2.0);\n    if (det < 0.0) return miss;\n\n    // Find the Closer of Two Solutions\n             float len = l - sqrt(det);\n    if (len < 0.0) len = l + sqrt(det);\n    if (len < 0.0) return miss;\n    return Intersect(len, (ray.origin + len*ray.direction - sphere.position) / sphere.radius, sphere.material);\n}\n\n// Since I created a floor plane, I likewise have to handle reflections for\n// planes by implementing [Line-Plane](http://en.wikipedia.org/wiki/Line-plane_intersection)\n// intersection. I only care about the intersect for the purposes of reflection,\n// so I only check if the quotient is non-zero.\nIntersect intersect(Ray ray, Plane plane) {\n    float len = -dot(ray.origin, plane.normal) / dot(ray.direction, plane.normal);\n    if (len < 0.0) return miss;\n    return Intersect(len, plane.normal, plane.material);\n}\n\n// In a *real* ray tracing renderer, geometry would be passed in from the host\n// as a mesh containing vertices, normals, and texture coordinates, but for the\n// sake of simplicity, I hand-coded the scene-graph. In this function, I take an\n// input ray and iterate through all geometry to determine intersections.\nIntersect trace(Ray ray) {\n    const int num_spheres = 3;\n    Sphere spheres[num_spheres];\n\n    // I initially started with the [smallpt](www.kevinbeason.com/smallpt/)\n    // scene definition, but soon found performance was abysmal on very large\n    // spheres. I kept the general format, modified to fit my data structures.\n\n    spheres[0] = Sphere(2.0, vec3(-4.0, 3.0 + sin(iTime), 0), Material(vec3(1.0, 0.0, 0.2), 1.0, 0.001));\n    spheres[1] = Sphere(3.0, vec3( 4.0 + cos(iTime), 3.0, 0), Material(vec3(0.0, 0.2, 1.0), 1.0, 0.0));\n    spheres[2] = Sphere(1.0, vec3( 0.5, 1.0, 6.0),                  Material(vec3(1.0, 1.0, 1.0), 0.5, 0.25));\n\n    // Since my ray tracing approach involves drawing to a 2D quad, I can no\n    // longer use the OpenGL Depth and Stencil buffers to control the draw\n    // order. Drawing is therefore sensitive to z-indexing, so I first intersect\n    // with the plane, then loop through all spheres back-to-front.\n\n    Intersect intersection = miss;\n    Intersect plane = intersect(ray, Plane(vec3(0, 1, 0), Material(vec3(1.0, 1.0, 1.0), 1.0, 0.0)));\n    if (plane.material.diffuse > 0.0 || plane.material.specular > 0.0) { intersection = plane; }\n    for (int i = 0; i < num_spheres; i++) {\n        Intersect sphere = intersect(ray, spheres[i]);\n        if (sphere.material.diffuse > 0.0 || sphere.material.specular > 0.0)\n            intersection = sphere;\n    }\n    return intersection;\n}\n\n// This is the critical part of writing a ray tracer. I start with some empty\n// scratch vectors for color data and the Fresnel factor. I trace the scene with\n// using an input ray, and continue to fire new rays until the iteration depth\n// is reached, at which point I return the total sum of the color values from\n// computed at each bounce.\nvec3 radiance(Ray ray) {\n    vec3 color = vec3(0.0), fresnel = vec3(0.0);\n    vec3 mask = vec3(1.0);\n    for (int i = 0; i <= iterations; ++i) {\n        Intersect hit = trace(ray);\n\n        // This goes back to the dummy \"miss\" intersect. Basically, if the scene\n        // trace returns an intersection with either a diffuse or specular\n        // coefficient, then it has encountered a surface of a sphere or plane.\n        // Otherwise, the current ray has reached the ambient-colored sky box.\n\n        if (hit.material.diffuse > 0.0 || hit.material.specular > 0.0) {\n\n            // Here I use the [Schlick Approximation](http://en.wikipedia.org/wiki/Schlick's_approximation)\n            // to determine the Fresnel specular contribution factor, a measure\n            // of how much incoming light is reflected or refracted. I compute\n            // the Fresnel term and use a mask to track the fraction of\n            // reflected light in the current ray with respect to the original.\n\n            vec3 r0 = hit.material.color.rgb * hit.material.specular;\n            float hv = clamp(dot(hit.normal, -ray.direction), 0.0, 1.0);\n            fresnel = r0 + (1.0 - r0) * pow(1.0 - hv, 5.0);\n            mask *= fresnel;\n\n            // I handle shadows and diffuse colors next. I condensed this part\n            // into one conditional evaluation for brevity. Remember `epsilon`?\n            // I use it to trace a ray slightly offset from the point of\n            // intersection to the light source. If the shadow ray does not hit\n            // an object, it will be a \"miss\" as it hits the skybox. This means\n            // there are no objects between the point and the light, at which\n            // point I can add the diffuse color to the fragment color since the\n            // object is not in shadow.\n\n            if (trace(Ray(ray.origin + hit.len * ray.direction + epsilon * light.direction, light.direction)) == miss) {\n                color += clamp(dot(hit.normal, light.direction), 0.0, 1.0) * light.color\n                       * hit.material.color.rgb * hit.material.diffuse\n                       * (1.0 - fresnel) * mask / fresnel;\n            }\n\n            // After computing diffuse colors, I then generate a new reflection\n            // ray and overwrite the original ray that was passed in as an\n            // argument to the radiance(...) function. Then I repeat until I\n            // reach the iteration depth.\n\n            vec3 reflection = reflect(ray.direction, hit.normal);\n            ray = Ray(ray.origin + hit.len * ray.direction + epsilon * reflection, reflection);\n\n        } else {\n\n            // This is the other half of the tracing branch. If the trace failed\n            // to return an intersection with an attached material, then it is\n            // safe to assume that the ray points at the sky, or out of bounds\n            // of the scene. At this point I realized that real objects have a\n            // small sheen to them, so I hard-coded a small spotlight pointing\n            // in the same direction as the main light for pseudo-realism.\n\n            vec3 spotlight = vec3(1e6) * pow(abs(dot(ray.direction, light.direction)), 250.0);\n            color += mask * (ambient + spotlight); break;\n        }\n    }\n    return color;\n}\n\n// The main function primarily deals with organizing data from OpenGL into a\n// format that the ray tracer can use. For ray tracing, I need to fire a ray for\n// each pixel, or more precisely, a ray for every fragment. However, pixels to\n// fragment coordinates do not map one a one-to-one basis, so I need to divide\n// the fragment coordinates by the viewport resolution. I then offset that by a\n// fixed value to re-center the coordinate system.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv    = fragCoord.xy / iResolution.xy - vec2(0.5);\n         uv.x *= iResolution.x / iResolution.y;\n\n    // For each fragment, create a ray at a fixed point of origin directed at\n    // the coordinates of each fragment. The last thing before writing the color\n    // to the fragment is to post-process the pixel values using tone-mapping.\n    // In this case, I adjust for exposure and perform linear gamma correction.\n\n    Ray ray = Ray(vec3(0.0, 2.5, 12.0), normalize(vec3(uv.x, uv.y, -1.0)));\n    fragColor = vec4(pow(radiance(ray) * exposure, vec3(1.0 / gamma)), 1.0);\n}\n\n// If all goes well, you should see an animated scene below!\n// <iframe src=\"https://www.shadertoy.com/embed/4ljGRd?gui=true&paused=false\"\n//         width=\"100%\" height=\"380px\" frameborder=\"0\" allowfullscreen></iframe>\n\n// This was my first foray into ray tracing. Originally, I wanted to write this\n// using the OpenGL Compute Shader. That was harder to setup than I originally\n// realized, and I spent a fair bit of time mucking around with OpenGL and cmake\n// before deciding to just sit down and start programming.\n\n// All things considered, this is a pretty limited ray tracer. Some low hanging\n// fruit might be to add anti-aliasing and soft shadows. The former was not an\n// issue until I ported this from a HiDPI display onto the WebGL canvas. The\n// latter involves finding a quality random number generator. Maybe a summer\n// project before I start working ...\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ljGRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[5055, 5569, 5614, 5654, 6104], [6106, 6404, 6447, 6447, 6621], [6623, 6937, 6963, 6963, 8363], [8365, 8709, 8733, 8733, 11998], [12000, 12448, 12503, 12503, 13086]], "test": "error"}
{"id": "4ljGWV", "name": "IzÃ©", "author": "sagoston", "description": "Ha tudnÃ¡m, mi ez...", "tags": ["valami"], "likes": 0, "viewed": 98, "published": "Public", "date": "1432557877", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float norm(vec2 v){\n\treturn v.x+v.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 6.0 * (fragCoord.xy) / iResolution.xy - 3.0;\n    float k;\n    //int h = 200+int(100.0*sin(iTime));\n    for(int i=0;i<1000;++i){\n    \tuv = vec2(uv.x*uv.x-uv.y*uv.y,2.0*uv.x*uv.y) + 6.0 * (fragCoord.xy) / iResolution.xy - 3.0;\n        if(norm(uv) > 2.0){\n            k = float(i);\n        \tbreak;\n        }\n    }\n    //fragColor = vec4(k,0,k,1);\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ljGWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 38], [40, 40, 97, 97, 500]], "test": "valid"}
{"id": "4lS3Dc", "name": "Spikes On A Colourful Background", "author": "Ada_Code", "description": "Some stuff I made on my first go at GLSL.", "tags": ["2d", "spiky"], "likes": 1, "viewed": 98, "published": "Public", "date": "1432928713", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float t = 0.;\n    float d = 0.1;\n    float c = 0.2;\n    if (uv.x > sin(uv.y*10.+iTime))\n    {\n        t=sin(iTime)*0.5+0.5;\n        d=tan(iTime)*0.5+0.5;\n        c=cos(iTime)*0.5+0.5;\n    }\n\tfragColor = vec4(t,d,c,0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lS3Dc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 323]], "test": "valid"}
{"id": "4lS3DK", "name": "Hyper Dodecahedron", "author": "tholzer", "description": "A hyperbolic kaleidoscope dodecahedron original created by nimitz.\nUse mouse to select shape and to rotate it.", "tags": ["raymarcher", "kaleidoscope", "dodecahedron", "hyperbolic"], "likes": 25, "viewed": 557, "published": "Public", "date": "1432286230", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//---------------------------------------------------------\n// Shader:   HyperDodecahedron.glsl   by tholzer 2015-05-11\n//           https://www.shadertoy.com/view/4lS3DK \n// original: 'Famous solid' by nimitz (@stormoid)\n//           https://www.shadertoy.com/view/ltlGWM\n// modified: use mouse to select different shape types now\n// tags:     hyperbolic, dodecahedron, kaleidoscope, raymarcher\n//---------------------------------------------------------\n/*\nQuick laydown of what's going on:\n -knighty's folding technique to get dodecahedron distance (see: https://www.shadertoy.com/view/XlX3zB)\n -Linear extrapolation of sphere to \"hyberbolize\" the dodecahedron\n -Fold symmetries are used to displace, shade and color\n -Cheap analytic curvature for shading (see: https://www.shadertoy.com/view/Xts3WM)\n -Wave noise for bump mapping (generalized triangle noise: https://www.shadertoy.com/view/XtX3DH)\n -eiffie's auto-overstep raymarching method: https://www.shadertoy.com/view/ldSSDV\n -Lighting mostly from iq\n*/\n\n#define ROTATE true\n#define ITR 120\n#define FAR 7.0\n#define time iTime\n#define TYPES 5.0\n\nint solidType = 2;   // use 0 to 4 for starting shape.\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\nvec3 fold(in vec3 p)\n{\n    const vec3 nc = vec3(-0.5,-0.809017,0.309017);\n    for(int i=0;i<5;i++)\n    {\n\t\tp.xy = abs(p.xy);\n\t\tfloat t = 2.*min(0.,dot(p,nc));\n\t\tp -= t*nc;\n\t}\n    return p;\n}\n\nfloat smax(float a, float b)\n{\n    const float k = 2.;\n    float h = 1.-clamp(.5 + .5*(b-a)/k, 0., 1.);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat tri(in float x){return abs(fract(x)-0.5)*2.;}\n\nfloat map(in vec3 p)\n{\n    vec3 fp = fold(p) - vec3(0.,0.,1.275);\n    float d = mix(dot(fp,vec3(.618,0,1.)), length(p)-1.15,-3.6);\n    \n    if (solidType == 1)\n    {\n\t  d += tri(fp.x*8.+fp.z*3.)*0.05+tri(fp.x*fp.y*40.+time*0.2)*0.07-0.17;\n      d += tri(fp.y*5.)*0.04;\n      d *= 0.9;\n\t}\n    else if (solidType == 2)\n    {\n\t  d *= 0.7;\n      d += sin(time+fp.z*5.+sin(fp.x*20.*fp.y*8.)+1.1)*0.05-0.08;\n      d += sin(fp.x*20.*sin(fp.z*8.+time*0.2))*0.05;\n      d += sin(fp.x*20.*sin(fp.z*8.-time*0.3)*sin(fp.y*10.))*0.05;\n    }\n\telse if (solidType == 3)\n\t{\n      d = smax(d+.5, -(d+sin(fp.y*20.+time+fp.z*10.)+1.5)*0.3)*.55;\n      d += sin(max(fp.x*1.3,max(fp.z*.5,fp.y*1.))*35.+time)*0.03;\n    }\n\telse if (solidType == 4)\n      d = smax(d+.5, -(d+sin(fp.z*10.+sin(fp.x*20.*fp.y*9.)+1.1)*0.3-0.3))*.5;\n\telse\n    {\n      d = smax(d+.2, -(d+cos(fp.z*13.+cos(fp.x*18.*fp.y*2.)+2.1)*0.5-0.5))*.8;\n\t  d += tri(fp.x*3.+fp.z*6.)*0.1+tri(fp.x*fp.y*4.+time*0.2)*0.1-0.17;\n      d *= 0.5;\n    }\n    \n    return d*0.25;\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n    float t=0.,stp=0.0,os=0.0,pd=10.0, d =0.;\n\tfor(int i=0;i<ITR;i++)\n    {\n        t+=stp;\n        d=map(ro+rd*t);\n        if (t>FAR || abs(d) <0.0005)break;\n        if(d>=os)\n        {\t\t\n            os=.9*d*d/pd;\n            stp=d+os;\n            pd=d;\n        }\n        else\n        {\n            stp=-os;\n            pd=1.;\n            os=.001;\n        }\n    }\n    return t;\n}\n\nvec3 normal(in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.0001;\n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\n//Cheap analytic curvature: https://www.shadertoy.com/view/Xts3WM\nfloat curv(in vec3 p)\n{\n    vec2 e = vec2(-1., 1.)*0.03;\n    \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    \n    return .15/(e.x*e.x) *(t1 + t2 + t3 + t4 - 4. * map(p));\n}\n\nfloat wav(in float x){return sin(x*6.283)*0.25+0.25;}\nvec2 wav2(in vec2 p){return vec2(wav(p.x+wav(p.y*1.5)),wav(p.y+wav(p.x*1.5)));}\n\nfloat wavenoise(in vec2 p)\n{\n    float z=2.;\n    float z2=1.;\n\tfloat rz = 0.;\n    vec2 bp = p;\n    rz+= (wav(-time*0.5+p.x*(sin(-time)*0.3+.9)+wav(p.y-time*0.2)))*.7/z;\n\tfor (float i=0.; i<=3.; i++ )\n\t{\n        vec2 dg = wav2(bp*2.)*.8;\n        dg *= mm2(time*.2);\n        p += dg/z2;\n\n        bp *= 2.4;\n        z2 *= 1.05;\n\t\tz *= 2.4;\n\t\tp *= 1.4;\n        \n        rz+= (wav(p.x+wav(p.y)))/z;\n\t}\n\treturn rz;\n}\n\nvec3 tex(in vec3 p)\n{   \n    float rz;\n    vec3 col;\n    if (solidType == 1)\n    {\n        rz= p.y*15.+p.x*30.+p.z*5.;\n    \tcol = (sin(vec3(.7,2.,.1-rz*0.2)+rz*.1+0.45))*0.5+0.5;\n\t}\n\telse if (solidType == 2)\n    {\n    \trz= (sin(p.x*0.+p.z*20.)-p.y*20.);\n    \tcol = (sin(vec3(2.1,.7,.1)+rz*.09+4.15))*0.5+0.5;\n\t}\n\telse if (solidType == 3)    \n    {\n        rz= sin(p.z*3.+p.x*6.)*0.5+0.5;\n    \tcol = mix(vec3(.7,0.1,0.),vec3(1,.5,0.4),rz)*0.5+0.05;\n    }\n\telse if (solidType == 4)\n    {\n        rz= p.z*13.+p.x*30.;\n    \tcol = (sin(vec3(2.2,.7,.1)+rz*.1+4.2))*1.3+1.3;\n    }\n\telse \n    {\n        rz= sin(p.z*13.) + p.x*23.;\n    \tcol = (sin(vec3(0.2,.9,.5)+rz*0.4+2.2))*1.1+1.1;\n    }\n    return col;\n}\n\n//Bump mapping\nfloat bumptex(in vec3 p)\n{\n    if      (solidType == 1) return wavenoise(mix(p.zy,p.yx,1.)*0.55);\n    else if (solidType == 2) return wavenoise(mix(p.yz,p.xy,.5)*0.55);\n    else if (solidType == 3) return wavenoise(mix(p.zy,p.xy,.5)*0.44);\n    else if (solidType == 4) return wavenoise(mix(p.zy,p.xy,.1)*0.55);\n    else                     return wavenoise(mix(p.zy,p.xy,.2)*0.50);\n}\n\nvec3 bump(in vec3 p, in vec3 n)\n{\n    vec2 e = vec2(.01,0);\n    float n0 = bumptex(p);\n    vec3 d = vec3(bumptex(p+e.xyy)-n0, bumptex(p+e.yxy)-n0, bumptex(p+e.yyx)-n0)/e.x;\n    n = normalize(n-d*.3);\n    return n;\n}\n\nfloat shadow(in vec3 ro, in vec3 rd, in float mint, in float tmax)\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<15; i++ )\n    {\n\t\tfloat h = map(ro + rd*t);\n        res = min( res, 4.*h/t );\n        t += clamp( h, 0.01, .1 );\n        if(h<0.001 || t>tmax) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat ao( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= .95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 rotx(vec3 p, float a)\n{\n    float s = sin(a), c = cos(a);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 roty(vec3 p, float a)\n{\n    float s = sin(a), c = cos(a);\n    return vec3(c*p.x + s*p.z, p.y, -s*p.x + c*p.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = q-0.5;\n\tfloat ratio = iResolution.x / iResolution.y;\n    p.x *= ratio;\n    solidType = int( iMouse.x / iResolution.x * TYPES);\n\t\n    // camera\n    vec2 mo = iMouse.xy / iResolution.xy*1.5 -.75;\n\tmo.x *= ratio;\n\tif (ROTATE)\n        mo += vec2(time*0.03, time*0.004);\n\tvec3 ro = vec3(.0,0.0,-7.0);\n    vec3 rd = vec3(p,1.2);\n\tro = rotx(ro, -mo.y*3.0);ro = roty(ro, mo.x*3.0);\n\trd = rotx(rd, -mo.y*3.0);rd = roty(rd ,mo.x*3.0);\n\t\n    float rz = march(ro,rd);\n    vec3 col = vec3(0.9);   \n    if ( rz < FAR )\n    {\n        //setup\n        vec3 pos = ro+rz*rd;\n        float crv= curv(pos);\n        vec3 nor = normal(pos);\n       \tvec3 fpos = fold(pos);\n        vec3 lgt = normalize(vec3(.0, 1., 0.9));\n        float shd = shadow( pos, lgt, 0.02, 3.0 );\n        nor = bump(fpos, nor);\n        \n        //components\n        float dif = max(dot(nor,lgt),0.0)*shd;\n        float bac = max(0.2 + 0.8*dot(nor,vec3(-lgt.x,lgt.y,-lgt.z)),0.0);\n        float fre = clamp(pow(1.0+dot(nor,rd),3.),0.,10.)*shd;\n        vec3 haf = normalize(lgt - rd);\n        float spe = pow(clamp(dot(nor,haf),0.0,1.0),50.0)*shd;\n        float occ= crv*0.25+0.75;\n\t\t\n        //compose\n        col  = 0.2*occ + dif*vec3(1.0,0.8,0.6) \n            + 0.4*bac*vec3(1.0)*occ;\n        col *= 0.5*pow(tex(fpos),vec3(.5));\n        col += .4*fre*vec3(1.0) + .35*spe*vec3(1.0);\n        col *= ao(pos,nor);\n        col = pow(col,vec3(.75))*1.3;\n    }\n    \n    //vignetting from iq\n    col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.12 )*0.8+0.4;\n\t\n\tfragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": "Xsf3Wj", "previewfilepath": "https://soundcloud.com/daniel-koerber/zack-hemsey-see-what-ive", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/daniel-koerber/zack-hemsey-see-what-ive", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lS3DK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1126, 1161, 1182, 1182, 1234], [1236, 1236, 1258, 1258, 1426], [1428, 1428, 1458, 1458, 1572], [1574, 1574, 1596, 1596, 1625], [1627, 1627, 1649, 1649, 2637], [2639, 2639, 2676, 2676, 3057], [3059, 3059, 3083, 3083, 3243], [3245, 3311, 3334, 3334, 3544], [3546, 3546, 3568, 3568, 3599], [3600, 3600, 3621, 3621, 3679], [3681, 3681, 3709, 3709, 4091], [4093, 4093, 4114, 4114, 4793], [4795, 4810, 4836, 4836, 5193], [5195, 5195, 5228, 5228, 5410], [5412, 5412, 5480, 5480, 5731], [5733, 5733, 5771, 5771, 6067], [6069, 6069, 6097, 6097, 6185], [6186, 6186, 6214, 6214, 6303], [6305, 6305, 6362, 6362, 7953]], "test": "valid"}
{"id": "4lS3W3", "name": "Audio cube II - Visualiser", "author": "uNiversal", "description": "A variation of AudioCube by kuvkar -- Modified to work with Kodi shadertoy [url]http://imgur.com/a/WfT2T#0[/url]\nCleanup channels and code white spaces mainly. Making it work with Kodi shadertoy", "tags": ["3d", "audio", "visualiser"], "likes": 5, "viewed": 2283, "published": "Public API", "date": "1432818373", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nAudio cube II - Visualiser - \nVariation of AudioCube by: kuvkar - 19th March, 2015 https://www.shadertoy.com/view/llBGR1\nAuido Cube II by: uNiversal - 28th May, 2015\nCreative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n*/\n \n//Distance field functions from\n//http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n/*-------------------------------------------------------------------------*/\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n    return length(max(abs(p)-b,0.0));\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) +\n           length(max(d,0.0));\n}\n\n/*-------------------------------------------------------------------------*/\n\n#define PI 3.14159\n#define TYPE_CUBE 1\n#define TYPE_SPHERE 2\n#define OBJECT_COUNT 2\n\nmat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\n\nstruct Object\n{\n    mat3 rot;\n    vec3 pos;\n    vec3 size;\n    int type;\n};\n\nObject objects[OBJECT_COUNT];\n\nfloat dist(vec3 position)\n{\n    float m = 9999.0;\n    vec4 audio = texture(iChannel0, vec2(0.0, 0.0));\n    vec2 uv = vec2(position.x, position.y) * 1.0;\n    vec4 col = texture(iChannel0, uv).rgba;\n\n    Object o = objects[0];\n    vec3 p = position + o.pos;\n\n    p = p * o.rot;\n    float f = 0.0;\n\n    float a = sdBox(p, o.size);\n    float b = sdSphere(p, o.size.x);\n    float au = audio.x;\n\n    f = au * a + (1.0 - au) * b;\n    f -= sdSphere(p, o.size.x) * (0.3 + au * 0.4);\n\n    m = min(f, m);\n    return m;\n}\n\nfloat toClipSpace(float f)\n{\n    return f * 2.0 - 1.0;\n}\n\nvec3 lookAt(vec3 from, vec3 to, vec3 dir)\n{\n    mat3 m;\n    \n    vec3 fwd = normalize(to - from);\n    vec3 _up = vec3(0.0, 1.0, 0.0);\n    vec3 r = cross(fwd, _up);\n    vec3 u = cross(r, fwd);\n    \n    m[0] = r;\n    m[1] = u;\n    m[2] = fwd;\n    vec3 d = m * dir;    \n    d.z *= -1.0;\n    return d;\n}\n\nbool trace(vec3 from, vec3 dir, out vec3 hitPosition, out float m)\n{\n    \n    const int steps = 300;\n    float step = 0.01;    \n    vec3 rp = from;\n    m = 99999.0;\n    \n    for (int i = 0; i < steps; ++i)\n    {\n        rp += dir * step;\n        float sp = dist(rp);\n        step  = sp;\n        m = min(m, abs(sp));\n        if (abs(sp) <= 0.001)\n        {\n            hitPosition = rp;\n            return true;\n        }\n        \n    }\n    return false;\n}\n\nObject getObject(vec3 position, int type)\n{\n    Object c;\n    c.pos = position;\n    c.rot = mat3(1.0);\n    c.type = type;\n    c.size = vec3(0.1, 0.1, 0.1);\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.x);\n    uv.y += (iResolution.y / iResolution.x) * 0.4;\n\n    vec4 audio = texture(iChannel0, vec2(1.0, 0.0));\n\n    objects[0] = getObject(vec3(0.0), TYPE_CUBE);\n    objects[0].size = vec3(0.1, 0.1, 0.1);\n\n    objects[0].rot *= rotx(iTime * 1.5);\n    objects[0].rot *= roty(sin(iTime * 1.5));\n\n    vec3 camPos = vec3(0.0, 0.0, 1.0);    \n    vec3 lk = vec3(-toClipSpace(uv.x), -toClipSpace(uv.y), -2.0);\n    vec3 mclip = vec3(0.0);\n    vec3 dir = lookAt(camPos, mclip, normalize(lk));\n    vec3 hit = vec3(0.0);\n    vec4 color = vec4(0.0);\n\n    float m;\n    bool h = trace(camPos, dir, hit, m);\n    vec4 aColor = vec4(1.0);\n\n    float p =  pow(length(uv - vec2(0.5, 0.5)), 3.0);\n    aColor.r = 0.5 + (sin((iTime + 100.0) * 0.25) * 0.5);\n    aColor.g = 0.5 + (cos((iTime + 300.0) * 0.15) * 0.5);\n\n    if(h)\n    {\n        vec2 offset = vec2(0.001, 0.0);\n        vec3 grad = normalize(vec3(dist(hit + offset.xyy) - dist(hit - offset.xyy), \n                                   dist(hit + offset.yxy) - dist(hit - offset.yxy),\n                                   dist(hit + offset.yyx) - dist(hit - offset.yyx)));\n        \n        float d = clamp(dot(grad, vec3(0.0, 0.0, 1.0)), 0.0, 1.0);\n        float rim = (1.0 - d) * 1.4;        \n        color += aColor * pow(rim, 2.0);\n\n    }\n    else\n    {\n        color = aColor * pow(length(uv - vec2(0.5, 0.5)) * (1.0 + p * audio.x * 5.0), 1.4) * 1.5;\n    }\n\n    float d = (1.0 - m * 75.0) * 15.0 * p;\n    color += aColor * pow(clamp(d, 0.0, 0.0), 1.2);\n\n    fragColor = color;\n}\n", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lS3W3.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[250, 429, 464, 464, 490], [492, 492, 525, 525, 594], [596, 596, 627, 627, 667], [669, 669, 705, 705, 789], [791, 791, 836, 836, 878], [880, 880, 921, 921, 992], [994, 994, 1025, 1025, 1127], [1129, 1293, 1313, 1313, 1440], [1441, 1441, 1461, 1461, 1588], [1698, 1698, 1725, 1725, 2207], [2209, 2209, 2237, 2237, 2265], [2267, 2267, 2310, 2310, 2566], [2568, 2568, 2636, 2636, 3023], [3025, 3025, 3068, 3068, 3196], [3198, 3198, 3255, 3255, 4842]], "test": "error"}
{"id": "4lS3Wc", "name": "Perlin Sphere", "author": "jozxyqk", "description": "simple ray marching test", "tags": ["raymarching", "perlinnoise"], "likes": 2, "viewed": 447, "published": "Public", "date": "1432907368", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat noise3D(vec3 p)\n{\n    p.z = fract(p.z)*256.0;\n    float iz = floor(p.z);\n    float fz = fract(p.z);\n    vec2 a_off = vec2(23.0, 29.0)*(iz)/256.0;\n    vec2 b_off = vec2(23.0, 29.0)*(iz+1.0)/256.0;\n    float a = texture(iChannel0, p.xy + a_off, -999.0).r;\n    float b = texture(iChannel0, p.xy + b_off, -999.0).r;\n    return mix(a, b, fz) - 0.5;\n}\n\nfloat perlin(vec3 p)\n{\n    float v = 0.0;\n    for (float i = 0.0; i < 6.0; i += 1.0)\n        v += noise3D(p * pow(2.0, i)) * pow(0.35, i);\n    return v;\n}\n\nfloat density(vec3 p)\n{\n    float n = perlin(p * 0.04);\n    //n *= abs(n);\n    n = sqrt(n+1.0) * 0.2 * (1.0+sin(iTime));\n    //n = n * 0.1;\n    float l = length(p);\n    return n + l*l*0.7;\n}\n\nfloat thresh = 1.0;\n\nbool trace(vec3 start, vec3 ray, out vec3 hit, out vec3 norm)\n{\n    bool hashit = false;\n    const float steps = 64.0;\n    vec3 p = start;\n    vec3 s = ray/steps;\n    for (float i = 0.0; i < steps; i += 1.0)\n    {\n        p += s;\n        if (density(p) > thresh)\n        {\n            hashit = true;\n            break;\n        }\n    }\n    if (!hashit)\n        return false;\n    for (int i = 0; i < 10; ++i)\n    {\n        s *= 0.5;\n        if (density(p) > thresh)\n            p -= s;\n       \telse\n            p += s;\n    }\n    hit = p;\n    const float e = 0.005;\n    float hit_density = density(hit);\n    norm = -normalize(vec3(density(p+vec3(e,0,0)), density(p+vec3(0,e,0)), density(p+vec3(0,0,e))) - hit_density);\n    return true;\n}\n\nvec3 getCol(vec3 start, vec3 dir, out vec3 hit, out vec3 norm, out vec3 ref)\n{\n    trace(start, dir, hit, norm);\n    vec3 eye = -normalize(dir);\n    vec3 light = -normalize(hit);\n    ref = reflect(-eye, norm);\n    float dist = length(hit-start);\n    float fog = exp(-dist);\n    float diffuse = max(0.0, dot(norm, light));\n    float specular = pow(max(0.0, dot(ref, light)), 100.0);\n    vec3 p = hit * 0.1;\n    vec3 col = normalize(vec3(noise3D(p), noise3D(p+1.234), noise3D(p+3.543))*0.2+0.5);\n    //vec3 col = vec3(1.0);\n    return vec3(col * (diffuse*0.6+0.4)+specular*0.3);\n}\n\n//http://code.google.com/p/qshaderedit/source/browse/qshaderedit/shaders/sancho/minnaertward.glsl?spec=svn165&r=165\nfloat fresnel(vec3 i, vec3 n)\n{\n    float idotn = dot(-i, n);\n    if (idotn < 0.0)\n        return 0.0;\n    const float ior = 1.3;\n\tfloat kr = (ior-1.0)/(ior+1.0);\n\tkr *= kr;\n\treturn kr + (1.0-kr)*pow( 1.0 - idotn, 5.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float fog_density = 0.3;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float aspect = iResolution.z*iResolution.x/iResolution.y;\n    vec3 start = vec3(0,-0.8,-0.5);\n    vec3 dir = 2.5 * normalize(vec3((uv*2.0-1.0) * vec2(aspect,1.0) * 6.0, 10.0));\n \t//dir = dir.xzy;\n    \n    vec3 hit, norm, ref;\n    vec3 first = getCol(start, dir, hit, norm, ref);\n    vec3 qwe1, qwe2;\n    bool shadow = trace(hit, -hit, qwe1, qwe2);\n    float fog = exp(-length(hit-start)*fog_density);\n    float f = clamp(fresnel(normalize(dir), norm)*2.0, 0.0, 1.0);\n    vec3 second = getCol(hit, ref*3.0, hit, norm, ref);\n    float fog2 = exp(-length(hit-start)*fog_density);\n    vec3 col = fog * mix(first * (shadow?0.8:1.0), fog2 * second, f);\n    \n    fragColor = vec4(col, 1.0);\n    //fragColor = vec4(vec3(), 1.0);\n}\n", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lS3Wc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 24, 24, 352], [354, 354, 376, 376, 508], [510, 510, 533, 533, 700], [723, 723, 786, 786, 1457], [1459, 1459, 1537, 1537, 2037], [2039, 2155, 2186, 2186, 2376], [2378, 2378, 2435, 2435, 3244]], "test": "error"}
{"id": "4lS3WG", "name": "4d ray marching", "author": "ostkaka", "description": "Ray marching in 4 dimensions! This is a projection on a 3d slice of 4d.", "tags": ["4draymarchingtesseractdistortion"], "likes": 9, "viewed": 282, "published": "Public", "date": "1431640054", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ITERATIONS 64\n#define EPSILON 0.01\n#define FAR 1.0e6\n#define PI 3.1415926535897932384626\n\nfloat hTorus(in vec4 pos, in float r1, in float r2)\n{\n    return length(vec3(length(pos.xz)-r1,pos.y, pos.w))-r2;\n}\n\nfloat tesseract(in vec4 p, in float s)\n{\n    vec4 d = abs(p) - 0.5*s;\n  return min(max(max(d.x, d.y),max(d.z,d.w)),0.0) +\n         length(max(d,0.0));\n}\n\n// Should loook like a sphere\nfloat hCylinder(in vec4 pos, float r)\n{\n\treturn length(pos.xyz)-r;   \n}\n\nfloat hSphere(in vec4 pos, float r)\n{\n    return length(pos)-r;\n}\n\nvec4 repetition(in vec4 p, in vec4 c )\n{\n   return mod(p-0.5*c,c)-0.5*c;\n}\n\n\n\nvec2 map(in vec4 pos)\n{\n    vec4 localPos = repetition(pos, vec4(4, 2, 5, 4));\n    \n    float distance = FAR;\n    float distortedDistance = FAR;\n    \n    distance = min(distance, tesseract(localPos, 1.0));\n    distance = max(distance, -hTorus(localPos, 0.5, 0.5));\n    \n    distance = min(distance, hCylinder(localPos, 0.05));\n    distance = min(distance, hSphere(localPos-vec4(vec3(0.0), 1.0), 0.2));\n    \n\n    \n    vec4 spos = 16.0*pos;\n    distance += 0.01*(sin(spos.x)+sin(spos.y)+sin(spos.z)+sin(spos.w));\n    distortedDistance = distance-0.01;\n    \n    distance = min(distance, pos.y+1.0);\n    \n    return vec2(distance, min(distortedDistance, distance));\n}\n\nvec4 calculateNormal(vec4 pos, float epsilon)\n{\n\tvec4 epsilonVec = vec4(epsilon, 0.0, 0.0, 0.0);\n    vec4 xyyy = vec4(epsilon, 0.0, 0.0, 0.0);\n    vec4 yxyy = vec4(0.0, epsilon, 0.0, 0.0);\n    vec4 yyxy = vec4(0.0, 0.0, epsilon, 0.0);\n    vec4 yyyx = vec4(0.0, 0.0, 0.0, epsilon);\n    \n\tvec4 normal = vec4(\n\t    map(pos+xyyy).x - map(pos-xyyy).x,\n\t    map(pos+yxyy).x - map(pos-yxyy).x,\n\t    map(pos+yyxy).x - map(pos-yyxy).x,\n    \tmap(pos+yyyx).x - map(pos-yyyx).x);\n\treturn normalize(normal);\n}\n\nvec4 castRay(in vec4 pos, in vec4 direction)\n{\n    vec4 rayPos = pos+0.25*direction;\n    vec4 rayDirection = direction;\n    float distance = 0.0;\n    float rayDistance = distance;\n    \n    float iterations = 0.0;\n    \n    for (int i = 0; i < ITERATIONS; ++i)\n    {\n        iterations += 1.0;\n        \n        \n        vec2 mapPoint = map(rayPos);\n        distance = max(mapPoint.y, 0.25*mapPoint.x);\n        \n        rayPos += distance*rayDirection;\n        rayDistance += distance;\n        \n        if (mapPoint.x < EPSILON) break;\n        if (rayDistance  > FAR) break;\n        \n    }\n    \n    \n    vec4 lightdir = normalize(vec4(0.0, 0.0, 0.0, 1.0));\n    vec4 normal = calculateNormal(rayPos, EPSILON);\n    \n    \n    vec3 aura = vec3(1.0)*iterations/float(ITERATIONS)/pow(rayDistance*0.0625, 0.5);\n    vec3 color = vec3(0.0, 0.2, 0.0)*(dot(lightdir, normal))/pow(rayDistance*0.25, 0.5);\n    \n    if (distance < 0.1)\n       return vec4(vec3(color+aura-0.25), 1.0);\n    else\n   \t\treturn vec4(vec3(aura-0.25), 1.0);\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = vec2(-1.0) + 2.0*fragCoord.xy / iResolution.xy;\n    vec2 mouse = 8.0 * (iMouse.xy / iResolution.xy-0.5);\n    mouse.y = clamp(mouse.y, -0.49*PI, 0.49*PI);\n\n    if (iMouse.y == 0.0)\n        mouse.y = 0.0;\n    \n\tfloat time = 1.0 + 0.125*iTime;\n    \n    // camera\t\n\tvec4 pos = vec4(2.0, 0.0, 2.0, 2.0+iTime);\n\tvec3 target = pos.xyz + vec3( cos(mouse.x + time), tan(mouse.y), sin(mouse.x + time) );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( pos.xyz, target, 0.0 );\n    \n    // ray direction\n\tvec3 direction = ca * normalize( vec3(0.5*uv.xy,1.0) );\n    \n \n    time = 0.25+0.25*clamp(cos(0.1*PI*iTime+1.2*PI), -0.95, 0.95)/0.95;\n    vec2 phase = vec2(cos(PI*time), sin(PI*time));\n    \n    vec4 direction4 = vec4(direction.x, direction.y*phase.x, direction.z, 1.0*direction.y*phase.y);\n   \n\tfragColor = clamp(castRay(pos+iTime*vec4(vec3(0.0), 0.1), direction4), 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lS3WG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[98, 98, 151, 151, 213], [215, 215, 255, 255, 367], [369, 399, 438, 438, 470], [472, 472, 509, 509, 537], [539, 539, 579, 579, 613], [617, 617, 640, 640, 1280], [1282, 1282, 1329, 1329, 1778], [1780, 1780, 1826, 1826, 2797], [2800, 2800, 2852, 2852, 3029], [3032, 3032, 3089, 3089, 3987]], "test": "valid"}
{"id": "4lSGDc", "name": "metaballs pt.2", "author": "the23", "description": "some more metaballs, variation of earlier shader with animated color", "tags": ["2d", "metaballs", "glow"], "likes": 16, "viewed": 462, "published": "Public", "date": "1432911591", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float speed = 13.0;\n\nconst float radius = 5.7;\nconst float thresholdFactor = 0.008;\nconst int ballCount = 6;\n\nconst vec3 backgroundColor = vec3(0.0);\n\nconst float capDistance = 0.8;\n\nfloat dstMetaball(vec2 pos, vec2 center, float radius)\n{\n  vec2 diff = pos - center;\n  return radius / dot(diff, diff);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{ \n  // create centered local positions\n  float aspect = iResolution.x / iResolution.y;\n  vec2 tex = fragCoord.xy / iResolution.xy;\n  tex.x *= aspect;\n  tex -= clamp(vec2(aspect, 1.0 / aspect) - 1.0, 0.0, 1.0)  * 0.5;\n    \n  vec3 color = backgroundColor;\n\n    \n  float dst = 0.0;\n  // add a fat ball in the middle\n  dst += dstMetaball(tex, vec2(0.5, 0.5), radius) * 20.0;\n\n  // init the vars for the other balls\n  vec2 ballPos = vec2(0.0);\n  float sinTime = sin(iTime * speed * 0.1);\n\n  vec2 dir1 = vec2(sin(radians(0.0)), cos(radians(0.0)));\n  vec2 dir2 = vec2(sin(radians(60.0)), cos(radians(60.0)));\n  vec2 dir3 = vec2(sin(radians(120.0)), cos(radians(120.0)));\n\n  for (int i=0; i < 2; ++i)\n  {\n    ballPos = sign(float(i) - 0.5) * sinTime * 0.5 * dir1 * capDistance;\n    dst += dstMetaball(tex, ballPos + 0.5/*center*/, radius);\n   \n    ballPos = sign(float(i) - 0.5) * sinTime * 0.55 * dir2 * capDistance;\n    dst += dstMetaball(tex, ballPos + 0.5/*center*/, radius);\n\n    ballPos = sign(float(i) - 0.5) * sinTime * 0.5 * dir3 * capDistance;\n    dst += dstMetaball(tex, ballPos + 0.5/*center*/, radius);\n  }\n    \n  // scale down the distance, don't forget the middle ball\n  dst /= float(ballCount) + 2.0;\n  \n  vec3 ballColor = vec3(sin(iTime * speed * 0.08), \n                        sin(iTime * speed * 0.07), \n                        sin(iTime * speed * 0.06));\n  ballColor = normalize(ballColor);\n  ballColor = ballColor * 0.5 + 0.5;\n  // blend between colors\n  color = mix(color, ballColor, dst * thresholdFactor);\n\n  fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lSGDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[189, 189, 245, 245, 310], [312, 312, 368, 406, 1925]], "test": "valid"}
{"id": "4lSGDK", "name": "heart mess", "author": "ddddddddd", "description": "messing around. ran out of time. bye", "tags": ["heart"], "likes": 1, "viewed": 120, "published": "Public", "date": "1432261736", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// simple sphere cheat map.\n// modified. playing around.\n// dean alex\n\n// USE MOUSE\n\n\nfloat PI = 3.14159265358979586;\n\nfloat focal = 0.5;\nfloat aspect = iResolution.x / iResolution.y;\nfloat heartRadius = 0.7 + sin( iTime * 6.0) * 0.05;\nfloat heartX = 0.5 * aspect;\nfloat heartY = 0.4;\n\n\n\n\n\nvec2 warp( float x, float y, float radius ){\n    \n    // width of radius at y\n    float rad_w = sqrt( radius*radius - y*y );\n    float warp_x = x / rad_w;\n    \n    // height of radius at x\n    float rad_h = sqrt( radius*radius - x*x );\n    float warp_y = y / rad_h;\n    \n    //\n    warp_x = warp_x + (cos( x * PI ));\n    warp_y = warp_y + (cos( y * PI ));\n    \n    return vec2( warp_x, warp_y );\n}\n\nvec4 hext( float x, float y ){\n    float sides = 4.0;\n    float spotCount = 15.0;\n    float spotRatio = 0.75;\n    \n    float ox = iTime * 0.11;\n    float oy = iTime * 0.13 * y * 0.1;\n    \n    float spdx = mod( x * spotCount + ox, 2.0 ) - 1.0;\n    float spdy = mod( y * spotCount + oy, 2.0 ) - 1.0;\n    \n    float sptheta = atan( spdy, spdx );\n    float spdis = sqrt( spdx * spdx + spdy * spdy );\n    \n    if( spdis > spotRatio ){\n        return vec4( sin(x)*0.7, 0.0, sin(x), 1.0 );\n    }else{\n        \n        float hexangle = (2.0 * PI / sides );\n        float hextheta = mod( sptheta / hexangle, 1.0 );\n        \n        float Ax = 1.0;\n        float Ay = 0.0;\n        float Bx = cos( hexangle );\n        float By = sin( hexangle );\n        \n        float Mx = Bx * hextheta + Ax * (1.0 - hextheta);\n        float My = By * hextheta + Ay * (1.0 - hextheta);\n        float Mdis = sqrt( Mx * Mx + My * My );\n        Mdis *= Mdis;\n        \n        if( spdis > Mdis ){\n            return vec4( 0.0, sin(x), 0.0, 1.0 );\n        }else{\n            return vec4( sin(x)*1.4, 0.0, 0.0, 1.0 );\n        }\n    }\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    //----- pixel coords -----\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float s = uv.s * aspect;\n    float t = 1.0 - uv.t;\n    \n    \n    //----- get heart shape -----\n    float dx = (s - heartX) / heartRadius;\n    float dy = (t - heartY) / heartRadius;\n    \n    float theta = atan( dy, dx ) + PI / 2.0;\n    theta = abs( PI - abs( theta - PI));\n    float thetamf = theta / PI;\n    \n    float outlineRadius0 = 0.4;\n    float outlineRadius1 = 0.7;\n    \n    float outline = sin( theta * 1.1) * (1.0 - thetamf * thetamf) * outlineRadius0 * heartRadius + outlineRadius1 * heartRadius * thetamf * thetamf;\n    \n    float dis = sqrt( dx*dx + dy*dy );\n    float dismf = dis / outline;\n    \n    if( dismf > 1.0 ){\n        fragColor = texture( iChannel0, vec2( s * 2.0, t * 2.0 )) * 0.4;\n        fragColor = hext( s * 2.0, t * 2.0 );\n        return;\n    }\n    \n    vec3 surfaceNorm = vec3( dx, dy, sqrt( dismf*dismf - dy*dy - dx*dx));\n    \n    \n    \n    \n    \n    \n    \n    \n    //----- get coordinates of texture -----\n    \n    vec2 d = warp( dx, dy, outline );\n    \n    float px = (s - heartX) * 2.0;\n    float py = (t - heartY) * 2.0;\n    vec2 p = warp( px, py, heartRadius );\n    \n   float qx = p.x * 0.15 + d.x * 0.85;\n   float qy = p.y * 0.15 + d.y * 0.85;\n    \n    \n    \n    //----- shading -----\n    dismf = 1.0 - dismf;\n    \n    \n    vec4 texs = texture( iChannel0, vec2( qx * focal + heartX, qy * focal + heartY ) );\n    vec4 tex = hext( qx * focal + heartX, qy * focal + heartY );\n    \n    tex.rgb *= (dismf * 0.9) + 0.1;\n    \n    // specular\n    dismf = dismf * dismf;\n    tex.rgb += dismf * texs.rgb * 10.0;\n        \n    fragColor = tex;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lSGDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 290, 334, 367, 687], [689, 689, 719, 719, 1792], [1796, 1796, 1853, 1894, 3513]], "test": "error"}
{"id": "4lSGRt", "name": "quick triangle pattern pubinti", "author": "public_int_i", "description": "borreddom", "tags": ["2d", "pttern"], "likes": 0, "viewed": 141, "published": "Public", "date": "1432987863", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy/iResolution.xy-vec2(.5);\n    uv *= pow((cos(iTime*.427345)*.5+.5),2.)+.04;\n    uv *= 1.+texture(iChannel0,cos(uv)).x*(cos(iTime)*.5+.5)*.3;\n   \n    float k = 1.;\n    vec3 c = vec3(1.),a = vec3(uv.x,k,uv.y);\n    for (int i = 0; i < 8; i++) {\n        k *= sign(uv.x+uv.y-1.);\n        uv = mod(uv,vec2(.5))*2.;\n        a = a.zxy;\n        a += vec3(uv.x,k,uv.y);\n    \tc *= abs(a);\n    }\n    \n    fragColor = vec4(c*k*.5+.5,1.);\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lSGRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 508]], "test": "error"}
{"id": "4t23zt", "name": "Defrag", "author": "SpacePrez", "description": "shader to approx display of degrag program operation", "tags": ["colors"], "likes": 2, "viewed": 321, "published": "Public", "date": "1431468209", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec4 randColor(vec2 co){\n    float x = fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n    if(x < 0.1){\n        return vec4(1.0,0.7,0.0,1.0);\n    }\n    else if(x < 0.3){\n        return vec4(1.0,0.0,0.0,1.0);\n    }\n    else if(x < 0.4){\n        return vec4(0.3,0.3,0.3,1.0);\n    }\n    else{\n        return vec4(0.0,0.85,0.1,1.0);\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 uv = fragCoord.xy / iResolution.xy;\n\t//fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    \n    int numCells = 100;\n    float floatCells = float(numCells);\n    float cells = float(numCells);\n    float cellWidth = iResolution.x / cells;\n    \n    //current cursor position\n    int index = int(iTime * 13.8);\n    float ind = float(index);\n    int cursorRow = int(index / numCells);\n    cursorRow = int(mod(float(cursorRow), floatCells));\n    float col = mod(ind, cells);\n    int cursorCol = int(col);\n    \n    //current render pixel\n    int rendRow = int(fragCoord.y / cellWidth);\n    int rendCol = int(fragCoord.x / cellWidth);\n    \n    //draw grid\n    float rendLineDist = fragCoord.y / cellWidth;\n    rendLineDist =  rendLineDist - floor(rendLineDist);\n    if(rendLineDist < 0.199){\n        fragColor = vec4(0.0,0.0,0.0,1.0);\n        return;\n    }\n    rendLineDist = fragCoord.x / cellWidth;\n    rendLineDist =  rendLineDist - floor(rendLineDist);\n    if(rendLineDist < 0.199){\n        fragColor = vec4(0.0,0.0,0.0,1.0);\n        return;\n    }\n    \n    //draw colors\n    if(rendRow == cursorRow && rendCol == cursorCol){\n        fragColor = vec4(0.0,0.0,1.0,1.0);\n    }\n    else if(rendRow == cursorRow && rendCol < cursorCol){\n        //fragColor = vec4(0.0,0.0,1.0,1.0);\n        fragColor = randColor(vec2(rendRow, rendCol));\n    }\n    else if(rendRow < cursorRow){\n        //fragColor = vec4(1.0,0.0,0.0,1.0);\n        fragColor = randColor(vec2(rendRow, rendCol));\n    }\n    else{\n        fragColor = vec4(0.3,0.3,0.3,1.0);\n    }\n    \n    //vec3 texSample \t= texture( iChannel0, uv ).rgb;\n    \n    \n    //fragColor = vec4(0.0,0.0,0.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t23zt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 25, 25, 348], [351, 351, 408, 503, 2060]], "test": "valid"}
{"id": "4tB3Dc", "name": "rainbow glow", "author": "tabularasa1992", "description": "This is my interpretation of 2015/05/12 by @hughsk here: https://www.shadertoy.com/view/ltS3zd", "tags": ["2d", "colorful", "trippy"], "likes": 3, "viewed": 416, "published": "Public", "date": "1432930100", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float n(float g) { return g + .5; }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n  vec2 p  = vec2(iResolution.x/iResolution.y, 1) * uv;\n  float a = atan(p.y, p.x);\n  float l = length(p);\n  vec3  c = vec3(0);\n\n  p = vec2(sin(a + iTime), cos(a))/l * tan(a);\n\n  for (int i = 0; i < 3; i++) {\n    float mag = 0.0;\n    float t = iTime;// + float(i) * 0.05;\n\n    p.y += 5.425;\n    p.x += 10.5;\n\n    mag += n(cos(p.y * 1.5 + t * 5.));\n    mag += n(sin(p.x + t * 3.));\n    mag += n(cos(p.x * p.y));\n    mag *= 0.4;\n\n    c[i] = mag;\n  }\n\n  fragColor = vec4(pow(c, vec3(0.6)), 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tB3Dc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 35], [37, 37, 92, 92, 637]], "test": "valid"}
{"id": "4tBGzc", "name": "JUST US TIMER", "author": "yasuo", "description": "Inspiration of KITH and TSP.", "tags": ["kith"], "likes": 1, "viewed": 251, "published": "Public", "date": "1430754624", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\t\t#define NEAR 0.1\n\t\t#define FAR 100.\n\t\t#define ITER 128\n\t\t#define pi 3.14159265\n\n\t\t#define CHAR_DOT 10\n\t\t#define CHAR_J  1\n\t\t#define CHAR_U  2\n\t\t#define CHAR_S  3\n\t\t#define CHAR_T  4\n\t\t#define CHAR_K  5\n\t\t#define CHAR_I  6\n\t\t#define CHAR_H  7\n\n\t\tfloat getHrs(){return mod(floor(iTime/3600.),24.);}\n\t\tfloat getMns(){return mod(floor(iTime/60.),60.);}\n\t\tfloat getScs(){return mod(floor(iTime),60.);}\n\n\t\tfloat sdBox( vec3 p, vec3 b )\n\t\t{\n\t\t\tvec3 d = abs(p) - b;\n\t\t\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n\t\t}\n\n\t\tvec4 mapCube( vec3 pos, vec3 size, vec3 cl)\n\t\t{\n\t\t\tfloat dist = sdBox(pos , size);\n\t\t\treturn vec4(cl, dist );\n\t\t}\n\n\t\tvec4 combine(vec4 val1, vec4 val2 )\n\t\t{\n\t\t\tif ( val1.w < val2.w ) return val1;\n\t\t\treturn val2;\n\t\t}\n\n\t\tmat4 matRotateY(float rad)\n\t\t{\n\t\t\treturn mat4( cos(rad),0,-sin(rad),0,\n\t\t\t\t\t\t 0,       1,        0,0,\n\t\t\t\t\t\t sin(rad),0, cos(rad),0,\n\t\t\t\t\t\t 0,       0,        0,1);\n\t\t}\n\n\t\tvec4 renderDot(vec4 pos, int num, vec3 translate, float size)\n\t\t{\n\t\t\tvec4 val1 = mapCube(pos.xyz + vec3( 0.0, -size*2.0, 0 )+translate, vec3(size,size,size), vec3( 3, 3, 3));\n\t\t\tvec4 val2 = mapCube(pos.xyz + vec3( 0.0, size*2.0, 0 )+translate, vec3(size,size,size), vec3( 3, 3, 3));\n\t\t\treturn combine( val1, val2);\n\t\t}\n\n\t\tvec4 renderJ(vec4 pos, int num, vec3 translate, float size)\n\t\t{\n\t\t\tvec4 val1 = mapCube(pos.xyz + vec3( -size*2.0, 0, 0 )+translate, vec3(size,size*5.0,size), vec3( 3, 3, 3));\n\t\t\tvec4 val2 = mapCube(pos.xyz + vec3( 0, size*4.0, 0 )+translate, vec3(size,size,size), vec3( 3, 3, 3));\n\t\t\tvec4 val3 = mapCube(pos.xyz + vec3( size*2.0, 3.0, 0 )+translate, vec3(size,size*2.0,size), vec3( 3, 3, 3));\n\t\t\tvec4 val4 = combine ( val1, val2 );\n\t\t\treturn combine( val3, val4);\n\t\t}\n\n\t\tvec4 renderU(vec4 pos, int num, vec3 translate, float size)\n\t\t{\n\t\t\tvec4 val1 = mapCube(pos.xyz + vec3( size*2.0, 0, 0 )+translate, vec3(size,size*5.0,size), vec3( 3, 3, 3));\n\t\t\tvec4 val2 = mapCube(pos.xyz + vec3( -size*2.0, 0, 0 )+translate, vec3(size,size*5.0,size), vec3( 3, 3, 3));\n\t\t\tvec4 val3 = mapCube(pos.xyz + vec3( 0, size*4.0, 0 )+translate, vec3(size,size,size), vec3( 3, 3, 3));\n\t\t\t\n\t\t\tvec4 val4 = combine ( val1, val2 );\n\t\t\t\n\t\t\treturn combine( val3, val4);\n\t\t}\n\n\t\tvec4 renderS(vec4 pos, int num, vec3 translate, float size)\n\t\t{\n\t\t\tvec4 val1 = mapCube(pos.xyz + vec3( -size*2.0, 2.0, 0 )+translate, vec3(size,size,size), vec3( 3, 3, 3));\n\t\t\tvec4 val2 = mapCube(pos.xyz + vec3( size*2.0, -2.0, 0 )+translate, vec3(size,size,size), vec3( 3, 3, 3));\n\t\t\tvec4 val3 = mapCube(pos.xyz + vec3( 1.0, size*4.0, 0 )+translate, vec3(size*2.0,size,size), vec3( 3, 3, 3));\n\t\t\tvec4 val4 = mapCube(pos.xyz + vec3( -1.0, -size*4.0, 0 )+translate, vec3(size*2.0,size,size), vec3( 3, 3, 3));\n\t\t\tvec4 val5 = mapCube(pos.xyz + vec3( 0, 0, 0 )+translate, vec3(size,size,size), vec3( 3, 3, 3));\n\t\t\tvec4 val6 = combine ( val1, val2 );\n\t\t\tvec4 val7 = combine ( val3, val4 );\n\t\t\tvec4 val8 = combine ( val5, val6 );\n\t\t\treturn combine( val7, val8);\n\t\t}\n\n\t\tvec4 renderT(vec4 pos, int num, vec3 translate, float size)\n\t\t{\n\t\t\tvec4 val1 = mapCube(pos.xyz + vec3( 0, 0, 0 )+translate, vec3(size,size*5.0,size), vec3( 3, 3, 3));\n\t\t\tvec4 val2 = mapCube(pos.xyz + vec3( 0, -size*4.0, 0 )+translate, vec3(size*3.0,size,size), vec3( 3, 3, 3));\n\t\t\treturn combine( val1, val2);\n\t\t}\n\n\t\tvec4 renderK(vec4 pos, int num, vec3 translate, float size)\n\t\t{\n\t\t\tvec4 val1 = mapCube(pos.xyz + vec3( size*2.0, 0, 0 )+translate, vec3(size,size*5.0,size), vec3( 3, 3, 3));\n\t\t\tvec4 val2 = mapCube(pos.xyz + vec3( 0.0, 0.0, 0.0 )+translate, vec3(size,size,size), vec3( 3, 3, 3));\n\t\t\tvec4 val3 = mapCube(pos.xyz + vec3( -size*2.0, -3.0, 0 )+translate, vec3(size,size*2.0,size), vec3( 3, 3, 3));\n\t\t\tvec4 val4 = mapCube(pos.xyz + vec3( -size*2.0, 3.0, 0 )+translate, vec3(size,size*2.0,size), vec3( 3, 3, 3));\n\t\t\tvec4 val5 = combine ( val1, val2 );\n\t\t\tvec4 val6 = combine ( val3, val4 );\n\t\t\treturn combine( val5, val6);\n\t\t}\n\n\t\tvec4 renderI(vec4 pos, int num, vec3 translate, float size)\n\t\t{\n\t\t\tvec4 val1 = mapCube(pos.xyz + vec3( 0, 0, 0 )+translate, vec3(size,size*5.0,size), vec3( 3, 3, 3));\n\t\t\treturn val1;\n\t\t}\n\n\t\tvec4 renderH(vec4 pos, int num, vec3 translate, float size)\n\t\t{\n\t\t\tvec4 val1 = mapCube(pos.xyz + vec3( size*2.0, 0, 0 )+translate, vec3(size,size*5.0,size), vec3( 3, 3, 3));\n\t\t\tvec4 val2 = mapCube(pos.xyz + vec3( -size*2.0, 0, 0 )+translate, vec3(size,size*5.0,size), vec3( 3, 3, 3));\n\t\t\tvec4 val3 = mapCube(pos.xyz + vec3( 0, 0, 0 )+translate, vec3(size,size,size), vec3( 3, 3, 3));\n\t\t\t\n\t\t\tvec4 val4 = combine ( val1, val2 );\n\t\t\treturn combine( val3, val4);\n\t\t}\n\n\t\tvec4 renderChar(vec4 pos, int num, vec3 translate)\n\t\t{\n\t\t\tfloat size = 1.0;\n\t\t\tvec4 res = vec4(0);\n\t\t\tif(num == CHAR_J) \t    { res = renderJ(pos,num,translate,size); } \n\t\t\telse if(num == CHAR_U)  { res = renderU(pos,num,translate,size); }\n\t\t\telse if(num == CHAR_S)  { res = renderS(pos,num,translate,size); }\n\t\t\telse if(num == CHAR_T)  { res = renderT(pos,num,translate,size); }\n\t\t\telse if(num == CHAR_K)  { res = renderK(pos,num,translate,size); }\n\t\t\telse if(num == CHAR_I)  { res = renderI(pos,num,translate,size); }\n\t\t\telse if(num == CHAR_H)  { res = renderH(pos,num,translate,size); }\t\n\n\t\t\treturn res;\n\t\t}\n\n\t\tvec4 map( vec3 pos, mat4 m)\n\t\t{\n\t\t\tvec4 q = vec4(pos+vec3(0,0,-50.0),1.0)*m;\n\t\t\t\n\t\t\tint num = int(mod(iTime,10.));\n\t\t\tif(num != 8 && num != 9 && num != 0){\n\t\t\t\tq.x = mod(q.x, 10.0)-5.0;\n\t\t\t\tq.y = mod(q.y, 16.0)-8.0;\n\t\t\t\t//q.z = mod(q.z, 16.0)-8.0;\n\t\t\t}\n\n\t\t\tvec4 digit;\n\t\t\tint char0;\n\t\t\tint char1;\n\t\t\tint char2;\n\t\t\tint char3;\n\t\t\tif(num == 8 ) {\n\t\t\t\tchar0 = CHAR_T;\n\t\t\t\tchar1 = CHAR_S;\n\t\t\t\tchar2 = CHAR_U;\n\t\t\t\tchar3 = CHAR_J;\n\t\t\t} else if(num == 9) {\n\t\t\t\tchar0 = CHAR_S;\n\t\t\t\tchar1 = CHAR_U;\n\t\t\t} else if(num == 0) {\n\t\t\t\tchar0 = CHAR_H;\n\t\t\t\tchar1 = CHAR_T;\n\t\t\t\tchar2 = CHAR_I;\n\t\t\t\tchar3 = CHAR_K;\n\t\t\t}\n\n\t\t\tif(num == 8 || num == 0) {\n\t\t\t\t// JU:ST\n\t\t\t\tvec4 num1 = renderChar(q,char0,vec3(-15,0,0));\n\t\t\t\tvec4 num2 = renderChar(q,char1,vec3(-5,0,0));\n\t\t\t\tvec4 num3 = renderChar(q,char2,vec3(5,0,0));\n\t\t\t\tvec4 num4 = renderChar(q,char3,vec3(15,0,0));\n\n\t\t\t\tvec4 num5 = combine(num1, num2);\n\t\t\t\tvec4 num6 = combine(num3, num4);\n\t\t\t\treturn combine(num5, num6);\n\t\t\t} if(num == 9) {\n\t\t\t\tvec4 num1 = renderChar(q,char0,vec3(-5,0,0));\n\t\t\t\tvec4 num2 = renderChar(q,char1,vec3(5,0,0));\n\t\t\t\treturn combine(num1, num2);\n\t\t\t} else {\n\t\t\t\tdigit = renderChar(q,num,vec3(0,0,0));\n\t\t\t}\n\n\t\t\treturn digit;\n\t\t}\n\t\t\n\t\tvec2 rot(vec2 p, float a) {\n\t\t\treturn vec2(\n\t\t\t\tcos(a) * p.x - sin(a) * p.y,\n\t\t\t\tsin(a) * p.x + cos(a) * p.y);\n\t\t}\n\n\t\tvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n\t\t\tvec2 position = ( fragCoord.xy / iResolution.xy );\n\t\t\tposition -= .5;\n\t\t\t//if(abs(position.y) > 0.40) discard;\n\t\t\tvec3 dir = vec3(position, -1.0 );\n\t\t\tdir = normalize(dir);\n\n         \tfloat aspect = iResolution.x / iResolution.y;\n         \tdir = normalize(vec3(position * vec2(aspect, 1.0), 1.0));\n\t\t \tdir.yz = rot(dir.yz, 0.1);\n\n\t\t\tvec3 pos = vec3(0.0, 5.0, 15.0);\n\n\t\t\tmat4 m;\n\t\t\tint sec = int(mod(iTime,10.));\n\t\t\tif(sec != 8 && sec != 9 && sec != 0){\n\t\t\t\tfloat dir = 1.0;\n\t\t\t\tif(sec > 4) {\n\t\t\t\t\tdir = -1.0;\n\t\t\t\t}\n\t\t\t\tm = matRotateY(iTime*0.2*dir);\n\t\t\t} else {\n\t\t\t\tpos = vec3(0.0, 5.0, 10.0+mod(iTime,15.));\n\t\t\t\tm = matRotateY(0.);\n\t\t\t}\n\n\t\t\tvec4 result;\n\t\t\tfor (int i =0; i < ITER; i++)\n\t\t\t{\n\t\t\t\tresult = map( pos, m);\n\t\t\t\tif (result.w < NEAR || result.w > FAR) break;\n\t\t\t\tpos += result.w * dir;\n\t\t\t}\n\n\t\t\tvec3 col = map(pos, m).xyz;\n\t\t\tif ( pos.z> 100. )\n\t\t\t{\n\t\t\t\t// background effect\n\t\t\t\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\t\t\tcol = vec3(uv.x+sin(iTime*0.7),0.1,0.3);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvec3 lightPos = vec3(20.0, 20.0, 20.0 );\n\t\t\t\tvec3 light2Pos = normalize( lightPos - pos);\n\t\t\t\tvec3 eps = vec3( .1, .01, .0 );\n\t\t\t\tvec3 n = vec3( result.w - map( pos - eps.xyy , m).w,\n\t\t\t\t\t       result.w - map( pos - eps.yxy , m).w,\n\t\t\t\t\t       result.w - map( pos - eps.yyx , m).w );\n\t\t\t\tn = normalize(n);\n\t\t\t\t\t\t\n\t\t\t\tfloat lambert = max(.0, dot( n, light2Pos));\n\t\t\t\tcol *= vec3(lambert);\n\t\t\t\t\n\t\t\t\tvec3 h = normalize( -dir + light2Pos);\n\t\t\t\tfloat spec = max( 0., dot( n, h ) );\n\t\t\t\tcol += vec3(pow( spec, 16.)) ;\n\t\t\t}\n\t\t\tfragColor = vec4( col, 1.0);\n\t\t}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tBGzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[247, 247, 262, 262, 298], [301, 301, 316, 316, 350], [353, 353, 368, 368, 398], [402, 402, 435, 435, 526], [530, 530, 577, 577, 643], [647, 647, 686, 686, 745], [749, 749, 779, 779, 917], [921, 921, 986, 986, 1239], [1243, 1243, 1306, 1306, 1710], [1714, 1714, 1777, 1777, 2187], [2191, 2191, 2254, 2254, 2950], [2954, 2954, 3017, 3017, 3267], [3271, 3271, 3334, 3334, 3890], [3894, 3894, 3957, 3957, 4080], [4084, 4084, 4147, 4147, 4546], [4550, 4550, 4604, 4604, 5159], [5163, 5163, 5194, 5194, 6345], [6351, 6351, 6378, 6378, 6465], [6469, 6469, 6525, 6525, 8081]], "test": "valid"}
{"id": "4tj3zK", "name": "Position Rotation", "author": "anastadunbar", "description": "Rotation using mat. mat follows a pattern.", "tags": ["2d"], "likes": 1, "viewed": 478, "published": "Public", "date": "1430527625", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rotation(in float angle,in vec2 position,in vec2 center)\n{\n    //Function seen from https://www.shadertoy.com/view/XlsGWf\n    float rot = radians(angle);\n    mat2 rotation = mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n    return vec2((position-center)*rotation);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Time set-up\n    float time = iTime;\n    float sintime = (sin(time)/2.)+0.5;\n    \n    //Stretched uv and angle\n\tvec2 uv = (fragCoord.xy/iResolution.xy);\n    vec2 stuv = ((uv-0.5)*vec2(1.0,0.6))+0.5;\n\tvec2 angle = rotation(time*40.,stuv,(iMouse.xy/iResolution.xy));\n    \n    //Rotating uv\n    vec2 rotuv = vec2(fract((angle*5.)+0.5));\n    \n    //Texture\n    vec3 texture = texture(iChannel0, rotuv).rgb;\n    \n\tfragColor = vec4(mix(texture,vec3(rotuv,0.),sintime),1.0);\n}", "image_inputs": [{"id": "4df3zn", "previewfilepath": "/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tj3zK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 63, 126, 272], [274, 274, 331, 349, 806]], "test": "error"}
{"id": "4tS3W3", "name": "Pulse waves - Visualiser", "author": "uNiversal", "description": "A simpler multiple waveform type visualiser based on Waves Remix by: ADOB\n\nMade to work with Kodi Shadertoy https://github.com/topfs2/visualization.shadertoy", "tags": ["2d", "audio", "visualiser"], "likes": 17, "viewed": 2877, "published": "Public API", "date": "1432811566", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nPulse waves - Visualiser - https://www.shadertoy.com/view/4tS3W3\nBased on Waves Remix by: ADOB - 10th April, 2015 https://www.shadertoy.com/view/4ljGD1\nPulse waves by: uNiversal - 28th May, 2015\nCreative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n*/\n\nfloat squared(float value) { return value * value; }\n\nfloat getAmp(float frequency) { return texture(iChannel0, vec2(frequency / 512.0, 0)).x; }\n\nfloat getWeight(float f) {\n    return (+ getAmp(f-2.0) + getAmp(f-1.0) + getAmp(f+2.0) + getAmp(f+1.0) + getAmp(f)) / 5.0; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uvTrue = fragCoord.xy / iResolution.xy;\n    vec2 uv = -1.0 + 2.0 * uvTrue;\n\n    float lineIntensity;\n    float glowWidth;\n    vec3 color = vec3(0.0);\n\n    for(float i = 0.0; i < 5.0; ++i) {\n\n        uv.y += (0.3 * sin(uv.y + i - 5.0 - iTime * 0.0));\n        float Y = uv.y + getWeight((i) * 20.0) *\n            (texture(iChannel0, vec2(uvTrue.x, 1)).x - 0.5);\n        lineIntensity = 0.5 + squared(0.6 * abs(mod(uvTrue.x + i / 4.3 + iTime,2.0) - 1.0));\n        glowWidth = abs(lineIntensity / (150.0 * Y));\n        color += vec3(glowWidth * (1.5 + sin(iTime * 0.13)),\n                      glowWidth * (1.5 - sin(iTime * 0.23)),\n                      glowWidth * (1.5 - cos(iTime * 0.19)));\n    }    \n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "XsXGRr", "previewfilepath": "/media/ap/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tS3W3.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 278, 306, 306, 330], [332, 332, 363, 363, 422], [424, 424, 450, 450, 548], [550, 550, 607, 607, 1358]], "test": "error"}
{"id": "4tS3zt", "name": "Dichromatic Vision", "author": "Yaniel", "description": "A shader that filters out all colours that aren't red.\nEDIT: Generalised the shader to sort of a bandpass filter for colours.", "tags": ["postprocessing"], "likes": 1, "viewed": 242, "published": "Public", "date": "1431214366", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// conversion routines from http://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat xor(bool a, bool b)\n{\n\treturn float((a || b) && !(a && b));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.y = 1.0-uv.y;\n    uv.x = fract(uv.x+0.5);\n    vec4 color = texture(iChannel0, uv);\n    \n    vec3 hsv = vec3(uv.x, 1.0, 0.5+0.5*xor(mod(uv.x,0.1) > 0.05, mod(uv.y,0.1) > 0.05));\n    //0.76388 to 0.06944\n    if (uv.y < 0.525)\n\t\thsv.y = min(smoothstep(0.4,0.5,abs(fract(hsv.x-0.1*iTime)-0.5)), smoothstep(0.15, 1.0, hsv.y));    \n\tfragColor = vec4(hsv2rgb(hsv), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tS3zt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 103, 125, 125, 456], [458, 458, 480, 480, 649], [651, 651, 678, 678, 718], [720, 720, 777, 777, 1192]], "test": "error"}
{"id": "4tSGDy", "name": "FBM Simplex3D smoke", "author": "Lallis", "description": "Smoke inside a raytraced sphere. The smoke is raymarched with static steps from simplex3d fbm.", "tags": ["fbm", "simplex", "smoke"], "likes": 31, "viewed": 1528, "published": "Public", "date": "1431714310", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//http://webstaff.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf\n//simplex pretty much 99% copied from there\n//adjusted by getting \"completely random\" gradients instead of randoming from 12 preset ones\n//and normalizing the gradient vector\n\n#define time iTime*0.25\n#define PI 3.14159265359\n\nmat3 rot(vec3 ang)\n{\n\tmat3 x = mat3(1.0,0.0,0.0,0.0,cos(ang.x),-sin(ang.x),0.0,sin(ang.x),cos(ang.x));\n\tmat3 y = mat3(cos(ang.y),0.0,sin(ang.y),0.0,1.0,0.0,-sin(ang.y),0.0,cos(ang.y));\n\tmat3 z = mat3(cos(ang.z),-sin(ang.z),0.0,sin(ang.z),cos(ang.z),0.0,0.0,0.0,1.0);\n\treturn x*y*z;\n}\n\nfloat noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,128.852))) * 43758.5453)*2.0-1.0;\n}\n\nfloat simplex3D(vec3 p)\n{\n\t\n\tfloat f3 = 1.0/3.0;\n\tfloat s = (p.x+p.y+p.z)*f3;\n\tint i = int(floor(p.x+s));\n\tint j = int(floor(p.y+s));\n\tint k = int(floor(p.z+s));\n\t\n\tfloat g3 = 1.0/6.0;\n\tfloat t = float((i+j+k))*g3;\n\tfloat x0 = float(i)-t;\n\tfloat y0 = float(j)-t;\n\tfloat z0 = float(k)-t;\n\tx0 = p.x-x0;\n\ty0 = p.y-y0;\n\tz0 = p.z-z0;\n\t\n\tint i1,j1,k1;\n\tint i2,j2,k2;\n\t\n\tif(x0>=y0)\n\t{\n\t\tif(y0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } // X Y Z order\n\t\telse if(x0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } // X Z Y order\n\t\telse { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }  // Z X Z order\n\t}\n\telse \n\t{ \n\t\tif(y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } // Z Y X order\n\t\telse if(x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } // Y Z X order\n\t\telse { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } // Y X Z order\n\t}\n\t\n\tfloat x1 = x0 - float(i1) + g3; \n\tfloat y1 = y0 - float(j1) + g3;\n\tfloat z1 = z0 - float(k1) + g3;\n\tfloat x2 = x0 - float(i2) + 2.0*g3; \n\tfloat y2 = y0 - float(j2) + 2.0*g3;\n\tfloat z2 = z0 - float(k2) + 2.0*g3;\n\tfloat x3 = x0 - 1.0 + 3.0*g3; \n\tfloat y3 = y0 - 1.0 + 3.0*g3;\n\tfloat z3 = z0 - 1.0 + 3.0*g3;\t\n\t\t\t\t \n\tvec3 ijk0 = vec3(i,j,k);\n\tvec3 ijk1 = vec3(i+i1,j+j1,k+k1);\t\n\tvec3 ijk2 = vec3(i+i2,j+j2,k+k2);\n\tvec3 ijk3 = vec3(i+1,j+1,k+1);\t\n            \n\tvec3 gr0 = normalize(vec3(noise3D(ijk0),noise3D(ijk0*2.01),noise3D(ijk0*2.02)));\n\tvec3 gr1 = normalize(vec3(noise3D(ijk1),noise3D(ijk1*2.01),noise3D(ijk1*2.02)));\n\tvec3 gr2 = normalize(vec3(noise3D(ijk2),noise3D(ijk2*2.01),noise3D(ijk2*2.02)));\n\tvec3 gr3 = normalize(vec3(noise3D(ijk3),noise3D(ijk3*2.01),noise3D(ijk3*2.02)));\n\t\n\tfloat n0 = 0.0;\n\tfloat n1 = 0.0;\n\tfloat n2 = 0.0;\n\tfloat n3 = 0.0;\n\n\tfloat t0 = 0.5 - x0*x0 - y0*y0 - z0*z0;\n\tif(t0>=0.0)\n\t{\n\t\tt0*=t0;\n\t\tn0 = t0 * t0 * dot(gr0, vec3(x0, y0, z0));\n\t}\n\tfloat t1 = 0.5 - x1*x1 - y1*y1 - z1*z1;\n\tif(t1>=0.0)\n\t{\n\t\tt1*=t1;\n\t\tn1 = t1 * t1 * dot(gr1, vec3(x1, y1, z1));\n\t}\n\tfloat t2 = 0.5 - x2*x2 - y2*y2 - z2*z2;\n\tif(t2>=0.0)\n\t{\n\t\tt2 *= t2;\n\t\tn2 = t2 * t2 * dot(gr2, vec3(x2, y2, z2));\n\t}\n\tfloat t3 = 0.5 - x3*x3 - y3*y3 - z3*z3;\n\tif(t3>=0.0)\n\t{\n\t\tt3 *= t3;\n\t\tn3 = t3 * t3 * dot(gr3, vec3(x3, y3, z3));\n\t}\n\treturn 96.0*(n0+n1+n2+n3);\n\t\n}\n\nfloat fbm(vec3 p)\n{\n\tfloat f;\n    f  = 0.50000*simplex3D( p ); p = p*2.01;\n    f += 0.25000*simplex3D( p ); p = p*2.02; //from iq\n    f += 0.12500*simplex3D( p ); p = p*2.03;\n    f += 0.06250*simplex3D( p ); p = p*2.04;\n    f += 0.03125*simplex3D( p );\n\treturn f;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\tvec2 p = uv*2.0-1.0;\n\tp.x*=(iResolution.x/iResolution.y);\n\tvec3 col = vec3(0.1);\n    vec3 ro = vec3(0.0,0.0,-2.0);\n    vec3 rd = normalize(vec3(p,0.0)-ro);\n    ro*=rot(vec3(time-2.0*PI*iMouse.y/iResolution.y,time+2.0*PI*iMouse.x/iResolution.x,0.0));\n    rd*=rot(vec3(time-2.0*PI*iMouse.y/iResolution.y,time+2.0*PI*iMouse.x/iResolution.x,0.0));\n    vec3 rp = ro;\n    if(pow(dot(rd,ro-vec3(0.0)),2.0) - pow(length(ro-vec3(0.0)),2.0) + 1.0>0.0)\n    {\n    \tfloat d = -dot(rd,(ro-vec3(0.0)))-sqrt(pow(dot(rd,ro-vec3(0.0)),2.0) - pow(length(ro-vec3(0.0)),2.0) + 1.0);\n    \trp+=rd*d;\n    \tfloat t = 0.05;\n    \tfor(int i = 0; i<64; i++)\n   \t\t{       \n        \trp+= rd*t;\n        \tfloat ds = length(rp)-1.0;\n        \tif(ds>0.0) break;\n        \tcol = mix(col, \n                      vec3(1.0*abs(sin(time)),1.5*abs(ds),1.0*abs(sin(time+PI*0.5))),\n                      (fbm(rp*2.0)*4.0+1.0)*abs(ds)*0.1);\n   \t\t}\n    }\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tSGDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 292, 312, 312, 575], [577, 577, 600, 600, 681], [683, 683, 708, 708, 2833], [2835, 2835, 2854, 2854, 3100], [3102, 3102, 3157, 3157, 4139]], "test": "valid"}
{"id": "ldfGDN", "name": "2013", "author": "w23", "description": "This was a silly attempt at marching fbm-based terrain and clouds together that I made somewhere in 2013 while learning GLSL. Although it is full of bad code, slowness, artifacts, dumb ideas and cannot be fixed, it still looks rather cool so here it is.", "tags": ["noise", "terrain", "raymarch", "clouds", "old", "bad"], "likes": 50, "viewed": 2373, "published": "Public", "date": "1430930413", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//uniform float g_time;\n//varying vec2 p;\n\nfloat t;// = iTime * .5;\nconst float c_pi = 3.1415926;\n\nstruct ray_t { vec3 origin, dir; };\n#define RT(r,l) (r.origin + r.dir * l)\nstruct material_t { vec3 diffuse; float specular; };\nstruct light_dir_t { vec3 color, dir; };\n\nmaterial_t cmat = material_t(vec3(.6, .75, .2), 500000.);\nlight_dir_t sun = light_dir_t(vec3(1., .9, .5), normalize(vec3(1.3, 1., -.2)));\n\n// Make a ray using normalized pixel position, eye position and focus point\nray_t lookAtDir(in vec3 uv_dir, in vec3 pos, in vec3 at) {\n\tvec3 f = normalize(at - pos);\n\tvec3 r = cross(f, vec3(0.,1.,0.));\n\tvec3 u = cross(r, f);\n\treturn ray_t(pos, normalize(uv_dir.x * r + uv_dir.y * u + uv_dir.z * f));\n}\n\nfloat hash(in float x) { return fract(sin(x*.0007)*29835.24389); }\nfloat hash(in vec2 x) { return hash(dot(x,vec2(23.17,17.23))); }\nfloat hash(in vec3 x) { return hash(dot(x,vec3(23.17,17.23,42.5))); }\nfloat noise_value(in vec2 p) {\n\tvec2 e=vec2(1.,0.), F = floor(p), f = fract(p), k = (3. - 2.*f) * f * f;\n\treturn mix(mix(hash(F),      hash(F+e.xy), k.x),\n\t\t\t   mix(hash(F+e.yx), hash(F+e.xx), k.x), k.y);\n}\nfloat noise_value(in vec3 p) {\n\tvec2 e = vec2(1.,0.);\n\tvec3 F = floor(p), f = fract(p), k = (3. - 2.*f) * f * f;\n\treturn mix(\n\t\t   mix(mix(hash(F),       hash(F+e.xyy), k.x),\n\t\t\t   mix(hash(F+e.yxy), hash(F+e.xxy), k.x), k.y),\n\t\t   mix(mix(hash(F+e.yyx), hash(F+e.xyx), k.x),\n\t\t\t   mix(hash(F+e.yxx), hash(F+e.xxx), k.x), k.y), k.z);\n}\n\nfloat terrain_height(in vec3 at) {\n\tfloat k = .5;\n\tvec2 p = at.xz * .0005;\n\tmat2 m = mat2(1.3,  1.5, 1.5, -1.3);\n\tfloat h = 0.;//noise_value(p) * k;\n\tfor (int i = 0; i < 8; ++i) { h += noise_value(p) * k; k *= .5; p = m * p; }\n\treturn 1200. * h * h * h * h;\n}\n\t\nfloat terrain_distance(in vec3 at) {\n\treturn min(1.+at.y,at.y - terrain_height(at));\n}\n\nfloat cloud_noise(in vec3 p) {\n\tfloat k = .5, v = 0.;\n    v += noise_value(p) * k; k *= .5; p =  p * 2.01;\n    v += noise_value(p) * k; k *= .5; p =  p * 2.01;\n    v += noise_value(p) * k; k *= .5; p =  p * 2.01;\n    v += noise_value(p) * k; k *= .5; p =  p * 2.01;\n\treturn v;\n}\n\n#define MAX_DISTANCE 23000.\n#define CLOUDS_HEIGHT_MAX 3000.\n#define CLOUDS_HEIGHT_MIN 1000.\n\nvec4 accum = vec4(0.);\nfloat prevV = 0.;\nfloat dist = 0.;\nfloat solid = 0.;\n\nfloat world(in vec3 at, in vec3 dir) {\n\tif (at.y > CLOUDS_HEIGHT_MAX)\n\t\treturn (dir.y < 0.) ? (at.y - CLOUDS_HEIGHT_MAX + 10.) / -dir.y : 1000.;\n\tif (at.y > CLOUDS_HEIGHT_MIN) {\n\t\tvec3 cs = at*.001 - t *.3;\n\t\tfloat k = sin((at.y - CLOUDS_HEIGHT_MIN) / (CLOUDS_HEIGHT_MAX - CLOUDS_HEIGHT_MIN) * c_pi),\n\t\t\tv = cloud_noise(cs) * k,\n\t\t\tV = max(0., v * v - .13);\n\t\tif (V > .0) {\n\t\t\tfloat A = ((V + prevV) * .5 * dist) * .005;\n\t\t\t//vec3 cloudcolor = vec3(.125);// * V;// + sun.color * max(0.,(-cloud_noise(cs+sun.dir*.01)+v))*7.725;\n\t\t\tvec3 cloudcolor = vec3(1.) + sun.color * max(0.,(-cloud_noise(cs+sun.dir*100.)+v)) * 2.;\n\t\t\taccum.rgb += cloudcolor * A * (1. - accum.a);\n\t\t\taccum.a += A;\n\t\t}\n\t\tprevV = V;\n\t\treturn 1. + 200. * (1. - V);\n\t}\n\tfloat H = terrain_distance(at);\n\treturn (dir.y <= 0.) ? H : min(H, (CLOUDS_HEIGHT_MIN + 10. - at.y) / dir.y);\n}\n\nvec3 normal(in vec3 at) {\n\tvec2 e = vec2(.1, .0);\n\treturn normalize(vec3(world(at+e.xyy, vec3(0.))-world(at, vec3(0.)),\n\t\t  world(at+e.yxy, vec3(0.))-world(at, vec3(0.)),\n\t\t  world(at+e.yyx, vec3(0.))-world(at, vec3(0.))));\n}\n\nfloat trace(in ray_t ray, in float maxPath) {\n\tfloat path = 0.;\n\tfor (int i = 0; i < 128; ++i) {\n\t\tdist = world(RT(ray, path), ray.dir);\n\t\tif (dist < .001*path) { solid = 1.; break; }\n\t\tif (accum.a >= 1.) break;\n\t\tpath += dist;\n\t\tif (path > maxPath) break;\n\t}\n\treturn path;\n}\n\nvec3 background(in vec3 dir) {\n    vec3 ac = vec3(101.,133.,162.) / 255.;\n\treturn ac + sun.color * pow(max(0., dot(dir, sun.dir)), 40.);\n}\n\nvec3 light(in vec3 at, in vec3 from, in light_dir_t l) {\n\tvec3 n = normal(at), h = normalize(from + l.dir);\n\t//if (trace(ray_t(at+n*1., l.dir), 3000.) < 3000.) return vec3(0.);\n\treturn l.color * (\n\t\tcmat.diffuse * max(0., dot(n, l.dir))\n\t\t+ pow(max(0., dot(n, h)), cmat.specular) * (cmat.specular + 8.) / (8. * c_pi));\n}\n\nvoid update_mat(in vec3 at) {\n\tfloat h = at.y;// + 30. * (noise_value(at.zx*.00002) - .5);\n\tif (h < 125.) {\n\t\tcmat.diffuse = vec3(.2, .4, .9);\n\t\tcmat.specular = 30.;\n\t} else if(h < 150.) {\n\t\tcmat.diffuse = vec3(.8, .8, .2);\n\t} else if(h < 220.) {\n\t\tcmat.diffuse = vec3(.8, .9, .2);\n\t} else if(h > 400.) {\n\t\tcmat.diffuse = vec3(1.);\n\t} else {\n\t\tcmat.specular = 100000.;\n\t}\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    t = iTime * .5;\n\t// Calculate normalized and aspect-corrected pixel position \n\tfloat aspect = iResolution.x / iResolution.y;\n\tvec2 uv = (fragCoord.xy / iResolution.xy * 2. - 1.) * vec2(aspect, 1.);\n\t\n\tray_t ray;\n\tif (iMouse.z <= 0.) {\n\t\tfloat s = sin(-t*.2), c = cos(t*.2);\n\t\tmat3 r = mat3(c, 0., -s, 0., 1., 0., s, 0., c);\n\t\tvec3 at = vec3(1500.*t, 0., 0.);\n\t\tvec3 pos = at + r * (vec3(8000.,4000.,8000.)*(1.1 + sin(t*.5)));\n\t\tray = lookAtDir(normalize(vec3(uv, 2.)), pos, at+vec3(0., 2000.*sin(t), 0.));\n\t} else {\n\t\tvec2 mp = iMouse.xy / iResolution.xy;\n\t\tfloat a = 2. * c_pi * mp.x;\n\t\tfloat s = sin(a), c = cos(a);\n\t\tmat3 r = mat3(c, 0., -s, 0., 1., 0., s, 0., c);\n\t\tray = lookAtDir(normalize(vec3(uv, 2.)),\n\t\t \t\t\t    vec3(1500.*t, 0. ,0.)+r*vec3(6000.,100.+6000.*(1.-mp.y),6000.),\n\t\t\t\t\t\tvec3(1500.*t, 0. ,0.));\n\t}\n\n\tray.origin.y = max(terrain_height(ray.origin)+10., ray.origin.y);\n\tfloat path = trace(ray, MAX_DISTANCE);\n\n\tvec3 color = vec3(0.);\n\taccum.a = min(accum.a, 1.);\n\tif (solid > 0.) {\n\t\tvec3 at = RT(ray,path);\n\t\tupdate_mat(at);\n\t\tcolor = light(at, -ray.dir, sun);\n\t} else {\n\t\tcolor = accum.rgb;\n\t}\n\n    float klen = clamp(pow(path / MAX_DISTANCE, 2.), 0., 1.);\n\tcolor = mix(color, background(ray.dir), klen) * (1.-accum.a) + accum.rgb;\n    color += .64 * sun.color * pow(max(0., dot(ray.dir, sun.dir)), 2.);\n\n\tfragColor = vec4(color, 0.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldfGDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[408, 484, 542, 542, 709], [711, 711, 735, 735, 777], [778, 778, 801, 801, 842], [843, 843, 866, 866, 912], [913, 913, 943, 943, 1119], [1120, 1120, 1150, 1150, 1455], [1457, 1457, 1491, 1491, 1716], [1719, 1719, 1755, 1755, 1805], [1807, 1807, 1837, 1837, 2085], [2257, 2257, 2295, 2295, 3105], [3107, 3107, 3132, 3132, 3332], [3334, 3334, 3379, 3379, 3609], [3611, 3611, 3641, 3641, 3749], [3751, 3751, 3807, 3807, 4071], [4073, 4073, 4102, 4102, 4446], [4448, 4448, 4505, 4505, 5865]], "test": "valid"}
{"id": "ll23Rc", "name": "Manhattan IFS", "author": "avi", "description": "Putting back the cubes...", "tags": ["3d", "ifs", "manhattan", "koch"], "likes": 4, "viewed": 226, "published": "Public", "date": "1431128958", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Modified by Avi Levy (c) 2015\n *\n * This is a Manhattan surface,\n * rendered using an IFS.\n *\n * IFS equations due to Brent Werness\n *\n * Instructions:\n *      Click and drag the fractal\n *          - Upwards zooms in\n *          - Left/right rotates\n *\n * \n * \n * Original by inigo quilez - iq/2013\n */\n\nconst int iterations = 8;\nfloat scale = 3.;\nfloat colorScale = 9.;\n\nconst vec3 v1 = vec3(  2./3.,  0.,  0. );\nconst vec3 v2 = vec3(  -2./3.,  0.,  0. );\nconst vec3 v3 = vec3(  0.,  2./3.,  0. );\nconst vec3 v4 = vec3(  0.,  -2./3.,  0. );\nconst vec3 v5 = vec3(  0.,  0.,  2./3. );\nconst vec3 v6 = vec3(  0.,  0.,  -2./3. );\n\nconst vec3 a1 = vec3(  1./3.,  1./3., 0. );\nconst vec3 a2 = vec3(  -1./3.,  1./3., 0. );\nconst vec3 a3 = vec3(  1./3.,  -1./3., 0. );\nconst vec3 a4 = vec3(  -1./3.,  -1./3., 0. );\n\nconst vec3 b1 = vec3(  0.,  1./3., 1./3. );\nconst vec3 b2 = vec3(  0.,  -1./3., 1./3. );\nconst vec3 b3 = vec3(  0.,  1./3., -1./3. );\nconst vec3 b4 = vec3(  0.,  -1./3., -1./3. );\n\nconst vec3 c1 = vec3(  1./3.,  0., 1./3. );\nconst vec3 c2 = vec3(  -1./3.,  0., 1./3. );\nconst vec3 c3 = vec3(  1./3.,  0., -1./3. );\nconst vec3 c4 = vec3(  -1./3.,  0., -1./3. );\n\nconst vec3 x1 = vec3(  1./3.,  1./3., 1./3. );\nconst vec3 x2 = vec3(  -1./3.,  1./3., 1./3. );\nconst vec3 x3 = vec3(  1./3.,  -1./3., 1./3. );\nconst vec3 x4 = vec3(  -1./3.,  -1./3., 1./3. );\nconst vec3 x5 = vec3(  1./3.,  1./3., -1./3. );\nconst vec3 x6 = vec3(  -1./3.,  1./3., -1./3. );\nconst vec3 x7 = vec3(  1./3.,  -1./3., -1./3. );\nconst vec3 x8 = vec3(  -1./3.,  -1./3., -1./3. );\n\nfloat rect(vec3 p, vec3 radius) {\n    return length(max(abs(p) - radius, 0.));\n}\n\n// return distance and address\nvec2 map(vec3 p) {\n    float cube = rect(p, vec3(1./3.));\n\n    float a = 0.0;\n    float s = 1.0;\n    float r = 1.0;\n    float dm;\n    vec3 v;\n    for(int i=0; i < iterations; i++) {\n        float d, t;\n        d = dot(p-v1,p-v1);\n        //if( d<dm ) {\n            v=v1; dm=d; t = 0.;\n        //}        \n        d = dot(p-v2,p-v2);\n        if( d<dm ) {\n            v=v2; dm=d; t = 1.;\n        }\n        d = dot(p-v3,p-v3);\n        if( d<dm ) {\n            v=v3; dm=d; t = 2.;\n        }\n        d = dot(p-v4,p-v4);\n        if( d<dm ) {\n            v=v4; dm=d; t = 3.;\n        }\n        d = dot(p-v5,p-v5);\n        if( d<dm ) {\n            v=v5; dm=d; t = 4.;\n        }\n        d = dot(p-v6,p-v6);\n        if( d<dm ) {\n            v=v6; dm=d; t = 5.;\n        }\n\n        d = dot(p-a1,p-a1);\n        if( d<dm ) {\n            v=a1; dm=d; t = 6.;\n        }\n        d = dot(p-a2,p-a2);\n        if( d<dm ) {\n            v=a2; dm=d; t = 7.;\n        }\n        d = dot(p-a3,p-a3);\n        if( d<dm ) {\n            v=a3; dm=d; t = 8.;\n        }\n        d = dot(p-a4,p-a4);\n        if( d<dm ) {\n            v=a4; dm=d; t = 9.;\n        }                        \n        \n        d = dot(p-b1,p-b1);\n        if( d<dm ) {\n            v=b1; dm=d; t = 10.;\n        }\n        d = dot(p-b2,p-b2);\n        if( d<dm ) {\n            v=b2; dm=d; t = 11.;\n        }\n        d = dot(p-b3,p-b3);\n        if( d<dm ) {\n            v=b3; dm=d; t = 12.;\n        }\n        d = dot(p-b4,p-b4);\n        if( d<dm ) {\n            v=b4; dm=d; t = 13.;\n        }\n\n        d = dot(p-c1,p-c1);\n        if( d<dm ) {\n            v=c1; dm=d; t = 14.;\n        }\n        d = dot(p-c2,p-c2);\n        if( d<dm ) {\n            v=c2; dm=d; t = 15.;\n        }\n        d = dot(p-c3,p-c3);\n        if( d<dm ) {\n            v=c3; dm=d; t = 16.;\n        }\n        d = dot(p-c4,p-c4);\n        if( d<dm ) {\n            v=c4; dm=d; t = 17.;\n        }\n\n        d = dot(p-x1,p-x1);\n        if( d<dm ) {\n            v=x1; dm=d; t = 18.;\n        }\n        d = dot(p-x2,p-x2);\n        if( d<dm ) {\n            v=x2; dm=d; t = 19.;\n        }\n        d = dot(p-x3,p-x3);\n        if( d<dm ) {\n            v=x3; dm=d; t = 20.;\n        }\n        d = dot(p-x4,p-x4);\n        if( d<dm ) {\n            v=x4; dm=d; t = 21.;\n        }\n        d = dot(p-x5,p-x5);\n        if( d<dm ) {\n            v=x5 ; dm=d; t = 22.;\n        }\n        d = dot(p-x6,p-x6);\n        if( d<dm ) {\n            v=x6; dm=d; t = 23.;\n        }\n        d = dot(p-x7,p-x7);\n        if( d<dm ) {\n            v=x7; dm=d; t = 24.;\n        }\n        d = dot(p-x8,p-x8);\n        if( d<dm ) {\n            v=x8; dm=d; t = 25.;\n        }        \n        p = v + scale * (p - v);\n        r *= scale;\n        s *= colorScale;\n        a = t + colorScale * a;\n    }\n    \n    float manhattan = (sqrt(dm)-0.5)/r;\n    if(cube < manhattan) {\n        return vec2(cube, 0.);\n    } else {\n        return vec2(manhattan, a/s);\n    }\n}\n\nconst float precis = 0.000001;\n\nvec3 intersect(in vec3 ro, in vec3 rd) {\n    vec3 res = vec3(1e20, 0.0, 0.0);\n    \n    float maxd = 5.0;\n\n    // sierpinski\n    float h = 1.0;\n    float t = 0.5;\n    float m = 0.0;\n    vec2 r;\n    for(int i=0; i<100; i++) {\n        r = map( ro+rd*t );\n        if( r.x<precis || t>maxd ) break;\n        m = r.y;\n        t += r.x;\n    }\n\n    if(t < maxd && r.x < precis) {\n        res = vec3(t, 2., m);\n    }\n\n    return res;\n}\n\nvec3 light = normalize(vec3(1., .7, .9));\n\nvec4 render(in vec3 ro, in vec3 rd) {\n    // raymarch\n    vec3 tm = intersect(ro,rd);\n    if(tm.y < 0.5) {\n        return vec4(0., 0., 0., 1.);\n    }\n    // Position vector\n    vec3 position = ro + tm.x * rd;\n    \n    // Normal vector calculation\n    vec3 epsilon = vec3(precis, 0., 0.);\n    vec3 normal = normalize(\n        vec3(\n            map(position + epsilon.xyy).x - map(position - epsilon.xyy).x,\n            map(position + epsilon.yxy).x - map(position - epsilon.yxy).x,\n            map(position + epsilon.yyx).x - map(position - epsilon.yyx).x\n        )\n    );\n\n    // Occlusion calculation\n    float ao = 0.;\n    float sca = 1.;\n    for(int i=0; i<8; i++) {\n        float h = 0.001 + 0.5*pow(float(i)/7.0,1.5);\n        float d = map(position + h * normal).x;\n        ao += -(d-h)*sca;\n        sca *= 0.95;\n    }\n\n    // surface-light interacion\n    vec3 color = (\n        .5 + .5 * cos(\n            6.2831 * tm.z + vec3(0., 1., 2.)\n        )\n    )\n    * (0.5 + 0.5 * normal.y) // ambient lighting\n    * clamp(1.0 - 0.8*ao, 0.0, 1.0) // occlusion\n    * 1.5 * vec3(1);\n\n    return vec4(\n        pow(clamp(color, 0., 1.), vec3(.45)) // gamma\n    , 1.);\n}\n\nvoid mainImage(out vec4 color, in vec2 fragCoord) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.5);\n    if(iMouse.z>0.0) {\n        m = iMouse.xy/iResolution.xy/10.;\n        m.y = pow(2., 150. * m.y - 3.);\n    }\n\n    // camera\n    float an = 3.2 + 0.5*iTime - 6.2831*(m.x-0.5);\n\n    vec3 ro = vec3(2.5*sin(an),0.,2.5*cos(an));\n    vec3 ta = vec3(0.0,0.,0.0);\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 5.0*ww*m.y );\n\n    color = render(ro, rd);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll23Rc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 1564, 1597, 1597, 1644], [1646, 1677, 1695, 1695, 4594], [4628, 4628, 4668, 4668, 5053], [5098, 5098, 5135, 5151, 6261], [6263, 6263, 6314, 6314, 6930]], "test": "valid"}
{"id": "ll23Rd", "name": "Companion Cube Remix", "author": "ChristinaCoffin", "description": "Remixed a couple existing shadertoys that had nothing to do with a companion cube to make a \"Companion Cube\" :) \nSee the tex() + heartMapping() func for my main experiment of mixing procedural heart shape in raymarching object", "tags": ["procedural", "raymarching"], "likes": 68, "viewed": 4295, "published": "Public", "date": "1431588925", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Companion Cube Remix - @christinacoffin\n//\t- heart shape mapping doesnt completely play nice with the parallax mapping, something to improve upon.\n// \t\n// modified version of Parallax mapping demo by nimitz (twitter: @stormoid)  : https://www.shadertoy.com/view/4lSGRh\n// modified procedural heartshape by Iq : https://www.shadertoy.com/view/XsfGRn\n\n//Show only the raymarched geometry (for comparison)\n//#define RAYMARCHED_ONLY\n\n//The amount of parallax\n#define PARALLAX_SCALE .2\n\n//Scale the texture offset as a function of incidence (much better results)\n#define USE_OFFSET_SCALING\n#define OFFSET_SCALE 4.\n\n//Bump mapping intensity\n#define BUMP_STRENGTH .21\n#define BUMP_WIDTH 0.004\n\n//Main texture scale\nconst float texscl = 2.5;\n\n#define ITR 70\n#define FAR 15.\n#define time iTime\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\nfloat hash(vec2 x){\treturn fract(cos(dot(x.xy,vec2(2.31,53.21))*124.123)*412.0); }\n\nfloat sdfsw = 0.; //Global mouse control\n\nfloat length4(in vec3 p ){\n\tp = p*p; p = p*p;\n\treturn pow( p.x + p.y + p.z, 1.0/4.0 );\n}\n\nfloat map(vec3 p)\n{\n    float d = mix(length(p)-1.1,length4(p)-1.,sdfsw-0.3);\n    d = min(d, -(length4(p)-4.));\n    return d*.95;\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tfloat precis = 0.001;\n    float h=precis*2.0;\n    float d = 0.;\n    for( int i=0; i<ITR; i++ )\n    {\n        if( abs(h)<precis || d>FAR ) break;\n        d += h;\n\t    float res = map(ro+rd*d);\n        h = res;\n    }\n\treturn d;\n}\n\nvec3 normal(in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.005;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\n//From TekF (https://www.shadertoy.com/view/ltXGWS)\nfloat cells(in vec3 p)\n{\n    p = fract(p/2.0)*2.0;\n    p = min(p, 2.0-p);\n    return 1.-min(length(p),length(p-1.0));\n}\n\nvec4 heartMapping( in vec2 p )\n{\t\n\tp.y -= 0.25;\n\n    // background color\n    // make this black for now since we use the heart shape to displace things and dont want the other parts affected (keep it black colored)\n    vec3 bcol = vec3(0,0,0);//1.0,0.8,0.7-0.07*p.y)*(1.0-0.25*length(p));\n\n    float tt = mod(iTime,1.5)/1.5;\n    float ss = pow(tt,.2)*0.5 + 0.5;\n    ss = 1.0 + ss*0.5*sin(tt*6.2831*3.0 + p.y*0.5)*exp(-tt*4.0);\n    p *= vec2(0.5,1.5) + ss*vec2(0.5,-0.5);\n\n    // shape\n    float a = atan(p.x,p.y)/3.141593;\n    float r = length(p);\n    float h = abs(a);\n    float d = (13.0*h - 22.0*h*h + 10.0*h*h*h)/(6.0-5.0*h);\n\n\t// color\n\tfloat s = d;//1.0-0.5*clamp(r/d,0.0,1.0);\n    \n\ts = 0.5;// + 0.5*p.x;\n\ts *= 1.0;//-0.25*r;\n\ts = 0.5 + 0.6*s;\n\n\ts *= 0.5+0.5*pow( 1.0-clamp(r/d, 0.0, 1.0 ), 0.1 );\n\n\tvec3 hcol = vec3(1.0,0.0,0.3)*s;\n\t\n    vec3 col = mix( bcol, hcol, smoothstep( -0.01, 0.01, d-r) );\n\n    col.x *= ss;//fluctate color based on the beating animation\n    col.y = ss;//\n\n    //todo: we could encode other shapes in other color channels and mix them in tex() differently\n    \n    return vec4(col,1.0);\n}\n\nfloat tex( vec3 p )\n{\n    p *= texscl;\n    float rz= 0.0;//-0.5;\n    float z= 1.;\n    \n    // do the Heart shape mapping before the parallax loop warps the position data\n    // triplanar map it so we get it on all 6 sides\n    float heartScaleFactor = 1.1;\n    vec4 heart0 = heartMapping( p.xy * heartScaleFactor );\n    vec4 heart1 = heartMapping( p.zy * heartScaleFactor );\n    vec4 heart2 = heartMapping( p.xz * heartScaleFactor );\n    \n    heart0 = max( heart0, heart1 );\n    heart0 = max( heart0, heart2 );\n    float heartMask = (heart0.x + heart1.x + heart2.x *0.333);\n    heartMask = clamp(heartMask, 0.0, 1.0);\n    \n    for ( int i=0; i<2; i++ )\n    { \n        #ifndef RAYMARCHED_ONLY\n        rz += cells(p)/z;\n        #endif\n        \n        p *= 2.5*0.15;\n        z *= -1.1*0.15;\n    }\n \n    return clamp(heartMask+(rz*rz)*4.95,0.,1.)*2.73 - 1.0-heartMask;\n}\n\n/*\n\tThe idea is to displace the shaded position along the surface normal towards\n\tthe viewer,\tthe tgt vector is the displacement vector, then\tI apply a scaling\n\tfactor to the displacement and also have an incidence based\toffset scaling set up.\n*/\nvec3 prlpos(in vec3 p, in vec3 n, in vec3 rd)\n{\n    //vec3 tgt = cross(cross(rd,n), n); //Naive method (easier to grasp?)\n    vec3 tgt = n*dot(rd, n) - rd; //Optimized\n\n#ifdef USE_OFFSET_SCALING\n    tgt /= (abs(dot(tgt,rd)))+OFFSET_SCALE;\n    \n#endif\n    \n    p += tgt*tex(p)*PARALLAX_SCALE;\n    return p;\n}\n\nfloat btex(in vec3 p)\n{\n    float rz=  tex(p);\n    rz += tex(p*20.)*0.01; //Extra (non-parallaxed) bump mapping can be added\n    \n //   rz += tex(p);\n    \n    return rz;\n}\n\nvec3 bump(in vec3 p, in vec3 n, in float ds)\n{\n    vec2 e = vec2(BUMP_WIDTH*sqrt(ds)*0.5, 0);\n    float n0 = btex(p);\n    vec3 d = vec3(btex(p+e.xyy)-n0, btex(p+e.yxy)-n0, btex(p+e.yyx)-n0)/e.x;\n    vec3 tgd = d - n*dot(n ,d);\n    n = normalize(n-tgd*BUMP_STRENGTH*2./(ds));\n    return n;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 bp = fragCoord.xy/iResolution.xy*2.-1.; \n    vec2 p = bp;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(0.4,-0.25):mo;\n\tmo.x *= iResolution.x/iResolution.y;\n\t\n    \n    mo.y = 0.425;// lock the shape to be 'companion cube-ish in appearance\n    mo.y += (0.5 * abs(sin(iTime)))-0.15; \n    \n    p.x += mo.x*1.;\n    sdfsw = mo.y*4.;\n    \n\tvec3 ro = vec3(0.,0.,4.);\n    vec3 rd = normalize(vec3(p,-3.+sin(time*0.9+sin(time))));\n    mat2 mx = mm2(time*.1+sin(time*0.4)-0.2);\n    mat2 my = mm2(time*0.07+cos(time*0.33)-0.1);\n    ro.xz *= mx;rd.xz *= mx;\n    ro.xy *= my;rd.xy *= my;\n\t\n\tfloat rz = march(ro,rd);\n\t\n    vec3 col = vec3(0);\n    \n    if ( rz < FAR )\n    {\n        vec3 pos = ro+rz*rd;\n        vec3 nor= normal( pos );\n        pos = prlpos(pos,nor,rd);\n        float d = distance(ro,pos);\n        nor = bump(pos, nor, d);\n\n        vec3 ligt = normalize( vec3(-.5, 0.5, -0.3) );\n        float dif = clamp( dot( nor, ligt ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-ligt))), 0.0, 1.0 );\n        float spe = pow(clamp( dot( reflect(rd,nor), ligt ), 0.0, 1.0 ),10.);\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        vec3 brdf = vec3(0.3);\n        brdf += bac*vec3(0.3);\n        brdf += dif*0.5;\n        \n        float tx=  tex(pos);\n        col = sin(vec3(1.5+mo.x*0.4,2.2+mo.x*0.25,2.7)+tx*1.2+4.2)*0.6+0.55;\n        col = col*brdf + spe*.5/sqrt(rz) +.25*fre;\n        \n        col = mix(col,vec3(.0),clamp(exp(rz*0.43-4.),0.,1.));\n    }\n \n    col.x *= col.z;//colorize\n    col.xyz = col.zxy;//color channel flip!   \n    \n    \n    col = clamp(col*1.05,0.,1.);\n    col *= pow(smoothstep(0.,.2,(bp.x + 1.)*(bp.y + 1.)*(bp.x - 1.)*(bp.y - 1.)),.3);\n    col *= smoothstep(3.9,.5,sin(p.y*.5*iResolution.y+time*10.))+0.1;\n    col -= hash(col.xy+p.xy)*.025;\n\t\n\n    \n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll23Rd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[690, 789, 810, 810, 862], [863, 863, 882, 882, 945], [965, 989, 1015, 1015, 1077], [1079, 1079, 1098, 1098, 1210], [1212, 1212, 1249, 1249, 1478], [1480, 1480, 1504, 1504, 1666], [1668, 1720, 1744, 1744, 1839], [1841, 1841, 1873, 1873, 2963], [2965, 2965, 2986, 2986, 3831], [3833, 4080, 4127, 4201, 4387], [4389, 4389, 4412, 4412, 4560], [4562, 4562, 4608, 4608, 4852], [4854, 4854, 4911, 4911, 6820]], "test": "valid"}
{"id": "ll2GDV", "name": "UnNamed 1", "author": "aiekick", "description": "UnNamed 1", "tags": ["unnamed1"], "likes": 2, "viewed": 1092, "published": "Public API", "date": "1432748755", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define uTime iTime \n#define uScreenSize iResolution.xy \n\nvec2 s,g,m;\nfloat dstepf = 0.0; // perf analyse float\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\ts = uScreenSize;\n    g = fragCoord;\n    \n\tfloat timeCoef = 0.5;\n\n    float time = uTime * timeCoef;\n    float cam_a = time; // angle z\n    \n    vec3 camUp=vec3(0,1,0);//Change camere up vector here\n  \tvec3 camView=vec3(0,0,0); //Change camere view here\n  \tfloat prec = 0.00001; // ray marching precision\n    float RMPrec = 0.5; // ray marching tolerance precision\n    \n\tfloat cam_e = 0.; // elevation\n    \n\tfloat gmin = 0.2; // uPad1.x;\n\tfloat gmax = 1.05; // uPad1.y;\n\tfloat gt= (sin(time/4.)*.5+.5)*(gmax-gmin)+gmin;\n\n\tfloat dmin = 2.7; // uPad.x;\n\tfloat dmax = 3.2; // uPad.y;\n\tfloat cam_d = sin(time*4.-2.)*(dmax-dmin)+dmin;\n\n\tvec2 uv = (2. * g -s )/ min(s.y,s.x);\n    \n\tvec3 col = vec3(0.);\n    \n\tvec3 ro = vec3(-sin(cam_a), sin(cam_e), cos(cam_a))*cam_d;\n  \tvec3 rov = normalize(camView-ro);\n\tvec3 u = normalize(cross(camUp,rov));\n  \tvec3 v = cross(rov,u);\n  \tvec3 rd = normalize(rov + uv.x*u + uv.y*v);\n    \n   \tfloat d = 0.,r=0.;\n   \tvec3 p = ro+rd*d;\n   \tfloat s = prec;\n\n\tfloat f = 1.15;// uSlider;\n\n\tfor(int i=0;i<150;i++)\n   {      \n    \tif (s<prec) break;\n\n\t\tdstepf += 0.02;// uSlider1;\n\n\t\tvec3 c = abs(p) - 0.5;\n\t\tc = mod(p, c/f*2.) - c/f;\n\t\tr = mix(length(c), length(p) - 1., -gt);\n\n       d+=s=r*RMPrec;\n       p=ro+rd*d;\n   }\n\n\tcol = mix(col, vec3(0.8,0.9,1.0)/*uColor*/, 1.0-exp( -0.0005*d*d/**uSlider3*/ ) );\n\tcol = mix(col, vec3(0.8,0.2,0.4)/*uColor1*/, 0.5);\n\tcol *= dstepf;\n\t\n\tfragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll2GDV.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[228, 250, 307, 307, 1734]], "test": "valid"}
{"id": "ll2GRt", "name": "Oil stain", "author": "noby", "description": "A little 2D effect I wrote earlier this year based on iq's noise derivatives. A standalone GLSL version only works on nVidia for some reason, I'm probably abusing the derivatives too badly, or maybe the noise has some sort of a quirk I haven't noticed...", "tags": ["2d", "noise", "fbm", "perlin", "blackandwhite", "fluid", "monochrome", "liquid", "noisederivative"], "likes": 64, "viewed": 3078, "published": "Public", "date": "1431523178", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#define INVERT\nmat2 rot2d(float angle){return mat2(cos(angle),-sin(angle),sin(angle),cos(angle));}\nfloat r(float a, float b){return fract(sin(dot(vec2(a,b),vec2(12.9898,78.233)))*43758.5453);}\nfloat h(float a){return fract(sin(dot(a,dot(12.9898,78.233)))*43758.5453);}\n\nfloat noise(vec3 x){\n    vec3 p  = floor(x);\n    vec3 f  = fract(x);\n    f       = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    return mix(mix(mix( h(n+0.0), h(n+1.0),f.x),\n                   mix( h(n+57.0), h(n+58.0),f.x),f.y),\n               mix(mix( h(n+113.0), h(n+114.0),f.x),\n                   mix( h(n+170.0), h(n+171.0),f.x),f.y),f.z);\n}\n\n// http://www.iquilezles.org/www/articles/morenoise/morenoise.htm\n// http://www.pouet.net/topic.php?post=401468\nvec3 dnoise2f(vec2 p){\n    float i = floor(p.x), j = floor(p.y);\n    float u = p.x-i, v = p.y-j;\n    float du = 30.*u*u*(u*(u-2.)+1.);\n    float dv = 30.*v*v*(v*(v-2.)+1.);\n    u=u*u*u*(u*(u*6.-15.)+10.);\n    v=v*v*v*(v*(v*6.-15.)+10.);\n    float a = r(i,     j    );\n    float b = r(i+1.0, j    );\n    float c = r(i,     j+1.0);\n    float d = r(i+1.0, j+1.0);\n    float k0 = a;\n    float k1 = b-a;\n    float k2 = c-a;\n    float k3 = a-b-c+d;\n    return vec3(k0 + k1*u + k2*v + k3*u*v,\n                du*(k1 + k3*v),\n                dv*(k2 + k3*u));\n}\n\nfloat fbm(vec2 uv){               \n    vec2 p = uv;\n\tfloat f, dx, dz, w = 0.5;\n    f = dx = dz = 0.0;\n    for(int i = 0; i < 28; ++i){        \n        vec3 n = dnoise2f(uv);\n        dx += n.y;\n        dz += n.z;\n        f += w * n.x / (1.0 + dx*dx + dz*dz);\n        w *= 0.86;\n        uv *= vec2(1.16);\n        uv *= rot2d(1.25*noise(vec3(p*0.1, 0.12*iTime))+\n                    0.75*noise(vec3(p*0.1, 0.20*iTime)));\n    }\n    return f;\n}\n\nfloat fbmLow(vec2 uv){\n    float f, dx, dz, w = 0.5;\n    f = dx = dz = 0.0;\n    for(int i = 0; i < 4; ++i){        \n        vec3 n = dnoise2f(uv);\n        dx += n.y;\n        dz += n.z;\n        f += w * n.x / (1.0 + dx*dx + dz*dz);\n        w *= 0.75;\n        uv *= vec2(1.5);\n    }\n    return f;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv = 1.0-2.0*(fragCoord.xy / iResolution.xy);\n    uv.y /= iResolution.x/iResolution.y;\n    float t = iTime*0.6;\n    \n    vec2 rv = uv/(length(uv*2.5)*(uv*30.0));\n    uv *= rot2d(0.3*t);\n    float val = 0.5*fbm(uv*2.0*fbmLow(length(uv)+rv-t));\n    uv *= rot2d(-0.6*t);\n    \n    #ifdef INVERT\n    \tfragColor = 1.0-1.2*vec4( vec3(0.5*fbm(uv*val*8.0)+0.02*r(uv.x,uv.y)), 1.0 );\n    #else\n    \tfragColor = 1.6*vec4( vec3(0.5*fbm(uv*val*8.0)+0.02*r(uv.x,uv.y)), 1.0 );\n    #endif\n    \n    fragColor.rgb *= 3.8;\n    fragColor.rgb = fragColor.rgb/(1.0+fragColor.rgb);\n    fragColor.rgb = smoothstep(0.18, 0.88, fragColor.rgb);\n    //fragColor.rgb = pow(fragColor.rgb, vec3(1.0/2.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll2GRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 17, 41, 41, 100], [101, 101, 127, 127, 194], [195, 195, 212, 212, 270], [272, 272, 292, 292, 636], [638, 750, 772, 772, 1302], [1304, 1304, 1323, 1323, 1743], [1745, 1745, 1767, 1767, 2041], [2043, 2043, 2097, 2097, 2781]], "test": "error"}
{"id": "llB3zd", "name": "sand sponge ", "author": "joeedh", "description": "Erosion with noise", "tags": ["sandspongeerosion"], "likes": 1, "viewed": 152, "published": "Public", "date": "1431418983", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//ray march steps\n#define STEPS 100\n\nfloat noise(vec2 xy) {\n    //xy = mod(xy, 1.0);\n    \n    //xy *= 0.2;\n    //xy *= 200.0;\n    if (xy[0] == 0.0) xy[0] += 0.00001;\n    if (xy[1] == 0.0) xy[1] += 0.00001;\n    \n    float t = fract(1.0 / (0.0001 + abs(0.001*sin(xy[0]-123.0*xy[0]*xy[1]))));\n    t = fract(1.0/(0.00001+fract(t + 200.0*xy[0] / (0.000001+abs(20.0*xy[1])))));\n    return abs(t);\n}\n\nvec2 noise2(vec2 xy) {\n    float a = noise(xy), b = noise(vec2(a+xy[1], a-xy[0]));\n    \n\treturn normalize(vec2(a, b))*0.35;\n}\n\nfloat smoothstep2(float a, float b, float t) {\n    float t3=t*t*t, t4=t3*t, t5=t4*t;\n    \n    t = 6.0*t5 - 15.0*t4 + 10.0*t3;\n    return a + (b - a)*t;\n}\nfloat pnoise2(vec2 uv, float sz) {\n    float u = uv[0]/sz, v = uv[1]/sz, fu = floor(u), fv = floor(v);\n    \n    float c1 = noise(vec2(fu, fv)*sz); \n    float c2 = noise(vec2(fu, fv+1.0)*sz); \n    float c3 = noise(vec2(fu+1.0, fv+1.0)*sz); \n    float c4 = noise(vec2(fu+1.0, fv)*sz); \n    \n    u -= fu; v -= fv;\n    \n    u = smoothstep(0.0, 1.0, u);\n    v = smoothstep(0.0, 1.0, v);\n    \n    float r1 = c1 + (c2 - c1)*v;\n    float r2 = c4 + (c3 - c4)*v;\n    \n    float r = r1 + (r2 - r1)*u;\n    \n    return r;\n}\n\nfloat pnoise(vec3 uvz, float sz) {\n    float zu = floor(uvz[2]/sz)*sz;\n    float a = pnoise2(uvz.xy+zu*4.0, sz);\n    float b = pnoise2(uvz.xy+(zu+sz)*4.0, sz);\n    \n    float z = 1.0-fract(abs(uvz[2]/sz));\n    z = smoothstep(0.0, 1.0, z);\n    \n    return a + (b - a)*z;\n}\n\nfloat atan2(float x, float y) {\n    if (x > 0.0) {\n        return atan(y / x);\n    } else if (y >= 0.0 && x < 0.0) {\n        return atan(y/x) + 3.14159;\n    } else if (y < 0.0 && x < 0.0) {\n        return atan(y/x) - 3.14159;\n    } else if (y > 0.0 && x == 0.0) {\n        return 3.14159*0.5;\n    } else if (y < 0.0 && x == 0.0) {\n        return -3.14159*0.5;\n    } else {\n    \treturn 0.0;\n    }\n}\n\nfloat atan2(vec2 xy) {\n    return atan2(xy[1], xy[0]);\n}\n\nfloat manlen(vec2 vec) {\n    vec = abs(vec);\n    return vec[1]+vec[0];\n}\n\n//float noise(vec3 pos) {\n//    return fract(1.0/sin(length(pos)*3.5+pos[0]*pos[1]*1.0)*0.5+0.5)*0.5+0.5;\n//}\n\nfloat func1(float p, float s, float m) {\n    //m = 9.0;\n    m = floor(m);\n    \n    float r1 = float(mod(floor(p*s*m - m*0.5), m) != 0.0); \n    \n    return r1;\n}\nfloat funca(float p, float s, float m) {\n    float r1 = func1(p, s, 4.0);\n\n    return r1;\n}\nfloat funcb(float p, float s, float m) {\n    float r2 = func1(p+0.5, s, 3.0);\n\n    return r2;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n/*\non factor;\noff period;\n\nprocedure length(px, py, pz);\n\tsqrt(px*px + py*py + pz*pz);\n\nprocedure sdBox(px, py, pz, bx, by, bz);\n\tmin(max(abs(px)-bx, max(abs(py)-by, abs(pz)-bz)), 0)\n    + length(max(abs(px)-bx, 0), max(abs(py)-by, 0),\n             max(abs(pz)-bz, 0));\nsdbox(px + rx*s, py + ry*s, pz + rz*s, w, w, w);\n\n*/\n\n\nfloat box(vec3 pos, float w) {\n   return -sdBox(pos, vec3(w,w,w));\n}\n\nfloat crossb(vec3 pos, float w) {\n    float b1 = box(vec3(pos[0], pos[1], 0.0), w);\n    float b2 = box(vec3(pos[0], 0.0, pos[2]), w);\n    float b3 = box(vec3(0.0, pos[1], pos[2]), w);\n    \n    return max(max(b1, b2), b3);\n}\n\nfloat sponge(vec3 pos, float w) {\n    float c1 = crossb(pos, w);\n    float c2 = box(pos, w*3.0);\n    \n    return min(-c1, c2);\n}\n\nfloat density(vec3 pos, float sz) {\n    \n    float w = 0.15;\n    \n    //pos += pnoise(pos, 0.3)*0.1-0.1;\n    vec3 opos = pos;\n    float x = pos[0], y = pos[1], z = pos[2];\n    float t1 = abs(fract(0.8+iTime*0.1)-0.5)*2.0*1.15 + 0.15;\n    \n    float c = sponge(pos, w);\n    float sz1 = (t1)*1.5; //(t1*0.5+0.5)*2.0;\n    float p = (1.0-pnoise(pos*sz1, 0.3))-0.4*t1*2.0;\n    \n    c = min(c, p);\n    for (int i=0; i<3; i++) {\n\t    pos *= 3.0;\n    \tfloat c2 = sponge(mod(pos + w*0.5, w*3.0), w);\n        c = min(c, c2);\n    }\n    return c;\n    \n}\n\nvec3 sample1(vec3 p, vec3 d) {\n    float t=0.0, ret=0.0, dt, dt1=1.0/float(STEPS), dt2=dt1*1.0;\n    float sum = 0.0, r=0.0;\n    float first = 1.0, df=0.0;\n    float fac, lastdf, lastr=density(p - d*dt1, 1.0);\n    \n    dt = dt1;\n    \n    for (int i=0; i<STEPS; i++) {\n        r = density(p + d*t, 1.0);\n\t\t     \n        if (abs(r) < 0.00001) {\n           \tsum = 1.0;\n            break;\n        }\n        \n        //df = (r-lastr)/dt;\n        \n        float r2 = density(p + d*(t+0.001), 1.0);\n        lastdf = df;\n        df = (abs(r2)-abs(r))/0.001 + 0.000;\n      \n        ///*\n        fac = (-abs(r)/df);\n        \n        dt = -r*23.0*dt1; //(r+lastr)*0.5;\n        \n            \n        lastr = r;\n        t += dt;\n        if (t < 0.0) t = 0.0;\n    }\n    \n    float t2 = t - 0.1;\n    vec3 pos = p + d*t;\n    \n#define DF1 0.0001\n    \n    float r2 = density(vec3(pos[0]+DF1, pos[1], pos[2]), 1.0);\n    float r3 = density(vec3(pos[0], pos[1]+DF1, pos[2]), 1.0);\n    float r4 = density(vec3(pos[0], pos[1], pos[2]+DF1), 1.0);\n   // float r6 = density(p + d*(t+0.005), 1.0);\n    \n    vec3 norm = vec3(r2, r3, r4)/DF1;\n    \n    //df = (abs(r2)-abs(r))/0.001 + 0.000;\n    norm = normalize(norm);\n    norm *= -0.1;\n    float r5 = density(pos+norm, 1.0);\n    \n    //abs(abs(df-df)\n    //float ao = (abs(r6)*0.5 + abs(r)*0.5)/0.005;\n    //ao = (0.5*abs(df)+(1.0-ao*0.9))*0.9;\n    float ao2 = 1.0-t;\n    ao2 = 1.0-r5*1.0;\n    ao2 = pow(min(ao2*0.96, 1.0), 50.0);\n    ao2 = ao2*(1.0-t*t*t*0.4)*1.4;\n    return vec3(ao2, t, dt);\n}\n\nvec3 getray(vec2 uv) {\n    return normalize(vec3(uv, -1.0));\n}\n\nvec2 rot2d(vec2 v, float th) {\n    return vec2(sin(th)*v[1] + cos(th)*v[0], sin(th)*v[0] - cos(th)*v[1]);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 uv = vec3((fragCoord.xy-iResolution.xy*0.5) / iResolution.x, 0.0);\n    float th1 = iTime*0.9;\n    float rr = 1.0;\n    vec3 origin = vec3(cos(th1)*rr, sin(th1)*rr, 0.0);\n    vec3 target = vec3(0.0, 0.0, 0.0);\n    \n    //uv *= 2.0;\n\tvec3 up = normalize(cross(origin-target, vec3(0.0, 0.0, 1.0)));\n    vec3 cr = normalize(cross(up, origin-target));\n    vec3 zc = normalize(origin-target);\n    \n    vec3 ray = origin + up*uv[0] + cr*uv[1];\n    ray = normalize(ray - (origin+zc*0.5)) ;// - origin);\n    float c1=0.0;\n    //vec3 ray = -normalize((origin + uv) - target);\n    float c = 0.0, totw = 0.0, ts=0.0, mint=100.0, maxt=-100.0, thet;\n    \n    #define DF 0.000001\n\n    vec3 isect = sample1(origin, ray);\n    float ft = isect[1];\n    vec3 pos = origin + ray*isect[1];\n    float r0 = density(pos, 1.0);\n    float r1 = (density(pos+vec3(DF, 0.0, 0.0), 1.0)-r0)/DF;\n    float r2 = (density(pos+vec3(0.0, DF, 0.0), 1.0)-r0)/DF;\n    float r3 = (density(pos+vec3(0.0, 0.0, DF), 1.0)-r0)/DF;\n\n    vec3 norm = normalize(vec3(r1, r2, r3));\n\n    float spec = dot(normalize((norm+ray)), normalize(vec3(0, -1, 0)));\n    spec = max(spec, 0.0);\n    spec = pow(spec*1.0, 60.0);\n    float diffa = max(dot(norm, normalize(vec3(10.0, 0.5, 2.0))), 0.0);\n    float diffb = max(dot(norm, normalize(vec3(-20.0, 0.5, 2.0))), 0.0)*0.2;\n\n    //abs((0.2+0.6*spec+diffa*0.5+diffb))\n    float light = abs((spec*0.0+diffa*0.5+diffb))*1.0;\n    light = min(max(light, 0.0), 1.0);\n\n    c = isect[0] != 0.0 ? isect[0]*0.2 + 3.0*isect[0]*0.5*min(max(light, 0.0), 1.0) : 0.0;\n\n\tfragColor = vec4(c*1.5, c*1.32, c*0.9, 1.0);\n    fragColor = fragColor*0.6+0.2;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llB3zd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 37, 59, 125, 392], [394, 394, 416, 416, 519], [521, 521, 567, 567, 674], [675, 675, 709, 709, 1185], [1187, 1187, 1221, 1221, 1458], [1460, 1460, 1491, 1491, 1856], [1858, 1858, 1880, 1880, 1914], [1916, 1916, 1940, 1940, 1988], [1990, 2101, 2141, 2156, 2261], [2262, 2262, 2302, 2302, 2353], [2354, 2354, 2394, 2394, 2449], [2451, 2451, 2482, 2482, 2569], [2571, 2896, 2926, 2926, 2964], [2966, 2966, 2999, 2999, 3189], [3191, 3191, 3224, 3224, 3319], [3321, 3321, 3356, 3356, 3862], [3864, 3864, 3894, 3894, 5381], [5383, 5383, 5405, 5405, 5445], [5447, 5447, 5477, 5477, 5554], [5555, 5555, 5612, 5612, 7242]], "test": "valid"}
{"id": "llBGRd", "name": "EvilSeed", "author": "dila", "description": "I discovered this rust effect and had to put it to good use.", "tags": ["escape", "blades", "rust"], "likes": 22, "viewed": 522, "published": "Public", "date": "1431375913", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = 3.14159;\n\nmat3 xrot(float t)\n{\n    return mat3(1.0, 0.0, 0.0,\n                0.0, cos(t), -sin(t),\n                0.0, sin(t), cos(t));\n}\n\nmat3 yrot(float t)\n{\n    return mat3(cos(t), 0.0, -sin(t),\n                0.0, 1.0, 0.0,\n                sin(t), 0.0, cos(t));\n}\n\nmat3 zrot(float t)\n{\n    return mat3(cos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0);\n}\n\nfloat btime = 1.0;\nfloat bspeed = 10.0;\n\nfloat map(vec3 pos)\n{\n    float dir = 1.0;\n    vec3 id = floor(pos);\n    pos.y += sin(iTime+id.x*10.0+id.z*10.0);\n    pos = fract(pos) * 2.0 - 1.0;\n    pos *= yrot(iTime*btime*4.0*dir);\n    float s = length(pos.xz);\n    float k = atan(pos.z, pos.x);\n    float mr = 0.9;\n    float r = mix(0.8, 1.0, 0.5 + 0.5 * sin(s/mr*dir*bspeed+k*10.0));\n    float p = mr * r;\n    float e = 1.0 - s/p;\n    vec3 c = vec3(pos.x, clamp(pos.y,-0.02*e, 0.02*e), pos.z);\n\treturn min(max(length(c-pos), s-p), s-0.1);\n}\n\nvec3 normal(vec3 p)\n{\n    vec3 o = vec3(0.01, 0.0, 0.0);\n    return normalize(vec3(map(p+o.xyy) - map(p-o.xyy),\n                          map(p+o.yxy) - map(p-o.yxy),\n                          map(p+o.yyx) - map(p-o.yyx)));\n}\n\nfloat trace(vec3 o, vec3 r)\n{\n \tfloat t = 0.0;\n    for (int i = 0; i < 16; ++i) {\n     \tvec3 p = o + r * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    return t;\n}\n\nfloat pshade(vec3 p)\n{\n    vec3 id = floor(p);\n    p.y += sin(iTime+id.x*10.0+id.z*10.0);\n    p = fract(p) * 2.0 - 1.0;\n    p *= yrot(iTime*btime*4.0+length(p.xz)*4.0);\n    p += id;\n\tfloat ac = texture(iChannel0, vec2(p.y,p.z)).x;\n    float bc = texture(iChannel0, vec2(p.x,p.z)).x;\n    float cc = texture(iChannel0, vec2(p.x,p.y)).x;\n    float s = ((ac + bc + cc) / 3.0) * 2.0 - 1.0;\n    return s;\n}\n\nvec4 surf(vec3 r, vec3 w, vec3 sn, float t)\n{\n    float prod = max(dot(sn,-r), 0.0);\n    float off = 0.5 + 0.5 * sin(pshade(w)*pi*5.0);\n    float ao = map(w) * 20.0;\n    float fog = prod / (1.0 + t * t + off + ao);\n    return vec4(vec3(fog),off);\n}\n\nvec3 shade(vec3 r, float time)\n{\n    r *= xrot(iTime) * zrot(time);\n    \n    vec3 o = vec3(0.0, 0.0, 0.0);\n    o.z += time;\n    \n    float t = trace(o, r);\n    vec3 w = o + r * t;\n    vec3 sn = normal(w);\n    \n    vec4 ac = surf(r, w, sn, t);\n    \n    vec3 from = vec3(0.8, 0.2, 0.1);\n    vec3 to = vec3(1.0, 1.0, 1.0);\n    \n    float fx = 1.0 - ac.w;\n    \n    vec3 mixed = ac.xyz * mix(from, to, fx);\n    \n    return mixed;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 r = normalize(vec3(uv, 1.0 - dot(uv,uv) * 0.33));\n\n    btime = 2.0;\n    bspeed = 10.0;\n    vec3 sa = shade(r, iTime);\n    \n    float of = 0.01;\n    \n    btime = 4.0;\n    bspeed = 20.0;\n    vec3 sb = shade(r, iTime+of);\n\n    btime = 6.0;\n    bspeed = 20.0;\n    vec3 sc = shade(r, iTime+of*2.0);\n    \n    vec3 f = sa * 0.2 + sb * 0.5 + sc * 0.3;\n    \n\tfragColor = vec4(f,1.0);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llBGRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 47, 47, 156], [158, 158, 178, 178, 287], [289, 289, 309, 309, 418], [461, 461, 482, 482, 957], [959, 959, 980, 980, 1184], [1186, 1186, 1215, 1215, 1363], [1365, 1365, 1387, 1387, 1765], [1767, 1767, 1812, 1812, 2015], [2017, 2017, 2049, 2049, 2443], [2445, 2445, 2502, 2502, 3003]], "test": "error"}
{"id": "llj3Dm", "name": "Full_", "author": "shezard", "description": "Some nightish scene", "tags": ["fullmoon"], "likes": 6, "viewed": 246, "published": "Public", "date": "1430826803", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(in vec2 uv){\n    return fract(sin(dot(uv.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise1d(in float p) {\n  \tfloat fl = floor(p);\n    float fc = fract(p);\n    \n  \treturn mix(rand(vec2(fl,fl)),rand(vec2(fl,fl)+1.0),fc);   \n}\n\nfloat noise(in vec2 uv) {\n\treturn sin(1.5*uv.x)*sin(1.5*uv.y);\n}\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat fbm1d(in float p) {\n        float f = 0.0;\n    f += 0.5000*noise1d(p); p = p*2.02;\n    f += 0.2500*noise1d(p); p = p*2.03;\n    f += 0.1250*noise1d(p); p = p*2.01;\n    f += 0.0625*noise1d(p);\n    return f/0.9375;\n}\n\nfloat fbm(vec2 uv) {\n    float f = 0.0;\n    f += 0.5000*noise(uv+iTime*.1); uv = m*uv*2.02;\n    f += 0.2500*noise(uv+iTime*.1); uv = m*uv*2.03;\n    f += 0.1250*noise(uv+iTime*.1); uv = m*uv*2.01;\n    f += 0.0625*noise(uv+iTime*.1);\n    return f/0.9375;\n}\n\nfloat fbm2(in vec2 uv) {\n   vec2 p = vec2(fbm(uv + vec2(0.0,0.0)),\n                 fbm(uv + vec2(5.2,1.3)));\n\n   return fbm(uv + 4.0*p);\n}\n\nfloat r = 0.0;\n\nvec3 mountain(in vec2 p, in vec2 offset) {\n     \n    float c = 0.0;\n    if(-p.y > fbm1d(p.x)) {\n        \n       float mountain = (1.0 - (ceil(-p.y) * -p.y)) * length(p-offset) * .125;\n    \n       c = max(c,mountain);\n    }\n    \n    return c * (.95 + .05 * texture(iChannel0,p*.5).rgb);\n}\n\nvec3 scene( in vec2 p) {\n    \n    vec2 offset = vec2(1.3,-.6);\n    \n    vec3 c = vec3(.9) * length(p+offset) + fbm2(p*20.0+20.0)*.0025; \n    \n    \t c = clamp(c,.0,.2) / length(p+offset) - fbm2(p+vec2(iTime*.01,0))*.025;\n\n    float stars = (1.0 - clamp(0.0, 0.025, r*10.0) * 40.0) * .4 * (p.y * 3.0 + 1.0) * (.25 + fbm2(p*200.0)) * ceil(p.y);\n    \n    c = max(c, stars);\n    \n    c = max(c,mountain(p, offset));\n    \n    c = max(c,mountain(p+vec2(-0.4,0.1), offset+vec2(-0.4,0.1)));\n    \n    c = max(c,mountain(p+vec2(-0.55,0.2), offset+vec2(-0.55,0.2)));\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 p = -1.0 + 2.0 * uv;\n    \t p.x *= iResolution.x/iResolution.y;\n\n    \t r = rand(uv);\n    \n    vec3 c = scene(p);\n    \n\tfragColor = vec4(c,1.0);\n}", "image_inputs": [{"id": "XsXGRn", "previewfilepath": "/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llj3Dm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 95], [97, 97, 124, 124, 242], [244, 244, 269, 269, 308], [361, 361, 386, 386, 580], [582, 582, 602, 602, 836], [838, 838, 862, 862, 977], [995, 995, 1037, 1037, 1282], [1284, 1284, 1308, 1308, 1859], [1861, 1861, 1918, 1918, 2119]], "test": "error"}
{"id": "llj3zV", "name": "Gas Giant!", "author": "HamzaHutchinson", "description": "Trying to make a nice looking space scene. Inspiration, code and learning drawn from a number of different shaders. Thanks to iq, Antonalog and mu6k.", "tags": ["space", "planet", "stars", "gasgiant"], "likes": 140, "viewed": 19291, "published": "Public API", "date": "1430612911", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Reference shaders below\n// RAYMARCHED BALL (iq):  https://www.shadertoy.com/view/ldfSWs\n// NOISE (iq): https://www.shadertoy.com/view/4sfGzS#\n// CUBEMAP (iq): https://www.shadertoy.com/view/ltl3D8\n// SWIRLY STUFF (Antonalog): https://www.shadertoy.com/view/4s23WK\n// STAR/FLARE (mu6k): https://www.shadertoy.com/view/4sX3Rs\n// RAY V SPHERE (reinder): https://www.shadertoy.com/view/4tjGRh\n\nconst int star_iterations = 10;\nconst float distort_iterations = 5.0;\nconst float tex_scale = 0.025;\nconst float time_scale = 0.2;\nconst vec3 col_star = vec3( 1.0, 0.7, 0.5 );\nconst vec3 pos_star = vec3( 0.0, 9.0, 30.0 );\nconst vec3 world_up = vec3( 0.0, 1.0, 0.0 );\n\nstruct CameraInfo\n{\n    vec3 pos;\n    vec3 dir;\n    mat3 m;\n    mat3 mInv;\n};\n\nfloat hash( float n ) { return fract(sin(n)*123.456789); }\n\nvec2 rotate( in vec2 uv, float a)\n{\n    float c = cos( a );\n    float s = sin( a );\n    return vec2( c * uv.x - s * uv.y, s * uv.x + c * uv.y );\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 fl = floor( p );\n    vec3 fr = fract( p );\n    fr = fr * fr * ( 3.0 - 2.0 * fr );\n\n    float n = fl.x + fl.y * 157.0 + 113.0 * fl.z;\n    return mix( mix( mix( hash( n +   0.0), hash( n +   1.0 ), fr.x ),\n                     mix( hash( n + 157.0), hash( n + 158.0 ), fr.x ), fr.y ),\n                mix( mix( hash( n + 113.0), hash( n + 114.0 ), fr.x ),\n                     mix( hash( n + 270.0), hash( n + 271.0 ), fr.x ), fr.y ), fr.z );\n}\n\nfloat fbm( in vec2 p, float t )\n{\n    float f;\n    f  = 0.5000 * noise( vec3( p, t ) ); p *= 2.1;\n    f += 0.2500 * noise( vec3( p, t ) ); p *= 2.2;\n    f += 0.1250 * noise( vec3( p, t ) ); p *= 2.3;\n    f += 0.0625 * noise( vec3( p, t ) );\n    return f;\n}\n\nvec2 field(vec2 p)\n{\n    float t = time_scale * iTime;\n\n    p.x += t;\n\n    float n = fbm( p, t );\n\n    float e = 0.25;\n    float nx = fbm( p + vec2( e, 0.0 ), t );\n    float ny = fbm( p + vec2( 0.0, e ), t );\n\n    return vec2( n - ny, nx - n ) / e;\n}\n\nvec3 distort( in vec2 p )\n{\n    for( float i = 0.0; i < distort_iterations; ++i )\n    {\n        p += field( p ) / distort_iterations;\n    }\n    vec3 s = 2.5 * texture( iChannel0, vec2( 0.0, p.y * tex_scale ) ).xyz;\n\n    return fbm( p, 0.0 ) * s;\n}\n\nvec2 map( in vec2 uv )\n{\n    uv.x *= 5.0;\n    uv.x += 0.01 * iTime;\n    uv.y *= 15.0;\n    return uv;\n}\n\nvec3 doBackgroundStars( in vec3 dir )\n{\n    vec3 n  = abs( dir );\n    vec2 uv = ( n.x > n.y && n.x > n.z ) ? dir.yz / dir.x: \n              ( n.y > n.x && n.y > n.z ) ? dir.zx / dir.y:\n                                           dir.xy / dir.z;\n    \n    float f = 0.0;\n    \n    for( int i = 0 ; i < star_iterations; ++i )\n    {\n        uv = rotate( 1.07 * uv + vec2( 0.7 ), 0.5 );\n        \n        float t = 10. * uv.x * uv.y + iTime;\n        vec2 u = cos( 100. * uv ) * fbm( 10. * uv, 0.0 );\n        f += smoothstep( 0.5, 0.55, u.x * u.y ) * ( 0.25 * sin( t ) + 0.75 );\n    }\n    \n    return f * col_star;\n}\n\nvec3 doMainStar( in vec2 uv, in vec2 sp)\n{\n    float t = atan( uv.x - sp.x, uv.y - sp.y );\n    float n = 2.0 + noise( vec3( 10.0 * t, iTime, 0.0 ) );\n    float d = length( uv - sp ) * 25.0;\n    return ( ( 1.0 + n ) / ( d * d * d ) ) * col_star;\n}\n\nfloat doCastSphere( in vec3 p, in vec3 rd )\n{\n    float b = dot( p, rd );\n    float c = dot( p, p ) - 1.0;\n    \n    float f = b * b - c;\n    if( f >= 0.0 )\n    {\n        return -b - sqrt( f );\n    }\n    return -1.0;\n}\n\nvec3 doMaterial( in vec3 pos )\n{\n    vec2 uv;\n    uv.x = atan( pos.x, pos.z );\n    uv.y = asin( pos.y );\n    return distort( map( uv ) );\n}\n\nvec3 doLighting( in vec3 n, in vec3 c, in vec3 rd, in vec3 rdc )\n{\n    vec3  l   = normalize( pos_star + 2.0 * ( pos_star - dot( pos_star, rdc ) * rdc ) );\n    float ndl = dot( n, l );\n    float ndr = dot( n, -rd );\n    float ldr = dot( l, rd );\n    float f   = max( ndl, 0.0 ) + 0.002;\n    float g   = ldr * smoothstep( 0.0, 0.1, ndr ) * pow( 1.0 - ndr, 10.0 );\n    return clamp( f * c + g * col_star, 0.0, 1.0 );\n}\n\nfloat doFlare( in vec2 uv, in vec2 dir, float s )\n{\n    float d = length( uv - dot( uv, dir ) * dir );\n    float f = 0.0;\n    f += max( pow( 1.0 - d, 128.0 ) * ( 1.0   * s - length( uv ) ), 0.0 );\n    f += max( pow( 1.0 - d,  64.0 ) * ( 0.5   * s - length( uv ) ), 0.0 );\n    f += max( pow( 1.0 - d,  32.0 ) * ( 0.25  * s - length( uv ) ), 0.0 );\n    f += max( pow( 1.0 - d,  16.0 ) * ( 0.125 * s - length( uv ) ), 0.0 );\n    return f;\n}\n\nfloat doLensGlint( in vec2 uv, in vec2 c, float r, float w )\n{\n    float l = length( uv - c );\n    return length( c ) * smoothstep( 0.0, w * r, l ) * ( 1.0 - smoothstep( w * r, r, l ) );\n}\n\nvec3 render( in vec2 uv, in CameraInfo ci )\n{\n    // create view ray\n    vec3 rd  = ci.m * normalize( vec3( uv, 1.0 ) );\n    vec3 rdc = ci.m * vec3( 0.0, 0.0, 1.0 );\n    \n    // background stars\n    vec3 c = doBackgroundStars( rd );\n    \n    // main star\n    vec3 cp = ci.mInv * (pos_star - ci.pos);\n    vec2 sp = cp.xy / cp.z;\n    if( cp.z > 0. )\n    {\n        c += doMainStar( uv, sp );\n    }\n    \n    // planet\n    float t = doCastSphere( ci.pos, rd );\n    if( t > 0.0 )\n    {\n        vec3 pos = ci.pos + t * rd;\n        vec3 nor = normalize( pos );\n        c = doMaterial( pos );\n        c = doLighting( nor, c, rd, rdc );\n    }\n    \n    // lens flare\n    if( cp.z > 0.0 && sp.x > -1.0 && sp.x < 1.0 )\n    {\n        float oc = smoothstep( 0.35, 0.4, length( sp ) );\n        float f = 0.0;\n        f += doFlare( uv - sp, vec2( 1.,0. ), oc );\n        f += oc * 0.05 * doLensGlint( uv, -0.4 * sp, 0.2, 0.92 );\n        f += oc * 0.09 * doLensGlint( uv, -0.8 * sp, 0.3, 0.95 );\n        f += oc * 0.04 * doLensGlint( uv, -1.1 * sp, 0.06, 0.8 );\n        c += f * col_star;\n    }\n    \n    return c;\n}\n\nCameraInfo doCamera( in vec3 pos, in vec3 dir )\n{\n    CameraInfo ci;\n    \n    vec3 ww = dir;\n    vec3 uu = normalize( cross( ww, world_up ) );\n    vec3 vv = normalize( cross( uu, ww ) );\n    mat3 m = mat3( uu, vv, ww );\n    mat3 mInv = mat3( uu.x, vv.x, ww.x,\n                      uu.y, vv.y, ww.y,\n                      uu.z, vv.z, ww.z );\n    \n    ci.pos = pos;\n    ci.dir = dir;\n    ci.m = m;\n    ci.mInv = mInv;\n    \n    return ci;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = gl_FragCoord.xy / iResolution.xy - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    // camera default movement\n    float cx = cos( 0.1 * iTime + 3.55 );\n    float sx = sin( 0.1 * iTime + 3.55 );\n    float cy = 0.;\n    \n    // camera mouse movement\n    if( iMouse.z > 0. )\n    {\n        cx = cos( 10. * m.x );\n        sx = sin( 10. * m.x );\n        cy = cos( 3.2 * m.y );\n    }\n    \n    // camera position/direction\n    vec3 camPos = 2. * vec3( cx - sx, cy, sx + cx );\n    vec3 camDir = normalize( -camPos );\n\n    // render scene\n    vec3 c = render( uv, doCamera( camPos, camDir ) );\n    //vec3 c = vec3( distort( map( uv ) ) );\n    //vec3 c = vec3( fbm( map( uv ), iTime ) );\n    \n    // gamma correction\n    c = pow( c, vec3( 0.4545 ) );\n    \n    fragColor = vec4( c, 1.0 );\n}\n", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llj3zV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 740, 763, 763, 798], [800, 800, 835, 835, 946], [948, 948, 974, 974, 1426], [1428, 1428, 1461, 1461, 1684], [1686, 1686, 1706, 1706, 1936], [1938, 1938, 1965, 1965, 2185], [2187, 2187, 2211, 2211, 2289], [2291, 2291, 2330, 2330, 2898], [2900, 2900, 2942, 2942, 3146], [3148, 3148, 3193, 3193, 3365], [3367, 3367, 3399, 3399, 3506], [3508, 3508, 3574, 3574, 3924], [3926, 3926, 3977, 3977, 4363], [4365, 4365, 4427, 4427, 4553], [4555, 4555, 4600, 4623, 5651], [5653, 5653, 5702, 5702, 6091], [6093, 6093, 6149, 6149, 6996]], "test": "error"}
{"id": "lljGRd", "name": "Illusory Blocks", "author": "NBickford", "description": "Based on http://www.ritsumei.ac.jp/~akitaoka/ !\n", "tags": ["2d", "opticalillusion", "antialiased"], "likes": 3, "viewed": 1168, "published": "Public API", "date": "1431568787", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ss 4\n#define pi 3.1415926535897\n#define rotation 1.\n\nfloat roundf(float v, float d){\n    return ceil(v/d-0.5)*d;\n}\n\nvec2 roundf(vec2 uv, float d){\n    return ceil(uv/d-0.5)*d;\n}\n\n\nfloat checkerboard(vec2 uv){\n    vec2 p=mod(uv-vec2(0.25,0.25),1.0);\n    return mod(step(p.x,0.5)+step(p.y,0.5),2.0);\n}\n\nvec2 rot(vec2 uv, float r){\n    float cr=cos(r),sr=sin(r);\n    return vec2(cr*uv.x-sr*uv.y,sr*uv.x+cr*uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float tv=0.0;\n    float t=iTime*0.5;\n    \n    for(int xp=0;xp<ss;xp++){\n        for(int yp=0;yp<ss;yp++){\n\tvec2 uv = 2.0*(fragCoord.xy-iResolution.xy*0.5+vec2(xp,yp)/float(ss))/iResolution.x;\n            uv*=1.0;//+0.01*cos(pi*t)*pow(length(uv),2.0); Yes, it's just an optical illusion - no barrel distortion.\n            float rad=pow(2.0,t*0.1-2.9);\n    uv*=4.0*rad;//clamp(pow(2.0,iTime*0.1),1.0,2.0);\n    //smoothstep(4.0,10.0,t)\n    //uv=rot(uv,0.01*rotation*sin(pi*t));\n    \n    \n   // uv.x=uv.x-round(uv.y-0.25,0.5)*t;\n\tfloat v=checkerboard(uv);\n            \n            //get activeness of inversion\n            vec2 squarepos=roundf(uv,0.5);\n            float isactive=smoothstep(2.3*(rad+0.1),2.3*(rad-0.1),length(squarepos));\n            \n            //Possible inversion\n            uv=mod(abs(uv),0.5)/0.5;\n            float d=0.07;\n            float w=0.25;\n            \n            float v1=v;\n            if(uv.x>0.5+d && uv.x<0.5+d+w && uv.y>0.25-d && uv.y<0.25-d+w) v1=1.-v1;\n            if(uv.x>0.25-d && uv.x<0.25-d+w && uv.y>0.5+d && uv.y<0.5+d+w) v1=1.-v1;\n            \n            float v2=v;\n            if(uv.x>0.5+d && uv.x<0.5+d+w && uv.y>0.5+d && uv.y<0.5+d+w) v2=1.-v2;\n            if(uv.x>0.25-d && uv.x<0.25-d+w && uv.y>0.25-d && uv.y<0.25-d+w) v2=1.-v2;\n            \n            float blend=0.5+0.5*cos(pi*t+squarepos.y*0.2);\n            \n            v=mix(v,mix(v2,v1,blend),isactive);\n            //v=isactive;\n            //v=v2;\n            \n    \n    /*if(abs(round(uv.y,0.5)-uv.y)<0.01) v=0.5;*/\n            tv+=v;\n        }\n    }\n    \n    tv=tv/float(ss*ss);\n    fragColor=vec4(tv,tv,tv,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lljGRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 92, 92, 122], [124, 124, 154, 154, 185], [188, 188, 216, 216, 307], [309, 309, 336, 336, 419], [421, 421, 478, 478, 2115]], "test": "valid"}
{"id": "lljGz3", "name": "Tetrahedral Sierpinski", "author": "avi", "description": "This is a tetrahedral sierpinski gasket. I'm using it to practice with IFS fractals in order to make a better Manhattan surface fractal render.", "tags": ["3d", "ifs", "sierpinski"], "likes": 4, "viewed": 582, "published": "Public", "date": "1431073781", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Modified by Avi Levy (c) 2015\n *\n * This is the famous Sierpinski\n * tetrahedron, to 16 iterations.\n *\n * Instructions:\n *      Click and drag the fractal\n *          - Upwards zooms in\n *          - Left/right rotates\n *\n * \n * Original by inigo quilez - iq/2013\n */\n\nconst vec3 va = vec3(  0.0,  0.57735,  0.0 );\nconst vec3 vb = vec3(  0.0, -1.0,  1.15470 );\nconst vec3 vc = vec3(  1.0, -1.0, -0.57735 );\nconst vec3 vd = vec3( -1.0, -1.0, -0.57735 );\n\n// return distance and address\nvec2 map(vec3 p) {\n    float a = 0.0;\n    float s = 1.0;\n    float r = 1.0;\n    float dm;\n    vec3 v;\n    for(int i=0; i<16; i++) {\n        float d, t;\n        d = dot(p-va,p-va);              v=va; dm=d; t=0.0;\n        d = dot(p-vb,p-vb); if( d<dm ) { v=vb; dm=d; t=1.0; }\n        d = dot(p-vc,p-vc); if( d<dm ) { v=vc; dm=d; t=2.0; }\n        d = dot(p-vd,p-vd); if( d<dm ) { v=vd; dm=d; t=3.0; }\n        p = v + 2.0*(p - v); r*= 2.0;\n        a = t + 4.0*a; s*= 4.0;\n    }\n    \n    return vec2( (sqrt(dm)-1.0)/r, a/s );\n}\n\nconst float precis = 0.000001;\n\nvec3 intersect(in vec3 ro, in vec3 rd) {\n    vec3 res = vec3(1e20, 0.0, 0.0);\n    \n    float maxd = 5.0;\n\n    // sierpinski\n    float h = 1.0;\n    float t = 0.5;\n    float m = 0.0;\n    vec2 r;\n    for(int i=0; i<100; i++) {\n        r = map( ro+rd*t );\n        if( r.x<precis || t>maxd ) break;\n        m = r.y;\n        t += r.x;\n    }\n\n    if(t < maxd && r.x < precis) {\n        res = vec3(t, 2., m);\n    }\n\n    return res;\n}\n\nvec3 light = normalize(vec3(1., .7, .9));\n\nvec4 render(in vec3 ro, in vec3 rd) {\n    // raymarch\n    vec3 tm = intersect(ro,rd);\n    if(tm.y < 0.5) {\n        return vec4(0., 0., 0., 1.);\n    }\n    // Position vector\n    vec3 position = ro + tm.x * rd;\n    \n    // Normal vector calculation\n    vec3 epsilon = vec3(precis, 0., 0.);\n    vec3 normal = normalize(\n        vec3(\n            map(position + epsilon.xyy).x - map(position - epsilon.xyy).x,\n            map(position + epsilon.yxy).x - map(position - epsilon.yxy).x,\n            map(position + epsilon.yyx).x - map(position - epsilon.yyx).x\n        )\n    );\n\n    // Occlusion calculation\n    float ao = 0.;\n    float sca = 1.;\n    for(int i=0; i<8; i++) {\n        float h = 0.001 + 0.5*pow(float(i)/7.0,1.5);\n        float d = map(position + h * normal).x;\n        ao += -(d-h)*sca;\n        sca *= 0.95;\n    }\n\n    // surface-light interacion\n    vec3 color = (\n        .5 + .5 * cos(\n            6.2831 * tm.z + vec3(0., 1., 2.)\n        )\n    )\n    * (0.5 + 0.5 * normal.y) // ambient lighting\n    * clamp(1.0 - 0.8*ao, 0.0, 1.0) // occlusion\n    * 1.5 * vec3(1);\n\n    return vec4(\n        pow(clamp(color, 0., 1.), vec3(.45)) // gamma\n    , 1.);\n}\n\nvoid mainImage(out vec4 color, in vec2 fragCoord) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.5);\n    if(iMouse.z>0.0) {\n        m = iMouse.xy/iResolution.xy/10.;\n        m.y = pow(2., 150. * m.y - 3.);\n    }\n\n    // camera\n    float an = 3.2 + 0.5*iTime - 6.2831*(m.x-0.5);\n\n    vec3 ro = vec3(2.5*sin(an),0.0,2.5*cos(an));\n    vec3 ta = vec3(0.0,-0.5,0.0);\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 5.0*ww*m.y );\n\n    color = render(ro, rd);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lljGz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[457, 488, 506, 506, 1010], [1044, 1044, 1084, 1084, 1469], [1514, 1514, 1551, 1567, 2677], [2679, 2679, 2730, 2730, 3349]], "test": "valid"}
{"id": "lljGzV", "name": "Raster bars (Anastadunbar)", "author": "anastadunbar", "description": "Trying to make raster bars.", "tags": ["2d", "noob"], "likes": 0, "viewed": 150, "published": "Public", "date": "1430597715", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926536897932\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat dsin(float val)\n{\n    return sin(radians(val));\n}\n\nfloat clamps(float val)\n{\n    return clamp(val,0.,1.);\n}\n\nfloat randfade(vec2 co, float time){\n    float a = fract(sin(dot(co.xy+1. ,vec2(12.9898,78.233))) * 43758.5453);\n    float b = fract(sin(dot(co.xy+2. ,vec2(12.9898,78.233))) * 43758.5453); \n    float c = fract(sin(dot(co.xy+3. ,vec2(12.9898,78.233))) * 43758.5453); \n    return mix(a,b+clamps(mix(0.,c,sin(time/2.))),(sin(time)/2.)+0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float time = iTime;\n    //Make background\n    float noisebg = 1.-(length(uv-0.5)-randfade(uv,time)*sin((uv.y*5.+uv.x)+(uv.x*3.+(uv.y*uv.y*6.))+time));\n    vec3 bg = clamp(vec3(pow(noisebg,0.2),noisebg*1.5,noisebg),0.,1.);\n    \n    //Make raster bar1\n    //vec2(shade,alpha)\n    float ypos = sin(time)/1.;\n    float size = 5.;\n    vec2 uv1 = ((uv-0.5)*size)+0.5;\n    vec2 rasterbar = vec2(dsin((uv1.y*180.)+(ypos*180.)),1.-clamps(float(uv1.y>(1.-ypos))+float(uv1.y<(0.-ypos))));\n    //\n    //Make raster bar2\n    //vec2(shade,alpha)\n    ypos = sin(time*3.)/1.1;\n    vec2 rasterbar2 = vec2(dsin((uv1.y*180.)+(ypos*180.)),1.-clamps(float(uv1.y>(1.-ypos))+float(uv1.y<(0.-ypos))));\n    //\n    //Make raster bar3\n    //vec2(shade,alpha)\n    ypos = sin(time*2.)/0.7;\n    vec2 rasterbar3 = vec2(dsin((uv1.y*180.)+(ypos*180.)),1.-clamps(float(uv1.y>(1.-ypos))+float(uv1.y<(0.-ypos))));\n    //This is confusing\n    vec3 colors = vec3(clamp(bg-rasterbar.g-rasterbar2.g-rasterbar3.g,0.,1.))+vec3(mix(0.,rasterbar.r,rasterbar.g),mix(0.,rasterbar2.r,rasterbar2.g)-rasterbar.g,((mix(0.,rasterbar3.r,rasterbar3.g))-rasterbar.g)-rasterbar2.g);\n\tfragColor = vec4(colors,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lljGzV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 51, 51, 123], [125, 125, 148, 148, 180], [182, 182, 207, 207, 238], [240, 240, 276, 276, 579], [581, 581, 638, 638, 1844]], "test": "valid"}
{"id": "llS3zd", "name": "Gimbal Harmonics", "author": "otaviogood", "description": "I like visualizations of different frequencies next to each other. So I tried one with discs. I stuck with the same lighting and materials as my last shader.", "tags": ["raymarching", "harmonics", "harmonic", "gimbal"], "likes": 57, "viewed": 3844, "published": "Public API", "date": "1431490269", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^This means do anything you want with this code. Because we are programmers, not lawyers.\n\n-Otavio Good\n*/\n\nfloat localTime = 0.0;\nfloat marchCount;\n\nfloat PI=3.14159265;\n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nvec3 RotateX(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\n}\nvec3 RotateY(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\n}\nvec3 RotateZ(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\n}\n\n\n/*vec3 GetEnvColor(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 tex = texture(iChannel0, rayDir).xyz;\n\ttex = tex * tex;\t// gamma correct\n    return tex;\n}*/\n\n// This is a procedural environment map with a giant overhead softbox,\n// 4 lights in a horizontal circle, and a bottom-to-top fade.\nvec3 GetEnvColor2(vec3 rayDir, vec3 sunDir)\n{\n    // fade bottom to top so it looks like the softbox is casting light on a floor\n    // and it's bouncing back\n    vec3 final = vec3(1.0) * dot(-rayDir, sunDir) * 0.5 + 0.5;\n    final *= 0.125;\n    // overhead softbox, stretched to a rectangle\n    if ((rayDir.y > abs(rayDir.x)*1.0) && (rayDir.y > abs(rayDir.z*0.25))) final = vec3(2.0)*rayDir.y;\n    // fade the softbox at the edges with a rounded rectangle.\n    float roundBox = length(max(abs(rayDir.xz/max(0.0,rayDir.y))-vec2(0.9, 4.0),0.0))-0.1;\n    final += vec3(0.8)* pow(saturate(1.0 - roundBox*0.5), 6.0);\n    // purple lights from side\n    final += vec3(8.0,6.0,7.0) * saturate(0.001/(1.0 - abs(rayDir.x)));\n    // yellow lights from side\n    final += vec3(8.0,7.0,6.0) * saturate(0.001/(1.0 - abs(rayDir.z)));\n    return vec3(final);\n}\n\n/*vec3 GetEnvColorReflection(vec3 rayDir, vec3 sunDir, float ambient)\n{\n\tvec3 tex = texture(iChannel0, rayDir).xyz;\n\ttex = tex * tex;\n    vec3 texBack = texture(iChannel0, rayDir).xyz;\n    vec3 texDark = pow(texBack, vec3(50.0)).zzz;\t// fake hdr texture\n    texBack += texDark*0.5 * ambient;\n    return texBack*texBack*texBack;\n}*/\n\nvec3 camPos = vec3(0.0), camFacing;\nvec3 camLookat=vec3(0,0.0,0);\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 matMin(vec2 a, vec2 b)\n{\n\tif (a.x < b.x) return a;\n\telse return b;\n}\n\nfloat spinTime;\n\nconst float thick = 0.85;\nconst float spacer = 0.01;\nconst float thickSpace = thick - spacer;\nfloat Disc(vec3 p, float scale)\n{\n    float len = length(p.xz);\n    // infinite cylinder\n    float dist = len - scale;\n    // cut out the inner disc\n    dist = max(dist, -(len - thick*scale));\n    //dist = max(dist, -(length(p.xz + vec2(thick*scale, 0.0)) - thick*scale*0.15));\n    // cut off half the disc because that looks cool maybe.\n    dist = max(dist, -p.z);\n    // make it flat, but with nice rounded edges so reflections look good. (slow)\n    dist = -smin(-dist, -(abs(p.y)-0.025), 0.015*scale);\n    //dist = max(dist, abs(p.y)-0.025);\n    return dist;\n}\n\n// Calculate the distance field that defines the object.\nvec2 DistanceToObject(vec3 p)\n{\n    float dist = 1000000.0;\n    float currentThick = 8.0;\n    float harmonicTime = spinTime*0.125*3.14159*4.0;\n    // make 15 discs inside each other\n    for (int i = 0; i < 15; i++)\n    {\n        dist = min(dist, Disc(p, currentThick));\n        p = RotateX(p, harmonicTime);\n        p = RotateZ(p, harmonicTime);\n        // scale down a level\n        currentThick *= thickSpace;\n    }\n    vec2 distMat = vec2(dist, 0.0);\n    // ball in center\n    distMat = matMin(distMat, vec2(length(p) - 0.45, 6.0));\n    return distMat;\n}\n\n// dirVec MUST BE NORMALIZED FIRST!!!!\nfloat SphereIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 spherePos, float rad)\n{\n    vec3 radialVec = pos - spherePos;\n    float b = dot(radialVec, dirVecPLZNormalizeMeFirst);\n    float c = dot(radialVec, radialVec) - rad * rad;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    return -b - sqrt(h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    localTime = iTime - 0.0;\n\t// ---------------- First, set up the camera rays for ray marching ----------------\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\n    float zoom = 1.7;\n    uv /= zoom;\n\n\t// Camera up vector.\n\tvec3 camUp=vec3(0,1,0);\n\n\t// Camera lookat.\n\tcamLookat=vec3(0,0.0,0);\n\n    // debugging camera\n    float mx=iMouse.x/iResolution.x*PI*2.0-0.7 + localTime*3.1415 * 0.0625*0.666;\n\tfloat my=-iMouse.y/iResolution.y*10.0 - sin(localTime * 0.31)*0.5;//*PI/2.01;\n\tcamPos += vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*(12.2);\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\n\tvec3 upNorm=cross(camVec, sideNorm);\n\tvec3 worldFacing=(camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;\n\tvec3 rayVec = normalize(worldPix - camPos);\n\n\t// ----------------------------------- Animate ------------------------------------\n    localTime = iTime*0.125;\n    // This is a wave function like a triangle wave, but with flat tops and bottoms.\n    // period is 1.0\n    float rampStep = min(3.0,max(1.0, abs((fract(localTime)-0.5)*1.0)*8.0))*0.5-0.5;\n    rampStep = smoothstep(0.0, 1.0, rampStep);\n    // lopsided triangle wave - goes up for 3 time units, down for 1.\n    float step31 = (max(0.0, (fract(localTime+0.125)-0.25)) - min(0.0,(fract(localTime+0.125)-0.25))*3.0)*0.333;\n\n    spinTime = step31 + localTime - 0.125;\n\t// --------------------------------------------------------------------------------\n\tvec2 distAndMat = vec2(0.5, 0.0);\n\tfloat t = 0.0;\n\t//float inc = 0.02;\n\tfloat maxDepth = 21.0;\n\tvec3 pos = vec3(0,0,0);\n    marchCount = 0.0;\n    // intersect with sphere first as optimization so we don't ray march more than is needed.\n    float hit = SphereIntersect(camPos, rayVec, vec3(0.0), 8.0);\n    if (hit >= 0.0)\n    {\n        t = hit;\n        // ray marching time\n        for (int i = 0; i < 120; i++)\t// This is the count of the max times the ray actually marches.\n        {\n            pos = camPos + rayVec * t;\n            // *******************************************************\n            // This is _the_ function that defines the \"distance field\".\n            // It's really what makes the scene geometry.\n            // *******************************************************\n            distAndMat = DistanceToObject(pos);\n            // move along the ray\n            t += distAndMat.x;\n            if ((t > maxDepth) || (abs(distAndMat.x) < 0.0025)) break;\n            //marchCount+= 1.0;\n        }\n    }\n    else\n    {\n        t = maxDepth + 1.0;\n        distAndMat.x = 1000000.0;\n    }\n    // --------------------------------------------------------------------------------\n\t// Now that we have done our ray marching, let's put some color on this geometry.\n\n\tvec3 sunDir = normalize(vec3(3.93, 10.82, -1.5));\n\tvec3 finalColor = vec3(0.0);\n\n\t// If a ray actually hit the object, let's light it.\n\t//if (abs(distAndMat.x) < 0.75)\n    if (t <= maxDepth)\n\t{\n        // calculate the normal from the distance field. The distance field is a volume, so if you\n        // sample the current point and neighboring points, you can use the difference to get\n        // the normal.\n        vec3 smallVec = vec3(0.005, 0, 0);\n        vec3 normalU = vec3(distAndMat.x - DistanceToObject(pos - smallVec.xyy).x,\n                           distAndMat.x - DistanceToObject(pos - smallVec.yxy).x,\n                           distAndMat.x - DistanceToObject(pos - smallVec.yyx).x);\n\n        vec3 normal = normalize(normalU);\n\n        // calculate 2 ambient occlusion values. One for global stuff and one\n        // for local stuff\n        float ambientS = 1.0;\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.1).x*10.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.2).x*5.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.4).x*2.5);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.8).x*1.25);\n        float ambient = ambientS * saturate(DistanceToObject(pos + normal * 1.6).x*1.25*0.5);\n        ambient *= saturate(DistanceToObject(pos + normal * 3.2).x*1.25*0.25);\n        ambient *= saturate(DistanceToObject(pos + normal * 6.4).x*1.25*0.125);\n        ambient = max(0.035, pow(ambient, 0.3));\t// tone down ambient with a pow and min clamp it.\n        ambient = saturate(ambient);\n\n        // calculate the reflection vector for highlights\n        vec3 ref = reflect(rayVec, normal);\n        ref = normalize(ref);\n\n        // Trace a ray for the reflection\n        float sunShadow = 1.0;\n        float iter = 0.1;\n        vec3 nudgePos = pos + ref*0.3;// normal*0.02;\t// don't start tracing too close or inside the object\n\t\tfor (int i = 0; i < 40; i++)\n        {\n            float tempDist = DistanceToObject(nudgePos + ref * iter).x;\n\t        sunShadow *= saturate(tempDist*50.0);\n            if (tempDist <= 0.0) break;\n            //iter *= 1.5;\t// constant is more reliable than distance-based\n            iter += max(0.00, tempDist)*1.0;\n            if (iter > 9.0) break;\n        }\n        sunShadow = saturate(sunShadow);\n\n        // ------ Calculate texture color ------\n        vec3 texColor;\n        texColor = vec3(1.0);// vec3(0.65, 0.5, 0.4)*0.1;\n        texColor = vec3(0.85, 0.945 - distAndMat.y * 0.15, 0.93 + distAndMat.y * 0.35)*0.951;\n        if (distAndMat.y == 6.0) texColor = vec3(0.91, 0.1, 0.41)*10.5;\n        //texColor *= mix(vec3(0.3), vec3(1.0), tex3d(pos*0.5, normal).xxx);\n        texColor = max(texColor, vec3(0.0));\n        texColor *= 0.25;\n        //texColor += vec3(1.0, 0.0, 0.0) * 8.0/length(pos);\n\n        // ------ Calculate lighting color ------\n        // Start with sun color, standard lighting equation, and shadow\n        vec3 lightColor = vec3(0.0);// sunCol * saturate(dot(sunDir, normal)) * sunShadow*14.0;\n        // sky color, hemisphere light equation approximation, ambient occlusion\n        lightColor += vec3(0.1,0.35,0.95) * (normal.y * 0.5 + 0.5) * ambient * 0.2;\n        // ground color - another hemisphere light\n        lightColor += vec3(1.0) * ((-normal.y) * 0.5 + 0.5) * ambient * 0.2;\n\n\n        // finally, apply the light to the texture.\n        finalColor = texColor * lightColor;\n       // if (distAndMat.y == 6.0) finalColor += vec3(0.91, 0.032, 0.01)*0.2;\n        //if (distAndMat.y == ceil(mod(localTime, 4.0))) finalColor += vec3(0.0, 0.41, 0.72)*0.925;\n\n        // reflection environment map - this is most of the light\n        vec3 refColor = GetEnvColor2(ref, sunDir)*sunShadow;// * (length(normalU)/smallVec.x-0.875)*8.0;\n        finalColor += refColor * 0.35 * ambient;// * sunCol * sunShadow * 9.0 * texColor.g;\n\n        // fog\n\t\tfinalColor = mix(vec3(1.0, 0.41, 0.41) + vec3(1.0), finalColor, exp(-t*0.0007));\n        // visualize length of gradient of distance field to check distance field correctness\n        //finalColor = vec3(0.5) * (length(normalU) / smallVec.x);\n\t}\n    else\n    {\n\t    finalColor = GetEnvColor2(rayVec, sunDir);// + vec3(0.1, 0.1, 0.1);\n    }\n    //finalColor += marchCount * vec3(1.0, 0.3, 0.91) * 0.001;\n\n    // vignette?\n    //finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\n    //finalColor *= 1.2;\n\n\t// output the final color with sqrt for \"gamma correction\"\n\tfragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llS3zd.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[0, 626, 649, 649, 678], [679, 679, 702, 702, 731], [732, 732, 757, 757, 786], [788, 788, 821, 821, 938], [939, 939, 972, 972, 1088], [1089, 1089, 1122, 1122, 1239], [1389, 1522, 1567, 1680, 2366], [2768, 2804, 2845, 2845, 2938], [2940, 2940, 2969, 2969, 3013], [3126, 3126, 3159, 3159, 3689], [3691, 3748, 3779, 3779, 4305], [4307, 4346, 4438, 4438, 4668], [4670, 4670, 4727, 4727, 12075]], "test": "valid"}
{"id": "lt23WK", "name": "Knotting", "author": "shezard", "description": "Testing knots", "tags": ["knot"], "likes": 28, "viewed": 1243, "published": "Public", "date": "1432641104", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14\n#define TAU 6.28318530718\n\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat noise(in vec2 uv) {\n\treturn sin(1.5*uv.x)*sin(1.5*uv.y);\n}\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat fbm(vec2 uv) {\n    float f = 0.0;\n    f += 0.5000*noise(uv); uv = m*uv*2.02;\n    f += 0.2500*noise(uv); uv = m*uv*2.03;\n    f += 0.1250*noise(uv); uv = m*uv*2.01;\n    f += 0.0625*noise(uv);\n    return f/0.9375;\n}\n\nfloat fbm2(in vec2 uv) {\n   vec2 p = vec2(fbm(uv + vec2(0.0,0.0)),\n                 fbm(uv + vec2(5.2,1.3)));\n\n   return fbm(uv + 4.0*p);\n}\n\nfloat rand(in vec2 uv) {\n    return fract(sin(dot(uv.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 add(in vec2 a, in vec2 b) {\n \n    float mat;\n    if(a.x < b.x) {\n      mat = a.y;\n    } else {\n      mat = b.y;\n    }\n    \n    return vec2(min(a.x,b.x), mat);\n}\n\nvec2 sub(in vec2 a, in vec2 b) {\n    \n    float mat;\n    if(a.x < b.x) {\n      mat = b.y;\n    } else {\n      mat = a.y;\n    }\n    \n    return vec2(max(a.x, b.x), mat);\n}\n\nvec3 rep(in vec3 p, in vec3 c) {\n    vec3 q = mod(p,c)-0.5*c;\n    return q;\n}\n\nvec2 rotate(in vec2 p, in float ang) {\n    float c = cos(ang), s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nvec2 torus(in vec3 p, in vec2 t, in float mat) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return vec2(length(q)-t.y, mat);\n}\n\nvec2 sphere(in vec3 p, in float r, in float mat) {\n    return vec2(length(p) - r, mat);\n}\n\nvec2 plane(in vec3 p, in vec4 n, in float mat) {\n  return vec2(dot(p,n.xyz) + n.w, mat);\n}\n\nvec2 cylinder(in vec3 p, in vec3 c, in float mat) {\n  return vec2(length(p.xz-c.xy)-c.z, mat);\n}\n\nvec2 box(in vec3 p, in vec3 b, in float mat) {\n  return vec2(length(max(abs(p)-b,0.0)), mat);\n}\n\n// WIP\nfloat trans(in float x, in vec2 p) {\n   return mod(x, 0.001*TAU) - 0.001*TAU / 2.0;\n}\n\n\nvec2 knot(in vec3 p, in float k, in float mat) {\n    float r = length(p.xy);\n    float oa, a = atan(p.y, p.x); \n    oa = k*a;\n    a = trans(a, p.xy);\n    \n    p.xy = r*vec2(cos(a), sin(a)); p.x -= 6.0;\n    p.xz = cos(oa)*p.xz + sin(oa)*vec2(-p.z, p.x);\n    p.x = abs(p.x) - 1.35; \n    return vec2(length(p) - 1.0, mat);\n}\n\nfloat map(in vec3 p, inout float mat) {\n   \n   p.z = cos(p.z);\n    \n   vec2 scene = vec2(999.0, 0.0);\n   \n    // TODO : see how to interpolate between rate N and N+1\n   float rate = 1.0; // mod(iTime, 3.0);\n   \n   float r1 = floor(rate);\n   float r2  = floor(rate) + 1.0;\n    \n   vec2 k = knot(p, r1, length(p+fbm2(p.xy))*.1);\n    \n   vec2 k2 = knot(p, r2, length(p+fbm2(p.xy))*.1);\n    \n   float y = 0.5 + cos(iTime) * 0.5;\n    \n   scene = add(scene,mix(k,k2,y));\n    \n   mat = scene.y;\n   return scene.x;\n}\n\nmat3 setLookAt(in vec3 ro, in vec3 ta,in float cr) {\n\tvec3  cw = normalize(ta-ro);\n\tvec3  cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3  cu = normalize( cross(cw,cp) );\n\tvec3  cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd, in float mint, in float tmax) {\n\tfloat res = 1.0;\n    float t = mint;\n    \n    float mat = 0.0;\n    \n    for( int i = 0; i < 16; i++ ) {\n\t\tfloat h = map(ro + rd*t, mat);\n        res = min( res, 4.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*uv;\n    p.x *= iResolution.x / iResolution.y;\n    \n    // camera\t\n    vec3 ro = vec3(\n        0.0,\n        0.0,\n        16.0+iTime*5.0\n   \t);\n    vec3 ta = vec3(0.0,0.0,0.0);\n    float roll = iTime*.1;\n\n    // camera tx\n    mat3 ca = setLookAt( ro, ta, roll );\n    vec3 rd = normalize( ca * vec3(p.xy,1.75) );\n\n    float t = 0.001;      // Near\n    float tmax = 120.0; // Far\n   \t\n    float h = 0.001;\n    float hmax = 0.001;\n    \n    float mat = 0.0;\n    \n    vec3 c = vec3(0.0);\n    vec3 ao = vec3(0.0);\n    \n    const int steps = 100;\n    for(int i = 0 ; i < steps ; i++) {\n        \n        if(h < hmax || t > tmax ) {\n        \tao = vec3(1.0) - float(i)/float(steps);\n            break;\n        }\n        \n        h = map(ro + t *rd, mat);\n        t += h;\n    }\n    \n    if(t < tmax) {\n        vec3 pos = ro+rd*t;\n        \n        vec2 r = vec2(0.001,0.0);\n        vec3 nor = normalize(vec3(map(pos+r.xyy, mat)-map(pos-r.xyy, mat),\n                                  map(pos+r.yxy, mat)-map(pos-r.yxy, mat),\n                                  map(pos+r.yyx, mat)-map(pos-r.yyx, mat)));\n      \tvec3 ref = reflect(rd,nor);\n        \n        c = vec3(1.0,1.2,1.1);;\n        \n        if(mat == 0.0) {\n            c = vec3(0.0);\n        } else {\n            c = vec3(.5,.1,.3);\n            \n            c = rgb2hsv(c);\n            \n            c.x += mat+.1 + pos.z*.1;\n            c.y = .85;\n            c.z = 1.4;\n            \n            c = hsv2rgb(c);\n        }\n        \n        float power = 8.0;\n        ao = vec3(pow(ao.x,power),pow(ao.y,power),pow(ao.z,power));\n        \n        c *= 1.0 - exp(1.0 / log(ao));\n    } else {\n        c = vec3(0.);\n    }\n    \n\tfragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt23WK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 65, 65, 396], [398, 398, 420, 420, 589], [591, 591, 616, 616, 655], [708, 708, 728, 728, 926], [928, 928, 952, 952, 1067], [1069, 1069, 1093, 1093, 1165], [1167, 1167, 1199, 1199, 1332], [1334, 1334, 1366, 1366, 1503], [1505, 1505, 1537, 1537, 1582], [1584, 1584, 1622, 1622, 1709], [1711, 1711, 1759, 1759, 1835], [1837, 1837, 1887, 1887, 1926], [1928, 1928, 1976, 1976, 2018], [2020, 2020, 2071, 2071, 2116], [2118, 2118, 2164, 2164, 2213], [2215, 2222, 2258, 2258, 2307], [2310, 2310, 2358, 2358, 2631], [2633, 2633, 2672, 2672, 3141], [3143, 3143, 3195, 3195, 3376], [3378, 3378, 3450, 3450, 3742], [3744, 3744, 3801, 3801, 5555]], "test": "valid"}
{"id": "lt23zc", "name": "Wondercube", "author": "kuvkar", "description": "Transforming fractal cube. Fractal model is based on iq's article  http://iquilezles.org/www/articles/menger/menger.htm\nRotate with mouse, looks nice at fullscreen.", "tags": ["fractal"], "likes": 9, "viewed": 258, "published": "Public", "date": "1431182637", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n#define inf 999999.0\n\n// This sets switching to the second model on the transition.\nconst bool switchModel = true;\n\nmat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\nmat3 rotation;\n\nvec3 light = vec3(0.0, 0.0, -1.0);\nvec4 ambient = vec4(0.15);\nconst float boxs = 1.0;\n\n// distance functions: \n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdBox(in vec3 p,in vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\n\nfloat sdCross( in vec3 p )\n{\n  float da = sdBox(p.xyz, vec3(inf, boxs, boxs));\n  float db = sdBox(p.yzx, vec3(boxs, inf, boxs));\n  float dc = sdBox(p.zxy, vec3(boxs, boxs, inf));\n  return min(da,min(db,dc));\n}\n\n\n// \"scene\"\nfloat colswitch = 0.0;\nconst float switchFreg = 4.0;\nbool model1 = true;\nint hititer = -1;\nvec4 basecolor = vec4(0.0, 0.5, 1.0, 0.0);\nvec4 secondarycol = vec4(0.1, 0.2, 0.2, 0.0);\n\n\nfloat map(in vec3 pos)\n{\n    pos *= rotation;\n    \n    float s = 1.0;\n    const int iter = 3;\n    \n    float m = udRoundBox(pos, vec3(boxs * 0.5), 0.4);\n    \n    for (int i = 0; i < iter; ++i)\n    {\n        vec3 a = mod(pos * s, 2.0) - 1.0;\n        \n        s *= 3.0;\n        float cr = 1.5;\n        if(model1 && switchModel)\n        {\n            cr = 2.0;\n        }\n        vec3 r = cr - 3.0 * abs(a);\n        float c = sdCross(r) / s;\n        \n        if(c > 0.0 && m < 0.0)\n        {\n        \thititer = i;\n        }\n        \n        \n        m = max(m, c);\n    }\n    return m;\n}\n\nvec3 grad(in vec3 p)\n{\n    vec2 offset = vec2(0.008, 0.0);\n    vec3 g = vec3(map(p + offset.xyy) - map(p - offset.xyy),\n\t\t\t\t  map(p + offset.yxy) - map(p - offset.yxy),\n\t\t\t\t  map(p + offset.yyx) - map(p - offset.yyx));\n    return normalize(g);\n                  \n}\n\n\nfloat ao (in vec3 pos, in vec3 norm)\n{\n    float dist = 0.01;\n    pos += norm * dist;\n    float m = map(pos);\n    float ao = clamp(m, 0.0, dist) / dist;\n    return ao;\n}\n\n\nbool trace(in vec3 o, in vec3 dir, inout vec4 color)\n{\n    color = vec4(0.0);\n    vec3 rp = o;\n    float m = 0.0;\n    float closest = 9999.0;\n    float t = iTime * 0.4 + 9.0;\n    colswitch = mod(t, switchFreg * 2.0);\n    bool firstpass = colswitch < switchFreg;\n\tvec4 bcol = vec4(0.0);\n    float mm = mod(t, switchFreg);\n    \n\tfor (int i = 0; i < 100; ++i)\n    {\n\n        // initial state setup\n        bcol = firstpass ? basecolor : secondarycol;\n        model1 = firstpass;\n        \n        float m = o.z + mm;\n        float dif = rp.z - m;\n\n\t\t// switch on sweep\n        if (dif < 0.0)\n        {\n            bcol = firstpass ? secondarycol : basecolor;\n            model1 = !firstpass;\n        }                \n        \n        m = map(rp);\n        closest = min(closest, m);\n        color = bcol;\n        if (m < 0.0)\n        {\n            // coloring\n            if(hititer == 1)\n            {\n            \tcolor = vec4(0.2, 0.4, 0.8, 0.0);\n            }\n\n            if(hititer == 2)\n            {\n            \tcolor = vec4(1., 1.0, 1.0, 0.0);\n            }\n            \n            vec3 norm = grad(rp);\n            // diffuse\n            float d = dot(light, norm);\n            d = clamp(d, 0.1, 1.0);\n            color *= d;\n            \n            // blinn-phong specular\n            vec3 H = normalize(-dir + light);\n            float spc = clamp(dot(H, norm), 0.0, 1.0);\n            \n            spc = pow(spc, 35.0) * 0.4;\n            color += spc * vec4(1.0, 1.0, 1.0, 0.0);\n            \n\t\t\t// ambient + ao            \n            color += ambient;\n            color *= mix(ao(rp, norm), 1.0, 0.5);\n            \n            // switch effect \n            float e = abs(dif);\n            float efsize = 0.05;\n            e = 1.0 - clamp(e, 0.0, efsize) / efsize;\n            color += e * texture(iChannel0, vec2(rp.z, rp.x) * 4.0).r;\n            return true;\n        }\n        \n        \n        rp += dir * max(m, 0.0001);\n        \n        if(rp.z > 1.0)\n        {\n    \t   // outer glow\t\n           float maxd = 0.03;\n           float glow = clamp( (maxd - closest), 0.0, closest) / closest;\n           color = vec4(0.0, 0.5, 1.0, 0.0) * (glow) * 0.5; \n           return glow >= 0.8;\n        }\n    }\n    return false;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    light = normalize(light);\n    fragColor = vec4(0.0);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.5);\n    uv.y /= iResolution.x / iResolution.y;\n    \n    rotation = mat3(1.0);\n    rotation *= roty(iTime * 0.2);\n    rotation *= rotx(iTime * 0.1);\n    \n    rotation *= roty(iMouse.x * 0.025);\n    rotation *= rotx(-iMouse.y * 0.025);\n    \n    vec3 o = vec3(0.0, 0.0, -3.0);\n    vec3 dir = normalize(vec3(uv.x, uv.y, 0.6));\n    \n    if(!trace(o, dir, fragColor))\n    {\n        fragColor += vec4(0.9, 0.7, 0.5, 0.0) * (1.8 - pow(length(uv), 0.45));\n    }\n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt23zc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 135, 155, 155, 282], [283, 283, 303, 303, 430], [534, 629, 674, 674, 714], [716, 716, 751, 751, 847], [850, 850, 878, 878, 1059], [1062, 1255, 1279, 1279, 1837], [1839, 1839, 1861, 1861, 2103], [2106, 2106, 2144, 2144, 2275], [2278, 2278, 2332, 2332, 4510], [4513, 4513, 4570, 4570, 5141]], "test": "error"}
{"id": "lt2GRV", "name": "Light Fields", "author": "mu6k", "description": "Took my terrain from rocket science and added some glowing spheres.", "tags": ["reflection", "terrain", "raymarch", "volumetric", "glow"], "likes": 38, "viewed": 3442, "published": "Public API", "date": "1430584454", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* by musk License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License. */\n/* synced to this: https://www.youtube.com/watch?v=0NKUpo_xKyQ */\n\n#define motion_blur\n\n#ifdef motion_blur\n#define time (iTime + texture(iChannel0,gl_FragCoord.xy/256.0).x/24.0)\n#else\n#define time (iTime)\n#endif\n\nvoid angularRepeat(const float a, inout vec2 v)\n{\n    float an = atan(v.y,v.x);\n    float len = length(v);\n    an = mod(an+a*.5,a)-a*.5;\n    v = vec2(cos(an),sin(an))*len;\n}\n\n\nvoid angularRepeat(const float a, const float offset, inout vec2 v)\n{\n    float an = atan(v.y,v.x);\n    float len = length(v);\n    an = mod(an+a*.5,a)-a*.5;\n    an+=offset;\n    v = vec2(cos(an),sin(an))*len;\n}\n\nfloat mBox(vec3 p, vec3 b)\n{\n\treturn max(max(abs(p.x)-b.x,abs(p.y)-b.y),abs(p.z)-b.z);\n}\n\nfloat mSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\n\nvec2 frot(const float a, in vec2 v)\n{\n    float cs = cos(a), ss = sin(a);\n    vec2 u = v;\n    v.x = u.x*cs + u.y*ss;\n    v.y = u.x*-ss+ u.y*cs;\n    return v;\n}\n\nvoid rotate(const float a, inout vec2 v)\n{\n    float cs = cos(a), ss = sin(a);\n    vec2 u = v;\n    v.x = u.x*cs + u.y*ss;\n    v.y = u.x*-ss+ u.y*cs;\n}\n\nfloat dfTerraHills(vec3 p)\n{\n    p.y-=1.0;\n    vec3 pm = p;\n    pm.xz = mod(pm.xz+vec2(8.0),16.0)-vec2(8.0);\n    pm = abs(pm);\n    return (p.y*.8+3.0+pm.x*.1+pm.z*.1);\n}\n\nfloat dfTerra(vec3 p)\n{\n    p.y+=.1;\n    vec3 p2 = p;\n    float height = (sin(p.x*.1)+sin(p.z*.1))*1.5;\n    rotate(.6,p2.xz);\n    return max(dfTerraHills(p2),dfTerraHills(p))+height;\n}\n\n\nfloat dfBalls(vec3 p)\n{\n    vec2 pm = mod(p.xz+5.0,10.0)-5.0;\n    vec2 id = p.xz-pm;\n    float h = dfTerra(vec3(id.x,.0,id.y));\n    h+=sin(id.x*7.1+id.y*17.841+time*sin(id.x*9.1+id.y))*.5;\n    p.y+=h;\n    \n    return length(vec3(pm.x,p.y,pm.y))-.3;\n}\n\nfloat df(vec3 p)\n{\n    return min(dfTerra(p),dfBalls(p));\n}\n\nvec3 nf(vec3 p)\n{\n    vec2 e = vec2(0,0.005);\n    return normalize(vec3(dfTerra(p+e.yxx),dfTerra(p+e.xyx),dfTerra(p+e.xxy)));\n}\n\nvec3 cf(vec2 p)\n{\n    return texture(iChannel0,p*.00005).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ctime = time*.125+32.0;\n    float stime = ctime - mod(ctime,1.0);\n    float cs0 = sin(stime*141.123);\n    float cs1 = sin(stime*51.124);\n    cs0 = cs0*cs0*cs0*cs0*cs0*4.0;\n    cs1 = cs1*cs1;\n\tvec2 uv = (fragCoord.xy-iResolution.xy*.5) / iResolution.yy;\n    vec2 mouse = (iMouse.xy-iResolution.xy*.5) / iResolution.yy;\n    if (iMouse.w>.2) mouse*=.0;;\n    \n    vec3 pos = vec3(.1,.1,-5);\n    //vec3 dir = normalize(vec3(uv,1.0));\n    vec3 dir = normalize(vec3(uv,1.0));\n    \n    pos.z += time*8.0*cs1+stime*8.0;\n    rotate(.3,pos.xz);\n    rotate(-.1+sin(time*.071*cs0+stime*2.0)*.2,dir.yz);\n    rotate(.3+sin(sin(time*.05*cs0+stime*2.0)*2.0+time*.1*cs0+stime*2.0),dir.xz);\n    \n    \n    float dist,tdist = .0;\n    vec3 fog = vec3(.0);\n    \n    for (int i=0; i<120; i++)\n    {\n        float db, df;\n        dist = min(df = dfTerra(pos),db = dfBalls(pos));\n     \t//dist = df(pos);\n        fog += vec3(0.01/(1.0+db*db))*dist*cf(pos.xz);\n       \tpos += dist*dir;\n        tdist+=dist;\n        if (dist<0.0001||dist>200.0)break;\n    }\n    \n    vec3 light = normalize(vec3(1,2,3));\n    \n    \n    vec3 skyColor = vec3(.1,.1,.1)*.7;\n    \n    vec3 ambientColor = skyColor*.07;\n    vec3 materialColor = vec3(.5,.5,.5);\n    vec3 emissiveColor = vec3(.0,.0,.0);\n    vec3 reflection = vec3(.0);\n    float diffuse = 1.0;\n    \n    if (dfBalls(pos)<dfTerra(pos))\n    {\n     \tmaterialColor= vec3(.0);\n        emissiveColor = cf(pos.xz)*2.0;\n    }\n    else\n    {\n        diffuse = 1.0/(1.0+dfBalls(pos));\n        vec3 noi = texture(iChannel0,pos.xz).xyz;\n        vec3 col = cf(pos.xz);\n        materialColor = col*noi;\n        vec3 rpos = pos;\n        vec3 rdir = reflect(dir,nf(pos));\n        rdir += (noi.xyz-vec3(.5))*9.0;\n        rdir = normalize(rdir);\n        float dist = .0;\n        for (int i=0; i<10; i++)\n        {\n            dist = dfBalls(rpos);\n            rpos += dist*rdir;\n        }\n        if (dist<.1)\n            reflection = col*noi.x*.5;\n    }\n  \n    \n   \n    float value = \n        df(pos+light)+\n        df(pos+light*.5)*2.0+\n        df(pos+light*.25)*4.0+\n        df(pos+light*.125)*8.0+\n        df(pos+light*.06125)*16.0;\n    \n    value=value*.2+.04;\n    value=min(value,1.0);\n    value=max(.0,value);\n    \n    vec3 normal = nf(pos);\n   \n    vec3 ref = reflect(dir,nf(pos));\n    //float ro = min(max(min(min(df(pos+ref),df(pos+ref*0.25)*4.0), df(pos+ref*.5)*2.0)*.5,.0),1.0);\n   \tfloat ro=1.0;\n    \n    float ao = df(pos+normal*.125)*8.0 +\n        df(pos+normal*.5)*2.0 +\n    \tdf(pos+normal*.25)*4.0 +\n    \tdf(pos+normal*.06125)*16.0;\n    \n    ao=ao*.125+.5;\n    \n    \n    float fres = pow((dot(dir,nf(pos))*.5+.5),2.0);\n    \n    vec3 color = (value*vec3(dot(nf(pos),light)*.5+.5)*.5+ambientColor*ao)*materialColor*diffuse +reflection*fres;\n    color += emissiveColor;\n    //color = vec3(fres);\n    vec3 cSky = skyColor*(1.0-dir.y);\n    if (dist>0.5) color = cSky*.1;\n    /*else color = mix(cSky,color,1.0/(1.0+tdist*.005));*/\n   \t\n    color += fog;\n    //color = fog;\n    //color = reflection;\n    \n    color*=1.3; //boost\n    ;\n    color *= (1.0-pow(length(uv),2.0)*.9);\n    color *= min(time*.1,1.0);\n    color *= 1.5/(.5+mod(time,8.0)*.125);\n    color = mix(color,vec3(length(color)),length(color)*.5-.1);\n    \n\tfragColor = vec4(pow(color,vec3(1.0/2.2)),1.0)+texture(iChannel0,fragCoord.xy/256.0)/128.0;\n    //fragColor = vec4(ro);\n    //fragColor = vec4(ao);\n    //fragColor = vec4(value);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt2GRV.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 311, 360, 360, 484], [487, 487, 556, 556, 696], [698, 698, 726, 726, 786], [788, 788, 820, 820, 846], [849, 849, 886, 886, 1008], [1010, 1010, 1052, 1052, 1160], [1162, 1162, 1190, 1190, 1331], [1333, 1333, 1356, 1356, 1517], [1520, 1520, 1543, 1543, 1770], [1772, 1772, 1790, 1790, 1831], [1833, 1833, 1850, 1850, 1960], [1962, 1962, 1979, 1979, 2025], [2027, 2027, 2084, 2084, 5498]], "test": "error"}
{"id": "lt2Gzt", "name": "Stairway to the Stars", "author": "dr2", "description": "A long climb; use the mouse to look around.", "tags": ["raymarching", "replication"], "likes": 41, "viewed": 5616, "published": "Public API", "date": "1431533117", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Stairway to the Stars\" by dr2 - 2015\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float s = 0.;\n  float a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return s;\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\n#define REFBALL\n\nint idObj;\nfloat tCur, stPitch, rotAng, rOut, rIn, rWid;\nvec3 qHit, ltPos[2];\nint doLt;\nconst float dstFar = 20.;\n\nvec3 BrickCol (vec2 p)\n{\n  vec2 i = floor (p);\n  if (2. * floor (i.y / 2.) != i.y) {\n    p.x += 0.5;\n    i = floor (p);\n  }\n  p = smoothstep (0.02, 0.08, abs (fract (p + 0.5) - 0.5));\n  return (0.5 + 0.5 * p.x * p.y) * vec3 (0.5, 0.4, 0.3);\n}\n\nvec3 WoodCol (vec2 p)\n{\n  float f = Fbm2 (p * vec2 (1., 0.1));\n  return mix (vec3 (0.8, 0.4, 0.2), vec3 (0.45, 0.25, 0.1), f);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, pp;\n  float d, dr, da, dy, dMin, r, ns, nh, sh, sw, rw, ca, sa;\n  const int ins = 12;\n  const int inh = 6;\n  dMin = dstFar;\n  ns = float (ins);\n  nh = float (inh);\n  sh = 0.2 * stPitch / ns;\n  sw = 1.1 * pi * rOut / ns;\n  rw = 0.09;\n  pp = p;\n  pp.xz = Rot2D (pp.xz, rotAng);\n  pp.y += stPitch * rotAng / (2. * pi);\n  r = length (pp.xz);\n  dr = max (r - rOut, rIn - r);\n  q = pp;\n  d = dMin;\n  dy = stPitch / ns;\n  q.y -= dy;\n  da = 2. * pi / ns;\n  ca = cos (da);  sa = sin (da);\n  for (int j = 0; j < ins; j ++) {\n    q.y = mod (q.y + dy + 0.5 * stPitch, stPitch) - 0.5 * stPitch;\n    d = min (d, max (max (max (dr, abs (q.z) - sw), q.x), abs (q.y) - sh));\n    if (d < dMin) { dMin = d;  idObj = 1;  qHit = q; }\n    q.xz = q.xz * ca + q.zx * vec2 (- sa, sa);\n  }\n  d = min (min (d, max (r - rIn, - (r - rIn + rWid))),\n     max (r - rOut - rWid, - (r - rOut)));\n  q = pp;\n  dy = stPitch / nh;\n  q.y -= 0.25 * stPitch + dy;\n  da = 2. * pi / nh;\n  ca = cos (da);  sa = sin (da);\n  for (int j = 0; j < inh; j ++) {\n    q.y = mod (q.y + dy + 0.5 * stPitch, stPitch) - 0.5 * stPitch;\n    d = max (d, - length (q.xy) + rw);\n    q.xz = q.xz * ca + q.zx * vec2 (- sa, sa);\n  }\n  if (d < dMin) { dMin = d;  idObj = 2;  qHit = q; }\n  if (doLt != 0) {\n    d = PrSphDf (p - ltPos[0], 0.07 * rIn);\n    if (d < dMin) { dMin = d;  idObj = 5; }\n   }\n  if (doLt != 1) {\n    d = PrSphDf (p - ltPos[1], 0.07 * rIn);\n    if (d < dMin) { dMin = d;  idObj = 6; }\n  }\n#ifdef REFBALL\n  d = min (d, max (r - 0.006 * rIn, 0.));\n  if (d < dMin) { dMin = d;  idObj = 3; }\n  pp = p;\n  pp.y = mod (pp.y + stPitch * rotAng / (2. * pi) + 0.5 * stPitch, stPitch) -\n     0.5 * stPitch;\n  d = PrSphDf (pp, 0.3 * rIn);\n  if (d < dMin) { dMin = d;  idObj = 4; }\n#endif\n  return dMin;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * vec3 (v.y, v.z, v.w));\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjCol (vec3 ro, vec3 rd, vec3 vn)\n{\n  vec3 ltDir, acDif, col; \n  float ltDist, ltDistSq, dif, atten, acSpe, sh, d, h;\n  col = vec3 (0.);\n  if (idObj == 1) {\n    col = WoodCol (120. * qHit.zx);\n  } else if (idObj == 2) {\n    if (abs (vn.y) > 0.005) col = 0.4 * vec3 (0.5, 0.4, 0.3);\n    else col = BrickCol (vec2 (20. * (atan (qHit.z, qHit.x) / pi + 1.),\n       40. * qHit.y));\n  } else if (idObj == 3) {\n    col = vec3 (0.4, 0.4, 0.2);\n  } else if (idObj == 5) {\n    col = vec3 (1., 1., 0.5) * (0.75 + 0.25 * dot (rd, normalize (ltPos[0] - ro)));\n  } else if (idObj == 6) {\n    col = vec3 (1., 1., 0.5) * (0.75 + 0.25 * dot (rd, normalize (ltPos[1] - ro)));\n  }\n  if (idObj < 5) {\n    acDif = vec3 (0.);\n    acSpe = 0.;\n    for (int j = 0; j < 2; j ++) {\n      doLt = j;\n      ltDir = ltPos[j] - ro;\n      ltDistSq = dot (ltDir, ltDir);\n      ltDist = sqrt (ltDistSq);\n      ltDir /= ltDist;\n      dif = clamp (dot (vn, ltDir), 0., 1.);\n      sh = 0.;\n      if (dif > 0.) {\n\tsh = 1.;\n\td = 0.01;\n\tfor (int i = 0; i < 60; i ++) {\n\t  h = ObjDf (ro + ltDir * d);\n\t  sh = min (sh, 50. * h / d);\n\t  d += h;\n\t  if (d > ltDist) break;\n\t}\n\tdif *= sh;\n      }\n      atten = 1. / (0.1 + ltDistSq);\n      acDif += atten * dif;\n      acSpe += atten * sh * pow (clamp (dot (reflect (rd, vn), ltDir), 0., 1.), 16.);\n    }\n    col = (0.4 + 0.2 * acDif) * col + 0.03 * acSpe * vec3 (1.);\n  }\n  return col;\n}\n\nfloat GlowCol (vec3 ro, vec3 rd, float dstHit)\n{\n  vec3 ltDir;\n  float ltDist, wGlow;\n  wGlow = 0.;\n  for (int j = 0; j < 2; j ++) {\n    ltDir = ltPos[j] - ro;\n    ltDist = length (ltDir);\n    ltDir /= ltDist;\n    if (ltDist < dstHit) wGlow += pow (max (dot (rd, ltDir), 0.), 1024.) / ltDist;\n  }\n  return clamp (0.5 * wGlow, 0., 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn, roo, rds;\n  float dstHit, rLt, aLt;\n  int idObjT;\n  rotAng = 0.3 * tCur;\n  stPitch = 0.4;\n  rWid = 0.006;\n  rLt = 0.6 * rOut;\n  aLt = 0.1 * pi;\n  ltPos[0] = vec3 (rLt * cos (aLt), stPitch * (0.1 - 0.14 * cos (tCur)),\n     rLt * sin (aLt));\n  aLt = - 0.95 * pi;\n  ltPos[1] = vec3 (rLt * cos (aLt), stPitch * (-0.4 + 0.14 * sin (tCur)),\n     rLt * sin (aLt));\n  roo = ro;\n  idObj = -1;\n  doLt = -1;\n  dstHit = ObjRay (ro, rd);\n  if (idObj < 0) dstHit = dstFar;\n#ifdef REFBALL\n  if (idObj == 4 && dstHit < dstFar) {\n    ro += rd * dstHit;\n    rd = reflect (rd, ObjNf (ro));\n    ro += 0.01 * rd;\n    roo = ro;\n    idObj = -1;\n    dstHit = ObjRay (ro, rd);\n  }\n#endif\n  if (dstHit >= dstFar) {\n    col = vec3 (0., 0., 0.1);\n    rds = rd;\n    rds.xz = Rot2D (rds.xz, rotAng);\n    rds = (rds + vec3 (1.));\n    for (int j = 0; j < 10; j ++)\n       rds = 11. * abs (rds) / dot (rds, rds) - 3.;\n    col += min (1., 1.5e-6 * pow (min (16., length (rds)), 5.)) *\n       vec3 (0.7, 0.6, 0.6);\n  } else {\n    ro += rd * dstHit;\n    idObjT = idObj;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    col = ObjCol (ro, rd, vn);\n  }\n  col = mix (col, vec3 (1., 1., 0.5), GlowCol (roo, rd, dstHit));\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 canvas = iResolution.xy;\n  vec2 uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  vec4 mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  mat3 vuMat;\n  vec3 ro, rd;\n  vec2 vEl, vAz;\n  float az, el;\n  rOut = 0.5;\n  rIn = 0.2;\n  ro = - vec3 (0., 0.1, 0.9) * rOut;\n  az = 0.2;\n  el = 0.1;\n  if (mPtr.z > 0.) {\n    ro.z = clamp (ro.z + 0.8 * mPtr.x, - 0.99 * rOut, - 0.4 * rIn);\n    el = clamp (el + 3. * mPtr.y, -1.5, 1.5);\n  }\n  vEl = vec2 (cos (el), sin (el));\n  vAz = vec2 (cos (az), sin (az));\n  vuMat = mat3 (1., 0., 0., 0., vEl.x, - vEl.y, 0., vEl.y, vEl.x) *\n     mat3 (vAz.x, 0., vAz.y, 0., 1., 0., - vAz.y, 0., vAz.x);\n  rd = normalize (vec3 (uv, 1.5)) * vuMat;\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt2Gzt.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 276, 300, 300, 347], [349, 349, 374, 374, 553], [555, 555, 576, 576, 713], [715, 715, 748, 748, 775], [777, 777, 807, 807, 881], [1015, 1015, 1039, 1039, 1257], [1259, 1259, 1282, 1282, 1387], [1389, 1389, 1411, 1411, 3170], [3172, 3172, 3193, 3193, 3416], [3418, 3418, 3451, 3451, 3627], [3629, 3629, 3670, 3670, 5025], [5027, 5027, 5075, 5075, 5363], [5365, 5365, 5400, 5400, 6624], [6626, 6626, 6682, 6682, 7443]], "test": "valid"}
{"id": "ltB3zt", "name": "BadLand", "author": "kuvkar", "description": "Use mouse to control target position.\n\nAttempted to make \"inverse kinematics\" in shader. I'm turning each joint towards the target slightly at each iteration. It works ok-ish i think. \n", "tags": ["2d", "physics"], "likes": 23, "viewed": 1384, "published": "Public", "date": "1431610190", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n#define inf 999999.0\n\nvec2 rotate(vec2 point, float angle)\n{\n    float x = point.x; float y = point.y;\n    point.x = x * cos(angle) - y * sin(angle);\n    point.y = y * cos(angle) + x * sin(angle);\n    return point;\n}\n\nbool box2d(vec2 pos, vec2 uv, vec2 pivot, float angle, float w, float h)\n{\n    uv -= pos;\n    uv = rotate(uv, angle) + pivot;\n    \n    bool x = (w - uv.x) > 0.0 && (-w - uv.x) < 0.0;\n    bool y = (h - uv.y) > 0.0 && (-h - uv.y) < 0.0;\n    \n    return x && y;\n}\n\nvec2 angletovec(float angle)\n{\n    float xn = cos(angle);\n    float yn = sin(angle);\n    return vec2(xn, yn);\n}\n\nstruct Joint\n{\n    vec2 pos;\n    float w;\n    float h;\n    float angle;\n};\n\nvec2 endPoint(in Joint j)\n{\n    return j.pos + vec2(cos(-j.angle), sin(-j.angle)) * j.w * 2.0;\n}\n    \nbool drawJoint(in Joint j, vec2 uv)\n{\n    return box2d(j.pos, uv, vec2(-j.w, 0.0), j.angle, j.w, j.h);\n}\n\nvoid rotateJoint(inout Joint j1, in vec2 target, float amount)\n{\t\n    vec2 ep = j1.pos;\n    vec2 targetv = normalize(target - ep);\n    targetv.y *= -1.0;\n    // which way to turn?\n    // construct a vector normal to direction and check sign of dot product\n    float an = (j1.angle) + PI * 0.5;\n    vec2 norm = angletovec(an);\n    float turn = dot(norm, targetv);\n    float dir = turn > 0.0 ? 1.0 : -1.0;\n    \n    // turn\n    vec2 fwd = angletovec(j1.angle);\n    float d = clamp(dot(fwd, targetv), -1.0, 1.0);\n    float turnangle = acos(d);\n      \n    j1.angle += turnangle * dir * amount;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    fragColor = vec4(0.0);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.5);\n    float aspect = iResolution.x / iResolution.y;\n    uv.y /= aspect;\n    \n    float mx = iMouse.x / iResolution.x;\n    float my = iMouse.y / iResolution.y;\n    vec2 target = vec2(mx, my);\n    target -= vec2(0.5);\n    target.y /= aspect;\n\n    if(iMouse.wz == vec2(0.0))\n    {\n        target = vec2(sin(iTime) * 0.45, 0.1 + cos(iTime) * 0.15);\n    }\n    \n    const int JOINTS = 7;\n    Joint j[JOINTS];\n\t\n    j[0].pos = vec2(-0.0, -0.3);\n    j[0].w = 0.05;\n    j[0].h = 0.02;\n    j[0].angle = -PI * 0.5;\n    float fj = float(JOINTS);\n    \n    for (int i = 1; i < JOINTS; ++i)\n    {\n        j[i].pos = endPoint(j[i - 1]);\n        float r = (fj - float(i)) / fj;\n        j[i].w = 0.03;\n        j[i].h = 0.01 * r;\n    \tj[i].angle = -PI * 0.5;    \n    }\n\tconst int iter = 5;\n    const float weight = 0.35;\n    \n    for (int x = 0; x < iter; ++x)\n    {\t\n        for (int i = JOINTS - 1; i >= 1; --i)\n        {\n            j[i].pos = endPoint(j[i - 1]);\n            rotateJoint(j[i], target, weight * (float(i) / float(iter)));\n        }\n    }\n    \n    for (int i = 1; i < JOINTS; ++i)\n    {\n       j[i].pos = endPoint(j[i - 1]);\n    }\n\n    bool b = false;\n    for (int i = 0; i < JOINTS; ++i)\n    {\n        b = b || drawJoint(j[i], uv);\n    }\n    \n    fragColor = vec4(0.7, 0.1, uv.y + 0.3, 0.0);\n    fragColor -= vec4(b ? 1.0 : 0.0);\n    fragColor = max(fragColor, 0.0);\n    if(sin(uv.x * 17.0) * 0.01 - uv.y > 0.20)\n    {\n        fragColor = vec4(0.0);\n    }\n    \n    // target \"light\";\n    fragColor += 1.0 - smoothstep(length(uv - target), 0.0, 0.01);;\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltB3zt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 41, 79, 79, 235], [237, 237, 311, 311, 497], [499, 499, 529, 529, 610], [688, 688, 715, 715, 784], [790, 790, 827, 827, 894], [896, 896, 960, 960, 1486], [1489, 1489, 1546, 1546, 3203]], "test": "error"}
{"id": "ltBGDK", "name": "Very decomposed Sphere on curved", "author": "ManuManu", "description": "Tries with a decomposed sphere...\n\nMade on GlSlSandbox here : http://glslsandbox.com/e#25179.1", "tags": ["raymarching", "distortion", "fractals"], "likes": 2, "viewed": 1448, "published": "Public API", "date": "1432382959", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n\n// IT's strange, the version http://glslsandbox.com/e#25099.7\n// does not compile on my (cheap) desktop computer (without any error line)\n// but is ok on my old laptop...\n//\n// It looks like using a vec2 ( material , dist ) for the raymarching \n// is failing somewhere...\n//\n// Do you know why ?\n\n\n#define NB_ITER 256\n#define FAR \t100.\n\n\n//#define EDIT\n\nvec3 skyColor( vec2 uv)\n{\n\tvec3 col1 = vec3(.0, .4, .6);\n\tvec3 col2  = vec3(.6, .6,.4);\n\treturn mix (col1, col2, 1.-length(uv+vec2(.2, .3) ) / .5);\n}\nvec4 mapFloor ( vec3 pos )\n{\n\tvec3 col1 = vec3( 1., 0., 0.);\n\tvec3 col2 = vec3( 0., 1., 0.);\n\tfloat val = sign( fract( .25*pos.x) -.5 ) * sign( fract( .25*pos.z) -.5 );\n\tvec3 col =mix( col1, col2, val );\n\tfloat dist = pos.y;\n\treturn vec4( col, dist );\n}\n\nvec4 mapSphere( vec3 pos, float radius )\n{\n//\tfloat DEP_VAL =sin(time) +2.;\n\tfloat dist = length(  pos ) - radius;//+ .2*sin(DEP_VAL *pos.x + sin(5.*time)) * sin(DEP_VAL *pos.y+ cos(6.*time)) * sin(DEP_VAL *pos.z+ sin(time));\n\tvec3 col = vec3( 1.0, .2, .2 );\n\treturn  vec4( col, dist);\n}\n\n\nfloat Mylength( vec3 pos )\n{\n\treturn max(abs(pos.x), max( abs(pos.y), abs( pos.z)) );\n}\n\nfloat Mylength2( vec3 pos )\n{\n\treturn abs(pos.x) + abs(pos.y) + abs( pos.z);\n}\n\nvec4 mapCube( vec3 pos )\n{\n\t//vec4 ret = vec4( abs(atan (pos.x ) ) *abs(atan (pos.y ) ), .0, .0, 1.  );\n\t//vec4 ret = vec4(fract( pos.z ) > .5);\n\tvec3 col = vec3( .0, .9, .1);\n\tfloat dist = Mylength(  pos ) - 5.0;\n\treturn vec4( col, dist );\n}\n\n\nvec4 combine(vec4 val1, vec4 val2 )\n{\n\tif ( val1.w < val2.w ) return val1;\n\treturn val2;\n}\n\n\nvec4 subst( vec4 val1, vec4 val2 )\n{\n\tfloat dist = max(-val2.w, val1.w);\n\treturn vec4(vec3(val1), dist);\n}\n\n\nvec4 mapLotsOfSpheres( vec3 pos)\n{\n\tvec3 col = vec3(.3, .8, .2 );\n\tconst float radius=6.0;\n\tfloat dist = length( mod( pos+15., 30.)-15.) -radius;\n\treturn vec4( col, dist);\n}\nvec4 mapLotsOfCubes( vec3 pos)\n{\n\tvec3 col = vec3(.3, .8, .2 );\n\tconst float radius=6.0;\n\tfloat dist = Mylength( mod( pos+8., 16.)-8.) -radius;\n\treturn vec4( col, dist);\n}\n\nvec4 StrangeSphere( vec3 pos ) \n{\n\t//float move = sin(3.*time ) *.5 - 10.;\n\tfloat move = 10.;\n\tfloat rad = 10.;\n\tvec3 newPos = pos - vec3( .0+move, 5., 50.);\n\tvec4 val2 = mapSphere(newPos, rad );\n\tvec3 p = newPos;\n\t//float magicVal = 4.5 + 2.9*sin(1.*time);\n\tfloat magicVal = 2.5;\n\tfloat fact = .45;\n\t//if (val2.w < .1 )\t// Optimization, don't try the strange thing outside the sphere\n\tfor (int i = 0; i < 6; i++)\n\t{\n\t\tfloat t = float(i)*.11+0.004*iTime;\n\t\tfloat c = cos(t);\n\t\tfloat s = sin(t);\n\t\tmat2 m = mat2(c,-s,s,c);\n\t\tp.xy = m*p.xy;\n\t\t\t      \n\t\trad *= fact;\n\t\tp.x = p.x - rad*2.;\n\t\tvec3 p2 = p;\n\t\tp2.xzy=mod (p.xzy+rad, rad*magicVal) -rad;\n\t\t//p2.z=mod (p.z+rad, rad*2.5) -rad;\n\t\t//p2=mod (p+rad, rad*2.5) -rad;\n\n\t\t//vec3 p2 = p;\n\t\tvec4 sph = mapSphere( p2, rad );\n\t\t//val2= combine(val2, sph);\n\t\tval2 = subst(val2, sph);\n\t\t//val2 = sph;\n\t}\n\treturn val2;\n}\n\n\nvec4 map( vec3 pos)\n{\n\tvec4 ret = mapFloor( pos );\n\n\tvec4 res = combine( ret, StrangeSphere(pos));\n\treturn res;\n}\n\nfloat ambientOcclusion(vec3 pos, vec3 norm)\n{\n    const int steps = 3;\n    const float delta = 0.50;\n\n    float a = 0.0;\n    float weight = 1.0;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta; \n        a += weight*(d - map(pos + norm*d).w);\n        weight *= 0.5;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k) {\n    float sh = 1.0;\n    float t = mint;\n    float h = 0.0;\n    for(int i = 0; i < 15; i++) {\n        if(t > maxt) continue;\n        h = map(ro + rd * t).w;\n        sh = min(sh, k * h / t);\n        t += h;\n    }\n    return sh;\n}\n\nvec2 rot(vec2 r, float a) {\n\treturn vec2(\n\t\tcos(a) * r.x - sin(a) * r.y,\n\t\tsin(a) * r.x + cos(a) * r.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ( fragCoord.xy / iResolution.xy );\n\tuv -= .5;\n\tuv.x *= iResolution.x / iResolution.y;\n\t//uv.x += cos( uv.x)*3.02;\n\t//float fish_eye =  -length(uv)*1.+ sin(time);\n\t//float fish_eye = sin(5.*uv.x) + sin(5.*uv.y) + 1.;\n\tfloat fish_eye =  0.;\n\tvec3 dir = vec3( uv, 1.0 + fish_eye);\n\tdir = normalize(dir);\n\t\n\tvec3 pos = vec3( .0, 8.1, .0);\n\t//vec3 pos = vec3( 20.*sin(time), 8.1, 20.*cos(time));\n\t\n\tfloat nbIterF = 0.;\n\tvec4 result;\n\tfor (int i =0; i < NB_ITER; i++)\n\t{\n\t\tresult = map( pos );\n\t\tpos += result.w * dir;\n\t\tif ( (pos.z > FAR) || (abs(result.w) < .001)) break;\n\t\t//if ( (pos.z > FAR)) break;\n\t\tnbIterF += 1.0;\n\t\tdir.xy=rot(dir.xy,result.w*0.021);\n\t\tdir.yz=rot(dir.yz,result.w*0.01);\n\t\tdir.zx=rot(dir.zx,result.w*0.01);\n\t}\n\tvec3 col = result.xyz;\n\tif ( pos.z> FAR ) \n\t{\n\t\tcol = skyColor(uv);\n\t}\n\telse\n\t{\n\t\t//vec3 lightPos = vec3(10.* sin(3.*time) + 10., 8.5, 10.*cos(3.*time) + 30. );\n\t\tvec3 lightPos = vec3(1.* sin(3.*iTime) + 10., 8.5, 1.*cos(3.*iTime) + 30. );\n\t\tvec3 light2Pos = normalize( lightPos - pos);\n\t\tvec3 eps = vec3( .1, .0, .0 );\n\t\tvec3 n = vec3( result.w - map( pos - eps.xyy ).w,\n\t\t\t       result.w - map( pos - eps.yxy ).w,\n\t\t\t       result.w - map( pos - eps.yyx ).w );\n\t\tn = normalize(n);\n\t\t//col =abs(n);\n\t\t\t\t\n\t\tfloat lambert = max(.0, dot( n, light2Pos));\n\t\tcol *= vec3(lambert);\n\t\t\n\t\t//vec3 light = vec3( sin( time ), 20 , cos(time) );\n\t\t//col = col* vec3(dot ( -dir, n ));\n\t\t\n\t\t// specular : \n\t\tvec3 h = normalize( -dir + light2Pos);\n\t\tfloat spec = max( 0., dot( n, h ) );\n\t\tcol += vec3(pow( spec, 16.));\n\t\tcol *= ambientOcclusion( pos, n );\n\t\tcol *= softshadow(pos, light2Pos, .02, 5., 14. );\n\t\t//col = vec3(ambientOcclusion( pos, n ));\n\t\t\n\t}\n\t//vec3 col = vec3( nbIterF/64. );\n\tfragColor= vec4( col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltBGDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[341, 357, 382, 382, 506], [507, 507, 535, 535, 760], [762, 762, 804, 837, 1049], [1052, 1052, 1080, 1080, 1139], [1141, 1141, 1170, 1170, 1219], [1221, 1221, 1247, 1365, 1463], [1466, 1466, 1503, 1503, 1556], [1559, 1559, 1595, 1595, 1665], [1668, 1668, 1702, 1702, 1841], [1842, 1842, 1874, 1874, 2013], [2015, 2015, 2048, 2089, 2877], [2880, 2880, 2901, 2901, 2993], [2995, 2995, 3040, 3040, 3342], [3344, 3344, 3428, 3428, 3656], [3658, 3658, 3685, 3685, 3764], [3767, 3767, 3824, 3824, 5574]], "test": "valid"}
{"id": "ltBGzt", "name": "Distance field drawing methods", "author": "104", "description": "Exploring different ways to draw a filled AA circle. Most people are using smoothstep() to draw filled 2D geometry but I also like other falloff curves, especially 1/d (shown by default).", "tags": ["2d", "distancefield", "circle"], "likes": 25, "viewed": 754, "published": "Public", "date": "1431355309", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Recommended:\n// ---------------------\n//#define SMOOTHSTEP\n#define DIV\n//#define SIGN\n\n// Not recommended:\n// ---------------------\n//#define POW\n//#define FLOOR\n\n\nvec4 circle(vec2 uv, vec2 origin, float radius, vec4 color)\n{\n    float d = length(uv - origin) - radius;// distance from uv to the edge of the circle.\n    \n    // VERY VIABLE:-------------------------\n    \n    // using smoothstep() is idiomatic, fast, and clean (no bleeding).\n    #ifdef SMOOTHSTEP\n    float a = 1.0 -smoothstep(0.,0.006, d);\n    #endif\n    \n    // using a divide gives a very long falloff, so it bleeds which I think is pretty.\n    #ifdef DIV\n    const float amount = 300.0;// bigger number = more accurate / crisper falloff.\n    float a = clamp(1.0 / (clamp(d, 1.0/amount, 1.0)*amount), 0.,1.);\n    #endif\n\n    // using sign() which gives 1 50% AA value. it's cheap, but kind of ugly.\n    #ifdef SIGN\n\tconst float epsilon = 0.0007;\n    if(abs(d) <= epsilon) d = 0.;// is there a way to optimize this out?\n    float a = (sign(-d) + 1.0) / 2.0;\n    #endif\n\n    // NOT SO VIABLE:-------------------------\n    \n    // using pow() to crispen edges. pretty, but I think smoothstep has about the same effect and is cheaper..\n    #ifdef POW\n    float a = pow(clamp(1.0 - d,0.,1.),200.0);\n    #endif\n    \n    // you can also use floor() to create a sharp edge, but you'll have to first\n    // go through the DIV method above. floor just eliminates the smoothness and bleeding.\n    // Not very useful...\n    #ifdef FLOOR\n    const float amount = 100000.0;// bigger number = more accurate\n    float a = floor( clamp(1.0 / (clamp(d, 1.0/amount, 1.0)*amount), 0.,1.) );\n    #endif\n\n    return vec4(color.rgb, color.a * a);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.yy;\n    \n    // background color\n    fragColor = vec4(1.0);\n\n    // red circle\n    vec4 c1 = circle(uv, vec2(0.5 +((sin(iTime*0.75)+1.)/3.), 0.5), 0.3, vec4(.85,0.,0.,1));\n\tfragColor = mix(fragColor, c1, c1.a);\n\n    // blue circle\n    vec4 c2 = circle(uv, vec2(0.5 +((cos(iTime*0.85)+1.)/2.), 0.5), 0.2, vec4(.2,0.,0.8,1));\n\tfragColor = mix(fragColor, c2, c2.a);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltBGzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[90, 167, 228, 228, 1698], [1701, 1701, 1758, 1758, 2161]], "test": "valid"}
{"id": "ltj3DK", "name": "solar flare in starfield", "author": "rcread", "description": "modified bsdbeard/nimitz shader to be all procedural and added my own starfield", "tags": ["2d", "stars", "flare"], "likes": 25, "viewed": 1257, "published": "Public", "date": "1432672276", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by randy read - rcread/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//\tmodified to be all procedural and added my own starfield\n//\t\tbsdbeard -- https://www.shadertoy.com/view/4d2XR1\n//\t\tnimitz -- https://www.shadertoy.com/view/lsSGzy\n\n//\thash22() from Dave_Hoskins -- https://www.shadertoy.com/view/ltfGDs\nvec2 hash22( vec2 p ) {\n\tp\t\t= fract( p * vec2( 5.3983, 5.4427 ) );\n    p\t\t+= dot( p.yx, p.xy + vec2( 21.5351, 14.3137 ) );\n\treturn fract( vec2( p.x * p.y * 95.4337, p.x * p.y * 97.597 ) );\n}\nfloat sum( vec2 p ) { return p.x + p.y; }\nfloat stars( vec2 p, float density, float brightness ) {\n\treturn 1. / ( 1. + brightness * exp( pow( 2., density ) * sum( hash22( p ) ) ) );\n}\nfloat noise( vec2 p ) {\n\treturn .5 + ( sin( p.x ) + sin( p.y  ) ) / 4.;\n}\nmat2 m2 = mat2( 0.80,  0.60, -0.60,  0.80 ) * 2.;\nfloat fbm( in vec2 p ) {\n\tfloat z\t\t=2.;\n\tfloat rz\t= -0.05;\n\tp\t\t\t*= 0.25;\n\tfor (int i= 0 ; i < 4 ; i++) {\n\t\trz\t\t+= abs( ( noise( p * vec2( .741, .0217 ) ) - 0.5 ) * 2. ) / z;\n\t\tz\t\t= z * 2.;\n\t\tp\t\t= p * 2. * m2;\n\t}\n\treturn rz;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat t\t\t= -iTime * .2; \n\tvec2 p\t\t= fragCoord;\n\tvec2 uv\t\t= p / iResolution.xy - 0.5;\n\tuv.x\t\t*= iResolution.x / iResolution.y;\n\tuv\t\t\t*= 15. * 0.1;\n\t\n\tfloat r\t\t= length( uv );\n\tfloat x\t\t= dot( normalize( uv ), vec2( .5, 0. ) ) + t;\n\tfloat y\t\t= dot( normalize( uv ), vec2( 0., .5 ) ) + t;\n \n    float val;\n    val\t\t\t= fbm( vec2( r + y * 4.5, r + x * 4.5 ) );\n\tval\t\t\t= smoothstep( 5. * .02 - .1, 10. + ( 5. * 0.02 - .1 ) + .001, val );\n\tval\t\t\t= sqrt( val );\n\t\n\tvec3 col\t= val / vec3( 4., 1., .3 );\n\tcol\t\t\t= 1. - col;\n\tcol\t\t\t= mix( col, vec3( 1. ), 5. - 266.667 * r );\n\tfloat a\t\t= col.x;\n    a\t\t\t= clamp( a, 0., 1. );\t//\tcomment out for smoky effect\n\tcol\t\t\t= clamp( col, 0., 1. );\n\n\t//fragColor.rgb = mix( vec3( stars( p, 5., .25 ) ), col, a );\n    fragColor.rgb = mix( vec3( clamp( pow( 1.3 * stars( p, 5., .25 ), 3. ), 0., 1. ) ), col, a );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltj3DK.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[294, 365, 388, 388, 555], [556, 556, 577, 577, 597], [598, 598, 654, 654, 739], [740, 740, 763, 763, 813], [864, 864, 888, 888, 1089], [1090, 1090, 1147, 1147, 1988]], "test": "valid"}
{"id": "ltjGRd", "name": "Café Wall", "author": "NBickford", "description": "A quick implementation of the Café Wall illusion - with another trick added. Also, antialiased!", "tags": ["2d", "opticalillusion", "antialiased", "quick"], "likes": 9, "viewed": 1201, "published": "Public API", "date": "1431566972", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ss 4\n#define pi 3.1415926535897\n#define rotation 1.\n\nfloat roundf(float v, float d){\n    return ceil(v/d-0.5)*d;\n}\n\n\nfloat checkerboard(vec2 uv){\n    vec2 p=mod(uv-vec2(0.5),1.0);\n    return mod(step(p.x,0.5)+step(p.y,0.5),2.0);\n}\n\nvec2 rot(vec2 uv, float r){\n    float cr=cos(r),sr=sin(r);\n    return vec2(cr*uv.x-sr*uv.y,sr*uv.x+cr*uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float tv=0.0;\n    float t=iTime*0.67;\n    \n    for(int xp=0;xp<ss;xp++){\n        for(int yp=0;yp<ss;yp++){\n            vec2 uv = 2.0*(fragCoord.xy-iResolution.xy*0.5+vec2(xp,yp)/float(ss))/iResolution.x;\n            uv*=4.0;\n\n            //Enable to counteract the Cafe Wall effect\n            //uv=rot(uv,0.01*rotation*sin(pi*t));\n\n\n            uv.x=uv.x-roundf(uv.y-0.25,0.5)*t;\n            float v=checkerboard(uv);\n\n            if(abs(roundf(uv.y,0.5)-uv.y)<0.01) v=0.5;\n                    tv+=v;\n        }\n    }\n    tv=tv/float(ss*ss);\n    fragColor=vec4(tv,tv,tv,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltjGRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 92, 92, 122], [125, 125, 153, 153, 238], [240, 240, 267, 267, 350], [352, 352, 409, 409, 991]], "test": "valid"}
{"id": "ltjGzd", "name": "ngRay2", "author": "netgrind", "description": "neat", "tags": ["fractal", "raycast", "cube", "sponge", "manger", "woah"], "likes": 8, "viewed": 1504, "published": "Public API", "date": "1431592253", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//By Cale Bradbury, 2015\n\n//how many itterations of the fractal\n#define loops 5.0\n\n//uncomment the line below to turn the sponge into the tradtional box\n//#define BOX\n\n//uncomment the line below to make shit magical\n//#define COLOR\n\n//fuck yeah, mirror that shit\n#define MIRROR\n\n// Base ray trace code via https://www.shadertoy.com/view/Xds3zN by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sphere( vec3 p, float s ){\n  return length(p)-s;\n}\n\nfloat qbox( vec3 p, float s )\n{\n  return length(max(abs(p)-vec3(s,s,s),0.0));\n}\n\nfloat box( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nvec2 kale(vec2 uv, float angle, float base, float spin) {\n\tfloat a = atan(uv.y,uv.x)+spin;\n\tfloat d = length(uv);\n\ta = mod(a,angle*2.0);\n\ta = abs(a-angle);\n\tuv.x = sin(a+base)*d;\n\tuv.y = cos(a+base)*d;\n    return uv;\n}\n\nvec2 map( in vec3 pos )\n{\n    float size = 3.5;\n    #ifdef BOX\n    float res = qbox(pos,size);\n    #else\n     float res = sphere(pos,size);\n    #endif\n    pos+=size;\n    \n    float t = iTime;\n    for(float i = 0.0; i<loops;i++){\n        size /= 3.0;\n        \n        float b = box(opRep(pos,vec3(size*6.,size*6.,0)),vec3(size,size,10.));\n        res = opS(res,b);\n        b = box(opRep(pos,vec3(size*6.,0.,size*6.)),vec3(size,10.,size));\n        res = opS(res,b);\n        b = box(opRep(pos,vec3(0.,size*6.,size*6.)),vec3(10.,size,size));\n        res = opS(res,b);\n    }\n\t\n    return vec2(res,1.0);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 0.;\n    float tmax = 20.0;\n    \n#if 0\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n\tfloat precis = 0.01;\n    float t = tmin;\n    float m = 0.0;\n    for( int i=0; i<30; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.;\n    return vec2( t, m );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<8; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 render( in vec3 ro, in vec3 rd, float c )\n{ \n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    vec3 col = vec3(c);\n    if( m>-.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // lighitng        \n        float occ = 0.5;//calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = .5;//clamp( 0.5+0.5*nor.y, 0.5, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.5, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.5,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.5, 1.0 ),16.0);\n        \n      // dif *= softshadow( pos, lig, 0.01, .5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 brdf = vec3(0.0);\n        brdf += 1.20*dif;\n\t\tbrdf += 1.20*spe*dif;\n        brdf += 0.30*amb*occ;\n        brdf += 0.40*dom*occ;\n        brdf += 0.30*bac*occ;\n        brdf += 0.40*fre*occ;\n\t\t//brdf += 0.02;\n\t\tcol = brdf;\n        col*=(1.0-res.x*.11);\n        \n    \t//col = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0005*t*t ) );\n\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    #ifdef MIRROR\n    p.x = -abs(p.x);\n    #endif\n\t\t \n\tfloat time = 15.0 + iTime*.5;\n\tfloat camDist = 3.;\n\t// camera\t\n\tvec3 ro = vec3(cos(time)*camDist+camDist+.1,0.,sin(time)*camDist+camDist+.1);\n    //vec3( -0.5+camDist*cos(0.1*time), 5.0, 0.5 + camDist*sin(0.1*time) );\n\tvec3 ta = vec3( -1.001, -1., -1. );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, time );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.5) );\n\n    float bg =  q.y*.2+.1;\n    // render\t\n    vec3 col = render( ro, rd,bg );\n    col = vec3(mix(col.r,bg,1.0-col.r));\n\n    col *= 1.-length((q*2.-1.))*.3;\n    #ifdef COLOR\n    col = sin(col*vec3(10.,6.,15.)*(sin(time*.35)*.5+2.)+time)*.5+.5;\n    #endif\n    \n\tcol = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltjGzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[279, 458, 491, 491, 517], [519, 519, 549, 549, 582], [584, 584, 614, 614, 643], [645, 645, 686, 686, 779], [781, 781, 813, 813, 837], [839, 839, 870, 870, 918], [920, 920, 949, 949, 1045], [1047, 1047, 1104, 1104, 1265], [1267, 1267, 1292, 1292, 1866], [1868, 1868, 1908, 1908, 2494], [2496, 2496, 2570, 2570, 2830], [2832, 2832, 2864, 2864, 3085], [3087, 3087, 3129, 3129, 3428], [3430, 3430, 3478, 3478, 4722], [4724, 4724, 4776, 4776, 4953], [4955, 4955, 5012, 5012, 5900]], "test": "valid"}
{"id": "ltS3W3", "name": "KIFS Menger", "author": "dom767", "description": "A quick replication of a KIFS Menger system I'm working on, just testing out GLSL, based on original code from Kali + Knighty + some ideas from Syntopia", "tags": ["fractal", "menger", "kifs"], "likes": 18, "viewed": 821, "published": "Public", "date": "1432938505", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// http://www.fractalforums.com/movies-showcase-%28rate-my-movie%29/very-rare-deep-sea-fractal-creature/\n\nconst int Iterations=6;\nconst float detail=.005;\nconst vec3 lightdir=-vec3(0.5,1.,0.5);\n\nmat2 rot;\n\nfloat de(vec3 p); \nvec4 getColour(vec3 p);\nvec4 lerp(vec4 col1, vec4 col2, float amt);\n\nvec3 normal(vec3 p) {\n\tvec3 e = vec3(0.0,detail,0.0);\n\t\n\treturn normalize(vec3(\n\t\t\tde(p+e.yxx)-de(p-e.yxx),\n\t\t\tde(p+e.xyx)-de(p-e.xyx),\n\t\t\tde(p+e.xxy)-de(p-e.xxy)\n\t\t\t)\n\t\t);\t\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<48; i++ )\n    {\n        float h = de(ro + rd*t);\n\t\th = max( h, 0.0 );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.01, 0.5 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec4 light(in vec3 p, in vec3 dir,float d)\n{\n\tvec4 lightCol;\n\tvec3 ldir=normalize(lightdir);\n\tvec3 n=normal(p);\n\tfloat sh=softshadow(p,-ldir,1.,20.);\n\tfloat diff=max(0.,dot(ldir,-n));\n\tvec3 r = reflect(ldir,n);\n\tfloat spec=max(0.,dot(dir,-r));\n\tvec3 ray = .8*d*((0.4*p-3.*r)+d*vec3(1.0,0.95,0.85));\n//\tlightCol = texture(iChannel0,ray.xz+ray.xy);\n    lightCol = getColour(p);\n\treturn 3.0*lightCol*diff*sh+pow(spec,30.)*.5*sh+.15*max(0.,dot(normalize(dir),-n));\t\n\t\t}\n\nvec4 raymarch(in vec3 from, in vec3 dir)\n{\n\tfloat st,d=1.0,totdist=st=0.;\n\tvec3 p;\n\tvec4 col;\n    float mind=100.;\n\tfor (int i=0; i<90; i++) \n\t{\n\t\tif (d>detail && totdist<150.)\n\t\t{\n\t\t\tp=from+totdist*dir;\n\t\t\td=de(p);\n            mind = min(d, mind);\n\t\t\ttotdist+=d;\n\t\t}\n\t}\n\tvec4 backg=lerp(vec4(1.0,0.9,0.7,1),vec4(0.2,0.4,0.5,1),1.-mind);\n\tif (d<detail) {\n\t\tcol=light(p, dir,d); \n\t} else { \n\t\tcol=backg;\n\t}\n\tcol = col;//mix(col, backg, 1.0-exp(-.000025*pow(totdist,3.5)));\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t=iTime*.3;\n\tvec2 uv = fragCoord.xy / iResolution.xy*2.-1.;\n\tuv.y*=iResolution.y/iResolution.x;\n\n    vec3 from=vec3(10.*cos(iTime*0.3),-.7,5.*sin(iTime*0.3));\n    vec3 to = normalize(vec3(0.,0.,0.) - from);\n\tvec3 dir=normalize(vec3(uv*.7,1.));\n    vec3 up = vec3(0.,1.,0.);\n    vec3 right = normalize(cross(to, up));\n    up = normalize(cross(right, to));\n    mat3 rot3 = mat3(right.x,right.y,right.z,up.x,up.y,up.z,to.x,to.y,to.z);\n    dir *= rot3;\n\n\tvec4 col=raymarch(from,dir); \n\tfragColor = col;\n}\n\nmat3 MakeRPY(float roll, float pitch, float yaw)\n{\n    float cp = cos(pitch);\n    float sp = sin(pitch);\n    float sr = sin(roll);\n    float cr = cos(roll);\n    float sy = sin(yaw);\n    float cy = cos(yaw);\n\n    return mat3(cp * cy, (sr * sp * cy) - (cr * sy), (cr * sp * cy) + (sr * sy),\n                cp * sy, (sr * sp * sy) + (cr * cy), (cr * sp * sy) - (sr * cy),\n                -sp, sr * cp, cr * cp);\n}\n\nfloat de(vec3 p) {\n    vec3 rotAxis = vec3(0,1,0);\n//\tmat3 rot = rotationMatrix3(rotAxis, iTime*5.);\n\tp*=vec3(0.4,0.4,0.4);\n\tvec3 offset = vec3(1,1,1);\n\tfloat scale = 3. + 0.3 * sin(iTime * 0.084);\n    float rotx = 5.0 * sin(iTime * 0.01);\n    float roty = 5.0 * sin(iTime * 0.0057);\n    float rotz = 5.0 * sin(iTime * 0.0266);\n    mat3 rot = MakeRPY(rotx,roty,rotz);\n\n\tfor (int i=0; i<Iterations; i++) {\n        p*=rot;\n\t\tfloat tmp;\n\t\t\n\t\tp = abs(p);\n\t\tif (p.x-p.y<0.) {tmp=p.y;p.y=p.x;p.x=tmp;}\n\t\tif (p.x-p.z<0.) {tmp=p.z;p.z=p.x;p.x=tmp;}\n\t\tif (p.y-p.z<0.) {tmp=p.z;p.z=p.y;p.y=tmp;}\n\n\t\tp.z -= 0.5*offset.z*(scale-1.)/scale;\n\t\tp.z = -abs(-p.z);\n\t\tp.z += 0.5*offset.z*(scale-1.)/scale;\n\n\t\tp.xy = scale*p.xy - offset.xy*(scale-1.);\n\t\tp.z = scale*p.z;\n\t}\n    vec3 d = abs(p) - vec3(1.,1.,1.);\n    float distance = min(max(d.x, max(d.y, d.z)),0.) + length(vec3(max(d.x,0.),max(d.y,0.), max(d.z,0.)));\n    distance *= pow(scale, -float(Iterations));\n    return distance;\n}\n\nvec4 lerp(vec4 col1, vec4 col2, float amt)\n{\n    amt = clamp(amt,0.,1.);\n    return col1*amt + col2*(1.-amt);\n}\n\nvec4 getColour(vec3 p) {\n\tp*=vec3(0.4,0.4,0.4);\n\tvec3 offset = vec3(1,1,1);\n\tfloat scale = 3. + 0.3 * sin(iTime * 0.084);\n    float rotx = 5.0 * sin(iTime * 0.01);\n    float roty = 5.0 * sin(iTime * 0.0057);\n    float rotz = 5.0 * sin(iTime * 0.0266);\n    mat3 rot = MakeRPY(rotx,roty,rotz);\n\n    float colour=1000000.;\n\n\tfor (int i=0; i<Iterations; i++) {\n        p*=rot;\n\t\tfloat tmp;\n\t\t\n\t\tp = abs(p);\n\t\tif (p.x-p.y<0.) {tmp=p.y;p.y=p.x;p.x=tmp;}\n\t\tif (p.x-p.z<0.) {tmp=p.z;p.z=p.x;p.x=tmp;}\n\t\tif (p.y-p.z<0.) {tmp=p.z;p.z=p.y;p.y=tmp;}\n\n\t\tp.z -= 0.5*offset.z*(scale-1.)/scale;\n\t\tp.z = -abs(-p.z);\n\t\tp.z += 0.5*offset.z*(scale-1.)/scale;\n\n\t\tp.xy = scale*p.xy - offset.xy*(scale-1.);\n\t\tp.z = scale*p.z;\n\n        colour = min(colour, length(p)-0.7);\n    }\n    \n    return lerp(vec4(0.21,0.35,0.66,1.), vec4(0.76,0.65,0.21,1.), colour);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltS3W3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 294, 315, 315, 469], [471, 471, 536, 536, 775], [777, 777, 821, 821, 1242], [1244, 1244, 1286, 1286, 1730], [1732, 1732, 1789, 1789, 2297], [2299, 2299, 2349, 2349, 2710], [2712, 2712, 2730, 2730, 3681], [3683, 3683, 3727, 3727, 3794], [3796, 3796, 3820, 3820, 4632]], "test": "error"}
{"id": "ltS3WG", "name": "Fire rose", "author": "Lallis", "description": "Creating fire with some simplex fbm. Maybe try out some different colors ? ;)", "tags": ["fbm", "fire", "simplex"], "likes": 10, "viewed": 404, "published": "Public", "date": "1431816720", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nfloat noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,128.852))) * 43758.5453)*2.0-1.0;\n}\n\nfloat simplex3D(vec3 p)\n{\n\t\n\tfloat f3 = 1.0/3.0;\n\tfloat s = (p.x+p.y+p.z)*f3;\n\tint i = int(floor(p.x+s));\n\tint j = int(floor(p.y+s));\n\tint k = int(floor(p.z+s));\n\t\n\tfloat g3 = 1.0/6.0;\n\tfloat t = float((i+j+k))*g3;\n\tfloat x0 = float(i)-t;\n\tfloat y0 = float(j)-t;\n\tfloat z0 = float(k)-t;\n\tx0 = p.x-x0;\n\ty0 = p.y-y0;\n\tz0 = p.z-z0;\n\t\n\tint i1,j1,k1;\n\tint i2,j2,k2;\n\t\n\tif(x0>=y0)\n\t{\n\t\tif(y0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } // X Y Z order\n\t\telse if(x0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } // X Z Y order\n\t\telse { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }  // Z X Z order\n\t}\n\telse \n\t{ \n\t\tif(y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } // Z Y X order\n\t\telse if(x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } // Y Z X order\n\t\telse { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } // Y X Z order\n\t}\n\t\n\tfloat x1 = x0 - float(i1) + g3; \n\tfloat y1 = y0 - float(j1) + g3;\n\tfloat z1 = z0 - float(k1) + g3;\n\tfloat x2 = x0 - float(i2) + 2.0*g3; \n\tfloat y2 = y0 - float(j2) + 2.0*g3;\n\tfloat z2 = z0 - float(k2) + 2.0*g3;\n\tfloat x3 = x0 - 1.0 + 3.0*g3; \n\tfloat y3 = y0 - 1.0 + 3.0*g3;\n\tfloat z3 = z0 - 1.0 + 3.0*g3;\t\n\t\t\t\t \n\tvec3 ijk0 = vec3(i,j,k);\n\tvec3 ijk1 = vec3(i+i1,j+j1,k+k1);\t\n\tvec3 ijk2 = vec3(i+i2,j+j2,k+k2);\n\tvec3 ijk3 = vec3(i+1,j+1,k+1);\t\n            \n\tvec3 gr0 = normalize(vec3(noise3D(ijk0),noise3D(ijk0*2.01),noise3D(ijk0*2.02)));\n\tvec3 gr1 = normalize(vec3(noise3D(ijk1),noise3D(ijk1*2.01),noise3D(ijk1*2.02)));\n\tvec3 gr2 = normalize(vec3(noise3D(ijk2),noise3D(ijk2*2.01),noise3D(ijk2*2.02)));\n\tvec3 gr3 = normalize(vec3(noise3D(ijk3),noise3D(ijk3*2.01),noise3D(ijk3*2.02)));\n\t\n\tfloat n0 = 0.0;\n\tfloat n1 = 0.0;\n\tfloat n2 = 0.0;\n\tfloat n3 = 0.0;\n\n\tfloat t0 = 0.5 - x0*x0 - y0*y0 - z0*z0;\n\tif(t0>=0.0)\n\t{\n\t\tt0*=t0;\n\t\tn0 = t0 * t0 * dot(gr0, vec3(x0, y0, z0));\n\t}\n\tfloat t1 = 0.5 - x1*x1 - y1*y1 - z1*z1;\n\tif(t1>=0.0)\n\t{\n\t\tt1*=t1;\n\t\tn1 = t1 * t1 * dot(gr1, vec3(x1, y1, z1));\n\t}\n\tfloat t2 = 0.5 - x2*x2 - y2*y2 - z2*z2;\n\tif(t2>=0.0)\n\t{\n\t\tt2 *= t2;\n\t\tn2 = t2 * t2 * dot(gr2, vec3(x2, y2, z2));\n\t}\n\tfloat t3 = 0.5 - x3*x3 - y3*y3 - z3*z3;\n\tif(t3>=0.0)\n\t{\n\t\tt3 *= t3;\n\t\tn3 = t3 * t3 * dot(gr3, vec3(x3, y3, z3));\n\t}\n\treturn 96.0*(n0+n1+n2+n3);\n\t\n}\n\nfloat fbm(vec3 p)\n{\n\tfloat f;\n    f  = 0.50000*simplex3D( p ); p = p*2.01;\n    f += 0.25000*simplex3D( p ); p = p*2.02; //from iq\n    f += 0.12500*simplex3D( p ); p = p*2.03;\n    f += 0.06250*simplex3D( p ); p = p*2.04;\n    f += 0.03125*simplex3D( p );\n\treturn f;\n}\n\nmat3 rot(vec3 ang)\n{\n\tmat3 x = mat3(1.0,0.0,0.0,0.0,cos(ang.x),-sin(ang.x),0.0,sin(ang.x),cos(ang.x));\n\tmat3 y = mat3(cos(ang.y),0.0,sin(ang.y),0.0,1.0,0.0,-sin(ang.y),0.0,cos(ang.y));\n\tmat3 z = mat3(cos(ang.z),-sin(ang.z),0.0,sin(ang.z),cos(ang.z),0.0,0.0,0.0,1.0);\n\treturn x*y*z;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n\tvec2 p = uv*2.0-1.0;\n\tp.x*=1.78;\n    p.x*=2.0;\n    p.x*=uv.y*uv.y+2.0;\n    p.x*=pow(uv.y,10.0*uv.y)+0.8;\n\tp.y-=1.0;\n\tuv.y-=0.2;\n\tfloat time = iTime*0.25;\n\tp.x+=fbm(vec3(time*0.1,uv)*0.5)*0.5;\n\tvec3 ro = vec3(0.0,-time*4.0,-2.0);\n\tvec3 rd = normalize(vec3(vec2(p.x,p.y-time*4.0),0.0)-ro);\n\tvec3 lp = vec3(0.0,-time*4.0-1.5,0.0);\n\tvec3 col = vec3(0.02, 0.005,0.001);\n\tif(length(p)<2.5) // don't waste resources on pixels that are behind the mask\n\t{\n\t\tfor(int i = 0; i<5; i++)\n\t\t{\t\n\t\t\tvec3 rp = ro+rd*float(i);\n\t\t\tfloat c = distance(rp,lp);\n\t\t\tfloat n = fbm(rp)*0.5+0.5;\n\t\t\tcol = col*(10.0*n/c)*(fbm(vec3(time*0.1))*0.5+1.0);\n\t\t\t\n\t\t}\n\t}\t\t//some color masks with fbm\n\tcol*=smoothstep(1.0,-1.0,uv.y-smoothstep(0.0,1.0,fbm(vec3(vec2(p.x,uv.y*1.0-time*2.0),time)*1.0)*2.0));\n\tcol*=smoothstep(1.0,-1.0,uv.y-smoothstep(0.0,1.0,fbm(vec3(vec2(p.x+100.0,uv.y*1.0-time*1.5),time)*2.0)*2.0));\n\tcol*=smoothstep(1.0,-1.0,uv.y-smoothstep(0.0,4.0,fbm(vec3(vec2(p.x+200.0,uv.y*1.0-time*1.0),time)*2.0)*2.0));\n\tcol*=smoothstep(2.5,0.0,length(p)); //mask the edges\n\tcol*=vec3(1.0,1.0,100.0*smoothstep(0.0,-1.0,uv.y-p.x*p.x*0.1)); //blue hue bottom\n\tcol = clamp(col, 0.0,1.0);\n\n    col*=1.0+smoothstep(0.5,0.2,length((uv*2.0-1.0)*vec2(.75,1.0)+vec2(0.0,1.2)))*2.0; //stronger base for the flame\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltS3WG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 49, 49, 130], [132, 132, 157, 157, 2282], [2284, 2284, 2303, 2303, 2549], [2551, 2551, 2571, 2571, 2834], [2836, 2836, 2890, 2890, 4239]], "test": "valid"}
{"id": "ltS3Wy", "name": "Broken - Mandelbrot", "author": "TomHodson", "description": "A really simple Mandelbrot shader", "tags": ["2d"], "likes": 3, "viewed": 570, "published": "Public", "date": "1431877255", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//map screen space to world space\nvec2 screen_map(vec2 uv, vec2 center, vec2 zoom) {\n    return ((uv - vec2(0.5,0.5)) * zoom) - center;\n}\n\n//raise a complex number to an arbitrary power then add a constant\nvec2 power_add(vec2 z, float power, vec2 c) {\n    float r = length(z);\n    float t = atan(z.y, z.x);\n    return vec2(pow(r,power)*cos(power*t) + c.x, pow(r,power)*sin(power*t) + c.y);\n}\n\n//square a complex number just using components then add a constant\nvec2 square_add(vec2 z, vec2 c) {\n \treturn vec2((z.x*z.x - z.y*z.y) + c.x, (2.0 * z.y * z.x) + c.y);\n}\n\n//calculate if the given point is in the mandelbrot set\nfloat mandelbrot(vec2 c) {\n    \n \tconst float power = 2.0;// + (0.1 * iTime);\n   \tconst float limit = 2.0;// choose a limit of 2 becuase the point is guranteed to diverge once |z| > 2\n    vec2 z = c;\n    float escape = 0.0;\n    \n    for(int i = 0; i < 600; i++)\t{\n        \n        z = square_add(z, c);    \n        //z = power_add(z, power, c);\n        \n        if(length(z) > limit) {\n            //add a fractional part to the escape time to make the colours smoother\n            //based on the observation that the recursion formula is asymptopically just squaring\n            escape =  float(i) - log(log(length(z))/ log(limit)) / log(power) ;//float(i);\n            break;\n        }\n    }  \n    return escape;\n}\n\n//average the pixel value over an area\nfloat average_mandelbrot(vec2 c, float zoom) {\n  vec2 p = zoom / (iResolution.xy * 1.0);  \n float val = 3.0*mandelbrot(c) + mandelbrot(c + p * vec2(1.0, 1.0)) + mandelbrot(c + p * vec2(1.0, -1.0))+ mandelbrot(c + p * vec2(-1.0, 1.0)) + mandelbrot(c + p * vec2(-1.0, -1.0));\n return val / 10.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //uv is a 2d vector represnting which pixel you're currently computing\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    float zoom = exp(-iTime / 2.0);\n    \n    vec2 center = mix(vec2(0.6, 0.0), vec2(0.236835, 0.812488), clamp(1.0 - exp(-iTime), 0.0, 1.0));\n    vec2 z = screen_map(uv, center, vec2(3.0,2.0) * zoom * 1.1);\n    \n    float escape = average_mandelbrot(z, zoom);\n    //float escape = mandelbrot(z);\n    \n    float Pi = 3.14159;\n    float x = escape / 50.0;\n    vec4 orange = vec4(0.8, 0.2,0.1, 1.0);\n    vec4 black = vec4(0.0, 0.0,0.0, 1.0);\n    \n    fragColor = mix(black, orange, x*1.0);\n  \n}", "image_inputs": [{"id": "4sf3zn", "previewfilepath": "/presets/webcam.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/webcam.png", "ctype": "webcam"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltS3Wy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 34, 84, 84, 137], [139, 206, 251, 251, 391], [393, 461, 494, 494, 563], [565, 621, 647, 647, 1337], [1339, 1378, 1424, 1424, 1673], [1676, 1676, 1733, 1808, 2343]], "test": "valid"}
{"id": "ltS3zd", "name": "2015/05/12", "author": "hughsk", "description": "Just mucking around a little.", "tags": ["2d", "sin"], "likes": 18, "viewed": 395, "published": "Public API", "date": "1431389823", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float n(float g) { return g * .5 + .5; }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n  vec2 p  = vec2(iResolution.x/iResolution.y, 1) * uv;\n  float a = atan(p.y, p.x);\n  float l = length(p);\n  vec3  c = vec3(0);\n\n  p = vec2(sin(a), cos(a))/l;\n\n  for (int i = 0; i < 3; i++) {\n    float mag = 0.0;\n    float t = iTime;// + float(i) * 0.05;\n\n    p.y += 0.425;\n\n    mag += n(cos(p.y * 1.5 + t * 5.));\n    mag += n(sin(p.x + t * 3.));\n    mag += n(cos(p.x * p.y));\n    mag *= 0.333;\n\n    c[i] = mag;\n  }\n\n  fragColor = vec4(1.0 - pow(c, vec3(0.4545)), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltS3zd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 40], [42, 42, 97, 97, 621]], "test": "valid"}
{"id": "Ml23Rc", "name": "003 Audio Spectrum Examples", "author": "nmarsden", "description": "Keys.. \nPress space to toggle between 'show all' and 'show selected' mode.  \nHold down 1-7 to 'select' one of 7 possible visualizations besides smiley\n\nPorted these old shadertoy examples https://github.com/notlion/audio-shadertoy/wiki/Shader-Examples", "tags": ["2d", "audio"], "likes": 3, "viewed": 241, "published": "Public", "date": "1431308363", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define PI 3.141592653589793\n\n\n// Radial Spectrum\nvoid radialSpectrum( out vec4 fragColor, in vec2 fragCoord )\n{\n  float u_aspect = iResolution.x / iResolution.y;\n\n  vec2 v_texcoord = fragCoord.xy / iResolution.xy;\n    \n  vec2 pos = vec2((v_texcoord.x * 2. - 1.) * u_aspect, v_texcoord.y * 2. - 1.);\n\n  float theta = abs(atan(pos.x, pos.y)) / PI * .75;\n  float amp = texture(iChannel0, vec2(theta, 0.25)).x;\n  float dist = distance(pos, vec2(0., 0.));\n  dist *= dist;\n\n  vec3 c1 = vec3(0., 0., 0.);\n  vec3 c2 = vec3(0., .5, .8);\n\n  float fade = float(amp > dist) * (dist / amp);\n\n  fragColor = vec4(mix(c1, c2, fade), 1.);\n}\n\n\n// Radial Spectrum Variation 2\nvoid radialSpectrumVariationTwo( out vec4 fragColor, in vec2 fragCoord )\n{\n  float u_aspect = iResolution.x / iResolution.y;\n  vec2 v_texcoord = fragCoord.xy / iResolution.xy;\n    \n  vec2 pos = v_texcoord * 2. - 1.;\n  pos *= vec2(u_aspect, 1.);\n  float theta = (atan(pos.y, pos.x) + PI) / (PI * 2.);\n  float dist = length(pos);\n  float amp = texture(iChannel0, vec2(dist, 0.25)).x;\n  amp = sqrt(amp);\n\n  float fade = float(amp > theta) * (theta / amp);\n\n  fragColor = vec4(mix(\n    vec3(0., .1, .1),\n    vec3(0., 1., .8),\n    fade\n  ), 1.);\n}\n\n\n// Circluar Audio Spectrum\nvoid circluarAudioSpectrum( out vec4 fragColor, in vec2 fragCoord )\n{\n  float u_aspect = iResolution.x / iResolution.y;\n  vec2 v_texcoord = fragCoord.xy / iResolution.xy;\n  vec2 u_mouse = iMouse.xy / iResolution.xy;\n    \n  vec2 center = vec2(.5, .5); \n\n  vec2 pos = vec2(v_texcoord.x*u_aspect, v_texcoord.y);\n  pos.x-=1.0;\n\n  float freq = texture(iChannel0, v_texcoord).x;\n\n  vec3 color = vec3(freq > v_texcoord.y) * (v_texcoord.y / freq);\n\n  float d = distance(pos, center); \n  float radiusSize = texture(iChannel0, vec2(.1,0)).x; \n  if(d > radiusSize && d < (radiusSize+.1))\n  {\n    fragColor = vec4(d, 1.0-u_mouse.x, 1.0-u_mouse.y, 1.0);\n  }\n  else\n  {\n    d=d*d*d;\n    fragColor = vec4((1.0-freq)*d, (1.0-u_mouse.x)*d, (1.0-u_mouse.y)*d, 1.0); \n  }\n}\n\n\n// Circluar Strip Reactor\nvoid circluarStripReactor( out vec4 fragColor, in vec2 fragCoord )\n{\n  float u_aspect = iResolution.x / iResolution.y;\n  vec2 v_texcoord = fragCoord.xy / iResolution.xy;\n  vec2 u_mouse = iMouse.xy / iResolution.xy;\n  float u_time = iTime;\n    \n  vec2 center = vec2(.5, .5); \n\n  vec2 pos = vec2(v_texcoord.x*u_aspect, v_texcoord.y);\n  //  pos.x-=1.0;\n  vec2 scaledMouse = vec2(u_mouse.x*u_aspect, u_mouse.y);\n\n  float freq = texture(iChannel0, v_texcoord).x;\n\n  vec3 color = vec3(freq > v_texcoord.y) * (v_texcoord.y / freq);\n\n  float d = distance(pos, scaledMouse); \n  float radiusSize = texture(iChannel0, vec2(.1,0)).x; \n  if(d > radiusSize && d < (radiusSize+abs(sin(u_time))))\n  {\n     fragColor = vec4(d, 1.0-u_mouse.x, 1.0-u_mouse.y, 1.0);\n  }\n  else\n  {\n    d=d*d*d;\n    float id = .5*exp(1.-d);\n    d = 0.41; \n    fragColor = vec4(id*d, id*d, id*d, 1.0); \n  }\n}\n\n// Reza Glowies\nvoid rezaGlowies( out vec4 fragColor, in vec2 fragCoord )\n{\n  float u_aspect = iResolution.x / iResolution.y;\n  vec2 v_texcoord = fragCoord.xy / iResolution.xy;\n  vec2 u_mouse = iMouse.xy / iResolution.xy;\n  float u_time = iTime;\n\n  vec2 center = vec2(.5, .5); \n  vec2 pos = vec2(v_texcoord.x*u_aspect, v_texcoord.y);\n  pos.x+=-1.0;\n  vec2 scaledMouse = vec2(u_mouse.x*u_aspect, u_mouse.y);\n\n  float freq = texture(iChannel0, v_texcoord).x;\n\n  float d = distance(pos, center);  \n  d*=1.3*abs(sin(.5));\n  d = 1.-d;\n\n  vec3 vignette = vec3(d,d,d);\n\n  float scalar = 10.0*texture(iChannel0, vec2(0,0)).x;; \n  float scalar2 = 10.0*texture(iChannel0, vec2(.1,0)).x;; \n  float scalar3 = 10.0*texture(iChannel0, vec2(.2,0)).x;; \n  float scalar4 = 10.0*texture(iChannel0, vec2(.3,0)).x;; \n  float scalar5 = 10.0*texture(iChannel0, vec2(.4,0)).x;; \n  float scalar6 = 10.0*texture(iChannel0, vec2(.5,0)).x;; \n  float scalar7 = 10.0*texture(iChannel0, vec2(.6,0)).x;; \n  float scalar8 = 10.0*texture(iChannel0, vec2(.7,0)).x;; \n  float scalar9 = 10.0*texture(iChannel0, vec2(.8,0)).x;; \n  float scalar10 = 10.0*texture(iChannel0, vec2(.9,0)).x;; \n  float scalar11 = 10.0*texture(iChannel0, vec2(1.0,0)).x;; \n\n  vec2 s = vec2(sin(scalar*pos.x+sin(u_time+scalar2)),cos(scalar*pos.y+cos(u_time+scalar3)));\n  float amp = distance(s,vec2(0.,0.));\n\n  fragColor = vec4(vignette/amp, 1.0); \n}\n\n\n// Radial Spectrum Variation 3\nvoid radialSpectrumVariationThree( out vec4 fragColor, in vec2 fragCoord )\n{\n  float u_aspect = iResolution.x / iResolution.y;\n  vec2 v_texcoord = fragCoord.xy / iResolution.xy;\n  vec2 u_mouse = iMouse.xy / iResolution.xy;\n  float u_time = iTime;\n\n  vec2 pos = v_texcoord * 2. - 1.;\n  pos *= vec2(u_aspect, 1.);\n\n  float theta = abs(atan(pos.x, pos.y) / PI);\n\n  float dist = length(pos);\n  dist -= distance(pos, vec2(-.5, .5));\n  dist -= distance(pos, vec2(.5, .5));\n  dist += distance(pos, vec2(-.5, -.5));\n  dist += distance(pos, vec2(.5, -.5));\n  dist = sqrt(dist) / 2.;\n\n  float amp = texture(iChannel0, vec2(dist, 0.)).x;\n  amp = sqrt(amp);\n\n  float fade = float(amp > theta && amp < theta * 1.4) * (theta / amp);\n\n  fragColor = vec4(mix(\n    vec3(0., .1, .1),\n    vec3(0., 1., .8),\n    fade\n  ), 1.);\n}\n\n\n// Reza Glowies 2\nvoid rezaGlowiesTwo( out vec4 fragColor, in vec2 fragCoord )\n{\n  float u_aspect = iResolution.x / iResolution.y;\n  vec2 v_texcoord = fragCoord.xy / iResolution.xy;\n  vec2 u_mouse = iMouse.xy / iResolution.xy;\n  float u_time = iTime;\n    \n  vec2 center = vec2(.5, .5); \n  vec2 pos = vec2(v_texcoord.x*u_aspect, v_texcoord.y);\n  pos.x+=-1.0;\n  vec2 scaledMouse = vec2(u_mouse.x*u_aspect, u_mouse.y);\n\n  float freq = texture(iChannel0, v_texcoord).x;\n\n  float d = distance(pos, center);  \n  d*=1.3*abs(sin(.5));\n  d = 1.-d;\n\n  vec3 vignette = vec3(d,d,d);\n\n  float scalar = 10.0*texture(iChannel0, vec2(0,0)).x;; \n  float scalar2 = texture(iChannel0, vec2(.1,0)).x;; \n  float scalar3 = texture(iChannel0, vec2(.2,0)).x;; \n  float scalar4 = 10.0*texture(iChannel0, vec2(.3,0)).x;; \n  float scalar5 = 10.0*texture(iChannel0, vec2(.4,0)).x;; \n  float scalar6 = 10.0*texture(iChannel0, vec2(.5,0)).x;; \n  float scalar7 = 10.0*texture(iChannel0, vec2(.6,0)).x;; \n  float scalar8 = 10.0*texture(iChannel0, vec2(.7,0)).x;; \n  float scalar9 = 10.0*texture(iChannel0, vec2(.8,0)).x;; \n  float scalar10 = 10.0*texture(iChannel0, vec2(.9,0)).x;; \n  float scalar11 = 10.0*texture(iChannel0, vec2(1.0,0)).x;; \n\n  vec2 s = vec2(sin(scalar*pos.x+sin(u_time+scalar4)),cos(scalar*pos.y+cos(u_time+scalar6)));\n  vec2 s2 = vec2(sin(s.x), cos(s.y));\n  float amp = distance(s2,vec2(scalar8,scalar8));\n\n\n//  float amp = distance(s,u_mouse);\n\n  fragColor = vec4(vignette/amp, 1.0); \n}\n\n\n\n// quasicrystal fractal\nvoid quasicrystalFractal( out vec4 fragColor, in vec2 fragCoord )\n{\n  float u_aspect = iResolution.x / iResolution.y;\n  vec2 v_texcoord = fragCoord.xy / iResolution.xy;\n  vec2 u_mouse = iMouse.xy / iResolution.xy;\n  float u_time = iTime;\n\n  vec2 pos = vec2((v_texcoord.x * 2. - 1.) * u_aspect, v_texcoord.y * 2. - 1.);\n\n  float theta = abs(atan(pos.x, pos.y)) / PI * .75;\n  float amp = texture(iChannel0, vec2(0.5, 0.3)).x;\n  float dist = distance(pos, vec2(0., 0.));\n  dist *= dist;\n\n  float fade = float(amp > dist) * (dist / amp);\n\n  vec2 resolution = vec2(2.0, 2.0);\n  vec2 p = pos * 12.4 * u_mouse.y*4.;\n  const float tot = PI * 3.00;\n  const float n = 16.0;\n  const float df = tot / n;\n  float c = 2.0  * 10. * u_mouse.x;\n  float t = u_time * 0.232646 * (theta/7. * u_mouse.x) * 1.2234 * (amp * 5.0);\n\n  if (n > 1.0) {\n    for (float phi = 0.0; phi < tot; phi += df){\n        c += cos(cos(phi) * p.x+ sin(phi) * p.y + t);\n    }\n  }\n  c /= n;\n  //c = c > 0.07 ? 0. : 0.9 ;\n\n  fragColor = vec4(c, c, c, 1.);\n}\n\n    \n// quasi 2\nvoid quasiTwo( out vec4 fragColor, in vec2 fragCoord )\n{\n  float u_aspect = iResolution.x / iResolution.y;\n  vec2 v_texcoord = fragCoord.xy / iResolution.xy;\n  vec2 u_mouse = iMouse.xy / iResolution.xy;\n  float u_time = iTime;\n\n  vec2 pos = vec2((v_texcoord.x * 2. - 1.) * u_aspect, v_texcoord.y * 2. - 1.);\n\n  float theta = abs(atan(pos.x, pos.y)) / PI * 1.75;\n  float amp = texture(iChannel0, vec2(0.25, 0.2)).x;\n  float dist = distance(pos, vec2(0., 0.));\n  dist *= dist;\n\n  float fade = float(amp > dist*.210) * (dist);\n\n  vec2 resolution = vec2(2.0, 2.0);\n  vec2 p = pos * 12.4 * u_mouse.y*4.;\n  const float tot = PI * 3.00;\n  const float n = 16.0;\n  const float df = tot / n;\n  float c = 2.0  * 10.0 * (u_mouse.x/100.0);\n  float t = u_time * 0.232646 * (theta/7. * u_mouse.x) * 1.42363* (amp * 5.0);\n\n  if (n > 1.0) {\n    for (float phi = 0.0; phi < tot; phi += df){\n        c += cos(cos(phi) * p.x+ sin(phi) * p.y + t) * fade;\n    }\n  }\n  c /= n;\n  c = c > 0.05 ? 1.0 : 0. ;\n\n  fragColor = vec4(c, c, c, 1.);\n}\n\n\n// quasi crystal variable editing\nvoid quasiCrystalVariableEditing( out vec4 fragColor, in vec2 fragCoord )\n{\n  float u_aspect = iResolution.x / iResolution.y;\n  vec2 v_texcoord = fragCoord.xy / iResolution.xy;\n  vec2 u_mouse = iMouse.xy / iResolution.xy;\n  float u_time = iTime;\n\n  vec2 pos = vec2((v_texcoord.x * 2. - 1.) * u_aspect, v_texcoord.y * 2. - 1.);\n\n  float theta = abs(atan(pos.x, pos.y)) / PI * .75;\n  float amp = 1.0;\n\n  vec2 resolution = vec2(2.0, 2.0);\n\n  //     this one |\n  vec2 p = pos * 20.6 *4.;\n  const float tot = PI * 3.00;\n\n  //     this one |\n  const float n = 10.0;\n  const float df = tot / n;\n  float c = 2.0  * 0.2;\n  float t = u_time * 0.232646 * 5.0;\n\n  if (n > 1.0) {\n    for (float phi = 0.0; phi < tot; phi += df){\n        c += cos(cos(phi) * p.x+ sin(phi) * p.y + t);\n    }\n  }\n  c /= n;\n  c = c > 0.07 ? 0. : 0.9 ;\n\n  fragColor = vec4(c, c, c, 1.);\n}\n\n\n// Smiley\nfloat circle(vec2 px_pos, vec2 pos, float radius){\n  return float(distance(px_pos, pos) < radius);\n}\nfloat ampAt(float pos){\n  return texture(iChannel0, vec2(pos, 0.)).x;\n}\n\nvoid smiley( out vec4 fragColor, in vec2 fragCoord )\n{\n  float u_aspect = iResolution.x / iResolution.y;\n  vec2 v_texcoord = fragCoord.xy / iResolution.xy;\n  vec2 u_mouse = iMouse.xy / iResolution.xy;\n  float u_time = iTime;\n\n  vec2 pos = (v_texcoord * 2. - 1.) * vec2(u_aspect, 1.);\n\n  float fade = 0.;\n  fade += circle(pos, vec2(0., 0.), .7 + ampAt(.6) * .2);\n  fade -= circle(pos, vec2(0., 0.), .5 + ampAt(.5) * .2);\n  fade -= float(pos.y > 0.);\n  fade = max(fade, circle(pos, vec2(-.5, .5), .1 + ampAt(.2) * .4));\n  fade = max(fade, circle(pos, vec2(.5, .5),  .1 + ampAt(.4) * .4));\n\n  fragColor = vec4(mix(\n    vec3(0.),\n    vec3(1., 1., 0.),\n    fade\n  ), 1.);\n}\n\n\nvoid showAll( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord.x *= 4.0;\n   \tfragCoord.y *= 2.0;\n    \n    if (fragCoord.x < iResolution.x) {\n        \n\t\tif (fragCoord.y > iResolution.y) {\n            fragCoord.y -= iResolution.y;\n \t\t\tradialSpectrum(fragColor, fragCoord);\n\t\t} else {\n\t\t\tradialSpectrumVariationThree(fragColor, fragCoord);\n\t\t}\n    } else if (fragCoord.x < iResolution.x * 2.0) {\n        fragCoord.x -= iResolution.x;\n        \n\t\tif (fragCoord.y > iResolution.y) {\n            fragCoord.y -= iResolution.y;\n\t    \tradialSpectrumVariationTwo(fragColor, fragCoord);\n        } else {\n\t\t\tquasicrystalFractal(fragColor, fragCoord);\n        }\n    } else if (fragCoord.x < iResolution.x * 3.0) {\n        fragCoord.x -= iResolution.x * 2.0;\n        \n\t\tif (fragCoord.y > iResolution.y) {\n            fragCoord.y -= iResolution.y;\n\t    \tcircluarAudioSpectrum(fragColor, fragCoord);\n        } else {\n\t\t\tquasiTwo(fragColor, fragCoord);\n        }\n    } else {\n        fragCoord.x -= iResolution.x * 3.0;\n        \n\t\tif (fragCoord.y > iResolution.y) {\n            fragCoord.y -= iResolution.y;\n\t    \tcircluarStripReactor(fragColor, fragCoord);\n        } else {\n\t\t\tsmiley(fragColor, fragCoord);\n        }\n    }\n}\n\nbool keyToggle( int ascii ) \n{\n\treturn (texture(iChannel1, vec2((0.5 + float(ascii)) / 256.0, 0.75)).x > 0.0);\n}\n\nbool keyPress( int ascii ) \n{\n\treturn (texture(iChannel1, vec2((0.5 + float(ascii)) / 256.0, 0.25)).x > 0.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // check keyboard\n    bool key_space = keyToggle(32);\n    bool key_1     = keyPress(49); \n    bool key_2     = keyPress(50); \n    bool key_3     = keyPress(51); \n    bool key_4     = keyPress(52); \n    bool key_5     = keyPress(53); \n    bool key_6     = keyPress(54); \n    bool key_7     = keyPress(55); \n    bool key_8     = keyPress(56); \n     \n    if (key_space) {\n        if (key_1) {\n\t\t    radialSpectrum(fragColor, fragCoord);\n        } else if (key_2) {\n      \t\tradialSpectrumVariationTwo(fragColor, fragCoord);      \n        } else if (key_3) {\n            circluarAudioSpectrum(fragColor, fragCoord);\n        } else if (key_4) {\n            circluarStripReactor(fragColor, fragCoord);\n        } else if (key_5) {\n            radialSpectrumVariationThree(fragColor, fragCoord);\n        } else if (key_6) {\n            quasicrystalFractal(fragColor, fragCoord);\n        } else if (key_7) {\n            quasiTwo(fragColor, fragCoord);\n        } else {\n            smiley(fragColor, fragCoord);\n        }\n    } else {   \n\t\tshowAll(fragColor, fragCoord);\n    }\n\n    \n    \n    \n    \n\t//radialSpectrum(fragColor, fragCoord);\n    //radialSpectrumVariationTwo(fragColor, fragCoord);\n    //circluarAudioSpectrum(fragColor, fragCoord);\n    //circluarStripReactor(fragColor, fragCoord);\n    //rezaGlowies(fragColor, fragCoord);\n    //radialSpectrumVariationThree(fragColor, fragCoord);\n    //rezaGlowiesTwo(fragColor, fragCoord);\n    //quasicrystalFractal(fragColor, fragCoord);\n    //quasiTwo(fragColor, fragCoord);\n    //quasiCrystalVariableEditing(fragColor, fragCoord);\n    //smiley(fragColor, fragCoord);\n    \n    \n}", "image_inputs": [{"id": "4df3Rn", "previewfilepath": "/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music"}, {"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml23Rc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 51, 113, 113, 625], [628, 659, 733, 733, 1201], [1204, 1231, 1300, 1300, 1985], [1988, 2014, 2082, 2082, 2883], [2885, 2901, 2960, 2960, 4274], [4277, 4308, 4384, 4384, 5116], [5119, 5137, 5199, 5199, 6595], [6599, 6623, 6690, 6690, 7636], [7643, 7654, 7710, 7710, 8671], [8674, 8708, 8783, 8783, 9561], [9564, 9574, 9624, 9624, 9674], [9675, 9675, 9698, 9698, 9746], [9748, 9748, 9802, 9802, 10416], [10419, 10419, 10474, 10474, 11633], [11635, 11635, 11665, 11665, 11747], [11749, 11749, 11778, 11778, 11860], [11863, 11863, 11920, 11942, 13544]], "test": "error"}
{"id": "Ml23WG", "name": "Shiny Balls", "author": "dirkadirkadan", "description": "Shiny balls floating around", "tags": ["raymarching", "reflections"], "likes": 0, "viewed": 136, "published": "Public", "date": "1432241140", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat time;\n\n\n#define EPS .00001\n#define MAX_BOUNCES 4\n#define MAX_ITER 100\n#define STEP_FACTOR .8\n\nint mat_hit;\n\nvec3 right_ball_mat;\nvec3 left_ball_mat;\nvec3 floor_mat;\n\nfloat fbm(vec2 p)\n{\n    p /= 50.;\n    mat2 m = mat2(.8, -.6, .6, .8); \n    float amp = .5;\n \n    float f=0.;\n    for (int i = 0; i < 6; i++)\n    {\n        f += amp * texture(iChannel0, p).r;\n        p *= m * 2.;\n        amp *= .5;\n    }\n    \n    return f;\n}\n\n\nfloat udBox( vec3 p, vec3 b )\n{\n  mat3 rot;\n\n  p = p - vec3(0,2.,0.);\n\n  float speed = 8.;\n  float st = sin(time*speed);\n  float ct = cos(time*speed);\n\n  rot[0] = vec3(st,ct,0.);\n  rot[2] = vec3(0.,0.,1.);\n  rot[1] = vec3(ct,-st,0.);\n  \n  p = rot*p;\n  \n  return length(max(abs(p)-b,0.0));\n}\n\nfloat opDisplace( vec3 p )\n{\n  /*\n    float d1 = primitive(p);\n    float d2 = displacement(p);\n    return d1+d2;\n    */\n    return 0.;\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opI( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\nfloat opBlend( vec3 p )\n{\n  /*\n    float d1 = primitiveA(p);\n    float d2 = primitiveB(p);\n    return smin( d1, d2 );\n    */\n    return 0.;\n}\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat sdCappedCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 v = vec2( c.z*c.y/c.x, -c.z );\n\n    vec2 w = v - q;\n\n    vec2 vv = vec2( dot(v,v), v.x*v.x );\n    vec2 qv = vec2( dot(v,w), v.x*w.x );\n\n    vec2 d = max(qv,0.0)*qv/vv;\n\n    return sqrt( dot(w,w) - max(d.x,d.y) )* sign(max(q.y*v.x-q.x*v.y,w.y));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sphere(vec3 z, vec3 loc, float radius)\n{\n    return length(z-loc)-radius;\n}\n\nfloat de(vec3 z)\n{\n  \n    z.x = mod(z.x,10.)-5.;\n    z.z = mod(z.z,10.)-5.;\n    \n    float sphere1 = sphere(z, vec3(0.,sin(time*20.),0.), .5);\n    float sphere2 = sphere(z, vec3(-1.,-1.+.5*cos(time*20.),-1.), .7);\n    float flr = z.y+2.;\n    \n    mat_hit = int(step(0.,sphere1-sphere2));\n\n    float dist = min(sphere1,sphere2);\n    mat_hit += int(step(0.,dist-flr));\n    dist = min(dist,udBox(z,vec3(1.45)));\n    dist = min(dist,flr);\n    \n    return dist;\n}\n\nvec3 norm(vec3 p)\n{\n    float d = de(p);\n    \n    float x = d - de(vec3(p.x+EPS,p.y,p.z));\n    float y = d - de(vec3(p.x,p.y+EPS,p.z));\n    float z = d - de(vec3(p.x,p.y,p.z+EPS));\n    \n    return normalize(vec3(x,y,z));\n}\n\nfloat ao(vec3 p, vec3 n)\n{\n    n*=-0.2;\n    float f = .8+de(p+n);\n    return clamp(f,0.,1.);\n}\n\nfloat march(vec3 ro, vec3 rd, out bool hit, out vec3 pt, inout float d)\n{\n    hit = false;\n    for (int i = 0; i < MAX_ITER; i++)\n    {\n        pt = ro+rd*d;\n        float s = de(pt);\n        d += STEP_FACTOR*s;\n        \n        if (s < EPS)\n        {\n            hit = true;\n            return d;\n        }\n    }\n    \n    return 100.;\n}\n\nvec3 fogclr=vec3(.5,.6,.7);\n\nvec3 light(vec3 col, vec3 normal)\n{\n    vec3 lpos = vec3(2.);\n    vec3 ldir = normalize(vec3(-1.));\n    \n    return col*(clamp(dot(normal,ldir),0.,1.));\n    \n}\n\nvoid fog(inout vec3 col, float d, float f)\n{\n    col = mix(col,fogclr, clamp(1.-exp(-d*d*.0105*2.5*f),.0,1.));\n}\n\nbool trace(vec3 ro, vec3 rd, inout vec3 col)\n{\n    vec3 orig_ro = ro;\n    float d = 0.;\n    int max_bounces = MAX_BOUNCES;\n    \n    float factor = 1.;\n    factor = .95;\n    \n    bool any_hits = false;\n    for (int bounce = 0; bounce < MAX_BOUNCES; bounce++)\n    {\n        factor *= factor;\n        bool hit = false;\n        vec3 pt;\n        \n        d = march(ro,rd,hit,pt,d);\n        \n        if (hit)\n        {\n            vec3 mat_color = normalize(vec3(float(mat_hit),float(mat_hit)+1.,float((mat_hit+1)*(mat_hit+1))));\n            vec3 n = norm(pt);\n            col += clamp(factor,0.,1.)*light(mat_color, n);\n//            col *= ao(pt,n);\n\n            col += clamp(1.-abs(dot(n,pt-orig_ro)),0.,1.);\n            \n            float f = fbm(orig_ro.xy);\n            fog(col,d, f);\n            //col = mix(col,fogclr,f);\n            \n            ro = pt;\n            d = 0.01;\n            rd = reflect(rd,n);\n            any_hits = true;\n        }\n        else\n        {\n            break;\n        }\n    }\n    \n    return any_hits;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n  vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = 2.*uv-1.;\n    uv.x *= iResolution.x/iResolution.y;\n \n\n    time = iTime*.1;\n// vec2 uv = fragCoord;\n    \n    \n    vec3 col = vec3(0.);\n    /*\n    float x_noise = .3*noise(vec3(time,sin(time),2.));\n    float y_noise = .3*noise(vec3(cos(time),time,2.));\n    */\n\n  vec3 ro;\n  ro = vec3(5.,3.,8.);\n    ro = vec3(5.*sin(time*8.),+sin(time*8.)+cos(time*8.),8.*cos(time*9.));\n    ro.xy += uv;\n\n\n    vec3 rd = normalize(vec3(uv,-1.));\n    \n    \n    bool any_hits = trace(ro,rd,col);\n    \n    if (!any_hits) col= fogclr;\n   \n    col.xyz = vec3(col.x*col.x,col.y*col.y,col.z*col.z);\n    \n    \n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml23WG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[173, 173, 192, 192, 430], [433, 433, 464, 464, 723], [725, 725, 753, 844, 861], [863, 863, 896, 896, 922], [924, 924, 957, 957, 982], [984, 984, 1009, 1108, 1125], [1127, 1127, 1160, 1160, 1185], [1187, 1187, 1231, 1231, 1527], [1529, 1529, 1562, 1562, 1627], [1629, 1629, 1675, 1675, 1710], [1712, 1712, 1730, 1730, 2170], [2172, 2172, 2191, 2191, 2394], [2396, 2396, 2422, 2422, 2490], [2492, 2492, 2565, 2565, 2829], [2860, 2860, 2895, 2895, 3019], [3021, 3021, 3065, 3065, 3133], [3135, 3135, 3181, 3181, 4171], [4175, 4175, 4232, 4232, 4903]], "test": "error"}
{"id": "Ml23WV", "name": "Sailing Home", "author": "dr2", "description": "Choppy seas and patchy fog.", "tags": ["ocean", "fog"], "likes": 12, "viewed": 1324, "published": "Public API", "date": "1432733725", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Sailing Home\" by dr2 - 2015\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Choppy seas and patchy fog. Based on \"Wavescape\"; blended fog\n// idea from nimitz's \"Xyptonjtroz\".\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + cHashA4.xy) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  const vec3 cHashVA3 = vec3 (37.1, 61.7, 12.4);\n  const vec3 e = vec3 (1., 0., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  float i, f;\n  i = floor (p);  f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec2 t = Hashv2f (i);\n  return mix (t.x, t.y, f);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i, f;\n  i = floor (p);  f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nvec2 Noisev2v2 (vec4 p)\n{\n  vec4 i, f, t1, t2;\n  i = floor (p);  f = fract (p);\n  f = f * f * (3. - 2. * f);\n  t1 = Hashv4f (dot (i.xy, cHashA3.xy));\n  t2 = Hashv4f (dot (i.zw, cHashA3.xy));\n  return vec2 (mix (mix (t1.x, t1.y, f.x), mix (t1.z, t1.w, f.x), f.y),\n               mix (mix (t2.x, t2.y, f.z), mix (t2.z, t2.w, f.z), f.w));\n}\n\nfloat Noisefv3a (vec3 p)\n{\n  vec3 i, f;\n  i = floor (p);  f = fract (p);\n  f *= f * (3. - 2. * f);\n  vec4 t1 = Hashv4v3 (i);\n  vec4 t2 = Hashv4v3 (i + vec3 (0., 0., 1.));\n  return mix (mix (mix (t1.x, t1.y, f.x), mix (t1.z, t1.w, f.x), f.y),\n              mix (mix (t2.x, t2.y, f.x), mix (t2.z, t2.w, f.x), f.y), f.z);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;  p *= 2.;\n  }\n  return f;\n}\n\nfloat Fbm3 (vec3 p)\n{\n  const mat3 mr = mat3 (0., 0.8, 0.6, -0.8, 0.36, -0.48, -0.6, -0.48, 0.64);\n  float f, a, am, ap;\n  f = 0.;  a = 0.5;\n  am = 0.5;  ap = 4.;\n  p *= 0.5;\n  for (int i = 0; i < 6; i ++) {\n    f += a * Noisefv3a (p);\n    p *= mr * ap;  a *= am;\n  }\n  return f;\n}\n\nfloat FrAbsf (float p)\n{\n  return abs (fract (p) - 0.5);\n}\n\nvec3 FrAbsv3 (vec3 p)\n{\n  return abs (fract (p) - 0.5);\n}\n\nfloat FrNoise3d (vec3 p, vec3 disp)\n{\n  vec3 q;\n  float a, f;\n  a = 2.;\n  f = 0.;\n  q = p;\n  for (int j = 0; j < 4; j ++) {\n    p += FrAbsv3 (q + FrAbsv3 (q).yzx) + disp;\n    p *= 1.2;\n    f += a * (FrAbsf (p.x + FrAbsf (p.y + FrAbsf (p.z))));\n    q = 2. * q + 0.2;\n    a *= 0.7;\n  }\n  return f;\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nint idObj;\nmat3 ballMat, ballMatX[4];\nvec3 qHit, ballPos, ballPosX[4], sunCol, sunDir, cloudDisp, waterDisp,\n   fogDisp;\nvec2 bGap;\nfloat tCur, fCloud, fogAmp;\nconst float dstFar = 250.;\n\nvec3 SkyGrndCol (vec3 ro, vec3 rd)\n{\n  vec3 p, q, cSun, skyBg, clCol, col;\n  float colSum, attSum, s, att, a, dDotS, ds;\n  const vec3 cCol1 = 0.5 * vec3 (0.15, 0.2, 0.4),\n     cCol2 = 0.5 * vec3 (0.25, 0.5, 0.7), gCol = vec3 (0.08, 0.12, 0.08);\n  const float cloudLo = 200., cloudRngI = 1./200., atFac = 0.09;\n  const int nLay = 20;\n  if (rd.y < 0.015 * Fbm1 (16. * rd.x + 0.01 * tCur)- 0.0075) col = gCol *\n     (0.7 + 0.3 * Noisefv2 (1000. * vec2 (5. * atan (rd.x, rd.z), rd.y)));\n  else {\n    fCloud = clamp (fCloud, 0., 1.);\n    dDotS = max (dot (rd, sunDir), 0.);\n    ro += cloudDisp;\n    p = ro;\n    p.xz += (cloudLo - p.y) * rd.xz / rd.y;\n    p.y = cloudLo;\n    ds = 1. / (cloudRngI * rd.y * (2. - rd.y) * float (nLay));\n    colSum = 0.;  attSum = 0.;\n    s = 0.;  att = 0.;\n    for (int j = 0; j < nLay; j ++) {\n      q = p + rd * s;\n      q.z *= 0.7;\n      att += atFac * max (fCloud - Fbm3 (0.01 * q), 0.);\n      a = (1. - attSum) * att;\n      colSum += a * (q.y - cloudLo) * cloudRngI;\n      attSum += a;  s += ds;\n      if (attSum >= 1.) break;\n    }\n    colSum += 0.5 * min ((1. - attSum) * pow (dDotS, 3.), 1.);\n    clCol = vec3 (1.) * colSum + 0.05 * sunCol;\n    cSun = sunCol * clamp ((min (pow (dDotS, 1500.) * 2., 1.) +\n       min (pow (dDotS, 10.) * 0.75, 1.)), 0., 1.);\n    skyBg = mix (cCol1, cCol2, 1. - rd.y);\n    col = clamp (mix (skyBg + cSun, 1.6 * clCol, attSum), 0., 1.);\n  }\n  return col;\n}\n\nfloat WaveHt (vec3 p)\n{\n  const mat2 qRot = mat2 (1.6, -1.2, 1.2, 1.6);\n  vec4 t4, t4o, ta4, v4;\n  vec2 q2, t2, v2;\n  float wFreq, wAmp, pRough, ht;\n  wFreq = 0.18;  wAmp = 0.6;  pRough = 8.;\n  t4o.xz = tCur * vec2 (1., -1.);\n  q2 = p.xz + waterDisp.xz;\n  ht = 0.;\n  for (int j = 0; j < 3; j ++) {\n    t4 = (t4o.xxzz + vec4 (q2, q2)) * wFreq;\n    t2 = Noisev2v2 (t4);\n    t4 += 2. * vec4 (t2.xx, t2.yy) - 1.;\n    ta4 = abs (sin (t4));\n    v4 = (1. - ta4) * (ta4 + sqrt (1. - ta4 * ta4));\n    v2 = pow (1. - pow (v4.xz * v4.yw, vec2 (0.65)), vec2 (pRough));\n    ht += (v2.x + v2.y) * wAmp;\n    q2 *= qRot;  wFreq *= 2.;  wAmp *= 0.2;\n    pRough = 0.8 * pRough + 0.2;\n  }\n  return ht;\n}\n\nfloat WaveRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = 0; j < 70; j ++) {\n    p = ro + s * rd;\n    h = p.y - WaveHt (p);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.4, 1.2 * h) + 0.01 * s;\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = 0; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      h = step (0., p.y - WaveHt (p));\n      sLo += h * (s - sLo);\n      sHi += (1. - h) * (s - sHi);\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nvec3 WaveNf (vec3 p, float d)\n{\n  vec2 e = vec2 (max (0.1, 5e-5 * d * d), 0.);\n  float h = WaveHt (p);\n  return normalize (vec3 (h - WaveHt (p + e.xyy), e.x, h - WaveHt (p + e.yyx)));\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, db;\n  int ih;\n  dMin = dstFar;\n  db = max (abs (p.x) - 2. * bGap.x, 0.);\n  p.z = mod (p.z + 2. * bGap.y, 4. * bGap.y) - 2. * bGap.y;\n  q = p;\n  if (p.z > 0.) {\n    if (p.x > 0.) {\n      q -= ballPosX[0];  q *= ballMatX[0];  ih = 0;\n    } else {\n      q -= ballPosX[1];  q *= ballMatX[1];  ih = 1;\n    }\n  } else {\n    if (p.x > 0.) {\n      q -= ballPosX[2];  q *= ballMatX[2];  ih = 0;\n    } else {\n      q -= ballPosX[3];  q *= ballMatX[3];  ih = 1;\n    }\n  }\n  d = max (PrSphDf (q, 1.2), db);\n  if (d < dMin) { dMin = d;  idObj = 1;  qHit = q; }\n  q.y -= 2.2;\n  d = max (PrCylDf (q.xzy, 0.05, 1.), db);\n  if (d < dMin) { dMin = d;  idObj = 2;  qHit = q; }\n  q.y -= 1.3;\n  d = max (PrCylDf (q.xzy, 0.15, 0.3), db);\n  if (d < dMin) { dMin = d;  idObj = 3 + ih;  qHit = q; }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float d, dHit;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.002 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec3 ObjCol (vec3 n)\n{\n  vec3 col;\n  col = vec3 (0.);\n  if (idObj == 1) {\n    col = vec3 (1., 0.5, 0.);\n    if (abs (qHit.y) < 0.125) col =\n       (mod (floor (7. * (atan (qHit.x, qHit.z) / pi + 1.)), 2.) == 0.) ?\n       vec3 (1., 0., 0.) : vec3 (0.04);\n    else if (qHit.y > 1.16) col = vec3 (0., 0.5, 0.);\n    else if (abs (qHit.y) < 0.15) col = vec3 (1., 0., 0.);\n    else if (abs (abs (qHit.y) - 0.33) < 0.03) col = vec3 (1.);\n    else if (abs (abs (qHit.y) - 0.39) < 0.03) col = vec3 (0.05);\n  } else if (idObj == 2) {\n    col = vec3 (0.7, 0.4, 0.);\n  } else if (idObj == 3) {\n    if (abs (qHit.y) < 0.2) \n       col = vec3 (0., 1., 0.) * (3. + 2.5 * cos (10. * tCur));\n    else col = vec3 (0.6, 0.4, 0.2);\n  } else if (idObj == 4) {\n    if (abs (qHit.y) < 0.2) \n       col = vec3 (1., 0., 0.) * (3. + 2.5 * sin (10. * tCur));\n    else col = vec3 (0.6, 0.4, 0.2);\n  }\n  return col;\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  for (int j = 0; j < 40; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, 20. * h / d);\n    d += 0.1;\n    if (h < 0.001) break;\n  }\n  return clamp (sh, 0., 1.);\n}\n\nvec3 ObjRender (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float sh, cc;\n  int idObjT;\n  idObjT = idObj;\n  vn = ObjNf (ro);\n  idObj = idObjT;\n  col = ObjCol (rd);\n  cc = 1. - smoothstep (0.3, 0.6, fCloud);\n  sh = ObjSShadow (ro, sunDir);\n  return col * (0.3 + 0.7 * max (0., max (dot (vn, sunDir), 0.)) *\n     (0.7 + 0.3 * cc * sh)) + 0.3 * cc * sh * sunCol *\n     pow (max (0., dot (sunDir, reflect (rd, vn))), 32.);\n}\n\nfloat FogAmp (vec3 p, float d)\n{\n  vec3 q;\n  float s1, s2;\n  q = p + fogDisp;\n  q.y *= 2.;\n  s1 = sin (tCur * 0.6);\n  q.x += 0.3 * s1;\n  s2 = sin (0.5 * q.x);\n  q.y += 0.1 * s1 + 0.2 * s2;\n  q.z += s2;\n  return fogAmp * FrNoise3d (q / (d + 30.), fogDisp);\n}\n\nvec3 FogCol (vec3 col, vec3 ro, vec3 rd, float dHit)\n{\n  vec3 q;\n  float d, dq, fFac, f, fa;\n  d = 3.;\n  dq = 0.2;\n  fFac = 1.;\n  for (int j = 0; j < 5; j ++) {\n    q = ro + rd * d;\n    f = FogAmp (q, d);\n    fa = 1. - clamp (f - FogAmp (q + dq, d), 0., 1.);\n    col = mix (col, vec3 (0.8, 0.8, 0.75) * fa,\n      clamp (fFac * f * smoothstep (0.9 * d, 2.3 * d, dHit), 0., 1.));\n    d *= 1.6;\n    dq *= 0.8;\n    fFac *= 1.1;\n    if (d > dHit) break;\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn, rdd, refCol, roo, rdo;\n  float dstHit, dstWat, dstFog, dif, bk, sh, foamFac, tWeathr;\n  const float eta = 0.75, att = 0.5;\n  int idObjT;\n  bool doReflect;\n  cloudDisp = 5. * tCur * vec3 (1., 0., 1.);\n  waterDisp = 0.25 * tCur * vec3 (-1., 0., 1.);\n  fogDisp = 0.05 * tCur * vec3 (1., 0., 0.);\n  sunDir = normalize (vec3 (0.2, 0.5, 0.5));\n  sunCol = vec3 (1., 0.4, 0.3) + vec3 (0., 0.5, 0.2) * sunDir.y;\n  tWeathr = mod (0.05 * tCur, 2. * pi);\n  fCloud = 0.5 + 0.15 * sin (tWeathr);\n  fogAmp = 0.25 * SmoothBump (0.35 * pi, 0.65 * pi, 0.15 * pi, tWeathr);\n  roo = ro;\n  rdo = rd;\n  ro.y = max (ro.y, WaveHt (ro) + 0.1);\n  dstWat = WaveRay (ro, rd);\n  idObj = -1;\n  dstHit = ObjRay (ro, rd);\n  if (idObj < 0) dstHit = dstFar;\n  dstFog = min (dstHit, dstWat);\n  doReflect = (dstWat < dstFar && dstWat < dstHit);\n  if (doReflect) {\n    ro += rd * dstWat;\n    vn = WaveNf (ro, dstWat);\n    rdd = rd;\n    rd = reflect (rd, vn);\n    idObj = -1;\n    dstHit = ObjRay (ro, rd);\n    if (idObj < 0) dstHit = dstFar;\n    dstFog = min (dstFog + dstHit, dstFar);\n  } \n  col = (dstHit < dstFar) ? ObjRender (ro + rd * dstHit, rd) :\n     SkyGrndCol (ro, rd);\n  if (doReflect) {\n    refCol = col;\n    rd = refract (rdd, vn, eta);\n    idObj = -1;\n    dstHit = ObjRay (ro, rd);\n    if (idObj < 0) dstHit = dstFar;\n    dstFog = min (dstFog + dstHit, dstFar);\n    col = (dstHit < dstFar) ? ObjRender (ro + rd * dstHit, rd) *\n       exp (- att * dstHit) : vec3 (0., 0.05, 0.05);\n    col = mix (col, 0.8 * refCol, pow (1. - abs (dot (rdd, vn)), 5.));\n    foamFac = 0.9 * pow (clamp (WaveHt (ro) +\n       0.004 * Fbm3 (256. * ro) - 0.55, 0., 1.), 8.);\n    col = mix (col, vec3 (0.9), foamFac);\n  }\n  col = FogCol (col, roo, rdo, dstFog);\n  return col;\n}\n\nvoid BallPM (float bOffset)\n{\n  const vec3 e = vec3 (1., 0., 0.);\n  float h[5], b;\n  ballPos.z += bOffset;\n  h[0] = WaveHt (ballPos);\n  h[1] = WaveHt (ballPos + e.yyx);\n  h[2] = WaveHt (ballPos - e.yyx);\n  h[3] = WaveHt (ballPos + e);\n  h[4] = WaveHt (ballPos - e);\n  ballPos.y = 0.1 + (2. * h[0] + h[1] + h[2] + h[3] + h[4]) / 15.;\n  ballPos.z -= bOffset;\n  b = (h[1] - h[2]) / (6. * e.x);\n  ballMat[2] = normalize (vec3 (0., b, 1.));\n  b = (h[3] - h[4]) / (6. * e.x);\n  ballMat[1] = normalize (cross (ballMat[2], vec3 (1., b, 0.)));\n  ballMat[0] = cross (ballMat[1], ballMat[2]);\n}\n\nvoid SetBuoys (vec3 ro)\n{\n  float bOffset;\n  bOffset = mod (ro.z + 2. * bGap.y, 4. * bGap.y) - 2. * bGap.y;\n  ballPos = vec3 (bGap.x, 0., bGap.y);\n  BallPM (bOffset);\n  ballPosX[0] = ballPos;\n  ballMatX[0] = ballMat;\n  ballPos = vec3 (- bGap.x, 0., bGap.y);\n  BallPM (bOffset);\n  ballPosX[1] = ballPos;\n  ballMatX[1] = ballMat;\n  ballPos = vec3 (bGap.x, 0., - bGap.y);\n  BallPM (bOffset);\n  ballPosX[2] = ballPos;\n  ballMatX[2] = ballMat;\n  ballPos = vec3 (- bGap.x, 0., - bGap.y);\n  BallPM (bOffset);\n  ballPosX[3] = ballPos;\n  ballMatX[3] = ballMat;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n  vec2 uvs = uv;\n  uv.x *= iResolution.x / iResolution.y;\n  tCur = iTime;\n  mat3 vuMat;\n  vec3 col, ro, rd, ca, sa;\n  float el, az, rl;\n  az = 0.;\n  el = 0.02 * pi + 0.04 * (1. + sin (0.5 * tCur + 0.3)) +\n     0.024 * (1. + sin (0.8 * tCur));\n  rl = 0.1 * sin (0.5 * tCur) + 0.06 * sin (0.8 * tCur + 0.3);\n  ca = cos (vec3 (el, az, rl));\n  sa = sin (vec3 (el, az, rl));\n  vuMat = mat3 (ca.z, - sa.z, 0., sa.z, ca.z, 0., 0., 0., 1.) *\n     mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n     mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y);\n  rd = normalize (vec3 (uv, 3.1)) * vuMat;\n  ro = vec3 (0., 1.5, -20.) * vuMat;\n  ro.z += 2. * tCur;\n  bGap = vec2 (8., 16.);\n  SetBuoys (ro);\n  col = pow (clamp (ShowScene (ro, rd), 0., 1.), vec3 (0.45));\n  uvs *= uvs * uvs;\n  col = mix (vec3 (0.2), col,\n     pow (max (0., 0.8 - length (uvs * uvs)), 0.2));\n  fragColor = vec4 (col, 1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml23WV.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[120, 370, 394, 394, 444], [446, 446, 470, 470, 517], [519, 519, 543, 543, 782], [784, 784, 809, 809, 939], [941, 941, 966, 966, 1147], [1149, 1149, 1174, 1174, 1486], [1488, 1488, 1514, 1514, 1808], [1810, 1810, 1832, 1832, 1966], [1968, 1968, 1989, 1989, 2249], [2251, 2251, 2275, 2275, 2309], [2311, 2311, 2334, 2334, 2368], [2370, 2370, 2407, 2407, 2667], [2669, 2669, 2726, 2726, 2809], [2811, 2811, 2844, 2844, 2871], [2873, 2873, 2915, 2915, 2966], [3156, 3156, 3192, 3192, 4575], [4577, 4577, 4600, 4600, 5261], [5263, 5263, 5297, 5297, 5825], [5827, 5827, 5858, 5858, 6012], [6014, 6014, 6036, 6036, 6854], [6856, 6856, 6889, 6889, 7065], [7067, 7067, 7088, 7088, 7296], [7298, 7298, 7320, 7320, 8186], [8188, 8188, 8225, 8225, 8435], [8437, 8437, 8472, 8472, 8851], [8853, 8853, 8885, 8885, 9110], [9112, 9112, 9166, 9166, 9580], [9582, 9582, 9617, 9617, 11362], [11364, 11364, 11393, 11393, 11947], [11949, 11949, 11974, 11974, 12502], [12504, 12504, 12560, 12560, 13505]], "test": "error"}
{"id": "Ml2GWy", "name": "Fractal Tiling", "author": "iq", "description": "Inspired by the previous [url=https://www.shadertoy.com/view/ll2GWy]Smooth XOR[/url] experiment.", "tags": ["2d", "xor", "tiling"], "likes": 172, "viewed": 8631, "published": "Public API", "date": "1432180668", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2015\n//   https://www.youtube.com/c/InigoQuilez\n//   https://iquilezles.org/\n// I share this piece (art and code) here in Shadertoy and through its Public API, only for educational purposes. \n// You cannot use, sell, share or host this piece or modifications of it as part of your own commercial or non-commercial product, website or project.\n// You can share a link to it or an unmodified screenshot of it provided you attribute \"by Inigo Quilez, @iquilezles and iquilezles.org\". \n// If you are a teacher, lecturer, educator or similar and these conditions are too restrictive for your needs, please contact me and we'll work it out.\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = 256.0*fragCoord.xy/iResolution.x + iTime;\n\n    vec3 col = vec3(0.0);\n    for( int i=0; i<6; i++ ) \n    {\n        vec2 a = floor(pos);\n        vec2 b = fract(pos);\n        \n        vec4 w = fract((sin(a.x*7.0+31.0*a.y + 0.01*iTime)+vec4(0.035,0.01,0.0,0.7))*13.545317); // randoms\n                \n        col += w.xyz *                                   // color\n               2.0*smoothstep(0.45,0.55,w.w) *           // intensity\n               sqrt( 16.0*b.x*b.y*(1.0-b.x)*(1.0-b.y) ); // pattern\n        \n        pos /= 2.0; // lacunarity\n        col /= 2.0; // attenuate high frequencies\n    }\n    \n    col = pow( col, vec3(0.7,0.8,0.5) );    // contrast and color shape\n    \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml2GWy.jpg", "access": "shaders20k", "license": "proprietary-license", "functions": [[0, 669, 726, 726, 1459]], "test": "valid"}
{"id": "MlB3DV", "name": "PBR_Test", "author": "2v_S", "description": "Physically Based Rendering Test\n", "tags": ["pbr", "ggx"], "likes": 53, "viewed": 2216, "published": "Public", "date": "1432464840", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n* References : \n*\n* http://renderwonk.com/publications/s2010-shading-course/hoffman/s2010_physically_based_shading_hoffman_b_notes.pdf\n* \n* http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n*\n* http://graphicrants.blogspot.fr/2013/08/specular-brdf-reference.html\n*\n* http://www.filmicworlds.com/2014/04/21/optimizing-ggx-shaders-with-dotlh/\n*\n* http://blog.selfshadow.com/publications/s2013-shading-course/#course_content\n*\n*\tRay marching code from iq\n*/\n\n\n#define NB_LIGHTS 3\n\n// Metals values in linear space\n#define GOLD vec3(1.0, 0.71, 0.29)\n#define COPPER vec3(0.95, 0.64, 0.54)\n#define IRON vec3(0.56, 0.57, 0.58)\n#define ALUMINIUM vec3(0.91, 0.92, 0.92)\n#define SILVER vec3(0.95, 0.93, 0.88)\n\n\n\nfloat fPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat fSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n// ---- Scene definition\nvec2 fScene(vec3 p) {\n    \n    vec3 pSphere = p/*opRep(p, vec3( 2.0, 0.0, 2.0))*/;\n    \n \tvec2 sphere0 = vec2(fSphere(p, 1.0), 0.5); \t\n    vec2 sphere1 = vec2(fSphere(p+vec3(2.1, 0.0, 2.0), 1.0), 2.5);\n\tvec2 sphere2 = vec2(fSphere(p+vec3(-2.1, 0.0, 2.0), 1.0), 3.5);\n    vec2 sphere3 = vec2(fSphere(p+vec3(2.1, 0.0, -2.0), 1.0), 4.5);\n    vec2 sphere4 = vec2(fSphere(p+vec3(-2.1, 0.0, -2.0), 1.0), 5.5);\n\t\n\n\n    vec2 plane = vec2(fPlane(p, vec4(0, 1, 0, 1.0)), 1.5);\n    \n    return opU(opU(opU(opU(opU(plane, sphere0), sphere1), sphere2), sphere3), sphere4);\n}\n// -----\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 100.0;\n    \n    \n\tfloat precis = 0.00001;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec2 res = fScene( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = fScene( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    fScene(pos+eps.xyy).x - fScene(pos-eps.xyy).x,\n\t    fScene(pos+eps.yxy).x - fScene(pos-eps.yxy).x,\n\t    fScene(pos+eps.yyx).x - fScene(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\nstruct Light {\n \tvec3 pos;\n    vec3 color;\n};\nLight lights[NB_LIGHTS];\n\n\nfloat G1V ( float dotNV, float k ) {\n\treturn 1.0 / (dotNV*(1.0 - k) + k);\n}\n\nvec3 computePBRLighting ( in Light light, in vec3 position, in vec3 N, in vec3 V, in vec3 albedo, in float roughness, in vec3 F0 ) {\n\n\tfloat alpha = roughness*roughness;\n\tvec3 L = normalize(light.pos.xyz - position);\n\tvec3 H = normalize (V + L);\n\n\tfloat dotNL = clamp (dot (N, L), 0.0, 1.0);\n\tfloat dotNV = clamp (dot (N, V), 0.0, 1.0);\n\tfloat dotNH = clamp (dot (N, H), 0.0, 1.0);\n\tfloat dotLH = clamp (dot (L, H), 0.0, 1.0);\n\n\tfloat D, vis;\n\tvec3 F;\n\n\t// NDF : GGX\n\tfloat alphaSqr = alpha*alpha;\n\tfloat pi = 3.1415926535;\n\tfloat denom = dotNH * dotNH *(alphaSqr - 1.0) + 1.0;\n\tD = alphaSqr / (pi * denom * denom);\n\n\t// Fresnel (Schlick)\n\tfloat dotLH5 = pow (1.0 - dotLH, 5.0);\n\tF = F0 + (1.0 - F0)*(dotLH5);\n\n\t// Visibility term (G) : Smith with Schlick's approximation\n\tfloat k = alpha / 2.0;\n\tvis = G1V (dotNL, k) * G1V (dotNV, k);\n\n\tvec3 specular = /*dotNL **/ D * F * vis;\n\n\tvec3 ambient = vec3(.01);\n\n\tfloat invPi = 0.31830988618;\n\tvec3 diffuse = (albedo * invPi);\n\n\n\treturn ambient + (diffuse + specular) * light.color.xyz * dotNL ;\n}\n\nvec3 addPBR( in vec3 position, in vec3 N, in vec3 V, in vec3 baseColor, in float metalMask, in float smoothness, in float reflectance) {\n\tvec3 color = vec3(0.0);\n\n    float roughness = 1.0 - smoothness*smoothness;\n    vec3 F0 = 0.16*reflectance*reflectance * (1.0-metalMask) + baseColor*metalMask;\n    vec3 albedo = baseColor;\n    \n    float s = 0.0;\n    \n    \n\tfor ( int i = 0; i < NB_LIGHTS; ++i ) {\n\t\tvec3 col = computePBRLighting ( lights[i], position, N, V, albedo, roughness, F0);\n\t\tcolor += col;\t\n        s += softshadow( position, normalize(lights[i].pos.xyz - position), 0.02, 2.5 );\n\t}\n\n\treturn color*s;\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.8, 0.9, 1.0)*8.0; // Sky color\n    \n    vec2 res = castRay( ro, rd );\n    float t = res.x;\n    float m = res.y;\n    vec3 p = ro + t*rd;\n    \n    if(m>-0.5) { // Intersection found\n        if( m < 1.0 ) {\n           // float f = mod( floor( 5.0*p.z ) + floor( 5.0*p.x ), 2.0 );\n            vec3 sur = vec3(1.0,1.0,1.0)*smoothstep(-1.0,-0.6,sin(16.0*p.x));\n            col = addPBR( p, calcNormal( p ), -rd, GOLD*sur, sur.x, 0.3+0.6*sur.x, 0.5 );\n        } \n        else if( m < 2.0 ) {\n            float f = mod( floor( 5.0*p.z ) + floor( 5.0*p.x ), 2.0 );\n            col = addPBR(p, calcNormal( p ), -rd, vec3(0.5), 0.0, 0.3+0.6*f, 0.5 );\n        }\n        else if( m < 3.0 ) {\n            vec3 sur = vec3(1.0,1.0,1.0)*smoothstep(-1.0,-0.4,sin(18.0*p.x));\n            col = addPBR( p, calcNormal( p ), -rd, COPPER*sur, sur.x, 0.3+0.6*sur.x, 0.5 );\n        }\n        else if( m < 4.0 ) {\n            vec3 sur = vec3(1.0,1.0,1.0)*smoothstep(-1.0,-0.0995,sin(106.0*p.x))*smoothstep(-1.0,-0.9,sin(47.0*p.z));\n            col = addPBR( p, calcNormal( p ), -rd, vec3(0.2), 1.0-sur.x, 0.9*sur.x, 0.5 );\n        }\n        else if( m < 5.0 ) {\n            vec3 sur = vec3(1.0)*smoothstep(-1.0,-0.765,sin(24.0*p.x))*smoothstep(-1.0,-0.4,sin(70.9*p.z));\n            col = addPBR( p, calcNormal( p ), -rd, GOLD*(1.0-sur), sur.x, 0.3+0.6*sur.x, 0.5 );\n        }\n        else if( m < 6.0 ) {\n            vec3 sur = vec3(1.0,1.0,1.0)*smoothstep(-1.0,-0.4,sin(18.0*p.x));\n            col = addPBR( p, calcNormal( p ), -rd, ALUMINIUM*sur, sur.x, 0.3+0.6*sur.x, 0.5 );\n        }\n    }\n    \n\treturn col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec4 hejlToneMapping (in vec4 color) {\n \tvec4 x = max(vec4(0.0), color-vec4(0.004)); \n\treturn (x * ((6.2*x)+vec4(0.5))) / max(x * ((6.2*x)+vec4(1.7))+vec4(0.06), vec4(1e-8));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float time = 0.25*iTime;\n    \n    lights[0] = Light(vec3(0.0, 5.0, .0), vec3(1.0));   \n\tlights[1] = Light(vec3(12.0*sin(iTime), 8.0, 12.0*cos(iTime)), vec3(1.0));   \t\n    lights[2] = Light(vec3(-12.0*cos(-iTime), 8.0, 12.0*sin(-iTime)), vec3(.05));   \n\n   \n\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\t\n\n\t// camera\t\n\tvec3 ro = vec3( 7.0*sin(time), 3.6 , -7.0*cos(time) );\n\tvec3 ta = vec3( 0.0 );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.5) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n    #if 0\n        col = pow( col, vec3(0.4545) );\n        fragColor=vec4( col, 1.0 );\n    #else \n    \tfloat exposure = 0.032 + 0.023*sin(time-3.14);\n   \t\tfragColor = hejlToneMapping(vec4(col, 1.0) * exposure) ;\n    #endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlB3DV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[524, 748, 780, 806, 837], [839, 839, 873, 873, 899], [900, 900, 933, 933, 959], [961, 961, 991, 991, 1024], [1026, 1026, 1056, 1056, 1085], [1086, 1111, 1132, 1132, 1672], [1673, 1683, 1723, 1723, 2054], [2057, 2057, 2131, 2131, 2395], [2397, 2397, 2429, 2429, 2668], [2744, 2744, 2780, 2780, 2819], [2821, 2821, 2953, 2953, 3863], [3865, 3865, 4001, 4001, 4480], [4482, 4482, 4521, 4521, 6132], [6134, 6134, 6186, 6186, 6363], [6365, 6365, 6403, 6403, 6541], [6543, 6543, 6600, 6600, 7529]], "test": "valid"}
{"id": "MlB3R3", "name": "Marble Effect", "author": "jonobr1", "description": "A shader to create an animated marble effect.", "tags": ["2d", "noise", "bw", "marble", "white", "black"], "likes": 14, "viewed": 1824, "published": "Public API", "date": "1430854582", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14;\nconst int resolution = 16;\nvec2 period = vec2( 5.0, 10.0 );\nfloat power = 8.0;\nfloat size = 64.0;\n\n//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nfloat smoothNoise(float x, float y) {\n\n   //get fractional part of x and y\n   float fractX = x - floor(x);\n   float fractY = y - floor(y);\n   \n   //wrap around\n   float x1 = mod((floor(x) + iResolution.x), iResolution.x);\n   float y1 = mod((floor(y) + iResolution.y), iResolution.y);\n   \n   //neighbor values\n   float x2 = mod((x1 + iResolution.x - 1.0), iResolution.x);\n   float y2 = mod((y1 + iResolution.y - 1.0), iResolution.y);\n\n   //smooth the noise with bilinear interpolation\n   float value = 0.0;\n   value += fractX       * fractY       * snoise(vec2(x1, y1));\n   value += fractX       * (1.0 - fractY) * snoise(vec2(x1, y2));\n   value += (1.0 - fractX) * fractY       * snoise(vec2(x2, y1));\n   value += (1.0 - fractX) * (1.0 - fractY) * snoise(vec2(x2, y2));\n\n   return value;\n}\n\nfloat turbulence( vec2 pos, in float size ) {\n\n    float value = 0.0, initialSize = size;\n    float x = pos.x;\n    float y = pos.y;\n    \n    for ( int i = 0; i < resolution; i++ ) {\n    \tvalue += smoothNoise( x / size, y / size ) * size;\n        size /= 2.0;\n    }\n    \n    return( 128.0 * value / initialSize );\n}\n\nfloat marble( in vec2 p ) {\n\n  \tfloat x = p.x;\n    float y = p.y;\n\n    float xy = x / iResolution.y * period.x;\n    xy += y * period.y / iResolution.x;\n    xy += power * turbulence( p, size ) / 256.0;\n\n    return sin( 256.0 * xy * PI );\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 pos = uv.xy;\n\n    period.x += 10.0 * cos( iTime );\n    period.y += 10.0 * sin( iTime );\n    \n\tfloat n = marble( pos );\n    \n\tfragColor = vec4(vec3(1.0 - n), 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlB3R3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[122, 491, 512, 512, 561], [563, 563, 584, 584, 633], [635, 635, 657, 657, 694], [696, 696, 720, 720, 2226], [2228, 2228, 2265, 2302, 3017], [3019, 3019, 3064, 3064, 3333], [3335, 3335, 3362, 3362, 3578], [3580, 3580, 3637, 3637, 3855]], "test": "valid"}
{"id": "MlB3Rd", "name": "Woooo testing", "author": "Yevano", "description": "It's a thing", "tags": ["testing", "fields"], "likes": 3, "viewed": 132, "published": "Public", "date": "1431380961", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define EPSILON .0001\n#define PI 3.1415926535898\n#define MAX_DIST 100.\n#define THRESHOLD 0.75\n\nmat2 getRotMat(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvec3 distFunc(vec3 xyz) {\n    //xyz = normalize(xyz);\n    xyz += 1.;\n    xyz *= 0.5;\n    //return vec3(cos(32.*length(xyz.xy) * xyz.z), sin(32.*length(xyz)), tan(32.*length(xyz))*/);\n    //return vec3(0., 0., 8. * sin(4.*length(xyz)));\n    //return vec3(0., 0., length(xyz) - 0.5);\n    return vec3(0., 0., sin(xyz.x * 16.) + sin(xyz.y * 16.) + sin(xyz.z * 16.));\n}\n\nfloat udBox( vec3 xyz, vec3 b ) {\n  return length(max(abs(xyz)-b,0.0));\n}\n\nfloat sphere(vec3 xyz, float r) {\n    return length(xyz) - r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1. + 2. * q;\n    p.x *= iResolution.x/iResolution.y;\n\n\tvec3 ro = vec3(sin(iTime) * 2., 0., cos(iTime) * 2.);\n    //vec3 ro = vec3(0., 0., 0.);\n\tvec3 rd = normalize(vec3(p * 1., 1.));\n    \n    float a = PI-iTime;\n    //rd.xz *= getRotMat(PI - PI * 2. * iMouse.x/iResolution.x);\n    rd.xz *= getRotMat(PI-iTime);\n    \n    float l = 0.;\n    for(int i = 1; i < 2048; i++) {\n        vec3 r = ro + rd * l;\n        vec3 v = distFunc(r);\n        //float d = max(udBox(r, vec3(1., 1., 1.)), THRESHOLD - max(v.x, v.y)) * 0.05;\n        float d = max(sphere(r, 1.5), THRESHOLD - max(max(v.x, v.y), v.z)) * 0.05;\n        if(d <= EPSILON) {\n            fragColor = vec4(v.x, v.y, v.z, 1.) - l/4. + 0.1;\n            break;\n        }\n        if(l > MAX_DIST) {\n            fragColor = vec4(0.);\n            break;\n        }\n        l += d;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlB3Rd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[95, 95, 120, 120, 172], [174, 174, 199, 227, 538], [540, 540, 573, 573, 613], [615, 615, 648, 648, 678], [680, 680, 737, 737, 1627]], "test": "valid"}
{"id": "MlB3WV", "name": "Worley Fractal bump+mouse", "author": "104", "description": "Bump-mapping based on a worley fractal noise pattern. Use mouse to move light around. See also https://www.shadertoy.com/view/MtSGWK for a similar experiment using triangles", "tags": ["2d", "mouse", "texture", "worley", "bump"], "likes": 12, "viewed": 378, "published": "Public", "date": "1432430911", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nMaking a worley fractal is sorta weak, because each iteration generates entirely new\ncells, unrelated to the \"parent\" cells. So you end up with what looks like a bunch of\nlayers overlayed, instead of a clean tessellation.\n\nBut that effect might just be what you're looking for. It has a soft, crumpled look.\n\nCompare this to a similar fractal noise pattern based on just tessellating triangles:\nhttps://www.shadertoy.com/view/MtSGWK\n\nThe triangle version looks much \"sharper\" and harder, because the edges ar retained\nfor each iteration. So it looks like a single surface, tessellated.\n\nThis worley version looks more \"blurred\", because edges are re-built each iteration.\n\n*/\n\n// -------------------------------------------------------\n// parameters...\n\n\n// 0 = no coloring; just see bump effect\n// 1 = stylized by distance\n// 2 = reveal raw distance (typical worley)\n#define COLOR_MODE 1\n\n\nconst int iterationCount = 10;\n\n// normally this should be 0.5 to cut cells in half each iteration.\n// small amounts are cool too though like 0.1.\n// greater than 1 doesn't make much sense considering the algo, and <0 is just nonsense.\nconst float iterationSizeFactor = .5;\n\nconst float iterationNormalInfluenceFactor = 0.79;\n\nconst float iterationColorInfluenceFactor = 0.68;\n\n\n\n\n\n// -------------------------------------------------------\n// utilities\n// c64 palette because why not.\nvec3 color0 = vec3(0,0,0);// black\nvec3 color1 = vec3(1,1,1);// white\nvec3 color2 = vec3(0.41,0.22,0.17);// red\nvec3 color3 = vec3(0.44,0.64,0.70);// cyan\nvec3 color4 = vec3(0.44,0.24,0.53);// violet\nvec3 color5 = vec3(0.35,0.55,0.26);// green\nvec3 color6 = vec3(0.21,0.16,0.47);// blue\nvec3 color7 = vec3(0.72,0.78,0.44);// yellow\nvec3 color8 = vec3(0.44,0.31,0.15);// orange\nvec3 color9 = vec3(0.26,0.22,0);// brown\nvec3 colorA = vec3(0.60,0.40,0.35);// light red\nvec3 colorB = vec3(0.27,0.27,0.27);// grey1\nvec3 colorC = vec3(0.42,0.42,0.42);// grey2\nvec3 colorD = vec3(0.60,0.82,0.52);// light green\nvec3 colorE = vec3(0.42,0.37,0.71);// light blue\nvec3 colorF = vec3(0.58,0.58,0.58);// grey3\nvec3 getPalette(int i)\n{\n    if(i == 0) return color6;\n    if(i == 1) return color3;\n    if(i == 2) return color5;\n    if(i == 3) return color9;\n    if(i == 4) return color7;\n    return color8;\n}\n\n\n\nfloat nsin(float a)\n{\n    return (sin(a)+1.)/2.;\n}\nfloat rand(float n)\n{\n \treturn fract(cos(n*89.42)*343.42);\n}\nvec2 rand(vec2 n)\n{\n \treturn vec2(rand(n.x*23.62-300.0+n.y*34.35),rand(n.x*45.13+256.0+n.y*38.89)); \n}\n\n// returns (dx, dy, distance)\nvec3 worley(vec2 n,float s)\n{\n    vec3 ret = vec3(s * 10.);\n    // look in 9 cells (n, plus 8 surrounding)\n    for(int x = -1;x<2;x++)\n    {\n        for(int y = -1;y<2;y++)\n        {\n            vec2 xy = vec2(x,y);// xy can be thought of as both # of cells distance to n, and \n            vec2 cellIndex = floor(n/s) + xy;\n            vec2 worleyPoint = rand(cellIndex);// random point in this cell (0-1)\n            worleyPoint += xy - fract(n/s);// turn it into distance to n. ;\n            float d = length(worleyPoint) * s;\n            if(d < ret.z)\n                ret = vec3(worleyPoint, d);\n        }\n    }\n    return ret;\n}\n\n\nvec4 applyLighting(vec4 inpColor, vec2 uv, vec3 normal, vec3 LightPos, vec4 LightColor, vec4 AmbientColor)\n{\n    if(distance(uv.xy, LightPos.xy) < 0.01) return vec4(1.,0.,0.,1.);\n    vec3 LightDir = vec3(LightPos.xy - uv, LightPos.z);\n    float D = length(LightDir);// distance for attenuation\n    vec3 N = normalize(normal);\n    vec3 L = normalize(LightDir);\n    vec3 Diffuse = (LightColor.rgb * LightColor.a) * max(dot(N, L), 0.0);\n    vec3 Ambient = AmbientColor.rgb * AmbientColor.a;\n    vec3 Intensity = Ambient + Diffuse;\n    vec3 FinalColor = inpColor.rgb * Intensity;\n    return vec4(FinalColor, inpColor.a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 scrollOffset = vec2(iTime * iResolution.x / 17., 0.0);\n    vec2 uv = fragCoord.xy + scrollOffset;\n    \n    vec2 lightPosXY = vec2(nsin(iTime * 1.66), nsin(iTime * 1.99));\n    lightPosXY = (lightPosXY * 0.75) + 0.125;// not so big movement\n    lightPosXY *= iResolution.xy;\n    lightPosXY += scrollOffset;\n    if(iMouse.z > 0.)\n\t    lightPosXY = iMouse.xy + scrollOffset;\n    \n    fragColor = vec4(vec3(0.5), 1.0);// background\n\n    // compute the normal for this fragment by subdividing.\n    float wsize = iResolution.x;\n    vec2 normal = vec2(0.);\n    float influenceFactor = 1.0;\n    \n    float colorMix = 1.0;\n    \n    for(int i = 0; i < iterationCount; ++ i)\n    {\n        vec3 w = worley(uv, wsize);\n\t\tnormal.xy += influenceFactor * w.xy;\n        wsize *= iterationSizeFactor;\n        influenceFactor *= iterationNormalInfluenceFactor;\n\n        float tintAmt = w.z / wsize;\n        \n        // i don't really understand why this looks so much better at low size factors.\n        if(iterationSizeFactor < 0.5)\n\t        tintAmt = tintAmt * iterationSizeFactor;\n        \n#if COLOR_MODE == 1\n        fragColor = vec4(mix(fragColor.rgb, getPalette(i), tintAmt * colorMix), 1.0);\n#endif\n#if COLOR_MODE == 2\n        fragColor = vec4(vec3(tintAmt), 1.0);\n#endif\n        colorMix *= iterationColorInfluenceFactor;\n    }\n    \n    // lighting\n#if COLOR_MODE != 2\n    vec3 lightPos = vec3(lightPosXY, iResolution.x / 2.);\n    vec4 lightColor = vec4(0.95,0.9,0.9,1.);\n    vec4 ambientColor = vec4(0.5,0.5,0.9,1.);\n\tfragColor = applyLighting(fragColor, uv, vec3(normal, 2.5), lightPos, lightColor, ambientColor);\n    \n    // show light position.\n    if(distance(uv, lightPosXY) < iResolution.x / 75.)\n        fragColor = vec4(1.0,1.0,0.,1.0);\n#endif\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlB3WV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1276, 2077, 2101, 2101, 2272], [2276, 2276, 2297, 2297, 2326], [2327, 2327, 2348, 2348, 2387], [2388, 2388, 2407, 2407, 2490], [2492, 2522, 2551, 2551, 3154], [3157, 3157, 3265, 3265, 3775], [3777, 3777, 3834, 3834, 5586]], "test": "valid"}
{"id": "MlBGW3", "name": "Liquid Tunnel -\"helloWorld\"Shdr", "author": "patu", "description": "Hi!\nI just started playing with shaders.", "tags": ["2d", "tunnel"], "likes": 10, "viewed": 779, "published": "Public API", "date": "1432937603", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float k;\nfloat centerBlack;\nfloat depth;\nfloat rotation;\n\nvec2 p;\nvec2 uv;\nvec3 textColor;\n\nconst float pi = 3.1416;\nconst float pi2 = 3.1416 * 2.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n   \t\n    k = iTime / 1.8;\n\tuv = fragCoord.xy / iResolution.xy;\n    p = uv - .5;\n    \n    float dfc = distance(vec2(.5), uv);\n    \n    depth = 1.0 / dfc ;\n    rotation = atan(p.y, p.x) / pi + sin(k / 4.0) + depth * cos(k * 0.3) * 0.2;\n        \n    centerBlack = (1.00 - cos(dfc * pi2)) * 0.1;\n    \n    vec2 pos = vec2(\n            mod(depth + k * 8.0, pi2), \n        \trotation \n    );\n    \n    float x = pos.x;\n    float y = pos.y;\n    \n    float r = (25.0 + (sin(x - 0.5) + sin(y * pi) * 18.0) - sin(x * pi) * 19.0) * 0.3;\n\tfloat g = 1.0 + (sin(x + 0.6) * sin(y * pi ) );\n\tfloat b = 5.0 + (sin(x * 0.7) + sin(y * pi) * 5.0);\n        \n    textColor = vec3(r, b / 3.0, b) * vec3(b, r, g) / 5.0 ;\n    \n    fragColor = vec4(textColor, 1.0) * centerBlack;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlBGW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[150, 150, 207, 207, 960]], "test": "valid"}
{"id": "MlBGWG", "name": "Carved Trees", "author": "Kali", "description": "Mostly coded with \"Shader Editor\" android app, some time ago. Mouse enabled.", "tags": ["2d", "fractal", "3dlighting"], "likes": 20, "viewed": 595, "published": "Public", "date": "1431816558", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//(if mousex+y>0...) \n#define time iTime*.5\n#define resolution iResolution.xy\n\nvec3 ldir;\nfloat ot;\n\nfloat tree(vec2 p) {\n\tp=p*.72+vec2(0.,1.32);\n\tot=1000.;\n\tfor (int i=0; i<28; i++) {\n\t\tfloat l=dot(p,p);\n\t\tot=min(ot,abs(l-.6));\n\t\tp.x=abs(p.x);\n\t\tp=p/l*2.-vec2(.38,.2);\n  \n\t}\n\treturn dot(p,p)*.02;\n}\n\nfloat light(vec2 p) {\n\tvec2 d=vec2(0.,.003);\n\tfloat d1=tree(p-d.xy)-tree(p+d.xy);\n\tfloat d2=tree(p-d.yx)-tree(p+d.yx);\t\n  \tvec3 n1=vec3(0.,d.y,d1);\n  \tvec3 n2=vec3(d.y,0.,d2);\n  \tvec3 n=normalize(cross(n1,n2));\n  \tfloat diff=max(0.,dot(ldir,n))*.6;\n\tvec3 r=reflect(vec3(0.,0.,1.),ldir);\n\tfloat spec=pow(max(0.,dot(r,n)),25.)*.4;\n  \treturn (diff+spec+.15)*max(0.4,1.-tree(p));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = gl_FragCoord.xy/resolution.xy-.5;\n\tvec2 aspect=vec2(resolution.x/resolution.y,1.);\n    p*=aspect;\n  \tif (iMouse.z>0.) p+=3.*(iMouse.xy/iResolution.xy-.5);\n    p*=1.+sin(time)*.2;\n    float a=2.+cos(time*.3)*.5;\n    mat2 rot=mat2(sin(a),cos(a),-cos(a),sin(a));\n    p*=rot;\n    p+=vec2(sin(time),cos(time))*.2;\n\tvec3 lightpos=vec3(sin(time*3.)*.8,cos(time)*.9,-1.);\n\tlightpos.xy*=aspect*.5;\n\tldir=normalize(vec3(p,-tree(p))+lightpos);\n  \tfloat l=light(p);\n  \tot=max(1.-ot*.7,0.);\n\tvec3 col=l*vec3(ot*ot*1.45,ot*.9,ot*ot*.55);\n\tcol+=pow(max(0.,.2-length(p+lightpos.xy))/.2,3.)*vec3(1.2,1.1,1.);\n\tcol*=pow(max(0.,1.-length(p+lightpos.xy)*.3),2.5);\n\tfragColor = vec4(col+.03, 1.0 );\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlBGWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 101, 121, 121, 299], [301, 301, 322, 322, 678], [680, 680, 737, 737, 1427]], "test": "valid"}
{"id": "MlBGWK", "name": "Beware your eyes ", "author": "ManuManu", "description": "Just to show off to some friends what could be done with 2D shaders, with some simple code to start having things on your screen...\nI'm aware that it's ugly :)\nMade on GlSlSandbox here :\nhttp://glslsandbox.com/e#24464.1", "tags": ["2d", "ugly", "spiral"], "likes": 4, "viewed": 2487, "published": "Public API", "date": "1432379559", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n\nfloat rand( vec2 p )\n{\n\treturn fract(sin(dot(p.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat noise(vec2 _v, vec2 _freq)\n{\n\tfloat fl1 = rand(floor(_v * _freq));\n\tfloat fl2 = rand(floor(_v * _freq) + vec2(1.0, 0.0));\n\tfloat fl3 = rand(floor(_v * _freq) + vec2(0.0, 1.0));\n\tfloat fl4 = rand(floor(_v * _freq) + vec2(1.0, 1.0));\n\tvec2 fr = fract(_v * _freq);\n\n\t// linear interpolate\n\tfloat r1 = mix(fl1, fl2, fr.x);\n\tfloat r2 = mix(fl3, fl4, fr.x);\n\treturn mix(r1, r2, fr.y);\n}\n\nfloat perlin_noise(vec2 _pos, float _freq_start, float _amp_start, float _amp_ratio)\n{\n\tfloat freq = _freq_start;\n\tfloat amp = _amp_start;\n\tfloat pn = noise(_pos, vec2(freq, freq)) * amp;\n\tfor(int i=0; i<4; i++)\n\t{\n\t\tfreq *= 2.0;\n\t\tamp *= _amp_ratio;\n\t\tpn += (noise(_pos, vec2(freq, freq)) * 2.0 - 1.0) * amp;\n\t}\n\treturn pn;\n}\n\n\n// disk :\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ( fragCoord.xy / iResolution.xy );\n\tuv -=.5;\n\tuv.x *= iResolution.x/ iResolution.y;\n\n\tvec3 col = vec3( .1, .9, .1 );\n\tif ( length( uv ) < .5 ) col = vec3( .9, .1, .1 );\n\tfragColor = vec4(col, 1.);\n}//*/\n/*\n\n// diamonds\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 uv = ( fragCoord.xy / iResolution.xy );\n\tuv -=.5;\n\tuv.x *= iResolution.x/ iResolution.y;\n\n\tfragColor = vec4(vec3( length(sin(20.*uv + sin(iTime)))), 1.);\n}//*/\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 uv = ( fragCoord.xy / iResolution.xy );\n\tuv -=.5;\n\tuv.x *= iResolution.x/ iResolution.y;\n\n\tfragColor = vec4(vec3( sin(length(40.0*uv))), 1.);\n}//*/\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 uv = ( fragCoord.xy / iResolution.xy );\n\tuv -=.5;\n\tuv.x *= iResolution.x/ iResolution.y;\n\n\tfragColor = vec4(vec3( sin( (-9. + .0*cos(iTime))*iTime + length(40.*uv))), 1.);\n}//*/\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 uv = ( fragCoord.xy / iResolution.xy );\n\tuv -=.5;\n\tuv.x *= iResolution.x/ iResolution.y;\n\n\tfragColor = vec4(vec3( sin(iTime + length(40.*uv))), 1.);\n\n\tgl_FragColor = vec4(vec3( sin(cos(time) + length(40.*uv))), 1.);\n}\n//*/\n/*\n// repeating quarter of circles :\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 uv = ( fragCoord.xy / iResolution.xy );\n\tuv -=.5;\n\tuv.x *= iResolution.x/ iResolution.y;\n\n\n\tfragColor = vec4(vec3( sin(cos(iTime) + length(40.*mod(3.*uv, 1.)))), 1.);\n}//*/\n/*\n// cool error :\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 uv = ( fragCoord.xy / iResolution.xy );\n\tuv -=.5;\n\tuv.x *= iResolution.x/ iResolution.y;\n\n\tfragColor = vec4(vec3( sin(cos(iTime) + length(40.*mod(3.*abs(uv), 1.)))), 1.);\n}//*/\n//repeating circles :\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 uv = ( fragCoord.xy / iResolution.xy );\n\tuv -=.5;\n\tuv.x *= iResolution.x/ iResolution.y;\n\n\tfragColor = vec4(vec3( sin(cos(iTime) +  length(40.*(mod(3.*uv, 1.)-.5)))), 1.);\n}//*/\n// combining everything : \nfloat Mylength(vec2 pos)\n{\n\treturn max(abs(pos.x), abs(pos.y));\n}\n\n// Spiral\n//#define F(x) (log(x))\n//#define F(x) (x <= 0.1 ? 10.*x : log(x))\n//#define F(x) 0.5*x\n#define F(x) (x)\n//#define F(x) pow(x,1.414213562373095)\n//#define F(x) pow(x,2.0)\n//#define F(x) pow(x,10.0)\n//#define F(x) pow(x,42.0)\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord.xy / iResolution.xy );\n\tuv -=.5;\n\tuv.x *= iResolution.x/ iResolution.y;\n\n\tconst float PI = 3.14159265358979323846264;\n\tfloat a = atan(uv.x, uv.y ) * 6./PI;\n\tfloat r = length(uv);\n\tfloat twist = fract(-4.*F(r)+iTime+a);\n\t\n\tfloat val = float(twist > .5);\n\tfragColor = vec4(vec3( val ), 1.);\n}\n//*/\n\n//*\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord.xy / iResolution.xy );\n\tuv -=.5;\n\t//uv.x += sin(iTime)*.005*cos( 80.*uv.y + 10.*iTime);\n\t//uv.x += cos(uv.x * .5*sin(2.*iTime));\n\t//uv.y += cos(uv.y * cos(iTime));\n\tuv.x *= iResolution.x/ iResolution.y;\n\n\tfloat val1 = sin(cos(3.*iTime) +  length(40.*(mod(3.*uv, 1.)-.5)));\n\tfloat val2 = sin(cos(5.*iTime) +  Mylength(40.*(mod(4.*uv, 1.)-.5)));\n\tfloat val3 = length(sin(20.*uv)+sin(10.*iTime));\n\n\tconst float PI = 3.14159265358979323846264;\n\tfloat a = atan(uv.x, uv.y ) * 6./PI;\n\tfloat r = length(uv);\n\tfloat twist = fract(-4.*r+iTime+a);\n\tfloat val = float(twist > .5);\n\t\n\tvec3 finalColor1 = vec3( val1 * val2+val3, val1+val2, val2-val1 );\n\tvec3 finalColor2 = vec3( (val1 + val2+val3)/3., (val1-val2)/2., val2*val1/2. );\n\t//vec3 finalColor2 = vec3(sin(50.*uv.y - 10.*iTime));\n\t\n\tvec3 FinalColor= mix( finalColor1, finalColor2, val) ;\n    //vec3 FinalColor = finalColor1;\n    FinalColor -= perlin_noise( uv, 10., 2., .5 );\n\tfragColor = vec4(FinalColor, 1.);\n}\n//*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlBGWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[3, 3, 25, 25, 93], [94, 94, 128, 128, 480], [482, 482, 568, 568, 808], [811, 2921, 2947, 2947, 2986], [3607, 3612, 3669, 3669, 4654]], "test": "valid"}
{"id": "MlBGz3", "name": "Bird Flock", "author": "dr2", "description": "Searching for all those fish", "tags": ["raymarching", "replication"], "likes": 5, "viewed": 950, "published": "Public API", "date": "1430817203", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Bird Flock\" by dr2 - 2015\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec3 i = floor (p);\n  vec3 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  float q = dot (i, cHashA3);\n  vec4 t1 = Hashv4f (q);\n  vec4 t2 = Hashv4f (q + cHashA3.z);\n  return mix (mix (mix (t1.x, t1.y, f.x), mix (t1.z, t1.w, f.x), f.y),\n     mix (mix (t2.x, t2.y, f.x), mix (t2.z, t2.w, f.x), f.y), f.z);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h)\n{\n  return max (length (p.xy - vec2 (rhi *\n     clamp (p.x / rhi, -1., 1.), 0.)) - rlo, abs (p.z) - h);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nint idObj;\nmat3 birdMat;\nvec3 qHit, sunDir, waterDisp, cloudDisp;\nfloat tCur, birdLen, vbOff, wngAng, wngAngL;\nbool lastRow, isColr, qIsColr;\nconst float dstFar = 100.;\nconst int idWing = 21, idBdy = 22, idEye = 23, idBk = 24;\n\nvec3 SkyBg (vec3 rd)\n{\n  const vec3 sbCol = vec3 (0.1, 0.1, 0.6);\n  vec3 col;\n  col = sbCol + 0.2 * pow (1. - max (rd.y, 0.), 5.);\n  return col;\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  const float skyHt = 150.;\n  vec3 col;\n  float cloudFac;\n  if (rd.y > 0.) {\n    ro += cloudDisp;\n    vec2 p = 0.01 * (rd.xz * (skyHt - ro.y) / rd.y + ro.xz);\n    float w = 0.65;\n    float f = 0.;\n    for (int j = 0; j < 4; j ++) {\n      f += w * Noisefv2 (p);\n      w *= 0.5;\n      p *= 2.3;\n    }\n    cloudFac = clamp (5. * (f - 0.5) * rd.y + 0.1, 0., 1.);\n  } else cloudFac = 0.;\n  float s = max (dot (rd, sunDir), 0.);\n  col = SkyBg (rd) + (0.35 * pow (s, 6.) + 0.65 * min (pow (s, 256.), 0.3));\n  col = mix (col, vec3 (0.75), cloudFac);\n  return col;\n}\n\nfloat WaterHt (vec3 p)\n{\n  p *= 0.05;\n  p += waterDisp;\n  float ht = 0.;\n  const float wb = 1.414;\n  float w = wb;\n  for (int j = 0; j < 6; j ++) {\n    w *= 0.5;\n    p = wb * vec3 (p.y + p.z, p.z - p.y, 2. * p.x) + 10. * waterDisp;\n    ht += w * abs (Noisefv3 (p) - 0.5);\n  }\n  return ht;\n}\n\nvec3 WaterNf (vec3 p, float d)\n{\n  vec2 e = vec2 (max (0.01, 0.001 * d * d), 0.);\n  float ht = WaterHt (p);\n  return normalize (vec3 (ht - WaterHt (p + e.xyy), e.x, ht - WaterHt (p + e.yyx)));\n}\n\nfloat BirdWingDf (vec3 p, float dMin)\n{\n  vec3 q, qh;\n  float d, dd, a, wr;\n  float wSegLen = 0.15 * birdLen;\n  float wChord = 0.3 * birdLen;\n  float wSpar = 0.03 * birdLen;\n  float fTap = 8.;\n  float tFac = (1. - 1. / fTap);\n  q = p - vec3 (0., 0., 0.3 * birdLen);\n  q.x = abs (q.x) - 0.1 * birdLen;\n  float wf = 1.;\n  a = lastRow ? wngAngL : wngAng;\n  d = dMin;\n  qh = q;\n  for (int k = 0; k < 5; k ++) {\n    q.xy = Rot2D (q.xy, a);\n    q.x -= wSegLen;\n    wr = wf * (1. - 0.5 * q.x / (fTap * wSegLen));\n    dd = PrFlatCylDf (q.zyx, wr * wChord, wr * wSpar, wSegLen);\n    if (k < 4) {\n      q.x -= wSegLen;\n      dd = min (dd, PrCapsDf (q, wr * wSpar, wr * wChord));\n    } else {\n      q.x += wSegLen;\n      dd = max (dd, PrCylDf (q.xzy, wr * wChord, wSpar));\n      dd = min (dd, max (PrTorusDf (q.xzy, 0.98 * wr * wSpar,\n         wr * wChord), - q.x));\n    }\n    if (dd < d) { d = dd;  qh = q; }\n    a *= 1.03;\n    wf *= tFac;\n  }\n  if (d < dMin) { dMin = min (dMin, d);  idObj = idWing;  qHit = qh;\n     qIsColr = isColr; }\n  return dMin;\n}\n\nfloat BirdBodyDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, a, wr;\n  float bkLen = 0.2 * birdLen;\n  q = p;\n  wr = q.z / birdLen;\n  float tr, u;\n  if (wr > 0.5) {\n    u = (wr - 0.5) / 0.5;\n    tr = 0.17 - 0.11 * u * u;\n  } else {\n    u = clamp ((wr - 0.5) / 1.5, -1., 1.);\n    u *= u;\n    tr = 0.17 - u * (0.34 - 0.18 * u); \n  }\n  d = PrCapsDf (q, tr * birdLen, birdLen);\n  if (d < dMin) {\n    dMin = d;  idObj = idBdy;  qHit = q;\n  }\n  q = p;\n  q.x = abs (q.x);\n  wr = (wr + 1.) * (wr + 1.);\n  q -= birdLen * vec3 (0.3 * wr, 0.1 * wr, -1.2);\n  d = PrCylDf (q, 0.009 * birdLen, 0.2 * birdLen);\n  if (d < dMin) { dMin = min (dMin, d);  idObj = idBdy;  qHit = q; }\n  q = p;\n  q.x = abs (q.x);\n  q -= birdLen * vec3 (0.08, 0.05, 0.9);\n  d = PrSphDf (q, 0.04 * birdLen);\n  if (d < dMin) { dMin = d;  idObj = idEye;  qHit = q; }\n  q = p;  q -= birdLen * vec3 (0., -0.015, 1.15);\n  wr = clamp (0.5 - 0.3 * q.z / bkLen, 0., 1.);\n  d = PrFlatCylDf (q, 0.2 * wr * bkLen, 0.2 * wr * bkLen, bkLen);\n  if (d < dMin) { dMin = d;  idObj = idBk;  qHit = q; }\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 g, q;\n  float szArray, exArray, hGap, bb;\n  szArray = 7.;\n  exArray = floor (szArray / 2.);\n  hGap = 1.;\n  bb = PrBoxDf (p, vec3 (szArray * hGap, 4. * hGap, szArray * hGap));\n  g.xz = floor ((p.xz + hGap) / (2. * hGap));\n  p.xz -= g.xz * 2. * hGap;\n  p.y += vbOff * mod (g.x + g.z, 2.);\n  lastRow = (g.x == exArray || g.z == exArray);\n  isColr = (g.x == 0. && g.z == 0.);\n  p.xz += 0.2 * vbOff * mod (g.xz, 2.);\n  q = birdMat * p;\n  return max (0.8 * BirdBodyDf (q, BirdWingDf (q, dstFar)), bb);\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec3 e = vec3 (0.001, -0.001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * vec3 (v.y, v.z, v.w));\n}\n\nvec4 BirdCol (vec3 n)\n{\n  vec3 col, nn;\n  float spec;\n  spec = 0.2;\n  if (idObj == idWing) {\n    float gw = 0.15 * birdLen;\n    float w = mod (qHit.x, gw);\n    w = SmoothBump (0.15 * gw, 0.65 * gw, 0.1 * gw, w);\n    col = qIsColr ? mix (vec3 (1., 0., 0.), vec3 (0., 1., 0.), w) :\n       mix (vec3 (1.), vec3 (0.1), w);\n  } else if (idObj == idEye) {\n    col = vec3 (0., 0., 0.6);\n    spec = 0.7;\n  } else if (idObj == idBdy) {\n    nn = birdMat * n;\n    col = mix (mix (vec3 (1., 0.8, 0.8), vec3 (0.05, 0.2, 0.05),\n       smoothstep (0.5, 1., nn.y)), vec3 (0., 0., 0.8),\n       1. - smoothstep (-1., -0.3, nn.y));\n  } else if (idObj == idBk) {\n    col = vec3 (1., 0.4, 0.1);\n  }\n  return vec4 (col, spec);\n}\n\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int i = 0; i < 50; i++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, 20. * h / d);\n    d += 0.01;\n    if (h < 0.001) break;\n  }\n  return clamp (sh, 0., 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 vn, col;\n  float dstHit, reflFac, htWat, dw, bk, sh;\n  int idObjT;\n  htWat = -2.5;\n  reflFac = 1.;\n  col = vec3 (0.);\n  idObj = -1;\n  dstHit = ObjRay (ro, rd);\n  if (rd.y < 0. && dstHit >= dstFar) {\n    dw = - (ro.y - htWat) / rd.y;\n    ro += dw * rd;\n    rd = reflect (rd, WaterNf (ro, dw));\n    ro += 0.01 * rd;\n    idObj = -1;\n    dstHit = ObjRay (ro, rd);\n    reflFac *= 0.7;\n  }\n  if (idObj < 0) dstHit = dstFar;\n  if (dstHit >= dstFar) col = reflFac * SkyCol (ro, rd);\n  else {\n    ro += rd * dstHit;\n    idObjT = idObj;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    col4 = BirdCol (vn);\n    sh = ObjSShadow (ro, sunDir);\n    bk = max (dot (vn, - normalize (vec3 (sunDir.x, 0., sunDir.z))), 0.);\n    col = reflFac * (col4.rgb * (0.3 + 0.2 * bk +\n       0.7 * sh * max (dot (vn, sunDir), 0.)) +\n       sh * col4.a * pow (max (0., dot (sunDir, reflect (rd, vn))), 64.));\n  }\n  col = sqrt (clamp (col, 0., 1.));\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 uv = 2. * (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n  tCur = iTime;\n  mat3 vuMat;\n  vec3 ro, rd, ori, ca, sa;\n  sunDir = normalize (vec3 (cos (0.031 * tCur), 0.5, sin (0.031 * tCur)));\n  waterDisp = 0.005 * tCur * vec3 (-1., 0., -1.);\n  cloudDisp = 10. * tCur * vec3 (-1., 0., -1.);\n  birdLen = 0.4;\n  vbOff = 0.8 * birdLen * cos (0.3 * tCur);\n  wngAng = -0.1 + 0.2 * sin (7. * tCur);\n  wngAngL = -0.1 + 0.25 * sin (12. * tCur);\n  ori = vec3 (0., 0.75 * pi, 0.25 * sin (0.77 * tCur));\n  ca = cos (ori);\n  sa = sin (ori);\n  birdMat = mat3 (ca.z, - sa.z, 0., sa.z, ca.z, 0., 0., 0., 1.) *\n     mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n     mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y);\n  ori = vec3 (0.1 + 0.2 * cos (0.07 * tCur), -0.25 * pi - 0.033 * tCur, 0.);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.z, - sa.z, 0., sa.z, ca.z, 0., 0., 0., 1.) *\n     mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n     mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y);\n  ro = vec3 (0., 0., - 15. - 6. * cos (0.1 * tCur)) * vuMat;\n  rd = normalize (vec3 (uv, 4.5)) * vuMat;\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlBGz3.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 265, 289, 289, 336], [338, 338, 363, 363, 542], [544, 544, 569, 569, 875], [877, 877, 934, 934, 1017], [1019, 1019, 1049, 1049, 1123], [1125, 1125, 1157, 1157, 1252], [1254, 1254, 1287, 1287, 1314], [1316, 1316, 1359, 1359, 1432], [1434, 1434, 1476, 1476, 1527], [1529, 1529, 1588, 1588, 1692], [1694, 1694, 1740, 1740, 1797], [2027, 2027, 2049, 2049, 2173], [2175, 2175, 2207, 2207, 2765], [2767, 2767, 2791, 2791, 3057], [3059, 3059, 3091, 3091, 3253], [3255, 3255, 3294, 3294, 4299], [4301, 4301, 4340, 4340, 5361], [5363, 5363, 5385, 5385, 5890], [5892, 5892, 5925, 5925, 6101], [6103, 6103, 6124, 6124, 6341], [6343, 6343, 6366, 6366, 7049], [7052, 7052, 7089, 7089, 7300], [7302, 7302, 7337, 7337, 8287], [8289, 8289, 8345, 8345, 9511]], "test": "valid"}
{"id": "Mlj3zc", "name": "p6mm inversion with star pattern", "author": "curena", "description": "A new version of a previous shader, now with an islamic star pattern (p6mm symmetry and hyperbolic inversion). The pattern is taken from \"Reales Alcázares\" in Seville (Spain). Comment '#define INVERSION' (line 10) to see the pattern without inversion.", "tags": ["pattern", "tilling", "hyperbolic", "wallpaper", "p6mm"], "likes": 12, "viewed": 602, "published": "Public API", "date": "1431170325", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"p6mm inversion\" by Carlos Ureña - 2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// *******************************************************************\n// global defs and params\n//\n\n// uncomment to perform animated circle inversion\n#define INVERSION\n\n// uncomment to view the fundamental region\n//#define HILIGHT_FUNDAMENTAL        \n\n// uncomment to view stripe animation\n// #define ANIMATION\n\n// ----------------------------------------------------------------\n// parameters and pre-calculated constants\n\nconst int \n    n          = 5 ; // square root of the number of samples per pixel (for A.A.)\n                     // full supersample anti-aliasing is done\n\nconst float \n    sqr2       = 1.41421356237, // square root of 2\n    sqr3       = 1.73205080756, // square root of 3.0\n    sqr2_inv   = 1.0/sqr2 ,\n    sqr3_inv   = 1.0/sqr3 ,\n    cos30      = 0.86602540378, // cos(30 degrees)\n    sin30      = 0.50000000000, // sin(30 degrees)\n    \n    \n#ifdef INVERSION\n    l           = 0.1,          // length of triangle in NDC (mind --> 1.0)\n#else\n#ifdef HILIGHT_FUNDAMENTAL            \n    l           = 5.2,\n#else    \n    l           = 5.5,          // length of triangle in NDC (mind --> 1.0)\n#endif    \n#endif\n    l_inv       = 1.0/l ,       // length inverse\n    line_w      = 0.03,         // line width for basic symmetry lines render\n    speedFactor = 1.0 ,         // speed factor for inversion animation (greater->faster)\n    sw          = 0.020 ;       // stripes half width for islamic star pattern\n\nconst vec2  \n    u        = 1.0*vec2( 1.0, 0.0  ) ,          // grid basis: U vector\n    v        = 0.5*vec2( 1.0, sqr3 ) ,          // grid basis: V vector\n    u_dual   = 1.0*vec2( 1.0, -sqr3_inv ) ,     // dual grid basis: U vector\n    v_dual   = 2.0*vec2( 0.0,  sqr3_inv ) ,     // dual grid basis: V vector\n    tri_cen  = vec2( 0.5, 0.5*sqr3_inv ) ;      // triangle center\nvec2\n    center ; //= 0.5*iResolution.xy ;             // viewport center in DC \nfloat \n    mind ,   // = min(iResolution.x,iResolution.y),// minimun viewport dimension in pixels \n    secs ;   // == iTime*speedFactor ;  // global time, scaled by speed factor\n    \n// -----------------------------------------------------------------------------------\n// point orbit transformation parameters\nint \n    nMirrorOdd = 0 , \n    nMirror    = 0 ,\n\tnGridX     = 0 , \n    nGridY     = 0 ;\n\n\n// *******************************************************************************\n// functions\n\n\nfloat NormCos( float w )\n{\n \treturn 0.5*(1.0+cos(secs*w)) ;   \n}\n\n\n// -------------------------------------------------------------------------------\n// mirror reflection of 'p' around and axis through 'v1' and 'v2'\n// (only for points to right of the line from v1 to v2)\n//\nvec2 Mirror( vec2 p, vec2 v1, vec2 v2 )\n{\n \tvec2   s = v2-v1 ,\n           n = normalize(vec2( s.y, -s.x )) ;\n    float  d = dot(p-v1,n) ;\n    \n    if ( 0.0 <= d )\n    {\n       nMirrorOdd = 1-nMirrorOdd ;\n       nMirror = nMirror+1 ;\n       return p-2.0*d*n ;\n    }\n    else\n       return p ;\n}\n// -------------------------------------------------------------------\n// Signed perpendicular distance from 'p' to line through 'v1' and 'v2'\n\nfloat SignedDistance( vec2 p, vec2 v1, vec2 v2 )\n{\n \tvec2   s = v2-v1 ,\n           n = normalize(vec2( s.y, -s.x )) ;\n    return dot(p-v1,n) ;\n}\n// -------------------------------------------------------------------\n// un-normalized signed distance to line\n\nfloat UnSignedDistance( vec2 p, vec2 v1, vec2 v2 )\n{\n \tvec2   s = v2-v1 ,\n           un = vec2( s.y, -s.x ) ;\n    return dot(p-v1,un) ;\n}\n// -------------------------------------------------------------------\n// Signed perpendicular distance from 'p' to polyline from 'v1' \n// to 'v2' then to 'v3'\n\nfloat DoubleSignedDistance( vec2 p, vec2 v1, vec2 v2, vec2 v3 )\n{\n \t\n    vec2  dir1 = v2 + normalize(v1-v2),\n          dir3 = v2 + normalize(v3-v2);\n        \n    vec2  vm = 0.5*(dir1+dir3) ;\n    \n    float dm = UnSignedDistance( p, v2, vm ) ;\n    \n    if ( dm >= 0.0 )\n   \t\treturn SignedDistance( p, v1, v2 ) ;\n   \telse\n        return SignedDistance( p, v2, v3 ) ; \n}\n// -------------------------------------------------------------------------------\n// Takes 'p0' to the group's fundamental region, returns its coordinates in that region\n\nvec2 p6mm_ToFundamental( vec2 p0 ) \n{\n    nMirrorOdd = 0 ;\n    nMirror    = 0 ;\n    \n    // p1 = fragment coords. in the grid reference frame\n    \n    vec2 p1 = vec2( dot(p0,u_dual), dot(p0,v_dual) );\n    \n    // p2 = fragment coords in the translated grid reference frame \n    \n    vec2 p2 = vec2( fract(p1.x), fract(p1.y) ) ;\n    \n    nGridX = int(p1.x-p2.x) ; // largest integer g.e. to p1.x\n    nGridY = int(p1.y-p2.y) ; // largest integer g.e. to p2.x\n    \n    // p3 = barycentric coords in the translated triangle\n    // (mirror, using line x+y-1=0 as axis, when point is right and above axis)\n    \n    vec2 p3 = Mirror( p2, vec2(1.0,0.0), vec2(0.0,1.0) );\n    \n    // p4 = p3, but expressed back in cartesian coordinates\n    \n    vec2 p4 = p3.x*u + p3.y*v ;\n    \n    // p7 = mirror around the three lines through the barycenter, perp. to edges.\n    \n    vec2 p5 = Mirror( p4, vec2(0.5,0.0), tri_cen );\n    vec2 p6 = Mirror( p5, vec2(1.0,0.0), tri_cen );\n    vec2 p7 = Mirror( p6, tri_cen, vec2(0.0,0.0) );\n  \n    return p7 ;\n}\n\n// --------------------------------------------------------------------\n// A possible distance function\n\nfloat DistanceFunc( float d )\n{\n   return 1.0-smoothstep( line_w*0.85, line_w*1.15, d );   \n}\n\n// -------------------------------------------------------------------------------\n// Point color for basic symmetry lines in (r,g,b)\n\nvec4 p6mm_SimmetryLines( vec2 p_ndc )\n{\n\n    vec2 pf = p6mm_ToFundamental( p_ndc );\n    \n    float d1 = abs(pf.y),\n          d2 = abs(pf.x-0.5),\n          d3 = abs( SignedDistance( pf, tri_cen, vec2(0.0,0.0) ) );\n     \n    vec4 res = vec4( 0.0, 0.0, 0.0, 1.0 ) ;\n        \n    res.r = DistanceFunc(d2);\n    res.g = DistanceFunc(d1);\n    res.b = DistanceFunc(d3);\n    \n    return res ;    \n}\n\n// ---------------------------------------------------------------------\n// Stripe half width for star pattern\n\nvec4 Stripe( float d )\n{\n   if ( d > sw*0.85 )\n     return vec4( 0.0,0.0,0.0,1.0 );\n   else\n     return vec4(1.0,1.0,1.0,1.0)  ;\n    \n    \n}\n\n \n\n\n// ----------------------------------------------------------------------\n// Converts from device (pixel) coordinates to normalized coordinates\n\nvec2 DCToNDC( vec2 p_dc )\n{\n    // compute NDC:\n    vec2 p = l_inv*(p_dc - center)/mind ;\n\n#ifdef HILIGHT_FUNDAMENTAL    \n    p = p + vec2(0.25*l, 0.25*l*sqr3_inv) ;\n#endif\n    \n    // rotate 30 deg. and return\n    vec2 res= vec2( p.x*cos30 - p.y*sin30,\n                 p.y*cos30 + p.x*sin30 );\n                    \n    // flip (just to match photo)\n    return vec2( res.y, res.x ) ;\n}\n// --------------------------------------------------------------------\n// When activated, performs the circle inversion\n\nvec2 Inversion( vec2 p, vec2 cen )\n{\n#ifdef INVERSION     \n   vec2  vr   = p  -cen ;\n   float r    = length( vr );\n   \n    return cen + normalize(vr)/(r*0.1) \n              + secs/4.0*vec2(1.0,0.5)  \n              + 1.0*l*vec2( sin(secs/40.0), cos(secs/42.0) ) ;\n#else\n   return p*13.0 ;  // an arbitrary constant to allow seeing a bigger region\n#endif\n}\n\n// ---------------------------------------------------------------------\n// Color for islamic star pattern\n\nvec4 p6mm_Stripes( vec2 p_ndc )\n{\n    vec2 pf = p6mm_ToFundamental( p_ndc );\n    vec2 c  = tri_cen ;\n    \n    // constants defining the stripes \n    float \n        f   = 0.30 ,\n        fs1 = 0.14 ,\n        s1  = fs1*c.x,\n        s2  = 0.5*s1 ;\n        \n    // stripes vertexes\n    vec2 \n        // upper strip\n        u1 = vec2( f*c.x, 0.0 ) ,\n        u2 = vec2( c.x, (1.0-f)*c.y ),\n        \n        // lower strip\n        l1 = vec2( c.x, s1+s2 ),\n        l2 = vec2( c.x-s2, s1 ),\n        l3 = vec2( sqr3*s1, s1 ),\n        \n        // right strip\n        r1 = vec2( c.x-s1, (1.0-fs1)*c.y ),\n        r2 = vec2( c.x-s1, s2 ) ,\n        r3 = vec2( c.x-s1-s2, 0.0 ),\n        \n    \t// origin star strip\n        mm = vec2( s1*(sqr3-1.0/3.0), s1*(1.0-sqr3_inv) );\n    \n#ifdef ANIMATION    \n    const float k = 0.3 ;\n    \n    vec2 u2_despl = vec2(c.x,NormCos(1.0*k)*c.y), \n         u1_despl = vec2(NormCos(2.0*k)*c.x, 0.0),\n         l1_despl = vec2(c.x,s1+NormCos(3.0*k)*(c.y-s1)), \n         r3_despl = vec2((1.0-s1)*NormCos(5.0*k)*c.x, 0.0);\n    \n    u1 = 0.5*(u1+u1_despl) ;\n    u2 = 0.5*(u2+u2_despl) ;\n    l1 = 0.5*(l1+l1_despl) ;\n    r3 = 0.5*(r3+r3_despl);\n#endif    \n                    \n    // signed and unsigned distances to stripes:\n    \n    float\n        d1s = SignedDistance( pf, u1, u2 ) ,\n        d2s = DoubleSignedDistance( pf, l1, l2, l3 ) ,\n        d3s = DoubleSignedDistance( pf, r1, r2, r3 ) ,\n        d4s = DoubleSignedDistance( pf, u1, mm, l3 ) ,\n        d1  = abs( d1s ),\n        d2  = abs( d2s ),\n        d3  = abs( d3s ),\n        d4  = abs( d4s );\n    \n   \n    // stripes inclusion\n    bool in1, in2, in3, in4 ;\n    \n    if ( nMirrorOdd == 0 )\n    {\n        in1 = (d1 < sw) && ! (d2 < sw) && ! (d4 < sw);\n        in2 = (d2 < sw) && ! (d3 < sw);\n        in3 = (d3 < sw) && ! (d1 < sw);\n        \n        in4 = (d4 < sw) && ! (d2 < sw);\n    }\n    else\n    {\n        in1 = (d1 < sw) && ! (d3 < sw) ;\n        in2 = (d2 < sw) && ! (d1 < sw) && ! (d4 < sw);;\n        in3 = (d3 < sw) && ! (d2 < sw);\n        \n        in4 = (d4 < sw) && ! (d1 < sw);\n    } \n    \n    vec4 col ;\n    \n    // compute final color\n    \n    if ( in1 )      \n        col = Stripe( d1 ) ;\n    else if ( in2 ) \n        col = Stripe( d2 ) ;\n    else if ( in3 ) \n        col = Stripe( d3 ) ; \n    else if ( in4 )\n        col = Stripe( d4 ) ;   \n    else if ( d2s < 0.0 && d3s < 0.0 )\n        col = vec4( 0.0, 0.4, 0.0, 1.0 ) ;\n    else if ( d1s < 0.0 && d2s < 0.0 || d1s <0.0 && d3s < 0.0 )\n        col = vec4( 0.1, 0.1, 0.1, 1.0 );\n    else if ( d1s < 0.0 || d2s < 0.0 )\n        col = vec4( 0.0, 0.4, 0.9, 1.0 );   \n    else    \n        col = vec4( 0.6, 0.0, 0.0, 1.0 ) ; \n        \n#ifdef HILIGHT_FUNDAMENTAL        \n    if ( nMirror != 0 || nGridX != 0 || nGridY != 0 )\n     \tcol = 0.9*vec4(0.5,0.5,0.5,1) + 0.1*col ;   \n#endif\n        \n    return col ;\n}\n                  \n// ------------------------------------------------------------\n// islamic star pattern, for a point in DC coordinates\n\nvec2 mou ; //= DCToNDC( 0.5*iResolution.xy ); // mouse pressed position (==center before pressing)\n                  \nvec4 p6mm_Stripes_dc( vec2 p_dc )                 \n{\n  vec2 p_ndc = Inversion( DCToNDC( p_dc ), mou );\n  return p6mm_Stripes( p_ndc ) ;          \n}\n\n// --------------------------------------------------------------------\n// camera in world coordinates\n// (in world coordinates, Z is the vertical direction)\n\nfloat near = 1.7 ;\n\nvec3 eye_pos = vec3( -1.0, -1.5, 1.0 ),\n     look_at = vec3( 0.0, 0.0, 0.0 ),\n     eye_vup = vec3( 0.0, 0.0, 1.0 );\n\nvec3 eye_z    , //= normalize( eye_pos-look_at ) ,\n     eye_x   , //= normalize( cross( eye_vup, eye_z ) ),\n     eye_y   ; //= normalize( cross( eye_z, eye_x ) ); \n\n// -------------------------------------------------------------------------------\n\nvec3 GetDir( vec2 p_dc )\n{\n    vec2        p_ndc = 2.0*(p_dc-center)/mind ;      \n    vec3        dir   = normalize( p_ndc.x*eye_x \n                                   + p_ndc.y*eye_y \n                                   - near*eye_z );\n    const float wd    = 0.3 ;\n    float       c     = cos( iTime*wd ), \n                s     = sin( iTime*wd ) ;\n     \n    return vec3(  dir.x*c - dir.y*s,\n                  dir.y*c + dir.x*s,\n                  dir.z);\n}\n\n// -------------------------------------------------------------------------------\n\nvec4 Sky( vec3 ndir ) // ndir == normalized direction\n{\n   float z = max( ndir.z, 0.0 ) ;   \n   return vec4( 0.5,0.5,0.5, 1.0) + z*0.5*vec4( 0.3, 0.4, 0.5, 1.0 ) ;\n    \n}\n\nfloat Luminance( vec4 col )\n{\n   return col.r ; //0.3333*( col.r+col.g+col.b ) ;   \n    \n}\n\n// -------------------------------------------------------------------------------\n\nvec3 GetNormal( vec2 pos )\n{\n    const float d = 0.003 ;   \n    \n    vec2 dx = vec2( d, 0.0 ),\n         dy = vec2( 0.0, d );\n    float h0  = Luminance( p6mm_Stripes( pos )),\n          hdx = Luminance( p6mm_Stripes( pos+dx )),\n          hdy = Luminance( p6mm_Stripes( pos+dy ));\n    vec3 vdx = vec3( d, 0.0, 2.0*(hdx-h0) ),\n         vdy = vec3( 0.0, d, 2.0*(hdy-h0) );\n    \n    vec3 nor = normalize( cross( vdx, vdy ) );\n\n    if ( nor.z < 0.0 ) nor = -nor ;\n    return nor ;\n}\n\n// -------------------------------------------------------------------------------\n\nstruct TraceState\n{\n    vec3  ray_org, \n          ray_dir,\n          hit_pos,\n          hit_nor ;\n    float hit_col,\n          tmin ;\n          \n    \n} ;\n    \nvoid BasePlane( inout TraceState ts )\n{\n    if ( ts.ray_dir.z > 0.0 ) // ray to the sky\n       return ; \n    \n    // find distance (t) to intersection with plane z=0\n   float t = - ts.ray_org.z / ts.ray_dir.z ;\n    \n   if ( t < 0.0 ) // t must be positive\n       return  ; // use red to flag an error\n    \n   // if t is further away than previous, exit\n   if ( ts.tmin >= 0.0 )\n   if ( t > ts.tmin )\n       return ;\n       \n    // intersection point\n   vec3 p_int = ts.ray_org + t*ts.ray_dir ; \n    \n  \n   // if out limits, return\n   const float hs = 60.0 ;  \n   if ( abs( p_int.x ) > hs || abs( p_int.y ) > hs )\n       return ;\n    \n   // convert to ndc and do inversion\n   vec2 p_int_ndc = Inversion( 0.5*p_int.xy, vec2(0.0,0.0) ) ;\n   vec4 col = p6mm_Stripes( p_int_ndc ) ;\n   \n   // compute normal\n   vec3 nor = GetNormal( p_int_ndc ); \n    //nor = vec3( 0.0, 0.0, 1.0 );\n    \n    \n}\n\n// ------------------------\nvec4 RayTrace_dc( vec2 p_dc )\n{\n   vec3 ray_org = eye_pos,\n        ray_dir = GetDir( p_dc ) ;\n   \n   if ( ray_dir.z > 0.0 ) // ray to the sky\n       return vec4( 0.5, 0.5, 0.8, 1.0 ); \n    \n    // find distance (t) to intersection with plane z=0\n   float t = - ray_org.z / ray_dir.z ;\n    \n   if ( t < 0.0 ) // t must be positive\n       return Sky( ray_dir) ; // use red to flag an error\n    \n   vec3 p_int = ray_org + t*ray_dir ;  // intersection point\n    \n  \n   // if out limits, return\n   const float hs = 60.0 ;  \n   if ( abs( p_int.x ) > hs || abs( p_int.y ) > hs )\n       return vec4( 0.0, 0.0, 1.0, 1.0 ) ;//Sky( ray_dir ) ;\n    \n   // convert to ndc and do inversion\n   vec2 p_int_ndc = Inversion( 0.5*p_int.xy, vec2(0.0,0.0) ) ;\n   vec4 col = p6mm_Stripes( p_int_ndc ) ;\n   \n   // compute normal\n   vec3 nor = GetNormal( p_int_ndc ); \n    //nor = vec3( 0.0, 0.0, 1.0 );\n   \n   // dir to light\n   vec3 ldir = normalize( vec3( 1.0, 0.2, 1.0 ) ) ;\n    \n   // vector to viewer (and reflected)\n   vec3 vv = normalize( -ray_dir );\n    \n   if ( vv.z < 0.0 ) vv = -1.0*vv ;\n   vec3 vvr = normalize(vv- 2.0*dot( vv,nor)*nor) ;\n    \n   // MIL\n   float nl = max( 0.0, dot(nor,ldir) ),\n         rv = max( 0.0, dot(ldir,vvr) ),\n         pexp = 1.0 ;\n    \n  const float kd = 1.1, ks = 1.2 ;\n    \n  return kd*nl*col + ks*pow( rv, pexp)*vec4( 1.0, 1.0, 1.0, 1.0 ); \n   \n}\n\n// -------------------------------------------------------------------------------\n// main color computing function for a point in device coordinates\n\nvec4 MainColorFunction_dc( vec2 p_dc )\n{\n    return p6mm_Stripes_dc( p_dc );  // islamic star pattern \n    //return RayTrace_dc( p_dc ) ;\n}\n\n// -------------------------------------------------------------------------------\n// initialize globals which depend on values known at run-time \n\nvoid InitGlobals()\n{\n    center = 0.5*iResolution.xy ;             // viewport center in DC \n    mind   = min(iResolution.x,iResolution.y); // minimun viewport dimension in pixels \n    secs   = iTime*speedFactor ;  // global time, scaled by speed factor\n    mou    = DCToNDC( 0.5*iResolution.xy ); // mouse pressed position (==center before pressing)\n    \n    // eye pos\n    eye_z  = normalize( eye_pos-look_at ) ;\n    eye_x  = normalize( cross( eye_vup, eye_z ) );\n    eye_y  = normalize( cross( eye_z, eye_x ) ); \n}\n \n// -------------------------------------------------------------------------------\n// main function, does multi-sample anti-aliasing\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    InitGlobals() ;\n    \n    const float n_inv = 1.0/float(n) ;\n    vec4 res          = vec4( 0.0, 0.0, 0.0, 1.0 );\n    \n    if ( iMouse.w != 0.0 )\n        mou  = DCToNDC( iMouse.xy  ) ;\n    \n    for (int ix = 0 ; ix < n ; ix += 1 )\n    for (int iy = 0 ; iy < n ; iy += 1 )\n    {\n       float px = -0.5 + (0.5+float(ix))*n_inv,   \n             py = -0.5 + (0.5+float(iy))*n_inv ;\n        \n       vec2 p_dc = fragCoord + vec2( px, py ) ;\n       res += MainColorFunction_dc( p_dc );\n    }\n    fragColor = n_inv*n_inv*res ;   \n}\n// -------------------------------------------------------------------------------", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mlj3zc.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[2425, 2523, 2549, 2549, 2587], [2590, 2798, 2839, 2839, 3091], [3092, 3236, 3286, 3286, 3380], [3381, 3494, 3546, 3546, 3631], [3632, 3793, 3858, 3858, 4160], [4161, 4333, 4370, 4370, 5366], [5368, 5473, 5504, 5504, 5566], [5568, 5703, 5742, 5742, 6092], [6094, 6206, 6230, 6230, 6346], [6352, 6497, 6524, 6544, 6883], [6884, 7006, 7042, 7042, 7360], [7362, 7470, 7503, 7503, 10306], [10457, 10564, 10616, 10616, 10711], [11174, 11258, 11284, 11284, 11714], [11716, 11800, 11855, 11855, 11970], [11972, 11972, 12001, 12001, 12062], [12064, 12148, 12176, 12176, 12623], [12625, 12868, 12907, 12907, 13755], [13757, 13785, 13816, 13816, 15150], [15152, 15303, 15343, 15343, 15442], [15444, 15592, 15612, 15612, 16109], [16112, 16246, 16303, 16303, 16834]], "test": "valid"}
{"id": "MlS3DG", "name": "RubiksCube", "author": "dila", "description": "Very slow rubix cube being solved. Kali did it before https://www.shadertoy.com/view/XtX3Rj", "tags": ["cube", "rubix"], "likes": 5, "viewed": 319, "published": "Public", "date": "1431870018", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define STEP_COUNT 8\n\nconst float pi = 3.14159;\n\nmat3 xrot(float t)\n{\n    return mat3(1.0, 0.0, 0.0,\n                0.0, cos(t), -sin(t),\n                0.0, sin(t), cos(t));\n}\n\nmat3 yrot(float t)\n{\n    return mat3(cos(t), 0.0, -sin(t),\n                0.0, 1.0, 0.0,\n                sin(t), 0.0, cos(t));\n}\n\nmat3 zrot(float t)\n{\n    return mat3(cos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0);\n}\n\nfloat mask(float a, float b)\n{\n    return max(sign(a-b), 0.0);\n}\n\nfloat interp(float a, float b)\n{\n    float m = mask(a, b);\n    return m * pi * 0.5 * clamp(a-b, 0.0, 1.0);\n}\n\nmat3 scramble(vec3 p)\n{\n    mat3 r = mat3(1.0);\n    float pt = (0.5+0.5*sin(iTime*0.25)) * 6.0;\n\n    if (p.x == -1.0) {\n        r = r * xrot(interp(pt, 0.0));\n    }\n    \n    vec3 q = p * r;\n    if (floor(q.y+0.5) == -1.0) {\n        r = r * yrot(interp(pt, 1.0));\n    }\n    \n    q = p * r;\n    if (floor(q.z+0.5) == -1.0) {\n        r = r * zrot(interp(pt, 2.0));\n    }\n    \n    q = p * r;\n    if (floor(q.x+0.5) == 1.0) {\n        r = r * xrot(interp(pt, 3.0));\n    }\n    \n    q = p * r;\n    if (floor(q.y+0.5) == 1.0) {\n        r = r * yrot(interp(pt, 4.0));\n    }\n    \n    q = p * r;\n    if (floor(q.z+0.5) == 1.0) {\n        r = r * zrot(interp(pt, 5.0));\n    }\n    \n    return r;\n}\n\nfloat cube(vec3 p)\n{\n  vec3 d = abs(p) - vec3(1.0 / 32.0);\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nvec3 normal(vec3 p)\n{\n    vec3 o = vec3(0.01, 0.0, 0.0);\n    return normalize(vec3(cube(p+o.xyy) - cube(p-o.xyy),\n                          cube(p+o.yxy) - cube(p-o.yxy),\n                          cube(p+o.yyx) - cube(p-o.yyx)));\n}\n\nvec3 colour(vec3 p)\n{\n\tvec3 sn = normal(p);\n    vec3 ln = 0.5 + 0.5 * sn;\n    vec3 asn = abs(sn);\n    float mc = max(asn.x, max(asn.y, asn.z));\n    \n    if (mc == asn.x) {\n        return mix(vec3(1.0, 1.0, 1.0), vec3(1.0, 1.0, 0.0), ln.x);\n    }\n    \n    if (mc == asn.y) {\n        return mix(vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0), ln.y);\n    }\n    \n    if (mc == asn.z) {\n        return mix(vec3(1.0, 0.0, 0.0), vec3(1.0, 0.5, 0.0), ln.z);\n    }\n    \n    return vec3(0.0);\n}\n\nvec4 map(vec3 p)\n{\n    p *= xrot(iTime) * zrot(iTime*2.0);\n    \n    float d = 1000.0;\n    vec3 f = vec3(0.0);\n    for (int i = -1; i <= 1; ++i) {\n        for (int j = -1; j <= 1; ++j) {\n            for (int k = -1; k <= 1; ++k) {\n                vec3 v = vec3(float(i),float(j),float(k));\n                vec3 o = scramble(v) * p + v;\n                vec3 c = clamp(o, -0.45, 0.45);\n                float m = length(c - o);\n                if (m < d) {\n                    d = m;\n                    f = o;\n                }\n            }\n        }\n    }\n    return vec4(d, colour(f));\n}\n\nfloat trace(vec3 o, vec3 r)\n{\n \tfloat t = 0.0;\n    for (int i = 0; i < STEP_COUNT; ++i) {\n        vec3 p = o + r * t;\n        float d = map(p).x;\n        t += d;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 r = normalize(vec3(uv, 1.0));\n    \n    vec3 o = vec3(0.0, 0.0, -4.0);\n    \n    float t = trace(o, r);\n    vec3 w = o + r * t;\n    vec4 fd = map(w);\n    \n    float bl = 1.0 / (1.0 + t * t * 0.01 + fd.x * 100.0);\n    \n    vec3 bk = mix(vec3(0.8,0.8,1.0), vec3(0.5,0.5,0.5), 0.5+0.5*uv.y);\n    \n    vec3 fc = mix(fd.yzw, bk, 1.0-bl);\n    \n\tfragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlS3DG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 69, 69, 178], [180, 180, 200, 200, 309], [311, 311, 331, 331, 440], [442, 442, 472, 472, 506], [508, 508, 540, 540, 616], [618, 618, 641, 641, 1300], [1302, 1302, 1322, 1322, 1433], [1435, 1435, 1456, 1456, 1666], [1668, 1668, 1689, 1689, 2146], [2148, 2148, 2166, 2166, 2735], [2737, 2737, 2766, 2766, 2920], [2922, 2922, 2979, 2979, 3468]], "test": "valid"}
{"id": "MlS3Rc", "name": "Echoplex", "author": "dila", "description": "Rusty beams inside some structure.\nSimulated motion blur by blending in some of the previous frames.", "tags": ["sphere", "scene", "world"], "likes": 41, "viewed": 2011, "published": "Public", "date": "1430940904", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = 3.14159;\n\nmat3 xrot(float t)\n{\n    return mat3(1.0, 0.0, 0.0,\n                0.0, cos(t), -sin(t),\n                0.0, sin(t), cos(t));\n}\n\nmat3 yrot(float t)\n{\n    return mat3(cos(t), 0.0, -sin(t),\n                0.0, 1.0, 0.0,\n                sin(t), 0.0, cos(t));\n}\n\nmat3 zrot(float t)\n{\n    return mat3(cos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0);\n}\n\nfloat pshade(vec3 p)\n{\n\tfloat ac = texture(iChannel0, vec2(p.y,p.z)).x;\n    float bc = texture(iChannel0, vec2(p.x,p.z)).x;\n    float cc = texture(iChannel0, vec2(p.x,p.y)).x;\n    float s = ((ac + bc + cc) / 3.0) * 2.0 - 1.0;\n    return s;\n}\n\nfloat sphere(vec3 p)\n{\n    vec3 q = fract(p+0.5) * 2.0 - 1.0;\n\treturn 1.3 - length(q);  \n}\n\nfloat map(vec3 p)\n{\n\treturn min(sphere(p), sphere(p+0.5));\n}\n\nfloat trace(vec3 o, vec3 r)\n{\n    float t = 0.0;\n    for (int i = 0; i < 32; ++i) {\n        vec3 p = o + r * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    return t;\n}\n\nvec3 normal(vec3 p)\n{\n    vec3 o = vec3(0.01, 0.0, 0.0);\n    return normalize(vec3(map(p+o.xyy) - map(p-o.xyy),\n                          map(p+o.yxy) - map(p-o.yxy),\n                          map(p+o.yyx) - map(p-o.yyx)));\n}\n\nvec3 campos(float time)\n{\n    vec3 f = vec3(0.25);\n    f.z += time;\n\treturn f;\n}\n\nfloat occlusion(vec3 origin, vec3 ray) {\n    float delta = 0.1;\n    const int samples = 16;\n    float r = 0.0;\n    for (int i = 1; i <= samples; ++i) {\n        float t = delta * float(i);\n     \tvec3 pos = origin + ray * t;\n        float dist = map(pos);\n        float len = abs(t - dist);\n        r += len * pow(2.0, -float(i));\n    }\n    return r;\n}\n\nvec4 surf(vec3 r, vec3 w, vec3 sn, float t)\n{\n    float prod = max(dot(sn,-r), 0.0);\n    float off = 0.5 + 0.5 * sin(pshade(w)*pi*5.0);\n    float fog = prod / (1.0 + t * t + off);\n    return vec4(vec3(fog),off);\n}\n\nvec3 shade(vec3 o, vec3 r)\n{\n    float t = trace(o, r);\n    vec3 w = o + r * t;\n    vec3 sn = normal(w);\n    \n\tfloat lit = occlusion(o, r) * 5.0;\n    \n    vec4 ac = surf(r, w, sn, t);\n    \n    vec3 from = vec3(0.8, 0.2, 0.1);\n    vec3 to = vec3(1.0, 1.0, 1.0);\n    \n    float fx = 1.0 - ac.w;\n    \n    vec3 mixed = ac.xyz * mix(from, to, fx);\n    \n    vec3 fc = lit * mixed;\n    \n    return fc;\n}\n\nvec3 raydir(vec3 r, float t)\n{\n    return r * yrot(t) * xrot(t*2.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 r = normalize(vec3(uv, 1.0 - dot(uv,uv) * 0.333));\n    float ms = iTime * 0.25;\n    float of = 0.01;\n    \n    vec3 ao = campos(ms);\n    vec3 ar = raydir(r, ms);\n    vec3 ac = shade(ao, ar);\n    \n    vec3 bo = campos(ms-of);\n    vec3 br = raydir(r, ms-of);\n    vec3 bc = shade(bo, br);\n    \n    vec3 co = campos(ms-of*2.0);\n    vec3 cr = raydir(r, ms-of*2.0);\n    vec3 cc = shade(co, cr);\n    \n    ac = ac * 0.5 + bc * 0.25 + cc * 0.25;\n    \n\tfragColor = vec4(ac, 1.0);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlS3Rc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 47, 47, 156], [158, 158, 178, 178, 287], [289, 289, 309, 309, 418], [420, 420, 442, 442, 661], [663, 663, 685, 685, 753], [755, 755, 774, 774, 815], [817, 817, 846, 846, 998], [1000, 1000, 1021, 1021, 1225], [1227, 1227, 1252, 1252, 1307], [1309, 1309, 1349, 1349, 1659], [1661, 1661, 1706, 1706, 1874], [1876, 1876, 1904, 1904, 2272], [2274, 2274, 2304, 2304, 2344], [2346, 2346, 2403, 2403, 2998]], "test": "error"}
{"id": "MlS3zK", "name": "VoxelSpace", "author": "dila", "description": "This went terribly wrong. I must learn how to do voxels properly.", "tags": ["cube", "voxel", "world"], "likes": 8, "viewed": 390, "published": "Public", "date": "1430439315", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = 3.14159;\n\nmat3 xrot(float t)\n{\n\treturn mat3(1.0, 0.0, 0.0,\n                0.0, cos(t), -sin(t),\n                0.0, sin(t), cos(t));\n}\n\nmat3 yrot(float t)\n{\n\treturn mat3(cos(t), 0.0, -sin(t),\n                0.0, 1.0, 0.0,\n                sin(t), 0.0, cos(t));\n}\n\nmat3 zrot(float t)\n{\n    return mat3(cos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0);\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat noise(vec3 p)\n{\n    float ta = texture(iChannel0, vec2(p.x,p.y)).x;\n    float tb = texture(iChannel0, vec2(p.y,p.z)).x;\n    float tc = texture(iChannel0, vec2(p.x,p.z)).x;\n    return (ta + tb + tc) / 3.0;\n}\n\nfloat fakeBox(vec3 p)\n{\n    vec3 q = abs(p);\n    return min(q.x,min(q.y,q.z));\n}\n\nfloat toffset = 0.0;\n\nfloat map(vec3 p, vec3 r)\n{  \n    float sc = 3.0;\n    \n\tvec3 pc = floor(p*sc);\n    \n    vec3 pf = fract(p*sc) * 2.0 - 1.0;\n    \n    bool skip = false;\n    \n    if (noise((pc+toffset)*0.01) > 0.5) {\n     \tskip = true;\n    }\n    \n    if (abs(pc.x)<2.0 && abs(pc.y)<2.0) {\n     \tskip = true;\n    }\n    \n    if (skip) {\n        return 0.05 * fakeBox(pf + sign(r) * 4.0);\n    }\n    \n    return sdBox(pf, vec3(1.0));\n}\n\nvec3 normal(vec3 p, vec3 r)\n{\n    vec3 o = vec3(0.01, 0.0, 0.0);\n    return normalize(vec3(\n        map(p+o,r) - map(p-o,r),\n        map(p+o.yxy,r) - map(p-o.yxy,r),\n        map(p+o.yyx,r) - map(p-p.yyx,r)));\n}\n\nfloat trace(vec3 o, vec3 r)\n{\n    float t = 0.0;\n    for (int i = 0; i < 32; ++i) {\n        vec3 p = o + r * t;\n        float d = map(p, r);\n        t += d * 0.5;\n    }\n    return t;\n}\n\nvec3 shade(vec3 o, vec3 r)\n{\n    float t = trace(o, r);\n    vec3 world = o + r * t;\n    vec3 seed = floor(world*3.0) * 0.5;\n    vec3 sn = normal(world, r);\n    \n    vec3 ta = vec3(sin(seed.x+seed.z), cos(seed.y), sin(seed.z+seed.y));\n    ta = ta * 0.5 + 0.5;\n    vec3 tb = ta * 0.9;\n    \n    float bl = max(dot(sn,r), 0.0);\n    \n    vec3 fc = mix(ta, tb, 1.0-bl);\n    \n    float fog = 1.0 / (1.0 + t * t * t * 1.0);\n    \n    vec3 sh = fc * fog;\n    \n    return sh;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 r = normalize(vec3(uv, 1.0 - dot(uv,uv) * 0.33));\n    r *= xrot(iTime*0.5) * yrot(iTime) * zrot(iTime*0.5);\n    \n    vec3 o = vec3(0.0);\n    o.z += iTime;\n    \n    float tsc = 0.5;\n    float base = floor(50.0+iTime*tsc);\n    float intp = fract(50.0+iTime*tsc);\n    \n    toffset = 0.0;\n\tvec3 sa = shade(o, r);\n\n    toffset = base - 1.0;\n\tvec3 sb = shade(o, r);\n    \n    toffset = base - 2.0;\n\tvec3 sc = shade(o, r);\n    \n    float it = smoothstep(0.0, 1.0, intp);\n    \n    vec3 fa = mix(sa, sb, it);\n    vec3 fb = mix(fa, sc, 1.0-it);\n    \n\tfragColor = vec4(fb,1.0);\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlS3zK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 47, 47, 153], [155, 155, 175, 175, 281], [283, 283, 303, 303, 412], [414, 414, 445, 445, 483], [485, 485, 516, 516, 612], [614, 614, 635, 635, 826], [828, 828, 851, 851, 908], [932, 932, 959, 959, 1344], [1346, 1346, 1375, 1375, 1556], [1558, 1558, 1587, 1587, 1742], [1744, 1744, 1772, 1772, 2210], [2212, 2212, 2269, 2269, 2961]], "test": "error"}
{"id": "MlSGzd", "name": "Music in my blood", "author": "pixelzealot", "description": "Playing around with noise and voronoi. Rough thinking/inspiration was blood cells flowing and reacting to a heart beat. Thanks as always to iq for lots of great sources of inspiration and code.", "tags": ["voronoi", "metaballs", "reactive"], "likes": 26, "viewed": 586, "published": "Public", "date": "1431384474", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Enable debug and click in the window to see all the control points being considered\n#define DEBUG 0\n\n// Does what it says on the tin, increase to zoom out\n#define ZOOM 12.0\n\nvec2 hash( vec2 p ) \n{ \n    return texture( iChannel0, (p+0.5)/256.0, -100.0 ).xy;\n}\n\nmat2 rotate2D(float angle)\n{\n   \tfloat c = cos(angle);\n    float s = sin(angle);\n    return mat2(vec2(c, s), vec2(-s, c));\n}\n\nfloat line(vec2 p, vec2 a, vec2 b)\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\t\n\treturn length( pa - ba*h );\n}\n\n// Thanks to iq for the voronoi shader (https://www.shadertoy.com/view/MslGD8) some great stuff in there.\nvec3 voronoi(in vec2 uv, inout vec3 col)\n{\n    vec2 x = uv + vec2(1.0, 0.0) * iTime;\n    \n    vec2 n = floor(x);\n    vec2 f = x - n;\n\n\tfloat md = ZOOM;\n    float td = 0.0;\n    \n    #if DEBUG\n\tfloat aspectAdjust = max(iResolution.x, iResolution.y);\n    vec2 click = iMouse.xy / aspectAdjust * ZOOM;\n    click += vec2(1.0, 0.0) * iTime;\n    #endif\n    \n    mat2 rot = rotate2D(iTime);\n    \n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) );\n        vec2 h = hash(n + g);\n        vec2 lo = h - 0.5;\n        lo = rot * lo;\n        \n        vec2  o = vec2(0.5) + lo;\n      \tvec2  r = g - f + o;\n\t\tfloat d = dot( r, r );\n        float potential = 1.0 / d;\n        \n        if (d < md)\n            md = d;\n        \n        td += potential;\n        \n        #if DEBUG\n        {\n            vec2 n = floor(click);\n            vec2 f = click - n;\n            \n\t\t\tvec2 h = hash(n + g);\n        \tvec2 lo = h - 0.5;\n        \tlo = rot * lo;      \n            \n\t\t\tvec2  o = vec2(0.5) + lo;\n      \t\tvec2  r = g - f + o;            \n            float d = dot( r, r );\n            \n            float t = line(x, click, n + g + o);\n            \n            vec3 lineCol = vec3(1.0/d);\n            col = mix(col, lineCol, 1.0-smoothstep(0.0, 25.0/aspectAdjust, abs(t)));\n        }\n        #endif\n    }\n    return vec3(td, sqrt(md), hash(n));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy/max(iResolution.x,iResolution.y);\n    vec3 col = vec3(0.0);\n\n    float n = texture(iChannel1, vec2(0.00, 0.25)).x;\n    float sizeAdjust = n * 4.0;\n    float cellAdjust = 0.5 + n*0.5;\n    \n   \tvec3 c = voronoi(p * ZOOM, col);\n    \n    vec3 cellCol = vec3(\n        sin(c.y * c.y * 8.0 * cellAdjust) * 0.5 + 0.5, \n        0.0, \n        0.0);\n    \n    cellCol = mix(vec3(0.5, 0.0, 0.0), cellCol, (c.x > 14.0 + sizeAdjust) ? 1.0 : 0.0);\n    \n    // computer voronoi pattern\n    col += mix(\n        cellCol,\n        vec3(0.1, 0.1, 0.1), \n        1.0 - smoothstep(14.0 + sizeAdjust, 22.0 + sizeAdjust, c.x));\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlSGzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[104, 177, 199, 199, 261], [263, 263, 291, 291, 387], [389, 389, 425, 425, 547], [549, 655, 697, 697, 2041], [2043, 2043, 2100, 2100, 2763]], "test": "error"}
{"id": "Mt23z3", "name": "Rainbow Metroid Jellyfish", "author": "ChristinaCoffin", "description": "originally started messing with lightglows+lines, then decided to do subtractive lights and shapes and this was born.\nThe subconscious creative process has a mind of its own :)\nBest viewed in fullscreen to get all the filament details.", "tags": ["procedural", "2d", "translucent", "silhouette"], "likes": 12, "viewed": 590, "published": "Public", "date": "1431101020", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// Rainbow Metroid Jellyfish\n//\n// @christinacoffin\n// 2015-05-08 - rough sketch , maybe add more depth and bioluminesence inside it later!\n//\n//\n// used the blob glowcode here as a starting base: https://www.shadertoy.com/view/MtS3Wh\n//\nfloat glowstar(float x,float y,float sparkDur,float fy,float sparkDist,float xShakeWidth,float t,float offset)\n{\n    x = abs(x)+(t*0.25);\n    y += abs(x*y*t*0.1);\n\n    sparkDist *= 5.0;\n\n    float xx=x+sin(t*sparkDur*3.0)*xShakeWidth;\n    float yy=y+cos(t*sparkDur)*0.4*sparkDist;\n\n    yy = abs(yy);\n    xx += (xx*yy)-abs(yy);\n\n    float speed = 1.0;\n    float starFalloff;\n    float starLight = 0.0;\n    \n   \tstarFalloff = ((xx*xx)*(y*xx*cos(xx*x*y)+y+x*2.0))+(yy*yy);// \n    \n    float star_0 = starFalloff;\n    \n    starFalloff -= sqrt(xx*xx*xx*xx+yy*yy*yy*yy); //octstar\n   \n    float star_1 = starFalloff;\n    \n    starFalloff -= sqrt(xx*xx*xx*xx+yy*yy*yy*yy/t)*abs(y*y*y*y);\n    \n    float star_2 = starFalloff;\n    \n\tstarLight = sqrt(xx*xx+yy*yy);\n\n    starFalloff -= sqrt(xx*xx*xx*xx+yy*yy*yy*yy)*t*1.0;\n\n    float overTime = 0.9/(starFalloff*speed);\n\n    float final = abs(overTime*sin(t*sparkDur));\n    \n    final = pow(final,0.235);// smaller pow under 1.0, soft and dim stars\n    return final;//adding abs removes the 'darklights'\n}\n\n\n\n\n\nfloat makePoint(float x,float y,float sparkDur,float fy,float sparkDist,float xShakeWidth,float t,float offset)\n{\n    x = abs(x)+(t*0.25);\n    y += abs(x*y*t*0.1);\n    \n   sparkDist *= 5.0;//10.1;\n\n   float xx=x+sin(t*sparkDur*3.0)*xShakeWidth;\n   float yy=y+cos(t*sparkDur)*0.4*sparkDist;\n\n    yy = abs(yy);\n     xx += (xx*yy)-abs(yy);\n    \n    float speed = 1.0;\n    float starFalloff;\n    float starLight = 0.0;\n    \n   \tstarFalloff = ((xx*xx)*(y*xx*cos(xx*x*y)+y+x*2.0))+(yy*yy);// \n\n    float star_0 = starFalloff;\n    \n    starFalloff -= sqrt(xx*xx*xx*xx+yy*yy*yy*yy); //octstar\n   \n    float star_1 = starFalloff;\n    \n    starFalloff -= sqrt(xx*xx*xx*xx+yy*yy*yy*yy/t)*abs(y*y*y*y);\n    \n    float star_2 = starFalloff;\n    \n\tstarLight = sqrt(xx*xx+yy*yy);\n\n    starFalloff -= sqrt(xx*xx*xx*xx+yy*yy*yy*yy)*t*1.0;\n  \n\t//starFalloff /= 0.1*abs(cos(tan(xx*x*x*t*y*y*xx))/t*10.1);//add more lines inside, but additive\n \n     starFalloff *= starFalloff/0.52;//darken mandible tentacles\n\n    \n    float overTime = 0.61799/(starFalloff*speed);\n\n    float final = abs(overTime*sin(t*sparkDur));\n    \n    final = pow(final,0.235);\n\tstarLight -= pow(starLight, 0.412171);\n    final = starLight - abs(final);\n    \n    final -= fract(star_2*0.01/star_0);\n\n    return final;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    float periodTime = 1.9;//limit the animation cycle to the period that looks the most interesting and loop it.\n    float time=(sin(iTime*0.1)*sin(iTime*0.1))*periodTime;\n    time = abs(time)+0.9;\n    \n   vec2 p=(fragCoord.xy/iResolution.x)*2.0-vec2(1.0,iResolution.y/iResolution.x);\n\n   p=p*2.0;\n   \n   p = p * 1.3;//scale down another bit to zoom in\n   float x=0.0151+ p.x+sin(time*0.70);\n   float y=(p.y)+0.5+sin(time)-1.0;\n\n \t//skew and offset a bit in screenspace to frame the part i like\n   y -= abs(x+y)*0.1;\n   y -= 0.2;\n\n    \n   float a=\n       makePoint(x,y,3.0,2.9,0.8,1.15,time,0.1);\n   a=a+makePoint(x,y,1.9,2.0,0.8,0.2,time,0.4);\n   a=a+makePoint(x,y,0.8,0.7,0.4,0.17,time,0.7);\n   a=a+makePoint(x,y,2.3,0.1,0.6,0.3,time,2.5);\n   a=a+makePoint(x,y,0.8,1.7,0.5,0.24,time,1.6);\n   a=a+makePoint(x,y,0.3,1.0,0.4,0.33,time,0.8);\n   a=a+makePoint(x,y,1.4,1.7,0.4,0.08,time,1.3);\n   a=a+makePoint(x,y,1.3,2.1,0.6,0.14,time,2.3);\n   a=a+makePoint(x,y,1.8,1.7,0.5,0.14,time,2.8);   \n   \n    //more layers\n   float b=\n       makePoint(x,y,1.2,1.9,0.8,1.3,time,0.6);\n   b=b+makePoint(x,y,0.7,2.7,0.4,0.41,time,0.16);\n    \n   b=b+makePoint(x,y,1.4,0.6,0.4,0.52,time,0.26);\n   b=b+makePoint(x,y,2.6,0.4,0.6,0.33,time,0.36);\n   b=b+makePoint(x,y,0.7,1.4,0.5,0.44,time,0.46);\n   b=b+makePoint(x,y,0.7,1.7,0.4,0.45,time,0.56);\n   b=b+makePoint(x,y,0.8,0.5,0.4,0.56,time,0.66);\n   b=b+makePoint(x,y,1.4,0.9,0.6,0.37,time,0.76);\n   b=b+makePoint(x,y,0.7,1.3,0.5,0.48,time,0.86);\n  \n   vec3 d=vec3(a,a+a-y*32.0,a-y*50.0)/32.0;\n    \n   d += vec3(b,b+b-y*32.0,b-y*50.0)/32.0; \n    //add in electric glow\n   d.x += max( d.y, glowstar(x,y,3.0,2.9,0.8,1.15,time*time,0.1)*0.7 );\n    \n\tfragColor = vec4(d.x,d.y,d.z,1.0);\n    //flip colors\n    fragColor.xyz = fragColor.zyx;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt23z3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 241, 353, 353, 1285], [1291, 1291, 1404, 1404, 2563], [2565, 2565, 2622, 2622, 4391]], "test": "valid"}
{"id": "MtB3zt", "name": "Wave Interference", "author": "16807", "description": "blah", "tags": ["2d", "wave", "interference"], "likes": 1, "viewed": 99, "published": "Public", "date": "1431366992", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat wave(vec2 xy, float wavelength, float speed){\n    float x = xy.x;\n    float y = xy.y;\n    \n    return sin(sqrt(x*x + y*y)/wavelength - iTime*speed);\n}\nvec4 view(float x, float y, float z){\n    return vec4((vec3(x,y,z)+1.)/2., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 xy = (2.*fragCoord.xy - iResolution.xy)/100.;\n    vec2 x = vec2(1,0);\n    vec2 y = vec2(0,1);\n    \n    float a = wave(xy - x, 0.5, 1.);\n    float b = wave(xy + x, 0.5, 1.);\n    \n\tfragColor = view(0.,0.,a+b);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtB3zt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 52, 52, 157], [158, 158, 195, 195, 239], [241, 241, 298, 298, 514]], "test": "valid"}
{"id": "MtBGDG", "name": "Emerging Redux", "author": "Kali", "description": "New version - Mouse enabled", "tags": ["fractal", "towers"], "likes": 57, "viewed": 1143, "published": "Public", "date": "1431849151", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n#define ENABLE_HARD_SHADOWS // turn off to enable faster AO soft shadows \n\n\n#define RAY_STEPS 80\n#define SHADOW_STEPS 50\n#define LIGHT_COLOR vec3(.97,.92,.82)\n#define AMBIENT_COLOR vec3(.5,.5,.55)\n#define FLOOR_COLOR vec3(.35,.25,.2)\n#define ENERGY_COLOR vec3(1.,.7,.4)\n#define BRIGHTNESS 1.5\n#define GAMMA 1.2\n#define SATURATION .9\n\n\n\n#define detail .000025\n#define t iTime*.1\n\n\nfloat cc,ss;\nvec3 lightdir=normalize(vec3(0.5,-0.4,-1.));\nvec3 ambdir=normalize(vec3(0.,0.,1.));\nconst vec3 origin=vec3(0.,3.11,0.);\nfloat det=0.0;\nvec3 pth1;\n\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\n\nvec3 path(float ti) {\nreturn vec3(0.,2.5,0.)+vec3(cos(ti),cos(ti*.935485),sin(ti)*1.2);\n}\n\n\nvec4 formula (vec4 p) {\n\tp.y-=t*.25;\n    p.y=abs(3.-mod(p.y-t,6.));\n    for (int i=0; i<6; i++) {\n\t\tp.xyz = abs(p.xyz)-vec3(.0,2.,.0);\n\t\tp=p*2./clamp(dot(p.xyz,p.xyz),.3,1.)-vec4(0.5,1.5,0.5,0.);\n\t\tp.xz*=mat2(cc,ss,-ss,cc);\n\t}\n\treturn p;\n}\n\n\nfloat textur(vec3 p) {\n    p=abs(1.-mod(p,2.));\n    vec3 c=vec3(3.,4.,2.);\n\tfloat es=1000., l=0.;\n\tfor (int i = 0; i < 12; i++) { \n\t\t\tp = abs(p + c) - abs(p - c) - p; \n\t\t\tp/= clamp(dot(p, p), .5, 1.);\n\t\t\tp = p* -1.3 + c;\n        \tes=min(min(abs(p.x),abs(p.y)),es);\n\t}\n\treturn es*es*3.;\n}\n\n\nvec2 de(vec3 pos) {\n\tfloat aa=smoothstep(0.,1.,clamp(cos(t-pos.y*.4)*1.5,0.,1.))*3.14159;\n    cc=cos(aa);ss=sin(aa);\n    float hid=0.;\n\tvec3 tpos=pos;\n\t//tpos.xz=abs(1.5-mod(tpos.xz,3.))-1.5;\n\tvec4 p=vec4(tpos,1.);\n\tfloat y=max(0.,.3-abs(pos.y-3.3))/.3;\n    p=formula(p);\n    float fl=pos.y-3.7-length(sin(pos.xz*60.))*.01;\n\tfloat fr=max(abs(p.z/p.w)-.01,length(p.zx)/p.w-.002);\n\tfloat bl=max(abs(p.x/p.w)-.01,length(p.zy)/p.w-.0005);\n    fr=smin(bl,fr,.02);\n\tfr*=.9;\n    //float fr=length(p.xyz)/p.w;\n    fl-=(length(p.xz)*.005+length(sin(pos*3.+t*5.))*.15);\n    fl*=.9;\n\tfloat d=smin(fl,fr,.7);\n    if (abs(d-fl)<.2) {\n        hid=1.;\n    }\n    return vec2(d,hid);\n}\n\n\nvec3 normal(vec3 p) {\n\tvec3 e = vec3(0.0,det,0.0);\n\t\n\treturn normalize(vec3(\n\t\t\tde(p+e.yxx).x-de(p-e.yxx).x,\n\t\t\tde(p+e.xyx).x-de(p-e.xyx).x,\n\t\t\tde(p+e.xxy).x-de(p-e.xxy).x\n\t\t\t)\n\t\t);\t\n}\n\nfloat shadow(vec3 pos, vec3 sdir) {//THIS ONLY RUNS WHEN WITH HARD SHADOWS\n\tfloat sh=1.0;\n\tfloat totdist =2.0*det;\n\tfloat dist=5.;\n\t\tfor (int steps=0; steps<SHADOW_STEPS; steps++) {\n\t\t\tif (totdist<4. && dist>detail) {\n\t\t\t\tvec3 p = pos - totdist * sdir;\n\t\t\t\tdist = de(p).x;\n\t\t\t\tsh = min( sh, max(20.*dist/totdist,0.0) );\n\t\t\t\ttotdist += max(.01,dist);\n\t\t\t}\n\t\t}\n\t\n    return clamp(sh,0.1,1.0);\n}\n\n\nfloat calcAO( const vec3 pos, const vec3 nor ) {\n\tfloat aodet=detail*75.;\n\tfloat totao = 0.0;\n    float sca = 8.0;\n    for( int aoi=0; aoi<6; aoi++ ) {\n        float hr = aodet*float(aoi*aoi);\n        vec3 aopos =  nor * hr + pos;\n        float dd = de( aopos ).x;\n        totao += -(dd-hr)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - 5.0*totao, 0., 1. );\n}\n\n\nvec3 light(in vec3 p, in vec3 dir, in vec3 n, in float hid) {//PASSING IN THE NORMAL\n\t#ifdef ENABLE_HARD_SHADOWS\n\t\tfloat sh=shadow(p, lightdir);\n\t#else\n\t\tfloat sh=calcAO(p,-2.5*lightdir);//USING AO TO MAKE VERY SOFT SHADOWS\n\t#endif\n\tfloat ao=calcAO(p,n);\n\tfloat diff=max(0.,dot(lightdir,-n))*sh*.95;\n\tfloat y=3.16-p.y;\n\tvec3 amb=max(.6,dot(dir,-n))*.7*AMBIENT_COLOR;\n\tvec3 r = reflect(lightdir,n);\n\tfloat spec=pow(max(0.,dot(dir,-r))*sh,15.)*.5;\n\tvec3 col;\n\t\tcol=texture(iChannel0,p.xz*7.).xyz; \n\t\tif (abs(hid-1.)<.001) col=texture(iChannel0,p.xz).xyz;\n\tcol=col*(amb*ao*.8+diff*.8*LIGHT_COLOR)+spec*.7*LIGHT_COLOR;\t\n\treturn col;\n}\n\nvec3 raymarch(in vec3 from, in vec3 dir) \n\n{\n\tfloat ey=mod(t*.5,1.);\n\tfloat glow,eglow,ref,sphdist,totdist=glow=eglow=ref=sphdist=0.;\n\tvec2 d=vec2(1.,0.);\n\tvec3 p, col=vec3(0.);\n\tvec3 origdir=dir,origfrom=from,sphNorm;\n\t\n    for (int i=0; i<RAY_STEPS; i++) {\n\t\tif (d.x>det && totdist<6.0) {\n\t\t\tp=from+totdist*dir;\n\t\t\td=de(p);\n\t\t\tdet=detail*(1.+totdist*60.)*(1.+ref*5.);\n\t\t\ttotdist+=max(detail,d.x); \n\t\t\tif (d.y<.5) glow+=max(0.,.02-d.x)/.02;\n\t\t}\n\t}\n\tvec3 ov=normalize(vec3(1.,.5,1.));\n\tvec3 sol=dir+lightdir;\n    float l=pow(max(0.,dot(normalize(-dir*ov),normalize(lightdir*ov))),1.5)+sin(atan(sol.x,sol.y)*20.+length(from)*50.)*.0015;\n    totdist=min(5.9,totdist);\n    p=from+dir*(totdist-detail);\n    vec3 backg=.4*(1.2-l)+LIGHT_COLOR*l*.75;\n\tbackg*=AMBIENT_COLOR*(1.-max(0.2,dot(normalize(dir),vec3(0.,1.,0.)))*.2);\n\tfloat fondo=0.;\n\tvec3 pp=p*.5+sin(t*2.)*.5;\n    for (int i=0; i<10; i++) {\n        fondo+=clamp(0.,1.,textur(pp+dir*float(i)*.01))*max(0.,1.-exp(-.05*float(i)))*2.;\n    }\n    vec3 backg2=backg*(1.+fondo*(FLOOR_COLOR)*2.);\n    if (d.x<.01) {\n        vec3 norm=normal(p);\n\t\tcol=mix(light(p-abs(d.x-det)*dir, dir, norm, d.y),backg,1.-exp(-.3*totdist*totdist)); \n\t\tcol = mix(col, backg2, 1.0-exp(-.02*pow(abs(totdist),2.)));\n\t} else { \n\t\tcol=backg2;\n\t}\n\tvec3 lglow=LIGHT_COLOR*pow(abs(l),30.)*.5;\n    col+=glow*(.3+backg+lglow)*.007;\n\tcol+=lglow*min(1.,totdist*totdist*.2)*1.5;\n    \n\treturn min(vec3(1.),col); \n}\n\nvec3 move(inout mat2 rotview1,inout mat2 rotview2) {\n\tvec3 go=path(t);\n\tvec3 adv=path(t+.5);\n\tvec3 advec=normalize(adv-go);\n\tfloat an=atan(advec.x,advec.z);\n\trotview1=mat2(cos(an),sin(an),-sin(an),cos(an));\n\t\t  an=advec.y*1.5;\n\trotview2=mat2(cos(an),sin(an),-sin(an),cos(an));\n\treturn go;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    pth1 = path(t+.3)+origin+vec3(0.,.01,0.);\n\tvec2 uv = fragCoord.xy / iResolution.xy*2.-1.;\n    vec2 uv2=uv;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec2 mouse=(iMouse.xy/iResolution.xy-.5)*3.;\n\tif (iMouse.z<1.) mouse=vec2(0.);\n\tmat2 rotview1, rotview2;\n\tvec3 from=origin+move(rotview1,rotview2);\n\tvec3 dir=normalize(vec3(uv,.75));\n\tdir.yz*=rot(mouse.y);\n\tdir.xz*=rot(mouse.x-1.);\n\tdir.yz*=rotview2;\n\tdir.xz*=rotview1;\n\tvec3 color=raymarch(from,dir); \n\tcolor=clamp(color,vec3(.0),vec3(1.));\n\tcolor=pow(abs(color),vec3(GAMMA))*BRIGHTNESS;\n\tcolor=mix(vec3(length(color)),color,SATURATION);\n\tcolor*=1.2-length(pow(abs(uv2),vec2(3.)))*.5;\n\tfloat fadein=clamp(iTime-.5,0.,1.);\n    fragColor = vec4(color*vec3(.93,.95,.91),1.)*fadein;\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtBGDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[543, 543, 584, 584, 677], [680, 680, 699, 699, 746], [749, 749, 770, 770, 838], [841, 841, 864, 864, 1080], [1083, 1083, 1105, 1105, 1370], [1373, 1373, 1392, 1392, 2041], [2044, 2044, 2065, 2065, 2228], [2230, 2230, 2265, 2304, 2622], [2625, 2625, 2673, 2673, 2993], [2996, 2996, 3057, 3080, 3626], [3628, 3628, 3672, 3672, 5056], [5058, 5058, 5110, 5110, 5348], [5351, 5351, 5408, 5408, 6138]], "test": "error"}
{"id": "MtBGDV", "name": "triangle interpolation raytrace", "author": "public_int_i", "description": "raytracing spheres to show points on a triangle, added basic lighting", "tags": ["triangle", "raytrace", "interpolation"], "likes": 1, "viewed": 212, "published": "Public", "date": "1432437556", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define FAR 100000.\n\nfloat sphere(in vec3 rp, in vec3 rd) {\n\tfloat sc = dot(rp, rp) - .05;\n\tfloat sb = dot(rd, rp);\n\n\tfloat sd = sb*sb - sc;\n\tfloat st = -sb - sqrt(abs(sd));\n\n    if (!(sd < 0.0 || st < 0.0)) {\n        return st;\n    }\n    return FAR;\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy/iResolution.xy-vec2(.5);\n    uv.y *= iResolution.y/iResolution.x;\n    \n    float ct = iMouse.x/iResolution.x*6.15;\n    vec3 rp = vec3(sin(ct)*8.,0.,cos(ct)*8.);\n    vec3 rd = normalize(-rp);\n    rp.y += 2.;\n    \n    vec3 rr = cross(vec3(0.,1.,0.),rd);\n    rd = normalize(rd*.4+uv.x*rr+uv.y*cross(rd,rr));\n    \n    \n    const float utimes = 9.;\n    const float vtimes = 9.;\n    const float us = 1./utimes;\n    const float vs = 1./vtimes;\n    \n    vec3 t1 = vec3(cos(iTime)*2.5,sin(iTime)*2.5,0.);\n    vec3 t2 = vec3(0.,5.,5.);\n    vec3 t3 = vec3(sin(iTime)*2.5+2.5,cos(iTime)*2.5+2.5,cos(iTime*.6)*2.);\n    \n    vec3 ud = t2-t1;\n    vec3 vd = t3-t2;\n    \n    float d = FAR;\n    vec2 fuv = vec2(0.);\n    float sd;\n    \n    for (float u = 0.; u < 1.; u+=us) {\n        for (float v = 0.; v < 1.; v+=vs) {\n            if (v > u) break;\n            vec3 sp = t1+u*ud+v*vd;\n            sd=sphere(rp-sp,rd);\n            d = min(d,sd);\n            sd = sign(sd-d);\n            fuv = fuv*sd+(1.-sd)*vec2(u,v);\n        }\n    }\n    if (d < FAR) {\n        rp += rd*d;\n        rp -= t1+fuv.x*ud+fuv.y*vd;\n        \n        vec3 c =  texture(iChannel0,fuv).xyz;\n        c = c*.2+\n            max(0.,dot(normalize(vec3(4.,10.,-6.)),normalize(rp)))*c;\n        \n        fragColor = vec4(c,1.);\n    } else {\n       fragColor = vec4(.2); \n    }\n}", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtBGDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 60, 60, 253], [260, 260, 317, 317, 1667]], "test": "error"}
{"id": "MtBGWK", "name": "Anti Menger Sphere Sponge", "author": "ManuManu", "description": "Some tests I made to understand the Menger Sponge, I tried to visualize the holes, and found it nice.\n\nObviously from IQ raymarching samples...", "tags": ["raymarching", "sphere", "menger", "sponge"], "likes": 12, "viewed": 1590, "published": "Public API", "date": "1432378260", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//---------------------------------------------------------\n//\n// source header from IQ, for sure...\n//\n//\n// Modified by ManuManu to create the Monge effect\n//\n//\n\n// Shader:   RayMarchingPrimitivesV2.glsl\n// original: https://www.shadertoy.com/view/Xds3zN   colored\n//           http://glslsandbox.com/e#20839          gray scaled\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// A list of usefull distance function to simple primitives (animated), and an example \n// on how to / do some interesting boolean operations, repetition and displacement.\n// More info here: http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n//---------------------------------------------------------\n\n\n//---------------------------------------------------------\n\n#define ANIMATE true\n#define ROTATE true\n#define flag true\n\nfloat aTime = 0.0;\nfloat sinTime = 0.0;\n//---------------------------------------------------------\n//  primitives\n//---------------------------------------------------------\nfloat sdPlane( vec3 p )\n{\n  return p.y;\n}\n\n\n//----------------------------------------------------------------------\n// distance operations\n//----------------------------------------------------------------------\n\n\n// Union: d1 +d2\nvec2 opU( vec2 d1, vec2 d2 )\n{\n  return (d1.x < d2.x) ? d1 : d2;\n}\n\n//----------------------------------------------------------------------\n// animated fractal Anti sphere sponge\nfloat AntiSphereSponge(vec3 w)\n{\n  const int ITER = 10;\n  float sphereHoles = 8.0 + 5.*sin(0.4123*aTime);\n  float sphereScale = 1.5 + 0.2*sin(0.345*aTime);\n  float scale =1.5;\n  float k = scale*.5;\n  float d = 10000.0;\n  float r, d1;\n  float sph=length(w * vec3(0.8, 0.8, 0.5)) - 0.6 ;\n  \n  if ( sph < .1)\n  for (int i = 0; i < ITER; i++) \n  {\n    vec3 zz = mod(w * k, sphereHoles) - vec3(0.5 * sphereHoles);\n    r = length(zz);\n    d1 = -(sphereScale - r) / k;\n    k *= scale;\n    d = min(d, d1);\n  }\n\telse d = 0.;\n  d = max(d,sph);\n  return d;\n}\n//----------------------------------------------------------------------\nvec2 map( in vec3 pos )\n{\n  vec3 r1, r2;\n  vec2 res = vec2( sdPlane( pos), 1.0 );\n  float color = 46.9 + 40.0 * cos(0.2 * iTime);\n  res = opU(res,vec2(AntiSphereSponge(pos - vec3(0.0, 0.7, 0.0)), color));\n  return res;\n}\n//----------------------------------------------------------------------\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n  float tmin = 1.0;\n  float tmax = 20.0;\n\n  float precis = 0.002;\n  float t = tmin;\n  float m = -1.0;\n  for ( int i=0; i<100; i++ )\n  {\n    vec2 res = map( ro+rd*t );\n    if ( res.x<precis || t>tmax ) break;\n    t += res.x;\n    m = res.y;\n  }\n\n  if ( t>tmax ) m=-1.0;\n  return vec2( t, m );\n}\n\n//----------------------------------------------------------------------\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n  float res = 1.0;\n  float t = mint;\n  for ( int i=0; i<14; i++ )\n  {\n    float h = map( ro + rd*t ).x;\n    res = min( res, 8.0*h/t );\n    t += clamp( h, 0.02, 0.10 );\n    if ( h<0.001 || t>tmax ) break;\n  }\n  return clamp( res, 0.0, 1.0 );\n}\n\n//----------------------------------------------------------------------\nvec3 calcNormal( in vec3 pos )\n{\n  vec3 eps = vec3( 0.001, 0.0, 0.0 );\n  vec3 nor = vec3(\n  map(pos+eps.xyy).x - map(pos-eps.xyy).x, \n  map(pos+eps.yxy).x - map(pos-eps.yxy).x, \n  map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n  return normalize(nor);\n}\n\n//----------------------------------------------------------------------\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n  float occ = 0.0;\n  float sca = 1.0;\n  for ( int i=0; i<5; i++ )\n  {\n    float hr = 0.01 + 0.12*float(i) / 4.0;\n    vec3 aopos =  nor * hr + pos;\n    float dd = map( aopos ).x;\n    occ += -(dd-hr)*sca;\n    sca *= 0.95;\n  }\n  return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n//---------------------------------------------------------\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n  aTime = ANIMATE ? iTime : 0.0;\n  sinTime = sin(aTime);\n  vec3 col = vec3(0.8, 0.9, 1.0);\n  vec2 res = castRay(ro, rd);\n  float t = res.x;\n  float m = res.y;\n  if ( m > -0.5 )\n  {\n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormal( pos );\n    vec3 ref = reflect( rd, nor );\n\n    // material        \n    col = 0.45 + 0.3*sin( vec3(0.05, 0.08, 0.10)*(m-1.0) );\n\n    if ( m<1.5 )\n    {\n      float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n      col = 0.4 + 0.1*f*vec3(1.0);\n    }\n\n    // lighting        \n    float occ = calcAO( pos, nor );\n    vec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n    float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float bac = clamp( dot( nor, normalize(vec3(-lig.x, 0.0, -lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y, 0.0, 1.0);\n    float dom = smoothstep( -0.1, 0.1, ref.y );\n    float fre = pow( clamp(1.0+dot(nor, rd), 0.0, 1.0), 2.0 );\n    float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ), 16.0);\n\n    dif *= softshadow( pos, lig, 0.02, 2.5 );\n    dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n    vec3 brdf = vec3(0.0);\n    brdf += 1.20*dif*vec3(1.00, 0.90, 0.60);\n    brdf += 1.20*spe*vec3(1.00, 0.90, 0.60)*dif;\n    brdf += 0.30*amb*vec3(0.50, 0.70, 1.00)*occ;\n    brdf += 0.40*dom*vec3(0.50, 0.70, 1.00)*occ;\n    brdf += 0.30*bac*vec3(0.25, 0.25, 0.25)*occ;\n    brdf += 0.40*fre*vec3(1.00, 1.00, 1.00)*occ;\n    brdf += 0.02;\n    col = col*brdf;\n    col = mix( col, vec3(0.8, 0.9, 1.0), 1.0-exp( -0.005*t*t ) );\n  }\n  return vec3( clamp(col, 0.0, 1.0) ); \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = 2.0*(fragCoord.xy / iResolution.xy) - 1.0;\n  p.x *= iResolution.x / iResolution.y;\n\n  // camera  \n  float angle = ROTATE ? 0.02*iTime : 0.0;\n  float rx = 0.5 + 3.0*cos(angle + 6.0*iMouse.x);\n  float rz = 0.5 + 3.0*sin(angle + 6.0*iMouse.x);\n  vec3 ro = vec3( rx, 1.0 + 1.0*iMouse.y, rz );\n  vec3 ta = vec3( 0.0, 0.5, 0.0 );\n\n  // camera tx\n  vec3 cw = normalize( ta-ro );\n  vec3 cp = vec3( 0.0, 1.0, 0.0 );\n  vec3 cu = normalize( cross(cw, cp) );\n  vec3 cv = normalize( cross(cu, cw) );\n  vec3 rd = normalize( p.x*cu + p.y*cv + 3.0*cw );\n\n  // pixel color\n  vec3 col = render( ro, rd );\n  col = pow( col, vec3(0.4545) );\n  fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtBGWK.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[943, 1078, 1103, 1103, 1119], [1293, 1310, 1340, 1340, 1376], [1378, 1490, 1522, 1522, 2037], [2038, 2111, 2136, 2136, 2331], [2332, 2405, 2445, 2445, 2738], [2740, 2813, 2887, 2887, 3130], [3132, 3205, 3237, 3237, 3454], [3456, 3529, 3571, 3571, 3840], [3841, 3901, 3940, 3940, 5493], [5496, 5496, 5553, 5553, 6218]], "test": "valid"}
{"id": "Mtj3DG", "name": "Ancient Mars", "author": "florian", "description": "Scene from Karla Quintero's modern dance performance \"If Mars\"\nMashup of heavy RMF, Kali's fractal (and stars I believe) and Nimitz's fog trick.\nAdded IQ's noise for posting on shadertoy.\nApologies for the brute force detail and hence slowness.", "tags": ["mars"], "likes": 56, "viewed": 3934, "published": "Public API", "date": "1432597510", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Ancient Ruins\n// Scene from Karla Quintero's modern dance performance \"If Mars\"\n//\n// Mashup of heavy RMF, Kali's fractal (and stars I believe) and Nimitz's fog trick.\n// Added IQ's noise for posting on shadertoy.\n// Apologies for the brute force detail and hence slowness.\n// \n// @rianflo\n\n\nfloat smin(float a, float b, float k)\n{\n\treturn -(log(exp(k*-a)+exp(k*-b))/k);\n}\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\n#if 1\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n#else\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n#endif\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n\nconst float PI = 3.1415926535897932384626433832795;\n\n\n// ----------------------------------------------------------EDIT ME----------------------------------------------------------------------\nfloat rmf(vec3 p)\n{\n    float signal = 0.0;\n    float value  = 0.0;\n    float weight = 1.0;\n    float h = 1.0;\n    float f = 1.0;\n\n    for (int curOctave=0; curOctave < 11; curOctave++) \n    {\n        signal = noise(p)*2.0-0.4;\n        signal = pow(1.0 - abs(signal), 2.0) * weight;\n        weight = clamp(0.0, 1.0, signal * 16.0);\n        value += (signal * pow(f, -1.0));\n        f *= 2.0;\n        p *= 2.0;\n    }\n    \n    return (value * 1.25) - 1.0;\n}\n\nconst int Iterations=15;\n\nconst float Scale=2.1;\n\nfloat de(vec3 pos) \n{\n\tvec3 p=pos;\n    p.y +=4.76-iTime*0.005;\n\tp.xz=abs(.5-mod(pos.xz,1.))+.01;\n\tfloat DEfactor=1.;\n\tfloat ot=1000.;\n\tfor (int i=0; i<Iterations; i++) \n    {\n\t\tp = abs(p)-vec3(0.,2.,0.);  \n\t\tfloat r2 = dot(p, p);\n\t\tot = min(ot,abs(length(p)));\n\t\tfloat sc=Scale/clamp(r2,0.4,1.);\n\t\tp*=sc; \n\t\tDEfactor*=sc;\n\t\tp = p - vec3(0.5,1.,0.5);\n\t}\n    float rr=length(pos+vec3(0.,-3.03,1.85))-.017;\n    float d=length(p)/DEfactor-.0005;\n\t\n    return d;\n}\n\nfloat sdf(vec3 p)\n{\n\tfloat sd = p.y;\n    \n    \n\tsd = smin(sd, de(p), 60.0);\n    //sd = min(sd, length(p)-1.0-rmf(p+time*0.01, 8.0, 1.8, coneR)*0.06);\n    sd -= rmf(p*8.0+2.0)*0.015;       // ceiling\n    \n    return sd;\n}\n\nvec4 getColorAndRoughness(vec3 p, vec3 N, float ambo)\n{\n    return vec4(1.0);\n}\n\nvec3 grad(vec3 p, float coneR)\n{\n    coneR*=3.0;\n    vec3 f = vec3(sdf(p));\n    vec3 g = vec3(sdf(p+vec3(coneR, 0.0, 0.0)),\n                  sdf(p+vec3(0.0, coneR, 0.0)),\n                  sdf(p+vec3(0.0, 0.0, coneR)));\n    return (g-f) / coneR;\n}\n\nvec3 setupRayDirection(float camFov)\n{\n\tvec2 coord = vec2(gl_FragCoord.xy);\n    vec2 v = vec2(coord / iResolution.xy) * 2.0 - 1.0;\n    float camAspect = iResolution.x/iResolution.y;\n    float fov_y_scale = tan(camFov/2.0);\n    vec3 raydir = vec3(v.x*fov_y_scale*camAspect, v.y*fov_y_scale, -1.0);\n    return normalize(raydir);\n}\n\nfloat ambientOcclusion( in vec3 pos, in vec3 nor, float coneR )\n{\n  float occ = 0.0;\n  float sca = 1.1;\n  for ( int i=0; i<5; i++ )\n  {\n    float hr = 0.02 + 0.11*float(i) / 4.0;\n    vec3 aopos =  nor * hr + pos;\n    float dd = sdf(aopos);\n    occ += -(dd-hr)*sca;\n    sca *= 0.95;\n  }\n  return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );\n}\n\n\nvec3 shade(vec3 ro, vec3 rd, float t, float coneR, vec3 ld)\n{\n    vec3 g = grad(ro+rd*t, coneR);\n    vec3 N = normalize(g);\n    float ambo = ambientOcclusion(ro+rd*t, N, coneR);\n    float ndl = clamp(dot(N, ld), 0.0, 1.0);\n    vec3 color = mix(vec3(0.782, 0.569, 0.45), vec3(0.8, 0.678, 0.569), clamp(1.5-length(g), 0.0, 1.0));\n    return vec3(mix(ambo*color, ambo*color*ndl, 0.5));\n}\n\nfloat fogmap(in vec3 p, in float d)\n{\n    vec3 q = p;\n    q.z-=0.0;\n    p.x -= iTime*0.05;\n    vec3 turb = vec3(noise(80.0*p.xyz+iTime*0.51)*0.5, noise(160.0*p.xzy+iTime*0.2)*0.3, noise(60.0*p.zyx+iTime*0.1)*0.2);\n    p += turb;\n    float fog = (max(noise(p*64.0+0.1)-0.1, 0.0)*noise(p*16.0))*0.03;\n    \n    return fog;\n}\n\n\n#define iterations 14\n#define formuparam 0.530\n\n#define volsteps 3\n#define stepsize 0.2\n\n#define zoom   1.20\n#define tile   0.850\n#define speed  0.1\n\n#define brightness 0.0015\n#define darkmatter 0.400\n#define distfading 0.160\n#define saturation 0.400\n\nvec3 space(vec2 uv)\n{\n    vec3 v=vec3(0.4);\n    vec3 dir=vec3(uv*zoom,1.);\n\t\n\t//float a2=2.0;\n\tfloat a1=4.0;//+time*0.001;\n\tmat2 rot1=mat2(cos(a1),sin(a1),-sin(a1),cos(a1));\n\tmat2 rot2=rot1;//mat2(cos(a2),sin(a2),-sin(a2),cos(a2));\n\tdir.xz*=rot1;\n\tdir.xy*=rot2;\n\t\n\t//from.x-=time;\n\t//mouse movement\n\tvec3 from=vec3(170.0, 170.2,0.01);\n\tfrom+=vec3(0.0,0.0,-2.);\n\t\n\t//from.x-=iMouse.x;\n\t//from.y-=iMouse.y;\n\t\n\tfrom.xz*=rot1;\n\tfrom.xy*=rot2;\n\t\n\t//volumetric rendering\n\tfloat s=.4,fade=.2;\n\t\n    \n    for (int r=0; r<volsteps; r++) \n    {\n        vec3 q = vec3(0.3, 0.5, -3.0)+s*dir;\n        \n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) \n        { \n\t\t\tp=abs(p)/dot(p,p)-formuparam; // the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n        \n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a*2.; // add contrast\n\t\tif (r>3) fade*=1.-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n    \n    vec3 lightDir = normalize(vec3(0.0, 0.4, -0.3));\n    //float v = mouse.y;\n\tvec3 rayOrigin = vec3(0.0, 0.01, 0.7);\n    mat3 rm = rotationMatrix(vec3(0.0, 0.8, -0.15), -2.1);\n    vec3 rayDir = rm*setupRayDirection(radians(60.0));\n    \n\n    float travel = 0.0;\n    \n    vec3 sp = vec3(0.0);\n    float coneR;\n    vec3 col = space(p)*0.01;\n    float fog = 0.0;\n    \n    for (int i=0; i<256; i++)\n    {\n        \n        coneR = travel * tan(0.5*radians(60.0)/iResolution.y);\n        float sd = sdf(rayOrigin+rayDir*travel);\n        \n        if (sd < coneR)\n        {\n            \n            col = shade(rayOrigin, rayDir, travel, coneR, lightDir);\n            col = mix(col, vec3(0.4, 0.4, 0.5), smoothstep(3.0, 4.0, travel));\n            break;\n        }\n        \n        fog += fogmap(rayOrigin+rayDir*travel, travel);\n        if (travel > 4.0 )\n        {\n            col = mix(col, vec3(0.4, 0.4, 0.5), smoothstep(1.0, 0.0, p.y));\n            break;\n        }\n        \n        travel += min(sd + travel * .001, 8.0);\n        \n        \n    }\n    \n    fog = min(fog, 1.0);\n    \n    \n    \n    col = mix(col, vec3(0.97, .95, .9), fog);\n    col = pow(col, vec3(1.2));\n    \n    vec2 q = fragCoord.xy/iResolution.xy;\n    col *= pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.1);\n    \n    fragColor = vec4(col, 1.0);\n    \n    \n    \n}\n\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mtj3DG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 295, 334, 334, 375], [377, 377, 400, 400, 439], [1092, 1092, 1137, 1137, 1609], [1666, 1805, 1824, 1824, 2260], [2312, 2312, 2333, 2333, 2771], [2773, 2773, 2792, 2792, 2993], [2995, 2995, 3050, 3050, 3074], [3076, 3076, 3108, 3108, 3324], [3326, 3326, 3364, 3364, 3654], [3656, 3656, 3721, 3721, 3986], [3989, 3989, 4050, 4050, 4373], [4375, 4375, 4412, 4412, 4696], [4951, 4951, 4972, 4972, 6211], [6213, 6213, 6270, 6270, 7664]], "test": "error"}
{"id": "MtjGDV", "name": "Maindemoparty logo", "author": "XT95", "description": "Rest in peace â€ŽChristian V Artin ", "tags": ["maindemoparty", "massilia", "christian", "artin", "varou"], "likes": 4, "viewed": 1274, "published": "Public API", "date": "1432736803", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float box( vec3 p, vec3 s )\n{\n  return length(max(abs(p)-s,0.0))-.1;\n}\nfloat noise(vec3 p) //Thx to Las^Mercury\n{\n\tvec3 i = floor(p);\n\tvec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n\tvec3 f = cos((p-i)*acos(-1.))*(-.5)+.5;\n\ta = mix(sin(cos(a)*a),sin(cos(1.+a)*(1.+a)), f.x);\n\ta.xy = mix(a.xz, a.yw, f.y);\n\treturn mix(a.x, a.y, f.z);\n}\n\nfloat sphere(vec3 p, vec4 spr)\n{\n\treturn length(spr.xyz-p) - spr.w;\n}\n\nfloat flame(vec3 p)\n{\n\tfloat d = sphere(p*vec3(1.,.5,1.), vec4(3.,2.,.0,1.));\n\treturn d + (noise(p+vec3(.0,-iTime*4.,.0)) + noise(p*3.)*.5)*.15*(p.y-2.) ;\n}\n\nfloat map( in vec3 p )\n{\n\tp.x -= 17./2.;\n\tfloat d = 999999.;\n\tvec3 pp = p-vec3(17./2.,0.,0.);\n\tpp.xy = mod(p.xy,vec2(1.))-.5;\n\td = min(d, box(pp,vec3(.3,.3,1.)) );\n\td = max(d, p.x);\n\td = max(d, -p.x-17.);\n\td = max(d, p.y-4.);\n\td = max(d, -p.y);\n\td = max(d, -box(p+vec3(16.5,-3.5,0.), vec3(.4,.4,2.)) );\n\td = max(d, -box(p+vec3(14.5,-3.5,0.), vec3(.4,.4,2.)) );\n\td = max(d, -box(p+vec3(11.5,-3.5,0.), vec3(1.4,.4,2.)) );\n\td = max(d, -box(p+vec3(5.5,-3.5,0.), vec3(2.4,.4,2.)) );\n\td = max(d, -box(p+vec3(0.5,-3.5,0.), vec3(.4,.4,2.)) );\n\td = max(d, -box(p+vec3(15.5,-1.5,0.), vec3(.4,1.4,2.)) );\n\td = max(d, -box(p+vec3(13.5,-1.5,0.), vec3(.4,1.4,2.)) );\n\td = max(d, -box(p+vec3(11.5,-1.5,0.), vec3(.4,1.4,2.)) );\n\td = max(d, -box(p+vec3(6.5,-1.5,0.), vec3(.4,1.4,2.)) );\n\td = max(d, -box(p+vec3(4.5,-1.5,0.), vec3(.4,1.4,2.)) );\n\td = max(d, -box(p+vec3(9.,-.5,0.), vec3(.9,.4,2.)) );\n\td = max(d, -box(p+vec3(9.,-2.5,0.), vec3(.9,.4,2.)) );\n\td = max(d, -box(p+vec3(2.,-1.5,0.), vec3(.9,1.4,3.)) );\n\td = max(d, -box(p+vec3(5.,-2.5,0.), vec3(.9,.4,3.)) );\n\td = min(d, (flame(p+vec3(17./2.,0.,0.))));\n\treturn d;\n}\n\nvec3 raymarch(in vec3 org, in vec3 dir)\n{\n\tfloat d = 0.0, glow = 0.0, eps = 0.02;\n\tvec3  p = org;\n\t\n\tfor(int i=0; i<64; i++)\n\t{\n\t\td = map(p) + eps;\n\t\tp += d * dir;\n\t\tif( d<eps )\n\t\t\tbreak;\n\t}\n\treturn p;\n}\nvec3 normal(in vec3 p)\n{\n    vec3 eps = vec3(0.01,0.0,0.0);\n    return normalize(vec3(\n        map(p+eps.xyy)-map(p-eps.xyy),\n        map(p+eps.yxy)-map(p-eps.yxy),\n        map(p+eps.yyx)-map(p-eps.yyx)\n    ));\n}\nfloat ambiantOcclusion( in vec3 p, in vec3 n, in float d)\n{\n    float dlt = 0.1;\n    float oc = 1.0;\n    \n    for(int i=1; i<=6; i++)\n    {\n\t\tfloat dist = abs(map(p+n*dlt));\n\t\tdlt += dist;\n\t\toc += map(p+n*dlt)+dist;\n    }\n    oc /= 6.;\n    \n    return 1. - exp(-oc*d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 v = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\tv.x *= iResolution.x/iResolution.y;\n\tvec3 col = vec3(0.);\n\tvec3 org = vec3(0.,2.5,8.);\n\tvec3 dir = normalize( vec3( v.xy, -1.5+length(v)*.25 ) );\n\n\n\tvec3 p = raymarch(org,dir);\n\tvec3 n = normal(p);\n\tcol = vec3(0.) ;\n\tfloat f = flame(p);\n\tif(f<.1)\n\t{\n\t\tcol = vec3(1.,.5,.1);\n\t}\n\telse if(map(p)<.1)\n\t{\n\t\tcol += ambiantOcclusion(p,-dir,1.5);\n\t\tcol *= ambiantOcclusion(p,n,1.5);\n\t\tcol += vec3(1.,.5,.1) / (.5+pow(f,2.));\n\t}\n\tfragColor = vec4(col*min(iTime*.25,1.), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtjGDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 70], [71, 71, 113, 113, 350], [352, 352, 384, 384, 421], [423, 423, 444, 444, 579], [581, 581, 605, 605, 1689], [1691, 1691, 1732, 1732, 1894], [1895, 1895, 1919, 1919, 2107], [2108, 2108, 2167, 2167, 2378], [2380, 2380, 2437, 2437, 2960]], "test": "valid"}
{"id": "MtjGRd", "name": "Palette Dithering Test", "author": "Flyguy", "description": " Testing palette dithering using the bayer matrix texture and colors from the Commodore 64's color palette.", "tags": ["raymarching", "dither", "c64", "palette"], "likes": 81, "viewed": 5116, "published": "Public API", "date": "1431576207", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define DITHER\n#define AUTO_MODE\n#define DOWN_SCALE 2.0\n\n#define MAX_STEPS 196\n#define MIN_DIST 0.002\n#define NORMAL_SMOOTHNESS 0.1\n#define PI 3.14159265359\n\n#define PALETTE_SIZE 16\n#define SUB_PALETTE_SIZE 8\n\n#define RGB(r,g,b) (vec3(r,g,b) / 255.0)\n\nvec3 palette[PALETTE_SIZE];\nvec3 subPalette[SUB_PALETTE_SIZE];\n\n//Initalizes the color palette.\nvoid InitPalette()\n{\n    //16-Color C64 color palette.\n\tpalette = vec3[](\n        RGB(  0,  0,  0),\n        RGB(255,255,255),\n        RGB(152, 75, 67),\n        RGB(121,193,200),\t\n        RGB(155, 81,165),\n        RGB(104,174, 92),\n        RGB( 62, 49,162),\n        RGB(201,214,132),\t\n        RGB(155,103, 57),\n        RGB(106, 84,  0),\n        RGB(195,123,117),\n        RGB( 85, 85, 85),\t\n        RGB(138,138,138),\n        RGB(163,229,153),\n        RGB(138,123,206),\n        RGB(173,173,173)\n\t);\n    \n    //8-Color metalic-like sub palette.\n\tsubPalette = vec3[](\n        palette[ 6],\n        palette[11],\n        palette[ 4],\n        palette[14],\n        palette[ 5],\n        palette[ 3],\n        palette[13],\n        palette[ 1]\n\t);\n\t\n}\n\n//Blends the nearest two palette colors with dithering.\nvec3 GetDitheredPalette(float x,vec2 pixel)\n{\n\tfloat idx = clamp(x,0.0,1.0)*float(SUB_PALETTE_SIZE-1);\n\t\n\tvec3 c1 = vec3(0);\n\tvec3 c2 = vec3(0);\n\t\n\tc1 = subPalette[int(idx)];\n    c2 = subPalette[int(idx) + 1];\n    \n    #ifdef DITHER\n    \tfloat dith = texture(iChannel0, pixel / iChannelResolution[0].xy).r;\n    \tfloat mixAmt = float(fract(idx) > dith);\n    #else\n    \tfloat mixAmt = fract(idx);\n    #endif\n    \n\treturn mix(c1,c2,mixAmt);\n}\n\n//Returns a 2D rotation matrix for the given angle.\nmat2 Rotate(float angle)\n{\n\treturn mat2(cos(angle), sin(angle), -sin(angle), cos(angle));   \n}\n\n//Distance field functions & operations by iq. (http://iquilezles.org/www/articles/distfunctions/distfunctions.htm)\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opI( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return q;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\n//Scene definition/distance function.\nfloat Scene(vec3 pos)\n{\n    float map = -sdSphere(pos, 24.0);\n    \n    vec3 rep = opRep(pos - 2.0, vec3(4.0));\n    \n    map = opU(map, opI(sdBox(pos, vec3(5.5)), sdSphere(rep, 1.0)));\n    \n    vec3 gSize = vec3(0, 0, 0.25);\n    \n    float grid = opU(opU(sdCylinder(rep.xyz, gSize), sdCylinder(rep.xzy, gSize)), sdCylinder(rep.zxy, gSize));\n     \n    grid = opI(sdBox(pos,vec3(4.5)),grid);\n    \n    map = opU(map, grid);\n    \n    return map;\n}\n\n//Returns the normal of the surface at the given position.\nvec3 Normal(vec3 pos)\n{\n\tvec3 offset = vec3(NORMAL_SMOOTHNESS, 0, 0);\n    \n    vec3 normal = vec3\n    (\n        Scene(pos - offset.xyz) - Scene(pos + offset.xyz),\n        Scene(pos - offset.zxy) - Scene(pos + offset.zxy),\n        Scene(pos - offset.yzx) - Scene(pos + offset.yzx)\n    );\n    \n    return normalize(normal);\n}\n\n//Marches a ray defined by the origin and direction and returns the hit position.\nvec3 RayMarch(vec3 origin,vec3 direction)\n{\n    float hitDist = 0.0;\n    \n    for(int i = 0;i < MAX_STEPS;i++)\n    {\n        float sceneDist = Scene(origin + direction * hitDist);\n        \n        hitDist += sceneDist;\n        \n        if(sceneDist < MIN_DIST)\n        {\n            break;\n        }\n    }\n    \n    return origin + direction * hitDist;\n}\n\n//Scene shading.\nvec3 Shade(vec3 position, vec3 normal, vec3 rayOrigin,vec3 rayDirection,vec2 pixel)\n{\n    vec3 color = vec3(0);\n    \n    float ang = iTime * 2.0;\n    \n    vec3 lightPos = vec3(cos(ang), cos(ang*2.0), sin(ang)) * 2.0;  \n    \n    //Normal shading\n\tfloat shade = 0.4 * max(0.0, dot(normal, normalize(-lightPos)));\n    \n    //Specular highlight\n    shade += 0.6 * max(0.0, dot(-reflect(normalize(position - lightPos), normal), rayDirection));\n    \n    //Linear falloff\n    shade *= (16.0-distance(position, lightPos))/16.0,\n    \n    //Apply palette\n    color = GetDitheredPalette(shade, pixel);\n\n    //color = mix(color, vec3(0.1), step(22.0, length(position)));\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitPalette();\n    \n    vec2 aspect = iResolution.xy / iResolution.y;\n    \n    fragCoord = floor(fragCoord / DOWN_SCALE) * DOWN_SCALE;\n    \n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n    vec2 mouse = iMouse.xy / iResolution.xy - 0.5;\n    \n    vec2 camAngle = vec2(0);\n    \n    #ifdef AUTO_MODE\n\t\tcamAngle.x = PI * (-1.0 / 8.0) * sin(iTime * 0.5);\n    \tcamAngle.y = -iTime;\n    #else\n        camAngle.x = PI * mouse.y + PI / 2.0;\n        camAngle.x += PI / 3.0;\n\n        camAngle.y = 2.0 * PI * -mouse.x;\n        camAngle.y += PI;\n    #endif\n    \n    vec3 rayOrigin = vec3(0 , 0, -16.0);\n    vec3 rayDirection = normalize(vec3(uv - aspect / 2.0, 1.0));\n    \n    mat2 rotateX = Rotate(camAngle.x);\n    mat2 rotateY = Rotate(camAngle.y);\n    \n    //Transform ray origin and direction\n    rayOrigin.yz *= rotateX;\n    rayOrigin.xz *= rotateY;\n    rayDirection.yz *= rotateX;\n    rayDirection.xz *= rotateY;\n    \n    vec3 scenePosition = RayMarch(rayOrigin, rayDirection);\n    \n    vec3 outColor = Shade(scenePosition,Normal(scenePosition), rayOrigin, rayDirection, fragCoord / DOWN_SCALE);\n    \n    //Palette preview\n    if(uv.x < 0.05) \n    {\n        outColor = GetDitheredPalette(uv.y, fragCoord / DOWN_SCALE);\n    }\n    \n\tfragColor = vec4(outColor, 1.0);\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtjGRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[316, 348, 368, 402, 1085], [1087, 1143, 1188, 1188, 1582], [1584, 1636, 1662, 1662, 1730], [1732, 1848, 1881, 1881, 1906], [1908, 1908, 1941, 1941, 1967], [1969, 1969, 2002, 2002, 2027], [2029, 2029, 2059, 2059, 2104], [2106, 2106, 2141, 2141, 2165], [2167, 2167, 2198, 2198, 2294], [2296, 2296, 2332, 2332, 2366], [2368, 2406, 2429, 2429, 2848], [2850, 2909, 2932, 2932, 3232], [3234, 3316, 3359, 3359, 3669], [3671, 3688, 3773, 3773, 4371], [4373, 4373, 4430, 4430, 5693]], "test": "error"}
{"id": "MtjGRK", "name": "Rainbow of N00bs", "author": "anastadunbar", "description": "Was very bored and had to do this.", "tags": ["2d", "test", "noise", "perlin", "noob", "rainbow", "hue", "hsl"], "likes": 21, "viewed": 427, "published": "Public", "date": "1430509350", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265358979323\n\n//Random\nfloat rand(vec2 uv)\n{\n    float dt = dot(uv, vec2(12.9898, 78.233));\n\treturn fract(sin(mod(dt, PI / 2.0)) * 43758.5453);\n}\n\n\n//HSL\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\n//My function for rainbow\nfloat grid(float val, float scale)\n{\n    return mix(floor(val*scale)/scale,val,0.2);\n}\n\n//Clouds from (https://www.shadertoy.com/view/MlS3z1)\nconst int iter = 8;\n   \nfloat turbulence(vec2 fragCoord, float octave, int id)\n{\n    float col = 0.0;\n    vec2 xy;\n    vec2 frac;\n    vec2 tmp1;\n    vec2 tmp2;\n    float i2;\n    float amp;\n    float maxOct = octave;\n    for (int i = 0; i < iter; i++)\n    {\n        amp = maxOct / octave;\n        i2 = float(i);\n        xy = id == 1 || id == 4? (fragCoord + 50.0 * float(id) * iTime / (4.0 + i2)) / octave : fragCoord / octave;\n        frac = fract(xy);\n        tmp1 = mod(floor(xy) + iResolution.xy, iResolution.xy);\n        tmp2 = mod(tmp1 + iResolution.xy - 1.0, iResolution.xy);\n        col += frac.x * frac.y * rand(tmp1) / amp;\n        col += frac.x * (1.0 - frac.y) * rand(vec2(tmp1.x, tmp2.y)) / amp;\n        col += (1.0 - frac.x) * frac.y * rand(vec2(tmp2.x, tmp1.y)) / amp;\n        col += (1.0 - frac.x) * (1.0 - frac.y) * rand(tmp2) / amp;\n        octave /= 2.0;\n    }\n    return (col);\n}\n//____________________________________________________\n\n//Draw on screen\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float time = iTime;\n    //Rainbow's positions\n    vec2 rainbowuv = vec2(((uv.x*4.)-1.5)+(sin((time*1.0)+uv.y*PI)/3.),0.);\n    //Make a rainbow\n    vec3 rainbow = clamp(hsl2rgb(vec3(grid(rainbowuv.x+rainbowuv.y,8.)-0.05,1.,0.5))*vec3(1.7,1.4,1.2),0.,1.);\n    //Make a rainbow mask\n    float rainbowmask = 1.-(float((rainbowuv.x+rainbowuv.y) < 0.)+float((rainbowuv.x+rainbowuv.y) > 1.));\n    \n    //Sky\n    vec3 sky = clamp(vec3(0.2,sin(uv.y),1.)+0.3,0.,1.);\n    \n    //Sky+Rainbow\n    vec3 skyandrainbow = (mix(sky,rainbow,rainbowmask));\n    \n    //Clouds\n    float cloud1 = turbulence(fragCoord, 128.0, 1);\n    float cloud2 = turbulence(fragCoord+2000., 128.0, 1);\n    float cloudss = clamp(pow(mix(cloud1,cloud2,0.5),30.)/9.,0.,1.);\n    \n    //Output\n\tfragColor = vec4(skyandrainbow+cloudss,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtjGRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 41, 62, 62, 163], [166, 172, 199, 199, 342], [344, 370, 406, 406, 456], [458, 536, 592, 592, 1410], [1467, 1484, 1541, 1541, 2387]], "test": "valid"}
{"id": "MtSGRt", "name": "crystal beacon", "author": "ryk", "description": "Experimenting with folded and rotated distance fields.", "tags": ["raymarch"], "likes": 89, "viewed": 2585, "published": "Public", "date": "1431292903", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float time;\nfloat atime;\n\nstruct Ray\n{\n\tvec3 org;\n\tvec3 dir;\n};\n\nvec3 background(vec3 dir){\n    float a = atan(dir.y, dir.x);\n    float f = dir.z;\n    vec3 nadir = vec3(.1,.3,.5);\n    vec3 ground = vec3(.1,.6,.2);\n    vec3 sky = vec3(1.);\n    vec3 zenith = vec3(.0, .0, .2);\n    vec3 col = f < 0. ? mix(nadir, ground, f+1.) : mix(sky, zenith, pow(f,.25));\n    return col * (5.+sin(a*2.))/6.*2.5;\n}\n\nvec4 box(vec3 p, float w){\n    p = abs(p);\n    float dx = p.x-w;\n    float dy = p.y-w;\n    float dz = p.z-w;\n    float m = max(p.x-w, max(p.y-w, p.z-w));\n    return vec4(m,dx,dy,dz);\n}\n\nmat3 rotateX(float a){\n    return mat3(1.,0.,0.,\n                0.,cos(a), -sin(a),\n                0.,sin(a), cos(a));\n}\n\nmat3 rotateY(float a){\n    return mat3(cos(a), 0., -sin(a),\n                0.,1.,0.,\n                sin(a), 0., cos(a));\n}\n\nmat3 rotation;\nfloat jitter;\n\nvec4 map(vec3 p){\n    for (int i = 0; i < 5; i++){\n        p = abs(p*rotation + vec3(0.1, .0, .0));\n        p.y -= .8;\n        p.x -= .06;\n        p.z -= jitter;\n        p.xy = p.yx;\n    }\n    return box(p, .6);\n}\n\nvec3 normal(vec3 pos)\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nvec3 render(Ray ray){\n    float dist = 0.;\n    vec3 pos;\n    for (int i = 0; i < 60; i++){\n        pos = ray.org + dist*ray.dir;\n        dist+=map(pos).x;\n    }\n    vec4 m = map(pos);\n    if (m.x < 0.01){\n        vec3 n = normal(pos);\n        vec3 l = normalize(vec3(1.,2.,5.));\n        vec3 diffuse = clamp(dot(n, l),0., 1.)*vec3(1.);\n        vec3 r = reflect(ray.dir, n);\n        vec3 refl = background(r);\n        float dx = m.y;\n        float dy = m.z;\n        float dz = m.w;\n        float start = 0.00;\n        float end = 0.05;\n        float f = smoothstep(start, end, abs(dx-dy));\n        f *= smoothstep(start, end, abs(dx-dz));\n        f *= smoothstep(start, end, abs(dz-dy));\n        f = 1. - f;\n        float rf = 1.-abs(dot(ray.dir, n));\n        rf = pow(rf,3.);\n        float flash = 1.-fract(atime);\n        flash = sqrt(flash);\n        return diffuse*(1.-rf)*.8 + flash*f*vec3(2.9, 1.4, 1.2) + refl*rf*1.3; \n    }\n\n    //return vec3(0.);\n    return background(ray.dir)*0.2;\n}\n\nRay createRay(vec3 center, vec3 lookAt, vec3 up, vec2 uv, float fov, float aspect)\n{\n\tRay ray;\n\tray.org = center;\n\tvec3 dir = normalize(lookAt - center);\n\tup = normalize(up - dir*dot(dir,up));\n\tvec3 right = cross(dir, up);\n\tuv = 2.*uv - vec2(1.);\n\tfov = fov * 3.1415/180.;\n\tray.dir = dir + tan(fov/2.) * right * uv.x + tan(fov/2.) / aspect * up * uv.y;\n\tray.dir = normalize(ray.dir);\t\n\treturn ray;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime;\n    vec2 p = fragCoord.xy / iResolution.xy;\n\tvec3 cameraPos = vec3(7.*sin(time/3.),7.*cos(time/3.),-4.*sin(time/8.));\n\tvec3 lookAt = vec3(0.);\n\tvec3 up = vec3(0.,0.,1.);\n\tfloat aspect = iResolution.x/iResolution.y;\n    float t = floor(time);\n    float f = fract(time);\n    t += 1. - exp(-f*9.);\n    atime = t;\n    rotation = rotateX(atime*1.9)*rotateY(atime*1.4);\n    jitter = sin(time*80.)*.1*pow((1.-fract(time)),4.);\n\tRay ray = createRay(cameraPos, lookAt, up, p, 90., aspect);\n    vec3 col = render(ray);\n    float vig = p.x*(1.-p.x)*p.y*(1.-p.y)*4.;\n    vig = pow(vig,0.3);\n    col *= vig;\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtSGRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 65, 91, 91, 397], [399, 399, 425, 425, 583], [585, 585, 607, 607, 707], [709, 709, 731, 731, 833], [865, 865, 882, 882, 1078], [1080, 1080, 1103, 1103, 1324], [1326, 1326, 1347, 1347, 2317], [2319, 2319, 2403, 2403, 2718], [2720, 2720, 2777, 2777, 3420]], "test": "valid"}
{"id": "MtSGWG", "name": "Skateboard camo version", "author": "yasuo", "description": "it's just my drawing staff that I really like to draw, and experiment.", "tags": ["3d", "skateboard"], "likes": 7, "viewed": 852, "published": "Public API", "date": "1431798043", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\t\t#define NEAR 0.1\n\t\t#define FAR 100.\n\t\t#define ITER 128\n\t\t#define HALF_PI 1.5707963267948966\n\t\tconst float PI = 3.14159265359;\n\t\tconst float DEG_TO_RAD = PI / 180.0;\n\t\tfloat gt;\n\t\tfloat gtime;\n\n\t\tmat4 matRotateX(float rad)\n\t\t{\n\t\t\treturn mat4(1,       0,        0,0,\n\t\t\t\t\t\t0,cos(rad),-sin(rad),0,\n\t\t\t\t\t\t0,sin(rad), cos(rad),0,\n\t\t\t\t\t\t0,       0,        0,1);\n\t\t}\n\n\t\tmat4 matRotateY(float rad)\n\t\t{\n\t\t\treturn mat4( cos(rad),0,-sin(rad),0,\n\t\t\t\t\t\t 0,       1,        0,0,\n\t\t\t\t\t\t sin(rad),0, cos(rad),0,\n\t\t\t\t\t\t 0,       0,        0,1);\n\t\t}\n\n\t\tmat4 matRotateZ(float rad)\n\t\t{\n\t\t\treturn mat4(cos(rad),-sin(rad),0,0,\n\t\t\t\t\t\tsin(rad), cos(rad),0,0,\n\t\t\t\t\t\t       0,        0,1,0,\n\t\t\t\t\t\t\t   0,        0,0,1);\n\t\t}\n\n\t\tvec4 combine(vec4 val1, vec4 val2 )\n\t\t{\n\t\t\tif ( val1.w < val2.w ) return val1;\n\t\t\treturn val2;\n\t\t}\n\t\t\n\t\tvec2 rot(vec2 p, float a) {\n\t\t\treturn vec2(\n\t\t\t\tcos(a) * p.x - sin(a) * p.y,\n\t\t\t\tsin(a) * p.x + cos(a) * p.y);\n\t\t}\n\n\t\t// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\t\tfloat sdCappedCylinder( vec3 p, vec2 h )\n\t\t{\n\t\t  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n\t\t  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n\t\t}\n\n\t\t// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\t\tfloat sdCone( vec3 p, float r, float h )\n\t\t{\n\t\t\tvec2 c = normalize( vec2( h, r ) );\n\t\t    float q = length(p.xy);\n\t\t    return max( dot(c,vec2(q,p.z)), -(p.z + h) );\n\t\t}\n\n\t\t// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\t\tfloat udRoundBox( vec3 p, vec3 b, float r )\n\t\t{\n\t\t  return length(max(abs(p)-b,sin(r*0.1)))-r;\n\t\t}\n\n\t\tfloat rand( vec2 p )\n\t\t{\n\t\t\treturn fract(sin(dot(p.xy ,vec2(12.9898,78.233))) * 43758.5453);\n\t\t}\n\n\t\tfloat noise(vec2 _v, vec2 _freq)\n\t\t{\n\t\t\tfloat fl1 = rand(floor(_v * _freq));\n\t\t\tfloat fl2 = rand(floor(_v * _freq) + vec2(1.0, 0.0));\n\t\t\tfloat fl3 = rand(floor(_v * _freq) + vec2(0.0, 1.0));\n\t\t\tfloat fl4 = rand(floor(_v * _freq) + vec2(1.0, 1.0));\n\t\t\tvec2 fr = fract(_v * _freq);\n\n\t\t\tfloat r1 = mix(fl1, fl2, fr.x);\n\t\t\tfloat r2 = mix(fl3, fl4, fr.x);\n\t\t\treturn mix(r1, r2, fr.y);\n\t\t}\n\n\t\tfloat perlin_noise(vec2 _pos, float _freq_start, float _amp_start, float _amp_ratio)\n\t\t{\n\t\t\tfloat freq = _freq_start;\n\t\t\tfloat amp = _amp_start;\n\t\t\tfloat pn = noise(_pos, vec2(freq, freq)) * amp;\n\t\t\tfor(int i=0; i<4; i++)\n\t\t\t{\n\t\t\t\tfreq *= 2.0;\n\t\t\t\tamp *= _amp_ratio;\n\t\t\t\tpn += (noise(_pos, vec2(freq, freq)) * 2.0 - 1.0) * amp;\n\t\t\t}\n\t\t\treturn pn;\n\t\t}\n\n\t\tvec3 texmain(vec2 position) {\n\t\t\tfloat noise = perlin_noise( position + vec2(10, 10), 3., .3, .3 );\n\t\t\t\n\t\t\tfloat t = iTime*2.0;\n\t\t\tfor(int i=1;i<3;i++)\n\t\t\t{\n\t\t\t\tvec2 newp=position;\n\t\t\t\tnewp.x+=3.3/float(i)*cos(float(i)*position.y+t*0.3+0.3*float(i))+noise;\n\t\t\t\tnewp.y+=2.3/float(i)*sin(float(i)*position.x+t*0.5+0.3*float(i))-noise;\n\t\t\t\tposition=newp;\n\t\t\t}\n\t\t\tvec3 col=vec3(0.35*sin(1.1*position.x),0.5*sin(2.0*position.y),0.1*sin(position.x));\n\t\n\t\t\treturn col;\n\t\t}\n\n\t\tvec4 map( vec3 pos, mat4 m)\n\t\t{\n\t\t\tpos = vec3((pos.x),(pos.y),(pos.z));\n\t\t\tvec4 q = vec4(pos+vec3(0,0,-70.0),1.0)*m;\n\n\t\t\tvec3 bcl = texmain(q.xz);\n\t\t\t//vec3 bcl = vec3(1.0,1.0,0);\n\t\t\tvec4 newQ = vec4(q.xyz+ vec3( 0, -4.0, -18.0 ),1.0)*matRotateX(12.0 * DEG_TO_RAD);\n\t\t\tvec4 val = vec4(bcl,udRoundBox(newQ.xyz,vec3(7.0,0.1,3.0),0.5));\n\n\t\t\tvec4 newQ0 = vec4(q.xyz+ vec3( 0, -3.5, 2 ),1.0);\n\t\t\tvec4 val0 = vec4(bcl,udRoundBox(newQ0.xyz,vec3(7.0,0.1,18.0),0.5));\n\n\t\t\tvec4 newQ1 = vec4(q.xyz+ vec3( 6, 0, 15 ),1.0)*matRotateZ(-90.0 * DEG_TO_RAD);\n\t\t\tvec4 val1 = vec4(1.0,0,0,sdCappedCylinder(newQ1.xyz,vec2(2.0,2.0)));\n\n\t\t\tvec4 newQ2 = vec4(q.xyz+ vec3( -6, 0, 15 ),1.0)*matRotateZ(-90.0 * DEG_TO_RAD);\n\t\t\tvec4 val2 = vec4(1.0,0,0,sdCappedCylinder(newQ2.xyz,vec2(2.0,2.0)));\n\n\t\t\tvec4 newQ3 = vec4(q.xyz+ vec3( 0, 0, 15 ),1.0)*matRotateZ(-90.0 * DEG_TO_RAD);\n\t\t\tvec4 val3 = vec4(0.7,0.7,0.7,sdCappedCylinder(newQ3.xyz,vec2(1.0,5.0)));\n\n\t\t\tvec4 newQ4 = vec4(q.xyz+ vec3( -0, 0, 15 ),1.0)*matRotateX(-90.0 * DEG_TO_RAD);\n\t\t\tvec4 val4 = vec4(0.3,0.3,0.3,sdCone(newQ4.xyz,2.0,4.0));\n\n\n\t\t\tvec4 newQ5 = vec4(q.xyz+ vec3( 6, 0, -15 ),1.0)*matRotateZ(-90.0 * DEG_TO_RAD);\n\t\t\tvec4 val5 = vec4(1.0,0,0,sdCappedCylinder(newQ5.xyz,vec2(2.0,2.0)));\n\n\t\t\tvec4 newQ6 = vec4(q.xyz+ vec3( -6, 0, -15 ),1.0)*matRotateZ(-90.0 * DEG_TO_RAD);\n\t\t\tvec4 val6 = vec4(1.0,0,0,sdCappedCylinder(newQ6.xyz,vec2(2.0,2.0)));\n\n\t\t\tvec4 newQ7 = vec4(q.xyz+ vec3( 0, 0, -15 ),1.0)*matRotateZ(-90.0 * DEG_TO_RAD);\n\t\t\tvec4 val7 = vec4(0.7,0.7,0.7,sdCappedCylinder(newQ7.xyz,vec2(1.0,5.0)));\n\n\t\t\tvec4 newQ8 = vec4(q.xyz+ vec3( 0, 0, -15 ),1.0)*matRotateX(-90.0 * DEG_TO_RAD);\n\t\t\tvec4 val8 = vec4(0.3,0.3,0.3,sdCone(newQ8.xyz,2.0,4.0));\n\n\t\t\tvec4 val9 = combine ( val, val0 );\n\t\t\tvec4 val10 = combine ( val1, val2 );\n\t\t\tvec4 val11 = combine ( val3, val4 );\n\t\t\tvec4 val12 = combine ( val5, val6 );\n\t\t\tvec4 val13 = combine ( val7, val8 );\n\t\t\tvec4 val14 = combine ( val9, val10 );\n\t\t\tvec4 val15 = combine ( val11, val12 );\n\t\t\tvec4 val16 = combine ( val13, val14 );\n\t\t\treturn combine ( val15, val16 );\n\t\t}\n\n\t\tvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t\t\tgt = iTime*0.5;\n\n\t\t\tvec2 position = ( fragCoord.xy / iResolution.xy );\n\t\t\tposition -= .5;\n\t\t\tvec3 dir = vec3( position, 1.0 );\n\t\t\t\n         \tfloat aspect = iResolution.x / iResolution.y;\n         \tdir = normalize(vec3(position * vec2(aspect, 1.0), 1.0));\n\t\t \tdir.yz = rot(dir.yz, -0.1);\n\n\t\t \tvec3 pos = vec3(0.0, 3.0, 15.0);\n\t\n\t\t\tfloat t = floor(gt);\n\t\t    float f = fract(gt);\n\t\t    t += sin(-13.0 * (f + 1.0) * HALF_PI) * pow(2.0, -10.0 * f) + 1.0;\n\t\t    gtime = t;\n\n\t\t\tmat4 m = matRotateY(iTime)*matRotateX(gtime)*matRotateZ(gtime);\n\n\t\t\tvec4 result;\n\t\t\tfor (int i =0; i < ITER; i++)\n\t\t\t{\n\t\t\t\tresult = map(pos, m);\n\t\t\t\tif (result.w < NEAR || result.w > FAR) break;\n\t\t\t\tpos += result.w * dir;\n\t\t\t}\n\n\t\t\tvec3 col = map(pos, m).xyz;\n\t\t\tif ( pos.z> 100. )\n\t\t\t{\n\t\t\t\tfloat temp = length(vec2(position.xy))+0.9;\n\t\t\t\tcol = vec3(.5,.5,.5)/vec3(temp);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvec3 lightPos = vec3(20.0, 20.0, 20.0 );\n\t\t\t\tvec3 light2Pos = normalize( lightPos - pos);\n\t\t\t\tvec3 eps = vec3( .1, .01, .0 );\n\t\t\t\tvec3 n = vec3( result.w - map( pos - eps.xyy, m ).w,\n\t\t\t\t\t       result.w - map( pos - eps.yxy, m ).w,\n\t\t\t\t\t       result.w - map( pos - eps.yyx, m ).w );\n\t\t\t\tn = normalize(n);\n\t\t\t\t\t\t\n\t\t\t\tfloat lambert = max(.0, dot( n, light2Pos));\n\t\t\t\tcol *= vec3(lambert);\n\t\t\t\t\n\t\t\t\t// specular : \n\t\t\t\tvec3 h = normalize( -dir + light2Pos);\n\t\t\t\tfloat spec = max( 0., dot( n, h ) );\n\t\t\t\tcol += vec3(pow( spec, 16.)) ;\n\t\t\t}\n\n\t\t\tfragColor = vec4( col, 1.0);\n\t\t}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtSGWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[197, 197, 227, 227, 361], [365, 365, 395, 395, 533], [537, 537, 567, 567, 698], [702, 702, 741, 741, 800], [806, 806, 833, 833, 920], [924, 1000, 1044, 1044, 1149], [1153, 1229, 1273, 1273, 1398], [1402, 1478, 1525, 1525, 1576], [1580, 1580, 1604, 1604, 1676], [1680, 1680, 1716, 1716, 2063], [2067, 2067, 2155, 2155, 2417], [2421, 2421, 2450, 2450, 2886], [2890, 2890, 2921, 2921, 4944], [4948, 4948, 5004, 5004, 6446]], "test": "valid"}
{"id": "MtSGWK", "name": "Triangle fractal bump +mouse", "author": "104", "description": "a bump-map based on a triangle fractal. Use mouse to move light around. Basically I subdivide triangles in two using the longest edge. Makes rock-looking textures. See also https://www.shadertoy.com/view/MlB3WV for a similar experiment with Worley noise", "tags": ["fractal", "mouse", "texture", "bump"], "likes": 18, "viewed": 506, "published": "Public", "date": "1432430933", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// -------------------------------------------------------\n// parameters...\n\n// 0 = random triangle color\n// 1 = stylized, based on distance to triangle\n// 2 = reveal raw distance to triangle\n// 3 = no color, only bump map\n#define COLOR_MODE 1\n\nconst int iterationCount = 14;\n\nconst float iterationColorInfluenceFactor = 0.75;// how much do we attenuate color every iteration\n\n// exponent. higher=tries to keep triangles equal sized. more regular-looking.\n// 0 = turbulent and chaotic\n// 5 starts to look quite \"regular\"\nconst float regularity = 2.2;\n\n#define initialVertexHeight (iResolution.x * 0.05);// basically, how much height variation. how bumpy.\nconst float iterationNormalInfluenceFactor = 0.7;\nconst float heightRandomness = 1.;// 0 = don't randomize heights; make them look uniform by just adding the same every iteration. 1=completely random.\n\n\n// -------------------------------------------------------\n// utilities\nfloat saturate(float n) { return clamp(n,0.,1.); }\n\n// c64 palette because why not.\nvec3 color0 = vec3(0,0,0);// black\nvec3 color1 = vec3(1,1,1);// white\nvec3 color2 = vec3(0.41,0.22,0.17);// red\nvec3 color3 = vec3(0.44,0.64,0.70);// cyan\nvec3 color4 = vec3(0.44,0.24,0.53);// violet\nvec3 color5 = vec3(0.35,0.55,0.26);// green\nvec3 color6 = vec3(0.21,0.16,0.47);// blue\nvec3 color7 = vec3(0.72,0.78,0.44);// yellow\nvec3 color8 = vec3(0.44,0.31,0.15);// orange\nvec3 color9 = vec3(0.26,0.22,0);// brown\nvec3 colorA = vec3(0.60,0.40,0.35);// light red\nvec3 colorB = vec3(0.27,0.27,0.27);// grey1\nvec3 colorC = vec3(0.42,0.42,0.42);// grey2\nvec3 colorD = vec3(0.60,0.82,0.52);// light green\nvec3 colorE = vec3(0.42,0.37,0.71);// light blue\nvec3 colorF = vec3(0.58,0.58,0.58);// grey3\nvec3 getPalette(int i)\n{\n    if(i == 0) return color6;\n    if(i == 1) return color3;\n    if(i == 2) return color5;\n    if(i == 3) return color9;\n    if(i == 4) return color7;\n    return color8;\n}\n\n\n\n\nfloat rand(float n)\n{\n \treturn fract(cos(n*89.42)*343.42);\n}\nvec2 rand(vec2 n)\n{\n \treturn vec2(rand(n.x*23.62-300.0+n.y*34.35),rand(n.x*45.13+256.0+n.y*38.89)); \n}\nvec3 rand(vec3 n)\n{\n \treturn vec3(rand(n.xy), rand(n.z));\n}\nfloat rand1(vec2 n) {\n\t\n  return fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\nfloat rand1(vec3 n) {\n\treturn rand1(vec2(rand1(n.xy), n.z));\n}\nfloat nsin(float a)\n{\n    return (sin(a)+1.)/2.;\n}\nvec4 applyLighting(vec4 inpColor, vec2 uv, vec3 normal, vec3 LightPos, vec4 LightColor, vec4 AmbientColor)\n{\n    if(distance(uv.xy, LightPos.xy) < 0.01) return vec4(1.,0.,0.,1.);\n    vec3 LightDir = vec3(LightPos.xy - uv, LightPos.z);\n    float D = length(LightDir);// distance for attenuation\n    vec3 N = normalize(normal);\n    vec3 L = normalize(LightDir);\n    vec3 Diffuse = (LightColor.rgb * LightColor.a) * max(dot(N, L), 0.0);\n    vec3 Ambient = AmbientColor.rgb * AmbientColor.a;\n    vec3 Intensity = Ambient + Diffuse;\n    vec3 FinalColor = inpColor.rgb * Intensity;\n    return vec4(FinalColor, inpColor.a);\n}\nvec3 calcNormalForTriangle(vec3 a, vec3 b, vec3 c)\n{\n    vec3 dir = cross(b - a, c - a);\n\tvec3 normal = normalize(dir);\n    return normal;\n}\nfloat sgn(vec2 p1, vec2 p2, vec2 p3)\n{\n    return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);\n}\nbool IsPointInTriangle (vec2 pt, vec2 v1, vec2 v2, vec2 v3)\n{\n    bool b1, b2, b3;\n    b1 = sgn(pt, v1, v2) < 0.0;\n    b2 = sgn(pt, v2, v3) < 0.0;\n    b3 = sgn(pt, v3, v1) < 0.0;\n    return ((b1 == b2) && (b2 == b3));\n}\n\n// THANK YOU IQ / https://www.shadertoy.com/view/XsXSz4\n// signed distance to a 2D triangle\nfloat sdTriangle( in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    vec2 d = min( min( vec2( dot( pq0, pq0 ), v0.x*e0.y-v0.y*e0.x ),\n                       vec2( dot( pq1, pq1 ), v1.x*e1.y-v1.y*e1.x )),\n                       vec2( dot( pq2, pq2 ), v2.x*e2.y-v2.y*e2.x ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n// -------------------------------------------------------\n// the algorithm\n\n// calculates the normal & coloring within the given triangle. iteration is done inside here.\n// only call this if you know that uv is within the specified triangle.\nvec4 doStuffForThisTriangle(vec3 a, vec3 b, vec3 c, vec2 uv, out vec3 normal)\n{\n    // points come in with no height info, so generate them.\n    a.z = rand1(a.xy) * initialVertexHeight;\n    b.z = rand1(b.xy) * initialVertexHeight;\n    c.z = rand1(c.xy) * initialVertexHeight;\n    vec4 fragColor = vec4(vec3(0.5),1.0);\n    \n    float colorMix = 1.0;\n    float heightAffect = initialVertexHeight;\n    for(int i = 0; i < iterationCount; ++ i)\n    {\n        // the idea: split this triangle in 2, by finding the longest segment\n        // and splitting it. To do this, first find the longest segment,\n        // then rotate the triangle vertices so AB is the longest segment.\n        float ab = distance(a.xy,b.xy);\n        float bc = distance(b.xy,c.xy);\n        float ca = distance(c.xy,a.xy);\n\t    vec3 temp = c;\n        if(ca > ab && ca > bc)\n        {\n            // ca is longest; rotate to CAB\n            c = b;\n            b = a;\n            a = temp;\n        }\n        else if(bc > ab)\n        {\n            // bc is longest; rotate to BCA\n            c = a;\n            a = b;\n            b = temp;\n        }\n\n        // find a random point between A and B to split at, creating 2 new sub-triangles\n        float pos = rand1(a.xy + b.xy) - 0.5;// from -0.5 to 0.5\n        // this pushes the point towards 0 (the center of the segment).\n        float sgn = sign(pos);// workaround for negative values in pow() - thanks for FabriceNeyret2 for pointing out this bug.\n        // thus, the higher the exponent, the more things look like a regular triangle grid.\n        pos = pow(abs(pos), regularity) * 2.0 * sgn;\n        pos = (pos + 1.) / 2.0;// pos is now 0-1, favoring 0.5\n        vec3 d = mix(a, b, pos);\n        \n        // perturb the new point's height. one way to make this look really accurate\n        // would be to consider the xy position and the angle it will form with other vertices.\n        float randomHeight = (rand1(a.xy + b.xy + pos) * 2.0) - 1.0;// -1 to 1.\n        randomHeight *= heightAffect;\n        d.z += mix(heightAffect, randomHeight, heightRandomness);// find random height for the new point\n        \n        float distToEdge = sdTriangle(a.xy, d.xy, c.xy, uv);// distance from uv to the triangle\n        if(distToEdge < 0.)// triangle 1: ADC\n            b = d;\n        else\n        {\n            // triangle 2: DBC\n            a = d;\n\t\t\tdistToEdge = sdTriangle(a.xy, b.xy, c.xy, uv);\n        }\n\n        // colorize this pixel...\n#if COLOR_MODE == 0\n        float tintAmt = rand1(a.xy+b.xy+c.xy);// pow(dist, 0.2);\n        fragColor = vec4(mix(fragColor.rgb, getPalette(i), tintAmt * colorMix), 1.0);\n#endif\n#if COLOR_MODE == 1 || COLOR_MODE == 2\n        // we know the distance to the edge.\n        // using the center of the triangle we can get a gradient from 0-1 from edge to center\n        vec2 center = (a.xy + b.xy + c.xy) / 3.0;\n        float distToCenter = distance(uv, center);\n        distToEdge = -distToEdge;\n        float tintAmt = distToEdge / (distToCenter + distToEdge);\n        tintAmt = pow(tintAmt, 1.2);\n        tintAmt = 1.0 - tintAmt;\n#if COLOR_MODE == 1\n        fragColor = vec4(mix(fragColor.rgb, getPalette(i), tintAmt * colorMix), 1.0);\n#endif\n#if COLOR_MODE == 2\n        fragColor = vec4(vec3(tintAmt),1.);\n#endif\n#endif\n        // honestly i would expect 0.5 to work here but it really is way too subtle. i don't really understand why.\n\t\theightAffect *= iterationNormalInfluenceFactor;\n        colorMix *= iterationColorInfluenceFactor;\n    }\n\n    // i thought i kept everything clockwise, not sure why i need to flip this.\n    normal = -calcNormalForTriangle(a,b,c);\n    return fragColor;\n}\n\n\n\n\n// -------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 scrollOffset = vec2(iTime * iResolution.x / 17., 0.0);\n    vec2 uv = fragCoord.xy + scrollOffset;\n    \n    vec2 lightPosXY = vec2(nsin(iTime * 1.66), nsin(iTime * 1.99));\n    lightPosXY = (lightPosXY * 0.75) + 0.125;// not so big movement\n    lightPosXY *= iResolution.xy;\n    lightPosXY += scrollOffset;\n    if(iMouse.z > 0.)\n\t    lightPosXY = iMouse.xy + scrollOffset;\n    \n    fragColor = vec4(vec3(0.5), 1.0);// background\n\n    vec3 normal = vec3(0.);\n    vec3 a, b, c;// triangle points\n\n    // top-level rectangle size. we will manually divide the rect into 2 triangles.\n    vec2 tileSize = iResolution.xy / 1.0;\n    vec2 tilePosition = floor(uv / tileSize) * tileSize;// snap to grid of size\n\n    // the goal of everything here is to compute the normal of this fragment.\n    // make sure these are clockwise for normal calculation\n    a = vec3(0., tileSize.y, 0.0);\n    b = vec3(tileSize.x, tileSize.y, 0.0);\n    c = vec3(0., 0., 0.0);\n    a.xy += tilePosition;\n    b.xy += tilePosition;\n    c.xy += tilePosition;\n    if(IsPointInTriangle(uv, a.xy, b.xy, c.xy))\n    {\n    \tfragColor = doStuffForThisTriangle(a, b, c, uv, normal);\n    }\n    else\n    {\n        a = vec3(0.,0., 0.0);\n        b = vec3(tileSize.x, tileSize.y, 0.0);\n        c = vec3(tileSize.x, 0., 0.0);\n        a.xy += tilePosition;\n        b.xy += tilePosition;\n        c.xy += tilePosition;\n       \tfragColor = doStuffForThisTriangle(a, b, c, uv, normal);\n    }\n    \n    // lighting\n#if COLOR_MODE != 2\n    vec3 lightPos = vec3(lightPosXY, iResolution.x / 2.);\n    vec4 lightColor = vec4(0.95,0.9,0.9,1.);\n    vec4 ambientColor = vec4(0.5,0.5,0.9,1.);\n\tfragColor = applyLighting(fragColor, uv, normal, lightPos, lightColor, ambientColor);\n    \n    // show light position.\n    if(distance(uv, lightPosXY) < iResolution.x / 75.)\n        fragColor = vec4(1.0,1.0,0.,1.0);\n#endif\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtSGWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[858, 930, 955, 955, 980], [982, 1711, 1735, 1735, 1906], [1911, 1911, 1932, 1932, 1971], [1972, 1972, 1991, 1991, 2074], [2075, 2075, 2094, 2094, 2134], [2135, 2135, 2156, 2156, 2227], [2228, 2228, 2249, 2249, 2290], [2291, 2291, 2312, 2312, 2341], [2342, 2342, 2450, 2450, 2960], [2961, 2961, 3013, 3013, 3101], [3102, 3102, 3140, 3140, 3216], [3217, 3217, 3278, 3278, 3436], [3438, 3530, 3597, 3597, 4149], [4228, 4394, 4473, 4534, 8048], [8053, 8113, 8170, 8170, 10030]], "test": "valid"}
{"id": "Xl23zc", "name": "Ocean Thing", "author": "Kyle273", "description": "Wroley noise + distance fields. Terribly optimized!\nGoing for a wind-waker style water.", "tags": ["distancefields", "noob", "wroley"], "likes": 8, "viewed": 1590, "published": "Public API", "date": "1431021208", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_ITER = 100;\nconst float MAX_DIST = 20.0;\nconst float EPS = 0.001;\n\n\n\nvec3 camOrigin = vec3(1.0 ,0.0,0.0);\n\n\nfloat length2(vec2 p){\n    return dot(p,p);\n}\n\nfloat noise(vec2 p){\n\treturn fract(sin(fract(sin(p.x) * (43.13311)) + p.y) * 31.0011);\n}\n\nfloat worley(vec2 p) {\n    //Set our distance to infinity\n\tfloat d = 1e30;\n    //For the 9 surrounding grid points\n\tfor (int xo = -1; xo <= 1; ++xo) {\n\t\tfor (int yo = -1; yo <= 1; ++yo) {\n            //Floor our vec2 and add an offset to create our point\n\t\t\tvec2 tp = floor(p) + vec2(xo, yo);\n            //Calculate the minimum distance for this grid point\n            //Mix in the noise value too!\n\t\t\td = min(d, length2(p - tp - noise(tp)));\n\t\t}\n\t}\n\treturn 3.0*exp(-4.0*abs(2.5*d - 1.0));\n}\n\nfloat fworley(vec2 p) {\n    //Stack noise layers \n\treturn sqrt(sqrt(sqrt(\n\t\tworley(p*5.0 + 0.05*iTime) *\n\t\tsqrt(worley(p * 50.0 + 0.12 + -0.1*iTime)) *\n\t\tsqrt(sqrt(worley(p * -10.0 + 0.03*iTime))))));\n}\n   \n\nfloat vNoisePlane(vec3 pos)\n{\n    vec2 xz = (pos.xz)*0.008;\n    float h = fworley(xz) - 2.0;\n    return -pos.y - h;\n    \n}\nfloat sphere(vec3 pos, float radius, vec3 center)\n{\n    float phi = dot(vec3(0.0,1.0,0.0),(normalize(center-pos)));\n    float theta = dot(vec3(1.0,0.0,0.0),(normalize(center-pos)));\n    return length(center-pos)-radius + 0.025*sin(10.0*(phi)) + 0.025*cos(10.0*(theta));\n}\nfloat distFunc(vec3 pos)\n{\n   \n   return  vNoisePlane(pos);\n}\n\nvec4 march(vec3 ray)\n{\n    float totalDist = 0.0;\n    vec3 pos = camOrigin;\n    float dist = EPS;\n    \n    for(int i = 0; i < MAX_ITER; i++)\n    {\n        if(dist < EPS || totalDist > MAX_DIST)\n        \tbreak;\n        dist = distFunc(pos);\n        totalDist += dist;\n        pos += dist*ray;\n    }\n    return vec4(pos,dist);\n}\n\nvec3 light(vec3 pos, vec3 rayDir)\n{\n    float amb = 0.1;\n    vec2 eps = vec2(0.0,EPS);\n    vec3 norm = normalize(vec3(\n        distFunc(pos+eps.yxx)-distFunc(pos-eps.yxx),\n        distFunc(pos+eps.xyx)-distFunc(pos-eps.xyx),\n        distFunc(pos+eps.xxy)-distFunc(pos-eps.xxy)));\n    float diffuse = max(0.0,dot(-rayDir,norm));\n    float spec = pow(diffuse,32.0);\n    return vec3(amb,diffuse,spec);\n                      \n}\nvec4 sun(vec2 uv)\n{\n    float sundist = dot(uv,uv)-0.25;\n    if(sundist < 0.)\n    {\n       \treturn vec4(mix(vec3(0.6,0.5,0.0),vec3(1.0), -sundist/0.5), 1.0);\n    }\n    return vec4(0.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\t vec3 camTarget = vec3(0.0);\n\t\n\tvec3 upDir = vec3(0.0,1.0,0.0);\t\n\tvec3 camDir = normalize(camTarget-camOrigin);\n\tvec3 camRight = normalize(cross(upDir,camOrigin));\n\tvec3 camUp = cross(camDir, camRight);\n\tvec2 uv = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    //Orthographic ray march\n    vec3 rayDir = normalize(camRight*uv.x  + camUp*uv.y + camDir);\n    vec4 point = march(rayDir);\n    if(point.w < EPS)\n    {\n        vec3 amb = vec3(0.4,0.4,0.4);\n        vec3 dif = vec3(0.2,0.2,0.8);\n        vec3 spec =vec3(1.0,1.0,1.0);\n        vec3 l = light(point.xyz,rayDir);\n        vec3 col = amb*l.x + dif*l.y + spec * l.z;\n        fragColor = vec4(col, 1.0);\n        \n        if(fworley(point.xz * 0.008) > 0.9)\n        {\n            fragColor +=vec4(0.6);\n        }\n       \n        \n    }\n    else if(uv.y > -0.03)\n    {\n        \n        fragColor = vec4(mix(vec3(1.5,0.3,0.5),vec3(0.4,0.4,0.9),uv.y),1.0) + sun(uv);\n    }\n    else\n    {\n        fragColor = vec4(0.0);\n    }\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xl23zc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[122, 122, 144, 144, 167], [169, 169, 189, 189, 257], [259, 259, 281, 316, 751], [753, 753, 776, 802, 955], [961, 961, 990, 990, 1083], [1084, 1084, 1135, 1135, 1355], [1356, 1356, 1382, 1382, 1417], [1419, 1419, 1441, 1441, 1745], [1747, 1747, 1782, 1782, 2170], [2171, 2171, 2190, 2190, 2358], [2359, 2359, 2416, 2416, 3439]], "test": "valid"}
{"id": "Xl2GDy", "name": "Hypnoteye", "author": "HellMood", "description": "I was bored, so i did a quick port of [url=https://www.pouet.net/prod.php?which=65604]Hypnoteye 128b[/url]\nWTF, no XOR ?! maybe i'm just stupid :P\nWill do sound later, my initial try caused ear bleedings :D", "tags": ["hypnoteye", "desire", "msdos"], "likes": 9, "viewed": 542, "published": "Public", "date": "1432080231", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Helmut TÃ¶dtmann - HellMood/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Couldn't resist to bring this at least to under 512b :P\n// See the 128b original at https://www.pouet.net/prod.php?which=65604\n// Or directly as video at https://www.youtube.com/watch?v=HIFY5AETrlM\n// Feel free to use any of this. If you got ideas on how to make\n// the XOR pattern faster or smaller, i'd be curious to hear them =)\nvoid mainImage(out vec4 f,in vec2 k )\n{\n\tvec2 uv = k.xy/iResolution.xy - .5;\n    uv.x *= 1.5;\n    float a = atan(uv.y,uv.x)/3.14 + iTime/20. + 9.,r = length(uv),\n    c1=float(r > .1),c2 = float(r < .49),c3 = float(r > .51),v = 0.,p = 2.;\n    r = .2 / r + iTime / 4.;\n    for(int i = 9;i > 0;i--)\n    {\n        p /= 2.;\n\t\tint m = 0;\n        if (a > p)m++;\n        if (r > p)m++;\n        a = mod(a,p);\n        r = mod(r,p);\n        if (m == 1)v += p;\n    }\n    f = vec4(mod(v*8.,1.),mod(v*4.,1.),mod(v,2.),0)*c1*c2+c3;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xl2GDy.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 471, 510, 510, 989]], "test": "valid"}
{"id": "Xl2GWG", "name": "messing around with arc tangent", "author": "shanemarks", "description": "messing around with atangent", "tags": ["tan"], "likes": 1, "viewed": 139, "published": "Public", "date": "1431978379", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n\tvec2 uv = fragCoord.xy / iResolution.xy*(iTime+20.)*10.;\n\t\n        uv.y =atan (uv.x,uv.y)+sin(uv.x);\n\t\t\n\n    \n    \n    vec4 col =  vec4(0,0,cos(uv.x),1.0);\n            uv.x=sin(iTime);\n\n    vec4 mixed = mix(col,vec4(1,1,1,1),sin(uv.x));\n            uv.x-=uv.y;\n\n    \n        vec4 mixed2 = mix(col,vec4(1,1,1,1),sin(uv.x));\n\t\tmixed = mixed2-mixed;\n\n   fragColor = mixed;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xl2GWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 434]], "test": "valid"}
{"id": "XlB3R3", "name": "john's wood grain", "author": "shaktool", "description": "john's wood grain", "tags": ["johnswoodgrain"], "likes": 4, "viewed": 312, "published": "Public", "date": "1430678069", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random( vec2 p )\n{\n    float q = p.x * 269.5 + p.y * 183.3;\n\treturn fract( sin( q ) * 43758.5453 );\n}\n\nfloat noise( vec2 point )\n{\n\tvec2 p = floor( point );\n\tvec2 f = fract( point );\n\treturn mix(\n\t\tmix( random( p + vec2( 0.0, 0.0 ) ), random( p + vec2( 1.0, 0.0 ) ), f.x ),\n\t\tmix( random( p + vec2( 0.0, 1.0 ) ), random( p + vec2( 1.0, 1.0 ) ), f.x ),\n\t\tf.y\n\t);\n}\n\nfloat fractal( vec2 point )\n{\n    float sum = 0.0;\n    float scale = 0.5;\n    for ( int i = 0; i < 5; i++ )\n\t{\n\t\tsum += noise( point ) * scale;\n\t\tpoint *= 2.0;\n        scale /= 2.0;\n\t}\n    \n\treturn sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 point = fragCoord.xy / iResolution.x;\n    point.x += iTime * 0.1;\n    \n    point.y /= 5.0;\n    point.x /= 50.0;\n    float value    = fractal( point * 20.0 );\n    \n    value = value * 40.0;\n    value = fract(value);\n    \n    vec3 darkBrown = vec3( 0.5, 0.1, 0.1 );\n    vec3 lightBrown = vec3( 0.75, 0.4, 0.2 );\n    vec3 color = mix( darkBrown, lightBrown, value );\n    \n    \n\tfragColor.rgb = color;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlB3R3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 107], [109, 109, 136, 136, 369], [371, 371, 400, 400, 575], [577, 577, 634, 634, 1040]], "test": "valid"}
{"id": "XlBGRd", "name": "Rainbow Caverns", "author": "BrwnRyce", "description": "A simple infinite array spherical holes.", "tags": ["3d", "raymarching"], "likes": 2, "viewed": 149, "published": "Public", "date": "1431240009", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 dSphere(vec3 p){\n  \tfloat d = length(p)-4.2;\n  \treturn vec2(d,1);\n}\n\nvec2 oSub(vec2 a, vec2 b){\n  \tfloat d = max(a.x, -b.x);\n  \treturn vec2(d,1);\n}\n\nvec2 infiniteSpheres(vec3 p, vec3 c){\n    vec3 q;\n\tq.x = mod(p.x,c.x)-0.5*c.x;\n    q.y = mod(p.y,c.y)-0.5*c.y;\n    q.z = mod(p.z,c.z)-0.5*c.z;\n\treturn dSphere(q);\n}\n\nvec2 dist(vec3 p){\n  \treturn oSub(vec2(-1,1),infiniteSpheres(p,vec3(7.0, 7.0, 7.0)));                       \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 vPos = -1.0+2.0*q;\n\n    vec3 camUp = vec3(0,\n                      2.0*cos(iTime*0.1),\n                      -2.0*sin(iTime*0.1)); \n  \n    vec3 camPos = vec3(iTime*15.0+8.0*cos(iTime),\n                       3.5,\n                       3.5);\n  \n  \tvec3 camLook = vec3(camPos.x-sin(iTime*0.5),\n\t\t\t\t\t\tcamPos.y+0.2*cos(iTime*0.5),\n                        camPos.z+1.0);\n\n    vec3 vpn = normalize(camLook-camPos);\n  \tvec3 u = normalize(cross(camUp,vpn));\n  \tvec3 v = cross(vpn,u);\n\tvec3 vcv = camPos+vpn;\n  \tvec3 scrCoord = vcv+vPos.x*u*iResolution.x/iResolution.y+vPos.y*v;\n  \tvec3 scp = normalize(scrCoord-camPos);\n\n  \tconst vec3 e = vec3(0.0001,0,0);\n  \tconst float maxDepth = 128.0;\n  \tvec2 d = vec2(0.02,0.0);\n  \tvec3 p;\n\n  \tfloat f = 1.0;\n  \tfor(int i=0; i<128; i++){\n    \tif ((abs(d.x) < .001) || (f > maxDepth)) \n      \t\tbreak;\n    \n    \tf += d.x;\n    \tp = camPos+scp*f;\n    \td = dist(p);\n  \t}\n  \n  \tif (f < maxDepth){\n    \tvec3 color = vec3(0.5+0.7*cos(mod(p.x,11840.0)*0.0400),\n                          0.5+0.7*cos(mod(p.x,11840.0)*0.0100),\n                          0.5+0.7*cos(mod(p.x,11840.0)*0.0200));\n   \n  \t\tvec3 n = vec3(d.x-dist(p-e.xyy).x,\n\t\t\t\t\t  d.x-dist(p-e.yxy).x,\n                  \t  d.x-dist(p-e.yyx).x);\n        \n    \tvec3 N = normalize(n);\n    \tfragColor=vec4(color*dot(N,normalize(camPos-p)),1.0);\n        //fragColor=vec4((16.0/f)*color*vec3(0.7,0.7,0.7),1.0);\n    }else\n    \tfragColor=vec4(0,0,0,1);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlBGRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 72], [74, 74, 100, 100, 152], [154, 154, 191, 191, 318], [320, 320, 338, 338, 430], [432, 432, 486, 486, 1968]], "test": "valid"}
{"id": "XlBGzc", "name": "Contrast illusion", "author": "FabriceNeyret2", "description": "all the diamonds are identical.", "tags": ["illusion", "perception", "short"], "likes": 4, "viewed": 1448, "published": "Public API", "date": "1430755675", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv0 = fragCoord.xy / iResolution.y, uv = -.1+1.2*uv0;\n    vec2 m = iMouse.xy / iResolution.xy;\n    float v = 6.,c=.5;\n\n    uv *= mat2(-1.,.5,1.,.5);\n    \n    if (uv0.x>  (1.-cos(iTime/4.))*.5*iResolution.x/iResolution.y)\n        c = (1.+floor(uv.x*v)+floor(uv.y*v))/(v);\n\n    if ((c>0.) && (c<1.)) {\n\t    c = .5*(fract(uv.x*v)+fract(uv.y*v));\n    \t//c = .5 + .2*(2.*c-1.);\n    }\n    \n\tfragColor = vec4(c);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlBGzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 471]], "test": "valid"}
{"id": "XlBGzy", "name": "yin yang volume 3d", "author": "public_int_i", "description": "yin yang type pattern, tried to use ray marching artifacts as a effect. later i might add in some smoothing instead of the noise.", "tags": ["3d", "volume", "yang", "yin", "marched"], "likes": 1, "viewed": 273, "published": "Public API", "date": "1431447411", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define NOISE\n#define NOISE_AMOUNT .014\n\nconst vec4 yin = vec4(1.);\nconst vec4 yang = vec4(0.,0.,0.,1.);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ctime = cos(iTime);\n\n\tvec3 rd = vec3(fragCoord.xy/iResolution.xy-vec2(.5), .5);\n    rd.y *= iResolution.y/iResolution.x;\n    rd = normalize(rd);\n    \n    vec3 rp = vec3(0.,0.,-5.);\n    \n    \n    float f1,f2;\n    vec4 cb = vec4(0.);\n    vec4 c = vec4(0.);\n    float d,db;\n    for (int i = 0; i < 32; i++) {\n        d = length(rp);\n        db = max(3.-d,0.);\n        \n        f1 = fract((rp.x*rp.z+rp.y/(4.4+ctime*4.))*(.4+ctime*.3));\n        f2 = 1.-f1;\n        \n        cb = (yin*f1 + yang*f2)*db;\n        c = mix(c,cb,cb.w);\n        \n\t\trp += rd*d*.41;\n        #ifdef NOISE\n        rp += mod(vec3(f1,f2,f1*f2)*34783.8237324,vec3(NOISE_AMOUNT));\n    \t#endif\n    }\n    \n    fragColor = mix(vec4(pow(rd.x,2.)),c,c.w);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlBGzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[108, 108, 165, 165, 892]], "test": "valid"}
{"id": "Xlj3zc", "name": "Almost mandelbrot", "author": "m1el", "description": "I wanted to draw a Mandelbrot set with checkerboard on it, but due to an error got this.\nThe image is mirrored 4 times, just for aesthetic reasons. ", "tags": ["checkerboard", "complex"], "likes": 9, "viewed": 182, "published": "Public", "date": "1431016115", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-iResolution.xy/2.) / min(iResolution.x,iResolution.y) *2.;\n    uv /= exp(sin(iTime/5.)*4.+4.);\n\n    if (abs(uv.y) > abs(uv.x)) {\n        uv = vec2(uv.y, uv.x);\n    }\n    uv.x = abs(uv.x);\n    uv.x -= 1.;\n    for (int i = 0; i < 100; i++) {\n    uv = -uv+vec2(uv.x*uv.x-uv.y*uv.y,2.*uv.x*uv.y);\n        if (length(uv) > 2.) {\n            uv = vec2(10,0);\n        }\n    }\n    float f = step(0.,(mod(uv.x*20.,1.)-0.5)*(mod(uv.y*20.,1.)-0.5));\n    //float f = length(uv);\n\tfragColor = vec4(f,f,f,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xlj3zc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 581]], "test": "valid"}
{"id": "XljGR3", "name": "Alien Cavern", "author": "aiekick", "description": "Alien Cavern", "tags": ["alien", "cavern"], "likes": 36, "viewed": 4879, "published": "Public API", "date": "1430923697", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//#define USE_HOLE\n    \nfloat dstepf = 0.0;\n#define uScreenSize iResolution.xy\n#define uTime iTime\n\nconst vec2 RMPrec = vec2(0.6, 0.01); // ray marching tolerance precision // low, high\nconst vec2 DPrec = vec2(1e-3, 30.); // ray marching distance precision // low, high\n    \n// light\nconst vec3 LCol = vec3(0.8,0.5,0.2);\nconst vec3 LPos = vec3(-0.6, 0.7, -0.5);\nconst vec3 LAmb = vec3( 0. );\nconst vec3 LDif = vec3( 1. , 0.5, 0. );\nconst vec3 LSpe = vec3( 0.8 );\n\n// material\nconst vec3 MCol = vec3(0.);\nconst vec3 MAmb = vec3( 0. );\nconst vec3 MDif = vec3( 1. , 0.5, 0. );\nconst vec3 MSpe = vec3( 0.6, 0.6, 0.6 );\nconst float MShi =30.;\n    \n#define mPi 3.14159\n#define m2Pi 6.28318\n\nvec2 s,g,uv,m;\n\nvec2 uvs(vec3 p) // uv sphere\n{\n\tp = normalize(p);\n\tvec2 sp;\n\tsp.x = atan(p.z, p.x) / (m2Pi+1.27);\n\tsp.y = asin(p.y) / (mPi);\n\treturn sp;\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( .5+.5*(b-a)/k, 0., 1. );\n\treturn mix( b, a, h ) - k*h*(1.-h);\n}\n\nfloat sdCyl( vec3 p, vec2 h )\n{\n  \tvec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  \treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\nvec3 getHotColor(float Temp) // blackbody temperature color\n{\n\tvec3 col = vec3(255.);\n\tcol.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n\tif (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\nvec2 getTemp(vec3 p)\n{\n\tp*=2.;\n\tfloat r = fract(p.x+p.z);\n\treturn vec2(dot(p,p)*(1000.)*r,r);\n}\n\n//--------------------------------------------------------------------------\n// Grab all sky information for a given ray from camera\n// from Dave Hoskins // https://www.shadertoy.com/view/Xsf3zX\nvec3 GetSky(in vec3 rd, in vec3 sunDir, in vec3 sunCol)\n{\n\tfloat sunAmount = max( dot( rd, sunDir), 0.0 );\n\tfloat v = pow(1.0-max(rd.y,0.0),6.);\n\tvec3  sky = mix(vec3(.1, .2, .3), vec3(.32, .32, .32), v);\n\tsky = sky + sunCol * sunAmount * sunAmount * .25;\n\tsky = sky + sunCol * min(pow(sunAmount, 800.0)*1.5, .3);\n\treturn clamp(sky, 0.0, 1.0);\n}\n\nvec4 map(vec3 p)\n{\n\tvec2 res = vec2(0.);\n    \n\tfloat t = sin(uTime*0.2)*.5+.5;\n\tt*=2.;\n    \n\tfloat rugo=cos(2.*p.x)*sin(1.5*p.z)*sin(3.*p.y)*cos(1.3);\n    \n\tvec3 sci = vec3(0.9,2.,0.9);// scale in\n\tvec3 pob = vec3(0.,5.,0.);// pos bottom\n\tvec3 pocy = vec3(0.,-5.,0.);//pos cyl\n    \n\tvec3 col = getHotColor(getTemp(p).x);\n    \n\tfloat diamhole = 1.1;\n\tfloat spi = length(p*sci) - 4.5 - rugo;//in\n\tfloat spb = length(p+pob) - 4.5 + dot(col, vec3(0.01));//bottom\n\tfloat spo = spi - 1. ;//out\n\n    float disp = dot(col, vec3(0.03));\n    \n#ifdef USE_HOLE\n\tfloat cyl = sdCyl(p+pocy, vec2(diamhole,4.));//top hole\n\tfloat spicyl = smin(spi,cyl,0.6) + disp;\n\tfloat cavern = smin(max(-spicyl, spo ), spb, 3.5);\n#else\n    float cavern = smin(max(-spi, spo ), spb, 3.5);\n#endif\n        \n    dstepf += 0.01;\n    \n\treturn vec4(cavern, col);\n}\n\nvec3 nor(vec3 p, float prec)\n{\n\tvec2 e = vec2(prec, 0.);\n    \n\tvec3 n;\n    \n\tn.x = map(p+e.xyy).x - map(p-e.xyy).x; \n\tn.y = map(p+e.yxy).x - map(p-e.yxy).x; \n\tn.z = map(p+e.yyx).x - map(p-e.yyx).x;  \n    \n\treturn normalize(n); \n}\n\nvec3 ads( vec3 p, vec3 n )\n{\n\tvec3 ldif = normalize( LPos - p);\n\tvec3 vv = normalize( vec3(0.) - p );\n\tvec3 refl = reflect( vec3(0.) - ldif, n );\n    \n\tvec3 amb = MAmb*LAmb;\n\tvec3 dif = max(0., dot(ldif, n.xyz)) * MDif * LDif;\n\tvec3 spe = vec3( 0. );\n\tif( dot(ldif, vv) > 0.)\n\t\tspe = pow(max(0., dot(vv,refl)),MShi)*MSpe*LSpe;\n    \n\tvec3 col = amb*1.2 + dif*1.5 + spe*0.8;\n    \n\treturn col;\n}\n\nvec4 scn(vec4 col, vec3 ro, vec3 rd)\n{\n\tfloat s = DPrec.x;\n\tfloat d = 0.;\n\tvec3 p = ro+rd*d;\n\tvec4 c = col;\n    \n\tfloat b = 0.35;\n    \n\tfor(int i=0;i<200;i++)\n\t{\n\t\tif(s<DPrec.x||s>DPrec.y) break;\n\t\ts = map(p).x;\n\t\td += s*(s>DPrec.x?RMPrec.x:RMPrec.y);\n\t\tp = ro+rd*d;\n\t}\t\n    \n\tfloat lightIntensity = sin(uTime*0.2)*.5;\n\n\tif (s<DPrec.x)\n\t{\n\t\tvec2 r = getTemp(p);\n\t\n\t\tvec3 n = nor(p, r.y); \n      \t\n\t\tc.rgb = map(p).yzw + dot(n,rd) + ads(p,n) * lightIntensity;\n\t}\n\telse\n\t{\n\t\tvec3 dir = -normalize(vec3(2.,10.,0.));\n\t\tvec3 col = vec3(lightIntensity);\n\t\tc.rgb = GetSky(rd, dir, col);\n\t}\n    \n\treturn c;\n}\n\nvec3 cam(vec2 uv, vec3 ro, vec3 cu, vec3 org, float persp)\n{\n\tvec3 rorg = normalize(org-ro);\n\tvec3 u =  normalize(cross(cu, rorg));\n\tvec3 v =  normalize(cross(rorg, u));\n\tvec3 rd = normalize(rorg + u*uv.x + v*uv.y);\n\treturn rd;\n}\n\nvec4 Image(in vec2 fragCoord )\n{\n\ts = uScreenSize;\n\tg = fragCoord;\n\tuv = (2.*g-s)/s.y;\n\t\n\tfloat t = uTime*.2;\n\tfloat ts = sin(t)*.5+.5;\n    \n\tfloat axz = -t/2.; // angle XZ\n\tfloat axy = 2.6 + 0.42*ts; // angle XY // inf 3.02 // sup 2.60\n\tfloat cd = 3.;// cam dist to scene origine\n\n\t//axy = 2.6; // on bloque la camera an haut pour mise au point\n    \n\tfloat ap = 1.; // angle de perspective\n\tvec3 cu = vec3(0.,1.,0.); // cam up \n\tvec3 org = vec3(0., 0.8, 0.); // scn org\n\tvec3 ro = vec3(cos(axz),sin(axy),sin(axz))*cd; // cam org\n    \n\tvec3 rd = cam(uv, ro, cu, org, ap);\n    \n\tvec4 c = vec4(0.,0.,0.,1.); // col\n    \n\tc = scn(c, ro, rd);//scene\n\t\n    c += dstepf;\n    \n\treturn c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = Image(fragCoord);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XljGR3.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[602, 839, 870, 870, 978], [980, 980, 1021, 1021, 1103], [1105, 1105, 1136, 1136, 1237], [1239, 1460, 1521, 1521, 1840], [1842, 1842, 1864, 1864, 1937], [1939, 2134, 2191, 2191, 2479], [2481, 2481, 2499, 2499, 3308], [3310, 3310, 3340, 3340, 3539], [3541, 3541, 3569, 3569, 3933], [3935, 3935, 3973, 3973, 4535], [4537, 4537, 4597, 4597, 4766], [4768, 4768, 4800, 4800, 5450], [5452, 5452, 5509, 5509, 5545]], "test": "valid"}
{"id": "XlS3W3", "name": "20150528_pon de ring", "author": "FMS_Cat", "description": "This is pon de ring of Mister Donut", "tags": ["2d"], "likes": 0, "viewed": 178, "published": "Public", "date": "1432827207", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define WOW 0.0\n\n#define PI 3.14159265\n\nfloat hash( vec2 _v ){\n    return fract(sin(dot(_v,vec2(89.44,19.36)))*22189.22);\n}\n\nfloat iHash( vec2 _v, vec2 _r ){\n    float h00 = hash( vec2( floor( _v*_r + vec2( 0.0, 0.0 ) ) / _r ) );\n    float h10 = hash( vec2( floor( _v*_r + vec2( 1.0, 0.0 ) ) / _r ) );\n    float h01 = hash( vec2( floor( _v*_r + vec2( 0.0, 1.0 ) ) / _r ) );\n    float h11 = hash( vec2( floor( _v*_r + vec2( 1.0, 1.0 ) ) / _r ) );\n    vec2 ip = vec2( smoothstep( vec2( 0.0, 0.0 ), vec2( 1.0, 1.0 ), mod( _v*_r, 1.0 ) ) );\n    return ( h00 * ( 1.0 - ip.x ) + h10 * ip.x ) * ( 1.0 - ip.y ) + ( h01 * ( 1.0 - ip.x ) + h11 * ip.x ) * ip.y;\n}\n\nfloat noise( vec2 _v ){\n    float sum = 0.;\n    for( int i = 1; i < 9; i ++ )\n    {\n        sum += iHash( _v + vec2( i ), vec2( 2.0 * pow( 2.0, float( i ) ) ) ) / pow( 2.0, float( i ) );\n    }\n    return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 p = vec2( fragCoord.xy * 2.0 - iResolution.xy ) / iResolution.x;\n\n\tfloat sum = 0.0;\n\tvec3 nor = vec3( 0.0 );\n\tfor( float i = 0.0; i < PI * 1.9; i += PI * 0.25 ){\n\t\tvec2 gap = p - vec2( cos( i ), sin( i ) ) * 0.4 * ( 1.0 + WOW * sin( iTime * 4.0 ) * 0.5 );\n\t\tfloat strength = exp( -length( gap ) * 16.0 ) * 10.0;\n\t\tsum += strength;\n\t\tnor += vec3( gap, 0.1 ) * strength;\n\t}\n\t\n\tfloat meta = pow( clamp( sum, 0.0, 1.0 ), 100.0 );\n\tnor = normalize( nor );\n\tvec3 dif = ( clamp( dot( normalize( vec3( 1.0, 1.0, 1.0 ) ), nor ), 0.0, 1.0 ) + 0.1 ) * vec3( 0.9, 0.6, 0.3 );\n\tfloat sugar = clamp( abs( noise( p * 7.0 + 20.0 ) - 0.5 ) * 2.0, 0.0, 1.0 ) * 0.12 * sum;\n\tvec3 spe = pow( clamp( dot( normalize( vec3( 0.8, 0.9, 1.0 ) + vec3( 0.0, 0.0, 1.0 ) ), nor ) + sugar * 0.1, 0.0, 1.0 ), 30.0 ) * vec3( 0.2 );\n\t\n\tvec3 bg = ( vec3( 0.9, 0.0, 0.4 ) + clamp( sin( p.x * 50.0 + p.y * 40.0 + iTime * 8.0 ) * 10.5 - 4.0, 0.0, 1.0 ) * vec3( 0.0, 1.2, -0.3 ) * exp( -length( p*0.8 ) ) );\n\t\n\tfragColor = vec4( meta * ( dif + spe + sugar ) + ( 1.0 - meta ) * bg, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlS3W3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[86, 86, 108, 108, 169], [171, 171, 203, 203, 698], [700, 700, 723, 723, 910], [912, 912, 968, 968, 2025]], "test": "valid"}
{"id": "XlS3z3", "name": "alinearity of time", "author": "jameswilddev", "description": "aaarp.", "tags": ["bands"], "likes": 5, "viewed": 139, "published": "Public", "date": "1430695477", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float band = floor(fragCoord.y / 32.0) + iTime * 0.1;\n\tfragColor = vec4(mod(fragCoord.y - 8.0, 32.0) > 16.0 ? vec3(0.0) : mix(vec3(0.1, 1.0, 0.7), vec3(0.2, 0.3, 0.25), sin(band * 3.9 + fragCoord.x / (8.0 + sin(band * 4.0 + 3.1) * 18.0))),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlS3z3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 308]], "test": "valid"}
{"id": "XlSGDK", "name": "Ice Dreamer", "author": "vgs", "description": "Just a quick doodle! :)", "tags": ["ice", "dream", "cold"], "likes": 42, "viewed": 2007, "published": "Public", "date": "1432673954", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Vinicius Graciano Santos - vgs/2015\n// https://www.shadertoy.com/view/XlSGDK\n\n#define STEPS 100\n#define EPS 0.02\n#define FAR 100.0\n#define PI 3.14159265359\n\n// smin by iq\nfloat smin( float a, float b, float k )\n{\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat map(vec3 p) {\n    p = mod(p, 10.0) - 5.0;\n    return smin(length(p)-1.25, min(length(p.yz), \n                min(length(p.xz), length(p.xy))), 0.5)-1.0;\n}\n\nvec3 grad(vec3 p) {\n    vec2 q = vec2(0.0, EPS);\n    return vec3(map(p + q.yxx) - map(p - q.yxx),\n                map(p + q.xyx) - map(p - q.xyx),\n                map(p + q.xxy) - map(p - q.xxy));\n}\n\n// Cube and bump mapping by iq\nvec3 cubeMap(vec3 p, vec3 n) {\n    vec3 a = texture(iChannel0, 0.1*p.yz).rgb;\n    vec3 b = texture(iChannel0, 0.1*p.xz).rgb;\n    vec3 c = texture(iChannel0, 0.1*p.xy).rgb;\n    n = abs(n);\n    return (a*n.x + b*n.y + c*n.z)/(n.x+n.y+n.z);   \n}\n\nvec3 bumpMap(vec3 p, vec3 n, float c) {\n    vec2 q = vec2(0.0, 0.25);\n\tvec3 grad = -(vec3(cubeMap(p+q.yxx, n).r, cubeMap(p+q.xyx, n).r, cubeMap(p+q.xxy, n).r)-c)/q.y;\n    vec3 t = grad - n*dot(grad, n);\n    return normalize(n - t);\n}\n\nvec3 shade(vec3 ro, vec3 rd, float t) {\n    vec3 p = ro + t*rd;\n    vec3 n = normalize(grad(p));\n    vec3 tex = cubeMap(p, n);\n    n = bumpMap(p, n, tex.r);\n    \n    vec3 col = 3.0*vec3(0.3, 0.5, 0.7)*tex*(pow(1.0-dot(-rd, n), 4.0)*.6 + .4*dot(-rd, n));\n    float fog = 1.0 - exp(-0.01*t);\n    return mix(col, vec3(1.0), fog);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n\tvec2 uv = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    vec2 vi = fragCoord.xy/iResolution.xy;\n    \n    vec3 ro = vec3(0.0, 0.0, 2.5+iTime);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    \n    float t = 0.0, d = 0.0;\n    for (int i = 0; i < STEPS; ++i) {\n        d = .55*map(ro + t*rd);\n        if (d < EPS || t > FAR) break;\n        t += d;\n        rd.xy = cos(0.05*d)*rd.xy + sin(0.05*d)*vec2(-rd.y, rd.x);\n    }\n\t\n    vec3 col = d < EPS ? shade(ro, rd, t) : vec3(1.0);\n\tcol += 1.0-vec3(1.0)*pow(vi.x*vi.y*(1.0-vi.x)*(1.0-vi.y), 0.03);\n    \n    col = max(col-0.26, 0.0);\n\tcol = (col*(6.2*col+.5))/(col*(6.2*col+1.7)+0.06);\n    \n    col = pow(col, vec3(1.0/2.2));    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlSGDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[171, 185, 226, 226, 316], [318, 318, 337, 337, 478], [480, 480, 499, 499, 678], [680, 711, 741, 741, 953], [955, 955, 994, 994, 1188], [1190, 1190, 1229, 1229, 1518], [1520, 1520, 1577, 1577, 2292]], "test": "error"}
{"id": "XlSGRt", "name": "2D Softshadows", "author": "Diede", "description": "simple 2D shape rendering with softshadows", "tags": ["2d"], "likes": 6, "viewed": 275, "published": "Public", "date": "1431179674", "time_retrieved": "2021-10-01T00:00:00", "image_code": "///////////////////////////////////////////////////////////\n// COPYRIGHT 2015 BY DIEDE APERS\n// Realtime 2D volumetric light\n// NOT optimized algorithm: Foreach pixel, Foreach light\n// Foreach sample, Foreach object.\n// Only sphere drawing and intersection\n//\n// TODO:\n// Revamp intersection, no need to calculate exact point\n// Add more lights\n// Add more primitives (triangle, line, polygon)\n// Animation\n// Optimize\n///////////////////////////////////////////////////////////\n\nstruct Ray\n{\n    vec2 origin;\n    vec2 end;\n};\n    \nstruct Circle\n{\n    vec2 position;\n    float radius;\n    vec3 color;\n};\n\nbool drawLine(vec2 position, Ray line, int thickness)\n{\n\treturn false;\n}\n    \nfloat intersectCircle(Ray ray, Circle circle)\n{\n    float dist = distance(ray.origin, ray.end);\n    \n    vec2 d = ray.origin - ray.end;\n    \n    float a = dot(d, d);\n    float b = 2.0 * dot(d, ray.origin - circle.position);\n    float c = dot(circle.position, circle.position) + dot(ray.origin, ray.origin) - 2.0 * dot(circle.position, ray.origin) - circle.radius*circle.radius;\n\n    float test = b*b - 4.0*a*c;\n\n    if (test >= 0.0) \n    {\n        dist = (-b - sqrt(test)) / (2.0 * a);\n    }\n    \n    return dist;\n}\n\nbool intersectCircleShadow(Ray ray, Circle circle)\n{\n    bool inShadow = false;\n    \n    float intersection = intersectCircle(ray, circle);\n    if(!(intersection > 0.0 || intersection < -1.0))\n    {\n        inShadow = true;\n    }\n    \n    return inShadow;\n}\n\nfloat drawCircle(vec2 position, Circle circle)\n{\n    float xd = circle.position.x-position.x;\n\tfloat yd = circle.position.y-position.y;\n\n    if((xd*xd + yd*yd) <= circle.radius * circle.radius)\n    {\n        return 1.0;\n    }\n    \n    return 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 rgb = vec3(0.1, 0.1, 0.1);\n\tvec2 origin = fragCoord.xy;\n    \n    float lightIntensity = 1.0;\n    vec3 lightColor = vec3(0.0, 0.9, 0.6);\n    \n    Circle circle1, circle2, circle3;\n    circle1.position = vec2(iResolution.x/4.0, iResolution.y/2.0);\n    circle1.radius = 50.0;\n    circle1.color = vec3(0.2, 0.2, 0.2);\n    \n    circle2.position = vec2(circle1.position.x / 2.0 + ((sin(iTime) +1.0) * 1.5) * circle1.position.x, circle1.position.y / 2.0 + ((sin(iTime * 2.0) * 0.5) + 0.5) * circle1.position.y);\n    //circle2.position = vec2(iMouse.x, iMouse.y);\n    circle2.radius = 10.0;\n    circle2.color = vec3(1.0, 1.0, 1.0);\n    \n    circle3.position = vec2(iResolution.x - iResolution.x/4.0, iResolution.y/2.0);\n    circle3.radius = 50.0;\n    circle3.color = vec3(0.2, 0.2, 0.2);\n    \n    rgb += drawCircle(origin, circle1) * circle1.color; // First object\n    rgb += drawCircle(origin, circle2) * circle2.color; // First light\n    rgb += drawCircle(origin, circle3) * circle3.color; // Second light\n    \n    const float samples = 20.0; // TODO: include in circle\n    Ray ray;\n    ray.origin = origin;\n    ray.end = circle2.position;\n    \n    // Light \n    for(float i = 1.0; i <= samples; ++i)\n    {\n        bool inShadow = false;\n        \n        // Resample\n        // Perendicular to the surface of the light\n        vec2 vec = normalize(ray.end - ray.origin);\n        vec2 sampleVec = vec2(vec.y, -vec.x);\n        vec2 resample = sampleVec * (i - samples/2.0);\n        ray.end = circle2.position + resample;\n        \n        // FOR EACH OBJECT\n        {\n            inShadow = intersectCircleShadow(ray, circle1) || intersectCircleShadow(ray, circle3);\n        }\n        \n        if(!inShadow)\n        {\n            float dist = distance(ray.origin, ray.end);\n            rgb += lightColor / dist * lightIntensity;\n        }\n    }\n    \n\tfragColor = vec4(rgb, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlSGRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 605, 660, 660, 677], [683, 683, 730, 730, 1198], [1200, 1200, 1252, 1252, 1457], [1459, 1459, 1507, 1507, 1707], [1709, 1709, 1766, 1766, 3647]], "test": "valid"}
{"id": "XlSGzt", "name": "Basic Reflection Test", "author": "resonance", "description": "Just testing some basic stuff.", "tags": ["3d", "raymarching", "reflection", "csg"], "likes": 0, "viewed": 130, "published": "Public", "date": "1431205706", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Victor Franco (resonance) */\n\n#define FAR 50.0\n#define EPS 0.001\n#define STEPS 256\n\n#define PI    3.14159265359\n#define TWOPI 6.28318530718\n\nstruct Inter {\n\tint id;\n\tfloat dist;\n};\n\nInter iCilindroZ(int id, vec3 p, float s) {\n \treturn Inter (id, length(p.xy) - s);   \n}\n\nInter iSphere(int id, vec3 p, float s) {\n \treturn Inter (id, length(p) - s);\n}\n\nInter iCube(int id, vec3 p, float s) {\n \treturn Inter(id, length(max(abs(p) - s, 0.0)));   \n}\n\nInter opU(in Inter a, in Inter b) {\n \treturn a.dist > b.dist ? b : a;   \n}\n\nInter opS(in Inter a, in Inter b) {\n\tb.dist = -b.dist;\n    return a.dist > b.dist ? a : b;\n}\n\nInter map(vec3 p) {\n    vec3 pCubos  = p;\n    vec3 pCubos2 = p;\n    \n    float t  = iTime * 0.075 + 0.5 * TWOPI * pCubos.z/FAR;    \n    float t2 = iTime * 0.075 + 0.5 * TWOPI * pCubos.x/FAR;\n    \n    pCubos.xy += 18.0 * vec2(cos(t), sin(t));    \n    pCubos.xy = mod(pCubos.xy, 10.0) - 5.0;\n    pCubos.z  = mod(pCubos.z,  1.25) - 0.625;\n    \n    pCubos2.xy += 18.0 * vec2(cos(t), sin(t));    \n    pCubos2.zy = mod(pCubos2.zy, 10.0) - 5.0;\n    pCubos2.x  = mod(pCubos2.x,  1.25) - 0.625;\n    \n    vec3 pEsfera = p;\n    pEsfera.z += -5.2;\n    \n \treturn opU(\n        iSphere(1, pEsfera, 1.0),\n        opS(opU(iCube(2, pCubos,  1.0),\n                iCube(2, pCubos2, 1.0)),\n        \tiSphere(3, pEsfera, 1.8)\n        \t));\n}\n\nvec3 colorize(Inter inter) {\n    if (inter.id == 1) return vec3(0.3, 0.4, 0.6);\n    if (inter.id == 2) return vec3(0.4);\n    if (inter.id == 3) return vec3(0.0);\n    return vec3(1.0);\n}\n\nvec3 normals(vec3 p) {\n \tvec2 e = vec2(0.01, 0.0);\n    return normalize(vec3(\n        map(p + e.xyy).dist - map(p - e.xyy).dist,\n        map(p + e.yxy).dist - map(p - e.yxy).dist,\n        map(p + e.yyx).dist - map(p - e.yyx).dist));\n}\n\nbool raymarch(out Inter inter, in vec3 ro, in vec3 rd) \n{\n    Inter deltaInter;  // InterseÃ§Ã£o temporÃ¡ria do ponto de\n                       // marching atÃ© o objeto\n    \n    float dist;        // DistÃ¢ncia real do 'ro' atÃ© o objeto\n    \n    // Intersecta\n    for (int i = 0; i < STEPS; i++) {\n        deltaInter = map(ro + dist * rd);\n\n        // Caso passemos da distÃ¢ncia mÃ¡xima, para o loop\n        if (dist > FAR)\n            break;\n        \n        // Caso ocorra colisÃ£o, move as informaÃ§Ãµes da interseÃ§Ã£o\n        // temporÃ¡ria para a interseÃ§Ã£o final e retorna verdadeiro\n        if (deltaInter.dist < EPS)\n        {\n            inter.id   = deltaInter.id;\n            inter.dist = dist;\n            return true;\n        }\n        \n        dist += deltaInter.dist;\n    }\n    \n    // Retorna que nÃ£o foi possÃ­vel encontrar uma interseÃ§Ã£o\n\treturn false;\n}\n\nvec3 renderPixel(in vec2 coord)\n{\n    // PosiÃ§Ã£o da colisÃ£o e cor da colisÃ£o\n\tInter inter;\n    vec3 col = vec3(0.0);\n    \n    // Coordenadas do plano\n    vec2 uv = 1.0 - 2.0 * (coord.xy / iResolution.xy);\n         uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 rd = normalize(vec3(uv, 1.0));\n    vec3 ro = vec3(0.0);\n    \n    // Se acontecer raymarching\n    float realDist;\n    \n    for (int i = 0; i < 3; i++) {\n        // Realiza o raymarching\n        if (!raymarch(inter, ro, rd))\n        \tbreak;\n       \n        if (i == 0)\n            realDist = inter.dist;\n        \n        // PosisÃ£o de colisÃ£o e normal\n        vec3 pos = ro + rd * (inter.dist - EPS);\n        vec3 normal = normals(pos);\n        \n        // Pinta\n        if (i == 0)\n            col = colorize(inter);\n        else\n        \tcol += 0.2 * colorize(inter);\n        \n        //if (inter.id == 1)\n        //    break;\n        \n        // Muda o referencial para o ponto de colisao\n\n        ro = pos;\n        rd = reflect(rd, normal);\n    }\n    \n    col = mix(col, vec3(1.0), realDist/FAR);\n    return realDist == 0.0 ? vec3(1.0) : col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 e = vec2(0.5, 0.0);\n    \n    // 2x multisampling;\n  \tvec3 col = renderPixel(fragCoord + e.xx)\n             + renderPixel(fragCoord + e.xy);\n    \n\tfragColor = vec4(col/2.0, 1.0);\n}\n    \n    ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlSGzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 185, 228, 228, 272], [274, 274, 314, 314, 352], [354, 354, 392, 392, 447], [449, 449, 484, 484, 523], [525, 525, 560, 560, 617], [619, 619, 638, 638, 1337], [1339, 1339, 1367, 1367, 1524], [1526, 1526, 1548, 1548, 1760], [1762, 1762, 1819, 1819, 2683], [2685, 2685, 2718, 2773, 3814], [3816, 3816, 3871, 3871, 4060]], "test": "valid"}
{"id": "XsBXDy", "name": "BRDF Lab Pathtraced", "author": "Orihaus", "description": ":3", "tags": ["brdf"], "likes": 2, "viewed": 156, "published": "Public", "date": "1430462039", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define saturate(i) ( clamp( i, 0.0, 1.0 ) )\n\nconst float pi = 3.14159265;\nconst float tau = pi * 2.0;\nconst float halfpi = pi * 0.5;\nconst float oneoverpi  = 1.0 / pi;\nconst float oneovertau = 1.0 / tau;\n\nconst float ZMAX = 99999.0;\nconst float EPSILON = 0.001;\n\nstruct Intersection\n{\n\tvec3 position;\n\tfloat distance;\n\tvec3 normal;\n    bool hit;\n    vec3 color;\n    float emission;\n    float roughness;\n    vec2 uv;\n};\n\t\nstruct Light\n{\n    vec4 lightOrientation;\n    vec3 planarDirection;\n    vec3 planarRight;\n    vec3 planarUp;\n    vec3 lightExtents;\n    vec3 lightPosition;\n};\n    \nstruct Ray\n{\n\tvec3 origin;\n\tvec3 direction;\n};\n\t\nstruct Plane\n{\n    vec2 extent;\n\tvec3 center;\n    \n    vec4 orient;\n    \n    vec3 color;\n    float emission;\n    float roughness;\n};\n     \nstruct Sphere\n{\n\tvec3 c;\n\tfloat r;\n    float emission;\n    vec3 color;\n    float roughness;\n};\n    \n//\n    \nIntersection MinIntersection( Intersection a, Intersection b )\n{\n\tif( a.distance < b.distance )\n\t\treturn a;\n\telse\n\t\treturn b;\n}\n\nIntersection RaySphere(Ray ray, Sphere sphere)\n{\n\tIntersection i;\n\ti.distance = ZMAX;\n\tvec3 c = sphere.c;\n\tfloat r = sphere.r;\n\tvec3 e = c-ray.origin;\n\tfloat a = dot(e, ray.direction);\n\tfloat b = r*r - dot(e,e) + a*a;\n\tif( b>0.0 )\n\t{\n\t\tfloat f = sqrt(b);\n\t\tfloat t = a - f;\n\t\tif(t > EPSILON)\n\t\t{\n\t\t\ti.position = ray.origin + ray.direction*t;\n\t\t\ti.normal = normalize(i.position-c);\n\t\t\ti.distance = t;\n            i.roughness = sphere.roughness;\n            i.emission = sphere.emission;\n            i.color = sphere.color;\n            i.hit = true;\n            i.uv = i.normal.xy;\n\t\t}\n\t}\n\treturn i;\n}\n\n//\n\nstruct Spatial\n{\n\tvec4 pos, rot;\n};\n\n// Construct Quaternion from Euler Angles\nvec4 constructQuaternion( vec3 angles )\n{\t\n    vec3 halfAngles = 0.5 * angles;\n    \n    float cos_z_2 = cos( halfAngles.z );\n    float cos_y_2 = cos( halfAngles.y );\n    float cos_x_2 = cos( halfAngles.x );\n\n    float sin_z_2 = sin( halfAngles.z );\n    float sin_y_2 = sin( halfAngles.y );\n    float sin_x_2 = sin( halfAngles.x );\n\n    // and now compute quaternion\n    vec4 quat;\n    quat.w = cos_z_2*cos_y_2*cos_x_2 + sin_z_2*sin_y_2*sin_x_2;\n    quat.x = cos_z_2*cos_y_2*sin_x_2 - sin_z_2*sin_y_2*cos_x_2;\n    quat.y = cos_z_2*sin_y_2*cos_x_2 + sin_z_2*cos_y_2*sin_x_2;\n    quat.z = sin_z_2*cos_y_2*cos_x_2 - cos_z_2*sin_y_2*sin_x_2;\n    return quat;\n}\n\nvec3 quaternionMultiply( vec4 quat, vec3 vector )\n{\n\tvec3 uv, uuv;\n    vec3 qvec = quat.xyz;\n    \n    uv = cross( qvec, vector );\n    uuv = cross( qvec, uv );\n    \n\tuv  *= ( 2.0 * quat.w );\n\tuuv *= 2.0;\n\n\treturn normalize( vector + uv + uuv );\n}\n\nvec3 rotateVector( vec4 quat, vec3 vec )\n{\n\treturn vec + 2.0 * cross( cross( vec, quat.xyz ) + quat.w * vec, quat.xyz );\n}\n\nconst vec3 left = vec3( 1, 0, 0 );\nconst vec3 up = vec3( 0, 1, 0 );\nconst vec3 forward = vec3( 0, 0, 1 );\nconst vec4 quaternionIdentity = vec4( 0, 0, 0, 1 );\n\nvec3 linePlaneIntersect(in vec3 rayOrigin, in vec3 rayDirection, in vec3 planeCenter, in vec3 planeNormal )\n{\n\tfloat distanceToPlane = dot( planeNormal, planeCenter - rayOrigin ) / dot( planeNormal, rayDirection );\n\treturn rayOrigin + rayDirection * distanceToPlane;\n}\n\nIntersection RayPlane( Ray ray, Plane p )\n{\n\tIntersection i;\n    i.hit = false;\n\ti.distance = ZMAX;\n   \n    vec3 axisX = quaternionMultiply( p.orient, left );\n    vec3 axisY = quaternionMultiply( p.orient, forward );\n    vec3 axisZ = quaternionMultiply( p.orient, up );\n    \n\t// Intersect ray with plane\n    float distanceToPlane = dot( axisZ, p.center - ray.origin ) / dot( axisZ, ray.direction );\n    \n    if( distanceToPlane > EPSILON )\n    {\n        vec3 pointOnPlane = ray.origin + ray.direction * distanceToPlane;\n        vec3 toCenter = pointOnPlane - p.center;\n\n        float x_dot_c = dot( axisX, toCenter );\n        float y_dot_c = dot( axisY, toCenter );\n        float inExtentX = abs( x_dot_c );\n        float inExtentY = abs( y_dot_c );\n\n        vec2 extents = vec2( p.extent.x, p.extent.y );\n        if( inExtentY < extents.y && inExtentX < extents.x )\n        {\n            i.position = pointOnPlane;\n            i.normal = axisZ;//dot( axisZ, ray.direction ) < 0.0 ? axisZ : -axisZ;\n            i.distance = distanceToPlane;\n            i.hit = true;\n\n            vec2 scaledPosition = vec2( 0.5 + x_dot_c * 0.5, 0.5 + y_dot_c * 0.5 ) / extents;\n            i.uv = scaledPosition.xy;\t\n\n            i.emission  = p.emission;\n            i.roughness = p.roughness;\n            i.color = p.color;\n        }\n    }\n    \n\treturn i;\n}\n\nint sideOfPlane(in vec3 p, in vec3 pc, in vec3 pn)\n{\n   if (dot(p-pc,pn)>=0.0) return 1; else return 0;\n}\n\nvec3 projectOnPlane( vec3 point, vec3 planeCenter, vec3 planeNorm ) \n{\n    return point - dot( point - planeCenter, planeNorm ) * planeNorm;\n}\n\nvec3 closestPointOnRect( vec3 rect, vec3 extents, vec3 position, vec3 axisX, vec3 axisY, vec3 axisZ )\n{\n\tvec3 proj = projectOnPlane( position, rect, axisZ );\n\tvec3 dir = proj - rect;\n\n\tvec2 diagonal = vec2( dot( dir, axisX ), dot( dir, axisY ) );\n\tvec2 nearest2D = vec2( clamp( diagonal.x, -extents.x, extents.x ), clamp( diagonal.y, -extents.y, extents.y ) );\n    \n\tvec3 nearestPointInside = rect + ( axisX * nearest2D.x + axisY * nearest2D.y );\n\treturn nearestPointInside;\n}\n\n//\n\nPlane pone;\nPlane ptwo;\nPlane pthree;\nPlane pfour;\nPlane pfive;\nPlane psix;\nSphere sphere;\nSphere spheretwo;\n\n//\n\nIntersection projectRay( Ray ray )\n{\n    Intersection intersection;\n    \n\tintersection = RayPlane( ray, pone );\n\tintersection = MinIntersection( RayPlane( ray, ptwo ), intersection );\n\t//intersection = MinIntersection( RayPlane( ray, pthree ), intersection );\n\tintersection = MinIntersection( RayPlane( ray, pfour ), intersection );\n\tintersection = MinIntersection( RayPlane( ray, pfive ), intersection );\n\tintersection = MinIntersection( RayPlane( ray, psix ), intersection );\n    intersection = MinIntersection( RaySphere( ray, sphere ), intersection );\n    intersection = MinIntersection( RaySphere( ray, spheretwo ), intersection );\n    \n    return intersection;\n}\n\n//\n\nvec2 Hash22(in vec2 p)\n{\n\treturn fract(vec2(sin(p.x * 591.32 + p.y * 154.077), cos(p.x * 391.32 + p.y * 49.077)));\n}\n\n\n// code from : http://www.rorydriscoll.com/2009/01/07/better-sampling/\n\nvec3 cosineWeightedDirection( vec2 uv, vec3 normal, float roughness ) \n{\n    float u = uv.x; float v = uv.y;\n    float r = sqrt(u);\n    float angle = 6.283185307179586 * v;\n    // compute basis from normal\n    vec3 sdir, tdir;\n    if (abs(normal.x)<.5) \n    {\n        sdir = cross(normal, vec3(1,0,0));\n    } \n    else \n    {\n        sdir = cross(normal, vec3(0,1,0));\n    }\n    tdir = cross(normal, sdir);\n    \n    return ( r*cos(angle)*sdir + r*sin(angle)*tdir + sqrt(1.-u)*normal ) * roughness;\n}\n\nvec3 TangentToWorld( vec3 Vec, vec3 TangentZ )\n{\n\tvec3 UpVector = abs( TangentZ.z ) < 0.999 ? vec3( 0.0, 0.0, 1.0 ) : vec3( 1.0, 0.0, 0.0 );\n\tvec3 TangentX = normalize( cross( UpVector, TangentZ ) );\n\tvec3 TangentY = cross( TangentZ, TangentX );\n\treturn TangentX * Vec.x + TangentY * Vec.y + TangentZ * Vec.z;\n}\n\nvec3 ImportanceSampleGGX( vec2 E, float Roughness )\n{\n\tfloat m = Roughness * Roughness;\n\tfloat m2 = m * m;\n\n\tfloat Phi = 2.0 * pi * E.x;\n\tfloat CosTheta = sqrt( (1.0 - E.y) / ( 1.0 + (m2 - 1.0) * E.y ) );\n\tfloat SinTheta = sqrt( 1.0 - CosTheta * CosTheta );\n\n\tvec3 H;\n\tH.x = SinTheta * cos( Phi );\n\tH.y = SinTheta * sin( Phi );\n\tH.z = CosTheta;\n\t\n\t//float d = ( CosTheta * m2 - CosTheta ) * CosTheta + 1.0;\n\t//float D = m2 / ( pi*d*d );\n\t//float PDF = D * CosTheta;\n\n\treturn H;\n}\n\nvec3 UniformSampleCone( vec2 E, float CosThetaMax )\n{\n\tfloat Phi = 2.0 * pi * E.x;\n\tfloat CosTheta = mix( CosThetaMax, 1.0, E.y );\n\tfloat SinTheta = sqrt( 1.0 - CosTheta * CosTheta );\n\n\tvec3 L;\n\tL.x = SinTheta * cos( Phi );\n\tL.y = SinTheta * sin( Phi );\n\tL.z = CosTheta;\n\n\t//float PDF = 1.0 / ( 2 * PI * (1 - CosThetaMax) );\n\n\treturn L;\n}\n\nvec3 UniformSampleHemisphere( vec2 E )\n{\n\tfloat Phi = 2.0 * pi * E.x;\n\tfloat CosTheta = E.y;\n\tfloat SinTheta = sqrt( 1.0 - CosTheta * CosTheta );\n\n\tvec3 H;\n\tH.x = SinTheta * cos( Phi );\n\tH.y = SinTheta * sin( Phi );\n\tH.z = CosTheta;\n\n\t//float PDF = 1.0 / (2 * PI);\n\n\treturn H;\n}\n\nvec3 getWeightedDirection( float seed, vec3 normal, vec3 incident, float roughness, vec3 view, vec2 ouv )\n{\n    vec2 uv = Hash22( vec2( iTime, seed ) * ouv.xy );\n    return cosineWeightedDirection( uv, normal, seed > 0.8 ? roughness : 1.0 );\n    \n    //if( seed < 0.0 )\n    \t//return TangentToWorld( UniformSampleHemisphere( uv, roughness ), incident );\n    //else\n    //    return TangentToWorld( UniformSampleCone( uv, 0.9 ), incident );\n    //return UniformSampleHemisphere( uv );\n}\n\n//\n\nfloat distributionBeckmann( float roughness, float n_dot_h )\n{\n\tfloat m = roughness * roughness;\n\tfloat m2 = m * m;\n\tfloat NoH2 = n_dot_h * n_dot_h;\n\treturn exp( (NoH2 - 1.0) / (m2 * NoH2) ) / ( pi * m2 * NoH2 * NoH2 );\n}\n\nfloat distributionGGX( float roughness, float n_dot_h )\n{\n\tfloat m = roughness * roughness;\n\tfloat m2 = m * m;\n\tfloat d = ( n_dot_h * m2 - n_dot_h ) * n_dot_h + 1.0;\n\treturn m2 / ( pi*d*d );\n}\n\n// From : https://www.unrealengine.com/blog/physically-based-shading-on-mobile\n\nfloat EnvBRDFApproxNonmetal( float Roughness, float NoV )\n{\n    const vec2 c0 = vec2( -1.0, -0.0275 );\n    const vec2 c1 = vec2(  1.0,  0.0425 );\n    vec2 r = Roughness * c0 + c1;\n    return min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n}\n\n//\n\nfloat Square( float s )\n{\n    return s*s;\n}\n\nfloat F_Fresnel( float SpecularColor, float VoH )\n{\n\tfloat SpecularColorSqrt = sqrt( clamp( 0.0, 0.99, SpecularColor ) );\n\tfloat n = ( 1.0 + SpecularColorSqrt ) / ( 1.0 - SpecularColorSqrt );\n\tfloat g = sqrt( n*n + VoH*VoH - 1.0 );\n\treturn 0.5 * Square( (g - VoH) / (g + VoH) ) * ( 1.0 + Square( ((g+VoH)*VoH - 1.0) / ((g-VoH)*VoH + 1.0) ) );\n}\n\nfloat F_Schlick( in float f90, in float u )\n{\n    float f = pow( 1.0 - u, 5.0 );\n\treturn f + ( 1.0 - f ) * f90;\n}\n\nfloat disneyDiffuse( float NdotV, float NdotL, float LdotH, float linearRoughness )\n{\n\tfloat energyBias = mix( 0.0, 0.5, linearRoughness );\n   \tfloat energyFactor = mix( 1.0, 1.0 / 1.51, linearRoughness );\n    \n\tfloat fd90 = energyBias + 2.0 * LdotH * LdotH * linearRoughness;\n\n\tfloat lightScatter = F_Schlick( fd90, NdotL );\n\tfloat viewScatter  = F_Schlick( fd90, NdotV );\n\treturn lightScatter * viewScatter * energyFactor;\n}\n\nfloat V_SmithGGXCorrelatedOriginal( float NdotL, float NdotV, float alphaG )\n{\n\t// This is the optimize version\n\tfloat alphaG2 = alphaG * alphaG;\n    float NdotL2 = NdotL * NdotL;\n    float NdotV2 = NdotV * NdotV;\n    \n\tfloat lambda_v = (-1.0 + sqrt( alphaG2 * ( 1.0 - NdotL2 ) / NdotL2 + 1.0 ) ) * 0.5;\n\tfloat lambda_l = (-1.0 + sqrt( alphaG2 * ( 1.0 - NdotV2 ) / NdotV2 + 1.0 ) ) * 0.5;\n\tfloat G_SmithGGXCorrelated = 1.0 / ( 1.0 + lambda_v + lambda_l );\n\tfloat V_SmithGGXCorrelated = G_SmithGGXCorrelated / ( 4.0 * NdotL * NdotV );\n    return V_SmithGGXCorrelated;\n}\n\nfloat V_SmithGGXCorrelated( float NdotL, float NdotV, float alphaG )\n{\n\t// This is the optimize version\n\tfloat alphaG2 = alphaG * alphaG;\n\t// Caution : the \" NdotL *\" and \" NdotV *\" are explicitely inversed , this is not a mistake .\n\tfloat Lambda_GGXV = NdotL * sqrt((-NdotV * alphaG2 + NdotV ) * NdotV + alphaG2 );\n\tfloat Lambda_GGXL = NdotV * sqrt((-NdotL * alphaG2 + NdotL ) * NdotL + alphaG2 );\n\n\treturn 0.5 / ( Lambda_GGXV + Lambda_GGXL );\n}\n\nconst float PI = 3.14159265359;\nconst float oneoverPI = 1.0 / PI;\nfloat D_Beckmann( float NoH, float m )\n{\n\tfloat m2 = m * m;\n\tfloat NoH2 = NoH * NoH;\n\treturn exp( (NoH2 - 1.0) / (m2 * NoH2) ) / ( PI * m2 * NoH2 * NoH2 );\n}\n\nfloat D_GGX( float NdotH, float m )\n{\n\tfloat m2 = m * m;\n\tfloat f = ( NdotH * m2 - NdotH ) * NdotH + 1.0;\n\treturn m2 / (f * f);\n}\n\nfloat cot ( float x) { return cos (x) / sin (x); }\nfloat acot ( float x) { return atan (1.0 / x); }\n\nfloat illuminanceSphereOrDisk( float cosTheta , float sinSigmaSqr )\n{\n\tfloat sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\n\n\tfloat illuminance = 0.0;\n\tif ( cosTheta * cosTheta > sinSigmaSqr )\n\t{\n\t\tilluminance = PI * sinSigmaSqr * saturate( cosTheta );\n\t}\n\telse\n\t{\n        float x = sqrt( 1.0 / sinSigmaSqr - 1.0 ); // For a disk this simplify to x = d / r\n        float y = -x * ( cosTheta / sinTheta );\n        float sinThetaSqrtY = sinTheta * sqrt( 1.0 - y * y );\n        illuminance = ( cosTheta * acos( y ) - x * sinThetaSqrtY ) \n            * sinSigmaSqr + atan( sinThetaSqrtY / x );\n\t}\n\treturn max( illuminance , 0.0 );\n}\n\nfloat getSphereIlluminance( vec3 lightDirection, vec3 worldNormal, \n                            float lightRadius, float sqrDist )\n{\n\t/*float Beta = acos( dot( worldNormal, lightDirection ) );\n\tfloat H = sqrt( sqrDist );\n\tfloat h = H / lightRadius;\n\tfloat x = sqrt( h * h - 1.0 );\n\tfloat y = -x * ( 1.0 / tan( Beta ) );\n\n\tfloat illuminance = 0.0;\n\tif( h * cos ( Beta ) > 1.0 )\n\t\tilluminance = cos ( Beta ) / ( h * h );\n\telse\n    {\n\t\tilluminance = ( 1.0 / ( PI * h * h ) ) *\n\t\t\t( cos( Beta ) * acos ( y ) - x * sin( Beta ) * sqrt( 1.0 - y * y ) ) +\n\t\t\t( 1.0 / PI ) * atan( sin ( Beta ) * sqrt( 1.0 - y * y ) / x );\n\t}\n\n\tilluminance *= PI;*/\n    \n\tfloat cosTheta = clamp( dot( worldNormal , lightDirection ), -0.999, 0.999 );\n\tfloat sqrLightRadius = lightRadius * lightRadius;\n\tfloat sinSigmaSqr = min( sqrLightRadius / sqrDist, 0.9999 );\n    float illuminance = illuminanceSphereOrDisk( cosTheta, sinSigmaSqr );\n    return illuminance;\n}\n\nfloat smoothDistanceAtt( float squaredDistance , float invSqrAttRadius )\n{\n\tfloat factor = squaredDistance * invSqrAttRadius;\n\tfloat smoothFactor = saturate( 1.0 - factor * factor );\n\treturn smoothFactor * smoothFactor;\n}\n\nfloat getDistanceAtt( vec3 unormalizedLightVector, float invSqrAttRadius )\n{\n\tfloat sqrDist = dot ( unormalizedLightVector, unormalizedLightVector );\n\tfloat attenuation = 1.0 / ( max( sqrDist, 0.01 * 0.01 ) );\n    attenuation *= smoothDistanceAtt( sqrDist, invSqrAttRadius );\n    return attenuation;\n}\n\nvec3 DoLight( vec3 origin, vec3 lightPosition, vec3 normal, vec3 viewDirection )\n{\n    float lightRadius = 0.125;\n    \n    vec3 lightVector = ( lightPosition - origin );\n    \n    //\n    \n    vec3 R = reflect( -viewDirection, normal );\n    vec3 ClosestPointOnRay = dot( lightVector, R ) * R;\n    vec3 CenterToRay = ClosestPointOnRay - lightVector;\n    vec3 ClosestPointOnSphere = lightVector + CenterToRay \n       * saturate( lightRadius * inversesqrt( dot( CenterToRay, CenterToRay ) ) );\n    lightVector = ClosestPointOnSphere;\n    \n    //\n    \n\tvec3 light = normalize( lightVector );\n    \n    vec3 halfVector = normalize( viewDirection + light );\n    float n_dot_v = abs( dot( viewDirection, normal ) + 1e-5 );\n    float n_dot_l = saturate( dot( light, normal ) );\n    float l_dot_h = saturate( dot( light, halfVector ) );\n    float n_dot_h = saturate( dot( normal, halfVector ) );\n    \n    float roughness = 0.4;//saturate( sin( iTime ) );\n    float roughnessSquared = roughness * roughness;\n    \n    float fresnel = F_Schlick( 0.04, n_dot_v );\n    float visibility = V_SmithGGXCorrelated( n_dot_l, n_dot_v, roughnessSquared );\n    float distribution = D_GGX( n_dot_h, roughnessSquared );\n    float specular = distribution * fresnel * saturate( visibility * oneoverPI );\n    \n    float attenuation = getDistanceAtt( lightVector, 0.00007 );\n    float diffuse = oneoverPI;// * disneyDiffuse( n_dot_v, n_dot_l, l_dot_h, roughness );\n    \n    float illuminance = getSphereIlluminance( light, normal, \n                                              lightRadius, dot( lightVector, lightVector ) );\n    \n    //\n    \n    Ray shadowray;\n    shadowray.origin = origin;\n    shadowray.direction = light;\n    Intersection shadowintersect = projectRay( shadowray );\n    float shadow = shadowintersect.distance < length( lightVector ) ? 0.0 : 1.0; \n    \n    float final = illuminance * ( diffuse + specular );\n    return vec3( final );\n}\n\nvec3 getBRDF( Light light, Intersection intersect, vec3 incidentReflection, vec3 viewDirection, vec3 enviroment )\n{\n    return DoLight( intersect.position, light.lightPosition, intersect.normal, viewDirection );\n}\n\n// filmic without sRGB conversion\n\n// shoulder strength\nconst float A = 0.22;\n// linear strength\nconst float B = 0.3;\n// linear angle\nconst float C = 0.1;\n// toe strength\nconst float D = 0.20;\n// toe numerator\nconst float E = 0.01;\n// toe denominator\nconst float F = 0.30;\n// linear white point\nconst float W = 11.2;\nfloat filmic_curve(float x) {\n\treturn ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n}\nfloat inverse_filmic_curve(float x) {\n    float q = B*(F*(C-x) - E);\n    float d = A*(F*(x - 1.0) + E);\n    return (q -sqrt(q*q - 4.0*D*F*F*x*d)) / (2.0*d);\n}\nvec3 filmic(vec3 x) {\n    float w = filmic_curve(W);\n    return vec3(\n        filmic_curve(x.r),\n        filmic_curve(x.g),\n        filmic_curve(x.b)) / w;\n}\nvec3 inverse_filmic(vec3 x) {\n    x *= filmic_curve(W);\n    return vec3(\n        inverse_filmic_curve(x.r),\n        inverse_filmic_curve(x.g),\n        inverse_filmic_curve(x.b));\n}\n\n//---------------------------------------------------------------------------------\n\nfloat linear_srgb(float x) {\n    return mix(1.055*pow(x, 1./2.4) - 0.055, 12.92*x, step(x,0.0031308));\n}\nvec3 linear_srgb(vec3 x) {\n    return mix(1.055*pow(x, vec3(1./2.4)) - 0.055, 12.92*x, step(x,vec3(0.0031308)));\n}\n\nfloat srgb_linear(float x) {\n    return mix(pow((x + 0.055)/1.055,2.4), x / 12.92, step(x,0.04045));\n}\nvec3 srgb_linear(vec3 x) {\n    return mix(pow((x + 0.055)/1.055,vec3(2.4)), x / 12.92, step(x,vec3(0.04045)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.y / iResolution.x;\n    float sintime = sin( iTime );\n    \n    pone.orient = quaternionIdentity;\n    pone.extent = vec2( 3, 1 );\n    pone.center = vec3( 0,-1, 0 );\n    pone.color = vec3( 1.0, 1.0, 1.0 );\n    pone.emission = 0.75;\n    pone.roughness = 0.9;\n\n    ptwo.orient = constructQuaternion( ( vec3( -1.0, 0.0, 0.0 ) ) * halfpi );\n    ptwo.extent = vec2( 3.0, 1.0 );\n    ptwo.center = vec3( 0, 0, 1 );\n    ptwo.color = vec3( 0.25, 0.75, 0.25 );\n    ptwo.emission = 0.875;\n    ptwo.roughness = 0.1;\n\n    pthree.orient = constructQuaternion( ( vec3( 1.0, 0.0, 1.0 ) ) * halfpi );\n    pthree.extent = vec2( 0.125, 1.0 );\n    pthree.center = vec3( 0.0, sintime, 0.9975 );\n    //pthree.emission = 0.975;\n    pthree.color = vec3( 1.0, 1.0, 1.0 );\n    pthree.roughness = 0.1;\n\n    pfour.orient = constructQuaternion( ( vec3( 0.0, 0.0, -1.0 ) ) * halfpi );\n    pfour.extent = vec2( 1.0, 3.0 );\n    pfour.center = vec3( -1.0, 0.0, 0.0 );\n    pfour.emission = 0.0;\n    pfour.color = vec3( 1.0, 1.0, 1.0 );\n    pfour.roughness = 0.9;\n\n    pfive.orient = constructQuaternion( ( vec3( 1.0, 1.0, -1.0 ) ) * halfpi );\n    pfive.extent = vec2( 1.0, 3.0 );\n    pfive.center = vec3( 0.0, 1.0, 0.0 );\n    //pfive.emission = 0.875;\n    pfive.color = vec3( 1.0, 1.0, 1.0 );\n    pfive.roughness = 0.9;\n\n    psix.orient = constructQuaternion( ( vec3( 1.0, 0.0, 1.0 ) ) * halfpi );\n    psix.extent = vec2( 1.0, 3.0 );\n    psix.center = vec3( 0.0, 0.0, -1.0 );\n    //psix.emission = 0.0;\n    psix.color = vec3( 0.75, 0.25, 0.25 );\n    psix.roughness = 0.1;\n\n    sphere.r = 0.5;\n    sphere.c = vec3( 0.0, 0.0, 0.0 );\n    sphere.roughness = 0.25;\n    sphere.color = vec3( 1.0 );\n\n    spheretwo.r = 0.125;\n    spheretwo.c = vec3( cos( iTime ) * 0.7, 0.5 * sintime, sintime * 0.7 );\n    spheretwo.emission = 4.75;\n    spheretwo.roughness = 0.25;\n    spheretwo.color = vec3( 1.0 );\n    //\n    \n\tfloat finalval = 0.0;\n    vec3 finalColor = vec3( finalval );\n    \n    vec2 mouse = 1.125 - ( iMouse.xy / iResolution.xy ) * 5.0;\n    \n\tvec2 pos = -1.0 + 2.0 * ( fragCoord.xy / iResolution.xy );\n\tpos.y *= aspect;\n    \n  \tvec3 view = vec3( pos.x, pos.y, 1.0 );\n    vec4 viewOrientation = constructQuaternion( vec3( 0.0, -( mouse.x ), 0.0 ) * halfpi );\n    \n    vec3 viewVector = quaternionMultiply( viewOrientation, view );\n\tvec3 rayDir = normalize( viewVector );\n    \n\tRay ray;\n\tray.origin = vec3( 3.0, 0.0, 0.0 );\n\tray.direction = rayDir;\n    \n    //\n    \n    vec3 enviroment = vec3( 0.0 );\n    float occlusion = 1.0;\n    \n    Intersection intersect, aaintersect;\n    vec3 viewDirection    = -rayDir;\n    \n    //\n    \n    Light light;\n    //light.lightOrientation = constructQuaternion( vec3( sin( time ), 0.0, 1.0 ) * halfpi );\n    //light.planarDirection  = quaternionMultiply( light.lightOrientation, up );\n    //light.planarRight      = quaternionMultiply( light.lightOrientation, -left );\n    //light.planarUp         = normalize( cross( light.planarRight, light.planarDirection ) );\n    light.lightExtents     = vec3( 0.125, 0.5, 1.0 );\n    light.lightPosition    = spheretwo.c;\n    \n    const int aasamples = 2;\n    const float faaSamples = float( aasamples * aasamples * 2 * 2 );\n    const float aaraycountoverone = 1.0 / float( faaSamples );\n    \n    bool everhit = false; float hitcount = 0.0;\n   \tvec3 aaoffset = vec3( fwidth( pos ) * 0.5, 1.0 );\n    for( int x = -aasamples; x < aasamples; x++ )\n    {\n    \tfor( int y = -aasamples; y < aasamples; y++ )\n        {\n            ray.direction = normalize( viewVector + vec3( x, y, 0.0 ) * aaoffset );\n            \n            aaintersect = projectRay( ray );\n            \n            vec3 incident = normalize( intersect.position - ray.origin );\n        \tvec3 incidentReflection = reflect( incident, intersect.normal );\n            \n            vec3 colorin = getBRDF( light, aaintersect, incidentReflection, \n                                   viewDirection, enviroment );\n            colorin *= 2.0;  // Hardcoded Exposure Adjustment\n\n\t\t\tfloat ExposureBias = 2.0;\n            vec3 curr = filmic( ExposureBias * colorin );\n\n            vec3 whiteScale = 1.0 / filmic( vec3( W ) );\n            vec3 color = curr * whiteScale;\n\n        \tfinalColor += aaraycountoverone * color;\n        }\n    }\n\n    //\n\n    finalColor = linear_srgb( finalColor );\n\tfragColor = vec4( finalColor, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsBXDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[874, 882, 946, 946, 1009], [1011, 1011, 1059, 1059, 1610], [1653, 1695, 1736, 1736, 2350], [2352, 2352, 2403, 2403, 2597], [2599, 2599, 2641, 2641, 2721], [2882, 2882, 2991, 2991, 3150], [3152, 3152, 3195, 3195, 4495], [4497, 4497, 4549, 4549, 4602], [4604, 4604, 4674, 4674, 4746], [4748, 4748, 4851, 4851, 5224], [5340, 5344, 5380, 5380, 6012], [6014, 6018, 6042, 6042, 6134], [6137, 6209, 6281, 6281, 6708], [6710, 6710, 6758, 6758, 7021], [7023, 7023, 7076, 7076, 7502], [7504, 7504, 7557, 7557, 7842], [7844, 7844, 7884, 7884, 8122], [8124, 8124, 8231, 8231, 8609], [8611, 8615, 8677, 8677, 8836], [8838, 8838, 8895, 8895, 9030], [9032, 9112, 9171, 9171, 9355], [9357, 9361, 9386, 9386, 9404], [9406, 9406, 9457, 9457, 9750], [9752, 9752, 9797, 9797, 9865], [9867, 9867, 9952, 9952, 10293], [10295, 10295, 10373, 10406, 10863], [10865, 10865, 10935, 10968, 11311], [11379, 11379, 11419, 11419, 11536], [11538, 11538, 11575, 11575, 11667], [11669, 11669, 11691, 11691, 11719], [11720, 11720, 11743, 11743, 11768], [11770, 11770, 11839, 11839, 12397], [12399, 12399, 12531, 13038, 13335], [13337, 13337, 13411, 13411, 13558], [13560, 13560, 13636, 13636, 13861], [13863, 13863, 13945, 13945, 15787], [15789, 15789, 15904, 15904, 16002], [16277, 16321, 16350, 16350, 16401], [16402, 16402, 16439, 16439, 16560], [16561, 16561, 16582, 16582, 16718], [16719, 16719, 16748, 16748, 16899], [16901, 16986, 17014, 17014, 17090], [17091, 17091, 17117, 17117, 17205], [17207, 17207, 17235, 17235, 17309], [17310, 17310, 17336, 17336, 17422], [17424, 17424, 17481, 17481, 21825]], "test": "valid"}
{"id": "Xt23z3", "name": "Ring Twister", "author": "Flyguy", "description": " Classic twister effect applied to a ring.", "tags": ["distort", "shading", "ring", "twist"], "likes": 171, "viewed": 8258, "published": "Public API", "date": "1430963214", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define ANTI_ALIAS\n\n#define NUM_FACES 4\n#define IN_RADIUS 0.25\n#define OUT_RADIUS 0.70\n#define SCROLL_SPEED -0.9\n\n#define COLOR_1 0.50, 0.90, 0.95\n#define COLOR_2 0.95, 0.60, 0.10\n\nfloat tau = atan(1.0) * 8.0;\nfloat pi = atan(1.0) * 4.0;\nfloat aaSize = 0.0;\n\nvec4 slice(float x0, float x1, vec2 uv)\n{\n    float u = (uv.x - x0)/(x1 - x0);\n    float w = (x1 - x0);\n    vec3 col = vec3(0);\n    \n    //Gradient\n    col = mix(vec3(COLOR_1), vec3(COLOR_2), u);\n    \n    //Lighting \n    col *= w / sqrt(2.0 * IN_RADIUS*IN_RADIUS * (1.0 - cos(tau / float(NUM_FACES))));\n    \n    //Edges\n    col *= smoothstep(0.05, 0.10, u) * smoothstep(0.95, 0.90, u) + 0.5;\n    \n    //Checker board\n    uv.y += iTime * SCROLL_SPEED; //Scrolling\n    \n    #ifdef ANTI_ALIAS\n    \tcol *= (-1.0 + 2.0 * smoothstep(-0.03, 0.03, sin(u*pi*4.0) * cos(uv.y*16.0))) * (1.0/16.0) + 0.7;\n    #else\n    \tcol *= sign(sin(u * pi * 4.0) * cos(uv.y * 16.0)) * (1.0/16.0) + 0.7;\n    #endif\n    \n    float clip = 0.0;\n    \n    #ifdef ANTI_ALIAS\n    \tclip = (1.0-smoothstep(0.5 - aaSize/w, 0.5 + aaSize/w, abs(u - 0.5))) * step(x0, x1);\n    #else\n    \tclip = float((u >= 0.0 && u <= 1.0) && (x0 < x1));\n    #endif\n    \n    return vec4(col, clip);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    aaSize = 2.0 / iResolution.y; //Scale anti aliasing with resolution\n    vec2 res = iResolution.xy / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    uv -= res / 2.0;\n    uv *= 2.0;\n    \n    //Polar coordinates\n    vec2 uvr = vec2(length(uv), atan(uv.y, uv.x) + pi);\n    uvr.x -= OUT_RADIUS;\n    \n    vec3 col = vec3(0.05);\n    \n    //Twisting angle\n    float angle = uvr.y + 2.0*iTime + sin(uvr.y) * sin(iTime) * pi;\n    \n    for(int i = 0;i < NUM_FACES;i++)\n    {\n        float x0 = IN_RADIUS * sin(angle + tau * (float(i) / float(NUM_FACES)));\n        float x1 = IN_RADIUS * sin(angle + tau * (float(i + 1) / float(NUM_FACES)));\n        \n        vec4 face = slice(x0, x1, uvr);\n        \n        col = mix(col, face.rgb, face.a); \n    }\n    \n    //col = (abs(uv.x) > 1.0) ? vec3(1) : col;\n    \n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt23z3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[260, 260, 301, 301, 1205], [1207, 1207, 1264, 1264, 2105]], "test": "valid"}
{"id": "Xt23zt", "name": "Endless Dancing I's", "author": "BrwnRyce", "description": "Raymarching UIUC", "tags": ["raymarching"], "likes": 0, "viewed": 128, "published": "Public", "date": "1431464898", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 dSphere(vec3 p){\n  \tfloat d = length(p)-4.2;\n  \treturn vec2(d,1);\n}\n\nvec2 dFloor(vec3 p){\n  return vec2(p.y+0.2,0);\n}\n\nvec2 oSub(vec2 a, vec2 b){\n  \tfloat d = max(a.x, -b.x);\n  \treturn vec2(d,1);\n}\n\nvec2 oAdd(vec2 a, vec2 b){\n  \tfloat d = min(a.x, b.x);\n    float c;\n    if(d==a.x)\n        c = a.y;\n    else\n        c = b.y;\n  \treturn vec2(d,c);\n}\n\nfloat udRoundBox(vec3 p, vec3 b, float r){\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nvec2 infiniteIs(vec3 p, vec3 c){\n    vec3 q;\n\tq.x = mod(p.x,c.x)-0.5*c.x;\n    q.y = p.y;\n    //q.y = mod(p.y,c.y)-0.5*c.y;\n    \n    q.z = mod(p.z,c.z)-0.5*c.z;\n\treturn oAdd(oAdd(oAdd(vec2(udRoundBox(q,vec3(0.2,0.1,0.5),0.1),1.0),\n                vec2(udRoundBox(q+vec3(0.0,-1.4+0.18*cos(iTime*6.0)*(1.0-0.1*sin(p.z*5.5)),0.0),vec3(0.2,0.1,0.5),0.1),1.0)),\n                vec2(udRoundBox(q+vec3(0.0,-0.7,0.0),vec3(0.2,0.69+-0.09*cos(iTime*6.0),0.1),0.1),1.0)),\n                dFloor(p));\n               \t\n}\n\nvec2 dist(vec3 p){\n  \treturn infiniteIs(p,vec3(4.0,4.0,4.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 q = fragCoord.xy/iResolution.xy;\n    vec2 vPos = -1.0+2.0*q;\n\n\n  \n    vec3 camPos = vec3(1.0*mod(iTime*10.0,600.0),\n                       3.7+3.0*sin(iTime*0.8),\n                       0.0);\n  \n  \tvec3 camLook = vec3(camPos.x+30.0,\n\t\t\t\t\t\t1.7,\n                        camPos.z+0.0);\n    \n    vec3 camUp = vec3(0.0,\n                      1.0+0.0*cos(iTime),\n                      0.0*sin(iTime)); \n\n    vec3 vpn = normalize(camLook-camPos);\n  \tvec3 u = normalize(cross(camUp,vpn));\n  \tvec3 v = cross(vpn,u);\n\tvec3 vcv = camPos+vpn;\n  \tvec3 scrCoord = vcv+vPos.x*u*iResolution.x/iResolution.y+vPos.y*v;\n  \tvec3 scp = normalize(scrCoord-camPos);\n\n  \tconst vec3 e = vec3(0.01,0,0);\n  \tconst float maxDepth = 256.0;\n  \tvec2 d = vec2(0.002,0.0);\n  \tvec3 p;\n\n  \tfloat f = 1.0;\n  \tfor(int i=0; i<64; i++){\n    \tif ((abs(d.x) < .001) || (f > maxDepth)) \n      \t\tbreak;\n    \n    \tf += d.x;\n    \tp = camPos+scp*f;\n    \td = dist(p);\n  \t}\n  \n  \tif (f < maxDepth){\n        vec3 color;\n        if(d.y==1.0){\n    \t\tcolor = vec3(0.863, //Orange\n                         0.447,\n                         0.118);\n        }else{\n            color = vec3(0.454,\t//Blue\n                         0.522,\n                         0.745);\n        }\n   \n  \t\tvec3 n = vec3(d.x-dist(p-e.xyy).x,\n\t\t\t\t\t  d.x-dist(p-e.yxy).x,\n                  \t  d.x-dist(p-e.yyx).x);\n        \n    \tvec3 N = normalize(n);\n    \tfragColor=vec4(color*dot(N,normalize(camPos-p))-f/128.0,1.0);\n    }else\n    \tfragColor=vec4(0.0,0.0,0.0,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt23zt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 72], [74, 74, 94, 94, 122], [124, 124, 150, 150, 202], [204, 204, 230, 230, 352], [354, 354, 396, 396, 436], [438, 438, 470, 470, 945], [947, 947, 965, 965, 1010], [1012, 1012, 1066, 1066, 2570]], "test": "valid"}
{"id": "Xt2GDG", "name": "Doorways", "author": "luutifa", "description": "I wanted to add bumps and textures, maybe reflections and refine the distfield a bit, but really had to finish this for school.", "tags": ["raymarch", "lighting"], "likes": 9, "viewed": 249, "published": "Public", "date": "1432019308", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\n    precision highp float;\n#endif\n\n#define PI 3.14159265\n#define EPSILON 0.001\n#define ITERATIONS 30\n#define MAX_MARCH_LEN 30.0\n#define NUM_POINTLIGHTS 3\nvec3 cam = vec3(0.0, 1.7+sin(iTime)*0.1, sin(iTime*0.6)*0.2);\nvec3 normal;\nvec4 light_p_coord[NUM_POINTLIGHTS]; //W is bool visibility\nvec3 light_p_color[NUM_POINTLIGHTS];\n\nmat3 getXRotMat(float a) {\n    return mat3(\n         1.0,  0.0,     0.0,\n         0.0,  cos(a), -sin(a),\n         0.0,  sin(a),  cos(a)\n    );\n}\n\nmat3 getYRotMat(float a) {\n    return mat3(\n         cos(a),  0.0,  sin(a),\n         0.0,     1.0,  0.0,\n        -sin(a),  0.0,  cos(a)\n    );\n}\n\nmat3 getZRotMat(float a) {\n    return mat3(\n         cos(a), -sin(a),  0.0,\n         sin(a),  cos(a),  0.0,\n         0.0,     0.0,     1.0\n    );\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat box(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat plane(vec3 pos) {\n    return pos.y;\n}\n\nfloat sphere(vec3 pos, float r) {\n    return length(pos)-r;\n}\n\n/*-------------------------------------------------------------------*/\n\nfloat wallWithDoor(vec3 pos) {\n    float doorW = 1.2;\n    float doorH = 2.0;\n    \n    float wall = box(pos, vec3(20.0, 10.0, 0.2));\n    //pos.x = mod(pos.x, 10.0)-5.0;\n    float door = min(\n            box(pos, vec3(doorW, doorH*2.0, 40.0)),\n            sphere(pos-vec3(0.0, doorH*2.0, 0.0), doorW)\n    );\n    float door2 = min(\n            box(pos-vec3(6.0, 0.0, 0.0), vec3(doorW, doorH*2.0, 40.0)),\n            sphere(pos-vec3(6.0, doorH*2.0, 0.0), doorW)\n    );\n    \n    return max(\n        wall,\n        -min(\n            door,\n            door2\n        )\n    );\n}\n\nfloat scene(vec3 pos) {\n    return smin(\n        plane(pos),\n        min(\n            wallWithDoor(pos-vec3(-0.2, 0.0, 6.0)),\n            wallWithDoor(getYRotMat(PI/2.0)*(pos-vec3(3.0, 0.0, 9.0)))\n        ),\n        0.1\n    );\n}\n\n/*---------------------------------------------------------------------------*/\n\nvec3 getGradient(vec3 p) {\n    vec2 e = vec2(EPSILON, 0.0);\n    return (vec3(scene(p+e.xyy), scene(p+e.yxy), scene(p+e.yyx)) - scene(p)) / e.x;\n}\n\nvec3 march(vec3 origin, vec3 direction) {\n    float t=EPSILON;\n    float dist;\n    for (int i=0; i<ITERATIONS; i++) {\n        dist = scene(origin+direction*t);\n        t += dist;\n        if (dist<EPSILON)\n            break;\n        if (t>MAX_MARCH_LEN)\n            break;\n    }\n    return origin + direction*t;\n}\n\nfloat softShadow(vec3 origin, vec3 direction, float mint, float maxt, float k) {\n    float l = 1.0;\n    float t = mint;\n    float dist;\n    for(int i=0;i<ITERATIONS;i++)\n    {\n        dist = scene(origin + direction*t);\n        if(dist<EPSILON)\n            return 0.0; //If hits a surface, fragment is completely shadowed\n        t += dist;\n        l = min(l, k*dist/t);\n        if(t > maxt)\n            break;\n    }\n    return l;\n}\n\nvec3 pointLight(vec3 pos, vec3 lpos, vec3 lcol) {\n    float diff = max(dot(normalize(pos-lpos), -normal), 0.0);\n    float dist = 1.0/(length(pos-lpos));\n    float shadow = softShadow(pos, normalize(lpos-pos), 0.1, length(lpos-pos), 30.0);\n    return dist * diff * lcol * shadow;\n}\n\nvec3 lighting(vec3 pos) {\n    vec3 l = vec3(0.0);\n    for (int i=0; i<NUM_POINTLIGHTS; i++) {\n        vec3 lcoord = light_p_coord[i].xyz;\n        l += pointLight(pos, lcoord, light_p_color[i]);\n        \n        if (light_p_coord[i].w > 0.5) {\n            if (length(pos-cam) > length(lcoord-cam))\n                l += pow(max(dot(normalize(cam-lcoord), -normalize(pos-cam)), 0.0), 2000.0)*light_p_color[i];\n        }\n    }\n    return l;\n    \n}\n\nvec3 getPicture(vec2 screenPos) {\n    vec3 pos = march(cam, getZRotMat(sin(iTime*0.2)*0.04)*getYRotMat(-0.2)*normalize(vec3(screenPos, 1.0)));\n    normal = normalize(getGradient(pos));\n    return lighting(pos);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    light_p_coord[0] = vec4(sin(iTime*0.331)*0.5-2.0, 2.0, 9.0+cos(iTime*0.42), 0.0);\n    light_p_color[0] = vec3(1.0, 0.6, 0.1)*2.8;\n    \n    //This light for fake GI :D\n    light_p_coord[1] = vec4(0.2, sin(iTime*0.64)*0.4+3.0, 3.0, 0.0);\n    light_p_color[1] = normalize(vec3(1.0, 0.7, 0.3))*0.8;\n    \n    light_p_coord[2] = vec4(3.0+sin(iTime*0.4)*3.0, 1.5+sin(iTime*0.6654)*0.3, 6.0+cos(iTime*0.4)*3.0, 1.0);\n    light_p_color[2] = vec3(0.2, 0.9, 0.4)*(sin(iTime*3.0)*0.2+0.8)*(sin(iTime*5.0)*0.3+0.6)*(cos(iTime*0.6)*0.2+1.0);\n\n    fragColor = vec4(getPicture((2.0*fragCoord.xy - iResolution.xy)/iResolution.y)*1.3, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt2GDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[279, 340, 366, 366, 484], [486, 486, 512, 512, 630], [632, 632, 658, 658, 779], [781, 781, 822, 822, 915], [917, 917, 944, 944, 1035], [1037, 1037, 1060, 1060, 1080], [1082, 1082, 1115, 1115, 1143], [1145, 1218, 1248, 1248, 1786], [1788, 1788, 1811, 1811, 2016], [2018, 2099, 2125, 2125, 2244], [2246, 2246, 2287, 2287, 2558], [2560, 2560, 2640, 2640, 2992], [2994, 2994, 3043, 3043, 3274], [3276, 3276, 3301, 3301, 3719], [3721, 3721, 3754, 3754, 3933], [3935, 3935, 3990, 3990, 4619]], "test": "valid"}
{"id": "Xt2GRc", "name": "coming up on DALT-HCI", "author": "netgrind", "description": "I am comming up on dalt hydrochloride", "tags": ["blackandwhite", "psychedelic", "dalt", "comeup"], "likes": 10, "viewed": 1689, "published": "Public API", "date": "1430977021", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define loop 5.0\n\nfloat func(vec3 p, float t){\n    float f = 0.0;\n    float a  = atan(p.y,p.x)*2.;\n    float d = length(p);\n    \n    p.xy *= mat2(cos(a+t*.1)*d,sin(a)*d,-sin(a)*d,cos(a+t*.1)*d);\n    \n    f+=length(sin(p));\n    f*= sin(p.z+t+cos(length(p.xy)+t));\n    f = abs(f);\n    f = pow(f,p.z);\n    f = sin(f*d+t);\n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 m = iMouse.xy/iResolution.xy;\n    float t = iTime;\n    \n    fragCoord.xy -= iResolution.xy*.5;    \n\tvec2 uv = fragCoord.xy / iResolution.xx*20.;\n    \n    vec4 c = vec4(1.0);\n    float f = 0.0;\n    float d = length(uv);\n    float a = atan(uv.y,uv.x);\n    \n    for(float i = 0.0; i<loop; i++){\n    \tf += func(vec3(uv.x,uv.y,i*0.7),t); \n    }\n    c.rgb = vec3(f/loop);\n    c.a =1.0;\n\tfragColor = c;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt2GRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 18, 46, 46, 334], [336, 336, 393, 393, 800]], "test": "valid"}
{"id": "XtB3Wc", "name": "glowing 2D Metaballs", "author": "the23", "description": "same colored metaballs, using the \"expensive\" metaballs function.", "tags": ["2d", "metaballs", "glow"], "likes": 5, "viewed": 366, "published": "Public", "date": "1432899084", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float speed = 10.0;\n\nconst float radius = 2.7;\nconst float thresholdFactor = 0.008;\nconst int ballCount = 6;\n\nconst vec3 backgroundColor = vec3(0.0);\nconst vec3 metaballColor = vec3(1.0, 0.3, 0.02);\n\nfloat dstMetaball(vec2 pos, vec2 center, float radius)\n{\n  vec2 diff = pos - center;\n  return radius / dot(diff, diff);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{ \n  // create centered local positions\n  float aspect = iResolution.x / iResolution.y;\n  vec2 tex = fragCoord.xy / iResolution.xy;\n  tex.x *= aspect;\n  tex -= clamp(vec2(aspect, 1.0 / aspect) - 1.0, 0.0, 1.0)  * 0.5;\n    \n  vec3 color = backgroundColor;\n\n    \n  float dst = 0.0;\n  // add the first ball in the middle\n  dst += dstMetaball(tex, vec2(0.5, 0.5), radius);\n\n  // init the vars for the other balls\n  vec2 ballPos = vec2(0.25, 0.0);\n  float angle = radians(60.0 + iTime * speed);\n  mat2 matRotate = mat2(cos(angle), -sin(angle),\n                        sin(angle),  cos(angle));\n\n  // iterate over the balls, sum up the distance, rotate the ball position\n  for (int i=0; i < ballCount; ++i)\n  {\n    dst += dstMetaball(tex, ballPos + 0.5/*center*/, radius);\n    ballPos = matRotate * ballPos;\n  }\n    \n  // normalize the distance\n  dst /= float(ballCount) + 1.0;\n  \n  // blend between colors\n  color = mix(backgroundColor, metaballColor, dst * thresholdFactor);\n\n  fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtB3Wc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[206, 206, 262, 262, 327], [329, 329, 385, 423, 1389]], "test": "valid"}
{"id": "XtBGDG", "name": "Simplex3D noise + fbm", "author": "Lallis", "description": "Testing some simplex noise. Not the most elegant code, but it works. :)\nUse mouse to slide between simplex and fbm.", "tags": ["noise", "fbm", "simplex"], "likes": 44, "viewed": 2160, "published": "Public", "date": "1431657504", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//http://webstaff.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf\n//simplex pretty much 99% copied from there\n//adjusted by getting \"completely random\" gradients instead of randoming from 12 preset ones\n//and normalizing the gradient vector\n\n#define time iTime*0.5\n\nfloat noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,128.852))) * 43758.5453)*2.0-1.0;\n}\n\nfloat simplex3D(vec3 p)\n{\n\t\n\tfloat f3 = 1.0/3.0;\n\tfloat s = (p.x+p.y+p.z)*f3;\n\tint i = int(floor(p.x+s));\n\tint j = int(floor(p.y+s));\n\tint k = int(floor(p.z+s));\n\t\n\tfloat g3 = 1.0/6.0;\n\tfloat t = float((i+j+k))*g3;\n\tfloat x0 = float(i)-t;\n\tfloat y0 = float(j)-t;\n\tfloat z0 = float(k)-t;\n\tx0 = p.x-x0;\n\ty0 = p.y-y0;\n\tz0 = p.z-z0;\n\t\n\tint i1,j1,k1;\n\tint i2,j2,k2;\n\t\n\tif(x0>=y0)\n\t{\n\t\tif(y0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } // X Y Z order\n\t\telse if(x0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } // X Z Y order\n\t\telse { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }  // Z X Z order\n\t}\n\telse \n\t{ \n\t\tif(y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } // Z Y X order\n\t\telse if(x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } // Y Z X order\n\t\telse { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } // Y X Z order\n\t}\n\t\n\tfloat x1 = x0 - float(i1) + g3; \n\tfloat y1 = y0 - float(j1) + g3;\n\tfloat z1 = z0 - float(k1) + g3;\n\tfloat x2 = x0 - float(i2) + 2.0*g3; \n\tfloat y2 = y0 - float(j2) + 2.0*g3;\n\tfloat z2 = z0 - float(k2) + 2.0*g3;\n\tfloat x3 = x0 - 1.0 + 3.0*g3; \n\tfloat y3 = y0 - 1.0 + 3.0*g3;\n\tfloat z3 = z0 - 1.0 + 3.0*g3;\t\n\t\t\t\t \n\tvec3 ijk0 = vec3(i,j,k);\n\tvec3 ijk1 = vec3(i+i1,j+j1,k+k1);\t\n\tvec3 ijk2 = vec3(i+i2,j+j2,k+k2);\n\tvec3 ijk3 = vec3(i+1,j+1,k+1);\t\n            \n\tvec3 gr0 = normalize(vec3(noise3D(ijk0),noise3D(ijk0*2.01),noise3D(ijk0*2.02)));\n\tvec3 gr1 = normalize(vec3(noise3D(ijk1),noise3D(ijk1*2.01),noise3D(ijk1*2.02)));\n\tvec3 gr2 = normalize(vec3(noise3D(ijk2),noise3D(ijk2*2.01),noise3D(ijk2*2.02)));\n\tvec3 gr3 = normalize(vec3(noise3D(ijk3),noise3D(ijk3*2.01),noise3D(ijk3*2.02)));\n\t\n\tfloat n0 = 0.0;\n\tfloat n1 = 0.0;\n\tfloat n2 = 0.0;\n\tfloat n3 = 0.0;\n\n\tfloat t0 = 0.5 - x0*x0 - y0*y0 - z0*z0;\n\tif(t0>=0.0)\n\t{\n\t\tt0*=t0;\n\t\tn0 = t0 * t0 * dot(gr0, vec3(x0, y0, z0));\n\t}\n\tfloat t1 = 0.5 - x1*x1 - y1*y1 - z1*z1;\n\tif(t1>=0.0)\n\t{\n\t\tt1*=t1;\n\t\tn1 = t1 * t1 * dot(gr1, vec3(x1, y1, z1));\n\t}\n\tfloat t2 = 0.5 - x2*x2 - y2*y2 - z2*z2;\n\tif(t2>=0.0)\n\t{\n\t\tt2 *= t2;\n\t\tn2 = t2 * t2 * dot(gr2, vec3(x2, y2, z2));\n\t}\n\tfloat t3 = 0.5 - x3*x3 - y3*y3 - z3*z3;\n\tif(t3>=0.0)\n\t{\n\t\tt3 *= t3;\n\t\tn3 = t3 * t3 * dot(gr3, vec3(x3, y3, z3));\n\t}\n\treturn 96.0*(n0+n1+n2+n3);\n\t\n}\n\nfloat fbm(vec3 p)\n{\n\tfloat f;\n    f  = 0.50000*simplex3D( p ); p = p*2.01;\n    f += 0.25000*simplex3D( p ); p = p*2.02; //from iq\n    f += 0.12500*simplex3D( p ); p = p*2.03;\n    f += 0.06250*simplex3D( p ); p = p*2.04;\n    f += 0.03125*simplex3D( p );\n\treturn f;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy/iResolution.xy*2.0-1.0;\n\tuv.x*=(iResolution.x/iResolution.y);\n    float mx = iMouse.x>0.0?iMouse.x/iResolution.x:0.5;\n    float my = iMouse.y>0.0?iMouse.y/iResolution.y:0.5;\n\tuv*=my*10.0;\n\tvec3 col = vec3(0.0);\n    float n;\n\tif(uv.x>(mx*2.0-1.0)*(my)*10.0*(iResolution.x/iResolution.y))\n\t{\n\t\tn = fbm(vec3(time,vec2(uv)))*0.5+0.5;\n\n\t}\n\telse\n\t{\n\t\tn = simplex3D(vec3(time,vec2(uv)))*0.5+0.5;\n\n\t}\t   \n    col = vec3(n*0.1,n*0.7,n*0.8);\n\tcol = mix(col, vec3(0.5,0.5,0.4), 0.5*sin(time)-0.5);\n    //col = vec3(n);\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtBGDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 266, 289, 289, 370], [372, 372, 397, 397, 2522], [2524, 2524, 2543, 2543, 2789], [2791, 2791, 2846, 2846, 3408]], "test": "valid"}
{"id": "XtBGDK", "name": "Crisp transitioning lines", "author": "sophje", "description": "SIMPLE! Vertical lines with festive colors.", "tags": ["vertical"], "likes": 0, "viewed": 121, "published": "Public", "date": "1432261798", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 position = (fragCoord.xy/iResolution.xy);\n\n    float cX = position.x - 2.5;\n    float cY = position.y - 1.5;\n\n    float newX = log(sqrt(cX*cX + cY*cY));\n    float newY = atan(cX, cY);\n     \n\tfloat PI = 39.14159;\n\tfloat numHorBands = 100.9;\n\tfloat numVertBands = 10.8;\n\tfloat numDiagBands = 1.0;\n    float numArms = 6.5;\n\tfloat numLines = 5.0;\n\tfloat numRings = 7.0;\n\tfloat spiralAngle = PI/8.0;\n\t\n    float color = 100.0;\n\t\n\t//Vertical Bands\n\t//color += cos(numVertBands*cY + iTime);\t\n\t//Horizontal Bands\n\tcolor += cos(numHorBands*cX - iTime);\t\n\t//Diagonal Bands\n\t//color += cos(200.0*numDiagBands*(cX*sin(spiralAngle) + cY*cos(spiralAngle)) + iTime);\t\n\t//Arms\n\t//color += cos(numLines*newY + iTime);\n\t//Rings\n\tcolor += cos(numRings*newX - iTime);\n    //Spirals\n\tcolor += cos(500.0*numArms*(newX*sin(spiralAngle) + newY*cos(spiralAngle)) + iTime);\n\t//overall brightness/color\n\t//color *= cos(iTime/10.0);\n    fragColor = vec4( vec3( sin( color + iTime / 100.0 ) * 90.75, color, sin( color + iTime / 36.0 ) * 9.75 ), 1.0 );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtBGDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1093]], "test": "valid"}
{"id": "XtBGRd", "name": "Chinese Lanterns", "author": "hypothete", "description": "Chinese lanterns float through endless space", "tags": ["raytrace", "distf", "lanterns"], "likes": 4, "viewed": 175, "published": "Public", "date": "1431318823", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//thx iq for distance functions: http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nstruct camera {\n    vec3 position;\n    vec3 direction;\n};\n    \nconst vec3 worldUp = vec3(0.0,-1.0,0.0);\nconst float minStep = 0.1;\nconst float maxStep = 80.0;\nconst float delta = 0.01;\nconst float damping = 0.9;\nconst int numSteps = 100;\n\nbool onALantern = false;\n\nmat3 getViewMatrix (vec3 t, vec3 d, vec3 k)\n{\n\tvec3 z = normalize(d);\n    vec3 x = normalize(cross(d,k));\n    vec3 y = normalize(cross(z,x));\n    return mat3(x,y,z);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n\nfloat opRep( vec3 p, vec3 c )\n{\n    vec3 q = mod(p,c)-0.5*c;\n    float sphereDistf = sdSphere(q,  0.8);\n    float cylDistf = sdCappedCylinder(q,  vec2(0.4,1.0));\n    float coneDistf = udBox(vec3(q.x,q.y+1.6,q.z), vec3(0.2,0.6,0.01));\n    \n    float summed = min(cylDistf , sphereDistf);\n    summed = min(summed, coneDistf);\n    \n\tonALantern = summed == sphereDistf;\n    return summed;\n}\n\n\nfloat distf (vec3 pos)\n{\n\treturn opRep(pos,vec3(10.0));\n}\n\nvec3 normal (vec3 p)\n{\n    vec2 dm = vec2(delta, 0.0);\n\treturn normalize(vec3(\n    \tdistf(p+dm.xyy) - distf(p-dm.xyy),\n        distf(p+dm.yxy) - distf(p-dm.yxy),\n        distf(p+dm.yyx) - distf(p-dm.yyx)\n    ));\n}\n\nfloat castRay ( vec3 pos, vec3 dir, out vec3 norm)\n{\n    float dist = minStep;\n    for(int step = 0; step < numSteps; step++)\n    {\n        norm = pos + dir*dist;\n        float normL = distf(norm);\n        if(normL > delta || dist > maxStep){\n            dist += normL*damping;\n        }\n    }\n    return dist;\n}\n\n\nvec4 render(in vec2 xy)\n{\n    camera myCam = camera( \n    \tvec3(-cos(iTime/30.0)*30.0,3.0*sin(iTime/6.0),-sin(iTime/30.0)*30.0),\n    \tvec3(iMouse.x/iResolution.x*3.0-1.5,iMouse.y/iResolution.y*3.0-1.5,1.0)\n\t);\n    \n    mat3 viewMatrix = getViewMatrix(myCam.position, myCam.direction, worldUp);\n\n\tvec3 rayDir = viewMatrix * normalize(vec3(xy, 1.0));\n    vec3 ro = vec3(0.0,0.0,0.0);\n    vec4 colToRtn = vec4(1.0);\n    float histDistanceFunction = castRay(myCam.position, rayDir, ro);\n    if(histDistanceFunction < maxStep){\n        \n        vec3 nml = normal(ro);\n        if(onALantern){\n            colToRtn=vec4(1.0,1.0,0.8,1.0);\n            colToRtn += vec4(texture(iChannel1, vec2(nml.x,nml.z+iTime/10.0)));\n            colToRtn.xyz *= (15./distance(myCam.position, ro));\n            \n        }\n        else{\n            colToRtn = vec4(nml.x,0.0,0.0,1.0);\n            colToRtn *= vec4(texture(iChannel0, nml.xz));\n            colToRtn.xyz *= (25./distance(myCam.position, ro));\n        }\n        \n        \n        //color correction\n        \n        return colToRtn;\n    }\n    else{\n    \treturn vec4(0);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xx - 0.5;\n    fragColor = render(uv);\n}", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtBGRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 366, 411, 411, 533], [535, 535, 570, 570, 594], [596, 596, 638, 638, 737], [739, 739, 770, 770, 808], [810, 810, 842, 870, 931], [934, 934, 965, 965, 1320], [1323, 1323, 1347, 1347, 1380], [1382, 1382, 1404, 1404, 1595], [1597, 1597, 1649, 1649, 1909], [1912, 1912, 1937, 1937, 3027], [3029, 3029, 3086, 3086, 3164]], "test": "error"}
{"id": "Xtj3zt", "name": "Eclipse shape", "author": "SpacePrez", "description": "simple eclipse shape", "tags": ["sun"], "likes": 0, "viewed": 149, "published": "Public", "date": "1431462827", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float rad = 100.0 + iTime;\n    float thick = 0.8 + rad;\n    float thick2 = 40.0 + thick;\n    float disp = 35.0;\n    float disp2 = 30.0;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t//fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    \n    float xDist = abs(fragCoord.x - (iResolution.x/2.0));\n    float yDist = abs(fragCoord.y - (iResolution.y/2.0));\n    \n    float dist = sqrt((xDist * xDist) + (yDist * yDist));\n    \n    if(dist > rad && dist < thick){\n        fragColor = vec4(1.0,1.0,1.0,1.0);\n    }\n    else if(dist > thick && dist < thick2){\n        float frac = (dist - thick);\n        //frac = 2.0 - frac;\n        frac = (disp - frac) / disp2;\n\t\tfragColor = vec4(frac,frac,frac,1.0);\n        \n    }\n    /*\n    else if(dist < rad){\n        fragColor = vec4(0.0,0.0,0.0,1.0);\n    }*/\n    else{\n    \t//fragColor = vec4(0.1,0.1,0.1,1.0);\n        fragColor = vec4(0.0,0.0,0.0,1.0);\n    }\n    \n    //TODO: add chromatic abberation on edge?\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xtj3zt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1011]], "test": "valid"}
{"id": "XtjGR3", "name": "Run Game Demo2", "author": "yasuo", "description": "inspiration of spectra game.", "tags": ["3d", "game"], "likes": 14, "viewed": 1913, "published": "Public", "date": "1430919366", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\t\t#define NEAR 0.1\n\t\t#define FAR 100.\n\t\t#define ITER 128\n\t\t#define PI 3.14159265\n\n\t\tconst float Tau\t\t= 6.2832;\n\t\tconst float speed\t= .05;\n\t\tconst float density\t= .0000000000000001;\n\t\tconst float shape\t= .05;\n\n\t\tvec2 frot(vec2 p,float a){float c=cos(a),s=sin(a);return p*mat2(c,-s,s,c);}\n\t\tbool xnor(bool a,bool b){return !(a^^b);}\n\t\tbool alleq(bool a,bool b,bool c){return xnor(a,b)&&xnor(b,c)&&xnor(c,a);}\n\t\tbool rect(vec2 p,vec2 wh){return abs(p.x)<abs(wh.x)&&abs(p.y)<abs(wh.y);}\n\t\tbool digNF(vec2 p){return rect(p,vec2(.015,.17));}\n\t\tbool digN(vec2 p,int n){float D=.005;bool a=digNF(p-vec2(.1+D,.1+D)),b=digNF(p-vec2(.1+D,-.1-D)),c=digNF(p-vec2(-.1-D,.1+D)),d=digNF(p-vec2(-.1-D,-.1-D)),e=digNF(frot(p,PI/2.)),f=digNF(frot(p-vec2(0.,.2+2.*D),PI/2.)),g=digNF(frot(p+vec2(0.,.2+2.*D),PI/2.));if(n==0){return a||b||c||d||f||g;}if(n==1){return a||b;}if(n==2){return a||d||e||f||g;}if(n==3){return a||b||e||f||g;}if(n==4){return a||b||c||e;}if(n==5){return b||c||e||f||g;}if(n==6){return b||c||d||e||f||g;}if(n==7){return a||b||f;}if(n==8){return a||b||c||d||e||f||g;}if(n==9){return a||b||c||e||f||g;}return false;}\n\t\tbool colon(vec2 p){return rect(p*3.-vec2(0.,.3),vec2(.1))||rect(p*3.-vec2(0.,-.3),vec2(.1));}\n\n\t\tfloat getHrs(){return mod(floor(iTime/3600.),24.);}\n\t\tfloat getMns(){return mod(floor(iTime/60.),60.);}\n\t\tfloat getScs(){return mod(floor(iTime),60.);}\n\n\t\tfloat random(vec2 seed) {\n\t\t    return fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453);\n\t\t}\n\n\t\tfloat Cell(vec2 coord) {\n\t\t    vec2 cell = fract(coord) * vec2(.5, 2.) - vec2(.1, .5);\n\t\t    return (1. - length(cell * 0.5 - 0.25)) * step(random(floor(coord)), density) * 5.;\n\t\t}\n\n\t\tfloat sdBox( vec3 p, vec3 b )\n\t\t{\n\t\t\tvec3 d = abs(p) - b;\n\t\t\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n\t\t}\n\n\t\tvec4 mapCube( vec3 pos, vec3 cl)\n\t\t{\n\t\t\tfloat dist = sdBox(  pos , vec3(2.0,0.3,10.0));\n\t\t\treturn vec4( cl, dist );\n\t\t}\n\n\t\tfloat ship( vec3 p)\n\t\t{\n\t\t    return dot(vec3(0.9,0.3,0.5),abs(p))-1.0;\n\t\t}\n\n\t\tvec4 combine(vec4 val1, vec4 val2 )\n\t\t{\n\t\t\tif ( val1.w < val2.w ) return val1;\n\t\t\treturn val2;\n\t\t}\n\n\t\tvec4 map( vec3 pos)\n\t\t{\n\t\t\tvec4 q = vec4(pos+vec3(0,0,-60.0+iTime*70.0),1.0);\n\t\t\tq.z = mod(q.z, 40.0)-20.0;\n\n\t\t\tvec4 val1 = mapCube(q.xyz+vec3( 0, 0, 0.0 ), vec3(0.3+pos.y+sin(iTime*0.7),0.5+pos.y+sin(iTime*0.7),0.7+pos.y+sin(iTime*0.7)) );\n\t\t\t\n    \t\tfloat si = ship(pos+vec3( 0, -5.0+sin(iTime*10.0), -50.0 ));\n\t\t\treturn combine(val1,vec4(1,1,1,si));\n\t\t}\n\n\t\tvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n\t\t\tvec2 position = ( fragCoord.xy / iResolution.xy );\n\t\t\tposition -= .5;\n\n\t\t\tvec2 rot_t = vec2(iTime + cos(iTime*0.33) - length( position *sin(iTime*0.21)));\n\t\t\tmat2 rot_x = mat2(cos(rot_t.y), -sin(rot_t.x),sin(rot_t.x), cos(rot_t.y)) * 2.0;\n\n\t\t\tint sec = int(mod(iTime,10.));\n\n\t\t\tfloat dir2 = 1.0;\n\t\t\tif(sec>=4) {\n\t\t\t\tif(sec>=7)\n\t\t\t\t{\n\t\t\t\t\tdir2 = -1.0;\n\t\t\t\t}\n\t\t\t\tposition = position*rot_x*dir2;\n\t\t\t}\n\n\t\t\tvec3 dir = vec3( position, 1.0 );\n\t\t\tdir = normalize(dir);\n\t\t\t\n\t\t\tvec3 pos = vec3( .0, 3.5, 15.0);\n\t\t\t\n\t\t\tvec4 result;\n\t\t\tfor (int i =0; i < ITER; i++)\n\t\t\t{\n\t\t\t\tresult = map( pos);\n\t\t\t\tif (result.w < NEAR || result.w > FAR) break;\n\t\t\t\tpos += result.w * dir;\n\t\t\t}\n\n\t\t\tvec3 col = map(pos).xyz;\n\t\t\tif ( pos.z> 100. )\n\t\t\t{\n\t\t\t\tvec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\t\t\t\tif(sec>=4) {\n\t\t\t\t\tp = p*rot_x*dir2;\n\t\t\t\t}\n\n\t\t\t\tp.y += 0.1;\n\t\t\t\tvec2 uv;\n\t\t\t\t\n\t\t\t\tfloat r = sqrt(dot(p,p));\n\t\t\t\tfloat a = atan(p.y,p.x);\n\t\t\t\t\n\t\t\t\tuv.x = 0.1 * (iTime*3.0) - .1 / r;\n\t\t\t\tuv.y = 1. * a / 3.1416;\n\t\t\t\t\n\t\t\t\tvec2 position = floor(uv*20.0+sin(iTime)*2.0)/20.0;\n\n\t\t\t\tfloat ca = sin(3.14 * 20.0 * fract(sin(dot(position.xy,vec2(11.9898,78.233)))*43758.5453) + 2.0 * iTime);\n\t\t\t\tfloat cb = sin(3.14 * 30.0 * fract(sin(dot(position.xy,vec2(11.9898,78.233)))*43758.5453) + 3.0 * iTime);\n\t\t\t\tfloat cc = sin(3.14 * 20.0 * fract(sin(dot(position.xy,vec2(11.9898,78.233)))*43758.5453) + 1.0 * iTime);\n\t\t\t\tfloat color = ca*cb+cc-1.0;\n\n\t\t\t\t// took effect from http://glslsandbox.com/e#24979.0\n\t\t\t    float a2 = fract(atan(p.x, p.y) / Tau);\n\t\t\t    float d = length(p);\n\n\t\t\t    vec2 coord = vec2(pow(d, shape), a2) * 256.;\n\t\t\t    vec2 delta = vec2(-iTime * speed * 256., .5);\n\n\t\t\t    float c = 0.;\n\t\t\t\tcoord += delta;\n\t\t\t\tc = max(c, Cell(coord));\n\n\t\t\t    col = vec3(0.3+color, 0.5+color, 0.7+color)+vec3(c * d);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvec3 lightPos = vec3(20.0, 20.0, 20.0 );\n\t\t\t\tvec3 light2Pos = normalize( lightPos - pos);\n\t\t\t\tvec3 eps = vec3( .1, .01, .0 );\n\t\t\t\tvec3 n = vec3( result.w - map( pos - eps.xyy ).w,\n\t\t\t\t\t       result.w - map( pos - eps.yxy ).w,\n\t\t\t\t\t       result.w - map( pos - eps.yyx ).w );\n\t\t\t\tn = normalize(n);\n\t\t\t\t\t\t\n\t\t\t\tfloat lambert = max(.0, dot( n, light2Pos));\n\t\t\t\tcol *= vec3(lambert);\n\t\t\t\t\n\t\t\t\t// specular : \n\t\t\t\tvec3 h = normalize( -dir + light2Pos);\n\t\t\t\tfloat spec = max( 0., dot( n, h ) );\n\t\t\t\tcol += vec3(pow( spec, 16.)) ;\n\t\t\t}\n\t\t\t\n\t\t\tvec2 p2 = -1.0 + 2.0 * fragCoord.xy / iResolution.xy - vec2(0.7,1.1);\n\t\t\tfloat digT=0.;\n\t\t\tdigT+=digN(p2*5.-vec2(-.2,-1.),int(fract(iTime)*3.0))?1.:0.;\n\t\t\tdigT+=digN(p2*5.-vec2(.2,-1.),int(fract(iTime)*6.0))?1.:0.;\n\t\t\tdigT+=colon(p2*5.-vec2(.5,-1.))?1.:0.;\n\t\t\tdigT+=digN(p2*5.-vec2(.8,-1.),int(fract(iTime)*9.0))?1.:0.;\n\t\t\tdigT+=digN(p2*5.-vec2(1.2,-1.),int(mod(getScs(),10.)))?1.:0.;\n\n\t\t\tfragColor = vec4( col+vec3(digT), 1.0);\n\t\t}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtjGR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[211, 211, 237, 237, 286], [289, 289, 314, 314, 330], [333, 333, 366, 366, 406], [409, 409, 435, 435, 482], [485, 485, 504, 504, 535], [538, 538, 562, 562, 1116], [1119, 1119, 1138, 1138, 1212], [1216, 1216, 1231, 1231, 1267], [1270, 1270, 1285, 1285, 1319], [1322, 1322, 1337, 1337, 1367], [1371, 1371, 1396, 1396, 1474], [1478, 1478, 1502, 1502, 1658], [1662, 1662, 1695, 1695, 1786], [1790, 1790, 1826, 1826, 1909], [1913, 1913, 1936, 1936, 1988], [1992, 1992, 2031, 2031, 2090], [2094, 2094, 2117, 2117, 2449], [2453, 2453, 2509, 2509, 5292]], "test": "valid"}
{"id": "XtjGRt", "name": "Domain coloring!", "author": "Nilax", "description": "asdf", "tags": ["hurdur"], "likes": 1, "viewed": 126, "published": "Public", "date": "1431423602", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float yZoom = 5.0+sin(iTime);\n    vec2 pos = vec2(60.0*uv.x-60.0,\n                    yZoom * uv.y + float(5.0*iTime)- yZoom);\n    vec2 res = vec2(0.0);\n    \n    for (float n = 0.9; n < 100.0; n += 1.0) {\n        res.x += pow(n, pos.x)*cos(pos.y*log(n));\n        res.y += pow(n, pos.x)*sin(pos.y*log(n));        \n    }\n    fragColor = vec4(sin(res.x), sin(res.y), cos(res.x*res.y), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtjGRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 493]], "test": "valid"}
{"id": "XtjGzc", "name": "a_raytracer_test", "author": "AmbBAI", "description": "yes, raytracer.", "tags": ["raytracer"], "likes": 2, "viewed": 199, "published": "Public", "date": "1430995649", "time_retrieved": "2021-10-01T00:00:00", "image_code": "        const int MAX_REFLECT = 5;\n        const vec3 black = vec3(0.,0.,0.);\n        const vec3 white = vec3(1.,1.,1.);\n        const vec3 red = vec3(1.,0.,0.);\n        const vec3 blue = vec3(0.,0.,1.);\n\n        struct Ray {\n            vec3 origin;\n            vec3 direction;\n        };\n\n        struct Light {\n            int type;\n \n            vec3 position;\n            vec3 direction;\n            float range;\n\n            vec3 color;\n            float intensity;\n        };\n\n        struct Sphere {\n            vec3 center;\n            float radius;\n\n            int material;\n            vec3 color;\n            float reflectiveness;\n        };\n\n        struct Plane {\n            vec3 normal;\n            float distance;\n\n            int material;\n            vec3 color;\n            float reflectiveness;\n        };\n        \n        struct IntersectionResult {\n            float distance;\n            vec3 position;\n            vec3 normal;\n\n            int material;\n            vec3 color;\n            float reflectiveness;\n        };\n\n        vec3 theEye = vec3(0, 0, 0);\n        \n        Light theLight = Light(3, vec3(5.,5.,0.), normalize(vec3(-5.,-7.,5.)), 50., white, 1.);\n        //Light theLight = Light(2, vec3(0.,5.,5.), normalize(vec3(0.,-1.,0.)), 50., white, 1.);\n\n        float spotLightCosHalfPhi = cos(radians(60.));\n        float spotLightCosHalfTheta = cos(radians(10.));\n        float spotLightFalloff = 2.;\n\n\n        Sphere redSphere = Sphere(vec3(-2.5, 0, 5), 2., 11, red, 0.25);\n        Sphere blueSphere = Sphere(vec3(2.5, 0, 5), 2., 11, blue, 0.25);\n        Plane thePlane = Plane(vec3(0.,1.,0.), -2., 1, white, 0.5);\n\n        vec3 specColor = white;\n        float shininess = 10.;\n\n\n        IntersectionResult minIntersection(IntersectionResult a, IntersectionResult b)\n        {\n            if (a.distance < 0.) return b;\n            if (b.distance < 0.) return a;\n           \tif (a.distance < b.distance) return a; else return b;\n        }\n\n        float intersectPlane(Ray ray, Plane plane) {\n            float a = dot(ray.direction, plane.normal);\n            if (a >= 0.0) return -1.;\n            \n            vec3 position = plane.normal * plane.distance;\n            float b = dot(plane.normal, ray.origin - position);\n            if (b <= 0.0) return -1.;\n            \n            return -b / a;\n        }\n\n        float intersectSphere(Ray ray, Sphere sphere) {\n            vec3 co = ray.origin - sphere.center;\n            float discriminant = dot(co, ray.direction) * dot(co, ray.direction)\n                    - (dot(co, co) - sphere.radius * sphere.radius);\n\n            if (discriminant >= 0.0)\n                return -dot(ray.direction, co) - sqrt(discriminant);\n            else\n                return -1.;\n        }\n\n        IntersectionResult intersectScene(Ray ray)\n        {\n            float dis = -1.;\n\n            dis = intersectSphere(ray, redSphere);\n            IntersectionResult redSphereIntersection;\n            redSphereIntersection.distance = dis;\n            if (dis >= 0.)\n            {\n                redSphereIntersection.position = ray.origin + redSphereIntersection.distance * ray.direction;\n                redSphereIntersection.normal = normalize(redSphereIntersection.position - redSphere.center);\n                redSphereIntersection.material = redSphere.material;\n                redSphereIntersection.color = redSphere.color;\n                redSphereIntersection.reflectiveness = redSphere.reflectiveness;\n            }\n\n            dis = intersectSphere(ray, blueSphere);\n            IntersectionResult blueSphereIntersection;\n            blueSphereIntersection.distance = dis;\n            if (dis >= 0.)\n            {\n                blueSphereIntersection.position = ray.origin + blueSphereIntersection.distance * ray.direction;\n                blueSphereIntersection.normal = normalize(blueSphereIntersection.position - blueSphere.center);\n                blueSphereIntersection.material = blueSphere.material;\n                blueSphereIntersection.color = blueSphere.color;\n                blueSphereIntersection.reflectiveness = blueSphere.reflectiveness;\n            }\n\n            dis = intersectPlane(ray, thePlane);\n            IntersectionResult planeIntersection;\n            planeIntersection.distance = dis;\n            if (dis >= 0.)\n            {\n                planeIntersection.position = ray.origin + planeIntersection.distance * ray.direction;\n                planeIntersection.normal = thePlane.normal;\n                planeIntersection.material = thePlane.material;\n                planeIntersection.color = thePlane.color;\n                planeIntersection.reflectiveness = thePlane.reflectiveness;\n            }\n\n            IntersectionResult ret = minIntersection(redSphereIntersection, blueSphereIntersection);\n            ret = minIntersection(planeIntersection, ret);\n            return ret;\n        }\n\n        float calcShadow(vec3 position, vec3 lightDir)\n        {\n            Ray shadowRay = Ray(position, lightDir);\n            IntersectionResult ret = intersectScene(shadowRay);\n            if (ret.distance >= 0.) return 0.;\n            else return 1.;\n        }\n\n        void calcLight(out vec3 lightDir, out vec3 lightColor, vec3 position)\n        {\n            float intensity = theLight.intensity;\n            if (theLight.type == 1)\n            {\n                lightDir = -theLight.direction;\n                lightColor = theLight.color * intensity;\n            }\n            else if (theLight.type == 2 || theLight.type == 3)\n            {\n                lightDir = theLight.position - position;\n                float distance = length(lightDir);\n                lightDir /= distance;\n\n                float atten = theLight.range / (0.5 * distance * distance + 2. * distance + 1.);\n\n                if (theLight.type == 3)\n                {\n                    float rio = dot(-theLight.direction, lightDir);\n                    float factor = 1.;\n                    if (rio <= spotLightCosHalfPhi) factor = 0.;\n                    else if (rio > spotLightCosHalfTheta) factor = 1.;\n                    else\n                    {\n                        factor = (rio - spotLightCosHalfPhi) / (spotLightCosHalfTheta - spotLightCosHalfPhi);\n                        factor = clamp(pow(factor, spotLightFalloff), 0., 1.);\n                    }\n                    intensity *= factor;\n                }\n\n                lightColor = theLight.color * (intensity * atten);\n            }\n\n            lightColor *= calcShadow(position, lightDir);\n        }\n\n        vec3 calcColor(int material, vec3 position, vec3 normal, vec3 color)\n        {\n            if (material == 0) return black;\n\n            vec3 lightDir;\n            vec3 lightColor;\n            calcLight(lightDir, lightColor, position);\n\n            if (material == 1)\n            {\n                float tmp = abs(floor(position.x * 1.) + floor(position.z * 1.));\n                return ((mod(tmp, 2.) < 1.) ? black : white) * lightColor;\n            }\n            else if (material == 2)\n            {\n                vec2 texCoord = vec2(position.x * 0.2, position.z * 0.2);\n                return texture(iChannel0, texCoord).xyz * lightColor;\n            }\n            else if (material == 10)\n            {\n                return color * (max(0.0, dot(normal, lightDir)) * .8 + .2) * lightColor;\n            }\n            else if (material == 11)\n            {\n                float lambertian = max(0.0, dot(normal, lightDir));\n                float specular = 0.0;\n                if (lambertian > 0.0)\n                {\n                    vec3 reflectDir = normalize(normal * dot(normal, lightDir) * 2. - lightDir);\n                    float specAngle = max(dot(reflectDir, normalize(theEye - position)), 0.);\n                    specular = pow(specAngle, shininess);\n                }\n                \n                return (color * lambertian + specColor * specular) * lightColor;\n            }\n            else if (material == 12)\n            {\n                float lambertian = max(0.0, dot(normal, lightDir));\n                float specular = 0.0;\n                if (lambertian > 0.0)\n                {\n                    vec3 halfDir = normalize(lightDir + normalize(theEye - position));\n                    float specAngle = max(dot(halfDir, normal), 0.);\n                    specular = pow(specAngle, shininess * 4.);\n                }\n                \n                return (color * lambertian + specColor * specular) * lightColor;\n            }\n            return black;\n        }\n\n        vec3 rayTrace(Ray ray)\n        {\n            vec3 color = black;\n            float reflectiveness = 1.0;\n            for (int i=0; i<MAX_REFLECT; ++i)\n            {\n                IntersectionResult ret = intersectScene(ray);\n                if (ret.distance >= 0.)\n                {\n                    vec3 sampleColor = calcColor(ret.material, ret.position, ret.normal, ret.color);\n                    color += sampleColor * (1. - ret.reflectiveness) * reflectiveness;\n                    reflectiveness *= ret.reflectiveness;\n\n                    if (reflectiveness > 0.)\n                    {\n                        vec3 reflectDir = normalize(ret.normal * (-2. * dot(ret.normal, ray.direction)) + ray.direction);\n                        ray = Ray(ret.position, reflectDir);\n                    }\n                    else break;\n                }\n                else break;\n            }\n            return color;\n        }\n\n        void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n            float posPixelX = fragCoord.x / iResolution.x * 2.0 - 1.0;\n            float posPixelY = fragCoord.y / iResolution.y * 2.0 - 1.0;\n            float radio = iResolution.x / iResolution.y;\n\n            theEye = vec3(sin(iTime*0.2) * 0.2, sin(iTime*0.3) * 0.2, -1.);\n            vec3 rayDir = normalize(vec3(posPixelX * radio, posPixelY, 0) - theEye);\n            Ray theRay = Ray(theEye, rayDir);\n\n            fragColor.xyz = rayTrace(theRay);\n        }", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtjGzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1200, 1728, 1816, 1816, 1978], [1988, 1988, 2032, 2032, 2350], [2360, 2360, 2407, 2407, 2769], [2779, 2779, 2831, 2831, 4916], [4926, 4926, 4982, 4982, 5184], [5194, 5194, 5273, 5273, 6583], [6593, 6593, 6671, 6671, 8597], [8607, 8607, 8639, 8639, 9538], [9548, 9548, 9605, 9605, 10070]], "test": "error"}
{"id": "XtjGzt", "name": "2D Primitive Distance Functions", "author": "104", "description": "using distance functions to generate 2D filled shapes. Actually some of these are not 100% accurate but they're good for most applications.", "tags": ["2d"], "likes": 31, "viewed": 895, "published": "Public", "date": "1431982659", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = 3.14159;\nconst float pi2 = pi * 2.;\n\nmat2 rot2D(float r)\n{\n    float c = cos(r), s = sin(r);\n    return mat2(c, s, -s, c);\n}\n\n// convert distance to alpha\nfloat dtoa(float d, float amount)\n{\n    float a = clamp(1.0 / (clamp(d, 1.0/amount, 1.0)*amount), 0.,1.);\n    return a;\n}\n\n\n\n// distance functions: ------------------------------------------------\n\n\n\n// circle\nfloat sdCircle(vec2 uv, vec2 origin, float radius)\n{\n    float d = length(uv - origin) - radius;\n    return d;\n}\n\n// signed distance to segment of 1D space. like, for making a vertical column\nfloat sdSegment1D(float uv, float a, float b)\n{\n    return max(a - uv, uv - b);\n}\nfloat sdAxisAlignedRect(vec2 uv, vec2 tl, vec2 br)\n{\n  \tvec2 d = max(tl - uv, uv - br);\n    return length(max(vec2(0.0), d)) + min(0.0, max(d.x, d.y));\n}\n\n// the big question is what is the best way to INPUT a free rect? tl+br+angle? p1,p2,p3?\nfloat sdRect(vec2 uv, vec2 a, vec2 b, float angle)\n{\n    // flatten the line to be axis-aligned.\n    vec2 rectDimensions = b - a;\n    mat2 rotMat = rot2D(-angle);\n    a *= rotMat;\n    b *= rotMat;\n\treturn sdAxisAlignedRect(uv * rotMat, a, b);\n}\n\n// really a line segment with line width is just a rect expressed differently\nfloat sdLineSegment(vec2 uv, vec2 a, vec2 b, float lineWidth)\n{\n    // flatten the line to be axis-aligned.\n    vec2 rectDimensions = b - a;\n    float angle = atan(rectDimensions.x, rectDimensions.y);\n    mat2 rotMat = rot2D(-angle);\n    a *= rotMat;\n    b *= rotMat;\n    float halfLineWidth = lineWidth / 2.;\n    a -= halfLineWidth;\n    b += halfLineWidth;\n\treturn sdAxisAlignedRect(uv * rotMat, a, b);\n}\n\n// union of line segment and 2 circles\nfloat sdLineSegmentRounded(vec2 uv, vec2 a, vec2 b, float lineWidth)\n{\n    // flatten the line to be axis-aligned.\n    vec2 rectDimensions = b - a;\n    float angle = atan(rectDimensions.x, rectDimensions.y);\n    mat2 rotMat = rot2D(-angle);\n    a *= rotMat;\n    b *= rotMat;\n    float halfLineWidth = lineWidth / 2.;\n\n    uv *= rotMat;\n    vec2 tl = vec2(a.x - halfLineWidth, a.y);\n    vec2 br = vec2(b.x + halfLineWidth, b.y);\n\n    return min(min(sdAxisAlignedRect(uv, tl, br),\n                   sdCircle(uv, a, halfLineWidth)),\n                   sdCircle(uv, b, halfLineWidth));\n}\n\n\n// squircle\n// http://en.wikipedia.org/wiki/Squircle\nfloat sdSquircle(vec2 uv, vec2 origin, float radius, float power, float rot_)\n{\n    mat2 rot = rot2D(rot_);\n\tvec2 v = abs((origin*rot) - (uv*rot));\n    float d = pow(v.x,power) + pow(v.y, power);\n    d -= pow(radius, power);\n    return d;\n}\n\n// distance to edge of hexagon\nfloat sdHexagon(vec2 p, vec2 hexPos, float hexRadius, float hexRotation)\n{\n    mat2 rot = rot2D(hexRotation);\n\tvec2 v = abs((hexPos*rot) - (p*rot));\n\n\tvec2 topBottomEdge = vec2(0., 1.);\n\tconst vec2 sideEdges = vec2(0.86602540358, 0.5);// cos(radians(30)), sin(radians(30))\n\n\tfloat dot1 = dot(v, topBottomEdge);\n\tfloat dot2 = dot(v, sideEdges);\n    float dotMax = max(dot1, dot2);\n\t\n    return dotMax - hexRadius;\n}\n\n\n// signed distance to a 2D triangle\n// thank you iq: https://www.shadertoy.com/view/XsXSz4\nfloat sdTriangle(in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2)\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    vec2 d = min( min( vec2( dot( pq0, pq0 ), v0.x*e0.y-v0.y*e0.x ),\n                       vec2( dot( pq1, pq1 ), v1.x*e1.y-v1.y*e1.x )),\n                       vec2( dot( pq2, pq2 ), v2.x*e2.y-v2.y*e2.x ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.yy;\n    \n    // background color\n    fragColor = vec4(1.0,0.94,0.67,1.0);\n    float dist;\n    float a, b, c, d, e, f;\n    vec2 tl, rectSize;\n    \n    // green column ------------------------------------------------\n    a = (sin(iTime+4.)+1.)/2.;\n    dist = sdSegment1D(uv.x, a, a + 0.3);\n\tfragColor = mix(fragColor, vec4(.1,0.5,0.2,1.0), 0.3 * dtoa(dist, 60.));\n\n    \n    \n    // axis-aligned rect ------------------------------------------------\n    vec4 circleColor = vec4(.4,0.5,0.6,1.0);\n    tl.x = (sin(iTime+5.)+1.)/3.;// top\n    tl.y = (sin(iTime+6.)+1.)/3.;// left\n    rectSize.x = (sin(iTime+7.)+2.5)/7.;// height\n\trectSize.y = (sin(iTime+8.)+2.5)/7.;// width\n    dist = sdAxisAlignedRect(uv, tl, tl + rectSize);\n    // the -0.05 here will make the object bigger, and reveal how accurate the distances are at corners.\n\tfragColor = mix(fragColor, circleColor, 0.9 * dtoa(dist-0.05, 60.));\n    \n    // draw the points\n    dist = sdCircle(uv, tl,0.);\n\tfragColor = mix(fragColor, circleColor * 0.5, 0.9 * dtoa(dist, 250.));\n    \n    dist = sdCircle(uv, tl + rectSize,0.);\n\tfragColor = mix(fragColor, circleColor * 0.5, 0.9 * dtoa(dist, 250.));\n\n    \n    // white rectangle ------------------------------------------------\n    vec4 rectColor = vec4(1.0);\n    a = 0.2+ (sin(iTime*0.25+25.)+.5)/5.;// top\n    b = 0.5;\n    c = 0.3;\n\td = 0.8;\n    vec2 br;\n    tl = vec2(min(a,c),min(b,d));\n    br = vec2(max(tl.x+0.1,max(a,c)),max(tl.y+0.1,max(b,d)));\n    \n    tl += vec2(.8,-0.4);\n    br += vec2(1.,-0.4);\n    \n    float angle = (sin(iTime)+1.0);// 0-2\n    angle = angle * pi / 9.;// restrict; many angles produce negative shape\n\n    dist = sdRect(uv, tl,br, angle);\n\tfragColor = mix(fragColor, rectColor, 0.9 * dtoa(dist - 0.05, 600.));\n    \n    // draw the points\n    dist = sdCircle(uv, tl,0.);\n\tfragColor = mix(fragColor, rectColor * 0.5, 0.9 * dtoa(dist, 250.));\n    \n    dist = sdCircle(uv, br,0.);\n\tfragColor = mix(fragColor, rectColor * 0.5, 0.9 * dtoa(dist, 250.));\n\n    \n    \n    // line segment ------------------------------------------------\n    vec4 lineSegmentColor = vec4(.1,0.5,0.2,1.0);\n    a = 0.4 + (sin(iTime*0.15+5.)+.5)/5.;// top\n    b = (sin(iTime*0.15+6.)+3.)/6.;// left\n    c = 0.5 + (sin(iTime*0.15+7.)+.5)/5.5;// height\n\td = (sin(iTime*0.15+8.)+3.5)/6.5;// width\n\n    float lineWidth = (sin(iTime*0.25+9.)+1.05)*0.18;\n    \n    dist = sdLineSegment(uv, vec2(a,b), vec2(c,d), lineWidth);\n\tfragColor = mix(fragColor, lineSegmentColor, 0.6 * dtoa(dist, 600.));\n    \n    // draw the points\n    dist = sdCircle(uv, vec2(a,b),0.);\n\tfragColor = mix(fragColor, lineSegmentColor, 0.8 * dtoa(dist, 250.));\n    \n    dist = sdCircle(uv, vec2(c,d),0.);\n\tfragColor = mix(fragColor, lineSegmentColor, 0.8 * dtoa(dist, 250.));\n    \n    \n    \n    \n    // rounded line segment ------------------------------------------------\n    lineSegmentColor = vec4(.5,0.5,0.1,1.0);\n    a += 0.75;\n    c += 0.75;\n    dist = sdLineSegmentRounded(uv, vec2(a,b), vec2(c,d), lineWidth);\n\tfragColor = mix(fragColor, lineSegmentColor, 0.6 * dtoa(dist, 600.));\n    \n    // draw the points\n    dist = sdCircle(uv, vec2(a,b),0.);\n\tfragColor = mix(fragColor, lineSegmentColor, 0.8 * dtoa(dist, 250.));\n    \n    dist = sdCircle(uv, vec2(c,d),0.);\n\tfragColor = mix(fragColor, lineSegmentColor, 0.8 * dtoa(dist, 250.));\n    \n    \n    \n    // triangle ------------------------------------------------\n    vec4 triangleColor = vec4(.3,0.1,0.3,1.0);\n    float time = iTime * 0.7;\n    a = (sin(time)+1.)/2.;\n    b = (sin(time+4.*0.4)+1.)/4.;\n    c = (sin(time+4.*0.4)+1.)/4.;;\n\td = 0.75;\n\te = 0.8;\n\tf = 0.75;\n    \n    dist = sdTriangle(uv, vec2(a,b), vec2(c,d), vec2(e,f));\n    // the -0.05 here will make the object bigger, and reveal how accurate the distances are at corners.\n\tfragColor = mix(fragColor, triangleColor, 0.7 * dtoa(dist - 0.05, 200.));\n    \n    // draw the points\n\tfragColor = mix(fragColor, triangleColor, 0.9 * dtoa(sdCircle(uv, vec2(a,b),0.005), 2000.));\n\tfragColor = mix(fragColor, triangleColor, 0.9 * dtoa(sdCircle(uv, vec2(c,d),0.005), 2000.));\n\tfragColor = mix(fragColor, triangleColor, 0.9 * dtoa(sdCircle(uv, vec2(e,f),0.005), 2000.));\n    \n    \n    \n    \n    \n    // red squircle ------------------------------------------------\n    dist = sdSquircle(uv,\n                      vec2(0.5 +((sin(iTime*0.75)+1.)/3.), (cos(iTime*1.3)/6.)+0.5),\n                      0.2, (sin(iTime)/1.2)+1.5, iTime);\n    // this converts distance -> alpha + color -> fragcolor\n\tfragColor = mix(fragColor, vec4(.85,0.,0.,1.0), 0.7 * dtoa(dist, 250.));\n    \n\n    // blue circle ------------------------------------------------\n    dist = sdCircle(uv,\n                    vec2(0.5 +((cos(iTime*0.85)+1.)/2.), (pow(cos(iTime*1.1),3.)/7.)+0.5),\n                    0.2);\n\tfragColor = mix(fragColor, vec4(.2,0.,0.8,1.0), 0.7 * dtoa(dist, 250.));\n    \n    \n    // yellow hex ------------------------------------------------\n\tdist = sdHexagon(uv,\n                     vec2(0.5 +((cos((iTime+1.4)*1.25)+1.)/4.), 0.6),\n                     0.2,\n                     iTime);\n\tfragColor = mix(fragColor, vec4(0.8,0.8,0.1,1.0), 0.7 * dtoa(dist, 60.));\n    \n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtjGzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 54, 75, 75, 141], [143, 172, 207, 207, 293], [372, 382, 434, 434, 494], [496, 574, 621, 621, 655], [656, 656, 708, 708, 809], [811, 900, 952, 996, 1144], [1146, 1224, 1287, 1331, 1629], [1631, 1670, 1740, 1784, 2254], [2257, 2310, 2389, 2389, 2550], [2552, 2583, 2657, 2657, 2997], [3000, 3091, 3156, 3156, 3708], [3713, 3713, 3770, 3770, 8945]], "test": "valid"}
{"id": "XtS3DV", "name": "fractal with analytical normals", "author": "joeedh", "description": "Example of deriving normals analytically when ray marching.  Also, semi-faked AO.", "tags": ["fractalaonormalsraymarching"], "likes": 3, "viewed": 222, "published": "Public", "date": "1432354385", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define DIV 3.0  //different levels give different/stranger appearange\n//#define DIV (abs(sin(iTime*0.5)*2.0)+1.5)\n#define LEVELS 4\n\n#define AO_DIST 0.4; //(sin(iTime)*0.4+0.6)\n//#define AO_ONLY\n\n#define STEPS 80\n#define ERROR_LIMIT 0.001\n#define STEPMUL 0.25 //smaller values give more precis results, if combined with higher STEPS\n\n#define SLICE_START 0.0 //(sin(iTime*1.0)*0.5+1.0)*3.0\n\nstruct Sample {\n    float dis;\n    vec2 ao;\n    vec3 no;\n};\n    \nvec2 do_ao(float dis) {\n    float r = abs(dis)/AO_DIST;\n    \n    r = smoothstep(0.0, 1.0, r);\n    r = 1.0 - pow(r*0.7, 0.4);\n    \n    return vec2(r*0.9, 1.0); //min(r, 1.0);\n    //return pow(min(r*3.0, 1.0), 0.5);\n}\n\nvec2 combine_ao(vec2 a, vec2 b) {\n    float r1 = a[0]+b[0];\n    float r2 = a[1]+b[1];\n    return vec2(r1, r2);\n}\n\nSample subtract(Sample a, Sample b) {\n    float num = a.ao[0] > b.ao[0]+0.01 ? a.ao[1] : b.ao[1];\n    vec2 ao = vec2(0.0, 0.0);\n    \n    if (a.dis < 0.05) {\n    \tao = a.ao + b.ao;\n    } else {\n        ao = b.ao;\n    }\n    \n    ao = b.ao;\n    //ao = a.ao + b.ao;\n    \n    vec3 no = -a.dis > b.dis ? a.no : b.no;\n    \n    return Sample(\n        max(-a.dis, b.dis),\n        ao,\n        no);\n}\n\n\nSample add(Sample a, Sample b) {\n    vec3 diff;\n    \n    vec3 no = a.dis < b.dis ? a.no : b.no;\n    \n    return Sample(min(a.dis, b.dis), combine_ao(a.ao, b.ao), no);\n}\n\n//*\nSample sphere(vec3 p, vec3 c, float radius) {\n    p -= c;\n    float w = 2.5; //(pow(radius, 0.1));\n    return Sample(length(p) - radius, w*do_ao(length(p)-radius), -p);\n}\n\nSample box(vec3 p, vec3 c, vec3 size) {\n    p = abs(p-c) - size;\n    \n    float d = max(max(p[0], p[1]), p[2]);\n    float d1 = d;\n    \n    //*\n    d = max(d, p[0]+p[1]);\n    d = max(d, p[0]+p[2]);\n    d = max(d, p[1]+p[2]);\n    //*/\n    \n    vec3 no = vec3(0.0);\n    \n    float b1 = float(p[0] > p[1] && p[0] > p[2]);\n    float b2 = float(p[1] > p[0] && p[1] > p[2]);\n    float b3 = float(p[2] > p[0] && p[2] > p[1]);\n        \n    no = vec3(b1, b2, b3);\n    \n    return Sample(d, do_ao(d), no);\n}\n\n/*\nSample simplebox(vec3 p, vec3 c, vec3 size) {\n    p = abs(p-c) - size;\n    \n    float d = max(max(p[0], p[1]), p[2]);\n    \n    float b1 = float(p[0] > p[1] && p[0] > p[2]);\n    float b2 = float(p[1] > p[0] && p[1] > p[2]);\n    float b3 = float(p[2] > p[0] && p[2] > p[1]);\n        \n    vec3 no = vec3(b1, b2, b3)*-p;\n    \n    return Sample(d, do_ao(d), no);\n}\n*/\n\n\n//*/\n\nvec3 rotz(vec3 p, float th, float sfac) {\n    th += iTime*2.0*sfac+0.9;\n    return vec3(\n        sin(th)*p[0] - cos(th)*p[1],\n        sin(th)*p[1] + cos(th)*p[0],\n        p[2]\n    );\n}\nvec3 twist(vec3 p, float sfac) {\n    float tfac = 10.0; //(1.0-sin(iTime)*0.25-0.75)*10.0; //10.0\n    return rotz(p, p[2]*tfac+sfac*6.0, sfac); //vec3(p[0]+(sin(p[2]*20.0))*0.1, p[1]+cos(p[2]*20.0)*0.01, p[2]);\n}\n    \nSample bcross(vec3 p, float w) {\n    return add(add(box(p, vec3(0), vec3(w, w, 1000.0)),\n               box(p, vec3(0), vec3(w, 10000.0, w))),\n               box(p, vec3(0), vec3(10000.0, w, w)));\n}\n\nfloat rep(float p, float step) {\n    //return mod(p, step);\n    \n    float t = mod(abs(p), step)/step;\n    float t2 = mod(floor(p/(step*2.0)), 2.0);\n    \n    if (sign(p) > 0.00)\n        t = 1.0 - t;\n    \n    if (t2 != 0.0) {\n//        t = 1.0 - t;\n    }    \n    \n    return t*step; //sign(p)*step;\n}\n\nvec3 rep(vec3 p, float step) {\n    return vec3(\n        rep(p[0], step),\n        rep(p[1], step),\n        rep(p[2], step)\n    );\n}\n\nSample sample1(Sample cur, vec3 p, vec3 rd, float t) {\n    vec3 b = abs(p)-vec3(0.4, 0.4, 0.1);\n    Sample ret = cur;\n    \n    Sample ret2 = box(p, vec3(0.0), vec3(1.0, 1.0, 1.0)); \n    float w = 1.0/DIV, w2 = w;\n    vec3 op = p;\n    float fac = 1.0, off = 0.0;\n    \n    for (int i=0; i<LEVELS; i++) {\n        Sample crs = bcross(p, w);\n        \n        ret2 = subtract(crs, ret2);\n        \n        fac *= 1.0/w;\n        off = -w;\n        \n        p = rep(op*fac+vec3(off,off,off), 2.0)*0.5;\n    }\n    \n    ret = ret2;\n    return ret;\n}\n/*\nvec3 sample_no(vec3 p, vec3 rd, float t) {\n#define DF 0.000001\n    Sample samp = Sample(0.0, vec2(0.0), vec3(0.0));\n    \n    float s1 = sample(samp, p, rd, t).dis;\n    float s2 = sample(samp, p+vec3(DF, 0.0, 0.0), rd, t).dis;\n    float s3 = sample(samp, p+vec3(0.0, DF, 0.0), rd, t).dis;\n    float s4 = sample(samp, p+vec3(0.0, 0.0, DF), rd, t).dis;\n    \n    //s1 = abs(s1);\n    //s2 = abs(s2);\n    //s3 = abs(s3);\n    //s4 = abs(s4);\n\t//\n    \n    return (vec3(s2, s3, s4) - vec3(s1, s1, s1))/DF;\n    \n}*/\n\nfloat tri(float t) {\n    return abs(abs(fract(t))-0.5)*2.0;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = (uv-0.5);\n    uv[0] *= 1.75;\n    \n    float tm = iTime*2.0+4.0;\n    float cdis = sin(tm*0.70)*0.5+0.8;\n    float z1 = smoothstep(0.0, 1.0, tri(tm*0.1))-0.5;\n    z1 *= 0.5;\n    cdis = 3.0 + sin(tm*1.5)*0.0;\n    //tm = 0.9;\n    float sp1 = 0.25, sp2=0.4;\n\tvec3 ro = vec3(cos(tm*sp1)*cdis, sin(tm*sp2)*cdis, z1+1.45); //sin(tm*1.0+1.5)*0.5+1.7);\n    vec3 rt = vec3(0.0, 0.0, 0.0);\n    \n    vec3 rd = normalize(rt-ro);\n    \n    vec3 rx = normalize(cross(rd, vec3(0.0, 0.0, 1.0)));\n    vec3 ry = normalize(cross(rx, rd));\n    \n    //lens distortion\n    float sc = 1.0 + 0.2*pow(length(uv)*1.0, 3.0);\n    rd += uv.x*rx*sc + uv.y*ry*sc;\n    \n    float dis=0.0;\n    float t = 0.0;\n    float tmul = 0.5;\n    Sample samp=Sample(0.0, vec2(0.0), vec3(0.0));\n    vec3 p;\n    \n    //jump to bounding box first, for greater precision later\n    for (int i=0; i<45; i++) {\n        p = ro+rd*t;\n\t\n        samp=box(p, vec3(0.0), vec3(1.0, 1.0, 1.0)); \n        t += samp.dis*0.6;\n        \n    }    \n    \n    for (int i=0; i<STEPS; i++) {\n\t    t = max(t, SLICE_START);\n        p = ro+rd*t;\n\t\n        samp=Sample(0.0, vec2(0.0), vec3(0.0));\n        samp = sample1(samp, p, rd, t);\n        dis = samp.dis;\n        \n        //need to make step be computer by sample()\n        tmul = STEPMUL;\n        t += dis*tmul;\n        \n        float mn = -ERROR_LIMIT;\n        if (dis >= mn*2.0 && dis <= 0.001) { //dis < 0.005 && dis > -0.005) {\n            break;\n        }\n    }\n    \n    float ao = max(samp.ao[0]/samp.ao[1], 0.0);\n    float c = 1.0;\n    \n#ifndef AO_ONLY\n    //* //lighting, needs (slow) filtering\n    vec3 light = normalize(vec3(0.0, 1.0, 0.5));\n    \n    vec3 no = normalize(samp.no);\n    c = abs(dis);\n    c = 1.5*(abs(dot(no, light))*0.6+0.4)*float(c < 0.05);\n    \n    ao = ao*0.65+0.35;\n    \n    //FAKE self shadowing, subtract from AO by how much light is reflected\n    ao -= (max(abs(dot(no, light)), 0.0))*0.55;\n    ao = max(ao, 0.0);\n\t//*/\n#endif\n    c *= ao;\n    \n    //radial blend from screen center, adjusted for distance in xy plane\n    float cf = length(ro.xy) < 3.0 ? length(ro.xy)/3.0 : 1.0;\n    c += (c*pow(0.89 - pow(length(uv), 1.2), 1.0)*1.3-c)*cf;\n    vec3 color = vec3(0.5, 0.8, 0.95)*c*1.5;\n    \n    //add some subtle color variation\n    color[1] -= pow(pow(length(uv), 0.8), 1.2)*0.07*(c == 0.0 ? 0.0 : 1.0);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtS3DV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[177, 455, 478, 478, 670], [672, 672, 705, 705, 784], [786, 786, 823, 823, 1175], [1178, 1178, 1210, 1210, 1346], [1348, 1352, 1397, 1397, 1522], [1524, 1524, 1563, 1563, 2020], [2390, 2396, 2437, 2437, 2580], [2581, 2581, 2613, 2613, 2793], [2799, 2799, 2831, 2831, 2997], [2999, 2999, 3031, 3058, 3298], [3300, 3300, 3330, 3330, 3430], [3432, 3432, 3486, 3486, 3968], [3969, 4479, 4499, 4499, 4540], [4541, 4541, 4598, 4598, 7007]], "test": "valid"}
{"id": "XtS3R3", "name": "projectivity", "author": "Doublefresh", "description": "shows how to transform a parabola to a circle as the image of a projective transformation.", "tags": ["2d", "transformation", "projective"], "likes": 11, "viewed": 1061, "published": "Public API", "date": "1431208918", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct conic_t {\n    float a, b, c, d, e, f;\n};\n    \nconic_t newconic(in float a, in float b, in float c, in float d, in float e, in float f) {\n    conic_t cs;\n    cs.a = a;\n    cs.b = b;\n    cs.c = c;\n    cs.d = d;\n    cs.e = e;\n    cs.f = f;\n    return cs;\n}\n\n// Projective coordinate transformation under which the  \n// image of a parabola y^2 - xis transformed to the unit circle\nvec3 parabola2circle(in vec3 p) {\n    vec3 q;\n    \n    q.y = p.z - p.y;\n    q.z = p.z + p.y;\n    q.x = p.x;\n    \n    return q; \n}\n    \n// ax^2 + by^2 + cxy + dx + ey + f \nfloat conic(in vec3 p, in conic_t z) {\n    float Z = p.z;\n    p /=  p.z;\n    float v = z.a*p.x*p.x + z.b*p.y*p.y + z.c*p.y*p.x + z.d*p.x + z.e*p.y + p.z * z.f;\n    \n    // technique from iq: divide by gradient:\n    vec3 grad;\n    grad.x = 2.0*z.a*p.x + p.y*z.c + z.d;\n    grad.y = 2.0*z.b*p.y + p.x*z.c + z.e;\n    grad.z = p.z;\n    v /= dot(grad, grad) / max(Z, 0.35);\n    \n    return smoothstep(0.01, 0.00, abs(v));\n}\n\nfloat gridlines(vec3 p) {\n    float Z = p.z;\n    float th = 0.3;\n    p /= p.z;\n    \n    vec2 l = mod( p.xy, th );\n    \n    l = vec2(l.x > 0.5*th ? th - l.x : l.x,\n             l.y > 0.5*th ? th - l.y : l.y);\n\n    float z = 1.0-smoothstep(0.0, 0.08*th, l.x);\n    float w = 1.0-smoothstep(0.0, 0.08*th, l.y);\n    \n    return pow(min(max(z,w), clamp(Z, 0.0, 1.0)), 2.0);\n}\n\nconic_t parabola() {\n    return newconic(1.0, 0.0, 0.0, 0.0, -1.0, 0.0);\n}\n\nconic_t line() {\n    return newconic(0.0, 0.0, 0.0, 1.0, -1.0, 0.0);\n}\n\nconic_t circle() {\n    return newconic(1.0, 1.0, 0.0, 0.0, 0.0, -1.0);\n}\n\nconic_t hyperbola() {\n    return newconic(1.0, -1.0, 0.0, 0.0, 0.0, -1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uva = fragCoord.xy / iResolution.xy;\n    vec3 col, col_h;\n    \n    uva = 2.0 * uva - 1.0;\n    uva.x *= iResolution.x / iResolution.y;\n    vec3 uv = vec3(uva.xy*2.5, 1.0);\n    \n        \n    col = vec3(0.3+ 0.1*uv.y, 0.3 + 0.1*uv.y, 0.3 + 0.1*uv.y);\n    \n    uv = mix(uv, parabola2circle(uv), 0.5 + 0.5*sin(iTime));\n \n    col = mix(col, vec3(0.7), gridlines(uv));\n    col = mix(col, vec3(0.8, 0.4, 1.0), conic(uv, parabola()));\n    col = mix(col, vec3(0.4, 0.8, 1.0), conic(uv, line()));\n    col = mix(col, vec3(0.0, 0.8, 0.0), conic(uv, circle()));\n    //col = mix(col, vec3(1.0, 0.0, 0.0), conic(uv, hyperbola()));\n    \n     \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtS3R3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 143, 143, 260], [262, 384, 417, 417, 513], [519, 555, 593, 593, 973], [975, 975, 1000, 1000, 1344], [1346, 1346, 1366, 1366, 1420], [1422, 1422, 1438, 1438, 1492], [1494, 1494, 1512, 1512, 1566], [1568, 1568, 1589, 1589, 1644], [1647, 1647, 1703, 1703, 2372]], "test": "valid"}
{"id": "XtS3WG", "name": "More metaballs", "author": "Tsarpf", "description": "WIP", "tags": ["raymarching"], "likes": 4, "viewed": 248, "published": "Public", "date": "1431638676", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat lengthRound(vec3 p)\n{\n\tfloat n = 1.7;\n\treturn pow(pow(p.x,n) + pow(p.y,n) + pow(p.z,n), 1.0/n);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  \n  //float lengthRounded = lengthRound(max(d,0.0));\n  //return min(max(d.x,max(d.y,d.z)),0.0) + lengthRounded;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec3 repeatPos(vec3 p, vec3 c)\n{\n\treturn mod(p,c)-.5 * c;\n}\n\nfloat getDistance(vec3 position)\n{\t\n    vec3 pos = vec3\n        (\n            (position.x - 15.0 * sin(iTime)),\n            position.y + 2.0 * cos(iTime),\n            position.z - 0.5\n        );\n    \n    vec3 pos2 = vec3\n        (\n            (position.x + 1.7 * cos(iTime)) + 2.0,\n            position.y + 19.7 * sin(iTime),\n            position.z\n        );\n    vec3 pos3 = vec3(\n        \tposition.x - 9.8 * sin(iTime - 3.3) + 0.2,\n        \tposition.y + 1.8 * cos(iTime - 3.3),\n        \tposition.z - 20.0 * cos(iTime)\n    \t);\n  \n    \n    \n    \n    float dis1 = sdSphere(pos, 20.0);\n    \n    float dis2 = sdSphere(pos2, 13.3);\n    //float dis2 = sdBox(pos2, vec3(1., 1., 1.));\n    \n    \n    \n    float dis3 = sdSphere(pos3, 15.0);\n  \n    \n    float distance = smin(dis1, dis2, 0.4);\n    distance = smin(distance, dis3, 0.4);\n  \n    \n    //return dis1;\n    return distance;\n    \n    \n    //return sdSphere(pos, 2.0);\n    //Repeat shape\n\t//vec3 repPos = repeatPos(position, vec3(5.0,20.0,4.5));\n    \n    //Draw cubes\n\t//return sdBox(repPos, vec3(1.,1.,1.));\n\t\n    //Draw spheres\n\t//return sdSphere(repPos, 1.0);\n}\n\nvec4 getColor(vec3 position)\n{\n\tfloat e = 0.0001;\n\tfloat f0 = getDistance(position);\n\t\n    //Approximate the normal by stepping a minimal amount in each of the axes' direction\n\tfloat fx = getDistance(vec3(position.x + e, position.y, position.z));\n\tfloat fy = getDistance(vec3(position.x, position.y + e, position.z));\n\tfloat fz = getDistance(vec3(position.x, position.y, position.z + e));\n\t\n\t\n\t\n\tvec3 normal = normalize(vec3(fx - f0, fy - f0, fz - f0));\n\tvec3 lightPosition = vec3\n\t\t(\n\t\t\t-10.0, //+ 12.0*sin(iTime*1.0),\n\t\t\t0.0, //+ 12.0*sin(iTime*2.0),\n            -50.0\n            //iTime * 20.0\n            \n            //-1.0 - sin(iTime) * 2.0\n\t\t\t//280.0 + 300.0*sin(iTime*1.0) //Make the light move on the z axis\n\t\t\t//iTime * 5.0 + 100.0\n\t\t);\n\tvec3 lightDir = normalize(lightPosition - position);\n\tvec4 lightColor = vec4\n        (\n            (sin(iTime * 0.1) + 0.5)/ 10.0,\n            (sin(iTime / 1.1) + 1.5)/ 10.0,\n            (cos(iTime * 0.1) + 0.5)/ 10.0,\n            //0.5 * tan(iTime),\n            //0.5 - 0.5 * sin(iTime),\n            //0.5 - 0.5 * cos(iTime),\n            0.2);\n\tvec4 lightIntensity = lightColor * dot(normal, lightDir);\n\tfloat reflectance = 0.5;\n\t\n\tfloat lightDistance = length(position-lightPosition);\n    \n    //Hacky but pretty good looking light intensity diminishing over distance\n\t//float distanceIntensity = (1.0 / (pow(lightDistance / 100.0, 1.1))); \n    float distanceIntensity = (5.0 / (pow(lightDistance / 25.0, 1.0001))); \n\t\n\treturn reflectance * lightIntensity * (distanceIntensity);\n\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Moving eye position, bugs on some weaker hardware and just shows grey as mentioned in the omments\n    //vec3 eye = vec3(0, 3, iTime * 20.0 - 50.0);\n    \n    //Still eye\n\tvec3 eye = vec3(0, 0, -50);\n\t//eye.z = -1.0*sin(iTime);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = vec3(1, 0, 0);\n    \n    //Epsilon for when we are close enough to a surface to decide the surface is right here\n    float epsilon = 0.1;\n    float maxDistance = 100000.0;\n\n\t//Normalized device coordinates\n\tvec2 ndcXY = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\t\n\t// aspect ratio\n\tfloat aspectRatio = iResolution.x / iResolution.y;\n\t\n\t// scaled XY which fits the aspect ratio\n\tvec2 uv = ndcXY * vec2( aspectRatio, 1.0 );\n\t//uv.y += (0.07 * sin(uv.x + iTime*4.0));\n\n\t\n    \n    //Variables needed for ray marching this pixel\n    float focalLength = 1.0;\n    vec3 forward = normalize(cross(right, up));\n    \n    vec3 planePos = right * uv.x + up * uv.y;\n\t\n    vec3 pImagePlane = eye + forward * focalLength + planePos;\n    vec3 rayDirection = normalize(pImagePlane - eye);\n\n\t// Sky color\n    vec4 color = vec4\n\t\t(\n\t\t\t0.30,\n\t\t\t0.30,\n\t\t\t0.30,\n\t\t\t1\n\t\t); \n\n    float t = 0.0;\n    const float maxSteps = 512.0;\n    for(float i = 0.0; i < maxSteps; ++i)\n    {\n        vec3 p = pImagePlane + rayDirection * t;\n\t\tfloat d = getDistance(p);\n\t\tif(d > maxDistance) {break;}\n        if(d < epsilon)\n        {\n\t\t\n            //Fixed color, no shading\n\t\t\t//color = vec4(i*0.1+0.1,0.5,0,1);\n            \n            //Shade this surface\n\t\t\tcolor = getColor(p);\n            break;\n        }\n\t\t//March forward by the distance to the closest surface to current point in space\n        t += d;\n    }\n\n    fragColor = color;\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir)\n{    \n    //Still eye\n\tvec3 eye = vec3(0, 0, -7);\n\t//eye.z = -1.0*sin(iTime);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = vec3(1, 0, 0);\n    //Epsilon for when we are close enough to a surface to decide the surface is right here\n    float epsilon = 0.1;\n    float maxDistance = 100000.0;\n\n\t//Normalized device coordinates\n\tvec2 ndcXY = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\t\n\t// aspect ratio\n\tfloat aspectRatio = iResolution.x / iResolution.y;\n\t\n\t// scaled XY which fits the aspect ratio\n\tvec2 uv = ndcXY * vec2( aspectRatio, 1.0 );\n\t//uv.y += (0.07 * sin(uv.x + iTime*4.0));\n\n\t\n    \n    //Variables needed for ray marching this pixel\n    float focalLength = 1.0;\n    vec3 forward = normalize(cross(right, up));\n    \n    vec3 planePos = right * uv.x + up * uv.y;\n\t\n    vec3 pImagePlane = eye + forward * focalLength + planePos;\n    //vec3 rayDirection = normalize(pImagePlane - eye);\n    vec3 rayDirection = -fragRayDir;\n\n\t// Sky color\n    vec4 color = vec4\n\t\t(\n\t\t\t0.30,\n\t\t\t0.30,\n\t\t\t0.30,\n\t\t\t1\n\t\t); \n\n    float t = 0.0;\n    const float maxSteps = 512.0;\n    for(float i = 0.0; i < maxSteps; ++i)\n    {\n        vec3 p = pImagePlane + rayDirection * t;\n\t\tfloat d = getDistance(p);\n\t\tif(d > maxDistance) {break;}\n        if(d < epsilon)\n        {\n\t\t\n            //Fixed color, no shading\n\t\t\t//color = vec4(i*0.1+0.1,0.5,0,1);\n            \n            //Shade this surface\n\t\t\tcolor = getColor(p);\n            break;\n        }\n\t\t//March forward by the distance to the closest surface to current point in space\n        t += d;\n    }\n\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtS3WG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 59], [61, 61, 88, 88, 164], [166, 166, 207, 207, 278], [280, 280, 311, 311, 511], [513, 513, 545, 545, 572], [574, 574, 608, 608, 1686], [1688, 1688, 1718, 1718, 3222], [3224, 3224, 3281, 3456, 4963], [4965, 4965, 5058, 5078, 6618]], "test": "valid"}
{"id": "XtSGWy", "name": "3d Sound Visualizer", "author": "tholzer", "description": "My 1st project of a 3d sound visualizer...\nUse mouse to move the camera.", "tags": ["3d", "sound", "raymarcher", "visualizer"], "likes": 5, "viewed": 506, "published": "Public", "date": "1431699342", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//---------------------------------------------------------\n// Shader:   3d visualizer.glsl                      5/2015\n//           a try to visualize sound data in 3d...    \n//---------------------------------------------------------\n\n//---------------------------------------------------------\n#define ANIMATE true\n#define ROTATE true\n#define flag true\n\nfloat time = 0.0;\nfloat aTime = 0.0;\nfloat sinTime = 0.0;\nvec2 uv;\nvec2 mouse;\n//---------------------------------------------------------\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n}\n\n//---------------------------------------------------------\nfloat length6( vec2 p )  // (x^6+y^6)^(1/6)\n{\n  p = p*p*p; \n  p = p*p;\n  return pow( p.x + p.y, 1.0/6.0 );\n}\n//---------------------------------------------------------\n//  primitives\n//---------------------------------------------------------\nfloat sdPlane( vec3 p )\n{\n  return p.y;\n}\n\nfloat sdWaveSphere(vec3 p, float radius, float waves, float waveSize) \n{\n  // deformation of radius\n  float d = waveSize*(radius*radius-(p.y*p.y));\n  radius += d * cos(atan(p.x,p.z) * float(waves));\n  return 0.5 * (length(p) - radius);\n}\n\n// h.xy = base rectangle size,  h.z = height\nfloat sdCylinder6( vec3 p, vec3 h )\n{\n  return max( length6(p.xz) - h.x, abs(p.y) - h.z );\n}\n\n//---------------------------------------------------------\n// distance operations\n//---------------------------------------------------------\n// Union: d1 + d2\nvec2 opU( vec2 d1, vec2 d2 )\n{\n  return (d1.x < d2.x) ? d1 : d2;\n}\n\n//---------------------------------------------------------\nvec2 map( in vec3 pos )\n{\n  vec2 res = vec2( sdPlane( pos), 1.0 );\n  float color = 50.0+ 40.0 * cos(0.2 * time);\n  \n  // get frequency and sound wave data \n  float soundFFT  = texture( iChannel0, vec2(0.5, 0.25) ).x; \n  float soundWave = texture( iChannel0, vec2(0.0, 0.95) ).y;\n  float fftHeight  = 0.02 + soundFFT;\n  float waveHeight = 0.02 + soundWave;\n    \n  vec3  r1 = rotateY (pos - vec3( 1.0, 0.0,  1.0), aTime*-0.5);\n  res = opU( res, vec2( sdCylinder6( r1, vec3(0.1, 0.05, fftHeight) ), color + 44.) );\n    \n        r1 = rotateY (pos - vec3(-1.0, 0.0, -1.0), aTime*-0.5);\n  res = opU( res, vec2( sdCylinder6( r1, vec3(0.1, 0.05, fftHeight) ), color + 44.) );\n\n        r1 = rotateY (pos - vec3(-1.0, 0.0,  1.0), aTime*0.5);\n  res = opU( res, vec2( sdCylinder6( r1, vec3(0.1, 0.05, waveHeight) ), color + 88.) );\n\n        r1 = rotateY (pos - vec3( 1.0, 0.0, -1.0), aTime*0.5);\n  res = opU( res, vec2( sdCylinder6( r1, vec3(0.1, 0.05, waveHeight) ), color + 88.) );\n    \n  res = opU( res, vec2( sdWaveSphere  ( pos - vec3(0.0, 0.1, 0.1), 0.8, 12., (soundFFT-0.4)*0.6), color ) );\n  return res;\n}\n//----------------------------------------------------------------------\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n  float tmin = 0.8;\n  float tmax = 8.0;\n\n  float precis = 0.0001;\n  float t = tmin;\n  float m = -1.0;\n  for ( int i=0; i<50; i++ )\n  {\n    vec2 res = map( ro+rd*t );\n    if ( (res.x < precis) || (t > tmax) ) break;\n    t += res.x;\n    m = res.y;\n  }\n  if ( t>tmax ) m=-1.0;\n  return vec2( t, m );\n}\n\n//----------------------------------------------------------------------\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n  float res = 1.0;\n  float t = mint;\n  for ( int i=0; i<14; i++ )\n  {\n    float h = -0.01+map( ro + rd*t ).x;\n    res = min( res, 8.0*h/t );\n    t += clamp( h, 0.02, 0.10 );\n    if ( h<0.001 || t>tmax ) break;\n  }\n  return clamp( res, 0.0, 1.0 );\n}\n\n//----------------------------------------------------------------------\nvec3 calcNormal( in vec3 pos )\n{\n  const vec3 eps = vec3( 0.0001, 0.0, 0.0 );\n  vec3 nor = vec3(\n    map(pos+eps.xyy).x - map(pos-eps.xyy).x, \n    map(pos+eps.yxy).x - map(pos-eps.yxy).x, \n    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n  return normalize(nor);\n}\n\n//----------------------------------------------------------------------\n// http://en.wikipedia.org/wiki/Ambient_occlusion\n// http://joomla.renderwiki.com/joomla/index.php?option=com_content&view=article&id=140&Itemid=157\nfloat calcAO( in vec3 pos, in vec3 nor )  // get ambient occlusion\n{\n  float occ = 0.0;\n  float sca = 1.0;\n  for ( int i=0; i<5; i++ )\n  {\n    float hr = 0.01 + 0.12*float(i) / 4.0;\n    vec3 aopos =  nor * hr + pos;\n    float dd = map(aopos).x;\n    occ += -(dd-hr)*sca;\n    sca *= 0.95;\n  }\n  return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n//----------------------------------------------------------------------\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n  aTime = ANIMATE ? time : 0.0;\n  sinTime = sin(aTime);\n  vec3 col = vec3(0.8, 0.9, 1.0);\n  vec2 res = castRay(ro, rd);\n  float t = res.x;\n  float m = res.y;\n  if ( m > -0.5 )\n  {\n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormal( pos );\n    vec3 ref = reflect( rd, nor );\n\n    // material        \n    col = 0.45 + 0.3*sin( vec3(0.05, 0.08, 0.10)*(m-1.0) );\n\n    if ( m<1.5 )\n    {\n      float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n      col = 0.4 + 0.1*f*vec3(1.0);\n    }\n\n    // lighting        \n    float occ = calcAO( pos, nor );\n    vec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n    float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float bac = clamp( dot( nor, normalize(vec3(-lig.x, 0.0, -lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y, 0.0, 1.0);\n    float dom = smoothstep( -0.1, 0.1, ref.y );\n    float fre = pow( clamp(1.0+dot(nor, rd), 0.0, 1.0), 2.0 );\n    float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ), 16.0);\n\n    dif *= softshadow( pos, lig, 0.02, 2.5 );\n    dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n    vec3 brdf = vec3(0.0);\n    brdf += 1.20*dif*vec3(1.00, 0.90, 0.60);\n    brdf += 1.20*spe*vec3(1.00, 0.90, 0.60)*dif;\n    brdf += 0.30*amb*vec3(0.50, 0.70, 1.00)*occ;\n    brdf += 0.40*dom*vec3(0.50, 0.70, 1.00)*occ;\n    brdf += 0.30*bac*vec3(0.25, 0.25, 0.25)*occ;\n    brdf += 0.40*fre*vec3(1.00, 1.00, 1.00)*occ;\n    brdf += 0.02;\n    col = col*brdf;\n    col = mix( col, vec3(0.8, 0.9, 1.0), 1.0-exp( -0.005*t*t ) );\n  }\n  return vec3( clamp(col, 0.0, 1.0) ); \n}\n//----------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  time = iTime;\n  mouse = iMouse.xy / iResolution.xy;\n  uv = 2.0*(gl_FragCoord.xy / iResolution.xy) - 1.0;\n  uv.x *= iResolution.x / iResolution.y;\n\n  // camera  \n  float angle = ROTATE ? 0.02*time : 0.0;\n  float rx = 0.5 + 3.0*cos(angle + 6.0*mouse.x);\n  float rz = 0.5 + 3.0*sin(angle + 6.0*mouse.x);\n  vec3 ro = vec3( rx, 1.0 + 5.0*mouse.y, rz );\n  vec3 ta = vec3( 0.0, 0.5, 0.0 );\n\n  // camera tx\n  vec3 cw = normalize( ta - ro );\n  vec3 cp = vec3( 0.0, 1.0, 0.0 );\n  vec3 cu = normalize( cross(cw, cp) );\n  vec3 cv = normalize( cross(cu, cw) );\n  vec3 rd = normalize( uv.x*cu + uv.y*cv + 3.0*cw );\n\n  // pixel color\n  vec3 col = render( ro, rd );\n  col = pow( col, vec3(0.4545) );\n  fragColor=vec4( col, 1.0 );\n}\n", "image_inputs": [{"id": "4dfGzn", "previewfilepath": "/media/ap/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtSGWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[437, 497, 528, 528, 635], [637, 697, 742, 742, 805], [806, 941, 966, 966, 982], [984, 984, 1056, 1083, 1221], [1223, 1268, 1305, 1305, 1360], [1362, 1523, 1553, 1553, 1589], [1591, 1651, 1676, 1676, 2752], [2753, 2826, 2866, 2866, 3165], [3167, 3240, 3314, 3314, 3563], [3565, 3638, 3670, 3670, 3900], [3902, 4124, 4192, 4192, 4459], [4460, 4533, 4572, 4572, 6124], [6125, 6198, 6255, 6255, 6973]], "test": "error"}
