{"id": "4d2Xzh", "name": "Fake Reflections", "author": "fizzer", "description": "I used neighbouring cell boundaries in a voronoi pattern to determine a maximum radius for circle centered at the current cell's point. Then I used complex inversion to create a fake reflection effect. No raytracing/raymarching required! Mouse zooms.", "tags": ["procedural", "voronoi", "spheres", "balls", "shiny", "reflective"], "likes": 18, "viewed": 1302, "published": "Public", "date": "1409003089", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_REFLECTION_DEPTH 4\n\nfloat time;\n\nfloat hash(float n)\n{\n    return fract(sin(n) * 43758.5453);\n}\n\nfloat noise(vec2 p)\n{\n    return hash(p.x + p.y * 57.0);\n}\n\nfloat smoothNoise2(vec2 p)\n{\n    vec2 p0 = floor(p + vec2(0.0, 0.0));\n    vec2 p1 = floor(p + vec2(1.0, 0.0));\n    vec2 p2 = floor(p + vec2(0.0, 1.0));\n    vec2 p3 = floor(p + vec2(1.0, 1.0));\n    vec2 pf = fract(p);\n    return mix( mix(noise(p0), noise(p1), pf.x), \n              \tmix(noise(p2), noise(p3), pf.x), pf.y);\n}\n\nvec2 cellPoint(vec2 cell)\n{\n    return vec2(noise(cell) + cos(time + cell.y) * 0.3,\n                noise(cell*0.3) + sin(time + cell.x) * 0.3);\n}\n\nvec4 circles(vec2 t, out float rad, out float idx)\n{\n    vec2 p = floor(t);\n    float nd = 1e10;\n    vec2 nc;\n    vec2 nq;\n\n    for(int y = -1; y < 2; y += 1)\n        for(int x = -1; x < 2; x += 1)\n        {\n            vec2 b = vec2(float(x), float(y));\n            vec2 q = b + p;\n            vec2 c = q + cellPoint(q);\n            vec2 r = c - t;\n\n            float d = dot(r, r);\n\n            if(d < nd)\n            {\n                nd = d;\n                nc = c;\n                nq = q;\n            }\n        }\n\n    rad = 1.0;\n    idx = nq.x + nq.y * 119.0;\n\n    for(int y = -1; y < 2; y += 1)\n        for(int x = -1; x < 2; x += 1)\n        {\n            if(x==0 && y==0)\n                continue;\n\n            vec2 b = vec2(float(x), float(y));\n            vec2 q = b + nq;\n            vec2 c = q + cellPoint(q);\n\n            rad = min(rad, distance(nc, c) * 0.5);\n        }\n\n    return vec4((t - nc) / rad, nc);\n}\n\nvec2 cmul(vec2 z0,vec2 z1)\n{\n    return vec2(z0.x * z1.x - z0.y * z1.y, z0.x * z1.y + z0.y * z1.x);\n}\n\nvec2 cdiv(vec2 z0,vec2 z1)\n{\n    vec2 z1conj = vec2(z1.x, -z1.y);\n    vec2 n = cmul(z0, z1conj);\n    vec2 d = cmul(z1, z1conj);\n    return n / d.x;\n}\n\nvec2 cinv(vec2 z)\n{\n    return cdiv(vec2(1.0,0.0),z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec2 tt = (fragCoord.xy / iResolution.y - vec2(0.5)) * (4.0 - 3.0 * iMouse.x / iResolution.x);\n    float b = 1.0;\n\n    for(int i = 0; i < (MAX_REFLECTION_DEPTH + 1);i += 1)\n    {\n        float rad, idx;\n        vec4 c = circles(tt, rad, idx);\n        float z = 1.0 - dot(c.xy, c.xy);\n\n        if(z<0.0)\n        {\n            float sh = mix(0.7, 1.0, smoothstep(0.0, 0.3, length(c.xy) - 0.95));\n            fragColor.rgb += sh * b * mix(0.1, 0.5, step(fract(tt.x + 0.5 * step(0.5, fract(tt.y))), 0.5));\n            break;\n        }\n\n        vec3 n = normalize(vec3(c.xy,z * 1.5));\n        vec3 diff = mix(vec3(0.0), mix(vec3(0.25, 1.0, 0.5), vec3(0.25, 0.25, 1.0), 0.5 + 0.5 * cos(idx * 12.0)),\n                      0.8 + 0.2 * (smoothNoise2(n.xy * 128.0) + 0.5 * smoothNoise2(n.xy * 256.0)));\n        float m = 1.0  -smoothstep(0.99, 1.0, length(c.xy));\n        fragColor.rgb += (vec3(0.1, 0.1, 0.2) * 0.1 + vec3(1.0, 1.0, 0.7) * diff * (0.4 + n.y * 0.4) +\n                             \t\tpow(0.5 + 0.5 * dot(n, normalize(vec3(1.0))), 8.0)) * b * m;\n        b *= pow(1.0 - n.z, 1.3) * 0.7;\n        tt = cinv(c.xy * vec2(1.0, -1.0)) * rad + c.zw;\n    }\n    \n    fragColor.rgb = sqrt(fragColor.rgb);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4d2Xzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 45, 66, 66, 107], [109, 109, 130, 130, 167], [169, 169, 197, 197, 492], [494, 494, 521, 521, 640], [642, 642, 694, 694, 1564], [1566, 1566, 1594, 1594, 1667], [1669, 1669, 1697, 1697, 1818], [1820, 1820, 1839, 1839, 1875], [1877, 1877, 1934, 1934, 3199]], "test": "ok"}
{"id": "4dBSzD", "name": "mengerishObject", "author": "rebb", "description": "Tests on mengersponge. ", "tags": ["raymarching"], "likes": 3, "viewed": 219, "published": "Public", "date": "1409344939", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define INF 7.0\n\nfloat marched = 0.0;\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n// camera rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nfloat sdSphere( vec3 p, float size)\n{\n  return length(p)-1.2;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdCross( in vec3 p )\n{\n  float da = sdBox(p.xyz,vec3(INF,1.0,1.0));\n  float db = sdBox(p.yzx,vec3(1.0,INF,1.0));\n  float dc = sdBox(p.zxy,vec3(1.0,1.0,INF));\n  return min(da,min(db,dc));\n}\n\n\n\n\t\nfloat map( vec3 p )\n{\n   vec3 pui;\n   pui.x = 1.0;\n   pui.y = 1.0;\n   pui.z = 1.0;\n   float d = sdBox(p,pui);\n   int m;\n   float s = 1.0;\n   for( int m=0; m<2;m++ )\n   {\n   \t  vec3 a;\n   \t  vec3 q;\n   \t  q=p*s;\n      a = mod( q, 1.0 )-0.5;\n     \n      s *= 3.0;\n      \n      vec3 r = .8 - 5.8*abs(a);\n   \n      float c = sdCross(r)/s;\n      d = max(d,-c);\n   }\n\n   return d;\n}\nfloat rm(vec3 origin, vec3 ray, float min_distance, float max_distance) {\n\tint i;\n\tfloat distance_marched = min_distance;\n\tfor (int i=0; i<200; i++) {\n\t\tvec3 indi = ray*distance_marched;\n\t\n\t\tvec3 moi = indi + origin;\n\t\t\n\t\tfloat step_distance = map(moi);\n\t\tif (abs(step_distance) < 0.0001) {\n\t\t\treturn distance_marched/(max_distance-min_distance);\n\t\t}\n\t\tdistance_marched += step_distance;\n\t\tmarched=distance_marched;\n\t\tif (distance_marched > max_distance) {\n\t\t\treturn -1.0;\n\t\t}\n\t}\n\treturn -1.0;\n}\n\tvec3 render(vec2 q) {\n\tvec3 dir;\n\tvec3 screen;\n\tvec3 ray;\n    vec2 moro = vec2 (iTime);\n    \n\tdir.x = 0.0;\n\tdir.y = 0.0;\n\tdir.z = -2.8;\n        \n\tmat3 rot = rotationXY(moro);\n\tscreen.x = q.x;\n\tscreen.y = q.y;\n\tscreen.z = -2.0;\n\tray = screen - dir;\n\t\n\t\n\tfloat s = rm(rot*dir, rot*ray, 1.0, 4.0);\n\t\n\tvec3 col;\n\t\n\tif (s == -1.0) {\n\t\t\t\tcol.x = 0.0;\n\t\t\t\tcol.y = 0.0;\n\t\t\t\tcol.z = 0.0;\n\n\t} else {\n\t\n\t\tcol = vec3(s-.8*.8+0.4*q.y *sin(q.x))*marched/1.76;\n\t\tcol.rg *= marched*.4;\n\t}\n\t\n\treturn col;\n\t\n\t}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = (2.0*fragCoord.xy - iResolution.xy)/iResolution.x;\n\t\n\tvec3 col = render(q);\n\tfragColor = vec4(col.xyz, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dBSzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 139, 170, 170, 326], [328, 328, 365, 365, 391], [393, 393, 424, 424, 520], [522, 522, 550, 550, 716], [722, 722, 743, 743, 1098], [1099, 1099, 1172, 1172, 1594], [1596, 1596, 1617, 1617, 2088], [2090, 2090, 2147, 2147, 2268]], "test": "ok"}
{"id": "4dfXWX", "name": "2D Rays", "author": "klacansky", "description": "A simple 2D line path tracer.", "tags": ["2d"], "likes": 1, "viewed": 114, "published": "Public", "date": "1407174442", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct Ray {\n    vec2 d;\n    vec2 o;\n};\n    \nstruct Segment {\n    vec4 a, b;\n};\n    \nstruct IsectData {\n    vec2 n;\n    float t;\n};\n    \nstruct Material {\n    vec4 K_d;\n    vec4 K_e;\n    vec4 K_s;\n};\n    \nfloat tmin = 0.0;\nvec2 seed;\nconst int samples = 100;\nconst int bounces = 3;\nconst float tau = 6.28318530718;\n\n\nfloat\nrand(vec2 co)\n{\n    float a = 12.9898;\n    float b = 78.233;\n    float c = 43758.5453;\n    float dt= dot(co.xy ,vec2(a,b));\n    float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nfloat\ncross2(const vec2 u, const vec2 v)\n{\n    return u.x*v.y - u.y*v.x;\n}\n\nbool\nintersect(const Ray r, const Segment segment, out IsectData isect)\n{\n    vec2 d = segment.b.xy - segment.a.xy;\n    vec2 o = segment.a.xy;\n\n    float c = cross2(d, r.d);\n    float s = cross2(r.o - o, r.d) / c;\n\n    if (c != 0.0 && 0.0 <= s && s <= 1.0) {\n        isect.n = normalize(c*vec2(-d.y, d.x));\n        isect.t = (o.x - r.o.x + s*d.x)/r.d.x;\n        return true;   \n    } else {\n        return false;\n    }\n}\n    \n    \n// TODO: segments lying exactly on pixels and being lights causes problems\nvoid\nmainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    seed = fragCoord.xy*iTime;\n\n\n    Material materials[6];\n    materials[0] = Material(vec4(0.0), vec4(5.0*abs(sin(iTime)), 2.0*abs(sin(iTime - 0.01)), 0.0, 1.0), vec4(0.0));\n    materials[1] = Material(vec4(0.0), vec4(0.0, 2.0, 2.0, 1.0), vec4(0.0));\n    materials[2] = Material(vec4(0.0), vec4(0.0), vec4(1.0));\n    materials[3] = Material(vec4(0.0), vec4(0.0), vec4(1.0));\n    materials[4] = Material(vec4(0.0), vec4(0.0), vec4(1.0));\n    materials[5] = Material(vec4(0.0), vec4(0.0), vec4(1.0));\n\n    Segment segments[6];\n    segments[0] = Segment(vec4(0.75*iResolution.x, 0.25*iResolution.x, 0.0, 1.0), vec4(0.625*iResolution.x, 0.12*iResolution.x, 0.0, 1.0));\n    segments[1] = Segment(vec4(0.06*iResolution.x, 0.2*iResolution.x, 0.0, 1.0), vec4(0.1*iResolution.x, 0.3*iResolution.x, 0.0, 1.0));\n    segments[2] = Segment(vec4(-0.06*iResolution.x, -0.06*iResolution.x, 0.0, 1.0), vec4(0.06*iResolution.x, -0.06*iResolution.x, 0.0, 1.0));\n    segments[3] = Segment(vec4(0.06*iResolution.x, -0.06*iResolution.x, 0.0, 1.0), vec4(0.06*iResolution.x, 0.06*iResolution.x, 0.0, 1.0));\n    segments[4] = Segment(vec4(0.06*iResolution.x, 0.06*iResolution.x, 0.0, 1.0), vec4(-0.06*iResolution.x, 0.06*iResolution.x, 0.0, 1.0));\n    segments[5] = Segment(vec4(-0.06*iResolution.x, 0.06*iResolution.x, 0.0, 1.0), vec4(-0.06*iResolution.x, -0.06*iResolution.x, 0.0, 1.0));\n\n    float cos_val = cos(iTime/4.0);\n    float sin_val = sin(iTime/4.0);\n    \n    mat4 m_model = mat4(\n        cos_val, sin_val, 0.0, 0.0,\n        -sin_val, cos_val, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        0.31*iResolution.x, 0.25*iResolution.x + 0.06*iResolution.x*cos_val, 0.0, 1.0);\n    segments[2].a = m_model*segments[2].a;\n    segments[2].b = m_model*segments[2].b;\n    segments[3].a = m_model*segments[3].a;\n    segments[3].b = m_model*segments[3].b;\n    segments[4].a = m_model*segments[4].a;\n    segments[4].b = m_model*segments[4].b;\n    segments[5].a = m_model*segments[5].a;\n    segments[5].b = m_model*segments[5].b;\n\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\n    vec4 color = vec4(0.0);\n    for (int i = 0; i < samples; i++) {\n        seed += 1.0;\n        // pixel ray\n        float random = rand(seed);\n        random = float(i)/float(samples) + random*1.0/float(samples);\n        Ray r = Ray(normalize(vec2(cos(tau*random), sin(tau*random))), fragCoord.xy);\n        vec4 L = vec4(0.0);\n        vec4 R = vec4(1.0);\n        \n     \n        vec4 R_s = vec4(0.0);\n        vec4 L_s = vec4(0.0);\n        IsectData isect;\n        IsectData isect_tmp;\n        \n        for (int j = 0; j < bounces; j++) {\n            float tmax = 1.0/0.0;\n\n            for (int k = 0; k < 6; k++) {\n                // get closest object\n                if (intersect(r, segments[k], isect_tmp) && isect_tmp.t >= tmin && isect_tmp.t <= tmax) {\n                    isect = isect_tmp;\n                    R_s = materials[k].K_s;\n                    L_s = materials[k].K_e;\n                    tmax = isect_tmp.t;\n                }\n            }\n\n            if (R_s != vec4(0.0)) {\n                r = Ray(reflect(r.d, isect.n), r.o + (tmax - 0.001)*r.d); // avoid self intersection\n            }\n\n            L += R*L_s;\n            R *= R_s;\n        }\n        color += 1.0/float(samples)*L;\n    }\n    \n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dfXWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[317, 317, 338, 338, 507], [509, 509, 551, 551, 583], [585, 585, 658, 658, 1005], [1016, 1091, 1146, 1146, 4437]], "test": "ok"}
{"id": "4djXzz", "name": "Topologica", "author": "otaviogood", "description": "At some point I stopped understanding exactly what makes this work, but it just kept getting cooler. Mostly, it's stepping through a low frequency noise function that ramps up to a 1/x pulse. But then there are lots of tweaks on top of that.", "tags": ["noise", "glow", "contour"], "likes": 169, "viewed": 12741, "published": "Public API", "date": "1408603987", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n-Otavio Good\n*/\n\n// various noise functions\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 47.0;\n    return fract(cos(f*3.333)*100003.9);\n}\nfloat Hash3d(vec3 uv)\n{\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\n    return fract(cos(f*3.333)*100003.9);\n}\nfloat mixP(float f0, float f1, float a)\n{\n    return mix(f0, f1, a*a*(3.0-2.0*a));\n}\nconst vec2 zeroOne = vec2(0.0, 1.0);\nfloat noise2d(vec2 uv)\n{\n    vec2 fr = fract(uv.xy);\n    vec2 fl = floor(uv.xy);\n    float h00 = Hash2d(fl);\n    float h10 = Hash2d(fl + zeroOne.yx);\n    float h01 = Hash2d(fl + zeroOne);\n    float h11 = Hash2d(fl + zeroOne.yy);\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\n}\nfloat noise2dT(vec2 uv)\n{\n    vec2 fr = fract(uv);\n    vec2 smoothv = fr*fr*(3.0-2.0*fr);\n    vec2 fl = floor(uv);\n    uv = smoothv + fl;\n    return textureLod(iChannel0, (uv + 0.5)/iChannelResolution[0].xy, 0.0).y;\t// use constant here instead?\n}\nfloat noise(vec3 uv)\n{\n    vec3 fr = fract(uv.xyz);\n    vec3 fl = floor(uv.xyz);\n    float h000 = Hash3d(fl);\n    float h100 = Hash3d(fl + zeroOne.yxx);\n    float h010 = Hash3d(fl + zeroOne.xyx);\n    float h110 = Hash3d(fl + zeroOne.yyx);\n    float h001 = Hash3d(fl + zeroOne.xxy);\n    float h101 = Hash3d(fl + zeroOne.yxy);\n    float h011 = Hash3d(fl + zeroOne.xyy);\n    float h111 = Hash3d(fl + zeroOne.yyy);\n    return mixP(\n        mixP(mixP(h000, h100, fr.x), mixP(h010, h110, fr.x), fr.y),\n        mixP(mixP(h001, h101, fr.x), mixP(h011, h111, fr.x), fr.y)\n        , fr.z);\n}\n\nfloat PI=3.14159265;\n\nvec3 saturate(vec3 a)\n{\n\treturn clamp(a, 0.0, 1.0);\n}\nvec2 saturate(vec2 a)\n{\n\treturn clamp(a, 0.0, 1.0);\n}\nfloat saturate(float a)\n{\n\treturn clamp(a, 0.0, 1.0);\n}\n\nfloat Density(vec3 p)\n{\n    //float ws = 0.06125*0.125;\n    //vec3 warp = vec3(noise(p*ws), noise(p*ws + 111.11), noise(p*ws + 7111.11));\n    float final = noise(p*0.06125);// + sin(iTime)*0.5-1.95 + warp.x*4.0;\n    float other = noise(p*0.06125 + 1234.567);\n    other -= 0.5;\n    final -= 0.5;\n    final = 0.1/(abs(final*final*other));\n    final += 0.5;\n    return final*0.0001;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// ---------------- First, set up the camera rays for ray marching ----------------\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;// - 0.5;\n\n\t// Camera up vector.\n\tvec3 camUp=vec3(0,1,0); // vuv\n\n\t// Camera lookat.\n\tvec3 camLookat=vec3(0,0.0,0);\t// vrp\n\n\tfloat mx=iMouse.x/iResolution.x*PI*2.0 + iTime * 0.01;\n\tfloat my=-iMouse.y/iResolution.y*10.0 + sin(iTime * 0.03)*0.2+0.2;//*PI/2.01;\n\tvec3 camPos=vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*(200.2); \t// prp\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);//vpn\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\t// u\n\tvec3 upNorm=cross(camVec, sideNorm);//v\n\tvec3 worldFacing=(camPos + camVec);//vcv\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;//scrCoord\n\tvec3 relVec = normalize(worldPix - camPos);//scp\n\n\t// --------------------------------------------------------------------------------\n\tfloat t = 0.0;\n\tfloat inc = 0.02;\n\tfloat maxDepth = 70.0;\n\tvec3 pos = vec3(0,0,0);\n    float density = 0.0;\n\t// ray marching time\n    for (int i = 0; i < 37; i++)\t// This is the count of how many times the ray actually marches.\n    {\n        if ((t > maxDepth)) break;\n        pos = camPos + relVec * t;\n        float temp = Density(pos);\n        //temp *= saturate(t-1.0);\n\n        inc = 1.9 + temp*0.05;\t// add temp because this makes it look extra crazy!\n        density += temp * inc;\n        t += inc;\n    }\n\n\t// --------------------------------------------------------------------------------\n\t// Now that we have done our ray marching, let's put some color on this.\n\tvec3 finalColor = vec3(0.01,0.1,1.0)* density*0.2;\n\n\t// output the final color with sqrt for \"gamma correction\"\n\tfragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4djXzz.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[562, 589, 612, 612, 689], [690, 690, 713, 713, 805], [806, 806, 847, 847, 890], [928, 928, 952, 952, 1225], [1226, 1226, 1251, 1251, 1473], [1474, 1474, 1496, 1496, 2055], [2079, 2079, 2102, 2102, 2132], [2133, 2133, 2156, 2156, 2186], [2187, 2187, 2212, 2212, 2242], [2244, 2244, 2267, 2381, 2625], [2627, 2627, 2684, 2769, 4448]], "test": "error"}
{"id": "4dlXWs", "name": "[SIG2014] Val's 2D Shader", "author": "val", "description": "This is the first shader I've ever written. Click and drag the mouse for sine wave magic.", "tags": ["sig2014"], "likes": 0, "viewed": 124, "published": "Public", "date": "1407869109", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Calculate the circle\nfloat calcCircle(vec2 p, vec2 center, float radius)\n{\n    // Calculate the distance to the center of the circle\n\tfloat d = length(center - p);\n    \n    // Calculate the border of the circle\n    d = smoothstep(radius, radius + 0.01, d);\n    return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Convert texture coordinates to [-1,1]\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;    // Fix the aspect ratio\n    \n    // Calculate the circle shape\n    //vec2  center = vec2(sin(iTime), cos(iTime)) * 0.1;\n\tvec2 center;\n    float radius;\n    //float d      = calcCircle(p, center, radius);\n    float d = 0.9;\n    float m = iMouse.x;\n    \n    if (m == 0.0) {\n        radius = 0.03;\n        for (int i = 2500; i>0; i--){\n        \tcenter.x = float(i) / 600.0 - 1.0;\n        \tcenter.y = sin(iTime - float(i) * 50.0 / 10.0) + 1.0;\n        \td *= calcCircle(p + 0.1, center - 1.0, radius);\n    \t}\n    }\n    else {\n        radius = 100.0 / iMouse.x / 40.0;\n        for (int i = 2500; i>0; i--){\n        \tcenter.x = float(i) / 600.0 - 1.0;\n        \tcenter.y = sin(iTime - float(i) * m / 10.0) + 1.0;\n        \td *= calcCircle(p + 0.1, center - 1.0, radius);\n    \t}  \n    }\n    \n\t// Calculate the color based on the circle shape\n    vec3 backgroundColor = vec3(p.x * -0.2, 0.05, 0.1);\n\tvec3 circleColor     = vec3(1.0, p.x, p.y);\n    vec3 col             = mix(circleColor, backgroundColor, d);\n    \n   \n    // Send the color to the screen\n\tfragColor = vec4(col, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dlXWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 24, 77, 135, 275], [278, 278, 335, 380, 1568]], "test": "ok"}
{"id": "4dSXR1", "name": "2d Shadow casting (Corner based)", "author": "Tharich", "description": "This is my first attempt implementing shadow casting for 2D objects.\nNotes: \nDoesn't handle thin objects well.\nJumping when shadow changes source corner.", "tags": ["2d", "lighting", "shadows"], "likes": 20, "viewed": 878, "published": "Public", "date": "1408673205", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Checks if spesific pixel is located within these bounds\nfloat pixelInCube(vec2 p, vec4 t){\n    return float(p.x > t.x-t.z*.5 && p.x < t.x+t.z*.5 && p.y > t.y-t.w*.5 && p.y < t.y+t.w*.5);\n}\n\n// Checks if spesific pixel is located within these bounds\nfloat pixelInCircle(vec2 p, vec3 t){\n    float hypT = pow(t.z*.5,2.)+pow(t.z*.5,2.);\n    float hypP = pow(p.x-t.x,2.)+pow(p.y-t.y,2.);\n    return float(hypP < hypT);\n}\n\n// Creates a cone for the light\nfloat shadow_isInBounds(vec2 p, vec3 l, vec4 t, float side){\n    \n    float ty = t.y - t.w*.5*(float(l.x > t.x)-.5)*2.*side;\n    float tx = t.x - t.z*.5*(float(l.y < t.y)-.5)*2.*side;\n    \n\tfloat rot = atan(ty-l.y,tx-l.x)+45.;\n    float lx = l.x + cos(rot)*l.z*side;\n    float ly = l.y + sin(rot)*l.z*side;\n    \n    float angle = (ly-ty)/(lx-tx);\n    float \tf = float(p.y > ly+((p.x-lx)*angle) && lx>tx);  \n    \t\tf += float(p.y < ly+((p.x-lx)*angle) && lx<tx);\n    \n\treturn f;\n}\n\n// Culls the \"front\" of the cone so that only the \"shadow\" is visible\nfloat shadow_cullLight(float f, vec2 p, vec3 l, vec4 t){\n\tfloat ty = t.y - t.w*.5*(float(l.y > t.y)-.5)*2.;\n    float tx = t.x - t.z*.5*(float(l.x > t.x)-.5)*2.;\n    \n    float c = 1.0;\n    \n    c*= float((p.y < ty && ty > l.y) || (p.y > ty && ty < l.y));\n    c*= float((p.x < tx && tx > l.x) || (p.x > tx && tx < l.x));\n    return clamp(f-c,0.0,1.0);\n}\n\n// Checks if spesific pixel is located within these bounds\nfloat pixelInShadow(vec2 p, vec3 l, vec4 t){\n\treturn shadow_cullLight(shadow_isInBounds(p, l, t, 1.)-shadow_isInBounds(p, l, t, -1.),p,l,t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 color = vec4(.3);\n\tvec4 cube;\n    vec4 T = vec4(fragCoord.xy,iResolution.xy);\n    vec3 light = vec3(iMouse.x+float(iMouse.x == 0.0)*T.z*.4,iMouse.y+float(iMouse.y == 0.0)*T.w*.5,20.0);\n    float time = iTime; // Controlls the rotationspeed of the circle\n    \n    color.rg += pixelInCircle(T.xy,light);\n    float circleScale = 1.01;\n    // Draw rotating circle\n    for(int i = 0; i < 6; i+=1){\n    \tcube = vec4(cos(float(i)*circleScale+time)*T.w*.3+T.z*.7,sin(float(i)*circleScale+time)*T.w*.3+T.w*.5,40.0,40.0);\n        color.r += pixelInCube(T.xy,cube);\n        color -= pixelInShadow(T.xy,light,cube)*.95;\n    }\n    \n    // Draw the corner objects\n    for(int i = 0; i < 4; i+=1){\n    \tcube = vec4(mod(floor(float(i)*.5),2.0)*-T.z*.8 + T.z*.9,mod(float(i),2.0)*-T.w*.8 + T.w*.9,40.0,40.0);\n        color.r += pixelInCube(T.xy,cube);\n        color -= pixelInShadow(T.xy,light,cube)*.95;\n    }\n    \n    // Draw the wall\n    cube = vec4(T.z*.2,0.0,10.0,T.w);\n    color.r += pixelInCube(T.xy,cube);\n    color -= pixelInShadow(T.xy,light,cube)*.95;\n    \n\tfragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dSXR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 59, 93, 93, 191], [193, 252, 288, 288, 419], [1358, 1417, 1461, 1461, 1559], [1561, 1561, 1618, 1618, 2700]], "test": "ok"}
{"id": "4dSXRD", "name": "Light, music v2", "author": "predatiti", "description": "More less noise.\nI hope my trick does not hurt too much a normal tracing path", "tags": ["pathtracing"], "likes": 5, "viewed": 427, "published": "Public", "date": "1409330549", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//use or not object raymarch in raytrace\n#if 1\n\tbool useRaymarch = false;\n\tconst float t = 16.0;\n#else\n\tbool useRaymarch = true;\n\tconst float t = 8.0;\n#endif\n\n#define pi acos(-1.0)\n#define pi2 pi/2.0\n\n//for transparency change, change first number in mref() to -1\nstruct Material\n{\n    vec4 color;\n    vec2 brdf;\n};\n\nstruct Sphere\n{\n\tvec4 center_radius;\n\tint idmaterial;\n};\n\nstruct Box\n{\n    vec3 min, max;\n   int idmaterial;\n};\n    \nstruct Cylinder \n{\n    vec3 c;\n    float r,h;\n    int idmaterial;\n};\n\nBox box0;\nSphere sfere[7];\nBox boxe[4];\nCylinder cylinder[3];\nMaterial material[6];\n\nvec3 light = vec3(0.0, 0.0, 0.0);\nvec3 pq, cub, lcub, nrm, crm;\nvec2 p,rv2;\nvec2 randv2;\nfloat side = 1.0;\nfloat time ;\nfloat f0, f1,f2,f3;\n\n\nvec2 rand2(){// implementation derived from one found at: lumina.sourceforge.net/Tutorials/Noise.html\n   randv2+=vec2(1.0,1.0);\n   return vec2(fract(sin(dot(randv2.xy ,vec2(12.9898,78.233))) * 43758.5453),\n      \t\t   fract(cos(dot(randv2.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nvec3 CosineWeightedSampleHemisphere ( vec3 normal, vec2 rnd )\n{\n   //rnd = vec2(rand(vec3(12.9898, 78.233, 151.7182), seed),rand(vec3(63.7264, 10.873, 623.6736), seed));\n   float phi = acos( sqrt(1.0 - rnd.x)) ;\n   float theta = 2.0 * 3.14 * rnd.y ;\n\n   vec3 sdir = cross(normal, (abs(normal.x) < 0.5001) ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 1.0, 0.0));\n   vec3 tdir = cross(normal, sdir);\n\n   return normalize(phi * cos(theta) * sdir + phi * sin(theta) * tdir + sqrt(1.0 - rnd.x) * normal);\n}\n\nvec3 cosPowDir(vec3  dir, float power) \n{//creates a biased random sample\n   vec2 r=rand2()*vec2(6.2831853,1.0);\n   vec3 sdir=cross(dir,((abs(dir.x)<0.5)?vec3(1.0,0.0,0.0):vec3(0.0,1.0,0.0)));\n   vec3 tdir=cross(dir,sdir); \n   r.y=pow(r.y,0.01/power);\n   float oneminus = sqrt(1.0-r.y*r.y);\n   return cos(r.x)*oneminus*sdir + sin(r.x)*oneminus*tdir + r.y*dir;\n}\n\n/*vec3 RandomPointOnLight(vec4 sfera)\n{\n   float r3 = rand2().x;\n   float r4 = rand2().y;\n   vec3 C = vec3(2.0 * cos(2.0 * 3.141592 * r3) * sqrt(r4 * (1.0 - r4)),\n                           2.0 * sin(2.0 * 3.141592 * r3) * sqrt(r4 * (1.0 - r4)),\n                           1.0 - 2.0 * r4 );    \n   return (C * sfera.w*1.05 + sfera.xyz );\n}*/\n\nvec2 intersectCube(vec3 origin, vec3 ray, Box cube) {      \n   vec3   tMin = (cube.min - origin) / ray;      \n   vec3   tMax = (cube.max - origin) / ray;      \n   vec3     t1 = min(tMin, tMax);      \n   vec3     t2 = max(tMin, tMax);\n   float tNear = max(max(t1.x, t1.y), t1.z);\n   float  tFar = min(min(t2.x, t2.y), t2.z);\n   return vec2(tNear, tFar);   \n}\n\nvec3 normalForCube(vec3 hit, Box cube)\n{  \n   if(hit.x < cube.min.x + 0.0001) return vec3(-1.0, 0.0, 0.0);   \n   else if(hit.x > cube.max.x - 0.0001) return vec3( 1.0, 0.0, 0.0);   \n   else if(hit.y < cube.min.y + 0.0001) return vec3(0.0, -1.0, 0.0);   \n   else if(hit.y > cube.max.y - 0.0001) return vec3(0.0, 1.0, 0.0);      \n   else if(hit.z < cube.min.z + 0.0001) return vec3(0.0, 0.0, -1.0);   \n   else return vec3(0.0, 0.0, 1.0);   \n}\n\nfloat intersectSphere(vec3 origin, vec3 ray, Sphere s) {   \n   vec3 toSphere = origin - s.center_radius.xyz;      \n   float sphereRadius = s.center_radius.w;\n   float a = dot(ray, ray);      \n   float b = 2.0 * dot(toSphere, ray);   \n   float c = dot(toSphere, toSphere) - sphereRadius*sphereRadius;   \n   float discriminant = b*b - 4.0*a*c;      \n   if(discriminant > 0.0) {      \n      float t = (-b - sqrt(discriminant)) / (2.0 * a);   \n      if(t > 0.0) return t;      \n   }   \n   return 10000.0;   \n}  \n\nvec3 normalForSphere(vec3 hit, Sphere s) {   \n   return (hit - s.center_radius.xyz+pq) / s.center_radius.w;   \n} \n\nfloat iCylinder(vec3 ro, vec3 rd, Cylinder cylinder)\n{\n\tvec3  rc = ro - cylinder.c;\n    float a = dot( rd.xz, rd.xz );\n\tfloat b = dot( rc.xz, rd.xz );\n\tfloat c = dot( rc.xz, rc.xz ) - cylinder.r*cylinder.r;//0.249;\n\tfloat d = b*b - a*c;\n\tif( d>=0.0 )\n\t{\n\t\t// cylinder\t\t\t\n\t\tfloat s = (-b - sqrt( d ))/a;\n        float hy = ro.y+s*rd.y;\n\t\tif( s>0.0 && hy<cylinder.h && hy>-cylinder.h )\n\t\t{\n\t\t\treturn s;\n\t\t}\n\t\t// cap\t\t\t\n\t\ts = (cylinder.h - ro.y)/rd.y;\n\t\tif( s>0.0 && (s*s*a+2.0*s*b+c)<0.0 )\n\t\t{\n\t\t\treturn s;\n\t\t}\n\t}\n    return 100000.0;\n}\n\nvec3 normalforCylinder(vec3 hit,Cylinder cylinder)\n{\n    vec3 nor;\n\tnor.xz = hit.xz - cylinder.c.xz;\n    nor.y = 0.0;\n    nor = nor/cylinder.r;\n    return nor;\n}\n\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\n/*vec3 doBump( in vec3 pos, in vec3 nor, in float signal, in float scale )\n{\n    // build frame   \n    vec3  s = dFdx( pos );\n    vec3  t = dFdy( pos );\n    vec3  u = cross( t, nor );\n    vec3  v = cross( nor, s );\n    float d = dot( s, u );\n\n    // compute bump   \n    float bs = dFdx( signal );\n    float bt = dFdy( signal );\n   \n    // offset normal   \n#if 1\n   return normalize( nor - scale*(bs*u + bt*v)/d );\n#else\n    // if you cannot ensure the frame is not null   \n   vec3 vSurfGrad = sign( d ) * ( bs * u + bt * v );\n    return normalize( abs(d)*nor - scale*vSurfGrad );\n#endif\n}*/\n\n//raymarch stuff\nfloat rmSphere( vec3 p, vec3 c, float r )\n{\n   return length(p-c) - r;\n}\n\nfloat rmCube(vec3 p,vec3 size)\n{\n   return max(max(abs(p.x) - size.x, abs(p.y) - size.y), abs(p.z) - size.z);\n}\n\nfloat CylinderXY( vec3 p, vec3 c ) {\n   return length(p.xy-c.xy)-c.z;\n}\n\nfloat CylinderXZ( vec3 p, vec3 c ) {\n   return length(p.xz-c.xy)-c.z;\n}\n\nfloat CylinderYZ( vec3 p, vec3 c ) {\n   return length(p.yz-c.xy)-c.z;\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.yz),p.x)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvoid oprep2(inout vec2 p, float l, float s, float k) \n{\n   float r=1./l;\n   float ofs=s+s/(r*2.0);\n   float a= mod( atan(p.x, p.y) + pi2*r*k, pi*r) -pi2*r;\n   p.xy=vec2(sin(a),cos(a))*length(p.xy) -ofs;\n   p.x+=ofs;\n}\n\nfloat scene(vec3 p)\n{\n   float f = 1000.0;\n   vec3 q = p-crm;\n//-------------------------------------\n   float box = 24.0;\n   oprep2(q.yz, box, 0.042, 0.0);\n\n   int ind = int((atan(p.z,p.y)/pi)*box)*1;//+ box-1;\n   if(ind<0) ind = -ind;\n   float h = texture(iChannel1, vec2( float(ind)/box, 0.3)).x * 0.2;\n   f = rmCube(q, vec3(0.025,0.0250,0.025+h));\n//-----------------------------------------   \n    vec3 tcol = texture(iChannel3, 1.0-(p.zy+1.0)/2.0).rgb;\n    h = tcol.y*0.01;\n    float f1 = CylinderYZ( p-crm, vec3(0.0, 0.0, 0.55) );\n    p.x += h;\n    float f2 = sdCylinder( p-crm, vec2(0.53, 0.01) );\n    \n   f = max(f,-f1);\n   f = min(f,f2);\n   return f;\n}\n\nfloat rmIntersect(vec3 ro, vec3 rd, float maxd)\n{\n   float d = 0.005;\n   side = sign(scene(ro+rd*d));//keep track of which side you are on\n\n   for( int i=0; i<100; i++)\n   {\n      float f = scene (ro + rd * d);\n      if(abs(f) < 0.001)\treturn d;     \n      d += f * side;\n      if(d > maxd) {return 10000.0; }\n   }\n    return d;\n}\n//end raymarch stuff\n\nvoid initscene()\n{\n   light = vec3(0.0, sin(time*0.75)*0.65,   sin(time*0.5)*1.65);\n\n    sfere[0].center_radius = vec4(-1.3, 0.0+f0, 0.0,    0.323);//rosu\n   \tsfere[1].center_radius = vec4(-1.3, 0.0+f1, 1.0,    0.323);//verde\n   \tsfere[2].center_radius = vec4(-1.3, 0.0+f2,-1.0,    0.323);//albastru\n   \tsfere[3].center_radius = vec4(-1.3, 0.0-f0, 0.0,    0.323);//rosu\n    sfere[4].center_radius = vec4(-1.3, 0.0-f1, 1.0,    0.323);//verde\n    sfere[5].center_radius = vec4(-1.3, 0.0-f2,-1.0,    0.323);//albastru\n    sfere[6].center_radius = vec4( light,               0.323);//light\n    \n    cylinder[0].c = vec3(-1.3,0.0,0.0);\n    cylinder[0].r = 0.1;\n    cylinder[0].h = 1.0;\n    \n    cylinder[1].c = vec3(-1.3,0.0,1.0);\n    cylinder[1].r = 0.1;\n    cylinder[1].h = 1.0;\n    \n    cylinder[2].c = vec3(-1.3,0.0,-1.0);\n    cylinder[2].r = 0.1;\n    cylinder[2].h = 1.0;\n\n   \tbox0.min = vec3(-2.0, -1.0, -2.0);\n   \tbox0.max = vec3( 2.0,  1.0,  2.0);\n\n   \tcub = vec3(1.8, -0.0,-1.25);\n   \tlcub = vec3(0.03, 0.81, 0.5);\n\n   \tboxe[0].min = cub - lcub;\n   \tboxe[0].max = cub + lcub;\n    \n    cub = vec3(1.8, -0.0, 1.25);\n   \tlcub = vec3(0.03, 0.81, 0.5);\n\n   \tboxe[1].min = cub - lcub;\n   \tboxe[1].max = cub + lcub;\n    \n    crm = vec3(1.8, 0.0, 0.0); //position of raymarch scene\n    cub = crm;\n   \tlcub = vec3(01.03, 0.8, 0.8);\n\n   \tboxe[3].min = cub - lcub;\n   \tboxe[3].max = cub + lcub;\n    \n    //vec4 mat[7];//vec3 color and float power of emisive\n\tmaterial[0].color = vec4(vec3(0.9 ,0.3 , 0.3), 0.0); //0 - rosu                    \n\tmaterial[1].color = vec4(vec3(0.3 ,0.9 , 0.3), 0.0); //1 - verde\n\tmaterial[2].color = vec4(vec3(0.3 ,0.3 , 0.9), 0.0); //2 - albastru\n\tmaterial[3].color = vec4(vec3(0.9 ,0.9 , 0.9), 0.0); //3 - cilinder\n    material[4].color = vec4(vec3(1.0 ,1.0 , 1.0), 0.0); //3 - box on wall\n    material[5].color = vec4(vec3(1.0 ,1.0 , 1.0), 1.0); //3 - light\n\n\t//reflect/refract(-1 <> 1) and difusse refl/refr (0 <> 1)\n\tmaterial[0].brdf = vec2(-1.0 ,0.0 ); //0 - rosu               \n\tmaterial[1].brdf = vec2(-1.0 ,0.0 ); //1 - verde\n\tmaterial[2].brdf = vec2(-1.0 ,0.0 ); //2 - albastru\n\tmaterial[3].brdf = vec2(-1.0 ,0.0 ); //3 - cilinder\n    material[4].brdf = vec2( 1.0 ,1000.0 ); //3 - box on wall\n    material[5].brdf = vec2( 0.0 ,0.0 ); //3 - light\n\n}\n\nvoid intersectscene(vec3 ro, vec3 rd, inout float t, inout int i)\n{\n   //pq = cos(rd*20.0*length(ro-vec3(-0.8,0.1,-0.7))+(ro-vec3(-0.8,0.1,-0.7))*50.+time*10.)*0.02;\n\n    float tSphere6 = intersectSphere(ro, rd, sfere[6]);\n    if(tSphere6 < t) { t = tSphere6;i=6;} \n        \n   float tSphere0 = intersectSphere(ro, rd, sfere[0]);\n   float tSphere1 = intersectSphere(ro, rd, sfere[1]);\n   float tSphere2 = intersectSphere(ro, rd, sfere[2]);\n   float tSphere3 = intersectSphere(ro, rd, sfere[3]);\n   float tSphere4 = intersectSphere(ro, rd, sfere[4]);\n   float tSphere5 = intersectSphere(ro, rd, sfere[5]);\n   \n   if(tSphere0 < t) { t = tSphere0;i=0;}\n   if(tSphere1 < t) { t = tSphere1;i=1;}   \n   if(tSphere2 < t) { t = tSphere2;i=2;}\n   if(tSphere3 < t) { t = tSphere3;i=3;} \n   if(tSphere4 < t) { t = tSphere4;i=4;} \n   if(tSphere5 < t) { t = tSphere5;i=5;} \n   \n\tfloat tcyl = iCylinder(ro, rd, cylinder[0]);\n    if(tcyl<t) {t = tcyl; i = 10;}\n    tcyl = iCylinder(ro, rd, cylinder[1]);\n    if(tcyl<t) {t = tcyl; i = 11;}\n    tcyl = iCylinder(ro, rd, cylinder[2]);\n    if(tcyl<t) {t = tcyl; i = 12;}\n    \n   \n    vec2 tbox = intersectCube(ro, rd, boxe[0]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 20;}\n    tbox = intersectCube(ro, rd, boxe[1]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 21;}\n\n  if(useRaymarch)\n  {\n     bool b = boxe[3].min.x <= ro.x && boxe[3].max.x >= ro.x &&\n              boxe[3].min.y <= ro.y && boxe[3].max.y >= ro.y &&\n              boxe[3].min.z <= ro.z && boxe[3].max.z >= ro.z;\n    tbox = intersectCube(ro, rd, boxe[3]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t || b)\n    {\n        tbox.x = 0.0;\n        float rm = rmIntersect(ro+rd*tbox.x, rd, tbox.y);\n        if(rm < t)\n        {\n            t = rm; i = 30; float e = 0.0001;\n            ro = ro + rd * t;\n            nrm = vec3(scene(ro + vec3(e, 0.0, 0.0)) - scene(ro - vec3(e, 0.0, 0.0)), \n                       scene(ro + vec3(0.0, e, 0.0)) - scene(ro - vec3(0.0, e, 0.0)), \n                       scene(ro + vec3(0.0, 0.0, e)) - scene(ro - vec3(0.0, 0.0, e)));\n            nrm = side * normalize(nrm);\n        }\n    } \n  }\n}\n\nfloat distanceToSegment( vec2 a, vec2 b, vec2 p )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\t\n\treturn length( pa - ba*h );\n}\n\nvoid ColorAndNormal(vec3 hit, inout vec4 mcol, inout vec3 normal, vec2 tRoom, inout vec2 mref, inout float t, const int id)\n{\n\tif(t == tRoom.y)\n\t{            \n        mref = vec2(0.0,0.0);\n        normal =-normalForCube(hit, box0);   \n        //if(hit.x < box0.min.x+0.001) \n           // mcol = vec4(0.9, 0.9, 0.9, 0.0);   \n       // else\n        if(hit.x > box0.max.x-0.001 && !useRaymarch) \n        {\n            float cc = -0.3;\n            mcol = vec4(0.9, 0.9, 0.9, 0.0);\n            float d1 = distanceToSegment( vec2(0.22,0.00+cc), vec2(-0.22,0.00+cc), hit.yz );//T\n            float d2 = distanceToSegment( vec2(0.22,0.12+cc), vec2(0.22,-0.12+cc), hit.yz );\n            \n            float d3 = distanceToSegment( vec2(0.05,0.25+cc), vec2(-0.22,0.25+cc), hit.yz );//i\n            float d4 = distanceToSegment( vec2(0.22,0.25+cc), vec2( 0.22,0.25+cc), hit.yz );\n            \n            float d5 = distanceToSegment( vec2(0.22,0.50+cc), vec2(-0.22,0.50+cc), hit.yz );//t\n            float d6 = distanceToSegment( vec2(0.12,0.58+cc), vec2( 0.12,0.42+cc), hit.yz );\n            \n            float d7 = distanceToSegment( vec2(0.05,0.75+cc), vec2(-0.22,0.75+cc), hit.yz );//i\n            float d8 = distanceToSegment( vec2(0.22,0.75+cc), vec2( 0.22,0.75+cc), hit.yz );\n            \n            float d = min(d1,min(d2,min(d3,d4)));//Ti\n                  d = min(d,min(d5,min(d6,min(d7,d8))));//ti\n            d = clamp(d, 0.0, 1.0);\n\t\t\tmcol.w = smoothstep( 0.24, 0.97,1.0- d*10.5 )*1.0;\n        }\n           // mcol = vec4(0.9, 0.9, 0.9, 0.0);//mcol = vec4(texture(iChannel0, 1.0-(hit.zy+1.5)/3.0).rgb, 0.0);    \n        if(hit.z > box0.max.z-0.001)    \n            mcol = vec4(0.2, 0.7, 0.2, 0.0);\n        else if(hit.z < box0.min.z+0.001)    \n           mcol = vec4(0.2, 0.2, 0.7, 0.0);//vec4(texture(iChannel0, 1.-(hit.xy+1.5)/3.0).rgb,0.0);  \n        else if(hit.y<box0.min.y+0.001)  //floor \n        {\n           vec3 tcol = texture(iChannel2, 1.0-(hit.xz-1.5)/3.0).rgb;\n            float rf = clamp(1.0-tcol.z*14.0, 0.0,1.0);\n            rf = mix(0.001,70.0,rf+0.003);\n            mref = vec2(1.0,rf);\n            normal.xz = normal.xz + (tcol.xz*2.0-1.0)*0.1;\n            //normal.yz = normal.yz + (tcol.yz)*0.55;\n            normal = normalize(normal);\n            mcol.xyz = mix(vec3(1.0),tcol,0.8);;\n        } \n\t\telse if(hit.y > box0.max.y-0.001)//ceiling\n        {\n            mcol.xyz = vec3(0.3,0.3,0.3);\n            float gr = 1.95; float rost = 0.04;\n            float v0 = dot(vec3(0, gr, gr),hit);\n            float v1 = dot(vec3(gr, gr, 0),hit);\n            v0 -= floor(v0);\n            v1 -= floor(v1);\n\t\t\tif(v0>rost && v1> rost)  mcol.xyz = vec3(0.99,0.99,0.99);\n        } \n\t}     \n\telse   \n\t{\n\t\t     if(id==0) {normal = normalForSphere(hit, sfere[0]); mcol = material[0].color;mref = material[0].brdf;}\n        else if(id==1) {normal = normalForSphere(hit, sfere[1]); mcol = material[1].color;mref = material[1].brdf;}\n        else if(id==2) {normal = normalForSphere(hit, sfere[2]); mcol = material[2].color;mref = material[2].brdf;}\n        else if(id==3) {normal = normalForSphere(hit, sfere[3]); mcol = material[0].color;mref = material[0].brdf;}\n    \telse if(id==4) {normal = normalForSphere(hit, sfere[4]); mcol = material[1].color;mref = material[1].brdf;}\n        else if(id==5) {normal = normalForSphere(hit, sfere[5]); mcol = material[2].color;mref = material[2].brdf;}\n        else if(id==6) {normal = normalForSphere(hit, sfere[6]); mcol = material[5].color;mref = material[5].brdf;}\n    \telse if(id==10) {normal = normalforCylinder(hit, cylinder[0]); mcol = material[3].color;mref = material[3].brdf;}\n        else if(id==11) {normal = normalforCylinder(hit, cylinder[1]); mcol = material[3].color;mref = material[3].brdf;}\n        else if(id==12) {normal = normalforCylinder(hit, cylinder[2]); mcol = material[3].color;mref = material[3].brdf;}\n\t\telse if(id==20) {normal = normalForCube(hit, boxe[0]); mcol = material[4].color;mref = material[4].brdf;}\n\t\telse if(id==21) {normal = normalForCube(hit, boxe[1]); mcol = material[4].color;mref = material[4].brdf;}\n        \n        //box on wall      \n        if(id==20 /*&& hit.x > boxe[0].max.x-0.001*/)\n        {\n            //dont work bunp :(((\n            //vec3 mate = texcube( iChannel0, 0.25*hit, normal ).xyz;\n            //normal = doBump( hit, normal, dot(mate,vec3(0.2)), 0.01*1.9 );\n            vec3 tcol = texture(iChannel0, 1.0-(hit.zy-vec2(sin(time*0.0),1.5))/2.0).rgb;\n            float rf = clamp(1.0-tcol.y*1.9,0.0,1.0);;\n            rf = (rf+0.1)*4.0;\n            mref.y = rf;\n            normal.yz = normal.yz + (tcol.yz*2.0-1.0)*0.3;\n            normal = normalize(normal);\n            //mcol.xyz = tcol; \n        }\n        \n        if(id==30)//raymarch object\n        {\n            normal = nrm;\n            vec3 tcol = texture(iChannel3, 1.0-(hit.zy+1.0)/2.0).rgb;\n            float rf = clamp(1.0-tcol.y*3.0,0.0,1.0);\n            rf = mix(0.1,10.0,rf+0.01);\n            mref = vec2(-1.0, rf);\n            mcol.xyz = mix(vec3(1.0),tcol,0.0);\n        }\n    }  \n}\n\nvec3 getColor(vec3 ro, vec3 rd)\n{\n    vec3 color = vec3(0.0);\n    vec3 col = vec3(1.0);\n    int id=-1;\n    \n    for(int i=0; i<6; i++)\n    {\n    \tfloat t = 10000.0; //seed++;\n\n   \t\tvec2 tRoom = intersectCube(ro, rd, box0);          \n   \t\tif(tRoom.x < tRoom.y)   t = tRoom.y; \n   \t\t//else return col;\n    \n    \tintersectscene(ro, rd, t, id);\n    \n    \tvec3 hit = ro + rd * t;        \n\t\tvec4 mcol = vec4(vec3(0.9),0.0);                 \n    \tvec3 normal; \n    \tvec2 mref = vec2(0);\n      \n    \tColorAndNormal(hit, mcol, normal, tRoom, mref, t, id);\n    \thit = hit + normal * 0.0001;\n        //vec3 nl = dot(rd,normal)>0.0? normal : -normal;\n         \n        vec2 rnd = rand2();\n        col *= mcol.xyz*1.0;\n        if(mcol.w>0.0) \n        {\n            float df=max(dot(rd,-normal),3.0)+0.3;\n            color += col*mcol.xyz*mcol.w * df ;\n            break;\n        }\n\n        if(mref.x==0.0)\n        {\n        \trd = CosineWeightedSampleHemisphere ( normal, rnd);      \n        \t\n        \tvec3 rl;       \n        \trl = sfere[6].center_radius.xyz;\n        \trl = normalize(rl-hit);\n        \tfloat p =5.0;// if(i==0) p=0.0;\n        \tp = max(0.0,dot(rd,rl))*p;\n        \trd = normalize(rd + rl*p);\n        \n        \tcol *= clamp(dot(normal,rd),0.0,1.0)/pi;\n        }       \n        else if(mref.x>0.0)\n        {\n            rd = reflect(rd,normal); //col *= 0.2;\n            //vec3 rnd = vec3(rand2(),rand2().x);           \n            //rd = normalize(rd + rnd*mref.y);\n            rd = cosPowDir(rd, mref.y);\n        }\n        else if(mref.x<0.0)\n        {\n            vec3 nrd = reflect(rd,normal); \n            vec3 ior=vec3(1.0,1.52,1.0/1.52);\n            vec3 refr=refract(rd,normal,(side>=0.0)?ior.z:ior.y);//calc the probabilty of reflecting instead\n            vec2 ca=vec2(dot(normal,rd),dot(normal,refr)),n=(side>=0.0)?ior.xy:ior.yx,nn=vec2(n.x,-n.y);\n            if(rand2().y>0.5*(pow(dot(nn,ca)/dot(n,ca),2.0)+pow(dot(nn,ca.yx)/dot(n,ca.yx),2.0)))\n               nrd=refr;\n            \n            rd = nrd;\n\n            col *= 1.2;\n        }\n        \n        ro = hit + rd * 0.001; //seed++;\n        \n        if(dot(col,col) < 0.001) break;\n    }\n    \n    \t//color = mcol.xyz;\n \treturn color;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n    float seed = iTime + iResolution.y *(p.x+1.0) + p.y;\n\t\n\trandv2=fract(cos((fragCoord.xy+fragCoord.yx*vec2(1000.0,1000.0))+vec2(iTime))*10000.0);\n\t\n    //move camera with mouse\n\tvec3 ro = vec3( 0.0+3.0*cos(8.0*mo.x), -0.3 + 1.5*(mo.y), 0.0 + 3.0*sin(8.0*mo.x) );\n\tvec3 ta = vec3( 0.0, 0.0, 0.0 );\n\t\n    //camera path\n    time = 0.2 * iTime;\n    vec3 path = vec3(sin(time)*0.3 + 0.0, 0.0, cos(time)*1.9 + 0.0);    \n    ro = path; ta = path + vec3(cos(time*0.5)*0.5+0.0, -0.01, sin(time*0.0)+0.1);\n    \n    //view of raymarch\n    //ro = vec3( -1.2,0.0, 0.0); ta = vec3(1.0,0.0,0.0);\n\t// camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n    \n    f0 = texture( iChannel1, vec2( 0.01, 0.0 ) ).x;\n    f1 = texture( iChannel1, vec2( 0.56, 0.0 ) ).x;\n    f2 = texture( iChannel1, vec2( 0.96, 0.0 ) ).x;\n    \n    f0 = pow(f0*1.0,5.0);\n    \n    initscene();\n\t\n\tvec3 col = vec3(0.0);\n\n    for(float i=0.0; i<t; i++)\n    {\n    \tcol += getColor( ro, rd );\n    }\n\n    col = pow( clamp( col/t, 0.0, 1.0 ), vec3(0.65) );\n    //col.g += tc;\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "XsXGRr", "previewfilepath": "/media/ap/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dSXRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[731, 731, 744, 832, 1008], [1010, 1010, 1073, 1179, 1500], [1502, 1502, 1543, 1575, 1863], [2208, 2208, 2261, 2261, 2565], [2567, 2567, 2607, 2607, 3007], [3009, 3009, 3065, 3065, 3514], [3518, 3518, 3560, 3560, 3630], [3633, 3633, 3687, 3687, 4167], [4169, 4169, 4221, 4221, 4330], [4332, 4332, 4385, 4385, 4529], [5123, 5140, 5183, 5183, 5212], [5214, 5214, 5246, 5246, 5325], [5327, 5327, 5363, 5363, 5398], [5400, 5400, 5436, 5436, 5471], [5473, 5473, 5509, 5509, 5544], [5546, 5546, 5582, 5582, 5681], [5683, 5683, 5738, 5738, 5900], [5902, 5902, 5923, 5923, 6564], [6566, 6566, 6615, 6615, 6896], [6919, 6919, 6937, 6937, 9200], [9202, 9202, 9269, 9367, 11377], [11379, 11379, 11430, 11430, 11552], [11554, 11554, 11679, 11679, 16625], [16627, 16627, 16660, 16660, 18833], [18835, 18835, 18892, 18892, 20272]], "test": "error"}
{"id": "4dsXWj", "name": "alertBall", "author": "Kilves", "description": "Wow, It got rly nice.", "tags": ["raymarching", "ball"], "likes": 0, "viewed": 168, "published": "Public", "date": "1406937823", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PLANE 1000.0\n#define PI 3.141593\n#define LOOPS 128.0\n#define LIGHTLOOPS 128.0\n#define L1 1\n#define L2 2\n#define SPEED 5.0\n\nstruct light \n{\n    vec3 pos;\n    vec3 color;\n    float intensity;\n    float dist;\n};\n    \nstruct ball\n{\n    vec3 pos;\n    vec3 color;\n    float r;\n};\n    \nstruct hitInfo\n{\n    vec4 info;\n    int type;\n};\n    \nlight light1 = light(vec3(0,0,-20.0), vec3(1,1,1), 200.0, 1.0);\nlight light2 = light(vec3(0,-20,40.0), vec3(1,1,1), 1.0, 5.0);\nball ball1 = ball(vec3(0,10,0), vec3(1,0,0), 10.0);\n    \nvec4 Rball(vec3 point, vec3 pos, float r, vec3 color) {\n    return vec4(1,1,0,distance(point, pos)-r);\n}\n\nvec4 Rplane(vec3 point) {\n    return vec4(0,sin(point.z)+sin(point.x),0, point.y+6.0);\n}\n\nfloat map(in vec3 p) {\n    float d = Rplane(p).w;\n    d = min(d, Rball(p,p - vec3(0.0, 0.25, 0.0), 0.25, vec3(1,0,0)).w);\n    return d;\n}\n\nvec3 calcNormal(vec3 p) {\n\tvec3 e = vec3(0.001, 0.0, 0.0);\n    vec3 nor = vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n    );\n    return normalize(nor);\n}\n\nhitInfo DE(vec3 point) { //distance estimation\n    //return vec4(1,0,0,distance(point, vec3(0,0,3))-20.0);\n    vec4 ball1d = Rball(point, ball1.pos, ball1.r, ball1.color);\n    vec4 plane1d = Rplane(point);\n    if(plane1d.w<ball1d.w){return hitInfo(plane1d, 1);}\n    return hitInfo(ball1d, 2);\n}\n\n\nvec3 getNormal(vec3 point, int type) { //calculating normal every step is expensive, so...\n    if(type == 1) {return vec3(0,1,0);}\n    if(type == 2) {return normalize(point - ball1.pos);}\n    return vec3(0,0,0);\n}\n\nlight closestLight(vec3 point) {\n    return light1;\n    if(distance(point, light1.pos)<distance(point, light2.pos)){return light1;}\n    return light2;\n}\n\nfloat traceToLight(vec3 pos, vec3 normal, light l) {\n    vec3 point = pos;\n    float dis = 0.1;\n    for(float i = 0.0; i<LIGHTLOOPS; ++i) {\n        point += normalize(l.pos-point)*dis;\n        hitInfo castInfo = DE(point);\n        dis = castInfo.info.w;\n        if(dis<0.0001){return 0.0;}\n    }\n    float light = (dot(normal,normalize(l.pos-pos)));\n    return clamp(light/(pow(distance(l.pos, pos), 2.0))*light1.intensity, 0.,1.);\n}\n\nvec3 createCast(vec3 origo, vec3 tgt, vec3 up, vec2 plane, float fov) {\n    vec3 az = normalize(tgt - origo);\n    vec3 ax = normalize(cross(az, up));\n    vec3 ay = cross(ax, az);\n    \n    vec3 point = tgt + fov * length(tgt-origo) * (plane.x * ax + plane.y * ay);\n    return normalize(point-origo);\n}\n\nvec4 casty(vec3 start, vec3 dir) {\n    vec3 point = start;\n    dir = normalize(dir);\n    for(float i = 0.0; i<LOOPS; ++i) {\n        hitInfo castInfo = DE(point);\n        float dis = castInfo.info.w;\n        if(dis<0.1) {\n            float light = traceToLight(point, getNormal(point, castInfo.type), closestLight(point));\n            return vec4(castInfo.info.xyz*light+castInfo.info.xyz*0.0,1);\n        }\n        point += dir*dis;\n    }\n    return vec4(0,0,0,0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 campos = vec3(sin(iTime)*50.,sin(iTime)*10.+10.,-50.*cos(iTime));\n    light1.pos = vec3(-5.,40., -10.);\n    light2.pos = vec3(20.*cos(iTime*SPEED-3.0), 30, 20);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 color = casty(campos, createCast(campos, vec3(0,0,0), vec3(0,1,0), (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y, 1.0));\n\tfragColor = color+vec4(0.,0.0,0.0,0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dsXWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[525, 525, 580, 580, 629], [631, 631, 656, 656, 719], [721, 721, 743, 743, 858], [860, 860, 885, 885, 1097], [1099, 1099, 1123, 1205, 1393], [1396, 1396, 1434, 1486, 1609], [1611, 1611, 1643, 1643, 1763], [1765, 1765, 1817, 1817, 2198], [2200, 2200, 2271, 2271, 2500], [2502, 2502, 2536, 2536, 2967], [2969, 2969, 3026, 3026, 3419]], "test": "error"}
{"id": "4dXSDX", "name": "Box twist", "author": "FMS_Cat", "description": "twist! twist!!\n( yes i'm doing ugly texturing )", "tags": ["3d"], "likes": 1, "viewed": 202, "published": "Public", "date": "1407158011", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nfloat t=iTime;\nfloat obj;\n\nfloat distFunc(vec3 p,vec2 uv){\n    float ts=sin(t);\n    float tc=cos(t);\n    float tws=sin(uv.y*sin(t)*6.);\n    float twc=cos(uv.y*sin(t)*6.);\n    p=mat3(twc,0,-tws,0,1,0,tws,0,twc)*p;\n    p=mat3(tc,-ts*tc,ts*ts,ts,tc*tc,-ts*tc,0,ts,tc)*p;\n    float distW=999.,distR=999.;\n    vec3 d;\n    for(float c=0.;c<8.;c++)\n    {\n\t    d=abs(p+vec3(mod(c,2.)*.2-.1,mod(floor(c/2.),2.)*.2-.1,mod(floor(c/4.),2.)*.2-.1))-vec3(.1,.1,.1);\n\t    if(mod(c+floor(c/2.)+floor(c/4.),2.)==0.)\n        {\n            distW=min(distW,min(max(d.x,max(d.y,d.z)),0.0)+length(max(d,0.0)));\n        }\n        else\n        {\n            distR=min(distR,min(max(d.x,max(d.y,d.z)),0.0)+length(max(d,0.0)));\n        }\n    }\n    if(distW<=distR){obj=1.;return distW;}\n    else{obj=0.;return distR;}\n}\n\nvec3 getNormal(vec3 p,vec2 uv){\n\tfloat d=0.0001;\n\treturn normalize(vec3(\n\t\tdistFunc(p+vec3(d,0.,0.),uv)-distFunc(p+vec3(-d,0.,0.),uv),\n\t\tdistFunc(p+vec3(0.,d,0.),uv)-distFunc(p+vec3(0.,-d,0.),uv),\n\t\tdistFunc(p+vec3(0.,0.,d),uv)-distFunc(p+vec3(0.,0.,-d),uv)\n\t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv=(fragCoord.xy*2.-iResolution.xy)/iResolution.x;\n\tvec3 camP=vec3(0.,0.,1.);\n\tvec3 camC=vec3(0.);\n\tvec3 camU=vec3(0.,1.,0.);\n\tvec3 camS=cross(normalize(camC-camP),camU);\n\tvec3 ray=normalize(camS*uv.x+camU*uv.y+(camC-camP));\n\t\n\tfloat dist=0.;\n\tfloat rayL=0.;\n\tvec3 rayP=camP;\n\tfor(int i=0;i<64;i++){\n\t\tdist=distFunc(rayP,uv);\n\t\trayL+=dist;\n\t\trayP=camP+ray*rayL;\n\t}\n\t\n\tif(abs(dist)<0.001){\n\t\tfloat frag=dot(-ray,getNormal(rayP,uv));\n\t\tfragColor=vec4(vec3(frag)*vec3(1.,obj,obj)*.5/rayL,1.);\n\t}else{\n\t\tfragColor=vec4(vec3(0.,0.,0.), 1.0);\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dXSDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 73, 104, 104, 839], [841, 841, 872, 872, 1105], [1107, 1107, 1163, 1163, 1711]], "test": "ok"}
{"id": "4dXXD2", "name": "Car Curves", "author": "TekF", "description": "Trying to imitate car body styling with some fairly cheap maths.", "tags": ["modelling"], "likes": 30, "viewed": 4440, "published": "Public API", "date": "1407433084", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Hazel Quantock 2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// scene parameters\n//const vec3 CarColour = vec3(1);\nconst vec3 CarColour = vec3(.0,.2,.02); // British racing green\n//const vec3 CarColour = vec3(.7,0,0);\n//const vec3 CarColour = vec3(0,.05,.5);\n//const vec3 CarColour = vec3(.03);\n\n//#define MORPH // for lols\n\n// consts\nconst float tau = 6.2831853;\nconst float phi = 1.61803398875;\n\nvec2 glFragCoord;\n\n// slower, smoother min max\nfloat Max( float a, float b, float smoothing )\n{\n    // circular smoothing (this works WAY better than I expected!)\n    if ( a > -smoothing && b > -smoothing )\n    {\n        a += smoothing; b += smoothing;\n        return sqrt(a*a+b*b)-smoothing;\n    }\n    else\n    \treturn max(a,b);\n}\n\nfloat Min( float a, float b, float smoothing )\n{\n    return -Max(-a,-b, smoothing);\n}\n\n\nfloat DistanceField( vec3 p )\n{\n\tp.x = abs(p.x) + abs(p.y+p.z*.03)*.2;\n    \n    float t = 0.0;\n    #ifdef MORPH\n    \tt = iTime;\n    #endif\n\t\n\t// car-like curves...\n    \n    // sides\n\tfloat f = Max(\n\t\t\tp.x -.7 +.1*sin(p.z*1.0+0.0 + t),\n\t\t\tp.y + p.z*.05 -.21 +.08*sin(p.z*3.2+1.8 + t),\n        \t.05\n\t\t);\n\n\n    // mid section\n\tf = Min( f, Max(\n\t\t\tp.x + p.z*.05 -.45 +.08*sin(p.z*1.5+5.0 + t),\n\t\t\tp.y + p.z*.115 -.4 +.1*sin(p.z*2.3+4.0 + t),\n        \t.15\n\t\t), .0 );\n\t\n\treturn Max(Max(Max( -.2-p.y, -p.z-1.5, .01 ), f, .01 ), p.z-1.5, .15 ) * .8;\n}\n\n\nvec3 Sky( vec3 ray )\n{\n\t//return mix( vec3(.8), vec3(0), exp2(-(1.0/max(ray.y,.01))*vec3(.4,.6,1.0)) );\n\tfloat depth = 100.0;\n\tfloat a = atan(ray.x,ray.z);\n\tif ( ray.y < sin(a*11.0+cos(a*3.0))*.03 ) depth = 8.0;\n\tif ( ray.y < sin(a*7.0+cos(a*5.0)+.1)*.06 ) depth = 2.0;\n\tif ( ray.y < sin(a*3.0+cos(a*2.0)+.1)*.05 ) depth = .3;\n\tvec3 col = mix( vec3(1.1), vec3(0.2,0.15,0), exp2(-min(1.0/max(ray.y,.01),depth)*vec3(.4,.6,1.0)) );\n\treturn col;\n}\n\n\nvec3 Shade( vec3 pos, vec3 ray, vec3 normal, vec3 lightDir, vec3 lightCol, float shadowMask, float distance )\n{\n\tvec3 albedo = CarColour;\n\n\n\t// direct light\n\tfloat ndotl = max(.0,dot(normal,lightDir));\n\tfloat lightCut = smoothstep(.0,.1,ndotl);//pow(ndotl,2.0);\n\tvec3 light = lightCol*shadowMask*ndotl;\n\n\n\t// ambient light\n\tvec3 ambient = mix( vec3(.2,.27,.4), vec3(.1,.07,.05), (-normal.y*.5+.5) ); // ambient\n\n\t// ambient occlusion, based on my DF Lighting: https://www.shadertoy.com/view/XdBGW3\n\tfloat aoRange = distance/20.0;\n\tfloat occlusion = max( 0.0, 1.0 - DistanceField( pos + normal*aoRange )/aoRange ); // can be > 1.0\n\tocclusion = exp2( -2.0*pow(occlusion,2.0) ); // tweak the curve\n\tambient *= occlusion;\n\n\n\t// subsurface scattering\n\tfloat transmissionRange = 0.1;\n\tfloat transmission = DistanceField( pos + lightDir*transmissionRange )/transmissionRange;\n\tvec3 sslight = lightCol * smoothstep(0.0,1.0,transmission);\n\tvec3 subsurface = vec3(1,.8,.5) * sslight;\n\n\n\t// specular\n\tfloat specularMap = 1.0;\n\tfloat specPower = exp2(mix(5.0,16.0,specularMap));\n\t\n\tvec3 h = normalize(lightDir-ray);\n\tvec3 specular = lightCol*shadowMask*pow(max(.0,dot(normal,h))*lightCut, specPower)*specPower/32.0;\n\t\n\n\t// reflections\n\tvec3 rray = reflect(ray,normal);\n\tvec3 reflection = Sky( rray );\n\t\n\t// reflection occlusion, adjust the divisor for the gradient we expect\n\tfloat specOcclusion = max( 0.0, 1.0 - DistanceField( pos + rray*aoRange )/(aoRange*max(.01,dot(rray,normal))) ); // can be > 1.0\n\tspecOcclusion = exp2( -2.0*pow(specOcclusion,2.0) ); // tweak the curve\n\t\n\t// prevent sparkles in heavily occluded areas\n\tspecOcclusion *= occlusion;\n\n\treflection *= specOcclusion; // could fire an additional ray for more accurate results\n\t\n\t// fresnel\n\tfloat fresnel = pow( 1.0+dot(normal,ray), 5.0 );\n\tfresnel = mix( mix( .0, .05, specularMap ), mix( .4, .8, specularMap ), fresnel );\n\t\n\tvec3 result = vec3(0);\n\n\t\n\t// Combine all shading stages\n\t// comment these out to toggle various parts of the effect\n\tlight += ambient;\n\n//\tlight = mix( light, subsurface, .5 );\n\t\n\tresult = light*albedo;\n\n\tresult = mix( result, reflection, fresnel );\n\t\n\tresult += specular;\n\n\treturn result;\n}\n\n\n\n\n// Isosurface Renderer\n#ifdef FAST\nconst int traceLimit=40;\nconst float traceSize=.005;\n#else\nconst int traceLimit=60;\nconst float traceSize=.002;\n#endif\t\n\nfloat Trace( vec3 pos, vec3 ray, float traceStart, float traceEnd )\n{\n\tfloat t = traceStart;\n\tfloat h;\n\tfor( int i=0; i < traceLimit; i++ )\n\t{\n\t\th = DistanceField( pos+t*ray );\n\t\tif ( h < traceSize || t > traceEnd )\n\t\t\tbreak;\n\t\tt = t+h;\n\t}\n\t\n\tif ( t > traceEnd )//|| h > .001 )\n\t\treturn 0.0;\n\t\n\treturn t;\n}\n\nfloat TraceMin( vec3 pos, vec3 ray, float traceStart, float traceEnd )\n{\n    float Min = traceEnd;\n    float MinStep = .0; // make it trace faster/further by using positive vals here\n\tfloat t = traceStart;\n\tfloat h;\n\tfor( int i=0; i < traceLimit; i++ )\n\t{\n\t\th = DistanceField( pos+t*ray );\n\t\tif ( h < .001 || t > traceEnd )\n\t\t\tbreak;\n\t\tMin = min(h,Min);\n\t\tt = t+max(h,MinStep);\n\t}\n\t\n\tif ( h < .001 )\n\t\treturn 0.0;\n\t\n\treturn Min;\n}\n\nvec3 Normal( vec3 pos, vec3 ray, float t )\n{\n\t// in theory we should be able to get a good gradient using just 4 points\n\n\tfloat pitch = .5 * t / iResolution.x;\n#ifdef FAST\n\t// don't sample smaller than the interpolation errors in Noise()\n\tpitch = max( pitch, .005 );\n#endif\n\t\n\tvec2 d = vec2(-1,1) * pitch;\n\n\tvec3 p0 = pos+d.xxx; // tetrahedral offsets\n\tvec3 p1 = pos+d.xyy;\n\tvec3 p2 = pos+d.yxy;\n\tvec3 p3 = pos+d.yyx;\n\t\n\tfloat f0 = DistanceField(p0);\n\tfloat f1 = DistanceField(p1);\n\tfloat f2 = DistanceField(p2);\n\tfloat f3 = DistanceField(p3);\n\t\n\tvec3 grad = p0*f0+p1*f1+p2*f2+p3*f3 - pos*(f0+f1+f2+f3);\n\t\n\t// prevent normals pointing away from camera (caused by precision errors)\n\tfloat gdr = dot ( grad, ray );\n\tgrad -= max(.0,gdr)*ray;\n\t\n\treturn normalize(grad);\n}\n\n\n// Camera\n\nvec3 Ray( float zoom )\n{\n\treturn vec3( glFragCoord.xy-iResolution.xy*.5, iResolution.x*zoom );\n}\n\nvec3 Rotate( inout vec3 v, vec2 a )\n{\n\tvec4 cs = vec4( cos(a.x), sin(a.x), cos(a.y), sin(a.y) );\n\t\n\tv.yz = v.yz*cs.x+v.zy*cs.y*vec2(-1,1);\n\tv.xz = v.xz*cs.z+v.zx*cs.w*vec2(1,-1);\n\t\n\tvec3 p;\n\tp.xz = vec2( -cs.w, -cs.z )*cs.x;\n\tp.y = cs.y;\n\t\n\treturn p;\n}\n\n\n// Camera Effects\n\nvoid BarrelDistortion( inout vec3 ray, float degree )\n{\n\t// would love to get some disperson on this, but that means more rays\n\tray.z /= degree;\n\tray.z = ( ray.z*ray.z - dot(ray.xy,ray.xy) ); // fisheye\n\tray.z = degree*sqrt(ray.z);\n}\n\nvec3 LensFlare( vec3 ray, vec3 lightCol, vec3 light, float lightVisible, float sky )\n{\n\tvec2 dirtuv = glFragCoord.xy/iResolution.x;\n\t\n\tfloat dirt = 1.0-texture( iChannel1, dirtuv ).r;\n\t\n\tfloat l = (dot(light,ray)*.5+.5);\n\t\n\treturn (\n\t\t\t((pow(l,30.0)+.05)*dirt*.1\n\t\t\t+ 1.0*pow(l,200.0))*lightVisible + sky*1.0*pow(l,5000.0)\n\t\t   )*lightCol\n\t\t   + 5.0*pow(smoothstep(.9999,1.0,l),20.0) * lightVisible * normalize(lightCol);\n}\n\n\nfloat SmoothMax( float a, float b, float smoothing )\n{\n\treturn a-sqrt(smoothing*smoothing+pow(max(.0,a-b),2.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    glFragCoord = fragCoord;\n    \n\tvec3 ray = Ray(1.8);\n\t\n\tBarrelDistortion( ray, .2 );\n\t\n\tray = normalize(ray);\n\tvec3 localRay = ray;\n\n\tvec2 mouse = vec2(-.1,iTime*.01);\n\tif ( iMouse.z > .0 )\n\t\tmouse = vec2(.5)-iMouse.yx/iResolution.yx;\n\t\t\n\tfloat T = iTime*.0;\n\tvec3 pos = 3.0*Rotate( ray, vec2(.2,1.5-T)+vec2(-1.0,-7.0)*mouse );\n\t//pos += vec3(0,.3,0) + T*vec3(0,0,-1);\n    pos.y += .06-pos.z*.02; // tail is higher\n    pos.z += pos.z*.2; // centre on the end of the car we're looking at\n    pos.x += .3;//sign(pos.x)*.2*smoothstep(.0,.5,abs(pos.x)); // off-centre framing\n\t\n\tvec3 col;\n\n//\tvec3 lightDir = normalize(vec3(3,1,-2));\n    vec3 lightDir;\n    lightDir.y = 1.0;\n    lightDir.z = 4.0*cos(iTime/10.0);\n    lightDir.x = 4.0*sin(iTime/10.0);\n    lightDir = normalize(lightDir);\n\t\n\tvec3 lightCol = vec3(1.2,1,.8)*1.0;\n\t\n\t// can adjust these according to the scene, even per-pixel to a bounding volume\n\tfloat near = .05;\n\tfloat far = 40.0;\n\t\n\tfloat t = Trace( pos, ray, near, far );\n\tif ( t > .0 )\n\t{\n\t\tvec3 p = pos + ray*t;\n\t\t\n\t\t// shadow test\n\t\tfloat s = 0.0;\n\t\ts = TraceMin( p, lightDir, .05, far );\n\t\t\n\t\tvec3 n = Normal(p, ray, t);\n\t\tcol = Shade( p, ray, n, lightDir, lightCol,\n\t\t\t\t\t//(s>.0)?0.0:1.0,\n                    smoothstep( .0, .01, s ),\n                    t );\n\t\t\n\t\t// fog\n\t\tfloat f = 200.0;\n\t\tcol = mix( vec3(.8), col, exp2(-t*vec3(.4,.6,1.0)/f) );\n\t}\n\telse\n\t{\n\t\tcol = Sky( ray );\n\t}\n\t\n\t// lens flare\n\tfloat s = TraceMin( pos, lightDir, .5, 40.0 );\n\tcol += LensFlare( ray, lightCol, lightDir, smoothstep(.01,.1,s), step(t,.0) );\n\t\n\t// vignetting:\n\tcol *= smoothstep( .7, .0, dot(localRay.xy,localRay.xy) );\n\t\n\t// compress bright colours, ( because bloom vanishes in vignette )\n\tvec3 c = (col-1.0);\n\tc = sqrt(c*c+.05); // soft abs\n\tcol = mix(col,1.0-c,.48); // .5 = never saturate, .0 = linear\n\t\n\t// grain\n\tvec2 grainuv = fragCoord.xy + floor(iTime*60.0)*vec2(37,41);\n\tvec2 filmNoise = textureLod( iChannel0, .5*grainuv/iChannelResolution[0].xy, 0.0 ).rb;\n\tcol *= mix( vec3(1), mix(vec3(1,.5,0),vec3(0,.5,1),filmNoise.x), .1*filmNoise.y );\n\t\n\t// compress bright colours\n\tfloat l = max(col.x,max(col.y,col.z));//dot(col,normalize(vec3(2,4,1)));\n\tl = max(l,.01); // prevent div by zero, darker colours will have no curve\n\tfloat l2 = SmoothMax(l,1.0,.01);\n\tcol *= l2/l;\n\t\n\tfragColor = vec4(pow(col,vec3(1.0/2.2)),1);\n}\n", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dXXD2.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[467, 495, 543, 610, 779], [781, 781, 829, 829, 866], [869, 869, 900, 900, 1412], [1415, 1415, 1437, 1518, 1858], [1861, 1861, 1972, 1972, 4037], [4198, 4198, 4267, 4267, 4504], [4506, 4506, 4578, 4578, 4936], [4938, 4938, 4982, 5057, 5705], [5719, 5719, 5743, 5743, 5815], [5817, 5817, 5854, 5854, 6069], [6091, 6091, 6146, 6217, 6324], [6326, 6326, 6412, 6412, 6749], [6752, 6752, 6806, 6806, 6866], [6868, 6868, 6925, 6925, 9262]], "test": "error"}
{"id": "4s2XR1", "name": "Light & Music", "author": "predatiti", "description": "test light, music & minimal path tracing", "tags": ["pathtracing"], "likes": 8, "viewed": 736, "published": "Public", "date": "1409242136", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//use or not object raymarch in raytrace\n#if 0\n\tbool useRaymarch = false;\n\tconst float t = 64.0;\n#else\n\tbool useRaymarch = true;\n\tconst float t = 8.0;\n#endif\n\n#define pi acos(-1.0)\n#define pi2 pi/2.0\n\n//for transparency change, change first number in mref() to -1\nstruct Material\n{\n    vec4 color;\n    vec2 brdf;\n};\n\nstruct Sphere\n{\n\tvec4 center_radius;\n\tint idmaterial;\n};\n\nstruct Box\n{\n    vec3 min, max;\n   int idmaterial;\n};\n    \nstruct Cylinder \n{\n    vec3 c;\n    float r,h;\n    int idmaterial;\n};\n\nBox box0;\nSphere sfere[6];\nBox boxe[4];\nCylinder cylinder[3];\nMaterial material[5];\n\nvec3 light = vec3(0.0, 0.0, 0.0);\nvec3 pq, cub, lcub, nrm, crm;\nvec2 p,rv2;\nvec2 randv2;\nfloat side = 1.0;\nfloat time ;//= iTime;\nfloat f0, f1,f2,f3;\n\n\nvec2 rand2(){// implementation derived from one found at: lumina.sourceforge.net/Tutorials/Noise.html\n   randv2+=vec2(1.0,1.0);\n   return vec2(fract(sin(dot(randv2.xy ,vec2(12.9898,78.233))) * 43758.5453),\n      \t\t   fract(cos(dot(randv2.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nvec3 CosineWeightedSampleHemisphere ( vec3 normal, vec2 rnd )\n{\n   //rnd = vec2(rand(vec3(12.9898, 78.233, 151.7182), seed),rand(vec3(63.7264, 10.873, 623.6736), seed));\n   float phi = acos( sqrt(1.0 - rnd.x)) ;\n   float theta = 2.0 * 3.14 * rnd.y ;\n\n   vec3 sdir = cross(normal, (abs(normal.x) < 0.5001) ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 1.0, 0.0));\n   vec3 tdir = cross(normal, sdir);\n\n   return normalize(phi * cos(theta) * sdir + phi * sin(theta) * tdir + sqrt(1.0 - rnd.x) * normal);\n}\n\nvec3 cosPowDir(vec3  dir, float power) \n{//creates a biased random sample\n   vec2 r=rand2()*vec2(6.2831853,1.0);\n   vec3 sdir=cross(dir,((abs(dir.x)<0.5)?vec3(1.0,0.0,0.0):vec3(0.0,1.0,0.0)));\n   vec3 tdir=cross(dir,sdir); \n   r.y=pow(r.y,0.01/power);\n   float oneminus = sqrt(1.0-r.y*r.y);\n   return cos(r.x)*oneminus*sdir + sin(r.x)*oneminus*tdir + r.y*dir;\n}\n\n/*vec3 RandomPointOnLight(vec4 sfera)\n{\n   float r3 = rand2().x;\n   float r4 = rand2().y;\n   vec3 C = vec3(2.0 * cos(2.0 * 3.141592 * r3) * sqrt(r4 * (1.0 - r4)),\n                           2.0 * sin(2.0 * 3.141592 * r3) * sqrt(r4 * (1.0 - r4)),\n                           1.0 - 2.0 * r4 );    \n   return (C * sfera.w*1.05 + sfera.xyz );\n}*/\n\nvec2 intersectCube(vec3 origin, vec3 ray, Box cube) {      \n   vec3   tMin = (cube.min - origin) / ray;      \n   vec3   tMax = (cube.max - origin) / ray;      \n   vec3     t1 = min(tMin, tMax);      \n   vec3     t2 = max(tMin, tMax);\n   float tNear = max(max(t1.x, t1.y), t1.z);\n   float  tFar = min(min(t2.x, t2.y), t2.z);\n   return vec2(tNear, tFar);   \n}\n\nvec3 normalForCube(vec3 hit, Box cube)\n{  \n   if(hit.x < cube.min.x + 0.0001) return vec3(-1.0, 0.0, 0.0);   \n   else if(hit.x > cube.max.x - 0.0001) return vec3( 1.0, 0.0, 0.0);   \n   else if(hit.y < cube.min.y + 0.0001) return vec3(0.0, -1.0, 0.0);   \n   else if(hit.y > cube.max.y - 0.0001) return vec3(0.0, 1.0, 0.0);      \n   else if(hit.z < cube.min.z + 0.0001) return vec3(0.0, 0.0, -1.0);   \n   else return vec3(0.0, 0.0, 1.0);   \n}\n\nfloat intersectSphere(vec3 origin, vec3 ray, Sphere s) {   \n   vec3 toSphere = origin - s.center_radius.xyz;      \n   float sphereRadius = s.center_radius.w;\n   float a = dot(ray, ray);      \n   float b = 2.0 * dot(toSphere, ray);   \n   float c = dot(toSphere, toSphere) - sphereRadius*sphereRadius;   \n   float discriminant = b*b - 4.0*a*c;      \n   if(discriminant > 0.0) {      \n      float t = (-b - sqrt(discriminant)) / (2.0 * a);   \n      if(t > 0.0) return t;      \n   }   \n   return 10000.0;   \n}  \n\nvec3 normalForSphere(vec3 hit, Sphere s) {   \n   return (hit - s.center_radius.xyz+pq) / s.center_radius.w;   \n} \n\nfloat iCylinder(vec3 ro, vec3 rd, Cylinder cylinder)\n{\n\tvec3  rc = ro - cylinder.c;\n    float a = dot( rd.xz, rd.xz );\n\tfloat b = dot( rc.xz, rd.xz );\n\tfloat c = dot( rc.xz, rc.xz ) - cylinder.r*cylinder.r;//0.249;\n\tfloat d = b*b - a*c;\n\tif( d>=0.0 )\n\t{\n\t\t// cylinder\t\t\t\n\t\tfloat s = (-b - sqrt( d ))/a;\n        float hy = ro.y+s*rd.y;\n\t\tif( s>0.0 && hy<cylinder.h && hy>-cylinder.h )\n\t\t{\n\t\t\treturn s;\n\t\t}\n\t\t// cap\t\t\t\n\t\ts = (cylinder.h - ro.y)/rd.y;\n\t\tif( s>0.0 && (s*s*a+2.0*s*b+c)<0.0 )\n\t\t{\n\t\t\treturn s;\n\t\t}\n\t}\n    return 100000.0;\n}\n\nvec3 normalforCylinder(vec3 hit,Cylinder cylinder)\n{\n    vec3 nor;\n\tnor.xz = hit.xz - cylinder.c.xz;\n    nor.y = 0.0;\n    nor = nor/cylinder.r;\n    return nor;\n}\n\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\n/*vec3 doBump( in vec3 pos, in vec3 nor, in float signal, in float scale )\n{\n    // build frame   \n    vec3  s = dFdx( pos );\n    vec3  t = dFdy( pos );\n    vec3  u = cross( t, nor );\n    vec3  v = cross( nor, s );\n    float d = dot( s, u );\n\n    // compute bump   \n    float bs = dFdx( signal );\n    float bt = dFdy( signal );\n   \n    // offset normal   \n#if 1\n   return normalize( nor - scale*(bs*u + bt*v)/d );\n#else\n    // if you cannot ensure the frame is not null   \n   vec3 vSurfGrad = sign( d ) * ( bs * u + bt * v );\n    return normalize( abs(d)*nor - scale*vSurfGrad );\n#endif\n}*/\n\n//raymarch stuff\nfloat rmSphere( vec3 p, vec3 c, float r )\n{\n   return length(p-c) - r;\n}\n\nfloat rmCube(vec3 p,vec3 size)\n{\n   return max(max(abs(p.x) - size.x, abs(p.y) - size.y), abs(p.z) - size.z);\n}\n\nfloat CylinderXY( vec3 p, vec3 c ) {\n   return length(p.xy-c.xy)-c.z;\n}\n\nfloat CylinderXZ( vec3 p, vec3 c ) {\n   return length(p.xz-c.xy)-c.z;\n}\n\nfloat CylinderYZ( vec3 p, vec3 c ) {\n   return length(p.yz-c.xy)-c.z;\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.yz),p.x)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvoid oprep2(inout vec2 p, float l, float s, float k) \n{\n   float r=1./l;\n   float ofs=s+s/(r*2.0);\n   float a= mod( atan(p.x, p.y) + pi2*r*k, pi*r) -pi2*r;\n   p.xy=vec2(sin(a),cos(a))*length(p.xy) -ofs;\n   p.x+=ofs;\n}\n\nfloat scene(vec3 p)\n{\n   float f = 1000.0;\n   vec3 q = p-crm;\n//-------------------------------------\n   float box = 24.0;\n   oprep2(q.yz, box, 0.042, 0.0);\n\n   int ind = int((atan(p.z,p.y)/pi)*box)*1;//+ box-1;\n   if(ind<0) ind = -ind;\n   float h = texture(iChannel1, vec2( float(ind)/box, 0.3)).x * 0.2;\n   f = rmCube(q, vec3(0.025,0.0250,0.025+h));\n//-----------------------------------------   \n    vec3 tcol = texture(iChannel3, 1.0-(p.zy+1.0)/2.0).rgb;\n    h = tcol.y*0.01;\n    float f1 = CylinderYZ( p-crm, vec3(0.0, 0.0, 0.55) );\n    p.x += h;\n    float f2 = sdCylinder( p-crm, vec2(0.53, 0.01) );\n    \n   f = max(f,-f1);\n   f = min(f,f2);\n   return f;\n}\n\nfloat rmIntersect(vec3 ro, vec3 rd, float maxd)\n{\n   float d = 0.005;\n   side = sign(scene(ro+rd*d));//keep track of which side you are on\n\n   for( int i=0; i<60; i++)\n   {\n      float f = scene (ro + rd * d);\n      if(abs(f) < 0.001)\treturn d;     \n      d += f * side;\n      if(d > maxd) {return 10000.0; }\n   }\n    return d;\n}\n//end raymarch stuff\n\nvoid initscene()\n{\n   //light = vec3(sin(time)*0.0-0.0, +0.1, cos(time)*0.0+0.4);\n\n    sfere[0].center_radius = vec4( 0.0, 0.0+f0, 0.0,    0.323);//rosu\n   \tsfere[1].center_radius = vec4( 0.0, 0.0+f1, 1.0,    0.323);//verde\n   \tsfere[2].center_radius = vec4( 0.0, 0.0+f2,-1.0,    0.323);//albastru\n   \tsfere[3].center_radius = vec4( 0.0, 0.0-f0, 0.0,    0.323);//rosu\n    sfere[4].center_radius = vec4( 0.0, 0.0-f1, 1.0,    0.323);//verde\n    sfere[5].center_radius = vec4( 0.0, 0.0-f2,-1.0,    0.323);//albastru\n    \n    cylinder[0].c = vec3(0.0,0.0,0.0);\n    cylinder[0].r = 0.1;\n    cylinder[0].h = 1.0;\n    \n    cylinder[1].c = vec3(0.0,0.0,1.0);\n    cylinder[1].r = 0.1;\n    cylinder[1].h = 1.0;\n    \n    cylinder[2].c = vec3(0.0,0.0,-1.0);\n    cylinder[2].r = 0.1;\n    cylinder[2].h = 1.0;\n\n   \tbox0.min = vec3(-2.0, -1.0, -2.0);\n   \tbox0.max = vec3( 2.0,  1.0,  2.0);\n\n   \tcub = vec3(-1.8, -0.0,0.0);\n   \tlcub = vec3(0.03, 0.5, 0.81);\n\n   \tboxe[0].min = cub - lcub;\n   \tboxe[0].max = cub + lcub;\n    \n    crm = vec3(1.8, 0.0,0.0); //position of raymarch scene\n    cub = crm;\n   \tlcub = vec3(01.03, 0.8, 0.8);\n\n   \tboxe[1].min = cub - lcub;\n   \tboxe[1].max = cub + lcub;\n    \n    //vec4 mat[7];//vec3 color and float power of emisive\n\tmaterial[0].color = vec4(vec3(0.9 ,0.3 , 0.3), 1.0); //0 - rosu                    \n\tmaterial[1].color = vec4(vec3(0.3 ,0.9 , 0.3), 1.0); //1 - verde\n\tmaterial[2].color = vec4(vec3(0.3 ,0.3 , 0.9), 1.0); //2 - albastru\n\tmaterial[3].color = vec4(vec3(0.9 ,0.9 , 0.9), 0.0); //3 - light\n    material[4].color = vec4(vec3(1.0 ,1.0 , 1.0), 0.0); //3 - light\n\n\t//reflect/refract(-1 <> 1) and difusse refl/refr (0 <> 1)\n\tmaterial[0].brdf = vec2( 0.0 ,0.0 ); //0 - rosu               \n\tmaterial[1].brdf = vec2( 0.0 ,0.0 ); //1 - verde\n\tmaterial[2].brdf = vec2( 0.0 ,0.0 ); //2 - albastru\n\tmaterial[3].brdf = vec2( 0.0 ,0.0 ); //3 - diff\n    material[4].brdf = vec2( 0.0 ,0.0 ); //3 - light\n\n}\n\nvoid intersectscene(vec3 ro, vec3 rd, inout float t, inout int i)\n{\n   //pq = cos(rd*20.0*length(ro-vec3(-0.8,0.1,-0.7))+(ro-vec3(-0.8,0.1,-0.7))*50.+time*10.)*0.02;\n\n   float tSphere0 = intersectSphere(ro, rd, sfere[0]);\n   float tSphere1 = intersectSphere(ro, rd, sfere[1]);\n   float tSphere2 = intersectSphere(ro, rd, sfere[2]);\n   float tSphere3 = intersectSphere(ro, rd, sfere[3]);\n   float tSphere4 = intersectSphere(ro, rd, sfere[4]);\n   float tSphere5 = intersectSphere(ro, rd, sfere[5]);\n\n   if(tSphere0 < t) { t = tSphere0;i=0;}\n   if(tSphere1 < t) { t = tSphere1;i=1;}   \n   if(tSphere2 < t) { t = tSphere2;i=2;}\n   if(tSphere3 < t) { t = tSphere3;i=3;} \n   if(tSphere4 < t) { t = tSphere4;i=4;} \n   if(tSphere5 < t) { t = tSphere5;i=5;} \n\n\tfloat tcyl = iCylinder(ro, rd, cylinder[0]);\n    if(tcyl<t) {t = tcyl; i = 10;}\n    tcyl = iCylinder(ro, rd, cylinder[1]);\n    if(tcyl<t) {t = tcyl; i = 11;}\n    tcyl = iCylinder(ro, rd, cylinder[2]);\n    if(tcyl<t) {t = tcyl; i = 12;}\n    \n   \n    vec2 tbox = intersectCube(ro, rd, boxe[0]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 20;} \n\n  if(useRaymarch)\n  {\n     bool b = boxe[1].min.x <= ro.x && boxe[1].max.x >= ro.x &&\n              boxe[1].min.y <= ro.y && boxe[1].max.y >= ro.y &&\n              boxe[1].min.z <= ro.z && boxe[1].max.z >= ro.z;\n      tbox = vec2(0.0);\n      \n    if(!b)\n    {\n    \ttbox = intersectCube(ro, rd, boxe[1]); \n        if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) b = true;\n    }\n    //if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t || b)\n    if(b)\n    {\n        tbox.x = 0.0;\n        float rm = rmIntersect(ro+rd*tbox.x, rd, tbox.y);\n        if(rm < t)\n        {\n            t = rm; i = 30; float e = 0.0001;\n            ro = ro + rd * t;\n            nrm = vec3(scene(ro + vec3(e, 0.0, 0.0)) - scene(ro - vec3(e, 0.0, 0.0)), \n                       scene(ro + vec3(0.0, e, 0.0)) - scene(ro - vec3(0.0, e, 0.0)), \n                       scene(ro + vec3(0.0, 0.0, e)) - scene(ro - vec3(0.0, 0.0, e)));\n            nrm = side * normalize(nrm);\n        }\n    } \n  }\n}\n\nfloat distanceToSegment( vec2 a, vec2 b, vec2 p )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\t\n\treturn length( pa - ba*h );\n}\n\nvoid ColorAndNormal(vec3 hit, inout vec4 mcol, inout vec3 normal, vec2 tRoom, inout vec2 mref, inout float t, const int id)\n{\n\tif(t == tRoom.y)\n\t{            \n        mref = vec2(0.0,0.0);\n        normal =-normalForCube(hit, box0);   \n        //if(hit.x < box0.min.x+0.001) \n           // mcol = vec4(0.9, 0.9, 0.9, 0.0);   \n       // else\n        if(hit.x > box0.max.x-0.001 ) \n        {\n            float cc = -0.3;\n            mcol = vec4(0.9, 0.9, 0.9, 0.0);\n            float d1 = distanceToSegment( vec2(0.22,0.00+cc), vec2(-0.22,0.00+cc), hit.yz );//T\n            float d2 = distanceToSegment( vec2(0.22,0.12+cc), vec2(0.22,-0.12+cc), hit.yz );\n            \n            float d3 = distanceToSegment( vec2(0.05,0.25+cc), vec2(-0.22,0.25+cc), hit.yz );//i\n            float d4 = distanceToSegment( vec2(0.22,0.25+cc), vec2( 0.22,0.25+cc), hit.yz );\n            \n            float d5 = distanceToSegment( vec2(0.22,0.50+cc), vec2(-0.22,0.50+cc), hit.yz );//t\n            float d6 = distanceToSegment( vec2(0.12,0.58+cc), vec2( 0.12,0.42+cc), hit.yz );\n            \n            float d7 = distanceToSegment( vec2(0.05,0.75+cc), vec2(-0.22,0.75+cc), hit.yz );//i\n            float d8 = distanceToSegment( vec2(0.22,0.75+cc), vec2( 0.22,0.75+cc), hit.yz );\n            \n            float d = min(d1,min(d2,min(d3,d4)));//Ti\n                  d = min(d,min(d5,min(d6,min(d7,d8))));//ti\n            d = clamp(d, 0.0, 1.0);\n\t\t\tmcol.w = smoothstep( 0.24, 0.97,1.0- d*10.5 )*1.0;\n        }\n           // mcol = vec4(0.9, 0.9, 0.9, 0.0);//mcol = vec4(texture(iChannel0, 1.0-(hit.zy+1.5)/3.0).rgb, 0.0);    \n        if(hit.z > box0.max.z-0.001)    \n            mcol = vec4(0.2, 0.7, 0.2, 0.0);\n        else if(hit.z < box0.min.z+0.001)    \n           mcol = vec4(0.2, 0.2, 0.7, 0.0);//vec4(texture(iChannel0, 1.-(hit.xy+1.5)/3.0).rgb,0.0);  \n        else if(hit.y<box0.min.y+0.001)  //floor \n        {\n            vec3 tcol = texture(iChannel2, 1.0-(hit.xz-1.5)/3.0).rgb;\n            float rf = clamp(1.0-tcol.z*14.0, 0.0,1.0);\n            rf = mix(0.01,70.0,rf+0.003);\n            mref = vec2(1.0,rf);\n            normal.xz = normal.xz + (tcol.xz*2.0-1.0)*0.1;\n            //normal.yz = normal.yz + (tcol.yz)*0.55;\n            normal = normalize(normal);\n            mcol.xyz = mix(vec3(1.0),tcol,0.5);;\n        } \n\t\telse if(hit.y > box0.max.y-0.001)//ceiling\n        {\n            mcol.xyz = vec3(0.3,0.3,0.3); mref= vec2(0.0,0.0);\n            float gr = 1.95; float rost = 0.04;\n            float v0 = dot(vec3(0, gr, gr),hit);\n            float v1 = dot(vec3(gr, gr, 0),hit);\n            v0 -= floor(v0);\n            v1 -= floor(v1);\n            if(v0>rost && v1> rost)  {mcol.xyz = vec3(0.99,0.99,0.99); mref = vec2(1.0,0.01);}\n        } \n\t}     \n\telse   \n\t{\n\t\t     if(id==0) {normal = normalForSphere(hit, sfere[0]); mcol = material[0].color;mref = material[0].brdf;}\n        else if(id==1) {normal = normalForSphere(hit, sfere[1]); mcol = material[1].color;mref = material[1].brdf;}\n        else if(id==2) {normal = normalForSphere(hit, sfere[2]); mcol = material[2].color;mref = material[2].brdf;}\n        else if(id==3) {normal = normalForSphere(hit, sfere[3]); mcol = material[0].color;mref = material[0].brdf;}\n    \telse if(id==4) {normal = normalForSphere(hit, sfere[4]); mcol = material[1].color;mref = material[1].brdf;}\n        else if(id==5) {normal = normalForSphere(hit, sfere[5]); mcol = material[2].color;mref = material[2].brdf;}\n    \telse if(id==10) {normal = normalforCylinder(hit, cylinder[0]); mcol = material[3].color;mref = material[3].brdf;}\n        else if(id==11) {normal = normalforCylinder(hit, cylinder[1]); mcol = material[3].color;mref = material[3].brdf;}\n        else if(id==12) {normal = normalforCylinder(hit, cylinder[2]); mcol = material[3].color;mref = material[3].brdf;}\n\t\telse if(id==20) {normal = normalForCube(hit, boxe[0]); mcol = material[4].color;mref = material[4].brdf;}\n//box on wall      \n        if(id==20 /*&& hit.x > boxe[0].max.x-0.001*/)\n        {\n            //dont work bunp :(((\n            //vec3 mate = texcube( iChannel0, 0.25*hit, normal ).xyz;\n            //normal = doBump( hit, normal, dot(mate,vec3(0.2)), 0.01*1.9 );\n            vec3 tcol = texture(iChannel0, 1.0-(hit.zy-vec2(sin(time*0.0),1.5))/2.0).rgb;\n            float rf = clamp(1.0-tcol.y*1.9,0.0,1.0);;\n            rf = (rf+0.1)*4.0;\n            mref = vec2( 1.0, rf);\n            normal.yz = normal.yz + (tcol.yz*2.0-1.0)*0.3;\n            normal = normalize(normal);\n            //mcol.xyz = tcol; \n        }\n        \n        if(id==30)//raymarch object\n        {\n            normal = nrm;\n            vec3 tcol = texture(iChannel3, 1.0-(hit.zy+1.0)/2.0).rgb;\n            float rf = clamp(1.0-tcol.y*3.0,0.0,1.0);\n            rf = mix(0.1,10.0,rf+0.01);\n            mref = vec2( 1.0, rf);\n            mcol.xyz = mix(vec3(1.0),tcol,0.0);\n        }\n    }  \n}\n\nvec3 getColor(vec3 ro, vec3 rd)\n{\n    vec3 color = vec3(0.0);\n    vec3 col = vec3(1.0);\n    int id=-1;\n    \n    for(int i=0; i<6; i++)\n    {\n    \tfloat t = 10000.0; //seed++;\n\n   \t\tvec2 tRoom = intersectCube(ro, rd, box0);          \n   \t\tif(tRoom.x < tRoom.y)   t = tRoom.y; \n   \t\t//else return col;\n    \n    \tintersectscene(ro, rd, t, id);\n    \n    \tvec3 hit = ro + rd * t;        \n\t\tvec4 mcol = vec4(vec3(0.9),0.0);                 \n    \tvec3 normal; \n    \tvec2 mref = vec2(0);\n      \n    \tColorAndNormal(hit, mcol, normal, tRoom, mref, t, id);\n    \thit = hit - normal * 0.0001;\n        vec3 nl = dot(rd,normal)>0.0? normal : -normal;\n         \n        col *= mcol.xyz*1.0;\n        if(mcol.w>0.0) \n        {\n            float df=max(dot(rd,-normal),0.0)*3.0+0.0;\n            color += col*mcol.xyz*mcol.w *df;\n            break;\n        }\n\n        if(mref.x==0.0)\n        {\n        \trd = CosineWeightedSampleHemisphere ( normal, rand2());      \n        \tfloat rnd = rand2().x;\n        \tvec3 rl;       \n        \trl = sfere[0].center_radius.xyz;\n        \tif(rnd>0.16) rl = sfere[1].center_radius.xyz;\n        \tif(rnd>0.32) rl = sfere[2].center_radius.xyz;\n            if(rnd>0.48) rl = sfere[3].center_radius.xyz;\n            if(rnd>0.64) rl = sfere[4].center_radius.xyz;\n            if(rnd>0.80) rl = sfere[5].center_radius.xyz;\n        \trl = normalize(rl-hit);\n        \tfloat p = 5.0; //if(i==0) p=3.0;\n        \tp = max(0.0,dot(rd,rl))*p;\n        \trd = normalize(rd + rl*p);\n        \n        \tcol *= clamp(dot(normal,rd),0.0,1.0)/pi;\n        }       \n        else if(mref.x>0.0)\n        {\n            rd = reflect(rd,normal); col *= 1.0;\n            vec3 rnd = vec3(rand2(),rand2().x);           \n            //rd = normalize(rd + rnd*mref.y);\n            rd = cosPowDir(rd, mref.y);\n        }\n        else if(mref.x<0.0)\n        {\n            vec3 nrd = reflect(rd,normal); \n            vec3 ior=vec3(1.0,1.52,1.0/1.52);\n            vec3 refr=refract(rd,normal,(side>=0.0)?ior.z:ior.y);//calc the probabilty of reflecting instead\n            vec2 ca=vec2(dot(normal,rd),dot(normal,refr)),n=(side>=0.0)?ior.xy:ior.yx,nn=vec2(n.x,-n.y);\n            if(rand2().y>0.5*(pow(dot(nn,ca)/dot(n,ca),2.0)+pow(dot(nn,ca.yx)/dot(n,ca.yx),2.0)))\n               nrd=refr;\n            \n            rd = nrd;\n\n            col *= 1.2;\n        }\n        \n        ro = hit + rd * 0.0001; //seed++;\n        \n        if(dot(col,col)<0.002) break;\n    }\n    \n    \t//color = mcol.xyz;\n \treturn color;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n    float seed = iTime + iResolution.y *(p.x+1.0) + p.y;\n\t\n\trandv2=fract(cos((fragCoord.xy+fragCoord.yx*vec2(1000.0,1000.0))+vec2(iTime))*10000.0);\n\t\n    //move camera with mouse\n\tvec3 ro = vec3( 0.0+3.0*cos(8.0*mo.x), -0.3 + 1.5*(mo.y), 0.0 + 3.0*sin(8.0*mo.x) );\n\tvec3 ta = vec3( 0.0, 0.0, 0.0 );\n\t\n    //camera path\n    time = 0.2 * iTime;;\n    vec3 path = vec3(sin(time)*0.7 + 0.0, 0.4, cos(time)*1.9 + 0.0);    \n    ro = path; ta = path + vec3(cos(time*0.5)*1.5+0.0, -0.1, sin(time*0.0)+0.1);\n    \n    //view of raymarch\n    //ro = vec3(0.1,0.0,0.0); ta = vec3(1.0,0.0,0.0);\n\t// camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n    \n    f0 = texture( iChannel1, vec2( 0.01, 0.0 ) ).x;\n    f1 = texture( iChannel1, vec2( 0.56, 0.0 ) ).x;\n    f2 = texture( iChannel1, vec2( 0.96, 0.0 ) ).x;\n    \n    f0 = pow(f0*1.0,5.0);\n    \n    initscene();\n\t\n\tvec3 col = vec3(0.0);\n\n    for(float i=0.0; i<t; i++)\n    {\n        p += (rand2() * 2.0 - 1.0) * 0.5 / iResolution.x;\n        rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n    \tcol += getColor( ro, rd );\n    }\n\n    col = pow( clamp( col/t, 0.0, 1.0 ), vec3(0.75) );\n    //col.g += tc;\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4s2XR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[741, 741, 754, 842, 1018], [1020, 1020, 1083, 1189, 1510], [1512, 1512, 1553, 1585, 1873], [2218, 2218, 2271, 2271, 2575], [2577, 2577, 2617, 2617, 3017], [3019, 3019, 3075, 3075, 3524], [3528, 3528, 3570, 3570, 3640], [3643, 3643, 3697, 3697, 4177], [4179, 4179, 4231, 4231, 4340], [4342, 4342, 4395, 4395, 4539], [5133, 5150, 5193, 5193, 5222], [5224, 5224, 5256, 5256, 5335], [5337, 5337, 5373, 5373, 5408], [5410, 5410, 5446, 5446, 5481], [5483, 5483, 5519, 5519, 5554], [5556, 5556, 5592, 5592, 5691], [5693, 5693, 5748, 5748, 5910], [5912, 5912, 5933, 5933, 6574], [6576, 6576, 6625, 6625, 6905], [6928, 6928, 6946, 7009, 8854], [8856, 8856, 8923, 9021, 10933], [10935, 10935, 10986, 10986, 11108], [11110, 11110, 11235, 11235, 15990], [15992, 15992, 16025, 16025, 18476], [18478, 18478, 18535, 18535, 20022]], "test": "error"}
{"id": "4sBXzz", "name": "g-force 2D", "author": "muellst", "description": "pixel emit particles that are attracted by 4 masses and tracked for some timesteps until they fall on the texture.", "tags": ["2d", "gravitysimulation"], "likes": 3, "viewed": 718, "published": "Public", "date": "1408216595", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define pi 3.1415\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy; //start position\n    vec2 v=uv-vec2(0.5);//initial velocity of particle\n    v=.1*v;\n    \n    //centers of masses\n    vec2 mpos=vec2(0.5)+0.1*vec2(sin(iTime/20.),cos(iTime/10.));\n    vec2 mpos1=vec2(0.5)+0.3*vec2(sin(iTime/14.),cos(iTime/4.+2.));\n    vec2 mpos2=vec2(0.5)+0.5*vec2(sin(iTime/17.+3.),cos(iTime/5.+4.));\n    vec2 mpos3=vec2(0.5)+0.6*vec2(sin(iTime/26.+6.),cos(iTime/7.));\n    \n    //simulate particle motion for somw timesteps\n    for(int i=0;i<20;i++)\n    {\n    \tuv+= v; //apply velocity\n        \n        //update velocity by 1/r to masses\n        float l=length(uv-mpos)+.1;\n        v=v+0.001*(uv-mpos)/length(uv-mpos)*1./l/l;\n        l=length(uv-mpos1)+.1;\n        v=v+0.001*(uv-mpos1)/length(uv-mpos1)*1./l/l;\n        l=length(uv-mpos2)+.1;\n        v=v+0.001*(uv-mpos2)/length(uv-mpos2)*1./l/l;\n        l=length(uv-mpos3)+.1;\n        v=v+0.001*(uv-mpos3)/length(uv-mpos3)*1./l/l;\n        v=0.99*v; //damp velocity\n    }\n    \n    float s=5.; //scale for intensity\n    vec4 texture=vec4(texture(iChannel0, vec2(uv[0]-floor(uv[0]),uv[1]-floor(uv[1]))));\n    //color the texture by velocity components\n\tfragColor = vec4(v[0]*s,v[1]*s,length(v)*s,1.)*length(texture);\n//fragColor = vec4(0.5*(sin(atan(v[0],v[1]))+1.),0.,length(v)*s,1.)*length(texture);\n}", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sBXzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 77, 77, 1390]], "test": "error"}
{"id": "4sjXRh", "name": "Squiggles", "author": "Dave_Hoskins", "description": "Experimenting with movement in Voronoi noise. Mouse X to force zoom out.\nFull screen it if you can!", "tags": ["voronoi", "squiggles"], "likes": 35, "viewed": 3075, "published": "Public API", "date": "1408912258", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Squiggles\n// Dave H.\n// https://www.shadertoy.com/view/4sjXRh\n\n#define MOD2 vec2(.16632,.17369)\n#define MOD3 vec3(.16532,.17369,.15787)\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 Hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3.zxy, p3.yxz+19.19);\n    return fract(vec2(p3.x * p3.y, p3.z*p3.x));\n}\n\n//---------------------------------------------------------------------------------------\nvec3 Cells(in vec2 p, in float time)\n{\n    vec2 f = fract(p);\n    p = floor(p);\n\tfloat d = 1.0e10;\n    vec2 id = vec2(0.0);\n    time *= 1.5;\n    \n\tfor (int xo = -1; xo <= 1; xo++)\n\t{\n\t\tfor (int yo = -1; yo <= 1; yo++)\n\t\t{\n            vec2 g = vec2(xo, yo);\n            vec2 n = Hash22(p+g);\n            n = n*n*(3.0-2.0*n);\n            \n\t\t\tvec2 tp = g + .5 + sin(time + 6.2831 * n)*1.2 - f;\n            float d2 = dot(tp, tp);\n\t\t\tif (d2 < d)\n            {\n                // 'id' is the colour code for each squiggle\n                d = d2;\n                id = n;\n            }\n\t\t}\n\t}\n\treturn vec3(sqrt(d), id);\n}\n\n//---------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xx;\n\tfloat time = iTime;\n    vec3 col = vec3(0.0);\n\tfloat amp = 1.0;\n    float size = 4.0 * (abs(fract(time*.01-.5)-.5)*50.0+1.0) + ((iMouse.x/iResolution.x) * 200.0);\n    float timeSlide = .05;\n         \n    for (int i = 0; i < 20; i++)\n    {\n        vec3 res = Cells(uv * size - size * .5, time);\n        float c = 1.0 - res.x;\n        // Get a colour associated with the returned id...\n        vec3 wormCol =  clamp(abs(fract((res.y+res.z)* 1.1 + vec3(1.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0) -1.0, 0.0, 1.0);\n        c = smoothstep(0.6+amp*.25, 1., c);\n        col += amp * c * ((wormCol * .1) + vec3(.9, .2, .15));\n        amp *= .85;\n        time -= timeSlide;\n    }\n\tfragColor = vec4(min(col, 1.0), 1.0);\n}\n", "image_inputs": [{"id": "4ssGRr", "previewfilepath": "https://soundcloud.com/badklaat/badklaat-insects-clip", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/badklaat/badklaat-insects-clip", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sjXRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[140, 251, 272, 272, 397], [399, 489, 527, 527, 1103], [1105, 1195, 1252, 1252, 2004]], "test": "ok"}
{"id": "4slSWf", "name": "Bender", "author": "iq", "description": "Bender distance field (partial, only what's visible to camera).", "tags": ["procedural", "3d", "raymarching", "distancefield", "sdf", "cartoon"], "likes": 203, "viewed": 18108, "published": "Public API", "date": "1407382465", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2013\n//   https://www.youtube.com/c/InigoQuilez\n//   https://iquilezles.org\n// I share this piece (art and code) here in Shadertoy and through its Public API, only for educational purposes. \n// You cannot use, sell, share or host this piece or modifications of it as part of your own commercial or non-commercial product, website or project.\n// You can share a link to it or an unmodified screenshot of it provided you attribute \"by Inigo Quilez, @iquilezles and iquilezles.org\". \n// If you are a teacher, lecturer, educator or similar and these conditions are too restrictive for your needs, please contact me and we'll work it out.\n\n\n//========================================================================================\n// noises\n//========================================================================================\n\nfloat sin_noise( in vec2 x ) { return sin(x.x+sin(x.y)); }\nfloat fbm( vec2 p )\n{\n    const mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\n    float f = 0.0;\n    f += 0.5000*sin_noise( p ); p = m2*p*2.02;\n    f += 0.2500*sin_noise( p ); p = m2*p*2.03;\n    f += 0.1250*sin_noise( p ); p = m2*p*2.01;\n    f += 0.0625*sin_noise( p );\n    return f/0.9375;\n}\n\n//========================================================================================\n// distance primitives\n//========================================================================================\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 sdSegment( vec3 a, vec3 b, vec3 p )\n{\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ), h );\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n\treturn max( max( dot(q,c.xy), p.y), -p.y-c.z );\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat det( vec2 a, vec2 b ) { return a.x*b.y-b.x*a.y; }\nvec3 getClosest( vec2 b0, vec2 b1, vec2 b2 ) \n{\n    float a =     det(b0,b2);\n    float b = 2.0*det(b1,b0);\n    float d = 2.0*det(b2,b1);\n    float f = b*d - a*a;\n    vec2  d21 = b2-b1;\n    vec2  d10 = b1-b0;\n    vec2  d20 = b2-b0;\n    vec2  gf = 2.0*(b*d21+d*d10+a*d20); gf = vec2(gf.y,-gf.x);\n    vec2  pp = -f*gf/dot(gf,gf);\n    vec2  d0p = b0-pp;\n    float ap = det(d0p,d20);\n    float bp = 2.0*det(d10,d0p);\n    float t = clamp( (ap+bp)/(2.0*a+b+d), 0.0 ,1.0 );\n    return vec3( mix(mix(b0,b1,t), mix(b1,b2,t),t), t );\n}\n\nvec2 sdBezier( vec3 a, vec3 b, vec3 c, vec3 p, in float thickness )\n{\n\tvec3 w = normalize( cross( c-b, a-b ) );\n\tvec3 u = normalize( c-b );\n\tvec3 v = normalize( cross( w, u ) );\n\n\tvec2 a2 = vec2( dot(a-b,u), dot(a-b,v) );\n\tvec2 b2 = vec2( 0.0 );\n\tvec2 c2 = vec2( dot(c-b,u), dot(c-b,v) );\n\tvec3 p3 = vec3( dot(p-b,u), dot(p-b,v), dot(p-b,w) );\n\n\tvec3 cp = getClosest( a2-p3.xy, b2-p3.xy, c2-p3.xy );\n\n\treturn vec2( 0.85*(sqrt(dot(cp.xy,cp.xy)+p3.z*p3.z) - thickness), cp.z );\n}\n\n//========================================================================================\n// distance operators\n//========================================================================================\n\nfloat opU( float d2, float d1 ) { return min( d1,d2); }\nfloat opS( float d2, float d1 ) { return max(-d1,d2); }\nvec3  opU( vec3  d2, vec3  d1 ) { return ( d2.x<d1.x)? d2:d1; }\nvec3  opS( vec3  d2, vec3  d1 ) { return (-d1.x>d2.x)?-d1:d2; }\n\n//========================================================================================\n// Bender\n//========================================================================================\n\nvec4 map( vec3 p )\n{\n\tvec3 q = vec3( abs(p.x), p.yz );\n\n    // head and body\n\tfloat d1;\n    d1 =          sdSegment(     vec3(0.0,1.8,0.0), vec3(0.0,0.7,0.0), p ).x - 0.5;\n    d1 = opU( d1, sdCone(      p-vec3(0.0,2.8,0.0), vec3( normalize(vec2(0.9,0.1)), 0.5 ) ) );\n    d1 = opS( d1, sdCylinder( (p-vec3(0.0,1.0,0.4)).zxy, vec2(0.2,1.0) ) );\n    d1 = opU( d1, sdCylinder( (p-vec3(0.0,-0.32,0.0)), vec2(0.93,0.7) ) );\n    d1 = opU( d1, sdCone(     (p-vec3(2.2,1.7,1.0))*vec3(1.0,-1.0,-1.0), vec3( normalize(vec2(0.8,0.4)), 0.5 ) ) );\n    vec4 res = vec4( d1,1.0,0.0,0.0 );\n    \n    // neck and fingers    \n    {\n    vec3 d;\n    d =         vec3( udRoundBox( p-vec3(0.0,1.55,0.30), vec3(0.35,0.1,0.3)-0.03, 0.12 ), 1.0, 5.0 );\n    d = opS( d, vec3( udRoundBox( p-vec3(0.0,1.55,0.35), vec3(0.35,0.1,0.5)-0.04, 0.10 ), 0.0, 5.0) );\n    d = opU( d, vec3( sdCone(     p-vec3(0.0,1.08,0.00), vec3(0.60,0.8,0.7) ), 1.0, 6.0) );\n    d = opU( d, vec3( sdSphere(   p-vec3(0.0,2.70,0.00), 0.08 ), 1.0, 7.0) );\n    d = opU( d, vec3( sdSphere(   p-vec3(0.0,2.20,0.00), 0.15 ), 1.0, 8.0) );\n    d = opU( d, vec3( sdSegment( vec3(2.2,2.10,1.0), vec3(2.2,2.35,0.8), q ).x - 0.08, 0.8,  9.0) );\n\td = opU( d, vec3( sdSegment( vec3(2.2,2.10,1.0), vec3(2.4,2.35,1.2), q ).x - 0.08, 0.8, 10.0) );\n\td = opU( d, vec3( sdSegment( vec3(2.2,2.10,1.0), vec3(2.0,2.35,1.2), q ).x - 0.08, 0.8, 11.0) );\n    d = opU( d, vec3( sdSegment( vec3(2.2,2.35,0.8), vec3(2.2,2.40,0.8), q ).x - 0.08, 0.8,  9.0) );\n\td = opU( d, vec3( sdSegment( vec3(2.4,2.35,1.2), vec3(2.4,2.50,1.1), q ).x - 0.08, 0.8, 10.0) );\n\td = opU( d, vec3( sdSegment( vec3(2.0,2.35,1.2), vec3(2.0,2.50,1.1), q ).x - 0.08, 0.8, 11.0) );\n    if( d.x<res.x ) res = vec4( d.x,3.0,d.yz );\n    }\n    \n    // eyes and mouth\n    {\n    vec3 d;\n    d =         vec3( sdSphere(   p-vec3( 0.18,1.55,0.48), 0.18           ), 1.0, 12.0 );\n    d = opU( d, vec3( sdSphere(   p-vec3(-0.18,1.55,0.48), 0.18           ), 1.0, 13.0 ) );\n    d = opU( d, vec3( sdCylinder( p-vec3( 0.00,1.00,0.00), vec2(0.47,0.4) ), 1.0, 14.0 ) );\n    if( d.x<res.x ) res = vec4( d.x,2.0, d.yz );\n    }\n    \n    // arms\n    {\n    vec3 d;\n    d =         vec3( sdSphere( q-vec3( 0.88,0.15,0.0), 0.19 ), 0.0, 15.0 );\n    d = opU( d, vec3( sdBezier( vec3(0.9,0.15,0.0), vec3(2.0,-0.5,0.0), vec3(2.2,2.0,1.0), q, 0.13 ), 16.0) );\n    if( d.x<res.x ) res = vec4( d.x,0.0, d.yz );\n    }\n\n    return res;\n}\n\n//========================================================================================\n\nvec4 raycast( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 9.0;\n    float t = 0.0;\n    vec4 res = vec4(-1.0);\n    for( int i=0; i<128; i++ )\n    {\n\t    vec4 tmp = map( ro+rd*t );\n        res = vec4(t,tmp.yzw);\n        if( tmp.x<0.001 || t>maxd ) break;\n        t += tmp.x;\n    }\n    return (t>maxd) ? vec4(-1.0) : res;\n}\n\n// https://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(-1.0,1.0) * 0.005;   \n\treturn normalize( e.yxx*map( pos + e.yxx ).x + \n\t\t\t\t\t  e.xxy*map( pos + e.xxy ).x + \n\t\t\t\t\t  e.xyx*map( pos + e.xyx ).x + \n\t\t\t\t\t  e.yyy*map( pos + e.yyy ).x );    \n}\n\n// https://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<48; i++ )\n    {\n        float h = map(ro + rd*t).x;\n        res = min( res, k*h/t );\n        if( res<0.001 || t>5.0 ) break;\n\t\tt += clamp( h, 0.005, 0.5 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvoid generateRay( out vec3 resRo, out vec3 resRd, in vec3 po, in vec3 ta, in vec2 pi )\n{\n\tvec2 p = (2.0*pi-iResolution.xy)/iResolution.y;\n        \n    // camera matrix\n    vec3 ww = normalize( ta - po );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 2.2*ww );\n\n    resRo = po;\n    resRd = rd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    float an = 5.7 + 0.62831*iTime;\n\tvec3  po = vec3(1.0 + 3.5*sin(an),0.6,3.5*cos(an));\n    vec3  ta = vec3(1.0,1.5,0.0);\n\n    vec3 ro,  rd;  generateRay( ro,  rd,  po, ta, fragCoord.xy );\n    vec3 ro2, rd2; generateRay( ro2, rd2, po, ta, fragCoord.xy+vec2(2.0,0.0) );\n    vec3 ro3, rd3; generateRay( ro3, rd3, po, ta, fragCoord.xy+vec2(0.0,2.0) );\n    \n    //-----------------------------------------------------\n\t// sky\n    //-----------------------------------------------------\n    \n    float gra = smoothstep(-0.3,0.6,rd.y);                    \n    vec3  sky = vec3(0.4,0.7,1.0)*0.2;\n    float h = (1000.0-ro.y)/rd.y;\n    if( h>0.0 )\n    {\n        vec2 uv = ro.xz + rd.xz*h;\n        float cl = smoothstep( 0.0, 0.8, fbm( 0.002*uv ) );\n        cl = clamp( floor(cl*3.0)/(3.0-1.0), 0.0, 1.0 );\n        sky = mix( sky, vec3(0.9,0.6,0.3), 0.4*cl*gra );\n    }\n    vec3 col = mix( 0.6*vec3(0.6,0.9,1.0), sky, gra );\n\n    //-----------------------------------------------------\n\t// bender\n    //-----------------------------------------------------\n\n    // raymarch\n    vec4 tmat  = raycast( ro ,rd );\n    if( tmat.y>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + tmat.x*rd;\n        vec3 nor = calcNormal(pos);\n\t\tvec3 ref = reflect( rd, nor );\n\n        // materials\n\t\tvec3 mate = vec3(0.0);\n\t\tif( tmat.y<0.5 )\n\t\t{\n\t\t\tmate = vec3(0.1,0.12,0.15);\n            mate *= smoothstep( -0.95, -0.94, sin(40.0*tmat.z) );\n\t\t}\n\t\telse if( tmat.y<1.5 )\n\t\t{\n\t\t\tmate = vec3(0.13,0.17,0.24);\n            mate *= clamp( 200.0*udRoundBox( pos-vec3(0.0,1.55,0.35), vec3(0.35,0.1,0.5)-0.04, 0.1 ), 0.0, 1.0 );\n\t\t}\n\t\telse if( tmat.y<2.5 )\n\t\t{\n\t\t\tmate = vec3(0.7,0.68,0.4);\n            vec3 qos = vec3( abs(pos.x), pos.yz );\n            mate *= clamp( 100.0 * sdBox(qos-vec3(0.18+0.05*sign(pos.x),1.55+0.05,0.5),vec3(0.04,0.04,0.5) ), 0.0, 1.0 );\n            float teeth = min( sdBox(qos-vec3(0.0,1.08,0.5),vec3(1.0,0.01,0.3) ),\n                               sdBox(qos-vec3(0.0,0.92,0.5),vec3(1.0,0.01,0.3) ) );\n            teeth = min( teeth, sdBox( vec3(mod(qos.x+0.09,0.18),qos.yz) -vec3(0.0,1.0,0.5),vec3(0.01,0.3,0.3) ) );\n            mate *= clamp( 100.0 * teeth, 0.0, 1.0 );\n\t\t}\n\t\telse if( tmat.y<3.5 )\n\t\t{\n            mate = vec3(0.25,0.29,0.34) * tmat.z;\n\t\t}\n        \n\t\t// lighting \n        const vec3 lig = normalize(vec3(0.8,0.6,0.3));\n\t\tfloat dif = max(dot(nor,lig),0.0);\n\t\tfloat sha = 0.0; if( dif>0.01 ) sha=softshadow( pos+0.01*nor, lig, 0.0005, 32.0 );\n        float fre = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 5.0 );\n        vec3 brdf = vec3(0.0);\n        brdf += 1.5*sha;\n\t\tbrdf += 0.75;\n        brdf += 0.7*smoothstep(0.1,0.15,fre*sha);\n        \n\t\t// surface-light interacion\n\t\tcol = mate*brdf;\n\t}\n\n    // cartoon edges\n    vec4 tmat2 = raycast(ro2,rd2); // raytrace right pixel\n    vec4 tmat3 = raycast(ro3,rd3); // raytrace top pixel too\n    col *= clamp( 1.0 - 10.0*max(abs(tmat.w-tmat2.w),abs(tmat.w-tmat3.w)), 0.0, 1.0 );\n\n    // gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n    \n\t// vignetting\n\tvec2 q = fragCoord / iResolution.xy;\n    col *= 0.4 + 0.6*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4slSWf.jpg", "access": "shaders20k", "license": "proprietary-license", "functions": [[861, 861, 891, 891, 919], [920, 920, 941, 941, 1209], [1417, 1417, 1448, 1448, 1539], [1541, 1541, 1583, 1583, 1714], [1716, 1716, 1754, 1754, 1845], [1847, 1847, 1882, 1882, 1908], [1910, 1910, 1946, 1946, 2049], [2051, 2051, 2096, 2096, 2138], [2140, 2140, 2169, 2169, 2195], [2196, 2196, 2243, 2243, 2721], [2723, 2723, 2792, 2792, 3200], [3407, 3407, 3440, 3440, 3462], [3463, 3463, 3496, 3496, 3518], [3519, 3519, 3552, 3552, 3582], [3583, 3583, 3616, 3616, 3646], [3841, 3841, 3861, 3861, 6236], [6330, 6330, 6370, 6370, 6652], [6654, 6719, 6751, 6751, 6957], [6959, 7022, 7087, 7087, 7343], [7345, 7345, 7433, 7433, 7751], [7753, 7753, 7810, 7810, 11171]], "test": "ok"}
{"id": "4slSWX", "name": "Lava-Spewing Volcano", "author": "reuben364", "description": "A volcano. It was pretty rushed, but I had fun doing it.", "tags": ["volcanolava2d"], "likes": 2, "viewed": 183, "published": "Public", "date": "1407324223", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime*1000.\n#define resolution iResolution.xy\n#define PI 3.1415\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\nfloat smax( float a, float b, float k ) {\n    return -smin(-a,-b,k);\n}\n\nvec2 r(vec2 x)\n{\n\treturn fract(sin(vec2(dot(x,vec2(127.1,311.7)),dot(x,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec2 sr2(vec2 x) {\n    vec2 floored = floor(x);\n    vec2 fracted = .5*sin(PI*(fract(x)-.5))+.5;\n    return mix(mix(r(floored), r(floored+vec2(1,0)), fracted.x),\n              mix(r(floored+vec2(0,1)), r(floored+vec2(1,1)), fracted.x),\n              fracted.y);       \n}\n\nvec2 sr1(float x) {\n    return sr2(vec2(0,x));\n}\n\nfloat volcano (vec2 pos) {\n   \treturn smax(pos.y+.1*length(sr1(25.*pos.x))-3.,pos.y-1./pow(pos.x,2.), 1.);\n}\n\nfloat volcanoLava (vec2 pos) {\n    return abs(pos.x + .01*pos.y*(.5-length(sr1(pos.y-time/100.))))-.4;\n}\n\nfloat lavaBall (vec2 pos) {\n    pos -= vec2(0, -time/200.);\n    vec2 mods = mod(pos, vec2(2.,3.));\n    vec2 divs = floor(pos/vec2(2.,3.));\n    pos = mods;\n    pos-=vec2(.1,.1)+vec2(1.8,2.8)*sr2(divs);\n    return length(pos)-.1;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / resolution;\n    uv-=vec2(.5,0.);\n    vec4 backgroundCol = mix(vec4(1,.4,0,1), mix(vec4(.8,.5,0.,1.), vec4(.1,0,0,1), min(1.,uv.y)), min(1.,4.*uv.y));\n    uv*=5.;\n    uv+=0.1*sr1(time/100.);\n    vec4 lavaBallCol = vec4(1,.5,0,1);\n    float lavaBallMul = lavaBall(uv)<0. ? 1. : 0.;\n    vec4 volcanoLavaCol = mix(vec4(1,1,0,1), vec4(1,0,0,1), length(sr1(uv.x*25.-uv.y+0.1*sin(5.*uv.y)+time/200.)));\n    float volcanoLavaMul = float(volcanoLava(uv)<0.);\n    vec4 volcanoCol = .25*(3.+length(sr2(uv*10.)))*vec4(171./256.,106./256.,32./256., 1.);\n    float volcanoMul = float(volcano(uv) < 0.);\n\tfragColor = mix(\n        mix(mix(backgroundCol,\n                lavaBallCol, lavaBallMul),\n            volcanoLavaCol, volcanoLavaMul)\n        ,volcanoCol, volcanoMul);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4slSWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 78, 119, 119, 190], [191, 191, 232, 232, 261], [263, 263, 279, 279, 369], [371, 371, 389, 389, 640], [642, 642, 661, 661, 690], [692, 692, 718, 718, 800], [802, 802, 832, 832, 906], [908, 908, 935, 935, 1137], [1141, 1141, 1198, 1198, 1985]], "test": "ok"}
{"id": "4slXWs", "name": "SIG2014 O", "author": "mrdoob", "description": "Done in a keyboard without parenthesis. Lots of copy/paste action.", "tags": ["sphere"], "likes": 4, "viewed": 1009, "published": "Public", "date": "1407869872", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//------------------------------------------------------------------------\n// Camera\n//\n// Move the camera. In this case it's using time and the mouse position\n// to orbitate the camera around the origin of the world (0,0,0), where\n// the yellow sphere is.\n//------------------------------------------------------------------------\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 0.3*iTime + 10.0*mouseX;\n\tcamPos = vec3(3.5*sin(an),1.0,3.5*cos(an));\n    camTar = vec3(sin(iTime),cos(iTime),0.0);\n}\n\n\n//------------------------------------------------------------------------\n// Background \n//\n// The background color. In this case it's just a black color.\n//------------------------------------------------------------------------\nvec3 doBackground( void )\n{\n    return vec3( 0.0, 0.0, 0.0);\n}\n    \n//------------------------------------------------------------------------\n// Modelling \n//\n// Defines the shapes (a sphere in this case) through a distance field, in\n// this case it's a sphere of radius 1.\n//------------------------------------------------------------------------\nfloat doModel( vec3 p )\n{\n    return length(p) - 1.0;\n}\n\nfloat doModel2( vec3 p )\n{\n    p.x = sin(p.x + iTime) * sin(p.y);\n    p.y = cos(p.y + iTime) * sin(p.x);\n    p.z = sin(p.z + iTime);\n    return length(p * sin(iTime * 0.1) - 0.25) - 0.25;\n}\n\n//------------------------------------------------------------------------\n// Material \n//\n// Defines the material (colors, shading, pattern, texturing) of the model\n// at every point based on its position and normal. In this case, it simply\n// returns a constant yellow color.\n//------------------------------------------------------------------------\nvec3 doMaterial( in vec3 pos, in vec3 nor )\n{\n    return vec3(sin(iTime + pos.x),cos(iTime + pos.y),0.05);\n}\n\n//------------------------------------------------------------------------\n// Lighting\n//------------------------------------------------------------------------\nfloat calcSoftshadow( in vec3 ro, in vec3 rd );\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal )\n{\n    vec3 lin = vec3(0.0);\n\n    // key light\n    //-----------------------------\n    vec3  lig = normalize(vec3(1.0,0.7,0.9));\n    float dif = max(dot(nor,lig),0.0);\n    float sha = 0.0; if( dif>0.01 ) sha=calcSoftshadow( pos+0.01*nor, lig );\n    lin += dif*vec3(4.00,4.00,4.00)*sha;\n\n    // ambient light\n    //-----------------------------\n    lin += vec3(0.50,0.50,0.50);\n\n    \n    // surface-light interacion\n    //-----------------------------\n    vec3 col = mal*lin;\n\n    \n    // fog    \n    //-----------------------------\n\tcol *= exp(-0.01*dis*dis);\n\n    return col;\n}\n\nfloat calcIntersection( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 20.0;           // max trace distance\n\tconst float precis = 0.001;        // precission of the intersection\n    float h = precis*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for( int i=0; i<90; i++ )          // max number of raymarching iterations is 90\n    {\n        if( h<precis||t>maxd ) break;\n\t    h = doModel2( ro+rd*t );\n        t += h;\n    }\n\n    if( t<maxd ) res = t;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.002;             // precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps ) + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ) + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ) + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ) );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.0005;                 // selfintersection avoidance distance\n\tfloat h = 1.0;\n    for( int i=0; i<40; i++ )         // 40 is the max numnber of raymarching steps\n    {\n        h = doModel(ro + rd*t);\n        res = min( res, 64.0*h/t );   // 64 is the hardness of the shadows\n\t\tt += clamp( h, 0.02, 2.0 );   // limit the max and min stepping distances\n    }\n    return clamp(res,0.0,1.0);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, iTime * 0.2 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = doBackground();\n\n\t// raymarch\n    float t = calcIntersection( ro, rd );\n    if( t>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\n        // materials\n        vec3 mal = doMaterial( pos, nor );\n\n        col = doLighting( pos, nor, rd, t, mal );\n\t}\n\n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n    // gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n\t   \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4slXWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 332, 415, 415, 548], [551, 782, 809, 809, 844], [850, 1132, 1157, 1157, 1187], [1189, 1189, 1215, 1215, 1378], [1380, 1733, 1778, 1778, 1841], [2054, 2054, 2138, 2138, 2714], [2716, 2716, 2766, 2766, 3184], [3186, 3186, 3218, 3218, 3630], [3632, 3632, 3680, 3680, 4106], [4108, 4108, 4172, 4172, 4350], [4352, 4352, 4409, 4409, 5621]], "test": "ok"}
{"id": "4ssSDs", "name": "Where am I", "author": "dsan", "description": "My first shader!", "tags": ["sig2014"], "likes": 7, "viewed": 197, "published": "Public", "date": "1407871504", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n    \n//------------------------------------------------------------------------\n// Camera\n//\n// Move the camera. In this case it's using time and the mouse position\n// to orbitate the camera around the origin of the world (0,0,0), where\n// the yellow sphere is.\n//------------------------------------------------------------------------\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 0.3*iTime + 10.0*mouseX;\n\tcamPos = vec3(3.5*sin(an),1.0,3.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n\n//------------------------------------------------------------------------\n// Background \n//\n// The background color. In this case it's just a black color.\n//------------------------------------------------------------------------\nvec3 doBackground( void )\n{\n    return vec3( 0.0, 0.0, 0.0);\n}\n    \nfloat map(float s, float a1, float a2, float b1, float b2)\n{\n    return b1 + (s-a1)*(b2-b1)/(a2-a1);\n}\n//------------------------------------------------------------------------\n// Modelling \n//\n// Defines the shapes (a sphere in this case) through a distance field, in\n// this case it's a sphere of radius 1.\n//------------------------------------------------------------------------\nfloat doModel( vec3 p )\n{\tfloat sp = map( sin(iTime*7.0), -1.0, 1.0, .2, .52) ;\n    float s1 = (sin(iTime*5.0)+1.2)*.36;\n    float s2 = (sin(iTime*7.0)+1.2)*.16  ;\n    return length(p+sp) - ( s1 + s2 );\n}\n\n\n//------------------------------------------------------------------------\n// Material \n//\n// Defines the material (colors, shading, pattern, texturing) of the model\n// at every point based on its position and normal. In this case, it simply\n// returns a constant yellow color.\n//------------------------------------------------------------------------\nvec3 doMaterial( in vec3 pos, in vec3 nor )\n{\n    return vec3(0.1,0.57,0.3);\n}\n\n//------------------------------------------------------------------------\n// Lighting\n//------------------------------------------------------------------------\nfloat calcSoftshadow( in vec3 ro, in vec3 rd );\n\n\n\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal )\n{\n    vec3 lin = vec3(0.0);\n\n    // key light\n    //-----------------------------\n    vec3  lig = normalize(vec3(0.0,1.0,0.9));\n    float dif = max(dot(nor,lig),0.0);\n    float sha = 0.0; if( dif>0.01 ) sha=calcSoftshadow( pos+0.01*nor, lig );\n    lin += dif*vec3(4.00,4.00,4.00)*sha;\n    \n    //dot product of view vector and normal\n    float view = dot( rd, nor );\n\tfloat thing =  1.0 -  clamp( view, 0.0, 1.0);\n    \n    \n    // ambient light\n    //-----------------------------\n    float s1 = map( sin(iTime),-1.0,1.0,.3,1.0);\n    lin += vec3(.1,0.43,.43) ;\n    \n    // surface-light interacion\n    //-----------------------------\n    vec3 col = mal*lin;\n    \n    // fog    \n    //-----------------------------\n\tcol *= exp(-0.01*dis*dis);\n\n    return col * pow(thing,2.0) ;\n}\n\nfloat calcIntersection( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 20.0;           // max trace distance\n\tconst float precis = 0.001;        // precission of the intersection\n    float h = precis*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    \n    \n    for( int i=0; i<90; i++ )          // max number of raymarching iterations is 90\n    {\n        if( h<precis||t>maxd ) break;\n        float sp = map( sin(iTime*7.0), -1.0, 1.0, .04, .2) ;\n\t    h = doModel( ro+rd*t );\n        t += h*sp;\n    }\n\n    if( t<maxd ) res = t;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.002;             // precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps ) + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ) + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ) + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ) );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.0005;                 // selfintersection avoidance distance\n\tfloat h = 1.0;\n    for( int i=0; i<40; i++ )         // 40 is the max numnber of raymarching steps\n    {\n        h = doModel(ro + rd*t);\n        res = min( res, 64.0*h/t );   // 64 is the hardness of the shadows\n\t\tt += clamp( h, 0.02, 2.0 );   // limit the max and min stepping distances\n    }\n    return clamp(res,0.0,1.0);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\tfloat mx = map( m.x, -100.0, 100.0, 0.0, 1.0);\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n     \n    float s1 = (sin(iTime*5.0)+1.2)*.36;\n    float s2 = (sin(iTime*7.0)+1.2)*.16;\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, (s1+s2)*mx );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,3.0) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n        \n\tvec3 col = doBackground();\n\tvec3 nor;\n    \n\t// raymarch\n    float t = calcIntersection( ro, rd );\n    if( t>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + t*rd;\n        nor = calcNormal(pos);\n\n        // materials\n        vec3 mal = doMaterial( pos, nor );\n\n        col = doLighting( pos, nor, rd, t, mal + rd*.2 );\n       // col -= doLighting( pos+22.0 , nor, nor, t, mal );\n\t}\n\n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n    // gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n    \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ssSDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[6, 338, 421, 421, 540], [543, 543, 569, 569, 780], [783, 1014, 1041, 1041, 1076], [1082, 1082, 1142, 1142, 1184], [1185, 1467, 1492, 1492, 1671], [1674, 2027, 2072, 2072, 2105], [2321, 2321, 2405, 2405, 3182], [3184, 3184, 3234, 3234, 3726], [3728, 3728, 3760, 3760, 4172], [4174, 4174, 4222, 4222, 4648], [4650, 4650, 4714, 4714, 4892], [4894, 4894, 4951, 4951, 6383]], "test": "error"}
{"id": "4ssSWf", "name": "Cairo tiling", "author": "nimitz", "description": "Cairo pentagonal tiling and snub square tiling.\n\nThe standard \"F2-F1\" edge detection misses the reflected edges, is there a solution which doesn't involve evaluating twice? ", "tags": ["procedural", "2d", "tiling"], "likes": 40, "viewed": 1831, "published": "Public", "date": "1407374606", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Cairo tiling by nimitz (stormoid.com) (twitter: @stormoid)\n\n//Inspired by Petri Leskinen's \"Cairo Pentagonal Tiling\" http://pixelero.wordpress.com/page/2/\n\n/*\n\tCairo pentagonal tiling made using a \"voronoi-like\" function,\n\tthe main difference is that half the tiles are reflected and the centers are\n\tdisplaced symmetrically.\n\n\tPlease let me know if you can think of a simple way to get all the edges.\n*/\n\n#define time iTime*0.5\nfloat hash( float n ){ return fract(sin(n)*43758.5453);}\n\n\n//returns: x -> distance form center | y -> cell id | z -> distance from edge\nvec3 field(const in vec2 p)\n{\n    vec2 fp = fract(p);\n    vec2 ip = floor(p);\n    \n    vec3 rz = vec3(1.);\n    \n    //vary the offset over time\n    float of = sin(time*0.6)*.5;\n    \n    //reflect\n   \tfloat rf = mod(ip.x+ip.y,2.0);\n    fp.x = rf-fp.x*sign(rf-.5);\n    \n\tfor(float j=0.; j<=1.; j++)\n\tfor(float i=0.; i<=1.; i++)\n    {\n        vec2 b = vec2(j, i);\n        \n        //Displace each sample\n        float sgn = sign(j-0.5); \n        float cmp = float(j == i);\n        vec2 o = vec2(sgn*cmp,-sgn*(1.-cmp));\n        //o = b-vec2(i,j); //variation\n        vec2 sp = fp - b + of*o;\n        b += o;\n        \n        float d = dot(sp,sp);\n        \n        if( d<rz.x )\n        {\n            rz.z = rz.x;\n            rz.x = d;\n            b.x = rf-b.x*sign(rf-.5);\n        \trz.y = hash( dot(ip+b,vec2(7.0,113.0) ) );\n        }\n        else if( d<rz.z )\n\t\t{\n            rz.z = d;\n\t\t}\n    }\n    \n    //truncation\n    float d = dot(fp-.5,fp-.5);\n    d += 0.4; //truncation weight\n    if (d < rz.x)\n    {\n        rz.z = rz.x;\n        rz.x = d;\n        rz.y = hash( dot(ip,vec2(7.0,113.0) ) );\n    }\n    else if(d < rz.z )\n\t{\n    \trz.z = d;\n\t}\n    \n    //F2-F1 edge detection\n    rz.z = rz.z-rz.x;\n    \n    return rz;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n\tp.x *= iResolution.x/iResolution.y;\n    float a = sin(time)*.5;\n    float b = .5;\n    \n    p *= 6.+sin(time*0.4);\n    p.x += time;\n    p.y += sin(time)*0.5;\n    \n    vec3 rz = field(p);\n    \n    vec3 col = (sin(vec3(.2,.55,.8)+rz.y*4.+2.)+0.4)*0.6+0.5;\n    col *= 1.-rz.x;\n    col *= smoothstep(0.,.04,rz.z);\n    \n    fragColor = vec4(col,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ssSWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[431, 431, 453, 453, 487], [1788, 1788, 1845, 1845, 2239]], "test": "error"}
{"id": "4ssXWs", "name": "SIG2014_HERBST", "author": "herbst", "description": "should become an deterministic ifs renderer.", "tags": ["fractal", "ifs"], "likes": 14, "viewed": 2587, "published": "Public", "date": "1407871016", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Tweak these to get different results\nconst int   NUM_CIRCLES \t= 17;\nconst float TIME_MULTIPLIER = 3.0;\nconst float CONSTANT_N\t    = 3.0;\n\nconst float N = CONSTANT_N;\n\n// Actual code below\n\n#define TWO_PI 6.28318530718\n#define TWO_THIRDS_PI 2.09439510239\n\n\nvec2 curUV;\n\nvec3 drawCircle(vec2 p, vec2 center, float radius, float edgeWidth, vec3 color)\n{\n    float dist = length(p - center);\n   \t\n    vec3 ret;\n\tret = color * (1.0 - smoothstep(radius, radius+edgeWidth, abs(dist-0.35) ));\n   \n    return ret;\n} \n\nvec3 draw(mat3 mat) {\n  // get center\n    return drawCircle(curUV, vec2(mat[2][0], mat[2][1]), 0.001, 0.01, vec3(1,1,1));\n}\n\n\n\nmat3 t1,t2;\n\n// shadertoy gives unknown error on try of recursion, thus\n// duplication...\n\nvec3 rec5(mat3 t, int iter) {\n    if(iter < 1)\n        return vec3(0.);\n    \n    vec3 col;\n    \n    mat3 tt1 = t * t1;\n    mat3 tt2 = t * t2;\n    \n    col += draw(tt1);\n    col += draw(tt2);\n    \n    //col += rec5(tt1,iter-1);\n    //col += rec5(tt2,iter-1);\n    \n    return col;\n}\n\n\nvec3 rec4(mat3 t, int iter) {\n    if(iter < 1)\n        return vec3(0.);\n    \n    vec3 col;\n    \n    mat3 tt1 = t * t1;\n    mat3 tt2 = t * t2;\n    \n    col += draw(tt1);\n    col += draw(tt2);\n    \n    col += rec5(tt1,iter-1);\n    col += rec5(tt2,iter-1);\n    \n    return col;\n}\n\nvec3 rec3(mat3 t, int iter) {\n    if(iter < 1)\n        return vec3(0.);\n    \n    vec3 col;\n    \n    mat3 tt1 = t * t1;\n    mat3 tt2 = t * t2;\n    \n    col += draw(tt1);\n    col += draw(tt2);\n    \n    col += rec4(tt1,iter-1);\n    col += rec4(tt2,iter-1);\n    \n    return col;\n}\n\nvec3 rec2(mat3 t, int iter) {\n    if(iter < 1)\n        return vec3(0.);\n    \n    vec3 col;\n    \n    mat3 tt1 = t * t1;\n    mat3 tt2 = t * t2;\n    \n    col += draw(tt1);\n    col += draw(tt2);\n    \n    col += rec3(tt1,iter-1);\n    col += rec3(tt2,iter-1);\n    \n    return col;\n}\n\n\nvec3 rec(mat3 t, int iter) {\n    if(iter < 1)\n        return vec3(0.);\n    \n    vec3 col;\n    \n    mat3 tt1 = t * t1;\n    mat3 tt2 = t * t2;\n    \n    col += draw(tt1);\n    col += draw(tt2);\n    \n    col += rec2(tt1,iter-1);\n    col += rec2(tt2,iter-1);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Map coordinates into a small window around [-1, 1]\n\tvec2 uv = (fragCoord.xy*2.0 - iResolution.xy) / iResolution.y;\n\tuv *= 1.2;\n\t\n    t1 = mat3(0.9,-.2,0.0,sin(iTime),0.9,0,-0.4,.3 + cos(iTime * 0.2),0);\n    t2 = mat3(0.5,-0.3 + cos(iTime * 0.8 + 0.1),0.1,0.2 + sin(iTime * 1.3),0.8,0,0.1,-0.2,0);\n    \n    \n\tvec3 color = vec3(0.0);\n\tfloat angleIncrement = TWO_PI / float(NUM_CIRCLES);\n    \n    mat3 tcur = mat3(1,0,0,0,1,0,0, 0,0);\n    \n    curUV = uv;\n\tcolor += rec(tcur,5);\n    \n    /*\n\tfor (int i = 0; i < NUM_CIRCLES; ++i) {\n\t\tfloat t = angleIncrement*(float(i));\n\t\tfloat r = sin(float(N)*t+iTime*TIME_MULTIPLIER);\n\t\tvec2 p = vec2(r*cos(t), r*sin(t));\n\n\t\tvec3 circleColor = vec3(sin(t),\n\t\t\t\t\t\t\t\tsin(t+TWO_THIRDS_PI),\n\t\t\t\t\t\t\t\tsin(t+2.0*TWO_THIRDS_PI))*0.5+0.5;\n\n        float radius = 0.06;\n       color += drawCircle(curUV, p, radius, 0.01, circleColor);\n\t}\n\t*/\n\t\n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ssXWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[272, 272, 353, 353, 509], [512, 512, 533, 549, 635], [730, 730, 759, 759, 1010], [1013, 1013, 1042, 1042, 1289], [1291, 1291, 1320, 1320, 1567], [1569, 1569, 1598, 1598, 1845], [1848, 1848, 1876, 1876, 2123], [2125, 2125, 2182, 2237, 3086]], "test": "ok"}
{"id": "4sXSWs", "name": "Film grain", "author": "jcant0n", "description": "Simple filter", "tags": ["noise", "postprocessing"], "likes": 68, "viewed": 5345, "published": "Public", "date": "1407669254", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 color = texture(iChannel0, uv);\n    \n    float strength = 16.0;\n    \n    float x = (uv.x + 4.0 ) * (uv.y + 4.0 ) * (iTime * 10.0);\n\tvec4 grain = vec4(mod((mod(x, 13.0) + 1.0) * (mod(x, 123.0) + 1.0), 0.01)-0.005) * strength;\n    \n    if(abs(uv.x - 0.5) < 0.002)\n        color = vec4(0.0);\n    \n    if(uv.x > 0.5)\n    {\n    \tgrain = 1.0 - grain;\n\t\tfragColor = color * grain;\n    }\n    else\n    {\n\t\tfragColor = color + grain;\n    }\n}", "image_inputs": [{"id": "4sX3Rn", "previewfilepath": "/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sXSWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 545]], "test": "error"}
{"id": "ld2Szh", "name": "polygon test", "author": "gaz", "description": "3d", "tags": ["raymarching", "polygon"], "likes": 4, "viewed": 153, "published": "Public", "date": "1409144048", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI\t3.14159265359\n#define PI2\t( PI * 2.0 )\n\nvec2 rotate( in vec2 p, in float t )\n{\n\treturn p * cos( -t ) + vec2( p.y, -p.x ) * sin( -t );\n}\n    \nvec3 rotate( in vec3 p, in vec3 t )\n{\n    p.yz = rotate( p.yz, t.x );\n    p.zx = rotate( p.zx, t.y );\n\tp.xy = rotate( p.xy, t.z );\n    return p;\n}\n\nfloat udBox( in vec3 p, in vec3 b )\n{\n\treturn length( max( abs( p ) - b, 0.0 ) );\n}\n\nfloat boundingBox( in vec3 p, in vec3 r, out bool f )\n{\n\tconst float o = 0.03;\n    f = false;\n    if ( abs( p.x ) > r.x ) return udBox( p, r - o );\n\tif ( abs( p.y ) > r.y ) return udBox( p, r - o );\n\tif ( abs( p.z ) > r.z ) return udBox( p, r - o );\n    //if ( dot(step(r,abs(p)),vec3(1.0))>0.0 ) return udBox( p, r - o );\n\tf = true;\n    //return length( p );\n    return 1.0;\n}\n\n/*\nfloat triangleDE( in vec3 p, in vec3 a, in vec3 b, in vec3 c )\n{\n    vec3 ab = b - a;\n    vec3 bc = c - b;\n    vec3 ca = a - c;\n    vec3 ap = p - a;\n    vec3 bp = p - b;\n    vec3 cp = p - c;\n    vec3 n = cross( ab, -ca ) ;\n    if ( dot( cross( n, ab ), ap ) < 0.0 )\n    {        \n        float t = clamp( dot( ab, ap ) / dot( ab, ab ), 0.0, 1.0 );        \n        return length( vec3( t * ab - ap ) );\n    }\n    if ( dot( cross( n, bc ), bp ) < 0.0 )\n    {\n        float t = clamp( dot( bc, bp ) / dot( bc, bc ), 0.0, 1.0 );        \n        return length( vec3( t * bc - bp ) );\n    }\n    if ( dot( cross( n, ca ), cp ) < 0.0 )\n    {\n        float t = clamp( dot( ca, cp ) / dot( ca, ca ), 0.0, 1.0 );        \n        return length( vec3( t * ca - cp ) );\n    }\n    return abs( dot( normalize( n ), ap ) );\n}\n*/\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat udTriangle( in vec3 p, in vec3 v1, in vec3 v2, in vec3 v3 )\n{\n    vec3 v21 = v2 - v1; vec3 p1 = p - v1;\n    vec3 v32 = v3 - v2; vec3 p2 = p - v2;\n    vec3 v13 = v1 - v3; vec3 p3 = p - v3;\n    vec3 nor = cross( v21, v13 );\n\n    return sqrt((min( min(dot(cross(v21,nor),p1),dot(cross(v32,nor),p2)),dot(cross(v13,nor),p3))<0.0) \n                  ?\n                  min( min( \n                  dot2(v21*clamp(dot(v21,p1)/dot2(v21),0.0,1.0)-p1), \n                  dot2(v32*clamp(dot(v32,p2)/dot2(v32),0.0,1.0)-p2) ), \n                  dot2(v13*clamp(dot(v13,p3)/dot2(v13),0.0,1.0)-p3) )\n                  :\n                  dot(nor,p1)*dot(nor,p1)/dot2(nor) );\n    /*\n    return sqrt( (sign(dot(cross(v21,nor),p1)) + \n                  sign(dot(cross(v32,nor),p2)) + \n                  sign(dot(cross(v13,nor),p3))<2.0) \n                  ?\n                  min( min( \n                  dot2(v21*clamp(dot(v21,p1)/dot2(v21),0.0,1.0)-p1), \n                  dot2(v32*clamp(dot(v32,p2)/dot2(v32),0.0,1.0)-p2) ), \n                  dot2(v13*clamp(dot(v13,p3)/dot2(v13),0.0,1.0)-p3) )\n                  :\n                  dot(nor,p1)*dot(nor,p1)/dot2(nor) );\n\t*/\n}\n\nfloat udQuad( in vec3 p, in vec3 v1, in vec3 v2, in vec3 v3, in vec3 v4 )\n{\n    vec3 v21 = v2 - v1; vec3 p1 = p - v1;\n    vec3 v32 = v3 - v2; vec3 p2 = p - v2;\n    vec3 v43 = v4 - v3; vec3 p3 = p - v3;\n    vec3 v14 = v1 - v4; vec3 p4 = p - v4;\n    vec3 nor = cross( v21, v14 );\n\n    return sqrt( (sign(dot(cross(v21,nor),p1)) + \n                  sign(dot(cross(v32,nor),p2)) + \n                  sign(dot(cross(v43,nor),p3)) + \n                  sign(dot(cross(v14,nor),p4))<3.0) \n                  ?\n                  min( min( min( \n                  dot2(v21*clamp(dot(v21,p1)/dot2(v21),0.0,1.0)-p1), \n                  dot2(v32*clamp(dot(v32,p2)/dot2(v32),0.0,1.0)-p2) ), \n                  dot2(v43*clamp(dot(v43,p3)/dot2(v43),0.0,1.0)-p3) ),\n                  dot2(v14*clamp(dot(v14,p4)/dot2(v14),0.0,1.0)-p4) )\n                  :\n                  dot(nor,p1)*dot(nor,p1)/dot2(nor) );\n}\n\nstruct Mesh\n{\n    vec3 a;\n    vec3 b;\n    vec3 c;\n    vec3 d;\n};\n\nconst float sepT = 4.0;\nconst float sepR = 6.0;\nconst float radT = 0.2;\nconst float radR = 0.5;   \n    \nMesh genTorus( in int idx )\n{\n    float thetaT = PI2 / sepT;\n    float thetaR = PI2 / sepR;\n    float i = float( idx );\n    float idT = mod( i, sepT );\n    vec3 vt0 = vec3( radT, 0.0, 0.0 );\n    vec3 vt1 = vec3( radT, 0.0, 0.0 );\n    vt0.xy = rotate( vt0.xy, idT * thetaT );\n    vt1.xy = rotate( vt1.xy, ( idT + 1.0 ) * thetaT );\n    vt0.x += radR;\n    vt1.x += radR;\n    float idR = floor( i / sepT );\n    vec3 v0 = vt0;\n    vec3 v1 = vt1;\n    vec3 v2 = vt0;\n    vec3 v3 = vt1;\n    v0.zx = rotate( v0.zx, idR * thetaR );\n    v1.zx = rotate( v1.zx, idR * thetaR );\n    v2.zx = rotate( v2.zx, ( idR + 1.0 ) * thetaR );\n    v3.zx = rotate( v3.zx, ( idR + 1.0 ) * thetaR );\n    //if (idx < int( sepT * sepR ) ) return Mesh( v0, v1, v2 );\n    //return Mesh( v2, v3, v1 );\n    return Mesh( v1, v0, v2, v3 );\n}\n\n/*\n\nvec3 calcNormal( in vec3 p )\n{\n\tconst vec2 e = vec2( 0.0001, 0.0 );\n\tvec3 n = vec3(\n\t\tmap( p + e.xyy ) - map( p - e.xyy ),\n\t\tmap( p + e.yxy ) - map( p - e.yxy ),\n\t\tmap( p + e.yyx ) - map( p - e.yyx ) );\n\treturn normalize( n );    \n}\n\nfloat map( in vec3 p )\n{\n    bool f;\n    float d = boundingBox( p, vec3( 0.72, 0.22, 0.72 ), f );\n    if ( f )\n    { \n        for ( int i = 0; i < 30; i++ )\n    \t{\n            Mesh m = genTorus( i );\n            d = min( udQuad( p, m.a, m.b, m.c, m.d ), d );\n        }\n        d -= 0.001;\n    }\n    vec3 a = vec3(0.0, 1.0, 0.0);\n    vec3 b = vec3(1.5, 0.0, 0.0);\n    vec3 c = vec3(0.0, -1.0, 0.0);\n    return min( d, udTriangle( p, a, b, c ) - 0.001 ); \n}\n*/\n\nvec3 calcNormal( in vec3 p, in vec3 v1, in vec3 v2 )\n{\n    return normalize( cross(  v2 - v1, p - v1 ) );\n}\n    \nfloat map( in vec3 p, out vec3 nor )\n{\n    bool f;\n    vec3 v1 = vec3( 0.0 );\n    vec3 v2 = vec3( 0.0 );\n    nor = vec3( 0.0 );\n    float de = boundingBox( p, vec3( 0.72, 0.22, 0.72 ), f );\n    if ( f )\n    { \n        for ( int i = 0; i < int(sepT*sepR); i++ )\n    \t{\n            Mesh m = genTorus( i );\n            float d0 = udQuad( p, m.a, m.b, m.c, m.d );\n            if ( d0 < de )\n            {\n              de = d0;\n              v1 = m.a;\n              v2 = m.b;\n            }\n        }\n        de -= 0.001;\n    }\n    vec3 t1 = vec3(1.5, 0.0, 0.0);\n    vec3 t2 = vec3(0.0, 1.0, 0.0);\n    vec3 t3 = vec3(0.0, -1.0, 0.0);\n    float d0 = udTriangle( p, t1, t2, t3 ) - 0.001;\n    if ( d0 < de )\n    {\n    \tde = d0;\n        v1 = t1;\n        v2 = t2;       \n    }\n    vec3 q1 = vec3(0.0, 0.0, 0.0);\n    vec3 q2 = vec3(-1.0, 0.8, 0.0);\n    //vec3 q3 = vec3(-1.2 + 0.5 * sin(iTime), 0.0, 0.0); // concave quad\n    vec3 q3 = vec3(-1.2, 0.0, 0.0);\n    vec3 q4 = vec3(-1.0, -0.8, 0.0);\n    float d1 = udQuad( p, q1, q2, q3, q4 ) - 0.001;\n    if ( d1 < de )\n    {\n        de = d1;\n        v1 = q1;\n        v2 = q2;       \n    }\n    nor = calcNormal( p, v1, v2 );\n    return de; \n}\n\n\nfloat march( in vec3 ro, in vec3 rd, out vec3 nor )\n{\n\tconst float maxd = 5.0;\n\tconst float precis = 0.001;\n    float h = precis * 2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for( int i = 0; i < 48; i++ )\n    {\n        if( h < precis || t > maxd ) break;\n\t    //h = map( ro + rd * t );\n\t    h = map( ro + rd * t, nor );\n        t += h;\n    }\n    if( t < maxd ) res = t;\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = ( 2.0 * fragCoord.xy - iResolution.xy ) / iResolution.y;\n\tvec3 col = vec3( 0.4 + 0.15 * p.y );\n   \tvec3 rd = normalize( vec3( p, -1.8 ) );\n\tvec3 ro = vec3( 0.0, 0.0, 3.0 );\n    vec3 light = normalize( vec3( 0.5, 0.8, 3.0 ) );\n    vec3 rot = vec3( 0.3, 0.5 * iTime, 0.4 );\n    ro = rotate( ro, rot );\n\trd = rotate( rd, rot );\n\tlight = rotate( light, rot );\n    vec3 n;\n    //float t = march( ro, rd );\n    float t = march( ro, rd, n );\n    if( t > -0.1 )\n    {\n        //vec3 pos = ro + t * rd;\n        //vec3 n = calcNormal( pos );\n        float br = dot( n, light ) ;\n\t\tcol = vec3( 1.0, 0.8, 0.5 );\n        //float side = dot( n, rotate( vec3(0.0, 0.0, 1.0 ), rot));\n        float side = dot( n, -rd);\n        if (side < 0.0) // reverse\n        {\n            col = vec3( 0.5, 0.5, 1.0 );\n            br *= -1.0;\n            // br = abs( br );\n        }\n        br = clamp( ( br + 0.5 ) * 0.7, 0.3, 1.0 );\n        col*=  br; \n\t}\n   \tfragColor = vec4( vec3( col ), 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ld2Szh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 89, 89, 146], [152, 152, 189, 189, 298], [300, 300, 337, 337, 383], [385, 385, 440, 440, 762], [1580, 1580, 1605, 1605, 1624], [1626, 1626, 1693, 1693, 2795], [2797, 2797, 2872, 2872, 3692], [3864, 3864, 3893, 3893, 4668], [5368, 5368, 5422, 5422, 5475], [5481, 5481, 5519, 5519, 6658], [6661, 6661, 6714, 6714, 7051], [7053, 7053, 7110, 7110, 8093]], "test": "ok"}
{"id": "ldfGzM", "name": "Autumn Morning Lego Trees", "author": "baldand", "description": "Simple landscape populated with vaguely tree like objects. Mist/fog/clouds to give a bit of atmosphere.", "tags": ["procedural", "3d", "raymarching", "distancefield"], "likes": 13, "viewed": 645, "published": "Public", "date": "1409292949", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Copyright (c) 2014 Andrew Baldwin (baldand)\n// License = Attribution-ShareAlike 4.0 International (CC BY-SA 4.0) (http://creativecommons.org/licenses/by-sa/4.0/)\n\n#define SHADOW\n#define AO\n\nfloat rnd(vec2 n)\n{\n  return fract(sin(dot(n.xy, vec2(12.345,67.891)))*12345.6789);\n}\n\nfloat rnd2(vec3 n)\n{\n  return fract(sin(dot(n.xyz, vec3(12.345,67.891,40.123)))*12345.6789);\n}\n\n\nfloat saw(float t)\n{\n\treturn abs(fract(t*.5)*2.-1.)*2.-1.;\n}\n\nfloat obj(vec3 pos, vec3 opos)\n{\n\tpos *= vec3(1.,.5,1.);\n\tvec3 coord = floor(pos);\n\tcoord = vec3(coord.x,0.,coord.z);\n\tvec3 f = fract(pos);\n\tvec3 diff = vec3(1.,0.,0.);\n\tfloat tl = rnd(coord.xz);\n\tfloat ltl = length(pos-coord);\n\tfloat tr = rnd(coord.xz+diff.xz);\n\tfloat ltr = length(pos-coord-diff);\n\tfloat bl = rnd(coord.xz+diff.yx);\n\tfloat lbl = length(pos-coord-diff.yyx);\n\tfloat br = rnd(coord.xz+diff.xx);\n\tfloat lbr = length(pos-coord-diff.xyx);\n\tfloat b = .25*(ltl+ltr+lbl+lbr)-0.;\n    f = f*f*(3.0-2.0*f);\n\tfloat off = .5*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.z);\n\tb = min(min(ltl-off,ltr-off),min(lbl-off,lbr-off));\n\t\n\tvec3 opos1 = opos*10.;\n\tvec3 fopos = floor(opos1);\n\tb = max(b,-.1*length(opos1-.5-fopos)+.05);\n\tvec3 opos2 = opos*13.21873;\n\tfopos = floor(opos2);\n\tb = max(b,-length(opos2-.5-fopos)/13.21873+.05);\n\t\n\treturn b;\n}\n\nfloat height(vec3 pos) \n{\n\treturn -10.*sin(.06*((pos.x+.5)))*sin(.05*((pos.z+.5)))-30.*sin(.01*(pos.x+.5))*sin(.01*(pos.z+.5));\n}\n\nfloat gridheight(vec3 pos)\n{\n\treturn -10.*sin(.06*floor((pos.x+.5)))*sin(.05*floor((pos.z+.5)))-30.*sin(.01*floor(pos.x+.5))*sin(.01*floor(pos.z+.5));\n}\n\nvec3 map(vec3 pos, float time)\n{\n\tvec3 floorpos = pos;\n\tfloorpos.y -= height(pos);\n\tvec3 res = vec3(floorpos.y+1.,0.,0.0);\n\tif (floorpos.y<3.) {\n\t\tvec3 opos = pos;\n\t\tpos.y -= gridheight(pos);\n\t\tfloat b = obj(pos,opos);\n\t\tfloat b2 = 0.;\n\t\tb = max(b,b2);\n\t\tif (b<res.x) {\n\t\t\tres.x = b;\n\t\t\tres.y = 1.;\n\t\t}\n\t} else {\n\t\tres.x = max(floorpos.y-10000.,1.);\n\t\tres.y = 4.;\n\t}\n\tres.z = floorpos.y;\n\treturn res;\n}\n\nvec3 normal(vec3 pos, float time)\n{\n\tvec3 eps = vec3(0.001,0.,0.);\n\tfloat dx = map(pos+eps.xyy,time).x;\n\tfloat dy = map(pos+eps.yxy,time).x;\n\tfloat dz = map(pos+eps.yyx,time).x;\n\tfloat mdx = map(pos-eps.xyy,time).x;\n\tfloat mdy = map(pos-eps.yxy,time).x;\n\tfloat mdz = map(pos-eps.yyx,time).x;\n\treturn normalize(vec3(dx-mdx,dy-mdy,dz-mdz));\n}\n\nvec3 model(vec3 rayOrigin, vec3 rayDirection,float time)\n{\n\tfloat t = 0.;\n\tvec3 p;\n\tfloat d = 2.;\n\tbool nothit = true;\n\tvec3 r;\n\tfloat scatter = 0.;\n    \n    vec3 sundir = normalize(vec3(cos(0.1),sin(0.1),0.4));\n    vec3 skycol = vec3(0.13,.2,.6); \n\tfloat sun = clamp(dot(sundir,rayDirection),0.0,1.0);\n    skycol = 0.75*mix(vec3(.3,.3,.1),skycol,.95+.05*sun)+vec3(1.0,0.8,0.7)*pow(sun,16.0);\n    \n\tfor (int i=0;i<2000;i++) {\n\t\tif (nothit) {\n\t\t\tt += min(d*.5,10.);\n\t\t\tp = rayOrigin + t * rayDirection;\n\t\t\tr = map(p,time);\n            scatter += d*5.*clamp(-p.y+2.-r.z,0.,1.)\n                     + d*.2*clamp(p.y+5.+r.z-10.,0.,1.)\n                \t + d*.5\n                \t + d*1.*clamp(\n                         0.01*r.z*(sin((p.x+r.z)*.05))\n                        + (sin( (p.y+r.z*.5)*.1)) * (sin(r.z*.3))\n                         ,0.0,10.0)*clamp(p.y-150.+r.z,0.0,5.0);\n\t\t\td = r.x;\n\t\t\tnothit = d>t*.001 && t<100000.;\n\t\t}\n\t}\n\tt += d*.5;\n\tp = rayOrigin + t * rayDirection;\n\tvec3 n = normal(p,time);\n\tfloat lh = abs(fract(iTime*.1)*2.-1.);\n\tlh = 79.*lh*lh*(3.-2.*lh);\n\tvec3 lightpos = p+sundir;\n\tvec3 lightdist = lightpos - p;\n\tfloat light = 2.+dot(lightdist,n)*1./length(lightdist);\n#ifdef AO\n\t// AO\n\tfloat at = 0.4;\n\tfloat dsum = d;\n\tvec3 ap;\n\tfor (int i=0;i<4;i++) {\n\t\tap = p + at * n;\n\t\tdsum += map(ap,time).x/(at*at);\n\t\tat += 0.1;\n\t}\n\tfloat ao = clamp(dsum*.1,0.,1.);\n\tlight = light*ao;\n#endif\n#ifdef SHADOW\n\t// March for shadow\n\tvec3 s;\n\tfloat st;\n\tfloat sd=0.;\n\tfloat sh=1.;\n\tst=.3;//+.5*rnd2(p+.0123+fract(iTime*.11298923));\n\tvec3 shadowRay = normalize(sundir);\n\tnothit = true;\n\tfor (int i=0;i<10;i++) {\n\t\tif (nothit) {\n\t\t\tst += sd*.5;\n\t\t\ts = p + st * shadowRay;\n\t\t\tsd = map(s,time).x;\n\t\t\tsh = min(sh,sd);\n\t\t\tnothit = sd>0.00001;\n\t\t}\n\t}\n\tlight = 5.0*light * clamp(sh,0.1,1.);\n#endif\n\tvec3 m;\n\tm=.5+.2*abs(fract(p)*2.-1.);\n\tm=mix(vec3(.05,.15,.03),vec3(.25,.1,.03),rnd(floor(p.xz*.5)));\n\tif (r.y==0.) {\n\t\tm=vec3(.08,0.05,0.01);\n\t} else if (r.y==2.) {\n\t\tm=.3+vec3(m.x+m.y+m.z)*.333;\n\t} else if (r.y==3.) {\n\t\tm=vec3(1.,0.,0.);\n\t} else if (r.y==4.) {\n\t\tm=skycol;\n\t}\n\tvec3 c = vec3(clamp(1.*light,0.,10.))*vec3(m)+vec3(scatter*.001);\n\treturn c; \n}\n\nvec3 camera(in vec2 sensorCoordinate, in vec3 cameraPosition, in vec3 cameraLookingAt, in vec3 cameraUp)\n{\n\tvec2 uv = 1.-sensorCoordinate;\n\tvec3 sensorPosition = cameraPosition;\n\tvec3 direction = normalize(cameraLookingAt - sensorPosition);\n\tvec3 lensPosition = sensorPosition + 2.*direction;\n\tconst vec2 lensSize = vec2(1.);\n    vec2 sensorSize = vec2(iResolution.x/iResolution.y,1.0);\n\tvec2 offset = sensorSize * (uv - 0.5);\n\tvec3 right = cross(cameraUp,direction);\n\tvec3 rayOrigin = sensorPosition + offset.y*cameraUp + offset.x*right;\n\tvec3 rayDirection = normalize(lensPosition - rayOrigin);\n\tvec3 colour = vec3(0.);\n\tcolour = 2.*max(model(rayOrigin, rayDirection,iTime),vec3(0.));\n\tcolour = colour/(1.+colour);\n    return colour;\n}\n\t\t\nvec3 world(vec2 fragCoord)\n{\n\t// Position camera with interaction\n\tfloat anim = saw(iTime*.1);\n\tfloat rotspeed = .75+10.*iMouse.x/iResolution.x;\n\tfloat radius = (1.+anim+iMouse.y/iResolution.y)*10.;//10.+5.*sin(iTime*.2);\n    float speed = 0.5;\n    float time = speed*iTime;\n\tvec3 base = vec3(time*3.71,0.,time*5.);\n    float up = 0.;\n    if (iMouse.z>1.) up = 4.0*iMouse.y/iResolution.y-2.0;\n\tvec3 cameraTarget = vec3(0.,0.,0.)+base+vec3(sin(rotspeed)*cos(up),sin(up),cos(rotspeed)*cos(up));\n\tvec3 cameraPos = vec3(0.0)+base;//radius*sin(rotspeed),0.,radius*cos(rotspeed))+base;\n\tfloat h = height(cameraPos)+2.;\n\tcameraTarget.y += h;\n\tcameraPos.y += h;\n\tvec3 cameraUp = vec3(0.,1.,0.);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\treturn camera(uv,cameraPos,cameraTarget,cameraUp);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4(world(fragCoord),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldfGzM.jpg", "access": "shaders20k", "license": "cc-by-4.0", "functions": [[193, 193, 212, 212, 278], [280, 280, 300, 300, 374], [377, 377, 397, 397, 437], [439, 439, 471, 471, 1276], [1278, 1278, 1303, 1303, 1407], [1409, 1409, 1437, 1437, 1561], [1563, 1563, 1595, 1595, 1965], [1967, 1967, 2002, 2002, 2307], [2309, 2309, 2367, 2367, 4460], [4462, 4462, 4568, 4568, 5199], [5203, 5203, 5231, 5268, 5985], [5987, 5987, 6044, 6044, 6086]], "test": "ok"}
{"id": "ldfXWl", "name": "Beautypi's Creepy Eye", "author": "SNce", "description": "Recreated from iq's video.", "tags": ["fbmbeautypi"], "likes": 0, "viewed": 216, "published": "Public", "date": "1407844865", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float noise(in vec2 pos)\n{\n    //return fract(sin(dot(pos ,vec2(12.9898,78.233))) * 43758.5453);\n    return fract( sin( dot(pos*0.001 ,vec2(24.12357, 36.789) ) ) * 12345.123);\n}\n\nfloat smooth_noise(vec2 pos)\n{\n    float corners = (noise(vec2(pos.x-1.0, pos.y-1.0)) + \n                    noise(vec2(pos.x+1.0, pos.y-1.0)) + \n                    noise(vec2(pos.x-1.0, pos.y+1.0)) + \n                   \tnoise(vec2(pos.x+1.0, pos.y+1.0)))/16.0;\n                          \n\tfloat sides = (noise(vec2(pos.x-1.0, pos.y)) + noise(vec2(pos.x+1.0, pos.y)) +\n                  noise(vec2(pos.x, pos.y-1.0)) + noise(vec2(pos.x, pos.y+1.0))) / 8.0;\n                          \n\tfloat centre = noise(vec2(pos.x,pos.y)) / 4.0;\n    \n    return centre + sides + corners;                                \n}\n\nfloat interpolate_noise(vec2 pos)\n{\n\tfloat a, b, c, d;\n    \n    a = smooth_noise(floor(pos));\n    b = smooth_noise(vec2(floor(pos.x+1.0), floor(pos.y)));\n    c = smooth_noise(vec2(floor(pos.x), floor(pos.y+1.0)));\n    d = smooth_noise(vec2(floor(pos.x+1.0), floor(pos.y+1.0)));\n    \n    a = mix(a, b, fract(pos.x));\n    b = mix(c, d, fract(pos.x));\n    a = mix(a, b, fract(pos.y));\n    \n    return a;\n}\n\nfloat fbm_interpolated(vec2 pos)\n{\n    float f = 0.0;\n    \n    f += 0.5000 * interpolate_noise(pos); pos *= 0.203;\n    f += 0.2500 * interpolate_noise(pos); pos *= 0.202;\n    f += 0.1250 * interpolate_noise(pos); pos *= 0.201;\n    f += 0.0625 * interpolate_noise(pos); pos *= 0.204;\n    f /= 0.9375;\n    \n    return f;\n}\n\nfloat fbm(vec2 pos)\n{\n    float f = 0.0;\n    \n    f += 0.5000 * smooth_noise(pos); pos *= 0.203;\n    f += 0.2500 * smooth_noise(pos); pos *= 0.202;\n    f += 0.1250 * smooth_noise(pos); pos *= 0.201;\n    f += 0.0625 * smooth_noise(pos); pos *= 0.204;\n    f /= 0.9375;\n    \n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy;\n\tvec2 uv = pos / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    \n    float a = atan(p.y, p.x);\n    \n    p.x *= iResolution.x / iResolution.y;\n    \n    vec3 color = vec3(1.0);\n    \n    float r = sqrt(dot(p, p));\n    \n    float ss = 0.5 + 0.5*sin(4.0 * iTime);\n    float anim = 1.0 + 0.1* ss * clamp(1.0-r, 0.0, 1.0);\n    r *= anim;\n    \n    if(r < 0.8)\n    {\n        color = vec3(0.0, 0.3, 0.4);\n        float f = fbm_interpolated(15.0 * p);\n        color = mix(color, vec3(0.2, 0.5, 0.4), f);\n        \n        f = 1.0 - smoothstep(0.2, 0.5, r);\n        color = mix(color, vec3(0.9, 0.4, 0.2), f);\n        \n        a += 0.1 + fbm_interpolated(6.0 * p);\n        \n        f = smoothstep(0.3, 1.0, fbm_interpolated(vec2(6.0*r, 20.0*a)));\n        color = mix(color, vec3(1.0), f);\n        \n        f = smoothstep(0.4, 0.9, fbm_interpolated(vec2(8.0*r, 45.0*a)));\n        color *= 1.0 - f;\n        \n        f = smoothstep(0.5, 0.95, r);\n        color *= 1.0 - 0.5 * f;\n        \n        f = smoothstep(0.2, 0.25, r);\n        color *= f;\n        \n        f = 1.0 - smoothstep(0.0, 0.5, length(p - vec2(0.3, 0.3)));\n        color += vec3(1.0, 0.9, 0.8) * f * 0.9;\n        \n        f = smoothstep(0.75, 0.8, r);\n        color = mix(color, vec3(1.0), f);\n    }\n    \n    fragColor = vec4(color, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldfXWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 96, 177], [179, 179, 209, 209, 788], [790, 790, 825, 825, 1192], [1194, 1194, 1228, 1228, 1514], [1516, 1516, 1537, 1537, 1803], [1805, 1805, 1862, 1862, 3186]], "test": "timeout"}
{"id": "ldjXz1", "name": "Voxel Saturn", "author": "gaz", "description": "voxel", "tags": ["distancefunction", "voxel"], "likes": 38, "viewed": 840, "published": "Public", "date": "1409240300", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Reference\n// https://www.shadertoy.com/view/MdBGRm\n// https://www.shadertoy.com/view/4dX3zl\n\nfloat sdSphere(in vec3 p, in float d )\n{\n    return length( p ) - d; \n} \n\nfloat sdTorus( in vec3 p, in vec2 t )\n{\n  vec2 q = vec2( length( p.xz ) - t.x, p.y );\n  return length( q ) - t.y;\n}\n\nfloat map( in vec3 p )\n{\n    return min(sdSphere( p, 1.0 ), sdTorus( p, vec2( 1.5, 0.2 ) ));\n}\n\nvec2 rotate( in vec2 p, in float t )\n{\n\treturn p * cos( -t ) + vec2( p.y, -p.x ) * sin( -t );\n}   \n\nvec3 rotate( in vec3 p, in vec3 t )\n{\n    p.yz = rotate( p.yz, t.x );\n    p.zx = rotate( p.zx, t.y );\n\tp.xy = rotate( p.xy, t.z );\n    return p;\n}\n\nvec3 hsv(float h, float s, float v)\n{\n  return mix( vec3( 1.0 ), clamp( ( abs( fract(\n    h + vec3( 3.0, 2.0, 1.0 ) / 3.0 ) * 6.0 - 3.0 ) - 1.0 ), 0.0, 1.0 ), s ) * v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = ( 2.0 * fragCoord.xy - iResolution.xy ) / iResolution.y;\n    vec3 rd =normalize( vec3( p, -1.8 ) );\n\tvec3 ro = vec3( 0.0, 0.0, 3.0 );\n    vec3 rot = vec3( 0.5, iTime * 0.3, iTime * 0.2 );\n\tro = rotate( ro, rot );\n\trd = rotate( rd, rot );       \n    float s = 10.0;\n    ro *= s;\n  \tvec3 grid = floor( ro );\n\tvec3 grid_step = sign( rd );\n\tvec3 delta = ( -fract( ro ) + 0.5 * ( grid_step + 1.0 ) ) / rd;    \n\tvec3 delta_step =  1.0 / abs( rd );\n\tvec3 mask = vec3( 0.0 );\n    vec3 pos;\n    bool hit = false;\n\tfor ( int i = 0; i < 96; i++ )\n    {\n        pos = ( grid + 0.5 ) / s;\n\t\tif ( map( pos ) < 0.0 ) \n       \t{\n           \thit = true;\n           \tbreak;\n        }\n\t\tvec3 c = step( delta, delta.yzx );\n\t\tmask = c * ( 1.0 - c.zxy );\n\t\tgrid += grid_step * mask;\t\t\n\t\tdelta += delta_step * mask;\n\t}\n    vec3 col = vec3( 0.4 + 0.15 * p.y );\n    if ( hit )\n    {\n        col = hsv( 0.2 * length( pos ) + 0.03 * iTime, 0.6, 1.0 );        \n\t    float br = dot( vec3( 0.5, 0.9, 0.7 ), mask );\n        float depth = dot( delta - delta_step, mask );\n \t\tfloat fog = min( 1.0, 300.0 / depth / depth );       \n        vec3 uvw = fract( ro + rd * depth );\n        vec2 uv = vec2( dot( uvw.yzx, mask ), dot( uvw.zxy, mask ) );\n        uv = abs( uv - vec2( 0.5 ) );\n        float gr = 1.0 - 0.1 * smoothstep( 0.4, 0.5, max( uv.x, uv.y ) );\n        col *= br * fog * gr;\n               \n    }\n\tfragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldjXz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[96, 96, 136, 136, 167], [170, 170, 209, 209, 285], [287, 287, 311, 311, 381], [383, 383, 421, 421, 478], [483, 483, 520, 520, 629], [631, 631, 668, 668, 800], [802, 802, 859, 859, 2278]], "test": "ok"}
{"id": "ldlSW2", "name": "glenzy", "author": "rlx", "description": "A remake of an old demo effect.\nThis was a main part of my Assembly 2014 1k intro.\nUnfortunately, the intro did not run properly on the compo machine and was disqualified :)\n", "tags": ["intro", "remake", "glenz"], "likes": 6, "viewed": 265, "published": "Public", "date": "1407068873", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 tc;\nfloat Cube( vec3 p )\n{\n    float Time = 2.1 + iTime*0.6;\n\ttc.x = sin( Time );\n\ttc.y = cos( Time );\n\tmat2 m = mat2( tc.y, -tc.x, tc.x, tc.y );\n\tp.xy *= m;\n\tp.xy *= m;\n\tp.yz *= m;\n\tp.zx *= m;\n\tp.zx *= m;\n\tp.zx *= m;\n\ttc = p;\n\treturn length( max( abs( p ) - 0.5, 0.0 ) );\n}\n\nfloat Text( vec2 uv )\n{\n\tuv.y = mod( uv.y, 1.0 );\n\treturn ( ( uv.y < uv.x ) != ( 1.0 - uv.y < uv.x ) ) ? 1.0 : 0.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 p = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\n\tp.x *= iResolution.x / iResolution.y;\n\n\n\tvec3 ro = vec3( 0.0, 0.0, 1.5 );\n\tvec3 rd = normalize( vec3( p, -1.0 ) );\n\n\tfloat Step = 1.0;\n\tfloat Distance = 0.0;\n\n\tfloat Near = -1.0;\n\tfloat Far = -1.0;\n    \n\tfor( int i = 0; i < 120; i++ )\n\t{\n\t\tif( Distance > 4.0 )\n\t\t\tbreak;\n\n\t\tif( Step < 0.001 )\n\t\t{\n\t\t\tFar = Text( tc.yx ) + Text( -tc.yx ) + Text( tc.xz ) + Text( -tc.xz ) + Text( tc.zy ) + Text( -tc.zy );\n\t\t\tDistance += 0.013;\n\n\t\t\tif( Near < 0.0 )\n\t\t\t{\n\t\t\t\tNear = Far;\n\t\t\t}\n\t\t}\n\n\n\n\t\tStep = Cube( rd*Distance + ro );\n\t\tDistance += Step;\n\t}\n\n\tvec3 Color = vec3( 0.0 );\n\n\tif( Near > 0.0 )\n\t{\n\t\tColor = mix( vec3( 1.0, 0.0, 0.0 ), vec3( 1.0, 1.0, 1.0 ), vec3( ( Near*0.45 + Far*Far*0.04 ) ) );\n\t}\n\n\tfragColor = vec4( Color, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldlSW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[9, 9, 31, 31, 279], [281, 281, 304, 304, 398], [401, 401, 458, 458, 1240]], "test": "ok"}
{"id": "ldsSW2", "name": "beauty heart", "author": "thu_yumeng", "description": "thanks iq,little improvement", "tags": ["heart", "reflect", "refract"], "likes": 2, "viewed": 217, "published": "Public", "date": "1407073231", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//thanks to iq's work\n#define ambientAmount 0.5\n#define shininess 300.0\n\nvec3 ldir;\n\nfloat Eta = 0.66; // Ratio of indices of refrection\n//fresnel F\nfloat F = 0.04195;//((1.0-Eta)*(1.0-Eta))/((1.0+Eta)*(1.0+Eta));\nfloat FresnelPower = 5.0;\n \nfloat heartH(vec2 p)\n{\n    //animate\n    float tt = mod(iTime, 1.5)/1.5;\n    float ss = pow(tt,.2)*0.5 + 0.5;\n    ss -= ss*0.2*sin(tt*6.2831*3.0)*exp(-tt*4.0);\n    \n    //shape\n    float a = atan(p.x,p.y)/3.141593;\n    float r = length(p);\n    float h = abs(a);\n    float d = (13.0*h-22.0*h*h+10.0*h*h*h)/(6.0-5.0*h);\n    \n    return smoothstep(-.01,1.01,d-r);\n}\n\nvec3 light(vec2 p,vec3 col)\n{\n    //reflection\n    vec2 d = vec2(0.,.003);\n    float d1 = heartH(p-d.xy)-heartH(p+d.xy);\n    float d2 = heartH(p-d.yx)-heartH(p+d.yx);\n    vec3 n1 = vec3(0.,d.y,d1);\n    vec3 n2 = vec3(d.y,0.,d2);\n    vec3 n = normalize(cross(n1,n2));\n    float diff = max(0.,dot(ldir,n))*.6;\n    vec3 r = reflect(vec3(.0,.0,1.0),ldir);\n    float spec = pow(max(0.,dot(r,n)),25.)*0.4;\n    \n    vec3 diff_col = diff*col;\n    vec3 spec_col = spec*col;\n    vec3 reflect_col = diff_col + spec_col;\n    \n    //refraction\n    vec3 v = vec3(0.,0.,2.) - vec3(p,heartH(p));\n    v = normalize(v);\n    vec3 lfrac = refract(ldir,n,Eta);\n    float ratio = F+(1.0-F)*pow((1.0-dot(v,n)),FresnelPower);\n    float interval = -1.0*(heartH(p)/lfrac.z);\n    p = interval*p;\n    vec3 refract_col = vec3(1.0,0.8,0.7-0.07*p.y)*(1.0-0.25*length(p));\n    \n    return mix(refract_col,reflect_col,ratio);\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy)/min(iResolution.y,iResolution.x);\n\t\n\tp.y -= 0.25;\n\n    // background color\n    vec3 bcol = vec3(1.0,0.8,0.7-0.07*p.y)*(1.0-0.25*length(p));\n\n    // animate\n    float tt = mod(iTime,1.5)/1.5;\n    float ss = pow(tt,.2)*0.5 + 0.5;\n    ss -= ss*0.2*sin(tt*6.2831*3.0)*exp(-tt*4.0);\n    p *= vec2(0.5,1.5) + ss*vec2(0.5,-0.5);\n   \n\n    // shape\n    float a = atan(p.x,p.y)/3.141593;\n    float r = length(p);\n    float h = abs(a);\n    float d = (13.0*h - 22.0*h*h + 10.0*h*h*h)/(6.0-5.0*h);\n\n\t// c  olor\n\tfloat s = 1.0-0.5*clamp(r/d,0.0,1.0);\n\ts = 0.75 + 0.75*p.x;\n\ts *= 1.0-0.25*r;\n\ts = 0.5 + 0.6*s;\n\ts *= 0.5+0.5*pow( 1.0-clamp(r/d, 0.0, 1.0 ), 0.1 );\n\tvec3 hcol = vec3(1.0,0.5*r,0.3)*s;\n\t\n    vec3 col = mix( bcol, hcol, smoothstep(-.01,0.4,d-r) );\n    \n    //lighting\n    vec3 lightPos = vec3(0.8,.2,2.0); \n    ldir = normalize(vec3(p,heartH(p))-lightPos);\n    col = light(p,col)*.01+col*.9;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldsSW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[242, 242, 264, 278, 604], [606, 606, 635, 652, 1505], [1508, 1508, 1565, 1565, 2533]], "test": "ok"}
{"id": "ldsXDs", "name": "Tiny Ray Marcher 2.0", "author": "Aaro", "description": "Its so small and cute!<br/><br/>now contains shadows", "tags": ["ray", "shadow", "tiny", "marcher"], "likes": 3, "viewed": 304, "published": "Public", "date": "1408026717", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Minimal Ray Marcher by Aaro Permaa (and some other shadertoyers, Lanza, Andre and Ben)\n\n//So, here is the smallest ray marcher i could make (that has shading and shadows) it is 35 lines\n//and has 342 characters, 47 LESS than my shadowless version. Performance with this renderer\n//is awful, partially becouse it doesnt contain break; statement.\n//Smooth shadow algorithm by IQ, major improvements by Lanza, Andre and Ben\n\n#define R iResolution\n#define T iTime\nvoid mainImage(out vec4 C,vec2 G)\n{\n    vec3 u=(2.*vec3(G.xy,0)-R)/R.y;\n    float t=0.,r=1.,c=t,h=3.;\n    u.z=r;\n    vec3 o=u,p=u,q=vec3(7,abs(sin(T*h)),3),l=q.zxz;\n    q.x=t;\n    for(int i=0;i<99;i++)\n    {\n        p=u*t+o;\n        h=min(length(p-q)-1.,p.y+1.);\n        i>63 ?r=min(r,8.*h/t):h<.001 ? c=5./length(p-l):t;\n        t+=h; \n        if(i==45){\n            o=p;\n            u=normalize(l-o);\n            t=.1;\n        }\n    }\n    C=vec4(c*r);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldsXDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[466, 466, 501, 501, 921]], "test": "ok"}
{"id": "ldsXWj", "name": "dizzyCircles", "author": "gcorallo", "description": "circles, fullscreen is better / a pantalla completa funciona mejor.", "tags": ["circles", "sin", "cos", "harmonic"], "likes": 7, "viewed": 202, "published": "Public", "date": "1407028361", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec4 color;\n    vec2 pos = fragCoord.xy;\n    \n    float r = 0.0;\n    float g = 0.0;\n    float b = 0.0;\n    \n    \n    for(float i=0.0; i<10.0; i++){\n    \n        vec2 center = vec2(sin(iTime*2.0+i*10.0)*iResolution.x*0.01*i+iResolution.x*0.5, \n                        cos(iTime*2.0+i*10.0)*iResolution.y*0.01*i+iResolution.x*0.25);\n\t    \n        float dist = distance (pos, center);     \n        \n        r+= sin(dist/10.0+iTime);\n    \tg+= cos(dist/10.0-iTime*1.1);\n    \tb = 0.2-(r+g)*0.1;\n        r+=b*0.2;\n    }\n    \n    color= vec4 (r, g, b, 1.0);\n    \n\tfragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldsXWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 643]], "test": "ok"}
{"id": "ls2SRh", "name": "polygon raymarching", "author": "gaz", "description": "It don't run on Chrome on my PC. It run on FireFox on my PC. Why?\nother https://www.shadertoy.com/view/ld2Szh", "tags": ["raymarching", "polygon"], "likes": 3, "viewed": 241, "published": "Public", "date": "1409143978", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI\t3.14159265359\n#define PI2\t( PI * 2.0 )\n\nvec2 rotate( in vec2 p, in float t )\n{\n\treturn p * cos( -t ) + vec2( p.y, -p.x ) * sin( -t );\n}\n    \nvec3 rotate( in vec3 p, in vec3 t )\n{\n    p.yz = rotate( p.yz, t.x );\n    p.zx = rotate( p.zx, t.y );\n\tp.xy = rotate( p.xy, t.z );\n    return p;\n}\n\nfloat udBox( in vec3 p, in vec3 b)\n{\n\treturn length( max( abs( p ) - b, 0.0 ) );\n}\n\nfloat boundingBox( in vec3 p, in vec3 r, out bool f )\n{\n\tconst float o = 0.05;\n    f = false;\n\tif ( abs( p.x ) > r.x) return udBox( p, r - o );\n\tif ( abs( p.y ) > r.y) return udBox( p, r - o );\n\tif ( abs( p.z ) > r.z) return udBox( p, r - o );\n\tf = true;\n    return length( p );\n}\n\nfloat triangleDE( in vec3 p, in vec3 a, in vec3 b, in vec3 c  )\n{\n    vec3 ab = b - a;\n    vec3 bc = c - b;\n    vec3 ca = a - c;\n    vec3 ap = p - a;\n    vec3 bp = p - b;\n    vec3 cp = p - c;\n    vec3 n = cross( ab, -ca );\n    vec3 nab = cross( n, ab );\n    vec3 nbc = cross( n, bc );\n    vec3 nca = cross( n, ca );\n    if ( dot( nab, ap ) < 0.0 )\n    {        \n        float t = clamp( dot( ab, ap ) / dot( ab, ab ), 0.0, 1.0 );        \n        return length( vec3( t * ab - ap ) );\n    }\n    if ( dot( nbc, bp ) < 0.0 )\n    {\n        float t = clamp( dot( bc, bp ) / dot( bc, bc ), 0.0, 1.0 );        \n        return length( vec3( t * bc - bp ) );\n    }\n    if ( dot( nca, cp ) < 0.0 )\n    {\n        float t = clamp( dot( ca, cp ) / dot( ca, ca ), 0.0, 1.0 );        \n        return length( vec3( t * ca - cp ) );\n    }\n    return abs( dot( normalize( n ), ap ) );\n}\n\nstruct Mesh\n{\n    vec3 a;\n    vec3 b;\n    vec3 c;\n};\n    \nMesh genMesh( in int idx )\n{\n\tfloat t = PI2 / 8.0;\n    float i = float( idx );\n    vec3 a;\n    float t0, t1;\n    if ( idx < 8 )\n    {\n        a = vec3( 0.0, 0.0, 0.3 );\n        t0 = t * i;\n        t1 = t * ( i + 1.0 );\n    } else {\n        a = vec3( 0.0, 0.0, -0.3 );\n        t0 = t * ( i + 1.0 );\n        t1 = t * i;\n        i++;\n    }   \n    float r0 = mod( i, 2.0 ) * 0.5 + 0.5;\n    float r1 = mod( i + 1.0, 2.0 ) * 0.5 + 0.5;\n\tvec3 b = vec3( r0 * cos( t0 ), r0 * sin( t0 ), 0.0 );\n\tvec3 c = vec3( r1 * cos( t1 ), r1 * sin( t1 ), 0.0 );   \n\treturn Mesh( a, c, b );\n}\n\nfloat map(vec3 p)\n{    \n\tbool f;\n    float d = boundingBox( p, vec3( 1.0, 1.0, 0.35 ), f );\n    if ( f )\n    { \n        for ( int i = 0; i < 16; i++ )\n    \t{\n\t\t\tMesh m = genMesh( i );\n    \t\td = min( triangleDE( p, m.a, m.b, m.c ), d );\n    \t}\n        d -= 0.001;\n    }\n    return d; \n}\n\nvec3 calcNormal( in vec3 p )\n{\n\tconst vec2 e = vec2( 0.0001, 0.0 );\n\tvec3 n = vec3(\n\t\tmap( p + e.xyy ) - map( p - e.xyy ),\n\t\tmap( p + e.yxy ) - map( p - e.yxy ),\n\t\tmap( p + e.yyx ) - map( p - e.yyx ) );\n\treturn normalize( n );    \n}\n\nfloat march( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 10.0;\n\tconst float precis = 0.001;\n    float h = precis * 2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for( int i = 0; i < 64; i++ )\n    {\n        if( h < precis || t > maxd ) break;\n\t    h = map( ro + rd * t );\n        t += h;\n    }\n    if( t < maxd ) res = t;\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = ( 2.0 * fragCoord.xy - iResolution.xy ) / iResolution.y;\n\tvec3 col = vec3( 0.4 + 0.15 * p.y );\n   \tvec3 rd = normalize( vec3( p, -1.8 ) );\n\tvec3 ro = vec3( 0.0, 0.0, 3.0 );\n    vec3 light = normalize( vec3( 0.5, 0.8, 3.0 ) );\n    vec3 rot = vec3( 0.2, 0.5, 0.3 ) * iTime;\n    ro = rotate( ro, rot );\n\trd = rotate( rd, rot );\n\tlight = rotate( light, rot );\n    float t = march( ro, rd );\n    if( t > -0.1 )\n    {\n        vec3 pos = ro + t * rd;\n        vec3 n = calcNormal( pos );\n\t\tfloat diff = dot( n, light );\n        diff = clamp( ( diff + 0.5 ) * 0.7, 0.3, 1.0 );\n\t\tcol = vec3( 1.0, 0.6, 0.6 ) *  diff;\n\t}\n   \tfragColor = vec4( vec3( col ), 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ls2SRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 89, 89, 146], [152, 152, 189, 189, 298], [300, 300, 336, 336, 382], [384, 384, 439, 439, 664], [666, 666, 731, 731, 1534], [1594, 1594, 1622, 1622, 2163], [2165, 2165, 2184, 2184, 2450], [2452, 2452, 2482, 2482, 2684], [2686, 2686, 2725, 2725, 3027], [3029, 3029, 3086, 3086, 3750]], "test": "ok"}
{"id": "lsBSRR", "name": "The Disco Tunnel", "author": "poljere", "description": "2D tunnel with LEDs that react to music", "tags": ["2d", "tunnel", "reactive", "music", "leds"], "likes": 61, "viewed": 10308, "published": "Public API", "date": "1408689512", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float tex(vec2 uv, float s)\n{    \n    float col;\n    float ntiles = 10.0;\n    \n    // Calculate the shape of the LEDs\n    vec2 r = mod(uv * ntiles, 1.0) - vec2(0.5);\n    col = 1.0 - dot(r, r);\n    \n    // Add some light to the tunnel\n    vec4 n = texture(iChannel1, floor(uv * ntiles) / ntiles);\n    col *= mod(n.r * n.g * n.b * s + iTime * 0.1 + clamp(s, 0.0, 0.6), 1.0);    \n    return clamp(col, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uv1 = uv * 2.0 - 1.0;\n    \n    uv1.x *= iResolution.x / iResolution.y;\n    \n    // Calculate new UV coordinates\n    vec2 center = vec2(0.0, 0.0) + \n        vec2(0.075*(0.5 + 0.5 * sin(iTime*4.0)),\n             0.05*(0.5 + 0.5 * sin(iTime*0.01 + 1.7)));\n    vec2 p = uv1 - center;\n    float r = length(p);\n    float a = atan(p.y, p.x) * 3.0 / 3.14;\n    vec2 uv2= vec2(1.0 / r + iTime*0.25, a);\n\n    // Read the sound texture\n    float sound = texture(iChannel2, vec2(0.01, 1.0 - r)).r;\n    sound = pow(sound, 1.5);\n    \n    // Calculate the colors\n    vec3 c1 = vec3(0.02, 0.1, 0.02);\n    vec3 c2 = mix( vec3(1.0, 0.6, 0.6), vec3(0.6, 0.6, 1.0), vec3(0.5 + 0.5 * sin(iTime*0.1)));\n    vec3 c  = mix(c1, c2, r);\n    vec3 coltunnel =  sound * c * tex(uv2, sound) + ( 0.15 * texture(iChannel0, uv2).rgb);\n    vec3 colback   = vec3(0.05,0.05,0.05);\n\n    // Mix the colors\n\tfragColor = vec4(r * coltunnel + (1.0 - r) * colback, 1.0);\n}\n", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}, {"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsBSRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 411], [413, 413, 470, 470, 1451]], "test": "error"}
{"id": "lsBXRW", "name": "Pulsations", "author": "fizzer", "description": "Just playing around with a fractal. I used a Catmull-Rom spline to create the colours, and tried to keep the code compact.", "tags": ["fractal", "spline", "hermite"], "likes": 23, "viewed": 1077, "published": "Public", "date": "1409428539", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 cmul(vec2 z0, vec2 z1)\n{\n    return vec2(z0.x * z1.x - z0.y * z1.y, z0.x * z1.y + z0.y * z1.x);\n}\n\nvec2 cdiv(vec2 z0, vec2 z1)\n{\n    vec2 z1conj = vec2(z1.x, -z1.y);\n    return cmul(z0, z1conj) / cmul(z1, z1conj).x;\n}\n\nvec4 hermite(mat4 m, float t)\n{\n    float t2 = t * t, t3 = t2 * t;\n    return m * vec4(2.0 * t3 - 3.0 * t2 + 1.0, t3 - 2.0 * t2 + t, -2.0 * t3 + 3.0 * t2, t3 - t2);\n}\n\nvec3 catmullRom(mat4 m, float t)\n{\n    if(t > m[2].w)\n        m = mat4(m[1], m[2], m[3], m[3] * 2.0 - m[2]);\n    else if(t > m[1].w)\n        m = mat4(m[0], m[1], m[2], m[3]);\n    else\n        m = mat4(m[0] * 2.0 - m[1], m[0], m[1], m[2]);\n\n    t = (t - m[1].w) / (m[2].w - m[1].w);\n    m = m * mat4(0.0, 1.0, 0.0, 0.0, -0.5, 0.0, 0.5, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, -0.5, 0.0, 0.5);\n    return hermite(m, t).xyz;\n}\n\nfloat pattern(vec2 p, int n, vec2 o)\n{\n    p *= 0.5;\n    vec2 t = vec2(cos(1.04719755), sin(1.04719755)) * 2.0;\n    float m = 1.0;\n    for(int i = 0; i < 8; i += 1)\n    {\n        if(i < n)\n        {\n            p = cdiv(vec2(1.0, 0.0), cmul(abs(fract(p) - vec2(0.5)), t));\n            m = max(m, length(p) / 2.0);\n        }\n    }\n    return 1.1 - exp(-distance(p, o) / m) * 1.6;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.y * 0.7;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    mat4 m = mat4( vec3(0.1, 0.1, 0.2), 0.2,  vec3(0.2, 0.3, 0.42), 0.7,   \n                vec3(1.0, 0.9, 0.5), 0.92, vec3(0.2, 0.3, 0.42), 1.0);\n\n    for(int i = 0; i < 8; i+=1)\n    {\n        vec2 c = uv + float(i) * 5e-5;\n        float p = pattern(c, 5, vec2(cos(iTime + c.y * 15.0) * 0.5, 0.0)) * 0.75 +\n            pattern(c.yx, 6, vec2(0.0, sin(iTime * 0.5) * 0.5)) * 0.25 +\n            pattern(c.yx * 2.0, 7, vec2(0.0, sin(iTime + c.x * 8.0))) * 0.2;\n        fragColor.rgb += catmullRom(m, clamp(p * 0.9, 0.0, 1.0));\n    }\n    fragColor.rgb /= 8.0;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsBXRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 102], [104, 104, 133, 133, 222], [224, 224, 255, 255, 390], [392, 392, 426, 426, 805], [807, 807, 845, 845, 1187], [1189, 1189, 1246, 1246, 1897]], "test": "ok"}
{"id": "lsBXRz", "name": "Upset Lines", "author": "atmarksharp", "description": "Upset Lines", "tags": ["line", "colors", "mod", "gradation"], "likes": 2, "viewed": 142, "published": "Public", "date": "1408328824", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 hsv_to_rgb(float h, float s, float v, float a)\n{\n\tfloat c = v * s;\n\th = mod((h * 6.0), 6.0);\n\tfloat x = c * (1.0 - abs(mod(h, 2.0) - 1.0));\n\tvec4 color;\n \n\tif (0.0 <= h && h < 1.0) {\n\t\tcolor = vec4(c, x, 0.0, a);\n\t} else if (1.0 <= h && h < 2.0) {\n\t\tcolor = vec4(x, c, 0.0, a);\n\t} else if (2.0 <= h && h < 3.0) {\n\t\tcolor = vec4(0.0, c, x, a);\n\t} else if (3.0 <= h && h < 4.0) {\n\t\tcolor = vec4(0.0, x, c, a);\n\t} else if (4.0 <= h && h < 5.0) {\n\t\tcolor = vec4(x, 0.0, c, a);\n\t} else if (5.0 <= h && h < 6.0) {\n\t\tcolor = vec4(c, 0.0, x, a);\n\t} else {\n\t\tcolor = vec4(0.0, 0.0, 0.0, a);\n\t}\n \n\tcolor.rgb += v - c;\n \n\treturn color;\n}\n\nbool test(float x, float width, float ms){\n\treturn ( x * sin(x) - width * sin(ms*0.7) ) < 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tfloat width = iResolution.x;\n\tfloat height = iResolution.y;\n\tfloat x = fragCoord.x;\n\tfloat y = fragCoord.y;\n    float ms = iTime * 0.7;\n\n\tif(test(x, width, (ms+3.0)*1.1) || test(width-x, width, (ms+3.0)*1.2)){\n\t\tfragColor = hsv_to_rgb(abs(cos(ms*0.3)), 0.3*abs(sin(ms*0.1))*y/height, 1.0, 1.0);\n\t}else{\n\t\tfragColor = hsv_to_rgb(abs(cos(ms*0.3)), abs(sin(ms)), y/height * (width-x)/width, 1.0);\n\t}\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsBXRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 53, 53, 631], [633, 633, 675, 675, 729], [731, 731, 787, 787, 1187]], "test": "ok"}
{"id": "lsfXWX", "name": "Sub Pixel Moir Fractal", "author": "sootn", "description": " ", "tags": ["fractal"], "likes": 4, "viewed": 189, "published": "Public", "date": "1407244455", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535897932384626433832795\n\nvec3 hsv2rgb(in vec3 c) {\n    vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n\trgb = rgb * rgb * (3.0 - 2.0 * rgb);\n\treturn c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / 100.;\n    vec2 rv = iResolution.xy / 200.;\n\tvec2 diff = rv - uv;\n    float angle = atan(diff.x, diff.y);\n    float angleparts = (2. * PI + angle) / (2. * PI);// Angle translated to 0..1\n    float value = sin(angleparts * pow(min(iTime, 25.), 3.));\n\tfragColor = vec4(hsv2rgb(vec3(1.0, value, 1./distance(uv, rv))), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsfXWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 71, 71, 243], [245, 245, 302, 302, 650]], "test": "ok"}
{"id": "lsjSRh", "name": "Concentric (Brownian)", "author": "Orihaus", "description": "Circles.", "tags": ["2d"], "likes": 14, "viewed": 562, "published": "Public", "date": "1409091673", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 mm2(in float a){float c = abs( cos(a) ), s = sin(a);return mat2(c,-s,s,c);}\n\nconst float pi = 3.14159265;\nconst float halfpi = pi * 0.5;\n\nfloat saturate( float a )\n{\n\treturn clamp( a, 0.0, 1.0 );\n}\n\n//\n// Fractional Brownian Motion code by IQ.\n\nfloat noise( float x, float y )\n{\n\treturn sin(1.5*x)*sin(1.5*y);\n}\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\nfloat fbm4( float x, float y )\n{\n    vec2 p = vec2( x, y );\n    float f = 0.0;\n    f += 0.5000*noise( p.x, p.y ); p = m*p*2.02;\n    f += 0.2500*noise( p.x, p.y ); p = m*p*2.03;\n    f += 0.1250*noise( p.x, p.y ); p = m*p*2.01;\n    f += 0.0625*noise( p.x, p.y );\n    return f/0.9375;\n}\n\n//\n\nconst float linesmooth = 0.0333;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat aspect = iResolution.x/iResolution.y;\n    \n    vec2 mainuv = ( fragCoord.xy / iResolution.xy );\n\n    float finalval = 0.0;\n    \n    //\n\n    float scale = 2.5;\n    vec2 uv = mainuv * scale - scale * 0.5;\n    uv.x *= aspect;\n        \n    float mainval = 1.0;\n  \tfloat inverseLength = saturate( length( uv ) );\n        \n    float core = inverseLength * 25.0;\n    float coreident = ceil( core );\n\n    vec2 rotatedUVs = uv * mm2( halfpi + fbm4( coreident * 0.5, iTime * 0.07 ) * pi * pi );\n    rotatedUVs          *= mm2( halfpi - fbm4( coreident * 2.0, iTime * 0.1  ) * pi * pi );\n    float arcpos = ( pi + atan( rotatedUVs.y, rotatedUVs.x ) ) / halfpi;\n    arcpos /= pi;\n    arcpos = smoothstep( 0.2, 0.2025 - coreident * 0.0001, fract( arcpos ) * fract( -arcpos ) );\n\n    mainval *= fbm4( coreident, iTime * 0.3 ) * arcpos;\n        \n    float coresmooth = fract( core ) * fract( -core );\n  \tfloat corewidth  = fwidth( coresmooth );\n   \tconst float edgethreshold = 0.1;\n    mainval *= smoothstep( edgethreshold - corewidth, edgethreshold + corewidth, coresmooth );\n    finalval += mainval;\n    \n    //\n    \n    finalval = max( finalval, 0.0 ) + 0.0025;\n    finalval = min( finalval, 1.0 );\n\n\tfragColor = vec4( vec3( pow( finalval, 1.0 / 2.2 ) ), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsjSRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 80], [143, 143, 170, 170, 202], [250, 250, 283, 283, 316], [368, 368, 400, 400, 651], [691, 691, 748, 748, 2007]], "test": "ok"}
{"id": "lslXWX", "name": "zebra balls", "author": "FMS_Cat", "description": "", "tags": ["3d"], "likes": 2, "viewed": 143, "published": "Public", "date": "1407432791", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 v=vec2(0,1);\n\nfloat f(vec3 p)\n{\n    float t=iTime*3.;\n    p.xy*=mat2(cos(t),-sin(t),sin(t),cos(t));\n    t=iTime*sin(iTime*3E-3);\n    p.zx*=mat2(cos(t),-sin(t),sin(t),cos(t));\n    t=iTime*2.;\n    p.yz*=mat2(cos(t),-sin(t),sin(t),cos(t));\n    float r=.15;\n    float d=length(p+v.yxx*.4)-r;\n    d=min(d,length(p-v.yxx*.4)-r);\n    d=min(d,length(p+v.xyx*.4)-r);\n    d=min(d,length(p-v.xyx*.4)-r);\n    d=min(d,length(p+v.xxy*.4)-r);\n    d=min(d,length(p-v.xxy*.4)-r);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p=(fragCoord.xy*2.-iResolution.xy)/iResolution.x;\n    vec3 r=normalize(v.yxx*p.x+v.xyx*p.y-v.xxy);\n    \n    float minL=1E-3,maxL=1E4,rL,rD=minL*2.;\n    vec3 rP;\n    for(int c=0;c<16;c++)\n    {\n        if(abs(rD)<minL||maxL<rL)break;\n        rP=v.xxy+r*rL;\n        rD=f(rP);\n        rL+=rD;\n    }\n    \n    float col;\n    if(rD<1E-2)\n    {\n        col=iTime*9.-length(p)*3E2;\n    }else{\n        col=iTime*9.-length(p)*3E2+3.1415;\n    }\n    fragColor=vec4((.5+.5*vec3(sin(col),sin(col+1.),sin(col+2.))),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lslXWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 36, 36, 483], [485, 485, 542, 542, 1054]], "test": "ok"}
{"id": "lsSSRz", "name": "Bumpmapped brick floor", "author": "xilconic", "description": "Continuation from https://www.shadertoy.com/view/MsSSzR, by adding bumpmapping (2 implementations), simple lighting environment and raymarching for geometry.", "tags": ["procedural", "3d", "raymarching", "bumpmapping", "excersize", "documented"], "likes": 4, "viewed": 390, "published": "Public", "date": "1408619275", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The width and height of a brick/mortar in [0,1] image space\n#define BRICKWIDTH 2.0\n#define BRICKHEIGHT 1.28\n#define MORTARTHICKNESS 0.16\n\n// Describes the width and height of a single brick 'feature' in image space.\n// A 'brick feature' is define as rectangle following:\n//    - Horizontally: mortar: [0, 0.5 * MORTARTHICKNESS]\n//                    brick : [0.5 * MORTARTHICKNESS, BRICKWIDTH + 0.5 * MORTARTHICKNESS]\n//                    mortar: [BRICKWIDTH + 0.5 * MORTARTHICKNESS, BRICKWIDTH + MORTARTHICKNESS]\n//    - Vertically  : mortar: [0, 0.5 * MORTARTHICKNESS]\n//                    brick : [0.5 * MORTARTHICKNESS, BRICKHEIGHT + 0.5 * MORTARTHICKNESS]\n//                    mortar: [BRICKHEIGHT + 0.5 * MORTARTHICKNESS, BRICKHEIGHT + MORTARTHICKNESS]\n#define BMWIDTH (BRICKWIDTH + MORTARTHICKNESS)\n#define BMHEIGHT (BRICKHEIGHT + MORTARTHICKNESS)\n\n// Describes the relative mortar boundary in normalized 'break feature' space [0,1]\n#define MWF (MORTARTHICKNESS * 0.5 / BMWIDTH)\n#define MHF (MORTARTHICKNESS * 0.5 / BMHEIGHT)\n\nconst float PI=3.14159265;\n\n/**\n * Distance function for the floor at y == -5 (World space).\n * @param p: worldspace position vector [x,y,z]\n * @return: [distance, material definition index]\n */\nvec2 obj_floor(in vec3 p)\n{\n  return vec2(p.y+5.0,0);\n}\n\n/**\n * General distance function used in the shader.\n * @param p: worldspace position vector [x,y,z]\n * @return: [distance, material definition index]\n */\nvec2 distance_to_obj(in vec3 p)\n{\n    return obj_floor(p);\n}\n\n/**\n * Map the given location to the 'brick feature' space of the floor.\n * @param p: worldspace position vector [x,y,z]\n * @return: Return the feature space coordinates, range [0,1].\n */\nvec2 getBrickFeatureCoordinate(in vec3 p){\n    vec2 textureCoordinates = p.xz / vec2(BMWIDTH, BMHEIGHT);\n    \n    if (mod(textureCoordinates.y * 0.5, 1.0) > 0.5)\n    {\n        textureCoordinates.x += 0.5;\n    }\n    \n    float xBrick = floor(textureCoordinates.x);\n    textureCoordinates.x -= xBrick;\n    float yBrick = floor(textureCoordinates.y);\n    textureCoordinates.y -= yBrick;\n    \n    return textureCoordinates;\n}\n\n/**\n * Determine the color of the brick floor.\n * @param p: worldspace position vector [x,y,z]\n * @return The base RGB color at the given location.\n */\nvec3 floor_color(in vec3 p)\n{\n    // Material color information:\n    vec4 brickColor = vec4(0.5, 0.15, 0.14, 1.0); // RGBA\n    vec4 mortarColor = vec4(0.5, 0.5, 0.5, 1.0); // RGBA\n    \n    vec2 textureCoordinates = getBrickFeatureCoordinate(p);\n    \n    // Step functions describing when inside brick and when inside mortar:\n    float widthIndex = step(MWF, textureCoordinates.x) - step(1.0-MWF, textureCoordinates.x);\n    float heightIndex = step(MHF, textureCoordinates.y) - step(1.0-MHF, textureCoordinates.y);\n    \n    // Decide color for mortar or brick.\n    // widthIndex * heightIndex is basically AND-ing if inside width/height of a brick.\n    return mix(mortarColor.rgb, brickColor.rgb, widthIndex*heightIndex);\n}\n\n/**\n * Determine the base surface color for the given location and material id.\n * @param materialIndex: The material identifier.\n * @param position: worldspace position vector [x,y,z]\n * @return The base RGB color at the given location.\n */\nvec3 GetMaterialColor(float materialIndex, in vec3 position){\n\tif (materialIndex == 0.0){\n\t\treturn floor_color(position);\n\t}\n\treturn vec3(0,0,0);\n}\n\n/**\n * Calculated the bump height at the given location for the brick surface.\n * @param p: worldspace position vector [x,y,z], peturbed with bumpmapping.\n * @return The bump height at the given location, in range [0,1]\n */\nfloat calculateBumpHeight(in vec3 p){\n    vec2 textureCoordinates = getBrickFeatureCoordinate(p);\n    \n    float hu, hv;\n    \n    hu = smoothstep(0.0, MWF, textureCoordinates.x) - smoothstep(1.0-MWF, 1.0, textureCoordinates.x);\n    hv = smoothstep(0.0, MWF, textureCoordinates.y) - smoothstep(1.0-MWF, 1.0, textureCoordinates.y);\n    \n    return hu*hv;\n}\n\n/**\n * Determine normal using dFdx and dFdy, as presented in \"Texturing & Modelling: A Procedural Approach 3rd ed.\"\n * @param p: worldspace position vector [x,y,z], peturbed with bumpmapping.\n * @return The new surface normal for the floor, taking the mortar grooves into account.\n */\nvec3 calculateNormal(in vec3 p){\n    // Note: You could use facefoward instead of having to multiply dFdy with -1.0.\n    //       This however does increase the required parameters for this method.\n    \n    // Accuracy note: Estimate derivative by comparing to value calculated in a neighboring pixel.\n    //                This can lead to a more coarse estimation than doing a custom derivative instead.\n \treturn cross(dFdx(p), -1.0*dFdy(p));   \n}\n\n/**\n * Performs bump mapping for the floor (Material index == 0).\n * @param p: worldspace position vector [x,y,z]\n * @param globalNormalVector: Surface normal vector at @paramref(p)\n * @param useCustomDerivative: True if custom derivative code should be used; False if dFdx and dFdy should be used instead.\n * @return The new surface normal for the floor, taking the mortar grooves into account.\n */\nvec3 floor_bumpmap(in vec3 p, in vec3 globalNormalVector, bool useCustomDerivative){\n    float heightScaling = 0.01;\n    float heightIncrement = calculateBumpHeight(p);\n    \n    if(useCustomDerivative)\n    {\n        float dhdx = heightScaling * (calculateBumpHeight(vec3(p.x + 0.02, p.y, p.z)) - heightIncrement);\n        float dhdz = heightScaling * (calculateBumpHeight(vec3(p.x, p.y, p.z + 0.02)) - heightIncrement);\n\n        vec3 vector_dhdx = vec3(0.02, dhdx, 0.0);\n        vec3 vector_dhdz = vec3(0.0, dhdz, -0.02);\n    \n    \treturn normalize(cross(vector_dhdx, vector_dhdz));\n    }\n    else\n    {\n        return normalize(calculateNormal(p + globalNormalVector * (heightIncrement*heightScaling)));\n    }\n}\n\n\n/**\n * Checks for bump map modifications to the given normal vector at the given location.\n * @param materialIndex: Index of the material (Produced by distance_to_obj)\n * @param position: worldspace position vector [x,y,z]\n * @param globalNormalVector: Surface normal vector at @paramref(position)\n * @param useCustomDerivative: True if custom derivative code should be used; False if dFdx and dFdy should be used instead.\n * @return The new surface normal, taking bump mapping into account.\n */\nvec3 EvaluateBumpMap(float materialIndex, in vec3 position, in vec3 globalNormalVector, bool useCustomDerivative){\n    if (materialIndex == 0.0){\n        return floor_bumpmap(position, globalNormalVector, useCustomDerivative);\n    }\n    return globalNormalVector;\n}\n\n/**\n * Estimates the surface normal of the distance field at a given position.\n * @param position: Final raymarched position.\n * @param originalDistance: distance from 'position' to the nearest object.\n * @return The unit normal vector.\n */\nvec3 EsitmateDistanceFieldNormal(in vec3 position, float originalDistance){\n\t// Note: Parameter 'originalDistance' can be removed be calling internally at loss of performance:\n\t//       float originalDistance = distance_to_obj(position);\n\t\n\t// Quick trick for generating small permutation of 'position'\n\tconst float derivativeDelta = 0.02;\n\tconst vec2 e = vec2(derivativeDelta,0); \n\t\n\t// Perform a discrete forward derivative:\n\tvec3 n = vec3(originalDistance - distance_to_obj(position - e.xyy).x,\n\t\t\t\t  originalDistance - distance_to_obj(position - e.yxy).x,\n\t\t\t\t  originalDistance - distance_to_obj(position - e.yyx).x);\n\t// Note: discrete central derivative could be used instead for more accuracy at cost of performace.\n\t\n\treturn normalize(n); // Normalization helps saving 3 divisions by 'derivativeDelta'\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Normalized fragment coordinate in range [-0.5, 0.5]\n    vec2 vPos = fragCoord.xy/iResolution.xy - 0.5;\n    \n    if(abs(vPos.x) < 0.001){\n        fragColor = vec4(1.0,1.0,1.0,1.0);\n        return;\n    }\n\n\t// See the following URL for naming definitions:\n\t//   http://uploads.gamedev.net/monthly_03_2013/ccs-191720-0-04862100-1363766190.png\n    // Camera up vector, using positive y as 'up':\n    vec3 cameraUpVector = vec3(0,1,0);\n  \n    // Point where the camera is looking at:\n    vec3 cameraTarget = vec3(0,0,0);\n\n    // Map current clicked mouse position on radians [0, 2*PI] horizontally and [0, 0.5*PI) vertically:\n    // Note: 0.5 gives rendering problems if iMouse.Y == iResolution.y\n\t//       This is due to cameraViewDirection and cameraUpVector align perfectly, which causes the\n\t//       cross-product to yield 0. This prevents spanning the horizontal and vertical axis of the\n\t//       camera.\n    float mx = iMouse.x/iResolution.x * 2.0*PI;\n    float my = iMouse.y/iResolution.y * 0.49*PI; \n    \n    vec3 eyeWorldPosition = vec3(cos(my)*cos(mx),\n\t\t\t\t\t\t\t\t sin(my),\n\t\t\t\t\t\t\t\t cos(my)*sin(mx)) * 6.0;\n\n    // Camera setup.\n\t// 1. Get the unit vector for the central viewing direction of the camera:\n    vec3 cameraViewDirection = normalize(cameraTarget - eyeWorldPosition);\n\t\n\t// 2. Spanning the horizontal (u) and veritcal (v) unit vectors describing the camera view-plane axis:\n    vec3 u = normalize(cross(cameraUpVector, cameraViewDirection));\n    vec3 v = normalize(cross(cameraViewDirection, u));\n\t\n\t// 3. Determine the 'projection window' coordinate\n\t// 3.1 Determine the 'project window' center / the camera position:\n    vec3 cameraPosition = eyeWorldPosition + cameraViewDirection;\n\t// 3.2 Map vPos onto the 'project window', taking aspect ratio into account:\n    vec3 evaluatedCoordinate = cameraPosition +\n\t\t\t\t\t\t\t   vPos.x * u * iResolution.x/iResolution.y + // horizontal component\n\t\t\t\t\t\t\t   vPos.y * v; // vertical component\n    vec3 rayCastDirection = normalize(evaluatedCoordinate-eyeWorldPosition);\n\n    // Distance-aided ray marching\n    const float maxd = 100.0; //Max drawing distance from camera center\n    const float inverseMax = 1.0 / maxd;\n    \n    vec2 d = vec2(0.0, 0.0);\n    vec3 colorRGB, rayPosition, normal;\n\n    float rayDistanceTraveled = 1.0;\n    for(int i = 0; i < 256; i++) // maximum value affects horizon mapping/warping\n    {\n    \trayDistanceTraveled += d.x;\n    \trayPosition = eyeWorldPosition + rayCastDirection * rayDistanceTraveled;\n    \td = distance_to_obj(rayPosition);\n        \n        if ((abs(d.x) < .001) || (rayDistanceTraveled > maxd)) \n    \t\tbreak;\n  \t}\n  \n  \tif (rayDistanceTraveled < maxd)\n  \t{\n    \t// y is used to manage materials.\n\t\tcolorRGB = GetMaterialColor(d.y, rayPosition);\n    \n    \tnormal = EsitmateDistanceFieldNormal(rayPosition, d.x);\n      \n    \tnormal = EvaluateBumpMap(d.y, rayPosition, normal, vPos.x > 0.0);\n      \n\t\t// Rotating point light around [0,10,0]:\n\t\tconst float lightRadius = 20.0;\n\t\tvec3 lightPosition = vec3(sin(iTime)*lightRadius, 10, cos(iTime)*lightRadius);\n\t\t\n\t\t// Do simple phong lighting:\n    \tfloat b = clamp(dot(normal, normalize(eyeWorldPosition - rayPosition + lightPosition)),0.0,1.0);    \t\n    \tfragColor=vec4((b*colorRGB + pow(b,16.0)) * (1.0 - rayDistanceTraveled * inverseMax), 1.0);\n  \t}\n  \telse \n    \tfragColor=vec4(0,0,0,1); //background color\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsSSRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1068, 1235, 1262, 1262, 1290], [1292, 1447, 1480, 1480, 1507], [1509, 1697, 1739, 1739, 2118], [2120, 2272, 2301, 2336, 2994], [2996, 3238, 3299, 3299, 3385], [3387, 3611, 3648, 3648, 3965], [3967, 4252, 4284, 4657, 4701], [4703, 5103, 5187, 5187, 5815], [5818, 6314, 6428, 6428, 6579], [6581, 6822, 6897, 7124, 7634], [7636, 7636, 7693, 7749, 11054]], "test": "ok"}
{"id": "lsSSzz", "name": "Painting - Sho style", "author": "iq", "description": "A super quick doodling session, using Sho Murase's work as reference.", "tags": ["procedural", "2d"], "likes": 38, "viewed": 5149, "published": "Public API", "date": "1408413665", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat hash( vec2 p )\n{\n\tfloat h = dot(p,vec2(127.1,311.7));\n\t\n    return -1.0 + 2.0*fract(sin(h)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02; p.y += 0.02*iTime;\n    f += 0.2500*noise( p ); p = m*p*2.03; p.y -= 0.02*iTime;\n    f += 0.1250*noise( p ); p = m*p*2.01; p.y += 0.02*iTime;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\nvec2 fbm2( vec2 p )\n{\n    return vec2( fbm(p.xy), fbm(p.yx) );\n}\n\nvec3 doImage( vec2 p, vec2 q )\n{   \n    p *= 0.25;\n    \n    float f = 0.3 + fbm( 1.0*(p + fbm2(2.0*(p + fbm2(4.0*p)))) );\n\n    vec2 r = p.yx*2.0;\n    f -= 0.2*(1.0-2.0*abs(f))*clamp( 0.5 + 3.0*fbm( 1.0*(r + fbm2(2.0*(r + fbm2(4.0*r)))) ), 0.0, 1.0 );\n\n    float v = 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y);\n    f += 1.1*(1.0-smoothstep( 0.0, 0.6, v ));\n    \n    float w = fwidth(f);\n    float bl = smoothstep( -w, w, f );\n\n    float ti = smoothstep( -0.9, 0.7, fbm(3.0*p+0.5) );\n    \n\treturn mix( mix( vec3(0.0,0.0,0.0), \n                     vec3(0.9,0.0,0.0), ti ), \n                     vec3(1.0,1.0,1.0), bl );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy+2.0*fragCoord.xy)/ iResolution.y;\n    vec2 q = p;\n    \n    q = 0.5 + 0.5*q/vec2(600.0/800.0,1.0);\n    \n    vec3 col = doImage( (p-0.0), clamp(q,0.0,1.0) );\n    \n    col *= 1.0 - smoothstep( 0.0, 1.0/iResolution.y, abs(q.x - 0.5)-0.5 );\n    \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsSSzz.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[176, 176, 198, 198, 290], [292, 292, 318, 318, 612], [614, 614, 635, 635, 888], [890, 890, 911, 911, 954], [956, 956, 988, 988, 1565], [1567, 1567, 1624, 1624, 1931]], "test": "timeout"}
{"id": "lssXWj", "name": "away", "author": "gcorallo", "description": "tunel difuso y reverso.", "tags": ["tunnel"], "likes": 1, "viewed": 115, "published": "Public", "date": "1407030976", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec4 color;\n    vec2 pos = fragCoord.xy;\n    \n    float r = 0.0;\n    float g = 0.0;\n    float b = 0.0;\n    \n    \n    for(float i=1.0; i<4.0; i++){\n    \t\n        vec2 center = vec2(sin(iTime*2.0+i*20.0)*iResolution.x*0.1+iResolution.x*0.5, \n                        cos(iTime*2.0+i*10.0)*iResolution.x*0.1+iResolution.x*0.2);\n\t    \n        float dist = distance (pos, center);     \n        \n        if(i==1.0){\n        \tr+= sin(dist/180.0+iTime*2.0)*0.5+0.5;\n            \n        }\n        if(i==2.0){\n        \tg+= sin(dist/180.0+iTime*2.0)*0.5+0.5;\n            \n           \n        }\n        if(i==3.0){\n        \tb+= sin(dist/180.0+iTime*2.0)*0.5+0.5;\n           \n        }\n       \n    }\n    \n    color= vec4 (r, g, b, 1.0);\n    \n\tfragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lssXWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 817]], "test": "ok"}
{"id": "lssXWX", "name": "Raster bars in space", "author": "squid", "description": "Simple old skool raster bars in space", "tags": ["rasterbars"], "likes": 4, "viewed": 280, "published": "Public", "date": "1407440659", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec3 nrand3( vec2 co )\n{\n\tvec3 a = fract( cos( co.x*8.3e-3 + co.y )*vec3(1.3e5, 4.7e5, 2.9e5) );\n\tvec3 b = fract( sin( co.x*0.3e-3 + co.y )*vec3(8.1e5, 1.0e5, 0.1e5) );\n\tvec3 c = mix(a, b, 0.5);\n\treturn c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 ruv = fragCoord.xy / iResolution.xy;\n    \n    \n    //Simplicity Galaxy's starfield + scrolling code\n    vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n\tvec2 uvs = uv * iResolution.xy / max(iResolution.x, iResolution.y);\n\tvec3 p = vec3(uvs / 4., 0) + vec3(1., -1.3, 0.);\n\tp += .15 * vec3(sin(iTime / 16.), sin(iTime / 12.),  sin(iTime / 128.));\n\t\n    vec3 col = vec3(0.);\n    \n    vec2 seed = (p.xy * 2.0);\t\n\tseed = floor(seed * iResolution.x);\n\tvec3 rnd = nrand3( seed );\n    col += vec3(pow(rnd.y,30.0));\n    \n    float rps0 = .5+sin(iTime)*.3;\n    float rps1 = .5+cos(iTime)*.3;\n    float rps2 = .5+sin(3.14159+iTime)*.3;\n    rps0 = abs(ruv.y-rps0);\n    rps1 = abs(ruv.y-rps1);\n    rps2 = abs(ruv.y-rps2);\n    if(rps0 < .08) col = vec3(1., .5, 0.)*pow(1.-(rps0/.08), .5);\n    if(rps1 < .08) col = vec3(0., .5, 1.)*pow(1.-(rps1/.08), .5);\n    if(rps2 < .08) col = vec3(0.5, 0., 1.)*pow(1.-(rps2/.08), .5);\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lssXWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 25, 25, 208], [210, 210, 267, 267, 1214]], "test": "ok"}
{"id": "lsXSD2", "name": "Simple Trig Ray Marcher", "author": "twitchingace", "description": "Simple rayMarcher displaying Trig terrain", "tags": ["3d", "raymarch"], "likes": 4, "viewed": 174, "published": "Public", "date": "1406988331", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct Ray{\n\tvec3 origin;\n\tvec3 direction;\n};\n    \nstruct Material{\n\tfloat specular;\n\tfloat diffuse;\n\tfloat ambient;\n\tfloat shininess;\n    float reflectivity;\n    float transparency;\n};\n    \nstruct Sphere{\n\tvec3 position;\n\tvec3 colour;\n\tfloat radius;\n};\n\t\nstruct PointLight{\n\tvec3 position;\n\tvec3 colour;\n};\n\n\nstruct Output{\n\tvec3 origin;\n\tvec3 normal;\n\tfloat dis;\n\tMaterial material;\n    vec3 colour;\n};\n    \n#define minT 1.0\n#define delT 0.01\n#define maxT 10.0\n    \n#define numSphere 3\nSphere sphere[numSphere];\n\n#define numLight 6\nPointLight pointlight[numLight];\n\n#define numMaterial 8\nMaterial material[numMaterial];\n\n#define PI 3.14159\nvec3 backgroundColour = vec3(0.0, 0.0, 0.7);\nvec3 eye;\n\nRay castRay(vec3 lookat){\n\tvec2 uv = (gl_FragCoord.xy * 2.1 - iResolution.xy) / iResolution.xx;\n\n\tvec3 forward = normalize(lookat - eye);\n\tvec3 up = vec3(0.0, 1.0, 0.0);\n\t\n\tvec3 right = cross(up, forward);\n\tup = cross(forward, right);\n\t\n\tRay ray;\n\t\n\tray.origin = eye;\n\tray.direction = normalize(right * uv.x + up * uv.y + forward);\n\t\n\teye = ray.origin;\n\t\n\treturn ray;\n}\n\nfloat getTerrain(vec2 point){\n    return cos(point.y) * 0.5 + sin(point.x) * 0.5 - 1.5;\n}\n\nvec3 getNormal(vec3 point){\n    float eps = 0.01;\n\tvec3 n = vec3( getTerrain(vec2(point.x-eps,point.z)) - getTerrain(vec2(point.x+eps,point.z)),\n                         2.0 * eps,\n                         getTerrain(vec2(point.x,point.z-eps)) - getTerrain(vec2(point.x,point.z+eps)) );\n    return normalize( n );\n}\n\nvoid rayMarch(Ray ray, Material mat, inout Output o){\n    \n    for (float t = minT; t < maxT; t+= delT){\n    \tvec3 p = ray.origin + ray.direction * t;\n        if (p.y <= getTerrain(p.xz)){\n            if (t < o.dis){\n            \to.material = mat;\n                o.normal = getNormal(p);\n                o.dis = t;\n                o.colour = vec3(1.0);\n                o.origin = p;\n            }\n            break;\n        }\n    }\n}\n\n\nvoid sphereIntersect(const Sphere sphere, const Ray ray, in Material mat, inout Output o) {\n\tvec3 d = ray.origin - sphere.position;\n\t\n\tfloat a = dot(ray.direction, ray.direction);\n\tfloat b = dot(ray.direction, d);\n\tfloat c = dot(d, d) - sphere.radius * sphere.radius;\n\t\n\tfloat g = b*b - a*c;\n\t\n\tif(g > 0.0) {\n\t\tfloat dis = (-sqrt(g) - b) / a;\n\t\tif(dis > 0.0 && dis < o.dis) {\n\t\t\to.dis = dis;\n\t\t\to.origin = ray.origin + ray.direction * dis;\n\t\t\to.normal = (o.origin - sphere.position) / sphere.radius;\n            o.colour = sphere.colour;\n\t\t\to.material = mat;\n\t\t}\n\t}\n}\n\nSphere makeSphere(float offset, float radius){\n    float t = iTime + offset;\n    float x = cos(t);\n    float z = sin(t * 2.0) * 3.5;\n    float y = getTerrain(vec2(x,z)) + radius;//sin(t * 1.5);\n\t\n\treturn Sphere(vec3(x, y, z),\n\t\t\t\t  vec3(sin(offset) + 1.0 / 2.0, cos(offset) + 1.0 / 2.0, 0.2),\n\t\t\t\t  radius);\n}\n\nvoid makeScene(){\n\t\n    material[0] = Material(0.1, 0.6, 0.1, 0.0, 0.2, 0.0);\n    material[1] = Material(0.0, 0.8, 0.0, 0.0, 0.1, 0.0);\n    material[2] = Material(0.2, 0.6, 0.5, 0.0, 0.7, 0.0);\n    material[3] = Material(0.1, 0.6, 0.1, 1.0, 0.3, 0.0);\n    material[4] = Material(0.1, 0.6, 0.7, 0.0, 0.2, 0.0);\n    material[5] = Material(0.0, 0.8, 0.0, 0.0, 0.1, 0.0);\n    material[6] = Material(0.2, 0.6, 0.5, 0.0, 0.7, 0.0);\n    material[7] = Material(0.1, 0.6, 0.1, 1.0, 0.3, 0.0);\n    \n\tfor (int i = 0; i < numSphere; i++){\n\t\tsphere[i] = makeSphere(float(i), float(i) / 3.0 + 0.5);\n\t}\n    \n    float r = 6.0;\n\tfloat y = 0.0;\n\t\n\tfloat t0 = -iTime + PI * 0.0;\n\tpointlight[0].position = vec3(cos(t0) * r, y, sin(t0) * r);\n\tpointlight[0].colour = vec3(0.0, 0.0, 0.5);\n\tfloat t1 = -iTime + PI * 0.333333;\n\tpointlight[1].position = vec3(cos(t1) * r, y, sin(t1) * r);\n\tpointlight[1].colour = vec3(0.4, 0.0, 0.4);\n\n\tfloat t2 = -iTime + PI * 0.666666;\n\tpointlight[2].position = vec3(cos(t2) * r, y, sin(t2) * r);\n\tpointlight[2].colour = vec3(0.3, 0.3, 0.3);\n\n\tfloat t3 = -iTime + PI * 1.0;\n\tpointlight[3].position = vec3(cos(t3) * r, y, sin(t3) * r);\n\tpointlight[3].colour = vec3(0.0, 0.4, 0.4);\n\n\tfloat t4 = -iTime + PI * 1.333333;\n\tpointlight[4].position = vec3(cos(t4) * r, y, sin(t4) * r);\n\tpointlight[4].colour = vec3(0.5, 0.0, 0.0);\n\n\tfloat t5 = -iTime + PI * 1.666666;\n\tpointlight[5].position = vec3(cos(t5) * r, y, sin(t5) * r);\n\tpointlight[5].colour = vec3(0.4, 0.4, 0.0);\n    \n\t//pointlight[0] = PointLight(vec3(-4.0, 4.0, -8.0), vec3(0.5, 0.5, 0.5));\n\t//pointlight[1] = PointLight(vec3(4.0, -4.0, 5.0), vec3(0.5, 0.5, 0.5));\n    //pointlight[2] = PointLight(vec3(2.0, 5.0, 0.0), vec3(1.0, 0.0, 1.0));\n\n}\n\nvec3 illuminatePointLight(PointLight light, Output o){\n    vec3 brightness = vec3(0.0);\n    \n\tvec3 pointToLight = o.origin - light.position;\n    for (int j = 0; j < 3; j++){\n\t\tbrightness[j] += light.colour[j] * o.material.diffuse * dot(normalize(pointToLight), normalize(o.normal));\n\t\tbrightness[j] += light.colour[j] * o.material.specular * dot(normalize(2.0 * dot(normalize(pointToLight), normalize(o.normal))\n\t\t\t\t\t\t\t\t\t\t\t\t * normalize(o.normal) - normalize(pointToLight)),\n\t\t\t\t\t\t\t\t\t   eye - o.origin);\n    }\n    return brightness;\n}\n\nvec3 shade(Output o){\n    vec3 brightness = vec3(o.material.ambient);\n\t\n\tfor (int i = 0; i < numLight; i++){\n\t\tbrightness += illuminatePointLight(pointlight[i], o);\n\t}\n\tbrightness[0] = clamp(brightness[0], 0.0, 1.0);\n    brightness[1] = clamp(brightness[1], 0.0, 1.0);\n    brightness[2] = clamp(brightness[2], 0.0, 1.0);\n\t\n    float dis = length(eye - o.origin);\n\t\n\tdis -= 10.0;\n\tdis *= 0.07;\n\tdis = clamp(dis, 0.0, 1.0);\n    brightness *= o.colour;\n\treturn brightness * (1.0 - dis);\n}\n\nOutput traceStep(in Ray ray){\n    Output o  = Output(vec3(0.0), \n                       vec3(0.0, 0.0, 0.1), \n                       1.0e4,\n                       Material(\n\t\t\t\t\t\t0.0,\n\t\t\t\t\t\t0.0,\n\t\t\t\t\t \t0.0,\n\t\t\t\t\t\t0.0,\n\t\t\t\t\t\t0.0,\n                        0.0),\n                       vec3(0.0));\n                      \n\tvec3 colour = vec3(0.0);\n\tfor (int i = 0; i < numSphere; i++){\n\t\tsphereIntersect(sphere[i], ray, material[3], o);\n    }\n    \n    rayMarch(ray, material[2], o);\n    \n    return o;\n}\n\nvec3 getSky(in Ray ray){\n    vec3 colour = vec3(0.0);\n    //if (ray.direction.y >= 0.01){\n\t\tcolour += vec3(0.529, 0.807, 0.980);\n        colour += vec3(1.0)/10.0 * ray.direction.x * ray.direction.z/ray.direction.y;\n    //}\n    return colour;\n}\n\nvec3 trace(in Ray ray){\n\tvec3 colour = vec3(0.0);\n    float reflectivity = 1.0;\n    Output o;\n    \n    for (int i = 0; i < 4; i++){\n    \to = traceStep(ray);\n        \n        if (o.dis > 1.0e3) break;\n        \n        colour += shade(o) * reflectivity;\n        \n        reflectivity *= o.material.reflectivity;\n        \n        float l = length(ray.origin - o.origin) + 0.0001;\n\t\tcolour -= 0.02 / l;\n\n\t\treflectivity *= o.material.reflectivity;\n        \n\t\tif(reflectivity < 0.05) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tray = Ray(o.origin + o.normal * 0.0001, reflect(normalize(o.origin - ray.origin), o.normal));\n    }\n    \n    if(o == Output(vec3(0.0), \n \t           vec3(0.0, 0.0, 0.1), \n               1.0e4,\n               Material(\n               0.0,\n               0.0,\n               0.0,\n               0.0,\n               0.0,\n               0.0),\n               vec3(0.0))) {\n        colour += getSky(ray);\n    }\n    \n    \n    return colour;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tmakeScene();\n\t//eye = vec3(5.0, 4.0, -2.0);\n    eye = vec3(sin(iTime) * 4.0, cos(iTime) + 2.0, -4.0 + cos(iTime) * 2.0);\n    Ray ray = castRay(vec3(0.0));\n\t\n\tvec3 color = trace(ray);\n\tfragColor = vec4(color, 1.0);\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsXSD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[698, 698, 723, 723, 1067], [1069, 1069, 1098, 1098, 1158], [1160, 1160, 1187, 1187, 1475], [1477, 1477, 1530, 1530, 1911], [1914, 1914, 2005, 2005, 2481], [2483, 2483, 2529, 2529, 2792], [2794, 2794, 2811, 2811, 4502], [4504, 4504, 4558, 4558, 5038], [5040, 5040, 5061, 5061, 5525], [5527, 5527, 5556, 5556, 6025], [6027, 6027, 6051, 6051, 6270], [6272, 6272, 6295, 6295, 7206], [7208, 7208, 7265, 7265, 7484]], "test": "error"}
{"id": "MdBSRW", "name": "Blackbody Lava", "author": "ben", "description": "A quick tweak of fizzer's Flowing Lava shader. - https://www.shadertoy.com/view/4djSzR", "tags": ["lava", "blackbody"], "likes": 64, "viewed": 2018, "published": "Public", "date": "1409426674", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//  Blackbody Lava, based on fizzer's Flowing Lava - https://www.shadertoy.com/view/4djSzR\n//  \n//  ~bj.2014\n\n#define NEW_LAVA 1\n#define TEMPERATURE 2200.0\n\nfloat fbm(vec2 p);\nfloat fizzerEmbers(inout vec3 diffuse, vec3 norm, float time, vec2 coord);\n\nvec3 blackbody(float t)\n{\n    t *= TEMPERATURE;\n    \n    float u = ( 0.860117757 + 1.54118254e-4 * t + 1.28641212e-7 * t*t ) \n            / ( 1.0 + 8.42420235e-4 * t + 7.08145163e-7 * t*t );\n    \n    float v = ( 0.317398726 + 4.22806245e-5 * t + 4.20481691e-8 * t*t ) \n            / ( 1.0 - 2.89741816e-5 * t + 1.61456053e-7 * t*t );\n\n    float x = 3.0*u / (2.0*u - 8.0*v + 4.0);\n    float y = 2.0*v / (2.0*u - 8.0*v + 4.0);\n    float z = 1.0 - x - y;\n    \n    float Y = 1.0;\n    float X = Y / y * x;\n    float Z = Y / y * z;\n\n    mat3 XYZtoRGB = mat3(3.2404542, -1.5371385, -0.4985314,\n                        -0.9692660,  1.8760108,  0.0415560,\n                         0.0556434, -0.2040259,  1.0572252);\n\n    return max(vec3(0.0), (vec3(X,Y,Z) * XYZtoRGB) * pow(t * 0.0004, 4.0));\n}\n\nvec3 lava(vec3 norm, float lavaHeight, vec3 p, float f0, vec2 coord, float time, float moveSpeed, vec3 diffuse, vec3 ro)\n{\n    float embers = fizzerEmbers(diffuse, norm, time, coord);\n    \n    float mask = max(0.0, 1.0 - abs(lavaHeight - p.y) * 16.0);\n    \n    vec2 uv = norm.yy - p.zx;\n    uv.x -= mask * lavaHeight + p.y;\n    float tex = 1.1 - texture(iChannel0, uv).x;\n    \n    float hot = smoothstep(0.2, 0.0, lavaHeight);\n    float cold = smoothstep(0.0, 1.0, (p.z + time * moveSpeed + sin(p.x + time * 0.2) + 1.0) * 0.3 + 0.1);\n    float glow = max(0.0, (1.0-mask)*4.0 * (0.1 - (p.y - lavaHeight) * (f0 * 1.5 - 0.5) * f0));\n    float haze = length(ro-p) * 0.025 * cold;\n    \n    float temp = ((hot * 2.4 + 2.8) * tex - cold) * (tex+0.2);\n    temp = mix(glow * 1.2, smoothstep(0.0, 1.5, temp) * 2.0, mask) + embers * 6.0;\n    \n    return diffuse * (1.0-mask) \n                   + blackbody(temp) * vec3(2.6, 0.8, 0.5)\n                   + haze * vec3(0.5,0.1,0.05);\n}\n// everything beyond this point is fizzer's original shader\n// https://www.shadertoy.com/view/4djSzR\n\n\nfloat fizzerEmbers(inout vec3 diffuse, vec3 norm, float time, vec2 coord)\n{\n    diffuse*=(0.5+0.5*norm.x)*2.5+vec3(1.0,0.35,0.04)*0.02;\n    float embers=smoothstep(0.77+sin(time*20.0)*0.01+sin(time)*0.01,1.0,fbm(coord*10.0+vec2(cos(coord.y*0.8+time*0.7)*10.0,time*4.0)));\n    embers+=smoothstep(0.77+sin(time*22.0)*0.01+sin(time*1.2)*0.01,1.0,fbm(vec2(100.0)+coord*8.0+vec2(time*8.0+cos(coord.y*0.3+time*0.3)*10.0,time*7.0)));\n    return embers;\n}\n\n\n#define MOTIONBLUR_EMBERS \t0 // Set to 1 to enable sampled motion blur on the embers.\n#define ADD_HEAT_GLOW \t\t0 // Set to 1 to make the rock glow red as the lava covers it.\n\nfloat moveSpeed=0.75;\nfloat time;\n\nfloat cubic(float x)\n{\n    return (3.0 * x - 2.0 * x * x) * x;\n}\n\nvec3 rotateX(float angle, vec3 v)\n{\n    return vec3(v.x, cos(angle) * v.y + sin(angle) * v.z, cos(angle) * v.z - sin(angle) * v.y);\n}\n\nvec3 rotateY(float angle, vec3 v)\n{\n    return vec3(cos(angle) * v.x + sin(angle) * v.z, v.y, cos(angle) * v.z - sin(angle) * v.x);\n}\n\nfloat hash(float n)\n{\n    n=mod(n,1024.0);\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise(vec2 p)\n{\n    return hash(p.x + p.y*57.0);\n}\n\nfloat smoothNoise2(vec2 p)\n{\n    vec2 p0 = floor(p + vec2(0.0, 0.0));\n    vec2 p1 = floor(p + vec2(1.0, 0.0));\n    vec2 p2 = floor(p + vec2(0.0, 1.0));\n    vec2 p3 = floor(p + vec2(1.0, 1.0));\n    vec2 pf = fract(p);\n    return mix( mix(noise(p0), noise(p1), pf.x),mix(noise(p2), noise(p3), pf.x), pf.y);\n}\n\nfloat cellnoise(vec2 p)\n{\n    vec2 fp=fract(p);\n    vec2 ip=p-fp;\n    float nd=1e3;\n    vec2 nc=p;\n    for(int i=-1;i<2;i+=1)\n        for(int j=-1;j<2;j+=1)\n        {\n            vec2 c=ip+vec2(i,j)+vec2(noise(ip+vec2(i,j)),noise(ip+vec2(i+10,j)));\n            float d=distance(c,p);\n            if(d<nd)\n            {\n                nd=d;\n                nc=c;\n            }\n        }\n\n    return nd;\n}\n\nfloat heightField(vec2 p)\n{\n    float f=0.0;\n    for(int i=0;i<3;i+=1)\n        f+=smoothNoise2(p*exp2(float(i+2)))/exp2(float(i));\n    return smoothstep(0.0,0.7,1.0-smoothstep(0.0,0.9,cellnoise(p)))*0.4+f*0.04;\n}\n\n\nfloat fbm(vec2 p)\n{\n    float f=0.0;\n    for(int i=0;i<4;i+=1)\n        f+=smoothNoise2(p*exp2(float(i)))/exp2(float(i+1));\n    return f;\n}\n\nfloat bumpHeight(vec2 p)\n{\n    float f=0.0;\n    p*=4.0;\n    for(int i=0;i<5;i+=1)\n        f+=smoothNoise2(p*exp2(float(i)))/exp2(float(i+1));\n    return f*0.15;\n}\n\nvec3 bumpNormal(vec2 p)\n{\n    vec2 eps=vec2(1e-5,0.0);\n    float bumpScale=10.0;\n    float c=bumpHeight(p);\n    float d0=(bumpHeight(p+eps.xy))-c;\n    float d1=(bumpHeight(p+eps.yx))-c;\n    return normalize(cross(vec3(eps.y,d1,eps.x),vec3(eps.x,d0,eps.y)));\n}\n\nvec3 heightFieldNormal(vec2 p)\n{\n    vec2 eps=vec2(1e-1,0.0);\n    float bumpScale=10.0;\n    float c=heightField(p);\n    float d0=(heightField(p+eps.xy))-c;\n    float d1=(heightField(p+eps.yx))-c;\n    vec3 n0 = normalize(cross(vec3(eps.y,d1,eps.x),vec3(eps.x,d0,eps.y)));\n    vec3 bn = bumpNormal(p);\n    return normalize(n0+(bn-n0*dot(n0,bn))*0.2);\n}\n\nvec3 tonemap(vec3 c)\n{\n    return c/(c+vec3(0.6));\n}\n\nfloat evalLavaHeight(vec2 p)\n{\n    return mix(-0.5,0.2,cubic(clamp(1.0-(-p.y-time*moveSpeed)+sin(p.x+time*0.2),0.0,1.0)));\n}\n\nvec3 _sample(vec2 coord)\n{\n    // Set up ray.\n    vec3 ro=vec3(0.0,3.0,-2.0-time*moveSpeed+cos(time*1.0)*0.05);\n    vec3 rd=rotateY(3.1415926+sin(time*0.1),rotateX(1.0+sin(time*0.4)*0.05,normalize(vec3(coord,-1.3))));\n\n    // Intersect the ray with the upper and lower planes of the heightfield.\n    float t0=(0.5-ro.y)/rd.y;\n    float t1=(0.0-ro.y)/rd.y;\n\n    const int n=14;\n\n    float lavaHeight=0.0;\n\n    vec3 prevp=ro+rd*t0,p=prevp;\n    float ph=heightField(prevp.xz);\n\n    // Raymarch through the heightfield with a fixed number of steps.\n    for(int i=1;i<n;i+=1)\n    {\n        float pt=mix(t0,t1,float(i-1)/float(n));\n        float t=mix(t0,t1,float(i)/float(n));\n        p=ro+rd*t;\n        lavaHeight=evalLavaHeight(p.xz);\n        float h=max(lavaHeight,heightField(p.xz));\n        if(h>p.y)\n        {\n            // Refine the intersection point.\n            float lrd=length(rd.xz);\n            vec2 v0=vec2(lrd*pt, prevp.y);\n            vec2 v1=vec2(lrd*t, p.y);\n            vec2 v2=vec2(lrd*pt, ph);\n            vec2 dv=vec2(h-v2.y,v2.x-v1.x);\n            float inter=dot(v2-v0,dv)/dot(v1-v0,dv);\n            p=mix(prevp,p,inter);\n\n            // Re-evaluate the lava height using the refined intersection point.\n            lavaHeight=evalLavaHeight(p.xz);\n            break;\n        }\n        prevp=p;\n        ph=h;\n    }\n\n    vec3 norm=heightFieldNormal(p.xz);\n    \n    // Base colour for the rocks.\n    float f0=sqrt(fbm(p.xz*0.5));\n    vec3 diffuse=mix(vec3(0.1,0.2,0.1)*0.5,mix(vec3(0.1),vec3(1.0,0.8,0.6)*0.3,f0),max(0.0,norm.y))*mix(0.7,0.2,p.y)*mix(0.3,1.0,fbm(p.xz*3.0));\n\n#if NEW_LAVA\n    return lava(norm, lavaHeight, p, f0, coord, time, moveSpeed, diffuse, ro);\n#else\n    // Cheating by simply adding light from the lava into the diffuse albedo.\n    diffuse+=vec3(1.0,0.35,0.04)*clamp((1.0-norm.y)*0.1+pow(max(0.0,(1.0-abs(lavaHeight-p.y)*4.0)),2.0),0.0,1.0)*0.4;\n    diffuse=mix(1.5*vec3(1.0,0.35,0.04),diffuse,clamp((p.y-lavaHeight)*16.0,0.0,1.0));\n    \n#if ADD_HEAT_GLOW\n    vec3 glow=smoothstep(0.0,3.0,p.z+time*moveSpeed)*max(0.0,1.0-p.y*1.5)*pow(3.0*vec3(0.4,0.21,0.1)*(0.6*fbm(p.xz+vec2(time*0.5,0.0))+0.6*fbm(p.xz+vec2(-time*0.5,0.0))),vec3(3.0));\n#else\n    vec3 glow=vec3(0.0);\n#endif\n    \n    // Some small bright bits for fake embers to suggest fire.\n#if MOTIONBLUR_EMBERS\n    vec3 embers=vec3(0.0);\n    for(int j=0;j<8;j+=1)\n    {\n        float mb_time=time+float(j)*6e-2/8.0;\n\t    embers+=vec3(1.0,0.35,0.04)*smoothstep(0.77+sin(mb_time*20.0)*0.01+sin(mb_time)*0.01,1.0,fbm(coord*10.0+vec2(cos(coord.y*0.8+mb_time*0.7)*10.0,mb_time*4.0)));\n    \tembers+=vec3(1.0,0.35,0.04)*smoothstep(0.77+sin(mb_time*22.0)*0.01+sin(mb_time*1.2)*0.01,1.0,fbm(vec2(100.0)+coord*8.0+vec2(mb_time*8.0+cos(coord.y*0.3+mb_time*0.3)*10.0,mb_time*7.0)));\n    }\n    embers/=8.0*0.5;\n#else\n    vec3 embers=vec3(1.0,0.35,0.04)*smoothstep(0.77+sin(time*20.0)*0.01+sin(time)*0.01,1.0,fbm(coord*10.0+vec2(cos(coord.y*0.8+time*0.7)*10.0,time*4.0)));\n    embers+=vec3(1.0,0.35,0.04)*smoothstep(0.77+sin(time*22.0)*0.01+sin(time*1.2)*0.01,1.0,fbm(vec2(100.0)+coord*8.0+vec2(time*8.0+cos(coord.y*0.3+time*0.3)*10.0,time*7.0)));\n#endif\n    \n    // Wrap lighting is applied here, both to the rock, lava, and glow from lava. This is not correct, but\n    // it gives some substance to the lava and variation/shadow to the glow.\n    return diffuse*(0.5+0.5*norm.x)*2.5+vec3(1.0,0.35,0.04)*0.02+embers+glow;\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time=iTime;\n    // Sample the scene, with a distorted coordinate to simulate heat haze.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = (uv - vec2(0.5)) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    fragColor.rgb=_sample(uv+vec2(cos(smoothNoise2(vec2(-time*10.0+uv.y*10.0,uv.x)))*0.01,0.0));\n    fragColor.rgb=tonemap(fragColor.rgb)*1.2;\n}\n\n", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdBSRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[252, 252, 277, 277, 1038], [1040, 1040, 1162, 1162, 2013], [2117, 2117, 2192, 2192, 2564], [2776, 2776, 2798, 2798, 2840], [2842, 2842, 2877, 2877, 2975], [2977, 2977, 3012, 3012, 3110], [3112, 3112, 3133, 3133, 3193], [3195, 3195, 3216, 3216, 3251], [3253, 3253, 3281, 3281, 3559], [3561, 3561, 3586, 3586, 3965], [3967, 3967, 3994, 3994, 4179], [4182, 4182, 4201, 4201, 4320], [4322, 4322, 4348, 4348, 4484], [4486, 4486, 4511, 4511, 4745], [4747, 4747, 4779, 4779, 5097], [5099, 5099, 5121, 5121, 5151], [5153, 5153, 5183, 5183, 5277], [5279, 5279, 5305, 5324, 8694], [8696, 8696, 8753, 8753, 9111]], "test": "error"}
{"id": "MdBSz1", "name": "hi-fives", "author": "dirkadirkadan", "description": "Watch this fractal high-five itself!", "tags": ["fractal", "brodom"], "likes": 0, "viewed": 130, "published": "Public", "date": "1408845151", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define DRAW_TUNNEL 1.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = 2.*uv-1.;\n    p.x *= iResolution.x/iResolution.y;\n   float bail=2000.;\n   vec3 col = vec3(0.);\n    vec3 final_col = vec3(0.);\n    \n    float x = atan(p.y,p.x);\n    float y = .5/dot(p,p)+iTime;\n    \n    vec3 tunnel_col = vec3(mod(step(mod(x,.2),.1)+step(mod(y,.2),.1),2.));\n    tunnel_col *= .2;\n    tunnel_col *= 1.-smoothstep(1.2,0.,length(p));\n\tfinal_col += DRAW_TUNNEL*tunnel_col;\n    \n    vec2 oth= vec2(.05+mod(.1*iTime,.20)); \n    for (int i=0; i < 30; i++)\n    {\n        p += vec2(p.x*p.x-p.y*p.y,p.x*p.y*2.)+oth;\n        col = 2.*vec3(cos(p.x),p.y,p);\n        if (length(p) > bail) \n        {\n            col *= vec3(0.);\n            break;\n        }\n    }\n    \n    final_col += col;\n    \n\tfragColor = vec4(final_col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdBSz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 81, 81, 869]], "test": "ok"}
{"id": "MdfSWf", "name": "Colourful Tunnel", "author": "FreeFull", "description": "Old tunnel I wrote a few years ago and never did anything with", "tags": ["2d", "tunnel", "colourful"], "likes": 9, "viewed": 257, "published": "Public", "date": "1407278750", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float tau = atan(1.)*8.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float time = iTime;\n    vec2 p = fragCoord.xy / iResolution.xy * 2.0 - 1.0 ;\n    p.x = p.x * 1.6;\n    if(abs(p.x) < 1.0) {\n\t\tvec4 col;\n\t\tfloat x,y;\n\t\tx = atan(p.x,p.y);\n\t\ty = 1./length(p.xy);\n\t\tcol.x = sin(x*5. + sin(time)/3.) * sin(y*5. + time);\n\t\tcol.y = sin(x*5. - time + sin(y+time*3.));\n\t\tcol.z = -col.x + col.y * sin(y*4.+time);\n\t\tcol = clamp(col,0.,1.);\n\t\tcol.y = pow(col.y,.5);\n\t\tcol.z = pow(col.z,.1);\n\t\tfragColor = 1.-col*length(p.xy);\n    } else {\n        fragColor = vec4(0.0);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdfSWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 83, 83, 585]], "test": "ok"}
{"id": "MdfXWl", "name": "Tiny Ray marcher", "author": "Aaro", "description": "Little testing of my own skills on what is the smallest (least characters) ray marcher that i could make (that has decent scene, not just a one sphere). This is what i came up with. I know, it has horrible performance, but i couldn't get it faster.", "tags": ["ray", "distance", "tiny", "march", "fields"], "likes": 4, "viewed": 182, "published": "Public", "date": "1407764749", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//This is the smallest i could get ray marcher to be\n//This ray marcher is 18 lines of code and 399 (Its under 400! :P) characters (whitespace and newline characters dont count).\n//Note the small amount of blur in the distance as well as the fact that there is no if statement in the loop.\n//I didnt found any way of removing it without adding more characters (new line characters dont count).\n//This also reduces performance alot. Still you can get ~60 fps (with some lagspikes) 1080p with 96 steps\n//---Aaro Permaa\n#define ti iTime\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n\tvec3 d = normalize(vec3(uv, 1));\n\tfloat t = 0.0;\n\tfor(int i=0; i < 96; i+=1){\n\t\tvec3 p = d * t;\n\t\tp.z += ti * 10.0;\n\t\tp = vec3(p.x * cos(ti) - p.y * sin(ti), p.x * sin(ti) + p.y * cos(ti), p.z);\n\t\tp = mod(p, 10.0) - 0.5 * 10.0;\n\t\tvec2 q = vec2(length(p.xz) - 2.0, p.y);\n\t\tfloat d = min(distance(p, vec3(0)) - 1.3, length(q) - 0.2);\n\t\tt+=d;\n\t}\n\tfragColor = vec4(1.0 / t * 7.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdfXWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[538, 538, 595, 595, 1071]], "test": "ok"}
{"id": "MdlXWf", "name": "Dining room", "author": "squid", "description": "A dining room, just direct light with shadow + AO. Still a work in progress.Thanks to @movAX13h, @Dave_Hoskins, @eiffie", "tags": ["raymarch"], "likes": 5, "viewed": 295, "published": "Public", "date": "1407522483", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//define this for replicating the row of chairs w/ mod\n//seems buggy, sometimes the back of the chairs don't render, but its way faster\n#define USE_MOD_FOR_CHAIRS\n\nvec2 raymarch(in vec3 ro, in vec3 rd, in float maxt);\nvec3 calc_normal(in vec3 pos);\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\n\nfloat hash( float n ) { return fract(sin(n)*43758.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\nfloat tbnoise(in vec3 pos)\n{\n    float f = 0.;\n    vec3 q = 8.0*pos;\n            f  = 0.5000*noise( q ); q = m*q*2.01;\n            f += 0.2500*noise( q ); q = m*q*2.02;\n            f += 0.1250*noise( q ); q = m*q*2.03;\n            f += 0.0625*noise( q ); q = m*q*2.01;\n    return f;\n}\n\nvec2 chair(in vec3 p)\n{\n    float t = sdBox(p, vec3(.03, .4, .25));//back\n    t = opS(t, sdBox(p, vec3(.6, .2, .15)));\n    t = min(t, sdBox(p+vec3(.27,.4,0.), vec3(.25, .03, .25)));//seat\n    \n    //legs\n    t = min(t, sdBox(p+vec3(0.,.7,0.22), vec3(.03, .3, .03)));\n    t = min(t, sdBox(p+vec3(0.,.7,-0.22), vec3(.03, .3, .03)));\n    t = min(t, sdBox(p+vec3(0.49,.7,0.22), vec3(.03, .3, .03)));\n    t = min(t, sdBox(p+vec3(0.49,.7,-0.22), vec3(.03, .3, .03)));\n    return vec2(t, 4.);\n}\n\nvec2 table(in vec3 p)\n{\n    float t = sdBox(p, vec3(.75, .03, 1.6)); //table top\n    //legs\n    t = min(t, sdBox(p+vec3(.7, .5, 1.55), vec3(.04, .5, .04)));\n    t = min(t, sdBox(p+vec3(.7, .5, -1.55), vec3(.04, .5, .04)));\n    t = min(t, sdBox(p+vec3(-.7, .5, 1.55), vec3(.04, .5, .04)));\n    t = min(t, sdBox(p+vec3(-.7, .5, -1.55), vec3(.04, .5, .04)));\n    return vec2(t, 1.);\n}\n\nvec2 map(in vec3 p)\n{\n    vec2 res = vec2(sdPlane(p), 0.);\n    \n    {\n        vec3 q = p;\n    \tq.x = abs(q.x);\n    \t#ifdef USE_MOD_FOR_CHAIRS\n        q.z = mod(q.z, .8)-.4;\n    \tvec2 c = chair(q-vec3(1.1, 1., 0.));\n        c.x = max(c.x, abs(p.z)-1.7);\n        res = opU(res, c);//chair(q - vec3(1.1, 1., 0.)));\n        #else\n        q.z += .4;\n        res = opU(res, chair(q - vec3(1.1, 1., -.8)));\n    \tres = opU(res, chair(q - vec3(1.1, 1., 0.)));\n    \tres = opU(res, chair(q - vec3(1.1, 1., .8)));\n    \tres = opU(res, chair(q - vec3(1.1, 1., 1.6)));\n        #endif\n    }\n    \n    res = opU(res, table(p-vec3(0., 1., 0.)));\n    \n    return res;\n}\n\nvec3 mat_color(float id, in vec3 p)\n{\n \tif(id == 0.) return vec3(.35, .35, .33);\n    else if(id == 1.)\n    {\n        return vec3(.2, .1, .1)*tbnoise(p*vec3(8., .5, 1.));\n    }\n    else if(id == 4.) return vec3(.8, .4, 0.);\n    else return vec3(0., 0., 1.);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat totao = 0.0;\n    float sca = 1.0;\n    for( int aoi=0; aoi<5; aoi++ )\n    {\n        float hr = 0.01 + 0.05*float(aoi);\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        totao += -(dd-hr)*sca;\n        sca *= 0.75;\n    }\n    return clamp( 1.0 - 4.0*totao, 0.0, 1.0 );\n}\n\nvec3 shade(in vec3 p, in vec3 v, in vec3 n, in vec3 l, in float id)\n{\n\tfloat shd = 1.;\n    if(raymarch(p+l*.01, l, 100.).y >= 0.) shd = 0.;\n    vec3 sp = vec3(0.);\n    vec3 diffuse = mat_color(id,p)*dot(n,l);\n    vec3 ambient = calcAO(p, n)*diffuse*.3;\n    return ((diffuse+sp)*shd) + ambient;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n\n\t// camera\t\n\tvec3 ro = vec3( -0.5+4.2*cos(0.1*time + 6.0*mo.x), 2.0 + 4.0*mo.y, 0.5 + 4.2*sin(0.1*time + 6.0*mo.x) );\n\tvec3 ta = vec3( 0., 1., 0. );\n\t\n\t// camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n    \n    vec3 col = vec3(0.);\n    \n    vec2 hr = raymarch(ro, rd, 1000.);\n    \n    if(hr.y >= 0.)\n    {\n        vec3 p = ro + rd*hr.x;\n        vec3 n = calc_normal(p);\n        vec3 l = (vec3(sin(time*.01), 5., cos(time*.01))-p);\n        float ld = length(l);\n        l /= ld;\n        col = shade(p, rd, n, l, hr.y) * (1./ld*ld);\n    }\n    \n\tfragColor = vec4(col, 1.);\n}\n\nvec3 calc_normal(in vec3 pos)\n{\n    \tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nvec2 raymarch(in vec3 ro, in vec3 rd, in float maxt)\n{\n    const float prs = .001;\n    float h = 2.*prs;\n    vec2 res = vec2(0, -1.);\n    for(int i = 0; i < 64; ++i)\n    {\n        if(res.x>maxt) break;\n        res.x += h;\n        vec2 r = map(ro+rd*res.x);\n        h = r.x;\n        res.y = r.y;\n    }\n    if(res.x>maxt) res.y = -1.0;\n    return res;\n}", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdlXWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[251, 251, 281, 281, 314], [315, 315, 348, 348, 374], [376, 376, 401, 401, 416], [418, 418, 453, 453, 479], [481, 481, 512, 512, 608], [611, 611, 641, 641, 670], [673, 673, 696, 696, 734], [735, 735, 761, 761, 1130], [1257, 1257, 1285, 1285, 1541], [1543, 1543, 1566, 1566, 2030], [2032, 2032, 2055, 2055, 2413], [2415, 2415, 2436, 2436, 3064], [3066, 3066, 3103, 3103, 3324], [3326, 3326, 3368, 3368, 3673], [3675, 3675, 3744, 3744, 3970], [3972, 3972, 4029, 4029, 4930], [4932, 4932, 4963, 4963, 5188], [5190, 5190, 5244, 5244, 5541]], "test": "error"}
{"id": "MdsXDX", "name": "ripples-blue", "author": "soumyajitdeb", "description": "blue ripples", "tags": ["2d"], "likes": 2, "viewed": 213, "published": "Public", "date": "1407494123", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec2 center = vec2(0.5,0.5);\nfloat speed = 0.08;\nfloat invAr = iResolution.y / iResolution.x;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;  \n\t\t\t\n\tfloat x = (center.x-uv.x);\n\tfloat y = (center.y-uv.y) *invAr;\n\tfloat r = -sqrt(x*x + y*y); \n    \n\tfloat z = 1.2 + 0.8*sin((r+iTime*speed)/0.01);\n\tfragColor = vec4(0,1.0-z,0.4+1.0-z,1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdsXDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[96, 96, 153, 153, 391]], "test": "ok"}
{"id": "MdSXzz", "name": "Warping - procedural 4", "author": "iq", "description": "More fbm warping", "tags": ["procedural", "2d", "warping"], "likes": 179, "viewed": 18676, "published": "Public API", "date": "1409129442", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Copyright Inigo Quilez, 2014 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat hash( vec2 p )\n{\n\tfloat h = dot(p,vec2(127.1,311.7));\n    return -1.0 + 2.0*fract(sin(h)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\nvec2 fbm2( in vec2 p )\n{\n    return vec2( fbm(p.xy), fbm(p.yx) );\n}\n\nvec3 map( vec2 p )\n{   \n    p *= 0.7;\n\n    float f = dot( fbm2( 1.0*(0.05*iTime + p + fbm2(-0.05*iTime+2.0*(p + fbm2(4.0*p)))) ), vec2(1.0,-1.0) );\n\n    float bl = smoothstep( -0.8, 0.8, f );\n\n    float ti = smoothstep( -1.0, 1.0, fbm(p) );\n\n    return mix( mix( vec3(0.50,0.00,0.00), \n                     vec3(1.00,0.75,0.35), ti ), \n                     vec3(0.00,0.00,0.02), bl );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy+2.0*fragCoord.xy)/iResolution.y;\n    \n\n    float e = 0.0045;\n\n    vec3 colc = map( p               ); float gc = dot(colc,vec3(0.333));\n    vec3 cola = map( p + vec2(e,0.0) ); float ga = dot(cola,vec3(0.333));\n    vec3 colb = map( p + vec2(0.0,e) ); float gb = dot(colb,vec3(0.333));\n    \n    vec3 nor = normalize( vec3(ga-gc, e, gb-gc ) );\n\n    vec3 col = colc;\n    col += vec3(1.0,0.7,0.6)*8.0*abs(2.0*gc-ga-gb);\n    col *= 1.0+0.2*nor.y*nor.y;\n    col += 0.05*nor.y*nor.y*nor.y;\n    \n    \n    vec2 q = fragCoord.xy/iResolution.xy;\n    col *= pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.1);\n    \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdSXzz.jpg", "access": "shaders20k", "license": "proprietary-license", "functions": [[693, 693, 715, 715, 805], [807, 807, 833, 833, 1127], [1129, 1129, 1150, 1150, 1346], [1348, 1348, 1372, 1372, 1415], [1417, 1417, 1437, 1437, 1803], [1805, 1805, 1862, 1862, 2521]], "test": "timeout"}
{"id": "MsBSz1", "name": "Simple Ripples", "author": "jessifin", "description": "I'm trying to simulate water ripples in OpenGL. Looks kinda neat to me :P", "tags": ["ripples"], "likes": 6, "viewed": 862, "published": "Public", "date": "1408851769", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float timeFactor = 10.0;\n\nfloat ripple(float dist, float rippleIntensity, float rippleScale) {\n\treturn rippleScale * (sin(dist * rippleIntensity - iTime * timeFactor) / (dist * rippleIntensity));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float intensity = ripple(distance(fragCoord.xy / iResolution.xy, iMouse.xy / iResolution.xy), 100., 5.);\n    for(int x = 0; x < 2; x++) {\n        for(int y = 0; y < 2; y++) {\n            vec2 center = vec2(0.375 + float(x) * 0.25, 0.375 + float(y) * 0.25);\n            float dist = distance(fragCoord.xy / iResolution.xy, center);\n            intensity += ripple(dist, 50.  + 100. * float(x), 2.5 + 5. * float(y));\n        }\n    }\n    vec4 color = vec4(0.,0.,intensity,1.0);\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsBSz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 32, 100, 100, 203], [205, 205, 262, 262, 766]], "test": "ok"}
{"id": "MsjSzz", "name": "Da Rasterizer", "author": "TDM", "description": "smooth rasterize line and circle shapes\nand a little 3d pipeline :)", "tags": ["3d", "rasterizer", "line", "circle", "pipeline"], "likes": 77, "viewed": 3150, "published": "Public", "date": "1408552576", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define LINEAR_ROTATION\n\n#define WEIGHT (3.0 / iResolution.x)\nconst vec3 RED = vec3(1.0,0.0,0.0);\nconst vec3 GREEN = vec3(0.0,1.0,0.0);\nconst vec3 BLUE = vec3(0.0,0.8,1.0);\nconst vec3 WHITE = vec3(1.0,1.0,0.97);\nconst vec3 YELLOW = vec3(1.0,1.0,0.0);\n\n// rasterize functions\nfloat line(vec2 p, vec2 p0, vec2 p1, float w) {\n    vec2 d = p1 - p0;\n    float t = clamp(dot(d,p-p0) / dot(d,d), 0.0,1.0);\n    vec2 proj = p0 + d * t;\n    float dist = length(p - proj);\n    dist = 1.0/dist*WEIGHT*w;\n    return min(dist*dist,1.0);\n}\nfloat circle(vec2 p, vec2 c, float r, float w) {\n    float dist = abs(length(p - c)) + r;\n    dist = 1.0/dist*WEIGHT*w;\n    return min(dist*dist,1.0);\n}\n\n// matrices\nmat4 getRotMatrix(vec3 a) {\n    vec3 s = sin(a);\n    vec3 c = cos(a);    \n    mat4 ret;\n    ret[0] = vec4(c.y*c.z,c.y*s.z,-s.y,0.0);\n    ret[1] = vec4(s.x*s.y*c.z-c.x*s.z,s.x*s.y*s.z+c.x*c.z,s.x*c.y,0.0);\n    ret[2] = vec4(c.x*s.y*c.z+s.x*s.z, c.x*s.y*s.z-s.x*c.z,   c.x*c.y,0.0);    \n    ret[3] = vec4(0.0,0.0,0.0,1.0);\n    return ret;\n}\nmat4 getPosMatrix(vec3 p) {   \n    mat4 ret;\n    ret[0] = vec4(1.0,0.0,0.0,p.x);\n    ret[1] = vec4(0.0,1.0,0.0,p.y);\n    ret[2] = vec4(0.0,0.0,1.0,p.z);   \n    ret[3] = vec4(0.0,0.0,0.0,1.0);\n    return ret;\n}\n\n// utils\nvec3 mix3(vec3 a, vec3 b, vec3 c, float t) {\n    if(t>0.5) return mix(b,c,t*2.0-1.0);\n    else return mix(a,b,t*2.0);\n}\nvec3 fragment(vec3 p) {\n    float t = sin(p.x*0.8+iTime*0.5)*0.5+0.5;\n    float fog = min(pow(p.z,3.0)*400.0,1.0);\n    return mix3(RED,GREEN,BLUE,t) * fog;\n}    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    //uv = uv * (1.0 + pow(length(uv)*0.4,0.5)) * 0.6;\n    \n    float line_width = 0.4;\n    float time = iTime * 0.31415;\n    vec3 c = vec3(mix(vec3(0.19,0.13,0.1),vec3(1.0), 0.5*pow(length(uv)*0.5,2.0)));\n    mat4 cam = getPosMatrix(vec3(0.0,0.0,10.0));\n    \n#ifdef LINEAR_ROTATION\n    mat4 rot = getRotMatrix(vec3(time,time*0.86,time*0.473));\n#else\n    float p = 0.08;\n    mat4 rot = getRotMatrix(vec3(time\t\t+sin(time*30.0)*p,\n                                 time*0.860\t+sin(time*20.0)*p*1.24,\n                                 time*0.473\t+sin(time*10.0)*p));\n#endif\n    \n    vec3 instances[18];\n    instances[0] = vec3( 0.0, 0.0,-1.0);\n    instances[1] = vec3(-1.0, 0.0,-1.0);\n    instances[2] = vec3( 1.0, 0.0,-1.0);\n    instances[3] = vec3( 0.0, 1.0,-1.0);\n    instances[4] = vec3( 0.0,-1.0,-1.0);    \n    instances[5] = vec3(-1.0, 0.0, 0.0);\n    instances[6] = vec3( 1.0, 0.0, 0.0);\n    instances[7] = vec3( 0.0, 1.0, 0.0);\n    instances[8] = vec3( 0.0,-1.0, 0.0);        \n    instances[9] = vec3(-1.0,-1.0, 0.0);\n    instances[10] = vec3( 1.0, 1.0, 0.0);\n    instances[11] = vec3(-1.0, 1.0, 0.0);\n    instances[12] = vec3( 1.0,-1.0, 0.0);    \n    instances[13] = vec3( 0.0, 0.0, 1.0);\n    instances[14] = vec3(-1.0, 0.0, 1.0);\n    instances[15] = vec3( 1.0, 0.0, 1.0);\n    instances[16] = vec3( 0.0, 1.0, 1.0);\n    instances[17] = vec3( 0.0,-1.0, 1.0);\n    \n    // box pipeline\n    for(int dip = 0; dip < 18; dip++) {\n        \n        // input assembly\n        vec3 vert[8];\n        vert[0] = vec3(-1.0,-1.0, 1.0);\n        vert[1] = vec3(-1.0, 1.0, 1.0);    \n        vert[2] = vec3( 1.0, 1.0, 1.0);    \n        vert[3] = vec3( 1.0,-1.0, 1.0);\n        vert[4] = vec3(-1.0,-1.0,-1.0);\n        vert[5] = vec3(-1.0, 1.0,-1.0);    \n        vert[6] = vec3( 1.0, 1.0,-1.0);    \n        vert[7] = vec3( 1.0,-1.0,-1.0);\n\n        // vertex processing        \n        mat4 pos = getPosMatrix(instances[dip] * 4.0);\n        mat4 mat = pos * rot * cam;\n\n        for(int i = 0; i < 8; i++) {\n\n            // transform\n            vert[i] = (vec4(vert[i],1.0) * mat).xyz;\n\n            // perspective\n            vert[i].z = 1.0 / vert[i].z;\n            vert[i].xy *= vert[i].z;\n        }    \n\n        // primitive assembly and rasterize\n        float i;\n        i  = line(uv,vert[0].xy,vert[1].xy,line_width);\n        i += line(uv,vert[1].xy,vert[2].xy,line_width);\n        i += line(uv,vert[2].xy,vert[3].xy,line_width);\n        i += line(uv,vert[3].xy,vert[0].xy,line_width);\n        i += line(uv,vert[4].xy,vert[5].xy,line_width);\n        i += line(uv,vert[5].xy,vert[6].xy,line_width);\n        i += line(uv,vert[6].xy,vert[7].xy,line_width);\n        i += line(uv,vert[7].xy,vert[4].xy,line_width);\n        i += line(uv,vert[0].xy,vert[4].xy,line_width);\n        i += line(uv,vert[1].xy,vert[5].xy,line_width);\n        i += line(uv,vert[2].xy,vert[6].xy,line_width);\n        i += line(uv,vert[3].xy,vert[7].xy,line_width);\n        c += fragment(vert[0]) * min(i,1.0);\n    }\n        \n    instances[0] = vec3(-1.0, 1.0,-1.0);\n    instances[1] = vec3( 1.0, 1.0,-1.0);\n    instances[2] = vec3(-1.0,-1.0,-1.0);\n    instances[3] = vec3( 1.0,-1.0,-1.0);\n    instances[4] = vec3(-1.0, 1.0, 1.0);\n    instances[5] = vec3( 1.0, 1.0, 1.0);\n    instances[6] = vec3(-1.0,-1.0, 1.0);\n    instances[7] = vec3( 1.0,-1.0, 1.0);\n    \n    // cicle pipeline\n    for(int dip = 0; dip < 8; dip++) {\n        \n        // input assembly\n        vec3 vert = vec3(0.0);\n\n        // vertex processing\n        mat4 pos = getPosMatrix(instances[dip] * 4.0);\n        mat4 mat = pos * rot * cam;\n\n        // transform\n        vert = (vec4(vert,1.0) * mat).xyz;\n\n        // perspective\n        vert.z = 1.0 / vert.z;\n        vert.xy *= vert.z;\n\n        // rasterize\n        c += fragment(vert) * circle(uv,vert.xy,-vert.z,line_width);\n    }\n    \n    // fragment\n\tfragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsjSzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[252, 275, 322, 322, 524], [525, 525, 573, 573, 677], [679, 691, 718, 718, 1029], [1030, 1030, 1057, 1057, 1239], [1241, 1250, 1294, 1294, 1369], [1370, 1370, 1393, 1393, 1527], [1533, 1533, 1590, 1590, 5552]], "test": "ok"}
{"id": "MsXSWj", "name": "Kajastus", "author": "Marken", "description": "Shader from my 1k intro named Kajastus. Published in assembly 2014.\nFull intro: http://www.youtube.com/watch?v=EMtuaxu8elo", "tags": ["3d", "raymarching", "tunnel"], "likes": 29, "viewed": 2290, "published": "Public", "date": "1407075580", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rbox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat Map( vec3 p )\n{\n\tp.z -= iTime*1.25;\n\tp = mod(p,2.5)-0.5*2.5;\n\t\n\tvec3 p2 = p;\n\t\t\n\tfloat d1 = rbox(p2, vec3(0.25,0.25,2.25), 0.5);\n\tfloat d2 = rbox(p2, vec3(0.15,0.15,1.25), 0.5);\n\td1 = max(-d2,d1);\n\t\n\tp.x += 0.3;\n\tp.z += 0.5;\n\td2 = rbox(p, vec3(0.01,0.5,0.01), 0.02);\n\t\n\tp.x -= 0.65;\n\tp.z -= 0.8;\n\tfloat d3 = rbox(p, vec3(0.01,0.5,0.01), 0.02);\n    d1 = -log( exp( -6.0*d1 ) + exp( -6.0*min(d2,d3) ) )/6.0;\n\t\n\td2 = rbox(p2, vec3(0.05,5.0,0.05), 0.4);\n\tfloat res = max(-d2, d1);\n\t\n\tp2 = vec3(sin(-0.3)*p2.x-p2.y, p2.y, p2.z);\n\tp2.z -= 0.8;\n\td2 = rbox(p2, vec3(0.05,5.0,0.05), 0.4);\n\t\n\treturn max(-d2, res);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p=-1.0+2.0*fragCoord.xy/iResolution.xy;\n\tp.x *= 1.7;\n\t\n\tvec3 ro = vec3( 1.2 );\n\tvec3 rd = normalize( vec3( p, -1.0 ) );\n\t\n\tfloat h = 1.0;\n\tfloat t = 0.0;\n\t\n    \n\tfor( int i = 0; i<64; i++ )\n\t{\n\t\tif( h < 0.001 )// || t > 20.0 )\n\t\t\tbreak;\n\n\t\th = Map( rd*t + ro );\n\t\t\n\t\tt += h;\n\t}\n\n\tfragColor=vec4(t*0.18);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsXSWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 79], [81, 81, 102, 102, 693], [695, 695, 752, 752, 1064]], "test": "ok"}
{"id": "Xd2XRh", "name": "Undulating lines", "author": "abubusoft", "description": "Undulating lines with automatic color change", "tags": ["procedural", "lines"], "likes": 29, "viewed": 1171, "published": "Public", "date": "1408930424", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float VELOCITY        = 1.0  ;           // speed of lines [ 0.5  .. 1.5  ] =  1.0\nconst float HEIGHT          = 0.5    ;           // height of the lines  [ 0    .. 1.0  ] =  0.5\nconst float FREQUENCY       = 7.5 ;           // frequency  [ 1.0  .. 14.0 ] =  9.0\nconst float AMPLITUDE       = 0.3 ;           // amplitude  [ 0.1  .. 0.5  ] =  0.2\nconst int   NUMBER          = 10    ;           // lines      [ 0    .. 20   ] = 10.0\nconst float INVERSE         = 1.0 / float(10);  // inverse\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec3 col = vec3( 1.);\n   \n   float rColMod;\n   float gColMod;\n   float bColMod;\n   \n   float offset;\n   float t;\n   \n   float color;\n   float colora;\n   \n   float tsin;\n           \n   for (int i = 0; i < NUMBER; ++i)\n   {\n      vec2 pos= fragCoord.xy/iResolution.xy;\n      \n      offset = float(i) * INVERSE;\n            \n      t      = iTime + VELOCITY *(offset * offset * 2.);\n      \n      tsin   = sin( t );\n      \n      pos.y -= HEIGHT;\n      pos.y+=sin(pos.x * FREQUENCY + t ) * AMPLITUDE * tsin;\n      \n      color  = 1.0 - pow( abs( pos.y ) , 0.2 );\n      colora = pow( 1. , 0.2 * abs( pos.y ) );\n      \n      rColMod = (1. - (offset * .5) + .5) * colora ;\n      gColMod = ((offset * .5) + .5) * colora ;\n      bColMod = ((offset * .5) + .5) * colora ;\n           \n      col -= color * INVERSE * vec3( mix(rColMod, gColMod, tsin), mix(gColMod, bColMod, tsin) , mix(bColMod, rColMod, tsin)) ;      \n   }\n   \n   fragColor=vec4(col.x, col.y, col.z ,1.0);\n     \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xd2XRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[500, 500, 557, 557, 1527]], "test": "ok"}
{"id": "Xd2Xz1", "name": "1D Cubic Bezier", "author": "demofox", "description": "Use the mouse to control the yellow control point.\nA cubic bezier curve is defined as: P = A*(1-T)^3+3*B*(1-T)^2*T+3*C*(1-T)*T^2+D*T^3\nWhat if A,B,C,D are scalars?  You get a nice cubic f(x) function that has 4 control points.", "tags": ["2d", "bezier"], "likes": 26, "viewed": 2555, "published": "Public", "date": "1409079912", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define A 0.0\n#define B (sin(iTime*1.5) * 0.5)\n#define C (iMouse.z <= 0.0 ? 0.25 : iMouse.y / iResolution.y - 0.5)\n#define D 0.0\n\n#define DA (B - A)\n#define DB (C - B)\n#define DC (D - C)\n\n#define EDGE   0.005\n#define SMOOTH 0.0025\n\n// F(x,y) = F(x) - y\nfloat F ( in vec2 coords )\n{\n    float T = coords.x;\n    return\n        (A * (1.0-T) * (1.0-T) * (1.0-T)) + \n        (B * 3.0 * (1.0-T) * (1.0-T) * T) +\n        (C * 3.0 * (1.0-T) * T * T) +\n        (D * T * T * T) -\n        coords.y;\n}\n\n/*\n// gradiant function for finding G for a generic function when you can't\n// get it analytically using partial derivatives.  We could do\n// partial derivatives of F above, but I'm being lazy.\nvec2 Grad( in vec2 coords )\n{\n    vec2 h = vec2( 0.01, 0.0 );\n    return vec2( F(coords+h.xy) - F(coords-h.xy),\n                 F(coords+h.yx) - F(coords-h.yx) ) / (2.0*h.x);\n}\n*/\n\n// a proper gradient function finally\nvec2 Grad( in vec2 coords )\n{\n    float T = coords.x;\n    float T2 = T * T;\n    float S = (1.0 - T);\n    float S2 = S * S;\n    \n    float DF =\n        DA * S2 +\n        DB * 2.0 * S * T +\n        DC * T2;\n    \n    return vec2 (\n        3.0*DF,\n        -1.0\n    );\n}\n\n// signed distance function for F(x,y)\nfloat SDF( in vec2 coords )\n{\n    float v = F(coords);\n    vec2  g = Grad(coords);\n    return abs(v)/length(g);\n}\n\n// signed distance function for Circle, for control points\nfloat SDFCircle( in vec2 coords, in vec2 offset )\n{\n    coords -= offset;\n    float v = coords.x * coords.x + coords.y * coords.y - EDGE*EDGE;\n    vec2  g = vec2(2.0 * coords.x, 2.0 * coords.y);\n    return v/length(g); \n}\n\n//-----------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 percent = ((fragCoord.xy / iResolution.xy) - vec2(0.25,0.5));\n    percent.x *= aspectRatio;\n\n    vec3 color = vec3(1.0,1.0,1.0);\n    float dist = SDFCircle(percent, vec2(0.0,A));\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(1.0,0.0,0.0),vec3(1.0,1.0,1.0),dist);\n    }\n    \n    dist = SDFCircle(percent, vec2(0.33,B));\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(0.0,1.0,0.0),vec3(1.0,1.0,1.0),dist);\n    }    \n    \n    dist = SDFCircle(percent, vec2(0.66,C));\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(1.0,1.0,0.0),vec3(1.0,1.0,1.0),dist);\n    }    \n    \n    dist = SDFCircle(percent, vec2(1.0,D));\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(0.0,0.0,1.0),vec3(1.0,1.0,1.0),dist);\n    }      \n    \n    dist = SDF(percent);\n    if (dist < EDGE + SMOOTH)\n    {\n        dist = smoothstep(EDGE - SMOOTH,EDGE + SMOOTH,dist);\n        color *= (percent.x >= 0.0 && percent.x <= 1.0) ? vec3(dist) : vec3(0.95);\n    }\n    \n\tfragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xd2Xz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[232, 253, 281, 281, 489], [867, 905, 934, 934, 1170], [1172, 1211, 1240, 1240, 1324], [1326, 1385, 1436, 1436, 1606], [1608, 1688, 1745, 1745, 3149]], "test": "ok"}
{"id": "XdjSRz", "name": "concentric_circles", "author": "tejaswivinnakota", "description": "concentric circles", "tags": ["circles", "ripples", "concentric"], "likes": 1, "viewed": 167, "published": "Public", "date": "1408456032", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec2 center = vec2(iMouse.x/iResolution.x,iMouse.y/iResolution.y);\n\nfloat speed = 0.08;\nfloat invAr = iResolution.y / iResolution.x;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;  \t\t\t\n\tfloat x = (center.x-uv.x);\n\tfloat y = (center.y-uv.y) *invAr;\n\tfloat r = sqrt(x*x + y*y);\n    float rad = 0.1 + 0.3 * abs(sin(iTime));\n    float rad2 = 0.01 + 0.39 * abs(sin(iTime));\n    if(r > rad)\n        fragColor = vec4(0.33,0.33,0.33,1.0);\n    if(r >= rad2 && r <= rad)\n        fragColor = vec4(1,1,1,1.0);\n\telse if(r < rad2)\n\t\tfragColor = vec4(0.33,0.33,0.33,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdjSRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[135, 135, 192, 192, 613]], "test": "ok"}
{"id": "XdlSDs", "name": "[SIG2014] - Total Noob", "author": "dynamite", "description": "A circle of color with shape - first shadertoy, this was fun!", "tags": ["2d", "colors", "noob"], "likes": 249, "viewed": 28890, "published": "Public", "date": "1407870776", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    float tau = 3.1415926535*2.0;\n    float a = atan(p.x,p.y);\n    float r = length(p)*0.75;\n    vec2 uv = vec2(a/tau,r);\n\t\n\t//get the color\n\tfloat xCol = (uv.x - (iTime / 3.0)) * 3.0;\n\txCol = mod(xCol, 3.0);\n\tvec3 horColour = vec3(0.25, 0.25, 0.25);\n\t\n\tif (xCol < 1.0) {\n\t\t\n\t\thorColour.r += 1.0 - xCol;\n\t\thorColour.g += xCol;\n\t}\n\telse if (xCol < 2.0) {\n\t\t\n\t\txCol -= 1.0;\n\t\thorColour.g += 1.0 - xCol;\n\t\thorColour.b += xCol;\n\t}\n\telse {\n\t\t\n\t\txCol -= 2.0;\n\t\thorColour.b += 1.0 - xCol;\n\t\thorColour.r += xCol;\n\t}\n\n\t// draw color beam\n\tuv = (2.0 * uv) - 1.0;\n\tfloat beamWidth = (0.7+0.5*cos(uv.x*10.0*tau*0.15*clamp(floor(5.0 + 10.0*cos(iTime)), 0.0, 10.0))) * abs(1.0 / (30.0 * uv.y));\n\tvec3 horBeam = vec3(beamWidth);\n\tfragColor = vec4((( horBeam) * horColour), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdlSDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 882]], "test": "ok"}
{"id": "XdlSWl", "name": "Bounding Colorful Balls", "author": "atmarksharp", "description": "Balls are controlled by random with fibonacci.", "tags": ["colorful", "random", "ball"], "likes": 0, "viewed": 172, "published": "Public", "date": "1407851919", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define millis iTime\n#define width  iResolution.x\n#define height iResolution.y\n\nconst int points = 10;\n\nfloat a = 11.21219;\nfloat b = 21.66294;\n\nvec4 hsv_to_rgb(float h, float s, float v, float a)\n{\n\tfloat c = v * s;\n\th = mod((h * 6.0), 6.0);\n\tfloat x = c * (1.0 - abs(mod(h, 2.0) - 1.0));\n\tvec4 color;\n \n\tif (0.0 <= h && h < 1.0) {\n\t\tcolor = vec4(c, x, 0.0, a);\n\t} else if (1.0 <= h && h < 2.0) {\n\t\tcolor = vec4(x, c, 0.0, a);\n\t} else if (2.0 <= h && h < 3.0) {\n\t\tcolor = vec4(0.0, c, x, a);\n\t} else if (3.0 <= h && h < 4.0) {\n\t\tcolor = vec4(0.0, x, c, a);\n\t} else if (4.0 <= h && h < 5.0) {\n\t\tcolor = vec4(x, 0.0, c, a);\n\t} else if (5.0 <= h && h < 6.0) {\n\t\tcolor = vec4(c, 0.0, x, a);\n\t} else {\n\t\tcolor = vec4(0.0, 0.0, 0.0, a);\n\t}\n \n\tcolor.rgb += v - c;\n \n\treturn color;\n}\n\nfloat my_fib(float _max){\n\tfloat _a = b;\n\tfloat _b = b + a;\n\ta = _a;\n\tb = _b;\n\treturn float(mod(b, 1.0)) * _max;\n}\n\nfloat rand(float _max){\n\treturn abs(sin(my_fib(14.123)+10.0*sin(millis*0.02)))*_max;\n}\n\nfloat sq(float n){\n\treturn n*n;\n}\n\nbool in_circle(vec2 cur, float r, vec4 center){\n\treturn sq(cur.x - center.x) + sq(cur.y - center.y) < sq(r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat point_x[points];\n\tfloat point_y[points];\n\tfloat point_r[points];\n\n\tfor(int i=0; i<points; i++){\n\t\tpoint_x[i] = rand(1.0)*(width-50.0)+25.0;\n\t\tpoint_y[i] = rand(1.0)*(height-50.0)+25.0;\n\t\tpoint_r[i] = rand(1.0)*(40.0) + 10.0;\n\t}\n\n\tfloat ms = millis;\n\n\tvec4 white = vec4(1.0, 1.0, 1.0, 1.0);\n\tvec4 red = vec4(1.0, 0.0, 0.0, 1.0);\n\tvec2 cur = fragCoord;\n\tbool flag = false;\n\n\tfor(int i=0; i<points; i++){\n\t\tfloat rate = float(i)/float(points);\n\t\tfloat shift = 10.0*rate;\n\t\tfloat rad = 20.0;\n\n\t\tif(in_circle(cur, point_r[i], vec4(point_x[i] + sin(ms+shift)*rad, point_y[i] + sin(ms+shift)*rad, 0.0, 0.0))){\n\t\t\tfragColor = hsv_to_rgb(rate,1.0,1.0,1.0);\n\t\t\tflag = true;\n\t\t}\n\t}\n\n\tif(flag == false){\n\t\tfragColor = white;\n\t}\n\n\treturn;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdlSWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[145, 145, 198, 198, 776], [778, 778, 803, 803, 892], [894, 894, 917, 917, 980], [982, 982, 1000, 1000, 1015], [1017, 1017, 1064, 1064, 1127], [1129, 1129, 1186, 1186, 1921]], "test": "ok"}
{"id": "XdlXDl", "name": "[SIG2014] Demofox Hackathon", "author": "demofox", "description": "hackathon!", "tags": ["3d", "hackathon", "siggraph"], "likes": 5, "viewed": 204, "published": "Public", "date": "1407867755", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n/*\n  Written by Alan Wolfe\n  http://demofox.org/\n  http://blog.demofox.org/\n*/\n\n//=======================================================================================\n\n#define FLT_MAX 3.402823466e+38\n\n//=======================================================================================\nstruct SMaterial\n{\n\tfloat m_diffuse;\n\tvec3 m_diffuseColor;\n\tfloat m_specular;\n\tvec3 m_specularColor;\n\tvec3 m_emissiveColor;\n\tfloat m_refraction;\n\tfloat m_refractionIndex;\n};\n\n//=======================================================================================\nstruct SCollisionInfo\n{\n\tint\t\t\tm_Id;\n\tbool\t\tm_foundHit;\n\tbool \t\tm_fromInside;\n\tfloat \t\tm_collisionTime;\n\tvec3\t\tm_intersectionPoint;\n\tvec3\t\tm_surfaceNormal;\n\tvec2\t\tm_textureCoordinates;\n\tSMaterial \tm_material;\n};\n\n//=======================================================================================\nstruct SSphere\n{\n\tint\t\t\tm_Id;\n\tvec3   \t\tm_center;\n\tfloat  \t\tm_radius;\n\tSMaterial\tm_material;\n};\n\t\n//=======================================================================================\nstruct SAxisAlignedBox\n{\n\tint\t\t\tm_Id;\n\tvec3\t\tm_pos;\n\tvec3\t\tm_scale;\n\tSMaterial\tm_material;\n};\n\t\n//=======================================================================================\nstruct SPointLight\n{\n\tvec3\t\tm_pos;\n\tvec3\t\tm_color;\n};\n\t\n//=======================================================================================\nstruct SDirLight\n{\n\tvec3\t\tm_reverseDir;\n\tvec3\t\tm_color;\n};\n\t\n//=======================================================================================\n// Scene parameters\n//=======================================================================================\n\t\n//----- settings\n#define DO_SHADOWS false // setting this to false will speed up rendering\nconst int c_maxRayBounces \t\t= 3;\n\t\n//----- camera\nfloat angleX = 3.14;\nfloat angleY = 0.4;\n\nfloat distx  = 4.0 + (sin(iTime * 1.0) * 0.5 + 0.5) * 8.0;\nfloat disty  = 2.0 + (sin(iTime * 1.5) * 0.5 + 0.5) * 10.0;\nfloat height = 0.0 + (sin(iTime * 1.5) * 0.5 + 0.5) * 3.0;\n\nvec3 cameraPos\t= vec3(cos(-iTime * 0.6)*distx,height,sin(-iTime * 0.6)*disty);\n\nvec3 cameraAt \t= vec3(0.0,height * -0.25,0.0);\n//float fwdTime = -iTime - 0.01;\n//vec3 cameraAt \t= vec3(cos(fwdTime * 0.6)*distx,height,sin(fwdTime * 0.6)*disty);\n\nvec3 cameraFwd  = normalize(cameraAt - cameraPos);\nvec3 cameraLeft  = normalize(cross(normalize(cameraAt - cameraPos), vec3(0.0,sign(cos(angleY)),0.0)));\nvec3 cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n\nfloat cameraViewWidth\t= 6.0;\nfloat cameraViewHeight\t= cameraViewWidth * iResolution.y / iResolution.x;\nfloat cameraDistance\t= 6.0;  // intuitively backwards!\n\n//----- lights\nvec3 lightAmbient\t\t\t\t= vec3(0.1,0.1,0.1);\n\nSPointLight lightPoint1 =\n\tSPointLight\n\t(\n\t\tvec3(sin(1.57 + iTime*1.5),sin(iTime*0.5),cos(1.57 + iTime*1.5)),\n\t\tvec3(0.9,0.9,0.9)\n\t);\n\n//----- primitives\nSSphere lightPoint1Sphere =\n\tSSphere\n\t(\n\t\t1,\t\t\t\t\t\t//id\n\t\tlightPoint1.m_pos,\t\t//center\n\t\t0.03,\t\t\t\t\t//radius\n\t\tSMaterial\n\t\t(\n\t\t\t0.0,\t\t\t\t//diffuse amount\n\t\t\tvec3(0.0,0.0,0.0),\t//diffuse color\n\t\t\t1.0,\t\t\t\t//specular amount\n\t\t\tvec3(0.0,0.0,0.0),\t//specular color\n\t\t\tlightPoint1.m_color,//emissive color\n\t\t\t0.0,\t\t\t\t//refraction amount\n\t\t\t0.0\t\t\t\t\t//refraction index\n\t\t)\n\t);\t\n\nSSphere sphere1 =\n\tSSphere\n\t(\n\t\t2,\t\t\t\t\t\t//id\n\t\tvec3(0.0,0.0,0.0),\t\t//center\n\t\t0.75,\t\t\t\t\t//radius\n\t\tSMaterial\n\t\t(\n\t\t\t1.0,\t\t\t\t//diffuse amount\n\t\t\tvec3(0.5,1.0,1.0),\t//diffuse color\n\t\t\t500.0,\t\t\t\t//specular amount\n\t\t\tvec3(1.0,1.0,1.0),\t//specular color\n\t\t\tvec3(0.0,0.0,0.0),\t//emissive color\n\t\t\t0.9,\t\t\t\t//refraction amount\n\t\t\t0.6\t\t\t\t\t//refraction index\t\t\t\n\t\t)\n\t);\n\n\nSSphere sphere2 =\n\tSSphere\n\t(\n\t\t3,\t\t\t\t\t\t//id\n\t\tvec3(sin(2.0 + iTime*1.5)*4.0,sin(iTime),cos(2.0 + iTime*1.5)*4.0),\t//center\n\t\t0.6,\t\t\t\t\t//radius\n\t\tSMaterial\n\t\t(\n\t\t\t0.25,\t\t\t\t//diffuse amount\n\t\t\tvec3(1.0,1.0,1.0),  //diffuse color\n\t\t\t20.0,\t\t\t\t//specular amount\n\t\t\tvec3(1.0,1.0,1.0),\t//specular color\n\t\t\tvec3(0.0,0.0,0.0),\t//emissive\n\t\t\t0.9,\t\t\t\t//refraction amount\n\t\t\t0.7\t\t\t\t\t//refraction index\t\t\t\n\t\t)\n\t);\n\n\nSSphere sphere3 =\n\tSSphere\n\t(\n\t\t4,\t\t\t\t\t\t//id\n\t\tvec3(sin(5.14 + iTime*2.0)*1.5,sin(iTime*1.2),cos(5.14 + iTime*2.0)*1.5),\t//center\n\t\t0.5,\t\t\t\t\t//radius\n\t\tSMaterial\n\t\t(\n\t\t\t0.25,\t\t\t\t//diffuse amount\n\t\t\tvec3(1.0,1.0,1.0),  //diffuse color\n\t\t\t20.0,\t\t\t\t//specular amount\n\t\t\tvec3(1.0,1.0,1.0),\t//specular color\n\t\t\tvec3(0.0,0.0,0.0),\t//emissive\n\t\t\t0.75,\t\t\t\t//refraction amount\n\t\t\t0.7\t\t\t\t\t//refraction index\t\t\t\n\t\t)\n\t);\n\nSSphere sphere4 =\n\tSSphere\n\t(\n\t\t6,\t\t\t\t\t\t//id\n        vec3(sin(2.0 + iTime*1.5)*4.0,sin(iTime*1.2),cos(2.0 + iTime*1.5)*4.0) + \n\t\tvec3(sin(5.14 + iTime*5.0),0.0,cos(5.14 + iTime*5.0)),\t//center\n\t\t0.3,\t\t\t\t\t//radius\n\t\tSMaterial\n\t\t(\n\t\t\t0.25,\t\t\t\t//diffuse amount\n\t\t\tvec3(1.0,0.5,1.0),  //diffuse color\n\t\t\t20.0,\t\t\t\t//specular amount\n\t\t\tvec3(1.0,1.0,1.0),\t//specular color\n\t\t\tvec3(0.0,0.0,0.0),\t//emissive\n\t\t\t0.8,\t\t\t\t//refraction amount\n\t\t\t0.7\t\t\t\t\t//refraction index\t\t\t\n\t\t)\n\t);\n\nSSphere sphere5 =\n\tSSphere\n\t(\n\t\t7,\t\t\t\t\t\t//id\n\t\tvec3(sin(5.0 + iTime*1.25)*4.0,sin(1.0+iTime),cos(5.0 + iTime*1.25)*4.0),\t//center\n\t\t0.6,\t\t\t\t\t//radius\n\t\tSMaterial\n\t\t(\n\t\t\t0.25,\t\t\t\t//diffuse amount\n\t\t\tvec3(1.0,1.0,0.8),  //diffuse color\n\t\t\t40.0,\t\t\t\t//specular amount\n\t\t\tvec3(1.0,1.0,1.0),\t//specular color\n\t\t\tvec3(0.0,0.0,0.0),\t//emissive\n\t\t\t0.9,\t\t\t\t//refraction amount\n\t\t\t1.0\t\t\t\t\t//refraction index\t\t\t\n\t\t)\n\t);\n\nSAxisAlignedBox floorBox = \n\tSAxisAlignedBox\n\t(\n\t\t5,\t\t\t\t\t\t//Id\n\t\tvec3(0.0,-2,0.0),\t\t//center\n\t\tvec3(100.0,0.1,100.0),\t//scale\n\t\tSMaterial\n\t\t(\n\t\t\t1.0,\t\t\t\t//diffuse amount\n\t\t\tvec3(1.0,1.0,1.0),\t//diffuse color\n\t\t\t20.0,\t\t\t\t//specular amount\n\t\t\tvec3(0.0,0.0,0.0),\t//specular color\n\t\t\tvec3(0.0,0.0,0.0),\t//emissive\t\t\n\t\t\t0.0,\t\t\t\t//refraction amount\n\t\t\t0.0\t\t\t\t\t//refraction index\t\t\t\n\t\t)\n\t);\n\n//----- macro lists\n\n// sphere primitive list\n#define SPHEREPRIMLIST PRIM(sphere1) PRIM(sphere2) PRIM(sphere3)\n\n//PRIM(sphere4) PRIM(sphere5)\n\n// sphere primitive list with light primitives\n#define SPHEREPRIMLISTWITHLIGHTS SPHEREPRIMLIST PRIM(lightPoint1Sphere)\n\n// box primitive list\n#define BOXPRIMLIST PRIM(floorBox)\n\n// point light list\n#define POINTLIGHTLIST LIGHT(lightPoint1)\n\n//=======================================================================================\nbool RayIntersectSphere (inout SSphere sphere, inout SCollisionInfo info, in vec3 rayPos, in vec3 rayDir, in int ignorePrimitiveId)\n{\n\tif (ignorePrimitiveId == sphere.m_Id)\n\t\treturn false;\n\n\t//get the vector from the center of this circle to where the ray begins.\n\tvec3 m = rayPos - sphere.m_center;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.m_radius * sphere.m_radius;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn false;\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn false;\n\n\t//not inside til proven otherwise\n\tbool fromInside = false;\n\n\t//ray now found to intersect sphere, compute smallest t value of intersection\n\tfloat collisionTime = -b - sqrt(discr);\n\n\t//if t is negative, ray started inside sphere so clamp t to zero and remember that we hit from the inside\n\tif(collisionTime < 0.0)\n\t{\n\t\tcollisionTime = -b + sqrt(discr);\n\t\tfromInside = true;\n\t}\n\n\t//enforce a max distance if we should\n\tif(info.m_collisionTime >= 0.0 && collisionTime > info.m_collisionTime)\n\t\treturn false;\n\n\t// set all the info params since we are garaunteed a hit at this point\n\tinfo.m_fromInside = fromInside;\n\tinfo.m_collisionTime = collisionTime;\n\tinfo.m_material = sphere.m_material;\n\n\t//compute the point of intersection\n\tinfo.m_intersectionPoint = rayPos + rayDir * info.m_collisionTime;\n\n\t// calculate the normal\n\tinfo.m_surfaceNormal = normalize(info.m_intersectionPoint - sphere.m_center);\n\t\n\t// texture coordinates are just the angular part of spherical coordiantes of normal\n\tinfo.m_textureCoordinates = vec2\n\t(\n\t\tatan(info.m_surfaceNormal.y, info.m_surfaceNormal.x) / 16.0,\n\t\tacos(info.m_surfaceNormal.z ) / 16.0\n\t);\n\t\n\t// bump mapping\n\tvec3 uaxis = normalize(cross(vec3(0.0,1.0,0.0), info.m_surfaceNormal));\n\tvec3 vaxis = normalize(cross(uaxis, info.m_surfaceNormal));\n\tmat3 mattanspace = mat3\n\t(\n\t\tuaxis,\n\t\tvaxis,\n\t\tinfo.m_surfaceNormal\n\t);\n\t\n\tfloat delta = -1.0/512.0;\n\tfloat A = texture(iChannel0, info.m_textureCoordinates + vec2(0.0, 0.0)).x;\n\tfloat B = texture(iChannel0, info.m_textureCoordinates + vec2(delta, 0.0)).x;\n    float C = texture(iChannel0, info.m_textureCoordinates + vec2(0.0, delta)).x;\n\t\n\tvec3 norm = normalize(vec3(B - A, C - A, 0.25));\n\t\n    if (sphere.m_Id == 2 || sphere.m_Id >= 6)\n        info.m_surfaceNormal = normalize(info.m_surfaceNormal);\n    else\n\t\tinfo.m_surfaceNormal = normalize(mattanspace * norm);\n\n\t// we found a hit!\n\tinfo.m_foundHit = true;\n\tinfo.m_Id = sphere.m_Id;\n\treturn true;\n}\n\n//=======================================================================================\nbool RayIntersectAABox (inout SAxisAlignedBox box, inout SCollisionInfo info, in vec3 rayPos, in vec3 rayDir, in int ignorePrimitiveId)\n{\n\tif (ignorePrimitiveId == box.m_Id)\n\t\treturn false;\n\t\n\tfloat rayMinTime = 0.0;\n\tfloat rayMaxTime = FLT_MAX;\n\t\n\t//enforce a max distance\n\tif(info.m_collisionTime >= 0.0)\n\t{\n\t\trayMaxTime = info.m_collisionTime;\n\t}\t\n\t\n\t// find the intersection of the intersection times of each axis to see if / where the\n\t// ray hits.\n\tfor(int axis = 0; axis < 3; ++axis)\n\t{\n\t\t//calculate the min and max of the box on this axis\n\t\tfloat axisMin = box.m_pos[axis] - box.m_scale[axis] * 0.5;\n\t\tfloat axisMax = axisMin + box.m_scale[axis];\n\n\t\t//if the ray is paralel with this axis\n\t\tif(abs(rayDir[axis]) < 0.0001)\n\t\t{\n\t\t\t//if the ray isn't in the box, bail out we know there's no intersection\n\t\t\tif(rayPos[axis] < axisMin || rayPos[axis] > axisMax)\n\t\t\t\treturn false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//figure out the intersection times of the ray with the 2 values of this axis\n\t\t\tfloat axisMinTime = (axisMin - rayPos[axis]) / rayDir[axis];\n\t\t\tfloat axisMaxTime = (axisMax - rayPos[axis]) / rayDir[axis];\n\n\t\t\t//make sure min < max\n\t\t\tif(axisMinTime > axisMaxTime)\n\t\t\t{\n\t\t\t\tfloat temp = axisMinTime;\n\t\t\t\taxisMinTime = axisMaxTime;\n\t\t\t\taxisMaxTime = temp;\n\t\t\t}\n\n\t\t\t//union this time slice with our running total time slice\n\t\t\tif(axisMinTime > rayMinTime)\n\t\t\t\trayMinTime = axisMinTime;\n\n\t\t\tif(axisMaxTime < rayMaxTime)\n\t\t\t\trayMaxTime = axisMaxTime;\n\n\t\t\t//if our time slice shrinks to below zero of a time window, we don't intersect\n\t\t\tif(rayMinTime > rayMaxTime)\n\t\t\t\treturn false;\n\t\t}\n\t}\n\t\n\t//if we got here, we do intersect, return our collision info\n\tinfo.m_fromInside = (rayMinTime == 0.0);\n\tif(info.m_fromInside)\n\t\tinfo.m_collisionTime = rayMaxTime;\n\telse\n\t\tinfo.m_collisionTime = rayMinTime;\n\tinfo.m_material = box.m_material;\n\t\n\tinfo.m_intersectionPoint = rayPos + rayDir * info.m_collisionTime;\n\n\t// figure out the surface normal by figuring out which axis we are closest to\n\tfloat closestDist = FLT_MAX;\n\tint closestAxis = 0;\n\tfor(int axis = 0; axis < 3; ++axis)\n\t{\n\t\tfloat distFromPos= abs(box.m_pos[axis] - info.m_intersectionPoint[axis]);\n\t\tfloat distFromEdge = abs(distFromPos - (box.m_scale[axis] * 0.5));\n\n\t\tif(distFromEdge < closestDist)\n\t\t{\n\t\t\tclosestAxis = axis;\n\t\t\tclosestDist = distFromEdge;\n\t\t\tinfo.m_surfaceNormal = vec3(0.0,0.0,0.0);\n\t\t\tif(info.m_intersectionPoint[axis] < box.m_pos[axis])\n\t\t\t\tinfo.m_surfaceNormal[axis] = -1.0;\n\t\t\telse\n\t\t\t\tinfo.m_surfaceNormal[axis] =  1.0;\n\t\t}\n\t}\n\t\n\t// texture coordinates \n\tvec3 uaxis = vec3(1.0,0.0,0.0);\n\tvec3 vaxis = vec3(0.0,1.0,0.0);\n\t\n\tif (closestAxis == 0)\n\t{\n\t\tuaxis = vec3(0.0,1.0,0.0);\n\t\tvaxis = vec3(0.0,0.0,1.0);\n\t}\n\telse if (closestAxis == 1)\n\t{\n\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\tvaxis = vec3(0.0,0.0,1.0);\t\t\n\t}\n\t\n\tvec3 relPoint = info.m_intersectionPoint - box.m_pos;\n\tinfo.m_textureCoordinates = vec2\n\t(\n\t\tdot(relPoint, uaxis) * 0.25,\n\t\tdot(relPoint, vaxis) * 0.25\n\t);\n\t\n\t// bump mapping\n\tmat3 mattanspace = mat3\n\t(\n\t\tuaxis,\n\t\tvaxis,\n\t\tinfo.m_surfaceNormal\n\t);\n\t\n\tfloat delta = -1.0/512.0;\n\tif (box.m_Id == 4) {\n\t\tfloat A = texture(iChannel1, info.m_textureCoordinates + vec2(0.0, 0.0)).x;\n\t\tfloat B = texture(iChannel1, info.m_textureCoordinates + vec2(delta, 0.0)).x;\n    \tfloat C = texture(iChannel1, info.m_textureCoordinates + vec2(0.0, delta)).x;\n\t\tvec3 norm = normalize(vec3(B - A, C - A, 0.25));\n\t\tinfo.m_surfaceNormal = normalize(mattanspace * norm);\n\t}\n\telse {\n\t\tfloat A = texture(iChannel0, info.m_textureCoordinates + vec2(0.0, 0.0)).x;\n\t\tfloat B = texture(iChannel0, info.m_textureCoordinates + vec2(delta, 0.0)).x;\n    \tfloat C = texture(iChannel0, info.m_textureCoordinates + vec2(0.0, delta)).x;\n\t\tvec3 norm = normalize(vec3(B - A, C - A, 0.25));\n\t\tinfo.m_surfaceNormal = normalize(mattanspace * norm);\t\t\n\t}\n\t\n\t// we found a hit!\n\tinfo.m_foundHit = true;\n\tinfo.m_Id = box.m_Id;\n\treturn true;\t\n}\n\n//=======================================================================================\nvoid ApplyPointLight (inout vec3 pixelColor, in SCollisionInfo collisionInfo, in SPointLight light, in float reflectionAmount, in vec3 rayDir)\n{\n\t{\n\t\t// diffuse\n\t\tvec3 hitToLight = normalize(light.m_pos - collisionInfo.m_intersectionPoint);\n\t\tfloat dp = dot(collisionInfo.m_surfaceNormal, hitToLight);\n\t\tif(dp > 0.0)\n\t\t\tpixelColor += collisionInfo.m_material.m_diffuseColor * dp * light.m_color * collisionInfo.m_material.m_diffuse * reflectionAmount;\n\t\t\t\t\n\t\t// specular\n\t\tvec3 reflection = reflect(hitToLight, collisionInfo.m_surfaceNormal);\n\t\tdp = dot(rayDir, reflection);\n\t\tif (dp > 0.0)\n\t\t\tpixelColor += collisionInfo.m_material.m_specularColor * pow(dp, collisionInfo.m_material.m_specular) * light.m_color * reflectionAmount;\n\t}\n}\n\n//=======================================================================================\nvoid TraceRay (in vec3 rayPos, in vec3 rayDir, inout vec3 pixelColor, in int depth)\n{\n\tint lastHitPrimitiveId = 0;\n\tfloat colorMultiplier = 1.0; // used by reflections and refractions that aren't fully 1.0\n\t\n\tvec3 rayToCameraDir = rayDir;\n\t\n\tfor(int index = 0; index < c_maxRayBounces; ++index)\n\t{\n\t\t\n\t\tSCollisionInfo collisionInfo =\n\t\t\tSCollisionInfo\n\t\t\t(\n\t\t\t\t0,\n\t\t\t\tfalse,\n\t\t\t\tfalse,\n\t\t\t\t-1.0,\n\t\t\t\tvec3(0.0,0.0,0.0),\n\t\t\t\tvec3(0.0,0.0,0.0),\n\t\t\t\tvec2(0.0,0.0),\n\t\t\t\tSMaterial(\n\t\t\t\t\t1.0,\n\t\t\t\t\tvec3(0.0,0.0,0.0),\n\t\t\t\t\t1.0,\n\t\t\t\t\tvec3(0.0,0.0,0.0),\n\t\t\t\t\tvec3(0.0,0.0,0.0),\n\t\t\t\t\t0.0,\n\t\t\t\t\t0.0\n\t\t\t\t)\n\t\t\t);\n\n\t\t// run intersection against all objects, including light objects\t\t\n\t\t#define PRIM(x) RayIntersectSphere(x, collisionInfo, rayPos, rayDir, lastHitPrimitiveId);\n\t\tSPHEREPRIMLISTWITHLIGHTS\n\t\t#undef PRIM\n\t\t\t\n\t\t// run intersections against all boxes\n\t\t#define PRIM(x) RayIntersectAABox(x, collisionInfo, rayPos, rayDir, lastHitPrimitiveId);\n\t\tBOXPRIMLIST\n\t\t#undef PRIM\n\n\t\n\t\tif (collisionInfo.m_foundHit)\n\t\t{\t\n            if (collisionInfo.m_Id == 2 || collisionInfo.m_Id >= 6)\n            {\n                //no texture\n            }\n            else if (collisionInfo.m_Id == 5)\n            {\n                collisionInfo.m_material.m_diffuseColor = vec3(1.0,1.0,1.0) - texture(iChannel2, collisionInfo.m_textureCoordinates * 0.0625).xyz;\n            }\n\t\t\telse if (collisionInfo.m_Id == 4)\n\t\t\t\tcollisionInfo.m_material.m_diffuseColor = texture(iChannel1, collisionInfo.m_textureCoordinates).xyz;\n\t\t\telse\n\t\t\t\tcollisionInfo.m_material.m_diffuseColor = texture(iChannel0, collisionInfo.m_textureCoordinates).xyz;\n\t\t\t\n\t\t\t// point lights\n\t\t\t#define LIGHT(light) ApplyPointLight(pixelColor, collisionInfo, light, colorMultiplier, rayDir);\n\t\t\tPOINTLIGHTLIST\n\t\t\t#undef LIGHT\t\t\t\t\n\n\t\t\t// ambient light\n\t\t\tpixelColor += lightAmbient * collisionInfo.m_material.m_diffuseColor * collisionInfo.m_material.m_diffuse * colorMultiplier;\n\t\t\t\n\t\t\t// emissive color\n\t\t\tpixelColor += collisionInfo.m_material.m_emissiveColor * colorMultiplier;\t\t\n\t\t\t\n\t\t\t//do refraction if we should\n\t\t\tif (collisionInfo.m_material.m_refraction > 0.0)\n\t\t\t{\t\t\t\t\t\n\t\t\t\tif (collisionInfo.m_fromInside)\n\t\t\t\t\tcollisionInfo.m_surfaceNormal *= -1.0;\n\t\t\t\t\n\t\t\t\t// if we are entering a refractive object, we can't ignore it since we need to go out the back\n\t\t\t\t// side possibly.  Since we can't ignore it, we need to push a little bit past the point of\n\t\t\t\t// intersection so we don't intersect it again.\n\t\t\t\tlastHitPrimitiveId = 0;\t\t\t\t\n\t\t\t\trayPos = collisionInfo.m_intersectionPoint + rayDir * 0.001;\n\t\t\t\t\n\t\t\t\t// \n\t\t\t\trayDir = refract(rayToCameraDir, collisionInfo.m_surfaceNormal, collisionInfo.m_material.m_refractionIndex);\n\t\t\t\t\n\t\t\t\tcolorMultiplier *= collisionInfo.m_material.m_refraction;\n\t\t\t\tif (colorMultiplier < 0.1)\n\t\t\t\t\treturn;\t\t\t\t\n\t\t\t}\t\n\t\t\t// else we are done\n\t\t\telse\n\t\t\t\treturn;\n\t\t}\n\t\t// no hit means bail out\n\t\telse\n\t\t{\n\t\t\tpixelColor+= vec3(0.1,0.1,0.1) * colorMultiplier;\n\t\t\treturn;\n\t\t}\n\t}\n\t\t\t\n}\n\n//=======================================================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 rawPercent = (fragCoord.xy / iResolution.xy);\n\tvec2 percent = rawPercent - vec2(0.5,0.5);\n\t\n\tvec3 rayPos;\n\tvec3 rayTarget;\n\t\n\trayTarget = (cameraFwd * cameraDistance)\n\t\t\t  + (cameraLeft * percent.x * cameraViewWidth)\n\t          + (cameraUp * percent.y * cameraViewHeight);\n\t\t\n\trayPos = cameraPos;\n    \n    float envelope = min(max(0.0, iTime - 4.0),1.0);\n    \n    float leftAdjustMag = sin(iTime * 0.2) * 0.5 + 0.5;\n    leftAdjustMag *= 0.25;\n    float leftAdjust = sin(iTime * 2.0 * (rawPercent.x * rawPercent.y)) * leftAdjustMag * leftAdjustMag * envelope;\n    rayPos += cameraLeft * leftAdjust;\n    \n    float upAdjustMag = sin(iTime * 0.3) * 0.5 + 0.5;\n    upAdjustMag *= 0.25;\n    float upAdjust = sin(iTime * 3.0 * (rawPercent.x * rawPercent.y)) * upAdjustMag * envelope;\n    rayPos += cameraUp * upAdjust;\n\t\n\tvec3 rayDir = normalize(rayTarget);\n\t\n\tvec3 pixelColor = vec3(0.0,0.0,0.0);\n\tTraceRay(rayPos, rayDir, pixelColor, 0);\n\tfragColor = vec4(pixelColor, 1.0);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdlXDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[6031, 6121, 6254, 6254, 8781], [8783, 8873, 9010, 9010, 12754], [12756, 12846, 12990, 12990, 13582], [16634, 16724, 16781, 16781, 17759]], "test": "error"}
{"id": "XdsSDj", "name": "Linescape Remix", "author": "xbe", "description": "Linescape remix in 3D slicing terrain along z axis... Use raytracing to intersect vertical planes rejecting points over noise value. Maybe quite inefficient way of achieving this, but was fun doing it... It is missing some other objects to look better. \n", "tags": ["3d", "raytracing", "terrain", "slices"], "likes": 18, "viewed": 545, "published": "Public", "date": "1407084128", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////\n// XBE\n// Linescape Remix \n// Terrain Rendering with slices\n\n//////////////////////////////////////\n// Noise from IQ\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n\tconst float K1 = 0.366025404;\n\tconst float K2 = 0.211324865;\n\t\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n\tvec2 a = p - i + (i.x+i.y)*K2;\n\tvec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);\n\tvec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\t\n\tvec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\t\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\t\n\treturn dot( n, vec3(70.0) );\n}\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat fbm4( in vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n\n//////////////////////////////////////\n// Musgrave's noise function\n\nfloat multifractal(vec2 point)\n{\n\tfloat value = 1.0;\n\tfloat rmd = 0.0;\n\tfloat pwHL = pow(2., -0.5);\n\tfloat pwr = pwHL;\n\n\tfor (int i=0; i<4; i++)\n\t{\n\t\tvalue *= pwr*noise(2.*point) + 0.65;\n\t\tpoint *= 2.;\n\t\tpwr *= pwHL;\n\t}\n\n\treturn value;\n}\n\nfloat hybridMultiFractal(in vec2 point)\n{\n\tfloat value = 1.0;\n\tfloat signal = 0.0;\n\tfloat pwHL = pow(3., -0.25);\n\tfloat pwr = pwHL;\n\tfloat weight = 0.;\n\n\t/* get first octave of function */\n\tvalue = pwr*(noise(2.*point)+0.05);\n\tweight = value;\n\tpoint *= 3.;\n\tpwr *= pwHL;\n\n\t/* spectral construction inner loop, where the fractal is built */\n\tfor (int i=1; i<4; i++)\n\t{\n\t\tweight = weight>1. ? 1. : weight;\n\t\tsignal = pwr * (noise(2.*point) + 0.05);\n\t\tvalue += weight*signal;\n\t\tweight *= signal;\n\t\tpwr *= pwHL;\n\t\tpoint *= 3.;\n\t}\n\n\treturn value;\n}\n\nfloat heteroTerrain(vec2 point)\n{\n\tfloat value = 1.;\n\tfloat increment = 0.;\n\tfloat pwHL = pow(2., -0.5);\n\tfloat pwr = pwHL;\n\n\tvalue = pwr*(0.05 + noise(2.*point));\n\tpoint *= 2.;\n\tpwr *= pwHL;\n\n\tfor (int i=1; i<4; i++)\n\t{\n\t\tincrement = (noise(2.*point) + 0.05) * pwr * value;\n\t\tvalue += increment;\n\t\tpoint *= 2.;\n\t\tpwr *= pwHL;\n\t}\n\n\treturn value;  \n}\n\nfloat heightfield(in vec2 p)\n{\n//    return fbm4(0.125*p);\n//    return multifractal(0.0625*p);\n    return hybridMultiFractal(0.125*p);\n//    return heteroTerrain(0.0625*p);\n}\n\n//////////////////////////////////////\n/// Ray-Primitive intersections\n\nstruct Inter {\n\tvec3 p;\t\t//pos\n\tvec3 n; \t//normal\n\tvec3 vd;\t// viewdir\n\tfloat d;\t//distance\n    float dn;  // noise\n};\n\nvoid intPlane(vec3 ro, vec3 rd, vec3 p, vec3 n, inout Inter i)\n{\n\tfloat d = -1.;\n\tfloat dpn = dot(rd,n);\n\tif (abs(dpn)>0.00001)\n\t{\n\t\td = (dot(n, p) + dot(n,ro)) / dpn;\n\t\tif (d>0.)\n\t\t{\n            vec3 ip = ro+d*rd;\n//            float no = heightfield(0.25*vec2(ip.x, ip.z + 0.25*iTime));\n            float no = heightfield(ip.xz);\n            float dn = ip.y + no;\n            if ((dn<0.01)&&(i.d<0.))\n            {\n                i.p = ip;\n                i.n = n;\n                i.d = d;\n                i.dn = abs(dn);\n                i.vd = -rd;\n            }\n\t\t}\n\t}\n}\n\n////////////////////////////////////\n// Raytracing\n\nvec3 raytrace( vec3 ro, vec3 rd, vec3 sky, vec3 ld)\n{\n\tInter i;\n\ti.p = vec3(0.,0.,0.);\n\ti.n = vec3(0.,0.,0.);\n\ti.d = -1.;\n    i.dn = -1.;\n\ti.vd = vec3(0.,0.,0.);\n\t//\n\tvec3 col = vec3(0.1,0.1,0.1);\n\tvec3 p = vec3(0.,0.,1.25);\n    p.z -= ro.z;\n\tvec3 n = vec3(0.,0.,-1.);\n    float inc = 0.125;\n    for (int k=0; k<36; k++)\n    {\n\t\tintPlane( ro, rd, p, n, i);\n        if (i.d>0.) break;\n        p.z += inc; inc += 0.01; \n    }\n\t//\n\t//\n\tif (i.d>0.)\n\t{\n        col = vec3(0.45, 0.25, 0.05)*exp(-2.*abs(i.dn-i.p.y)) + vec3( i.dn<0.1?smoothstep(1.,0.,i.dn*128.):0. );\n//        col *= exp(-0.01*i.d*i.d);\n//\t\tcol *= exp(-0.001*i.d);\n\t\t// lighting\n        float n1 = heightfield(vec2(i.p.x-0.001, i.p.z));\n        float n2 = heightfield(vec2(i.p.x+0.001, i.p.z));\n        vec3 n = normalize(vec3( -(n2-n1), 0.002, 0.0 ));\n\t\tcol *= 0.1 + dot(n, ld);\n        // Background\n        col = mix( col, sky, 1.0-exp(-0.00125*i.d*i.d*i.d) );\n\t}\n    else\n        col = sky;\n\treturn clamp(col,0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\t\t \n\t// camera\t\n\tvec3 ro = vec3( 0., 1.25, -1. );\n\tvec3 ta = vec3( 0.0, 0.9, 0.0 );\n\tro.y += 0.25*sin(0.25*iTime);\n\tta.x += 0.25*cos(0.2*iTime);\n\t// camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n\n    ro.z += iTime;\n    \n\tvec3 lig = normalize(vec3(-2., 2., 1.));\n//    lig.x = sin(0.33*iTime);\n//    vec3 lig = normalize( vec3(-0.6, 0.7, -0.5) );\n    vec3 sky = vec3(0.86,0.86,0.88) - rd.y*0.6;\n    float sun = clamp( dot(rd,lig), 0.0, 1.0 );\n    sky += 0.5*vec3(1.0,0.8,0.4)*0.5*pow( sun, 10.0 );\n    sky *= 0.9;\n    // Render planes\n//    vec3 bkg = vec3(0.86,0.86,0.88) + p.y*0.1;\n    vec3 col = raytrace( ro, rd, sky, lig );\n    \n\t// Vignetting\n\tvec2 r = -1.0 + 2.0*(q);\n\tfloat vb = max(abs(r.x), abs(r.y));\n\tcol *= (0.05 + 0.95*(1.0-exp(-(1.0-vb)*30.0)));\n\tfragColor=vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdsSDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 158, 179, 179, 298], [300, 300, 326, 326, 748], [801, 801, 826, 826, 1015], [1086, 1086, 1118, 1118, 1323], [1325, 1325, 1366, 1366, 1868], [1870, 1870, 1903, 1903, 2219], [2221, 2221, 2251, 2316, 2396], [2590, 2590, 2654, 2654, 3165], [3219, 3219, 3272, 3272, 4202], [4204, 4204, 4261, 4261, 5308]], "test": "ok"}
{"id": "XdsSDs", "name": "Siggraph2014 - Something", "author": "marko3d", "description": "Blue to red", "tags": ["siggraph2014"], "likes": 5, "viewed": 226, "published": "Public", "date": "1407871166", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float noise(vec3 p)\n{\n\tvec3 i = floor(p);\n\tvec4 a = dot(i, vec3(1., 57., 11.)) + vec4(0., 57., 21., 78.);\n\tvec3 f = cos((p-i)*acos(-1.))*(-.5)+.5;\n\ta = mix(sin(cos(a)*a),sin(cos(1.+a)*(1.+a)), f.x);\n\ta.xy = mix(a.xz, a.yw, f.y);\n\treturn mix(a.x, a.y, f.z);\n}\n\nfloat sphere(vec3 p, vec4 spr)\n{\n\treturn length(spr.xyz-p) - spr.w;\n}\n\nfloat flame(vec3 p)\n{\n\tfloat d = sphere(p*vec3(0.95,.5,1.), vec4(.0,-1.,.0,1.));\n\treturn d + (noise(p+vec3(.0,iTime*4.,4.0)) + noise(p*11.)*.2)*.35*(p.y) ;\n}\n\nfloat scene(vec3 p)\n{\n\treturn min(59.-length(p) , abs(flame(p)) );\n}\n\nvec4 raymarch(vec3 org, vec3 dir)\n{\n\tfloat d = 7.0, glow = 2.0, eps = 0.03;\n\tvec3  p = org;\n\tbool glowed = true;\n\t\n\tfor(int i=0; i<54; i++)\n\t{\n\t\td = scene(p) + eps;\n\t\tp += d * dir;\n\t\tif( d>eps )\n\t\t{\n\t\t\tif(flame(p) < .0)\n\t\t\t\tglowed=true;\n\t\t\tif(glowed)\n       \t\t\tglow = float(i)/64.;\n\t\t}\n\t}\n\treturn vec4(p,glow);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 v = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\tv.x *= iResolution.x/iResolution.y;\n\t\n\tvec3 org = vec3(0., -3., 2.);\n\tvec3 dir = normalize(vec3(v.x*1., -v.y, -1.0));\n\t\n\tvec4 p = raymarch(org, dir);\n\tfloat glow = p.w;\n\t\n\tvec4 col = mix(vec4(2.5,.7,.1,1.), vec4(0.1,.5,1.,1.), p.y*.06+.4);\n\t\n\tfragColor = mix(vec4(0.), col, pow(glow*4.,3.));\n\t//fragColor = mix(vec4(1.), mix(vec4(1.,.5,.1,1.),vec4(0.1,.5,1.,1.),p.y*.02+.4), pow(glow*2.,4.));\n\n    \n}\n\n", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdsSDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 258], [260, 260, 292, 292, 329], [331, 331, 352, 352, 488], [490, 490, 511, 511, 558], [560, 560, 595, 595, 872], [874, 874, 931, 931, 1387]], "test": "ok"}
{"id": "XdSSRR", "name": "Voronoi + Julia", "author": "squid", "description": "Playing with combining the Julia set with the Voronoi set, using iq's voronoi function. There could possibly be a better, more beautiful way, to do this", "tags": ["2d", "fractal", "voronoi", "julia"], "likes": 1, "viewed": 143, "published": "Public", "date": "1408035117", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ANIMATE\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nvec2 hash( vec2 p )\n{\n    p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn fract(sin(p)*43758.5453);\n}\nfloat julia(in vec4 p)\n{\n    const int ITR = 20;\n    vec2 z = p.xy; vec2 c = p.zw;\n    int idx = ITR;\n    for(int i = 0; i < ITR; ++i) \n    {\n        vec2 r = vec2((dot(z,z*vec2(1., -1.)))+c.x, \n                       dot(z.yx,z.xy)+c.y);\n        if(dot(r,r) > 4.)\n        {\n            idx = i;\n            break;\n        }\n        z = r;\n    }\n    float v = mod(float(idx), 50.) / 50.;\n    return length(z);\n}\nvec2 voronoi( in vec2 x )\n{\n    vec2 n = floor( x );\n    vec2 f = fract( x );\n\n\tvec2 m = vec2( 8.0 );\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2( float(i),float(j) );\n        vec2 o = hash( n + g );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( .5*iTime + 6.2831*o );\n        #endif\t\n\t\tvec2 r = g - f + o;\n\t\tfloat d = dot(r,r);\n        if( d<m.x )\n        {\n            m.x = d;\n            m.y = hash( dot(n+g,vec2(7.0,113.0) ) );\n        }\n    }\n    return vec2( sqrt(m.x), m.y );\n}\n\n\n\nvec2 mpx(in vec2 p)\n{\n    float apc = iResolution.x/iResolution.y;\n    return vec2(2.5*apc, 2.5)*(p - vec2(.5));\n}\n\n//from: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = mpx(fragCoord.xy / iResolution.xy);\n    uv *= 1.25;\n    \n   \tvec3 col = vec3(0.); \n      \n    float j = julia(vec4(uv, vec2(sin(iTime*.1)*1.2)*voronoi(uv).xx ));\n    if(j < 2.) col += hsv2rgb(vec3((j/4.)+.15, 1., .8));\n    vec2 v = voronoi(uv);\n    col += hsv2rgb(vec3(v.y, 1., .3));\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdSSRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 40, 40, 79], [81, 81, 102, 102, 206], [207, 207, 231, 231, 618], [619, 619, 646, 646, 1148], [1152, 1152, 1173, 1173, 1266], [1268, 1332, 1354, 1354, 1523], [1526, 1526, 1583, 1583, 1913]], "test": "ok"}
{"id": "XdSSz1", "name": "String theory", "author": "nimitz", "description": "This looks better than I expected.  Try playing with the parameters", "tags": ["2d", "iterations", "fractaloid"], "likes": 128, "viewed": 3523, "published": "Public", "date": "1408673677", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// String Theory by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/XdSSz1\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n#define BASE_ANGLE 3.5\n#define ANGLE_DELTA 0.02\n#define XOFF .7\n\n#define time iTime\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\n\nfloat f(vec2 p, float featureSize)\n{\n\tp.x = sin(p.x*1.+time*1.2)*sin(time+p.x*0.1)*3.;\t\n    p += sin(p.x*1.5)*.1;\n    return smoothstep(-0.0,featureSize,abs(p.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x/iResolution.y;\n    float featureSize = 60./((iResolution.x*aspect+iResolution.y));\n\n    vec2 p = fragCoord.xy / iResolution.xy*6.5-3.25;\n\tp.x *= aspect;\n\tp.y = abs(p.y);\n\t\n\tvec3 col = vec3(0);\n\tfor(float i=0.;i<26.;i++)\n\t{\n\t\tvec3 col2 = (sin(vec3(3.3,2.5,2.2)+i*0.15)*0.5+0.54)*(1.-f(p,featureSize));\n\t\tcol = max(col,col2);\n\t\t\n        p.x -= XOFF;\n        p.y -= sin(time*0.11+1.5)*1.5+1.5;\n\t\tp*= mm2(i*ANGLE_DELTA+BASE_ANGLE);\n\t\t\n        vec2 pa = vec2(abs(p.x-.9),abs(p.y));\n        vec2 pb = vec2(p.x,abs(p.y));\n        \n        p = mix(pa,pb,smoothstep(-.07,.07,sin(time*0.24)+.1));\n\t}\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdSSz1.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[310, 310, 331, 331, 383], [386, 386, 422, 422, 551], [553, 553, 610, 610, 1263]], "test": "ok"}
{"id": "XdsXDl", "name": "[SIG2014] Ballzy", "author": "Farrokh", "description": "Ballzy attempt", "tags": ["hackathon"], "likes": 1, "viewed": 128, "published": "Public", "date": "1407867927", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//------------------------------------------------------------------------\n// Camera\n//\n// Move the camera. In this case it's using time and the mouse position\n// to orbitate the camera around the origin of the world (0,0,0), where\n// the yellow sphere is.\n//------------------------------------------------------------------------\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 0.3*iTime;\n\tcamPos = vec3(3.5*an,cos(5.*an),0.);\n    \n   // camPos = vec3(an/50., cos(an), 0.);\n   // camPos = vec3(10., 0., 0.);\n    camTar = camPos + vec3(0., 0.,-iTime);\n}\n\n\n//------------------------------------------------------------------------\n// Background \n//\n// The background color. In this case it's just a black color.\n//------------------------------------------------------------------------\nvec3 doBackground( void )\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n//------------------------------------------------------------------------\n// Modelling \n//\n// Defines the shapes (a sphere in this case) through a distance field, in\n// this case it's a sphere of radius 1.\n//------------------------------------------------------------------------\n\nfloat doSpheres(vec3 p, float r)\n{\n    vec3 q = mod(p, 2.0) - 1.0;\n    return length(q) - r;\n}\n                \nfloat doCrazyCube(vec3 pp)\n{\n    vec3 p = vec3( pp.x * cos(-iTime) + pp.y * sin(-iTime),\n                    -pp.x * sin(-iTime) + pp.y * cos(-iTime),\n                     pp.z);\n                  \n   // p = mod (p, vec3(0., 0., 4.)) - vec3(0., 0., 2.);\n    \n    float v = abs(p.x) - 1.0;\n    if (abs(p.y) - 1.0 > v)\n        v = abs(p.y) - 1.0;\n    if (abs(p.z) - 0.5> v)\n        v = abs(p.z) - 0.5;\n    return v;\n}\n        \nfloat doModel( vec3 p )\n{\n\treturn min(doSpheres(p, sin(p.x*1.2 + iTime + p.y)/2.0 + 0.5), doCrazyCube(p));\n}\n\n\n//------------------------------------------------------------------------\n// Material \n//\n// Defines the material (colors, shading, pattern, texturing) of the model\n// at every point based on its position and normal. In this case, it simply\n// returns a constant yellow color.\n//------------------------------------------------------------------------\nvec3 doMaterial( in vec3 pos, in vec3 nor )\n{\n    vec3 objSpace = mod(pos, 2.0) - 1.0;\n    \n    float redVal = abs(objSpace.x);\n    float greenVal = abs(objSpace.y);\n    float blueVal = abs(objSpace.z);\n    \n    \n    return vec3(redVal, greenVal, blueVal);\n}\n\n//------------------------------------------------------------------------\n// Lighting\n//------------------------------------------------------------------------\nfloat calcSoftshadow( in vec3 ro, in vec3 rd );\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal )\n{\n    vec3 lin = vec3(0.0);\n\n    // key light\n    //-----------------------------\n    vec3  lig = normalize(vec3(1.0,0.7,0.9));\n    float dif = max(dot(nor,lig),0.0);\n    float sha = 0.0; if( dif>0.01 ) sha=calcSoftshadow( pos+0.01*nor, lig );\n    lin += dif*vec3(4.00,4.00,4.00)*sha;\n\n    // ambient light\n    //-----------------------------\n    lin += vec3(0.50,0.50,0.50);\n\n    \n    // surface-light interacion\n    //-----------------------------\n    vec3 col = mal*lin;\n\n    \n    // fog    \n    //-----------------------------\n\tcol *= exp(-0.01*dis*dis);\n\n    return col;\n}\n\nfloat calcIntersection( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 20.0;           // max trace distance\n\tconst float precis = 0.001;        // precission of the intersection\n    float h = precis*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for( int i=0; i<90; i++ )          // max number of raymarching iterations is 90\n    {\n        if( h<precis||t>maxd ) break;\n\t    h = doModel( ro+rd*t);\n        t += h;\n    }\n\n    if( t<maxd ) res = t;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.002;             // precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps ) + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ) + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ) + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ) );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.0005;                 // selfintersection avoidance distance\n\tfloat h = 1.0;\n    for( int i=0; i<40; i++ )         // 40 is the max numnber of raymarching steps\n    {\n        h = doModel(ro + rd*t);\n        res = min( res, 64.0*h/t );   // 64 is the hardness of the shadows\n\t\tt += clamp( h, 0.02, 2.0 );   // limit the max and min stepping distances\n    }\n    return clamp(res,0.0,1.0);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera(ro, ta, iTime, m.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, iTime/5.);  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = doBackground();\n\n\t// raymarch\n    float t = calcIntersection( ro, rd );\n    if( t>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\n        // materials\n        vec3 mal = doMaterial( pos, nor );\n\n        col = doLighting( pos, nor, rd, t, mal );\n\t}\n\n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n    // gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n\t   \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdsXDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 332, 415, 415, 605], [608, 839, 866, 866, 900], [1185, 1185, 1219, 1219, 1279], [1297, 1297, 1325, 1325, 1712], [1722, 1722, 1747, 1747, 1830], [1833, 2186, 2231, 2231, 2444], [2657, 2657, 2741, 2741, 3317], [3319, 3319, 3369, 3369, 3785], [3787, 3787, 3819, 3819, 4231], [4233, 4233, 4281, 4281, 4707], [4709, 4709, 4773, 4773, 4951], [4953, 4953, 5010, 5010, 6217]], "test": "ok"}
{"id": "XdsXWs", "name": "[SIG2014] Note", "author": "tomka", "description": "A test.", "tags": ["sphere"], "likes": 0, "viewed": 128, "published": "Public", "date": "1407870332", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 center = vec2(iResolution.x * 0.5, iResolution.y * 0.5);\n    vec2 direction = fragCoord.xy - center.xy;\n    float r = 40.0;\n\n    float dist = sqrt( direction.x * direction.x + direction.y * direction.y );\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    if (dist < r) {\n\t    fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    } else {\n        fragColor = vec4(0.0, 0.0, 0.0,1.0);\n    }\n\n    // Add virtual light\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdsXWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 481]], "test": "ok"}
{"id": "Xs2SzR", "name": "Nebula Flight", "author": "TekF", "description": "Experiment in marching emissive media, to try to get something fast enough to run full screen.", "tags": ["raymarching"], "likes": 46, "viewed": 3669, "published": "Public API", "date": "1408490004", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Hazel Quantock 2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nconst float tau = 6.28318530717958647692;\n\n#if ( 1 ) // is hash noise or texture noise faster?\n\n// texture noise\nvec2 Noise( in vec3 x )\n{\n    vec3 p = floor(x), f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec4 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0 );\n\treturn mix( rg.yw, rg.xz, f.z );\n}\n\n#else\n\n// hash noise adapted from IQ\nfloat hash( vec3 p )\n{\n\tfloat h = dot(p,vec3(127.1,311.7,201.3));\n\t\n    return fract(sin(h)*43758.5453123);\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix(mix( mix( hash( i + vec3(0,0,0) ), \n                         hash( i + vec3(1,0,0) ), u.x),\n                    mix( hash( i + vec3(0,1,0) ), \n                         hash( i + vec3(1,1,0) ), u.x), u.y),\n               mix( mix( hash( i + vec3(0,0,1) ), \n                         hash( i + vec3(1,0,1) ), u.x),\n                    mix( hash( i + vec3(0,1,1) ), \n                         hash( i + vec3(1,1,1) ), u.x), u.y), u.z );\n}\n\nvec2 Noise( in vec3 x )\n{\n    return vec2( noise(x), noise(x.zxy) );\n}\n\n#endif\n\n\nvec4 Density( vec3 pos )\n{\n    pos /= 30.0;\n    vec2 s = vec2(0);\n\ts += Noise(pos.xyz/1.0)/1.0;\n\ts += Noise(pos.zxy*2.0)/2.0;\n\ts += Noise(pos.yzx*4.0)/4.0;\n\ts += Noise(pos.xzy*8.0)/8.0;\n    \n    s /= 2.0-1.0/8.0;\n    \n    s.y = pow(s.y,5.0)*1.0;\n    \n    //s.y *= smoothstep( 2.5, .0, length(pos) );\n    \n    return vec4(pow(sin(vec3(1,2,5)+tau*s.x)*.5+.5,vec3(1.0))*16.0,s.y);\n}\n\n\nvec3 Path( float time )\n{\n    // sort of like a spirograph pattern, but more random\n    time *= .2;\n    vec2 a = vec2(1,.3)*time;\n    float r = sin(time*1.2)*.2+.8;\n    \n    return 100.0*r*vec3(cos(a.x),1,sin(a.x))*vec2(cos(a.y),sin(a.y)).xyx;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float T = iTime;\n    \n    // create a camera without constant \"up\", so we get more spacey feel and more variety\n    \n    // fly a \"plane\", with a free camera inside it\n    // i.e. \"up\" stays in the plane of the curve\n    \n    \n    vec3 pos = Path(T);\n    \n    float d = .5;\n    vec3 a=Path(T+d), b=Path(T-d);\n    vec3 sky = (a+b)/2.0-pos;\n\n    // alternate between looking forward and looking toward centre of nebula, for parallax\n    vec3 forward = normalize( mix( normalize(a-b), normalize(vec3(0)-pos), smoothstep( -.2, .2, sin(T*.2) ) ) );\n    vec3 right = normalize(cross(sky,forward));\n    vec3 up = normalize(cross(forward,right));\n    \n    vec2 uv = (fragCoord.xy-iResolution.xy*.5)/iResolution.y;\n    vec3 ray = forward*1.0 + right*uv.x + up*uv.y;\n    ray = normalize(ray);\n    \n    vec3 c = vec3(0,0,0);\n\tfloat t = 0.0;\n    float baseStride = 3.0; // small enough to detect the highest frequency details\n    float stride = baseStride;\n    float visibility = 1.0;\n    for ( int i=0; i < 30; i++ )\n    {\n        if ( visibility < .001 ) break; // causes \"ripples\" on things, but not bad.\n        \n        vec4 samplev = Density( pos + t*ray );\n        float visibilityAfterSpan = pow( 1.0-samplev.a, stride );\n\n\t\t// optional: don't allow any non-occluding glow\n        samplev.rgb *= samplev.a;\n\n        c += samplev.rgb*visibility*(1.0-visibilityAfterSpan); // this seems too easy!\n        visibility *= visibilityAfterSpan;\n\n//        float newStride = baseStride/visibility; // this is wrong, but looks amazing!\n        float newStride = baseStride/mix(1.0,visibility,.3); // step further when visibility is reduced (but not too much\n        t += (stride+newStride)*.5;\n        stride = newStride;\n    }\n    \n    c = pow(c,vec3(1.0/2.2));\n    \n    // dithering, because I can see banding\n    c += (texture(iChannel1,(fragCoord.xy+.5)/8.0,-100.0).x-.5)/256.0;\n    \n\tfragColor = vec4(c,1);\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xs2SzR.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1236, 1236, 1262, 1262, 1615], [1618, 1618, 1643, 1701, 1863], [1866, 1866, 1923, 1923, 3828]], "test": "error"}
{"id": "XsBSRz", "name": "N Tunel", "author": "Wingrime", "description": "Well, thats my first raymach shader", "tags": ["raymach"], "likes": 0, "viewed": 147, "published": "Public", "date": "1408116249", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec3 l = normalize( vec3(1.0,1.0 ,-2.0) );\n\nfloat sdFloat(vec3 p, float s) {\n\treturn length(p)-s;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n        return length(max (abs(p) -b ,0.0) );\n}\n\nfloat lambert(vec3 n , vec3 l) {\n\treturn max(dot(n, l) , 0.0);\n}\nvec2 rot(vec2 r,float ang) {\n    return vec2(r.x* cos(ang) - r.y * sin(ang),  r.x*sin(ang) + r.y* cos(ang) ) ;\n}\nfloat obj(vec3 rp) {\nvec2 rotx =   rot(vec2(rp.x,rp.z) ,0.04*sin(iTime));\n\nvec3 trn = vec3(1.0,1.0,1.0);\n\nvec3 nrp1 = vec3(rotx.x ,rp.y , rotx.y + 5.0*iTime);\n\nvec3 nrp1_2 = nrp1+ vec3(0.5,0.5,0.0);\n\nvec3 nrp2= mod( nrp1_2,trn)-0.5*trn;\n\n\nfloat nrp3 = max(-sdFloat(nrp2,0.55), sdBox(nrp2, vec3(0.5,0.5 ,0.5 )  ) );\n\n\nreturn  nrp3;\n}\n\nvec3 est_normal(vec3 rp ) {\n\nconst float diff = 0.0001;\n\nvec3 x_p = vec3(diff ,0.0,0.0);\nvec3 x_m = vec3(-diff ,0.0,0.0);\n\nvec3 y_p = vec3(0.0,diff ,0.0);\nvec3 y_m = vec3(0.0,-diff ,0.0);\n\nvec3 z_p = vec3(0.0,0.0 ,diff);\nvec3 z_m = vec3(0.0,0.0,-diff);\n\n\nfloat x_diff = obj(rp+x_p) - obj(rp+x_m);\nfloat y_diff = obj(rp+y_p) - obj(rp+y_m);\nfloat z_diff = obj(rp+z_p) - obj(rp+z_m);\n\nreturn normalize(vec3(x_diff,y_diff,z_diff));\n\n}\n\n\nvec3 raymatch_iter2(vec3 ro , vec3 rd ) {\n\n        vec3 rp = ro;\n        float s = 0.0;\n        const int mstep = 20;\n        const float eps = 0.0001;\n        for (int i = 0; i < mstep ; i++) {\n\n                s = obj(rp);\n\n                rp = rp + rd*s;\n        }\n\n        vec3 n = est_normal(rp);\n        vec3 ret = vec3(0.0);\n\n        if (abs(s) < eps) {\n            ret = vec3(1.0)*lambert(n, l);\n         }\n\n        return ret;\n\n}\n\nvec3 raymatch(vec3 ro , vec3 rd ) {\n\n        vec3 rp = ro;\n        float s = 0.0;\n        const int mstep = 80;\n        const float eps = 0.0001;\n\tfor (int i = 0; i < mstep ; i++) {\n\n\t\n                s = obj(rp);\n\n                rp = rp + rd*s;\n                if (abs(s) < eps ) break;\n\t\n\t}\n\n        //vec3 n = normalize(vec3 (rp));\n\n        vec3 n = est_normal(rp);\n        vec3 ret = vec3(0.0);\n\n        if (abs(s) < eps) {\n            //ret = vec3(1.0)*lambert(n, l) ;//+0.6*raymatch_iter2(rp+vec3(0.1), normalize(-reflect((rp-ro),n)));\n        ret = 0.5+0.5*n;\n        }\n\n        return ret;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n        vec2 uv = 2.0*(fragCoord.xy / iResolution.xy)-1.0;\n        /* projective*/\n        vec3 ro = vec3(0.0 , 0.0 , -5.0 );\n        /*ortogonal*/\n        //vec3 ro = vec3(uv.x , uv.y , -2.0 );\n\n        vec3 proj_plane = vec3 (uv.x , uv.y , -1.0 );\n\n\tvec3 rd = normalize( proj_plane - ro);\n\n\n\tvec3 res = raymatch(ro,rd);\n\n\tfragColor = vec4(res,1.0);\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsBSRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 45, 77, 77, 100], [102, 102, 131, 131, 179], [181, 181, 213, 213, 245], [246, 246, 274, 274, 358], [359, 359, 379, 379, 691], [693, 693, 720, 720, 1123], [1126, 1126, 1167, 1167, 1564], [1566, 1566, 1601, 1601, 2167], [2169, 2169, 2226, 2226, 2580]], "test": "ok"}
{"id": "XsfSWs", "name": "Gradation Panels", "author": "atmarksharp", "description": "Gradation Panels with 10 x 6 matrices. ", "tags": ["color", "panel"], "likes": 1, "viewed": 157, "published": "Public", "date": "1407678164", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 hsv_to_rgb(float h, float s, float v, float a)\n{\n\tfloat c = v * s;\n\th = mod((h * 6.0), 6.0);\n\tfloat x = c * (1.0 - abs(mod(h, 2.0) - 1.0));\n\tvec4 color;\n \n\tif (0.0 <= h && h < 1.0) {\n\t\tcolor = vec4(c, x, 0.0, a);\n\t} else if (1.0 <= h && h < 2.0) {\n\t\tcolor = vec4(x, c, 0.0, a);\n\t} else if (2.0 <= h && h < 3.0) {\n\t\tcolor = vec4(0.0, c, x, a);\n\t} else if (3.0 <= h && h < 4.0) {\n\t\tcolor = vec4(0.0, x, c, a);\n\t} else if (4.0 <= h && h < 5.0) {\n\t\tcolor = vec4(x, 0.0, c, a);\n\t} else if (5.0 <= h && h < 6.0) {\n\t\tcolor = vec4(c, 0.0, x, a);\n\t} else {\n\t\tcolor = vec4(0.0, 0.0, 0.0, a);\n\t}\n \n\tcolor.rgb += v - c;\n \n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float width = iResolution.x;\n    float height = iResolution.y;\n    float millis = iTime * 1.3;\n\tfloat ms = millis * 0.25;\n\tint panel_w = 10;\n\tint panel_h = 6;\n\tfloat sub_w = width / float(panel_w);\n\tfloat sub_h = height / float(panel_h);\n\tfloat cx = width / 2.0;\n\tfloat cy = height / 2.0;\n\n\tint grid_x = int(fragCoord.x / sub_w);\n\tint grid_y = int(fragCoord.y / sub_h);\n\tfloat shift_x = sin(ms) + 1.0;\n\tfloat rx = shift_x - (float(grid_x)/float(panel_w));\n\tfloat ry = float(grid_y)/float(panel_h);\n\n\tif(rx*ry > 0.1){\n\t\tfragColor = hsv_to_rgb(sin(ms)/2.0 + 0.5, rx * ry, 1.0, 1.0);\n\t}else{\n\t\tfragColor = hsv_to_rgb(sin(ms+0.1)/2.0 + 0.5, 0.1, 1.0, 1.0);\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsfSWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 53, 53, 631]], "test": "ok"}
{"id": "XsfXDl", "name": "Rock Shapes WIP", "author": "asteropaeus", "description": "Was hoping to have my first real shadertoy demo out in time to commemorate the Siggraph Hackathon, even if my schedule may not let me make it. As it turns out, this is quite unfinished:  buggy, slow, messy, and no texturing.  But it was sure fun!", "tags": ["raymarching"], "likes": 38, "viewed": 4731, "published": "Public", "date": "1407662638", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\nLets try out this distance field raymarching stuff, in the style of iq.\n\nExtremely unfinished and messy, but the basic idea - using randomly generated BSP splits to\ngenerate interesting shapes that resemble rock formations - seems to show some potential, if I\ncan get rid of all the artifacts.\n\nThe real fun would be if I could get a nice displacement working on top of all this.\n\nA great deal of optimization should be possible once I clean up some of this horrible mess.\n\nDaniel \"Asteropaeus\" Dresser\n\n*/\n\n\nconst float heightCap = 0.5;\n\nfloat hash( vec2 p )\n{\n\tfloat h = dot(p,vec2(127.1,311.7));\n\t\n    return -1.0 + 2.0*fract(sin(h)*43758.5453123);\n}\n\nvec2 getCell( vec3 p, out vec3 normals[6], out vec3 centers[6], out float hardnesses[6] )\n{\n\thardnesses[0] = hardnesses[1] = hardnesses[2] = hardnesses[3] = 0.002;\n\tnormals[0] = vec3(1,0,0);\n\tnormals[1] = vec3(1,0,0);\n\tnormals[2] = vec3(0,1,0);\n\tnormals[3] = vec3(0,1,0);\n\tcenters[0] = vec3(-1,0,0);\n\tcenters[1] = vec3(1,0,0);\n\tcenters[2] = vec3(0,-1,0);\n\tcenters[3] = vec3(0,1,0);\n\t\t\n\tvec3 splitAxis = vec3( 1.0, 0.0, 0.0 );\n\t//vec3 splitCenter = vec3(0.0, 0.0001 * iMouse.x / iResolution.x, 0.0);\n    //vec3 splitCenter = vec3(0.000007);\n    vec3 splitCenter = vec3(0.000027 + 0.000001 * floor(iTime / 20.0));\n\tfloat splitSize = 0.9;\n\tvec2 rockId = splitCenter.xy;\n\t\n\tfloat curAxis = 1.0;\n\tfor( float i = 0.0; i < 10.0; i += 1.0 )\n\t{\n\t\tcurAxis *= -1.0;\n        \n\t\tsplitAxis = vec3( normalize( curAxis * vec2(splitAxis.y, -splitAxis.x ) + 0.0 * 0.35 * vec2( hash( splitCenter.xy ), hash( splitCenter.xy + vec2( 0.1, 0.0 ) ) ) ),\n                         0.2 * hash( splitCenter.xy + vec2( 3.1, 3.0 ) ) );\n\n\t\t   \n\t\tfloat axisDot = dot( p - splitCenter, splitAxis);\n\t\tfloat dist = abs( axisDot );\n\t\t\n\t\t\n\t\tvec3 newSplitCenter = vec3( splitCenter.xy + sign( axisDot ) * splitAxis.xy * splitSize * ( 1.0 + 0.3 * hash( splitCenter.xy + vec2(0.7, sign(axisDot)))), 0.0 );\n\t\t//if( hash( newSplitCenter + vec2(0.2,0.7 ) ) > 0.3 * max( 1.0, 7.0 - i ) )\n        \n\t\t\n\t\tfloat splitPick = hash( splitCenter.xy + vec2(0.2,0.7 ) ) > 0.0 ? 1.0 : -1.0;\n        float hardness = hash( splitCenter.xy + vec2(0.2,0.7 ) ) > -( 1.0 - 1.9 * pow( 8.0 * length( rockId - newSplitCenter.xy ), 2.0 ) ) ? 1.0 : 0.0;\n\t\tif( axisDot * splitPick < 0.0 && hardness == 0.0 )\n\t\t//if( axisDot > 0.0 )\n\t\t{\n\t\t\trockId = newSplitCenter.xy;\n\t\t\thardnesses[0] = hardnesses[1] = hardnesses[2] = hardnesses[3] = 0.02;\n\t\t}\n        hardness = 0.02 * ( 1.0 - hardness ) + 0.002;\n\t\tif( curAxis > 0.0 )\n\t\t{\n\t\t\tif( axisDot > 0.0 )\n\t\t\t{\n                if( dot(centers[0] - splitCenter, splitAxis) < 0.0 )\n                {\n                    normals[0] = splitAxis;\n                    centers[0] = splitCenter;\n                    hardnesses[0] = hardness;\n                }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n                if( dot(centers[1] - splitCenter, splitAxis) > 0.0 )\n                {\n\t\t\t\t\tnormals[1] = splitAxis;\n\t\t\t\t\tcenters[1] = splitCenter;\n    \t            hardnesses[1] = hardness;   \n                }\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif( axisDot > 0.0 )\n\t\t\t{\n                if( dot(centers[2] - splitCenter, splitAxis) < 0.0 )\n                {\n                    normals[2] = splitAxis;\n                    centers[2] = splitCenter;\n                    hardnesses[2] = hardness;\n                }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n                if( dot(centers[3] - splitCenter, splitAxis) > 0.0 )\n                {\n\t\t\t\t\tnormals[3] = splitAxis;\n\t\t\t\t\tcenters[3] = splitCenter;\n                \thardnesses[3] = hardness;\n                }\n\t\t\t}\n\t\t}\n\t\t\n\t\tsplitCenter = newSplitCenter;\n\t\tsplitSize *= sqrt(0.5) * ( 1.0 + 0.0 * hash( splitCenter.xy + vec2(0.5,0.5) ) );\n\t}\n    \n    float eccentricity = 2.0 * (0.5 - length( rockId ));\n    normals[4] = normalize( vec3( eccentricity * 0.4 * hash(rockId + vec2(6.0)), 0.1 + eccentricity * 0.6 * hash(rockId + vec2(5.0)), 1.0 ) );\n    centers[4] = vec3( rockId.xy, eccentricity * eccentricity * eccentricity* 0.15 + 0.2 * hash(rockId + vec2(4.0)) );\n    \n    float extraChunkOffset = 0.1 * hash(splitCenter.xy + vec2(14.0));\n    centers[5] = vec3( splitCenter.xy, dot(centers[4] - splitCenter, normals[4]) / normals[4].z + extraChunkOffset );\n    normals[5] = normalize( vec3( hash(splitCenter.xy + vec2(15.0)), hash(splitCenter.xy + vec2(16.0)), 2.0 ) );\n                      \n    if( extraChunkOffset < 0.0 )\n    {\n        vec3 swap = normals[4];\n        normals[4] = normals[5];\n        normals[5] = swap;\n        swap = centers[4];\n        centers[4] = centers[5];\n        centers[5] = swap;\n    }\n    //normals[4] = vec3( 0.0, 0.0, 1.0 );\n    //normals[4] = vec3( 0.0, 0.0, 1.0 );\n    //float softnessBoost = 0.05 * pow( 0.5 * ( hash( splitCenter.xy + vec2( 12.0, 11.0 ) ) + 1.0), 3.0 );\n    hardnesses[0] = max( hardnesses[0], 0.03 * pow( 0.5 * ( hash( splitCenter.xy + vec2( 12.0, 11.0 ) ) + 1.0), 3.0 ) );\n    hardnesses[1] = max( hardnesses[0], 0.03 * pow( 0.5 * ( hash( splitCenter.xy + vec2( 12.0, 12.0 ) ) + 1.0), 3.0 ) );\n    hardnesses[2] = max( hardnesses[0], 0.03 * pow( 0.5 * ( hash( splitCenter.xy + vec2( 12.0, 13.0 ) ) + 1.0), 3.0 ) );\n    hardnesses[3] = max( hardnesses[0], 0.03 * pow( 0.5 * ( hash( splitCenter.xy + vec2( 12.0, 14.0 ) ) + 1.0), 3.0 ) );\n    //0.03 * ( 1.0 - closestHardness1 ) + 0.002 + softnessBoost;\n    \n    return length( splitCenter ) > 1.00 ? vec2(1e38) : rockId;\n}\n\nfloat cellMap( vec3 p, vec3 normals[6], vec3 centers[6], float hardnesses[6], vec2 rockId, float flip )\n{\n    if( rockId.x == 1e38 ) return 1e38;\n    float closestDist1 = 1e38;\n    float closestDist2 = 1e38;\n    float closestHardness1 = 1e38;\n    float closestHardness2 = 1e38;\n\n\n    float dir = -1.0;\n    for( int i = 0; i < 4; i += 1 )\n    {\n        dir *= -1.0;\n        float dist = dir * dot( p - centers[i], normals[i]);\n        if( dist < closestDist1 )\n        {\n            closestDist2 = closestDist1;\n            closestHardness2 = closestHardness1;\n            closestDist1 = dist;\n            closestHardness1 = hardnesses[i];\n        }\n        else if( dist < closestDist2 )\n        {\n            closestDist2 = dist;\n            closestHardness2 = hardnesses[i];\n        }\n    }\n\n    /*float softnessBoost = 0.1 * pow( 0.5 * ( hash( rockId + vec2( 12.0, 11.0 ) ) + 1.0), 3.0 );\n    float softness1 = 0.03 * ( 1.0 - closestHardness1 ) + 0.002 + softnessBoost;\n    float softness2 = 0.03 * ( 1.0 - closestHardness2 ) + 0.002 + softnessBoost;*/\n    float softness1 = closestHardness1;\n    float softness2 = closestHardness2;\n    \n    \n\n    if( softness2 > softness1 )\n    {\n    \tfloat swap = softness1;\n        softness1 = softness2;\n        softness2 = swap;\n        \n        swap = closestDist1;\n        closestDist1 = closestDist2;\n        closestDist2 = swap;\n    }\n\n\n    softness1 = max( softness1, closestDist1 );\n    softness2 = max( softness2, closestDist2 );\n\n    float softness = min( softness1, softness2 );\n    float verticalDist1 = -dot( p - centers[4], normals[4] );\n    float verticalDist2 = -dot( p - centers[5], normals[5] );\n    float pickSide = ( verticalDist2 <  verticalDist1 || verticalDist1 > 0.0 ) ? 1.0 : -1.0;\n    float verticalDist = pickSide == flip ? verticalDist1 :\n    \tmin( -verticalDist1, verticalDist2 );\n    //float verticalDist = verticalDist1;\n    \n\n    float bigRadAxis1 = softness1 - closestDist1;\n    float bigRadAxis2 = softness1 - verticalDist;\n    float bigRadAxis1Clamp = max( 0.0, bigRadAxis1);\n    float bigRadAxis2Clamp = max( 0.0, bigRadAxis2);\n    float bigRad = sqrt( bigRadAxis1Clamp * bigRadAxis1Clamp + bigRadAxis2Clamp * bigRadAxis2Clamp );\n    bigRad = bigRad > 0.0 ? bigRad : max( bigRadAxis1, bigRadAxis2 );\n    \n    float smallRadAxis1 = softness2 - closestDist2;\n    float smallRadAxis2 = softness2 - ( softness1 - bigRad );\n    float smallRadAxis1Clamp = max( 0.0, smallRadAxis1 );\n    float smallRadAxis2Clamp = max( 0.0, smallRadAxis2 );\n    float smallRad = sqrt( smallRadAxis1Clamp * smallRadAxis1Clamp + smallRadAxis2Clamp * smallRadAxis2Clamp );\n    smallRad = smallRad > 0.0 ? smallRad : max( smallRadAxis1, smallRadAxis2 );\n    //smallRad = min( smallRad, 0.0 );\n\n    //return bigRad - softness1;\n    return smallRad - softness2;\n}\n\nfloat getOcclusion( vec3 pos, vec3 nor, float stepLength, vec2 self )\n{\n    const float lookupRad = 0.06;\n    const int lookupSamples = 16;\n    const int steps = 4;\n    float ret = 0.0;\n    vec2 prevId = vec2( 0.0 );\n    for( int l = 0; l < lookupSamples; l++ )\n    {\n        float hardnesses[6];\n        vec3 normals[6];\n        vec3 centers[6];\n        float angle = float(l) / float(lookupSamples) * 2.0 * 3.14159265;\n        vec2 rockId = getCell( pos + lookupRad * vec3( sin( angle ), cos(angle), 0.0 ), normals, centers, hardnesses );\n        if( rockId == prevId ) continue;\n        prevId = rockId;\n        float flip = rockId != self ? 1.0 : -1.0;\n\n        float accum = 0.0;\n        for( int i = 0; i < steps; i++ )\n        {\n            float dist = float(i) * stepLength;\n            float cellDist = cellMap( pos + nor * dist, normals, centers, hardnesses, rockId, flip );\n            accum += max( 0.0, (dist - cellDist) / dist );\n        }\n        ret = max( ret, accum );\n\n    \t/*float step = 8.;\n    \tfloat ao = 0.;\n    \tfloat dist;\n    \tfor (int i = 1; i <= 3; i++) {\n        dist = step * float(i);\n\t\tao += max(0., (dist - map(p + n * dist).y) / dist);*/\n    }\n    //return 1. - ao * 0.1;\n    return 0.2 * ret;\n}\n\n\nfloat trace( vec3 camPos, vec3 camDir, float t, float reflT, vec3 reflDir, out vec3 hit, out float hardnesses[6], out vec3 normals[6], out vec3 centers[6], out vec2 rockId )\n{\n    float marchThroughBorder = 0.0001;\n    float status = 1.0;\n    for( float j = 0.0; j < 40.0; j += 1.0 )\n    {\n        float curCellStartT = t;\n        //march += camDir * 0.005;\n        t += marchThroughBorder;\n        if( reflT < t )\n        {\n            /*camPos = camPos + camDir * reflT;\n            camDir = reflDir;\n            t = marchThroughBorder;\n            status = -1.0;\n            reflT = 1e38;*/\n            hit = camPos + camDir * reflT;\n            return -1.0;\n        }\n\n        vec3 march = camPos + camDir * t;\n\n\n        if( ( abs( march.x ) > 1.0 && march.x * camDir.x > 0.0 ) ||\n            ( abs( march.y ) > 1.0 && march.y * camDir.y > 0.0 ) || march.z > heightCap) break;\n\n        rockId = getCell( march, normals, centers, hardnesses );\n\n\n        float sideDot0 = dot( camDir, normals[0] );\n        float sideDot1 = dot( camDir, normals[1] );\n        float sideDot2 = dot( camDir, normals[2] );\n        float sideDot3 = dot( camDir, normals[3] );\n        float sideDot4 = dot( camDir, normals[4] );\n        float sideDot5 = dot( camDir, normals[5] );\n        float cellExitDist = reflT;\n        if( sideDot0 < 0.0 ) cellExitDist = min( cellExitDist, dot( normals[0], centers[0] - camPos) / sideDot0 ); \n        if( sideDot1 > 0.0 ) cellExitDist = min( cellExitDist, dot( normals[1], centers[1] - camPos) / sideDot1 );\n        if( sideDot2 < 0.0 ) cellExitDist = min( cellExitDist, dot( normals[2], centers[2] - camPos) / sideDot2 );\n        if( sideDot3 > 0.0 ) cellExitDist = min( cellExitDist, dot( normals[3], centers[3] - camPos) / sideDot3 );\n        t = max( t, min( sideDot4 > 0.0 ? 0.0 : dot( normals[4], centers[4] - camPos) / sideDot4,\n                        sideDot5 > 0.0 ? 0.0 : dot( normals[5], centers[5] - camPos) / sideDot5 ) );\n        //hitColor = normals[3] * 0.5 + vec3(0.5);\n        //hitColor = vec3( cellExitDist * 0.1 );\n        //break;\n\n        float dist = 1e38;\n        float mapTol = 0.001;\n        for( float k = 0.0; k < 20.0; k += 1.0 )\n        {\n            dist = cellMap( camPos + camDir * t, normals, centers, hardnesses, rockId, 1.0 );\n            if( dist < mapTol || t + dist > cellExitDist ) break;\n            t += dist;\n        }\n\n        if( dist < mapTol && t < reflT)\n        {\n            /*vec2 checkRockId = getCell( camPos + camDir * t, normals, centers, hardnesses );\n            if( checkRockId != rockId )\n            {\n                //reflectionMult *= vec3( 1.0, 0.0, 0.0 );\n                //t = curCellStartT * 0.75 + t * 0.25;\n                //t = curCellStartT + 0.1;\n                continue;\n\n            }*/\n            \n            hit = camPos + camDir * t;\n            //hitColor = reflectionMult * vec3( 0.8 );\n            return status;\n            //break;\n        }\n\n        t = cellExitDist;\n    }\n    \n    return 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0 * fragCoord.xy / iResolution.xy - vec2(1)) * vec2( 1.0, 1.0 );\n    \n    float camAngle = ( iMouse.z < 0.0 ? 0.0 : iMouse.x - iMouse.z ) / iResolution.x * 4.0 * 3.1415926 - 0.1 + iTime / 20.0 * 2.0 * 3.14159265;\n    float camDistance = max( 16.0 * ( iMouse.w < 0.0 ? 0.0 : iMouse.y - iMouse.w ) / iResolution.y + 2.1, 0.0001 );\n    //float camAngle = abs( iMouse.x ) / iResolution.x * 4.0 * 3.1415926 - 2.6 + 2.0;\n    //float camDistance = max( 16.0 * abs (iMouse.y ) / iResolution.y - 1.0, 0.0001 ) ;\n    vec3 camPos = vec3( sin( camAngle ) * camDistance, cos( camAngle ) * camDistance, 0.35 );\n    vec3 camForward = normalize( vec3( 0.0, 0.0, 0.0 ) - camPos );\n    vec3 camRight = normalize( cross( vec3( 0.0, 0.0, 1.0 ), camForward ) );\n    vec3 camUp = normalize( cross( camForward, camRight ) );\n    \n    vec3 camDir = normalize( camForward + 0.3 * iResolution.x / iResolution.y * camRight * uv.x + 0.3 * camUp * uv.y );\n\t\n    float waterHitT = -camPos.z / camDir.z;\n    vec3 waterHit = camPos + waterHitT * camDir;\n    vec3 waterNorm = normalize( vec3( 0.0, 0.03 * sin( 120.0 * waterHit.y + 2.0 * iTime ) + 0.1 * sin( 10.0 * waterHit.y + iTime ), 1.0 ) );\n    vec3 reflDir = reflect( camDir, waterNorm );\n    \n    \n    \n    /*float shortestStartIntersection = (1.0 - camPos.x ) / camDir.x;\n    shortestStartIntersection = min( shortestStartIntersection, (-1.0 - camPos.x ) / camDir.x );\n    shortestStartIntersection = min( shortestStartIntersection, (1.0 - camPos.y ) / camDir.y );\n    shortestStartIntersection = min( shortestStartIntersection, (-1.0 - camPos.y ) / camDir.y );*/\n    \n\n    vec3 reflectionMult = vec3( 1.0 );\n    \n    \n    vec3 hitColor = vec3( -1.0 );\n    /*if( camDir.z > 0.0 )\n    {\n        hitColor = vec3( 0.3, 0.3, 0.8 );\n    }\n    else*/\n    {\n        float t = max( (-sign( camDir.x ) - camPos.x ) / camDir.x, (-sign( camDir.y) - camPos.y ) / camDir.y );\n    \tt = max( t, (heightCap - camPos.z ) / camDir.z );\n        \n        //float waterDist = ( -camPos.z ) / camDir.z;\n        \n        vec3 cellTracingCamDir = camDir;\n        vec3 cellTracingCamPos = camPos;\n        float status = 1.0;\n        vec3 hit = waterHit;\n        if( waterHitT < t )\n        {\n            //cellTracingCamPos = waterHit;\n            //cellTracingCamDir = reflDir;\n            //t = max( (-sign( cellTracingCamDir.x ) - cellTracingCamPos.x ) / cellTracingCamDir.x, (-sign( cellTracingCamDir.y) - cellTracingCamPos.y ) / cellTracingCamDir.y );\n            // //reflectionMult = vec3( 0.5 );\n            //hit = waterHit;\n            status = -1.0;\n            //waterHitT = 1e38;\n        }\n\n        \n        //shortestStartIntersection = 1.0;\n        //vec3 march = camPos + camDir * ( shortestStartIntersection + marchThroughBorder );\n\n        float hardnesses[6];\n        vec3 normals[6];\n        vec3 centers[6];\n        vec2 rockId;\n\n        \n        if( status > 0.0 )\n        {\n\t\t\tstatus *= trace( cellTracingCamPos, cellTracingCamDir, t, waterHitT, reflDir, hit, hardnesses, normals, centers, rockId );\n        }\n        /*if( dot( hit - cellTracingCamPos, cellTracingCamDir ) > waterHitT )\n        {\n\t\t\thit = cellTracingCamPos + waterHitT * cellTracingCamDir;\n        \tstatus = -1.0;\n        }*/\n    \n\t\tvec3 sunDir = normalize( vec3( 1.0, 1.0, 1.0 ) );\n        //if( hitColor.x >= 0.0 )\n        //if( status != 0.0 )\n        {\n            \n            //vec3 march = camPos + camDir * t;\n            vec3 nor;\n            if( status == 1.0 )\n            {\n                vec3 eps = vec3( 0.001, 0.0, 0.0 );\n                nor = normalize( vec3(\n                    cellMap( hit + eps.xyy, normals, centers, hardnesses, rockId, 1.0 ) - cellMap( hit - eps.xyy, normals, centers, hardnesses, rockId, 1.0 ),\n                    cellMap( hit + eps.yxy, normals, centers, hardnesses, rockId, 1.0 ) - cellMap( hit - eps.yxy, normals, centers, hardnesses, rockId, 1.0 ),\n                    cellMap( hit + eps.yyx, normals, centers, hardnesses, rockId, 1.0 ) - cellMap( hit - eps.yyx, normals, centers, hardnesses, rockId, 1.0 )\n                ) );\n            }\n            else\n            {\n                nor = vec3( 0.0, 0.0, 1.0 );\n                rockId = vec2( 0.0 );\n            }\n\n            //nor = vec3( 0.0, 0.0, 1.0 );\n\n            \n            float test = hit.x;\n            float occlMult = 1.0 - getOcclusion( hit, nor, 0.01, rockId );\n            occlMult = occlMult > 0.0 ? occlMult : 1.0;\n            hitColor = mix( vec3( 0.2, 0.2, 0.3 ), vec3 ( 0.2, 0.2, 0.19 ), -nor.z * 0.5 + 0.5 ) * max( 0.0, occlMult );\n            \n            float shadow = max( 0.0, trace( hit, sunDir, 0.01, 1e38, vec3( 0.0 ), hit, hardnesses, normals, centers, rockId ) );\n            //float shadow = 0.0;\n\n            hitColor += vec3( 0.65, 0.6, 0.45 ) * max( 0.0, dot( normalize(nor), sunDir ) ) * ( 1.0 - shadow );\n            \n            //hitColor.z = sin( test );\n            //hitColor *= status < 0.0 ? 0.5 : 1.0;\n        }\n        /*else\n        {\n            vec3 halfAng = normalize( sunDir - camDir );\n            hitColor = vec3( 0.1, 0.1, 0.5 ) + pow( max( 0.0, dot( halfAng, waterNorm ) ), 8.0 );\n        }*/\n    }\n    //if( hitColor == vec3( -1.0 ) ) hitColor = vec3( 0.1, 0.1, 0.5 );\n\n\t//vec3 material = vec3( 0.7 + 0.3 * hash(rockId + vec2(1.0)) );\n\t//material.xy = vec2( 0.0 );\n\t//float mask = clamp( edgemask * 1000.0, 0.0, 1.0 );\n\t//fragColor = vec4( mix( vec3( 0.4, 0.35, 0.25 ), mix( 1.0, 0.4 + 0.6 * pow( clamp( edgemask, 0.0, 1.0 ), 0.4), 20.0 * softness ) * material, mask ), 1.0);\n    const float gamma = 1.0 / 2.4;\n    fragColor = vec4( pow( hitColor.x, gamma ), pow( hitColor.y, gamma ), pow( hitColor.z, gamma ), 1.0 );\n\t//fragColor += 1.0 * vec4( closestDist1 / softness1, closestDist2 / softness2, 0.0, 1.0);\n\t//fragColor = vec4( 0.0 );\n\t//fragColor += 0.5 * vec4( clamp( closestDist1 / softness1, 0.0, 1.0), clamp( closestDist2 / softness2, 0.0, 1.0 ), 0.0, 1.0);\n\t//fragColor = vec4( vec3( 0.0 ) * ( 1.0 - binary_edge ) + binary_edge * vec3( 0.7 + 0.3 * hash(rockId + vec2(1.0)) ), 1.0);\n\t//fragColor = vec4( vec3( 0.5 ) * min( 1.0, 1.0 - edgemask * 1000.0 ), 1.0 );\n    //fragColor = vec4( iMouse.z, -iMouse.z * 0.001, iMouse.z * 0.01, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsfXDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[543, 543, 565, 565, 657], [659, 659, 750, 750, 5345], [5347, 5347, 5452, 5452, 8157], [8159, 8159, 8230, 8230, 9390], [9393, 9393, 9568, 9568, 12397], [12399, 12399, 12456, 12456, 18671]], "test": "ok"}
{"id": "XsjXz1", "name": "Blue Iris", "author": "lexicobob", "description": "my shader attempt from iq's eye tutorial on youtube, using his cool noise functions.  https://www.youtube.com/watch?v=emjuqqyq_qc", "tags": ["example", "tutorial", "eye", "youtube"], "likes": 6, "viewed": 526, "published": "Public", "date": "1409234934", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This is a procedural pattern that has 2 parameters, that generalizes cell-noise, \n// perlin-noise and voronoi, all of which can be written in terms of the former as:\n//\n// cellnoise(x) = pattern(0,0,x)\n// perlin(x) = pattern(0,1,x)\n// voronoi(x) = pattern(1,0,x)\n//\n// From this generalization of the three famouse patterns, a new one (which I call \n// \"Voronoise\") emerges naturally. It's like perlin noise a bit, but within a jittered \n// grid like voronoi):\n//\n// voronoise(x) = pattern(1,1,x)\n//\n// Not sure what one would use this generalization for, because it's slightly slower \n// than perlin or voronoise (and certainly much slower than cell noise), and in the \n// end as a shading TD you just want one or another depending of the type of visual \n// features you are looking for, I can't see a blending being needed in real life.  \n// But well, if only for the math fun it was worth trying. And they say a bit of \n// mathturbation can be healthy anyway!\n\n\n// Use the mouse to blend between different patterns:\n\n// ell noise    u=0,v=0\n// voronoi      u=1,v=0\n// perlin noise u=0,v1=\n// voronoise    u=1,v=1\n\n// More info here: http://iquilezles.org/www/articles/voronoise/voronoise.htm\n\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat iqnoise( in vec2 x, float u, float v )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\t\t\n\tfloat k = 1.0+63.0*pow(1.0-v,4.0);\n\t\n\tfloat va = 0.0;\n\tfloat wt = 0.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = vec2( float(i),float(j) );\n\t\tvec3 o = hash3( p + g )*vec3(u,u,1.0);\n\t\tvec2 r = g - f + o.xy;\n\t\tfloat d = dot(r,r);\n\t\tfloat ww = pow( 1.0-smoothstep(0.0,1.414,sqrt(d)), k );\n\t\tva += o.z*ww;\n\t\twt += ww;\n    }\n\t\n    return va/wt;\n}\n\nfloat noise ( vec2 x)\n{\n\treturn iqnoise(x, 0.0, 1.0);\n}\n\nmat2 m = mat2( 0.8, 0.6, -0.6, 0.8);\n\nfloat fbm( vec2 p)\n{\n\tfloat f = 0.0;\n    f += 0.5000 * noise(p); p *= m* 2.02;\n    f += 0.2500 * noise(p); p *= m* 2.03;\n    f += 0.1250 * noise(p); p *= m* 2.01;\n    f += 0.0625 * noise(p); p *= m* 2.04;\n    f /= 0.9375;\n    return f;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    \n    \n    float background = 1.0;// smoothstep(-0.25, 0.25, p.x);\n    \n    float r = sqrt( dot (p,p));\n    float a = atan(p.y, p.x) + 0.01*iTime;\n    vec3 col = vec3(1.0);\n    \n    float ss = 0.5 + 0.5 * sin(iTime * 2.0);\n    float anim = 1.0 + 0.05*ss* clamp(1.0-r, 0.0, 1.0);\n    r *= anim;\n    \n    if( r< 0.8)\n    {\n\t\tcol = vec3(0.12, 0.60, 0.57);\n        float f = fbm(5.0 * p);\n        col = mix(col, vec3(0.12,0.52, 0.60), f); // iris bluish green mix\n        \n        f = 1.0 - smoothstep( 0.2, 0.4, r);\n        col = mix(col, vec3(0.60,0.44,0.12), f); //yellow\n        \n        a += 0.05 * fbm(20.0*p);\n        \n        f = smoothstep(0.3, 1.0, fbm(vec2(5.0 * r, 20.0 * a))); //white highlight\n        col = mix(col, vec3(1.0), f);\n        \n        f = smoothstep(0.3, 1.0, fbm(vec2(5.0 * r, 5.0 * a))); //yellow highlight\n        col = mix(col, vec3(0.60,0.44,0.12), f);\n        \n        f = smoothstep(0.5, 1.0, fbm(vec2(5.0 * r, 15.0 * a))); //dark highlight\n        col *= 1.0 - f;\n        \n        f = smoothstep(0.55, 0.8, r); //dark at edge\n        col *= 1.0 - 0.5*f;\n        \n        f = smoothstep( 0.2, 0.25, r); //pupil\n        col *= f;\n        \n        f = 1.0 - smoothstep(0.0, 0.5, length(p - vec2(0.24, 0.2))); //light\n        col += vec3(1.0, 0.9, 0.8) *f * 0.75;       \n        \n        f = smoothstep(0.75, 0.8, r);\n        col = mix(col, vec3(1.0), f);\n    }\n    \n\tfragColor = vec4(col * background ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsjXz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1199, 1199, 1221, 1221, 1372], [1374, 1374, 1420, 1420, 1855], [1857, 1857, 1880, 1880, 1912], [1952, 1952, 1972, 1972, 2189], [2192, 2192, 2249, 2249, 3805]], "test": "ok"}
{"id": "XslSWl", "name": "Hypercomplex", "author": "TDM", "description": "modification of julia set. julia fractal distant function based on Inigo Quilez implementation: https://www.shadertoy.com/view/MsfGRr", "tags": ["julia", "sphere", "occlusion", "complex", "tracing", "quaternion", "ambient"], "likes": 84, "viewed": 2700, "published": "Public", "date": "1409270837", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Hypercomplex\" by Alexander Alekseev aka TDM - 2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst int NUM_STEPS = 128;\nconst int AO_SAMPLES = 3;\nconst float INV_AO_SAMPLES = 1.0 / float(AO_SAMPLES);\nconst float EPSILON = 1e-5;\nconst vec3 RED = vec3(0.6,0.03,0.08);\nconst vec3 ORANGE = vec3(0.3,0.1,0.1);\nconst vec3 BG = vec3(0.05,0.05,0.075);\n\n// lighting\nfloat diffuse(vec3 n,vec3 l,float p) { return pow(dot(n,l) * 0.4 + 0.6,p); }\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 8.0) / (3.1415 * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\nfloat specular(vec3 n,vec3 e,float s) {    \n    float nrm = (s + 8.0) / (3.1415 * 8.0);\n    return pow(max(1.0-abs(dot(n,e)),0.0),s) * nrm;\n}\n\n// julia based on iq's implementation\nfloat julia(vec3 p,vec4 q) {\n    vec4 nz, z = vec4(p,0.0);\n    float z2 = dot(p,p), md2 = 1.0;    \n    for(int i = 0; i < 11; i++) {\n        md2 *= 4.0*z2;\n        nz.x = z.x*z.x-dot(z.yzw,z.yzw);\n        nz.y = 2.0*(z.x*z.y + z.w*z.z);\n        nz.z = 2.0*(z.x*z.z + z.w*z.y);\n        nz.w = 2.0*(z.x*z.w - z.y*z.z);\n        z = nz + q;\n        z2 = dot(z,z);\n        if(z2 > 4.0) break;\n    }    \n\treturn 0.25*sqrt(z2/md2)*log(z2);    \n}\n\nfloat rsq(float x) {\n    x = sin(x);\n    return pow(abs(x),3.0) * sign(x);\n}\n\n// world\nfloat map(vec3 p) {\n    const float M = 0.6;\n    float time = iTime + rsq(iTime*0.5) * 2.0;\n    return julia(p,vec4( \n        sin(time*0.96456)*0.451*M,\n        cos(time*0.59237)*0.435*M,\n        sin(time*0.73426)*0.396*M,\n        cos(time*0.42379)*0.425*M\n    ));\n}\n    \nvec3 getNormal(vec3 p) {\n    vec3 n;\n    n.x = map(vec3(p.x+EPSILON,p.y,p.z));\n    n.y = map(vec3(p.x,p.y+EPSILON,p.z));\n    n.z = map(vec3(p.x,p.y,p.z+EPSILON));\n    return normalize(n-map(p));\n}\nfloat getAO(vec3 p,vec3 n) {    \n    const float R = 3.0;\n    const float D = 0.8;\n    float r = 0.0;\n    for(int i = 0; i < AO_SAMPLES; i++) {\n        float f = float(i)*INV_AO_SAMPLES;\n        float h = 0.1+f*R;\n        float d = map(p + n * h);\n        r += clamp(h*D-d,0.0,1.0) * (1.0-f);\n    }    \n    return clamp(1.0-r,0.0,1.0);\n}\n\nfloat spheretracing(vec3 ori, vec3 dir, out vec3 p) {\n    float t = 0.0;    \n    for(int i = 0; i < NUM_STEPS; i++) {\n        p = ori + dir * t;\n        float d = map(p);\n        if(d <= 0.0 || t > 2.0) break;\n        t += max(d*0.3,EPSILON);\n    }    \n    return step(t,2.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;    \n    float time = iTime * 0.1;\n    vec2 sc = vec2(sin(time),cos(time));\n    \n    // tracing of distance map\n    vec3 p;\n    vec3 ori = vec3(0.0,0.0,1.5);\n    vec3 dir = normalize(vec3(uv.xy,-1.0));    \n    ori.xz = vec2(ori.x * sc.y - ori.z * sc.x, ori.x * sc.x + ori.z * sc.y);\n    dir.xz = vec2(dir.x * sc.y - dir.z * sc.x, dir.x * sc.x + dir.z * sc.y);\n    \n    float mask = spheretracing(ori,dir,p);\n    vec3 n = getNormal(p);\n    float ao = pow(getAO(p,n), 2.2);\n    ao *= n.y * 0.5 + 0.5;\n    \n    // bg    \n    vec3 bg = mix(\n        mix(vec3(0.0), BG,        \n        \tsmoothstep(-1.0,1.0,uv.y)),\n        mix(BG*0.5, vec3(0.0),        \n        \tsmoothstep(-1.0,1.0,uv.y)),\n        smoothstep(-1.0,1.0,uv.x));      \n    bg *= 0.8 + 0.2 * smoothstep(0.1,0.0,sin((uv.x-uv.y)*40.0));\n    \n    // color\n    vec3 l0 = normalize(vec3(-0.0,0.0,-1.0));\n    vec3 l1 = normalize(vec3(0.3,0.5,0.5));\n    vec3 l2 = normalize(vec3(0.0,1.0,0.0));\n    vec3 color = RED * 0.4;\n    color += specular(n,l0,dir,1.0) * RED;\n    color += specular(n,l1,dir,1.0) * ORANGE * 1.1; \n    color = color*ao*4.0;\n    \n    color = mix(bg,color,mask);\n        \n    //color = vec3(ao);\n    //color = n * 0.5 + 0.5;\n\t\n\tfragColor = vec4(pow(color,vec3(0.4545)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XslSWl.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[395, 407, 445, 445, 483], [484, 484, 530, 530, 634], [635, 635, 674, 674, 776], [778, 816, 844, 844, 1254], [1256, 1256, 1276, 1276, 1332], [1334, 1343, 1362, 1362, 1609], [1615, 1615, 1639, 1639, 1811], [1812, 1812, 1840, 1840, 2149], [2151, 2151, 2204, 2204, 2429], [2431, 2431, 2488, 2488, 3842]], "test": "ok"}
{"id": "XslXWs", "name": "[SIG2014] CircleSlide", "author": "asteropaeus", "description": "Well, I sat down and someone told me the theme was circles, so this may be a bit less 3 dimensional than it should be for the theme ...", "tags": ["wip"], "likes": 3, "viewed": 177, "published": "Public", "date": "1407869414", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Start with iq's voronoi noise from https://www.shadertoy.com/view/ldl3W8\nvec2 hash2( vec2 p )\n{\n\t// texture based white noise\n\treturn texture( iChannel0, (p+0.5)/256.0, -100.0 ).xy;\n\t\n    // procedural white noise\t\n\t//return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec3 voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n    vec2 col;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( iTime + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n            col = o;\n        }\n    }\n    \n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec3( col, md );\n}\n\nvec2 rotateCircle( vec2 p, vec2 center, float angle, float inner, float outer )\n{\n    vec2 disp = p - center;\n    float l = length( disp );\n    vec2 rotX = vec2( cos( angle ), sin( angle ) );\n    vec2 rotY = rotX.yx * vec2( -1.0, 1.0 );\n    \n    return ( l > outer || l < inner ) ? p : center + vec2( dot( disp, rotX ), dot( disp, rotY ) ); \n}\n\nstruct circleStruct\n{\n    vec2 center;\n    float angle;\n    float inner;\n    float outer;\n};\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = 2.0 * (fragCoord.xy/iResolution.xx) - vec2(1.0,iResolution.y / iResolution.x  );\n    \n    const int numSplits = 5;\n    vec4 circleStruct[numSplits];\n    float circleRot[numSplits];\n    \n    vec2 splitCenter = vec2( 0.0 );\n    vec2 splitAxis = normalize( vec2( 1.0, 0.3 ) );\n    float splitSize = 0.9;\n\n    for( int i = numSplits - 1; i >= 0; i -- )\n\t{   \n        circleStruct[i] = vec4( splitCenter, 0.6 * splitSize, 0.8 * splitSize );\n        splitSize *= 0.8;\n\t\tsplitAxis = vec2( normalize( vec2(splitAxis.y, -splitAxis.x ) + 0.0 * 0.35 * hash2( 256.0 * splitCenter.xy ) ) );\n        float axisDot = dot( p - splitCenter, splitAxis );\n        splitCenter = vec2( splitCenter + sign( axisDot ) * splitAxis * splitSize );\n        \n        \n    }\n    for( int i = 0; i < numSplits; i++ )\n\t{\n        p = rotateCircle( p, circleStruct[i].xy, max( 0.0, iTime - float(numSplits - 1 - i) * 5.0 ), circleStruct[i].z, circleStruct[i].w );\n    }\n        \n    //p = rotateCircle( p, vec2(0.5), iTime, 0.3, 0.5 );\n    //p = rotateCircle( p, vec2(0.0), iTime, 0.5, 0.7 );\n    \n    vec3 c = voronoi( 16.0*p );\n\n\t// isolines\n    /*vec3 col = c.x*(0.5 + 0.5*sin(64.0*c.x))*vec3(1.0);\n    // borders\t\n    col = mix( vec3(1.0,0.6,0.0), col, smoothstep( 0.04, 0.07, c.x ) );\n    // feature points\n\tfloat dd = length( c.yz );\n\tcol = mix( vec3(1.0,0.6,0.1), col, smoothstep( 0.0, 0.12, dd) );\n\tcol += vec3(1.0,0.6,0.1)*(1.0-smoothstep( 0.0, 0.04, dd));*/\n    vec3 col = mix( vec3( 0.2 ), vec3( hash2( c.xy * 256.0 ), 0.0 ), 1.0 - pow( 1.0 - c.z, 4.0 ) );\n    \n\n\tfragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XslXWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 76, 98, 128, 309], [311, 311, 338, 338, 1397], [1399, 1399, 1480, 1480, 1742], [1838, 1838, 1895, 1895, 3479]], "test": "error"}
{"id": "XsSSRz", "name": "Tiny Ray Marcher 3.0", "author": "Aaro", "description": "Oh its on. I'm sure comment section will be full with compacting suggestions... probs about the normal calculation.<br/>1.0 version: https://www.shadertoy.com/view/MdfXWl<br/>2.0 version: https://www.shadertoy.com/view/ldsXDs", "tags": ["reflection", "ray", "shadow", "marching", "tiny"], "likes": 4, "viewed": 267, "published": "Public", "date": "1408111927", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Tiny Ray Marcher 3.0\n\n//Originally written by Aaro Permaa, compacting by Ben and Dave_Hoskins\n//466 characters\n\n#define k =min(length(p-q)-a,p.y+a);p+=j\n#define n normalize\n#define v vec3\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    v R=iResolution;\n\tv u=(2.*fragCoord.xyx-R)/R.y;\n\tfloat t=0.,r=1.,c=t,h=3.,s=t,a=r,b=.1;\n\tu.z=r;\n\tv o=u,p=u,q=v(7,abs(sin(iTime*h)),4),l=q.xxz,g=u,j=v(0,-b,b);\n\tq.x=t;\n\tfor(int i=0;i<192;i++)\n\t{\n\t\tp=u*t+o;\n\t\th k-j;\n\t\ti>127 ?r=min(r,8.*h/t):h<.001 ? c=5./length(p-l):t;\n\t\tt+=h;\n\t\tif(i==63){\n\t\t\to=p;\n\t\t\ts=c;\n\t\t\th k.zxx;\n\t\t\tt k.yzx;\n\t\t\tr k;\n\t\t\tp.x k;\n\t\t\tu=reflect(u,normalize(v(t,r,p.x)-h));\n\t\t\tt=b;\n\t\t\tr=a;\n\t\t}\n\t\tif(i==127){\n\t\t\tu=normalize(l-o);\n\t\t\tt=b;\n\t\t}\n\t}\n\tfragColor=vec4(c*r);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsSSRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "ok"}
{"id": "XsSSzh", "name": "Floating Sphere", "author": "MikeCAT", "description": "A sphere is floating in 3D space. Its color alse changes. We consider the light, but the calculation for light is not considered deeply.", "tags": ["3d", "sphere", "practice"], "likes": 0, "viewed": 148, "published": "Public", "date": "1408627739", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 spherePos=vec4(0.0,0.0,20.0,15.0); // {x,y,z,r}\nvec4 sphereColor=vec4(1.0,0.85,0.0,0.4); // {r,g,b,alpha}\nconst vec3 lightPos=vec3(40.0,-50.0,70.0); // {x,y,z}\nconst vec4 lightColor=vec4(1.0,1.0,1.0,0.8); // {r,g,b,alpha}\nconst vec4 floorColor1=vec4(0.0,0.0,0.0,1.0); // {r,g,b,alpha}\nconst vec4 floorColor2=vec4(1.0,1.0,1.0,1.0); // {r,g,b,alpha}\nconst vec4 backGroundColor=vec4(0.0,0.0,0.0,1.0); // {r,g,b,a}\nconst vec3 cameraPos=vec3(0.0,-80.0,55.0); // {x,y,z}\nconst vec3 cameraDir=vec3(0.0,0.847998,-0.529999); // {x,y,z}\nconst vec3 cameraX=vec3(1.0,0.0,0.0); // {x,y,z}\nconst vec3 cameraY=vec3(0.0,0.529999,0.847998); // {x,y,z}\n\nconst float EPS=1e-2;\n\nstruct LineSphereHitPointInfo {\n\tint n; // number of hitting point(s)\n\tfloat t[2]; // t for hitting point(s)\n};\n\n/*\n * Calculate hitting point of line P=ins+t*ind and sphere.\n * @param ins start point of the line\n * @param ind direction vector of the line\n * @param inc center and radius of the sphere\n * @return information about hitting point\n */\nLineSphereHitPointInfo getLineSphereHitPoint(vec3 ins,vec3 ind,vec4 inc) {\n\tLineSphereHitPointInfo ret;\n\tvec3 t;\n\tfloat a,b,c;\n\tfloat d;\n\tfloat s;\n\tt=ins-inc.xyz;\n\ta=dot(ind,ind);\n\tb=2.0*dot(ind,t);\n\tc=dot(t,t)-inc.w*inc.w;\n\td=b*b-4.0*a*c;\n\tif(d<0.0) {\n\t\tret.n=0;\n\t} else if(-EPS<d && d<EPS) {\n\t\tret.n=1;\n\t\tret.t[0]=-b/(2.0*a);\n\t} else {\n\t\ts=sqrt(d);\n\t\t// ot[0]<ot[1] because a>0\n\t\tret.n=2;\n\t\tret.t[0]=(-b-s)/(2.0*a);\n\t\tret.t[1]=(-b+s)/(2.0*a);\n\t}\n\treturn ret;\n}\n\nvec4 mixColor(vec3 x,vec3 y,float xRatio) {\n\treturn vec4(clamp(mix(y,x,xRatio),0.0,1.0),1.0);\n}\n\n/*\nx : right\ny : front\nz : up\n*/\n\n// Copyed and pasted in order to avoid recursion. It is not so good...\nvec4 getColorOfOnePoint2(vec3 sp,vec3 d) {\n\tbool doCalculateLight=false;\n\tvec3 colPoint;\n\tvec3 colN;\n\tvec4 col;\n\t// Collision check with sphere is omitted.\n\tif(sp.z*d.z<0.0) {\n\t\tfloat t=-sp.z/d.z;\n\t\tvec2 xy=sp.xy+t*d.xy;\n\t\tint p=0;\n\t\tif(xy.x<0.0) {\n\t\t\tif(mod(-xy.x,20.0)<10.0){p++;}\n\t\t} else {\n\t\t\tif(mod(xy.x,20.0)>=10.0){p++;}\n\t\t}\n\t\tif(xy.y<0.0) {\n\t\t\tif(mod(-xy.y,20.0)<10.0){p++;}\n\t\t} else {\n\t\t\tif(mod(xy.y,20.0)>=10.0){p++;}\n\t\t}\n\t\tif(p==1) {\n\t\t\tcol=floorColor2;\n\t\t} else {\n\t\t\tcol=floorColor1;\n\t\t}\n\t\tdoCalculateLight=true;\n\t\tcolPoint=sp+t*d;\n\t\tcolN=vec3(0,0,1);\n\t} else {\n\t\tcol=backGroundColor;\n\t}\n\tif(doCalculateLight) {\n\t\tvec3 toLight=lightPos.xyz-colPoint;\n\t\tvec3 hwv;\n\t\tfloat lightValue;\n\t\tLineSphereHitPointInfo sotp;\n\t\tsotp=getLineSphereHitPoint(colPoint,toLight,spherePos);\n\t\tif(sotp.n==2 && ((EPS<sotp.t[0] && sotp.t[0]+EPS<1.0) || (EPS<sotp.t[1] && sotp.t[1]+EPS<1.0))) {\n\t\t\tlightValue=0.0;\n\t\t} else {\n\t\t\thwv=normalize(-normalize(d)+toLight);\n\t\t\tlightValue=dot(hwv,colN);\n\t\t\tif(lightValue<EPS) {\n\t\t\t\tlightValue=0.0;\n\t\t\t} else {\n\t\t\t\tlightValue=clamp(pow(clamp(lightValue,0.0,1.0),1.2),0.0,1.0);\n\t\t\t}\n\t\t}\n\t\tcol=mixColor(lightColor.rgb*col.rgb*lightValue,col.rgb,lightColor.a);\n\t}\n\treturn col;\n}\n\nvec4 getColorOfOnePoint(vec3 sp,vec3 d) {\n\tbool doCalculateLight=false;\n\tvec3 colPoint;\n\tvec3 colN;\n\tvec4 col;\n\tLineSphereHitPointInfo hp;\n\thp=getLineSphereHitPoint(sp,d,spherePos);\n\tif(hp.n==2 && (hp.t[0]>EPS || hp.t[1]>EPS)) {\n\t\tvec3 np;\n\t\tvec3 n,nn;\n\t\tvec3 nd;\n\t\tvec4 nextColor;\n\t\tif(hp.t[0]>EPS) {\n\t\t\tnp=sp+hp.t[0]*d;\n\t\t} else {\n\t\t\tnp=sp+hp.t[1]*d;\n\t\t}\n\t\tn=np-spherePos.xyz;\n\t\tnn=normalize(n);\n\t\tnd=reflect(d,nn);\n\t\tnextColor=getColorOfOnePoint2(np,nd);\n\t\tcol=mixColor(sphereColor.rgb,nextColor.rgb,sphereColor.a);\n\t\tdoCalculateLight=true;\n\t\tcolPoint=np;\n\t\tcolN=nn;\n\t} else if(sp.z*d.z<0.0) {\n\t\tfloat t=-sp.z/d.z;\n\t\tvec2 xy=sp.xy+t*d.xy;\n\t\tint p=0;\n\t\tif(xy.x<0.0) {\n\t\t\tif(mod(-xy.x,20.0)<10.0){p++;}\n\t\t} else {\n\t\t\tif(mod(xy.x,20.0)>=10.0){p++;}\n\t\t}\n\t\tif(xy.y<0.0) {\n\t\t\tif(mod(-xy.y,20.0)<10.0){p++;}\n\t\t} else {\n\t\t\tif(mod(xy.y,20.0)>=10.0){p++;}\n\t\t}\n\t\tif(p==1) {\n\t\t\tcol=floorColor2;\n\t\t} else {\n\t\t\tcol=floorColor1;\n\t\t}\n\t\tdoCalculateLight=true;\n\t\tcolPoint=sp+t*d;\n\t\tcolN=vec3(0,0,1);\n\t} else {\n\t\tcol=backGroundColor;\n\t}\n\tif(doCalculateLight) {\n\t\tvec3 toLight=lightPos.xyz-colPoint;\n\t\tvec3 hwv;\n\t\tfloat lightValue;\n\t\tLineSphereHitPointInfo sotp;\n\t\tsotp=getLineSphereHitPoint(colPoint,toLight,spherePos);\n\t\tif(sotp.n==2 && ((EPS<sotp.t[0] && sotp.t[0]+EPS<1.0) || (EPS<sotp.t[1] && sotp.t[1]+EPS<1.0))) {\n\t\t\tlightValue=0.0;\n\t\t} else {\n\t\t\thwv=normalize(-normalize(d)+toLight);\n\t\t\tlightValue=dot(hwv,colN);\n\t\t\tif(lightValue<EPS) {\n\t\t\t\tlightValue=0.0;\n\t\t\t} else {\n\t\t\t\tlightValue=clamp(pow(clamp(lightValue,0.0,1.0),1.2),0.0,1.0);\n\t\t\t}\n\t\t}\n\t\tcol=mixColor(lightColor.rgb*col.rgb*lightValue,col.rgb,lightColor.a);\n\t}\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tconst float pi=3.141592653589793238462643383279502884197169399;\n\tspherePos.x=30.0*sin(iTime);\n\tspherePos.y=20.0*sin(iTime*1.3);\n\tspherePos.z=25.0+10.0*sin(iTime*1.9);\n\tfloat colorTime=mod(iTime/6.7,2.0*pi)*3.0/4.0;\n\tsphereColor.rgb=normalize(clamp(vec3(\n\t\tsin(colorTime),\n\t\tsin(colorTime-pi/2.0),\n\t\tmax(sin(colorTime-pi),sin(colorTime+pi/2.0))\n\t),0.0,1.0));\n\n\tvec2 offset=(fragCoord.xy/iResolution.xy)*2.0-1.0;\n\tif(iResolution.x>iResolution.y) {\n\t\toffset.y*=iResolution.y/iResolution.x;\n\t} else {\n\t\toffset.x*=iResolution.x/iResolution.y;\n\t}\n\tvec3 vec=cameraDir.xyz+cameraX.xyz*offset.x+cameraY.xyz*offset.y;\n\tfragColor=getColorOfOnePoint(cameraPos.xyz,vec);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsSSzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[777, 1013, 1087, 1087, 1475], [1477, 1477, 1520, 1520, 1572], [1608, 1679, 1721, 1721, 2882], [2884, 2884, 2925, 2925, 4508], [4510, 4510, 4567, 4567, 5228]], "test": "ok"}
{"id": "XsSXzR", "name": "Circuit Board", "author": "demofox", "description": "via wang tiling and a very lame shading multiplier that varies over distance.\nRelated blog post:  https://blog.demofox.org/2014/08/13/wang-tiling/", "tags": ["2d", "tiling", "wangtiling"], "likes": 13, "viewed": 735, "published": "Public", "date": "1408123373", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\nWritten by Alan Wolfe\nhttp://demofox.org/\nhttp://blog.demofox.org/\n\nWang tiling is a method for creating organic looking images with 2d tiles\n\nMore info on wang tiling:\nhttp://research.microsoft.com/en-us/um/people/cohen/WangFinal.pdf\nhttp://procworld.blogspot.ca/2013/01/introduction-to-wang-tiles.html\n*/\n\n// unscaled tile size\n#define TILE_SIZE 0.15\n\n// used when displaying the individual tiles\n#define TILE_PADDING 0.05\n\n// used when displaying the tile grid\n#define TILE_SCALE 1.5\n#define TILE_SCROLL vec2(0.25, 0.1)*5.0\n\nfloat SDFHorizLine( in vec2 coords, float offsetY )\n{\n    float v = offsetY-coords.y;\n    vec2  g = vec2(0.0,-1.0);\n    return abs(v)/length(g);\n}\n\nfloat SDFVertLine( in vec2 coords, float offsetX )\n{\n    float v = coords.x - offsetX;\n    vec2  g = vec2(1.0,0.0);\n    return abs(v)/length(g);\n}\n\nfloat SDFCircle( in vec2 coords, float offsetX, float offsetY, float radius )\n{\n    coords.x -= offsetX;\n    coords.y -= offsetY;\n    float v = coords.x * coords.x + coords.y * coords.y - radius;\n    vec2  g = vec2(2.0 * coords.x, 2.0 * coords.y);\n    return v/length(g); \n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 RenderTilePixelLevel1 (vec3 incolor, int leftType, int topType, int rightType, int bottomType, float percentX, float percentY)\n{\n    float col = 1.0;\n    \n    if ((leftType == 1 && percentX < 0.5) ||\n        (rightType == 1 && percentX > 0.5))\n    {\n        float newCol = smoothstep(0.0,0.05,SDFHorizLine(vec2(percentX,percentY), 0.5));\n    \tcol = min(col, newCol);\n    }\n    \n\n    if ((topType == 1 && percentY < 0.5) ||\n        (bottomType == 1 && percentY > 0.5))\n    {\n        float newCol = smoothstep(0.1,0.15,SDFVertLine(vec2(percentX,percentY),0.5));\n    \tcol = min(col, newCol);\n    }\n    \n    if (leftType != rightType || topType != bottomType)\n    {\n        float newCol = smoothstep(0.048,0.068,SDFCircle(vec2(percentX,percentY),0.5,0.5,0.001));\n    \tcol = min(col, newCol);    \n    }\n    \n    return mix(vec3(0.125,0.125,0.125),incolor,col);\n}\n\nvec3 RenderTilePixelLevel2 (vec3 incolor, int leftType, int topType, int rightType, int bottomType, float percentX, float percentY)\n{\n    float col = 1.0;\n    \n    if ((leftType == 0 && percentX < 0.75) ||\n        (rightType == 0 && percentX > 0.75))\n    {\n        float newCol = smoothstep(0.03,0.08,SDFHorizLine(vec2(percentX,percentY), 0.75));\n    \tcol = min(col, newCol);\n    }\n    \n\n    if ((topType == 1 && percentY < 0.75) ||\n        (bottomType == 1 && percentY > 0.75))\n    {\n        float newCol = smoothstep(0.0,0.05,SDFVertLine(vec2(percentX,percentY),0.75));\n    \tcol = min(col, newCol);\n    }\n    \n    if (leftType != rightType || topType != bottomType)\n    {\n        float newCol = smoothstep(0.01,0.03,SDFCircle(vec2(percentX,percentY),0.75,0.75,0.001));\n    \tcol = min(col, newCol);    \n    }\n    \n    return mix(vec3(0.125,0.125,0.5),incolor,col);\n}\n\nvec3 RenderTilePixelLevel3 (vec3 incolor, int leftType, int topType, int rightType, int bottomType, float percentX, float percentY)\n{\n    float col = 1.0;\n    \n    if ((leftType == 1 && percentX < 0.25) ||\n        (rightType == 1 && percentX > 0.25))\n    {\n        float newCol = smoothstep(0.02,0.07,SDFHorizLine(vec2(percentX,percentY), 0.25));\n    \tcol = min(col, newCol);\n    }\n    \n\n    if ((topType == 0 && percentY < 0.25) ||\n        (bottomType == 0 && percentY > 0.25))\n    {\n        float newCol = smoothstep(0.0,0.05,SDFVertLine(vec2(percentX,percentY),0.25));\n    \tcol = min(col, newCol);\n    }\n    \n    if (leftType != rightType || topType != bottomType)\n    {\n        float newCol = smoothstep(0.03,0.05,SDFCircle(vec2(percentX,percentY),0.25,0.25,0.001));\n    \tcol = min(col, newCol);    \n    }\n    \n    return mix(vec3(0.5,0.125,0.125),incolor,col);\n}\n\nvec3 RenderTilePixelLevel4 (vec3 incolor, int leftType, int topType, int rightType, int bottomType, float percentX, float percentY)\n{\n    float col = 1.0;\n    \n    if (leftType == 0 && leftType == rightType)\n    {\n        float newCol = smoothstep(0.05,0.1,SDFHorizLine(vec2(percentX,percentY), 0.5));\n    \tcol = min(col, newCol);        \n    }\n    \n    if (topType == 0 && topType == bottomType)\n    {\n        float newCol = smoothstep(0.05,0.1,SDFVertLine(vec2(percentX,percentY), 0.5));\n    \tcol = min(col, newCol);        \n    }    \n    \n    if (leftType == 0 && leftType == topType)\n    {\n        float newCol = smoothstep(0.05,0.1,abs(SDFCircle(vec2(percentX,percentY), 0.0, 0.0,0.25)));\n    \tcol = min(col, newCol);        \n    }\n    \n    if (leftType == 0 && leftType == bottomType)\n    {\n        float newCol = smoothstep(0.05,0.1,abs(SDFCircle(vec2(percentX,percentY), 0.0, 1.0,0.25)));\n    \tcol = min(col, newCol);        \n    }    \n    \n    if (rightType == 0 && rightType == topType)\n    {\n        float newCol = smoothstep(0.05,0.1,abs(SDFCircle(vec2(percentX,percentY), 1.0, 0.0,0.25)));\n    \tcol = min(col, newCol);        \n    }\n        \n    if (rightType == 0 && rightType == bottomType)\n    {\n        float newCol = smoothstep(0.05,0.1,abs(SDFCircle(vec2(percentX,percentY), 1.0, 1.0,0.25)));\n    \tcol = min(col, newCol);        \n    }    \n    \n    return mix(vec3(0.85,0.85,0.125),incolor,col);\n}\n\nvec3 RenderTilePixel (int leftType, int topType, int rightType, int bottomType, float percentX, float percentY, vec3 bgColor)\n{\n    vec3 color = bgColor;    \n    color = RenderTilePixelLevel4(color,leftType,topType,rightType,bottomType,percentX,percentY);        \n    color = RenderTilePixelLevel3(color,leftType,topType,rightType,bottomType,percentX,percentY);    \n    color = RenderTilePixelLevel2(color,leftType,topType,rightType,bottomType,percentX,percentY);    \n    color = RenderTilePixelLevel1(color,leftType,topType,rightType,bottomType,percentX,percentY);\n    return color;\n}\n\nvec3 RenderAllTiles (vec2 pixel)\n{\n    float tileX = floor(pixel.x / (TILE_SIZE + TILE_PADDING));\n    float tileY = floor(pixel.y / (TILE_SIZE + TILE_PADDING));\n        \n    if (tileX < 0.0 || tileY < 0.0 || tileX > 3.0 || tileY > 3.0)\n        return vec3(0,0,0);\n        \n    float tileOffsetX = pixel.x - tileX * (TILE_SIZE + TILE_PADDING) - TILE_PADDING;\n    float tileOffsetY = pixel.y - tileY * (TILE_SIZE + TILE_PADDING) - TILE_PADDING;\n    \n    if (tileOffsetX < 0.0 || tileOffsetY < 0.0)\n        return vec3(0,0,0);\n    \n    tileOffsetX /= TILE_SIZE;\n    tileOffsetY /= TILE_SIZE;\n    \n    float tile = tileY * 4.0 + tileX;   \n    int leftType = int(mod(tile / 8.0,2.0));\n    int topType = int(mod(tile / 4.0,2.0));\n    int rightType = int(mod(tile / 2.0,2.0));    \n    int bottomType = int(mod(tile,2.0));\n\n    return RenderTilePixel(leftType,topType,rightType,bottomType,tileOffsetX,tileOffsetY, vec3(0,1,0));\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\n\treturn texture( iChannel0, (uv+118.4)/256.0, -100.0 ).x;\n}\n\nint CoinFlip (vec2 sampleAt, vec2 seed)\n{\n    return noise(sampleAt / seed) > 0.5 ? 1 : 0;\n}\n\nvec3 RenderScreen(vec2 pixel)\n{   \n    float shading = (sin(pixel.x)+1.0) / 2.0 * 0.2 + 0.8;\n    shading *= (sin(pixel.x*2.0)+1.0) / 2.0 * 0.2 + 0.8;\n    vec3 bgColor = vec3(0,1,0);\n    \n    float tileX = floor(pixel.x / TILE_SIZE);\n    float tileY = floor(pixel.y / TILE_SIZE);\n  \n  \tfloat tileOffsetX = fract(pixel.x / TILE_SIZE);\n    float tileOffsetY = fract(pixel.y / TILE_SIZE);\n    \n    // calculate our tile edges, making sure to be coherent with our neighbors!\n    int leftType   = CoinFlip(vec2(tileX-1.0,tileY    ), vec2(0.12,0.37));\n    int rightType  = CoinFlip(vec2(tileX,    tileY    ), vec2(0.12,0.37));\n\tint topType    = CoinFlip(vec2(tileX,    tileY-1.0), vec2(0.41,0.73));\n    int bottomType = CoinFlip(vec2(tileX,    tileY    ), vec2(0.41,0.73));\n\n\t// render the tile pixel!\n    return RenderTilePixel(leftType,topType,rightType,bottomType,tileOffsetX,tileOffsetY, bgColor) * shading;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // calculate our pixel's location in X,Y percent of the resolution of the screen\n    // and apply the aspect ratio to get rid of distortion. Also make y = 0 be at the\n    // top of the screen and center the display\n\tvec2 pixel = fragCoord.xy / iResolution.xy;\n    pixel.y = 1.0 - pixel.y;\n    pixel.y = pixel.y - 0.5 + (TILE_SIZE + TILE_PADDING) * 2.0 + TILE_PADDING * 0.5;\n\n    float aspectRatio = iResolution.x / iResolution.y;\n    pixel.x -= 0.5;\n    pixel.x *= aspectRatio;\n    pixel.x += (TILE_SIZE + TILE_PADDING)*2.0 + TILE_PADDING * 0.5;\n    \n    vec3 color = vec3(0,0,0);\n\tif (iMouse.z > 0.0)\n    {\n    \tcolor = RenderAllTiles(pixel);\n    }\n    else\n    {\n    \tfloat scale = 0.5 + TILE_SCALE * (sin(iTime*0.33) * 0.5 + 0.5);\t\n  \t\tcolor = RenderScreen(pixel*scale + iTime * TILE_SCROLL);\n    }\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsSXzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[532, 532, 585, 585, 678], [680, 680, 732, 732, 826], [828, 828, 907, 907, 1102], [1104, 1104, 1145, 1145, 1238], [1240, 1240, 1373, 1373, 2102], [2104, 2104, 2237, 2237, 2971], [2973, 2973, 3106, 3106, 3840], [3842, 3842, 3975, 3975, 5258], [5260, 5260, 5387, 5387, 5845], [5847, 5847, 5881, 5881, 6768], [6770, 6770, 6796, 6796, 6946], [6948, 6948, 6989, 6989, 7040], [7042, 7042, 7073, 7073, 7948], [7954, 7954, 8011, 8230, 8857]], "test": "error"}
{"id": "XsXSWX", "name": "FMS_Cat background Alt", "author": "FMS_Cat", "description": "yay", "tags": ["2d"], "likes": 4, "viewed": 187, "published": "Public", "date": "1407129032", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv=(-iResolution.xy+2.0*fragCoord.xy)/iResolution.y;\n    float y=length(floor(uv*12.)),t=iTime*12.,H=.5;\n\tfragColor=vec4(H+H*sin(y-t),H+H*sin(y-t-1.),H+H*sin(y-t-2.),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsXSWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 235]], "test": "ok"}
{"id": "XsXXDX", "name": "Markers", "author": "rougier", "description": "Some antialiased markers (may be used for scatter plots)", "tags": ["visualization", "antialias", "subpixel", "shape", "marker"], "likes": 36, "viewed": 2030, "published": "Public", "date": "1407174261", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Subpixels antialiased markers\n// Nicolas P. Rougier (http://www.loria.fr/~rougier)\n// Released under BSD license.\n\nconst float M_PI = 3.14159265358979323846;\nconst float SQRT_2 = 1.4142135623730951;\n\n\nvec4 stroke(float distance, float linewidth, float antialias, vec4 stroke)\n{\n    vec4 frag_color;\n    float t = linewidth/2.0 - antialias;\n    float signed_distance = distance;\n    float border_distance = abs(signed_distance) - t;\n    float alpha = border_distance/antialias;\n    alpha = exp(-alpha*alpha);\n\n    if( border_distance > (linewidth/2.0 + antialias) )\n        discard;\n    else if( border_distance < 0.0 )\n        frag_color = stroke;\n    else\n        frag_color = vec4(stroke.rgb*alpha, 1.);\n\n    return frag_color;\n}\n\nvec4 filled(float distance, float linewidth, float antialias, vec4 fill)\n{\n    vec4 frag_color;\n    float t = linewidth/2.0 - antialias;\n    float signed_distance = distance;\n    float border_distance = abs(signed_distance) - t;\n    float alpha = border_distance/antialias;\n    alpha = exp(-alpha*alpha);\n\n    // Within linestroke\n    if( border_distance < 0.0 )\n        frag_color = fill;\n    // Within shape\n    else if( signed_distance < 0.0 )\n        frag_color = fill;\n    else\n        // Outside shape\n        if( border_distance > (linewidth/2.0 + antialias) )\n            discard;\n        else // Line stroke exterior border\n            frag_color = vec4(fill.rgb*alpha, 1.0);\n\n    return frag_color;\n}\n\nvec4 outline(float distance, float linewidth, float antialias, vec4 stroke, vec4 fill)\n{\n    vec4 frag_color;\n    float t = linewidth/2.0 - antialias;\n    float signed_distance = distance;\n    float border_distance = abs(signed_distance) - t;\n    float alpha = border_distance/antialias;\n    alpha = exp(-alpha*alpha);\n\n    // Within linestroke\n    if( border_distance < 0.0 )\n        frag_color = stroke;\n    else if( signed_distance < 0.0 )\n        // Inside shape\n        if( border_distance > (linewidth/2.0 + antialias) )\n            frag_color = fill;\n        else // Line stroke interior border\n            frag_color = mix(fill, stroke, alpha);\n    else\n        // Outide shape\n        if( border_distance > (linewidth/2.0 + antialias) )\n            discard;\n        else // Line stroke exterior border\n            frag_color = vec4(stroke.rgb*alpha, 1.0);\n\n    return frag_color;\n}\n\n\nfloat marker_T(vec2 P, float size)\n{\n   float x = -P.y;\n   float y = P.x;\n\n   float r1 = max(abs(x -size/3. + size/3.), abs(x - size/3. - size/3.));\n   float r2 = max(abs(y - size/3.), abs(y + size/3.));\n   float r3 = max(abs(x), abs(y));\n   float r = max(min(r1,r2),r3);\n   r -= size/2.;\n   return r;\n}\n\nfloat marker_check(vec2 P, float size)\n{\n    float x = SQRT_2/2. * (P.x - P.y);\n    float y = SQRT_2/2. * (P.x + P.y);\n\n    float r1 = max(abs(x - 2.*size/3.), abs(x - 1.*size/3.));\n    float r2 = max(abs(y - 2.*size/3.), abs(y - size/3.));\n    float r3 = max(abs(x),max(abs(x-size/3.), abs(y)));\n    float r = max(min(r1,r2),r3);\n    r -= size/2.;\n    return r;\n}\n\nfloat marker_cross(vec2 P, float size)\n{\n   float x = SQRT_2/2. * (P.x - P.y);\n   float y = SQRT_2/2. * (P.x + P.y);\n\n    float r1 = max(abs(x - size/3.), abs(x + size/3.));\n    float r2 = max(abs(y - size/3.), abs(y + size/3.));\n    float r3 = max(abs(x), abs(y));\n    float r = max(min(r1,r2),r3);\n    r -= size/2.;\n    return r;\n}\n\n\nfloat marker_clobber(vec2 P, float size)\n{\n    const float t1 = -M_PI/2.;\n    vec2  c1 = 0.25*vec2(cos(t1),sin(t1));\n\n    const float t2 = t1+2.*M_PI/3.;\n    vec2  c2 = 0.25*vec2(cos(t2),sin(t2));\n\n    const float t3 = t2+2.*M_PI/3.;\n    vec2  c3 = 0.25*vec2(cos(t3),sin(t3));\n\n    float r1 = length( P - c1*size) - size/3.5;\n    float r2 = length( P - c2*size) - size/3.5;\n    float r3 = length( P - c3*size) - size/3.5;\n    return min(min(r1,r2),r3);\n}\n\n\nfloat marker_asterisk(vec2 P, float size)\n{\n   float x = SQRT_2/2. * (P.x - P.y);\n   float y = SQRT_2/2. * (P.x + P.y);\n\n   float r1 = max(abs(x)- size/2., abs(y)- size/10.);\n   float r2 = max(abs(y)- size/2., abs(x)- size/10.);\n   float r3 = max(abs(P.x)- size/2., abs(P.y)- size/10.);\n   float r4 = max(abs(P.y)- size/2., abs(P.x)- size/10.);\n   return min( min(r1,r2), min(r3,r4));\n}\n\n\nfloat marker_chevron(vec2 P, float size)\n{\n    float x = 1./SQRT_2 * (P.x - P.y);\n    float y = 1./SQRT_2 * (P.x + P.y);\n    float r1 = max(abs(x),        abs(y))        - size/3.;\n    float r2 = max(abs(x-size/3.), abs(y-size/3.)) - size/3.;\n    return max(r1,-r2);\n}\n\nfloat marker_ring(vec2 P, float size)\n{\n    float r1 = length(P) - size/2.;\n    float r2 = length(P) - size/4.;\n    return max(r1,-r2);\n}\n\nfloat marker_infinity(vec2 P, float size)\n{\n    const vec2 c1 = vec2(+0.25, 0.00);\n    const vec2 c2 = vec2(-0.25, 0.00);\n    float r1 = length(P-c1*size) - size/3.;\n    float r2 = length(P-c1*size) - size/7.;\n    float r3 = length(P-c2*size) - size/3.;\n    float r4 = length(P-c2*size) - size/7.;\n    return min( max(r1,-r2), max(r3,-r4));\n}\n\nfloat marker_tag(vec2 P, float size)\n{\n    float x = -P.x;\n    float y = P.y;\n    float r1 = max(abs(x)- size/2., abs(y)- size/6.);\n    float r2 = abs(x-size/1.5)+abs(y)-size;\n    return max(r1,.75*r2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float linewidth = 1.5;\n    const float antialias = 1.0;\n\n    const float rows = 4.0;\n    const float cols = 9.0;\n    float body = min(iResolution.x/cols, iResolution.y/rows) / SQRT_2;\n    vec2 texcoord = vec2(fragCoord.x, iResolution.y-fragCoord.y);\n    vec2 size   = iResolution.xy / vec2(cols,rows);\n    vec2 center = (floor(texcoord/size) + vec2(0.5,0.5)) * size;\n    texcoord -= center;\n\n    float theta = (iTime/2.0);\n\n    float cos_theta = cos(theta);\n    float sin_theta = sin(theta);\n    texcoord = vec2(cos_theta*texcoord.x - sin_theta*texcoord.y,\n                    sin_theta*texcoord.x + cos_theta*texcoord.y);\n\n    float d;\n\n    float s = size.x/SQRT_2;\n    \n    if (fragCoord.x < 1.*size.x)\n        d = marker_T(texcoord, s);\n\n    else if (fragCoord.x < 2.*size.x)\n        d = marker_check(texcoord, s);\n\n    else if (fragCoord.x < 3.*size.x)\n        d = marker_cross(texcoord, s);\n        \n    else if (fragCoord.x < 4.*size.x)\n        d = marker_clobber(texcoord, s);\n\n    else if (fragCoord.x < 5.*size.x)\n        d = marker_asterisk(texcoord, s);\n\n    else if (fragCoord.x < 6.*size.x)\n        d = marker_chevron(texcoord, s);\n\n    else if (fragCoord.x < 7.*size.x)\n        d = marker_ring(texcoord, s);\n\n    else if (fragCoord.x < 8.*size.x)\n        d = marker_infinity(texcoord, s);\n\n    else if (fragCoord.x < 9.*size.x)\n        d = marker_tag(texcoord, s);\n\n\n    if (fragCoord.y < 1.*size.y)\n        fragColor = stroke(d, linewidth, antialias, vec4(1,1,1,1));\n    else if (fragCoord.y < 2.*size.y)\n        fragColor = outline(d, linewidth, antialias, vec4(1,1,1,1), vec4(.25,.25,.25,1) );\n    else if (fragCoord.y < 3.*size.y)\n        fragColor = outline(d, linewidth, antialias, vec4(1,1,1,1), vec4(.75,.75,.75,1) );\n    else\n        fragColor = filled(d, linewidth, antialias, vec4(1,1,1,1));\n\n        }\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsXXDX.jpg", "access": "shaders20k", "license": "bsd-new", "functions": [[204, 204, 280, 280, 734], [736, 736, 810, 810, 1446], [1448, 1448, 1536, 1536, 2338], [2341, 2341, 2377, 2377, 2644], [2646, 2646, 2686, 2686, 3010], [3012, 3012, 3052, 3052, 3345], [3348, 3348, 3390, 3390, 3802], [3805, 3805, 3848, 3848, 4191], [4194, 4194, 4236, 4236, 4462], [4464, 4464, 4503, 4503, 4601], [4603, 4603, 4646, 4646, 4945], [4947, 4947, 4985, 4985, 5151], [5153, 5153, 5210, 5210, 7048]], "test": "ok"}
