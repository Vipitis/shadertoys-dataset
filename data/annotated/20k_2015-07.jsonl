{"id": "4lfSD4", "name": "De-Burn-In", "author": "RavenWorks", "description": "Use at your own risk :P I just had a burnt-in screen so I figured I'd try it... (I know it's not perfect noise, I can see the 'seams' too, but it should be good enough for these purposes!)", "tags": ["noise"], "likes": 3, "viewed": 1215, "published": "Public API", "date": "1436664906", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = 3.14159;\n\nfloat random(vec2 inPt, float offset){\n    const float a = 98765.432;\n    const float b = 12345.678;\n    const float c = 45678.912;\n    const float d = 78945.612;\n    \n    vec2 p = inPt;\n    p -= 5000.0;\n    p += iTime*0.1;\n    p += offset;\n    p.x += sin(inPt.y);\n    p.y += sin(inPt.x);\n    \n    \n    \n    float sinvalX = sin(p.x*a*sin(p.x*b));\n    float sinvalY = sin(p.y*c*sin(p.y*d));\n    \n    float sinval = (sinvalX+sinvalY)*0.5;\n    \n    return sinval;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float channelGap = 500.0;\n    vec3 randChans = vec3(random(fragCoord,0.0),random(fragCoord,1.0*channelGap),random(fragCoord,2.0*channelGap));\n    float winner = max(max(randChans.r,randChans.g),randChans.b);\n    if (winner == randChans.r) {\n        fragColor = vec4(1.0,0.0,0.0,1.0);\n    } else if (winner == randChans.g) {\n        fragColor = vec4(0.0,1.0,0.0,1.0);\n    } else {\n        fragColor = vec4(0.0,0.0,1.0,1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lfSD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 65, 65, 489], [491, 491, 548, 548, 989]], "test": "valid"}
{"id": "4lfSD7", "name": "The Red Planet", "author": "adam27", "description": "My vision of Mars.", "tags": ["3d", "terrain", "planet", "mars", "warsztat"], "likes": 9, "viewed": 2054, "published": "Public API", "date": "1436984048", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst mat2 mat = mat2(1.8, 1.1, -1.1, 1.8);\n\nfloat rand(vec2 v)\n{\n\tfloat x = fract(sin(dot(v, vec2(1872.8497, -2574.9248))) * 72123.19);\n\treturn x;\n}\n\nfloat noise(in vec2 p) \n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix(mix(rand(i + vec2(0.0,0.0)), rand(i + vec2(1.0,0.0)), u.x),\n\t\t\t\t\t\tmix(rand(i + vec2(0.0,1.0)), rand(i + vec2(1.0,1.0)), u.x), u.y);\n}\n\nfloat map(vec2 xz)\n{\n\txz += noise(xz);\n\tvec2 a = 1.0 - abs(sin(xz));\n\tvec2 b = abs(cos(xz));\n\treturn pow(dot(a, b) * length(cos(xz)), 0.5) + pow(sin(xz.x), 1.0) + pow(cos(xz.y), 1.0);\n}\n\nfloat terrain(vec3 p)\n{\n\tvec2 xz = p.xz / 5.0;\n\txz.x *= 0.7;\n\tfloat amp = 1.5;\n\tfloat h = 0.0;\n\tfloat freq = 0.1;\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tfloat h1 = map(xz * freq);\n\t\tfloat h2 = map(xz * freq);\n\t\th += (h1 + h2) * amp;\n\t\tfreq *= 2.1;\n\t\tamp *= 0.21;\n\t\txz *= mat;\n\t}\n\treturn p.y - h;\n}\n\n\nfloat castRay(inout vec3 p, vec3 dir)\n{\t\n\tfloat t = 0.1;    \n\tfloat d = 0.1;\n\tfor (int i = 0; i < 200; i++)\n\t{\n\t\tfloat h = terrain(p + dir*t);\n\t\tif (h < 0.0)\n\t\t\tbreak;\n\t\t\n\t\td *= 1.05;\n        t += d;\n        if (i == 199)\n            return 20000.0;\n\t}\n    \n\tfloat t2 = t;\n\tfloat h2 = terrain(p + dir*t2);\n\tif (h2 > 0.0)\n\t\treturn t2;\n\tfloat t1 = t - d*10.0;\n\tfloat h1 = terrain(p + dir*t1);\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tt = mix(t1, t2, h1/(h1-h2));\n\t\tfloat h = terrain(p + dir*t);\n\t\tif (h < 0.0)\n\t\t{\n            t2 = t; \n            h2 = h;\n        }\n\t\telse\n\t\t{\n            t1 = t; \n            h1 = h;\n        }\n\t}\t\n\tp = p + dir*t;\n\treturn t;\n}\n\nvec3 getNormal(vec3 p, float d)\n{\n    vec3 n;\n    n.y = terrain(p);    \n    n.x = terrain(p + vec3(d, 0.0, 0.0)) - n.y;\n    n.z = terrain(p + vec3(0.0, 0.0, d)) - n.y;\n    n.y = d;\n    return normalize(n);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 angle = vec2(iTime / 4.0, radians(5.0));\n    vec3 center = vec3(-iTime * 10.0, 0.0, -iTime * 10.0);\n    float zoom = 1.0;\n    \n    vec3 p = vec3(cos(angle.x)*cos(angle.y), sin(angle.y), sin(angle.x)*cos(angle.y));\n\tvec2 uv = (fragCoord.xy/* + vec2(int(iTime*30.0))*/) / iResolution.yy - vec2(iResolution.x / iResolution.y / 2.0, 0.5);\n    \n    vec3 tx = vec3(-sin(angle.x), 0.0, cos(angle.x));\n    vec3 ty = vec3(-cos(angle.x)*sin(angle.y), cos(angle.y), -sin(angle.x)*sin(angle.y));\n    \n    vec3 p2 = p * 1.5;\n    p = p * zoom + center;\n    p.y -= terrain(vec3(p.x, 0.0, p.z)) - 3.0;\n    \n    vec3 dir = tx * uv.x + ty * uv.y - p2;\n    \n    vec3 color = vec3(0.0);\n    vec3 light = normalize(vec3(0.6, 0.8, 0.3));\n    \n    \n\tfloat dist = castRay(p, dir);\n\t\n    if (dist > 10000.0)\n        color = vec3(0.8, 0.4, 0.2) * 1.0 - dot(vec3(0.0, 1.0, 0.0), dir);\n    else    \n   \t\tcolor = vec3(0.8, 0.45, 0.2) * pow(max(dot(getNormal(p, dist*0.001), light), 0.0), 2.0) + noise(p.xz * 4.0) / 25.0;\n\t\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lfSD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 66, 66, 150], [152, 152, 177, 177, 409], [411, 411, 431, 431, 596], [598, 598, 621, 621, 890], [893, 893, 932, 932, 1543], [1545, 1545, 1578, 1578, 1752], [1755, 1755, 1810, 1810, 2854]], "test": "valid"}
{"id": "4lfSzS", "name": "Awesome star", "author": "foxes", "description": "i found in game.interstellarmovie.com planet generator and simulated generation of stars with the noise.\nyou can rotate with mouse \n[url=https://www.youtube.com/watch?v=Z_uN24AQaV4]  Interstellar gameplay[/url]", "tags": ["procedural", "3d", "noise", "ray", "sun", "star"], "likes": 174, "viewed": 15635, "published": "Public API", "date": "1437405566", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Panteleymonov A K 2015\n\n//\n// procedural noise from https://www.shadertoy.com/view/4sfGzS\n// for first variant\n/*float hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}*/\n\n// animated noise\nvec4 NC0=vec4(0.0,157.0,113.0,270.0);\nvec4 NC1=vec4(1.0,158.0,114.0,271.0);\n//vec4 WS=vec4(10.25,32.25,15.25,3.25);\nvec4 WS=vec4(0.25,0.25,0.25,0.25);\n\n//\n//vec4 hash4(vec4 x){ return fract(fract(x*0.31830988618379067153776752674503)*fract(x*0.15915494309189533576888376337251)*265871.1723); }\n//vec4 hash4( vec4 n ) { return fract(sin(n)*753.5453123); }\n//float noise3( vec3 x )\n//{\n//    vec3 p = floor(x);\n//    vec3 f = fract(x);\n//    f = f*f*(3.0-2.0*f);\n//    float n = p.x + dot(p.yz,vec2(157.0,113.0));\n//    vec4 s1=mix(hash4(vec4(n)+NC0),hash4(vec4(n)+NC1),vec4(f.x));\n//    return mix(mix(s1.x,s1.y,f.y),mix(s1.z,s1.w,f.y),f.z);\n//}\n\n// just a noise\n//float noise4( vec4 x )\n//{\n//    vec4 p = floor(x);\n//    vec4 f = fract(x);\n//    p.w=mod(p.w,100.0); // looping noise in one axis\n//    f = f*f*(3.0-2.0*f);\n//    float n = p.x + dot(p.yzw,vec3(157.0,113.0,642.0));\n//    vec4 vs1=mix(hash4(vec4(n)+NC0),hash4(vec4(n)+NC1),vec4(f.x));\n//    n = n-642.0*p.w + 642.0*mod(p.w+1.0,100.0);\n//    vec4 vs2=mix(hash4(vec4(n)+NC0),hash4(vec4(n)+NC1),vec4(f.x));\n//    vs1=mix(vec4(vs1.xz,vs2.xz),vec4(vs1.yw,vs2.yw),vec4(f.y));\n//    vs1.xy=mix(vs1.xz,vs1.yw,vec2(f.z));\n//    return mix(vs1.x,vs1.y,f.w);\n//}\n\n// mix noise for alive animation\n//float noise4r( vec4 x )\n//{\n//    return (noise4(x)+noise4(x+=WS)+noise4(x+=WS)+noise4(x+=WS))*0.25;\n//    //return noise4(x);\n//}\n\n// mix noise for alive animation, full source\nvec4 hash4( vec4 n ) { return fract(sin(n)*1399763.5453123); }\nvec3 hash3( vec3 n ) { return fract(sin(n)*1399763.5453123); }\nvec3 hpos( vec3 n ) { return hash3(vec3(dot(n,vec3(157.0,113.0,271.0)),dot(n,vec3(271.0,157.0,113.0)),dot(n,vec3(113.0,271.0,157.0)))); }\n//vec4 hash4( vec4 n ) { return fract(n*fract(n*0.5453123)); }\n//vec4 hash4( vec4 n ) { n*=1.987654321; return fract(n*fract(n)); }\nfloat noise4q(vec4 x)\n{\n\tvec4 n3 = vec4(0,0.25,0.5,0.75);\n\tvec4 p2 = floor(x.wwww+n3);\n\tvec4 b = floor(x.xxxx+n3) + floor(x.yyyy+n3)*157.0 + floor(x.zzzz +n3)*113.0;\n\tvec4 p1 = b + fract(p2*0.00390625)*vec4(164352.0, -164352.0, 163840.0, -163840.0);\n\tp2 = b + fract((p2+1.0)*0.00390625)*vec4(164352.0, -164352.0, 163840.0, -163840.0);\n\tvec4 f1 = fract(x.xxxx+n3);\n\tvec4 f2 = fract(x.yyyy+n3);\n\tf1=f1*f1*(3.0-2.0*f1);\n\tf2=f2*f2*(3.0-2.0*f2);\n\tvec4 n1 = vec4(0,1.0,157.0,158.0);\n\tvec4 n2 = vec4(113.0,114.0,270.0,271.0);\t\n\tvec4 vs1 = mix(hash4(p1), hash4(n1.yyyy+p1), f1);\n\tvec4 vs2 = mix(hash4(n1.zzzz+p1), hash4(n1.wwww+p1), f1);\n\tvec4 vs3 = mix(hash4(p2), hash4(n1.yyyy+p2), f1);\n\tvec4 vs4 = mix(hash4(n1.zzzz+p2), hash4(n1.wwww+p2), f1);\t\n\tvs1 = mix(vs1, vs2, f2);\n\tvs3 = mix(vs3, vs4, f2);\n\tvs2 = mix(hash4(n2.xxxx+p1), hash4(n2.yyyy+p1), f1);\n\tvs4 = mix(hash4(n2.zzzz+p1), hash4(n2.wwww+p1), f1);\n\tvs2 = mix(vs2, vs4, f2);\n\tvs4 = mix(hash4(n2.xxxx+p2), hash4(n2.yyyy+p2), f1);\n\tvec4 vs5 = mix(hash4(n2.zzzz+p2), hash4(n2.wwww+p2), f1);\n\tvs4 = mix(vs4, vs5, f2);\n\tf1 = fract(x.zzzz+n3);\n\tf2 = fract(x.wwww+n3);\n\tf1=f1*f1*(3.0-2.0*f1);\n\tf2=f2*f2*(3.0-2.0*f2);\n\tvs1 = mix(vs1, vs2, f1);\n\tvs3 = mix(vs3, vs4, f1);\n\tvs1 = mix(vs1, vs3, f2);\n\tfloat r=dot(vs1,vec4(0.25));\n\t//r=r*r*(3.0-2.0*r);\n\treturn r*r*(3.0-2.0*r);\n}\n\n// body of a star\nfloat noiseSpere(vec3 ray,vec3 pos,float r,mat3 mr,float zoom,vec3 subnoise,float anim)\n{\n  \tfloat b = dot(ray,pos);\n  \tfloat c = dot(pos,pos) - b*b;\n    \n    vec3 r1=vec3(0.0);\n    \n    float s=0.0;\n    float d=0.03125;\n    float d2=zoom/(d*d); \n    float ar=5.0;\n   \n    for (int i=0;i<3;i++) {\n\t\tfloat rq=r*r;\n        if(c <rq)\n        {\n            float l1=sqrt(rq-c);\n            r1= ray*(b-l1)-pos;\n            r1=r1*mr;\n            s+=abs(noise4q(vec4(r1*d2+subnoise*ar,anim*ar))*d);\n        }\n        ar-=2.0;\n        d*=4.0;\n        d2*=0.0625;\n        r=r-r*0.02;\n    }\n    return s;\n}\n\n// glow ring\nfloat ring(vec3 ray,vec3 pos,float r,float size)\n{\n  \tfloat b = dot(ray,pos);\n  \tfloat c = dot(pos,pos) - b*b;\n   \n    float s=max(0.0,(1.0-size*abs(r-sqrt(c))));\n    \n    return s;\n}\n\n// rays of a star\nfloat ringRayNoise(vec3 ray,vec3 pos,float r,float size,mat3 mr,float anim)\n{\n  \tfloat b = dot(ray,pos);\n    vec3 pr=ray*b-pos;\n       \n    float c=length(pr);\n\n    pr*=mr;\n    \n    pr=normalize(pr);\n    \n    float s=max(0.0,(1.0-size*abs(r-c)));\n    \n    float nd=noise4q(vec4(pr*1.0,-anim+c))*2.0;\n    nd=pow(nd,2.0);\n    float n=0.4;\n    float ns=1.0;\n    if (c>r) {\n        n=noise4q(vec4(pr*10.0,-anim+c));\n        ns=noise4q(vec4(pr*50.0,-anim*2.5+c*2.0))*2.0;\n    }\n    n=n*n*nd*ns;\n    \n    return pow(s,4.0)+s*s*n;\n}\n\nvec4 noiseSpace(vec3 ray,vec3 pos,float r,mat3 mr,float zoom,vec3 subnoise,float anim)\n{\n  \tfloat b = dot(ray,pos);\n  \tfloat c = dot(pos,pos) - b*b;\n    \n    vec3 r1=vec3(0.0);\n    \n    float s=0.0;\n    float d=0.0625*1.5;\n    float d2=zoom/d;\n\n\tfloat rq=r*r;\n    float l1=sqrt(abs(rq-c));\n    r1= (ray*(b-l1)-pos)*mr;\n\n    r1*=d2;\n    s+=abs(noise4q(vec4(r1+subnoise,anim))*d);\n    s+=abs(noise4q(vec4(r1*0.5+subnoise,anim))*d*2.0);\n    s+=abs(noise4q(vec4(r1*0.25+subnoise,anim))*d*4.0);\n    //return s;\n    return vec4(s*2.0,abs(noise4q(vec4(r1*0.1+subnoise,anim))),abs(noise4q(vec4(r1*0.1+subnoise*6.0,anim))),abs(noise4q(vec4(r1*0.1+subnoise*13.0,anim))));\n}\n\nfloat sphereZero(vec3 ray,vec3 pos,float r)\n{\n  \tfloat b = dot(ray,pos);\n  \tfloat c = dot(pos,pos) - b*b;\n    float s=1.0;\n    if (c<r*r) s=0.0;\n    return s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n\n    float time=iTime*1.0;\n    \n\tfloat mx = iMouse.z>0.0?iMouse.x/iResolution.x*10.0:time*0.025;\n    float my = iMouse.z>0.0?iMouse.y/iResolution.y*4.0-2.0:-0.6;\n    vec2 rotate = vec2(mx,my);\n\n    vec2 sins=sin(rotate);\n    vec2 coss=cos(rotate);\n    mat3 mr=mat3(vec3(coss.x,0.0,sins.x),vec3(0.0,1.0,0.0),vec3(-sins.x,0.0,coss.x));\n    mr=mat3(vec3(1.0,0.0,0.0),vec3(0.0,coss.y,sins.y),vec3(0.0,-sins.y,coss.y))*mr;    \n\n    mat3 imr=mat3(vec3(coss.x,0.0,-sins.x),vec3(0.0,1.0,0.0),vec3(sins.x,0.0,coss.x));\n    imr=imr*mat3(vec3(1.0,0.0,0.0),vec3(0.0,coss.y,-sins.y),vec3(0.0,sins.y,coss.y));\n\t\n    vec3 ray = normalize(vec3(p,2.0));\n    vec3 pos = vec3(0.0,0.0,3.0);\n    \n    float s1=noiseSpere(ray,pos,1.0,mr,0.5,vec3(0.0),time);\n    s1=pow(min(1.0,s1*2.4),2.0);\n    float s2=noiseSpere(ray,pos,1.0,mr,4.0,vec3(83.23,34.34,67.453),time);\n    s2=min(1.0,s2*2.2);\n    fragColor = vec4( mix(vec3(1.0,1.0,0.0),vec3(1.0),pow(s1,60.0))*s1, 1.0 );\n    fragColor += vec4( mix(mix(vec3(1.0,0.0,0.0),vec3(1.0,0.0,1.0),pow(s2,2.0)),vec3(1.0),pow(s2,10.0))*s2, 1.0 );\n\t\n    fragColor.xyz -= vec3(ring(ray,pos,1.03,11.0))*2.0;\n    fragColor = max( vec4(0.0), fragColor );\n    \n    float s3=ringRayNoise(ray,pos,0.96,1.0,mr,time);\n    fragColor.xyz += mix(vec3(1.0,0.6,0.1),vec3(1.0,0.95,1.0),pow(s3,3.0))*s3;\n\n    float zero=sphereZero(ray,pos,0.9);\n    if (zero>0.0) {\n    \t//float s4=noiseSpace(ray,pos,100.0,mr,0.5,vec3(0.0),time*0.01);\n\t    vec4 s4=noiseSpace(ray,pos,100.0,mr,0.05,vec3(1.0,2.0,4.0),0.0);\n    \t//float s5=noiseSpace(ray,pos,100.0,vec3(mx,my,0.5),vec3(83.23,34.34,67.453),time*0.01);\n    \t//s4=pow(s4*2.0,6.0);\n    \t//s4=pow(s4*1.8,5.7);\n    \ts4.x=pow(s4.x,3.0);\n    \t//s5=pow(s5*2.0,6.0);\n    \t//fragColor.xyz += (vec3(0.0,0.0,1.0)*s4*0.6+vec3(0.9,0.0,1.0)*s5*0.3)*sphereZero(ray,pos,0.9);\n    \tfragColor.xyz += mix(mix(vec3(1.0,0.0,0.0),vec3(0.0,0.0,1.0),s4.y*1.9),vec3(0.9,1.0,0.1),s4.w*0.75)*s4.x*pow(s4.z*2.5,3.0)*0.2*zero;\n    \t//fragColor.xyz += (mix(mix(vec3(1.0,0.0,0.0),vec3(0.0,0.0,1.0),s4*3.0),vec3(1.0),pow(s4*2.0,4.0))*s4*0.6)*sphereZero(ray,pos,0.9);\n        \n        \n\t\t/*float b = dot(ray,pos);\n  \t\tfloat c = dot(pos,pos) - b*b;\n    \tfloat l1 = sqrt(abs(10.0-c));\n    \tvec3 spos = (ray*(b-l1))*mr;\n        vec3 sposr=ceil(spos)+spos/abs(spos)*0.5;\n        //sposr+=hpos(sposr)*0.2;\n        \n        float ss3=max(0.0,ringRayNoise(ray,(sposr)*imr,0.001,10.0,mr,time));\n        fragColor.xyz += vec3(ss3);*/\n    }\n    \n    //fragColor = max( vec4(0.0), fragColor );\n    //s+=noiseSpere(ray,vec3(0.0,0.0,3.0),0.96,vec2(mx+1.4,my),vec3(83.23,34.34,67.453));\n    //s+=noiseSpere(ray,vec3(0.0,0.0,3.0),0.90,vec2(mx,my),vec3(123.223311,956.34,7.45333))*0.6;\n    \n    fragColor = max( vec4(0.0), fragColor );\n\tfragColor = min( vec4(1.0), fragColor );\n}\n\n//\n// SunShader 1.0 for Unity3D 4-5\n//\n// Panteleymonov Aleksandr 2016\n//\n// foxes@bk.ru\n// mail@panteleymonov.ru\n//\n/*\nShader \"Space/Star/Sun\"\n{\n\tProperties\n\t{\n\t\t_Radius(\"Radius\", Float) = 0.5\n\t\t_Light(\"Light\",Color) = (1,1,1,1)\n\t\t_Color(\"Color\", Color) = (1,1,0,1)\n\t\t_Base(\"Base\", Color) = (1,0,0,1)\n\t\t_Dark(\"Dark\", Color) = (1,0,1,1)\n\t\t_RayString(\"Ray String\", Range(0.02,10.0)) = 1.0\n\t\t_RayLight(\"Ray Light\", Color) = (1,0.95,1.0,1)\n\t\t_Ray(\"Ray End\", Color) = (1,0.6,0.1,1)\n\t\t_Detail(\"Detail Body\", Range(0,5)) = 3\n\t\t_Rays(\"Rays\", Range(1.0,10.0)) = 2.0\n\t\t_RayRing(\"Ray Ring\", Range(1.0,10.0)) = 1.0\n\t\t_RayGlow(\"Ray Glow\", Range(1.0,10.0)) = 2.0\n\t\t_Glow(\"Glow\", Range(1.0,100.0)) = 4.0\n\t\t_Zoom(\"Zoom\", Float) = 1.0\n\t\t_SpeedHi(\"Speed Hi\", Range(0.0,10)) = 2.0\n\t\t_SpeedLow(\"Speed Low\", Range(0.0,10)) = 2.0\n\t\t_SpeedRay(\"Speed Ray\", Range(0.0,10)) = 5.0\n\t\t_SpeedRing(\"Speed Ring\", Range(0.0,20)) = 2.0\n\t\t_Seed(\"Seed\", Range(-10,10)) = 0\n\t}\n\t\tSubShader\n\t{\n\t\tTags{ \"Queue\" = \"Transparent\" \"IgnoreProjector\" = \"True\" \"RenderType\" = \"Transparent\" }\n\t\tLOD 100\n\n\t\tPass\n\t\t{\n\t\t\tBlend One OneMinusSrcAlpha\n\t\t\tCGPROGRAM\n\t\t\t#pragma vertex vert\n\t\t\t#pragma fragment frag\n\t\t\t#pragma target 4.0\n\t\t\t\n\t\t\t#include \"UnityCG.cginc\"\n\n\t\t\tstruct appdata\n\t\t\t{\n\t\t\t\tfloat4 vertex : POSITION;\n\t\t\t\tfloat2 uv : TEXCOORD0;\n\t\t\t};\n\n\t\t\tstruct v2f\n\t\t\t{\n\t\t\t#if UNITY_5_0\n\t\t\t\tUNITY_FOG_COORDS(1)\n\t\t\t#endif\n\t\t\t\tfloat4 vertex : SV_POSITION;\n\t\t\t};\n\n\t\t\tsampler2D _MainTex;\n\t\t\tfloat _Radius;\n\t\t\tfloat _RayString;\n\t\t\tfixed4 _Light;\n\t\t\tfixed4 _Color;\n\t\t\tfixed4 _Base;\n\t\t\tfixed4 _Dark;\n\t\t\tfixed4 _Ray;\n\t\t\tfixed4 _RayLight;\n\t\t\tint _Detail;\n\t\t\tfloat _Rays;\n\t\t\tfloat _RayRing;\n\t\t\tfloat _RayGlow;\n\t\t\tfloat _Zoom;\n\t\t\tfloat _SpeedHi;\n\t\t\tfloat _SpeedLow;\n\t\t\tfloat _SpeedRay;\n\t\t\tfloat _SpeedRing;\n\t\t\tfloat _Glow;\n\t\t\tfloat _Seed;\n\n\t\t\tfloat4 posGlob; // center position\n\t\t\t\t\t\t\t\t\t\n\t\t\tv2f vert (appdata v)\n\t\t\t{\n\t\t\t\tv2f o;\t\t\n\t\t\t\tposGlob = float4(UNITY_MATRIX_MV[0].w, UNITY_MATRIX_MV[1].w, UNITY_MATRIX_MV[2].w,0);\n\t\t\t\tfloat3x3 r=transpose((float3x3)UNITY_MATRIX_MV);\n\t\t\t\tfloat3x3 m;\n\t\t\t\tm[2]=normalize(mul(r,(float3)posGlob));\n\t\t\t\tm[1]=normalize(cross(m[2],float3(0.0, 1.0, 0.0)));\n\t\t\t\tm[0]=normalize(cross(m[1],m[2]));\n\t\t\t\to.uv1 = mul(transpose(m), (float3)v.vertex);\n            \to.vertex = mul(UNITY_MATRIX_MVP, float4(o.uv1, 1.0));\n\t\t\t\t\n\t\t\t\t#if UNITY_5_0\n\t\t\t\tUNITY_TRANSFER_FOG(o,o.vertex);\n\t\t\t\t#endif\n\t\t\t\treturn o;\n\t\t\t}\n\n\t\t\t// animated noise\n\t\t\tfixed4 hash4(fixed4 n) { return frac(sin(n)*(fixed)753.5453123); }\n\n\t\t\t// mix noise for alive animation\n\t\t\tfixed noise4q(fixed4 x)\n\t\t\t{\n\t\t\t\tfixed4 n3 = fixed4(0,0.25,0.5,0.75);\n\t\t\t\tfixed4 p2 = floor(x.wwww+n3);\n\t\t\t\tfixed4 b = floor(x.xxxx +n3) + floor(x.yyyy +n3)*157.0 + floor(x.zzzz +n3)*113.0;\n\t\t\t\tfixed4 p1 = b + frac(p2*0.00390625)*fixed4(164352.0, -164352.0, 163840.0, -163840.0);\n\t\t\t\tp2 = b + frac((p2+1)*0.00390625)*fixed4(164352.0, -164352.0, 163840.0, -163840.0);\n\t\t\t\tfixed4 f1 = frac(x.xxxx+n3);\n\t\t\t\tfixed4 f2 = frac(x.yyyy+n3);\n\t\t\t\t\n\t\t\t\tfixed4 n1 = fixed4(0,1.0,157.0,158.0);\n\t\t\t\tfixed4 n2 = fixed4(113.0,114.0,270.0,271.0);\t\t\n\t\t\t\tfixed4 vs1 = lerp(hash4(p1), hash4(n1.yyyy+p1), f1);\n\t\t\t\tfixed4 vs2 = lerp(hash4(n1.zzzz+p1), hash4(n1.wwww+p1), f1);\n\t\t\t\tfixed4 vs3 = lerp(hash4(p2), hash4(n1.yyyy+p2), f1);\n\t\t\t\tfixed4 vs4 = lerp(hash4(n1.zzzz+p2), hash4(n1.wwww+p2), f1);\t\n\t\t\t\tvs1 = lerp(vs1, vs2, f2);\n\t\t\t\tvs3 = lerp(vs3, vs4, f2);\n\t\t\t\t\n\t\t\t\tvs2 = lerp(hash4(n2.xxxx+p1), hash4(n2.yyyy+p1), f1);\n\t\t\t\tvs4 = lerp(hash4(n2.zzzz+p1), hash4(n2.wwww+p1), f1);\n\t\t\t\tvs2 = lerp(vs2, vs4, f2);\n\t\t\t\tvs4 = lerp(hash4(n2.xxxx+p2), hash4(n2.yyyy+p2), f1);\n\t\t\t\tfixed4 vs5 = lerp(hash4(n2.zzzz+p2), hash4(n2.wwww+p2), f1);\n\t\t\t\tvs4 = lerp(vs4, vs5, f2);\n\t\t\t\tf1 = frac(x.zzzz+n3);\n\t\t\t\tf2 = frac(x.wwww+n3);\n\t\t\t\t\n\t\t\t\tvs1 = lerp(vs1, vs2, f1);\n\t\t\t\tvs3 = lerp(vs3, vs4, f1);\n\t\t\t\tvs1 = lerp(vs1, vs3, f2);\n\t\t\t\t\n\t\t\t\treturn dot(vs1,0.25);\n\t\t\t}\n\t\t\t\t\t\n\t\t\tfloat RayProj;\n\t\t\tfloat sqRadius; // sphere radius\n\t\t\tfloat fragTime;\n\t\t\tfloat sphere; // sphere distance\n\t\t\tfloat3 surfase; // position on surfase\n\n\t\t\t// body of a star\n\t\t\tfixed noiseSpere(float zoom, float3 subnoise, float anim)\n\t\t\t{\n\t\t\t\tfixed s = 0.0;\n\n\t\t\t\tif (sphere <sqRadius) {\n\t\t\t\t\tif (_Detail>0.0) s = noise4q(fixed4(surfase*zoom*3.6864 + subnoise, fragTime*_SpeedHi))*0.625;\n\t\t\t\t\tif (_Detail>1.0) s =s*0.85+noise4q(fixed4(surfase*zoom*61.44 + subnoise*3.0, fragTime*_SpeedHi*3.0))*0.125;\n\t\t\t\t\tif (_Detail>2.0) s =s*0.94+noise4q(fixed4(surfase*zoom*307.2 + subnoise*5.0, anim*5.0))*0.0625;//*0.03125;\n\t\t\t\t\tif (_Detail>3.0) s =s*0.98+noise4q(fixed4(surfase*zoom*600.0 + subnoise*6.0, fragTime*_SpeedLow*6.0))*0.03125;\n\t\t\t\t\tif (_Detail>4.0) s =s*0.98+noise4q(fixed4(surfase*zoom*1200.0 + subnoise*9.0, fragTime*_SpeedLow*9.0))*0.01125;\n\t\t\t\t}\n\t\t\t\treturn s;\n\t\t\t}\n\n\t\t\tfixed4 frag (v2f i) : SV_Target\n\t\t\t{\n\t\t\t\tfloat invz =1/_Zoom;\n\t\t\t\t_Radius*=invz;\n\t\t\t\tfragTime=_Time.x*10.0;\n\t\t\t\tposGlob = float4(UNITY_MATRIX_MV[0].w, UNITY_MATRIX_MV[1].w, UNITY_MATRIX_MV[2].w,0);\n\t\t\t\tfloat3x3 m = (float3x3)UNITY_MATRIX_MV;\n\t\t\t\tfloat3 ray = normalize(mul(m, i.uv1) + posGlob.xyz);\n\t\t\t\tm = transpose((float3x3)UNITY_MATRIX_V);\n\n\t\t\t\tRayProj = dot(ray, (float3)posGlob);\n\t\t\t\tfloat sqDist=dot((float3)posGlob, (float3)posGlob);\n\t\t\t\tsphere = sqDist - RayProj*RayProj;\n\t\t\t\tsqRadius = _Radius*_Radius;\n\t\t\t\tif (RayProj<=0.0) sphere=sqRadius;\n\t\t\t\tfloat3 pr = ray*abs(RayProj) - (float3)posGlob;\n\t\t\t\t\n\t\t\t\tif (sqDist<=sqRadius) {\n\t\t\t\t\tsurfase=-posGlob;\n\t\t\t\t\tsphere=sqDist;\n\t\t\t\t} else if (sphere <sqRadius) {\n\t\t\t\t\tfloat l1 = sqrt(sqRadius - sphere);\n\t\t\t\t\tsurfase = mul(m,pr - ray*l1);\n\t\t\t\t} else {\n\t\t\t\t\tsurfase=(float3)0;\n\t\t\t\t}\n\n\t\t\t\tfixed4 col = fixed4(0,0,0,0);\n\n\t\t\t\tif (_Detail >= 1.0) {\n\t\t\t\t\tfloat s1 = noiseSpere(0.5*_Zoom, float3(45.78, 113.04, 28.957)*_Seed, fragTime*_SpeedLow);\n\t\t\t\t\ts1 = pow(s1*2.4, 2.0);\n\t\t\t\t\tfloat s2 = noiseSpere(4.0*_Zoom, float3(83.23, 34.34, 67.453)*_Seed, fragTime*_SpeedHi);\n\t\t\t\t\ts2 = s2*2.2;\n\n\t\t\t\t\tcol.xyz = fixed3(lerp((float3)_Color, (float3)_Light, pow(s1, 60.0))*s1);\n\t\t\t\t\tcol.xyz += fixed3(lerp(lerp((float3)_Base, (float3)_Dark, s2*s2), (float3)_Light, pow(s2, 10.0))*s2);\n\t\t\t\t}\n\n\t\t\t\tfixed c = length(pr)*_Zoom;\n\t\t\t\tpr = normalize(mul(m, pr));//-ray;\n\t\t\t\tfixed s = max(0.0, (1.0 - abs(_Radius*_Zoom - c) / _RayString));//*RayProj;\n\t\t\t\tfixed nd = noise4q(float4(pr+float3(83.23, 34.34, 67.453)*_Seed, -fragTime*_SpeedRing + c))*2.0;\n\t\t\t\tnd = pow(nd, 2.0);\n\t\t\t\tfixed dr=1.0;\n\t\t\t\tif (sphere < sqRadius) dr = sphere / sqRadius;\n\t\t\t\tpr*=10.0;\n\t\t\t\tfixed n = noise4q(float4(pr+ float3(83.23, 34.34, 67.453)*_Seed, -fragTime*_SpeedRing + c))*dr;\n\t\t\t\tpr*=5.0;\n\t\t\t\tfixed ns = noise4q(float4(pr+ float3(83.23, 34.34, 67.453)*_Seed, -fragTime*_SpeedRay + c))*2.0*dr;\n\t\t\t\tif (_Detail>=3.0) {\n\t\t\t\t\tpr *= 3.0;\n\t\t\t\t\tns = ns*0.5+noise4q(float4(pr+ float3(83.23, 34.34, 67.453)*_Seed, -fragTime*_SpeedRay + 0))*dr;\n\t\t\t\t}\n\t\t\t\tn = pow(n, _Rays)*pow(nd,_RayRing)*ns;\n\t\t\t\tfixed s3 = pow(s, _Glow) + pow(s, _RayGlow)*n;\n\n\t\t\t\tif (sphere < sqRadius) col.w = 1.0-s3*dr;\n\t\t\t\tif (sqDist>sqRadius)\n\t\t\t\t\tcol.xyz = col.xyz+lerp((fixed3)_Ray, (fixed3)_RayLight, s3*s3*s3)*s3; //pow(s3, 3.0)\n\t\t\t\t\n\t\t\t\tcol = clamp(col, 0, 1);\n\n#if UNITY_5_0\n\t\t\t\t// apply fog\n\t\t\t\tUNITY_APPLY_FOG(i.fogCoord, col);\n#endif\n\t\t\t\treturn col;\n\t\t\t}\n\t\t\tENDCG\n\t\t}\n\t}\n}\n*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lfSzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1975, 2021, 2043, 2043, 2083], [2084, 2084, 2106, 2106, 2146], [2147, 2147, 2168, 2168, 2284], [2285, 2417, 2440, 2440, 3735], [3737, 3755, 3844, 3844, 4351], [4353, 4366, 4416, 4416, 4549], [4551, 4569, 4646, 4646, 5094], [5096, 5096, 5184, 5184, 5759], [5761, 5761, 5806, 5806, 5921], [5923, 5923, 5980, 5980, 8819]], "test": "valid"}
{"id": "4lfXD4", "name": "Cray Tracer", "author": "vanSulli", "description": "learning about raytracing", "tags": ["test", "raytrace", "learning"], "likes": 2, "viewed": 189, "published": "Public", "date": "1436676902", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 nSphere( in vec3 pos, in vec4 sph){\n    return (pos - sph.xyz)/sph.w;\n}\n\nvec3 nPlane(in vec3 pos){\n    return vec3(0.0, 1.0, 0.0);\n}\n\nfloat iSphere(in vec3 ro, in vec3 rd, in vec4 sph){\n    vec3 oc = ro - sph.xyz;\n    float b = 2.0*dot(oc, rd);\n    float c = dot(oc, oc) - sph.w*sph.w;\n    float h = b*b - 4.0*c;\n    \n    if(h<0.0) return -1.0;\n    \n    float t = (-b - sqrt(h))/2.0;\n    return t;\n}\n\nfloat iPlane(in vec3 ro, in vec3 rd){\n    return -ro.y/rd.y;\n}\n\nvec4 sphere1 = vec4(0.0, 1.0, 0.0, 1.0);\n\nfloat intersect(in vec3 ro, in vec3 rd, out float resT){\n    float tsphere = iSphere(ro, rd, sphere1); //intersect with a sphere\n    float tplane = iPlane(ro, rd);\n    resT = 1000.0;\n    float id = -1.0;\n    if(tsphere > 0.0)\n    {\n        // hit a sphere\n        id = 1.0;\n        resT = tsphere;\n    }\n    if(tplane > 0.0 && tplane < resT){\n        // hit a plane\n        id = 2.0;\n        resT = tplane;\n    }\n    \n    return id;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 light = normalize(vec3(cos(iTime), 0.5, 0.7));\n    \n\tvec2 uv = (fragCoord.xy / iResolution.xy);\n    //sphere1.x = cos(iTime/2.0);\n    \n    // Make a ray\n    vec2 uvd = uv;// + vec2(iMouse.x/iResolution.x*2.0 - 1.5,iMouse.y/iResolution.y*2.0 - 1.0);\n    \n    vec3 ro = vec3(0.0, 0.1, 3.0);\n    ro += vec3(vec2(iMouse.x/iResolution.x*2.0 - 1.5,iMouse.y/iResolution.y*2.0 - 1.0),0.0);\n    vec3 rd = normalize(vec3(1.0*uvd* vec2(1.7, 1.0), -1.0) );\n    \n    // test for intersection with the scene\n    float t;\n    float id = intersect( ro, rd, t);\n    \n    vec3 col = vec3(0.0);\n    if( id>0.0 && id<1.5){\n     // hit sphere\n        vec3 position = ro + t*rd;\n        vec3 normal = nSphere(position, sphere1 );\n        float diffuse = dot(normal, light);\n        float ao = 0.5 + 0.5*normal.y;\n        col = vec3(0.390625, 0.5843, 0.929)*diffuse*ao + vec3(0.1, 0.2, 0.4)*ao;\n        \n    }\n    else if(id>1.5){\n     // hit plane\n        vec3 position = ro + t*rd;\n        vec3 normal = nPlane(position);\n        float diffuse = dot(normal, light);\n        float ambient = smoothstep(0.0, sphere1.w * 1.5, length(position.xz - sphere1.xz));\n        col = diffuse*ambient*vec3(0.5, 0.3, 0.0);\n    }\n    col = sqrt(col);\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lfXD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 76], [78, 78, 103, 103, 137], [139, 139, 190, 190, 404], [406, 406, 443, 443, 468], [512, 512, 568, 568, 946], [948, 948, 1005, 1005, 2259]], "test": "valid"}
{"id": "4lfXDM", "name": "Hatching", "author": "nmz", "description": "Cheap Procedural hatching for arbitrary geometry.\nUsing a mix of triplanar and cube projection for texturing.", "tags": ["procedural", "3d", "texturing", "technique"], "likes": 25, "viewed": 1197, "published": "Public", "date": "1436973899", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Hatching by nmz (twitter: @stormoid)\n\n/*\n\tnimitz here, I'll post what I feel to be \"less interesting\"\n\tshaders\ton this account from now on.\n\n\tShowing here procedural hatching using a combination\n\tof triplanar and cube projection\n\n\tThe \"shadows\" you see are only done using a denser hatching param.\n\n\tAlso featuring simple sepia tone conversion.\n*/\n\n#define ITR 80\n#define FAR 15.\n#define time iTime\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\nfloat torus(in vec3 p, in vec2 t){\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat map(vec3 p)\n{\n    float d = torus(p,vec2(.9,0.33));\n    d = min(d, -length(p)+5.);   \n    return d;\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tfloat precis = 0.001;\n    float h=precis*2.;\n    float d = 0.;\n    for( int i=0; i<ITR; i++ )\n    {\n        if( abs(h)<precis || d>FAR ) break;\n        d += h;\n\t    float res = map(ro+rd*d);\n        h = res;\n    }\n\treturn d;\n}\n\nfloat noise( in vec2 x ){return texture(iChannel0, x*.01).x;}\nfloat texh(in vec2 p, in float str)\n{\n    p*= .7;\n    float rz= 1.;\n    for (int i=0;i<10;i++)\n    {\n        float g = texture(iChannel0,vec2(0.025,.5)*p).x;\n        g = smoothstep(0.-str*0.1,2.3-str*0.1,g);\n        rz = min(1.-g,rz);\n        p.xy = p.yx;\n        p += .07;\n        p *= 1.2;\n        if (float(i) > str)break;\n    }\n    return rz*1.05;\n}\n\nvec3 cubeproj(in vec3 p, in float str)\n{\n    vec3 x = vec3(texh(p.zy/p.x,str));\n    vec3 y = vec3(texh(p.xz/p.y,str));\n    vec3 z = vec3(texh(p.xy/p.z,str));\n    \n    p = abs(p);\n    if (p.x > p.y && p.x > p.z) return x;\n    else if (p.y > p.x && p.y > p.z) return y;\n    else return z;\n}\n\nfloat texcube(in vec3 p, in vec3 n, in float str)\n{\n\tfloat x = texh(p.yz,str);\n\tfloat y = texh(p.zx,str);\n\tfloat z = texh(p.xy,str);\n    n *= n;\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\nvec3 normal(in vec3 p, in vec3 rd)\n{  \n    vec2 e = vec2(-1., 1.)*0.005;\n\tvec3 n = (e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );\n\tn -= max(.0, dot (n, rd))*rd;\n    return normalize(n);\n}\n\nfloat shadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<21; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res, 6.0*h/t );\n        t += clamp( h, 0.03, 0.2 );\n        if( abs(h)<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 sepia(in vec3 col)\n{\n    return vec3(dot(col, vec3(0.393,0.769,0.189)),\n                dot(col, vec3(0.349,0.686,0.168)),\n                dot(col, vec3(0.272,0.534,0.131)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = q-0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 mo = iMouse.xy / iResolution.xy-.5;\n\tmo.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0,2.+sin(time*0.5)-.7,0.);\n    ro.x += sin(time*.5)*4.;\n    ro.z += cos(time*.5)*4.;\n    \n    vec3 tgt = vec3(0,0,.5+sin(time));\n    vec3 eye = normalize( tgt - ro);\n    vec3 rgt = normalize(cross( vec3(0.0,1.0,0.0), eye ));\n    vec3 up = normalize(cross(eye,rgt));\n    vec3 rd = normalize( p.x*rgt + p.y*up + 1.5*eye );\n\n\tfloat rz = march(ro,rd);\n\t\n    vec3 col = vec3(0.);\n    vec3 ligt = vec3(1,2,3);\n    \n    if ( rz < FAR )\n    {\n        vec3 pos = ro+rz*rd;\n        vec3 nor= normal(pos,rd);\n        float nl  = max(dot(nor,normalize(ligt)),0.);\n        float sh = shadow(pos,normalize(ligt-pos),0.1,distance(pos,ligt));\n        nl *= sh*0.8+0.2;\n        nl = 1.0-nl;\n        nl = clamp(nl,0.,1.);\n        const float st = 10.;\n        vec3 col1 = vec3(texcube(pos,nor,nl*st));\n        vec3 col2 = cubeproj(pos,nl*st);\n        col = mix(col1,col2, .5);\n    }\n    \n    if (distance(ro,ligt) < rz)\n    {\n\t\tfloat lball = pow(max(dot(normalize(rd), normalize(ligt-ro)),0.), 4000.0);\n    \tcol += lball*vec3(1)*2.;\n    }\n    \n    col = sepia(col);\n\tcol *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.12 )*0.5+0.5; //form iq\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lfXDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[402, 402, 423, 423, 475], [477, 477, 511, 511, 564], [566, 566, 585, 585, 673], [675, 675, 712, 712, 940], [942, 942, 967, 967, 1003], [1004, 1004, 1041, 1041, 1357], [1359, 1359, 1399, 1399, 1647], [1649, 1649, 1700, 1700, 1841], [1843, 1843, 1879, 1879, 2077], [2079, 2079, 2149, 2149, 2412], [2414, 2414, 2439, 2439, 2595], [2597, 2597, 2654, 2654, 4007]], "test": "error"}
{"id": "4llSDM", "name": "CravoCircles", "author": "cravo", "description": "Recreating an old effect I saw once... (see https://www.youtube.com/watch?v=lM9Pk-jAhmw)\nIt boggles my eyes :-)", "tags": ["2d", "circle"], "likes": 3, "viewed": 148, "published": "Public", "date": "1437123545", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // default background colour\n    fragColor = vec4(0.0,0.0,0.7,1.0);\n    \n    // start with a circle in the middle of the screen\n    vec2 circleCentre = vec2(iResolution.xy) * 0.5;\n    float angle = iTime * 2.0;   \n    float radius = iResolution.y * 0.5;\n    float angleSign = 1.0; // which way round the circle is going\n    float width = 4.0; // how thick the lines are\n    \n    for(float i = 0.0; i < 5.0; ++i)\n    {\n        float dist = length(fragCoord.xy - circleCentre);\n\n        if ( dist < radius && dist > radius - width)\n        {     \n            fragColor = vec4(1.0);\n        }\n        \n        // Halve the radius and compute next circle's centre point\n        radius *= 0.5;\n        circleCentre.x += radius * sin((angle*angleSign) * (i + 1.0));\n        circleCentre.y += radius * cos((angle*angleSign) * (i + 1.0));\n        \n        // Flip the direction of travel\n        angleSign = -angleSign;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4llSDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 90, 981]], "test": "valid"}
{"id": "4llXD7", "name": "Rounded Box - distance 2D", "author": "iq", "description": "SIGNED distance to a rounded box. Video tutorials explaining how it works: [url]https://www.youtube.com/watch?v=62-pRVZuS5c[/url] and [url]https://www.youtube.com/watch?v=s5NGeUV2EyU[/url]", "tags": ["2d", "distance", "signed"], "likes": 37, "viewed": 8802, "published": "Public API", "date": "1437197054", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright Â© 2015 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org\n\n\n// Signed distance to a 2D rounded box. Tutorials explaining\n// how it works: \n//\n// https://www.youtube.com/watch?v=62-pRVZuS5c\n// https://www.youtube.com/watch?v=s5NGeUV2EyU\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n// and www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\n\n// b.x = width\n// b.y = height\n// r.x = roundness top-right  \n// r.y = roundness boottom-right\n// r.z = roundness top-left\n// r.w = roundness bottom-left\nfloat sdRoundBox( in vec2 p, in vec2 b, in vec4 r ) \n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n\tvec2 si = vec2(0.9,0.6) + 0.3*cos(iTime+vec2(0,2));\n    vec4 ra = 0.3 + 0.3*cos( 2.0*iTime + vec4(0,1,2,3) );\n    ra = min(ra,min(si.x,si.y));\n\n\tfloat d = sdRoundBox( p, si, ra );\n\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-3.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = sdRoundBox(m, si, ra );\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4llXD7.jpg", "access": "shaders20k", "license": "mit", "functions": [[1478, 1632, 1686, 1686, 1843], [1845, 1845, 1902, 1902, 2667]], "test": "valid"}
{"id": "4llXDN", "name": "Nearest Point", "author": "anastadunbar", "description": "Idea came from when working on my game project.<br/>if (min(dist_a,dist_b,dist_c,dist_d) = dist_a) {nearest = point_a} ... and so on", "tags": ["2d", "boolean"], "likes": 6, "viewed": 186, "published": "Public", "date": "1436925672", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Da pie is useless for this one, it's still fun to write it down by remembering the numbers.\n#define PI 3.14159265358979323846264\n\nfloat midsin(float val) {\n\treturn (sin(val)/2.)+0.5;\t\n}\nfloat midcos(float val) {\n\treturn (cos(val)/2.)+0.5;\t\n}\nvec3 rgb(int val1, int val2, int val3) {\n    return vec3(float(val1),float(val2),float(val3))/255.;\n}\n#define min4(a,b,c,d) min(min(min(a,b),c),d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n\tvec2 position = fragCoord.xy / iResolution.xy;\n    vec2 uv = vec2(((position.x-0.5)*(iResolution.x/iResolution.y))+0.5,position.y);\n    \n    vec2 point_a = vec2(midsin(time),0.4);\n    vec3 color_a = rgb(255,128,0);\n        \n    vec2 point_b = vec2(midcos(time/3.),midsin(time/3.));\n    vec3 color_b = rgb(100,255,0);\n        \n    vec2 point_c = vec2(midsin(time/2.53),0.8);\n    vec3 color_c = rgb(0,120,255);\n\n    vec2 point_d = vec2(midsin(time/1.4)/2.,midcos(time/1.4)/2.);\n    vec3 color_d = rgb(200,0,255);\n    \n    vec3 output_colors = vec3(0.);\n    \n    if (min4(length(uv-point_a),length(uv-point_b),length(uv-point_c),length(uv-point_d)) == length(uv-point_a)) {\n        output_colors = color_a;\n    }\n    if (min4(length(uv-point_a),length(uv-point_b),length(uv-point_c),length(uv-point_d)) == length(uv-point_b)) {\n        output_colors = color_b;\n    }\n    if (min4(length(uv-point_a),length(uv-point_b),length(uv-point_c),length(uv-point_d)) == length(uv-point_c)) {\n        output_colors = color_c;\n    }\n    if (min4(length(uv-point_a),length(uv-point_b),length(uv-point_c),length(uv-point_d)) == length(uv-point_d)) {\n        output_colors = color_d;\n    }\n    \n    float circle_size = 100.;\n    float circle_1 = 1.-clamp(floor(length(uv-point_a)*circle_size),0.,1.);\n    float circle_2 = 1.-clamp(floor(length(uv-point_b)*circle_size),0.,1.);\n    float circle_3 = 1.-clamp(floor(length(uv-point_c)*circle_size),0.,1.);\n    float circle_4 = 1.-clamp(floor(length(uv-point_d)*circle_size),0.,1.);\n    float all_circles = circle_1+circle_2+circle_3+circle_4;\n    \n\tfragColor = vec4(output_colors-all_circles,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4llXDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[132, 132, 157, 157, 187], [188, 188, 213, 213, 243], [244, 244, 284, 284, 345], [391, 391, 448, 448, 2102]], "test": "valid"}
{"id": "4llXW8", "name": "Raymarching Colega", "author": "vamoss", "description": "Testing raymarching", "tags": ["raymarching"], "likes": 8, "viewed": 216, "published": "Public", "date": "1436363920", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by tiago rezende & modified by vamoss - tiagosr/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst float VERY_LARGE_DISTANCE = 100.;\nconst float CAMERA_DISTORT = .4;\nconst int MAX_STEPS = 80;\nconst int MAX_SS_STEPS = 40;\n\n#define PI 3.14159265359\n#define pMod(a, b) (mod(a,b)-0.5*b)\n#define STANDARD_RAYMARCH\n//#define WATCH_DISTANCE\n//#define WATCH_STEPS\n\nvec3 opRotX(in float x, in vec3 point) {\n    return vec3(point.x, point.y*cos(x)-point.z*sin(x), point.y*sin(x)+point.z*cos(x));\n}\n\nmat3 mRotX(in float x) {\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(x), -sin(x),\n        0.0, sin(x), cos(x)\n        );\n}\n\nvec3 opRotY(in float y, in vec3 point) {\n    return vec3(point.x*cos(y)-point.z*sin(y), point.y, point.x*sin(y)+point.z*cos(y));\n}\n\nmat3 mRotY(float y) {\n    return mat3(\n        cos(y), 0.0, -sin(y),\n        0.0, 1.0, 0.0,\n        sin(y), 0.0, cos(y)\n        );\n}\n\nvec3 opRotZ(in float z, in vec3 point) {\n    return vec3(point.x*cos(z)-point.y*sin(z), point.x*sin(z)+point.y*cos(z), point.z);\n}\n\nmat3 mRotZ(in float z) {\n    return mat3(\n        cos(z), -sin(z), 0.0,\n        sin(z), cos(z), 0.0,\n        0.0, 0.0, 1.0\n        );\n}\n\nvec3 hsv2rgb(in vec3 c)\n{\n    const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat fSphere(in vec3 p, in float r) {\n    return length(p)-r;\n}\nfloat sdTorus(in vec3 p, in vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat sdBox(in vec3 p, in vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone(in vec3 p, in vec3 c) {\n    vec2 q = vec2(length(p.xz), p.y);\n    float d1 = -p.y-c.z;\n    float d2 = max(dot(q, c.xy), p.y);\n    return length(max(vec2(d1, d2),0.0)) + min(max(d1, d2), 0.0);\n}\n\nfloat sdCappedCone(in vec3 p, in vec2 c) {\n    float q = length(p.xy);\n    return dot(c, vec2(q, p.z));\n}\n\nfloat fCylinder(in vec3 p, in float r, in float height) {\n    return max(length(p.xz)-r,abs(p.y)-height);\n}\nfloat fInfCylinder(in vec2 p, in float r) {\n    return length(p)-r;\n}\n\nfloat fCapsule(in vec3 p, in float r, in float c) {\n    return mix(length(p.xz)-r,\n               length(vec3(p.x,abs(p.y)-c,p.z))-r,\n               step(c, abs(p.y)));\n}\n\nfloat fPlane(in vec3 p, in vec3 n) {\n    return dot(p, n);\n}\n\n//=====================================================\nfloat map( in vec3 p )\n{\n    // ground plane\n\tfloat ground = p.y + 1.0;\n    vec3 v1 = vec3(0.5, 0.5, -0.5)-p;\n    vec3 v2 = vec3(0.5, 0.5, -0.5)-p;\n    float rithym = sin(iTime+floor(v1.x*0.5));\n    float rithym2 = sin(iTime*8.0+floor(v1.x*0.5));\n    float d1 = sdTorus(vec3(pMod(v1.xz, 2.), v1.y).xzy, vec2((rithym2+1.0)/4.0+0.4,0.1+rithym2*0.01));\n    float d3 = sdCone(vec3(pMod(v2.xz, 2.), p.y+rithym*2.0-1.0).xzy, vec3(0.5, 0.3, 1.0));\n    vec2 p4 = vec2(iTime*2.0,1.2)-p.xy;\n    float d4 = fInfCylinder(vec2(pMod(p4.x-PI/4.0, PI*2.0), p4.y), 0.5);\n    vec2 p5 = vec2(iTime*2.0+PI,-0.6)-p.xy;\n    float d5 = 1.0;//fInfCylinder(vec2(pMod(p5.x-PI/4, PI*2), p5.y), 0.3);\n    \n    return min(ground,min(d1,min(d3, min(d4, d5))));\t\n}\n\n\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = VERY_LARGE_DISTANCE;\n\tfloat h = 1.0;\n    float t = 0.0;\n    for( int i=0; i<MAX_STEPS; i++ )\n    {\n#ifdef WATCH_STEPS\n        if(h<0.001 || t>maxd) return float(i)/float(MAX_STEPS);\n#else\n        if( h<0.001 || t>maxd ) break;\n#endif\n\t    h = map( ro+rd*t );\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n\t\n    return t;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.0002,0.0,0.0);\n\n\treturn normalize( vec3(\n           map(pos+eps.xyy) - map(pos-eps.xyy),\n           map(pos+eps.yxy) - map(pos-eps.yxy),\n           map(pos+eps.yyx) - map(pos-eps.yyx) ) );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n    float t = 0.0;\n\tfloat h = 1.0;\n    for( int i=0; i<MAX_SS_STEPS; i++ )\n    {\n        //t += max(warpzone(ro+rd*t, rd, k),0.);\n        h = map(ro + rd*t);\n        res = min( res, k*h/t );\n\t\tt += clamp( h, 0.01, 1.0 );\n\t\tif( h<0.0001 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.02 + 0.025*float(i*i);\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return 1.0 - clamp( occ, 0.0, 1.0 );\n}\n\nvec3 lig = normalize(vec3(1.0,0.9,0.7));\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.5);\n    if( iMouse.z>0.0 ) m = iMouse.xy/iResolution.xy;\n    \n    // camera\n    float an = 2.5 + 0.12*iTime - 6.2*m.x;\n    float cr = 0.3*cos(0.2*iTime);\n    vec3 ro = vec3(15.0*sin(an),10.0+m.x*60.0-24.0*m.y,15.0*cos(an));\n    vec3 ta = vec3( 0.0, 2.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(cr),cos(cr),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    float r2 = p.x*p.x*0.32 + p.y*p.y;\n    p *= (7.0-sqrt(37.5-11.5*r2))/(r2+1.0);\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n    \n    vec3 col = ro*rd;\n\n#ifdef WATCH_DISTANCE\n    float t = intersect(ro,rd);\n    fragColor = vec4(vec3(1.-t/VERY_LARGE_DISTANCE),1.);\n#endif\n\n#ifdef WATCH_STEPS\n    fragColor = vec4(vec3(1.0-intersect(ro, rd)), 1.);\n#endif\n\n\n#ifdef STANDARD_RAYMARCH\n    float t = intersect(ro,rd);\n    if( t>0.0 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\t\tfloat sha = calcSoftshadow( pos + nor*0.01, lig, 32.0 );\n\t\tfloat occ = calcOcclusion( pos, nor );\n\t\tcol =  vec3((sin(pos.x)+1.0)/2.0,(cos(pos.x)+1.0)/2.0,(sin(pos.y)+1.0)/2.0);\n\t\t\n\t}\n\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.45) );\n\tfragColor = vec4( col, 1.0);\n#endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4llXW8.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[416, 416, 456, 456, 546], [548, 548, 572, 572, 683], [685, 685, 725, 725, 815], [817, 817, 838, 838, 949], [951, 951, 991, 991, 1081], [1083, 1083, 1107, 1107, 1218], [1220, 1220, 1245, 1245, 1420], [1422, 1422, 1460, 1460, 1486], [1487, 1487, 1525, 1525, 1594], [1596, 1596, 1632, 1632, 1723], [1725, 1725, 1761, 1761, 1931], [1933, 1933, 1975, 1975, 2038], [2040, 2040, 2097, 2097, 2147], [2148, 2148, 2191, 2191, 2217], [2219, 2219, 2270, 2270, 2389], [2391, 2391, 2427, 2427, 2451], [2453, 2509, 2533, 2553, 3242], [3245, 3245, 3288, 3288, 3633], [3635, 3635, 3667, 3667, 3880], [3882, 3882, 3939, 3939, 4244], [4246, 4246, 4295, 4295, 4586], [4633, 4633, 4690, 4690, 6010]], "test": "valid"}
{"id": "4lsXD4", "name": "Displacement mapping", "author": "Kyroaku", "description": "Simple test for displacement mapping based on diffuse texture.", "tags": ["displacement", "texture", "bump", "displacementmapping", "diffuse"], "likes": 1, "viewed": 134, "published": "Public", "date": "1436877919", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision mediump float;\n\n#define MAX_MARCH_STEPS\t\t128\n#define MAX_MARCH_DISTANCE\t0.01\n\nstruct Fragment\n{\n    float depth;\n    vec3 material;\n};\n\nstruct PointLight\n{\n    vec3 position;\n    vec3 color;\n};\n\nfloat dSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat dSphereBumped(vec3 p, float r, vec3 c)\n{\n    return length(p) - r - c.r*0.1;\n}\n\nfloat dPlane(vec3 p)\n{\n    return p.y;\n}\n\nfloat dPlaneBumped(vec3 p, vec3 c)\n{\n    return p.y - c.r * 0.1;\n}\n\nFragment minF(Fragment a, Fragment b)\n{\n    if(a.depth < b.depth) return a;\n    else return b;\n}\n\nFragment map(vec3 p)\n{\n    vec3 c = texture(iChannel0, p.xz*0.1).xyz;\n    vec3 c2 = texture(iChannel0, p.xz*1.0).xyz;\n    \n    vec3 matGround = vec3(1.0, 0.6, 0.2);\n    vec3 matBall = vec3(0.7, 0.5, 0.3);\n    \n    Fragment f;\n    f = \t\tFragment(dSphereBumped(p - vec3(0.0, 1.5, 0.0), 1.0, c2), matBall);\n    f = minF(f, Fragment(dPlaneBumped(p, c), matGround));\n    return f;\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 t = vec2(0.01, 0.0);\n    return normalize(\n        vec3(\n        map(p+t.xyy).depth - map(p-t.xyy).depth,\n        map(p+t.yxy).depth - map(p-t.yxy).depth,\n        map(p+t.yyx).depth - map(p-t.yyx).depth )\n        );\n}\n\nmat3 lookAt(vec3 p, vec3 t, vec3 u)\n{\n    vec3 z = normalize(t - p);\n    vec3 x = normalize(cross(z, u));\n    vec3 y = normalize(cross(x, z));\n    return mat3(x, y, z);\n}\n\nFragment ray(vec3 ro, vec3 rd)\n{\n    float depth = 0.0;\n    for(int i = 0; i < MAX_MARCH_STEPS; i++)\n    {\n        Fragment f = map(ro + rd * depth);\n        depth += f.depth;\n        if(f.depth < MAX_MARCH_DISTANCE)\n        {\n            f.depth = depth;\n            return f;\n        }\n    }\n    return Fragment(-1.0, vec3(0.0, 0.0, 0.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n    \n    vec3 cp = vec3(cos(iTime)*6.0, 6.0, sin(iTime)*6.0);\n    vec3 ct = vec3(0.0, 0.0, -2.0);\n    vec3 cu = vec3(0.0, 1.0, 0.0);\n    mat3 cam = lookAt(cp, ct, cu);\n    \n    vec3 rd = cam * normalize(vec3(p, 2.5));\n    \n    Fragment f = ray(cp, rd);\n    vec3 pos = cp + rd*f.depth;\n    \n    vec3 n = normal(pos);\n    float diffuse = dot(n, normalize(vec3(0.0, 2.0, 1.0)));\n    \n    vec3 color = f.material * diffuse;\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lsXD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[205, 205, 237, 237, 265], [267, 267, 313, 313, 351], [353, 353, 375, 375, 393], [395, 395, 431, 431, 461], [463, 463, 502, 502, 559], [561, 561, 583, 583, 938], [940, 940, 961, 961, 1188], [1190, 1190, 1227, 1227, 1360], [1362, 1362, 1394, 1394, 1705], [1707, 1707, 1764, 1764, 2323]], "test": "error"}
{"id": "4lsXWH", "name": "color: texture sampling gamma", "author": "hornet", "description": "inspired by https://www.shadertoy.com/view/4tfXDH - see also https://www.shadertoy.com/view/XtsSzH\nNote that the sampled texture is not meant to be used as an image, rather for it's values as a lookup-table.\nThe result is valid none-the-less.", "tags": ["filtering", "mipmap", "sampling", "gamma", "srgb"], "likes": 3, "viewed": 1482, "published": "Public API", "date": "1436429607", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float gamma = 2.4;\n\nvec3 hash32n(vec2 p);\n\nvec3 srgb2lin( vec3 c )\n{\n    return pow( c, vec3(gamma) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - vec2(2.0*iTime,0.0)) / iChannelResolution[0].xy;\n\n\tvec3 colA;\n\n\tif ( fragCoord.y / iResolution.y > 2.0/3.0 )\n\t{\n        //incorrect, as filtering is done in srgb-space\n\t\tcolA = pow( texture( iChannel0, uv, 0.0 ).xyz, vec3(gamma) );\n\t}\n    else if ( fragCoord.y / iResolution.y > 1.0/3.0 )\n    {\n        //manual bilinear filtering\n        //emulating proper, correct, filtering in linear space\n        //\n        //note that the texture still blurs/sharpens in a strobing fashion\n        //since were are sampling below the nyquist frequency\n        vec2 uvpx = uv * iChannelResolution[0].xy;\n        vec2 uvpx_f = fract( uvpx );\n        vec2 uvpx_i = floor( uvpx ) + vec2(0.5);\n        \n        vec2 uv_i = uvpx_i / iChannelResolution[0].xy;\n        vec2 uv0 = uv_i;\n        vec2 uv1 = uv_i + vec2(1,0) / iChannelResolution[0].xy;\n        vec2 uv2 = uv_i + vec2(0,1) / iChannelResolution[0].xy;\n        vec2 uv3 = uv_i + vec2(1,1) / iChannelResolution[0].xy;\n            \n        vec3 colA0 = srgb2lin( texture( iChannel0, uv0, 0.0 ).rgb );\n        vec3 colA1 = srgb2lin( texture( iChannel0, uv1, 0.0 ).rgb );\n        vec3 colA2 = srgb2lin( texture( iChannel0, uv2, 0.0 ).rgb );\n        vec3 colA3 = srgb2lin( texture( iChannel0, uv3, 0.0 ).rgb );\n        colA = mix ( mix( colA0, colA1, uvpx_f.x ),\n                     mix( colA2, colA3, uvpx_f.x ),\n                     uvpx_f.y );\n    }\n    else\n    {\n        //sampling one mip down (test to go above nyquist frequency)\n        //...shows that mip-creation is incorrectly done in srgb-space too\n        colA = pow( texture( iChannel0, uv, 1.0 ).xyz, vec3(gamma) );\n    }\n\n    vec3 outcol = colA;\n\toutcol += hash32n( fragCoord.xy + fract( iTime ) ) / 255.0; //dither for quantisation\n    outcol = pow( outcol, vec3(1.0/gamma) ); //gamma-correction\n    \n\t//fragColor = vec4( vec3(1.0) - outcol, 1.0 ); //shows middle strobing a lot\n    fragColor = vec4( outcol, 1.0 );\n}\n\n//note: uniform pdf rand [0;1[\nvec3 hash32n(vec2 p)\n{\n\tp  = fract(p * vec2(5.3987, 5.4421));\n    p += dot(p.yx, p.xy +  vec2(21.5351, 14.3137));\n\treturn fract(vec3(p.x * p.y * 95.4307, p.x * p.y * 97.5901, p.x * p.y * 93.8369));\n}\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lsXWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 74, 74, 110], [112, 112, 169, 169, 2121], [2123, 2154, 2176, 2176, 2353]], "test": "error"}
{"id": "4lsXWn", "name": "testergsdf", "author": "swipe", "description": "gdffdf", "tags": ["2d"], "likes": 0, "viewed": 130, "published": "Public", "date": "1435850004", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lsXWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 147]], "test": "valid"}
{"id": "4lsXz2", "name": "cymatics wave tank kindof", "author": "iterationsteppa", "description": "Mouse Interaction. Some wave machines with variable distance from centre and wave speed (period), similar to sound waves bouncing inside a square plate in cymatics. Similar to animal pigments for example in fish. ", "tags": ["cymatics"], "likes": 6, "viewed": 353, "published": "Public", "date": "1438138590", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//using a wave tank emulation, with 4 wave engines  placed in symmetry the waves meet in the middle. when wave engines are far away, the lines made by the\n//wave engines are nearly straight and the middle is same as in the pic.\n//Please share developments from this work on this page in comments. \n//Prizes for you if you can make a linear-tile-version using square waves instead of sines or somthing.\n//Creative Commons Ã¢â¬â Attribution 3.0 Antony Stewart\n//overall formula is a variable patterned alternataive to perlin noise function\n//and can be used for iso-surfaces i.e multiply in 3d with a sphere.\n\n\nvoid mainImage( out vec4 color, vec2 UVcoords )\n{\n   float d3 = iResolution.y*.5 ,//number to move pic upwards\n         d4 =  iResolution.x*.5 ,//number to move pic sideways\n         d2 = 8.0 - 4.0 * sin(iTime*.07 ) + iMouse.y*0.0021, //number to move 5 wave machines outwards\n    \td1 = .5; ;// wave width\n   UVcoords = .5*(UVcoords - vec2(d4,d3)); //move pic around\n    \n    \n\t//function to make color concentric sinewaves like water drop waves radiating from a pt:   \n#define S(X, Y, period)   color += sin(length(UVcoords + vec2(X,Y)*d2)*period);    // sin(length()*p2)+v2\n\t//see end for full formula including angular coordinates as well as concentric\n\t//Tip: to remix the code, you can try mixing 3/4/8 \n    //wave machines in different symmetries and vary their distance and amplitudes\n  \n\n   \n//make 5 wave machines where the color is added t*d2ogether on coordinates of pentagon:\n    \n    //central wave machine on origin\n    S(0.0,0.0,iMouse.x*0.01)\n        \n    //4 other wave machines on axes\n    S(0,1.0*d2,d1)  S(0,-1.0*d2,d1)  S(-1.0*d2,-0.0,d1)  S(1.0*d2,0.0,d1)   \n}\n    \n\n//NOTE: original version had concentric wave forms in this fasion:\n\n//float2 xy2 = IN.uv_MainTex + float2(-0.5, -0.5*d3 ) + float2(k1,j1)*d2; \n//position of the point\n\n//float c2 = length(xy2);//polar coordinates (x axis becomes radial)\n\n//ht+=  (sin(c2 * p2)  *v2) ;//angular coordinates (y becomes angle)\n    \n    \n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lsXz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "valid"}
{"id": "4lsXzj", "name": "Signed Distance Teddy", "author": "Doidel", "description": "A floating teddy designed with some trigonometry in a signed distance field. Based on otaviogood's \"Straticum\".\nPlease go easy on me, it's my very first shader ^^ That's also why there's no real material or clouds (yet)...", "tags": ["procedural", "fractal", "raymarch", "signeddistancefield", "teddybear"], "likes": 7, "viewed": 1586, "published": "Public API", "date": "1438089429", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^This means do anything you want with this code. Because we are programmers, not lawyers.\n-Otavio Good\n*/\n\n// Set this to change detail level. [1 - 10] is a good range.\nconst int NUM_SIN_REPS = 9;\nconst int MAX_MARCH_REPS = 250;\nconst float MARCH_DISTANCE_MULTIPLIER = 0.1;\n\nfloat localTime = 0.0;\n\n// some noise functions\nfloat Hash(float f)\n{\n    return fract(cos(f)*7561.0);\n}\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 521.0;\t// repeats after this value\n    float rand = fract(cos(f)*104729.0);\n    return rand;\n}\nvec2 Hash2(vec2 v)\n{\n    return fract(cos(v*3.333)*vec2(100003.9, 37049.7));\n}\nfloat Hash3d(vec3 uv)\n{\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\n    return fract(sin(f)*110003.9);\n}\n\nfloat mixS(float f0, float f1, float a)\n{\n    if (a < 0.5) return f0;\n    return f1;\n}\n\nfloat mixC(float f0, float f1, float a)\n{\n    return mix(f1, f0, cos(a*3.1415926) *0.5+0.5);\n}\n\nfloat mixP(float f0, float f1, float a)\n{\n    return mix(f0, f1, a*a*(3.0-2.0*a));\n}\nvec2 mixP2(vec2 v0, vec2 v1, float a)\n{\n    return mix(v0, v1, a*a*(3.0-2.0*a));\n}\n\nfloat mixSS(float f0, float f1, float a)\n{\n    return mix(f0, f1, smoothstep(0.0, 1.0, a));\n}\n\nconst vec2 zeroOne = vec2(0.0, 1.0);\nfloat noise2dVec(vec2 uv)\n{\n    vec2 fr = fract(uv);\n    vec2 fl = floor(uv);\n    vec2 h0 = vec2(Hash2d(fl), Hash2d(fl + zeroOne));\n    vec2 h1 = vec2(Hash2d(fl + zeroOne.yx), Hash2d(fl + zeroOne.yy));\n    vec2 xMix = mixP2(h0, h1, fr.x);\n    return mixC(xMix.x, xMix.y, fr.y);\n}\nfloat noise2d(vec2 uv)\n{\n    vec2 fr = fract(uv);\n    vec2 fl = floor(uv);\n    float h00 = Hash2d(fl);\n    float h10 = Hash2d(fl + zeroOne.yx);\n    float h01 = Hash2d(fl + zeroOne);\n    float h11 = Hash2d(fl + zeroOne.yy);\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\n}\nfloat noise(vec3 uv)\n{\n    vec3 fr = fract(uv.xyz);\n    vec3 fl = floor(uv.xyz);\n    float h000 = Hash3d(fl);\n    float h100 = Hash3d(fl + zeroOne.yxx);\n    float h010 = Hash3d(fl + zeroOne.xyx);\n    float h110 = Hash3d(fl + zeroOne.yyx);\n    float h001 = Hash3d(fl + zeroOne.xxy);\n    float h101 = Hash3d(fl + zeroOne.yxy);\n    float h011 = Hash3d(fl + zeroOne.xyy);\n    float h111 = Hash3d(fl + zeroOne.yyy);\n    return mixP(\n        mixP(mixP(h000, h100, fr.x),\n             mixP(h010, h110, fr.x), fr.y),\n        mixP(mixP(h001, h101, fr.x),\n             mixP(h011, h111, fr.x), fr.y)\n        , fr.z);\n}\n\nfloat PI=3.14159265;\n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nvec3 RotateX(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  //if (RIGHT_HANDED_COORD)\n  return vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\n  //else return new float3(x, cos * y - sin * z, sin * y + cos * z);\n}\nvec3 RotateY(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  //if (RIGHT_HANDED_COORD)\n  return vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\n  //else return new float3(cos * x + sin * z, y, -sin * x + cos * z);\n}\nvec3 RotateZ(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  //if (RIGHT_HANDED_COORD)\n  return vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\n}\n\n\n// This function basically is a procedural environment map that makes the sun\nvec3 sunCol = vec3(258.0, 228.0, 170.0) / 3555.0;//unfortunately, i seem to have 2 different sun colors. :(\nvec3 GetSunColorReflection(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 localRay = normalize(rayDir);\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\n\tfloat sunIntensity = 0.015 / dist;\n\tsunIntensity = pow(sunIntensity, 0.3)*100.0;\n\n    sunIntensity += exp(-dist*12.0)*300.0;\n\tsunIntensity = min(sunIntensity, 40000.0);\n    //vec3 skyColor = mix(vec3(1.0, 0.95, 0.85), vec3(0.2,0.3,0.95), pow(saturate(rayDir.y), 0.7))*skyMultiplier*0.95;\n\treturn sunCol * sunIntensity*0.0425;\n}\nvec3 GetSunColorSmall(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 localRay = normalize(rayDir);\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\n\tfloat sunIntensity = 0.05 / dist;\n    sunIntensity += exp(-dist*12.0)*300.0;\n\tsunIntensity = min(sunIntensity, 40000.0);\n\treturn sunCol * sunIntensity*0.025;\n}\n\nvec4 cXX = vec4(0.0, 3.0, 0.0, 0.0);\n\nvec3 camPos = vec3(0.0), camFacing;\nvec3 camLookat=vec3(0,0.0,0);\n\nfloat SinRep(float a)\n{\n    float h = 0.0;\n    float mult = 1.0;\n    for (int i = 0; i < NUM_SIN_REPS; i++)\n    {\n        h += (cos(a*mult)/(mult));\n        mult *= 2.0;\n    }\n    return h;\n}\n\nvec2 DistanceToObject(vec3 p)\n{\n    float final = 0.0;\n    float material = 0.0;\n    if (p.y > -2.0)\n    {\n    \tfloat balloonform = length(vec3(p.x*1.3,p.y,p.z*1.3)) -2.0;\n        final = balloonform;\n        material = \t0.2;\n    }\n    else if (p.y > -4.0)\n    {  \n    \tfloat cord = length(p.xz) - 0.02;\n        final = cord;\n    } else {\n     \t// the teddy\n        \n        //right arm\n        float teddyHandUp = length(vec3(p.x, p.y + 4.5, p.z)) - 0.5;\n        vec3 teddyArmUpPos1 = vec3(0.1, -4.8, 0.1);\n        vec3 teddyArmUpPos2 = vec3(0.15, -5.3, 0.15);\n        vec3 t = normalize(teddyArmUpPos2 - teddyArmUpPos1);\n        float l = dot(t,p-teddyArmUpPos1);\n        float teddyArmUp = length((teddyArmUpPos1 + clamp(l,0.0,1.5) * t) - p) - 0.5;\n        \n        \n        // left arm\n        vec3 teddyArmDownPos1 = vec3(2.2, -6.3, 2.2);\n        vec3 teddyArmDownPos2 = vec3(2.35, -6.8, 2.35);\n        t = normalize(teddyArmDownPos2 - teddyArmDownPos1);\n        l = dot(t,p-teddyArmDownPos1);\n        float teddyArmDown = length((teddyArmDownPos1 + clamp(l,0.0,1.5) * t) - p) - 0.5;\n        \n        // body\n        float teddyBody = length(vec3((p.x - 1.2) * 1.3, p.y + 7.5, (p.z - 1.2) * 1.3)) - 1.8;\n        \n        // head\n        float teddyHead = length(vec3(p.x - 1.2, p.y + 5.2, p.z - 1.2)) - 1.0;\n        \n        // eyes\n        float teddyEyeLeft = length(vec3(p.x - 1.5, p.y + 5.0, p.z - 0.3)) - 0.15;\n        float teddyEyeRight = length(vec3(p.x - 2.0, p.y + 5.0, p.z - 0.8)) - 0.15;\n        \n        // ears\n        float teddyEarLeft = length(vec3((p.x - 0.8)* 1.5, p.y + 4.7, (p.z - 0.9)*1.5)) - 0.7;  \n        float teddyEarRight = length(vec3((p.x - 1.6)* 1.5, p.y + 4.7, (p.z - 1.7)*1.5)) - 0.7; \n        \n        // nose\n        float teddyNose = length(vec3(p.x - 1.65, p.y + 5.35, p.z - 0.65)) - 0.4;\n        float teddyNoseBump = length(vec3(p.x - 1.85, p.y + 5.35, p.z - 0.35)) - 0.1;\n        \n        // left leg\n        vec3 teddyLegLeftPos1 = vec3(1.9, -9.0, 1.9);\n        vec3 teddyLegLeftPos2 = vec3(4.0, -9.3, 1.0);\n        t = normalize(teddyLegLeftPos2 - teddyLegLeftPos1);\n        l = dot(t,p-teddyLegLeftPos1);\n        float teddyLegLeft = length((teddyLegLeftPos1 + clamp(l,0.0,1.5) * t) - p) - 0.5;\n        \n        // right leg\n        vec3 teddyLegRightPos1 = vec3(1.0, -9.0, 1.0);\n        vec3 teddyLegRightPos2 = vec3(2.0, -9.3, -1.5);\n        t = normalize(teddyLegRightPos2 - teddyLegRightPos1);\n        l = dot(t,p-teddyLegRightPos1);\n        float teddyLegRight = length((teddyLegRightPos1 + clamp(l,0.0,1.5) * t) - p) - 0.5;\n        \n        final = min(teddyNose, min(teddyNoseBump, min(teddyLegLeft, teddyLegRight)));\n        final = min(teddyHead, min(teddyEyeLeft, min(teddyEyeRight, min(teddyEarLeft, min(teddyEarRight, final)))));\n        final = min(teddyHandUp, min(teddyArmUp, min(teddyArmDown, min(teddyBody, final))));\n        \n        if (final == teddyEyeLeft || final == teddyEyeRight || final == teddyNoseBump)\n        {\n         \tmaterial = 0.1; \n        }\n    }\n    return vec2(final, material);\n}\n\nfloat distFromSphere;\nfloat IntersectSphereAndRay(vec3 pos, float radius, vec3 posA, vec3 posB, out vec3 intersectA2, out vec3 intersectB2)\n{\n\t// Use dot product along line to find closest point on line\n\tvec3 eyeVec2 = normalize(posB-posA);\n\tfloat dp = dot(eyeVec2, pos - posA);\n\tvec3 pointOnLine = eyeVec2 * dp + posA;\n\t// Clamp that point to line end points if outside\n\t//if ((dp - radius) < 0) pointOnLine = posA;\n\t//if ((dp + radius) > (posB-posA).Length()) pointOnLine = posB;\n\t// Distance formula from that point to sphere center, compare with radius.\n\tfloat distance = length(pointOnLine - pos);\n\tfloat ac = radius*radius - distance*distance;\n\tfloat rightLen = 0.0;\n\tif (ac >= 0.0) rightLen = sqrt(ac);\n\tintersectA2 = pointOnLine - eyeVec2 * rightLen;\n\tintersectB2 = pointOnLine + eyeVec2 * rightLen;\n\tdistFromSphere = distance - radius;\n\tif (distance <= radius) return 1.0;\n\treturn 0.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    localTime = iTime - 1.6;\n\t// ---------------- First, set up the camera rays for ray marching ----------------\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\n\n\t// Camera up vector.\n\tvec3 camUp=vec3(0,1,0); // vuv\n\n\t// Camera lookat.\n\tcamLookat=vec3(0,0.0,0);\t// vrp\n\n    // debugging camera\n    float mx=iMouse.x/iResolution.x*PI*2.0-0.7 + localTime * 0.123;\n\tfloat my=-iMouse.y/iResolution.y*10.0 - sin(localTime * 0.31)*0.5;//*PI/2.01;\n\tvec3 camAdd = vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*(9.2); \t// prp\n    camPos += camAdd;\n\n\n    // add randomness to camera for depth-of-field look close up.\n    //camPos += vec3(Hash2d(uv)*0.91, Hash2d(uv+37.0), Hash2d(uv+47.0))*0.01;\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);//vpn\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\t// u\n\tvec3 upNorm=cross(camVec, sideNorm);//v\n\tvec3 worldFacing=(camPos + camVec);//vcv\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;//scrCoord\n\tvec3 relVec = normalize(worldPix - camPos);//scp\n\n\t// --------------------------------------------------------------------------------\n\t// I put a bounding sphere around the whole object. If the ray is outside\n\t// of the bounding sphere, I don't bother ray marching. It's just an optimization.\n\tvec3 iA, iB;\n\tfloat hit = IntersectSphereAndRay(vec3(0,-5.0,0), /*7.6*/10.0, camPos, camPos+relVec, iA, iB);\n\n\t// --------------------------------------------------------------------------------\n\tvec2 distAndMat = vec2(0.05, 0.0);\n\tfloat t = 0.0;\n\tfloat inc = 0.02;\n\tfloat maxDepth = 110.0;\n\tvec3 pos = vec3(0,0,0);\n    // start and end the camera ray at the sphere intersections.\n    camPos = iA;\n    maxDepth = distance(iA, iB);\n\t// ray marching time\n\tif (hit > 0.5)\t// check if inside bounding sphere before wasting time ray marching.\n\t{\n        for (int i = 0; i < MAX_MARCH_REPS; i++)\t// This is the count of the max times the ray actually marches.\n        {\n            if ((t > maxDepth) || (abs(distAndMat.x) < 0.0075)) break;\n            pos = camPos + relVec * t;\n            // *******************************************************\n            // This is _the_ function that defines the \"distance field\".\n            // It's really what makes the scene geometry.\n            // *******************************************************\n            distAndMat = DistanceToObject(pos);\n            // adjust by constant because deformations mess up distance function.\n            t += distAndMat.x * MARCH_DISTANCE_MULTIPLIER;\n        }\n    }\n    else\n    {\n\t\tt = maxDepth + 1.0;\n        distAndMat.x = 1.0;\n    }\n\t// --------------------------------------------------------------------------------\n\t// Now that we have done our ray marching, let's put some color on this geometry.\n\n\tvec3 sunDir = normalize(vec3(0.93, 1.0, -1.5));\n\tvec3 finalColor = vec3(0.0);\n\n\t// If a ray actually hit the object, let's light it.\n\tif (abs(distAndMat.x) < 0.75)\n    //if (t <= maxDepth)\n\t{\n        // calculate the normal from the distance field. The distance field is a volume, so if you\n        // sample the current point and neighboring points, you can use the difference to get\n        // the normal.\n        vec3 smallVec = vec3(0.005, 0, 0);\n        vec3 normalU = vec3(distAndMat.x - DistanceToObject(pos - smallVec.xyy).x,\n                           distAndMat.x - DistanceToObject(pos - smallVec.yxy).x,\n                           distAndMat.x - DistanceToObject(pos - smallVec.yyx).x);\n\n        vec3 normal = normalize(normalU);\n\n        // calculate 2 ambient occlusion values. One for global stuff and one\n        // for local stuff - so the green sphere light source can also have ambient.\n        float ambientS = 1.0;\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.1).x*10.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.2).x*5.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.4).x*2.5);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.8).x*1.25);\n        float ambient = ambientS * saturate(DistanceToObject(pos + normal * 1.6).x*1.25*0.5);\n        ambient *= saturate(DistanceToObject(pos + normal * 3.2).x*1.25*0.25);\n        ambient *= saturate(DistanceToObject(pos + normal * 6.4).x*1.25*0.125);\n        ambient = max(0.15, pow(ambient, 0.3));\t// tone down ambient with a pow and min clamp it.\n        ambient = saturate(ambient);\n\n        // Trace a ray toward the sun for sun shadows\n        float sunShadow = 1.0;\n        float iter = 0.2;\n\t\tfor (int i = 0; i < 10; i++)\n        {\n            float tempDist = DistanceToObject(pos + sunDir * iter).x;\n\t        sunShadow *= saturate(tempDist*10.0);\n            if (tempDist <= 0.0) break;\n            iter *= 1.5;\t// constant is more reliable than distance-based\n            //iter += max(0.2, tempDist)*1.2;\n        }\n        sunShadow = saturate(sunShadow);\n\n        // calculate the reflection vector for highlights\n        vec3 ref = reflect(relVec, normal);\n\n        // ------ Calculate texture color of the rock ------\n        // base texture can be swirled noise.\n\t\t//vec3 rp = RotateY(pos, pos.y*0.4 - cos(localTime)*0.4);\n        //float n = noise(rp*4.0) + noise(rp*8.0) + noise(rp*16.0) + noise(rp*32.0);\n        vec3 redBase = vec3(1.0,0.01,0.05);\n        vec3 brownBase = vec3(0.3,0.15,0.0);\n        \n        vec3 texColor = redBase;\n        if (pos.y <= -4.0)\n        {\n         \ttexColor = brownBase;\n            float n = noise(pos * 40.0);\n            //n = saturate(n*0.25 * 0.95 + 0.05);\n            texColor *= n/2.0 + 1.0/2.0;\n        }\n        \n        if (distAndMat.y > 0.05 && distAndMat.y <= 0.15)\n        {\n         \ttexColor = vec3(0.05,0.05,0.1);   \n        }\n\n        /*\n        // fade to reddish texture on outside\n        texColor += vec3(0.99, 0.21, 0.213) * clamp(length(pos)-4.0, 0.0, 0.4);\n        // give it green-blue texture that matches the shape using normal length\n        texColor += vec3(1.0, 21.0, 26.0)*0.6 * saturate(length(normalU)-0.01);\n        // Give it a reddish-rust color in the middle\n        texColor -= vec3(0.0, 0.3, 0.5)*saturate(-distAndMat.y*(0.9+sin(localTime+0.5)*0.9));\n        // make sure it's not too saturated so it looks realistic\n        texColor = max(vec3(0.02),texColor);\n        */;\n\n        // ------ Calculate lighting color ------\n        // Start with sun color, standard lighting equation, and shadow\n        vec3 lightColor = sunCol * saturate(dot(sunDir, normal)) * sunShadow*14.0;\n        // sky color, hemisphere light equation approximation, anbient occlusion\n        lightColor += vec3(0.1,0.35,0.95) * (normal.y * 0.5 + 0.5) * ambient * 0.25;\n        // ground color - another hemisphere light\n        lightColor += vec3(1.0) * ((-normal.y) * 0.5 + 0.5) * ambient * 0.2;\n\n        // finally, apply the light to the texture.\n        finalColor = texColor * lightColor;\n\n        // specular highlights - just a little\n        vec3 refColor = GetSunColorReflection(ref, sunDir)*0.68;\n        finalColor += refColor * sunCol * sunShadow * 9.0 * texColor.g;\n\n        // fog that fades to sun color so that fog is brightest towards sun\n        finalColor = mix(vec3(0.98, 0.981, 0.981) + min(vec3(0.25),GetSunColorSmall(relVec, sunDir))*2.0, finalColor, exp(-t*0.007));\n        //finalColor = vec3(1.0, 21.0, 26.0) * saturate(length(normalU)-0.01);\n        \n        // if it's the balloon, make it a bit transparent\n        \n        if (distAndMat.y > 0.15)\n        {\n            vec3 bgCol = mix(vec3(1.0, 0.95, 0.85), vec3(0.2,0.5,0.95), pow(saturate(relVec.y), 0.7))*0.95;\n            // add the sun\n            bgCol += GetSunColorSmall(relVec, sunDir);// + vec3(0.1, 0.1, 0.1);\n            finalColor = mix(bgCol, finalColor, 0.9);\n        }\n\t}\n    else\n    {\n        // Our ray trace hit nothing, so draw sky.\n        // fade the sky color, multiply sunset dimming\n        finalColor = mix(vec3(1.0, 0.95, 0.85), vec3(0.2,0.5,0.95), pow(saturate(relVec.y), 0.7))*0.95;\n        // add the sun\n        finalColor += GetSunColorSmall(relVec, sunDir);// + vec3(0.1, 0.1, 0.1);\n    }\n\n    // vignette?\n    finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\n    finalColor *= 1.95;\n\n\t// output the final color with sqrt for \"gamma correction\"\n\tfragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lsXzj.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[753, 777, 798, 798, 833], [834, 834, 857, 857, 980], [981, 981, 1001, 1001, 1059], [1060, 1060, 1083, 1083, 1169], [1171, 1171, 1212, 1212, 1257], [1259, 1259, 1300, 1300, 1353], [1355, 1355, 1396, 1396, 1439], [1440, 1440, 1479, 1479, 1522], [1524, 1524, 1566, 1566, 1617], [1656, 1656, 1683, 1683, 1935], [1936, 1936, 1960, 1960, 2227], [2228, 2228, 2250, 2250, 2835], [2859, 2859, 2882, 2882, 2911], [2912, 2912, 2935, 2935, 2964], [2965, 2965, 2990, 2990, 3019], [3021, 3021, 3054, 3054, 3268], [3269, 3269, 3302, 3302, 3516], [3517, 3517, 3550, 3550, 3695], [3698, 3884, 3938, 3938, 4360], [4361, 4361, 4410, 4410, 4664], [4771, 4771, 4794, 4794, 4962], [4964, 4964, 4995, 4995, 8031], [8055, 8055, 8174, 8235, 8929], [8932, 8932, 8989, 8989, 17313]], "test": "valid"}
{"id": "4tfSRj", "name": "2D Vector field visualizer", "author": "nmz", "description": "The RGB coloring is trying to show the underlying gradient field.\n\nSimple version: https://www.shadertoy.com/view/XlfSRj", "tags": ["2d", "visualization", "vectorfield", "vecotr", "visulizer"], "likes": 63, "viewed": 2810, "published": "Public", "date": "1437767399", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//2D Vector field visualizer by nmz (twitter: @stormoid)\n\n/*\n\tThere is already a shader here on shadertoy for 2d vector field viz, \n\tbut I found it to be hard to use so I decided to write my own.\n*/\n\n#define time iTime\n\nconst float arrow_density = 1.5;\nconst float arrow_length = .45;\n\nconst vec3 luma = vec3(0.2126, 0.7152, 0.0722);\n\nfloat f(in vec2 p)\n{\n    return sin(p.x+sin(p.y+time*0.1)) * sin(p.y*p.x*0.1+time*0.2);\n}\n\n\n//---------------Field to visualize defined here-----------------\nvec2 field(in vec2 p)\n{\n\tvec2 ep = vec2(.05,0.);\n    vec2 rz= vec2(0);\n\tfor( int i=0; i<7; i++ )\n\t{\n\t\tfloat t0 = f(p);\n\t\tfloat t1 = f(p + ep.xy);\n\t\tfloat t2 = f(p + ep.yx);\n        vec2 g = vec2((t1-t0), (t2-t0))/ep.xx;\n\t\tvec2 t = vec2(-g.y,g.x);\n        \n        p += .9*t + g*0.3;\n        rz= t;\n\t}\n    \n    return rz;\n}\n//---------------------------------------------------------------\n\nfloat segm(in vec2 p, in vec2 a, in vec2 b) //from iq\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp(dot(pa,ba)/dot(ba,ba), 0., 1.);\n\treturn length(pa - ba*h)*20.*arrow_density;\n}\n\nfloat fieldviz(in vec2 p)\n{\n    vec2 ip = floor(p*arrow_density)/arrow_density + .5/arrow_density;   \n    vec2 t = field(ip);\n    float m = pow(length(t),0.5)*(arrow_length/arrow_density);\n    vec2 b = normalize(t)*m;\n    float rz = segm(p, ip, ip+b);\n    vec2 prp = (vec2(-b.y,b.x));\n    rz = min(rz,segm(p, ip+b, ip+b*0.65+prp*0.3));\n    return clamp(min(rz,segm(p, ip+b, ip+b*0.65-prp*0.3)),0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy-0.5;\n\tp.x *= iResolution.x/iResolution.y;\n    p *= 10.;\n\t\n    vec2 fld = field(p);\n    vec3 col = sin(vec3(-.3,0.1,0.5)+fld.x-fld.y)*0.65+0.35;\n    col = mix(col,vec3(fld.x,-fld.x,fld.y),smoothstep(0.75,1.,sin(time*0.4)))*0.85;\n    float fviz = fieldviz(p);\n    \n    #if 1\n    col = max(col, 1.-fviz*vec3(1.));\n    #else\n    if (dot(luma,col) < 0.5)\n    \tcol = max(col, 1.-fviz*vec3(1.));\n    else\n        col = min(col, fviz*vec3(1.));\n    #endif\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tfSRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[335, 335, 355, 355, 424], [427, 493, 516, 516, 815], [883, 883, 938, 938, 1070], [1072, 1072, 1099, 1099, 1475], [1477, 1477, 1534, 1534, 2052]], "test": "valid"}
{"id": "4tfSRX", "name": "Testcard", "author": "WilstonOreo", "description": "There was no testcard shader yet, so I wrote my own :-)\n\nFont is from FlyGuy:\nhttps://www.shadertoy.com/view/Mt2GWD\n\nCheckboard pattern from iq:\nhttps://www.shadertoy.com/view/4dBSRK\n", "tags": ["2d", "test", "image"], "likes": 15, "viewed": 278, "published": "Public", "date": "1438290692", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst float soft = 0.002;\nconst float PI = 3.14159265358979323846264;\n\nvec3 test_color = vec3(1.0,1.0,1.0);\n\nvec4 ch_spc = vec4(0x000000,0x000000,0x000000,0x000000);\nvec4 ch_exc = vec4(0x003078,0x787830,0x300030,0x300000);\nvec4 ch_quo = vec4(0x006666,0x662400,0x000000,0x000000);\nvec4 ch_hsh = vec4(0x006C6C,0xFE6C6C,0x6CFE6C,0x6C0000);\nvec4 ch_dol = vec4(0x30307C,0xC0C078,0x0C0CF8,0x303000);\nvec4 ch_pct = vec4(0x000000,0xC4CC18,0x3060CC,0x8C0000);\nvec4 ch_amp = vec4(0x0070D8,0xD870FA,0xDECCDC,0x760000);\nvec4 ch_apo = vec4(0x003030,0x306000,0x000000,0x000000);\nvec4 ch_lbr = vec4(0x000C18,0x306060,0x603018,0x0C0000);\nvec4 ch_rbr = vec4(0x006030,0x180C0C,0x0C1830,0x600000);\nvec4 ch_ast = vec4(0x000000,0x663CFF,0x3C6600,0x000000);\nvec4 ch_crs = vec4(0x000000,0x18187E,0x181800,0x000000);\nvec4 ch_com = vec4(0x000000,0x000000,0x000038,0x386000);\nvec4 ch_dsh = vec4(0x000000,0x0000FE,0x000000,0x000000);\nvec4 ch_per = vec4(0x000000,0x000000,0x000038,0x380000);\nvec4 ch_lsl = vec4(0x000002,0x060C18,0x3060C0,0x800000);\nvec4 ch_0 = vec4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000);\nvec4 ch_1 = vec4(0x001030,0xF03030,0x303030,0xFC0000);\nvec4 ch_2 = vec4(0x0078CC,0xCC0C18,0x3060CC,0xFC0000);\nvec4 ch_3 = vec4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000);\nvec4 ch_4 = vec4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000);\nvec4 ch_5 = vec4(0x00FCC0,0xC0C0F8,0x0C0CCC,0x780000);\nvec4 ch_6 = vec4(0x003860,0xC0C0F8,0xCCCCCC,0x780000);\nvec4 ch_7 = vec4(0x00FEC6,0xC6060C,0x183030,0x300000);\nvec4 ch_8 = vec4(0x0078CC,0xCCEC78,0xDCCCCC,0x780000);\nvec4 ch_9 = vec4(0x0078CC,0xCCCC7C,0x181830,0x700000);\nvec4 ch_col = vec4(0x000000,0x383800,0x003838,0x000000);\nvec4 ch_scl = vec4(0x000000,0x383800,0x003838,0x183000);\nvec4 ch_les = vec4(0x000C18,0x3060C0,0x603018,0x0C0000);\nvec4 ch_equ = vec4(0x000000,0x007E00,0x7E0000,0x000000);\nvec4 ch_grt = vec4(0x006030,0x180C06,0x0C1830,0x600000);\nvec4 ch_que = vec4(0x0078CC,0x0C1830,0x300030,0x300000);\nvec4 ch_ats = vec4(0x007CC6,0xC6DEDE,0xDEC0C0,0x7C0000);\nvec4 ch_A = vec4(0x003078,0xCCCCCC,0xFCCCCC,0xCC0000);\nvec4 ch_B = vec4(0x00FC66,0x66667C,0x666666,0xFC0000);\nvec4 ch_C = vec4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000);\nvec4 ch_D = vec4(0x00F86C,0x666666,0x66666C,0xF80000);\nvec4 ch_E = vec4(0x00FE62,0x60647C,0x646062,0xFE0000);\nvec4 ch_F = vec4(0x00FE66,0x62647C,0x646060,0xF00000);\nvec4 ch_G = vec4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000);\nvec4 ch_H = vec4(0x00CCCC,0xCCCCFC,0xCCCCCC,0xCC0000);\nvec4 ch_I = vec4(0x007830,0x303030,0x303030,0x780000);\nvec4 ch_J = vec4(0x001E0C,0x0C0C0C,0xCCCCCC,0x780000);\nvec4 ch_K = vec4(0x00E666,0x6C6C78,0x6C6C66,0xE60000);\nvec4 ch_L = vec4(0x00F060,0x606060,0x626666,0xFE0000);\nvec4 ch_M = vec4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000);\nvec4 ch_N = vec4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000);\nvec4 ch_O = vec4(0x00386C,0xC6C6C6,0xC6C66C,0x380000);\nvec4 ch_P = vec4(0x00FC66,0x66667C,0x606060,0xF00000);\nvec4 ch_Q = vec4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00);\nvec4 ch_R = vec4(0x00FC66,0x66667C,0x6C6666,0xE60000);\nvec4 ch_S = vec4(0x0078CC,0xCCC070,0x18CCCC,0x780000);\nvec4 ch_T = vec4(0x00FCB4,0x303030,0x303030,0x780000);\nvec4 ch_U = vec4(0x00CCCC,0xCCCCCC,0xCCCCCC,0x780000);\nvec4 ch_V = vec4(0x00CCCC,0xCCCCCC,0xCCCC78,0x300000);\nvec4 ch_W = vec4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000);\nvec4 ch_X = vec4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000);\nvec4 ch_Y = vec4(0x00CCCC,0xCCCC78,0x303030,0x780000);\nvec4 ch_Z = vec4(0x00FECE,0x981830,0x6062C6,0xFE0000);\nvec4 ch_lsb = vec4(0x003C30,0x303030,0x303030,0x3C0000);\nvec4 ch_rsl = vec4(0x000080,0xC06030,0x180C06,0x020000);\nvec4 ch_rsb = vec4(0x003C0C,0x0C0C0C,0x0C0C0C,0x3C0000);\nvec4 ch_pow = vec4(0x10386C,0xC60000,0x000000,0x000000);\nvec4 ch_usc = vec4(0x000000,0x000000,0x000000,0x00FF00);\nvec4 ch_a = vec4(0x000000,0x00780C,0x7CCCCC,0x760000);\nvec4 ch_b = vec4(0x00E060,0x607C66,0x666666,0xDC0000);\nvec4 ch_c = vec4(0x000000,0x0078CC,0xC0C0CC,0x780000);\nvec4 ch_d = vec4(0x001C0C,0x0C7CCC,0xCCCCCC,0x760000);\nvec4 ch_e = vec4(0x000000,0x0078CC,0xFCC0CC,0x780000);\nvec4 ch_f = vec4(0x00386C,0x6060F8,0x606060,0xF00000);\nvec4 ch_g = vec4(0x000000,0x0076CC,0xCCCC7C,0x0CCC78);\nvec4 ch_h = vec4(0x00E060,0x606C76,0x666666,0xE60000);\nvec4 ch_i = vec4(0x001818,0x007818,0x181818,0x7E0000);\nvec4 ch_j = vec4(0x000C0C,0x003C0C,0x0C0C0C,0xCCCC78);\nvec4 ch_k = vec4(0x00E060,0x60666C,0x786C66,0xE60000);\nvec4 ch_l = vec4(0x007818,0x181818,0x181818,0x7E0000);\nvec4 ch_m = vec4(0x000000,0x00FCD6,0xD6D6D6,0xC60000);\nvec4 ch_n = vec4(0x000000,0x00F8CC,0xCCCCCC,0xCC0000);\nvec4 ch_o = vec4(0x000000,0x0078CC,0xCCCCCC,0x780000);\nvec4 ch_p = vec4(0x000000,0x00DC66,0x666666,0x7C60F0);\nvec4 ch_q = vec4(0x000000,0x0076CC,0xCCCCCC,0x7C0C1E);\nvec4 ch_r = vec4(0x000000,0x00EC6E,0x766060,0xF00000);\nvec4 ch_s = vec4(0x000000,0x0078CC,0x6018CC,0x780000);\nvec4 ch_t = vec4(0x000020,0x60FC60,0x60606C,0x380000);\nvec4 ch_u = vec4(0x000000,0x00CCCC,0xCCCCCC,0x760000);\nvec4 ch_v = vec4(0x000000,0x00CCCC,0xCCCC78,0x300000);\nvec4 ch_w = vec4(0x000000,0x00C6C6,0xD6D66C,0x6C0000);\nvec4 ch_x = vec4(0x000000,0x00C66C,0x38386C,0xC60000);\nvec4 ch_y = vec4(0x000000,0x006666,0x66663C,0x0C18F0);\nvec4 ch_z = vec4(0x000000,0x00FC8C,0x1860C4,0xFC0000);\nvec4 ch_lpa = vec4(0x001C30,0x3060C0,0x603030,0x1C0000);\nvec4 ch_bar = vec4(0x001818,0x181800,0x181818,0x180000);\nvec4 ch_rpa = vec4(0x00E030,0x30180C,0x183030,0xE00000);\nvec4 ch_tid = vec4(0x0073DA,0xCE0000,0x000000,0x000000);\nvec4 ch_lar = vec4(0x000000,0x10386C,0xC6C6FE,0x000000);\n\n\n\nfloat circle(vec2 pos, float r)\n{\nfloat _distance = length(pos);\nfloat _v = (_distance ) / r;\nreturn 1.0 - smoothstep(1.0 - soft / r,1.0,_v); \n}\n\nfloat checkboard(vec2 pos)\n{ \nfloat id = 0.5 + 0.5*cos(iTime + sin(dot(floor(pos+0.5),vec2(113.1,17.81)))*43758.545);  \nvec2  pa = smoothstep( 0.0, 0.2, id*(0.5 + 0.5*cos(6.2831*pos)) );   \nreturn pa.x * pa.y;\n}\n\n\nfloat grid(vec2 pos)\n{\nfloat width = soft * 35.0;\npos += width * 0.5;\n\nreturn clamp(4.0 * \n    (min(smoothstep(0.0,width, mod(pos.x + 0.5,1.0)),\n    smoothstep(1.0 - width,1.0, mod(1.0 - pos.x - 0.5,1.0))) +\n    min(smoothstep(0.0,width, mod(pos.y + 0.5,1.0)),\n    smoothstep(1.0 - width,1.0, mod(1.0 - pos.y - 0.5,1.0)))),0.0,1.0);\n}\n\nvec3 palette(vec2 pos)\n{\nint index = int(clamp(pos.x*8.0,0.0,8.0));\n\n if (index == 0) return vec3(0.5,0.5,0.5);\n if (index == 1) return vec3(1.0,1.0,0.0);\n if (index == 2) return vec3(0.0,1.0,1.0);\n if (index == 3) return vec3(0.0,1.0,0.0);\n if (index == 4) return vec3(1.0,0.0,1.0);\n if (index == 5) return vec3(1.0,0.0,0.0);\n if (index == 6) return vec3(0.0,0.0,1.0);\n if (index == 7) return vec3(0.0,0.0,0.0);\n    \nreturn vec3(0.0);\n}\n\nvec3 grayscale(vec2 pos, float steps)\n{\nreturn vec3(0.3 + float(int(pos.x * steps)) / steps * float(0.7));\n}\n\nvec3 interference(vec2 pos, float steps)\n{\nfloat freq = pow((float(int(pos.x * steps)) / steps),2.0) * 100.0 * steps * PI;\n\nreturn vec3(0.5)*(1.0 + cos(pos.x * freq));\n}\n\nvec3 hueGradient(float t) {\n  vec3 p = abs(fract(t + vec3(1.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0);\nreturn (clamp(p - 1.0, 0.0, 1.0));\n}\n\nvec3 complementGradient(float t, vec3 color)\n{\nvec3 p = t <= 0.5 ?  \n  mix( vec3(0.0),color,t) :\n  mix( color,1.0 - color,t);\nreturn p; \n}\n\nvec3 complementGradient(vec2 pos)\n{\n  float oneThird = 1.0 / 3.0;\n    \n  if (pos.y <= oneThird) return complementGradient(pos.x,vec3(1.0,0.0,0.0));\n  if (pos.y <= 2.0 * oneThird) return complementGradient(pos.x,vec3(0.0,1.0,0.0));\n  if (pos.y <= 1.0) return complementGradient(pos.x,vec3(0.0,0.0,1.0));\n    \n  return vec3(1.0,1.0,1.0);\n}\n\n\n//Extracts bit b from the given number.\n//Shifts bits right (num / 2^bit) then ANDs the result with 1 (mod(result,2.0)).\nfloat extract_bit(float n, float b)\n{\n  b = clamp(b,-1.0,24.0);\nreturn floor(mod(floor(n / pow(2.0,floor(b))),2.0));   \n}\n\n//Returns the pixel at uv in the given bit-packed sprite.\nfloat sprite(vec4 spr, vec2 size, vec2 uv)\n{\n  uv = floor(uv);\n  \n  //Calculate the bit to extract (x + y * width) (flipped on x-axis)\n  float bit = (size.x-uv.x-1.0) + uv.y * size.x;\n  \n  //Clipping bound to remove garbage outside the sprite's boundaries.\n  bool bounds = all(greaterThanEqual(uv,vec2(0))) && all(lessThan(uv,size));\n  \n  float pixels = 0.0;\n  pixels += extract_bit(spr.x, bit - 72.0);\n  pixels += extract_bit(spr.y, bit - 48.0);\n  pixels += extract_bit(spr.z, bit - 24.0);\n  pixels += extract_bit(spr.w, bit - 00.0);\n  \n  return bounds ? pixels : 0.0;\n}\n\n\n#define CHAR_SIZE vec2(8.0, 12.0)\n#define CHAR_SPACING vec2(8.0, 12.0)\n#define MAX_INT_DIGITS 4\n\nvec2 print_pos = vec2(0.0);\n\n\n//Prints a character and moves the print position forward by 1 character width.\nfloat print_char(vec4 ch, vec2 uv)\n{\n  float px = sprite(ch, CHAR_SIZE, uv - print_pos);\n  print_pos.x += CHAR_SPACING.x;\n  return px;\n}\n\n//Returns the digit sprite for the given number.\nvec4 get_digit(float d)\n{\n  d = floor(d);\n  \n  if(d == 0.0) return ch_0;\n  if(d == 1.0) return ch_1;\n  if(d == 2.0) return ch_2;\n  if(d == 3.0) return ch_3;\n  if(d == 4.0) return ch_4;\n  if(d == 5.0) return ch_5;\n  if(d == 6.0) return ch_6;\n  if(d == 7.0) return ch_7;\n  if(d == 8.0) return ch_8;\n  if(d == 9.0) return ch_9;\n  return vec4(0.0);\n}\n\nfloat print_integer(float number, int zeros, vec2 uv)\n{\n  float result = 0.0;\n  \nfor(int i = MAX_INT_DIGITS;i >= 0;i--)\n  {\n      float digit = mod( number / pow(10.0, float(i)) , 10.0);\n\n      if(abs(number) > pow(10.0, float(i)) || zeros > i  || i == 0) //Clip off leading zeros.\n      {\n        result += print_char(get_digit(digit),uv);\n      }\n  }   \n  return result;\n}\n\n\nvec3 text(vec2 pos) \n{\n\npos *= CHAR_SIZE;\npos.x *= CHAR_SIZE.x * 2.0;\npos.x -= CHAR_SIZE.x*2.0;\npos.y += 12.0; \nfloat col = 0.0;\ncol += print_char(ch_T,pos);\ncol += print_char(ch_e,pos);\ncol += print_char(ch_s,pos);\ncol += print_char(ch_t,pos);\npos.x -= CHAR_SIZE.x*1.0;\ncol += print_char(ch_C,pos);\ncol += print_char(ch_a,pos);\ncol += print_char(ch_r,pos);\ncol += print_char(ch_d,pos);\npos.x -= CHAR_SIZE.x*1.0;\ncol += print_integer(mod(iTime,100.0),2,pos);\nreturn vec3(col);\n}\n\nvec3 testcard(vec2 pos)\n{\nvec2 gridPos = pos* 8.0 - 0.5;\nvec3 g = vec3(grid(gridPos)) + test_color * checkboard(gridPos);\n\nif (abs(gridPos.x + 0.5) <= 5.99)\n{\n  float x = (gridPos.x + 0.5) / 12.0 + 0.5;\n  float y = gridPos.y + 0.5;\n  vec2 v = vec2(x,y);\n  if (y <= 4.99 && y >= 2.01) \n    g = palette(v);\n  if (y <= 1.99 && y >= 0.01) \n    g = grayscale(v,5.0);\n  if (y <= -0.01 && y >= -1.99) \n    g = text(v);\n\n  if (y <= -1.01 && y >= -1.99)\n    g = interference(v,10.0);\n  if (y <= -2.01 && y >= -2.99)\n    g = hueGradient(v.x);\n  if (y <= -3.01 && y >= -4.99) // Red complement \n    g = complementGradient((v + vec2(0.0,5.0))/vec2(1.0,2.0));\n}\n\ng += clamp(circle(pos,10.0 / 12.0) - circle(pos,10.0 / 12.0 - 0.005),0.0,1.0);\n\n\nreturn g;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\nvec2 pos = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    fragColor = vec4(testcard(pos),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tfSRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[5404, 5404, 5437, 5437, 5548], [5550, 5550, 5578, 5578, 5761], [5764, 5764, 5786, 5786, 6098], [6100, 6100, 6124, 6124, 6537], [6539, 6539, 6578, 6578, 6647], [6820, 6820, 6847, 6847, 6956], [6958, 6958, 7004, 7004, 7096], [7098, 7098, 7133, 7133, 7435], [7438, 7559, 7596, 7596, 7680], [7682, 7740, 7784, 7784, 8311], [8441, 8521, 8557, 8557, 8657], [8659, 8708, 8733, 8733, 9054], [9056, 9056, 9111, 9111, 9430], [9433, 9433, 9455, 9455, 9911], [9913, 9913, 9938, 9938, 10655], [10659, 10659, 10716, 10716, 10864]], "test": "valid"}
{"id": "4tfSW7", "name": "The Pole is a Lie", "author": "Vizual", "description": "A simple shadow implementation used to reveal a hidden pole upon which the ball rests. The pole is modeled as an implicit cylinder that lies directly beneath the sphere.", "tags": ["shadows", "cylinder"], "likes": 0, "viewed": 174, "published": "Public", "date": "1436976484", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Light Intensities\nvec3 ia = vec3(0.4,0.4,0.4);\nvec3 id = vec3(1.0,0.9,0.5);\nvec3 is = vec3(1.0,0.9,0.5);\nfloat alpha = 8.0;\n\n// Viewport Resolution\nfloat aspect = iResolution.x / iResolution.y;\nfloat height = 1.0;\nfloat width = aspect;\n\n// Camera and Ground Positions\nvec3 eye = vec3(width/2.0,height/2.0,-3.0);\nfloat ground_z = 1.0;\n\n// Colors\nvec4 sphereColor = vec4(0.9,0.3,0.4,1.0);\n\nbool insideCircle(vec2 P, vec3 center, float rad) \n{\n    float d1 = (P.x - center.x) * (P.x - center.x);\n    float d2 = (P.y - center.y) * (P.y - center.y);\n    return d1 + d2 < rad*rad;\n}\n\nbool intersectsCylinder(vec3 center, float rad, vec3 origin, vec3 dir)\n{\n    vec2 center2D = vec2(center.x,center.y);\n    vec2 origin2D = vec2(origin.x,origin.y);\n    vec2 dir2D = vec2(dir.x,dir.y);\n    \n    vec2 oc = origin2D - center2D;\n    float a = dot(dir2D,dir2D);\n    float b = 2.0 * dot(dir2D,oc);\n    float c = dot(oc,oc) - rad*rad;\n    \n    float det = b*b - 4.0*a*c;\n    if (det < 0.0) {\n        return false;   \n    }\n    else {\n        float t1 = (-b - sqrt(det)) / (2.0*a);\n        float t2 = (-b + sqrt(det)) / (2.0*a);\n        float z1 = origin.z + dir.z*t1;\n        float z2 = origin.z + dir.z*t2;\n        if  (( (z1 < ground_z) && (z1 > 0.0) ) ||\n             ( (z2 < ground_z) && (z2 > 0.0) )) {\n            return true;        \n        }\n        return false;\n    }\n}\n\nbool intersectsSphere(vec3 center, float rad, vec3 origin, vec3 dir)\n{\n    vec3 oc = origin-center;\n    float a = dot(dir,dir);\n    float b = 2.0 * dot(dir,oc);\n    float c = dot(oc,oc) - rad*rad;\n    \n    float det = b*b - 4.0*a*c;\n    return (det >= 0.0) ? true : false;\n}\n\nvec3 getLightPos()\n{\n    float r = 5.0;\n    float t = iTime / 3.0;\n    float x = width/2.0 + 1.5*r*cos(t) / 2.0;\n    float y = height/2.0 + r*sin(t)/2.0;\n    float z = -r;\n    return vec3(x, y, z);\n}\n\nvec4 getSphereColor(vec3 P, vec3 center, float rad)\n{    \n    vec3 N = normalize(P - center);\n    vec3 L1 = normalize(getLightPos() - P);\n    vec3 V = normalize(eye - P);\n    vec3 R = 2.0 * dot(N,L1) * N - L1;\n    \n    vec3 ambient = ia*0.5;\n    vec3 diffuse = dot(N,L1) * id;\n    vec3 specular = pow(max(dot(R,V),0.0),alpha) * is;\n    \n    return vec4(ambient + diffuse + specular, 1.0) * sphereColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x = uv.x * aspect;\n    \n    float rad = 0.15;\n    vec3 center = vec3(width/2.0,height/2.0,0.0);\n    \n    if ( insideCircle(uv, center, rad) )\n    {\n        float z = -sqrt(rad*rad - pow(uv.x - center.x,2.0) - pow(uv.y - center.y,2.0));\n        vec3 point = vec3(uv.x, uv.y, z);\n        fragColor = getSphereColor(point, center, rad);\n    }\n    else {\n        vec3 point = vec3(uv.x,uv.y,ground_z);\n        vec3 dir = normalize(getLightPos() - point);\n        if (    intersectsSphere(center, rad, point, dir) || \n                intersectsCylinder(center, rad/4.0, point, dir) ) {\n            fragColor = texture( iChannel0, uv ) * vec4(ia,1.0);\n        }\n        else {\n            fragColor = texture( iChannel0, uv ) * vec4(ia + id,1.0);\n        }\n    }\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tfSW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[391, 391, 443, 443, 579], [581, 581, 653, 653, 1368], [1370, 1370, 1440, 1440, 1644], [1646, 1646, 1666, 1666, 1845], [1847, 1847, 1900, 1900, 2251], [2253, 2253, 2310, 2310, 3121]], "test": "error"}
{"id": "4tlXDM", "name": "tongues?", "author": "fernlightning", "description": "I broke it, and so decided to make it worse - not quite what I planned...\n\nEvolution of https://www.shadertoy.com/view/XtsSWM\n", "tags": ["warp", "vogel"], "likes": 13, "viewed": 260, "published": "Public", "date": "1437136700", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Based in part on https://www.shadertoy.com/view/XtsSWM\n\n#define A 2.39996322972865332\n#define N 256.0\n#define R 0.1\n#define PI 3.14159265359    \n\nvoid mainImage(out vec4 o, in vec2 i) {\n    vec2 S=iResolution.xy;\n    i = (i+i-S)/S.y;\n    \n    float w = iTime * 4.0;\n    i*=dot(i,i+vec2(cos(w),sin(w))*0.1); //warp\n    \n    float r = max(0.1,length(i)-R);\n    float v = floor(r*r*N-w);\n      \n    float c = 1.;\n    for(float k = 0.; k < 40.; k++) {\n        vec2 p = sqrt((v+w)/N)*cos(v*A+vec2(0., PI/2.))-i;\n        c = min(c, dot(p,p));\n        v++;\n    }\n    \n    float g = max(0.,1.-sqrt(c)/R)*max(0.,1.-r);\n    o = vec4(g, g*g, g*0.3, 1.);\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tlXDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[149, 149, 188, 188, 647]], "test": "valid"}
{"id": "4tlXWH", "name": "Complex function 1", "author": "rioka", "description": "Plotting f(z) = (z^2 Ã¢Ëâ 1)(z Ã¢Ëâ 2 Ã¢Ëâ i)^2 / (z^2 + 2 + 2i). Complex utility functions from https://harrisonclarke.wordpress.com/2010/02/07/fractals-on-the-gpu-glsl/ and http://www.codeproject.com/Articles/492355/Domain-Coloring-Method-on-GPU ", "tags": ["function", "complex", "maths"], "likes": 0, "viewed": 112, "published": "Public", "date": "1436394219", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float c_abs(vec2 z)\n{\n    return sqrt(z.x * z.x + z.y * z.y);\n}\n\nfloat c_arg(vec2 z)\n{\n    return atan(z.y, z.x);\n}\n\nvec2 c_mult(vec2 a, vec2 b) \n{\n    return vec2(a.x * b.x - a.y * b.y, (a.x+a.y)*(b.x+b.y) - a.x*b.x - a.y*b.y);\n}\n\nvec2 c_div(vec2 a, vec2 b)\n{\n    return vec2(((a.x*b.x+a.y*b.y)/(b.x*b.x+b.y*b.y)),((a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 xy = ((fragCoord.xy - (iResolution.xy / 2.0)) / iResolution.xy);\n    vec2 uv = xy * 7.0;\n    vec2 a = c_mult(uv, uv) - vec2(1.0, 0.0);\n    vec2 b = uv - vec2(2.0, 0.0) - vec2(0.0, 1.0);\n    vec2 c = c_mult(uv, uv) + vec2(2.0, 0.0) + vec2(0.0, iTime);\n    vec2 top = c_mult(a, c_mult(b,b));\n    vec2 result = c_div(top, c);\n    fragColor = vec4(vec3(c_arg(result), mod(c_arg(result), 3.0) / 2.0, mod(c_arg(result), 5.0)) / 4.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tlXWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 63], [65, 65, 86, 86, 115], [117, 117, 147, 147, 230], [232, 232, 260, 260, 356], [359, 359, 416, 416, 857]], "test": "valid"}
{"id": "4tsSRj", "name": "No Man's Portal", "author": "mech4rhork", "description": "Portal effect from No Man's Sky: Portal gameplay trailer\nhttps://www.youtube.com/watch?v=WQhSP82uhY4", "tags": ["procedural", "2d", "noise", "lighting", "bump"], "likes": 7, "viewed": 1598, "published": "Public API", "date": "1438299299", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SCALING \t\t1.5\n#define SPEED\t\t\t0.19\n#define PORTAL_COUNT \t3\n#define PORTAL_SIZE\t\t1.6\n//#define\tDIR_LIGHT\n#define\tANIM_LIGHT\n\n// -------------------------------------\n// rotation\n// -------------------------------------\nvec2 rotate( vec2 p, vec2 c, float t ) {\n    vec2 v = p - c;\n    mat2 rot = mat2( cos( t ), -sin( t ), sin( t ), cos( t ) );\n    return v * rot;\n}\n// -------------------------------------\n// swirl tansformation\n// -------------------------------------\nvec2 swirl( vec2 p, vec2 c, float t ) {\n    vec2 v = p - c;\n    float theta = 6.28 * sqrt( dot( v, v ) ) * 1.3;\n    mat2 f = mat2( cos( theta + t ), sin( theta + t ), -sin( theta + t ), cos( theta + t ) );\n    return v * f + c;\n}\n// -------------------------------------\n// from \"Hash without Sine\" by Dave_Hoskins\n// https://www.shadertoy.com/view/4djSRW\n// -------------------------------------\nfloat hash( vec2 p ) {\n\tp  = fract( p * vec2( 0.16632, 0.17369 ) );\n    p += dot( p.xy, p.yx + 19.19 );\n    return fract( p.x * p.y );\n}\n// -------------------------------------\n// from \"Noise - value - 2D\" by iq\n// https://www.shadertoy.com/view/lsf3WH\n// -------------------------------------\nfloat noise( vec2 p ) {\n\tvec2 i = floor( p );\n\tvec2 f = fract( p );\n\t\n\tf = f * f * ( 3.0 - 2.0 * f );\n\t\n\treturn mix(\n\t\tmix( hash( i + vec2( 0.0, 0.0 ) ), hash( i + vec2( 1.0, 0.0 ) ), f.x ),\n\t\tmix( hash( i + vec2( 0.0, 1.0 ) ), hash( i + vec2( 1.0, 1.0 ) ), f.x ),\n\t\tf.y\n\t);\n}\n// -------------------------------------\n// procedural texture ( clouds )\n// -------------------------------------\nvec3 proTex( vec2 p ) {\n    float d = 0.5;\n\tmat2 h = mat2( 1.6, 1.2, -1.2, 1.6 );\n\t\n\tfloat color = 0.0;\n\tfor( int i = 0; i < 3; i++ ) {\n\t\tcolor += d * noise( p * 200.0 );\n\t\tp *= h;\n\t\td /= 2.0;\n\t}\n    \n    return vec3( pow( 0.5 + 0.75 * exp(-color*color), 2.5 ) );\n}\n// -------------------------------------\n// one portal\n// -------------------------------------\nvec4 portal( vec2 p, vec2 c, float s, vec4 t ) {\n    p -= c;\n    vec2 q = p;\n    p.y *= iResolution.y / iResolution.x; // ratio\n    p *= SCALING; // scaling\n    \n    t += c.xyxy * 9.0;\n    \n   \t// transformations\n    p = swirl( p, c, t.z );\n    p = rotate( p, c, 1.57 );\n    \n    float lenSqr = dot( p, p );\n    float len = sqrt( dot( p, p ) );\n    float size = 0.1 * s;\n    \n    float colMask = 1.0 - step( size, len ); // mask\n    vec3 col = proTex( ( p + vec2( t.z, 0.0 ) ) * 0.1 );\n    \n    // vignette (bump)\n    col = mix(\n        col,\n        1. - vec3( 0.5 + 0.75*pow( exp( -lenSqr * lenSqr ), 2048.0 ) ),\n        0.33\n    );\n    \n    // ring\n    if( len > size * 0.95 ) {\n        col = mix( col, vec3( 0.3 ), 1.0 );\n    }\n    \n\treturn vec4( col, colMask );\n}\n// -------------------------------------\n// image with all the portals\n// -------------------------------------\nvec4 getImage( vec2 uv, vec2 c, vec4 t ) {\n    vec4 col = vec4( 0.0 );\n    \n    vec2 centers[PORTAL_COUNT];\n    float size = PORTAL_SIZE;\n    c *= SCALING;\n    \n    for( int i = 0; i < PORTAL_COUNT; i++ ) {\n        centers[i] += vec2( float( i - ( PORTAL_COUNT / 2 ) ), 0.0 );\n        centers[i] *= size / SCALING;\n        vec4 prtl = portal( uv, ( centers[i] + c ) / size * 0.5, size, t );\n        col = mix( col, prtl, prtl.a );\n    }\n    \n\treturn col;\n}\n// -------------------------------------\n// from \"Normal map calculation\" by sergey_reznik\n// https://www.shadertoy.com/view/llS3WD\n// -------------------------------------\nfloat sampleHeight( vec2 coord, vec2 c, vec4 t ) {\n    return 0.046 * dot(\n        getImage( coord, c, t ).xyz,\n        vec3( 1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0 )\n    );\n}\n// -------------------------------------\n// also by sergey_reznik\n// -------------------------------------\nvec3 getNormal( vec2 uv, vec2 c, vec4 t ) {\n\tvec2 du = vec2( 1.0 / 1024.0, 0.0 );\n    vec2 dv = vec2( 0.0, 1.0 / 1024.0 );\n    \n    float hpx = sampleHeight( uv + du, c, t );\n    float hmx = sampleHeight( uv - du, c, t );\n    float hpy = sampleHeight( uv + dv, c, t );\n    float hmy = sampleHeight( uv - dv, c, t );\n    \n    float dHdU = ( hmx - hpx ) / ( 2.0 * du.x );\n    float dHdV = ( hmy - hpy ) / ( 2.0 * dv.y );\n    \n    return vec3( dHdU, dHdV, 1.0 );\n}\n/*\n\t*\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // vignetting\n    float vignette = pow( uv.x * uv.y * ( 1.0 - uv.x ) * ( 1.0 - uv.y ), 0.025 );\n    \n    uv = ( uv * 2.0 ) - 1.0; // for using ( 0.0, 0.0 ) as the center\n    \n    // time\n\tvec4 t = SPEED * ( 0.15 * iTime * vec4( 0.5, 1.5, 6.0, 10.0 ) + vec4( 0.0, 0.0, 0.0, 0.0 ) );\n\n\t// center of scene\n\tvec2 center = vec2( 0.0, -0.25 );\n    \n    // image\n    fragColor.rgb = vec3( 0.149, 0.055, 0.149 ); // background color\n    vec4 image = getImage( uv, center, t );\n    \n    // lighting\n    float atten;\n    vec3 normal = 0.5 + 0.5 * normalize( getNormal( uv, center, t ) );\n    vec3 lightColor = vec3( 1.0, 0.988, 0.925 );\n    vec3 specularColor = vec3( 1.0, 0.996, 0.965 ) * 0.6;\n    vec3 ambient = vec3( 0.22, 0.153, 0.17 );\n    vec3 red = vec3( 0.584, 0.357, 0.510 );\n    \n    #ifdef DIR_LIGHT\n    vec3 lightVec = vec3( 0.67, 1.286, -1.0 ); // light direction\n    atten = 1.0;\n    #else\n    vec3 lightPos = vec3( vec2( -0.34, 1.6 ), -1.2 ); // vec3( -2.8, 3.33, -1.0 ); // light position\n    \n    #ifdef ANIM_LIGHT\n    lightPos *= vec3( 1.0 + 0.067 * cos( t.zw * 3.0 ), 1.0 ); // light position (animated)\n    #endif\n    \n    vec3 lightVec = vec3(\n        ( ( uv - center ) * vec2( 1.0, iResolution.y / iResolution.x ) ).xy * SCALING, 0.0\n    ) - lightPos; // light direction\n    atten = 1.0 / length( lightVec );\n    #endif\n    lightVec = normalize( lightVec );\n    \n    vec3 lighting = atten * lightColor * max( 0.0, dot( lightVec, normal ) );\n    lighting = mix( vec3( 0.0 ), vec3( lighting ), image.a );\n    lighting += vec3( 0.125 );\n    \n    // specular lighting\n    vec3 eyeVec = normalize( vec3( 1.77, 0.0, 1.0 ) ); // camera direction\n    vec3 specular = atten * specularColor * vec3( pow( max( 0.0, dot( reflect( -lightVec, normal ), eyeVec ) ), 0.44 ) );\n    \n    // ### TEST : red ambien lighting\n    vec3 redLightPos = vec3( vec2( -0.34, -2.2 ), -1.0 );\n    vec3 redLightVec = vec3( ( ( uv - center ) * vec2( 1.0, iResolution.y / iResolution.x ) ).xy * SCALING, 0.0 ) - redLightPos;\n    atten = 1.0 / length( redLightVec );\n    vec3 redLighting = atten * red * max( 0.0, dot( redLightVec, normal ) );\n    // ENDTEST ###\n    \n    fragColor = mix(\n        fragColor,\n        image * vec4( lighting + specular, 1.0 ) + vec4( vec3( ambient * redLighting ), 0.0 ),\n        image.a\n    );\n    fragColor *= vignette;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tsSRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[132, 226, 266, 266, 372], [373, 478, 517, 517, 707], [708, 875, 897, 897, 1011], [1012, 1170, 1193, 1193, 1446], [1447, 1562, 1585, 1585, 1827], [1828, 1924, 1972, 1972, 2691], [2692, 2804, 2846, 2846, 3260], [3261, 3434, 3484, 3484, 3602], [3603, 3710, 3753, 3753, 4171], [4172, 4181, 4238, 4238, 6624]], "test": "valid"}
{"id": "4tsSzS", "name": "squid - Forest", "author": "squid", "description": "Only one loop in map()! Unfortunately also very broken. Suggestions?", "tags": ["3d"], "likes": 3, "viewed": 1374, "published": "Public API", "date": "1437696271", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ITERATIONS 4\n// *** Change these to suit your range of random numbers..\n// This current set suits the UV coords of the screen and up..\n#define MOD2 vec2(443.8975,397.2973)\n#define MOD3 vec3(443.8975,397.2973, 491.1871)\n#define MOD4 vec4(443.8975,397.2973, 491.1871, 470.7827)\n\n// *** Use these for integer ranges, ie Value-Noise/Perlin functions.\n//#define MOD2 vec2(.16632,.17369)\n//#define MOD3 vec3(.16532,.17369,.15787)\n//#define MOD4 vec4(.16532,.17369,.15787, .14987)\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n\tvec2 p2 = fract(vec2(p) * MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tp  = fract(p * MOD2);\n    p += dot(p.xy, p.yx+19.19);\n    return fract(p.x * p.y);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p)\n{\n\tp  = fract(p * MOD3);\n    p += dot(p.xyz, p.yzx + 19.19);\n    return fract(p.x * p.y * p.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\t//p  = fract(p * MOD3);\n    vec3 p3 = fract(vec3(p) * MOD3);\n    p3 += dot(p3.xyz, p3.yzx + 19.19);\n   return fract(vec2(p3.x * p3.y, p3.z*p3.x));\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3.zxy, p3.yxz+19.19);\n    return fract(vec2(p3.x * p3.y, p3.z*p3.x));\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * MOD3);\n   p3 += dot(p3.xyz, p3.yzx + 19.19);\n   return fract(vec3(p3.x * p3.y, p3.x*p3.z, p3.y*p3.z));\n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3.zxy, p3.yxz+19.19);\n    return fract(vec3(p3.x * p3.y, p3.x*p3.z, p3.y*p3.z));\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p)\n{\n\tp = fract(p * MOD3);\n    p += dot(p.zxy, p+19.19);\n    return fract(vec3(p.x * p.y, p.x*p.z, p.y*p.z));\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * MOD4);\n    p4 += dot(p4.wzxy, p4+19.19);\n    return fract(vec4(p4.x * p4.y, p4.x*p4.z, p4.y*p4.w, p4.x*p4.w));\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * MOD4);\n    p4 += dot(p4.wzxy, p4+19.19);\n    return fract(vec4(p4.x * p4.y, p4.x*p4.z, p4.y*p4.w, p4.x*p4.w));\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx) * MOD4);\n    p4 += dot(p4.wzxy, p4+19.19);\n    return fract(vec4(p4.x * p4.y, p4.x*p4.z, p4.y*p4.w, p4.x*p4.w));\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p)\n{\n\tvec4 p4 = fract(p * MOD4);\n    p4 += dot(p4.wzxy, p4+19.19);\n    return fract(vec4(p4.x * p4.y, p4.x*p4.z, p4.y*p4.w, p4.x*p4.w));\n}\n\n//###############################################################################\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nvec2 U( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n#define mat_tree_bark 1.0\n\nmat3 rotateY(float r)\n{\n    vec2 cs = vec2(cos(r), sin(r));\n    return mat3(cs.x, 0, cs.y, 0, 1, 0, -cs.y, 0, cs.x);\n}\n\nmat3 rotateZ(float r)\n{\n    vec2 cs = vec2(cos(r), sin(r));\n    return mat3(cs.x, cs.y, 0., -cs.y, cs.x, 0., 0., 0., 1.);\n}\n\nvec2 tree(in vec3 p, in vec2 id) {\n    vec4 h = hash42(vec2(id));\n    float height = 5.+h.x*12.;\n\tvec2 r = vec2(sdCylinder(p-vec3(0.,height,0.), vec2(.6+h.x*.5,height)), \n                mat_tree_bark);\n    \n    vec3 np = p; float lh = height*2.;\n    if(np.y > lh) return r;\n    for(int i = 0; i < 2; ++i) {\n    \tfloat bh = mod(np.y, 2.)-1.;\n        vec4 bhs = hash41(floor(np.y/2.)+h.y*30.);\n        vec3 v = vec3(np.x,np.z,bh)*rotateZ((bhs.y)*12.28)+\n                              vec3(0.,(3.*(bhs.x>0.5?1.:-1.)),0.);\n        r = U(r, \n              vec2(sdCylinder(v, vec2(0.2-float(i)*0.08, 3.)), mat_tree_bark ));\n        np = v;\n    }\n    return r;\n}\n\nvec2 map(in vec3 p) {\n\tvec2 tp = mod(p.xz, vec2(20.))-vec2(10.);\n    return U(\n\t\tvec2(p.y, 0.1), \n        tree(vec3(tp.x, p.y, tp.y), ceil(p.xz/20.-10.) )\n    );\n}\n\nvec2 nrm(in vec3 ro, in vec3 rd) {\n\tfloat tmin = .01;\n    float tmax = 200.0;\n    \n\tfloat precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<60; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\nvec3 norm(in vec3 pos) {\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 matcol(in float id) {\n\tif(id == mat_tree_bark) return vec3(0.3, 0.2, 0.);\n    else return vec3(0.2, 0.1, 0.);\n}\n\nvec3 shade(in vec3 ro, in vec3 rd, in vec2 nh) {\n\tvec3 p = ro+rd*nh.x;\n    vec3 n = norm(p);\n    vec3 l = normalize(vec3(.5, .7, 0.));\n    return dot(n, l)*matcol(nh.y)*\n        softshadow(p, l, 0.1, 5.);\n}\n\nvec3 render(in vec3 ro, in vec3 rd) {\n\tvec2 nh = nrm(ro, rd);\n    return nh.y > -1. ? shade(ro, rd, nh) : vec3(0.);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n\n\t// camera\t\n    float z = 60.;\n\tvec3 ro = vec3( z*cos(0.1*time + 6.0*mo.x), z*.2 + z*mo.y, z*sin(0.1*time + 6.0*mo.x) );\n\tvec3 ta = vec3( 0. );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.5) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n\tcol = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tsSzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[483, 593, 616, 616, 715], [717, 827, 849, 849, 935], [937, 1047, 1069, 1069, 1165], [1167, 1277, 1299, 1324, 1449], [1451, 1562, 1583, 1583, 1708], [1710, 1820, 1842, 1842, 1976], [1979, 2090, 2111, 2111, 2247], [2249, 2360, 2381, 2381, 2488], [2490, 2599, 2621, 2621, 2761], [2763, 2872, 2893, 2893, 3038], [3040, 3149, 3170, 3170, 3315], [3317, 3426, 3447, 3447, 3581], [3666, 3666, 3702, 3702, 3801], [3802, 3802, 3830, 3830, 3863], [3892, 3892, 3915, 3915, 4010], [4012, 4012, 4035, 4035, 4135], [4137, 4137, 4171, 4171, 4793], [4795, 4795, 4816, 4816, 4958], [4960, 4960, 4994, 4994, 5312], [5314, 5314, 5338, 5338, 5559], [5560, 5560, 5587, 5587, 5765], [5766, 5766, 5840, 5840, 6101], [6103, 6103, 6129, 6129, 6219], [6221, 6221, 6269, 6269, 6427], [6429, 6429, 6466, 6466, 6546], [6548, 6548, 6600, 6600, 6777], [6779, 6779, 6836, 6836, 7420]], "test": "valid"}
{"id": "4tsXDH", "name": "Swirl (Anastadunbar)", "author": "anastadunbar", "description": "Thank you guys for learning me GLSL.", "tags": ["2d", "swirl", "illusion", "trippy", "dizzy"], "likes": 2, "viewed": 248, "published": "Public", "date": "1436450423", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float pi = 3.1415926535897932384626433832795028841;\n\nfloat sin1(float val) {\n\treturn ((sin((val*2.)-1.5)/2.)+0.5);\n}\n\nfloat strobes(float val) {\n\t//return step(0.5,fract(val*8.));\n\treturn pow(sin1(val*pi*8.),10.)*6000.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float ourtime = iTime;\n\tvec2 position = ( gl_FragCoord.xy / iResolution.xy );\n\tvec2 uv = vec2(position.x,((position.y-0.5)*(iResolution.y/iResolution.x))+0.5);\n\tfloat length1 = length(uv-0.5);\n\tfloat atan2 = (atan(uv.x-0.5,uv.y-0.5)+pi)/(pi*2.);\n\tfloat circle1 = clamp((length1-0.15)*900.,0.,1.);\n    //float swirl = clamp(strobes((1.-length(abs(uv-0.5)-50.))*5.+(ourtime/1.5)),0.,1.); //Want neave.com version?\n\tfloat swirl = clamp(strobes(atan2+(length1*5.)+(ourtime/1.5)),0.,1.);\n\tfloat swirla2 = (1.-length(abs(uv-0.5)-50.))*5.;\n\tfloat swirl2 = clamp(strobes(swirla2-ourtime),0.,1.);\n\tfloat outputs = mix(swirl,swirl2,circle1);\n\tfragColor = vec4(vec3(outputs), 1.0 );\n}\n\n/*\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\nfloat pi = 3.1415926535897932384626433832795028841;\n\nfloat sin1(float val) {\n\treturn ((sin((val*2.)-1.5)/2.)+0.5);\n}\n\nfloat strobes(float val) {\n\t//return step(0.5,fract(val*8.));\n\treturn pow(sin1(val*pi*8.),10.)*6000.;\n}\n\nvoid main( void ) {\n\tfloat ourtime = (time);\n\tvec2 position = ( gl_FragCoord.xy / resolution.xy );\n\tvec2 uv = vec2(position.x,((position.y-0.5)*(resolution.y/resolution.x))+0.5);\n\tfloat length1 = length(uv-0.5);\n\tfloat atan2 = (atan(uv.x-0.5,uv.y-0.5)+pi)/(pi*2.);\n\tfloat circle1 = clamp((length1-0.15)*900.,0.,1.);\n\tfloat swirl = clamp(strobes(atan2+(length1*7.)+(ourtime/4.)),0.,1.);\n\tfloat swirla2 = (1.-length(abs(uv-0.5)-50.))*5.;\n\tfloat swirl2 = clamp(strobes(swirla2-ourtime),0.,1.);\n\tfloat outputs = mix(swirl,swirl2,circle1);\n\tgl_FragColor = vec4(vec3(outputs), 1.0 );\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tsXDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 76, 76, 116], [118, 118, 144, 179, 221], [223, 223, 280, 280, 958]], "test": "valid"}
{"id": "4tsXRS", "name": "SolarWind", "author": "tholzer", "description": "nuclear fire burns...", "tags": ["burn", "sun", "fire", "sphere", "lightning", "solar", "wind"], "likes": 20, "viewed": 1105, "published": "Public", "date": "1437575656", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//--------------------------------------------------------------------\n// Shader : SolarWind = PhyroclasticFireball + Burn\n//          nuclear fire burns...  by tHolzer\n// Tags   : solar, wind, sun, burn, sphere, lightning, fire\n//--------------------------------------------------------------------\n\t\n//uniform float time;\n//uniform vec2 mouse;\n//uniform vec2 resolution;\n\n#define time iTime\n#define mouse iMouse\n#define resolution iResolution\n\n//--------------------------------------------------------------------\n// Shader      : PhyroclasticFireball \n// see also    : https://www.shadertoy.com/view/MtXSzS\n// port from   : http://glslsandbox.com/e#8625.0 by Duke \n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//--------------------------------------------------------------------\n\n#define saturate(oo) clamp(oo, 0.0, 1.0)\n\n// Quality Settings\n#define MarchSteps 4\n\n// Scene Settings\n#define ExpPosition vec3(0.0)\n#define Radius 2.0\n#define Background vec3(0.1, 0.0, 0.0)\n\n// Noise Settings\n#define NoiseSteps 1\n#define NoiseAmplitude 0.06\n#define NoiseFrequency 4.0\n#define Animation vec3(0.0, -3.0, 0.5)\n\n// Colour Gradient\n#define Color1 vec3(1.0, 1.0, 1.0)\n#define Color2 vec3(1.0, 0.8, 0.2)\n#define Color3 vec3(1.0, 0.03, 0.0)\n#define Color4 vec3(0.05, 0.02, 0.0)\n\n// help functions\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\n\nvec4 taylorInvSqrt(vec4 r){ return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v)\n{\n\tconst vec2  C = vec2(1.0/6.0, 1.0/3.0);\n\tconst vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n \n\t// First corner\n\tvec3 i  = floor(v + dot(v, C.yyy));\n\tvec3 x0 = v - i + dot(i, C.xxx);\n \n\t// Other corners\n\tvec3 g = step(x0.yzx, x0.xyz);\n\tvec3 l = 1.0 - g;\n\tvec3 i1 = min(g.xyz, l.zxy);\n\tvec3 i2 = max(g.xyz, l.zxy);\n\tvec3 x1 = x0 - i1 + C.xxx;\n\tvec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n\tvec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n \n\t// Permutations\n\ti = mod289(i);\n\tvec4 p = permute( permute( permute( i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n \n\t// Gradients: 7x7 points over a square, mapped onto an octahedron.\n\t// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n\tfloat n_ = 0.142857142857; // 1.0/7.0\n\tvec3  ns = n_ * D.wyz - D.xzx;\n\tvec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n \n\tvec4 x_ = floor(j * ns.z);\n\tvec4 y_ = floor(j - 7.0 * x_);    // mod(j,N)\n \n\tvec4 x = x_ *ns.x + ns.yyyy;\n\tvec4 y = y_ *ns.x + ns.yyyy;\n \n\tvec4 h = 1.0 - abs(x) - abs(y);\n\tvec4 b0 = vec4(x.xy, y.xy);\n\tvec4 b1 = vec4(x.zw, y.zw);\n \n\tvec4 s0 = floor(b0) * 2.0 + 1.0;\n\tvec4 s1 = floor(b1) * 2.0 + 1.0;\n\tvec4 sh = -step(h, vec4(0.0));\n \n\tvec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n\tvec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n \n\tvec3 p0 = vec3(a0.xy, h.x);\n\tvec3 p1 = vec3(a0.zw, h.y);\n\tvec3 p2 = vec3(a1.xy, h.z);\n\tvec3 p3 = vec3(a1.zw, h.w);\n \n\t//Normalise gradients\n\tvec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n \n\tp0 *= norm.x;\n\tp1 *= norm.y;\n\tp2 *= norm.z;\n\tp3 *= norm.w;\n\n\t// Mix final noise value\n\tvec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n\tm = m * m;\n \n\treturn 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat Turbulence(vec3 position, float minFreq, float maxFreq, float qWidth)\n{\n\tfloat value = 0.0;\n\tfloat cutoff = clamp(0.5/qWidth, 0.0, maxFreq);\n\tfloat fade;\n\tfloat fOut = minFreq;\n \n\tfor(int i=NoiseSteps ; i>=0 ; i--)\n\t{\n\t\tif(fOut >= 0.5 * cutoff) break;\n\t\tfOut *= 2.0;\n\t\tvalue += abs(snoise(position * fOut))/fOut;\n\t}\n\tfade = clamp(2.0 * (cutoff-fOut)/cutoff, 0.0, 1.0);\n\treturn 1.0 - value - fade * abs(snoise(position * fOut)) / fOut;\n}\n\nfloat SphereDist(vec3 position)\n{\n\treturn length(position - ExpPosition) - Radius;\n}\n \nvec3 Shade(float distance)\n{\n\tfloat c1 = saturate(distance*5.0 + 0.5);\n\tfloat c2 = saturate(distance*5.0);\n\tfloat c3 = saturate(distance*3.4 - 0.5);\n\n\tvec3 a = mix(Color1,Color2, c1);\n\tvec3 b = mix(a,     Color3, c2);\n\treturn \t mix(b,     Color4, c3);\n}\n\n// Draws the scene\nfloat RenderScene(vec3 position, out float distance)\n{\n\tfloat noise = Turbulence(position * NoiseFrequency + Animation*time*0.4, 0.1, 1.5, 0.03) * NoiseAmplitude;\n\tnoise = saturate(abs(noise));\n\tdistance = SphereDist(position) - noise;\n\treturn noise;\n}\n\n// Basic ray marching method.\nvec3 March(vec3 rayOrigin, vec3 rayStep)\n{\n\tvec3 position = rayOrigin;\n\tfloat distance;\n\tfloat displacement;\n\tfor(int step = MarchSteps; step >=0  ; --step)\n\t{\n\t\tdisplacement = RenderScene(position, distance);\n\t\tif(distance < 0.05) break;\n\t\tposition += rayStep * distance;\n\t}\n\treturn mix(Shade(displacement), Background, float(distance >= 0.5));\n}\n\n// check sphrer hit\nbool IntersectSphere(vec3 ro, vec3 rd, vec3 pos, float radius, out vec3 intersectPoint)\n{\n\tvec3 relDistance = (ro - pos);\n\tfloat b = dot(relDistance, rd);\n\tfloat c = dot(relDistance, relDistance) - radius*radius;\n\tfloat d = b*b - c;\n\tintersectPoint = ro + rd*(-b - sqrt(d));\n\treturn d >= 0.0;\n}\n\nvec3 fireball(vec2 p)\n{\n\tfloat rotx = mouse.y * 0.01;\n\tfloat roty = mouse.x * 0.01;\n\tfloat zoom = 10.0;\n\n\t// camera\n\tvec3 ro = zoom * normalize(vec3(cos(roty), cos(rotx), sin(roty)));\n\tvec3 ww = normalize(vec3(0.0, 0.0, 0.0) - ro);\n\tvec3 uu = normalize(cross( vec3(0.0, 1.0, 0.0), ww));\n\tvec3 vv = normalize(cross(ww, uu));\n\tvec3 rd = normalize(p.x*uu + p.y*vv + 1.5*ww);\n\n\tvec3 col = Background;\n\tvec3 origin;\n\t\n\tif(IntersectSphere(ro, rd, ExpPosition, Radius + NoiseAmplitude*6.0, origin))\n\t{\n\t\tcol = March(origin, rd);\n\t}\n\treturn col;\n}\n\n//--------------------------------------------------------------------\n// Shader: burn\n// Yuldashev Mahmud Effect took from shaderToy mahmud9935@gmail.com\n// original:  http://glslsandbox.com/e#26733.0\n//--------------------------------------------------------------------\nfloat snoise(vec3 uv, float res)\n{\n\tconst vec3 s = vec3(1e0, 1e2, 1e3);\n\tuv *= res;\n\tvec3 uv0 = floor(mod(uv, res))*s;\n\tvec3 uv1 = floor(mod(uv+vec3(1.), res))*s;\n\tvec3 f = fract(uv); \n\tf = f*f*(3.0-2.0*f);\n\tvec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,\n\t              uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);\n\tvec4 r = fract(sin(v*1e-1)*1e3);\n\tfloat r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\tr = fract(sin((v + uv1.z - uv0.z)*1e-1)*1e3);\n\tfloat r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\treturn mix(r0, r1, f.z)*2.-1.;\n}\n\nvec3 burn (vec2 p) \n{\n\tfloat color1 = 4.0 - (3.*length(2.5*p));\n\tvec3 coord = vec3(atan(p.x,p.y)/6.2832+.5, length(p)*.4, .5);\n\tfor(int i = 1; i <= 3; i++)\n\t{\n\t\tfloat power = pow(2.0, float(i));\n\t\tcolor1 += 0.5*(1.5 / power) * snoise(coord + vec3(0.,-time*.05, -time*.01), power*16.);\n\t}\n\tcolor1 *= 0.6;\n\treturn vec3( color1, pow(max(color1,0.),2.)*0.4, pow(max(color1,0.),3.)*0.15);\n}\n\n//--------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 p = (fragCoord.xy / resolution.xy) - 0.5;\n  p.x *= resolution.x / resolution.y;\n  vec3 color1 = fireball(p);\n  vec3 color2 = burn(p);\n  fragColor = vec4( mix(color1, color2, 0.7), 1.0);\n}\n", "image_inputs": [{"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tsXRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1612, 1612, 1633, 1633, 1680], [1682, 1682, 1703, 1703, 1750], [1752, 1752, 1774, 1774, 1809], [1811, 1811, 1838, 1838, 1888], [1890, 1890, 1912, 1912, 3717], [3719, 3719, 3796, 3796, 4161], [4163, 4163, 4196, 4196, 4247], [4250, 4250, 4278, 4278, 4503], [4505, 4524, 4578, 4578, 4776], [4778, 4808, 4850, 4850, 5155], [5157, 5177, 5266, 5266, 5471], [5473, 5473, 5496, 5496, 6012], [6014, 6287, 6321, 6321, 6839], [6841, 6841, 6862, 6862, 7226], [7228, 7299, 7356, 7356, 7551]], "test": "valid"}
{"id": "4tXSD4", "name": "Function Grapher", "author": "djmkultra", "description": "Plots 1D and 2D scalar functions.\n z key toggles mouse zooming\n x key toggles mouse pan\n 1,2,3 keys zoom out by factors of 2 each", "tags": ["2d", "3d", "math", "curves", "plot"], "likes": 12, "viewed": 267, "published": "Public", "date": "1436668219", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Enable 1D function f(x)\n#define FX 1\n// Optional vis of implict function\n#define FXDISTANCE 1\n// Enable 2D function f(x,y)\n#define FXY 1\n// Demo mode, shows different modes.\n#define DEMO 1\n\nconst float kDomainScale = 5.5;  // Scale default domain (1px = 1unit). Zoom in/out.\nconst vec2 kOriginShift = vec2(.5, .5);  // Position of origin relative to domain bounds.\n\nconst float kTemporalScale = .25;\n\nconst float kLineWidth = 2.;\nconst float kInvLineWidth = 1. / kLineWidth;\nconst vec4 kLineColor = vec4(.9, .8, .1, 1.);\n\nconst vec4 kPosColor = vec4(.9, .05, .05, 1.);\nconst vec4 kNegColor = vec4(.05, .05, .9, 1.);\n\nconst float kToneExposure = .8; // Make 2D plot brighter/darker\n\nconst float kGridSpacing = 100.0;\nconst float kTickSpacing = 5.0;  // dash/space width\nconst float kGridOpacity = .6;\nconst vec4 kGridColor = vec4(.5, .5, .5, 1.) * kGridOpacity;\nconst vec4 kAxesColor = vec4(.5, .1, .1, 1.) * kGridOpacity;\nconst float kGridLineWidth = 1.;\n\nconst float kRootJitterScale = .9;  // percent of visible domain to jitter roots.\nconst float kCoefJitterScale = .01; \n\nconst float kPrime1 = 991.;\nconst float kPrime2 = 661.;\nconst float kInvPrime2 = 1. / kPrime2;\n// handy for animating functions.\nvec4 Randf(vec4 seed) {\n \treturn mod(seed * kPrime1, vec4(kPrime2)) * kInvPrime2;   \n}\nvec4 TimeSins(float seed) {\n \tvec4 phase = Randf(vec4(1., 3., 5., 7.) * seed) * 1000.;  // big phase rand\n    vec4 freq = vec4(1.) + Randf(vec4(2., 4., 6., 8.) * seed) * .2; // small freq rand\n    return sin(freq + phase + iTime * kTemporalScale);\n}\n\n//------------------------------------------------------\n// Define a 1D function here.\n\nfloat Fx(float x) {\n    float rootJitter = kRootJitterScale * iResolution.x;\n    float coefsJitter = kCoefJitterScale / iResolution.x * 600.;\n    // This is a 7th order polynomical with wandering roots.\n    vec4 roots = TimeSins(1.) * rootJitter;  \n    vec4 coefs = TimeSins(2.) * coefsJitter;\n \troots = (roots + vec4(x)) * coefs;\n    vec4 roots2 = TimeSins(3.) * rootJitter;\n    vec4 coefs2 = TimeSins(4.) * coefsJitter;\n    roots2 = (roots2 + vec4(vec3(x), 1.)) * coefs2;\n    return roots.x * roots.y * roots.z * roots.w * roots2.x * roots2.y * roots2.z * roots2.w;\n}\n\n//------------------------------------------------------\n// Define a 2D function here.\n\nfloat Fxy(float x, float y) {\n    \n \tvec4 rands = TimeSins(3.) * vec4(vec2(kRootJitterScale), 1., 1.);\n    float d = distance(vec2(x,y), vec2(rands.xy + vec2(-rands.z * 100., rands.w * 100.)));\n    float d2 = distance(vec2(x,y), vec2(rands.yx + vec2(rands.z - rands.w, rands.z * rands.w) * 131.));\n    d *= .05;\n    d2 *= .1;\n    float dd = .81 / (d * d + 1.) + 2. / (d2 * d2 + 1.);\n    float decay = dd;\n    d = 1. / dd ;\n    float wave = 25. * sin(d * .051 - iTime * 2.333) + \n        29. * sin(d * .27 - iTime * 5.55 + (.2 + d * .00015));\n    return wave * decay * 4.;\n}\n\nvec4 Blend(vec4 colorUnder, vec4 colorOver) {\n \tfloat compAlpha = 1. - colorOver.a;\n    vec4 color = colorUnder * compAlpha + colorOver;\n\treturn color;\n}\n\n// Linear ramp from minval to maxval\nvec2 RampAt(vec2 x, vec2 minval, vec2 maxval) {\n\tvec2 ramp = (x - minval) / (maxval - minval);\n    return clamp(ramp, vec2(0.), vec2(1.));\n}\n\n// The Grid\nvec4 GetGridColor(vec2 pos, float scale) {\n    float order = floor(log(scale));\n    float gridScale = exp(order);\n    float gridSpacing = kGridSpacing * gridScale;\n    vec2 lineWidth = vec2(kGridLineWidth * scale);\n    float tickSpace = kTickSpacing;\n    vec2 dashMask = mod(pos.yx, vec2(tickSpace * 2.));\n    dashMask = min(RampAt(dashMask, vec2(0.), vec2(scale)), \n                   RampAt(dashMask, vec2(tickSpace + scale), vec2(tickSpace)));\n    float dashBlend = (tickSpace - 2.5 * scale);  // don't draw tick marks if they get too small\n    dashBlend = clamp(dashBlend, 0., 1.);\n    dashMask = dashBlend * dashMask + (1. - dashBlend) * vec2(1.);\n    vec2 lined = mod(pos + vec2(scale), vec2(gridSpacing));\n \tvec2 lines = min(RampAt(lined, vec2(0.), vec2(scale)), RampAt(lined, lineWidth + vec2(scale), lineWidth));\n    lines *= dashMask;\n    vec4 color = kGridColor * max(lines.x, lines.y);\n    vec2 axesd = RampAt(abs(pos) * 2., lineWidth + vec2(scale), lineWidth);\n    vec2 axess = axesd * dashMask;\n    color = Blend(color, kAxesColor * max(axess.x, axess.y));\n    return color;\n}\n\nfloat Implicit1DFunctionDistance(vec2 pos, float fxvalue) {\n \tfloat diff = pos.y - fxvalue;\n    return diff / length(vec2(dFdx(diff), dFdy(diff)));  // divide by grad-mag to get exact distance from 0\n}\n\nvec4 ColorScalarFunction(vec2 pos, float fxyvalue) {\n \tvec4 color = max(fxyvalue, 0.) * kPosColor - min(fxyvalue, 0.) * kNegColor;\n    color *= kToneExposure;\n    color = color / (vec4(1.) + color); // Tone map color\n    return color;\n}\n\nvec4 Plot1DFunction(vec2 pos, float fxvalue) {\n \tfloat d = abs(Implicit1DFunctionDistance(pos, fxvalue));\n    return kLineColor * smoothstep(kLineWidth, 0., d);\n}\n\n// key is javascript keycode: http://www.webonweboff.com/tips/js/event_key_codes.aspx\nbool ReadKey( int key, bool toggle )\n{\n\tfloat keyVal = texture( iChannel0, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 origin = iResolution.xy * kOriginShift;\n\tvec2 mousePos = iMouse.xy - origin;\n    \n    // 1, 2, 3 each zoom by a factor of 2\n    bool one = ReadKey( 49, true );\n    bool two = ReadKey( 50, true );\n    bool three = ReadKey( 51, true );\n    \n    // z key toggles zoom.\n    bool z = ReadKey( 90, true );\n    // x key toggles pan.\n    bool x = ReadKey( 88, true );\n    \n    float userZoom = one ? 2. : 1.;\n    userZoom *= two ? 2. : 1.;\n    userZoom *= three ? 2. : 1.;\n    \n    float mouseZoom = mousePos.y > 0. ? 1. + mousePos.y * .01 : 1. / (1. - mousePos.y * .01);\n    float zoom = kDomainScale * userZoom * (z ? mouseZoom : 1.);\n    // position in plot domain\n    vec2 pos = zoom * (fragCoord.xy - origin - mousePos * (x ? 1. : 0.));\n    \n    // Start with background.\n\tfragColor = GetGridColor(pos, zoom);\n    \n#if DEMO\n    // blends between modes.\n    float slice = 25. / 3.;\n    float t = mod(iTime + slice, slice * 3.);\n    vec2 fxalpha = min(RampAt(vec2(t), vec2(0., slice), vec2(1., slice + 1.)), \n                        RampAt(vec2(t), vec2(slice * 2., slice * 2.), vec2(slice * 2. - 1., slice * 2. - 1.)));\n\tfloat fxyalpha = 1. - fxalpha.x;\n#else \n    vec2 fxalpha = vec2(1.);\n    float fxyalpha = 1.;\n#endif\n    \n    \n#if FX\n    // Plot a 1D funciton of x\n    float fx = Fx(pos.x);\n    // Blend plot of 1D function over the grid.\n    fragColor = Blend(fragColor, Plot1DFunction(pos, fx) * fxalpha.x);\n#if FXDISTANCE\n    // Optionally visualize the implicit function used to make line.\n\tfragColor = Blend(ColorScalarFunction(pos, Implicit1DFunctionDistance(pos, fx)) * fxalpha.y, fragColor);\n#endif\n#endif\n\n#if FXY\n    // Plot a 2D function of x and y\n    float fxy = Fxy(pos.x, pos.y);\n    fragColor = Blend(ColorScalarFunction(pos, fxy) * fxyalpha, fragColor);\n#endif\n    \n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tXSD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1174, 1208, 1231, 1231, 1294], [1295, 1295, 1322, 1322, 1544], [1634, 1634, 1653, 1653, 2203], [2293, 2293, 2322, 2322, 2866], [2868, 2868, 2913, 2913, 3021], [3023, 3060, 3107, 3107, 3200], [3202, 3214, 3256, 3256, 4304], [4306, 4306, 4365, 4365, 4507], [4509, 4509, 4561, 4561, 4745], [4747, 4747, 4793, 4793, 4909], [5158, 5158, 5215, 5215, 7010]], "test": "error"}
{"id": "4tXSRj", "name": "trianglesTT2", "author": "motte", "description": "triangles", "tags": ["triangles"], "likes": 3, "viewed": 128, "published": "Public", "date": "1437984658", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define PI_HALF 1.5707963267\n\nfloat signf (vec2 p1, vec2 p2, vec2 p3)\n{\n    return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);\n}\n\nbool PointInTriangle (vec2 pt, vec2 v1, vec2 v2, vec2 v3)\n{\n    bool b1, b2, b3;\n    b1 = signf(pt, v1, v2) < 0.0;\n    b2 = signf(pt, v2, v3) < 0.0;\n    b3 = signf(pt, v3, v1) < 0.0;\n    return ((b1 == b2) && (b2 == b3));\n}\n\nvec2 getTriPoint(float shift)\n{\n    float t = mod(iTime*0.1 + shift, PI_HALF);    \n    float x = pow(sin(t), 0.22);\n    float y = pow(cos(t), 2.0) ;    \n    \n    return vec2(x * 0.5, y);\n}\n\n\nfloat calc1tri(float c, vec2 uv, int i, float ydecal)\n{\n    vec2 p = getTriPoint(float(i)*0.9);\n    vec2 left = vec2(-p.x+0.5, p.y-ydecal);\n    vec2 right = vec2(p.x+0.5, p.y-ydecal);\n\n    if (PointInTriangle(uv, right, left, vec2(0.5,0.0) ))\n    {\n        float distanceToEdge = length(uv-left);\n\n        float d = clamp(distanceToEdge, 0.0, 1.0);\n        c += 0.081;\n    }\n    return c;\n}\n\nvec3 getBackgroundColor(float y)\n{\n    float t = iTime*0.1;\n    \n    float phaseTime = (t - floor(t)) * 4.0;  \n    int phaseStart = int(mod(t, 4.0));   // => [0, 3]\n    int phaseEnd = int(mod((t + 1.0), 4.0));\n    \n    float subPhaseTime = phaseTime - floor(phaseTime); \n    \n    vec3 al,bl,ah,bh;\n        \n    if (phaseStart<1)\n    {\n        ah = vec3(0.4784,0.788235,0.9725);\n        bh = vec3(0.8196,0.3843,0.87039);\n    }\n    else if (phaseStart<2)\n    {\n        ah = vec3(0.8196,0.3843,0.87039);\n        bh = vec3(0.098,0.760781,0.3647);\n    }\n    else if (phaseStart<3)\n    {\n        ah = vec3(0.098,0.760781,0.3647);\n        bh = vec3(0.921568,0.8,0.247);\n    }\n    else\n    {\n        ah = vec3(0.921568,0.8,0.247);\n        bh = vec3(0.4784,0.788235,0.9725);\n    }\n    \n    vec3 up = mix(ah, bh, subPhaseTime);\n    vec3 low = mix(ah, bh, subPhaseTime);\n    return mix(up, low, y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float c = 0.0;\n    float c2 = 0.0;\n    const int halfIterCount = 10;\n    for (int i=0;i<7;i++)\n    {\n        c2=0.0;\n        c = calc1tri(c, uv, i, 0.0);\n        float localc = c;\n        for (int j=-halfIterCount;j<halfIterCount;j++)\n        {\n            float fj = float(j);\n            localc = calc1tri(localc, uv, i, fj/iResolution.y);\n            c2 += max(0.0,localc-c); // delta color: take in account only if different from original color\n        }\n        c += c2/float(halfIterCount*2);\n    }\n\n    float lum = c/float(halfIterCount*2);\n    vec3 bg = getBackgroundColor(uv.y);\n    fragColor = vec4(bg.x,bg.y,bg.z,1.0) + lum;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tXSRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 96, 96, 172], [174, 174, 233, 233, 397], [399, 399, 430, 430, 587], [590, 590, 645, 645, 980], [982, 982, 1016, 1016, 1871], [1873, 1873, 1930, 1930, 2614]], "test": "valid"}
{"id": "4tXXD8", "name": "implicit-checker", "author": "substack", "description": "checkerboard implicit surface raytracer", "tags": ["raytracer"], "likes": 0, "viewed": 275, "published": "Public", "date": "1436171572", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 scene (vec3, vec3);\nconst float EPSILON = 0.001;\n\nfloat torus (float x, float y, float z) {\n  float r = 2.0, a = 0.25;\n  float b = r - sqrt(x*x + y*y);\n  return b*b + z*z - a*a;\n}\nfloat sphere (float x, float y, float z) {\n  float r = 0.8;\n  return sqrt(x*x + y*y + z*z) - r*r;\n}\nfloat geometry (float x, float y, float z) {\n  return 1.0\n    * torus(y + 0.0, x, z) / sphere(x + 0.0, y, z)\n    * torus(y - 2.0, z, x) / sphere(y - 2.0, z, x)\n    * torus(y + 2.0, z, x) / sphere(y + 2.0, z, x)\n    * torus(y - 4.0, x, z) / sphere(y - 4.0, x, z)\n    * torus(y + 4.0, z, x) / sphere(y + 4.0, z, x)\n  ;\n}\n#define surface(p) geometry((p).x,(p).y,(p).z)\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  float aspect = iResolution.x / iResolution.y;\n  uv -= 0.5;\n  uv.x = aspect * uv.x;\n  float t = iTime;\n  float x = fragCoord.x, y = fragCoord.y;\n  \n  vec3 C = vec3(sin(t*0.5) * 6.0, 4.0, cos(t*0.25) * 8.0);\n  vec3 T = vec3(0);\n  vec3 E = normalize(T - C);\n  vec3 U = vec3(0,1,0);\n  vec3 D = normalize(E + uv.x * normalize(cross(E, U)) + uv.y * U);\n  vec3 N = scene(C, D);\n  vec3 color;\n  if (length(N) < EPSILON) {\n    color = vec3(\n        sin(t/4.0),sin((x+t/3.0)/(y+t/4.0)),cos(t/5.0)\n    ) / sin(x / 16.0) / cos(y / 16.0);\n  } else {\n    color = N / sin(x / 16.0) / cos(y / 16.0);\n  }\n  fragColor = vec4(color, 1.0);\n}\n\nvec3 scene (vec3 C, vec3 D) {\n  float t = surface(C + 10.0 * D);\n  vec3 v0, v1;\n  for (int i = 0; i < 30; i++) {\n    v0 = C - (t - EPSILON) * D;\n    v1 = C - (t + EPSILON) * D;\n    float t0 = surface(v0);\n    float t1 = surface(v1);\n    t = t - t0 / (t1 - t0) * 2.0 * EPSILON;\n    if (t0 < 0.01 || t1 < 0.01) {\n      vec3 N = (v1 - v0) / (EPSILON * 2.0);\n      return N + 0.5;\n    }\n  }\n  return vec3(0.0, 0.0, 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tXXD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 96, 96, 184], [185, 185, 227, 227, 284], [285, 285, 329, 329, 603], [652, 652, 708, 708, 1375], [1377, 1377, 1406, 1406, 1795]], "test": "error"}
{"id": "llfXRS", "name": "simulating collisions - sorted", "author": "FabriceNeyret2", "description": "like https://www.shadertoy.com/view/ltXXRS but with brick particles sorted in y.\n-> even more more efficient !", "tags": ["simulation"], "likes": 2, "viewed": 1428, "published": "Public API", "date": "1437487704", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// array implementation: https://www.shadertoy.com/view/4tfSzS . so slowwww...\n// simple brick particles: https://www.shadertoy.com/view/ltXXRS\n// here: sorted particles. ( https://www.shadertoy.com/view/llfXRS ). the best !\n\nfloat time,T,cycl;\n\nfloat rnd(float x) { return fract(1345.56*sin(876.654*(x))); }\nfloat rnd(int i, int j) { return rnd(float(i)-47.45*float(j)); }\n\n#define N (30*20/10)\nivec2 grid[N];\n\n#define valid(x,y) ( x>=0 && x<20 && y>=0 && y<30 )\n\n\n// --- value of grid(y,x)\nint testGrid(int y, int x) { // test collision with grid-aligned brick-particles\n    //return 0;\n    if ( !valid(x,y) ) return -1;\n/*\n    for (int i=0; i<N; i++)\n          \t\tif (grid[i].y==y && grid[i].x==x) return 1;\n*/\n    if      (y<10) { for (int i=0; i<N/3+5; i++)\n                   \t\tif (grid[i].y==y && grid[i].x==x) return 1; }\n    else if (y<20) { for (int i=N/3-5; i<2*N/3+5; i++)\n                   \t\tif (grid[i].y==y && grid[i].x==x) return 1; }\n    else           { for (int i=2*N/3-5; i<N; i++)\n        \t\t\t\tif (grid[i].y==y && grid[i].x==x) return 1; }\n\n    return 0;\n}\n\n\nvoid mainImage( out vec4 f, vec2 uv )\n{\n    time = floor(4.*iTime);\n    T    = mod(time,48.);\n    cycl = time-T-827.31; // floor(time/48.);\n    vec2 r = iResolution.xy;\n\tuv = (2.*uv-r) / r.y; uv.y = -uv.y;\n\n    // --- init grid \n    float y = 0.;\n    for (int i=0; i<N; i++)\n        grid[i] = ivec2(20.*rnd(float(i)),y+=rnd(float(i)-7.6543)); // avg = 2 brick per line\n    \n    // --- init particle\n \tivec2 p, pos = ivec2(10,0), vel=ivec2(0,1);\n\n    // --- simulation\n    // horribly greedy : yes, it replays whole time & pos for each pixel at each frame \n    for (float t=0.; t<48.; t++)\n        if (t>T) break; // future must be kept unknown for the sake of human beings. \n        else {\n            p = pos+vel; // target new position\n            p.x = p.x<0 ? 19 : p.x >19 ? 0 : p.x; // cyclical world\n            p.y = p.y<0 ? 29 : p.y >29 ? 0 : p.y;\n            if (testGrid(p.y,p.x)==0) // free space on trajectory: go, go !\n            { pos = p; vel = ivec2(0,1);}\n            else vel= ivec2(rnd(t+cycl)<.5?-1:1 ,0); // blocked: jiggle around\n        }\n    \n    // --- display\n    vec2 fuv = (uv-vec2(-.666,-1))/2.*30.; // 20x30 grid, centered, (0,0) top left\n    ivec2 iuv = ivec2(fuv);\n    \n    int v = testGrid(iuv.y,iuv.x); \n    \n    // out of playfield\n    if (v<0) {  \n\t    // f = vec4(.5); \n    \tf = .2+.2*texture(iChannel1,uv);\n        return;\n    }\n   \n    // display blocks\n    // f = vec4(v);\n   \tif (v==0) f = .3*texture(iChannel2,uv); else f = texture(iChannel0,uv*2.5);\n       \n    // display particle\n    //if ((pos.x==iuv.x) && (pos.y==iuv.y) )f = vec4(1,0,0,0);\n    f = mix(f, vec4(1,0,T/48.,0), smoothstep(.5,.4,length(vec2(pos)+.5-fuv)));\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llfXRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[246, 246, 266, 266, 308], [309, 309, 334, 334, 373], [466, 492, 520, 588, 1076], [1079, 1079, 1118, 1118, 2748]], "test": "error"}
{"id": "lllSR2", "name": "w10", "author": "gyabo", "description": "Windows10 wallpapar wip.\n\nOMG\nhttps://www.youtube.com/watch?t=128&v=hL8BBOwupcI\n\n\nhttps://www.youtube.com/watch?t=128&v=hL8BBOwupcI\n\nomg.", "tags": ["windows10", "cineshader"], "likes": 24, "viewed": 90944, "published": "Public API", "date": "1438214088", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define PI     3.1415926535897921284\n#define REP    25\n#define d2r(x) (x * PI / 180.0)\n#define WBCOL  (vec3(0.5, 0.7,  1.7))\n#define WBCOL2 (vec3(0.15, 0.8, 1.7))\n\n\nfloat hash( vec2 p ) {\n\tfloat h = dot( p, vec2( 127.1, 311.7 ) );\n\treturn fract( sin( h ) * 458.325421) * 2.0 - 1.0;\n}\n\nfloat noise( vec2 p ) {\n\tvec2 i = floor( p );\n\tvec2 f = fract( p );\n\t\n\tf = f * f * ( 3.0 - 2.0 * f );\n\t\n\treturn mix(\n\t\tmix( hash( i + vec2( 0.0, 0.0 ) ), hash( i + vec2( 1.0, 0.0 ) ), f.x ),\n\t\tmix( hash( i + vec2( 0.0, 1.0 ) ), hash( i + vec2( 1.0, 1.0 ) ), f.x ),\n\t\tf.y\n\t);\n}\n\nvec2 rot(vec2 p, float a) {\n\treturn vec2(\n\t\tp.x * cos(a) - p.y * sin(a),\n\t\tp.x * sin(a) + p.y * cos(a));\n}\n\nfloat nac(vec3 p, vec2 F, vec3 o) {\n\tconst float R = 0.0001;\n\tp += o;\n\treturn length(max(abs(p.xy)-vec2(F),0.0)) - R;\t\n}\n\n\nfloat by(vec3 p, float F, vec3 o) {\n\tconst float R = 0.0001;\n\tp += o;\n\treturn length(max(abs(mod(p.xy, 3.0))-F,0.0)) - R;\t\n}\n\n\nfloat recta(vec3 p, vec3 F, vec3 o) {\n\tconst float R = 0.0001;\n\tp += o;\n\treturn length(max(abs(p)-F,0.0)) - R;\t\n}\n\n\nfloat map1(vec3 p, float scale) {\n\tfloat G = 0.50;\n\tfloat F = 0.50 * scale;\n\tfloat t =  nac(p, vec2(F,F), vec3( G,  G, 0.0));\n\tt = min(t, nac(p, vec2(F,F), vec3( G, -G, 0.0)));\n\tt = min(t, nac(p, vec2(F,F), vec3(-G,  G, 0.0)));\n\tt = min(t, nac(p, vec2(F,F), vec3(-G, -G, 0.0)));\n\treturn t;\n}\n\nfloat map2(vec3 p) {\n\tfloat t = map1(p, 0.9);\n\tt = max(t, recta(p, vec3(1.0, 1.0, 0.02), vec3(0.0, 0.0, 0.0)));\n\treturn t;\n}\n\n\n// http://glslsandbox.com/e#26840.0\nfloat gennoise(vec2 p) {\n\tfloat d = 0.5;\n\tmat2 h = mat2( 1.6, 1.2, -1.2, 1.6 );\n\t\n\tfloat color = 0.0;\n\tfor( int i = 0; i < 2; i++ ) {\n\t\tcolor += d * noise( p * 5.0 + iTime);\n\t\tp *= h;\n\t\td /= 2.0;\n\t}\n\treturn color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = vec4(0.0);\n    for(int count = 0 ; count < 2; count++) {\n        vec2 uv = -1.0 + 2.0 * ( fragCoord.xy / iResolution.xy );\n        uv *= 1.4;\n        uv.x += hash(uv.xy + iTime + float(count)) / 512.0;\n        uv.y += hash(uv.yx + iTime + float(count)) / 512.0;\n        vec3 dir = normalize(vec3(uv * vec2(iResolution.x / iResolution.y, 1.0), 1.0 + sin(iTime) * 0.01));\n        dir.xz = rot(dir.xz, d2r(70.0));\n        dir.xy = rot(dir.xy, d2r(90.0));\n        vec3 pos    = vec3(-0.1 + sin(iTime * 0.3) * 0.1, 2.0 + cos(iTime * 0.4) * 0.1, -3.5);\n        vec3  col   = vec3(0.0);\n        float t     = 0.0;\n        float M     = 1.002;\n        float bsh   = 0.01;\n        float dens  = 0.0;\n\n        for(int i = 0 ; i < REP * 24; i++) {\n            float temp = map1(pos + dir * t, 0.6);\n            if(temp < 0.2) {\n                col += WBCOL * 0.005 * dens;\n            }\n            t += bsh * M;\n            bsh *= M;\n            dens += 0.025;\n        }\n\n        //windows\n        t = 0.0;\n        float y = 0.0;\n        for(int i = 0 ; i < REP * 50; i++) {\n            float temp = map2(pos + dir * t);\n            if(temp < 0.1) {\n                col += WBCOL2 * 0.005;\n            }\n            t += temp;\n            y++;\n        }\n        col += ((2.0 + uv.x) * WBCOL2) + (y / (25.0 * 50.0));\n        col += gennoise(dir.xz) * 0.5;\n        col *= 1.0 - uv.y * 0.5;\n        col *= vec3(0.05);\n        col  = pow(col, vec3(0.717));\n        fragColor += vec4(col, 1.0 / (t));\n    }\n    fragColor /= vec4(2.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lllSR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[166, 166, 188, 188, 284], [286, 286, 309, 309, 562], [564, 564, 591, 591, 670], [672, 672, 707, 707, 792], [795, 795, 830, 830, 919], [922, 922, 959, 959, 1035], [1038, 1038, 1071, 1071, 1329], [1331, 1331, 1351, 1351, 1455], [1458, 1494, 1518, 1518, 1709], [1712, 1712, 1769, 1769, 3306]], "test": "valid"}
{"id": "lllSWr", "name": "protoplasm", "author": "FabriceNeyret2", "description": ".", "tags": ["3d", "raymarching", "spheremarching"], "likes": 32, "viewed": 2094, "published": "Public API", "date": "1436005980", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define T iTime\n#define r(v,t) { float a = (t)*T, c=cos(a),s=sin(a); v*=mat2(c,s,-s,c); }\n#define SQRT3_2  1.26\n#define SQRT2_3  1.732\n#define smin(a,b) (1./(1./(a)+1./(b)))\n\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n           \t\t    -0.80,  0.36, -0.48,\n             \t\t-0.60, -0.48,  0.64 );\n\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x ) { // in [0,1]\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.-2.*f);\n\n    float n = p.x + p.y*57. + 113.*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.), hash(n+  1.),f.x),\n                        mix( hash(n+ 57.), hash(n+ 58.),f.x),f.y),\n                    mix(mix( hash(n+113.), hash(n+114.),f.x),\n                        mix( hash(n+170.), hash(n+171.),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p ) { // in [0,1]\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n// --- End of: Created by inigo quilez --------------------\n\n// --- more noise\n\n#define snoise(x) (2.*noise(x)-1.)\n\nfloat sfbm( vec3 p ) { // in [-1,1]\n    float f;\n    f  = 0.5000*snoise( p ); p = m*p*2.02;\n    f += 0.2500*snoise( p ); p = m*p*2.03;\n    f += 0.1250*snoise( p ); p = m*p*2.01;\n    f += 0.0625*snoise( p );\n    return f;\n}\n\n#define sfbm3(p) vec3(sfbm(p), sfbm(p-327.67), sfbm(p+327.67))\n\n// --- using the base ray-marcher of Trisomie21: https://www.shadertoy.com/view/4tfGRB#\n\nvec4 bg = vec4(0,.2,0,0);\n\nvoid mainImage( out vec4 f, vec2 w ) {\n    vec4 p = vec4(w,0,1)/iResolution.yyxy-.5, d,c; p.x-=.4; // init ray \n    // (p.xz,.13); r(p.yz,.2); r(p.xy,.1);   // camera rotations\n    d = p; p.z += 10.;                        // ray dir = ray0-vec3(0)\n    // p = -vec4(0,.5,1,0)*T;\n    f = vec4(bg);\n    float x1,x2,x=1e9;\n    \n    for (float i=1.; i>0.; i-=.01)  {\n        if (f.x>=.99) break; // windows bug: miss it if at end ! thanks Dave_Hoskins\n        \n        vec4 u = .03*floor(p/vec4(8,8,1,1)+3.5), t = p;\n        r(t.xy,u.x); r(t.xz,u.y); //r(t.yz,1.);    // objects rotations\n\n        // x1 =length(t.xyz)-7.; // if you prefer the clean trim\n\t\tt.xyz += sfbm3(t.xyz/2.+vec3(.5*T,0,0))*(.6+8.*(.5-.5*cos(T/16.)));\n        c = 5.*texture(iChannel0,t.xy).rrrr;\n \n        x = abs(mod(length(t.xyz),1.)-1./2.);\n        x1 = length(t.xyz)-7.; \n        x = max(x,x1);\n        if ((x1>.1) && (p.z<0.)) break; // optimization\n        //x = max(x,-abs(t.x)+.2);\n        //x = max(x,-abs(t.y)+.2);\n        \n        if(x<.01) { // hit !\n              f += (1.-f)*.2*mix(bg,c,i*i); x=.1; \n              //if (f.x>=.99) break; // compiler bug on windows -> moved to begin of loop\n            }  // color texture + black fog \n        \n        p += d*x;           // march ray\n     }\n}\n", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lllSWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[485, 485, 508, 508, 547], [549, 549, 575, 587, 980], [982, 982, 1003, 1015, 1198], [1315, 1315, 1337, 1350, 1537], [1719, 1719, 1757, 1757, 2996]], "test": "error"}
{"id": "lllSzS", "name": "All States of Water", "author": "KK", "description": "Shader made for Warsztat.GD compo.", "tags": ["warsztat"], "likes": 8, "viewed": 2193, "published": "Public API", "date": "1437677380", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nfloat n(vec2 pos)\n{\n    vec2 ip = floor(pos);\n    vec2 d = pos - ip;\n    // 6x5 - 15x4 + 10x3\n    d *= d*d*(10.0+d*(6.0*d-15.0));\n    pos = ip + d;\n    pos += 0.5;\n    pos /= iChannelResolution[0].xy;\n    return texture(iChannel0,pos.xy).x*2.0-1.0;\n}\n\nfloat n3(vec3 pos)\n{\n    float ip = floor(pos.z);\n    float  d = pos.z - ip;\n    d *= d*d*(10.0+d*(6.0*d-15.0));\n    pos.xy += 100.0*ip;\n    return mix(n(pos.xy),n(pos.xy+100.0),d);\n}\n\nfloat nt(vec2 pos,float t)\t{ return n3(vec3(pos,t)); }\n\nvec2 cosin(float t)\n{\n    return vec2(cos(t),sin(t));\n}\n\nfloat water(vec3 pos)\n{\n    float t = iTime*2.0;\n    float d = pos.z;\n    pos.xy *= 0.8;\n    d -= n(pos.xy/0.2 + t*4.0*vec2(-1.8,0.1))/40.0;\n    d -= n(pos.xy/0.7 + t*3.0*vec2(0.1,0.4) + cosin(t*1.1))/12.0;\n    d -= n(pos.xy/1.0 - t*2.5 + cosin(t/4.1))/8.0;\n    d -= n(pos.xy/2.1 + t/2.0 + cosin(t/2.0))/4.0;\n    d -= n(pos.xy/4.0 +t*vec2(-1,0.5)/2.0)/2.0;\n    d -= n(pos.xy/16.0 +t*vec2(1,-0.5)/2.0)/1.0;\n    return d;\n}\n\nfloat fracno(vec2 pos)\n{\n    float v = 0.0;\n    v += abs(n(pos.xy/1.0))*1.0;\n    v += abs(n(pos.xy/2.0))*2.0;\n    v += abs(n(pos.xy/4.0))*4.0;\n    return v;\n}\n\nfloat ice(vec3 pos)\n{\n    vec2 pp = normalize(pos.xy);\n    float r = n(pp*4.0)*0.3 + n(pp*410.0)*0.05;\n    float d = length(pos.xy) - 10.0 - r;\n    float h = pos.z-2.5;\n    float l = length(pos.xy);\n    h += sin(iTime*2.0)*0.4;\n    h -= n(pos.xy/0.02)/50.0;\n    //h -= n(pos.xy/0.07)/20.0;\n    h += fracno(pos.xy/2.0)*l*l*0.007;\n    d = max(d,h);\n    return d;\n}\n\nvec4 Fn(vec3 pos)\n{\n    float d = water(pos);//pos.z + n(pos.xy)*0.5;\n    float di = ice(pos);\n    if(di<d) return vec4(0.0,1.0,0.0,di);\n\n    return vec4(1.0,0.0,0.0,d);\n}\n\nvec3 nm(vec3 pos)\n{\n    vec3 normal;\n    vec2 e = vec2(0.05+length(pos)*0.0005,0.0);\n    normal.x = Fn(pos+e.xyy).w - Fn(pos-e.xyy).w;\n    normal.y = Fn(pos+e.yxy).w - Fn(pos-e.yxy).w;\n    normal.z = Fn(pos+e.yyx).w - Fn(pos-e.yyx).w;\n    return normalize(normal);\n}\n\nvoid trace(vec3 tpos,vec3 tdir,out vec3 _pos,out vec4 mt)\n{\n\tfloat g = 0.0;\n    mt = vec4(0,0,0,0);\n\n\tfor(int i=0;i<150;i++)\n\t{\n\t\tif(g>1000.0) break;\n\t\tmt = Fn(tpos);\n\t\tif(mt.w<0.002) break;\n\t\ttpos += mt.w*tdir;\n\t\tg += mt.w;\n\t}\n    _pos = tpos;\n}\n\nfloat cloud(vec2 p)\n{\n    p *= 1.5;\n    float t = iTime*0.3;\n    float c = 0.0;\n    c += n(p/4.0 + t*vec2(-0.3,1))*4.0;\n    p += t*vec2(0.3,1)*4.0;\n    c += n(p/2.0)*2.0;\n    c += n(p*1.0)/1.0;\n    c += n(p*2.0)/2.0;\n    c += n(p*4.0)/4.0;\n    c += n(p*8.0)/8.0;\n    return max(c*0.5,0.0);\n}\n\nvec3 sky(vec3 dir)\n{\n    dir = normalize(dir);\n    dir.z = abs(dir.z);\n\tvec3 c0 = mix(vec3(0.3,0.5,0.9),vec3(0.05,0.1,0.4),sqrt(dir.z*1.5));\n    \n    vec2 cpos = dir.xy/dir.z;\n    float cl = cloud(cpos);\n    float cl1 = cloud(cpos-0.1*vec2(-1,-1));\n    cl1 = clamp(cl1,0.0,1.0);\n    float lit = 1.0 - cl1;\n    float shade = 0.5/(0.5+cl*0.5);\n    vec3 ccol = mix(vec3(0.2,0.22,0.3)*shade,vec3(0.4,0.3,0.3),lit);\n    \n    c0 = mix(c0,ccol,clamp(cl,0.0,1.0));\n    \n    return c0;\n}\n\nvec4 getcolor(vec3 pos,vec3 dir,vec4 d)\n{\n\tif(length(pos)>900.0)\n        return vec4(sky(dir),0.0);\n\n    vec3 ld = normalize(vec3(4,-2,4));\n    vec3 normal = nm(pos);\n    vec4 c = vec4(clamp(dot(normal,ld),0.0,1.0));\n    if(d.y>0.5) return c*vec4(1.2,1.2,1.3,0.0);\n    return c*vec4(0.02,0.04,0.05,0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vpos = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n\tvpos.x *= iResolution.x/iResolution.y;\n\tvpos *= .8;\n\t\n    \n\tvec2 mpos = iMouse.xy / iResolution.xy*2. - 1.;\n\tvec3 front = normalize(vec3(-1.,-mpos.x,mpos.y-.5));\n    \n    \n\t//front = normalize(vec3(-1,-0.7,0));\n    front.xy = cosin(iTime*0.2);\n    front.z = -(sin(iTime*0.3)*.5+.5)*0.6;\n    front = normalize(front);\n\tvec3 up = vec3(0,0,1);\n\tvec3 right = cross(up,front);\n\t//pos = vec3(1,-2,1.2)-front*4.0;\n    vec3 pos = vec3(0,0,2.2)-front*24.0;\n\n\tvec3 vdir = normalize(front + vpos.x*right + vpos.y*up);\n\tvec3 tdir = normalize(vdir);\n\tvec3 tpos = pos;\n\tvec4 c = vec4(sky(tdir)*0.3,0.0);\n\tfloat m=0.0;\n    vec4 d=vec4(0,0,0,0);\n\tvec3 lpos = vec3(10,10,0);\n\n\t//fragColor = pow(c,vec4(1.0/2.2));\n    //return;\n    \n    trace(tpos,tdir,tpos,d);\n\n\tif(d.w<0.002)\n\t{\n\t\tc = getcolor(tpos,tdir,d);\n        \n        //if(d.x>0.5)\n        {\n\t\t    vec3 normal = nm(tpos);\n            vec3 tpos2 = tpos + normal*0.02;\n            vec3 tdir2 = reflect(tdir,normal);\n            vec4 d2;\n            trace(tpos2,tdir2,tpos2,d2);\n            \n            float fres = pow(1.0 - clamp(dot(normal,-tdir),0.0,1.0),5.0);\n            c += getcolor(tpos2,tdir2,d2)*mix(0.04,1.0,fres);\n        }\n\t}\n    \n\tif(length(tpos)>900.0)\n\t{\n\t\tc = vec4(sky(tdir),0.0);\n\t}\n\n\t\n\tfragColor = pow(c,vec4(1.0/2.2));\n}\n", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lllSzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 21, 21, 252], [254, 254, 274, 274, 437], [439, 439, 467, 467, 493], [495, 495, 516, 516, 550], [552, 552, 575, 575, 973], [975, 975, 999, 999, 1133], [1135, 1135, 1156, 1156, 1497], [1499, 1499, 1518, 1518, 1670], [1672, 1672, 1691, 1691, 1938], [1940, 1940, 1999, 1999, 2186], [2188, 2188, 2209, 2209, 2479], [2481, 2481, 2501, 2501, 2959], [2961, 2961, 3002, 3002, 3266], [3268, 3268, 3325, 3325, 4663]], "test": "error"}
{"id": "lllXR2", "name": "Raymarch 169 chars", "author": "GregRostami", "description": "I'm trying to shrink my previous shader: https://www.shadertoy.com/view/MtXXRH\nThis was inspired by coyote's [2TC 15] Fractal Complex shader: https://www.shadertoy.com/view/ltfGzS\nSize optimizing friends (addicts) ... please help! ", "tags": ["3d", "raymarch", "small", "2tc"], "likes": 13, "viewed": 1133, "published": "Public API", "date": "1438226147", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**/ // 169 chars - moved some code in the for() command\nvoid mainImage(out vec4 o, vec2 u) {                                            \\\n    o.xy = u/iResolution.x;\n    vec4 r, q, p = o += .5;\n    q.z = iTime;\n    for ( p--; p.w++<99.; r = sin(q), r = max(r.y-r,.1*(cos(q*9.)-r.y)) )\n     \t(o.a = max(r.x,r.z)) >.01\n        ? q -= p*o.a, o -= .01 : o; }\n/**/\n\n\n/** // 172 chars:\n#define mainImage(o,u)\t\t\t\t\t\t\t\t\t\\\n    o.xy = u/iResolution.x;\t\t\t\t\t\t\t\t\\\n    vec4 r, q, p = o += .5;\t\t\t\t\t\t\t\t\\\n    q.z = iTime;\t\t\t\t\t\t\t\t\t\t\\\n    p--;\t\t\t\t\t\t\t\t\t\t\t\t\\\n    while (p.w++<99.)                                   \\\n    \tr = sin(q), r = max(r.y-r,.1*(cos(q*9.)-r.y)),\t\\\n     \t(o.a = max(r.x,r.z)) >.01\t\t\t\t\t\t\\\n        ? q -= p*o.a, o -= .01 : o\n/**/\n\n\n//Super Fabrice implemented several size optimizations\n//Plus further optimization by 834144373 brings it down to 196 chars!!\n//coyote reworked the loop code for -1 char.\n//Had to add 2 chars to make it work on all platforms. :(\n/**\nvoid mainImage(out vec4 o,vec2 u)\n{\n    o -= o;\n    o.xy = u/iResolution.x;\t\t\t// Red, Green & Yellow color gradient.\n    vec4 r, q,                        // Initialize 4D vector for geometry.            \n        p = o += .5;               // Set the camera to look straight ahead.\n    q.z = iTime;\t\t\t\t\t// Animate camera across the z-axis.\n    p--;                           // p = p - 1.0\n    for (int i=0; i++<99;)       // Main ray-marching loop.\n    \tr = sin(q), r = max(r.y-r,.1*(cos(q*9.)-r.y)), // 3D geometry (Menger Sponge).\n     \t(o.a = max(r.x,r.z)) >.01  // If the ray misses,\n        ? q -= p*o.a,              // then march the ray forward and\n        o -= .01                   // darken distant pixels (shading).\n        : o;                       // else, ray hit the geometry. Output color. \n}\n/**/\n\n// 203 chars - uses iTime for better rendering.\n/**\nvoid mainImage (out vec4 o,vec2 u)\n{\n    o = vec4(u/iResolution.x,0,0);\n    vec4 r, q, p=o+=.5;\n    q.z = iTime;\n    p--;\n    for (int i=0; i++<99;)  \n    \tr = sin(q),\n        r = max(r.y-r,.1*(cos(q*9.)-r.y)),\n     \t(o.a=max(r.x,r.z)) >.01 ? q -= p*o.a, o -= .01 : o;\n}\n/**/\n\n\n//Original Shader at 227 chars:\n/**\n#define X r = cos(q.xyww*s), d = max(d,(cos(q.y)-min(r.x,min(r.y,r.z)))/s),s*=8.;\nvoid mainImage(out vec4 o, vec2 n )\n{\n    vec4 r,q=iDate,p=q-q-.4;\n    p.xy+=n/iResolution.x;\n    for (float i=1.; i>0.; i-=.01)\n    {\n        float d=0.,s=1.;\n\t\tX X\n        d>.01 ?\n        q -= p*d,\n        o = p+i\n        : o;\n    }\n}\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lllXR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[5, 57, 93, 93, 355]], "test": "valid"}
{"id": "llsSRj", "name": "Relaxing wind", "author": "rohtie", "description": "Enjoying the chill wind!", "tags": ["relaxing", "wind"], "likes": 4, "viewed": 177, "published": "Public", "date": "1438180048", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smin (float a, float b, float k) {\n    a = pow(a, k); b = pow(b, k);\n    return pow((a*b)/(a + b), 1.0/k);\n}\n\nvoid mainImage (out vec4 col, in vec2 p) {\n    float t = iTime;\n    \n    p /= iResolution.xy;\n    \n    vec2 q1 = p - vec2(0.13, 0.12);\n    vec2 q2 = p - vec2(0.65 - sin(t/5.0)*0.25, 0.6 - cos(t)*0.05);\n    vec2 q3 = p - vec2(0.5, 0.12);\n    \n    float r1 = length(q1) + 1.0 + cos(atan(q1.y, q1.x) * 6.0 + t*6.0);\n    float r2 = length(q2);\n    float r3 = smoothstep(0.0, 0.0, -q3.y);\n    \n    float r = smin(r1, r2, 1.0);\n    r = max(r, r3);\n    \n    float eyes = (\n        smoothstep(0.16, 0.01, length(q2 + vec2(0.1, -0.1)) + 0.08) + \n        smoothstep(0.16, 0.01, length(q2 + vec2(0.28, -0.1)) + 0.089)\n    );\n    eyes = min(eyes, smoothstep(0.0, 0.001, q2.y - 0.11));\n    r = max(r, eyes);\n\n    float mouth = smoothstep(0.3, 0.28, length(q2 + vec2(0.22, 0.0)) + 0.26);\n    mouth = min(mouth, smoothstep(0.0, 0.001, -q2.y));\n    r = max(r, mouth);\n    \n    r = smoothstep(0.3, 0.27, r);\n    \n    col.rgb = (\n        // Background\n        vec3(0.125 + p.y*0.21) +\n        vec3(0.13, p.x*p.y, sqrt(p.x*p.y*p.x)) +\n        vec3(0.0, -p.x, -sqrt(p.y)) * vec3(0.25) +\n        \n        // Objects\n        vec3(r) /\n        vec3(smoothstep(0.27, 0.4, r2) + 0.26 + p.x*p.y) *\n        vec3(p.y*0.51, p.x*p.y, 0.15) +\n        \n        // Specular\n        vec3(smoothstep(0.6, 0.1, length(q2 - vec2(0.15, 0.07)) + 0.25) * p.x) * \n        vec3(1.00, 0.12, 0.21)\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llsSRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 52, 92, 92, 166], [168, 168, 210, 210, 1530]], "test": "valid"}
{"id": "llsSzB", "name": "RedSmoke", "author": "Makio64", "description": "An attempt to create a more classic smoking effect turn to this pretty effect.", "tags": ["noise", "fbm", "fire", "plasma", "smoke"], "likes": 34, "viewed": 1229, "published": "Public API", "date": "1437811153", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//noise & fbm from : https://www.shadertoy.com/view/Xds3Rj\n\nfloat hash(float x)\n{\n\treturn fract(21654.6512 * sin(385.51 * x));\n}\n\nfloat hash(vec2 p)\n{\n\treturn fract(21654.65155 * sin(35.51 * p.x + 45.51 * p.y));\n}\n\nfloat lhash(float x, float y)\n{\n\tfloat h = 0.0;\n\t\n\tfor(int i = 0;i < 5;i++)\n\t{\n\t\th += (fract(21654.65155 * float(i) * sin(35.51 * x + 45.51 * float(i) * y * (5.0 / float(i))))* 2.0 - 1.0) / 10.0;\n\t}\n\treturn h / 5.0 + 0.02;\n\treturn (fract(21654.65155 * sin(35.51 * x + 45.51 * y))* 2.0 - 1.0) / 20.0;\n}\n\nfloat noise(vec2 p)\n{\n\tvec2 fl = floor(p);\n\tvec2 fr = fract(p);\n\t\n\tfr.x = smoothstep(0.0,1.0,fr.x);\n\tfr.y = smoothstep(0.0,1.0,fr.y);\n\t\n\tfloat a = mix(hash(fl + vec2(0.0,0.0)), hash(fl + vec2(1.0,0.0)),fr.x);\n\tfloat b = mix(hash(fl + vec2(0.0,1.0)), hash(fl + vec2(1.0,1.0)),fr.x);\n\t\n\treturn mix(a,b,fr.y);\n}\n\n//Fractal Brownian Motion \nfloat fbm(vec2 p)\n{\n\tfloat v = 0.0, f = 1.0, a = 0.5;\n\tfor(int i = 0;i < 5; i++)\n\t{\n\t\tv += noise(p * f) * a;\n\t\tf *= 2.0;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n//Fun start here\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //change the animation speed\n    float time = iTime*1.;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = uv*2.0 -1.0;\n\tuv.x *= iResolution.x / iResolution.y;\t\n\n    float p = fbm(vec2(noise(uv+time/2.5),noise(uv*2.+cos(time/2.)/2.)));\n\t//uncomment for more plasma/lighting/plastic effect..\n    //p = (1. - abs(p * 2.0 - 1.0))*.8;\n\n\tvec3 col = pow(vec3(p),vec3(0.3))-0.4;\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.2,pow(1.0 / 2.0,0.5) - uv.y/40.0) );\n    float s = smoothstep(.35,.6,col.x);\n    float s2 = smoothstep(.47,.6,col.x);\n    float s3 = smoothstep(.51,.6,col.x);\n    //multiply by the inverse to get the \"smoky\" effect, first attempt\n    col*=vec3(1.3,.1,0.1)*s; //add red\n    col+=vec3(0.3,0.4,.1)*s2; //add orange\n    col+=vec3(1.,4.,.1)*s3; //add yellow\n    //made it more bright\n    col*=1.5;\n    fragColor = vec4(col,col.r*.3);\n    fragColor.rgb += 0.05;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llsSzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 81, 81, 128], [130, 130, 150, 150, 213], [215, 215, 246, 246, 516], [518, 518, 539, 539, 826], [828, 855, 874, 874, 1003], [1005, 1022, 1079, 1112, 1959]], "test": "valid"}
{"id": "llsXD7", "name": "Tunnel Flythrough", "author": "Cubed", "description": "First attempt at raymarching. \nCredit to IÃÂ±igo QuÃÂ­lez for creating this page: http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nand dila tube for this simple raymarching tutorial: https://www.youtube.com/watch?v=yxNnRSefK94", "tags": ["tunnel", "grey"], "likes": 11, "viewed": 370, "published": "Public", "date": "1437358962", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Using IÃÂ±igo QuÃÂ­lez's distance functions from: http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCross(in vec3 p)\n{\n  float da = sdBox(p.xyz,vec3(4.0,0.0,1.0));\n  float db = sdBox(p.yzx,vec3(1.0,2.0,2.0));\n  float dc = sdBox(p.zxy,vec3(0.5,1.0,sin(iTime*4.0)+2.5));\n  return min(da,min(db,dc));\n}\n\nfloat opRep(vec3 p, vec3 c) {\n    vec3 q = mod(p,c)-0.5*c;\n    return sdCross(q);\n}\n\nfloat trace(vec3 o, vec3 r) {\n    float t = 0.0;\n    for (int i = 0; i < 32; i++) {\n    \tvec3 p = o + r * t;\n        float d = opRep(p, vec3(6.0, 6.0, 6.0));\n        t += d * 1.0;\n    }\n    return t;\n}\n\nmat2 rotation(float theta) {\n    return mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 r = normalize(vec3(uv, 1.0));\n    r.xz *= rotation(sin(iTime) * 0.2);\n    r.xy *= rotation(cos(iTime) * 0.2);\n    vec3 o = vec3(0.0, iTime, iTime * 10.0);\n    float t = trace(o, r);\n    float fog = 1.0 / (1.0 + t * t * 0.001);  \n    vec3 fc = vec3(1.0-fog);\n\tfragColor = vec4(fc ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llsXD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 123, 154, 154, 241], [243, 243, 269, 269, 450], [452, 452, 481, 481, 535], [537, 537, 566, 566, 738], [740, 740, 768, 768, 836], [838, 838, 895, 895, 1302]], "test": "valid"}
{"id": "llsXD8", "name": "Cell Merge (prototype)", "author": "W_Master", "description": "very inefficient code, also contains glitches, want to make a better one with similar result.\nclick to interact.", "tags": ["2d", "circle", "glitched", "inefficient"], "likes": 11, "viewed": 1579, "published": "Public API", "date": "1436516238", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define sin60 0.86602540378\n\n#define clicksize 1.0\n\nvec3 color_bg = vec3(0.0,0.0,0.0);\nvec3 color_inner = vec3(1.0,1.0,0.0);\nvec3 color_outer = vec3(0.5,0.8,0.3);\n\nfloat getVolume(vec2 localPos, float radius)\n{\n    localPos = abs(localPos);\n    \n    vec2 maxPos = localPos + vec2(0.5);\n    \n    float rr2 = radius * radius;\n    \n    if( dot(maxPos, maxPos) <= rr2)\n    {\n        return 1.0;\n    }\n    \n    vec2 minPos = localPos - vec2(0.5);\n    if( dot(minPos, minPos) >= rr2)\n    {\n        return 0.0;\n    }\n    \n    vec2 pA, pB;\n    // pA\n    if( sqrt(radius * radius - minPos.x * minPos.x) > maxPos.y)\n    {\n        pA = vec2(sqrt(rr2 - maxPos.y * maxPos.y) , maxPos.y);\n    }\n    else\n    {\n        pA = vec2(minPos.x, sqrt(rr2 - minPos.x * minPos.x));\n    }\n    //pB\n    if( sqrt(radius * radius - minPos.y * minPos.y) > maxPos.x)\n    {\n        pB = vec2( maxPos.x, sqrt(rr2 - maxPos.x * maxPos.x));\n    }\n    else\n    {\n        pB = vec2( sqrt(rr2 - minPos.y * minPos.y), minPos.y);\n    }\n    \n    vec2 block = abs(pB-pA);\n    float areaTri = (block.x * block.y) / 2.0;\n    \n    float areaBoxWidth = min(pA.x, pB.x) - minPos.x;\n    float areaBoxHeight = min(pA.y, pB.y) - minPos.y;\n    \n    float areaBoxOverlap = areaBoxWidth * areaBoxHeight;\n    \n    float areaTotal = areaTri + areaBoxWidth + areaBoxHeight - areaBoxOverlap ;\n    \n    return areaTotal;\n}\n\nvec2 getCellVolume(vec2 fragCoord, vec4 cell)\n{\n    vec2 volume = vec2(0.0);\n    volume.x = getVolume(cell.xy - fragCoord, cell.z);\n    if( volume.x == 0.0 )\n    {\n        volume.y = getVolume(cell.xy - fragCoord, cell.w);\n    }\n    else\n    {\n        volume.y = 1.0 - volume.x;\n    }\n    return volume;\n}\n\nvec2 getCellVolumeMerge(vec2 fragCoord, vec4 cell1, vec4 cell2)\n{\n    vec2 circleSize = (cell1.zw + cell2.zw) / 2.0; // average size \n    \n    float dis = distance(cell1.xy, cell2.xy);\n    \n    circleSize /= (dis * 1.3 / circleSize);\n    \n    \n    vec2 forward = normalize(cell2.xy-cell1.xy);\n    vec2 right = vec2(forward.y, -forward.x);\n    \n    vec2 length1 = cell1.zw + circleSize;\n    vec2 length2 = cell2.zw + circleSize;\n    \n    vec2 volume = vec2(0.0);\n    \n    if( dis < length1.x + length2.x )// test inner\n    {\n        float L1 = length1.x;\n        float L2 = length2.x;\n        \n        float cosA = (dis*dis + L1*L1 - L2*L2) / (2.0 * dis * L1);\n        \n        float Lf = cosA * L1;\n        float Ls = sqrt(L1*L1 - Lf*Lf);\n        \n        if(Ls > circleSize.x)\n        {\n            vec2 pointRight = cell1.xy + forward * Lf + right * Ls;\n            vec2 pointLeft = cell1.xy + forward * Lf - right * Ls;\n\n            vec2 checkPR1 = normalize(cell1.xy - pointRight);\n            checkPR1 = vec2(checkPR1.y, -checkPR1.x); // rotate CW\n            vec2 checkPR2 = normalize(cell2.xy - pointRight);\n            checkPR2 = vec2(-checkPR2.y, checkPR2.x); // rotate CCW\n\n            vec2 checkPL1 = normalize(cell1.xy - pointLeft);\n            checkPL1 = vec2(-checkPL1.y, checkPL1.x); // rotate CCW\n            vec2 checkPL2 = normalize(cell2.xy - pointLeft);\n            checkPL2 = vec2(checkPL2.y, -checkPL2.x); // rotate CW\n\n            vec2 fromR = fragCoord - pointRight;\n            vec2 fromL = fragCoord - pointLeft;\n\n            if(dot(checkPR1,fromR) > 0.0 && dot(checkPR2, fromR) > 0.0 \n                && dot(checkPL1,fromL) > 0.0 && dot(checkPL2, fromL) > 0.0)\n            {\n                volume.x = 1.0 - getVolume(fromR, circleSize.x) - getVolume(fromL, circleSize.x);\n            }\n        }\n    }\n    \n    if( dis < length1.y + length2.y )// outer\n    {\n        float L1 = length1.y;\n        float L2 = length2.y;\n        \n        float cosA = (dis*dis + L1*L1 - L2*L2) / (2.0 * dis * L1);\n        \n        float Lf = cosA * L1;\n        float Ls = sqrt(L1*L1 - Lf*Lf);\n        \n        if(Ls > circleSize.y)\n        {\n            vec2 pointRight = cell1.xy + forward * Lf + right * Ls;\n            vec2 pointLeft = cell1.xy + forward * Lf - right * Ls;\n\n            vec2 checkPR1 = normalize(cell1.xy - pointRight);\n            checkPR1 = vec2(checkPR1.y, -checkPR1.x); // rotate CW\n            vec2 checkPR2 = normalize(cell2.xy - pointRight);\n            checkPR2 = vec2(-checkPR2.y, checkPR2.x); // rotate CCW\n\n            vec2 checkPL1 = normalize(cell1.xy - pointLeft);\n            checkPL1 = vec2(-checkPL1.y, checkPL1.x); // rotate CCW\n            vec2 checkPL2 = normalize(cell2.xy - pointLeft);\n            checkPL2 = vec2(checkPL2.y, -checkPL2.x); // rotate CW\n\n            vec2 fromR = fragCoord - pointRight;\n            vec2 fromL = fragCoord - pointLeft;\n\n            if(dot(checkPR1,fromR) > 0.0 && dot(checkPR2, fromR) > 0.0 \n                && dot(checkPL1,fromL) > 0.0 && dot(checkPL2, fromL) > 0.0)\n            {\n                volume.y = 1.0 - getVolume(fromR, circleSize.y) - getVolume(fromL, circleSize.y);\n            }\n        }\n    }\n    \n    \n    return volume;\n}\n\nvec3 volumeToColor(vec2 volume)\n{\n    if( volume.x != 0.0 )\n    {\n        return mix(color_outer, color_inner, min(1.0,volume.x));\n    }\n    return mix(color_bg, color_outer, min(1.0,volume.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 cellSize = vec2( 40.0, 60.0);\n    \n    float s60r = sin60 * cellSize.y;\n    \n    vec2 center = iResolution.xy/2.0;\n    \n    vec4 cell1 = vec4(center + vec2(cellSize.y,-s60r), cellSize);\n    vec4 cell2 = vec4(center + vec2(-cellSize.y,-s60r), cellSize);\n    vec4 cell3 = vec4(center + vec2(sin(iTime*0.25)*150.0, s60r), cellSize);\n    \n    vec4 cell4 = vec4(iMouse.xy, cellSize * clicksize);\n    \n    \n    vec2 volume = vec2(0.0); // x = inner, y = outer\n    \n    volume += getCellVolume(fragCoord.xy, cell1);\n    volume += getCellVolume(fragCoord.xy, cell2);\n    volume += getCellVolume(fragCoord.xy, cell3);\n    volume += getCellVolume(fragCoord.xy, cell4);\n    \n    volume += getCellVolumeMerge(fragCoord.xy, cell1, cell4);\n    volume += getCellVolumeMerge(fragCoord.xy, cell2, cell4);\n    volume += getCellVolumeMerge(fragCoord.xy, cell3, cell4);\n    volume += getCellVolumeMerge(fragCoord.xy, cell1, cell2);\n    volume += getCellVolumeMerge(fragCoord.xy, cell2, cell3);\n    volume += getCellVolumeMerge(fragCoord.xy, cell3, cell1);\n    \n    fragColor = vec4(volumeToColor(volume),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llsXD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[164, 164, 210, 210, 1364], [1366, 1366, 1413, 1413, 1671], [1673, 1673, 1738, 1738, 4896], [4898, 4898, 4931, 4931, 5094], [5096, 5096, 5153, 5153, 6254]], "test": "valid"}
{"id": "llsXzS", "name": "Complex zoom", "author": "rioka", "description": "Playing with complex variables.", "tags": ["math", "function", "complex"], "likes": 0, "viewed": 101, "published": "Public", "date": "1437689471", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Complex utility functions from https://harrisonclarke.wordpress.com/2010/02/07/fractals-on-the-gpu-glsl/ \n//and http://www.codeproject.com/Articles/492355/Domain-Coloring-Method-on-GPU \n\nfloat c_abs(vec2 z)\n{\n    return sqrt(z.x * z.x + z.y * z.y);\n}\n\nfloat c_arg(vec2 z)\n{\n    return atan(z.y, z.x);\n}\n\nvec2 c_mult(vec2 a, vec2 b) \n{\n    return vec2(a.x * b.x - a.y * b.y, (a.x+a.y)*(b.x+b.y) - a.x*b.x - a.y*b.y);\n}\n\nvec2 c_div(vec2 a, vec2 b)\n{\n    return vec2(((a.x*b.x+a.y*b.y)/(b.x*b.x+b.y*b.y)),((a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y)));\n}\n\nvec2 c_pow(vec2 z)\n{\n    vec2 y = z;\n    for (int i=1; i<50; i++){\n    \ty = c_mult(y, z);\n    }\n    return y;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 xy = ((fragCoord.xy - (iResolution.xy / 2.0)) / iResolution.xy);\n    vec2 uv = xy * iTime * 0.1;\n    vec2 a = c_pow(uv) - vec2(1.0, 0.0);\n    vec2 b = uv - vec2(2.0, 0.0) - vec2(0.0, 1.0);\n    vec2 c = c_mult(uv, uv) + vec2(2.0, 0.0) + vec2(0.0, iTime);\n    vec2 top = c_mult(a, c_pow(b));\n    vec2 result = c_div(top, c);\n    fragColor = vec4(vec3(c_arg(result), mod(c_arg(result), 3.0) / 2.0, mod(c_arg(result), 5.0)) / 4.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llsXzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[189, 189, 210, 210, 252], [254, 254, 275, 275, 304], [306, 306, 336, 336, 419], [421, 421, 449, 449, 545], [547, 547, 567, 567, 658], [661, 661, 718, 718, 1159]], "test": "valid"}
{"id": "llXSWr", "name": "AMIGA's 30th The Juggler", "author": "pellicus", "description": "My first shadertoy production! :D (updated)\n2015, 30th AMIGA Anniversary. \nThis shader represent  the Amiga Juggler , a raytracing animation created by Eric Graham in 1986/87.\nmore info on www.ereticus.com\n@pellicus", "tags": ["raytracing", "sphere", "amiga", "juggler", "mirror", "humanoid"], "likes": 42, "viewed": 5812, "published": "Public API", "date": "1435769209", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// My AMIGA's 30th anniversary contribution.\n\n// started from iq primitives.\n// switched to a pure raytracing approach\n// added the text title borrowing code from https://www.shadertoy.com/view/Mt2GWD\n//\n// This is my first shadertoy.com production :D\n// so veeery far to be considered a well written and optimized code :D.\n// Heavly inspired from http://meatfighter.com/juggler/ and totally rebuilt on GLSL.\n\n// This is the Amiga Juggler , a raytracing animation by Eric Graham 86/87 ... yes,\n// 28 years ago!. I think this is one of the most inspiring piece\n// of digital art made on Amiga after all :D.\n// I desired to see it in real time since I've seen it\n// on my Amiga, tons of years ago, It was provided as a playback of a precalculated movie.\n\n// I'll try to post a little more about this shader on my new blog next days\n//  www.ereticus.com\n// a site where I , @pellicus, will rant some heresies ;) and ideas about graphic stuff, shaders,\n// raytracing and alternative rendering techs, engine3ds, unity plugins, and stuff like\n// that looking at videogames\n// and multimedia productions perspective.\n\n// Thanks you all for watching. :D\n// Genoa (Italy), 1 july 2015\n// Dario Pelella (@pellicus or dario.pelella on FB)\n\n\n// ===============================================================\n// VECTOR TEXT TITLE  ============================================\n// ===============================================================\nvec2 g_pen;\nvec4 g_out_color;\n\nvoid tris(vec2 a, vec2 c,vec2 b)\n{\n    vec2 pa = g_pen-a;\n    bool si = (b.x-a.x)*pa.y-(b.y-a.y)*pa.x > 0.0;\n    vec2 ca= c-a;\n    if ((ca.x)*pa.y-(ca.y)*pa.x > 0.0 == si) return;\n    vec2 cb=c-b;\n    if (cb.x*(g_pen.y-b.y)-cb.y*(g_pen.x-b.x) > 0.0 != si) return;\n    g_out_color = vec4(1,1,1,1);\n}\n\nvoid vector_text()\n{\n    vec2 uv=g_pen;\n    \n    \n    vec2 off= abs(uv-vec2(0.125000,0.125000)) - vec2(0.125000); if( off.x <= 0.0 || off.y <=  0.0)\n    { tris(vec2(0.207,0.005),vec2(0.210,0.010),vec2(0.133,0.006));tris(vec2(0.090,0.005),vec2(0.095,0.012),vec2(0.005,0.005));tris(vec2(0.095,0.012),vec2(0.000,0.011),vec2(0.005,0.005));tris(vec2(0.210,0.010),vec2(0.129,0.012),vec2(0.133,0.006));tris(vec2(0.095,0.012),vec2(0.002,0.016),vec2(0.000,0.011));tris(vec2(0.210,0.010),vec2(0.205,0.017),vec2(0.129,0.012));tris(vec2(0.095,0.012),vec2(0.090,0.017),vec2(0.002,0.016));tris(vec2(0.205,0.017),vec2(0.136,0.018),vec2(0.129,0.012));tris(vec2(0.205,0.017),vec2(0.196,0.019),vec2(0.136,0.018));\n        tris(vec2(0.090,0.017),vec2(0.078,0.020),vec2(0.002,0.016));tris(vec2(0.196,0.019),vec2(0.148,0.021),vec2(0.136,0.018));tris(vec2(0.196,0.019),vec2(0.181,0.026),vec2(0.148,0.021));tris(vec2(0.078,0.020),vec2(0.021,0.026),vec2(0.002,0.016));tris(vec2(0.181,0.026),vec2(0.155,0.029),vec2(0.148,0.021));tris(vec2(0.078,0.020),vec2(0.071,0.035),vec2(0.021,0.026));tris(vec2(0.071,0.035),vec2(0.072,0.072),vec2(0.021,0.026));tris(vec2(0.072,0.072),vec2(0.072,0.086),vec2(0.021,0.026));tris(vec2(0.131,0.072),vec2(0.072,0.086),vec2(0.072,0.072));\n        tris(vec2(0.122,0.086),vec2(0.131,0.072),vec2(0.075,0.154));tris(vec2(0.131,0.072),vec2(0.122,0.086),vec2(0.072,0.086));tris(vec2(0.072,0.086),vec2(0.075,0.154),vec2(0.021,0.026));tris(vec2(0.181,0.026),vec2(0.131,0.072),vec2(0.155,0.029));tris(vec2(0.054,0.205),vec2(0.131,0.072),vec2(0.181,0.026));tris(vec2(0.075,0.154),vec2(0.032,0.203),vec2(0.021,0.026));tris(vec2(0.131,0.072),vec2(0.054,0.205),vec2(0.075,0.154));tris(vec2(0.075,0.154),vec2(0.054,0.205),vec2(0.032,0.203));tris(vec2(0.054,0.205),vec2(0.042,0.209),vec2(0.032,0.203));\n        tris(vec2(0.287,0.000),vec2(0.230,0.008),vec2(0.258,0.002));tris(vec2(0.287,0.000),vec2(0.333,0.008),vec2(0.230,0.008));tris(vec2(0.275,0.089),vec2(0.272,0.094),vec2(0.173,0.094));tris(vec2(0.275,0.089),vec2(0.173,0.094),vec2(0.171,0.090));tris(vec2(0.275,0.089),vec2(0.171,0.090),vec2(0.177,0.083));tris(vec2(0.269,0.083),vec2(0.275,0.089),vec2(0.177,0.083));tris(vec2(0.258,0.081),vec2(0.269,0.083),vec2(0.177,0.083));tris(vec2(0.258,0.081),vec2(0.177,0.083),vec2(0.190,0.080));tris(vec2(0.252,0.071),vec2(0.258,0.081),vec2(0.190,0.080));\n        tris(vec2(0.252,0.071),vec2(0.190,0.080),vec2(0.202,0.061));tris(vec2(0.268,0.018),vec2(0.252,0.071),vec2(0.202,0.061));tris(vec2(0.268,0.018),vec2(0.202,0.061),vec2(0.215,0.016));tris(vec2(0.268,0.018),vec2(0.215,0.016),vec2(0.230,0.008));tris(vec2(0.295,0.017),vec2(0.268,0.018),vec2(0.230,0.008));tris(vec2(0.295,0.017),vec2(0.230,0.008),vec2(0.333,0.008));tris(vec2(0.196,0.156),vec2(0.181,0.158),vec2(0.189,0.153));tris(vec2(0.196,0.156),vec2(0.197,0.170),vec2(0.181,0.158));tris(vec2(0.197,0.170),vec2(0.175,0.175),vec2(0.181,0.158));\n        tris(vec2(0.197,0.170),vec2(0.198,0.189),vec2(0.175,0.175));tris(vec2(0.198,0.189),vec2(0.168,0.196),vec2(0.175,0.175));tris(vec2(0.287,0.191),vec2(0.212,0.193),vec2(0.258,0.181));tris(vec2(0.212,0.193),vec2(0.168,0.196),vec2(0.198,0.189));tris(vec2(0.287,0.191),vec2(0.168,0.196),vec2(0.212,0.193));tris(vec2(0.287,0.191),vec2(0.178,0.203),vec2(0.168,0.196));tris(vec2(0.287,0.191),vec2(0.208,0.207),vec2(0.178,0.203));\n    }\n    if(g_out_color.a>0.0)return;\n    off= abs(uv-vec2(0.375000,0.125000)) - vec2(0.125000); if( off.x <= 0.0 || off.y <=  0.0)\n    { tris(vec2(0.287,0.000),vec2(0.230,0.008),vec2(0.258,0.002));tris(vec2(0.287,0.000),vec2(0.333,0.008),vec2(0.230,0.008));\n        tris(vec2(0.275,0.089),vec2(0.272,0.094),vec2(0.173,0.094));tris(vec2(0.275,0.089),vec2(0.173,0.094),vec2(0.171,0.090));tris(vec2(0.275,0.089),vec2(0.171,0.090),vec2(0.177,0.083));tris(vec2(0.269,0.083),vec2(0.275,0.089),vec2(0.177,0.083));tris(vec2(0.258,0.081),vec2(0.269,0.083),vec2(0.177,0.083));tris(vec2(0.258,0.081),vec2(0.177,0.083),vec2(0.190,0.080));tris(vec2(0.252,0.071),vec2(0.258,0.081),vec2(0.190,0.080));tris(vec2(0.252,0.071),vec2(0.190,0.080),vec2(0.202,0.061));tris(vec2(0.268,0.018),vec2(0.252,0.071),vec2(0.202,0.061));\n        tris(vec2(0.268,0.018),vec2(0.202,0.061),vec2(0.215,0.016));tris(vec2(0.268,0.018),vec2(0.215,0.016),vec2(0.230,0.008));tris(vec2(0.295,0.017),vec2(0.268,0.018),vec2(0.230,0.008));tris(vec2(0.295,0.017),vec2(0.230,0.008),vec2(0.333,0.008));tris(vec2(0.333,0.008),vec2(0.319,0.030),vec2(0.295,0.017));tris(vec2(0.333,0.008),vec2(0.370,0.034),vec2(0.319,0.030));tris(vec2(0.370,0.034),vec2(0.332,0.071),vec2(0.319,0.030));tris(vec2(0.370,0.034),vec2(0.386,0.077),vec2(0.332,0.071));tris(vec2(0.386,0.077),vec2(0.322,0.116),vec2(0.332,0.071));\n        tris(vec2(0.386,0.077),vec2(0.356,0.148),vec2(0.322,0.116));tris(vec2(0.356,0.148),vec2(0.297,0.154),vec2(0.322,0.116));tris(vec2(0.356,0.148),vec2(0.258,0.181),vec2(0.297,0.154));tris(vec2(0.356,0.148),vec2(0.287,0.191),vec2(0.258,0.181));tris(vec2(0.287,0.191),vec2(0.212,0.193),vec2(0.258,0.181));tris(vec2(0.287,0.191),vec2(0.168,0.196),vec2(0.212,0.193));tris(vec2(0.287,0.191),vec2(0.178,0.203),vec2(0.168,0.196));tris(vec2(0.287,0.191),vec2(0.208,0.207),vec2(0.178,0.203));tris(vec2(0.510,0.005),vec2(0.512,0.010),vec2(0.415,0.006));\n        tris(vec2(0.512,0.010),vec2(0.409,0.012),vec2(0.415,0.006));tris(vec2(0.512,0.010),vec2(0.506,0.016),vec2(0.409,0.012));tris(vec2(0.506,0.016),vec2(0.414,0.018),vec2(0.409,0.012));tris(vec2(0.506,0.016),vec2(0.496,0.019),vec2(0.414,0.018));tris(vec2(0.496,0.019),vec2(0.425,0.019),vec2(0.414,0.018));tris(vec2(0.496,0.019),vec2(0.484,0.027),vec2(0.425,0.019));tris(vec2(0.484,0.027),vec2(0.431,0.029),vec2(0.425,0.019));tris(vec2(0.484,0.027),vec2(0.439,0.183),vec2(0.431,0.029));tris(vec2(0.439,0.183),vec2(0.387,0.182),vec2(0.431,0.029));\n        tris(vec2(0.439,0.183),vec2(0.451,0.188),vec2(0.387,0.182));tris(vec2(0.451,0.188),vec2(0.370,0.190),vec2(0.387,0.182));tris(vec2(0.451,0.188),vec2(0.460,0.194),vec2(0.370,0.190));tris(vec2(0.460,0.194),vec2(0.362,0.195),vec2(0.370,0.190));tris(vec2(0.460,0.194),vec2(0.452,0.202),vec2(0.362,0.195));tris(vec2(0.452,0.202),vec2(0.368,0.202),vec2(0.362,0.195));tris(vec2(0.556,0.200),vec2(0.487,0.200),vec2(0.489,0.193));tris(vec2(0.510,0.183),vec2(0.556,0.200),vec2(0.489,0.193));\n    }\n    if(g_out_color.a>0.0)return;\n    off= abs(uv-vec2(0.625000,0.125000)) - vec2(0.125000); if( off.x <= 0.0 || off.y <=  0.0)\n    { tris(vec2(0.510,0.005),vec2(0.512,0.010),vec2(0.415,0.006));\n        tris(vec2(0.512,0.010),vec2(0.409,0.012),vec2(0.415,0.006));tris(vec2(0.512,0.010),vec2(0.506,0.016),vec2(0.409,0.012));tris(vec2(0.506,0.016),vec2(0.414,0.018),vec2(0.409,0.012));tris(vec2(0.506,0.016),vec2(0.496,0.019),vec2(0.414,0.018));tris(vec2(0.686,0.011),vec2(0.666,0.012),vec2(0.678,0.007));tris(vec2(0.626,0.006),vec2(0.628,0.011),vec2(0.531,0.006));tris(vec2(0.782,0.007),vec2(0.784,0.011),vec2(0.711,0.006));tris(vec2(0.628,0.011),vec2(0.527,0.011),vec2(0.531,0.006));tris(vec2(0.784,0.011),vec2(0.708,0.012),vec2(0.711,0.006));\n        tris(vec2(0.784,0.011),vec2(0.781,0.017),vec2(0.708,0.012));tris(vec2(0.628,0.011),vec2(0.533,0.018),vec2(0.527,0.011));tris(vec2(0.628,0.011),vec2(0.622,0.018),vec2(0.533,0.018));tris(vec2(0.781,0.017),vec2(0.714,0.018),vec2(0.708,0.012));tris(vec2(0.622,0.018),vec2(0.611,0.019),vec2(0.533,0.018));tris(vec2(0.611,0.019),vec2(0.543,0.020),vec2(0.533,0.018));tris(vec2(0.781,0.017),vec2(0.727,0.020),vec2(0.714,0.018));tris(vec2(0.686,0.011),vec2(0.688,0.021),vec2(0.666,0.012));tris(vec2(0.781,0.017),vec2(0.758,0.026),vec2(0.727,0.020));\n        tris(vec2(0.611,0.019),vec2(0.600,0.029),vec2(0.543,0.020));tris(vec2(0.600,0.029),vec2(0.548,0.030),vec2(0.543,0.020));tris(vec2(0.758,0.026),vec2(0.734,0.032),vec2(0.727,0.020));tris(vec2(0.758,0.026),vec2(0.691,0.160),vec2(0.734,0.032));tris(vec2(0.600,0.029),vec2(0.565,0.161),vec2(0.548,0.030));tris(vec2(0.565,0.161),vec2(0.510,0.183),vec2(0.548,0.030));tris(vec2(0.556,0.200),vec2(0.487,0.200),vec2(0.489,0.193));tris(vec2(0.510,0.183),vec2(0.556,0.200),vec2(0.489,0.193));tris(vec2(0.565,0.161),vec2(0.556,0.200),vec2(0.510,0.183));\n        tris(vec2(0.640,0.073),vec2(0.556,0.200),vec2(0.565,0.161));tris(vec2(0.640,0.073),vec2(0.565,0.161),vec2(0.666,0.012));tris(vec2(0.688,0.021),vec2(0.640,0.073),vec2(0.666,0.012));tris(vec2(0.688,0.021),vec2(0.691,0.160),vec2(0.640,0.073));tris(vec2(0.758,0.026),vec2(0.700,0.182),vec2(0.691,0.160));tris(vec2(0.691,0.160),vec2(0.644,0.199),vec2(0.640,0.073));tris(vec2(0.700,0.182),vec2(0.644,0.199),vec2(0.691,0.160));tris(vec2(0.700,0.182),vec2(0.723,0.196),vec2(0.644,0.199));tris(vec2(0.723,0.196),vec2(0.719,0.202),vec2(0.644,0.199));\n        \n    }\n    if(g_out_color.a>0.0)return;\n    off= abs(uv-vec2(0.875000,0.125000)) - vec2(0.125000); if( off.x <= 0.0 || off.y <=  0.0)\n    { tris(vec2(0.782,0.007),vec2(0.784,0.011),vec2(0.711,0.006));tris(vec2(0.784,0.011),vec2(0.708,0.012),vec2(0.711,0.006));tris(vec2(0.784,0.011),vec2(0.781,0.017),vec2(0.708,0.012));tris(vec2(0.781,0.017),vec2(0.714,0.018),vec2(0.708,0.012));tris(vec2(0.781,0.017),vec2(0.727,0.020),vec2(0.714,0.018));tris(vec2(0.781,0.017),vec2(0.758,0.026),vec2(0.727,0.020));tris(vec2(0.758,0.026),vec2(0.734,0.032),vec2(0.727,0.020));tris(vec2(0.758,0.026),vec2(0.691,0.160),vec2(0.734,0.032));tris(vec2(0.758,0.026),vec2(0.700,0.182),vec2(0.691,0.160));\n        tris(vec2(0.998,0.006),vec2(1.000,0.010),vec2(0.923,0.007));tris(vec2(0.881,0.005),vec2(0.886,0.012),vec2(0.796,0.005));tris(vec2(0.886,0.012),vec2(0.790,0.012),vec2(0.796,0.005));tris(vec2(1.000,0.010),vec2(0.920,0.012),vec2(0.923,0.007));tris(vec2(0.886,0.012),vec2(0.793,0.016),vec2(0.790,0.012));tris(vec2(1.000,0.010),vec2(0.995,0.017),vec2(0.920,0.012));tris(vec2(0.886,0.012),vec2(0.881,0.018),vec2(0.793,0.016));tris(vec2(0.995,0.017),vec2(0.926,0.018),vec2(0.920,0.012));tris(vec2(0.995,0.017),vec2(0.986,0.019),vec2(0.926,0.018));\n        tris(vec2(0.881,0.018),vec2(0.868,0.020),vec2(0.793,0.016));tris(vec2(0.986,0.019),vec2(0.939,0.021),vec2(0.926,0.018));tris(vec2(0.986,0.019),vec2(0.972,0.026),vec2(0.939,0.021));tris(vec2(0.868,0.020),vec2(0.811,0.027),vec2(0.793,0.016));tris(vec2(0.972,0.026),vec2(0.945,0.030),vec2(0.939,0.021));tris(vec2(0.868,0.020),vec2(0.861,0.035),vec2(0.811,0.027));tris(vec2(0.861,0.035),vec2(0.863,0.073),vec2(0.811,0.027));tris(vec2(0.972,0.026),vec2(0.922,0.073),vec2(0.945,0.030));tris(vec2(0.863,0.073),vec2(0.863,0.086),vec2(0.811,0.027));\n        tris(vec2(0.922,0.073),vec2(0.863,0.086),vec2(0.863,0.073));tris(vec2(0.922,0.073),vec2(0.912,0.086),vec2(0.863,0.086));tris(vec2(0.972,0.026),vec2(0.912,0.086),vec2(0.922,0.073));tris(vec2(0.863,0.086),vec2(0.865,0.154),vec2(0.811,0.027));tris(vec2(0.972,0.026),vec2(0.865,0.154),vec2(0.912,0.086));tris(vec2(0.865,0.154),vec2(0.822,0.204),vec2(0.811,0.027));tris(vec2(0.972,0.026),vec2(0.844,0.205),vec2(0.865,0.154));tris(vec2(0.865,0.154),vec2(0.844,0.205),vec2(0.822,0.204));tris(vec2(0.844,0.205),vec2(0.833,0.209),vec2(0.822,0.204));\n        \n    }\n    \n}\n#define PI 3.1415926536\n\nconst vec2 res = vec2(640.0,400.0);\nconst mat3 mRot = mat3(0.9553, -0.2955, 0.0, 0.2955, 0.9553, 0.0, 0.0, 0.0, 1.0);\nconst vec3 ro = vec3(0.0,0.0,-4.0);\n\nconst vec3 cRed = vec3(1.0,0.0,0.0);\nconst vec3 cWhite = vec3(1.0);\nconst vec3 cGrey = vec3(0.66);\nconst vec3 cPurple = vec3(0.51,0.29,0.51);\n\nconst float maxx = 0.378;\n\nvoid mainVectorText( inout vec4 fragColor, in vec2 fragCoord )\n{   g_pen = fragCoord.xy/iResolution.xy;\n    float asp = iResolution.y/iResolution.x;\n    vec2 uvR = floor(g_pen*res);\n    g_pen*=vec2(1.2,1.2*asp);\n    g_pen.x = 0.195+(1.0-g_pen.x);\n    g_out_color = vec4(1,1,1.0,0.0);\n    \n    //  if(distance(g_pen,vec2(1,1))<0.01)g_out_color =vec4(1,0,0,1.0);\n    \n    vector_text();\n    fragColor.rgb =mix(fragColor.rgb,g_out_color.rgb,g_out_color.a);\n    \n    \n    \n    \n    vec2 uv = uvR/res + vec2(-0.046,-0.13);\n    \n    vec3 rd = normalize(vec3((uv)*vec2(2.0,2.0*asp),1.0));\n    \n    float b = dot(rd,ro);\n    float t1 = b*b-15.0;\n    float t = -b-sqrt(t1);\n    vec3 nor = normalize(ro+rd*t)*mRot;\n    vec2 tuv = floor(vec2(atan(nor.x,nor.z)/PI+((floor((iTime)*60.0)/60.0)*0.5),acos(nor.y)/PI)*8.0);\n    fragColor = vec4(mix(fragColor.rgb,mix(cRed,cWhite,clamp(mod(tuv.x+tuv.y,2.0),0.0,1.0)),1.0-step(t1,0.0)),1.0);\n    \n    \n    \n    \n}\n\n\n\n//#######################################################################\n//#######################################################################\n//#######################################################################\n\n#define PRECISION_STEP 0.001\n//----------------------------------------------------------------------\n\n// Inspired by http://meatfighter.com/juggler/\n// I used some values and snippets here and there\n\n#define Math_PI 3.1415926\n\n\n// Materials\n#define MAT_FLOOR  vec3(-1.0,1.0,0.0)\n#define MAT_MIRROR vec3(-1.0,2.0,0.0)\n\n#define MAT_LIMBS  vec3(0.929,0.508,0.508)\n\n#define MAT_TORSO  vec3(0.890,0.000,0.000)\n#define MAT_EYES   vec3(0.087,0.019,0.508)\n#define MAT_HAIR   vec3(0.111,0.054,0.071)\n\n//#define MAT_SKY     10.0\n#define MAT_SKY_COLOR_A   vec3(0.74,0.74,1.0)\n#define MAT_SKY_COLOR_B   vec3(0.13,0.137,0.96)\n\n// Scene constants\n\n#define CAMERA_NEAR 0.03\n#define CAMERA_FAR 25.0\n\n// The global scale of the scene is the same found in meatfighter.com,\n// should be better to change it in meters instead of centimeters but\n// I preferred to respect the original author choice.\n\n#define gSCALE  0.01\n\n// Animations and Modeling parameters\n\n#define JUGGLE_X0  -182.0\n#define JUGGLE_X1  -108.0\n#define JUGGLE_Y0  88.0\n#define JUGGLE_H_Y  184.0\n\n#define JUGGLE_H_VX ( (JUGGLE_X0 - JUGGLE_X1) / 60.0)\n#define JUGGLE_L_VX ((JUGGLE_X1 - JUGGLE_X0) / 30.0)\n\n#define  JUGGLE_H_H (JUGGLE_H_Y - JUGGLE_Y0)\n#define  JUGGLE_H_VY (4.0 * JUGGLE_H_H / 60.0)\n#define  JUGGLE_G (JUGGLE_H_VY * JUGGLE_H_VY/ (2.0 * JUGGLE_H_H))\n\n\n#define  JUGGLE_B_VY (2.0 * JUGGLE_H_H / 30.0)\n#define  JUGGLE_B ((JUGGLE_B_VY * JUGGLE_B_VY )/ (JUGGLE_H_H))\n\n#define JUGGLE_L_VY  (0.5 * JUGGLE_G * 60.0)\n\n#define HIPS_MAX_Y 85.0\n#define HIPS_MIN_Y  81.0\n\n#define HIPS_ANGLE_MULTIPLIER  (2.0 * Math_PI / 30.0)\n\n// by reason of culling and skip unnecessary calculations\nfloat sdCapsule( vec3 pa, vec3 ba, float r )\n{\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat rAABB( in vec3 roo, in vec3 rdd, in vec3 rad )\n{\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n    \n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN > tF || tF < 0.0) return CAMERA_FAR;\n    \n    return tN;\n}\n// by reason of modeling\n\nfloat rPlane(vec3 o,vec3 d,vec4 pn)\n{\n    float num = pn.w - dot(pn.xyz,o);\n    float denom = dot(pn.xyz,d);\n    float t = num/denom;\n    if(t>PRECISION_STEP)\n        return t;\n    return CAMERA_FAR;\n}\n\n\nfloat rSphere(vec3 o, vec3 d, vec3 c, float r)\n{\n    vec3 e= c - o;\n    float a= dot(e, d);\n    float b= r*r - dot(e,e) + a*a;\n    if(b>0.0)\n    {\n        float t = a- sqrt(b);\n        if(t>PRECISION_STEP)\n            return t;\n    }\n    return CAMERA_FAR;\n}\n\n#define tSPH(v,r,col) { vec3 sp = ((v)+vec3(-150.0,0.0,150.0))*gSCALE;mind = rSphere( ro,rd, sp ,float(r)*gSCALE);if(mind<res.x){res=vec4(mind,col); n_out =normalize((ro+rd*mind)-sp); } }\n\n\n\n// the modeling and animation updates.\n\n// we have 8 spheres per limb\n#define countA 8\n\nvoid tUpdateAppendage(inout vec4 res,vec3 ro,vec3 rd,vec3 p, vec3 q, vec3 w, float A, float B,inout vec3 n_out)\n{\n    vec3 V=q-p;\n    float D=length(V);\n    float inverseD = 1.00 / D;\n    V*= inverseD;\n    \n    vec3 W = normalize(w);\n    vec3 U = cross(V, W);\n    \n    float A2 = A * A;\n    \n    float y = 0.5 * inverseD * (A2 - B * B + D * D);\n    float square = A2 - y * y;\n    if (square < 0.0) {\n        return;\n    }\n    float x = sqrt(square);\n    \n    vec3 j = p+U*x+V*y;\n    float ooA=  1.0 / 8.0;\n    vec3 d= (j- p)*ooA;\n    \n    vec3 k = p;\n    float mind=res.x;\n    \n    \n    \n    for(int i = 0; i <= countA; i++)\n    {\n        float fi=float(i);\n        tSPH((k+d*fi),(2.5+2.5*fi*ooA),MAT_LIMBS);\n    }\n    \n    d= (j- q )*ooA;\n    k = q;\n    for(int i = 0; i < countA; i++)\n    {\n        tSPH((k+d*float(i)),5.0,MAT_LIMBS);\n    }\n    \n    \n}\n\n\n// the juggler sphere animation paths, taken from http://meatfighter.com/juggler/\nvoid juggling(inout vec3 c,float t)\n{\n    if(t<60.0)\n    {\n        c.z = JUGGLE_X1 + JUGGLE_H_VX * t;\n        c.y = JUGGLE_Y0 + ((JUGGLE_H_VY - 0.5 * JUGGLE_G * t) * t);\n    }\n    else\n    {   float h= t-60.0;\n        c.z = JUGGLE_X0 + ((JUGGLE_X1 - JUGGLE_X0)/30.0) * h;\n        c.y = JUGGLE_Y0 + (((2.0 * JUGGLE_H_H / 30.0) - 0.5 * JUGGLE_B * h) * h)*.5;\n    }\n}\n// the raytracing scene function.\nvec4 trace(in vec3 ro, in vec3 rd,out vec3 n_out)\n{   vec4 res=vec4(CAMERA_FAR,-2.0,-2.0,0.0);\n    n_out=vec3(0);\n    float mind = rPlane(ro,rd,vec4(0,1.0,0,0));\n    if(mind<res.x) { res=vec4(mind,MAT_FLOOR); n_out =vec3(0.0,1.0,0.0);}\n    \n    \n    float chkd=rAABB(ro-vec3(0,1,0),rd,vec3(0.6,1.0,0.6));\n    if(chkd<res.x)\n    {\n        float t =  mod(iTime*30.0,90.0);\n        vec3 pos = ro;\n        vec3 c=vec3(110.0);\n        juggling(c,t);\n        tSPH(c,14.0,MAT_MIRROR);\n        \n        juggling(c,mod(t+25.0,90.0));\n        tSPH(c,14.0,MAT_MIRROR);\n        \n        juggling(c,mod(t+55.0,90.0));\n        tSPH(c,14.0,MAT_MIRROR);\n        \n        float T =  mod(iTime*30.0,30.0);\n        \n        float angle = HIPS_ANGLE_MULTIPLIER * T;\n        float oscillation = 0.5 * (1.0 + cos(angle));\n        vec3 o = vec3(151.0, HIPS_MIN_Y + (HIPS_MAX_Y - HIPS_MIN_Y) * oscillation,-151.0);\n        vec3 v=normalize(vec3(0.0,70.0,(HIPS_MIN_Y - HIPS_MAX_Y) * sin(angle)) );\n        vec3 u=vec3(0.0,v.z,-v.y);\n        vec3 w=vec3(1.0,0.0,0.0);\n        vec3 k = o;\n        \n        for(int i = 0; i <= 7; i++)\n        {\n            float percent = float(i) / 7.0;\n            tSPH(( k+v*(32.0*percent)) , (16.0+4.0*percent),MAT_TORSO);\n        }\n        tSPH(o+v*70.0, 14., MAT_LIMBS);\n        tSPH(o+v*55.0, 5., MAT_LIMBS);\n        \n        vec3 p=vec3(159.0,1.5,-133.0);\n        \n#define mapYZ(o,v,w,y,z) (v*y+w*z+o)\n        vec3 q = mapYZ(o,v,u,-9.0,-16.0);\n        tUpdateAppendage(res,ro,rd, p, q, u, 42.58, 34.07,n_out);\n        \n        p=vec3( 139.0,2.5,-164.0);\n        q=mapYZ( o, v, u, -9.0, 16.0);\n        tUpdateAppendage(res,ro,rd, p, q, u, 42.58, 34.07,n_out);\n        \n        vec3 n ;\n        float armAngle = -0.35 * oscillation;\n        p.x = 69.0 + 41.0 * cos(armAngle);\n        p.y = 60.0 - 41.0 * sin(armAngle);\n        p.z = -108.0;\n        \n        q=mapYZ( o, v, u, 45.0, -19.0);\n        n=mapYZ( o, v, u, 45.41217, -19.91111);\n        n-= q;\n        tUpdateAppendage(res,ro,rd, p, q, n, 44.294, 46.098,n_out);\n        \n        p.z = -182.0;\n        q=mapYZ( o, v, u, 45.0, 19.0);\n        n=mapYZ( o, v, u, 45.41217, 19.91111);\n        n= q- n;\n        tUpdateAppendage(res,ro,rd,p, q, n, 44.294, 46.098,n_out);\n        \n        c = mapYZ( o, v, u, 69.0, -7.0);\n        c.x=142.0;\n        tSPH(c, 4.0, MAT_EYES);\n        \n        c = mapYZ( o, v, u, 69.0, 7.0);\n        c.x=142.0;\n        tSPH(c, 4.0, MAT_EYES);\n        \n        c =  o + v*71.0;\n        c.x=152.0;\n        tSPH(c, 14.0, MAT_HAIR);\n        \n    }\n    \n    return res;\n}\n\n\nvec4 castRay( in vec3 ro, in vec3 rd ,out vec3 n_out)\n{\n    float tmin = CAMERA_NEAR;\n    \n    float precis = PRECISION_STEP;\n    \n    vec3 m =  vec3(-2.0);\n    n_out =vec3(0.0);\n    vec4 traced = trace(ro,rd,n_out);\n    float tmax =min(CAMERA_FAR,traced.x);\n    float t = tmin;\n    vec4 res=vec4(CAMERA_FAR,-2.0,-2.0,0.0);\n    \n    if(traced.x < CAMERA_FAR)\n        return traced;\n    \n    \n    n_out=vec3(0);\n    m=vec3(-2.0);\n    return vec4( CAMERA_FAR, m.x,m.y,m.z );\n}\n\n\n\nvec3  LightDirection = vec3(-0.646997, 0.754829, -0.107833);\n\nvec4 render( in vec3 ro, in vec3 rd ,out vec3 pos,out vec3 nor,out vec3 ref)\n{\n    // the sky... ugly dot(viewdir,up) ..\n    float l = pow(rd.y+.21 , .3 );\n    vec3 col =mix(vec3(MAT_SKY_COLOR_A),vec3(MAT_SKY_COLOR_B), l);\n    \n    vec4 res = castRay(ro,rd,nor);\n    float t = res.x;\n    vec3 m = res.yzw;\n    float tm =1.0;\n    if( m.x>=-1.0 )\n    {\n        pos = ro + t*rd;\n        ref = reflect( rd, nor );\n        \n        if( m.x<0.0 )\n        {\n            if(m.y<=1.0)\n            {   // the floor\n                float f = mod( floor(pos.z+.5) + floor(pos.x+0.5), 2.0);\n                col = mix(vec3(1,1,0),vec3(0,1,0),f);\n                col *=mix(vec3(1,1,1),vec3(0.1,.1,.1),t/CAMERA_FAR);\n            }\n            else\n            {   // mirror ball\n                tm=-1.0;\n                col=vec3(1.0);\n            }\n        }else // solid stuff\n            col = m;\n        // lighitng calculation\n        \n        float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, LightDirection ), 0.0, 1.0 );\n        float spe = pow(clamp( dot( ref, LightDirection ), 0.0, 1.0 ),16.0);\n        vec3 nnn;\n        // a shadow\n        dif *= (castRay(pos,LightDirection,nnn).x<CAMERA_FAR?0.0:1.0);\n        \n        vec3 lit = vec3(dif);\n        lit += 0.20*amb*vec3(0.50,0.50,0.60);\n        col *= lit;\n        // specular on solid stuff, no floor or mirrors\n        if(m.x>0.0)\n            col+= spe*dif;\n    }\n    \n    return vec4( col,tm );\n}\n\n// from iq code :D\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n    float time =  iTime;\n    \n    // camera animation , mouse x to spin around the scene.\n    vec3 ro = vec3( -0.5+3.2*cos(0.1*time + 6.0*mo.x), .50 + 1.0, 0.5 + 3.2*sin(0.1*time + 6.0*mo.x) );\n    vec3 ta = vec3( -0.0, 1.0, 0.0 );\n    \n    // mouse y to zoom in and out a little\n    ro = ro+normalize(ta-ro)*mo.y*2.0;\n    \n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n    vec3 rd = ca * normalize( vec3(p.xy,2.5) );\n    \n    // render\n    vec3 pos,nor,ref;\n    vec4 col = render( ro, rd ,pos,nor,ref);\n    // mirrors reflections, the first bounce\n    if(col.w<0.0)\n        col = pow(max(0.0, dot( ref, LightDirection ) ),26.0) + render( pos, ref ,pos,nor,ref);\n    // and a second one\n    if(col.w<0.0)\n        col = render( pos, ref ,pos,nor,ref);\n    \n    // gamma\n    col = pow( col, vec4(0.4545) );\n    \n    fragColor=vec4( col.xyz, 1.0 );\n    \n    // the title\n    //    mainText(fragColor,fragCoord);\n    mainVectorText(fragColor,fragCoord);\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llXSWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1463, 1463, 1497, 1497, 1761], [1763, 1763, 1783, 1783, 12782], [13133, 13133, 13197, 13197, 14077], [15879, 15937, 15983, 15983, 16077], [16079, 16079, 16133, 16133, 16418], [16445, 16445, 16482, 16482, 16646], [16649, 16649, 16697, 16697, 16907], [17188, 17188, 17301, 17301, 18042], [18045, 18127, 18164, 18164, 18491], [18492, 18526, 18577, 18577, 21084], [21087, 21087, 21142, 21142, 21561], [21627, 21627, 21705, 21747, 23105], [23107, 23126, 23178, 23178, 23367], [23369, 23369, 23426, 23426, 24588]], "test": "valid"}
{"id": "llXXD4", "name": "Warsztat!", "author": "warsztat", "description": "warsztat", "tags": ["warsztat"], "likes": 2, "viewed": 1462, "published": "Public API", "date": "1436783818", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float warsztat(vec2 uv1)\n{\n    vec2 uv = (((((uv1 * 2.0) - 1.0) * 1.1818) + 1.0) * 0.5);\n    if (uv.x > 0.09090909090909091 && uv.x < 0.6363636363636364 && uv.y > 0.4090909090909091 && uv.y < 0.5454545454545454) return 1.0;\n    if (uv.x > 0.5454545454545454 && uv.x < 0.7727272727272727 && uv.y > 0.5454545454545454 && uv.y < 0.7727272727272727) return 1.0;\n    if (uv.x > 0.4090909090909091 && uv.x < 0.5454545454545454 && uv.y > 0.09090909090909091 && uv.y < 0.4090909090909091) return 1.0;\n    if (uv.x > 0.3181818181818182 && uv.x < 0.45454545454545453 && uv.y > 0.0 && uv.y < 0.09090909090909091) return 1.0;\n    if (uv.x > 0.4090909090909091 && uv.x < 0.5454545454545454 && uv.y > 0.5454545454545454 && uv.y < 0.6363636363636364) return 1.0;\n    if (uv.x > 0.7727272727272727 && uv.x < 0.9090909090909091 && uv.y > 0.9090909090909091 && uv.y < 1.0) return 1.0;\n    if (uv.x > 0.0 && uv.x < 0.09090909090909091 && uv.y > 0.3181818181818182 && uv.y < 0.45454545454545453) return 1.0;\n    if (uv.x > 0.9090909090909091 && uv.x < 1.0 && uv.y > 0.7727272727272727 && uv.y < 0.9090909090909091) return 1.0;\n    if (uv.x > 0.3181818181818182 && uv.x < 0.4090909090909091 && uv.y > 0.3181818181818182 && uv.y < 0.4090909090909091) return 1.0;\n    if (uv.x > 0.6363636363636364 && uv.x < 0.7272727272727273 && uv.y > 0.7727272727272727 && uv.y < 0.8636363636363636) return 1.0;\n    if (uv.x > 0.7727272727272727 && uv.x < 0.8636363636363636 && uv.y > 0.6363636363636364 && uv.y < 0.7272727272727273) return 1.0;\n    if (uv.x > 0.45454545454545453 && uv.x < 0.5454545454545454 && uv.y > 0.6363636363636364 && uv.y < 0.6818181818181818) return 1.0;\n    if (uv.x > 0.6363636363636364 && uv.x < 0.7272727272727273 && uv.y > 0.5 && uv.y < 0.5454545454545454) return 1.0;\n    if (uv.x > 0.6818181818181818 && uv.x < 0.7727272727272727 && uv.y > 0.8636363636363636 && uv.y < 0.9090909090909091) return 1.0;\n    if (uv.x > 0.8636363636363636 && uv.x < 0.9545454545454546 && uv.y > 0.7272727272727273 && uv.y < 0.7727272727272727) return 1.0;\n    if (uv.x > 0.0 && uv.x < 0.045454545454545456 && uv.y > 0.2727272727272727 && uv.y < 0.3181818181818182) return 1.0;\n    if (uv.x > 0.045454545454545456 && uv.x < 0.09090909090909091 && uv.y > 0.45454545454545453 && uv.y < 0.5) return 1.0;\n    if (uv.x > 0.09090909090909091 && uv.x < 0.13636363636363635 && uv.y > 0.36363636363636365 && uv.y < 0.4090909090909091) return 1.0;\n    if (uv.x > 0.2727272727272727 && uv.x < 0.3181818181818182 && uv.y > 0.0 && uv.y < 0.045454545454545456) return 1.0;\n    if (uv.x > 0.2727272727272727 && uv.x < 0.3181818181818182 && uv.y > 0.36363636363636365 && uv.y < 0.4090909090909091) return 1.0;\n    if (uv.x > 0.36363636363636365 && uv.x < 0.4090909090909091 && uv.y > 0.09090909090909091 && uv.y < 0.13636363636363635) return 1.0;\n    if (uv.x > 0.36363636363636365 && uv.x < 0.4090909090909091 && uv.y > 0.2727272727272727 && uv.y < 0.3181818181818182) return 1.0;\n    if (uv.x > 0.36363636363636365 && uv.x < 0.4090909090909091 && uv.y > 0.5454545454545454 && uv.y < 0.5909090909090909) return 1.0;\n    if (uv.x > 0.45454545454545453 && uv.x < 0.5 && uv.y > 0.045454545454545456 && uv.y < 0.09090909090909091) return 1.0;\n    if (uv.x > 0.5 && uv.x < 0.5454545454545454 && uv.y > 0.6818181818181818 && uv.y < 0.7272727272727273) return 1.0;\n    if (uv.x > 0.5454545454545454 && uv.x < 0.5909090909090909 && uv.y > 0.36363636363636365 && uv.y < 0.4090909090909091) return 1.0;\n    if (uv.x > 0.5909090909090909 && uv.x < 0.6363636363636364 && uv.y > 0.7727272727272727 && uv.y < 0.8181818181818182) return 1.0;\n    if (uv.x > 0.6363636363636364 && uv.x < 0.6818181818181818 && uv.y > 0.45454545454545453 && uv.y < 0.5) return 1.0;\n    if (uv.x > 0.7272727272727273 && uv.x < 0.7727272727272727 && uv.y > 0.9090909090909091 && uv.y < 0.9545454545454546) return 1.0;\n    if (uv.x > 0.7727272727272727 && uv.x < 0.8181818181818182 && uv.y > 0.5909090909090909 && uv.y < 0.6363636363636364) return 1.0;\n    if (uv.x > 0.8636363636363636 && uv.x < 0.9090909090909091 && uv.y > 0.6818181818181818 && uv.y < 0.7272727272727273) return 1.0;\n    if (uv.x > 0.8636363636363636 && uv.x < 0.9090909090909091 && uv.y > 0.8636363636363636 && uv.y < 0.9090909090909091) return 1.0;\n    if (uv.x > 0.9090909090909091 && uv.x < 0.9545454545454546 && uv.y > 0.9090909090909091 && uv.y < 0.9545454545454546) return 1.0;   \n    return 0.0;\n}\n\nvec3 sample_back(vec2 uv1, float start, float speed, float scale, vec2 mov)\n{ \n   vec2 uv = ((uv1) * 2.0) - 1.0;\n   float rot = start + iTime * speed;\n   mat2 m = mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n   uv = m * uv;\n   uv = uv + mov;\n   uv = uv * scale;\n   uv = (uv + 1.0) * 0.5;\n   return texture(iChannel0, uv).rrr;\n}\n\nvec3 draw_warsztat(vec3 base, vec2 uv, float col,float alpha)\n{\n    float v = 0.0;\n    if (warsztat(uv) > 0.99) v = alpha;\n    return mix(base, vec3(col), v);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.0 * (fragCoord.xy / iResolution.xy) - 1.0;\n    uv *= vec2(iResolution.x / iResolution.y, -1.0);\n    vec2 wuv = uv;\n    wuv *= (sin(iTime*2.2+0.3)*0.1)+1.0;\n    uv += 1.0;\n    uv *= 0.5;\n    \n    wuv += 1.0;\n    wuv *= 0.5;\n    \n    float t = iTime;\n    vec3 bkg =\n        vec3(0.2, 1.0, 0.3) * sample_back(uv, 0.0, 0.2, 1.2, vec2(0.0,  0.0)) * 0.25 +\n        vec3(0.7, 1.0, 0.3) * sample_back(uv, 0.5, -0.09, 0.6, vec2(0.6, -0.3)) * sin(t) * 0.6 + \n        vec3(cos(t*0.3)+1.0, 0.2, 0.5) * sample_back(uv, 0.75, 0.45, 2.2, vec2(-0.3, 0.9)) * 0.35;\n    \n    vec3 col = bkg;\n    \n    float uvm = 1.0 / 26.0;\n    \n    col = draw_warsztat(col, wuv + vec2(-uvm*0.0, -uvm * 2.0), 0.0, 0.5);\n    col = draw_warsztat(col, wuv - vec2(uvm, 0.0), 160.0/255.0, 1.0);\n    col = draw_warsztat(col, wuv - vec2(-uvm, 0.0), 160.0/255.0, 1.0);\n    col = draw_warsztat(col, wuv - vec2(0.0, uvm), 160.0/255.0, 1.0);\n    col = draw_warsztat(col, wuv - vec2(0.0, -uvm), 160.0/255.0, 1.0);\n    col = draw_warsztat(col, wuv, 80.0/255.0, 1.0);\n    \n\tfragColor = vec4(vec3(col), 1.0);\n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llXXD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 4396], [4398, 4398, 4475, 4475, 4727], [4729, 4729, 4792, 4792, 4889], [4891, 4891, 4948, 4948, 6022]], "test": "error"}
{"id": "ltfSWr", "name": "crowded coral", "author": "FabriceNeyret2", "description": ".", "tags": ["3d", "raymarching", "spheremarching"], "likes": 14, "viewed": 1406, "published": "Public API", "date": "1435770050", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n#define T .3*iTime\n#define r(v,t) { float a = (t)*T, c=cos(a),s=sin(a); v*=mat2(c,s,-s,c); }\n#define SQRT3_2  1.26\n#define SQRT2_3  1.732\n#define smin(a,b) (1./(1./(a)+1./(b)))\n\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                       -0.80,  0.36, -0.48,\n                     -0.60, -0.48,  0.64 );\n\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x ) { // in [0,1]\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.-2.*f);\n\n    float n = p.x + p.y*57. + 113.*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.), hash(n+  1.),f.x),\n                        mix( hash(n+ 57.), hash(n+ 58.),f.x),f.y),\n                    mix(mix( hash(n+113.), hash(n+114.),f.x),\n                        mix( hash(n+170.), hash(n+171.),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p ) { // in [0,1]\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n// --- End of: Created by inigo quilez --------------------\n\n// --- more noise\n\n#define snoise(x) (2.*noise(x)-1.)\n\nfloat sfbm( vec3 p ) { // in [-1,1]\n    float f;\n    f  = 0.5000*snoise( p ); p = m*p*2.02;\n    f += 0.2500*snoise( p ); p = m*p*2.03;\n    f += 0.1250*snoise( p ); p = m*p*2.01;\n    f += 0.0625*snoise( p );\n    return f;\n}\n\n#define sfbm3(p) vec3(sfbm(p), sfbm(p-127.67), sfbm(p+291.67))\n\n// --- using the base ray-marcher of Trisomie21: https://www.shadertoy.com/view/4tfGRB#\n\nvec4 bg = vec4(0,0,.3,0); // vec4(0,0,.4,0);\n\nvoid mainImage( out vec4 f, vec2 w ) {\n    vec4 p = vec4(w,0,1)/iResolution.yyxy-.5, d,c; p.x-=.4; // init ray\n     r(p.xz,.13); r(p.yz,.2); r(p.xy,.1);   // camera rotations\n    d = p;                                 // ray dir = ray0-vec3(0)\n    p.z = 5.*T;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    float closest = 999.0;\n    f = bg;\n    float x1,x2,x3,l,x=1e9;\n   \n    for (float i=1.; i>0.; i-=.01)  {\n       \n         vec4 u = floor(p/8.), t = mod(p, 8.)-4., ta; // objects id + local frame\n        // vec4 u = floor(p/vec4(8,8,1,1)+3.5),  t = p, ta,v;\n      \n        ta = abs(t);\n        r(t.xy,u.x); r(t.xz,u.y); // r(t.yz,.1);    // objects rotations\n        u = sin(78.*(u+u.yzxw));                    // randomize ids\n        t -= 4.*u;                                  // jitter positions\n        c = p/p*1.2;\n        t.xyz += 1.*sfbm3(t.xyz/3.+vec3(-.9*T,0,0));\n \n        l = length(mod(p.xyz, 8.)-4.)-2.9-u.z;\n        t = abs(mod(t,.5)-.5/2.)-.01;\n        x1 = max (t.x,t.y); x2 = max (t.y,t.z); x3 = max (t.x,t.z);\n        x = min(x1,min(x2,x3));\n        x = max(x,l);\n         if (x<.01) c = mix(c,u,.1);\n      \n        if(x<.01) // hit !\n            { f = mix(bg,c,i*i); break;  }  // color texture + black fog\n       \n        p += d*x;           // march ray\n     }\n     // f += vec4(1,0,0,0) * exp(-closest)*(.5+.5*cos(.5*T)); // thanks kuvkar !\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltfSWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[501, 501, 524, 524, 563], [565, 565, 591, 603, 996], [998, 998, 1019, 1031, 1214], [1331, 1331, 1353, 1366, 1553], [1754, 1754, 1792, 1792, 3125]], "test": "valid"}
{"id": "ltlSWr", "name": "pulse cell", "author": "nexor", "description": "bloop.", "tags": ["noise", "cell"], "likes": 3, "viewed": 167, "published": "Public", "date": "1435997709", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*precision highp float;\n\n//new version, optimized for size and speed by FabriceNeyret2\n\n#define s smoothstep\n\nfloat l, t=iDate.w, T=fract(t);\nvec2 p,m,r;\nmat2 m2 = mat2( 8, -6, 6, 8 )*.2; \n\nfloat N() {\n    m = fract(p);\n    l = dot(p-m,vec2(1,157));  // why p-(p=fract(p)) not working ?\n    p *= m2;\n    m *= m*(3.-m-m);\n#define h(n) fract(sin(n+vec2(0,157))*57.) \n    r = mix( h(l), h(++l),m.x);\n    return mix(r.x,r.y,m.y);\n}\n\nvoid mainImage( out vec4 f, vec2 u ) {\n    u = 14.*u/iResolution.y-vec2(13,7);  \n    T = s(.1,.7,T) + t-T;\n    p = u + 9.*sin(T*.1-t/3.+vec2(1.6,0));\n    f = vec4(4,1,4,1.5)*.1\n        *( N() + N()/2. + N()/4. + N()/8. ); // 2*fbm\n    l =   s( 4.,1.2, length(u) +.7*sin(T*6.3) ) \n        * 4.*(f.a+mod(f.b,.2));\n\tf = 1.-sqrt(\n        \t\t mix( vec4(.2,2,1.3,1)*l, vec4(.5,0,.8,1), l )\n        \t   - mix(f-f, f, s(.0,.005,l))\n               );\n}\n*/\n\n//old version\n#define time iTime\n#define resolution iResolution.xy\n\nconst float pi = 3.14156;\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*157.0;\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+157.0), hash(n+158.0),f.x),f.y);\n}\n\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m2*p*2.02;\n    f += 0.2500*noise( p ); p = m2*p*2.03;\n    f += 0.1250*noise( p ); p = m2*p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\nvec2 tr(vec2 p)\n{\n\t p /= resolution.xy;\n\t p = -1.0+2.0*p;\n\t p.x *= resolution.x/resolution.y;\n\t return p;\n}\n\nvec2 pix(vec2 p, int s)\n{\n\t return floor(p*float(s)+0.5)/float(s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = tr(fragCoord.xy);\n\n    vec2 c = vec2(0.0);\n\n    //c.x = cos(time*0.5)*0.5;\n    //c.y = sin(time*0.5)*0.5;\n\n    //uv = pix(uv,128);\n\n    float t = smoothstep(0.1,0.7,fract(time))+floor(time);\n\n    vec3 bg = vec3(0.2,0.8,0.3);\n    bg *= fbm(uv*8.0 \n              +10.0*vec2(\n                  cos(t*0.1-time*0.35),\n                  sin(t*0.1-time*0.35))\n             );\n\n    vec3 col = vec3(1.0,.65,0.1);\n\n    vec2 v = uv-c;\n    float ang = atan(v.y,v.x);\n    float d = length(v);\n\n    float len =\n        smoothstep(\n            1.0,0.3\n            ,d*1.75\n            +0.175\n            *sin(t*pi*2.0)\n        );\n\n    len *= bg.b+mod(bg.g,0.2);\n    len *= 4.0;\n\n    col *= 2.0*len;\n    col = mix(col,vec3(0.0,0.8,0.5),len);\n\t\t\tcol = mix(col,\n\t\t\tcol-bg.rgg,\n\t\t\tsmoothstep(0.0,0.005,len)\n\t\t\t);\n\n    col = sqrt(col);\n    col = 1.0-col.brg;\n\n\n    fragColor = vec4( col, 1.0 );\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltlSWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[972, 972, 995, 995, 1037], [1039, 1039, 1065, 1065, 1284], [1336, 1336, 1357, 1357, 1556], [1558, 1558, 1575, 1575, 1665], [1667, 1667, 1692, 1692, 1735], [1737, 1737, 1794, 1794, 2684]], "test": "valid"}
{"id": "ltlXRB", "name": "metaballs 9000", "author": "rcbuchanan", "description": "Pretty much everywhere it's gonna to be metaballs", "tags": ["metaballs", "moremetaballs", "stillmetaballs"], "likes": 6, "viewed": 194, "published": "Public", "date": "1437880315", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926\n\n#define EPSILON 0.01\n#define MAXDEPTH 10.0\n\n#define JUMPFWD 0.25\n#define MAXSTEPS int(100.0 / JUMPFWD)\n\nbool hit = false;\nint steps = 0;\n\nfloat map (vec3 p);\n\nvec3 mapnorm (vec3 p)\n{\n\tvec2 e = vec2(EPSILON, 0);\n\treturn normalize(vec3(\n\t\t    map(p + e.xyy) - map(p-e.xyy),\n\t\t    map(p + e.yxy) - map(p-e.yxy),\n\t\t    map(p + e.yyx) - map(p-e.yyx)));\n}\n\nvec3 look (vec3 eye, vec3 obj, vec2 uv)\n{\n\tvec3 at = normalize(obj - eye);\n\tvec3 up = vec3(0, 0, 1);\n\tvec3 right = cross(up, at);\n\tvec3 down = cross(at, right);\n    \n\treturn normalize(right * uv.x + down * uv.y + at);   \n}\n\nfloat meta (float d)\n{\n\treturn 0.05 / (d * d);\n\t//return pow(0.75 / d, 2.0);\n}\n\nvec3 findax2 (vec3 ax1) {\n\tvec3 ax2 = dot(ax1, vec3(1, 0, 0)) > dot(ax1, vec3(0, 1, 0)) ? vec3(0, 1, 0) : vec3(1, 0, 0);\n\tax2 = normalize(ax2 - dot(ax2, ax1) * ax2);\n\treturn ax2;\n}\n\nfloat map (vec3 p)\n{\n\tfloat w = 0.;\n\n\tfloat t;\n\tvec3 ax1, ax2, r;\n\t\n\t//t = 0.5 * PI;\n\t//t = 0.;\n\n\tax1 = normalize(vec3(0.00000000,  0.00000000, -0.95105650));\n\tt = iTime + dot(ax1, vec3(1, 2, 3));\n\tr = ax1 * sin(t) + findax2(ax1) * cos(t);\n\tw += meta(length(p - r));\n\n\tax1 = normalize(vec3(0.00000000,  0.85065080, -0.42532537));\n\tt = iTime + dot(ax1, vec3(1, 2, 3));\n\tr = ax1 * sin(t) + findax2(ax1) * cos(t);\n\tw += meta(length(p - r));\n\n\tax1 = normalize(vec3(0.80901698,  0.26286556, -0.42532537));\n\tt = iTime + dot(ax1, vec3(1, 2, 3));\n\tr = ax1 * sin(t) + findax2(ax1) * cos(t);\n\tw += meta(length(p - r));\n\n\tax1 = normalize(vec3(0.50000000, -0.68819095, -0.42532537));\n\tt = iTime + dot(ax1, vec3(1, 2, 3));\n\tr = ax1 * sin(t) + findax2(ax1) * cos(t);\n\tw += meta(length(p - r));\n\n\tax1 = normalize(vec3(-0.50000000, -0.68819095, -0.42532537));\n\tt = iTime + dot(ax1, vec3(1, 2, 3));\n\tr = ax1 * sin(t) + findax2(ax1) * cos(t);\n\tw += meta(length(p - r));\n\t\n\tax1 = normalize(vec3(-0.80901698,  0.26286556, -0.42532537));\n\tt = iTime + dot(ax1, vec3(1, 2, 3));\n\tr = ax1 * sin(t) + findax2(ax1) * cos(t);\n\tw += meta(length(p - r));\n\n\tax1 = normalize(vec3(0.50000000,  0.68819095,  0.42532537));\n\tt = iTime + dot(ax1, vec3(1, 2, 3));\n\tr = ax1 * sin(t) + findax2(ax1) * cos(t);\n\tw += meta(length(p - r));\n\n\tax1 = normalize(vec3(0.80901698, -0.26286556,  0.42532537));\n\tt = iTime + dot(ax1, vec3(1, 2, 3));\n\tr = ax1 * sin(t) + findax2(ax1) * cos(t);\n\tw += meta(length(p - r));\n\n\tax1 = normalize(vec3(0.00000000, -0.85065080,  0.42532537));\n\tt = iTime + dot(ax1, vec3(1, 2, 3));\n\tr = ax1 * sin(t) + findax2(ax1) * cos(t);\n\tw += meta(length(p - r));\n\n\tax1 = normalize(vec3(-0.80901698, -0.26286556,  0.42532537));\n\tt = iTime + dot(ax1, vec3(1, 2, 3));\n\tr = ax1 * sin(t) + findax2(ax1) * cos(t);\n\tw += meta(length(p - r));\n\n\tax1 = normalize(vec3(-0.50000000,  0.68819095,  0.42532537));\n\tt = iTime + dot(ax1, vec3(1, 2, 3));\n\tr = ax1 * sin(t) + findax2(ax1) * cos(t);\n\tw += meta(length(p - r));\n\n\tax1 = normalize(vec3(0.00000000,  0.00000000,  0.95105650));\n\tt = iTime + dot(ax1, vec3(1, 2, 3));\n\tr = ax1 * sin(t) + findax2(ax1) * cos(t);\n\tw += meta(length(p - r));\n\t\n\treturn -w + 1.0;\n}\n\nvec3 march (vec3 ro, vec3 rd)\n{\n\tfloat k = 0.0;\n    \n\tfor (int i = 0; i < MAXSTEPS; i++) {\n\t\tfloat leap = map(ro + k * rd);\n        \n\t\tif (leap < EPSILON)\n\t\t\thit = true;\n        \n\t\tif (hit || k > MAXDEPTH)\n\t\t\tbreak;\n        \n\t\t// TODO: wat.\n\t\tk += leap * JUMPFWD;\n\t\tsteps = i;\n\t}\n\treturn ro + k * rd;\n}\n\n/*\nfloat map (vec3 p)\n{\n\treturn length(p) - 1.0;\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.xx;\n\tfloat igt = iTime * 0.25;\n\tvec3 eye = vec3(2. * sin(igt), 2. * cos(igt), 0);\n\tvec3 obj = vec3(0, 0, 0);\n\n\tvec3 p = march (eye, look(eye, obj, uv));\n\t//fragColor = vec4(map(p), hit ? 1.0 : 0.0, float(steps) / float(MAXSTEPS), 1.0);\n\tfragColor = vec4(hit ? mapnorm(p) : vec3(floor(mod(iTime * 100., 2.0))), 1.0);\n\t//fragColor = vec4(map(p), 0.0, 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltlXRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[181, 181, 204, 204, 371], [373, 373, 414, 414, 595], [597, 597, 619, 619, 675], [677, 677, 702, 702, 857], [859, 859, 879, 879, 3033], [3035, 3035, 3066, 3066, 3337], [3394, 3394, 3451, 3451, 3875]], "test": "error"}
{"id": "ltlXW8", "name": "Merge Shape", "author": "anastadunbar", "description": "Inspired by PowerPoint.", "tags": ["2d", "shapes", "intersect", "union", "combine", "subtract", "combinations"], "likes": 2, "viewed": 205, "published": "Public", "date": "1436471208", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float combine(float a,float b) {\n    return (a+b)-(a*b*2.);\n}\nfloat custom(float a, float b, float oo, float ao, float ob, float ab) {\n    //https://www.shadertoy.com/view/Xdj3Rh\n\treturn mix(mix(oo,ob,b),mix(ao,ab,b),a);\n}\n#define clamps(x) clamp(x,0.,1.)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    vec2 position = fragCoord.xy / iResolution.xy;\n\tvec2 uv = vec2(position.x,((position.y-0.5)*(iResolution.y/iResolution.x))+0.5);\n    \n    float sharpness = 1000.;\n    vec2 ci_position = vec2(0.4+(cos(time*3.)*0.01),(sin(time*2.)*0.02)+0.5);\n    float circle1 = clamps(1.-((length(uv-ci_position)-0.2)*sharpness));\n    float outline1 = clamps(1.-((length(uv-ci_position)-0.2)*sharpness))-clamps(1.-((length(uv-ci_position)-0.19)*sharpness));\n    float circle2 = (clamps(1.-((length(uv-(1.-ci_position))-0.2)*sharpness)));\n    float outline2 = (clamps(1.-((length(uv-(1.-ci_position))-0.2)*sharpness)))-(clamps(1.-((length(uv-(1.-ci_position))-0.19)*sharpness)));\n    float show_outlines = clamps(outline1+outline2);\n    \n    float the_intersect = clamps(circle1*circle2); //a AND b\n    float the_combine = clamps((circle1+circle2)-(circle1*circle2*2.)); //a XOR b\n    float the_subtract = clamps(circle1-circle2); //a AND(!b)\n    float the_union = clamps(circle1+circle2); //a OR b\n    \n    float display_types = 0.; //To display these 4 combinations on screen\n    float time_types = mod(time/2.,4.);\n                           display_types = the_intersect; //Show first\n    if (time_types > 1.) { display_types = the_combine; }\n    if (time_types > 2.) { display_types = the_subtract; }\n    if (time_types > 3.) { display_types = the_union; } //Show last\n    if (position.y < 0.03) { display_types = step(uv.x,ceil(time_types)/4.); } //Draw bar\n    \n\tfragColor = vec4((display_types/1.5)+((1.-show_outlines)/5.),((1.-show_outlines)/5.),((1.-show_outlines)/5.),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltlXW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 61], [62, 62, 134, 178, 222], [256, 256, 313, 313, 1910]], "test": "valid"}
{"id": "ltlXWn", "name": "Wobbly Button", "author": "cejockel", "description": "button test", "tags": ["gradient", "button"], "likes": 2, "viewed": 135, "published": "Public", "date": "1435939495", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 q = uv - vec2(0.5,0.5);\n    \n    vec3 col = vec3(1.0,1.0,1.0);\n    \n    float s = 0.005* (0.5+sin(iTime*2.0+(uv.x*25.0)*0.5)/2.0)*10.5;\n    float r = 0.19;\n    col *= 1.0-smoothstep( r, r+s,  length (q) );\n    float w = 0.17;\n    col *= 1.0-smoothstep( w, w+s, abs(0.5-uv.x));\n\tfloat h = 0.1;\n    col *= 1.0-smoothstep( h, h+s, abs(0.5-uv.y));\n    vec3 col_Inv= 1.0-col;\n    col *= smoothstep( 0.2, 0.67, uv.y) * vec3(0.4,1.0,0.3);\n    col = col+ col_Inv;\n    \n    \n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltlXWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 609]], "test": "valid"}
{"id": "ltlXzS", "name": "states of matter", "author": "miloszmaki", "description": "Shader presenting different states of matter (solid, liquid, gas / plasma). Made for competition on warsztat.gd", "tags": ["3d", "physics", "warsztat"], "likes": 4, "viewed": 1682, "published": "Public API", "date": "1437677520", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float MELTING = 5.0;\nconst float EVAPORATING = 5.0;\nconst float DURATION = MELTING + EVAPORATING;\nconst float RADIUS = 1.0;\nconst int ITERATIONS = 100;\nconst vec3 UPDIR = vec3(0, 1, -0.3);\nconst vec3 EYE = vec3(0, 0, -4);\nconst float VISIBILITY = 10.0;\n\nfloat sphere(vec3 p, vec3 pos, float rad)\n{\n    return length(p - pos) - rad;\n}\n\nfloat plane(vec3 p, vec3 n, float d)\n{\n    return dot(p, normalize(n)) - d;\n}\n\nfloat circle(vec3 p, vec3 pos, vec3 n, float d, float rad)\n{\n    return max(sphere(p, pos, rad), plane(p, n, d));\n}\n\nfloat scene(vec3 p, float t)\n{\n    if (t > MELTING + 0.5*EVAPORATING) t = 0.0;\n    t = clamp(t / MELTING, 0.0, 1.0);\n    vec3 spos = t * -normalize(UPDIR) * 2.0*RADIUS;\n    float d = sphere(p, spos, RADIUS);\n    d = min(d, plane(p, UPDIR, -RADIUS));\n    d = min(d, circle(p, vec3(0), UPDIR, -RADIUS*0.8, sqrt(t)*RADIUS*3.0));\n    return d;\n}\n\nvec3 shade(vec3 pos)\n{\n    float d = 1.0 - length(pos) / VISIBILITY;\n    float a = clamp(plane(pos, UPDIR, -RADIUS), 0.0, 1000.0);\n    return d * mix(vec3(0.6),vec3(0,0.8,1.0),a*1.5);\n}\n\nfloat plasma(vec2 pos, float rep, float w1, float w2, float w3)\n{\n    float t = iTime;\n    return sin(rep * (sin(w1*pos.x + t) + sin(w2*pos.y + 5.8*t) + sin(w3*(pos.x - pos.y) + 1.2 * t)));\n}\n\nvec3 render(vec3 dir, float t)\n{\n    vec3 st = dir * (VISIBILITY / float(ITERATIONS));\n    vec3 pos = EYE + dir * VISIBILITY;\n    vec3 color = vec3(0.0);\n    for (int i=0; i<ITERATIONS; i++)\n    {\n        float d = scene(pos, t);\n        if (d <= 0.0) color = shade(pos);\n        pos -= st;\n    }\n    \n    float ft = clamp((t - MELTING) / EVAPORATING, 0.0, 1.0);\n    float dens = mix(15.0, 5.0, ft*ft);\n    float fog = plasma(dens*dir.xy, 5.0, 45.0, -52.0, 35.0);\n    ft = clamp(-4.5*ft*(ft-1.0), 0.0, 1.0);\n    color = mix(color, vec3(0.4,0.8,1.0)*fog, ft);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 dir = normalize(vec3(uv, 2.0));\n    \n    float time = mod(iTime, DURATION);\n\t\n    vec3 color = render(dir, time);\n    \n    //color = mix(color, vec3(1), 0.2 * mod(iTime, 1.0));\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltlXzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[260, 260, 303, 303, 339], [341, 341, 379, 379, 418], [420, 420, 480, 480, 535], [537, 537, 567, 567, 878], [880, 880, 902, 902, 1065], [1067, 1067, 1132, 1132, 1258], [1260, 1260, 1292, 1292, 1843], [1845, 1845, 1902, 1902, 2246]], "test": "valid"}
{"id": "ltsSRj", "name": "Oh dear", "author": "gazliddon", "description": "Pretty self explanatory", "tags": ["awful"], "likes": 3, "viewed": 225, "published": "Public", "date": "1438149984", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// A list of usefull distance function to simple primitives, and an example on how to \n// do some interesting boolean operations, repetition and displacement.\n//\n// More info here: http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n#if 0\n\treturn max( max( dot(q,c.xy), p.y), -p.y-c.z );\n#else\n    float d1 = -p.y-c.z;\n    float d2 = max( dot(q,c.xy), p.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif    \n}\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length2(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length8(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n  return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//----------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n//----------------------------------------------------------------------\nfloat cos01(in float t)\n{\n    return ((cos(t) + 1.0)/2.0);\n}\n\n\nvec2 map( in vec3 pos )\n{   \n    vec3 ball0 = vec3( 0.0,0.25, 0.0);\n    vec3 ball1 = vec3( 0.5, 0.25, 0);\n    vec3 shaftStart = vec3(0.25,0.25, 0.0);\n    vec3 shaftEnd = vec3(0.25,0.90 + cos01(iTime * 10.0) / 2.0,0.0);\n    \n    vec2 res = opU( vec2( sdPlane(     pos), 1.0 ),\n\t                vec2( sdSphere(    pos-ball0, 0.25 ), 46.9 ) );\n    \n    \n    res=opU(res,vec2(sdSphere(pos-ball1,0.25),10.1));\n    \n            \n/*    res = opU( res, vec2( sdBox(       pos-vec3( 1.0,0.25, 0.0), vec3(0.25) ), 3.0 ) );\n    res = opU( res, vec2( udRoundBox(  pos-vec3( 1.0,0.25, 1.0), vec3(0.15), 0.1 ), 41.0 ) );\n\tres = opU( res, vec2( sdTorus(     pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), 25.0 ) );\n*/\n    \n    res = opU( res, vec2( sdCapsule(   pos,shaftStart, shaftEnd, 0.1  ), 31.9 ) );\n    \n/*\tres = opU( res, vec2( sdTriPrism(  pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ),43.5 ) );\n\tres = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.30,-1.0), vec2(0.1,0.2) ), 8.0 ) );\n\tres = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), 55.0 ) );\n\tres = opU( res, vec2( sdTorus82(   pos-vec3( 0.0,0.25, 2.0), vec2(0.20,0.05) ),50.0 ) );\n\tres = opU( res, vec2( sdTorus88(   pos-vec3(-1.0,0.25, 2.0), vec2(0.20,0.05) ),43.0 ) );\n\tres = opU( res, vec2( sdCylinder6( pos-vec3( 1.0,0.30, 2.0), vec2(0.1,0.2) ), 12.0 ) );\n\tres = opU( res, vec2( sdHexPrism(  pos-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ),17.0 ) );\n*/\n/*    res = opU( res, vec2( opS(\n\t\t             udRoundBox(  pos-vec3(-2.0,0.2, 1.0), vec3(0.15),0.05),\n\t                 sdSphere(    pos-vec3(-2.0,0.2, 1.0), 0.25)), 13.0 ) );\n    res = opU( res, vec2( opS(\n\t\t             sdTorus82(  pos-vec3(-2.0,0.2, 0.0), vec2(0.20,0.1)),\n\t                 sdCylinder(  opRep( vec3(atan(pos.x+2.0,pos.z)/6.2831,\n\t\t\t\t\t\t\t\t\t\t\t  pos.y,\n\t\t\t\t\t\t\t\t\t\t\t  0.02+0.5*length(pos-vec3(-2.0,0.2, 0.0))),\n\t\t\t\t\t\t\t\t\t     vec3(0.05,1.0,0.05)), vec2(0.02,0.6))), 51.0 ) );\n\tres = opU( res, vec2( 0.7*sdSphere(    pos-vec3(-2.0,0.25,-1.0), 0.2 ) + \n\t\t\t\t\t                   0.03*sin(50.0*pos.x)*sin(50.0*pos.y)*sin(50.0*pos.z), \n                                       65.0 ) );\n\tres = opU( res, vec2( 0.5*sdTorus( opTwist(pos-vec3(-2.0,0.25, 2.0)),vec2(0.20,0.05)), 46.7 ) );\n*/\n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n#if 0\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n\tfloat precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.8, 0.9, 1.0);\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n\t\t\n        if( m<1.5 )\n        {\n            \n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.4 + 0.1*f*vec3(1.0);\n        }\n\n        // lighitng        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 brdf = vec3(0.0);\n        brdf += 1.20*dif*vec3(1.00,0.90,0.60);\n\t\tbrdf += 1.20*spe*vec3(1.00,0.90,0.60)*dif;\n        brdf += 0.30*amb*vec3(0.50,0.70,1.00)*occ;\n        brdf += 0.40*dom*vec3(0.50,0.70,1.00)*occ;\n        brdf += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        brdf += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tbrdf += 0.02;\n\t\tcol = col*brdf;\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0005*t*t ) );\n\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n\n\t// camera\t\n\tvec3 ro = vec3( -0.5+3.2*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 3.2*sin(0.1*time + 6.0*mo.x) );\n\tvec3 ta = vec3( -0.5, 0.4, 0.5 );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.5) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n\tcol = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltsSRj.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[378, 378, 403, 403, 418], [420, 420, 455, 455, 481], [483, 483, 514, 514, 601], [603, 603, 648, 648, 688], [690, 690, 723, 723, 776], [778, 778, 814, 814, 1056], [1058, 1058, 1110, 1110, 1224], [1226, 1226, 1262, 1262, 1510], [1512, 1512, 1548, 1548, 1647], [1650, 1650, 1688, 1688, 1929], [1931, 1931, 1956, 1956, 1993], [1995, 1995, 2020, 2020, 2078], [2080, 2080, 2105, 2105, 2170], [2172, 2172, 2207, 2207, 2274], [2276, 2276, 2311, 2311, 2378], [2380, 2380, 2417, 2417, 2468], [2544, 2544, 2577, 2577, 2603], [2605, 2605, 2635, 2635, 2668], [2670, 2670, 2700, 2700, 2729], [2731, 2731, 2755, 2755, 2887], [2889, 2962, 2987, 2987, 3022], [3025, 3025, 3050, 3050, 5266], [5268, 5268, 5308, 5308, 5898], [5901, 5901, 5975, 5975, 6236], [6238, 6238, 6270, 6270, 6491], [6493, 6493, 6535, 6535, 6834], [6839, 6839, 6878, 6878, 8464], [8466, 8466, 8518, 8518, 8695], [8697, 8697, 8754, 8754, 9347]], "test": "valid"}
{"id": "ltsSW7", "name": "Honeycomb noise", "author": "foxes", "description": "an example of a Honeycomb noise, generator without sin for realization on CPU, move the mouse up and down to zoom, left and right to mix several layers.", "tags": ["procedural", "2d", "noise"], "likes": 18, "viewed": 1495, "published": "Public API", "date": "1437322050", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nfloat hash(float x){ return fract(fract(x*0.31830988618379067153776752674503)*fract(x*0.15915494309189533576888376337251)*265871.1723); }\nvec3 hash(vec3 x){ return fract(fract(x*0.31830988618379067153776752674503)*fract(x*0.15915494309189533576888376337251)*265871.1723); }\n\nfloat hash2(vec2 x) { return hash(dot(mod(x,100.0),vec2(127.1,311.7))); }\nvec3 hash3x2(vec2 x1,vec2 x2,vec2 x3) { return hash(vec3(dot(mod(x1,100.0),vec2(127.1,311.7)),dot(mod(x2,100.0),vec2(127.1,311.7)),dot(mod(x3,100.0),vec2(127.1,311.7)))); }\n\n//float hash(float x) { return 0.0; }\n//float hash2(vec2 x) { return 0.0; }\n\nvec4 hash4( vec4 n ) { return fract(sin(n)*753.5453123); }\n\nfloat noise2( vec2 x )\n{\n    vec3 p = floor(vec3(x,x.y+0.5));\n    vec3 f = fract(vec3(x,x.y+0.5));\n    \n    //f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y * 157.0;\n    vec4 s1=hash4(vec4(n)+vec4(0.0,1.0,157.0,158.0));\n    s1.xy=mix(s1.xz,s1.yw,vec2(f.x));\n    return mix(s1.x,s1.y,f.y);\n}\n\nfloat noiseHoneycomb(vec2 i) {\n    vec2 c3;\n    i.x*=1.1547005383792515290182975610039;\n    c3.x=floor(i.x)+1.0f;\n    vec2 b=vec2(i.y+i.x*0.5,i.y-i.x*0.5);\n    c3.y=floor(b.x)+floor(b.y);\n    vec3 o=fract(vec3(i.x,b.xy));\n    \n    vec4 s;\n    vec3 m1=hash3x2(c3+vec2(1.0,0.0),c3+vec2(-1.0,-1.0),c3+vec2(-1.0,1.0));\n    vec3 m2=hash3x2(c3,c3+vec2(0.0,1.0),c3+vec2(0.0,-1.0));\n    vec3 m3=hash3x2(c3+vec2(-1.0,0.0),c3+vec2(1.0,1.0),c3+vec2(1.0,-1.0));\n    vec3 m4=vec3(m2.x,m2.z,m2.y);\n    \n    vec3 w1=vec3(o.x,(1.0-o.y),o.z);\n    vec3 w2=vec3((1.0-o.x),o.y,(1.0-o.z));\n\n    vec2 d=fract(c3*0.5)*2.0;\n    \n    s=fract(vec4(dot(m1,w1),dot(m2,w2),dot(m3,w2),dot(m4,w1)));\n\n    return fract(mix(mix(s.z,s.w,d.x),mix(s.x,s.y,d.x),d.y));\n}\n\nfloat noiseHoneycombStar(vec2 i) {\n    vec2 c3;\n    i.x*=1.1547005383792515290182975610039;\n    c3.x=floor(i.x)+1.0f;\n    vec2 b=vec2(i.y+i.x*0.5,i.y-i.x*0.5);\n    c3.y=floor(b.x)+floor(b.y);\n    vec3 o=fract(vec3(i.x,b.xy));\n    \n    vec4 s;\n    vec3 m1=vec3(hash2(c3+vec2(1.0,0.0)),hash2(c3+vec2(-1.0,-1.0)),hash2(c3+vec2(-1.0,1.0)));\n    vec3 m2=vec3(hash2(c3),hash2(c3+vec2(0.0,1.0)),hash2(c3+vec2(0.0,-1.0)));\n    vec3 m3=vec3(hash2(c3+vec2(-1.0,0.0)),hash2(c3+vec2(1.0,1.0)),hash2(c3+vec2(1.0,-1.0)));\n    vec3 m4=vec3(m2.x,m2.z,m2.y);\n    \n    vec3 w1=vec3(o.x,(1.0-o.y),o.z);\n    vec3 w2=vec3((1.0-o.x),o.y,(1.0-o.z));\n    w1=w1*w1*(3.0-2.0*w1);\n    w2=w2*w2*(3.0-2.0*w2);\n\n    vec2 d=fract(c3*0.5)*2.0;\n    \n    s=fract(vec4(dot(m1,w1),dot(m2,w2),dot(m3,w2),dot(m4,w1)));\n\n    return fract(mix(mix(s.z,s.w,d.x),mix(s.x,s.y,d.x),d.y));\n}\n\nvoid mainImage(out vec4 o, vec2 uv)\n{\n\tuv=uv/iResolution.y/.1;\n    \n    float mx = iMouse.x>0.0?iMouse.x/iResolution.x:0.5;\n    float my = iMouse.y>0.0?iMouse.y/iResolution.y:0.5;\n    \n    float time=iTime*5.0 * my;\n    \n    vec2 i=(uv-vec2(9.0,5.0))*my*10.0+vec2(time,time*0.5);\n    \n    if (uv.y<my*10.0)\n    {\n        if (uv.x<mx*17.8) {\n        \to.xyz=vec3(noiseHoneycomb(i));\n        }\n    \telse {\n        \to.xyz=vec3(noiseHoneycomb(i)*0.3+noiseHoneycomb(i*6.0)*0.25+noiseHoneycomb(i*16.0)*0.2+noiseHoneycomb(i*32.0)*0.2);\n        \to.xyz=o.xyz*0.7+noiseHoneycomb(i*0.25)*0.2;\n    \t}\n    } else {\n        if (uv.x<mx*17.8) {\n        \to.xyz=vec3(noiseHoneycombStar(i));\n        }\n    \telse {\n        \to.xyz=vec3(noiseHoneycombStar(i)*0.3+noiseHoneycombStar(i*6.0)*0.25+noiseHoneycombStar(i*16.0)*0.2+noiseHoneycombStar(i*32.0)*0.2);\n        \to.xyz=o.xyz*0.7+noiseHoneycombStar(i*0.25)*0.2;\n    \t}\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltsSW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 22, 22, 139], [140, 140, 158, 158, 275], [277, 277, 298, 298, 350], [351, 351, 390, 390, 523], [602, 602, 624, 624, 660], [662, 662, 686, 686, 950], [952, 952, 982, 982, 1685], [1687, 1687, 1721, 1721, 2532], [2534, 2534, 2571, 2571, 3441]], "test": "valid"}
{"id": "ltsXD7", "name": "Wavefunctions (redux)", "author": "djmkultra", "description": "Renders complex-valued 2D functions, (specifically complex waves E^(ix)) as height-fields. ", "tags": ["visualization", "complexwaves"], "likes": 20, "viewed": 294, "published": "Public", "date": "1437350141", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define HEIGHT_FIELD 1  // Render Fxy (2D function as a height field), otherwise Fxyz volume rendering\n#define COMPONENTS 0  // Toggle between real/im components and magnitude vis.\n\nconst int kMarchSteps = 111; // Adjust this value for better quality or faster rendering.\n\nconst float near = 1.;\nconst float zoom = .002;\nconst vec3 kEye = vec3(5., 10., 10.) * 2.;\nvec3 eye = kEye;\nvec3 at = vec3(0., 0., 0.);\n\nconst vec4 backgroundColor = vec4(0.);\nconst float brightness = 2.;\n\nconst float pi = 3.14159265359;\nconst float twopi = 2. * pi;\n\nvec4 rands = vec4(0.);\n\nvec3 Tone(vec3 hdr, float scale, float base) {\n    vec3 hdrs = max(hdr, 0.) * scale;\n    return hdrs / (vec3(base) + hdrs);\n}\nvec3 Tone(vec3 hdr) { return Tone(hdr, brightness, 1.); }\nvec4 Tone(vec4 hdra) { return vec4(Tone(hdra.rgb), hdra.a); }\n\nvec4 HitXZPlane(vec3 start, vec3 dir) {\n    float t = -start.y / dir.y;\n    return vec4(start + dir * t, t);\n}\n\nvec4 HitXYPlane(vec3 start, vec3 dir) {\n    float t = -start.z / dir.z;\n    return vec4(start + dir * t, t);\n}\n\n// returns xyz pos and t value for the backside of box, neg for no hit\nvec4 HitBox(vec3 minp, vec3 maxp, vec3 start, vec3 dir) {\n \tvec3 tminp = start - minp;\n    vec3 tmaxp = start - maxp;\n    vec3 invdir = -vec3(1.) / dir;\n    tminp *= invdir;\n    tmaxp *= invdir;\n    vec3 tmin = min(tminp, tmaxp);\n    vec3 tmax = max(tminp, tmaxp);\n    float maxt = min(min(tmax.x, tmax.y), tmax.z);\n    float mint = max(max(tmin.x, tmin.y), tmin.z);\n    return vec4(start + dir * mint, maxt < mint ? -1. : (maxt - mint));\n}\n\nvec3 GetRayDir(vec2 uv) {\n\tvec3 up = vec3(0., 1., 0.);\n    vec3 vdir = normalize(at - eye);\n    vec3 xdir = normalize(cross(vdir, up));\n    up = normalize(cross(xdir, vdir));\n    vec3 center = eye + vdir * near;\n    vec2 zuv = (uv - vec2(.5)) * iResolution.xy * zoom;\n    vec3 pix = center + zuv.x * xdir + zuv.y * up;\n    return pix - eye;\n}\n\nvec4 GridColor(vec2 uv) {\n    const float linewidth = .1;\n    //float order = log\n    float tickwidth = 10.;\n \tvec2 duv = fwidth(uv);\n    float fade = clamp(1.1 - max(duv.x, duv.y) / (tickwidth * .6), 0., 1.);\n    vec2 duv2 = duv;\n    duv *= linewidth;\n    duv2 += duv;\n    vec2 ticks = smoothstep(duv2, duv, abs(mod(uv + duv2, vec2(tickwidth)) - duv2)) * fade;\n    vec2 axis = smoothstep(duv2, duv, abs(uv)) * fade;\n    float axisv = max(axis.x, axis.y);\n    vec4 color = vec4(.15, .15, .15, 1.) * max(ticks.x, ticks.y) * (1. - axisv)\n        + vec4(1., .1, .1, 1.) * axisv;\n    return color;\n}\n\nvec4 Blend(vec4 bottom, vec4 top) { return bottom * (1. - top.a) + top; }\n\nfloat ttest(float t) { return step(0., t); }\n\n// E^(i*theta*lambda + phase)\nvec2 CExp(float theta, float lambda, float phase) {\n \tfloat v = theta * lambda + phase;\n    return vec2(cos(v),sin(v));\n}\n\n// ------------------------------------------------------------\n// Complex-valued function of x and y that is the super-position of complex waves.\n\nvec2 DemoWaves(float x, float y) {\n    float theta = atan(x, y);\n \tfloat d = length(vec2(x,y));\n    float t = -iTime;\n    \n    //------------------\n    // This is the place to play with the waves, try altering their direction and phaes etc...\n    \n    // Radial waves\n    vec2 radialwave = 1. * CExp(d, 1., t);\n    radialwave += CExp(d, 2., t * 1.01) * rands.x;\n    radialwave += CExp(-d, 3., t * 1.005) * rands.y;\n    \n    // Angular waves\n    vec2 angularwave = CExp(theta, 2., t * 1.07) * rands.z;\n    angularwave += CExp(-theta, 5., -t) * rands.w;\n    \n    return 1. * radialwave + 1. * angularwave;\n}\n\nvec2 CxyWaves(float x, float y) {\n    return DemoWaves(x, y);\n}\n\n// crappy complex coloring: Real = (red-green), Imaginary = (yellow-blue)\nvec4 CColor(vec2 c, vec2 weight) {  \n    const vec4 rcolor = vec4(1., 0.01, 0.01, 1.);\n    const vec4 rcolorn = vec4(0., 1., 0.01, 1.);\n    const vec4 icolor = vec4(.9, .9, 0.01, 1.);\n    const vec4 icolorn = vec4(0.01, 0.01, 1., 1.);\n\tvec4 realcolor = (rcolor* max(c.x, 0.) + (rcolorn) * max(-c.x, 0.));\n    realcolor.a = 1.;\n    vec4 imagcolor = (icolor * max(c.y, 0.) + (icolorn) * max(-c.y, 0.));\n    imagcolor.a = 1.;\n \tvec4 color = (realcolor * weight.x + imagcolor * weight.y);\n    return color;\n}\n\n// ----------------------------------------------------\n// Height field evaluation for a (complex-valued) function of two variables\nvec4 prevval = vec4(0.);  // used to detect isosurface crossing.\nvec4 Fxy(vec3 xyz) {\n\tconst float thickness = 1.;\n    \n\t// Evaluate the function.\n \tvec2 val = CxyWaves(xyz.x, xyz.z) * vec2(1., 1.);\n    \n    // Compute color.\n#if COMPONENTS\n    // Visualize real and imaginary parts as 2 height fields\n    vec2 dif = val - xyz.yy;\n    vec2 crossing = prevval.xy * dif;\n    vec2 stepwidth = prevval.xy - dif;\n    vec4 w = abs(vec4(prevval.xy, dif) / stepwidth.xyxy);\n    //w = vec4(1., 1., 0., 0.);\n    crossing = step(0.00000001, -crossing);\n    vec4 color = CColor(val * w.xy + prevval.zw * w.zw, crossing * .5) * .8;\n    prevval = vec4(dif, val);\n#else\n    // Visualize the amplitude of the wave function.\n    float d = length(val) - xyz.y;\n    float crossing = (prevval.z * d) < 0. ? 1. : 0.;\n    vec2 w = abs(vec2(prevval.z, d) / (prevval.z - d));\n\tvec4 color = CColor(val * w.x + prevval.xy * w.y, vec2(.5));\n    prevval.xyz = vec3(val, d);\n    color = color * crossing * .8;    \n#endif\n    \n    return color;\n}\n\n// ------------------------------------------------\n// A funtion of x, y, z, returns color. Volume-render 3D function.\n\nvec4 Fxyz(vec3 xyz) {\n    const float scale = 5.;\n    const float d = 1.;\n    float dist = length(xyz);\n    float amp = 1. / (1. + dist * dist);\n\tfloat wave = sin(dist * scale + iTime);\n    vec4 c = max(0., wave) * vec4(1., .1, .1, 1.) + max(0., -wave) * vec4(.1, .1, 1., 1.);\n \treturn  vec4(c.rgb, 1.) * amp;  \n}\n\n\nvec4 March(vec3 start, vec3 dir, float maxd, float dd) {\n    vec4 ddir = vec4(dir, 1.) * dd;\n    vec4 pos = vec4(start, 0.);\n    vec4 color = vec4(0.);\n    prevval = vec4(-pos.y);\n    for (int i = 0; i < kMarchSteps; ++i) {\n        float density = 1.;\n        \n#if HEIGHT_FIELD\n        // 2D height field.\n        vec4 c = Fxy(pos.xyz);\n#else \n        // 3D function volume rendering\n        vec4 c = Fxyz(pos.xyz);\n#endif        \n        \n        // axis clipping\n        //c = pos.z > 0. ? vec4(0.) : c; \n        \n        c = (pos.w > maxd ? vec4(0.) : c); // reject samples outside box\n        c.a = clamp(c.a, 0., 1.);  // insure we have good alpha values.\n        color = color + c * (1. - color.a);  // blending\n        pos += ddir;\n    }\n    return color;\n}\n\n// key is javascript keycode: http://www.webonweboff.com/tips/js/event_key_codes.aspx\nbool ReadKey( int key, bool toggle )\n{\n\tfloat keyVal = texture( iChannel1, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool one = ReadKey( 49, true );\n    bool two = ReadKey( 50, true );\n    bool three = ReadKey( 51, true );\n\n    float theta = iMouse.x / iResolution.x * twopi;\n    if (one) {  // 1 key toggles orbit\n        theta += iTime * .2;\n    }\n    vec2 cossin = vec2(cos(theta), sin(theta));\n    eye.x = kEye.x * cossin.x - kEye.z * cossin.y;\n    eye.z = kEye.x * cossin.y + kEye.z * cossin.x;\n\n    eye.y -= (iMouse.y > 0. ? 1. : 0.) * (iMouse.y - iResolution.y * .5) * .3;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \t\n    rands = vec4(.5) + .5 * cos(vec4(iTime) * vec4(1., -.997, 1.13, 1.21) * .5 + vec4(13., 17., 19., 23.));\n\t// 2 key toggles random coefficients.\n    rands = two ? vec4(1.) : rands;\n\trands = smoothstep(.3, .6, rands);\n    \n    vec3 ray = GetRayDir(uv);\n    float rayd = length(ray);\n    float invrayd = 1. / rayd;\n\n#if 1\n    // jittering expariment, .\n    vec4 noise = texture(iChannel0, uv / fwidth(uv) / 255.);\n    vec3 jitterStart = ray * invrayd * (.5 - noise.x) * 2.;\n    //jitterStart = mix(vec3(0.), jitterStart, (1. + sin(iTime)) * .5);\n#else\n    vec3 jitterStart = vec3(0.);     \n#endif\n    \n    // Domain grid. (not yet integrated with the sceen correctly)\n    vec4 xzplane = HitXZPlane(eye, ray);\n    vec4 xzgrid = GridColor(xzplane.xz) * ttest(xzplane.w);\n    vec4 xyplane = HitXYPlane(eye, ray);\n    vec4 xygrid = GridColor(xyplane.xy) * ttest(xyplane.w);\n    vec4 gridcolor = Blend(xzgrid * .5, xygrid * .1);\n    \n    // Set up the function domain.\n    float boxscale = 5.;\n    vec3 boxsize = vec3(3., 1., 3.) * boxscale;\n    vec4 boxhit = HitBox(-boxsize, boxsize, eye, ray);\n    \n    // Set up step size and stopping distance\n    float backlen = boxhit.w * rayd; \n   \tfloat dr =  backlen / float(kMarchSteps); //sqrt(2.) * 2. * boxscale / float(kMarchSteps);\n    \n    // March!\n    vec4 marchColor = March(boxhit.xyz + jitterStart * dr, ray * invrayd, backlen, dr) * ttest(boxhit.w);\n\n    fragColor = vec4(Blend(backgroundColor, Blend(gridcolor * 1., Tone(marchColor))));\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltsXD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[565, 565, 611, 611, 690], [691, 691, 712, 712, 748], [749, 749, 771, 771, 810], [812, 812, 851, 851, 922], [924, 924, 963, 963, 1034], [1036, 1107, 1164, 1164, 1547], [1549, 1549, 1574, 1574, 1891], [1893, 1893, 1918, 1918, 2488], [2490, 2490, 2525, 2525, 2563], [2565, 2565, 2587, 2587, 2609], [2611, 2641, 2692, 2692, 2762], [2912, 2912, 2946, 2946, 3517], [3519, 3519, 3552, 3552, 3582], [3584, 3658, 3692, 3692, 4162], [4164, 4361, 4381, 4381, 5312], [5434, 5434, 5455, 5455, 5747], [5750, 5750, 5806, 5806, 6514], [6763, 6763, 6820, 6820, 8831]], "test": "error"}
{"id": "ltsXD8", "name": "raytracing demo", "author": "zephmann", "description": "raytracing demo for freddev", "tags": ["raytracing"], "likes": 8, "viewed": 216, "published": "Public", "date": "1436512194", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float eps = 0.0001;\n\n// a point and a directional light\nvec3 dl = normalize(vec3(-1.0, -1.0, 1.0));\nvec3 pl = vec3(5.0, 10.0, -5.0);\n\n// ground normal and point in plane\nvec3 gn = vec3(0.0, 1.0, 0.0);\nvec3 gp = vec3(0.0, 0.0, 0.0);\nvec3 gc = vec3(0.6);\n\n// first sphere\nvec3 sp1 = vec3(-3.0, 2.0, 0.0);\nfloat sr1 = 9.0;\nvec3 sc1 = vec3(0.8, 0.1, 0.7);\n\n// second sphere\nvec3 sp2 = vec3(3.0, 3.0, 2.0);\nfloat sr2 = 16.0;\nvec3 sc2 = vec3(0.0);//vec3(0.1, 0.6, 0.8);\n\n// ray plane intersection\n// returns the length along the ray to the point of intersection\n// returns -1.0 if the ray misses the object\nfloat ground(vec3 ro, vec3 rd) {\n    float t = -1.0;\n    \n    float denom = dot(gn, rd);\n    \n    if(abs(denom) > eps) {\n        float tt = dot((gp- ro), gn) / denom;\n        \n        if(tt > 0.0)\n        \tt = tt;\n    }\n    \n    return t;\n}\n\n// ray sphere intersection\n// returns the length along the ray to the point of intersection\n// returns -1.0 if the ray misses the object\nfloat sphere(vec3 ro, vec3 rd, vec3 sp, float sr) {\n    float t = -1.0;\n    \n    vec3 l = sp - ro;\n    float tca = dot(l, rd);\n    float d2 = dot(l, l) - tca*tca;\n    \n    if(d2 <= sr) {\n        float thc = sqrt(sr - d2);\n        \n        float t0 = tca - thc;\n        float t1 = tca + thc;\n        \n        if(t0 > t1) {\n            float temp = t0;\n            t1 = t0;\n            t0 = temp;\n        }\n        \n        t = t0 < 0.0 ? t0 : t0;\n    }\n    \n    return t;\n}\n\n// calc the surface shading\n// nn is the normalized normal\n// p is the intersection point\n// i is the direction from the camera\n// sc is the surface's base color\nvec3 shade(vec3 nn, vec3 p, vec3 i, vec3 sc) {\n    float amb = 0.1;\n    \n    vec3 l = vec3(0.0);\n    \n    // switch between point and directional lights\n    if(true)\n    \tl = normalize(pl - p);\n    else\n    \tl = -dl;\n    \n    float diff = max(dot(nn, l), 0.0);\n    \n    vec3 h = normalize((-i + l) * 0.5);\n    float spec = max(dot(nn, h), 0.0);\n    spec = pow(spec, 100.0);\n    \n    return sc * (diff + amb) + vec3(spec);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // get the screen space coords of our pixel\n    // map from (0, width, 0, height) to (-1, 1, -1, 1)\n    float delta = 2.0 / iResolution.y;\n    vec2 uv = ((fragCoord.xy - iResolution.xy*0.5) * delta);\n    \n    vec3 fc = vec3(0.0);  // stores the final surface color\n    \n    float sinTime = sin(iTime * 0.25);\n    float cosTime = cos(iTime * 0.25);\n    \n    // 4x4 supersampling to try to reduce aliasing\n    for(float j = 0.0; j < 16.0; j++) {\n        \n        float rs = 1.0; // reflection contribution\n    \n        // offset the camera direction for the super sampling\n        float tempx = mod(j, 4.0);\n        float tempy = floor(j * 0.25);\n        tempx = (tempx*0.333 - 0.5) * delta;\n        tempy = (tempy*0.333 - 0.5) * delta;\n        \n        // define camera origin and ray direction for pixel\n        vec3 ro = vec3(sinTime * 35.0, 7.0 + sinTime, cosTime * -35.0);\n        vec3 rd = normalize(vec3(uv.x + tempx, uv.y + tempy - 0.75, 5.0));\n        \n        // rotate the direction\n        tempx = rd.x;\n        rd.x = cosTime*rd.x - sinTime*rd.z;\n        rd.z = cosTime*rd.z + sinTime*tempx;\n\n        // for loop for the ray depth\n        float t;\n        int index;\n        for(int i = 0; i < 4; i++) {\n\n            // if we are still reflecting light\n            if(rs > 0.05) {\n                t = 1000000.0;\n                index = -1;\n\n                // check ground intersection\n                float temp = ground(ro, rd);\n                if( temp > eps && temp < t) {\n                    t = temp;\n                    index = 0;\n                }\n\n                // check our sphere\n                temp = sphere(ro, rd, sp1, sr1);\n                if(temp > eps && temp < t) {\n                    t = temp;\n                    index = 1;\n                }\n\n                temp = sphere(ro, rd, sp2, sr2);\n                if(temp > eps && temp < t) {\n                    t = temp;\n                    index = 2;\n                }\n\n                // we hit something, so calc surface color\n                if(index > -1) {\n                    vec3 p = ro + rd * t;\n                    vec3 nn = vec3(0.0);\n\n                    vec3 surf = vec3(0.0);\n\n                    // shade the ground plane\n                    if(index == 0) {\n                        nn = gn;\n\n                        surf = shade(gn, p, rd, gc);\n\n                        if(mod(floor(p.x * 0.25),2.0) != mod(floor(p.z * 0.25),2.0)) {\n                            surf = vec3(0.1);\n                        }\n\n                        surf *= rs;\n\n                        rs *= 0.1;\n                    }\n\n                    // shade the first \"plastic\" sphere\n                    else if(index == 1) {\n                        nn = normalize(p - sp1);\n\n                        surf = shade(nn, p, rd, sc1) * rs;\n\n                        rs *= 0.1;\n                    }\n\n                    // shade the second \"mirror\" sphere\n                    else if(index == 2) {\n                        nn = normalize(p - sp2);\n\n                        surf = shade(nn, p, rd, sc2) * rs;\n                        rs *= 0.9;\n                    }\n\n                    // add our current surface color to the final color\n                    fc += surf;\n\n                    // calculate the reflected ray's direction and origin\n                    rd = normalize(rd - 2.0*nn*dot(nn, rd));\n                    ro = p;\n\n                }\n\n                // we missed, stop tracing\n                else {\n                    float temp = max(rd.y, 0.15);\n                    fc += vec3(temp, temp, 1.0) * rs;\n                    rs = 0.0;\n                }\n            }\n        }\n    }\n    \n    // average all the samples contributions\n    fc *= 0.0625;\n    \n    fragColor = vec4(fc, 1.0);\n    \n    // uncomment to check uvs\n    //fragColor = vec4(uv, 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltsXD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[471, 607, 639, 639, 847], [849, 986, 1037, 1037, 1458], [1460, 1622, 1668, 1668, 2045], [2048, 2048, 2105, 2209, 5953]], "test": "valid"}
{"id": "ltsXzj", "name": "arch", "author": "rimina", "description": "prototyping and testing stuff.\n\nAmbient occlusion method used is from here :  https://www.shadertoy.com/view/4sdGWN\nThe marcher in test is implemented according to this article : http://diglib.eg.org/handle/10.2312/stag.20141233.001-008", "tags": ["raymarching", "coordinates", "prototyping", "bendingspace"], "likes": 1, "viewed": 145, "published": "Public", "date": "1438210971", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3 AMBIENT = vec3(0.6);\nconst vec3 DIFFUSE = vec3(0.6);\nconst vec3 SPECULAR = vec3(0.4, 0.35, 0.4);\n\n//Adjust for your screen\nconst vec3 GAMMA = vec3(2.2);\n\nconst float PI = 3.14159265359;\n\nfloat sgn(float x) {\n\treturn (x<0.)?-1.:1.;\n}\n\nfloat box( vec3 p, vec3 b ){\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0)+length(max(d,0.0));\n}\n\nvec3 rotateY(vec3 p, float a){\n  float c = cos(a);\n  float s = sin(a);\n  vec3 q = p;\n  q.x = c * p.x + s * p.z;\n  q.z = -s * p.x + c * p.z;\n  return q;\n}\n\nvec3 rotateZ(vec3 p, float a){\n  float c = cos(a);\n  float s = sin(a);\n  vec3 q = p;\n  q.x = c * p.x - s * p.y;\n  q.y = s * p.x + c * p.y;\n  return q;\n}\n\nfloat repeat(float p, float c){\n  return mod(p+(.5*c), c)-.5*c;\n}\n\nfloat distf(vec3 p){\n    \n  float r = length(p);\n  float theta = atan(p.y/p.x);\n  float phi = atan(p.x, p.y);\n  \n  vec3 pos = vec3(r, theta, phi);\n  pos.x = repeat(pos.x, 4.);\n  \n  float kaari = box(pos, vec3(1.0));\n  return kaari;\n}\n\nvec3 normals(vec3 p){\n  vec3 eps = vec3(1.0/iResolution.x, 0., 0.);\n  vec3 n = vec3(\n    distf(p+eps.xyy) - distf(p-eps.xyy),\n    distf(p+eps.yxy) - distf(p-eps.yxy),\n    distf(p+eps.yyx) - distf(p-eps.yyx));\n  return normalize(n);\n}\n\nfloat march(vec3 orig, vec3 dir, float far){  \n  float t = .0001;\n  float step = 0.;\n  \n  float omega = 1.;\n  float prev_radius = 0.;\n  \n  float candidate_t = t;\n  float candidate_error = 1000.;\n    \n   vec3 p = vec3(0.);\n  \n  float sg = sgn(distf(orig));\n  for(int i = 0; i < 64; ++i){\n    p = dir*t+orig;\n    float sg_radius = sg*distf(p);\n    float radius = abs(sg_radius);\n    \n    bool fail = omega > 1. && (radius+prev_radius) < step;\n    if(fail){\n      step -= omega * step;\n      omega = 1.;\n    }\n    else{\n      step = sg_radius*omega;\n    }\n    prev_radius = radius;\n    float error = radius/t;\n    \n    if(!fail && error < candidate_error){\n      candidate_t = t;\n      candidate_error = error;\n    }\n    if(!fail && error < (.5/iResolution.x) || t > far){\n      break;\n    }\n    t += step;\n  }\n    \n  float er = candidate_error;\n    for(int j = 0; j < 6; ++j){\n        float radius = abs(sg*distf(p));\n        p = p + dir*(radius-er);\n        t = length(p-orig);\n        er = radius/t;\n        \n        if(er < candidate_error ){\n            candidate_t = t;\n            candidate_error = er;\n        }\n   }  \n    \n  if(t > far || candidate_error > (.5/iResolution.x)){\n    return t;\n  }\n  return candidate_t;\n}\n\nvec3 render(in vec3 orig, in vec3 dir, out vec3 n, out float t, in float far){\n  t = march(orig, dir, far);\n  vec3 p = t*dir+orig;\n  if(t < far){\n    n = normals(p);\n  }\n  return p;\n}\n\n//Testing the ambient occlusion method from here : https://www.shadertoy.com/view/4sdGWN\nfloat hash( float n )//->0:1\n{\n    return fract(sin(n)*3538.5453);\n}\n\nvec3 randomSphereDir(vec2 rnd)\n{\n\tfloat s = rnd.x*PI*2.;\n\tfloat t = rnd.y*2.-1.;\n\treturn vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\n\nvec3 randomHemisphereDir(vec3 dir, float i)\n{\n\tvec3 v = randomSphereDir( vec2(hash(i+1.), hash(i+2.)) );\n\treturn v * sgn(dot(v, dir));\n}\n\nfloat ambientOcclusion( in vec3 p, in vec3 n, float maxDist, float falloff )\n{\n\tconst int nbIte = 32;\n    const float nbIteInv = 1./float(nbIte);\n    const float rad = 1.-1.*nbIteInv; //Hemispherical factor (self occlusion correction)\n    \n\tfloat ao = 0.0;\n    \n    for( int i=0; i<nbIte; i++ )\n    {\n        float l = hash(float(i))*maxDist;\n        vec3 rd = normalize(n+randomHemisphereDir(n, l )*rad)*l; // mix direction with the normal\n        \t\t\t\t\t\t\t\t\t\t\t\t\t    // for self occlusion problems!\n        \n        ao += (l - distf( p + rd )) / pow(1.+l, falloff);\n    }\n\t\n    return clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\n\nvec3 shading(vec3 n, vec3 p, vec3 ld, vec3 dir, vec3 orig){    \n    float nl = dot(n,ld);\n    float intensity = clamp(nl, 0. ,1.);\n    \n    vec3 refDir = reflect(-ld, n);\n\n    float angle = max(dot(refDir, dir), 0.);\n    float spec = pow(angle, 0.4);\n\n    float ao = ambientOcclusion(p, n, 5.0, 0.5);\n    vec3 color = vec3(ao*AMBIENT + intensity*DIFFUSE*0.4 + spec*SPECULAR*0.4);\n  \n  return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float FAR = 20.;\n  vec2 a = -1.0+2.0*(fragCoord.xy.xy/iResolution.xy);\n  a.x *= iResolution.x/iResolution.y;\n    \n    \n  vec3 target = vec3(0.0, 0.0, -1.0);\n  vec3 orig = vec3(0.0, 5.0, 100.0-1.8*iTime);\n  \n  vec3 cw = normalize(target-orig);\n  vec3 cu = normalize(cross(cw,vec3(0., 1.,0.)));\n  vec3 cv = normalize(cross(cu,cw));\n  mat3 camera = mat3(cu, cv, cw);\n  \n  vec3 dir = normalize(camera*vec3(a, 1.57));\n  vec3 n = vec3(0.);\n  float t = FAR;\n  vec3 p = render(orig, dir, n, t, FAR);\n\n  vec3 light = (target-orig)/distance(target, orig);\n    \n  vec3 col = vec3(0.);\n  if(t < FAR){\n    col = shading(n, p, light, dir, orig);\n    //Bit glow to the near parts\n  \tcol =  smoothstep(0., 1., col*(FAR/t*0.2));\n  }\n\n  float dist = length(p-orig);\n  float fogAmount = 1.0 - exp( -dist*.03);\n  col = mix(col, vec3(0.8), fogAmount);\n    \n  col = pow(col, 1.0/GAMMA);\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltsXzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[198, 198, 218, 218, 243], [245, 245, 273, 273, 358], [360, 360, 390, 390, 513], [515, 515, 545, 545, 667], [669, 669, 700, 700, 734], [736, 736, 756, 756, 969], [971, 971, 992, 992, 1204], [1206, 1206, 1250, 1250, 2431], [2433, 2433, 2511, 2511, 2616], [2618, 2707, 2737, 2737, 2775], [2777, 2777, 2809, 2809, 2912], [2914, 2914, 2959, 2959, 3050], [3052, 3052, 3130, 3130, 3669], [3672, 3672, 3731, 3731, 4072], [4075, 4075, 4132, 4132, 5031]], "test": "valid"}
{"id": "ltXSDN", "name": "Starfield!", "author": "Kos", "description": "Parallax stars!", "tags": ["2d", "parallax"], "likes": 7, "viewed": 650, "published": "Public", "date": "1436810346", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 aspect;\nvec2 uv;\nvec2 pan;\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(32.9898,78.233))) * 43758.5453);\n}\n\nfloat rand1(float i) {\n    return rand(vec2(i, i));\n}\n\nvec4 star(int n) {\n    float fn = float(n);\n    vec2 p = vec2(\n        rand1(0.12+float(n))* 3.,\n        rand1(0.5+float(n)) * 3.);\n   \tfloat pf = rand1(fn*0.63)*0.5+0.5;\n    p += pan*pf;\n    p = mod(p, 3.);\n    p -= vec2(0.5);\n    \n    vec3 rgb = vec3(\n        rand1(0.654*fn),\n        rand1(0.953*fn),\n        rand1(0.123*fn));\n    \n    float blink = rand1(0.868*fn)+0.8;\n    \n    float dist = length(uv-p);\n\t\n    float i;    \n    i = 0.002 * pow(length(uv-p), -1.2) * pf;\n    \n    if (rand1(0.589*fn*iTime) > blink) {\n        i *= 0.5;\n    }\n    \n    return vec4(rgb*i, 1);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    aspect = iResolution.xy / min(iResolution.x, iResolution.y);\n\tuv = fragCoord.xy / min(iResolution.x, iResolution.y);\n    \n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    fragColor = vec4(0);\n    \n    pan = vec2(sin(iTime)+cos(iTime*0.21),\n               sin(iTime*0.52)+cos(iTime*0.36));\n    \n    for (int i=0; i<200; ++i) {\n        fragColor += star(i);\n    }\n    \n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltXSDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[33, 33, 53, 53, 125], [127, 127, 149, 149, 180], [182, 182, 200, 200, 761], [763, 763, 820, 820, 1199]], "test": "valid"}
{"id": "ltXSRS", "name": "Abstract Cave", "author": "anlumo", "description": "Went into a more abstract direction from the cave.", "tags": ["nuclai15"], "likes": 0, "viewed": 217, "published": "Public", "date": "1437468734", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3 fog_color = vec3(0.7,0.85,1.0);\nconst float fog_density = 0.02;\n\n//-------------------------------------------------------------------------\n// MAP\n//\n// The cave structure is represented algorithmically as a signed\n// distance field:\n//      - positive numbers mean empty space\n//      - negative numbers are solid space\n//\n// This distance is returned as the .x component of a 2D vector, and\n// the .y component represents an optional texture \"number\".\n//-------------------------------------------------------------------------\nvec2 mapCave( in vec3 pos )\n{\n    // ---- CEILING ----\n\n    float ceiling_y =\n        // global offset upwards of ceeling\n        0.1 + sin(iTime*3.1415926 / 10.0) / 4.0\n\t;\n    \n   \t// ---- FLOOR ----\n           \n    float floor_y =\n        // global offset downwards of floor\n        0.7\n        // curve minimum around origin and slopes upward\n        +1.0 - 0.25 * sqrt(pos.x*pos.x + pos.z*pos.z)\n    ;\n    \n    floor_y += (sin(pos.x*3.1415926*4.0) + sin(pos.z*3.1415926*4.0))/8.0;\n    floor_y += sin(iTime*3.1415926*pos.x*pos.z);\n\n    // The cave is made up of two planes with variable offsets.  \n    return vec2( min(pos.y + floor_y, -pos.y + ceiling_y), 0.0 );\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map(in vec3 pos) {\n    return opU(mapCave(pos), vec2(sdTorus(pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05)), 25.0));\n}\n\n//----------------------------------------------------------------------\n// TEXTURE\n//\n// The texture of the cave is computed based on a 3D position, usually\n// around the contour where the signed distance field is zero.  This\n// function also takes the material returned from the map() function,\n// and then computes a color as a 3D vector. \n//----------------------------------------------------------------------\nvec3 texture( in vec3 pos, in float mat )\n{    \n    // Default texture for the cave. This is currently a checkerboard.\n//    float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n    float f = (sin(pos.z*3.1415926*10.0) + sin(pos.x*3.1415926*10.0) + 1.0)/2.0;\n    return 0.2 + 0.1*f*vec3(0.2, (sin(iTime*3.1415926 * 100.0)+1.0) / 2.0, 1.0);\n}\n\n//----------------------------------------------------------------------\n// RENDERING\n//\n// A form of ray marching is used to trace through the signed distance\n// field, then perform simple physically-based lighting.\n//\n// NOTE: You shouldn't need to change this unless you need more advanced\n// customizations of the rendering process (e.g. reflections).\n//----------------------------------------------------------------------\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 0.1;\n    float tmax = 12.0;\n    float scale = 0.1;\n\tfloat precis = 0.0001;\n    float t = tmin;\n    float m = -1.0;\n\tvec2 last = vec2(0.0, 0.0);\n    for( int i=0; i<500; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( abs(res.x)<precis || t>tmax ) break;\n        if( res.x * last.x < 0.0 ) {\n            scale *= 0.5;\n        }\n        else if (res.x > last.x) {\n        \tscale = min(0.1, scale * 2.0);\n\t\t}\n        t += res.x * scale;\n\t    m = res.y;\n        last = res;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.8, 0.9, 1.0);\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n\n        col = texture(pos, m);\n\n        // Lighting calculations.  \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(0.0, 1.0, 0.0) - pos );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n\n        // You can customize the weights and colors\n        // for each of these lighting components. \n\t\tvec3 brdf = vec3(0.0);\n        brdf += 1.20*dif;\n\t\tbrdf += 1.20*spe*dif;\n        brdf += 0.30*amb*occ;\n        brdf += 0.40*dom*occ;\n        brdf += 0.30*bac*occ;\n        brdf += 0.40*fre*occ;\n\t\tbrdf += 0.02;\n\t\tcol = col*brdf;\n\n        // Fog calculation.\n    \t//col = mix( col, fog_color, 1.0-exp( -fog_density*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\n//----------------------------------------------------------------------\n// MAIN\n//----------------------------------------------------------------------\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\n    // Camera origin and target. \n\tfloat time = 15.0 + iTime;\n\tvec3 ro = vec3( -0.5+3.2*cos(0.1*time + 6.0*mo.x), mo.y-0.5, 0.5 + 3.2*sin(0.1*time + 6.0*mo.x) );\n\tvec3 ta = vec3( -0.5, -0.4, 0.5 );\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // Ray direction.\n\tvec3 rd = ca * normalize( vec3(p.xy,2.5) );\n\n    // Render this pixel.\n    vec3 col = render( ro, rd );\n\tcol = pow( col, vec3(0.4545) );\n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltXSRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 542, 571, 596, 1210], [1212, 1212, 1245, 1245, 1298], [1300, 1300, 1330, 1330, 1363], [1365, 1365, 1388, 1388, 1484], [1486, 1902, 1945, 2084, 2248], [2250, 2679, 2711, 2711, 2932], [2934, 2934, 2976, 2976, 3275], [3277, 3277, 3317, 3317, 3871], [3873, 3873, 3912, 3912, 5177], [5179, 5333, 5385, 5385, 5562], [5564, 5564, 5621, 5621, 6202]], "test": "valid"}
{"id": "ltXXW4", "name": "Warp Experiment 3", "author": "aiekick", "description": "texture warping by metaballs \nuse mouse for move the last metawarpingball :)", "tags": ["warpexperiment3"], "likes": 3, "viewed": 1381, "published": "Public API", "date": "1436755829", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvec3 mBallWarp(vec2 uv, vec2 pos, float radius)\n{\n   \tuv = length(uv-pos) * vec2(0.7);\n\treturn vec3(uv,radius/dot(uv,uv));\n}\n\nvoid mainImage( out vec4 f, in vec2 v )\n{\n    float \n        t = iTime*1.,\n        r = 2e-3,\n    \tz = 1.;\n    \n    vec2 \n        s = iResolution.xy,\n        mo = (2.*iMouse.xy-s)/s.y * z;\n    \n    v = (v+v-s)/s.y * z;\n    \n\t\n    vec3 mb = mBallWarp(v, vec2(0.), r);  \n    mb += mBallWarp(v, vec2(cos(t),sin(t))*.4, r);  \n    mb += mBallWarp(v, vec2(cos(-t),0.5*sin(-t))*.8, r);  \n    mb += mBallWarp(v, vec2(2.*cos(-t),sin(t))*.8, r); \n    \n    if (iMouse.z > 0.)\n\t\tmb += mBallWarp(v, mo, r);  \n    \n    f = texture(iChannel0, mb.xy) + mb.z;\n}\n", "image_inputs": [{"id": "XsXGRn", "previewfilepath": "/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltXXW4.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[138, 138, 187, 187, 262], [264, 264, 305, 305, 807]], "test": "error"}
{"id": "ltXXzS", "name": "Aliasing1", "author": "SonOfLilit", "description": "A one line animation based on float aliasing. Even prettier in full screen.", "tags": ["floataliasing"], "likes": 1, "viewed": 112, "published": "Public", "date": "1437507804", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = vec4(1.0, 1.0, 1.0, 1.0) * mod(0.91 * fragCoord.x + 0.19 * fragCoord.y + sin(iTime * 1e-4), 1e-10) * 2e5;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltXXzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 181]], "test": "valid"}
{"id": "MlfSD8", "name": "REND1", "author": "dennixtreme", "description": "x", "tags": ["workshop"], "likes": 1, "viewed": 105, "published": "Public", "date": "1436278406", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// --- Maths\n// -----------------------------------------------------------------------------------------------\n//\n\nvec3 Rotate(vec3 p, float x, float y, float z)\n{\n    vec4 pos = vec4(p, 1.0);\n    \n    // --- EX3: implement rotation transforms using vec4 !!!\n\tmat4 rx = mat4(1.0,    0.0,    0.0,  0.0,\n                   0.0, cos(x), -sin(x), 0.0,\n                   0.0, sin(x),  cos(x), 0.0,\n                   0.0,    0.0,     0.0, 1.0);\n    \n\tmat4 ry = mat4(cos(y), 0.0, -sin(y), 0.0,\n                      0.0, 1.0,     0.0, 0.0,\n                   sin(y), 0.0,  cos(y), 0.0,\n                      0.0, 0.0,     0.0, 1.0);\n    \n\tmat4 rz = mat4(cos(z), -sin(z), 0.0, 0.0,\n                   sin(z),  cos(z), 0.0, 0.0,\n                      0.0,     0.0, 1.0, 0.0,\n                      0.0,     0.0, 0.0, 1.0);\n\n\tvec4 rpos = pos * rz * ry * rx;\n    return rpos.xyz;\n}\n\nvec3 Scale(vec3 p, float sx, float sy, float sz)\n{\n    vec4 pos = vec4(p, 1.0);\n    \n    // --- EX2: implement scale transform using vec4 !!!\n    mat4 s = mat4(sx, 0.0, 0.0, 0.0, \n                  0.0, sy, 0.0, 0.0, \n                  0.0, 0.0, sz, 0.0, \n                  0.0, 0.0, 0.0, 1.0);\n    vec4 spos = s * pos;\n    return spos.xyz;\n}\n\nvec3 Translate(vec3 p, float tx, float ty, float tz)\n{\n    vec4 pos = vec4(p, 1.0);\n    \n    // --- EX1: implement translation tranform using vec4 !!!\n    mat4 t = mat4(1.0, 0.0, 0.0, tx,\n                  0.0, 1.0, 0.0, ty,\n                  0.0, 0.0, 1.0, tz,\n                  0.0, 0.0, 0.0, 1.0);\n    vec4 tpos = pos * t;\n    return tpos.xyz;\n}\n\n// --- SDF shapes\n// -----------------------------------------------------------------------------------------------\n//\n\nfloat Sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat Torus(vec3 p, vec2 r)\n{\n  vec2 q = vec2(length(p.xz) - r.x, p.y);\n  return length(q) - r.y;\n}\n\n// --- SDF operations\n// -----------------------------------------------------------------------------------------------\n//\n\nvec2 Union(vec2 d1, vec2 d2)\n{\n    return d1.x < d2.x ? d1 : d2;\n}\n\n// --- main stuff\n// -----------------------------------------------------------------------------------------------\n//\n\nvec2 Scene(vec3 p)\n{\n    // --- initial positions\n    vec3 ps1 = p;\n    vec3 ps2 = p - vec3(2.0, 0.0, 0.0);\n    vec3 pt = p + vec3(2.0, 0.0, 0.0);\n    \n    // --- update positions\n    float stime = sin(iTime);\n    float ctime = cos(iTime);\n    float sf = 1.0 - abs(stime) * 0.5;\n    ps1 = Scale(ps1, sf, sf, sf);\n    \n    float rfx = stime;\n    float rfy = stime;\n    float rfz = ctime;\n    pt = Rotate(pt, rfx, rfy, rfz);\n    \n    ps2 = Translate(ps2, 0.0, stime, 0.0);\n    \n    // --- compute shapes (SDF estimation, material index)\n    vec2 torus = vec2(Torus(pt, vec2(0.55, 0.1)), 1.0);\n    vec2 sphere0 = vec2(Sphere(ps1, 0.25), 2.0);\n    vec2 sphere1 = vec2(Sphere(ps2, 0.25), 3.0);\n    \n    // --- compute SDF for scene\n    return Union(torus, Union(sphere0, sphere1));\n}\n\nvec3 RayMarch(vec3 origin, vec3 direction)\n{\n    float maxDist = 200.0;\n    float totalDistance = 0.0;\n    int totalSteps = 0;\n    float selectedMaterial = 0.0;\n    for (int steps = 0; steps < 100; ++steps)\n    {\n        vec3 point = origin + totalDistance * direction;\n        vec2 dist = Scene(point);\n        if (dist.x < 0.0002 || totalDistance > maxDist)\n            break;\n        totalDistance += dist.x;\n        totalSteps++;\n        selectedMaterial = dist.y;\n    }\n    if (totalDistance > maxDist)\n    \tselectedMaterial = 0.0;\n    return vec3(totalDistance, selectedMaterial, float(totalSteps) / 200.0);\n}\n\nvec3 Normal(vec3 pos)\n{\n    vec3 eps = vec3(0.0001, 0.0, 0.0);\n    vec3 pos00 = (pos + eps.xyy);\n    vec3 pos01 = (pos - eps.xyy);\n    vec3 pos10 = (pos + eps.yxy);\n    vec3 pos11 = (pos - eps.yxy);\n    vec3 pos20 = (pos + eps.yyx);\n    vec3 pos21 = (pos - eps.yyx);\n\tvec3 normal = vec3(Scene(pos00).x - Scene(pos01).x, \n                       Scene(pos10).x - Scene(pos11).x, \n                       Scene(pos20).x - Scene(pos21).x);\n\treturn normalize(normal);\n}\n\nvec3 Render(vec3 origin, vec3 direction, vec2 uv)\n{\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    vec3 res = RayMarch(origin, direction);\n    \n    // --- background\n    color = mix(vec3(1.00, 0.90, 0.60), vec3(0.50, 0.70, 1.00), pow(uv.y * 0.5 + 0.5, 0.5)) * 0.7;\n    \n    // --- if we have a material\n    if (res.y > 0.0)\n    {\n        // --- get surface normal\n    \tvec3 newPos = origin + res.x * direction;\n    \tvec3 normal = Normal(newPos);\n        \n        // --- ambient color\n        vec3 ambient = vec3(0.50, 0.70, 1.00) * 0.1;\n        vec3 lightDirection = normalize(vec3(0.6, 0.7, 0.5));\n        \n        // --- diffuse lighting\n        vec3 diffuse = vec3(1.0);\n        float ndotl = clamp(dot(normal, lightDirection), 0.0, 1.0);\n        \n        // --- EX4: compute diffuse lighting with given direction and color !!!\n        \n        if (res.y > 0.95)\n            diffuse *= vec3(0.7, 0.0, 0.0) * texture(iChannel0, newPos.xy).rgb;\n       \tif (res.y > 1.95)\n           diffuse = vec3(0.0);\n        if (res.y > 2.95)\n            diffuse = vec3(0.0);\n        \n        diffuse *= ndotl;\n        // --- half-vector\n        vec3 halfVector = normalize(lightDirection - direction);\n        \n        // --- fresnel\n        vec3 reflectance = vec3(0.0);\n        vec3 fresnel = vec3(0.0);\n        \n        // --- material specific stuff for the torus\n        if (res.y > 0.95)\n            reflectance = vec3(0.04); // plastic\n        if (res.y > 1.95)\n            reflectance = vec3(1.022, 0.782, 0.344); // gold\n        if (res.y > 2.95)\n            reflectance = vec3(0.955, 0.638, 0.538); // copper\n                 \n        float ldoth = 1.0 - dot(normal, halfVector);\n        fresnel = reflectance + (1.0 - reflectance) * pow(ldoth, 5.0);\n        // --- EX5: compute fresnel !!!\n        \n        // --- NDF stuff\n        float ndoth = clamp(dot(normal, halfVector), 0.0, 1.0);\n        \n        float roughness = 0.0;\n        if (res.y > 0.95)\n            roughness = 0.4;\n        if (res.y > 1.95)\n            roughness = 0.4;\n        if (res.y > 2.95)\n            roughness = 0.2;\n        \n        float atrsqr = pow(roughness, 4.0);\n        float num = pow((pow(ndoth, 2.0) * (atrsqr - 1.0) + 1.0), 2.0);\n        // --- EX6: compute NDF !!!!\n\t\tfloat D = atrsqr/(num*3.1415926535);\n       \tvec3 specular = vec3(D);\n        \n        // --- final color\n        color = diffuse + specular * fresnel * ndotl;\n        //color = fresnel;\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 offsets[5];\n    offsets[0] = vec2(0.0, 0.0);\n    offsets[1] = vec2(0.5, 0.0);\n    offsets[2] = vec2(-0.5, -0.0);\n    offsets[3] = vec2(0.0, 0.5);\n    offsets[4] = vec2(0.0, -0.5);\n    \n    vec2 mo = iMouse.xy / iResolution.xy;\n    \n    vec3 cam_pos = vec3(-0.3 + mo.x * 2.0, -0.2 + mo.y * 2.0, 3.0);\n    vec3 cam_up = vec3(0.0, 1.0, 0.0);\n    vec3 cam_right = vec3(1.0, 0.0, 0.0);\n    vec3 cam_forward = normalize(cross(cam_up, cam_right));\n    float focal_length = 1.77;\n    vec3 color = vec3(0.0);\n    \n    for (int i = 0; i < 1; ++i)\n    {\n        vec2 coords_ss = (fragCoord.xy + offsets[i]) / iResolution.xy;\n    \tvec2 coords_cs = 2.0 * coords_ss - 1.0;\n   \t \tcoords_cs.x *= iResolution.x / iResolution.y;\n        \n        vec3 ray_d = normalize(cam_forward * focal_length + cam_right * coords_cs.x + cam_up * coords_cs.y);\n    \tvec3 ray_o = cam_pos;\n    \n        color += Render(ray_o, ray_d, coords_cs);\n    }\n    \n    //color /= 5.0;\n\tcolor = pow(color, vec3(0.4545));\n\n    fragColor = vec4(color, 1.0);\n}\n\n", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlfSD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[117, 117, 165, 165, 873], [875, 875, 925, 925, 1217], [1219, 1219, 1273, 1273, 1567], [1690, 1690, 1721, 1721, 1749], [1751, 1751, 1780, 1780, 1850], [1977, 1977, 2007, 2007, 2043], [2166, 2166, 2186, 2215, 2944], [2946, 2946, 2990, 2990, 3561], [3563, 3563, 3586, 3586, 4026], [4028, 4028, 4079, 4079, 6496], [6498, 6498, 6555, 6555, 7578]], "test": "error"}
{"id": "MllSD8", "name": "tunnel monster", "author": "Psycho", "description": "solskogen 2015 compo winner.  Party hack that didn't quite turn out as intended, but let's support the compo...", "tags": ["tunnel", "raymaching", "monster", "solskogen"], "likes": 13, "viewed": 1333, "published": "Public", "date": "1436545325", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 body=vec3(0,0.3,0);\nvec3 foot[6];\nvec3 knee[6];\nfloat speed = .6;\n\n\nvec3 solve( vec3 p, float l1, float l2, vec3 dir )\n{\n\tvec3 q = p*( 0.5 + 0.5*(l1*l1-l2*l2)/dot(p,p) );\n\tfloat s = l1*l1 - dot(q,q);\n\tq += sqrt(max(s,0.))*normalize(cross(p,dir));\n\treturn q;\n}\nvoid ik()\n{\n  vec3 by=vec3(0.);\n  for (int i=0;i<6;i++)\n  {\n    float phase = (i==1||i==2||i==5) ? .5 : 0.;\n    float t = fract(iTime*speed+phase+float(i)*.0);\n  \tfoot[i] = body+vec3(fract(float(i)*.5)*8.-2.,-3,2.-floor(float(i)*.8));\n    if (i>1 && i<4) foot[i].x*=1.4;\n    if (t<.5)\n      foot[i].y+=(1.-cos(t*12.56))*.8;\n    foot[i].z-= (-cos(t*6.28))*.8;\n    \n    knee[i] = foot[i]+solve(body-foot[i],3.,3.,vec3(0,0,sign(foot[i].x)));  \n    by+=knee[i].y;\n  }  \n  body.y = by.y*.05;\n}\n\nvec3 rotatey(vec3 r, float v)\n{ return vec3(r.x*cos(v)+r.z*sin(v),r.y,r.z*cos(v)-r.x*sin(v)); \n}\nfloat box( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\nfloat capsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  return length( pa - ba*clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 ) ) - r;\n}\n\nfloat cylinder( vec3 p, vec2 c )\n{\n  return max(abs(p.y)-c.x, length(p.xz)-c.y);\n}\nfloat torus34( vec3 p, vec2 r )\n{\n  vec2 q = vec2(length(p.xz)-r.x,p.y);\n  return max(max(p.x,-.5-p.z), length(q)-r.y);\n}\n\nvec2 u(vec2 a,vec2 b)\n{\n  return (a.x<b.x) ? a : b;\n}\nfloat smoothmin(float a, float b, float r)\n{\n  return a>r || b>r ? min(a,b) : min( min(a,b),r-length(vec2(a,b)-r));\t\n}\n\nvec2 eval(vec3 p) \n{\n  vec3 q = p+vec3(0,-1,-4.*iTime*speed);\n  q+= sin(q.yzx*.3)*2.+sin(q)*.4+sin(q.yzx*2.)*.1;\n  float tunnel =  5. - pow(dot(vec2(1.,1.),pow(q.xy,vec2(4.))),.25);\n  tunnel =smoothmin(tunnel, p.y+3., .3);\n    \n\n  q= p+sin(p.zxy*2.)*.2 + sin(p.yzx*9.)*.03;//+texture(iChannel2,p.xy*.1).xyz*.1;\n  float legs = 100.;\n  for (int i=0;i<6;i++)\n    legs= min(legs, min(\n        capsule(q,body,knee[i],.2),\n        capsule(q,knee[i],foot[i],.2)));\n  \n  q-= body;p-=body;\n    \n  p = rotatey( rotatey(p,sin(iTime*speed*2.)*.5).xzy, sin(iTime*speed*3.)*.3).xzy;\n  legs = smoothmin(legs,length(q+vec3(0,.1,0))-.7,.2);\n  legs = smoothmin(legs,length(q+sin((p.yzx+iTime)*2.)*.1+vec3(0,1,0))-.6,.1);\n  \n  \n  q = vec3(length(p.xz)-.7,p.y+.9,fract(atan(p.x,p.z)*4./6.28-.2)*1.6-.8);\n  float h1 = length(q)-.5, h2 = .3-length(q-vec3(.5,0,0));\n  float head = max(h1,h2);\n  p.y+=.5;\n  legs = smoothmin(legs,head,.3);\n    \n  vec3 pp = q+vec3(-.0,0,0);\n  float eye = length(pp)-.35;\n  \n    \n  vec2 r = u(u(u(\n        vec2(tunnel,1),\n        vec2(legs,2)),\n        vec2(head, 2.+smoothstep(h1-.1,h1,h2))),\n        vec2(eye,4.+smoothstep(-0.34,-.33,-pp.x/*+texture(iChannel1,q.xy)*.01*/)));\n\n  return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  ik();\n    \n  vec2 p = fragCoord.xy / iResolution.xy-.5,c;\n  float heading = sin(iTime)*.3, pitch= cos(iTime)*.2+.2;\n  vec3 vdir= normalize(\n               rotatey(rotatey(vec3(p.y,p.x*1.5,1),\n               pitch).yxz,heading)),\n       vpos= vec3(0,-.3,min(0.,3.*iTime-50.)+sin(iTime*.7)*2.-1.)-4.*normalize(rotatey(rotatey(vec3(0,0,1),pitch).yxz,heading));\n  \n  float t,stp,tmin=0.,r,m,d,tmax=100.;\n  vec3 e=vec3(.01,0,0),cx=e.yyy,n,bg=vec3(.6,.8,1)+.2*sin(vdir*8.),lightdir=vec3(1,1,heading);\n  \n  t=tmin;stp=1.;\n  for (int i=0;i<64;i++)\n  {\n\tt+=stp;\n\tif (t>tmax ||stp<0.005) break;\n\tstp = eval(vpos+vdir*t).x;\n  }\n  if (t<tmax) \n  { vpos+= vdir*t;\n    c= eval(vpos);\n    n= normalize(vec3(eval(vpos+e.xyy).x,eval(vpos+e.yxy).x,eval(vpos+e.yyx).x)-c.x);\n\n    n+= texture(iChannel1,vpos.xy).xyz*.3;\n   \n    r= clamp(eval(vpos+n*.3).x*.8+eval(vpos+n*.7).x+.5,.3,1.); //so\n\t\n    vdir=reflect(vdir,n);\n    d=clamp(dot(normalize(lightdir),n),.0,1.);\n    float af=.2;\n   \n    vec3 diff=vec3(1,0,0);\n    if (c.y>=1.) diff=texture(iChannel1,vec2(vpos.z-4.*speed*iTime,6.28*atan(vpos.y,vpos.x))*.05).xyz;\n    if (c.y>=2.) {diff=mix(vec3(texture(iChannel2,vpos.xy*.3)+.2),vec3(1.5),c.y-2.); af+=(c.y-2.)*.1;}\n   \tif (c.y>=4.) {diff=mix(vec3(0),vec3(1.,.1,.1),c.y-4.);af=1.;}\n\n\tn= mix(diff*d\n     +vec3(.5 * pow( clamp( dot( normalize(lightdir),vdir)\n        ,.0,1.) ,12.)),\n        diff, af); // n = col..\n\n    cx = mix(n*r, vec3(0), t/tmax);\n    tmin= .1;\n   }\n   else{\n     cx = vec3(0);\n   }\n   fragColor.xyz= cx;\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "XsXGRr", "previewfilepath": "/media/ap/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MllSD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 73, 125, 125, 264], [265, 265, 276, 276, 753], [755, 755, 786, 786, 851], [852, 852, 881, 881, 968], [971, 971, 1021, 1021, 1127], [1129, 1129, 1163, 1163, 1211], [1212, 1212, 1245, 1245, 1333], [1335, 1335, 1358, 1358, 1388], [1389, 1389, 1433, 1433, 1507], [1509, 1509, 1529, 1529, 2708], [2710, 2710, 2767, 2767, 4280]], "test": "error"}
{"id": "MllSz2", "name": "Colored Smooth XOR Pattern", "author": "tholzer", "description": "Smoothing out a bit the discontinous XOR pattern and colorize it.", "tags": ["2d", "hsv", "xor", "pattern", "smooth"], "likes": 3, "viewed": 315, "published": "Public", "date": "1438243988", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Colored Smooth XOR Pattern\n// Smoothing out a bit the discontinous XOR pattern and colorize it.\n// 'Smooth XOR' created by inigo quilez - iq/2015\n//   https://www.shadertoy.com/view/ll2GWy\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvec3 hsv(float h, float s, float v)\n{\n  return mix(vec3(1.0),clamp((abs(fract(h+vec3(3.0, 2.0, 1.0)/3.0)*6.0-3.0)-1.0), 0.0, 1.0),s)*v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 p = 256.0 * fragCoord.xy / iResolution.x + iTime;\n\n  float an = smoothstep( -0.5, 0.5, cos(3.14159*iTime) );\n  float x = 0.0;\n  for( int i=0; i<7; i++ ) \n  {\n    vec2 a = floor(p);\n    vec2 b = fract(p);\n  \n    x += mod( a.x + a.y, 2.0 ) \n      // the following line implements the smooth xor\n      * mix( 1.0, 1.5*pow(4.0*(1.0-b.x)*b.x*(1.0-b.y)*b.y,0.25), an );\n      \n    p /= 2.0;\n    x /= 2.0;\n  }\n  vec3 col = hsv(fract(0.1*iTime),1.,1.);\n  fragColor = vec4( col*x, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MllSz2.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[280, 280, 317, 317, 417], [419, 419, 476, 476, 964]], "test": "valid"}
{"id": "MllXDH", "name": "Cell Merge with Metaballs", "author": "aiekick", "description": "you can use mouse  for moving the last blob", "tags": ["cellmergewithmetaballs"], "likes": 15, "viewed": 1891, "published": "Public API", "date": "1436578277", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// bases on Cell Merge (prototype) from https://www.shadertoy.com/view/llsXD8\n// with metaball\nfloat mBall(vec2 uv, vec2 pos, float radius)\n{\n\treturn radius/dot(uv-pos,uv-pos);\n}\n\nvoid mainImage( out vec4 f, in vec2 g )\n{\n\tvec3 color_bg = vec3(0.0,0.0,0.0);\n    vec3 color_inner = vec3(1.0,1.0,0.0);\n    vec3 color_outer = vec3(0.5,0.8,0.3);\n\n    vec2 s = iResolution.xy;\n    vec2 uv = (2.*g-s)/s.y;\n    vec2 mo = (2.*iMouse.xy-s)/s.y;\n        \n    float mb = 0.;\n    \n   \tmb += mBall(uv, vec2(0.), 0.02);// metaball 1\n    mb += mBall(uv, vec2(0.57, 0.), 0.02);// metaball 2\n    mb += mBall(uv, vec2(sin(iTime)*.5, 0.5), 0.02);// metaball 3\n    mb += mBall(uv, mo, 0.02);// metaball 4\n        \n    vec3 col = color_bg;\n    vec3 mbext = color_outer * (1.-smoothstep(mb, mb+0.01, 0.5)); // 0.5 fro control the blob thickness\n    vec3 mbin = color_inner * (1.-smoothstep(mb, mb+0.01, 0.8)); // 0.8 for control the blob kernel size\n        \n    f.rgb = vec3(mbin+mbext);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MllXDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 95, 141, 141, 178], [180, 180, 221, 221, 968]], "test": "valid"}
{"id": "MlsSDH", "name": "Visualizing YUV", "author": "ap", "description": "Just trying to understand color spaces. Using BT.709\n\nLuma is X axis\nU is Y axis\nV is time", "tags": ["yuv", "visualize"], "likes": 2, "viewed": 1428, "published": "Public API", "date": "1436568857", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float square(float x)\n{\n    return x*x;\n}\n\nfloat LinearToSRGB(const float LinearValue)\n{\n\t\tif (LinearValue <= 0.0031308)\n\t\t\t\treturn LinearValue * 12.92;\n\t\telse \n\t\t\t\treturn pow(LinearValue, (1.0/2.4)) * (1.055) - 0.055;\n}\n\nvec3 LinearToSRGB(const vec3 LinearColor)\n{\n\treturn vec3(\n\t\tLinearToSRGB(LinearColor.x), \n\t\tLinearToSRGB(LinearColor.y), \n\t\tLinearToSRGB(LinearColor.z));\n}\n\nvec3 YUVToRGB(vec3 YUVColor)\n{\n\tvec3 ret;\n\n\tret.x = dot(YUVColor, vec3(1.0,  0.0,      1.28033));\n\tret.y = dot(YUVColor, vec3(1.0, -0.21482, -0.38059));\n\tret.z = dot(YUVColor, vec3(1.0,  2.12798,  0.0));\n\n\treturn ret;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor.xyz = (YUVToRGB(vec3(uv, square(sin(iTime)))));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlsSDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 41], [43, 43, 88, 88, 220], [222, 222, 265, 265, 377], [379, 379, 409, 409, 598], [601, 601, 658, 658, 761]], "test": "valid"}
{"id": "MlsSR2", "name": "Nano Hummus", "author": "chronokun", "description": "obligatory 3d ray march of an infinite lattice of balls floating in space with deliberately low iteration count for soupy look.", "tags": ["3d", "raymarch", "balls"], "likes": 0, "viewed": 161, "published": "Public", "date": "1438224169", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// Note: Made some changes suggested by FabriceNeyret2\n//\n\n// FabriceNeyret2 suggested 447 char version:\n/*\nfloat t = iTime;\n\nfloat dist(vec3 d)  {\n    vec3 c = d-d; float f;  \n    \n    for(int i = 0; i < 16; i++)\n    \tf = length( mod(c + vec3(cos(t),sin(t),t*5.), 4.) - 2.) - .8,\n        f > 0. ? c += d*f : c;\n    \n    return length(c*10.);\n}\n\n#define dir(p)     normalize(vec3((p)*R/R.y, 1))\n#define Q(s)       dir(p+s/R) * dist(dir(p+s/R))\n// #define Q(s)       dir(p+s/R) * sample(p+s/R)\n// #define sample(p)  dist(dir(p))\n\nvoid mainImage( out vec4 o, vec2 p ) {\n\tvec2 R = iResolution.xy, e=vec2(1,0);\n    \n    o = vec4(5.*sin(t)+5., 2.5, 0, 0) \n        * 5./dist(dir(p=p/R*2.-1.)) // sample(p)\n        * dot( .5+.5*normalize(cross(Q(-e.yx)-Q(e.yx), Q(-e)-Q(e))) , \n               vec3(1,2,.5)/2.3\n             ); \n}\n*/\n\n//\n\nfloat sSphere(vec3 p, vec3 o, float r)\n{\n\treturn(length(p-o)-r);   \n}\n\nfloat sScene(vec3 p)\n{\n    /*\n    p += vec3(cos(iTime)*10.0, sin(iTime) * 10.0, iTime * 50.0);\n    p = mod(p, vec3(40.0, 40.0, 40.0)) - vec3(20.0, 20.0, 20.0);\n \treturn(sSphere(p, vec3(0.0, 0.0, 0.0), 8.0));\n\t*/\n    \n    p += vec3(cos(iTime), sin(iTime), iTime * 5.);\t//\n    p = mod(p, vec3(4)) - vec3(2);\t\t\t\t\t\t\t\t\t\t// Scaled values to smaller numbers and\n \treturn(sSphere(p, vec3(0), .8));\t\t\t\t\t\t// more readable initializers\n}\n\nvec3 march(vec3 s, vec3 d, float t)\n{\n    return(s + (d*t));\n}\n\nfloat dist(vec3 s, vec3 d)\n{\n    //vec3 c = vec3(0.0, 0.0, 0.0);\n    vec3 c = s; // fixed s being unused, was supposed to be start location\n    \n    float l;\n    for(int i = 0; i < 16; ++i)\n    {\n    \tfloat f = sScene(c);\n        c = march(c, d, max(f, 1e-4));\n        l = length(c);\n        if(f < 0.0) break;\n    }\n    return(l);\n}\n\nvec3 dir(vec2 p)\n{\n    p.x *= iResolution.x / iResolution.y;\n\treturn(normalize(vec3(p, 1.0)));    \n}\n\nfloat sam(vec2 p)\n{\n    return(dist(vec3(p, 1.0), dir(p)));\n}\n\nvec3 draw(vec2 p)\n{\n    //vec2 e = vec2(1.0/iResolution.x, 1.0/iResolution.y);\n    vec2 e = 1./iResolution.xy; // shortened\n    \n    vec2 s[4];\n    s[0] = p + vec2(e.x, 0.0);\n    s[1] = p + vec2(0.0, e.y);\n    s[2] = p + vec2(-e.x, 0.0);\n    s[3] = p + vec2(0.0, -e.y);\n    vec3 q[4];\n    for(int i = 0; i < 4; ++i)\n    {\n    \tq[i] = dir(s[i]) * sam(s[i]);\n    }\n    //vec3 a = normalize(q[2]-q[0]);\n    //vec3 b = normalize(q[3]-q[1]);\n    vec3 a = (q[2]-q[0]); // removed redundant normalize\n    vec3 b = (q[3]-q[1]); // ''\n    vec3 n = (normalize(cross(b, a)) + vec3(1.0, 1.0, 1.0)) / 2.0;\n    \n    float l = dot(n, normalize(vec3(1.0, 2.0, 0.5)));\n    \n    vec3 c = vec3((sin(iTime)+1.0)/2.0, 0.25, 0.0) * l;\n    //c *= 50.0/sample(p);\n    c *= 5./sam(p); // scaled to match new smaller coords\n    \n    return(c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ((fragCoord.xy / iResolution.xy) * 2.0) - vec2(1.0, 1.0);\n    \n    vec3 c = draw(uv);\n    \n    \n\tfragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlsSR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[833, 833, 873, 873, 902], [904, 904, 926, 1115, 1330], [1332, 1332, 1369, 1369, 1394], [1396, 1396, 1424, 1460, 1729], [1731, 1731, 1749, 1749, 1831], [1833, 1833, 1852, 1852, 1894], [1896, 1896, 1915, 1974, 2715], [2717, 2717, 2774, 2774, 2909]], "test": "valid"}
{"id": "MlsSzS", "name": "Water in a box", "author": "adam27", "description": "Woda, pudeÃâko i powietrze.", "tags": ["water", "box", "warsztat", "air"], "likes": 9, "viewed": 2268, "published": "Public API", "date": "1437677914", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat rand(vec2 v)\n{\n\tfloat x = fract(sin(dot(v, vec2(1872.8497, -2574.9248))) * 72123.19);\n\treturn x;\n}\n\nfloat noise(in vec2 p) \n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix(mix(rand(i + vec2(0.0,0.0)), rand(i + vec2(1.0,0.0)), u.x),\n\t\t\t\t\t\tmix(rand(i + vec2(0.0,1.0)), rand(i + vec2(1.0,1.0)), u.x), u.y);\n}\n\nfloat map(vec2 xz)\n{\n\txz += noise(xz);\n\tvec2 a = 1.0 - abs(sin(xz));\n\tvec2 b = abs(cos(xz));\n\treturn pow(dot(a, b), 0.5);\n}\n\nconst mat2 mat = mat2(1.8, 1.1, -1.1, 1.8);\n\nfloat water(vec3 p)\n{\n\tvec2 xz = p.xz;\n\txz.x *= 0.7;\n\tfloat amp = 1.0;\n\tfloat h = 0.0;\n\tfloat freq = 0.2;\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tfloat h1 = map((xz + iTime) * freq);\n\t\tfloat h2 = 0.0;\n\t\th += (h1 + h2) * amp;\n\t\tfreq *= 1.8;\n\t\tamp *= 0.18;\n\t\txz *= mat;\n\t}\n\treturn p.y - h;\n}\n\nvec3 getNormal(vec3 p, float d)\n{\n    vec3 n;\n    n.y = water(p);    \n    n.x = water(p + vec3(d,0,0)) - n.y;\n    n.z = water(p + vec3(0,0,d)) - n.y;\n    n.y = d;\n    return normalize(n);\n}\n\nconst int MAX_STEPS = 100;\n\nstruct Distance\n{\n\tfloat value;\n\tvec3 color;\n};\n\nstruct Hit\n{\n\tbool is;\n\tvec3 pos, normal;\n\tvec3 color;\n};\n    \nfloat box(vec3 p, vec3 s)\n{ \n    vec3 w = abs(p) - s;\n    return min(max(w.x,max(w.y,w.z)),0.0) + length(max(w,0.0));   \n}\n    \nDistance add(Distance d1, Distance d2)\n{\n    if (d2.value > d1.value)\n        return d1;\n    else\n        return d2;\n}\n    \nDistance distance(vec3 p)\n{   \n    Distance d = Distance(box(p - vec3(0.4, 0.0, 0.0), vec3(0.02, 0.4, 0.42)), vec3(0.3, 0.7, 0.5)); \n    d = add(d, Distance(box(p + vec3(0.4, 0.0, 0.0), vec3(0.02, 0.4, 0.42)), vec3(0.3, 0.7, 0.5))); \n    d = add(d, Distance(box(p - vec3(0.0, 0.0, 0.4), vec3(0.42, 0.4, 0.02)), vec3(0.3, 0.7, 0.5))); \n    d = add(d, Distance(box(p + vec3(0.0, 0.0, 0.4), vec3(0.42, 0.4, 0.02)), vec3(0.3, 0.7, 0.5))); \n    d = add(d, Distance(box(p + vec3(0.0, 0.4, 0.0), vec3(0.4, 0.02, 0.4)), vec3(0.3, 0.7, 0.5))); \n    \n    d = add(d, Distance(box(p - vec3(0.0, 0.32, 0.0), vec3(0.36, 0.02, 0.36)), vec3(0.2, 0.3, 0.6))); \n    \n    return d;\n}\n\nDistance distance2(vec3 p)\n{    \n    \n    Distance d = Distance(box(p - vec3(0.4, 0.0, 0.0), vec3(0.02, 0.4, 0.42)), vec3(0.3, 0.7, 0.5)); \n    d = add(d, Distance(box(p + vec3(0.4, 0.0, 0.0), vec3(0.02, 0.4, 0.42)), vec3(0.3, 0.7, 0.5))); \n    d = add(d, Distance(box(p - vec3(0.0, 0.0, 0.4), vec3(0.42, 0.4, 0.02)), vec3(0.3, 0.7, 0.5))); \n    d = add(d, Distance(box(p + vec3(0.0, 0.0, 0.4), vec3(0.42, 0.4, 0.02)), vec3(0.3, 0.7, 0.5))); \n    d = add(d, Distance(box(p + vec3(0.0, 0.4, 0.0), vec3(0.4, 0.02, 0.4)), vec3(0.3, 0.7, 0.5))); \n    \n    return d;\n}\n\nHit castRay(inout vec3 p, vec3 dir)\n{\t\n\tHit hit;\n\tDistance dist = distance(p);\n\tfloat eps = 0.001;\n    bool r = false;\n    vec3 c = vec3(0.0);\n\t\n\tfor (int i = 0; i < MAX_STEPS; i++)\n\t{\n\t\tDistance dist;\n        if (r)\n            dist = distance2(p);\n        else\n            dist = distance(p);\n                \n\t\tfloat d = dist.value;\n\t\tif (abs(d) <= eps)\n\t\t{\n           \tif (!r && dist.color.b > 0.55)\n            {            \n            \tdir = refract(dir, getNormal(p, 0.001), 0.9);\n                c = dist.color;\n                r = true;\n            }\n            else\n            {\n                hit.is = true;\n                hit.pos = p;\n                hit.normal.x = distance(p + vec3(eps,0,0)).value - distance(p - vec3(eps,0,0)).value;\n                hit.normal.y = distance(p + vec3(0,eps,0)).value - distance(p - vec3(0,eps,0)).value;\n                hit.normal.z = distance(p + vec3(0,0,eps)).value - distance(p - vec3(0,0,eps)).value;\n                hit.normal = normalize(hit.normal);\n                hit.color = dist.color * (1.0 - float(i) / float(MAX_STEPS));\n                if (r)\n                    hit.color += c;\n                return hit;\n            }\n\t\t}\n\t\tp += dir*d;\n\t}\t\n\thit.is = false;\n\thit.color = vec3(0);\n\treturn hit;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 angle = vec2(-iMouse.x/200.0, radians(50.0));\n    vec3 center = vec3(0.0);\n    float zoom = 2.0;\n    \n    vec3 p = vec3(cos(angle.x)*cos(angle.y), sin(angle.y), sin(angle.x)*cos(angle.y));\n\tvec2 uv = (fragCoord.xy/* + vec2(int(iTime*30.0))*/) / iResolution.yy - vec2(iResolution.x / iResolution.y / 2.0, 0.5);\n    \n    vec3 tx = vec3(-sin(angle.x), 0.0, cos(angle.x));\n    vec3 ty = vec3(-cos(angle.x)*sin(angle.y), cos(angle.y), -sin(angle.x)*sin(angle.y));\n    \n    vec3 p2 = p;\n    p = p * zoom + center;\n    \n    vec3 dir = tx * uv.x + ty * uv.y - p2;\n    \n    vec3 color = vec3(0.0);\n    vec3 light = normalize(vec3(-0.6, 0.8, -0.3));\n    \n    \n\tHit hit = castRay(p, dir);\n    \n\tif (hit.is)\n\t\tcolor = hit.color * (max(dot(hit.normal, light), 0.0) * 0.8 + 0.2);\n\telse\n\t\tcolor = vec3(0);\n\t\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlsSzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 21, 21, 105], [107, 107, 132, 132, 364], [366, 366, 386, 386, 489], [536, 536, 557, 557, 819], [821, 821, 854, 854, 1010], [1152, 1152, 1179, 1179, 1274], [1280, 1280, 1320, 1320, 1398], [1404, 1404, 1431, 1431, 2068], [2070, 2070, 2098, 2098, 2633], [2635, 2635, 2672, 2672, 3899], [3901, 3901, 3956, 3956, 4799]], "test": "valid"}
{"id": "MlsXRj", "name": "MultipleCircleInversions", "author": "tholzer", "description": "Show how multiple conformal transformations can be added together, producing a result that maintains conformality.", "tags": ["2d", "circle", "checkerboard", "conformal", "inversion"], "likes": 17, "viewed": 259, "published": "Public", "date": "1438180114", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//----------------------------------------------\n// MultipleCircleInversions.glsl by THolzer \n// Circle inversion with 3 different patterns.\n// original by BeondTheStatic 2015-07-27\n//   https://www.shadertoy.com/view/MlXXR2\n// Show how multiple conformal transformations can be added together,\n// producing a result that maintains conformality.\n// Tags: 2d, conformal, circle, inversion, checkerboard\n//----------------------------------------------\n\n#define time iTime\n#define resolution iResolution\n\n//----------------------------------------------\nconst float periodTime = 15.0;\n\nconst vec3 patternColor0 = vec3(1.0);\nconst vec3 patternColor1 = vec3(0.2,0.4,0.5);\nconst vec3 patternColor2 = vec3(0.2,0.5,0.2);\nconst vec3 patternColor3 = vec3(0.5,0.4,0.2);\n\nconst int circles = 4;  // number of circle inversions\n\n//----------------------------------------------\n// return rotated position p\n//----------------------------------------------\nvec2 rotate(vec2 p, float a)\n{\n\tfloat s = sin(radians(a));\n\tfloat c = cos(radians(a));\n\treturn vec2(p.y*c + p.x*s, -p.y*s + p.x*c);\n}\n//----------------------------------------------\n// p = position; o = circle center, r = radius\n//----------------------------------------------\nvec2 cInvert(vec2 p, vec2 o, float r)\n{\n\tvec2 po = p-o;\n\treturn po / dot(po, po)*pow(r, 2.);\n}\n//----------------------------------------------\n// return checkerboard pattern color\n//----------------------------------------------\nvec3 CheckerboardColor (in vec2 pos)\n{\n    return (mod(floor(pos.x * 10.0) \n               +floor(pos.y * 10.0), 2.0) \n                < 1.0 ? patternColor0 : patternColor1);\n}\n//----------------------------------------------\n// return rounded square pattern color\n//----------------------------------------------\nvec3 RoundedSquaresColor (in vec2 pos)\n{\n  float k = smoothstep(0.0, 0.5, sin(pos.x * 10.0) +sin(pos.y * 10.0) );\n  return mix(patternColor0, patternColor2, k);\n}\n//----------------------------------------------\n// return hexagonal grid color\n// http://glslsandbox.com/e#23933\n//----------------------------------------------\nvec3 HexagonalGridColor (in vec2 position         \n\t                ,in float gridSize\n\t                ,in float gridThickness) \n{\n  vec2 pos = position / gridSize; \n  pos.x *= 0.57735 * 2.0;\n  pos.y += mod(floor(pos.x), 2.0)*0.5;\n  pos = abs((mod(pos, 1.0) - 0.5));\n  float d = abs(max(pos.x*1.5 + pos.y, pos.y*2.0) - 1.0);\n  float k = smoothstep(0.0, gridThickness, d);\n  return mix(patternColor0, patternColor3, k);\n}\n//----------------------------------------------\n// return color of circle inversions\n//----------------------------------------------\nvec3 CircleInversions (in vec2 pos)\n{\n\t// adding up circle inversions\n    vec2 invertSum = vec2(0.0);\n    for(int i=0; i<circles; i++)\n    {\n        float rn = float(i) / float(circles);  \n        invertSum += cInvert(pos, rotate(vec2(0.0, rn)\n                            ,time * 13.0*rn), 0.5);\n    }\n   \tpos = fract(invertSum);\n    \n    float border = clamp(8.*(.5-max(abs(pos.x-0.5), abs(pos.y-0.5))), 0.1, 1.0);\n    vec3 col;\n//  col = 2. * border * texture(iChannel0, uv).rgb;\n    float sceneTime = periodTime / 3.0;\n    int selection = int(mod(time, periodTime) / periodTime * 3.0);\n    if      (selection < 1)  col = border * CheckerboardColor(pos);\n    else if (selection < 2)  col = border * RoundedSquaresColor(pos);\n    else                     col = border * HexagonalGridColor(pos, 0.1, 0.2);\n    return col;\n}\n//----------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / resolution.xy -0.5;\n    uv.x *= resolution.x / resolution.y;\n    fragColor = vec4(CircleInversions(uv), 11.01);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlsXRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[818, 945, 975, 975, 1078], [1079, 1224, 1263, 1263, 1318], [1319, 1454, 1492, 1492, 1630], [1631, 1768, 1808, 1808, 1930], [1931, 2094, 2225, 2225, 2515], [2516, 2651, 2688, 2720, 3474], [3475, 3524, 3581, 3581, 3724]], "test": "valid"}
{"id": "MlsXWn", "name": "FrickinLasers", "author": "dila", "description": "Laser security system.", "tags": ["laser", "room"], "likes": 22, "viewed": 588, "published": "Public", "date": "1436032060", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = 3.14159;\n\nmat3 xrot(float t)\n{\n    return mat3(1.0, 0.0, 0.0,\n                0.0, cos(t), -sin(t),\n                0.0, sin(t), cos(t));\n}\n\nmat3 yrot(float t)\n{\n    return mat3(cos(t), 0.0, -sin(t),\n                0.0, 1.0, 0.0,\n                sin(t), 0.0, cos(t));\n}\n\nmat3 zrot(float t)\n{\n    return mat3(cos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0);\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdTube(vec3 p, float a)\n{\n    return length(p.xy) - a;\n}\n\nfloat room(vec3 p)\n{\n\tfloat fd = sdBox(p, vec3(8.0));\n    fd = min(fd, sdBox(p+vec3(0.0,6.0,0.0), vec3(2.0,2.0,100.0)));\n    fd = min(fd, sdBox(p+vec3(0.0,6.0,0.0), vec3(100.0,2.0,2.0)));\n    return fd;\n}\n\nbool alpha = false;\n\nvec2 map(vec3 p)\n{   \n\tfloat d = -room(p);\n    float m = 0.0;\n    \n    float pe = sdBox(p+vec3(0.0,8.0,0.0), vec3(1.0, 2.0, 1.0));\n    if (pe < d) {\n        d = pe;\n        m = 1.0;\n    }\n    \n    if (alpha) {\n        float c = sdBox(p+vec3(0.0,5.0,0.0), vec3(1.0));\n        if (c < d)\n        {\n            d = c;\n            m = 2.0;\n        }\n    } else {\n        float c = length(p+vec3(0.0,5.3,0.0)) - 0.7;\n        if (c < d)\n        {\n            d = c;\n            m = 3.0;\n        }\n    }\n    \n    return vec2(d, m);\n}\n\nvec3 normal(vec3 p)\n{\n\tvec3 o = vec3(0.01, 0.0, 0.0);\n    return normalize(vec3(map(p+o.xyy).x - map(p-o.xyy).x,\n                          map(p+o.yxy).x - map(p-o.yxy).x,\n                          map(p+o.yyx).x - map(p-o.yyx).x));\n}\n\nfloat trace(vec3 o, vec3 r)\n{\n \tfloat t = 0.0;\n    for (int i = 0; i < 32; ++i) {\n        vec3 p = o + r * t;\n        float d = map(p).x;\n        t += d;\n    }\n    return t;\n}\n\nfloat mapl(vec3 p)\n{\n    p *= yrot(pi*0.25);\n\tfloat r = 0.01;\n    float o = 7.0;\n    vec3 q = fract(p) * 2.0 - 1.0;\n    float a = sdTube(vec3(q.z,q.y,q.x), r);\n    float b = sdTube(vec3(q.x,q.y,q.z), r);\n    return min(a,b);\n}\n\nfloat tracel(vec3 o, vec3 r)\n{\n \tfloat t = 0.0;\n    for (int i = 0; i < 16; ++i) {\n        vec3 p = o + r * t;\n        float d = mapl(p);\n        t += d * 0.8;\n    }\n    return t;\n}\n\nvec3 _texture(vec3 p)\n{\n\tvec3 ta = texture(iChannel0, vec2(p.y,p.z)).xyz;\n    vec3 tb = texture(iChannel0, vec2(p.x,p.z)).xyz;\n    vec3 tc = texture(iChannel0, vec2(p.x,p.y)).xyz;\n    return (ta + tb + tc) / 3.0;\n}\n\nvec4 diffcol(vec3 w, vec3 r, vec3 sn, vec2 fd, float t)\n{\n    vec3 mdiff = vec3(0.0); \n    float gloss = 0.0;\n    float light = 1.0;\n    if (fd.y == 1.0) {\n        mdiff = vec3(1.0);\n        gloss = 1.0;\n    } else if (fd.y == 2.0) {\n        mdiff = vec3(1.0);\n    } else if (fd.y == 3.0) {\n        mdiff = vec3(1.0);\n        gloss = 1.0;\n    } else {\n        if (sn.y > 0.9) {\n    \t\tmdiff = vec3(1.0) * vec3(0.2,0.5,0.2);\n            gloss = 0.1;\n        } else if (sn.y < -0.9) {\n            mdiff = vec3(5.0);\n            gloss = 1.0;\n            light = 0.0;\n        } else {\n            mdiff = _texture(w*0.1) * vec3(0.0, 1.0, 1.0);\n            gloss = 1.0;\n        }\n    }\n    float fog = 1.0 / (1.0 + t * t * 0.05);\n    mdiff = mix(mdiff, vec3(1.0), abs(w.y) / 8.0 * light);\n    return vec4(mdiff*fog, gloss);\n}\n\nvec3 laser(vec3 o, vec3 r)\n{\n    float t = tracel(o, r);\n    float k = 1.0 / (1.0 + t * t * 0.1);\n    return vec3(1.0, 0.0, 0.0) * k;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    mat3 xfm = xrot(sin(-iTime*0.25)*0.25) * yrot(iTime);\n    \n    vec3 r = normalize(vec3(uv, 1.0));\n    r *= xrot(pi * 0.25) * xfm;\n    \n    vec3 o = vec3(0.0, 0.0, -3.0);\n    o *= xfm;\n    o.y -= 3.0;\n    \n    alpha = true;\n    float t = trace(o, r);\n    vec3 w = o + r * t;\n    vec2 fd = map(w);\n    vec3 sn = normal(w);\n\n\tvec4 mdiff = diffcol(w, r, sn, fd, t);\n    \n    if (fd.y == 2.0) {\n    \talpha = false;\n    \tvec3 rr = refract(r, sn, 0.9);\n    \tfloat art = trace(w, rr);\n        vec3 aw = w + rr * art;\n    \tvec2 afd = map(aw);\n        vec3 asn = normal(aw);\n\t\tmdiff = diffcol(aw, rr, asn, afd, t+art);\n        mdiff.xyz += laser(w, rr);\n        mdiff.w = 1.0;\n        \n        if (afd.y == 3.0) {\n            alpha = false;\n            vec3 brf = reflect(rr, asn);\n            float brt = trace(aw + asn * 0.1, brf);\n            vec3 bw = aw + brf * brt;\n            vec2 bfd = map(bw);\n            vec3 bsn = normal(bw);\n            vec4 bdiff = diffcol(bw, brf, bsn, bfd, brt);\n            float prod = max(dot(rr, -asn), 0.0);\n            mdiff.xyz = bdiff.xyz * prod + laser(aw, t+art+brf);\n        }\n    }\n\n    alpha = true;\n    vec3 rf = reflect(r, sn);\n    float tr = trace(w + sn * 0.01, rf);\n    vec3 rw = w + rf * tr;\n    vec2 rfd = map(rw);\n    vec3 rsn = normal(rw);\n    vec4 rdiff = diffcol(rw, rf, rsn, rfd, t+tr);\n    \n    float prod = max(dot(r, -sn), 0.0);\n    \n\tvec3 fdiff = mix(mdiff.xyz, rdiff.xyz, mdiff.w*(1.0-prod));\n\n    vec3 fc = fdiff + laser(o, r);\n    \n\tfragColor = vec4(sqrt(fc), 1.0);\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlsXWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 47, 47, 156], [158, 158, 178, 178, 287], [289, 289, 309, 309, 418], [420, 420, 451, 451, 489], [491, 491, 522, 522, 618], [620, 620, 651, 651, 682], [684, 684, 704, 704, 888], [911, 911, 929, 929, 1437], [1439, 1439, 1460, 1460, 1673], [1675, 1675, 1704, 1704, 1850], [1852, 1852, 1872, 1872, 2078], [2080, 2080, 2110, 2110, 2261], [2263, 2263, 2286, 2286, 2477], [2479, 2479, 2536, 2536, 3298], [3300, 3300, 3328, 3328, 3435], [3437, 3437, 3494, 3494, 5137]], "test": "error"}
{"id": "MlsXzS", "name": "Complex function 2", "author": "rioka", "description": "Another experiment with complex variables. http://www.chiark.greenend.org.uk/~sgtatham/newton/", "tags": ["function", "complex", "maths"], "likes": 2, "viewed": 119, "published": "Public", "date": "1437695102", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Complex utility functions from https://harrisonclarke.wordpress.com/2010/02/07/fractals-on-the-gpu-glsl/ \n//and http://www.codeproject.com/Articles/492355/Domain-Coloring-Method-on-GPU \n\nfloat c_abs(vec2 z)\n{\n    return sqrt(z.x * z.x + z.y * z.y);\n}\n\nfloat c_arg(vec2 z)\n{\n    return atan(z.y, z.x);\n}\n\nvec2 c_mult(vec2 a, vec2 b) \n{\n    return vec2(a.x * b.x - a.y * b.y, (a.x+a.y)*(b.x+b.y) - a.x*b.x - a.y*b.y);\n}\n\nvec2 c_div(vec2 a, vec2 b)\n{\n    return vec2(((a.x*b.x+a.y*b.y)/(b.x*b.x+b.y*b.y)),((a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y)));\n}\n\nvec2 c_pow_4(vec2 z)\n{\n    vec2 y = z;\n    for (int i=1; i<4; i++){\n    \ty = c_mult(y, z);\n    }\n    return y;\n}\n\nvec2 c_pow_3(vec2 z)\n{\n    vec2 y = z;\n    for (int i=1; i<2; i++){\n    \ty = c_mult(y, z);\n    }\n    return y;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 xy = ((fragCoord.xy - (iResolution.xy / 2.0)) / iResolution.xy);\n    vec2 uv = xy *6.0;\n    vec2 a = c_pow_3(uv) - vec2(uv.y, uv.x);\n    vec2 b = (c_pow_4(uv)* iTime*0.01) - vec2(uv.x);\n    vec2 result = c_div(a,b);\n    fragColor = vec4(vec3(c_arg(result), mod(c_arg(result), 2.0) / 2.0, mod(c_arg(result), 2.0)) / 4.0, 1.0);\n\t//fragColor = vec4(vec3(c_arg(result)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlsXzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[189, 189, 210, 210, 252], [254, 254, 275, 275, 304], [306, 306, 336, 336, 419], [421, 421, 449, 449, 545], [547, 547, 569, 569, 659], [661, 661, 683, 683, 773], [776, 776, 833, 833, 1214]], "test": "valid"}
{"id": "MlXXD4", "name": "Simplex vs \"iqnoise\" (3D)", "author": "voax", "description": "Comparing simplex (gradient) noise to \"iq\" (value) from https://www.shadertoy.com/view/4sfGzS#\nQuality vs speed, or an unfair comparison?", "tags": ["noise", "simplex", "iq"], "likes": 4, "viewed": 436, "published": "Public", "date": "1436786343", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define FBM \t\t\t// toggle between fBm and plain noise\nfloat scale = 10.0;\t\t// uv scale\nfloat speed = 0.5;\t\t// time multiplier\n\n// Simplex noise below = ctrl+c, ctrl+v:\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  { \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat simple_iqnoise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel0, (uv+0.5)/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z ) * 2.0 - 1.0;\n}\n\n#define fBm(p, func) { f = 0.5 * func(p); p *= 2.01; f += 0.25 * func(p); p *= 2.03; f += 0.125 * func(p); p *= 2.02; f += 0.0625 * func(p); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord / iResolution.xy;\n    vec3 q = vec3(uv * scale, iTime * speed);\n    \n    float f;\n    #ifdef FBM\n    if (uv.x < 0.5) {\n        fBm(q, snoise);\n    } else {\n        q *= 2.0;\n        fBm(q, simple_iqnoise);\n    }\n    #else\n    if (uv.x < 0.5)\n        f = snoise(q);\n    else\n        f = simple_iqnoise(q*2.0);\n    #endif\n    fragColor = vec4(f) / 2.0 + 0.5;\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlXXD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[558, 558, 579, 579, 628], [630, 630, 651, 651, 700], [702, 702, 724, 724, 764], [766, 766, 794, 794, 846], [848, 848, 872, 872, 3016], [3018, 3018, 3053, 3053, 3275], [3421, 3421, 3478, 3478, 3858]], "test": "error"}
{"id": "MlXXRB", "name": "Glitch 0.1", "author": "xernobyl", "description": "Trying to come up with some glitch ideas for post processing. Open to ideas and suggestions.", "tags": ["noise", "distortion", "glitch", "screenspace"], "likes": 17, "viewed": 1228, "published": "Public", "date": "1437526372", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat rand(vec2 co)\n{\n\treturn fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n\tif (mod(iTime, 2.0) > 1.9)\n\t\tuv.x += cos(iTime * 10.0 + uv.y * 1000.0) * 0.01;\n    \n    //if (mod(iTime, 4.0) > 3.0)\n\t//\tuv = floor(uv * 32.0) / 32.0;\n    \n\tif (mod(iTime, 5.0) > 3.75)\n    \tuv += 1.0 / 64.0 * (2.0 * vec2(rand(floor(uv * 32.0) + vec2(32.05,236.0)), rand(floor(uv.y * 32.0) + vec2(-62.05,-36.0))) - 1.0);\n\n\tfragColor = texture(iChannel0, uv);\n    \n    if (rand(vec2(iTime)) > 0.90)\n\t\tfragColor = vec4(dot(fragColor.rgb, vec3(0.25, 0.5, 0.25)));\n    \n    fragColor.rgb += 0.25 * vec3(rand(iTime + fragCoord / vec2(-213, 5.53)), rand(iTime - fragCoord / vec2(213, -5.53)), rand(iTime + fragCoord / vec2(213, 5.53))) - 0.125;\n}", "image_inputs": [{"id": "4sf3zn", "previewfilepath": "/presets/webcam.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/webcam.png", "ctype": "webcam"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlXXRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 22, 22, 92], [95, 95, 152, 152, 840]], "test": "error"}
{"id": "MtfSz2", "name": "SW Glitch", "author": "dmmn", "description": "SW Glitch", "tags": ["glitch"], "likes": 9, "viewed": 640, "published": "Public", "date": "1437989992", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 rgb2hsv(vec3 c){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n        vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n        vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n        float d = q.x - min(q.w, q.y);\n        float e = 1.0e-10;\n        return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat rand(vec2 n) { \n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\n// MAIN\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 color = texture(iChannel0, uv);\n    \n    // blue\n    vec3 hsvColor = rgb2hsv(color.rgb);\n    hsvColor.x = .59;\n    hsvColor.y = clamp(hsvColor.y, .4, .6 );\n    \n    float noise = rand(1. + fragCoord.y + fragCoord.x * iTime);\n    hsvColor.z += noise * .2;\n    \n    // vertical lines\n    hsvColor.z += .2 * step(mod(fragCoord.x, 3.), 1.);\n    \n    // horizontal lines\n    float offset = rand(fragCoord.y * fragCoord.x + fragCoord.x * iTime) * 10.;\n    float ratio = step(rand(50. + fragCoord.y + fragCoord.x * iTime), .2);\n    float timeShift = cos(iTime) * 200.;\n    hsvColor.z += .4 * step(mod(fragCoord.y + offset + iTime * 400. + timeShift, 200.), 10.) * ratio;\n    \n    // random rectangles\n    //float offset2 = rand(ceil(fragCoord.y / 100.) * floor(iTime * 20.));\n    //hsvColor.z += .15 * step(mod(fragCoord.y + iTime + offset2 * 100. + 100., 200.), 100.);\n    \n    // horizontal rectangles\n    float offset3 = rand(ceil(fragCoord.y * 0.01));\n    hsvColor.z += .15 * step(mod(fragCoord.y + iTime * 15000., 2000. + 2000. * offset3), 400. + 800. * offset3);\n    \n    color.rgb = hsv2rgb(hsvColor);\n    \n\tfragColor = color;\n}", "image_inputs": [{"id": "4sX3Rn", "previewfilepath": "/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtfSz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 372], [374, 374, 395, 395, 564], [566, 566, 586, 586, 624], [626, 626, 646, 646, 716], [727, 727, 784, 784, 1964]], "test": "error"}
{"id": "MtfXDn", "name": "pie-charts", "author": "kusma", "description": "lots of anti-aliased pie-charts\n\n...or white-supremacist pac-men, depending on how you look at it.", "tags": ["piechart"], "likes": 0, "viewed": 140, "published": "Public", "date": "1435755490", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float piechart(vec2 p, float r, float a0, float a1)\n{\n    vec2 n0 = vec2(-cos(a0), sin(a0));\n    vec2 n1 = -vec2(-cos(a1), sin(a1));\n\tvec2 nm = normalize(n0 + n1);\n\n    float da0 = dot(p, n0);\n    float da1 = dot(p, n1);\n\n    float da;\n\t// if the angle between a0 and a1 is less than 180 degrees\n    bool convex = (a1 - a0) < 3.1415926;\n    if (convex)\n    \tda = max(da0, da1);\n    else\n    \tda = min(da0, da1);\n\n    // add a miter limit of 0.0\n    float dm = dot(p, nm);\n    if (convex)\n    \tda = max(da, dm);\n    else\n    \tda = min(da, dm);\n\n    float dc = length(p) - r;\n    return max(dc, da) + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float r = 16.0;\n    vec2 pos = floor((fragCoord.xy) / (2.0 * r));\n    float a0 = mod(pos.x * 0.5 - iTime * 0.1, 3.1415926 * 2.0);\n    float a1 = mod(pos.y * 0.5 + iTime * 0.5, 3.1415926 * 2.0);\n    if (a1 < a0)\n        \ta1 += 3.14159265 * 2.0; // make sure a1 is larger than a0\n\n\tfloat d = piechart(fragCoord.xy - r - pos * r * 2.0, r, a0, a1);\n    float a = clamp(0.5 - d, 0.0, 1.0);\n    \n\tfragColor = vec4(vec3(sqrt(a)) + vec3(0.0, 0.0, 0.0), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtfXDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 53, 53, 605], [607, 607, 664, 664, 1121]], "test": "valid"}
{"id": "Mts3Dr", "name": "Raymarching trash", "author": "Izokina", "description": "Playing with raymarching optimizations", "tags": ["raymarching", "dummy"], "likes": 0, "viewed": 170, "published": "Public", "date": "1436260116", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// #define DEBUG .01\n\nconst int COUNT = 2;\nconst int STEPS = 1000;\nconst int REFLECTIONS = 100;\nconst float DIST_EPS = .001;\nconst float EPS = .01;\nconst float FOG = .6;\nconst float BOTTOM = 1.;\nconst float FAR = 10.;\n\nvec2 start(vec2 coord) {\n    float scale = 2. / iResolution.x;\n    if (iResolution.y < iResolution.x)\n        scale = 2. / iResolution.y;\n    return vec2(coord.x - iResolution.x * .5, coord.y - iResolution.y * .5) * scale;\n}\n\nfloat touch(const in vec4 sphere, const in vec3 pos) {\n    return length(pos - sphere.xyz) - sphere.w;\n}\n\nstruct S {\n    vec4 pos;\n    vec4 col;\n};\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    S sphs[COUNT];\n    vec4 neg = vec4(0., 0., 1., 1.5);\n\tsphs[0] = S(vec4(0., 0., 1., 1.), vec4(1., 1., 0., .2));\n\tsphs[1] = S(vec4(sin(iTime), cos(iTime), .25, .25), vec4(0., 1., 0., .1));\n    vec3 pos = vec3(start(fragCoord), 0.);\n    vec3 dir = normalize(vec3(pos.xy, 1.5));\n    vec4 res = vec4(0., 0., 0., 1.);\n    for (int i = 0; i < REFLECTIONS; i++) {\n        float len = EPS;\n        float last = 0.;\n#ifdef DEBUG\n        float it = 0.;\n#endif\n        for (int j = 0; j < STEPS; j++) {\n#ifdef DEBUG\n            it += DEBUG;\n#endif\n            vec3 cur = pos + dir * len;\n            float dist = 0.;\n            if (dir.y < 0.)\n                dist = (cur.y + BOTTOM) / -dir.y;\n            else\n                dist = FAR;\n            dist = max(dist, -touch(neg, cur));\n            for (int g = 0; g < COUNT; g++)\n            \tdist = min(dist, touch(sphs[g].pos, cur));\n            len += dist;\n            if (len > FAR || (dist < DIST_EPS && dist < last))\n                break;\n            last = dist;\n        }\n        vec3 n;\n        vec4 col;\n        pos += dir * len;\n        float dist = pos.y + BOTTOM;\n        if (dist < DIST_EPS) {\n            if (dist < -DIST_EPS)\n                n = pos - neg.xyz;\n            else\n            \tn = vec3(0., 1., 0.);\n            if ((fract(pos.x) - .5) * (fract(pos.z) - .5) > 0.)\n                col = vec4(1., 0., 0., .2);\n            else\n                col = vec4(0., 0., 1., .6);\n        }\n        for (int g = 0; g < COUNT; g++) {\n            float cur = touch(sphs[g].pos, pos);\n            if (cur < dist) {\n                dist = cur;\n                n = pos - sphs[g].pos.xyz;\n                col = sphs[g].col;\n            }\n        }\n#ifdef DEBUG\n        res.r += it;\n#endif\n        dir -= n * dot(dir, n) / dot(n, n) * 2.;\n        float g = exp(-len * FOG);\n        res.a *= g;\n        float my = res.a * col.a;\n#ifdef DEBUG\n        res.gb += col.gb * my;\n#else\n        res.rgb += col.rgb * my;\n#endif\n        res.a -= my;\n        if (res.a < EPS)\n            break;\n    }\n    fragColor = res;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mts3Dr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[219, 219, 243, 243, 443], [594, 594, 651, 651, 2719]], "test": "error"}
{"id": "MtsSDH", "name": "Cell Merge (v1)", "author": "W_Master", "description": "haha I can watch this all day!\nAlso thanks to aiekick, for showing some metaball technique! here I just used a power of 5 to make them less interactive at larger distances.", "tags": ["2d", "circle", "metaball", "smoothstep"], "likes": 21, "viewed": 2103, "published": "Public API", "date": "1436556526", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 color_bg = vec3(0.0);\nvec3 color_inner = vec3(1.0,0.9,0.16);\n\nvec3 color_outer = vec3(0.12,0.59,0.21);\n//vec3 color_outer = mix(color_bg, color_inner, 0.3); // also nice effect\n\nfloat timeScale = 1.0;\nfloat mapScale = 1.0;\n\n#define cellCount 20.0\n\n// size in pixels inner/outer with mapscale 1.0\nvec2 cellSize = vec2(30.0, 44.0); \n\n\n\nvec3 powerToColor(vec2 power)\n{\n    float tMax = pow(1.03,mapScale*2.2);\n    float tMin = 1.0 / tMax;\n    \n    vec3 color = mix(color_bg, color_outer, smoothstep(tMin,tMax,power.y));\n    color = mix(color, color_inner, smoothstep(tMin,tMax,power.x));\n    return color;\n}\n\n\nvec2 getCellPower( vec2 coord, vec2 pos, vec2 size )\n{\n    vec2 power;\n    \n    power = (size*size) / dot(coord-pos,coord-pos);\n    power *= power * sqrt(power); // ^5\n    \n    return power;\n}\n\n\nvoid mainImage( out vec4 color, in vec2 coord )\n{\n\tfloat T = iTime * 0.1 * timeScale / mapScale;\n    \n    vec2 hRes = iResolution.xy*0.5;\n    \n    vec2 pos;\n    vec2 power = vec2(0.0,0.0);\n    \n    \n    for(float x = 1.0; x != cellCount + 1.0; ++x)\n    {\n        pos = hRes * vec2(sin(T*fract(0.246*x)+x*3.6)*cos(T*fract(0.374*x)-x*fract(0.6827*x))+1.,\n                          cos(T*fract(0.4523*x)+x*5.5)*sin(T*fract(.128*x)+x*fract(0.3856*x))+1.);\n        \n    \tpower += getCellPower(coord.xy, pos, cellSize*(.75+fract(0.2834*x)*.25) / mapScale);\n    }\n    \n    color.rgb = powerToColor(power);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtsSDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[339, 339, 370, 370, 609], [612, 612, 666, 666, 804], [807, 807, 856, 856, 1407]], "test": "valid"}
{"id": "MtsSzB", "name": "trianglesTT", "author": "motte", "description": "triangles", "tags": ["triangles"], "likes": 3, "viewed": 228, "published": "Public", "date": "1437733394", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float signf (vec2 p1, vec2 p2, vec2 p3)\n{\n    return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);\n}\n\nbool PointInTriangle (vec2 pt, vec2 v1, vec2 v2, vec2 v3)\n{\n    bool b1, b2, b3;\n    b1 = signf(pt, v1, v2) < 0.0;\n    b2 = signf(pt, v2, v3) < 0.0;\n    b3 = signf(pt, v3, v1) < 0.0;\n    return ((b1 == b2) && (b2 == b3));\n}\n\nvec2 getTriPoint(float shift)\n{\n    float r = 0.9;\n    float rsqr = r*r;\n    float t = mod(iTime*0.1 + shift,  3.1415*0.5);\n    float tsqr = t*t;\n    \n    float x = sin(t);\n    float y = cos(t) ;\n    \n    return vec2(x * 0.5, y);\n}\n\nfloat distanceToEdge(vec2 point)\n{\n    return 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float c = 0.0;\n    \n    for (int i=0;i<7;i++)\n    {\n        vec2 p = getTriPoint(float(i)*0.9);\n        vec2 left = vec2(-p.x+0.5, p.y);\n        vec2 right = vec2(p.x+0.5, p.y);\n    \n        if (PointInTriangle(uv, right, left, vec2(0.5,0.0) ))\n        {\n            float distanceToEdge = length(uv-left);\n            \n            float d = clamp(distanceToEdge, 0.0, 1.0);\n            \n            c += 0.081;\n        }\n    }\n\n    \n    fragColor = vec4(0.98,0.7,0.5,1.0) + vec4(c,c,c,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtsSzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 117], [119, 119, 178, 178, 342], [344, 344, 375, 375, 575], [577, 577, 611, 611, 629], [631, 631, 688, 688, 1226]], "test": "valid"}
{"id": "MtXSRj", "name": "City road", "author": "Cubed", "description": "New to raymarching, playing around with stuff. \nCredit to IÃÂ±igo QuÃÂ­lez for the distance field functions, which I've mutilated horribly. :)", "tags": ["basic", "raymarch"], "likes": 16, "viewed": 1775, "published": "Public API", "date": "1437863139", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 opRep(vec3 p, vec3 c) {\n    return mod(p,c)-0.5*c;\n}\n\nfloat opU( float d1, float d2 ) {\n    return min(d1,d2);\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nmat2 rotation(float theta) {\n    return mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n}\n\nfloat map(vec3 p) {\n    float res = sdBox(opRep(p, vec3(11.0, 0.0, 11.0)), vec3(3.0, 8.0, 3.0));\n    res = opU(res, sdBox(opRep(p + vec3(0.0, -4.0, 5.0), vec3(0.0, 0.0, 10.0)), vec3(1.0, 0.2, 5.0)));\n    res = opU(res, sdBox(opRep(p + vec3(0.0, -4.3, 0.0), vec3(0.0, 0.0, 4.0)), vec3(0.1, 0.05, 0.8)));\n    res = opU(res, p.y);\n    \n\treturn res;\n}\n\nfloat trace(vec3 o, vec3 r) {\n    float t = 0.0;\n    for (int i = 0; i < 50; i++) {\n    \tvec3 p = o + r * t;\n        float d = map(p);\n        t += d;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 r = normalize(vec3(uv, 1.0));\n    r.yz *= rotation(0.5);\n    r.xy *= rotation(sin(iTime + 10.0) * 0.5);\n    \n    float altitude = cos(iTime * 0.5) * 4.5 + 5.5;\n    vec3 o = vec3(sin(iTime * 0.5) * 1.7, altitude, iTime * 32.0);\n    float t = trace(o, r);\n    float fog = 1.0 / (1.0 + t * t * 0.01);  \n    vec3 fc = vec3(fog);\n\tfragColor = vec4(fc ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtXSRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 57], [59, 59, 92, 92, 117], [119, 119, 150, 150, 237], [239, 239, 267, 267, 335], [337, 337, 356, 356, 684], [686, 686, 715, 715, 858], [860, 860, 917, 917, 1391]], "test": "valid"}
{"id": "MtXSWr", "name": "crowded strips", "author": "FabriceNeyret2", "description": "Be sure to wait long enough ;-)", "tags": ["3d", "raymarching", "spheremarching"], "likes": 19, "viewed": 1489, "published": "Public API", "date": "1435770032", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define T iTime\n#define r(v,t) { float a = (t)*T, c=cos(a),s=sin(a); v*=mat2(c,s,-s,c); }\n#define SQRT3_2  1.26\n#define SQRT2_3  1.732\n#define smin(a,b) (1./(1./(a)+1./(b)))\n\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n           \t\t    -0.80,  0.36, -0.48,\n             \t\t-0.60, -0.48,  0.64 );\n\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x ) { // in [0,1]\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.-2.*f);\n\n    float n = p.x + p.y*57. + 113.*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.), hash(n+  1.),f.x),\n                        mix( hash(n+ 57.), hash(n+ 58.),f.x),f.y),\n                    mix(mix( hash(n+113.), hash(n+114.),f.x),\n                        mix( hash(n+170.), hash(n+171.),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p ) { // in [0,1]\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n// --- End of: Created by inigo quilez --------------------\n\n// --- more noise\n\n#define snoise(x) (2.*noise(x)-1.)\n\nfloat sfbm( vec3 p ) { // in [-1,1]\n    float f;\n    f  = 0.5000*snoise( p ); p = m*p*2.02;\n    f += 0.2500*snoise( p ); p = m*p*2.03;\n    f += 0.1250*snoise( p ); p = m*p*2.01;\n    f += 0.0625*snoise( p );\n    return f;\n}\n\n#define sfbm3(p) vec3(sfbm(p), sfbm(p-327.67), sfbm(p+327.67))\n\n// --- using the base ray-marcher of Trisomie21: https://www.shadertoy.com/view/4tfGRB#\n\nvec4 bg = vec4(0,0,.2,0);\n\nvoid mainImage( out vec4 f, vec2 w ) {\n    vec4 p = vec4(w,0,1)/iResolution.yyxy-.5, d,c; p.x-=.4; // init ray \n    (p.xz,.13); r(p.yz,.2); r(p.xy,.1);   // camera rotations\n    d = p;                                 // ray dir = ray0-vec3(0)\n    p = -vec4(0,.5,1,0)*T;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    float closest = 999.0;\n    f = vec4(bg);\n    float x1,x2,x=1e9;\n    \n    for (float i=1.; i>0.; i-=.01)  {\n        \n        // vec4 u = floor(p/8.), t = mod(p, 8.)-4., ta; // objects id + local frame\n        vec4 u = floor(p/vec4(8,8,1,1)+3.5),\n            t = p, ta,v;\n        \n        // r(t.xy,u.x); r(t.xz,u.y); r(t.yz,1.);    // objects rotations\n        u = sin(78.*(u+u.yzxw));                    // randomize ids\n        // t -= u;                                  // jitter positions\n        c = p/p*1.2;\n\t\tt.xyz += 1.*sfbm3(t.xyz/2.+vec3(-.5*T,0,0));\n \n\t\tx1 = abs(mod(t.z,.5)-.5/2.)-.0; \n        // x1 = length(t.xyz)-4.; x = max(x, x1);\n        // max(ta.x,max(ta.y,ta.z))\n        x2 = abs(mod(t.x-.5,1.)-.5)-.4; x = max(-x2,x1);\n        if (x2<.1) c = mix(c, vec4(.1,.3,.1,0)+.5*texture(iChannel0, t.xy), clamp(cos(T/8.),0.,1.));\n       \n        if(x<.01) // hit !\n            { f = mix(bg,c,i*i); break;  }  // color texture + black fog \n        \n        p += d*x;           // march ray\n     }\n     // f += vec4(1,0,0,0) * exp(-closest)*(.5+.5*cos(.5*T)); // thanks kuvkar ! \n}\n", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtXSWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[485, 485, 508, 508, 547], [549, 549, 575, 587, 980], [982, 982, 1003, 1015, 1198], [1315, 1315, 1337, 1350, 1537], [1719, 1719, 1757, 1757, 3127]], "test": "error"}
{"id": "MtXSzB", "name": "fwidth aa", "author": "rcread", "description": "left half reduced aliasing using fwidth", "tags": ["2d", "aa"], "likes": 13, "viewed": 440, "published": "Public", "date": "1437537180", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by randy read - rcread/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat sum( vec2 a ) { return a.x + a.y; }\n\n//\tmodified dgreensp/kali shader https://www.shadertoy.com/view/4ljGDd\n\nconst int MAGIC_BOX_ITERS = 13;\nconst float MAGIC_BOX_MAGIC = 0.76;\n\nfloat magicBox(vec3 p) {\n    p = 1.0 - abs(1.0 - mod(p, 2.0));\n    \n    float lastLength = length(p);\n    float tot = 0.0;\n    for (int i=0; i < MAGIC_BOX_ITERS; i++) {\n      p = abs(p)/(lastLength*lastLength) - MAGIC_BOX_MAGIC;\n      float newLength = length(p);\n      tot += abs(newLength-lastLength);\n      lastLength = newLength;\n    }\n\n    return tot;\n}\n\nconst mat3 M = mat3(0.28862355854826727, 0.6997227302779844, 0.6535170557707412,\n                    0.06997493955670424, 0.6653237235314099, -0.7432683571499161,\n                    -0.9548821651308448, 0.26025457467376617, 0.14306504491456504);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 modp = mod( floor( fragCoord.xy ), 2. );\n\tfloat m = mod( sum( modp ), 2. ) * 1.5 - .5;\n    \n\tvec2 uv = fragCoord.xy / iResolution.yy;\n    uv.x += iTime * .01;\n    vec3 p = 0.5*M*vec3(uv, 0.0);\n    float result = magicBox(p);\n    result *= 0.03;\n    result = clamp( result, 0., 1. );\n    if ( fragCoord.x < iResolution.x / 2. ) {\n        fragColor = vec4(vec3(min( result, fwidth( m * result ) / 3. )),1.0);\n    } else {\n\t\tfragColor = vec4(vec3(result),1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtXSzB.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[127, 127, 148, 148, 168], [311, 311, 335, 335, 669], [919, 919, 976, 976, 1448]], "test": "valid"}
{"id": "MtXXRB", "name": "Gears Animated ", "author": "athlete", "description": "Inspired by the tutorial by iq: https://www.youtube.com/watch?v=0ifChJ0nJfM", "tags": ["2d", "tutorial", "distancefunction", "iq"], "likes": 4, "viewed": 1313, "published": "Public API", "date": "1437524059", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.1415;\nconst float PIOVER180 = PI/180.0;\n\nconst int numRects = 17;\nconst float radius = 0.4;\n\n//naive rect \n//#define Rect(p) max(abs(p).x,abs(p).y)>.0385 ? 1. : 0.\n\n//anti aliased rect, thanks @FabriceNeyret2\n#define Rect(p) smoothstep(.035,.0385,max(abs(p).x,abs(p).y))\n\n//rotation, takes angle in degree\nvec2 Rot(vec2 p, float angle)\n{\n\tmat2 rotMatrix = mat2(cos(angle*PIOVER180), sin(angle*PIOVER180), //first column\n                          -sin(angle*PIOVER180), cos(angle*PIOVER180)); //second column\n    vec2 result = p * rotMatrix;\n\n   \treturn result;\n}\n\nfloat DrawGear(vec2 p, float radius)\n{   \n    float A=1.0; // alpha mask\n    \n    //draw teeth of gear in a circle and angled  \n    for(int i=0; i<numRects; i++)\n    {\n    \tvec2 rec = p;\n        rec = Rot(rec, float(i)*360.0/float(numRects));\n        \n   \t \trec.y -= 0.4;\n        A *= Rect(rec);\n    }\n    \n    //Draw Circle and subtract 2nd circle in the middle\n    float l = length(p);\n   \n    return max(A*smoothstep(radius, radius+5e-3, l), \n                 smoothstep(radius/10.+1e-3, radius/10., l)\n               );\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //current pixel position stored in p\n\tvec2 p = fragCoord / iResolution.y; //keeps the aspect ratio!\n    \n    //move scene\n    p -= vec2(0.715, 0.37);\n    \n    //scale\n    p *= 1.25;\n    \n    //start with background color\n    fragColor = smoothstep(vec4(0,.2,.1,1),vec4(.8,.8,1,1), p.y+vec4(.5,.4,.2,0));\n    \n    //backup current position\n    vec2 q = p;\n    \n    //animate\n    p = Rot(p, iTime*10.0);    \n    q -= vec2(0.605, 0.60);\n    q = Rot(q, -iTime*10.0 - 5.0); //rotate in opposite direction\n    \n    float G1 = DrawGear(p, radius);\n    float G2 = DrawGear(q, radius);\n\n    //fragColor *= min(G1, G2);\n    fragColor *= G1 * G2;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtXXRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[291, 325, 356, 356, 581], [583, 583, 621, 621, 1108], [1111, 1111, 1168, 1209, 1810]], "test": "valid"}
{"id": "Xl2GWm", "name": "70s Dancing Wallpaper", "author": "HamzaHutchinson", "description": "Just a little bit of messing around with no specific goals or direction.", "tags": ["2d", "sound"], "likes": 16, "viewed": 3128, "published": "Public API", "date": "1438230831", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float bgwidth = 0.2;\nconst float speed = 0.2;\nconst float size = 0.7;\nconst float thickness = 0.1;\nconst float spikiness = 0.3;\nconst float arms = 4.;\nconst float tiling = 5.;\nconst vec3 color1 = vec3( 0.9, 0.25, 0.4 );\nconst vec3 color2 = vec3( 0.3, 0.75, 0.2 );\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3( 0. );\n    \n\tvec2 uv = 2. * fragCoord.xy / iResolution.xy - vec2( 1. );\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float t = speed * iTime;\n    \n    vec2 l = normalize( vec2( cos( t ), sin( t ) ) );\n    float d = length( uv - dot( uv, l ) * l );\n    float m = ( 1.0 - bgwidth * d * d );\n    \n    uv = sin( tiling * uv );\n    float f = atan( uv.y, uv.x ) + speed * iTime;\n    \n    float s = size;\n    s += spikiness * sin( arms * f );\n    s += texture( iChannel0, vec2( 1., 0. ) ).x;\n    \n    d = length( uv ) - s;\n    bool inside = d < 0.;\n    d = abs( d );\n    \n    if( inside ) col += m * color1;\n    else col += m * color2;\n    \n\tfloat w = fwidth( d );\n\tfloat a = mix( 1., 0., smoothstep( -w, w, d - thickness ) );\n    col += a * vec3( 1. );\n    \n\tfragColor = vec4( col, 1. );\n}", "image_inputs": [{"id": "XsXGRr", "previewfilepath": "/media/ap/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xl2GWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[271, 271, 328, 328, 1139]], "test": "error"}
{"id": "XlfSRf", "name": "Psycose", "author": "PLS", "description": "Look the center of your screen during 1minute, and look at other things.", "tags": ["wave", "illusion"], "likes": 5, "viewed": 169, "published": "Public", "date": "1438343411", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float wave( vec2 uv, float rad )\n{\n    return mod(length(uv) - iTime * 100., rad) * 0.02;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy - iResolution.xy * 0.5;\n\tfragColor = vec4(0.4,1.,0.4,1.0) * wave(uv, 50.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlfSRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 91], [93, 93, 150, 150, 252]], "test": "valid"}
{"id": "XlfXDN", "name": "Miles blobs age 14", "author": "djmkultra", "description": "My young associate just learned the joy of mathgraphicshackingfun.", "tags": ["firstshader"], "likes": 0, "viewed": 106, "published": "Public", "date": "1436733736", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat blob(vec2 pos, float number) {\n    // point is the blob location.\n    vec2 point = iResolution.xy * .5 + sin(vec2(iTime) + vec2(13. * number, 20.) + number * 27.) * 100.;\n    vec2 dist = pos - point;\n    float len = length(dist);\n    dist = abs(dist);\n    float blend = (1. + sin(iTime + number * 991.)) * .5;\n    len = blend * max(dist.x, dist.y) + (1. - blend) * len;\n    float sizeJiggle = (1. + sin(iTime * number * .1 + number * 661.) * .8);\n    float d = 1. - .04 * len * sizeJiggle;    \n\treturn clamp(d, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    float invert = (1. + sin(iTime)) * .5;\n\n    float d1 = blob(fragCoord, 17.);\n    float inside = 1.;\n    if ( d1 == 0. )\n        inside = 0.;\n    d1 = invert * d1 + (1. - invert) * (1. - d1) * inside;\n    float d2 = blob(fragCoord, 13.);\n    float d3 = blob(fragCoord, 18.);\n\n    \n\tfragColor = vec4(.7, .4, .2, 1.) * d1 + vec4(.9, .1, .8, 1.) * d2 + vec4(1., .1, .1, 1.) * d3;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlfXDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 37, 72, 528], [530, 530, 587, 587, 1012]], "test": "valid"}
{"id": "XlfXRf", "name": "Cool guys...", "author": "Xender", "description": "Cool guys don't look at explosions...\n...because of hazard of being hit by small metal parts in the eyes, baby.\n\n// Really just a bunch of \"stolen\" content glued together, see comments in source for credits.\n// Just a baby's first 2 hours compo shader.", "tags": ["explosions", "warsztat"], "likes": 5, "viewed": 459, "published": "Public", "date": "1438372813", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// From https://www.shadertoy.com/view/llXXD4\n\nfloat warsztat(vec2 uv1)\n{\n\tvec2 uv = (((((uv1 * 2.0) - 1.0) * 1.1818) + 1.0) * 0.5);\n\tif (uv.x > 0.09090909090909091 && uv.x < 0.6363636363636364 && uv.y > 0.4090909090909091 && uv.y < 0.5454545454545454) return 1.0;\n\tif (uv.x > 0.5454545454545454 && uv.x < 0.7727272727272727 && uv.y > 0.5454545454545454 && uv.y < 0.7727272727272727) return 1.0;\n\tif (uv.x > 0.4090909090909091 && uv.x < 0.5454545454545454 && uv.y > 0.09090909090909091 && uv.y < 0.4090909090909091) return 1.0;\n\tif (uv.x > 0.3181818181818182 && uv.x < 0.45454545454545453 && uv.y > 0.0 && uv.y < 0.09090909090909091) return 1.0;\n\tif (uv.x > 0.4090909090909091 && uv.x < 0.5454545454545454 && uv.y > 0.5454545454545454 && uv.y < 0.6363636363636364) return 1.0;\n\tif (uv.x > 0.7727272727272727 && uv.x < 0.9090909090909091 && uv.y > 0.9090909090909091 && uv.y < 1.0) return 1.0;\n\tif (uv.x > 0.0 && uv.x < 0.09090909090909091 && uv.y > 0.3181818181818182 && uv.y < 0.45454545454545453) return 1.0;\n\tif (uv.x > 0.9090909090909091 && uv.x < 1.0 && uv.y > 0.7727272727272727 && uv.y < 0.9090909090909091) return 1.0;\n\tif (uv.x > 0.3181818181818182 && uv.x < 0.4090909090909091 && uv.y > 0.3181818181818182 && uv.y < 0.4090909090909091) return 1.0;\n\tif (uv.x > 0.6363636363636364 && uv.x < 0.7272727272727273 && uv.y > 0.7727272727272727 && uv.y < 0.8636363636363636) return 1.0;\n\tif (uv.x > 0.7727272727272727 && uv.x < 0.8636363636363636 && uv.y > 0.6363636363636364 && uv.y < 0.7272727272727273) return 1.0;\n\tif (uv.x > 0.45454545454545453 && uv.x < 0.5454545454545454 && uv.y > 0.6363636363636364 && uv.y < 0.6818181818181818) return 1.0;\n\tif (uv.x > 0.6363636363636364 && uv.x < 0.7272727272727273 && uv.y > 0.5 && uv.y < 0.5454545454545454) return 1.0;\n\tif (uv.x > 0.6818181818181818 && uv.x < 0.7727272727272727 && uv.y > 0.8636363636363636 && uv.y < 0.9090909090909091) return 1.0;\n\tif (uv.x > 0.8636363636363636 && uv.x < 0.9545454545454546 && uv.y > 0.7272727272727273 && uv.y < 0.7727272727272727) return 1.0;\n\tif (uv.x > 0.0 && uv.x < 0.045454545454545456 && uv.y > 0.2727272727272727 && uv.y < 0.3181818181818182) return 1.0;\n\tif (uv.x > 0.045454545454545456 && uv.x < 0.09090909090909091 && uv.y > 0.45454545454545453 && uv.y < 0.5) return 1.0;\n\tif (uv.x > 0.09090909090909091 && uv.x < 0.13636363636363635 && uv.y > 0.36363636363636365 && uv.y < 0.4090909090909091) return 1.0;\n\tif (uv.x > 0.2727272727272727 && uv.x < 0.3181818181818182 && uv.y > 0.0 && uv.y < 0.045454545454545456) return 1.0;\n\tif (uv.x > 0.2727272727272727 && uv.x < 0.3181818181818182 && uv.y > 0.36363636363636365 && uv.y < 0.4090909090909091) return 1.0;\n\tif (uv.x > 0.36363636363636365 && uv.x < 0.4090909090909091 && uv.y > 0.09090909090909091 && uv.y < 0.13636363636363635) return 1.0;\n\tif (uv.x > 0.36363636363636365 && uv.x < 0.4090909090909091 && uv.y > 0.2727272727272727 && uv.y < 0.3181818181818182) return 1.0;\n\tif (uv.x > 0.36363636363636365 && uv.x < 0.4090909090909091 && uv.y > 0.5454545454545454 && uv.y < 0.5909090909090909) return 1.0;\n\tif (uv.x > 0.45454545454545453 && uv.x < 0.5 && uv.y > 0.045454545454545456 && uv.y < 0.09090909090909091) return 1.0;\n\tif (uv.x > 0.5 && uv.x < 0.5454545454545454 && uv.y > 0.6818181818181818 && uv.y < 0.7272727272727273) return 1.0;\n\tif (uv.x > 0.5454545454545454 && uv.x < 0.5909090909090909 && uv.y > 0.36363636363636365 && uv.y < 0.4090909090909091) return 1.0;\n\tif (uv.x > 0.5909090909090909 && uv.x < 0.6363636363636364 && uv.y > 0.7727272727272727 && uv.y < 0.8181818181818182) return 1.0;\n\tif (uv.x > 0.6363636363636364 && uv.x < 0.6818181818181818 && uv.y > 0.45454545454545453 && uv.y < 0.5) return 1.0;\n\tif (uv.x > 0.7272727272727273 && uv.x < 0.7727272727272727 && uv.y > 0.9090909090909091 && uv.y < 0.9545454545454546) return 1.0;\n\tif (uv.x > 0.7727272727272727 && uv.x < 0.8181818181818182 && uv.y > 0.5909090909090909 && uv.y < 0.6363636363636364) return 1.0;\n\tif (uv.x > 0.8636363636363636 && uv.x < 0.9090909090909091 && uv.y > 0.6818181818181818 && uv.y < 0.7272727272727273) return 1.0;\n\tif (uv.x > 0.8636363636363636 && uv.x < 0.9090909090909091 && uv.y > 0.8636363636363636 && uv.y < 0.9090909090909091) return 1.0;\n\tif (uv.x > 0.9090909090909091 && uv.x < 0.9545454545454546 && uv.y > 0.9090909090909091 && uv.y < 0.9545454545454546) return 1.0;   \n\treturn 0.0;\n}\n\nvec3 sample_back(vec2 uv1, float start, float speed, float scale, vec2 mov)\n{ \n   vec2 uv = ((uv1) * 2.0) - 1.0;\n   float rot = start + iTime * speed;\n   mat2 m = mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n   uv = m * uv;\n   uv = uv + mov;\n   uv = uv * scale;\n   uv = (uv + 1.0) * 0.5;\n   return texture(iChannel0, uv).rrr;\n}\n\nvec3 draw_warsztat(vec3 base, vec2 uv, float col,float alpha)\n{\n\tfloat v = 0.0;\n\tif (warsztat(uv) > 0.99) v = alpha;\n\treturn mix(base, vec3(col), v);\n}\n\n\n// From https://www.shadertoy.com/view/lsf3RH\n\nfloat snoise(vec3 uv, float res)\n{\n\tconst vec3 s = vec3(1e0, 1e2, 1e3);\n\t\n\tuv *= res;\n\t\n\tvec3 uv0 = floor(mod(uv, res))*s;\n\tvec3 uv1 = floor(mod(uv+vec3(1.), res))*s;\n\t\n\tvec3 f = fract(uv); f = f*f*(3.0-2.0*f);\n\n\tvec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,\n\t\t      \t  uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);\n\n\tvec4 r = fract(sin(v*1e-1)*1e3);\n\tfloat r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\tr = fract(sin((v + uv1.z - uv0.z)*1e-1)*1e3);\n\tfloat r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\treturn mix(r0, r1, f.z)*2.-1.;\n}\n\nvec3 explosion(vec2 p)\n{\n\t// vec2 p = -.5 + fragCoord.xy / iResolution.xy;\n\t// p.x *= iResolution.x/iResolution.y;\n\t\n\tfloat color = 3.0 - (3.*length(2.*p));\n\t\n\tvec3 coord = vec3(atan(p.x,p.y)/6.2832+.5, length(p)*.4, .5);\n\t\n\tfor(int i = 1; i <= 7; i++)\n\t{\n\t\tfloat power = pow(2.0, float(i));\n\t\tcolor += (1.5 / power) * snoise(coord + vec3(0.,-iTime*.05, iTime*.01), power*16.);\n\t}\n\t// return vec4( color, pow(max(color,0.),2.)*0.4, pow(max(color,0.),3.)*0.15 , 1.0);\n\treturn vec3( color, pow(max(color,0.),2.)*0.4, pow(max(color,0.),3.)*0.15);\n}\n\n\n\n// From https://www.shadertoy.com/view/MdlGWX\n//Credit: http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 blackout_noise(vec2 uv)\n{\n\t//Fragment position, only used as random seed\n\t// vec2 uv = fragCoord.xy / iResolution.xy; \n\t\n\t//Flicker frequency\n\tfloat flicker = 10.0;\n\t\t\n\t//Play with power to change noise frequency\n\tfloat freq = sin(pow(mod(iTime, flicker)+flicker, 1.9));\n\t\n\t//Play with this to change raster dot size (x axis only, y is calculated with aspect ratio)\n\tfloat pieces = float(1000);\n\t\n\t//Calculations to maintain square pixels\n\tfloat ratio_x = 1.0 / pieces;\n\tfloat ratio_y = ratio_x * iResolution.x / iResolution.y;\n\tfloat half_way_x = abs(freq * ratio_x);\n\tfloat half_way_y = abs(freq * ratio_y);\n\t\t\n\t//Comment this out to see how raster dots are simulated (noise overlay)\n\t// col *= vec3(rand(uv+mod(iTime, freq)), rand(uv+mod(iTime+.1, freq)), rand(uv));\n\t\t\n\t//Use this for greyscale noise, comment out the line above (noise overlay)\n\treturn vec3(rand(uv+mod(iTime, freq)), rand(uv+mod(iTime, freq)), rand(uv+mod(iTime, freq)));\n}\n\n\n// helpers\n\nfloat sawtooth(float t, float period)\n{\n\treturn mod(t, period) / period;\n}\n\n\n// Main\n\n#define WHOLE_ANIM_TIME 7.0\n// #define MAIN_ANIM_TIME 5.0\n\n#define WRENCH_ANIM_START 1.0\n#define WRENCH_ANIM_END   5.0\n\n#define EXPL_ANIM_START 0.0\n#define EXPL_ANIM_END   5.0\n\n#define BLACKOUT_ANIM_START 5.0\n#define BLACKOUT_ANIM_END   7.0\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = 2.0 * (fragCoord.xy / iResolution.xy) - 1.0;\n\tuv *= vec2(iResolution.x / iResolution.y, -1.0);\n\n\tvec3 col = vec3(0);\n\n\n\tfloat time = mod(iTime, WHOLE_ANIM_TIME);\n\n\tif ( time > EXPL_ANIM_START && time < EXPL_ANIM_END ) {\n\t\tfloat expl_t = (time - EXPL_ANIM_START) / (EXPL_ANIM_END - EXPL_ANIM_START);\n\n\t\tvec2 explosion_uv = log(expl_t) * uv * 0.5;\n\t\t// vec2 explosion_uv = -exp(-expl_t) * uv * 5.0;\n\t\t// vec2 explosion_uv = (1.0-expl_t) * uv * 5.0;\n\t\tcol += explosion(explosion_uv);\n\t}\n\n\tif ( time > WRENCH_ANIM_START && time < WRENCH_ANIM_END ) {\n\t\tfloat wrench_t = (time - WRENCH_ANIM_START) / (WRENCH_ANIM_END - WRENCH_ANIM_START);\n\n\t\tvec2 warsztat_uv = uv;\n\t\t// warsztat_uv *= (sin(iTime*2.2+0.3)*0.1)+1.0;\n\t\twarsztat_uv = (1.0-wrench_t) * uv * 100.0; // (sin(iTime*2.2+0.3)*0.1)+1.0;\n\n\t\t// uv += 1.0;\n\t\t// uv *= 0.5;\n\n\t\t// You spin me right round, baby, right round...\n\t\tfloat rot_angle = wrench_t * 4.0;\n\t\twarsztat_uv *= mat2(sin(rot_angle), cos(rot_angle), cos(rot_angle), -sin(rot_angle));\n\t\t\n\t\twarsztat_uv += 1.0;\n\t\twarsztat_uv *= 0.5;\n\t\t\n\t\tfloat uvm = 1.0 / 26.0;\n\t\t\n\t\tcol = draw_warsztat(col, warsztat_uv + vec2(-uvm*0.0, -uvm * 2.0), 0.0, 0.5);\n\t\tcol = draw_warsztat(col, warsztat_uv - vec2(uvm, 0.0), 160.0/255.0, 1.0);\n\t\tcol = draw_warsztat(col, warsztat_uv - vec2(-uvm, 0.0), 160.0/255.0, 1.0);\n\t\tcol = draw_warsztat(col, warsztat_uv - vec2(0.0, uvm), 160.0/255.0, 1.0);\n\t\tcol = draw_warsztat(col, warsztat_uv - vec2(0.0, -uvm), 160.0/255.0, 1.0);\n\t\tcol = draw_warsztat(col, warsztat_uv, 80.0/255.0, 1.0);\n\t}\n\n\tif ( time > BLACKOUT_ANIM_START && time < BLACKOUT_ANIM_END ) {\n\t\tcol = blackout_noise(uv);\n\t}\n\n\tfragColor = vec4(vec3(col), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlfXRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 73, 73, 4338], [4340, 4340, 4417, 4417, 4669], [4671, 4671, 4734, 4734, 4822], [4872, 4872, 4906, 4906, 5430], [5432, 5432, 5456, 5546, 5977], [5981, 6112, 6132, 6132, 6204], [6206, 6206, 6236, 6352, 7156], [7171, 7171, 7210, 7210, 7245], [7499, 7499, 7554, 7554, 9222]], "test": "error"}
{"id": "XlfXzM", "name": "Reactive Sphere", "author": "glk7", "description": "A reactive ray marched sphere. The typical sphere perturbed by a couple ceiled sin waves based on some frequencies of the music played.", "tags": ["raymarch", "reactive", "sphere"], "likes": 77, "viewed": 6102, "published": "Public API", "date": "1436473084", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by genis sole - 2015\n// License Creative Commons Attribution 4.0 International License.\n\n// Enable more representative frequency analysis.\n//#define CF \n\n// Toggle non-reactive version.\n// #define S\n\nvec4 freqs = vec4(0.6, 0.7, 0.2, 0.2);\n\nvec4 FreqAnalysis() {\n#ifdef S\n    return freqs;\n#endif\n    \n    vec4 sy = vec4(0.0);    \n    \n#ifdef CF\n    // 0.25 / (512 / 4) = 0.001953125\n    for(float i = 0.0; i < 0.25; i += 0.001953125) {\n   \t\tsy.x += texture(iChannel0, vec2(i, 0.0)).x;\n    }\n    \n    for(float i = 0.25; i < 0.5; i += 0.001953125) {\n   \t\tsy.y += texture(iChannel0, vec2(i, 0.0)).x;\n    }\n    \n    for(float i = 0.5; i < 0.75; i += 0.001953125) {\n   \t\tsy.z += texture(iChannel0, vec2(i, 0.0)).x;\n    }\n    \n    for(float i = 0.75; i <= 1.0; i += 0.001953125) {\n   \t\tsy.w += texture(iChannel0, vec2(i, 0.0)).x;\n    }\n    sy *= vec4(0.0078125); // 1 / (512 / 4) = 0.0078125\n    \n#else\n    \n    sy.x = texture(iChannel0, vec2(0.0, 0.0)).x;\n\tsy.y = texture(iChannel0, vec2(0.33, 0.0)).x;\n    sy.z = texture(iChannel0, vec2(0.66, 0.0)).x;\n    sy.w = texture(iChannel0, vec2(1.0, 0.0)).x;\n    \n#endif\n    \n    return sy;\n    //return step(0.01, iChannelTime[0])*sy + (1.0 - step(0.01, iChannelTime[0]))*freqs;\n}\n\n\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat sin3(in vec3 p) {\n\treturn (sin(p.x) + sin(p.y) + sin(p.z));\n}\n\nfloat noise(in vec3 p) {\n    float j = iTime * 0.045;\n    float v = (sin3((p+vec3(j*7.0, j*2.3, j*1.0)) * 10.0) * freqs.w +\n               sin3((p+vec3(j*3.0, j*1.2, j*0.4)) * 8.0) * freqs.z +\n               sin3((p+vec3(j*2.4, j*0.6, j*2.6)) * 6.0) * freqs.y +\n               sin3((p+vec3(j*1.4, j*5.8, j*1.9)) * 4.0) * freqs.x) * 0.25;\n    //return 0.0;\n    \n    v = abs(v);\n    float f = floor(v*10.0);\n    \n    v = clamp((smoothstep(0.0, 1.0, mix(0.1, 0.2, v*10.0-f)) + f)* 0.1, 0.0, 1.0);\n    return v;\n}\n\n// Taken from http://iquilezles.org/www/articles/palettes/palettes.htm\nvec3 ColorPalette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nbool RaySphereIntersection(in vec3 ro, in vec3 rd, in vec3 c, in float r, out vec3 p0, out vec3 p1) {\n    p0 = vec3(0.0);\n    p1 = vec3(0.0);\n    \n   \tvec3 oc = ro - c;\n    float poc = dot(rd, oc);\n    \n    float sloc = dot(oc, oc);\n    float test = poc*poc - sloc + r*r;\n        \n    if (test < 0.0) return false;\n    \n    float sqt = sqrt(test);\n    float d0 = -poc - sqt;\n    float d1 = -poc + sqt;\n    \n\tp0 = ro + d0*rd;\n    p1 = ro + d1*rd;\n    return true;\n}\n\nvec3 SphereNormal(in vec3 d, in float r, in float e) {\n    float theta = atan(d.y,d.x) ;\n    float phy = acos(d.z);\n    \n    vec3 dy0 = vec3(cos(theta+e)*sin(phy), sin(theta+e)*sin(phy), cos(phy));\n    vec3 dy1 = vec3(cos(theta-e)*sin(phy), sin(theta-e)*sin(phy), cos(phy));\n\n    vec3 dx0 = vec3(cos(theta)*sin(phy+e), sin(theta)*sin(phy+e), cos(phy+e));\n    vec3 dx1 = vec3(cos(theta)*sin(phy-e), sin(theta)*sin(phy-e), cos(phy-e));\n    \n    float ny0 = noise(dy0*r);\n    float ny1 = noise(dy1*r);\n    float nx0 = noise(dx0*r);\n    float nx1 = noise(dx1*r);\n    \n    dy0 *= r + ny0;\n    dy1 *= r + ny1;\n    dx0 *= r + nx0;\n    dx1 *= r + nx1;\n    \n    return normalize(cross(dy0 - dy1, dx1 - dx0));\n}\n\nbool RayMarchPerturbedSphere(in vec3 ro, in vec3 rd, in vec3 c, in float r, in float br, \n                             out vec3 n, out vec3 sd) {\n    n = vec3(0.0);\n    sd = vec3(0.0);\n    \n    vec3 bp0 = vec3(0.0);\n    vec3 bp1 = vec3(0.0);\n    bool bres = RaySphereIntersection(ro, rd, c, br, bp0, bp1);\n    if (!bres) return false;\n    \n    vec3 p0 = vec3(0.0); \n    vec3 p1 = vec3(0.0);\n    bool res = RaySphereIntersection(ro, rd, c, r, p0, p1); \n    \n    float dist = float(res)*length(p0 - bp0) + (1.0-float(res)) * length(bp0 - bp1);\n\t//float dist = length(bp0 - bp1);\n    const float sc = 128.0;\n    const float invsc = 1.0 / sc;\n    float s = dist * invsc;\n    \n    bool ret = false;\n    vec3 pn = vec3(0.0);\n    for (float d = 0.0; d < sc; ++d) {\n    \tpn = (bp0 + d*s*rd) - c;\n\t\t\n        sd = normalize(pn) * r;\n        float h = length(pn) - r - s;\n        \n        float h0 = noise(sd);\n        if (h0 > h) {\n            ret = true;\n            break;\n        } \n    }\n    \n    n = SphereNormal(normalize(pn), r, s);\n    return ret;\n}\n\n\n// Based on this: http://iquilezles.org/www/articles/rmshadows/rmshadows.htm        \nfloat ShadowFactor(in vec3 sd, in vec3 ld, in vec3 c, in float r, in float br) {\n    float w = noise(sd);\n    vec3 ro = c + (normalize(sd) * (w+r));\n    \n    vec3 bp0 = vec3(0.0);\n    vec3 bp1 = vec3(0.0);\n    bool bres = RaySphereIntersection(ro, -ld, c, br, bp0, bp1);\n    \n    vec3 p0 = vec3(0.0);\n    vec3 p1 = vec3(0.0);\n    bool res = RaySphereIntersection(ro, -ld, c, r, p0, p1);\n    \n    float dist = min(length(ro - bp0)+ float(!bres) * 10000.0, \n                     length(ro - p0) + float(!res) * 10000.0);\n    \n    const float sc = 128.0;\n    const float invsc = 1.0 / sc;\n    float s = dist * invsc;\n    \n    float dmin = 1.0;\n    \n    for (float d = 0.0; d < sc; ++d) {\n    \tvec3 pn = (ro + d*s*-ld) - c;\n\t\t\n        sd = normalize(pn) * r;\n        float h = length(pn) - r + s;\n        \n        float h0 = noise(sd);\n        if (h0 > h) {\n            dmin = 0.0;\n            break;\n        }\n        \n        dmin = min(dmin, 4.0*(h-h0)/(d*s));\n    }\n    \n    return clamp(dmin, 0.0, 1.0);\n    \n}\n\n\nvec3 GetColor(vec3 sd) {\n    float n = noise(sd);\n    vec3 c = ColorPalette(n, vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5),\n                             vec3(1.0, 1.0, 0.5), vec3(0.4, 0.3, 0.5));\n    \n    c = rgb2hsv(c);\n    c.y += 0.30;\n    c.z += 0.1;\n    c = hsv2rgb(c);\n    \n    return c;\n    \n}\n\nvec3 CameraRay(vec2 fragCoord, float n) {\n    float a = 1.0/max(iResolution.x, iResolution.y);\n    \n    return normalize(vec3((fragCoord - iResolution.xy*0.5)*a, n));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 rd = CameraRay(fragCoord, 1.0);\n    \n    vec3 sc = vec3(0.0, 0.0, 10.0);\n    float sr = 1.0;\n \n    vec3 n = vec3(0.0);\n    vec3 sd = vec3(0.0);\n    if (RaySphereIntersection(vec3(0.0), rd, sc, sr+1.0, n, sd)) {\n        freqs = FreqAnalysis();\n    }\n    \n    bool hit = RayMarchPerturbedSphere(vec3(0.0), rd, sc, sr, sr+1.0, n, sd);\n    \n    vec3 color = vec3(0.05);\n    if (hit) {\n        \n        float w = max(max(freqs.x,freqs.y) , max(freqs.z, freqs.w));\n        vec2 nM = vec2(sin(iTime*1.4), cos(iTime*1.2));\n        \n        vec3 l = normalize(vec3(-(nM.x*2.0 -1.0), -(nM.y*2.0 - 1.0), -0.9 + w*3.0));\n        \n        float sf = ShadowFactor(sd, l, sc, sr, sr+1.0);\n        \n        color = GetColor(sd);\n        vec3 diff = color * max(dot(-l, n), 0.0 ) * sf * 0.95;\n        vec3 amb = color * 0.05;\n        \n        color = diff;\n    \tcolor += amb;\n    }\n    \n    fragColor = vec4(pow(color, vec3(0.55)), 1.0);\n}", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlfXzM.jpg", "access": "shaders20k", "license": "cc-by-4.0", "functions": [[251, 251, 272, 272, 1231], [1234, 1234, 1256, 1256, 1587], [1589, 1589, 1611, 1611, 1780], [1782, 1782, 1805, 1805, 1849], [1851, 1851, 1875, 1875, 2360], [2362, 2433, 2509, 2509, 2552], [2555, 2555, 2656, 2656, 3019], [3021, 3021, 3075, 3075, 3722], [3724, 3724, 3869, 3869, 4771], [4774, 4859, 4939, 4939, 5870], [5873, 5873, 5897, 5897, 6169], [6171, 6171, 6212, 6212, 6339], [6342, 6342, 6399, 6399, 7331]], "test": "error"}
{"id": "XllXWr", "name": "Tet shadows", "author": "ryanmichael", "description": "Moving tet that casts shadows", "tags": ["shadows", "tet"], "likes": 1, "viewed": 103, "published": "Public", "date": "1436242314", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Struct to bind bool toggle with an intersection point for geometry processing\nstruct iPoint\n{\n\tvec3 point;\n    vec3 normal;\n    bool intersected;\n};\n\n//P is ray initial point. d is ray direction. ABC are tri vertices\niPoint rayTriangleTest( vec3 P, vec3 d, vec3 A, vec3 B, vec3 C )\n{\n    iPoint returnPoint;\n    returnPoint.intersected = false;\n    \n\t//Cull faces where normals are opposing - make sure winding order is right\n\tvec3 triNorm = normalize(cross( B - A, C- A ));    \n\n    //Back face and parallel check\n    if( dot(d,triNorm) <= 0.0 )\n        return returnPoint;\n     \n    //Ray-plane intersection\n    float dPlane = dot(triNorm,A);\n    \n\tfloat t = (dPlane - dot(triNorm,P))/ dot(d,triNorm);\n    \n    //Plane intersection point\n    vec3 Q = P + t*d;\n    \n    float a = dot(triNorm,cross(B-A,Q-A));\n    float b = dot(triNorm,cross(C-B,Q-B));\n    float c = dot(triNorm,cross(A-C,Q-C));\n\n    if( a >= 0.0 && b >= 0.0 && c >= 0.0 )\n    {\n        returnPoint.point = Q;\n        returnPoint.normal = triNorm;\n        returnPoint.intersected = true;\n    }\n    \n    return returnPoint; \n}\n\n\n\nvec3 tetVert0 = vec3( 0.0, 0.0, 0.0);\nvec3 tetVert1 = vec3( 1.0, 0.0, 0.0);\nvec3 tetVert2 = vec3( 0.0, 1.0, 0.0);\nvec3 tetVert3 = vec3( 0.0, 0.0, 1.0);\n\nvec3 tetCenter = vec3( 0.25, 0.25, 0.25 );\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    //Scale matrix\n    mat4 S = mat4( iResolution.x/10.0, 0.0, 0.0, 0.0,\n                  \t0.0, iResolution.x/10.0, 0.0, 0.0,\n                  \t0.0, 0.0, iResolution.x/10.0, 0.0,\n                 \t0.0, 0.0, 0.0, 1.0);\n    \n    mat4 preT = mat4( 1.0, 0.0, 0.0, 0.0,\n                  \t0.0, 1.0, 0.0, 0.0,\n                  \t0.0, 0.0, 1.0, 0.0,\n                 \t- tetCenter.x, -tetCenter.y, -tetCenter.z, 1.0);\n    \n    float r1Rotate = 0.3 * iTime;\n    \n    mat4 R1 = mat4( cos(r1Rotate), -sin(r1Rotate), 0.0, 0.0,\n                   \tsin(r1Rotate), cos(r1Rotate), 0.0, 0.0,\n                   0.0, 0.0, 1.0, 0.0,\n                   0.0, 0.0, 0.0, 1.0 );\n    \n    float r2Rotate = 0.5 * iTime;\n   \n    \n    mat4 R2 = mat4( cos(r2Rotate), 0.0, -sin(r2Rotate), 0.0,\n                   0.0, 1.0, 0.0, 0.0,\n                   \tsin(r2Rotate), 0.0, cos(r2Rotate), 0.0,\n                   0.0, 0.0, 0.0, 1.0 );    \n    \n    mat4 postT = mat4( 1.0, 0.0, 0.0, 0.0,\n                  \t0.0, 1.0, 0.0, 0.0,\n                  \t0.0, 0.0, 1.0, 0.0,\n                 \tiResolution.x/2.0, iResolution.y/2.0, iResolution.x/4.0*sin(iTime), 1.0);\n\n\ttetVert0 = (postT * R2 * R1 * S * preT * vec4( tetVert0, 1.0)).xyz;\n\ttetVert1 = (postT * R2 * R1 * S * preT * vec4( tetVert1, 1.0)).xyz;\n\ttetVert2 = (postT * R2 * R1 * S * preT * vec4( tetVert2, 1.0)).xyz; \n    tetVert3 = (postT * R2 * R1 * S * preT * vec4( tetVert3, 1.0)).xyz;\n \n    \n    \n    //World space position of background canvas\n\tvec3 canvas = vec3( fragCoord.x, fragCoord.y, -iResolution.x/2.0 );\n        \n    //Camera position\n    vec3 cam = vec3( iResolution.x/2.0,iResolution.y/2.0, iResolution.x/2.0 );\n    \n    //Light source vectors\n    vec3 L1Pos = vec3( iResolution.x/4.0,iResolution.y/4.0, iResolution.x );\n    vec3 L1Color = vec3(0.6, 0.5, 0.5);\n    \n    vec3 L2Pos = vec3( iResolution.x,iResolution.y/2.0, iResolution.x/2.0 );\n    vec3 L2Color = vec3(0.5, 0.5, 0.6);        \n    \n    vec3 Lamb = vec3( 0.4 );\n    \n    //Tet colors\n    vec4 tetColor0 = vec4( 0.85, 0.85, 0.0, 1.0 );\n    vec4 tetColor1 = vec4( 0.0, 0.85, 0.85, 1.0 );\n    vec4 tetColor2 = vec4( 0.85, 0.0, 0.85, 1.0 );\n    vec4 tetColor3 = vec4( 0.75, 0.75, 0.75, 1.0 );\n\n    //Ray from canvas to camera\n    vec3 R = normalize( cam - canvas );\n    \n    bool intersects = false;\n\n    iPoint triTest0 = rayTriangleTest( canvas, R, tetVert0, tetVert3, tetVert2 );\n\n    if( triTest0.intersected == true )\n    {\n        vec3 L1 = normalize( L1Pos - triTest0.point );\n     \tvec3 diffuseColor = L1Color * dot( triTest0.normal, L1 );\n        \n\n       \tvec3 V = normalize( cam - triTest0.point );\n        vec3 L2 = normalize( L2Pos - triTest0.point );\n        vec3 R2 = 2.0 * dot( triTest0.normal, L2 ) * triTest0.normal - L2;\n        vec3 specularColor = L2Color * pow( max( 0.0, dot(R2,V) ),8.0 );\n        \n        fragColor = vec4( diffuseColor + specularColor + Lamb, 1.0 ) * tetColor0;       \n   \n        return;\n    }\n  \n    iPoint triTest1 = rayTriangleTest( canvas, R, tetVert1, tetVert2, tetVert3 );\n  \n    if( triTest1.intersected == true )\n    {\n        vec3 L1 = normalize( L1Pos - triTest1.point );\n     \tvec3 diffuseColor = L1Color * dot( triTest1.normal, L1 );\n\n        vec3 V = normalize( cam - triTest1.point );\n        vec3 L2 = normalize( L2Pos - triTest1.point );\n        vec3 R2 = 2.0 * dot( triTest1.normal, L2 ) * triTest1.normal - L2;\n        vec3 specularColor = L2Color * pow( max( 0.0, dot(R2,V) ),8.0 );\n        \n        fragColor = vec4( diffuseColor + specularColor + Lamb, 1.0 ) * tetColor1;        \n   \n        return;\n    }\n \n    iPoint triTest2 = rayTriangleTest( canvas, R, tetVert0, tetVert2, tetVert1 );\n    \n    if( triTest2.intersected == true )\n    {\n        \n        \n        vec3 L1 = normalize( L1Pos - triTest2.point );\n     \tvec3 diffuseColor = L1Color * dot( triTest2.normal, L1 );\n        \n       \tvec3 V = normalize( cam - triTest2.point );\n        vec3 L2 = normalize( L2Pos - triTest2.point );\n        vec3 R2 = 2.0 * dot( triTest2.normal, L2 ) * triTest2.normal - L2;\n        vec3 specularColor = L2Color * pow( max( 0.0, dot(R2,V) ),8.0 );\n        \n        fragColor = vec4( diffuseColor + specularColor + Lamb, 1.0 ) * tetColor2;\n                                                                    \n   \n        \n        return;\n    }\n    \n\n    iPoint triTest3 = rayTriangleTest( canvas, R, tetVert0, tetVert1, tetVert3 );\n   \n    if( triTest3.intersected == true )\n    {\n        vec3 L1 = normalize( L1Pos - triTest3.point );\n     \tvec3 diffuseColor = L1Color * dot( triTest3.normal, L1 );\n        \n        vec3 V = normalize( cam - triTest3.point );\n        vec3 L2 = normalize( L2Pos - triTest3.point );\n        vec3 R2 = 2.0 * dot( triTest3.normal, L2 ) * triTest3.normal - L2;\n        vec3 specularColor = L2Color * pow( max( 0.0, dot(R2,V) ),8.0 );\n        \n        fragColor = vec4( diffuseColor + specularColor + Lamb, 1.0 ) * tetColor3;        \n   \n        return;\n    }    \n  \n\n    //Shadows\n    \n    //First light\n    R = L1Pos - canvas;\n    iPoint triShadowTest0 = rayTriangleTest( canvas, R, tetVert0, tetVert3, tetVert2 );    \n    iPoint triShadowTest1 = rayTriangleTest( canvas, R, tetVert1, tetVert2, tetVert3 );\n    iPoint triShadowTest2 = rayTriangleTest( canvas, R, tetVert0, tetVert2, tetVert1 );\n    iPoint triShadowTest3 = rayTriangleTest( canvas, R, tetVert0, tetVert1, tetVert3 );\n   \n    if( triShadowTest0.intersected == true || \n       triShadowTest1.intersected == true ||\n       triShadowTest2.intersected == true || \n       triShadowTest3.intersected == true )\n    {\n        L1Color = vec3(0.0);\n    }\n    \n    //Second light\n    R = L2Pos - canvas;\n    triShadowTest0 = rayTriangleTest( canvas, R, tetVert0, tetVert3, tetVert2 );    \n    triShadowTest1 = rayTriangleTest( canvas, R, tetVert1, tetVert2, tetVert3 );\n    triShadowTest2 = rayTriangleTest( canvas, R, tetVert0, tetVert2, tetVert1 );\n    triShadowTest3 = rayTriangleTest( canvas, R, tetVert0, tetVert1, tetVert3 );\n   \n    if( triShadowTest0.intersected == true || \n       triShadowTest1.intersected == true ||\n       triShadowTest2.intersected == true || \n       triShadowTest3.intersected == true )\n    {\n        L2Color = vec3(0.0);\n    }    \n    \n    vec2 uv = vec2(fragCoord.x,-fragCoord.y) / iResolution.xy;\n    fragColor = texture( iChannel0, uv ) * vec4(L1Color + L2Color + Lamb,1.0);\n    \n    return;\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XllXWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[152, 219, 285, 285, 1094], [1295, 1295, 1352, 1375, 7721]], "test": "error"}
{"id": "XlsSW7", "name": "Circles wave", "author": "arthew0", "description": "Circles wave", "tags": ["bw"], "likes": 4, "viewed": 181, "published": "Public", "date": "1437165217", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n//  Circles\n//\thttp://www.alexeyrudenko.com/\n//\n//  Created by Alexey Roudenko on 17/07/15.\n//  Copyright (c) 2015 Alexey Roudenko. All rights reserved.\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat aspect = iResolution.x / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 position = 0.5 - uv;\n    vec2 uva = vec2(position.x, position.y / aspect);\n    float v = uva.x * 10.0 * sin(uva.y * 10.0) - 10.0 * uva.y* sin(uva.x * 10.0);\n    float value = 0.08 + 1.0 / (80.0 * sin(iTime * 2.5 + v));    \n    vec2 uvd = mod(uva, value) - value / 2.0;\n    float c = .01 / sqrt(dot(uvd, uvd));\n\tfloat summ = smoothstep(0.4, 0.43, c);\n\tvec3 color = vec3(summ, summ, summ);    \n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlsSW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[160, 160, 217, 217, 736]], "test": "valid"}
{"id": "XlsXRj", "name": "Rotating world", "author": "farious", "description": "Testing out several things, focused on the lambertian shading.", "tags": ["3d", "sphere", "lambertian"], "likes": 5, "viewed": 223, "published": "Public", "date": "1438034922", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 sphere(vec2 uv, vec2 pos, float r, vec3 light)\n{\n    vec2 p = uv - pos;\n    float d = length(p) - r;\n    float z = sqrt(abs(r*r - dot(p, p)));\n    vec3 pP = normalize(vec3(p, z));\n    float i = dot(pP, light);\n    \n    return vec4(i,i,i,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy;\n    vec3 light = normalize(vec3(cos(iTime) * 10.0, sin(iTime) * 15.0, sin(iTime)*10.0 + cos(iTime + 11.0)*5.0));\n    vec2 center = iResolution.xy * 0.5 + vec2(sin(iTime), cos(iTime)) * 160.0;\n\tfloat radius = 0.25 * iResolution.y;    \n    fragColor = sphere(uv, center, radius, light);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlsXRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 53, 53, 249], [251, 251, 308, 308, 620]], "test": "valid"}
{"id": "XlXXRj", "name": "Folding flower", "author": "qleonetti", "description": "Still having fun learning shaders with http://patriciogonzalezvivo.com/2015/thebookofshaders/, hope you will enjoy !  pretty sure the code could be better...", "tags": ["2d", "animation", "pink"], "likes": 1, "viewed": 133, "published": "Public", "date": "1437772100", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat motif(vec2 uv, float fr) {\n    vec2 st = uv - 0.5;\n    st = rotate2d( - iTime * fr / 16.0 ) * st;\n    st += 0.5;\n    st = fract(sign(st - .5) * st * fr);\n    return max(st.x,st.y);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfloat m = 1.;\n    for (float i = 2.;i < 11.; i++) {\n        m = min(m, motif (uv,i));\n    }\n\tfragColor = vec4(m,.5,.5,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlXXRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 114], [116, 116, 148, 148, 304], [305, 305, 362, 362, 530]], "test": "valid"}
{"id": "XlXXW8", "name": "Night road v1", "author": "Maurogik", "description": "A simple raymarched scene complete with lighting, shadowing and light emission from light bulbs.", "tags": ["raymarching", "light", "stars", "night"], "likes": 10, "viewed": 353, "published": "Public", "date": "1436857973", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//90ÃÂ° FOV\n#define FOCAL_LENGTH 1.0 \n#define MOVE_CAMERA 0.75\n#define MOVE_SPEED 5.0\n#define FX_SPEED 1000.0\n#define MAX_STEPS 512\n#define MIN_DIST 0.01\n#define MAX_DIST 110.0\n#define FOG_STR 1.0\n#define GRADIENT_OFFSET 0.1\n#define AMBIANT_LIGHT 0.05\n#define Z_REPEAT 10.0\n\n//scene data\nvec3 projectionUp;\nvec3 projectionRight;\nvec3 projectionForward;\nvec3 projectionCenter;\nvec3 cameraOffset;\nvec3 lightPos;\nvec3 skyColor;\nvec2 fragUV;\n\nfloat sqrLen(vec3 vec)\n{\n \treturn vec.x * vec.x + vec.y * vec.y + vec.z * vec.z;\n}\n\nvec3 lerp(vec3 from, vec3 to, float progress)\n{\n    return from * (1.0 - progress) + to * progress;\n}\n\nvec2 pixelToNormalizedspace(vec2 pixel)\n{\n    vec2 res;\n    res.x = pixel.x * 2.0 / iResolution.x - 1.0;\n    res.y = pixel.y * 2.0 / iResolution.y - 1.0;\n    res.y *= iResolution.y / iResolution.x;//correct aspect ratio\n    return res;\n}\n\nvec3 fragCoordToProjectionPlane(vec2 fragUv)\n{\n\tvec2 uv = pixelToNormalizedspace(fragUv);\n    return projectionCenter + projectionRight * uv.x + projectionUp * uv.y;\n}\n\n//project a direction onto the original (without rotation) projection plane\n//to get world space uv\nvec2 dirToWorldSpacedUV(vec3 dir)\n{\n    dir= normalize(dir);\n    vec3 projRight \t= vec3(1.0, 0.0, 0.0);\n    vec3 projUp \t= vec3(0.0, 1.0, 0.0);\n    vec3 projForw\t= vec3(0.0, 0.0, 1.0);\n\n    float u = dot(dir, projRight) / dot(projRight, projRight);\n    float v = dot(dir, projUp) / dot(projUp, projUp);\n    return vec2(u, v);\n}\n\nvec2 worldToProjectionPlane(vec3 point)\n{\n    vec4 camStart = vec4(projectionCenter + cameraOffset, 1.0);\n    vec4 camToPoint = vec4(normalize(point - camStart.xyz), 0.0);\n    vec4 projectionPlane = vec4(projectionForward, -FOCAL_LENGTH);\n    float intersectDist = dot(projectionPlane, camStart) / dot(projectionPlane, camToPoint);\n    vec3 pointOnPlane = camStart.xyz + camToPoint.xyz * intersectDist;\n    float u = dot(pointOnPlane, projectionRight) / dot(projectionRight, projectionRight);\n    float v = dot(pointOnPlane, projectionUp) / dot(projectionUp, projectionUp);\n    return vec2(u, v);\n}\n\n//Create a shape by removing shape2 from shape1\nfloat subtractField(float df1, float df2)\n{\n    return max(df1, -df2);\n}\n\n//get distance to a cylinder\nfloat cylinderDist(vec3 center, vec2 dimension, vec3 point)\n{\n  \tvec3 p = point - center;   \n  \tvec2 d = abs(vec2(length(p.xz), p.y)) - dimension;\n  \treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n//get distance to an AA box\nfloat AABox(vec3 pmin, vec3 pmax, vec3 point)\n{\n\tfloat dx = max(0.0, max(pmin.x - point.x, point.x - pmax.x));\n    float dy = max(0.0, max(pmin.y - point.y, point.y - pmax.y));\n    float dz = max(0.0, max(pmin.z - point.z, point.z - pmax.z));\n    return sqrt(dx*dx + dy*dy + dz*dz);    \n}\n\n//get distance to surface of a sphere\nfloat sphereDist(vec4 sphere, vec3 point)\n{\n    return length(point - sphere.xyz) - sphere.w;\n}\n\n//get distance to surface of a plane\nfloat planeDist(vec4 plane, vec3 point)\n{\n    \n\treturn abs(dot(plane, vec4(point, 1.0)));\n}\n\n\n//Pack a plane as a [normal, distToOrigin] vector\nvec4 createPlane(vec3 normal, float dist)\n{\n\treturn vec4(normalize(normal), dist);\n}\n\n//Pack a sphere as a [center, radius] vector\nvec4 createSphere(vec3 pos, float radius)\n{\n \treturn vec4(pos, radius);   \n}\n\nvec3 cylinderPos\t= vec3(3.0, 1.0, 3.0);\nvec2 cylinderSize\t= vec2(0.1, 2.0);\nvec4 plane;\nvec4 sphere;\nvec3 roadPt1  \t\t= vec3(1.25, -0.95, 0.0) - vec3(2.5, 0.05, 20.0) * 0.5;\nvec3 roadPt2\t\t= vec3(1.25, -0.95, 0.0) + vec3(2.5, 0.05, 20.0) * 0.5;\nvec3 groundColor \t= vec3(0.3);\nvec3 poleColor\t\t= vec3(0.25);\nvec3 lampColor \t\t= vec3(5.0, 5.0, 5.0);\nvec3 roadColor\t\t= vec3(0.1);\n\nfloat calcColorWeight(float dist, float minDist)\n{\n    return clamp(1.0 - (dist / minDist - 1.0), 0.0, 1.0);\n}\n\nvec3 domainMod(vec3 point){\n    vec3 moddedPoint\t= point;\n    moddedPoint.x \t\t= abs(point.x); //symmetry\n    moddedPoint.z \t\t= mod(point.z, Z_REPEAT);\n    return moddedPoint;\n}\n\n//get distance and color to nearest surface\nvec4 colorDistanceField(vec3 point)\n{   \n    vec3 moddedPoint\t= domainMod(point);\n    \n    float roadDist\t\t= AABox(roadPt1, roadPt2, moddedPoint);\n    float distSphere \t= sphereDist(sphere, moddedPoint);\n    float distCylinder \t= cylinderDist(cylinderPos, cylinderSize, moddedPoint);\n    float distPlane\t\t= planeDist(plane, point);\n    float minDist\t\t= MAX_DIST;\n    minDist \t\t\t= min(distSphere, distCylinder);    \n    minDist \t\t\t= min(minDist, distPlane);\n    minDist \t\t\t= min(minDist, roadDist);\n        \n    //blend colors\n    vec3 color = vec3(0.0);\n    color += calcColorWeight(roadDist, minDist) \t* roadColor;\n    color += calcColorWeight(distSphere, minDist) \t* lampColor;\n    color += calcColorWeight(distCylinder, minDist) * poleColor;\n    color += calcColorWeight(distPlane, minDist) \t* groundColor;\n    \n\treturn vec4(color, minDist);\n}\n\n//get distance to nearest surface\nfloat distanceField(vec3 point)\n{   \n    vec3 moddedPoint = domainMod(point);\n    \n    float roadDist\t\t= AABox(roadPt1, roadPt2, moddedPoint);\n    float distSphere \t= sphereDist(sphere, moddedPoint);\n    float distCylinder \t= cylinderDist(cylinderPos, cylinderSize, moddedPoint);\n    float distPlane\t\t= planeDist(plane, point);\n    float minDist\t\t= MAX_DIST;\n    minDist \t\t\t= min(distSphere, distCylinder);    \n    minDist \t\t\t= min(minDist, distPlane);\n    minDist \t\t\t= min(minDist, roadDist);\n   \treturn minDist;\n}\n\n//get uv for road teture from a world point on a road tile\nvec2 pointToRoadUV(vec3 point){ \n    float y =  mod(point.z * 2.0, Z_REPEAT) / Z_REPEAT;\n    float x = (point.x - roadPt1.x) / (roadPt2.x - roadPt1.x);\n    return vec2(x, y);\n}\n\n//raymarch with atmospheric accumulation of color at sampling points\nvec4 rmAtmosphere(vec3 rayStart, vec3 rayDir, float minDist)\n{\n    float totalDist = minDist;\n    float dist;\n    vec3 color = vec3(0.0);\n    float stepBias;\n    vec3 atmColor;\n    vec4 dfRes;\n    \n    for(int i = 0; i < MAX_STEPS; ++i)\n    {   \n        stepBias = max(0.5, float(i) / float(MAX_STEPS));//to avoid artefacts\n        dfRes = colorDistanceField(rayStart + rayDir * totalDist);\n        dist = dfRes.w;        \n        totalDist += dist * stepBias;\n        \n        if(dist <= MIN_DIST * stepBias)\n        {\n            atmColor = dfRes.xyz;\n            color = lerp(color, skyColor, pow(totalDist / MAX_DIST, 1.0 / FOG_STR));            \n        \treturn vec4((color + atmColor), totalDist);   \n        }\n        \n        if(totalDist >= MAX_DIST)\n        {\n            return vec4(color + skyColor, MAX_DIST);  \n        }                       \n        //color accumulation while raymarching to add emission FX\n        atmColor = dfRes.xyz;\n        color += (clamp(atmColor - vec3(1.0), vec3(0.0), vec3(3.0)) * max(1.5 - dist, 0.0)) / (totalDist * totalDist);    \n    }      \n        \n    return vec4(color + skyColor, totalDist);    \n}\n\n//simple distance raymarching\nfloat rmDist(vec3 rayStart, vec3 rayDir, float minDist)\n{\n    float totalDist = minDist;\n    float dist;\n    float stepBias;\n    \n    for(int i = 0; i < MAX_STEPS; ++i)\n    {   \n        stepBias = 1.0;\n        dist = distanceField(rayStart + rayDir * totalDist);\n        totalDist += dist * stepBias;\n        if(dist <= MIN_DIST)\n        {\n            return totalDist;\n        }\n        \n        if(totalDist >= MAX_DIST)\n        {\n            return MAX_DIST;  \n        }        \n    }      \n        \n    return totalDist;    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    plane\t \t\t= createPlane(vec3(0.0, 1.0, 0.0), 1.0);\n\tsphere \t\t= createSphere(vec3(3.0, 3.0, 3.0), 0.3);\n    \n    fragUV = fragCoord;      \n\n    //Do camera setup from mouse coord\n    projectionCenter \t= vec3(0.0, 0.2, mod(MOVE_SPEED * iTime, 10.0));\n    projectionForward \t= vec3(0.0, 0.0, 1.0);\n    projectionUp \t\t= vec3(0.0, 1.0, 0.0);\n    projectionRight \t= vec3(1.0, 0.0, 0.0);        \n    vec3 mouseProj\t\t= (fragCoordToProjectionPlane(iMouse.xy));\n    cameraOffset\t\t= normalize(vec3(-mouseProj.x * MOVE_CAMERA, -mouseProj.y * MOVE_CAMERA, -1.0)) * FOCAL_LENGTH;\n    \n    //reproject the camera plane\n    projectionForward \t= normalize(-cameraOffset);\n    projectionUp \t\t= vec3(0.0, 1.0, 0.0);\n    projectionRight \t= cross(projectionUp, projectionForward);\n    projectionUp \t\t= cross(projectionForward, projectionRight);  \n    \n    lightPos\t\t\t= projectionCenter + cameraOffset + vec3(0.0, 3.0, 1.5);  \n            \n    //setup ray\n    vec3 rayPos \t\t\t\t= projectionCenter + cameraOffset;\n    vec3 pointOnProjectionPlane = fragCoordToProjectionPlane(fragCoord);\n    vec3 rayDirection \t\t\t= normalize(pointOnProjectionPlane - rayPos);\n    \n    //sky and stars\n    vec2 skyUV \t= dirToWorldSpacedUV(rayDirection) * 1.5;\n    vec3 stars \t= texture(iChannel0, skyUV).xyz;\n    stars      \t*= pow(sqrLen(stars) * 0.45, 10.0) * 0.5;\n    float skyDarkness\t= pow(abs(rayDirection.y) * 1.5, 0.5);\n    skyColor \t= lerp(\n          vec3(0.1, 0.1, 0.3)\n        , vec3(0.005, 0.005, 0.01) + stars * skyDarkness\n        , skyDarkness);    \n    \n    //march ray\n    vec4 rayMarchResult \t= rmAtmosphere(rayPos, rayDirection, 0.0);    \n    float dist \t\t\t\t= rayMarchResult.w;\n    float distAttenuation \t= pow(1.0 - dist/MAX_DIST * 0.8, 1.0);   \n    vec4 surfaceColor \t\t= vec4(rayMarchResult.xyz, 1.0);\n\n    if(dist < MAX_DIST && sqrLen(rayMarchResult.xyz) < 2.0)//to avoid shadowing the sky\n    {\n        vec3 endPoint \t\t= rayPos + rayDirection * (dist);\n        vec3 pointToLight \t= normalize(lightPos - endPoint);\n        \n        //add headlights\n        vec3 headlightPoint = endPoint;\n        headlightPoint.x \t= abs(headlightPoint.x * 3.5);\n        vec3 headlightDiff \t= projectionCenter + vec3(4.0, -0.5, -1.5) - headlightPoint; \n        headlightDiff.z \t*= 0.75;\n        float headlight \t= clamp(40.0 / sqrLen(headlightDiff), 0.0, 100.0);        \n        \n        //normal computation\n        float g1 = distanceField(endPoint + vec3(GRADIENT_OFFSET, 0.0, 0.0))\n            - distanceField(endPoint + vec3(-GRADIENT_OFFSET, 0.0, 0.0));\n        float g2 = distanceField(endPoint + vec3(0.0, GRADIENT_OFFSET, 0.0))\n            - distanceField(endPoint + vec3(0.0, -GRADIENT_OFFSET, 0.0));\n        float g3 = distanceField(endPoint + vec3(0.0, 0.0, GRADIENT_OFFSET))\n            - distanceField(endPoint + vec3(0.0, 0.0, -GRADIENT_OFFSET));\n        vec3 normal = normalize(vec3(g1, g2, g3));\n        \n        //road normal from texture\n        vec2 normalUV = pointToRoadUV(endPoint);\n        normal += texture(iChannel0, normalUV).xyz \n            * (1.0 - clamp(AABox(roadPt1, roadPt2, domainMod(endPoint)) * 5.0, 0.0, 1.0)) * 0.5;\n        normal = normalize(normal);\n        \n        //dist to lamps\n        float lampLight = min(pow(22.0 / sqrLen(domainMod(endPoint + normal * 0.1) - sphere.xyz), 20.0), 3.0);\n        lampLight /= 3.0;\n        \n        //lighting    \n        float spec = pow(clamp(dot(normalize(-rayDirection + pointToLight), normal), 0.0, 1.0), 16.0);\n        float ambiant = (AMBIANT_LIGHT * distAttenuation + lampLight) * pow(distAttenuation, 2.0);\n        surfaceColor = surfaceColor * ambiant \n            + surfaceColor * max(0.0, dot(normal, pointToLight) * headlight)\n            + vec4(0.8) * spec * headlight;\n        \n\t    //check for shadow casting        \n        float shadowDist \t= rmDist(endPoint + normal * 0.01, pointToLight, 0.0);    \n    \tfloat shadow\t\t\t= 1.0 - (shadowDist / MAX_DIST);\n        shadow\t\t\t\t\t= clamp(shadow - lampLight * 0.3, 0.0, 1.0);\n    \tfloat lightIntensity \t= 1.0 - pow(shadow, 4.0);\n \t   \tsurfaceColor \t\t\t*= lightIntensity;     \n    }\n    \n    fragColor = surfaceColor;\n}\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlXXW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[441, 441, 465, 465, 523], [525, 525, 572, 572, 626], [628, 628, 669, 669, 865], [867, 867, 913, 913, 1034], [1036, 1136, 1171, 1171, 1463], [1465, 1465, 1506, 1506, 2063], [2065, 2113, 2156, 2156, 2185], [2187, 2216, 2277, 2277, 2421], [2423, 2451, 2498, 2498, 2739], [2741, 2779, 2822, 2822, 2874], [2876, 2913, 2954, 2954, 3004], [3007, 3057, 3100, 3100, 3141], [3143, 3188, 3231, 3231, 3264], [3640, 3640, 3690, 3690, 3750], [3752, 3752, 3779, 3779, 3928], [3930, 3974, 4011, 4011, 4820], [4822, 4856, 4889, 4889, 5371], [5373, 5432, 5463, 5463, 5608], [5610, 5679, 5741, 5741, 6828], [6830, 6860, 6917, 6917, 7390], [7392, 7392, 7449, 7449, 11573]], "test": "error"}
{"id": "XlXXzX", "name": "Revisited Main Sequence Star", "author": "Continous", "description": "A revisit of the loved main sequence star by flight404 with very slight tweaks, and some comments.", "tags": ["noise", "sun", "reactive", "music", "perlin"], "likes": 25, "viewed": 898, "published": "Public", "date": "1438320124", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// based on https://www.shadertoy.com/view/lsf3RH by\n// trisomie21 (THANKS!)\n// My apologies for the ugly code.\n\n\nfloat snoise(vec3 uv, float res)\t// by trisomie21\n{\n\tconst vec3 s = vec3(1e0, 1e2, 1e4);\n\t\n\tuv *= res;\n\t\n\tvec3 uv0 = floor(mod(uv, res))*s;\n\tvec3 uv1 = floor(mod(uv+vec3(1.), res))*s;\n\t\n\tvec3 f = fract(uv); f = f*f*(3.0-2.0*f);\n\t\n\tvec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,\n\t\t      \t  uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);\n\t\n\tvec4 r = fract(sin(v*1e-3)*1e5);\n\tfloat r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\tr = fract(sin((v + uv1.z - uv0.z)*1e-3)*1e5);\n\tfloat r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\treturn mix(r0, r1, f.z)*2.-1.;\n}\n\nfloat freqs[4];\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfreqs[0] = texture( iChannel1, vec2( 0.02, 0.25 ) ).x;\n\tfreqs[1] = texture( iChannel1, vec2( 0.07, 0.25 ) ).x;\n\tfreqs[2] = texture( iChannel1, vec2( 0.15, 0.25 ) ).x;\n\tfreqs[3] = texture( iChannel1, vec2( 0.30, 0.25 ) ).x;\n\n\tfloat brightness\t= freqs[1] * 0.35 + freqs[2] * 0.25; //Effects overall size of the star. This also increases brightness.\n\tfloat radius\t\t= 0.24 + brightness * 0.25; //Radius of star, where brightness gets tied to star size. should not be changed in respect of corona.\n\tfloat invRadius \t= 1.0/radius;\n\t\n\tvec3 orange\t\t\t= vec3( ((freqs[1]) * 0.9), 0.6, ((freqs[0]) * 0.9) ) * (1.0); //Corona color.\n\tvec3 orangeRed\t\t= vec3( ((freqs[2]) * 0.9), 0.2, ((freqs[3]) * 0.9) ) * (1.0); //Star color.\n    //The following provided for use with quieter sources providing a much higher contrast. Suggested use with microphones or stereo mix.\n    \t//vec3 orange\t\t\t= vec3( freqs[1], 0.3, freqs[0] ) * (1.5) + (0.2, 0.1, 0.1); //Corona color.\n\t\t//vec3 orangeRed\t\t= vec3( freqs[2], 0.1, freqs[3] ) * (1.25) + (0.2, 0.1, 0.1); //Star color.\n    \n\tfloat time\t\t= iTime * 0.1;\n\tfloat aspect\t= iResolution.x/iResolution.y;\n\tvec2 uv\t\t\t= fragCoord.xy / iResolution.xy;\n\tvec2 p \t\t\t= -0.5 + uv;\n\tp.x *= aspect;\n\n\tfloat fade\t\t= pow( length( 2.0 * p ), 0.5 );\n\tfloat fVal1\t\t= 1.0 - fade;\n\tfloat fVal2\t\t= 1.0 - fade;\n\t\n\tfloat angle\t\t= atan( p.x, p.y )/6.2832;\n\tfloat dist\t\t= length(p);\n\tvec3 coord\t\t= vec3( angle, dist, time * 0.1 );\n\t\n\tfloat newTime1\t= abs( snoise( coord + vec3( 0.0, -time * ( 0.35 + brightness * 0.001 ), time * 0.015 ), 15.0 ) );\n\tfloat newTime2\t= abs( snoise( coord + vec3( 0.0, -time * ( 0.15 + brightness * 0.001 ), time * 0.015 ), 45.0 ) );\t\n\tfor( int i=1; i<=7; i++ ){\n\t\tfloat power = pow( 2.0, float(i + 1) );\n\t\tfVal1 += ( 0.5 / power ) * snoise( coord + vec3( 0.0, -time, time * 0.2 ), ( power * ( 10.0 ) * ( newTime1 + 1.0 ) ) );\n\t\tfVal2 += ( 0.5 / power ) * snoise( coord + vec3( 0.0, -time, time * 0.2 ), ( power * ( 25.0 ) * ( newTime2 + 1.0 ) ) );\n\t}\n\t\n\tfloat corona\t\t= pow( fVal1 * max( 1.1 - fade, 0.0 ), 2.0 ) * 25.0;  //Effects 'bleed' of corona, or distance it travels outwards.\n\tcorona\t\t\t\t+= pow( fVal2 * max( 1.1 - fade, 0.0 ), 2.0 ) * 25.0;  //Effects intensity of corona.\n\tcorona\t\t\t\t*= 1.2 - newTime1; //Should be left alone, does the same as above two, but with less granularity.\n\tvec3 sphereNormal \t= vec3( 0.0, 0.0, 1.0 );\n\tvec3 dir \t\t\t= vec3( 0.0 );\n\tvec3 center\t\t\t= vec3( 0.5, 0.5, 1.0 );\n\tvec3 starSphere\t\t= vec3( 0.05 ); //Light bleed from star, should remain near 0\n\t\n\tvec2 sp = -1.0 + 2.0 * uv;\n\tsp.x *= aspect;\n\tsp *= ( 1.95 - brightness ); //Do not change, should remain extremely close to 2.0 - brightness. Extremely close.\n  \tfloat r = dot(sp,sp);\n\tfloat f = (1.0-sqrt(abs(1.0-r)))/(r) + brightness * 0.5; //Effects overall brightness of the sun.\n\tif( dist < radius ){  //Manages the surface animation.\n\t\tcorona\t\t\t*= pow( dist * invRadius, 24.0 );\n  \t\tvec2 newUv;\n \t\tnewUv.x = sp.x*f;\n  \t\tnewUv.y = sp.y*f;\n\t\tnewUv += vec2( time, 0.0 );\n\t\t\n\t\tvec3 texSample \t= texture( iChannel0, newUv ).rgb;\n\t\tfloat uOff\t\t= ( texSample.g * brightness * 4.5 + time );\n\t\tvec2 starUV\t\t= newUv + vec2( uOff, 0.0 );\n\t\tstarSphere\t\t= texture( iChannel0, starUV ).rgb;\n\t}\n\t\n\tfloat starGlow\t= min( max( 1.0 - dist * ( 1.0 - brightness ), 0.0 ), 1.0 );\n\t//fragColor.rgb\t= vec3( r );\n\tfragColor.rgb\t= vec3( f * ( 0.75 + brightness * 0.3 ) * orange ) + starSphere + corona * orange + starGlow * orangeRed;\n\tfragColor.a\t\t= 1.0;\n}\n\n", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "4df3Rn", "previewfilepath": "/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlXXzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[114, 114, 165, 165, 691], [710, 710, 767, 767, 4220]], "test": "error"}
{"id": "XtfSW4", "name": "2D Simplex Clouds", "author": "voax", "description": "Not exactly innovative but still a useful texturing primitive. This simple implementation can no doubt be improved upon in many ways. The cloud effect is created by sampling a gradient (procedural here but could just as easily be a texture) with noisy uv.", "tags": ["2d", "noise", "clouds", "fbm", "cloud", "fog", "simplex"], "likes": 29, "viewed": 3027, "published": "Public", "date": "1436597360", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float cloudDensity = 1.0; \t// overall density [0,1]\nfloat noisiness = 0.35; \t// overall strength of the noise effect [0,1]\nfloat speed = 0.1;\t\t\t// controls the animation speed [0, 0.1 ish)\nfloat cloudHeight = 2.5; \t// (inverse) height of the input gradient [0,...)\n\n\n// Simplex noise below = ctrl+c, ctrl+v:\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  { \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\n/// Cloud stuff:\nconst float maximum = 1.0/1.0 + 1.0/2.0 + 1.0/3.0 + 1.0/4.0 + 1.0/5.0 + 1.0/6.0 + 1.0/7.0 + 1.0/8.0;\n// Fractal Brownian motion, or something that passes for it anyway: range [-1, 1]\nfloat fBm(vec3 uv)\n{\n    float sum = 0.0;\n    for (int i = 0; i < 8; ++i) {\n        float f = float(i+1);\n        sum += snoise(uv*f) / f;\n    }\n    return sum / maximum;\n}\n\n// Simple vertical gradient:\nfloat gradient(vec2 uv) {\n \treturn (1.0 - uv.y * uv.y * cloudHeight);   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 p = vec3(uv, iTime*speed);\n    vec3 someRandomOffset = vec3(0.1, 0.3, 0.2);\n    vec2 duv = vec2(fBm(p), fBm(p + someRandomOffset)) * noisiness;\n    float q = gradient(uv + duv) * cloudDensity;\n\tfragColor = vec4(q,q,q, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtfSW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[699, 699, 720, 720, 769], [771, 771, 792, 792, 841], [843, 843, 865, 865, 905], [907, 907, 935, 935, 987], [989, 989, 1013, 1013, 3157], [3277, 3359, 3379, 3379, 3531], [3533, 3562, 3587, 3587, 3636], [3638, 3638, 3695, 3695, 3972]], "test": "valid"}
{"id": "XtfXD4", "name": "blwnOutScan", "author": "cmpst", "description": "yup", "tags": ["scan"], "likes": 3, "viewed": 104, "published": "Public", "date": "1436662793", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 tex0 = texture(iChannel0,uv);\n    \n    float sY = sin(fragCoord.y + t * 2.0);\n    float sX = sin(fragCoord.x + t * 60.0);\n                  \n    float c = uv.y;\n  \tc += sY - 0.4;\n   \n    float a = sX;\n    \n    c -= 4. * sin(t * 4.0 + uv.y * 20.0);\n   \tc += 1. * sin(t * 1.0 + uv.y * 40.0);\n    c += 1. * sin(t * 4.0 + uv.x * 4.0);\n  \n    c += fract(sin(dot(uv.xy ,vec2(13.18,78.233))) * 338.5453);\n    \n    float r = c - 0.13;\n    float g = c - 0.1;\n    float b = c ;\n    \n    vec4 final = vec4(r,g,b,1.0);\n    final.rgb += vec3(0.4,0.4,0.4);\n    \n    fragColor = (tex0*5.0) + final;\n}", "image_inputs": [{"id": "4df3zn", "previewfilepath": "/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtfXD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 723]], "test": "error"}
{"id": "XtfXzj", "name": "Energy", "author": "Makio64", "description": "tweak value of my red smoke to get this \"sf effect\"", "tags": ["fbm", "perlin", "sf", "electricity"], "likes": 7, "viewed": 280, "published": "Public", "date": "1437813716", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Simple for of my previous one :\n//https://www.shadertoy.com/view/llsSzB\n\nfloat hash(float x)\n{\n\treturn fract(21654.6512 * sin(385.51 * x));\n}\n\nfloat hash(vec2 p)\n{\n\treturn fract(21654.65155 * sin(35.51 * p.x + 45.51 * p.y));\n}\n\nfloat lhash(float x, float y)\n{\n\tfloat h = 0.0;\n\t\n\tfor(int i = 0;i < 5;i++)\n\t{\n\t\th += (fract(21654.65155 * float(i) * sin(35.51 * x + 45.51 * float(i) * y * (5.0 / float(i))))* 2.0 - 1.0) / 10.0;\n\t}\n\treturn h / 5.0 + 0.02;\n\treturn (fract(21654.65155 * sin(35.51 * x + 45.51 * y))* 2.0 - 1.0) / 20.0;\n}\n\nfloat noise(vec2 p)\n{\n\tvec2 fl = floor(p);\n\tvec2 fr = fract(p);\n\t\n\tfr.x = smoothstep(0.0,1.0,fr.x);\n\tfr.y = smoothstep(0.0,1.0,fr.y);\n\t\n\tfloat a = mix(hash(fl + vec2(0.0,0.0)), hash(fl + vec2(1.0,0.0)),fr.x);\n\tfloat b = mix(hash(fl + vec2(0.0,1.0)), hash(fl + vec2(1.0,1.0)),fr.x);\n\t\n\treturn mix(a,b,fr.y);\n}\n\n\nfloat distanceToSegment( vec2 a, vec2 b, vec2 p )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\t\n\treturn length( pa - ba*h );\n}\n\n//Fractal Brownian Motion \nfloat fbm(vec2 p)\n{\n\tfloat v = 0.0, f = 1.0, a = 0.5;\n\t\n\tfor(int i = 0;i < 5; i++)\n\t{\n\t\tv += noise(p * f) * a;\n\t\t\n\t\tf *= 2.0;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n//Fun start here\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //change the animation speed\n    float time = iTime*5.;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = uv*2.0 -1.0;\n\tuv.x *= iResolution.x / iResolution.y;\t\n\tuv.y -= iTime;\n    float p = fbm(vec2(noise(uv+time/2.5)/3.,noise(uv*19.)));\n    p = (1. - abs(p * 2.0 - 1.0))*.8;\n\n\tvec3 col = pow(vec3(p),vec3(0.3))-0.4;\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.2,pow(1.0 / 2.0,0.5) - uv.y/40.0) );\n    float s = smoothstep(.3,.6,col.x);\n    float s2 = smoothstep(.48,.6,col.x);\n    float s3 = smoothstep(.51,.6,col.x);\n    //multiply by the inverse to get the \"smoky\" effect, first attempt\n    col*=vec3(0.1,.1,1.1)*s;\n    col+=vec3(0.3,0.4,.1)*s2; //add orange\n    col+=vec3(5.,5.,5.)*s3; //add yellow\n    //made it more bright\n    col*=1.6;\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtfXzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 75, 96, 96, 143], [145, 145, 165, 165, 228], [230, 230, 261, 261, 531], [533, 533, 554, 554, 841], [844, 844, 895, 895, 1017], [1019, 1046, 1065, 1065, 1199], [1201, 1218, 1275, 1308, 2057]], "test": "valid"}
{"id": "XtlSDn", "name": "Rolling Marbles (with shadows)", "author": "rubixcom", "description": "This version of the marbles has soft shadows but only one light source and is bit slower than my colourful version (https://www.shadertoy.com/view/ltXSWr)", "tags": ["raymarching", "reflection", "simple", "shadow"], "likes": 12, "viewed": 538, "published": "Public API", "date": "1435850165", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int maxSteps = 80;\nconst int shadowSteps = 30;\nconst int reflectionSteps = 5;\n\n#define LIGHTS 1\n#define SHADOWS \n#define REFLECTIONS\n\nconst vec4 lightColor = vec4(1.0,.75,0.6,0.0); \nconst vec4 lightColor2 = vec4(0.0,1.0,0.6,0.0);\nconst vec4 lightColor3 = vec4(0.75,0.0,1.0,0.0);\n\nvec3 rayVector(in vec3 position, in vec3 target, in vec2 fragCoord)\n{\n    vec3 eye = normalize(target - position);\n    vec3 up = vec3(0., 1., 0.);\n    vec3 right = cross(eye, up);\n    up = cross(eye,right);\n\n    mat3 cameraMatrix = mat3(right.x, up.x, eye.x,\n                \t\t\t right.y, up.y, eye.y,\n                \t\t\t right.z, up.z, eye.z);\n\n    vec2 uv = fragCoord.xy / iResolution.xy - vec2(.5);\n    uv.x = uv.x * iResolution.x/iResolution.y;\n    uv.y = -uv.y;\n    float focalDistance = 0.6 + .3 * sin(iTime* .25);\n    return (normalize(vec3(uv.x,uv.y,focalDistance)) * cameraMatrix) * .5;\n}\n\nvec4 textureBall (in vec2 pos)\n{\n\treturn vec4(step(.5,fract((pos.x+pos.y)*4.)));\n}\n\nvec4 texturePlane (in vec2 pos)\n{\n\treturn vec4(abs(step(0.5,fract(pos.x*3.)) - step(0.5,fract(pos.y*3.))));\n}\n\nvec4 shade(in vec3 pos, in vec3 normal, in vec3 cameraVector, in vec3 lightPos, in vec4 lightColor, in vec4 surface)\n{\n    vec3 light = normalize(lightPos - pos);\n    float dotlight = dot(normal,light);\n\n    vec3 cameraReflected = normalize(reflect(cameraVector,normal));\n    float spec = 0.0;\n    if (dot(cameraReflected,light) < 0.0)\n        spec = min(1.0,pow(dot(cameraReflected,light),2.0));\n    return (surface\n        * vec4(0.2+dotlight) * lightColor\n        + vec4(0.5*spec)) * 10.0/length(lightPos - pos); // Sphere color\n}\n\nfloat map(in vec3 p, in vec3 shapeLoc, out vec3 pm)\t\n{\n\tfloat bounce = 1.6*abs(sin(iTime + float(int(p.y/6.0) + int(p.x/6.0))));\n\tpm = vec3(mod(p.x,6.0),p.y-bounce,mod(p.z,6.0)) - shapeLoc;\n\t\n\treturn min(length(pm) - 1.8, p.y); \n}\n\t\nvec3 normal(in vec3 p, in vec3 pm)\n{\n\tif (p.y < 0.1)\n\t{\n\t\treturn vec3(0.,1.,0.);\n\t}\n\telse\n\t{\n\t\treturn normalize(pm);\n\t}\n}\n\nvec4 textured(in vec3 p, in vec3 pm, in mat3 rotation)\n{\n\tif (p.y < 0.1)\n\t{\n\t\treturn texturePlane( vec2(p.x *.1 - 3.1415 * .5 * iTime,p.z *.1));\n\t}\n\telse\n\t{\n\t\tvec3 pmr = rotation * pm; \n\t\treturn textureBall( vec2(atan(pmr.x,pmr.z)*.20,pmr.y*.25));\n\t}\n}\n\nfloat shadow(in vec3 ro, in vec3 rd, in vec3 shapeLoc, in vec3 lightPos)\n{\n\tfloat res = 1.0;\n\tfloat t = 1.0;\n    for(int i = 1; i < shadowSteps; ++i)\n    {\n        vec3 pm = vec3(0.,0.,0.);\n\t\tvec3 p = ro + rd * t;\n\t\tfloat h = map(p, shapeLoc, pm);\n\t\tif ( h < 0.01 )\n\t\t\treturn 0.01;\n\t\t\n\t\tres = min( res, 4. * h / t);\n\t\tt += h;\n\t}\n\t\n\treturn res;\n}\n\nvec4 reflection(in vec3 ro, in vec3 rd, in vec3 shapeLoc, in mat3 rotation, in vec3 lights[3])\n{\n    vec4 color = vec4(0.0);\n\n    float t = 1.6;\n    for(int i = 0; i < reflectionSteps; ++i)\n    {\n        vec3 p = ro + rd * t;\n        \n        vec3 pm = vec3(0.,0.,0.);\n\t\tfloat d = map(p, shapeLoc, pm);\n        if(d < 0.1)\n        {\n\t\t\tvec3 normal = normal(p, pm); vec4 texc = textured(p, pm, rotation);\n\n\t\t\tcolor = (0.0\n#if (LIGHTS >= 1)\n\t\t\t\t+ shade(p, normal, -rd, lights[0], lightColor, texc)\n#endif\n#if (LIGHTS >= 2)\n\t\t\t    + shade(p, normal, -rd, lights[1], lightColor2, texc)\n#endif\n#if (LIGHTS >= 3)\n                + shade(p, normal, -rd, lights[2], lightColor3, texc)\n#endif\n\t\t\t) / float(LIGHTS);\n            break;\n        }\n\n        t += d;\n    }\n\n    return color;\n}\n\nvec4 march(in vec3 ro, in vec3 rd, in vec3 shapeLoc, in mat3 rotation, in vec3 lights[3])\n{\n    vec4 color = vec4(0.0);\n\n    float t = 0.0;\n    for(int i = 0; i < maxSteps; ++i)\n    {\n        vec3 p = ro + rd * t;\n\n        vec3 pm = vec3(0.,0.,0.);\n\t\tfloat d = map(p, shapeLoc, pm);\n        if (d <= 0.01)\n        {\n\t\t\tvec3 normal = normal(p, pm); vec4 texc = textured(p, pm, rotation);\n\n            vec3 cameraReflected = normalize(reflect(rd, -normal));\n\n\t\t\tcolor = (0.0\n#if (LIGHTS >= 1)\n\t\t\t\t+ shade(p, normal, -rd, lights[0], lightColor, texc)\n\t#ifdef SHADOWS\n\t\t\t\t* shadow(p, normalize(lights[0]-p), shapeLoc, lights[0])\n\t#endif\n#endif\n#if  (LIGHTS >= 2)\n\t\t\t\t+ shade(p, normal, -rd, lights[1], lightColor2, texc)\n\t#ifdef SHADOWS\n\t\t\t\t* shadow(p, normalize(lights[1]-p), shapeLoc, lights[1])\n\t#endif\n#endif\n#if  (LIGHTS >= 3)\n\t\t\t\t+ shade(p, normal, -rd, lights[2], lightColor3, texc)\n\t#ifdef SHADOWS\n\t\t\t\t* shadow(p, normalize(lights[2]-p), shapeLoc, lights[2])\n\t#endif\n#endif\n\t\t\t) / float(LIGHTS)\n#ifdef REFLECTIONS\n\t\t\t+ .5*reflection(p, cameraReflected, shapeLoc, rotation, lights)\n#endif\n\t\t\t;\n\t\t\tbreak;\n        }\n\n        t += d;\n    }\n    return color;\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n    vec3 shapeLoc = vec3(3.0,1.8,3.0);\n    vec3 lights[3];\n#if (LIGHTS >= 1)\n\tlights[0] = //vec3(-cameraLoc.x, 3.*cameraLoc.y, -cameraLoc.z);\n\t\tvec3(3. + 4.0 * sin(iTime*2.), 16.0 + 8.0 * sin(0.4*iTime) , 3.+4.0 * cos(2.*iTime));\n#endif\n#if (LIGHTS >= 2)\n\tlights[1] = vec3(3. + 4.0 * sin(iTime*3.), 4.0 + 4.0 * sin(0.2*iTime) , 3.+8.0 * cos(3.*iTime));\n#endif\n#if (LIGHTS >= 3)\n\tlights[2] = vec3(3. + 8.0 * sin(iTime*4.), 4.0 + 4.0 * sin(0.1*iTime) , 3.+4.0 * cos(4.*iTime));\n#endif\n    \n    mat3 rotation = mat3(cos(iTime*5.),-sin(iTime*5.), 0.,\n                  sin(iTime*5.),cos(iTime*5.), 0.,\n                   0.,0.,1.);\n    \n    ro *= 3.;\n    ro.y += 6.;\n    \n    fragColor = march(ro, rd, shapeLoc, rotation, lights);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 shapeLoc = vec3(3.0,1.8,3.0);\n    vec3 cameraLoc = vec3(4.0 * sin(iTime), 6.0 + 4.0 * sin(0.4*iTime) , 4.0 * cos(iTime)) + shapeLoc;\n    vec3 cameraTarget = shapeLoc + vec3(0.0,1.+1.*sin(iTime*.01),0.0);\n    vec3 lights[3];\n#if (LIGHTS >= 1)\n\tlights[0] = //vec3(-cameraLoc.x, 3.*cameraLoc.y, -cameraLoc.z);\n\t\tvec3(3. + 4.0 * sin(iTime*2.), 16.0 + 8.0 * sin(0.4*iTime) , 3.+4.0 * cos(2.*iTime));\n#endif\n#if (LIGHTS >= 2)\n\tlights[1] = vec3(3. + 4.0 * sin(iTime*3.), 4.0 + 4.0 * sin(0.2*iTime) , 3.+8.0 * cos(3.*iTime));\n#endif\n#if (LIGHTS >= 3)\n\tlights[2] = vec3(3. + 8.0 * sin(iTime*4.), 4.0 + 4.0 * sin(0.1*iTime) , 3.+4.0 * cos(4.*iTime));\n#endif\n    \n    vec3 ro = cameraLoc;\n    vec3 rd = rayVector(cameraLoc, cameraTarget, fragCoord);\n\n    mat3 rotation = mat3(cos(iTime*5.),-sin(iTime*5.), 0.,\n                  sin(iTime*5.),cos(iTime*5.), 0.,\n                   0.,0.,1.);\n\n    \n    fragColor = march(ro, rd, shapeLoc, rotation, lights);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtlSDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[286, 286, 355, 355, 882], [884, 884, 916, 916, 966], [968, 968, 1001, 1001, 1077], [1079, 1079, 1197, 1197, 1612], [1614, 1614, 1668, 1668, 1844], [1847, 1847, 1883, 1883, 1968], [1970, 1970, 2026, 2026, 2222], [2224, 2224, 2298, 2298, 2569], [4512, 4512, 4590, 4590, 5319], [5321, 5321, 5378, 5378, 6334]], "test": "valid"}
{"id": "XtlSR2", "name": "ShaderPus", "author": "chronokun", "description": "2d octopus created with signed distance function bezier tentacles", "tags": ["2d", "sdf", "beziers", "badfps"], "likes": 3, "viewed": 246, "published": "Public", "date": "1438071971", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sBezier(vec2 p, vec2 cp0, vec2 cp1, vec2 cp2, vec2 cp3, float u, float r)\n{\n\tvec4 a;\n\tvec4 b;\n\n\ta[3] = (cp3.x + (3.0 * (cp1.x - cp2.x)) - cp0.x) / 8.0;\n\ta[2] = (3.0 * (cp3.x - cp2.x - cp1.x + cp0.x)) / 8.0;\n\ta[1] = ((cp3.x - cp0.x) / 2.0) - a[3];\n\ta[0] = ((cp3.x + cp0.x) / 2.0) - a[2];\n\n\tb[3] = (cp3.y + (3.0 * (cp1.y - cp2.y)) - cp0.y) / 8.0;\n\tb[2] = (3.0 * (cp3.y - cp2.y - cp1.y + cp0.y)) / 8.0;\n\tb[1] = ((cp3.y - cp0.y) / 2.0) - b[3];\n\tb[0] = ((cp3.y + cp0.y) / 2.0) - b[2];\n\n\tfloat x = a[3]*(u*u*u) + a[2]*(u*u) + a[1]*u + a[0];\n\tfloat y = b[3]*(u*u*u) + b[2]*(u*u) + b[1]*u + b[0];\n\n\tfloat s = sqrt(pow((x - p.x), 2.0) + pow((y - p.y), 2.0)) - (r*(1.0-u));\n\n\treturn(s);\n}\n\nfloat opS(float fD1, float fD2)\n{\n\treturn(max(-fD1, fD2));\n}\n\nfloat opI(float fD1, float fD2)\n{\n\treturn(max(fD1, fD2));\n}\n\nfloat opU(float fD1, float fD2)\n{\n\treturn(min(fD1, fD2));\n}\n\nfloat sTentacle(vec2 pc, vec2 cpts[4])\n{\n\tfloat fR = 0.02;\n\tfloat fD = 4.0;\n\tfloat fStep = 1.0;\n\tfloat fU = -1.0;\n\tfor(int i = 0; i < 16; ++i)\n\t{\n\t\tfloat fDTempA = sBezier(pc, cpts[0], cpts[1], cpts[2], cpts[3], fU+fStep, fR);\n\t\tfloat fDTempB = sBezier(pc, cpts[0], cpts[1], cpts[2], cpts[3], fU-fStep, fR);\n\t\tif(fDTempA < fD)\n\t\t{\n\t\t\tfU += fStep;\n\t\t}\n\t\telse if(fDTempB < fD)\n\t\t{\n\t\t\tfU -= fStep;\n\t\t}\n\n\n\t\tfD = sBezier(pc, cpts[0], cpts[1], cpts[2], cpts[3], fU, fR);\n\t\tfStep /= 2.0;\n\t}\n\n\treturn(fD);\n}\n\nvec3 shaderPus(vec2 pc)\n{\n\tvec3 color = vec3(0.0, 0.0, 0.0);\n\n\tfloat wiggle[7];\n\tfor(int i = 0; i < 7; ++i)\n\t{\n\t\twiggle[i] = sin((float(i+1)*iTime) / 4.0);\n\t}\n    \n    vec2 cpts0[4];\n    vec2 cpts1[4];\n    vec2 cpts2[4];\n    vec2 cpts3[4];\n    vec2 cpts4[4];\n    vec2 cpts5[4];\n\tvec2 cpts6[4];\n\tvec2 cpts7[4];\n\n\n\tcpts0[0] = vec2(-0.75, 0.72);\n\tcpts0[1] = vec2(0.0+(wiggle[2]*-0.25), 0.75+(wiggle[2]*-0.25));\n\tcpts0[2] = vec2(0.0+(wiggle[3]*-0.3), -0.75);\n\tcpts0[3] = vec2(0.75, -0.75+(wiggle[0]*0.25));\n\t//\n\tcpts1[0] = vec2(-0.75, 0.75);\n\tcpts1[1] = vec2(0.0+(wiggle[2]*-0.25), 0.85+(wiggle[2]*-0.25));\n\tcpts1[2] = vec2(0.0+wiggle[3], -0.45);\n\tcpts1[3] = vec2(0.75, -0.65+(wiggle[0]*-0.25));\n\t//\n\tcpts2[0] = vec2(-0.75, 0.75);\n\tcpts2[1] = vec2(-0.25+(wiggle[6]*-0.25), 0.55+(wiggle[5]*-0.125));\n\tcpts2[2] = vec2(0.0+(wiggle[4]*0.3), -0.95);\n\tcpts2[3] = vec2(0.65, -0.55+(wiggle[1]*0.25));\n\t//\n\tcpts3[0] = vec2(-0.75, 0.82);\n\tcpts3[1] = vec2(-0.15+(wiggle[1]*0.5), 0.65+(wiggle[3]*-0.125));\n\tcpts3[2] = vec2(0.4+(wiggle[3]*0.2), -0.25);\n\tcpts3[3] = vec2(0.95, -0.35+(wiggle[1]*-0.25));\n\t//\n\tcpts4[0] = vec2(-0.75, 0.52);\n\tcpts4[1] = vec2(0.35+(wiggle[1]*-0.65), 0.33+(wiggle[2]*-0.25));\n\tcpts4[2] = vec2(0.4+(wiggle[2]*0.2), -0.25+(wiggle[4]*-0.25));\n\tcpts4[3] = vec2(0.75, -0.85+(wiggle[2]*0.25));\n\t//\n\tcpts5[0] = vec2(-0.75, 0.62);\n\tcpts5[1] = vec2(0.35+(wiggle[6]*-0.25), 0.35+(wiggle[2]*-0.65));\n\tcpts5[2] = vec2(0.4, -0.25+(wiggle[3]*-0.25));\n\tcpts5[3] = vec2(0.75, 0.25+(wiggle[2]*-0.25));\n\t//\n\tcpts6[0] = vec2(-0.75, 0.54);\n\tcpts6[1] = vec2(-0.52+(wiggle[2]*-0.25), 0.2+(wiggle[2]*-0.25));\n\tcpts6[2] = vec2(0.0+(wiggle[2]*0.25), 0.0+(wiggle[2]*-0.25));\n\tcpts6[3] = vec2(0.75+(wiggle[1]*-0.75), -0.85+(wiggle[3]*0.25));\n\t//\n\tcpts7[0] = vec2(-0.77, 0.55);\n\tcpts7[1] = vec2(0.0+(wiggle[5]*0.25), 0.0+(wiggle[1]*-0.55));\n\tcpts7[2] = vec2(-0.25+(wiggle[2]*0.25), -0.5+(wiggle[0]*-0.125));\n\tcpts7[3] = vec2(-0.55+(wiggle[1]*-0.35), -0.95+(wiggle[3]*-0.25));\n\n\tfloat fD = 100.0;\n\n\tfD = min(fD, sTentacle(pc, cpts0));\n    fD = min(fD, sTentacle(pc, cpts1));\n    fD = min(fD, sTentacle(pc, cpts2));\n    fD = min(fD, sTentacle(pc, cpts3));\n    fD = min(fD, sTentacle(pc, cpts4));\n    fD = min(fD, sTentacle(pc, cpts5));\n    fD = min(fD, sTentacle(pc, cpts6));\n    fD = min(fD, sTentacle(pc, cpts7));\n\n\tfD = min(length(pc - vec2(-0.65, 0.65))-0.25, fD);\n\n\tfloat fD2 = 4.0;\n\t\n\tfD2 = opS(length(pc - vec2(-0.57+(wiggle[2]*-0.25), 0.65+(wiggle[2]*-0.25)))-0.0625, fD2);\n\tfD2 = opS(length(pc - vec2(-0.77+(wiggle[1]*0.25), 0.65+(wiggle[3]*0.25)))-0.0625, fD2);\n\tfD2 = opU(length(pc - vec2(-0.79+(wiggle[2]*-0.0625), 0.65+(wiggle[4]*-0.0625)))-0.0225, fD2);\n\tfD2 = opU(length(pc - vec2(-0.59+(wiggle[3]*-0.0625), 0.65+(wiggle[5]*-0.0625)))-0.0225, fD2);\n\n\tfloat fDPX = fD * iResolution.x;\n\tfDPX = min(fDPX, sqrt(2.0));\n\tfDPX = max(fDPX, 0.0);\n\n\tfloat fDPX2 = fD2 * iResolution.x;\n\tfDPX2 = min(fDPX2, sqrt(2.0));\n\tfDPX2 = max(fDPX2, 0.0);\n    \n    float fDPX3 = (fD2+0.01) * iResolution.x;\n\tfDPX3 = min(fDPX3, sqrt(2.0));\n\tfDPX3 = max(fDPX3, 0.0);\n\t\n\tfloat fT = (fDPX/sqrt(2.0));\n\n\tfloat fC = mix(1.0, 0.0, fT);\n\n\tfC = max(0.0, fC);\n\tfC = min(1.0, fC);\n\n\tfloat fT2 = (fDPX2/sqrt(2.0));\n    float fT3 = (fDPX3/sqrt(2.0));\n\n\tfloat fC2 = mix(1.0, 0.0, fT2);\n\n\tfC2 = max(0.0, fC2);\n\tfC2 = min(1.0, fC2);\n    \n    float fC3 = mix(1.0, 0.0, fT3);\n    fC3 = max(0.0, fC3);\n\tfC3 = min(1.0, fC3);\n\n\tcolor = mix(vec3(0.0, 0.75*pc.y, 0.85), vec3((2.0/3.0)*(-pc.x+1.0), 0.0, 1.0), fC);\n\tcolor = mix(color, vec3(1.0, 1.0, 0.5), fC2);\n    color = mix(color, vec3(0.0, 0.0, 0.0), fC3);\n    return(color);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 c = shaderPus((uv*2.0)-vec2(1.0, 1.0));\n    \n\tfragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtlSR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 81, 81, 684], [686, 686, 719, 719, 746], [748, 748, 781, 781, 807], [809, 809, 842, 842, 868], [870, 870, 910, 910, 1369], [4953, 4953, 5010, 5010, 5139]], "test": "valid"}
{"id": "XtlSW7", "name": "Prettier Mandelbrot", "author": "Wicpar", "description": "a prettier version of my funky mandelbrot :)", "tags": ["fractal", "mandelbrot", "pretty"], "likes": 2, "viewed": 154, "published": "Public", "date": "1437156686", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int iter = 1000;\nfloat scale = 3.;\nvec2 center = vec2(1.001105,0.300717);\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    scale = 1./(pow(iTime,iTime/20.));\n    vec2 z, c;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    c.x = 1.3333 * (uv.x - 0.5) * scale - center.x;\n    c.y = (uv.y - 0.5) * scale - center.y;\n    z = c;\n    int it;\n    for(int i = 0; i<iter; i++) {\n        float x = (z.x * z.x - z.y * z.y) + c.x;\n        float y = (z.y * z.x + z.x * z.y) + c.y;\n\n        if((x * x + y * y) > 4.0) break;\n        z.x = x;\n        z.y = y;\n        it = i;\n    }\n\t fragColor = vec4(pal(float(iter-it)/float(iter),vec3(0.,0.,0.),vec3(1,1,1),vec3(4,2,1),vec3(0,0,0)),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtlSW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 149, 149, 192], [194, 194, 251, 251, 808]], "test": "valid"}
{"id": "XtlXRB", "name": "crowded gyros - 425 chars", "author": "FabriceNeyret2", "description": " compact simplified version of [url]https://www.shadertoy.com/view/MllXz7[/url]", "tags": ["3d", "raymarching", "short", "spheremarching"], "likes": 20, "viewed": 1713, "published": "Public API", "date": "1437601299", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// compact simplified version of https://www.shadertoy.com/view/MllXz7 (773 chars)\n// using the base ray-marcher of Trisomie21: https://www.shadertoy.com/view/4tfGRB#\n\n#define r(t) *=mat2(C=cos(t*T),S=sin(t*T),-S,C),\n\nvoid mainImage( out vec4 f, vec2 w ) {\n    f-=f;\n    float T=iTime, C,S, x;\n    vec4 p = f-.5, d,u,t,a; \n    p.xy += w/iResolution.y, p.x-=.4; \n    p.xz r(.13)   p.yz r(.2)  \n    d = p;  p.z += 5.*T;\n      \n    for (float i=1.; i>0.; i-=.01) {\n        \n        u = sin(78.+ceil(p/8.)), t = mod(p,8.)-4.; \n        x=1e9;\n        \n        for (float j=2.3; j>1.; j-= .3)\n            t.xy r(u.x)   t.xz r(u.y)\n            a = abs(t),\n            x = min(x, max(abs(length(t.xyz)-j*1.26),  max(a.x,max(a.y,a.z))-j)); \n \n        if(x <.01) {  f = vec4(i*i*1.2); break;  } \n        p -= d*x;           \n     }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtlXRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "valid"}
{"id": "XtS3Dt", "name": "Flip Dot Plasma", "author": "slembcke", "description": "Plasma drawn on a mechanical flip dot display.", "tags": ["plasma", "monochrome", "flipdots"], "likes": 21, "viewed": 603, "published": "Public", "date": "1436481915", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI 3.141592653589793\n\n#define CELL_SIZE 40.0\n#define WIDTH 0.4\n#define ROUND 0.5\n\n#define INTERVAL 0.6\n\n// Rotate the uv coords for a flip dot plane around the x-axis.\nvec2 flipX(vec2 uv, float a){\n    vec3 r = vec3(uv, 3.0);\n    vec3 n = vec3(0.0, sin(a), cos(a));\n    float t = (r.z*n.z)/dot(n, r);\n    \n    vec3 p = r*t;\n    return vec2(p.x, p.y/n.z);\n}\n\n// Called for the value of each flip dot cell.\n// Borrowed from https://www.shadertoy.com/view/MdXGDH\nfloat display(vec2 uv, float t){\n    uv *= 20.0;\n    t *= 0.01;\n    \n\tvec2 center = vec2(640.0/2.0, 360.0/2.0) + vec2(640.0/2.0*sin(-t*3.0), 360.0/2.0*cos(-t*3.0));\n\n\tfloat color1 = (sin(dot(uv.xy, vec2(sin(t*3.0), cos(t*3.0)))*0.02 + t*3.0) + 1.0)/2.0;\n\tfloat color2 = (cos(length(uv.xy - center)*0.03) + 1.0)/2.0;\n\tfloat color = (color1 + color2)/2.0;\n\n\treturn (cos(M_PI*color/0.5 + t*3.0) + 1.0)/2.0;\n}\n\n// Each flip cell has a slightly different timing.\nfloat delay(vec2 uv){\n    return texture(iChannel0, uv/1024.0).r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Cell coordinates.\n    vec2 cell = fragCoord.xy/CELL_SIZE;\n    vec2 cellf = fract(cell);\n    vec2 celli = cell - cellf;\n    \n    // Time values.\n    float t = iTime/INTERVAL + 0.5*delay(celli) + celli.y/40.0;\n    float tf = fract(t);\n    float ti = t - tf;\n    \n    // Current and next display value.\n    float d0 = step(0.5, display(celli, ti));\n    float d1 = step(0.5, display(celli, ti + 1.0));\n    \n    // Flip dot rotation phase. [0, 1]\n    float phase = mix(d0, d1, smoothstep(0.0, 1.0, tf));\n    \n    // Coordinates of the flip dot's plane.\n    vec2 plane = flipX(2.0*cellf - 1.0, M_PI*phase);\n    \n    // Implicit function for the rounded rectangle.\n    float f = ROUND - length(plane - clamp(plane, -WIDTH, WIDTH));\n    \n    // Anti-alias and output!\n    vec3 color = mix(vec3(0.2), vec3(1.0), step(phase, 0.5));\n    float aa = smoothstep(0.0, fwidth(f), f);\n\tfragColor = vec4(aa*color, 1.0);\n}", "image_inputs": [{"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtS3Dt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[114, 178, 207, 207, 366], [368, 470, 502, 502, 875], [877, 928, 949, 949, 995], [997, 997, 1054, 1079, 1965]], "test": "error"}
{"id": "XtsSDH", "name": "Scanline Render", "author": "P_Malin", "description": "Idea to use discard to only calculate one scanline per frame (hacked horribly into an old shader).\nOriginal glslsandbox version using feedback: http://glslsandbox.com/e#26529.0\nOriginal Shadertoy version: https://www.shadertoy.com/view/ldl3zn\n", "tags": ["scanline", "render"], "likes": 17, "viewed": 685, "published": "Public", "date": "1436446934", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// TimeWarp @P_Malin\n// Scanline render version\n// Original here: https://www.shadertoy.com/view/ldl3zn\n\n#define ENABLE_MONTE_CARLO\n#define USE_DISCARD\n \n#define ENABLE_REFLECTIONS\n#define ENABLE_FOG\n#define ENABLE_SPECULAR\n#define ENABLE_DIRECTIONAL_LIGHT\n\nconst float kPI = acos(0.0);\nconst float kTwoPI = kPI * 2.0;\n\n#ifdef ENABLE_MONTE_CARLO\nvec4 gPixelRandom;\nvec3 gRandomNormal;\n \nvoid CalcPixelRandom( const vec2 fragCoord, const float seed )\n{\n    // Nothing special here, just numbers generated by bashing keyboard\n    vec4 s1 = sin(seed * 3.3422 + fragCoord.xxxx * vec4(324.324234, 563.324234, 657.324234, 764.324234)) * 543.3423;\n    vec4 s2 = sin(seed * 1.3422 + fragCoord.yyyy * vec4(567.324234, 435.324234, 432.324234, 657.324234)) * 654.5423;\n    gPixelRandom = fract(2142.4 + s1 + s2);\n    gRandomNormal = normalize( gPixelRandom.xyz - 0.5);\n}\n\nfloat GetTime()\n{\n\treturn 0.0;\n}\n#else\nfloat GetTime()\n{\n\treturn iTime;\n}\n#endif\n \nstruct C_Ray\n{\n    vec3 vOrigin;\n    vec3 vDir;\n};\n \nstruct C_HitInfo\n{\n    vec3 vPos;\n    float fDistance;\n    vec3 vObjectId;\n};\n \nstruct C_Material\n{\n    vec3 cAlbedo;\n    float fR0;\n    float fSmoothness;\n    vec2 vParam;\n};\n \nvec3 RotateX( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n   \n    vec3 vResult = vec3( vPos.x, c * vPos.y + s * vPos.z, -s * vPos.y + c * vPos.z);\n   \n    return vResult;\n}\n \nvec3 RotateY( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n   \n    vec3 vResult = vec3( c * vPos.x + s * vPos.z, vPos.y, -s * vPos.x + c * vPos.z);\n   \n    return vResult;\n}\n   \nvec3 RotateZ( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n   \n    vec3 vResult = vec3( c * vPos.x + s * vPos.y, -s * vPos.x + c * vPos.y, vPos.z);\n   \n    return vResult;\n}\n \nvec4 DistCombineUnion( const in vec4 v1, const in vec4 v2 )\n{\n    //if(v1.x < v2.x) return v1; else return v2;\n    return mix(v1, v2, step(v2.x, v1.x));\n}\n \nvec4 DistCombineIntersect( const in vec4 v1, const in vec4 v2 )\n{\n    return mix(v2, v1, step(v2.x,v1.x));\n}\n \nvec4 DistCombineSubtract( const in vec4 v1, const in vec4 v2 )\n{\n    return DistCombineIntersect(v1, vec4(-v2.x, v2.yzw));\n}\n \nvec3 DomainRepeatXZGetTile( const in vec3 vPos, const in vec2 vRepeat, out vec2 vTile )\n{\n    vec3 vResult = vPos;\n    vec2 vTilePos = (vPos.xz / vRepeat) + 0.5;\n    vTile = floor(vTilePos + 1000.0);\n    vResult.xz = (fract(vTilePos) - 0.5) * vRepeat;\n    return vResult;\n}\n \nvec3 DomainRepeatXZ( const in vec3 vPos, const in vec2 vRepeat )\n{\n    vec3 vResult = vPos;\n    vec2 vTilePos = (vPos.xz / vRepeat) + 0.5;\n    vResult.xz = (fract(vTilePos) - 0.5) * vRepeat;\n    return vResult;\n}\n \nvec3 DomainRepeatY( const in vec3 vPos, const in float fSize )\n{\n    vec3 vResult = vPos;\n    vResult.y = (fract(vPos.y / fSize + 0.5) - 0.5) * fSize;\n    return vResult;\n}\n \nvec3 DomainRotateSymmetry( const in vec3 vPos, const in float fSteps )\n{\n    float angle = atan( vPos.x, vPos.z );\n \n    float fScale = fSteps / (kTwoPI);\n    float steppedAngle = (floor(angle * fScale + 0.5)) / fScale;\n \n    float s = sin(-steppedAngle);\n    float c = cos(-steppedAngle);\n \n    vec3 vResult = vec3( c * vPos.x + s * vPos.z,\n                vPos.y,\n                -s * vPos.x + c * vPos.z);\n \n    return vResult;\n}\n \nfloat GetDistanceXYTorus( const in vec3 p, const in float r1, const in float r2 )\n{\n    vec2 q = vec2(length(p.xy)-r1,p.z);\n    return length(q)-r2;\n}\nfloat GetDistanceYZTorus( const in vec3 p, const in float r1, const in float r2 )\n{\n    vec2 q = vec2(length(p.yz)-r1,p.x);\n    return length(q)-r2;\n}\nfloat GetDistanceCylinderY(const in vec3 vPos, const in float r)\n{\n    return length(vPos.xz) - r;\n}\nfloat GetDistanceBox( const in vec3 vPos, const in vec3 vSize )\n{\n    vec3 vDist = (abs(vPos) - vSize);\n    return max(vDist.x, max(vDist.y, vDist.z));\n}\n \nfloat GetDistanceRoundedBox( const in vec3 vPos, const in vec3 vSize, float fRadius )\n{\n    vec3 vClosest = max(min(vPos, vSize), -vSize);\n    return length(vClosest - vPos) - fRadius;\n}\n \nfloat GetDistanceWinder( const in vec3 vPos )\n{\n   float fWinderSize = 0.15;\n   float fAngle = atan(vPos.x, vPos.z) + vPos.y * 2.0;\n\t\n   float fBump = 1.0 + sin(fAngle * 10.0 * kPI) * 0.05;\n   return length(vPos + vec3(0.0, -1.0 - 0.2, 0.0)) * fBump - fWinderSize;\t\n}\n\nvec4 GetDistanceClock( const in vec3 vPos )\n{\n\tconst float fRadius = 1.0;\n\tconst float fThickness = 0.1;\n\tconst float fInsetRadius = 0.9;\n\tconst float fInsetDepth = 0.1;\n\tfloat fTorusDist = GetDistanceXYTorus(vPos, 1.0, fThickness);\n\t\n\tfloat fCylinderDist = length(vPos.xy) - fRadius;\n\tfloat fCylinderCap = abs(vPos.z) - fThickness;\n\tfCylinderDist = max(fCylinderDist, fCylinderCap);\n\tfloat fDist = min(fTorusDist, fCylinderDist);\n\t\n\tfloat fWinderDist = GetDistanceWinder(vPos);\n\tfDist = min(fDist, fWinderDist);\n\tvec4 vResult = vec4(fDist, 2.0, 0.0, 0.0);\n\t\n\tfloat fInsetDist = length(vPos.xy) - fInsetRadius;\n\tfloat fInsetCap = abs(vPos.z - fThickness) - fInsetDepth;\n\t\n\tvec4 vInsetCapDist = vec4(fInsetCap, 3.0, vPos.x, vPos.y);\n\tvec4 vInsetDist = vec4(fInsetDist, 2.0, 0.0, 0.0);\n\t\n\tvInsetDist = DistCombineIntersect(vInsetDist, vInsetCapDist);\n\t\n\tvResult = DistCombineSubtract(vResult, vInsetDist);\n\t\n\t\n\tfloat fHandSeconds = GetTime();\n\t\n\tfHandSeconds = floor(fHandSeconds) + (pow(fract(fHandSeconds), 50.0));\n\tfloat fHandAngle = -fHandSeconds * kPI * 2.0 / 60.0;\n\t\n\tvec3 vHandDomain = RotateZ(vPos, fHandAngle);\n\tfloat fHandHeight = 0.05;\n\tvHandDomain.z -= fThickness - fInsetDepth + fHandHeight;\n\tfloat fHandDist = length(vHandDomain.xz) - 0.01;\n\tfHandDist = max(fHandDist, (abs(vHandDomain.y + 0.4) - 0.4));\n\t\n\tvec4 vHandDist = vec4(fHandDist, 4.0, 0.0, 0.0);\n\t\n\tvResult = DistCombineUnion(vResult, vHandDist);\n\t\n\treturn vResult;\n}\n \nvec3 WarpDomain( const in vec3 vPos )\n{\n    vec3 vResult = vPos + vec3(0.0, 0.1, 0.1);\n\n    float fUnbend = clamp(atan(vResult.y, vResult.z), 0.0, kPI * 0.9);\n    vResult = RotateX(vResult, -fUnbend);\n     \n    float fDroopBlend = max(-vResult.y, 0.0);\t\n    vResult.y += fDroopBlend * 0.4;\n    vResult.z += sin(vResult.x * 4.0  + vResult.y * 6.0 + GetTime()) * fDroopBlend * 0.05;\n    return vResult;\n}\n\n// result is x=scene distance y=material or object id; zw are material specific parameters (maybe uv co-ordinates)\nvec4 GetDistanceScene( const in vec3 vPos )\n{         \n    vec4 vResult = vec4(10000.0, -1.0, 0.0, 0.0);\n                    \n    vec3 vClockDomain = WarpDomain(vPos + vec3(0.0, -0.1, -0.45));\n    vClockDomain.y += 0.2;\t\n    vResult = DistCombineUnion(vResult, GetDistanceClock(vClockDomain));\n        \n    vec4 vWallDist1 = vec4(vPos.z - 0.2, 1.0, vPos.xy);\n    vec4 vWallDist2 = vec4(vPos.y, 1.0, vPos.xz);\n    vWallDist1 = DistCombineIntersect(vWallDist1, vWallDist2);\n    vResult = DistCombineUnion(vResult, vWallDist1);\n             \n\t\n    vec4 vFloorDist = vec4(vPos.y + 2.3, 5.0, vPos.xz);\n    vResult = DistCombineUnion(vResult, vFloorDist);\n\t\n    return vResult;\n}\n \nvec3 GetWatchFaceColour( const vec2 vUV )\n{\n        float fRadius = length(vUV);\n       \n        float fFraction = (atan(vUV.x, -vUV.y) / (kPI * 2.0)) + (0.5 / 60.0);\n               \n        float fTickValue = fFraction * 60.0;   \n        float fTickIndex = floor(fTickValue);\n        float fTickFraction = fract(fTickValue);\n               \n\tfloat fTickLength = 0.25;       \n\tfTickLength += step( fract(fTickIndex / 10.0), 0.5 / 10.0 ) * 0.1;\n\tfTickLength += step( fract(fTickIndex / 5.0), 0.5 / 5.0 ) * 0.05;\n\t\n\tfloat fTickWidth = 0.2;\n\tfloat fInTickSegment = step(abs(fTickFraction - 0.5), fTickWidth);\n\t\n\tfloat fInTickRadiusOuter = step(fRadius, 0.8);\n\tfloat fInTickRadiusInner = step(1.0 - fTickLength, fRadius);\n\t\n\t// 1.0 if not one of these...\n\tfloat fBlend = 1.0 - fInTickSegment * fInTickRadiusOuter * fInTickRadiusInner;\n\t\n\t// central dot\n\tfBlend = fBlend * step(0.025, fRadius);                                 \n\t\n\treturn mix(vec3(0.05), vec3(0.95), fBlend);\n}\n \nC_Material GetObjectMaterial( const in vec3 vObjId, const in vec3 vPos, const in vec3 vNormal )\n{\n    C_Material mat;\n             \n    if(vObjId.x < 1.5)\n    {\n        // wall\n        mat.fR0 = 0.2;\n\t\tvec3 cTextureSample = texture(iChannel0, vObjId.yz).rgb;\n        mat.fSmoothness = cTextureSample.r * cTextureSample.b;\n        mat.cAlbedo = cTextureSample * cTextureSample;\n    }\n    else\n    if(vObjId.x < 2.5)\n    {\n        // silver\n        mat.fR0 = 0.95;\n        mat.fSmoothness = 0.9;\n        mat.cAlbedo = vec3(0.9, 0.9, 0.91);\n    }\n    else\n    if(vObjId.x < 3.5)\n    {\n\t    // clock face\n            mat.fR0 = 0.01;\n            mat.fSmoothness = 0.9;\n            mat.cAlbedo = GetWatchFaceColour( vObjId.yz );\n    }\n    else\n    if(vObjId.x < 4.5)\n    {\n        // hand\n        mat.fR0 = 0.01;\n        mat.fSmoothness = 0.9;\n        mat.cAlbedo = vec3(0.95, 0.05, 0.05);\n    }\n    else\n    if(vObjId.x < 5.5)\n    {\n        // floor\n        mat.fR0 = 0.01;\n\t\tvec3 cTextureSample = texture(iChannel1, vObjId.yz).rgb;\n        mat.cAlbedo = cTextureSample * cTextureSample;\n        mat.fSmoothness = cTextureSample.r * cTextureSample.g;\n    }\n \n    return mat;\n}\nvec3 GetLightDirection()\n{\n    vec3 vLightDir = vec3(1.0, 2.0, 1.0);\n\n    #ifdef ENABLE_MONTE_CARLO       \n    vLightDir += gRandomNormal * 0.01;\n    #endif\n    return normalize(vLightDir);\n}\nvec3 GetLightCol()\n{\n    return vec3(1.0, 0.7, 0.5) * 10.0;\n}\n\nvec3 GetSkyGradient( const in vec3 vDir )\n{\n\tfloat fBlend = vDir.y * 0.5 + 0.5;\n\treturn mix(vec3(0.0, 0.0, 0.0), vec3(0.25, 0.5, 1.0) * 4.0, fBlend);\n}\n \nvec3 GetAmbientLight(const in vec3 vNormal)\n{\n    return GetSkyGradient(vNormal);\n}\n \n#define kFogDensity 0.075\nvoid ApplyAtmosphere(inout vec3 col, const in C_Ray ray, const in C_HitInfo intersection)\n{\n    #ifdef ENABLE_FOG\n    // fog\n    float fFogAmount = exp(intersection.fDistance * -kFogDensity);\n    vec3 cFog = GetSkyGradient(ray.vDir);\n    col = mix(cFog, col, fFogAmount);\n    #endif\n}\n\nvec3 GetSceneNormal( const in vec3 vPos )\n{\n    // tetrahedron normal\n    float fDelta = 0.01;\n \n    vec3 vOffset1 = vec3( fDelta, -fDelta, -fDelta);\n    vec3 vOffset2 = vec3(-fDelta, -fDelta,  fDelta);\n    vec3 vOffset3 = vec3(-fDelta,  fDelta, -fDelta);\n    vec3 vOffset4 = vec3( fDelta,  fDelta,  fDelta);\n \n    float f1 = GetDistanceScene( vPos + vOffset1 ).x;\n    float f2 = GetDistanceScene( vPos + vOffset2 ).x;\n    float f3 = GetDistanceScene( vPos + vOffset3 ).x;\n    float f4 = GetDistanceScene( vPos + vOffset4 ).x;\n \n    vec3 vNormal = vOffset1 * f1 + vOffset2 * f2 + vOffset3 * f3 + vOffset4 * f4;\n \n    return normalize( vNormal );\n}\n \n#define kRaymarchEpsilon 0.01\n#define kRaymarchMatIter 20\n#define kRaymarchStartDistance 0.01\n// This is an excellent resource on ray marching -> http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvoid Raymarch( const in C_Ray ray, out C_HitInfo result, const float fMaxDist, const int maxIter )\n{       \n    result.fDistance = kRaymarchStartDistance;\n    result.vObjectId.x = 0.0;\n                             \n    for(int i=0;i<=kRaymarchMatIter;i++)             \n    {\n        result.vPos = ray.vOrigin + ray.vDir * result.fDistance;\n        vec4 vSceneDist = GetDistanceScene( result.vPos );\n        result.vObjectId = vSceneDist.yzw;\n \n        // abs allows backward stepping - should only be necessary for non uniform distance functions\n        if((abs(vSceneDist.x) <= kRaymarchEpsilon) || (result.fDistance >= fMaxDist) || (i > maxIter))\n        {\n            break;\n        }                       \n \n        result.fDistance = result.fDistance + vSceneDist.x;   \n    }\n     \n      \n    if(result.fDistance >= fMaxDist)\n    {\n        result.vPos = ray.vOrigin + ray.vDir * result.fDistance;\n        result.vObjectId.x = 0.0;\n        result.fDistance = 1000.0;\n    }\n}\n \nfloat GetShadow( const in vec3 vPos, const in vec3 vLightDir, const in float fLightDistance )\n{\n    C_Ray shadowRay;\n    shadowRay.vDir = vLightDir;\n    shadowRay.vOrigin = vPos;\n \n    C_HitInfo shadowIntersect;\n    Raymarch(shadowRay, shadowIntersect, fLightDistance, 32);\n                                                                                                       \n    return step(0.0, shadowIntersect.fDistance) * step(fLightDistance, shadowIntersect.fDistance );         \n}\n \n// http://en.wikipedia.org/wiki/Schlick's_approximation\nfloat Schlick( const in vec3 vNormal, const in vec3 vView, const in float fR0, const in float fSmoothFactor)\n{\n    float fDot = dot(vNormal, -vView);\n    fDot = min(max((1.0 - fDot), 0.0), 1.0);\n    float fDot2 = fDot * fDot;\n    float fDot5 = fDot2 * fDot2 * fDot;\n    return fR0 + (1.0 - fR0) * fDot5 * fSmoothFactor;\n}\n \nfloat GetDiffuseIntensity(const in vec3 vLightDir, const in vec3 vNormal)\n{\n    return max(0.0, dot(vLightDir, vNormal));\n}\n \nfloat GetBlinnPhongIntensity(const in C_Ray ray, const in C_Material mat, const in vec3 vLightDir, const in vec3 vNormal)\n{         \n    vec3 vHalf = normalize(vLightDir - ray.vDir);\n    float fNdotH = max(0.0, dot(vHalf, vNormal));\n \n    float fSpecPower = exp2(4.0 + 6.0 * mat.fSmoothness);\n    float fSpecIntensity = (fSpecPower + 2.0) * 0.125;\n \n    return pow(fNdotH, fSpecPower) * fSpecIntensity;\n}\n \n// use distance field to evaluate ambient occlusion\nfloat GetAmbientOcclusion(const in C_Ray ray, const in C_HitInfo intersection, const in vec3 vNormal)\n{\n    vec3 vPos = intersection.vPos;\n     \n    float fAmbientOcclusion = 1.0;\n     \n    float fDist = 0.0;\n    for(int i=0; i<=5; i++)\n    {\n        fDist += 0.1;\n \n        vec4 vSceneDist = GetDistanceScene(vPos + vNormal * fDist);\n \n        fAmbientOcclusion *= 1.0 - max(0.0, (fDist - vSceneDist.x) * 0.2 / fDist );                                 \n    }\n     \n    return fAmbientOcclusion;\n}\n \nvec3 GetObjectLighting(const in C_Ray ray, const in C_HitInfo intersection, const in C_Material material, const in vec3 vNormal, const in vec3 cReflection)\n{\n    vec3 cScene ;\n   \n    vec3 vSpecularReflection = vec3(0.0);\n    vec3 vDiffuseReflection = vec3(0.0);\n   \n    float fAmbientOcclusion = GetAmbientOcclusion(ray, intersection, vNormal);\n    vec3 vAmbientLight = GetAmbientLight(vNormal) * fAmbientOcclusion;\n   \n    vDiffuseReflection += vAmbientLight;\n   \n    vSpecularReflection += cReflection * fAmbientOcclusion;\n             \n    #ifdef ENABLE_DIRECTIONAL_LIGHT\n    vec3 vLightDir = GetLightDirection();\n      \n    float fShadowBias = 0.05;           \n    float fShadowFactor = GetShadow( intersection.vPos + vLightDir * fShadowBias, vLightDir, 10.0 );\n    vec3 vIncidentLight = GetLightCol() * fShadowFactor;\n   \n    vDiffuseReflection += GetDiffuseIntensity( vLightDir, vNormal ) * vIncidentLight;                                                                               \n    vSpecularReflection += GetBlinnPhongIntensity( ray, material, vLightDir, vNormal ) * vIncidentLight;\n    #endif // ENABLE_DIRECTIONAL_LIGHT\n   \n    vDiffuseReflection *= material.cAlbedo;             \n    \n    #ifdef ENABLE_SPECULAR\n    float fFresnel = Schlick(vNormal, ray.vDir, material.fR0, material.fSmoothness * 0.9 + 0.1);\n    cScene = mix(vDiffuseReflection , vSpecularReflection, fFresnel);\n    #else\n    cScene = vDiffuseReflection;\n    #endif\n   \n    return cScene;\n}\n \nvec3 GetSceneColourSimple( const in C_Ray ray )\n{\n    C_HitInfo intersection;\n    Raymarch(ray, intersection, 10.0, 32);\n                       \n    vec3 cScene;\n \n    if(intersection.vObjectId.x < 0.5)\n    {\n        cScene = GetSkyGradient(ray.vDir);\n    }\n    else\n    {\n        vec3 vNormal = GetSceneNormal(intersection.vPos);\n        C_Material material = GetObjectMaterial(intersection.vObjectId, intersection.vPos, vNormal);\n \n        // use sky gradient instead of reflection\n        vec3 cReflection = GetSkyGradient(reflect(ray.vDir, vNormal));\n \n        // apply lighting\n        cScene = GetObjectLighting(ray, intersection, material, vNormal, cReflection );\n    }\n \n    ApplyAtmosphere(cScene, ray, intersection);\n \n    return cScene;\n}\n \nvec3 GetSceneColour( const in C_Ray ray )\n{                                                         \n    C_HitInfo intersection;\n    Raymarch(ray, intersection, 30.0, 256);\n               \n    vec3 cScene;\n     \n    if(intersection.vObjectId.x < 0.5)\n    {\n        cScene = GetSkyGradient(ray.vDir);\n    }\n    else\n    {\n        vec3 vNormal = GetSceneNormal(intersection.vPos);\n        C_Material material = GetObjectMaterial(intersection.vObjectId, intersection.vPos, vNormal);\n \n        #ifdef ENABLE_MONTE_CARLO\n        vNormal = normalize(vNormal + gRandomNormal / (5.0 + material.fSmoothness * 200.0));\n        #endif\n \n        vec3 cReflection;\n        #ifdef ENABLE_REFLECTIONS   \n        {\n            // get colour from reflected ray\n            float fSepration = 0.05;\n            C_Ray reflectRay;\n            reflectRay.vDir = reflect(ray.vDir, vNormal);\n            reflectRay.vOrigin = intersection.vPos + reflectRay.vDir * fSepration;\n                                                                 \n            cReflection = GetSceneColourSimple(reflectRay);                                                                       \n        }\n        #else\n        cReflection = GetSkyGradient(reflect(ray.vDir, vNormal));                             \n        #endif\n        // apply lighting\n        cScene = GetObjectLighting(ray, intersection, material, vNormal, cReflection );\n    }\n     \n    ApplyAtmosphere(cScene, ray, intersection);\n     \n    return cScene;\n}\n \nvoid GetCameraRay( const in vec3 vPos, const in vec3 vForwards, const in vec3 vWorldUp, const in vec2 fragCoord, out C_Ray ray)\n{\n    vec2 vPixelCoord = fragCoord.xy;\n    #ifdef ENABLE_MONTE_CARLO\n    vPixelCoord += gPixelRandom.zw;\n    #endif\n    vec2 vUV = ( vPixelCoord / iResolution.xy );\n    vec2 vViewCoord = vUV * 2.0 - 1.0;\n \n    vViewCoord *= 0.75;\n     \n    float fRatio = iResolution.x / iResolution.y;\n \n    vViewCoord.y /= fRatio;                         \n \n    ray.vOrigin = vPos;\n \n    vec3 vRight = normalize(cross(vForwards, vWorldUp));\n    vec3 vUp = cross(vRight, vForwards);\n       \n    ray.vDir = normalize( vRight * vViewCoord.x + vUp * vViewCoord.y + vForwards);       \n}\n \nvoid GetCameraRayLookat( const in vec3 vPos, const in vec3 vInterest, const in vec2 fragCoord, out C_Ray ray)\n{\n    vec3 vForwards = normalize(vInterest - vPos);\n    vec3 vUp = vec3(0.0, 1.0, 0.0);\n \n    GetCameraRay(vPos, vForwards, vUp, fragCoord, ray);\n}\n \nvec3 OrbitPoint( const in float fHeading, const in float fElevation )\n{\n    return vec3(sin(fHeading) * cos(fElevation), sin(fElevation), cos(fHeading) * cos(fElevation));\n}\n \nvec3 Gamma( const in vec3 cCol )\n{\n    return sqrt(cCol);\n}\n \nvec3 InvGamma( const in vec3 cCol )\n{\n    return cCol * cCol;\n}\n \n \nvec3 Tonemap( const in vec3 cCol )\n{\n    \n    vec3 vResult = 1.0 - exp2(-cCol);\n \n    return Gamma(vResult);\n}\n \nvec3 InvTonemap( const in vec3 cCol )\n{\n    vec3 vResult = cCol;\n    vResult = clamp(vResult, 0.01, 0.99);\n    vResult = InvGamma(vResult);\n    return - log2(1.0 - vResult);\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cFinal = vec3(0.0);\n        \n    #ifdef ENABLE_MONTE_CARLO           \n\n#ifdef USE_DISCARD    \n    float scanSpeed = 30.0;\n    float activePixel = mod( floor(iTime * scanSpeed), iResolution.y );\n    float activeRange = iResolution.y - fragCoord.y - activePixel;\n    if( (activeRange < 0.0) || (activeRange > 1.0) )\n        discard; \n#endif // USE_DISCARD        \n    \n    const int iterations = 16;\n    \n    for( int iter = 0; iter<iterations; iter++)\n    {\n\t    CalcPixelRandom( fragCoord, iTime + float(iter) );\n    #endif\n     \n        C_Ray ray;\n\n        const float fCamreaHeadingMin = -0.8;\n        const float fCamreaHeadingMax = 1.8;\n        const float fCamreaElevationMin = 0.1;\n        const float fCamreaElevationMax = 0.7;\n        const float fCamreaDistMin = 3.0;\n        const float fCamreaDistMax = 2.0;\n\n        vec2 vMouse = iMouse.xy / iResolution.xy;\n\n        // If we have never moved the mouse\n        if(iMouse.x <= 0.0)\n        {\n            vMouse.xy = vec2(0.0, 1.0);\n        }\n\n\n        float fHeading = mix(fCamreaHeadingMin, fCamreaHeadingMax, vMouse.x);\n        float fElevation = mix(fCamreaElevationMin, fCamreaElevationMax, vMouse.y);\n        float fCameraDist = mix(fCamreaDistMax, fCamreaDistMin, vMouse.y);\n\n        vec3 vCameraPos = OrbitPoint(fHeading, fElevation) * fCameraDist;\n\n        #ifdef ENABLE_MONTE_CARLO           \n        float fDepthOfField = 0.025;\n        vCameraPos += gRandomNormal * fDepthOfField;\n        #endif\n\n        GetCameraRayLookat( vCameraPos, vec3(0.0, -0.5, 0.2), fragCoord, ray);\n\n        vec3 cScene = GetSceneColour( ray ); \n\n        float fExposure = 0.4;\n        cScene = cScene * fExposure;\n\n        cFinal += cScene;\n\n    #ifdef ENABLE_MONTE_CARLO           \n    }\n    cFinal /= float(iterations);\n    #endif\n\n    // vignette\n    vec2 vUV = ((fragCoord.xy / iResolution.xy) - 0.5) * 2.0;\n    float fDist = dot(vUV, vUV);\n    fDist = fDist * fDist;\n    float fAmount = 1.0 / (fDist * 5.0 + 1.0);\n    cFinal = cFinal * fAmount;\n    \n    cFinal = Tonemap(cFinal);\n         \n    float fAlpha = 1.0;\n     \n    fragColor = vec4( cFinal, fAlpha );\n}\n ", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtsSDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[7020, 7020, 7063, 7063, 7991], [9166, 9166, 9192, 9192, 9357], [9358, 9358, 9378, 9378, 9419]], "test": "error"}
{"id": "XtsSWH", "name": "raytracer with blackjack and...", "author": "yaro_b", "description": "My first raytracer.\n\nNOTE: Click&drag mouse to change camera position.", "tags": ["raytracing", "brdf"], "likes": 2, "viewed": 1248, "published": "Public API", "date": "1436405888", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// My first raytracer.\n\n#define MAX_BOUNCE_COUNT 16\n\n// NxN anti-aliasing.\n#define AA_COUNT 4\n\n#define ENABLE_SHADOWS 1\n\n#define PI 3.14159265359\n\n// Index of refraction.\nfloat eta_air = 1.00029;\nfloat eta_glass = 1.5;\n\nfloat camera_orbit_radius = 2.5;\nfloat camera_elevation = PI / 4.0; // radians\nfloat camera_azimuth = 0.0; // radians;\nvec3 camera_pos;\nvec3 camera_dir;\nvec3 camera_up;\n\nfloat camera_aspect_ratio = iResolution.x / iResolution.y;\nfloat camera_fov_y = PI / 3.0; // radians\nfloat camera_near = 0.1;\nfloat camera_far = 10.0;\nfloat camera_far_half_height = tan(0.5 * camera_fov_y) * camera_far;\nfloat camera_far_half_width = camera_far_half_height * camera_aspect_ratio;\n\n// vec3 light_pos = vec3(1.0, 1.0, -1.0);\n// vec3 light_pos = vec3(cos(2.0 * PI * iTime), sin(2.0 * PI * iTime), -1.0);\nvec3 light_pos = 2.0 * vec3(cos(2.0 * PI * iTime / 8.0), 1.0, sin(2.0 * PI * iTime / 8.0));\nvec3 light_radiance = vec3(1.0, 1.0, 1.0);\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\n\nstruct Material\n{\n    vec3 specular;\n    vec3 diffuse;\n    float alpha; // width parameter aka roughness\n    float eta;   // index of refraction\n    int scatter_mask;\n};\n\nstruct Sphere\n{\n    vec3 origin;\n    float radius;\n};\n\nstruct Plane\n{\n    // dot(normal, X) = d\n    vec3 normal;\n    float d;\n};\n\nfloat spacing_angle = 2.0 / 3.0 * PI; // radians\nfloat spacing_radius = 1.0;\n\n// Scene objects:\nSphere diffuse_ball = Sphere(spacing_radius * vec3(cos(0.0 * spacing_angle), 0.5, sin(0.0 * spacing_angle)), 0.5);\nSphere specular_ball = Sphere(spacing_radius * vec3(cos(1.0 * spacing_angle), 0.5, sin(1.0 * spacing_angle)), 0.5);\nSphere glass_ball = Sphere(spacing_radius * vec3(cos(2.0 * spacing_angle), 0.5, sin(2.0 * spacing_angle)), 0.5);\nPlane checker_floor = Plane(vec3(0.0, 1.0, 0.0), 0.0);\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\n\n#define SCENE_GLASS_BALL 1\n#define SCENE_PLASTIC_BALL 2\n#define SCENE_GOLDEN_BALL 3\n#define SCENE_FLOOR 4\n\n#define SCATTER_DIFFUSE 1\n#define SCATTER_SPECULAR 2\n#define SCATTER_TRANSPARENT 4\n\nvoid get_material(vec3 pos, int id, inout Material mtl)\n{\n    if (id == SCENE_GLASS_BALL)\n    {\n        mtl.specular = vec3(0.04, 0.04, 0.04);\n        mtl.diffuse = vec3(1.0, 1.0, 1.0) - mtl.specular;\n        mtl.alpha = 0.05;\n        mtl.eta = 1.5;\n        mtl.scatter_mask = SCATTER_TRANSPARENT;\n    }\n    else if (id == SCENE_PLASTIC_BALL)\n    {\n        mtl.specular = vec3(0.04, 0.04, 0.04);\n        mtl.diffuse = vec3(1.0, 0.0, 0.0) - mtl.specular;\n        mtl.alpha = 0.25;\n        mtl.eta = 1.46; // PLA (pure); TODO: Pick something better for colored plastic.\n        mtl.scatter_mask = SCATTER_DIFFUSE;\n    }\n    else if (id == SCENE_GOLDEN_BALL)\n    {\n        mtl.specular = vec3(1.022, 0.782, 0.344);\n        mtl.diffuse = vec3(0.0, 0.0, 0.0);\n        mtl.alpha = 0.35;\n        mtl.eta = 1.47;\n        mtl.scatter_mask = SCATTER_SPECULAR;\n    }\n    else if (id == SCENE_FLOOR)\n    {\n        float checker_size = 0.5;\n        float alpha = floor(pos.x / checker_size) + floor(pos.z / checker_size);\n        alpha = abs(alpha);\n        alpha -= 2.0 * floor(alpha / 2.0);\n\n        mtl.specular = vec3(0.04, 0.04, 0.04);\n        /* mtl.diffuse = mix(vec3(0.95, 0.95, 0.95), vec3(0.25, 0.25, 0.25), alpha); */\n        mtl.diffuse = mix(vec3(0.25, 0.25, 0.95), vec3(0.95, 0.95, 0.25), alpha);\n        mtl.alpha = 0.25;\n        mtl.eta = 1.46; // PLA (pure); TODO: Pick something better for colored plastic.\n        mtl.scatter_mask = SCATTER_DIFFUSE;\n    }\n    else\n    {\n        mtl.specular = vec3(0.05, 0.05, 0.05);\n        mtl.diffuse = vec3(1.0, 0.0, 1.0) - mtl.specular;\n        mtl.alpha = 1.0;\n        mtl.eta = 1.46; // PLA (pure); TODO: Pick something better for colored plastic.\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\n\n// Schlick's approximation\nvec3 fresnel(vec3 f0, float i_dot_n)\n{\n    return f0 + (1.0 - f0) * pow(1.0 - max(0.0, i_dot_n), 5.0);\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\n\n#if 0\n// BSDF = BRDF + BTDF\n\n// BRDF (reflection):\nf_r(i, o, n) = F(i, h) * G(i, o, h) * D(h) / (4 * |i.n| * |o.n|)\nh = h_r\n// with Smith G\nf_r(i, o, n) = F(i, h) * G1(i, h) * G1(o, h) * D(h) / (4 * |i.n| * |o.n|)\n\n\n\n// BTDF (refraction):\nf_t(i, o, n) = (|i.h| * |o.h|) / (|i.n| * |o.n|) * eta_o^2 * (1 - F(i, h)) * G(i, o, h) * D(h) / (eta_i * i.h + eta_o * o.h)^2\nh = h_t\n// with Smith G\nf_t(i, o, n) = (|i.h| * |o.h|) / (|i.n| * |o.n|) * eta_o^2 * (1 - F(i, h)) * G1(i, h) * G1(o, h) * D(h) / (eta_i * i.h + eta_o * o.h)^2\n\n\n\n// GGX distribution:\nD(m) = a_g^2 * chi_plus(m.n) / (PI * cos^4(theta_m) * (a_g^2 + tan^2(theta_m))^2)\nG1(v, m) = chi_plus(v.m / v.n) * 2.0 / (1.0 + sqrt(1.0 + a_g^2 * tan^2(theta_v)))\n\ntheta_m = arccos(m.n)\ntheta_v = arccos(v.n)\nchi_plus(a) = step(0.0, a)\n\n\n\np_m(m) = D(m) * |m.n|\n#endif\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\n\nfloat D_ggx(float m_dot_n, Material mtl)\n{\n    float theta_m = acos(m_dot_n);\n    float result = pow(mtl.alpha, 2.0) * step(0.0, m_dot_n) / (PI * pow(m_dot_n, 4.0) * pow(pow(mtl.alpha, 2.0) + pow(tan(theta_m), 2.0), 2.0));\n    /* float result = pow(mtl.alpha, 2.0) / (PI * pow(pow(m_dot_n, 2.0) * (pow(mtl.alpha, 2.0) - 1.0) + 1.0, 2.0)); */\n    return result;\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\n\n// Using Smith G approximation scheme:\n// G(i, o, n) = G1(i, n) * G1(o, n)\nfloat G1_ggx(float v_dot_m, float v_dot_n, Material mtl)\n{\n    float theta_v = acos(v_dot_n);\n    float result = step(0.0, v_dot_m / v_dot_n) * 2.0 / (1.0 + sqrt(1.0 + pow(mtl.alpha, 2.0) * pow(tan(theta_v), 2.0)));\n    /* float result = 2.0 * v_dot_n / (v_dot_n + sqrt(pow(mtl.alpha, 2.0) + (1.0 - pow(mtl.alpha, 2.0)) * pow(v_dot_n, 2.0))); */\n    return result;\n}\n\n// Lambertian diffure BRDF.\nvec3 diffuse_brdf(vec3 i, vec3 o, vec3 n, Material mtl)\n{\n    vec3 f_r = mtl.diffuse / PI;\n    return f_r;\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\n\n// Microfacet BRDF with GGX distribution.\nvec3 specular_brdf(vec3 i, vec3 o, vec3 n, Material mtl)\n{\n    float i_dot_n = dot(i, n);\n    float o_dot_n = dot(o, n);\n\n    vec3 h_r = sign(i_dot_n) * normalize(i + o);\n\n    float i_dot_h = dot(i, h_r);\n    float o_dot_h = dot(o, h_r);\n    float h_dot_n = dot(h_r, n);\n\n    vec3 F = fresnel(mtl.specular, i_dot_h);\n    float G1_i = G1_ggx(i_dot_h, i_dot_n, mtl);\n    float G1_o = G1_ggx(o_dot_h, o_dot_n, mtl);\n    float D = D_ggx(h_dot_n, mtl);\n\n    vec3 f_r = F * G1_i * G1_o * D / (4.0 * max(0.0, i_dot_n) * max(0.0, o_dot_n));\n    return clamp(f_r, 0.0, 1.0);\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\n\nvec3 btdf(vec3 i, vec3 o, vec3 n, float eta_i, float eta_o, Material mtl)\n{\n    float i_dot_n = dot(i, n);\n    float o_dot_n = dot(o, n);\n\n    vec3 h_t = -normalize(eta_i * i + eta_o * o);\n\n    float i_dot_h = dot(i, h_t);\n    float o_dot_h = dot(o, h_t);\n    float h_dot_n = dot(h_t, n);\n\n    vec3 F = fresnel(mtl.specular, i_dot_h);\n    float G1_i = G1_ggx(i_dot_h, i_dot_n, mtl);\n    float G1_o = G1_ggx(o_dot_h, o_dot_n, mtl);\n    float D = D_ggx(h_dot_n, mtl);\n\n    vec3 f_t = (max(0.0, i_dot_h) * max(0.0, o_dot_h)) / (max(0.0, i_dot_n) * max(0.0, o_dot_n)) *\n        pow(eta_o / eta_i, 2.0) * (1.0 - F) * G1_i * G1_o * D / pow(eta_i * i_dot_h + eta_o * o_dot_h, 2.0);\n    return clamp(f_t, 0.0, 1.0);\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\n\nvoid setup_camera_orbit(\n        float radius,\n        float azimuth,\n        float elevation,\n        out vec3 cam_pos,\n        out vec3 cam_dir,\n        out vec3 cam_up)\n{\n    float cos_az = cos(azimuth);\n    float sin_az = sin(azimuth);\n\n    float cos_el = cos(elevation);\n    float sin_el = sin(elevation);\n\n    cam_pos = radius * vec3(\n            cos_az * cos_el,\n            sin_el,\n            sin_az * cos_el);\n    cam_dir = -normalize(cam_pos);\n    // up = vec3(\n    //          cos(az) * cos(el + PI),\n    //          sin(el + PI),\n    //          sin(az) * cos(el + PI)),\n    // where\n    //          cos(el + PI) == -sin(el)\n    //          sin(el + PI) == cos(el)\n    cam_up = vec3(\n            cos_az * -sin_el,\n            cos_el,\n            sin_az * -sin_el);\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\n\n// ray-plane intersection:\n/* r = ray_pos + t * ray_dir */\n/* dot(n, r) = d */\n/* dot(n, r.pos + t * r.dir) = d */\n/* dot(n, r.pos) + t * dot(n, r.dir) = d */\n/* => t = (d - dot(n, r.pos)) / dot(n, r.dir) */\nbool intersect_ray_plane(vec3 ray_pos, vec3 ray_dir, Plane p, out float t)\n{\n    bool result = false;\n\n    float n_dot_dir = dot(p.normal, ray_dir);\n    if (abs(n_dot_dir) > 0.000001)\n    {\n        float n_dot_pos = dot(p.normal, ray_pos);\n        float t1 = (p.d - n_dot_pos) / n_dot_dir;\n        if (t1 >= 0.0)\n        {\n            t = t1;\n            result = true;\n        }\n    }\n\n    return result;\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\n\n// ray-sphere intersection:\n/* r = ray_pos + t * ray_dir */\n/* ||r - origin|| == radius^2 */\n/* v = r - origin = r.pos + t * r.dir - origin = (r.pos - origin) + t * r.dir = a + t * b */\n/* dot(v, v) = R^2 */\n/* dot(a + t * b, a + t * b) = dot(a,a) + 2*t*dot(a,b) + t*t*dot(b,b) = R^2 */\n/* A = dot(b,b) */\n/* B = 2*dot(a,b) */\n/* C = dot(a,a)-R^2 */\n/* => t = (-B +- sqrt(B*B - 4*A*C)) / (2*A) */\nbool intersect_ray_sphere(vec3 ray_pos, vec3 ray_dir, Sphere s, out float t)\n{\n    bool result = false;\n\n    float A = dot(ray_dir, ray_dir);\n    float B = 2.0 * dot(ray_pos - s.origin, ray_dir);\n    float C = dot(ray_pos - s.origin, ray_pos - s.origin) - s.radius * s.radius;\n    float det = B * B - 4.0 * A * C;\n    if (abs(A) > 0.0 && det >= 0.0)\n    {\n        float t1 = (-B - sqrt(det)) / (2.0 * A);\n        float t2 = (-B + sqrt(det)) / (2.0 * A);\n\n        if (t1 >= 0.0 && t2 >= 0.0)\n        {\n            t = min(t1, t2);\n            result = true;\n        }\n        else if (t1 >= 0.0)\n        {\n            t = t1;\n            result = true;\n        }\n        else if (t2 >= 0.0)\n        {\n            t = t2;\n            result = true;\n        }\n    }\n\n    return result;\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\n\n// NOTE: We use prev_id to identify an object the ray collided with on the previous trace step.\n// In general this approach is wrong, because objects should be allowed to cast shadows on themselves,\n// but in our scene all objects are either convex (spheres) and flat (plane). So, self-shadowing is\n// not possible anyway.\nint raytrace(int prev_id, vec3 ray_pos, vec3 ray_dir, out vec3 pos, out vec3 normal)\n{\n    int id = 0;\n    float t_min = 1000.0;// camera_far;\n    float t;\n\n    if (prev_id != SCENE_PLASTIC_BALL && intersect_ray_sphere(ray_pos, ray_dir, diffuse_ball, t))\n    {\n        t_min = t;\n        pos = ray_pos + t * ray_dir;\n        normal = normalize(pos - diffuse_ball.origin);\n        id = SCENE_PLASTIC_BALL;\n    }\n    if (prev_id != SCENE_GOLDEN_BALL && intersect_ray_sphere(ray_pos, ray_dir, specular_ball, t) && t < t_min)\n    {\n        t_min = t;\n        pos = ray_pos + t * ray_dir;\n        normal = normalize(pos - specular_ball.origin);\n        id = SCENE_GOLDEN_BALL;\n    }\n    if (prev_id != SCENE_GLASS_BALL && intersect_ray_sphere(ray_pos, ray_dir, glass_ball, t) && t < t_min)\n    {\n        t_min = t;\n        pos = ray_pos + t * ray_dir;\n        normal = normalize(pos - glass_ball.origin);\n        id = SCENE_GLASS_BALL;\n    }\n    if (prev_id != SCENE_FLOOR && intersect_ray_plane(ray_pos, ray_dir, checker_floor, t) && t < t_min)\n    {\n        t_min = t;\n        pos = ray_pos + t * ray_dir;\n        normal = checker_floor.normal;\n        id = SCENE_FLOOR;\n    }\n\n    return id;\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    camera_azimuth = 2.0 * PI * (0.5 + iMouse.x / iResolution.x);\n    camera_elevation = 0.5 * PI * (0.25 + iMouse.y / iResolution.y);\n\n    setup_camera_orbit(\n        camera_orbit_radius,\n        camera_azimuth,\n        camera_elevation,\n        camera_pos,\n        camera_dir,\n        camera_up);\n    vec3 camera_right = cross(camera_up, camera_dir);\n\n    // NxN anti-aliasing.\n    vec3 pixel_radiance = vec3(0.0, 0.0, 0.0);\n    for (int aa_x = 0; aa_x < AA_COUNT; ++aa_x)\n    {\n        for (int aa_y = 0; aa_y < AA_COUNT; ++aa_y)\n        {\n            vec2 aa_sample_offset = vec2(aa_x, aa_y) / float(AA_COUNT);\n            vec2 uv = (fragCoord.xy + aa_sample_offset) / iResolution.xy;\n            // uv = 2.0 * uv - 1.0;\n            // uv.x *= camera_aspect_ratio;\n\n            vec3 ray_pos = camera_pos;\n            vec3 ray_far = camera_pos +\n                camera_far * camera_dir +\n                camera_far_half_width * (-1.0 + 2.0 * uv.x) * camera_right +\n                camera_far_half_height * (-1.0 + 2.0 * uv.y) * camera_up;\n            vec3 ray_dir = normalize(ray_far - ray_pos);\n\n            vec3 radiance = vec3(0.0, 0.0, 0.0);\n            vec3 L_i = light_radiance;\n\n            int id = 0;\n            for (int bounce = 0; bounce < MAX_BOUNCE_COUNT; ++bounce)\n            {\n                vec3 pos, n;\n                id = raytrace(id, ray_pos, ray_dir, pos, n);\n\n                if (id > 0)\n                {\n                    Material mtl;\n                    get_material(pos, id, mtl);\n\n                    vec3 l = normalize(light_pos - pos);\n                    /* vec3 v = normalize(camera_pos - pos); */\n                    vec3 i = -ray_dir;\n\n                    // TODO\n#if ENABLE_SHADOWS\n                    vec3 dummy_pos, dummy_normal;\n                    int shadow_id = raytrace(id, pos, l, dummy_pos, dummy_normal);\n                    float shadow = (shadow_id == 0) ? 1.0 : 0.0;\n#else\n                    float shadow = 1.0;\n#endif\n\n                    if (mtl.scatter_mask == SCATTER_DIFFUSE)\n                    {\n                        radiance += L_i * shadow * PI * max(0.0, dot(l, n)) * diffuse_brdf(i, l, n, mtl);\n                        L_i = vec3(0.0, 0.0, 0.0);\n\n                        break;\n                    }\n                    else if (mtl.scatter_mask == SCATTER_SPECULAR)\n                    {\n                        radiance += L_i * shadow * PI * max(0.0, dot(l, n)) * specular_brdf(i, l, n, mtl);\n\n                        vec3 m = n;\n                        vec3 R_theta = fresnel(mtl.specular, dot(i, m));\n                        R_theta = clamp(R_theta, 0.0, 1.0);\n\n                        bvec3 flags = greaterThan(R_theta, vec3(0.0, 0.0, 0.0));\n                        if (any(flags))\n                        {\n                            vec3 o_r = 2.0 * max(0.0, dot(i, m)) * m - i;\n                            vec3 f_r = specular_brdf(i, o_r, m, mtl);\n\n                            L_i *= R_theta;//f_r;\n                            ray_pos = pos;\n                            ray_dir = o_r;\n                        }\n                    }\n                    else if (mtl.scatter_mask == SCATTER_TRANSPARENT)\n                    {\n                        float eta_i = eta_air;\n                        float eta_o = mtl.eta;\n                        if (dot(i, n) <= 0.0) // Ray exiting the object?\n                        {\n                            float eta_i = mtl.eta;\n                            float eta_o = eta_air;\n                            n = -n;\n                        }\n\n                        radiance += L_i * shadow * PI * max(0.0, dot(l, n)) * btdf(i, l, n, eta_i, eta_o, mtl);\n                        id = 0;\n\n                        vec3 m = n;\n                        vec3 R_theta = fresnel(mtl.specular, dot(i, m));\n                        R_theta = clamp(R_theta, 0.0, 1.0);\n\n                        bvec3 flags = greaterThan(vec3(1.0, 1.0, 1.0) - R_theta, vec3(0.0, 0.0, 0.0));\n                        if (any(flags))\n                        {\n                            float c = dot(i, m);\n                            float eta = eta_i / eta_o;\n\n                            vec3 o_t = (eta * c - sign(dot(i, n)) * sqrt(1.0 + eta * (c * c - 1.0))) * m - eta * i;\n                            vec3 f_t = btdf(i, o_t, m, eta_i, eta_o, mtl);\n\n                            L_i *= vec3(1.0, 1.0, 1.0) - R_theta;//f_t;\n                            ray_pos = pos + 0.000001 * o_t;\n                            ray_dir = o_t;\n                            id = 0;\n                        }\n                    }\n                }\n                else\n                {\n                    break;\n                }\n            }\n\n            pixel_radiance += radiance;\n        }\n    }\n\n    fragColor.rgb = pixel_radiance / float(AA_COUNT * AA_COUNT);\n\n    // TODO: Tonemapping.\n\n    // Linear to gamma (sRGB) color space conversion (approximated).\n    float inv_gamma = 1.0 / 2.2;\n    fragColor.rgb = pow(fragColor.rgb, vec3(inv_gamma, inv_gamma, inv_gamma));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtsSWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2135, 2135, 2192, 2192, 3837], [3941, 3968, 4006, 4006, 4072]], "test": "valid"}
{"id": "XtsXDM", "name": "Funky Mandelbrot", "author": "Wicpar", "description": "a Mandelbrot shader, if you zoom enough, you may visualize floating point errors, and what it is like to be under LSD", "tags": ["procedural", "mandelbrot", "funky", "lsd"], "likes": 2, "viewed": 111, "published": "Public", "date": "1437149349", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int iter = 1000;\nfloat scale = 3.;\nvec2 center = vec2(1.001105,0.300717);\n\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    scale = 1./(pow(iTime,iTime/20.));\n    vec2 z, c;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    c.x = 1.3333 * (uv.x - 0.5) * scale - center.x;\n    c.y = (uv.y - 0.5) * scale - center.y;\n    z = c;\n    int it;\n    for(int i = 0; i<iter; i++) {\n        float x = (z.x * z.x - z.y * z.y) + c.x;\n        float y = (z.y * z.x + z.x * z.y) + c.y;\n\n        if((x * x + y * y) > 4.0) break;\n        z.x = x;\n        z.y = y;\n        it = i;\n    }\n\t fragColor = vec4(hsv2rgb_smooth(vec3( float(it)/10., 1.0,1. )),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtsXDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 115, 115, 293], [295, 295, 352, 352, 872]], "test": "valid"}
{"id": "XtsXRB", "name": "Raymarch Visualizer", "author": "AlainGalvan", "description": "A quick tool I built to help visualize raymarching based off this presentation from iq. (page 31)\nhttp://iquilezles.org/www/material/nvscene2008/rwwtt.pdf\npurple means more iterations.\nForked from this shadertoy: https://www.shadertoy.com/view/lslSRf", "tags": ["raymarch", "visualize"], "likes": 3, "viewed": 336, "published": "Public", "date": "1437608382", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Raymarching Visualizer\n//By Alain Galvan - Based of a presentation by iq.\n\n// **************************************************************************\n// CONSTANTS\n\n#define PI 3.14159\n#define TWO_PI 6.28318\n#define PI_OVER_TWO 1.570796\n#define ONE_OVER_PI 0.318310\n#define GR   1.61803398\n\n#define SMALL_FLOAT 0.0001\n#define BIG_FLOAT 1000000.\n\n// **************************************************************************\n// GLOBALS\n\nvec3  g_camPointAt   = vec3(0.);\nvec3  g_camOrigin    = vec3(0.);\nfloat g_time         = 0.;\nvec3  g_ldir         = vec3(.8, 1., 0.8);\n\n// **************************************************************************\n// UTILITIES\n\n// Rotate the input point around the y-axis by the angle given as a\n// cos(angle) and sin(angle) argument.  There are many times where  I want to\n// reuse the same angle on different points, so why do the heavy trig twice.\n// Range of outputs := ([-1.,-1.,-1.] -> [1.,1.,1.])\n\nvec3 rotateAroundYAxis( vec3 point, float cosangle, float sinangle )\n{\n    return vec3(point.x * cosangle  + point.z * sinangle,\n        point.y,\n        point.x * -sinangle + point.z * cosangle);\n}\n\n// Rotate the input point around the x-axis by the angle given as a\n// cos(angle) and sin(angle) argument.  There are many times where  I want to\n// reuse the same angle on different points, so why do the  heavy trig twice.\n// Range of outputs := ([-1.,-1.,-1.] -> [1.,1.,1.])\n\nvec3 rotateAroundXAxis( vec3 point, float cosangle, float sinangle )\n{\n    return vec3(point.x,\n        point.y * cosangle - point.z * sinangle,\n        point.y * sinangle + point.z * cosangle);\n}\n\n// convert a 3d point to two polar coordinates.\n// First coordinate is elevation angle (angle from the plane going through x+z)\n// Second coordinate is azimuth (rotation around the y axis)\n// Range of outputs - ([PI/2, -PI/2], [-PI, PI])\nvec2 cartesianToPolar( vec3 p ) \n{    \n    return vec2(PI/2. - acos(p.y / length(p)), atan(p.z, p.x));\n}\n\n// **************************************************************************\n// DISTANCE FIELDS\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// **************************************************************************\n// SCENE MARCHING\n\n\nvec2 scenedf( vec3 p )\n{\n    vec2 obj =  vec2(sdBox(p, vec3(1.) ), 1.);\n    return obj;\n}\n\n#define DISTMARCH_STEPS 32\n#define DISTMARCH_MAXDIST 30.\n\n\nvec2 distmarch( vec3 ro, vec3 rd, float maxd )\n{\n\n    float epsilon = 0.001;\n    float dist = 10. * epsilon;\n    float t = 0.;\n    float material = 0.;\n    float iterations = 0.;\n    \n    for (int i=0; i < DISTMARCH_STEPS; i++) \n    {\n        iterations = float(i);\n        if ( abs(dist) < epsilon || t > maxd || (float(i) > mod(8. * (iTime+15.), 30.))) break;\n        // advance the distance of the last lookup\n        t += dist;\n        vec2 dfresult = scenedf( ro + t * rd );\n        dist = dfresult.x;\n    }\n\n    if( t > maxd ) iterations = -1.0; \n    return vec2( t, iterations );\n}\n\n\n\n// **************************************************************************\n// CAMERA & GLOBALS\n\nstruct CameraData\n{\n    vec3 origin;\n    vec3 dir;\n    vec2 st;\n};\n\nCameraData setupCamera( in vec2 fragCoord )\n{\n\n    // aspect ratio\n    float invar = iResolution.y / iResolution.x;\n    vec2 st = fragCoord.xy / iResolution.xy - .5;\n    st.y *= invar;\n\n    // calculate the ray origin and ray direction that represents\n    // mapping the image plane towards the scene\n    vec3 iu = vec3(0., 1., 0.);\n\n    vec3 iz = normalize( g_camPointAt - g_camOrigin );\n    vec3 ix = normalize( cross(iz, iu) );\n    vec3 iy = cross(ix, iz);\n\n    vec3 dir = normalize( st.x*ix + st.y*iy + .7 * iz );\n\n    return CameraData(g_camOrigin, dir, st);\n\n}\n\nvoid animateGlobals()\n{\n    // remap the mouse click ([-1, 1], [-1/ar, 1/ar])\n    vec2 click = iMouse.xy / iResolution.xx;    \n    click = 2.0 * click - 1.0;  \n    \n    g_time = .8 * iTime - 10.;\n\n    // camera position\n    g_camOrigin = vec3(4.5, 0.0, 4.5);\n    \n    float rotx    = -1. * PI * (.5 * click.y + .45) + .05 * g_time;\n    float cosrotx = cos(rotx);\n    float sinrotx = sin(rotx);\n    \n    float roty    = TWO_PI * click.x + .05 * g_time;\n    float cosroty = cos(roty);\n    float sinroty = sin(roty);\n\n    // Rotate the camera around the origin\n    g_camOrigin = rotateAroundXAxis(g_camOrigin, cosrotx, sinrotx);\n    g_camOrigin = rotateAroundYAxis(g_camOrigin, cosroty, sinroty);\n\n    g_camPointAt   = vec3(0., 0., 0.);\n    \n    float lroty    = .9 * g_time;\n    float coslroty = cos(lroty);\n    float sinlroty = sin(lroty);\n\n    // Rotate the light around the origin\n    g_ldir = rotateAroundYAxis(g_ldir, coslroty, sinlroty);\n\n}\n\n// **************************************************************************\n// Visualize Functions (Mind the mess!)\n\n/*\n * Returns a component based on luminocity p, saturation q, and hue h.\n */\nfloat hueToRgb(float p, float q, float h)\n{\n    if ((h * 6.) < 1.)\n        return p + (q - p) * h * 6.;\n    else if ((h * 2.) < 1.)\n        return q;\n    else if ((h * 3.) < 2.)\n        return p + (q - p) * ((2. / 3.) - h) * 6.;\n    else\n        return p;\n}\n/*\n * Returns a vec4 with components r,g,b,a, based off vec4 col with components h,s,l,a.\n */\nvec3 hslToRgb(vec3 col)\n{\n    vec3 outColor = vec3(0.);\n    float p, q, tr, tg, tb;\n    \n    if (col.b <= .5)\n        q = col.b * (1. + col.g);\n    else\n        q = col.b + col.g - (col.b * col.g);\n\n    p = 2. * col.b - q;\n    tr = col.r + (1. / 3.);\n    tg = col.r;\n    tb = col.r - (1. / 3.);\n\n    outColor.r = hueToRgb(p, q, tr);\n    outColor.g = hueToRgb(p, q, tg);\n    outColor.b = hueToRgb(p, q, tb);\n\n    return outColor;\n}\n\n//https://www.shadertoy.com/view/WlfXRN\nvec3 viridis(float t) {\n\n    const vec3 c0 = vec3(0.2777273272234177, 0.005407344544966578, 0.3340998053353061);\n    const vec3 c1 = vec3(0.1050930431085774, 1.404613529898575, 1.384590162594685);\n    const vec3 c2 = vec3(-0.3308618287255563, 0.214847559468213, 0.09509516302823659);\n    const vec3 c3 = vec3(-4.634230498983486, -5.799100973351585, -19.33244095627987);\n    const vec3 c4 = vec3(6.228269936347081, 14.17993336680509, 56.69055260068105);\n    const vec3 c5 = vec3(4.776384997670288, -13.74514537774601, -65.35303263337234);\n    const vec3 c6 = vec3(-5.435455855934631, 4.645852612178535, 26.3124352495832);\n\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n\n}\n\n\n// **************************************************************************\n// MAIN\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // Animate globals\n    animateGlobals();\n\n    // Setup Camera\n    CameraData cam = setupCamera( fragCoord );\n\n    // Scene Marching\n    vec2 scenemarch = distmarch( cam.origin, cam.dir, DISTMARCH_MAXDIST );\n    \n    // Visualizer\n    vec3 scenecol = vec3(0.);\n    \n    if (scenemarch.y > SMALL_FLOAT)\n        scenecol = viridis(scenemarch.y / float(DISTMARCH_STEPS));\n\n    fragColor.rgb = scenecol;\n    fragColor.a = 1.;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtsXRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[944, 944, 1014, 1014, 1142], [1422, 1422, 1492, 1492, 1618], [1620, 1858, 1892, 1892, 1962], [2062, 2062, 2093, 2093, 2180], [2280, 2280, 2304, 2304, 2369], [3189, 3189, 3234, 3255, 3755], [3757, 3757, 3780, 3834, 4701], [4822, 4900, 4943, 4943, 5157], [5158, 5252, 5277, 5277, 5682], [5684, 5724, 5747, 5747, 6403], [6493, 6493, 6550, 6576, 6980]], "test": "valid"}
{"id": "XtXXzj", "name": "another julia fractal", "author": "kaminate", "description": "All criticism appreciated, no matter what", "tags": ["juliafractal"], "likes": 4, "viewed": 245, "published": "Public", "date": "1437790043", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// following mandelbrot tutorial at\n// http://warp.povusers.org/Mandelbrot/\n\n//http://www.iquilezles.org/www/articles/palettes/palettes.htm\n#define GetColor( a, b, c, d, t)   a + b * cos( 6.28 * ( c * t + d ) )\n\n#define JULIA\n\nvoid mainImage( out vec4 fragColor, vec2 uv )\n{\n  float t = ( cos( iTime / 2. ) + 1.0 ) / 2.0;\n  \n  vec2 R = iResolution.xy;\n  uv /= R;\n  float aspect = R.x / R.y;\n\n  vec2 vsPos = ( uv * 2. - 1. ) / aspect;\n\n  float scale = mix( .2, .3, t );\n  vec2 camPos = vec2( 0 );\n  float camRot = iTime / 7.;\n  float c = cos( camRot );\n  float s = sin( camRot );\n  mat3 cam = mat3(\n      scale * vec3( c, -s , 0 ),\n      scale * vec3( s, c , 0 ),\n      vec3( camPos, 1. ) );\n\n  // z starts out as the pixel coordinate\n  vec2 z0, z = ( cam * vec3( vsPos, 1.0 ) ).xy;\n\n#ifdef JULIA\n  z0 = vec2( 0., mix( 0.8, 0.81, t ) );\n#else\n  // for mandelbrot, z0 is unique for every pixel\n  z0 = z;\n#endif\n\n  float iterPercent = 1.;\n  const float maxIters = 100.;\n  for( float n = 0.; n < maxIters; ++n )\n  {\n    if( dot( z, z ) > 4. )\n    {\n      iterPercent = n / maxIters;\n      break;\n    }\n    z = z0 + vec2( z.x*z.x - z.y*z.y, 2.0 * z.x * z.y );\n  }\n\n  fragColor = GetColor( .5, .5, 1.,\n      vec4( .0, .3, 0.6, 1. ),\n      iterPercent );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtXXzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[228, 228, 275, 275, 1250]], "test": "valid"}
{"id": "XtXXzS", "name": "Light, Dark and Red", "author": "predatiti", "description": "Test !!! How big is number of sample on your PC ? For my : 15 fps - 32 sample - Nvidia GTX 560", "tags": ["pathtracing"], "likes": 13, "viewed": 508, "published": "Public", "date": "1437899248", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float t = 32.0;//nr. sample per pixel\n\n#define pi acos(-1.0)\n#define pi2 pi/2.0\n\nstruct Sphere\n{\n\tvec4 center_radius;\n\tint idmaterial;\n};\n\nstruct Box\n{\n    vec3 min, max;\n   int idmaterial;\n};\n    \nstruct Cylinder \n{\n    vec3 c;\n    float r,h;\n    int idmaterial;\n};\n\nBox box0;\nSphere sfere[4];\nBox boxe[15];\nCylinder cylinder[4];\n//Material material[6];\n\nvec3 light = vec3(0.0, 0.0, 0.0);\nvec3 cub, lcub, nrm, crm;\nvec2 uvCoord;\nvec2 p,rv2;\nvec2 randv2;\nfloat side = 1.0;\nfloat time;// = iTime;\nfloat f0, f1,f2,f3;\n\nvec2 clight = vec2(-1.6,0.1);//vec2(sin(iTime*0.5)*1.9-0.0,0.1);\nvec2 clight1 = vec2(1.6,0.1);\n\nvec2 rand2(){// implementation derived from one found at: lumina.sourceforge.net/Tutorials/Noise.html\n   randv2+=vec2(1.0,1.0);\n   return vec2(fract(sin(dot(randv2.xy ,vec2(12.9898,78.233))) * 43758.5453),\n      \t\t   fract(cos(dot(randv2.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nvec3 CosineWeightedSampleHemisphere ( vec3 normal, vec2 rnd )\n{\n   //rnd = vec2(rand(vec3(12.9898, 78.233, 151.7182), seed),rand(vec3(63.7264, 10.873, 623.6736), seed));\n   float phi = acos( sqrt(1.0 - rnd.x)) ;\n   float theta = 2.0 * 3.14 * rnd.y ;\n\n   vec3 sdir = cross(normal, (abs(normal.x) < 0.5001) ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 1.0, 0.0));\n   vec3 tdir = cross(normal, sdir);\n\n   return normalize(phi * cos(theta) * sdir + phi * sin(theta) * tdir + sqrt(1.0 - rnd.x) * normal);\n}\n\nvec3 cosPowDir(vec3  dir, float power) \n{//creates a biased random sample\n   vec2 r=rand2()*vec2(6.2831853,1.0);\n   vec3 sdir=cross(dir,((abs(dir.x)<0.5)?vec3(1.0,0.0,0.0):vec3(0.0,1.0,0.0)));\n   vec3 tdir=cross(dir,sdir); \n   r.y=pow(r.y,0.01/power);\n   float oneminus = sqrt(1.0-r.y*r.y);\n   return cos(r.x)*oneminus*sdir + sin(r.x)*oneminus*tdir + r.y*dir;\n}\n\nvec2 intersectCube(vec3 origin, vec3 ray, Box cube) {      \n   vec3   tMin = (cube.min - origin) / ray;      \n   vec3   tMax = (cube.max - origin) / ray;      \n   vec3     t1 = min(tMin, tMax);      \n   vec3     t2 = max(tMin, tMax);\n   float tNear = max(max(t1.x, t1.y), t1.z);\n   float  tFar = min(min(t2.x, t2.y), t2.z);\n   return vec2(tNear, tFar);   \n}\n\nvec3 normalForCube(vec3 hit, Box cube)\n{  \n   if(hit.x < cube.min.x + 0.0001) return vec3(-1.0, 0.0, 0.0);   \n   else if(hit.x > cube.max.x - 0.0001) return vec3( 1.0, 0.0, 0.0);   \n   else if(hit.y < cube.min.y + 0.0001) return vec3(0.0, -1.0, 0.0);   \n   else if(hit.y > cube.max.y - 0.0001) return vec3(0.0, 1.0, 0.0);      \n   else if(hit.z < cube.min.z + 0.0001) return vec3(0.0, 0.0, -1.0);   \n   else return vec3(0.0, 0.0, 1.0);   \n}\n\nfloat intersectSphere(vec3 origin, vec3 ray, Sphere s) {   \n   vec3 toSphere = origin - s.center_radius.xyz;      \n   float sphereRadius = s.center_radius.w;\n   float a = dot(ray, ray);      \n   float b = dot(toSphere, ray);   \n   float c = dot(toSphere, toSphere) - sphereRadius*sphereRadius;   \n   float discriminant = b*b - a*c;      \n   if(discriminant > 0.0) {      \n      float t = (-b - sqrt(discriminant)) ;   \n      if(t > 0.0) return t;      \n   }   \n   return 10000.0;   \n}  \n\nvec3 normalForSphere(vec3 hit, Sphere s) {   \n   return (hit - s.center_radius.xyz) / s.center_radius.w;   \n} \n\nfloat iCylinder(vec3 ro, vec3 rd, Cylinder cylinder)\n{\n\tvec3  rc = ro - cylinder.c;\n    float a = dot( rd.xz, rd.xz );\n\tfloat b = dot( rc.xz, rd.xz );\n\tfloat c = dot( rc.xz, rc.xz ) - cylinder.r*cylinder.r;//0.249;\n\tfloat d = b*b - a*c;\n\tif( d>=0.0 )\n\t{\n\t\t// cylinder\t\t\t\n\t\tfloat s = (-b - sqrt( d ))/a;\n        float hy = ro.y-cylinder.c.y+s*rd.y;\n\t\tif( s>0.0 && hy<cylinder.h && hy>-cylinder.h )\n\t\t{\n\t\t\treturn s;\n\t\t}\n\t\t// cap\t\t\t\n\t\t/*s = (cylinder.h - ro.y+cylinder.c.y)/rd.y;\n\t\tif( s>0.0 && (s*s*a+2.0*s*b+c)<0.0 )\n\t\t{\n\t\t\treturn s;\n\t\t}*/\n\t}\n    return 100000.0;\n}\n\nvec3 normalforCylinder(vec3 hit,Cylinder cylinder)\n{\n    vec3 nor;\n\tnor.xz = hit.xz - cylinder.c.xz;\n    nor.y = 0.0;\n    nor = nor/cylinder.r;\n    //nor.y = 1.0*sign(hit.y-cylinder.c.y);\n    return nor;\n}\n\nvoid initscene()\n{\n    box0.min = vec3(-3.0, -1.2, -2.0);//room\n   \tbox0.max = vec3( 3.0,  1.2,  2.0);\n    \n    light = vec3(cos(time *0.0)*1.65-0.5, sin(time*0.0)*0.65+0.7, sin(time*0.5)*1.65);\n\n    float h = sin(time*3.0)*0.03;\n    float sinr = sin(time)*0.5; float cosr = cos(time)*0.5;\n    sfere[0].center_radius = vec4(-2.8, -0.49, 0.0,    0.16);//rosu\n   \tsfere[1].center_radius = vec4(-2.8, -0.24, 0.0,    0.10);//verde\n   \tsfere[2].center_radius = vec4(-2.8, -0.10, 0.0,    0.04);//albastru\n    sfere[3].center_radius = vec4(clight, 1.8,  0.1);//albastru\n    \n    vec3 center = vec3(0.0,0.0,0.0); \n    cylinder[0].c = vec3( -2.7,-0.3, 0.5) + center;\n    cylinder[0].r = 0.04;\n    cylinder[0].h = 0.4;\n    \n    cylinder[1].c = vec3(-2.7,-0.3,-0.5) + center;\n    cylinder[1].r = 0.04;\n    cylinder[1].h = 0.4;\n    \n    cylinder[2].c = vec3(-0.55,0.0, 0.25) + center;\n    cylinder[2].r = 0.04;\n    cylinder[2].h = 0.4;\n    \n    cylinder[3].c = vec3(-0.55,0.0,-0.25) + center;\n    cylinder[3].r = 0.04;\n    cylinder[3].h = 0.4;\n\n   \tcenter = vec3(-0.0,-0.0, 0.0);\n    cub = vec3(0.0, 0.0, 1.37) + center;//perete dreapta\n    lcub = vec3(0.03, 1.3, 0.65);    \n   \tboxe[0].min = cub - lcub;\n   \tboxe[0].max = cub + lcub;\n    \n   \tcub = vec3(-0.0, 0.0, -1.37) + center;//perete stanga\n   \tlcub = vec3(0.03, 1.3, -0.65);\n   \tboxe[1].min = cub - lcub;\n   \tboxe[1].max = cub + lcub;\n    \n   \tcub = vec3(0.0, 1.0, 0.0) + center;//perete sus\n    lcub = vec3(0.03, 0.2, 0.8);\n   \tboxe[2].min = cub - lcub;\n   \tboxe[2].max = cub + lcub;   \n    \n   \tcub = vec3( -2.8, -0.8, 0.5) + center;//----------\n   \tlcub = vec3(0.2, 0.15, 1.3);    \n   \tboxe[3].min = cub - lcub;\n   \tboxe[3].max = cub + lcub;\n    \n   \tcub = vec3( -2.8, 0.2, -0.5) + center;//----------\n   \tlcub = vec3(0.2, 0.15, 1.3); \n   \tboxe[4].min = cub - lcub;\n   \tboxe[4].max = cub + lcub;\n/*\n   \tcub = vec3(0.41, 0.0, 0.06) + center;//maner dreapta\n   \tlcub = vec3(0.021, 0.1, 0.01);\n   \tboxe[5].min = cub - lcub;\n   \tboxe[5].max = cub + lcub;\n\n   \tcub = vec3(0.41, 0.0, -0.06) + center;//maner stanga\n   \tlcub = vec3(0.021, 0.1, 0.01);\n   \tboxe[6].min = cub - lcub;\n   \tboxe[6].max = cub + lcub;\n\n//dulap\n\n//birou\n\tcenter = vec3(0.8,-0.8,-1.6);\n   \tcub = vec3( 0.0, 0.4, 0.0) + center;//tablie\n   \tlcub = vec3(0.65, 0.015, 0.35);\n   \tboxe[7].min = cub - lcub;\n   \tboxe[7].max = cub + lcub;\n\n//scaun\n   \tcub = vec3(-0.0, 0.1, 0.5) + center;//tablie\n   \tlcub = vec3(0.25, 0.015, 0.25);\n   \tboxe[8].min = cub - lcub;\n   \tboxe[8].max = cub + lcub;\n\n   \tcub = vec3(-0.22, -0.15, 0.28) + center;//picior stanga fata\n   \tlcub = vec3(0.03, 0.25, 0.03);\n   \tboxe[9].min = cub - lcub;\n   \tboxe[9].max = cub + lcub;\n\n   \tcub = vec3( 0.22, -0.15, 0.28) + center;//picior dreapta fata\n   \tlcub = vec3(0.03, 0.25, 0.03);\n   \tboxe[10].min = cub - lcub;\n   \tboxe[10].max = cub + lcub;\n\n   \tcub = vec3( 0.22, 0.2,  0.72) + center;//picior dreapta spate\n   \tlcub = vec3(0.03, 0.60, 0.03);\n   \tboxe[11].min = cub - lcub;\n   \tboxe[11].max = cub + lcub;\n\n   \tcub = vec3(-0.22, 0.2,  0.72) + center;//picior stanga spate\n   \tlcub = vec3(0.03, 0.60, 0.03);\n   \tboxe[12].min = cub - lcub;\n   \tboxe[12].max = cub + lcub;\n\n   \tcub = vec3(-0.0, 0.6,  0.74) + center;//spatar\n   \tlcub = vec3(0.25, 0.10, 0.01);\n   \tboxe[13].min = cub - lcub;\n   \tboxe[13].max = cub + lcub;\n    \n    cub = vec3(-1.6,-0.87,  1.9) ;//calorifer\n   \tlcub = vec3(0.55, 0.3, 0.06);\n   \tboxe[14].min = cub - lcub;\n   \tboxe[14].max = cub + lcub;\n*/\n}\n\nvoid intersectscene(vec3 ro, vec3 rd, inout float t, inout int i, bool bl)\n{\n    //float tSphere6 = intersectSphere(ro, rd, sfere[3]);\n    //if(tSphere6 < t ) { t = tSphere6;i=6;}\n    //if(tSphere6 < t && bl) { t = tSphere6;i=6;}\n\n   \tfloat tSphere = intersectSphere(ro, rd, sfere[0]);\n    if(tSphere < t) { t = tSphere;i=0;}\n   \ttSphere = intersectSphere(ro, rd, sfere[1]);\n    if(tSphere < t) { t = tSphere;i=1;}\n   \ttSphere = intersectSphere(ro, rd, sfere[2]);\n    if(tSphere < t) { t = tSphere;i=2;}\n\t\n    \n    \n\tfloat tcyl = iCylinder(ro, rd, cylinder[0]);\n    if(tcyl<t) {t = tcyl; i = 10;}\n    tcyl = iCylinder(ro, rd, cylinder[1]);\n    if(tcyl<t) {t = tcyl; i = 11;}\n    tcyl = iCylinder(ro, rd, cylinder[2]);\n    /*if(tcyl<t) {t = tcyl; i = 12;}\n    tcyl = iCylinder(ro, rd, cylinder[3]);\n\tif(tcyl<t) {t = tcyl; i = 13;}\n    */\n\tvec2 tbox = intersectCube(ro, rd, boxe[0]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 20;}\n    tbox = intersectCube(ro, rd, boxe[1]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 21;}\n    tbox = intersectCube(ro, rd, boxe[2]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 22;}\n    tbox = intersectCube(ro, rd, boxe[3]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 23;}\n    tbox = intersectCube(ro, rd, boxe[4]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 24;}\n\n\n    //tbox = intersectCube(ro, rd, boxe[7]); \n    //if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 27;}\n    /*tbox = intersectCube(ro, rd, boxe[8]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 28;}\n    tbox = intersectCube(ro, rd, boxe[9]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 29;}\n    tbox = intersectCube(ro, rd, boxe[10]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 30;}\n    tbox = intersectCube(ro, rd, boxe[11]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 31;}\n    tbox = intersectCube(ro, rd, boxe[12]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 32;}\n    tbox = intersectCube(ro, rd, boxe[13]); \n\tif(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 33;}*/\n    \n    //tbox = intersectCube(ro, rd, boxe[14]); \n    //if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 34;}\n}\n\nvoid ColorAndNormal(vec3 hit, inout vec4 mcol, inout vec3 normal, vec2 tRoom, inout vec2 mref, inout float t, const int id)\n{\n\tif(t == tRoom.y)\n\t{            \n\t\tmref = vec2(0.0,0.0);\n        normal =-normalForCube(hit, box0);    \n        if(normal.z<0.0)\n\t\t{\n         \t//clight = vec2(-1.6,0.1);//vec2(sin(iTime*0.5)*1.9-0.0,0.1);\n            if(\tall(lessThanEqual(hit.xy,vec2(-0.05,0.6)+clight)) &&\n               \tall(greaterThanEqual(hit.xy,vec2(-0.7,-0.6)+clight)) ||\n               \tall(lessThanEqual(hit.xy,vec2(0.7,0.6)+clight)) &&\n               \tall(greaterThanEqual(hit.xy,vec2(0.05,-0.6)+clight)))\n               \tmcol = vec4(vec3(1.1),2.0);\n                \n             /*if(\tall(lessThanEqual(hit.xy,vec2(-0.05,0.6)+clight1)) &&\n               \tall(greaterThanEqual(hit.xy,vec2(-0.7,-0.6)+clight1)) ||\n               \tall(lessThanEqual(hit.xy,vec2(0.7,0.6)+clight1)) &&\n               \tall(greaterThanEqual(hit.xy,vec2(0.05,-0.6)+clight1)))\n               \tmcol = vec4(vec3(1.1),2.0);\n\t\t\t}*/\n        }\n\t}     \n\telse   \n\t{\n        \t if(id==0) {normal = normalForSphere(hit, sfere[0]);mcol.xyz = vec3(1.0,0.0,0.0);}\n        else if(id==1) {normal = normalForSphere(hit, sfere[1]);mcol.xyz = vec3(1.0,0.0,0.0);}\n        else if(id==2) {normal = normalForSphere(hit, sfere[2]);mcol.xyz = vec3(1.0,0.0,0.0);}\n        //else if(id==6) {normal = normalForSphere(hit, sfere[3]);}\n    \telse if(id==10) {normal = normalforCylinder(hit, cylinder[0]);}\n        else if(id==11) {normal = normalforCylinder(hit, cylinder[1]);}\n        //else if(id==12) {normal = normalforCylinder(hit, cylinder[2]);}\n        //else if(id==13) {normal = normalforCylinder(hit, cylinder[3]);}\n        else if(id==20) {normal = normalForCube(hit, boxe[0]);}\n        else if(id==21) {normal = normalForCube(hit, boxe[1]);}\n        else if(id==22) {normal = normalForCube(hit, boxe[2]);}\n        else if(id==23) {normal = normalForCube(hit, boxe[3]);}\n        else if(id==24) {normal = normalForCube(hit, boxe[4]);}\n        /*else if(id==25) {normal = normalForCube(hit, boxe[5]);}\n        else if(id==26) {normal = normalForCube(hit, boxe[6]);}\n        else if(id==27) {normal = normalForCube(hit, boxe[7]);}\n        else if(id==28) {normal = normalForCube(hit, boxe[8]);}\n        else if(id==29) {normal = normalForCube(hit, boxe[9]);}\n        else if(id==30) {normal = normalForCube(hit, boxe[10]);}\n        else if(id==31) {normal = normalForCube(hit, boxe[11]);}\n        else if(id==32) {normal = normalForCube(hit, boxe[12]);}\n        else if(id==33) {normal = normalForCube(hit, boxe[13]);}\n        else if(id==34) {normal = normalForCube(hit, boxe[14]);}*/\n        \n       \tif(id>-1 && id<10) //sfere\n        {\n            mcol.xyz = vec3(1.0, 0.0, 0.0);\n            mref = vec2(0.0,0.0);// transparent, glossines\n        }\n\t\tif(id>9 && id<20)//cilindrii\n        {\n\t\t\tmcol.xyz = vec3(1.0);\n            mref = vec2(1.0,0.0);// transparent, glossines\n        }\n        \n       \tif(id>22)//suporti gri\n        {\n\t\t\tmcol.xyz = vec3(0.2);\n            mref = vec2(0.0,0.0);// transparent, glossines\n        }\n        \n       /* if(id==34)//calorifer\n        {\n            mcol.xyz = vec3(sin(hit.x*59.0)+2.0-0.2);\n            mref = vec2(0.0,0.0);\n        }*/\n    }  \n}\n\nvec3 directLight(vec3 hit, vec3 normal, vec3 lightf, vec3 cl, inout bool i)\n{\n   vec3 color = vec3(0.0);\n   int id = -1;\n   i = false;\n    \n   vec3 L = normalize(lightf-hit);;//(toLight*rsqrt(sqdist);\n   float diffuse = clamp(dot(normal,L),0.0,1.0);\n \n   if(diffuse>0.0)\n   {\n      float ldist =distance(lightf,hit);\n      float sh = 1000.0;\n      intersectscene(hit + normal * 0.0001, L, sh, id, false);           \n      if(sh>ldist)\n         {color += cl * (diffuse/(ldist))*0.32; i = true;}\n   }\n   return color;\n}\n\nvec3 getColor(vec3 ro, vec3 rd)\n{\n    vec3 color = vec3(0.0);\n    vec3 col = vec3(1.0);\n    int id=-1;\n    int tm = -1;\n    \n    for(int i=0; i<6; i++)\n    {\n    \tfloat t = 10000.0; //seed++;\n\t\t\n   \t\tvec2 tRoom = intersectCube(ro, rd, box0);          \n   \t\tif(tRoom.x < tRoom.y)   t = tRoom.y; \n    \n    \tintersectscene(ro, rd, t, id, true);\n    \n    \tvec3 hit = ro + rd * t;        \n\t\tvec4 mcol = vec4(vec3(0.99),0.0);\n    \tvec3 normal; \n    \tvec2 mref = vec2(0.0);\n      \n    \tColorAndNormal(hit, mcol, normal, tRoom, mref, t, id);\n    \thit = hit + normal * 0.0001;\n         \n        vec2 rnd = rand2();\n        //rnd.x = 1.0/6.0 * ( float(i) + rnd.x );\n        col *= mcol.xyz;\n        if(mcol.w>0.0) \n        {\n            color += col*mcol.xyz*mcol.w ;\n            break;\n        }\n\t\t\n        if(mref.x==0.0)\n        {\n        rd = CosineWeightedSampleHemisphere ( normal, rnd);      \n        \n        col *= clamp(dot(normal,rd),0.0,1.0)*0.62;\n            \n        bool isLight = false;\n        //vec3 rnd3 = vec3(rand2(),rand2().x) *2.0 -1.0;\n        rnd = rand2()*2.0-1.0;\n        vec3 lightf = vec3(clight,2.02)+ vec3(rnd.x*0.6,rnd.y * 0.3,0.0)*0.7;\n        vec3 lightf1 = vec3(clight1,2.02)+ vec3(rnd.x*0.6,rnd.y * 0.3,0.0);\n        \n        light = lightf;\n        //if(rand2().x>1.0)  light = lightf1;\n        vec3 dl = directLight(hit, normal, light, vec3(0.9,0.9,0.9), isLight);\n        float nd = max(0.0,dot(light,vec3(0.0,0.0,1.0)))+max(0.0,dot(light,normal));\n        color += col * dl*5.0 *nd;\n        //if(isLight) break;\n        }\n        else rd = reflect(rd,normal);\n        ro = hit + rd * 0.0001; \n    \n        if(dot(col,col) < 0.1 && i>3) break;\n    }\n \treturn color;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    p = -1.0+2.0*fragCoord.xy/iResolution.xy;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy  -vec2(0.0,2.0);\n\t\t \n\tfloat time = 15.0 + iTime;\n    float seed = iTime + iResolution.y *(p.x+1.0) + p.y;\n\t\n\trandv2=fract(cos((fragCoord.xy+fragCoord.yx*vec2(1000.0,1000.0))+vec2(iTime))*10000.0);\n\t\n    //move camera with mouse\n\tvec3 ro = vec3( 3.5*cos(8.0*mo.x), 2.0 + 1.1*(mo.y*1.0), 0.0 + 3.5*sin(8.0*mo.x) );\n\tvec3 ta = vec3( 0.0, 0.0, 0.0 );\n\t\n    //camera path\n    time = 0.2* iTime;\n    vec3 path = vec3(sin(time*0.5)*2.0, sin(time)*0.7, cos(time*0.5)*2.0);    \n    //ro = path; ta = path + vec3(-sin(time*0.5)*0.5+0.0, -cos(time)*0.2, -cos(time*0.5)*0.5+0.0);\n    \n    //view of raymarch\n    //ro = vec3(-0.4,-0.8, 1.0); ta = vec3(-0.4,-0.8, 1.5);\n\t// camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n    \n    initscene();\n\t\n\tvec3 col = vec3(0.0);\n\n    for(float i=0.0; i<t; i++)\n    {\n        p += (rand2() * 2.0 - 1.0) * 0.7 / iResolution.x;\n        rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n    \tcol += getColor( ro, rd );\n    }\n\n    col = pow( clamp( col/t, 0.0, 1.0 ), vec3(0.65) );\n    //col.g += tc;\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtXXzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[619, 619, 632, 720, 896], [898, 898, 961, 1067, 1388], [1390, 1390, 1431, 1463, 1751], [1753, 1753, 1806, 1806, 2110], [2112, 2112, 2152, 2152, 2552], [2554, 2554, 2610, 2610, 3038], [3042, 3042, 3084, 3084, 3151], [3154, 3154, 3208, 3208, 3718], [3720, 3720, 3772, 3772, 3925], [3927, 3927, 3945, 3945, 7380], [7382, 7382, 7458, 7611, 9751], [9753, 9753, 9878, 9878, 13003], [13005, 13005, 13082, 13082, 13522], [13524, 13524, 13557, 13557, 15223], [15225, 15225, 15282, 15282, 16607]], "test": "valid"}
