{"id": "4lfcDr", "name": "Path tracing cornellbox with MIS", "author": "cschied", "description": "path tracing in the cornell box", "tags": ["cornellbox", "pathtracing", "mis"], "likes": 109, "viewed": 9855, "date": "1504273098", "time_retrieved": "2024-06-20T19:00:18.074586", "image_code": "#define INFINITY 9999999.0\n#define PI 3.141592653589\n#define NUM_SAMPLES 32\n#define NUM_BOUNCES 3\n\nfloat light_size;\nfloat light_area;\n//vec3 light_position = vec3(0, 0.97, 0);\nvec3 light_position;\nvec3 light_normal;\nint seed;\nvec4 light_albedo;\nint flat_idx;\n\n\n\nvec2\nsample_disk(vec2 uv)\n{\n\tfloat theta = 2.0 * 3.141592653589 * uv.x;\n\tfloat r = sqrt(uv.y);\n\treturn vec2(cos(theta), sin(theta)) * r;\n}\n\nvec3\nsample_cos_hemisphere(vec2 uv)\n{\n\tvec2 disk = sample_disk(uv);\n\treturn vec3(disk.x, sqrt(max(0.0, 1.0 - dot(disk, disk))), disk.y);\n}\n\nmat3\nconstruct_ONB_frisvad(vec3 normal)\n{\n\tmat3 ret;\n\tret[1] = normal;\n\tif(normal.z < -0.999805696) {\n\t\tret[0] = vec3(0.0, -1.0, 0.0);\n\t\tret[2] = vec3(-1.0, 0.0, 0.0);\n\t}\n\telse {\n\t\tfloat a = 1.0 / (1.0 + normal.z);\n\t\tfloat b = -normal.x * normal.y * a;\n\t\tret[0] = vec3(1.0 - normal.x * normal.x * a, b, -normal.x);\n\t\tret[2] = vec3(b, 1.0 - normal.y * normal.y * a, -normal.y);\n\t}\n\treturn ret;\n}\n\nvoid\nencrypt_tea(inout uvec2 arg)\n{\n\tuvec4 key = uvec4(0xa341316c, 0xc8013ea4, 0xad90777d, 0x7e95761e);\n\tuint v0 = arg[0], v1 = arg[1];\n\tuint sum = 0u;\n\tuint delta = 0x9e3779b9u;\n\n\tfor(int i = 0; i < 32; i++) {\n\t\tsum += delta;\n\t\tv0 += ((v1 << 4) + key[0]) ^ (v1 + sum) ^ ((v1 >> 5) + key[1]);\n\t\tv1 += ((v0 << 4) + key[2]) ^ (v0 + sum) ^ ((v0 >> 5) + key[3]);\n\t}\n\targ[0] = v0;\n\targ[1] = v1;\n}\n\nvec2\nget_random()\n{\n  \tuvec2 arg = uvec2(flat_idx, seed++);\n  \tencrypt_tea(arg);\n  \treturn fract(vec2(arg) / vec2(0xffffffffu));\n}\n\nstruct Ray\n{\n\tvec3 origin, dir;\n};\n\nstruct AABB\n{\n\tvec3 min_, max_;\n};\n\nmat4\nrotate_y(float a)\n{\n\tmat4 ret = mat4(1.0);\n\tret[0][0] = ret[2][2] = cos(a);\n\tret[0][2] = sin(a);\n\tret[2][0] = -ret[0][2];\n\treturn ret;\n}\n\nvec3\nsample_light(vec2 rng)\n{\n\treturn light_position + vec3(rng.x - 0.5, 0, rng.y - 0.5) * light_size;\n}\n\nbool\nintersect_aabb(in Ray ray, in AABB aabb, inout float t_min, inout float t_max)\n{\n\tvec3 div = 1.0 / ray.dir;\n\tvec3 t_1 = (aabb.min_ - ray.origin) * div;\n\tvec3 t_2 = (aabb.max_ - ray.origin) * div;\n\n\tvec3 t_min2 = min(t_1, t_2);\n\tvec3 t_max2 = max(t_1, t_2);\n\n\tt_min = max(max(t_min2.x, t_min2.y), max(t_min2.z, t_min));\n\tt_max = min(min(t_max2.x, t_max2.y), min(t_max2.z, t_max));\n\n\treturn t_min < t_max;\n}\n\nvec3\nray_at(in Ray ray, float t)\n{\n\treturn ray.origin + t * ray.dir;\n}\n\nfloat\nintersect_plane(\n\tRay ray,\n    vec3 center,\n    vec3 normal)\n{\n    float denom = dot(ray.dir, normal);\n    float t = dot(center - ray.origin, normal) / denom;\n\treturn t > 0.0 ? t : INFINITY;\n}\n\nfloat\nintersect_box(Ray ray, out vec3 normal, vec3 size)\n{\n\tfloat t_min = 0.0;\n\tfloat t_max = 999999999.0;\n\tif(intersect_aabb(ray, AABB(-size, size), t_min, t_max)) {\n\t\tvec3 p = ray_at(ray, t_min);\n\t\tp /= size;\n\t\tif(abs(p.x) > abs(p.y)) {\n\t\t\tif(abs(p.x) > abs(p.z)) {\n\t\t\t\tnormal = vec3(p.x > 0.0 ? 1.0 : -1.0, 0, 0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnormal = vec3(0, 0, p.z > 0.0 ? 1.0 : -1.0);\n\t\t\t}\n\t\t}\n\t\telse if(abs(p.y) > abs(p.z)) {\n\t\t\tnormal = vec3(0, p.y > 0.0 ? 1.0 : -1.0, 0);\n\t\t}\n\t\telse {\n\t\t\tnormal = vec3(0, 0, p.z > 0.0 ? 1.0 : -1.0);\n\t\t}\n\n\t\treturn t_min;\n\t}\n\n\treturn INFINITY;\n}\n\nfloat\nintersect_light(Ray ray)\n{\n\tfloat t = intersect_plane(ray, light_position, light_normal);\n\n\tvec3 p = ray_at(ray, t);\n\tif(all(lessThan(abs(light_position - p).xz, vec2(light_size * 0.5)))) {\n\t\treturn t;\n\t}\n\n\treturn INFINITY;\n}\n\nfloat\nintersect(Ray ray, inout vec3 p, inout vec3 normal, out vec4 albedo)\n{\n\tfloat t_min = INFINITY;\n\n\talbedo = vec4(0.0);\n\n\t{\n\t\tfloat t = intersect_light(ray);\n\t\tif(t < t_min) {\n\t\t\t//albedo = vec3(100);\n\t\t\talbedo = light_albedo;\n\t\t\t//albedo = vec3(dot(ray.dir, light_normal) < 0.0 ? 1.0 : 0.0);\n\t\t\tnormal = light_normal;\n\t\t\tt_min  = t;\n\t\t\tp = ray_at(ray, t);\n\t\t}\n\t}\n\n\t{\n\t\tvec3 normal_tmp;\n\t\tRay ray_tmp = ray;\n\t\t//mat4 r = rotate_y(scene_time);\n\t\tmat4 r = rotate_y(0.3);\n\t\tray_tmp.origin -= vec3(-0.35, -0.5, -0.35);\n\t\tray_tmp.dir = vec3(r * vec4(ray_tmp.dir, 0));\n\t\tray_tmp.origin = vec3(r * vec4(ray_tmp.origin, 1.0));\n\t\tfloat t = intersect_box(ray_tmp, normal_tmp, vec3(0.25, 0.5, 0.25));\n\t\tif(t < t_min) {\n\t\t\tt_min = t;\n\t\t\tp = ray_at(ray, t);\n\t\t\talbedo = vec4(0.7, 0.7, 0.7, 0);\n\t\t\tnormal = vec3(transpose(r) * vec4(normal_tmp, 0.0));\n\t\t}\n\t}\n\n\t{\n\t\tvec3 normal_tmp;\n\t\tRay ray_tmp = ray;\n\t\tray_tmp.origin -= vec3(0.5, -0.75, 0.35);\n\t\tfloat t = intersect_box(ray_tmp, normal_tmp, vec3(0.25, 0.25, 0.25));\n\t\tif(t < t_min) {\n\t\t\tt_min = t;\n\t\t\tp = ray_at(ray, t);\n\t\t\talbedo = vec4(0.7, 0.7, 0.7, 0);\n\t\t\tnormal = normal_tmp;\n\t\t}\n\t}\n\n\t// left\n\t{\n\t\tvec3 n = vec3(1, 0, 0);\n\t\tfloat t = intersect_plane(ray, vec3(-1, 0, 0), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThanEqual(p_tmp.yz, vec2(1))) && all(greaterThanEqual(p_tmp.yz,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tnormal = n;\n\t\t\t\tp = p_tmp;\n\n\t\t\t\tt_min = t;\n\n\t\t\t\talbedo = vec4(0.9, 0.1, 0.1, 0);\n\t\t\t}\n\t\t}\n\t}\n\t// right\n\t{\n\t\tvec3 n = vec3(-1, 0, 0);\n\t\tfloat t = intersect_plane(ray, vec3(1, 0, 0), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThanEqual(p_tmp.yz, vec2(1))) && all(greaterThanEqual(p_tmp.yz,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tnormal = n;\n\t\t\t\tp = p_tmp;\n\n\t\t\t\tt_min = t;\n\n\t\t\t\talbedo = vec4(0.1, 0.9, 0.1, 0);\n\t\t\t}\n\t\t}\n\t}\n\t// floor\n\t{\n\t\tvec3 n = vec3(0, 1, 0);\n\t\tfloat t = intersect_plane(ray, vec3(0, -1, 0), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThan(p_tmp.xz, vec2(1))) && all(greaterThan(p_tmp.xz,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tnormal = n;\n\t\t\t\tp = p_tmp;\n\t\t\t\talbedo = vec4(0.7, 0.7, 0.7, 0);\n\n\t\t\t\tt_min = t;\n\t\t\t}\n\t\t}\n\t}\n\t// ceiling\n\t{\n\t\tvec3 n = vec3(0, -1, 0);\n\t\tfloat t = intersect_plane(ray, vec3(0, 1, 0), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThan(p_tmp.xz, vec2(1))) && all(greaterThan(p_tmp.xz,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tnormal = n;\n\t\t\t\tp = p_tmp;\n\t\t\t\talbedo = vec4(0.7, 0.7, 0.7, 0);\n\n\t\t\t\tt_min = t;\n\t\t\t}\n\t\t}\n\t}\n\t// back wall\n\t{\n\t\tvec3 n = vec3(0, 0, 1);\n\t\tfloat t = intersect_plane(ray, vec3(0, 0, -1), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThan(p_tmp.xy, vec2(1))) && all(greaterThan(p_tmp.xy,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tnormal = n;\n\t\t\t\tp = p_tmp;\n\t\t\t\talbedo = vec4(0.7, 0.7, 0.7, 0);\n\n\t\t\t\tt_min = t;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tnormal = normalize(normal);\n\n\treturn t_min;\n}\n\nbool\ntest_visibility(vec3 p1, vec3 p2)\n{\n\tconst float eps = 1e-5;\n\n\tRay r = Ray(p1, normalize(p2 - p1));\n\tr.origin += eps * r.dir;\n\n\tvec3 n, p;\n\tvec4 a; // ignored\n\tfloat t_shadow = intersect(r, p, n, a);\n\n\treturn t_shadow > distance(p1, p2) - 2.0 * eps;\n}\n\nvec3\npt_mis(Ray ray)\n{\n\tvec3 contrib = vec3(0);\n\tvec3 tp = vec3(1.0);\n\n\tvec3 position, normal;\n\tvec4 albedo;\n\tfloat t = intersect(ray, position, normal, albedo);\n\n\tif(t == INFINITY)\n\t\treturn vec3(0.0);\n\n\tif(albedo.a > 0.0) { /* hight light source */\n\t\treturn albedo.rgb * albedo.a;\n\t}\n\n\tfor(int i = 0; i < NUM_BOUNCES; i++) {\n\t\tmat3 onb = construct_ONB_frisvad(normal);\n\n\t\t{ /* NEE */\n\t\t\tvec3 pos_ls = sample_light(get_random());\n\t\t\tvec3 l_nee = pos_ls - position;\n\t\t\tfloat rr_nee = dot(l_nee, l_nee);\n\t\t\tl_nee /= sqrt(rr_nee);\n\t\t\tfloat G = max(0.0, dot(normal, l_nee)) * max(0.0, -dot(l_nee, light_normal)) / rr_nee;\n\n\t\t\tif(G > 0.0) {\n\t\t\t\tfloat light_pdf = 1.0 / (light_area * G);\n\t\t\t\tfloat brdf_pdf = 1.0 / PI;\n\n\t\t\t\tfloat w = light_pdf / (light_pdf + brdf_pdf);\n\n\t\t\t\tvec3 brdf = albedo.rgb / PI;\n\n\t\t\t\tif(test_visibility(position, pos_ls)) {\n\t\t\t\t\tvec3 Le = light_albedo.rgb * light_albedo.a;\n\t\t\t\t\tcontrib += tp * (Le * w * brdf) / light_pdf;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t{ /* brdf */\n\t\t\tvec3 dir = normalize(onb * sample_cos_hemisphere(get_random()));\n\n\t\t\tvec3 brdf = albedo.rgb / PI;\n\n\t\t\tRay ray_next = Ray(position, dir);\n\t\t\tray_next.origin += ray_next.dir * 1e-5;\n\n\t\t\tvec3 position_next, normal_next;\n\t\t\tvec4 albedo_next;\n\t\t\tfloat t = intersect(ray_next, position_next, normal_next, albedo_next);\n\n\t\t\tif(t == INFINITY)\n\t\t\t\tbreak;\n\n\t\t\tfloat brdf_pdf = 1.0 / PI;\n\n\t\t\tif(albedo_next.a > 0.0) { /* hit light_source */\n\t\t\t\tfloat G = max(0.0, dot(ray_next.dir, normal)) * max(0.0, -dot(ray_next.dir, normal_next)) / (t * t);\n\t\t\t\tif(G <= 0.0) /* hit back side of light source */\n\t\t\t\t\tbreak;\n\n\t\t\t\tfloat light_pdf = 1.0 / (light_area * G);\n\n\t\t\t\tfloat w = brdf_pdf / (light_pdf + brdf_pdf);\n\n\t\t\t\tvec3 Le = light_albedo.rgb * light_albedo.a;\n\t\t\t\tcontrib += tp * (Le * w * brdf) / brdf_pdf;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ttp *= brdf / brdf_pdf;\n\n\t\t\tposition = position_next;\n\t\t\tnormal = normal_next;\n\t\t\talbedo = albedo_next;\n\t\t}\n\t}\n\n\treturn contrib;\n}\n\nvoid\nmainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tlight_size = 0.5;\n\tlight_area = light_size * light_size;\n\tlight_position = vec3(0.5 * sin(iTime), 0.90, 0.5 * cos(iTime));\n\tlight_normal = vec3(0, -1, 0);\n\tseed = 0;\n\tlight_albedo = vec4(1, 1, 1, 2.0 / (light_size * light_size));\n\tflat_idx = int(dot(gl_FragCoord.xy, vec2(1, 4096)));\n\n\n\tvec2 p = fragCoord.xy / vec2(iResolution) - vec2(0.5);\n\tfloat a = float(iResolution.x) / float(iResolution.y);\n\tif(a < 1.0)\n\t\tp.y /= a;\n\telse\n\t\tp.x *= a;\n\n\tvec3 cam_center = vec3(0, 0, 3.125);\n\n\tvec3 s = vec3(0);\n\tfor(int i = 0; i < NUM_SAMPLES; i++) {\n\t\tRay ray;\n\t\tray.origin = cam_center;\n\t\tvec2 r = get_random();\n\t\tvec3 ray_dir = normalize(vec3(p + r.x * dFdx(p) + r.y * dFdy(p), -1));\n\t\tray.dir = ray_dir;\n\t\tvec3 c = pt_mis(ray);\n\t\ts += c;\n\t}\n\n\tfragColor = vec4(pow(s / float(NUM_SAMPLES), vec3(1.0 / 2.2)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lfcDr.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[135, 263, 290, 290, 401], [403, 403, 440, 440, 541], [543, 543, 584, 584, 937], [939, 939, 974, 974, 1330], [1332, 1332, 1351, 1351, 1462], [1536, 1536, 1560, 1560, 1677], [1679, 1679, 1708, 1708, 1783], [1785, 1785, 1870, 1870, 2195], [2197, 2197, 2231, 2231, 2267], [2269, 2269, 2337, 2337, 2467], [2469, 2469, 2527, 2527, 3045], [3047, 3047, 3079, 3079, 3278], [3280, 3280, 3356, 3356, 6136], [6138, 6138, 6178, 6178, 6394], [6396, 6396, 6418, 6418, 8320], [8322, 8322, 8377, 8377, 9185]]}
{"id": "4lfcRl", "name": "Cubic Truchet Pattern", "author": "Shane", "description": "A standard cubic Truchet pattern, rendered in a simplistic style. Nothing exciting. :)", "tags": ["raymarching", "truchet", "polar", "cubic", "tile"], "likes": 73, "viewed": 4071, "date": "1506008177", "time_retrieved": "2024-06-20T19:00:20.602080", "image_code": "/*\n\n\tCubic Truchet Pattern\n\t---------------------\n\n\tI have a more elaborate 3D Truchet related example to post, but wanted to put up a \n\tsimpler version first. There are a few cubic Truchet examples on here, including one\n\tof my own, so I'm not bringing anything particularly new to the table. :)\n\n\tI like 3D cubic Truchet patterns, because they're geometrically interesting, and are\n\treasonably easy to produce. A standard 3D Truchet tile consists of three toroids \n\tcentered on three edges of a cube, positioned to enter and exit six cube faces... Look \n\tone up on the internet, and that diatribe should make more sense. :) The idea is to \n\tinterconnect the tiles in a 3D grid - by randomly rotating each around one of the axes - \n\tto produce an interesting spaghetti looking pattern.\n\n\tConstructing the individual tiles is as simple as breaking space into a cubic grid then\n\tpositioning three torii in each cell. If you can position, rotate and render a torus,\n\tthen it should be rudimentary.\n\n\tDetailed scenes look cool, but sometimes it can be difficult to separate the main point \n\tof the code from the details themselves. The Truchet code requires but a few lines. \n\tAdding a few decorations complicates things slightly, and trying to do it in a more \n\tefficient way can confuse things even further. I've tried my best to mitigate this.\n    However, you'll see some esoteric object ID code scattered throughout the example, which\n\tconsists of last minute logic that I put together to get the job done... You can safely \n\tignore it. :)\n\t\n\tI code most things on a fast computer these days, which doesn't exactly help when it\n\tcomes to optimization. As a rough guage, I'll try to get it running as smoothly as\n\tpossible in fullscreen. This one seems to run OK in fullscreen, but it could do with\n\ta few extra tweaks. Aesthetically speaking, I had the 800 by 450 canvas in mind.\n\n\tI'm not really sure what kind of look I was going for, but I wanted something simple\n\tand clean looking that clearly showed the Truchet pattern. The lighting is very basic,\n\tbut reasonably effective.\n\n\tAnyway, I'll put up my more interesting example next... provided I don't get \n\tsidetracked. :)\n\n\n\tOther cubic Truchet examples:\n\n\t// The first cubic Truchet example I saw on here. Really cool, and shiny. :)\n\tTruchet Tentacles - WAHa_06x36\n\thttps://www.shadertoy.com/view/ldfGWn\n\n\t// Dr2's interpretation.\n\tTruchet Flythrough 2 - Dr2\n\thttps://www.shadertoy.com/view/4dsBWf\n\n\t// Another one I did a while back. Less detailed, so probably easier to understand.\n\tTwisted Tubes - Shane\n\thttps://www.shadertoy.com/view/lsc3DH\n\n*/\n\n// Maximum ray distance.\n#define FAR 80.\n\n// Scene object ID: Main tube, colored inner tube or colored band.\nfloat objID; // Global ID to keep a copy of the above from pass to pass.\n\n// Storage vectors to help determine the above and produce the blinking light effect. They're\n// used inside the distance function. I'm not fond of using globals inside distance field\n// functions, but felt it was necessary in this case.\nvec3 vObjID;\nfloat gID; \n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// Tube: Cylindrical tube, square tube, etc. In this case, it's a squarish tube with some\n// beveled sides.\nfloat tube(vec2 p){\n    \n    // Normally needed, but in this example \"p\" is passed to the function in its absoluted form.\n    //p = abs(p); \n\n    return max(max(p.x, p.y), (p.x + p.y)*.5773); // .7071 for an octagon, etc.\n    //return max(p.x, p.y); // Square tube, etc.\n}\n\n\n\n// The toroidal tube objects. Each consist of a white squarish outer tube, a similar colored \n// inner one (only visible through the holes) and some colored bands.\nvec4 torTube(vec3 p){\n\n\n    // Tube width.\n    const float rad2 = .065;\n    \n    \n    // Main tube. If it were not for the additional tube decorations, the following \n    // would be all that'd be required.\n    //\n    // Note that we're converting one of the coordinates to its circular form. That way, \n    // we're rendering a circular tube, instead of a straight one. It's an oversimplification, \n    // but that's basically all a torus is. By the way, it doesn't have to be circular, \n    // converting \"p.xy\" to an octagonal form, etc, would work also.\n    float tb = tube(abs(vec2(length(p.xy) - .5, p.z))) - rad2;\n    \n\n    \n    // Adding some details to the tube. \n    //\n    \n    // Inner tube for colored lights.\n    float innerTb = tb + .015; \n    \n    \n    // Tube segments - for the bands and holes.\n    //\n    // Number of tube segments. Breaking a circle into 8 lots of 3. Other combinations can\n    // work though.\n    const float aNum = 24.; \n    \n    // To place things evenly around the tube, you need to obtain the angle subtended to the center,\n    // partition it into the required number of cells (aNum), then obtain the angle at the center.\n    float a = atan(p.y, p.x);    \n    float ia = floor(a/6.283*aNum) + .5; // .5 to move to the cell center.\n\n    // Converting to polar coordinates - In effect: Radial position, \"p.x,\" and angular position, \"p.y.\"\n    p.xy = rot2(ia*6.283/aNum)*p.xy;\n    // The radial coordinate effective starts off at the center, so to spread the objects out, you have\n    // to advance them  along the radial coordinate in the radial direction. In this case, we want the \n    // objects to have the same radius as the torus we're attaching them to, which is \".5.\"\n    p.x -= .5;\n\n    // Drawing the objects within each of the partitioned cells. In this case, we're rendering some \n    // colored sleeves (or bands), and boring out some holes.\n    \n    p = abs(p);\n    \n    float band = 1e5;\n    \n    // Group the 24 cell partitions into groups of 3 - in order to cover every third cell with the \n    // colored band and bore some holes out in the others... I figured it'd break up the monotony. :)\n    // On a side note, I try to avoid \"if\" statements inside distance functions when I can, but I \n    // figured this would be the best way for readability. Although, I might rework it later.\n    if(mod(ia + 1., 3.)>2.){\n \n        band = max(tube(p.xz) - rad2 - .01, p.y - .04);\n    \tband = max(band, min(band + .005, -p.y + .015));\n    }\n    else {\n        \n        // Cute trick to break the cell into four - in order to bore out four holes in each cell.\n        // Comment it out to produce just one hole.\n        p = abs(p - .02);\n        \n        // Cut out two cross sections from the main tube.\n        tb = max(tb, -min(tube(p.xy) - rad2 + .055, tube(p.yz) - rad2 + .055)); \n        \n    }\n \n    \n    // Return the tube, bands, and inner tube objects.\n    return vec4(tb, band, innerTb, ia);\n}\n\n\n/*\n\n\tThe Truchet pattern:\n\n\tA standard 3D Truchet tile consists of three toroids centered on three edges of a cube, \n    positioned to enter and exit six cube faces... Look one up on the internet, and that \n\tdiatribe will make more sense. :) The idea is to connect the tiles in a 3D grid, then \n\trandomly rotate each around one of the axes to produce an interesting spaghetti looking \n\tpattern.\n\n\tConstructing the individual tiles is as simple as breaking space into a cubic grid then\n\tpositioning three torii in each cell. If you can position, rotate and render a torus,\n\tthen it should be rudimentary.\n\n\tOn a side note, if you're one of those people who have trouble with the torus concept, \n    you're basically rendering a straight tube that has had one of its coordinates warped \n    into a circle first:\n\n\tfloat torus(vec3 p, vec3 center){\n\n\t    // Position the torus.\n        p -= center;\n\t\t// Warp - Comment out below, and you're left with a straight tube.\n    \tvec2 q = vec2(length(p.xy) - .5, p.z); // vec2(length(p.xz) - .5, p.y), etc.\n    \t// Render a circular tube.\n\t\tfloat dist = length(q) - rad;\n\t}\n\n*/\n\n\n// I can thank Mattz for reminding me of this. You don't need to call all three decorated tubes,\n// then determine the minimum. You can determine the minimum main tube, then call the function\n// for the tube containing the more elaborate detailing that corresponds to it. And by that I\n// mean return the unique oriented point that corresponds to the nearest tube segment distance.\n//\nvec4 torTubeTest(vec3 p){\n    \n    vec2 v = vec2(length(p.xy) - .5, p.z);\n    \n    // Main tube distance squared. Note: If a + c < b + c, then a*a<b*b.\n    // Ie: we don't need to test length(v) - r, just dot(v, v);\n    return vec4(p, dot(v, v));\n}\n\n\nfloat map(vec3 p)\n{\n \n    // Random ID for each grid cube.\n    float rnd = fract(sin(dot(floor(p + vec3(111, 73, 27)), vec3(7.63, 157.31, 113.97)))*43758.5453);\n\n    // Partition space into a grid of unit cubes - centered at the origin and ranging from\n    // vec3(-.5, -.5, -.5) to vec3(-.5, -.5, -.5).\n    p = fract(p) - .5;\n      \n    // Use each cube's random ID to rotate it in such a way that another one of its faces is \n    // facing forward. In case you're not aware, the swizzling below is a cheap trick used to\n    // achieve this. By the way, there may be a faster way to write the conditionals - using \n    // ternary operators, or something to that effect, but I'm leaving it this way for now... \n    // However, if a GPU expert feels that it's unnecessarily slow, then feel free to let me \n    // know, and I'll change it.\n    if(rnd>.833) p = p.xzy;\n    else if(rnd>.666) p = p.yxz;\n    else if(rnd>.5) p = p.yzx;\n    else if(rnd>.333) p = p.zxy;\n    else if(rnd>.166) p = p.zyx;\n        \n    // I can thank Mattz for reminding me of this step. Each Truchet tile contains three decorated\n    // tubes. However, you only need to find the closest tube, \"not\" the closest decorated tube, which\n    // requires a lot more GPU power. Each of these return the closest point and the distance...\n    // Actually, the squared distance, which for comparisson purposes, is the same thing.\n    vec4 tb1 = torTubeTest(vec3(p.xy + .5, p.z));\n    vec4 tb2 = torTubeTest(vec3(p.yz - .5, p.x));\n    vec4 tb3 = torTubeTest(vec3(p.xz - vec2(.5, -.5), p.y));\n     \n    // Sort the distances, then return the closest point.\n    p = tb1.w<tb2.w && tb1.w<tb3.w ? tb1.xyz : tb2.w<tb3.w ? tb2.xyz : tb3.xyz;\n \n    // Render the randomly aligned Truchet block. Ie, the three torii - plus bells and whistles.\n    // Each quarter torus consists of three separate objects: A white tube with some holes in it, \n    // some bracing (the colored sleeve looking things) and a colored inner tube. That's nine\n    // objects returned in all. If it were not for the need to sort objects and attain a segment\n    // identifier (tb.w), only a float would be necessary.\n    vec4 tb = torTube(p);\n        \n\n    /// A unique angular segment identifier - used to produce the blinking lights.\n    gID = tb.w;\n    \n     \n    // Each torus segment contains three individual objects. Here, we're finding the minimum in\n    // each category. We're keeping a global copy here that will be sorted for object identification\n    // outside the raymarching loop. The reason this step is necessary is because the line below\n    // finds the closest object, but doesn't tell us which object that is. That requires sorting,\n    // which is best done outside the loop, for speed reasons.\n    vObjID = tb.xyz;\n    \n    // Finding the minimum of the above to determine the overall minimum object in the scene.\n    return min(min(vObjID.x, vObjID.y), vObjID.z);\n    \n    \n}\n\n\n\n// Recreating part of the distance function to obtain the segment IDs, which in turn is used\n// to create the blink effect.\nfloat lightBlink(vec3 p, float gID){\n    \n    // Unique identifier for the cubic grid cell.\n    float rnd = fract(sin(dot(floor(p + vec3(111, 73, 27)), vec3(7.63, 157.31, 113.97)))*43758.5453);\n \n    // Reusing \"rnd\" to produce a new random number, then using that\n    // random number to create lights that blink at random intervals.\n    rnd = fract(rnd + gID*43758.54571);\n    \n    // Blink at random.\n    return smoothstep(0.33, .66, sin(rnd*6.283 + iTime*3.)*.5 + .5);\n\n    \n}\n\n//float glow;\n// Standard raymarching algorithm.\nfloat trace(vec3 o, vec3 r){\n    \n    //glow = 0.;\n    \n    // Total ray distance travelled, and nearest distance at the current ray position.\n    float t = 0., d;\n    \n    for (int i = 0; i<128; i++) {\n        \n        // Surface distance.\n        d = map(o + r*t);\n        \n        //if(abs(d)<.05) glow += (.05 - abs(d))/(1. + d*d);\n        // If the ray position is within the surface threshold (\"abs\" means either side of the \n        // surface), or if we've traversed beyond the maximum, exit the loop.\n        if(abs(d)<.001*(t*.125 + 1.) || t>FAR) break;\n        \n        \n        // Standard jump.\n        t += d; \n        \n        // Shortening the ray jump right near the camera to alleviated near-camera artifacts.\n        //t += t<.125 ? d*.7 : d; \n    }\n    \n    // Clamp the total distance to \"FAR.\" It can sometimes get rid of far surface artifacts.\n    return min(t, FAR);\n}\n\n// Cheap shadows are the bain of my raymarching existence, since trying to alleviate artifacts is an excercise in\n// futility. In fact, I'd almost say, shadowing - in a setting like this - with limited  iterations is impossible... \n// However, I'd be very grateful if someone could prove me wrong. :)\nfloat shadow(vec3 ro, vec3 lp, float k, float t){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 32; \n    \n    vec3 rd = lp-ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = .001*(t*.125 + 1.);  // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        dist += clamp(h, .01, .2); \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0.0 || dist > end) break; \n    }\n\n    // I sometimes add a constant to the final shade value, which lightens the shadow a bit. It's a preference \n    // thing. Really dark shadows look too brutal to me. Sometimes, I'll also add AO, just for kicks. :)\n    return min(max(shade, 0.) + .0, 1.); \n}\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat cAO(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = 1., occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.35/4.0;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n// Normal calculation, with some edging and curvature bundled in.\nvec3 nrm(vec3 p, inout float edge, inout float crv, float t) { \n\t\n    // It's worth looking into using a fixed epsilon versus using an epsilon value that\n    // varies with resolution. Each affects the look in different ways. Here, I'm using\n    // a mixture. I want the lines to be thicker at larger resolutions, but not too thick.\n    // As for accounting for PPI; There's not a lot I can do about that.\n    vec2 e = vec2(1./mix(400., iResolution.y, .5)*(1. + t*.5), 0);\n\n\tfloat d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\tfloat d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\tfloat d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\tfloat d = map(p)*2.;\n\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    //edge = abs(d1 + d2 + d3 + d4 + d5 + d6 - d*3.);\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n/*    \n    // Wider sample spread for the curvature.\n    e = vec2(12./450., 0);\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx);\n    crv = clamp((d1 + d2 + d3 + d4 + d5 + d6 - d*3.)*32. + .5, 0., 1.);\n*/\n    \n    e = vec2(.002, 0); //iResolution.y - Depending how you want different resolutions to look.\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\t\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // Aspect correct screen coordinates.\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5)/iResolution.y;\n    \n    // Ray origin, or camera - Moving along the Z-axis.\n    vec3 o = vec3(0., 0., iTime); \n    // Light. Situated near the camera whilst moving along with it.\n\tvec3 lp = vec3(-1, 3, -.25) + o;\n    \n    // Unit ray vector.\n    vec3 r = normalize(vec3(uv, 1));\n    // Slight bulbous scene warp.\n    //vec3 r = (vec3(uv, 1.1));\n    //r = normalize(vec3(r.xy, r.z - length(r.xy)*.1));\n\n    \n    \n    // Rotating \"r\" back and forth along various axes for some cheap camera movement. \n    r.xz *= rot2(sin(iTime/2.) * 0.4);\n    r.xy *= rot2(cos(iTime/2.) * 0.2);\n    \n    // Trace out the scene.\n    float t = trace(o, r);\n    \n    // Determining the object ID. Sorting the three different objects outside the loop\n    // is a little less readable, but usually faster. See the distance function.\n    objID = (vObjID.x<vObjID.y && vObjID.x<vObjID.z) ? 0. : (vObjID.y<vObjID.z) ? 1. : 2.;\n\n    // Segment ID: Sorting the segments to determine the unique ID. This ID is fed\n    // into a function to give the blinking light effect.\n    float svGID = gID;\n     \n \n\t// Initiate the scene color to zero.\n    vec3 sc = vec3(0);\n\n    \n    // An object in the scene has been hit, so light it.\n    if(t<FAR){\n        \n        // Hit position.\n        vec3 sp = o + r*t;\n        \n        // Normal, plus edges and curvature. The latter isn't used.\n        float edge = 0., crv = 1.;\n        vec3 sn = nrm(sp, edge, crv, t);\n        \n        // Producing a gradient color based on position. Made up on the spot.\n        vec3 oCol = mix(vec3(1, .1, .3), vec3(1, .5, .1), dot(sin(sp*8. - cos(sp.yzx*4.)), vec3(.166)) + .5);\n        oCol = mix(oCol, oCol.yzx, smoothstep(.3, 1., dot(sin(sp*4. + cos(sp.zxy*4. + iTime)), vec3(.166*.6)) + .3));\n        \n        // Color the individual objects, based on object ID.\n        if(objID<.5)oCol = mix(oCol, vec3(1), .97); // The whitish tube.\n        else if(objID<1.5) oCol = mix(oCol, vec3(1), .05); // The colorful bands.\n        else {\n            \n            oCol = mix(oCol, vec3(1), .05); // Inner tube color. Same as above, but you could change it.\n          \t//oCol = mix(oCol, oCol.zyx, dot(cos(sp*32. + sin(sp.yzx*16.)), vec3(.166)) + .5);\n            \n            // The blinking light effect. In effect, the number varies color intensity is periodically\n            // ramped right up. The individual segment ID is responsible for the randomness.\n            oCol *= lightBlink(sp, svGID)*7.5 + .5;\n        }\n        \n        \n        // Ambient occlusion and shadows.\n        float ao = cAO(sp, sn);\n        float sh = shadow(sp + sn*.002, lp, 16., t); \n        \n\n        // Point light direction vector.\n        vec3 ld = lp - sp;\n        float dist = max(length(ld), 0.001); // Distance.\n        ld /= dist; // Using the distance to nomalize the point light direction vector.\n        \n\n        // Attenuation - based on light to surface distance.\n        float atten = 3.5/(1. + dist*0.05 + dist*dist*0.05);\n        \n        // Diffuse light.\n        float diff = max(dot(ld, sn), 0.);\n        \n       \n        \n        // Combining the above terms to produce the final color.\n    \tsc = oCol*(diff + ao*.35);\n        \n        \n        // Fake caustic lighting... It didn't sit right with the scene, so it didn't make the cut. :)\n        //sc += .02/max(abs(.05 - map(sp*1.5)), .01)*oCol*vec3(1, .7, .5);\n        //sc += oCol*abs(tan(t*1.5 + iTime/2.))*vec3(.1, .2, 1)*.05;\n         \n        // Applying the dark edges, attenuation, shadows and ambient occlusion.\n        sc *= (1. - edge*.7)*atten*(sh + ao*.3)*ao;\n        \n        \n    }\n    \n    \n    // Applying some basic camera distance fog. Not to be confused with the light\n    // to surface attenuation.\n    float fog = 1./(1. + t*.125 + t*t*.05);\n    sc = mix(vec3(0), sc, fog);//\n    //sc = mix(sc, vec3(0), smoothstep(0.0, .2, t/FAR));\n    \n    \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    //sc *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125);\n    // Colored variation.\n    sc = mix(pow(min(vec3(1.5, 1, 1).zyx*sc, 1.), vec3(1, 3, 16).zyx), sc, \n             pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125)*.75 + .25);\n    \n    \n\tfragColor = vec4(sqrt(max(sc, 0.)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lfcRl.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[3059, 3092, 3114, 3114, 3172], [3174, 3282, 3301, 3422, 3554], [3558, 3722, 3743, 3764, 6675], [7798, 8183, 8208, 8208, 8431], [8434, 8434, 8453, 8492, 11364], [11368, 11492, 11528, 11583, 11972], [11974, 12023, 12051, 12165, 12915], [12917, 13218, 13267, 13384, 14684], [14686, 14838, 14875, 14875, 15134], [15136, 15202, 15264, 15607, 16588], [16592, 16592, 16649, 16696, 20960]]}
{"id": "4lfczB", "name": "Sphere over lake", "author": "Nowado", "description": "Any description", "tags": ["sphere"], "likes": 6, "viewed": 444, "date": "1505383586", "time_retrieved": "2024-06-20T19:00:20.602080", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n    \n#define r iResolution.xy\n#define t iTime\n{\n    vec2 uv = fragCoord/r;\n    vec2 d = vec2 (.3*sin(t),.1*cos(t));\n    uv-=.5;\n    uv.x*=r.x/r.y;\n    float l = length(uv+d)*4.5*(2.0*uv.y+1.0);\n    l=l;\n    fragColor = vec4(0.25/l,0.4/l,0.5/l,1.0); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lfczB.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": []}
{"id": "4lfczl", "name": "Noise Offset", "author": "nyu", "description": "A sample, to be copied and pasted anywhere you want to hide any too uniform effects (like ).\nNote: noise codes aren't from me.", "tags": ["2d", "noise"], "likes": 1, "viewed": 107, "date": "1505918077", "time_retrieved": "2024-06-20T19:00:20.608312", "image_code": "#define PI 3.14159\n#define PERLIN\n//#define SIMPLEX\n\n// noise function from: https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n\n//****************** simplex *****************//\n\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat sNoise(vec2 v){\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n//**************** perlin ***********************//\n\nfloat rand(vec2 c){\n\treturn fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise(vec2 p, float freq ){\n\tfloat unit = 1.0/freq;\n\tvec2 ij = floor(p/unit);\n\tvec2 xy = mod(p,unit)/unit;\n\t//xy = 3.*xy*xy-2.*xy*xy*xy;\n\txy = .5*(1.-cos(PI*xy));\n\tfloat a = rand((ij+vec2(0.,0.)));\n\tfloat b = rand((ij+vec2(1.,0.)));\n\tfloat c = rand((ij+vec2(0.,1.)));\n\tfloat d = rand((ij+vec2(1.,1.)));\n\tfloat x1 = mix(a, b, xy.x);\n\tfloat x2 = mix(c, d, xy.x);\n\treturn mix(x1, x2, xy.y);\n}\n\nfloat pNoise(vec2 p, int res){\n\tfloat persistance = .5;\n\tfloat n = 0.;\n\tfloat normK = 0.;\n\tfloat f = 4.;\n\tfloat amp = 1.;\n\tint iCount = 0;\n\tfor (int i = 0; i<50; i++){\n\t\tn+=amp*noise(p, f);\n\t\tf*=2.;\n\t\tnormK+=amp;\n\t\tamp*=persistance;\n\t\tif (iCount == res) break;\n\t\tiCount++;\n\t}\n\tfloat nf = n/normK;\n\treturn nf*nf*nf*nf;\n}\n\n// ************** demo ****************  //\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    #ifdef PERLIN\n        float n = pNoise(uv * 6.0, 4);\n    #elif defined SIMPLEX\n    \tfloat n = sNoise(uv * 12.0) / 10.0;\n    #else\n    \tfloat n = 0.0;\n    #endif\n    \n    uv.x += n;\n    float waves = clamp(sin((uv.x + (iTime / 10.0)) * 10.0), 0.0, 1.0);\n    \n    if (((round(sin(iTime / 1.0)) / 2.0) + 0.5) < 0.5) {\n    \tfragColor = vec4(clamp(waves, 0.0, 1.0));\n    } else {\n    \tfragColor = vec4(clamp(waves, 0.0, 1.0));\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lfczl.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[144, 194, 216, 216, 255], [257, 257, 278, 278, 1098], [1100, 1153, 1172, 1172, 1240], [1242, 1242, 1275, 1275, 1637], [1639, 1639, 1669, 1669, 1958], [1960, 2005, 2062, 2062, 2543]]}
{"id": "4lfyDX", "name": "SphereTest1", "author": "itishappy", "description": "Lights on a sphere.", "tags": ["noise", "sphere", "raytrace"], "likes": 0, "viewed": 58, "date": "1506571134", "time_retrieved": "2024-06-20T19:00:21.262701", "image_code": "#define    PI 3.1415926\n#define TWOPI 6.2831853\n/*\n#define     X vec3(1.0, 0.0, 0.0);\n#define     Y vec3(0.0, 1.0, 0.0);\n#define     Z vec3(0.0, 0.0, 1.0);\n*/\n\n/* Table of contents:                                                    *\\\n\t1. A fuck ton of perlin noise stuff\n\t\tI used this: http://flafla2.github.io/2014/08/09/perlinnoise.html\n\t\n\t2. The rest\n\t\tqMult()\n\t\trotate()\n\t\tlight()\n\t\trender()\n\t\tmainImage()\n\\*                                                                       */\n\n\n// PERLIN NOISE\n\nint whichVec[8] = int[8](0, 3, 8, 8, 6, 3, 0, 2); // shhhhh... don't worry about it.\n\nfloat grad(int i, vec3 n) {\n    switch(whichVec[i]) {\n    \tcase 0:  return  n.x + n.y;\n        case 1:  return -n.x + n.y;\n    \tcase 2:  return  n.x - n.y;\n    \tcase 3:  return -n.x - n.y;\n    \tcase 4:  return  n.x + n.z;\n    \tcase 5:  return -n.x + n.z;\n    \tcase 6:  return  n.x - n.z;\n    \tcase 7:  return -n.x - n.z;\n    \tcase 8:  return  n.y + n.z;\n    \tcase 9:  return -n.y + n.z;\n    \tcase 10: return  n.y - n.z;\n    \tcase 11: return -n.y - n.z;\n    \tcase 12: return  n.y + n.x;\n    \tcase 13: return -n.y + n.z;\n    \tcase 14: return  n.y - n.x;\n    \tcase 15: return -n.y - n.z;\n        default: return 0.0;\n    }\n}\n\nfloat lerp(float p1, float p2, float v) {\n    return v * p1 + (1.0 - v) * p2;\n}\n\n\n//still not sure this works...\nfloat noiseSphere(vec3 p) {\n    p = 0.5 * p + 0.5; // shift domain from [-1.0, 1.0] to [0.0, 1.0]\n    float x1, x2, y1, y2;\n    x1 = lerp(grad(0, p), grad(1, p), p.x);\n    x2 = lerp(grad(2, p), grad(3, p), p.x);\n    y1 = lerp(x1, x2, p.y);\n    x1 = lerp(grad(4, p), grad(5, p), p.x);\n    x2 = lerp(grad(6, p), grad(7, p), p.x);\n    y2 = lerp(x1, x2, p.y);\n    return 0.5 * lerp(y1, y2, p.z) + 0.5; // shift range from [-1.0, 1.0] to [0.0, 1.0]\n}\n\n// THE REST\n\nvec3 X = vec3(1.0, 0.0, 0.0);\nvec3 Y = vec3(0.0, 1.0, 0.0);\nvec3 Z = vec3(0.0, 0.0, 1.0);\n\n// Rotates?\nmat2 rot(float a) {\n    return mat2(cos(a), sin(a), \n               -sin(a), cos(a));\n}\n\n// Quaternion multiplication\nvec4 qMult(vec4 q1, vec4 q2) {\n    vec4 qr;\n\tqr.x = (q1.w * q2.x) + (q1.x * q2.w) + (q1.y * q2.z) - (q1.z * q2.y);\n\tqr.y = (q1.w * q2.y) - (q1.x * q2.z) + (q1.y * q2.w) + (q1.z * q2.x);\n\tqr.z = (q1.w * q2.z) + (q1.x * q2.y) - (q1.y * q2.x) + (q1.z * q2.w);\n\tqr.w = (q1.w * q2.w) - (q1.x * q2.x) - (q1.y * q2.y) - (q1.z * q2.z);\n\treturn qr;\n}\n\n// Rotate using quaternions\nvec3 rotate(vec3 point, vec3 axis, float angle) {\n    vec4 p, q1, q2;\n    p.xyz = point;\n    p.w = 0.0;\n    q1.xyz = sin(0.5 * angle) * axis;\n    q1.w = cos(0.5 * angle);\n    q2.xyz = -q1.xyz;\n    q2.w = q1.w;\n    return qMult(qMult(q1, p), q2).xyz;\n}\n\n// Draws some spinning lights\nvec3 light(vec3 n) {\n    float rSpeed = 0.03;\n    float gSpeed = 0.05;\n    float bSpeed = 0.07;\n    vec3 rStart = Z;\n    vec3 gStart = Z;\n    vec3 bStart = Z;\n    vec3 rAxis = rotate(X, Z, 0.0 * TWOPI / 3.0);\n    vec3 gAxis = rotate(X, Z, 1.0 * TWOPI / 3.0);\n    vec3 bAxis = rotate(X, Z, 2.0 * TWOPI / 3.0);\n    vec3 rDir = rotate(rStart, rAxis, TWOPI * iTime * rSpeed);\n    vec3 gDir = rotate(gStart, gAxis, TWOPI * iTime * gSpeed);\n    vec3 bDir = rotate(bStart, bAxis, TWOPI * iTime * bSpeed);\n    return vec3(dot(n, rDir), dot(n, gDir), dot(n, bDir));\n}\n\n// Spins a sphere and lights it\nvec3 render(vec3 p) {\n    float speed = 0.1;\n    vec3 axis = vec3(0.0, 1.0, 0.0);\n    //return light(p);\n    //return vec3(noiseSphere(rotate(p, axis, TWOPI * iTime * speed)));\n    return light(p) * noiseSphere(rotate(p, axis, TWOPI * iTime * speed * 3.));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = vec2((2.0 * fragCoord - iResolution.xy) / iResolution.y);\n    fragColor = vec4(0.0);\n    if(length(uv) < 1.0) {\n        fragColor.xyz = render(vec3(uv, sqrt(1.0 - uv.x * uv.x - uv.y * uv.y)));\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lfyDX.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[557, 593, 620, 620, 1214], [1216, 1216, 1257, 1257, 1295], [1298, 1329, 1356, 1356, 1774], [1880, 1892, 1911, 1911, 1979], [1981, 2010, 2040, 2040, 2351], [2353, 2381, 2430, 2430, 2632], [2634, 2664, 2684, 2684, 3222], [3224, 3256, 3277, 3277, 3514], [3516, 3516, 3571, 3571, 3783]]}
{"id": "4lfyRX", "name": "kali flower 2 dynamic", "author": "ollj", "description": "iMouse.y lowers max iterations; 0..450\niMouse.x lowers stepLengthFactor for each step; 0..1\nlower right=high precision,low performance\n\nfork of\nhttps://www.shadertoy.com/view/4llyz2\n\nextends the ray-march loop with a log_dynamiceps() break condition.", "tags": ["3d", "kali", "dynamiceps", "logeps"], "likes": 12, "viewed": 781, "date": "1505644828", "time_retrieved": "2024-06-20T19:00:22.353670", "image_code": "//L 3d kali d 2\n//parent: https://www.shadertoy.com/view/4llyz2\n// Created by SHAU - 2017 , License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//self  : https://www.shadertoy.com/new\n//adds dynamicEps to parent:\n// where the break-condition of the marching loop is log(squared_function);\n//  t   ==accumulated distance to camera.\n//  ns.x==current distance field return value == distance to \"surface\", gradient descent\n//  if (t>FAR|| log(t*t*EPS/ns.x)>0.) break;\n\n//You go down a special type of non euclidean geometry rabbit hole\n// when you make Epsilon non consant over distance.\n//\n//[Alice in Wonderland] was the resolve \n// of someone tryigng and failing to understand non-euclidean geoometry and topology\n// ,where distance and scale suddenly matter less than curvature.\n// The resolution was to break up with topology to became a famous writer instead.\n//[DynamicEps] extends on this.\n\n#define DynamicEps\n\n\n//setting EPS 1e-5 gets you some almost free surface scattering, due to fractal geometry.\n#define EPS 1e-4\n//set eps=0.01 to see some strance scattering, and som,e \"thicker material_ID outlines\"\n\n#define FAR 20.0 \n#define PI 3.1415\n#define T iTime\n\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\nfloat rand(vec2 co) {return fract(sin(dot(co.xy ,vec2(12.9898, 78.233))) * 43758.5453);}\n\nvec3 lc = vec3(0.0);\n\n// IQ - cosine based palette\n//http://iquilezles.org/www/articles/palettes/palettes.htm\nvec3 palette(in float t) {\n    vec3 CP1A = vec3(0.5, 0.5, 0.5);\n    vec3 CP1B = vec3(0.5, 0.5, 0.5);\n    vec3 CP1C = vec3(2.0, 1.0, 0.0);\n    vec3 CP1D = vec3(0.50, 0.20, 0.25);\n    return CP1A + CP1B * cos(6.28318 * (CP1C * t + CP1D));\n}\n\nfloat sdBox(vec3 p, vec3 bc, vec3 b) {    \n    vec3 d = abs(bc - p) - b; \n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));;\n}\n\n/*\nfloat map(vec3 rp) {\n    \n    float msd = FAR;\n    for (int i = 0; i < 16; i++) {    \n       rp = abs(rp) / dot(rp, rp) - .25;  \n       msd = min(msd, sdBox(rp, 1.0 - rp, vec3(1.0)));\n    }\n    \n    return msd;\n}\n*/\n\nvec2 near(vec2 new, vec2 old) {\n    if (new.x < old.x) return new;\n    return old;\n}\n\nvec2 map(vec3 rp) {\n    \n    vec2 msd = vec2(FAR, 0);\n    for (int i = 0; i < 10; i++) {  \n        //this is so sensitive\n       float c = 0.3;// + sin(T * 0.2) * 0.1; //clamp(0.3 + sin(T * 0.4) * 0.06, 0.24, 0.32); //0.1 - 0.3\n       float q = 1.0 + sin(T) * 0.1;  //1.6 + sin((T - PI)  * 0.1) * 0.4; // 3.6 - 1.0\n       rp = abs(rp) / dot(rp, rp) - c;\n       rp.xy *= rot(float(i));\n       msd = near(msd, vec2(sdBox(rp, q - rp, vec3(1.0)), i)); \n    }\n    \n    return msd;\n}\n\n//from shane\nvec3 normal(vec3 rp, out float edge) {\n    \n    vec2 e = vec2(EPS, 0.0);\n\tfloat d1 = map(rp + e.xyy).x;\n    float d2 = map(rp - e.xyy).x;\n\tfloat d3 = map(rp + e.yxy).x;\n    float d4 = map(rp - e.yxy).x;\n\tfloat d5 = map(rp + e.yyx).x;\n    float d6 = map(rp - e.yyx).x;\n\tfloat d = map(rp).x * 2.0;\n\n    // Edges - Take a geometry measurement from either side of the hit point. Average them, then see how\n    // much the value differs from the hit point itself. Do this for X, Y and Z directions. Here, the sum\n    // is used for the overall difference, but there are other ways. Note that it's mainly sharp surface \n    // curves that register a discernible difference.\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    \n    //edge = max(max(abs(d1 + d2 - d), abs(d3 + d4 - d)), abs(d5 + d6 - d)); // Etc.\n    \n    // Once you have an edge value, it needs to normalized, and smoothed if possible. How you \n    // do that is up to you. This is what I came up with for now, but I might tweak it later.\n    edge = smoothstep(0.0, 1.0, sqrt(edge / e.x * 2.0));\n    \n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n//spheretrack Logeps VolumeGlow\nvec3 marchScene(vec3 ro, vec3 rd\n){vec2 m=1.-iMouse.xy/iResolution.xy;//m could be identical to ScreenSpace.xy\n //[l] lazily coutneracts overstepping for higher precision in its gradient descent.\n //     by intentional understepping, assuming lipschits constant >1,\n float l=m.x;//set by iMouse.x\n //dynamic number of iterations lacks backwards compatibility.\n float iterMax=450.*m.y;//set by Mouse.y\n //float EPS=0.001; ish.\n //loop accumulators:\n float t=.0,     // t=distanceToCamera (without epsilon)\n       g=.0;     // VolumeMarched smoothstep glow: +=lerp((exp(-SquaredDistanceToGlowCenter)))\n vec2  r=vec2(0);// .x=distanceToSurface .y=MaterialID\n for (float i = 0.; i < iterMax; i++){\n     vec3 p=ro + rd * t;//pointOnRay\n     vec2 r = map(p);   //shortest euclideanPointDistance to distanceField of pointOnRay.\n #ifdef DynamicEps\n     if (t>FAR|| log(t*t*EPS/r.x)>0.) break;//zFar || logEps        exits\n     //above is very basic logeps, IFF (scene is scaled properly) it relpaces the line below.\n #else\n     if (t>FAR||         EPS>r.x    ) break;//zFar || zNearSurface  exits\n #endif\n     g += smoothstep(0.,1.,1.2*exp(-dot(p,p)));//increment glow\n     t += r.x*l ;}//march along ray\n return vec3(t,g,r.y);}//vec3(distanceToCamera,GlowIntensity,MaterialID)\n\n/**/\nvoid setupCamera(out vec3 ro, out vec3 rd, vec2 uv) {\n    vec3 lookAt = vec3(0);\n    vec3 camera = vec3(0.0, 0.5, -3.6);\n    camera.xz *= rot(1.0);\n    camera.xy *= rot(T * 0.5);\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = PI / 3.; // FOV - Field of view.\n    vec3 forward = normalize(lookAt.xyz - camera.xyz);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);    \n    rd = normalize(forward + FOV * uv.x * right + FOV * uv.y * up);\n    ro = camera;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec3 pc = vec3(0.0); //pixel colour\n    vec3 lp = vec3(4.0, 5.0, -2.0);\n    lc = palette(T * 0.05);\n    float pulse = (sin(T * 16.0) + 1.0) * 0.5;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n \n    vec3 ro, rd;\n    setupCamera(ro, rd, uv);\t\n\n    vec3 t = marchScene(ro, rd);\n    \n    if (t.x > 0.0 && t.x < FAR) {\n        vec3 rp = ro + rd * t.x;\n        float edge = 0.0;\n        vec3 n = normal(rp, edge);\n        vec3 ld = normalize(lp - rp);\n        float diff = clamp(dot(n, ld), 0.0, 1.0);\n        float fres = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 64.0);;\n        vec3 refl = reflect(n, rd);    \n        float spec = pow(clamp(dot(refl, rd), 0.0, 1.0), 16.0);\n        \n        float rt = length(rp);   \n        \n        pc += edge * palette(t.z * 0.1 + T * 0.1) * 2.0 * exp(rt * -rt * 0.8);;\n        pc += spec * lc * exp(rt * -rt) * clamp(pulse, 0.1, 1.0);    \n        \n        pc += vec3(1.0) * diff / (rt * rt * rt);\n        pc += lc * exp(rt * -rt * 0.6) * diff * clamp(pulse, 0.1, 1.0);\n        pc += lc * t.y * clamp(pulse, 0.1, 1.0);\n        \n        pc += vec3(0.8, 0.0, 0.3) * max(n.y, 0.0) * 0.02;\n    }\n\n    float gfog = 1.0 - exp(-t.x * t.x * 0.1 / FAR);\n    pc = mix(pc, vec3(0.0), gfog);\n    \n\tfragColor = vec4(sqrt(clamp(pc, 0., 1.)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lfyRX.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1056, 1198, 1217, 1217, 1263], [1264, 1264, 1285, 1285, 1352], [1376, 1464, 1490, 1490, 1702], [1704, 1704, 1742, 1742, 1844], [1846, 2066, 2097, 2097, 2150], [2152, 2152, 2171, 2171, 2629], [2631, 2644, 2682, 2682, 3781], [3783, 3815, 3850, 3850, 5035], [5086, 5091, 5144, 5144, 5629], [5631, 5631, 5686, 5686, 7029]]}
{"id": "4lfyz2", "name": "Psychedelic Triangles Dipole", "author": "ttoinou", "description": "Tweaking [url]https://www.shadertoy.com/view/MdjBDm[/url]. Click for removing continuity (abs())", "tags": ["zoom", "spiral", "tiling", "infinite", "dipole", "pinwheel"], "likes": 16, "viewed": 461, "date": "1505416680", "time_retrieved": "2024-06-20T19:00:22.366166", "image_code": "#define SHOW_DUAL_POINTS 1\n#define SHOW_SEGMENTS 1\n\n#define PI 3.14159265359\n        \nvec2 polar( float k , float t )\n{\n  return k*vec2(cos(t),sin(t));\n}\n\nvec2 cpow( vec2 z , float p )  { return polar(pow(dot(z,z),p/2.),atan(z.y,z.x)*p); }\nvec2 cnorm( vec2 z )  { return z/length(z); }\nvec2 cmuli( vec2 z )  { return vec2( -z.y , z.x ); }\nvec2 cconj( vec2 z )  { return vec2( z.x , -z.y ); }\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 cexp( vec2 z ) { return polar(exp(z.x) , z.y ); }\nvec2 clog( vec2 z ) { return vec2( log(length(z)) , atan(z.y , z.x) ); }\nvec2 cdiv( vec2 a, vec2 b )  { float d = dot(b,b); return vec2( dot(a,b), a.y*b.x - a.x*b.y ) / d; }\n\n\n// segment.x is distance to closest point\n// segment.y is barycentric coefficient for closest point\n// segment.z is length of closest point on curve, on the curve, starting from A\n// segment.a is approximate length of curve\nvec4 segment( vec2 p, vec2 a, vec2 b )\n{\n  a -= p;\n  b -= p;\n  vec3 k = vec3( dot(a,a) , dot(b,b) , dot(a,b) );\n  float t = (k.x - k.z)/( k.x + k.y - 2.*k.z );\n  float len = length(b-a);\n    \n  if( t < 0. ){\n      return vec4( sqrt(k.x) , 0. , 0. , len );\n  } else if( t > 1. ){\n      return vec4( sqrt(k.y) , 1. , len , len );\n  } else {\n  \treturn vec4( length(a*(1.-t) + b*t) , t , t*len , len );\n  }\n}\n\n// https://www.shadertoy.com/view/4djSRW\n#define ITERATIONS 4\n\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 hash3point(vec2 p)\n{\n    //vec3 col = hash32(p);\n    vec3 col = \n            hash32(p*1.25672+vec2(.2,.8))\n          * hash32(vec2(p.y,p.x)/3.42464-vec2(.5,.0))\n          - hash32(vec2(3.0+p.y,1.2))\n    ;\n    \n    return pow(\n        (abs(col)+max(col,0.0))/2.0\n        , vec3(.6,.5,.4)\n    );\n}\n\nfloat smoothFunction(float k)\n{\n    return 1.0 / ( 1.0 + k*k );\n}\n\nvec3 smoothFunction(vec3 k)\n{\n    return 1.0 / ( 1.0 + k*k );\n}\n\n\nfloat coeffDistPoint(vec2 uv,vec2 colPoint,float scale)\n{    \n    //float dist = length(uv - colPoint) * scale;\n    //dist = pow(dist,0.25);\n    //dist = 1.0 - smoothstep(0.0,1.0,dist);\n    \n    vec2 uv_ = (uv - colPoint)*scale*24.0;\n    float dist = dot(uv_,uv_);\n    return  1.0 / ( 1.0 + dist );\n}\n\nvoid mixColorPoint(vec2 uv,inout vec3 col,vec2 colPoint,float scale)\n{\n    col = mix(\n        col , \n        hash3point(colPoint) ,\n        coeffDistPoint(uv,colPoint,scale)\n    );\n}\n\n\nvec3 mixColorLine(vec2 uv,vec3 currentCol,vec3 colLine,vec2 lineA,vec2 lineB,float scale)\n{\n    return mix(\n        currentCol , \n        colLine ,\n        1.0 - smoothstep(0.0,1.0,sqrt(sqrt( segment(uv,lineA,lineB).x * scale )))\n    );\n}\n\nbool pointsOnSameSideOfLine(vec2 pointA,vec2 pointB,vec2 lineA, vec2 lineB)\n{\n    vec2 n = lineB - lineA;\n    n = vec2(n.y,-n.x);\n    return  dot(pointA-lineA,n)\n          * dot(pointB-lineA,n)\n    > 0.0;\n}\n\n\nfloat viewportMagnify = 1.0;\nvec2 screenToViewport(vec2 uv)\n{\n    return (uv - iResolution.xy/2.0 ) / min(iResolution.x,iResolution.y) * viewportMagnify;\n}\n\nvec2 viewportToScreen(vec2 uv,vec2 base)\n{\n    return (uv - base/4.0) / viewportMagnify * min(iResolution.x,iResolution.y) +  iResolution.xy/2.0;\n    //return (uv - iResolution.xy/2.0 ) / min(iResolution.x,iResolution.y) * viewportMagnify;\n}\n\n\nstruct Pinwheel\n{\n    vec2 A; // Right angle, divided into 1 acute and 1 obtuse\n    vec2 B; // Acute angle, stays acute\n    vec2 C; // Obtuse angle, stays obtuse\n    \n    vec2 D; // on GA\n    vec2 E; // on AB\n    vec2 F; // on BC, close to B\n    vec2 G; // on BC, close to C\n    \n    float r;\n    float ID;\n    float ID2;\n};\n\n    \nfloat det22(vec2 a,vec2 b)\n{\n    return a.x*b.y - a.y*b.x;\n}\n\nvec3 barycentricCoordinate(vec2 P,Pinwheel T)\n{\n    vec2 PA = P - T.A;\n    vec2 PB = P - T.B;\n    vec2 PC = P - T.C;\n    \n    vec3 r = vec3(\n        det22(PB,PC),\n        det22(PC,PA),\n        det22(PA,PB)\n    );\n    \n    return r / (r.x + r.y + r.z);\n}\n    \n    \n#define EQUERRE_COPY(T,Q) \\\n    T.A = Q.A; \\\n    T.B = Q.B; \\\n    T.C = Q.C; \\\n    T.ID = Q.ID; \\\n    T.ID2 = Q.ID2; \\\n    T.r = Q.r; \n    \n#define EQUERRE_COMPUTE_DEFG(T) \\\n\tT.E = (T.A + T.B)/2.0; \\\n\tT.F = (3.0 * T.B + 2.0 * T.C)/5.0; \\\n\tT.G = (T.B + 4.0 * T.C)/5.0; \\\n\tT.D = (T.G + T.A)/2.0;\n    \n#define EQUERRE_GET1(T,Q) \\\n\tT.A = Q.F; \\\n    T.B = Q.B; \\\n    T.C = Q.E;\n\n#define EQUERRE_GET2(T,Q) \\\n\tT.A = Q.F; \\\n    T.B = Q.G; \\\n    T.C = Q.E;\n\n#define EQUERRE_GET3(T,Q) \\\n\tT.A = Q.D; \\\n    T.B = Q.E; \\\n    T.C = Q.G;\n\n#define EQUERRE_GET4(T,Q) \\\n\tT.A = Q.D; \\\n    T.B = Q.E; \\\n    T.C = Q.A;\n\n#define EQUERRE_GET5(T,Q) \\\n\tT.A = Q.G; \\\n    T.B = Q.A; \\\n    T.C = Q.C;\n\n#define EQUERRE_COND_12_345(X,T) \\\n\tpointsOnSameSideOfLine(X,T.F,T.E,T.G)\n \n#define EQUERRE_COND_1_2(X,T) \\\n\tpointsOnSameSideOfLine(X,T.B,T.E,T.F)\n\n#define EQUERRE_COND_34_5(X,T) \\\n\tpointsOnSameSideOfLine(X,T.E,T.A,T.G)\n        \n#define EQUERRE_COND_3_4(X,T) \\\n\tpointsOnSameSideOfLine(X,T.G,T.E,T.D)\n        \n#define EQUERRE_CENTER(T) ((T.A+T.B+T.C)/3.0)\n\n        \n\n// Base Triangle\nPinwheel Tri;\n\nfloat TriangleAngle;\n//float k = 1./(1. - sqrt(3.)*.5);\nfloat RadiusCoeff;\nfloat AngleCoeff;\nfloat k;\n\nvec2 A,B,C,D,E,F,G,H;\nbool AB,BC,CD,DA;\n\n\nfloat logZoom = 0.;\nfloat angleShift = 0.;\n\n#define POINT_SPIRAL(n,m) (polar( pow(k,(n + logZoom)/2.) , (n)*AngleCoeff + m*PI/2. - angleShift ))\n// why nPI/3 and not nPI/6 ???????????????????????????\n\nvoid ComputeSpiralPoints(float r)\n{\n    A = POINT_SPIRAL(r,0.);\n    B = POINT_SPIRAL(r,1.);\n    C = POINT_SPIRAL(r,2.);\n    D = POINT_SPIRAL(r,3.);\n    \n    E = POINT_SPIRAL(r+1.,3.);\n    F = POINT_SPIRAL(r+1.,0.);\n    G = POINT_SPIRAL(r+1.,1.);\n    H = POINT_SPIRAL(r+1.,2.);\n}\n\n\nbool FindTriangle(float r,vec2 uv)\n{\n    ComputeSpiralPoints(r);\n    \n    AB = !pointsOnSameSideOfLine(uv,C,A,B);\n    BC = !pointsOnSameSideOfLine(uv,D,B,C);\n    CD = !pointsOnSameSideOfLine(uv,A,C,D);\n    DA = !pointsOnSameSideOfLine(uv,B,D,A);\n    \n    Tri.r = r;\n    bool k = true;\n    \n    if(AB && !BC)\n    {\n        Tri.A = B;\n        Tri.B = E;\n        Tri.C = F;\n        Tri.ID = r*4.+0.;\n    }\n    else if(BC && !CD)\n    {\n        Tri.A = C;\n        Tri.B = F;\n        Tri.C = G;\n        Tri.ID = r*4.+1.;\n    }\n    else if(CD && !DA)\n    {\n        Tri.A = D;\n        Tri.B = G;\n        Tri.C = H;\n        Tri.ID = r*4.+2.;\n    }\n    else if(DA && !AB)\n    {\n        Tri.A = A;\n        Tri.B = H;\n        Tri.C = E;\n        Tri.ID = r*4.+3.;\n    }\n    else\n    {\n        //return AB || BC || CD || DA;\n        k = false;\n    }\n    \n    return k;\n}\n\nvec2 deformation_pole = vec2(.1,.0);\n\nvec2 deformation( vec2 uv )\n{\n    //uv = cpow(uv,2.)*2.5;\n    uv = cmul( uv + deformation_pole , uv - deformation_pole );\n    uv = cpow(uv, mix( -.15 , .5 , (cos(-.4+iTime/sqrt(13.))+1.)/2. ) );\n    \n    if(iMouse.z < .5 )\n    //  uv = abs(uv);\n    uv.y = abs(uv.y);\n    \n    \n    //uv = cdiv( uv + deformation_pole , uv - deformation_pole );\n    //uv = cdiv(vec2(1.,0.),uv);\n    return uv;\n    //return clog( uv + deformation_pole ) - clog( uv - deformation_pole );\n    //return cexp( cdiv( uv + deformation_pole , clog( uv - deformation_pole ) ) );\n}\n\nvec2 deformation_inverse(vec2 def )\n{\n    return cdiv(2.*deformation_pole,def -  vec2(1.,0.)) + deformation_pole;\n}\n\nfloat qLimit;\n\n\n\nvec3 colorTriangle(vec2 uv_s,Pinwheel Tri)\n{\n    \n    vec3 col = hash3point(vec2(\n        // coloring algorithm\n        Tri.ID+cos(Tri.ID2),sin(Tri.ID*3.)-Tri.ID2\n    ));\n    \n    //col = vec3(1.);\n    \n    //vec3 col = hash3point(vec2(Tri.ID,Tri.ID*Tri.ID));\n    \n    /*Tri.A = deformation_inverse(Tri.A);\n    Tri.B = deformation_inverse(Tri.B);\n    Tri.C = deformation_inverse(Tri.C);\n    uv_s = uv;*/\n\n    float scale = 1./viewportMagnify/(1. + dot(uv_s,uv_s)*1.); // LOG correction\n    vec3 EquerreColor = vec3(0.0,0.0,0.0);\n    \n    \n    \n    #if SHOW_SEGMENTS==1\n        #define OPERATION1(x,y) col = mixColorLine(uv_s,col,EquerreColor,x,y,scale);\n    \tOPERATION1(Tri.A,Tri.B);\n    \tOPERATION1(Tri.B,Tri.C);\n    \tOPERATION1(Tri.C,Tri.A);\n    #endif\n    \n    \n    scale /= 3.;\n    vec2 TriCenterMix = (Tri.A + Tri.B + Tri.C)/3.;\n   // TriCenterMix = Tri.B;\n    \n    #if SHOW_DUAL_POINTS==1\n        col *= 3.*(.5 + coeffDistPoint(uv_s,TriCenterMix,scale));\n        //col *= 1. - coeffDistPoint(uv_s,TriCenterMix,scale);\n    #endif\n    \n    return col*2./(1. + dot(uv_s,uv_s)/1e3 );\n}\n\nvec3 color(vec2 uv_s)\n{\n    float r = floor( log(dot(uv_s,uv_s))/log(k) - logZoom );\n    \n    \n    if( !FindTriangle(r+1.,uv_s) )\n    {\n        // inside circle\n        FindTriangle(r,uv_s);\n    }\n    \n    \n    \n\tint nbIterations = 6;\n    \n    Pinwheel Tri_TMP;\n    Tri.ID2 = 0.;\n    \n    bool direction = false;\n    #define ID_DIRECTION(x) (direction ? 4.-x : x)\n      \n    EQUERRE_COPY(Tri_TMP,Tri);\n    float q;\n    qLimit = ( 1. / mix( 1. , 1./.14  , iMouse.x/iResolution.x ) )/5.*viewportMagnify;\n    qLimit = .1;\n    \n    for(int i = 0 ; i < nbIterations ; i++)\n    {\n        Tri_TMP.ID2 *= 5.;\n        EQUERRE_COMPUTE_DEFG(Tri);\n        \n        if( EQUERRE_COND_12_345(uv_s,Tri) )\n        {\n            if( EQUERRE_COND_1_2(uv_s,Tri) )\n            {\n            \tEQUERRE_GET1(Tri_TMP,Tri);\n                Tri_TMP.ID2 += ID_DIRECTION(0.);\n            }\n            else\n            {\n            \tEQUERRE_GET2(Tri_TMP,Tri);\n                Tri_TMP.ID2 += ID_DIRECTION(1.);\n                direction = !direction;\n            }\n        }\n        else if( EQUERRE_COND_34_5(uv_s,Tri) )\n        {\n            if( EQUERRE_COND_3_4(uv_s,Tri) )\n            {\n            \tEQUERRE_GET3(Tri_TMP,Tri);\n                Tri_TMP.ID2 += ID_DIRECTION(2.);\n                direction = !direction;\n            }\n            else\n            {\n            \tEQUERRE_GET4(Tri_TMP,Tri);\n                Tri_TMP.ID2 += ID_DIRECTION(3.);\n            }\n        }\n        else \n        {\n            EQUERRE_GET5(Tri_TMP,Tri);\n            Tri_TMP.ID2 += ID_DIRECTION(4.);\n        }\n        \n        q = length(Tri_TMP.B - Tri_TMP.A)/qLimit;\n        if( q < 1. )\n        {\n            break;\n        }\n        else\n        {\n        \tEQUERRE_COPY(Tri,Tri_TMP);\n        }\n    }\n    \n    \n    \n    \n    q = max( \n        (q-1./sqrt(5.))/(1. - 1./sqrt(5.))\n        // nice effects here\n        //* pow(viewportMagnify/length(uv_s),.75)\n        * 1.\n    , 0. );\n    \n    return mix(\n        colorTriangle(uv_s,Tri),\n        colorTriangle(uv_s,Tri_TMP),\n        smoothstep(0.,1.,sqrt(q))\n    );\n    \n    //return colorTriangle(uv_s,Tri);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float A = ( -cos(iTime / 23.) + 1. )/2.*.3;\n    TriangleAngle = atan(2.); // Pinwheel\n    //TriangleAngle = PI/3.; // Equerre\n    TriangleAngle -= A;\n    \n    //PI * ( mix( 1./12. ,  1./4. ,  iMouse.x/iResolution.x ) + .333 );\n    \n    angleShift = -iTime*.25;\n    logZoom = -iTime/sqrt(3.) + cos(iTime/2.)*.4;\n    \n    RadiusCoeff = 1. / ( 1./tan(TriangleAngle) - 1. );\n    k = 1. + 2.*(RadiusCoeff * (1. + RadiusCoeff ) );\n    \n    AngleCoeff = asin( - RadiusCoeff / sqrt(k) );\n    \n\tvec2 uv = screenToViewport(fragCoord.xy );\n    //uv *= mat2(cos(iTime/6.+vec4(0.,1.6,-1.6,0.)));\n    \n    vec2 uv_s = deformation(uv);\n    \n    viewportMagnify = 1.;\n    //uv_s *= viewportMagnify;\n    \n    \n    fragColor.rgb = color(uv_s);\n    fragColor.rgb = tanh(fragColor.rgb * 26. / (.2 + qLimit/viewportMagnify*16.)  ); // LOG correction\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lfyz2.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[86, 86, 119, 119, 153], [155, 155, 187, 187, 239], [240, 240, 263, 263, 285], [286, 286, 309, 309, 338], [339, 339, 362, 362, 391], [392, 392, 422, 422, 477], [478, 478, 499, 499, 532], [533, 533, 554, 554, 605], [606, 606, 636, 636, 706], [709, 933, 973, 973, 1337], [1667, 1778, 1799, 1799, 1920], [1922, 1922, 1947, 1975, 2222], [2224, 2224, 2255, 2255, 2289], [2291, 2291, 2320, 2320, 2354], [2357, 2357, 2414, 2542, 2657], [2659, 2659, 2729, 2729, 2841], [2844, 2844, 2935, 2935, 3082], [3084, 3084, 3161, 3161, 3290], [3322, 3322, 3354, 3354, 3448], [3450, 3450, 3492, 3492, 3691], [4025, 4025, 4053, 4053, 4085], [4087, 4087, 4134, 4134, 4340], [5713, 5769, 5804, 5804, 6047], [6050, 6050, 6086, 6086, 6906], [6946, 6946, 6975, 7003, 7498], [7500, 7500, 7537, 7537, 7615], [7634, 7634, 7678, 7678, 8721], [8723, 8723, 8746, 8746, 10845], [10847, 10847, 10904, 10904, 11739]]}
{"id": "4llcRj", "name": "Crossy Cath", "author": "jniac", "description": "Smooth cross shaped gradients\nDrag to zoom in / out.", "tags": ["simple", "colors", "2dgradient"], "likes": 0, "viewed": 137, "date": "1505514967", "time_retrieved": "2024-06-20T19:00:22.366166", "image_code": "float PI = 3.14159265359;\nfloat PI2 = 6.28318530718;\n\nfloat map(float n, float nMin, float nMax) {\n\treturn (n - nMin) / (nMax - nMin);\n}\nfloat mapClamp(float n, float nMin, float nMax) {\n\treturn n < nMin ? 0. : n > nMax ? 1. : (n - nMin) / (nMax - nMin);\n}\nfloat gain(float x, float p) {\n\treturn (x < .5 ? .5 * pow(abs(2. * x), p) : 1. - .5 * pow(abs(2. * (1. - x)), p));\n}\nvec2 gain(vec2 v, float p) {\n\treturn vec2(gain(v.x, p), gain(v.y, p));\n}\nvec3 gain(vec3 v, float p) {\n\treturn vec3(gain(v.x, p), gain(v.y, p), gain(v.z, p));\n}\n\n\nfloat min4(float a, float b, float c, float d) {\n    return min(min(a, b), min(c, d));\n}\nvec2 scale(vec2 v, float s) {\n    return v * s - (s - 1.) / 2.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 st = fragCoord.xy / iResolution.y;\n    st.x += -(iResolution.x / iResolution.y - 1.) / 2.;\n    vec3 color = vec3(0.0);\n    \n    vec2 mouseR = iMouse.xy / iResolution.xy;\n    \n    float x = smoothstep(.2, .8, mouseR.x);\n    st = scale(st, mix(.7, .1, x));\n    st += mix(0., .4, x);\n    \n//    if (mouseR.x < 1./3.) {\n//\t    st = scale(st, .8);\n//    } else if (mouseR.x < 2./3.) {\n//        st *= .5;\n//        st += .5;\n//    } else {\n//        st = scale(st, .2);\n//        st += .35;\n//    }\n    \n    // bottom-left\n    vec2 margin = vec2(-0.090, -0.090);\n    float s = 1.964;\n    vec2 bl = smoothstep(margin - s / 2., margin + s / 2., st); \n    vec2 tr = smoothstep(margin - s / 2., margin + s / 2., 1.0 - st);\n\t\n    vec3 pct = vec3(min4(bl.x, bl.y, tr.x, tr.y));\n    float p = bl.x * bl.y * tr.x * tr.y;\n    pct = mix(pct, vec3(p), vec3(8., 7., 9.));\n\n    pct = gain(pct, 4.);\n    \n    float t = 5.880;\n    t += iTime;\n    t += PI2 * mouseR.y;\n    color = sin(pct * PI + t * 1.);\n    \n    color = color.rgb + color.bbb - color.ggg * 3.;\n    //color = sin(color + vec3(1,2,3));\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4llcRj.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[54, 54, 98, 98, 136], [137, 137, 186, 186, 256], [257, 257, 287, 287, 373], [374, 374, 402, 402, 446], [447, 447, 475, 475, 533], [536, 536, 584, 584, 624], [625, 625, 654, 654, 690], [692, 692, 749, 749, 1879]]}
{"id": "4lscDr", "name": "Fractal Land Nyan Cat", "author": "Profesor08", "description": "Fractal Land Nyan Cat", "tags": ["3d", "fractal", "webgl"], "likes": 2, "viewed": 281, "date": "1504394014", "time_retrieved": "2024-06-20T19:00:23.438693", "image_code": "// \"Fractal Cartoon\" - former \"DE edge detection\" by Kali\n\n// Cartoon-like effect using eiffies's edge detection found here: \n// https://www.shadertoy.com/view/4ss3WB\n// I used my own method previously but was too complicated and not compiling everywhere.\n// Thanks to the suggestion by WouterVanNifterick. \n\n// There are no lights and no AO, only color by normals and dark edges.\n\n// update: Nyan Cat cameo, thanks to code from mu6k: https://www.shadertoy.com/view/4dXGWH\n\n\n// #define SHOWONLYEDGES\n#define NYAN \n#define WAVES\n//#define BORDER\n\n#define RAY_STEPS 150\n\n#define BRIGHTNESS 1.2\n#define GAMMA 1.4\n#define SATURATION .65\n\n\n#define detail .001\n#define t iTime*.5\n\n\nconst vec3 origin=vec3(-1.,.7,0.);\nfloat det=0.0;\n\n\n// 2D rotation function\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\n// \"Amazing Surface\" fractal\nvec4 formula(vec4 p) {\n\t\tp.xz = abs(p.xz+1.)-abs(p.xz-1.)-p.xz;\n\t\tp.y-=.25;\n\t\tp.xy*=rot(radians(35.));\n\t\tp=p*2./clamp(dot(p.xyz,p.xyz),.2,1.);\n\treturn p;\n}\n\n// Distance function\nfloat de(vec3 pos) {\n#ifdef WAVES\n\tpos.y+=sin(pos.z-t*6.)*.15; //waves!\n#endif\n\tfloat hid=0.;\n\tvec3 tpos=pos;\n\ttpos.z=abs(3.-mod(tpos.z,6.));\n\tvec4 p=vec4(tpos,1.);\n\tfor (int i=0; i<4; i++) {p=formula(p);}\n\tfloat fr=(length(max(vec2(0.),p.yz-1.5))-1.)/p.w;\n\tfloat ro=max(abs(pos.x+1.)-.3,pos.y-.35);\n\t\t  ro=max(ro,-max(abs(pos.x+1.)-.1,pos.y-.5));\n\tpos.z=abs(.25-mod(pos.z,.5));\n\t\t  ro=max(ro,-max(abs(pos.z)-.2,pos.y-.3));\n\t\t  ro=max(ro,-max(abs(pos.z)-.01,-pos.y+.32));\n\tfloat d=min(fr,ro);\n\treturn d;\n}\n\n\n// Camera path\nvec3 path(float ti) {\n\tti*=1.5;\n\tvec3  p=vec3(sin(ti),(1.-sin(ti*2.))*.5,-ti*5.)*.5;\n\treturn p;\n}\n\n// Calc normals, and here is edge detection, set to variable \"edge\"\n\nfloat edge=0.;\nvec3 normal(vec3 p) { \n\tvec3 e = vec3(0.0,det*5.,0.0);\n\n\tfloat d1=de(p-e.yxx),d2=de(p+e.yxx);\n\tfloat d3=de(p-e.xyx),d4=de(p+e.xyx);\n\tfloat d5=de(p-e.xxy),d6=de(p+e.xxy);\n\tfloat d=de(p);\n\tedge=abs(d-0.5*(d2+d1))+abs(d-0.5*(d4+d3))+abs(d-0.5*(d6+d5));//edge finder\n\tedge=min(1.,pow(edge,.55)*15.);\n\treturn normalize(vec3(d1-d2,d3-d4,d5-d6));\n}\n\n\n// Used Nyan Cat code by mu6k, with some mods\n\nvec4 rainbow(vec2 p)\n{\n\tfloat q = max(p.x,-0.1);\n\tfloat s = sin(p.x*7.0+t*70.0)*0.08;\n\tp.y+=s;\n\tp.y*=1.1;\n\t\n\tvec4 c;\n\tif (p.x>0.0) c=vec4(0,0,0,0); else\n\tif (0.0/6.0<p.y&&p.y<1.0/6.0) c= vec4(255,43,14,255)/255.0; else\n\tif (1.0/6.0<p.y&&p.y<2.0/6.0) c= vec4(255,168,6,255)/255.0; else\n\tif (2.0/6.0<p.y&&p.y<3.0/6.0) c= vec4(255,244,0,255)/255.0; else\n\tif (3.0/6.0<p.y&&p.y<4.0/6.0) c= vec4(51,234,5,255)/255.0; else\n\tif (4.0/6.0<p.y&&p.y<5.0/6.0) c= vec4(8,163,255,255)/255.0; else\n\tif (5.0/6.0<p.y&&p.y<6.0/6.0) c= vec4(122,85,255,255)/255.0; else\n\tif (abs(p.y)-.05<0.0001) c=vec4(0.,0.,0.,1.); else\n\tif (abs(p.y-1.)-.05<0.0001) c=vec4(0.,0.,0.,1.); else\n\t\tc=vec4(0,0,0,0);\n\tc.a*=.8-min(.8,abs(p.x*.08));\n\tc.xyz=mix(c.xyz,vec3(length(c.xyz)),.15);\n\treturn c;\n}\n\nvec4 nyan(vec2 p)\n{\n\tvec2 uv = p*vec2(0.4,1.0);\n\tfloat ns=3.0;\n\tfloat nt = iTime*ns; nt-=mod(nt,240.0/256.0/6.0); nt = mod(nt,240.0/256.0);\n\tfloat ny = mod(iTime*ns,1.0); ny-=mod(ny,0.75); ny*=-0.05;\n\tvec4 color = texture(iChannel1,vec2(uv.x/3.0+210.0/256.0-nt+0.05,.5-uv.y-ny));\n\tif (uv.x<-0.3) color.a = 0.0;\n\tif (uv.x>0.2) color.a=0.0;\n\treturn color;\n}\n\n\n// Raymarching and 2D graphics\n\nvec3 raymarch(in vec3 from, in vec3 dir) \n\n{\n\tedge=0.;\n\tvec3 p, norm;\n\tfloat d=100.;\n\tfloat totdist=0.;\n\tfor (int i=0; i<RAY_STEPS; i++) {\n\t\tif (d>det && totdist<25.0) {\n\t\t\tp=from+totdist*dir;\n\t\t\td=de(p);\n\t\t\tdet=detail*exp(.13*totdist);\n\t\t\ttotdist+=d; \n\t\t}\n\t}\n\tvec3 col=vec3(0.);\n\tp-=(det-d)*dir;\n\tnorm=normal(p);\n#ifdef SHOWONLYEDGES\n\tcol=1.-vec3(edge); // show wireframe version\n#else\n\tcol=(1.-abs(norm))*max(0.,1.-edge*.8); // set normal as color with dark edges\n#endif\t\t\n\ttotdist=clamp(totdist,0.,26.);\n\tdir.y-=.02;\n\tfloat sunsize=7.-max(0.,texture(iChannel0,vec2(.6,.2)).x)*5.; // responsive sun size\n\tfloat an=atan(dir.x,dir.y)+iTime*1.5; // angle for drawing and rotating sun\n\tfloat s=pow(clamp(1.0-length(dir.xy)*sunsize-abs(.2-mod(an,.4)),0.,1.),.1); // sun\n\tfloat sb=pow(clamp(1.0-length(dir.xy)*(sunsize-.2)-abs(.2-mod(an,.4)),0.,1.),.1); // sun border\n\tfloat sg=pow(clamp(1.0-length(dir.xy)*(sunsize-4.5)-.5*abs(.2-mod(an,.4)),0.,1.),3.); // sun rays\n\tfloat y=mix(.45,1.2,pow(smoothstep(0.,1.,.75-dir.y),2.))*(1.-sb*.5); // gradient sky\n\t\n\t// set up background with sky and sun\n\tvec3 backg=vec3(0.5,0.,1.)*((1.-s)*(1.-sg)*y+(1.-sb)*sg*vec3(1.,.8,0.15)*3.);\n\t\t backg+=vec3(1.,.9,.1)*s;\n\t\t backg=max(backg,sg*vec3(1.,.9,.5));\n\t\n\tcol=mix(vec3(1.,.9,.3),col,exp(-.004*totdist*totdist));// distant fading to sun color\n\tif (totdist>25.) col=backg; // hit background\n\tcol=pow(col,vec3(GAMMA))*BRIGHTNESS;\n\tcol=mix(vec3(length(col)),col,SATURATION);\n#ifdef SHOWONLYEDGES\n\tcol=1.-vec3(length(col));\n#else\n\tcol*=vec3(1.,.9,.85);\n#ifdef NYAN\n\tdir.yx*=rot(dir.x);\n\tvec2 ncatpos=(dir.xy+vec2(-3.+mod(-t,6.),-.27));\n\tvec4 ncat=nyan(ncatpos*5.);\n\tvec4 rain=rainbow(ncatpos*10.+vec2(.8,.5));\n\tif (totdist>8.) col=mix(col,max(vec3(.2),rain.xyz),rain.a*.9);\n\tif (totdist>8.) col=mix(col,max(vec3(.2),ncat.xyz),ncat.a*.9);\n#endif\n#endif\n\treturn col;\n}\n\n// get camera position\nvec3 move(inout vec3 dir) {\n\tvec3 go=path(t);\n\tvec3 adv=path(t+.7);\n\tfloat hd=de(adv);\n\tvec3 advec=normalize(adv-go);\n\tfloat an=adv.x-go.x; an*=min(1.,abs(adv.z-go.z))*sign(adv.z-go.z)*.7;\n\tdir.xy*=mat2(cos(an),sin(an),-sin(an),cos(an));\n    an=advec.y*1.7;\n\tdir.yz*=mat2(cos(an),sin(an),-sin(an),cos(an));\n\tan=atan(advec.x,advec.z);\n\tdir.xz*=mat2(cos(an),sin(an),-sin(an),cos(an));\n\treturn go;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy*2.-1.;\n\tvec2 oriuv=uv;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec2 mouse=(iMouse.xy/iResolution.xy-.5)*3.;\n\tif (iMouse.z<1.) mouse=vec2(0.,-0.05);\n\tfloat fov=.9-max(0.,.7-iTime*.3);\n\tvec3 dir=normalize(vec3(uv*fov,1.));\n\tdir.yz*=rot(mouse.y);\n\tdir.xz*=rot(mouse.x);\n\tvec3 from=origin+move(dir);\n\tvec3 color=raymarch(from,dir); \n\t#ifdef BORDER\n\tcolor=mix(vec3(0.),color,pow(max(0.,.95-length(oriuv*oriuv*oriuv*vec2(1.05,1.1))),.3));\n\t#endif\n\tfragColor = vec4(color,1.);\n}", "image_inputs": [{"id": "Xsf3Rn", "previewfilepath": "/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture"}, {"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lscDr.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[728, 752, 771, 771, 818], [820, 849, 871, 871, 1004], [1006, 1027, 1047, 1047, 1532], [1535, 1550, 1571, 1571, 1647], [1649, 1733, 1754, 1754, 2074], [2077, 2124, 2146, 2146, 2885], [2887, 2887, 2906, 2906, 3242], [3245, 3277, 3321, 3321, 5121], [5123, 5146, 5173, 5173, 5542], [5544, 5544, 5601, 5601, 6111]]}
{"id": "4lscRl", "name": "specular on ellipsoid", "author": "FabriceNeyret2", "description": "play with mouse and observe how specular is trapped in high curvature areas.\nuncomment bump or edit light dir if you wish.", "tags": ["raytracing", "sphere", "shading", "curvature", "perception"], "likes": 0, "viewed": 486, "date": "1506009990", "time_retrieved": "2024-06-20T19:00:23.438693", "image_code": "#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nvoid mainImage( out vec4 O, vec2 U ) {\t\n    O-=O;\n\tvec2 r = iResolution.xy, \n         M = iMouse.xy;\n    if (length(M)<5.) M = (.5+.5*.3*vec2(sin(iTime),cos(1.7*iTime)) )*r; // autodemo\n#define frame(U)  (U+U - r) /r.y\n         U = frame(U)*.7;\n         M = frame(M)*3.;\n    \n\tvec3 R  = vec3(1,.4,.1),              // 3 lengths of the ellipsoid\n         L  = vec3(0,0,1),                // light dir\n       //L  = vec3(0,1,0),                \n         ro = vec3(0,0,5),                // camera com\n         rd = normalize(vec3(U,-4));      // ray dir\n    mat2 Ra = rot(M.x),\n         Rb = rot(M.y); \n    ro.xz *= Ra; ro.yz *= Rb;             // goto ellipsoid frame ( rotations )\n    rd.xz *= Ra; rd.yz *= Rb;\n    \n   vec3  eo = ro/R, ed = rd/R;            // goto sphere frame ( scaling by 1/R )\n    float A = dot(ed,ed),                 // solve ray - sphere intersection :\n          B = dot(ed,eo),                 // P = O+l.D & |P|²=1  =>  A.l² + 2B.l + C = 0\n          C = dot(eo,eo)-1.,\n          D = B*B-A*C;\n    if (D>=0.) {\n        L = normalize(L);\n        vec3 P = ro + rd*(-B-sqrt(D))/A,  // hit point ( in ellipsoid frame )\n             N = normalize(P / (R*R) ),   // normal at hit point\n             H = normalize(L-rd);         // half-vector\n      //float s = 100.; N = normalize(N + 3.*sin(s*P)/s); // bump\n                      \n        O = vec4(1,smoothstep(1.,0.,abs(P)/.01)),   // color\n        O =  (.2 + .8* clamp(dot(N,L),0.,1.) ) *O   // ambiant & diffuse\n            + 5.*pow( clamp(dot(N,H),0.,1.), 100.); // specular\n    }\n}\n    \n    ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lscRl.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[51, 51, 89, 89, 1608]]}
{"id": "4lscW2", "name": "recursive reflections epsilon 2", "author": "ollj", "description": "working on (the illusion of) smooth infinite reflections with shadows till the horizon.", "tags": ["reflection", "shadow", "water", "fisheye", "mirror", "horizon", "dynamiceps", "edynvr"], "likes": 5, "viewed": 974, "date": "1506490095", "time_retrieved": "2024-06-20T19:00:25.590944", "image_code": "//self  : https://www.shadertoy.com/view/4lscW2\n//parent: https://www.shadertoy.com/view/4td3Dj\n//many minor improvements. I twiddledand learned a few things\n//hard to describe your progress when you basically just try somewhat random ideas\n//and only let the apparently better ones progress.\n\n//the MAX_ limit range definitions only set upper bounds.\n//that are reached exponentially, so their size barely matters.\n//\n//MAX_SHADOW_REFLECTIONS sets how many reflections will have shadows calculated for them\n#define MAX_SHADOW_REFLECTIONS 2.0\n//with 2.0, a reflection in a reflection has shadows in it. usually enough.\n//\n///MAX_DIST can easily be 1000000. but may crash in higher resolutions\n#define MAX_DIST          100.\n//note to self , with synamiceps log() , \"MAX_DIST\" changed its meaning \n// into something that is just not \"maximum distance\" of anything non fuzzyanymore.\n\n//MAX_STEPS can easily be 1000000. but may crash in higher resolutions\n#define MAX_STEPS         200.\n//MAX_HARD can be 200 to 2000, depending on hardware, but may crash in higher resolutions\n#define MAX_HARD  700\n//this is the absolute upper limit of steps per ray, including all its reflections.\n//the hardlimit is only reached in extreme cases, \n//like when the camera POSITION is already close to a surface!\n\n\n//every second pixel is skipped and left black. +20% more fps on older hardware?\n//#define doLazyDither\n//not worth it.\n\n#define doOcclusionShaddow\n//AO really helps the projection, because it is full of mirrors, confusing without AO\n#define doOcclusionAmbient\n\n#define sat(a) clamp(a,.0,1.)\n\n/*\nThis revision adds 2 LOD modes to how it approaches the surface of a gradient.\nIn a sense, this makes it similar to heavily mixing 2 LOD renders of \"spyro the dragon\"; .\n Close distance has epsilon increase over     distance² , good for mirror, bad for horizon\n Far   distance has epsilon increase over log(distance²), too much distortion for mirrors\nA lot of twiddilng is involved to make the 2 \"overlap\" nicely.\n \"overlap\" in the sense that, a ray may bounce 5 times,\n  and all accumulating precision errors of many rough estimates must be kept small.\n*/\n\n/*\nhard bugs:\n fisheye cam is more trouble than its worth, making lipschitzes bad.\n maybe replace the FishEyeCam with an orthogonal cam. \n fisheyecam is more an intentional stress-test than good looks.\n maybe do some seeded scattering on calculating a reflection.\n maybe add any texturing to this bland method-demo.\n It could need more parameters to the shadow function \n  to make it look better close up than a far.\n I have incomplete plans to include [Cauchy distribution] \n  to move shadowSamlingPoints closer to the camera.\n \n Not sure why, but shadertoy makes the color depth in reflections within reflections \n  look a lot lower than other boilerplates.\n this is likely a precision issue, unlikely a conversion error.\n*/\n\n\n/*\n Older notes from the parent version:\n\n by ollj\n goal is to allow for high render distance and high detail close to the camera\n goal is to allow for hall of mirror reflections for as long as there are steps left, \n  scatterable non-fake reflections.\n goal is to see the shadow in the reflection of a revflection of a reflection...\n goal is to have any fragment converge in the same linear time\n  where closer surfaces simply get more detail/reflections.\n Idealy a top down perspective gets the same fps than a set with an infinite horizon!\n practically, there is still a difference of 60to5 fps, but i am slowly getting to 40to40; ..\n Ambient Occlusion calculatons are draining most resources.\n\nBelow methods causes raymarching to converge more linearily\n for many very different fragments of very different scenes\n  While it also \"warps space\" towards the ray, the more steps have been taken.\n Surfaces close to the camera have low epsilon, high precision, lots of reflections.\n Surfaces far from the camera have less precision, less reflections, higher epsilon\n Surfaces/hallways that are nearrly coplanar to a ray \n  no longer have the problem of \"running out oof steps\" AT ALL.\n\nLONG RENDER DISTANCE;\nHeuristic root solving either converges too slowly or too quickly.\nif (converges too quickly) you could have more detail == larger distances instead.\nIdeally you want to modify them so that all possible cases converge roughly equally.\nThis is achieved by defining MAX_DIST and MAX_STEPS as non-static float pools\n that diminish with each raymarchng step,\nIf (any pool drains below 0) the raymarching ends before MAX_HARD iterations.\n heuristic root solving is eigher likely [too divergend] or [converging too slowly]\n these 2 extremes are constrained by draining MAX_DIST and MAX_STEPS.\nDoing many small steps drains the 2 pools reciprocally-DIFFERENTLY from, the other \n than doing many large steps!\nBoth with one (reciprocal) factor, both pools converge \"much more equally\" \n depending on \"scene openness\" because they drain by the same factor.\n\nRECURSIVE REFLECTION;\nIf (a ray hits a reflective wall) it keeps raymarching a bounched ray.\n The loop sums up a total color as sum of all reflected rays.\nA reflected ray makes up a smaller fraction of the total color.\nIf (that fraction is too small) no morere flecting of this ray happens,\nFinally, the last reflected fraction of a color is added; \n if (we run out of steps) that is \"sky\" or \"ground\" color.\nTodo, make that =mix(SkyOrGroundColor,gradientColor,reasonablyScaledDistanceToGradient)\n\nBALLACHE OF PRECISION\n (nearby) reflections need high precision of they distort too much.\n DynamicEps methods insist on low precision, tent to be very \"noisy\"\n Depending on a points distance to camera, \n  it use a differet (conditions) to determine if (a point is near a surface).\n p+=SurfaceNormal; is a necessary compromise between fast and good recursive reflections.\n*/\n\n\n#define PI acos(-1.)  \n#define PIB asin(1.)\n\n#define skyColor       vec3(.2,.5,1.)\n#define shadowColor    vec3(.2,.2,.5)\n#define groundColor    vec3(.6,1.,.7)\n#define buildingsColor vec3(.8,.7,.2)\n#define redColor       vec3(.9,.2,.7)\n//these colors visually make sense for contrast, even for red-green blindness.:\n//shadows are blue\n//ground is greener\n//floating objects are red\n//near ground objects are yellow\n#define SKY_MTL 0\n#define GROUND_MTL 1\n#define BUILDINGS_MTL 2\n#define RED_MTL 3\n\n//these defines are not too practiical:\n#define fovyCoefficient 1.\n#define shadowHardness 3.\n#define time iTime\n\n//i lost my latest cleaned up iprved version of this, \n//leaving us with this older messier version.\n\n//the ugliest thing here is that,\n//if a reflected ray runs out of steps/distance, it aborts\n//meaning it is the last reflection\n//but without dithering this looks a bit ugly\n//\n//in other versions i added fake dithering by modifying RayDirection by +=0.001\n//for each step.\n//this warps space a bit (speudo randomly), which is still fine, we call this \"gravity\" , ya know?\n\n//the main trick here is that some cases are better for (nearby) reflections \n//while others are better for ling distance surfaces.\n//and all combinations can be made almost linearily convergent.\n//the problem here is that it only starts to look good \n//with at least 500 itterations of raymarchoing\n//too much for the average 2014 hardware in useful resolutions/framerates\n\nfloat CubeDistance2 (in vec3 point, in vec3 size){return length(max(abs(point)-size,0.));}\nfloat sdHexPrism(vec3 p,vec2 h){vec3 q=abs(p);return max(q.z-h.y,max(q.x*.866025+q.y*.5,q.y)-h.x);}\nvec3 DistanceRepetition(in vec3 point, in vec3 repetition ){\n    vec3 q = mod(point, repetition)-.5*repetition;return q;}\nfloat CubeRepetition(in vec3 point, in vec3 repetition ){\n  point.x+=sin(point.y*.11+time*5.);\n  point.z+=cos(point.y*.11);\n  vec3 q = mod(point,repetition)\n  -0.5*repetition;q.y = point.y;\n  return sdHexPrism(q.zxy,vec2(10.,50));\n  return CubeDistance2 ( q, vec3 (10., 50.+sin(time)*15.,10.));}\nfloat PlaneDistance(in vec3 point,in vec3 normal,in float pDistance){return dot(point-(normal * pDistance), normal);}\nfloat modA(float x){return mod(time*.1+x+55.,230.)-55.;}\nfloat fSphere       (vec3 p,float r){return length(p)-r;}\nfloat SphereDistance(vec3 point, vec3 center, float radius){\n  point.z = modA(point.z);point.x = modA(point.x);\n  return fSphere(point-center,radius);}\nfloat RedDistance(in vec3 position){return SphereDistance(position,vec3(0.,66.,0.),30.);}\nfloat BuildingsDistance(in vec3 position){\n  return min(CubeRepetition(position                                ,vec3(80.,0., 90.)),\n\t         CubeRepetition(position+vec3(350.,sin(time)*30.,0.) ,vec3(90.,0.,100.)));}\nfloat GroundDistance(in vec3 position){return PlaneDistance(position,vec3(0.,1.,0.),0.);}\n//merging distance functions above to distanceField function below:\nfloat df(in vec3 position, out int mtl){\n    float radial=length(vec2(position.x,position.z));\n\tfloat radialSine=sin(radial*.05-time*2.)*5.;\n    float gndDistance=position.y-radialSine+6.;\n    float bldDistance=BuildingsDistance(position);\n    float redDistance=RedDistance      (position);\n                       float closest=gndDistance;mtl=   GROUND_MTL;\n    if (bldDistance<closest){closest=bldDistance;mtl=BUILDINGS_MTL;}\n    if (redDistance<closest){closest=redDistance;mtl=      RED_MTL;}\n    return closest;}\n//end of sdf geometry;\n\n//iqs famous softshadow, set to low quality\nfloat SoftShadow( in vec3 landPoint, in vec3 lightVector, float mint, float maxt, float iterations ){\n    float penumbraFactor=1.0;vec3 sphereNormal;float t=mint;\n    for(int s=0;s<20;++s){if(t > maxt) break;\n        float nextDist = min(\n            BuildingsDistance(landPoint + lightVector * t )\n            , RedDistance(landPoint + lightVector * t ));\n        if( nextDist < 0.001 ){return 0.0;}\n        penumbraFactor = min( penumbraFactor, iterations * nextDist / t );\n        t += nextDist;}return penumbraFactor;}\n\n//distance fog is no longer needed, is a relict here.\nvoid applyFog( in float distance, inout vec3 rgb ){\n    //float fogAmount = (1.0 - clamp(distance*0.0015,0.0,1.0) );\n    //float fogAmount = exp( -distance* 0.006 );\n    //vec3 fogColor = vec3(0.9,0.95,1);\n    //if(fogAmount<.6)rgb= vec3(1.,1.,0.);\n    //else rgb=clamp(rgb,0.,1.);\n    //rgb=mix(skyColor,rgb,fogAmount);\n}\n//for mad()-awareness.\nfloat mad (float b,float c,float d){return b*c+d;}\n\n//this is based on old code, with inefficient material handling:\nvec3 MaterialColor(int mtl){\n    if(mtl==      SKY_MTL) return skyColor;\n    if(mtl==BUILDINGS_MTL) return buildingsColor;\n    if(mtl==   GROUND_MTL) return groundColor;\n    if(mtl==      RED_MTL) return redColor;\n    return vec3(1.0,1.0,1.0);}\nfloat AmbientOcclusion(vec3 p,vec3 n,float d,float s){float r=1.;int t;\n  for(int i=0;i<5;++i){if(--s<0.)break;r-=(s*d-(df(p+n*s*d,t)))/pow(2.,s);}return r;}\n \n//i think THIS version of the shader solved all issues of normals, even normals with small epsilon?\n//by using a different dynamiceps close to the camera than faraway from the camera.\n//and by doing some epsilon twiddeling on the gradient itself.\n//i was tweaking this only to notice that e=0.1 is pretty much the best working value for the scenes scaling.\nvec3 ComputeNormal(vec3 pos, int material,float eps){int d;float e=.1;\n  return vec3(df(vec3(pos.x+e,pos.y  ,pos.z  ),d)-df(vec3(pos.x-e,pos.y  ,pos.z  ),d)\n             ,df(vec3(pos.x  ,pos.y+e,pos.z  ),d)-df(vec3(pos.x  ,pos.y-e,pos.z  ),d)\n             ,df(vec3(pos.x  ,pos.y  ,pos.z+e),d)-df(vec3(pos.x  ,pos.y  ,pos.z-e),d));}\n\n\n//if (near surface) do surface things\n//[p]Position [d]RayDirection [c]colorAccumulator [e]epsilon [m]materialID \n//[s]shadowReflections \n//this function gets a LOT of revision.\n//it was tricky to seperate it from the loop that it is in, to more easily modify it.\n//this is all about making code easier to edit, and not about fast parsing.\nvec3 onSurface(inout vec3 p,inout vec3 d,vec3 c,\n    int m, float e,inout float s,     inout float sg    ){\n    vec3 n=ComputeNormal(p,m,e);n=normalize(n);\n      vec3 col=MaterialColor(m);\n      if(s>.0){//if we stil calculate shadows (for this reflection)\n\t\tvec3 lightpos = vec3(250.0*sin(time*.005), 400.0 + 40.0 *cos(time*.002), 250.0*cos(time*.005));\n        lightpos=lightpos-p;vec3 lightVector=normalize(lightpos);float lightdist=length(lightpos);\n     p+=n;//this is important for good reflections but \n    // it has side effects:\n    //the gradient is measured with the same offset from surface (good)\n    //the reflection happens at that offset, which leads to a [fold] of reflection space!\n    // and to a \"holographic mirror\"\n    //as if the surface has a thickness of +1.\n    //which is not too useful for fract(), adding differentials of -1 to compensate.\n        float shadow = SoftShadow(p, lightVector, 0.3, lightdist,shadowHardness);    \n        #ifdef doOcclusionShaddow\n        if(m==BUILDINGS_MTL){col=mix(shadowColor,col,sat(p.y/7.));}\n\t\tfloat attenuation=sat(dot(n,lightVector));\n\t\tshadow=min(shadow,attenuation);col=mix(shadowColor,col,shadow);\n        #endif\n        #ifdef doOcclusionAmbient\n        float AO=AmbientOcclusion(p,n,1.,7.);col=mix(shadowColor,col,AO);\n        #endif\n         s--;}\n      float refl=.34;//surface reflectiveness\n      if (m==GROUND_MTL)refl=.3;//ground has other reflectiveness\n      c=mix(c,col,sg);//mix the color of the current ray (reflection) with the accumulated total color to be returned.\n      sg=sg*refl;if(sg<.01)return c;\n      d=d-(n*1.5*(dot(d,n)));//direction gets reflected at surface normal. \n        //*1.5 factor means we WILL likely overstp within reflections, accumulatively for each reflection.\n        //this is a reasonable fps booster for less quality in reflections.\n return c;\n}\n\n//the raimarch loop gets complicated\n//, with  \"reflections till the horizon\" and \"dual dynamicEps\"\n/*dynamiceps Raymarching;\n- started with the idea of draining 2 pools, instead of one.\n- - Let [ee] be an epsilon that increments with each step\n     or that is = log(squaredDistanceToCamera/lastStelLength)\n- - there are 2 modes for epsilon increments.\n- - - the log(squared) mode is worse fror precision of reflections\n- - - the     squared  mode is worse for long distances.\n- - - we use [b] to switch between these modes.\n- - Let n be the distance to a surface, the gradient at p.\n- - maxDist-=ee/n; drains slower for many long steps, (substract normalized gradient)\n     This allows for much larger render distance (initial motivation for this)\n- - maxSteps-=ee*n; dains slower on many short step distances of near-parallel/orbital rays,.\n     This allows for smaller epsilon (secondary motivation for this)\n- - if(one of the pools is draind) assume that our epsilon is good enough.\n- - both pools drain speed (very likely) converges quickly.\n*/\n//main raymarching loop with maxDistance and MaxSteps and epsilon changed a bit.\n//if (hits a surface) reflect!\n//returns color of fragment.\n//[o]RayOrigin [t]RayDirection \nvec3 RayMarch(vec3 o,vec3 t)\n{int mtl=0\n;vec3 hitColor\n;vec3 r;\n  float sg=1.;\n  float n= 1.;\n  float s=MAX_SHADOW_REFLECTIONS;\n  float maxDist =MAX_DIST;\n  float maxSteps=MAX_STEPS;\n  #ifndef DynamicEpsLog\n    maxSteps*=4.;//simpler steps, but more steps\n  #endif\n  int hardLimit =MAX_HARD;\n  float e     =.01;\n //main raymardching loop accumulates a color. can do so over many reflections.\n //the maximum number of sphere-tracking steps is MAX_HARD;\n //the maximum number of reflections is MAX_HARD;\n //the maximum number of surfaces that get shadow and AO calculated for them is MAX_SHADOW_REFLECTIONS\n //because AO is an inner lop, and it makes sense to constrain the O(n*m) compleity\n //by limiting m<=MAX_SHADOW_REFLECTIONS, with n==MAX_HARD;\n for(int ever=0;ever<MAX_HARD;ever++){//the ride (n)ever ends! unless [hardlimit<0] triggers a return. this lets me drain hardlöimit in the loop-\n    n=df(o,mtl);\n   float ee=mad(n,.000001,e*1.00001);\n   float l=dot(o,o);\n   o+=t*n;\n   bool b=l<MAX_DIST;//could be =sqrt(l)*2.<MAX_DIST; makes not much of a difference.here\n   if(b)e=ee;               //for long view distance\n   if(b)b=.0<log(l/n*1e-7);//for long view distance\n   else b=n+.5<e*60.;      //for better close up shadows (+<.6 for sharper corners)\n   if(b){hardLimit--;r=onSurface(o,t,r,mtl,e,s,sg);}\n   maxSteps -=ee*n;\n   maxDist  -=ee/n;\n//i am sure this can be improved a lot. but benchmarking this on different scenes takes time.\n//and i lack the theoretical undertanding to model many cases to an optimum.\t\n      if(\n         maxSteps<0.1\n       ||maxDist<=0.\n       ||hardLimit<=0\n      ){\n\t   return mix(r,skyColor,sg);//overwrite horizon noise with sky\n}\n    \n  }\n    //there are some rays that needed more than MAX_HARD steps\n    //but also never exhausted any countdown.\n    //ths hints at lipschitz discontinuity, likely due to fisheye lens transform.\n    //evaluating rays that got lost in discontinuities is never pretty.\n    //trying my best here\n    //return vec3(3);//highlight what never got near a surface\n    r=onSurface(o,t,r,mtl,e,s,sg);\n    return mix(r,skyColor,sg);//overwrite horizon noise with sky\n;}\n\n\n//dont ask why, i stuck with a BAD fisheye camera\n//, if only because it makes it easier to \"see the horizon\" in a simple fast transformation.\n//and this is all about horizon.\nvoid FishEyeCamera( vec2 screenPos, float ratio, float fovy, out vec3 position, out vec3 direction ){\n    screenPos *= vec2(ratio,fovy);\n\tfloat height=cos(time/5.);    \n\tdirection=normalize(cross(vec3(screenPos,3.0),vec3(0,1,0)));\n    direction=vec3( sin(screenPos.y+PIB)*sin(screenPos.x)\n                  ,-cos(screenPos.y+PIB)-height*.5-.4+sin(time/20.)*0.2-0.1\n                  ,-sin(screenPos.y+PIB)*cos(screenPos.x));\n\tposition=vec3(sin(time/ 6.)*100.+20.+iMouse.x\n\t              ,height       *205.+206.+iMouse.y\n\t              ,sin(time/14.)*135.+cos(time/13.)*135.)+1.0;\n\tdirection=normalize(direction);\n}\n\nvoid mainImage(out vec4 o, in vec2 u){   \n #ifdef doLazyDither\n if(mod(u.y-u.x,2.)<.5){o=vec4(0,0,.1,1); return;}\n //if(mod(u.y-u.x+floor(iTime*66.),2.)<.5){o=vec4(0); return;}//bad vsync effects\n #endif\n u.y-=u.y*1./iResolution.y;\n float ratio=iResolution.x/iResolution.y;\n vec2 uv = u.xy/iResolution.xy*vec2(.5);\n vec3 d=vec3(1.,0.,0.);vec4 CamRotation;vec3 p;\n FishEyeCamera(uv,ratio,fovyCoefficient,p,d);\n int m;\n vec3 col=RayMarch(p,d);\n //vec3 col=vec3(0);\n     #ifdef doLazyDither\n    \n   // col=sqrt(col);\n     #endif\n o=vec4(col,1.0);\n}\n\n/*\n10fps to the horizons with many reflected shadows, check!\n\ntodo, an [Inverse Ackerman Function], in GL_ES  :D\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lscW2.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[6897, 7272, 7322, 7322, 7362], [7363, 7363, 7395, 7395, 7462], [7463, 7463, 7523, 7523, 7584], [7585, 7585, 7642, 7642, 7880], [7881, 7881, 7950, 7950, 7998], [7999, 7999, 8019, 8019, 8055], [8056, 8056, 8093, 8093, 8113], [8114, 8114, 8174, 8174, 8265], [8266, 8266, 8302, 8302, 8355], [8356, 8356, 8398, 8398, 8572], [8573, 8573, 8612, 8612, 8662], [8663, 8731, 8771, 8771, 9248], [9273, 9317, 9418, 9418, 9839], [9841, 9895, 9946, 10215, 10217], [10218, 10241, 10277, 10277, 10291], [10293, 10358, 10386, 10386, 10602], [10603, 10603, 10657, 10657, 10760], [10763, 11120, 11173, 11173, 11451], [11454, 11794, 11901, 11901, 13654], [13656, 14879, 14909, 14909, 17020], [17023, 17199, 17300, 17300, 17814], [17816, 17816, 17854, 17854, 18361]]}
{"id": "4lscWX", "name": "I can't go - variant 2", "author": "FabriceNeyret2", "description": "Another variant of the so prolific PrzemyslawZaworski fractal [url]https://www.shadertoy.com/view/4tsyWX[/url]", "tags": ["procedural", "3d", "fractal", "time", "dream", "golf", "twotweet"], "likes": 3, "viewed": 483, "date": "1506688985", "time_retrieved": "2024-06-20T19:00:25.590944", "image_code": "void mainImage(out vec4 c, vec2 f) {\n    c = vec4( ( f+f -(c.xy=iResolution.xy) ) / c.y +2. , 2, 0);\n    c.x -=  2.;\n    float t = mod(iTime/8.,2.);\n    for ( int i = 0; i++ < 50; c = vec4(1.2,0,1.4,0) * abs(c) )\n          c /= dot(c,c), c.z -= .85 + .15* min(t,2.-t); }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lscWX.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 36, 36, 270]]}
{"id": "4lsczl", "name": "Flow Noise 2d", "author": "TinyTexel", "description": "Flow noise as described in Texturing and Modeling A Procedural Approach (no pseudoadvection for now).\nBasic ideas:\n- domain distorted fbm ( http://www.iquilezles.org/www/articles/warp/warp.htm )\n- rotate gradient kernels to animate noise", "tags": ["noise"], "likes": 24, "viewed": 801, "date": "1506017405", "time_retrieved": "2024-06-20T19:00:27.093546", "image_code": "// Flow Noise 2d\n// by TinyTexel\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n\n/*\nFlow noise as described in \"Texturing and Modeling A Procedural Approach\" (no pseudoadvection for now).\nBasic ideas:\n- domain distorted fbm ( http://www.iquilezles.org/www/articles/warp/warp.htm )\n- rotate gradient kernels to animate noise (faster rotation for higher octaves)\n\n[Perlin, K., and F. Neyret. 2001. Flow noise. SIGGRAPH Technical Sketches and Applications]\n*/\n\n///////////////////////////////////////////////////////////////////////////\n//=======================================================================//\n\n#define Frame float(iFrame)\n#define Time iTime\n#define PixelCount iResolution.xy\n#define OUT\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nfloat Pow(float x, float e) {return pow(x, e);}\nvec2 Pow(vec2 x, float e) {return pow(x, vec2(e));}\nvec3 Pow(vec3 x, float e) {return pow(x, vec3(e));}\nvec4 Pow(vec4 x, float e) {return pow(x, vec4(e));}\n\nfloat GammaDecode(float x) {return pow(x,      2.2) ;}\nvec2  GammaDecode(vec2  x) {return pow(x, vec2(2.2));}\nvec3  GammaDecode(vec3  x) {return pow(x, vec3(2.2));}\nvec4  GammaDecode(vec4  x) {return pow(x, vec4(2.2));}\n\nfloat GammaEncode(float x) {return pow(x,      1.0 / 2.2) ;}\nvec2  GammaEncode(vec2  x) {return pow(x, vec2(1.0 / 2.2));}\nvec3  GammaEncode(vec3  x) {return pow(x, vec3(1.0 / 2.2));}\nvec4  GammaEncode(vec4  x) {return pow(x, vec4(1.0 / 2.2));}\n\n#define FUNC4_UINT(f)\t\t\t\t\t\t\t\t\\\nuvec2 f(uvec2 v) {return uvec2(f(v.x ), f(v.y ));}\t\\\nuvec3 f(uvec3 v) {return uvec3(f(v.xy), f(v.z ));}\t\\\nuvec4 f(uvec4 v) {return uvec4(f(v.xy), f(v.zw));}\t\\\n    \n\n// single iteration of Bob Jenkins' One-At-A-Time hashing algorithm:\n//  http://www.burtleburtle.net/bob/hash/doobs.html\n// suggested by Spatial on stackoverflow:\n//  http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nuint BJXorShift(uint x) \n{\n    x += x << 10u;\n    x ^= x >>  6u;\n    x += x <<  3u;\n    x ^= x >> 11u;\n    x += x << 15u;\n\t\n    return x;\n}\n\nFUNC4_UINT(BJXorShift)    \n    \n\n// xor-shift algorithm by George Marsaglia\n//  https://www.thecodingforums.com/threads/re-rngs-a-super-kiss.704080/\n// suggested by Nathan Reed:\n//  http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/\nuint GMXorShift(uint x)\n{\n    x ^= x << 13u;\n    x ^= x >> 17u;\n    x ^= x <<  5u;\n    \n    return x;\n}\n\nFUNC4_UINT(GMXorShift) \n    \n// hashing algorithm by Thomas Wang \n//  http://www.burtleburtle.net/bob/hash/integer.html\n// suggested by Nathan Reed:\n//  http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/\nuint WangHash(uint x)\n{\n    x  = (x ^ 61u) ^ (x >> 16u);\n    x *= 9u;\n    x ^= x >> 4u;\n    x *= 0x27d4eb2du;\n    x ^= x >> 15u;\n    \n    return x;\n}\n\nFUNC4_UINT(WangHash) \n    \n//#define Hash BJXorShift\n#define Hash WangHash\n//#define Hash GMXorShift\n\n// \"floatConstruct\"          | renamed to \"ConstructFloat\" here \n// By so-user Spatial        | http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n// used under CC BY-SA 3.0   | https://creativecommons.org/licenses/by-sa/3.0/             \n// reformatted and changed from original to extend interval from [0..1) to [-1..1) \n//-----------------------------------------------------------------------------------------\n// Constructs a float within interval [-1..1) using the low 23 bits + msb of an uint.\n// All zeroes yields -1.0, all ones yields the next smallest representable value below 1.0. \nfloat ConstructFloat(uint m) \n{\n\tfloat flt = uintBitsToFloat(m & 0x007FFFFFu | 0x3F800000u);// [1..2)\n    float sub = (m >> 31u) == 0u ? 2.0 : 1.0;\n    \n    return flt - sub;// [-1..1)             \n}\n\nvec2 ConstructFloat(uvec2 m) { return vec2(ConstructFloat(m.x), ConstructFloat(m.y)); }\nvec3 ConstructFloat(uvec3 m) { return vec3(ConstructFloat(m.xy), ConstructFloat(m.z)); }\nvec4 ConstructFloat(uvec4 m) { return vec4(ConstructFloat(m.xyz), ConstructFloat(m.w)); }\n\n\nuint Hash(uint  v, uint  r) { return Hash(v ^ r); }\nuint Hash(uvec2 v, uvec2 r) { return Hash(Hash(v.x , r.x ) ^ (v.y ^ r.y)); }\nuint Hash(uvec3 v, uvec3 r) { return Hash(Hash(v.xy, r.xy) ^ (v.z ^ r.z)); }\nuint Hash(uvec4 v, uvec4 r) { return Hash(Hash(v.xy, r.xy) ^ Hash(v.zw, r.zw)); }\n\n// Pseudo-random float value in interval [-1:1).\nfloat Hash(float v, uint  r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\nfloat Hash(vec2  v, uvec2 r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\nfloat Hash(vec3  v, uvec3 r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\nfloat Hash(vec4  v, uvec4 r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\n\n\nfloat HashFlt(uint   v, uint  r) { return ConstructFloat(Hash(v, r)); }\nfloat HashFlt(uvec2  v, uvec2 r) { return ConstructFloat(Hash(v, r)); }\nfloat HashFlt(uvec3  v, uvec3 r) { return ConstructFloat(Hash(v, r)); }\nfloat HashFlt(uvec4  v, uvec4 r) { return ConstructFloat(Hash(v, r)); }\n\nuint HashUInt(float v, uint  r) { return Hash(floatBitsToUint(v), r); }\nuint HashUInt(vec2  v, uvec2 r) { return Hash(floatBitsToUint(v), r); }\nuint HashUInt(vec3  v, uvec3 r) { return Hash(floatBitsToUint(v), r); }\nuint HashUInt(vec4  v, uvec4 r) { return Hash(floatBitsToUint(v), r); }\n\n\nfloat Root4(float x)\n{\n    return rsqrt(rsqrt(x));\n}\n\nfloat SCurveCos(float x)\n{\n    return cos(x * Pi)*-.5+.5;\n}\n\nfloat SCurveC1(float x)\n{\n    return (x * -2.0 + 3.0) * x*x;\n}\n\nfloat SCurveC2(float x)\n{\n    return ((x * 6.0 - 15.0) * x + 10.0) * x*x*x;\n}\n\nfloat Sign(float x) {return x < 0.0 ? -1.0 : 1.0;}\n\n\n#define LOOP(head0, head1, head2, body) {head0 body} {head1 body} {head2 body}\n\n// https://en.wikipedia.org/wiki/Simplex_noise\nfloat SmplxGNoise(vec2 uv, float rotS, uint seed)\n{\n    // const float n = 2.0;\n    const float F = 0.36602540378443860;// (sqrt(n + 1.0) - 1.0) / n;\n    const float G = 0.21132486540518708;// (1.0 - rsqrt(n + 1.0)) / n;\n    \n    vec2 uv2 = uv + (uv.x + uv.y) * F;\n    \n    vec2 iuv = floor(uv2);\n    vec2 fuv = uv2 - iuv;\n    \n    uvec2 vSeed = uvec2(0x0D66487Cu, 0x9A19276Bu) ^ uvec2(seed);\n\n    float res = 0.0;\n\n    LOOP(vec2 vert = vec2(0.0, 0.0);, \n         vec2 vert = (fuv.x > fuv.y ? vec2(1.0, 0.0) : vec2(0.0, 1.0));, \n         vec2 vert = vec2(1.0, 1.0);,\n        \n        uint vHash = HashUInt(vert + iuv, vSeed);\n         \n        float h0 = HashFlt(vHash, 0x7483EC45u);\n        float h1 = HashFlt(vHash, 0xE42B9889u);\n         \n        float ang = h0;\n        ang += Time * rotS * (1.0 + 0.309 * h1);\n        \n        vec2 g = AngToVec(ang * Pi);\n\n        vec2 vec  = fuv - vert;\n             vec -= (vec.x + vec.y) * G;\n        \n        float w = Pow3(clamp01(1.0 - 2.0 * SqrLen(vec)));\n             // w = SCurveC2(clamp01(1.0 - sqrt(2.0)*length(vec)));        \n        \n        float v = dot(vec, g);\n        \n        res += w * v;\n\t)\n\n   \n    //res *= 3.36;//SCurveC2\n    res *= 4.123;//Pow3\n    //res *= 6.2;//Pow4\n    \n    //res = abs(res*res)*2.0-1.0;\n    return res;\n}\n\n#undef LOOP\n\n\nfloat Fbm(vec2 uv, uint seed)\n{\n    const float count = 8.0;\n    \n    float res = 0.0;\n    float accu_w = 0.0;\n    float w = 1.0;\n    float rs = 0.2;\n    \n    for(float i = 0.0; i < count; ++i)\n    {\n        float v = SmplxGNoise(uv, rs, seed);\n        \n        res += v * w;\n        \n        accu_w += w;\n        \n        rs *= -1.7;        \n        w *= 0.51;\n        uv *= 2.2;\n        \n        seed = GMXorShift(seed);\n    }\n    \n    res /= accu_w;\n    \n    return res;\n}\n\n\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{     \n    vec2 uv = uv0.xy - 0.5;\n\tvec2 tex = uv0.xy / PixelCount.xx;\n    vec2 tex21 = tex * 2.0 - vec2(1.0);\n    \n    uint seed0 = 0x17E66082u;\n    uint seed1 = 0x0C1BEFEFu;\n    uint seed2 = 0xAF6DCAB3u;\n\n    \n    tex *= 2.0;\n    \n    vec2 o;\n    o.x = Fbm(tex + vec2(0.45, 0.13) , seed0)*1.;\n    o.y = Fbm(tex + vec2(0.32, 0.87) , seed1)*1.;    \n    \n    o = (abs(o)*2.0-1.0) * 0.5;\n    //o = (abs(abs(o)*2.0-1.0)*2.0-1.0) * 0.3;\n\n    float v = Fbm(tex + o * 0.1, seed2);\n    \n    v = v*.5+.5;\n    //v = o.y*0.5+0.5;\n    //v = (v*2.0-1.0)*128.0*0.5+0.5;\n    //v = pow(clamp(v, 0.0, 1.0), 1.0 / 2.2);\n    outCol = vec4(vec3(v), 1.0);   \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-sa-4.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lsczl.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[487, 912, 933, 933, 945], [946, 946, 967, 967, 981], [982, 982, 1003, 1003, 1025], [1027, 1027, 1053, 1053, 1090], [1092, 1092, 1115, 1115, 1129], [1130, 1130, 1153, 1153, 1171], [1172, 1172, 1195, 1195, 1213], [1214, 1214, 1237, 1237, 1255], [1257, 1257, 1286, 1286, 1304], [1305, 1305, 1332, 1332, 1356], [1357, 1357, 1384, 1384, 1408], [1409, 1409, 1436, 1436, 1460], [1462, 1462, 1490, 1490, 1516], [1517, 1517, 1545, 1545, 1571], [1572, 1572, 1600, 1600, 1626], [1627, 1627, 1655, 1655, 1681], [1683, 1683, 1711, 1711, 1743], [1744, 1744, 1772, 1772, 1804], [1805, 1805, 1833, 1833, 1865], [1866, 1866, 1894, 1894, 1926], [2124, 2366, 2392, 2392, 2505], [2507, 2507, 2787, 2787, 2865], [2867, 2867, 3116, 3116, 3242], [3346, 3964, 3995, 3995, 4163], [4165, 4165, 4195, 4195, 4252], [4253, 4253, 4283, 4283, 4341], [4342, 4342, 4372, 4372, 4431], [4434, 4434, 4463, 4463, 4485], [4486, 4486, 4515, 4515, 4562], [4563, 4563, 4592, 4592, 4639], [4640, 4640, 4669, 4669, 4721], [4723, 4772, 4802, 4802, 4856], [4857, 4857, 4887, 4887, 4941], [4942, 4942, 4972, 4972, 5026], [5027, 5027, 5057, 5057, 5111], [5114, 5114, 5148, 5148, 5185], [5186, 5186, 5220, 5220, 5257], [5258, 5258, 5292, 5292, 5329], [5330, 5330, 5364, 5364, 5401], [5403, 5403, 5436, 5436, 5474], [5475, 5475, 5508, 5508, 5546], [5547, 5547, 5580, 5580, 5618], [5619, 5619, 5652, 5652, 5690], [5693, 5693, 5715, 5715, 5745], [5747, 5747, 5773, 5773, 5806], [5808, 5808, 5833, 5833, 5870], [5872, 5872, 5897, 5897, 5949], [5951, 5951, 5972, 5972, 6001], [6084, 6131, 6182, 6210, 7421], [7437, 7437, 7468, 7468, 7912], [7916, 7916, 7964, 7964, 8603]]}
{"id": "4lsyD7", "name": "Concentric Rectwist", "author": "cacheflowe", "description": "My smallest shader yet. It's been a while, and I had a few minutes to spare. ", "tags": ["blackandwhite", "concentric", "opart"], "likes": 6, "viewed": 635, "date": "1505102560", "time_retrieved": "2024-06-20T19:00:27.093546", "image_code": "#define audio 0.\n\nvec2 rotateCoord(vec2 uv, float rads) {\n    return uv * mat2(cos(rads), sin(rads), -sin(rads), cos(rads));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 10. * (2. * fragCoord - iResolution.xy) / iResolution.y;\n    uv = rotateCoord(uv, length(uv) * 0.11 * sin(iTime * 0.5));\n    float lines = (audio == 1.) ? 5. + texture( iChannel0, vec2(0.4, 0.2) ).r * 10. : 10.;\n    float col = 0.5 + 0.5 * sin(max(abs(uv.x), abs(uv.y)) * lines + iTime * 5.);\n    float aa = 100. / iResolution.y;\n    fragColor = vec4(vec3(smoothstep(0.5 - aa, 0.5 + aa, col)), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lsyD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[18, 18, 57, 57, 126], [128, 128, 185, 185, 600]]}
{"id": "4lsyDX", "name": "Truchet Roads", "author": "morgaza", "description": "Satisfying\n\nhttp://paulbourke.net/geometry/tilingplane/index.html#truchet", "tags": ["2d", "animation", "truchet"], "likes": 4, "viewed": 220, "date": "1506692563", "time_retrieved": "2024-06-20T19:00:27.602716", "image_code": "#if defined(_STANDALONE)\n\nin vec4 texcoord;\nout vec4 out_color;\nuniform float time;\n\n#define fragCoord texcoord.zw\n#define iTime time\n#define fragColor out_color\n\n#define MAIN() void main()\n\n#else\n\n#define const\n#define MAIN() void mainImage(out vec4 fragColor, in vec2 fragCoord)\n\n#endif\n\n\n\n#define PI 3.14159265359\n#define DIAMETER 0.4f\n#define SCALE 100.0f\n\nfloat clamp01(float f)\n{\n\treturn max(min(f, 1.0f), 0.0f);\n}\n// Source https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * 0.1031f);\n    p3 += dot(p3, p3.yzx + 19.19f);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat func(float f)\n{\n\treturn (f > 0.5f ? (0.5f - (f - 0.5f)) : f) * 2.0f;\n}\nvec3 road(float f)\n{\n\treturn f > 0.8 ? vec3(mix(vec3(0.3f), vec3(0.8f), (f - 0.8f) * 5.0f)) : vec3(mix(vec3(0.4f, 0.5f, 0.1f), vec3(0.3f), clamp01(f * 5.0f)));\n}\n\n\nconst vec2 coords0[] = vec2[]( vec2(-1, -1), vec2(-1, 1) );\nconst vec2 coords1[] = vec2[]( vec2(1, 1), vec2(1, -1) );\n\nMAIN()\n{\n\tvec2 uv = (fragCoord) / SCALE;\n\tconst vec2 coord = floor(uv);\n\tuv = mod(uv, 1.0f) * 2.0f - 1.0f;\n\t\n\tconst float t = iTime * 0.5f;\n\tconst int val0 = int(floor(hash13(vec3(coord, floor(t))) * 1.99999f));\n\tconst int val1 = int(floor(hash13(vec3(coord, ceil(t))) * 1.99999f));\n\tconst float lerp = clamp01((t - floor(t)));\n\t\n\tfloat f = 1.0f;\n\tvec2 r[] = vec2[]( coords0[val0], coords1[val1] );\n\tint idx = 0;\n\tif(val0 != val1)\n\t{\n\t\tf = lerp;\n\t\tif(f < 0.5f)\n\t\t{\n\t\t\tf *= 2.0f;\n\t\t\tidx = val0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tf = (0.5f - (f - 0.5f)) * 2.0f;\n\t\t\tidx = val1;\n\t\t}\n\t\t\n\t\tf = pow(f, 10.0f) * 1000.0f;\n\t\tr[0] = coords0[idx] + vec2(0, f * coords0[idx].y);\n\t\tr[1] = coords1[idx] + vec2(f * coords1[idx].x, 0);\n\t\tf += 1.0f;\n\t}\n\t\n\tfloat result = 0.0f;\n\tconst float rad_min = (f - DIAMETER * 0.5f);\n\tconst float rad_max = (f + DIAMETER * 0.5f);\n\tconst float tile_mask = clamp01((1.0f - length(uv) * 0.95f) * 20.0f);\n\tfor(int i = 0; i < 2; i++)\n\t{\n\t\tconst float dist = distance(r[i], uv);\n\t\tif(dist >= rad_min && dist <= rad_max)\n\t\t{\n\t\t\tconst float r = (dist - rad_min) / (rad_max - rad_min);\n\t\t\tresult = max(func(r), result);\n\t\t}\n\t}\n\t\n\tfragColor = vec4(road(clamp01(result) * tile_mask), 1.0f);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lsyDX.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[361, 361, 385, 385, 420], [421, 469, 492, 492, 598], [600, 600, 621, 621, 676], [677, 677, 697, 697, 838]]}
{"id": "4lXyRf", "name": "Visualizing 2D dot products", "author": "etale_cohomology", "description": "Part of the video tutorial: youtube.com/watch?v=hYPuXCYOH48", "tags": ["2d", "math", "tutorial", "space", "vector", "dot", "product"], "likes": 18, "viewed": 536, "date": "1505868227", "time_retrieved": "2024-06-20T19:00:28.287541", "image_code": "// Part of the video tutorial: youtube.com/watch?v=hYPuXCYOH48\n\n#define SCALE 2.\n#define FSAA (SCALE * 4. / iResolution.y)\n#define GRID_REPEAT 1.\n\n#define RGB_DARK  vec3(.04)\n#define RGB_LIGHT vec3(.96)\n#define RGB_GRAY  vec3(.5)\n#define RGB_RED   vec3(1., .4, .4)\n#define RGB_BLUE  vec3(.0, .5, 1.)\n#define RGB_PURP  vec3(.8, .4, 1.)\n\nfloat op_join(float a, float b){\n    return min(a, b);\n}\n\nfloat vproj_scalar(vec2 vec_a, vec2 vec_b){\n    return dot(vec_a, vec_b) / dot(vec_b, vec_b);\n}\n\nvec2 vproj(vec2 vec_a, vec2 vec_b){\n    return vproj_scalar(vec_a, vec_b) * vec_b;\n}\n\nvec2 vproj01(vec2 vec_a, vec2 vec_b){\n    return clamp(vproj_scalar(vec_a, vec_b), .0, 1.) * vec_b;\n}\n\nfloat df_line(vec2 uv, vec2 vec_a, vec2 vec_b, float thickness){\n    vec2 vec_ap = uv    - vec_a;\n    vec2 vec_ab = vec_b - vec_a;\n    return distance(vec_ap, vproj(vec_ap, vec_ab)) - thickness;\n}\n\nfloat df_segment(vec2 uv, vec2 vec_a, vec2 vec_b, float thickness){\n    vec2 vec_ap = uv    - vec_a;\n    vec2 vec_ab = vec_b - vec_a;\n    return distance(vec_ap, vproj01(vec_ap, vec_ab)) - thickness;\n}\n\n// ------------------------------------------------------------------------------------------------ \n#define ARROW_THICKNESS .01\n#define ARROW_HEAD_LEN  .05\n\n#define PI  3.14159\n#define TAU (2. * PI)\n#define XI  (.5 * PI)\n\n#define rot2D(t) mat2(cos(t), sin(t), -sin(t), cos(t))\n\nstruct Arrow{\n    vec2  pos;    // Position!\n    float norm;   // Magnitude/length!\n    float angle;  // Angle!\n};\n\nconst Arrow ARROW_DEFAULT = Arrow(vec2(.0, .0), 1., XI);\n\n// An arrow made of 3 line segments!\nfloat arrow_draw(vec2 uv, Arrow arrow){\n    vec2 arrow_uv = uv - arrow.pos;\n    arrow_uv *= rot2D(arrow.angle);\n\n    vec2 head_end = vec2(arrow.norm, .0);\n    float norm_sign = sign(arrow.norm);\n\n    float stem = df_segment(arrow_uv, vec2(.0, .0), head_end, ARROW_THICKNESS);\n\n    float head_len = min(ARROW_HEAD_LEN, norm_sign * arrow.norm);\n    float head_left  = df_segment(arrow_uv, head_end, head_end + vec2(-norm_sign * head_len, +norm_sign * head_len), ARROW_THICKNESS);\n    float head_right = df_segment(arrow_uv, head_end, head_end + vec2(-norm_sign * head_len, -norm_sign * head_len), ARROW_THICKNESS);\n    float head = op_join(head_left, head_right);\n\n    float arrow_full = op_join(stem, head);\n    return smoothstep(FSAA, .0, arrow_full);\n}\n\nvec2 arrow_polar2rect(Arrow arrow){\n    return arrow.norm * vec2(cos(arrow.angle), sin(arrow.angle));\n}\n\nfloat arrow_vproj_scalar(Arrow arrow0, Arrow arrow1){\n    vec2 arrow0_rect = arrow_polar2rect(arrow0);\n    vec2 arrow1_rect = arrow_polar2rect(arrow1);\n    return dot(arrow0_rect, arrow1_rect) / dot(arrow1_rect, arrow1_rect);\n}\n\nfloat arrow_dot(Arrow arrow0, Arrow arrow1){\n    vec2 arrow0_rect = arrow_polar2rect(arrow0);\n    vec2 arrow1_rect = arrow_polar2rect(arrow1);\n    return dot(arrow0_rect, arrow1_rect);\n    //return arrow0.norm * arrow1.norm * cos(arrow0.angle - arrow1.angle);\n}\n\n// ------------------------------------------------------------------------------------------------ \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv = SCALE * (2. * fragCoord.xy - iResolution.xy) / iResolution.y;  // [-1; 1]\n\n    // Axes!\n    float axis_x = df_line(uv, vec2(0, 0), vec2(1, 0), .01);\n    float axis_y = df_line(uv, vec2(0, 0), vec2(0, 1), .01);\n    float axes = smoothstep(FSAA, .0, op_join(axis_x, axis_y));\n\n    // Grid!\n    float half_repeat = .5 * GRID_REPEAT;\n    vec2 grid_uv = mod(uv - half_repeat, GRID_REPEAT) - half_repeat;\n    float grid_x = df_line(grid_uv, vec2(0, 0), vec2(1, 0), .001);\n    float grid_y = df_line(grid_uv, vec2(0, 0), vec2(0, 1), .001);\n    float grid = smoothstep(FSAA, .0, op_join(grid_x, grid_y));\n\n    Arrow arrow0 = ARROW_DEFAULT;\n    Arrow arrow1 = ARROW_DEFAULT;\n    Arrow arrow2 = ARROW_DEFAULT;\n\n    arrow0.angle = .5 * iTime;\n    arrow1.angle = .1 * PI;\n    arrow2.angle = arrow1.angle;\n    arrow0.norm = 1.1;\n    arrow1.norm = 2.2;\n    arrow2.norm = arrow_vproj_scalar(arrow0, arrow1) * arrow1.norm;\n\n    float dot_product = df_segment(uv, vec2(0, 0), vec2(arrow_dot(arrow0, arrow1), 0), .01);\n    dot_product = smoothstep(FSAA, .0, dot_product);\n\n    vec3 scene = RGB_DARK;\n    scene = mix(scene, RGB_GRAY, grid);\n    scene = mix(scene, RGB_LIGHT, axes);\n    scene = mix(scene, RGB_RED,   arrow_draw(uv, arrow0));\n    scene = mix(scene, RGB_BLUE,  arrow_draw(uv, arrow1));\n    scene = mix(scene, RGB_LIGHT, arrow_draw(uv, arrow2));\n    scene = mix(scene, RGB_PURP,  dot_product);\n\tfragColor.rgb = scene;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lXyRf.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 336, 368, 368, 392], [394, 394, 437, 437, 489], [491, 491, 526, 526, 575], [577, 577, 614, 614, 678], [680, 680, 744, 744, 876], [878, 878, 945, 945, 1079], [1534, 1571, 1610, 1610, 2324], [2326, 2326, 2361, 2361, 2429], [2431, 2431, 2484, 2484, 2658], [2660, 2660, 2704, 2704, 2921], [2923, 3024, 3078, 3078, 4503]]}
{"id": "4tfcz2", "name": "Magic Carpet", "author": "KilledByAPixel", "description": "This one has a time warp effect to make it shrink to center, 2 way symmetric, and some color tweaks. I also changed the squares to circles.", "tags": ["fractal", "zoom", "recursion"], "likes": 15, "viewed": 977, "date": "1505584044", "time_retrieved": "2024-06-20T19:00:29.215047", "image_code": "//////////////////////////////////////////////////////////////////////////////////\n// Prisma Carpet - Copyright 2017 Frank Force\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//////////////////////////////////////////////////////////////////////////////////\n\nconst float zoomSpeed\t\t\t= 0.5;\t// how fast to zoom (negative to zoom out)\nconst float zoomScale\t\t\t= 0.1;\t// how much to multiply overall zoom (closer to zero zooms in)\nconst int recursionCount\t\t= 5;\t// how deep to recurse\nconst int glyphSize\t\t\t\t= 5;\t// width & height of glyph in pixels\nconst float curvature\t\t\t= 2.0;\t// time warp to add curvature\n\n//////////////////////////////////////////////////////////////////////////////////\n// Precached values and math\n\nconst float glyphSizeF = float(glyphSize);\nconst float glyphSizeLog = log(glyphSizeF);\n\nconst float e = 2.718281828459;\nconst float pi = 3.14159265359;\nfloat RandFloat(int i) { return (fract(sin(float(i)) * 43758.5453)); }\nint RandInt(int i) { return int(100000.0*RandFloat(i)); }\n\nvec3 HsvToRgb(vec3 c) \n{\n    float s = c.y * c.z;\n    float s_n = c.z - s * .5;\n    return vec3(s_n) + vec3(s) * cos(2.0 * pi * (c.x + vec3(1.0, 0.6666, .3333)));\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n// Color and image manipulation\n\nfloat GetRecursionFade(int r, float timePercent)\n{\n    if (r > recursionCount)\n        return timePercent;\n    \n    // fade in and out recusion\n    float rt = max(float(r) - timePercent, 0.0);\n    float rc = float(recursionCount);\n    return rt / rc;\n}\n\nvec3 InitPixelColor() { return vec3(0); }\nvec3 CombinePixelColor(vec3 color, float timePercent, int i, int r, vec2 pos, ivec2 glyphPos, ivec2 glyphPosLast)\n{\n    int ir =  (i+r);\n    ir += (glyphPos.y + 2*glyphPosLast.y);\n    ir += (glyphPos.x + 2*glyphPosLast.x);\n\n    vec3 myColor = vec3\n    (\n    \tmix(-0.7, 0.7, RandFloat(ir)),\n    \tmix(0.0, 0.8, RandFloat(ir + 10)),\n        mix(0.0, 0.8, RandFloat(ir + 20))\n    );\n    \n    float f = GetRecursionFade(r, timePercent);\n    \n    // make round\n    if (length(2.0*(pos - vec2(0.5))) > 1.0)\n        f = 0.0;\n    \n    myColor.x = pow(myColor.x, 2.0);\n    myColor.y = pow(myColor.y, 3.0);\n    myColor.z = pow(myColor.z, 3.0);\n    color += myColor*f;\n    return color;\n}\n\nvec3 FinishPixel(vec3 color, vec2 uv)\n{\n    // color wander\n    color.x += 0.01*iTime;\n    \n    // convert to rgb\n    color = HsvToRgb(color);\n    return color;\n}\n\nvec2 InitUV(vec2 uv)\n{\n    \n    float theta = pi*3.0/4.0;\n\tfloat c = cos(theta);\n\tfloat s = sin(theta);\n\tuv = vec2((uv.x*c - uv.y*s), (uv.x*s + uv.y*c));\n    \n\t//// wave\n\t//uv.x += 0.01*sin(10.0*uv.y + 0.053*iTime);\n\t//uv.y += 0.01*sin(10.0*uv.x + 0.033*iTime);\n\t//uv.x += 0.03*sin(2.0*uv.y + 0.113*iTime);\n\t//uv.y += 0.03*sin(2.0*uv.x + 0.073*iTime);\n    \n    uv = abs(uv);\n    \n    return uv;\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n// Fractal functions\n\nivec2 GetFocusPos(int i) { return ivec2(glyphSize/2); }\n      \n// get color of pos, where pos is 0-1 point in the glyph\nvec3 GetPixelFractal(vec2 pos, int iterations, float timePercent)\n{\n\tivec2 glyphPosLast = GetFocusPos(-2);\n\tivec2 glyphPos =     GetFocusPos(-1);\n\tvec3 color = InitPixelColor();\n    \n\tfor (int r = 0; r <= recursionCount + 1; ++r)\n\t{\n        color = CombinePixelColor(color, timePercent, iterations, r, pos, glyphPos, glyphPosLast);\n        if (r > recursionCount)\n\t\t\treturn color;\n           \n        // update pos\n        pos *= glyphSizeF;\n\n        // get glyph and pos within that glyph\n        glyphPosLast = glyphPos;\n        glyphPos = ivec2(pos);\n        \n        // next glyph\n\t\tpos -= vec2(floor(pos));\n\t}\n}\n \n//////////////////////////////////////////////////////////////////////////////////\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\t// use square aspect ratio\n\tvec2 uv = fragCoord;\n\tuv = fragCoord / iResolution.y;\n\tuv -= vec2(0.5*iResolution.x / iResolution.y, 0.5);\n    uv = InitUV(uv);\n    \n    vec4 tweak = vec4(505, 205, 640, 164);\t// preset\n    //vec4 tweak = iMouse; // mouse control\n    tweak -= vec4(320, 180, 320, 180);\n    tweak /= vec4(320, 180, 320, 180);\n    \n    // time warp\n    float time = iTime*zoomSpeed ;\n    time += curvature*(tweak.x)*(pow(2.0 - length(uv), (1.0*tweak.z)));\n    \n\t// get time \n\tfloat timePercent = time ;\n\tint iterations =int(floor(timePercent));\n\ttimePercent -= float(iterations);\n\t\n\t// update zoom, apply pow to make rate constant\n\tfloat zoom = pow(e, -glyphSizeLog*timePercent);\n    \n    // apply pow to the time by distance from center to make it fade\n    zoom *= zoomScale;\n\tzoom *= (2.0*tweak.y)*pow(length(uv), 5.0*tweak.w);\n \n\t// get offset\n\tvec2 offset = vec2(0);\n    const float gsfi = 1.0 / glyphSizeF;\n\tfor (int i = 0; i < 13; ++i)\n\t\toffset += (vec2(GetFocusPos(i)) * gsfi) * pow(gsfi,float(i));\n    \n\t// apply zoom & offset\n    vec2 uvFractal = uv * zoom + offset;\n\t\n\t// check pixel recursion depth\n\tvec3 pixelFractalColor = GetPixelFractal(uvFractal, iterations, timePercent);\n    pixelFractalColor = FinishPixel(pixelFractalColor, uv);\n    \n\t// apply final color\n\tfragColor = vec4(pixelFractalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tfcz2.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[649, 914, 938, 938, 984], [985, 985, 1005, 1005, 1042], [1044, 1044, 1068, 1068, 1208], [1210, 1326, 1376, 1376, 1578], [1580, 1580, 1603, 1603, 1621], [1622, 1622, 1737, 1737, 2298], [2300, 2300, 2339, 2359, 2462], [2464, 2464, 2486, 2486, 2860], [2862, 2967, 2993, 2993, 3022], [3030, 3087, 3154, 3154, 3703], [3706, 3791, 3848, 3881, 5184]]}
{"id": "4tfyWf", "name": "Mandel Distort", "author": "themasmo", "description": "A simple noise effect on mandelbrot fractal", "tags": ["fractal", "noise", "mandelbrot"], "likes": 0, "viewed": 85, "date": "1506591475", "time_retrieved": "2024-06-20T19:00:29.554325", "image_code": "// Click to change the effect\n\nvec2 rotate(vec2 p, float ang){\n    float c = cos(ang), s = sin(ang);\n    return vec2(p.y * c - p.x * s, p.y * s + p.x * c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 R = (4.0*( fragCoord.xy / iResolution.xy ) - 2.0);\n\t\n    \n  \tvec2 m = iMouse.xy / iResolution.xy;\n\tvec2 F=rotate(gl_FragCoord.xy,iTime/10.0);\n\t\n  \tvec3 p = vec3(F / iResolution.y, 0.5-m.x+0.02*sin(iTime));\n\tfloat ki=16.0+112.0*(iMouse.x/iResolution.x);\n  \tfor (float i = 1.0; i < 128.0; i++)\n\t{\n\t\tif(i>ki)\n\t\t\tbreak;\n    \t\tp.xzy = vec3(1.3, 0.999, 0.777) * abs(p/dot(p,p)-vec3(1.0,1.0,m.y*0.3));\n\t}\n\t\n\tfloat cm=0.0;\n\t\n\tfloat cre=R.x;\n\tfloat cim=R.y;\n\tfloat zre=p.x/5.0;\n\tfloat zim=p.y/5.0;\n\tfloat max=32.0;\n\tfloat j=0.0;\n\t\n\tfor(float i=0.0;i<256.0;i++)\n\t{\n\t\tif(i>max)\n\t\t{\n\t\t\tcm=0.0;\n\t\t\tbreak;\n\t\t}\n\t\tfloat dam=zre*zre-zim*zim+cre;\n\t\tzim=2.0*zre*zim+cim;\n\t\tzre=dam;\n\t\tif( (zre*zre+zim*zim)>4.0)\n\t\t{\n\t\t\tcm=i/max;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tvec3 cc=vec3(cm,cm,cm)*p;\n\n\tif(cm<0.3)\n\t\tcc = vec3(cm,cm,cm)/p;\n    \n    \n    fragColor = vec4(cc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tfyWf.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 31, 62, 62, 157], [159, 159, 216, 216, 1057]]}
{"id": "4tfyWr", "name": "Parallel Transport", "author": "sillsm", "description": "Parallel Transport Study", "tags": ["geometry", "manifold", "connection"], "likes": 4, "viewed": 142, "date": "1504240355", "time_retrieved": "2024-06-20T19:00:30.590815", "image_code": "// Parallel Transport Study\n// Copyright Max Sills 2016, licensed under the MIT license.\n/*\nThis is an attempt to write down what I'm learning about geometry to keep\nmyself honest. Feel free to correct anything I'm saying in the comments.\n\nThe sphere is a two dimensional topological manifold.\nMeaning it's a set of points M, together with a collection of subsets O,\ncalled the \"open\" sets. This can be denoted (M, O).\n\nWhen you embed the sphere in R3, it inherits the induced topology \nfrom R3 (base of open balls). The manifold structure is obtained \nby adding invertible charts from the sphere to R2. A manifold is a\nset M, its open sets O, and a collection of charts A, (M, O, A).\n\nConsider two charts which map the northern and southern \nhemispheres of the sphere into a unit disk on the plane.\n\nThe northern chart maps points (X,Y,Z) on the sphere\nto the points (x, y) on the unit disc. Points (x, y)\non the disc are mapped back to (x, y, sqrt(-x^2 + y^2 + 1)).\n\nEvery point in the northern hemisphere has a corresponding \npoint in the pictured unit disc. It also has a tangent plane\nwhich touches the sphere only at that point. Actually, there\nare an infinite amount of such planes, because you can rotate \na tangent plane by any amount around its normal vector\nand still get another tangent plane.\n\nAn immediate question is, what orientation should an arbitrary tangent plane\nhave? The answer is given by something called an \"affine connection\".\nRiemannian manifolds, which are pairs (M, O, A, metric), where a metric\nis a way to define the distance between two points, have a special \"default\" \norientation map, called the \"Levi-Civita connection\". That's pictured\non the left.\n\nParallel transport is a technique to determine per-unit surface area\ncurvature. You take a loop around an area on a manifold, and see how \ntangent plane orientations have changed with respect to the Levi-Civita connection.\n\nYou can interact with this study, and imagine different curves on the northern\nhemisphere of a sphere being projected down to the unit disc. The two arrows\nrepresent the orientation of a tangent plane on the sphere.\n*/\n#define PI 3.14159\nmat3 Rot (float angle)\n{\n    float c = cos(angle/360.*2.*PI);\n    float s = sin(angle/360.*2.*PI);\n    \nreturn  mat3(\n        vec3(c, s, 0),\n        vec3(-s, c, 0),\n        vec3(0, 0, 1)\n); \n}\n\nmat3 Disp (vec2 displacement)\n{\nreturn  mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(displacement, 1)\n); \n}\n\nvec2 Apply(mat3 m, vec2 p)\n{\n    return (m*vec3(p,1.)).xy;\n}\n\n// Nead a repetition operator that respects\n// negatives and is centered at zero or\n// mirror symmetries flake out.\nfloat RepeatInterval(float x, float size)\n{\n    return mod(x-size/2., size) - size/2.;\n}\n\n// Smooth Clamp for distance functions\n// Return val until x exceeds cap, then\n// smoothly, quickly, go to infinitiy.\nfloat SmoothClamp(float x, float cap, float val)\n{\n    return val + exp(10000.*(x-cap));\n}\n\nfloat sdCappedCylinder( vec2 p, vec2 h )\n{\n  p -= vec2(0.,h.y);\n  vec2 d = abs(vec2(length(p.x),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat arrow(vec2 p, float len){\n    float body = sdCappedCylinder(p, vec2(.001, len));\n    \n    p.x = abs(p.x); // Mirror cap.\n    vec2 p_cap = Apply(Rot(145.) * Disp(vec2(0.,-2.*len)), p );\n    float cap = sdCappedCylinder(p_cap, vec2(.001, len/2.));\n    return min(body,cap);\n}\n\nfloat radii(vec2 p)\n{\n    float l = length(p);\n    float theta = atan(p.y,p.x);\n    theta = RepeatInterval(theta, 45./360.*2.*PI );\n    \n    p.x = l*cos(theta);\n    p.y = l*sin(theta);\n    \n    //Gridlines\n    vec2 pp=Apply(Rot(90.), p);\n    float grids = arrow(pp,15.);\n    \n    // Arrows\n    \n    p.x -= iTime/5.;\n    p.x = RepeatInterval(p.x,1.);\n    p = Apply(Rot(90.), p);\n    float a = arrow(p,l/4.*.2);\n\n    float d = min(a,grids);\n    return SmoothClamp(l,5.,d);\n}\n\nfloat circles(vec2 p)\n{\n    float l = length(p);\n    float theta = atan(p.y,p.x);\n    theta = RepeatInterval(theta - iTime/10., 15./360.*2.*PI );\n    \n    p.x = l*cos(theta);\n    p.y = l*sin(theta);\n    \n    p.x = RepeatInterval(p.x,1.) ;\n    \n    float a = arrow(p, l/5.*.2);\n    \n    // Coordinate circles\n    float x = RepeatInterval(l,1.);\n    float b = 50.*(x)*(x);\n    a = min(a, b);\n    \n    return SmoothClamp(l,5.5,a);\n}\n\nfloat mouse(vec2 uv)\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\t\t\n    mo = mo *2.0 - 1.0; \n    mo.x *= iResolution.x / iResolution.y;\n    mo *= 5.;\n    \n    float theta = atan(mo.y,mo.x);\n    vec2 p = uv - mo;\n    float l = length(mo);\n    p = Apply(Rot((theta+PI/2.)*-180./PI + 180.), p);\n    float radial_arrow = arrow(p, .5);\n    p = Apply(Rot(-90.), p);\n    float circ_arrow = arrow(p, .5);\n    \n    float d = min(circ_arrow,radial_arrow);\n    return SmoothClamp(l,5.1,d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\t\t\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 5.;\n    \n    fragColor = vec4(0);\n    float d = min(mouse(uv), min(radii(uv), circles(uv)));\n    \n    float t = clamp(d, 0.0, .04) * 2.*12.5;\n    vec4 bg = vec4(0);\n    vec4 fg = vec4(.8);\n    fragColor = mix(bg, fg, 1.-t);  \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/4tfyWr.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 2150, 2174, 2174, 2342], [2344, 2344, 2375, 2375, 2471], [2473, 2473, 2501, 2501, 2533], [2535, 2651, 2694, 2694, 2739], [2741, 2859, 2909, 2909, 2949], [2951, 2951, 2993, 2993, 3112], [3114, 3114, 3145, 3145, 3393], [3395, 3395, 3416, 3416, 3867], [3869, 3869, 3892, 3892, 4298], [4300, 4300, 4322, 4322, 4777], [4779, 4779, 4836, 4836, 5189]]}
{"id": "4tfyzs", "name": "RayMarching_Part2", "author": "guyue", "description": "第二次", "tags": ["raymarchingpart2"], "likes": 2, "viewed": 58, "date": "1506007415", "time_retrieved": "2024-06-20T19:00:30.590815", "image_code": "\nconst int MAX_RAY_NUM = 255;\nconst float  MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float SCALE = 0.0001;\n\n\nfloat sphereSDF(vec3 p){\n\n   return length(p)-1.0;\n\n\n}\n\n\n\nfloat ShortestDistanceToObjectSurface(vec3 dir,vec3 eye,float start,float end){\n        float depth = start;\n    \n    for(int i = 1;i<MAX_RAY_NUM;i++){\n       float dist = sphereSDF(eye+depth*dir);\n        \n        if(dist<SCALE){\n            \n        return depth;\n        \n        }\n        \n        depth+=dist;\n        if(depth>=end){\n        \n        return end;\n        }\n\n    \n    }\n    \n    return end;\n     \n\n\n\n}\n\n\nvec3 RayDir(vec2 size,vec2 fragcood){\n    vec2 xy = fragcood-size/2.0;\n    float z = size.y;\n    return normalize(vec3(xy,-z));\n    \n\n}\n\nvec3 createNormal(vec3 p){\n\n  return normalize(vec3(\n   sphereSDF(vec3(p.x+SCALE,p.y,p.z))-sphereSDF(vec3(p.x-SCALE,p.y,p.z)),\n    \n   sphereSDF(vec3(p.x,p.y+SCALE,p.z))-sphereSDF(vec3(p.x,p.y-SCALE,p.z)), \n\n   sphereSDF(vec3(p.x,p.y,p.z+SCALE))-sphereSDF(vec3(p.x,p.y,p.z-SCALE))\n\n   ));\n\n\n\n}\n\n\nvec3 PhongLight(vec3 k_d,vec3 k_s,vec3 eye,vec3 lightpos,vec3 LightScale,vec3 p,float alpha){\n    \n    vec3 N = createNormal(p);\n    vec3 L = normalize(lightpos-p);\n    vec3 V = normalize(eye-p);\n    vec3 R = normalize(reflect(-L,N));\n    \n  \n    float LdotN = dot(L,N)*2.0;\n    \n    float RdotN = dot(R,V);\n    \n    if(LdotN<0.0){\n        \n     \n        return vec3(0.0,0.0,0.0);\n    \n        \n    }\n    \n    \n    if(RdotN<0.0){\n        \n        \n    \n      return k_d*LightScale*LdotN;\n    \n    \n    }\n    \n    \n    return LightScale*(k_d*LdotN+pow(RdotN,alpha)*k_s*2.0);\n\n    \n\n}\n\n\nvec3 PhongLightPosSuf(vec3 k_a,vec3 k_d,vec3 k_s,vec3 eye,vec3 p,float alpha){\n\n    vec3 Ambient = vec3(1.0,1.0,1.0)*0.5;\n    \n    vec3 color = Ambient*k_a;\n    \n    \n    vec3 LightPos1 = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    \n    vec3 LightScale = vec3(0.4,0.6,0.1);\n    \n    color+=PhongLight(k_d,k_s,eye,LightPos1,LightScale,p,alpha);\n    \n    \n    \n    vec3 LightPos2 = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    \n    vec3 LightScale2 = vec3(0.8,0.2,0.2);\n    \n     color+=PhongLight(k_d,k_s,eye,LightPos2,LightScale2,p,alpha);\n    \n    return color;\n    \n    \n    \n    \n    \n    \n\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 eye = vec3(0.0,0.0,3.0);\n    \n    vec3 dir = RayDir(iResolution.xy,fragCoord);\n    \n    float dist = ShortestDistanceToObjectSurface(dir,eye,MIN_DIST,MAX_DIST);\n    \n    vec3 pos = eye+dist*dir;\n    \n    vec3 k_a = vec3(0.3,0.3,0.3);\n    \n    vec3 k_d = vec3(0.3,0.2,0.9);\n    \n    vec3 k_s = vec3(1.0,1.0,1.0);\n    \n    float alpha = 10.0;\n    \n \n     vec3 LightScale = vec3(0.4,0.6,0.8);\n    if(dist<5.0){\n        \n      vec3 col = PhongLightPosSuf(k_a,k_d,k_s,eye,pos,alpha);\n       // vec3 col =   PhongLight(k_d,k_s,eye,lightpos,LightScale,pos,alpha);\n        \n          \n        \n        fragColor = vec4(col,1.0);\n        return;\n    \n    }\n    \n    \n    \n\tvec2 uv = RayDir(iResolution.xy,fragCoord).xy;\n    \n\tfragColor = vec4(0,0,0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tfyzs.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[119, 119, 143, 143, 173], [177, 177, 256, 256, 598], [601, 601, 638, 638, 736], [738, 738, 764, 764, 1031], [1034, 1034, 1127, 1127, 1616], [1619, 1619, 1697, 1697, 2346], [2349, 2349, 2406, 2406, 3163]]}
{"id": "4tlcRS", "name": "Implicit Surfaces", "author": "jgkling", "description": "Goopy", "tags": ["raymarching"], "likes": 2, "viewed": 170, "date": "1505975133", "time_retrieved": "2024-06-20T19:00:31.493894", "image_code": "#define MAX_ITERATIONS 50.f\n#define T_MAX 3.5f\n\nconst float k_smooth = 24.0;\n\n// Exponential Smooth Min - from IQ's article: http://www.iquilezles.org/www/articles/smin/smin.htm\nfloat SmoothMin_IQ( in float a, in float b )\n{\n    float res = exp(-k_smooth * a) + exp(-k_smooth * b);\n    return -log(res) / k_smooth;\n}\n\n// IQ's Signed Distance Functions: http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat SDF_Sphere( in vec3 pos, in float radius )\n{\n    return length(pos) - radius;\n}\n\nfloat SDF_Torus( in vec3 pos, in vec2 t)\n{\n    vec2 qos = vec2(length(pos.xz) - t.x, pos.y);\n    return length(qos) - t.y;\n}\n\nfloat SDF_RoundedBox( vec3 pos, vec3 b, float r )\n{\n  return length(max(abs(pos) - b, 0.0)) - r;\n}\n\nfloat SceneMap( in vec3 pos )\n{\n    // Bounding Volume\n    float distToBoundingSphere = SDF_Sphere(pos, 1.0);\n    if(distToBoundingSphere < 0.025f)\n    {\n        // Cached calls to sin\n        float sin_norm1 = (sin(iTime) + 1.0) * 0.5; // remap to [0,1]\n        float sin_norm2 = (sin(iTime * 0.2) + 1.0) * 0.5; // remap to [0,1]\n        float sin_norm3 = (sin(iTime * 0.6) + 1.0) * 0.5; // remap to [0,1]\n        float sin1 = sin(iTime * 0.5);\n        float sin2 = sin(iTime * 1.2);\n        float sin3 = sin(iTime * 1.5);\n        \n        float sdf1 = SDF_Sphere(pos - vec3(0.0, sin(iTime * 0.25) * 0.3, 0.0), (sin_norm1 * 0.8 + 0.8) * 0.25);\n        float sdf2 = SDF_Torus(pos - 0.5 * vec3(0.0, sin1, 0.0), vec2((sin_norm3) * 0.44, 0.025));\n        float sdf3 = SDF_Torus(pos - 0.5 * vec3(0.0, sin(iTime * 1.7), 0.0), vec2((sin_norm2) * 0.6, 0.05));\n        float sdf4 = SDF_Torus(pos - 0.5 * vec3(0.0, sin(iTime * 1.4 + 1.0), 0.0), vec2((sin_norm2) * 0.5, 0.06));\n        float sdf5 = SDF_Torus(pos - 0.5 * vec3(0.0, sin2, 0.0), vec2((sin_norm3) * 0.8, 0.07));\n        float sdf6 = SDF_RoundedBox(pos - 0.5 * vec3(sin1, sin(iTime * 1.2), 0.0), vec3(0.025) * (sin_norm1 * 0.5 + 0.75), 0.025);\n        float sdf7 = SDF_RoundedBox(pos - 0.5 * vec3(sin(iTime * 1.5 + 1.0), sin(iTime * 0.5 + 1.0), 0.0), vec3(0.075) * (sin_norm1 * 0.5 + 0.45), 0.025);\n        float sdf8 = SDF_RoundedBox(pos - 0.5 * vec3(sin(iTime * 0.5 + 0.5), sin(iTime * 1.2 + 0.5), 0.0), vec3(0.075) * (sin_norm1 * 0.5 + 0.75), 0.025);\n        float sdf9 = SDF_RoundedBox(pos - 0.5 * vec3(sin(iTime * 0.5 + 1.0), sin(iTime * 1.5 + 0.5), 0.0), vec3(0.075) * (sin_norm1 * 0.5 + 0.45), 0.025);\n        float sdf10 = SDF_RoundedBox(pos - 0.5 * vec3(sin2, sin(iTime * 0.8 + 0.5), 0.0), vec3(0.075) * (sin_norm1 * 0.5 + 0.75), 0.025);\n        \n        // Exponential Smooth Min - from IQ's article: http://www.iquilezles.org/www/articles/smin/smin.htm\n        sdf1 = exp(-k_smooth * sdf1) +\n               exp(-k_smooth * sdf2) +\n               exp(-k_smooth * sdf3) +\n               exp(-k_smooth * sdf4) +\n               exp(-k_smooth * sdf5) +\n               exp(-k_smooth * sdf6) +\n               exp(-k_smooth * sdf7) +\n               exp(-k_smooth * sdf8) +\n               exp(-k_smooth * sdf9) +\n               exp(-k_smooth * sdf10);\n               \n        return -log(sdf1) / k_smooth;\n    }\n    else\n    {\n        return distToBoundingSphere;\n    }\n}\n\nvec3 ComputeNormal( in vec3 pos )\n{\n    vec2 epsilon = vec2(0.0, 0.001);\n    return normalize( vec3( SceneMap(pos + epsilon.yxx) - SceneMap(pos - epsilon.yxx),\n                            SceneMap(pos + epsilon.xyx) - SceneMap(pos - epsilon.xyx),\n                            SceneMap(pos + epsilon.xxy) - SceneMap(pos - epsilon.xxy)));\n}\n\n\nvec3 LightContrib( in vec3 lightDir, in vec3 lightCol, in vec3 normal, in vec3 camLook )\n{\n    vec3 baseCol = vec3(0.2);\n    vec3 specularColor = vec3(0.9);\n    float lambertDot = clamp(dot(normal, lightDir), 0.001, 1.0);\n    float phongDot = pow(clamp(dot(camLook, reflect(lightDir, normal)), 0.0, 1.0), 40.0);\n    \n    vec3 diffuseTerm = baseCol * pow(lambertDot, 2.0) * lightCol;\n    vec3 specularTerm = 0.1 * phongDot * specularColor;\n    \n    return lightCol * (diffuseTerm + specularTerm);\n}\n\nvec3 ComputeLighting( in vec3 normal, in vec3 camLook )\n{\n    vec3 accumLight = vec3(0.0);\n    \n    accumLight += LightContrib(normalize(vec3(0.0, 1.0, -1.0)), vec3(0.92, 0.82, 0.22), normal, camLook);\n    accumLight += LightContrib(normalize(vec3(0.5, -0.75, -1.0)), vec3(0.98, 0.8, 0.2), normal, camLook);\n    accumLight += LightContrib(normalize(vec3(0.0, -1.0, 1.0)), vec3(0.4, 0.4, 0.8), normal, camLook);\n    accumLight += LightContrib(normalize(vec3(-5.0, 2.0, 0.75)), vec3(0.8, 0.8, 0.45) * 1.1, normal, camLook);\n    accumLight += LightContrib(normalize(vec3(0.75, 0.25, 0.55)), vec3(0.85, 0.85, 0.42) * 1.1, normal, camLook);\n    \n    return accumLight;\n}\n\nvec3 RaymarchScene( in vec3 origin, in vec3 dir )\n{\n    float distance;\n    float t = 0.01;\n    float hitSomething = 0.0;\n    \n    float i;\n    for(i = 0.0; i < MAX_ITERATIONS; i += 1.0)\n    {\n        distance = SceneMap(origin + t * dir);\n        \n        if(distance < 0.01)\n        {\n            hitSomething = 1.0;\n            break;\n        } else if (t > T_MAX)\n        {\n            break;\n        }\n        \n        t += distance;\n    }\n    return vec3(t, hitSomething, i);\n}\n\nvec4 cosinePallette(float i)\n{\n    float r = 0.5f + 0.5f * cos(6.28318 * (0.05f * i + 0.3f));\n    float g = 0.5f + 0.5f * cos(6.28318 * (1.0f * i + 0.1f));\n    float b = 0.5f + 0.5f * cos(6.28318 * (0.0f * i + 0.1f));\n    return vec4(r, g, b, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screenPoint = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    // Compute ray direction\n    float distance = 2.5;\n    vec3 rayOrigin = vec3(cos(iTime * 0.5) * distance, 0.0, sin(iTime * 0.5) * distance); // camera position\n    vec3 rayDirection;\n    \n    // Ray casting\n    vec3 refPoint = vec3(0.0, 0.0, 0.0);\n    vec3 camLook = normalize(refPoint - rayOrigin);\n    vec3 camRight = normalize(cross(camLook, vec3(0.f, 1.f, 0.f)));\n    vec3 camUp = normalize(cross(camRight, camLook));\n    \n    vec3 rayPoint = refPoint + screenPoint.x * camRight + screenPoint.y * camUp;\n    rayDirection = normalize(rayPoint - rayOrigin);\n    \n    vec3 result = RaymarchScene(rayOrigin, rayDirection);\n    \n    vec4 finalColor;\n    if(result.y > 0.0)\n    {\n        vec3 normal = ComputeNormal(rayOrigin + result.x * rayDirection);\n        finalColor = vec4(ComputeLighting(normal, camLook), 1.f);\n    }\n    else\n    {\n        vec2 uv = fragCoord.xy / iResolution.xy;\n        float sinThing = sin(iTime * 0.175f + 2.f * (uv.x * uv.y));\n        float cosThing = cos(iTime * 0.175f+ 3.f * (uv.x + uv.y));\n        float sinThing2 = sin(iTime * 0.125f + 2.f * (length(screenPoint)));\n        float colorThing = (sinThing * cosThing * sinThing2) * 0.5f + 0.5f;\n        finalColor = vec4(cosinePallette(colorThing) * 0.5f);\n    }\n    fragColor = vec4(pow(finalColor.xyz, vec3(1.f / 2.2f)), 1.f);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tlcRS.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[78, 178, 224, 224, 316], [318, 421, 471, 471, 506], [508, 508, 550, 550, 632], [634, 634, 685, 685, 732], [734, 734, 765, 788, 3159], [3161, 3161, 3196, 3196, 3498], [3501, 3501, 3591, 3591, 3998], [4000, 4000, 4057, 4057, 4665], [4667, 4667, 4718, 4718, 5150], [5152, 5152, 5182, 5182, 5402], [5404, 5404, 5461, 5461, 6860]]}
{"id": "4tlyRB", "name": "Veins of Primes", "author": "cauliflower", "description": "Basically the same representation as in the famous Ulam spiral, but here the prime numbers are extended to the negative integers, and surprisingly the veins run straight through them.\n\nUse mouse to zoom/navigate.", "tags": ["2d", "mathematics", "primes", "scrolling"], "likes": 4, "viewed": 160, "date": "1505456365", "time_retrieved": "2024-06-20T19:00:31.499961", "image_code": "// Veins of Primes\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Primality test, created by inigo quilez\n// https://www.shadertoy.com/view/4slGRH\nbool isPrime(int x)\n{\n\tif( x==1 ) return false;\n\tif( x==2 ) return true;\n\tif( x==3 ) return true;\n\tif( x==5 ) return true;\n\tif( x==7 ) return true;\n\tif( (x%2)==0 ) return false;\n\tif( (x%3)==0 ) return false;\n\tif( (x%5)==0 ) return false;\n\n    int xm = 1 + int(sqrt(float(x)));\n    \n\tint y = 7;\n\tfor( int i=0; i<100000; i++ ) // count up to 3000000\n\t{\n\t\t         if( (x%y)==0 ) return false;\n\t\ty += 4;  if( y>=xm    ) return true;\n\t\t         if( (x%y)==0 ) return false;\n\t\ty += 2;  if( y>=xm )    return true;\n\t\t         if( (x%y)==0 ) return false;\n\t\ty += 4;  if( y>=xm )    return true;\n\t\t         if( (x%y)==0 ) return false;\n\t\ty += 2;  if( y>=xm )    return true;\n\t\t         if( (x%y)==0 ) return false;\n\t\ty += 4;  if( y>=xm )    return true;\n\t\t         if( (x%y)==0 ) return false;\n\t\ty += 6;  if( y>=xm )    return true;\n\t\t         if( (x%y)==0 ) return false;\n\t\ty += 2;  if( y>=xm )    return true;\n\t\t         if( (x%y)==0 ) return false;\n\t\ty += 6;  if( y>=xm )    return true;\n\t}\n\t\n\treturn true;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat zoom = 1.0;\n    float speed = 0.3;\n    float shiftX = 0.0;\n    float shiftY = 0.0;\n    if (iMouse.z > 0.0) {\n        vec2 normMouse = iMouse.xy/iResolution.xy-0.5;\n        vec2 deflection = normMouse*normMouse*normMouse;\n    \tshiftX = (exp(deflection.x*50.0)-exp(-deflection.x*50.0))*5000.0;\n    \tshiftY = (exp(deflection.y*24.0)-exp(-deflection.y*24.0))*200.0;\n        // magnify when mouse vertically centered\n        zoom = floor(mix(iResolution.y/80.0, 1.0, smoothstep(0.0, 0.1, normMouse.y*normMouse.y*4.0)));\n    }        \n\n    float shear = mod(iTime*speed, 2.0);\n    float offsetY = -0.5*shear + shiftY;  // scroll one row up per turn\n    vec2 cy = vec2(0.0);\n    for (int i = 0; i <= 1; i++) {\n        float y = floor((fragCoord.y-0.5+float(i) - floor(iResolution.y*0.5))/zoom + offsetY);\n        float offsetX = y*shear + 0.25*shear*shear + shiftX; \n\t    vec2 cx = vec2(0.0);\n    \tfor (int j = 0; j <= 1; j++) {\n            float x = floor((fragCoord.x-0.5+float(j) - floor(iResolution.x*0.5))/zoom + offsetX);\n            int n = abs(int(y * y + x));  // consider negative primes too\n            cx[j] = isPrime(n) ? 1.0 : 0.0;\n        }\n        // ultra smooth anti-alias for large magnification, horizontally\n        cy[i] = mix((cx[0]+cx[1])*0.5, mix(cx[0], cx[1], fract(offsetX*zoom)), smoothstep(1.5, 3.5, zoom));\n    }\n    // ultra smooth anti-alias for large magnification, vertically\n    float c = mix((cy[0]+cy[1])*0.5, mix(cy[0], cy[1], fract(offsetY*zoom)), smoothstep(0.5, 1.5, zoom));\n\n    fragColor = vec4(0.0, c, c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tlyRB.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[107, 191, 212, 212, 1194], [1196, 1196, 1251, 1251, 2808]]}
{"id": "4tlyW8", "name": "sinsin", "author": "YunzhongTianjing", "description": "test sin", "tags": ["2d"], "likes": 1, "viewed": 87, "date": "1504589029", "time_retrieved": "2024-06-20T19:00:31.499961", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n    uv.y = iResolution.y / iResolution.x * uv.y;\n    \n    vec4 color = vec4(1.);\n    \n    for(float i = -1.; i < +1. ; i += .1){\n    \tfloat line = smoothstep(0.,0.005,abs(uv.x - i));\n        color = mix(vec4(0.5),color,line);\n        \n        line = smoothstep(0.,0.005,abs(uv.y - i));\n        color = mix(vec4(.5),color,line);\n    }\n    \n    float axis = smoothstep(0.,0.01,abs(uv.x));\n    color = mix(vec4(.3),color,axis);\n    axis = smoothstep(0.,0.01,abs(uv.y));\n    color = mix(vec4(.3),color,axis);\n    \n    //float sinsin = smoothstep(0.,0.01,abs(.5 * sin(2. * 3.14 * uv.x + iTime) - uv.y));\n    float sinsin = smoothstep(0.,0.003,abs(.5 * sin(2. * 3.14 * uv.x + iTime) - uv.y) / sqrt(1.0 + .5*.5*6.2831*6.2831*cos(2. * 3.14 * uv.x + iTime)*cos(2. * 3.14 * uv.x + iTime)));\n    color = mix(vec4(.1),color,sinsin);\n    \n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tlyW8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 960]]}
{"id": "4tscWf", "name": "Sunset Eclipse Phase", "author": "Kellers176", "description": "Sunset Eclipse thing that I was doing while messing around.", "tags": ["sunset", "gradient"], "likes": 1, "viewed": 83, "date": "1506703240", "time_retrieved": "2024-06-20T19:00:31.499961", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv.y *= iResolution.y / iResolution.x;\n    \n\t//variables\n\tvec2 Position = vec2(0.5,0.3);\n\tvec2 eclipsePosition = vec2(0.35, 0.3);\n\tfloat Radius = 0.2;\n\tfloat eclipseRadius = 0.15;\n\tvec3 Background = vec3(1.0,uv.y,0.0);\n\tvec3 sunColor = vec3(1.0,1.0,0.0);\n\tvec3 eclipseColor = vec3(1.0,uv.y,0.0);\n\n    \n\teclipsePosition.x *= (sin(iTime * 0.1) + 1.4);\n\n\t//Question 2\n\tvec4 layer1 = vec4(Background, 1.0);\n\tvec4 layer2 = vec4(sunColor, 1.0 - smoothstep(0.1, Radius, length(Position - uv)));\n\tvec4 layer3 = vec4(eclipseColor, 1.0 - step(eclipseRadius, length(eclipsePosition - uv)));\n\n\tvec4 Composite = mix(layer1, layer2, layer2.a);\n\tComposite = mix(Composite, layer3, layer3.a);\n\tfragColor = Composite;\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tscWf.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 815]]}
{"id": "4tsczB", "name": "Fibonacci Sphere", "author": "starea", "description": "Equirectangular Playground. A demonstration shader to illustrate how to use an equirectangular image as the input. For stereoscopic or gnomonic projection, please refer to [url]https://www.shadertoy.com/view/4sjcz1[/url] for more info.", "tags": ["playground", "equirectangular"], "likes": 8, "viewed": 535, "date": "1505324096", "time_retrieved": "2024-06-20T19:00:33.215362", "image_code": "/** \n * Equirectangular Fibonacci Sphere\n * Link to demo: https://www.shadertoy.com/view/Ms2yDK\n * starea @ ShaderToy\n *\n * Most of the code is forked from:\n * [1] nomadiclizard's Dragon Egg. https://www.shadertoy.com/view/MslyRr\n * Thank you nomadiclizard for sharing!\n * I added the equirectangular part and orange circles to mimic the Kusama style (https://hirshhorn.si.edu/kusama/).\n *\n * Reference: \n * [1] Keinert, Benjamin, et al. \"Spherical fibonacci mapping.\" ACM Transactions on Graphics (TOG) 34.6 (2015): 193.\n       http://lgdv.cs.fau.de/uploads/publications/spherical_fibonacci_mapping.pdf\n * [2] https://www.openprocessing.org/sketch/41142\n * [3] http://stackoverflow.com/questions/9600801/evenly-distributing-n-points-on-a-sphere\n *\n * My Related Shaders:\n * [1] Unified Gnomonic & Stereographic Projections. https://www.shadertoy.com/view/ldBczm\n * [2] Cubemap to Gnomonic Projection. https://www.shadertoy.com/view/4sjcz1\n * [3] [WiP] Halftone Sphere. https://www.shadertoy.com/view/4sSyD1\n *\n **/\n\n#define pi 3.14159265359\n#define twoPi 6.28318530718\n#define halfPi 1.57079632679\n#define infinity 100.0\n#define phi 1.61803398875\n#define phiMinusOne 0.61803398875\n#define twoPiOnPhi 3.88322207745\n#define root5 2.2360679775\n#define logPhiPlusOne 0.96242365011\n#define EQUIRECTANGULAR false\n#define KUSAMA_COLOR true\n//#define TIME iTime\n#define TIME 5.0\n\n// egg definition and colouring\nconst float maxn = 50.0;\nconst float growtime = 5.0;\nconst bool convex = true;\nconst float f1 = 856.0, s1 = 3.0, a1 = 0.15;\nconst float f2 = 335.0, s2 = 2.0, a2 = 0.10;\n\n// SIMPLE STUFF THAT WOULD BE COOL IF WEBGL HAD IN A STANDARD LIBRARY :V\n\nvec3 lookat(vec3 p1, vec3 p2)\n{\n    return normalize(p2 - p1);\n}\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec4 rotationQuat(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float c = cos(0.5 * angle);\n    float s = sqrt(1.0 - c * c);\n    return vec4(axis.x * s, axis.y * s, axis.z * s, c);\n}\n\nvec3 rotate(vec3 p, vec4 q)\n{\n\treturn p + 2.0 * cross(q.xyz, cross(q.xyz, p) + q.w * p);\n}\n\nvec3 rotate(vec3 p, vec3 axis, float angle)\n{\n    return rotate(p, rotationQuat(axis, angle));\n}\n\nmat4 translationMatrix(vec3 p)\n{\n    return mat4(1.0, 0.0, 0.0, 0.0,\n                0.0, 1.0, 0.0, 0.0,\n                0.0, 0.0, 1.0, 0.0,\n                p.x, p.y, p.z, 1.0);\n}\n\nmat4 scaleMatrix(float s)\n{\n    return mat4(s,   0.0, 0.0, 0.0,\n                0.0, s,   0.0, 0.0,\n                0.0, 0.0, s,   0.0,\n                0.0, 0.0, 0.0, 1.0);\n}\n\n// k'th fibonacci number\nfloat calcfk(float k)\n{\n\treturn round(pow(phi, k) / root5);\n}\n\n// calculates a basis vector for fibonacci sphere n\nvec2 calcbk(float fk, float n)\n{\n    return vec2(twoPi * fract((fk + 1.0) * phiMinusOne) - twoPiOnPhi,\n                -2.0 * fk / n);\n}\n\n// calc point i of n in spherical coordinates\nvec2 calcpoint(float i, float n)\n{\n    return vec2(twoPi * fract(i * phiMinusOne),\n                1.0 - (2.0 * i + 1.0) / n);\n}\n\n// converts [phi,cos theta] into [x,y,z] for unit sphere\nvec3 s2c(vec2 s)\n{\n    float sinTheta = sqrt(1.0 - s.y * s.y);\n    return vec3(cos(s.x) * sinTheta,\n                sin(s.x) * sinTheta,\n                s.y);\n}\n\n// converts [x,y,z] into [phi, cos theta] for unit sphere\nvec2 c2s(vec3 c)\n{\n    return vec2(atan(c.y, c.x),\n                c.z);\n}\n\n// angle between two points in spherical coords\nfloat angdist(vec2 sp1, vec2 sp2)\n{\n    float sinTheta1 = sqrt(1.0 - sp1.y * sp1.y);\n    float sinTheta2 = sqrt(1.0 - sp2.y * sp2.y);\n    return acos(sp1.y * sp2.y + sinTheta1 * sinTheta2 * cos(sp2.x - sp1.x));\n}\n\n// calculate new point [phi, cos theta] if walking point sp on bearing ib distance d\nvec2 gcircle(vec2 sp, float ib, float d)\n{\n    float cosd = cos(d);\n    float sind = sin(d);\n    float sinTheta1 = -sp.y;\n    float cosTheta1 = sqrt(1.0 - sp.y * sp.y);\n    float sinTheta2 = sinTheta1 * cosd + cosTheta1 * sind * cos(ib);\n    float theta2 = asin(sinTheta2);\n    float phi2 = sp.x + atan(sin(ib) * sind * cosTheta1, cosd - sinTheta1 * sinTheta2);\n    return vec2(mod(phi2, twoPi), cos(theta2 + halfPi));\n}\n\n// 0..1 for seed x\nfloat random(float x)\n{\n    return fract(abs(sin(x * 12.9898) * 43758.5453));\n}\n\n// distance to nearest cell on a fibonacci sphere\nfloat fibspheren(vec3 p, float n, out float minidx, out vec3 sn)\n{\n    // get spherical coords for point p on surface of unit sphere\n    vec2 sp = c2s(p);\n    float avdist = sqrt(4.0 * pi / n);\n    \n    // calc the dominant zone number\n    float k = max(2.0, floor(log(root5 * n * pi * (1.0 - sp.y * sp.y)) / logPhiPlusOne));   \n    \n    // calc basis vectors for this zone\n    // [could all be precalculated and looked up for k,n]\n    vec2 f = vec2(calcfk(k), calcfk(k + 1.0));\n    vec2 bk = calcbk(f[0], n);\n    vec2 bk1 = calcbk(f[1], n);\n    mat2 b = mat2(bk, bk1);\n    mat2 invb = inverse(b);\n    \n    // change of basis for point sp to local grid uv\n    float z0 = 1.0 - 1.0 / n;\n    vec2 c = floor(invb * (sp - vec2(0.0, z0)));\n    \n    // for k<=4 paper suggests using (-1,0,+1)^2 offset factors but we'll\n    // stick with (0,1)^2 and live with the occasional glitches\n    float mindist = pi;\n    vec2 minisp;\n    for (int s = 0; s < 4; s++) {\n        // figure out the point index and generate fib point\n        vec2 o = vec2(s - (s/2) * 2, s / 2);\n        float idx = dot(f, c + o);\n        if (idx > n) continue;        \n        vec2 isp = calcpoint(idx, n);\n        \n        // walk on a random bearing a random distance to make cells move a bit\n        //float b = mod((-0.05 + 0.1 * random(idx + 42.39)) * iTime, twoPi);\n        //float d = dist * random(idx + 28.93) * cos((-0.5 + 1.0 * random(idx + 42.39)) * iTime);\n        //isp = gcircle(isp, b, d);\n        \n        // closest?\n        float dist = angdist(isp, sp);\n        if (dist < mindist) {\n\t\t\tmindist = dist;\n            minidx = idx;\n            minisp = isp;\n        }\n    }\n    \n    // use nearest point to calculate surface normal via rotation around cotangent from p -> ip\n    // ohhhh wow I can make keeled scales real easy if dist varies by direction!\n    vec3 ip = s2c(minisp), cotan;\n    if (convex) {\n        cotan = cross(ip - p, p);\n    } else {\n        cotan = cross(p - ip, p);\n    }\n    sn = rotate(p, cotan, mindist / avdist);\n    return mindist;\n}\n\n// view stuff\nconst float fov = radians(50.0);\nconst vec3 up = vec3(0.0, 1.0, 0.0);\nconst vec3 right = vec3(1.0, 0.0, 0.0);\nconst vec3 forward = vec3(0.0, 0.0, -1.0);\n\n// calculates intersection parameters for a ray through a sphere at sp radius r\n// return true if the halfray ro + t1.rd is hitting\nbool spherehit(vec3 sp, float r, vec3 ro, vec3 rd, out float t1, out float t2)\n{\n    vec3 rosp = ro - sp;\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(rd, rosp);\n    float c = dot(rosp, rosp) - (r * r);\n    float b2m4ac = b * b - 4.0 * a * c;\n    if (b2m4ac >= 0.0) {\n        float r = sqrt(b2m4ac);\n        t1 = (-b - r) / (2.0 * a);\n        t2 = (-b + r) / (2.0 * a);\n        return t1 >= 0.0 || t2 >= 0.0;\n    } else {\n        return false;\n    }\n}\n\n\nbool spherehitd(vec3 sp, float r, vec3 ro, vec3 rd, out float t1, out float t2)\n{\n    return true; \n}\n\n// black -> white via red and yellow for 0,1\nvec4 falsecolourr(float x, float stretch)\n{\n    float px = pow(clamp(x, 0.0, 1.0), stretch) * pi;\n    return vec4(sin(clamp(px, 0.0, halfPi)),\n                sin(clamp(px - pi / 3.0, 0.0, halfPi)),\n                sin(clamp(px - 2.0 * pi / 3.0, 0.0, halfPi)),\n                1.0);\n}\n\n// black -> white via green and cyan for 0,1\nvec4 falsecolourg(float x, float stretch)\n{\n    float px = pow(clamp(x, 0.0, 1.0), stretch) * pi;\n    return vec4(sin(clamp(px - 2.0 * pi / 3.0, 0.0, halfPi)),\n                sin(clamp(px, 0.0, halfPi)),\n                sin(clamp(px - pi / 3.0, 0.0, halfPi)),\n                1.0);\n}\n\nvoid render(out vec4 fragColor, in vec2 fragCoord, vec3 ro, vec3 rd)\n{\n    \n    // number of points in fibsphere\n    float n = pow(2.0, log(maxn) / log(2.0) * smoothstep(0.0, 1.0, TIME / growtime)); \n    \n    // fibsphere location and size\n    vec3 sp = vec3(0.0);\n\tif (!EQUIRECTANGULAR) sp = vec3(0.0, 0.0, -2.0);\n    float sr = pow((n / maxn), 0.333) * (1.0 + 0.01 * cos(TIME));\n    \n    // mouse rotates it\n    float r1 = (iMouse.x / iResolution.x - 0.5) * twoPi;\n    float r2 = (iMouse.y / iResolution.y - 0.5) * twoPi;\n    r1 += TIME * 0.25;\n    \n    // transform and inverse matrices\n    mat4 ms = scaleMatrix(1.0 / sr) *\n              translationMatrix(-sp);\n    mat4 mr = rotationMatrix(forward, -r1) *\n              rotationMatrix(right, -r2);\n    mat4 mmr = rotationMatrix(right, r2) *\n        \t   rotationMatrix(forward, r1);\n    \n    \n    // check if an intersection is possible (in world space)\n    float t1, t2;\n    if (spherehit(sp, sr, ro, rd, t1, t2)) {\n        \n        \n        vec4 wp = vec4(ro + t1 * rd, 1.0);\n    \t// calculate hit of fibsphere (back in model space)\n        vec3 mp = vec3(mr * ms * wp), msn;\n        float idx, ir = fibspheren(mp, n, idx, msn);\n        \n        // surface normal back in world coords\n        vec3 sn = vec3(mmr * vec4(msn, 1.0));\n        \n        // colour it all pretty - similar to adding octaves of noise\n        // overlaying lots of waves gives it a cool mesmerising effect\n        float vrange = 0.5 + a1 * cos(f1 * (idx / maxn) + s1 * TIME) +\n            \t\t\ta2 * cos(f2 * (idx / maxn) + s2 * TIME);\n        \n        vec3 c = vec3(0.0, 1.0, 0.0); \n       // if (idx < 0.5) c = vec3(1.0, 0.0, 0.0); \n        if (KUSAMA_COLOR) c = vec3(0.86, 0.78, 0.1);\n        c*=smoothstep(.02, .0 , ir-0.1 + sin(iTime+idx)*.05);\n        //if (ir > 0.1 + sin(iTime + idx) * 0.05) c = vec3(0.0); \n        fragColor = vec4(c, 1.0); \n        \n        \n    \t// define the spherical coordinates, [-1, 1]\n    \tvec2 s = vec2(1.0 - (atan(mp.y, mp.x) * 0.5)  / pi, acos(mp.z) / pi); \n        //fragColor = vec4(fract(s*8.).xyy,1);\n    \t//fragColor = texture(iChannel0, s);\n    } else {\n        fragColor = vec4(1.0); \n        //fragColor = 0.3 + 0.3 * vec4(fragCoord.y / iResolution.y);\n    }\n}\n\nvoid mainVR(out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd)\n{\n    // the VR version does it for us\n    render(fragColor, fragCoord, ro, rd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n    // figure out where to look\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = lookat(ro, vec3(uv.x * tan(fov), uv.y * tan(fov), -1.0));\n    \n    if (EQUIRECTANGULAR) {\n   \t\tvec2 sph = fragCoord.xy / iResolution.xy * vec2(twoPi, pi);\n    \trd = vec3(sin(sph.y) * sin(sph.x), cos(sph.y), sin(sph.y) * cos(sph.x)); \n    }\n    render(fragColor, fragCoord, ro, rd);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tsczB.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1575, 1649, 1680, 1680, 1713], [1715, 1715, 1760, 1760, 2383], [2385, 2385, 2428, 2428, 2579], [2581, 2581, 2610, 2610, 2671], [2673, 2673, 2718, 2718, 2769], [2771, 2771, 2803, 2803, 2950], [2952, 2952, 2979, 2979, 3126], [3128, 3153, 3176, 3176, 3214], [3216, 3268, 3300, 3300, 3404], [3406, 3452, 3486, 3486, 3580], [3582, 3639, 3657, 3657, 3799], [3801, 3859, 3877, 3877, 3933], [3935, 3983, 4018, 4018, 4195], [4197, 4282, 4324, 4324, 4702], [4704, 4723, 4746, 4746, 4802], [4804, 4854, 4920, 4986, 6896], [7066, 7198, 7278, 7278, 7655], [7658, 7658, 7739, 7739, 7759], [7761, 7806, 7849, 7849, 8090], [8092, 8137, 8180, 8180, 8421], [8423, 8423, 8493, 8535, 10655], [10657, 10657, 10733, 10770, 10814], [10816, 10816, 10871, 10907, 11309]]}
{"id": "4tsczS", "name": "RayMarching Saturn Tes", "author": "YsmrRy", "description": "test", "tags": ["raymarch"], "likes": 2, "viewed": 108, "date": "1505290553", "time_retrieved": "2024-06-20T19:00:33.221306", "image_code": "vec3 lightDir = normalize(vec3(5.,5.,1.));\n\nvec3 onRep( vec3 p, float interval )\n{ return mod(p, interval) - interval * 0.5; }\n\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat distFunc( vec3 pos )\n{\n    pos.xz = mod(pos.xz,1.)-0.5*1.;\n    pos /= 0.5;\n    vec2 t = vec2(0.6,0.10);\n    float amp = 0.6*sin(iTime)+0.3;\n    pos.y -= amp;\n    vec2 q = vec2(length(pos.xz)-t.x,pos.y);\n\tfloat res = min( length(vec3(pos.x, pos.y, pos.z))-.2, pos.y+amp );\n    res = min( res, length(q)-t.y );\n    //res = min( res, pos.x-3. );\n    \n    return res*0.5;\n}\n\nvec3 getNormal( vec3 pos )\n{\n    float eps = 0.0001;\n    \n    return normalize( vec3( distFunc(pos)-distFunc(vec3( pos.x-eps, pos.y, pos.z )),\n                                              distFunc(pos)-distFunc(vec3( pos.x, pos.y-eps, pos.z )),\n                          \t\t\t\t\t  distFunc(pos)-distFunc(vec3( pos.x, pos.y, pos.z-eps ))) );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = distFunc( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy*2.-iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    vec3 col = vec3( 0. );\n    \n    vec3 camPos = vec3( 1., 6., 10. );\n    vec3 ray = normalize( vec3( uv, 0. ) - camPos );\n    vec3 cur = camPos, curM;\n    vec3 normal = vec3(0.);\n    float diff = 0.0;\n    bool hit = false;\n    float ite;\n    \n    for( int j = 0; j < 2; ++j )\n    {\n    \tfor( int i = 0; i < 200; ++i )\n    \t{\n            float d = distFunc( cur );\n            if( d < 0.0001 )\n            {\n                normal = getNormal( cur );\n                diff += 0.9*dot( normal, lightDir );\n                hit = true;\n                ite = float(i);\n                break;\n            }\n\n            cur += ray * d;\n        }\n        \n        if( j == 0 )\n            curM = cur;\n       \t\n        if( !hit || curM.y <= 0.01 )\n            break;\n        \n        cur += normal*0.01;\n        ray = reflect( ray, normal );\n    }\n    \n    if( curM.y <= 0.01 )\n    {\n        float f = mod( floor(5.0*cur.z) + floor(5.0*cur.x), 2.0);\n        col = 0.1 + 0.1*f*vec3(1.0);\n    }\n    \n    vec3 ref = reflect( ray, normal );\n    float spe = pow(clamp( dot( ref, lightDir ), 0.0, 1.0 ),16.0);\n    \n    col += 1.2*vec3( 0.7, 0.8, 0.9 )*1.3*vec3( diff )*hsv2rgb(vec3(curM.z/4.,0.8,1.0))*softshadow( cur, lightDir, 0.02, 2.5 )+vec3(0.1);\n    col += spe*vec3( diff );\n    col += 0.1*softshadow( cur, ref, 0.02, 2.5 );\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tsczS.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[44, 44, 82, 82, 126], [128, 128, 150, 150, 313], [315, 315, 343, 343, 690], [692, 692, 720, 720, 1032], [1034, 1034, 1108, 1108, 1371], [1373, 1373, 1430, 1430, 2870]]}
{"id": "4tsyRf", "name": "Circles with Layers", "author": "matt_aquino0802", "description": "a shader that creates 3 circles that overlap each other using layers", "tags": ["2d", "circles", "layers"], "likes": 0, "viewed": 84, "date": "1505775908", "time_retrieved": "2024-06-20T19:00:33.221306", "image_code": "// circles\nvec2 redCircle = vec2(0.45, 0.25);\nvec2 greenCircle = vec2(0.5, 0.25);\nvec2 blueCircle = vec2(0.55, 0.25);\n\nfloat radius = 0.1;\n\n// colors\nvec3 Red = vec3(1.0, 0.0, 0.0);\nvec3 Green = vec3(0.0, 1.0, 0.0);\nvec3 Blue = vec3(0.0, 0.0, 1.0);\n\nfloat frequency = 1.0;\nfloat amplitude = 0.5;\n\n// creates a transparent layer\nvec4 Transparent = vec4(0.0, 0.0, 0.0, 0.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n \tvec2 uv = fragCoord.xy / iResolution.xy;\n \n \tfloat aspectRatio = iResolution.y / iResolution.x;\n    \n    uv.y *= aspectRatio;\n    \n    // animates the green circle to move up and down, while keeping the circle visible\n    greenCircle.y = (abs(sin(iTime * frequency) + 1.0) / 2.0) * amplitude;\n    \n    vec4 Layer1 = vec4(1.0, 1.0, 1.0, 1.0);\n\tvec4 Layer2;\n\tvec4 Layer3;\n\tvec4 Layer4;\n    \n    \n    // draws red circle layer\n    if (length(redCircle - uv) < radius)\n        Layer2 = vec4(Red, 1.0);\n    else\n        Layer2 = Transparent;\n    \n    // draws green circle layer\n    if (length(greenCircle - uv) < radius)\n        Layer3 = vec4(Green, 1.0);\n    else\n        Layer3 = Transparent;\n    \n    // draws blue circle layer\n    if (length(blueCircle - uv) < radius)\n        Layer4 = vec4(Blue, 1.0);\n    else\n       \tLayer4 = Transparent;\n    \n    // blends layers over each other\n    vec4 Composite = mix(Layer1, Layer2, Layer2.a);\n    Composite = mix(Composite, Layer3, Layer3.a);\n    Composite = mix(Composite, Layer4, Layer4.a);\n    \n    fragColor = Composite;\n\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tsyRf.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[297, 374, 431, 431, 1505]]}
{"id": "4tsyWS", "name": "Alien Light", "author": "Yetman", "description": "2D spot-light with a sine wave pattern, chromatic split and noise.", "tags": ["procedural", "2d", "noise", "wave"], "likes": 4, "viewed": 621, "date": "1506324400", "time_retrieved": "2024-06-20T19:00:33.609341", "image_code": "#define PI 3.1415926535897932384626433832795\n#define PI2 (2.0*PI)\n#define WAVE_FREQ 75.0\n#define COMPRESSION_FACTOR 1.0\n#define WAVE_SPEED 30.0\n#define NOISE_SCALE 5.0\n#define NOISE_SPEED 100.0\n#define NOISE_INTENSITY 0.7\n#define WAVE_FADE_FACTOR 7.0\n#define CHROMATIC_OFFSET 0.04\n#define CONE_HALF_ANGLE atan(1.0,1.0)\n#define CONE_CENTER vec2(0.0, 1.0)\n#define CONE_DIRECTION vec2(0.0, -1.0)\n#define CONE_FADE_FACTOR 2.0\n#define LIGHT_INTENSITY 1.5\n\n//all rand and noise functions from https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nfloat limit_angle(float angle){\n    return PI2 * fract(angle / PI2);\n}\n\nfloat eval(vec2 delta){\n\tfloat dist = length(delta);\n    float x = WAVE_FREQ*dist;\n    x *= 1.0+(COMPRESSION_FACTOR*dist);\n    x -= WAVE_SPEED*iTime;\n    float wave = 0.5 + (0.5*sin(limit_angle(x)));\n    //1e5 added below to abuse the problem of sin function \n    //when using high floating points to make a glitch effect\n    //NOTE: this is probably not a reliable way to make an effect since it may not work on other devices\n    vec2 noise_kernel = NOISE_SCALE*delta + NOISE_SPEED*fract(iTime) + 1e5; \n    float noise_val = NOISE_INTENSITY*rand(noise(noise_kernel));\n    float fade = 1.0+WAVE_FADE_FACTOR*dist*dist;\n\treturn (wave + noise_val)/fade;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const vec2 center = CONE_CENTER;\n    const vec2 direction = normalize(CONE_DIRECTION);\n    const vec2 orthogonal = vec2(-direction.y, direction.x);\n\tvec2 p = (2.0*fragCoord.xy - iResolution.xy)/iResolution.yy;\n    vec2 delta = p - center;\n    vec2 offset = CHROMATIC_OFFSET*orthogonal;\n\tfloat r = eval( delta + offset );\n\tfloat gb = eval( delta - offset );\n    float ang = atan(dot(delta, orthogonal), dot(delta, direction)) / CONE_HALF_ANGLE;\n\tfloat intensity = max(0.0, 1.0/(1.0+CONE_FADE_FACTOR*ang*ang) - 1.0/(1.0 + CONE_FADE_FACTOR));\n\tfragColor = vec4(vec3(r, gb, gb) * intensity * LIGHT_INTENSITY, 1.0);\n\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tsyWS.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[451, 553, 573, 573, 611], [613, 613, 633, 633, 700], [702, 702, 722, 722, 931], [933, 933, 964, 964, 1003], [1005, 1005, 1028, 1028, 1657], [1661, 1661, 1718, 1718, 2337]]}
{"id": "4tsyWX", "name": "I can't go (171c)", "author": "PrzemyslawZaworski", "description": "I am dreaming and in darkness I can see strange path leading to Infinity. \nMaybe there I will find answers to all the questions ?", "tags": ["procedural", "3d", "fractal", "time", "dream", "golf", "twotweet"], "likes": 2, "viewed": 112, "date": "1506670602", "time_retrieved": "2024-06-20T19:00:33.609341", "image_code": "void mainImage(out vec4 c, vec2 f) {\nvec2 u=iResolution.xy;\nu =(f+f-u)/u.y;\nc = vec4(u+vec2(cos(u.y*5.+iTime)/5.,2),2,0);\n    for (int i = 0; i++<50; c=vec4(1.2,0,1.4,0)*abs(c/dot(c,c)-vec4(0,0,.9,0)));}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tsyWX.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 36, 36, 203]]}
{"id": "4tXcRl", "name": "Simple Greeble - Split4", "author": "blackjero", "description": "Manual unroll of so called shape grammar split (for \"man made\" tech detail) applied to a rough procedural reconstruction of the first few seconds of the death star trench sequence.\nMouse to look around (2 camera paths) ", "tags": ["tech", "tiles", "greeble", "split", "laserbeam", "deathstar", "trench", "shapegrammar", "cineshader"], "likes": 96, "viewed": 6530, "date": "1505881974", "time_retrieved": "2024-06-20T19:00:40.597665", "image_code": "// Simple Greeble - Split4 by Jerome Liard, August 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://www.shadertoy.com/view/4tXcRl\n\n// Manual unroll of so called shape grammar split (for \"man made\" tech detail)\n// applied to a rough procedural reconstruction of the first few seconds of the death star trench sequence.\n// Mouse to look around (2 camera paths)\n\n// I was initially working on split/subdivided tiles for something else,\n// but as it started to look familiar I pushed in the fan art direction.\n//\n// The tiles use several hardcoded quad split variants (all resulting in 4 children),\n// and we recurse down 1 level on a couple of them (max 10 leaves).\n//\n// I find the lack of motion blur disturbing, but time was spent on other futile things instead.\n\n#if 1\n#define TIME_OFFSET 0.0\n#define CAM2_TIME_OFFSET 0.0\n#else\n#define TIME_OFFSET 54.0\n#define CAM2_TIME_OFFSET 7.0\n#endif\n#define CAMERA_REPEAT\n// tile eval count (x1 x2 x4 (max)... to deal with cell boundaries), the more evals the less artifacts but it also depend on a ton of other things - use 1 or 2 really\n#define NUM_TILE_EVALS 1\n// warp first iteration with raytracing to reduce trace iteration count, affects lighting a bit\n#define RAYTRACE_FIRST_MARCH_DISTANCE\n// small trace optim that creates color disparity as a side effect (a bug promoted into a feature)\n#define RAYMARCH_WITH_LOD\n// allow proper shadows close to us, expensive and doesn't contribute that much... disable\n//#define TRACED_SHADOW\n// do the main cast shadow analytically\n#define ANALYTICAL_SHADOW\n// worry not, it's not screenspace\n#define AO\n// color tiles (debug)\n//#define COLOR_TILES\n#define STARFIELD\n#define SUN\n// scene type\n//#define PRIMITIVES\n#define SORT_OF_MOON\n#define LASERS\n// max marching iterations\n#define MAX_ITERATIONS 140\n// tweak for perfs vs quality etc\n#define DBREAK 0.00125\n#define TMAX 200.0\n#define TFRAC 0.5\n\n// threshold distance used by RAYMARCH_WITH_LOD and RAYTRACE_FIRST_MARCH_DISTANCE\n#define ROUGH_SHELL_D 0.45\n\n#define FLYING_SPEED 10.0\n#define TRENCH_DEPTH 4.8\n#define TRENCH_HALF_WIDTH 2.0\n\nfloat PI = 3.141592654;\n\n#ifndef FLT_MAX\n#define FLT_MAX 1000000.0\n#endif\n\nvec3 RED\t = vec3( 1, 0, 0 );\nvec3 GREEN\t = vec3( 0, 1, 0 );\nvec3 BLACK\t = vec3( 0, 0, 0 );\n\nvec2 xset( vec2 p, float v ) { return vec2( v, p.y );}\nvec2 yset( vec2 p, float v ) { return vec2( p.x, v );}\nvec3 xset( vec3 p, float v ) { return vec3( v, p.y, p.z );}\nvec3 yset( vec3 p, float v ) { return vec3( p.x, v, p.z );}\nvec3 zset( vec3 p, float v ) { return vec3( p.x, p.y, v );}\n\n#define IMPL_SATURATE(type) type saturate( type x ) { return clamp( x, type(0.0), type(1.0) ); }\nIMPL_SATURATE( float )\nIMPL_SATURATE( vec2 )\nIMPL_SATURATE( vec3 )\nIMPL_SATURATE( vec4 )\n\nfloat smoothstep_unchecked( float x ) { return ( x * x ) * ( 3.0 - x * 2.0 ); }\nvec2 smoothstep_unchecked( vec2 x ) { return ( x * x ) * ( 3.0 - x * 2.0 ); }\nvec3 smoothstep_unchecked( vec3 x ) { return ( x * x ) * ( 3.0 - x * 2.0 ); }\n// cubicstep is a generic smoothstep where you can set in and out slopes\n// slope at x=0 is df0\n// slope at x=1 is df1\n// smoothstep_unchecked(x) == cubicstep(x,0,0)\nfloat cubicstep( float x, float df0, float df1 ) { float b = 3.0 - df1 - 2.0 * df0; float a = 1.0 - df0 - b; return ( ( a * x + b ) * x + df0 ) * x; }\nfloat linearstep( float a, float b, float x ) { return saturate( ( x - a ) / ( b - a ) ); }\nfloat smoothbump( float a, float r, float x ) { return 1.0 - smoothstep_unchecked( min( abs( x - a ), r ) / r ); }\nvec2 perp( vec2 v ) { return vec2( -v.y, v.x ); }\nfloat calc_angle( vec2 v ) { return atan( v.y, v.x ); }\nfloat calc_angle( vec2 a, vec2 b ) { return calc_angle( vec2( dot( a, b ), dot( perp( a ), b ) ) ); }\nvec3 contrast( vec3 x, vec3 s ) { return ( x - 0.5 ) * s + 0.5; }\nfloat lensqr( vec2 v ) { return dot( v, v ); }\nfloat lensqr( vec3 v ) { return dot( v, v ); }\nfloat lensqr( vec4 v ) { return dot( v, v ); }\nfloat pow2( float x ) { return x * x; }\nfloat pow4( float x ) { x *= x; x *= x; return x; }\nvec4 pow2( vec4 x ) { return x * x; }\nvec4 pow4( vec4 x ) { x *= x; x *= x; return x; }\nfloat pow5( float x ) { float x2 = x * x; return x2 * x2 * x; }\nfloat maxcomp( float x ) { return x; }\nfloat maxcomp( vec2 v ) { return max( v.x, v.y ); }\nfloat maxcomp( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat mincomp( float x ) { return x; }\nfloat mincomp( vec2 v ) { return min( v.x, v.y ); }\nfloat mincomp( vec3 v ) { return min( min( v.x, v.y ), v.z ); }\nfloat box( float x ) { return abs( x ) < 1.0 ? 1.0 : 0.0; }\nvec3 chrominance( vec3 c ) { return c / max( c.r, max( c.g, c.b ) ); }\nvec3 luminance( vec3 c ) { return vec3( dot( vec3( 0.2989, 0.5866, 0.1145 ), c ) ); }\n\n// project this on line (O,d), d is assumed to be unit length for project_on_line1\n// project_on_liney: d = 0,1,0\n#define PROJECT_ON_LINE1(type) \\\ntype project_on_liney( type P, type O ) { O.y += ( P - O ).y; return O; } /* d = vec3(0,1,0) */\n\nPROJECT_ON_LINE1( vec2 )\nPROJECT_ON_LINE1( vec3 )\n\n#define DECL_BOUNDS( btype, type, booltype ) \\\nstruct btype { type pmin; type pmax; }; \\\n/* min,max constructor*/ \\\nbtype mkbounds_unchecked( type amin, type amax ) { btype ret; ret.pmin = amin; ret.pmax = amax; return ret; } \\\n/*btype mkbounds_unchecked_invalid() { btype ret; ret.pmin = FLT_MAX; ret.pmax = -FLT_MAX; return ret; }*/ \\\ntype size( btype b ) { return b.pmax - b.pmin; } \\\ntype center( btype b ) { return 0.5 * ( b.pmax + b.pmin ); } \\\ntype closest( btype b, type p ) { return min( max( p, b.pmin ), b.pmax ); } \\\nbool inside( btype b, type p ) { return all_( /*booltype*/( p == closest( b, p ) ) ); }\n\nbool all_( bool value ) { return value; } // not defined in glsl, apparently + can't use same name else some compilers barf\nbool all_( bvec2 value ) { return all( value ); }\nbool all_( bvec3 value ) { return all( value ); }\n\nDECL_BOUNDS( bounds1, float, bool )\nDECL_BOUNDS( bounds2, vec2, bvec2 )\nDECL_BOUNDS( bounds3, vec3, bvec3 )\n\nbounds3 mkbounds_unchecked( bounds2 b, float height )\n{\n\tbounds3 ret;\n\tret.pmin = vec3( b.pmin.xy, 0 );\n\tret.pmax = vec3( b.pmax.xy, height );\n\treturn ret;\n}\nbounds2 xy( bounds3 b ) { return mkbounds_unchecked( b.pmin.xy, b.pmax.xy  ); }\nbounds2 xy( bounds2 b ) { return b; }\n\n#define REPEAT_FUNCTIONS( type, btype ) \\\ntype repeat( type x, type len ) { return len * fract( x * ( type( 1.0 ) / len ) ); }\\\ntype repeat_mirror( type x, type len ) { return len * abs( type( -1.0 ) + 2.0 * fract( ( ( x * ( type( 1.0 ) / len ) ) - type( -1.0 ) ) * 0.5 ) ); }\n\nREPEAT_FUNCTIONS( float, bounds1 )\nREPEAT_FUNCTIONS( vec2, bounds2 )\nREPEAT_FUNCTIONS( vec3, bounds3 )\n\n#define TRI_FUNCTIONS(type,btype) \\\n/* y=1-x on 0,1, output 0,1 */ \\\ntype tri0( type x ) { return abs( fract( x * 0.5 ) - type(0.5) ) * 2.0; } \\\n/* function returns 0 at x = half_width */ \\\ntype tri_p( type x, type half_width, type half_period )\t{ return half_width - repeat_mirror( x, half_period ); }\n\nTRI_FUNCTIONS( float, bounds1 )\nTRI_FUNCTIONS( vec2, bounds2 )\nTRI_FUNCTIONS( vec3, bounds3 )\n\nfloat spaced_tri( float x, float period, float half_width ) { period *= 0.5; x /= period; return max( 0.0, 1.0 + ( tri0( x ) - 1.0 ) * ( period / half_width ) ); }\nfloat spaced_bumps( float x, float s, float r ) { return smoothstep_unchecked( spaced_tri( x, s, r ) ); }\n\n// hash functions from David Hoskins's https://www.shadertoy.com/view/4djSRW\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n//#define HASHSCALE3 443.8975\n//#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n//#define HASHSCALE3 vec3(443.897, 441.423, 437.195, 444.129)\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21( float p )\n{\n\tvec3 p3 = fract( vec3( p ) * HASHSCALE3 );\n\tp3 += dot( p3, p3.yzx  + 19.19 );\n\treturn fract( ( p3.xx  + p3.yz  ) * p3.zy  );\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22( vec2 p )\n{\n\tvec3 p3 = fract( vec3( p.xyx  ) * HASHSCALE3 );\n\tp3 += dot( p3, p3.yzx  + 19.19 );\n\treturn fract( ( p3.xx  + p3.yz  ) * p3.zy  );\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32( vec2 p )\n{\n\tvec3 p3 = fract( vec3( p.xyx ) * HASHSCALE3 );\n\tp3 += dot( p3, p3.yxz  + 19.19 );\n\treturn fract( ( p3.xxy  + p3.yzz  ) * p3.zyx );\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42( vec2 p )\n{\n\tvec4 p4 = fract( vec4( p.xyxy  ) * HASHSCALE4 );\n\tp4 += dot( p4, p4.wzxy  + 19.19 );\n\treturn fract( ( p4.xxyz + p4.yzzw ) * p4.zywx );\n\n}\n\nvec2 V30 = vec2( 0.866025403, 0.5 );\nvec2 V45 = vec2( 0.707106781, 0.707106781 );\n\nvec2 unit_vector2( float angle ) { return vec2( cos( angle ), sin( angle ) ); }\nvec2 rotate_with_unit_vector( vec2 p, vec2 cs ) { return vec2( cs.x * p.x - cs.y * p.y, cs.y * p.x + cs.x * p.y ); }\nvec2 rotate_with_angle( vec2 p, float a_angle ) { return rotate_with_unit_vector( p, unit_vector2( a_angle ) ); }\n\n// theta is angle with the z axis, range [0,pi].\n// phi is angle with x vectors on z=0 plane, range [0,2pi].\nvec3 zup_spherical_coords_to_vector( float theta, float phi )\n{\n\tvec2 theta_vec = unit_vector2( theta );\n\tvec2 phi_vec = unit_vector2( phi );\n\treturn vec3( theta_vec.y * phi_vec, theta_vec.x );\n}\n\nvec3 yup_spherical_coords_to_vector( float theta, float phi ) { return zup_spherical_coords_to_vector( theta, phi ).yzx; }\n\nmat4 yup_spherical_offset( float theta, float phi )\n{\n\tvec3 y = yup_spherical_coords_to_vector( theta, phi );\n\tvec3 z = yup_spherical_coords_to_vector( theta + PI * 0.5, phi );\n\tvec3 x = cross( y, z );\n\treturn mat4( vec4( x, 0.0 ), vec4( y, 0.0 ), vec4( z, 0.0 ), vec4( 0, 0, 0, 1 ) );\n}\n\n// debug visualization\nvec3 viridis_quintic( float x )\n{\n\tx = saturate( x );\n\tvec4 x1 = vec4( 1.0, x, x * x, x * x * x ); // 1 x x2 x3\n\tvec4 x2 = x1 * x1.w * x; // x4 x5 x6 x7\n\treturn vec3(\n\t\tdot( x1.xyzw, vec4( +0.280268003, -0.143510503, +2.225793877, -14.815088879 ) ) + dot( x2.xy, vec2( +25.212752309, -11.772589584 ) ),\n\t\tdot( x1.xyzw, vec4( -0.002117546, +1.617109353, -1.909305070, +2.701152864 ) ) + dot( x2.xy, vec2( -1.685288385, +0.178738871 ) ),\n\t\tdot( x1.xyzw, vec4( +0.300805501, +2.614650302, -12.019139090, +28.933559110 ) ) + dot( x2.xy, vec2( -33.491294770, +13.762053843 ) ) );\n}\n\nstruct Ray { vec3 o; vec3 d; };\n\nRay get_view_ray( vec2 normalized_pos, float z, float aspect, float tan_half_fovy )\n{\n\tRay view_ray;\n\tview_ray.o = vec3( normalized_pos * vec2( aspect, 1.0 ) * tan_half_fovy, -1.0 ) * z;\n\tview_ray.d = normalize( view_ray.o );\n\treturn view_ray;\n}\n\nmat4 lookat( vec3 eye, vec3 center, vec3 up )\n{\n\tvec3 z = normalize( eye - center );\n    vec3 x = normalize( cross( up, z ) );\n\treturn mat4( vec4( x, 0.0 ), vec4( cross( z, x ), 0.0 ), vec4( z, 0.0 ), vec4( eye, 1.0 ) );\n}\n\nfloat opU( float d1, float d2 ) { return -max( -d1, -d2 ); }\nfloat opS( float d1, float d2 ) { return max( -d2, d1 );}\nfloat opI( float d1, float d2 ) { return max( d1, d2 ); }\nfloat opI( float d1, float d2, float d3 ) { return max( max( d1, d2 ), d3 ); }\n\nfloat sd_bounds_half_size( float p, float h ) { p = abs( p ) - h; return p; }\nfloat sd_bounds_half_size( vec2 p, vec2 h ) { p = abs( p ) - h; return opI( p.x, p.y ); }\nfloat sd_bounds_half_size( vec3 p, vec3 h ) { p = abs( p ) - h; return opI( p.x, p.y, p.z ); }\nfloat sd_bounds_range( vec2 p, vec2 mi, vec2 ma ) { vec2 hmi = mi * 0.5; vec2 hma = ma * 0.5; return sd_bounds_half_size( p - ( hma + hmi ), hma - hmi ); }\nfloat sd_bounds_range( float p, float mi, float ma ) { return sd_bounds_half_size( p - ( ( ma + mi ) * 0.5 ), ( ma - mi ) * 0.5 ); }\nfloat sd_bounds_range( vec3 p, vec3 mi, vec3 ma ) { return sd_bounds_half_size( p - ( ( ma + mi ) * 0.5 ), ( ma - mi ) * 0.5 ); }\nfloat sd_bounds( vec2 p, bounds2 b ) { return sd_bounds_range( p, b.pmin, b.pmax ); }\nfloat sd_bounds( vec3 p, bounds3 b ) { return sd_bounds_range( p, b.pmin, b.pmax ); }\n\nstruct Plane2 { vec2 base; vec2 normal; };\nstruct Plane { vec3 base; vec3 normal; };\n\nPlane2 mkplane2( vec2 base, vec2 normal ) { Plane2 plane; plane.base = base; plane.normal = normal; return plane; }\nPlane mkplane( vec3 base, vec3 normal ) { Plane plane; plane.base = base; plane.normal = normal; return plane; }\n\n// a few tediously hardcoded subdivisions that generates 4 children\n\n#define SPLIT4_BOUNDS\n\nstruct Split4\n{\n#ifdef SPLIT4_BOUNDS\n\tbounds2 b00;\n\tbounds2 b01;\n\tbounds2 b10;\n\tbounds2 b11;\n#endif\n\tvec4 d;\n};\n\nvec4 get_distances( vec2 p, Split4 split )\n{\n#if 1\n\treturn split.d;\n#else\n// should be same result\n\tvec4 d;\n\td.x = sd_bounds_range( p, split.b00.pmin, split.b00.pmax );\n\td.y = sd_bounds_range( p, split.b01.pmin, split.b01.pmax );\n\td.z = sd_bounds_range( p, split.b10.pmin, split.b10.pmax );\n\td.w = sd_bounds_range( p, split.b11.pmin, split.b11.pmax );\n\treturn d;\n#endif\n}\n\nSplit4 sd_Split_b_xxx( vec2 p, vec2 mi, vec2 ma, vec3 s )\n{\n//  -------------------------\n//  |     |\t    |     |     |\n//  | b00 | b01 | b10 | b11 |\n//  |     |\t    |     |     |\n//  -------------------------\n//     x10     x0    x11\n\n\tfloat x0 = mix( mi.x, ma.x, s.x );\n\tfloat x10 = mix( mi.x, x0, s.y );\n\tfloat x11 = mix( x0, ma.x, s.z );\n\n#if 0\n// diagonal features\n\tfloat dx = linearstep( 0.4, 0.6, ( p.y - mi.y ) / ( ma.y - mi.y ) ) * ( ma.x - mi.x ) * 0.15;\n\tx0 += dx;\n\tx10 += dx;\n\tx11 += dx;\n#endif\n\n\tSplit4 split;\n\t//\n#ifdef SPLIT4_BOUNDS\n\tsplit.b00 = mkbounds_unchecked( mi, xset( ma, x10 ) );\n\tsplit.b01 = mkbounds_unchecked( xset( mi, x10 ), xset( ma, x0 ) );\n\tsplit.b10 = mkbounds_unchecked( xset( mi, x0 ), xset( ma, x11 ) );\n\tsplit.b11 = mkbounds_unchecked( xset( mi, x11 ), ma );\n#endif\n\t//\n\tfloat d = sd_bounds_range( p, mi, ma );\n\tfloat a = p.x - x0;\n\tfloat d0 = opI( a, d );\n\tfloat d1 = opI( -a, d );\n\tfloat b = p.x - x10;\n\tsplit.d.x = opI( d0, b );\n\tsplit.d.y = opI( d0, -b );\n\tfloat c = p.x - x11;\n\tsplit.d.z = opI( d1, c );\n\tsplit.d.w = opI( d1, -c );\n\t//\n\treturn split;\n}\n\nSplit4 sd_Split_b_xyy( vec2 p, vec2 mi, vec2 ma, vec3 s )\n{\n//     ---------------\n//     | \t  |      |\n//     | b01  |  b11 |\n// y10 | -----|      |\n//     | \t  |------| y11\n//     | b00  |  b10 |\n//     ---------------\n//            x0\n\n\tfloat x0 = mix( mi.x, ma.x, s.x );\n\tfloat y10 = mix( mi.y, ma.y, s.y );\n\tfloat y11 = mix( mi.y, ma.y, s.z );\n\n#if 1\n// diagonal features\n\tfloat dx = linearstep( 0.4, 0.6, ( p.y - mi.y ) / ( ma.y - mi.y ) ) * ( ma.x - mi.x ) * 0.15;\n\tx0 += dx;\n#endif\n\n\tSplit4 split;\n\t//\n#ifdef SPLIT4_BOUNDS\n\tsplit.b00 = mkbounds_unchecked( mi, vec2( x0, y10 ) );\n\tsplit.b01 = mkbounds_unchecked( yset( mi, y10 ), xset( ma, x0 ) );\n\tsplit.b10 = mkbounds_unchecked( xset( mi, x0 ), yset( ma, y11 ) );\n\tsplit.b11 = mkbounds_unchecked( vec2( x0, y11 ), ma );\n#endif\n\t//\n\tfloat d = sd_bounds_range( p, mi, ma );\n\tfloat a = p.x - x0;\n\tfloat d0 = opI( a, d );\n\tfloat d1 = opI( -a, d );\n\tfloat b = p.y - y10;\n\tsplit.d.x = opI( d0, b );\n\tsplit.d.y = opI( d0, -b );\n\tfloat c = p.y - y11;\n\tsplit.d.z = opI( d1, c );\n\tsplit.d.w = opI( d1, -c );\n\t//\n\treturn split;\n}\n\nSplit4 sd_Split_b_xyx( vec2 p, vec2 mi, vec2 ma, vec3 s )\n{\n// \t   ------------------\n//     | b01 |     |    |\n// y10 | ----| b10 | b11|\n//     | b00 |     |    |\n// \t   ------------------\n// \t        x0    x11\n\n\tfloat x0 = mix( mi.x, ma.x, s.x );\n\n#if 0\n// diagonal features (a bit too much)\n\tfloat dx = linearstep( 0.4, 0.6, ( p.y - mi.y ) / ( ma.y - mi.y ) ) * ( ma.x - mi.x ) * 0.15;\n\tx0 += dx;\n#endif\n\n\tfloat y10 = mix( mi.y, ma.y, s.y );\n\tfloat x11 = mix( x0, ma.x, s.z );\n\n#if 0\n// diagonal feature (a bit too much)\n\tfloat dx = linearstep( 0.4, 0.6, ( p.y - mi.y ) / ( ma.y - mi.y ) ) * ( ma.x - mi.x ) * 0.15;\n\tx11 += dx;\n#endif\n\n\t//\n\tSplit4 split;\n#ifdef SPLIT4_BOUNDS\n\tsplit.b00 = mkbounds_unchecked( mi, vec2( x0, y10 ) );\n\tsplit.b01 = mkbounds_unchecked( yset( mi, y10 ), xset( ma, x0 ) );\n\tsplit.b10 = mkbounds_unchecked( xset( mi, x0 ), xset( ma, x11 ) );\n\tsplit.b11 = mkbounds_unchecked( xset( mi, x11 ), ma );\n#endif\n\t//\n\tfloat d = sd_bounds_range( p, mi, ma );\n\tfloat a = p.x - x0;\n\tfloat d0 = opI( a, d );\n\tfloat d1 = opI( -a, d );\n\tfloat b = p.y - y10;\n\tsplit.d.x = opI( d0, b );\n\tsplit.d.y = opI( d0, -b );\n\tfloat c = p.x - x11;\n\tsplit.d.z = opI( d1, c );\n\tsplit.d.w = opI( d1, -c );\n\t//\n\treturn split;\n}\n\n// that one can't be expressed as a 2 levels split, but as an incomplete level 3 (we only store 4 bounds)\nSplit4 sd_Split_b_H( vec2 p, vec2 mi, vec2 ma, vec3 s )\n{\n//   --------------------\n//   |     |  b10 |     |\n//   |     |\t  |     |\n//   | b00 |------| b11 | y20\n//   |     |\t  |     |\n//   |     |  b01 |     |\n//   --------------------\n//         x0    x10\n\n\t// note: we sort s.x and s.z, it make this function easier to use\n\tfloat x0 = mix( mi.x, ma.x, min( s.x, s.z ) );\n\tfloat y20 = mix( mi.y, ma.y, s.y );\n\tfloat x10 = mix( x0, ma.x, max( s.x, s.z ) );\n\tSplit4 split;\n\t//\n#ifdef SPLIT4_BOUNDS\n\tsplit.b00 = mkbounds_unchecked( mi, xset( ma, x0 ) );\n\tsplit.b01 = mkbounds_unchecked( xset( mi, x0 ), vec2( x10, y20 ) );\n\tsplit.b10 = mkbounds_unchecked( vec2( x0, y20 ), xset( ma, x10 ) );\n\tsplit.b11 = mkbounds_unchecked( xset( mi, x10 ), ma );\n#endif\n\t//\n\tfloat d = sd_bounds_range( p, mi, ma );\n\tfloat d0 = opI( p.x - x0, d );\n\tfloat d1 = opI( -p.x + x0, d );\n\tfloat d20 = opI( p.x - x10, d1 );\n\tfloat d21 = opI( -p.x + x10, d1 );\n\tsplit.d.x = opI( d0, p.x - x0 );\n\tsplit.d.y = opI( d20, -p.y + y20 );\n\tsplit.d.z = opI( d20, p.y - y20 );\n\tsplit.d.w = opI( d21, -p.x + x10 );\n\t//\n\treturn split;\n}\n\nstruct TechTilesArgs\n{\n\tvec4 height0, height10, height11;\n\tvec3 size0, size10, size11; //relative\n\tbool sub10, sub11; // recurse or not\n};\n\n// d stores 4 df for 4 boxes, h stored boxes height\nfloat getDist4( float z, vec4 d, vec4 h )\n{\n\tvec4 v = vec4( z ) - h;\n\treturn opU( opU( opI( v.x, d.x ), opI( v.y, d.y ) ),\n\t\t\t\topU( opI( v.z, d.z ), opI( v.w, d.w ) ) );\n}\n\n// 4 scopes output + recurse 2 of them\nfloat sd_TechTilesTestsSub( vec3 p, int lod, float t, TechTilesArgs args, float e )\n{\n\tvec4 d = vec4( FLT_MAX );\n\tvec4 heights = args.height0;\n\n//\tSplit4 b = sd_Split_b_xxx( p.xy, vec2( 0, 0 ), vec2( 1, 1 ), args.size0 );\n//\tSplit4 b = sd_Split_b_xyy( p.xy, vec2( 0, 0 ), vec2( 1, 1 ), args.size0 );\n\tSplit4 b = sd_Split_b_xyx( p.xy, vec2( 0, 0 ), vec2( 1, 1 ), args.size0 );\n//\tSplit4 b = sd_Split_b_H( p.xy,vec2( 0, 0 ), vec2( 1, 1 ), args.size0 );\n\n\td = get_distances( p.xy, b ) + e;\n\n#ifdef SPLIT4_BOUNDS\n\tif ( args.sub10 )\n\t{\n\t\t// do one more level\n\t\tSplit4 b2 = sd_Split_b_xyy( p.xy, b.b01.pmin, b.b01.pmax, args.size10 );\n\t\tvec4 d2 = get_distances( p.xy, b2 ) + e;\n\t\td.y = getDist4( p.z, d2, args.height10 );\n\t\theights = max( heights, args.height10 );\n\t}\n#endif\n\n#ifdef SPLIT4_BOUNDS\n\tif ( args.sub11 )\n\t{\n\t\t// do one more level\n\t\tSplit4 b2 = sd_Split_b_xxx( p.xy, b.b11.pmin, b.b11.pmax, args.size11 );\n\t\tvec4 d2 = get_distances( p.xy, b2 ) + e;\n\t\td.w = getDist4( p.z, d2, args.height11 );\n\t\theights = max( heights, args.height11 );\n\t}\n#endif\n\n\treturn getDist4( p.z, d, heights );\n}\n\nstruct TechTilesArgs0\n{\n\tfloat hmin;\n\tfloat hmax;\n\tfloat hdetail; // the height of sub detail\n};\n\nfloat sd_TechTilesTestsSub0( vec3 p, int lod, float t, Ray ray, vec2 index, TechTilesArgs0 targs )\n{\n\tfloat d = FLT_MAX;\n\n//\td = opI( p.z - 1.0, sd_bounds_range( p.xy, vec2( 0, 0 ), vec2( 1, 1 ) ) );\n//\treturn d;\n\n\tfloat e0 = 0.0125 * 2.0;\n\tfloat e = e0 + t * 0.001; // else e becomes 0 as far as tracing is concerned... increases cost\n\n\tTechTilesArgs args;\n\n\tvec4 ha = hash42( index );\n\tvec4 hb = hash42( index + 100.0 );\n\n\tfloat rnd_type_and_rotation = ha.w;\n\tvec3 size0_hash = ha.xyz;\n\tvec4 height0_hash = hb;\n\n\targs.sub10 = rnd_type_and_rotation < 0.6;\n\targs.sub11 = rnd_type_and_rotation < 0.3;\n\n\tfloat rota = fract( rnd_type_and_rotation * 3.0 );\n\tif ( rota < 0.25 ) p.xy = p.yx;\n\telse if ( rota < 0.5 ) p.xy = vec2( 1.0 - p.y, p.x );\n\n\tfloat m1 = 0.15;\n\targs.size0 = m1 + ( 1.0 - m1 * 2.0 ) * size0_hash; // hash32 expensive\n\n\targs.size10 = vec3( 0.25, 0.5, 0.75 );\n\targs.height10 = vec4( 1.0 );\n//\targs.height10 = hash42( index + 80.0 ) * 0.25; // don't hash all... leave splits is interesting too\n\n\targs.size11 = vec3( 0.25, 0.5, 0.5 );\n\targs.height11 = vec4( 1.0 );\n//\targs.height11 = hash42( index + 85.0 ) * 0.25;\n\n\targs.height0 = mix( vec4( targs.hmin ), vec4( targs.hmax ), height0_hash );\n\n\targs.height10 = args.height0 + targs.hdetail * args.height10;\n\targs.height11 = args.height0 + targs.hdetail * args.height11;\n\n\td = sd_TechTilesTestsSub( p, lod, t, args, e );\n\n\t// bevel\n\td = opI( d, dot( p - vec3( 0, 0, 0.1 ), vec3( -V45.x, 0, V45.y ) ) );\n\td = opI( d, dot( p - vec3( 0, 0, 0.1 ), vec3( 0, -V30.x, V30.y ) ) );\n\n\treturn d;\n}\n\n// feature max height will be hscale*2\nfloat sd_TechTiles( vec3 p, int lod, float t, Ray ray, TechTilesArgs0 targs, float e )\n{\n#if ( NUM_TILE_EVALS == 2 )\n\n\t// we do 2 evals in alternate checker patterns, \"only\" x2 cost and relatively clean\n\t// it still has corner cases (ha..ha..) but help in some situations\n\n\tfloat d = FLT_MAX;\n\n\tvec2 index0 = floor( p.xy );\n\tvec2 indexi = index0;\n\tfloat m = mod( indexi.x + indexi.y, 2.0 );\n\n\tvec2 dd;\n\n\tfor ( int k = 0; k < 2; k += 1 )\n\t{\n\t\tvec3 p2 = p;\n\t\tvec2 index = index0;\n\t\tp2.xy = p.xy - index;\n\n\t\tif ( m == float( k ) )\n\t\t{\n\t\t\tvec2 offset = vec2( 0.0 );\n\t\t\tvec2 rp2 = p2.xy - 0.5;\n\t\t\tif ( abs( rp2.y ) > abs( rp2.x ) ) offset.y += rp2.y > 0.0 ? 1.0 : -1.0;\n\t\t\telse offset.x += rp2.x > 0.0 ? 1.0 : -1.0;\n\t\t\tindex += offset;\n\t\t\tp2.xy -= offset;\n\t\t}\n\n\t\tfloat ddd = sd_TechTilesTestsSub0( p2, lod, t, ray, index, targs );\n#if 0\n\t\tdd[k] = ddd; // gpu hangs on desktop (GTX 970)\n#else\n\t\tif ( k == 0 ) dd.x = ddd;\n\t\telse  dd.y = ddd;\n#endif\n\n//\t\td = ddd; // compiler bug? doesn't work on laptop...\n\t}\n\n\td = opU( dd.x, dd.y );\n\n#else\n\n\tvec3 p2 = p;\n\tvec2 index = floor( p.xy );\n\tp2.xy = p.xy - index;\n\treturn sd_TechTilesTestsSub0( p2, lod, t, ray, index, targs  ); // only 1 eval\n\n#endif\n\n}\n\nfloat sd_DeathStarTrench( vec3 p, int lod, float t, Ray ray )\n{\n\tfloat d = FLT_MAX;\n\tfloat hw = TRENCH_HALF_WIDTH;\n\n#ifdef RAYMARCH_WITH_LOD\n\td = opU( d, p.x + TRENCH_HALF_WIDTH );\n\td = opU( d, -p.x + TRENCH_HALF_WIDTH );\n\td = opU( d, p.z + TRENCH_DEPTH );\n\td = opI( d, p.z );\n\tif ( abs( d ) > ROUGH_SHELL_D ) return d;\n#endif\n\n\tTechTilesArgs0 targs;\n\ttargs.hmin = 0.025;\n\ttargs.hmax = 0.30;\n\ttargs.hdetail = 0.05;\n\n\t// tiles for vertical walls\n\tTechTilesArgs0 targs_walls;\n\ttargs_walls.hmin = 0.01;\n\ttargs_walls.hmax = 0.22;\n\ttargs_walls.hdetail = 0.05;\n\n#if 1\n\t// the shallow trench rows perpendicular to the main one\n\tif ( mod( floor( p.y ), 7.0 ) == 0.0 )\n\t{\n\t\ttargs.hmax *= 0.3;\n\t\ttargs.hmin *= 0.3;\n\t\ttargs_walls.hmax *= 0.3;\n\t\ttargs_walls.hmin *= 0.3;\n\t}\n#endif\n\n\tfloat h03 = 0.0; // surface trench clamp control\n\tfloat h00 = ( targs.hmax + targs.hdetail ); // wall tile top clamp control\n\tfloat h0 = h00;\n\tfloat h1 = ( targs_walls.hmax + targs_walls.hdetail );\n\n\t// inflate more for tracing\n\th0 *= 2.0;\n\th1 *= 2.0;\n\n\tbounds2 bsides = mkbounds_unchecked( vec2( hw - h1, -TRENCH_DEPTH ), vec2( hw, h0 ) );\n\tbounds2 trench_xz = mkbounds_unchecked( vec2( -hw, -TRENCH_DEPTH ), vec2( hw, 10 ) );\n\n\tfloat e = 0.15; // 51%\n//\tfloat e = 0.25; // 75%\n\n\tbool top_layer = ( p.z > 0.0 ) && ( p.z < h0 );\n\tbool bottom_layer = ( p.z < -TRENCH_DEPTH + h0 );\n\n\tbool top_layer2 = top_layer && ( abs( p.x ) > hw - h03 );\n\tbool bottom_layer2 = bottom_layer && ( abs( p.x ) <= hw );\n\n\tfloat hoffset = top_layer2 ? 0.0 : -TRENCH_DEPTH;\n\n\ttargs.hmin += hoffset;\n\ttargs.hmax += hoffset;\n\n\t{\n\t\tfloat d1 = sd_TechTiles( p, lod, t, ray, targs, e );\n\t\td = opS( p.z, sd_bounds( p.xz, trench_xz ) );\n\n\t\tif ( top_layer2 || bottom_layer2 ) d = opU( d, d1 );\n\t}\n\n\tif ( inside( bsides, xset( p.xz, abs( p.x ) ) ) ) // perf culling\n\t{\n\t\tvec3 p2 = p.yzx;\n\t\tp2.z = abs( p2.z );\n\t\tp2.z -= hw;\n\t\tp2.z = -p2.z;\n\t\tp2.xy *= 2.0;\n\n\t\tfloat d1 = opI( p.z - TRENCH_DEPTH, sd_TechTiles( p2, lod, t, ray, targs_walls, e ) );\n\t\td1 = opI( d1, p.z - h00 * 0.45 ); // clamp top\n\t\td = opU( d1, d );\n\t}\n\n\treturn d;\n}\n\nfloat sindecay( float x, vec3 args ) { return exp( -args.x * x ) * sin( x * args.y ) * args.z; }\nfloat sindecay_derivative( float x, vec3 args ) { return ( args.y * cos( args.y * x ) - args.x * sin( args.y * x ) ) * exp( -args.x * x ) * args.z; }\n\n// function used in overshoot steps, d is the derivative of the curve at x=0, only x>0 bit is used\nfloat overshoot( float x, vec3 args, float df0 )\n{\n\tif ( x > 1.0 ) return 1.0 - sindecay( x - 1.0, args );\n\treturn cubicstep( x, df0, -sindecay_derivative( 0.0, args ) );\n}\n\n// first test, with an anticipation bump\nfloat overshootstep1( float x, vec3 args )\n{\n\tfloat df0 = 6.0;\n\tfloat s = 0.5;\n\tif ( x > 0.0 ) return 1.0 - ( 1.0 - overshoot( x, args, df0 ) ) * s;\n\treturn 1.0 - ( 1.0 + ( 1.0 - cubicstep( max( x, -1.0 ) + 1.0, 0.0, df0 ) ) ) * s;\n}\n\n// dive_step_expin_a from y0+1.0 to 0.0\n// df0 is the derivative at x=0 if we don't scale by 1/(1+y0)\n// the real derivative at 0 is a/(a+df0)\n// a controls the rate of ease in exp dive\n// same as dive_step_expin_y0( x, df0, df0/a )\nfloat overshootstep2( float x, float df0, float a, vec3 args )\n{\n\tfloat y0 = df0 / a; // calculate y0 such that the derivative at x=0 becomes df0\n\tfloat y = x > 0.0 ? overshoot( x, args, df0 ) : -( 1.0 - exp( x * a ) ) * y0; // look there is a smiley in that calculation\n\treturn ( y + y0 ) / ( 1.0 + y0 ); // the step goes from y0 to 1, normalize so it is 0 to 1\n}\n\n// like overshootstep2 but from -inf to 1 instead of 0 to 1 (steep turn)\nfloat overshootstep3( float x, float df0, float a, vec3 args )\n{\n\tfloat y0 = df0 / a; // calculate y0 such that the derivative at x=0 becomes df0\n\tfloat y = x > 0.0 ? overshoot( x, args, df0 ) : 1.0 - exp( -df0 * x );\n\treturn ( y + y0 ) / ( 1.0 + y0 ); // the step goes from y0 to 1, normalize so it is 0 to 1\n}\n\nfloat oversteer( float x, float a, float b, float x0 ) { return exp( -pow2( x ) * 3.0 ) - exp( -pow2( x - x0 ) * 3.0 ) * 0.5; }\n\nstruct CameraRet { vec3 eye; float roll; float pitch; vec4 debug_color; float exposure; };\n\nCameraRet init_cam()\n{\n\tCameraRet cam;\n\tcam.pitch = 0.0;\n\tcam.roll = 0.0;\n\tcam.exposure = 1.0;\n\tcam.debug_color = vec4( 0.0 );\n\treturn cam;\n}\n\nmat4 look_around_mouse_control( mat4 camera, float pitch, float tan_half_fovy )\n{\n\tfloat mouse_ctrl = 1.0;\n\tvec2 mm_offset = vec2( 0.0, pitch );\n\tvec2 mm = vec2( 0.0, 0.0 );\n\n#ifndef EXTRA_3D_CAMERA\n\tif ( iMouse.z > 0.0 )\n\t\tmm = ( iMouse.xy - iResolution.xy * 0.5 ) / ( min( iResolution.x, iResolution.y ) * 0.5 );\n#endif\n\n\tmm.x = -mm.x;\n\tmm = sign( mm ) * pow( abs( mm ), vec2( 0.9 ) );\n\tmm *= PI * tan_half_fovy * mouse_ctrl;\n\tmm += mm_offset;\n\treturn camera * yup_spherical_offset( mm.y, mm.x );\n}\n\n// awkwardly reproduce a camera path similar to the one in the movie\nCameraRet get_camera1_movie_dive_path( float t )\n{\n\tCameraRet cam = init_cam();\n\n\t// approach curves\n\n\t// turn curve\n\tfloat x = overshootstep3( t * 0.55 - 1.4, 2.2, 6.0, vec3( 1.1, 3.0, 0.5 ) ) - 1.0;\n\n\t// descent curve\n\tfloat zz = 1.0 - overshootstep2( t * 1.0 - 2.0, 0.8, 4.0, vec3( 1.0, 1.0, 0.4 ) );\n\tfloat z = -TRENCH_DEPTH * 0.75 + zz * 5.0;\n\n\tcam.eye = vec3( -x, t * FLYING_SPEED, z );\n\n\tfloat pp = ( 1.0 - smoothstep( 0.0, 2.4, t ) );\n\tcam.pitch = -PI * 0.18 * pp;\n//\tcam.debug_color = vec4( GREEN.rgb, pp * 0.5 );\n\n\tfloat rr = oversteer( ( t - 2.7 ), 0.3, 0.3, 1.0 );\n\tcam.roll -= -rr * PI * 0.2;\n//\tcam.debug_color = vec4( RED.rgb, rr*0.5 );\n\n\tcam.eye.z += 0.2 * sin( t * 2.0 );\n\n\tcam.eye.x += ( 0.4 * TRENCH_HALF_WIDTH * sin( t * 1.0 ) ); // left right amplitude\n//\tcam.roll -= 0.2 * cos( t * 1.0 + 0.25 ); // steering roll (anticipates, derivative)\n\tcam.roll += 0.05 * sin( t * 2.0 ); // noise roll\n\n\t// occasional jumps\n\tcam.eye.z += ( 1.0 - ( 1.0 + cos( PI * spaced_tri( t * 0.2, 4.0, 0.5 ) ) ) * 0.5 ) * 7.0;\n\n\tcam.exposure = mix( 0.57*7., 0.18*7., smoothstep( -1.0, 2.0, cam.eye.z ) );\n\treturn cam;\n}\n\nmat4 get_camera1_movie_dive( mat4 camera, float tan_half_fovy, float t, inout vec4 debug_color, inout float exposure )\n{\n\tvec3 center = get_camera1_movie_dive_path( t + 0.05 ).eye;\n\tCameraRet cam = get_camera1_movie_dive_path( t );\n\tvec3 eye = cam.eye;\n\tvec3 up = vec3( 0, 0, 1 );\n\tup.xz = rotate_with_angle( up.xz, cam.roll );\n\tcamera = lookat( eye, center, up );\n\texposure = cam.exposure;\n\tdebug_color = cam.debug_color;\n\treturn look_around_mouse_control( camera, cam.pitch, tan_half_fovy );\n}\n\nCameraRet get_camera2_path( float t )\n{\n\tt *= 0.4; // slow down\n\tCameraRet cam = init_cam();\n\tcam.exposure = 0.35*7.;\n\tcam.roll -= cos( t + 0.25 ) * 0.175;\n\tcam.pitch -= PI * 0.2;\n\tfloat xpos_max = 2.5;\n\tfloat ypos = t * FLYING_SPEED;\n\txpos_max += ( 1.0 + sin( t * 0.05 ) * 0.5 ) * 2.0;\n\tcam.eye = vec3( xpos_max * sin( t ), ypos, 2.75 );\n\treturn cam;\n}\n\nmat4 get_camera2( mat4 camera, float tan_half_fovy, float t, inout vec4 debug_color, inout float exposure )\n{\n\tvec3 center = get_camera2_path( t + 0.02 ).eye;\n\tCameraRet cam = get_camera2_path( t );\n\tvec3 eye = cam.eye;\n\tvec3 up = vec3( 0, 0, 1 );\n\tup.xz = rotate_with_angle( up.xz, cam.roll );\n\tcamera = lookat( eye, center, up );\n\texposure = cam.exposure;\n\tdebug_color = cam.debug_color;\n\treturn look_around_mouse_control( camera, cam.pitch - PI * 0.08, tan_half_fovy );\n}\n\n// plane base 0,0,pz plane normal 0,0,nz\nvec2 intersect_plane2_nz( Ray ray, float pz, float nz )\n{\n\tfloat epsilon = 1e-4;\n\tfloat vdotn = ray.d.z * nz;\n\tfloat d = ( ray.o.z - pz ) * nz;\n\tfloat t = ( abs( vdotn ) <= epsilon ? FLT_MAX : -d / vdotn );\n\treturn vec2( t, d );\n}\n\n// plane base 0,0,px plane normal 0,0,nx\nvec2 intersect_plane2_nx( Ray ray, float px, float nx )\n{\n\tfloat epsilon = 1e-4;\n\tfloat vdotn = ray.d.x * nx;\n\tfloat d = ( ray.o.x - px ) * nx;\n\tfloat t = ( abs( vdotn ) <= epsilon ? FLT_MAX : -d / vdotn );\n\treturn vec2( t, d );\n}\n\n// turn t (result of intersect_plane* functions) into a negative space range\nvec2 mm3( vec2 t ) { return t.y * t.x > 0.0 ? vec2( t.x, FLT_MAX ) : vec2( -FLT_MAX, t.x ); }\n\n// intersect 2 negative space ranges, assume convex\nvec2 mm4( vec2 a, vec2 b ) { return vec2( max( a.x, b.x ), min( a.y, b.y ) ); }\n\n// raytrace to get a better first march distance\nfloat warpTrace( Ray ray )\n{\n\tvec2 t0 = intersect_plane2_nz( ray, ROUGH_SHELL_D, 1.0 );\n\tvec2 t1 = intersect_plane2_nx( ray, -TRENCH_HALF_WIDTH + ROUGH_SHELL_D, 1.0 );\n\tvec2 t2 = intersect_plane2_nx( ray, TRENCH_HALF_WIDTH - ROUGH_SHELL_D, -1.0 );\n\tvec2 t3 = intersect_plane2_nz( ray, -TRENCH_DEPTH + ROUGH_SHELL_D, 1.0 );\n\tfloat d = opU( opU( opI( t0.y, t1.y ), opI( t0.y, t2.y ) ), t3.y );\n\tif ( d < 0.0 ) return 0.0; // we are inside... do nothing and gtfo\n\tvec2 r0 = mm3( t0 );\n\tvec2 r01 = mm4( r0, mm3( t1 ) );\n\tvec2 r02 = mm4( r0, mm3( t2 ) );\n\tvec3 dd = vec3( FLT_MAX );\n\tif ( r01.x != FLT_MAX && r01.y > r01.x && r01.x > 0.0 ) dd.x = r01.x;\n\tif ( r02.x != FLT_MAX && r02.y > r02.x && r02.x > 0.0 ) dd.y = r02.x;\n\tif ( t3.x != FLT_MAX && t3.x > 0.0 ) dd.z = t3.x;\n\treturn mincomp( dd );\n}\n\nfloat sd_Scene( vec3 p, int lod, float t, Ray ray )\n{\n\tfloat d1 = FLT_MAX;\n\tfloat d2 = FLT_MAX;\n#ifdef PRIMITIVES\n// was for simple check lighting (need disable shadow hacks)\n\td1 = opU( sd_bounds_range( p, -vec3( 1. ), vec3( 1. ) ), length( p - vec3( 0., 3., 0. ) ) - 1. );\n#endif\n#ifdef SORT_OF_MOON\n\td2 = sd_DeathStarTrench( p, lod, t, ray );\n#endif\n\treturn opU( d1, d2 );\n}\n\nstruct TraceOutput\n{\n\tfloat t; // ray travel distance\n\tfloat num_iterations;\n\tfloat dist; // \"hit\" point distance to surface\n\tfloat shadow;\n};\n\nvec3 sd_SceneGrad( vec3 p, int lod, TraceOutput to, Ray ray )\n{\n\t// if p is far away the epsilon will vanish in the addition and normal calculation will be broken\n\t// this was to keep the gradient working even at large-ish distances...\n//\tvec3 h = max( vec3( 0.006 ), abs( p ) * 1e-6 );\n\tvec3 h = vec3( 0.001 );\n\tvec3 n = normalize( vec3( sd_Scene( p + vec3( h.x, 0.0, 0.0 ), lod, to.t, ray ),\n\t\t\t\t\t\t\t  sd_Scene( p + vec3( 0.0, h.y, 0.0 ), lod, to.t, ray ),\n\t\t\t\t\t\t\t  sd_Scene( p + vec3( 0.0, 0.0, h.z ), lod, to.t, ray ) ) - to.dist ); // to.dist == sd_Scene( p, lod, to.t, ray ), our last eval \n\t// if the normal is backfacing, our point p is likely behind an occluded object (a thin object or an edge we accidentally traced through)\n\t// this creates distracting salt noise that makes certain lighting components unstable (fresnel)\n\t// if we care the simplest hack to do that attenuates the artifacts in our scene is to negate\n\treturn dot( n, ray.d ) > 0.0 ? -n : n;\n}\n\nTraceOutput traceScene( Ray ray, int lod, float shadow_sharpness, float tmax, bool warp_trace, float max_iterations )\n{\n\tTraceOutput to;\n\tto.t = 0.0;\n\tto.num_iterations = 0.0;\n\tto.dist = 0.0;\n\tto.shadow = 1.0;\n\n#ifdef RAYTRACE_FIRST_MARCH_DISTANCE\n\tif ( warp_trace ) { to.t += warpTrace( ray ); if ( to.t == FLT_MAX ) return to; } // jump close to first hit\n#endif\n\n\tfor ( int i = 0; i < MAX_ITERATIONS; ++i )\n\t{\n\t\tfloat d = sd_Scene( ray.o + to.t * ray.d, lod, to.t, ray );\n\t\tto.dist = d;\n\t\tif ( ( abs( to.dist ) <= DBREAK * to.t ) || to.t > tmax ) break;\n\t\tto.shadow = min( to.shadow, shadow_sharpness * to.dist / to.t ); // iq's awesome trick http://www.iquilezles.org/www/material/nvscene2008/rwwtt.pdf for shadows\n\t\tto.t += to.dist * TFRAC;\n\t\tto.num_iterations += 1.0;\n\t\tif ( to.num_iterations >= max_iterations ) break;\n\t}\n\n\tto.shadow = max( 0.0, to.shadow ); // fixes some artifacts\n\treturn to;\n}\n\nfloat star_glare( float x, float e, float c ) { return exp2( -pow( x, e ) * c ); }\n\n// black body color adapted from Fabrice Neyret's https://www.shadertoy.com/view/4tdGWM\n// T absolute temperature (K), m1 is a 0,1 param that controls output scale\nvec3 black_body( float T, float m1 )\n{\n\tfloat m = .01 + 5. * m1;\n\tvec3 f = vec3( 1. ) + 0.5 * vec3( 0., 1., 2. );\n\tfloat Trcp = 1. / T;\n\treturn ( 10. / m * ( f * f * f ) ) / ( exp( ( 19e+3 * f * Trcp ) ) - 1. );  // Planck law\n}\n\n// assumes x 0,1 maps to 24e+2, 30e+3\n#define FF 24.\n// vaguely use this distribution there https://en.wikipedia.org/wiki/Stellar_classification\nfloat Tprob2( float x ) { return exp( -x * FF ); }\nfloat Tprob2_int( float x ) { return -exp( -x * FF ) * ( 1.0 / FF ); }\nfloat Tprob2_int_inv( float x ) { return -log( -x * FF ) * ( 1.0 / FF ); }\n#if 0\nfloat cdf( float x ) { return Tprob2_int( x ) - Tprob2_int( 0. );}\nfloat cdf_inv( float x ) { return Tprob2_int_inv( x + Tprob2_int( 0. ) ); }\n#else\nfloat cdf( float x ) { return Tprob2_int( x ) - ( -1. / FF ); } // hardcode the function\nfloat cdf_inv( float x ) { return Tprob2_int_inv( x + ( -1. / FF ) ); }\n#endif\n\nvec3 star_color( float x ) { return black_body( mix( 24e+2, 30e+3, x ), 1. ); }\n\n#ifdef STARFIELD\n// stars are clamped on their cell borders (we don't bother iterating neighbours)\nvec3 starfield( vec3 viewvec )\n{\n\tvec2 num = vec2( 1.0, 2.0 ) * 250.0;\n\tfloat theta = acos( viewvec.z );\n\tfloat phi = calc_angle( viewvec.xy );\n\tif ( phi < 0.0 ) phi += 2.0 * PI;\n\tvec2 sc = vec2( theta, phi );\n\tvec2 scd = vec2( 1.0, 2.0 ) * PI / num;\n\tvec2 sci = floor( sc / scd ); // if ( mod( sci.x + sci.y, 2.0 ) == 1.0 ) return RED;\n\tvec2 scf = ( sc - sci * scd ) / scd; //\treturn vec3( scf, 0.0 ); // view cells\n//\tvec4 r = vec4(0.5); // aligned stars\n\tvec4 r = hash42( sci ); //\treturn vec3( r ); // color cell by hash\n\tvec2 scc = ( ( sci + 0.5 ) * scd ); // cell center\n\tvec2 r2 = hash22( sci ); //\treturn vec3( r2.y ); // debug // x: discard probability, y: color distribution uniform input\n\tif ( r2.x > sin( scc.x ) ) return BLACK; // randomly decimate in sin theta fashion for something uniform-ish\n//\tif ( r2.x > sin( scc.x ) ) return RED; // visualize the decimation\n\tvec2 sc2 = ( ( sci + r.xy ) * scd ); // cell center\n\tvec3 v = zup_spherical_coords_to_vector( sc2.x, sc2.y ); // return v;\n\tv = normalize( v ); // we also need to renormalize already normal vector here else broken on GTX1060 laptop\n\tfloat c = 1.0 - dot( v, viewvec ); // return vec3( 1.0 - smoothstep( 0.0, 1.0, c ) ); // debug: show the full disks (max glow radius) // 0->2\n\tvec3 col = star_color( cdf_inv( r2.y * cdf( 1. ) ) ); // return vec3( chrominance( col ) );\n#if 1\n\tc *= 1e+6;\n\tcol = mix( col, vec3( maxcomp( col ) ), 0.5 ); // after all those efforts we lerp towards monotone... :-]\n\treturn star_glare( c * 0.0095, 0.8, 80.0 ) * col * 1.5; // fixme: make the radius resolution/fovy dependent \n//\treturn star_glare( c * 0.01, mix( 0.4, 0.8, r.w ), mix( 30.0, 60.0, r.z ) ) * col * 120.; // manual glow;\n#else\n// with larger glares and plausible star colors it starts to look like space photos a bit (maybe)\n\tc *= 6e+4;\n\treturn star_glare( c, mix( 0.3, 0.8, r.w ), mix( 3.0, 6.0, r.z ) ) * col * 80.; // manual glow;\n#endif\n}\n#endif\n\nvoid build_onb( vec3 z, vec3 x0, out vec3 x, out vec3 y ) { y = normalize( cross( x0, z ) ); x = normalize( cross( z, y ) ); }\n\nvec3 sunval( float sun_dp, vec2 p, vec3 sun_color, vec3 sun_color_c )\n{\n\tfloat r = ( ( -sun_dp + 1. ) * 0.5 ) * 300.0;\n\tfloat f = 0.;\n#if 1\n// flares\n\tfloat a = calc_angle( p );\n\tfloat da = 2.0 * PI / 6.0;\n\tfloat a0 = floor( a * ( 1.0 / da ) ) * da;\n\tvec2 va0 = perp( unit_vector2( a0 ) );\n\tvec2 va1 = -perp( unit_vector2( a0 + da ) );\n\tvec2 d = vec2( dot( va0, p ), dot( va1, p ) );\n\tfloat f0 = opU( d.x, d.y );\n\tf = f0 * 8.;\n\tf += 1.0 - exp( -r * 0.01 ) * 0.85;\n\tf = 1. / ( 0.01 + f * 50. );\n\tf *= 0.125;\n#endif\n\treturn 2. * sun_color * star_glare( max( 0.0, r - 0.17 ) * 0.075, 0.35, 24.0 ) + f * sun_color_c;\n}\n\n// I used a bit of pbr reference to see what happens (don't worry it all deteriorates into sad hacks pretty quickly)\n// https://learnopengl.com/#!PBR/Theory\n// http://graphicrants.blogspot.jp/\n// alpha = roughness * roughness\nfloat D_blinn_phong( float m_dot_n, float alpha ) { float alpha_sqr = alpha * alpha; return pow( m_dot_n, ( 2. / alpha_sqr ) - 2. ) / ( PI * alpha_sqr ); }\nfloat D_beckmann( float m_dot_n, float alpha )\n{\n\tfloat alpha_sqr = alpha * alpha;\n\tfloat m_dot_n_sqr = m_dot_n * m_dot_n;\n\treturn exp( ( m_dot_n_sqr - 1. ) / ( alpha_sqr * m_dot_n_sqr ) ) / ( PI * alpha_sqr * m_dot_n_sqr * m_dot_n_sqr );\n}\n// Trowbridge-Reitz\nfloat D_GGX( float m_dot_n, float alpha ) { float alpha_sqr = alpha * alpha; return alpha_sqr / ( PI * pow2( pow2( m_dot_n ) * ( alpha_sqr - 1. ) + 1. ) ); }\nfloat G_implicit( float n_dot_l, float n_dot_v ) { return n_dot_l * n_dot_v; }\nfloat G_neumann( float n_dot_l, float n_dot_v ) { return n_dot_l * n_dot_v / max( n_dot_l, n_dot_v ); }\nfloat G_kelemen( float n_dot_l, float n_dot_v, float v_dot_h ) { return n_dot_l * n_dot_v / pow2( v_dot_h ); }\nfloat F_none( float v_dot_h, float F0 ) { return F0; }\nfloat F_schlick( float v_dot_h, float F0 ) { return F0 + ( 1. - F0 ) * pow5( 1. - v_dot_h ); }\n\nvec3 add_light_contrib( vec3 albedo, vec3 l, vec3 n, vec3 v, float Li, float dwi, float kdiffuse, float kspecular )\n{\n\tfloat F0 = 0.08;\n\tfloat roughness = 0.25;\n\tfloat alpha = roughness * roughness;\n\tvec3 h = normalize( l + v );\n\tfloat eps = 1e-4; // else divides by zero\n\tfloat n_dot_l = max( eps, dot( n, l ) );\n\tfloat n_dot_v = max( eps, dot( n, v ) );\n\tfloat n_dot_h = max( eps, dot( n, h ) );\n\tfloat v_dot_h = max( eps, dot( h, v ) );\n\tfloat l_dot_h = max( eps, dot( l, h ) );\n\n//\tfloat D = D_blinn_phong( n_dot_h, alpha ); // https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_shading_model\n//\tfloat D = D_beckmann( n_dot_h, alpha );\n\tfloat D = D_GGX( n_dot_h, alpha ); // n_dot_h should probably be clamped to >=0\n\n//\tfloat G = G_implicit( n_dot_l, n_dot_v );\n\tfloat G = G_neumann( n_dot_l, n_dot_v );\n//\tfloat G = G_kelemen( n_dot_l, n_dot_v, v_dot_h );\n\n//\tfloat F = F_none( n_dot_v, F0 );\n\tfloat F = F_schlick( n_dot_v, F0 );\n\n\treturn  ( ( kdiffuse * albedo * ( 1.0 / PI ) + kspecular * ( D * F * G ) / ( 4. * n_dot_l * n_dot_v ) ) ) * Li * n_dot_l * dwi;\n}\n\n//http://www.cs.utah.edu/~reinhard/cdrom/tonemap.pdf\nvec3 tonemap_reinhard( vec3 x ) { return x / ( 1. + x ); }\nvec3 gamma_correction( vec3 L ) { return pow( L, vec3( 0.45 ) ); }\n// mentioned in http://resources.mpi-inf.mpg.de/tmo/logmap/\nvec3 gamma_correction_itu( vec3 L ) { return mix( 4.5061986 * L, 1.099 * pow( L, vec3( 0.45 ) ) - 0.099, step( vec3( 0.018 ), L ) ); }\n\nfloat penumbra_sun( float x ) { x = max( x, 0.0 ); return 1.0 - exp2( -x * 1.9 ); } // darker/narrower\n//float penumbra_sun( float x ) { x = max( -x, 0.0 ); return exp2( -x * iSlider0 * 10. ); } // brighter/wider\nfloat penumbra_bounce( float x ) { x = max( x, 0.0 ); return 1.0 - exp2( -x * 0.2 ); } // darker/narrower\n//float penumbra_bounce( float x ) { x = max( x, 0.0 ); return x = exp2( -x * 1.4 ); } // brighter/wider\n\n// e = eye pos, v = vader vector, p = lit point, n = normal, l = sun direction\nvec3 shade( in vec3 e, in vec3 v, mat4 cam, in vec3 p, in vec3 n, vec3 l\n\t\t\t, float traced_shadow, float sun_shadow, float first_bounce\n\t\t\t, TraceOutput to, float ao, float exposure, vec2 uv )\n{\n\tvec3 col = vec3( 0. );\n\tbool sky = to.t > TMAX;\n\n//\treturn sky ? BLACK : ( vec3( 1.0 ) + n ) * 0.5; // normal debug color\n//\treturn vec3( 1.0 - exp( -to.t * 0.15 ) ); // distance to hit point\n//\treturn viridis_quintic( to.num_iterations * ( 1.0 / float( MAX_ITERATIONS ) ) ); // visualize the number of iterations\n//\treturn viridis_quintic( to.dist / ( DBREAK * to.t ) );\n//\treturn viridis_quintic( to.dist );\n//\treturn viridis_quintic( ao );\n\n\tvec3 sun_color = black_body( 19000.0, 0.8 );\n\tvec3 sun_color_c = chrominance( sun_color );\n\tvec3 albedo = vec3( 0.85, 0.85, 1 );\n#ifdef COLOR_TILES\n\talbedo = mix( vec3( 0.2 ), vec3( 1.0 ), hash32( floor( p.xy ) ) );\n#endif\n\n\tif ( !sky )\n\t{\n\t\tfloat iter = to.num_iterations * ( 1.0 / float( MAX_ITERATIONS ) );\n\t\tfloat fog_start = 30.0;\n\t\tfloat fog = exp2( -max( to.t - fog_start, 0.0 ) * 0.02 ); // this is mostly to fade the horizon\n\t\tfloat ao_z = 1.0 - saturate( abs( p.z * ( 1.0 / TRENCH_DEPTH ) ) ); // vertical occlusion\n\t\tfloat kdiffuse = 0.75;\n\t\tfloat kspecular = 1.0;\n\t\tfloat sunI = 2.2;\n\t\tfloat kambient = 0.005;\n\t\tfloat shadow = min( traced_shadow, sun_shadow );\n\n//\t\treturn vec3( shadow );\n//\t\tn = normalize( n + 0.07 * l ); // soften a bit\n#if 1\n // main sun light\n\t\tcol += add_light_contrib( albedo, l, n, -v\n\t\t\t\t\t\t\t\t  , sunI * mix( 0.0, 1., ao_z ) * mix( 0., 1., shadow )\n\t\t\t\t\t\t\t\t  , 1.\n\t\t\t\t\t\t\t\t  , kdiffuse\n\t\t\t\t\t\t\t\t  , kspecular * shadow * ao_z ); // modulate specular to reduce sparkles\n#endif\n#if 1\n// dummy secondary source\n\t\tvec3 l2 = normalize( vec3( 5, -5.5, 10 ) );\n\t\tcol += add_light_contrib( albedo, l2, n, -v\n\t\t\t\t\t\t\t\t  , 0.34 * mix( 0.08, 1., ao_z ) * ao\n\t\t\t\t\t\t\t\t  , 1.\n\t\t\t\t\t\t\t\t  , kdiffuse\n\t\t\t\t\t\t\t\t  , kspecular * shadow * ao_z ); // modulate specular to reduce sparkles\n#endif\n#if 1\n// first bounce\n\t\tcol += add_light_contrib( albedo, reflect( l, vec3( -1., 0., 0. ) ), n, -v\n\t\t\t\t\t\t\t\t  , first_bounce\n\t\t\t\t\t\t\t\t  , 0.05\n\t\t\t\t\t\t\t\t  , kdiffuse\n\t\t\t\t\t\t\t\t  , kspecular * shadow * ao_z );\n#endif\n#if 1\n// ambient\n\t\tcol += PI * vec3( kambient * ao_z * ao );\n#endif\n#if 1\n// random crap\n\t\tcol *= fog * ao * ao * ( 1. - iter * 0.7 );\n#endif\n\t}\n\telse\n\t{\n\t\tcol = vec3( 0. );\n\n#ifdef SUN\n\t\tvec3 sx, sy;\n\t\tbuild_onb( l, cam[0].xyz, sx, sy ); // we want the flares to be viewspaceish\n\t\tcol += sunval( dot( l, v ), vec2( dot( v, sx ), dot( v, sy ) ), sun_color, sun_color_c );\n#endif\n\n#ifdef STARFIELD\n\t\tcol += starfield( v );\n#endif\n\t}\n\n\tcol = exposure * tonemap_reinhard( col );\n//\tcol = max( vec3( 0. ), contrast( col, vec3( 1.015 ) ) );\n\n\tfloat vignette = .0 + 1. * pow( 20. * uv.x * uv.y * ( 1. - uv.x ) * ( 1. - uv.y ), 0.075 ); \n\tcol *= vignette;\n\n\tcol = gamma_correction_itu( col );\n//\tcol = gamma_correction( col );\n\n\treturn col;\n}\n\n// black -> green -> white gradient\nvec3 laser_heatmap( float u ) { float r = 0.5; vec3 c = vec3( smoothbump( r * float( 2.0 ), r, u ) ); c.g += smoothbump( r * float( 1.0 ), r, u ); return c; }\n\n#define LASER_LEN 1.5\n#define LASER_LEN_RCP (1.0/(LASER_LEN))\n#define LASER_SPEED (60.0)\n// spawn at player + that\n#define LASER_SPAWN_DISTANCE (40.0)\n#define LASER_PERIOD (LASER_SPAWN_DISTANCE*2.0/(FLYING_SPEED+LASER_SPEED))\n\n// for lasers capsules...\nvec2 sphere_trace( vec2 O, vec2 d, float radius, vec2 C )\n{\n\tfloat tp = dot( C - O, d ); // P = project C on line (O,d)\n\tvec2 P = O + d * tp;\n\tfloat h_sqr = lensqr( P - C );\n\tfloat radius_sqr = radius * radius;\n\tif ( h_sqr > radius_sqr ) return vec2( FLT_MAX, FLT_MAX ); // ray missed the sphere\n//\tbool start_inside = lensqr( O - C ) <= radius_sqr; // start inside the sphere?\n\tfloat dt = sqrt( radius_sqr - h_sqr ); // distance from P to In (near hit) and If (far hit)\n//\tif ( start_inside )\treturn vec2(FLT_MAX,tp+dt);\t// order In->O->If // record only far hit If\n//\tif ( tp < 0.0 )\treturn vec2(FLT_MAX,FLT_MAX); // order In->If->O // O is outside the sphere and beyhond If, no hit\n\treturn vec2( tp - dt, tp + dt ); // record 2 hits In, If\n}\n\n// laser code is total bloat, we raytrace infinite cylinders and integrate something\n// volumetric along a fixed number of steps between the 2 intersections, when they exist\nvec3 lasers( Ray view_ray, float hs, float time, float t0 )\n{\n\tfloat fade = 1.0 - smoothstep( -TRENCH_DEPTH * 0.05, 0.0, view_ray.o.z );\n\tfloat pos = FLYING_SPEED * time; // camera pos\n\tfloat laser_period = LASER_PERIOD * FLYING_SPEED;\n\tfloat offset = hs * 5.0;\n\tfloat nth = floor( ( pos - offset ) / laser_period );\n\tfloat y0 = offset + nth * laser_period + LASER_SPAWN_DISTANCE;\n\tfloat yy_t = ( pos - ( offset + nth * laser_period ) ) * ( 1.0 / FLYING_SPEED );\n\tfloat laser_pos = y0 - yy_t * LASER_SPEED;\n\tvec2 orig = hash21( nth * hs );\n\tfloat w2 = TRENCH_HALF_WIDTH * 0.8;\n\torig = mix( vec2( -w2, -TRENCH_DEPTH * 0.9 ), vec2( w2, -TRENCH_DEPTH * 0.3 ), orig );\n\tfloat r = 0.085;\n\tvec3 color = BLACK;\n\n\t//todo: case when we are inside the laser\n\tfloat vzx1len = length( view_ray.d.zx );\n\tvec2 vzx1 = view_ray.d.zx / vzx1len;\n\tvec2 st = sphere_trace( view_ray.o.zx, vzx1, r, vec3( orig.x, 0, orig.y ).zx );\n\tif ( st.x == FLT_MAX || // no hit\n\t\t st.y < 0.0 ) // hitting behind the camera\n\t\t\t\t\t  // we don't intersect the laser cylinder, gtfo\n\t\treturn color;\n\n\tvec3 cacc = vec3( 0.0);\n\tfloat aacc = 0.0;\n\n\tfloat vzx1len_rcp = 1.0 / vzx1len;\n\tfloat t00 = st.x * vzx1len_rcp;\n\tfloat t11 = st.y * vzx1len_rcp;\n\n#define LASER_ITER 20.0\n\tfor ( float i = 0.0; i <= LASER_ITER; i += 1.0 )\n\t{\n\t\tfloat x = i * ( 1.0 / LASER_ITER );\n\t\tfloat t = t00 + ( t11 - t00 ) * cubicstep(  x, 2.5, 2.5 ); // smaller steps near the center to better capture the gradient\n\t\tvec3 p = view_ray.o + t * view_ray.d;\n\t\tvec3 vzx = p - project_on_liney( p, vec3( orig.x, 0, orig.y ) );\n\t\tvec3 pl = p;\n\t\tpl.y -= laser_pos; // local\n\t\tfloat ri = length( vzx );\n\t\tif ( pl.y > LASER_LEN - r ) ri = length( pl - vec3( orig.x, LASER_LEN - r, orig.y ) );\n\t\telse if ( pl.y < -LASER_LEN + r ) ri = length( pl - vec3( orig.x, -LASER_LEN + r, orig.y ) );\n\t\tfloat ddx = 1.0 - saturate( ri * ( 1.0 / r ) );\n\t\tfloat xxx = pl.y * LASER_LEN_RCP;\n\t\tddx *= box( xxx ) * fade;\n\t\tvec3 emission = laser_heatmap( ddx ) * 0.2;\n\t\tfloat opacity = saturate( ddx * 0.1 );\n\t\tcacc += ( 1.0 - aacc ) * emission;\n\t\taacc += ( 1.0 - aacc ) * opacity; // http://developer.download.nvidia.com/books/HTML/gpugems/gpugems_ch39.html\n\t}\n\n\tcolor = cacc;\n\tcolor = cacc * aacc;\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4( 0., 0., 0., 1 );\n\tfloat aspect = iResolution.x / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n//\tfragColor.xyz = star_color( uv.x ).xyz; return;\n//\tfragColor.xyz = laser_heatmap( uv.x ); return;\n\n\tfloat tan_half_fovy = 0.6;\n\tfloat znear = 0.1;\n\tvec4 debug_color = vec4( 1.0, 1.0, 1.0, 0.0 );\n\tfloat time = iTime + TIME_OFFSET;\n\tfloat fade = 1.0;\n\tfloat exposure = 1.0;\n\tmat4 camera;\n\n#ifdef EXTRA_3D_CAMERA\n\tcamera[0] = iCamera[0];\n\tcamera[1] = iCamera[1];\n\tcamera[2] = iCamera[2];\n\tcamera[3] = iCamera[3];\n\ttan_half_fovy = iTanHalfFovy;\n\texposure = iExposure;\n#else\n\t{\n\t\tfloat time_slice = 30.0;\n#ifdef CAMERA_REPEAT\n\t\tfloat camera_select = mod( floor( time / time_slice ), 2.0 );\n\t\tfloat time_slice_r = 0.25;\n\t\tfade = 1.0 - min( spaced_bumps( time, time_slice, time_slice_r ), 1.0 - box( time / time_slice_r ) );\n\t\ttime = mod( time, time_slice );\n#else\n\t\tfloat camera_select = 0.0;\n#endif\n\t\tif ( camera_select == 0.0 ) camera = get_camera1_movie_dive( camera, tan_half_fovy, time, debug_color, exposure );\n\t\telse camera = get_camera2( camera, tan_half_fovy, time + CAM2_TIME_OFFSET, debug_color, exposure );\n\t}\n#endif\n\n\tRay view_ray = get_view_ray( ( uv - vec2( 0.5 ) ) * 2.0, znear, aspect, tan_half_fovy );\n\n\tview_ray.o = camera[3].xyz;\n\tview_ray.d = ( camera * vec4( view_ray.d, 0.0 ) ).xyz;\n\tview_ray.d = normalize( view_ray.d ); // have to renormalize this already normalized (yey!) vector here else lasers are broken (only on laptop GTX1060)\n\n\tTraceOutput to = traceScene( view_ray, 0, 15.0, TMAX, true, float( MAX_ITERATIONS ) );\n\n\tvec3 l = normalize( vec3( -8, 0, 5.2 ) ); // careful with z, long shadows make the tracing slower\n\tvec3 p = view_ray.o + to.t * view_ray.d;\n\tvec3 n = sd_SceneGrad( p, 0, to, view_ray );\n\n\tfloat ao = 1.0;\n\n#ifdef AO\n\t{\n\t\t// http://www.iquilezles.org/www/material/nvscene2008/rwwtt.pdf\n\t\tfloat delta = 0.1;\n\t\tfloat a = 0.0;\n\t\tfloat b = 1.0;\n\t\tfor ( int i = 0; i < 5; i++ )\n\t\t{\n//\t\t\tif ( to.t > 30 ) break;\n\t\t\tfloat fi = float( i );\n\t\t\tfloat d = sd_Scene( p + delta * fi * n, 0, to.t, view_ray );\n\t\t\ta += ( delta * fi  - d ) * b;\n\t\t\tb *= 0.5;\n\t\t}\n\t\tao = saturate( 1.0 - 1.2 * a );\n\t\t// note: had to lower DBREAK inorder to avoid ugly patterns when far away from surface\n\t}\n#endif\n\n\tbool sky = to.t > TMAX;\n\n\tfloat sun_shadow = 1.0; // shadow\n\tfloat first_bounce = 0.0; // first light bounce (illuminates the bottom left corner)\n\tfloat traced_shadow = 1.0;\n\n\tif ( !sky )\n\t{\n#ifdef TRACED_SHADOW\n\t\tfloat expensive_shadow_dist = 40.0;\n\t\tif ( to.t < expensive_shadow_dist )\n\t\t{\n\t\t\tRay sray;\n\t\t\tsray.o = p + n * 0.1 * 1.0;\n\t\t\tsray.d = l;\n\n\t\t\tTraceOutput tos = traceScene( sray, 0, 15.0, 10.0, false, 20.0 );\n\t\t\ttraced_shadow = tos.shadow;\n\t\t\ttraced_shadow += smoothstep( expensive_shadow_dist - 2.0, expensive_shadow_dist, to.t );\n\t\t\ttraced_shadow = saturate( traced_shadow );\n\t\t}\n#endif\n\t\tvec2 l2 = normalize( l.xz );\n\t\tvec2 l2r = reflect( l2, vec2( -1, 0 ) );\n\t\tfloat so = 0.0; // shadow plane offset from z=0\n\t\tPlane2 pl1 = mkplane2( vec2( -TRENCH_HALF_WIDTH, so ), -perp( l2 ) );\n\t\tPlane2 pl2 = mkplane2( vec2( TRENCH_HALF_WIDTH, so ), -perp( l2r ) );\n\t\tPlane2 pl3 = pl2;\n\t\tpl3.normal = -pl3.normal;\n\t\tpl3.base.y += ( l2.y / l2.x ) * 2.0 * TRENCH_HALF_WIDTH;\n\n\t\tif ( ( abs( p.x ) < TRENCH_HALF_WIDTH ) && ( p.z < so ) )\n\t\t{\n#ifdef ANALYTICAL_SHADOW\n\t\t\tsun_shadow = penumbra_sun( dot( p.xz - pl1.base, pl1.normal ) );\n#endif\n\t\t\tfirst_bounce = penumbra_bounce( min( dot( p.xz - pl2.base, pl2.normal ),\n\t\t\t\t\t\t\t\t\t\t\t\t dot( p.xz - pl3.base, pl3.normal ) ) );\n\n\t\t\tfirst_bounce *= step( p.x, TRENCH_HALF_WIDTH - 0.5 ) * step( p.z, 0.0 );\n\t\t}\n\t}\n\n\tfragColor.rgb = shade( view_ray.o, view_ray.d, camera, p, n, l\n\t\t\t\t\t\t   , traced_shadow, sun_shadow, first_bounce, to, ao, exposure, uv );\n#ifdef LASERS\n\tfragColor.rgb += lasers( view_ray, 0.0, time, to.t );\n\tfragColor.rgb += lasers( view_ray, 1.0, time, to.t );\n\tfragColor.rgb += lasers( view_ray, -1.0, time, to.t );\n\tfragColor.rgb += lasers( view_ray, -0.5, time, to.t );\n\tfragColor.rgb += lasers( view_ray, +0.5, time, to.t );\n#endif\n\tfragColor.rgb *= fade;\n\tfragColor.rgb = mix( fragColor.rgb, debug_color.rgb, debug_color.a );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tXcRl.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1939, 2298, 2328, 2328, 2352], [2353, 2353, 2383, 2383, 2407], [2408, 2408, 2438, 2438, 2467], [2468, 2468, 2498, 2498, 2527], [2528, 2528, 2558, 2558, 2587], [2686, 2686, 2815, 2815, 2855], [2856, 2856, 2893, 2893, 2933], [2934, 2934, 2971, 2971, 3011], [3012, 3178, 3228, 3228, 3328], [3329, 3329, 3376, 3376, 3420], [3421, 3421, 3468, 3468, 3535], [3536, 3536, 3557, 3557, 3585], [3586, 3586, 3614, 3614, 3641], [3642, 3642, 3678, 3678, 3743], [3744, 3744, 3777, 3777, 3809], [3810, 3810, 3834, 3834, 3856], [3857, 3857, 3881, 3881, 3903], [3904, 3904, 3928, 3928, 3950], [3951, 3951, 3974, 3974, 3990], [3991, 3991, 4014, 4014, 4042], [4043, 4043, 4064, 4064, 4080], [4081, 4081, 4102, 4102, 4130], [4131, 4131, 4154, 4154, 4194], [4195, 4195, 4221, 4221, 4233], [4234, 4234, 4259, 4259, 4285], [4286, 4286, 4311, 4311, 4349], [4350, 4350, 4376, 4376, 4388], [4389, 4389, 4414, 4414, 4440], [4441, 4441, 4466, 4466, 4504], [4505, 4505, 4527, 4527, 4564], [4565, 4565, 4593, 4593, 4635], [4636, 4636, 4662, 4662, 4721], [4723, 5134, 5184, 5184, 5243], [5246, 5355, 5377, 5377, 5403], [5406, 5406, 5430, 5430, 5466], [5469, 5469, 5502, 5502, 5544], [5547, 5547, 5579, 5579, 5634], [5636, 5636, 5661, 5661, 5677], [5678, 5760, 5786, 5786, 5809], [5810, 5810, 5836, 5836, 5859], [5970, 5970, 6025, 6025, 6127], [6128, 6128, 6153, 6153, 6207], [6208, 6208, 6233, 6233, 6245], [6819, 6819, 6876, 6876, 6931], [7028, 7028, 7089, 7089, 7191], [7192, 7192, 7241, 7241, 7297], [7857, 7967, 7991, 7991, 8119], [8121, 8232, 8255, 8255, 8388], [8390, 8501, 8524, 8524, 8658], [8660, 8769, 8792, 8792, 8931], [9016, 9016, 9050, 9050, 9095], [9096, 9096, 9145, 9145, 9212], [9213, 9213, 9262, 9262, 9326], [9328, 9437, 9500, 9500, 9632], [9634, 9634, 9697, 9697, 9756], [9758, 9758, 9811, 9811, 10045], [10047, 10070, 10103, 10103, 10646], [10681, 10681, 10766, 10766, 10926], [10928, 10928, 10975, 10975, 11150], [11152, 11152, 11185, 11185, 11212], [11213, 11213, 11246, 11246, 11270], [11271, 11271, 11304, 11304, 11328], [11329, 11329, 11372, 11372, 11407], [11409, 11409, 11456, 11456, 11486], [11487, 11487, 11532, 11532, 11576], [11577, 11577, 11622, 11622, 11671], [11672, 11672, 11723, 11723, 11827], [11828, 11828, 11882, 11882, 11960], [11961, 11961, 12012, 12012, 12090], [12091, 12091, 12129, 12129, 12176], [12177, 12177, 12215, 12215, 12262], [12350, 12350, 12393, 12393, 12465], [12466, 12466, 12507, 12507, 12578], [12580, 12785, 12829, 12829, 13156], [13158, 13158, 13217, 13392, 14252], [14254, 14254, 14313, 14491, 15331], [15333, 15333, 15392, 15544, 16558], [16560, 16666, 16723, 16992, 17766], [17908, 17960, 18003, 18003, 18131], [18133, 18172, 18257, 18257, 19262], [19362, 19362, 19462, 19462, 20909], [20911, 20950, 21038, 21038, 22141], [22143, 22143, 22206, 22206, 24214], [24216, 24216, 24254, 24254, 24312], [24313, 24313, 24362, 24362, 24462], [24464, 24563, 24613, 24613, 24735], [24737, 24778, 24822, 24822, 25011], [25013, 25246, 25310, 25310, 25610], [25612, 25685, 25749, 25749, 25996], [25998, 25998, 26054, 26054, 26125], [26219, 26219, 26241, 26241, 26360], [26362, 26362, 26443, 26443, 26862], [26864, 26933, 26983, 26983, 28049], [28051, 28051, 28171, 28171, 28546], [28548, 28548, 28587, 28587, 28901], [28903, 28903, 29012, 29012, 29377], [29379, 29420, 29477, 29477, 29650], [29652, 29693, 29750, 29750, 29923], [29925, 30002, 30022, 30022, 30095], [30097, 30149, 30177, 30177, 30228], [30230, 30279, 30307, 30307, 31074], [31076, 31076, 31129, 31129, 31452], [31598, 31598, 31661, 31884, 32567], [32569, 32569, 32688, 32688, 33472], [33474, 33474, 33521, 33521, 33556], [33558, 33722, 33760, 33760, 33950], [34005, 34097, 34122, 34122, 34147], [34148, 34148, 34177, 34177, 34218], [34219, 34219, 34252, 34252, 34293], [34618, 34618, 34646, 34646, 34697], [36720, 36720, 36779, 36779, 36846], [36848, 36848, 36919, 36919, 37462], [37464, 37690, 37741, 37741, 37845], [37846, 37846, 37894, 37894, 38086], [38087, 38107, 38150, 38150, 38264], [38265, 38265, 38315, 38315, 38343], [38344, 38344, 38393, 38393, 38447], [38448, 38448, 38512, 38512, 38558], [38559, 38559, 38600, 38600, 38613], [38614, 38614, 38658, 38658, 38708], [38710, 38710, 38827, 38827, 39776], [39778, 39831, 39864, 39864, 39889], [39890, 39890, 39923, 39923, 39956], [39957, 40017, 40054, 40054, 40151], [40153, 40153, 40184, 40184, 40236], [40237, 40366, 40400, 40400, 40452], [40578, 40657, 40851, 40851, 43547], [43549, 43585, 43616, 43616, 43743], [43972, 43998, 44057, 44057, 44742], [44744, 44918, 44979, 44979, 47139], [47141, 47141, 47198, 47198, 51341]]}
{"id": "4tXcRs", "name": "House_jb", "author": "JacobB", "description": "assignment for class", "tags": ["assignment"], "likes": 0, "viewed": 54, "date": "1505923400", "time_retrieved": "2024-06-20T19:00:40.597665", "image_code": "float drawCircle(in float radius, in vec2 position, in vec2 uv){   \n   float alpha = step(radius, length(position-uv));\n    return alpha;\n}\n\nfloat drawRect(in vec2 position, in vec2 sideLength, in vec2 uv){\n\tfloat alpha;\n    alpha = step(position.x, uv.x);\n    alpha = step(position.y, uv.y)*alpha;\n    alpha = step(uv.y - sideLength.y, position.y)*alpha;\n    alpha = step(uv.x-sideLength.x, position.x)*alpha;\n    return alpha;\n    \n}\n\n\nvec4 red = vec4(1.0, 0.0, 0.0, 1.0);\nvec4 green = vec4(0.0, 1.0, 0.0, 1.0);\nvec4 blue = vec4(0.0, 0.0, 1.0, 1.0);\n\nvec2 position = vec2(0.1, 0.0);\nvec2 side = vec2(0.8, 0.7);\n\nvec2 chimney = vec2(0.8, 0.7);\nvec2 chimneySide = vec2(0.1, 0.25);\n\nvec2 win1 = vec2(0.6, 0.4);\nvec2 win1Side = vec2(0.2, 0.15);\n\nvec2 win2 = vec2(0.2, 0.4);\nvec2 win2Side = vec2(0.2, 0.15);\n\nvec2 win3 = vec2(0.6, 0.1);\nvec2 win3Side = vec2(0.2, 0.15);\n\nvec2 win4 = vec2(0.2, 0.1);\nvec2 win4Side = vec2(0.2, 0.15);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //set the variables to 0.0 to make a layer invisible.\n    float houseOpacity = 1.0;\n    float chimneyOpacity = 1.0;\n    float windowsOpacity = 1.0;\n    \n    //layer1 = house, layer2 = chimney, layer3 = windows.\n    vec4 layer1, layer2, layer3;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    \n    layer1 = blue;\n    layer1.a = drawRect(position, side, uv);\n    layer1.a*=houseOpacity;\n    \n    layer2 = red;\n    layer2.a = drawRect(chimney, chimneySide, uv);\n    layer2.a*=chimneyOpacity;\n    \n    layer3 = green;\n    layer3.a = drawRect(win1, win1Side, uv);\n    layer3.a = drawRect(win2, win2Side, uv) + layer3.a;\n    layer3.a = drawRect(win3, win3Side, uv) + layer3.a;\n    layer3.a = drawRect(win4, win4Side, uv) + layer3.a;\n    layer3.a*=windowsOpacity;\n    \n    \n    \n\tvec4 tempColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    \n    //comment out a line to disable a layer.\n    tempColor = mix(tempColor, layer1, layer1.a);\n    tempColor = mix(tempColor, layer2, layer2.a);\n    tempColor = mix(tempColor, layer3, layer3.a);\n    \n\tfragColor = tempColor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tXcRs.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 64, 64, 139], [141, 141, 206, 206, 435], [930, 930, 987, 1045, 2051]]}
{"id": "4tXcRX", "name": "testanother", "author": "pas", "description": "oh", "tags": ["ihavenoideawhatiamdoing"], "likes": 2, "viewed": 63, "date": "1505651105", "time_retrieved": "2024-06-20T19:00:40.597665", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int val = int(fragCoord.x) ^ int(fragCoord.y);\n    float col = float(val/(iFrame % 500));\n\tfragColor = vec4(col, col / 2.0, pow(col * 0.1, 1.001), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tXcRX.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 216]]}
{"id": "4tXcW2", "name": "FirstProject", "author": "pjdevpl", "description": "First attemt to learn the sphere tracing from scratch", "tags": ["procedural", "3d", "spheretracing", "generated"], "likes": 0, "viewed": 62, "date": "1506365009", "time_retrieved": "2024-06-20T19:00:40.597665", "image_code": "#define add(a,b)    min((a),(b))\n#define com(a,b)    max((a),(b))\n#define neg(a)        (-(a))\n#define sub(a,b)    com((a),neg(b))\n#define inf(a,v)    ((a)+(v))\n\n#define pmod(a,b)    ( mod(mod((a),(b))+(b),(b)) )\n#define rep(a,r)    ( pmod(((a)+(r)*.5),(r))-(r)*.5 )\n\n#define repx(a,r)    vec3( rep((a).x,(r)), (a).yz )\n#define repy(a,r)    vec3( (a).x, rep((a).y,(r)), (a).z )\n#define repz(a,r)    vec3( (a).xy,rep((a).z,(r)) )\n#define repxy(a,r)    vec3( rep((a).xy,(r)), (a).z )\n#define repyz(a,r)    vec3( (a).x, rep((a).yz,(r)) )\n#define repxz(a,r)    vec3( rep((a).x,(r)), (a).y, rep((a).z,(r)) )\n\n#define scale(p,s)    ((p)/(s))*(s)\n\n//#define pmod(a,b)    \n//{ \n//    mod(mod(a,b)+b,b) \n//}\n\n//float opScale( vec3 p, float s )\n//{\n//    return primitive(p/s)*s;\n//}\n\n#define pi2            (2.*3.141593)\n#define R(plane,a)  (plane=vec2(cos((a)*pi2)*plane.x+sin((a)*pi2)*plane.y,cos((a)*pi2)*plane.y-sin((a)*pi2)*plane.x))\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat displacement(vec3 p)\n{\n    return sin(1.2*p.x)*sin(1.2*p.y)*sin(1.2*p.z);\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\nvec3 opCheapBend( vec3 p )\n{\n    float c = cos(2.0*p.y);\n    float s = sin(2.0*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\n//float opScale( vec3 p, float s )\n//{\n//    return primitive(p/s)*s;\n//}\n\nfloat fn(vec3 pos) \n{\n    R(pos.xy,iTime/8.);\n    //float s = udBox(pos,vec3(.5,.5,.5));\n    float s = udBox(opCheapBend(pos),vec3(.5,.5,.5));\n    //float s = sdSphere(pos,.5);\n    //float d = displacement(pos);\n    \n    float t = sdTorus(pos,vec2(.8, .25));\n    //float t = sdTorus(opTwist(pos),vec2(.8, .25));\n    //float t = sdTorus(opCheapBend(pos),vec2(.8, .25));\n    //float s = sdSphere(pos, 0.75);\n    \n    float sm = smin(s, t, 32.);\n    \n    return sm;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 vpos = uv*2.-1.;\n    vpos.x *= iResolution.x/iResolution.y;\n    vpos *= .8;\n\n    vec3 front = normalize(vec3(-1,0,1));\n    vec3 up = vec3(0,-1,0);\n    vec3 right = cross(up,front);\n    vec3 pos = vec3(0.,0.,0.)-front*2.5;\n\n    vec3 rdir = normalize(front + vpos.x*right + vpos.y*up);\n\n    vec3 rpos = pos;\n\n    for(int i=0;i<50;i++)\n    {\n        float d = fn(rpos);\n        //float d = opTwist(pos);\n        rpos += d*rdir;\n        if(d<0.01) break;\n        //rpos = 1;\n    }\n\n\n    fragColor = vec4(length(rpos-pos)-1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tXcW2.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[700, 931, 972, 972, 1043], [1045, 1045, 1080, 1080, 1104], [1106, 1106, 1137, 1137, 1175], [1177, 1177, 1210, 1210, 1275], [1277, 1277, 1305, 1305, 1358], [1360, 1360, 1384, 1384, 1516], [1518, 1518, 1546, 1546, 1663], [1665, 1740, 1761, 1761, 2204], [2206, 2206, 2263, 2263, 2841]]}
{"id": "4tXyD4", "name": "hsb2rgb", "author": "sgoal", "description": "hsb2rgb", "tags": ["hsb2rgb"], "likes": 2, "viewed": 115, "date": "1504750582", "time_retrieved": "2024-06-20T19:00:40.906764", "image_code": "#define Native 0\n\n#define _local_main_ void main()\n#define _shadertoy_main_ void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n#define u_resolution iResolution\n\n#if Native == 1\n    #define Main() _local_main_\n    #define fragColor gl_FragColor\n    #define fragCoord gl_FragCood\n    #define iTime iGlobalTime\n#else\n    #define Main() _shadertoy_main_\n    #define gl_FragColor fragColor\n    #define gl_FragCood fragCoord\n    #define iGlobalTime iTime\n#endif \n\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define TWO_PI 6.28318530718\n#define PI 3.141592653\n\n//  Function from Iñigo Quiles \n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0, \n                     0.0, \n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nMain(){\n    vec2 st = 2.0*vec2(gl_FragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    vec3 color = vec3(0.0);\n\n    // Use polar coordinates instead of cartesian\n    vec2 toCenter = vec2(0)-st*0.5;\n    float angle = atan(toCenter.y,toCenter.x*sin(PI*iTime));\n    float radius = length(toCenter);\n  \t\n    // Map the angle (-PI to PI) to the Hue (from 0 to 1)\n    // and the Saturation to the radius\n    //color = vec3(angle/TWO_PI+0.5,radius,1.0);\n    color = mix(hsb2rgb(vec3((angle/TWO_PI)+0.5,radius*3.0,1.0)),vec3(0.996,0.933,1.000),\n                smoothstep(.49,.5,radius));\n\n    gl_FragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tXyD4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[564, 639, 665, 665, 900]]}
{"id": "4tXyDH", "name": "dynamic Epsilon Moebius", "author": "ollj", "description": "iMous.y scales Epsilon, you want to keep that near the bottom\nimouse.y shows  3 modes in 3 segments\n\ngeometry is from\nhttps://www.shadertoy.com/view/XldSDs", "tags": ["terrain", "moebius", "epsilon", "epsilondynamiceps", "dynamicepsilon", "dynamiciterations"], "likes": 31, "viewed": 2521, "date": "1504533396", "time_retrieved": "2024-06-20T19:00:45.191963", "image_code": "//mod 3d moebius band terrain (good textureID code) dynamiceps.2\n//self  : https://www.shadertoy.com/view/4tXyDH\n//parent: https://www.shadertoy.com/view/XldSDs\n//removed iChannel calls must now be explicit\n#define UseIchannel\n//extended float trace(vec3 ro, vec3 rd,vec2 uv) to support 3 modes, set by EpsExp;\n\n/*\nThis demonstrates what i call [DynamicEps family] where epsilon depends on;\n - Previuus step length\n - Distance to camera\n - Silly things like iMouse.y (debugging and BAD field visualisation)\n - a linear function,  sqrt() or log()\n - all ot the above\n*/\n\n//best quality has makes epsilon logarythm; of squared distance , divided by last step length.\n\n//illustrating 3 modes below by making epsilon multiplied by iMouse.x\n#define EpsFactor ((iMouse.y/iResolution.x)*999.+.0001)\n//main purpose of EpsFactor is to illustrate the log()\n//set #defineEpsExpMO 2 below, to see how EpsFactor~=iMouse.y becomes nearly irrelevant.\n\n// if(EpsExpMO>-1) EpsExpMO ->overwrites-> EpsExp, making iMouse.x irrelevant.\n#define EpsExpMO -1\n\n/*\n[EpsExp] sets one of 3 modes within the raymarching loop \n (this should be more static in your implementation)\nEpsExp==0 ;the prrecious step lenghth is irrelevant, epsilon is static (besides EpsFactor)\nEpsExp==1 ;previous step length linearily scales epsilon.\nEpsExp==1 ;previous step length AND distance to camera logarrythmically scale epsilon.\n\n//d is accumulated euclidean distance to camera, d is euclidean distance ot the previous step\n         if(t>FAR) break;//marchign wend beyond zFAR\n#if   EpsExp==0\n         if(abs(d)<rmEps)break;  //constant epsilon\n#elif EpsExp==1\n         if(abs(d)<rmEps*(t*.125+1.)) break; //linear epsilon\n#else\n         if(0.<log(t*t*rmEps/d)||t>FAR)break; //log(epsilon)\n#endif\n\nEpsExp 2 has significantly better precision at roughly equal runtime.\nEpsExp 2 performs exponentially worse on higher resolutions,\n         and exponewntially better on lower resolutions.\n*/\n\n\n//in the long run, logarytmiceps seems to perform best.\n\n\n/*\nThis also spawns (and kind of begs for develipng)\nDynamicIter, where the number of raymarching iterations may depend on\n - uv.y             //more iteratons near horizon)\n - uv.x             //more iterations in the centr of a corridor)\n - length(uv-mouse) //more iterations near the mouse cursot \n - dither(hash(uv)) //hide understepping, low iteration count in hashed dithering. \n\nand this only makes sense because dynamiceps allows to scale Iteration count much higher.\n*/\n\n\n\n//shape is VERY nice, suits the dynamiceps demo:\n\n/*\n    Mobius Object\n    -------------\n\n\tI love looking at the Mobius-related renderings that artistically and scientifically inclined people\n\tput up on places like DeviantArt, etc. There are so many interesting variations and rendering styles \n\tout there. There's also a few interesting examples on this site. Anyway, here's yet another one.\n\n\tAesthetically speaking, I started with a clean look that emphasized the Mobius object, then lost focus \n    and got carried away with the surroundings, which for some reason, led to things resembling a grungey, \n\tbrooding early-2000s demo scene. :) I saved the cleaner version, so I might put that up later.\n\n\tTopology was a long time ago for me, so I'm not sure what the object is technically called, but it's \n\teasy to see that it's based on the Mobius strip. In descriptive terms, I guess it's a toroidal shape... \n\ttwisted in the poloidal direction about the toroidal axis? Either way, these things are not much more \n    difficult to code than a torus.\n\n\tAs for the Mobius object construction, it's pretty straight forward for anyone comfortable with the \n\tconcepts behind a toroidal distance field. As always, it was helpful to have examples on this site to \n\trefer to. One of Dr2's versions helped me correct an annoying quantization error I was making. I'm \n\thuman, and therefore prone to errors. Thankfully, Dr2 is not. :D\n\n\tOther examples:\n    \n\t// Interlinked Mobius strips. Really cool geometry.\n\tLinked Rings - Dr2    \n\thttps://www.shadertoy.com/view/XsGXR1\n\n\t// An Escher recreation: A lot of work went into it.\n\tMoebius Strip 2 - Dr2\n\thttps://www.shadertoy.com/view/MscXWX\n\n    // I love this one. More variation.\n\tTwisted Jewelry - vgs\n\thttps://www.shadertoy.com/view/MdjXzG\n\tBased on:\n\tMöbius Balls - xTr1m\n\thttps://www.shadertoy.com/view/ldl3zr\n\n*/\n\n\n#define FAR 40.\n\n// Scene object ID to separate the Mobius object from the terrain and a Mobius object ID to separate \n// the rails from the slats. It was easier to do it this way, but I'll amalgamate them later.\nfloat objID;\nfloat mObjID;\n\n// 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n// of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 r2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n\n// IQ's smooth minium function. \nfloat smin(float a, float b , float s){\n    \n    float h = clamp( 0.5 + 0.5*(b-a)/s, 0. , 1.);\n    return mix(b, a, h) - h*(1.0-h)*s;\n}\n\n\n// Smooth maximum, based on the function above.\nfloat smax(float a, float b, float s){\n    \n    float h = clamp( 0.5 + 0.5*(a-b)/s, 0., 1.);\n    return mix(b, a, h) + h*(1.0-h)*s;\n}\n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(41, 289)));\n    return fract(vec2(262144, 32768)*n);\n    \n}//https://www.shadertoy.com/view/XldSDs\n\n// 2D 2nd-order Voronoi: Obviously, this is just a rehash of IQ's original. I've tidied\n// up those if-statements. Since there's less writing, it should go faster. That's how \n// it works, right? :)\n//\nfloat Voronoi(in vec2 p){\n    \n\tvec2 g = floor(p), o; p -= g;\n\t\n    // I'm not sure what the largest conceivable closest squared-distance would be, but I think \n    // values as high as 2.5 (center to non-diagonal outer square corner) are possible. Statistically, \n    // it's unlikely, so when scaling back the final value to the zero-to-one range, I divide by \n    // something less than my maximum and cap it to one... It's all a matter of what look you're \n    // trying to achieve.\n\tvec3 d = vec3(2.5);\n    \n\tfor(int y=-1; y<=1; y++){\n\t\tfor(int x=-1; x<=1; x++){\n            \n\t\t\to = vec2(x, y);\n            o += hash22(g + o) - p;\n            \n\t\t\td.z = dot(o, o);\n            d.y = max(d.x, min(d.y, d.z));\n            d.x = min(d.x, d.z); \n                       \n\t\t}\n\t}\n\n    // Final value, with rough scaling.\n    return min((d.y - d.x)*.6, 1.); // Scale: [0, 1].\n    \n}\n\n\n// The triangle function that Shadertoy user Nimitz has used in various triangle noise demonstrations.\n// See Xyptonjtroz - Very cool. Anyway, it's not really being used to its full potential here.\nvec3 tri(in vec3 x){return abs(fract(x)-.5);} // Triangle function.\n//vec3 triSmooth(in vec3 x){return cos(x*6.2831853)*0.25+0.25;} // Smooth version. Not used here.\n\n\n// This is a cheap...ish routine - based on the triangle function - that produces a pronounced jagged \n// looking surface. It's not particularly sophisticated, but it does a surprizingly good job at laying \n// the foundations for a sharp rock face. Obviously, more layers would be more convincing. In fact, \n// I'm disappointed that there weren't enough cycles for one more layer. Unfortunately, this is a \n// GPU-draining distance function. The really fine details have been bump mapped.\nfloat terrain(in vec3 p){\n    \n    \n    // This is just one variation on a common technique: Take a cheap function, then\n    // layer it by applying mutations, rotations, frequency and amplitude changes,\n    // etc. Feeding the function into itself, folding it, and so forth can also \n    // produce interesting surfaces, patterns, etc.\n    //\n    // Good examples of the technique include IQ's spiral noise and Nimitz's triangle\n    // noise, each of which can be found on Shadertoy. \n    //\n    float n = dot(tri(p*0.3 + tri(p.yzx*0.15)), vec3(0.44));\n    p = p*1.57;//1.5773;// - n; // The \"n\" mixes things up more.\n    p.yz = mat2(.866025, .5, -.5, .866025)*p.yz;\n    p.xz = mat2(.866025, .5, -.5, .866025)*p.xz;\n    n += dot(tri(p*0.45 + tri(p.yzx*0.225)), vec3(0.222));\n    \n    return smoothstep(0.3, .95, n); // Smoothstep for peaks and troughs. Range [0, 1]\n\n\n}\n\n// The Mobius object: Take an object, sweep it around in a path (circle) at radius R, and twist (roll) \n// with the axial plane as you do it. Essentially, that's all you're doing.\n//\n// By the way, I've explained the process in a hurry with a \"near enough is good enough\" attitude, \n// so if any topology experts out there spot any conceptual errors, mislabling, etc, feel free to \n// let me know.\nfloat Mobius(vec3 q){\n \n    //// CONSTANTS ////\n    const float toroidRadius = 1.25; // The object's disc radius.\n    //const float ringWidth = .15; \n    const float polRot = 4./4.; // Poloidal rotations.\n    const float ringNum = 32.; // Number of quantized objects embedded between the rings.\n    \n    \n    //// RAIL SECTION ////\n    vec3 p = q;\n    \n    // Angle of the point on the XZ plane.\n    float a = atan(p.z, p.x);\n    \n    // Angle of the point at the center of 32 (ringNum) partitioned cells.\n    //\n    // Partitioning the circular path into 32 (ringNum) cells - or sections, then obtain the angle of \n    // the center position of that cell. The reason you want that angle is so that you can render \n    // something at the corresponding position. In this case, it will be a squared-off ring looking object.  \t\n    float ia = floor(ringNum*a/6.2831853);  \n    // The \".5\" value for the angle of the cell center. It was something obvious that I'd overlooked.\n    // Thankfully, Dr2 did not. :)\n  \tia = (ia + .5)/ringNum*6.2831853; \n    \n    // Sweeping a point around a central point at a distance (toroidRadius), more or less. Basically, it's\n    // the toroidal axis bit. If that's confusing, looking up a toroidal\\poloidal image will clear it up.\n    p.xz *= r2(a);\n    p.x -= toroidRadius;\n    p.xy *= r2(a*polRot);  // Twisting about the poloidal direction (controlled by \"polRot) as we sweep.\n    \n\n    // The rail object. Taking the one rail, then ofsetting it along X and Y, resulting in four rails.\n    // This is a neat spacial partitioning trick, and worth knowing if you've never encountered it before.\n    // Basically, you're taking the rail, and splitting it into two along X and Y... also along Z, but since \n    // the object is contiunous along that axis, the result is four rails.\n    p = abs(abs(p) - .25); // Change this to \"p = abs(p),\" and you'll see what it does.\n\n    float rail = max(max(p.x, p.y) - .07, (max(p.y-p.x, p.y + p.x)*.7071 - .075)); // Makeshift octagon.\n    \n    \n    //// REPEAT RING SECTION ////\n    // The repeat square rings. It's similar to the way in which the rails are constructed, but since the object\n    // isn't continous, we need to use the quantized angular positions (using \"ia\").\n    p = q;\n    // Another toroidal sweep using the quantized (partitioned, etc) angular position.\n    p.xz *= r2(ia); // Using the quantized angle to obtain the position of the center of the corresponding cell.\n    p.x -= toroidRadius;\n    p.xy *= r2(a*polRot);  // Twisting about the poloidal direction - as we did with the rails.\n    \n    // Constructing some square rings.\n    p = abs(p);\n    float ring = max(p.x, p.y); // Square shape.\n    // Square rings: A flat cube, with a thinner square pole taken out.\n    ring = max(max(ring - .275, p.z - .03), -(ring - .2));\n    \n    \n    //// WHOLE OBJECT ////\n    // Object ID for shading purposes.\n    mObjID = step(ring, rail); //smoothstep(0., .07, rail - sqr);\n    \n    // Smoothly combine (just slightly) the square rings with the rails.\n    return smin(ring, rail, .07); \n\n}\n\n\n// Combining the Mobius object with the terrain.\nfloat map(vec3 p){\n    \n    // Mobius object, sitting a bit above the terrain.\n    float obj = Mobius(p - vec3(0, .4, 0));\n    \n    float ter = terrain(p); // The terrain.\n \n    float fl = p.y  - ter; // Adding it to a flat plane.\n    \n    // Creating a flat area to sit the Mobius object on.\n    fl =  smax(fl, -max(length(p - vec3(0, 2.5, 0)) - 3., - p.y - .0), .5);\n \n    // Object ID.\n    objID = step(obj, fl);\n    \n    // Putting the Mobius object on the terrain.\n    return min(fl, obj);\n \n}\n\n\n// Standard raymarching routine.\nfloat trace(vec3 ro, vec3 rd,vec2 uv){\n float t = .0;    \n float rmIte=32.;\n float rmEps=.002; \n int EpsExp=0;//left third of iMouse \n if(uv.x>(iMouse.x/iResolution.x)*2.-1.+.5){//central third ofiMouse\n  EpsExp=2;\n  //rmIte gets \"uo to 200-3000\" rmIte-rations, for being VERY convergent log()\n  //due to maximum convergende, it rarely ever uses that many iterations\n  rmIte=min(300.,48.*log(    min(iResolution.x,iResolution.y)));\n  //values above 1000 cause too high risk to crash some implementation's drivers.\n  // rmIte=min(1000.,.5*(length(vec2(iResolution.x,iResolution.y))));\n }else if(uv.x>(iMouse.x/iResolution.x)*2.-1.5){//right third ofiMouse\n  EpsExp=1;\n  rmIte=48.;//linear increasing eps gets a few more rmIte-rations, \n            //for being a bit more convergentt\n  rmEps=.001; //and a smaller epsilon\n }\n\n //manual overwrite\n #if EpsExpMO==1\n  EpsExp=1;\n  rmIte=48.;//linear increasing eps gets a few more rmIte-rations, \n            //for being a bit more convergentt\n  rmEps=.001;//and a smaller epsilon\n #elif EpsExpMO==2\n  EpsExp=2;\n  rmIte=min(300.,48.*log(min(iResolution.x,iResolution.y)));\n  //values above 1000 cause too high risk to crash some implementation's drivers.\n//float rmIte=min(1000.,.5*(length(vec2(iResolution.x,iResolution.y))));\n  //also allows for smaller epsilon\n  rmEps= .000001;\n #endif\n rmEps*=EpsFactor;//mouse.y scales this one\n for (float i=.0; i<rmIte; i++){\n   float d=map(ro + rd*t);\n     if(t>FAR) break;\n     if (EpsExp==0){\n      if(abs(d)<rmEps)break;\n     }else if (EpsExp==1){\n      if(abs(d)<rmEps*(t*.125+1.)) break;//scaling epsilon by lasr march distance is nice.\n     }else{\n      if(0.<log(t*t*rmEps/d))break;//also logarytmic epsilon allows for high values\n     }\n     t += d*.85;  // Using more accuracy, in the first pass.\n    }\n    \n    return min(t, FAR);\n}\n\n\n\n// The normal function with some edge detection rolled into it. Sometimes, it's possible to get away\n// with six taps, but we need a bit of epsilon value variance here, so there's an extra six.\nvec3 getNormal(vec3 p, inout float edge, inout float crv, float ef, float t){ \n\t\n    vec2 e = vec2(ef/iResolution.y, 0); // Larger epsilon for greater sample spread, thus thicker edges.\n\n    // Take some distance function measurements from either side of the hit point on all three axes.\n\tfloat d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\tfloat d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\tfloat d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\tfloat d = map(p)*2.;\t// The hit point itself - Doubled to cut down on calculations. See below.\n     \n    // Edges - Take a geometry measurement from either side of the hit point. Average them, then see how\n    // much the value differs from the hit point itself. Do this for X, Y and Z directions. Here, the sum\n    // is used for the overall difference, but there are other ways. Note that it's mainly sharp surface \n    // curves that register a discernible difference.\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    //edge = max(max(abs(d1 + d2 - d), abs(d3 + d4 - d)), abs(d5 + d6 - d)); // Etc.\n    \n    // Once you have an edge value, it needs to normalized, and smoothed if possible. How you \n    // do that is up to you. This is what I came up with for now, but I might tweak it later.\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n    \n    \n    //crv = clamp((d1 + d2 + d3 + d4 + d5 + d6 - d*3.)*32. + .5, 0., 1.);\n\t\n    // Redoing the calculations for the normal with a more precise epsilon value.\n    e = vec2(.002, 0);//*min(1. + t, 5.)\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx); \n    \n    // Return the normal.\n    // Standard, normalized gradient mearsurement.\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 20; \n    \n    vec3 rd = (lp-ro); // Unnormalized direction ray.\n\n    float shade = 1.0;\n    float dist = 0.05;    \n    float end = max(length(rd), 0.001);\n    //float stepDist = end/float(maxIterationsShad);\n    \n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        //dist += min( h, stepDist ); // So many options here: dist += clamp( h, 0.0005, 0.2 ), etc.\n        dist += clamp(h, 0.01, 0.5);\n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0.001 || dist > end) break; \n    }\n\n    // I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing.\n    return min(max(shade, 0.) + 0.2, 1.0); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat cAO(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = 2.0, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\n\n \n\n// The bump mapping function.\nfloat bumpFunction(in vec3 p){\n    \n    // A reproduction of the lattice at higher frequency. Obviously, you could put\n    // anything here. Noise, Voronoi, other geometrical formulas, etc.\n    return Voronoi(p.xz*6.);\n   \n   \n}\n\n// Standard function-based bump mapping function with some edging thrown into the mix.\nvec3 doBumpMap(in vec3 p, in vec3 n, float bumpfactor, inout float edge, inout float crv){\n    \n    // Resolution independent sample distance... Basically, I want the lines to be about\n    // the same pixel width, regardless of resolution... Coding is annoying sometimes. :)\n    vec2 e = vec2(1.5/iResolution.y, 0); \n    \n    float f = bumpFunction(p); // Hit point function sample.\n    \n    float fx = bumpFunction(p - e.xyy); // Nearby sample in the X-direction.\n    float fy = bumpFunction(p - e.yxy); // Nearby sample in the Y-direction.\n    float fz = bumpFunction(p - e.yyx); // Nearby sample in the Y-direction.\n    \n    float fx2 = bumpFunction(p + e.xyy); // Sample in the opposite X-direction.\n    float fy2 = bumpFunction(p + e.yxy); // Sample in the opposite Y-direction.\n    float fz2 = bumpFunction(p+ e.yyx);  // Sample in the opposite Z-direction.\n    \n     \n    // The gradient vector. Making use of the extra samples to obtain a more locally\n    // accurate value. It has a bit of a smoothing effect, which is a bonus.\n    vec3 grad = vec3(fx - fx2, fy - fy2, fz - fz2)/(e.x*2.);  \n    //vec3 grad = (vec3(fx, fy, fz ) - f)/e.x;  // Without the extra samples.\n\n\n    // Using the above samples to obtain an edge value. In essence, you're taking some\n    // surrounding samples and determining how much they differ from the hit point\n    // sample. It's really no different in concept to 2D edging.\n    edge = abs(fx + fy + fz + fx2 + fy2 + fz2 - 6.*f);\n    edge = smoothstep(0., 1., edge/e.x);\n    \n    \n    // We may as well use the six measurements to obtain a rough curvature value while we're at it.\n    //crv = clamp((fx + fy + fz + fx2 + fy2 + fz2 - 6.*f)*32. + .6, 0., 1.);\n    \n    // Some kind of gradient correction. I'm getting so old that I've forgotten why you\n    // do this. It's a simple reason, and a necessary one. I remember that much. :D\n    grad -= n*dot(n, grad);          \n                      \n    return normalize(n + grad*bumpfactor); // Bump the normal with the gradient vector.\n\t\n}\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D channel, vec3 p, vec3 n){\n    \n    n = max(abs(n) - .2, 0.001);\n    n /= dot(n, vec3(1));\n    #ifdef UseIchannel\n\tvec3 tx = texture(channel, p.zy).xyz;\n    vec3 ty = texture(channel, p.xz).xyz;\n    vec3 tz = texture(channel, p.xy).xyz;\n    \n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n    #else \n     return vec3(0);\n    #endif\n}\n    \n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.002, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n// Cool curve function, by Shadertoy user, Nimitz.\n//\n// I think it's based on a discrete finite difference approximation to the continuous\n// Laplace differential operator? Either way, it gives you the curvature of a surface, \n// which is pretty handy. I used it to do a bit of fake shadowing.\n//\n// Original usage (I think?) - Cheap curvature: https://www.shadertoy.com/view/Xts3WM\n// Other usage: Xyptonjtroz: https://www.shadertoy.com/view/4ts3z2\nfloat curve(in vec3 p, in float w){\n\n    vec2 e = vec2(-1., 1.)*w;\n    \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    \n    return 0.125/(w*w) *(t1 + t2 + t3 + t4 - 4.*map(p));\n}\n\n\n// Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n// example that explains it, if you require it.\nfloat n3D(in vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n\n\n// Very basic pseudo environment mapping... and by that, I mean it's fake. :) However, it \n// does give the impression that the surface is reflecting the surrounds in some way.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 envMap(vec3 p){\n    \n    p *= 2.;\n    p.xz += iTime*.5;\n    \n    float n3D2 = n3D(p*2.);\n   \n    // A bit of fBm.\n    float c = n3D(p)*.57 + n3D2*.28 + n3D(p*4.)*.15;\n    c = smoothstep(0.5, 1., c); // Putting in some dark space.\n    \n    p = vec3(c*c*c*c, c*c, c); // Bluish tinge.\n    \n    return mix(p.zxy, p, n3D2*.34 + .665); // Mixing in a bit of purple.\n\n}\n \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t\n\t// Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n \n \n    \n\t// Camera Setup.\n\tvec3 lk = vec3(0, .25, 0);  // \"Look At\" position.\n\tvec3 ro = lk + vec3(cos(iTime/4.)*2.8, cos(iTime/2.)*sin(iTime/4.)*.25 + .75, sin(iTime/4.)*3.3); // Camera position, doubling as the ray origin.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(.85, 1.75, -1);// Put it a bit in front of the camera.\n\t\n\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.25; // FOV - Field of view.\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    vec3 rd = normalize(fwd + (rgt*uv.x + up*uv.y)*FOV);\n\n    \n    /*   \n    // Mouse controls.   \n\tvec2 ms = vec2(0);\n    if (iMouse.z > 1.0) ms = (2.*iMouse.xy - iResolution.xy)/iResolution.xy;\n    vec2 a = sin(vec2(1.5707963, 0) - ms.x); \n    mat2 rM = mat2(a, -a.y, a.x);\n    rd.xz = rd.xz*rM; \n    a = sin(vec2(1.5707963, 0) - ms.y); \n    rM = mat2(a, -a.y, a.x);\n    rd.yz = rd.yz*rM;\n    */\n\t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd, uv);\n    \n    float svObjID = objID;\n    float svMObjID = mObjID;\n\t\n    // Initiate the scene color to black.\n\tvec3 sceneCol = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n        // Edge and edge-factor. The latter was necessary, to even up the line width between\n        // the Mobius object and the terrain... but I ultimately didn't use it. :)\n        float edge, crv = 1., ef = 4.; // Curvature variable not used, and commented out in the function.\n        \n        // Texture scale factor.\n        float tSize0 = 1.;\n        \n        // Texture-based bump mapping factor.\n        float bf = .005;\n        \n        if(svObjID<0.5) { // Different setting for the terrain.\n            bf = .02;\n            tSize0 = 1./1.;\n            ef = 1.5;\n        }\n    \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    vec3 sn = getNormal(sp, edge, crv, ef, t);\n        \n        // Texture-based bump mapping. Comment it out, if you prefer a cleaner look.\n        // I haven't decided yet. :)\n   \n\n        #ifdef UseIchannel\n         sn =texBump(iChannel0, sp*tSize0, sn, bf);\n        #else \n          //sn = vec3(.0);\n        #endif\n        \n        // Function-based bump mapping. Note the second edge variable used for bump mapped\n        // edging - as opposed to distance field edging. There's also a second curvature\n        // variable that isn't used.\n        float edge2 = 0., crv2 = 1.;    \n        if(svObjID<.5) sn = doBumpMap(sp, sn, .1/(1. + t/FAR), edge2, crv2);    \n        \n\n\t    \n        \n        // Obtaining the texel color. \n\t    vec3 texCol;        \n        \n        if(svObjID<0.5) { // Terrain texturing.\n            \n            //texCol = vec3(.5); \n            #ifdef UseIchannel\n             texCol =tex3D(iChannel0, sp*tSize0, sn);//*vec3(1, .6, .4);\n            #else \n             texCol = vec3(.1);\n            #endif\n            texCol = smoothstep(0.05, .5, texCol)*vec3(1, .75, .5);//*vec3(1, .7, .6);//\n            texCol *= terrain(sp)*.5 + .5;\n            //texCol *= crv*.75 + .25;\n        }\n        else { // Mobius texturing.\n            \n            texCol = vec3(.5); \n            #ifdef UseIchannel\n             texCol =tex3D(iChannel0, sp*tSize0, sn);\n            #else \n             texCol = vec3(.1);\n            #endif\n            texCol = smoothstep(0.05, .5, texCol);\n            \n            // Coloring the Mobius rings. Mixing to avoid nesting an \"if\" call.\n            texCol = mix(texCol, texCol*vec3(1, .4, .2)*2., svMObjID);\n        }\n\n\n    \t\n    \t// Light direction vectors.\n\t    vec3 ld = lp-sp;\n\n        // Distance from respective lights to the surface point.\n\t    float lDist = max(length(ld), 0.001);\n    \t\n    \t// Normalize the light direction vectors.\n\t    ld /= lDist;\n\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, 8.);\n    \tfloat ao = cAO(sp, sn); // Ambient occlusion.\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*lDist*0.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.0);\n        diff = pow(diff, 4.)*1.5; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 16.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow( clamp(dot(sn, rd) + 1., .0, 1.), 4.);\n\n        \n        \n        // I got a reminder looking at XT95's \"UI\" shader that there are cheaper ways\n        // to produce a hint of reflectivity than an actual reflective pass. :)        \n        vec3 env = envMap(reflect(rd, sn))*2.; //envMap(refract(rd, sn, 1./1.3))*3.;\n        if(svObjID<.5) { // Lowering the terrain settings a bit.\n            env *= .25;\n            //diff *= .5;\n            spec *= .5;            \n            fre *= .5;\n        }\n        \n\n        // Combining the above terms to procude the final color.\n        sceneCol += (texCol*(diff + 0.15 + vec3(.7, .9, 1)*fre) + env + vec3(.7, .9, 1)*spec*2.);\n\n        \n        // Distance function edging for the Mobius object, and bump mapped edging only\n        // for the terrain.\n        if(svObjID>.5) sceneCol *= (1. - edge*.8);\n        else sceneCol *= (1. - edge2*.7); //*crv2;//(1. - edge*.8)*\n        \n\n        // Shading.\n        sceneCol *= ao*atten*sh;\n        \n        \n\t\n\t}\n    \n    // Simple dark fog. It's almost black, but I left a speck of blue in there to account for \n    // the blue reflective glow... Although, it still doesn't explain where it's coming from. :)\n    vec3 bg = mix(vec3(.6, .5, 1), vec3(.025, .05, .1), clamp(rd.y + .75, 0., 1.));\n    sceneCol = mix(sceneCol, bg/48., smoothstep(0., .95, t/FAR));\n    \n    // Rought gamma correction.\n\tfragColor = vec4(sqrt(clamp(sceneCol, 0., 1.)), 1.0);\n    \n    fragColor.r-=.1;//reduce red, as \"personal easy differentiable (water)mark\"\n    \n    #if EpsExpMO<0\n    //mix in white border lines\n                  uv.x-=iMouse.x/iResolution.x*2.-1.;\n    fragColor=mix(vec4(1.),fragColor,\n                  min(1.,sqrt(abs(abs((uv.x))-.5))+.7));\n    #endif\n      //abs(uv.x)-(iMouse.x/iResolution.x)*2.-.5))\n\t\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tXyDH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[4595, 4747, 4765, 4765, 4833], [4836, 4869, 4908, 4908, 5004], [5007, 5055, 5093, 5093, 5188], [5190, 5212, 5233, 5582, 5672], [5713, 5915, 5940, 5940, 6793], [6796, 6994, 7014, 7014, 7039], [7162, 7651, 7676, 8143, 8521], [8523, 8921, 8942, 8968, 12000], [12003, 12052, 12070, 12130, 12550], [12553, 12586, 12624, 12624, 14414], [14418, 14612, 14689, 14689, 16393], [16395, 16586, 16630, 16747, 17862], [17865, 18017, 18054, 18054, 18313], [18320, 18350, 18380, 18539, 18578], [18580, 18667, 18757, 18941, 20694], [20696, 20850, 20896, 20896, 21491], [21498, 21685, 21745, 21745, 22252], [22254, 22705, 22740, 22740, 22944], [22947, 23090, 23111, 23111, 23457], [23461, 23760, 23780, 23780, 24128], [24133, 24133, 24189, 24215, 30871]]}
{"id": "4tXyDn", "name": "The ollj (fast, simple) arrow", "author": "etale_cohomology", "description": "Fork of ollj's https://www.shadertoy.com/view/XsBBRd\n\nThe fastest arrow SDF in the west. Draws 28000 arrows at 60 fps with a Titan XM (tested offline in OpenGL). About 20x faster than the other arrow SDF I had found: https://www.shadertoy.com/view/XtlcRM", "tags": ["2d", "simple", "sdf", "fast", "optimized", "distance", "field", "arrow", "signed", "ollj"], "likes": 6, "viewed": 198, "date": "1504669395", "time_retrieved": "2024-06-20T19:00:45.598110", "image_code": "// Fork of ollj's https://www.shadertoy.com/view/XsBBRd\n\n// Arrow-shaped distance field, by ollj. Made for performance.\n// The head is computed with a single dot().\n// The stem distance field is good enough for most cases.\n\n// ------------------------------------------------------------------------------------------------\nfloat m_stretch(float point, float stretch){\n    return .5 * (sign(point) * stretch - point) * (sign(abs(point) - stretch) + 1.);\n}\n\n#define m_stretch_neg(p, st) (.5 * m_stretch(2. * p + st, st))  /* Stretch-negative: positive values are fixed */\n#define m_stretch_pos(p, st) (.5 * m_stretch(2. * p, st))  /* Stretch-positive: negative values are fixed */\n\n// A fast \"manual\" lossy rotate function by ollj.\n// Control the angle of rotation by specifying the ROTATE_PARAM constants.\n// https://en.wikipedia.org/wiki/Trigonometric_constants_expressed_in_real_radicals\nfloat ollj_rotate(vec2 uv){\n    const float ROTATE_PARAM0 = sqrt(1.);  // Try changing these!\n    const float ROTATE_PARAM1 = sqrt(.0);\n    return dot(uv, vec2(ROTATE_PARAM0 + ROTATE_PARAM1, ROTATE_PARAM0 - ROTATE_PARAM1));\n}\n\n// Optimized arrow SDF, by ollj\n// @head_len isn't actual uv units, but the unit size depends on ROTATE_PARAMs\nfloat sdf_arrow(vec2 uv, float norm, float angle, float head_height, float stem_width){\n    uv = vec2(cos(angle) * uv.x + sin(angle) * uv.y, -sin(angle) * uv.x + cos(angle) * uv.y);\n\n    norm -= head_height;  // Make sure the norm INCLUDES the arrow head\n    uv.x -= norm;  // Place the arrow's origin at the stem's base!\n\n    uv.y = abs(uv.y);\n    float head = max(ollj_rotate(uv) - head_height, -uv.x);\n\n    uv.x = m_stretch_neg(uv.x, norm);\n    uv.y = m_stretch_pos(uv.y, stem_width);\n    float stem = length(uv);\n\n    return min(head, stem);  // Join head and stem!\n}\n\n// ------------------------------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    float SCALE = 8. * (1.1 + sin(.4 * iTime));\n    vec2 uv = SCALE * (2. * fragCoord - iResolution.xy) / iResolution.y;\n\n    vec2  arrow_uv = uv + .5 * vec2(2. * cos(iTime), sin(.5 * iTime));\n    float arrow_norm = 1. * (1. + sin(iTime));  // Actual uv units PLUS a small constant!\n    float arrow_angle = iTime;\n    float arrow_head_height = .1;  // Actual uv units under suitable ROTATE_PARAMs\n    float arrow_stem_width = .04;  // Actual uv units PLUS a small constant!\n    float arrow_aa = 4. * SCALE / iResolution.y;\n    float arrow;\n\n    //for(float i=0.; i<28000.; i += 1.){  // This is a good way to benchmark, right? Right...? =D\n        arrow = sdf_arrow(arrow_uv, arrow_norm, arrow_angle, arrow_head_height, arrow_stem_width);\n        arrow = smoothstep(arrow_aa, 0., arrow);\n    //}\n\n    fragColor.rgb = vec3(arrow);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tXyDn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[224, 324, 368, 368, 455], [681, 890, 917, 917, 1115], [1117, 1228, 1315, 1315, 1799], [1801, 1901, 1955, 1955, 2787]]}
{"id": "4tXyWN", "name": "Integer Hash - III", "author": "iq", "description": "Yeat another hash experiment", "tags": ["2d", "hash"], "likes": 34, "viewed": 2889, "date": "1504764022", "time_retrieved": "2024-06-20T19:00:45.925473", "image_code": "// The MIT License\n// Copyright © 2017 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Not tested for uniformity, stratification, periodicity or whatever. Use (or not!) at your own risk\n//\n// See these too: \n//\n// - https://www.shadertoy.com/view/llGSzw\n// - https://www.shadertoy.com/view/XlXcW4\n// - https://www.shadertoy.com/view/4tXyWN\n\nfloat hash( uvec2 x )\n{\n    uvec2 q = 1103515245U * ( (x>>1U) ^ (x.yx   ) );\n    uint  n = 1103515245U * ( (q.x  ) ^ (q.y>>3U) );\n    return float(n) * (1.0/float(0xffffffffU));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uvec2 p = uvec2(fragCoord) + 1920U*1080U*uint(iFrame);\n    \n    float f = hash(p);\n    \n    fragColor = vec4( f, f, f, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/4tXyWN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1079, 1336, 1359, 1359, 1515], [1517, 1517, 1574, 1574, 1706]]}
{"id": "ldfyDs", "name": "droplet", "author": "lorcan", "description": "2d droplet", "tags": ["2d"], "likes": 0, "viewed": 93, "date": "1505992154", "time_retrieved": "2024-06-20T19:00:45.925473", "image_code": "float drop(vec2 p, vec2 c, float period)\n{\n    float d = distance(p, c) / period;\n    \n    // todo period modulation\n    return abs(cos(3.14 * d)) * exp(-0.3 * d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    \n    float t = 0.5+0.5*sin(iTime);\n    vec2 p = fragCoord.xy;\n    vec2 c = iResolution.xy * 0.5;\n    float d = drop(p, c, 4.0 + 60.0 * t);\n    \n    fragColor = mix(vec4(0.0, 0.0, 0.0, 1.0), vec4(1.0, 0.0, 0.0, 1.0), d);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldfyDs.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 42, 42, 165], [167, 167, 224, 224, 538]]}
{"id": "ldlcD8", "name": "Abstracts Curves", "author": "aiekick", "description": "Abstracts Curves", "tags": ["curves", "abstracts"], "likes": 7, "viewed": 443, "date": "1504282414", "time_retrieved": "2024-06-20T19:00:46.804280", "image_code": "// Created by Stephane Cuillerdier - @Aiekick/2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\n// Matrix operations\nmat3 getRotXMat(float a){return mat3(1.,0.,0.,0.,cos(a),-sin(a),0.,sin(a),cos(a));}\nmat3 getRotYMat(float a){return mat3(cos(a),0.,sin(a),0.,1.,0.,-sin(a),0.,cos(a));}\nmat3 getRotZMat(float a){return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\n\nvec2 path(float t)\n{\n    return vec2(2., 5.1) * 1.;\n}\n\nfloat df(vec3 p)\n{\n\tp.xy -= path(p.z);\n   \tp *= getRotZMat(p.z*0.05);\n    p = mod(p, 10.) - 5.;\n    return abs(p.y + sin(p.x)* .5) - .02;\n}\n\nvec3 nor( vec3 p, float k)\n{\n\tvec3 e = vec3( k, 0., 0. );\n\tvec3 nor = vec3(\n\t    df(p+e.xyy) - df(p-e.xyy),\n\t    df(p+e.yxy) - df(p-e.yxy),\n\t    df(p+e.yyx) - df(p-e.yyx) );\n\treturn normalize(nor);\n}\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// get density of the df at surfPoint\n// ratio between constant step and df value\nfloat SubDensity(vec3 surfPoint, float prec, float ms) \n{\n\tvec3 n;\n\tfloat s = 0.;\n    const int iter = 8;\n\tfor (int i=0;i<iter;i++)\n\t{\n\t\tn = nor(surfPoint,prec); \n\t\tsurfPoint = surfPoint - n * ms; \n\t\ts += df(surfPoint);\n\t}\n\treturn 1.-s/(ms*float(iter)); // s < 0. => inside df\n}\n\nfloat SubDensity(vec3 p, float s) \n{\n\tvec3 n = nor(p,s);\n\treturn df(p - n * s);\n}\n\n// from shane sahders\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n )\n{\n    n = max((abs(n) - .2)*7., .001);\n    n /= (n.x + n.y + n.z );  \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    return p*p;\n}\n\n// from shane sahders\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf)\n{\n    const vec2 e = vec2(0.001, 0);\n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n}\n\nvec4 shade(vec3 ro, vec3 rd, float d, vec3 lp)\n{\n\tvec3 p = ro + rd * d;\n\tfloat sb = SubDensity(p, 0.001, 0.1);\n\tvec3 bb = blackbody(100.*sb+100.);\n\tvec3 ld = normalize(lp-p);\n\tvec3 n = nor(p, .01);\n\tn = doBumpMap(iChannel0, -p*0.5, n, 0.015);\t\n\tvec3 refl = reflect(rd,n);\n\tfloat amb = 0.08;\n\tfloat diff = clamp( dot( n, ld ), 0.0, 1.0 );\n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 16. );\n\tfloat spe = pow(clamp( dot( refl, ld ), 0.0, 1.0 ),25.);\n\tfloat sss = 1. - SubDensity(p*0.1, 5.) * 0.5; \n\treturn vec4(\n        (diff + fre + bb.x * sss) * amb + diff * 0.5, \n        (diff + fre + bb * sb + sss * 0.3) * amb + spe * 0.6 - diff * sss * 0.05\t\n    );\n}\n\nvec3 cam(vec2 g, vec2 si, vec3 ro, vec3 cv)\n{\n\tvec2 uv = (g+g-si)/si.y;\n\tvec3 cu = normalize(vec3(0,1,0) * getRotZMat(ro.z*-0.03));\n  \tvec3 z = normalize(cv-ro);\n    vec3 x = normalize(cross(cu,z));\n  \tvec3 y= cross(z,x);\n  \treturn normalize(z + uv.x*x + uv.y*y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 f = vec4(0);\n    \n    vec2 g = fragCoord.xy;\n    vec2 si = iResolution.xy;\n\t\n    float time = iTime * 8.;\n    \n    vec3 cu = vec3(0,1,0);\n  \tvec3 cv = vec3(path(time + .1),time + .1);\n    vec3 ro = vec3(path(time),time);\n    ro *= getRotZMat(ro.z*0.06);\n\tcv *= getRotZMat(ro.z*0.06);\n\t\n\tvec3 lp = vec3(path(ro.z + 7.),ro.z + 7.);\n    vec3 rd = cam(g, si, ro, cv);\n\n    float s = 1., d = 1.;\n    for(int i=0;i<250;i++)\n    {      \n        if (log(d*d/s/1e6)>0.) break;\n        d += s = df(ro+rd*d) * .1;\n    }\n\t\n    f = shade(ro, rd, d, lp);\n\tf = f + f.x*0.3;\n\tf = mix( f, vec4(0.8), 1.0-exp( -0.001*d*d ) );\n\tfragColor = sqrt(f*f*f*2.);\n}\n", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldlcD8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[196, 217, 242, 242, 300], [301, 301, 326, 326, 384], [385, 385, 410, 410, 468], [470, 470, 490, 490, 523], [525, 525, 543, 543, 664], [666, 666, 694, 694, 865], [867, 1088, 1116, 1116, 1441], [1443, 1525, 1582, 1582, 1803], [1805, 1805, 1841, 1841, 1886], [1888, 2064, 2115, 2115, 2286], [2288, 2497, 2560, 2560, 3028], [3030, 3030, 3078, 3078, 3690], [3692, 3692, 3737, 3737, 3957], [3959, 3959, 4016, 4016, 4661]]}
{"id": "ldSBWV", "name": "Voronoi Trial", "author": "WingStone", "description": "just a test;\nuse three closest point to ensure two border and fix corner;\nreference:\nhttp://www.iquilezles.org/www/articles/voronoilines/voronoilines.htm\nhttps://www.shadertoy.com/view/MslGD8", "tags": ["voronoi"], "likes": 2, "viewed": 347, "date": "1505398679", "time_retrieved": "2024-06-20T19:00:47.380033", "image_code": "//#define GRAY\n\nvec2 Hash(vec2 p )\n{\n    mat2 mat = mat2(vec2(131.31, 313.13), vec2(13.13, 31.31));\n    p = mat  * p;\n    return fract(sin(p)*18.5453);\n}\n\nvec2 GetCenter(vec2 vpo1, vec2 vpo2, vec2 vpo3)\n{\n    \n    float d1 = dot(vpo3 - vpo1, vpo2 - vpo1);\n    float d2 = dot(vpo3 - vpo2, vpo1 - vpo2);\n    float d3 = dot(vpo1 - vpo3, vpo2 - vpo3);\n    \n    float c1 = d2 * d3;\n    float c2 = d1 * d3;\n    float c3 = d2 * d1;\n    \n    float c = c1 + c2 + c3;\n    \n    vec2 center = ((c2 + c3)*vpo1 + (c3 + c1)*vpo2 + (c1 + c2)*vpo3) / 2.0 / c;\n\n    return center;\n}\n\n//=============\n//return vec2( diatance, id)\nvec2 Veronoi(vec2 po, out vec2 vpo, out vec2 vpo1, out vec2 vpo2, out vec2 vpo3)\n{\n    po = 4.0 * po;\n    vec2 flo = floor(po);\n    vpo = fract(po);\n    vec3 mi1 = vec3(10.0);\n    float dist2, dist3;\n    \n    for(int i = -1; i <= 1; i++)\n    \tfor(int j = -1; j <= 1; j++)\n        {\n            vec2 po1 = vec2(float(i), float(j));\n            vec2 o = Hash(flo + po1);\n            vec2 v = po1 - vpo + (0.5 + 0.5 * sin(6.2831 * o + iTime));\n            float d = length(v);\n            \n            //use one closest point to ensure part;\n            //use two closest point to ensure one border;\n            //use three closest point to ensure two border and fix corner;\n            if(d < mi1.x)\n            {\n                dist3 = dist2;\n                vpo3 = vpo2;\n                \n              \tdist2 = mi1.x;\n                vpo2 = vpo1;\n                \n                mi1 = vec3(d, o);\n                vpo1 = v;\n            }\n            else if(d < dist2)\n            {\n                dist3 = dist2;\n                vpo3 = vpo2;\n                \n                dist2 = d;\n                vpo2 = v;\n            }\n            else if(d < dist3)\n            {\n                dist3 = d;\n                vpo3 = v;\n            }\n        }\n    return vec2(mi1.x, mi1.y + mi1.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 vpo, vpo1, vpo2, vpo3;\n\tvec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    vec2 cell = Veronoi(uv, vpo, vpo1, vpo2, vpo3);\n    \n//gray, no center and no border    \n#ifdef GRAY\t\n    float col = (0.5 + 0.5 * cos(cell.y * 6.0 + iTime));\n\n    col *= smoothstep(0.0, 0.15, cell.x);\t\t//black center\n\n    fragColor = vec4(col,col, col, 1.0);\n    \n#else\n    vec3 col = fract(vec3(sin(cell.y + iTime)) + vec3(0.8, 0.5, 0.1));\n    \n    float wi = 0.06;\n    \n    col *= smoothstep(0.0, 0.15, cell.x);\t\t//black center\n    \n    //border\n    float len1 = dot(0.5 * (vpo1 + vpo2), normalize(vpo2 - vpo1));\n    float len2 = dot(0.5 * (vpo1 + vpo3), normalize(vpo3 - vpo1));\n    float factor1 = smoothstep(0., wi, len1);\n    float factor2 = smoothstep(0., wi, len2);\n    col *=factor1*factor2;\n    \n    //corner\n    float c = 0.25;\n    float factor3 = smoothstep(0., wi, pow(len1,c)+pow(len2,c)-0.97);\n    col *= factor3;\n    \n\n            \n    fragColor = vec4(col, 1.0);\n    \n#endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldSBWV.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 16, 36, 36, 153], [155, 155, 204, 204, 564], [566, 611, 693, 693, 1901], [1903, 1903, 1960, 1960, 2962]]}
{"id": "llfcWr", "name": "The Ocean and the Sun", "author": "blinry", "description": "Experiments with fractal noise. Raymarched water surface.", "tags": ["sunset", "ocean", "fractalnoise"], "likes": 2, "viewed": 276, "date": "1504304658", "time_retrieved": "2024-06-20T19:00:47.380033", "image_code": "#define PI 3.14159\n#define EPSILON 0.0001\n#define MAX_DIST 100.0\n\nfloat rand2(vec2 co) {\n    float a = 12.9898;\n    float b = 78.233;\n    float c = 43758.5453;\n    float dt = dot(co.xy ,vec2(a,b));\n    float sn = mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float h1 = rand2(i)*sin(iTime+100000.0*rand2(i));\n    float h2 = rand2(i + vec2(1.0, 0.0))*sin(iTime+100000.0*rand2(i + vec2(1.0, 0.0)));\n    float h3 = rand2(i + vec2(1.0, 1.0))*sin(iTime+100000.0*rand2(i + vec2(1.0, 1.0)));\n    float h4 = rand2(i + vec2(0.0, 1.0))*sin(iTime+100000.0*rand2(i + vec2(0.0, 1.0)));\n\n    vec2 u = smoothstep(0.0, 1.0, f);\n\n    return mix(mix(h1, h2, u.x), mix(h4, h3, u.x), u.y);\n}\n\nfloat fbm(vec2 st) {\n    float value = 0.0;\n    float amplitude = 1.2;\n    for (int i=0; i<6; i++) {\n        value += amplitude*noise(st);\n        st *= 2.0;\n        amplitude *= 0.5;\n    }\n    return value;\n}\n\nfloat map(vec3 p) {\n    float h = fbm(p.zx*0.2);\n    return p.y-h;\n}\n\nfloat trace(vec3 o, vec3 r) {\n    float t = 0.1;\n    for (int i = 0; i < 64 ; i++) {\n        vec3 p = o + r*t;\n        float d = map(p);\n        if (d < 0.001*t || d > MAX_DIST) {\n            return t;\n        }\n        t += d*0.9;\n    }\n    return t;\n}\n\nfloat shadow(vec3 o, vec3 r) {\n    float t = 0.0;\n    float k = 16.0;\n    float res = 1.0;\n    for (int i = 0; i < 32 ; i++) {\n        vec3 p = o + r*t;\n        float d = map(p);\n        if (d < 0.001*t) {\n            return 0.0;\n        }\n        t += d*0.9;\n        res = min(res, k*d/t);\n    }\n    return res;\n}\n\nvec3 normal(vec3 p) {\n    return normalize(vec3(\n        map(vec3(p.x + EPSILON, p.y, p.z)) - map(vec3(p.x - EPSILON, p.y, p.z)),\n        map(vec3(p.x, p.y + EPSILON, p.z)) - map(vec3(p.x, p.y - EPSILON, p.z)),\n        map(vec3(p.x, p.y, p.z  + EPSILON)) - map(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 textur(vec3 p) {\n    return vec3(0.4,0.4,1.0)*(1.5+p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = 2.0*fragCoord.xy/iResolution.xy - vec2(1.0);\n    uv.x *= iResolution.x/iResolution.y;\n\n    float speed = 5.0;\n    float day = 0.5+0.5*sin(0.7*iTime);\n    float y = -1.0*cos(0.7*iTime);\n\n    vec3 light = vec3(100.0*y, 40.0*(day-0.5), 100.0+speed*iTime);\n\n    vec3 r = normalize(vec3(uv, 1.0));\n    vec3 o = vec3(0.0, 3.0, speed*iTime);\n    float t = trace(o, r);\n\n    vec3 c;\n\n    vec3 lightcolor = vec3(0.5-abs(0.5-day),0.5-(1.0-day),1.0-(1.0-day)*2.0);\n\n    if (t > MAX_DIST) {\n        c = lightcolor+vec3(0.7)*(0.5-r.y);\n        c *= 0.2+day;\n\n        float sun = 1.0-smoothstep(0.1, 0.3, length(uv - vec2(y, day-0.5)));\n        c += sun*0.8*vec3(1.0,1.0,1.0);\n\n        float star = 1.0-smoothstep(0.0, 0.1, length(fract(uv*10.0)+rand2(floor(uv*10.0))-uv*vec2(0.3,1.0)+vec2(-0.8,0.0)));\n        c += (1.0-smoothstep(0.0, 0.2, day))*star*vec3(1.0);\n    } else {\n        vec3 p = o+t*r;\n        vec3 n = normal(p);\n\n        vec3 r = r-2.0*dot(r,n)*n;\n\n        float specular = pow(dot(r,normalize(light-p)),40.0);\n\n        float s = shadow(p, normalize(light-p));\n\n        vec3 col = textur(p);\n\n        c = col*vec3(0.2*(0.5+day)+clamp((dot(n,normalize(light-p))),0.0,1.0)*s)+specular*lightcolor*(0.2+day);\n\n    }\n\n    fragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llfcWr.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[66, 66, 88, 88, 259], [261, 261, 283, 283, 749], [751, 751, 771, 771, 960], [962, 962, 981, 981, 1030], [1032, 1032, 1061, 1061, 1285], [1287, 1287, 1317, 1317, 1601], [1603, 1603, 1624, 1624, 1904], [1906, 1906, 1927, 1927, 1969], [1971, 1971, 2028, 2028, 3290]]}
{"id": "llfczj", "name": "black neons", "author": "balkhan", "description": "a negative lightning experiment", "tags": ["raymarch"], "likes": 5, "viewed": 167, "date": "1506623511", "time_retrieved": "2024-06-20T19:00:47.386130", "image_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n*/\n\n#define LPOS vec3(cos(t)*.8, sin(t)*.8, -t-1.5)\n#define I_MAX\t\t100\n#define E\t\t\t0.001\n\nvec4\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvoid\trotate(inout vec2 v, float angle);\nvec2\trot_t;\nvec3\th;\nvec3\tbase;\nvec3\tlight_pos;\nvec3\tlight_green = vec3(.5,.7,.4);\nvec3\tlight_blue = vec3(.1,.5,.7);\nvec3\tlight_red = vec3(.7,.2,.1);\nvec3\tuglob;\nfloat \tt;\n\nvoid mainImage(out vec4 c_out, in vec2 f)\n{\n    uglob*=0.;\n    vec3\tcol = vec3(0., 0., 0.);\n    vec2 R = iResolution.xy,\n          uv  = vec2(f-R/2.) / R.y;\n\tvec3\tdir = camera(uv);\n    vec3\tpos = vec3(-.0+cos(iTime*.5)*2., .0+sin(iTime*.5)*2., 1.0-iTime*.5);\n    t = iTime;\n\trot_t = vec2( cos(-t*.5)*.75, sin(-t*.5)*.75 );\n\n    dir.zx *= mat2(rot_t.x, rot_t.y, -rot_t.y, rot_t.x);\n    dir=normalize(dir);\n    vec4\tinter = (march(pos, dir));\n\n    col.xyz = (1.-inter.x*.0061251)-(1.-vec3(.125)*inter.w)*.5;\n    col.xyz += -h*.0053061251;\n\tcol.xyz += uglob*.75;\n    c_out =  vec4(col,1.0);\n}\n\nvec3 evaluateLight(in vec3 pos)\n{\n    vec3\tlightCol;\n    lightCol =\n        (mod(ceil(pos.y),3.)==1.?\n                light_blue\n               :\n                (mod(ceil(pos.y),3.)==2.?light_red:light_green)\n               )*.5;\n    \n    lightCol += \n        (mod(ceil(pos.x),3.)==1.?\n                light_blue\n               :\n                (mod(ceil(pos.x),3.)==2.?light_red:light_green)\n               )*.5;\n    \n    float distanceToL = \n        length(fract(pos.xy+light_pos.xy)-.5)-.025;\n\n    float\tdl = length(fract(pos.xy+light_pos.xy)-.5)-.025;;\n    vec3\to = fract(pos.xyz*15.+light_pos.xyz*15.)-.5;\n    float\tdl2 = max(max(max(abs(o.x), abs(o.y)), abs(o.z)) + .03, .0);\n\tvec3\tret = \n        max\n        (\n        lightCol * 5./(distanceToL*distanceToL)\n        ,\n    \tlightCol * 300.0/sqrt( (dl2-1.5*dl/(dl2)) )\n    )*.015;\n    dl = length(pos.xyz-LPOS);\n    uglob += .015*vec3(.2,.2,.9)*1./(dl*dl);\n    return ret;\n}\n\nfloat\tscene(vec3 p)\n{\n    vec3\top = p;\n    float\tmind = 1e5;\n    op = p;\n    \n    // \"star\" lattice\n    p.xy += .5;\n    p.xyz = fract(p.xyz*.5)-.5;\n    vec3 oo = abs(p);\n    vec3 o = p*p;\n    float s = sqrt(o.x+o.y);\n    s = min(s, sqrt(o.x+o.z));\n    s = min(s, sqrt(o.y+o.z));\n    mind = max(-(length(oo -(oo.x+oo.y+oo.z)/3. )-.3503125),s-0.45);\n\n    // cubic cylinder lattice\n    p = op;\n    p = fract(p)-.5;\n    o = p*p*p*p; // length4 square it a bit\n    s = pow(o.x+o.y,1./4.);\n    s = min(s, pow(o.x+o.z,1./4.));\n    s = min(s, pow(o.y+o.z,1./4.));\n    mind = min(mind, s-.025);\n\n    // cylinders for blacklight\n    p = op;\n    p.z += .52*t;\n    light_pos.xy = vec2(cos(p.z*4. ),sin(p.z*4. ))*.15;\n    p.xy = fract(p.xy)-.5;\n    p.z += .52*t;\n    p.xy+=light_pos.xy;\n    light_pos.z = p.z;\n\n    mind = min(mind, \n              length(p.xy)-.02501\n              );\n    \n    // positive light sphere\n\tmind = min(mind,\n               length(op-LPOS)-.0001\n               );\n    \n    return(mind);\n}\n\n\nvec4\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0, 0.0);\n    vec3\tp = vec3(0.0, 0.0, 0.0);\n    vec4\ts = vec4(0.0, 0.0, 0.0, 0.0);\n\n    for (int i = -1; i < I_MAX; ++i)\n    {\n    \tp = pos + dir * dist.y;\n        dist.x = scene(p);\n        dist.y += dist.x;\n        h += evaluateLight(p)*.5;\n        if (dist.x < E )\n        {\n            s.y = 1.;\n            break;\n        }\n        s.x++;\n    }\n    s.w = dist.y+dist.x;\n    return (s);\n}\n\n// Utilities\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec2\trot(vec2 p, vec2 ang)\n{\n\tfloat\tc = cos(ang.x);\n    float\ts = sin(ang.y);\n    mat2\tm = mat2(c, -s, s, c);\n    \n    return (p * m);\n}\n\n\nvec3 calcNormal( in vec3 pos, float e, vec3 dir)\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\n\treturn normalize(vec3(\n           march(pos+eps.xyy, dir).w - march(pos-eps.xyy, dir).w,\n           march(pos+eps.yxy, dir).w - march(pos-eps.yxy, dir).w,\n           march(pos+eps.yyx, dir).w - march(pos-eps.yyx, dir).w ));\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float\t\tfov = 1.;\n\tvec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llfczj.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 445, 488, 488, 1034], [1036, 1036, 1069, 1069, 1967], [1969, 1969, 1990, 1990, 2971], [2974, 2974, 3006, 3006, 3421], [3423, 3437, 3477, 3477, 3552], [3554, 3554, 3582, 3582, 3690], [3693, 3693, 3743, 3743, 4003], [4005, 4005, 4027, 4027, 4233]]}
{"id": "lllyD8", "name": "2d_sin", "author": "sgoal", "description": "2d_sin", "tags": ["2dsin"], "likes": 0, "viewed": 89, "date": "1504682923", "time_retrieved": "2024-06-20T19:00:47.386130", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n    uv.y = iResolution.y / iResolution.x * uv.y;\n    \n    vec4 color = vec4(1.);\n    \n    for(float i = -1.; i < +1. ; i += .1){\n    \tfloat line = smoothstep(0.,0.005,abs(uv.x - i));\n        color = mix(vec4(0.5),color,line);\n        \n        line = smoothstep(0.,0.005,abs(uv.y - i));\n        color = mix(vec4(.5),color,line);\n    }\n    \n    float axis = smoothstep(0.,0.01,abs(uv.x));\n    color = mix(vec4(.3),color,axis);\n    axis = smoothstep(0.,0.01,abs(uv.y));\n    color = mix(vec4(.3),color,axis);\n    \n    //float sinsin = smoothstep(0.,0.01,abs(.5 * sin(2. * 3.14 * uv.x + iGlobalTime) - uv.y));\n    float sinsin = smoothstep(0.,0.01,abs(.5 * sin(2. * 3.14 * uv.x + iTime) - uv.y) /\n                          sqrt(1.0 + .5*.5*6.2831*6.2831*cos(2. * 3.14 * uv.x + iTime)\n                          *cos(2. * 3.14 * uv.x + iTime)));\n    // float ft = abs(.5 * sin(2. * 3.14 * uv.x + iGlobalTime) - uv.y);\n    // float sinsin = smoothstep(0.,0.01,ft/fwidth(ft));\n    color = mix(vec4(.1),color,sinsin);\n    \n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lllyD8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 1147]]}
{"id": "lllyDB", "name": "Twin Shade B - torus (cloned) ", "author": "tgsstdio", "description": "Using Twin\n\nSEE Toon Shaded Torus (https://www.shadertoy.com/view/ll33Wn) for source of torus/edge detection/camera stuff (95% of code is from here)\n\nMY CHANGES due to diffuse toon shading with twin shade (duo-shade)\nhttps://www.shadertoy.com/view/lllyDS\n", "tags": ["toon"], "likes": 1, "viewed": 252, "date": "1506316590", "time_retrieved": "2024-06-20T19:00:47.386130", "image_code": "// USE ANY CUTOFF VALUES YOU LIKE. \n\n#define LIGHT_SHADE_CUTOFF 0.33\n#define DARK_SHADE_CUTOFF 0.15\nconst vec3 TORUS_COLOR = vec3(1.0, 0.5, 0.1);\n\n/// FORK of https://www.shadertoy.com/view/ll33Wn (95% of code is from here)\n/// MY CHANGES due to diffuse toon shading\n\n#define EPSILON 0.0001\n#define MAX_STEPS 500\n#define MIN_DIST 0.0\n#define MAX_DIST 25.0\n\n#define AMBIENT 0.1\n#define EDGE_THICKNESS 0.015\n#define SHADES 4.0\n\nfloat TorusSDF(vec3 samplePoint, vec2 dimensions)\n{\n\treturn length( vec2(length(samplePoint.xz)-dimensions.x,samplePoint.y) )-dimensions.y;\n}\n\nfloat SceneSDF(vec3 samplePoint)\n{\n    return TorusSDF(samplePoint, vec2(1.3, 0.45));\n}\n\nfloat March(vec3 origin, vec3 direction, float start, float stop, inout float edgeLength)\n{\n    float depth = start;\n    \n    for\t(int i = 0; i < MAX_STEPS; i++)\n    {\n        float dist = SceneSDF(origin + (depth * direction)); // Grab min step\n        edgeLength = min(dist, edgeLength);\n        \n        if (dist < EPSILON) // Hit\n            return depth;\n        \n        if (dist > edgeLength && edgeLength <= EDGE_THICKNESS ) // Edge hit\n            return 0.0;\n        \n        depth += dist; // Step\n        \n        if (depth >= stop) // Reached max\n            break;\n    }\n    \n    return stop;\n}\n\nvec3 RayDirection(float fov, vec2 size, vec2 fragCoord)\n{\n    vec2 xy = fragCoord - (size / 2.0);\n    float z = size.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 EstimateNormal(vec3 point)\n{\n    return normalize(vec3(SceneSDF(vec3(point.x + EPSILON, point.y, point.z)) - SceneSDF(vec3(point.x - EPSILON, point.y, point.z)),\n                          SceneSDF(vec3(point.x, point.y + EPSILON, point.z)) - SceneSDF(vec3(point.x, point.y - EPSILON, point.z)),\n                          SceneSDF(vec3(point.x, point.y, point.z + EPSILON)) - SceneSDF(vec3(point.x, point.y, point.z - EPSILON))));\n}\n\nmat4 LookAt(vec3 camera, vec3 target, vec3 up)\n{\n    vec3 f = normalize(target - camera);\n    vec3 s = cross(f, up);\n    vec3 u = cross(s, f);\n    \n    return mat4(vec4(s, 0.0),\n        \t\tvec4(u, 0.0),\n        \t\tvec4(-f, 0.0),\n        \t\tvec4(0.0, 0.0, 0.0, 1));\n}\n\n// NEW CODE HERE (START)\n// ORIGINAL https://www.shadertoy.com/view/XtscWS\nconst mat4 lightB2 = mat4(\n    251,166,10,165,\n    142,9,212,250,\n    7,165,250,168,\n    220,250,142,4\n)/255.;\n\nvec4 lightColorB2(vec2 fragCoord)\n{        \n    ivec2 gridPos = ivec2(fragCoord) % 4;         \n\n    float factor = lightB2[gridPos.x][3 - gridPos.y];\n\n    return vec4(vec3(factor), 1.);\n}\n\n// DARK TONE\n// diffs at [1][3], [3][1] with value of 8/255.\nconst mat4 darkB2 = mat4(\n    251,166,10,165,\n    142,9,212,8,\n    7,165,250,168,\n    220,8,142,4\n)/255.;\n    \nvec4 darkColorB(vec2 fragCoord)\n{        \n    ivec2 gridPos = ivec2(fragCoord) % 4;         \n\n    float factor = darkB2[gridPos.x][3 - gridPos.y];\n\n    return vec4(vec3(factor), 1.);\n}\n\nvec3 ComputeLighting(vec3 point, vec2 fragCoord, vec3 lightDir, vec3 lightColor)\n{\n    vec3 color = vec3(AMBIENT);\n    float diffuse = dot(EstimateNormal(point), normalize(lightDir));\n    float colorIntensity = ceil(diffuse * SHADES) / SHADES;\n    colorIntensity = max(colorIntensity, AMBIENT);    \n   \n    if (diffuse >= LIGHT_SHADE_CUTOFF)        \n    \tcolor = lightColor * colorIntensity;\n    else if (diffuse >= DARK_SHADE_CUTOFF) \n        color = colorIntensity * (lightColor * lightColorB2(fragCoord).xyz);\n    else\n        color = colorIntensity * (lightColor * darkColorB(fragCoord).xyz);\n    return color;\n}\n\n// NEW CODE HERE (END)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 viewDir = RayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 origin = vec3(sin(iTime) * 9.0, (sin(iTime * 2.0) * 4.0) + 6.0, cos(iTime) * 9.0);\n    mat4 viewTransform = LookAt(origin, vec3(0.0), vec3(0.0, 1.0, 0.0));\n    viewDir = (viewTransform * vec4(viewDir, 0.0)).xyz;\n    \n    float edgeLength = MAX_DIST;\n    float dist = March(origin, viewDir, MIN_DIST, MAX_DIST, edgeLength);\n    \n    if (dist > MAX_DIST - EPSILON) // No hit\n    {\n        fragColor = vec4(0.6);\n        return;\n    }\n    \n    if (dist < EPSILON) // Edge hit\n    {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    vec3 hitPoint = origin + (dist * viewDir);\n    vec3 lightDir = vec3(sin(iTime * 2.0) * 6.0, 4.0, sin(iTime * 1.25) * 5.0);\n   \n    vec3 color = ComputeLighting(hitPoint, fragCoord, lightDir, TORUS_COLOR);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lllyDB.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[147, 426, 477, 477, 567], [569, 569, 603, 603, 656], [658, 658, 749, 749, 1266], [1268, 1268, 1325, 1325, 1451], [1453, 1453, 1486, 1486, 1889], [1891, 1891, 1939, 1939, 2154], [2156, 2343, 2378, 2378, 2530], [2532, 2704, 2737, 2737, 2888], [2890, 2890, 2972, 2972, 3506], [3508, 3532, 3589, 3589, 4451]]}
{"id": "lllyR2", "name": "Signal progression", "author": "pohar", "description": "4k intro with sdf", "tags": ["in4k"], "likes": 1, "viewed": 92, "date": "1505597977", "time_retrieved": "2024-06-20T19:00:48.731688", "image_code": "#define PI 3.14159265\n#define EPSILON 0.00001\n\nvec3 ambientColor = vec3(0.2, 0.2, 0.2);\nvec3 diffuseColor = vec3(0.2, 0.6, 0.8);\nvec3 specularColor = vec3(1.0, 1.0, 1.0);\nvec3 lightDir = normalize(vec3(0.0, 4.0, 5.0));\nbool mode2d;\n\nvec3 mymod(vec3 p, vec3 m)\n{\n    return mod(p,m)-m/2.;\n}\n\n// https://commons.wikimedia.org/wiki/File:Dynamical_plane_with_Julia_set_for_c%3D0.35_with_binary_decomposition.png#cite_note-1\n\n// compute color of pixel\nfloat color(vec2 z, float time) \n{\n    const int iMax=100;\n    vec2 c = vec2(0.35+sin(time/3.33)*0.7,0.0+sin(time/2.0));  // initial value\n    float er2 = 10000.0;\n\n    // iteration\n    for ( int i = 0; i < iMax; i++) \n    {\n        z = vec2(z.x*z.x-z.y*z.y,2.0*z.x*z.y) +  c; // z= z^2+c\n        if (dot(z,z)> er2)   // escape test \n            // exterior\n            if (z.x>0.0)\n            { \n                return (float(i)/1000.);\n            } // upper part of the target set \n       \t\telse \n                return (0.); //false; //lower part of the target set \n    }\n    return (0.); //false; //interior\n}\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( (2.0*PI)*(c*t+d) );\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float height) \n{\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.0*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.0)) c = abs(c);\n\treturn c;\n}\nvec3 myFold(vec3 z)\n{  \n    if(z.x+z.y<0.) z.xy = -z.yx; // fold 1\n    if(z.x+z.z<0.) z.xz = -z.zx; // fold 2\n    if(z.y+z.z<0.) z.zy = -z.yz; // fold 3\n    \n    return z;\n}\n\nvec3 twist(vec3 p, float tw)\n{\n    float c = cos(tw);\n    float s = sin(tw);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    \n    return q;\n}\n\nvec3 rotX(vec3 p, float a)\n{\n    mat3 rot = mat3(1.,0.,0.,\n                    0., cos(a), -sin(a),\n                   0., sin(a), cos(a));\n    return p * rot;\n}\n\nvec3 rotZ(vec3 p, float a)\n{\n    mat3 rot = mat3(cos(a), 0., sin(a),\n        \t\t\t0., 1., 0.,\n                   -sin(a), 0., cos(a));\n    return p * rot;\n}\n\nvec3 rotY(vec3 p, float a)\n{\n    mat3 rot = mat3(cos(a), -sin(a), 0.,\n                    sin(a), cos(a), 0.,\n        \t\t\t0., 0., 1. \n                   );\n    return p * rot;\n}\n\n// octohedron\nfloat so(vec3 p,float s) { \n     return dot(p,normalize(sign(p+1e-6)))-s;\n}\n\n//Chamfered box\nfloat sbc(vec3 p,vec3 d,float c, float w) {\n    p=max(abs(p)-d, w);\n    return so(p,c);\n}\n\nfloat myshape(vec3 p,vec3 d,float c, float w) {\n    p=max(abs(p)-d, w);   \n    return so(p, c);\n}\n\nfloat map3(vec3 p)\n{\n    float d;\n    d =       myshape(rotZ(rotY(p  - vec3(-1.0, 0., 2.),iTime/2.),iTime/3.), vec3(0.4,  .2, 0.2 ), 0.25, 0. );\n    d = min(d,myshape(rotX(rotZ(p  - vec3( 0.0, 0., 3.),iTime/4.),iTime/1.), vec3(0.15, .3, 0.15), 0.2 , 0.1));\n    d = min(d,myshape(rotX(rotY(p  - vec3( 1.0, 0., 2.),iTime/3.),iTime/2.), vec3(0.15, .4, 0.15), 0.2 ,-0.10));\n    \n    return d;\n}\n\nfloat map4(vec3 p)\n{\n    return sdSphere(mymod(p, vec3(2.)), 0.5);\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        map3(vec3(p.x + EPSILON, p.y, p.z) ),\n        map3(vec3(p.x, p.y + EPSILON, p.z) ),\n        map3(vec3(p.x, p.y, p.z  + EPSILON) )\n    ));\n}\n\nvec4 ChamferedBoxes(vec2 uv)\n{\n    vec3 ro = vec3(0.);\n    vec3 rd = normalize(vec3(2.*uv.x-1., 1.33*uv.y-0.66, 1.));\n    vec3 color;\n    vec4 fragColor = vec4(0.);\n    float t = 0.;\n    for(int i=0; i<130 && t<40.; ++i)\n    {\n        vec3 p = ro + t * rd;\n        float d = map3(p);\n        if(d<EPSILON)\n        {\n            vec3 norm = estimateNormal(p);\n\n            float occ = 0.5 + 0.5 * norm.y;\n\n            float amb = clamp(0.5 + 0.5 * norm.y, 0.0, 1.0);\n            float dif = clamp(dot(lightDir, norm), 0.0, 1.0);\n\n            vec3 h = normalize(-rd + lightDir);\n            float spe = pow(clamp(dot(h, norm), 0.0, 1.0), 64.0);\n\n            diffuseColor = vec3(map4(p+norm));\n            color = amb * ambientColor\n             + dif * (diffuseColor + spe * specularColor) ;\n            \n            fragColor = vec4(vec3(1.)-(color * occ),1.);\n            \n           break;\n        }\n        t += d;\n    }\n    \n    return fragColor;\n}\n\nfloat map(in vec3 p, in float time)\n{   \n\tvec3 q = time>80.0?myFold(twist(p,time)):twist(p,time);\n    float c = pModPolar(q.xy,8.0);\n    /*\n    if(c<-1.0)\n        return 0.0;\n    */\n\tfloat d = sdBox(mymod(q,vec3(1.0)),vec3(0.5*sin(time*3.33)+0.5,0.3,0.2));\n\n\tq.yz+=0.5*sin(-time*3.0);\n    d = min(d,sdSphere(mymod(q,vec3(1.0)),0.1));\n\n    if(!mode2d)\n    {\n\t\tpModPolar(q.zy,4.0);\n\t\td = min(d,fCylinder(mymod(q.yzx,vec3(1.0)),0.05,1.1));\n    } \n\treturn d;\n}\n/*\nvec3 getNormal(vec3 p, float eps) \n{\n    vec3 n;\n    n.y = map(p);\n    n.x = map(vec3(p.x+eps,p.y,p.z)) - n.y;\n    n.z = map(vec3(p.x,p.y,p.z+eps)) - n.y;\n    n.y = eps;\n    return normalize(n);\n}\n*/\n\nvec4 trace(in vec3 rs, in vec3 rd, in float time)\n{\n    const float EPSILON_NRM = 0.1 / 1280.0;\n    vec4 ret=vec4(0.0);\n    float t = 0.0;\n    const int maxSteps = 30;\n    for(int i = 0; i < maxSteps ; ++i)\n    {\n        vec3 p = rs + normalize(rd) * t;\n        float d = map(p, time);\n        if(d < 0.000001 )\n        {\n            ret = vec4(palette(abs(d+1.0*p.z),vec3(0.5, 0.5, 0.5),vec3(0.5, 0.5, 0.5),vec3(1.0, 0.7, 0.4),vec3(0.00, 0.15, 0.20)),1.);\n            break;\n        }\n        t += d*1.0;\n    }\n\n    return ret;\n}\n\nvoid  mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    fragColor.a = 0.0;\n    float myTime = iTime*1.0;\n    \n    //  camera    \n    vec3 dir = normalize(vec3(2.*gl_FragCoord.xy -iResolution.xy, 0.8*iResolution.y));\n    vec3 org = vec3(0.,0.,myTime);\n    \n    /*if(myTime<20.0)\n    {\n        vec2 uv = fragCoord/iResolution.xy;\n        fragColor = ChamferedBoxes(uv);\n    }      \n    \n    if(fragColor.a == 0.0)*/\n    { \n        mode2d = (myTime<30.0) || (fract(myTime/10.0)<0.5);\n\n        fragColor = trace(org, twist(mode2d?dir:dir.xzy,myTime*0.5), myTime);\n        float bindecomp = 0.0; // color(dir.xy, myTime);\n        if((myTime>6.0) && bindecomp > 0.0)\n        {\n            fragColor.rgb = vec3(1.)-fragColor.rgb;\n            fragColor.a = bindecomp;\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lllyR2.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[233, 233, 261, 261, 289], [421, 447, 481, 481, 1062], [1064, 1064, 1136, 1136, 1180], [1182, 1182, 1217, 1217, 1241], [1243, 1288, 1337, 1337, 1411], [1413, 1413, 1444, 1444, 1531], [1533, 1533, 1583, 1583, 1975], [1976, 1976, 1997, 1997, 2149], [2151, 2151, 2181, 2181, 2310], [2312, 2312, 2340, 2340, 2473], [2475, 2475, 2503, 2503, 2629], [2631, 2631, 2659, 2659, 2807], [2809, 2823, 2849, 2849, 2898], [2900, 2916, 2959, 2959, 3005], [3007, 3007, 3054, 3054, 3104], [3106, 3106, 3126, 3126, 3496], [3498, 3498, 3518, 3518, 3566], [3568, 3568, 3597, 3597, 3772], [3774, 3774, 3804, 3804, 4725], [4727, 4727, 4764, 4764, 5183], [5184, 5388, 5439, 5439, 5918], [5920, 5920, 5975, 5975, 6701]]}
{"id": "lllyWr", "name": "lighting practice", "author": "Torumu106", "description": "light", "tags": ["light"], "likes": 0, "viewed": 57, "date": "1504442384", "time_retrieved": "2024-06-20T19:00:48.731688", "image_code": "float PI = 3.1415926535;\nint stop = 0;\nvec3 col = vec3(1.0, 1.0, 1.0);\nvec3 stoppos = vec3(0.0);\nbool shadow = false;\nfloat map(vec3 p){\n    float d = length(p) - 1.0;\n    if(d < 0.001) stop = 1;\n    if(!shadow)\n    \td = min(d, dot(p,vec3(0.0, 1.0, 0.0)) + 1.0);\n    if(d < 0.001 && stop != 1) stop = 2;\n    return d;\n}\nfloat trace(vec3 o, vec3 r){\n\tfloat t = 0.0;\n    vec3 p;\n    for(int i = 0; i < 128; ++i){\n    \tp = o + r * t;\n        float d = map(p);\n        if(d < 0.001){\n        \tbreak;\n        }\n        t += d * 0.9;\n    }\n    stoppos = p;\n    return t;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 r = normalize(vec3(uv - vec2(0.0, PI / 3.0), 1.0));\n    \n    float the = iTime;\n    vec3 o = vec3(0.0,10.0, -10.0);\n    r.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    o.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    \n    float t = trace(o, r);\n    \n    float light;\n    if(stop == 1) light =0.9 * max(dot(normalize(vec3(1.0)), normalize(stoppos)), 0.0) + 0.1;\n    else if(stop == 2) {\n    \tstop = 0;\n        shadow = true;\n        trace(stoppos, normalize(vec3(1.0)));\n        if(stop == 1) light = 0.1;\n        else light = 0.8;\n    }\n    else light = 0.0;\n    \n    vec3 fc = vec3(light) * col;\n    fragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lllyWr.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[118, 118, 136, 136, 319], [320, 320, 348, 348, 566], [567, 567, 624, 624, 1393]]}
{"id": "llscW4", "name": "Concentric Sawtooth Gradients", "author": "FlexMonkey", "description": "A little homage to Zach Lieberman's work :)\n\nBest in Chrome. \n", "tags": ["2d", "circles", "sawtooth"], "likes": 5, "viewed": 116, "date": "1504897324", "time_retrieved": "2024-06-20T19:00:48.731688", "image_code": "/*\n\tSimon Gladman | September 2017\n*/\n\nconst float stepWidth = 25.0; \n\nstruct HeightColorPair {\n    vec3 color;\n    float height; \n};\n    \nHeightColorPair sawtoothGradient(vec2 uv, vec2 offset, vec3 color) {\n    float len = length(uv - offset); \n    float value = len * stepWidth ;\n    value = smoothstep(0.0, 1.0, abs(mod(value, 1.0))) * 0.5; \n    value += 0.5;\n    value *= 1.0 - pow(len, 0.4);\n    \n    float height = 1.0 - floor(len * stepWidth) / stepWidth;\n    \n    return HeightColorPair(value * color, height); \n}\n\nHeightColorPair topHeightColor(HeightColorPair a, HeightColorPair b) {\n    HeightColorPair result = a;\n    \n    if (b.height > a.height) {\n     \tresult = b;   \n    }\n    \n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n\tvec2 uv = (fragCoord.xy / iResolution.xy) - 0.5;\n    \n    float aRadius = (sin(iTime * 0.5) * 0.25) + 0.25; \n\tHeightColorPair a = sawtoothGradient(uv, \n                                         vec2(cos(iTime) * aRadius, \n                                              sin(iTime) * aRadius),\n                                         vec3(1.0, 1.0, 0.0));\n    \n    float bRadius = (sin(iTime * 0.75) * 0.1) + 0.4; \n    HeightColorPair b = sawtoothGradient(uv, \n                                         vec2(sin(iTime * 0.3) * bRadius, \n                                              cos(iTime * 0.3) * bRadius),\n                                         vec3(0.0, 1.0, 1.0));\n    \n    float cRadius = (cos(iTime * 0.25) * 0.3) + 0.1; \n    HeightColorPair c = sawtoothGradient(uv, \n                                         vec2(sin(iTime * 0.7) * cRadius, \n                                              cos(iTime * 0.7) * cRadius),\n                                         vec3(1.0, 0.0, 1.0));\n    \n    vec3 color = topHeightColor(topHeightColor(a, b), c).color;  \n    \n    fragColor = vec4(color ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llscW4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 139, 207, 207, 521], [523, 523, 593, 593, 714], [716, 716, 773, 773, 1880]]}
{"id": "llscW7", "name": "Procedural Globe", "author": "PrzemyslawZaworski", "description": "Full procedural hypsometric globe. \nYou can set another map -> change float value in line 5\nYou can set antialiasing level -> line 7\nYou can rotate globe manually -> press left mouse button", "tags": ["procedural", "3d", "mouse", "raycasting", "fbm", "texture", "beginner", "perlin", "sphere", "planet", "map", "projection", "mapping", "globe", "cartography"], "likes": 22, "viewed": 1297, "date": "1505153515", "time_retrieved": "2024-06-20T19:00:49.428886", "image_code": "//Author: Przemyslaw Zaworski, 12.09.2017, version 1.1\n//License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nfloat generate_map = 50.0;\n\nconst int ssaa=4;\n\nmat2 rotation(float x)\n{\n    return mat2(cos(x),-sin(x),sin(x),cos(x));\n}\n\nfloat noise (vec3 n) \n{ \n\treturn fract(sin(dot(n, vec3(95.43583, 93.323197, 94.993431))) * 65536.32);\n}\n\nfloat perlin_a (vec3 n)\n{\n    vec3 x = floor(n * 64.0) * 0.015625;\n    vec3 k = vec3(0.015625, 0.0, 0.0);\n    float a = noise(x);\n    float b = noise(x + k.xyy);\n    float c = noise(x + k.yxy);\n    float d = noise(x + k.xxy);\n    vec3 p = (n - x) * 64.0;\n    float u = mix(a, b, p.x);\n    float v = mix(c, d, p.x);\n    return mix(u,v,p.y);\n}\n\nfloat perlin_b (vec3 n)\n{\n    vec3 base = vec3(n.x, n.y, floor(n.z * 64.0) * 0.015625);\n    vec3 dd = vec3(0.015625, 0.0, 0.0);\n    vec3 p = (n - base) *  64.0;\n    float front = perlin_a(base + dd.yyy);\n    float back = perlin_a(base + dd.yyx);\n    return mix(front, back, p.z);\n}\n\nfloat fbm(vec3 n)\n{\n    float t = 0.0;\n    float a = 1.0;\n    float b = 0.1;\n    for (int i = 0; i < 5; i++)\n    {\n        t += perlin_b(n * a) * b;\n        a *= 0.5;\n        b *= 2.0;\n    }\n    return t;\n}\n\nvec3 heightmap (vec3 n)\n{\n\treturn vec3(fbm((5.0 * n) + fbm((5.0 * n) * 3.0 - 1000.0) * 0.05),0,0);\n}\n\nvec3 grid(vec2 p)\n{\n    return vec3(1.0)*smoothstep(0.99,1.0,max(sin((p.x)*20.0),sin((p.y)*20.0)));\n}\n\nfloat sphere(vec3 ro, vec3 rd)\n{\n    float b = dot(ro,rd);\n    float c = dot(ro,ro)-1.0;\n    float h = b*b-c;\n    return (h<0.0)?-1.0:-b-sqrt(h);\n}\n\nvec3 atlas(vec2 uv)\n{    \n \tfloat color = clamp(vec4(vec3((heightmap(vec3(uv*5.0,generate_map)*0.02)-1.0)),1.0).r,0.0,1.0);\n    return \n    color<0.10 ? vec3(0.77,0.90,0.98):\n    color<0.20 ? vec3(0.82,0.92,0.99):\n    color<0.30 ? vec3(0.91,0.97,0.99):\n    color<0.55 ? vec3(0.62,0.75,0.59):\n    color<0.65 ? vec3(0.86,0.90,0.68):\n    color<0.75 ? vec3(0.99,0.99,0.63):\n    color<0.85 ? vec3(0.99,0.83,0.59):\n    color<0.95 ? vec3(0.98,0.71,0.49):     \n    color<0.99 ? vec3(0.98,0.57,0.47):              \n    vec3(0.79,0.48,0.43); \n}\n\nvec3 raycast (vec3 ro, vec3 rd, vec2 p)\n{\n    float t = sphere(ro,rd);\n    if (t > 0.0)\n    {\n    \tvec3 d = ro+rd*t;\n        p=vec2(acos(d.y/length(d)), atan(d.z,d.x));  \n        return (atlas(p).xyz+grid(p*3.0));        \n    } \n    return 1.7-vec3(length(p));;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec3 c = vec3(0.0);\n\tfor (int m=0;m<ssaa;m++)\n\t{\n\t\tfor (int n=0;n<ssaa;n++)\n\t\t{\n\t\t\tvec2 offset = vec2(float(m),float(n))/float(ssaa)-0.5;\n\t\t\tvec2 p = (fragCoord.xy+offset.xy)/iResolution.xy-0.5;\t\n            p.x*=iResolution.x/iResolution.y;\n            vec2 m = iMouse.xy / iResolution.xy-0.5;\n            m.x *= iResolution.x/iResolution.y;\n            p*= 1.5;\n            vec3 ro = vec3(0.0,0.0,2.4);\n            vec3 rd = normalize(vec3(p,-1.5));\n            mat2 rx = rotation(iTime*0.4+m.x*5.0);\n            ro.xz *= rx; rd.xz *= rx;  \n\t\t\tc+=raycast(ro,rd,p);\n\t\t}\n\t}\n\tc=c/float(ssaa*ssaa);    \n\tfragColor = vec4(c, 1.0);\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llscW7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 190, 214, 214, 263], [265, 265, 288, 288, 368], [370, 370, 395, 395, 711], [713, 713, 738, 738, 994], [996, 996, 1015, 1015, 1202], [1204, 1204, 1229, 1229, 1304], [1306, 1306, 1325, 1325, 1407], [1409, 1409, 1441, 1441, 1556], [1558, 1558, 1579, 1579, 2092], [2094, 2094, 2135, 2135, 2357], [2359, 2359, 2416, 2416, 3048]]}
{"id": "llsczf", "name": "Domain Warp Planet", "author": "dmemes", "description": "planet with domain warped noise for heights, and an inscattering atmosphere.", "tags": ["noise", "planet", "domainwarp"], "likes": 8, "viewed": 254, "date": "1506042681", "time_retrieved": "2024-06-20T19:00:50.689420", "image_code": "const vec3 lightDirection = normalize(vec3(-.5, -.1, 0.0));\nconst vec3 betaR = vec3(.38, 1.35, 3.31);\nconst vec3 betaM = vec3(2.1);\n\n#define ATMOSPHERE 1\n\n#define innerRadius 1.0\n#define atmoRadius 1.175\n#define waterLevel .45\n\n#define Hr .1332333\n#define Hm .02\n#define g .76\n\n#define PI 3.14159265359\n#define gamma 2.2\n#define invgamma 1.0 / gamma\n\n#define hash(a) fract(sin(a)*12345.0) \nfloat noise(vec3 x, float c1, float c2) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*c2+ c1*p.z;\n    return mix(\n        mix(\n            mix(hash(n+0.0),hash(n+1.0),f.x),\n            mix(hash(n+c2),hash(n+c2+1.0),f.x),\n            f.y),\n        mix(\n            mix(hash(n+c1),hash(n+c1+1.0),f.x),\n            mix(hash(n+c1+c2),hash(n+c1+c2+1.0),f.x),\n            f.y),\n        f.z);\n}\nfloat noise(vec3 p){\n\n\tfloat a = noise(p, 883.0, 971.0);\n\tfloat b = noise(p + 0.5, 113.0, 157.0);\n\treturn (a + b) * 0.5;\n}\nfloat map4( in vec3 p ) {\n\tfloat f;\n    f  = 0.50000*noise( p ); p = p*2.02;\n    f += 0.25000*noise( p ); p = p*2.03;\n    f += 0.12500*noise( p ); p = p*2.01;\n    f += 0.06250*noise( p );\n\treturn clamp(f, 0.0, 1.0);\n}\n\nfloat height(vec3 dir){\n    float h;\n    \n    if (abs(dir.y) > innerRadius * .9){\n        dir += 10.0;\n        h = map4(dir * 3.0+ map4(dir * 5.0) * (sin(iTime)*.5+.5)*1.5);\n        h = clamp(h + waterLevel * .2, 0.0, 1.0);\n    }else\n        h = map4(dir * 3.0+ map4(dir * 5.0) * (sin(iTime)*.5+.5)*1.5);\n    \n\treturn h;\n}\n\nvec2 map(vec3 pos){\n    float l = length(pos);\n    float h = height(pos / l);\n    float rh = max(.45, h);\n\treturn vec2(l - (1.0 + .2 * rh), h);\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nvec3 getGroundColor(vec3 pos, float h){\n    vec3 normal = calcNormal(pos);\n    float light = clamp(dot(-lightDirection, normal), 0.0, 1.0);\n    \n    float n = dot(normal, normalize(pos));\n    \n    light += pow(normal.y * .5 + .5, 2.0) * .01; // ambient\n    \n    vec3 col = vec3(0.0);\n    \n    float l = h - waterLevel;\n    if (l < 0.0)\n        // water\n    \tcol = mix(vec3(0.3, 0.6, 1.0), vec3(0.0, 0.0, 1.0), clamp(pow(-l*25.0, 3.0), 0.0, 1.0));\n    else{\n        // land\n        \n        // poles\n        if (abs(pos.y) > innerRadius * .9)\n            col = vec3(1.0);\n        else{\n            if (l < 0.02)\n                col = vec3(0.9, 0.85, 0.8); // sand\n            else if (l < .2){\n                if (n < .95)\n                    col = vec3(.2, .2, .2); // rock\n                else\n                    col = vec3(0.0, 0.55, 0.02); // grass\n            } else{\n                if (n < .95)\n                    col = vec3(.2); // rock\n                else\n                    col = vec3(1.0); // snow\n            }\n        }\n    }\n    \n    return col * light;\n}\n\nvec2 raySphere(in vec3 ro, in vec3 rd, in float rad) {\n\tfloat b = 2.0 * dot(ro, rd);\n    float c = dot(ro,ro) - rad*rad;\n    float det = b*b - 4.0 * c;\n    if (det > 0.0){\n        det = sqrt(det);\n    \treturn vec2(0.5 * (-b - det), 0.5 * (-b + det));\n    }\n    return vec2(-1.0, -1.0);\n}\n\nvec3 sampleAtmosphere(vec3 ro, vec3 rd, float start, float end){\n\tfloat scale = 1.0 / (atmoRadius - innerRadius);\n    \n    vec3 sumR = vec3(0.0);\n    vec3 sumM = vec3(0.0);\n    float odr = 0.0;\n    float odm = 0.0;\n    \n\tfloat mu = dot(rd, -lightDirection);\n\tfloat phaseM = 3.0 / (8.0 * PI) * ((1.0 - g * g) * (1.0 + mu * mu)) / ((2.0 + g*g) * pow(1.0f + g*g - 2.0 * g * mu, 1.5));\n\tfloat phaseR = 3.0 / (16.0 * PI) * (1.0 + mu * mu);\n    \n    float t = start;\n    float slength = (end - start) * (1.0 / 6.0);\n    float scaledLength = (end - start) * scale;\n    vec3 pos;\n    for (int i = 0; i < 6; i++){\n        pos = ro + rd * t;\n        \n        float h = (length(pos) - innerRadius) * scale;\n        \n        float r = exp(-h / Hr) * scaledLength;\n        float m = exp(-h / Hm) * scaledLength;\n        odr += r;\n        odm += m;\n        \n        float lodr = 0.0;\n        float lodm = 0.0;\n        float lt = 0.0;\n        vec2 li = raySphere(pos, -lightDirection, atmoRadius);\n        float llength = max(li.x, li.y) * .25;\n        float scaledllength = llength * scale;\n        bool f = true;\n        \n        for (int i = 0; i < 4; i++){\n            vec3 lpos = pos + -lightDirection * lt;\n            if (map(lpos).x < 0.0) { f = false; break; }\n            \n            float lh = (length(lpos) - innerRadius) * scale;\n            float lr = exp(-lh / Hr) * scaledllength;\n            float lm = exp(-lh / Hm) * scaledllength;\n            lodr += lr;\n            lodm += lm;\n            lt += llength;\n        }\n        if (f) {\n        \tvec3 tau = betaR * (odr + lodr) + betaM * 1.1 * (odm + lodm);\n            vec3 atten = exp(-tau);\n            sumR += atten * r;\n            sumM += atten * m;\n        }\n        \n        t += slength;\n    }\n    \n    return 20.0 * (sumR * betaR * phaseR + sumM * betaM * phaseM);\n}\n\nvec3 march(vec3 ro, vec3 rd){\n    vec2 ray = raySphere(ro, rd, atmoRadius);\n    if (ray.x < 0.0 && ray.y < 0.0) return vec3(0.0);\n    \n    float start = min(ray.x, ray.y);\n    float end = max(ray.x, ray.y);\n    \n    vec3 color = vec3(0.0);\n    \n    float t = start;\n    vec2 d;\n    vec3 pos;\n  \tvec2 ld = vec2(1000.0, 1.0);\n    for (int i = 0; i < 100; i++){\n        pos = ro + rd * t;\n        d = map(pos);\n        \n        if (d.x > ld.x && d.x > atmoRadius){\n            // getting farther away, and outside the planet, exit early\n            break;\n        }\n        \n        if (d.x < 0.0){\n            // hit the ground, sample ground color, blend atmo color\n            color = getGroundColor(pos, d.y);\n            end = t;\n            break;\n        }\n        \n        ld = d;\n        t += max(d.x * .5, .01);\n    }\n    \n    vec3 atmo = vec3(0.0);\n    #if ATMOSPHERE\n    atmo = sampleAtmosphere(ro, rd, start, end);\n    #endif\n    return color * (vec3(1.0) - atmo) + atmo;\n}\n\nvec3 tonemap(vec3 color)\n{\n\tfloat white = 2.;\n\tfloat luma = dot(color, vec3(0.2126, 0.7152, 0.0722));\n\tfloat toneMappedLuma = (1. + luma / (white*white)) / (1. + luma);\n\treturn pow(color * toneMappedLuma, vec3(invgamma));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 dir = vec3((uv.x - .5), (uv.y - .5) * iResolution.y / iResolution.x, 1.0);\n    \n    dir = normalize(dir);\n    \n    float t = -PI * 2.0 * iMouse.x / iResolution.x + PI;\n    \n    vec3 campos = vec3(sin(t), 0.0, cos(t)) * (4.0 * (1.0 - (iMouse.y / iResolution.y)) + atmoRadius*1.1);\n    vec3 right = vec3(sin(t + PI * .5), 0.0, cos(t + PI * .5));\n    vec3 fwd = normalize(-campos);\n    \n    vec3 color = march(campos, normalize(right * dir.x + fwd * dir.z + vec3(0.0, dir.y, 0.0)));\n    \n    color = tonemap(color);\n    \n    fragColor = vec4(color, 1.0);\n}\n\nvoid mainVR(out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir ) {\n    vec3 color = march(fragRayOri, fragRayDir);\n    \n    color = tonemap(color);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llsczf.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[390, 390, 431, 431, 828], [829, 829, 849, 849, 951], [952, 952, 977, 977, 1169], [1171, 1171, 1194, 1194, 1493], [1495, 1495, 1514, 1514, 1640], [1642, 1642, 1674, 1674, 1882], [1884, 1884, 1923, 1923, 2956], [2958, 2958, 3012, 3012, 3245], [3247, 3247, 3311, 3311, 5075], [5077, 5077, 5106, 5106, 6060], [6062, 6062, 6088, 6088, 6285], [6287, 6287, 6344, 6344, 6954], [6956, 6956, 7049, 7049, 7171]]}
{"id": "llsyzS", "name": "maxnorm plane distance", "author": "paniq", "description": "distance estimator for cube to plane; mostly useful for frustum testing interior cubes and boxes", "tags": ["distance", "plane", "maxnorm"], "likes": 3, "viewed": 528, "date": "1505344656", "time_retrieved": "2024-06-20T19:00:50.689420", "image_code": "float lengthMaxNorm(vec2 p) {\n    return max(abs(p.x), abs(p.y));\n}\n\nfloat distanceMaxNorm(vec2 a, vec2 b) {\n    return lengthMaxNorm(b-a);\n}\n\nfloat sdmSquare(vec2 p, vec2 c, float r)\n{\n    return distanceMaxNorm(p, c) - r;\n}\n\nfloat sdmPlane(vec2 p, vec3 plane) {\n    vec2 ap = abs(plane.xy);\n    return (dot(p,plane.xy) + plane.z) / (ap.x + ap.y);\n}\n\nfloat sdmPlane(vec3 p, vec4 plane) {\n    vec3 ap = abs(plane.xyz);\n    return (dot(p,plane.xyz) + plane.w) \n        / (ap.x + ap.y + ap.z);\n}\n\nfloat getDistance(vec2 p)\n{\n    float a = iTime * 0.2;\n    vec3 plane = vec3(cos(a),sin(a),0.7);\n    return sdmPlane(p, plane);\n}\n\n// from https://www.shadertoy.com/view/MdjyRK\nvec3 draw_line(float d, float thickness) {\n  const float aa = 3.0;\n  return vec3(smoothstep(0.0, aa / iResolution.y, max(0.0, abs(d) - thickness)));\n}\n\nvec3 draw_line(float d) {\n  return draw_line(d, 0.0025);\n}\n\nfloat draw_solid(float d) {\n  return smoothstep(0.0, 3.0 / iResolution.y, max(0.0, d));\n}\n\nvec3 draw_distance(float d) {\n  float t = clamp(d * 0.85, 0.0, 1.0);\n  vec3 grad = mix(vec3(1, 0.8, 0.5), vec3(0.3, 0.8, 1), t);\n\n  float d0 = abs(1.0 - draw_line(mod(d + 0.1, 0.2) - 0.1).x);\n  float d1 = abs(1.0 - draw_line(mod(d + 0.025, 0.05) - 0.025).x);\n  float d2 = abs(1.0 - draw_line(d).x);\n  vec3 rim = vec3(max(d2 * 0.85, max(d0 * 0.25, d1 * 0.06125)));\n\n  grad -= rim;\n  grad -= mix(vec3(0.05, 0.35, 0.35), vec3(0.0), draw_solid(d));\n\n  return grad;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n    vec2 m = (-iResolution.xy + 2.0 * iMouse.xy) / iResolution.y;\n\n    float d = getDistance(p);\n    float o = 0.0;\n    \n    vec2 rp = m;\n    \n    float sd = abs(getDistance(rp));\n    o += 1.0-smoothstep(0.0, 0.005, abs(sdmSquare(p, rp, sd)));\n    \n    fragColor = vec4(o+draw_distance(d), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llsyzS.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 29, 29, 67], [69, 69, 108, 108, 141], [143, 143, 185, 185, 225], [227, 227, 263, 263, 350], [352, 352, 388, 388, 493], [495, 495, 522, 522, 624], [626, 672, 714, 714, 822], [824, 824, 849, 849, 882], [884, 884, 911, 911, 973], [975, 975, 1004, 1004, 1437], [1439, 1439, 1496, 1496, 1863]]}
{"id": "llXcDM", "name": "Circle Wedge Tracing", "author": "paniq", "description": "2D case of ellipsoid frustum tracing for the unit circle. Vertical lines indicate outer and inner near and far depths of circle within wedge. Inner boundaries show 100% occlusion. The segments between outer and inner planes enclose a part of the surface.", "tags": ["tracing", "ellipse", "bounding", "conservative", "wedge"], "likes": 5, "viewed": 808, "date": "1505048630", "time_retrieved": "2024-06-20T19:00:54.411067", "image_code": "// Circle Wedge Tracing\n// using 2d vector graphics library (https://www.shadertoy.com/view/lslXW8)\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1);\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1);\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r);\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r);\nvoid set_source(sampler2D image);\n// control how source changes are applied\nconst int Replace = 0; // default: replace the new source with the old one\nconst int Alpha = 1; // alpha-blend the new source on top of the old one\nconst int Multiply = 2; // multiply the new source with the old one\nvoid set_source_blend_mode(int mode);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n// add a rectangle at O with size S and rounded corner of radius R\nvoid rounded_rectangle(vec2 o, vec2 s, float r);\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// non-uniformly scale the context by S\nvoid scale(vec2 s);\nvoid scale(float sx, float sy);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    vec2 clip;\n    vec2 scale;\n    float line_width;\n    bool premultiply;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n    int source_blend;\n    bool has_clip;\n};\n\n// save current stroke width, starting\n// point and blend mode from active context.\nContext save();\n// restore stroke width, starting point\n// and blend mode to a context previously returned by save()\nvoid restore(Context ctx);\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\nvoid debug_clip_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\n//////////////////////////////////////////////////////////\n\nfloat cross2d(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\nvec2 solve_quadratic0(vec3 fa) {\n    float a = fa[0];\n    float b = fa[1];\n    float c = fa[2];\n\n    // the quadratic solve doesn't work for a=0\n    // so we need a branch here.\n    if (a == 0.0) {\n        return vec2(-c / b);\n    } else { \n        // (-b +- sqrt(b*b - 4.0*a*c)) / 2.0*a\n        float k = -0.5*b/a;\n        float q = sqrt(k*k - c/a);\n        return k + vec2(-q,q);\n    }\n}\n\nvec2 iUnitCircle(in vec2 ro, in vec2 rd) {\n\tfloat b = 2.0*dot(ro, rd);\n\tfloat c = dot(ro, ro) - 1.0;\n    return solve_quadratic0(vec3(1.0, b, c));\n}\n\n\n\nvoid draw_screen_line(float d) {\n    move_to(d, -2.0);\n    line_to(d, 2.0);\n}\n\nvoid paint() {\n    float t = iTime;\n\n    // clear screen with a subtle gradient\n    set_source_linear_gradient(\n        vec3(0.0,0.0,0.3),\n        vec3(0.0,0.0,0.6),\n        vec2(0.0,-1.0),\n        vec2(0.0,1.0));\n    clear();\n    \n    scale(0.5);\n    \n    set_source_rgb(vec3(1.0));\n    set_line_width_px(1.3);\n    \n    circle(0.0, 0.0, 1.0);\n    stroke();\n    \n    \n    float apt = mix(0.5, 4.0, sin(t*0.12)*0.5+0.5);\n    float hw = 2.0;\n\tvec2 eye = vec2(-2.0, 0.0) + vec2(sin(t),cos(t))*1.2;\n    vec2 c = vec2(3.0, sin(t*0.1)*hw);\n    vec2 c0 = vec2(c.x, c.y + apt);\n    vec2 c1 = vec2(c.x, c.y - apt);\n\n    vec2 v0 = normalize(c0 - eye);\n    vec2 v1 = normalize(c1 - eye);\n    vec2 t0 = iUnitCircle(eye, v0);\n    vec2 t1 = iUnitCircle(eye, v1);\n    \n    bool i0 = (t0.x == t0.x);\n    bool i1 = (t1.x == t1.x);\n    \n    move_to(eye);\n    line_to(c0);\n    set_source_rgb(mix(vec3(1.0,0.0,0.0),vec3(1.0),vec3(i0)));\n    stroke();\n    move_to(eye);\n    line_to(c1);\n    set_source_rgb(mix(vec3(1.0,0.0,0.0),vec3(1.0),vec3(i1)));\n    stroke();\n    \n    vec2 q0 = eye.xx + v0.xx * t0;\n    vec2 q1 = eye.xx + v1.xx * t1;\n    \n    vec2 b0 = vec2(-1.0, 0.0);\n\tvec2 b1 = vec2(1.0, 0.0);\n    \n    bool w00 = cross2d(v0, b0 - eye) > 0.0;\n    bool w01 = cross2d(v1, b0 - eye) > 0.0;\n    bool w10 = cross2d(v0, b1 - eye) > 0.0;\n    bool w11 = cross2d(v1, b1 - eye) > 0.0;\n    \n    float outer_near = max(eye.x, (w00 != w01)?b0.x:min(q0.x, q1.x));\n    float outer_far = max(eye.x, (w10 != w11)?b1.x:max(q0.y, q1.y));\n    float inner_near = max(eye.x, max(q0.x, q1.x));\n    float inner_far = max(eye.x, min(q0.y, q1.y));\n        \n    set_source_rgb(vec3(0.0,1.0,0.5));\n    if ((w00 != w01) && (b0.x > eye.x)) {\n    \tcircle(b0, 0.05);\n    }\n    if (i0 && (q0.x > eye.x)) {\n    \tcircle(eye + v0 * t0.x, 0.05);\n    }   \n    if (i1 && (q1.x > eye.x)) {\n    \tcircle(eye + v1 * t1.x, 0.05);\n    }\n    fill();   \n    set_source_rgb(vec3(0.0,0.5,1.0));\n    if (w10 != w11) {\n    \tcircle(b1, 0.05);\n    }\n    if (i0) {\n\t    circle(eye + v0 * t0.y, 0.05);\n    }\n    if (i1) {\n\t    circle(eye + v1 * t1.y, 0.05);\n    }\n    fill();\n    \n    if (i0 || i1 || (w00 != w01) || (w10 != w11)) {\n        set_source_rgba(0.0,1.0,0.5,0.5);\n        draw_screen_line(outer_near);\n        stroke();\n        set_source_rgba(0.0,0.5,1.0,0.5);\n        draw_screen_line(outer_far);\n        stroke();    \n        if (i0 && i1) {    \n            set_source_rgba(0.0,1.0,0.5,1.0);\n            draw_screen_line(inner_near);\n            stroke();    \n            set_source_rgba(0.0,0.5,1.0,1.0);\n            draw_screen_line(inner_far);\n            stroke();      \n        }    \n    }\n}\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\nfloat AA;\nfloat AAINV;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n#define DEFAULT_CLIP_V -1e+20\n\nContext _stack;\n\nvoid init (vec2 fragCoord) {\n    uv = fragCoord.xy / iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n\n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        vec2(DEFAULT_CLIP_V),\n        vec2(1.0),\n        1.0,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0),\n        Replace,\n        false\n    );\n}\n\nvec3 _color = vec3(1.0);\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n    _stack.clip.y = DEFAULT_CLIP_V;\n}\n\nContext save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;\n    vec2 clip = _stack.clip;\n    bool has_clip = _stack.has_clip;\n    // preserve source\n    vec4 source = _stack.source;\n    _stack = ctx;\n    _stack.shape = shape;\n    _stack.clip = clip;\n    _stack.source = source;\n    _stack.has_clip = has_clip;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = vec2(1.0);\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;\n    _stack.scale = vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    _stack.scale *= vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(vec2 s) {\n    transform(mat3(s.x,0.0,0.0,0.0,s.y,0.0,0.0,0.0,1.0));\n}\n\nvoid scale(float sx, float sy) {\n    scale(vec2(sx, sy));\n}\n\nvoid scale(float s) {\n    scale(vec2(s));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color = mix(_color, _stack.source.rgb, _stack.source.a);\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(_color, 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = _color;\n}\n\nvoid add_clip(vec2 d) {\n    d = d / _stack.scale;\n    _stack.clip = max(_stack.clip, d);\n    _stack.has_clip = true;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);\n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n    _stack.clip = vec2(DEFAULT_CLIP_V);\n    _stack.has_clip = false;\n}\n\nvoid debug_gradient() {\n    vec2 d = _stack.shape;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid debug_clip_gradient() {\n    vec2 d = _stack.clip;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color = _color * (1.0 - src_a) + rgba.rgb * dst_a;\n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat min_uniform_scale() {\n    return min(_stack.scale.x, _stack.scale.y);\n}\n\nfloat uniform_scale_for_aa() {\n    return min(1.0, _stack.scale.x / _stack.scale.y);\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA*uniform_scale_for_aa(), 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);\n\treturn wa * wb;\n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n    if (_stack.has_clip) {\n\t    write_color(_stack.source, calc_aa_blur(_stack.clip.x));        \n    }\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*min_uniform_scale() * AAINV;\n}\n\nfloat get_gradient_eps() {\n    return (1.0 / min_uniform_scale()) * AAINV;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    if (_stack.source_blend == Multiply) {\n        _stack.source *= c;\n    } else if (_stack.source_blend == Alpha) {\n    \tfloat src_a = c.a;\n    \tfloat dst_a = _stack.premultiply?1.0:src_a;\n\t    _stack.source =\n            vec4(_stack.source.rgb * (1.0 - src_a) + c.rgb * dst_a,\n                 max(_stack.source.a, c.a));\n    } else {\n    \t_stack.source = c;\n    }\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) {\n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1) {\n    vec2 pa = _stack.position.xy - p0;\n    vec2 ba = p1 - p0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1) {\n    set_source_linear_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p0, p1);\n}\n\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r) {\n    float h = clamp( length(_stack.position.xy - p) / r, 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r) {\n    set_source_radial_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p, r);\n}\n\nvoid set_source_blend_mode(int mode) {\n    _stack.source_blend = mode;\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid rounded_rectangle(vec2 o, vec2 s, float r) {\n    s = (s * 0.5);\n    r = min(r, min(s.x, s.y));\n    o += s;\n    s -= r;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    vec2 df = max(dmin.xz, dmin.yw) + length2(dmax);\n    add_field(df - r);\n}\n\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), r);\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    rounded_rectangle(o, s, 0.0);\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), 0.0);\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 s = sign(pa.xz*ba.y-pa.yw*ba.x);\n    vec2 d = length2(pa - ba.xyxy*h.xxyy);\n    add_field(d);\n    add_clip(d * s);\n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat test_cross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat bezier_sign(vec2 A, vec2 B, vec2 C, vec2 p) {\n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0,\n        step(test_cross(A, B, p) * test_cross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * test_cross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    vec2 shape = vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw));\n    add_field(abs(shape));\n    add_clip(shape);\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(abs(f_x) / length(df_x));\n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t aspect = vec2(iResolution.x / iResolution.y, 1.0);\n\t ScreenH = min(iResolution.x,iResolution.y);\n\t AA = ScreenH*0.4;\n\t AAINV = 1.0 / AA;\n\n    init(fragCoord);\n\n    paint();\n\n    blit(fragColor);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llXcDM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[5710, 5770, 5801, 5801, 5827], [5829, 5829, 5861, 5861, 6218], [6220, 6220, 6262, 6262, 6368], [6372, 6372, 6404, 6404, 6449], [6451, 6451, 6465, 6465, 9093], [9270, 9330, 9357, 9357, 9383], [9385, 9445, 9466, 9466, 9573], [9575, 9575, 9612, 9612, 9698], [9700, 9700, 9746, 9746, 9779], [9781, 9919, 9947, 9947, 10407], [10435, 10435, 10454, 10454, 10487], [10489, 10489, 10507, 10507, 10540], [10542, 10542, 10566, 10566, 10670], [10672, 10672, 10688, 10688, 10709], [10711, 10711, 10738, 10760, 11043], [11045, 11045, 11073, 11073, 11307], [11309, 11309, 11333, 11333, 11419], [11421, 11421, 11448, 11448, 11661], [11663, 11663, 11689, 11689, 11917], [11919, 11919, 11941, 11941, 12067], [12069, 12069, 12089, 12089, 12149], [12151, 12151, 12183, 12183, 12210], [12212, 12212, 12233, 12233, 12255], [12257, 12257, 12281, 12281, 12341], [12343, 12343, 12377, 12377, 12401], [12403, 12403, 12417, 12417, 12481], [12483, 12483, 12509, 12509, 12541], [12543, 12543, 12569, 12569, 12590], [12592, 12592, 12615, 12615, 12710], [12712, 12712, 12736, 12736, 12805], [12807, 12807, 12832, 12832, 12879], [12881, 12881, 12898, 12898, 13011], [13013, 13013, 13036, 13036, 13165], [13167, 13167, 13195, 13195, 13323], [13325, 13325, 13349, 13349, 13489], [13491, 13491, 13529, 13529, 13663], [13665, 13665, 13702, 13702, 13737], [13739, 13739, 13766, 13766, 13816], [13818, 13818, 13848, 13848, 13904], [13906, 13906, 13935, 13935, 14116], [14118, 14118, 14140, 14140, 14307], [14309, 14309, 14322, 14322, 14361], [14363, 14363, 14393, 14393, 14422], [14424, 14424, 14457, 14457, 14514], [14516, 14516, 14542, 14542, 14592], [14594, 14594, 14615, 14615, 14680], [14682, 14682, 14706, 14706, 14789], [14791, 14791, 14806, 14806, 14847], [14849, 14849, 14865, 14865, 14903], [14905, 14905, 14923, 14923, 14980], [14982, 14982, 15012, 15012, 15382], [15384, 15384, 15442, 15442, 15480], [15482, 15482, 15511, 15511, 15547], [15549, 15549, 15597, 15597, 15628], [15630, 15630, 15664, 15664, 15723], [15725, 15725, 15802, 15802, 15967], [15969, 15969, 16046, 16046, 16126], [16128, 16128, 16204, 16204, 16320], [16322, 16322, 16398, 16398, 16476], [16478, 16478, 16516, 16516, 16550], [16552, 16552, 16574, 16574, 16620], [16622, 16622, 16649, 16649, 16693], [16695, 16695, 16744, 16744, 17005], [17007, 17007, 17080, 17080, 17134], [17136, 17136, 17168, 17168, 17204], [17206, 17206, 17262, 17262, 17318], [17320, 17320, 17350, 17350, 17443], [17444, 17444, 17484, 17484, 17507], [17509, 17509, 17531, 17531, 17582], [17584, 17584, 17616, 17616, 17638], [17640, 17655, 17677, 17677, 17969], [17971, 17971, 18003, 18003, 18025], [18027, 18027, 18046, 18046, 18078], [18127, 18190, 18232, 18232, 18298], [18300, 18370, 18421, 18421, 18773], [18775, 18809, 18855, 18855, 19367], [19369, 19438, 19484, 19484, 19990], [19992, 19992, 20025, 20025, 20241], [20243, 20243, 20302, 20302, 20347], [20349, 20349, 20392, 20392, 20453], [20455, 20455, 20497, 20497, 20539], [20541, 20601, 20658, 20658, 20857]]}
{"id": "llXcDr", "name": "4D Raytracer", "author": "AustinSpafford", "description": "An experiment in casting a 3D-raster of rays (across x/y/w), and sacrificing hue information in exchange for displaying hits across the w-dimension.\n\nI recommend playing with raytrace_scene(); such as changing constants and enabling the hyperspheres. :)", "tags": ["raytracer", "4d", "tesseract", "hypercube"], "likes": 25, "viewed": 473, "date": "1504333652", "time_retrieved": "2024-06-20T19:00:57.726350", "image_code": "// Author: Austin Spafford\n// Title: Hyper-Chroma\n// <dummy-comment to keep the title-scraper from reading into code>\n\n//#define ENABLE_HYPERSPHERES\n    \nprecision highp float;\nprecision highp int;\n\nconst float k_pi = radians(180.0);\nconst float k_tau = radians(360.0);\n\nconst int k_bloblet_count = 3;\n\nconst bool k_blob_enabled = true;\nconst bool k_ground_enabled = true;\n\nconst int k_hyperslice_count = 30;\n\nvec4 s_bloblet_positions[k_bloblet_count];\nfloat s_bloblet_radii[k_bloblet_count];\n\nvec3 s_hyperslice_colors[k_hyperslice_count];\nfloat s_hyperslice_depths[k_hyperslice_count];\n\nvec3 s_light_ambient_color = vec3(0.1);\nvec4 s_light_direction; // surface-to-light\n\nvec2 s_mouse_fractions; // (iMouse / iResolution)\n\nmat4 s_tesseract_world_to_local_rotation;\n\nfloat saturate(\n\tfloat value)\n{\n\treturn clamp(value, 0.0, 1.0);\n}\n\nfloat length_sq(\n\tvec2 vector)\n{\n\treturn dot(vector, vector);\n}\n\nfloat sq(\n    float value)\n{\n    return (value * value);\n}\n\nvec3 sq(\n    vec3 value)\n{\n    return vec3(\n        (value.x * value.x),\n        (value.y * value.y),\n        (value.z * value.z));\n}\n\nfloat distance_sq(\n\tvec2 point_one,\n\tvec2 point_two)\n{\n    vec2 delta = (point_two - point_one);\n    \n\treturn dot(delta, delta);\n}\n\nfloat wrap_angle(\n\tfloat original_radians)\n{\n    return mod(original_radians, k_tau);\n}\n    \nfloat linear_fraction(\n\tfloat min,\n\tfloat max,\n\tfloat value)\n{\n\treturn (min != max) ?\n        ((value - min) / (max - min)) :\n    \tstep(value, max);\n}\n\nfloat clamped_linear_fraction(\n\tfloat min,\n\tfloat max,\n\tfloat value)\n{\n\treturn clamp(linear_fraction(min, max, value), 0.0, 1.0);\n}\n\nfloat trig_cycle_fraction(\n\tfloat domain_fraction)\n{\n    // Smoothly moves through: (0.0, 0.0), (0.5, 1.0), (1.0, 0.0)\n    return linear_fraction(1.0, -1.0, cos(mix(0.0, radians(360.0), domain_fraction)));\n}\n\nint int_mod(\n    int numerator,\n    int divisor)\n{\n    return (numerator - ((numerator / divisor) * divisor));\n}\n\nfloat soft_add_fractions(\n\tfloat first,\n\tfloat second)\n{\n    // Derived from \"compliment(compliment(first) * compliment(second))\", which has the\n    // effect of almost naively adding two fractions when their small, but avoiding going above 1.0 when either one is large.\n    return (first + second - (first * second));\n}\n\nvec3 soft_add_colors(\n\tvec3 first,\n\tvec3 second)\n{\n    return vec3(\n        soft_add_fractions(first.r, second.r),\n        soft_add_fractions(first.g, second.g),\n        soft_add_fractions(first.b, second.b));\n}\n\nfloat random(\n    vec2 st)\n{\n    // From: https://thebookofshaders.com/10/\n\treturn fract(\n\t\tsin(dot(st.xy, vec2(12.9898, 78.233))) * \n\t\t43758.5453123);\n}\n\nvec3 hsb_to_rgb(\n    vec3 hsb_color)\n{\n    //  From: Iñigo Quiles \n    //  https://www.shadertoy.com/view/MsS3Wc\n    vec3 rgb = clamp(abs(mod((hsb_color.x * 6.0) + vec3(0.0,4.0,2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n    rgb = (rgb * rgb * (3.0 - (2.0 * rgb)));\n    return (hsb_color.z * mix(vec3(1.0), rgb, hsb_color.y));\n}\n\nmat2 rotation_mat2(\n\tfloat theta)\n{    \n    float cos_theta = cos(theta);\n    float sin_theta = sin(theta);\n    \n    return mat2(\n    \tcos_theta, sin_theta, // x-basis\n        (-1.0 * sin_theta), cos_theta); // y-basis\n}\n\nmat4 rotation_mat4_xy_plane(\n\tfloat theta)\n{\n    float cos_theta = cos(theta);\n    float sin_theta = sin(theta);\n    \n    return mat4(\n    \tcos_theta, sin_theta, 0.0, 0.0, // x-basis\n        (-1.0 * sin_theta), cos_theta, 0.0, 0.0, // y-basis\n        0.0, 0.0, 1.0, 0.0, // z-basis\n    \t0.0, 0.0, 0.0, 1.0); // w-basis\n}\n\nmat4 rotation_mat4_xz_plane(\n\tfloat theta)\n{\n    float cos_theta = cos(theta);\n    float sin_theta = sin(theta);\n    \n    return mat4(\n    \tcos_theta, 0.0, (-1.0 * sin_theta), 0.0, // x-basis\n        0.0, 1.0, 0.0, 0.0, // y-basis\n        sin_theta, 0.0, cos_theta, 0.0, // z-basis\n    \t0.0, 0.0, 0.0, 1.0); // w-basis\n}\n\nmat4 rotation_mat4_xw_plane(\n\tfloat theta)\n{\n    float cos_theta = cos(theta);\n    float sin_theta = sin(theta);\n \n    // NOTE: I'm unsure of what the proper rotation-signs should be for rotations involving the w-axis.\n    return mat4(\n    \tcos_theta, 0.0, 0.0, sin_theta, // x-basis\n        0.0, 1.0, 0.0, 0.0, // y-basis\n    \t0.0, 0.0, 1.0, 0.0, // z-basis\n        (-1.0 * sin_theta), 0.0, 0.0, cos_theta); // w-basis\n}\n\nmat4 rotation_mat4_yz_plane(\n\tfloat theta)\n{\n    float cos_theta = cos(theta);\n    float sin_theta = sin(theta);\n    \n    return mat4(\n    \t1.0, 0.0, 0.0, 0.0, // x-basis\n        0.0, cos_theta, sin_theta, 0.0, // y-basis\n        0.0, (-1.0 * sin_theta), cos_theta, 0.0, // z-basis\n    \t0.0, 0.0, 0.0, 1.0); // w-basis\n}\n\nmat4 rotation_mat4_yw_plane(\n\tfloat theta)\n{\n    float cos_theta = cos(theta);\n    float sin_theta = sin(theta);\n    \n    // NOTE: I'm unsure of what the proper rotation-signs should be for rotations involving the w-axis.\n    return mat4(\n    \t1.0, 0.0, 0.0, 0.0, // x-basis\n        0.0, cos_theta, 0.0, sin_theta, // y-basis\n    \t0.0, 0.0, 1.0, 0.0, // z-basis\n        0.0, (-1.0 * sin_theta), 0.0, cos_theta); // w-basis\n}\n\nmat4 rotation_mat4_zw_plane(\n\tfloat theta)\n{\n    float cos_theta = cos(theta);\n    float sin_theta = sin(theta);\n    \n    // NOTE: I'm unsure of what the proper rotation-signs should be for rotations involving the w-axis.\n    return mat4(\n    \t1.0, 0.0, 0.0, 0.0, // x-basis\n        0.0, 1.0, 0.0, 0.0, // y-basis\n    \t0.0, 0.0, cos_theta, sin_theta, // z-basis\n        0.0, 0.0, (-1.0 * sin_theta), cos_theta); // w-basis\n}\n\nfloat smooth_min(\n    float first_value,\n    float second_value,\n    float smoothing_distance)\n{\n    // Credit: http://www.iquilezles.org/www/articles/smin/smin.htm\n    float blend_fraction = saturate(0.5 + (0.5 * ((first_value - second_value) / smoothing_distance)));\n    return (\n        mix(first_value, second_value, blend_fraction) - \n        (smoothing_distance * (blend_fraction * (1.0 - blend_fraction))));\n}\n\nvoid raytrace_sphere(\n    vec4 sphere_center,\n    float sphere_radius,\n\tvec4 ray_origin,\n\tvec4 ray_direction,\n\tinout vec3 inout_ray_color,\n\tinout float inout_ray_depth)\n{\n    vec4 local_ray_origin = (ray_origin - sphere_center);\n    \n    // Solving for the intersections via the quadratic equation, as seen in: https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-sphere-intersection\n    float quadratic_a = 1.0; // dot(ray_direction, ray_direction)\n    float quadratic_b = (2.0 * dot(local_ray_origin, ray_direction));\n    float quadratic_c = (dot(local_ray_origin, local_ray_origin) - sq(sphere_radius));\n    float quadratic_discriminant = (sq(quadratic_b) - (4.0 * quadratic_a * quadratic_c));\n    \n    if (quadratic_discriminant >= 0.0)\n    {\n        float sqrt_quadratic_discriminant = sqrt(quadratic_discriminant);\n        float quadratic_divisor = (1.0 / (2.0 * quadratic_a));\n        \n        float depth_near = (((-1.0 * quadratic_b) - sqrt_quadratic_discriminant) * quadratic_divisor);\n        float depth_far = (((-1.0 * quadratic_b) + sqrt_quadratic_discriminant) * quadratic_divisor);\n        \n        float depth = ((depth_near >= 0.0) ? depth_near : depth_far);\n        \n        if ((depth >= 0.0) &&\n            (depth < inout_ray_depth))\n        {\n            vec4 intersection = (ray_origin + (ray_direction * depth));\n            \n            vec4 normal = normalize(intersection - sphere_center);\n            float diffuse_fraction = (1.0 * max(0.0, dot(normal, s_light_direction)));\n            float specular_fraction = 0.0; // (0.5 * pow(max(0.0, (-1.0 * dot(ray_direction, reflect((-1.0 * s_light_direction), normal)))), 40.0));\n            \n            inout_ray_color = mix(s_light_ambient_color, vec3(1.0), min(1.0, (diffuse_fraction + specular_fraction)));\n            inout_ray_depth = depth;\n        }\n    }\n}\n\nvoid raytrace_plane(\n\tvec4 plane_center,\n\tvec4 plane_normal,\n\tvec4 ray_origin,\n\tvec4 ray_direction,\n\tinout vec3 inout_ray_color,\n\tinout float inout_ray_depth)\n{    \n    // https://en.wikipedia.org/wiki/Line%E2%80%93plane_intersection#Algebraic_form\n    float depth = dot((plane_center - ray_origin), plane_normal) / dot(ray_direction, plane_normal);\n    \n    if ((depth >= 0.0) &&\n        (depth < inout_ray_depth))\n    {\n        vec4 intersection = (ray_origin + (ray_direction * depth));\n\n        float diffuse_fraction = (1.0 * max(0.0, dot(plane_normal, s_light_direction)));\n        float specular_fraction = 0.0; // (0.5 * pow(max(0.0, (-1.0 * dot(ray_direction, reflect((-1.0 * s_light_direction), normal)))), 40.0));\n        \n        vec3 surface_color = vec3(1.0);\n        \n        // Checkerboard\n        if (true)\n        {\n            float fuzziness = (0.025 * depth);\n            \n            surface_color = \n                mix(\n                \tvec3(0.1),\n                \tvec3(0.9),\n                \tabs((smoothstep(-fuzziness, fuzziness, cos(k_tau * intersection.x)) + smoothstep(-fuzziness, fuzziness, cos(k_tau * intersection.z))) - 1.0));            \n        }\n\n        inout_ray_color = (surface_color * mix(s_light_ambient_color, vec3(1.0), min(1.0, (diffuse_fraction + specular_fraction))));\n        inout_ray_depth = depth;\n    }\n}\n\nvoid raytrace_tesseract(\n\tvec4 tesseract_center,\n    vec4 tesseract_scale,\n\tvec4 world_ray_origin,\n\tvec4 world_ray_direction,\n\tinout vec3 inout_ray_color,\n\tinout float inout_ray_depth)\n{\n    // Using this method: https://tavianator.com/fast-branchless-raybounding-box-intersections/\n        \n    vec4 local_ray_origin = (s_tesseract_world_to_local_rotation * (world_ray_origin - tesseract_center));\n    vec4 local_ray_direction = (s_tesseract_world_to_local_rotation * world_ray_direction);\n    \n    vec4 local_ray_direction_inverse = (1.0 / local_ray_direction);\n    \n    float result_near_depth = 0.0;\n    float result_far_depth = 1000000.0;\n    \n    // X-slab\n    {\n        float pos_x_depth = ((tesseract_scale.x - local_ray_origin.x) * local_ray_direction_inverse.x);\n        float neg_x_depth = (((-1.0 * tesseract_scale.x) - local_ray_origin.x) * local_ray_direction_inverse.x);\n        \n        float x_near_depth = min(pos_x_depth, neg_x_depth);\n        float x_far_depth = max(pos_x_depth, neg_x_depth);\n        \n        result_near_depth = max(result_near_depth, x_near_depth);\n        result_far_depth = min(result_far_depth, x_far_depth);\n    }\n    \n    // Y-slab\n    {\n        float pos_y_depth = ((tesseract_scale.y - local_ray_origin.y) * local_ray_direction_inverse.y);\n        float neg_y_depth = (((-1.0 * tesseract_scale.y) - local_ray_origin.y) * local_ray_direction_inverse.y);\n        \n        float y_near_depth = min(pos_y_depth, neg_y_depth);\n        float y_far_depth = max(pos_y_depth, neg_y_depth);\n        \n        result_near_depth = max(result_near_depth, y_near_depth);\n        result_far_depth = min(result_far_depth, y_far_depth);\n    }\n    \n    // Z-slab\n    {\n        float pos_z_depth = ((tesseract_scale.z - local_ray_origin.z) * local_ray_direction_inverse.z);\n        float neg_z_depth = (((-1.0 * tesseract_scale.z) - local_ray_origin.z) * local_ray_direction_inverse.z);\n        \n        float z_near_depth = min(pos_z_depth, neg_z_depth);\n        float z_far_depth = max(pos_z_depth, neg_z_depth);\n        \n        result_near_depth = max(result_near_depth, z_near_depth);\n        result_far_depth = min(result_far_depth, z_far_depth);\n    }    \n    \n    // W-slab\n    {\n        float pos_w_depth = ((tesseract_scale.w - local_ray_origin.w) * local_ray_direction_inverse.w);\n        float neg_w_depth = (((-1.0 * tesseract_scale.w) - local_ray_origin.w) * local_ray_direction_inverse.w);\n        \n        float w_near_depth = min(pos_w_depth, neg_w_depth);\n        float w_far_depth = max(pos_w_depth, neg_w_depth);\n        \n        result_near_depth = max(result_near_depth, w_near_depth);\n        result_far_depth = min(result_far_depth, w_far_depth);\n    }\n    \n    if ((result_near_depth <= result_far_depth) &&\n        (result_near_depth < inout_ray_depth))\n    {\n        vec4 normalized_local_surface = ((local_ray_origin + (local_ray_direction * result_near_depth)) / tesseract_scale);\n        \n        float cube_hole_fraction = smoothstep(0.1, 1.0, s_mouse_fractions.x);\n        cube_hole_fraction = 0.8;\n        \n        if ((step(cube_hole_fraction, abs(normalized_local_surface)) * step(abs(normalized_local_surface), vec4(0.999999))) != vec4(0.0))\n        {\n            inout_ray_color = vec3(1.0);\n            inout_ray_depth = result_near_depth;\n\n            // Lighting\n            if (true)\n            {\n                vec4 surface_normal = (normalize(step(0.999, abs(normalized_local_surface))) * sign(normalized_local_surface));\n                float diffuse_fraction = (1.0 * max(0.0, dot(surface_normal, (s_tesseract_world_to_local_rotation * s_light_direction))));\n\n                inout_ray_color *= mix(s_light_ambient_color, vec3(1.0), diffuse_fraction);\n            }\n        }\n        else if (result_far_depth < inout_ray_depth)\n        {\n            normalized_local_surface = ((local_ray_origin + (local_ray_direction * result_far_depth)) / tesseract_scale);\n\n            if ((step(cube_hole_fraction, abs(normalized_local_surface)) * step(abs(normalized_local_surface), vec4(0.999999))) != vec4(0.0))\n            {\n                inout_ray_color = vec3(1.0);\n                inout_ray_depth = result_far_depth;\n\n                // Lighting\n                if (true)\n                {\n                    vec4 surface_normal = (normalize(step(0.999, abs(normalized_local_surface))) * (-1.0 * sign(normalized_local_surface)));\n                    float diffuse_fraction = (1.0 * max(0.0, dot(surface_normal, (s_tesseract_world_to_local_rotation * s_light_direction))));\n\n                    inout_ray_color *= mix(s_light_ambient_color, vec3(1.0), diffuse_fraction);\n                }\n            }\n        }\n    }\n}\n\nvoid raytrace_scene(\n\tvec4 ray_origin,\n\tvec4 ray_direction,\n\tout vec3 out_ray_color,\n\tout float out_ray_depth)\n{\n    out_ray_color = vec3(0.0, 0.0, 0.0);\n    out_ray_depth = 10.0;\n    \n#ifdef ENABLE_HYPERSPHERES\n    for (int bloblet_index = 0; bloblet_index < k_bloblet_count; bloblet_index++)\n    {\n        raytrace_sphere(\n            s_bloblet_positions[bloblet_index],\n            s_bloblet_radii[bloblet_index],\n            ray_origin,\n            ray_direction,\n        \tout_ray_color,\n        \tout_ray_depth);\n    }\n#endif\n    \n    vec4 tesseract_scale = vec4(0.6);\n    //tesseract_scale = vec4(0.8, 0.2, 0.2, 0.7);\n    tesseract_scale = vec4(0.6, 0.6, 0.6, 0.2);\n      \n    raytrace_tesseract(\n\t\tvec4(0.0, 0.3, 0.0, 0.0), // tesseract_center\n        tesseract_scale,\n    \tray_origin,\n        ray_direction,\n        out_ray_color,\n        out_ray_depth);\n        \n    raytrace_plane(\n    \tvec4(0.0, -0.8, 0.0, 0.0),\n    \tnormalize(vec4(0.0, 1.0, 0.0, 0.0)),\n        ray_origin,\n        ray_direction,\n        out_ray_color,\n        out_ray_depth);\n}\n\nvoid mainImage(\n\tout vec4 fragColor,\n    in vec2 fragCoord)\n{\n    vec2 test_point = (fragCoord.xy / iResolution.xy);\n    \n    s_mouse_fractions = (iMouse.xy / iResolution.xy);\n    \n    test_point -= 0.5;\n    test_point *= 2.0;\n    \n    float texture_aspect_ratio = (iResolution.x / iResolution.y);\n    \n    // Perform aspect-ratio correction.\n\ttest_point.x *= max(1.0, texture_aspect_ratio);\n    test_point.y *= max(1.0, (1.0 / texture_aspect_ratio));\n    \n    // Crop down until the artwork is touching at least one pair of edges.\n    {\n        float artwork_aspect_ratio = 1.0;\n        \n        //artwork_aspect_ratio = texture_aspect_ratio; // Zoom in until the artwork fills the frame.\n        \n        if ((artwork_aspect_ratio > 1.0) && (texture_aspect_ratio > 1.0))\n        {\n            test_point /= min(artwork_aspect_ratio, texture_aspect_ratio);\n        }\n        else if ((artwork_aspect_ratio < 1.0) && (texture_aspect_ratio < 1.0))\n        {\n            test_point *= max(artwork_aspect_ratio, texture_aspect_ratio);\n        }\n    }\n    \n    s_light_direction = normalize(vec4(1.0, 2.0, 1.5, 0.0));\n    \n    // Build a transform for the tesseract.\n    {\n        float animation_fraction = fract(iTime * 0.02);\n        \n    \ts_tesseract_world_to_local_rotation = (\n            rotation_mat4_xy_plane(k_tau * smoothstep(0.0, 0.1, animation_fraction)) * \n\n            //rotation_mat4_xy_plane(k_tau * smoothstep(0.1, 0.2, animation_fraction)) * \n            //rotation_mat4_xz_plane(k_tau * smoothstep(0.1, 0.2, animation_fraction)) *\n\n            //rotation_mat4_xz_plane(k_tau * 0.125) *\n            rotation_mat4_xw_plane(k_tau * smoothstep(0.1, 0.3, animation_fraction)) * \n            //rotation_mat4_xz_plane(k_tau * -0.125) * \n\n            rotation_mat4_xy_plane(k_tau * smoothstep(0.3, 0.4, animation_fraction)) *  \n            rotation_mat4_xw_plane(k_tau * smoothstep(0.3, 0.4, animation_fraction)) *  \n\n            //rotation_mat4_xy_plane(k_tau * smoothstep(0.4, 1.0, animation_fraction)) *  \n            //rotation_mat4_yz_plane(k_tau * 2.0 * smoothstep(0.4, 1.0, animation_fraction)) *  \n            //rotation_mat4_xz_plane(k_tau * smoothstep(0.4, 1.0, animation_fraction)) *  \n            rotation_mat4_xw_plane(k_tau * 2.0 * smoothstep(0.4, 1.0, animation_fraction)) *  \n            rotation_mat4_yw_plane(k_tau * smoothstep(0.4, 1.0, animation_fraction)) *  \n            rotation_mat4_zw_plane(k_tau * 3.0 * smoothstep(0.4, 1.0, animation_fraction)));\n    }\n    \n    // Compute the blob parameters.\n    for (int bloblet_index = 0; bloblet_index < k_bloblet_count; bloblet_index++)\n    {\n        float bloblet_fraction = (float(bloblet_index) / float(k_bloblet_count));\n        \n        vec4 bloblet_movement_rates =\n            vec4(\n                mix(0.02, 0.1, random(vec2(float(bloblet_index), 0.0))),\n                mix(0.02, 0.1, random(vec2(float(bloblet_index), 0.1))),\n                mix(0.02, 0.1, random(vec2(float(bloblet_index), 0.2))),\n                mix(0.02, 0.1, random(vec2(float(bloblet_index), 0.3))));\n        \n        bloblet_movement_rates *= 0.5;\n        \n        s_bloblet_positions[bloblet_index] = (1.0 * vec4(1.0, 1.0, 1.0, 1.0) * sin(k_tau * bloblet_movement_rates * iTime));\n        \n        if (false)\n        {\n            s_bloblet_positions[bloblet_index] = vec4(\n                cos(k_tau * ((0.0 * iTime) + bloblet_fraction)),\n                sin(k_tau * ((0.0 * iTime) + bloblet_fraction)),\n                0.0,\n                (1.0 * cos(k_tau * ((-0.1 * iTime) + (0.5 * bloblet_fraction)))));\n        }\n        \n        s_bloblet_radii[bloblet_index] = (0.5 * mix(1.0, 1.0, random(vec2(float(bloblet_index), 0.3))));\n    }\n    \n    vec3 scene_color;\n    {\n        // Render all of the hyperslices.\n        for (int hyperslice_index = 0; hyperslice_index < k_hyperslice_count; hyperslice_index++)\n        {\n            float dithering_fraction = random(test_point);\n            \n            float hyperslice_fraction = ((float(hyperslice_index) + mix(-0.5, 0.5, dithering_fraction)) / max(1.0, float(k_hyperslice_count - 1)));\n            \n            float w_fov = 0.5;//s_mouse_fractions.y;\n            \n            // Akin to how test_point varies from -1 to 1 on each axis, we're adding an additional axis of iteration/sampling.\n            float hyperslice_w = mix((-1.0 * w_fov), w_fov, hyperslice_fraction);\n            hyperslice_w = sign(hyperslice_w) * pow(abs(hyperslice_w), 2.0);\n            \n            vec4 ray_origin = vec4(0.0, 0.0, 1.75, 0.0);\n            vec4 ray_direction = normalize(vec4(test_point, -1.0, hyperslice_w));\n\n            // Orthographic.\n            if (false)\n            {\n                ray_origin = vec4((2.0 * test_point), 10.0, hyperslice_w);\n                ray_direction = vec4(0.0, 0.0, -1.0, 0.0);\n            }\n\n            // Camera-Pitch control.\n            if (false)\n            {\n                mat4 transform = rotation_mat4_yz_plane(k_tau * mix(-0.08, 0.25, (1.0 - s_mouse_fractions.y)));\n                ray_origin *= transform;\n                ray_direction *= transform;\n            }\n            else\n            {\n                mat4 transform = rotation_mat4_yz_plane(k_tau * 0.1);\n                ray_origin *= transform;\n                ray_direction *= transform;\n            }\n\n            // Camera-Yaw control.\n            if (false)\n            {\n                mat4 transform = rotation_mat4_xz_plane(k_tau * s_mouse_fractions.x);\n                ray_origin *= transform;\n                ray_direction *= transform;\n            }\n            else\n            {\n                float yaw_fraction = fract(iTime * 0.012);\n                yaw_fraction = mix(0.1, -0.35, smoothstep(-1.0, 1.0, cos(iTime * 0.11)));\n                \n                mat4 transform = rotation_mat4_xz_plane(k_tau * yaw_fraction);\n                ray_origin *= transform;\n                ray_direction *= transform;\n            }\n\n            raytrace_scene(\n                ray_origin,\n                ray_direction,\n            \ts_hyperslice_colors[hyperslice_index],\n            \ts_hyperslice_depths[hyperslice_index]);\n    \n            if (s_hyperslice_depths[hyperslice_index] < 10.0)\n            {\n                vec4 shadow_ray_origin = (ray_origin + (ray_direction * s_hyperslice_depths[hyperslice_index]));\n                vec4 shadow_ray_direction = s_light_direction;\n                \n                shadow_ray_origin += (0.001 * shadow_ray_direction);\n\n                vec3 shadow_ray_color = vec3(0.0);\n                float shadow_ray_depth = 10.0;\n                raytrace_scene(\n                    shadow_ray_origin,\n                    shadow_ray_direction,\n                    shadow_ray_color,\n                    shadow_ray_depth);\n\n                if (shadow_ray_depth < 10.0)\n                {\n                    s_hyperslice_colors[hyperslice_index] = min(s_hyperslice_colors[hyperslice_index], s_light_ambient_color);\n                }\n            }\n        }\n        \n        // Composite the hyperslices.\n        if (true)\n        {\n            vec3 color_summation = vec3(0.0);\n            \n            for (int hyperslice_index = 0; hyperslice_index < k_hyperslice_count; hyperslice_index++)\n            {\n            \tfloat hyperslice_fraction = (float(hyperslice_index) / max(1.0, float(k_hyperslice_count - 1)));\n                \n                float brightness = dot(s_hyperslice_colors[hyperslice_index], s_hyperslice_colors[hyperslice_index]); // Squaring into linear-space color.                \n                vec3 hyperslice_color = hsb_to_rgb(vec3((0.7 * hyperslice_fraction), 1.0, brightness));\n                    \n                color_summation += hyperslice_color;\n            }\n        \n        \tscene_color = sqrt(color_summation / float(k_hyperslice_count)); // Converting back into sqrt-space color.\n        }\n        else\n        {\n            vec3 color_summation = vec3(0.0);\n            \n            for (int hyperslice_index = 0; hyperslice_index < k_hyperslice_count; hyperslice_index++)\n            {\n                color_summation += sq(s_hyperslice_colors[hyperslice_index]); // Squaring into linear-space color.\n            }\n        \n        \tscene_color = sqrt(color_summation / float(k_hyperslice_count)); // Converting back into sqrt-space color.\n        }\n    }\n\n    vec3 background_color = vec3(0.0);\n    //background_color += (vec3(0.4) * max(smoothstep(0.04, 0.0, abs(fract(test_point.x))), smoothstep(0.04, 0.0, abs(fract(test_point.y))))); // Generate a coordinates-grid.\n    \n    vec3 color = scene_color;         \t\n    //color = mix(background_color, scene_color.rgb, scene_color.a);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llXcDr.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[697, 767, 798, 798, 832], [834, 834, 866, 866, 897], [899, 899, 927, 927, 957], [959, 959, 985, 985, 1092], [1094, 1094, 1148, 1148, 1224], [1226, 1226, 1270, 1270, 1313], [1319, 1319, 1381, 1381, 1469], [1471, 1471, 1541, 1541, 1602], [1604, 1604, 1656, 1722, 1811], [1813, 1813, 1863, 1863, 1925], [1927, 1927, 1983, 2197, 2247], [2249, 2249, 2299, 2299, 2460], [2462, 2462, 2490, 2536, 2615], [2617, 2617, 2655, 2730, 2938], [2940, 2940, 2975, 2975, 3160], [3162, 3162, 3206, 3206, 3482], [3484, 3484, 3528, 3528, 3804], [3806, 3806, 3850, 3850, 4227], [4229, 4229, 4273, 4273, 4549], [4551, 4551, 4595, 4595, 4975], [4977, 4977, 5021, 5021, 5401], [5403, 5403, 5499, 5567, 5819], [5821, 5821, 5991, 5991, 7711], [7713, 7713, 7873, 7961, 9070], [9072, 9072, 9258, 9354, 13764], [13766, 13766, 13878, 13878, 14822], [14824, 14824, 14885, 14885, 23544]]}
{"id": "llXczS", "name": "Flat Sine", "author": "anclin", "description": "Flat Sine", "tags": ["flatsine"], "likes": 0, "viewed": 72, "date": "1505232832", "time_retrieved": "2024-06-20T19:00:57.726350", "image_code": "const float PI = 3.14159;\nconst float speed = 0.5;\nconst float power = 5.0;\nconst float width = 0.02;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 color = vec3(0);\n    uv.x *= 1.1;\n    uv.x -= 0.05;\n    \n    \n    float s = sin(iTime*PI*speed);\n    //float s = sin( (iTime + uv.y*0.1) * 1.88 );\n    float flatSin = (s*power) / (abs(s)*(power-1.0)+1.0);\n    \n    float t = flatSin * 0.5 + 0.5;\n    \n    \n    if(abs(uv.x-t) < width){\n        color = vec3(1,0,0);\n    }\n    \n\tfragColor = vec4(color,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llXczS.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[103, 103, 160, 160, 565]]}
{"id": "llXyRj", "name": "Sinusoid", "author": "albertelwin", "description": "Sinusoid sketch in 258 chars.", "tags": ["2d", "sine"], "likes": 7, "viewed": 164, "date": "1505421516", "time_retrieved": "2024-06-20T19:00:57.726350", "image_code": "\nvoid mainImage(out vec4 c, vec2 x) {\n\tvec2 i = iResolution.xy;\n\tvec2 p = x / i;\n\tp = (x * 2. - i) / i.y * (p.x * p.y * .8 + .6);\n\t\n\tfloat t = iTime * .2;\n\tt = length(p) * 5.\n\t\t+ sin(t * .7 - sin((p.x * cos(t) + p.y * sin(t)) * 2. - t * 4.) * 2. + p.y * .4)\n\t\t+ sin(sin(t * 4. - (p.y * cos(t) - p.x * sin(t)) * 3.) + t + p.x * .3)\n\t;\n\n\tc = vec4(sin(t * 32.));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llXyRj.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1, 1, 37, 37, 361]]}
{"id": "llXyW7", "name": "Cascade Failure", "author": "WuTangTan", "description": "evocation", "tags": ["2d"], "likes": 0, "viewed": 429, "date": "1505050702", "time_retrieved": "2024-06-20T19:00:57.926359", "image_code": "float basis(float x) {\n  return sin(x) * sin(x);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  uv.x *= iResolution.x / iResolution.y;\n\n  float x = uv.x * 6.28 * 2.0;\n  float t = basis(x) * 0.75;\n  float t2 = basis(t * 8.0 + iTime);\n  t += t2 * 1.0 / 8.0;\n\n  vec3 c = vec3(0.0);\n\n  float sineTransition = smoothstep(uv.y, uv.y + pow(uv.x, 2.0), t);\n\n  c.r = sineTransition * t2;\n  c.g = c.r * 0.1;\n  c.b = c.r * 0.4;\n\n  c.rgb += (1.0 - sineTransition) * (1.0 - t2);\n\n  fragColor = vec4(c, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llXyW7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 22, 22, 50], [52, 52, 107, 107, 553]]}
{"id": "lsBBD1", "name": "abstract_fractal3d_0", "author": "balkhan", "description": "done after reading iq's \"monster\" shader", "tags": ["raymarching", "kifs"], "likes": 7, "viewed": 176, "date": "1506707631", "time_retrieved": "2024-06-20T19:00:58.799340", "image_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\n#define I_MAX\t50\n#define E\t\t0.01\n\n#define I 12.\n\nfloat\tsdHexPrism( vec3 p, vec2 h );\nfloat\tsdBox( vec3 p, vec3 b );\nfloat\tdistanceToL;\nvoid\trotate(inout vec2 v, float angle);\nfloat\tsdTorus( vec3 p, vec2 t );\nvec2\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvec3\tblackbody(float Temp);\nfloat\tscene(vec3 p);\n\nfloat\taa;\nmat2\tma;\n\nvec3\tlight_pos;\nvec3\th;\nfloat\tt; // time\n\nfloat\tii,m;\n\nvoid mainImage(out vec4 o, in vec2 f )\n{\n    h *= 0.;\n    o.xyz *= 0.;\n    t = iTime*.5;\n    vec2 R = iResolution.xy,\n          uv  = vec2(f-R/2.) / R.y;\n\tvec3\tdir = camera(uv);\n    vec3\tpos = vec3(.0, .0, 1.0);\n    vec2\tinter = (march(pos, dir));\n    if (inter.y < 20.)\n        o.xyz += vec3( abs(sin(t*1.+ii*.1+m+1.04)), abs(sin(t*1.+ii*.1+m+2.09)), abs(sin(t*1.+ii*.1+m+3.14)))*(1.-inter.x*.05);\n\n    o.xyz += h;\n}\n\nfloat\tscene(vec3 p)\n{\n    distanceToL = 1e3;\n    float r2,k=1.;\n    ii=0.;\n    m = r2 = 1e5;\n    aa = t*.025;\n    p.z+=6.;\n    rotate(p.zx, t+1.57+0.*iTime);\n    rotate(p.zy, t+1.57+0.*iTime);\n\n    for(float\ti = -1.; i < I; ++i)\n    {\n        ++ii;\n\t\t//r2 = min(r2, sdTorus(p, vec2(.521,.12) )); // torus based variant, comment 2 next lines if using \n\t\tr2= min(r2, sdHexPrism(p, vec2(.3,.3)) );\n\t\tdistanceToL = sdHexPrism(p, vec2(.3, .0))*32.;\n\t\taa=aa+.5/(i+2.);\n        if (mod(i, 3.) == 0.)\n        {\n            ma = mat2(cos(aa+1.*ii*.25),sin(aa+1.*ii*.25), -sin(aa+1.*ii*.25), cos(aa+1.*ii*.25) );\n\t        p.xy*=ma;\n\t        p.xy = abs(p.xy)-.125;\n\t\t\tp.z -= .2;\n        }\n        else if (mod(i, 3.) == 1.)\n        {\n            ma = mat2(cos(aa*3.+1.04+1.*ii*.1),sin(aa*3.+1.04+1.*ii*.1), -sin(aa*3.+1.04+1.*ii*.1), cos(aa*3.+1.04+1.*ii*.1) );\n\t        p.yz*=ma;\n\t        p.zy = abs(p.zy)-.125;\n            p.x -= .2;\n        }\n        else if (mod(i, 3.) == 2.)\n        {\n            ma = mat2(cos(aa*2.+2.08+1.*ii*.5),sin(aa*2.+2.08+1.*ii*.5), -sin(aa*2.+2.08+1.*ii*.5), cos(aa*2.+2.08+1.*ii*.5) );\n            p.zx*=ma;\n\t        p.xz = abs(p.xz)-.125;\n\t       \tp.y -= .2;\n        }\n\tm = min(m, log(sdBox(p,vec3(.0612510))/(k*k) ) );\n    k *= 1.125;\n    }\n    return r2;\n}\n\nvec3 evaluateLight(in vec3 pos)\n{\n    vec3\tlightCol;\n    lightCol = vec3(1.,.7,.2);\n    return (\n        \tlightCol * 1.0/(distanceToL*distanceToL)\n        \t)*(.25);\n}\n\nvec2\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0);\n    vec3\tp = vec3(0.0);\n    vec2\ts = vec2(0.0);\n\n    for (int i = 0; i < I_MAX; ++i)\n    {\n    \tp = pos + dir * dist.y;\n        dist.x = scene(p);\n        dist.y += dist.x;\n        h += evaluateLight(p);\n        if (dist.x < E || dist.y > 20.)\n        {\n           break;\n        }\n        s.x++;\n    }\n    s.y = dist.y;\n    return (s);\n}\n\n// Utilities\n\nfloat\tmylength(vec2 p)\n{\n    float\tret = 0.;\n \tp = p*p*p*p;\n    ret = pow(p.x+p.y, 1./4.);\n    \n    return (ret);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n\tvec2 q = vec2(length(p.zy)-t.x,p.x);\n\n    return length(q)-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\n\nvec3\tcamera(vec2 uv)\n{\n    float   fov = 1.;\n\tvec3    forw  = vec3(0.0, 0.0, -1.0);\n\tvec3    right = vec3(1.0, 0.0, 0.0);\n\tvec3    up    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsBBD1.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[480, 502, 542, 542, 919], [921, 921, 942, 942, 2202], [2204, 2204, 2237, 2237, 2370], [2372, 2372, 2404, 2404, 2770], [2772, 2786, 2810, 2810, 2901], [2903, 2903, 2936, 2936, 3003], [3005, 3005, 3041, 3041, 3125], [3127, 3127, 3158, 3158, 3196], [3199, 3199, 3221, 3221, 3428], [3430, 3430, 3470, 3470, 3545]]}
{"id": "ltfcDf", "name": "Be A Fan Boi", "author": "isak", "description": "My first little thingy that is ray marched and that I want to share. I'm a raymarch noobie, but I physics a bit.", "tags": ["raymarch", "yellow", "fan"], "likes": 2, "viewed": 95, "date": "1506645857", "time_retrieved": "2024-06-20T19:00:58.799340", "image_code": "#define MAX_STEPS 100\n#define EPSILON 0.005\n#define N_EPSILON 0.05\n#define PI 3.14159265358979323846\n\n#define ez vec3(0.0, 0.0, 1.0)\n\nmat2 rot(float a) {\n    float c = cos(a); float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n\nfloat blade(vec3 p, float a){\n    \n    p.xy *= rot(a); \n    p.xz *= rot(-clamp(0.3 + 0.03*p.y*p.y, 0.3, 0.6));\n    \n    float psy = p.y - 3.0;\n    float ppy = p.y - 1.0;\n    \n    \n    float xs = clamp(0.4 + -0.04*psy*psy, -1.5, 1.0);\n    float xp = clamp( 2.0 + 0.02*ppy*ppy,  1.0, 2.5);\n    \n    \n    return length(p - vec3(clamp(p.x, -2.0*xs, xp),\n                           clamp(p.y, -3.0, 3.0 - 0.1*p.x*p.x),\n                           0.0\n                           )) - 0.1;\n}\n\nfloat centre(vec3 p){\n    float rad = 2.5;\n    float len = 0.7;\n    vec2 d = abs(vec2(length(p.xy/rad), p.z/len) ) - 1.0 ;\n  \treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat concav(vec3 p){\n    float rad = 2.3;\n    float len = 0.7;\n    vec2 d = abs(vec2(length(p.xy/rad), p.z/len) ) - 1.0 ;\n  \treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat d_sphere(vec3 p, vec3 pos, float r){\n    return length(p - pos) - r;\n}\n\nfloat sceneSDF(vec3 p){\n    \n    p.z += 10.0;\n    \n    p.xz *= rot(iTime);\n    p.xy *= rot(2.6*iTime);\n    \n    float a = 2.0*PI/7.0;\n    mat2 R = rot(a);\n \n    vec2 O1 = vec2(0.0, -3.5);\n    vec2 O2 = R*O1;\n    vec2 O3 = R*O2;\n    vec2 O4 = R*O3;\n    vec2 O5 = R*O4;\n    vec2 O6 = R*O5;\n    vec2 O7 = R*O6;\n    \n    \n    float z_pos = 0.0;\n    \n    float d = min( \n        \t\t   min( blade(p + vec3(O1, z_pos), 0.0*a),\n                        blade(p + vec3(O2, z_pos), 1.0*a)) , \n                   min( blade(p + vec3(O3, z_pos), 2.0*a),\n                        blade(p + vec3(O4, z_pos), 3.0*a)));\n    \n    \t  d = min( min( d,\n                       \tblade(p + vec3(O5, z_pos), 4.0*a)),\n                   min( blade(p + vec3(O6, z_pos), 5.0*a),\n           \t\t\t\tblade(p + vec3(O7, z_pos), 6.0*a)));\n                       \n    d =  min(d,centre(p + vec3(0.0, 0.0, 0.7 + z_pos)));\n    \n    d = max(d, -concav(p + vec3(0.0, 0.0, 1.0 + z_pos)));\n    \n    vec2 p1 = vec2(0.2, 0.2);\n    vec2 p2 = rot(2.0*PI/3.0)*p1;\n    vec2 p3 = rot(2.0*PI/3.0)*p2;\n    \n    float d_logo = min(\n        \t\t\t\tmin( length(p + vec3(p1, 0.0 + z_pos)) - 0.2,\n                             length(p + vec3(p2, 0.0 + z_pos)) - 0.2),\n                             length(p + vec3(p3, 0.0 + z_pos)) - 0.2);\n    \n    d = max(d, - d_logo);\n    \n    return d;\n    \n}\n\n\n\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + N_EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - N_EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + N_EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - N_EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + N_EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - N_EPSILON))\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n\tvec2 uv = fragCoord.xy - 0.5*iResolution.xy;\n    uv *= 2.0/iResolution.y;\n    \n    uv *= 4.0;\n    \n    float fov = PI/20.0;\n    vec3 cam_pos = vec3(0.0, 0.0, 1.0*(1.0 + 1.0/tan(fov)));\n    \n    vec3 ray = cam_pos;\n    vec3 dir = normalize(vec3(uv.xy, 0.0) - cam_pos);\n    \n    vec3 light = normalize(vec3(0.5, 0.5, 1.0));\n    \n    float shade = 0.0;\n    float shade_1 = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++){\n        \n        float dist = sceneSDF(ray);\n        \n        if ( dist < EPSILON ) {\n            \n            vec3 n = estimateNormal(ray);\n            float soft = dot(light,n);\n            float soft_s = soft - 1.0;\n            shade += 0.8*soft;\n            shade += clamp(exp(-soft*soft*10.0), 0.0, 1.0);\n            shade += clamp(exp(-soft_s*soft_s*10000.0), 0.0, 1.0);\n            \n            break;\n        }\n        else if ( length(ray) > 30.0 )\n            break;\n        ray += 0.71*dir*dist;\n    }\n    \n    \n    \n\tfragColor = vec4(1.0, 0.9, 0.0, 0.0)*shade;\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltfcDf.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[134, 134, 153, 153, 225], [228, 228, 257, 257, 711], [713, 713, 734, 734, 891], [894, 894, 915, 915, 1072], [1075, 1075, 1117, 1117, 1151], [1153, 1153, 1176, 1176, 2486], [2491, 2491, 2520, 2520, 2842], [2844, 2844, 2900, 2900, 3898]]}
{"id": "ltfcDn", "name": "Avelina's Mandelbrot Zoom", "author": "Avelina", "description": "Mandelbrot zoom", "tags": ["fractal2d"], "likes": 0, "viewed": 81, "date": "1504537341", "time_retrieved": "2024-06-20T19:00:58.805313", "image_code": "vec2 uv2ri( highp vec2 uv, float radius, highp vec2 offset )\n{\n    float r = uv.x * 2.0 * radius - radius + offset.x;\n    float i = uv.y * 2.0 * radius - radius + offset.y;\n    \n    return vec2( r, i );\n}\n\n\n\nint mandelbrot( highp vec2 c )\n{\n    vec2 z = vec2( 0, 0 );\n    \n    for( int depth = 0; depth < 4001; depth++ )\n    {\n        z = vec2( z.x * z.x - z.y * z.y + c.x,\n                  2.0 * z.x * z.y + c.y );\n        if( length( z ) >= 2.0 )\n        {\n            return depth;\n        }\n    }\n    return -1;\n}\n\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 ir = uv2ri( uv, 2.0 / ( 1.0 + pow( 1.5, iTime ) / 2.0 ), vec2( -0.745428, 0.113009 ) );\n    \n    float c = float( mandelbrot( ir ) )/1000.0;\n    if( c < 0.0 )\n    {\n        fragColor = vec4(0,0,0,1);\n    }\n    else\n    {\n        fragColor.rgb = hsv2rgb( vec3( c, 1, pow( c, 0.5) ) );\n        fragColor.a = 1.0;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltfcDn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 62, 62, 204], [208, 208, 240, 240, 518], [520, 520, 542, 542, 705], [707, 707, 764, 764, 1134]]}
{"id": "ltfyD7", "name": "Power City", "author": "fizzer", "description": "Uses hybrid distance field raymarching and uniform grid traversal. Drag mouse to rotate the view.", "tags": ["voxel", "city", "power"], "likes": 75, "viewed": 2744, "date": "1505062529", "time_retrieved": "2024-06-20T19:00:58.805313", "image_code": "float box(vec3 p,vec3 o,vec3 s)\n{\n    p=abs(p-o)-s;\n    return max(p.x,max(p.y,p.z));\n}\n\nfloat hash(float n)\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise(vec3 p)\n{\n    return hash(p.x + p.y*57.0 + p.z*117.);\n}\n\nfloat noise(vec2 p)\n{\n    return hash(p.x + p.y*57.0);\n}\n\nfloat valnoise(vec2 p)\n{\n    vec2 c=floor(p);\n    vec2 f=smoothstep(0.,1.,fract(p));\n    return mix (mix(noise(c+vec2(0,0)), noise(c+vec2(1,0)), f.x),\n                mix(noise(c+vec2(0,1)), noise(c+vec2(1,1)), f.x), f.y);\n}\n\nfloat dist(vec3 p)\n{\n    float d=1e3;\n\n    vec3 p2=p;\n    float s=1.;\n    for(int i=0;i<4;++i)\n    {\n        p2.xz=abs(p2.xz);   \n        float cl=max(max(p2.x,p2.z),dot(p2.xz,normalize(vec2(1))));\n        float r=20.;\n        cl=min(cl-r+1.,max(box(vec3(p2.x,mod(p2.y,10.)-5.,p2.z),vec3(0),vec3(r,6.,r)),cl-r));\n        cl=max(cl,p2.y-50.+float(i)*80.);\n        if(i==3)cl=max(cl,p.y+25.);\n        cl/=s;\n        if(i==2)cl=max(cl,dot(p.yz-vec2(0,25),normalize(vec2(1))));\n        d=min(d,cl);\n        p2*=2.;\n        p2.xz=mod(p2.xz,100.)-50.;\n        s*=2.;\n    }\n\n    p2=abs(p-vec3(74,0,-35));\n    float cl=max(max(p2.x,p2.z),dot(p2.xz,normalize(vec2(1))))-6.;\n    d=min(d,cl);\n\n    p2=p;\n\n    d=min(d,distance(p,vec3(0,50,0))-14.);\n\n    {\n        vec3 p2=p;\n        p2.xz=mod(p2.xz,10.)-5.;\n        p2.xz=abs(p2.xz);\n        d=min(d,p.y+52.+max(p2.x,p2.z));\n    }\n\n    {\n        vec3 p2=p;\n        p2.xz=mod(p2.xz,80.)-40.;\n        p2.xz=abs(p2.xz);\n        d=min(d,p.y+41.+max(p2.x,p2.z));\n    }\n\n    d=min(d,max(p.y+15.,p.z+60.));\n\n    d=min(d,max(box(p,vec3(0,-70,0),vec3(31)), -box(p,vec3(0,-25,0),vec3(20))));\n\n    d=min(d,box(p,vec3(0,30,19),vec3(15,9,2)));\n\n    d=max(d,box(p,vec3(0),vec3(85,64,67)));\n\n\n    p2=p;\n    for(int i=0;i<4;++i)\n    {\n        vec3 p3=p2;\n        p2.y-=cos(float(i)*9.)*23.;\n        p3.xz=min(p3.xz,1.);\n        float rr=distance(p3.xz,normalize(p3.xz)*27.)-5.;\n        d=min(d,max(rr,abs(p3.y)-2.));\n        p2.xz=p2.zx*vec2(1,-1);\n    }\n\n    d=max(d,box(p,vec3(0),vec3(85,64,67)+40.));\n\n\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 t = fragCoord.xy / iResolution.xy-.5;\n\tt.x*=iResolution.x/iResolution.y;\n    t*=1.4;\n    \n    vec3 fog=vec3(.5,.5,1);\n\n    vec2 p=t.xy;\n    vec2 ot=t;\n\n    vec3 backg=vec3(0.75,1,.75)/3.*exp(-length(ot.xy)/2.);\n\n    vec3 ro=vec3(0,-20,380.);\n    vec3 rd=vec3(p,-3.);\n\n\n    {\n        float ang=0.3-iMouse.y/iResolution.y*.5;\n        ro.yz*=mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\n        rd.yz*=mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\n    }\n\n\n    {\n        float ang=0.6-iMouse.x/iResolution.x*.5;\n        ro.xz*=mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\n        rd.xz*=mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\n    }\n\n    ro+=rd*90.;\n\n    vec3 co=ro;\n    rd=normalize(rd);\n    vec3 ord=rd;\n\n    vec3 f=vec3(1.),a=vec3(0.);\n    float s=1.;\n    vec3 n;\n    for(int j=0;j<6;++j)\n    {\n        vec3 oro=ro;\n\n        float t=0.;\n        for(int i=0;i<20;++i)\n        {\n            ro=oro+rd*t;\n            float d=dist(ro);\n            if(d<1.-4.)\n            {\n                break;\n            }\n            t+=d;\n        }\n        if(t>200.)\n        {\n            fragColor.rgb=backg;\n            fragColor.rgb+=noise(gl_FragCoord.xy)/200.;\n\n            return;\n        }\n\n\n\n        oro=ro;\n        vec3 c=floor(ro);\n        vec3 ts=(c+max(vec3(0.),sign(rd))-ro)/rd;\n\n        for(int i=0;i<25;++i)\n        {\n            n=step(ts,ts.yzx)*step(ts,ts.zxy);\n            c+=sign(rd)*n;\n            float d=dist(c);\n            vec3 dd=sign(rd)/rd*n;\n            if(d<-1.7)\n            {\n                ro=oro+rd*min(ts.x,min(ts.y,ts.z));\n                break;\n            }\n            ts+=dd;\n        }\n        ro=oro+rd*min(ts.x,min(ts.y,ts.z));\n    }\n\n    float fogstrength=.0001;\n    vec3 ld=normalize(vec3(6,-2,1.4));\n    float sh=1.;\n    {\n        ro-=rd*1e-5;\n        vec3 oro=ro;\n        vec3 rd=ld;\n        vec3 c=floor(ro);\n        vec3 ts=(c+max(vec3(0.),sign(rd))-ro)/rd,n;\n\n        for(int i=0;i<4;++i)\n        {\n            n=step(ts,ts.yzx)*step(ts,ts.zxy);\n            c+=sign(rd)*n;\n            float d=dist(c);\n            vec3 dd=sign(rd)/rd*n;\n            if(d<-1.7)\n            {\n                sh=0.;\n                break;\n            }\n            ts+=dd;\n        }\n    }\n\n    vec3 rp=floor(ro);\n    fragColor.rgb=exp(-(rp.y+68.)/8.)*vec3(.5,1.,1.)*2.*mix(.8,1.,.5+.5*cos(iTime*17.));\n\n    fragColor.rgb+=((.75+.25*dot(n*-sign(rd),ld)))*mix(.5,1.,sh)*.01;\n\n    fragColor.rgb+=smoothstep(.96,.97,abs(cos(rp.x)*cos(rp.y+5.)*cos(rp.z)));\n    fragColor.rgb+=.1*smoothstep(.96,.97,abs(cos(rp.x*8.)*cos(rp.y+5.)*cos(rp.z*9.)));\n\n    float g=mod(rp.x+floor(rp.y/20.)*4.,40.);\n    fragColor.rgb+=.01*step(abs(mod(rp.y,20.)-clamp(min(g,40.-g),10.,15.)),.5);\n\n    if(length(rp.xz)<18.5)\n        fragColor.rgb+=.003;\n\n    fragColor.rgb+=(1.-smoothstep(0.,10.,distance(rp,vec3(0.,50.,0.))-14.))*vec3(.5,1,1)*.03;\n    fragColor.rgb+=(1.-smoothstep(0.,1.,distance(rp,vec3(0.,50.,0.))-14.))*vec3(.5,1,1)*.5*clamp((rp.y-50.)/50.,0.,1.);\n\n    if(rp.y>60.)\n        fragColor.rgb+=.2;\n\n    if(rp.y<-45.)\n        fragColor.rgb+=step(.9,noise(rp))*.1;\n\n    {\n        float sd=box(rp,vec3(0,30,19),vec3(15,8,2));\n        if(sd<0.)\n            fragColor.rgb*=.1;\n    }\n\n    vec3 screencolor=vec3(1,1,.7);\n    {\n        float sd=box(rp,vec3(0,30,19),vec3(12,6,2));\n        vec3 rp2=rp-vec3(0,30,19);\n        if(sd<0.)\n            fragColor.rgb+=.5*step(1.,abs(mod(rp2.y-cos(rp2.x/1.5+iTime)*2.,5.)))*screencolor;\n    }\n\n    fragColor.rgb+=mix(.8,1.,.5+.5*cos(iTime*7.))*screencolor*10./pow(distance(rp,vec3(0,30,15)),2.)*smoothstep(0.,16.,rp.z-17.);\n\n\n    float fogamount=exp(-distance(ro,co)*fogstrength/3.);\n    fragColor.rgb=mix(vec3(.5,1,.5),fragColor.rgb,fogamount);\n\n    fragColor.rgb=sqrt(fragColor.rgb)*1.5;\n\n    fragColor.rgb=mix(fragColor.rgb,backg,smoothstep(105.,125.,length(rp.xz)));\n\n    fragColor.rgb+=noise(gl_FragCoord.xy)/200.;\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltfyD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 33, 33, 87], [89, 89, 110, 110, 149], [151, 151, 172, 172, 218], [220, 220, 241, 241, 276], [278, 278, 302, 302, 502], [504, 504, 524, 524, 2047], [2049, 2049, 2106, 2106, 5974]]}
{"id": "ltfyDn", "name": "SSS Light Study 8", "author": "aiekick", "description": "SSS Light Study 8", "tags": ["sss", "light", "study", "8"], "likes": 9, "viewed": 509, "date": "1504283283", "time_retrieved": "2024-06-20T19:00:59.708470", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2017 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\nmat3 RotZ(float a){return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\n\nvec2 path(float t)\n{\n\treturn vec2(cos(t*0.2), sin(t*0.2)) * 2.;\n}\n\nfloat coefFromRGB(vec3 rgb)\n{\n\tvec3 wl = vec3(564.,533.,437.);\n\treturn length(wl * rgb) / length(wl);\n}\n\nvec2 df(vec3 p)\n{\n\tfloat plane = p.y + 2.;\n\tp *= RotZ(p.z*0.3);\n\tp += sin(p.zxy*0.8)*2. + sin(p.xzy * 0.8)*2.;\n    p *= RotZ(p.z*-0.8);\n    float d = length(p)-3.;\n\tvec2 res = vec2(d, 2.);\n\treturn res;\n}\n\nvec3 nor( in vec3 pos, float prec )\n{\n\tvec3 eps = vec3( prec, 0., 0. );\n\tvec3 nor = vec3(\n\t    df(pos+eps.xyy).x - df(pos-eps.xyy).x,\n\t    df(pos+eps.yxy).x - df(pos-eps.yxy).x,\n\t    df(pos+eps.yyx).x - df(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// get density of the df at surfPoint\n// ratio between constant step and df value\nfloat SubDensity(vec3 surfPoint, float prec, float ms) \n{\n\tvec3 n;\n\tfloat s = 0.;\n    const int iter = 10;\n\tfor (int i=0;i<iter;i++)\n\t{\n\t\tn = nor(surfPoint,prec); \n\t\tsurfPoint = surfPoint - n * ms; \n\t\ts += df(surfPoint).x;\n\t}\n\t\n\treturn 1.-s/(ms*float(iter)); // s < 0. => inside df\n}\n\nfloat SubDensity(vec3 p, float s) \n{\n\tvec3 n = nor(p,s); \t\t\t\t\t\t\t// precise normale at surf point\n\treturn df(p - n * s).x;\t\t\t\t\t\t// ratio between df step and constant step\n}\n\n// from shane sahders\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n )\n{\n    n = max((abs(n) - .2)*7., .001);\n    n /= (n.x + n.y + n.z );  \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    return p*p;\n}\n\nvec3 shade(vec3 ro, vec3 rd, float d, vec3 lp, float li)\n{\n\tvec3 p = ro + rd * d;\t\t\t\t\t\t\t\t\t\t\t// surface point\n\tfloat sb = SubDensity(p, 0.01, 0.076);\t\t\t\t\t\t\t// deep subdensity (10 iterations)\n\tvec3 bb = blackbody(100.*sb+100.);\t\t\t\t\t\t\t\t// bb\n\tvec3 ld = normalize(lp-p); \t\t\t\t\t\t\t\t\t\t// light dir\n\tvec3 n = nor(p, 0.1);\t// normal at surface point\n    \n    // derived from bumpmap func from shane\n    const vec2 e = vec2(0.1, 0);\n    mat3 m = mat3( tex3D(iChannel0, e.xyy, n), tex3D(iChannel0, e.yxy, n), tex3D(iChannel0, e.yyx, n));\n   \tvec3 g = vec3(1) * m * 20.;\n    g -= n * dot(n, g);\n    n =  normalize( n + g );\n    \n\tvec3 refl = reflect(rd,n);\t\t\t\t\t\t\t\t\t\t// reflected ray dir at surf point \n\tfloat amb = 0.1242; \t\t\t\t\t\t\t\t\t\t\t\t// ambiance factor\n\tfloat diff = clamp( dot( n, ld ), 0.0, 1.0 ); \t\t\t\t\t// diffuse\n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 4. ); \t\t\t// fresnel\n\tfloat spe = pow(clamp( dot( refl, ld ), 0.0, 1.0 ),16.);\t\t// specular\n\tfloat sss = 1. - SubDensity(p, 7.8); \t\t\t\t\t\t\t// one step sub density of df\n\tvec3 col = (diff + fre + bb * sb * 0.608 + sss * 0.352) * amb * li + spe * 0.612;\n\t\n\treturn mix(col, vec3(1), vec3(coefFromRGB(bb*0.8+0.1*diff + 0.1 *spe)));\n}\n\nvec3 cam(vec2 uv, vec3 ro, vec3 cv, float t)\n{\n\tvec3 cu = normalize(vec3(0,1,0));\n  \tvec3 z = normalize(cv-ro);\n    vec3 x = normalize(cross(cu,z));\n  \tvec3 y= cross(z,x);\n  \treturn normalize(z + uv.x*x + uv.y*y);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    float t = -iTime*2.;\n\n    vec2 si = iResolution.xy;\n    vec2 uv = (2.*fragCoord.xy-si)/si.y;\n    \n    vec3 col = vec3(1);\n    \n\tfloat ca = iTime;\n\tfloat ce = 0.5;\n\tfloat cd = 10.;\n\t\n\tvec3 ro = vec3(cos(ca), sin(ce), sin(ca)) * cd;\n  \tvec3 cv = vec3(0);\n\tvec3 rd = cam(uv, ro, cv, t);\n       \n\tfloat md = 20.;\n    float s = 1.;\n    float d = 1.;\n\t\n\tconst float iter = 250.;\n    for(float i=0.;i<iter;i++)\n    {      \n        if (0.<log(d*d/s/1e5)||d>md) break;\n        s = df(ro+rd*d).x;\n\t\td += s *0.2;\n    }\n    \n\tif (d<md)\n\t{\n\t\tvec3 p = ro+rd*d;\n\n\t\tcol = shade(ro, rd, d, ro, 1.2);\n\t}\n\telse\n    {\n        col = vec3(0);\n    }   \n    \n\tcol = mix(col, vec3(0), 1.-exp(-0.005*d*d));\n\t\n\tfragColor.rgb = col;\n}", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltfyDn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 214, 233, 233, 291], [293, 293, 313, 313, 358], [360, 360, 389, 389, 463], [465, 465, 482, 482, 668], [670, 670, 707, 707, 919], [921, 1142, 1170, 1170, 1495], [1497, 1579, 1636, 1636, 1862], [1864, 1864, 1900, 1900, 2035], [2037, 2213, 2264, 2264, 2435], [2437, 2437, 2495, 2495, 3617], [3619, 3619, 3665, 3665, 3834], [3836, 3836, 3890, 3890, 4601]]}
{"id": "ltlcW7", "name": "Simple Things", "author": "tsone", "description": "Simple pleasures. Simple things.", "tags": ["simple", "meta", "bobby"], "likes": 1, "viewed": 92, "date": "1505149930", "time_retrieved": "2024-06-20T19:00:59.708470", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = (fragCoord.xy - .5*iResolution.xy) / iResolution.y;\n    float t = 1.7 * iTime;\n    float v = 0.0;\n    for (float i = 0.05; i < 1.0; i += 0.1) {\n        vec2 p = uv - i*vec2(cos(i*t), sin(i*t));\n    \tv += 0.005 / max(1e-6, dot(p, p));\n    }\n    v = 0.98 * sqrt(min(v, 1.0));\n\tfragColor = vec4(v);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltlcW7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 55, 55, 364]]}
{"id": "ltlcWS", "name": "running man", "author": "FisherWu", "description": "running man", "tags": ["runningman"], "likes": 0, "viewed": 77, "date": "1506428086", "time_retrieved": "2024-06-20T19:00:59.708470", "image_code": "float sdfCircle(vec2 center, float radius, vec2 coord){\n    vec2 offset = coord - center;\n    return length(offset) - radius;\n}\n\nfloat sdfLine(vec2 p0, vec2 p1, float width, vec2 coord) {\n    vec2 dir0 = p1 - p0;\n    vec2 dir1 = coord - p0;\n    float h = clamp(dot(dir0, dir1)/dot(dir0, dir0), 0.0, 1.0);\n    return (length(dir1 - dir0 * h) - width * 0.5);\n}\n\nfloat sdfUnion( const float a, const float b ) {\n    return min(a, b);\n}\n\nfloat sdfDifference( const float a, const float b) {\n    return max(a, -b);\n}\n\nfloat sdfIntersection( const float a, const float b ) {\n    return max(a, b);\n}\n\nvec4 render(float d, vec4 color){\n    vec4 target;\n    float anti = fwidth(d);\n    float s = smoothstep(-anti, anti, d);\n    target = vec4(color.rgb, 1.0-s);\n    return target;\n}\n\nfloat drawRing(vec4 fragColor, vec2 fragCoord, vec2 center){\n    vec2 uv = fragCoord / iResolution.xy;\n    float maxRadius = min(iResolution.x, iResolution.y*0.8) / 2.0;\n    float ringRadius =  min(iResolution.x, iResolution.y*0.7) / 2.0;\n\tfloat d1 = sdfCircle(center, maxRadius, fragCoord);\n    float d2 = sdfCircle(center, ringRadius, fragCoord);\n    return sdfDifference(d1, d2);\n}\n\nfloat drawSupport(vec2 fragCoord, vec2 center){\n    float d1 = sdfLine(center, vec2(iResolution.x*0.3, 0.0), 5.0, fragCoord);\n    float d2 = sdfLine(center, vec2(iResolution.x*0.7, 0.0), 5.0, fragCoord);\n    return sdfUnion(d1, d2);\n}\n\nfloat drawSroll(vec2 fragCoord, vec2 center){\n    float pi = 3.1415926;\n    float maxRadius = min(iResolution.x, iResolution.y*0.8) / 2.0;\n    float radian = iTime * (pi/1.0);\n    vec2 offset = vec2(maxRadius*cos(radian), maxRadius*sin(radian));\n    float d1 = sdfLine(center-offset, center+offset, 0.1, fragCoord);\n    \n    vec2 offset2 = vec2(maxRadius*cos(radian+pi/3.0), maxRadius*sin(radian+pi/3.0));\n    float d2 = sdfLine(center-offset2, center+offset2, 0.1, fragCoord);\n    \n    vec2 offset3 = vec2(maxRadius*cos(radian+pi/1.5), maxRadius*sin(radian+pi/1.5));\n    float d3 = sdfLine(center-offset3, center+offset3, 0.1, fragCoord);\n    \n    float u1 = sdfUnion(d1, d2);\n    return sdfUnion(d3, u1);\n\n}\n\nfloat drawMouse(vec2 coord){\n\tfloat bodyUp = sdfCircle(vec2(iResolution.x/2.0-iResolution.y*0.025, iResolution.y*0.26), iResolution.y*0.035, coord);\n    float bodyDown = sdfCircle(vec2(iResolution.x/2.0, iResolution.y*0.2), iResolution.y*0.05, coord);\n    \n    float move = mod(iTime * 30.0, 8.0) * iResolution.x*0.002;\n    vec2 pointA = vec2(iResolution.x/2.0, iResolution.y*0.2);\n    vec2 pointB =  pointA + vec2(move, -iResolution.y*0.08);\n    vec2 pointC = pointA + vec2(-move, -iResolution.y*0.08);\n    float w = iResolution.y*0.01;\n\n    float lLeg = sdfLine(pointA, pointB, w, coord);\n    float rLeg = sdfLine(pointA, pointC, w, coord);\n\n    float target = sdfUnion(bodyUp, bodyDown);\n    target = sdfUnion(target, lLeg);\n    target = sdfUnion(target, rLeg);\n    return target;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 center = iResolution.xy * .5;\n    \n\tfloat d = drawRing(fragColor, fragCoord, center);    \n    vec4 layer0 = render(d, vec4(0, 1, 0, 1));\n    \n    d = drawSupport(fragCoord, center);\n    vec4 layer1 = render(d, vec4(1, 0, 0, 1));\n    \n    d = drawSroll(fragCoord, center);\n    vec4 layer2 = render(d, vec4(1, 1, 0, 1));\n    \n    d = drawMouse(fragCoord);\n    vec4 layer3 = render(d, vec4(0, 0, 1, 1));\n    \n    fragColor = vec4(0,0,0,1);\n    fragColor = mix(fragColor, layer0, layer0.a);\n    fragColor = mix(fragColor, layer1, layer1.a);\n    fragColor = mix(fragColor, layer2, layer2.a);\n    fragColor = mix(fragColor, layer3, layer3.a);\n\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltlcWS.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 55, 55, 127], [129, 129, 187, 187, 358], [360, 360, 408, 408, 432], [434, 434, 486, 486, 511], [513, 513, 568, 568, 592], [594, 594, 627, 627, 772], [774, 774, 834, 834, 1158], [1160, 1160, 1207, 1207, 1394], [1396, 1396, 1441, 1441, 2105], [2107, 2107, 2135, 2135, 2892], [2895, 2895, 2952, 2952, 3603]]}
{"id": "ltlczB", "name": "Watch me model Pepe to sad music", "author": "MathEin", "description": "An emotional journey.\nI cri evritim. \n\nMy very first SDF (Sad Distance Frog) renderer.", "tags": ["sdf", "sad", "meme", "pepe", "verysad", "saddest"], "likes": 15, "viewed": 366, "date": "1505462151", "time_retrieved": "2024-06-20T19:01:01.900565", "image_code": "const vec3 ColourSkin = vec3(0.25,0.5,0.2)*vec3(0.25,0.5,0.2);\nconst vec3 ColourLips = vec3(0.56,0.28,0.2)*vec3(0.56,0.28,0.2);\nconst vec3 ColourWhite = vec3(1.0);\nconst vec3 ColourBlack = vec3(0.0);\nconst float MaterialInnerEye = 1.0;\nconst float MaterialOuterEye = 0.0;\nconst float MaterialSkin = 2.0;\nconst float MaterialLips = 3.0;\n\nconst vec3 LightColour = vec3(1.0,1.0,0.8);\n\nconst float timeStartEyeDetail = 3.2;\nconst float timeStartMouthDetail = 9.6;\n\n\n// Generic SDF stuff (obviously not by me)\nfloat Sphere(vec3 point, vec3 center, float radius) \n{\n    return length(point - center) - radius;\n}\nfloat Ellipsoid( in vec3 p, vec3 center, in vec3 r )\n{\n    return (length( (p-center)/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\nfloat Capsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n// http://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf\nfloat det( vec2 a, vec2 b ) { return a.x*b.y-b.x*a.y; }\nvec3 getClosest( vec2 b0, vec2 b1, vec2 b2 ) \n{\n    float a =     det(b0,b2);\n    float b = 2.0*det(b1,b0);\n    float d = 2.0*det(b2,b1);\n    float f = b*d - a*a;\n    vec2  d21 = b2-b1;\n    vec2  d10 = b1-b0;\n    vec2  d20 = b2-b0;\n    vec2  gf = 2.0*(b*d21+d*d10+a*d20); gf = vec2(gf.y,-gf.x);\n    vec2  pp = -f*gf/dot(gf,gf);\n    vec2  d0p = b0-pp;\n    float ap = det(d0p,d20);\n    float bp = 2.0*det(d10,d0p);\n    float t = clamp( (ap+bp)/(2.0*a+b+d), 0.0 ,1.0 );\n    return vec3( mix(mix(b0,b1,t), mix(b1,b2,t),t), t );\n}\nvec4 Bezier( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n\tvec3 w = normalize( cross( c-b, a-b ) );\n\tvec3 u = normalize( c-b );\n\tvec3 v = normalize( cross( w, u ) );\n\n\tvec2 a2 = vec2( dot(a-b,u), dot(a-b,v) );\n\tvec2 b2 = vec2( 0.0 );\n\tvec2 c2 = vec2( dot(c-b,u), dot(c-b,v) );\n\tvec3 p3 = vec3( dot(p-b,u), dot(p-b,v), dot(p-b,w) );\n\n\tvec3 cp = getClosest( a2-p3.xy, b2-p3.xy, c2-p3.xy );\n\n\treturn vec4( sqrt(dot(cp.xy,cp.xy)+p3.z*p3.z), cp.z, length(cp.xy), p3.z );\n}\n\nfloat UnionRound( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\nvec2 UnionRound( vec2 a, vec2 b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b.x-a.x)/k, 0.0, 1.0 );\n\treturn vec2( mix( b.x, a.x, h ) - k*h*(1.0-h), mix( b.y, a.y, h ) );\n}\nfloat Union( float a, float b )\n{\n    return min( a, b );\n}\nvec2 Union( vec2 a, vec2 b )\n{\n    return vec2(min( a.x, b.x ), b.y);\n}\n\n\nfloat SubstractRound( float a, float b, float r ) \n{\n\tvec2 u = max( vec2( r + a, r - b ), vec2( 0.0, 0.0 ) );\n\treturn min( -r, max( a, -b ) ) + length( u );\n}\nvec2 SubstractRound( vec2 a, vec2 b, float r )\n{\n\treturn vec2(SubstractRound(a.x,b.x,r), SubstractRound(a.y,b.y,r));\n}\n\n\n// Animation stuff\nfloat DO(float value, float t, float minT)\n{\n    float dt = clamp(t-minT,0.0,1.0);\n\treturn mix(3.0,value, dt); \n}\nvec2 DO(vec2 value, float t, float minT)\n{\n\treturn vec2(DO(value.x, t, minT),value.y);\n}\n\n\n// Pepe SDF\nvec2 doEye(vec3 P, float t)\n{\n    float outerSocket = Ellipsoid( P, vec3(0.25,0.35,0.6), vec3(0.6,0.4,0.5));\n    float innerSocket = Ellipsoid( P, vec3(0.25,0.37,0.75), vec3(0.5,0.22,0.4));\n    vec2 innerEye = vec2(Ellipsoid( P, vec3(0.26,0.35,0.8), vec3(0.4,0.2,0.36)), MaterialInnerEye);\n    vec2 outerEye = vec2(Ellipsoid( P, vec3(0.25,0.37,0.75), vec3(0.5,0.22,0.4)), MaterialOuterEye);\n    \n    outerSocket = DO(outerSocket, t, timeStartEyeDetail);    \n    innerSocket = DO(innerSocket, t, timeStartEyeDetail+1.6);\n    innerEye = DO(innerEye, t, timeStartEyeDetail+2.4);\n    outerEye = DO(outerEye, t, timeStartEyeDetail+3.2);\n    \n    vec2 eyeSocket = vec2(SubstractRound(\n        outerSocket,\n        innerSocket,\n        0.05 ), MaterialSkin);\n    vec2 eye = UnionRound(innerEye, outerEye, 0.001);\n\n    // Eyelid detail\n    const float eyelidHeight = 0.58;\n    const float eyelidThickness = 0.05;\n    \n    vec3 a = vec3(0.0,eyelidHeight-0.05,1.0);\n    vec3 b = vec3(0.5,eyelidHeight,1.0);\n    vec3 c = vec3(0.7,eyelidHeight-0.15,0.85);\n    vec4 eyeLidA = Bezier( P, a, b, c );\n    vec2 eyelidDetailA = vec2(eyeLidA.x-eyelidThickness, MaterialSkin);\n    \n    a = vec3(0.0,eyelidHeight-0.43,1.0);\n    b = vec3(0.5,eyelidHeight-0.47,1.1);\n    c = vec3(0.7,eyelidHeight-0.3,0.85);\n    vec4 eyeLidB = Bezier( P, a, b, c );\n    vec2 eyelidDetailB = vec2(eyeLidB.x-eyelidThickness, MaterialSkin);   \n    \n    \n    eyelidDetailA = DO(eyelidDetailA, t, timeStartEyeDetail+4.0);\n    eyelidDetailB = DO(eyelidDetailB, t, timeStartEyeDetail+4.8);\n    vec2 eyelidDetail = UnionRound(eyelidDetailA, eyelidDetailB, 0.01);\n    \n    return UnionRound(UnionRound(eye,eyeSocket,0.01), eyelidDetail, 0.05);\n}\n\nvec2 doMouth( vec3 P, float t )\n{    \n    float thickness = 0.1;\n    float mouthHeight = -0.3;\n    float bottomMouthHeight = mouthHeight-0.1;\n    \n    vec3 a = vec3(0.0,mouthHeight,1.3);\n    vec3 b = vec3(0.3,mouthHeight,1.3);\n    vec3 c = vec3(0.6,mouthHeight+0.05,1.1);\n    vec4 mouthBezierA = Bezier( P, a, b, c );\n    \n    b = c + (c-b); a = c;\n    c = vec3(1.0,mouthHeight-0.2,0.50);\n    vec4 mouthBezierB = Bezier( P, a, b, c );\n    \n    float topMouthA = mouthBezierA.x - thickness;\n    float topMouthB = mouthBezierB.x-thickness;\n    topMouthA = DO(topMouthA, t, timeStartMouthDetail);\n    topMouthB = DO(topMouthB, t, timeStartMouthDetail+0.8);\n    \n    float topMouth = Union(topMouthA, topMouthB);\n    \n    a = vec3(0.0,bottomMouthHeight,1.3);\n    b = vec3(0.3,bottomMouthHeight,1.3);\n    c = vec3(0.6,bottomMouthHeight+0.05,1.1);\n    vec4 mouthBezierC = Bezier( P, a, b, c );\n    \n    b = c + (c-b); a = c;\n    c = vec3(1.0,mouthHeight-0.2,0.50);\n    vec4 mouthBezierD = Bezier( P, a, b, c );  \n    \n    float bottomMouthA = mouthBezierC.x - thickness;\n    float bottomMouthB = mouthBezierD.x - thickness;    \n    bottomMouthA = DO(bottomMouthA, t, timeStartMouthDetail+1.6);\n    bottomMouthB = DO(bottomMouthB, t, timeStartMouthDetail+2.4);\n    \n    float bottomMouth = Union(bottomMouthA,bottomMouthB);\n    \n    vec2 fullLips = vec2(Union(topMouth, bottomMouth), MaterialLips);\n    \n    return fullLips;\n}\nvec2 doMouthDetail(vec3 P, float t)\n{\n    float mouthHeight = -0.4;\n    vec3 a = vec3(0.95,mouthHeight+0.1,0.4);\n    vec3 b = vec3(1.15,mouthHeight,0.3);\n    vec3 c = vec3(0.95,mouthHeight-0.2,0.4);\n    vec4 detailBezier = Bezier( P, a, b, c );\n    float detail = detailBezier.x - 0.1;    \n    detail = DO(detail, t, timeStartMouthDetail+3.2);    \n    \n    return vec2(detail, MaterialSkin);\n}\n\nvec2 doPepe(vec3 P, float t)\n{\n    vec3 symmetricP = vec3(abs(P.x), P.y, P.z);\n    \n    vec2 mainHead = vec2(Ellipsoid( P, vec3(0.0,0.0,0.05), vec3(1.0,0.8,1.0)), MaterialSkin);\n    //return mainHead;\n    vec2 bottomHead = vec2(Ellipsoid( P, vec3(0.0,-0.35,0.15), vec3(0.75,0.5,0.75)*1.5), MaterialSkin);\n    vec2 backHead = vec2(Ellipsoid( P, vec3(0.0,-0.4,-0.35), vec3(1.0,0.8,0.75)), MaterialSkin);\n    \n    \n    vec2 eyeSocket = vec2(Ellipsoid( symmetricP, vec3(0.25,0.5,0.2), vec3(0.6,0.6,0.6)), MaterialSkin);\n\tvec2 eye = doEye(symmetricP, t);\n    \n    vec2 mouth = doMouth(symmetricP, t);\n    vec2 mouthDetail = doMouthDetail(symmetricP, t);\n    \n    mainHead = DO(mainHead, t, 0.0);\n    bottomHead = DO(bottomHead, t, 0.8);\n    backHead = DO(backHead, t, 1.6);\n    eyeSocket = DO(eyeSocket, t, 2.4);\n\n    \n    vec2 fullHead = UnionRound(\n        UnionRound(mainHead,bottomHead,0.1), \n        backHead, 0.2);\n    fullHead = UnionRound(fullHead, mouthDetail, 0.1);\n\n    \n    return UnionRound(\n        \t\tUnionRound(\n            \t\tUnionRound(fullHead,eyeSocket,0.1), \n            \t\tmouth, 0.01),\n        \t\teye, 0.05); \n}\n\nvec2 Scene( vec3 P )\n{\n\treturn doPepe(P, iTime);\n}\n\nvec3 SceneNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.01, 0.0, 0.0 );\n\tvec3 normal = vec3(\n\t    Scene( pos + eps.xyy ).x - Scene( pos - eps.xyy ).x,\n\t    Scene( pos + eps.yxy ).x - Scene( pos - eps.yxy ).x,\n\t    Scene( pos + eps.yyx ).x - Scene( pos - eps.yyx ).x );\n\treturn normalize( normal );\n}\n\n// Ray marching stuff from iq\nfloat calcSoftShadow( in vec3 ro, in vec3 rd, float k )\n{  \n    float res = 1.0;\n    float t = 0.01;\n    for( int i=0; i<32; i++ )\n    {\n        float h = Scene(ro + rd*t ).x;\n        res = min( res, smoothstep(0.0,1.0,k*h/t) );\n        t += clamp( h, 0.004, 0.1 );\n\t\tif( res<0.001 ) break;\n    }\n    return clamp(res*res,0.0,1.0);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    const float maxd = 10.0;\n    \n\tvec2 h = vec2(1.0,0.0);\n    vec2 t = vec2(0.0);\n   \n    for ( int i = 0; i < 50; ++i )\n    {\n        if ( h.x < 0.001 || t.x > maxd ) \n        {\n            break;\n        }\n        \n\t    h = Scene( ro + rd * t.x );\n        t = vec2(t.x+h.x, h.y);\n    }\n\n    if ( t.x > maxd )\n    {\n        t.x = -1.0;\n    }\n\t\n    return t;\n}\n\nfloat rainAmount(vec2 frag)\n{\n    // Rain from: https://www.shadertoy.com/view/XdSGDc\n    \n\tfloat dis = 1.;\n    \n    float result = 0.0;\n\tfor (int i = 0; i < 8; i++)\n\t{\n\n\t\t\tfloat f = pow(dis, .145)+.25;\n\n\t\t\tvec2 st =  f * (frag * vec2(1.5, .05)+vec2(-iTime*.1+frag.y*.5, iTime*.12));\n\t\t\tf = (texture(iChannel3, st * .5, -99.0).x + texture(iChannel3, st*.284, -99.0).y);\n\t\t\tf = clamp(pow(abs(f)*.5, 29.0) * 140.0, 0.00, frag.y*.4+.05);\n\n\t\t\tresult += 0.25*f;\n\t\t\n\t\tdis += 3.5;\n\t}    \n    \n    return result;\n}\n\nvec3 doAtmosphere(vec3 colour, \n                  vec2 frag,\n                  vec3 O, vec3 D, float rayDist)\n{\n    // cone light from https://www.shadertoy.com/view/llBGzm\n    \n    vec3 lightPos = vec3(-0.2, 6.0, -0.3);\n    float intensity = 10.0;\n    \n    float originAlong = dot(lightPos - O, D); \n    vec3 originNearest = O + D * originAlong;\n\n    vec3 normal = vec3(0.0, -1, 0.0);\n    intensity *= pow(max(0.0, dot(normal, normalize(originNearest - lightPos))), 10.0); \n    intensity /= pow(1.0 + distance(lightPos, originNearest) * 1.1, 2.0); \n    \n    float rain = rainAmount(frag)*0.8+0.2;\n    colour += rain*LightColour*intensity;\n    \n    return colour;\n}\n\n\n\n\n// Specular from http://filmicworlds.com/blog/optimizing-ggx-shaders-with-dotlh/\nvec2 ggx_fv(float LoH, float a)\n{\n    float LoH5 = pow(1.0- LoH, 5.0);\n    \n    float k = a*0.5;\n    float k2 = k*k;\n    float ik2 = 1.0-k2;\n    float vis = 1.0/(LoH*LoH*ik2+k2);\n    \n    return vec2(vis, LoH5*vis);\n}\nfloat ggx_d(float NoH, float alpha)\n{\n    float alphaSqr = alpha*alpha;\n    float denom = NoH*NoH*(alphaSqr-1.0)+1.0;\n    return alphaSqr/(3.14159*denom*denom);\n}\nfloat shade_specular(vec3 N, vec3 V, vec3 L, float roughness, float F0)\n{\n    vec3 H = normalize(-V+L);\n    float LoH = clamp(dot(L,H),0.0,1.0);\n    float NoH = clamp(dot(N,H),0.0,1.0);\n    float NoL = clamp(dot(L,N),0.0,1.0);  \n    \n    float alpha = roughness*roughness;\n\tfloat D = ggx_d(NoH, alpha);\n    vec2 fv = ggx_fv(LoH, alpha);\n    float FV = F0*fv.x + (1.0-F0)*fv.y;\n    //return D;\n    return NoL*D*FV;\n}\n\nvec3 shade(vec3 V, vec3 P, vec3 N, float material)\n{\n    vec3 R = reflect(V, N);\n    \n    vec3 diffuseLighting = vec3(0.0);\n    vec3 specularLighting = vec3(0.0);\n    \n    // Material parameters\n    vec3 albedo = mix( ColourWhite, ColourBlack, smoothstep(MaterialOuterEye, MaterialInnerEye, material));\n    albedo = mix( albedo, ColourSkin, smoothstep(MaterialInnerEye, MaterialSkin, material));\n    albedo = mix( albedo, ColourLips, smoothstep(MaterialSkin, MaterialLips, material)); \n    float roughness = 0.5*clamp((smoothstep(0.0, MaterialSkin, material))+0.1, 0.0, 1.0);\n    \n    // Lighting\n    float NoV = clamp(-dot(N, V),0.0,1.0);\n    float fresnel = 0.04+0.8*pow(1.0-NoV, 5.0);    \n    \n    {\n        vec3 lightDirection = normalize(vec3(-0.3,1.0,0.1));\n        vec3 L = lightDirection;\n        float NoL = clamp(dot(L,N),0.0,1.0);\n        float shadow = 3.0*NoL*calcSoftShadow(P+N*0.05, lightDirection, 3.0);\n        diffuseLighting += LightColour*shadow;\n        specularLighting += LightColour*shade_specular(N,V,L, roughness, 0.04);\n        \n    }\n        \n    diffuseLighting += 0.1*mix( vec3(1.0,0.71,0.51 )*0.5, LightColour*2.0, N.y*0.5+0.5 ); // ambient light\n    \n    // Outlines\n    float outerEdge = pow(smoothstep(0.0,0.2, NoV), 4.0);\n    float materialEdge = abs(fract(material)-0.5)*2.0;\n    float edge = (outerEdge*materialEdge)*0.8+0.2;    \n    \n    return (albedo*diffuseLighting + specularLighting)*edge;\n}\n\nvec3 render( vec2 uv, in vec3 ro, in vec3 rd )\n{ \n    vec3 colour = vec3(0.0);\n    \n    vec3 V = rd;\n    vec2 hit = castRay(ro, rd);\n    float depth = hit.x;\n    if(hit.x>0.0)\n    {\n        vec3 pos = ro + hit.x * rd;\n        vec3 normal = SceneNormal( pos );\n        colour = shade(rd, \n                       pos, normal, hit.y);\n    }\n    else\n    {\n        depth = 100.0;\n    }\n    \n    \n    colour = doAtmosphere(colour, \n                          uv,\n                          ro, rd, depth);\n    return colour;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    \n    vec2 mo = iMouse.xy/iResolution.xy;\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    \n    // camera\t\n    vec3 ro = vec3( 3.5*cos(6.0*mo.x+iTime*0.1), 2.0*mo.y+0.2, 3.0 + 4.0*sin(6.0*mo.x) );\n    vec3 ta = vec3( 0.0, -0.1, 0.5 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    // ray direction\n    vec3 rd = ca * normalize( vec3(p.xy,2.0) ); \n    \n    vec3 colour = render(uv, ro, rd);\n    colour = pow(colour, vec3(0.4545));\n    \n    fragColor.rgb = colour;\n}", "image_inputs": [{"id": "XsX3zn", "previewfilepath": "/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "MslSWX", "previewfilepath": "https://soundcloud.com/unikofficial/sad-violin-melody-air-horn-full", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/unikofficial/sad-violin-melody-air-horn-full", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltlczB.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[462, 505, 559, 559, 605], [606, 606, 660, 660, 729], [730, 730, 780, 780, 907], [908, 972, 1001, 1001, 1027], [1028, 1028, 1075, 1075, 1553], [1554, 1554, 1601, 1601, 2011], [2013, 2013, 2060, 2060, 2149], [2150, 2150, 2194, 2194, 2319], [2320, 2320, 2353, 2353, 2379], [2380, 2380, 2410, 2410, 2451], [2454, 2454, 2506, 2506, 2612], [2613, 2613, 2661, 2661, 2731], [2734, 2753, 2797, 2797, 2866], [2867, 2867, 2909, 2909, 2955], [2958, 2970, 2999, 2999, 4666], [4668, 4668, 4701, 4701, 6087], [6088, 6088, 6125, 6125, 6481], [6483, 6483, 6513, 6513, 7608], [7610, 7610, 7632, 7632, 7660], [7662, 7662, 7695, 7695, 7959], [7961, 7991, 8048, 8048, 8324], [8326, 8326, 8366, 8366, 8728], [8730, 8730, 8759, 8815, 9236], [9238, 9238, 9349, 9410, 9903], [9908, 9989, 10022, 10022, 10206], [10207, 10207, 10244, 10244, 10369], [10370, 10370, 10443, 10443, 10785], [10787, 10787, 10839, 10839, 12221], [12223, 12223, 12271, 12271, 12742], [12744, 12744, 12796, 12796, 12973], [12975, 12975, 13032, 13032, 13641]]}
{"id": "ltlyzj", "name": "Swallowtail catastrophe", "author": "dpiponi", "description": "A close up of diffraction at a swallowtail caustic.\nUse mouse to scale.\n\nFor some background see [url]https://github.com/dpiponi/caustics[/url]", "tags": ["optics"], "likes": 7, "viewed": 494, "date": "1505575161", "time_retrieved": "2024-06-20T19:01:02.429763", "image_code": "#if __VERSION__ < 130\n\nfloat tanh(float x) {\n    if (x < -12.0) {\n        return -1.0;\n    }\n    if (x > 12.0) {\n        return 1.0;\n    }\n    float p = exp(2.0*x);\n    return (p-1.0)/(p+1.0);\n}\n\nfloat cosh(float x) {\n    float p = exp(2.0*x);\n    return (1.0+p)/(2.0*p);\n}\n\n#endif\n\nvec2 ctimes(vec2 a, vec2 b) {\n    return mat2(a, -a.y, a.x)*b;\n}\n\nvec2 cexp(vec2 a) {\n    float r = exp(a.x);\n    return r*vec2(cos(a.y), sin(a.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Bands towards lower left and right are \"aliasing\" due to the\n    // sampling used in the integration. Bump up M to improve.\n    // M needs to be odd.\n#define M 197\n    float rate = 0.005;\n    \n    float xmax = 20.0+iMouse.x/iResolution.x*80.0;\n    float xmin = -xmax;\n    float ymax = xmax+15.0;\n    float ymin = xmin+15.0;\n    \n    float gamma = -3.75+5.75*sin(iTime);\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float alpha = ymin+uv.y*(ymax-ymin);\n    float beta = xmin+uv.x*(xmax-xmin);\n\n    //int k;\n    vec2 integral = vec2(0.0, 0.0);\n    \n    float coeff;\n    int odd = 1;\n    float x = -4.0;\n    float dx = 8.0/float(M);\n    \n    // We're computing integral from -infinity to infinity\n    // of exp(i*(z^5+gamma*x^3+2*beta*x+alpha))\n    // It's highly oscillatory so we deform the contour to one\n    // that is better behaved.\n    \n    for (int k = 0; k <= M; ++k) {\n        odd = 1-odd;\n        // Simpson's integration rule\n        if (k == 0 || k == M) {\n            coeff = 1.0;\n        } else {\n            if (odd == 1) {\n                coeff = 4.0;\n            } else {\n                coeff = 2.0;\n            }\n        }\n        float x2 = x*x;\n        float x3 = x*x2;\n        float x4 = x*x3;\n        \n        float u = rate*(5.0*x4+3.0*gamma*x2+2.0*beta*x+alpha);\n    \tfloat y = tanh(u);\n        \n        // Compute deformation of contour\n        vec2 z = vec2(x, y);\n        vec2 z2 = ctimes(z, z);\n        vec2 z3 = ctimes(z2, z);\n        vec2 z4 = ctimes(z3, z);\n        vec2 z5 = ctimes(z4, z);\n\n        vec2 f = z5+gamma*z3+beta*z2+alpha*z;\n        // Compute integrand\n\t\tvec2 g = cexp(vec2(-f.y, f.x));\n       \n        float d = cosh(u);\n        vec2 dz = dx*vec2(1.0, rate*(20.0*x3+6.0*gamma*x+2.0*beta)/(d*d));      \n\n        // Accumulate integral\n \t\tintegral += coeff*ctimes(g, dz);\n\n        \n     \tx += dx;\n   }\n   \n    float value = 0.5*length(integral)/(3.0);\n    \n    fragColor = vec4(value);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltlyzj.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[283, 283, 312, 312, 347], [349, 349, 368, 368, 433], [435, 435, 492, 649, 2441]]}
{"id": "ltscDX", "name": "Fun.", "author": "marcthenarc", "description": "Still exploring The Book of Shaders and basic 2D forms.", "tags": ["procedural", "2d"], "likes": 1, "viewed": 119, "date": "1506777294", "time_retrieved": "2024-06-20T19:01:02.629777", "image_code": "const float GRID = 5.;\nconst float DIV = 0.5 / GRID;\n\nfloat random (vec2 st)\n{\n    return fract(sin(dot(st.xy,\n        vec2(12.9898,78.233))) *\n        43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy / iResolution.y;\n\n    st += iTime * 0.05;\n\n    vec2 fpos = floor(st * GRID) / GRID;\n\n    // Used as RED component and for variation amongst cells.\n    float r = random(fpos);\n\n    vec3 c = vec3(r,\n        random(fpos + 1.),\n        random(fpos + 2.));\n        \n    if (distance(st, fpos + DIV) < DIV / 2. * (sin(iTime * 2. * r) * 0.5 + 1.))\n        c = 1. - c;\n\n    fragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltscDX.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[54, 54, 78, 78, 169], [171, 171, 228, 228, 649]]}
{"id": "ltscW4", "name": "Pyramid Forest", "author": "KilledByAPixel", "description": "Using my pixel fractal code to make a different kind of infinite zoom. Colors are generated symmetrically along the 45 degree line so it's rotated 45 degrees to make it center symmetric.", "tags": ["fractal", "zoom", "pixel", "recursive"], "likes": 19, "viewed": 569, "date": "1504898011", "time_retrieved": "2024-06-20T19:01:03.472472", "image_code": "//////////////////////////////////////////////////////////////////////////////////\n// Pixel Shrink Zoom - Copyright 2017 Frank Force\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//////////////////////////////////////////////////////////////////////////////////\n\nconst float zoomSpeed\t\t\t= 1.0;\t// how fast to zoom (negative to zoom out)\nconst float zoomScale\t\t\t= 0.3;\t// how much to multiply overall zoom (closer to zero zooms in)\nconst int recursionCount\t\t= 6;\t// how deep to recurse\nconst int glyphSize\t\t\t\t= 3;\t// width & height of glyph in pixels\nconst float curvature\t\t\t= 0.6;\t// time warp to add curvature\n\n//////////////////////////////////////////////////////////////////////////////////\n// Precached values and math\n\nconst float glyphSizeF = float(glyphSize);\nconst float glyphSizeLog = log(glyphSizeF);\nconst float e = 2.718281828459;\nconst float pi = 3.14159265359;\n\nfloat RandFloat(int i) { return (fract(sin(float(i)) * 43758.5453)); }\nint RandInt(int i) { return int(100000.0*RandFloat(i)); }\n\nvec3 HsvToRgb(vec3 c) \n{\n    float s = c.y * c.z;\n    float s_n = c.z - s * .5;\n    return vec3(s_n) + vec3(s) * cos(2.0 * pi * (c.x + vec3(1.0, 0.6666, .3333)));\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n// Color and image manipulation\n\nfloat GetRecursionFade(int r, float timePercent)\n{\n    if (r > recursionCount)\n        return timePercent;\n    \n    // fade in and out recusion\n    float rt = max(float(r) - timePercent, 0.0);\n    float rc = float(recursionCount);\n    return rt / rc;\n}\n\nvec3 InitPixelColor() { return vec3(0); }\nvec3 CombinePixelColor(vec3 color, float timePercent, int i, int r, vec2 pos, ivec2 glyphPos, ivec2 glyphPosLast)\n{\n    i = (i+r) + (glyphPosLast.x + glyphPosLast.y + glyphPos.x + glyphPos.y);\n\n    vec3 myColor = vec3\n    (\n    \tmix(-0.3, 0.3, RandFloat(i)),\n    \tmix(0.0, 0.6, RandFloat(i + 10)),\n        mix(0.0, 0.6, RandFloat(i + 20))\n    );\n\n    // combine with my color\n    float f = GetRecursionFade(r, timePercent);\n    myColor.y = pow(myColor.y, 2.0);\n    myColor.z = pow(myColor.z, 2.0);\n    color += myColor*f;\n    return color;\n}\n\nvec3 FinishPixel(vec3 color, vec2 uv)\n{\n    // color wander\n    color.x += 0.01*iTime;\n    \n    // convert to rgb\n    color = HsvToRgb(color);\n    return color;\n}\n\nvec2 InitUV(vec2 uv)\n{\n    float theta = 7.0*pi/4.0;\n\tfloat c = cos(theta);\n\tfloat s = sin(theta);\n\tuv = vec2((uv.x*c - uv.y*s), (uv.x*s + uv.y*c));\n    return uv;\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n// Fractal functions\n\nivec2 GetFocusPos(int i) { return ivec2(glyphSize/2); }\n      \n// get color of pos, where pos is 0-1 point in the glyph\nvec3 GetPixelFractal(vec2 pos, int iterations, float timePercent)\n{\n\tivec2 glyphPosLast = GetFocusPos(-2);\n\tivec2 glyphPos =     GetFocusPos(-1);\n\tvec3 color = InitPixelColor();\n    \n\tfor (int r = 0; r <= recursionCount + 1; ++r)\n\t{\n        color = CombinePixelColor(color, timePercent, iterations, r, pos, glyphPos, glyphPosLast);\n        if (r > recursionCount)\n\t\t\treturn color;\n           \n        // update pos\n        pos *= glyphSizeF;\n\n        // get glyph and pos within that glyph\n        glyphPosLast = glyphPos;\n        glyphPos = ivec2(pos);\n        \n        // next glyph\n\t\tpos -= vec2(floor(pos));\n\t}\n}\n \n//////////////////////////////////////////////////////////////////////////////////\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// use square aspect ratio\n\tvec2 uv = fragCoord;\n\tuv = fragCoord / iResolution.y;\n\tuv -= vec2(0.5*iResolution.x / iResolution.y, 0.5);\n    uv = InitUV(uv);\n    \n    // time warp\n    float time = iTime + curvature*length(uv);\n    \n    // BigWIngs - spinning\n    //float s = sin(time);\n\t//float c = cos(time);\n\t//uv *= mat2(-s, c, c, s);\n    \n\t// get time \n\tfloat timePercent = time*zoomSpeed;\n\tint iterations = int(floor(timePercent));\n\ttimePercent -= float(iterations);\n\t\n\t// update zoom, apply pow to make rate constant\n\tfloat zoom = pow(e, -glyphSizeLog*timePercent);\n\tzoom *= zoomScale;\n    \n\t// get offset\n\tvec2 offset = vec2(0);\n    const float gsfi = 1.0 / glyphSizeF;\n\tfor (int i = 0; i < 13; ++i)\n\t\toffset += (vec2(GetFocusPos(i)) * gsfi) * pow(gsfi,float(i));\n    \n\t// apply zoom & offset\n    vec2 uvFractal = uv * zoom + offset;\n\t\n\t// check pixel recursion depth\n\tvec3 pixelFractalColor = GetPixelFractal(uvFractal, iterations, timePercent);\n    pixelFractalColor = FinishPixel(pixelFractalColor, uv);\n    \n\t// apply final color\n\tfragColor = vec4(pixelFractalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltscW4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[653, 918, 942, 942, 988], [989, 989, 1009, 1009, 1046], [1048, 1048, 1072, 1072, 1212], [1214, 1330, 1380, 1380, 1582], [1584, 1584, 1607, 1607, 1625], [1626, 1626, 1741, 1741, 2167], [2169, 2169, 2208, 2228, 2331], [2333, 2333, 2355, 2355, 2498], [2500, 2605, 2631, 2631, 2660], [2668, 2725, 2792, 2792, 3341], [3344, 3429, 3486, 3514, 4571]]}
{"id": "ltscW8", "name": "Basic Raymarching - Viroids", "author": "CaliCoastReplay", "description": "Using my raymarcher on the viroid from :  http://www.michaelwalczyk.com/blog/2017/5/25/ray-marching .  Looks like plastic blood proteins.  My method seems to be useful for shiny materials.  EDIT:  Added colored lights!", "tags": ["raymarching", "abstract"], "likes": 8, "viewed": 611, "date": "1504661698", "time_retrieved": "2024-06-20T19:01:04.351262", "image_code": "//Learning from : http://www.michaelwalczyk.com/blog/2017/5/25/ray-marching\n\n//Contains some experimental terms to simulate global illumination\n//on backside of object via a variation\n//on specular highlights, and the use of Fresnel terms\n//for both light and shadow on the outside of objects.\n\n//Comments encouraged - code will be commented for teaching purposes soon.\n\n//--CaliCoastReplay\n\n//Returns the distance from a world point to a sphere defined by a center and radius.\n//Used in this example to \"map the world\" by returning distances to the viroid forms\n//from points along the marched rays.\nfloat distance_from_sphere(in vec3 world_point, in vec3 sphere_center, float radius)\n{\n    return length(world_point - sphere_center) - radius;\n}\n\n\t\n//Polynomial smooth minimum by Inigo Quilez.\n//Used in this case to \"join\" the two viroids into a metaball - a normal minimum would return\n//unjoined surface data.\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n//Distance to the closest world object from a given point p along the raymarcher.  \n//Used in this example to \"map the world\" - see above.\nfloat distance_to_closest_object(in vec3 p)\n{\n    \n    float sphere_0 = distance_from_sphere(p, vec3(-0.5 + cos(iTime), -0.5+cos(iTime), sin(iTime)), 2.0);    \n    float sphere_1= distance_from_sphere(p, vec3(.5+ sin(iTime), 0.5 + sin(iTime), cos(iTime)), 2.0);\n    \n    float displacement0 = sin(-3.0  * p.x) * sin(1.5 *  p.y) * sin(2.0 * p.z) * 0.25;\n    float displacement1 = cos(3.0 *   p.x) * cos(1.5 *  p.y) * cos(2.0 * p.z) * 0.5;\n\n    return smin(sphere_0 + displacement0, sphere_1 + displacement1, .7);\n   // return smin(sphere_0, sphere_1, .7);  //switch with this for simple spheres instead\n}\n\n//Estimates the normal vector (the vector perpendicular to the surface) at any given world point\n//representing a surface.  Should only be used at world points representing collisions.  Samples\n//the world at six more points bounding the world point along the three primary world axes (x, y, \n//and z) and then uses that data to estimate the normal there.\nvec3 calculate_normal(in vec3 world_point)\n{\n    const vec3 small_step = vec3(0.0025, 0.0, 0.0);\n\n    float gradient_x = distance_to_closest_object(world_point + small_step.xyy)\n        - distance_to_closest_object(world_point - small_step.xyy);\n    float gradient_y = distance_to_closest_object(world_point + small_step.yxy) \n        - distance_to_closest_object(world_point - small_step.yxy);\n    float gradient_z = distance_to_closest_object(world_point + small_step.yyx) \n        - distance_to_closest_object(world_point - small_step.yyx);\n\n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n\n    return normalize(normal);\n}\n\n//The actual raymarcher.  \"Marches\" a ray along a direction vector, starting at an eye/camera\n//point, by adding that direction vector to the origin, and repeating that until it either\n//hits something, travels a certain number of steps, or reaches a maximum distance.  If it hits\n//a surface, it calculates the surface normal at that point, and uses that normal to calculate\n//the lighting according to a modified Phong shading model.\nvec4 ray_march(in vec3 ray_origin, in vec3 ray_direction)\n{\n    float total_distance_traveled = 0.0;\n    const int NUMBER_OF_STEPS = 64;\n    const float MINIMUM_HIT_DISTANCE = 0.001;\n    const float MAXIMUM_TRACE_DISTANCE = 1000.0;\n\n    for (int i = 0; i < NUMBER_OF_STEPS; ++i)\n    {\n        vec3 current_position = ray_origin + total_distance_traveled * ray_direction;\n\t\tfloat distance_to_closest = distance_to_closest_object(current_position);\n        if (distance_to_closest < MINIMUM_HIT_DISTANCE) \n        {\n            vec3 normal = calculate_normal(current_position);\n            \n            vec3 light_positions[3];\n            light_positions[0] = vec3(1.0+sin(iTime)*5.0, -3.0+3.0*cos(iTime/3.0), 4.0 + 1.0 *sin(iTime/5.0));\n            light_positions[1] = vec3(1.0-sin(iTime/2.0)*2.0, -1.0-cos(iTime/2.0), 7.0 + 1.0 -sin(iTime/4.0));\n            light_positions[2] = vec3(2.0-sin(iTime/2.0)*2.0, -5.0-sin(iTime/4.0), 2.0 + 1.0 -sin(iTime/1.0));\n            vec3 light_intensities[3];\n            light_intensities[0] = vec3(0.8, 0.4, 0.4);\n            light_intensities[1] = vec3(0.04, 0.9, 0.2);\n            light_intensities[2] = vec3(0.1, 0.2, 0.8);\n            vec3 direction_to_view = normalize(current_position - ray_origin);float fresnel_base = 1.0 + dot(direction_to_view, normal);\n            float fresnel_intensity = 0.04*pow(fresnel_base, 2.0);\n            float fresnel_shadowing = pow(fresnel_base, 8.0);            \n            float fresnel_supershadowing = pow(fresnel_base, 40.0);      \n            float fresnel_antialiasing = 4.0*pow(fresnel_base, 8.0);\n            float attenuation =  pow(total_distance_traveled,2.0)/150.0;\n            \n            vec3 col = vec3(0.0);\n            \n            for (int j = 0; j < 3; j++)\n            {\n                vec3 direction_to_light = normalize(current_position - light_positions[j]);\n                vec3 light_reflection_unit_vector =\n                \t reflect(direction_to_light ,normal);                \n\n                float diffuse_intensity = 0.6*pow(max(0.0, dot(normal, direction_to_light)),5.0);            \n                float ambient_intensity = 0.2;            \n                float specular_intensity = \n                    1.15* pow(clamp(dot(direction_to_view, light_reflection_unit_vector), 0.0,1.0), 90.0);\n                float backlight_specular_intensity =             \n                    0.01* pow(clamp(dot(direction_to_light, light_reflection_unit_vector),0.0,1.0), 3.0); \n                \n                \n            \tvec3 colFromLight = vec3(0.0);\n                colFromLight += vec3(0.89, 0.35, 0.15) * diffuse_intensity;\n                colFromLight += vec3(0.3, 0.1, 0.1) * ambient_intensity;\n                colFromLight += vec3(1.0) * specular_intensity;            \n                colFromLight += vec3(1.0,0.5,0.5) * backlight_specular_intensity;            \n                colFromLight += vec3(1.0, 0.1, 0.2) * fresnel_intensity;\n                colFromLight -= vec3(0.0, 1.0, 1.0) * fresnel_shadowing ;\n                colFromLight -= vec3(0.0, 1.0, 1.0) * fresnel_supershadowing ;\n                colFromLight += vec3(.3, 0.1, 0.1) - attenuation ; \n               //\tcolFromLight *= 1.6;\n               // colFromLight *= sqrt(light_intensities[j]);\n                col += colFromLight;\n            }\n            return vec4(col, 1.0-fresnel_antialiasing);\n        }\n\n        if (total_distance_traveled > MAXIMUM_TRACE_DISTANCE)\n        {\n            break;\n        }\n        total_distance_traveled += distance_to_closest;\n    }\n    return vec4(0.0);\n}\n\n//The final image shader, taking in the screen coordinate and outputting color.  \n//Uses an eye (camera) position as the ray origin, then uses a look-at point\n//and a camera projection matrix to find the ray direction corresponding to the\n//screen coordinate.  Passes that ro/rd to the raymarcher to get the color at that point.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (-iResolution.xy + 2.0*fragCoord) / iResolution.y;\n\n     // camera movement\t\n\tfloat time_factor = 0.5*iTime;\n\tvec3 camera_position = vec3( 7.0*cos(time_factor), 0.4, 7.0*sin(time_factor));\n    vec3 ray_origin = camera_position;    \n    vec3 look_at = vec3( 0.0, sin(time_factor), 0.0 );\n    // camera matrix\n    vec3 ww = normalize( look_at - ray_origin );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 ray_direction = normalize( uv.x*uu + uv.y*vv + 1.5*ww );\n    \n    vec4 shaded_color = ray_march(ray_origin, ray_direction);\n\n    fragColor = vec4(shaded_color);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltscW8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[392, 601, 687, 687, 746], [750, 914, 955, 955, 1048], [1050, 1189, 1234, 1234, 1792], [1794, 2150, 2194, 2194, 2787], [2789, 3225, 3284, 3284, 6805], [6807, 7136, 7193, 7193, 7850]]}
{"id": "ltscWX", "name": "Accidental Snow", "author": "bradleygriffith", "description": "snow", "tags": ["snow"], "likes": 1, "viewed": 88, "date": "1506738505", "time_retrieved": "2024-06-20T19:01:04.739047", "image_code": "vec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat random( vec2 p) {\n    return fract(sin(dot(p.xy,vec2(12.9898,78.233)))*43758.5453);\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec3 color = vec3(.0);\n\n\n\n    float pointRadius = 25.6;\n    float pointCellWidth = 50.0;\n    float pointRadiusOfCell = pointRadius / pointCellWidth;\n    \n    vec2 totalCellCount = iResolution.xy / pointCellWidth;\n    vec2 cellUv = uv * totalCellCount;\n\n    // Tile the space\n    vec2 i_uv = floor(cellUv);\n    vec2 f_uv = fract(cellUv);\n\n    float m_dist = 1.;  // minimun distance\n    \n    \n    \n\n    for (int y= -1; y <= 1; y++) {\n        for (int x= -1; x <= 1; x++) {\n            // Neighbor place in the grid\n            vec2 neighbor = vec2(float(x), float(y));\n\n            // Random position from current + neighbor place in the grid\n            vec2 point = random2(i_uv + neighbor);\n\n       \n            vec2 cellRowCol = floor(fragCoord / pointCellWidth) + neighbor;\n            vec2 cellCenterFragCoord = ((cellRowCol * pointCellWidth) + (pointCellWidth / 2.0));\n            vec2 cellCenterUv = cellCenterFragCoord / iResolution.xy;\n            float cellSizeAdjust = random(cellCenterUv);\n\t\t\t\n\n            // Animate the point\n            point = 0.5 + 0.75 * sin(iTime + 6.2831 * point);\n\n            // Vector between the pixel and the point\n            vec2 diff = neighbor + point - f_uv;\n\n            // Distance to the point\n            float dist = length(diff);\n            dist += cellSizeAdjust; // Effectively remove point\n\n            // Keep the closer distance\n            m_dist = min(m_dist, dist);\n        }\n    }\n    \n    float cellPixel = (1.0 / pointCellWidth);\n    color += 1.0 - smoothstep(pointRadiusOfCell, pointRadiusOfCell + cellPixel, m_dist);\n \n    fragColor = vec4(vec3(color), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltscWX.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 24, 24, 117], [119, 119, 142, 142, 210], [216, 216, 273, 273, 1948]]}
{"id": "ltsyzl", "name": "Sampling Spherical Rectangle", "author": "koiava", "description": "Left - Sampling emitter area.\nRight - Sampling emitter solid angle.\nReference :\nAn Area-Preserving Parametrization for Spherical Rectangles\nhttps://www.solidangle.com/research/egsr2013_spherical_rectangle.pdf", "tags": ["rectangle", "sampling", "montecarlo"], "likes": 17, "viewed": 1259, "date": "1506072534", "time_retrieved": "2024-06-20T19:01:09.115224", "image_code": "#define PIXEL_SAMPLES \t\t4\t\t\t//Increase for higher quality\n#define LIGHT_SAMPLES\t\t1\t\t\t//Increase for higher quality\n\n//CDF for RIS to resample projected solid angle\n#define CDF_SIZE 1\t//Increase for better quality\n\n#define GAMMA \t\t\t\t2.2\t\t\t//\n#define SHADOWS\n#define LIGHT_CLIPPING\n//#define STRATIFIED_SAMPLING\nconst vec3 backgroundColor = vec3( 0.0 );\n\n#define SAMPLE_TOTAL_AREA\t\t\t0\n#define SAMPLE_SPHERICAL_RECTANGLE\t1\n#define SAMPLE_NONE\t\t\t\t\t2\nint samplingTechnique;\n\n//used macros and constants\n#define PI \t\t\t\t\t3.1415926\n#define TWO_PI \t\t\t\t6.2831852\n#define FOUR_PI \t\t\t12.566370\n#define INV_PI \t\t\t\t0.3183099\n#define INV_TWO_PI \t\t\t0.1591549\n#define INV_FOUR_PI \t\t0.0795775\n#define EPSILON \t\t\t0.0001 \n#define EQUAL_FLT(a,b,eps)\t(((a)>((b)-(eps))) && ((a)<((b)+(eps))))\n#define IS_ZERO(a) \t\t\tEQUAL_FLT(a,0.0,EPSILON)\n//********************************************\n\n// random number generator **********\n// from iq :)\nfloat seed;\t//seed initialized in main\nfloat rnd() { return fract(sin(seed++)*43758.5453123); }\n//***********************************\n\n//////////////////////////////////////////////////////////////////////////\n// Converting PDF from Solid angle to Area\nfloat PdfWtoA( float aPdfW, float aDist2, float aCosThere ){\n    if( aDist2 < EPSILON )\n        return 0.0;\n    return aPdfW * abs(aCosThere) / aDist2;\n}\n\n// Converting PDF between from Area to Solid angle\nfloat PdfAtoW( float aPdfA, float aDist2, float aCosThere ){\n    float absCosTheta = abs(aCosThere);\n    if( absCosTheta < EPSILON )\n        return 0.0;\n    \n    return aPdfA * aDist2 / absCosTheta;\n}\n//////////////////////////////////////////////////////////////////////////\n\nvec3 toVec3( vec4 v ) {\n    if( IS_ZERO( v.w ) ) {\n        return v.xyz;\n    }\n    \n    return v.xyz*(1.0/v.w);\n}\n\nvec3 sphericalToCartesian(\tin float rho,\n                          \tin float phi,\n                          \tin float theta ) {\n    float sinTheta = sin(theta);\n    return vec3( sinTheta*cos(phi), sinTheta*sin(phi), cos(theta) )*rho;\n}\n\nvoid cartesianToSpherical( \tin vec3 xyz,\n                         \tout float rho,\n                          \tout float phi,\n                          \tout float theta ) {\n    rho = sqrt((xyz.x * xyz.x) + (xyz.y * xyz.y) + (xyz.z * xyz.z));\n    phi = asin(xyz.y / rho);\n\ttheta = atan( xyz.z, xyz.x );\n}\n\nmat3 mat3Inverse( in mat3 m ) {\n    return mat3(\tvec3( m[0][0], m[1][0], m[2][0] ),\n\t\t\t\t\tvec3( m[0][1], m[1][1], m[2][1] ),\n                    vec3( m[0][2], m[1][2], m[2][2] ) );\n}\n\n//fast inverse for orthogonal matrices\nmat4 mat4Inverse( in mat4 m ) {\n    mat3 rotate_inv = mat3(\tvec3( m[0][0], m[1][0], m[2][0] ),\n                          \tvec3( m[0][1], m[1][1], m[2][1] ),\n                          \tvec3( m[0][2], m[1][2], m[2][2] ) );\n    \n    return mat4(\tvec4( rotate_inv[0], 0.0 ),\n                \tvec4( rotate_inv[1], 0.0 ),\n                \tvec4( rotate_inv[2], 0.0 ),\n              \t\tvec4( (-rotate_inv)*m[3].xyz, 1.0 ) );\n}\n    \n\n      \nstruct SurfaceHitInfo {\n    vec3 position_;\n\tvec3 normal_;\n    vec3 tangent_;\n    vec2 uv_;\n    int material_id_;\n};\n\n\n#define MTL_LIGHT \t\t0\n#define MTL_DIFFUSE\t\t1\n    \n\n#define OBJ_PLANE\t\t0\n#define OBJ_SPHERE\t\t1\n#define OBJ_CYLINDER\t2\n#define OBJ_AABB\t\t3\n#define OBJ_TRIANGLE\t4\n    \nstruct Object {\n    int type_;\n    int mtl_id_;\n    mat4 transform_;\n    mat4 transform_inv_;\n    \n    float params_[6];\n};\n    \nstruct Ray { vec3 origin; vec3 dir; };\nstruct Camera {\n    mat3 rotate;\n    vec3 pos;\n    float fovV;\n};\n    \n// ************ SCENE ***************\nObject objects[7];\nCamera camera;\n//***********************************\nvoid createAABB( mat4 transform, vec3 bound_min, vec3 bound_max, int mtl, out Object obj) {\n    vec3 xAcis = normalize( vec3( 0.9, 0.0, 0.2 ) );\n    vec3 yAcis = vec3( 0.0, 1.0, 0.0 );\n    obj.type_ = OBJ_AABB;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = bound_min.x;\n    obj.params_[1] = bound_min.y;\n    obj.params_[2] = bound_min.z;\n    obj.params_[3] = bound_max.x;\n    obj.params_[4] = bound_max.y;\n    obj.params_[5] = bound_max.z;\n}\n\nvoid createPlane(mat4 transform, float minX, float minY, float maxX, float maxY, int mtl, out Object obj) {\n    obj.type_ = OBJ_PLANE;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = minX;\t\t\t//radius\n    obj.params_[1] = minY;\t\t\t//min z\n    obj.params_[2] = maxX;\t\t\t//max z\n    obj.params_[3] = maxY;\t\t\t//max phi\n    obj.params_[4] = 0.0;\t\t//not used\n    obj.params_[5] = 0.0;\t\t//not used\n}\n\nvoid createTriangle(mat4 transform, vec2 v1, vec2 v2, vec2 v3, int mtl, out Object obj) {\n    obj.type_ = OBJ_TRIANGLE;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = v1.x;\t\t\t\n    obj.params_[1] = v1.y;\t\t\t\n    obj.params_[2] = v2.x;\t\t\t\n    obj.params_[3] = v2.y;\t\t\t\n    obj.params_[4] = v3.x;\t\t\n    obj.params_[5] = v3.y;\t\t\n}\n\nvoid createSphere(mat4 transform, float r, int mtl, out Object obj) {\n    obj.type_ = OBJ_SPHERE;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = r;\t\t\t//radius\n    obj.params_[1] = r*r;\t\t//radius^2\n    obj.params_[2] = 0.0;\t\t//not used\n    obj.params_[3] = 0.0;\t\t//not used\n    obj.params_[4] = 0.0;\t\t//not used \n    obj.params_[5] = 0.0;\t\t//not used\n}\n\nvoid createCylinder(mat4 transform, float r, float minZ, float maxZ, float maxTheta, int mtl, out Object obj) {\n    obj.type_ = OBJ_CYLINDER;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = r;\t\t\t//radius\n    obj.params_[1] = minZ;\t\t//min z\n    obj.params_[2] = maxZ;\t\t//max z\n    obj.params_[3] = maxTheta;\t//max phi\n    obj.params_[4] = 0.0;\t\t//not used\n    obj.params_[5] = 0.0;\t\t//not used\n}\n\nmat4 createCS(vec3 p, vec3 z, vec3 x) {\n    z = normalize(z);\n    vec3 y = normalize(cross(z,x));\n    x = cross(y,z);\n    \n    return mat4(\tvec4( x, 0.0 ), \n    \t\t\t \tvec4( y, 0.0 ),\n    \t\t\t\tvec4( z, 0.0 ),\n    \t\t\t\tvec4( p, 1.0 ));\n}\n\nvoid initScene() {\n    float time = iTime;\n    \n    //init lights\n    float r = 0.1;\n    \n    float xFactor = (iMouse.x==0.0)?0.0:2.0*(iMouse.x/iResolution.x) - 1.0;\n    float yFactor = (iMouse.x==0.0)?0.8:2.0*(iMouse.y/iResolution.y) - 1.0;\n    float x = 0.0;\n    float z = -3.0-yFactor*5.0;\n    float a = -1.8+sin(time*0.23);\n    mat4 trans = createCS(\tvec3(x, 3.0, z),\n                          \tvec3(0.0, sin(a), cos(a)),\n                  \t\t\tvec3(1.0, 0.0, 0.0));\n    createPlane(trans, -3.0, -1.0, 3.0, 1.0, MTL_LIGHT, objects[0]);\n    \n    //plane 1\n    trans = mat4(\tvec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( 0.0, 1.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, 1.0, 0.0 ),\n                    vec4( 0.0, 5.0, -10.0, 1.0 ));\n    createPlane(trans, -10.0, -2.0, 10.0, 4.0, MTL_DIFFUSE, objects[1]);\n   \n    //plane 2\n    trans = mat4(\tvec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, -1.0, 0.0 ),\n                    vec4( 0.0, -1.0, 0.0, 0.0 ),\n                    vec4( 0.0, -1.0, -4.0, 1.0 ));\n    createPlane(trans, -10.0, -4.0, 10.0, 2.0, MTL_DIFFUSE, objects[2]);\n \n    //Cylinder\n    trans = mat4(\tvec4( 0.0, 1.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, 1.0, 0.0 ),\n                    vec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( -0.0, 3.0, -6.0, 1.0 ));\n    createCylinder(trans, 4.0, -10.0, 10.0, PI/2.0, MTL_DIFFUSE, objects[3] );\n    \n    //sphere 1\n    trans = mat4( \tvec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( 0.0, 1.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, 1.0, 0.0 ),\n                    vec4( 2.5, 0.0, -2.0, 1.0 ));\n\n    createSphere(trans, 1.0, MTL_DIFFUSE, objects[4] );\n    \n    //sphere 2\n    trans = mat4( \tvec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( 0.0, 1.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, 1.0, 0.0 ),\n                    vec4( -1.0, 0.0, -5.0, 1.0 ));\n\n    createSphere(trans, 1.0, MTL_DIFFUSE, objects[5] );\n    \n    //box\n    trans = createCS(\tvec3(-1.5, -1.0, -3.0),\n                     \tvec3(0.0, 1.0, 0.0),\n                     \tvec3(0.2, 0.0, -0.7));\n    createAABB( trans, -vec3(0.5, 0.5, 0.0), vec3(0.5, 0.5, 2.5), MTL_DIFFUSE, objects[6]);\n}\n\n// ************************  INTERSECTION FUNCTIONS **************************\nbool solveQuadratic(float A, float B, float C, out float t0, out float t1) {\n\tfloat discrim = B*B-4.0*A*C;\n    \n\tif ( discrim <= 0.0 )\n        return false;\n    \n\tfloat rootDiscrim = sqrt( discrim );\n    \n    float t_0 = (-B-rootDiscrim)/(2.0*A);\n    float t_1 = (-B+rootDiscrim)/(2.0*A);\n    \n    t0 = min( t_0, t_1 );\n    t1 = max( t_0, t_1 );\n    \n\treturn true;\n}\n\nbool rayAABBIntersection( in Ray ray, float minX, float minY, float minZ, float maxX, float maxY, float maxZ, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n    vec3 boxMin = vec3( minX, minY, minZ );\n    vec3 boxMax = vec3( maxX, maxY, maxZ );\n    \n    vec3 OMIN = ( boxMin - ray.origin ) / ray.dir;\n    vec3 OMAX = ( boxMax - ray.origin ) / ray.dir;\n    vec3 MAX = max ( OMAX, OMIN );\n    vec3 MIN = min ( OMAX, OMIN );\n    float t1 = min ( MAX.x, min ( MAX.y, MAX.z ) );\n    t = max ( max ( MIN.x, 0.0 ), max ( MIN.y, MIN.z ) );\n    \n    if ( t1 <= t )\n        return false;\n    \n    if( !forShadowTest ) {\n        isect.position_ = ray.origin + ray.dir*t;\n        \n        if( EQUAL_FLT( isect.position_.x, minX, EPSILON ) ) {\n            isect.normal_ =  vec3( -1.0, 0.0, 0.0 );\n            isect.tangent_ \t\t= vec3( 0.0, 1.0, 0.0 );\n            isect.uv_.x = (isect.position_.z - minZ)/(maxZ - minZ);\n    \t\tisect.uv_.y = (isect.position_.y - minY)/(maxY - minY);\n        } else if( EQUAL_FLT( isect.position_.x, maxX, EPSILON ) ) {\n            isect.normal_ =  vec3( 1.0, 0.0, 0.0 );\n            isect.tangent_ = vec3( 0.0, 1.0, 0.0 );\n            isect.uv_.x = (isect.position_.z - minZ)/(maxZ - minZ);\n    \t\tisect.uv_.y = (isect.position_.y - minY)/(maxY - minY);\n        } else if( EQUAL_FLT( isect.position_.y, minY, EPSILON ) ) {\n            isect.normal_ =  vec3( 0.0, -1.0, 0.0 );\n            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n            isect.uv_.x = (isect.position_.x - minX)/(maxX - minX);\n    \t\tisect.uv_.y = (isect.position_.z - minZ)/(maxZ - minZ);\n        } else if( EQUAL_FLT( isect.position_.y, maxY, EPSILON ) ) {\n            isect.normal_ =  vec3( 0.0, 1.0, 0.0 );\n            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n            isect.uv_.x = (isect.position_.x - minX)/(maxX - minX);\n    \t\tisect.uv_.y = (isect.position_.z - minZ)/(maxZ - minZ);\n        } else if( EQUAL_FLT( isect.position_.z, minZ, EPSILON ) ) {\n            isect.normal_ =  vec3( 0.0, 0.0, -1.0 );\n            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n            isect.uv_.x = (isect.position_.x - minX)/(maxX - minX);\n    \t\tisect.uv_.y = (isect.position_.y - minY)/(maxY - minY);\n        } else if( EQUAL_FLT( isect.position_.z, maxZ, EPSILON ) ) {\n            isect.normal_ =  vec3( 0.0, 0.0, 1.0 );\n            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n            isect.uv_.x = (isect.position_.x - minX)/(maxX - minX);\n    \t\tisect.uv_.y = (isect.position_.y - minY)/(maxY - minY);\n        }\n        \n        isect.uv_ /= 2.0;\n    }\n    \n    return true;\n}\n\nbool raySphereIntersection( in Ray ray, in float radiusSquared, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n    float t0, t1;\n    vec3 L = ray.origin;\n    float a = dot( ray.dir, ray.dir );\n    float b = 2.0 * dot( ray.dir, L );\n    float c = dot( L, L ) - radiusSquared;\n    \n    if (!solveQuadratic( a, b, c, t0, t1))\n\t\treturn false;\n    \n    if( t0 > 0.0 ) {\n    \tt = t0;\n    } else {\n        if ( t1 > 0.0 ) {\n            t = t1;\n        } else {\n            return false;\n        }\n    }\n    \n    if( !forShadowTest ) {\n        isect.position_ = ray.origin + ray.dir*t;\n        isect.normal_ = normalize( isect.position_ );\n\n        float rho, phi, theta;\n        cartesianToSpherical( isect.normal_, rho, phi, theta );\n        isect.uv_.x = phi/PI;\n        isect.uv_.y = theta/TWO_PI;\n\n        isect.tangent_ = vec3( 0.0, 1.0, 0.0 );\n        vec3 tmp = cross( isect.normal_, isect.tangent_ );\n        isect.tangent_ = normalize( cross( tmp, isect.normal_ ) );\n    }\n\t\n\treturn true;\n}\n\n\nbool rayAAPlaneIntersection( in Ray ray, in float min_x, in float min_y, in float max_x, in float max_y, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n    if ( IS_ZERO( ray.dir.z ) )\n    \treturn false;\n    \n    t = ( -ray.origin.z ) / ray.dir.z;\n    \n    isect.position_ = ray.origin + ray.dir*t;\n    \n    if( (isect.position_.x < min_x) ||\n       \t(isect.position_.x > max_x) ||\n      \t(isect.position_.y < min_y) ||\n      \t(isect.position_.y > max_y) )\n        return false;\n    \n    if( !forShadowTest ) {\n        isect.uv_.x \t\t= (isect.position_.x - min_x)/(max_x - min_x);\n        isect.uv_.y \t\t= (isect.position_.y - min_y)/(max_y - min_y);\n        isect.normal_ \t\t= vec3( 0.0, 0.0, 1.0 );\n        isect.tangent_ \t\t= vec3( 1.0, 0.0, 0.0 );\n    }\n    \n    return true;\n}\n\nbool rayCylinderIntersection( in Ray r, in float radius, in float minZ, in float maxZ, in float maxPhi, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n\tfloat phi;\n\tvec3 phit;\n    \n\t// Compute quadratic cylinder coefficients\n\tfloat a = r.dir.x*r.dir.x + r.dir.y*r.dir.y;\n\tfloat b = 2.0 * (r.dir.x*r.origin.x + r.dir.y*r.origin.y);\n\tfloat c = r.origin.x*r.origin.x + r.origin.y*r.origin.y - radius*radius;\n \n\t// Solve quadratic equation for _t_ values\n\tfloat t0, t1;\n\tif (!solveQuadratic( a, b, c, t0, t1))\n\t\treturn false;\n\n    if ( t1 < 0.0 )\n        return false;\n    \n\tt = t0;\n    \n\tif (t0 < 0.0)\n\t\tt = t1;\n\n\t// Compute cylinder hit point and $\\phi$\n\tphit = r.origin + r.dir*t;\n\tphi = atan(phit.y,phit.x);\n    phi += PI;\n    \n\tif (phi < 0.0)\n        phi += TWO_PI;\n \n\t// Test cylinder intersection against clipping parameters\n\tif ( (phit.z < minZ) || (phit.z > maxZ) || (phi > maxPhi) ) {\n\t\tif (t == t1)\n            return false;\n\t\tt = t1;\n\t\t// Compute cylinder hit point and $\\phi$\n\t\tphit = r.origin + r.dir*t;\n\t\tphi = atan(phit.y,phit.x);\n        phi += PI;\n\n\t\tif ( (phit.z < minZ) || (phit.z > maxZ) || (phi > maxPhi) )\n\t\t\treturn false;\n\t}\n    \n    if( !forShadowTest ) {\n        isect.position_ = phit;\n        isect.uv_.x = (phit.z - minZ)/(maxZ - minZ);\n        isect.uv_.y = phi/maxPhi;\n        isect.normal_ = normalize( vec3( phit.xy, 0.0 ) );\n        isect.tangent_ = vec3( 0.0, 0.0, 1.0 );\n    }\n    \n\treturn true;\n}\n\nbool rayObjectIntersect( in Ray ray, in Object obj, in float distMin, in float distMax, in bool forShadowTest, out SurfaceHitInfo hit, out float dist ) {\n    bool hitResult = false;\n    float t;\n    SurfaceHitInfo currentHit;\n\n    //Convert ray to object space\n    Ray rayLocal;\n    rayLocal.origin = toVec3( obj.transform_inv_*vec4( ray.origin, 1.0 ) );\n    rayLocal.dir \t= toVec3( obj.transform_inv_*vec4( ray.dir   , 0.0 ) );\n\n    if( obj.type_ == OBJ_PLANE ) {\n        hitResult = rayAAPlaneIntersection( rayLocal, obj.params_[0], obj.params_[1], obj.params_[2], obj.params_[3], forShadowTest, t, currentHit );\n    } else if( obj.type_ == OBJ_SPHERE ) {\n        hitResult = raySphereIntersection( \trayLocal, obj.params_[1], forShadowTest, t, currentHit );\n    } else if( obj.type_ == OBJ_CYLINDER ) {\n        hitResult = rayCylinderIntersection(rayLocal, obj.params_[0], obj.params_[1], obj.params_[2], obj.params_[3], forShadowTest, t, currentHit );\n    } else if( obj.type_ == OBJ_AABB ) {\n        hitResult = rayAABBIntersection( rayLocal, obj.params_[0], obj.params_[1], obj.params_[2], obj.params_[3], obj.params_[4], obj.params_[5], forShadowTest, t, currentHit );\n    }\n\n    if( hitResult && ( t > distMin ) && ( t < distMax ) ) {\n        //Convert results to world space\n        currentHit.position_ = toVec3( obj.transform_*vec4( currentHit.position_, 1.0 ) );\n        currentHit.normal_   = toVec3( obj.transform_*vec4( currentHit.normal_  , 0.0 ) );\n        currentHit.tangent_  = toVec3( obj.transform_*vec4( currentHit.tangent_ , 0.0 ) );\n\n        dist = t;\n        hit = currentHit;\n        hit.material_id_ = obj.mtl_id_;\n        return true;\n    }\n    \n    return false;\n}\n\n#define CHECK_OBJ( obj ) { SurfaceHitInfo currentHit; float currDist; if( rayObjectIntersect( ray, obj, distMin, nearestDist, forShadowTest, currentHit, currDist ) && ( currDist < nearestDist ) ) { nearestDist = currDist; hit = currentHit; } }\nbool raySceneIntersection( in Ray ray, in float distMin, in bool forShadowTest, out SurfaceHitInfo hit, out float nearestDist ) {\n    nearestDist = 10000.0;\n    CHECK_OBJ( objects[0] );\n    if(!forShadowTest) {\t//Hack optimization for shadow rays\n        CHECK_OBJ( objects[1] );\n        CHECK_OBJ( objects[2] );\n        CHECK_OBJ( objects[3] );\n    }\n    CHECK_OBJ( objects[4] );\n    CHECK_OBJ( objects[5] );\n    CHECK_OBJ( objects[6] );\n    return ( nearestDist < 1000.0 );\n}\n// ***************************************************************************\n\n \n// Geometry functions ***********************************************************\nvec2 uniformPointWithinCircle( in float radius, in float Xi1, in float Xi2 ) {\n    float r = radius*sqrt(Xi1);\n    float theta = Xi2*TWO_PI;\n\treturn vec2( r*cos(theta), r*sin(theta) );\n}\n\nvec3 uniformPointWitinTriangle( in vec3 v1, in vec3 v2, in vec3 v3, in float Xi1, in float Xi2 ) {\n    Xi1 = sqrt(Xi1);\n    return (1.0-Xi1)*v1 + Xi1*(1.0-Xi2)*v2 + Xi1*Xi2*v3;\n}\n\nvec3 uniformDirectionWithinCone( in vec3 d, in float phi, in float sina, in float cosa ) {    \n\tvec3 w = normalize(d);\n    vec3 u = normalize(cross(w.yzx, w));\n    vec3 v = cross(w, u);\n\treturn (u*cos(phi) + v*sin(phi)) * sina + w * cosa;\n}\n\nvec3 localToWorld( in vec3 localDir, in vec3 normal )\n{\n    vec3 binormal = normalize( ( abs(normal.x) > abs(normal.z) )?vec3( -normal.y, normal.x, 0.0 ):vec3( 0.0, -normal.z, normal.y ) );\n\tvec3 tangent = cross( binormal, normal );\n    \n\treturn localDir.x*tangent + localDir.y*binormal + localDir.z*normal;\n}\n\nvec3 sampleHemisphereCosWeighted( in vec3 n, in float Xi1, in float Xi2 ) {\n    float theta = acos(sqrt(1.0-Xi1));\n    float phi = TWO_PI * Xi2;\n\n    return localToWorld( sphericalToCartesian( 1.0, phi, theta ), n );\n}\n\nvec3 randomHemisphereDirection( const vec3 n, in float Xi1, in float Xi2 ) {\n    vec2 r = vec2(Xi1,Xi2)*TWO_PI;\n\tvec3 dr=vec3(sin(r.x)*vec2(sin(r.y),cos(r.y)),cos(r.x));\n\treturn dot(dr,n) * dr;\n}\n\nvec3 randomDirection( in float Xi1, in float Xi2 ) {\n    float theta = acos(1.0 - 2.0*Xi1);\n    float phi = TWO_PI * Xi2;\n    \n    return sphericalToCartesian( 1.0, phi, theta );\n}\n\n///////////////////////////////////////////////////////////////////////\nvoid initCamera( \tin vec3 pos,\n                \tin vec3 target,\n                \tin vec3 upDir,\n                \tin float fovV\n               ) {\n\tvec3 back = normalize( pos-target );\n\tvec3 right = normalize( cross( upDir, back ) );\n\tvec3 up = cross( back, right );\n    camera.rotate[0] = right;\n    camera.rotate[1] = up;\n    camera.rotate[2] = back;\n    camera.fovV = fovV;\n    camera.pos = pos;\n}\n\nvoid updateCamera( int strata ) {\n    float strataSize = 1.0/float(PIXEL_SAMPLES);\n    float r1 = strataSize*(float(strata)+rnd());\n    //update camera pos\n    float cameraZ = 4.0;\n    vec3 upDir = vec3( 0.0, 1.0, 0.0 );\n    vec3 pos1, pos2;\n    pos1 = vec3( sin(iTime*0.154)*2.0, 2.0 + sin(iTime*0.3)*2.0, cameraZ + sin(iTime*0.8) );\n\n    camera.pos = pos1;\n    \n    vec3 target = vec3( sin(iTime*0.4)*0.3, 1.0, -5.0 );\n    \n\tvec3 back = normalize( camera.pos-target );\n\tvec3 right = normalize( cross( upDir, back ) );\n\tvec3 up = cross( back, right );\n    camera.rotate[0] = right;\n    camera.rotate[1] = up;\n    camera.rotate[2] = back;\n}\n\nRay genRay( in vec2 pixel, in float Xi1, in float Xi2 ) {\n    Ray ray;\n\tvec2 iPlaneSize=2.*tan(0.5*camera.fovV)*vec2(iResolution.x/iResolution.y,1.);\n\tvec2 ixy=(pixel/iResolution.xy - 0.5)*iPlaneSize;\n    ray.origin = camera.pos;\n    ray.dir = camera.rotate*normalize(vec3(ixy.x,ixy.y,-1.0));\n\treturn ray;\n}\n\nbool intersectPlane(vec3 plane_n, vec3 plane_p, vec3 ray_o, vec3 ray_d, out float t) { \n    // assuming vectors are all normalized\n    float denom = dot(plane_n, ray_d); \n    if (abs(denom) > 1e-7) { \n        vec3 vec = plane_p - ray_o; \n        t = dot(vec, plane_n) / denom; \n        return (t >= 0.0); \n    } \n \n    return false; \n}\n\nvec2 angular_to_cartesian(float phi) {\n    return vec2(cos(phi), sin(phi));\n}\n\nfloat cartesian_to_angular(vec2 w) {\n\treturn atan(float(-w.y), float(-w.x)) + PI;\n}\n\nstruct SphQuad {\n    vec3 o, x, y, z; // local reference system ’R’\n    float z0, z0sq; //\n    float x0, y0, y0sq; // rectangle coords in ’R’\n    float x1, y1, y1sq; //\n    float b0, b1, b0sq, k; // misc precomputed constants\n    float S; // solid angle of ’Q’\n};\n    \nvoid SphQuadInit(vec3 s,vec3 ex,vec3 ey,vec3 o, out SphQuad squad) {\n    squad.o = o;\n    float exl = length(ex), eyl = length(ey);\n    // compute local reference system ’R’\n    squad.x = ex / exl;\n    squad.y = ey / eyl;\n    squad.z = cross(squad.x, squad.y);\n    // compute rectangle coords in local reference system\n    vec3 d = s - o;\n    squad.z0 = dot(d, squad.z);\n    // flip ’z’ to make it point against ’Q’\n    if (squad.z0 > 0.) {\n    squad.z *= -1.;\n    squad.z0 *= -1.;\n    }\n    squad.z0sq = squad.z0 * squad.z0;\n    squad.x0 = dot(d, squad.x);\n    squad.y0 = dot(d, squad.y);\n    squad.x1 = squad.x0 + exl;\n    squad.y1 = squad.y0 + eyl;\n    squad.y0sq = squad.y0 * squad.y0;\n    squad.y1sq = squad.y1 * squad.y1;\n    // create vectors to four vertices\n    vec3 v00 = vec3(squad.x0, squad.y0, squad.z0);\n    vec3 v01 = vec3(squad.x0, squad.y1, squad.z0);\n    vec3 v10 = vec3(squad.x1, squad.y0, squad.z0);\n    vec3 v11 = vec3(squad.x1, squad.y1, squad.z0);\n    // compute normals to edges\n    vec3 n0 = normalize(cross(v00, v10));\n    vec3 n1 = normalize(cross(v10, v11));\n    vec3 n2 = normalize(cross(v11, v01));\n    vec3 n3 = normalize(cross(v01, v00));\n    // compute internal angles (gamma_i)\n    float g0 = acos(-dot(n0,n1));\n    float g1 = acos(-dot(n1,n2));\n    float g2 = acos(-dot(n2,n3));\n    float g3 = acos(-dot(n3,n0));\n    // compute predefined constants\n    squad.b0 = n0.z;\n    squad.b1 = n2.z;\n    squad.b0sq = squad.b0 * squad.b0;\n    squad.k = 2.*PI - g2 - g3;\n    // compute solid angle from internal angles\n    squad.S = g0 + g1 - squad.k;\n}\n\nvoid SphQuadSample(in vec3 x, SphQuad squad, float u, float v, out vec3 w, out float pdf) {\n    // 1. compute ’cu’\n    float au = u * squad.S + squad.k;\n    float fu = (cos(au) * squad.b0 - squad.b1) / sin(au);\n    float cu = 1./sqrt(fu*fu + squad.b0sq) * (fu>0. ? +1. : -1.);\n    cu = clamp(cu, -1., 1.); // avoid NaNs\n    // 2. compute ’xu’\n    float xu = -(cu * squad.z0) / sqrt(1. - cu*cu);\n    xu = clamp(xu, squad.x0, squad.x1); // avoid Infs\n    // 3. compute ’yv’\n    float d = sqrt(xu*xu + squad.z0sq);\n    float h0 = squad.y0 / sqrt(d*d + squad.y0sq);\n    float h1 = squad.y1 / sqrt(d*d + squad.y1sq);\n    float hv = h0 + v * (h1-h0), hv2 = hv*hv;\n    float yv = (hv2 < 1.-EPSILON) ? (hv*d)/sqrt(1.-hv2) : squad.y1;\n    // 4. transform (xu,yv,z0) to world coords\n    \n    vec3 p = (squad.o + xu*squad.x + yv*squad.y + squad.z0*squad.z);\n    w = normalize(p - x);\n    pdf = 1. / squad.S;\n}\n\nvoid update_x_bounds(vec3 pos, vec3 n, inout vec2 pmin, inout vec2 pmax) {\n    vec2 p1 = pmin;\n    vec2 p2 = vec2(pmin.x, pmax.y);\n    if(n.x != 0.0) {\n        float tmin = (pos.z*n.z - (p1.y - pos.y)*n.y)/n.x - p1.x + pos.x;\n        float tmax = (pos.z*n.z - (p2.y - pos.y)*n.y)/n.x - p2.x + pos.x;\n\n        float minx = clamp(pmin.x + tmin, pmin.x, pmax.x);\n        float maxx = clamp(pmin.x + tmax, pmin.x, pmax.x);\n\n        if(n.x > 0.0) {\n            pmin.x = min(minx, maxx);\n        } else {\n            pmax.x = max(minx, maxx);\n        }\n    }\n}\n\nvoid update_y_bounds(vec3 pos, vec3 n, inout vec2 pmin, inout vec2 pmax) {\n    vec2 p1 = pmin;\n    vec2 p2 = vec2(pmax.x, pmin.y);\n    //pos = pos.xzy;\n    if(n.y != 0.0){\n        float tmin = (pos.z*n.z - (p1.x - pos.x)*n.x)/n.y - p1.y + pos.y;\n        float tmax = (pos.z*n.z - (p2.x - pos.x)*n.x)/n.y - p2.y + pos.y;\n\n        float miny = clamp(pmin.y + tmin, pmin.y, pmax.y);\n        float maxy = clamp(pmin.y + tmax, pmin.y, pmax.y);\n\n        if(n.y > 0.0) {\n            pmin.y = min(miny, maxy);\n        } else {\n            pmax.y = max(miny, maxy);\n        }\n    }\n}\n\nvoid sampleArea(in vec3 pos, vec2 pmin, vec2 pmax, out vec3 w, out float pdfW) {\n    vec2 size = pmax - pmin;\n    float pdfA = 1.0 / (size.x*size.y);\n    vec3 p = vec3(pmin + size*vec2(rnd(), rnd()), 0.0);\n    w = p - pos;\n    float d2 = dot(w,w);\n    w /= sqrt(d2);\n    float aCosThere = max(0.0,-w.z);\n    pdfW = PdfAtoW( pdfA, d2, aCosThere );\n}\n\nvoid sampleDirectLight( vec3 pos,\n                       \tvec3 normal,\n                        float Xi1,\n                        float Xi2, \n                       \tout vec3 dir,\n                       \tout float pdf ) {\n    float height = objects[0].params_[2] - objects[0].params_[1];\n    float r = objects[0].params_[0];\n    float pdfA;\n    float d2;\n    float aCosThere;\n    float theta;\n    float thetaPdf;\n    float h;\n    float hPdf;\n    \n    //convert position to object space\n    pos = toVec3( objects[0].transform_inv_*vec4(pos, 1.0) );\n    normal = toVec3( objects[0].transform_inv_*vec4(normal, 0.0) );\n    \n    if(pos.z > 0.0) { \n        vec2 pmin = vec2(objects[0].params_[0], objects[0].params_[1]);\n        vec2 pmax = vec2(objects[0].params_[2], objects[0].params_[3]);\n\n#ifdef LIGHT_CLIPPING\n        update_x_bounds(pos, normal, pmin, pmax);\n        update_y_bounds(pos, normal, pmin, pmax);\n#endif\n        vec3 w[CDF_SIZE];\n        float ww[CDF_SIZE];\n        if(samplingTechnique == SAMPLE_TOTAL_AREA){\n            for(int i=0; i<CDF_SIZE; i++) {\n            \tsampleArea(pos, pmin, pmax, w[i], pdf);\n                ww[i] = max(0.0, dot(w[i], normal)) / pdf;\n            }\n        } else {\n            vec3 s = vec3(pmin, 0.0);\n            vec3 ex = vec3(pmax.x - pmin.x, 0., 0.);\n            vec3 ey = vec3(0., pmax.y - pmin.y, 0.);\n            SphQuad squad;\n            SphQuadInit(s, ex, ey, pos, squad);\n            \n            for(int i=0; i<CDF_SIZE; i++) {\n                SphQuadSample(pos, squad, rnd(), rnd(), w[i], pdf);\n                ww[i] = max(0.0, dot(w[i], normal)) / pdf;\n            }\n        }\n        \n        for(int i=1; i<CDF_SIZE; i++) {\n            ww[i] += ww[i-1];\n        }\n        \n        float a = Xi1 * ww[CDF_SIZE-1];\n        for(int i=0; i<CDF_SIZE; i++) {\n            if(ww[i] > a) {\n                pdf *= (ww[i] - ((i == 0)? 0.0 : ww[i-1])) / ww[CDF_SIZE-1];\n                pdf *= float(CDF_SIZE);\n                dir = w[i];\n                break;\n            }\n        }\n    } else {\n        pdf = 0.0;\n    }\n    \n    //convert dir to world space\n    dir = toVec3( objects[0].transform_*vec4(dir,0.0) );\n}\n\nbool isLightVisible( Ray shadowRay ) {\n    float distToHit;\n    SurfaceHitInfo tmpHit;\n    \n    raySceneIntersection( shadowRay, EPSILON, true, tmpHit, distToHit );\n    \n    return ( tmpHit.material_id_ == MTL_LIGHT );\n}\n\n\nvec3 Radiance( in Ray ray, float Xi ) {\n    vec3 L = vec3(4.0);\n    vec3 Lo = vec3( 0.0 );\n    \n    vec3 Wo = ray.dir*(-1.0);\n    SurfaceHitInfo hit;\n    float dist = 1000.0;\n\n    if( raySceneIntersection( ray, 0.0, false, hit, dist ) ) {\n        if( hit.material_id_ == MTL_LIGHT ) {\n            Lo = (dot(hit.normal_, Wo) > 0.0)? L : vec3(0.0, 0.0, 0.0);\n        } else {\n            for(int i=0; i<LIGHT_SAMPLES; i++){\n                vec3 Wi;\n                float pdfWi;\n                vec3 n = hit.normal_ * ((dot(hit.normal_, Wo) > 0.0 )? 1.0 : -1.0);\n                \n            \tfloat Xi1 = rnd();\n            \tfloat Xi2 = rnd();\n#ifdef STRATIFIED_SAMPLING\n                float strataSize = 1.0 / float(LIGHT_SAMPLES);\n                Xi2 = strataSize * (float(i) + Xi2);\n#endif\n                \n                sampleDirectLight( hit.position_, n, Xi1, Xi2, Wi, pdfWi );\n                float dotNWi = dot( Wi, n );\n\n                if ( (pdfWi > EPSILON) && (dotNWi > 0.0) ) {\n                    bool visible = true;\n#ifdef SHADOWS\n                    Ray shadowRay = Ray( hit.position_ + n*EPSILON, Wi );\n                    if ( !isLightVisible( shadowRay ) ) {\n                        visible = false;\n                    }\n#endif\n                    if(visible) {\n                        float brdf_pdf;\n\n                        vec3 brdf = vec3(1.0/PI);//max(0.0, dot(Wi, hit.normal_))*vec3(1.0);//Material_Evaluate( hit, Wo, Wi );\n\t\t\t\t\t\tvec3 Li = L/pdfWi;\n                        Lo += (brdf*Li*abs(dotNWi));\n                    }\n                }\n            }\n            Lo *= 1.0/float(LIGHT_SAMPLES);\n            \n        }\n    }\n        \n    return Lo;\n}\n\nvoid initSamplingTechnique(float p) {\n    float split = iMouse.x;\n    split = (split == 0.0)? iResolution.x * 0.5 : split;\n    float k = iMouse.x/iResolution.x;\n    float split1 = iMouse.x*k;\n    float split2 = iMouse.x + (iResolution.x-iMouse.x)*k;\n    \n    if(p < split-1.0) {\n        samplingTechnique = SAMPLE_TOTAL_AREA;\n    } else if(p > split+1.0){\n        samplingTechnique = SAMPLE_SPHERICAL_RECTANGLE;\n    } else {\n        samplingTechnique = SAMPLE_NONE;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed = /*iTime +*/ iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n    initSamplingTechnique(fragCoord.x);\n\n    if(samplingTechnique == SAMPLE_NONE) {\n        fragColor = vec4( 1.0 );\n    } else {\n        float fov = radians(45.0);\n        initCamera( vec3( 0.0, 0.0, 0.0 ),\n                    vec3( 0.0, 0.0, 0.0 ),\n                    vec3( 0.0, 1.0, 0.0 ),\n                    fov\n                    );\n\n        initScene();\n\n        vec3 accumulatedColor = vec3( 0.0 );\n        float oneOverSPP = 1.0/float(PIXEL_SAMPLES);\n        float strataSize = oneOverSPP;\n        Ray ray;\n\n        for( int si=0; si<PIXEL_SAMPLES; ++si ){\n            updateCamera( si );\n\n            vec2 screenCoord = fragCoord.xy + vec2( strataSize*( float(si) + rnd() ), rnd() );\n            ray = genRay( screenCoord, rnd(), rnd() );\n\n            if( length( ray.dir ) < 0.2 ) {\n                accumulatedColor = vec3( 0.0 );\n            } else {\n                accumulatedColor += Radiance( ray, strataSize*( float(si) + rnd() ) );\n            }\n        }\n\n        //devide to sample count\n        accumulatedColor = accumulatedColor*oneOverSPP;\n\n        //gamma correction\n        accumulatedColor = pow( accumulatedColor, vec3( 1.0 / GAMMA ) );\n\n\n        fragColor = vec4( accumulatedColor,1.0 );\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltsyzl.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[865, 956, 969, 969, 1012], [1052, 1170, 1230, 1230, 1323], [1325, 1376, 1436, 1436, 1576], [1577, 1653, 1676, 1676, 1766], [1768, 1768, 1895, 1895, 2003], [2005, 2005, 2175, 2175, 2306], [2308, 2308, 2339, 2339, 2490], [2492, 2531, 2562, 2562, 2948], [3557, 3595, 3686, 3686, 4122], [4124, 4124, 4231, 4231, 4598], [4600, 4600, 4689, 4689, 5010], [5012, 5012, 5081, 5081, 5448], [5450, 5450, 5561, 5561, 5928], [5930, 5930, 5969, 5969, 6162], [6164, 6164, 6182, 6182, 8345], [8347, 8426, 8502, 8502, 8792], [8794, 8794, 8968, 8968, 11371], [11373, 11373, 11501, 11501, 12383], [12386, 12386, 12555, 12555, 13180], [13182, 13182, 13350, 13350, 14628], [14630, 14630, 14783, 14783, 16322], [16568, 16568, 16697, 16697, 17045], [17128, 17210, 17288, 17288, 17396], [17398, 17398, 17496, 17496, 17576], [17578, 17578, 17668, 17668, 17818], [17820, 17820, 17875, 17875, 18129], [18131, 18131, 18206, 18206, 18349], [18351, 18351, 18427, 18427, 18546], [18548, 18548, 18600, 18600, 18728], [18730, 18802, 18947, 18947, 19201], [19203, 19203, 19236, 19236, 19843], [19845, 19845, 19902, 19902, 20152], [20154, 20154, 20240, 20284, 20489], [20491, 20491, 20529, 20529, 20568], [20570, 20570, 20606, 20606, 20653], [20936, 20936, 21004, 21004, 22525], [22527, 22527, 22618, 22645, 23437], [23439, 23439, 23513, 23513, 23993], [23995, 23995, 24069, 24069, 24569], [24571, 24571, 24651, 24651, 24919], [24921, 24921, 25142, 25142, 27091], [27093, 27093, 27131, 27131, 27313], [27316, 27316, 27355, 27355, 28998], [29000, 29000, 29037, 29037, 29473], [29475, 29475, 29532, 29532, 30857]]}
{"id": "ltXcD4", "name": "ZX Spectrum video scanout", "author": "baskanov", "description": "DRAM row and column access pattern during video scanout.", "tags": ["spectrum"], "likes": 2, "viewed": 108, "date": "1504843731", "time_retrieved": "2024-06-20T19:01:09.115224", "image_code": "const float g_fade_time = 256. * 64.;\nconst float g_pixel_clock = 512.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = 1. / max(1., floor(min(iResolution.x / (192. + 256.), iResolution.y / 192.)));\n\tvec2 pixel = floor(scale * vec2(fragCoord.x, iResolution.y - fragCoord.y));\n    \n    float counter = iTime * g_pixel_clock;\n\n    fragColor = vec4(0., 0., 0., 1.);\n    \n    float dram_row = pixel.y;\n    float dram_column = pixel.x;\n    if (dram_row < 128. && dram_column < 128.)\n    {\n        float dram_cell_counter = -1.;\n        if (dram_column < 48.)\n        {\n            float display_byte_index\n                = mod(dram_row, 32.)\n                + 32. * mod(floor(dram_column / 2.), 8.)\n                + 256. * mod(floor(dram_row / 32.), 4.)\n                + 1024. * mod(dram_column, 2.)\n                + 2048. * mod(floor(dram_column / 16.), 4.);\n            dram_cell_counter = 4. * mod(display_byte_index, 2.) + 16. * floor(display_byte_index / 2.);\n            dram_cell_counter += 256. * 192. * floor((counter - dram_cell_counter) / (256. * 192.));\n        }\n        else if (dram_column < 54.)\n        {\n            float attribute_byte_index\n                = mod(dram_row, 32.)\n                + 256. * mod(floor(dram_row / 32.), 4.)\n                + 1024. * mod(dram_column, 8.);\n            dram_cell_counter = 4. * mod(attribute_byte_index, 2.) + 16. * floor(attribute_byte_index / 2.) + 2.;\n            dram_cell_counter += 256. * 192. * floor((counter - dram_cell_counter) / (256. * 192.));\n            dram_cell_counter += 256. * min(7., floor((counter - dram_cell_counter) / 256.));\n        }\n        fragColor = vec4(0., 0., 0.5, 1.);\n        if (dram_cell_counter != -1.)\n        {\n            float time_since_access = counter - dram_cell_counter;\n            float value = max(0., 1. - time_since_access / g_fade_time);\n            fragColor = mix(vec4(0., 0., 0.5, 1.), vec4(1., 1., 0., 1.), value);\n        }\n    }\n    \n    float screen_row = pixel.y;\n    float screen_column = pixel.x - 192.;\n    if (0. <= screen_row && screen_row < 192. && 0. <= screen_column && screen_column < 256.)\n    {\n        float screen_pixel_counter = screen_row * 256. + screen_column;\n        screen_pixel_counter += 256. * 192. * floor((counter - screen_pixel_counter) / (256. * 192.));\n        float time_since_update = counter - screen_pixel_counter;\n        float value = max(0., 1. - time_since_update / g_fade_time);\n        fragColor = mix(vec4(0., 0., 0.5, 1.), vec4(1., 1., 0., 1.), value);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltXcD4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[73, 73, 130, 130, 2550]]}
{"id": "ltXcDf", "name": "Cylinder wth light", "author": "Torumu106", "description": "cylinder", "tags": ["light", "cylinder"], "likes": 1, "viewed": 72, "date": "1506642662", "time_retrieved": "2024-06-20T19:01:09.115224", "image_code": "float PI = 3.1415926535;\nvec3 col = vec3(1.0, 1.0, 1.0);\nint stop = 0;\nvec3 stoppos = vec3(0.0);\nfloat map(vec3 p){\n    vec3 p1 = p;\n    p1.y -= clamp(p.y, 0.0, 2.0);\n    float d = max(length(p1 - vec3(-2.0, 0.0, 0.0)) - 1.0, length(max(abs(p - vec3(-2.0, 1.0, 0.0)) - vec3(1.0, 1.0, 1.0),0.0)));\n    d = min(d, dot(p,vec3(0.0, 1.0, 0.0)) + 1.0);\n    return d;\n}\nvec3 grad(vec3 p) {\n    vec2 d = vec2(0.0, 0.001);\n\tfloat dFx = map(p + d.yxx) - map(p - d.yxx);\n\tfloat dFy = map(p + d.xyx) - map(p - d.xyx);\n\tfloat dFz = map(p + d.xxy) - map(p - d.xxy);\n\treturn normalize(vec3(dFx, dFy, dFz));\n}\nfloat trace(vec3 o, vec3 r){\n\tfloat t = 0.0;\n    vec3 p;\n    for(int i = 0; i < 128; ++i){\n    \tp = o + r * t;\n        float d = map(p);\n        if(d < 0.001){\n            stop = 1;\n        \tbreak;\n        }\n        t += d * 0.9;\n    }\n    stoppos = p;\n    return t;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 r = normalize(vec3(uv - vec2(0.0, PI / 3.0), 1.0));\n    \n    float the = iTime;\n    vec3 o = vec3(0.0,10.0, -10.0);\n    r.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    o.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    \n    float t = trace(o, r);\n    float light = 0.0;\n    if(stop == 1){\n    \tvec3 nor = grad(stoppos);\n        light = 0.7 * max(dot(nor, vec3(1.0)), 0.0) + 0.1;\n        stop = 0;\n        trace(stoppos + nor * 0.002, normalize(vec3(1.0,0.7,1.0)));\n        if(stop == 1) light = 0.1;\n    }\n    \n    vec3 fc = vec3(light) * col;\n    fragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltXcDf.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[97, 97, 115, 115, 362], [363, 363, 382, 382, 593], [594, 594, 622, 622, 862], [863, 863, 920, 920, 1634]]}
{"id": "ltXczj", "name": "Plasma Waves", "author": "scarletshark", "description": "I was inspired by my PC wallpaper (https://goo.gl/T12YEj), and the PS3 / PS4 animated wallpaper.  Just wanted to make a fun, flowy mess of vector lines!", "tags": ["2d", "antialiasing", "aa", "fourier"], "likes": 65, "viewed": 2118, "date": "1505487609", "time_retrieved": "2024-06-20T19:01:09.812199", "image_code": "/* This work is protected under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n * more information canbe found at:\n * https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US\n */\n\nconst float overallSpeed = 0.2;\nconst float gridSmoothWidth = 0.015;\nconst float axisWidth = 0.05;\nconst float majorLineWidth = 0.025;\nconst float minorLineWidth = 0.0125;\nconst float majorLineFrequency = 5.0;\nconst float minorLineFrequency = 1.0;\nconst vec4 gridColor = vec4(0.5);\nconst float scale = 5.0;\nconst vec4 lineColor = vec4(0.25, 0.5, 1.0, 1.0);\nconst float minLineWidth = 0.02;\nconst float maxLineWidth = 0.5;\nconst float lineSpeed = 1.0 * overallSpeed;\nconst float lineAmplitude = 1.0;\nconst float lineFrequency = 0.2;\nconst float warpSpeed = 0.2 * overallSpeed;\nconst float warpFrequency = 0.5;\nconst float warpAmplitude = 1.0;\nconst float offsetFrequency = 0.5;\nconst float offsetSpeed = 1.33 * overallSpeed;\nconst float minOffsetSpread = 0.6;\nconst float maxOffsetSpread = 2.0;\nconst int linesPerGroup = 16;\n\nconst vec4[] bgColors = vec4[]\n    (\n        lineColor * 0.5,\n        lineColor - vec4(0.2, 0.2, 0.7, 1)\n        );\n\n#define drawCircle(pos, radius, coord) smoothstep(radius + gridSmoothWidth, radius, length(coord - (pos)))\n\n#define drawSmoothLine(pos, halfWidth, t) smoothstep(halfWidth, 0.0, abs(pos - (t)))\n\n#define drawCrispLine(pos, halfWidth, t) smoothstep(halfWidth + gridSmoothWidth, halfWidth, abs(pos - (t)))\n\n#define drawPeriodicLine(freq, width, t) drawCrispLine(freq / 2.0, width, abs(mod(t, freq) - (freq) / 2.0))\n\nfloat drawGridLines(float axis)   \n{\n    return   drawCrispLine(0.0, axisWidth, axis)\n           + drawPeriodicLine(majorLineFrequency, majorLineWidth, axis)\n           + drawPeriodicLine(minorLineFrequency, minorLineWidth, axis);\n}\n\nfloat drawGrid(vec2 space)\n{\n    return min(1., drawGridLines(space.x)\n                  +drawGridLines(space.y));\n}\n\n// probably can optimize w/ noise, but currently using fourier transform\nfloat random(float t)\n{\n    return (cos(t) + cos(t * 1.3 + 1.3) + cos(t * 1.4 + 1.4)) / 3.0;   \n}\n\nfloat getPlasmaY(float x, float horizontalFade, float offset)   \n{\n    return random(x * lineFrequency + iTime * lineSpeed) * horizontalFade * lineAmplitude + offset;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 space = (fragCoord - iResolution.xy / 2.0) / iResolution.x * 2.0 * scale;\n    \n    float horizontalFade = 1.0 - (cos(uv.x * 6.28) * 0.5 + 0.5);\n    float verticalFade = 1.0 - (cos(uv.y * 6.28) * 0.5 + 0.5);\n\n    // fun with nonlinear transformations! (wind / turbulence)\n    space.y += random(space.x * warpFrequency + iTime * warpSpeed) * warpAmplitude * (0.5 + horizontalFade);\n    space.x += random(space.y * warpFrequency + iTime * warpSpeed + 2.0) * warpAmplitude * horizontalFade;\n    \n    vec4 lines = vec4(0);\n    \n    for(int l = 0; l < linesPerGroup; l++)\n    {\n        float normalizedLineIndex = float(l) / float(linesPerGroup);\n        float offsetTime = iTime * offsetSpeed;\n        float offsetPosition = float(l) + space.x * offsetFrequency;\n        float rand = random(offsetPosition + offsetTime) * 0.5 + 0.5;\n        float halfWidth = mix(minLineWidth, maxLineWidth, rand * horizontalFade) / 2.0;\n        float offset = random(offsetPosition + offsetTime * (1.0 + normalizedLineIndex)) * mix(minOffsetSpread, maxOffsetSpread, horizontalFade);\n        float linePosition = getPlasmaY(space.x, horizontalFade, offset);\n        float line = drawSmoothLine(linePosition, halfWidth, space.y) / 2.0 + drawCrispLine(linePosition, halfWidth * 0.15, space.y);\n        \n        float circleX = mod(float(l) + iTime * lineSpeed, 25.0) - 12.0;\n        vec2 circlePosition = vec2(circleX, getPlasmaY(circleX, horizontalFade, offset));\n        float circle = drawCircle(circlePosition, 0.01, space) * 4.0;\n        \n        \n        line = line + circle;\n        lines += line * lineColor * rand;\n    }\n    \n    fragColor = mix(bgColors[0], bgColors[1], uv.x);\n    fragColor *= verticalFade;\n    fragColor.a = 1.0;\n    // debug grid:\n    //fragColor = mix(fragColor, gridColor, drawGrid(space));\n    fragColor += lines;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltXczj.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 1568, 1604, 1604, 1800], [1802, 1802, 1830, 1830, 1918], [1920, 1993, 2016, 2016, 2090], [2092, 2092, 2158, 2158, 2260], [2262, 2262, 2319, 2319, 4199]]}
{"id": "ltXyD4", "name": "Dust in the PCI Slot?", "author": "DJDoomz", "description": "Based on Iq's integer hash and one of my own.\n", "tags": ["abstract"], "likes": 18, "viewed": 956, "date": "1504798310", "time_retrieved": "2024-06-20T19:01:09.812199", "image_code": "const int LOOP = 5;\n\nvec3 noise(uvec3 iuv){\n    iuv *=uvec3(5332,2524,7552);\n    for(int i = 0; i < LOOP; i++)\n    \tiuv += (iuv.yzx<<2) ^ (iuv.yxz)+iuv.z;\n    return vec3(iuv)*(1.0/float(0xffffffffU));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uvec3 p = uvec3(fragCoord,iFrame);\n\tfragColor = vec4(noise(p),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltXyD4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[21, 21, 43, 43, 203], [205, 205, 262, 262, 336]]}
{"id": "ltXyDM", "name": "Flickering Candlelight", "author": "ackleyrc", "description": "Iterating on Torchlight Test (https://www.shadertoy.com/view/XtsyDH) to create the shape and flickering effect of a candle flame. Can be moved with the mouse by uncommenting relevant code.", "tags": ["flame", "fire", "light", "flicker", "candle", "prng", "shape", "coherentnoise", "torch"], "likes": 3, "viewed": 408, "date": "1505030539", "time_retrieved": "2024-06-20T19:01:10.248653", "image_code": "// ----- math constants -----\nconst float PI = 3.14159265359;\nconst float TAU = 6.28318530718;\n\nfloat rand(float seed)\n{\n\t// Very simple pseudo-random number generator\n    // Returns a value between 0 and 1\n    // Preferentially returns the midrange\n    return mod(fract(sin(seed * 6789.54321)) + 0.5, 1.0);\n}\n\nfloat coherentNoise(float seed)\n{\n\tfloat a = floor(seed);\n    float b = ceil(seed);\n    float rA = rand(a);\n    float rB = rand(b);\n    if (rA == rB) {\n        return rA;\n    } else {\n        float nT = (1.0 - (b - seed)) / (b - a);\n        float cT = nT * nT * (3.0 - 2.0 * nT);\n        return rA + (cT * (rB - rA));\n    }\n}\n\nfloat multiOctaveNoise(float seed, int numOcts, float lacunarity, float persistence)\n{\n    float sum = 0.0;\n    for (int i = 0; i < numOcts; ++i)\n    {\n        float oct = coherentNoise(seed * pow(lacunarity, float(i)));\n        sum += oct * pow(persistence, float(i));  \n    }\n    return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 m = vec2(0.5,0.5);\n    // Uncomment the if clause below to move the flame around with the mouse\n    /*\n    if (iMouse.xy != vec2(0.0,0.0))\n    {\n    \tm = iMouse.xy / iResolution.xy;\n    }\n\t*/\n    \n    uv -= m;\n    uv -= vec2(0.0,-0.45);\n    float distortSpeed = 1.0;\n    float distortVar = multiOctaveNoise(iTime * distortSpeed + (0.25 * uv.y), 3, 2.0, 0.5);\n    uv -= vec2(0.15 * uv.y * (distortVar - 0.9),0.0);\n    \n    uv.x *= iResolution.x/iResolution.y;\n    float d = 1.0 * length(uv);\n    \n    float angleSpeed = 1.0;\n    float angle = atan(uv.x, uv.y);\n    float angleVar = multiOctaveNoise(iTime * angleSpeed, 3, 2.0, 0.5);\n    angle += 0.25 * ((angleVar * 0.125 * PI) - (0.125 * PI));\n    \n    float sizeSpeed = 1.0;\n    float sizeVar = multiOctaveNoise(iTime * sizeSpeed, 3, 3.0, 0.75);\n    \n    float redAngle = 1.0 - abs(angle);\n    redAngle = redAngle * (0.915 + 0.085 * sizeVar);\n    float redComp = smoothstep(redAngle, redAngle-0.4, d);\n    \n    float yellowAngle = 0.95 - abs(angle);\n    yellowAngle = 0.85 * yellowAngle * (0.915 + 0.085 * sizeVar);\n    float greenComp = smoothstep(yellowAngle, yellowAngle-0.35, d);\n    \n\tfragColor = vec4(redComp, greenComp, 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltXyDM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 96, 120, 249, 309], [311, 311, 344, 344, 636], [638, 638, 724, 724, 933], [935, 935, 992, 992, 2234]]}
{"id": "ltXyzS", "name": "Hot and Cold Crustacean", "author": "TheGrego", "description": "Varied rotations depending on distance from a point. It goes from hot to cold from within the crustacean's core.", "tags": ["2d", "sin", "rotate", "hot", "cold", "crustacean", "cineshader"], "likes": 11, "viewed": 15930, "date": "1505228208", "time_retrieved": "2024-06-20T19:01:10.436465", "image_code": "#define M_PI 3.1415926535897932384626433832795\n#define rot(a)  mat2( cos(a), sin(a),  -sin(a), cos(a) )\n\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    // set my uv\n    vec2 uv = iResolution.xy;\n    uv = (u+u - vec2(uv.x, 0) ) / uv.y;\n    \n    float T = iTime;\n    \n    // rotate the uv\n    float l = length(uv);\n    uv *= rot( l * 0.5);\n    uv *= uv/l * 4.0;\t\t// detail resolution\n        \n    // set some colors\n    vec3 color;\n    for( int i = 0; i < 3; i++){\n        float v = length( mod(uv, 0.5) - uv.x * 0.25 );\n        uv.y *= ((sin( v * 5.0) ) * 0.5) * ((sin(T - length(uv) * 0.5 ) + M_PI) * 0.4);\n        color[i] = cos(T + pow(length(uv), float(i) * 0.25));\n    }\n\n    vec3 color2 = vec3(pow(uv.y, 1.0) * 0.5);\n    fragColor = vec4( mix(color, color2, length(uv) * 0.5), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltXyzS.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[105, 105, 154, 171, 796]]}
{"id": "MlfcRS", "name": "A Viscous Wave Hello", "author": "TheGrego", "description": "A mendala of ripples and undulating trigonometry of viscosity.", "tags": ["procedural", "2d", "wave", "sin", "ripple"], "likes": 3, "viewed": 168, "date": "1505227486", "time_retrieved": "2024-06-20T19:01:10.436465", "image_code": "\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float z = iTime;\n    \n    // set centered uv\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0;\n    uv -= 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\t\n    // multiple and twist uv\n    uv *= sin(length(uv) * 2.0) * 7.0;\n\t\n    // calculate morphing central blobs\n    float val1 = length(uv);\n    val1 = 1.0 - fract(length(uv + sin(iTime + uv.x) * cos(iTime + uv.y) ));\n\t\n    // calculate rotating radial wave pattern\n    float val2 = length(uv * 0.1) * \n        cos( pow(sin(iTime + atan(uv.y, uv.x) * 10.0) + uv.x * length(uv * 0.1), 2.0 ));\n\n\t// combine values\n    float val = mix(val1, val2, sin(atan(uv.y, uv.x) * 10.0) );\n   \n    // colors\n    float r = pow(val, 5.0) * 3.0;\n    float g = val;\n    float b = val + 0.05;\n    fragColor = vec4(r, g, b, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlfcRS.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1, 1, 56, 56, 826]]}
{"id": "MlfcW2", "name": "Changing Eye", "author": "Kellers176", "description": "Here is an eye thing I made", "tags": ["colors", "eye"], "likes": 2, "viewed": 64, "date": "1506432133", "time_retrieved": "2024-06-20T19:01:10.436465", "image_code": "\nvec2 Position = vec2(0.5,0.5);\nvec2 maxSquare = vec2(0.75,0.75);\nvec2 minSquare = vec2(0.25,0.25);\nfloat Radius = .25;\nfloat Radius2 = .1;\nfloat Radius3 = .15;\nvec4 FGColor = vec4(1.0,1.0,1.0,1.0);\nvec4 BGColor = vec4(0.0,0.0,0.0,1.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 uv = fragCoord.xy / iResolution.xy;\nvec4 OtherColor = vec4 (0.0 + 0.5 *cos(iTime),0.0 + 0.5 *sin(iTime),1.0 + 0.5 *cos(iTime),1.0);\n\n//Question 1\nif(uv.x > minSquare.x && uv.x < maxSquare.x && uv.y > minSquare.y && uv.y < maxSquare.y)\nfragColor = FGColor;\nelse\nfragColor = BGColor;\n\n\n//Question 2 and Question 3\nfloat aspectRatio = iResolution.y / iResolution.x;\nPosition.y *= aspectRatio;\nuv.y *= aspectRatio;\n\n \n\nif(length(Position - uv) <= Radius2)\n{\nfragColor = BGColor;\n}\nelse if(length(Position - uv) <= Radius3)\n{\nfragColor = OtherColor;\n}\nelse if(length(Position - uv) <= Radius)\n{\nfragColor = FGColor;\n}\nelse\nfragColor = BGColor;\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlfcW2.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[238, 238, 295, 295, 942]]}
{"id": "MlfcW7", "name": "Raymarching Blended Functions", "author": "Lucky4Luuk", "description": "Modified version of IQ's Raymarching - Primivites shader: https://www.shadertoy.com/view/Xds3zN\nI'm working on putting this into a game engine.", "tags": ["raymarching", "distance", "function", "primitive"], "likes": 2, "viewed": 466, "date": "1505055241", "time_retrieved": "2024-06-20T19:01:11.667031", "image_code": "#define AA 4-3\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opI( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\nfloat opBlend(float d1, float d2, float a)\n{\n    if (a > 1.0)\n        a = 1.0;\n    if (a < 0.0)\n        a = 0.0;\n    return a * d1 + (1.0 - a) * d2;\n}\n\n// distance to sphere function (p is world position of the ray, s is sphere radius)\n// from http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere(vec3 p, float s)\n{\n\treturn length(p) - s;\n}\n\nfloat sdPlane(vec3 p)\n{\n    return p.y;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n    return length(max(abs(p)-b,0.0));\n}\n\nfloat fmod(float a, float b)\n{\n    if(a<0.0)\n    {\n        return b - mod(abs(a), b);\n    }\n    return mod(a, b);\n}\n\nvec2 map(vec3 pos)\n{\n    vec3 cp = vec3(0.0,0.0,0.0);\n    \n    vec2 res = opU(vec2(sdPlane(pos - vec3(0.0,0.0,0.0) + cp),1.0),\n                   vec2(sdSphere(pos - vec3(0.0,0.5,0.0) + cp,0.5),46.9));\n    \n    float b = opBlend(udBox(pos - vec3(1.0,0.5,0.0) + cp,vec3(0.5,0.5,0.5)),\n                      sdSphere(pos - vec3(1.0,0.5,0.0) + cp,0.5),(sin(iTime)+1.0)/2.0);\n    res = opU(res, vec2(b,78.5));\n    \n    b = opI(udBox(pos - vec3(-1.0,0.5 * (sin(iTime)+1.0)/2.0,0.0) + cp,vec3(0.5,0.5,0.5)),\n            sdSphere(pos - vec3(-1.0,0.5,0.0) + cp,0.5));\n    res = opU(res, vec2(b,129.8));\n    \n    b = opS(sdSphere(pos - vec3(-1.0,0.5,-1.0) + cp,0.5),\n            udBox(pos - vec3(-1.0,0.5 * (sin(iTime))/1.0,-1.0) + cp,vec3(0.5,0.5,0.5)));\n    res = opU(res, vec2(b,22.4));\n    \n    return res;\n}\n\nvec2 scene(vec3 position)\n{\n    vec3 translate = vec3(0.0, 0.5, 1.0);\n    \n    vec2 res = map(position);\n    \n    float distance = res.x;\n    float materialID = res.y;\n    \n    return vec2(distance, materialID);\n}\n\nvec2 castRay(vec3 pos, vec3 dir)\n{    \n    float tmin = 1.0;\n    float tmax = 20.0;\n\n#if 1\n    float tp1 = (0.0 - pos.y)/dir.y; if (tp1 > 0.0) tmax = min(tmax, tp1);\n    float tp2 = (1.6 - pos.y)/dir.y; if (tp2 > 0.0) { if (pos.y > 1.6) tmin = max(tmin, tp2);\n                                                     else tmax = min(tmax, tp2); }\n#endif\n    \n    float t = tmin;\n    float m = -1.0;\n    for (int i=0; i<64; i++)\n    {\n        float precis = 0.0005*t;\n        vec2 res = map(pos + dir*t);\n        if (res.x<precis || t>tmax) break;\n        t += res.x;\n        m = res.y;\n    }\n    \n    if (t>tmax) m=-1.0;\n    return vec2(t, m);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n    /*\n\tvec3 eps = vec3( 0.0005, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n\t*/\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        if( m<1.5 )\n        {\n            \n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.3 + 0.1*f*vec3(1.0);\n        }\n\n        // lighitng        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.30*dif*vec3(1.00,0.80,0.55);\n\t\tlin += 2.00*spe*vec3(1.00,0.90,0.70)*dif;\n        lin += 0.40*amb*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime;\n\n    \n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n\t\t// camera\t\n        vec3 ro = vec3( -0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.0*sin(0.1*time + 6.0*mo.x) );\n        vec3 ta = vec3( -0.5, -0.4, 0.5 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro - vec3(0.0,0.5,0.0), ta, 0.0 );\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\t\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlfcW7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[16, 16, 46, 46, 79], [81, 81, 114, 114, 140], [142, 142, 175, 175, 200], [202, 202, 246, 246, 352], [354, 513, 546, 546, 571], [573, 573, 596, 596, 614], [616, 616, 647, 647, 687], [689, 689, 719, 719, 804], [806, 806, 826, 826, 1609], [1611, 1611, 1638, 1638, 1824], [1826, 1826, 1860, 1860, 2467], [2469, 2469, 2543, 2543, 2803], [2805, 2805, 2837, 2837, 3276], [3278, 3278, 3320, 3320, 3619], [3622, 3622, 3661, 3661, 5232], [5234, 5234, 5286, 5286, 5463], [5465, 5465, 5522, 5522, 6511]]}
{"id": "MlfcWN", "name": "Weird Hash Noise", "author": "SugarRushLux", "description": "Weird", "tags": ["procedural", "crazy"], "likes": 1, "viewed": 67, "date": "1504822633", "time_retrieved": "2024-06-20T19:01:11.667031", "image_code": "float hash(float n)\n{\n \treturn fract(n*n*iTime*.02);   \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n   \tuv = ceil(uv*40.+40.*vec2(sin(iTime/13.),cos(iTime/2.)));\n\n    \n    fragColor = vec4(hash(2.0+iTime*uv.x), hash(3.0+iTime*uv.x), hash(4.0+iTime*uv.x), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlfcWN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 21, 21, 57], [60, 60, 117, 117, 322]]}
{"id": "MlfyDf", "name": "Capsule with light", "author": "Torumu106", "description": "capsule", "tags": ["light", "capsule"], "likes": 0, "viewed": 88, "date": "1506641311", "time_retrieved": "2024-06-20T19:01:11.667031", "image_code": "float PI = 3.1415926535;\nvec3 col = vec3(1.0, 1.0, 1.0);\nint stop = 0;\nvec3 stoppos = vec3(0.0);\nfloat map(vec3 p){\n    vec3 p1 = p;\n    p1.y -= clamp(p.y, 0.0, 2.0);\n    float d = length(p1 - vec3(-2.0, 0.0, 0.0)) - 1.0;\n    d = min(d, dot(p,vec3(0.0, 1.0, 0.0)) + 1.0);\n    return d;\n}\nvec3 grad(vec3 p) {\n    vec2 d = vec2(0.0, 0.001);\n\tfloat dFx = map(p + d.yxx) - map(p - d.yxx);\n\tfloat dFy = map(p + d.xyx) - map(p - d.xyx);\n\tfloat dFz = map(p + d.xxy) - map(p - d.xxy);\n\treturn normalize(vec3(dFx, dFy, dFz));\n}\nfloat trace(vec3 o, vec3 r){\n\tfloat t = 0.0;\n    vec3 p;\n    for(int i = 0; i < 128; ++i){\n    \tp = o + r * t;\n        float d = map(p);\n        if(d < 0.001){\n            stop = 1;\n        \tbreak;\n        }\n        t += d * 0.9;\n    }\n    stoppos = p;\n    return t;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 r = normalize(vec3(uv - vec2(0.0, PI / 3.0), 1.0));\n    \n    float the = iTime;\n    vec3 o = vec3(0.0,10.0, -10.0);\n    r.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    o.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    \n    float t = trace(o, r);\n    float light = 0.0;\n    if(stop == 1){\n    \tvec3 nor = grad(stoppos);\n        light = 0.7 * max(dot(nor, vec3(1.0)), 0.0) + 0.1;\n        stop = 0;\n        trace(stoppos + nor * 0.002, normalize(vec3(1.0)));\n        if(stop == 1) light = 0.1;\n    }\n    \n    vec3 fc = vec3(light) * col;\n    fragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlfyDf.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[97, 97, 115, 115, 287], [288, 288, 307, 307, 518], [519, 519, 547, 547, 787], [788, 788, 845, 845, 1551]]}
{"id": "MlfyW7", "name": "Psychedelic sinuous lines", "author": "luluco250", "description": "Some random effect that came out when I was trying to do some simple sinuous curve, but it looked too weird to not save it.\nI added the bizarre color combination on purpose.", "tags": ["2d", "sin", "color", "gradient", "curves", "psychedelic"], "likes": 0, "viewed": 81, "date": "1505052746", "time_retrieved": "2024-06-20T19:01:11.667031", "image_code": "void mainImage(out vec4 outCol, vec2 coord) {\n    vec2 uv = coord / iResolution.xy;\n    float factor = sin(iTime * 5.0 * uv.x) * 0.5 + 0.5;\n    \n    vec3 bg_col = mix(vec3(0.0), vec3(1.0, 0.0, 0.5), uv.y);\n    vec3 fg_col = mix(vec3(0.0, 1.0, 0.5), vec3(1.0), uv.y);\n    \n    vec3 col = uv.y > factor ? bg_col : fg_col;\n    \n    outCol = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlfyW7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 45, 45, 355]]}
{"id": "MlfyWf", "name": "Programming socks", "author": "luluco250", "description": "Don't ask", "tags": ["2d", "stripes"], "likes": 1, "viewed": 244, "date": "1506638217", "time_retrieved": "2024-06-20T19:01:12.042648", "image_code": "/*\n\tDedicated to />p/\n*/\n\nconst float stripe_color_speed = 0.01;\nconst float stripe_color_saturation = 0.45;\n\nconst float stripe_scale = 32.0;\nconst float inv_stripe_scale = 1.0 / stripe_scale;\n\nconst vec2 stripe_movement = vec2(2.0, 0.0);\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat wrap(float v, float _min, float _max) {\n\treturn mod(_min + (v - _min), _max - _min);\n}\n\nvoid mainImage(out vec4 col_out, vec2 coords) {\n    vec2 ps = vec2(1.0) / iResolution.xy;\n    vec2 uv = coords * ps;\n    \n    //move stripes\n    coords += vec2(iFrame) * stripe_movement;\n\n    //get \"blurred\" music frequency, so that it's not \"pointy\"\n    float music_wave = 0.0;    \n    const int samples = 6;\n    for (int i = 0; i < samples; ++i) {\n        music_wave += texture(iChannel0, vec2(uv.x * 0.16 + ps.x * float(i))).x;\n    }\n    music_wave /= float(samples);\n    music_wave *= 100.0;\n    \n    float distortion = 0.0;\n    distortion += sin(coords.x * 10.0) * 4.0;  //small noise\n    distortion += sin(coords.x * 0.03) * 8.0;  //medium noise\n    distortion += sin(coords.x * 0.01) * -50.0; //big noise\n    distortion += sin(coords.x * 0.01) * music_wave;\n    coords.y += distortion * 0.25;\n    \n    bool a_or_b = mod(coords.y * inv_stripe_scale, 2.0) < 1.0;\n    \n    float sock_hue = 0.0;\n    \n    //if the left mouse button is pressed\n    if (iMouse.z > 0.0)             //get a color hue from the mouse X position\n        sock_hue = iMouse.x * ps.x;\n    else                            //get a color hue from 0.0 to 1.0 based on time\n\t\tsock_hue = wrap(iTime * stripe_color_speed, 0.0, 1.0);\n    \n    //generate a RedGreenBlue color from a HueSaturationValue color\n    vec3 col_sock = hsv2rgb(vec3(sock_hue, stripe_color_saturation, 1.0));\n    \n    col_out.rgb = a_or_b ? col_sock : vec3(1.0);\n    col_out.a = 0.0;\n}\n", "image_inputs": [{"id": "4dXXDl", "previewfilepath": "https://soundcloud.com/crystalmist/macintosh-plus-420", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/crystalmist/macintosh-plus-420", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlfyWf.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 241, 263, 263, 432], [434, 434, 479, 479, 526], [528, 528, 575, 575, 1955]]}
{"id": "MllcD7", "name": "Voxel Space Skipping Example", "author": "fizzer", "description": ".", "tags": ["voxels"], "likes": 12, "viewed": 381, "date": "1505159168", "time_retrieved": "2024-06-20T19:01:12.679107", "image_code": "\n// Set this to nonzero to enable SDF-based space skipping.\n#define SKIP_SPACE 1\n\n// In this example:\n//   288 SDF samples when space skipping is enabled.\n//  1600 SDF samples when space skipping is disabled.\n\n// Signed distance field.\nfloat dist(vec3 p)\n{\n    // Just a field of repeating spheres.\n    p=mod(p,40.)-20.;\n    return length(p)-10.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n\n    vec2 t=uv-.5;\n    t.x*=iResolution.x/iResolution.y;\n\n    vec2 p=t.xy;\n\n    // Set up primary ray.\n    vec3 ro=vec3(0,30,-iTime*4.);\n    vec3 rd=normalize(vec3(p,-1.4));\n\n    vec3 co=ro;\n    vec3 ord=rd;\n\n    vec3 n;\n\n#if SKIP_SPACE\n    for(int j=0;j<4;++j)\n#endif\n    {\n        vec3 oro=ro;\n\n#if SKIP_SPACE\n\t\t// Use signed distance field raymarching to skip space quickly.\n        float t=0.;\n        for(int i=0;i<40;++i)\n        {\n            ro=oro+rd*t;\n            float d=dist(ro);\n            if(d<-3.)\n            {\n                break;\n            }\n            t+=d;\n        }\n#endif\n\n        // Prepare for uniform grid traversal.\n        oro=ro;\n        vec3 c=floor(ro);\n        vec3 ts=(c+max(vec3(0.),sign(rd))-ro)/rd;\n\n        // Perform uniform grid traversal.\n#if SKIP_SPACE\n        for(int i=0;i<32;++i)\n#else\n        // Use (many) more iterations to reach the same distances as would be reached with space skipping.\n        for(int i=0;i<1600;++i)\n#endif\n        {\n            // n holds 1.0 in the axis for which ts's component in that axis is\n            // the smallest, and 0.0 elsewhere. This indicates the axis plane with the closest intersection.\n            n=step(ts,ts.yzx)*step(ts,ts.zxy);\n            c+=sign(rd)*n;\n            float d=dist(c);\n            if(d<-1.7)\n            {\n\t\t        // Advance the ray march position to the next grid cell.\n                ro=oro+rd*min(ts.x,min(ts.y,ts.z));\n                break;\n            }\n            // Increment the axis plane inersections.\n            vec3 dd=sign(rd)/rd*n;\n            ts+=dd;\n        }\n        // Advance the ray march position to the next grid cell.\n        ro=oro+rd*min(ts.x,min(ts.y,ts.z));\n    }\n\n\n    // Checkerboard texture.\n    ro+=1e-3;\n    float tex=.8+.2*step(.5,fract(ro.x+.5*step(.5,fract(ro.y+.5*step(.5,fract(ro.z))))));\n\n    // Basic lighting.\n    vec3 ld=normalize(vec3(3,4,1));\n    fragColor.rgb=tex*vec3(.5+.5*dot(n*-sign(rd),ld));\n\n    // Distance fading.\n    float fogstrength=.001;\n    float fogamount=exp(-distance(ro,co)*fogstrength);\n    fragColor.rgb=mix(vec3(0),fragColor.rgb,fogamount);\n    \n    // Gamma.\n    fragColor.rgb=sqrt(fragColor.rgb);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MllcD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[210, 236, 256, 298, 348], [350, 350, 407, 407, 2686]]}
{"id": "MllcW8", "name": "Sea Net", "author": "TheGrego", "description": "Twisting net-like pattern", "tags": ["procedural", "2d", "blue"], "likes": 2, "viewed": 97, "date": "1504661731", "time_retrieved": "2024-06-20T19:01:12.685175", "image_code": "vec2 rotate( vec2 pt, float a ){\n\tmat2 r = mat2(cos(a), -sin(a),\n\t\t\t\t  sin(a), cos(a) );\n\treturn r * pt;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat z = iTime;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv *= 2.0;\n    uv -= 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= length(uv * 2.0) * 2.0;\n    uv = rotate(uv, sin(z * 0.5 + length(uv) * 0.2));\n    \n\n    vec3 c;\n\n    \n    for(int i=0; i<3; i++){\n    \tvec2 r = iResolution.xy;\n    \tfloat v = length(mod(uv,1.0)-0.5);\n    \tuv.x *= ((cos(z + v) + 1.0) * 0.5) * ((sin(z * 0.5) + 2.0) * 0.25);\n    \tuv.y *= ((sin(z + v) + 1.0) * 0.5) * ((sin(z * -0.5) + 2.0) * 0.25);\n    \tc[i] = cos( pow(length(uv * 1.0), 0.5 + float(i) * 0.1 ) );\n    }\n    \n    vec3 color = c * c;\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MllcW8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 32, 32, 106], [109, 109, 166, 166, 797]]}
{"id": "MllcWM", "name": "Thin Line", "author": "isak", "description": "Rotating thin line", "tags": ["distancefunction", "line", "aa", "thine"], "likes": 1, "viewed": 123, "date": "1505126253", "time_retrieved": "2024-06-20T19:01:12.685175", "image_code": "#define d_pix (1.0/iResolution.y)\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define pi 3.1415926535897932384626433832795\n\n\nfloat thin_line(vec2 uv, float a, float w){\n\n    vec2 direction = rot(a)*uv;\n    float d = abs(direction.x);\n    return smoothstep(1.0 + w, w - 1.0, d/d_pix);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n     \n    vec4 red = vec4(1, 0, 0, 1);\n    vec4 bg_color = 0.0*vec4(1, 1, 1, 1);\n\t\n    fragColor = bg_color;\n    \n    for (float i = -5.0; i < 6.0; i++)\n    \tfragColor += (red - bg_color)*thin_line(uv, (pi/4.)*sin(0.03*i*iTime), 1.0);\n}\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MllcWM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[134, 134, 177, 177, 299], [301, 301, 358, 358, 664]]}
{"id": "MllcWr", "name": "lighting practice2", "author": "Torumu106", "description": "lighting", "tags": ["lighting"], "likes": 0, "viewed": 62, "date": "1504448298", "time_retrieved": "2024-06-20T19:01:12.685175", "image_code": "float PI = 3.1415926535;\nvec3 col = vec3(1.0, 1.0, 1.0);\nint stop = 0;\nvec3 stoppos = vec3(0.0);\nfloat map(vec3 p){\n    float d = length(p) - 1.0;\n    d = min(d, dot(p,vec3(0.0, 1.0, 0.0)) + 1.0);\n    return d;\n}\nvec3 grad(vec3 p) {\n    vec2 d = vec2(0.0, 0.001);\n\tfloat dFx = map(p + d.yxx) - map(p - d.yxx);\n\tfloat dFy = map(p + d.xyx) - map(p - d.xyx);\n\tfloat dFz = map(p + d.xxy) - map(p - d.xxy);\n\treturn normalize(vec3(dFx, dFy, dFz));\n}\nfloat trace(vec3 o, vec3 r){\n\tfloat t = 0.0;\n    vec3 p;\n    for(int i = 0; i < 128; ++i){\n    \tp = o + r * t;\n        float d = map(p);\n        if(d < 0.001){\n            stop = 1;\n        \tbreak;\n        }\n        t += d * 0.9;\n    }\n    stoppos = p;\n    return t;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 r = normalize(vec3(uv - vec2(0.0, PI / 3.0), 1.0));\n    \n    float the = iTime;\n    vec3 o = vec3(0.0,10.0, -10.0);\n    r.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    o.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    \n    float t = trace(o, r);\n    float light = 0.0;\n    if(stop == 1){\n    \tvec3 nor = grad(stoppos);\n        light = 0.7 * max(dot(nor, vec3(1.0)), 0.0) + 0.1;\n        stop = 0;\n        trace(stoppos + nor * 0.002, normalize(vec3(1.0)));\n        if(stop == 1) light = 0.1;\n    }\n    \n    vec3 fc = vec3(light) * col;\n    fragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MllcWr.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[97, 97, 115, 115, 212], [213, 213, 232, 232, 443], [444, 444, 472, 472, 712], [713, 713, 770, 770, 1476]]}
{"id": "MllczB", "name": "Box Frustum Tracing", "author": "paniq", "description": "crossing planes indicate outer and inner near and far depths of scaled cube within frustum. Inner boundaries show 100% occlusion. The segments between outer and inner planes enclose a part of the surface.", "tags": ["intersection", "box", "frustum"], "likes": 10, "viewed": 962, "date": "1505392882", "time_retrieved": "2024-06-20T19:01:19.479635", "image_code": "// Box Frustum Tracing\n// using 2d vector graphics library (https://www.shadertoy.com/view/lslXW8)\n\n// for a description of the algorithm applied to ellipsoids see\n// https://gist.github.com/paniq/6c7a465b841dc2c87294c61108370389\n\n// note that this version is very verbose and purposefully lacks \n// any form of optimization for the sake of education.\n\nconst vec3 cube_init_center = vec3(0.0, 0.0, 3.0);\nconst vec2 min_frustum_half_size = vec2(1.77778,1.0)/30.0;\nconst vec2 max_frustum_half_size = vec2(1.77778,1.0)/6.0;\n\nconst int bound_none = 0;\nconst int bound_ray = 1;\nconst int bound_volume = 2;\nconst int bound_plane = 3;\n\nvec2 frustum_center;\nvec2 frustum_half_size;\nvec3 cube_center;\nvec3 cube_scale;\nvec4 cube_rotation;\nvec2 frustum_corners[4];\nvec3 frustum_ray_dirs[4];\nvec3 frustum_planes[4];\n// these are all in model space\nvec3 ms_frustum_apex;\nvec3 ms_frustum_ray_dirs[4];\nvec4 ms_frustum_planes[4];\nvec3 cube_corners[8];\nvec2 cube_ray_hits[4]; // these are scalars along the ray direction\nvec3 cube_edge_near[4];\nvec3 cube_edge_far[4];\nbvec2 cube_has_edge[4];\nbool cube_has_corner[8];\nvec2 outer_bound;\nvec2 inner_bound;\nivec2 outer_bound_type;\nivec2 inner_bound_type;\n\n// check only the horizontal frustum planes\nfloat dFrustumH(vec3 p) {\n    return max(\n        dot(p, frustum_planes[0]),\n        dot(p, frustum_planes[2]));    \n}\n\n// check only the vertical frustum planes\nfloat dFrustumV(vec3 p) {\n    return max(\n        dot(p, frustum_planes[1]),\n        dot(p, frustum_planes[3]));    \n}\n\nfloat dFrustum(vec3 p) {\n    return max(\n        dFrustumH(p),\n        dFrustumV(p));\n}\n\n// versor (unit quaternion) from axis and angle\nvec4 versor(vec3 axis, float angle) {\n    float a = angle * 0.5;\n    return vec4(axis * sin(a), cos(a));\n}\n\n// invert rotation\nvec4 conjugate(vec4 q) {    \n    return vec4(-q.xyz, q.w);\n}\n\n// rotate point by versor\n// q (t) * V * q (t) ^-1\nvec3 rotate(vec4 q, vec3 p) {\n    vec3 t = cross(q.xyz,p) * 2.0;\n    return p + q.w * t + cross(q.xyz, t);    \n}\n\nvec4 normalize_plane(vec4 pl) {\n    return pl / length(pl.xyz);\n}\n\n// transform vector in view space to model space\nvec3 modelspace_dir(vec3 v) {\n    return rotate(conjugate(cube_rotation), v) / cube_scale;\n}\n// transform vector in model space to view space\nvec3 viewspace_dir(vec3 v) {\n    return rotate(cube_rotation, v * cube_scale);\n}\n// transform point in view space to model space\nvec3 modelspace(vec3 p) {\n    return modelspace_dir(p - cube_center);\n}\n// transform point in model space to view space\nvec3 viewspace(vec3 p) {    \n    return viewspace_dir(p) + cube_center;\n}\n\n// from https://www.shadertoy.com/view/4s23DR\n// cube() by Simon Green\nvec2 intersect_unit_cube(vec3 org, vec3 dir)\n{\n\t// compute intersection of ray with all six bbox planes\n\tvec3 invR = -1.0/dir;\n\tvec3 tbot = invR * (org + 1.0);\n\tvec3 ttop = invR * (org - 1.0);\n\t\n\t// re-order intersections to find smallest and largest on each axis\n\tvec3 tmin = min (ttop, tbot);\n\tvec3 tmax = max (ttop, tbot);\n\t\n\t// find the largest tmin and the smallest tmax\n\tvec2 t0 = max(tmin.xx, tmin.yz);\n\tfloat near = max(t0.x, t0.y);\n\tt0 = min(tmax.xx, tmax.yz);\n\tfloat far = min(t0.x, t0.y);\n\n\t// check for hit\n    if (near < far && far > 0.0) {\n        return vec2(near, far);\n    } else {\n        return vec2(-1.0/0.0);\n    }\n}\nvec2 intersect_unit_cube(vec3 org, vec3 dir, out vec3 near_normal, out vec3 far_normal)\n{\n\t// compute intersection of ray with all six bbox planes\n\tvec3 invR = -1.0/dir;\n\tvec3 tbot = invR * (org + 1.0);\n\tvec3 ttop = invR * (org - 1.0);\n\t\n\t// re-order intersections to find smallest and largest on each axis\n\tvec3 tmin = min (ttop, tbot);\n\tvec3 tmax = max (ttop, tbot);\n\t\n\t// find the largest tmin and the smallest tmax\n\tvec2 t0 = max(tmin.xx, tmin.yz);\n\tfloat near = max(t0.x, t0.y);\n\tt0 = min(tmax.xx, tmax.yz);\n\tfloat far = min(t0.x, t0.y);\n\n\t// check for hit\n    if (near < far && far > 0.0) {\n        near_normal = -sign(dir) * step(tmin.yzx, tmin.xyz) * step(tmin.zxy, tmin.xyz);\n        far_normal = -sign(dir) * step(tmax.xyz, tmax.yzx) * step(tmax.xyz, tmax.zxy);        \n        return vec2(near, far);\n    } else {\n        return vec2(-1.0/0.0);\n    }\n}\n\n\nfloat intersect_plane_line(vec4 plane, vec3 ro, vec3 rd) {    \n    vec3 p0 = -dot(vec4(ro,1.0), plane)*plane.xyz;\n    return dot(p0, plane.xyz) / dot(rd, plane.xyz);\n}\n\nvoid intersect_plane_edge(int mc, vec4 plane, vec3 ro, vec3 rd, inout vec3 edge_near, inout vec3 edge_far, inout bvec2 has_edge) {\n    float d = intersect_plane_line(plane, ro, rd);\n    if (abs(d) < 1.0) {\n        vec3 p = viewspace(ro + rd * d);\n        float d;\n        if (mc == 0) {\n            d = dFrustumV(p);\n        } else {\n            d = dFrustumH(p);\n        }\n        if (d <= 0.0) {\n            if (!has_edge[0] || (p.z < edge_near.z)) {\n                edge_near = p;\n                has_edge[0] = true;\n            }\n            if (!has_edge[1] || (p.z > edge_far.z)) {\n                edge_far = p;\n                has_edge[1] = true;\n            }\n        }\n    }\n}\n\nvec2 lissajous(float t, float a, float b) {\n    return vec2(sin(a*t), sin(b*t));\n}\n\nvoid compute_bounds() {\n    outer_bound_type = ivec2(bound_none);\n    inner_bound_type = ivec2(bound_none);\n    outer_bound = vec2(1.0/0.0,-1.0/0.0);\n    inner_bound = vec2(-1.0/0.0,1.0/0.0);\n    \n    // check corners\n    for (int i = 0; i < 8; ++i) {\n        vec3 p = cube_corners[i];\n        if (cube_has_corner[i] && (p.z < outer_bound[0])) {\n        \touter_bound[0] = p.z;\n\t        outer_bound_type[0] = bound_volume;\n        }\n    }\n    // check edges\n    for (int i = 0; i < 4; ++i) {\n        if (cube_has_edge[i][0]\n            && (cube_edge_near[i].z < outer_bound[0])) {\n            outer_bound[0] = cube_edge_near[i].z;\n            outer_bound_type[0] = bound_plane;\n        }\n    }\n    // check faces\n    for (int i = 0; i < 4; ++i) {\n        if (cube_ray_hits[i].x >= 0.0) {\n            vec3 p = frustum_ray_dirs[i] * cube_ray_hits[i].x;\n            if (p.z < outer_bound[0]) {\n                outer_bound[0] = p.z;\n                outer_bound_type[0] = bound_ray;\n            }\n        }\n    }\n    // don't need to continue if we couldn't find a nearest depth\n    if (outer_bound_type[0] == bound_none) return;\n    \n    // check corners\n    for (int i = 0; i < 8; ++i) {\n        vec3 p = cube_corners[i];\n        if (cube_has_corner[i] && (p.z > outer_bound[1])) {\n        \touter_bound[1] = p.z;\n\t        outer_bound_type[1] = bound_volume;\n        }\n    }\n    // check edges\n    for (int i = 0; i < 4; ++i) {\n        if (cube_has_edge[i][1]\n            && (cube_edge_far[i].z > outer_bound[1])) {\n            outer_bound[1] = cube_edge_far[i].z;\n            outer_bound_type[1] = bound_plane;\n        }\n    }\n    // check faces\n    for (int i = 0; i < 4; ++i) {\n        if (cube_ray_hits[i].y >= 0.0) {\n            vec3 p = frustum_ray_dirs[i] * cube_ray_hits[i].y;\n            if (p.z > outer_bound[1]) {\n                outer_bound[1] = p.z;\n                outer_bound_type[1] = bound_ray;\n            }\n        }\n    }\n    \n    // we have an interior interval if all four corners\n    // hit the sphere\n    \n    int hits = 0;\n    for (int i = 0; i < 4; ++i) {\n        if (cube_ray_hits[i].x >= 0.0) {\n            hits++;\n        }    \n    }\n    \n    if (hits == 4) {\n        for (int i = 0; i < 4; ++i) {\n            if (cube_ray_hits[i].x >= 0.0) {\n                vec3 p0 = frustum_ray_dirs[i] * cube_ray_hits[i].x;\n                vec3 p1 = frustum_ray_dirs[i] * cube_ray_hits[i].y;\n                if (p0.z > inner_bound[0]) {\n                    inner_bound[0] = p0.z;\n                    inner_bound_type[0] = bound_ray;                \n                }\n                if (p1.z < inner_bound[1]) {\n                    inner_bound[1] = p1.z;\n                    inner_bound_type[1] = bound_ray;\n                }\n            }\n        }\n    }\n    \n    // if the interval is negative, we can't use it\n    if (inner_bound[1] < inner_bound[0]) {\n        inner_bound_type[0] = bound_none;\n    }    \n}\n\nvec4 plane_from_triangle(vec3 p0, vec3 d0, vec3 d1) {\n    vec3 n = normalize(cross(d0, d1));\n    return vec4(n, -dot(n, p0));\n}\n\nvoid setup_globals(float t) {\n    // move the frustum around\n    frustum_center = lissajous(t*0.07, 2.0, 1.0)*0.1;\n    // vary the frustum aperture\n    frustum_half_size = mix(\n        min_frustum_half_size,\n\t\tmax_frustum_half_size,\n        cos(t*0.13)*0.5+0.5);\n    \n    // move our cube around a bit\n    vec2 cube_offset = lissajous(t*0.2, 5.0, 4.0)*0.3;\n    cube_center = cube_init_center + vec3(cube_offset, 0.0);\n    cube_scale = vec3(\n        mix(0.2,1.0,cos(t*0.35)*0.5+0.5),\n        mix(0.2,1.0,cos(t*0.292)*0.5+0.5),\n        1.0);\n    cube_rotation = versor(normalize(vec3(1.0)), t*0.2);\n    \n    vec3 cd = vec3(1.0,-1.0,0.0);\n    cube_corners[0] = viewspace(vec3(cd.yyy));\n    cube_corners[1] = viewspace(vec3(cd.yyx));\n    cube_corners[2] = viewspace(vec3(cd.yxy));\n    cube_corners[3] = viewspace(vec3(cd.yxx));\n    cube_corners[4] = viewspace(vec3(cd.xyy));\n    cube_corners[5] = viewspace(vec3(cd.xyx));\n    cube_corners[6] = viewspace(vec3(cd.xxy));\n    cube_corners[7] = viewspace(vec3(cd.xxx));\n    \n    vec3 frustum_extents = vec3(frustum_half_size,-frustum_half_size.x);\n    frustum_corners[0] = frustum_center + frustum_extents.xy;\n    frustum_corners[1] = frustum_center + frustum_extents.zy;\n    frustum_corners[2] = frustum_center - frustum_extents.xy;\n    frustum_corners[3] = frustum_center - frustum_extents.zy;\n\n    ms_frustum_apex = modelspace(vec3(0.0));\n    \n    for (int i = 0; i < 4; ++i) {\n        frustum_ray_dirs[i] = normalize(vec3(frustum_corners[i],1.0));\n        ms_frustum_ray_dirs[i] = modelspace_dir(frustum_ray_dirs[i]);\n    }\n    \n    for (int i = 0; i < 4; ++i) {\n\t\tcube_ray_hits[i] = intersect_unit_cube(ms_frustum_apex, ms_frustum_ray_dirs[i]);\n    }\n    \n    frustum_planes[0] = normalize(cross(frustum_ray_dirs[1],frustum_ray_dirs[0]));\n    frustum_planes[1] = normalize(cross(frustum_ray_dirs[2],frustum_ray_dirs[1]));\n    frustum_planes[2] = normalize(cross(frustum_ray_dirs[3],frustum_ray_dirs[2]));\n    frustum_planes[3] = normalize(cross(frustum_ray_dirs[0],frustum_ray_dirs[3]));\n    \n    ms_frustum_planes[0] = plane_from_triangle(ms_frustum_apex,ms_frustum_ray_dirs[1],ms_frustum_ray_dirs[0]);\n    ms_frustum_planes[1] = plane_from_triangle(ms_frustum_apex,ms_frustum_ray_dirs[2],ms_frustum_ray_dirs[1]);\n    ms_frustum_planes[2] = plane_from_triangle(ms_frustum_apex,ms_frustum_ray_dirs[3],ms_frustum_ray_dirs[2]);\n    ms_frustum_planes[3] = plane_from_triangle(ms_frustum_apex,ms_frustum_ray_dirs[0],ms_frustum_ray_dirs[3]);\n    \n    for (int i = 0; i < 8; ++i) {\n        cube_has_corner[i] = (dFrustum(cube_corners[i]) <= 0.0);\n    }    \n    \n    for (int i = 0; i < 4; ++i) {\n        vec4 pl = ms_frustum_planes[i];\n        int mc = 0;\n        if ((i == 1)||(i == 3))\n            mc = 1;\n        cube_edge_near[i] = vec3(1.0/0.0);\n        cube_edge_far[i] = vec3(-1.0/0.0);\n        cube_has_edge[i] = bvec2(false);\n        intersect_plane_edge(mc, pl, cd.xxz, cd.zzx, cube_edge_near[i], cube_edge_far[i], cube_has_edge[i]);\n        intersect_plane_edge(mc, pl, cd.yxz, cd.zzx, cube_edge_near[i], cube_edge_far[i], cube_has_edge[i]);\n        intersect_plane_edge(mc, pl, cd.yyz, cd.zzx, cube_edge_near[i], cube_edge_far[i], cube_has_edge[i]);\n        intersect_plane_edge(mc, pl, cd.xyz, cd.zzx, cube_edge_near[i], cube_edge_far[i], cube_has_edge[i]);\n\n        intersect_plane_edge(mc, pl, cd.xzx, cd.zxz, cube_edge_near[i], cube_edge_far[i], cube_has_edge[i]);\n        intersect_plane_edge(mc, pl, cd.yzx, cd.zxz, cube_edge_near[i], cube_edge_far[i], cube_has_edge[i]);\n        intersect_plane_edge(mc, pl, cd.yzy, cd.zxz, cube_edge_near[i], cube_edge_far[i], cube_has_edge[i]);\n        intersect_plane_edge(mc, pl, cd.xzy, cd.zxz, cube_edge_near[i], cube_edge_far[i], cube_has_edge[i]);\n\n        intersect_plane_edge(mc, pl, cd.zxx, cd.xzz, cube_edge_near[i], cube_edge_far[i], cube_has_edge[i]);\n        intersect_plane_edge(mc, pl, cd.zyx, cd.xzz, cube_edge_near[i], cube_edge_far[i], cube_has_edge[i]);\n        intersect_plane_edge(mc, pl, cd.zyy, cd.xzz, cube_edge_near[i], cube_edge_far[i], cube_has_edge[i]);\n        intersect_plane_edge(mc, pl, cd.zxy, cd.xzz, cube_edge_near[i], cube_edge_far[i], cube_has_edge[i]);        \n    }\n    \n\tcompute_bounds();    \n   \n}\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1);\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1);\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r);\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r);\nvoid set_source(sampler2D image);\n// control how source changes are applied\nconst int Replace = 0; // default: replace the new source with the old one\nconst int Alpha = 1; // alpha-blend the new source on top of the old one\nconst int Multiply = 2; // multiply the new source with the old one\nvoid set_source_blend_mode(int mode);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add an ellipse path at P with radii RW and RH\nvoid ellipse(vec2 p, vec2 r);\nvoid ellipse(float x, float y, float rw, float rh);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n// add a rectangle at O with size S and rounded corner of radius R\nvoid rounded_rectangle(vec2 o, vec2 s, float r);\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// non-uniformly scale the context by S\nvoid scale(vec2 s);\nvoid scale(float sx, float sy);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    vec2 clip;\n    vec2 scale;\n    float line_width;\n    bool premultiply;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n    int source_blend;\n    bool has_clip;\n};\n\nfloat AA;\nfloat AAINV;\n\n// save current stroke width, starting\n// point and blend mode from active context.\nContext _save();\n// restore stroke width, starting point\n// and blend mode to a context previously returned by save()\nvoid restore(Context ctx);\n\n#define save(name) Context name = _save();\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\nvoid debug_clip_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\nconst float max_frustum_depth = 5.0;\nconst vec3 light_dir = normalize(vec3(-1.0, -1.0, 1.0));\nconst vec3 backlight_dir = normalize(vec3(0.8, 1.0, -1.0));\n\n\n// from https://www.shadertoy.com/view/4sjXW1\nvec3 tex(in vec2 p)\n{\n    float frq =50.3;\n    p += 0.405;\n    return vec3(1.)*smoothstep(.9, 1.05, max(sin((p.x)*frq),sin((p.y)*frq)));\n}\n\nfloat checkers(vec3 p) {\n    vec3 q = floor(p);\n    return mod(q.x + q.y + q.z, 2.0);\n}\n\nvoid paint_cube(vec3 ro, vec3 rd) {\n    vec3 ms_ro = modelspace(ro);\n    vec3 ms_rd = modelspace_dir(rd);\n    vec3 near_normal, far_normal;\n    vec2 range = intersect_unit_cube(ms_ro, ms_rd, near_normal, far_normal);\n    if (range.x > 0.0) {\n        add_field(-1.0);\n        vec3 dist = rd * range.x;\n        float df = dFrustum(ro + dist);\n        vec3 far_dist = rd * range.y;\n        float far_df = dFrustum(ro + far_dist);\n        vec3 ms_p_near = ms_ro + ms_rd * range.x;\n        vec3 ms_p_far = ms_ro + ms_rd * range.y;\n        vec3 normal;\n        vec3 ms_p;\n        bool backface = false;\n        if ((df < 0.0)||(far_df > 0.0)) {\n            normal = near_normal;\n            ms_p = ms_p_near;\n        } else {\n            ms_p = ms_p_far;\n            backface = true;\n            dist = far_dist;\n            df = far_df;\n            normal = far_normal;\n        }\n        vec3 color = vec3(0.0, 0.05, 0.1);\n        float lit = max(dot(normal, light_dir), 0.0);\n        float backlit = max(dot(normal, backlight_dir), 0.0);\n        color += lit * vec3(1.0,0.9,0.8);\n        color += backlit * vec3(1.0);\n        color *= vec3(mix(0.5,1.0,checkers(ms_p * 2.01)));\n        if (df < 0.0) {\n            if (backface) {\n                color *= vec3(0.7,0.9,1.0);\n            }                \n        }\n        color = pow(color, vec3(0.5));\n        color = mix(color, vec3(1.0), float(df > 0.0)*0.8);\n        color = mix(vec3(0.0), color, clamp((abs(df)-AAINV*1.5)*AA,-1.0,1.0)*0.5+0.5);\n        set_source_rgb(color);\n\t    fill();\n\t    new_path();\n    }\n}\n\nvoid paint_cube_zx() {\n    vec2 pt = get_origin();\t\n    paint_cube(\n        vec3(-pt[1], 2.0, pt[0]),\n        vec3(0.0, -1.0, 0.0));    \n}\n\nvoid paint_cube_zy() {\n    vec2 pt = get_origin();\t\n    paint_cube(\n        vec3(2.0, pt[1], pt[0]),\n        vec3(-1.0, 0.0, 0.0));    \n}\n\nvoid paint_cube_xy() {\n    vec2 pt = get_origin();\t\n    paint_cube(\n        vec3(pt[0], pt[1], -2.0),\n        vec3(0.0, 0.0, 1.0));\n}\n\nvoid paint_frustum_edges(vec2 pt[4]) {\n    for (int i = 0; i < 4; ++i) {\n\t\tmove_to(0.0, 0.0);\n\t\tline_to(pt[i]);\n    }\n    move_to(pt[0]);\n    for (int i = 1; i < 4; ++i) {\n\t\tline_to(pt[i]);\n    }    \n    close_path();\n}\n\nvoid paint_frustum_zx() {\n\tvec2 pts[4];\n    for (int i = 0; i < 4; ++i) {\n        vec3 corner = vec3(frustum_corners[i],1.0) * max_frustum_depth;\n        pts[i] = vec2(corner[2],-corner[0]);\n\t}\n    paint_frustum_edges(pts);\n}\nvoid paint_frustum_zy() {\n\tvec2 pts[4];\n    for (int i = 0; i < 4; ++i) {\n        vec3 corner = vec3(frustum_corners[i],1.0) * max_frustum_depth;\n        pts[i] = vec2(corner[2],corner[1]);\n\t}\n    paint_frustum_edges(pts);\n}\nvoid paint_frustum_xy() {\n\tvec2 pts[4];\n    for (int i = 0; i < 4; ++i) {\n        vec3 corner = vec3(frustum_corners[i],1.0) * max_frustum_depth;\n        pts[i] = vec2(corner[0],corner[1]);\n\t}\n    paint_frustum_edges(pts);\n}\n\nvec3 bound_color(int bound) {\n    if (bound == bound_volume) {\n        return vec3(1.0,0.0,0.5);\n    } else if (bound == bound_plane) {\n        return vec3(0.0,0.5,1.0);\n    } else if (bound == bound_ray) {\n        return vec3(1.0,0.5,0.0);\n    } else {\n        return vec3(0.0);\n    }\n}\n\nvoid paint() {\n    float t = iTime;\n    setup_globals(t);    \n        \n    float rdot = AAINV*8.0;\n\n    scale(0.4);\n\t\n    save(topview);\n    translate(-1.0,0.9);\n    save(topviewctx);\n    paint_cube_zx();\n    if (outer_bound_type[0] != bound_none) {\n        if (inner_bound_type[0] != bound_none) {\n            vec3 p0 = vec3(frustum_corners[1],1.0) * inner_bound[0];\n            vec3 p1 = vec3(frustum_corners[0],1.0) * inner_bound[0];\n            vec3 p2 = vec3(frustum_corners[0],1.0) * inner_bound[1];\n            vec3 p3 = vec3(frustum_corners[1],1.0) * inner_bound[1];\n            set_source_rgba(1.0,0.5,0.0,0.3);\n            move_to(p0.z, -p0.x);\n            line_to(p1.z, -p1.x);\n            line_to(p2.z, -p2.x);\n            line_to(p3.z, -p3.x);\n            close_path();\n            set_line_width(0.2);\n            fill();\n        }        \n        vec3 p0 = vec3(frustum_corners[1],1.0) * outer_bound[0];\n        vec3 p1 = vec3(frustum_corners[0],1.0) * outer_bound[0];\n        vec3 p2 = vec3(frustum_corners[0],1.0) * outer_bound[1];\n        vec3 p3 = vec3(frustum_corners[1],1.0) * outer_bound[1];\n        set_line_width_px(1.0);\n        set_source_rgb(bound_color(outer_bound_type[0]));\n\t\tmove_to(p0.z, -p0.x); \n        line_to(p1.z, -p1.x);\n\t\tstroke();\n        set_source_rgb(bound_color(outer_bound_type[1]));\n\t\tmove_to(p2.z, -p2.x); \n        line_to(p3.z, -p3.x);\n\t\tstroke();        \n    }\n    set_source_rgb(vec3(0.0));\n    set_line_width_px(1.0);\n    paint_frustum_zx();\n    stroke();\n    set_source_rgb(0.0,0.5,1.0);\n    for (int i = 0; i < 4; ++i) {\n        if (i == 2) continue;\n        if (cube_has_edge[i][0]) {\n            circle(cube_edge_near[i].z, -cube_edge_near[i].x, rdot);\n        }\n        if (cube_has_edge[i][1]) {\n            circle(cube_edge_far[i].z, -cube_edge_far[i].x, rdot);\n        }\n    }\n    fill();                    \n    set_source_rgb(1.0,0.0,0.5);\n    for (int i = 0; i < 8; ++i) {\n        if (cube_has_corner[i]) {\n\t    \tcircle(cube_corners[i].z, -cube_corners[i].x, rdot);\n        }\n    }\n    fill();                  \n    restore(topview);\n\t\n    save(sideview);\n    translate(-1.0,-1.6);\n    save(sideviewctx);\n    paint_cube_zy();\n    if (outer_bound_type[0] != bound_none) {\n        if (inner_bound_type[0] != bound_none) {\n            vec3 p0 = vec3(frustum_corners[0],1.0) * inner_bound[0];\n            vec3 p1 = vec3(frustum_corners[3],1.0) * inner_bound[0];\n            vec3 p2 = vec3(frustum_corners[3],1.0) * inner_bound[1];\n            vec3 p3 = vec3(frustum_corners[0],1.0) * inner_bound[1];\n            set_source_rgba(1.0,0.5,0.0,0.3);\n            move_to(p0.zy);\n            line_to(p1.zy);\n            line_to(p2.zy);\n            line_to(p3.zy);\n            close_path();\n            set_line_width(0.2);\n            fill();\n        }                \n        vec3 p0 = vec3(frustum_corners[0],1.0) * outer_bound[0];\n        vec3 p1 = vec3(frustum_corners[3],1.0) * outer_bound[0];\n        vec3 p2 = vec3(frustum_corners[3],1.0) * outer_bound[1];\n        vec3 p3 = vec3(frustum_corners[0],1.0) * outer_bound[1];\n        set_line_width_px(1.0);\n        set_source_rgb(bound_color(outer_bound_type[0]));\n\t\tmove_to(p0.zy); \n        line_to(p1.zy);\n\t\tstroke();\n        set_source_rgb(bound_color(outer_bound_type[1]));\n\t\tmove_to(p2.zy); \n        line_to(p3.zy);\n\t\tstroke();        \n    }    \n    set_source_rgb(vec3(0.0));\n    set_line_width_px(1.0);\n    paint_frustum_zy();\n    stroke();\n    set_source_rgb(0.0,0.5,1.0);\n    for (int i = 0; i < 4; ++i) {\n        if (cube_has_edge[i][0]) {\n            circle(cube_edge_near[i].z, cube_edge_near[i].y, rdot);\n        }\n        if (cube_has_edge[i][1]) {\n            circle(cube_edge_far[i].z, cube_edge_far[i].y, rdot);\n        }\n    }\n    fill();\n    set_source_rgb(1.0,0.0,0.5);\n    for (int i = 0; i < 8; ++i) {\n        if (cube_has_corner[i]) {\n\t    \tcircle(cube_corners[i].z, cube_corners[i].y, rdot);\n        }\n    }    \n    fill();    \n    restore(sideview);\n    \n\tsave(backview);\n    translate(-2.5,-0.4);\n    save(backviewctx);\n    paint_cube_xy();\n    if (outer_bound_type[0] != bound_none) {\n        {\n            vec3 p0 = vec3(frustum_corners[0],1.0) * outer_bound[1];\n            vec3 p1 = vec3(frustum_corners[1],1.0) * outer_bound[1];\n            vec3 p2 = vec3(frustum_corners[2],1.0) * outer_bound[1];\n            vec3 p3 = vec3(frustum_corners[3],1.0) * outer_bound[1];\n            set_source_rgba(vec4(bound_color(outer_bound_type[1]),0.3));\n            move_to(p0.xy);\n            line_to(p1.xy);\n            line_to(p2.xy);\n            line_to(p3.xy);\n            close_path();\n            set_line_width_px(1.0);\n            stroke();\n        }        \n        if (inner_bound_type[0] != bound_none) {\n            vec3 p0 = vec3(frustum_corners[0],1.0) * inner_bound[1];\n            vec3 p1 = vec3(frustum_corners[1],1.0) * inner_bound[1];\n            vec3 p2 = vec3(frustum_corners[2],1.0) * inner_bound[1];\n            vec3 p3 = vec3(frustum_corners[3],1.0) * inner_bound[1];\n            set_source_rgba(vec4(bound_color(inner_bound_type[1]),0.3));\n            move_to(p0.xy);\n            line_to(p1.xy);\n            line_to(p2.xy);\n            line_to(p3.xy);\n            close_path();\n            set_line_width_px(1.0);\n            stroke();            \n        }\n        {\n            vec3 p0 = vec3(frustum_corners[0],1.0) * outer_bound[0];\n            vec3 p1 = vec3(frustum_corners[1],1.0) * outer_bound[0];\n            vec3 p2 = vec3(frustum_corners[2],1.0) * outer_bound[0];\n            vec3 p3 = vec3(frustum_corners[3],1.0) * outer_bound[0];\n            set_source_rgb(bound_color(outer_bound_type[0]));\n            move_to(p0.xy);\n            line_to(p1.xy);\n            line_to(p2.xy);\n            line_to(p3.xy);\n            close_path();\n            set_line_width_px(1.0);\n            stroke();\n        }\n        if (inner_bound_type[0] != bound_none) {\n            vec3 p0 = vec3(frustum_corners[0],1.0) * inner_bound[0];\n            vec3 p1 = vec3(frustum_corners[1],1.0) * inner_bound[0];\n            vec3 p2 = vec3(frustum_corners[2],1.0) * inner_bound[0];\n            vec3 p3 = vec3(frustum_corners[3],1.0) * inner_bound[0];\n            set_source_rgb(bound_color(inner_bound_type[1]));\n            move_to(p0.xy);\n            line_to(p1.xy);\n            line_to(p2.xy);\n            line_to(p3.xy);\n            close_path();\n            set_line_width_px(1.0);\n            stroke();            \n        }        \n    }\n    set_source_rgb(vec3(0.0));\n    set_line_width_px(1.0);\n    paint_frustum_xy();\n    stroke();\n    set_source_rgb(1.0,0.0,0.5);\n    for (int i = 0; i < 8; ++i) {\n        if (cube_has_corner[i]) {\n\t    \tcircle(cube_corners[i].x, cube_corners[i].y, rdot);\n        }\n    }    \n    fill();    \n    restore(backview);\n\n    for (int i = 0; i < 4; ++i) {\n        vec2 dists = cube_ray_hits[i];\n        restore(backviewctx);\n        set_source_rgb(0.0,0.5,1.0);\n        if (cube_has_edge[i][0]) {            \n            circle(cube_edge_near[i].x, cube_edge_near[i].y, rdot);\n        }\n        if (cube_has_edge[i][1]) {\n            circle(cube_edge_far[i].x, cube_edge_far[i].y, rdot);\n        }        \n        fill();                    \n        if (dists.x > 0.0) {\n\t        vec3 enter = frustum_ray_dirs[i] * dists.x;\n            vec3 leave = frustum_ray_dirs[i] * dists.y;\n\t\t    restore(backviewctx);\n            set_source_rgb(1.0,0.5,0.0);\n            circle(enter.x, enter.y, rdot);\n            circle(leave.x, leave.y, rdot);\n            fill();\n            if (i < 2) {\n\t\t\t    restore(topviewctx);\n                set_source_rgb(1.0,0.5,0.0);\n                circle(enter.z, -enter.x, rdot);\n                circle(leave.z, -leave.x, rdot);\n                fill();\n            }\n            if ((i == 0)||(i == 3)) {\n\t\t\t    restore(sideviewctx);\n                set_source_rgb(1.0,0.5,0.0);\n                circle(enter.z, enter.y, rdot);\n                circle(leave.z, leave.y, rdot);\n                fill();                \n            }\n        }\n    }\n    \n    \n}\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n#define DEFAULT_CLIP_V -1e+20\n\nContext _stack;\n\nvoid init (vec2 fragCoord) {\n    uv = fragCoord.xy / iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n\n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        vec2(DEFAULT_CLIP_V),\n        vec2(1.0),\n        1.0,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0),\n        Replace,\n        false\n    );\n}\n\nvec3 _color = vec3(1.0);\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n    _stack.clip.y = DEFAULT_CLIP_V;\n}\n\nContext _save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;\n    vec2 clip = _stack.clip;\n    bool has_clip = _stack.has_clip;\n    // preserve source\n    vec4 source = _stack.source;\n    _stack = ctx;\n    _stack.shape = shape;\n    _stack.clip = clip;\n    _stack.source = source;\n    _stack.has_clip = has_clip;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = vec2(1.0);\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;\n    _stack.scale = vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    _stack.scale *= vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(vec2 s) {\n    transform(mat3(s.x,0.0,0.0,0.0,s.y,0.0,0.0,0.0,1.0));\n}\n\nvoid scale(float sx, float sy) {\n    scale(vec2(sx, sy));\n}\n\nvoid scale(float s) {\n    scale(vec2(s));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color = mix(_color, _stack.source.rgb, _stack.source.a);\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(_color, 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = _color;\n}\n\nvoid add_clip(vec2 d) {\n    d = d / _stack.scale;\n    _stack.clip = max(_stack.clip, d);\n    _stack.has_clip = true;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);\n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n    _stack.clip = vec2(DEFAULT_CLIP_V);\n    _stack.has_clip = false;\n}\n\nvoid debug_gradient() {\n    vec2 d = _stack.shape;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid debug_clip_gradient() {\n    vec2 d = _stack.clip;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color = _color * (1.0 - src_a) + rgba.rgb * dst_a;\n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat min_uniform_scale() {\n    return min(_stack.scale.x, _stack.scale.y);\n}\n\nfloat uniform_scale_for_aa() {\n    return min(1.0, _stack.scale.x / _stack.scale.y);\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA*uniform_scale_for_aa(), 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);\n\treturn wa * wb;\n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n    if (_stack.has_clip) {\n\t    write_color(_stack.source, calc_aa_blur(_stack.clip.x));        \n    }\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*min_uniform_scale() * AAINV;\n}\n\nfloat get_gradient_eps() {\n    return (1.0 / min_uniform_scale()) * AAINV;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    if (_stack.source_blend == Multiply) {\n        _stack.source *= c;\n    } else if (_stack.source_blend == Alpha) {\n    \tfloat src_a = c.a;\n    \tfloat dst_a = _stack.premultiply?1.0:src_a;\n\t    _stack.source =\n            vec4(_stack.source.rgb * (1.0 - src_a) + c.rgb * dst_a,\n                 max(_stack.source.a, c.a));\n    } else {\n    \t_stack.source = c;\n    }\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) {\n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1) {\n    vec2 pa = _stack.position.xy - p0;\n    vec2 ba = p1 - p0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1) {\n    set_source_linear_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p0, p1);\n}\n\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r) {\n    float h = clamp( length(_stack.position.xy - p) / r, 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r) {\n    set_source_radial_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p, r);\n}\n\nvoid set_source_blend_mode(int mode) {\n    _stack.source_blend = mode;\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid rounded_rectangle(vec2 o, vec2 s, float r) {\n    s = (s * 0.5);\n    r = min(r, min(s.x, s.y));\n    o += s;\n    s -= r;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    vec2 df = max(dmin.xz, dmin.yw) + length2(dmax);\n    add_field(df - r);\n}\n\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), r);\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    rounded_rectangle(o, s, 0.0);\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), 0.0);\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\n// from https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n    if (l == 0.0) {\n        return length(p) - ab.x;\n    }\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 r = vec2( ab.x*co, ab.y*si );\n\t\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nvoid ellipse(vec2 p, vec2 r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(sdEllipse(c.xy, r), sdEllipse(c.zw, r)));\n}\n\nvoid ellipse(float x, float y, float rw, float rh) {\n    ellipse(vec2(x,y), vec2(rw, rh));\n}\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 s = sign(pa.xz*ba.y-pa.yw*ba.x);\n    vec2 d = length2(pa - ba.xyxy*h.xxyy);\n    add_field(d);\n    add_clip(d * s);\n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat test_cross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat bezier_sign(vec2 A, vec2 B, vec2 C, vec2 p) {\n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0,\n        step(test_cross(A, B, p) * test_cross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * test_cross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    vec2 shape = vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw));\n    add_field(abs(shape));\n    add_clip(shape);\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(abs(f_x) / length(df_x));\n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t aspect = vec2(iResolution.x / iResolution.y, 1.0);\n\t ScreenH = min(iResolution.x,iResolution.y);\n\t AA = ScreenH*0.4;\n\t AAINV = 1.0 / AA;\n\n    init(fragCoord);\n\n    paint();\n\n    blit(fragColor);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MllczB.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1185, 1229, 1254, 1254, 1347], [1349, 1391, 1416, 1416, 1509], [1511, 1511, 1535, 1535, 1598], [1600, 1648, 1685, 1685, 1754], [1756, 1775, 1799, 1799, 1835], [1837, 1888, 1917, 1917, 2000], [2002, 2002, 2033, 2033, 2067], [2069, 2118, 2147, 2147, 2210], [2211, 2260, 2288, 2288, 2340], [2341, 2389, 2414, 2414, 2460], [2461, 2509, 2533, 2533, 2582], [2584, 2655, 2701, 2758, 3292], [3293, 3293, 3382, 3439, 4156], [4159, 4159, 4217, 4217, 4326], [4328, 4328, 4458, 4458, 5013], [5015, 5015, 5058, 5058, 5097], [5099, 5099, 5122, 5122, 8019], [8021, 8021, 8074, 8074, 8148], [8150, 8150, 8179, 8210, 12383], [18416, 18462, 18483, 18483, 18600], [18602, 18602, 18626, 18626, 18689], [18691, 18691, 18726, 18726, 20254], [20256, 20256, 20278, 20278, 20394], [20396, 20396, 20418, 20418, 20533], [20535, 20535, 20557, 20557, 20668], [20670, 20670, 20708, 20708, 20889], [20891, 20891, 20916, 20916, 21116], [21117, 21117, 21142, 21142, 21341], [21342, 21342, 21367, 21367, 21566], [21568, 21568, 21597, 21597, 21855], [21857, 21857, 21871, 21871, 29911], [30065, 30125, 30152, 30152, 30178], [30180, 30240, 30261, 30261, 30368], [30370, 30370, 30407, 30407, 30493], [30495, 30495, 30541, 30541, 30574], [30576, 30714, 30742, 30742, 31202], [31230, 31230, 31249, 31249, 31282], [31284, 31284, 31302, 31302, 31335], [31337, 31337, 31361, 31361, 31465], [31467, 31467, 31484, 31484, 31505], [31507, 31507, 31534, 31556, 31839], [31841, 31841, 31869, 31869, 32103], [32105, 32105, 32129, 32129, 32215], [32217, 32217, 32244, 32244, 32457], [32459, 32459, 32485, 32485, 32713], [32715, 32715, 32737, 32737, 32863], [32865, 32865, 32885, 32885, 32945], [32947, 32947, 32979, 32979, 33006], [33008, 33008, 33029, 33029, 33051], [33053, 33053, 33077, 33077, 33137], [33139, 33139, 33173, 33173, 33197], [33199, 33199, 33213, 33213, 33277], [33279, 33279, 33305, 33305, 33337], [33339, 33339, 33365, 33365, 33386], [33388, 33388, 33411, 33411, 33506], [33508, 33508, 33532, 33532, 33601], [33603, 33603, 33628, 33628, 33675], [33677, 33677, 33694, 33694, 33807], [33809, 33809, 33832, 33832, 33961], [33963, 33963, 33991, 33991, 34119], [34121, 34121, 34145, 34145, 34285], [34287, 34287, 34325, 34325, 34459], [34461, 34461, 34498, 34498, 34533], [34535, 34535, 34562, 34562, 34612], [34614, 34614, 34644, 34644, 34700], [34702, 34702, 34731, 34731, 34912], [34914, 34914, 34936, 34936, 35103], [35105, 35105, 35118, 35118, 35157], [35159, 35159, 35189, 35189, 35218], [35220, 35220, 35253, 35253, 35310], [35312, 35312, 35338, 35338, 35388], [35390, 35390, 35411, 35411, 35476], [35478, 35478, 35502, 35502, 35585], [35587, 35587, 35602, 35602, 35643], [35645, 35645, 35661, 35661, 35699], [35701, 35701, 35719, 35719, 35776], [35778, 35778, 35808, 35808, 36178], [36180, 36180, 36238, 36238, 36276], [36278, 36278, 36307, 36307, 36343], [36345, 36345, 36393, 36393, 36424], [36426, 36426, 36460, 36460, 36519], [36521, 36521, 36598, 36598, 36763], [36765, 36765, 36842, 36842, 36922], [36924, 36924, 37000, 37000, 37116], [37118, 37118, 37194, 37194, 37272], [37274, 37274, 37312, 37312, 37346], [37348, 37348, 37370, 37370, 37416], [37418, 37418, 37445, 37445, 37489], [37491, 37491, 37540, 37540, 37801], [37803, 37803, 37876, 37876, 37930], [37932, 37932, 37964, 37964, 38000], [38002, 38002, 38058, 38058, 38114], [38116, 38116, 38146, 38146, 38239], [38240, 38240, 38280, 38280, 38303], [38305, 38351, 38390, 38390, 39546], [39548, 39548, 39578, 39578, 39680], [39682, 39682, 39734, 39734, 39774], [39776, 39776, 39798, 39798, 39849], [39851, 39851, 39883, 39883, 39905], [39907, 39922, 39944, 39944, 40236], [40238, 40238, 40270, 40270, 40292], [40294, 40294, 40313, 40313, 40345], [40394, 40457, 40499, 40499, 40565], [40567, 40637, 40688, 40688, 41040], [41042, 41076, 41122, 41122, 41634], [41636, 41705, 41751, 41751, 42257], [42259, 42259, 42292, 42292, 42508], [42510, 42510, 42569, 42569, 42614], [42616, 42616, 42659, 42659, 42720], [42722, 42722, 42764, 42764, 42806], [42808, 42868, 42925, 42925, 43124]]}
{"id": "MllyDN", "name": "Water Ripples / Plasma Waves", "author": "Retrotation", "description": "fork of https://www.shadertoy.com/view/Ms3SWs", "tags": ["water", "sinewaves", "energy"], "likes": 6, "viewed": 680, "date": "1504928508", "time_retrieved": "2024-06-20T19:01:19.479635", "image_code": "\nfloat height(in vec2 uv){\n    float speed = 6.0;\n\n    float topright=\t\tsin(iTime*(speed+1.0)\t-sin(length(uv-vec2(1.0,1.0)))*53.0);\n    float topleft=\t\tsin(iTime*(speed+1.0)\t-sin(length(uv-vec2(0.0,1.0)))*37.0);\n    float bottomright=\tsin(iTime*(speed)    \t-sin(length(uv-vec2(1.0,0.0)))*61.0);\n    float bottomleft=\tsin(iTime*(speed+2.0)\t-sin(length(uv-vec2(0.0,0.0)))*47.0);\n\n    float horizontalWaves=sin(iTime*(speed+2.0)-sin(uv.y)*47.0);\n    \n    \n    float temp = horizontalWaves +bottomleft*0.4 +bottomright*0.2 +topleft*0.6 +topright*0.3;\n    \n    float b=smoothstep(-2.5,5.0,temp);\n    return b*3.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv=fragCoord.xy/iResolution.xy;\n    \n    float waveHeight=0.4+height(uv);\n    \n    vec3 color=vec3(waveHeight*0.3,waveHeight*0.5,waveHeight);\n    \n    fragColor = vec4( color, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MllyDN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1, 1, 26, 26, 610], [612, 612, 669, 669, 860]]}
{"id": "MlscWn", "name": "kerning a hash for Euler+Euclid", "author": "ollj", "description": "Mouse sets coefficients;... swiveled sideways  ...\nMouse.x sets cubic        == cubic change over x\nMouse.y sets null           == baseline height.y at x=0;\nMouse.z sets linear        == linear change\nMouse.w sets quadratic == a*a change\n\n+hash() for fun.", "tags": ["mod", "optimization", "hash", "overlap", "polynomial", "euler", "euclid", "calculus", "bisymmetry", "polynom", "halfspace", "tapping", "kerning"], "likes": 4, "viewed": 1131, "date": "1504436531", "time_retrieved": "2024-06-20T19:01:22.649686", "image_code": "/* start.Head:hash_for_Euler+Euclid\n\noptimization,mod,fract,integral,hash,polynom,analysis,euler,euclid,calculus,\nbisymmetry,polynomial,set\n\nself         : https://www.shadertoy.com/view/MlscWn\nrandom father: https://www.shadertoy.com/view/4llcWn\nmother       : https://www.shadertoy.com/view/Xtscz7\n replaced a hash with a Polynomial_3rd_deg, then mixed the hash back in.\n\nInclides lots of commented code and links on (a)symmetry & optimization:\nLibrary: Lib.Frames.8\nGuide  : Bisymmetry.4\nGuide  : Bisymmetry.4+1 (optimization pointers)\n*/\n\n/* end__.Head\n   start.Manual\n/*\nMouse sets coefficients; ...swiveled sideways  ...\nMouse.x sets cubic     == cubic change over x\nMouse.y sets null      == baseline height.y at x=0;\nMouse.z sets linear    == linear change\nMouse.w sets quadratic == a*a change\n\nFor hased bands of [bounding volumes] to be filled with dots or moons.\n\nThis turns any y=f(x) curve (including HASH,noise) into a dotted line.\n of any (homogeneous) period.x,interval.x \n WITHOUT A LOOP, by using fract()\np4() returns y=f(x) where f(x) is a (general) cubic polynomial.\n\nThis generalization blurs some lines between analysis, hashes and RNG.LCG.PCG\n ==Random/Linear/Permuted Number/Congruential/Congruential Generator\nThis makes me wonder what loops can be converted into single passes with fract()\n And what the constrains to types of loops are that can be turned to fract().\n And when it is worth it, and when not. (I bet it is worth it for binary trees).\n\nThe gradient is good within the mod() interval, \nJust make sure that the visible parts (dots) are within boundingVolume==interval==[i]\nLeonard Euler: \"The best inverval is [i]==0;\n...\n*/\n/* end__.Manual\n   start.Manual.Parameters\n*/\n//  set period,interval==[i]~0, not just VERY small, but actually divide by 0.\n//   Just to screw with (or implement basiccalculus) analysis on a fundamental level!\n//   TestDivideByZeroCase==0 will calculate; .0*vec2(fract(a/.0),floor(a/.0));\n//  Effects of settings depend on implementation:\n//              Leonard Euler : ==0  \"This is fine, I invented this\"\n//fract(Congruental Generator): ==0  \"No it is not fine! Null-State equals death!\"\n//          Low IEEE precision: ==1  \"Where is my hash! Screw you, all of you!\"\n//     Heuristic large epsilon: ==2  \"Whatever, this is as close as we can get!\"\n//       Euclidean Unit circle: ==-1 \"Null-State-death only affects me tangentially\"\n#define TestDivideByZeroCase -1\n\n//control speed of time, to make time static or negative.\n#define TimeS (iTime-1.)\n//-1. makes a better thumbnail for the first frame\n//-1. also offsets from [the initial VOID-state]:\n// Because Shadertoy has the PATHETIC error that iTime and iGlobalTime are not initialized.\n// iTime and iGlobalTime are initially ==NullPointer != 0. \n// This confuses many webgl implementations, eg: when using i=cos(acos(-1.)+iTime);\n// cos(acos(-1.)+0.)==-1. is fine.\n// (NullPointer +0.)!= 0. confuses many implementations. -> black screen on iTime==0.\n\n//  ColorgGradient==x>0, shows different gradients, index[1..4], points to a 2*2 matrix:\n//   2 gradients are euclidean sqrt(a), 2 of them 1/dot(a,a)\n//   2 gradients them are fract(a), 2 of them are not.\n//  ColorgGradient==0  is, by your powers combined, Captain Planet, all of the above.\n//  ColorgGradient==-1 is, a (disappearing) ring-variant of ColorgGradient==0\n//  ColorgGradient==-1 shows a spherical [Bounding Volume] in white/yellow\n#define ColorGradient 0\n\n//  HasMix linear interpolates between a hasn and a PolynomialWithExponent3\n#define MixHashPoly3 u5(cos(TimeS*0.61))\n//#define MixHashPoly3 .0\n\n//sub-pixel blur\n#define fsaa 14./min(iResolution.x,iResolution.y)\n\n//swivel view, make .y horizontal, more horizontal ScreenSpace for higher exponents.\n#define ViewSvivel\n//View.Zoom\n#define ViewZoom 5.\n//View.Frame\n#define fra(u) (u-.5*iResolution.xy)*ViewZoom/iResolution.y\n\n\n\n/* end__.Manual.Parameters\n   start.Lib.Frame.8\n*/\n//library of often used functions: //ounting, index starts at 0!\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\n#define u5(a) (a*.5+.5)\n#define u2(a) (a*2.-1.)\n//dot(1,a) is a faster sum_of_vector_components in most implements:\nv0 suv(v3 a){return dot(v3(1),a);}v0 suv(v2 a){return dot(v2(1),a);}\nv0 suv(v1 a){return a.x+a.y;}//sum_of_vector_components\nv0 mav(v1 a){return max(a.y,a.x);}//max of vector\nv0 mav(v2 a){return max(a.z,mav(a.xy));}\nv0 mav(v3 a){return max(mav(a.zw),mav(a.xy));}\n#define miv(a) -mav(-a)\n//triangle wave //euclidean grid\n#define tri(a) a=abs(u2(fract(a)))\n#define grid(a) mav(tri(a))\n//clamp().special clamp.general; //clamp().pseudo.inverse\n#define sat(a) clamp(a,0.,1.)\nv0 sat2(v0 a,v1 m){a=.5*(sign(a)+m.x)*a+m.y;a=(sign(2.-a)+1.)*(a-2.)+2.;return a*.5;}\n//stretch, sphere to pill; mirror_centric, most common, atomic;\n#define stretch(u,m) .5*(sign(u)*m-u)*((sign(abs(u)-m))+1.)\n//stretchMinus; positive values do not change; stretchPlus; negatives do not change.\n#define stretchM(u,m) stretch((u*2.+m),m)*.5\n#define stretchP(u,m) stretch((u*2.-m),m)*.5\n#define dd(a) dot(a,a)\n//perpendicular ==90deg rotation\nv1 perp(v1 a){return v1(-a.y,a.x);}\n//return [perpendicular dot product], relevant for distance to line\nv0 dotp(v1 a,v1 b){return dot(perp(a),b);}\n//return distance of [u] from segment, from [a] to [b]\nv0 dSegment(v1 p,v1 a,v1 b){p-=a;b-=a;return length(p-b*sat(dot(p,b)/dd(b)));}\n//---trigonometry, rotations and (distance to) Quadratic functions.\n//(distance to quadratic is a cubic with less than 2 intersections==roots)\n#define cs(a) vec2(cos(a),sin(a))\n//mirror p at half rotated axis == cheap SINGLE 2d rotation.\n#define rs(r) mat2(sin(r+vec4(1,0,0,-1)*asin(1.)))\n//golden ratios are the best factors for hashes; phi.xy-1.=1/phi.xy\nconst v1 phi=v1(sqrt(5.)*.5)+v1(-.5,.5);\n//Not too work-save plotter for quadratic functions.\nv1 evalQuad(v1 t,v1 A,v1 B,v1 C){A=(1.-t)*(A/B+C/A);return A*A;}\n//return all x where y=f(x)=0.; Solve quadratic equation for roots \nv2 SolveQuad(v2 a){v0 e=-a.x/3.;v0 p=a.y+a.x*e,t=p*p*p,\n q=-(2.*a.x*a.x-9.*a.y)*e/9.+a.z,d=q*q+4.*t/27.;if(d>.0){v1 x=(v1(1,-1)*sqrt(d)-q)*.5;\n return v2(suv(sign(x)*pow(abs(x),v1(1./3.)))+e);}v1 m=cs(acos(-sqrt(-27./t)*q*.5)/3.)\n  *v1(1,sqrt(3.));return v2(m.x+m.x,-suv(m),m.y-m.x)*sqrt(-p/3.)+e;}\n//return squared distance to line segment, no normalization needed.\nv0 dLine(v1 a,v1 b,v1 p){a=a-p;b-=p;p=b-a;return dd(a+p*sat(-dot(a,p)/dd(p)));}\n#define ddb(a) (dd(d+(c+b*t.a)*t.a))\n//Get distance of [p] to palnar bezier curve (ellipse) trough Cv[A,B,C]\nv0 dBezier(v1 p,v1 A,v1 B,v1 C){   \n //B=mix(B+v1(1e-4), B, abs(sign(B * 2.0 - A - C)));//colinear CV triviality\n v1 a=B-A,b=A-B*2.+C,c=a*2.,d=A-p;v2 k=v2(3.*dot(a,b),2.*dd(a)+dot(d,b),dot(d,a))/dd(b),\n t=sat(SolveQuad(k));return sqrt(miv(v2(ddb(x),ddb(y),ddb(z))));}\n//---window function & curve fittings.y:  https://www.shadertoy.com/view/Xtscz7\n#define bma(b,a,c) (((b)-(a))*(c)+a)\n// float Cosine(float x, float a, float b){return (b-a)*(1.-cos(x*acos(-1.)))*.5 + a;}\n#define wCosine(x,a,b) (bma(b,a,(1.-cos(x*acos(-1.)))*.5)\n// float Linear(float x, float a, float b){return  a*(x*(b/a-1.)+1.);}//doesnt look too good.\n#define wLinear(x,a,b) a*(x*(b/a-1.)+1.)\n//Smoothstep(0,1,x), without sat(a), unclamped scaled Hermite3;\n#define wSs2(x) (x)*(x)*(3.-2.*(x))\n#define wSs(x,a,b) wSs2((x)-(a)/((b)-(a)))\n//this is not too useful, without sat it sucks, unless you tsselate with simple interval.\n//\n//lower lipschitz == less likely spheretracking overestimation.\n//most general, smoothest most excessive, most zigzag, lowest lipschitz\n#define wHermiteD(x,a,b,e,f) (b+.5*x*(e+b-a+x*(a-b+e+x*3.*(e*3.+f+x*5./3.*(-e*3.-f+x*.4*(e*3.+f))))))\n#define wHermite(x,a,b,c,d) HermiteD(x,a,b,(c-b),(a-d))\n//special case of Hermite(), with a smooth .5 average. medium zigzag\n#define wCatmullRom(x,a,b,c,d) ((((d-a+3.*(b-c))*x+(2.*(a+c+c)-d-5.*b))*x+(c-a))*.5*x+b)\n//efficient and smooth 2nd derivative, least zigzag, highest lipschitz \n#define wCubic(x,a,b,c,d) ((((d-c-a+b)*(x-1.)+a-b)*x+(c-a))*x+b)\n//Cosine() is smoother than Cubic()\n//fast good monochrome distance field visualization.\nv3 rg(v3 c){v3 b=smoothstep(fsaa,-fsaa,c);\n return mix(fract(c*4.),b,.5+(atan(c))/acos(-1.));}\n//return y=f(a,m); m.xyzw coefficients of GeneralPoynomWithExponent3==f();\nv0 p3(v0 a,v3 m){\n //return m.x+a*m.y+a*a*m.z+a*a*a*m.w;//lazy, worst\n //return dot(vec4(1),m*vec4(1.,a*vec3(1,a*vec2(1.,a))));//overly explicit vector processor\n return dot(vec4(1),m*vec4(1.,a,a*a,a*a*a));//explicit vector processor\n return m.x+a*(m.y+a*(m.z+a* m.w));//explixit MAD() (better precision)\n ;}//#define p3(u,f) (f.x+u*f.y+(u*u)*f.z+(u*u*u)*f.w)\n//---hash\n#define hs vec4(1031,.1030,.0973,.1099)\n//h* hashes, fast mediocre, better for mobile gpu, Sans Euclid, without trigonometry.\nv0 h11(v0 p){v2 f=fract(v2(p)*hs.y);f+=dot(f,f.yzx+19.19);\n return fract((f.x+f.y)*f.z);}\nv2 hash33(v2 a){a=fract(a*hs.xyz);a+=dot(a,a.yxz+19.19);\n return fract(a.zyx*(a.xxy+a.yzz));}//https://www.shadertoy.com/view/4djSRW\n\nv3 h44(v3 a){a=fract(a*hs);a+=dot(a,a.wzxy+19.19);\n return fract(a.zywx*(a.xxyz+a.yzzw));\n}//https://www.shadertoy.com/view/4djSRW\n\n/* End__.Lib.Frame.8\n   Start.Special\n*/\n//subroutines that are too special to enter the Library,\n// to not be generalized or specialized (for now).\n\n//a mix (interpolate between) a polynom.y and a hash.y\nfloat ph(float a,vec4 m){return mix(h11(a),p3(a,m),MixHashPoly3);}\n\n/* End__.Special\n   Start.Main\n*/\nvoid mainImage( out vec4 O,in vec2 U){\n vec2 u =fra(U);vec4 m=vec4(fra(iMouse.xy),fra(iMouse.zw));  \n #ifdef ViewSvivel\n  u=u.yx;m=m.yxwz;//swivel view, use horizontal space to show higher exponentials.\n #endif\n    \n float i=u5(cos(acos(-1.)+TimeS));\n //i=interval of dots, goes all the way to 0, maybe not on linux.\n //testing limited precision (of IEEE float)\n #if   TestDivideByZeroCase==0\n  i=.000000;\n #elif TestDivideByZeroCase==1 \n  i=.000001;\n #elif TestDivideByZeroCase==2\n  i=.000020;\n #endif\n vec2 x=i*vec2(fract(u.x/i),floor(u.x/i));//dividing by 0, or very small values, here.\n //and then multiplying by the same (asmall number).\n \n //m=vec4(-1);//static debug overwrite\n m.xyzw=m.ywzx;//swivel coefficients to something that makes more sense \n               // for mouse.xy inputs.\n vec2 a=vec2(ph(x.y  ,m),\n             ph(x.y+i,m));//position.y of \n a=u.y-a;\n float f=min(dd(vec2(x.x  ,a.x)), //halfDot on the left  side of a period.\n             dd(vec2(x.x-i,a.y)));//halfDot on the right side of a period.\n //Above [f] stores a squared distance, \n // to have th option to not squaretroot it below.\n\n vec4 c=vec4(0);\n #if ColorGradient<1\n  //ColorgGradient==0 combines all of the other 4 gradients below.\n  c.y=smoothstep(fsaa,-fsaa,f -5./fsaa);//faster, gradient is NOT Euclidean distance.\n  //gradiend it inverse square, good enough for circles!\n  c.z=fract(f);\n  f=sqrt(f);\n  #if ColorGradient==-1\n   c.x=smoothstep(fsaa,-fsaa,abs(f-i+fsaa*2.)-fsaa);//gradient is Euclidean distance.\n  #else\n   c.x=smoothstep(fsaa,-fsaa,   (f*.5       )-fsaa);//gradient is Euclidean distance.\n  #endif\n  c.w=fract(f);\n  c=mix(c,c.xxxx,u5(sin(iTime*acos(-1.))));//oscillate between showing; c.x; or; c\n #elif ColorGradient==1\n  c.x=smoothstep(fsaa,-fsaa,sqrt(f)-fsaa)      ;//gradient is Euclidean distance.\n #elif ColorGradient==2\n  c.y=smoothstep(fsaa,-fsaa,f  -5./fsaa);//faster, gradient is NOT Euclidean distance.\n  //gradiend it inverse square, good enough for circles!\n #elif ColorGradient==3\n  c.z=fract(f);\n #else \n  c.w=fract(sqrt(f));\n #endif\n\n c.rg=mix(c.rg,c.aa,.5);//mix a as yellow;\n O=vec4(c.xyz,1);}\n/* End__.Main\n   Start.Bisymmetry.4\n*/\n\n/*\nBISYMETRY PRINCIPLEs:\n- Bisymmetry is a m,ethod to define and optimize ANY distance field, with biases.\n- Bisymmety is \"A set that I made up\" for lack of a better more common namespace.\n-  the Bisymmetry set overlaps with; Topology, Galois, Lie; Is mostly root solving.\n- Bisymmetry is \"code golf\". Best substitution,soluion depends on the functions context.\n- Bisymmetry is mostly about finding the differences between multiple Polinomials.\n-  to cancel or factorize out shared sums and fators.\n-  To increase symmetry-awareness. (in multiple contexts)\n-   transform your function into binomials with sign() where ever it is possible...\n- - This is possible where your gradient,topology has (hidden) symmetry.\n- - This is possible where your (polynomial) gradient can be reduced to binomials.\n- - This simplifies root solving a lot, calculating distance of points to isolines.\n-  Utilize  https://en.wikipedia.org/wiki/List_of_planar_symmetry_groups\n-  Utilize borders, defined by linear-algebra-deformed, as (branchless) branches.\n-  Only write atomic special cases and transformations, \n-   to construct general functions from.\n-  Instead of writing a general function, \n-   to be fed with a lot of parameters set to 0 or 1 to turn them into \"special cases\"\n- - This way general functions can be made into special \"shortcut\" functions more easily.\n- - This way special functions can more easily be extended, generalized.\n---\n- If(any loop only accumulates over some iterations of a loop)\n- - Your loop can be subdivided into overlapping fract()ions,\n- - ... like it is done for non-uniform_non-Rational_splines.\n- - ... like it is done for tesselated Voronoi.\n- - ... like it is done for fundamental calculus  https://www.shadertoy.com/view/MlscWn\n- - ... like it is doable for a lot of smin() smooth minimum functions.\n- - ... ... you only accumulate the (min) distance of nearby sums,prducts).\n- - - This transforms any loop into a (single pass) recursion\n- - ... ... of non-recursive subroutines! \n- - - This is Different from unrolling a loop or transforming a loop into a recursion.\n- - - This is closer to calculating a bezier curve with N recursive functions,\n- - - where; N=ControlVectors-2\n---\n--- Example of a \"bisymmetrically optimized function\":\nfloat demo(vec2 u,vec4 m){//u= uv position; m=iMouse.xyzw , parameters.\n u.x=abs(u.x-1.); u.y=-u.y*.5; //symmetry modifiers are likely \"outsourced\"\n float a=sign(m.x-1.)+1.;\n float b=sign(m.y+1.)+u.x;\n float c=sign(m.z+m.x)-m.y;\n float c=-sign(m.z-u.x);\n //parameters tent to mostly end up inside of sign()\n //above are all sign-factors, below is the final binomial,both rarely are shared subroutines.\n return u.x*(a+b)*(c+2.)*d*0.5-u.y\n //the *.5 and -u-y can likely be \"outsourced\"\n}\n- Contextual Bias constrains how you \"best\" transform binomials and branches.\n- Knowing your bias/context         limits  \"arbituarity of your choices\".\n- Knowing possible generalizations, extends \"arbituarity of your choices\".\n- In general, it makes sense to delay sqrt() or length() as much as possible.\n-  while also keeping brnches that are shortcuts \n-  Eg: usually abs(length()) begs to be a shortcut.\n...\n- This whole PRINCIPLE screams FRACTAL and SUPERPRIM !\n- - https://www.shadertoy.com/results?query=superprim\n- this PRINCIPLE more easily delays sqrt() or length() till the end of a function, \"outsource\"able\n\nHOW TO\n- Rearrange your branches so that sqrt() or length() is delayed as much as possible.\n- - This equates to segmenting a shape into sub-spahes with different exponents.\n- -  then sorting them by highest exponent.\n- -  then sorting them by shared binomial coeficcients.\n- -  ... (a more general case is still too vague to write here)\n-  abs(length()) can not be delayed, polynomialited, \n-   therefore it may as well be treated like a [Bounding Box,Volume] shortcut.\n-   If(your shape contains abs(length())) that branch stays as if() branch!\n- All other brahcnes usually end up being equally complex trees of equally complex branches.\n-  In that case, an openCL coders eyes open to reveal how to make long pipelines:\n- Substitute functions with identities to reveal their underlying bisymmetries.\n- - substitute max() to if()then() to mix(step)) to mix(sign()) to sums of sign()\n- - - for details on identities see - https://www.shadertoy.com/view/ldBfzc\n- - because there is often a lot of symmetry performance \"lost\" in if-branches, or max()=-min(-)\n- End up precalculating the specifics of a function, \n- Get a sum that you can easily modify. Than transform the sum into binominals\n-  of precalculated variabls, that make sense in the context.\n- - To get the factor of 2. transform a binimial into a non-binomial;\n- -  (a+b)*(c-b)=2.(a*b+a*c)=2.(a*(b+c));\n- - where ever an if() branch ends up as a branchless; .5*n*( binomial );\n\n...\n- Using only fullRotation*N/24 , makes it more likely that terms cancel each other out.\n- if (symmetry) 2 symmetric subroutine-values tend to cancel factors out, \n- ... down to sign(a)*sign(a)=1.\n- Your function(s) turns into a \"family of bisymmetrical functions\" \n- ... that are more easily generalized or specialized.\n- ... that are more easily made work-save against undefineds like: \n- ... a=atan(0.,0.)*tan(acos(.0))*log2(0.)*pow(0,0)*a/0.\n*/\n\n/* End__.Bisymmetry.4\n   Start.Bisymmetry.4+1 (optimization pointers)\n*/\n\n/*\nPreamble Warning; \n This has losts of pointers to overlapping sets of topics that can be studied for decades.\n But often a quick sloppy inefficient (heuristic analysis), \n  solution without years of study and application for optimization, \n  is just as efficient on the most limited resource, that is Time.\n   You may waste too much time just by reading the text below.\n   That may just be spent better socializing with family.\n   In the end, natural selection is a deadly bitch, sharing is caring,\n    and Analysis is just a compforting model.\n   The text below is mostly about isoline/contour, simplifying analysis by seperation.\n    https://www.shadertoy.com/results?query=isoline\n    https://en.wikipedia.org/wiki/Boundary_(topology)\n    https://en.wikipedia.org/wiki/Syllogism\n   Natural selection cares more about (reproductive) unification and maintenance\n    than about seperation.\n\nThis was first created in a shader called \"hash for Euler+Euclid\"\n because it wants to mix \"dope\" with [analysis] and [trigonometry]\n and because it includes hash functions;\n http://www.urbandictionary.com/define.php?term=Dope\n http://www.urbandictionary.com/define.php?term=So%20dope\n http://www.urbandictionary.com/define.php?term=hella%20dope\n\nAnyways:\nOptimization includes Bias and context, your biggest question ends up being, \n what you are optimizing for;\nFlexibility and Specialization end up likely being mutually exclusive.\n...\nOptimization includes what I poorly label as \"Bisymmetry\", \n which seems to be a messy set of all of the below, that i am still (re)structuring;\nhttps://www.shadertoy.com/results?query=bisymmetry\n...\nOptimization includes mostly being good at categorizing, using set theory.\nThis automatically ends up being more about arbitiary intuition \n than you will ever be able to be aware of. \nIt shows you that you are (more) biased and constrained by your personal experiences \n (than you CAN be aware of):\nhttps://www.youtube.com/watch?v=F7yLL5fJxT4\nIn geneal, do not assume an easily Categorizable universe.\nA model (of a world) Where everything has its frame without overlap, \n or where strong forces lead to hard Boolean boundaries between black and white\n is overly specific and overly exclusive. Boolean algebra is a VERY simplified model.\nIn reality, everything appears to be a fuzzy grey gradient (between black and white), \n a waveform that collapses into a single value just by measuring anything, \n and we arbitiarily define [isoline] boundaries \n for the sake of simpler comprehension \n from what we (believe to) have measured in the past.\nThe problem of our brains awareness is that \n we can not read information from our own memory without modifying the same information.\nOn the bright erside, a gradient just EXACTLY what a (signed) distance function returns.\nOptimization developes a skill of generalizing and specializing a function \n by applying set theory and by being more aware of generalalizing gradients, \n by modifying isolines arbitiaryly.\n Ask yourself WHY any point on that shader a specific color, on one side of a border: \nhttps://www.shadertoy.com/view/ldfBzs\n...\nCreating an isoline in shadertoy, with roughly even thickness, from a deformed gradient \n (where the ratios between 2 domains is strethced) is pretty simple; \n You end up dividing by the (smaller) gradients(s) to normalize it, \n which comes down to dividing by a first derivative. Which comes down to a substraction.\n There are different types of gradients though, euclidean, linear ... \n The functions a/=cross(dFdx(a),dFdy(a)) \n or a/=fWidth(a)=min(abs(dFdx(p)),abs(dFdy(p))) \n are VERY FAST rough approximations for the first derivative \n over the fragments by their position.\n It is good enough to estimate a curvature (2nd derivative), \n or to make a >=2 pixel wide nearly UNIFORMLY blurred isoline, border.\nAs such it is a lot about [Window function]s and [basis function]s \n for [Approximation theory]\n...\nOptimization includes [Galois Theory], \n as a bridge between [set theory] and [field theory].\nGalois basically solves roots of polynomials, (where y=f(x)=0)\n but cares more about the GENERAL corellations between the roots \n than the actual numerical value.xy of the roots. (a complex _plane root.y!=0);\nIn that sense it focuses on the first derivative of the roots, or on \n the local extrema of a function \n == the roots of the first derivative of a function.\nhttps://www.shadertoy.com/view/MdXBzB\nThus it bridges isolines and root solving.\n...\nOptimization often includes [Analysis, Calculus] \n often boiling down to [Fourier Analysis], \n because it is often more efficient and heuristically clsoe enough\n to calculate a good enough approximation, \n generally for an upper bound, than a more analytical [gradient descent].\nThis generally gets you to the [Taylor series] \n and the a long set of identities that transform [convergent infinite series] \n into an [convergent (in)finite sum, product] \n to approximate anything. Especially to approximate irrational values,\n that can not be expressed as finite fractions. \n  https://en.wikipedia.org/wiki/Topology\n  https://en.wikipedia.org/wiki/Window_function\n  https://en.wikipedia.org/wiki/Basis_function\n  https://en.wikipedia.org/wiki/List_of_continuity-related_mathematical_topics\n  https://en.wikipedia.org/wiki/B%C3%A9zier_curve\n  https://en.wikipedia.org/wiki/Parametric_equation\n  https://en.wikipedia.org/wiki/Approximation_theory\n...\nMore Basic optimization includes, being good at [boolean algebra] and inequalities, \n because after you arbitiarily divide a field into smapller segments \n (mostly with a biass to seperate high exponents from lower exponents)\n you will end up comparing 2 values for bounding volumes \n to calculate if a point is on the left or right side of a border (or isoline):\nhttps://i.imgur.com/XtzqimN.gif     \n even 16 BASIC boolean algebra operands are VERY arbitiarily ordered and named, \n showing there is NO BETTER structure.\nhttps://en.wikipedia.org/wiki/Boolean_algebra\nhttps://en.wikipedia.org/wiki/Algebraic_structure\nwith\nhttps://en.wikipedia.org/wiki/Equivalence_relation\nhttps://en.wikipedia.org/wiki/Congruence\nhttps://en.wikipedia.org/wiki/Isometry\nhttps://en.wikipedia.org/wiki/Glide_reflection   \n ==  https://www.shadertoy.com/view/XsfBDH\nhttps://en.wikipedia.org/wiki/Symmetrization\nhttps://en.wikipedia.org/wiki/List_of_planar_symmetry_groups\nhttps://en.wikipedia.org/wiki/Permutation\nhttps://en.wikipedia.org/wiki/Homeomorphism\nhttps://en.wikipedia.org/wiki/Coxeter_notation\nIn general, with [partially ordered set]s, [semigroup]s, \n and often [shared prime factors] of 2 values.\noptimization includes [homology] of algebraeic [topology];\n Similarities in multiple topologies.\n...\nGood optimization quickly includes Bounding Volume (Hierarchy); \n You must not get rid of an if-branch when it is a shortcut\n that is statistically worth being calculated and likely taken.\n Such a shortcut is almost always a \"bounding volume\",\n where you know that a point of ray is just too far from something\n to need to measure that thing in detail,\n and you can skip that thing, especially in fractal geometry, \n where this comes down to determining orbitals of fractals, \n == too slowly or non converging functions.\nhttps://en.wikipedia.org/wiki/Bounding_volume\nhttps://en.wikipedia.org/wiki/Bounding_volume_hierarchy\nA GPU is a parallel vector processor \n who deals almost only with 16x16 matrix transformations,\n and its hardware is optimized for type float32. \n This means, multiple functions can be unified into a single 16x16 matrix,\n and newer GPUs have no problem doing calculating multiple matrixes in a pipeline,\n meaning, it will calculate 4 matrices in the time of calculating 1 matrix,\n because there are 4 workers in a seamless assembly line,\n each doing their on unique modification in a\nhttps://en.wikipedia.org/wiki/Pipeline_(computing)\nThe problem here is that any if-branch is a branch in the pipeline\n and multiple shorter pipelines are usually slower (on newer hardware)\n than longer pipelines. Older hardware benefits less from that\n and benefits more from overly excessive bounding volumes.\n For newer hardware it can make sense to have LESS bounding volumes and less if-branches, \n even when that adds 2 more multiplications and more substractions,\n because it iis better at longer pipelines than at smaller more branching pipelines.\nA GPU makes a bad turing machine.\nAGPU is better for convergent deterministic convergent tasks,\n mostly boiling down to [root solving] and catching (arbitiarily defining) orbitals \n BEFORE you even come close to a\nhttps://en.wikipedia.org/wiki/Halting_problem\n== https://en.wikipedia.org/wiki/Undecidable_problem\n...\nOptimization often includes (or tuches) Symmetry topics;\n https://en.wikipedia.org/wiki/Similarity_(geometry)\n https://en.wikipedia.org/wiki/Lie_group\n https://en.wikipedia.org/wiki/Codomain\n https://en.wikipedia.org/wiki/Extensionality\n https://en.wikipedia.org/wiki/Radial_basis_function\n https://en.wikipedia.org/wiki/Diophantine_equation \n https://en.wikipedia.org/wiki/Lambda_calculus\n*/\n\n/* end__.Bisymmetry.4+1 (optimization pointers)\n   start.Dump.Memos\n*/\n\n//memo on bezier bounding volume: http://i.imgur.com/b4q3r2n.jpg\n//if a bezier is meant to define a surface, and i want to trace the BoundingVolume first\n//but the *.tricky points for the BV possibly make the BV not worth calculating.\n//still worth buffering for a static object?\n\n\n\n\n/*\n[halfspace tapping] link collection (v3) (may only be correlated, not even using the method, but SHOULD use the method)\n//\nsawblade serrated disk inversion  \nhttps://www.shadertoy.com/view/4t3fz7\nparent of the above is below\nhttps://www.shadertoy.com/view/XtSczV\n//\nwhich contains links to\ni tried to make this a sawblade\n, and noticed that i would need an insideout rounded box gradient for this: \nhttps://www.shadertoy.com/view/4t3fz7 \n//\nwe need a label for this [overlapping tile/slice] [typesetting] [CircleOfConfusion] \nstuff first time i see it in polar coordinates: \nprevious instances where linear or square lattice (and often only partially overlappin CoC's) \nhttps://www.shadertoy.com/view/4tjcWR\nhttps://www.shadertoy.com/view/MlscWn \n//\nI suggest [halfspace tapping]\n, where CoC implies bokeh, this generalizes it to \"overlapping of dark areas with lit areas\" \nthat may even not overlap completely (or at not overlap at all) :\ntoon clouds (very similar to / MlscWn ):\nhttps://www.shadertoy.com/view/4t23RR\nhttps://www.shadertoy.com/view/MltyR7 \nhttps://www.shadertoy.com/view/ltVcWt\nconcept of a non-monoispaced tree structure (branching a dualGlpyhString into 2 non monospaced sub-glyphs, branchless tree element)\nhttps://www.shadertoy.com/view/ltVcWt\n//\nolder and simpler [halfspace] shaders, closer to \nhttps://www.shadertoy.com/view/Md2cWK\nmodulo-gears:\nhttps://www.shadertoy.com/view/Msl3Rn\npavement:\nhttps://www.shadertoy.com/view/XsKXz3\npolar grid motion does 3-tap, and wopuld be great for half-space overlap:\nhttps://www.shadertoy.com/view/XtcfRH\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlscWn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[4098, 4166, 4179, 4179, 4200], [4200, 4200, 4213, 4213, 4234], [4235, 4235, 4248, 4248, 4264], [4264, 4291, 4304, 4304, 4325], [4325, 4341, 4354, 4354, 4381], [4382, 4382, 4395, 4395, 4428], [4549, 4637, 4656, 4656, 4722], [5045, 5078, 5092, 5092, 5113], [5114, 5182, 5201, 5201, 5224], [5225, 5280, 5308, 5308, 5358], [5757, 5810, 5843, 5843, 5874], [5875, 5943, 5962, 5962, 6241], [6242, 6310, 6335, 6335, 6389], [6427, 6499, 6531, 6611, 6766], [7989, 8078, 8090, 8090, 8172], [8173, 8248, 8265, 8409, 8556], [8658, 8744, 8757, 8757, 8833], [8834, 8834, 8850, 8850, 8927], [8927, 8968, 8981, 8981, 9059], [9250, 9305, 9330, 9330, 9371], [9373, 9407, 9445, 9445, 11528]]}
{"id": "MlsyD4", "name": "Quiver plot", "author": "rougier", "description": "Quiver plot. Better in fullscreen. Move the mouse.", "tags": ["sdf", "quiver", "arrows", "msg"], "likes": 3, "viewed": 176, "date": "1504903201", "time_retrieved": "2024-06-20T19:01:23.940618", "image_code": "vec4 filled(float distance, float linewidth, float antialias, vec4 fill, vec4 bg)\n{\n    vec4 frag_color;\n    float t = linewidth/2.0 - antialias;\n    float signed_distance = distance;\n    float border_distance = abs(signed_distance) - t;\n    float alpha = border_distance/antialias;\n    alpha = exp(-alpha*alpha);\n\n    // Within linestroke\n    if( border_distance < 0.0 )\n        frag_color = fill;\n    // Within shape\n    else if( signed_distance < 0.0 )\n        frag_color = fill;\n    else\n        // Outside shape\n        if( border_distance > (linewidth/2.0 + antialias) )\n            frag_color = bg;\n        else // Line stroke exterior border\n            frag_color = mix(bg, fill, alpha);\n\n    return frag_color;\n}\n\n// Computes the signed distance from a line\nfloat line_distance(vec2 p, vec2 p1, vec2 p2) {\n    vec2 center = (p1 + p2) * 0.5;\n    float len = length(p2 - p1);\n    vec2 dir = (p2 - p1) / len;\n    vec2 rel_p = p - center;\n    return dot(rel_p, vec2(dir.y, -dir.x));\n}\n\n// Computes the signed distance from a line segment\nfloat segment_distance(vec2 p, vec2 p1, vec2 p2) {\n    vec2 center = (p1 + p2) * 0.5;\n    float len = length(p2 - p1);\n    vec2 dir = (p2 - p1) / len;\n    vec2 rel_p = p - center;\n    float dist1 = abs(dot(rel_p, vec2(dir.y, -dir.x)));\n    float dist2 = abs(dot(rel_p, dir)) - 0.5*len;\n    return max(dist1, dist2);\n}\n\n// Computes the center with given radius passing through p1 & p2\nvec4 circle_from_2_points(vec2 p1, vec2 p2, float radius)\n{\n    float q = length(p2-p1);\n    vec2 m = (p1+p2)/2.0;\n    vec2 d = vec2( sqrt(radius*radius - (q*q/4.0)) * (p1.y-p2.y)/q,\n                   sqrt(radius*radius - (q*q/4.0)) * (p2.x-p1.x)/q);\n    return  vec4(m+d, m-d);\n}\n\nfloat arrow_curved(vec2 texcoord,\n                   float body, float head,\n                   float linewidth, float antialias)\n{\n    float w = linewidth/2.0 + antialias;\n    vec2 start = -vec2(body/2.0, 0.0);\n    vec2 end   = +vec2(body/2.0, 0.0);\n    float height = 0.5;\n\n    vec2 p1 = end - head*vec2(+1.0,+height);\n    vec2 p2 = end - head*vec2(+1.0,-height);\n    vec2 p3 = end;\n\n    // Head : 3 circles\n    vec2 c1  = circle_from_2_points(p1, p3, 1.25*body).zw;\n    float d1 = length(texcoord - c1) - 1.25*body;\n    vec2 c2  = circle_from_2_points(p2, p3, 1.25*body).xy;\n    float d2 = length(texcoord - c2) - 1.25*body;\n    vec2 c3  = circle_from_2_points(p1, p2, max(body-head, 1.0*body)).xy;\n    float d3 = length(texcoord - c3) - max(body-head, 1.0*body);\n\n    // Body : 1 segment\n    float d4 = segment_distance(texcoord, start, end - vec2(linewidth,0.0));\n\n    // Outside (because of circles)\n    if( texcoord.y > +(2.0*head + antialias) )\n         return 1000.0;\n    if( texcoord.y < -(2.0*head + antialias) )\n         return 1000.0;\n    if( texcoord.x < -(body/2.0 + antialias) )\n         return 1000.0;\n    if( texcoord.x > c1.x ) //(body + antialias) )\n         return 1000.0;\n\n    return min( d4, -min(d3,min(d1,d2)));\n}\n\nfloat arrow_triangle(vec2 texcoord,\n                     float body, float head, float height,\n                     float linewidth, float antialias)\n{\n    float w = linewidth/2.0 + antialias;\n    vec2 start = -vec2(body/2.0, 0.0);\n    vec2 end   = +vec2(body/2.0, 0.0);\n\n    // Head : 3 lines\n    float d1 = line_distance(texcoord, end, end - head*vec2(+1.0,-height));\n    float d2 = line_distance(texcoord, end - head*vec2(+1.0,+height), end);\n    float d3 = texcoord.x - end.x + head;\n\n    // Body : 1 segment\n    float d4 = segment_distance(texcoord, start, end - vec2(linewidth,0.0));\n\n    float d = min(max(max(d1, d2), -d3), d4);\n    return d;\n}\n\nfloat arrow_triangle_90(vec2 texcoord,\n                        float body, float head,\n                        float linewidth, float antialias)\n{\n    return arrow_triangle(texcoord, body, head, 1.0, linewidth, antialias);\n}\n\nfloat arrow_triangle_60(vec2 texcoord,\n                        float body, float head,\n                        float linewidth, float antialias)\n{\n    return arrow_triangle(texcoord, body, head, 0.5, linewidth, antialias);\n}\n\nfloat arrow_triangle_30(vec2 texcoord,\n                        float body, float head,\n                        float linewidth, float antialias)\n{\n    return arrow_triangle(texcoord, body, head, 0.25, linewidth, antialias);\n}\n\nfloat arrow_angle(vec2 texcoord,\n                  float body, float head, float height,\n                  float linewidth, float antialias)\n{\n    float d;\n    float w = linewidth/2.0 + antialias;\n    vec2 start = -vec2(body/2.0, 0.0);\n    vec2 end   = +vec2(body/2.0, 0.0);\n\n    // Arrow tip (beyond segment end)\n    if( texcoord.x > body/2.0) {\n        // Head : 2 segments\n        float d1 = line_distance(texcoord, end, end - head*vec2(+1.0,-height));\n        float d2 = line_distance(texcoord, end - head*vec2(+1.0,+height), end);\n        // Body : 1 segment\n        float d3 = end.x - texcoord.x;\n        d = max(max(d1,d2), d3);\n    } else {\n        // Head : 2 segments\n        float d1 = segment_distance(texcoord, end - head*vec2(+1.0,-height), end);\n        float d2 = segment_distance(texcoord, end - head*vec2(+1.0,+height), end);\n        // Body : 1 segment\n        float d3 = segment_distance(texcoord, start, end - vec2(linewidth,0.0));\n        d = min(min(d1,d2), d3);\n    }\n    return d;\n}\n\nfloat arrow_angle_90(vec2 texcoord,\n                     float body, float head,\n                     float linewidth, float antialias)\n{\n    return arrow_angle(texcoord, body, head, 1.0, linewidth, antialias);\n}\n\nfloat arrow_angle_60(vec2 texcoord,\n                        float body, float head,\n                        float linewidth, float antialias)\n{\n    return arrow_angle(texcoord, body, head, 0.5, linewidth, antialias);\n}\n\nfloat arrow_angle_30(vec2 texcoord,\n                        float body, float head,\n                        float linewidth, float antialias)\n{\n    return arrow_angle(texcoord, body, head, 0.25, linewidth, antialias);\n}\n\n\nfloat arrow_stealth(vec2 texcoord,\n                    float body, float head,\n                    float linewidth, float antialias)\n{\n    float w = linewidth/2.0 + antialias;\n    vec2 start = -vec2(body/2.0, 0.0);\n    vec2 end   = +vec2(body/2.0, 0.0);\n    float height = 0.5;\n\n    // Head : 4 lines\n    float d1 = line_distance(texcoord, end-head*vec2(+1.0,-height),\n                                       end);\n    float d2 = line_distance(texcoord, end-head*vec2(+1.0,-height),\n                                       end-vec2(3.0*head/4.0,0.0));\n    float d3 = line_distance(texcoord, end-head*vec2(+1.0,+height), end);\n    float d4 = line_distance(texcoord, end-head*vec2(+1.0,+0.5),\n                                       end-vec2(3.0*head/4.0,0.0));\n\n    // Body : 1 segment\n    float d5 = segment_distance(texcoord, start, end - vec2(linewidth,0.0));\n\n    return min(d5, max( max(-d1, d3), - max(-d2,d4)));\n}\n\n// Position jitter (see comments)\n#define srnd(p)  (2.* fract(sin(p*mat2(12.9898, 78.233,1,-47.14))* 43758.5453) -1. )\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float M_PI = 3.14159265358979323846;\n    const float SQRT_2 = 1.4142135623730951;\n    const float linewidth = 3.0;\n    const float antialias =  1.0;\n\n    const float rows = 48.0;\n    const float cols = 48.0;\n    float body = min(iResolution.x/cols, iResolution.y/rows) / SQRT_2;\n    vec2 texcoord = gl_FragCoord.xy;\n    vec2 size   = iResolution.xy / vec2(cols,rows);\n    vec2 center = (floor(texcoord/size) + vec2(0.5,0.5)) * size;\n\n    // Position jitter (see comments)\n    center += .2*size* srnd(center);\n\n    texcoord -= center;\n\n    // float theta = M_PI/3.0 + 0.1*(center.x / cols + center.y / rows);\n    \n    // vec2 mouse = iMouse.xy;\n    vec2 mouse = iResolution.xy*(.5+.5*vec2(.75*cos(iTime)+.25*sin(0.33*iTime),\n                                             .75*sin(iTime)+.25*cos(1.27*iTime)));\n    \n    float theta = M_PI-atan(center.y-mouse.y,  center.x-mouse.x);\n\n    \n    float cos_theta = cos(theta);\n    float sin_theta = sin(theta);\n    texcoord = vec2(cos_theta*texcoord.x - sin_theta*texcoord.y,\n                    sin_theta*texcoord.x + cos_theta*texcoord.y);\n\n    float l = 1.0-length(center-mouse.xy)/max(iResolution.x, iResolution.y);\n    l = 0.25 +.75*l;\n    \n    \n    // float d = arrow_curved(texcoord, body, 0.25*body, linewidth, antialias);\n    float d = arrow_stealth(texcoord, l*body, 0.25*body, linewidth, antialias);\n    // float d = arrow_triangle_90(texcoord, body, 0.15*body, linewidth, antialias);\n    // float d = arrow_triangle_60(texcoord, body, 0.20*body, linewidth, antialias);\n    // float d = arrow_triangle_30(texcoord, body, 0.25*body, linewidth, antialias);\n    // float d = arrow_angle_90(texcoord, body, 0.15*body, linewidth, antialias);\n    // float d = arrow_angle_60(texcoord, body, 0.20*body, linewidth, antialias);\n    // float d = arrow_angle_30(texcoord, body, 0.25*body, linewidth, antialias);\n\n    fragColor = filled(d, linewidth, antialias,\n                          vec4(0,0,0,1),vec4(1,1,1,1));\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlsyD4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 83, 83, 722], [724, 768, 815, 815, 990], [992, 1044, 1094, 1094, 1361], [1363, 1428, 1487, 1487, 1709], [1711, 1711, 1842, 1842, 2949], [2951, 2951, 3102, 3102, 3603], [3605, 3605, 3751, 3751, 3829], [3831, 3831, 3977, 3977, 4055], [4057, 4057, 4203, 4203, 4282], [4284, 4284, 4426, 4426, 5291], [5293, 5293, 5430, 5430, 5505], [5507, 5507, 5650, 5650, 5725], [5727, 5727, 5870, 5870, 5946], [5949, 5949, 6083, 6083, 6865], [6867, 6987, 7044, 7044, 9014]]}
{"id": "MlXcWS", "name": "Ray Spanning", "author": "paniq", "description": "See header for more info.", "tags": ["ray", "ellipsoid", "minkowski", "frustum", "spanning"], "likes": 3, "viewed": 580, "date": "1506220297", "time_retrieved": "2024-06-20T19:01:29.795632", "image_code": "/*\n\nStochastically visualizing the bounds of an 1D ellipsoid implicit function\nover a frustum volume spanned by four rays. If the volume crosses \nthe x-axis, the ellipsoid is within the frustum, and the intersection \npoints are the near and far plane scalars.\n\nGreen curves visualize the function at the corner of the frustum.\n\nIn this test, the ellipsoid is rotating to nudge it in and out\nof the frustum volume.\n\nI wrote this to see what a convex function would look like that \ncould e.g. be solved with newton's method.\n\nI don't really have an intuition to how to build that function yet.\n\n*/\n\n\n// polynomial arithmetic\n// describes piecewise univariate polynomial with degree 2\nstruct poly2 {\n    // the coefficients for f(x) = a0 * x^0 + a1 * x^1 + a2 * x^2\n    vec3 a;\n    // distance to horizon\n    float h;\n};\n\nconst float infinity = 1. / 0.;\n    \nbool hasaxis(poly2 f) {\n    return (f.h != infinity);\n}\n\npoly2 pa_init(float x) {\n    return poly2(vec3(x,1.0,0.0),infinity);\n}\n    \nfloat merge_axes(poly2 f, poly2 g) {\n    if (hasaxis(g)) {\n        if (hasaxis(f)) {\n            float a0 = min(f.h, g.h);\n            float a1 = max(f.h, g.h);\n            return ((a0 > 0.0)?a0:a1);\n        } else {\n            return g.h;\n\t\t}\n    }\n    return f.h;\n}\n\npoly2 pa_add(poly2 f, poly2 g) {\n    return poly2(f.a + g.a,merge_axes(f,g));\n}\npoly2 pa_add(poly2 f, float c) {\n    return poly2(vec3(f.a[0] + c,f.a[1],f.a[2]),f.h);\n}\npoly2 pa_add(float c, poly2 f) {\n    return poly2(vec3(f.a[0] + c,f.a[1],f.a[2]),f.h);\n}\npoly2 pa_sub(poly2 f, poly2 g) {\n    return poly2(f.a - g.a,merge_axes(f,g));\n}\npoly2 pa_sub(poly2 f, float c) {\n    return poly2(vec3(f.a[0] - c,f.a[1],f.a[2]),f.h);\n}\npoly2 pa_sub(float c, poly2 f) {\n    return poly2(vec3(c - f.a[0],-f.a[1],-f.a[2]),f.h);\n}\npoly2 pa_unm(poly2 f) {\n    return poly2(-f.a,f.h);\n}\n\n// {a0 a1 a2} * {b0 b1 b2}\n// = {a0*b0 (a0*b1 + a1*b0) (a0*b2 + a2*b0 + a1*b1) (a1*b2 + a2*b1) (a2*b2)}\n// the two new coefficients are truncated, so only linear\n// functions are going to work here reliably.\npoly2 pa_mul(poly2 f, poly2 g) {    \n    return poly2(vec3(\n    \tf.a[0] * g.a[0],\n\t    f.a[0] * g.a[1] + f.a[1] * g.a[0],\n        f.a[0] * g.a[2] + f.a[1] * g.a[1] + f.a[2] * g.a[0]\n        //f.a[1] * g.a[2] + f.a[2] * g.a[1],\n        //f.a[2] * g.a[2]\n        ), f.h);\n}\npoly2 pa_mul(poly2 f, float c) {\n    return poly2(f.a * c,f.h);\n}\npoly2 pa_mul(float c, poly2 f) {\n    return poly2(f.a * c,f.h);\n}\n\n// the two new coefficients are truncated, so only linear\n// functions are going to work here reliably.\npoly2 pa_pow2(poly2 f) {\n    return poly2(vec3(\n    \tf.a[0] * f.a[0],\n\t    2.0 * f.a[0] * f.a[1],\n        2.0 * f.a[0] * f.a[2] + f.a[1] * f.a[1]\n        //2.0 * f.a[1] * f.a[2],\n        //f.a[2] * f.a[2]\n        ), f.h);\n}\n\n// returns f(x), f'(x), f''(x)\nvec3 pa_f(vec3 a, float x) {\n    return vec3(\n        a[0] + (a[1] +       a[2] * x) * x,\n                a[1] + 2.0 * a[2] * x,\n                             a[2]);\n}\n\nfloat solve_quadratic(vec3 fa, float x) {\n    float a = fa[2];\n    float b = fa[1];\n    float c = fa[0];\n\n    // the quadratic solve doesn't work for a=0\n    // so we need a branch here.\n    if (a == 0.0) {\n        return -c / b;\n    } else { \n        // (-b +- sqrt(b*b - 4.0*a*c)) / 2.0*a\n        float k = -0.5*b/a;\n        float q = sqrt(k*k - c/a);\n        float q0 = k - q;\n        float q1 = k + q;\n        \n        // pick the root right of x\n\t\treturn (q0 <= x)?q1:q0;\n    }\n}\n\nfloat solve_quadratic0(vec3 fa) {\n    float a = fa[2];\n    float b = fa[1];\n    float c = fa[0];\n\n    // the quadratic solve doesn't work for a=0\n    // so we need a branch here.\n    if (a == 0.0) {\n        return -c / b;\n    } else { \n        // (-b +- sqrt(b*b - 4.0*a*c)) / 2.0*a\n        float k = -0.5*b/a;\n        float q = sqrt(k*k - c/a);\n        // pick the closest root right of 0\n\t\treturn k + ((k <= q)?q:-q);\n    }\n}\n\nvec2 solve_quadratic2(vec3 fa) {\n    float a = fa[2];\n    float b = fa[1];\n    float c = fa[0];\n\n    // the quadratic solve doesn't work for a=0\n    // so we need a branch here.\n    if (a == 0.0) {\n        return vec2(-c / b);\n    } else { \n        // (-b +- sqrt(b*b - 4.0*a*c)) / 2.0*a\n        float k = 0.5*b/a;\n        float q = sqrt(k*k - c/a);\n\t\treturn vec2(-k, q);\n    }\n}\n\nfloat solve_quadratic(poly2 f) {\n    return solve_quadratic0(f.a);\n}\n\n// returns the x position of the next root, where f(x) = 0\nfloat nextroot(poly2 f) {\n    return solve_quadratic(f);\n}\n\n// returns the position of the next event (root or start of new segment)\nfloat nextevent(poly2 f) {\n    float s = nextroot(f);\n    float h = (f.h <= 0.0)?infinity:f.h;\n    s = (s <= 0.0)?h:min(s,h);\n    return s;\n}\n\nfloat axis(poly2 f) {\n    return nextevent(f);\n}\n\nfloat pa_sign(poly2 f) {\n    return ((f.a[0] < 0.0)?-1.0:1.0);\n}\n\n// signed pow2; this is for transforming linear distance functions\n// to quadratic ones so they compare correctly against spherical functions\n// the position of the root is not altered\npoly2 pa_spow2(poly2 f) {\n    return pa_mul(pa_pow2(f), pa_sign(f));\n}\n\npoly2 pa_abs(poly2 f) {\n    float s = pa_sign(f);\n    \n    f.h = axis(f);    \n    \n    return poly2(f.a * s, f.h);\n}\n\npoly2 pa_const(float c) {\n    return poly2(vec3(c,0.0,0.0), infinity);\n}\n\npoly2 pa_ipol(vec2 a, vec2 b) {\n    float a1 = (a.y - b.y)/(a.x - b.x);\n\tfloat a0 = a.y - a1*a.x;\n    return poly2(vec3(a0, a1, 0.0), infinity);\n}\n\npoly2 pa_ipol(vec2 a, vec2 b, float k) {\n    float a2 = 0.5*k;\n    float aa2 = a2*a.x*a.x;\n    float a1 = (a.y - b.y + a2*b.x*b.x - aa2) / (a.x - b.x);\n    float a0 = a.y - a1*a.x - aa2;\n    return poly2(vec3(a0, a1, a2), infinity);\n}\n\npoly2 pa_min(poly2 f, poly2 g) {\n    float h = axis(pa_sub(f,g));\n    float fx = f.a[0];\n    float gx = g.a[0];\n    return poly2((fx < gx)?f.a:g.a, h);\n}\n\npoly2 pa_max(poly2 f, poly2 g) {\n    float h = axis(pa_sub(f,g));\n    float fx = f.a[0];\n    float gx = g.a[0];\n    return poly2((fx > gx)?f.a:g.a, h);\n    \n}\n\n// the output can only be subject to more comparisons, but must not\n// be transformed further.\npoly2 pa_hardmin(poly2 f, poly2 g) {\n#ifdef USE_HARDMIN\n    float fe = nextevent(f);\n    float ge = nextevent(g);    \n    float h = axis(pa_sub(f,g));\n    float fx = f.a[0];\n    float gx = g.a[0];\n    bool fi = (fx < 0.0);\n    bool gi = (gx < 0.0);\n    // both outside\n    if (!fi && !gi) {\n        if (fe <= ge)\n            return f;\n        else\n            return g;\n    // both inside\n    } else if (fi && gi) {\n        if (fe <= ge)\n            return f;\n        else\n            return g;\n    } else {\n        return poly2((fx < gx)?f.a:g.a, h);\n    }    \n#else\n    float h = axis(pa_sub(f,g));\n    float fx = f.a[0];\n    float gx = g.a[0];\n    return poly2((fx < gx)?f.a:g.a, h);\n#endif\n}\n\n// the output can only be subject to more comparisons, but must not\n// be transformed further.\npoly2 pa_hardmax(poly2 f, poly2 g) {\n    return pa_unm(pa_hardmin(pa_unm(f),pa_unm(g)));\n}\n\n// can only be used once on flat surfaces reliably\n// appears to still work with more complex functions?\npoly2 pa_smin(poly2 a, poly2 b, float r) {\n    poly2 e = pa_min(\n        pa_max(\n            pa_add(\n                pa_unm(\n                    pa_abs(\n                        pa_sub(a, b))), r),\n            pa_const(0.0)),pa_const(r));\n    return pa_sub(pa_min(a, b), pa_mul(pa_pow2(e), 0.25 / r));\n}\n\npoly2 pa_smax(poly2 a, poly2 b, float r) {\n    return pa_unm(pa_smin(pa_unm(a),pa_unm(b),r));\n}\n\n// approximates blend with a quadratic patch, but\n// very buggy. avoid.\npoly2 pa_smin2(poly2 a, poly2 b, float r) {\n    float h = solve_quadratic0(pa_sub(a, b).a);\n    float x0 = h - r;\n    float x1 = h + r;\n    if (0.0 < x0) {\n        a.h = x0;\n        return a;\n    } else if (0.0 >= x1) {\n        return b;\n    } else {\n        vec3 ay0 = pa_f(a.a, x0);\n        vec3 by0 = pa_f(b.a, x0);\n        vec3 ay1 = pa_f(a.a, x1);\n        vec3 by1 = pa_f(b.a, x1);\n        vec3 y0 = (ay0.x < by0.x)?ay0:by0;\n        vec3 y1 = (ay1.x < by1.x)?ay1:by1;\n        poly2 m = pa_ipol(vec2(x0, y0.x), vec2(x1, y1.x), (y1.y - y0.y) / (x1 - x0));\n        m.h = x1;\n    \treturn m;\n    }\n}\n\nvec3 ro;\nvec3 rd;\n\npoly2 sphere(poly2 x, poly2 y, poly2 z, float r) {\n    return pa_sub(pa_add(pa_add(pa_pow2(x),pa_pow2(y)),pa_pow2(z)), r*r);\n}\n\npoly2 ellipsoid(poly2 x, poly2 y, poly2 z, vec3 r) {\n    poly2 ex = pa_pow2(pa_mul(x, 1.0/r.x));\n    poly2 ey = pa_pow2(pa_mul(y, 1.0/r.y));\n    poly2 ez = pa_pow2(pa_mul(z, 1.0/r.z));\n    return pa_sub(pa_add(pa_add(ex,ey),ez), 1.0);\n}\n\npoly2 cube(poly2 x, poly2 y, poly2 z, float r) {\n#if 1\n\treturn pa_sub(pa_max(pa_max(pa_abs(x),pa_abs(y)),pa_abs(z)),r);\n#else\n    poly2 d = pa_max(pa_max(pa_abs(x),pa_abs(y)),pa_abs(z));\n    return pa_sub(pa_spow2(d),r * r);\n#endif\n}\n\npoly2 plane(poly2 x, poly2 y, poly2 z, vec4 n) {\n#if 0\n\treturn pa_sub(pa_add(pa_add(pa_mul(x,n.x),pa_mul(y,n.y)),pa_mul(z,n.z)),n.w);\n#else\n    poly2 d = pa_add(pa_add(pa_mul(x,n.x),pa_mul(y,n.y)),pa_mul(z,n.z));\n    return pa_sub(pa_spow2(d),n.w * n.w * sign(n.w));    \n#endif\n}\n\n/*\n// not really a cone - todo :|\npoly2 cone(poly2 x, poly2 y, poly2 z, vec2 a, float l) {\n    return pa_max(\n        pa_add(pa_mul(pa_add(pa_pow2(x),pa_pow2(y)),a.x),\n               pa_mul(a.y, z)),z);\n}\n*/\n\nvoid rotate(poly2 x, poly2 y, out poly2 rx, out poly2 ry, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    rx = pa_sub(pa_mul(x,c),pa_mul(y,s));    \n    ry = pa_add(pa_mul(x,s),pa_mul(y,c));\n}\n\nfloat anim_time;\npoly2 pa_map(poly2 x, poly2 y, poly2 z) {\n#if 0\n\tpoly2 w = plane(x, y, z, vec4(0.0,0.0,1.0,-0.6));\n    poly2 vz = pa_sub(z,sin(anim_time*0.3)*0.4);\n\tpoly2 s = sphere(pa_sub(x,1.0),y,vz, 0.5);\n\tpoly2 s2 = sphere(pa_sub(x,0.65),y,vz, 0.3);\n\t//poly2 c = cone(pa_sub(x,-0.5),y,pa_sub(z,-0.3), normalize(vec2(1.0,0.5)), 0.5);\n    poly2 rx, rz;\n    rotate(pa_sub(x,-0.5),pa_sub(z,-0.5),rx,rz,anim_time*0.5);\n    poly2 c = ellipsoid(rx,y,rz,vec3(0.2,0.5,0.5));\n    poly2 cb = cube(rx,y,pa_add(rz,-0.5),0.2);\n    \n    poly2 d = pa_hardmax(s,pa_unm(s2));\n    d = pa_hardmin(d,w);\n    d = pa_hardmin(d, c);    \n    d = pa_hardmin(d, cb);    \n#else\n    float a = iTime;//.5;\n    rotate(x,y,x,y,a*0.79);//anim_time*0.5);\n    rotate(y,z,y,z,a*0.49);//anim_time*0.5);\n    poly2 d = ellipsoid(x,y,z, vec3(1.0,0.9,0.4));\n    //poly2 d = cube(x,y,z,0.5);\n#endif\n\treturn d;\n}\n\npoly2 pa_map(vec3 ro, vec3 rd, float t) {\n    poly2 dt = pa_init(t);\n    poly2 x = pa_add(ro.x, pa_mul(rd.x, dt));\n    poly2 y = pa_add(ro.y, pa_mul(rd.y, dt));\n    poly2 z = pa_add(ro.z, pa_mul(rd.z, dt));\n    return pa_map(x,y,z);    \n}\n\n// how to convert pa_map to a classic map function\n// t is the ray scalar\n// returns function value at that point, and distance\n// to next root or horizon\nvec3 map(vec3 ro, vec3 rd, float t) {\n    poly2 f = pa_map(ro, rd, t);\n    return vec3(f.a[0], nextevent(f), f.a[1]);\n}\n\nvoid setup() {\n    anim_time = 0.0;\n}\n\nfloat tri(float x) {\n    return 2.0 * abs( floor(x*0.5+0.5) - 0.5*x );\n}\n\nvoid prepare_ray(float s, float t) {\n    //s = 0.0;\n    float q = tri(iTime*0.3);\n    vec2 c = vec2(mix(0.0,3.2,q),0.0);\n    vec2 w = vec2(1.0,1.0)*mix(0.1,1.5,q);\n    s = s*2.0 - 1.0;\n    t = t*2.0 - 1.0;\n    vec3 p1 = vec3(c + w*vec2(s,t), 0.0);\n#if 0\n    vec3 p0 = vec3(p1.xy, -1.0);\n#else\n    vec3 p0 = vec3(0.0, 0.0, -1.0);\n#endif\n    ro = p0;\n    rd = p1 - p0;\n}\n\nconst float coeff_scale = 0.5;\nfloat rayf(float t) {\n    poly2 f = pa_map(ro, rd, t);\n    return f.a[0]*coeff_scale;\n}\n\nfloat coeff_f(float t) {\n    prepare_ray(0.0, t);\n    poly2 f = pa_map(ro, rd, t - mod(t,0.5));\n    return f.a[0]*coeff_scale;\n}\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1);\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1);\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r);\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r);\nvoid set_source(sampler2D image);\n// control how source changes are applied\nconst int Replace = 0; // default: replace the new source with the old one\nconst int Alpha = 1; // alpha-blend the new source on top of the old one\nconst int Multiply = 2; // multiply the new source with the old one\nvoid set_source_blend_mode(int mode);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add an ellipse path at P with radii RW and RH\nvoid ellipse(vec2 p, vec2 r);\nvoid ellipse(float x, float y, float rw, float rh);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n// add a rectangle at O with size S and rounded corner of radius R\nvoid rounded_rectangle(vec2 o, vec2 s, float r);\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// non-uniformly scale the context by S\nvoid scale(vec2 s);\nvoid scale(float sx, float sy);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    vec2 clip;\n    vec2 scale;\n    float line_width;\n    bool premultiply;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n    int source_blend;\n    bool has_clip;\n};\n\n// save current stroke width, starting\n// point and blend mode from active context.\nContext save();\n// restore stroke width, starting point\n// and blend mode to a context previously returned by save()\nvoid restore(Context ctx);\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\nvoid debug_clip_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\n// your draw calls here\n//////////////////////////////////////////////////////////\n\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n#define NUM_STEPS_H 16\n#define NUM_STEPS_V 16\nvoid paint() {\n    setup();\n    set_source_rgb(vec3(1.0));\n    clear();\n    translate(-0.5,0.0);\n\n    // draw 1D graph of estimated distance to horizon\n    set_line_width_px(1.0);\n    set_source_rgba(0.0,0.0,0.0,1.0);\n    \n    vec2 st = 1.0/vec2(NUM_STEPS_V, NUM_STEPS_H);\n    for (int k = 0; k < NUM_STEPS_V; ++k) {\n        for (int i = 0; i < NUM_STEPS_H; ++i) {\n\t        float s = float(k) * st.x;\n            float t = float(i) * st.y;\n\t\t\tvec2 h = hash22(get_origin() + vec2(s,t) + mod(iTime,1.0)) * st;\n            prepare_ray(s + h.x,t + h.y);\n            graph1D(rayf);\n            stroke();        \n        }\n    }\n#if 1\n    set_source_rgb(vec3(0.0,1.0,0.0));\n    prepare_ray(0.0,0.0);\n    graph1D(rayf);\n    prepare_ray(1.0,0.0);\n    graph1D(rayf);\n    prepare_ray(1.0,1.0);\n    graph1D(rayf);\n    prepare_ray(0.0,1.0);\n    graph1D(rayf);\n    stroke();    \n#endif\n\n#if 0\n    set_source_rgb(vec3(1.0,0.0,0.0));\n    graph1D(coeff_f);\n    stroke();\n#endif\n    \n    set_source_rgba(0.0,0.0,0.0,0.3);\n    move_to(0.0,0.0);\n    line_to(1.0,0.0);\n    move_to(0.0,-1.0);\n    line_to(0.0,1.0);\n    move_to(1.0,-1.0);\n    line_to(1.0,1.0);\n    stroke();\n    \n}\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\nfloat AA;\nfloat AAINV;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n#define DEFAULT_CLIP_V -1e+20\n\nContext _stack;\n\nvoid init (vec2 fragCoord) {\n    uv = fragCoord.xy / iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n\n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        vec2(DEFAULT_CLIP_V),\n        vec2(1.0),\n        1.0,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0),\n        Replace,\n        false\n    );\n}\n\nvec3 _color = vec3(1.0);\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n    _stack.clip.y = DEFAULT_CLIP_V;\n}\n\nContext save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;\n    vec2 clip = _stack.clip;\n    bool has_clip = _stack.has_clip;\n    // preserve source\n    vec4 source = _stack.source;\n    _stack = ctx;\n    _stack.shape = shape;\n    _stack.clip = clip;\n    _stack.source = source;\n    _stack.has_clip = has_clip;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = vec2(1.0);\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;\n    _stack.scale = vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    _stack.scale *= vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(vec2 s) {\n    transform(mat3(s.x,0.0,0.0,0.0,s.y,0.0,0.0,0.0,1.0));\n}\n\nvoid scale(float sx, float sy) {\n    scale(vec2(sx, sy));\n}\n\nvoid scale(float s) {\n    scale(vec2(s));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color = mix(_color, _stack.source.rgb, _stack.source.a);\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(_color, 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = _color;\n}\n\nvoid add_clip(vec2 d) {\n    d = d / _stack.scale;\n    _stack.clip = max(_stack.clip, d);\n    _stack.has_clip = true;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);\n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n    _stack.clip = vec2(DEFAULT_CLIP_V);\n    _stack.has_clip = false;\n}\n\nvoid debug_gradient() {\n    vec2 d = _stack.shape;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid debug_clip_gradient() {\n    vec2 d = _stack.clip;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color = _color * (1.0 - src_a) + rgba.rgb * dst_a;\n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat min_uniform_scale() {\n    return min(_stack.scale.x, _stack.scale.y);\n}\n\nfloat uniform_scale_for_aa() {\n    return min(1.0, _stack.scale.x / _stack.scale.y);\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA*uniform_scale_for_aa(), 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);\n\treturn wa * wb;\n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n    if (_stack.has_clip) {\n\t    write_color(_stack.source, calc_aa_blur(_stack.clip.x));        \n    }\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*min_uniform_scale() * AAINV;\n}\n\nfloat get_gradient_eps() {\n    return (1.0 / min_uniform_scale()) * AAINV;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    if (_stack.source_blend == Multiply) {\n        _stack.source *= c;\n    } else if (_stack.source_blend == Alpha) {\n    \tfloat src_a = c.a;\n    \tfloat dst_a = _stack.premultiply?1.0:src_a;\n\t    _stack.source =\n            vec4(_stack.source.rgb * (1.0 - src_a) + c.rgb * dst_a,\n                 max(_stack.source.a, c.a));\n    } else {\n    \t_stack.source = c;\n    }\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) {\n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1) {\n    vec2 pa = _stack.position.xy - p0;\n    vec2 ba = p1 - p0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1) {\n    set_source_linear_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p0, p1);\n}\n\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r) {\n    float h = clamp( length(_stack.position.xy - p) / r, 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r) {\n    set_source_radial_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p, r);\n}\n\nvoid set_source_blend_mode(int mode) {\n    _stack.source_blend = mode;\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid rounded_rectangle(vec2 o, vec2 s, float r) {\n    s = (s * 0.5);\n    r = min(r, min(s.x, s.y));\n    o += s;\n    s -= r;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    vec2 df = max(dmin.xz, dmin.yw) + length2(dmax);\n    add_field(df - r);\n}\n\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), r);\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    rounded_rectangle(o, s, 0.0);\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), 0.0);\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\n// from https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n    if (l == 0.0) {\n        return length(p) - ab.x;\n    }\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 r = vec2( ab.x*co, ab.y*si );\n\t\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nvoid ellipse(vec2 p, vec2 r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(sdEllipse(c.xy, r), sdEllipse(c.zw, r)));\n}\n\nvoid ellipse(float x, float y, float rw, float rh) {\n    ellipse(vec2(x,y), vec2(rw, rh));\n}\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 s = sign(pa.xz*ba.y-pa.yw*ba.x);\n    vec2 d = length2(pa - ba.xyxy*h.xxyy);\n    add_field(d);\n    add_clip(d * s);\n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat test_cross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat bezier_sign(vec2 A, vec2 B, vec2 C, vec2 p) {\n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0,\n        step(test_cross(A, B, p) * test_cross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * test_cross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    vec2 shape = vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw));\n    add_field(abs(shape));\n    add_clip(shape);\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(abs(f_x) / length(df_x));\n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t aspect = vec2(iResolution.x / iResolution.y, 1.0);\n\t ScreenH = min(iResolution.x,iResolution.y);\n\t AA = ScreenH*0.4;\n\t AAINV = 1.0 / AA;\n\n    init(fragCoord);\n\n    paint();\n\n    blit(fragColor);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlXcWS.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[598, 856, 879, 879, 911], [913, 913, 937, 937, 983], [989, 989, 1025, 1025, 1257], [1259, 1259, 1291, 1291, 1338], [1339, 1339, 1371, 1371, 1427], [1428, 1428, 1460, 1460, 1516], [1517, 1517, 1549, 1549, 1596], [1597, 1597, 1629, 1629, 1685], [1686, 1686, 1718, 1718, 1776], [1777, 1777, 1800, 1800, 1830], [1832, 2040, 2072, 2072, 2311], [2312, 2312, 2344, 2344, 2377], [2378, 2378, 2410, 2410, 2443], [2445, 2549, 2573, 2573, 2772], [2774, 2805, 2833, 2833, 2971], [2973, 2973, 3014, 3014, 3457], [3459, 3459, 3492, 3492, 3886], [3888, 3888, 3920, 3920, 4267], [4269, 4269, 4301, 4301, 4337], [4339, 4398, 4423, 4423, 4456], [4458, 4531, 4557, 4557, 4672], [4674, 4674, 4695, 4695, 4722], [4724, 4724, 4748, 4748, 4788], [4790, 4975, 5000, 5000, 5045], [5047, 5047, 5070, 5070, 5163], [5165, 5165, 5190, 5190, 5237], [5239, 5239, 5270, 5270, 5385], [5387, 5387, 5427, 5427, 5621], [5623, 5623, 5655, 5655, 5776], [5778, 5778, 5810, 5810, 5936], [5938, 6033, 6069, 6069, 6728], [6730, 6825, 6861, 6861, 6915], [6917, 7022, 7064, 7064, 7324], [7326, 7326, 7368, 7368, 7421], [7423, 7495, 7538, 7538, 8094], [8115, 8115, 8165, 8165, 8241], [8243, 8243, 8295, 8295, 8479], [8481, 8481, 8529, 8529, 8714], [8716, 8716, 8764, 8764, 8995], [8997, 9206, 9274, 9274, 9408], [9427, 9427, 9468, 9468, 10284], [10286, 10286, 10327, 10327, 10524], [10526, 10681, 10718, 10718, 10800], [10802, 10802, 10816, 10816, 10839], [10841, 10841, 10861, 10861, 10913], [10915, 10915, 10951, 10966, 11283], [11316, 11316, 11337, 11337, 11403], [11405, 11405, 11429, 11429, 11533], [17410, 17430, 17451, 17451, 17570], [17618, 17618, 17632, 17632, 18777], [18954, 19014, 19041, 19041, 19067], [19069, 19129, 19150, 19150, 19257], [19259, 19259, 19296, 19296, 19382], [19384, 19384, 19430, 19430, 19463], [19465, 19603, 19631, 19631, 20091], [20119, 20119, 20138, 20138, 20171], [20173, 20173, 20191, 20191, 20224], [20226, 20226, 20250, 20250, 20354], [20356, 20356, 20372, 20372, 20393], [20395, 20395, 20422, 20444, 20727], [20729, 20729, 20757, 20757, 20991], [20993, 20993, 21017, 21017, 21103], [21105, 21105, 21132, 21132, 21345], [21347, 21347, 21373, 21373, 21601], [21603, 21603, 21625, 21625, 21751], [21753, 21753, 21773, 21773, 21833], [21835, 21835, 21867, 21867, 21894], [21896, 21896, 21917, 21917, 21939], [21941, 21941, 21965, 21965, 22025], [22027, 22027, 22061, 22061, 22085], [22087, 22087, 22101, 22101, 22165], [22167, 22167, 22193, 22193, 22225], [22227, 22227, 22253, 22253, 22274], [22276, 22276, 22299, 22299, 22394], [22396, 22396, 22420, 22420, 22489], [22491, 22491, 22516, 22516, 22563], [22565, 22565, 22582, 22582, 22695], [22697, 22697, 22720, 22720, 22849], [22851, 22851, 22879, 22879, 23007], [23009, 23009, 23033, 23033, 23173], [23175, 23175, 23213, 23213, 23347], [23349, 23349, 23386, 23386, 23421], [23423, 23423, 23450, 23450, 23500], [23502, 23502, 23532, 23532, 23588], [23590, 23590, 23619, 23619, 23800], [23802, 23802, 23824, 23824, 23991], [23993, 23993, 24006, 24006, 24045], [24047, 24047, 24077, 24077, 24106], [24108, 24108, 24141, 24141, 24198], [24200, 24200, 24226, 24226, 24276], [24278, 24278, 24299, 24299, 24364], [24366, 24366, 24390, 24390, 24473], [24475, 24475, 24490, 24490, 24531], [24533, 24533, 24549, 24549, 24587], [24589, 24589, 24607, 24607, 24664], [24666, 24666, 24696, 24696, 25066], [25068, 25068, 25126, 25126, 25164], [25166, 25166, 25195, 25195, 25231], [25233, 25233, 25281, 25281, 25312], [25314, 25314, 25348, 25348, 25407], [25409, 25409, 25486, 25486, 25651], [25653, 25653, 25730, 25730, 25810], [25812, 25812, 25888, 25888, 26004], [26006, 26006, 26082, 26082, 26160], [26162, 26162, 26200, 26200, 26234], [26236, 26236, 26258, 26258, 26304], [26306, 26306, 26333, 26333, 26377], [26379, 26379, 26428, 26428, 26689], [26691, 26691, 26764, 26764, 26818], [26820, 26820, 26852, 26852, 26888], [26890, 26890, 26946, 26946, 27002], [27004, 27004, 27034, 27034, 27127], [27128, 27128, 27168, 27168, 27191], [27193, 27239, 27278, 27278, 28434], [28436, 28436, 28466, 28466, 28568], [28570, 28570, 28622, 28622, 28662], [28664, 28664, 28686, 28686, 28737], [28739, 28739, 28771, 28771, 28793], [28795, 28810, 28832, 28832, 29124], [29126, 29126, 29158, 29158, 29180], [29182, 29182, 29201, 29201, 29233], [29282, 29345, 29387, 29387, 29453], [29455, 29525, 29576, 29576, 29928], [29930, 29964, 30010, 30010, 30522], [30524, 30593, 30639, 30639, 31145], [31147, 31147, 31180, 31180, 31396], [31398, 31398, 31457, 31457, 31502], [31504, 31504, 31547, 31547, 31608], [31610, 31610, 31652, 31652, 31694], [31696, 31756, 31813, 31813, 32012]]}
{"id": "MlXyWM", "name": "Canyon Waves", "author": "KilledByAPixel", "description": "Using my pixel fractal code, greatly simplified to be a 1x1 matrix so it's pretty much a 1D fractal for the colors. The shape is formed with some warping effects to give it a wavy effect.", "tags": ["fractal", "zoom", "recursion"], "likes": 17, "viewed": 238, "date": "1505018717", "time_retrieved": "2024-06-20T19:01:29.801718", "image_code": "//////////////////////////////////////////////////////////////////////////////////\n// Canyon Trip Zoom - Copyright 2017 Frank Force\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//////////////////////////////////////////////////////////////////////////////////\n\nconst float zoomSpeed\t\t\t= -3.0;\t// how fast to zoom (negative to zoom out)\nconst float zoomScale\t\t\t= 1.0;\t// how much to multiply overall zoom (closer to zero zooms in)\nconst int recursionCount\t\t= 8;\t// how deep to recurse\nconst float curvature\t\t\t= 0.3;\t// time warp to add curvature\n\n//////////////////////////////////////////////////////////////////////////////////\n// Precached values and math\n\nconst float e = 2.718281828459;\nconst float pi = 3.14159265359;\nfloat RandFloat(int i) { return (fract(sin(float(i)) * 43758.5453)); }\nint RandInt(int i) { return int(100000.0*RandFloat(i)); }\n\nvec4 HsvToRgb(vec4 c) \n{\n    float s = c.y * c.z;\n    float s_n = c.z - s * .5;\n    return vec4(s_n) + vec4(s) * cos(2.0 * pi * (c.x + vec4(1.0, 0.6666, .3333, 0.0)));\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n// Color and image manipulation\n\nfloat GetRecursionFade(int r, float timePercent)\n{\n    if (r > recursionCount)\n        return timePercent;\n    \n    // fade in and out recusion\n    float rt = max(float(r) - timePercent, 0.0);\n    float rc = float(recursionCount);\n    return rt / rc;\n}\n\nvec4 InitPixelColor() { return vec4(0); }\nvec4 CombinePixelColor(vec4 color, float timePercent, int i, int r)\n{\n    vec4 myColor = vec4\n    (\n    \tmix(-0.1, 0.1, RandFloat(i + r)),\n    \tmix(0.0, 0.8, RandFloat(i + r + 100)),\n        mix(0.0, 0.8, RandFloat(i + r + 200)),\n        0.0\n    );\n\n    // combine with my color\n    float f = GetRecursionFade(r, timePercent);\n    myColor.y = pow(myColor.y, 4.0);\n    myColor.z = pow(myColor.z, 4.0);\n    color += myColor*f;\n    return color;\n}\n\nvec4 FinishPixel(vec4 color, vec2 uv)\n{\n    // color wander\n    color.x += 0.02*iTime;\n    \n    // convert to rgb\n    return HsvToRgb(color);\n}\n\nvec2 InitUV(vec2 uv)\n{\n\t// wave\n\tuv.x += 0.05*sin(10.0*uv.y + 0.17*iTime);\n\tuv.y += 0.05*sin(10.0*uv.x + 0.13*iTime);\n\tuv.x += 0.8*sin(2.0*uv.y + 0.31*iTime);\n\tuv.y += 0.8*sin(2.0*uv.x + 0.27*iTime);\n    \n    // spin\n    float theta = 0.05*iTime;\n    float c = cos(theta);\n    float s = sin(theta);\n    uv *= mat2(-s, c, c, s);\n    \n    return uv * 20.0;\n}\n \n//////////////////////////////////////////////////////////////////////////////////\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// use square aspect ratio\n\tvec2 uv = fragCoord;\n\tuv = fragCoord / iResolution.y;\n\tuv -= vec2(0.5*iResolution.x / iResolution.y, 0.5);\n    uv = InitUV(uv);\n    \n\t// get time \n    float time = iTime + curvature*pow(abs(uv.x), 1.0);\n\tfloat timePercent = time*zoomSpeed;\n\tint iterations = int(floor(timePercent));\n\ttimePercent -= float(iterations);\n\t\n\t// update zoom, apply pow to make rate constant\n\tfloat zoom = pow(e, -timePercent);\n\tzoom *= zoomScale;\n\t\n\t// generate recursive colors\n\tfragColor = InitPixelColor();\n\tfor (int r = 0; r <= recursionCount + 1; ++r)\n        fragColor = CombinePixelColor(fragColor, timePercent, iterations, r);\n    fragColor = FinishPixel(fragColor, uv);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlXyWM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[588, 765, 789, 789, 835], [836, 836, 856, 856, 893], [895, 895, 919, 919, 1064], [1066, 1182, 1232, 1232, 1434], [1436, 1436, 1459, 1459, 1477], [1478, 1478, 1547, 1547, 1922], [1924, 1924, 1963, 1983, 2067], [2069, 2069, 2091, 2100, 2425], [2428, 2513, 2570, 2598, 3258]]}
{"id": "MlXyzB", "name": "polynomial interpolation", "author": "uchapow", "description": "A very basic demo of the Lagrange interpolation formula. 4 points are used here.\n\nFirst contribution on Shadertoy :)", "tags": ["2d", "interpolation", "lagrange"], "likes": 7, "viewed": 165, "date": "1505243654", "time_retrieved": "2024-06-20T19:01:29.801718", "image_code": "#define N 4\n\n\nfloat lagrange(int j, float x, vec2 p[N])\n{\n\tfloat r = 1.0;\n\tfloat xi, xj = p[j].x;\n\t\n\tfor(int i=0; i<N; i++)\n\t{\n\t\tif(i != j)\n\t\t{\n\t\t\txi = p[i].x;\n\t\t\tr *= (x - xi) / (xj - xi);\n\t\t}\n\t}\n\t\n\treturn r;\n}\n\nfloat g(float x, vec2 p[N])\n{\n\tfloat y = 0.0;\n\tfor(int j=0; j<N; j++) y += lagrange(j, x, p) * p[j].y;\n\t\n\treturn y;\n}\n\n\nvec3 drawPoint(vec3 col, vec2 pos, vec2 fragCoord)\n{\n\tfloat c = distance(fragCoord, pos);\n\tcol += vec3(1.0,0.0,0.0)*exp(-10.0*c*c);\n\treturn col;\n}\n\nvec3 drawCurve(vec3 col, float y, vec2 fragCoord, vec2 p[N])\n{\n\tvec3 curveColour = vec3(0.0,1.0,0.0);\n\tif(fragCoord.x < p[0].x || fragCoord.x > p[N-1].x)\n\t\tcurveColour = vec3(0.0,0.5,1.0);\n\tcol += (smoothstep(y - 0.2, y, fragCoord.y)\n          - smoothstep(y, y + 0.2, fragCoord.y)) * curveColour;\n\treturn col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 15.0; // zoom\n    \n    vec2 points[N] = vec2[N](\n        vec2(-8.0, 3.0+2.0*sin(iTime*2.0)),\n        vec2(-1.0, 2.0+6.0*sin(iTime*3.0)),\n        vec2(3.0, -1.0+4.0*sin(iTime*1.0)),\n        vec2(8.0, -1.0+4.0*sin(iTime*1.0))\n    );\n\t\n\tvec3 col = vec3(0.0);\n\tfor(int i=0; i<N; i++)\n        col = drawPoint(col, points[i], uv);\n\tcol = drawCurve(col, g(uv.x, points), uv, points);\n\t\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlXyzB.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[14, 14, 57, 57, 211], [213, 213, 242, 242, 330], [333, 333, 385, 385, 479], [481, 481, 543, 543, 793], [795, 795, 850, 850, 1366]]}
{"id": "MtfcDB", "name": "bad mandelbrot", "author": "mhiming", "description": "wikipedia rip", "tags": ["fractal"], "likes": 0, "viewed": 67, "date": "1506256549", "time_retrieved": "2024-06-20T19:01:29.801718", "image_code": "#define MAX_ITER 1000.\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nconst vec2 offset = vec2(0.3019, 0.4859);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;  // [-1; 1]\n    \n    vec2 c = uv / pow(1. + iTime / 3., 1. + iTime / 3.) + offset;\n    \n    float iter = 0.;\n    \n    vec2 z;\n    \n    while (length(z) < 4. && iter < MAX_ITER) {\n        z = vec2(z.x * z.x - z.y * z.y, 2. * z.x * z.y) + c;\n        iter++;\n    }\n    \n    if (iter < MAX_ITER) {\n        iter += 1. - log(log(length(z)) / log(2.)) / log(2.); // smoothing\n        float hue = sqrt(iter / MAX_ITER);\n   \t\tfragColor = vec4(hsv2rgb(vec3(hue, 1., 1.)), 1.0);\n    }\n    // else black\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtfcDB.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[24, 24, 46, 46, 215], [260, 260, 317, 317, 876]]}
{"id": "MtfcDS", "name": "Op Art Heart", "author": "g4b0r", "description": "Op Art Heart", "tags": ["2d", "opart"], "likes": 3, "viewed": 91, "date": "1506217779", "time_retrieved": "2024-06-20T19:01:29.801718", "image_code": "// Created by Gabor Nagy (gabor.nagy@me.com)\n// September 23, 2017\n//\n// Op Art Heart\n\nfloat sqr(float x) {\n    return x*x;\n}\n\nfloat heart(vec2 p)\n{\n    float n = sqr(p.x) + sqr(5.*(p.y+.25)/3.8 - sqrt(abs(p.x))) - 1.;\n    return 0. - n;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    vec3 r = iResolution;\n    \n    vec2 uv = (2. * fragCoord.xy - r.xy) / r.y;\n    vec2 uv_sin = vec2(uv.x + .33 * sin(uv.y * 5.), uv.y);\n    \n    // Rotate\n    uv_sin *= mat2(cos(t), sin(t), -sin(t), cos(t));\n    \n    // Stripes\n    float color = smoothstep(.5, .5 + 50./r.y, .5 + .5 * sin(uv_sin.x * 30.));\n    \n    // Scale heart\n    uv *= (2. - pow(sin(t * 4.),8.) * .6);  \n    \n    // Invert color inside heart\n    color = mix(color, 1.-color, smoothstep(-0.01, 0.01, heart(uv)));\n\t\n    fragColor = vec4(vec3(color), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtfcDS.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 87, 107, 107, 125], [127, 127, 148, 148, 239], [241, 241, 298, 298, 848]]}
{"id": "MtfcRj", "name": "Hypnosis Circle", "author": "anclin", "description": "Hypnosis Circle", "tags": ["hypnosiscircle"], "likes": 2, "viewed": 76, "date": "1505425856", "time_retrieved": "2024-06-20T19:01:29.801718", "image_code": "const float PI = 3.14159;\n\nfloat sin01(float x){\n\treturn sin(x)*0.5+0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float x = uv.x-0.5;\n    float y = uv.y-0.5;\n    \n    float d = sqrt(x*x+y*y);\n    \n    vec3 color = vec3(0);\n    \n    color = vec3(sin01(d*PI*100.));\n    vec3 color2 = vec3(sin01(d*PI*100. * sin01(iTime*0.1) ));\n    color += color2;\n    \n\tfragColor = vec4(color, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtfcRj.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[27, 27, 48, 48, 74], [76, 76, 133, 133, 448]]}
{"id": "MtfyD4", "name": "Dawn of the Androids", "author": "dr2", "description": "Android morphogenesis with a varifocal mirror (mousing permitted)", "tags": ["raymarch", "robot", "mirror"], "likes": 5, "viewed": 510, "date": "1504802490", "time_retrieved": "2024-06-20T19:01:29.819922", "image_code": "// \"Dawn of the Androids\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec3 qHit, qnHit, sunDir, msOrg;\nfloat tCur, tCyc, dstFar, msRad, msDep, msDir, mDskRad, frmWid, growPhs, rAngH,\n   rAngA, rAngSh;\nint idObj;\nbool isRefl, onRob;\n\nfloat PrRndBoxDf (vec3 p, vec3 b, float r);\nfloat PrSphDf (vec3 p, float s);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrRCylDf (vec3 p, float r, float rt, float h);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec2 Rot2D (vec2 q, float a);\n\nconst float pi = 3.14159;\n\nfloat RobDf (vec3 p, float dMin)\n{\n  vec3 q;\n  vec2 s;\n  float d, ds, szFac;\n  p.xz = vec2 (- p.z, p.x);\n  szFac = 6.;\n  p *= szFac;\n  dMin *= szFac;\n  p.yz = Rot2D (p.yz, rAngSh);\n  q = p;\n  q.y -= 2.;\n  ds = PrRCylDf (q.xzy, 1.6, 1.5, 2.);\n  q = p;  q.y -= 2.3;\n  d = max (PrSphDf (q, 0.85), - q.y);\n  q.y -= -0.08;\n  d = min (d, PrCylDf (q.xzy, 0.75, 0.1));\n  q = p;  q.y -= 1.55;\n  d = min (d, PrRCylDf (q.xzy, 0.9, 0.28, 0.7));\n  q = p;  \n  q.xz = Rot2D (q.xz, rAngH);\n  q.x = abs (q.x) - 0.3;  q.y -= 3.1;\n  q.xy = Rot2D (q.xy, 0.2 * pi);\n  q.y -= 0.25;\n  d = min (d, PrRCylDf (q.xzy, 0.06, 0.04, 0.3));\n  q = p;  q.x = abs (q.x) - 1.05;  q.y -= 2.1;\n  q.yz = Rot2D (q.yz, rAngA);\n  q.y -= -0.5;\n  d = min (d, PrRCylDf (q.xzy, 0.2, 0.15, 0.6));\n  q = p;  q.x = abs (q.x) - 0.4;  q.y -= 0.475;\n  d = min (d, PrRCylDf (q.xzy, 0.25, 0.15, 0.55));\n  d = mix (ds, d, growPhs);\n  if (d < dMin) { dMin = d;  idObj = 2; }\n  q = p;\n  q.xz = Rot2D (q.xz, rAngH);\n  q.x = abs (q.x) - 0.4;  q.yz -= vec2 (2.7, 0.7);\n  d = PrSphDf (q, 0.15);\n  if (d < dMin) { dMin = d;  idObj = 3; }\n  dMin /= szFac;\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  if (! isRefl) {\n    d = dMin;\n    q = p;\n    q.y -= msOrg.y;\n    d = min (d, PrCylDf (q, mDskRad + frmWid, msDep));\n    q.z -= -0.01;\n    d = max (d, - PrCylDf (q, mDskRad, msDep));\n    if (d < dMin) { dMin = d;  idObj = 1; }\n    q = p;\n    q.y -= 0.2 * frmWid;\n    d = PrRndBoxDf (q, vec3 (0.4, 0.2 * frmWid, msDep), 0.01);\n    if (d < dMin) { dMin = d;  idObj = 1; }\n  }\n  if (onRob) {\n    q = p;\n    q.xz = Rot2D (q.xz, (0.5 + floor (atan (q.z, - q.x) * (15. / (2. * pi)))) * (2. * pi / 15.));\n    q.x -= -2.;\n    dMin = RobDf (q, dMin);\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = 0; j < 40; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += 0.025;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\n#define SQRT3 1.7320508\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./SQRT3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (SQRT3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec3 HexGrid (vec2 p)\n{\n  vec2 q;\n  p -= HexToPix (PixToHex (p));\n  q = abs (p);\n  return vec3 (p, (SQRT3/2.) - q.x + 0.5 * min (q.x - SQRT3 * q.y, 0.));\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 vn, col, gCol, qh;\n  float sd, f;\n  vec2 e = vec2 (0.01, 0.);\n  if (rd.y > 0.) {\n    ro.xz += 2. * tCur;\n    sd = max (dot (rd, sunDir), 0.);\n    col = vec3 (0.1, 0.2, 0.4) + 0.2 * (1. - max (rd.y, 0.)) +\n       0.1 * pow (sd, 16.) + 0.2 * pow (sd, 256.);\n    f = Fbm2 (0.02 * (ro.xz + rd.xz * (100. - ro.y) / max (rd.y, 0.01)));\n    col = mix (col, vec3 (1.), clamp (0.2 + 0.8 * f * rd.y, 0., 1.));\n  } else {\n    ro -= (ro.y / rd.y) * rd;\n    qh = HexGrid (8. * ro.xz);\n    f = max (length (qh.xy) - 0.5, 0.);\n    vn = vec3 (0., Rot2D (vec2 (1., 0.), 5. * f * f));\n    vn.zx = vn.z * vec2 (qh.x, - qh.y) / length (qh.xy);\n    vn = VaryNf (50. * ro, vn, 0.5);\n    gCol = vec3 (0.8, 0.9, 0.8);\n    col = gCol * (0.5 + 0.5 * smoothstep (0.03, 0.06, qh.z)) *\n       (1. - 0.1 * Noisefv2 (100. * ro.xz));\n    col = col * (0.2 + 0.8 * max (dot (vn, sunDir), 0.)) +\n       0.2 * pow (max (dot (normalize (sunDir - rd), vn), 0.), 128.);\n    col = mix (mix (col, 0.7 * gCol, pow (1. + rd.y, 4.)), 0.95 * vec3 (0.45, 0.55, 0.7),\n       pow (1. + rd.y, 64.));\n  }\n  return col;\n}\n\nfloat MirHit (vec3 ro, vec3 rd)\n{\n  vec3 v;\n  float h, b, d;\n  v = ro - msOrg;\n  b = dot (rd, v);\n  d = b * b + msRad * msRad - dot (v, v);\n  h = dstFar;\n  if (d > 0.) {\n    d = sqrt (d);\n    h = - b + d * msDir;\n    qHit = ro + h * rd;\n    v = qHit - msOrg;\n    if (qHit.z > 0. || length (v.xy) > mDskRad) h = dstFar;\n    else qnHit = v / msRad;\n  }\n  return h;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 roo, rdo, col, vn, colA[2];\n  float dstObj, dstMir, sh, spec;\n  bool isBg;\n  dstMir = (rd.z > 0.) ? MirHit (ro, rd) : dstFar;\n  roo = ro;\n  rdo = rd;\n  for (int k = 0; k <= 1; k ++) {\n    onRob = (k == 0);\n    ro = roo;\n    rd = rdo;\n    isRefl = false;\n    isBg = false;\n    dstObj = ObjRay (ro, rd);\n    if (dstMir < min (dstObj, dstFar)) {\n      rd = reflect (rd, qnHit);\n      ro = qHit;\n      isRefl = true;\n      dstObj = ObjRay (ro, rd);\n      if (dstObj >= dstFar) isBg = true;\n    } else if (dstObj >= dstFar) isBg = true;\n    if (! isBg) {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      if (idObj == 1) {\n        vn = VaryNf (100. * ro, vn, 1.);\n        col = 0.4 * vec3 (1., 0.8, 0.2) + 0.6 * BgCol (ro, reflect (rd, vn));\n        spec = 0.3;\n      } else if (idObj == 2) {\n        vn = VaryNf (100. * ro, vn, max (5. - 7. * growPhs, 0.1));\n        col = mix (vec3 (0.3, 0.15, 0.15), mix (vec3 (0.2, 1., 0.2), vec3 (0.1, 0.3, 0.8),\n           clamp (5. * growPhs - 3., 0., 1.)), growPhs);\n        spec = 0.1 + 0.3 * growPhs;\n      } else if (idObj == 3) {\n        col = vec3 (1., 1., 0.);\n        spec = 1.;\n      }\n      sh = ObjSShadow (ro, sunDir);\n      col = col * (0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.)) +\n         spec * sh * pow (max (dot (normalize (sunDir - rd), vn), 0.), 128.);\n    } else {\n      col = BgCol (ro, rd);\n      if (rd.y < 0.) {\n        ro -= (ro.y / rd.y) * rd;\n        col *= ObjSShadow (ro, sunDir);\n      }\n    }\n    colA[k] = col;\n  }\n  col = mix (colA[0], colA[1], 1. - SmoothBump (0.1, 0.8, 0.1, tCyc)) *\n     mix (vec3 (0.9, 0.6, 0.6), vec3 (1.), SmoothBump (0.15, 0.9, 0.1, tCyc));\n  return pow (clamp (col, 0., 1.), vec3 (0.8));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr;\n  vec3 ro, rd, vd;\n  vec2 canvas, uv;\n  float az, el, t;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  dstFar = 15.;\n  t = mod (0.08 * tCur, 2.);\n  msDir = 2. * floor (t) - 1.;\n  t = pow (0.5 * (1. + cos (2. * pi * t)), 2.);\n  msRad = exp (8. * t) + 0.4;\n  mDskRad = 0.75;\n  frmWid = 0.05;\n  msDep = 0.25;\n  msOrg = vec3 (0., mDskRad + frmWid,\n     - sqrt (msRad * msRad - mDskRad * mDskRad) * msDir - msDep);\n  el = 0.03 * pi;\n  az = 0.;\n  if (mPtr.z > 0.) {\n    el = clamp (el - 2. * mPtr.y, 0.02 * pi, 0.3 * pi);\n    az = clamp (az - 2. * mPtr.x, -0.3 * pi, 0.3 * pi);\n  } else az += 0.2 * pi * sin (0.011 * 2. * pi * tCur);\n  ro = vec3 (0., mDskRad + frmWid, -7.);\n  rd = normalize (vec3 (uv, 4.));\n  ro.yz = Rot2D (ro.yz, el);\n  rd.yz = Rot2D (rd.yz, el);\n  ro.xz = Rot2D (ro.xz, az);\n  rd.xz = Rot2D (rd.xz, az);\n  tCyc = mod (0.03 * tCur, 1.);\n  growPhs = SmoothBump (0.3, 0.8, 0.15, tCyc);\n  t = mod (0.3 * tCur, 1.);\n  rAngH = 0.2 * pi * sin (2. * pi * t);\n  rAngA = 2. * pi * (0.5 - abs (t - 0.5));\n  rAngSh = 0.1 * (rAngA - 0.5 * pi);\n  t = smoothstep (0.85, 1., growPhs);\n  rAngH *= t;\n  rAngA *= t;\n  rAngSh *= t;\n  sunDir = normalize (vec3 (1., 2. - 3.2 * abs (tCyc - 0.5), -1.));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrRndBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRCylDf (vec3 p, float r, float rt, float h)\n{\n  vec2 dc;\n  float dxy, dz;\n  dxy = length (p.xy) - r;\n  dz = abs (p.z) - h;\n  dc = vec2 (dxy, dz) + rt;\n  return min (min (max (dc.x, dz), max (dc.y, dxy)), length (dc) - rt);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 e = vec3 (0.1, 0., 0.);\n  float s = Fbmn (p, n);\n  vec3 g = vec3 (Fbmn (p + e.xyy, n) - s,\n     Fbmn (p + e.yxy, n) - s, Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtfyD4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 663, 697, 697, 1773], [1775, 1775, 1797, 1797, 2405], [2407, 2407, 2440, 2440, 2616], [2618, 2618, 2639, 2639, 2846], [2848, 2848, 2885, 2885, 3111], [3138, 3138, 3162, 3162, 3392], [3394, 3394, 3418, 3418, 3478], [3480, 3480, 3503, 3503, 3635], [3637, 3637, 3668, 3668, 4746], [4748, 4748, 4781, 4781, 5112], [5114, 5114, 5149, 5149, 6846], [6848, 6848, 6904, 6904, 8282], [8284, 8284, 8328, 8328, 8375], [8377, 8377, 8410, 8410, 8437], [8439, 8439, 8481, 8481, 8532], [8534, 8534, 8587, 8587, 8766], [8768, 8768, 8825, 8825, 8908], [8910, 8910, 8940, 8940, 8998], [9121, 9121, 9145, 9145, 9192], [9194, 9194, 9219, 9219, 9418], [9420, 9420, 9441, 9441, 9580], [9582, 9582, 9611, 9611, 9823], [9825, 9825, 9864, 9864, 10071]]}
{"id": "Mtfyzl", "name": "Normals Compression - Octahedron", "author": "iq", "description": "Compressing normals by octahedral projection. See [url]http://www.vis.uni-stuttgart.de/~engelhts/paper/vmvOctaMaps.pdf[/url]. Compare to Fibonacci: [url]https://www.shadertoy.com/view/4t2XWK[/url]", "tags": ["3d", "normals", "compression"], "likes": 28, "viewed": 1746, "date": "1505944037", "time_retrieved": "2024-06-20T19:01:31.007898", "image_code": "// The MIT License\n// Copyright © 2017 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Compressing normals by octahedral projection. \n//\n// See http://www.vis.uni-stuttgart.de/~engelhts/paper/vmvOctaMaps.pdf\n//\n// Compare to Fibonacci: https://www.shadertoy.com/view/4t2XWK\n\n\n\nuint octahedral_32( in vec3 nor, uint sh )\n{\n    nor /= ( abs( nor.x ) + abs( nor.y ) + abs( nor.z ) );\n    nor.xy = (nor.z >= 0.0) ? nor.xy : (1.0-abs(nor.yx))*sign(nor.xy);\n    vec2 v = 0.5 + 0.5*nor.xy;\n\n    uint mu = (1u<<sh)-1u;\n    uvec2 d = uvec2(floor(v*float(mu)+0.5));\n    return (d.y<<sh)|d.x;\n}\n\n\n\nvec3 i_octahedral_32( uint data, uint sh )\n{\n    uint mu =(1u<<sh)-1u;\n    \n    uvec2 d = uvec2( data, data>>sh ) & mu;\n    vec2 v = vec2(d)/float(mu);\n    \n    v = -1.0 + 2.0*v;\n#if 1\n    // Rune Stubbe's version, much faster than original\n    vec3 nor = vec3(v, 1.0 - abs(v.x) - abs(v.y));\n    float t = max(-nor.z,0.0);\n    nor.x += (nor.x>0.0)?-t:t;\n    nor.y += (nor.y>0.0)?-t:t;\n#endif\n#if 0\n    // is there was a copysign() in GLSL...\n    vec3 nor = vec3(v, 1.0 - abs(v.x) - abs(v.y));\n    nor.xy -= copysign(max(-nor.z,0.0),nor.xy);\n#endif\n#if 0\n    // original\n    vec3 nor;\n    nor.z = 1.0 - abs(v.x) - abs(v.y);\n    nor.xy = (nor.z>=0.0) ? v.xy : (1.0-abs(v.yx))*sign(v.xy);\n#endif    \n    return normalize( nor );\n}\n\n\n\n//=================================================================================================\n// digit drawing function by P_Malin (https://www.shadertoy.com/view/4sf3RN)\n//=================================================================================================\nfloat SampleDigit(const in float n, const in vec2 vUV)\n{\t\t\n\tif(vUV.x  < 0.0) return 0.0;\n\tif(vUV.y  < 0.0) return 0.0;\n\tif(vUV.x >= 1.0) return 0.0;\n\tif(vUV.y >= 1.0) return 0.0;\n\t\n\tfloat data = 0.0;\n\t\n\t     if(n < 0.5) data = 7.0 + 5.0*16.0 + 5.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\telse if(n < 1.5) data = 2.0 + 2.0*16.0 + 2.0*256.0 + 2.0*4096.0 + 2.0*65536.0;\n\telse if(n < 2.5) data = 7.0 + 1.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 3.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 4.5) data = 4.0 + 7.0*16.0 + 5.0*256.0 + 1.0*4096.0 + 1.0*65536.0;\n\telse if(n < 5.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n\telse if(n < 6.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n\telse if(n < 7.5) data = 4.0 + 4.0*16.0 + 4.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 8.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\telse if(n < 9.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\t\n\tvec2 vPixel = floor(vUV * vec2(4.0, 5.0));\n\tfloat fIndex = vPixel.x + (vPixel.y * 4.0);\n\t\n\treturn mod(floor(data / pow(2.0, fIndex)), 2.0);\n}\n\nfloat PrintInt( in vec2 uv, in float value )\n{\n\tfloat res = 0.0;\n\tfloat maxDigits = 1.0+ceil(.01+log2(value)/log2(10.0));\n\tfloat digitID = floor(uv.x);\n\tif( digitID>0.0 && digitID<maxDigits )\n\t{\n        float digitVa = mod( floor( value/pow(10.0,maxDigits-1.0-digitID) ), 10.0 );\n        res = SampleDigit( digitVa, vec2(fract(uv.x), uv.y) );\n\t}\n\n\treturn res;\t\n}\n\n//=================================================================================================\n// all iq code below\n//=================================================================================================\n\nfloat map( vec3 p )\n{\n    p.xz *= 0.8;\n    p.xyz += 1.000*sin(  2.0*p.yzx );\n    p.xyz -= 0.500*sin(  4.0*p.yzx );\n    float d = length( p.xyz ) - 1.5;\n\treturn d * 0.25;\n}\n\n\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 7.0;\n\n\tfloat precis = 0.001;\n    float h = 1.0;\n    float t = 1.0;\n    for( int i=0; i<256; i++ )\n    {\n        if( (h<precis) || (t>maxd) ) break;\n\t    h = map( ro+rd*t );\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n\treturn t;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    // from Paul Malin (4 samples only in a tetrahedron\t\n    vec2 e = vec2(1.0,-1.0)*0.002;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 rt, in float cr )\n{\n\tvec3 cw = normalize(rt-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy+2.0*fragCoord.xy)/iResolution.y;\n\tvec2 q = fragCoord/iResolution.xy;\n\t\n    //-----------------------------------------------------\n\n\n    float ti = mod( 0.25*iTime, 8.0 );\n    float am = clamp( ti/3.0, 0.0, 1.0 ) - clamp( (ti-4.0)/3.0, 0.0, 1.0 );\n    uint precis = 1u + uint(floor(15.0*am));\n    \n    //-----------------------------------------------------\n\t\n\tfloat an = 4.0 + 0.1*iTime*2.0;\n    \n\tvec3 ro = vec3(4.5*sin(an),2.0,4.5*cos(an));\n    vec3 ta = vec3(0.0,0.0,0.0);\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    vec3 rd = normalize( ca * vec3(p,-1.5) );\n\n    //-----------------------------------------------------\n    \n\tvec3 col = vec3(0.07)*clamp(1.0-length(q-0.5),0.0,1.0);\n\n    float t = intersect(ro,rd);\n    if( t>0.0 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\t\tvec3 ref = reflect( rd, nor );\n        vec3 sor = nor;\n        \n        // compress normal\n        uint id = octahedral_32( nor, precis );\n        \n        // decompress normal\n        nor = i_octahedral_32( id, precis);\n        \n        nor = (p.x>0.0) ? nor : sor;\n\n        // material\n\t\tcol = vec3(0.2);\n        col *= 1.0 + 0.5*nor;\n\n        \n\t\t// lighting\n        float sky = 0.5 + 0.5*nor.y;\n        float fre = clamp( 1.0 + dot(nor,rd), 0.0, 1.0 );\n        float spe = pow(max( dot(-rd,nor),0.0),32.0);\n\t\t// lights\n\t\tvec3 lin  = vec3(0.0);\n\t\t     lin += 3.0*vec3(0.7,0.80,1.00)*sky;\n        \t lin += 8.0*vec3(0.7,0.8,1.00)*smoothstep(0.0,0.2,ref.y)*(0.1+0.9*pow(fre,5.0))*sky;\n             lin += 1.0*fre*vec3(1.0,0.90,0.80);\n        col = col * lin;\n        col += 0.50*spe;\n        col += 0.15*spe*spe*spe;\n\t}\n\n\t\n\tcol = sqrt(col);\n    \n    col += PrintInt( (q-vec2(0.7,0.75))*12.0*vec2(1.0,iResolution.y/iResolution.x), float(2u*precis) );\n\n    col *= smoothstep( 0.003,0.004,abs(q.x-0.5) );\n\n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/Mtfyzl.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1079, 1272, 1316, 1316, 1578], [1582, 1582, 1626, 1626, 2309], [2313, 2590, 2646, 2646, 3736], [3738, 3738, 3784, 3784, 4100], [4102, 4324, 4345, 4345, 4495], [4498, 4498, 4541, 4541, 4795], [4797, 4797, 4829, 4886, 5078], [5080, 5080, 5135, 5135, 5313], [5315, 5315, 5372, 5372, 7249]]}
{"id": "MtlcDn", "name": "Re Platonic solids", "author": "wizgrav", "description": "Clubberized port of https://www.shadertoy.com/view/Md3SDB by revers", "tags": ["platonic", "solids"], "likes": 11, "viewed": 530, "date": "1504431747", "time_retrieved": "2024-06-20T19:01:32.462690", "image_code": "/**\n * Created by Kamil Kolaczynski (revers) - 2016\n *\n * Licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n *\n * This shader uses geometry (except tetrahedron) and camera path from \"Spherical polyhedra\" \n * by nimitz. [ https://www.shadertoy.com/view/4dBXWD ]\n * I must admit that you have used very clever way of modeling platonic solids, mr nimitz :]\n * \n * The rendering is based on \"Transparent Cube Field\" by Shane. \n * [ https://www.shadertoy.com/view/Xds3zN ]\n * Code clear and very well documented (as always), mr Shane :]\n *\n * Thanks for sharing your work, guys!\n *\n * From my side: added glow, tetrahedron and normalized size of the solids to be enclosed inside\n * a fixed size sphere (see \"Circumradius\" parameter).\n * \n * This shader was created and exported from Synthclipse [ http://synthclipse.sourceforge.net/ ].\n */\n\n\n// The following block is needed for Clubber integration\n#ifndef CLUBBER\nvec4 iMusic[4];\nconst float iTransition = 1.0;\n#define CLUBBER_R abs(sin(iTime * 1.33))\n#define CLUBBER_G abs(cos(iTime * 0.66))\n#define CLUBBER_B abs(cos(iTime))\n#define CLUBBER_A min(abs(cos(iTime * 0.33)),abs(sin(iTime * 0.66)))\n#endif\n// Clubber end\n\nconst bool GlowEnabled = true;\nfloat Circumradius;\nconst float WallDistance = 0.01;\nconst float GlowDistance = 0.26974;\n\nconst bool Jitter = false;\nconst float MarchDumping = 0.658;\nconst float Far = 5.0;\nconst int MaxSteps = 156;\n\n#define PI 3.141592\n#define RADIANS(x) ((x) * (PI / 180.0))\n\n// https://en.wikipedia.org/wiki/Platonic_solid\n\n#define TETRAHEDRON_DIHEDRAL_ANGLE RADIANS(70.53)\n#define HEXAHEDRON_DIHEDRAL_ANGLE RADIANS(90.0)\n#define OCTAHEDRON_DIHEDRAL_ANGLE RADIANS(109.47)\n#define DODECAHEDRON_DIHEDRAL_ANGLE RADIANS(116.57)\n#define ICOSAHEDRON_DIHEDRAL_ANGLE RADIANS(138.19)\n\n#define TETRAHEDRON_SCHLAFLI_SYMBOL vec2(3.0, 3.0)\n#define HEXAHEDRON_SCHLAFLI_SYMBOL vec2(4.0, 3.0)\n#define OCTAHEDRON_SCHLAFLI_SYMBOL vec2(3.0, 4.0)\n#define DODECAHEDRON_SCHLAFLI_SYMBOL vec2(5.0, 3.0)\n#define ICOSAHEDRON_SCHLAFLI_SYMBOL vec2(3.0, 5.0)\n\n// Hash by iq\nfloat hash(float h) {\n\treturn fract(sin(h) * 43758.5453123);\n}\n\nvec3 rotx(vec3 p, float a) {\n\tfloat s = sin(a), c = cos(a);\n\treturn vec3(p.x, c * p.y - s * p.z, s * p.y + c * p.z);\n}\nvec3 roty(vec3 p, float a) {\n\tfloat s = sin(a), c = cos(a);\n\treturn vec3(c * p.x + s * p.z, p.y, -s * p.x + c * p.z);\n}\nvec3 rotz(vec3 p, float a) {\n\tfloat s = sin(a), c = cos(a);\n\treturn vec3(c * p.x - s * p.y, s * p.x + c * p.y, p.z);\n}\n\nfloat cot(float x) {\n\treturn 1.0 / tan(x);\n}\n\nfloat getInradius(vec2 pq, float diha) {\n\tfloat tn = tan(diha * 0.5);\n\tfloat a = 2.0 * Circumradius / (tan(PI / pq.y) * tn);\n\tfloat r = 0.5 * a * cot(PI / pq.x) * tn;\n\n\treturn r;\n}\n\nfloat tetrahedron(vec3 p) {\n\tfloat diha = -RADIANS(180.0 - 70.53); // 180 - \"Dihedral angle\"\n\tfloat tria = -RADIANS(60.0); // triangle angle\n\tfloat inra = getInradius(TETRAHEDRON_SCHLAFLI_SYMBOL, TETRAHEDRON_DIHEDRAL_ANGLE);\n\n\tfloat d = p.x - inra;\n\n\tp = rotz(p, diha);\n\td = max(d, p.x - inra);\n\n\tp = rotx(p, tria);\n\tp = rotz(p, diha);\n\n\td = max(d, p.x - inra);\n\n\tp = rotx(p, -tria);\n\tp = rotz(p, diha);\n\td = max(d, p.x - inra);\n\n\treturn d;\n}\n\n// cube\nfloat hexahedron(vec3 p) {\n\tfloat inra = getInradius(HEXAHEDRON_SCHLAFLI_SYMBOL, HEXAHEDRON_DIHEDRAL_ANGLE);\n\n\tfloat d = abs(p.x) - inra;\n\n\tp = rotz(p, 1.5708); // 90 degrees\n\td = max(d, abs(p.x) - inra);\n\n\tp = roty(p, 1.5708); // 90 degrees\n\td = max(d, abs(p.x) - inra);\n\n\treturn d;\n}\n\nfloat octahedron(vec3 p) {\n\tfloat d = -1e5;\n\n\tfloat inra = getInradius(OCTAHEDRON_SCHLAFLI_SYMBOL, OCTAHEDRON_DIHEDRAL_ANGLE);\n\n\tfor (float i = 0.0; i < 4.0; i++) {\n\t\tp = rotz(p, 1.231); // 70.53110 degrees\n\t\tp = rotx(p, 1.047); // 60 degrees\n\n\t\td = max(d, max(p.x - inra, -p.x - inra));\n\t}\n\treturn d;\n}\n\nfloat dodecahedron(vec3 p) {\n\tfloat d = -1e5;\n\n\tfloat inra = getInradius(DODECAHEDRON_SCHLAFLI_SYMBOL, DODECAHEDRON_DIHEDRAL_ANGLE);\n\n\tfor (float i = 0.0; i <= 4.0; i++) {\n\t\tp = roty(p, 0.81); // 46.40958 degrees\n\t\tp = rotx(p, 0.759); // 43.48750 degrees\n\t\tp = rotz(p, 0.3915); // 22.43130 degrees\n\n\t\td = max(d, max(p.x - inra, -p.x - inra));\n\t}\n\n\tp = roty(p, 0.577); // 33.05966 degrees\n\tp = rotx(p, -0.266); // -15.24068 degrees\n\tp = rotz(p, -0.848); // -48.58682 degrees\n\n\td = max(d, max(p.x - inra, -p.x - inra));\n\n\treturn d;\n}\n\nfloat icosahedron(vec3 p) {\n\tfloat d = -1e5;\n\n\t//center band\n\tconst float n1 = 0.7297; // 41.80873 degrees\n\tconst float n2 = 1.0472; // 60 degrees\n\n\tfloat inra = getInradius(ICOSAHEDRON_SCHLAFLI_SYMBOL, ICOSAHEDRON_DIHEDRAL_ANGLE);\n\n\tfor (float i = 0.0; i < 5.0; i++) {\n\n\t\tif (mod(i, 2.0) == 0.0) {\n\t\t\tp = rotz(p, n1);\n\t\t\tp = rotx(p, n2);\n\t\t} else {\n\t\t\tp = rotz(p, n1);\n\t\t\tp = rotx(p, -n2);\n\t\t}\n\t\td = max(d, max(p.x - inra, -p.x - inra));\n\t}\n\n\tp = roty(p, 1.048); // 60.04598 degrees\n\tp = rotz(p, 0.8416); // 48.22013 degrees\n\tp = rotx(p, 0.7772); // 44.53028 degrees\n\n\t//top caps\n\tfor (float i = 0.0; i < 5.0; i++) {\n\t\tp = rotz(p, n1);\n\t\tp = rotx(p, n2);\n\n\t\td = max(d, max(p.x - inra, -p.x - inra));\n\t}\n\treturn d;\n}\n\nfloat mapShape(vec3 p, float x) {\n    x = CLUBBER_G;\n    return mix(octahedron(p), icosahedron(p), smoothstep(0.33, 0.66,x));\n}\n\nfloat shapeProgress(float t) {\n\treturn 0.;\n}\n\nfloat map(vec3 p) {\n\treturn mapShape(p, shapeProgress(iTime));\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n\tfloat tmin = 0.0;\n\tfloat tmax = Far;\n\n\tfloat precis = 0.002;\n\tfloat t = tmin;\n\n\tvec3 accu = vec3(0.0);\n\tfloat steps = 0.0;\n\tfloat glowFactor = 0.0;\n\n\tfor (int i = 0; i < MaxSteps; i++) {\n\t\tsteps = float(i);\n\t\tfloat d = map(ro + rd * t);\n\t\tfloat absd = abs(d);\n\n\t\tif (Jitter) {\n\t\t\tabsd *= 0.8 + hash(absd) * 0.2;\n\t\t}\n\t\tif (t > tmax) {\n\t\t\tbreak;\n\t\t}\n\t\tglowFactor += pow(1.0 - smoothstep(0.0, GlowDistance, d), 14.0)\n\t\t\t\t* step(0.0, d);\n\t\tfloat f = absd * (1.0 - smoothstep(0.0, WallDistance, absd));\n\t\taccu += vec3(f);\n\n\t\tt += max(0.0002, absd * MarchDumping);\n\t}\n\tglowFactor /= steps * (mix(6.66, 0.66, CLUBBER_B)) ;\n\n\tif (GlowEnabled) {\n\t\taccu += 0.7 * pow(glowFactor, 1.2) * vec3(0.0, 1.0, 1.0);\n\t}\n\treturn accu;\n}\n\nmat2 mm2(in float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, -s, s, c);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n     Circumradius = 0.12 + 0.16 * min(1.0, CLUBBER_R);\n\tvec2 p = fragCoord.xy / iResolution.xy;\n\tvec2 uv = 2.0 * p - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tvec3 ro = vec3(0.0, 0.0, -1.0);\n\tvec3 rd = normalize(vec3(uv, 3.5));\n\n\tvec2 um = iMouse.xy / iResolution.xy - 0.5;\n\tum.x *= iResolution.x / iResolution.y;\n\n\tmat2 mx = mm2(iTime * 0.75 + um.x * 6.0);\n\tmat2 my = mm2(iTime * 0.77 + um.y * 6.0);\n\tro.xz *= mx;\n\trd.xz *= mx;\n\tro.xy *= my;\n\trd.xy *= my;\n\n\tvec3 col = render(ro, rd);\n\tcol = pow(col, vec3(0.4545));\n\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtlcDn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[2055, 2069, 2090, 2090, 2131], [2133, 2133, 2161, 2161, 2251], [2252, 2252, 2280, 2280, 2371], [2372, 2372, 2400, 2400, 2490], [2492, 2492, 2512, 2512, 2536], [2538, 2538, 2578, 2578, 2718], [2720, 2720, 2747, 2747, 3162], [3164, 3172, 3198, 3198, 3457], [3459, 3459, 3485, 3485, 3762], [3764, 3764, 3792, 3792, 4295], [4297, 4297, 4324, 4324, 5013], [5015, 5015, 5048, 5048, 5142], [5144, 5144, 5174, 5174, 5188], [5190, 5190, 5209, 5209, 5254], [5256, 5256, 5287, 5287, 6004], [6006, 6006, 6028, 6028, 6088], [6090, 6090, 6145, 6145, 6699]]}
{"id": "MtlcW4", "name": "Gradient Sample", "author": "anclin", "description": "Gradient Sample", "tags": ["gradientsample"], "likes": 1, "viewed": 101, "date": "1504890880", "time_retrieved": "2024-06-20T19:01:32.462690", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float aspect = iResolution.x / iResolution.y;\n    uv.x *= aspect;\n    \n    \n    //float t = .5;\n\tfloat t = sin(iTime)*0.5+0.5;\n    \n    \n    float delay = (uv.x * (1.0-t) + uv.y * t);\n    vec3 color = vec3(delay);\n    \n    if( uv.x > 1.0){\n    \tcolor = vec3(0);\n    }\n    \n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtlcW4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 413]]}
{"id": "MtlcWX", "name": "Cartesian Grid", "author": "Reedbeta", "description": "Function to render a 2D cartesian coordinate grid and some shapes on it, as a base for further diagram shaders.", "tags": ["procedural", "2d", "grid", "diagram"], "likes": 22, "viewed": 1335, "date": "1506747946", "time_retrieved": "2024-06-20T19:01:32.462690", "image_code": "vec2 rotate(vec2 v, float angle)\n{\n    float cosA = cos(angle), sinA = sin(angle);\n    return v.x * vec2(cosA, sinA) + v.y * vec2(-sinA, cosA);\n}\n\nvec2 ortho(vec2 v)\n{\n    return vec2(v.y, -v.x);\n}\n\nvoid stroke(float dist, vec3 color, inout vec3 fragColor, float thickness, float aa)\n{\n    float alpha = smoothstep(0.5 * (thickness + aa), 0.5 * (thickness - aa), abs(dist));\n    fragColor = mix(fragColor, color, alpha);\n}\n\nvoid fill(float dist, vec3 color, inout vec3 fragColor, float aa)\n{\n    float alpha = smoothstep(0.5*aa, -0.5*aa, dist);\n    fragColor = mix(fragColor, color, alpha);\n}\n\nvoid renderGrid(vec2 pos, out vec3 fragColor)\n{\n    vec3 background = vec3(1.0);\n    vec3 axes = vec3(0.4);\n    vec3 lines = vec3(0.7);\n    vec3 sublines = vec3(0.95);\n    float subdiv = 8.0;\n\n    float thickness = 0.003;\n    float aa = length(fwidth(pos));\n\n    fragColor = background;\n\n    vec2 toSubGrid = pos - round(pos*subdiv)/subdiv;\n    stroke(min(abs(toSubGrid.x), abs(toSubGrid.y)), sublines, fragColor, thickness, aa);\n\n    vec2 toGrid = pos - round(pos);\n    stroke(min(abs(toGrid.x), abs(toGrid.y)), lines, fragColor, thickness, aa);\n\n    stroke(min(abs(pos.x), abs(pos.y)), axes, fragColor, thickness, aa);\n}\n\nfloat distLineSeg(vec2 a, vec2 b, vec2 pos)\n{\n    float proj = dot(pos - a, b - a) / dot(b - a, b - a);\n    vec2 posNearest = mix(a, b, clamp(proj, 0.0, 1.0));\n    return length(pos - posNearest);\n}\n\nvoid renderLineSeg(vec2 a, vec2 b, vec3 color, float thickness, vec2 pos, inout vec3 fragColor)\n{\n    stroke(distLineSeg(a, b, pos), color, fragColor, thickness, length(fwidth(pos)));\n}\n\nfloat sdistLine(vec2 a, vec2 b, vec2 pos)\n{\n    return dot(pos - a, normalize(ortho(b - a)));\n}\n\nfloat sdistTri(vec2 a, vec2 b, vec2 c, vec2 pos)\n{\n    return max( sdistLine(a, b, pos),\n            max(sdistLine(b, c, pos),\n                sdistLine(c, a, pos)));\n}\n\nfloat sdistQuadConvex(vec2 a, vec2 b, vec2 c, vec2 d, vec2 pos)\n{\n    return max(  sdistLine(a, b, pos),\n            max( sdistLine(b, c, pos),\n             max(sdistLine(c, d, pos),\n                 sdistLine(d, a, pos))));\n}\n\nvoid renderATriangle(vec2 pos, inout vec3 fragColor)\n{\n    float dist = sdistTri(vec2(0.6, 0.4),\n                          vec2(1.1, 0.9),\n                          vec2(0.75, 0.95), pos);\n    stroke(dist, vec3(0, 0, 1), fragColor, 0.005, length(fwidth(pos)));\n}\n\nvoid renderAxes(vec2 origin, vec2 pos, inout vec3 fragColor)\n{\n    float len = 0.1;\n    float thickness = 0.0075;\n    float aa = length(fwidth(pos));\n\n    float xshaft = sdistQuadConvex(origin + vec2(0.5*thickness),\n                                   origin - vec2(0.5*thickness),\n                                   origin + vec2(len, -0.5*thickness),\n                                   origin + vec2(len, 0.5*thickness), pos);\n    float xhead = sdistTri(origin + vec2(len, -2.0*thickness),\n                           origin + vec2(len + 6.0*thickness, 0),\n                           origin + vec2(len, 2.0*thickness), pos);\n\n    fill(min(xshaft, xhead), vec3(1, 0, 0), fragColor, aa);\n\n    float yshaft = sdistQuadConvex(origin - vec2(0.5*thickness),\n                                   origin + vec2(0.5*thickness),\n                                   origin + vec2(0.5*thickness, len),\n                                   origin + vec2(-0.5*thickness, len), pos);\n    float yhead = sdistTri(origin + vec2(2.0*thickness, len),\n                           origin + vec2(0, len + 6.0*thickness),\n                           origin + vec2(-2.0*thickness, len), pos);\n\n    fill(min(yshaft, yhead), vec3(0, 0.75, 0), fragColor, aa);\n\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float aspect = iResolution.x / iResolution.y;\n\tvec2 pos = (fragCoord / iResolution.y) * 1.3 - vec2((1.3*aspect - 1.0)/2.0, 0.15);\n\n    // animate the grid a bit to test antialiasing\n    pos = vec2(0.5) + rotate(pos - vec2(0.5), cos(iTime) * 0.1 - 0.05) *\n        \t\t\t\t(sin(iTime) * 0.1 + 1.0);\n    pos.y -= 0.1 * sin(iTime);\n\n    fragColor.a = 1.0;\n\trenderGrid(pos, fragColor.rgb);\n\n    renderATriangle(pos, fragColor.rgb);\n\n    renderAxes(vec2(0), pos, fragColor.rgb);\n    renderAxes(vec2(1, 0), pos, fragColor.rgb);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtlcWX.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 34, 34, 145], [147, 147, 167, 167, 197], [199, 199, 285, 285, 422], [424, 424, 491, 491, 592], [594, 594, 641, 641, 1216], [1218, 1218, 1263, 1263, 1416], [1418, 1418, 1515, 1515, 1603], [1605, 1605, 1648, 1648, 1700], [1702, 1702, 1752, 1752, 1870], [1872, 1872, 1937, 1937, 2098], [2100, 2100, 2154, 2154, 2362], [2364, 2364, 2426, 2426, 3591], [3593, 3593, 3648, 3648, 4171]]}
{"id": "MtlyD8", "name": "Substance-D", "author": "edapx", "description": "Flower inspired by the blue flowers in \"A Scanner Darkly\"", "tags": ["blueflowers", "philipkdick", "ascannerdarkly"], "likes": 0, "viewed": 99, "date": "1504682710", "time_retrieved": "2024-06-20T19:01:32.462690", "image_code": "\nvec3 snowFlake(vec2 st, vec2 orig, float resize, float smoothness,\nfloat nPale, float paleInterr, float centerDim, float paleDim){\n    vec2 toCenter = vec2(orig)-st;\n    float angle = atan(toCenter.y,toCenter.x);\n    float radius = length(toCenter)*resize;\n\n    // il numero di petali visualizzato e' il doppio di nPale\n    float f = abs(cos(angle*nPale)*sin(angle*paleInterr))*.8+centerDim;\n    return vec3( 1.-smoothstep(f,f+smoothness,radius) );;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    \n    vec2 st = fragCoord.xy/iResolution.xy;\n    float mainFreq = 29.4;\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    vec3 colorA = vec3(0.149,0.141,0.912);\n    vec3 colorB = vec3(1.000,0.833,0.224);\n    vec3 colorC = vec3(1.000,0.233,0.100);\n    st.x *= iResolution.x/iResolution.y;\n    float sinTime = sin(iTime);\n    float cosTime = cos(iTime);\n\n    float resizeA = abs(sinTime)*mainFreq * 0.2;\n    float resizeB = abs(cosTime)*mainFreq * 2.9;\n    float resizeC = abs(cosTime)*mainFreq * 3.9;\n    vec2 center = vec2(0.5) * vec2(iResolution.x/iResolution.y, 1.);\n\n    colorA *= snowFlake(st, center, resizeA, 0.62, 3., 3., 0.3, 1.8);\n    colorB *= snowFlake(st, center, resizeB, 1.62, 6., 6., 0.6, 2.8);\n    colorC *= snowFlake(st, center, resizeC, 2.62, 9., 9., 0.9, 3.8);\n    vec3 colorDeb = colorB;\n    color += colorA+=colorB+=colorC;\n\n    fragColor = vec4(color,1.0);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtlyD8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1, 1, 131, 131, 452], [454, 454, 511, 511, 1395]]}
{"id": "MtlyDj", "name": "chaos portal (red/blue)", "author": "jes5199", "description": "just a different color scheme for https://www.shadertoy.com/view/lsfcD4", "tags": ["2d", "diamonds", "artifacts"], "likes": 2, "viewed": 152, "date": "1506489309", "time_retrieved": "2024-06-20T19:01:32.589811", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ((130.0 + iTime) / 3.0) * ((fragCoord.xy - (iResolution.xy / 2.0)) / iResolution.y);\n    \n    float value = (uv.x * sign(uv.y) + uv.y * sign(uv.x)) * sin(uv.x) * sin(uv.y);\n    float color = sin(value) * 3.0;\n    color = color * sign(uv.x) * sign(uv.y); // revision 2\n\n    float low = abs(color);\n    float med = abs(color) - 1.0;\n    float high = abs(color) - 2.0;\n    if(color > 0.0) {\n\t  fragColor = vec4(med, high, high,1.0);\n    } else {\n      fragColor = vec4(high, high, med,1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtlyDj.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 564]]}
{"id": "MtlyRf", "name": "Glass Duck 2", "author": "dr2", "description": "\"Glass Duck\" with different internal color algorithm - similar to guil's \"Playing marble\"", "tags": ["fractal", "reflection", "refraction"], "likes": 9, "viewed": 593, "date": "1505837729", "time_retrieved": "2024-06-20T19:01:32.605611", "image_code": "// \"Glass Duck 2\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n\nfloat PrSphDf (vec3 p, float s);\nfloat PrEllipsDf (vec3 p, vec3 r);\nfloat PrEllCylDf (vec3 p, vec2 r, float h);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec2 Rot2Cs (vec2 q, vec2 cs);\n\nvec3 ltDir;\nfloat dstFar, tCur;\nint idObj;\nconst int idBdy = 1, idWng = 2, idHead = 3, idBk = 4, idEye = 5;\nconst float pi = 3.14159;\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 r;\n  const vec2 cs = vec2 (cos (0.3), sin (0.3));\n  float dMin, d, h, s;\n  dMin = dstFar;\n  h = 0.5;\n  r = vec2 (0.2, 0.3 + 0.05 * clamp (p.z, -2., 2.));\n  s = (length (p.xz / r) - 1.) * min (r.x, r.y);\n  d = min (max (s, abs (p.y) - h), length (vec2 (s, p.y)) - h);\n  if (d < dMin) { dMin = d;  idObj = idBdy; }\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.5, 0.3, 0.6);\n  q.yz = Rot2Cs (q.yz, cs);\n  q.xy = Rot2Cs (q.xy, vec2 (cs.x, - cs.y));\n  q.xz = Rot2Cs (q.xz, vec2 (cs.x, - cs.y));\n  r = vec2 (0.3, 0.5 + 0.08 * clamp (q.z, -2., 2.));\n  h = 0.07;\n  s = (length (q.yz / r) - 1.) * min (r.x, r.y);\n  d = SmoothMin (min (max (s, abs (q.x) - h), length (vec2 (s, q.x)) - h), dMin, 0.05);\n  if (d < dMin) { dMin = d;  idObj = idWng; }\n  d = SmoothMin (PrEllipsDf (p - vec3 (0., 0.75, -0.4), vec3 (0.4, 0.35, 0.5)), dMin, 0.1);\n  if (d < dMin) { dMin = d;  idObj = idHead; }\n  q = p - vec3 (0., 0.65, -0.9);\n  q.zy = Rot2Cs (q.zy, vec2 (cs.x, - cs.y));\n  h = 0.15;\n  r = vec2 (0.15, 0.04) * (1. - 0.1 * min (2., max (0., 1. - q.z / h)));\n  d = PrEllCylDf (q, r, h);\n  q.z -= 0.9 * h;\n  d = SmoothMin (max (d, - PrEllCylDf (q, r - 0.02, 2. * h)), dMin, 0.01);\n  if (d < dMin) { dMin = d;  idObj = idBk; }\n  q = p;\n  q.x = abs (q.x);\n  d = PrSphDf (q - vec3 (0.245, 0.825, -0.6), 0.125);\n  if (d < dMin) { dMin = d;  idObj = idEye; }\n  return 0.9 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  const vec3 e = vec3 (0.0001, -0.0001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat MarbVol (vec3 p)\n{\n  vec3 q;\n  float f;\n  f = 0.;\n  q = p;\n  for (int j = 0; j < 7; j ++) {\n    q = 0.7 * (abs (q) / dot (q, q) - 1.);\n    q.yz = vec2 (q.y * q.y - q.z * q.z, 2. * q.y * q.z);\n    q = q.zxy;\n    f += exp (-15. * abs (dot (p, q)));\n  }\n  return f;\n}\n\nvec3 DukMarb (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  float t, dt, c;\n  col = vec3 (0.);\n  dt = 0.08 - 0.01 * cos (0.05 * 2. * pi * tCur);\n  t = 0.;\n  for (int j = 0; j < 64; j ++) {\n    t += dt;\n    c = MarbVol (ro + t * rd);\n    col = 0.95 * col + 0.05 * vec3 (1.7 * c - 0.7 * c * c, c, 0.4 * c * c * c);  \n  }\n  return clamp (col, 0., 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 q, vn, vnp, col;\n  const vec2 cs = vec2 (cos (0.3), sin (0.3));\n  float dstObj, ltDotVn, glit, fr;\n  dstFar = 30.;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += rd * dstObj;\n    vn = ObjNf (ro);\n    q = ro;\n    if (idObj != idEye) {\n      col = DukMarb (ro, refract (rd, vn, 0.75));\n      if (idObj == idBdy) {\n        col *= 1. - smoothstep (0.1, 0.3, ro.y) * smoothstep (0., 0.7, ro.z) * 0.1 *\n           SmoothBump (0.3, 0.5, 0.05, mod (20. * ro.x, 1.));\n      } else if (idObj == idWng) {\n        q.x = abs (q.x);\n        q -= vec3 (0.5, 0.3, 0.6);\n        q.yz = Rot2Cs (q.yz, cs);\n        q.xy = Rot2Cs (q.xy, vec2 (cs.x, - cs.y));\n        q.xz = Rot2Cs (q.xz, vec2 (cs.x, - cs.y));\n        col *= 1. - step (0.02, q.x) * smoothstep (0., 0.2, q.z) * 0.2 *\n           SmoothBump (0.3, 0.5, 0.05, mod (30. * q.y, 1.));\n      } else if (idObj == idBk) {\n        col = mix (vec3 (0.9, 0.6, 0.6) * max (0.7 - 0.3 * dot (rd, vn), 0.), col,\n          smoothstep (-1.1, -0.97, ro.z));\n      }\n    } else {\n       col = mix (vec3 (0.1, 0.1, 0.2), vec3 (0.2, 0.8, 0.5) * max (0.7 - 0.3 * dot (rd, vn), 0.),\n         smoothstep (0.02, 0.04, length (q.yz - vec2 (0.875, -0.65))));\n    }\n    ltDotVn = max (0., dot (vn, ltDir));\n    vnp = VaryNf (1000. * ro, vn, 2.);\n    glit = 500. * step (0.01, ltDotVn) *\n       pow (max (0., dot (ltDir, reflect (rd, vn))), 16.) *\n       pow (1. - 0.6 * abs (dot (normalize (ltDir - rd), vnp)), 8.);\n    col += vec3 (1., 1., 0.5) * (glit +\n       0.3 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 256.));\n    fr = pow (1. - abs (dot (rd, vn)), 5.);\n    col = mix (col, vec3 (0.5) * (0.7 + 0.3 * reflect (rd, vn).y), fr);\n  } else col = vec3 (0.5) * (0.7 + 0.3 * rd.y);\n  col = pow (clamp (col, 0., 1.), vec3 (0.9));\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float az, el;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.15 * pi;\n  if (mPtr.z > 0.) {\n    az += 2.5 * pi * mPtr.x;\n    el += 0.3 * pi * mPtr.y;\n    el = clamp (el, -0.27 * pi, -0.03 * pi);\n  } else {\n    az += 3.5 * pi * sin (0.007 * pi * tCur);\n    el += 0.12 * pi * sin (0.1 * pi * tCur);\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = vuMat * normalize (vec3 (uv, 4.));\n  ro = vuMat * vec3 (0., 0., -5.);\n  ro.y += 0.15;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n  fragColor = vec4 (ShowScene (ro, rd), 1);\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nfloat PrEllCylDf (vec3 p, vec2 r, float h)\n{\n  return max ((length (p.xy / r) - 1.) * min (r.x, r.y), abs (p.z) - h);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec3 e = vec3 (0.1, 0., 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtlyRf.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 541, 563, 563, 1935], [1937, 1937, 1970, 1970, 2147], [2149, 2149, 2170, 2170, 2380], [2382, 2382, 2406, 2406, 2652], [2654, 2654, 2687, 2687, 2992], [2994, 2994, 3029, 3029, 4821], [4823, 4823, 4879, 4879, 5771], [5773, 5773, 5806, 5806, 5833], [5835, 5835, 5870, 5870, 5932], [5934, 5934, 5978, 5978, 6053], [6055, 6055, 6100, 6100, 6203], [6205, 6205, 6262, 6262, 6345], [6347, 6347, 6378, 6378, 6442], [6476, 6476, 6500, 6500, 6630], [6632, 6632, 6657, 6657, 6843], [6845, 6845, 6874, 6874, 7086], [7088, 7088, 7127, 7127, 7311]]}
{"id": "Mtlyzf", "name": "patched 4D Polytopes", "author": "ollj", "description": "mouse.x sets shape\nmouse.y rotates object\n\nfork of:\nhttps://www.shadertoy.com/view/XdfGW4\nwithout global var.\nvery minor fix for better compatibility. might update it more later.", "tags": ["4d", "polychora", "platonic", "hyper", "polytope"], "likes": 15, "viewed": 636, "date": "1505850790", "time_retrieved": "2024-06-20T19:01:34.274996", "image_code": "/*\nfork of:\nhttps://www.shadertoy.com/view/XdfGW4\n Without global var.\n  Very minor fix for better compatibility.\n I might update it more later.\n*/\n\n// Original DE from Knighty's Fragmentarium frag.\n// Adapted by Syntopia\n\n// Click in the six different zones, to display\n// the six regular polytopes in 4D.\n//\n// Move up/down in a zone to rotate in 4D.\n//\n// For more info:\n// http://blog.hvidtfeldts.net/index.php/2012/02/distance-estimated-polychora/\n//\n// Knighty's original thread on FractalForums, where the code was posted:\n// http://www.fractalforums.com/general-discussion-b77/solids-many-many-solids/\n\n/*\nType,U,V,W,T\n3,0,1,0,0 - 5-cell (hypertetrahedron)\n4,0,1,0,0 - 8-cell (hypercube or Tesseract)\n4,0,0,1,0 - 24-cell (hyperoctahedron)\n4,0,0,0,1 - 16-cell  (no 3D equvivalent)\n5,0,1,0,0 - 120-cell (hyperdodecahedron)\n5,0,0,0,1 - 600-cell (hypericosahedron)\n*/\n\n#define MaxSteps 40\n#define MinimumDistance 0.05\n#define normalDistance     0.002\n\n#define PI 3.141592\n#define Scale 3.0\n#define FieldOfView 0.5\n#define Jitter 0.6\n#define FudgeFactor 1.0\n\n#define Ambient 0.32184\n#define Diffuse 0.5\n#define LightDir vec3(1.0)\n#define LightColor vec3(0.6,1.0,0.158824)\n#define LightDir2 vec3(1.0,-1.0,1.0)\n#define LightColor2 vec3(1.0,0.933333,1.0)\n#define Offset vec3(0.92858,0.92858,0.32858)\n\n// Return rotation matrix for rotating around vector v by angle\nmat3  rotationMatrix3(vec3 v, float angle)\n{\n\tfloat c = cos(radians(angle));\n\tfloat s = sin(radians(angle));\n\t\n\treturn mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n\t\t(1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n\t\t(1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n\t\t);\n}\n\nvec2 rotate(vec2 v, float a) {\n\treturn vec2(cos(a)*v.x + sin(a)*v.y, -sin(a)*v.x + cos(a)*v.y);\n}\n\n// Polychora parameters\nint Type = 5;\n\n\nfloat VRadius = 0.05048;\nfloat SRadius = 0.05476;\n\nmat3 rot;\nvec4 nc,nd,p;\nfloat zone = 0.0;\n\nvoid init(inout float U,inout float V,inout float W,inout float T){\n\tvec2 UV = iMouse.xy/iResolution.xy;\n\tfloat aa = 0.0;\n\t\n\t// Different zone presets\n\tif (iMouse.z>0.0) {\n\t\tif (UV.x < 1./6.) {\n\t\t\tType = 3;U = 0.; V = 1.; W = 0.; T = 0.;\n\t\t\tzone = 1.0;\n\t\t} else if (UV.x < 2./6.) {\n\t\t\tType = 4;U = 0.; V = 1.; W = 0.; T = 0.;\n\t\t\tzone = 2.0;\n\t\t} else if (UV.x < 3./6.) {\n\t\t\tType = 4;U = 0.; V = 0.; W = 1.; T = 0.;\n\t\t\tzone = 3.0;\n\t\t} else if (UV.x < 4./6.) {\n\t\t\tType = 4;U = 0.; V = 0.; W = 0.; T = 1.;\n\t\t\tzone = 4.0;\n\t\t} else if (UV.x < 5./6.) {\n\t\t\tType = 5;U = 0.; V = 1.; W = 0.; T = 0.;\n\t\t\tzone = 5.0;\n\t\t} else  {\n\t\t\tType = 5;U = 0.; V = 0.; W = 0.; T = 1.;\n\t\t\tzone = 6.0;\n\t\t}  \n\t\taa = UV.y*90.;\n\t}\n\tfloat cospin=cos(PI/float(Type)), isinpin=1./sin(PI/float(Type));\n\tfloat scospin=sqrt(2./3.-cospin*cospin), issinpin=1./sqrt(3.-4.*cospin*cospin);\n\n\tnc=0.5*vec4(0,-1,sqrt(3.),0.);\n\tnd=vec4(-cospin,-0.5,-0.5/sqrt(3.),scospin);\n\n\tvec4 pabc,pbdc,pcda,pdba;\n\tpabc=vec4(0.,0.,0.,1.);\n\tpbdc=0.5*sqrt(3.)*vec4(scospin,0.,0.,cospin);\n\tpcda=isinpin*vec4(0.,0.5*sqrt(3.)*scospin,0.5*scospin,1./sqrt(3.));\n\tpdba=issinpin*vec4(0.,0.,2.*scospin,1./sqrt(3.));\n\t\n\tp=normalize(U*pabc+V*pbdc+W*pcda+T*pdba);\n\n\tvec3 RotVector = vec3(0.0,1.0,0.1);\n\trot = rotationMatrix3(normalize(RotVector), aa);//in reality we need a 4D rotation\n}\n\nvec4 fold(vec4 pos) {\n\tif (Type == 3) {\n\t\tfor(int i=0;i<3;i++){\n\t\t\tpos.xy=abs(pos.xy);\n\t\t\tfloat t=-2.*min(0.,dot(pos,nc)); pos+=t*nc;\n\t\t\tt=-2.*min(0.,dot(pos,nd)); pos+=t*nd;\n\t\t}\n\t} else if (Type == 4) {\n\t\tfor(int i=0;i<8;i++){\n\t\t\tpos.xy=abs(pos.xy);\n\t\t\tfloat t=-2.*min(0.,dot(pos,nc)); pos+=t*nc;\n\t\t\tt=-2.*min(0.,dot(pos,nd)); pos+=t*nd;\n\t\t}\n\t} else if (Type == 5) {\n\t\tfor(int i=0;i<15;i++){\n\t\t\tpos.xy=abs(pos.xy);\n\t\t\tfloat t=-2.*min(0.,dot(pos,nc)); pos+=t*nc;\n\t\t\tt=-2.*min(0.,dot(pos,nd)); pos+=t*nd;\n\t\t}\n\t}\n\treturn pos;\n}\n\nfloat DD(float ca, float sa, float r){\n\t//magic formula to convert from spherical distance to planar distance.\n\t//involves transforming from 3-plane to 3-sphere, getting the distance\n\t//on the sphere then going back to the 3-plane.\n\treturn r-(2.*r*ca-(1.-r*r)*sa)/((1.-r*r)*ca+2.*r*sa+1.+r*r);\n}\n\nfloat dist2Vertex(vec4 z, float r){\n\tfloat ca=dot(z,p), sa=0.5*length(p-z)*length(p+z);//sqrt(1.-ca*ca);//\n\treturn DD(ca,sa,r)-VRadius;\n}\n\nfloat dist2Segment(vec4 z, vec4 n, float r){\n\t//pmin is the orthogonal projection of z onto the plane defined by p and n\n\t//then pmin is projected onto the unit sphere\n\tfloat zn=dot(z,n),zp=dot(z,p),np=dot(n,p);\n\tfloat alpha=zp-zn*np, beta=zn-zp*np;\n\tvec4 pmin=normalize(alpha*p+min(0.,beta)*n);\n\t//ca and sa are the cosine and sine of the angle between z and pmin. This is the spherical distance.\n\tfloat ca=dot(z,pmin), sa=0.5*length(pmin-z)*length(pmin+z);//sqrt(1.-ca*ca);//\n\treturn DD(ca,sa,r)-SRadius;\n}\n\n//it is possible to compute the distance to a face just as for segments: pmin will be the orthogonal projection\n// of z onto the 3-plane defined by p and two n's (na and nb, na and nc, na and and, nb and nd... and so on).\n//that involves solving a system of 3 linear equations.\n//it's not implemented here because it is better with transparency\n\nfloat dist2Segments(vec4 z, float r){\n\tfloat da=dist2Segment(z, vec4(1.,0.,0.,0.), r);\n\tfloat db=dist2Segment(z, vec4(0.,1.,0.,0.), r);\n\tfloat dc=dist2Segment(z, nc, r);\n\tfloat dd=dist2Segment(z, nd, r);\n\t\n\treturn min(min(da,db),min(dc,dd));\n}\n\nfloat DE(vec3 pos) {\n\t//return length(pos)-1.;\n\tfloat r=length(pos);\n\tvec4 z4=vec4(2.*pos,1.-r*r)*1./(1.+r*r);//Inverse stereographic projection of pos: z4 lies onto the unit 3-sphere centered at 0.\n\tz4.xyw=rot*z4.xyw;\n\tz4=fold(z4);//fold it\n\n\treturn min(dist2Vertex(z4,r),dist2Segments(z4, r));\n}\n\nvec3 lightDir;\nvec3 lightDir2;\n\n// Backgorund\nvec3 bg(vec3 dir) {\n\tif (dir.z>0.0) {\n\t\tfloat sun =clamp(dot(dir, normalize(vec3(0.2,0.2,0.5))),0.0,1.0);\n\t\tvec3 sky = vec3(0.6,0.4,1.0)*(1.0-dir.z*dir.z*0.4);\n\t\tsky += 1.3*pow(sun,30.0)*vec3(1.0,0.8,0.8);\n\t\treturn sky;\n\t} else {\n\t\tvec3 ground =  vec3(0.6,0.4,0.4)*(pow(abs(dir.z),0.1)*1.0);\n\t\treturn ground;\n\t}\n}\n\n\n// Lighting. Adds some environment reflections\nvec3 getLight(in vec3 color, in vec3 normal, in vec3 dir) {\n\tfloat diffuse = 0.3*max(0.0,dot(-normal, lightDir)); // Lambertian\n\tfloat diffuse2 =0.3* max(0.0,dot(-normal, lightDir2)); // Lambertian\n\tvec3 r = reflect(normal,dir);\n\treturn\n\t(diffuse*Diffuse)*(LightColor*color) +\n\t(diffuse2*Diffuse)*(LightColor2*color) +0.5*bg(r);\n}\n\n\n// Finite difference normal\nvec3 getNormal(in vec3 pos) {\n\tvec3 e = vec3(0.0,normalDistance,0.0);\n\t\n\treturn normalize(vec3(\n\t\t\tDE(pos+e.yxx)-DE(pos-e.yxx),\n\t\t\tDE(pos+e.xyx)-DE(pos-e.xyx),\n\t\t\tDE(pos+e.xxy)-DE(pos-e.xxy)\n\t\t\t)\n\t\t);\n}\n\n// Pseudo-random number\n// From: lumina.sourceforge.net/Tutorials/Noise.html\nfloat rand(vec2 co){\n\treturn fract(cos(dot(co,vec2(4.898,7.23))) * 23421.631);\n}\n\n// Solid color \nvec3 getColor(vec3 normal, vec3 pos) {\n\treturn vec3(1.0);\n}\n\n// Returns (r,theta [0..pi],phi [-pi,pi])\nvec3 cartesianToSpherical(vec3 p) {\n\tfloat r = length(p);\n\tfloat theta = acos(p.z/r);\n\tfloat phi = atan(p.y,p.x);\n\treturn vec3(r,theta,phi);\n}\n\n\nvec4 rayMarch(in vec3 from, in vec3 dir, in vec2 fragCoord) {\n\t// Add some noise to prevent banding\n\tfloat totalDistance = Jitter*rand(fragCoord.xy+vec2(iTime));\n\tvec3 dir2 = dir;\n\tfloat distance;\n\tint steps = 0;\n\tvec3 pos;\n\tfor (int i=0; i <= MaxSteps; i++) {\n\t\tpos = from + totalDistance * dir;\n\t\tdistance = DE(pos)*FudgeFactor;\n\t\t\n\t\ttotalDistance += distance;\n\t\tif (distance < MinimumDistance) break;\n\t\tsteps = i;\n\t}\n\t\n\t// 'AO' is based on number of steps.\n\tfloat ao = 1.0-float(steps)/float(MaxSteps);\n\t\n\t// Since our distance field is not signed,\n\t// backstep when calc'ing normal\n\tvec3 normal = getNormal(pos-dir*normalDistance*3.0);\n\tvec3 b = bg(dir);\n\tb = mix(b, vec3(0.0,0.0,0.0), 0.2);\n\tif (steps == MaxSteps) {\n\t\treturn vec4(b,1.0);\n\t}\n\tvec3 color = getColor(normal, pos);\n\tvec3 light = getLight(color, normal, dir);\n\tcolor =(color*Ambient+light)*(ao);\n\treturn vec4(color,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    float U = 0.0*cos(iTime)*0.5+0.1;\nfloat V =  0.2*sin(iTime*0.1)*0.5+0.2;\nfloat W =  1.0*cos(iTime*1.2)*0.5+0.5;\nfloat T =  0.01;\n\tinit(U,V,W,T);\n\t\n\t// Camera \n\tvec3 camPos = 0.4*(12.0+2.0*sin(iTime*0.6))*vec3(cos(iTime*0.3),sin(iTime*0.3),-1.6);\n\tvec3 target = vec3(0.0,0.0,0.0);\n\tvec3 camUp  = vec3(0.0,0.0,1.0);\n\t\n\t// Calculate orthonormal camera reference system\n\tvec3 camDir   = normalize(target-camPos); // direction for center ray\n\tcamUp = normalize(camUp-dot(camDir,camUp)*camDir); // orthogonalize\n\tvec3 camRight = normalize(cross(camDir,camUp));\n\t\n\tlightDir= -normalize(camPos+7.5*camUp);\n\tlightDir2=-normalize( camPos- 6.5*camRight);\n\n\tvec2 coord =-1.0+2.0*fragCoord.xy/iResolution.xy;\n\tfloat vignette = 0.2*pow(dot(coord,coord),1.0);\n\tcoord.x *= iResolution.x/iResolution.y;\n\t\n\t// Get direction for this pixel\n\tvec3 rayDir = normalize(camDir + (coord.x*camRight + coord.y*camUp)*FieldOfView);\n\t\n\tvec3 col = rayMarch(camPos, rayDir, fragCoord).xyz;   \n    col = clamp(col, 0.0,1.0);\n    col *=(1.0-vignette);\n\t\n\t// Marker at the bottom to indicate zone\n\tfloat pos =6.0*fragCoord.x/iResolution.x;\n\tif (pos<zone && pos>zone-1.0 && coord.y<-0.8) {\n\t\tcol = col.xxx;\n\t}\n    col=col.yzx;//color swivel to distinguish from older version\n\t\n\tfragColor = vec4(col,1.0);\n}\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mtlyzf.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1301, 1365, 1409, 1409, 1777], [1779, 1779, 1809, 1809, 1876], [1878, 2012, 2079, 2079, 3329], [3331, 3331, 3352, 3352, 3856], [3858, 3858, 3896, 4089, 4153], [4155, 4155, 4190, 4190, 4292], [4294, 4294, 4338, 4461, 4802], [4804, 5150, 5187, 5187, 5393], [5395, 5395, 5415, 5441, 5692], [5726, 5740, 5759, 5759, 6053], [6056, 6103, 6162, 6162, 6433], [6436, 6464, 6493, 6493, 6666], [6668, 6745, 6765, 6765, 6825], [6827, 6843, 6881, 6881, 6902], [6904, 6946, 6981, 6981, 7088], [7091, 7091, 7152, 7190, 7981], [7983, 7983, 8039, 8039, 9320]]}
{"id": "MtscRs", "name": "Spiral Lines", "author": "themasmo", "description": "A simple spiral effect", "tags": ["2d", "lines"], "likes": 1, "viewed": 98, "date": "1506094288", "time_retrieved": "2024-06-20T19:01:34.274996", "image_code": "\nfloat _OutlineWidth = 0.02;\nfloat _LineWidth = 0.08;\nvec4 _OutlineColor = vec4(0.,0.,0.,0.);\nvec4 _FrontColor = vec4(1.0,1.0,1.0,1.0);\n\n//======================\n// Line functions\n//======================\nfloat line(vec2 pos, vec2 point1, vec2 point2, float width) {\n    vec2 dir0 = point2 - point1;\n    vec2 dir1 = pos - point1;\n    float h = clamp(dot(dir0, dir1)/dot(dir0, dir0), 0.0, 1.0);\n    float d = (length(dir1 - dir0 * h) - width * 0.5);\n    return d;\n}\n\nvec4 line_with_color(vec2 pos, vec2 point1, vec2 point2, float width) {   \t\t\n    float d = line(pos, point1, point2, width);\n    float w = fwidth(0.5*d) * 2.0;\n    vec4 layer0 = vec4(_OutlineColor.rgb, 1.-smoothstep(-w, w, d - _OutlineWidth));\n    vec4 layer1 = vec4(_FrontColor.rgb, 1.-smoothstep(-w, w, d));\n    \n    return mix(layer0, layer1, layer1.a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.0*( fragCoord.xy / iResolution.xy) -1.0;\n    \n    \n\tfloat color=1.0;\n\tfloat rg=0.0;\n\tfloat an=iTime*50.0;\n\tfloat dan=iTime;\n\tvec2 oldp=vec2(0.0,0.0);\n\t\n\tfor(int i=0;i<64;i++)\n\t{\n//\t\tvec2 p1=vec2(0.0,0.0);\n\t\tvec2 p2=vec2(rg*cos(an*3.141/180.0),rg*sin(an*3.141/180.0));\n\t\tvec4 linea=line_with_color(uv,oldp,p2,0.005);\n\t\n\t\tfragColor = mix(fragColor,linea,linea.a);\n\t\t\n\t\tan+=dan;\n\t\trg+=0.02;\n\t\toldp=p2;\n\t}    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtscRs.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[137, 205, 266, 266, 464], [466, 466, 537, 537, 824], [826, 826, 883, 883, 1309]]}
{"id": "MtsyD4", "name": "Voxel City at night", "author": "ocb", "description": "Use of \"Construction Set\" shader.\nMouse enable.", "tags": ["raytracing", "transparency", "voxel", "reflect"], "likes": 6, "viewed": 740, "date": "1504905621", "time_retrieved": "2024-06-20T19:01:35.268830", "image_code": "// Author: ocb\n// Title: Voxels City at Night\n\n\n#define PI 3.141592653589793\n#define PIdiv2 1.57079632679489\n#define TwoPI 6.283185307179586\n#define INFINI 1000000.\n\n#define NO_TRANSPARENCY\n#define BORDER\n\n#define boxDim 100.\n#define maxBoxRnge 170\n#define maxReflRnge 70\n#define emptyChance 30.\n#define buildSize 5.\n\n// object name\n#define GND -1\n#define SKY -1000\n#define NONE 0\n#define BOX 1\n\n//Global var\nvec3 color = vec3(0.);\nvec3 lightRay = normalize(vec3(1.,.1,.2));\n\nfloat H1 (in float v) { \t\t\t\t\t\t\n    return fract(sin(v) * 437585.);\n}\nfloat H2 (in vec2 st,in float time) { \t\t\t\t\t\t\n    return fract(sin(dot(st,vec2(12.9898,8.233))) * 43758.5453123+time);\n}\nfloat H3 (in vec3 st,in float time) { \t\t\t\t\t\t\n    return fract(sin(dot(st,vec3(12.9898,8.233,17.6533107))) * 43758.5453123+time);\n}\n\nfloat sfcImpact(in float p, in float ray, in float h){\n    float t = (h-p)/ray;\n    if (t <= 0.001) t = INFINI;\n    return t;\n}\n\nvec3 skyGlow(in vec3 ray){\n    float a = dot(lightRay, ray);\n    return vec3(smoothstep(.98,1.,a));\n}\n\nvec3 setBox(in vec3 p){\n    return floor(p/boxDim + .5);\n}\n\nvec3 deBox(in vec3 box){\n    return box*boxDim;\t\t// return the center of the box\n}\nvec3 getNextBox(in vec3 p, in vec3 v, in vec3 box){\n    vec3 d = sign(v);\n\tvec3 dt = ((box+d*.5)*boxDim-p)/v;\n    float dmin = min(min(dt.x,dt.y),dt.z);\n    d *= step(dt, vec3(dmin));\n    return box+d;\n}\n\nbool checkBox(in vec3 box){\n    float h = H3(floor(box),0.)*(emptyChance + 2.);\n    return bool(int(floor( max(0.,h-emptyChance) )));\n}\n\nbool checkBox2(in vec3 box){\n    float h = H2(floor(box.xz/buildSize),0.);\n    return bool(step(min(31.,h*float(maxBoxRnge)), -box.y+20.));\n}\n\nvec4 browseBox(in vec3 box, in vec3 pos, in vec3 ray, inout int hitObj){\n    float t = INFINI, tt = INFINI;\n    float hitNbr = 0.;\n    vec3 d;\n    for(int i=0; i<maxBoxRnge;i++){\n    \tvec3 newBox = getNextBox(pos,ray,box);\n        d = box - newBox;\n        \n        if(checkBox2(newBox)) {\n            hitNbr ++;\n            color += .4/hitNbr*((dot(d,lightRay)+1.)*.3+.4)*vec3(0.08,H2(floor(newBox.xz/buildSize)*2.77665,0.)/8.+.1,0.3);\n            vec3 o = deBox(newBox+.5*d);\n            \n            if(abs(d.x) == 1.){\n                tt = (o.x-pos.x)/ray.x;\n                #ifdef BORDER\n                vec3 p = pos+tt*ray;\n                color.b += .1*(smoothstep(.4*boxDim, .5*boxDim ,abs(o.y-p.y)) + smoothstep(.4*boxDim, .5*boxDim ,abs(o.z-p.z)));\n                #endif\n            }\n            else if(abs(d.y) == 1.){\n                tt = (o.y-pos.y)/ray.y;\n                #ifdef BORDER\n                vec3 p = pos+tt*ray;\n                color.b += .1*(smoothstep(.4*boxDim, .5*boxDim ,abs(o.x-p.x)) + smoothstep(.4*boxDim, .5*boxDim ,abs(o.z-p.z)));\n                #endif\n            }\n            else{\n                tt = (o.z-pos.z)/ray.z;\n                #ifdef BORDER\n                vec3 p = pos+tt*ray;\n                color.b += .1*(smoothstep(.4*boxDim, .5*boxDim ,abs(o.x-p.x)) + smoothstep(.4*boxDim, .5*boxDim ,abs(o.y-p.y)));\n                #endif\n            }\n            \n            \n            #ifdef NO_TRANSPARENCY\n            if(bool(mod(newBox.y, 2.))){\n                hitObj = BOX;\n                t = tt;\n                break;\n            }\n            else{\n                vec3 refl = reflect(ray,d);\n                color += .4/hitNbr*skyGlow(refl);\n            }\n            #endif\n        }\n        box = newBox;\n    }\n    color = clamp(color,0.,1.);\n    return vec4(d,t);\n}\n\nbool browseBoxSimple(in vec3 box, in vec3 pos, in vec3 ray){\n    bool ret = false;\n    for(int i=0; i<maxReflRnge;i++){\n    \tbox = getNextBox(pos,ray,box);\n        if(checkBox2(box) && bool(mod(box.y, 2.)) ){\n            ret = true;\n            break;\n        }\n    }\n    return ret;\n}\n\nvec3 getCamPos(in vec3 camTarget){\n    float \trau = 100.,//*(sin(u_time/7.)+1.) + 50.,\n    \t\t//rau = 1.,\n    \t\talpha = iMouse.x/iResolution.x*4.*PI,\n    \t\ttheta = iMouse.y/iResolution.y*PI+(PI/2.0001);\n    \t\tif (iMouse.xy == vec2(0.)){\n                alpha = PIdiv2;\n                theta = 0.;\n            }\n    \n    return rau*vec3(-cos(theta)*sin(alpha),sin(theta),cos(theta)*cos(alpha))+camTarget;\n}\n\nvec3 getRay(in vec2 st, in vec3 pos, in vec3 camTarget){\n    float \tfocal = 2.;\n    vec3 ww = normalize( camTarget - pos );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0)) ) ;\n    vec3 vv = cross(uu,ww);\n\t// create view ray\n\treturn normalize( st.x*uu + st.y*vv + focal*ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = fragCoord.xy/iResolution.xy-.5;\n    st.x *= iResolution.x/iResolution.y;\n    \n    // camera def\n    vec3 camTarget = vec3(3000.*sin(iTime*.02),900.*sin(iTime*.05)-100.,2500.*cos(iTime*.03));\n    vec3 pos = getCamPos(camTarget);\n    vec3 ray = getRay(st, pos,camTarget);\n    \n\tvec3 lightRay = vec3(1.,0.,0.);\t\n\t\n    float t = INFINI;\n    vec3 norm;\n    int hitObj = SKY;\n    vec3 p = pos;\n    \n    vec3 box = setBox(p);\n\n    vec4 info = browseBox(box, p, ray, hitObj);\n    if(hitObj == SKY) color += skyGlow(ray)*min(1.,(1.-.5*texture(iChannel0,ray.yz*.5).x));\n    else{\n        norm = info.xyz;\n        t = info.w;\n        p += t*.999*ray;\n        \n        box = setBox(p);\n        vec3 refl = reflect(ray,norm);\n        if(!browseBoxSimple(box, p, refl)){\n            if(box.y == -10.) color += .2*skyGlow(refl);\n            else color += .5*skyGlow(refl);\n        }\n    }\n    \n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtsyD4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[396, 476, 499, 499, 544], [545, 545, 582, 582, 664], [665, 665, 702, 702, 795], [797, 797, 851, 851, 924], [926, 926, 952, 952, 1027], [1029, 1029, 1052, 1052, 1087], [1089, 1089, 1113, 1113, 1171], [1172, 1172, 1223, 1223, 1375], [1377, 1377, 1404, 1404, 1512], [1514, 1514, 1542, 1542, 1655], [1657, 1657, 1729, 1729, 3485], [3487, 3487, 3547, 3547, 3772], [3774, 3774, 3808, 3808, 4178], [4180, 4180, 4236, 4236, 4461], [4463, 4463, 4520, 4520, 5448]]}
{"id": "MtsyWM", "name": "Double pendulum attractor", "author": "nr4", "description": "This shader solves the system of nonlinear differential equations for the double pendulum with the runge-kutta-4 method.\nThe animation shows the attractor for different masses and lengths.", "tags": ["fractal", "chaotic", "nonlinearsystem"], "likes": 3, "viewed": 210, "date": "1505125444", "time_retrieved": "2024-06-20T19:01:36.038617", "image_code": "/** Double pendulum fractal shader\n    Copyright (C) 2017  Alexander Kraus <nr4@z10.info>\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n//lengths\nfloat L1 = 2.;\nfloat L2 = 1.;\n\n//masses\nfloat M1 = 3.5;\nfloat M2 = 0.1;\n\n//constants\nfloat G = 9.81;\n\n//runge kutta params\nfloat h = 1.e-1;\nfloat tmax = 3.;\n\n//math params\nfloat PI = 3.14159;\n\n/**eval system of differential equations\nparams:\ntp[0]: theta1\ntp[1]: theta2\ntp[2]: ptheta1\ntp[3]: ptheta2\n*/\nvec4 f(vec4 tp)\n{\n    float p0w = (L1*L2*(M1+M2*pow(sin(tp[0]-tp[1]),2.)));\n    float C1 = tp[2]*tp[3]*sin(tp[0]-tp[1])/p0w;\n    float C2 = (L2*L2*M2*tp[2]*tp[2]+L1*L1*(M1+M2)*tp[3]*tp[3]-L1*L2*M2*tp[2]*tp[3]*cos(tp[0]-tp[1]))*sin(2.*(tp[0]-tp[1]))/(2.*p0w*p0w);\n    \n    vec4 ret;\n    \n    ret[0] = (L2*tp[2]-L1*tp[3]*cos(tp[0]-tp[1]))/(L1*p0w);\n    ret[1] = (L1*(M1+M2)*tp[3]-L2*M2*tp[2]*cos(tp[0]-tp[1]))/(L2*M2*p0w);\n    ret[2] = -(M1+M2)*G*L1*sin(tp[0])-C1+C2;\n    ret[3] = -M2*G*L2*sin(tp[1])+C1-C2;\n    \n    return ret;    \n}\n\nvec4 step_rk4(vec4 tp)\n{\n    vec4 k1 = f(tp);\n    vec4 k2 = f(tp + h/2.*k1);\n    vec4 k3 = f(tp + h/2.*k2);\n    vec4 k4 = f(tp + h*k3);\n    return tp + h/6.*(k1+2.*k2+2.*k3+k4);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    M1 = 2.+1.*sin(iTime);\n    M2 = 2.+1.*cos(2.*iTime);\n    \n    L1 = 2.+.1*sin(iTime);\n    L2 = 1.+.1*cos(3.*iTime);\n    \n    vec4 state = vec4(uv*2.*PI/0.62-vec2(PI/2.,PI/2.), 0, 0);\n    float time = 0.;\n    while(time < tmax) \n    {\n        state = step_rk4(state);\n        time += h;\n    }\n    \n    /*\n    vec4 start = vec4(49./255., 255./255., 4./255., 1.);\n    vec4 end = vec4(232./255., 14./255., 18./255., 1.);\n    if(d<.5)\n        fragColor = mix(start, vec4(0.,0.,0.,1.), d);\n    else \n        fragColor = mix(vec4(0.,0.,0.,1.), end, d);*/\n    \n    \n    const int ncolors = 10;\n    vec4 color_list[ncolors] = vec4[ncolors]( vec4(1.,156./255., 19./255.,1.), vec4(232./255., 98./255., 12./255., 1.), vec4(1.,53./255., 0., 1.), vec4(232./255.,16./255.,12./255.,1.), vec4(1., 10./255., 150./255., 1.), vec4(1., 235./255., 10./255., 1.), vec4(195./255.,232./255., 12./255., 1.), vec4(97./255., 1., 0., 1.), vec4(12./255., 232./255., 25./255., 1.), vec4(13./255., 1. ,117./255., 1.) );\nfragColor = vec4(0.,0.,0.,1.0);\n    \n    if(state[1] < 20.*PI)\n    {\n        //float scale = state[1]/20.*PI;\n        float scale = state[1]/state[3]/2.*tmax;\n        vec4 start = vec4(49./255., 255./255., 4./255., 1.);\n        vec4 end = vec4(232./255., 14./255., 18./255., 1.);\n        fragColor=sin(scale)*start+cos(scale)*end;\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "gpl-3.0-plus", "thumbnail": "https://www.shadertoy.com/media/shaders/MtsyWM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[950, 1060, 1077, 1077, 1592], [1594, 1594, 1618, 1618, 1773], [1775, 1775, 1832, 1832, 3209]]}
{"id": "Mtsyz2", "name": "Munching Squares", "author": "tehsauce", "description": "A quick implementation of an algorithm described in [url]https://nbickford.wordpress.com/2011/04/03/the-minsky-circle-algorithm/[/url]", "tags": ["squares", "integer", "bitwise", "munching", "jacksonwright"], "likes": 3, "viewed": 2007, "date": "1505629012", "time_retrieved": "2024-06-20T19:01:36.038617", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int val = int(fragCoord.x) ^ int(fragCoord.y);\n    float col = float(val/iFrame);\n\tfragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mtsyz2.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 179]]}
{"id": "MtsyzB", "name": "spiral test", "author": "Bloodbrand", "description": "test", "tags": ["test"], "likes": 2, "viewed": 84, "date": "1505376959", "time_retrieved": "2024-06-20T19:01:36.038617", "image_code": "#define F(x) (log(x))\n\nvoid mainImage( out vec4 f, in vec2 w )\n{\n    vec2 p = 2.*w/iResolution.xy-1.;\n    f = vec4(vec3(float(fract(atan(p.y,p.x)*1.909859 + iTime - 4.*F(length(p))) > 0.5)), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtsyzB.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[23, 23, 64, 64, 197]]}
{"id": "MtXcDn", "name": "Simple 4D Raymarcher w/ Shadows", "author": "Assossa", "description": "Modification of shadertoy.com/view/4lXyz8\nOnly the camera is moving in the w axis. Both spheres are at w 0. The light is at w 1.5.", "tags": ["simple", "shadows", "raymarcher", "4d"], "likes": 2, "viewed": 95, "date": "1504289313", "time_retrieved": "2024-06-20T19:01:36.662883", "image_code": "/*\nThe modification from 3D to 4D was extremely simple.\nI simply had to replace vec3 with vec4 and\nthen animate the camera's movement in the w axis.\n*/\n\nconst float maxRender = 10e4; // Max distance to ray march\nconst float epsilon = 0.001; // Margin of error\nconst vec4 light = vec4(1.5, 1.5, -1.5, 1.5);\nconst vec4 up = vec4(0, 1, 0, 0);\n\n// Spheres\nint sphereCount = 2;\nvec4 sphereCenters[2];\nfloat sphereRadius[2];\nfloat floorHeight = -2.5;\n\n// Find distance between sphere and ray\nfloat sphereDistance(vec4 p, vec4 center, float radius) {\n    return distance(p, center) - radius;\n}\n\n// Find normal of sphere from hit location\nvec4 sphereNormal(vec4 p, vec4 center) {\n    return normalize(p - center);\n}\n\n// Get the hit location for a sphere and ray\nfloat sphereHit(vec4 o, vec4 d, vec4 center, float radius) {\n    // Keep track of the distance we have traveled\n    float dist = 0.0;\n    \n    // Kill the marching if we go too far\n    while(dist <= maxRender) {\n        // Get distance to sphere\n        float tempDist = sphereDistance(o, center, radius);\n        \n        // Add it to our distance counter and update the ray origin\n        dist += tempDist;\n        o += d * tempDist;\n        \n        // If we hit a sphere, then return the hit\n        if(tempDist <= epsilon) return dist;\n    }\n    \n    // We didn't hit anything\n    return -1.0;\n}\n\n// Get the hit for the floor\nfloat floorHit(vec4 o, vec4 d, float height) {\n    float du = dot(d, up);\n    if(du == 0.0) return -1.0;\n    \n    float dist = dot((up * height) - o, up) / du;\n    if(dist < 0.0) return -1.0;\n    \n    return dist;\n}\n\nvec2 findHit(vec4 origin, vec4 ray, int ignore) {    \n    // Find a hit\n    float hit = maxRender;\n    int hitID = -1;\n    \n    for(int i = 0; i < sphereCount; i++) {\n        if(i == ignore) continue;\n    \tfloat tempHit = sphereHit(origin, ray, sphereCenters[i], sphereRadius[i]);\n        if(tempHit < hit  && tempHit >= 0.0) {\n            hit = tempHit;\n            hitID = i;\n        }\n    }\n    \n    if(ignore != -1) {\n        // Check for hit with floor\n        float tempHit = floorHit(origin, ray, floorHeight);\n        if(tempHit < hit && tempHit >= 0.0) {\n            hit = tempHit;\n            hitID = -1;\n        }\n    }\n    \n    return vec2(hit == maxRender ? -1.0 : hit, hitID);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Create ray for current pixel\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec4 ray = normalize(vec4(uv, 1.0, 1.0));\n    vec4 origin = vec4(0.0, 0.0, -3.0, sin(iTime * 0.735413) - 2.6);\n    \n    // Initialize the spheres\n    sphereCenters[0] = vec4(0.0);\n    sphereCenters[1] = vec4(cos(iTime) * 1.8, sin(iTime) * 1.8, -0.8, 0.0);\n    sphereRadius[0] = 1.0;\n    sphereRadius[1] = 0.5;\n    \n    // Find a hit\n    vec2 tempHit = findHit(origin, ray, -10);\n    float hit = tempHit.x;\n    int hitID = int(tempHit.y);\n    \n    // If no hit, then use the sky color\n    if(hit < 0.0) {\n        fragColor = vec4(0.3, 0.5, 0.7, 1.0);\n        return;\n    }\n    \n    // Find hit point & light direction\n    vec4 hitPoint = origin + (ray * hit);\n    vec4 lightDir = normalize(light - hitPoint);\n    \n    // Find if we need a shadow\n    vec2 shadowHit = findHit(hitPoint, lightDir, hitID);\n    float shadow = shadowHit.y >= 0.0 ? 0.5 : 0.0;\n    \n    // Find the normal of the sphere and the diffuse lighting from the normal\n    vec4 nml = hitID == -1 ? up : sphereNormal(hitPoint, sphereCenters[hitID]);\n    float diffuse = max(dot(nml, lightDir) + 0.4 - shadow, 0.0) * 0.95;\n    \n    fragColor = vec4(vec3(diffuse), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtXcDn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[446, 486, 543, 543, 586], [588, 631, 671, 671, 707], [709, 754, 814, 865, 1354], [1356, 1385, 1431, 1431, 1600], [1602, 1602, 1651, 1673, 2294], [2296, 2296, 2351, 2387, 3643]]}
{"id": "MtXcWB", "name": "Analytic Frustum Slicing", "author": "paniq", "description": "Visualizes a quadric as seen through a frustum and the min/max function range on frustum screen plane slices. Blue depth slices along ray t are outside, orange crossing surface, teal inside (fully occluded).", "tags": ["ray", "quadric", "ellipsoid", "quadratic", "analytic", "spanning", "bunding"], "likes": 4, "viewed": 549, "date": "1506403389", "time_retrieved": "2024-06-20T19:01:44.299860", "image_code": "/*\n\nVisualizes \n a) a quadric as seen through a square frustum and \n b) the min/max function range on frustum screen plane slices. \n\nBlue depth slices along ray t are outside, \norange crossing surface, teal inside (fully occluded).\n\nThe black frizzy background of the graph is the ground truth:\na plot of all quadratic functions over all rays of the frustum.\n\nThe vertical lines are the analytically computed result.\n\nThis was done by building a bivariate quadratic function from \nsampling six ray functions at frustum edges and then computing\nthe bounds of that function. This is not the most straight forward\nway to do this, but I wasn't considering any optimization yet.\n\nIt is possible to iterate towards the nearest depth of \nconvex quadric objects within the frustum by using \nnewton's method and differential derivatives.\n\nI hope to eventually find a closed-form solution to compute the\nfour planes that interest me: near and far planes of \nthe orange section, and the near and far plane of teal\nsections. But I don't think there's much hope.\n\nFor non-convex quadrics such as cones one could build a \ntrivariate quadratic function to bound it over intervals\nof t, then use bisection with a bit of newton where applicable\nto find the nearest and farthest crossing planes.\n\n\n\n*/\n\n\n// polynomial arithmetic\n// describes piecewise univariate polynomial with degree 2\nstruct poly2 {\n    // the coefficients for f(x) = a0 * x^0 + a1 * x^1 + a2 * x^2\n    vec3 a;\n    // distance to horizon\n    float h;\n};\n\nconst float infinity = 1. / 0.;\n\nbool hasaxis(poly2 f) {\n    return (f.h != infinity);\n}\n\npoly2 pa_init(float x) {\n    return poly2(vec3(x,1.0,0.0),infinity);\n}\n\nfloat merge_axes(poly2 f, poly2 g) {\n    if (hasaxis(g)) {\n        if (hasaxis(f)) {\n            float a0 = min(f.h, g.h);\n            float a1 = max(f.h, g.h);\n            return ((a0 > 0.0)?a0:a1);\n        } else {\n            return g.h;\n\t\t}\n    }\n    return f.h;\n}\n\npoly2 pa_add(poly2 f, poly2 g) {\n    return poly2(f.a + g.a,merge_axes(f,g));\n}\npoly2 pa_add(poly2 f, float c) {\n    return poly2(vec3(f.a[0] + c,f.a[1],f.a[2]),f.h);\n}\npoly2 pa_add(float c, poly2 f) {\n    return poly2(vec3(f.a[0] + c,f.a[1],f.a[2]),f.h);\n}\npoly2 pa_sub(poly2 f, poly2 g) {\n    return poly2(f.a - g.a,merge_axes(f,g));\n}\npoly2 pa_sub(poly2 f, float c) {\n    return poly2(vec3(f.a[0] - c,f.a[1],f.a[2]),f.h);\n}\npoly2 pa_sub(float c, poly2 f) {\n    return poly2(vec3(c - f.a[0],-f.a[1],-f.a[2]),f.h);\n}\npoly2 pa_unm(poly2 f) {\n    return poly2(-f.a,f.h);\n}\n\n// {a0 a1 a2} * {b0 b1 b2}\n// = {a0*b0 (a0*b1 + a1*b0) (a0*b2 + a2*b0 + a1*b1) (a1*b2 + a2*b1) (a2*b2)}\n// the two new coefficients are truncated, so only linear\n// functions are going to work here reliably.\npoly2 pa_mul(poly2 f, poly2 g) {\n    return poly2(vec3(\n    \tf.a[0] * g.a[0],\n\t    f.a[0] * g.a[1] + f.a[1] * g.a[0],\n        f.a[0] * g.a[2] + f.a[1] * g.a[1] + f.a[2] * g.a[0]\n        //f.a[1] * g.a[2] + f.a[2] * g.a[1],\n        //f.a[2] * g.a[2]\n        ), f.h);\n}\npoly2 pa_mul(poly2 f, float c) {\n    return poly2(f.a * c,f.h);\n}\npoly2 pa_mul(float c, poly2 f) {\n    return poly2(f.a * c,f.h);\n}\n\n// the two new coefficients are truncated, so only linear\n// functions are going to work here reliably.\npoly2 pa_pow2(poly2 f) {\n    return poly2(vec3(\n    \tf.a[0] * f.a[0],\n\t    2.0 * f.a[0] * f.a[1],\n        2.0 * f.a[0] * f.a[2] + f.a[1] * f.a[1]\n        //2.0 * f.a[1] * f.a[2],\n        //f.a[2] * f.a[2]\n        ), f.h);\n}\n\n// returns f(x), f'(x), f''(x)\nvec3 pa_f(vec3 a, float x) {\n    return vec3(\n        a[0] + (a[1] +       a[2] * x) * x,\n                a[1] + 2.0 * a[2] * x,\n                             a[2]);\n}\n\nfloat solve_quadratic(vec3 fa, float x) {\n    float a = fa[2];\n    float b = fa[1];\n    float c = fa[0];\n\n    // the quadratic solve doesn't work for a=0\n    // so we need a branch here.\n    if (a == 0.0) {\n        return -c / b;\n    } else {\n        // (-b +- sqrt(b*b - 4.0*a*c)) / 2.0*a\n        float k = -0.5*b/a;\n        float q = sqrt(k*k - c/a);\n        float q0 = k - q;\n        float q1 = k + q;\n\n        // pick the root right of x\n\t\treturn (q0 <= x)?q1:q0;\n    }\n}\n\nfloat solve_quadratic0(vec3 fa) {\n    float a = fa[2];\n    float b = fa[1];\n    float c = fa[0];\n\n    // the quadratic solve doesn't work for a=0\n    // so we need a branch here.\n    if (a == 0.0) {\n        return -c / b;\n    } else {\n        // (-b +- sqrt(b*b - 4.0*a*c)) / 2.0*a\n        float k = -0.5*b/a;\n        float q = sqrt(k*k - c/a);\n        // pick the closest root right of 0\n\t\treturn k + ((k <= q)?q:-q);\n    }\n}\n\nvec2 solve_quadratic2(vec3 fa) {\n    float a = fa[2];\n    float b = fa[1];\n    float c = fa[0];\n\n    // the quadratic solve doesn't work for a=0\n    // so we need a branch here.\n    if (a == 0.0) {\n        return vec2(-c / b);\n    } else {\n        // (-b +- sqrt(b*b - 4.0*a*c)) / 2.0*a\n        float k = 0.5*b/a;\n        float q = sqrt(k*k - c/a);\n\t\treturn vec2(-k, q);\n    }\n}\n\nfloat solve_quadratic(poly2 f) {\n    return solve_quadratic0(f.a);\n}\n\n// returns the x position of the next root, where f(x) = 0\nfloat nextroot(poly2 f) {\n    return solve_quadratic(f);\n}\n\n// returns the position of the next event (root or start of new segment)\nfloat nextevent(poly2 f) {\n    float s = nextroot(f);\n    float h = (f.h <= 0.0)?infinity:f.h;\n    s = (s <= 0.0)?h:min(s,h);\n    return s;\n}\n\nfloat axis(poly2 f) {\n    return nextevent(f);\n}\n\nfloat pa_sign(poly2 f) {\n    return ((f.a[0] < 0.0)?-1.0:1.0);\n}\n\n// signed pow2; this is for transforming linear distance functions\n// to quadratic ones so they compare correctly against spherical functions\n// the position of the root is not altered\npoly2 pa_spow2(poly2 f) {\n    return pa_mul(pa_pow2(f), pa_sign(f));\n}\n\npoly2 pa_abs(poly2 f) {\n    float s = pa_sign(f);\n\n    f.h = axis(f);\n\n    return poly2(f.a * s, f.h);\n}\n\npoly2 pa_const(float c) {\n    return poly2(vec3(c,0.0,0.0), infinity);\n}\n\npoly2 pa_ipol(vec2 a, vec2 b) {\n    float a1 = (a.y - b.y)/(a.x - b.x);\n\tfloat a0 = a.y - a1*a.x;\n    return poly2(vec3(a0, a1, 0.0), infinity);\n}\n\npoly2 pa_ipol(vec2 a, vec2 b, float k) {\n    float a2 = 0.5*k;\n    float aa2 = a2*a.x*a.x;\n    float a1 = (a.y - b.y + a2*b.x*b.x - aa2) / (a.x - b.x);\n    float a0 = a.y - a1*a.x - aa2;\n    return poly2(vec3(a0, a1, a2), infinity);\n}\n\npoly2 pa_min(poly2 f, poly2 g) {\n    float h = axis(pa_sub(f,g));\n    float fx = f.a[0];\n    float gx = g.a[0];\n    return poly2((fx < gx)?f.a:g.a, h);\n}\n\npoly2 pa_max(poly2 f, poly2 g) {\n    float h = axis(pa_sub(f,g));\n    float fx = f.a[0];\n    float gx = g.a[0];\n    return poly2((fx > gx)?f.a:g.a, h);\n\n}\n\n// the output can only be subject to more comparisons, but must not\n// be transformed further.\npoly2 pa_hardmin(poly2 f, poly2 g) {\n#ifdef USE_HARDMIN\n    float fe = nextevent(f);\n    float ge = nextevent(g);\n    float h = axis(pa_sub(f,g));\n    float fx = f.a[0];\n    float gx = g.a[0];\n    bool fi = (fx < 0.0);\n    bool gi = (gx < 0.0);\n    // both outside\n    if (!fi && !gi) {\n        if (fe <= ge)\n            return f;\n        else\n            return g;\n    // both inside\n    } else if (fi && gi) {\n        if (fe <= ge)\n            return f;\n        else\n            return g;\n    } else {\n        return poly2((fx < gx)?f.a:g.a, h);\n    }\n#else\n    float h = axis(pa_sub(f,g));\n    float fx = f.a[0];\n    float gx = g.a[0];\n    return poly2((fx < gx)?f.a:g.a, h);\n#endif\n}\n\n// the output can only be subject to more comparisons, but must not\n// be transformed further.\npoly2 pa_hardmax(poly2 f, poly2 g) {\n    return pa_unm(pa_hardmin(pa_unm(f),pa_unm(g)));\n}\n\n// can only be used once on flat surfaces reliably\n// appears to still work with more complex functions?\npoly2 pa_smin(poly2 a, poly2 b, float r) {\n    poly2 e = pa_min(\n        pa_max(\n            pa_add(\n                pa_unm(\n                    pa_abs(\n                        pa_sub(a, b))), r),\n            pa_const(0.0)),pa_const(r));\n    return pa_sub(pa_min(a, b), pa_mul(pa_pow2(e), 0.25 / r));\n}\n\npoly2 pa_smax(poly2 a, poly2 b, float r) {\n    return pa_unm(pa_smin(pa_unm(a),pa_unm(b),r));\n}\n\n// approximates blend with a quadratic patch, but\n// very buggy. avoid.\npoly2 pa_smin2(poly2 a, poly2 b, float r) {\n    float h = solve_quadratic0(pa_sub(a, b).a);\n    float x0 = h - r;\n    float x1 = h + r;\n    if (0.0 < x0) {\n        a.h = x0;\n        return a;\n    } else if (0.0 >= x1) {\n        return b;\n    } else {\n        vec3 ay0 = pa_f(a.a, x0);\n        vec3 by0 = pa_f(b.a, x0);\n        vec3 ay1 = pa_f(a.a, x1);\n        vec3 by1 = pa_f(b.a, x1);\n        vec3 y0 = (ay0.x < by0.x)?ay0:by0;\n        vec3 y1 = (ay1.x < by1.x)?ay1:by1;\n        poly2 m = pa_ipol(vec2(x0, y0.x), vec2(x1, y1.x), (y1.y - y0.y) / (x1 - x0));\n        m.h = x1;\n    \treturn m;\n    }\n}\n\nvec3 ro;\nvec3 rd;\n\npoly2 sphere(poly2 x, poly2 y, poly2 z, float r) {\n    return pa_sub(pa_add(pa_add(pa_pow2(x),pa_pow2(y)),pa_pow2(z)), r*r);\n}\n\npoly2 ellipsoid(poly2 x, poly2 y, poly2 z, vec3 r) {\n    poly2 ex = pa_pow2(pa_mul(x, 1.0/r.x));\n    poly2 ey = pa_pow2(pa_mul(y, 1.0/r.y));\n    poly2 ez = pa_pow2(pa_mul(z, 1.0/r.z));\n    return pa_sub(pa_add(pa_add(ex,ey),ez), 1.0);\n}\n\npoly2 quadric(poly2 x, poly2 y, poly2 z, vec3 abc, float r){//ax^2+by^2+cz^2=r^2\n\tpoly2 ex = pa_mul(pa_pow2(x), abc.x);\t\t//cone=vec3(1.0,-1.0,1.0)\n\tpoly2 ey = pa_mul(pa_pow2(y), abc.y);\t\t//cyl=vec3(1.0,0.0,1.0)\n\tpoly2 ez = pa_mul(pa_pow2(z), abc.z);\t\t//ellipse=vec3(0.5,2.0,1.0)\n\treturn pa_sub(pa_add(pa_add(ex,ey),ez), abs(r)*r); //allows negative r parabola=vec3(1.0,-1.0,1.0),-0.5\n}\n\npoly2 cube(poly2 x, poly2 y, poly2 z, float r) {\n#if 1\n\treturn pa_sub(pa_max(pa_max(pa_abs(x),pa_abs(y)),pa_abs(z)),r);\n#else\n    poly2 d = pa_max(pa_max(pa_abs(x),pa_abs(y)),pa_abs(z));\n    return pa_sub(pa_spow2(d),r * r);\n#endif\n}\n\npoly2 plane(poly2 x, poly2 y, poly2 z, vec4 n) {\n#if 1\n\treturn pa_sub(pa_add(pa_add(pa_mul(x,n.x),pa_mul(y,n.y)),pa_mul(z,n.z)),n.w);\n#else\n    poly2 d = pa_add(pa_add(pa_mul(x,n.x),pa_mul(y,n.y)),pa_mul(z,n.z));\n    return pa_sub(pa_spow2(d),n.w * n.w * sign(n.w));\n#endif\n}\n\n/*\n// not really a cone - todo :|\npoly2 cone(poly2 x, poly2 y, poly2 z, vec2 a, float l) {\n    return pa_max(\n        pa_add(pa_mul(pa_add(pa_pow2(x),pa_pow2(y)),a.x),\n               pa_mul(a.y, z)),z);\n}\n*/\n\nvoid rotate(poly2 x, poly2 y, out poly2 rx, out poly2 ry, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    rx = pa_sub(pa_mul(x,c),pa_mul(y,s));\n    ry = pa_add(pa_mul(x,s),pa_mul(y,c));\n}\n\nfloat anim_time;\npoly2 pa_map(poly2 x, poly2 y, poly2 z) {\n#if 0\n\tpoly2 w = plane(x, y, z, vec4(0.0,0.0,1.0,-0.6));\n    poly2 vz = pa_sub(z,sin(anim_time*0.3)*0.4);\n\tpoly2 s = sphere(pa_sub(x,1.0),y,vz, 0.5);\n\tpoly2 s2 = sphere(pa_sub(x,0.65),y,vz, 0.3);\n\t//poly2 c = cone(pa_sub(x,-0.5),y,pa_sub(z,-0.3), normalize(vec2(1.0,0.5)), 0.5);\n    poly2 rx, rz;\n    rotate(pa_sub(x,-0.5),pa_sub(z,-0.5),rx,rz,anim_time*0.5);\n    poly2 c = ellipsoid(rx,y,rz,vec3(0.2,0.5,0.5));\n    poly2 cb = cube(rx,y,pa_add(rz,-0.5),0.2);\n\n    poly2 d = pa_hardmax(s,pa_unm(s2));\n    d = pa_hardmin(d,w);\n    d = pa_hardmin(d, c);\n    d = pa_hardmin(d, cb);\n#else\n    float a = iTime;//.5;\n    rotate(x,y,x,y,a*0.79);//anim_time*0.5);\n    //rotate(y,z,y,z,a*0.49);//anim_time*0.5);\n    rotate(x,z,x,z,a*0.69);\n\n    //poly2 d = ellipsoid(x,y,z, vec3(0.5,0.4,0.3));\n    //poly2 d = ellipsoid(x,y,z, vec3(0.5,0.45,0.2));\n    poly2 d = quadric(x,y,z, vec3(1.0/0.5,1.0/0.45,1.0/0.2), 1.0);\n    //poly2 d = plane(x,y,z, vec4(0.0,0.0,1.0,-0.6));\n    //poly2 d = cube(x,y,z,0.5);\n    //poly2 d = sphere(x,y,z, 0.5);\n#endif\n\treturn d;\n}\n\npoly2 pa_map(vec3 ro, vec3 rd, float t) {\n    poly2 dt = pa_init(t);\n    poly2 x = pa_add(ro.x, pa_mul(rd.x, dt));\n    poly2 y = pa_add(ro.y, pa_mul(rd.y, dt));\n    poly2 z = pa_add(ro.z, pa_mul(rd.z, dt));\n    return pa_map(x,y,z);\n}\n\n// how to convert pa_map to a classic map function\n// t is the ray scalar\n// returns function value at that point, and distance\n// to next root or horizon\nvec3 map(vec3 ro, vec3 rd, float t) {\n    poly2 f = pa_map(ro, rd, t);\n    return vec3(f.a[0], nextevent(f), f.a[1]);\n}\n\nvoid setup() {\n    anim_time = 0.0;\n}\n\nfloat tri(float x) {\n    return 2.0 * abs( floor(x*0.5+0.5) - 0.5*x );\n}\n\nvoid prepare_ray(float s, float t) {\n    //s = 0.0;\n    float q = tri(iTime*0.3);\n    vec2 c = vec2(mix(0.0,3.2,q),0.0);\n    vec2 w = vec2(1.0,1.0)*mix(0.1,1.5,q);\n    s = s*2.0 - 1.0;\n    t = t*2.0 - 1.0;\n    vec3 p1 = vec3(c + w*vec2(s,t), 0.0);\n    vec3 p0 = vec3(p1.xy * 0.0, -1.0);\n    ro = p0;\n    rd = p1 - p0;\n}\n\n// return the quadratic that fits y values at f(0), f(0.5) and f(1)\nvec3 quadratic_from_points(float y0, float y1, float y2) {\n    float a = 2.0*y0 - 4.0*y1 + 2.0*y2;\n    float b = -3.0*y0 + 4.0*y1 - y2;\n    float c = y0;\n    return vec3(c, b, a);\n}\n\n// this one fits f(-1), f(0) and f(1)\nvec3 quadratic_from_points_c(float y0, float y1, float y2) {\n\tfloat A = (y2 + y0)/2.0 - y1;\n\tfloat B = (y2 - y0)/2.0;\n\tfloat C = y1;\n    return vec3(C, B, A);\n}\n\nvec3 quadratic_from_points(vec2 p1, vec2 p2, vec2 p3) {\n\tfloat d = (p1.x - p2.x)*(p1.x - p3.x)*(p2.x - p3.x);\n\tfloat a = p3.x * (p2.y - p1.y) + p2.x * (p1.y - p3.y) + p1.x * (p3.y - p2.y);\n\tfloat b = p3.x*p3.x * (p1.y - p2.y) + p2.x*p2.x * (p3.y - p1.y) + p1.x*p1.x * (p2.y - p3.y);\n\tfloat c = p2.x * p3.x * (p2.x - p3.x) * p1.y + p3.x * p1.x * (p3.x - p1.x) * p2.y + p1.x * p2.x * (p1.x - p2.x) * p3.y;\n    return vec3(c, b, a) / d;\n}\n\nstruct poly2x2 {\n    vec3 abc;\n    vec3 def;\n};\n// compute the six coefficients of a bivariate quadratic\n// f(x,y) = A*x^2 + B*y^2 + C*x + D*y + E*x*y + F\n// so that the surface goes through the points\n// f(0,0) = Q\n// f(0,1) = R\n// f(1,0) = S\n// f(1,1) = T\n// f(0.5,0) = U\n// f(0,0.5) = V\npoly2x2 bivariate_quadratic_from_points(\n    float Q, float R, float S, float T, float U, float V) {\n    float A = 2.0*Q - 4.0*U + 2.0*S;\n    float B = 2.0*Q - 4.0*V + 2.0*R;\n    float C = -3.0*Q + 4.0*U - S;\n    float D = -3.0*Q + 4.0*V - R;\n    float E = Q + T - S - R;\n    float F = Q;\n    return poly2x2(vec3(A,B,C),vec3(D,E,F));\n}\n\n// same but for the points\n// f( 0, 0) = Q\n// f(-1, 0) = R\n// f( 1, 0) = S\n// f( 0,-1) = T\n// f( 0, 1) = U\n// f( 1, 1) = V\npoly2x2 bivariate_quadratic_from_points_c(\n    float Q, float R, float S, float T, float U, float V) {\n    float A = (S + R)/2.0 - Q;\n    float B = (U + T)/2.0 - Q;\n    float C = (S - R)/2.0;\n    float D = (U - T)/2.0;\n    float E = Q + V - S - U;\n    float F = Q;\n    return poly2x2(vec3(A,B,C),vec3(D,E,F));\n}\n\nfloat pa_f(poly2x2 p, float x, float y) {\n    return dot(p.abc,vec3(x*x,y*y,x)) + dot(p.def,vec3(y,x*y,1.0));\n}\n// first partial derivatives\nvec2 pa_ff(poly2x2 p, float x, float y) {\n    float A = p.abc[0];\n    float B = p.abc[1];\n    float C = p.abc[2];\n    float D = p.def[0];\n    float E = p.def[1];\n    return vec2(2.0*A*x + C + E*y, 2.0*B*y + D + E*x);\n}\n// second partial derivatives\nvec2 pa_fff(poly2x2 p, float x, float y) {\n    float A = p.abc[0];\n    float B = p.abc[1];\n    return vec2(2.0*A, 2.0*B);\n}\n\nstruct poly2x3 {\n    vec4 abcd;\n    vec4 efgh;\n    vec2 ij;\n};\n\n// compute the ten coefficients of a trivariate quadratic\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + D*x + E*y + F*z + G*x*y + H*x*z + I*y*z + J\n// so that the surface goes through the points\n// f( 0, 0, 0) = N\n// f(-1, 0, 0) = O\n// f( 1, 0, 0) = P\n// f( 0,-1, 0) = Q\n// f( 0, 1, 0) = R\n// f( 0, 0,-1) = S\n// f( 0, 0, 1) = T\n// f( 1, 1, 0) = U\n// f( 1, 0, 1) = V\n// f( 0, 1, 1) = W\npoly2x3 trivariate_quadratic_from_points_c(\n    float N, float O, float P, float Q, float R,\n    float S, float T, float U, float V, float W) {\n    float A = (P + O)/2.0 - N;\n    float B = (R + Q)/2.0 - N;\n    float C = (T + S)/2.0 - N;\n    float D = (P - O)/2.0;\n    float E = (R - Q)/2.0;\n    float F = (T - S)/2.0;\n    float G = U + N - P - R;\n    float H = V + N - P - T;\n    float I = W + N - R - T;\n    float J = N;\n    return poly2x3(vec4(A,B,C,D),vec4(E,F,G,H),vec2(I,J));\n}\nfloat pa_f(poly2x3 p, float x, float y, float z) {\n    return dot(p.abcd,vec4(x*x,y*y,z*z,x))\n        + dot(p.efgh,vec4(y,z,x*y,x*z))\n        + dot(p.ij,vec2(y*z,1.0));\n}\nstruct interval {\n    float i0;\n    float i1;\n};\n\ninterval inew(vec3 a, vec3 b) {\n    if (a.x < b.x)\n        return interval(a.x, b.x);\n    else\n        return interval(b.x, a.x);\n}\ninterval iunion(interval a, vec3 b) {\n    if (b.x < a.i0) {\n        return interval(b.x, a.i1);\n\t} else if (b.x >= a.i1) {\n        return interval(a.i0, b.x);\n    } else {\n        return a;\n    }\n}\ninterval iunion(interval a, interval b) {\n    return iunion(iunion(a, vec3(b.i0,0.0,0.0)),vec3(b.i1,0.0,0.0));\n}\n\n// for a univariate quadratic f(x), return the min/max bounds\n// within the range x=0..1\ninterval quadratic_bounds(vec3 p) {\n    float A = p[2];\n    float B = p[1];\n    float C = p[0];\n\tvec3 c0 = pa_f(p, 0.0);\n    vec3 c1 = pa_f(p, 1.0);\n    interval iv = inew(c0, c1);\n    if (abs(A) < 1e-8) {\n        return iv;\n    }\n    float x = -B / (2.0*A);\n    if (abs(x - 0.5) <= 0.5) {\n\t    vec3 h = pa_f(p, x);\n        iv = iunion(iv, h);\n\t}\n    return iv;\n}\n\n// for a bivariate quadratic f(x,y), return the min/max bounds\n// within the range x=0..1, y=0..1\ninterval bivariate_quadratic_bounds(poly2x2 p) {\n\tfloat c0 = pa_f(p, 0.0, 0.0);\n    float c1 = pa_f(p, 0.0, 1.0);\n    float c2 = pa_f(p, 1.0, 0.0);\n    float c3 = pa_f(p, 1.0, 1.0);\n    float c4 = pa_f(p, 0.5, 0.0);\n    float c5 = pa_f(p, 0.5, 1.0);\n    float c6 = pa_f(p, 0.0, 0.5);\n    float c7 = pa_f(p, 1.0, 0.5);\n    // check borders\n    interval b0 = quadratic_bounds(quadratic_from_points(c0,c4,c2));\n    interval b1 = quadratic_bounds(quadratic_from_points(c1,c5,c3));\n    interval b2 = quadratic_bounds(quadratic_from_points(c0,c6,c1));\n    interval b3 = quadratic_bounds(quadratic_from_points(c2,c7,c3));\n    interval iv = iunion(iunion(b0,b1),iunion(b2,b3));\n    float A = p.abc[0];\n    float B = p.abc[1];\n    float C = p.abc[2];\n    float D = p.def[0];\n    float E = p.def[1];\n    float F = p.def[2];\n    float det = 4.0*A*B - E*E;\n    float dx = 2.0*B*C - D*E;\n    float dy = 2.0*A*D - C*E;\n\tif (abs(det) < 1e-8) {\n        if (max(abs(dx),abs(dy)) < 1e-8) {\n\t        // parabolic cylinder\n            // A > 0: minimum; A < 0: maximum\n            // todo\n            // return vec2(0.0);\n        } else {\n\t        // parabolic cylinder\n            // no apex\n        }\n        //return vec2(0.0);\n    } else if (det > 0.0) {\n        // graph is an elliptic paraboloid\n        // A > 0: minimum; A < 0: maximum\n        float xm = -dx / det;\n        float ym = -dy / det;\n        if (max(abs(xm - 0.5),abs(ym - 0.5)) <= 0.5) {\n\t        float h = pa_f(p, xm, ym);\n            iv = iunion(iv, vec3(h,0.0,0.0));\n        }\n    } else { // (det < 0.0)\n        // no apex; graph is a hyperbolic paraboloid\n    }\n    return iv;\n}\n\ninterval bound_slice(float t) {\n\tprepare_ray(0.0,0.0);\n    poly2 f00 = pa_map(ro, rd, 0.0);\n\tprepare_ray(0.0,1.0);\n    poly2 f02 = pa_map(ro, rd, 0.0);\n\tprepare_ray(1.0,0.0);\n    poly2 f20 = pa_map(ro, rd, 0.0);\n\tprepare_ray(1.0,1.0);\n    poly2 f22 = pa_map(ro, rd, 0.0);\n\tprepare_ray(0.5,0.0);\n    poly2 f10 = pa_map(ro, rd, 0.0);\n\tprepare_ray(0.0,0.5);\n    poly2 f01 = pa_map(ro, rd, 0.0);\n\n    vec3 e00 = pa_f(f00.a, t);\n    vec3 e02 = pa_f(f02.a, t);\n    vec3 e20 = pa_f(f20.a, t);\n    vec3 e22 = pa_f(f22.a, t);\n    vec3 e10 = pa_f(f10.a, t);\n    vec3 e01 = pa_f(f01.a, t);\n\n    poly2x2 f = bivariate_quadratic_from_points(e00.x, e02.x, e20.x, e22.x, e10.x, e01.x);\n\n    return bivariate_quadratic_bounds(f);\n}\n\nconst float coeff_scale = 0.025;\nfloat rayf(float t) {\n#if 1\n    poly2 f = pa_map(ro, rd, t);\n    return f.a[0]*coeff_scale;\n#elif 0\n    prepare_ray(t, 0.5);\n    poly2 f = pa_map(ro, rd, 0.0);\n    return f.a[2]*coeff_scale;\n#else\n    poly2 f = pa_map(ro, rd, 0.0);\n    return pa_f(f.a, t).x*coeff_scale;\n#endif\n}\n\nfloat fieldf(vec2 p) {\n\tprepare_ray(p.x, p.y);\n    poly2 f = pa_map(ro, rd, 0.0);\n    float t = solve_quadratic0(f.a);\n    return max(t,0.0);\n}\n\nfloat coeff_ray_t;\nfloat coeff_f(float t) {\n    prepare_ray(0.0, t);\n    poly2 f = pa_map(ro, rd, coeff_ray_t);\n    return f.a[1]*coeff_scale;\n}\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1);\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1);\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r);\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r);\nvoid set_source(sampler2D image);\n// control how source changes are applied\nconst int Replace = 0; // default: replace the new source with the old one\nconst int Alpha = 1; // alpha-blend the new source on top of the old one\nconst int Multiply = 2; // multiply the new source with the old one\nvoid set_source_blend_mode(int mode);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add an ellipse path at P with radii RW and RH\nvoid ellipse(vec2 p, vec2 r);\nvoid ellipse(float x, float y, float rw, float rh);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n// add a rectangle at O with size S and rounded corner of radius R\nvoid rounded_rectangle(vec2 o, vec2 s, float r);\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// non-uniformly scale the context by S\nvoid scale(vec2 s);\nvoid scale(float sx, float sy);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    vec2 clip;\n    vec2 scale;\n    float line_width;\n    bool premultiply;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n    int source_blend;\n    bool has_clip;\n};\n\n// save current stroke width, starting\n// point and blend mode from active context.\nContext save();\n// restore stroke width, starting point\n// and blend mode to a context previously returned by save()\nvoid restore(Context ctx);\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\nvoid debug_clip_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\n// your draw calls here\n//////////////////////////////////////////////////////////\n\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec3 C;\nfloat testf(float x) {\n    return (C[0] + C[1]*x + C[2]*x*x)*coeff_scale;\n}\n\nconst float CR = 0.012;\nvoid paint_zenith(poly2 g0, float x) {\n    set_source_rgb(1.0,0.5,0.0);\n    float g0x = -g0.a[1] / (2.0*g0.a[2]);\n    float g0y = pa_f(g0.a, g0x).x;\n    if (g0x >= 0.0 && g0x < 1.0)\n        circle(x,g0y*coeff_scale,CR);\n    float t0 = pa_f(g0.a, 0.0).x;\n    float t1 = pa_f(g0.a, 1.0).x;\n    circle(x,t0*coeff_scale,CR);\n    circle(x,t1*coeff_scale,CR);\n    fill();\n}\n\n#define NUM_STEPS_H 16\n#define NUM_STEPS_V 16\nvoid paint() {\n    setup();\n    set_source_rgb(vec3(1.0));\n    clear();\n    translate(-0.5,-0.8);\n\n#if 1\n    float d = fieldf(get_origin());\n    float q = clamp(log2(abs(d))/8.0,0.0,1.0);\n    //set_source_rgb(hsl(d,mix(1.0,0.0,q),mix(0.5,1.0,q)*mix(0.7,1.0,sign(d)*0.5+0.5)  ));\n    set_source_rgb(hsl(d,1.0,mix(0.3,0.5,float(d > 0.0))));\n    graph2D(fieldf);\n    clear();\n    set_line_width_px(1.0);\n    set_source_rgba(0.0,0.0,0.0,1.0);\n\tstroke();\n\n    set_line_width_px(1.0);\n    set_source_rgba(0.0,0.0,0.0,1.0);\n\trectangle(0.0,0.0,1.0,1.0);\n\tstroke();\n#endif\n#if 1\n    set_line_width_px(1.0);\n    set_source_rgba(0.0,0.0,0.0,1.0);\n    vec2 st = 1.0/vec2(NUM_STEPS_V, NUM_STEPS_H);\n    for (int k = 0; k < NUM_STEPS_V; ++k) {\n        for (int i = 0; i < NUM_STEPS_H; ++i) {\n\t        float s = float(k) * st.x;\n            float t = float(i) * st.y;\n\t\t\tvec2 h = hash22(get_origin() + vec2(s,t) + mod(iTime,1.0)) * st;\n            prepare_ray(s + h.x,t + h.y);\n            graph1D(rayf);\n            stroke();\n        }\n    }\n#endif\n\n#if 1\n\n    set_line_width_px(1.3);\n    \n    float t = get_origin().x;\n    float tk = 1.0/32.0;\n    t -= mod(t - 0.5*tk, tk);\n    t += 0.5*tk;\n    float dt = 1.0 / 32.0;\n    interval q0 = bound_slice(t);\n    interval q1 = bound_slice(t + dt);\n    interval q2 = bound_slice(t - dt);\n\n    #if 0\n    float d0 = (q1.i0 - q2.i0) / (2.0 * dt);\n    float d1 = (q1.i1 - q2.i1) / (2.0 * dt);\n    float fa0 = (q0.i0 - q2.i0) / dt;\n    float fa1 = (q0.i1 - q2.i1) / dt;\n    float fb0 = (q1.i0 - q0.i0) / dt;\n    float fb1 = (q1.i1 - q0.i1) / dt;\n    float f0 = (fb0 - fa0) / (2.0*dt);\n    float f1 = (fb1 - fa1) / (2.0*dt);\n    set_source_rgb(vec3(0.0,0.5,1.0));\n    float ddt = 0.05;\n    move_to(t - ddt, q0.i0*coeff_scale - d0*coeff_scale*ddt);\n    line_to(t + ddt, q0.i0*coeff_scale + d0*coeff_scale*ddt);\n    stroke();\n    move_to(t - ddt, q0.i1*coeff_scale - d1*coeff_scale*ddt);\n    line_to(t + ddt, q0.i1*coeff_scale + d1*coeff_scale*ddt);\n    stroke();\n    set_source_rgb(vec3(1.0,0.0,0.0));\n    if ((i > 0) && (d0 < 0.0)) {\n        float z = solve_quadratic0(vec3(q0.i0, d0, f0));\n        if (z != z) {\n            z = -(2.0*q0.i0) / d0;\n        }\n        move_to(t, q0.i0*coeff_scale);\n        line_to(t + z, 0.0);\n        stroke();\n        circle(t + z, 0.0, CR);\n        fill();\n    }\n    #endif\n    if ((q0.i0 >= 0.0) && (q0.i1 > 0.0))\n        set_source_rgb(vec3(0.0,0.5,1.0));\n    else if ((q0.i0 < 0.0) && (q0.i1 <= 0.0))\n        set_source_rgb(vec3(0.0,1.0,0.5));\n        else\n            set_source_rgb(vec3(1.0,0.5,0.0));\n        circle(t, q0.i0*coeff_scale, CR);\n    circle(t, q0.i1*coeff_scale, CR);\n    fill();\n    move_to(t, q0.i0*coeff_scale);\n    line_to(t, q0.i1*coeff_scale);\n    stroke();\n    \n    set_line_width_px(1.0);\n#endif\n\n#if 0\n    set_source_rgba(0.0,0.0,0.0,0.3);\n    move_to(0.0,0.0);\n    line_to(1.0,0.0);\n    move_to(0.0,-1.0);\n    line_to(0.0,1.0);\n    move_to(0.25,-1.0);\n    line_to(0.25,1.0);\n    move_to(0.5,-1.0);\n    line_to(0.5,1.0);\n    move_to(0.75,-1.0);\n    line_to(0.75,1.0);\n    move_to(1.0,-1.0);\n    line_to(1.0,1.0);\n    stroke();\n#endif\n}\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\nfloat AA;\nfloat AAINV;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n#define DEFAULT_CLIP_V -1e+20\n\nContext _stack;\n\nvoid init (vec2 fragCoord) {\n    uv = fragCoord.xy / iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n\n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        vec2(DEFAULT_CLIP_V),\n        vec2(1.0),\n        1.0,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0),\n        Replace,\n        false\n    );\n}\n\nvec3 _color = vec3(1.0);\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n    _stack.clip.y = DEFAULT_CLIP_V;\n}\n\nContext save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;\n    vec2 clip = _stack.clip;\n    bool has_clip = _stack.has_clip;\n    // preserve source\n    vec4 source = _stack.source;\n    _stack = ctx;\n    _stack.shape = shape;\n    _stack.clip = clip;\n    _stack.source = source;\n    _stack.has_clip = has_clip;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = vec2(1.0);\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;\n    _stack.scale = vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    _stack.scale *= vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(vec2 s) {\n    transform(mat3(s.x,0.0,0.0,0.0,s.y,0.0,0.0,0.0,1.0));\n}\n\nvoid scale(float sx, float sy) {\n    scale(vec2(sx, sy));\n}\n\nvoid scale(float s) {\n    scale(vec2(s));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color = mix(_color, _stack.source.rgb, _stack.source.a);\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(_color, 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = _color;\n}\n\nvoid add_clip(vec2 d) {\n    d = d / _stack.scale;\n    _stack.clip = max(_stack.clip, d);\n    _stack.has_clip = true;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);\n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n    _stack.clip = vec2(DEFAULT_CLIP_V);\n    _stack.has_clip = false;\n}\n\nvoid debug_gradient() {\n    vec2 d = _stack.shape;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid debug_clip_gradient() {\n    vec2 d = _stack.clip;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color = _color * (1.0 - src_a) + rgba.rgb * dst_a;\n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat min_uniform_scale() {\n    return min(_stack.scale.x, _stack.scale.y);\n}\n\nfloat uniform_scale_for_aa() {\n    return min(1.0, _stack.scale.x / _stack.scale.y);\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA*uniform_scale_for_aa(), 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);\n\treturn wa * wb;\n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n    if (_stack.has_clip) {\n\t    write_color(_stack.source, calc_aa_blur(_stack.clip.x));\n    }\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*min_uniform_scale() * AAINV;\n}\n\nfloat get_gradient_eps() {\n    return (1.0 / min_uniform_scale()) * AAINV;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    if (_stack.source_blend == Multiply) {\n        _stack.source *= c;\n    } else if (_stack.source_blend == Alpha) {\n    \tfloat src_a = c.a;\n    \tfloat dst_a = _stack.premultiply?1.0:src_a;\n\t    _stack.source =\n            vec4(_stack.source.rgb * (1.0 - src_a) + c.rgb * dst_a,\n                 max(_stack.source.a, c.a));\n    } else {\n    \t_stack.source = c;\n    }\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) {\n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1) {\n    vec2 pa = _stack.position.xy - p0;\n    vec2 ba = p1 - p0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1) {\n    set_source_linear_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p0, p1);\n}\n\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r) {\n    float h = clamp( length(_stack.position.xy - p) / r, 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r) {\n    set_source_radial_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p, r);\n}\n\nvoid set_source_blend_mode(int mode) {\n    _stack.source_blend = mode;\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid rounded_rectangle(vec2 o, vec2 s, float r) {\n    s = (s * 0.5);\n    r = min(r, min(s.x, s.y));\n    o += s;\n    s -= r;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    vec2 df = max(dmin.xz, dmin.yw) + length2(dmax);\n    add_field(df - r);\n}\n\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), r);\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    rounded_rectangle(o, s, 0.0);\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), 0.0);\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\n// from https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n    if (l == 0.0) {\n        return length(p) - ab.x;\n    }\n\n    float m = ab.x*p.x/l;\n\tfloat n = ab.y*p.y/l;\n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\n    float c = (m2 + n2 - 1.0)/3.0;\n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n\n    vec2 r = vec2( ab.x*co, ab.y*si );\n\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nvoid ellipse(vec2 p, vec2 r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(sdEllipse(c.xy, r), sdEllipse(c.zw, r)));\n}\n\nvoid ellipse(float x, float y, float rw, float rh) {\n    ellipse(vec2(x,y), vec2(rw, rh));\n}\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 s = sign(pa.xz*ba.y-pa.yw*ba.x);\n    vec2 d = length2(pa - ba.xyxy*h.xxyy);\n    add_field(d);\n    add_clip(d * s);\n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat test_cross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat bezier_sign(vec2 A, vec2 B, vec2 C, vec2 p) {\n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0,\n        step(test_cross(A, B, p) * test_cross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * test_cross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    vec2 shape = vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw));\n    add_field(abs(shape));\n    add_clip(shape);\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(abs(f_x) / length(df_x));\n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t aspect = vec2(iResolution.x / iResolution.y, 1.0);\n\t ScreenH = min(iResolution.x,iResolution.y);\n\t AA = ScreenH*0.4;\n\t AAINV = 1.0 / AA;\n\n    init(fragCoord);\n\n    paint();\n\n    blit(fragColor);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtXcWB.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1286, 1540, 1563, 1563, 1595], [1597, 1597, 1621, 1621, 1667], [1669, 1669, 1705, 1705, 1937], [1939, 1939, 1971, 1971, 2018], [2019, 2019, 2051, 2051, 2107], [2108, 2108, 2140, 2140, 2196], [2197, 2197, 2229, 2229, 2276], [2277, 2277, 2309, 2309, 2365], [2366, 2366, 2398, 2398, 2456], [2457, 2457, 2480, 2480, 2510], [2512, 2720, 2752, 2752, 2987], [2988, 2988, 3020, 3020, 3053], [3054, 3054, 3086, 3086, 3119], [3121, 3225, 3249, 3249, 3448], [3450, 3481, 3509, 3509, 3647], [3649, 3649, 3690, 3690, 4124], [4126, 4126, 4159, 4159, 4552], [4554, 4554, 4586, 4586, 4932], [4934, 4934, 4966, 4966, 5002], [5004, 5063, 5088, 5088, 5121], [5123, 5196, 5222, 5222, 5337], [5339, 5339, 5360, 5360, 5387], [5389, 5389, 5413, 5413, 5453], [5455, 5640, 5665, 5665, 5710], [5712, 5712, 5735, 5735, 5816], [5818, 5818, 5843, 5843, 5890], [5892, 5892, 5923, 5923, 6038], [6040, 6040, 6080, 6080, 6274], [6276, 6276, 6308, 6308, 6429], [6431, 6431, 6463, 6463, 6585], [6587, 6682, 6718, 6718, 7369], [7371, 7466, 7502, 7502, 7556], [7558, 7663, 7705, 7705, 7965], [7967, 7967, 8009, 8009, 8062], [8064, 8136, 8179, 8179, 8735], [8756, 8756, 8806, 8806, 8882], [8884, 8884, 8936, 8936, 9120], [9122, 9122, 9182, 9202, 9507], [9509, 9509, 9557, 9557, 9742], [9744, 9744, 9792, 9792, 10019], [10021, 10230, 10298, 10298, 10428], [10447, 10447, 10488, 10488, 11536], [11538, 11538, 11579, 11579, 11772], [11774, 11929, 11966, 11966, 12048], [12050, 12050, 12064, 12064, 12087], [12089, 12089, 12109, 12109, 12161], [12163, 12163, 12199, 12214, 12482], [12484, 12552, 12610, 12610, 12733], [12735, 12773, 12833, 12833, 12933], [12935, 12935, 12990, 12990, 13370], [13420, 13662, 13762, 13762, 13997], [13999, 14122, 14224, 14224, 14433], [14435, 14435, 14476, 14476, 14546], [14547, 14576, 14617, 14617, 14794], [14795, 14825, 14867, 14867, 14948], [15014, 15391, 15534, 15534, 15873], [15874, 15874, 15924, 15924, 16044], [16095, 16095, 16126, 16126, 16226], [16227, 16227, 16264, 16264, 16424], [16425, 16425, 16466, 16466, 16537], [16539, 16628, 16663, 16663, 16991], [16993, 17091, 17139, 17139, 18725], [18727, 18727, 18758, 18758, 19442], [19477, 19477, 19498, 19498, 19756], [19758, 19758, 19780, 19780, 19901], [19922, 19922, 19946, 19946, 20047], [25924, 25944, 25965, 25965, 26084], [26094, 26094, 26116, 26116, 26169], [26195, 26195, 26233, 26233, 26562], [26610, 26610, 26624, 26624, 29731], [29908, 29968, 29995, 29995, 30021], [30023, 30083, 30104, 30104, 30211], [30213, 30213, 30250, 30250, 30336], [30338, 30338, 30384, 30384, 30417], [30419, 30557, 30585, 30585, 31045], [31073, 31073, 31092, 31092, 31125], [31127, 31127, 31145, 31145, 31178], [31180, 31180, 31204, 31204, 31308], [31310, 31310, 31326, 31326, 31347], [31349, 31349, 31376, 31398, 31681], [31683, 31683, 31711, 31711, 31945], [31947, 31947, 31971, 31971, 32057], [32059, 32059, 32086, 32086, 32299], [32301, 32301, 32327, 32327, 32555], [32557, 32557, 32579, 32579, 32705], [32707, 32707, 32727, 32727, 32787], [32789, 32789, 32821, 32821, 32848], [32850, 32850, 32871, 32871, 32893], [32895, 32895, 32919, 32919, 32979], [32981, 32981, 33015, 33015, 33039], [33041, 33041, 33055, 33055, 33119], [33121, 33121, 33147, 33147, 33179], [33181, 33181, 33207, 33207, 33228], [33230, 33230, 33253, 33253, 33348], [33350, 33350, 33374, 33374, 33443], [33445, 33445, 33470, 33470, 33517], [33519, 33519, 33536, 33536, 33649], [33651, 33651, 33674, 33674, 33803], [33805, 33805, 33833, 33833, 33961], [33963, 33963, 33987, 33987, 34127], [34129, 34129, 34167, 34167, 34301], [34303, 34303, 34340, 34340, 34375], [34377, 34377, 34404, 34404, 34454], [34456, 34456, 34486, 34486, 34542], [34544, 34544, 34573, 34573, 34754], [34756, 34756, 34778, 34778, 34937], [34939, 34939, 34952, 34952, 34991], [34993, 34993, 35023, 35023, 35052], [35054, 35054, 35087, 35087, 35144], [35146, 35146, 35172, 35172, 35222], [35224, 35224, 35245, 35245, 35310], [35312, 35312, 35336, 35336, 35419], [35421, 35421, 35436, 35436, 35477], [35479, 35479, 35495, 35495, 35533], [35535, 35535, 35553, 35553, 35610], [35612, 35612, 35642, 35642, 36012], [36014, 36014, 36072, 36072, 36110], [36112, 36112, 36141, 36141, 36177], [36179, 36179, 36227, 36227, 36258], [36260, 36260, 36294, 36294, 36353], [36355, 36355, 36432, 36432, 36597], [36599, 36599, 36676, 36676, 36756], [36758, 36758, 36834, 36834, 36950], [36952, 36952, 37028, 37028, 37106], [37108, 37108, 37146, 37146, 37180], [37182, 37182, 37204, 37204, 37250], [37252, 37252, 37279, 37279, 37323], [37325, 37325, 37374, 37374, 37635], [37637, 37637, 37710, 37710, 37764], [37766, 37766, 37798, 37798, 37834], [37836, 37836, 37892, 37892, 37948], [37950, 37950, 37980, 37980, 38073], [38074, 38074, 38114, 38114, 38137], [38139, 38185, 38224, 38224, 39372], [39374, 39374, 39404, 39404, 39506], [39508, 39508, 39560, 39560, 39600], [39602, 39602, 39624, 39624, 39675], [39677, 39677, 39709, 39709, 39731], [39733, 39748, 39770, 39770, 40062], [40064, 40064, 40096, 40096, 40118], [40120, 40120, 40139, 40139, 40171], [40220, 40283, 40325, 40325, 40391], [40393, 40463, 40514, 40514, 40866], [40868, 40902, 40948, 40948, 41460], [41462, 41531, 41577, 41577, 42083], [42085, 42085, 42118, 42118, 42334], [42336, 42336, 42395, 42395, 42440], [42442, 42442, 42485, 42485, 42546], [42548, 42548, 42590, 42590, 42632], [42634, 42694, 42751, 42751, 42950]]}
{"id": "MtXczn", "name": "HAL 4000", "author": "Manwe", "description": "4kb intro by the SandS.\n3rd place at Chaos Constructions 2017 demoparty.\nDownload exe, sources, youtube, etc.: http://www.pouet.net/prod.php?which=71630", "tags": ["wireframe", "landscape"], "likes": 29, "viewed": 4697, "date": "1506023268", "time_retrieved": "2024-06-20T19:01:45.457478", "image_code": "// HAL 4 kb intro by the SandS\n\nprecision highp float;\n\n#define t (mod(iTime,108.))\n\nfloat torus(vec3 o, float k)\n{\n    o.z -= 4.5; // pivot point\n    vec3 r = vec3(t/2.3, t/1.95, t/2.7), s = sin(r), c = cos(r); // rotate over axis x,y,z\n    o *= mat3( // rotation\n         c.y,     s.z*s.y,            -s.y*c.z,\n        -s.x*s.y, c.x*c.z+s.x*s.z*c.y, s.z*c.x-s.x*c.z*c.y,\n         c.x*s.y, s.x*c.z-c.x*s.z*c.y, s.z*s.x+c.x*c.z*c.y\n    );\n    float s1=clamp((t-33.)/14.,0.,1.); // morph to sphere on 0:33\n    k = mix(k,0.,s1*s1*s1);\n    float n = 8.-6.*k, l = 3.8*k-2.;\n    n = mix(n,2.,s1*s1*s1);\n    o = abs(o);\n    return pow(pow(o.x,n)+pow(o.y,n)+pow(o.z,n)+l,2.)-k*8.*(o.x*o.x + o.y*o.y);\n}\n\nfloat shape(vec3 o)\n{\n    return sin(o.x*5.)/15. + cos(o.x+1.5)/3. + sin(o.z+t)/5. - cos(o.x+2.)*cos(o.z+t)/3.;\n}\n\nfloat rt(vec3 o)\n{\n    return length(o-vec3(o.x,shape(o) - 1.5,o.z));\n}\n\nfloat s(float a, float z) // move star field\n{\n    return ( a-a*z+1. ) * 991.;\n}\n\nfloat wire(float dist) // convert distance to color\n{\n    return pow(1. - min(1.,abs(dist)),4.);\n}\n\nvoid mainImage(out vec4 outcolor, vec2 coordVar)\n{    \n    coordVar /= iResolution.xy;\n    float aspect = 16. / 9.;\n    vec2 uv = (coordVar - vec2(.5)) / vec2(1., aspect) *1.4;\n\n    float cf=0., ct=0., cm=0., cl=0., cs = 0., pi = 3.1416; // init colors: field, torus, torus, light, stars\n    float l = 1., d, e = .0001, m1, m2, r = 0., size, n, z; // ray length, current distance, epsilon\n    vec3 xyz, c = vec3(0.,0.,0.), norm = c, light = vec3(0.,1.,12.+max(0.,(t-47.)/8.)); // 3d-coordinates, final color, normal, light position\n\nif (t<62.) // Scene 1 from 0:00 to 1:02\n{\n// morphing\n    float kf = clamp(t/4.-5.,0.,1.); // plane -> landscape on 0:20\n    float kt = cos((t)/3.1)/2.5+.4; // cube -> toruns, from 0 to 1\n    float s1 = t - 22., td = 1.+max(s1*s1*s1/999.,0.)/9.; // torus distance\n    n = min(t*t*t/451.,17.7)+.3; // number of torus slices\n    n = mix(n,3.,clamp((t-42.)/5.,0.,1.));\n\n// draw field\n    z=30.-fract(t);\n    for (int i=30; i>0; i--) // z-slices from far to near\n    {\n        xyz = vec3(uv*(1.+z),z); // form 3D coordinates from screen coordinates and z\n        cf = max(cf, pow(wire( -xyz.y-1.5 + kf*shape(xyz+vec3(0.,0.,1.)) ),7.)*-uv.y*2.6); // draw field slice\n        z--;\n    };\n\n// draw torus\n// using SandS' super original proprietary rendering technic, let's call it \"Z-sliced space\" :)\n    z = 4.5 + 2.*(n-1.)/(n+1.); // start z\n    for (int i=18; i>0; i--) // z-slices from far to near\n    {\n        xyz = vec3(uv*(2.+z)*td,z); // form 3D coordinates from screen coordinates and z\n        cm = max(cm, float(torus(xyz,kt)<.1)); // draw torus mask\n        ct = max(ct, wire(torus(xyz,kt))/(z-2.6)); // draw torus slice\n        z -= 4./(n+1.); // density of render, smaller is better\n    };\n\n    cm = 1.-cm; // torus mask\n\n    if (t>46.)\n    {\n    // raymarching\n        xyz = normalize(vec3(uv, 1.)); // view direction\n\n        for (int i=0; i<40; i++)\n        {\n            d = rt(xyz*l);\n            if (d<.001) break;\n            l += d;\n            if (l>40.) break;\n        }\n        if (l<40.)\n        {\n            xyz *= l; // actual point\n            norm = normalize(vec3(\n            rt(xyz+vec3(e,0.,0.)) - rt(xyz-vec3(e,0.,0.)),\n            rt(xyz+vec3(0.,e,0.)) - rt(xyz-vec3(0.,e,0.)),\n            rt(xyz+vec3(0.,0.,e)) - rt(xyz-vec3(0.,0.,e))));\n            cl = cm*pow((length(norm+normalize(light-xyz))-1.1)*max(1.2-length(light-xyz)/15.,0.),4.);\n        }\n    }\n\n// draw stars\n    e = 2371.;\n\n    for(int i=0; i<40; i++)\n    {\n        n = t/15.;\n        if (t>=47.1)\n        {\n            n = 47.1/15. + (t-47.1)/20.;\n        }\n        z = fract(n+r); // n = slow time\n        m2 = s(uv.y,z);\n        if(m2 > 935.) // if higher than field\n        {\n            m1 = s(uv.x,z);\n            d = fract( sin( pow(floor(m1), floor(m2)/941.) ) * e );\n            if(d > .9985)\n            {\n                d = distance(vec2(m1,m2),vec2(floor(m1)+.5,floor(m2)+.5))*2.;\n                cs = max ( cs, z * min(1.,pow(1.5-d,15.)) );\n                cs = max ( cs, z * max(0.,1.-d) );\n            }\n        }\n        e-=.9;\n        r += .05;\n    }\n\n    cf *= cm; // apply torus mask to the field\n    cs *= cm; // apply torus mask to stars\n\n    cf *= clamp(t/4.-2.5,0.,1.); // fade in field on 0:10\n    cs *= clamp(t-31.,0.,1.); // fade in stars on 0:31\n\n    cl += cm*max(2.-l/20.,0.)*max(norm.z,0.); // add z-normals to the field light\n\n    cl *= pow(clamp(t*2.-93.2,0.,1.),3.); // fade in the field light at 0:46.6 - 0:47.1\n\n    c = vec3(cs/2., cs*cs, sqrt(cs)) +    // mix stars\n        vec3(0., cl*cl, cl) +    // mix lights\n        vec3(0., ct*ct, ct) +    // mix torus\n        vec3(cf*cf/2., 0., cf);  // mix field\n\n    c *= min(1.,t/4.); // global fade in\n\n    d = 2.-clamp(t/4.-12.75,0.,2.); // run big circle at 0:51\n    cf = smoothstep(1.,0.,abs(d-length(uv))) ; // global fade out\n    c += vec3(0., cf*cf, cf);    // mix big circle\n\n    d = 2.-clamp(t/4.-13.5,0.,2.2); // global fadeout at 54:00\n    cf = smoothstep(d-.1,d+.1,length(uv)) ;\n    c *= 1. - cf;\n} // endif t < 1:02\n\n\n\nelse // Scene 2 from 1:02\n{\n\nif (t<104.)\n{\n    m1 = min(t,85.)-62.; // stop move at 1:25\n    size = 31. - m1; // HAL size\n\n    z = fract(cos(m1*3.9)+sin(m1)*cos(m1*3.7)) ;// random blinking\n    if (t<65.) z = 3.-m1;\n\n    r = length(uv) * size;\n    cf = max(0.,.7-min(1.,r)); // red\n    ct = pow( r/99.*float(r<.6) , .4)    +    (.8-r)*float(r<.02); // blue\n    cm = min(1.,pow(max(0.,1.25-r),8.))/(10.-z*3.)    +    (z*.8+.3)*min(.7,pow(max(0.,.15-r)*9.,12.)); // yellow;\n\n    n = uv.y*size; // gradient\n\n// add plasma to red\n    m2 =\n    .3+.6*cos(cos(9.*(uv.x-.4)*pi + t/3.) + 9.*uv.y + t/7.) -\n    .6+.6*cos(cos(9.*uv.y*pi + t/5.) + 9.*(uv.x-.4) - t/9.);\n    cf += clamp(m2, 0., 1.)/3. * smoothstep(.1, 0., r-.4); // plasma * mask\n// end plasma\n    cf = mix(cf, floor(cf*16.)/16., max(0.,0.-n)); // discret red\n\n\n    xyz = vec3(cf+cm,cm,ct); // HAL 9000\n\n\tcf = atan(abs(uv.x),uv.y);\n    cm = clamp(pow(1.3-abs(cf),7.), 0.,1.); // mask\n    cm+= clamp(pow(1.05-abs(.8-cf),7.), 0.,1.); // mask\n\n    cm *= smoothstep(.1, 0., r-.53); // mask red radius\n\n    cl = max(0.,n) * pow(1.-sqrt(abs(r-.55)), 10.); // lights\n    cl += -pow(abs(n),3.) * pow(1.-sqrt(abs(r-.5)), 14.);\n\n\n    cl *= (.5 + cm/2.); // apply mask to the lights\n\n\n    cf = smoothstep(.97, .99, 1.035-abs(r-.68)); // rim\n    cf -= (1.-z/3.) * .5 * float(r>.61) * smoothstep(.0,.01,.685-r);\n\n    r = length(uv*vec2(.7,1.))*size; // lamps perspective\n\n\n    m2 = 1.35-fract(m1/24.); // ideal radius is .36\n    ct = 0.;\n    for(int i=1; i<4; i++)\n    {\n        ct += min(.8, max(0.,n) * pow(1.2-sqrt(abs(length(r-m2/float(i)))), 12.) )/((float(i)+.5)/1.5); // cool lamp\n    }\n\n    ct*=cm;\n\n    cl += ct;\n\n    light = vec3(cl*.9,cl*.9,cl);\n    norm = .4 * sqrt(n + .8) * vec3(cf/2.7,cf/2.,cf/1.5); // border\n\n    c = float(r<2.)*(xyz+light+norm);\n    c *= min(1.,(t-62.)/4.); // global fade in at 1:02\n\n}\n}\n    outcolor = vec4(c, 1.);\n}", "image_inputs": [{"id": "MdsSWf", "previewfilepath": "https://soundcloud.com/pavel-ksan/gravity-waves", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/pavel-ksan/gravity-waves", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtXczn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 85, 115, 115, 695], [697, 697, 718, 718, 810], [812, 812, 830, 830, 883], [885, 885, 931, 931, 965], [967, 967, 1020, 1020, 1065], [1067, 1067, 1117, 1117, 7001]]}
{"id": "MtXyD2", "name": "Time functions", "author": "tgsstdio", "description": "Bottom : default blending using sin\nplus separator from bender code\nMiddle: time with modulo blending\n2ND from top: switching color values within array\nTOP: subdividing sections by value within float array\n", "tags": ["time"], "likes": 0, "viewed": 83, "date": "1506439229", "time_retrieved": "2024-06-20T19:01:45.893943", "image_code": "#define MID_POINT 0.5\n#define RANGE_OF_TRIG_FUNC 0.5\n#define TWO_PI 6.283185307179586476925286766559\n// in hertz (per sec)\n#define FREQUENCY 0.1\n\n#define BLENDING_LOOP_IN_SECS 10.0\n#define PRIMARY_COLOR_LOOP_IN_SECS 6.0\n\n#define SUBDIVISION_LOOP_IN_SECS 8.0\n#define NO_OF_DIVISIONS 8\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec3 col = vec3(uv,0.5+0.5*sin(iTime));   \n    \n    \n    // SEPARATOR FROM https://www.shadertoy.com/view/4slSWf\n    float sep = iResolution.x * smoothstep( 0.5, 0.8, cos(1.57+0.25*1.2831*iTime));\n\t\n    // separator\n    col *= smoothstep( 1.0, 2.0, abs(fragCoord.x-sep));\t\t\n\t\n    if (uv.y < 0.4)       \n        // Bottom : default blending using sin plus separator from bender demo \n        // \n\t\tfragColor = vec4( col, 1.0 );\n    else if (uv.y < 0.6)\n    {\n        // Middle: SINE FUNCTION \n        \t// SINE starts at mid, goes up to max, down to mid then bottom and up to mid\n        \n        fragColor = vec4(MID_POINT + RANGE_OF_TRIG_FUNC * sin( FREQUENCY * TWO_PI * iTime));\n    }\n    else if (uv.y < 0.8)\n    {           \n        // 2ND from top: switching color values within array\n        float timeStep = mod(iTime, PRIMARY_COLOR_LOOP_IN_SECS) / PRIMARY_COLOR_LOOP_IN_SECS;\n        \n        vec3 primaryColors[3] = vec3[](        \n        \tvec3(1., 0., 0),\n        \tvec3(0., 1., 0),\n        \tvec3(0., 0., 1)                \n        );       \n            \n       \tint colorIndex = int(floor(timeStep * 3.0));            \n            \n        fragColor = vec4(primaryColors[colorIndex], 1.);               \n    }\n    else\n    {\n        // TOP: subdividing sections by value within float array           \n        float gapTimeStep = mod(iTime, SUBDIVISION_LOOP_IN_SECS) / SUBDIVISION_LOOP_IN_SECS;\n        \n\n        float sections[NO_OF_DIVISIONS] = float[](\n            1.,\n        \t2.,\n        \t4.,\n        \t8.,\n            16.,\n            32.,\n            64.,\n            128.\n        );                 \n       \n        float count = sections[int(gapTimeStep * float(NO_OF_DIVISIONS))]; \n\n        if (int(uv.x * count) % 2 == 0)\n        {\n            fragColor = vec4(1., 0., 1., 1.);  \n        }\n        else\n        {\n            fragColor = vec4(1., 1., 0., 1.);\n        }                \n               \n    }    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtXyD2.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[101, 285, 342, 342, 2317]]}
{"id": "MtXyDj", "name": "Analytical Normals 3D v2", "author": "tholzer", "description": "This shader was originally created by Inigo Quilez‏ (see https://www.shadertoy.com/view/XttSz2).\nI slightly modified this shader to gain more attention for this remarkable shader ;-)", "tags": ["3d", "noise", "raymarch", "normals", "analytical", "numerical"], "likes": 10, "viewed": 677, "date": "1506418571", "time_retrieved": "2024-06-20T19:01:47.088096", "image_code": "//---------------------------------------------------------------\n// shader:      Analytical Normals 3D v2\n//\n// The MIT License\n// Copyright © 2016 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n// Computing normals analytically has the benefit of being faster \n// if you need them often, while numerical normals are easier \n// to filter for antialiasing. See SHOW_NUMERICAL_NORMALS.\n//\n// more info: http://iquilezles.org/www/articles/morenoise/morenoise.htm\n// Proper noise code isolated here: https://www.shadertoy.com/view/XsXfRH\n//---------------------------------------------------------------\n\n//#define SHOW_NUMERICAL_NORMALS  // for comparison purposes\n\nfloat hash(float n) { return fract(sin(n)*753.5453123); }\n\n//---------------------------------------------------------------\n// value noise, and its analytical derivatives\n//---------------------------------------------------------------\nvec4 noised(in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n\tvec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    \n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    \n    float a = hash(n+  0.0);\n    float b = hash(n+  1.0);\n    float c = hash(n+157.0);\n    float d = hash(n+158.0);\n    float e = hash(n+113.0);\n\tfloat f = hash(n+114.0);\n    float g = hash(n+270.0);\n    float h = hash(n+271.0);\n\t\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \n                 du * (vec3(k1,k2,k3) + u.yzx*vec3(k4,k5,k6) + u.zxy*vec3(k6,k4,k5) + k7*u.yzx*u.zxy ));\n}\n//---------------------------------------------------------------\nvec4 sdBox(vec3 p, vec3 b) // distance and normal\n{\n    vec3 d = abs(p) - b;\n    float x = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n    vec3  n = step(d.yzx,d.xyz)*step(d.zxy,d.xyz)*sign(p);\n    return vec4( x, n );\n}\n\nvec4 fbmd(in vec3 pos)\n{\n    const float scale  = 1.5;\n    float a = 0.0; //+0.02*sin(iTime);  // size\n    float b = 0.5; //+0.05*sin(iTime);  // density\n\tfloat f = 1.1;\n    vec3  d = vec3(0.0);\n    for( int i=0; i<8; i++ )\n    {\n        vec4 n = noised(pos*f*scale);\n        a += b*n.x;           // accumulate values\t\t\n        d += b*n.yzw*f*scale; // accumulate derivatives\n        b *= 0.5;             // amplitude decrease\n        f *= 1.8;             // frequency increase\n    }\n\treturn vec4(a,d);\n}\n\nvec4 map(in vec3 p)\n{\n    p.z += 0.2*iTime;\n\tvec4 d1 = fbmd( p );\n    d1.x -= 0.37;\n\td1.x *= 0.7;\n    d1.yzw = normalize(d1.yzw);\n\n    // clip to box\n//    vec4 d2 = sdBox( p, vec3(1.5) );\n//    return (d1.x>d2.x) ? d1 : d2;\n    return d1;\n}\n\n// ray-box intersection in box space\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\tfloat tN = max (max (t1.x, t1.y), t1.z);\n\tfloat tF = min (min (t2.x, t2.y), t2.z);\n\tif (tN > tF || tF < 0.0) return vec2(-1.0);\n\treturn vec2( tN, tF );\n}\n\n// raymarch\nvec4 interesect( in vec3 ro, in vec3 rd )\n{\n\tvec4 res = vec4(-1.0);\n\n    // bounding volume    \n    vec2 dis = iBox( ro, rd, vec3(2.0, 2.5, 8.0) ) ;\n    if( dis.y < 0.0 ) return res;\n\n    // raymarch\n    float tmax = dis.y;\n    float t = dis.x;\n\tfor( int i=0; i<128; i++ )\n\t{\n        vec3 pos = ro + t*rd;\n\t\tvec4 hnor = map( pos );\n        res = vec4(t,hnor.yzw);\n        \n\t\tif (hnor.x < 0.001) break;\n\t\tt += hnor.x;\n        if (t > tmax) break;\n\t}\n\n\tif (t > tmax) res = vec4(-1.0);\n\treturn res;\n}\n\n// compute normal numerically\n#ifdef SHOW_NUMERICAL_NORMALS\n  vec3 calcNormal( in vec3 pos )\n  {\n\tvec2 eps = vec2( 0.0001, 0.0 );\n\tvec3 nor = vec3( map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t                 map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t                 map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n  }\n#endif\n\n// fibonacci points in s aphsre, more info:\n// http://lgdv.cs.fau.de/uploads/publications/spherical_fibonacci_mapping_opt.pdf\nvec3 forwardSF( float i, float n) \n{\n    const float PI  = 3.141592653589793238;\n    const float PHI = 1.618033988749894848;\n    float phi = 2.0*PI*fract(i/PHI);\n    float zi = 1.0 - (2.0*i+1.0)/n;\n    float sinTheta = sqrt( 1.0 - zi*zi);\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat ao = 0.0;\n    for( int i=0; i<32; i++ )\n    {\n        vec3 ap = forwardSF( float(i), 32.0 );\n        float h = hash(float(i));\n\t\tap *= sign( dot(ap,nor) ) * h*0.25;\n        ao += clamp( map( pos + nor*0.001 + ap ).x*3.0, 0.0, 1.0 );\n    }\n    return clamp( ao * 5.0 / 32.0, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 R = iResolution.xy;\n    vec2 p = (2.0*fragCoord.xy-R) / R.y;\n    vec2 mp = iMouse.xy / R.xy; \n\t// camera anim\n    float an = 0.1*iTime;\n    an = 3.7 - mp.x;\n\tvec3 ro = 3.0*vec3( cos(an), 0.0, sin(an)) + 0.5 -mp.y;\n\tvec3 ta = vec3( 0,0,0);\n\t\n    // camera matrix\t\n\tvec3  cw = normalize( ta-ro );\n\tvec3  cu = normalize( cross(cw,vec3(0,1,0)) );\n\tvec3  cv = normalize( cross(cu,cw) );\n\tvec3  rd = normalize( p.x*cu + p.y*cv + 1.7*cw );\n\n\t// render\n\tvec3 col = vec3(0.0);\n    vec4 tnor = interesect( ro, rd );\n\tfloat t = tnor.x;\n\n    if (t > 0.0)\n\t{\n\t\tvec3 pos = ro + t*rd;\n        #ifndef SHOW_NUMERICAL_NORMALS\n          vec3 nor = tnor.yzw; // no need to call calcNormal( pos );\n        #else\n          vec3 nor = calcNormal( pos );\n        #endif\n        float occ = calcAO( pos, nor );\n        float fre = clamp( 1.0+dot(rd,nor), 0.0, 1.0 );\n        float fro = clamp( dot(nor,-rd), 0.0, 1.0 );\n        col = mix( vec3(0.1, 0.1, 0.18), vec3(0.4, 0.3, 0.3), 0.5+0.5*nor.y );\n        //col = 0.5+0.5*nor;\n        col += 8.0*pow(fro,12.0)*(0.04+0.96*pow(fre,5.0));\n        col *= pow(vec3(occ),vec3(1.0,1.1,1.1) );\n\t}\n    col += sqrt(col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XsfSWl", "previewfilepath": "https://soundcloud.com/obergman/quilted-multiverse-mix", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/obergman/quilted-multiverse-mix", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/MtXyDj.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1596, 1658, 1679, 1679, 1715], [1717, 1896, 1920, 1920, 2755], [2756, 2822, 2873, 2873, 3051], [3053, 3053, 3077, 3077, 3560], [3562, 3562, 3583, 3583, 3803], [3805, 3842, 3893, 3893, 4157], [4159, 4171, 4214, 4214, 4668], [5015, 5141, 5177, 5177, 5441], [5443, 5443, 5485, 5485, 5780], [5782, 5782, 5839, 5839, 7019]]}
{"id": "MtXyDr", "name": "Waterworks", "author": "nolibab", "description": "Port 'Waterworks' by Fizzer", "tags": ["raymarching", "waves", "water"], "likes": 4, "viewed": 191, "date": "1504475503", "time_retrieved": "2024-06-20T19:01:47.088096", "image_code": "float n(vec3 v)\n{\nfloat s=.1*dot(v,v),r_,y_;\nv/=s;\nv.y+=(iTime/65.)*9.;\nvec3 m=fract(v)-.5,l=abs(m);\nr_=fract(dot(sin(floor(v)+step(l.yzx,l)*step(l.zxy,l)*sign(m)/2.)*43.5,vec3(.333)));\ny_=min(length(m)-.15,abs(length((r_<.333)?m.yz:(r_<.666)?m.zx:m.xy)-.1));\nreturn (((r_>.7)?max(y_,max(l.x,max(l.y,l.z))-.25):y_)-.01)*s/2.;\n}\n\nfloat s(vec3 l)\n{\nfloat v=n(l+vec3(0.,-.2,0.));\nreturn min(n(l),(l.y-cos(v*80.-(iTime/65.)*512.)*(.02-.02*smoothstep(0.,.1,v)))/2.8);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\nfloat v=0.,l;\nvec3 m=normalize(vec3(-1.+fragCoord.xy/(iResolution.y/2.),-1.)),y;\nfor(int r=0;r<150;++r)\n  {\n  v+=l=s(y=vec3(-2.,.5,4.)+m*v);\n  if(l<.001) break;\n  }\nfragColor=vec4(v<20.?abs(s(y+.02)-l)/vec3(4.,3.,2.)*200.:vec3(0.), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtXyDr.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 17, 17, 327], [329, 329, 346, 346, 464], [466, 466, 521, 521, 760]]}
{"id": "MtXyRB", "name": "Square Distance Foo", "author": "isak", "description": "Square Distance Foo based on line distance foo", "tags": ["distancefunction", "square", "proper"], "likes": 2, "viewed": 137, "date": "1505237860", "time_retrieved": "2024-06-20T19:01:47.088096", "image_code": "#define bg_color vec4(0.0)\n#define red vec4(1,0,0,1)\n#define blue vec4(0,0,1,1)\n#define green vec4(0,1,0,1)\n#define white vec4(1,1,1,1)\n#define d_pix (1.0/iResolution.y)\n\nfloat d_square(vec2 uv, float a, float b){\n    float px  = 0.5*a; float py = 0.5*b;  \n    float d = length(uv - vec2(clamp(uv.x,-px,px), clamp(uv.y, -py, py)) );\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.0*(fragCoord.xy / iResolution.xy) - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= 2.0;\n    \n    float size = 1.0 + sin(iTime);\n    float dist = d_square(uv, size, size);\n    \n    fragColor = bg_color;\n    fragColor += vec4(tanh(dist), 0.5, 0,1) * sin(50.0 * dist);\n    fragColor += 0.8*white * smoothstep(4.0*d_pix, 0.0, dist );\n\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtXyRB.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[171, 171, 213, 213, 348], [350, 350, 407, 407, 767]]}
{"id": "MtXyWX", "name": "Wave of dots", "author": "csaez", "description": "Based on https://33.media.tumblr.com/a5d2523e8a4fc92e1629ae9937d870f6/tumblr_nl4lm8O73g1u93xcqo1_500.gif", "tags": ["dots", "perception", "trigonometry"], "likes": 13, "viewed": 568, "date": "1506613431", "time_retrieved": "2024-06-20T19:01:47.306332", "image_code": "// some constants\n#define size 0.015\n#define radius 0.09\n#define speed 3.0\n#define amplitude 4.0\n#define spacing 0.1\n\n// some functions\n#define S(x) smoothstep(2.0 / iResolution.y, 0.0, x)\n#define solidCircle(uv, p, r) S(length(uv - p) - r)\n#define outlinedCircle(uv, p, r) S(abs(length(uv - p) - r))\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float circles = 0.0;\n    float guides = 0.0;\n\n    vec2 uv = fragCoord / iResolution.y;\n    ivec2 cell = ivec2(uv / spacing);\n    for (int i=cell.x - 1; i<=cell.x + 2; i++) {\n        for (int j=cell.y - 1; j<=cell.y + 2; j++) {\n            \n            vec2 offset = vec2(i, j) * spacing;\n            guides += outlinedCircle(uv, offset, radius);\n\n            float phase = float(i + j) * spacing * amplitude;\n            float factor = (iTime * speed) + phase;\n            vec2 pos = (vec2(cos(factor), sin(factor)) * radius) + offset;\n            circles += solidCircle(uv, pos, size);\n        }\n    }\n\n\tfragColor = vec4(circles + 0.3 * guides);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtXyWX.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[118, 303, 358, 358, 1011]]}
{"id": "MtXyz2", "name": "Interval CSG Register Machine", "author": "paniq", "description": "demonstrating how to perform CSG on brushes without z-sorting by evaluating distances to brush intervals using a virtual machine with 4 registers. mouse down displays distance estimate for that position and evaluations performed.", "tags": ["raymarching", "csg", "1d", "interval", "machine", "register", "vm"], "likes": 17, "viewed": 1074, "date": "1505511302", "time_retrieved": "2024-06-20T19:01:52.645998", "image_code": "// CSG on Intervals\n// using 2d vector graphics library (https://www.shadertoy.com/view/lslXW8)\n\n// note that this version is verbose and purposefully lacks \n// any form of optimization for the sake of education.\n\n// the general principle here is that we first evaluate the near and\n// far boundaries of the brushes that cross our line of sight, \n// so we end up with a list of 1D intervals for each brush.\n//\n// then we can perform CSG in rayspace and raymarch towards the\n// nearest resulting visible surface by repeatedly evaluating\n// a distance estimator that gives us the distance to the \n// nearest horizon.\n//\n// the distance estimator evaluates the CSG tree to receive \n// a lower bound on the distance to the edge closest to \n// the right of a given 1D scalar t.\n//\n// the CSG tree evaluation is sped up by transforming the tree\n// to an instruction list first (here done manually) that operates\n// on up to four virtual registers A, B, C, D to store temporary\n// values; after the instruction list has been executed, the\n// final result can be found in register A.\n//\n// the VM executing the instruction list needs only four operators:\n// SET A B (copy)\n// OR A B (boolean union)\n// AND A B (boolean intersection)\n// ANDN A B (boolean subtraction)\n// each operator can be encoded as a function that receives\n// a 4-bit bitmask encoding the comparisons a0>b0 a1>b0 a0>b1 a1>b1\n// for the two intervals passed to the operator, and returns\n// a new interval in D that sources one of the four possible values\n// for d0 d1 based on the bitmask.\n//\n// the complexity is O(n) for n union-only instructions,\n// but can reach O(n*n) in the worst case; the performance in\n// practice however is typically around O(3n). Through hierarchical\n// culling one can aggressively reduce the number of instructions\n// required to solve a tile:\n//\n// it is possible, not demonstrated here, to source the brush \n// intervals from a primitive-frustum intersection instead, and\n// to cull/rewrite instructions that yield no result, allowing\n// for hierarchical quadtree-style raymarching using\n// per-tile linked lists for tiles that contain more than one \n// instruction.\n\n\n// evaluation interval legend:\n// green: union\n// orange: intersection\n// magenta: subtraction\n\n// set to 1 to show CSG operator debug setup\n#define DEBUG_CSG_OPS 0\n#define DEBUG_CSG_OP CSG_ANDN\n#define TEST_SETUP 0\n\nconst vec2 ray_origin = vec2(0.0);\nconst vec2 ray_dir = vec2(1.0,0.0);\n\nconst int op_set = 0;\nconst int op_or = 1;\nconst int op_and = 2;\nconst int op_and_not = 3;\n\nconst int reg_a = -1;\nconst int reg_b = -2;\nconst int reg_c = -3;\nconst int reg_d = -4;\nconst int empty = -5;\n\nconst float infinity = 1.0/0.0;\nconst vec2 empty_interval = vec2(infinity);\n\n// these brushes are usually imported using a SSBO\n// here we provide a small local array\n#if DEBUG_CSG_OPS\n#define NUM_BRUSHES 2\n#elif TEST_SETUP\n#define NUM_BRUSHES 3\n#else\n#define NUM_BRUSHES 7\n#endif\nvec3 brushes[NUM_BRUSHES];\nvec2 brush_intervals[NUM_BRUSHES];\n\nvec2 iCircle(vec2 o_ro, vec2 rd, vec3 params) {\n\tvec2 ro = o_ro - params.xy / params.z;\n\tfloat k = dot(ro, rd);\n    float q = sqrt(k*k - dot(ro, ro) + 1.0);\n    vec2 d = (vec2(-q,q) - k) * params.z;\n    return (d.x != d.x)?empty_interval:d;\n}\n\nfloat dCircle(vec2 p, vec3 params) {\n    return length(p - params.xy) - params.z;\n}\n\n// dynamic array index hack\nvec3 get_brush(int brushid) {\n    for (int i = 0; i < NUM_BRUSHES; ++i) {\n        if (i == brushid)\n            return brushes[i];\n    }\n    return vec3(0.0);\n}\n\n// dynamic array index hack\nvec2 get_brush_interval(int brushid) {\n    for (int i = 0; i < NUM_BRUSHES; ++i) {\n        if (i == brushid)\n            return brush_intervals[i];\n    }\n    return empty_interval;\n}\n\n// dynamic array index hack\nfloat get_reg(vec4 regs, int regid) {\n    for (int i = 0; i < 4; ++i) { if (i == reg_a-regid) return regs[i]; }\n    return infinity;\n}\nvoid set_reg(inout vec4 regs, int regid, float val) {\n    for (int i = 0; i < 4; ++i) { if (i == reg_a-regid) { regs[i] = val; return; } }\n}\n\n#if DEBUG_CSG_OPS\n#define NUM_CSG_OPS 2\n#elif TEST_SETUP\n#define NUM_CSG_OPS 3\n#else\n#define NUM_CSG_OPS 9\n#endif\n#define CSG_OP ivec3\n// opcode, src1, src2\n// src1 must be register\n// src2 must be register, empty or brush\n// computation result will be written to src1\n// in a realworld example, this would be a SSBO\nCSG_OP csg_ops[NUM_CSG_OPS];\nvoid setup_globals(float t) {\n#if DEBUG_CSG_OPS\n    brushes[0] = vec3(0.5,0.0,0.08);\n    brushes[1] = vec3(mix(0.26,0.74,sin(t)*0.5+0.5),0.0,0.1);\n#elif TEST_SETUP\n    vec2 c = vec2(0.5,0.05);\n    float r0 = 0.21;\n    float a0 = t;\n    float a1 = a0 + radians(90.0);\n    brushes[0] = vec3(c.x + cos(a0)*r0, c.y + sin(a0)*r0,0.2);\n    brushes[1] = vec3(c.x - cos(a0)*r0, c.y - sin(a0)*r0,0.2);\n    brushes[2] = vec3(c.x, c.y, 0.1);\n#else\n\tbrushes[0] = vec3(0.3,0.0,0.1);\n    brushes[1] = vec3(mix(0.25,0.35,sin(t*0.7)*0.5+0.5),0.26,0.29);\n    brushes[6] = vec3(0.3,mix(0.0,0.1,sin(t*0.6)*0.5+0.5),0.12);\n    vec2 c = vec2(0.8,0.03);\n    float r0 = 0.08;\n    float r1 = 0.09;\n    float a0 = t;\n    float a1 = a0 + radians(90.0);\n    brushes[2] = vec3(c.x + cos(a0)*r0, c.y + sin(a0)*r0,0.1);\n    brushes[3] = vec3(c.x - cos(a0)*r0, c.y - sin(a0)*r0,0.1);\n    brushes[4] = vec3(c.x + cos(a1)*r1, c.y + sin(a1)*r1,0.1);\n    brushes[5] = vec3(c.x - cos(a1)*r1, c.y - sin(a1)*r1,0.1);\n#endif\n\n// dynamic array indexing hack just so we can squeeze out a little convenience\n#define CSG_INSTR(OP, A, B) if (i == k) { csg_ops[i] = CSG_OP(OP, A, B); } k++;\n#define CSG_SET(A, B) CSG_INSTR(op_set, A, B)\n#define CSG_OR(A, B) CSG_INSTR(op_or, A, B)\n#define CSG_AND(A, B) CSG_INSTR(op_and, A, B)\n#define CSG_ANDN(A, B) CSG_INSTR(op_and_not, A, B)\n    for (int i = 0; i < NUM_CSG_OPS; ++i) {\n\t    int k = 0;\n#if DEBUG_CSG_OPS\n        CSG_SET(reg_a, 0);\n        DEBUG_CSG_OP(reg_a, 1);\n#elif TEST_SETUP\n        CSG_SET (reg_a, 0);\n        CSG_OR\t(reg_a, 1);\n        CSG_AND\t(reg_a, 2);\n#else\n        CSG_SET\t(reg_a, 2);\n        CSG_AND\t(reg_a, 3);\n        CSG_SET\t(reg_b, 4);\n        CSG_AND\t(reg_b, 5);\n        CSG_OR\t(reg_a,\treg_b);\n        CSG_SET (reg_b, 0);\n        CSG_ANDN(reg_b, 1);\n        CSG_OR  (reg_a, reg_b);\n        CSG_ANDN(reg_a, 6);\n#endif\n    }\n#undef CSG_INSTR\n#undef CSG_OR\n#undef CSG_AND\n#undef CSG_AND_NOT\n\n    // precalculate brush intervals\n    for (int i = 0; i < NUM_BRUSHES; ++i) {\n        brush_intervals[i] = iCircle(ray_origin, ray_dir, brushes[i]);\n    }\n}\n\nfloat interval_edge(vec2 range, float t) {\n    if (range.x > t) {\n    \treturn range.x; \n\t} else if (range.y > t) {\n        return -range.y;\n    } else {\n        return infinity;\n    }\n}\n\n// given a ray scalar, compute a lower bound on the\n// distance to the next fully occluding interval\n// when the distance is near 0, we have hit a surface.\nfloat scene_next_feature(float t) {\n    vec4 regs;\n    for (int i = 0; i < NUM_CSG_OPS; ++i) {\n        CSG_OP op = csg_ops[i];\n        int opcode = op[0];\n        float d = get_reg(regs, op[1]);\n        float src;\n        if (op[2] < 0) {\n            src = get_reg(regs, op[2]);\n        } else {\n            src = interval_edge(get_brush_interval(op[2]), t);\n        }\n        if (opcode == op_or) {\n            d = min(d, src);\n        } else if (opcode == op_and) {\n            d = max(d, src);\n        } else if (opcode == op_and_not) {\n            d = max(d, -src);\n        } else if (opcode == op_set) {\n            d = src;\n        }\n        set_reg(regs, op[1], d);\n    }\n    return regs[0];\n}\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1);\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1);\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r);\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r);\nvoid set_source(sampler2D image);\n// control how source changes are applied\nconst int Replace = 0; // default: replace the new source with the old one\nconst int Alpha = 1; // alpha-blend the new source on top of the old one\nconst int Multiply = 2; // multiply the new source with the old one\nvoid set_source_blend_mode(int mode);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add an ellipse path at P with radii RW and RH\nvoid ellipse(vec2 p, vec2 r);\nvoid ellipse(float x, float y, float rw, float rh);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n// add a rectangle at O with size S and rounded corner of radius R\nvoid rounded_rectangle(vec2 o, vec2 s, float r);\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// non-uniformly scale the context by S\nvoid scale(vec2 s);\nvoid scale(float sx, float sy);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    vec2 clip;\n    vec2 scale;\n    float line_width;\n    bool premultiply;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n    int source_blend;\n    bool has_clip;\n};\n\nfloat AA;\nfloat AAINV;\n\n// save current stroke width, starting\n// point and blend mode from active context.\nContext _save();\n// restore stroke width, starting point\n// and blend mode to a context previously returned by save()\nvoid restore(Context ctx);\n\n#define save(name) Context name = _save();\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\nvoid debug_clip_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\nvoid paint() {\n    float t = iTime;\n    setup_globals(t);    \n        \n    float rdot = AAINV*1.0;\n\n    scale(3.);\n    translate(-0.5,0.0);\n    \n    set_line_width_px(1.0);\n\n    // compute CSG field per pixel\n    vec4 regs = vec4(infinity);\n    vec2 p = get_origin();\n    for (int i = 0; i < NUM_CSG_OPS; ++i) {\n        CSG_OP op = csg_ops[i];\n        int opcode = op[0];\n        float src1 = get_reg(regs, op[1]);\n        float src2 = (op[2] < 0)?get_reg(regs, op[2]):dCircle(p, get_brush(op[2]));\n        float dst;\n        if (opcode == op_or) {\n            dst = min(src1, src2);\n        } else if (opcode == op_and) {\n            dst = max(src1, src2);\n        } else if (opcode == op_and_not) {\n            dst = max(src1, -src2);\n        } else if (opcode == op_set) {\n            dst = src2;\n        }\n        set_reg(regs, op[1], dst);\n    }    \n    add_field(regs[0]);\n    set_source_rgb(hsl(0.6,0.7,0.95));\n    fill_preserve();\n    set_source_rgb(hsl(0.6,0.2,0.5));\n    stroke();\n    \n    // paint brushes\n    set_source_rgba(hsl(0.6,0.2,0.5,0.3));\n    for (int i = 0; i < NUM_BRUSHES; ++i) {\n        vec3 brush = brushes[i];\n\t\tcircle(brush.xy, brush.z);\n\t    stroke();\n    }   \n    \n    // paint ray    \n    set_source_rgba(0.0,0.0,0.0,0.2);\n\tmove_to(0.0, 0.0);\n    line_to(1.0, 0.0);\n    stroke();    \n    set_source_rgb(vec3(0.0));\n    circle(0.0, 0.0, rdot);\n    fill();    \n    move_to(1.0, rdot);\n    line_to(1.0, -rdot);\n    line_to(1.0+rdot*3.0, 0.0);\n    close_path();\n    fill();\n\n    vec2 m = get_query();\n    if (iMouse.z > 0.5) {\n        // paint brush ranges\n        vec4 iregs;\n        for (int i = 0; i < 4; ++i) { iregs[i] = infinity; }\n        const float h = 0.005;\n        float y = h * float(NUM_CSG_OPS * 5);\n        for (int i = 0; i < NUM_CSG_OPS; ++i) {\n            CSG_OP op = csg_ops[i];\n            int opcode = op[0];        \n            float src1 = get_reg(iregs, op[1]);\n            float src2 = (op[2] < 0)?get_reg(iregs, op[2]):interval_edge(get_brush_interval(op[2]), m.x);\n            float dst;\n            vec3 color;\n            if (opcode == op_or) {\n                color = hsl(0.4,0.7,0.5);\n                dst = min(src1, src2);\n            } else if (opcode == op_and) {\n                color = hsl(0.1,1.0,0.5);\n                dst = max(src1, src2);\n            } else if (opcode == op_and_not) {\n                color = hsl(0.9,0.7,0.5);\n                dst = max(src1, -src2);\n            } else if (opcode == op_set) {\n                color = hsl(0.6,0.7,0.5);\n                dst = src2;\n            } else {\n                dst = infinity;\n                color = vec3(1.0,0.0,0.0);\n            }\n            set_reg(iregs, op[1], dst);\n\n            vec2 total_range = vec2(infinity,-infinity);\n            if (src1 != infinity) {\n                total_range[0] = min(total_range[0], abs(src1));\n                total_range[1] = max(total_range[1], abs(src1));\n            }\n            if (src2 != infinity) {\n                total_range[0] = min(total_range[0], abs(src2));\n                total_range[1] = max(total_range[1], abs(src2));\n            }\n            if (dst != infinity) {\n                total_range[0] = min(total_range[0], abs(dst));\n                total_range[1] = max(total_range[1], abs(dst));\n            }\n\n            float y1 = y;\n            y = y - h;\n            float y2 = y;\n            y = y - h;\n            float y3 = y;\n            y = y - 3.0*h;\n\n            set_source_rgba(0.0,0.0,0.0,0.1);\n            move_to(total_range.x, y1);\n            line_to(total_range.y, y1);\n            move_to(total_range.x, y2);\n            line_to(total_range.y, y2);\n            move_to(total_range.x, y3);\n            line_to(total_range.y, y3);\n            stroke();\n\n            const float R = h*0.5;\n            set_source_rgb(color);\n            circle(abs(src1), y1, R);\n            circle(abs(src2), y2, R);\n            circle(abs(dst), y3, R);\n            fill();\n\n            move_to(abs(src1),y1);\n            line_to(abs(src1),0.0);\n\n            move_to(abs(src2),y2);\n            line_to(abs(src2),0.0);\n\n            move_to(abs(dst),y3);\n            line_to(abs(dst),0.0);\n            stroke();\n        }\n        \n        set_source_rgba(0.0,0.0,0.0,0.2);\n        move_to(m.x, -1.0);\n        line_to(m.x, 1.0);\n        stroke();\n\t    float rd = scene_next_feature(m.x);\n        set_source_rgb(vec3(0.0));\n        circle(rd, 0.0, rdot);\n        stroke();\n    } else {\n        float t = 0.0;\n        for (int i = 0; i < (NUM_CSG_OPS + 1); ++i) {\n            float dv = scene_next_feature(t);\n            if (dv <= 0.0) {\n                set_source_rgb(vec3(0.0));\n                circle(t, 0.0, rdot);\n                stroke();                \n                break;\n            }\n            t = dv;\n            if (t == infinity) break;\n            float cf = float(i) / float(NUM_CSG_OPS + 1);\n            set_source_rgb(hsl(cf,0.8,0.7));\n            circle(t, 0.0, rdot);\n            fill();\n        }\n    }\n}\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n#define DEFAULT_CLIP_V -1e+20\n\nContext _stack;\n\nvoid init (vec2 fragCoord) {\n    uv = fragCoord.xy / iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n\n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        vec2(DEFAULT_CLIP_V),\n        vec2(1.0),\n        1.0,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0),\n        Replace,\n        false\n    );\n}\n\nvec3 _color = vec3(1.0);\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n    _stack.clip.y = DEFAULT_CLIP_V;\n}\n\nContext _save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;\n    vec2 clip = _stack.clip;\n    bool has_clip = _stack.has_clip;\n    // preserve source\n    vec4 source = _stack.source;\n    _stack = ctx;\n    _stack.shape = shape;\n    _stack.clip = clip;\n    _stack.source = source;\n    _stack.has_clip = has_clip;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = vec2(1.0);\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;\n    _stack.scale = vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    _stack.scale *= vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(vec2 s) {\n    transform(mat3(s.x,0.0,0.0,0.0,s.y,0.0,0.0,0.0,1.0));\n}\n\nvoid scale(float sx, float sy) {\n    scale(vec2(sx, sy));\n}\n\nvoid scale(float s) {\n    scale(vec2(s));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color = mix(_color, _stack.source.rgb, _stack.source.a);\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(_color, 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = _color;\n}\n\nvoid add_clip(vec2 d) {\n    d = d / _stack.scale;\n    _stack.clip = max(_stack.clip, d);\n    _stack.has_clip = true;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);\n}\n\nvoid add_field(float c) {\n    c = c / _stack.scale.x;\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n    _stack.clip = vec2(DEFAULT_CLIP_V);\n    _stack.has_clip = false;\n}\n\nvoid debug_gradient() {\n    vec2 d = _stack.shape;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid debug_clip_gradient() {\n    vec2 d = _stack.clip;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color = _color * (1.0 - src_a) + rgba.rgb * dst_a;\n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat min_uniform_scale() {\n    return min(_stack.scale.x, _stack.scale.y);\n}\n\nfloat uniform_scale_for_aa() {\n    return min(1.0, _stack.scale.x / _stack.scale.y);\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA*uniform_scale_for_aa(), 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);\n\treturn wa * wb;\n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n    if (_stack.has_clip) {\n\t    write_color(_stack.source, calc_aa_blur(_stack.clip.x));        \n    }\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*min_uniform_scale() * AAINV;\n}\n\nfloat get_gradient_eps() {\n    return (1.0 / min_uniform_scale()) * AAINV;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    if (_stack.source_blend == Multiply) {\n        _stack.source *= c;\n    } else if (_stack.source_blend == Alpha) {\n    \tfloat src_a = c.a;\n    \tfloat dst_a = _stack.premultiply?1.0:src_a;\n\t    _stack.source =\n            vec4(_stack.source.rgb * (1.0 - src_a) + c.rgb * dst_a,\n                 max(_stack.source.a, c.a));\n    } else {\n    \t_stack.source = c;\n    }\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) {\n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1) {\n    vec2 pa = _stack.position.xy - p0;\n    vec2 ba = p1 - p0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1) {\n    set_source_linear_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p0, p1);\n}\n\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r) {\n    float h = clamp( length(_stack.position.xy - p) / r, 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r) {\n    set_source_radial_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p, r);\n}\n\nvoid set_source_blend_mode(int mode) {\n    _stack.source_blend = mode;\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid rounded_rectangle(vec2 o, vec2 s, float r) {\n    s = (s * 0.5);\n    r = min(r, min(s.x, s.y));\n    o += s;\n    s -= r;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    vec2 df = max(dmin.xz, dmin.yw) + length2(dmax);\n    add_field(df - r);\n}\n\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), r);\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    rounded_rectangle(o, s, 0.0);\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), 0.0);\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\n// from https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n    if (l == 0.0) {\n        return length(p) - ab.x;\n    }\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 r = vec2( ab.x*co, ab.y*si );\n\t\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nvoid ellipse(vec2 p, vec2 r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(sdEllipse(c.xy, r), sdEllipse(c.zw, r)));\n}\n\nvoid ellipse(float x, float y, float rw, float rh) {\n    ellipse(vec2(x,y), vec2(rw, rh));\n}\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 s = sign(pa.xz*ba.y-pa.yw*ba.x);\n    vec2 d = length2(pa - ba.xyxy*h.xxyy);\n    add_field(d);\n    add_clip(d * s);\n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat test_cross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat bezier_sign(vec2 A, vec2 B, vec2 C, vec2 p) {\n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0,\n        step(test_cross(A, B, p) * test_cross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * test_cross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    vec2 shape = vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw));\n    add_field(abs(shape));\n    add_clip(shape);\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(abs(f_x) / length(df_x));\n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t aspect = vec2(iResolution.x / iResolution.y, 1.0);\n\t ScreenH = min(iResolution.x,iResolution.y);\n\t AA = ScreenH*0.4;\n\t AAINV = 1.0 / AA;\n\n    init(fragCoord);\n\n    paint();\n\n    blit(fragColor);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtXyz2.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[2732, 2999, 3046, 3046, 3241], [3243, 3243, 3279, 3279, 3326], [3328, 3356, 3385, 3385, 3516], [3518, 3546, 3584, 3584, 3728], [3730, 3758, 3795, 3795, 3892], [3893, 3893, 3946, 3946, 4033], [4170, 4381, 4410, 4410, 6453], [6455, 6455, 6497, 6497, 6640], [6642, 6798, 6833, 6833, 7498], [13244, 13309, 13323, 13323, 18320], [18474, 18534, 18561, 18561, 18587], [18589, 18649, 18670, 18670, 18777], [18779, 18779, 18816, 18816, 18902], [18904, 18904, 18950, 18950, 18983], [18985, 19123, 19151, 19151, 19611], [19639, 19639, 19658, 19658, 19691], [19693, 19693, 19711, 19711, 19744], [19746, 19746, 19770, 19770, 19874], [19876, 19876, 19893, 19893, 19914], [19916, 19916, 19943, 19965, 20248], [20250, 20250, 20278, 20278, 20512], [20514, 20514, 20538, 20538, 20624], [20626, 20626, 20653, 20653, 20866], [20868, 20868, 20894, 20894, 21122], [21124, 21124, 21146, 21146, 21272], [21274, 21274, 21294, 21294, 21354], [21356, 21356, 21388, 21388, 21415], [21417, 21417, 21438, 21438, 21460], [21462, 21462, 21486, 21486, 21546], [21548, 21548, 21582, 21582, 21606], [21608, 21608, 21622, 21622, 21686], [21688, 21688, 21714, 21714, 21746], [21748, 21748, 21774, 21774, 21795], [21797, 21797, 21820, 21820, 21915], [21917, 21917, 21941, 21941, 22010], [22012, 22012, 22037, 22037, 22112], [22114, 22114, 22131, 22131, 22244], [22246, 22246, 22269, 22269, 22398], [22400, 22400, 22428, 22428, 22556], [22558, 22558, 22582, 22582, 22722], [22724, 22724, 22762, 22762, 22896], [22898, 22898, 22935, 22935, 22970], [22972, 22972, 22999, 22999, 23049], [23051, 23051, 23081, 23081, 23137], [23139, 23139, 23168, 23168, 23349], [23351, 23351, 23373, 23373, 23540], [23542, 23542, 23555, 23555, 23594], [23596, 23596, 23626, 23626, 23655], [23657, 23657, 23690, 23690, 23747], [23749, 23749, 23775, 23775, 23825], [23827, 23827, 23848, 23848, 23913], [23915, 23915, 23939, 23939, 24022], [24024, 24024, 24039, 24039, 24080], [24082, 24082, 24098, 24098, 24136], [24138, 24138, 24156, 24156, 24213], [24215, 24215, 24245, 24245, 24615], [24617, 24617, 24675, 24675, 24713], [24715, 24715, 24744, 24744, 24780], [24782, 24782, 24830, 24830, 24861], [24863, 24863, 24897, 24897, 24956], [24958, 24958, 25035, 25035, 25200], [25202, 25202, 25279, 25279, 25359], [25361, 25361, 25437, 25437, 25553], [25555, 25555, 25631, 25631, 25709], [25711, 25711, 25749, 25749, 25783], [25785, 25785, 25807, 25807, 25853], [25855, 25855, 25882, 25882, 25926], [25928, 25928, 25977, 25977, 26238], [26240, 26240, 26313, 26313, 26367], [26369, 26369, 26401, 26401, 26437], [26439, 26439, 26495, 26495, 26551], [26553, 26553, 26583, 26583, 26676], [26677, 26677, 26717, 26717, 26740], [26742, 26788, 26827, 26827, 27983], [27985, 27985, 28015, 28015, 28117], [28119, 28119, 28171, 28171, 28211], [28213, 28213, 28235, 28235, 28286], [28288, 28288, 28320, 28320, 28342], [28344, 28359, 28381, 28381, 28673], [28675, 28675, 28707, 28707, 28729], [28731, 28731, 28750, 28750, 28782], [28831, 28894, 28936, 28936, 29002], [29004, 29074, 29125, 29125, 29477], [29479, 29513, 29559, 29559, 30071], [30073, 30142, 30188, 30188, 30694], [30696, 30696, 30729, 30729, 30945], [30947, 30947, 31006, 31006, 31051], [31053, 31053, 31096, 31096, 31157], [31159, 31159, 31201, 31201, 31243], [31245, 31305, 31362, 31362, 31561]]}
{"id": "XlfcD4", "name": "dizzy", "author": "sgoal", "description": "dizzy", "tags": ["dizzy"], "likes": 0, "viewed": 66, "date": "1504758957", "time_retrieved": "2024-06-20T19:01:52.937031", "image_code": "#define Native 0\n\n#define _local_main_ void main()\n#define _shadertoy_main_ void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n#define u_resolution iResolution\n\n#if Native == 1\n    #define Main() _local_main_\n    #define fragColor gl_FragColor\n    #define fragCoord gl_FragCood\n    #define iTime iGlobalTime\n    #define u_time iGlobalTime\n#else\n    #define Main() _shadertoy_main_\n    #define gl_FragColor fragColor\n    #define gl_FragCood fragCoord\n    #define iGlobalTime iTime\n    #define u_time iGlobalTime\n#endif \n\nMain(){\n  vec2 st = 2.0*vec2(gl_FragCoord.xy - 0.5*iResolution.xy)/iResolution.y;//gl_FragCoord.xy/u_resolution.xy;\n  vec3 color = vec3(0.0);\n  float d = 0.0;\n\n\n  // Make the distance field\n   // if(fract(u_time) < 0.2)\n   // d = length( abs(st)+.5*sin(u_time) ); \n    //abs(st) [0,1]\n    //abs(st) -0.5 [-.5,.5]\n    // else if(fract(u_time)<0.4)\n   d = length( min(abs(st)-.3,0.) );\n  \t// else\n    d = length( max(abs(st)-.5*sin(u_time),0.) );\n\n  // Visualize the distance field\n  gl_FragColor = vec4(vec3(fract(d*10.0)),1.0);\n\n  // Drawing with the distance field\n  // gl_FragColor = vec4(vec3( step(.3,d) ),1.0);\n  // gl_FragColor = vec4(vec3( step(.3,d) * step(d,.4)),1.0);\n  // gl_FragColor = vec4(vec3( smoothstep(.3,.4,d)* smoothstep(.6,.5,d)) ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlfcD4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": []}
{"id": "XlfcRj", "name": "Hex Mesh", "author": "isak", "description": "Hexagon mesh scaled", "tags": ["hexagon", "mod", "transformation", "scaling"], "likes": 7, "viewed": 184, "date": "1505392080", "time_retrieved": "2024-06-20T19:01:53.246228", "image_code": "// Hex frequency\n#define N 16.0\n\n// Constants\n#define pi 3.14159265358979323846\n#define sin_60 0.8660254037844386\n#define rot_90 mat2(0.0, -1.0, 1.0, 0.0)\n\n// Hex directions\n#define hv_1 vec2(1.0, 0.0)\n#define hv_2 vec2(0.5, -sin_60)\n#define hv_3 vec2(0.5,  sin_60)\n\n// Mod directions 90 degrees to Hex directions\n#define mv_1 vec2(0.0, 1.0)\n#define mv_2 vec2(-sin_60, -0.5)\n#define mv_3 vec2( sin_60, -0.5)\n\nfloat d_hexagon(vec2 uv, float a){\n    return length(uv - hv_1*clamp( dot(uv, hv_1), -a, a) \n                     - hv_2*clamp( dot(uv, hv_2), -a, a) \n                     - hv_3*clamp( dot(uv, hv_3), -a, a) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n\tvec2 uv = 2.0*(fragCoord.xy / iResolution.xy) - 1.0;\n    uv.x *= iResolution.x/iResolution.y;    \n    \n    // Global scaling and rotation transformation\n    float p_time = clamp(1.0 - 2.3*sin(iTime/3.0), 0.0, 4.0);\n    float scale_f = abs( N / (p_time + dot(uv,uv)) );\n    uv *= scale_f; // scale_f = 5.0; // Try scale_f = 5.0;\n    float ct = cos(0.2*p_time); float st = sin(0.2*p_time);\n    uv *= mat2(ct, -st, st, ct);\n      \n    // Modding for repeated hexagons\n    uv = + mv_1 * mod(dot(uv, mv_1), 2.0)\n         + mv_2 * mod(dot(uv, mv_2), 2.0) \n         + mv_3 * mod(dot(uv, mv_3), 2.0);\n    \n    //uv*= rot_90; // uncomment to get stars\n    float size = 0.5 + 0.0025*sin(15.0*iTime);\n    float dist = d_hexagon(uv, size);\n\n\t// Final out\n\tfragColor = 2.0*vec4(dist, 0.5, 0,1) * sin(3.0*dist);\n    fragColor *= clamp(N/scale_f,0.0,1.0);  // Supress aliased regions\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlfcRj.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[267, 409, 443, 443, 621], [623, 623, 679, 679, 1556]]}
{"id": "XlfyR2", "name": "Pretty pattern", "author": "TheGrego", "description": "A simple, pretty repeating patterned animation.", "tags": ["2d", "pattern", "symetrical"], "likes": 2, "viewed": 106, "date": "1505410252", "time_retrieved": "2024-06-20T19:01:53.246228", "image_code": "#define POINT_COUNT 5.0\n#define PATTERN_SCALE 4.0\n\nvoid mainImage( out vec4 fragColor, in vec2 U )\n{\n\t// set the uv\n\tvec2 uv = iResolution.xy;\n    uv = (U + U - vec2(uv)) / uv.y;\n    \n    vec2 muv = uv;\n   \tmuv *= PATTERN_SCALE;\n\tmuv *= sin(iTime * 0.5 - length(muv) );\n    \n    float a = atan(muv.y, muv.x);\n    \n    float size = 0.2 + sin(a * 5.0);\n    float val = fract(iTime * 0.25 - length(muv) \n                      + sin( a * POINT_COUNT) \n                      * size );\n    val = smoothstep( 0.45, 0.65, val);\n   \t\n    float fade = smoothstep( 0.0, 0.2, 1.0 - length(uv));    \n    fragColor = vec4( vec3(val) * fade, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlfyR2.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[51, 51, 100, 115, 634]]}
{"id": "XlfyRj", "name": "Dancing Star", "author": "SunLuke", "description": "dance", "tags": ["huehe"], "likes": 2, "viewed": 116, "date": "1505393819", "time_retrieved": "2024-06-20T19:01:53.246228", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n    \n#define r iResolution.xy\n#define t iTime\n{\n    vec2 uv = fragCoord/r;\n    vec2 d = vec2 (.1*sin(t),.1*cos(t));\n    //uv/=.5;\n    uv-=.5;\n    //uv.x-=0.25;\n    uv.x*=r.x/r.y;\n    //uv.x=.19+uv.x*cos(t);\n    //uv.y=.19+uv.y*sin(t);\n    //uv.x=sin(uv.x);\n    //float l = (.16*sin(t*.6)+2.0)*length(uv);\n    float l = length(uv+d)*3.0125*(2.0*uv.y+1.0);\n    l=l;\n    fragColor = vec4(0.25/l,0.4/l,0.5/l,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlfyRj.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": []}
{"id": "Xllczj", "name": "Time's Ticking", "author": "Vovosunt", "description": "Tick-Tock goes the Clock.\n\nFocused on idea only.\nNothing optimized, everything dirty as hell, don't even talk about the noise.", "tags": ["2d", "text", "clock", "spiral"], "likes": 28, "viewed": 466, "date": "1505597679", "time_retrieved": "2024-06-20T19:01:53.773501", "image_code": "#define smooth (2.0/iResolution.y)\n#define thick 0.5\n#define timeScale 1.0\n#define rt (iTime * timeScale)\n\n#define PI      3.14159265359\n\nfloat rand(vec3 v){\n    return fract(cos(dot(v,vec3(13.46543,67.1132,123.546123)))*43758.5453);\n}\n\nfloat rand(vec2 v){\n    return fract(sin(dot(v,vec2(5.11543,71.3132)))*43758.5453);\n}\n\nfloat getNum(vec2 uv, int x, float smoothT){\n        vec2 uvm = uv / vec2(16.0) + vec2(x,12.) * 1. / 16.;\n        float dist = texture( iChannel0, uvm).a;\n        float sm = smoothT;\n        return smoothstep(sm,-sm,dist - thick)+\n        \tsmoothstep(8. * sm,-3.0 * sm,dist - thick)*dist;\n}\n\nfloat getNum2(vec2 uv, int x, float smoothT){\n    if(x < 10){\n        return getNum(uv, x, smoothT);\n    } else{\n        if(uv.x < 0.5){\n            return getNum(vec2(fract(uv.x * 2.0) * 0.5  +0.22,uv.y),x/10,smoothT);\n        }else{\n            return getNum(vec2(fract(uv.x * 2.0) * 0.5 +0.28,uv.y),x%10,smoothT);\n        }\n        \n    }\n}\n\nfloat noise(vec2 uv){\n    vec2 off = vec2(1,0);\n    vec2 fuv = floor(uv);\n    \n    float tl = rand(fuv);\n    float tr = rand(fuv + off.xy);\n    float bl = rand(fuv + off.yx);\n    float br = rand(fuv + off.xx);\n    \n    vec2 fruv = fract(uv);\n    fruv = fruv * fruv * (2.0 - fruv);\n    \n    return mix(mix(tl,tr,fruv.x), mix(bl,br,fruv.x),fruv.y);\n}\n\nfloat octNoise(vec2 uv, int octaves){\n    float sum = 0.0;\n    float f = 1.0;\n    for (int i = 0; i < octaves; ++i){\n        sum += (noise(uv*f) - 0.5) * 1. /f;\n        f *= 2.0;\n    }\n    return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - 0.5* iResolution.xy) / iResolution.y;\n    uv += octNoise(uv*1.6 + rt*0.1,2) * 0.1 * ( 0.5 + length(uv));\n    float a = (atan(uv.x,uv.y) + PI) /PI /2.;\n    float l = length(uv);\n    \n    float ll = a * 2.0 + pow(l,0.3) * 7.0;\n    float trueSm = smooth * 16.0 / ll;\n    float fll = floor(ll);\n    ll = fract(ll);\n    float cll = clamp((ll-0.46)*3.0,0.0,1.0);\n    float ra = a *24.0 - rt;\n        \n    float bgline = smoothstep(trueSm,-trueSm,abs(ll - 0.65)-0.35);\n    float bgline2 = smoothstep(trueSm,-trueSm,abs(ll - 0.6)-0.27);\n    float bgline3 = smoothstep(trueSm,-trueSm,abs(ll - 0.65)-0.3);\n    float bgwhite = smoothstep(trueSm,-trueSm,abs(ll - 0.6)-0.25);\n    float bgstrips = smoothstep(trueSm,-trueSm,abs(ll - 0.81)-0.03);\n    float bgstrips2 = smoothstep(trueSm,-trueSm,abs(ll - 0.81)-0.018);\n    float bgstrips3 = smoothstep(trueSm,-trueSm,abs(fract(ra * 5.0 + 0.5)-0.5)-0.45);\n    float bgstrips4 = smoothstep(trueSm,-trueSm,abs(fract(ra + 0.5)-0.5)-0.45);\n  \tfloat fresnel = smoothstep(0.2,-0.26,abs(ll - 0.8));\n\n    float fra = floor(ll*1.5) + \n        fract(a *3.0 - mix(floor(rt) - 3./12.,floor(rt)+ 1.- 3./12.,  pow(fract(rt),2.0)) * 3./12.);\n    \n    float arrow =abs(fra-0.5)*2.0 * (ll+0.25) * length(vec2(fra,ll+0.25)-0.5);\n    \n    float num = getNum2(vec2(clamp(fract(ra) *2. - 0.5,0.01,0.99),cll),\n                        int(mod(floor(ra),12.)) + 1,trueSm);\n    \n    float blick = abs(a-0.5)*2.0;\n    vec3 finCol = vec3(fract(a*30.0-l*40.0)*0.1);\n    finCol = mix(finCol, vec3(blick), bgline);\n    finCol = mix(finCol, vec3(1.0-blick), bgline2);\n    finCol = mix(finCol, vec3(1.0), bgwhite);\n    finCol = mix(finCol, vec3(0.0), bgstrips-bgstrips2 * min(bgstrips3,bgstrips4));\n    finCol = mix(finCol, vec3(0.0), num);\n    finCol = mix(finCol, vec3(0.0), fresnel +pow((1.0- l),8.0));\n    finCol = mix(finCol, vec3(smoothstep(0.003,-0.0,arrow)) * 0.5, smoothstep(0.002,0.0015,arrow));\n    \n\tfragColor = vec4(finCol,1.0);\n}\n", "image_inputs": [{"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xllczj.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[138, 138, 157, 157, 235], [237, 237, 256, 256, 322], [324, 324, 368, 368, 614], [616, 616, 661, 661, 959], [961, 961, 982, 982, 1309], [1311, 1311, 1348, 1348, 1513], [1515, 1515, 1572, 1572, 3544]]}
{"id": "XllyD4", "name": "Mathematical constants", "author": "rougier", "description": "A bunch of mathematical constants", "tags": ["math"], "likes": 9, "viewed": 864, "date": "1504853425", "time_retrieved": "2024-06-20T19:01:54.082491", "image_code": "// A bunch of mathematical constants\n\n// The base of natural logarithms (e)\nconst float M_E = 2.71828182845904523536028747135266250;\n\n// The logarithm to base 2 of M_E (log2(e))\nconst float M_LOG2E = 1.44269504088896340735992468100189214;\n\n// The logarithm to base 10 of M_E (log10(e))\nconst float M_LOG10E = 0.434294481903251827651128918916605082;\n\n// The natural logarithm of 2 (loge(2))\nconst float M_LN2 = 0.693147180559945309417232121458176568;\n\n// The natural logarithm of 10 (loge(10))\nconst float M_LN10 = 2.30258509299404568401799145468436421;\n\n// Pi, the ratio of a circle's circumference to its diameter.\nconst float M_PI = 3.14159265358979323846264338327950288;\n\n// Pi divided by two (pi/2)\nconst float M_PI_2 = 1.57079632679489661923132169163975144;\n\n// Pi divided by four  (pi/4)\nconst float M_PI_4 = 0.785398163397448309615660845819875721;\n\n// The reciprocal of pi (1/pi)\nconst float M_1_PI = 0.318309886183790671537767526745028724;\n\n// Two times the reciprocal of pi (2/pi)\nconst float M_2_PI = 0.636619772367581343075535053490057448;\n\n// Two times the reciprocal of the square root of pi (2/sqrt(pi))\nconst float M_2_SQRTPI = 1.12837916709551257389615890312154517;\n\n// The square root of two (sqrt(2))\nconst float M_SQRT2 = 1.41421356237309504880168872420969808;\n\n// The reciprocal of the square root of two (1/sqrt(2))\nconst float M_SQRT1_2 = 0.707106781186547524400844362104849039;\n\n// 1 degree in radians\nconst float degree = 180.0/M_PI;\n\n// 1 radian in degrees\nconst float radian = M_PI/180.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XllyD4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1459, 1516, 1573, 1573, 1663]]}
{"id": "XllyRS", "name": "Fire Starter", "author": "leon", "description": "Inspired by a private joke with GLKT on a road trip in California. 'Fire Starter' have to be read like the song of Prodigy.", "tags": ["fire"], "likes": 29, "viewed": 598, "date": "1505350682", "time_retrieved": "2024-06-20T19:01:54.088577", "image_code": "\n// Leon 14 / 09 / 2017\n// using lines of code of IQ, Mercury, LJ, Koltes, Duke\n\n#define MAX_STEPS 50.\n#define VOLUME_BIAS .001\n#define MIN_STEP_DIST .001\n#define PI 3.14159\n#define TAU 2.*PI\n#define orange vec3(1, 0.603, 0.078)\n\nfloat hash (float n) { return fract(sin(n)*43758.5453); }\nfloat noiseIQ( vec3 x ) {\n  vec3 p = floor(x);\n  vec3 f = fract(x);\n  f       = f*f*(3.0-2.0*f);\n  float n = p.x + p.y*57.0 + 113.0*p.z;\n  return mix(mix(mix( hash(n+0.0), hash(n+1.0),f.x),\n   mix( hash(n+57.0), hash(n+58.0),f.x),f.y),\n  mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\nfloat fbm (vec3 p, vec3 speed) {\n    float value = 0.0;\n    float amplitud = .5;\n    for (float i = 1.; i <= 6.; i++) {\n        value += amplitud * noiseIQ(p);\n        p *= 2.;\n    \tp += speed;\n        amplitud *= .5;\n    }\n    return value;\n}\n\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,s,-s,c); }\n\nfloat sdSphere (vec3 p, float r) { return length(p)-r; }\nfloat sdCylinder (vec2 p, float r) { return length(p)-r; }\nfloat sdCylinder (vec3 p, vec3 c) { return length(p.xz-c.xy)-c.z; }\nfloat sdBox (vec3 p, vec3 b) { vec3 d = abs(p) - b; return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)); }\n\nvec3 moda (vec2 p, float count) {\n    float an = TAU/count;\n    float a = atan(p.y,p.x)+an/2.;\n    float c = floor(a/count);\n    a = mod(a,an)-an/2.;\n    return vec3(vec2(cos(a),sin(a))*length(p),c);\n}\n\nfloat smin (float a, float b, float k) {\n    float h = clamp(.5+.5*(b-a)/k, 0., 1.);\n    return mix(b,a,h)-k*h*(1.-h);\n}\n\n// text\n#define grid 16.\n#define cell 1./16.\nconst int kA=177,kB=178,kC=179,kD=180,kE=181,kF=182,kG=183,kH=184,kI=185,kJ=186,kK=187;\nconst int kL=188,kM=189,kN=190,kO=191,kP=160,kQ=161,kR=162,kS=163,kT=164,kU=165,kV=166;\nconst int kW=167,kX=168,kY=169,kZ=170,kSpace=80;\nvec2 getSymbol (int key) { return vec2(mod(float(key),grid),floor(float(key)/grid)); }\nvec2 getLetterUV (vec2 target, vec2 offset) {\n    vec2 uvLetter = target;\n    uvLetter.x = uvLetter.x * 0.45 + 0.017;\n    uvLetter += offset / grid;\n    float crop = step(target.x, cell) * step(target.y, cell);\n    crop *= step(0., target.x) * step(0., target.y);\n    return uvLetter * crop;\n}\n\nfloat getText1 (vec2 target) {\n    int symbols[] = int[] ( kF,kI,kR,kE );\n    int count = symbols.length();\n    vec2 space = vec2(0.5,1);\n    vec2 textUV = vec2(0);\n    for (int i = 0; i < count; ++i) {\n        vec2 offset = vec2(i,0)/grid;\n        offset.x -= float(count)/grid/2.;\n        offset.y -= cell/2.;\n    \ttextUV += getLetterUV(target - offset, getSymbol(symbols[i]));\n    }\n    return (texture(iChannel0, textUV, -100.0) + vec4(0.0, 0.0, 0.0, 0.000000001)).w - 0.5+1.0/256.0;\n}\n\nfloat getText2 (vec2 target) {\n    int symbols[] = int[] ( kS,kT,kA,kR,kT,kE,kR );\n    int count = symbols.length();\n    vec2 space = vec2(0.5,1);\n    vec2 textUV = vec2(0);\n    for (int i = 0; i < count; ++i) {\n        vec2 offset = vec2(i,0)/grid;\n        offset.x -= float(count)/grid/2.;\n        offset.y -= cell/2.;\n    \ttextUV += getLetterUV(target - offset, getSymbol(symbols[i]));\n    }\n    return (texture(iChannel0, textUV, -100.0) + vec4(0.0, 0.0, 0.0, 0.000000001)).w - 0.5+1.0/256.0;\n}\n\nfloat map (vec3 pos) {\n    float scene = 1.;\n    \n    // fire\n    vec3 posNoisy = pos*2.;\n    posNoisy.xz *= rot(iTime);\n    vec3 timeNoisy = 5.*vec3(iTime*.6,iTime*-.9,iTime*.8);\n    float noisy = fbm(posNoisy, timeNoisy);\n    vec3 posFire = pos;\n    vec3 plankSize = vec3(2.,.5,.1);\n    posFire.x /= 2.;\n    float height = 3.;\n    posFire.y -= noisy*height-plankSize.y*2.;\n    scene = sdSphere(posFire, noisy*3.);\n    scene = max(scene, -sdSphere(posFire, .6));\n    \n    // text\n    vec2 posText = pos.xy / 10.;\n    vec3 crop = vec3(1000,1000,plankSize.z);\n    posText.y /= 2.;\n    posText.y -= .04;\n    float text = getText1(posText);\n    text = max(text, sdBox(pos, crop));\n    scene = min(scene, text);\n    posText *= 1.75;\n    posText.y += .06;\n    text = getText2(posText);\n    text = max(text, sdBox(pos, crop));\n    scene = min(scene, text);\n    \n    return scene;\n}\n\nfloat rand(vec2 p) { return fract(sin(dot(p*.16545,vec2(55.654654,50.16354)))*65198.); }\n\nvoid mainImage( out vec4 color, in vec2 coord )\n{\n    vec2 uvScreen = coord.xy/iResolution.xy;\n\tvec2 uv = (coord.xy-.5*iResolution.xy)/iResolution.y;\n    vec3 ray = normalize(vec3(uv,1.));\n    vec3 eye = vec3(uv, -4.) + vec3(0,.75,0);\n    vec3 pos = eye;\n    float steps = 0.;\n    for (float i = 0.; i < MAX_STEPS; ++i) {\n        float dist = map(pos);\n        if (dist < VOLUME_BIAS) {\n            steps += 1. / MAX_STEPS;\n            //steps = 1. - i / MAX_STEPS;\n            //break;\n        }\n        dist = abs(dist)*(.8+.2*rand(uvScreen+fract(iTime)));\n        dist = max(MIN_STEP_DIST, dist);\n        pos += ray * dist;\n    }\n\tcolor = vec4(1);\n    color.rgb = mix(orange, color.rgb, log(steps));\n    color *= clamp(steps,0.,1.);\n}\n            ", "image_inputs": [{"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XllyRS.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1, 230, 252, 252, 287], [288, 288, 313, 313, 624], [626, 626, 658, 658, 869], [871, 871, 891, 891, 941], [943, 943, 977, 977, 999], [1000, 1000, 1036, 1036, 1058], [1059, 1059, 1094, 1094, 1126], [1127, 1127, 1157, 1157, 1240], [1242, 1242, 1275, 1275, 1443], [1445, 1445, 1485, 1485, 1565], [1567, 1837, 1863, 1863, 1923], [1924, 1924, 1969, 1969, 2217], [2219, 2219, 2249, 2249, 2708], [2710, 2710, 2740, 2740, 3208], [3210, 3210, 3232, 3232, 4085], [4087, 4087, 4107, 4107, 4175], [4177, 4177, 4226, 4226, 4914]]}
{"id": "XllyW8", "name": "Virtual Fire", "author": "Karambit", "description": "Work in progress, quite slow atm", "tags": ["raymarching", "sdf", "fire"], "likes": 10, "viewed": 1268, "date": "1504599370", "time_retrieved": "2024-06-20T19:01:54.088577", "image_code": "#define PI 3.14159265359\n\n#define Scale vec3(.8, .8, .8)\n#define K 19.19\n\nbool Postprocess = false;\n\nvec3 hash(vec3 p3)\n{\n\tp3 = fract(p3 * Scale);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nvec3 noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\nvec3 fbm(in vec3 q)\n{\n            vec3 f  = 0.5000*noise( q ); q = m*q*2.01;\n            f += 0.2500*noise( q ); q = m*q*2.02;\n            f += 0.1250*noise( q ); q = m*q*2.03;\n            f += 0.0625*noise( q ); q = m*q*2.04; \n            f += 0.03125*noise( q ); q = m*q*2.05; \n            f += 0.015625*noise( q ); q = m*q*2.06; \n            f += 0.0078125*noise( q ); q = m*q*2.07; \n            f += 0.00390625*noise( q ); q = m*q*2.08;  \n    return vec3(f);\n}\n\nfloat smin( float a, float b )\n{\n\tfloat k = .1;\n    float h = clamp( .5+.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nfloat sdSphere(in vec3 p, in float r)\n{\n    return length(p) - r;\n}\n\nvec3 Fire(in vec3 q)\n{\n    vec3 s = vec3(q) - vec3(0.0,iTime*1.8, 0.0);\n    s = fbm(s);\n    return vec3(max((s.x)*0.9, 0.5*abs(q.x)), smin(s.y, q.y), q.z);\n}\n\nfloat map(in vec3 p)\n{\n    vec3 q = Fire(p);\n    \n    float sphere = sdSphere(q, 1.0);\n    \n    return sphere;\n}\n\nfloat intersect(in vec3 ro, in vec3 rd)\n{\n    float maxD = 5.0;\n    int iterations = 4;\n    float h = 1.0;\n    float t = 0.0;\n    \n    for(int i = 0; i < iterations; i++)\n    {\n        if(h < 0.001 || t > maxD)\n            break;\n        h = map(ro+rd*t);\n        t += h;\n    }\n    if( t>maxD ) t=-1.0;\n    return t;\n    \n}\n\nvec3 PostProcess(in vec2 fc)\n{\n    vec3 oColor = vec3(0.);\n    \n    int vertical = int(mod(fc.x, 6.0));\n    if(vertical < 2) oColor.x = 1.0;\n    else if(vertical >= 2 && vertical < 4) oColor.y = 1.0;\n    else oColor.z = 1.0;\n        \n    \n    float horizontal = (mod(fc.y, 6.0));\n    oColor *= vec3(horizontal/6.0);\n    \n    return oColor;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    //uv=floor(uv*iResolution.xy/6.0)*6.0;\n    //uv=uv/iResolution.xy;\n    \n    \n    vec3 ro = vec3(0.0, 0.85, 2.15);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    float t = 0.0;\n    \n    \n    t = intersect(ro, rd);\n    vec3 pos = ro+rd*t;\n    vec3 fire = vec3(0.0);\n    \n    if(t > 0.0)\n    {\n        vec3 pos = ro+rd*t;\n    \tfire = 1.0 - vec3(t*t-1.0);\n        fire = vec3((fire.x+1.0)*1.5-pos.y, (fire.x+0.8)*1.3-pos.y, (1.9+fire.x*2.0) * smoothstep(-0.1, 0.5, pos.y) );\n    }\n    \n    vec4 Output;\n    \n    if(Postprocess)\n       Output = vec4(PostProcess(fragCoord.xy), 1.0) * vec4(fire*2.0,1.0);\n    else\n       Output = vec4(fire,1.0);\n    \n\tfragColor = Output;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XllyW8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[101, 101, 121, 121, 226], [228, 228, 253, 253, 727], [854, 854, 875, 875, 1318], [1320, 1320, 1352, 1352, 1456], [1459, 1459, 1498, 1498, 1526], [1528, 1528, 1550, 1550, 1685], [1687, 1687, 1709, 1709, 1799], [1801, 1801, 1842, 1842, 2124], [2126, 2126, 2156, 2156, 2467], [2470, 2470, 2527, 2527, 3310]]}
{"id": "XlscD8", "name": "MD5", "author": "rory618", "description": "Maybe a bit overboard when it comes to quick random numbers for a shader.", "tags": ["hash", "md5"], "likes": 7, "viewed": 538, "date": "1504621519", "time_retrieved": "2024-06-20T19:01:54.088577", "image_code": "\nconst int[] s = int[](7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,\n                      5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,\n                      4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,\n                      6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21);\n\nconst uint[] K = uint[](0xd76aa478u, 0xe8c7b756u, 0x242070dbu, 0xc1bdceeeu,\n                        0xf57c0fafu, 0x4787c62au, 0xa8304613u, 0xfd469501u,\n                        0x698098d8u, 0x8b44f7afu, 0xffff5bb1u, 0x895cd7beu,\n                        0x6b901122u, 0xfd987193u, 0xa679438eu, 0x49b40821u,\n                        0xf61e2562u, 0xc040b340u, 0x265e5a51u, 0xe9b6c7aau,\n                        0xd62f105du, 0x02441453u, 0xd8a1e681u, 0xe7d3fbc8u,\n                        0x21e1cde6u, 0xc33707d6u, 0xf4d50d87u, 0x455a14edu,\n                        0xa9e3e905u, 0xfcefa3f8u, 0x676f02d9u, 0x8d2a4c8au,\n                        0xfffa3942u, 0x8771f681u, 0x6d9d6122u, 0xfde5380cu,\n                        0xa4beea44u, 0x4bdecfa9u, 0xf6bb4b60u, 0xbebfbc70u,\n                        0x289b7ec6u, 0xeaa127fau, 0xd4ef3085u, 0x04881d05u,\n                        0xd9d4d039u, 0xe6db99e5u, 0x1fa27cf8u, 0xc4ac5665u,\n                        0xf4292244u, 0x432aff97u, 0xab9423a7u, 0xfc93a039u,\n                        0x655b59c3u, 0x8f0ccc92u, 0xffeff47du, 0x85845dd1u,\n                        0x6fa87e4fu, 0xfe2ce6e0u, 0xa3014314u, 0x4e0811a1u,\n                        0xf7537e82u, 0xbd3af235u, 0x2ad7d2bbu, 0xeb86d391u);\n\n/*\nvoid initK(out int[64] K){\n    for(int i = 0; i < 64; i++){\n        K[i] = int(232. * abs(sin(float(i)+1.)));\n    }\n}\n*/\n\nconst uint A0 = 0x67452301u,\n           B0 = 0xefcdab89u,\n           C0 = 0x98badcfeu,\n           D0 = 0x10325476u;\n\n\nvoid MD5Round(inout uint A, inout uint B, inout uint C, inout uint D, in uint[16] M, uint i){\n    uint F, g;\n    if (i < 16u){\n        F = (B & C) | ((0xffffffffu-B) & D);\n        g = i;\n    } else if (i < 32u) {\n        F = (D & B) | ((0xffffffffu-D) & C);\n        g = (5u*i + 1u) % 16u;\n    } else if (i < 48u) {\n        F = B ^ C ^ D;\n        g = (3u*i + 5u) % 16u;\n    } else {\n        F = C ^ (B | (0xffffffffu-D));\n        g = (7u*i) % 16u;\n    }\n    \n    F = F + A + K[i] + M[g];\n    A = D;\n    D = C;\n    C = B;\n    B = B + (F << s[i]) | (F >> (32-s[i]));\n}\n\nuint[4] MD5( uint[16] M) {\n    uint A = A0, B = B0, C = C0, D = D0;    \n    \n    for(uint i = 0u; i < 64u; i++) {\n        MD5Round(A,B,C,D,M,i);\n    }\n    \n    return uint[](A,B,C,D);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //initK(K);\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uint[16] message;\n    message[0] = 0xffffffffu;\n    message[1] = uint(iFrame);\n    message[2] = floatBitsToUint(uv.x);\n    message[3] = floatBitsToUint(uv.y);\n    message[4] = floatBitsToUint(iResolution.x);\n    message[5] = floatBitsToUint(iResolution.y);\n    message[6] = floatBitsToUint(iTime);\n    \n    uint[4] res = MD5(message);\n    \n    float A = uintBitsToFloat (res[0]),\n          B = uintBitsToFloat (res[1]),\n          C = uintBitsToFloat (res[2]),\n          D = uintBitsToFloat (res[3]);\n    \n\tfragColor = fract(vec4(A,B,C,D));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlscD8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1561, 1804, 1897, 1897, 2369], [2558, 2558, 2615, 2631, 3229]]}
{"id": "XlscDH", "name": "Dispersion", "author": "tdhooper", "description": "Example of dispersion in a transparent material, to get those sweet rainbow effects.", "tags": ["spectrum", "refraction", "glass", "dispersion"], "likes": 66, "viewed": 2636, "date": "1504648946", "time_retrieved": "2024-06-20T19:01:56.234324", "image_code": "/*\n\n\tDispersion\n\t----------\n\n\tCombines multiple samples that vary the refractive\n    index and wavelength.\n\n    This gets expensive for high dispersion values that\n    need more samples to reduce banding.\n\n    I don't think this is physically correct in any way,\n    as I'm using a very crude method to split the\n    visible spectrum.\n\n*/\n\n\n// --------------------------------------------------------\n// CONFIG\n// --------------------------------------------------------\n\n// #define DEBUG\n\nconst float MAX_TRACE_DISTANCE = 5.;\nconst float INTERSECTION_PRECISION = .001;\nconst int NUM_OF_TRACE_STEPS = 50;\n\nconst float REFRACTION_BOUNCES = 3.;\nconst float DISPERSION_SAMPLES = 20.; // Higher = slower but smoother blending\nconst float WAVELENGTH_BLEND_MULTIPLIER = 5.;\n\nconst float DISPERSION = .15; // Try changing\n\n\n// --------------------------------------------------------\n// HG_SDF\n// https://www.shadertoy.com/view/Xs3GRB\n// --------------------------------------------------------\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat smax(float a, float b, float r) {\n    float m = max(a, b);\n    if ((-a < r) && (-b < r)) {\n        return max(m, -(r - sqrt((r+a)*(r+a) + (r+b)*(r+b))));\n    } else {\n        return m;\n    }\n}\n\n\n// --------------------------------------------------------\n// Rotation controls\n// --------------------------------------------------------\n\n#define PI 3.14159265359\n\nfloat time;\n\nmat3 sphericalMatrix(float theta, float phi) {\n    float cx = cos(theta);\n    float cy = cos(phi);\n    float sx = sin(theta);\n    float sy = sin(phi);\n    return mat3(\n        cy, -sy * -sx, -sy * cx,\n        0, cx, sx,\n        sy, cy * -sx, cy * cx\n    );\n}\n\nmat3 mouseRotation(vec2 xy) {\n    vec2 p = (-iResolution.xy + 2. * iMouse.xy) / iResolution.y;\n    \n    if (iMouse.x != 0. && iMouse.y != 0.) {\n        xy = p;\n    }\n\n    float rx, ry;\n\n    rx = (xy.y * .25) * PI;\n    ry = (-xy.x * .25) * PI;\n\n    return sphericalMatrix(rx, ry);\n}\n\n\nmat3 modelRotation() {\n    vec2 defaultRotation = vec2(sin(time * PI * 4.) * .1 + .5);\n    pR(defaultRotation, sin(time * PI * 2.) * .1);\n    \n    float a = time;\n    float r = mix(.2, .8, sin(time * PI * 1.) * .5 + .5);\n\n    defaultRotation = vec2(\n        sin(a * PI * 2.) * r,\n        cos(a * PI * 2.) * r\n    );\n\n    mat3 m = mouseRotation(defaultRotation);\n    return m;\n}\n\n\n// --------------------------------------------------------\n// Spectrum colour palette\n// IQ https://www.shadertoy.com/view/ll2GD3\n// --------------------------------------------------------\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n\n// --------------------------------------------------------\n// Materials\n// --------------------------------------------------------\n\nstruct Material {\n    int id;\n    bool transparent;\n    float refractiveIndex;\n    float dispersion;\n};\n\nMaterial transparentMaterial = Material(\n    0,\n    true,\n    1. / 1.333,\n    DISPERSION\n);\n\nMaterial backMaterial = Material(\n    1,\n    false,\n    0.,\n    0.\n);  \n\n\n// --------------------------------------------------------\n// Modelling\n// --------------------------------------------------------\n\nbool insideTransparency = false;\nbool enableTransparency = true;\n\nstruct Model {\n    float dist;\n    vec2 uv;\n    Material material;\n};\n\nModel newModel() {\n    return Model(\n        1e12,\n        vec2(0),\n        backMaterial\n    );\n}\n\n// checks to see which intersection is closer\nModel opU( Model m1, Model m2 ){\n    if (m1.dist < m2.dist) {\n        return m1;\n    } else {\n        return m2;\n    }\n}\n\nModel backModel(vec3 p) {\n    Model model = newModel();\n    p.z += 2.;\n    model.dist = dot(p, vec3(0,0,1)) - .7;\n    model.uv = vec2(p.x, p.y);\n    return model;\n}\n\nModel mainModel(vec3 p) {\n    Model model = newModel();\n\n    float part, d;\n    float indentOffset = .1;\n    float indentSize = .2;\n    float indentSmooth = .2;\n\n    // Sphere\n    d = length(p) - .3;\n\n    // Mirror\n    p.z *= sign(p.z);\n\n    // Indent\n    p.z -= indentSize + indentOffset;\n    part = length(p) - indentSize;\n    d = smax(d, -part, indentSmooth);\n\n    model.dist = d;\n    return model;\n}\n\nModel transparentModel(vec3 p) {\n    if ( ! enableTransparency) return newModel();\n\n    Model model = mainModel(p);\n    \n    if (insideTransparency) model.dist *= -1.;\n\n    model.material = transparentMaterial;\n    return model;\n}\n\nModel map( vec3 p ){\n    Model model = backModel(p);\n    p *= modelRotation();\n    model = opU(model, transparentModel(p));\n    return model;\n}\n\n\n// --------------------------------------------------------\n// Ray Marching\n// Adapted from: https://www.shadertoy.com/view/Xl2XWt\n// --------------------------------------------------------\n\n\nstruct CastRay {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n    float len;\n};\n\nstruct Hit {\n    Ray ray;\n    Model model;\n    vec3 pos;\n    bool isBackground;\n    vec3 normal;\n    vec3 color;\n};\n\nvec3 calcNormal( in vec3 pos ){\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).dist - map(pos-eps.xyy).dist,\n        map(pos+eps.yxy).dist - map(pos-eps.yxy).dist,\n        map(pos+eps.yyx).dist - map(pos-eps.yyx).dist );\n    return normalize(nor);\n}\n\nHit raymarch(CastRay castRay){\n\n    float currentDist = INTERSECTION_PRECISION * 2.0;\n    Model model;\n\n    Ray ray = Ray(castRay.origin, castRay.direction, 0.);\n\n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        if (currentDist < INTERSECTION_PRECISION || ray.len > MAX_TRACE_DISTANCE) {\n            break;\n        }\n        model = map(ray.origin + ray.direction * ray.len);\n        currentDist = model.dist;\n        ray.len += currentDist;\n    }\n\n    bool isBackground = false;\n    vec3 pos = vec3(0);\n    vec3 normal = vec3(0);\n\n    if (ray.len > MAX_TRACE_DISTANCE) {\n        isBackground = true;\n    } else {\n        pos = ray.origin + ray.direction * ray.len;\n        normal = calcNormal(pos);\n    }\n\n    return Hit(ray, model, pos, isBackground, normal, vec3(0));\n}\n\n\n// --------------------------------------------------------\n// Shading\n// --------------------------------------------------------\n\nfloat makeDots(vec2 uv, float repeat, float size) {\n    uv = mod(uv, 1. / repeat) * repeat;\n    uv -= .5;\n    return smoothstep(size, size * .8, length(uv));\n}\n\nfloat makeLine(float x, float thick) {\n    float start = .5 - thick * .5;\n    float end = .5 + thick * .5;\n    float aa = .01;\n    return smoothstep(start, start + aa, x) - smoothstep(end -aa, end, x);\n}\n\nfloat makeLines(float x, float repeat, float thick) {\n    x = mod(x, 1. / repeat) * repeat;\n    return makeLine(x, thick);\n}\n\nvec3 shadeSurface(Hit hit) {\n    vec3 color = vec3(0);\n\n    if (hit.isBackground) {\n        return color;\n    }    \n    \n    if (hit.model.material.id == 1) {\n        vec2 uv = hit.model.uv;\n        float repeat = 5.;\n        color += makeDots(uv + .5 / repeat, repeat, .1);\n        color += makeLines(uv.x, repeat, .025);\n        color += makeLines(uv.y, repeat, .025);\n    }\n\n    return color;\n}\n\n\n// --------------------------------------------------------\n// Refraction & Dispersion\n// Some refraction logic from https://www.shadertoy.com/view/lsXGzH\n// --------------------------------------------------------\n\nHit marchTransparent(Hit hit, float wavelength) {\n    enableTransparency = true;\n    insideTransparency = false;\n\n    for (float i = 0.; i < REFRACTION_BOUNCES; i++) {\n        if (hit.isBackground || ! hit.model.material.transparent) {\n            return hit;\n        } else {\n\n            // Adjust refractive index for wavelength and dispersion amount\n            float refractiveIndex = hit.model.material.refractiveIndex;\n            float riMin = refractiveIndex;\n            float riMax = refractiveIndex * (1. + hit.model.material.dispersion);\n            refractiveIndex = mix(riMin, riMax, wavelength);\n\n            // Invert when moving from the transparent object to air\n            if (insideTransparency) {\n                refractiveIndex = 1. / refractiveIndex;\n            }\n\n            vec3 rayDirection = refract(hit.ray.direction, hit.normal, refractiveIndex);\n            if (rayDirection == vec3(0)) {\n                // Total internal reflection\n                rayDirection = reflect(hit.ray.direction, hit.normal);\n            } else {\n                insideTransparency = ! insideTransparency;\n            }\n\n            // Don't let the ray get trapped inside a transparent object\n            if (i == REFRACTION_BOUNCES - 1.) {\n                enableTransparency = false;\n                insideTransparency = false;\n            }\n\n            // Move away from the surface before marching\n            float separation = 0.01;\n            float startDistance = separation / abs(dot(rayDirection, hit.normal));\n\n            vec3 rayOrigin = hit.pos + startDistance * rayDirection;\n            CastRay castRay = CastRay(rayOrigin, rayDirection);\n            hit = raymarch(castRay);\n        }\n    }\n    return hit;\n}\n\nvec3 shadeTransparentSurface(Hit hit) {\n    float wavelength;\n    vec3 sampleColor;\n    vec3 color = vec3(0);\n\n    // March for each wavelength and blend together\n    for(float r = 0.; r < DISPERSION_SAMPLES; r++){\n        wavelength = r / DISPERSION_SAMPLES;\n        Hit hit2 = marchTransparent(hit, wavelength);\n        sampleColor = shadeSurface(hit2) * spectrum(wavelength);\n        // I don't have a model for correctly blending wavelengths together\n        // so there's a fudge multiplier to stop the result going grey\n        sampleColor /= DISPERSION_SAMPLES / WAVELENGTH_BLEND_MULTIPLIER;\n        color += sampleColor;\n    }\n\n    return color;\n}\n\n\n// --------------------------------------------------------\n// Main\n// --------------------------------------------------------\n\n// https://www.shadertoy.com/view/Xl2XWt\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in vec3 up )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,up));\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvec3 getColor(vec2 p) {\n\n    vec3 camUp = vec3(0,-1,0);\n    vec3 camTar = vec3(0.);\n    vec3 camPos = vec3(0,0,1.25);\n\n    mat3 camMat = calcLookAtMatrix(camPos, camTar, camUp);\n    float focalLength = 2.;\n    vec3 rayDirection = normalize(camMat * vec3(p, focalLength));\n\n    CastRay castRay = CastRay(camPos, rayDirection);\n    Hit hit = raymarch(castRay);\n\n    #ifdef DEBUG\n        return hit.normal * .5 + .5;\n    #endif\n\n    if ( hit.isBackground || ! hit.model.material.transparent) {\n        return shadeSurface(hit);\n    }\n\n    return shadeTransparentSurface(hit);    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;    \n    vec2 m = iMouse.xy / iResolution.xy;\n\n    time = iTime;\n    time /= 4.;\n    time = mod(time, 1.);\n    \n    p /= 1.5;\n\n    vec3 color = getColor(p);\n\n    fragColor = vec4(color,1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlscDH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[817, 989, 1021, 1021, 1066], [1068, 1068, 1107, 1107, 1266], [1269, 1450, 1496, 1496, 1708], [1710, 1710, 1739, 1739, 1991], [1994, 1994, 2016, 2016, 2371], [2374, 2566, 2634, 2634, 2677], [2679, 2679, 2703, 2703, 2801], [3210, 3481, 3499, 3499, 3578], [3580, 3626, 3658, 3658, 3746], [3748, 3748, 3773, 3773, 3912], [3914, 3914, 3939, 3939, 4317], [4319, 4319, 4351, 4351, 4549], [4551, 4551, 4571, 4571, 4694], [4697, 5134, 5165, 5165, 5422], [5424, 5424, 5454, 5454, 6204], [6207, 6339, 6390, 6390, 6498], [6500, 6500, 6538, 6538, 6703], [6705, 6705, 6758, 6758, 6829], [6831, 6831, 6859, 6859, 7228], [7231, 7447, 7496, 7496, 9187], [9189, 9189, 9228, 9228, 9844], [9976, 10017, 10078, 10078, 10227], [10229, 10229, 10252, 10252, 10807], [10809, 10809, 10866, 10866, 11123]]}
{"id": "XlscRl", "name": "Cubic With Quadratic Segments", "author": "paniq", "description": "Approximating a 1D cubic polynomial curve (black) with several quadratic segments (blue), thus trading polynomial degree for sample points.", "tags": ["approximation", "cubic", "quadratic", "polynomial", "section", "interval"], "likes": 6, "viewed": 448, "date": "1506036560", "time_retrieved": "2024-06-20T19:02:00.549675", "image_code": "// Cubic With Quadratic Segments\n// using 2d vector graphics library (https://www.shadertoy.com/view/lslXW8)\n\n// set to 2,3,4 to see approximation with 2-4 segments\n#define SEGMENTS 2\n\n// 2 segments: matches value and first derivative at the end points,\n// as well as a value in the middle with a sometimes barely visible\n// discontinuity. can get bent fairly out of shape but looks plausible.\n\n// 3 segments: matches seven values evenly spaced from end to end\n// without matching derivatives. looks pretty clean except when derivatives\n// at both ends assume high values with equal sign.\n\n// 4 segments: matches nine values evenly spaced from end to end\n// without matching derivatives. quite convincing even when strongly bent.\n\n// ax^3 + bx^2 + cx + d\nvec4 cubic_coeffs;\n// f(x) = ax^3 + bx^2 + cx + d\nfloat cubic(float x) {\n    float x2 = x*x;\n    float x3 = x2*x;\n    return dot(cubic_coeffs, vec4(x3,x2,x,1.0));\n}\n// f'(x) = 3ax^2 + 2bx + c\nfloat dcubic(float x) {\n    float x2 = x*x;\n    return dot(cubic_coeffs.xyz * vec3(3.0,2.0,1.0), vec3(x2,x,1.0));\n}\n// f''(x) = 6ax + 2b\nfloat ddcubic(float x) {\n    return dot(cubic_coeffs.xy * vec2(6.0,2.0), vec2(x, 1.0));\n}\n// f'''(x) = 6a\nfloat dddcubic(float x) {\n    return cubic_coeffs.x * 6.0;\n}\n// cubic from points at f(0),f(1),f'(0),f'(1)\nvec4 cubic_from_points(float P, float Q, float U, float V) {\n\tfloat a = 2.0*(P - Q) + U + V;\n\tfloat b = (Q - P)*3.0 - 2.0*U - V;\n\tfloat c = U;\n\tfloat d = P;\n\treturn vec4(a,b,c,d);\n}\n\n// approximate a cubic segment \n// f(x) = k0 + k1*x + k2*x^2 + k3*x^3\n// with two quadratic segments\n// g(x) = i0 + i1*x + i2*x^2\n// in the interval (c-h, c+h) with matching first derivatives at f'(c-h) and f'(c+h)\nvoid quadratic_from_cubic(vec4 cubic, float c, float h, out vec3 left, out vec3 right) {\n    float k0 = cubic[0];\n    float k1 = cubic[1];\n    float k2 = cubic[2];\n    float k3 = cubic[3];\n    // 24 ops\n    float c2 = c*c;\n    float c2k3 = c2*k3;\n    float h2k3 = h*h*k3;\n    float ck3 = c*k3;\n    float q0 = (c*(c2k3 + h2k3)) + k0;\n    float q1 = (-3.0*c2k3 - h2k3) + k1;\n    float q2 = 3.0*ck3 + k2;\n    float w2 = 2.0*h*k3;\n    float w0 = w2*c2;\n    float w1 = -4.0*ck3*h;\n    left = vec3(q0 - w0, q1 - w1, q2 - w2);\n    right = vec3(q0 + w0, q1 + w1, q2 + w2); \n}\n\n// approximate a cubic segment \n// f(x) = k0 + k1*x + k2*x^2 + k3*x^3\n// with a quadratic segment\n// g(x) = i0 + i1*x + i2*x^2\n// in the interval (c-h, c+h)\nvec3 quadratic_from_cubic(vec4 cubic, float c, float h) {\n    float k0 = cubic[0];\n    float k1 = cubic[1];\n    float k2 = cubic[2];\n    float k3 = cubic[3];\n    // 14 ops\n    float c2 = c*c;\n    float c3 = c2*c;\n    float h2 = h*h;\n    return vec3(\n\t\t(c3 - c*h2)*k3 + k0,\n        -(3.0*c2 - h2)*k3 + k1,\n        3.0*c*k3 + k2);\n}\n\nvec3 quadratic_coeffs[SEGMENTS];\n#if (SEGMENTS == 4)\nfloat quadratic(float x) { \n    if (x < 0.25) {\n    \treturn dot(quadratic_coeffs[0], vec3(x*x,x,1.0)); \n    } else if (x < 0.5) {\n    \treturn dot(quadratic_coeffs[1], vec3(x*x,x,1.0)); \n    } else if (x < 0.75) {\n    \treturn dot(quadratic_coeffs[2], vec3(x*x,x,1.0)); \n    } else {\n        return dot(quadratic_coeffs[3], vec3(x*x,x,1.0)); \n    }\n}\n#elif (SEGMENTS == 3)\nfloat quadratic(float x) { \n    if (x < 0.333) {\n    \treturn dot(quadratic_coeffs[0], vec3(x*x,x,1.0)); \n    } else if (x < 0.667) {\n    \treturn dot(quadratic_coeffs[1], vec3(x*x,x,1.0)); \n    } else {\n        return dot(quadratic_coeffs[2], vec3(x*x,x,1.0)); \n    }\n}\n#else\nfloat quadratic(float x) { \n    if (x < 0.5) {\n    \treturn dot(quadratic_coeffs[0], vec3(x*x,x,1.0)); \n    } else {\n    \treturn dot(quadratic_coeffs[1], vec3(x*x,x,1.0)); \n    }\n}\n#endif\n\nvoid setup(float t) {\n    \n    cubic_coeffs = cubic_from_points(\n        sin(t*0.57), \n        cos(t*0.37),\n        sin(t*0.22), \n        cos(t*0.69));\n   \n#if (SEGMENTS == 4)\n    quadratic_coeffs[0] = quadratic_from_cubic(cubic_coeffs.wzyx, 0.125, 0.125).zyx;\n    quadratic_coeffs[1] = quadratic_from_cubic(cubic_coeffs.wzyx, 0.375, 0.125).zyx;\n    quadratic_coeffs[2] = quadratic_from_cubic(cubic_coeffs.wzyx, 0.625, 0.125).zyx;\n    quadratic_coeffs[3] = quadratic_from_cubic(cubic_coeffs.wzyx, 0.875, 0.125).zyx;\n#elif (SEGMENTS == 3)\n    quadratic_coeffs[0] = quadratic_from_cubic(cubic_coeffs.wzyx, 0.16667, 0.16667).zyx;\n    quadratic_coeffs[1] = quadratic_from_cubic(cubic_coeffs.wzyx, 0.5, 0.16667).zyx;\n    quadratic_coeffs[2] = quadratic_from_cubic(cubic_coeffs.wzyx, 0.83333, 0.16667).zyx;\n#else\n    vec3 q0, q1;\n    quadratic_from_cubic(cubic_coeffs.wzyx, 0.5, 0.5, q0, q1);\n\tquadratic_coeffs[0] = q0.zyx;\n    quadratic_coeffs[1] = q1.zyx;\n#endif\n    \n}\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1);\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1);\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r);\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r);\nvoid set_source(sampler2D image);\n// control how source changes are applied\nconst int Replace = 0; // default: replace the new source with the old one\nconst int Alpha = 1; // alpha-blend the new source on top of the old one\nconst int Multiply = 2; // multiply the new source with the old one\nvoid set_source_blend_mode(int mode);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add an ellipse path at P with radii RW and RH\nvoid ellipse(vec2 p, vec2 r);\nvoid ellipse(float x, float y, float rw, float rh);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n// add a rectangle at O with size S and rounded corner of radius R\nvoid rounded_rectangle(vec2 o, vec2 s, float r);\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// non-uniformly scale the context by S\nvoid scale(vec2 s);\nvoid scale(float sx, float sy);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    vec2 clip;\n    vec2 scale;\n    float line_width;\n    bool premultiply;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n    int source_blend;\n    bool has_clip;\n};\n\n// save current stroke width, starting\n// point and blend mode from active context.\nContext save();\n// restore stroke width, starting point\n// and blend mode to a context previously returned by save()\nvoid restore(Context ctx);\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\nvoid debug_clip_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\nfloat AA;\nfloat AAINV;\n\n// your draw calls here\n//////////////////////////////////////////////////////////\n\nvoid paint() {\n    float t = iTime;\n    setup(t);\n    float rdot = AAINV*3.0;\n\n    translate(-0.5,0.0);\n    \n    set_source_rgb(vec3(1.0));\n    clear();\n\n    set_line_width_px(1.0);\n    set_source_rgba(0.0,0.0,0.0,0.5);\n    move_to(0.0,-1.0);\n    line_to(0.0,1.0);\n    move_to(1.0,-1.0);\n    line_to(1.0,1.0);\n    stroke();\n    \n    set_source_rgba(0.5,0.0,0.0,0.2);\n    graph1D(cubic);\n    set_source_rgb(vec3(0.0));\n    stroke();\n    graph1D(quadratic);\n    set_source_rgb(0.0,0.0,1.0);\n    stroke();\n     \n    #if 0\n    set_source_rgba(0.0,0.0,0.0,0.1);\n    rectangle(-2.0,-1.0,window.x+2.0,2.0);\n    rectangle(window.y,-1.0,2.0-window.y,2.0);\n\tfill();\n    #endif\n             \n    \n}\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n#define DEFAULT_CLIP_V -1e+20\n\nContext _stack;\n\nvoid init (vec2 fragCoord) {\n    uv = fragCoord.xy / iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n\n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        vec2(DEFAULT_CLIP_V),\n        vec2(1.0),\n        1.0,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0),\n        Replace,\n        false\n    );\n}\n\nvec3 _color = vec3(1.0);\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n    _stack.clip.y = DEFAULT_CLIP_V;\n}\n\nContext save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;\n    vec2 clip = _stack.clip;\n    bool has_clip = _stack.has_clip;\n    // preserve source\n    vec4 source = _stack.source;\n    _stack = ctx;\n    _stack.shape = shape;\n    _stack.clip = clip;\n    _stack.source = source;\n    _stack.has_clip = has_clip;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = vec2(1.0);\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;\n    _stack.scale = vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    _stack.scale *= vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(vec2 s) {\n    transform(mat3(s.x,0.0,0.0,0.0,s.y,0.0,0.0,0.0,1.0));\n}\n\nvoid scale(float sx, float sy) {\n    scale(vec2(sx, sy));\n}\n\nvoid scale(float s) {\n    scale(vec2(s));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color = mix(_color, _stack.source.rgb, _stack.source.a);\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(_color, 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = _color;\n}\n\nvoid add_clip(vec2 d) {\n    d = d / _stack.scale;\n    _stack.clip = max(_stack.clip, d);\n    _stack.has_clip = true;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);\n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n    _stack.clip = vec2(DEFAULT_CLIP_V);\n    _stack.has_clip = false;\n}\n\nvoid debug_gradient() {\n    vec2 d = _stack.shape;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid debug_clip_gradient() {\n    vec2 d = _stack.clip;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color = _color * (1.0 - src_a) + rgba.rgb * dst_a;\n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat min_uniform_scale() {\n    return min(_stack.scale.x, _stack.scale.y);\n}\n\nfloat uniform_scale_for_aa() {\n    return min(1.0, _stack.scale.x / _stack.scale.y);\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA*uniform_scale_for_aa(), 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);\n\treturn wa * wb;\n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n    if (_stack.has_clip) {\n\t    write_color(_stack.source, calc_aa_blur(_stack.clip.x));        \n    }\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*min_uniform_scale() * AAINV;\n}\n\nfloat get_gradient_eps() {\n    return (1.0 / min_uniform_scale()) * AAINV;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    if (_stack.source_blend == Multiply) {\n        _stack.source *= c;\n    } else if (_stack.source_blend == Alpha) {\n    \tfloat src_a = c.a;\n    \tfloat dst_a = _stack.premultiply?1.0:src_a;\n\t    _stack.source =\n            vec4(_stack.source.rgb * (1.0 - src_a) + c.rgb * dst_a,\n                 max(_stack.source.a, c.a));\n    } else {\n    \t_stack.source = c;\n    }\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) {\n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1) {\n    vec2 pa = _stack.position.xy - p0;\n    vec2 ba = p1 - p0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1) {\n    set_source_linear_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p0, p1);\n}\n\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r) {\n    float h = clamp( length(_stack.position.xy - p) / r, 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r) {\n    set_source_radial_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p, r);\n}\n\nvoid set_source_blend_mode(int mode) {\n    _stack.source_blend = mode;\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid rounded_rectangle(vec2 o, vec2 s, float r) {\n    s = (s * 0.5);\n    r = min(r, min(s.x, s.y));\n    o += s;\n    s -= r;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    vec2 df = max(dmin.xz, dmin.yw) + length2(dmax);\n    add_field(df - r);\n}\n\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), r);\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    rounded_rectangle(o, s, 0.0);\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), 0.0);\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\n// from https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n    if (l == 0.0) {\n        return length(p) - ab.x;\n    }\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 r = vec2( ab.x*co, ab.y*si );\n\t\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nvoid ellipse(vec2 p, vec2 r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(sdEllipse(c.xy, r), sdEllipse(c.zw, r)));\n}\n\nvoid ellipse(float x, float y, float rw, float rh) {\n    ellipse(vec2(x,y), vec2(rw, rh));\n}\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 s = sign(pa.xz*ba.y-pa.yw*ba.x);\n    vec2 d = length2(pa - ba.xyxy*h.xxyy);\n    add_field(d);\n    add_clip(d * s);\n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat test_cross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat bezier_sign(vec2 A, vec2 B, vec2 C, vec2 p) {\n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0,\n        step(test_cross(A, B, p) * test_cross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * test_cross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    vec2 shape = vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw));\n    add_field(abs(shape));\n    add_clip(shape);\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(abs(f_x) / length(df_x));\n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t aspect = vec2(iResolution.x / iResolution.y, 1.0);\n\t ScreenH = min(iResolution.x,iResolution.y);\n\t AA = ScreenH*0.4;\n\t AAINV = 1.0 / AA;\n\n    init(fragCoord);\n\n    paint();\n\n    blit(fragColor);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlscRl.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[774, 805, 827, 827, 919], [920, 947, 970, 970, 1062], [1063, 1084, 1108, 1108, 1173], [1174, 1190, 1215, 1215, 1250], [1251, 1297, 1357, 1357, 1478], [1480, 1695, 1783, 1783, 2262], [2264, 2421, 2478, 2478, 2751], [3640, 3640, 3661, 3661, 4605], [10371, 10455, 10469, 10469, 11142], [11296, 11356, 11383, 11383, 11409], [11411, 11471, 11492, 11492, 11599], [11601, 11601, 11638, 11638, 11724], [11726, 11726, 11772, 11772, 11805], [11807, 11945, 11973, 11973, 12433], [12461, 12461, 12480, 12480, 12513], [12515, 12515, 12533, 12533, 12566], [12568, 12568, 12592, 12592, 12696], [12698, 12698, 12714, 12714, 12735], [12737, 12737, 12764, 12786, 13069], [13071, 13071, 13099, 13099, 13333], [13335, 13335, 13359, 13359, 13445], [13447, 13447, 13474, 13474, 13687], [13689, 13689, 13715, 13715, 13943], [13945, 13945, 13967, 13967, 14093], [14095, 14095, 14115, 14115, 14175], [14177, 14177, 14209, 14209, 14236], [14238, 14238, 14259, 14259, 14281], [14283, 14283, 14307, 14307, 14367], [14369, 14369, 14403, 14403, 14427], [14429, 14429, 14443, 14443, 14507], [14509, 14509, 14535, 14535, 14567], [14569, 14569, 14595, 14595, 14616], [14618, 14618, 14641, 14641, 14736], [14738, 14738, 14762, 14762, 14831], [14833, 14833, 14858, 14858, 14905], [14907, 14907, 14924, 14924, 15037], [15039, 15039, 15062, 15062, 15191], [15193, 15193, 15221, 15221, 15349], [15351, 15351, 15375, 15375, 15515], [15517, 15517, 15555, 15555, 15689], [15691, 15691, 15728, 15728, 15763], [15765, 15765, 15792, 15792, 15842], [15844, 15844, 15874, 15874, 15930], [15932, 15932, 15961, 15961, 16142], [16144, 16144, 16166, 16166, 16333], [16335, 16335, 16348, 16348, 16387], [16389, 16389, 16419, 16419, 16448], [16450, 16450, 16483, 16483, 16540], [16542, 16542, 16568, 16568, 16618], [16620, 16620, 16641, 16641, 16706], [16708, 16708, 16732, 16732, 16815], [16817, 16817, 16832, 16832, 16873], [16875, 16875, 16891, 16891, 16929], [16931, 16931, 16949, 16949, 17006], [17008, 17008, 17038, 17038, 17408], [17410, 17410, 17468, 17468, 17506], [17508, 17508, 17537, 17537, 17573], [17575, 17575, 17623, 17623, 17654], [17656, 17656, 17690, 17690, 17749], [17751, 17751, 17828, 17828, 17993], [17995, 17995, 18072, 18072, 18152], [18154, 18154, 18230, 18230, 18346], [18348, 18348, 18424, 18424, 18502], [18504, 18504, 18542, 18542, 18576], [18578, 18578, 18600, 18600, 18646], [18648, 18648, 18675, 18675, 18719], [18721, 18721, 18770, 18770, 19031], [19033, 19033, 19106, 19106, 19160], [19162, 19162, 19194, 19194, 19230], [19232, 19232, 19288, 19288, 19344], [19346, 19346, 19376, 19376, 19469], [19470, 19470, 19510, 19510, 19533], [19535, 19581, 19620, 19620, 20776], [20778, 20778, 20808, 20808, 20910], [20912, 20912, 20964, 20964, 21004], [21006, 21006, 21028, 21028, 21079], [21081, 21081, 21113, 21113, 21135], [21137, 21152, 21174, 21174, 21466], [21468, 21468, 21500, 21500, 21522], [21524, 21524, 21543, 21543, 21575], [21624, 21687, 21729, 21729, 21795], [21797, 21867, 21918, 21918, 22270], [22272, 22306, 22352, 22352, 22864], [22866, 22935, 22981, 22981, 23487], [23489, 23489, 23522, 23522, 23738], [23740, 23740, 23799, 23799, 23844], [23846, 23846, 23889, 23889, 23950], [23952, 23952, 23994, 23994, 24036], [24038, 24098, 24155, 24155, 24354]]}
{"id": "XlscWf", "name": "Islamic ornaments00", "author": "knighty", "description": "Islamic geometric art ornament. Obtained through foldings and ray mirroring.\nRef: G.S. Kaplan: \"Computer Graphics and Geometric Ornamental Design\", P.H.D. thesis, 2002.\n[url]http://www.cgl.uwaterloo.ca/csk/phd/kaplan_diss_full_print.pdf[/url]", "tags": ["2d", "stars", "pattern", "tiling", "art", "islamic", "ornament"], "likes": 31, "viewed": 695, "date": "1506778028", "time_retrieved": "2024-06-20T19:02:01.834705", "image_code": "/*\nIslamic geometric art ornament. Obtained through foldings and ray mirroring. There is still\nsome work to do:\n- More comments :P\n\nRef: G.S. Kaplan: \"Computer Graphics and Geometric Ornamental Design\", P.H.D. thesis, 2002.\n[url]www.cgl.uwaterloo.ca/csk/phd/kaplan_diss_full_print.pdf[/url]\n\nShader by knighty.\n\nLicence: public domain.\n\n*/\n\n//Gamma attempt\n#define GAMMA 2.2\n\n//uncomment me!\n//#define SIMPLE\n\n//Make it dance!\n#define WOBBLE 0.7\n\n//Comment me! Looks better and less complicated but without animation.\n//There is an \"error\" thought.\n#define VARIANT2\n\nfloat aaScale;\nfloat lineWidth = 0.;\nvec3 linesCol = vec3(0.6,0.75,.8);\nvec3 linesBorderCol = vec3(0.,0.,0.);\n\n//foldings constants\nconst vec2 rect = vec2(1.,1.3763819204711735382072095819109);// vec2(1, tan(3PI/10))\nconst vec3 f0 = vec3(0.80901699437494742410229341718282, -0.58778525229247312916870595463907, 0.);// vec3(cos(2PI/10, -sin(2PI/10),0)\nconst vec3 f1 = vec3(-0.58778525229247312916870595463907,-0.80901699437494742410229341718282, 0.85065080835203993218154049706301);// vec3(-sin(2PI/10), -cos(2PI/10),1/(2cos(3PI/10)))\nconst vec3 f2 = vec3(0.30901699437494742410229341718282,-0.95105651629515357211643933337938, 0.);// vec3(sin(PI/10), -cos(PI/10),0)\nconst vec3 f3 = vec3(0.,1., 0.);// for reference. We'll simply use abs(p.y)\nconst vec3 f4 = vec3(-0.58778525229247312916870595463907,-0.80901699437494742410229341718282, 0.52573111211913360602566908484788);// vec3(-sin(2PI/10), -cos(2PI/10),1/2*cos(2PI/10)*tg(PI/10))\nconst vec3 f5 = vec3(0.,1., 0.);// for reference. We'll simply use abs(p.y)\n#ifdef VARIANT2\nconst vec3 f6 = vec3(-0.95105651629515357211643933337938,-0.30901699437494742410229341718282, 0.85065080835203993218154049706301);// vec3(-cos(PI/10), -sin(PI/10),1/(2cos(3PI/10)))\n#endif\n\n//Ray\nstruct Ray{\n    vec2 O;\n    vec2 D;\n};\n//Starting ray\n#ifdef VARIANT2\nRay firstRay = Ray(vec2(0.80901699437494742410229341718282,0.26286555605956680301283454242394),//vec2(cos(PI/10),0)/(2cos(3PI/10))\n                   vec2(0.,1.));\n#else\nRay firstRay = Ray(vec2(1.,0.12410828034667904628607373958239),//vec2(1,2sin(PI/10)tg²(PI/10))\n                   vec2(-0.95105651629515357211643933337938,-0.30901699437494742410229341718282));// -vec2(cos(PI/10),sin(PI/10));\n#endif\n\nvoid reflectRay(inout Ray ray, in vec3 mirror){\n    //we assume that ray direction and mirror normal are normalized.\n    float nd = dot(mirror.xy, ray.D);\n    float t = -(mirror.z + dot(mirror.xy, ray.O))/nd;\n    ray.O += t * ray.D;\n    ray.D -= 2. * nd * mirror.xy;\n}\n\nfloat sideRay(in Ray ray, vec2 p){\n    p -= ray.O;\n    return ray.D.y * p.x - ray.D.x * p.y;\n}\n\nfloat sideRay(in Ray ray, vec2 p, inout float r){\n    float t = (sideRay(ray, p) < 0.) ? 1. : 0.;\n    t += r; if(t > 1.) t=0.;//xor with r... I haven't integer support.\n    r = (r == 0.) ? 1. : 0.; \n    return t;\n}\n\n//Mirrors that reflect the ray\n// are f2 and f3 for default variant and f2,f3 and f4 for the variant 2\n\n// Folds the plane about the line L\nint lineFold(inout vec2 p, in vec3 L){\n\tfloat t = -(dot(p,L.xy) + L.z);\n\tp += 2. * max(0.,t) * L.xy;\n\treturn int(t > 0.);\n}\n\n// Folds the plane about some symmetry lines.\n// Returns the number of folds performed.\nint fold(in vec2 p, out vec2 z){\n\tint nbrFold = 0;\n\t//fold into the rectangle rect. first translation by 2*rect then mirror about faces of rect.\n\tz=mod(p, 2.*rect);\n\tz -= rect;\n\tnbrFold += int(z.x>0.); nbrFold += int(z.y>0.);\n\tz = -abs(z) + rect;\n    \n\t// Other folds\n\tnbrFold += lineFold(z, f0);\n\tnbrFold += lineFold(z, f1);\n    nbrFold += lineFold(z, f2);\n\tnbrFold += int(z.y < 0.); z.y = abs(z.y);//same as lineFold(z, f3);\n#ifdef VARIANT2\n    nbrFold += lineFold(z, f6);\n#endif\n    nbrFold += lineFold(z, f4);\n\tnbrFold += int(z.y < 0.); z.y = abs(z.y);//same as lineFold(z, f5);\n\t\t\n\treturn nbrFold;\n}\n\nfloat segDist(vec2 p, vec2 a, vec2 b){\n\tp -= a; b -=a;\n\tfloat t = clamp(dot(p,b) / dot(b,b), 0., 1.);\n\treturn length(p - t * b);\n}\n\nfloat segDistNoClamp(vec2 p, vec2 a, vec2 b){\n\tp -= a; b -=a;\n\tfloat t = dot(p,b) / dot(b,b);\n\treturn length(p - t * b);\n}\n\n//The profile of the lines for opacity and color\nfloat profile(float x, float width, float pixWidth){\n    float a = -.5/pixWidth;\n    float b = -a * (width + pixWidth);\n    return smoothstep(0., 1., a * x + b);\n}\n\nvec4 combine(vec4 up, vec4 dn){\n    if(up.w*dn.w == 1.)\n        return vec4(0.,0.,0.,1.);\n    return vec4(mix(up.rgb, dn.rgb * (1.-dn.w), up.w)/(1. - up.w * dn.w),\n                up.w * dn.w);\n}\n\nvec4 stepIt(vec4 pcol, vec2 z, Ray ray, float parity){\n    float d = segDistNoClamp(z, ray.O, ray.O + ray.D);\n    float po = 1. - profile(d, lineWidth+2.*aaScale, aaScale);\n    float pc = profile(d, lineWidth, aaScale);\n    //vec3 col = pc * linesCol;\n    vec3 col = mix(linesBorderCol, linesCol, pc);\n    \n    if(parity < .5)\n        return combine(vec4(col,po), pcol);\n    else\n        return combine(pcol, vec4(col,po));\n}\n\n#ifndef SIMPLE\nvec4 drawIt(vec2 z, float parity){\n    Ray ray = firstRay;\n    vec4 col = vec4(1., 1., 1., 1.);\n    float tc = 0., r = 0.;\n    \n    col = stepIt(col, z, ray, parity);\n    tc += sideRay(ray, z, r);\n#ifdef VARIANT2\n    reflectRay(ray, f4);\n    col = stepIt(col, z, ray, parity);\n    tc += sideRay(ray, z, r);\n#endif\n    reflectRay(ray, f3);\n    col = stepIt(col, z, ray, parity);\n    tc += sideRay(ray, z, r);\n    \n    reflectRay(ray, f2);\n    col = stepIt(col, z, ray, parity);\n    tc += sideRay(ray, z, r);\n    \n#ifdef VARIANT2\n    reflectRay(ray, f3);\n    col = stepIt(col, z, ray, parity);\n    tc += sideRay(ray, z, r);\n    \n    /*reflectRay(ray, f2);\n    col = stepIt(col, z, ray, parity);\n\ttc += sideRay(ray, z, r);\n    */\n#endif\n    vec4 col1 = vec4(pow(vec3(0.75+0.25*sin(tc*tc*3.2+iTime),\n               0.75+0.25*sin(tc*1.5+iTime*.7),\n               0.75+0.25*sin(tc*tc*4.2+iTime*.3)), vec3(GAMMA)),\n               0.);\n    return combine(col, col1);\n}\n\n#else\n\n//Simple drawing. Not used. useful to see the action of the folding.\n//in order to use it, uncomment the \"#define SIMPLE\" above ^^^ \nvec4 drawIt(vec2 z, float parity){\n    \n    Ray ray = firstRay;\n    \n    float d = segDist(z, ray.O, ray.O + ray.D);\n#ifdef VARIANT2\n    reflectRay(ray, f4);\n    d = min(d, segDist(z, ray.O, ray.O + ray.D));\n#endif\n    reflectRay(ray, f3);\n    d = min(d, segDist(z, ray.O, ray.O + ray.D));\n    reflectRay(ray, f2);\n    d = min(d, segDist(z, ray.O, ray.O + ray.D));\n    /*reflectRay(ray, f3);\n    d = min(d, segDist(z, ray.O, ray.O + ray.D));\n    reflectRay(ray, f2);\n    d = min(d, segDist(z, ray.O, ray.O + ray.D));\n    */\n    return vec4(vec3(0.7 + 0.6* (parity)) *clamp(d*100., 0., 1.), 1.);\n}\n\n#endif\n\n//\nvoid initRay(vec2 p){\n    linesCol = pow(linesCol,vec3(GAMMA));\n    linesBorderCol = pow(linesBorderCol,vec3(GAMMA));\n    lineWidth = sin(0.2 * iTime)*0.01+0.015;\n#ifdef VARIANT2 \n    float ang = 0.12 * sin(iTime + WOBBLE * p.x);\n    float d = firstRay.O.y * tan(ang);\n    firstRay.O.x -= d; firstRay.O.y =0.;\n    firstRay.D = vec2(sin(ang), cos(ang));\n#endif    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat scaleFactor= 5.;//0.05*iMouse.y;\n\tvec2 p = scaleFactor*(fragCoord.xy-0.5*iResolution.xy) / iResolution.y;\n\taaScale=0.75*scaleFactor/iResolution.y;\n    \n    initRay(p);\n    \n    vec2 z = vec2(0.);\n\tint nbrFold = fold(p, z);\n    float parity = 1. - fract(float(nbrFold) * 0.5) * 2.;\n\n\tfragColor = drawIt(z, parity);\n    fragColor.xyz = pow(fragColor.xyz, vec3(1./GAMMA));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "public-domain", "thumbnail": "https://www.shadertoy.com/media/shaders/XlscWf.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1827, 2263, 2310, 2379, 2531], [2533, 2533, 2567, 2567, 2627], [2629, 2629, 2678, 2678, 2843], [2949, 2985, 3023, 3023, 3108], [3110, 3198, 3230, 3230, 3802], [3804, 3804, 3842, 3842, 3934], [3936, 3936, 3981, 3981, 4058], [4060, 4109, 4161, 4161, 4272], [4274, 4274, 4305, 4305, 4469], [4471, 4471, 4525, 4525, 4896], [6621, 6624, 6645, 6645, 6989], [6991, 6991, 7048, 7048, 7427]]}
{"id": "XlsczS", "name": "N-gon signed distance field", "author": "etale_cohomology", "description": "Fork of https://www.shadertoy.com/view/MlcXDB\n\nA signed distance field for a regular n-gon on the plane.... I think", "tags": ["2d", "simple", "antialias", "distance", "field", "geometry", "ngon", "signed"], "likes": 7, "viewed": 321, "date": "1505301280", "time_retrieved": "2024-06-20T19:02:01.834705", "image_code": "// Fork of https://www.shadertoy.com/view/MlcXDB\n\n#define NGON_NSIDES_MIN 3.\n#define NGON_NSIDES_MAX 16.\n\n#define time (.25 * iTime)\n\n#define PI  3.14159\n#define XI  (.5 * PI)\n#define TAU (2. * PI)\n\n// SDF stolen from https://www.shadertoy.com/view/MlcXDB\nfloat sdf_ngon(vec2 uv, float radius, float nsides){\n  float angle = atan(uv.y, uv.x) + XI;\n  float split = TAU / nsides;\n  return length(uv) * cos(split * floor(.5 + angle / split) - angle) - radius;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv =  (2. * fragCoord - iResolution.xy) / iResolution.y;\n\n    vec2  ngon_uv = uv - .25 * vec2(2. * cos(iTime), sin(2. * iTime));  // Displace!\n          ngon_uv *= mat2(cos(time), sin(time), -sin(time), cos(time));  // Rotate!\n    float ngon_radius = .5;\n    float ngon_nsides = NGON_NSIDES_MIN + floor(mod(iTime, NGON_NSIDES_MAX - NGON_NSIDES_MIN + 1.));\n    float ngon_antialias = 5. / iResolution.y;\n    float ngon = smoothstep(ngon_antialias, .0, sdf_ngon(ngon_uv, ngon_radius, ngon_nsides));\n\n    fragColor.rgb = vec3(ngon);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlsczS.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[199, 256, 308, 308, 458], [460, 460, 514, 514, 1055]]}
{"id": "Xlsyzf", "name": "Compositing", "author": "iq", "description": "Compares compositing layers back to front and front to back. This can be done easily by using premultiplied alpha. Also, blending in linear space.", "tags": ["2d", "blending", "compositing", "over"], "likes": 31, "viewed": 1793, "date": "1505805138", "time_retrieved": "2024-06-20T19:02:01.841494", "image_code": "// The MIT License\n// Copyright © 2017 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Compares compositing layers back to front and front to back.\n// Inspired by ollj's https://www.shadertoy.com/view/4tscRf\n\n\n// enable to try back_to_front compositing\n//#define BACK_TO_FRONT\n\n\n\nconst float kGamma = 2.2;   // set this to 1.0 to see the wrong way to blend colors (the way Photoshop does)\n\nvec4 over( in vec4 a, in vec4 b )\n{\n    return a + b*(1.0-a.w);\n}\n\nvec4 gamma2linear_premultalpha( vec4 c )\n{\n    return vec4( pow( c.xyz, vec3(kGamma) )*c.w, c.w);\n}\n\nvec4 linear2gamma_premultalpha( vec4 c )\n{\n    return vec4( pow(c.xyz/c.w,vec3(1.0/kGamma) ), 1.0 );\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u = (-iResolution.xy+2.0*fragCoord)/min(iResolution.x,iResolution.y);\n\n    // patterns\n    float patChecker = mod(floor(3.0*u.x)+floor(3.0*u.y),2.0);\n    float patCircle1 = 1.0-smoothstep(-0.2,0.2,length(u-.4*sin(0.43*iTime+vec2(0.0,1.0)))-0.7);\n    float patCircle2 = 1.0-smoothstep(-0.2,0.2,length(u-.4*sin(0.41*iTime+vec2(3.0,2.0)))-0.7);\n    float patCircle3 = 1.0-smoothstep(-0.2,0.2,length(u-.4*sin(0.53*iTime+vec2(4.0,1.0)))-0.7);\n    \n    // colors. Note gamma and premultiplication\n    vec4 c0 = gamma2linear_premultalpha(vec4(vec3(patChecker*.2+.7),1.0));\n    vec4 c1 = gamma2linear_premultalpha(vec4(.9,.1,.1,patCircle1));\n    vec4 c2 = gamma2linear_premultalpha(vec4(.1,.9,.1,patCircle2));\n    vec4 c3 = gamma2linear_premultalpha(vec4(.1,.1,.9,patCircle3));\n\n    vec4 cr;\n    \n    // Compositing of layers!\n    //  First, back to front\n    //  Second, front to back\n    // These two versions below should result in the same image\n    \n    #ifdef BACK_TO_FRONT\n     cr = c0;           // checkers background\n     cr = over(c1,cr);  // cover with red circle\n     cr = over(c2,cr);  // cover with green circle\n     cr = over(c3,cr);  // cover with blue circle\n    #else    \n     cr = c3;           // blue circle\n     cr = over(cr,c2);  // over green circle\n     cr = over(cr,c1);  // over red circle\n     cr = over(cr,c0);  // over checkers background\n    #endif \n\n    // undo premultiply and gamma, for display\n    fragColor = linear2gamma_premultalpha( cr );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/Xlsyzf.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1302, 1384, 1419, 1419, 1449], [1451, 1451, 1493, 1493, 1550], [1552, 1552, 1594, 1594, 1654], [1660, 1660, 1717, 1717, 3199]]}
{"id": "XlsyzX", "name": "Wave Propagator", "author": "roudy", "description": "Waves with some noise jitter. Trying to get it to appear as though the waves are propagating toward the viewer.", "tags": ["2d", "wave"], "likes": 0, "viewed": 80, "date": "1505765589", "time_retrieved": "2024-06-20T19:02:01.841494", "image_code": "const int waves_per_period = 2;\nconst float period = 4.0;\nconst float time_window_width = 0.1;\nconst float y_jitter_amount = 0.02;\nconst float base_width = 0.08;\n\nfloat logbase(float base, float val) {\n    return log(val)/log(base);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 origin_offset = iResolution.xy / 2.0;\n\tvec2 uv = (fragCoord.xy - origin_offset) / iResolution.xy;\n    float y_jitter_sample = (texture(iChannel0, uv).x - 0.5) * 2.0;\n    float y_jittered = abs(uv.y) + y_jitter_sample * y_jitter_amount; \n    float time_offset = pow(0.5 - abs(y_jittered), 1.5) * period;\n    float period_time = mod(iTime + time_offset, period / float(waves_per_period * 2));\n    float period_time_norm = period_time / period;\n    float window_time_norm = float(period_time_norm <= time_window_width) * period_time_norm\n        \t/ time_window_width;\n    \n    float period_weight = 1.0 - pow(abs(window_time_norm - 0.5), 3.0)\n        \t/ pow(time_window_width, 3.0);\n    period_weight = pow(period_weight, 2.3);\n    \n    float bf = float(0.9 - abs(uv.y) < logbase(0.04,abs(uv.x) - base_width) || abs(uv.x) < base_width);\n    fragColor = bf * period_weight * vec4(0.0, 1.0, 0.0, 1.0) + (1.0 - bf) * vec4(0.0, 0.0, 0.0, 1.0);\n   \n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlsyzX.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[163, 163, 201, 201, 234], [236, 236, 293, 293, 1245]]}
{"id": "XlXcDM", "name": "Eye of God", "author": "KilledByAPixel", "description": "Uses my pixel fractal code with colors generated in a 3x1 array and some warping effects to make it look like an eye. I also lowered the recursion depth and made the colors more bold.", "tags": ["fractal", "zoom", "recursion"], "likes": 26, "viewed": 757, "date": "1504978941", "time_retrieved": "2024-06-20T19:02:02.677307", "image_code": "//////////////////////////////////////////////////////////////////////////////////\n// Eye of God Zoom - Copyright 2017 Frank Force\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//////////////////////////////////////////////////////////////////////////////////\n\nconst float zoomSpeed\t\t\t= 3.0;\t// how fast to zoom (negative to zoom out)\nconst float zoomScale\t\t\t= 0.2;\t// how much to multiply overall zoom (closer to zero zooms in)\nconst int recursionCount\t\t= 4;\t// how deep to recurse\nconst int glyphSize\t\t\t\t= 3;\t// width & height of glyph in pixels\nconst float curvature\t\t\t= -6.0;\t// time warp to add curvature\n\n//////////////////////////////////////////////////////////////////////////////////\n// Precached values and math\n\nconst float glyphSizeF = float(glyphSize);\nconst float glyphSizeLog = log(glyphSizeF);\n\nconst float e = 2.718281828459;\nconst float pi = 3.14159265359;\nfloat RandFloat(int i) { return (fract(sin(float(i)) * 43758.5453)); }\nint RandInt(int i) { return int(100000.0*RandFloat(i)); }\n\nvec3 HsvToRgb(vec3 c) \n{\n    float s = c.y * c.z;\n    float s_n = c.z - s * .5;\n    return vec3(s_n) + vec3(s) * cos(2.0 * pi * (c.x + vec3(1.0, 0.6666, .3333)));\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n// Color and image manipulation\n\nfloat GetRecursionFade(int r, float timePercent)\n{\n    if (r > recursionCount)\n        return timePercent;\n    \n    // fade in and out recusion\n    float rt = max(float(r) - timePercent, 0.0);\n    float rc = float(recursionCount);\n    return rt / rc;\n}\n\nvec3 InitPixelColor() { return vec3(0); }\nvec3 CombinePixelColor(vec3 color, float timePercent, int i, int r, vec2 pos, ivec2 glyphPos, ivec2 glyphPosLast)\n{\n    i = (i+r) + (glyphPosLast.y + glyphPos.y);\n\n    vec3 myColor = vec3\n    (\n    \tmix(-0.3, 0.3, RandFloat(i)),\n    \tmix(0.0, 0.8, RandFloat(i + 10)),\n        mix(0.0, 0.8, RandFloat(i + 20))\n    );\n\n    // combine with my color\n    float f = GetRecursionFade(r, timePercent);\n    myColor.y = pow(myColor.y, 3.0);\n    myColor.z = pow(myColor.z, 3.0);\n    color += myColor*f;\n    return color;\n}\n\nvec3 FinishPixel(vec3 color, vec2 uv)\n{\n    // color wander\n    color.x += 0.01*iTime;\n    \n    // convert to rgb\n    color = HsvToRgb(color);\n    return color;\n}\n\nvec2 InitUV(vec2 uv)\n{\n    float theta = 4.0*pi/4.0;\n\tfloat c = cos(theta);\n\tfloat s = sin(theta);\n\t//uv = vec2((uv.x*c - uv.y*s), (uv.x*s + uv.y*c));\n    \n\t// wave\n\tuv.x += 0.03*sin(7.0*uv.y + 0.17*iTime);\n\tuv.y += 0.03*sin(7.0*uv.x + 0.13*iTime);\n\tuv.x += 0.2*sin(2.0*uv.y + 0.31*iTime);\n\tuv.y += 0.2*sin(2.0*uv.x + 0.27*iTime);\n    return uv;\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n// Fractal functions\n\nivec2 GetFocusPos(int i) { return ivec2(glyphSize/2); }\n      \n// get color of pos, where pos is 0-1 point in the glyph\nvec3 GetPixelFractal(vec2 pos, int iterations, float timePercent)\n{\n\tivec2 glyphPosLast = GetFocusPos(-2);\n\tivec2 glyphPos =     GetFocusPos(-1);\n\tvec3 color = InitPixelColor();\n    \n\tfor (int r = 0; r <= recursionCount + 1; ++r)\n\t{\n        color = CombinePixelColor(color, timePercent, iterations, r, pos, glyphPos, glyphPosLast);\n        if (r > recursionCount)\n\t\t\treturn color;\n           \n        // update pos\n        pos *= glyphSizeF;\n\n        // get glyph and pos within that glyph\n        glyphPosLast = glyphPos;\n        glyphPos = ivec2(pos);\n        \n        // next glyph\n\t\tpos -= vec2(floor(pos));\n\t}\n}\n \n//////////////////////////////////////////////////////////////////////////////////\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// use square aspect ratio\n\tvec2 uv = fragCoord;\n\tuv = fragCoord / iResolution.y;\n\tuv -= vec2(0.5*iResolution.x / iResolution.y, 0.5);\n    uv = InitUV(uv);\n    \n    // time warp\n    float time = iTime + curvature*pow(length(uv), 0.2);\n    \n\t// get time \n\tfloat timePercent = time*zoomSpeed;\n\tint iterations = int(floor(timePercent));\n\ttimePercent -= float(iterations);\n\t\n\t// update zoom, apply pow to make rate constant\n\tfloat zoom = pow(e, -glyphSizeLog*timePercent);\n\tzoom *= zoomScale;\n    \n\t// get offset\n\tvec2 offset = vec2(0);\n    const float gsfi = 1.0 / glyphSizeF;\n\tfor (int i = 0; i < 13; ++i)\n\t\toffset += (vec2(GetFocusPos(i)) * gsfi) * pow(gsfi,float(i));\n    \n\t// apply zoom & offset\n    vec2 uvFractal = uv * zoom + offset;\n\t\n\t// check pixel recursion depth\n\tvec3 pixelFractalColor = GetPixelFractal(uvFractal, iterations, timePercent);\n    pixelFractalColor = FinishPixel(pixelFractalColor, uv);\n    \n\t// apply final color\n\tfragColor = vec4(pixelFractalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlXcDM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[652, 917, 941, 941, 987], [988, 988, 1008, 1008, 1045], [1047, 1047, 1071, 1071, 1211], [1213, 1329, 1379, 1379, 1581], [1583, 1583, 1606, 1606, 1624], [1625, 1625, 1740, 1740, 2136], [2138, 2138, 2177, 2197, 2300], [2302, 2302, 2324, 2324, 2649], [2651, 2756, 2782, 2782, 2811], [2819, 2876, 2943, 2943, 3492], [3495, 3580, 3637, 3665, 4621]]}
{"id": "XlXcRX", "name": "Reflecting Machine", "author": "dr2", "description": " Lots of reflection; still doesn't do much... (mouse enabled)", "tags": ["raytracing", "raymarching", "reflection", "gearwheel"], "likes": 14, "viewed": 651, "date": "1505651673", "time_retrieved": "2024-06-20T19:02:05.659208", "image_code": "// \"Reflecting Machine\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrSphDf (vec3 p, float s);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrFlatCylAnDf (vec3 p, float b, float r, float w, float h);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec2 Rot2D (vec2 q, float a);\n\n#define NBLK 12.\n\nvec3 qnBlk[2], ltDir, vnBlk, qHit, qGear, vnCylOut, oblPos, oblSize;\nvec2 qBlk;\nfloat dstFar, tCur, bEdge, tCyc, tMov, bCylRad, bCylHt, dCylOut;\nint idObj;\nconst int idGr = 1, idPln = 2, idConv = 3, idSup = 4, idAx = 5, idBas = 6,\n   idWhl = 7, idSpl = 8;\nconst float pi = 3.14159;\n\nfloat ObjDf (vec3 p)\n{\n  vec4 a4;\n  vec3 q, bPos;\n  float dMin, d, angRot, r, a;\n  dMin = dstFar;\n  q = p - vec3 (1.13 + bEdge, bEdge, 1.);\n  r = length (q.yz);\n  q.yz = Rot2D (q.yz, -0.5 * pi * tMov / 5.);\n  a = (r > 0.) ? atan (q.z, - q.y) / (2. * pi) : 0.;\n  q.yz = Rot2D (q.yz, 2. * pi * (floor (8. * a + 0.5)) / 8.);\n  q.z = abs (q.z);\n  d = max (min (min (abs (r - 1.01) - 0.1, r - 0.3),\n     max (r - 1., dot (q.yz, vec2 (sin (0.8 * 2. * pi / 32.),\n     cos (0.8 * 2. * pi / 32.))))), abs (q.x) - 0.03);\n  if (d < dMin) { dMin = d;  idObj = idWhl;  qHit = q; }\n  d = PrBoxDf (p - vec3 (0., 0.98, 1.), vec3 (1.12, 0.02, 0.1));\n  d = min (d, PrBoxDf (p - vec3 (-1.018, 0.98, 0.51), vec3 (0.1, 0.02, 0.49 - bEdge)));\n  if (d < dMin) { dMin = d;  idObj = idPln; }\n  d = PrFlatCylAnDf (p - vec3 (-0.05, -0.21, 0.), 1., 0.2, 0.01, 0.1);\n  if (d < dMin) { dMin = d;  idObj = idConv; }\n  q = p - vec3 (-0.05, -0.21, 0.);  q.x = abs (q.x) - 1.;\n  d = PrCylDf (q, 0.19, 0.12);\n  if (d < dMin) { dMin = d;  idObj = idSpl;  qHit = q; }\n  q = p - vec3 (0.65, -0.1, 1.);  q.x = abs (q.x) - 0.3;\n  d = PrRoundBoxDf (q, vec3 (0.01, 1.04, 0.06), 0.02);\n  d = min (d, PrRoundBoxDf (p - vec3 (-1.05, -0.1, 1.), vec3 (0.04, 1.04, 0.01), 0.02));\n  q = p - vec3 (-0.05, -0.6, 0.);  q.xz = abs (q.xz) - vec2 (1., 0.2);\n  d = min (d, PrRoundBoxDf (q, vec3 (0.04, 0.54, 0.01), 0.02));\n  q = p - vec3 (-0.33, -0.6, 1.555);  q.x = abs (q.x) - 0.3;\n  d = min (d, PrRoundBoxDf (q, vec3 (0.01, 0.54, 0.04), 0.02));\n  if (d < dMin) { dMin = d;  idObj = idSup; }\n  q = p - vec3 (0.65, bEdge, 1.);\n  d = PrCylDf (q.yzx, 0.04, 0.62);\n  d = min (d, PrCylDf (p - vec3 (0.95, -0.21, 0.), 0.03, 0.27));\n  d = min (d, min (d, PrCylDf (p - vec3 (-1.05, -0.21, 0.55), 0.03, 0.82)));\n  d = min (d, PrCylDf ((p - vec3 (-0.36, -0.21, 1.555)).yzx, 0.03, 0.51));\n  if (d < dMin) { dMin = d;  idObj = idAx; }\n  d = PrBoxDf (p - vec3 (0., -1.2, 0.9), vec3 (1.6, 0.05, 1.4));\n  if (d < dMin) { dMin = d;  idObj = idBas; }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nfloat GearWlDf (vec3 p, float rad, float wlThk, float tWid, float nt, float angRot, \n   bool bev, float d)\n{\n  p.xy = Rot2D (p.xy, angRot);\n  p.xy = Rot2D (p.xy, floor (nt * atan (p.y, - p.x) / (2. * pi) + 0.5) * 2. * pi / nt);\n  if (bev) p.xy *= 1.2 - 0.2 * p.z / wlThk;\n  return max (d, - rad - 0.95 * (p.x - 2. * clamp (1.5 * tWid +\n     0.5 * p.x * step (0., p.x) - abs (p.y), 0., tWid)));\n}\n\nfloat GearDf (vec3 p)\n{\n  vec3 q;\n  float dMin, angRot, wlThk, tWid, nt, rad, d;\n  dMin = dstFar / 0.3;\n  angRot = 0.1 * pi * tMov;\n  rad = 0.3;\n  wlThk = rad / 7.;\n  tWid = rad / 10.;\n  nt = 20.;\n  q = - (p - vec3 (-1.05, -0.21, 1.3));\n  d = max (length (q.xy) - rad, abs (q.z) - wlThk);\n  if (d < dMin) {\n    d = GearWlDf (q, rad, wlThk, tWid, nt, angRot, true, d);\n    if (d < dMin) { dMin = d;  qGear = q / rad; }\n  } else dMin = min (dMin, d);\n  q = (p - vec3 (-1.05 + 0.85 * rad, -0.21, 1.3 + 0.85 * rad)).yzx;\n  d = max (length (q.xy) - rad, abs (q.z) - wlThk);\n  if (d < dMin) {\n    d = GearWlDf (q, rad, wlThk, tWid, nt, angRot + pi / nt, true, d);\n    if (d < dMin) { dMin = d;  qGear = q / rad; }\n  } else dMin = min (dMin, d);\n  angRot = -0.1 * pi * tMov;\n  rad = 0.39;\n  wlThk = rad / 15.;\n  tWid = rad / 16.;\n  nt = 36.;\n  q = (p - vec3 (0.1, bEdge, 1.)).yzx;\n  d = max (length (q.xy) - rad, abs (q.z) - wlThk);\n  if (d < dMin) {\n    d = GearWlDf (q, rad, wlThk, tWid, nt, angRot, false, d);\n    if (d < dMin) { dMin = d;  qGear = q / rad; }\n  } else dMin = min (dMin, d);\n  q = - (p - vec3 (0.1, -0.21, 1.555)).zyx;\n  d = max (length (q.xy) - rad, abs (q.z) - wlThk);\n  if (d < dMin) {\n    d = GearWlDf (q, rad * 2./3., wlThk, tWid, nt * 2./3., angRot * 3./2., false, d);\n    if (d < dMin) { dMin = d;  qGear = q / rad; }\n  } else dMin = min (dMin, d);\n  return 0.3 * dMin;\n}\n\nfloat GearRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 250; j ++) {\n    d = GearDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 GearNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.0005, -0.0005, 0.);\n  v = vec4 (GearDf (p + e.xxx), GearDf (p + e.xyy), GearDf (p + e.yxy), GearDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.0005, -0.0005, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec4 MvBlkPos (float t)\n{\n  vec3 p;\n  float a;\n  t = mod (t, tCyc);\n  if (t < 20.) {\n    a = 0.;\n    p = vec3 (-1.018 + 2.118 * t / 20., bEdge, 0.);\n  } else if (t < 25.) {\n    a = 0.5 * pi * (t - 20.) / 5.;\n    p = vec3 (1.1, bEdge + 1. * sin (a), 1. - 1. * cos (a));\n  } else if ( t < 45.) {\n    a = 0.5 * pi;\n    p = vec3 (1.1 - 2.118 * (t - 25.) / 20., 1. + bEdge, 1.);\n  } else if (t < 55.) {\n    a = 0.5 * pi;\n    p = vec3 (-1.018, 1. + bEdge, 1. - 1. * (t - 45.) / 10.);\n  } else {\n    t = 0.5 * (t - 55.);\n    a = -0.5 * pi * t;\n    p = vec3 (-1.018, 1. + bEdge - t * t, 0.);\n  }\n  return vec4 (p, a);\n}\n\nfloat MvBlkHit (vec3 ro, vec3 rd)\n{\n  vec4 a4;\n  vec3 rm, rdm, u, v, tm, tp;\n  float dMin, dn, df;\n  dMin = dstFar;\n  for (float k = 0.; k < NBLK; k ++) {\n    a4 = MvBlkPos (tMov + tCyc * k / NBLK);\n    rm = ro - a4.xyz;\n    rdm = rd;\n    rm.zy = Rot2D (rm.zy, a4.w);\n    rdm.zy = Rot2D (rdm.zy, a4.w);\n    v = rm / rdm;\n    tp = bEdge / abs (rdm) - v;\n    tm = - tp - 2. * v;\n    dn = max (max (tm.x, tm.y), tm.z);\n    df = min (min (tp.x, tp.y), tp.z);\n    if (df > 0. && dn < min (df, dMin)) {\n      dMin = dn;\n      vnBlk = - sign (rdm) * step (tm.zxy, tm) * step (tm.yzx, tm);\n      u = (v + dn) * rdm;\n      qBlk = vec2 (dot (u.zxy, vnBlk), dot (u.yzx, vnBlk));\n      vnBlk.zy = Rot2D (vnBlk.zy, - a4.w);\n    }\n  }\n  return dMin;\n}\n\nfloat BlkHit (vec3 ro, vec3 rd, vec3 bSize)\n{\n  vec3 v, tm, tp;\n  float dMin, dn, df;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  v = ro / rd;\n  tp = bSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = max (max (tm.x, tm.y), tm.z);\n  df = min (min (tp.x, tp.y), tp.z);\n  dMin = dstFar;\n  if (df > 0. && dn < df) {\n    dMin = dn;\n    qnBlk[0] = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n    qnBlk[1] = - sign (rd) * step (tp, tp.zxy) * step (tp, tp.yzx);\n  }\n  return dMin;\n}\n\nvoid InCylHit (vec3 ro, vec3 rd)\n{\n  vec3 s;\n  float a, b, w, ws, srdy;\n  dCylOut = dstFar;\n  vnCylOut = vec3 (0.);\n  a = dot (rd.xz, rd.xz);\n  b = dot (rd.xz, ro.xz);\n  w = b * b - a * (dot (ro.xz, ro.xz) - bCylRad * bCylRad);\n  if (w > 0.) {\n    ws = sqrt (w);\n    srdy = sign (rd.y);\n    if (a > 0.) {\n      dCylOut = (- b + ws) / a;\n      s = ro + dCylOut * rd;\n    } else s.y = bCylHt;\n    if (abs (s.y) < bCylHt) vnCylOut.xz = - s.xz / bCylRad;\n    else {\n      dCylOut = (- srdy * ro.y + bCylHt) / abs (rd.y);\n      vnCylOut.y = - srdy;\n    }\n  }\n}\n\n#define SQRT3 1.7320508\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./SQRT3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (SQRT3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec3 HexGrid (vec2 p)\n{\n  vec2 q;\n  p -= HexToPix (PixToHex (p));\n  q = abs (p);\n  return vec3 (p, (SQRT3/2.) - q.x + 0.5 * min (q.x - SQRT3 * q.y, 0.));\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  float sd, f;\n  if (rd.y < 0.) {\n    rd.y = 0.;\n    rd = normalize (rd);\n  }\n  ro.xz += tCur;\n  sd = max (dot (rd, ltDir), 0.);\n  f = Fbm2 (0.04 * (rd.xz * (100. - ro.y) / max (rd.y, 0.001) + ro.xz));\n  col = vec3 (0.15, 0.25, 0.5) + 0.1 * pow (sd, 16.) + 0.2 * pow (sd, 256.);\n  col = mix (col, vec3 (0.9), clamp (3. * (f - 0.5) * rd.y + 0.1, 0., 1.));\n  return col;\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 vn, col, gCol, qh;\n  vec2 qw, iw;\n  float hy, hhy, hw, ww, f, b, aa, sRotH, sRotV;\n  InCylHit (ro + vec3 (0., - bCylHt + 1.25, 0.), rd);\n  if (vnCylOut.y == 0.) {\n    ro += dCylOut * rd;\n    vn = vnCylOut;\n    hy = (ro.y - 1.75) / bCylHt;\n    hhy = abs (hy) - 0.43;\n    aa = atan (vn.x, - vn.z) /pi;\n    sRotH = mod (64. * 0.5 * (1. + aa) + 0.5, 1.) - 0.5;\n    hw = 0.29;\n    ww = 0.28;\n    qw = abs (vec2 (sRotH, hhy));\n    if (qw.x < ww && qw.y < hw) {\n      qw = abs (qw - 0.5 * vec2 (ww, hw)) - vec2 (0.44 * ww, 0.47 * hw);\n      if (max (qw.x, qw.y) < 0.) col = 0.7 * SkyCol (ro, reflect (rd, vn));\n      else col = vec3 (0.5, 0.5, 0.3) * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +\n         0.5 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 128.);\n    } else {\n      col = vec3 (0.8, 0.7, 0.5);\n      qw -= vec2 (ww, hw);\n      if (abs (hy) > (1. - 0.85/16.) || max (qw.x, qw.y) < 0.02) {\n        vn.xz = Rot2D (vn.xz, - pi * aa);\n        if (abs (hy) > (1. - 0.85/16.)) {\n          sRotV = (1. - abs (2. * SmoothBump (1. - 0.9/16., 0.97, 0.03, abs (hy)) - 1.));\n        } else {\n          sRotV = (1. - abs (2. * SmoothBump (hw, hw + 0.02, 0.02, abs (hhy)) - 1.)) * sign (hhy);\n          vn.xz = Rot2D (vn.xz, 0.4 * pi * sign (sRotH) *\n             (1. - abs (2. * SmoothBump (- (ww + 0.02), ww + 0.02, 0.04, sRotH) - 1.)));\n        }\n        vn.yz = Rot2D (vn.yz, -0.2 * pi * sRotV * sign (hy));\n        vn.xz = Rot2D (vn.xz, pi * aa);\n      } else {\n        qw = 16. * vec2 (24. * (0.5 * aa), hy);\n        col *= 1. - 0.3 * Noisefv2 (10. * qw);\n        iw = floor (qw);\n        if (2. * floor (iw.y / 2.) != iw.y) {\n          qw.x += 0.5;\n          iw = floor (qw);\n        }\n        qw = smoothstep (0.07, 0.08, abs (fract (qw + 0.5) - 0.5));\n        col *= (0.8 + 0.2 * qw.x * qw.y);\n      }\n      col = col * (0.3 + 0.7 * max (dot (vn, ltDir), 0.)) +\n         0.1 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 128.);\n    }\n  } else if (vnCylOut.y > 0.) {\n    ro += dCylOut * rd;\n    b = 1. - smoothstep (-0.1, -0.01, rd.y) * smoothstep (0.4, 0.8, dCylOut / (1.6 * bCylRad));\n    qh = HexGrid (4. * ro.zx);\n    f = max (length (qh.xy) - 0.5, 0.) * b;\n    vn = vec3 (0., Rot2D (vec2 (1., 0.), 4. * f * f));\n    vn.zx = vn.z * vec2 (qh.x, - qh.y) / length (qh.xy);\n    vn = VaryNf (50. * ro, vn, 0.2 * b);\n    gCol = vec3 (0.7, 0.7, 0.8) * (1. - 0.1 * b * Noisefv2 (100. * ro.xz));\n    col = gCol * (1. - min (0.2 * b * (1. - smoothstep (0.03, 0.06, qh.z)), 0.1));\n    col = col * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +\n       0.1 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 128.);\n    col *= 0.7 + 0.3 * smoothstep (0., 4., BlkHit (ro + oblPos, ltDir, oblSize));\n  } else col = SkyCol (ro, rd);\n  return col;\n}\n\nvec4 ObjCol (vec3 ro, vec3 vn)\n{\n  vec3 col, q;\n  float spec, r, a, s;\n  if (idObj == idWhl) {\n    col = vec3 (0.7, 0.9, 0.3);\n    q = ro - vec3 (1.13 + bEdge, bEdge, 1.);\n    r = length (q.yz);\n    q.yz = Rot2D (q.yz, -0.5 * pi * tMov / 5.);\n    a = (r > 0.) ? atan (q.z, - q.y) / (2. * pi) : 0.;\n    a = mod (64. * a + 0.5, 1.);\n    if (r > 0.99) vn.yz = Rot2D (vn.yz, - sin (a - 0.5));\n    if (r > 0.92) col *= 0.7 + 0.3 * SmoothBump (0.05, 0.95, 0.01, a);\n    spec = 0.5;\n  } else if (idObj == idGr) {\n    col = vec3 (0.8, 0.7, 0.3);\n    spec = 0.5;\n  } else if (idObj == idSpl) {\n    q = ro - vec3 (-0.05, -0.21, 0.);\n    s = sign (q.x);\n    q.x = abs (q.x) - 1.; \n    q.xy = Rot2D (q.xy, 0.1 * s * pi * tMov);\n    a = atan (q.x, - q.y) / (2. * pi);\n    a = mod (16. * a + 0.5, 1.);\n    if (abs (ro.z) > 0.1) {\n      col = vec3 (0.8, 0.8, 0.85);\n      spec = 0.5;\n    } else col = vec3 (0.4, 0.4, 0.3);\n    col *= 0.5 + 0.5 * SmoothBump (0.05, 0.95, 0.01, a);\n  } else if (idObj == idAx) {\n    col = vec3 (0.8, 0.8, 0.85);\n    spec = 0.5;\n  } else if (idObj == idPln) {\n    col = vec3 (0.3, 0.2, 0.);\n    spec = 0.;\n  } else if (idObj == idConv) {\n    q = ro - vec3 (-0.05, -0.21, 0.);\n    col = vec3 (0.8, 0.8, 0.2);\n    if (abs (q.x) < 1. && abs (vn.y) > 0.99 && sign (vn.y) != sign (q.y))\n       col *= 1. - 0.9 * SmoothBump (0.45, 0.55, 0.03,\n       mod (10. * (q.x - sign (q.y) * mod (0.9 * tMov, 20.) * 0.1 * 2. * pi * 0.19), 1.));\n  } else if (idObj == idSup) {\n    col = vec3 (0.4, 0.3, 0.1);\n  } else if (idObj == idBas) {\n    q = ro;\n    q.z -= 0.9;\n    q.xz = abs (q.xz) - vec2 (1.55, 1.35);\n    col = (max (q.x, q.z) > 0.) ? vec3 (0.2, 0.1, 0.) : vec3 (0., 0.1, 0.05);\n    spec = 0.;\n  }\n  return vec4 (col, spec);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 vn, col, roo, rdo, q;\n  float dstObj, dstGear, dstMvBlk, dstBlk, reflAtn;\n  bool doRefl, hitOrig;\n  oblPos = vec3 (0., -0.05, -0.9);\n  oblSize = vec3 (1.6, 1.3, 1.4);\n  col = BgCol (ro, rd);\n  dstBlk = BlkHit (ro + oblPos, rd, oblSize);\n  roo = ro;\n  rdo = rd;\n  if (dstBlk < dstFar) {\n    tCyc = 57.;\n    tMov = 2. * tCur;\n    bEdge = 0.08;\n    reflAtn = 1.;\n    hitOrig = false;\n    for (int nr = 0; nr < 3; nr ++) {\n      doRefl = false;\n      dstGear = GearRay (ro, rd);\n      dstObj = ObjRay (ro, rd);\n      if (dstGear < min (dstObj, dstFar)) {\n        dstObj = dstGear;\n        idObj = idGr;\n      }\n      dstMvBlk = MvBlkHit (ro, rd);\n      if (dstMvBlk < min (dstObj, dstFar)) {\n        vn = vnBlk;\n        q.xy = abs (qBlk);\n        doRefl = (max (q.x, q.y) < 0.85 * bEdge);\n        if (doRefl) ro += rd * dstMvBlk;\n      } else if (dstObj < dstFar) {\n        q = ro + rd * dstObj;\n        if (idObj == idGr) {\n          if (abs (length (qGear.xy) - 0.38) < 0.17) {\n            vn = GearNf (q);\n            doRefl = true;\n          }\n        } else if (idObj == idBas) {\n          vn = ObjNf (q);\n          q.z -= 0.9;\n          q.xz = abs (q.xz) - vec2 (1.55, 1.35);\n          doRefl = (vn.y > 0. && max (q.x, q.z) < 0.);\n        } else if (idObj == idPln) {\n          vn = ObjNf (q);\n          doRefl = (vn.y > 0.99);\n        } else if (idObj == idWhl) {\n          doRefl = (abs (length (qHit.yz) - 0.61) < 0.45);\n          if (doRefl) vn = ObjNf (q);\n        } else if (idObj == idSpl) {\n          vn = ObjNf (q);\n          doRefl = (abs (vn.z) > 0.99 && abs (length (qHit.xy) - 0.13) < 0.04);\n        }\n        if (doRefl) ro += rd * dstObj;\n      }\n      if (doRefl) {\n        rd = reflect (rd, vn);\n        ro += 0.01 * rd;\n        reflAtn *= 0.9 * reflAtn;\n      } else break;\n    }\n    if (dstMvBlk < min (dstObj, dstFar)) {\n      dstObj = dstMvBlk;\n      ro += rd * dstObj;\n      vn = vnBlk;\n      qBlk = abs (qBlk);\n      col4 = (max (qBlk.x, qBlk.y) > 0.85 * bEdge) ? vec4 (0.3, 1., 0.3, 0.5) :\n         vec4 (0.4, 0.4, 0.4, 0.1);\n    } else if (dstObj < dstFar) {\n      ro += rd * dstObj;\n      vn = (idObj == idGr) ? GearNf (ro) : ObjNf (ro);\n      col4 = ObjCol (ro, vn);\n    } else if (reflAtn < 1.) col = BgCol (ro, rd);\n    if (min (dstMvBlk, dstObj) < dstFar) {\n      col = col4.rgb * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +\n           col4.w * pow (max (dot (normalize (ltDir - rd), vn), 0.), 128.);\n      hitOrig = (reflAtn == 1.);\n    }\n    col *= reflAtn;\n    if (! hitOrig) col *= vec3 (0.95, 1., 0.95) * (0.8 + 0.2 * dot (rdo, - qnBlk[1]));\n    col = mix (col,  vec3 (1.) * (0.2 + 0.8 * max (dot (ltDir, qnBlk[0]), 0.) +\n       0.5 * pow (max (dot (normalize (ltDir - rdo), qnBlk[0]), 0.), 128.)), 0.15);\n    col = mix (col, BgCol (roo, reflect (rdo, qnBlk[0])), pow (1. - abs (dot (rdo, qnBlk[0])), 5.));\n  }\n  col = pow (clamp (col, 0., 1.), vec3 (0.8));\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv;\n  float el, az;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  dstFar = 20.;\n  bCylRad = 16.;\n  bCylHt = 3.;\n  az = -0.85 * pi;\n  el = 0.05 * pi;\n  if (mPtr.z > 0.) {\n    az -= 2. * pi * mPtr.x;\n    el -= 0.7 * pi * mPtr.y;\n  }\n  rd = normalize (vec3 (uv, 4.));\n  ro = vec3 (0., 0., -0.75 * bCylRad);\n  el = clamp (el, 0.015 * pi, 0.4 * pi);\n  ro.yz = Rot2D (ro.yz, el);\n  rd.yz = Rot2D (rd.yz, el);\n  ro.xz = Rot2D (ro.xz, az);\n  rd.xz = Rot2D (rd.xz, az);\n  ltDir = normalize (vec3 (1., 2., -1.));\n  ltDir.yz = Rot2D (ltDir.yz, el);\n  ltDir.xz = Rot2D (ltDir.xz, az);\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrFlatCylAnDf (vec3 p, float b, float r, float w, float h)\n{\n  p.x -= b * clamp (p.x / b, -1., 1.);\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec3 e = vec3 (0.1, 0., 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlXcRX.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 819, 841, 841, 2815], [2817, 2817, 2850, 2850, 3027], [3029, 3029, 3137, 3137, 3424], [3426, 3426, 3449, 3449, 4816], [4818, 4818, 4852, 4852, 5030], [5032, 5032, 5054, 5054, 5262], [5264, 5264, 5285, 5285, 5489], [5491, 5491, 5516, 5516, 6102], [6104, 6104, 6139, 6139, 6841], [6843, 6843, 6888, 6888, 7381], [7383, 7383, 7417, 7417, 7938], [7965, 7965, 7989, 7989, 8219], [8221, 8221, 8245, 8245, 8305], [8307, 8307, 8330, 8330, 8462], [8464, 8464, 8496, 8496, 8879], [8881, 8881, 8912, 8912, 11658], [11660, 11660, 11692, 11692, 13393], [13395, 13395, 13430, 13430, 16359], [16361, 16361, 16417, 16417, 17203], [17205, 17205, 17237, 17237, 17337], [17339, 17339, 17385, 17385, 17432], [17434, 17434, 17467, 17467, 17494], [17496, 17496, 17538, 17538, 17589], [17591, 17591, 17657, 17657, 17757], [17791, 17791, 17815, 17815, 17945], [17947, 17947, 17972, 17972, 18158], [18160, 18160, 18181, 18181, 18336], [18338, 18338, 18367, 18367, 18579], [18581, 18581, 18620, 18620, 18804], [18806, 18806, 18863, 18863, 18946], [18948, 18948, 18978, 18978, 19036]]}
{"id": "XlXcW4", "name": "Integer Hash - II", "author": "iq", "description": "Based on [url=https://www.shadertoy.com/view/4tfyW4]4tfyW4[/url]. but simpler and faster. See [url]https://www.shadertoy.com/view/llGSzw[/url] too.", "tags": ["2d", "hash"], "likes": 57, "viewed": 6027, "date": "1504747362", "time_retrieved": "2024-06-20T19:02:05.895341", "image_code": "// 2017 Inigo Quilez\n\n// Based on https://www.shadertoy.com/view/4tfyW4, but simpler and faster\n//\n// See these too: \n//\n// - https://www.shadertoy.com/view/llGSzw\n// - https://www.shadertoy.com/view/XlXcW4\n// - https://www.shadertoy.com/view/4tXyWN\n//\n// Not testes for uniformity, stratification, periodicity or whatever. Use (or not!) at your own risk\n\n\n  const uint k = 1103515245U;  // GLIB C\n//const uint k = 134775813U;   // Delphi and Turbo Pascal\n//const uint k = 20170906U;    // Today's date (use three days ago's dateif you want a prime)\n//const uint k = 1664525U;     // Numerical Recipes\n\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uvec3 p = uvec3(fragCoord, iFrame);\n    \n    fragColor = vec4( hash(p), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlXcW4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[388, 603, 625, 625, 758], [760, 760, 817, 817, 902]]}
{"id": "XlXcWj", "name": "z33d #1", "author": "z33d", "description": "WIP", "tags": ["webglx"], "likes": 5, "viewed": 165, "date": "1506348452", "time_retrieved": "2024-06-20T19:02:05.895590", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n  float T = iTime/100.0;\n  vec4 M = iMouse;\n  vec3 R = iResolution;\n\n  float k = 0.0;\n\n  for (float i = 0.0; i < 16.0; i++) {\n    vec3 p = vec3((2.0 * fragCoord.xy - R.xy) / R.yy, k - 1.);\n    \n    float a = T * 25.0;\n    p.zy *= mat2(cos(a), -sin(a), sin(a), cos(a));\n    a /= 2.;\n    p.xy *= mat2(cos(a), -sin(a), sin(a), cos(a));\n    a /= 2.;\n    p.zx *= mat2(cos(a), -sin(a), sin(a), cos(a));\n\n    vec3 z = p;\n    float c = 1.0;\n           \n    for (float i = 0.; i < 9.0; i++) {\n      float r = length(z);\n        if (r > 6.0) {\n          k += log(r) * r / c / 2.0;\n          break;\n        }\n\n      float a = acos(z.z / r) * (6.0 + 9.0 * M.x / R.x);\n      float b = atan(z.y, z.x) * (6.0 + 9.0 * M.y / R.y);\n\n      c = pow(r, 7.0) * 5.0 * c / r + 1.0;\n      z = pow(r, 7.0) * vec3(sin(a) * cos(b), -sin(a) * sin(b), -cos(a)) + p;\n    }\n\n    fragColor = vec4(1.0 - i / 16.0 - k + p / 4.0, 1.0);\n\t\n      if (log(length(z)) * length(z) / c < .005) {\n       break;\n    }\n  }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlXcWj.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 1038]]}
{"id": "XlXcWr", "name": "tan_sin_cos", "author": "sgoal", "description": "tan_sin_cos", "tags": ["fun"], "likes": 0, "viewed": 65, "date": "1504249124", "time_retrieved": "2024-06-20T19:02:05.895590", "image_code": "\nvoid circle(vec2 r, vec2 center, float radius, vec3 color, inout vec3 pixel) {\n\tif( length(r-center) < radius) {\n\t\tpixel = color;\n\t}\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv =  2.0*vec2(gl_FragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    vec3 backgroundColor = vec3(1.0);\n\tvec3 color1 = vec3(105,210,231)/255.0;\n    vec3 color2 = vec3(167,219,216)/255.0;\n    vec3 color3 = vec3(224,228,204)/255.0;\n\n    vec3 pixel = backgroundColor;\n    float radius1 = 0.4;\n    circle(uv,vec2(0,0),radius1*abs(cos(iTime)),color1,pixel);\n\n    float radius2 = 0.2;\n    circle(uv,vec2(0,0),radius2*abs(tan(iTime)),color2,pixel);\n\n    float radius3 = 0.24;\n    vec2 circlePos = vec2(0.3,0.4)*sin(iTime);\n    circle(uv,circlePos,radius3*abs(sin(iTime)),color3,pixel);\n\n\n    fragColor = vec4(pixel,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlXcWr.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1, 1, 79, 79, 135], [136, 136, 191, 191, 818]]}
{"id": "XlXyD4", "name": "SDF Ambient Occlusion ", "author": "mhnewman", "description": "Approximate ambient occlusion using signed distance functions in a ray marched scene.", "tags": ["ray", "distance", "occlusion", "ambient", "functions", "march", "signed"], "likes": 44, "viewed": 1693, "date": "1505161015", "time_retrieved": "2024-06-20T19:02:06.671456", "image_code": "// Approximate ambient occlusion using signed distance functions in a ray marched scene.\n// My first attempt at SDF ray marching.\n// Thanks to Jamie Wong for the great tutorial:\n// http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n\nconst int marchIter = 256;\nconst float marchDist = 100.0;\nconst float epsilon = 0.0001;\n\nconst int aoIter = 8;\nconst float aoDist = 0.07;\nconst float aoPower = 2.0;\n\nconst vec3 aoDir[12] = vec3[12](\n\tvec3(0.357407, 0.357407, 0.862856),\n\tvec3(0.357407, 0.862856, 0.357407),\n\tvec3(0.862856, 0.357407, 0.357407),\n\tvec3(-0.357407, 0.357407, 0.862856),\n\tvec3(-0.357407, 0.862856, 0.357407),\n\tvec3(-0.862856, 0.357407, 0.357407),\n\tvec3(0.357407, -0.357407, 0.862856),\n\tvec3(0.357407, -0.862856, 0.357407),\n\tvec3(0.862856, -0.357407, 0.357407),\n\tvec3(-0.357407, -0.357407, 0.862856),\n\tvec3(-0.357407, -0.862856, 0.357407),\n\tvec3(-0.862856, -0.357407, 0.357407)\n);\n\nconst float tau = 6.283185;\n\nvec3 cubePos0;\nmat3 cubeDir0;\nvec3 cubePos1;\nmat3 cubeDir1;\nvec3 cubePos2;\nmat3 cubeDir2;\nvec3 cubePos3;\nmat3 cubeDir3;\nvec3 cubePos4;\nmat3 cubeDir4;\n\nfloat ground(vec3 p) {\n    return p.z;\n}\n\nfloat cube(vec3 p) {\n    return max(length(max(abs(p) - vec3(1.0), 0.0)), length(p) - 1.35);\n}\n\nvoid setCube(float index, out vec3 cubePos, out mat3 cubeDir) {\n    float t = tau * mod(index / 5.0 + 0.02 * iTime + 0.12, 1.0);\n    float a = 2.0 * t;\n    float b = 3.0 * t;\n    float c = 7.0 * t;\n    cubePos = vec3(1.8 * cos(b), 1.8 * cos(c), 1.0 + sin(a));\n    cubeDir = mat3(cos(a), -sin(a), 0.0, sin(a), cos(a), 0.0, 0.0, 0.0, 1.0);\n    cubeDir *= mat3(cos(b), 0.0, -sin(b), 0.0, 1.0, 0.0, sin(b), 0.0, cos(b));\n    cubeDir *= mat3(cos(c), -sin(c), 0.0, sin(c), cos(c), 0.0, 0.0, 0.0, 1.0);\n}\n\nvoid setScene() {\n\tsetCube(0.0, cubePos0, cubeDir0);\n\tsetCube(1.0, cubePos1, cubeDir1);\n\tsetCube(2.0, cubePos2, cubeDir2);\n\tsetCube(3.0, cubePos3, cubeDir3);\n\tsetCube(4.0, cubePos4, cubeDir4);\n}\n\nfloat scene(vec3 p) {\n    float s = ground(p);\n    s = min(s, cube(cubeDir0 * (p - cubePos0)));\n    s = min(s, cube(cubeDir1 * (p - cubePos1)));\n    s = min(s, cube(cubeDir2 * (p - cubePos2)));\n    s = min(s, cube(cubeDir3 * (p - cubePos3)));\n    s = min(s, cube(cubeDir4 * (p - cubePos4)));\n    return s;\n}\n\nfloat march(vec3 eye, vec3 dir) {\n    float depth = 0.0;\n    for (int i = 0; i < marchIter; ++i) {\n        float dist = scene(eye + depth * dir);\n        depth += dist;\n        if (dist < epsilon || depth >= marchDist)\n\t\t\tbreak;\n    }\n    return depth;\n}\n\nfloat ao(vec3 p, vec3 n) {\n    float dist = aoDist;\n    float occ = 1.0;\n    for (int i = 0; i < aoIter; ++i) {\n        occ = min(occ, scene(p + dist * n) / dist);\n        dist *= aoPower;\n    }\n    occ = max(occ, 0.0);\n    return occ;\n}\n\nvec3 normal(vec3 p) {\n    return normalize(vec3(\n        scene(vec3(p.x + epsilon, p.y, p.z)) - scene(vec3(p.x - epsilon, p.y, p.z)),\n        scene(vec3(p.x, p.y + epsilon, p.z)) - scene(vec3(p.x, p.y - epsilon, p.z)),\n        scene(vec3(p.x, p.y, p.z + epsilon)) - scene(vec3(p.x, p.y, p.z - epsilon))\n    ));\n}\n\nvec3 ray(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = fieldOfView * size.y;\n    return normalize(vec3(xy, -z));\n}\n\nmat3 viewMatrix(vec3 dir, vec3 up) {\n    vec3 f = normalize(dir);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nmat3 alignMatrix(vec3 dir) {\n    vec3 f = normalize(dir);\n    vec3 s = normalize(cross(f, vec3(0.48, 0.6, 0.64)));\n    vec3 u = cross(s, f);\n    return mat3(u, s, f);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec3 dir = ray(2.5, iResolution.xy, fragCoord);\n    \n    vec2 m = vec2(0.5, 0.75);\n    if (iMouse.z > 0.0)\n        m = iMouse.xy / iResolution.xy;\n    m *= tau * vec2(1.0, 0.25);\n\n    float dist = 15.0;\n    vec3 center = vec3(0.0, 0.0, 1.0);\n    vec3 eye = center;\n    eye += vec3(dist * sin(m.x) * sin(m.y), dist * cos(m.x) * sin(m.y), dist * cos(m.y));\n    mat3 mat = viewMatrix(center - eye, vec3(0.0, 0.0, 1.0));\n    dir = mat * dir;\n    \n    setScene();\n    float depth = march(eye, dir);\n    if (depth >= marchDist - epsilon) {\n        fragColor = vec4(1.0);\n\t\treturn;\n    }\n    vec3 p = eye + depth * dir;\n    vec3 n = normal(p);\n \n    mat = alignMatrix(n);\n    float col = 0.0;\n    for (int i = 0; i < 12; ++i) {\n        vec3 m = mat * aoDir[i];\n        col += ao(p, m) * (0.5 + 0.5 * dot(m, vec3(0.0, 0.0, 1.0)));\n    }\n\n    fragColor = vec4(vec3(pow(0.2 * col, 0.7)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlXyD4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 1093, 1115, 1115, 1133], [1135, 1135, 1155, 1155, 1229], [1231, 1231, 1294, 1294, 1728], [1730, 1730, 1747, 1747, 1924], [1926, 1926, 1947, 1947, 2233], [2235, 2235, 2268, 2268, 2489], [2491, 2491, 2517, 2517, 2728], [2730, 2730, 2751, 2751, 3042], [3044, 3044, 3100, 3100, 3212], [3214, 3214, 3250, 3250, 3372], [3374, 3374, 3402, 3402, 3542], [3544, 3544, 3599, 3599, 4486]]}
{"id": "XlXyRS", "name": "blackholes", "author": "okalintu", "description": "simple blackhole repeater using raymarching", "tags": ["raymarch"], "likes": 2, "viewed": 88, "date": "1505215045", "time_retrieved": "2024-06-20T19:02:06.671456", "image_code": "float sdf(vec3 eye, float depth, vec3 dir)\n{\n    vec3 v = eye + depth * dir;\n    v = mod(v,8.0)-0.5*8.0;\n    return length(v) - 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n    \n    vec3 dir = normalize(vec3(vec2(uv.x*16.0/9.0, uv.y),-1.0 / tan(radians(45.0))));\n    vec3 eye = vec3(0.0, 0.0, 5.0 - iTime);\n    float depth = 0.01;\n    float min_dist = 1000.0;\n    for (int i = 0; i < 30; i++) { \n        float dist = sdf(eye, depth, dir);\n        if (dist < 0.0001) {\n            fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\t\t\treturn;\n        }\n        min_dist = min(min_dist, dist);\n        depth += dist;\n        if (depth >= 100.0) {\n            break;\n        }\n    }\n    \n    fragColor = vec4(0.0, 1.0/pow(1.0+min_dist, 2.0), 1.0/pow(1.0+min_dist, 3.0), 1.0)*(0.5-0.2*sin(iTime*1.5+depth/25.0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlXyRS.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 44, 44, 134], [136, 136, 193, 193, 866]]}
{"id": "XlXyWM", "name": "sawtoth gradient B", "author": "ollj", "description": "mouse sets points.\nforsimplicity, create only 2 points by pausing time and overlapping 2 of 3 points.\n\nforked:\nhttps://www.shadertoy.com/view/llscW4\nfor efficiency", "tags": ["circles", "fract", "phi", "parabola", "sawtooth"], "likes": 2, "viewed": 549, "date": "1504935092", "time_retrieved": "2024-06-20T19:02:07.229121", "image_code": "\n//suddenly, tripple parabola pairs!\n//#define  ModeParabola\n\n//fallof without clamp(), doesnt look too good\n//#define falloff\n\nconst float stepWidth = 10.; \n\n//View.Zoom\n#define ViewZoom 2.\n//View.Frame (centric view frame has best precision)\n#define fra(u) (u-.5*iResolution.xy)*ViewZoom/iResolution.y\n\n#define sc(a) vec2(sin(a),cos(a))\n//goden ratio >1\n#define phi (sqrt(5.)*.5+.5)\n#define u5(a) ((a)*.5+.5)\n#define u2(a) ((a)*2.-1.)\n#define dd(a) dot(a,a)\n\n//sawtoothGradient() should possibly be 2 seperate functions, \n//seperating its 2 iutputs, allowing them to be n-dimensional as #define\n//i need to sleep over this, as it confuses me more than it should.\n#ifdef falloff\n #define sgx(u)  u5(fract((u)*stepWidth ))*(1.-dd(u))\n //float sgx(vec2 u){return u5(fract(length(u)*stepWidth ))*(1.-dd(u));}\n#else\n #define sgx(u) u5(fract((u)*stepWidth))\n// float sgx(vec2 u){return u5(fract(length(u)*stepWidth ));}\n#endif\n#ifdef ModeParabola\n #define sgy(u) (1.-fract((u)*stepWidth)/stepWidth)\n //float sgy(vec2 u){return 1.-fract(length(u)*stepWidth)/stepWidth;}\n#else\n #define sgy(u) (1.-floor((u)*stepWidth)/stepWidth)\n //float sgy(vec2 u){return 1.-floor(length(u)*stepWidth)/stepWidth;}\n#endif\n//vec2 sawtoothGradient(vec2 u){return vec2(sgx(length(u)),sgy(length(u)));}\n//fork of: https://www.shadertoy.com/view/llscW4\n\nvoid mainImage( out vec4 fragColor, in vec2 U ) {\n\tvec2 u=fra(U);//fragCoord.xy / iResolution.xy;\n    vec4 m=vec4(fra(iMouse.xy),fra(iMouse.zw));// vec4(iMouse.xyzw/ iResolution.xyxy);\n    //m-=.5;    \n    //m.yz*=iResolution.x/iResolution.y;\n    if(iMouse.z<=.0)m=.25*vec4(sc(iTime+acos(0.)),sc(-iTime*phi));//mouse overwrite\n    \n    #if 1\n     #define ledd length\n    #else\n     #define ledd dd\n    #endif\n    \n    vec2 tt=sc(iTime*acos(0.));//tt=vec2(tt.y,-tt.x);\n    //d and e may be better off as matrix?\n    vec3 d=vec3(sgy(ledd(u-m.xy)),\n                sgy(ledd(u-m.zw)),\n                sgy(ledd(u-tt)));\n    vec3 e=vec3(sgx(ledd(u-m.xy)),\n                sgx(ledd(u-m.zw)),\n                sgx(ledd(u-tt)));\n    \n    //d=sqrt(d); e=sqrt(e);//complex plane wotld?\n    \n    //i think [a] and [b] are just a poorly structured matrix.\n    //sawtoothGradient() is better of being 2 functions,for less repetition in vectors.\n    \n    vec4 c=vec4(0);\n    d-=d.yzx;    //this is the fun part of my vector rearranment\n    //e-=e.yzx;   //nope \n    vec3 t=step(d,vec3(0));\n    c.x= mix(e.x,-e.y,t.x);\n    c.y= mix(e.y,-e.z,t.y);\n    c.z= mix(e.z,-e.x,t.z);\n    //seems like here; swiveling/permutations are equal o \"order of operations\"\n    //as in          ; swiveling implies causality.\n    //no wait, of course it does not:\n    c.xyz*=-(c.yzx+1.)*.5;//nope, not too pretty, but ill keep it!\n    \n    c.xyz=mix(c.xyz,c.yzx,.5);\n    c=c*2.;\n    //this color mix is faster, but i fail to permute it into something more monochrome.\n    //my simpler solution just got overly confusing, visually.\n    \n    \n    /*\n    //backup of a MUCH simpler 2-dot mix\n    vec2 a=vec2(d.x,e.x),b=vec2(d.y,e.y);//silly you and your flipped matrix.\n    float t=step(a.y-b.y,.0);\n    //t=u5(sign(b.y-a.y+.1));\n    c.x= mix(.0 ,b.x,t);\n    c.y= mix(a.x,0. ,t);\n    c.z= mix(a.x,b.x,t);\n*/\n    \n    //c.xyz=vec3(mix(a.x,b.x,step(a.y-b.y,.0)));//grey\n    c.w=1.;\n    fragColor=c;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlXyWM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1200, 1327, 1376, 1376, 3286]]}
{"id": "XlXyWr", "name": "AA grid with dots", "author": "etale_cohomology", "description": "An antialiased grid with dots!\n\nA reproduction of the diagram at 0:33 of the video: youtube.com/watch?v=ekScy_oQABY\n\n(Enable zoom by commenting in the 2nd-half of first line)", "tags": ["2d", "simple", "grid", "math", "tutorial", "antialias", "dots"], "likes": 2, "viewed": 140, "date": "1504241402", "time_retrieved": "2024-06-20T19:02:07.629070", "image_code": "#define SCALE      2. //* ((1.02 + sin(.5 * iTime)) * 6.)\n#define DOT_FREQ   1.\n#define DOT_RADIUS .1\n#define LINE_FREQ  .5\n\n#define LINE_THICKNESS .004\n\n#define RGB_DARK  vec3(.1)\n#define RGB_LIGHT vec3(.8)\n#define RGB_BLUE  vec3(.0, .6, 1.)\n\n// -----------------------------------------------------------------------------------------------\n// The vector-projection of vec_a to vec_b is always a scalar multiple of vec_b\n// (ie. a vector in the direction of vec_b, or, equivalently, a vector in the subspace spanned by vec_b).\n// This function computes that scalar multiple!\nfloat vproj_scalar(vec2 vec_a, vec2 vec_b){\n\treturn dot(vec_a, vec_b) / dot(vec_b, vec_b);\n}\n\n// A line is given by (any) 2 vertices in the line\nfloat df_line(vec2 uv, vec2 vec_a, vec2 vec_b){\n    vec2 dvec_ap =    uv - vec_a;  // Displacement vector from vec_a to current pixel\n    vec2 dvec_ab = vec_b - vec_a;  // Displacement vector from vec_a to vec_b\n    vec2 vproj_ap_ab = dvec_ab * vproj_scalar(dvec_ap, dvec_ab);  // Standard linear algebra vector projection!\n    return distance(dvec_ap, vproj_ap_ab) - LINE_THICKNESS;\n}\n\n// SDF for a disk centered at the origin!\nfloat sdf_disk(vec2 uv, float radius){\n    return length(uv) - radius;\n}\n\n// -----------------------------------------------------------------------------------------------\n// Repeat primitives, via iq's repeat method!\n// @scale is a number that aids antialiasing!\nfloat draw_linegrid(vec2 uv, float scale){\n\t//vec2 uv_repeat = LINE_FREQ * (fract(uv / LINE_FREQ - .5) - .5);  // 1st, repeat the coordinates!\n    vec2 uv_repeat = mod(uv - .5 * LINE_FREQ, LINE_FREQ) - .5 * LINE_FREQ;  // 1st, repeat the coordinates!\n\n    float hlines = df_line(uv_repeat, vec2(0), vec2(1, 0));  // 2nd, draw the primitives over the repeated coordinates!\n    float vlines = df_line(uv_repeat, vec2(0), vec2(0, 1));\n\n    float line_aa = 4. * scale / iResolution.y;\n    return smoothstep(line_aa, .0, min(hlines, vlines));\n}\n\n// Fork of cacheflowe's https://www.shadertoy.com/view/MdBfzm\n// @scale is a number that aids antialiasing!\nfloat draw_dotgrid(vec2 uv, float scale){\n    vec2  dot_uv = mod(uv - .5 * DOT_FREQ, DOT_FREQ) - .5 * DOT_FREQ;\n    float dot_aa = 4. * scale / iResolution.y;  // Scale-sensitive antialiasing!\n    return smoothstep(dot_aa, 0., sdf_disk(dot_uv, DOT_RADIUS));\n}\n\n// -----------------------------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = SCALE * (2. * fragCoord - iResolution.xy) / iResolution.y;  // The Fabrice map!\n    float time = .25 * iTime;\n    uv *= mat2(cos(time), sin(time), -sin(time), cos(time));\n\n    float linegrid = draw_linegrid(uv, SCALE);\n    float dotgrid  = draw_dotgrid(uv, SCALE);\n\n    vec3 scene = RGB_LIGHT;  // Background!\n    scene = mix(scene, RGB_BLUE, linegrid);\n    scene = mix(scene, RGB_DARK, dotgrid);\n\n    fragColor.rgb = scene;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlXyWr.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[244, 577, 620, 620, 669], [671, 722, 769, 769, 1107], [1109, 1151, 1189, 1189, 1223], [1225, 1416, 1458, 1558, 1955], [1957, 2065, 2106, 2106, 2324], [2326, 2425, 2479, 2479, 2920]]}
{"id": "XlXyzj", "name": "Burping Volcano", "author": "dr2", "description": "Now blowing smoke rings (mousing recommended)", "tags": ["raymarch", "cloud", "flame", "ring", "smoke", "volcano"], "likes": 5, "viewed": 606, "date": "1505396112", "time_retrieved": "2024-06-20T19:02:07.647695", "image_code": "// \"Burping Volcano\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrSphDf (vec3 p, float s);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nfloat Hashff (float p);\nfloat Noiseff (float p);\nfloat Noisefv2 (vec2 p);\nfloat Noisefv3 (vec3 p);\nfloat Fbm2 (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec2 Rot2D (vec2 q, float a);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\n\n#define NROCK 16\nvec4 rkPos[NROCK];\nvec3 sunDir, flmCylPos, smkPos;\nfloat dstFar, tCur, lavHt, qRad, flmCylRad, flmCylLen, smkRadEx,\n   smkRadIn, smkPhs, szFac, densFac;\nint idObj;\nconst int idMnt = 1, idRock = 2, idLav = 3;\nconst float pi = 3.14159;\n\nfloat MountDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, a, r, hd, s;\n  q = p;\n  a = atan (q.z, q.x) / (2. * pi) + 0.5;\n  r = length (q.xz);\n  s = 2. * Fbm2 (vec2 (33. * a, 7. * r)) - 0.5;\n  d = PrCylDf (q.xzy, 2., 0.75);\n  q.y -= 0.75;\n  d = max (d, - (PrSphDf (q, 0.35) - 0.03 * s));\n  hd = 0.015 * (1. + sin (64. * pi * a) + 2. * sin (25. * pi * a)) *\n     SmoothBump (0.5, 1.8, 0.3, r) + 0.15 * s * SmoothBump (0.1, 2., 0.2, r);\n  q.y -= 1.2 + hd;\n  d = max (max (d, - PrTorusDf (q.xzy, 2.8, 2.8)), 0.15 - length (q.xz));\n  q = p;\n  q.y -= -0.75;\n  d = max (SmoothMin (d, PrCylDf (q.xzy, 2.5, 0.05 *\n     (1. - smoothstep (2.2, 2.5, length (q.xz)))), 0.2), - q.y);\n  if (d < dMin) { dMin = d;  idObj = idMnt; }\n  q = p;\n  q.y -= lavHt;\n  d = PrCylDf (q.xzy, 0.3, 0.02);\n  if (d < dMin) { dMin = d;  idObj = idLav; }\n  return 0.8 * dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin, d;\n  dMin = dstFar;\n  dMin = MountDf (p, dMin);\n  for (int j = 0; j < NROCK; j ++) {\n    d = PrSphDf (p - rkPos[j].xyz, rkPos[j].w);\n    if (d < dMin) { dMin = d;  idObj = idRock;  qRad = rkPos[j].w; }\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat TransObjRay (vec3 ro, vec3 rd)\n{\n  vec3 q;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    q = ro + dHit * rd - flmCylPos;\n    d = PrCylDf (q.xzy, flmCylRad, flmCylLen);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvoid SetRocks ()\n{\n  vec3 bv0, bp0, bp;\n  float a, tm, fj;\n  for (int j = 0; j < NROCK; j ++) {\n    fj = float (j);\n    a = 2. * pi * Hashff (100.11 * fj);\n    bv0.xz = 0.7 * vec2 (cos (a), sin (a));\n    bv0.y = 1.4 + 0.3 * Hashff (11.11 * fj);\n    bp0.xz = 0.1 * bv0.xz;  \n    bp0.y = 0.5;\n    tm = mod (tCur + 0.15 * (fj + 0.6 * Hashff (fj)), 4.);\n    bp = bp0 + bv0 * tm;  \n    bp.y -= 0.5 * tm * tm;\n    rkPos[j] = vec4 (bp, 0.04 - 0.03 * tm / 4.);\n  }\n}\n\nfloat FlmAmp (vec3 ro, vec3 rd, float dHit)\n{\n  vec3 p, q, dp;\n  float g, s, fh, fr, f, hs;\n  p = ro + dHit * rd - flmCylPos;\n  hs = min (p.y / flmCylLen, 1.);\n  dp = (flmCylRad / 20.) * rd;\n  g = 0.;\n  for (int i = 0; i < 20; i ++) {\n    p += dp;\n    s = distance (p.xz, flmCylPos.xz);\n    q = 4. * p;  q.y -= 6. * tCur;\n    fh = 0.5 * max (1. - (p.y - flmCylPos.y) / flmCylLen, 0.);\n    fr = max (1. - s / flmCylRad, 0.);\n    f = Fbm3 (q);\n    q = 7. * p;  q.y -= 8.5 * tCur;\n    f += Fbm3 (q);\n    g += max (0.5 * fr * fr * fh * (f * f - 0.6), 0.);\n    q = 23. * p;  q.y -= 11. * tCur;\n    g += 1000. * pow (abs (Noisefv3 (q) - 0.11), 64.);\n    if (s > flmCylRad || p.y < flmCylPos.y - 0.99 * flmCylLen || g > 1.) break;\n  }\n  g = clamp (0.9 * g, 0., 1.);\n  if (hs > 0.) g *= 1. - hs * hs;\n  return g;\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float f;\n  if (rd.y >= 0.) {\n    ro.xz += 0.5 * tCur;\n    f = Fbm2 (0.02 * (rd.xz * (100. - ro.y) / max (rd.y, 0.001) + ro.xz));\n    col = vec3 (0.1, 0.2, 0.4);\n    col = mix (col, vec3 (0.8), clamp (3. * (f - 0.5) * rd.y + 0.1, 0., 1.));\n  } else {\n    ro -= ((ro.y + 0.75) / rd.y) * rd;\n    col = vec3 (0.17, 0.14, 0.05) * (0.7 + 0.3 * Fbm2 (10. * ro.xz));\n    f = 1. - smoothstep (0.1, 1., length (ro.xz) / dstFar);\n    vn = VaryNf (10. * ro, vec3 (0., 1., 0.), 3. * f);\n    col = col * (0.1 + 0.1 * max (vn.y, 0.) + 0.8 * max (dot (vn, sunDir), 0.));\n  }\n  return col;\n}\n\nfloat SmokeDens (vec3 p)\n{\n  mat2 rMat;\n  vec3 q, u;\n  p = p.xzy;\n  q = p / smkRadEx;\n  u = normalize (vec3 (q.xy, 0.));\n  q -= u;\n  rMat = mat2 (vec2 (u.x, - u.y), u.yx);\n  q.xy = rMat * q.xy;\n  q.xz = Rot2D (q.xz, 2. * tCur);\n  q.xy = q.xy * rMat;\n  q += u;\n  q.xy = Rot2D (q.xy, 0.1 * tCur);\n  return clamp (smoothstep (0., 1., densFac * PrTorusDf (p, smkRadIn, smkRadEx)) *\n     Fbm3 (5. * q + 0.01 * tCur) - 0.1, 0., 1.);\n}\n\nfloat SmokeShellDist (vec3 ro, vec3 rd)\n{\n  vec3 q;\n  float d, h;\n  d = 0.;\n  for (int j = 0; j < 150; j ++) {\n    q = ro + d * rd;\n    h = PrTorusDf (q.xzy, smkRadIn, smkRadEx);\n    d += h;\n    if (h < 0.001 || d > dstFar) break;\n  }\n  return d;\n}\n\nvec4 SmokeCol (vec3 ro, vec3 rd, vec3 col)\n{\n  vec3 clCol, tCol, q;\n  float d, dens, atten, sh;\n  clCol = vec3 (0.9);\n  atten = 0.;\n  d = 0.;\n  for (int j = 0; j < 150; j ++) {\n    q = ro + d * rd;\n    dens = SmokeDens (q);\n    sh = 0.5 + 0.5 * smoothstep (-0.2, 0.2, dens - SmokeDens (q + 0.1 * szFac * sunDir));\n    tCol = mix (vec3 (1., 0.2, 0.), vec3 (0.6, 0.6, 0.), clamp (smoothstep (0.2, 0.8, dens) +\n       0.2 * (1. - 2. * Noiseff (10. * tCur)), 0., 1.));\n    tCol = mix (mix (tCol, clCol, smkPhs), clCol, smoothstep (-0.15, -0.05,\n       (length (vec3 (q.xz * (1. - smkRadEx / length (q.xz)), q.y)) - smkRadIn) / szFac));\n    col = mix (col, 4. * dens * tCol * sh, 0.2 * (1. - atten) * dens);\n    atten += 0.12 * dens;\n    d += szFac * 0.01;\n    if (atten > 1. || d > dstFar) break;\n  }\n  atten *= smoothstep (0.02, 0.04, smkPhs);\n  return vec4 (col, atten);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, roo;\n  float dstHit, dstFlm, dstFlmR, intFlm, bgFlm, s, dstSmk;\n  lavHt = 0.4 + 0.12 * cos (2. * pi * smkPhs);\n  flmCylPos = vec3 (0., 0.9, 0.);\n  flmCylRad = 0.35;\n  flmCylLen = 1.3;\n  roo = ro;\n  SetRocks ();\n  dstFlm = TransObjRay (ro, rd);\n  dstHit = ObjRay (ro, rd);\n  bgFlm = (0.7 + 0.6 * Noiseff (10. * tCur));\n  intFlm = (dstFlm < dstHit) ? FlmAmp (ro, rd, dstFlm) : 0.;\n  if (dstHit >= dstFar) col = BgCol (ro, rd);\n  else {\n    ro += dstHit * rd;\n    vn = ObjNf (ro);\n    if (idObj == idMnt) {\n      s = clamp (ro.y / 1.2 + 0.6, 0., 1.);\n      vn = VaryNf (10. * ro, vn, 5. - 2. * s);\n      col = (0.5 + 0.7 * bgFlm * s) * vec3 (0.2 + 0.1 * (1. - s),\n         0.05 + 0.2 * (1. - s), 0.05);\n      col = col * (0.1 + 0.1 * max (vn.y, 0.) +\n         0.8 * max (dot (vn, sunDir), 0.));\n    } else if (idObj == idLav) {\n      col = mix (vec3 (0.4, 0., 0.), vec3 (0.8, 0.7, 0.),\n         step (1.1, 2. * Fbm2 (41. * ro.xz * vec2 (1. + 0.2 * sin (1.7 * tCur) *\n         vec2 (1. + 0.13 * sin (4.31 * tCur), 1. + 0.13 * cos (4.61 * tCur))))));\n      vn = VaryNf (21. * ro, vn, 10.);\n      col *= 0.5  + 1.5 * pow (max (vn.y, 0.), 32.);\n    } else if (idObj == idRock) {\n      col = mix (vec3 (0.8, 0., 0.), vec3 (0.1, 0.3, 0.1),\n         1. - (qRad - 0.005) / 0.03);\n      vn = VaryNf (200. * ro, vn, 10.);\n      col = col * (0.6 + 0.4 * max (dot (vn, vec3 (0., 0.5, 0.)), 0.));\n    }\n  }\n  if (intFlm > 0.) col = mix (col, bgFlm * mix (vec3 (1., 0.1, 0.1),\n     vec3 (1., 1., 0.5), 0.5 * intFlm), 1.2 * intFlm);\n  ro = roo - smkPos;\n  dstSmk = SmokeShellDist (ro, rd);\n  col4 = (dstSmk < min (dstHit, dstFar)) ? SmokeCol (ro + dstSmk * rd, rd, col) : vec4 (col, 0.);\n  col = mix (col, col4.rgb, min (col4.a, 1.));\n  return pow (clamp (col, 0., 1.), vec3 (0.7));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr;\n  vec3 rd, ro;\n  vec2 canvas, uv;\n  float az, el;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  dstFar = 30.;\n  szFac = 1.;\n  smkPhs = mod (0.04 * tCur, 1.);\n  smkRadIn = 0.25 * szFac;\n  smkRadEx = (0.5 - 0.4 * pow (1. - smkPhs, 2.)) * szFac;\n  densFac = 7.2 * (pow (smkPhs, 1.5) - 1.08) / szFac;\n  smkPos = vec3 (0., 0.6 + 4. * smkPhs * (1. - smoothstep (0.9, 1., smkPhs)), 0.);\n  ro = vec3 (0., 1. * smkPhs * (1. - smoothstep (0.9, 1., smkPhs)), -8.);\n  rd = normalize (vec3 (uv, 3.5));\n  rd.yz = Rot2D (rd.yz, -0.5 * atan (smkPos.y - ro.y, smkPos.z - ro.z));\n  az = 0.01 * tCur;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az -= 2. * pi * mPtr.x;\n    el -= 2. * pi * mPtr.y;\n  }\n  el = clamp (el, -0.01 * pi, 0.25 * pi);\n  ro.yz = Rot2D (ro.yz, el);\n  rd.yz = Rot2D (rd.yz, el);\n  ro.xz = Rot2D (ro.xz, az);\n  rd.xz = Rot2D (rd.xz, az);\n  sunDir = normalize (vec3 (1., 2., -1.));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec2 (dot (p + e.yy, cHashVA2), dot (p + e.xy, cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p); \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);  \n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;  \n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 e = vec3 (0.1, 0., 0.);\n  vec3 g;\n  float s;\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s, Fbmn (p + e.yxy, n) - s, Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlXyzj.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 809, 845, 845, 1652], [1654, 1654, 1676, 1676, 1913], [1915, 1915, 1948, 1948, 2124], [2126, 2126, 2147, 2147, 2354], [2356, 2356, 2394, 2394, 2631], [2633, 2633, 2651, 2651, 3091], [3093, 3093, 3138, 3138, 3899], [3901, 3901, 3932, 3932, 4525], [4527, 4527, 4553, 4553, 4955], [4957, 4957, 4998, 4998, 5205], [5207, 5207, 5251, 5251, 6077], [6079, 6079, 6114, 6114, 7910], [7912, 7912, 7968, 7968, 9026], [9028, 9028, 9061, 9061, 9088], [9090, 9090, 9132, 9132, 9183], [9185, 9185, 9231, 9231, 9288], [9322, 9322, 9346, 9346, 9383], [9385, 9385, 9409, 9409, 9462], [9464, 9464, 9488, 9488, 9642], [9644, 9644, 9668, 9668, 9888], [9890, 9890, 9915, 9915, 10062], [10064, 10064, 10089, 10089, 10275], [10277, 10277, 10302, 10302, 10527], [10529, 10529, 10550, 10550, 10705], [10707, 10707, 10728, 10728, 10883], [10885, 10885, 10914, 10914, 11130], [11132, 11132, 11171, 11171, 11383], [11385, 11385, 11415, 11415, 11473], [11475, 11475, 11520, 11520, 11623], [11625, 11625, 11682, 11682, 11765]]}
{"id": "XtdGWr", "name": "Hills 2D", "author": "emdeka87", "description": "WIP. \"Tiny Wings\" inspired.", "tags": ["2d", "game", "hills"], "likes": 6, "viewed": 512, "date": "1504274973", "time_retrieved": "2024-06-20T19:02:07.648692", "image_code": "vec3 grain(vec2 uv, float t, float s) {\n    float x = (uv.x + 4.0 ) * (uv.y + 4.0 ) * (t * 10.0);\n\tvec4 grain = vec4(mod((mod(x, 13.0) + 1.0) * (mod(x, 123.0) + 1.0), 0.01)-0.005) * s;\n    return grain.rgb;\n}\n\nfloat curve(vec2 p, float per, float amp, float dx) {\n   return p.y-(sin(per*p.x+dx)*amp-2.);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ouv = fragCoord.xy / iResolution.xy;\n\tvec2 uv = ouv * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    uv*=10.;\n    float t = iTime;\n\t\n    //hills\n    float hills = curve(uv,.3,2.1,t);\n    vec3 hillColor = mix(vec3(0.952, 0.674, 0.415),vec3(0.592, 0.125, 0.211),-ouv.y*hills*0.3);\n    hillColor+= (vec3(0.662, 0.564, 0.478)*step(mod(hills,.3),.1))/10.;\n    hillColor = mix(hillColor,vec3(0.4),step(0.001,hills));\n    \n    //bg hill\n    float bghill = curve(uv,.4,2.2,t/2.3);\n    vec3 bghillColor = mix(vec3(0.952, 0.674, 0.415),vec3(0.592, 0.125, 0.211),-ouv.y*bghill);\n    bghillColor+= (vec3(0.662, 0.564, 0.478)*step(mod(bghill,.3),.1))/10.;\n    bghillColor = mix(bghillColor,vec3(0.4),step(0.001,bghill));\n    \n    bghillColor/=1.3;\n    \n    vec3 c = vec3(0.850, 0.722, 0.517)+grain(ouv,1.0,3.);\n    c= mix(c,bghillColor,step(bghill,0.1));\n    c= mix(c,hillColor,step(hills,0.1));\n    \n    fragColor = vec4(c,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtdGWr.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 39, 39, 208], [210, 210, 263, 263, 305], [306, 306, 363, 363, 1303]]}
{"id": "XtfcRM", "name": "random testing", "author": "robertplummer", "description": "was testing out some script from https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl/28095165", "tags": ["noise"], "likes": 1, "viewed": 491, "date": "1506795088", "time_retrieved": "2024-06-20T19:02:07.901871", "image_code": "// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n// Compound versions of the hashing algorithm I whipped together.\nuint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\nuint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\nuint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\n// Pseudo-random value in half-open range [0:1].\nfloat random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }\nfloat random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t    vec3  inputs = vec3( gl_FragCoord.xy, iTime ); // Spatial and temporal inputs\n    float rand   = random( inputs );              // Random per-pixel value\n    vec3  luma   = vec3( rand );                  // Expand to RGB\n\n    fragColor = vec4( luma, 1.0 );\n\t//fragColor = vec4(uv,uv,uv,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtfcRM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 71, 92, 92, 223], [225, 291, 313, 313, 371], [372, 372, 394, 394, 452], [453, 453, 475, 475, 533], [535, 693, 725, 725, 1145], [1147, 1196, 1221, 1221, 1272], [1273, 1273, 1298, 1298, 1349], [1350, 1350, 1375, 1375, 1426], [1427, 1427, 1452, 1452, 1503], [1505, 1505, 1562, 1562, 1861]]}
{"id": "XtfcWH", "name": "rays shader", "author": "Coolok", "description": "rays shader", "tags": ["raysshader"], "likes": 2, "viewed": 207, "date": "1504527336", "time_retrieved": "2024-06-20T19:02:08.253667", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nconst float PI = 3.141592654;\nconst float side = 0.3;\nconst float angle = PI*1.0/3.0;\nconst float sinA = 0.86602540378;\nconst float cosA = 0.5;\nconst vec3 zero = vec3(0.0);\nconst vec3 one = vec3(1.0);\n\n// generates the colors for the rays in the background\nvec4 rayColor(vec2 fragToCenterPos, vec2 fragCoord) {\n\tfloat d = length(fragToCenterPos);\n\tfragToCenterPos = normalize(fragToCenterPos);\n\t\t\n\tfloat multiplier = 0.0;\n\tconst float loop = 60.0;\n\tconst float dotTreshold = 0.90;\n\tconst float timeScale = 0.75;\n\tconst float fstep = 10.0;\n\t\n\t// generates \"loop\" directions, summing the \"contribution\" of the fragment to it. (fragmentPos dot direction)\n\tfloat c = 0.5/(d*d);\n\tfloat freq = 0.25;\t\t\n\tfor (float i = 1.0; i < loop; i++) {\n\t\tfloat attn = c;\n\t\tattn *= 1.85*(sin(i*0.3*iTime)*0.5+0.5);\n\t\tfloat t = iTime*timeScale - fstep*i;\n\t\tvec2 dir = vec2(cos(freq*t), sin(freq*t));\n\t\tfloat m = dot(dir, fragToCenterPos);\n\t\tm = pow(abs(m), 4.0);\n\t\tm *= float((m) > dotTreshold);\n\t\tmultiplier += 0.5*attn*m/(i);\n\t}\n\n\tfloat f = abs(cos(iTime/2.0));\n\t\n\tconst vec4 rayColor = vec4(0.9, 0.7, 0.3, 1.0);\n\t\t\n\tfloat pat = abs(sin(10.0*mod(fragCoord.y*fragCoord.x, 1.5)));\n\tf += pat;\n\tvec4 color = f*multiplier*rayColor;\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat aspect = iResolution.x / iResolution.y;\t\n\tvec3 pos = vec3(fragCoord.xy / iResolution.xy, 1.0);\n\tpos.x *= aspect;\n\t\n\tvec2 fragToCenterPos = vec2(pos.x - 0.5*aspect, pos.y - 0.5);\n\tvec4 rayCol = rayColor(fragToCenterPos,fragCoord);\n\t\n\tfloat u, v, w;\n\tfloat c = 0.0;\t\n\n\tvec4 triforceColor = vec4(1.0);\n\tfragColor = mix(rayCol, triforceColor, c);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtfcWH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[248, 303, 356, 356, 1270], [1272, 1272, 1329, 1329, 1681]]}
{"id": "XtfyDn", "name": "meow", "author": "alephr", "description": "round", "tags": ["round"], "likes": 2, "viewed": 134, "date": "1504228084", "time_retrieved": "2024-06-20T19:02:08.811083", "image_code": "vec2 fgrad(float x){\n    return vec2(dFdx(x), dFdy(x));\n}\n\nfloat fgradlen(float x){\n    return length(fgrad(x));\n}\n\nfloat linestep(float edge0, float edge1, float x){\n    float w = edge1 - edge0;\n    return clamp(0., 1., (x - edge0)/w);\n}\n\nfloat PI = 3.141292;\nfloat root2inv = .7071;\n\nvec2 nangle2vec(float nangle){\n    return vec2(cos(PI*2.*nangle), sin(PI*2.*nangle));\n}\n\nfloat ncos(float nangle){\n    return cos(2.*PI*nangle);\n}\n\nfloat tri(float nangle){\n    float phase = mod(nangle, 1.);\n    return 2.*abs(phase - .5);\n}\nvec3 huecolor(float h){\n    \n    float hue_scale = mod(h, 1.)*6.;\n    if(hue_scale < 1.){\n        return vec3(1., (hue_scale - 0.), 0);\n    }else if(hue_scale < 2.){\n        return vec3(1. - (hue_scale - 1.), 1, 0);\n    }else if(hue_scale < 3.){\n        return vec3(0, 1, (hue_scale - 2.));\n    }else if(hue_scale < 4.){\n        return vec3(0, 1. - (hue_scale - 3.), 1.);\n    }else if(hue_scale < 5.){\n        return vec3((hue_scale - 4.), 0, 1.);\n    }else{\n        return vec3(1., 0, 1. - (hue_scale - 5.));\n    }\n    \n}\n\nfloat atan3(vec2 uv){\n    float at2 = atan(uv.y, uv.x)/(2.*PI);\n    if(at2 < 0.){\n        at2 += 1.0;\n    }\n    return at2;\n}\n\nfloat moveyring(vec2 uv, float thickness){\n    vec2 dir = normalize(uv);\n    float nangle = atan3(dir);\n    float center_off = abs(length(uv) - 1.0);\n    float line_dist = center_off - thickness;\n    vec2 grad = fgrad(line_dist);\n    \n    float cutoff_nangle = .5*ncos(iTime/32.);\n    float cos_cutoff = cos(2.*PI*cutoff_nangle);\n    float c = dir.x;\n    vec2 cutoff_point = nangle2vec(cutoff_nangle); \n    \n    if(c > cos_cutoff){\n        line_dist = \n            min(length(uv - cutoff_point),\n                length(uv - vec2(cutoff_point.x, -cutoff_point.y))) - thickness;\n    }\n    return line_dist;\n}\n\nvec2 uv_transform(vec2 uv, float thickness){\n    vec2 a = uv;\n    vec2 x_axis = nangle2vec(iTime/4.);\n    uv.x = x_axis.x*a.x - x_axis.y*a.y;\n    uv.y = x_axis.x*a.y + x_axis.y*a.x;\n    uv *= (1. + 2.*thickness);\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 t_uv = fragCoord.xy/iResolution.xy;\n    float thickness = .125;\n    uv = uv_transform(uv, thickness);\n    \n    vec2 dir = normalize(uv);\n    float nangle = atan3(dir);\n   \n   \tfloat local_distort = texture(iChannel1, t_uv).x;\n    \n    float line_dist = moveyring(uv, thickness);\n    vec2 off = normalize(fgrad(line_dist));\n    vec2 real_off = uv_transform(off, thickness)*thickness*.5*local_distort;\n    line_dist = moveyring(uv + real_off, thickness);\n    \n    float g = fgradlen(line_dist);\n    float hk_width = .5;\n    float s = linestep(g*hk_width, -g*hk_width, line_dist);\n    float tt = smoothstep(g*200., -g*200., line_dist);\n    \n    \n    vec4 lineColor = vec4(huecolor(nangle), 1.);\n    vec4 bgColor   = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    fragColor = bgColor;\n\tfragColor = mix(fragColor, lineColor, s);\n    //fragColor = vec4((off + 1.)*.5, 0, 1);\n    //fragColor = vec4(((uv + real_off) + 1.)*.5, 0, 1);\n    //fragColor = vec4(local_distort, 0, 0, 1);\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}, {"id": "4sf3zn", "previewfilepath": "/presets/webcam.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/webcam.png", "ctype": "webcam"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtfyDn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 20, 20, 57], [59, 59, 83, 83, 114], [116, 116, 166, 166, 238], [286, 286, 316, 316, 373], [375, 375, 400, 400, 432], [434, 434, 458, 458, 526], [527, 527, 550, 550, 1049], [1051, 1051, 1072, 1072, 1176], [1178, 1178, 1220, 1220, 1784], [1786, 1786, 1830, 1830, 2015], [2017, 2017, 2074, 2074, 3144]]}
{"id": "XtfyDX", "name": "Square Truchet Flow", "author": "Shane", "description": "Animating some flow lines on a square Truchet pattern.", "tags": ["animation", "square", "truchet", "flow", "pattern", "polar", "tile"], "likes": 66, "viewed": 1408, "date": "1506606526", "time_retrieved": "2024-06-20T19:02:10.459609", "image_code": "/*\n\n\tSquare Truchet Flow\n\t-------------------\n\n\tAfter looking at Fabrice's \"Smallest Truchet\" example then reading one of \n\tIapafoto's comments regarding Truchet animation, I searched Shadertoy for a \n\tsimple Truchet flow-lines demonstration, but the only one I could find was a\n\tflowing hexagonal Truchet shader by \"klk,\" and no square Truchet ones at all, \n\twhich surprised me, since they're kind of interesting looking and easy to produce.\n\n\tWith that in mind, I dusted off some old code and put one together in less than \n\tfive minutes... then proceeded to waste way too much time prettying it up when I \n\tshould've been doing other things. :)\n\n\tHere's a brief explanation of the process: Partition into a grid, render the tile,\n\tuse the grid coordinates to obtain the angle using the standard \"atan(p.y, p.x)\"\n\tformula, then use that angle and the time to animate something. At that point you'll\n\tnotice that the flowing objects cross the boundaries in opposing directions. You\n\tcan correct that by reversing the flow direction for all neighboring tiles, which\n\tmeans in a checkerboard fashion - You perform a similar step when rendering a grid\n\tof repeat rotating gears. There's a little more to it, but that's the basic idea.\n\n\tBy the way, I almost rendered some gears on all the corners of the square cells,\n\tbut decided it would complicate the example too much. Besides, I figured it'd be the\n\tkind of thing that someone like Dr2 would prefer to do anyway. :D\n\n\tAnyway, I'm going to get back to the example I'm supposed to be working on. Later,\n\tI'll have yet another go at animating a 3D Truchet. The comments are very rushed, \n\tso I'll get in and tidy those up later too.\n\t\n\tIf you take the comments away, there's not a great deal of code here, but just in \n\tcase there's too much window dressing, I've put a much simpler example together \n\tusing a smaller code imprint here:\n\n\t// A minimal implementation to show the main concept - for anyone who doesn't\n\t// want to sift through all the aesthetic related code in this one. :)\n\tMinimal Animated Truchet - Shane\n\thttps://www.shadertoy.com/view/XtfyDf\n\n\tOther examples:\n\n\t// Hexagonal Truchet flow. I'll do one of these later.\n\tHexlicity - klk\n\thttps://www.shadertoy.com/view/lt2SzG\n\n\t// Fabrice has many Truchet examples. This one sidetracked me into making the \n\t// example you're currently viewing. :D\n\tsmallest truchet - FabriceNeyret2\n\thttps://www.shadertoy.com/view/XllyWS\n\n*/\n\n\n#define SCROLL\n\n// Standard 2D rotation formula.\nmat2 r2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// Standard vec2 to float hash - Based on IQ's original.\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(141.213, 289.867)))*43758.5453); }\n\nfloat df(vec2 p, float tF, float s){\n    \n    return max(abs(p.x)*.866025 + tF*p.y*.5, -tF*p.y) - s;\n    \n}\n\nfloat df2(float a, float s){ return abs(a) - s; }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    // Screen coordinates.\n    float res = clamp(iResolution.y, 200., 600.);\n    vec2 uv = (fragCoord.xy - iResolution.xy*.5)/res;\n    \n    // Some minor fish-eye distortion to break up the monotony of the square grid\n    // lines, and to give it some subtle - albeit fake - depth.\n    uv *= 1. + dot(uv, uv)*.05;\n    \n    // Wavy screen coordinate distortion... Probably a bit much for this example.\n    //uv -= sin(uv*3.14159/2. - cos(uv.yx*3.14159/4. + iTime)*3.14159)*.01;\n    \n    // Right to left scrolling. I wanted this in to show the continuity of the pattern,\n    // but kind of interferes with the flow effect... Anyway, it's optional.\n    #ifdef SCROLL\n    float tm = iTime/32.;\n    // Slowing things down at larger resolutions - Based on Flockaroo's observation.\n    if(iResolution.x>800.) tm *= 1.5;\n    uv += vec2(tm, 7.);\n    #endif\n    \n    \n    // TRUCHET PATTERN\n    //\n    // Scaling the slightly distorted screen coordinates.\n    vec2 p = uv*5.;\n    \n\t// Cell ID. Used to generate unique random numbers for each grid cell.\n    vec2 ip = floor(p);\n    \n    // Grid partitioning. Converting to unit cell coordinates centered at the origin.\n    p -= ip + .5; // Equivalent to \"p = fract(p) - .5;.\"\n\n    \n    // Flow direction: The flow direction must be reversed every time you enter a \n    // neighboring tile. What this means is that you flip the direction for half the tiles \n    // in a checkerboard pattern. The line below is the way to do that... If you're as slow \n    // as I am, knowing the aforementioned will save you a lot of wasted time. :D\n    //\n    // I figured this out for myself ages ago, but it took me \"way\" too long. Set the \n    // direction variable, \"dir,\" to \"1.\" then note that every single neighboring tile has \n    // its direction reversed. Yes, it's obvious, and anyone who's rendered repeat animated \n    // gears would know this, but like I said, I'm a bit slow on the uptake. :D\n    // \n    float dir = fract(dot(ip, vec2(.5)))>.25 ? -1. : 1.; \n    // Another - more intuitive - way to write the above:\n    //float dir = mod(ip.x + ip.y, 2.)>.5 ? -1. : 1.; \n    \n    // A unique random number assigned to each grid tile.\n    float rnd = hash21(ip);\n    \n    \n    // Vertical tile flipping. If the random ID for the tile is more than the threshold,\n    // reverse the cell's Y coordinate, which effectively vertically flips the tile. Comment\n    // the line out and all tiles will have the same orientation, resulting in a pretty\n    // lacklustre pattern.\n    p.y *= (rnd >.5)? -1. : 1.;\n    \n    \n\t\n    // This line requires a bit of an explanation: The standard 2D Truchet tile consists of\n    // two arcs centered on opposite diagonal corners. Each are mirror reflections of the\n    // other about the diagonal line cutting the square grid cell. The following line of\n    // code is just a way to repeat space about the diagonal. What this means is that you \n    // can draw just one arc (corner torus) and the one in the other diagaonal corner will\n    // be rendered too. The easiest way to see this is to comment the line out and you'll\n    // see half the pattern disappear.\n    p = p.x>-p.y ? p : -p; \n    // \"p *= sign(p.x + p.y)\" would be nice, but it can sometimes return zero.\n    \n    \n\n    // Storage vector. \n    vec2 q;\n    \n    const float th = .3; // Arc thickness.\n    \n    // The arc, centered in the top right of the grid cell - or the bottom right if flipped.\n    float d = length(p - .5) - .5 - th/2.;\n    d = max(d, -th - d); // Remove the inner circles to produce an arc of thickness \"th.\"\n    \n    // The dashed grid lines.\n    float bord = max(abs(p.x), abs(p.y)) - .49;\n    q = abs(mod(p, 1./8.) - .5/8.);\n    float lines = (min(q.x, q.y) - .5/8./3.);\n    bord = min(bord, lines);\n    bord = step(0., bord);\n    \n    // Manipulating the resultant distant field for some cheap edges.\n    float ed = max(d -.035, -d);\n    ed = smoothstep(0., .0005/max(ed, .0005), ed);\n    \n    \n    // Used for the Truchet pattern border shadows. Produced through trial and error, so \n    // there's probably a cleaner way to write it.\n    float sh = smoothstep(0., .075, d - .01) - smoothstep(0., .3, d+.05);\n    \n    \n    \n    // Rendering the moving arrows and border dashes.\n    \n    // Moving the grid coordinates to the corner, or the center of the arc - in order to\n    // determine the angle of the pixel subtended to the arc center.\n    q = p - .5; \n    \n    // The actual animation. You perform that before polar partitioning.\n    q = r2(iTime*dir)*q;\n    \n    // Using the angle to convert into polar coordinates in order to partition into cells \n    // (8, in this case) around the arc, then rendering an object in each.\n    const float aNum = 8.;\n    float a = atan(q.y, q.x); // Pixel angle.\n    float ia = floor(a/6.283*aNum) + .5; // Obtaining the cell centers.\n    \n    q = r2(ia*6.283/aNum)*q; // Converting to polar coordinates: p.x = radius, p.y = angle.\n    q.x -= .5; // Moving the radial coordinate out to the radius of the arc.\n    \n    // Rendering the arrows - I could have made life easy for myself, rendered a nice \n    // symmetrical dot and left it at that, but I thought arrows would look cooler. It\n    // was a bit fidly, but I managed. :)\n    //\n    // The arrow line - I had to use the angle coordinate itself, and finally figured out\n    // that I'd need to used the truchet lines themselves to give the arrow lines curvature...\n    // Yeah, I should've rendered animated dots. :D\n    float d2 = df2(mod(a - .15*dir, 6.283/aNum) - .5*6.283/aNum, .2);\n    d2 = max(d + .14, -d2); // Control the arrow line width with the Truchet distance field.\n    \n    // Arrow head, or a triangle if you want to get technical. :) The triangles need to be\n    // flipped on neighboring cells. I figured that out via observation.\n    d2 = min(d2, df(q, dir, .025)); \n    \n    // Refining the 2D distance field - Analogous to honing in on the surface edges.\n    d2 = smoothstep(0., .015, d2); \n    \n\n    // Border dashes - More lines shaped by the Truchet borders.\n    float d4 = df2(mod(a - .15*dir, 6.283/aNum/3.) - .5*6.283/aNum/3., .03);\n    d4 = max(abs(abs(d) + .09/3.) - .09, -d4); // Control arrow width.\n    d4 = max(d4, d + .05);\n    // Refining the distance field - Analogous to honing in on the surface edges.\n    d4 = smoothstep(0., .015, d4);\n    \n\n    \n    // Refining the distance field - Analogous to honing in on the surface edges. I performed \n    // this down here because I think \"d\" was needed above somewhere to shape some lines.\n    d = smoothstep(0., .0005/max(d, .0005), d);\n    \n    \n    // COMBINING ALL THE LAYERS.\n\t//\n    // Mix the background in with the border first. For anyone who isn't aware, if you're mixing\n    // in a few layers, you start with the bottom layer first, then progress through to the\n    // front layer like so:\n    //\n    // col = mix(layer1, layer2, maskLayer1*alpha1);\n    // col = mix(col, layer3, maskLayer2*alpha2)\n    // col = mix(col, layer4, maskLayer3*alpha3)\n    // etc.\n    //\n    // The background - Just some subtle blending between redish colors and some randomized\n    // looking hatching. It's a design cliche, but it works. :)\n    float blend = dot(sin(uv*3.14159/8. - cos(uv.yx*3.14159/4.)*3.14159), vec2(.25)) + .5;\n    vec3 bG = mix(vec3(1.1, .05, .08)*1.1, vec3(.9, .1, 0)*1.1, length(p)*blend);\n    // Random looking diagonal hatch lines.\n    float hatch = clamp(sin((uv.x - uv.y)*3.14159*160.)*2. + .5, 0., 1.); // Diagonal lines.\n    float hRnd = hash21(floor(uv*240.));\n    if(hRnd>.66) hatch = hRnd; // Slight, randomization of the diagonal lines.  \n    bG *= hatch*.25 + .75; // Combining the colorful gradient background with the lines.\n    \n    // Mix the background with the border overlay. Note the \".8\" value for transparency.\n    vec3 col = mix(bG, vec3(0), bord*.8);\n\n    // Back shadow.\n    col = mix(col, vec3(.1, .02, .04), sh*.85);\n    \n    // Truchet overlay.\n    vec3 tCol = mix(vec3(1.2), vec3(.7, .75, .8), cos(a*2.*dir)*.5 + .5);\n    // \"mix(tCol, col, d)\" is the same, and more concise, but I wanted to show order.\n    col = mix(col, tCol, 1. - d); \n    \n    \n    // Adding in the edging.\n    col = mix(col, vec3(.05, 0, 0), 1. - ed);\n    \n    \n    // Mix in the arrows.\n    col = mix(col, vec3(.5, .05, .05), (1. - d2)*.95);\n    \n\n    // Dashed borders beside the arrows.\n    col = mix(col, vec3(0), (1. - d4)*.75);\n    \n    \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    //col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125);\n    // Colored variation.\n    col = mix(pow(min(vec3(1.5, 1, 1).zyx*col, 1.), vec3(1, 3, 16).zyx), col, \n             pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125));    \n    \n    \n    \n    // Screen color.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtfyDX.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[2461, 2494, 2514, 2514, 2572], [2574, 2631, 2652, 2652, 2716], [2718, 2718, 2754, 2754, 2825], [2827, 2827, 2855, 2855, 2876], [2879, 2879, 2935, 2967, 11727]]}
{"id": "Xtfyzl", "name": "Dynamic Amber", "author": "dr2", "description": "Post-Voronoian design for the Amber Room (mousing suggested)", "tags": ["voronoi", "reflection", "lighting"], "likes": 8, "viewed": 640, "date": "1505903200", "time_retrieved": "2024-06-20T19:02:10.471754", "image_code": "// \"Dynamic Amber\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrSphDf (vec3 p, float r);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nfloat SmoothMin (float a, float b, float r);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\n\nvec3 qnBlk[2], bSize, vnBall;\nvec2 gVec[7], hVec[7];\nfloat dstFar, tCur;\nint idObj;\nconst float pi = 3.14159;\n\n#define SQRT3 1.7320508\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./SQRT3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (SQRT3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\nvec4 HexVor (vec2 p)\n{\n  vec4 sd, udm;\n  vec2 ip, fp, d, u;\n  float amp, a;\n  amp = 0.7;\n  ip = PixToHex (p);\n  fp = p - HexToPix (ip);\n  sd = vec4 (4.);\n  udm = vec4 (4.);\n  for (int k = 0; k < 7; k ++) {\n    u = Hashv2v2 (ip + gVec[k]);\n    a = 1.5 * pi * (u.y - 0.5) * tCur;\n    d = hVec[k] + amp * (0.4 + 0.6 * u.x) * vec2 (cos (a), sin (a)) - fp;\n    sd.w = dot (d, d);\n    if (sd.w < sd.x) {\n      sd = sd.wxyw;\n      udm = vec4 (d, u);\n    } else sd = (sd.w < sd.y) ? sd.xwyw : ((sd.w < sd.z) ? sd.xyww : sd);\n  }\n  sd.xyz = sqrt (sd.xyz);\n  return vec4 (SmoothMin (sd.y, sd.z, 0.3) - sd.x, udm.xy, Hashfv2 (udm.zw));\n}\n\nvec2 BlkHit (vec3 ro, vec3 rd, vec3 bSize)\n{\n  vec3 v, tm, tp;\n  float dMin, dn, df;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  v = ro / rd;\n  tp = bSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = max (max (tm.x, tm.y), tm.z);\n  df = min (min (tp.x, tp.y), tp.z);\n  dMin = dstFar;\n  if (df > 0. && dn < df) {\n    dMin = dn;\n    qnBlk[0] = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n    qnBlk[1] = - sign (rd) * step (tp, tp.zxy) * step (tp, tp.yzx);\n  }\n  return vec2 (dMin, df);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float d, dMin;\n  dMin = dstFar;\n  q = p;  q.y -= bSize.y - 0.15;\n  dMin = PrSphDf (q, 0.15);\n  idObj = 1;\n  q = p;  q.y -= 0.5 * bSize.y;  q.xz = mod (q.xz, bSize.xz / 2.5) - bSize.xz / 5.;\n  d = max (max (PrSphDf (q, 0.06), q.y), - PrBox2Df (p.xz, bSize.xz - 0.06));\n  if (d < dMin) { dMin = d;  idObj = 2; }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat BallHit (vec3 ro, vec3 rd)\n{\n  vec3 p, u;\n  float b, d, w, dMin, rad;\n  dMin = dstFar;\n  rad = 0.2 * bSize.y;\n  p = vec3 (0., - bSize.y + 2. * rad, 0.);\n  u = ro - p;\n  b = dot (rd, u);\n  w = b * b - dot (u, u) + rad * rad;\n  if (w > 0.) {\n    d = - b - sqrt (w);\n    if (d > 0. && d < dMin) {\n      dMin = d;\n      vnBall = (u + d * rd) / rad;\n    }\n  }\n  return dMin;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 vc;\n  vec3 vn, ltPos, ltDir, col, col1, col2;\n  vec2 dBlock, w, iw, ww, q, b;\n  float dstObj, dstBall, spec, c, sd, wLit, glit;\n  HexVorInit ();\n  dstBall = BallHit (ro, rd);\n  if (dstBall < dstFar) {\n    ro += dstBall * rd;\n    rd = reflect (rd, vnBall);\n    ro += 0.01 * rd;\n  }\n  dBlock = BlkHit (ro, rd, bSize);\n  dstObj = ObjRay (ro, rd);\n  wLit = 0.;\n  glit = 0.;\n  if (dstObj < dBlock.y) {\n    ro += rd * dstObj;\n    vn = ObjNf (ro);\n    col = (idObj == 1) ? vec3 (1., 1., 0.9) : vec3 (0.9, 0.9, 0.7);\n    col *= 0.6 - 0.4 * dot (rd, vn);\n  } else if (dBlock.x < dstFar) {\n    vn = qnBlk[1];\n    ro += rd * dBlock.y;\n    if (vn.y == 0.) {\n      ltPos = vec3 (0., bSize.y, 0.);\n      if (abs (vn.z) == 1.) {\n        q = ro.xy;\n        b = bSize.xy;\n        sd = 1. + sign (vn.z);\n      } else {\n        q = ro.zy;\n        b = bSize.zy;\n        sd = 2. + sign (vn.x);\n      }\n      if (abs (q.y) < 0.95 * bSize.y) {\n        b *= vec2 (1./2.5, 0.95/1.5);\n        q += 0.5 * b;\n        iw = floor (q / b);\n        w = q - iw * b;\n        ww = 0.5 * b - abs (w - 0.5 * b);\n        wLit = 0.15 * (1. - smoothstep (0.1, 0.2, length (vec2 (1.5 * ww.x, abs (ro.y - 0.5 * bSize.y - 0.1)))));\n        if (min (ww.x, ww.y) > 0.01) {\n          vc = HexVor (32. * (w + 2. * iw * b + 11. * sd));\n          vn.xz = (abs (vn.z) == 1.) ? vec2 (vc.y, 2. * sign (vn.z)) : vec2 (2. * sign (vn.x), vc.y);\n          vn.y = - vc.z;\n          vn = normalize (vn);\n          c = 0.02 + 0.03 * vc.w + 0.04 * (mod (iw.x, 2.) - mod (iw.y, 2.)) + 0.02 * sd;\n          col1 = HsvToRgb (vec3 (c, 1., 0.6));\n          col2 = HsvToRgb (vec3 (c + 0.05, 1., 0.8));\n          col = mix (col1, col2, smoothstep (0.2, 0.8, Fbm2 (vc.yz + 50. * vc.w)));\n          col = mix (col, mix (col1, col2, 0.5), 1. - smoothstep (0.01, 0.05, vc.x));\n          spec = 0.15;\n          glit = 1.;\n        } else {\n          ww = smoothstep (0.002, 0.004, ww.xy);\n          col = vec3 (0.6, 0.3, 0.) * (1. - 0.1 * min (ww.x, ww.y));\n          spec = 0.1;\n        }\n      } else {\n        if (q.y > 0.) {\n          col = vec3 (0.7, 0.7, 0.8);\n          spec = 0.1;\n          vn = VaryNf (50. * ro, vn, 1.);\n        } else {\n          col = vec3 (0.4, 0.2, 0.1);\n          spec = 0.1;\n        }\n      }\n    } else if (vn.y > 0.) {\n      ltPos = vec3 (0., bSize.y, 0.);\n      col = 0.8 * mix (vec3 (0.8, 0.4, 0.2), vec3 (0.5, 0.25, 0.1),\n         Fbm2 (vec2 (50., 5.) * ro.xz)) *\n         (0.6 + 0.4 * smoothstep (0.03, 0.08, mod (10. * ro.x, 1.)));\n      col *= 0.6 + 0.4 * smoothstep (0.05, 0.15, length (ro.xz) / bSize.x);\n      spec = 0.1;\n    } else {\n      ltPos = vec3 (0., - bSize.y, 0.);\n      col = vec3 (0.7, 0.7, 0.8) * (0.7 + 0.3 * smoothstep (0., 0.15, length (ro.xz) / bSize.x));\n      spec = 0.1;\n      vn = VaryNf (50. * ro, vn, 1.);\n    }\n    ltDir = normalize (ltPos - ro);\n    if (glit > 0.) glit = 500. * step (0.01, max (0., dot (vn, ltDir))) *\n       pow (max (0., dot (ltDir, reflect (rd, vn))), 16.) *\n       pow (1. - 0.6 * abs (dot (normalize (ltDir - rd), VaryNf (1000. * ro, vn, 2.))), 8.);\n    col = wLit + glit * vec3 (1., 1., 0.5) + col * (0.1 + 0.8 * max (dot (vn, ltDir), 0.)) +\n       spec * pow (max (dot (normalize (ltDir - rd), vn), 0.), 128.);\n  } else col = vec3 (0.2);\n  return clamp (col, 0., 1.);  \n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  dstFar = 5.;\n  bSize = vec3 (2., 1., 2.);\n  ro = vec3 (0., 0., -0.9 * bSize.z);\n  rd = normalize (vec3 (uv, 3.));\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.7 * pi * mPtr.y;\n  }\n  el = clamp (el, -0.25 * pi, 0.25 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = vuMat * rd;\n  ro = vuMat * ro;\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec3 e = vec3 (0.1, 0., 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xtfyzl.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 531, 555, 555, 785], [787, 787, 811, 811, 871], [873, 873, 893, 893, 1113], [1115, 1115, 1137, 1137, 1741], [1743, 1743, 1787, 1787, 2291], [2293, 2293, 2315, 2315, 2654], [2656, 2656, 2689, 2689, 2865], [2867, 2867, 2888, 2888, 3090], [3092, 3092, 3126, 3126, 3469], [3471, 3471, 3506, 3506, 6806], [6808, 6808, 6864, 6864, 7654], [7656, 7656, 7689, 7689, 7778], [7780, 7780, 7813, 7813, 7840], [7842, 7842, 7887, 7887, 7990], [8024, 8024, 8048, 8048, 8108], [8110, 8110, 8134, 8134, 8264], [8266, 8266, 8291, 8291, 8477], [8479, 8479, 8500, 8500, 8655], [8657, 8657, 8686, 8686, 8898], [8900, 8900, 8939, 8939, 9123], [9125, 9125, 9155, 9155, 9213], [9215, 9215, 9239, 9239, 9375]]}
{"id": "XtlyWH", "name": "Manual multi-scale grid", "author": "etale_cohomology", "description": "Fork of https://www.shadertoy.com/view/XllyD8\n\nI'm addicted to grids (also, it's the only thing I can do)", "tags": ["2d", "simple", "grid", "math", "tutorial", "abs"], "likes": 2, "viewed": 188, "date": "1504628307", "time_retrieved": "2024-06-20T19:02:10.811198", "image_code": "// Fork of https://www.shadertoy.com/view/XllyD8\n\n#define SCALE 1. * (40. * (1.01 + sin(.4 * iTime)))  // Global scale!\n#define FSAA 4.  // Fullscreen antialiasing!\n\n#define GRID_SCALE0_FREQ .25\n#define GRID_SCALE1_FREQ 1.\n#define GRID_SCALE2_FREQ 4.\n\n#define MAX_GRID_SCALE0_SCALE (32. * GRID_SCALE0_FREQ)\n#define MAX_GRID_SCALE1_SCALE (32. * GRID_SCALE1_FREQ)\n#define MAX_GRID_SCALE2_SCALE (32. * GRID_SCALE2_FREQ)\n\n#define RGB_LIGHT vec3(.96)\n#define RGB_DARK  vec3(.04)\n#define RGB_GRAY  vec3(.7)\n#define RGB_BLUE  vec3(.0, .5, 1.)\n\n// I wonder if there's a shorter way to write this...\nvec2 df_op_repeat(vec2 point, vec2 frequency){\n    vec2 half_frequency = .5 * frequency;\n    return mod(point - half_frequency, frequency) - half_frequency;\n    //return frequency * (fract(point / frequency - .5) - .5);  // By ollj!\n}\n\nvec3 rgb_grid(vec2 uv, float aa){\n    //uv.y += sin(uv.x + iTime);\n\n    // This is the manual part. Instead of manually adding each scale (either unrolled or by looping through each scale),\n    // perhaps there's a way do write a function that does this *without* loops!\n    vec2 grid_scale0 = abs(df_op_repeat(uv, vec2(GRID_SCALE0_FREQ)));\n    vec2 grid_scale1 = abs(df_op_repeat(uv, vec2(GRID_SCALE1_FREQ)));\n    vec2 grid_scale2 = abs(df_op_repeat(uv, vec2(GRID_SCALE2_FREQ)));\n\n    // This is the manual part. Instead of manually adding each scale (either unrolled or by looping through each scale),\n    // perhaps there's a way do write a function that does this *without* loops!\n    vec3 rgb = RGB_LIGHT;  // Background color!\n    rgb = mix(rgb, RGB_GRAY, smoothstep(aa, .0, min(grid_scale0.x, grid_scale0.y)) * float(SCALE < MAX_GRID_SCALE0_SCALE));\n    rgb = mix(rgb, RGB_BLUE, smoothstep(aa, .0, min(grid_scale1.x, grid_scale1.y)) * float(SCALE < MAX_GRID_SCALE1_SCALE));\n    rgb = mix(rgb, RGB_DARK, smoothstep(aa, .0, min(grid_scale2.x, grid_scale2.y)) * float(SCALE < MAX_GRID_SCALE2_SCALE));\n    return rgb;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = SCALE * (2. * fragCoord - iResolution.xy) / iResolution.y;\n\n    float time = .1 * iTime;\n    uv = mat2(cos(time), -sin(time), sin(time), cos(time)) * uv;\n\n    float grid_aa = FSAA * SCALE / iResolution.y;\n    fragColor.rgb = rgb_grid(uv, grid_aa);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtlyWH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[537, 591, 637, 637, 825], [827, 827, 860, 1097, 1949], [1951, 1951, 2005, 2005, 2269]]}
{"id": "Xtlyzf", "name": "mouse and time", "author": "sgoal", "description": "mouse,simple", "tags": ["simple", "mouse"], "likes": 0, "viewed": 75, "date": "1505791204", "time_retrieved": "2024-06-20T19:02:10.811198", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy * 2. -  iResolution.xy) / min(iResolution.x , iResolution.y);\n    vec2 mxy =  iMouse.xy / iResolution.xy;\n    vec2 m = vec2(mxy.x *2.0 - 1.,mxy.y *2.0-1.);\n    float t = sin(length(m-uv)*30.+iTime*5.);\n\tfragColor = vec4(vec3(t),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xtlyzf.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 318]]}
{"id": "Xtlyzl", "name": "Apollonian Elevator-239 chars", "author": "GregRostami", "description": "This is a slight modification and reduction of Shane's amazing SH17A entry:\n[url]https://www.shadertoy.com/view/4d2BW1[/url]\nA BIG thanks to Fabrice for helping me reduce this shader.", "tags": ["raymarching", "twotweets", "apollonian", "short"], "likes": 17, "viewed": 3411, "date": "1506009509", "time_retrieved": "2024-06-20T19:02:10.817362", "image_code": "// 239 chars - coyote vanquished another char:\n#define L q *= k += 1.5 / dot(q = mod(--q, 2.) - 1., q) -k, s *= k//\n#define m (                                \\\n    q.y += .2*iTime, s = o/o,              \\\n    L,L,L,L,L,L,L,                         \\\n    length(q)/s - .01 )\n        \nvoid mainImage(out vec4 c, vec2 u)\n{\n    c-=c;\n    vec3 q = iResolution, o=q/q, s, k,\n         d = (vec3(u+u,q.y)-q)/q.y/6.;\n    for(; c.w++<1e2; ) q= o+= m*d;\n    q-=d; c.rgb = ( o*m - 2. ) / o.z + 1.;\n}\n\n/*\n\n// 240 chars - Replaced while with for and some more Fabrice MAGIC!\n#define L q *= k += 1.5 / dot(q = mod(--q, 2.) - 1., q) -k, s *= k//\n#define m (                                \\\n    q.y += .2*iTime, s = o/o,              \\\n    L,L,L,L,L,L,L,                         \\\n    length(q)/s - .01 )                   //\n#define mainImage(c,u)\t                   \\\n    vec3 q = iResolution,  o,s,k,          \\\n         d = (vec3(u+u,q.y)-q)/q.y/6.;     \\\n    for(o=q/q; c.w++<1e2; ) q= o+= m*d;    \\\n    q-=d; c.rgb = ( o*m - 2. ) / o.z + 1. /*\n\n\n// 247 chars - color shading and centered\n// Fabrice has already made this smaller ...\nfloat m(vec3 p)\n{\n    float i=0., s = 1., k;\n    for(p.y += .2*iTime ; i++<7.; s *= k )\n        p *= k = 1.5 / dot(p = mod(--p, 2.) - 1., p);\n    return length(p)/s - .01;   \n}\n\n#define mainImage(c,u)\t                 \\\n    vec3 o = iResolution,                \\\n         d = vec3((u+u-o.xy)/o.y, 1)/6.; \\\n         o/=o;\t                         \\\n    while(c.w++<1e2) o += m(o)*d;        \\\n    c.rgb = ( o*m(o - d) - 2. ) / o.z + 1.\n        \n\n// 219 chars - bare bones minimum\n\nfloat m(vec3 p) {\n    float i=0., s = 1., k;\n    for(p.z -= iTime ; i++<7.; s *= k )\n        p *= k = 1.5 / dot(p = mod(p - 1., 2.) - 1., p);\n    return length(p)/s - .01;   }\n\n#define mainImage(c,u)\t\t\t\t\t\t\t\t\\\n    vec3 d = vec3(u/iResolution.y-.8, 1)/6., o=d/d;\t\\\n    while(c.w++<1e2) o += m(o)*d;\t\t\t\t\t\\\n    c += m(o - d)  /*\n*/", "image_inputs": [{"id": "4slXDs", "previewfilepath": "https://soundcloud.com/antonio-antetomaso/mutiny-on-the-bounty-closing-titles-cover", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/antonio-antetomaso/mutiny-on-the-bounty-closing-titles-cover", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xtlyzl.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 284, 320, 320, 488]]}
{"id": "XtscWf", "name": "Radial Gradient Graphics", "author": "Kellers176", "description": "Gradient", "tags": ["agradientthingy"], "likes": 2, "viewed": 344, "date": "1506703137", "time_retrieved": "2024-06-20T19:02:10.944440", "image_code": "vec2 Position = vec2(0.1,0.1);\nfloat Radius = 1.0;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    //Without changing colors\n    //vec4 gradientColor = vec4(1.0 - length(Position - uv),0,1,1);\n\tvec4 gradientColor = vec4(1.0 - length(Position - uv),0.0 + 0.5 * sin(iTime),1.0 + 0.5 * cos(iTime),1.0);\n\n\n\tfragColor = gradientColor;\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtscWf.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[53, 53, 110, 110, 412]]}
{"id": "XtscWn", "name": "string wave / water wave bounce", "author": "FabriceNeyret2", "description": "From top to bottom:\nincident wave within a wave paquet along a string,\nbouncing wave on string attachment (right side),\ntotal wave.\nNB: for water waves, change b sign.", "tags": ["wave", "physics"], "likes": 2, "viewed": 640, "date": "1504349351", "time_retrieved": "2024-06-20T19:02:10.944666", "image_code": "const float c = 1., l = .2, la = 10.,           // celerity, wavelength, wave paquet length\n            k = 6.28 / l, ka = 6.28 / la;       // wave number\n\nfloat f( float x, float t) {                    // wave shape\n    x -= c*t; x = min(0.,x);                    // phase\n    if ( sin(ka/2.*x) > 0. ) x=0.;\n    return  .1*l*(.5-.5*cos(ka*x)) * sin(k*x);  // wave paquet amplitude * wave\n}\n\n#define D(v)  smoothstep( 8./R.y, 0., abs ( v -U.y )  )      // draw curve\n    \nvoid mainImage( out vec4 O, vec2 U )\n{\n\tvec2 R =  iResolution.xy;\n    U = ( U+U - R ) / R.y;\n    \n    float y =       f(U.x, iTime),              // incident wave\n          b =  -.8* f( 2.*R.x/R.y-U.x, iTime);  // bouncing wave.  Sign: -: string +: water wave\n    \n    O = vec4( D( y+b -.2) );                    // draw total wave\n    O.gb +=   D( y   +.4);                      // incident wave\n    O.b  +=   D( b   +.2);                      // bouncing wave\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtscWn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[140, 156, 184, 217, 391], [473, 473, 511, 511, 936]]}
{"id": "XtsyRB", "name": "Sphere Frustum Tracing", "author": "paniq", "description": "crossing planes indicate outer and inner near and far depths of sphere within frustum. Inner boundaries show 100% occlusion. The segments between outer and inner planes enclose a part of the surface.", "tags": ["sphere", "intersection", "frustum"], "likes": 45, "viewed": 1799, "date": "1505329818", "time_retrieved": "2024-06-20T19:02:17.205748", "image_code": "// Sphere Frustum Tracing\n// using 2d vector graphics library (https://www.shadertoy.com/view/lslXW8)\n\n// for a description of the algorithm see\n// https://gist.github.com/paniq/6c7a465b841dc2c87294c61108370389\n\n// note that this version is very verbose and purposefully lacks \n// any form of optimization for the sake of education.\n\nconst vec3 sphere_init_center = vec3(0.0, 0.0, 3.0);\nconst vec2 min_frustum_half_size = vec2(1.77778,1.0)/30.0;\nconst vec2 max_frustum_half_size = vec2(1.77778,1.0)/6.0;\n\nconst int bound_none = 0;\nconst int bound_ray = 1;\nconst int bound_volume = 2;\nconst int bound_plane = 3;\n\nvec2 frustum_center;\nvec2 frustum_half_size;\nvec3 sphere_center;\nvec2 frustum_corners[4];\nvec3 frustum_ray_dirs[4];\nvec3 frustum_planes[4];\nvec2 sphere_ray_hits[4]; // these are scalars along the ray direction\nbvec2 sphere_has_circle[4];\nvec3 circle_near[4];\nvec3 circle_far[4];\nbvec2 sphere_has_bound;\nvec3 sphere_near;\nvec3 sphere_far;\nvec2 outer_bound;\nvec2 inner_bound;\nivec2 outer_bound_type;\nivec2 inner_bound_type;\n\n// check only the horizontal frustum planes\nfloat dFrustumH(vec3 p) {\n    return max(\n        dot(p, frustum_planes[0]),\n        dot(p, frustum_planes[2]));    \n}\n\n// check only the vertical frustum planes\nfloat dFrustumV(vec3 p) {\n    return max(\n        dot(p, frustum_planes[1]),\n        dot(p, frustum_planes[3]));    \n}\n\nfloat dFrustum(vec3 p) {\n    return max(\n        dFrustumH(p),\n        dFrustumV(p));\n}\n\nvec2 intersect_unit_sphere(in vec3 ro, in vec3 rd) {\n\tfloat k = dot(ro, rd);\n    float q = sqrt(k*k - dot(ro, ro) + 1.0);\n    return vec2(-q,q) - k;\n}\n\n// for a circle formed by intersection of frustum plane\n// and unit sphere, return the nearest and farthest point\n// on the circle relative to the screen plane\nvoid intersect_plane_sphere(int mc, vec3 plane, vec3 sphere, \n\tout vec3 near, out vec3 far, out bvec2 has_bounds) {\n    // distance from plane to center of sphere\n    float d = dot(plane, sphere);\n    float d2 = d*d;\n    if (d2 > 1.0) {\n        has_bounds = bvec2(false);\n       \treturn;\n    }\n    // center of sphere projected to plane = center of circle\n    vec3 c = sphere - d*plane;\n    // radius of circle\n    float r = sqrt(1.0-d2);\n    // ray direction to circle center\n    vec3 n = c;\n    // null the component orthogonal to the screen plane\n    if (mc == 0) {\n        n.x = 0.0;\n    } else {\n        n.y = 0.0;\n    }\n    n = normalize(n);\n    near = c - n*r;\n    far = c + n*r;\n    if (mc == 0) {\n        has_bounds[0] = (dFrustumV(near) <= 0.0);\n        has_bounds[1] = (dFrustumV(far) <= 0.0);\n    } else {\n        has_bounds[0] = (dFrustumH(near) <= 0.0);\n        has_bounds[1] = (dFrustumH(far) <= 0.0);\n    }\n}\n\nvec2 lissajous(float t, float a, float b) {\n    return vec2(sin(a*t), sin(b*t));\n}\n\nvoid compute_bounds() {\n    outer_bound_type = ivec2(bound_none);\n    inner_bound_type = ivec2(bound_none);\n    outer_bound = vec2(1.0/0.0,-1.0/0.0);\n    inner_bound = vec2(-1.0/0.0,1.0/0.0);\n    \n    // check volume bounds first\n    // those are always the closest\n    if (sphere_has_bound[0]) {\n        outer_bound[0] = sphere_near.z;\n        outer_bound_type[0] = bound_volume;\n    } else {\n        // check circle bounds next\n        for (int i = 0; i < 4; ++i) {\n            if (sphere_has_circle[i][0]\n                && (circle_near[i].z < outer_bound[0])) {\n                outer_bound[0] = circle_near[i].z;\n                outer_bound_type[0] = bound_plane;\n            }\n        }\n        // also check for ray hits\n        for (int i = 0; i < 4; ++i) {\n            if (sphere_ray_hits[i].x >= 0.0) {\n                vec3 p = frustum_ray_dirs[i] * sphere_ray_hits[i].x;\n                if (p.z < outer_bound[0]) {\n                    outer_bound[0] = p.z;\n                    outer_bound_type[0] = bound_ray;\n                }\n            }\n        }\n    }\n    // don't need to continue if we couldn't find a nearest depth\n    if (outer_bound_type[0] == bound_none) return;\n    \n    // check volume bounds first\n    if (sphere_has_bound[1]) {\n        outer_bound[1] = sphere_far.z;\n        outer_bound_type[1] = bound_volume;\n    } else {\n        // check circle bounds next\n        for (int i = 0; i < 4; ++i) {\n            if (sphere_has_circle[i][1]\n                && (circle_far[i].z > outer_bound[1])) {\n                outer_bound[1] = circle_far[i].z;\n                outer_bound_type[1] = bound_plane;\n            }\n        }\n        // also check for ray hits\n        for (int i = 0; i < 4; ++i) {\n            if (sphere_ray_hits[i].y >= 0.0) {\n                vec3 p = frustum_ray_dirs[i] * sphere_ray_hits[i].y;\n                if (p.z > outer_bound[1]) {\n                    outer_bound[1] = p.z;\n                    outer_bound_type[1] = bound_ray;\n                }\n            }\n        }\n    }    \n    \n    // we have an interior interval if all four corners\n    // hit the sphere\n    \n    int hits = 0;\n    for (int i = 0; i < 4; ++i) {\n        if (sphere_ray_hits[i].x >= 0.0) {\n            hits++;\n        }    \n    }\n    \n    if (hits == 4) {\n        for (int i = 0; i < 4; ++i) {\n            if (sphere_ray_hits[i].x >= 0.0) {\n                vec3 p0 = frustum_ray_dirs[i] * sphere_ray_hits[i].x;\n                vec3 p1 = frustum_ray_dirs[i] * sphere_ray_hits[i].y;\n                if (p0.z > inner_bound[0]) {\n                    inner_bound[0] = p0.z;\n                    inner_bound_type[0] = bound_ray;                \n                }\n                if (p1.z < inner_bound[1]) {\n                    inner_bound[1] = p1.z;\n                    inner_bound_type[1] = bound_ray;\n                }\n            }\n        }\n    }\n    \n    // if the interval is negative, we can't use it\n    if (inner_bound[1] < inner_bound[0]) {\n        inner_bound_type[0] = bound_none;\n    }    \n}\n\nvoid setup_globals(float t) {\n    // move the frustum around\n    frustum_center = lissajous(t*0.07, 2.0, 1.0)*0.1;\n    // vary the frustum aperture\n    frustum_half_size = mix(\n        min_frustum_half_size,\n\t\tmax_frustum_half_size,\n        cos(t*0.13)*0.5+0.5);\n    \n    // move our sphere around a bit\n    vec2 sphere_offset = lissajous(t*0.2, 5.0, 4.0)*0.3;\n    sphere_center = sphere_init_center + vec3(sphere_offset, 0.0);\n    \n\tsphere_near = sphere_center - vec3(0.0,0.0,1.0);\n    sphere_far = sphere_center + vec3(0.0,0.0,1.0);\n    \n    vec3 frustum_extents = vec3(frustum_half_size,-frustum_half_size.x);\n    frustum_corners[0] = frustum_center + frustum_extents.xy;\n    frustum_corners[1] = frustum_center + frustum_extents.zy;\n    frustum_corners[2] = frustum_center - frustum_extents.xy;\n    frustum_corners[3] = frustum_center - frustum_extents.zy;\n\n    for (int i = 0; i < 4; ++i) {\n        frustum_ray_dirs[i] = normalize(vec3(frustum_corners[i],1.0));\n    }\n    \n    for (int i = 0; i < 4; ++i) {\n\t\tsphere_ray_hits[i] = intersect_unit_sphere(-sphere_center, frustum_ray_dirs[i]);\n    }\n    \n    frustum_planes[0] = normalize(cross(frustum_ray_dirs[1],frustum_ray_dirs[0]));\n    frustum_planes[1] = normalize(cross(frustum_ray_dirs[2],frustum_ray_dirs[1]));\n    frustum_planes[2] = normalize(cross(frustum_ray_dirs[3],frustum_ray_dirs[2]));\n    frustum_planes[3] = normalize(cross(frustum_ray_dirs[0],frustum_ray_dirs[3]));\n\n    sphere_has_bound[0] = (dFrustum(sphere_near) < 0.0);\n    sphere_has_bound[1] = (dFrustum(sphere_far) < 0.0);\n    \n    intersect_plane_sphere(0, frustum_planes[0], \n\t\tsphere_center, circle_near[0], circle_far[0], sphere_has_circle[0]);\n    intersect_plane_sphere(1, frustum_planes[1], \n\t\tsphere_center, circle_near[1], circle_far[1], sphere_has_circle[1]);\n    intersect_plane_sphere(0, frustum_planes[2], \n\t\tsphere_center, circle_near[2], circle_far[2], sphere_has_circle[2]);\n    intersect_plane_sphere(1, frustum_planes[3], \n\t\tsphere_center, circle_near[3], circle_far[3], sphere_has_circle[3]);\n    \n\tcompute_bounds();    \n   \n}\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1);\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1);\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r);\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r);\nvoid set_source(sampler2D image);\n// control how source changes are applied\nconst int Replace = 0; // default: replace the new source with the old one\nconst int Alpha = 1; // alpha-blend the new source on top of the old one\nconst int Multiply = 2; // multiply the new source with the old one\nvoid set_source_blend_mode(int mode);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add an ellipse path at P with radii RW and RH\nvoid ellipse(vec2 p, vec2 r);\nvoid ellipse(float x, float y, float rw, float rh);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n// add a rectangle at O with size S and rounded corner of radius R\nvoid rounded_rectangle(vec2 o, vec2 s, float r);\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// non-uniformly scale the context by S\nvoid scale(vec2 s);\nvoid scale(float sx, float sy);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    vec2 clip;\n    vec2 scale;\n    float line_width;\n    bool premultiply;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n    int source_blend;\n    bool has_clip;\n};\n\nfloat AA;\nfloat AAINV;\n\n// save current stroke width, starting\n// point and blend mode from active context.\nContext _save();\n// restore stroke width, starting point\n// and blend mode to a context previously returned by save()\nvoid restore(Context ctx);\n\n#define save(name) Context name = _save();\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\nvoid debug_clip_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\nconst float max_frustum_depth = 5.0;\nconst vec3 light_dir = normalize(vec3(-1.0, -1.0, 1.0));\nconst vec3 backlight_dir = normalize(vec3(0.8, 1.0, -1.0));\n\n\n// from https://www.shadertoy.com/view/4sjXW1\nvec3 tex(in vec2 p)\n{\n    float frq =50.3;\n    p += 0.405;\n    return vec3(1.)*smoothstep(.9, 1.05, max(sin((p.x)*frq),sin((p.y)*frq)));\n}\nvec3 sphproj(in vec3 p)\n{\n    vec2 sph = vec2(acos(p.y/length(p)), atan(p.z,p.x));    \n    vec3 col = tex(sph*.9);\n    return hsl(0.0,0.0,1.0-col.z*0.5);\n}\n\nvoid paint_sphere(vec3 ro, vec3 rd) {\n    vec3 ro_c = ro - sphere_center;\n    vec2 range = intersect_unit_sphere(ro_c, rd);\n    if (range.x > 0.0) {\n        add_field(-1.0);\n        vec3 dist = rd * range.x;\n        float df = dFrustum(ro + dist);\n        vec3 normal;\n        bool backface = false;\n        if (df < 0.0) {\n            normal = -normalize(ro_c + dist);\n        } else {\n            backface = true;\n            dist = rd * range.y;\n            df = dFrustum(ro + dist);\n            normal = normalize(ro_c + dist);\n        }\n        vec3 color = vec3(0.0, 0.05, 0.1);\n        float lit = max(dot(normal, light_dir), 0.0);\n        float backlit = max(dot(normal, backlight_dir), 0.0);\n        color += lit * vec3(1.0,0.9,0.8);\n        color += backlit * vec3(1.0);\n        if (df < 0.0) {\n\t\t\tcolor *= sphproj(normal);\n            if (backface) {\n                color *= vec3(0.7,0.9,1.0);\n            }                \n        }\n        color = pow(color, vec3(0.5));\n        color = mix(color, vec3(1.0), float(df > 0.0)*0.8);\n        color = mix(vec3(0.0), color, clamp((abs(df)-AAINV*1.5)*AA,-1.0,1.0)*0.5+0.5);\n        set_source_rgb(color);\n\t    fill();\n\t    new_path();\n    }\n}\n\nvoid paint_sphere_zx() {\n    vec2 pt = get_origin();\t\n    paint_sphere(\n        vec3(-pt[1], 2.0, pt[0]),\n        vec3(0.0, -1.0, 0.0));    \n}\n\nvoid paint_sphere_zy() {\n    vec2 pt = get_origin();\t\n    paint_sphere(\n        vec3(2.0, pt[1], pt[0]),\n        vec3(-1.0, 0.0, 0.0));    \n}\n\nvoid paint_sphere_xy() {\n    vec2 pt = get_origin();\t\n    paint_sphere(\n        vec3(pt[0], pt[1], -2.0),\n        vec3(0.0, 0.0, 1.0));\n}\n\nvoid paint_frustum_edges(vec2 pt[4]) {\n    for (int i = 0; i < 4; ++i) {\n\t\tmove_to(0.0, 0.0);\n\t\tline_to(pt[i]);\n    }\n    move_to(pt[0]);\n    for (int i = 1; i < 4; ++i) {\n\t\tline_to(pt[i]);\n    }    \n    close_path();\n}\n\nvoid paint_frustum_zx() {\n\tvec2 pts[4];\n    for (int i = 0; i < 4; ++i) {\n        vec3 corner = vec3(frustum_corners[i],1.0) * max_frustum_depth;\n        pts[i] = vec2(corner[2],-corner[0]);\n\t}\n    paint_frustum_edges(pts);\n}\nvoid paint_frustum_zy() {\n\tvec2 pts[4];\n    for (int i = 0; i < 4; ++i) {\n        vec3 corner = vec3(frustum_corners[i],1.0) * max_frustum_depth;\n        pts[i] = vec2(corner[2],corner[1]);\n\t}\n    paint_frustum_edges(pts);\n}\nvoid paint_frustum_xy() {\n\tvec2 pts[4];\n    for (int i = 0; i < 4; ++i) {\n        vec3 corner = vec3(frustum_corners[i],1.0) * max_frustum_depth;\n        pts[i] = vec2(corner[0],corner[1]);\n\t}\n    paint_frustum_edges(pts);\n}\n\nvec3 bound_color(int bound) {\n    if (bound == bound_volume) {\n        return vec3(1.0,0.0,0.5);\n    } else if (bound == bound_plane) {\n        return vec3(0.0,0.5,1.0);\n    } else if (bound == bound_ray) {\n        return vec3(1.0,0.5,0.0);\n    } else {\n        return vec3(0.0);\n    }\n}\n\nvoid paint() {\n    float t = iTime;\n    setup_globals(t);    \n        \n    float rdot = AAINV*8.0;\n\n    scale(0.4);\n\t\n    save(topview);\n    translate(-1.0,0.9);\n    save(topviewctx);\n    paint_sphere_zx();\n    if (outer_bound_type[0] != bound_none) {\n        if (inner_bound_type[0] != bound_none) {\n            vec3 p0 = vec3(frustum_corners[1],1.0) * inner_bound[0];\n            vec3 p1 = vec3(frustum_corners[0],1.0) * inner_bound[0];\n            vec3 p2 = vec3(frustum_corners[0],1.0) * inner_bound[1];\n            vec3 p3 = vec3(frustum_corners[1],1.0) * inner_bound[1];\n            set_source_rgba(1.0,0.5,0.0,0.3);\n            move_to(p0.z, -p0.x);\n            line_to(p1.z, -p1.x);\n            line_to(p2.z, -p2.x);\n            line_to(p3.z, -p3.x);\n            close_path();\n            set_line_width(0.2);\n            fill();\n        }        \n        vec3 p0 = vec3(frustum_corners[1],1.0) * outer_bound[0];\n        vec3 p1 = vec3(frustum_corners[0],1.0) * outer_bound[0];\n        vec3 p2 = vec3(frustum_corners[0],1.0) * outer_bound[1];\n        vec3 p3 = vec3(frustum_corners[1],1.0) * outer_bound[1];\n        set_line_width_px(1.0);\n        set_source_rgb(bound_color(outer_bound_type[0]));\n\t\tmove_to(p0.z, -p0.x); \n        line_to(p1.z, -p1.x);\n\t\tstroke();\n        set_source_rgb(bound_color(outer_bound_type[1]));\n\t\tmove_to(p2.z, -p2.x); \n        line_to(p3.z, -p3.x);\n\t\tstroke();        \n    }\n    set_source_rgb(vec3(0.0));\n    set_line_width_px(1.0);\n    paint_frustum_zx();\n    stroke();\n    set_source_rgb(0.0,0.5,1.0);\n    for (int i = 0; i < 4; ++i) {\n        if (i == 2) continue;\n        if (sphere_has_circle[i][0]) {\n            circle(circle_near[i].z, -circle_near[i].x, rdot);\n        }\n        if (sphere_has_circle[i][1]) {\n            circle(circle_far[i].z, -circle_far[i].x, rdot);\n        }\n    }\n    fill();                    \n    set_source_rgb(1.0,0.0,0.5);\n    if (sphere_has_bound[0])\n    \tcircle(sphere_near.z, -sphere_near.x, rdot);\n    if (sphere_has_bound[1])\n\t    circle(sphere_far.z, -sphere_far.x, rdot);\n    fill();                  \n    restore(topview);\n\t\n    save(sideview);\n    translate(-1.0,-1.6);\n    save(sideviewctx);\n    paint_sphere_zy();\n    if (outer_bound_type[0] != bound_none) {\n        if (inner_bound_type[0] != bound_none) {\n            vec3 p0 = vec3(frustum_corners[0],1.0) * inner_bound[0];\n            vec3 p1 = vec3(frustum_corners[3],1.0) * inner_bound[0];\n            vec3 p2 = vec3(frustum_corners[3],1.0) * inner_bound[1];\n            vec3 p3 = vec3(frustum_corners[0],1.0) * inner_bound[1];\n            set_source_rgba(1.0,0.5,0.0,0.3);\n            move_to(p0.zy);\n            line_to(p1.zy);\n            line_to(p2.zy);\n            line_to(p3.zy);\n            close_path();\n            set_line_width(0.2);\n            fill();\n        }                \n        vec3 p0 = vec3(frustum_corners[0],1.0) * outer_bound[0];\n        vec3 p1 = vec3(frustum_corners[3],1.0) * outer_bound[0];\n        vec3 p2 = vec3(frustum_corners[3],1.0) * outer_bound[1];\n        vec3 p3 = vec3(frustum_corners[0],1.0) * outer_bound[1];\n        set_line_width_px(1.0);\n        set_source_rgb(bound_color(outer_bound_type[0]));\n\t\tmove_to(p0.zy); \n        line_to(p1.zy);\n\t\tstroke();\n        set_source_rgb(bound_color(outer_bound_type[1]));\n\t\tmove_to(p2.zy); \n        line_to(p3.zy);\n\t\tstroke();        \n    }    \n    set_source_rgb(vec3(0.0));\n    set_line_width_px(1.0);\n    paint_frustum_zy();\n    stroke();\n    set_source_rgb(0.0,0.5,1.0);\n    for (int i = 0; i < 4; ++i) {\n        if (sphere_has_circle[i][0]) {\n            circle(circle_near[i].z, circle_near[i].y, rdot);\n        }\n        if (sphere_has_circle[i][1]) {\n            circle(circle_far[i].z, circle_far[i].y, rdot);\n        }\n    }\n    fill();\n    set_source_rgb(1.0,0.0,0.5);\n    if (sphere_has_bound[0])\n    \tcircle(sphere_near.z, sphere_near.y, rdot);\n    if (sphere_has_bound[1])\n\t    circle(sphere_far.z, sphere_far.y, rdot);\n    fill();    \n    restore(sideview);\n    \n\tsave(backview);\n    translate(-2.5,-0.4);\n    save(backviewctx);\n    paint_sphere_xy();\n    if (outer_bound_type[0] != bound_none) {\n        {\n            vec3 p0 = vec3(frustum_corners[0],1.0) * outer_bound[1];\n            vec3 p1 = vec3(frustum_corners[1],1.0) * outer_bound[1];\n            vec3 p2 = vec3(frustum_corners[2],1.0) * outer_bound[1];\n            vec3 p3 = vec3(frustum_corners[3],1.0) * outer_bound[1];\n            set_source_rgba(vec4(bound_color(outer_bound_type[1]),0.3));\n            move_to(p0.xy);\n            line_to(p1.xy);\n            line_to(p2.xy);\n            line_to(p3.xy);\n            close_path();\n            set_line_width_px(1.0);\n            stroke();\n        }        \n        if (inner_bound_type[0] != bound_none) {\n            vec3 p0 = vec3(frustum_corners[0],1.0) * inner_bound[1];\n            vec3 p1 = vec3(frustum_corners[1],1.0) * inner_bound[1];\n            vec3 p2 = vec3(frustum_corners[2],1.0) * inner_bound[1];\n            vec3 p3 = vec3(frustum_corners[3],1.0) * inner_bound[1];\n            set_source_rgba(vec4(bound_color(inner_bound_type[1]),0.3));\n            move_to(p0.xy);\n            line_to(p1.xy);\n            line_to(p2.xy);\n            line_to(p3.xy);\n            close_path();\n            set_line_width_px(1.0);\n            stroke();            \n        }\n        {\n            vec3 p0 = vec3(frustum_corners[0],1.0) * outer_bound[0];\n            vec3 p1 = vec3(frustum_corners[1],1.0) * outer_bound[0];\n            vec3 p2 = vec3(frustum_corners[2],1.0) * outer_bound[0];\n            vec3 p3 = vec3(frustum_corners[3],1.0) * outer_bound[0];\n            set_source_rgb(bound_color(outer_bound_type[0]));\n            move_to(p0.xy);\n            line_to(p1.xy);\n            line_to(p2.xy);\n            line_to(p3.xy);\n            close_path();\n            set_line_width_px(1.0);\n            stroke();\n        }\n        if (inner_bound_type[0] != bound_none) {\n            vec3 p0 = vec3(frustum_corners[0],1.0) * inner_bound[0];\n            vec3 p1 = vec3(frustum_corners[1],1.0) * inner_bound[0];\n            vec3 p2 = vec3(frustum_corners[2],1.0) * inner_bound[0];\n            vec3 p3 = vec3(frustum_corners[3],1.0) * inner_bound[0];\n            set_source_rgb(bound_color(inner_bound_type[1]));\n            move_to(p0.xy);\n            line_to(p1.xy);\n            line_to(p2.xy);\n            line_to(p3.xy);\n            close_path();\n            set_line_width_px(1.0);\n            stroke();            \n        }        \n    }\n    set_source_rgb(vec3(0.0));\n    set_line_width_px(1.0);\n    paint_frustum_xy();\n    stroke();\n    set_source_rgb(1.0,0.0,0.5);\n    if (sphere_has_bound[0])\n    \tcircle(sphere_near.x, sphere_near.y, rdot);\n    if (sphere_has_bound[1])\n\t    circle(sphere_far.x, sphere_far.y, rdot);\n    fill();    \n    restore(backview);\n\n    for (int i = 0; i < 4; ++i) {\n        vec2 dists = sphere_ray_hits[i];\n        restore(backviewctx);\n        set_source_rgb(0.0,0.5,1.0);\n        if (sphere_has_circle[i][0]) {            \n            circle(circle_near[i].x, circle_near[i].y, rdot);\n        }\n        if (sphere_has_circle[i][1]) {\n            circle(circle_far[i].x, circle_far[i].y, rdot);\n        }        \n        fill();                    \n        if (dists.x > 0.0) {\n\t        vec3 enter = frustum_ray_dirs[i] * dists.x;\n            vec3 leave = frustum_ray_dirs[i] * dists.y;\n\t\t    restore(backviewctx);\n            set_source_rgb(1.0,0.5,0.0);\n            circle(enter.x, enter.y, rdot);\n            circle(leave.x, leave.y, rdot);\n            fill();\n            if (i < 2) {\n\t\t\t    restore(topviewctx);\n                set_source_rgb(1.0,0.5,0.0);\n                circle(enter.z, -enter.x, rdot);\n                circle(leave.z, -leave.x, rdot);\n                fill();\n            }\n            if ((i == 0)||(i == 3)) {\n\t\t\t    restore(sideviewctx);\n                set_source_rgb(1.0,0.5,0.0);\n                circle(enter.z, enter.y, rdot);\n                circle(leave.z, leave.y, rdot);\n                fill();                \n            }\n        }\n    }\n    \n    \n}\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n#define DEFAULT_CLIP_V -1e+20\n\nContext _stack;\n\nvoid init (vec2 fragCoord) {\n    uv = fragCoord.xy / iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n\n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        vec2(DEFAULT_CLIP_V),\n        vec2(1.0),\n        1.0,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0),\n        Replace,\n        false\n    );\n}\n\nvec3 _color = vec3(1.0);\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n    _stack.clip.y = DEFAULT_CLIP_V;\n}\n\nContext _save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;\n    vec2 clip = _stack.clip;\n    bool has_clip = _stack.has_clip;\n    // preserve source\n    vec4 source = _stack.source;\n    _stack = ctx;\n    _stack.shape = shape;\n    _stack.clip = clip;\n    _stack.source = source;\n    _stack.has_clip = has_clip;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = vec2(1.0);\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;\n    _stack.scale = vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    _stack.scale *= vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(vec2 s) {\n    transform(mat3(s.x,0.0,0.0,0.0,s.y,0.0,0.0,0.0,1.0));\n}\n\nvoid scale(float sx, float sy) {\n    scale(vec2(sx, sy));\n}\n\nvoid scale(float s) {\n    scale(vec2(s));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color = mix(_color, _stack.source.rgb, _stack.source.a);\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(_color, 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = _color;\n}\n\nvoid add_clip(vec2 d) {\n    d = d / _stack.scale;\n    _stack.clip = max(_stack.clip, d);\n    _stack.has_clip = true;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);\n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n    _stack.clip = vec2(DEFAULT_CLIP_V);\n    _stack.has_clip = false;\n}\n\nvoid debug_gradient() {\n    vec2 d = _stack.shape;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid debug_clip_gradient() {\n    vec2 d = _stack.clip;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color = _color * (1.0 - src_a) + rgba.rgb * dst_a;\n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat min_uniform_scale() {\n    return min(_stack.scale.x, _stack.scale.y);\n}\n\nfloat uniform_scale_for_aa() {\n    return min(1.0, _stack.scale.x / _stack.scale.y);\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA*uniform_scale_for_aa(), 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);\n\treturn wa * wb;\n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n    if (_stack.has_clip) {\n\t    write_color(_stack.source, calc_aa_blur(_stack.clip.x));        \n    }\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*min_uniform_scale() * AAINV;\n}\n\nfloat get_gradient_eps() {\n    return (1.0 / min_uniform_scale()) * AAINV;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    if (_stack.source_blend == Multiply) {\n        _stack.source *= c;\n    } else if (_stack.source_blend == Alpha) {\n    \tfloat src_a = c.a;\n    \tfloat dst_a = _stack.premultiply?1.0:src_a;\n\t    _stack.source =\n            vec4(_stack.source.rgb * (1.0 - src_a) + c.rgb * dst_a,\n                 max(_stack.source.a, c.a));\n    } else {\n    \t_stack.source = c;\n    }\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) {\n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1) {\n    vec2 pa = _stack.position.xy - p0;\n    vec2 ba = p1 - p0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1) {\n    set_source_linear_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p0, p1);\n}\n\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r) {\n    float h = clamp( length(_stack.position.xy - p) / r, 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r) {\n    set_source_radial_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p, r);\n}\n\nvoid set_source_blend_mode(int mode) {\n    _stack.source_blend = mode;\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid rounded_rectangle(vec2 o, vec2 s, float r) {\n    s = (s * 0.5);\n    r = min(r, min(s.x, s.y));\n    o += s;\n    s -= r;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    vec2 df = max(dmin.xz, dmin.yw) + length2(dmax);\n    add_field(df - r);\n}\n\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), r);\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    rounded_rectangle(o, s, 0.0);\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), 0.0);\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\n// from https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n    if (l == 0.0) {\n        return length(p) - ab.x;\n    }\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 r = vec2( ab.x*co, ab.y*si );\n\t\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nvoid ellipse(vec2 p, vec2 r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(sdEllipse(c.xy, r), sdEllipse(c.zw, r)));\n}\n\nvoid ellipse(float x, float y, float rw, float rh) {\n    ellipse(vec2(x,y), vec2(rw, rh));\n}\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 s = sign(pa.xz*ba.y-pa.yw*ba.x);\n    vec2 d = length2(pa - ba.xyxy*h.xxyy);\n    add_field(d);\n    add_clip(d * s);\n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat test_cross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat bezier_sign(vec2 A, vec2 B, vec2 C, vec2 p) {\n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0,\n        step(test_cross(A, B, p) * test_cross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * test_cross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    vec2 shape = vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw));\n    add_field(abs(shape));\n    add_clip(shape);\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(abs(f_x) / length(df_x));\n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t aspect = vec2(iResolution.x / iResolution.y, 1.0);\n\t ScreenH = min(iResolution.x,iResolution.y);\n\t AA = ScreenH*0.4;\n\t AAINV = 1.0 / AA;\n\n    init(fragCoord);\n\n    paint();\n\n    blit(fragColor);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtsyRB.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1035, 1079, 1104, 1104, 1197], [1199, 1241, 1266, 1266, 1359], [1361, 1361, 1385, 1385, 1448], [1450, 1450, 1502, 1502, 1600], [1602, 1762, 1877, 1924, 2686], [2688, 2688, 2731, 2731, 2770], [2772, 2772, 2795, 2795, 5789], [5791, 5791, 5820, 5851, 7865], [13898, 13944, 13965, 13965, 14082], [14083, 14083, 14108, 14108, 14238], [14240, 14240, 14277, 14277, 15440], [15442, 15442, 15466, 15466, 15584], [15586, 15586, 15610, 15610, 15727], [15729, 15729, 15753, 15753, 15866], [15868, 15868, 15906, 15906, 16087], [16089, 16089, 16114, 16114, 16314], [16315, 16315, 16340, 16340, 16539], [16540, 16540, 16565, 16565, 16764], [16766, 16766, 16795, 16795, 17053], [17055, 17055, 17069, 17069, 25134], [25288, 25348, 25375, 25375, 25401], [25403, 25463, 25484, 25484, 25591], [25593, 25593, 25630, 25630, 25716], [25718, 25718, 25764, 25764, 25797], [25799, 25937, 25965, 25965, 26425], [26453, 26453, 26472, 26472, 26505], [26507, 26507, 26525, 26525, 26558], [26560, 26560, 26584, 26584, 26688], [26690, 26690, 26707, 26707, 26728], [26730, 26730, 26757, 26779, 27062], [27064, 27064, 27092, 27092, 27326], [27328, 27328, 27352, 27352, 27438], [27440, 27440, 27467, 27467, 27680], [27682, 27682, 27708, 27708, 27936], [27938, 27938, 27960, 27960, 28086], [28088, 28088, 28108, 28108, 28168], [28170, 28170, 28202, 28202, 28229], [28231, 28231, 28252, 28252, 28274], [28276, 28276, 28300, 28300, 28360], [28362, 28362, 28396, 28396, 28420], [28422, 28422, 28436, 28436, 28500], [28502, 28502, 28528, 28528, 28560], [28562, 28562, 28588, 28588, 28609], [28611, 28611, 28634, 28634, 28729], [28731, 28731, 28755, 28755, 28824], [28826, 28826, 28851, 28851, 28898], [28900, 28900, 28917, 28917, 29030], [29032, 29032, 29055, 29055, 29184], [29186, 29186, 29214, 29214, 29342], [29344, 29344, 29368, 29368, 29508], [29510, 29510, 29548, 29548, 29682], [29684, 29684, 29721, 29721, 29756], [29758, 29758, 29785, 29785, 29835], [29837, 29837, 29867, 29867, 29923], [29925, 29925, 29954, 29954, 30135], [30137, 30137, 30159, 30159, 30326], [30328, 30328, 30341, 30341, 30380], [30382, 30382, 30412, 30412, 30441], [30443, 30443, 30476, 30476, 30533], [30535, 30535, 30561, 30561, 30611], [30613, 30613, 30634, 30634, 30699], [30701, 30701, 30725, 30725, 30808], [30810, 30810, 30825, 30825, 30866], [30868, 30868, 30884, 30884, 30922], [30924, 30924, 30942, 30942, 30999], [31001, 31001, 31031, 31031, 31401], [31403, 31403, 31461, 31461, 31499], [31501, 31501, 31530, 31530, 31566], [31568, 31568, 31616, 31616, 31647], [31649, 31649, 31683, 31683, 31742], [31744, 31744, 31821, 31821, 31986], [31988, 31988, 32065, 32065, 32145], [32147, 32147, 32223, 32223, 32339], [32341, 32341, 32417, 32417, 32495], [32497, 32497, 32535, 32535, 32569], [32571, 32571, 32593, 32593, 32639], [32641, 32641, 32668, 32668, 32712], [32714, 32714, 32763, 32763, 33024], [33026, 33026, 33099, 33099, 33153], [33155, 33155, 33187, 33187, 33223], [33225, 33225, 33281, 33281, 33337], [33339, 33339, 33369, 33369, 33462], [33463, 33463, 33503, 33503, 33526], [33528, 33574, 33613, 33613, 34769], [34771, 34771, 34801, 34801, 34903], [34905, 34905, 34957, 34957, 34997], [34999, 34999, 35021, 35021, 35072], [35074, 35074, 35106, 35106, 35128], [35130, 35145, 35167, 35167, 35459], [35461, 35461, 35493, 35493, 35515], [35517, 35517, 35536, 35536, 35568], [35617, 35680, 35722, 35722, 35788], [35790, 35860, 35911, 35911, 36263], [36265, 36299, 36345, 36345, 36857], [36859, 36928, 36974, 36974, 37480], [37482, 37482, 37515, 37515, 37731], [37733, 37733, 37792, 37792, 37837], [37839, 37839, 37882, 37882, 37943], [37945, 37945, 37987, 37987, 38029], [38031, 38091, 38148, 38148, 38347]]}
{"id": "XtsyWX", "name": "Acid Drop - 269 chars", "author": "GregRostami", "description": "Here's a modification of gPlatl's beautiful Fractaloscopic shader:\n[url]https://www.shadertoy.com/view/4lXyWS[/url]\nI tried to animate just about everything ... enjoy in Fullscreen.", "tags": ["2d", "twotweets", "acid", "short", "koleidoscope"], "likes": 9, "viewed": 839, "date": "1506663642", "time_retrieved": "2024-06-20T19:02:17.205748", "image_code": "void mainImage(out vec4 O,vec2 U)\n{\n\tfloat t = iTime*.1, m = .4*sin(t*.2);\n    vec2 R = iResolution.xy;\n    O = vec4 ( dot( R = (2.+1.4*cos(t))*(U+U-R)/R.y,R ) *\n             sin( abs (mod (.2*t+atan (R.y,R.x), 2.094) - 1.05) + t + vec2(1.6,0) ), m,0);\n    for (int i=0; i++< 45;)\n        O.xzyw = vec4(1.3,.999,.678,0) * abs( abs(O)/dot(O,O) - vec4(1,1.02,.4*m,0) );\n}\n", "image_inputs": [{"id": "XslXDs", "previewfilepath": "https://soundcloud.com/simone-peltier/the-beatles-lucy-in-the-sky-with-diamonds", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/simone-peltier/the-beatles-lucy-in-the-sky-with-diamonds", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtsyWX.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 35, 35, 369]]}
{"id": "XtXcD2", "name": "SonicTheHedgehog", "author": "albertelwin", "description": "Sonic the Hedgehog shader.", "tags": ["sonic", "megadrive"], "likes": 11, "viewed": 195, "date": "1506464179", "time_retrieved": "2024-06-20T19:02:17.211832", "image_code": "\n#define PIXEL_ROW if(y < 1. && y >= 0.) {\n#define END_ROW } y -= 1.;\n\n#define P(R, G, B, A) if(x < 1. && x >= 0.) { color = vec4(R / 255.0, G / 255.0, B / 255.0, A); } x -= 1.;\n\n#define CL P(0., 0., 0., 0.)\n\n#define B1 P(96., 96., 224., 1.)\n#define B2 P(64., 64., 224., 1.)\n#define B3 P(32., 64., 192., 1.)\n#define B4 P(32., 32., 160., 1.)\n\n#define LB P(224., 160., 128., 1.)\n#define DB P(160., 96., 64., 1.)\n\n#define R1 P(224., 0., 0., 1.)\n#define R2 P(128., 0., 0., 1.)\n\n#define WH P(255., 255., 255., 1.)\n#define BL P(0., 0., 0., 1.)\n\n#define G0 P(224., 224., 224., 1.)\n#define G1 P(160., 160., 160., 1.)\n#define G2 P(128., 128., 128., 1.)\n#define G3 P(64., 64., 64., 1.)\n\n#define SONIC_WIDTH 27.\n#define SONIC_HEIGHT 40.\n\nvec4 draw_sonic(float x, float y) {\n    vec4 color = vec4(0.);\n    \n    y = SONIC_HEIGHT - y;\n    \n    PIXEL_ROW CL CL CL CL CL CL CL CL CL CL CL CL CL CL CL CL CL CL CL CL CL CL CL CL CL CL CL END_ROW\n    PIXEL_ROW CL CL CL CL CL CL CL CL B3 B3 B3 B3 B3 CL CL CL CL CL CL CL CL CL CL CL CL CL CL END_ROW\n    PIXEL_ROW CL CL CL CL CL B3 B3 B3 B3 B3 B3 B3 B2 B2 B3 B3 B3 CL CL CL CL CL CL CL CL CL CL END_ROW\n    PIXEL_ROW CL CL B4 B4 B4 B4 B3 B3 B3 B3 B3 B4 B4 B2 B2 B2 B3 B3 CL CL CL CL B4 CL CL CL CL END_ROW\n    PIXEL_ROW CL CL CL CL B4 B4 B4 B4 B4 B3 B3 B4 LB B4 B2 B2 B2 B2 B3 B3 CL B4 B4 CL CL CL CL END_ROW\n    PIXEL_ROW CL CL CL CL CL CL CL B4 B4 B4 B4 DB LB LB B4 B2 B1 B2 B2 B2 B3 B4 B4 CL CL CL CL END_ROW\n    PIXEL_ROW CL CL CL CL CL CL CL CL B4 B3 B4 DB LB LB LB B3 B1 B1 B1 B2 B2 B3 B4 CL CL CL CL END_ROW\n    PIXEL_ROW CL CL CL CL CL CL CL B3 B3 B3 B4 DB DB B2 B2 B1 B1 B1 B1 B1 B2 B2 B3 CL CL CL CL END_ROW\n    PIXEL_ROW CL CL CL CL CL B3 B3 B3 B4 B3 B3 B3 B2 B2 B1 B2 B2 B2 B2 B1 B2 B2 B3 CL CL CL CL END_ROW\n    PIXEL_ROW CL CL CL B3 B3 B3 B3 B4 B4 B3 B2 B1 B1 B2 B2 B2 G1 G1 B1 B2 B1 B2 B2 B3 CL CL CL END_ROW\n    PIXEL_ROW CL CL B3 B3 B3 B3 B3 B4 B4 B3 B1 WH B1 B2 B2 G1 WH WH G1 B1 B2 B2 B2 B1 CL CL CL END_ROW\n    PIXEL_ROW CL B3 B3 B4 B4 B4 B3 B4 B4 B3 B2 B1 B1 B2 B2 WH WH WH WH BL B3 B2 B2 BL CL CL CL END_ROW\n    PIXEL_ROW B4 B4 B4 B4 B4 B4 B4 B4 B4 B4 B3 B2 B2 B2 B2 WH WH WH WH BL BL B3 B2 BL CL CL CL END_ROW\n    PIXEL_ROW CL CL CL CL CL B4 B4 B4 B4 B4 B3 B3 B3 B3 B2 WH WH WH WH BL BL B1 BL BL CL CL CL END_ROW\n    PIXEL_ROW CL CL CL CL CL CL CL B4 B4 B4 B4 B3 B3 B3 B3 B1 WH WH WH BL BL WH BL G2 CL CL CL END_ROW\n    PIXEL_ROW CL CL CL CL CL CL B3 B3 B4 B4 B4 B4 B3 DB WH WH B1 WH WH WH WH DB G2 BL G2 CL CL END_ROW\n    PIXEL_ROW CL CL CL CL B3 B3 B3 B3 B4 B4 B4 B4 DB LB LB LB WH WH WH WH LB LB BL BL BL CL CL END_ROW\n    PIXEL_ROW CL CL CL B3 B3 B3 B4 B4 B4 B4 B4 B4 DB LB LB LB LB LB LB LB LB LB CL CL CL CL CL END_ROW\n    PIXEL_ROW CL CL CL B3 B4 B4 B4 B4 B4 B4 B4 B4 B4 DB LB LB LB LB LB DB DB R2 CL CL CL CL CL END_ROW\n    PIXEL_ROW CL CL B3 B4 B4 B4 B4 B4 B4 B4 B4 BL B4 B4 DB DB DB DB DB R2 R2 CL CL CL CL CL CL END_ROW\n    PIXEL_ROW CL CL CL CL CL CL CL B4 B4 B4 B4 B4 BL BL B4 B4 B3 R2 R2 R2 CL CL CL CL CL CL CL END_ROW\n    PIXEL_ROW CL CL CL CL CL CL CL CL CL B4 B4 LB LB LB LB B3 DB LB LB DB R2 CL CL CL CL CL CL END_ROW\n    PIXEL_ROW CL CL CL CL CL CL CL CL B4 LB LB DB DB DB B3 DB LB LB LB LB DB CL CL CL CL CL CL END_ROW\n    PIXEL_ROW CL CL CL CL CL CL CL B4 LB DB DB B4 B4 B4 B3 DB LB LB LB LB DB CL CL CL CL CL CL END_ROW\n    PIXEL_ROW CL CL CL CL CL CL CL B4 LB DB B4 B4 B4 B4 B3 DB DB LB LB DB R2 CL CL CL CL CL CL END_ROW\n    PIXEL_ROW CL CL CL CL CL CL B4 B4 DB WH WH G2 WH G2 B3 B3 DB DB DB R2 BL G3 CL CL CL CL CL END_ROW\n    PIXEL_ROW CL CL CL CL CL CL B4 B4 R2 WH G2 WH WH WH B4 B3 B3 B3 B3 B4 G3 G2 G2 CL CL CL CL END_ROW\n    PIXEL_ROW CL CL CL CL CL CL B4 B4 B4 G2 G3 G2 G2 G2 B4 B3 B4 BL B4 BL G3 G2 G2 CL CL CL CL END_ROW\n    PIXEL_ROW CL CL CL CL CL CL B4 CL CL CL G2 G2 G2 G2 B2 B3 CL B4 B4 BL BL G3 CL CL CL CL CL END_ROW\n    PIXEL_ROW CL CL CL CL CL CL CL CL CL CL BL G2 G2 B4 B2 CL CL B4 B4 CL CL CL CL CL CL CL CL END_ROW\n    PIXEL_ROW CL CL CL CL CL CL CL CL CL CL CL CL CL B4 B2 CL CL B4 B4 CL CL CL CL CL CL CL CL END_ROW\n    PIXEL_ROW CL CL CL CL CL CL CL CL CL CL CL CL B4 B2 CL CL CL B4 B4 CL CL CL CL CL CL CL CL END_ROW\n    PIXEL_ROW CL CL CL CL CL CL CL CL CL CL CL CL B4 B2 CL CL CL B4 B4 CL CL CL CL CL CL CL CL END_ROW\n    PIXEL_ROW CL CL CL CL CL CL CL CL CL CL G2 G1 G0 G0 G0 CL G3 G2 G2 G2 CL CL CL CL CL CL CL END_ROW\n    PIXEL_ROW CL CL CL CL CL CL CL CL CL CL G2 G2 G2 G1 G1 CL G3 G3 G3 G2 G2 CL CL CL CL CL CL END_ROW\n    PIXEL_ROW CL CL CL CL CL CL CL CL CL BL R2 G2 G2 R2 R2 G0 G2 G3 G3 G2 R2 CL CL CL CL CL CL END_ROW\n    PIXEL_ROW CL CL CL CL CL CL CL CL CL BL R2 R2 R2 G1 G0 G2 G2 R1 BL BL G3 G2 G2 CL CL CL CL END_ROW\n    PIXEL_ROW CL CL CL CL CL CL CL CL BL R2 R2 R2 G2 G1 R1 R1 R1 R1 R1 R1 BL BL BL R2 R2 CL CL END_ROW\n    PIXEL_ROW CL CL CL CL CL CL CL CL BL R2 R2 R2 G2 R1 R1 R1 R1 R1 R1 R1 R1 R1 R1 BL BL R2 R2 END_ROW\n    PIXEL_ROW CL CL CL CL CL CL CL CL BL BL BL BL BL BL BL BL BL BL BL BL BL BL BL BL BL BL BL END_ROW\n\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float scale = 0.25;\n    float px = mod(fragCoord.x * scale + iTime * 15.0, SONIC_WIDTH);\n    float py = mod(fragCoord.y * scale + iTime * 15.0, SONIC_HEIGHT);\n    vec4 sonic = draw_sonic(px, py);\n    \n    vec3 color = mix(vec3(0.0, 0.5, 1.0), sonic.rgb, sonic.a);\n    if(fract(fragCoord.y * scale * 0.5) < 0.5) {\n        color *= 0.95;\n    }\n\n    fragColor.rgb = color;\n    fragColor.a = 1.;\n}", "image_inputs": [{"id": "4dXGR8", "previewfilepath": "/media/previz/buffer00.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/previz/buffer00.png", "ctype": "buffer"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtXcD2.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[727, 727, 762, 762, 4966], [4968, 4968, 5023, 5023, 5421]]}
{"id": "XtXcRB", "name": "gyroscope balls", "author": "balkhan", "description": "circular thingy", "tags": ["raymarching"], "likes": 14, "viewed": 232, "date": "1506620618", "time_retrieved": "2024-06-20T19:02:17.219511", "image_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\nvec2\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvoid\trotate(inout vec2 v, float angle);\nvec3\tcalcNormal( in vec3 pos, float e, vec3 dir);\nfloat\tloop_circle(vec3 p);\nfloat\tcircle(vec3 p, float phase);\nfloat\tsdTorus( vec3 p, vec2 t, float phase );\nfloat\tmylength(vec2 p);\nfloat\tnrand( vec2 n );\n\nfloat \tt;\t\t\t// time\nvec3\tret_col;\t// torus color\nvec3\th; \t\t\t// light amount\n\n#define I_MAX\t\t40.\n#define E\t\t\t0.0001\n#define FAR\t\t\t8.5\n#define MAXI\t\t7.\t\t// num torus\n#define PI\t\t\t3.14\n\nvoid mainImage(out vec4 c_out, in vec2 f)\n{\n    t  = iTime*.125;\n    vec3\tcol = vec3(0., 0., 0.);\n\tvec2 R = iResolution.xy,\n          uv  = vec2(f-R/2.) / R.y;\n\tvec3\tdir = camera(uv);\n    vec3\tpos = vec3(.0, .0, 7.0);\n\n    pos.z = 4.5+3.*sin(t*3.);\n\n    #ifdef\tLOOKING_AROUND\n    dir.zy *= mat2(cos(t*.5),sin(t*.5),-sin(t*.5),cos(t*.5) );\n    dir.xy *= mat2(cos(1.57+t*.5),sin(1.57+t*.5),-sin(1.57+t*.5),cos(1.57+t*.5) );\n    #endif\n    \n    vec2\tinter = (march(pos, dir));\n    if (inter.y <= FAR)\n        col.xyz = ret_col*(1.-inter.x*.025);\n    else\n        col *= 0.;\n    col += h*.005125;\n    c_out =  vec4(col,1.0);\n}\n\nfloat\tscene(vec3 p)\n{  \n    float\tmind = 1e5;\n\n    vec2\trot = vec2( cos(t), sin(t) );\n\n\tmind = loop_circle(p);\n\t\n    return (mind);\n}\n\n#define VL(p) (1./((length(p)-.0)*(length(p)-.0) ) )\n\nvec2\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0, 0.0);\n    vec3\tp = vec3(0.0, 0.0, 0.0);\n    vec2\ts = vec2(0.0, 0.0);\n\n    dist.y = dist.x = length(p)-1.5;\n    if (dist.x < E )\n    {\n        dist.y-=dist.x;\n\t    for (float i = -1.; i < I_MAX; ++i)\n\t    {\n\t    \tp = pos + dir * dist.y;\n\t        dist.x = scene(p);\n\t        if (dist.x < length(p)-1.75)\n\t            dist.x = length(p)-1.75;\n\t        dist.y += dist.x;\n\t        if (dist.x < E || dist.y > FAR)\n            {\n                break;\n            }\n\t        s.x++;\n\t    }\n    }\n    s.y = dist.y;\n    return (s);\n}\n\nfloat nrand( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nfloat\tmylength(vec2 p)\n{\n\tfloat\tret;\n    \n    p = p*p*p*p;\n    \n    ret = (p.x+p.y);\n    ret = pow(ret, 1./4.);\n    \n    return ret;\n}\n\nfloat sdTorus( vec3 p, vec2 t, float phase )\n{\n\tvec2 q = vec2(length(p.xy)-t.x,p.z);\n    float\tvar = (sin(iTime*1.+phase))*3.14;\n    vec3\tcol;\n    col = vec3(\n        abs(sin(nrand(vec2(7.*phase*10., 7.*phase/3.14))*6.14+iTime*.125+0.00))\n        ,\n        abs(sin(nrand(vec2(7.*phase*10., 7.*phase/3.14))*6.14+iTime*.125+1.04))\n        ,\n        abs(sin(nrand(vec2(7.*phase*10., 7.*phase/3.14))*6.14+iTime*.125+2.08))\n    );\n    h += VL(p-.75*vec3(cos(var), sin(var), 0.)) * .125 * col;\n    h += VL(p-.75*vec3(cos(3.14), sin(3.14), 0.)) * .125 * col;\n    return min(min(\n        (mylength(q)-t.y)\n        +\n        1e5*step( var , (atan(p.y,p.x))+.0 )\n        ,\n        length(p-.75*vec3(cos(var), sin(var), 0.))-.125\n        )\n        ,\n        length(p-.75*vec3(cos(3.14), sin(3.14), 0.))-.125\n        )\n        ;\n}\n\nfloat\tcircle(vec3 p, float phase)\n{\n\tfloat\tret;\n    \n    ret = sdTorus(p, vec2(.75, .0625), phase );\n\n    return ret;\n}\n\nfloat\tloop_circle(vec3 p)\n{\n\tfloat\tret, old_ret;\n    \n    ret_col = vec3(0.);\n    ret = 1e5;old_ret = 1e5;p*=1.;\n    vec3 op = p;\n    \n    for(float i = 0.; i < MAXI; i++)\n    {\n        p = op;\n        rotate(p.xz, i/2.+iTime*2.);\n        rotate(p.zy, i/3.+iTime*2.);\n        rotate(p.yx, i/1.+iTime*2.);\n        old_ret = ret;\n    \tret = min(old_ret,\n        \t\t\tcircle(p, i/(7.))\n        \t\t\t);\n       if (ret != old_ret && ret > 0.)\n            ret_col = vec3(abs(sin(nrand(vec2(i*10., i/3.14))*6.14+t+0.00)),\n                           abs(sin(nrand(vec2(i*10., i/3.14))*6.14+t+1.04)),\n                           abs(sin(nrand(vec2(i*10., i/3.14))*6.14+t+2.08)));\n\n        op*=.9;\n    }\n    ret = min(ret, length(p)-.1);\n    return\tret;\n}\n\n// Utilities\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec2\trot(vec2 p, vec2 ang)\n{\n\tfloat\tc = cos(ang.x);\n    float\ts = sin(ang.y);\n    mat2\tm = mat2(c, -s, s, c);\n    \n    return (p * m);\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float\t\tfov = 1.;\n\tvec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n\nvec3 calcNormal( in vec3 pos, float e, vec3 dir)\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\n    return normalize(vec3(\n           march(pos+eps.xyy, dir).y - march(pos-eps.xyy, dir).y,\n           march(pos+eps.yxy, dir).y - march(pos-eps.yxy, dir).y,\n           march(pos+eps.yyx, dir).y - march(pos-eps.yyx, dir).y ));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtXcRB.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[427, 598, 641, 641, 1220], [1222, 1222, 1243, 1243, 1355], [1411, 1411, 1443, 1443, 1993], [1995, 1995, 2018, 2018, 2086], [2088, 2088, 2112, 2112, 2222], [2224, 2224, 2270, 2270, 3042], [3044, 3044, 3079, 3079, 3163], [3165, 3165, 3192, 3192, 3905], [3907, 3921, 3961, 3961, 4036], [4038, 4038, 4066, 4066, 4174], [4176, 4176, 4198, 4198, 4404], [4406, 4406, 4456, 4456, 4719]]}
{"id": "XtXcW4", "name": "Scanline with AA", "author": "andrut", "description": "Functional version of scanline algorithm with builtin antialiasing", "tags": ["antialiasing", "scanline", "algorithm"], "likes": 0, "viewed": 110, "date": "1504739671", "time_retrieved": "2024-06-20T19:02:17.539006", "image_code": "// Based on slide on scanline algorithm in NILE presented here: \n//  \"Programming and Scaling\" (2011) https://www.youtube.com/watch?v=YyIQKBzIuBY&t=49m46s \n// It's not very fast but it's super clever and compact; may be useful\n\nfloat ro(vec2 pos, vec2 P, vec2 Q) {\n  return (Q.y - P.y)*(pos.x + 1.0 - (Q.x + P.x)/2.0);\n}\n\nvec2 gamma(vec2 pos, vec2 P) {\n  return vec2(\n    min(pos.x + 1.0, max(pos.x, P.x)),\n    min(pos.y + 1.0, max(pos.y, P.y))\n  );\n}\n\nvec2 omega(vec2 pos, float m, vec2 P) {  \n  return vec2(\n    1./m*(gamma(pos, P).y - P.y) + P.x,\n       m*(gamma(pos, P).x - P.x) + P.y\n  );\n}\n\nfloat coverage(vec2 pos, vec2 A, vec2 B) {\n  float m =(A.y - B.y) / (A.x - B.x); \n  return ro(pos, gamma(pos, A), gamma(pos, omega(pos, m, A)))\n       + ro(pos, gamma(pos, omega(pos, m, A)),gamma(pos, omega(pos, m, B)))\n       + ro(pos, gamma(pos, omega(pos, m, B)), gamma(pos, B));\n}\n\nconst float PI = 3.141592653589793238462643383;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // prepare the shape:\n    const int ptsN = 32;\n    vec2 pts[ptsN];\n    for (int i = 0; i < ptsN; ++i) {\n        float a = float(i*2)*PI/float(ptsN) + iTime/3.0 + float(i&1)*sin(iTime/2.0)*4.0;\n        float R = float(4+4*(i&1))*iResolution.y/(3.0*5.0);\n        pts[i] = iResolution.xy/2.0 + R*vec2(cos(a), sin(a));\n    }\n    \n    // scanline algorithm:\n    float sum = 0.0;\n    for (int i = 0, j = ptsN - 1; i < ptsN; j = i++) {\n      sum += coverage(fragCoord.xy, pts[i], pts[j]);\n    }\n    float v = min(1.0, abs(sum));\n\t\n    fragColor = vec4(v*fragCoord.xy/iResolution.xy, (1.0-v)*fragCoord.y*0.5/iResolution.y, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtXcW4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 228, 264, 264, 320], [322, 322, 352, 352, 451], [453, 453, 492, 492, 595], [597, 597, 639, 639, 881], [932, 932, 989, 1015, 1616]]}
{"id": "XtXyDM", "name": "Workshop with Albert Elwin", "author": "carrotcake", "description": "Workshop with Albert Elwin, I fiddled a bit with the code and created this tornado effect (accidentally)", "tags": ["raymarching", "distance", "fields", "tornado", "albertelwin"], "likes": 2, "viewed": 104, "date": "1504967862", "time_retrieved": "2024-06-20T19:02:17.539006", "image_code": "    \nconst vec3 BG_COLOR = vec3(0.0, 0.0, 1.0);\nconst vec3 MG_COLOR = vec3(1.0, 1.0, 0.5);\nconst vec3 FG_COLOR = vec3(0.0, 1.0, 0.75);\n\nfloat sd_plane(vec3 p, float h);\nfloat sd_sphere(vec3 p, float r);\nfloat sd_box(vec3 p, float x, float y, float z);\nfloat sd_torus(vec3 p, float r, float h);\nfloat sd_cylinder(vec3 p, float r, float h);\n\nvec3 twist(vec3 p, float r, float a);\nvec3 repeat(vec3 p, float s);\n\nfloat smin(float a, float b, float k);\nfloat noise(vec3 p);\n\nfloat map(vec3 p) {\n    float d = 1000.0;\n\tp = twist(p, 1.5, 1.0);\n    d = smin(d, sd_plane(p, -1.0), 0.0);\n    //d = smin(d, sd_sphere(p, 1.5), sin(iTime));    \n    //d = smin(d, sd_sphere(p, 1.5), 0.75);    \n    //d = smin(d, sd_sphere(p - vec3(tan(iTime), tan(iTime), sin(iTime)), 1.5), 0.5);\n    \n    //vec3 q = repeat(p - vec3(0.0, -1.0, 0.0), 1.0);\n    \n\tvec3 q = repeat(p - vec3(tan(iTime), tan(iTime), sin(iTime)), 1.0);\n    d = smin(d, sd_sphere(q, 0.5), 0.0);\n                                  \n    d = smin(d, sd_sphere(p - vec3(tan(iTime), tan(iTime), sin(iTime)), 1.5), 0.5);\n    \n    d = d + noise((p + vec3(sin(iTime), tan(iTime), cos(iTime))) * 8.0) * 0.25;\n    \n    //d = smin(d, sd_torus(p - vec3(0.0, -0.5, 0.0), 2.0, 0.25), 0.0);\n    \n#if 0\n    d = smin(d, sd_plane(p, -0.75), 0.0);\n    \n    d = smin(d, sd_sphere(p - vec3(0.0, -0.25, 0.0), 1.0 + sin(iTime) * 0.0625), 0.25);\n    d = smin(d, sd_torus(p - vec3(0.0,-0.60, 0.0), 2.0, 0.1 + sin(iTime) * 0.025), 0.5);\n    \n\td += noise((p + vec3(0.0, iTime * 0.1, 0.0)) * 4.0) * 0.1;\n\n    float height = sin(4.25 - abs(p.x * 0.5)) * 1.5 * max(0.0, p.z + 1.0);\n    d = smin(d, sd_cylinder(repeat(p, 1.0) - vec3(0.0, -1.5, 0.0), 0.25, height), 0.5);\n#endif\n    \n    return d;  \n}\n\nfloat sd_plane(vec3 p, float h) {\n\treturn p.y - h;   \n}\n\nfloat sd_sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sd_box(vec3 p, float x, float y, float z) {\n\tvec3 d = abs(p) - vec3(x, y, z);\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sd_torus(vec3 p, float r, float h) {\n\tvec2 q = vec2(length(p.xz) - r, p.y);\n\treturn length(q) - h;\n}\n\nfloat sd_cylinder(vec3 p, float r, float h) {\n\tvec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nvec3 repeat(vec3 p, float s) {\n    vec3 q = p;\n    q.x = mod(q.x, s) - 0.5 * s;\n    q.z = mod(q.z, s) - 0.5 * s;\n    return q;\n}\n\nvec3 twist(vec3 p, float r, float a) {\n\tfloat c = cos(r * p.y + a);\n\tfloat s = sin(r * p.y + a);\n\treturn vec3(p.x * c + p.z * s, p.y, p.x * -s + p.z * c);\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n\treturn mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat noise(vec3 p) {\n\tvec3 s = vec3(7.0, 157.0, 113.0);\n\tvec3 ip = floor(p);\n\tp -= ip;\n\tvec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n\tp = p * p * (3.0 - 2.0 * p);\n\th = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z) * 2.0 - 1.0;\n}\n\nvec3 compute_normal(vec3 p) {\n\tvec3 eps = vec3(0.0005, 0.0, 0.0);\n    vec3 n;\n    n.x = map(p + eps.xyy) - map(p - eps.xyy);\n    n.y = map(p + eps.yxy) - map(p - eps.yxy);\n    n.z = map(p + eps.yyx) - map(p - eps.yyx);\n    n = normalize(n);\n    return n;\n}\n\nfloat compute_ao(vec3 p, vec3 n) {\n\tfloat occ = 0.0;\n\tfloat sca = 1.0;\n\tfor(int i = 0; i < 5; i++) {\n\t\tfloat hr = 0.01 + 0.12 * float(i) / 4.0;\n\t\tfloat d = map(p + hr * n);\n\t\tocc += -(d - hr) * sca;\n\t\tsca *= 0.95;\n\t}\n\treturn clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {    \n    vec3 ro = vec3(0.0, 0.0, -3.5);\n    vec3 rd;\n    rd.xy = (fragCoord.xy / iResolution.y) * 2.0 - vec2(iResolution.x / iResolution.y, 1.0);\n    rd.z = 1.0;\n    rd = normalize(rd);\n    \n    vec3 color = BG_COLOR;\n\t//color.x = sin(iTime);\n    //color.y = cos(iTime);\n    vec3 color2 = BG_COLOR;\n    color2.x = sin(iTime);\n    color2.y = cos(iTime);\n    \n    float t = 0.0;\n    float t_max = 7.5;\n    for(int i = 0; i < 256; i++) {\n        float d = map(ro + t * rd);\n        t += d * 0.6;\n        if(d < 0.002) {\n            vec3 p = ro + t * rd;\n            vec3 n = compute_normal(p);\n            vec3 l = normalize(vec3(0.25, 1.0, -0.5));\n            float dot_nl = clamp(dot(n, l), 0.0, 1.0);\n            float ao = compute_ao(p, n);\n            float fog = clamp(1.0 - t / t_max, 0.0, 1.0);\n            float light = mix(dot_nl, ao, 0.5);\n            \n            color = mix(MG_COLOR, color2, light);\n            color = mix(BG_COLOR, color, fog);\n            break;\n        }\n        else if(t > t_max) {\n            break;\n        }\n    }\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtXyDM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[470, 470, 489, 489, 1713], [1715, 1715, 1748, 1748, 1770], [1772, 1772, 1806, 1806, 1834], [1836, 1836, 1885, 1885, 1986], [1988, 1988, 2030, 2030, 2094], [2096, 2096, 2141, 2141, 2251], [2253, 2253, 2283, 2283, 2381], [2383, 2383, 2421, 2421, 2539], [2541, 2541, 2580, 2580, 2677], [2679, 2679, 2700, 2700, 2996], [2998, 2998, 3027, 3027, 3254], [3256, 3256, 3290, 3290, 3516], [3518, 3518, 3573, 3573, 4665]]}
